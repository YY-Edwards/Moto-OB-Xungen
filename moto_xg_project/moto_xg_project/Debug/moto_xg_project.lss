
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a950  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ca00  8000ca00  0000ce00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000017a4  8000cc00  8000cc00  0000d000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e3a4  8000e3a4  0000e7a4  2**0
                  ALLOC
  6 .data         00000a38  00000004  8000e3a8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000ede0  0000f23c  2**0
                  ALLOC
  8 .bss          00005958  00000a40  8000ede0  0000f240  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000f23c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000011c8  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 000026cc  00000000  00000000  00010438  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00029095  00000000  00000000  00012b04  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006b8e  00000000  00000000  0003bb99  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00015855  00000000  00000000  00042727  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002ef0  00000000  00000000  00057f7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00007423  00000000  00000000  0005ae6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d0b7  00000000  00000000  0006228f  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 01544087  00000000  00000000  0006f346  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 20 .debug_ranges 000012a0  00000000  00000000  015b33d0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c6 ac 	sub	pc,pc,-14676

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 80       	ld.ub	r0,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
														
		
};

void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
8000203e:	48 cb       	lddpc	r11,8000206c <app_init+0x30>
80002040:	48 cc       	lddpc	r12,80002070 <app_init+0x34>
80002042:	f0 1f 00 0d 	mcall	80002074 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	80 00       	ld.sh	r0,r0[0x0]
8000206e:	20 90       	sub	r0,9
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	28 60       	sub	r0,-122
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	2f 24       	sub	r4,-14
80002078:	00 00       	add	r0,r0
8000207a:	00 04       	add	r4,r0
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	44 a4       	lddsp	r4,sp[0x128]
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	cc 00       	breq	80002002 <program_start+0x2>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 b8       	sub	r8,123
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	68 4c       	ld.w	r12,r4[0x10]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	cc 08       	rjmp	8000221e <ButtonConfig_brdcst_func+0x9e>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6c 10       	ld.w	r0,r6[0x4]

800020a4 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a4:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a6:	48 3c       	lddpc	r12,800020b0 <FD_brdcst_func+0xc>
800020a8:	f0 1f 00 03 	mcall	800020b4 <FD_brdcst_func+0x10>
	
}
800020ac:	d8 02       	popm	pc
800020ae:	00 00       	add	r0,r0
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	cc 0c       	rcall	80002232 <ButtonConfig_brdcst_func+0xb2>
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	6c 10       	ld.w	r0,r6[0x4]

800020b8 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ba:	48 3c       	lddpc	r12,800020c4 <FD_reply_func+0xc>
800020bc:	f0 1f 00 03 	mcall	800020c8 <FD_reply_func+0x10>
	
	
}
800020c0:	d8 02       	popm	pc
800020c2:	00 00       	add	r0,r0
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	cc 2c       	rcall	8000224a <ButtonConfig_brdcst_func+0xca>
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	6c 10       	ld.w	r0,r6[0x4]

800020cc <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020cc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ce:	48 3c       	lddpc	r12,800020d8 <FD_request_func+0xc>
800020d0:	f0 1f 00 03 	mcall	800020dc <FD_request_func+0x10>
	
	
}
800020d4:	d8 02       	popm	pc
800020d6:	00 00       	add	r0,r0
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	cc 48       	rjmp	80002262 <Phyuserinput_brdcst_func+0x6>
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	6c 10       	ld.w	r0,r6[0x4]

800020e0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e2:	48 3c       	lddpc	r12,800020ec <EnOB_brdcst_func+0xc>
800020e4:	f0 1f 00 03 	mcall	800020f0 <EnOB_brdcst_func+0x10>
}
800020e8:	d8 02       	popm	pc
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	cc 64       	brge	8000207a <app_init+0x3e>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	6c 10       	ld.w	r0,r6[0x4]

800020f4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f4:	eb cd 40 80 	pushm	r7,lr
800020f8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fa:	19 a9       	ld.ub	r9,r12[0x2]
800020fc:	30 08       	mov	r8,0
800020fe:	f0 09 18 00 	cp.b	r9,r8
80002102:	c1 91       	brne	80002134 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002104:	19 b8       	ld.ub	r8,r12[0x3]
80002106:	30 19       	mov	r9,1
80002108:	f2 08 18 00 	cp.b	r8,r9
8000210c:	c0 61       	brne	80002118 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210e:	49 0c       	lddpc	r12,8000214c <EnOB_reply_func+0x58>
80002110:	f0 1f 00 10 	mcall	80002150 <EnOB_reply_func+0x5c>
80002114:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002118:	58 08       	cp.w	r8,0
8000211a:	c0 61       	brne	80002126 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
8000211c:	48 ec       	lddpc	r12,80002154 <EnOB_reply_func+0x60>
8000211e:	f0 1f 00 0d 	mcall	80002150 <EnOB_reply_func+0x5c>
80002122:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002126:	1a d8       	st.w	--sp,r8
80002128:	48 cc       	lddpc	r12,80002158 <EnOB_reply_func+0x64>
8000212a:	f0 1f 00 0a 	mcall	80002150 <EnOB_reply_func+0x5c>
8000212e:	2f fd       	sub	sp,-4
80002130:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002134:	48 ac       	lddpc	r12,8000215c <EnOB_reply_func+0x68>
80002136:	f0 1f 00 07 	mcall	80002150 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213a:	0f a8       	ld.ub	r8,r7[0x2]
8000213c:	1a d8       	st.w	--sp,r8
8000213e:	48 9c       	lddpc	r12,80002160 <EnOB_reply_func+0x6c>
80002140:	f0 1f 00 04 	mcall	80002150 <EnOB_reply_func+0x5c>
80002144:	2f fd       	sub	sp,-4
80002146:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214a:	00 00       	add	r0,r0
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	cc 7c       	rcall	800022dc <ButtonConfig_reply_func+0x8>
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	6c 10       	ld.w	r0,r6[0x4]
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	cc 94       	brge	800020e8 <EnOB_brdcst_func+0x8>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	cc a8       	rjmp	800022ee <ButtonConfig_reply_func+0x1a>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	cc c0       	breq	800020f6 <EnOB_reply_func+0x2>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	cc dc       	rcall	800022fc <ButtonConfig_reply_func+0x28>

80002164 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002164:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 41       	brne	80002176 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 2c       	lddpc	r12,80002178 <SingleDetection_brdcst_func+0x14>
80002172:	f0 1f 00 03 	mcall	8000217c <SingleDetection_brdcst_func+0x18>
80002176:	d8 02       	popm	pc
80002178:	80 00       	ld.sh	r0,r0[0x0]
8000217a:	cc f4       	brge	80002118 <EnOB_reply_func+0x24>
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	6c 10       	ld.w	r0,r6[0x4]

80002180 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002180:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002182:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002186:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002188:	4a bc       	lddpc	r12,80002234 <ButtonConfig_brdcst_func+0xb4>
8000218a:	f0 1f 00 2c 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000218e:	0f 88       	ld.ub	r8,r7[0x0]
80002190:	1a d8       	st.w	--sp,r8
80002192:	4a bc       	lddpc	r12,8000223c <ButtonConfig_brdcst_func+0xbc>
80002194:	f0 1f 00 29 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002198:	1a d5       	st.w	--sp,r5
8000219a:	4a ac       	lddpc	r12,80002240 <ButtonConfig_brdcst_func+0xc0>
8000219c:	f0 1f 00 27 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021a0:	0f a8       	ld.ub	r8,r7[0x2]
800021a2:	1a d8       	st.w	--sp,r8
800021a4:	4a 8c       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xc4>
800021a6:	f0 1f 00 25 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021aa:	2f dd       	sub	sp,-12
800021ac:	58 05       	cp.w	r5,0
800021ae:	c4 10       	breq	80002230 <ButtonConfig_brdcst_func+0xb0>
800021b0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021b2:	4a 64       	lddpc	r4,80002248 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021b4:	4a 63       	lddpc	r3,8000224c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021b6:	4a 72       	lddpc	r2,80002250 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021b8:	4a 71       	lddpc	r1,80002254 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ba:	4a 80       	lddpc	r0,80002258 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021bc:	0f b9       	ld.ub	r9,r7[0x3]
800021be:	0f c8       	ld.ub	r8,r7[0x4]
800021c0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021c4:	1a d8       	st.w	--sp,r8
800021c6:	1a d6       	st.w	--sp,r6
800021c8:	08 9c       	mov	r12,r4
800021ca:	f0 1f 00 1c 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021ce:	0f d9       	ld.ub	r9,r7[0x5]
800021d0:	0f e8       	ld.ub	r8,r7[0x6]
800021d2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d6:	1a d8       	st.w	--sp,r8
800021d8:	1a d6       	st.w	--sp,r6
800021da:	06 9c       	mov	r12,r3
800021dc:	f0 1f 00 17 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e0:	0f f9       	ld.ub	r9,r7[0x7]
800021e2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021e6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ea:	1a d8       	st.w	--sp,r8
800021ec:	1a d6       	st.w	--sp,r6
800021ee:	04 9c       	mov	r12,r2
800021f0:	f0 1f 00 12 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021f4:	ef 39 00 09 	ld.ub	r9,r7[9]
800021f8:	ef 38 00 0a 	ld.ub	r8,r7[10]
800021fc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002200:	1a d8       	st.w	--sp,r8
80002202:	1a d6       	st.w	--sp,r6
80002204:	02 9c       	mov	r12,r1
80002206:	f0 1f 00 0d 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000220a:	2f 8d       	sub	sp,-32
8000220c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002210:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002214:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002218:	1a d8       	st.w	--sp,r8
8000221a:	1a d6       	st.w	--sp,r6
8000221c:	00 9c       	mov	r12,r0
8000221e:	f0 1f 00 07 	mcall	80002238 <ButtonConfig_brdcst_func+0xb8>
80002222:	2f f6       	sub	r6,-1
80002224:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002226:	2f ed       	sub	sp,-8
80002228:	ec 05 18 00 	cp.b	r5,r6
8000222c:	fe 9b ff c8 	brhi	800021bc <ButtonConfig_brdcst_func+0x3c>
80002230:	d8 32       	popm	r0-r7,pc
80002232:	00 00       	add	r0,r0
80002234:	80 00       	ld.sh	r0,r0[0x0]
80002236:	cd 08       	rjmp	800023d6 <DataSession_reply_func+0x3a>
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	6c 10       	ld.w	r0,r6[0x4]
8000223c:	80 00       	ld.sh	r0,r0[0x0]
8000223e:	cd 28       	rjmp	800023e2 <DataSession_reply_func+0x46>
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	cd 3c       	rcall	800023e8 <DataSession_reply_func+0x4c>
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	cd 54       	brge	800021f0 <ButtonConfig_brdcst_func+0x70>
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	cd 74       	brge	800021f8 <ButtonConfig_brdcst_func+0x78>
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	cd 9c       	rcall	80002400 <CallControl_brdcst_func+0xc>
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	cd c4       	brge	8000220a <ButtonConfig_brdcst_func+0x8a>
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	cd e8       	rjmp	80002412 <CallControl_brdcst_func+0x1e>
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	ce 10       	breq	8000221c <ButtonConfig_brdcst_func+0x9c>

8000225c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000225c:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002260:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
80002262:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002264:	19 c7       	ld.ub	r7,r12[0x4]
80002266:	19 d8       	ld.ub	r8,r12[0x5]
80002268:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
8000226c:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000226e:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002270:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002274:	49 0c       	lddpc	r12,800022b4 <Phyuserinput_brdcst_func+0x58>
80002276:	f0 1f 00 11 	mcall	800022b8 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000227a:	1a d6       	st.w	--sp,r6
8000227c:	49 0c       	lddpc	r12,800022bc <Phyuserinput_brdcst_func+0x60>
8000227e:	f0 1f 00 0f 	mcall	800022b8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002282:	1a d5       	st.w	--sp,r5
80002284:	48 fc       	lddpc	r12,800022c0 <Phyuserinput_brdcst_func+0x64>
80002286:	f0 1f 00 0d 	mcall	800022b8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000228a:	5c 77       	castu.h	r7
8000228c:	1a d7       	st.w	--sp,r7
8000228e:	48 ec       	lddpc	r12,800022c4 <Phyuserinput_brdcst_func+0x68>
80002290:	f0 1f 00 0a 	mcall	800022b8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002294:	1a d4       	st.w	--sp,r4
80002296:	48 dc       	lddpc	r12,800022c8 <Phyuserinput_brdcst_func+0x6c>
80002298:	f0 1f 00 08 	mcall	800022b8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
8000229c:	1a d3       	st.w	--sp,r3
8000229e:	48 cc       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x70>
800022a0:	f0 1f 00 06 	mcall	800022b8 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022a4:	1a d2       	st.w	--sp,r2
800022a6:	48 bc       	lddpc	r12,800022d0 <Phyuserinput_brdcst_func+0x74>
800022a8:	f0 1f 00 04 	mcall	800022b8 <Phyuserinput_brdcst_func+0x5c>
800022ac:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022ae:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022b2:	00 00       	add	r0,r0
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	ce 34       	brge	8000227c <Phyuserinput_brdcst_func+0x20>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	6c 10       	ld.w	r0,r6[0x4]
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	ce 58       	rjmp	80002488 <TransmitControl_reply_func+0x8>
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	ce 70       	breq	80002290 <Phyuserinput_brdcst_func+0x34>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	ce 84       	brge	80002296 <Phyuserinput_brdcst_func+0x3a>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	ce 98       	rjmp	8000249c <TransmitControl_reply_func+0x1c>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	ce ac       	rcall	800024a2 <TransmitControl_reply_func+0x22>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	ce cc       	rcall	800024aa <TransmitControl_reply_func+0x2a>

800022d4 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022d4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022d8:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022dc:	0f 89       	ld.ub	r9,r7[0x0]
800022de:	30 08       	mov	r8,0
800022e0:	f0 09 18 00 	cp.b	r9,r8
800022e4:	c0 c1       	brne	800022fc <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022e6:	48 9c       	lddpc	r12,80002308 <ButtonConfig_reply_func+0x34>
800022e8:	f0 1f 00 09 	mcall	8000230c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022ec:	0f 98       	ld.ub	r8,r7[0x1]
800022ee:	1a d8       	st.w	--sp,r8
800022f0:	48 8c       	lddpc	r12,80002310 <ButtonConfig_reply_func+0x3c>
800022f2:	f0 1f 00 07 	mcall	8000230c <ButtonConfig_reply_func+0x38>
800022f6:	2f fd       	sub	sp,-4
800022f8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022fc:	48 6c       	lddpc	r12,80002314 <ButtonConfig_reply_func+0x40>
800022fe:	f0 1f 00 04 	mcall	8000230c <ButtonConfig_reply_func+0x38>
80002302:	e3 cd 80 80 	ldm	sp++,r7,pc
80002306:	00 00       	add	r0,r0
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	ce ec       	rcall	800024e6 <AudioRoutingControl_reply_func+0x6>
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	6c 10       	ld.w	r0,r6[0x4]
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	cd 28       	rjmp	800024b6 <TransmitControl_reply_func+0x36>
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	cf 04       	brge	800022f6 <ButtonConfig_reply_func+0x22>

80002318 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002318:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000231a:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000231e:	0d 88       	ld.ub	r8,r6[0x0]
80002320:	32 49       	mov	r9,36
80002322:	f2 08 18 00 	cp.b	r8,r9
80002326:	c2 91       	brne	80002378 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002328:	49 7c       	lddpc	r12,80002384 <DataSession_brdcst_func+0x6c>
8000232a:	f0 1f 00 18 	mcall	80002388 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000232e:	0d a5       	ld.ub	r5,r6[0x2]
80002330:	0d b8       	ld.ub	r8,r6[0x3]
80002332:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002336:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002338:	0d 98       	ld.ub	r8,r6[0x1]
8000233a:	1a d8       	st.w	--sp,r8
8000233c:	49 4c       	lddpc	r12,8000238c <DataSession_brdcst_func+0x74>
8000233e:	f0 1f 00 13 	mcall	80002388 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002342:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002346:	1a d8       	st.w	--sp,r8
80002348:	49 2c       	lddpc	r12,80002390 <DataSession_brdcst_func+0x78>
8000234a:	f0 1f 00 10 	mcall	80002388 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
8000234e:	2f ed       	sub	sp,-8
80002350:	58 05       	cp.w	r5,0
80002352:	c1 80       	breq	80002382 <DataSession_brdcst_func+0x6a>
80002354:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002356:	49 04       	lddpc	r4,80002394 <DataSession_brdcst_func+0x7c>
80002358:	ec 07 00 08 	add	r8,r6,r7
8000235c:	11 c8       	ld.ub	r8,r8[0x4]
8000235e:	1a d8       	st.w	--sp,r8
80002360:	1a d7       	st.w	--sp,r7
80002362:	08 9c       	mov	r12,r4
80002364:	f0 1f 00 09 	mcall	80002388 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002368:	2f f7       	sub	r7,-1
8000236a:	5c 57       	castu.b	r7
8000236c:	2f ed       	sub	sp,-8
8000236e:	ee 05 19 00 	cp.h	r5,r7
80002372:	fe 9b ff f3 	brhi	80002358 <DataSession_brdcst_func+0x40>
80002376:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002378:	1a d8       	st.w	--sp,r8
8000237a:	48 8c       	lddpc	r12,80002398 <DataSession_brdcst_func+0x80>
8000237c:	f0 1f 00 03 	mcall	80002388 <DataSession_brdcst_func+0x70>
80002380:	2f fd       	sub	sp,-4
80002382:	d8 22       	popm	r4-r7,pc
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	cf 20       	breq	8000236a <DataSession_brdcst_func+0x52>
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	6c 10       	ld.w	r0,r6[0x4]
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	cf 34       	brge	80002374 <DataSession_brdcst_func+0x5c>
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	cf 4c       	rcall	8000257a <spk_brdcst_func+0x6>
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	cf 68       	rjmp	80002582 <spk_brdcst_func+0xe>
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	cf 80       	breq	8000238a <DataSession_brdcst_func+0x72>

8000239c <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000239c:	eb cd 40 80 	pushm	r7,lr
800023a0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023a2:	19 a8       	ld.ub	r8,r12[0x2]
800023a4:	58 08       	cp.w	r8,0
800023a6:	c0 61       	brne	800023b2 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023a8:	48 dc       	lddpc	r12,800023dc <DataSession_reply_func+0x40>
800023aa:	f0 1f 00 0e 	mcall	800023e0 <DataSession_reply_func+0x44>
800023ae:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023b2:	1a d8       	st.w	--sp,r8
800023b4:	48 cc       	lddpc	r12,800023e4 <DataSession_reply_func+0x48>
800023b6:	f0 1f 00 0b 	mcall	800023e0 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023ba:	48 cc       	lddpc	r12,800023e8 <DataSession_reply_func+0x4c>
800023bc:	f0 1f 00 09 	mcall	800023e0 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023c0:	0f b8       	ld.ub	r8,r7[0x3]
800023c2:	1a d8       	st.w	--sp,r8
800023c4:	48 ac       	lddpc	r12,800023ec <DataSession_reply_func+0x50>
800023c6:	f0 1f 00 07 	mcall	800023e0 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023ca:	0f c8       	ld.ub	r8,r7[0x4]
800023cc:	1a d8       	st.w	--sp,r8
800023ce:	48 9c       	lddpc	r12,800023f0 <DataSession_reply_func+0x54>
800023d0:	f0 1f 00 04 	mcall	800023e0 <DataSession_reply_func+0x44>
800023d4:	2f dd       	sub	sp,-12
800023d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800023da:	00 00       	add	r0,r0
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	cf 94       	brge	800023d0 <DataSession_reply_func+0x34>
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	6c 10       	ld.w	r0,r6[0x4]
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	cf a8       	rjmp	800025da <spk_reply_func+0x2e>
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	cf bc       	rcall	800025e0 <spk_reply_func+0x34>
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	cf d0       	breq	800023e8 <DataSession_reply_func+0x4c>
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	cf e0       	breq	800023ee <DataSession_reply_func+0x52>

800023f4 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023f4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023f8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800023fc:	0f 98       	ld.ub	r8,r7[0x1]
800023fe:	1a d8       	st.w	--sp,r8
80002400:	48 bc       	lddpc	r12,8000242c <CallControl_brdcst_func+0x38>
80002402:	f0 1f 00 0c 	mcall	80002430 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002406:	2f fd       	sub	sp,-4
80002408:	0f 99       	ld.ub	r9,r7[0x1]
8000240a:	30 38       	mov	r8,3
8000240c:	f0 09 18 00 	cp.b	r9,r8
80002410:	c0 41       	brne	80002418 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002412:	30 09       	mov	r9,0
80002414:	48 88       	lddpc	r8,80002434 <CallControl_brdcst_func+0x40>
80002416:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002418:	0f 99       	ld.ub	r9,r7[0x1]
8000241a:	30 48       	mov	r8,4
8000241c:	f0 09 18 00 	cp.b	r9,r8
80002420:	c0 41       	brne	80002428 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002422:	30 19       	mov	r9,1
80002424:	48 48       	lddpc	r8,80002434 <CallControl_brdcst_func+0x40>
80002426:	b0 89       	st.b	r8[0x0],r9
80002428:	e3 cd 80 80 	ldm	sp++,r7,pc
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	cf f0       	breq	8000242c <CallControl_brdcst_func+0x38>
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	6c 10       	ld.w	r0,r6[0x4]
80002434:	00 00       	add	r0,r0
80002436:	0a 4e       	or	lr,r5

80002438 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002438:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
8000243c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002440:	0f 99       	ld.ub	r9,r7[0x1]
80002442:	30 08       	mov	r8,0
80002444:	f0 09 18 00 	cp.b	r9,r8
80002448:	c0 71       	brne	80002456 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000244a:	48 ac       	lddpc	r12,80002470 <TransmitControl_brdcst_func+0x38>
8000244c:	f0 1f 00 0a 	mcall	80002474 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002450:	30 09       	mov	r9,0
80002452:	48 a8       	lddpc	r8,80002478 <TransmitControl_brdcst_func+0x40>
80002454:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
80002456:	0f 99       	ld.ub	r9,r7[0x1]
80002458:	30 18       	mov	r8,1
8000245a:	f0 09 18 00 	cp.b	r9,r8
8000245e:	c0 71       	brne	8000246c <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002460:	48 7c       	lddpc	r12,8000247c <TransmitControl_brdcst_func+0x44>
80002462:	f0 1f 00 05 	mcall	80002474 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
80002466:	30 19       	mov	r9,1
80002468:	48 48       	lddpc	r8,80002478 <TransmitControl_brdcst_func+0x40>
8000246a:	b0 89       	st.b	r8[0x0],r9
8000246c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d0 08       	*unknown*
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	6c 10       	ld.w	r0,r6[0x4]
80002478:	00 00       	add	r0,r0
8000247a:	0a 4d       	or	sp,r5
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	d0 20       	acall	0x2

80002480 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002480:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002484:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002488:	0f 89       	ld.ub	r9,r7[0x0]
8000248a:	30 08       	mov	r8,0
8000248c:	f0 09 18 00 	cp.b	r9,r8
80002490:	c1 61       	brne	800024bc <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002492:	48 ec       	lddpc	r12,800024c8 <TransmitControl_reply_func+0x48>
80002494:	f0 1f 00 0e 	mcall	800024cc <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002498:	0f 98       	ld.ub	r8,r7[0x1]
8000249a:	1a d8       	st.w	--sp,r8
8000249c:	48 dc       	lddpc	r12,800024d0 <TransmitControl_reply_func+0x50>
8000249e:	f0 1f 00 0c 	mcall	800024cc <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024a2:	0f a8       	ld.ub	r8,r7[0x2]
800024a4:	1a d8       	st.w	--sp,r8
800024a6:	48 cc       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x54>
800024a8:	f0 1f 00 09 	mcall	800024cc <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024ac:	0f b8       	ld.ub	r8,r7[0x3]
800024ae:	1a d8       	st.w	--sp,r8
800024b0:	48 ac       	lddpc	r12,800024d8 <TransmitControl_reply_func+0x58>
800024b2:	f0 1f 00 07 	mcall	800024cc <TransmitControl_reply_func+0x4c>
800024b6:	2f dd       	sub	sp,-12
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024bc:	48 8c       	lddpc	r12,800024dc <TransmitControl_reply_func+0x5c>
800024be:	f0 1f 00 04 	mcall	800024cc <TransmitControl_reply_func+0x4c>
800024c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c6:	00 00       	add	r0,r0
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	d0 34       	*unknown*
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	6c 10       	ld.w	r0,r6[0x4]
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	d0 50       	acall	0x5
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	d0 64       	*unknown*
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	d0 80       	acall	0x8
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d0 90       	acall	0x9

800024e0 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024e0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024e2:	19 a9       	ld.ub	r9,r12[0x2]
800024e4:	30 08       	mov	r8,0
800024e6:	f0 09 18 00 	cp.b	r9,r8
800024ea:	c0 71       	brne	800024f8 <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
800024ec:	48 5c       	lddpc	r12,80002500 <AudioRoutingControl_reply_func+0x20>
800024ee:	f0 1f 00 06 	mcall	80002504 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
800024f2:	f0 1f 00 06 	mcall	80002508 <AudioRoutingControl_reply_func+0x28>
800024f6:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024f8:	48 5c       	lddpc	r12,8000250c <AudioRoutingControl_reply_func+0x2c>
800024fa:	f0 1f 00 03 	mcall	80002504 <AudioRoutingControl_reply_func+0x24>
800024fe:	d8 02       	popm	pc
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	d0 a8       	*unknown*
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	6c 10       	ld.w	r0,r6[0x4]
80002508:	80 00       	ld.sh	r0,r0[0x0]
8000250a:	46 54       	lddsp	r4,sp[0x194]
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	d0 b8       	*unknown*

80002510 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002510:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002514:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002518:	0f 89       	ld.ub	r9,r7[0x0]
8000251a:	30 08       	mov	r8,0
8000251c:	f0 09 18 00 	cp.b	r9,r8
80002520:	c1 b1       	brne	80002556 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002522:	0f b8       	ld.ub	r8,r7[0x3]
80002524:	31 09       	mov	r9,16
80002526:	f2 08 18 00 	cp.b	r8,r9
8000252a:	c0 f1       	brne	80002548 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000252c:	48 dc       	lddpc	r12,80002560 <Volume_reply_func+0x50>
8000252e:	f0 1f 00 0e 	mcall	80002564 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002532:	0f 99       	ld.ub	r9,r7[0x1]
80002534:	0f a8       	ld.ub	r8,r7[0x2]
80002536:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000253a:	1a d8       	st.w	--sp,r8
8000253c:	48 bc       	lddpc	r12,80002568 <Volume_reply_func+0x58>
8000253e:	f0 1f 00 0a 	mcall	80002564 <Volume_reply_func+0x54>
80002542:	2f fd       	sub	sp,-4
80002544:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002548:	1a d8       	st.w	--sp,r8
8000254a:	48 9c       	lddpc	r12,8000256c <Volume_reply_func+0x5c>
8000254c:	f0 1f 00 06 	mcall	80002564 <Volume_reply_func+0x54>
80002550:	2f fd       	sub	sp,-4
80002552:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002556:	48 7c       	lddpc	r12,80002570 <Volume_reply_func+0x60>
80002558:	f0 1f 00 03 	mcall	80002564 <Volume_reply_func+0x54>
8000255c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	d0 cc       	*unknown*
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	6c 10       	ld.w	r0,r6[0x4]
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	d0 e0       	acall	0xe
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d0 fc       	*unknown*
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	d1 14       	*unknown*

80002574 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002574:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002576:	19 d9       	ld.ub	r9,r12[0x5]
80002578:	30 08       	mov	r8,0
8000257a:	f0 09 18 00 	cp.b	r9,r8
8000257e:	c0 81       	brne	8000258e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002580:	10 99       	mov	r9,r8
80002582:	48 78       	lddpc	r8,8000259c <spk_brdcst_func+0x28>
80002584:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002586:	48 7c       	lddpc	r12,800025a0 <spk_brdcst_func+0x2c>
80002588:	f0 1f 00 07 	mcall	800025a4 <spk_brdcst_func+0x30>
8000258c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000258e:	30 19       	mov	r9,1
80002590:	48 38       	lddpc	r8,8000259c <spk_brdcst_func+0x28>
80002592:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002594:	48 5c       	lddpc	r12,800025a8 <spk_brdcst_func+0x34>
80002596:	f0 1f 00 04 	mcall	800025a4 <spk_brdcst_func+0x30>
8000259a:	d8 02       	popm	pc
8000259c:	00 00       	add	r0,r0
8000259e:	0a 40       	or	r0,r5
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	d1 2c       	*unknown*
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	6c 10       	ld.w	r0,r6[0x4]
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	d1 3c       	*unknown*

800025ac <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025ac:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ae:	19 a9       	ld.ub	r9,r12[0x2]
800025b0:	30 08       	mov	r8,0
800025b2:	f0 09 18 00 	cp.b	r9,r8
800025b6:	c0 f1       	brne	800025d4 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025b8:	19 e9       	ld.ub	r9,r12[0x6]
800025ba:	f0 09 18 00 	cp.b	r9,r8
800025be:	c0 40       	breq	800025c6 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025c0:	30 19       	mov	r9,1
800025c2:	48 98       	lddpc	r8,800025e4 <spk_reply_func+0x38>
800025c4:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025c6:	19 e8       	ld.ub	r8,r12[0x6]
800025c8:	1a d8       	st.w	--sp,r8
800025ca:	48 8c       	lddpc	r12,800025e8 <spk_reply_func+0x3c>
800025cc:	f0 1f 00 08 	mcall	800025ec <spk_reply_func+0x40>
800025d0:	2f fd       	sub	sp,-4
800025d2:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025d4:	30 09       	mov	r9,0
800025d6:	48 48       	lddpc	r8,800025e4 <spk_reply_func+0x38>
800025d8:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025da:	48 6c       	lddpc	r12,800025f0 <spk_reply_func+0x44>
800025dc:	f0 1f 00 04 	mcall	800025ec <spk_reply_func+0x40>
800025e0:	d8 02       	popm	pc
800025e2:	00 00       	add	r0,r0
800025e4:	00 00       	add	r0,r0
800025e6:	0a 40       	or	r0,r5
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	d1 48       	*unknown*
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	6c 10       	ld.w	r0,r6[0x4]
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	d1 58       	*unknown*

800025f4 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025f4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025f8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800025fc:	0f a9       	ld.ub	r9,r7[0x2]
800025fe:	30 08       	mov	r8,0
80002600:	f0 09 18 00 	cp.b	r9,r8
80002604:	c0 71       	brne	80002612 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002606:	48 dc       	lddpc	r12,80002638 <mic_brdcst_func+0x44>
80002608:	f0 1f 00 0d 	mcall	8000263c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000260c:	30 09       	mov	r9,0
8000260e:	48 d8       	lddpc	r8,80002640 <mic_brdcst_func+0x4c>
80002610:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002612:	0f a9       	ld.ub	r9,r7[0x2]
80002614:	31 18       	mov	r8,17
80002616:	f0 09 18 00 	cp.b	r9,r8
8000261a:	c0 d1       	brne	80002634 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000261c:	48 ac       	lddpc	r12,80002644 <mic_brdcst_func+0x50>
8000261e:	f0 1f 00 08 	mcall	8000263c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002622:	48 89       	lddpc	r9,80002640 <mic_brdcst_func+0x4c>
80002624:	30 18       	mov	r8,1
80002626:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002628:	13 89       	ld.ub	r9,r9[0x0]
8000262a:	f0 09 18 00 	cp.b	r9,r8
8000262e:	c0 31       	brne	80002634 <mic_brdcst_func+0x40>
80002630:	48 68       	lddpc	r8,80002648 <mic_brdcst_func+0x54>
80002632:	11 88       	ld.ub	r8,r8[0x0]
80002634:	e3 cd 80 80 	ldm	sp++,r7,pc
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	d1 64       	*unknown*
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	6c 10       	ld.w	r0,r6[0x4]
80002640:	00 00       	add	r0,r0
80002642:	0a 57       	eor	r7,r5
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	d1 78       	*unknown*
80002648:	00 00       	add	r0,r0
8000264a:	0a 4e       	or	lr,r5

8000264c <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
8000264c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002650:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002654:	49 ac       	lddpc	r12,800026bc <mic_reply_func+0x70>
80002656:	f0 1f 00 1b 	mcall	800026c0 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000265a:	0f 89       	ld.ub	r9,r7[0x0]
8000265c:	30 08       	mov	r8,0
8000265e:	f0 09 18 00 	cp.b	r9,r8
80002662:	c2 71       	brne	800026b0 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002664:	0f 98       	ld.ub	r8,r7[0x1]
80002666:	30 29       	mov	r9,2
80002668:	f2 08 18 00 	cp.b	r8,r9
8000266c:	c1 b1       	brne	800026a2 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000266e:	49 6c       	lddpc	r12,800026c4 <mic_reply_func+0x78>
80002670:	f0 1f 00 14 	mcall	800026c0 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002674:	0f a8       	ld.ub	r8,r7[0x2]
80002676:	1a d8       	st.w	--sp,r8
80002678:	49 4c       	lddpc	r12,800026c8 <mic_reply_func+0x7c>
8000267a:	f0 1f 00 12 	mcall	800026c0 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000267e:	0f b8       	ld.ub	r8,r7[0x3]
80002680:	1a d8       	st.w	--sp,r8
80002682:	49 3c       	lddpc	r12,800026cc <mic_reply_func+0x80>
80002684:	f0 1f 00 0f 	mcall	800026c0 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002688:	0f c8       	ld.ub	r8,r7[0x4]
8000268a:	1a d8       	st.w	--sp,r8
8000268c:	49 1c       	lddpc	r12,800026d0 <mic_reply_func+0x84>
8000268e:	f0 1f 00 0d 	mcall	800026c0 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002692:	0f d8       	ld.ub	r8,r7[0x5]
80002694:	1a d8       	st.w	--sp,r8
80002696:	49 0c       	lddpc	r12,800026d4 <mic_reply_func+0x88>
80002698:	f0 1f 00 0a 	mcall	800026c0 <mic_reply_func+0x74>
8000269c:	2f cd       	sub	sp,-16
8000269e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026a2:	1a d8       	st.w	--sp,r8
800026a4:	48 dc       	lddpc	r12,800026d8 <mic_reply_func+0x8c>
800026a6:	f0 1f 00 07 	mcall	800026c0 <mic_reply_func+0x74>
800026aa:	2f fd       	sub	sp,-4
800026ac:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026b0:	48 bc       	lddpc	r12,800026dc <mic_reply_func+0x90>
800026b2:	f0 1f 00 04 	mcall	800026c0 <mic_reply_func+0x74>
800026b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ba:	00 00       	add	r0,r0
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	d1 8c       	*unknown*
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	6c 10       	ld.w	r0,r6[0x4]
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	d1 9c       	*unknown*
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	d1 b0       	acall	0x1b
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d1 c4       	*unknown*
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	d1 e0       	acall	0x1e
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	d1 f8       	*unknown*
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d2 10       	acall	0x21
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d2 28       	*unknown*

800026e0 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026e0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026e4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026e8:	48 bc       	lddpc	r12,80002714 <dcm_brdcst_func+0x34>
800026ea:	f0 1f 00 0c 	mcall	80002718 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026ee:	0f 88       	ld.ub	r8,r7[0x0]
800026f0:	1a d8       	st.w	--sp,r8
800026f2:	48 bc       	lddpc	r12,8000271c <dcm_brdcst_func+0x3c>
800026f4:	f0 1f 00 09 	mcall	80002718 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026f8:	0f a8       	ld.ub	r8,r7[0x2]
800026fa:	1a d8       	st.w	--sp,r8
800026fc:	48 9c       	lddpc	r12,80002720 <dcm_brdcst_func+0x40>
800026fe:	f0 1f 00 07 	mcall	80002718 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002702:	0f 98       	ld.ub	r8,r7[0x1]
80002704:	1a d8       	st.w	--sp,r8
80002706:	48 8c       	lddpc	r12,80002724 <dcm_brdcst_func+0x44>
80002708:	f0 1f 00 04 	mcall	80002718 <dcm_brdcst_func+0x38>
8000270c:	2f dd       	sub	sp,-12
	
	
}
8000270e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002712:	00 00       	add	r0,r0
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d2 38       	*unknown*
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	6c 10       	ld.w	r0,r6[0x4]
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	d2 4c       	*unknown*
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	d2 60       	acall	0x26
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	d2 78       	*unknown*

80002728 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002728:	eb cd 40 80 	pushm	r7,lr
8000272c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000272e:	19 a9       	ld.ub	r9,r12[0x2]
80002730:	30 08       	mov	r8,0
80002732:	f0 09 18 00 	cp.b	r9,r8
80002736:	c1 b1       	brne	8000276c <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002738:	19 b8       	ld.ub	r8,r12[0x3]
8000273a:	30 19       	mov	r9,1
8000273c:	f2 08 18 00 	cp.b	r8,r9
80002740:	c0 51       	brne	8000274a <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002742:	48 ec       	lddpc	r12,80002778 <dcm_reply_func+0x50>
80002744:	f0 1f 00 0e 	mcall	8000277c <dcm_reply_func+0x54>
80002748:	c0 a8       	rjmp	8000275c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000274a:	58 08       	cp.w	r8,0
8000274c:	c0 51       	brne	80002756 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000274e:	48 dc       	lddpc	r12,80002780 <dcm_reply_func+0x58>
80002750:	f0 1f 00 0b 	mcall	8000277c <dcm_reply_func+0x54>
80002754:	c0 48       	rjmp	8000275c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002756:	48 cc       	lddpc	r12,80002784 <dcm_reply_func+0x5c>
80002758:	f0 1f 00 09 	mcall	8000277c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000275c:	0f d8       	ld.ub	r8,r7[0x5]
8000275e:	1a d8       	st.w	--sp,r8
80002760:	48 ac       	lddpc	r12,80002788 <dcm_reply_func+0x60>
80002762:	f0 1f 00 07 	mcall	8000277c <dcm_reply_func+0x54>
80002766:	2f fd       	sub	sp,-4
80002768:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
8000276c:	48 8c       	lddpc	r12,8000278c <dcm_reply_func+0x64>
8000276e:	f0 1f 00 04 	mcall	8000277c <dcm_reply_func+0x54>
80002772:	e3 cd 80 80 	ldm	sp++,r7,pc
80002776:	00 00       	add	r0,r0
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	d2 94       	*unknown*
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	6c 10       	ld.w	r0,r6[0x4]
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	d2 a8       	*unknown*
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	d2 bc       	*unknown*
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	d2 d0       	acall	0x2d
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	d2 dc       	*unknown*

80002790 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002790:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002792:	19 a9       	ld.ub	r9,r12[0x2]
80002794:	30 08       	mov	r8,0
80002796:	f0 09 18 00 	cp.b	r9,r8
8000279a:	c0 51       	brne	800027a4 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
8000279c:	48 4c       	lddpc	r12,800027ac <ToneControl_reply_func+0x1c>
8000279e:	f0 1f 00 05 	mcall	800027b0 <ToneControl_reply_func+0x20>
800027a2:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027a4:	48 4c       	lddpc	r12,800027b4 <ToneControl_reply_func+0x24>
800027a6:	f0 1f 00 03 	mcall	800027b0 <ToneControl_reply_func+0x20>
800027aa:	d8 02       	popm	pc
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d2 e8       	*unknown*
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	6c 10       	ld.w	r0,r6[0x4]
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	d2 f0       	acall	0x2f

800027b8 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027b8:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027ba:	f0 1f 00 1e 	mcall	80002830 <app_cfg+0x78>
800027be:	49 e8       	lddpc	r8,80002834 <app_cfg+0x7c>
800027c0:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027c2:	49 e6       	lddpc	r6,80002838 <app_cfg+0x80>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027c4:	49 e3       	lddpc	r3,8000283c <app_cfg+0x84>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027c6:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800027c8:	30 31       	mov	r1,3
					xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027ca:	30 12       	mov	r2,1
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
800027cc:	49 d5       	lddpc	r5,80002840 <app_cfg+0x88>
800027ce:	49 e7       	lddpc	r7,80002844 <app_cfg+0x8c>
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027d0:	10 94       	mov	r4,r8
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027d2:	6c 08       	ld.w	r8,r6[0x0]
800027d4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027d8:	58 38       	cp.w	r8,3
800027da:	c1 e1       	brne	80002816 <app_cfg+0x5e>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800027dc:	f0 1f 00 1b 	mcall	80002848 <app_cfg+0x90>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027e0:	66 08       	ld.w	r8,r3[0x0]
800027e2:	58 08       	cp.w	r8,0
800027e4:	c0 71       	brne	800027f2 <app_cfg+0x3a>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
800027e6:	f0 1f 00 1a 	mcall	8000284c <app_cfg+0x94>
					xcmp_enter_enhanced_OB_mode();
800027ea:	f0 1f 00 1a 	mcall	80002850 <app_cfg+0x98>
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027ee:	87 02       	st.w	r3[0x0],r2
800027f0:	c1 38       	rjmp	80002816 <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
800027f2:	58 18       	cp.w	r8,1
800027f4:	c0 61       	brne	80002800 <app_cfg+0x48>
				{
					//xcmp_exit_device_control_mode();
					xcmp_audio_route_AMBE();
800027f6:	f0 1f 00 18 	mcall	80002854 <app_cfg+0x9c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027fa:	30 28       	mov	r8,2
800027fc:	87 08       	st.w	r3[0x0],r8
800027fe:	c0 c8       	rjmp	80002816 <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
80002800:	58 28       	cp.w	r8,2
80002802:	c0 31       	brne	80002808 <app_cfg+0x50>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002804:	87 01       	st.w	r3[0x0],r1
80002806:	c0 88       	rjmp	80002816 <app_cfg+0x5e>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80002808:	58 38       	cp.w	r8,3
8000280a:	e7 f0 0a 00 	st.weq	r3[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
8000280e:	f7 b8 01 ff 	subne	r8,-1
80002812:	e7 f8 1a 00 	st.wne	r3[0x0],r8
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
80002816:	6e 08       	ld.w	r8,r7[0x0]
80002818:	1a d8       	st.w	--sp,r8
8000281a:	0a 9c       	mov	r12,r5
8000281c:	f0 1f 00 0f 	mcall	80002858 <app_cfg+0xa0>
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002820:	e0 6b 0f a0 	mov	r11,4000
80002824:	08 9c       	mov	r12,r4
80002826:	f0 1f 00 0e 	mcall	8000285c <app_cfg+0xa4>
	}
8000282a:	2f fd       	sub	sp,-4
8000282c:	cd 3b       	rjmp	800027d2 <app_cfg+0x1a>
8000282e:	00 00       	add	r0,r0
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	65 84       	ld.w	r4,r2[0x60]
80002834:	00 00       	add	r0,r0
80002836:	0a 48       	or	r8,r5
80002838:	00 00       	add	r0,r0
8000283a:	0d 80       	ld.ub	r0,r6[0x0]
8000283c:	00 00       	add	r0,r0
8000283e:	0a 44       	or	r4,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	d2 fc       	*unknown*
80002844:	00 00       	add	r0,r0
80002846:	0a 58       	eor	r8,r5
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	46 54       	lddsp	r4,sp[0x194]
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	44 f8       	lddsp	r8,sp[0x13c]
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	45 84       	lddsp	r4,sp[0x160]
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	45 24       	lddsp	r4,sp[0x148]
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	6c 10       	ld.w	r0,r6[0x4]
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	66 ec       	ld.w	r12,r3[0x38]

80002860 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002860:	eb cd 40 80 	pushm	r7,lr
80002864:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002866:	48 c9       	lddpc	r9,80002894 <app_payload_rx_proc+0x34>
80002868:	13 88       	ld.ub	r8,r9[0x0]
8000286a:	2f f8       	sub	r8,-1
8000286c:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000286e:	30 39       	mov	r9,3
80002870:	f2 08 18 00 	cp.b	r8,r9
80002874:	c0 71       	brne	80002882 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002876:	30 09       	mov	r9,0
80002878:	48 78       	lddpc	r8,80002894 <app_payload_rx_proc+0x34>
8000287a:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
8000287c:	48 7c       	lddpc	r12,80002898 <app_payload_rx_proc+0x38>
8000287e:	f0 1f 00 08 	mcall	8000289c <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002882:	48 88       	lddpc	r8,800028a0 <app_payload_rx_proc+0x40>
80002884:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002886:	48 88       	lddpc	r8,800028a4 <app_payload_rx_proc+0x44>
80002888:	70 0c       	ld.w	r12,r8[0x0]
8000288a:	0e 9b       	mov	r11,r7
8000288c:	f0 1f 00 07 	mcall	800028a8 <app_payload_rx_proc+0x48>

}
80002890:	e3 cd 80 80 	ldm	sp++,r7,pc
80002894:	00 00       	add	r0,r0
80002896:	0a 55       	eor	r5,r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	d3 18       	*unknown*
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	6c 10       	ld.w	r0,r6[0x4]
800028a0:	00 00       	add	r0,r0
800028a2:	0a 4c       	or	r12,r5
800028a4:	00 00       	add	r0,r0
800028a6:	0a 74       	tst	r4,r5
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	2f fc       	sub	r12,-1

800028ac <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028ac:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028ae:	19 e8       	ld.ub	r8,r12[0x6]
800028b0:	30 19       	mov	r9,1
800028b2:	f2 08 18 00 	cp.b	r8,r9
800028b6:	c0 61       	brne	800028c2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028b8:	48 98       	lddpc	r8,800028dc <DeviceInitializationStatus_brdcst_func+0x30>
800028ba:	70 09       	ld.w	r9,r8[0x0]
800028bc:	a1 a9       	sbr	r9,0x0
800028be:	91 09       	st.w	r8[0x0],r9
800028c0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028c2:	30 29       	mov	r9,2
800028c4:	f2 08 18 00 	cp.b	r8,r9
800028c8:	c0 80       	breq	800028d8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ca:	48 58       	lddpc	r8,800028dc <DeviceInitializationStatus_brdcst_func+0x30>
800028cc:	70 09       	ld.w	r9,r8[0x0]
800028ce:	e0 19 ff fc 	andl	r9,0xfffc
800028d2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028d4:	f0 1f 00 03 	mcall	800028e0 <DeviceInitializationStatus_brdcst_func+0x34>
800028d8:	d8 02       	popm	pc
800028da:	00 00       	add	r0,r0
800028dc:	00 00       	add	r0,r0
800028de:	0d 80       	ld.ub	r0,r6[0x0]
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	45 a8       	lddsp	r8,sp[0x168]

800028e4 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028e4:	eb cd 40 fc 	pushm	r2-r7,lr
800028e8:	20 1d       	sub	sp,4
800028ea:	18 97       	mov	r7,r12
800028ec:	14 95       	mov	r5,r10
800028ee:	12 96       	mov	r6,r9
	U16 status = 1;
800028f0:	30 18       	mov	r8,1
800028f2:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028f4:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028f8:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
800028fc:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
80002900:	30 0b       	mov	r11,0
80002902:	4e 38       	lddpc	r8,80002a8c <send_flash_command+0x1a8>
80002904:	70 0c       	ld.w	r12,r8[0x0]
80002906:	f0 1f 00 63 	mcall	80002a90 <send_flash_command+0x1ac>

    switch (command)
8000290a:	30 58       	mov	r8,5
8000290c:	f0 07 19 00 	cp.h	r7,r8
80002910:	c3 40       	breq	80002978 <send_flash_command+0x94>
80002912:	e0 8b 00 18 	brhi	80002942 <send_flash_command+0x5e>
80002916:	30 28       	mov	r8,2
80002918:	f0 07 19 00 	cp.h	r7,r8
8000291c:	c5 e0       	breq	800029d8 <send_flash_command+0xf4>
8000291e:	e0 8b 00 08 	brhi	8000292e <send_flash_command+0x4a>
80002922:	30 18       	mov	r8,1
80002924:	f0 07 19 00 	cp.h	r7,r8
80002928:	e0 81 00 a9 	brne	80002a7a <send_flash_command+0x196>
8000292c:	c9 e8       	rjmp	80002a68 <send_flash_command+0x184>
8000292e:	30 38       	mov	r8,3
80002930:	f0 07 19 00 	cp.h	r7,r8
80002934:	c7 20       	breq	80002a18 <send_flash_command+0x134>
80002936:	30 48       	mov	r8,4
80002938:	f0 07 19 00 	cp.h	r7,r8
8000293c:	e0 81 00 9f 	brne	80002a7a <send_flash_command+0x196>
80002940:	c2 c8       	rjmp	80002998 <send_flash_command+0xb4>
80002942:	35 28       	mov	r8,82
80002944:	f0 07 19 00 	cp.h	r7,r8
80002948:	c2 f0       	breq	800029a6 <send_flash_command+0xc2>
8000294a:	e0 8b 00 0c 	brhi	80002962 <send_flash_command+0x7e>
8000294e:	30 68       	mov	r8,6
80002950:	f0 07 19 00 	cp.h	r7,r8
80002954:	c2 20       	breq	80002998 <send_flash_command+0xb4>
80002956:	32 08       	mov	r8,32
80002958:	f0 07 19 00 	cp.h	r7,r8
8000295c:	e0 81 00 8f 	brne	80002a7a <send_flash_command+0x196>
80002960:	c2 38       	rjmp	800029a6 <send_flash_command+0xc2>
80002962:	36 08       	mov	r8,96
80002964:	f0 07 19 00 	cp.h	r7,r8
80002968:	c3 20       	breq	800029cc <send_flash_command+0xe8>
8000296a:	e0 68 00 d8 	mov	r8,216
8000296e:	f0 07 19 00 	cp.h	r7,r8
80002972:	e0 81 00 84 	brne	80002a7a <send_flash_command+0x196>
80002976:	c1 88       	rjmp	800029a6 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002978:	4c 57       	lddpc	r7,80002a8c <send_flash_command+0x1a8>
8000297a:	30 5b       	mov	r11,5
8000297c:	6e 0c       	ld.w	r12,r7[0x0]
8000297e:	f0 1f 00 46 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_dummy();
80002982:	e0 6b 00 ff 	mov	r11,255
80002986:	6e 0c       	ld.w	r12,r7[0x0]
80002988:	f0 1f 00 43 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_read_byte(&status);
8000298c:	fa cb ff fe 	sub	r11,sp,-2
80002990:	6e 0c       	ld.w	r12,r7[0x0]
80002992:	f0 1f 00 42 	mcall	80002a98 <send_flash_command+0x1b4>
			break;
80002996:	c7 28       	rjmp	80002a7a <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002998:	0e 9b       	mov	r11,r7
8000299a:	5c 7b       	castu.h	r11
8000299c:	4b c8       	lddpc	r8,80002a8c <send_flash_command+0x1a8>
8000299e:	70 0c       	ld.w	r12,r8[0x0]
800029a0:	f0 1f 00 3d 	mcall	80002a94 <send_flash_command+0x1b0>
			break;
800029a4:	c6 b8       	rjmp	80002a7a <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
800029a6:	4b a6       	lddpc	r6,80002a8c <send_flash_command+0x1a8>
800029a8:	0e 9b       	mov	r11,r7
800029aa:	5c 7b       	castu.h	r11
800029ac:	6c 0c       	ld.w	r12,r6[0x0]
800029ae:	f0 1f 00 3a 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029b2:	08 9b       	mov	r11,r4
800029b4:	6c 0c       	ld.w	r12,r6[0x0]
800029b6:	f0 1f 00 38 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029ba:	06 9b       	mov	r11,r3
800029bc:	6c 0c       	ld.w	r12,r6[0x0]
800029be:	f0 1f 00 36 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029c2:	04 9b       	mov	r11,r2
800029c4:	6c 0c       	ld.w	r12,r6[0x0]
800029c6:	f0 1f 00 34 	mcall	80002a94 <send_flash_command+0x1b0>
			break;
800029ca:	c5 88       	rjmp	80002a7a <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
800029cc:	36 0b       	mov	r11,96
800029ce:	4b 08       	lddpc	r8,80002a8c <send_flash_command+0x1a8>
800029d0:	70 0c       	ld.w	r12,r8[0x0]
800029d2:	f0 1f 00 31 	mcall	80002a94 <send_flash_command+0x1b0>
			break;
800029d6:	c5 28       	rjmp	80002a7a <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029d8:	4a d7       	lddpc	r7,80002a8c <send_flash_command+0x1a8>
800029da:	30 2b       	mov	r11,2
800029dc:	6e 0c       	ld.w	r12,r7[0x0]
800029de:	f0 1f 00 2e 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029e2:	08 9b       	mov	r11,r4
800029e4:	6e 0c       	ld.w	r12,r7[0x0]
800029e6:	f0 1f 00 2c 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029ea:	06 9b       	mov	r11,r3
800029ec:	6e 0c       	ld.w	r12,r7[0x0]
800029ee:	f0 1f 00 2a 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029f2:	04 9b       	mov	r11,r2
800029f4:	6e 0c       	ld.w	r12,r7[0x0]
800029f6:	f0 1f 00 28 	mcall	80002a94 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029fa:	58 06       	cp.w	r6,0
800029fc:	c3 f0       	breq	80002a7a <send_flash_command+0x196>
800029fe:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002a00:	4a 34       	lddpc	r4,80002a8c <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002a02:	0f 3b       	ld.ub	r11,r7++
80002a04:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002a06:	68 0c       	ld.w	r12,r4[0x0]
80002a08:	f0 1f 00 23 	mcall	80002a94 <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a0c:	0e 98       	mov	r8,r7
80002a0e:	0a 18       	sub	r8,r5
80002a10:	ec 08 19 00 	cp.h	r8,r6
80002a14:	cf 73       	brcs	80002a02 <send_flash_command+0x11e>
80002a16:	c3 28       	rjmp	80002a7a <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002a18:	49 d7       	lddpc	r7,80002a8c <send_flash_command+0x1a8>
80002a1a:	30 3b       	mov	r11,3
80002a1c:	6e 0c       	ld.w	r12,r7[0x0]
80002a1e:	f0 1f 00 1e 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
80002a22:	08 9b       	mov	r11,r4
80002a24:	6e 0c       	ld.w	r12,r7[0x0]
80002a26:	f0 1f 00 1c 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
80002a2a:	06 9b       	mov	r11,r3
80002a2c:	6e 0c       	ld.w	r12,r7[0x0]
80002a2e:	f0 1f 00 1a 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002a32:	04 9b       	mov	r11,r2
80002a34:	6e 0c       	ld.w	r12,r7[0x0]
80002a36:	f0 1f 00 18 	mcall	80002a94 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a3a:	58 06       	cp.w	r6,0
80002a3c:	c1 f0       	breq	80002a7a <send_flash_command+0x196>
80002a3e:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a40:	49 34       	lddpc	r4,80002a8c <send_flash_command+0x1a8>
80002a42:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a46:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a48:	06 9b       	mov	r11,r3
80002a4a:	68 0c       	ld.w	r12,r4[0x0]
80002a4c:	f0 1f 00 12 	mcall	80002a94 <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a50:	1a 9b       	mov	r11,sp
80002a52:	68 0c       	ld.w	r12,r4[0x0]
80002a54:	f0 1f 00 11 	mcall	80002a98 <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a58:	9a 08       	ld.sh	r8,sp[0x0]
80002a5a:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a5c:	0e 98       	mov	r8,r7
80002a5e:	0a 18       	sub	r8,r5
80002a60:	ec 08 19 00 	cp.h	r8,r6
80002a64:	cf 23       	brcs	80002a48 <send_flash_command+0x164>
80002a66:	c0 a8       	rjmp	80002a7a <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a68:	48 97       	lddpc	r7,80002a8c <send_flash_command+0x1a8>
80002a6a:	30 1b       	mov	r11,1
80002a6c:	6e 0c       	ld.w	r12,r7[0x0]
80002a6e:	f0 1f 00 0a 	mcall	80002a94 <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a72:	30 0b       	mov	r11,0
80002a74:	6e 0c       	ld.w	r12,r7[0x0]
80002a76:	f0 1f 00 08 	mcall	80002a94 <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a7a:	30 0b       	mov	r11,0
80002a7c:	48 48       	lddpc	r8,80002a8c <send_flash_command+0x1a8>
80002a7e:	70 0c       	ld.w	r12,r8[0x0]
80002a80:	f0 1f 00 07 	mcall	80002a9c <send_flash_command+0x1b8>

	return status;
}
80002a84:	9a 1c       	ld.sh	r12,sp[0x2]
80002a86:	2f fd       	sub	sp,-4
80002a88:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a8c:	00 00       	add	r0,r0
80002a8e:	1d 84       	ld.ub	r4,lr[0x0]
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	55 e0       	stdsp	sp[0x178],r0
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	57 12       	stdsp	sp[0x1c4],r2
80002a98:	80 00       	ld.sh	r0,r0[0x0]
80002a9a:	57 2e       	stdsp	sp[0x1c8],lr
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	56 2c       	stdsp	sp[0x188],r12

80002aa0 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002aa0:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002aa2:	58 0a       	cp.w	r10,0
80002aa4:	5f 09       	sreq	r9
80002aa6:	e0 68 ff fe 	mov	r8,65534
80002aaa:	ea 18 00 7f 	orh	r8,0x7f
80002aae:	10 3c       	cp.w	r12,r8
80002ab0:	5f b8       	srhi	r8
80002ab2:	f3 e8 10 08 	or	r8,r9,r8
80002ab6:	c0 e1       	brne	80002ad2 <data_flash_read_block+0x32>
80002ab8:	e0 68 10 00 	mov	r8,4096
80002abc:	f0 0b 19 00 	cp.h	r11,r8
80002ac0:	e0 8b 00 09 	brhi	80002ad2 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002ac4:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002ac8:	18 9b       	mov	r11,r12
80002aca:	30 3c       	mov	r12,3
80002acc:	f0 1f 00 02 	mcall	80002ad4 <data_flash_read_block+0x34>
80002ad0:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002ad2:	da 0a       	popm	pc,r12=1
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	28 e4       	sub	r4,-114

80002ad8 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002ad8:	eb cd 40 e0 	pushm	r5-r7,lr
80002adc:	18 96       	mov	r6,r12
80002ade:	16 97       	mov	r7,r11
80002ae0:	14 95       	mov	r5,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002ae2:	58 0c       	cp.w	r12,0
80002ae4:	5f 09       	sreq	r9
80002ae6:	e0 68 ff fe 	mov	r8,65534
80002aea:	ea 18 00 7f 	orh	r8,0x7f
80002aee:	10 3b       	cp.w	r11,r8
80002af0:	5f b8       	srhi	r8
80002af2:	f3 e8 10 08 	or	r8,r9,r8
80002af6:	c3 91       	brne	80002b68 <data_flash_write_page+0x90>
80002af8:	e0 68 01 00 	mov	r8,256
80002afc:	f0 0a 19 00 	cp.h	r10,r8
80002b00:	e0 8b 00 34 	brhi	80002b68 <data_flash_write_page+0x90>
	{
		return DF_INVALID_PARAM;
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b04:	30 09       	mov	r9,0
80002b06:	12 9a       	mov	r10,r9
80002b08:	12 9b       	mov	r11,r9
80002b0a:	30 5c       	mov	r12,5
80002b0c:	f0 1f 00 19 	mcall	80002b70 <data_flash_write_page+0x98>
	if ((status & STATUS_BUSY) != 0)
80002b10:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002b14:	c0 30       	breq	80002b1a <data_flash_write_page+0x42>
80002b16:	30 27       	mov	r7,2
80002b18:	c2 98       	rjmp	80002b6a <data_flash_write_page+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002b1a:	30 09       	mov	r9,0
80002b1c:	12 9a       	mov	r10,r9
80002b1e:	12 9b       	mov	r11,r9
80002b20:	30 6c       	mov	r12,6
80002b22:	f0 1f 00 14 	mcall	80002b70 <data_flash_write_page+0x98>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002b26:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
80002b2a:	0c 9a       	mov	r10,r6
80002b2c:	0e 9b       	mov	r11,r7
80002b2e:	30 2c       	mov	r12,2
80002b30:	f0 1f 00 10 	mcall	80002b70 <data_flash_write_page+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b34:	30 05       	mov	r5,0
80002b36:	30 56       	mov	r6,5
80002b38:	0a 99       	mov	r9,r5
80002b3a:	0a 9a       	mov	r10,r5
80002b3c:	0a 9b       	mov	r11,r5
80002b3e:	0c 9c       	mov	r12,r6
80002b40:	f0 1f 00 0c 	mcall	80002b70 <data_flash_write_page+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002b44:	5c 7c       	castu.h	r12
80002b46:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002b4a:	cf 71       	brne	80002b38 <data_flash_write_page+0x60>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002b4c:	18 97       	mov	r7,r12
80002b4e:	e2 17 00 20 	andl	r7,0x20,COH
80002b52:	f9 b7 01 06 	movne	r7,6
80002b56:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b5a:	30 09       	mov	r9,0
80002b5c:	12 9a       	mov	r10,r9
80002b5e:	12 9b       	mov	r11,r9
80002b60:	30 4c       	mov	r12,4
80002b62:	f0 1f 00 04 	mcall	80002b70 <data_flash_write_page+0x98>

	return return_code;
80002b66:	c0 28       	rjmp	80002b6a <data_flash_write_page+0x92>
80002b68:	30 17       	mov	r7,1
}
80002b6a:	0e 9c       	mov	r12,r7
80002b6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	28 e4       	sub	r4,-114

80002b74 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002b74:	d4 31       	pushm	r0-r7,lr
80002b76:	18 94       	mov	r4,r12
80002b78:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002b7c:	16 97       	mov	r7,r11
80002b7e:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b80:	30 03       	mov	r3,0
80002b82:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b84:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b88:	c4 98       	rjmp	80002c1a <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002b8a:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002b8e:	c1 b1       	brne	80002bc4 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b90:	e0 06 19 00 	cp.h	r6,r0
80002b94:	e0 8b 00 0a 	brhi	80002ba8 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002b98:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002b9c:	0e 9b       	mov	r11,r7
80002b9e:	08 9c       	mov	r12,r4
80002ba0:	f0 1f 00 24 	mcall	80002c30 <data_flash_write_block+0xbc>
80002ba4:	30 06       	mov	r6,0
80002ba6:	c3 a8       	rjmp	80002c1a <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002ba8:	e0 6a 01 00 	mov	r10,256
80002bac:	0e 9b       	mov	r11,r7
80002bae:	08 9c       	mov	r12,r4
80002bb0:	f0 1f 00 20 	mcall	80002c30 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002bb4:	ec c6 01 00 	sub	r6,r6,256
80002bb8:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002bba:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002bbe:	ee c7 ff 00 	sub	r7,r7,-256
80002bc2:	c2 c8       	rjmp	80002c1a <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002bc4:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002bc8:	0e 09       	add	r9,r7
80002bca:	0e 98       	mov	r8,r7
80002bcc:	e4 18 00 7f 	andh	r8,0x7f
80002bd0:	e0 18 ff 00 	andl	r8,0xff00
80002bd4:	f0 c8 ff 00 	sub	r8,r8,-256
80002bd8:	10 39       	cp.w	r9,r8
80002bda:	e0 88 00 19 	brls	80002c0c <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002bde:	0e 91       	mov	r1,r7
80002be0:	5c 51       	castu.b	r1
80002be2:	e0 6a 01 00 	mov	r10,256
80002be6:	02 1a       	sub	r10,r1
80002be8:	5c 7a       	castu.h	r10
80002bea:	0e 9b       	mov	r11,r7
80002bec:	08 9c       	mov	r12,r4
80002bee:	f0 1f 00 11 	mcall	80002c30 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bf2:	ec c6 01 00 	sub	r6,r6,256
80002bf6:	02 06       	add	r6,r1
80002bf8:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bfa:	e0 68 01 00 	mov	r8,256
80002bfe:	f0 05 01 05 	sub	r5,r8,r5
80002c02:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002c04:	e0 17 ff 00 	andl	r7,0xff00
80002c08:	10 07       	add	r7,r8
80002c0a:	c0 88       	rjmp	80002c1a <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002c0c:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002c10:	0e 9b       	mov	r11,r7
80002c12:	08 9c       	mov	r12,r4
80002c14:	f0 1f 00 07 	mcall	80002c30 <data_flash_write_block+0xbc>
80002c18:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002c1a:	e6 06 19 00 	cp.h	r6,r3
80002c1e:	5f 19       	srne	r9
80002c20:	58 7c       	cp.w	r12,7
80002c22:	5f 08       	sreq	r8
80002c24:	f3 e8 00 08 	and	r8,r9,r8
80002c28:	e4 08 18 00 	cp.b	r8,r2
80002c2c:	ca f1       	brne	80002b8a <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002c2e:	d8 32       	popm	r0-r7,pc
80002c30:	80 00       	ld.sh	r0,r0[0x0]
80002c32:	2a d8       	sub	r8,-83

80002c34 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002c34:	eb cd 40 c0 	pushm	r6-r7,lr
80002c38:	18 97       	mov	r7,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002c3a:	e0 68 ff fe 	mov	r8,65534
80002c3e:	ea 18 00 7f 	orh	r8,0x7f
80002c42:	10 3c       	cp.w	r12,r8
80002c44:	e0 88 00 04 	brls	80002c4c <data_flash_erase_block+0x18>
80002c48:	30 17       	mov	r7,1
80002c4a:	c3 e8       	rjmp	80002cc6 <data_flash_erase_block+0x92>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002c4c:	58 1b       	cp.w	r11,1
80002c4e:	c0 31       	brne	80002c54 <data_flash_erase_block+0x20>
80002c50:	32 06       	mov	r6,32
80002c52:	c0 a8       	rjmp	80002c66 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002c54:	58 2b       	cp.w	r11,2
80002c56:	c0 31       	brne	80002c5c <data_flash_erase_block+0x28>
80002c58:	35 26       	mov	r6,82
80002c5a:	c0 68       	rjmp	80002c66 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002c5c:	e0 66 00 d8 	mov	r6,216
80002c60:	58 3b       	cp.w	r11,3
80002c62:	f9 b6 01 60 	movne	r6,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c66:	30 09       	mov	r9,0
80002c68:	12 9a       	mov	r10,r9
80002c6a:	12 9b       	mov	r11,r9
80002c6c:	30 5c       	mov	r12,5
80002c6e:	f0 1f 00 18 	mcall	80002ccc <data_flash_erase_block+0x98>
	if ((status & STATUS_BUSY) != 0)
80002c72:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002c76:	c0 30       	breq	80002c7c <data_flash_erase_block+0x48>
80002c78:	30 27       	mov	r7,2
80002c7a:	c2 68       	rjmp	80002cc6 <data_flash_erase_block+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c7c:	30 09       	mov	r9,0
80002c7e:	12 9a       	mov	r10,r9
80002c80:	12 9b       	mov	r11,r9
80002c82:	30 6c       	mov	r12,6
80002c84:	f0 1f 00 12 	mcall	80002ccc <data_flash_erase_block+0x98>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002c88:	30 09       	mov	r9,0
80002c8a:	12 9a       	mov	r10,r9
80002c8c:	0e 9b       	mov	r11,r7
80002c8e:	0c 9c       	mov	r12,r6
80002c90:	f0 1f 00 0f 	mcall	80002ccc <data_flash_erase_block+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c94:	30 06       	mov	r6,0
80002c96:	30 57       	mov	r7,5
80002c98:	0c 99       	mov	r9,r6
80002c9a:	0c 9a       	mov	r10,r6
80002c9c:	0c 9b       	mov	r11,r6
80002c9e:	0e 9c       	mov	r12,r7
80002ca0:	f0 1f 00 0b 	mcall	80002ccc <data_flash_erase_block+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002ca4:	5c 7c       	castu.h	r12
80002ca6:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002caa:	cf 71       	brne	80002c98 <data_flash_erase_block+0x64>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002cac:	18 97       	mov	r7,r12
80002cae:	e2 17 00 20 	andl	r7,0x20,COH
80002cb2:	f9 b7 01 04 	movne	r7,4
80002cb6:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002cba:	30 09       	mov	r9,0
80002cbc:	12 9a       	mov	r10,r9
80002cbe:	12 9b       	mov	r11,r9
80002cc0:	30 4c       	mov	r12,4
80002cc2:	f0 1f 00 03 	mcall	80002ccc <data_flash_erase_block+0x98>

	return return_code;
}
80002cc6:	0e 9c       	mov	r12,r7
80002cc8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ccc:	80 00       	ld.sh	r0,r0[0x0]
80002cce:	28 e4       	sub	r4,-114

80002cd0 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002cd0:	d4 31       	pushm	r0-r7,lr
80002cd2:	20 3d       	sub	sp,12
80002cd4:	50 0c       	stdsp	sp[0x0],r12
80002cd6:	16 91       	mov	r1,r11
80002cd8:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002cda:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002cde:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002ce0:	e0 69 10 00 	mov	r9,4096
80002ce4:	f2 0a 01 07 	sub	r7,r9,r10
80002ce8:	ea 07 19 00 	cp.h	r7,r5
80002cec:	ea 07 17 b0 	movhi	r7,r5
80002cf0:	5c 87       	casts.h	r7
80002cf2:	16 92       	mov	r2,r11
80002cf4:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cf8:	4a e4       	lddpc	r4,80002db0 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002cfa:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002cfc:	e8 c8 ff ff 	sub	r8,r4,-1
80002d00:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002d02:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002d04:	08 9a       	mov	r10,r4
80002d06:	e0 6b 10 00 	mov	r11,4096
80002d0a:	04 9c       	mov	r12,r2
80002d0c:	f0 1f 00 2a 	mcall	80002db4 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002d10:	58 07       	cp.w	r7,0
80002d12:	c3 00       	breq	80002d72 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002d14:	40 13       	lddsp	r3,sp[0x4]
80002d16:	5c 73       	castu.h	r3
80002d18:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002d1c:	ec 08 18 00 	cp.b	r8,r6
80002d20:	c1 11       	brne	80002d42 <data_flash_write+0x72>
80002d22:	e6 c9 ff ff 	sub	r9,r3,-1
80002d26:	08 09       	add	r9,r4
80002d28:	30 08       	mov	r8,0
80002d2a:	c0 58       	rjmp	80002d34 <data_flash_write+0x64>
80002d2c:	13 3a       	ld.ub	r10,r9++
80002d2e:	ec 0a 18 00 	cp.b	r10,r6
80002d32:	c0 81       	brne	80002d42 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002d34:	2f f8       	sub	r8,-1
80002d36:	5c 88       	casts.h	r8
80002d38:	f0 07 19 00 	cp.h	r7,r8
80002d3c:	fe 9b ff f8 	brhi	80002d2c <data_flash_write+0x5c>
80002d40:	c1 98       	rjmp	80002d72 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002d42:	30 1b       	mov	r11,1
80002d44:	04 9c       	mov	r12,r2
80002d46:	f0 1f 00 1d 	mcall	80002db8 <data_flash_write+0xe8>
80002d4a:	40 08       	lddsp	r8,sp[0x0]
80002d4c:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d4e:	40 2a       	lddsp	r10,sp[0x8]
80002d50:	40 19       	lddsp	r9,sp[0x4]
80002d52:	12 0a       	add	r10,r9
80002d54:	0e 99       	mov	r9,r7
80002d56:	20 19       	sub	r9,1
80002d58:	5c 79       	castu.h	r9
80002d5a:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002d5c:	11 39       	ld.ub	r9,r8++
80002d5e:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002d60:	14 33       	cp.w	r3,r10
80002d62:	cf d1       	brne	80002d5c <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002d64:	e0 6a 10 00 	mov	r10,4096
80002d68:	04 9b       	mov	r11,r2
80002d6a:	08 9c       	mov	r12,r4
80002d6c:	f0 1f 00 14 	mcall	80002dbc <data_flash_write+0xec>
80002d70:	c0 78       	rjmp	80002d7e <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002d72:	0e 9a       	mov	r10,r7
80002d74:	5c 7a       	castu.h	r10
80002d76:	02 9b       	mov	r11,r1
80002d78:	40 0c       	lddsp	r12,sp[0x0]
80002d7a:	f0 1f 00 11 	mcall	80002dbc <data_flash_write+0xec>
80002d7e:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002d82:	0e 98       	mov	r8,r7
80002d84:	ee 05 19 00 	cp.h	r5,r7
80002d88:	c1 20       	breq	80002dac <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002d8a:	5c 78       	castu.h	r8
80002d8c:	40 0a       	lddsp	r10,sp[0x0]
80002d8e:	10 0a       	add	r10,r8
80002d90:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002d92:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002d94:	0e 15       	sub	r5,r7
80002d96:	5c 85       	casts.h	r5
80002d98:	e0 05 19 00 	cp.h	r5,r0
80002d9c:	ea 07 17 80 	movls	r7,r5
80002da0:	e0 07 17 b0 	movhi	r7,r0
80002da4:	5c 87       	casts.h	r7
80002da6:	30 09       	mov	r9,0
80002da8:	50 19       	stdsp	sp[0x4],r9
80002daa:	ca db       	rjmp	80002d04 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002dac:	2f dd       	sub	sp,-12
80002dae:	d8 32       	popm	r0-r7,pc
80002db0:	00 00       	add	r0,r0
80002db2:	0d 84       	ld.ub	r4,r6[0x0]
80002db4:	80 00       	ld.sh	r0,r0[0x0]
80002db6:	2a a0       	sub	r0,-86
80002db8:	80 00       	ld.sh	r0,r0[0x0]
80002dba:	2c 34       	sub	r4,-61
80002dbc:	80 00       	ld.sh	r0,r0[0x0]
80002dbe:	2b 74       	sub	r4,-73

80002dc0 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002dc0:	eb cd 40 c0 	pushm	r6-r7,lr
80002dc4:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002dc6:	4b f8       	lddpc	r8,80002ec0 <data_flash_init+0x100>
80002dc8:	fa c6 ff fc 	sub	r6,sp,-4
80002dcc:	f0 ea 00 00 	ld.d	r10,r8[0]
80002dd0:	ec eb 00 00 	st.d	r6[0],r10
80002dd4:	f0 e8 00 08 	ld.d	r8,r8[8]
80002dd8:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002ddc:	30 4b       	mov	r11,4
80002dde:	4b ac       	lddpc	r12,80002ec4 <data_flash_init+0x104>
80002de0:	f0 1f 00 3a 	mcall	80002ec8 <data_flash_init+0x108>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002de4:	31 9c       	mov	r12,25
80002de6:	f0 1f 00 3a 	mcall	80002ecc <data_flash_init+0x10c>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002dea:	31 9c       	mov	r12,25
80002dec:	f0 1f 00 39 	mcall	80002ed0 <data_flash_init+0x110>

	spi = &AVR32_SPI;
80002df0:	4b 97       	lddpc	r7,80002ed4 <data_flash_init+0x114>
80002df2:	fe 7c 24 00 	mov	r12,-56320
80002df6:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002df8:	0c 9b       	mov	r11,r6
80002dfa:	f0 1f 00 38 	mcall	80002ed8 <data_flash_init+0x118>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002dfe:	30 09       	mov	r9,0
80002e00:	12 9a       	mov	r10,r9
80002e02:	12 9b       	mov	r11,r9
80002e04:	6e 0c       	ld.w	r12,r7[0x0]
80002e06:	f0 1f 00 36 	mcall	80002edc <data_flash_init+0x11c>

	// Enable SPI.
	spi_enable(spi);
80002e0a:	6e 0c       	ld.w	r12,r7[0x0]
80002e0c:	f0 1f 00 35 	mcall	80002ee0 <data_flash_init+0x120>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002e10:	e0 6a 36 00 	mov	r10,13824
80002e14:	ea 1a 01 6e 	orh	r10,0x16e
80002e18:	0c 9b       	mov	r11,r6
80002e1a:	6e 0c       	ld.w	r12,r7[0x0]
80002e1c:	f0 1f 00 32 	mcall	80002ee4 <data_flash_init+0x124>
80002e20:	c0 50       	breq	80002e2a <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002e22:	30 29       	mov	r9,2
80002e24:	4b 18       	lddpc	r8,80002ee8 <data_flash_init+0x128>
80002e26:	b0 89       	st.b	r8[0x0],r9
		return;
80002e28:	c4 88       	rjmp	80002eb8 <data_flash_init+0xf8>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002e2a:	1a 96       	mov	r6,sp
80002e2c:	30 4a       	mov	r10,4
80002e2e:	4b 0b       	lddpc	r11,80002eec <data_flash_init+0x12c>
80002e30:	1a 9c       	mov	r12,sp
80002e32:	f0 1f 00 30 	mcall	80002ef0 <data_flash_init+0x130>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002e36:	4a 87       	lddpc	r7,80002ed4 <data_flash_init+0x114>
80002e38:	30 0b       	mov	r11,0
80002e3a:	6e 0c       	ld.w	r12,r7[0x0]
80002e3c:	f0 1f 00 2e 	mcall	80002ef4 <data_flash_init+0x134>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002e40:	e0 6b 00 9f 	mov	r11,159
80002e44:	6e 0c       	ld.w	r12,r7[0x0]
80002e46:	f0 1f 00 2d 	mcall	80002ef8 <data_flash_init+0x138>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002e4a:	e0 6b 00 ff 	mov	r11,255
80002e4e:	6e 0c       	ld.w	r12,r7[0x0]
80002e50:	f0 1f 00 2a 	mcall	80002ef8 <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[0]);
80002e54:	1a 9b       	mov	r11,sp
80002e56:	6e 0c       	ld.w	r12,r7[0x0]
80002e58:	f0 1f 00 29 	mcall	80002efc <data_flash_init+0x13c>
	spi_write_dummy();
80002e5c:	e0 6b 00 ff 	mov	r11,255
80002e60:	6e 0c       	ld.w	r12,r7[0x0]
80002e62:	f0 1f 00 26 	mcall	80002ef8 <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[1]);
80002e66:	fa cb ff fe 	sub	r11,sp,-2
80002e6a:	6e 0c       	ld.w	r12,r7[0x0]
80002e6c:	f0 1f 00 24 	mcall	80002efc <data_flash_init+0x13c>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002e70:	30 0b       	mov	r11,0
80002e72:	6e 0c       	ld.w	r12,r7[0x0]
80002e74:	f0 1f 00 23 	mcall	80002f00 <data_flash_init+0x140>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002e78:	31 f8       	mov	r8,31
80002e7a:	9a 09       	ld.sh	r9,sp[0x0]
80002e7c:	f0 09 19 00 	cp.h	r9,r8
80002e80:	c0 61       	brne	80002e8c <data_flash_init+0xcc>
80002e82:	34 88       	mov	r8,72
80002e84:	9a 19       	ld.sh	r9,sp[0x2]
80002e86:	f0 09 19 00 	cp.h	r9,r8
80002e8a:	c0 50       	breq	80002e94 <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002e8c:	30 39       	mov	r9,3
80002e8e:	49 78       	lddpc	r8,80002ee8 <data_flash_init+0x128>
80002e90:	b0 89       	st.b	r8[0x0],r9
		return;
80002e92:	c1 38       	rjmp	80002eb8 <data_flash_init+0xf8>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e94:	30 09       	mov	r9,0
80002e96:	12 9a       	mov	r10,r9
80002e98:	12 9b       	mov	r11,r9
80002e9a:	30 6c       	mov	r12,6
80002e9c:	f0 1f 00 1a 	mcall	80002f04 <data_flash_init+0x144>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002ea0:	30 09       	mov	r9,0
80002ea2:	12 9a       	mov	r10,r9
80002ea4:	12 9b       	mov	r11,r9
80002ea6:	30 1c       	mov	r12,1
80002ea8:	f0 1f 00 17 	mcall	80002f04 <data_flash_init+0x144>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002eac:	30 09       	mov	r9,0
80002eae:	12 9a       	mov	r10,r9
80002eb0:	12 9b       	mov	r11,r9
80002eb2:	30 5c       	mov	r12,5
80002eb4:	f0 1f 00 14 	mcall	80002f04 <data_flash_init+0x144>
	
	return;
}
80002eb8:	2f bd       	sub	sp,-20
80002eba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ebe:	00 00       	add	r0,r0
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	d3 24       	*unknown*
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	d3 38       	*unknown*
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	53 e8       	stdsp	sp[0xf8],r8
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	54 18       	stdsp	sp[0x104],r8
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	54 30       	stdsp	sp[0x10c],r0
80002ed4:	00 00       	add	r0,r0
80002ed6:	1d 84       	ld.ub	r4,lr[0x0]
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	55 7c       	stdsp	sp[0x15c],r12
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	55 b4       	stdsp	sp[0x16c],r4
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	57 0c       	stdsp	sp[0x1c0],r12
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	56 54       	stdsp	sp[0x194],r4
80002ee8:	00 00       	add	r0,r0
80002eea:	0a 5c       	eor	r12,r5
80002eec:	80 00       	ld.sh	r0,r0[0x0]
80002eee:	d3 34       	*unknown*
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	74 ca       	ld.w	r10,r10[0x30]
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	55 e0       	stdsp	sp[0x178],r0
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	57 12       	stdsp	sp[0x1c4],r2
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	57 2e       	stdsp	sp[0x1c8],lr
80002f00:	80 00       	ld.sh	r0,r0[0x0]
80002f02:	56 2c       	stdsp	sp[0x188],r12
80002f04:	80 00       	ld.sh	r0,r0[0x0]
80002f06:	28 e4       	sub	r4,-114

80002f08 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002f08:	20 1c       	sub	r12,1
80002f0a:	5c 5c       	castu.b	r12
80002f0c:	31 18       	mov	r8,17
80002f0e:	f0 0c 18 00 	cp.b	r12,r8
80002f12:	e0 88 00 03 	brls	80002f18 <CalculateBurst+0x10>
80002f16:	5e fd       	retal	0
80002f18:	48 28       	lddpc	r8,80002f20 <CalculateBurst+0x18>
80002f1a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002f1e:	5e fc       	retal	r12
80002f20:	80 00       	ld.sh	r0,r0[0x0]
80002f22:	d3 60       	acall	0x36

80002f24 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002f24:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002f26:	48 98       	lddpc	r8,80002f48 <payload_init+0x24>
80002f28:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002f2a:	48 98       	lddpc	r8,80002f4c <payload_init+0x28>
80002f2c:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002f2e:	30 09       	mov	r9,0
80002f30:	1a d9       	st.w	--sp,r9
80002f32:	1a d9       	st.w	--sp,r9
80002f34:	1a d9       	st.w	--sp,r9
80002f36:	30 28       	mov	r8,2
80002f38:	e0 6a 04 00 	mov	r10,1024
80002f3c:	48 5b       	lddpc	r11,80002f50 <payload_init+0x2c>
80002f3e:	48 6c       	lddpc	r12,80002f54 <payload_init+0x30>
80002f40:	f0 1f 00 06 	mcall	80002f58 <payload_init+0x34>
80002f44:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002f46:	d8 02       	popm	pc
80002f48:	00 00       	add	r0,r0
80002f4a:	0a 60       	and	r0,r5
80002f4c:	00 00       	add	r0,r0
80002f4e:	0a 64       	and	r4,r5
80002f50:	80 00       	ld.sh	r0,r0[0x0]
80002f52:	d9 58       	*unknown*
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	2f 5c       	sub	r12,-11
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	68 4c       	ld.w	r12,r4[0x10]

80002f5c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002f5c:	eb cd 40 f8 	pushm	r3-r7,lr
80002f60:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002f62:	48 e8       	lddpc	r8,80002f98 <payload_rx_process+0x3c>
80002f64:	70 08       	ld.w	r8,r8[0x0]
80002f66:	58 08       	cp.w	r8,0
80002f68:	c0 71       	brne	80002f76 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f6a:	30 4b       	mov	r11,4
80002f6c:	30 5c       	mov	r12,5
80002f6e:	f0 1f 00 0c 	mcall	80002f9c <payload_rx_process+0x40>
80002f72:	48 a8       	lddpc	r8,80002f98 <payload_rx_process+0x3c>
80002f74:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f76:	48 96       	lddpc	r6,80002f98 <payload_rx_process+0x3c>
80002f78:	30 05       	mov	r5,0
80002f7a:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f7c:	48 93       	lddpc	r3,80002fa0 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f7e:	6c 0c       	ld.w	r12,r6[0x0]
80002f80:	0a 99       	mov	r9,r5
80002f82:	08 9a       	mov	r10,r4
80002f84:	1a 9b       	mov	r11,sp
80002f86:	f0 1f 00 08 	mcall	80002fa4 <payload_rx_process+0x48>
80002f8a:	58 1c       	cp.w	r12,1
80002f8c:	cf 91       	brne	80002f7e <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f8e:	66 08       	ld.w	r8,r3[0x0]
80002f90:	40 0c       	lddsp	r12,sp[0x0]
80002f92:	5d 18       	icall	r8
80002f94:	cf 5b       	rjmp	80002f7e <payload_rx_process+0x22>
80002f96:	00 00       	add	r0,r0
80002f98:	00 00       	add	r0,r0
80002f9a:	0a 90       	mov	r0,r5
80002f9c:	80 00       	ld.sh	r0,r0[0x0]
80002f9e:	61 78       	ld.w	r8,r0[0x5c]
80002fa0:	00 00       	add	r0,r0
80002fa2:	0a 60       	and	r0,r5
80002fa4:	80 00       	ld.sh	r0,r0[0x0]
80002fa6:	5e 6c       	retmi	r12

80002fa8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002fa8:	d4 01       	pushm	lr
80002faa:	20 2d       	sub	sp,8
80002fac:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fae:	30 09       	mov	r9,0
80002fb0:	fa ca ff f8 	sub	r10,sp,-8
80002fb4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002fb6:	1a 9b       	mov	r11,sp
80002fb8:	f0 1f 00 02 	mcall	80002fc0 <set_idle_store_isr+0x18>
}
80002fbc:	2f ed       	sub	sp,-8
80002fbe:	d8 02       	popm	pc
80002fc0:	80 00       	ld.sh	r0,r0[0x0]
80002fc2:	60 28       	ld.w	r8,r0[0x8]

80002fc4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002fc4:	d4 01       	pushm	lr
80002fc6:	20 2d       	sub	sp,8
80002fc8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002fca:	58 0c       	cp.w	r12,0
80002fcc:	c1 10       	breq	80002fee <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fce:	30 08       	mov	r8,0
80002fd0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002fd2:	98 88       	ld.uh	r8,r12[0x0]
80002fd4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002fd8:	e0 48 40 00 	cp.w	r8,16384
80002fdc:	c0 91       	brne	80002fee <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002fde:	48 68       	lddpc	r8,80002ff4 <phy_rx+0x30>
80002fe0:	70 0c       	ld.w	r12,r8[0x0]
80002fe2:	30 09       	mov	r9,0
80002fe4:	fa ca ff fc 	sub	r10,sp,-4
80002fe8:	1a 9b       	mov	r11,sp
80002fea:	f0 1f 00 04 	mcall	80002ff8 <phy_rx+0x34>
		}	

    }
		
 
}
80002fee:	2f ed       	sub	sp,-8
80002ff0:	d8 02       	popm	pc
80002ff2:	00 00       	add	r0,r0
80002ff4:	00 00       	add	r0,r0
80002ff6:	0a c0       	st.b	r5++,r0
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	60 28       	ld.w	r8,r0[0x8]

80002ffc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002ffc:	eb cd 40 80 	pushm	r7,lr
80003000:	20 1d       	sub	sp,4
80003002:	fa c7 ff fc 	sub	r7,sp,-4
80003006:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003008:	30 09       	mov	r9,0
8000300a:	12 9a       	mov	r10,r9
8000300c:	1a 9b       	mov	r11,sp
8000300e:	f0 1f 00 03 	mcall	80003018 <set_idle_store+0x1c>
}
80003012:	2f fd       	sub	sp,-4
80003014:	e3 cd 80 80 	ldm	sp++,r7,pc
80003018:	80 00       	ld.sh	r0,r0[0x0]
8000301a:	60 78       	ld.w	r8,r0[0x1c]

8000301c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
8000301c:	d4 01       	pushm	lr
8000301e:	20 1d       	sub	sp,4
80003020:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003022:	98 88       	ld.uh	r8,r12[0x0]
80003024:	e2 18 f0 00 	andl	r8,0xf000,COH
80003028:	e0 48 40 00 	cp.w	r8,16384
8000302c:	c0 d1       	brne	80003046 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
8000302e:	49 08       	lddpc	r8,8000306c <phy_tx+0x50>
80003030:	70 08       	ld.w	r8,r8[0x0]
80003032:	58 08       	cp.w	r8,0
80003034:	c1 a0       	breq	80003068 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003036:	48 e8       	lddpc	r8,8000306c <phy_tx+0x50>
80003038:	70 0c       	ld.w	r12,r8[0x0]
8000303a:	30 09       	mov	r9,0
8000303c:	12 9a       	mov	r10,r9
8000303e:	1a 9b       	mov	r11,sp
80003040:	f0 1f 00 0c 	mcall	80003070 <phy_tx+0x54>
80003044:	c1 28       	rjmp	80003068 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003046:	e0 48 10 00 	cp.w	r8,4096
8000304a:	5f 0a       	sreq	r10
8000304c:	e0 48 20 00 	cp.w	r8,8192
80003050:	5f 09       	sreq	r9
80003052:	f5 e9 10 09 	or	r9,r10,r9
80003056:	c0 71       	brne	80003064 <phy_tx+0x48>
80003058:	e0 48 50 00 	cp.w	r8,20480
8000305c:	c0 40       	breq	80003064 <phy_tx+0x48>
8000305e:	e0 48 60 00 	cp.w	r8,24576
80003062:	c0 31       	brne	80003068 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003064:	48 48       	lddpc	r8,80003074 <phy_tx+0x58>
80003066:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003068:	2f fd       	sub	sp,-4
8000306a:	d8 02       	popm	pc
8000306c:	00 00       	add	r0,r0
8000306e:	0a cc       	st.b	r5++,r12
80003070:	80 00       	ld.sh	r0,r0[0x0]
80003072:	60 78       	ld.w	r8,r0[0x1c]
80003074:	00 00       	add	r0,r0
80003076:	0a bc       	st.h	r5++,r12

80003078 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003078:	d4 01       	pushm	lr
8000307a:	20 2d       	sub	sp,8
	void * ptr = NULL;
8000307c:	30 08       	mov	r8,0
8000307e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003080:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003082:	1a 9a       	mov	r10,sp
80003084:	fa cb ff fc 	sub	r11,sp,-4
80003088:	f0 1f 00 05 	mcall	8000309c <get_idle_store_isr+0x24>
8000308c:	58 1c       	cp.w	r12,1
8000308e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003092:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003096:	2f ed       	sub	sp,-8
80003098:	d8 02       	popm	pc
8000309a:	00 00       	add	r0,r0
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	5d 7c       	*unknown*

800030a0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
800030a0:	eb cd 40 c0 	pushm	r6-r7,lr
800030a4:	20 1d       	sub	sp,4
800030a6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
800030a8:	fe f8 04 70 	ld.w	r8,pc[1136]
800030ac:	70 08       	ld.w	r8,r8[0x0]
800030ae:	58 08       	cp.w	r8,0
800030b0:	c7 40       	breq	80003198 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
800030b2:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800030b4:	30 08       	mov	r8,0
800030b6:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800030b8:	fe f8 04 64 	ld.w	r8,pc[1124]
800030bc:	70 08       	ld.w	r8,r8[0x0]
800030be:	58 18       	cp.w	r8,1
800030c0:	c2 90       	breq	80003112 <phy_tx_func+0x72>
800030c2:	c0 43       	brcs	800030ca <phy_tx_func+0x2a>
800030c4:	58 28       	cp.w	r8,2
800030c6:	c6 91       	brne	80003198 <phy_tx_func+0xf8>
800030c8:	c6 18       	rjmp	8000318a <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800030ca:	fe f8 04 4e 	ld.w	r8,pc[1102]
800030ce:	70 0c       	ld.w	r12,r8[0x0]
800030d0:	1a 9a       	mov	r10,sp
800030d2:	fe fb 04 4e 	ld.w	r11,pc[1102]
800030d6:	f0 1f 01 14 	mcall	80003524 <phy_tx_func+0x484>
800030da:	58 1c       	cp.w	r12,1
800030dc:	c1 51       	brne	80003106 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800030de:	fe f8 04 42 	ld.w	r8,pc[1090]
800030e2:	70 08       	ld.w	r8,r8[0x0]
800030e4:	11 9a       	ld.ub	r10,r8[0x1]
800030e6:	fe f9 04 42 	ld.w	r9,pc[1090]
800030ea:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800030ec:	90 88       	ld.uh	r8,r8[0x0]
800030ee:	ea 18 ab cd 	orh	r8,0xabcd
800030f2:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800030f4:	30 19       	mov	r9,1
800030f6:	fe f8 04 36 	ld.w	r8,pc[1078]
800030fa:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800030fc:	30 19       	mov	r9,1
800030fe:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003102:	91 09       	st.w	r8[0x0],r9
80003104:	c4 a8       	rjmp	80003198 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003106:	e0 68 5a 5a 	mov	r8,23130
8000310a:	ea 18 ab cd 	orh	r8,0xabcd
8000310e:	8f 18       	st.w	r7[0x4],r8
80003110:	c4 48       	rjmp	80003198 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003112:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003116:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003118:	fe fa 04 08 	ld.w	r10,pc[1032]
8000311c:	74 0a       	ld.w	r10,r10[0x0]
8000311e:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003122:	b1 6a       	lsl	r10,0x10
80003124:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003126:	2f f8       	sub	r8,-1
80003128:	5c 58       	castu.b	r8
8000312a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000312c:	fe fa 03 fc 	ld.w	r10,pc[1020]
80003130:	94 09       	ld.sh	r9,r10[0x0]
80003132:	20 29       	sub	r9,2
80003134:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003136:	30 0a       	mov	r10,0
80003138:	f4 09 19 00 	cp.h	r9,r10
8000313c:	e0 89 00 0b 	brgt	80003152 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003140:	78 18       	ld.w	r8,r12[0x4]
80003142:	e8 18 00 ba 	orl	r8,0xba
80003146:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003148:	30 09       	mov	r9,0
8000314a:	fe f8 03 d2 	ld.w	r8,pc[978]
8000314e:	91 09       	st.w	r8[0x0],r9
80003150:	c2 48       	rjmp	80003198 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003152:	fe f9 03 ce 	ld.w	r9,pc[974]
80003156:	72 09       	ld.w	r9,r9[0x0]
80003158:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
8000315c:	78 1a       	ld.w	r10,r12[0x4]
8000315e:	f5 e9 10 09 	or	r9,r10,r9
80003162:	99 19       	st.w	r12[0x4],r9
80003164:	2f f8       	sub	r8,-1
80003166:	fe f9 03 c6 	ld.w	r9,pc[966]
8000316a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000316c:	fe f9 03 bc 	ld.w	r9,pc[956]
80003170:	92 08       	ld.sh	r8,r9[0x0]
80003172:	20 28       	sub	r8,2
80003174:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003176:	30 09       	mov	r9,0
80003178:	f2 08 19 00 	cp.h	r8,r9
8000317c:	e0 89 00 0e 	brgt	80003198 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003180:	30 29       	mov	r9,2
80003182:	fe f8 03 9a 	ld.w	r8,pc[922]
80003186:	91 09       	st.w	r8[0x0],r9
80003188:	c0 88       	rjmp	80003198 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000318a:	fc 18 00 ba 	movh	r8,0xba
8000318e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003190:	30 09       	mov	r9,0
80003192:	fe f8 03 8a 	ld.w	r8,pc[906]
80003196:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80003198:	fe f8 03 98 	ld.w	r8,pc[920]
8000319c:	11 89       	ld.ub	r9,r8[0x0]
8000319e:	30 18       	mov	r8,1
800031a0:	f0 09 18 00 	cp.b	r9,r8
800031a4:	e0 81 01 af 	brne	80003502 <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
800031a8:	fe f8 03 8c 	ld.w	r8,pc[908]
800031ac:	70 08       	ld.w	r8,r8[0x0]
800031ae:	e0 48 05 b0 	cp.w	r8,1456
800031b2:	f9 b8 02 00 	movhs	r8,0
800031b6:	fe f9 03 7e 	ld.w	r9,pc[894]
800031ba:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
800031bc:	fe f8 03 7c 	ld.w	r8,pc[892]
800031c0:	70 08       	ld.w	r8,r8[0x0]
800031c2:	58 68       	cp.w	r8,6
800031c4:	e0 8b 01 95 	brhi	800034ee <phy_tx_func+0x44e>
800031c8:	fe f9 03 74 	ld.w	r9,pc[884]
800031cc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
800031d0:	fe f8 03 70 	ld.w	r8,pc[880]
800031d4:	70 08       	ld.w	r8,r8[0x0]
800031d6:	58 08       	cp.w	r8,0
800031d8:	c0 b0       	breq	800031ee <phy_tx_func+0x14e>
800031da:	fe f8 03 66 	ld.w	r8,pc[870]
800031de:	70 08       	ld.w	r8,r8[0x0]
800031e0:	58 a8       	cp.w	r8,10
800031e2:	c0 60       	breq	800031ee <phy_tx_func+0x14e>
800031e4:	fe f8 03 5c 	ld.w	r8,pc[860]
800031e8:	70 08       	ld.w	r8,r8[0x0]
800031ea:	58 18       	cp.w	r8,1
800031ec:	c0 a1       	brne	80003200 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800031ee:	e0 68 5a 5a 	mov	r8,23130
800031f2:	ea 18 ab cd 	orh	r8,0xabcd
800031f6:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800031f8:	30 08       	mov	r8,0
800031fa:	8f 38       	st.w	r7[0xc],r8
800031fc:	e0 8f 01 8a 	bral	80003510 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003200:	fe f8 03 40 	ld.w	r8,pc[832]
80003204:	70 08       	ld.w	r8,r8[0x0]
80003206:	58 38       	cp.w	r8,3
80003208:	c0 91       	brne	8000321a <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
8000320a:	fe f8 03 3a 	ld.w	r8,pc[826]
8000320e:	70 09       	ld.w	r9,r8[0x0]
80003210:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003212:	70 18       	ld.w	r8,r8[0x4]
80003214:	8f 38       	st.w	r7[0xc],r8
80003216:	e0 8f 01 7d 	bral	80003510 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
8000321a:	fe f8 03 26 	ld.w	r8,pc[806]
8000321e:	70 08       	ld.w	r8,r8[0x0]
80003220:	58 28       	cp.w	r8,2
80003222:	c1 31       	brne	80003248 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80003224:	e0 68 c0 32 	mov	r8,49202
80003228:	ea 18 ab cd 	orh	r8,0xabcd
8000322c:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
8000322e:	fe 78 84 7f 	mov	r8,-31617
80003232:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80003234:	fe f8 03 14 	ld.w	r8,pc[788]
80003238:	90 08       	ld.sh	r8,r8[0x0]
8000323a:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
8000323c:	30 39       	mov	r9,3
8000323e:	fe f8 02 fa 	ld.w	r8,pc[762]
80003242:	91 09       	st.w	r8[0x0],r9
80003244:	e0 8f 01 66 	bral	80003510 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003248:	e0 68 c0 0e 	mov	r8,49166
8000324c:	ea 18 ab cd 	orh	r8,0xabcd
80003250:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80003252:	fe f8 02 fa 	ld.w	r8,pc[762]
80003256:	90 09       	ld.sh	r9,r8[0x0]
80003258:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
8000325a:	90 18       	ld.sh	r8,r8[0x2]
8000325c:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
8000325e:	30 19       	mov	r9,1
80003260:	fe f8 02 d8 	ld.w	r8,pc[728]
80003264:	91 09       	st.w	r8[0x0],r9
80003266:	e0 8f 01 55 	bral	80003510 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
8000326a:	fe 78 88 f2 	mov	r8,-30478
8000326e:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80003270:	fe f8 02 d0 	ld.w	r8,pc[720]
80003274:	70 08       	ld.w	r8,r8[0x0]
80003276:	58 48       	cp.w	r8,4
80003278:	c0 60       	breq	80003284 <phy_tx_func+0x1e4>
8000327a:	c4 53       	brcs	80003304 <phy_tx_func+0x264>
8000327c:	58 98       	cp.w	r8,9
8000327e:	e0 8b 00 43 	brhi	80003304 <phy_tx_func+0x264>
80003282:	c2 98       	rjmp	800032d4 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003284:	fe f8 02 cc 	ld.w	r8,pc[716]
80003288:	11 89       	ld.ub	r9,r8[0x0]
8000328a:	30 18       	mov	r8,1
8000328c:	f0 09 18 00 	cp.b	r9,r8
80003290:	c0 a1       	brne	800032a4 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003292:	fe f8 02 c2 	ld.w	r8,pc[706]
80003296:	90 09       	ld.sh	r9,r8[0x0]
80003298:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
8000329a:	90 19       	ld.sh	r9,r8[0x2]
8000329c:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
8000329e:	90 28       	ld.sh	r8,r8[0x4]
800032a0:	ae 78       	st.h	r7[0xe],r8
800032a2:	c1 48       	rjmp	800032ca <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032a4:	fe f9 02 b4 	ld.w	r9,pc[692]
800032a8:	92 0b       	ld.sh	r11,r9[0x0]
800032aa:	fe f8 02 aa 	ld.w	r8,pc[682]
800032ae:	90 0a       	ld.sh	r10,r8[0x0]
800032b0:	f7 ea 20 0a 	eor	r10,r11,r10
800032b4:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800032b6:	92 1b       	ld.sh	r11,r9[0x2]
800032b8:	90 1a       	ld.sh	r10,r8[0x2]
800032ba:	f7 ea 20 0a 	eor	r10,r11,r10
800032be:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032c0:	92 29       	ld.sh	r9,r9[0x4]
800032c2:	90 28       	ld.sh	r8,r8[0x4]
800032c4:	f3 e8 20 08 	eor	r8,r9,r8
800032c8:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032ca:	30 29       	mov	r9,2
800032cc:	fe f8 02 6c 	ld.w	r8,pc[620]
800032d0:	91 09       	st.w	r8[0x0],r9
800032d2:	c1 f9       	rjmp	80003510 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
800032d4:	fe f9 02 84 	ld.w	r9,pc[644]
800032d8:	92 0b       	ld.sh	r11,r9[0x0]
800032da:	fe f8 02 7a 	ld.w	r8,pc[634]
800032de:	90 0a       	ld.sh	r10,r8[0x0]
800032e0:	f7 ea 20 0a 	eor	r10,r11,r10
800032e4:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
800032e6:	92 1b       	ld.sh	r11,r9[0x2]
800032e8:	90 1a       	ld.sh	r10,r8[0x2]
800032ea:	f7 ea 20 0a 	eor	r10,r11,r10
800032ee:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
800032f0:	92 29       	ld.sh	r9,r9[0x4]
800032f2:	90 28       	ld.sh	r8,r8[0x4]
800032f4:	f3 e8 20 08 	eor	r8,r9,r8
800032f8:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
800032fa:	30 29       	mov	r9,2
800032fc:	fe f8 02 3c 	ld.w	r8,pc[572]
80003300:	91 09       	st.w	r8[0x0],r9
80003302:	c0 79       	rjmp	80003510 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003304:	e0 68 5a 5a 	mov	r8,23130
80003308:	ea 18 ab cd 	orh	r8,0xabcd
8000330c:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000330e:	30 08       	mov	r8,0
80003310:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80003312:	fe f9 02 26 	ld.w	r9,pc[550]
80003316:	93 08       	st.w	r9[0x0],r8
80003318:	cf c8       	rjmp	80003510 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
8000331a:	fe f8 02 3e 	ld.w	r8,pc[574]
8000331e:	90 38       	ld.sh	r8,r8[0x6]
80003320:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80003322:	e0 68 00 ba 	mov	r8,186
80003326:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003328:	30 08       	mov	r8,0
8000332a:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
8000332c:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
8000332e:	30 09       	mov	r9,0
80003330:	fe f8 02 08 	ld.w	r8,pc[520]
80003334:	91 09       	st.w	r8[0x0],r9
80003336:	ce d8       	rjmp	80003510 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80003338:	fe f8 02 10 	ld.w	r8,pc[528]
8000333c:	90 18       	ld.sh	r8,r8[0x2]
8000333e:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80003340:	fe f8 02 0c 	ld.w	r8,pc[524]
80003344:	90 08       	ld.sh	r8,r8[0x0]
80003346:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80003348:	4f e8       	lddpc	r8,80003540 <phy_tx_func+0x4a0>
8000334a:	70 08       	ld.w	r8,r8[0x0]
8000334c:	58 48       	cp.w	r8,4
8000334e:	c0 d1       	brne	80003368 <phy_tx_func+0x2c8>
80003350:	fe f8 02 00 	ld.w	r8,pc[512]
80003354:	11 89       	ld.ub	r9,r8[0x0]
80003356:	30 18       	mov	r8,1
80003358:	f0 09 18 00 	cp.b	r9,r8
8000335c:	c0 61       	brne	80003368 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
8000335e:	4f c8       	lddpc	r8,8000354c <phy_tx_func+0x4ac>
80003360:	90 18       	ld.sh	r8,r8[0x2]
80003362:	a9 a8       	sbr	r8,0x8
80003364:	ae 68       	st.h	r7[0xc],r8
80003366:	c0 48       	rjmp	8000336e <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80003368:	4f 98       	lddpc	r8,8000354c <phy_tx_func+0x4ac>
8000336a:	90 18       	ld.sh	r8,r8[0x2]
8000336c:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
8000336e:	fe 78 9a 13 	mov	r8,-26093
80003372:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80003374:	30 49       	mov	r9,4
80003376:	4f 18       	lddpc	r8,80003538 <phy_tx_func+0x498>
80003378:	91 09       	st.w	r8[0x0],r9
8000337a:	cc b8       	rjmp	80003510 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
8000337c:	4f 88       	lddpc	r8,8000355c <phy_tx_func+0x4bc>
8000337e:	70 0a       	ld.w	r10,r8[0x0]
80003380:	4f 89       	lddpc	r9,80003560 <phy_tx_func+0x4c0>
80003382:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003386:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80003388:	70 0a       	ld.w	r10,r8[0x0]
8000338a:	2f fa       	sub	r10,-1
8000338c:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80003390:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80003392:	70 0a       	ld.w	r10,r8[0x0]
80003394:	2f ea       	sub	r10,-2
80003396:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000339a:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
8000339c:	70 0a       	ld.w	r10,r8[0x0]
8000339e:	2f da       	sub	r10,-3
800033a0:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033a4:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
800033a6:	70 09       	ld.w	r9,r8[0x0]
800033a8:	2f c9       	sub	r9,-4
800033aa:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
800033ac:	58 c9       	cp.w	r9,12
800033ae:	c0 51       	brne	800033b8 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
800033b0:	30 59       	mov	r9,5
800033b2:	4e 28       	lddpc	r8,80003538 <phy_tx_func+0x498>
800033b4:	91 09       	st.w	r8[0x0],r9
800033b6:	ca d8       	rjmp	80003510 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
800033b8:	30 49       	mov	r9,4
800033ba:	4e 08       	lddpc	r8,80003538 <phy_tx_func+0x498>
800033bc:	91 09       	st.w	r8[0x0],r9
800033be:	ca 98       	rjmp	80003510 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
800033c0:	4e 78       	lddpc	r8,8000355c <phy_tx_func+0x4bc>
800033c2:	70 0a       	ld.w	r10,r8[0x0]
800033c4:	4e 79       	lddpc	r9,80003560 <phy_tx_func+0x4c0>
800033c6:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033ca:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
800033cc:	30 09       	mov	r9,0
800033ce:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
800033d0:	fe 78 80 03 	mov	r8,-32765
800033d4:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
800033d6:	fe 78 88 f3 	mov	r8,-30477
800033da:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
800033dc:	4d 98       	lddpc	r8,80003540 <phy_tx_func+0x4a0>
800033de:	70 08       	ld.w	r8,r8[0x0]
800033e0:	58 48       	cp.w	r8,4
800033e2:	c0 60       	breq	800033ee <phy_tx_func+0x34e>
800033e4:	c2 83       	brcs	80003434 <phy_tx_func+0x394>
800033e6:	58 98       	cp.w	r8,9
800033e8:	e0 8b 00 26 	brhi	80003434 <phy_tx_func+0x394>
800033ec:	c1 98       	rjmp	8000341e <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
800033ee:	4d 98       	lddpc	r8,80003550 <phy_tx_func+0x4b0>
800033f0:	11 89       	ld.ub	r9,r8[0x0]
800033f2:	30 18       	mov	r8,1
800033f4:	f0 09 18 00 	cp.b	r9,r8
800033f8:	c0 81       	brne	80003408 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
800033fa:	4d 88       	lddpc	r8,80003558 <phy_tx_func+0x4b8>
800033fc:	90 0a       	ld.sh	r10,r8[0x0]
800033fe:	4d a9       	lddpc	r9,80003564 <phy_tx_func+0x4c4>
80003400:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80003402:	90 08       	ld.sh	r8,r8[0x0]
80003404:	ae 78       	st.h	r7[0xe],r8
80003406:	c0 88       	rjmp	80003416 <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003408:	4d 78       	lddpc	r8,80003564 <phy_tx_func+0x4c4>
8000340a:	90 08       	ld.sh	r8,r8[0x0]
8000340c:	4d 39       	lddpc	r9,80003558 <phy_tx_func+0x4b8>
8000340e:	92 09       	ld.sh	r9,r9[0x0]
80003410:	f3 e8 20 08 	eor	r8,r9,r8
80003414:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80003416:	30 69       	mov	r9,6
80003418:	4c 88       	lddpc	r8,80003538 <phy_tx_func+0x498>
8000341a:	91 09       	st.w	r8[0x0],r9
8000341c:	c7 a8       	rjmp	80003510 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
8000341e:	4d 28       	lddpc	r8,80003564 <phy_tx_func+0x4c4>
80003420:	90 08       	ld.sh	r8,r8[0x0]
80003422:	4c e9       	lddpc	r9,80003558 <phy_tx_func+0x4b8>
80003424:	92 09       	ld.sh	r9,r9[0x0]
80003426:	f3 e8 20 08 	eor	r8,r9,r8
8000342a:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
8000342c:	30 69       	mov	r9,6
8000342e:	4c 38       	lddpc	r8,80003538 <phy_tx_func+0x498>
80003430:	91 09       	st.w	r8[0x0],r9
80003432:	c6 f8       	rjmp	80003510 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003434:	e0 68 5a 5a 	mov	r8,23130
80003438:	ea 18 ab cd 	orh	r8,0xabcd
8000343c:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000343e:	30 08       	mov	r8,0
80003440:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80003442:	4b e9       	lddpc	r9,80003538 <phy_tx_func+0x498>
80003444:	93 08       	st.w	r9[0x0],r8
80003446:	c6 58       	rjmp	80003510 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80003448:	4b e8       	lddpc	r8,80003540 <phy_tx_func+0x4a0>
8000344a:	70 08       	ld.w	r8,r8[0x0]
8000344c:	58 48       	cp.w	r8,4
8000344e:	c0 60       	breq	8000345a <phy_tx_func+0x3ba>
80003450:	c4 53       	brcs	800034da <phy_tx_func+0x43a>
80003452:	58 98       	cp.w	r8,9
80003454:	e0 8b 00 43 	brhi	800034da <phy_tx_func+0x43a>
80003458:	c2 d8       	rjmp	800034b2 <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
8000345a:	4b e8       	lddpc	r8,80003550 <phy_tx_func+0x4b0>
8000345c:	11 89       	ld.ub	r9,r8[0x0]
8000345e:	30 18       	mov	r8,1
80003460:	f0 09 18 00 	cp.b	r9,r8
80003464:	c1 31       	brne	8000348a <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80003466:	4b d8       	lddpc	r8,80003558 <phy_tx_func+0x4b8>
80003468:	90 1a       	ld.sh	r10,r8[0x2]
8000346a:	4b f9       	lddpc	r9,80003564 <phy_tx_func+0x4c4>
8000346c:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
8000346e:	90 2a       	ld.sh	r10,r8[0x4]
80003470:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80003472:	90 3a       	ld.sh	r10,r8[0x6]
80003474:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80003476:	90 19       	ld.sh	r9,r8[0x2]
80003478:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
8000347a:	90 29       	ld.sh	r9,r8[0x4]
8000347c:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
8000347e:	90 38       	ld.sh	r8,r8[0x6]
80003480:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80003482:	e0 68 00 ba 	mov	r8,186
80003486:	ae 78       	st.h	r7[0xe],r8
80003488:	c1 18       	rjmp	800034aa <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
8000348a:	4b 48       	lddpc	r8,80003558 <phy_tx_func+0x4b8>
8000348c:	90 1a       	ld.sh	r10,r8[0x2]
8000348e:	4b 69       	lddpc	r9,80003564 <phy_tx_func+0x4c4>
80003490:	92 1b       	ld.sh	r11,r9[0x2]
80003492:	f7 ea 20 0a 	eor	r10,r11,r10
80003496:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80003498:	90 2a       	ld.sh	r10,r8[0x4]
8000349a:	92 29       	ld.sh	r9,r9[0x4]
8000349c:	14 59       	eor	r9,r10
8000349e:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
800034a0:	90 38       	ld.sh	r8,r8[0x6]
800034a2:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
800034a4:	e0 68 00 ba 	mov	r8,186
800034a8:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
800034aa:	30 09       	mov	r9,0
800034ac:	4a 38       	lddpc	r8,80003538 <phy_tx_func+0x498>
800034ae:	91 09       	st.w	r8[0x0],r9
800034b0:	c3 08       	rjmp	80003510 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
800034b2:	4a a8       	lddpc	r8,80003558 <phy_tx_func+0x4b8>
800034b4:	90 1a       	ld.sh	r10,r8[0x2]
800034b6:	4a c9       	lddpc	r9,80003564 <phy_tx_func+0x4c4>
800034b8:	92 1b       	ld.sh	r11,r9[0x2]
800034ba:	f7 ea 20 0a 	eor	r10,r11,r10
800034be:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
800034c0:	90 2a       	ld.sh	r10,r8[0x4]
800034c2:	92 29       	ld.sh	r9,r9[0x4]
800034c4:	14 59       	eor	r9,r10
800034c6:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
800034c8:	90 38       	ld.sh	r8,r8[0x6]
800034ca:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
800034cc:	e0 68 00 ba 	mov	r8,186
800034d0:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
800034d2:	30 09       	mov	r9,0
800034d4:	49 98       	lddpc	r8,80003538 <phy_tx_func+0x498>
800034d6:	91 09       	st.w	r8[0x0],r9
800034d8:	c1 c8       	rjmp	80003510 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034da:	e0 68 5a 5a 	mov	r8,23130
800034de:	ea 18 ab cd 	orh	r8,0xabcd
800034e2:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034e4:	30 08       	mov	r8,0
800034e6:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
800034e8:	49 49       	lddpc	r9,80003538 <phy_tx_func+0x498>
800034ea:	93 08       	st.w	r9[0x0],r8
800034ec:	c1 28       	rjmp	80003510 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800034ee:	e0 68 5a 5a 	mov	r8,23130
800034f2:	ea 18 ab cd 	orh	r8,0xabcd
800034f6:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800034f8:	30 08       	mov	r8,0
800034fa:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
800034fc:	48 f9       	lddpc	r9,80003538 <phy_tx_func+0x498>
800034fe:	93 08       	st.w	r9[0x0],r8
80003500:	c0 88       	rjmp	80003510 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003502:	e0 68 5a 5a 	mov	r8,23130
80003506:	ea 18 ab cd 	orh	r8,0xabcd
8000350a:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000350c:	30 08       	mov	r8,0
8000350e:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80003510:	2f fd       	sub	sp,-4
80003512:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003516:	00 00       	add	r0,r0
80003518:	00 00       	add	r0,r0
8000351a:	0a cc       	st.b	r5++,r12
8000351c:	00 00       	add	r0,r0
8000351e:	0a a4       	st.w	r5++,r4
80003520:	00 00       	add	r0,r0
80003522:	0a 80       	andn	r0,r5
80003524:	80 00       	ld.sh	r0,r0[0x0]
80003526:	5d 7c       	*unknown*
80003528:	00 00       	add	r0,r0
8000352a:	0a c4       	st.b	r5++,r4
8000352c:	00 00       	add	r0,r0
8000352e:	0a 89       	andn	r9,r5
80003530:	00 00       	add	r0,r0
80003532:	0a 54       	eor	r4,r5
80003534:	00 00       	add	r0,r0
80003536:	0a 7c       	tst	r12,r5
80003538:	00 00       	add	r0,r0
8000353a:	0a b4       	st.h	r5++,r4
8000353c:	80 00       	ld.sh	r0,r0[0x0]
8000353e:	d9 64       	*unknown*
80003540:	00 00       	add	r0,r0
80003542:	0a 70       	tst	r0,r5
80003544:	00 00       	add	r0,r0
80003546:	0a d4       	st.w	--r5,r4
80003548:	00 00       	add	r0,r0
8000354a:	1d 90       	ld.ub	r0,lr[0x1]
8000354c:	00 00       	add	r0,r0
8000354e:	1e 8c       	andn	r12,pc
80003550:	00 00       	add	r0,r0
80003552:	0a 56       	eor	r6,r5
80003554:	80 00       	ld.sh	r0,r0[0x0]
80003556:	d3 58       	*unknown*
80003558:	00 00       	add	r0,r0
8000355a:	1d 88       	ld.ub	r8,lr[0x0]
8000355c:	00 00       	add	r0,r0
8000355e:	0a a0       	st.w	r5++,r0
80003560:	00 00       	add	r0,r0
80003562:	1e 90       	mov	r0,pc
80003564:	00 00       	add	r0,r0
80003566:	1d 94       	ld.ub	r4,lr[0x1]

80003568 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003568:	d4 01       	pushm	lr
8000356a:	20 1d       	sub	sp,4
	void * ptr = NULL;
8000356c:	30 0a       	mov	r10,0
8000356e:	fa cb ff fc 	sub	r11,sp,-4
80003572:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003574:	14 99       	mov	r9,r10
80003576:	1a 9b       	mov	r11,sp
80003578:	f0 1f 00 05 	mcall	8000358c <get_idle_store+0x24>
8000357c:	58 1c       	cp.w	r12,1
8000357e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003582:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80003586:	2f fd       	sub	sp,-4
80003588:	d8 02       	popm	pc
8000358a:	00 00       	add	r0,r0
8000358c:	80 00       	ld.sh	r0,r0[0x0]
8000358e:	5e 6c       	retmi	r12

80003590 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003590:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80003594:	f0 1f 00 21 	mcall	80003618 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003598:	4a 1b       	lddpc	r11,8000361c <phy_init+0x8c>
8000359a:	4a 2c       	lddpc	r12,80003620 <phy_init+0x90>
8000359c:	f0 1f 00 22 	mcall	80003624 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800035a0:	30 4b       	mov	r11,4
800035a2:	31 ec       	mov	r12,30
800035a4:	f0 1f 00 21 	mcall	80003628 <phy_init+0x98>
800035a8:	4a 18       	lddpc	r8,8000362c <phy_init+0x9c>
800035aa:	91 0c       	st.w	r8[0x0],r12
800035ac:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800035ae:	10 96       	mov	r6,r8
800035b0:	4a 05       	lddpc	r5,80003630 <phy_init+0xa0>
800035b2:	6c 0c       	ld.w	r12,r6[0x0]
800035b4:	ea 07 00 0b 	add	r11,r5,r7
800035b8:	f0 1f 00 1f 	mcall	80003634 <phy_init+0xa4>
800035bc:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800035c0:	e0 47 1e 00 	cp.w	r7,7680
800035c4:	cf 71       	brne	800035b2 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800035c6:	30 4b       	mov	r11,4
800035c8:	31 4c       	mov	r12,20
800035ca:	f0 1f 00 18 	mcall	80003628 <phy_init+0x98>
800035ce:	49 b8       	lddpc	r8,80003638 <phy_init+0xa8>
800035d0:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800035d2:	30 4b       	mov	r11,4
800035d4:	30 ac       	mov	r12,10
800035d6:	f0 1f 00 15 	mcall	80003628 <phy_init+0x98>
800035da:	49 98       	lddpc	r8,8000363c <phy_init+0xac>
800035dc:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800035de:	30 4b       	mov	r11,4
800035e0:	30 ac       	mov	r12,10
800035e2:	f0 1f 00 12 	mcall	80003628 <phy_init+0x98>
800035e6:	49 78       	lddpc	r8,80003640 <phy_init+0xb0>
800035e8:	91 0c       	st.w	r8[0x0],r12
800035ea:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800035ec:	10 96       	mov	r6,r8
800035ee:	49 65       	lddpc	r5,80003644 <phy_init+0xb4>
800035f0:	6c 0c       	ld.w	r12,r6[0x0]
800035f2:	ea 07 00 0b 	add	r11,r5,r7
800035f6:	f0 1f 00 10 	mcall	80003634 <phy_init+0xa4>
800035fa:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800035fe:	e0 47 14 00 	cp.w	r7,5120
80003602:	cf 71       	brne	800035f0 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80003604:	e0 6b 01 00 	mov	r11,256
80003608:	30 5c       	mov	r12,5
8000360a:	f0 1f 00 08 	mcall	80003628 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
8000360e:	48 f8       	lddpc	r8,80003648 <phy_init+0xb8>
80003610:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80003612:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003616:	00 00       	add	r0,r0
80003618:	80 00       	ld.sh	r0,r0[0x0]
8000361a:	44 3c       	lddsp	r12,sp[0x10c]
8000361c:	80 00       	ld.sh	r0,r0[0x0]
8000361e:	30 a0       	mov	r0,10
80003620:	80 00       	ld.sh	r0,r0[0x0]
80003622:	36 ac       	mov	r12,106
80003624:	80 00       	ld.sh	r0,r0[0x0]
80003626:	44 28       	lddsp	r8,sp[0x108]
80003628:	80 00       	ld.sh	r0,r0[0x0]
8000362a:	61 78       	ld.w	r8,r0[0x5c]
8000362c:	00 00       	add	r0,r0
8000362e:	0a 98       	mov	r8,r5
80003630:	00 00       	add	r0,r0
80003632:	32 aa       	mov	r10,42
80003634:	80 00       	ld.sh	r0,r0[0x0]
80003636:	2f fc       	sub	r12,-1
80003638:	00 00       	add	r0,r0
8000363a:	0a cc       	st.b	r5++,r12
8000363c:	00 00       	add	r0,r0
8000363e:	0a c0       	st.b	r5++,r0
80003640:	00 00       	add	r0,r0
80003642:	0a 74       	tst	r4,r5
80003644:	00 00       	add	r0,r0
80003646:	1e aa       	st.w	pc++,r10
80003648:	00 00       	add	r0,r0
8000364a:	0a bc       	st.h	r5++,r12

8000364c <payload_rx>:




static void payload_rx(void * payload)
{
8000364c:	d4 01       	pushm	lr
8000364e:	20 2d       	sub	sp,8
80003650:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003652:	30 08       	mov	r8,0
80003654:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80003656:	48 f8       	lddpc	r8,80003690 <payload_rx+0x44>
80003658:	70 08       	ld.w	r8,r8[0x0]
8000365a:	58 08       	cp.w	r8,0
8000365c:	c0 71       	brne	8000366a <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000365e:	30 4b       	mov	r11,4
80003660:	30 5c       	mov	r12,5
80003662:	f0 1f 00 0d 	mcall	80003694 <payload_rx+0x48>
80003666:	48 b8       	lddpc	r8,80003690 <payload_rx+0x44>
80003668:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000366a:	48 a8       	lddpc	r8,80003690 <payload_rx+0x44>
8000366c:	70 0c       	ld.w	r12,r8[0x0]
8000366e:	30 09       	mov	r9,0
80003670:	fa ca ff fc 	sub	r10,sp,-4
80003674:	1a 9b       	mov	r11,sp
80003676:	f0 1f 00 09 	mcall	80003698 <payload_rx+0x4c>
8000367a:	c0 91       	brne	8000368c <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
8000367c:	48 88       	lddpc	r8,8000369c <payload_rx+0x50>
8000367e:	70 0c       	ld.w	r12,r8[0x0]
80003680:	40 0b       	lddsp	r11,sp[0x0]
80003682:	f0 1f 00 08 	mcall	800036a0 <payload_rx+0x54>
		logFromISR("mm");
80003686:	48 8c       	lddpc	r12,800036a4 <payload_rx+0x58>
80003688:	f0 1f 00 08 	mcall	800036a8 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
8000368c:	2f ed       	sub	sp,-8
8000368e:	d8 02       	popm	pc
80003690:	00 00       	add	r0,r0
80003692:	0a 90       	mov	r0,r5
80003694:	80 00       	ld.sh	r0,r0[0x0]
80003696:	61 78       	ld.w	r8,r0[0x5c]
80003698:	80 00       	ld.sh	r0,r0[0x0]
8000369a:	60 28       	ld.w	r8,r0[0x8]
8000369c:	00 00       	add	r0,r0
8000369e:	0a 74       	tst	r4,r5
800036a0:	80 00       	ld.sh	r0,r0[0x0]
800036a2:	2f a8       	sub	r8,-6
800036a4:	80 00       	ld.sh	r0,r0[0x0]
800036a6:	d9 80       	acall	0x98
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	6d 9c       	ld.w	r12,r6[0x64]

800036ac <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800036ac:	eb cd 40 e0 	pushm	r5-r7,lr
800036b0:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800036b2:	fe f8 0b be 	ld.w	r8,pc[3006]
800036b6:	70 08       	ld.w	r8,r8[0x0]
800036b8:	58 08       	cp.w	r8,0
800036ba:	e0 80 01 05 	breq	800038c4 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800036be:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800036c0:	fe f8 0b b4 	ld.w	r8,pc[2996]
800036c4:	70 09       	ld.w	r9,r8[0x0]
800036c6:	2f f9       	sub	r9,-1
800036c8:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800036ca:	fe f8 0b ae 	ld.w	r8,pc[2990]
800036ce:	70 08       	ld.w	r8,r8[0x0]
800036d0:	58 18       	cp.w	r8,1
800036d2:	e0 80 00 84 	breq	800037da <phy_rx_func+0x12e>
800036d6:	c0 73       	brcs	800036e4 <phy_rx_func+0x38>
800036d8:	58 28       	cp.w	r8,2
800036da:	c5 b0       	breq	80003790 <phy_rx_func+0xe4>
800036dc:	58 38       	cp.w	r8,3
800036de:	e0 81 00 f3 	brne	800038c4 <phy_rx_func+0x218>
800036e2:	cd 38       	rjmp	80003888 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800036e4:	e0 6a 5a 5a 	mov	r10,23130
800036e8:	ea 1a ab cd 	orh	r10,0xabcd
800036ec:	14 36       	cp.w	r6,r10
800036ee:	e0 80 00 eb 	breq	800038c4 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800036f2:	ec 08 16 10 	lsr	r8,r6,0x10
800036f6:	e0 48 ab cd 	cp.w	r8,43981
800036fa:	e0 81 00 e5 	brne	800038c4 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800036fe:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003702:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003706:	20 28       	sub	r8,2
80003708:	fe f9 0b 74 	ld.w	r9,pc[2932]
8000370c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000370e:	30 09       	mov	r9,0
80003710:	f2 08 19 00 	cp.h	r8,r9
80003714:	e0 8a 00 d8 	brle	800038c4 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80003718:	fe f8 0b 68 	ld.w	r8,pc[2920]
8000371c:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
8000371e:	fe f8 0b 66 	ld.w	r8,pc[2918]
80003722:	70 0c       	ld.w	r12,r8[0x0]
80003724:	f0 1f 02 d9 	mcall	80004288 <phy_rx_func+0xbdc>
80003728:	fe f8 0b 64 	ld.w	r8,pc[2916]
8000372c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000372e:	58 0c       	cp.w	r12,0
80003730:	e0 80 00 ca 	breq	800038c4 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003734:	fe f8 0b 4c 	ld.w	r8,pc[2892]
80003738:	90 09       	ld.sh	r9,r8[0x0]
8000373a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000373e:	2f f9       	sub	r9,-1
80003740:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003742:	fe fa 0b 4a 	ld.w	r10,pc[2890]
80003746:	74 0a       	ld.w	r10,r10[0x0]
80003748:	fe fb 0b 2c 	ld.w	r11,pc[2860]
8000374c:	76 0b       	ld.w	r11,r11[0x0]
8000374e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003752:	2f f9       	sub	r9,-1
80003754:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003756:	e2 16 0f 00 	andl	r6,0xf00,COH
8000375a:	e0 46 01 00 	cp.w	r6,256
8000375e:	c0 c0       	breq	80003776 <phy_rx_func+0xca>
80003760:	e0 8b 00 05 	brhi	8000376a <phy_rx_func+0xbe>
80003764:	58 06       	cp.w	r6,0
80003766:	c0 80       	breq	80003776 <phy_rx_func+0xca>
80003768:	c0 c8       	rjmp	80003780 <phy_rx_func+0xd4>
8000376a:	e0 46 02 00 	cp.w	r6,512
8000376e:	c0 40       	breq	80003776 <phy_rx_func+0xca>
80003770:	e0 46 03 00 	cp.w	r6,768
80003774:	c0 61       	brne	80003780 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003776:	30 29       	mov	r9,2
80003778:	fe f8 0b 00 	ld.w	r8,pc[2816]
8000377c:	91 09       	st.w	r8[0x0],r9
8000377e:	ca 38       	rjmp	800038c4 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003780:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003784:	6c 0c       	ld.w	r12,r6[0x0]
80003786:	f0 1f 02 c3 	mcall	80004290 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
8000378a:	30 08       	mov	r8,0
8000378c:	8d 08       	st.w	r6[0x0],r8
8000378e:	c9 b8       	rjmp	800038c4 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003790:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003794:	b1 86       	lsr	r6,0x10
80003796:	14 06       	add	r6,r10
80003798:	fe f8 0a fc 	ld.w	r8,pc[2812]
8000379c:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000379e:	fe f8 0a e2 	ld.w	r8,pc[2786]
800037a2:	90 09       	ld.sh	r9,r8[0x0]
800037a4:	fe fb 0a e8 	ld.w	r11,pc[2792]
800037a8:	76 0b       	ld.w	r11,r11[0x0]
800037aa:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800037ae:	2f f9       	sub	r9,-1
800037b0:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800037b2:	fe f9 0a ca 	ld.w	r9,pc[2762]
800037b6:	92 08       	ld.sh	r8,r9[0x0]
800037b8:	20 28       	sub	r8,2
800037ba:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800037bc:	30 09       	mov	r9,0
800037be:	f2 08 19 00 	cp.h	r8,r9
800037c2:	e0 8a 00 07 	brle	800037d0 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800037c6:	30 19       	mov	r9,1
800037c8:	fe f8 0a b0 	ld.w	r8,pc[2736]
800037cc:	91 09       	st.w	r8[0x0],r9
800037ce:	c7 b8       	rjmp	800038c4 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800037d0:	30 39       	mov	r9,3
800037d2:	fe f8 0a a6 	ld.w	r8,pc[2726]
800037d6:	91 09       	st.w	r8[0x0],r9
800037d8:	c7 68       	rjmp	800038c4 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800037da:	ec 0a 14 10 	asr	r10,r6,0x10
800037de:	fe f8 0a b6 	ld.w	r8,pc[2742]
800037e2:	90 09       	ld.sh	r9,r8[0x0]
800037e4:	14 09       	add	r9,r10
800037e6:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800037e8:	fe f9 0a 98 	ld.w	r9,pc[2712]
800037ec:	92 08       	ld.sh	r8,r9[0x0]
800037ee:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800037f2:	76 0b       	ld.w	r11,r11[0x0]
800037f4:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800037f8:	2f f8       	sub	r8,-1
800037fa:	5c 88       	casts.h	r8
800037fc:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800037fe:	fe fa 0a 7e 	ld.w	r10,pc[2686]
80003802:	94 09       	ld.sh	r9,r10[0x0]
80003804:	20 29       	sub	r9,2
80003806:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003808:	30 0a       	mov	r10,0
8000380a:	f4 09 19 00 	cp.h	r9,r10
8000380e:	e0 89 00 1f 	brgt	8000384c <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003812:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003816:	e0 46 00 ba 	cp.w	r6,186
8000381a:	c0 d1       	brne	80003834 <phy_rx_func+0x188>
8000381c:	fe f8 0a 78 	ld.w	r8,pc[2680]
80003820:	90 09       	ld.sh	r9,r8[0x0]
80003822:	f4 09 19 00 	cp.h	r9,r10
80003826:	c0 71       	brne	80003834 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003828:	fe f8 0a 64 	ld.w	r8,pc[2660]
8000382c:	70 0c       	ld.w	r12,r8[0x0]
8000382e:	f0 1f 02 9b 	mcall	80004298 <phy_rx_func+0xbec>
80003832:	c0 88       	rjmp	80003842 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003834:	fe f6 0a 58 	ld.w	r6,pc[2648]
80003838:	6c 0c       	ld.w	r12,r6[0x0]
8000383a:	f0 1f 02 96 	mcall	80004290 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
8000383e:	30 08       	mov	r8,0
80003840:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003842:	30 09       	mov	r9,0
80003844:	fe f8 0a 34 	ld.w	r8,pc[2612]
80003848:	91 09       	st.w	r8[0x0],r9
8000384a:	c3 d8       	rjmp	800038c4 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000384c:	5c 86       	casts.h	r6
8000384e:	fe f9 0a 46 	ld.w	r9,pc[2630]
80003852:	92 0a       	ld.sh	r10,r9[0x0]
80003854:	0c 0a       	add	r10,r6
80003856:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003858:	fe f9 0a 34 	ld.w	r9,pc[2612]
8000385c:	72 09       	ld.w	r9,r9[0x0]
8000385e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003862:	2f f8       	sub	r8,-1
80003864:	fe f9 0a 1c 	ld.w	r9,pc[2588]
80003868:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000386a:	fe f9 0a 12 	ld.w	r9,pc[2578]
8000386e:	92 08       	ld.sh	r8,r9[0x0]
80003870:	20 28       	sub	r8,2
80003872:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003874:	30 09       	mov	r9,0
80003876:	f2 08 19 00 	cp.h	r8,r9
8000387a:	e0 89 00 25 	brgt	800038c4 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000387e:	30 39       	mov	r9,3
80003880:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003884:	91 09       	st.w	r8[0x0],r9
80003886:	c1 f8       	rjmp	800038c4 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003888:	e6 16 00 ff 	andh	r6,0xff,COH
8000388c:	fc 19 00 ba 	movh	r9,0xba
80003890:	12 36       	cp.w	r6,r9
80003892:	c0 e1       	brne	800038ae <phy_rx_func+0x202>
80003894:	fe f8 0a 00 	ld.w	r8,pc[2560]
80003898:	90 09       	ld.sh	r9,r8[0x0]
8000389a:	30 08       	mov	r8,0
8000389c:	f0 09 19 00 	cp.h	r9,r8
800038a0:	c0 71       	brne	800038ae <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800038a2:	fe f8 09 ea 	ld.w	r8,pc[2538]
800038a6:	70 0c       	ld.w	r12,r8[0x0]
800038a8:	f0 1f 02 7c 	mcall	80004298 <phy_rx_func+0xbec>
800038ac:	c0 88       	rjmp	800038bc <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800038ae:	fe f6 09 de 	ld.w	r6,pc[2526]
800038b2:	6c 0c       	ld.w	r12,r6[0x0]
800038b4:	f0 1f 02 77 	mcall	80004290 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
800038b8:	30 08       	mov	r8,0
800038ba:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800038bc:	30 09       	mov	r9,0
800038be:	fe f8 09 ba 	ld.w	r8,pc[2490]
800038c2:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800038c4:	fe f8 09 d8 	ld.w	r8,pc[2520]
800038c8:	11 89       	ld.ub	r9,r8[0x0]
800038ca:	30 08       	mov	r8,0
800038cc:	f0 09 18 00 	cp.b	r9,r8
800038d0:	c0 d1       	brne	800038ea <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
800038d2:	fe f8 09 ce 	ld.w	r8,pc[2510]
800038d6:	70 0c       	ld.w	r12,r8[0x0]
800038d8:	f0 1f 02 6c 	mcall	80004288 <phy_rx_func+0xbdc>
800038dc:	fe f8 09 c8 	ld.w	r8,pc[2504]
800038e0:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800038e2:	30 19       	mov	r9,1
800038e4:	fe f8 09 b8 	ld.w	r8,pc[2488]
800038e8:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800038ea:	fe f8 09 be 	ld.w	r8,pc[2494]
800038ee:	70 08       	ld.w	r8,r8[0x0]
800038f0:	58 38       	cp.w	r8,3
800038f2:	e0 80 04 7a 	breq	800041e6 <phy_rx_func+0xb3a>
800038f6:	58 48       	cp.w	r8,4
800038f8:	e0 80 01 02 	breq	80003afc <phy_rx_func+0x450>
800038fc:	58 08       	cp.w	r8,0
800038fe:	e0 81 04 b7 	brne	8000426c <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003902:	6e 28       	ld.w	r8,r7[0x8]
80003904:	e0 6a 5a 5a 	mov	r10,23130
80003908:	ea 1a ab cd 	orh	r10,0xabcd
8000390c:	14 38       	cp.w	r8,r10
8000390e:	c0 71       	brne	8000391c <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
80003910:	30 09       	mov	r9,0
80003912:	fe f8 09 9a 	ld.w	r8,pc[2458]
80003916:	91 09       	st.w	r8[0x0],r9
80003918:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000391c:	10 99       	mov	r9,r8
8000391e:	e0 19 00 00 	andl	r9,0x0
80003922:	fc 1a ab cd 	movh	r10,0xabcd
80003926:	14 39       	cp.w	r9,r10
80003928:	e0 81 04 a2 	brne	8000426c <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000392c:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003930:	fe f9 09 80 	ld.w	r9,pc[2432]
80003934:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
80003936:	fe f8 09 6e 	ld.w	r8,pc[2414]
8000393a:	70 08       	ld.w	r8,r8[0x0]
8000393c:	58 08       	cp.w	r8,0
8000393e:	c1 11       	brne	80003960 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003940:	fe f8 09 60 	ld.w	r8,pc[2400]
80003944:	70 0c       	ld.w	r12,r8[0x0]
80003946:	f0 1f 02 51 	mcall	80004288 <phy_rx_func+0xbdc>
8000394a:	fe f8 09 5a 	ld.w	r8,pc[2394]
8000394e:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003950:	58 0c       	cp.w	r12,0
80003952:	c0 71       	brne	80003960 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003954:	fe fc 09 60 	ld.w	r12,pc[2400]
80003958:	f0 1f 02 58 	mcall	800042b8 <phy_rx_func+0xc0c>
8000395c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003960:	6e 28       	ld.w	r8,r7[0x8]
80003962:	e2 18 f0 00 	andl	r8,0xf000,COH
80003966:	e0 48 c0 00 	cp.w	r8,49152
8000396a:	e0 81 00 c3 	brne	80003af0 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
8000396e:	30 19       	mov	r9,1
80003970:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003974:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
80003976:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000397a:	fe f8 09 46 	ld.w	r8,pc[2374]
8000397e:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003980:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003984:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003988:	fe f9 09 3c 	ld.w	r9,pc[2364]
8000398c:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
8000398e:	11 88       	ld.ub	r8,r8[0x0]
80003990:	37 f9       	mov	r9,127
80003992:	f2 08 18 00 	cp.b	r8,r9
80003996:	c6 d0       	breq	80003a70 <phy_rx_func+0x3c4>
80003998:	e0 8b 00 0c 	brhi	800039b0 <phy_rx_func+0x304>
8000399c:	31 29       	mov	r9,18
8000399e:	f2 08 18 00 	cp.b	r8,r9
800039a2:	c4 20       	breq	80003a26 <phy_rx_func+0x37a>
800039a4:	31 39       	mov	r9,19
800039a6:	f2 08 18 00 	cp.b	r8,r9
800039aa:	e0 81 00 83 	brne	80003ab0 <phy_rx_func+0x404>
800039ae:	c5 b8       	rjmp	80003a64 <phy_rx_func+0x3b8>
800039b0:	2f 08       	sub	r8,-16
800039b2:	30 19       	mov	r9,1
800039b4:	f2 08 18 00 	cp.b	r8,r9
800039b8:	e0 8b 00 7c 	brhi	80003ab0 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800039bc:	ef 38 00 0e 	ld.ub	r8,r7[14]
800039c0:	e2 18 00 f0 	andl	r8,0xf0,COH
800039c4:	59 08       	cp.w	r8,16
800039c6:	c0 71       	brne	800039d4 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
800039c8:	30 19       	mov	r9,1
800039ca:	fe f8 08 e2 	ld.w	r8,pc[2274]
800039ce:	91 09       	st.w	r8[0x0],r9
800039d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800039d4:	e0 48 00 20 	cp.w	r8,32
800039d8:	c2 11       	brne	80003a1a <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
800039da:	30 a9       	mov	r9,10
800039dc:	fe f8 08 d0 	ld.w	r8,pc[2256]
800039e0:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800039e2:	fe f6 08 e6 	ld.w	r6,pc[2278]
800039e6:	6c 08       	ld.w	r8,r6[0x0]
800039e8:	f0 0a 11 ff 	rsub	r10,r8,-1
800039ec:	fe f7 08 b8 	ld.w	r7,pc[2232]
800039f0:	2f f8       	sub	r8,-1
800039f2:	6e 0c       	ld.w	r12,r7[0x0]
800039f4:	f4 ca fe 00 	sub	r10,r10,-512
800039f8:	30 0b       	mov	r11,0
800039fa:	10 0c       	add	r12,r8
800039fc:	f0 1f 02 34 	mcall	800042cc <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
80003a00:	30 08       	mov	r8,0
80003a02:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003a04:	6e 0c       	ld.w	r12,r7[0x0]
80003a06:	f0 1f 02 33 	mcall	800042d0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a0a:	fe f8 08 96 	ld.w	r8,pc[2198]
80003a0e:	70 0c       	ld.w	r12,r8[0x0]
80003a10:	f0 1f 02 1e 	mcall	80004288 <phy_rx_func+0xbdc>
80003a14:	8f 0c       	st.w	r7[0x0],r12
80003a16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003a1a:	30 09       	mov	r9,0
80003a1c:	fe f8 08 90 	ld.w	r8,pc[2192]
80003a20:	91 09       	st.w	r8[0x0],r9
80003a22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a26:	fe f9 08 8a 	ld.w	r9,pc[2186]
80003a2a:	72 08       	ld.w	r8,r9[0x0]
80003a2c:	20 48       	sub	r8,4
80003a2e:	93 08       	st.w	r9[0x0],r8
80003a30:	e0 80 04 1e 	breq	8000426c <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a34:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003a38:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a3c:	fe f8 08 98 	ld.w	r8,pc[2200]
80003a40:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003a42:	8e 69       	ld.sh	r9,r7[0xc]
80003a44:	fe f8 08 94 	ld.w	r8,pc[2196]
80003a48:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003a4a:	8e 79       	ld.sh	r9,r7[0xe]
80003a4c:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003a4e:	f0 1f 02 24 	mcall	800042dc <phy_rx_func+0xc30>
80003a52:	fe f8 08 5a 	ld.w	r8,pc[2138]
80003a56:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003a58:	30 49       	mov	r9,4
80003a5a:	fe f8 08 4e 	ld.w	r8,pc[2126]
80003a5e:	91 09       	st.w	r8[0x0],r9
80003a60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003a64:	30 09       	mov	r9,0
80003a66:	fe f8 08 46 	ld.w	r8,pc[2118]
80003a6a:	91 09       	st.w	r8[0x0],r9
80003a6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003a70:	fe f9 08 40 	ld.w	r9,pc[2112]
80003a74:	72 08       	ld.w	r8,r9[0x0]
80003a76:	20 48       	sub	r8,4
80003a78:	93 08       	st.w	r9[0x0],r8
80003a7a:	e0 80 03 f9 	breq	8000426c <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003a7e:	fe f8 08 62 	ld.w	r8,pc[2146]
80003a82:	70 09       	ld.w	r9,r8[0x0]
80003a84:	8e 7b       	ld.sh	r11,r7[0xe]
80003a86:	fe fa 08 5e 	ld.w	r10,pc[2142]
80003a8a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003a8e:	2f f9       	sub	r9,-1
80003a90:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003a92:	fe f8 08 32 	ld.w	r8,pc[2098]
80003a96:	70 09       	ld.w	r9,r8[0x0]
80003a98:	20 29       	sub	r9,2
80003a9a:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003a9c:	30 29       	mov	r9,2
80003a9e:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003aa2:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003aa4:	30 39       	mov	r9,3
80003aa6:	fe f8 08 02 	ld.w	r8,pc[2050]
80003aaa:	91 09       	st.w	r8[0x0],r9
80003aac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003ab0:	30 39       	mov	r9,3
80003ab2:	fe f8 07 fa 	ld.w	r8,pc[2042]
80003ab6:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003ab8:	6e 29       	ld.w	r9,r7[0x8]
80003aba:	fe f8 08 2e 	ld.w	r8,pc[2094]
80003abe:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003ac0:	6e 39       	ld.w	r9,r7[0xc]
80003ac2:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003ac4:	fe f8 07 ec 	ld.w	r8,pc[2028]
80003ac8:	70 08       	ld.w	r8,r8[0x0]
80003aca:	59 48       	cp.w	r8,20
80003acc:	c0 61       	brne	80003ad8 <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003ace:	31 89       	mov	r9,24
80003ad0:	fe f8 07 e0 	ld.w	r8,pc[2016]
80003ad4:	91 09       	st.w	r8[0x0],r9
80003ad6:	c0 78       	rjmp	80003ae4 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003ad8:	59 08       	cp.w	r8,16
80003ada:	c0 51       	brne	80003ae4 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003adc:	31 09       	mov	r9,16
80003ade:	fe f8 07 d2 	ld.w	r8,pc[2002]
80003ae2:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003ae4:	30 49       	mov	r9,4
80003ae6:	fe f8 07 c2 	ld.w	r8,pc[1986]
80003aea:	91 09       	st.w	r8[0x0],r9
80003aec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
80003af0:	30 09       	mov	r9,0
80003af2:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003af6:	b0 89       	st.b	r8[0x0],r9
80003af8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003afc:	fe f8 07 c4 	ld.w	r8,pc[1988]
80003b00:	11 89       	ld.ub	r9,r8[0x0]
80003b02:	31 28       	mov	r8,18
80003b04:	f0 09 18 00 	cp.b	r9,r8
80003b08:	e0 81 01 4c 	brne	80003da0 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
80003b0c:	ef 39 00 09 	ld.ub	r9,r7[9]
80003b10:	fe f8 07 b0 	ld.w	r8,pc[1968]
80003b14:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003b16:	11 89       	ld.ub	r9,r8[0x0]
80003b18:	3f 28       	mov	r8,-14
80003b1a:	f0 09 18 00 	cp.b	r9,r8
80003b1e:	e0 81 01 3b 	brne	80003d94 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
80003b22:	30 19       	mov	r9,1
80003b24:	fe f8 07 c8 	ld.w	r8,pc[1992]
80003b28:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003b2a:	6e 29       	ld.w	r9,r7[0x8]
80003b2c:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003b30:	fe f8 07 80 	ld.w	r8,pc[1920]
80003b34:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003b36:	8e 59       	ld.sh	r9,r7[0xa]
80003b38:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003b3c:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003b3e:	8e 69       	ld.sh	r9,r7[0xc]
80003b40:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003b42:	8e 79       	ld.sh	r9,r7[0xe]
80003b44:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003b46:	fe f8 07 82 	ld.w	r8,pc[1922]
80003b4a:	fe f9 07 5a 	ld.w	r9,pc[1882]
80003b4e:	72 0a       	ld.w	r10,r9[0x0]
80003b50:	70 09       	ld.w	r9,r8[0x0]
80003b52:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b56:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b5a:	70 09       	ld.w	r9,r8[0x0]
80003b5c:	2f f9       	sub	r9,-1
80003b5e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b60:	e0 49 01 ff 	cp.w	r9,511
80003b64:	e0 88 00 16 	brls	80003b90 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b68:	30 09       	mov	r9,0
80003b6a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b6c:	fe f6 07 38 	ld.w	r6,pc[1848]
80003b70:	6c 0c       	ld.w	r12,r6[0x0]
80003b72:	f0 1f 01 d8 	mcall	800042d0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b76:	fe f8 07 2a 	ld.w	r8,pc[1834]
80003b7a:	70 0c       	ld.w	r12,r8[0x0]
80003b7c:	f0 1f 01 c3 	mcall	80004288 <phy_rx_func+0xbdc>
80003b80:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b82:	c0 71       	brne	80003b90 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003b84:	30 09       	mov	r9,0
80003b86:	fe f8 07 22 	ld.w	r8,pc[1826]
80003b8a:	91 09       	st.w	r8[0x0],r9
80003b8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b90:	fe f9 07 20 	ld.w	r9,pc[1824]
80003b94:	72 08       	ld.w	r8,r9[0x0]
80003b96:	20 18       	sub	r8,1
80003b98:	93 08       	st.w	r9[0x0],r8
80003b9a:	c0 71       	brne	80003ba8 <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003b9c:	30 09       	mov	r9,0
80003b9e:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003ba2:	91 09       	st.w	r8[0x0],r9
80003ba4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003ba8:	fe f8 07 20 	ld.w	r8,pc[1824]
80003bac:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003bb0:	72 0a       	ld.w	r10,r9[0x0]
80003bb2:	70 09       	ld.w	r9,r8[0x0]
80003bb4:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003bb8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003bbc:	70 09       	ld.w	r9,r8[0x0]
80003bbe:	2f f9       	sub	r9,-1
80003bc0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bc2:	e0 49 01 ff 	cp.w	r9,511
80003bc6:	e0 88 00 16 	brls	80003bf2 <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bca:	30 09       	mov	r9,0
80003bcc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bce:	fe f6 06 d6 	ld.w	r6,pc[1750]
80003bd2:	6c 0c       	ld.w	r12,r6[0x0]
80003bd4:	f0 1f 01 bf 	mcall	800042d0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bd8:	fe f8 06 c8 	ld.w	r8,pc[1736]
80003bdc:	70 0c       	ld.w	r12,r8[0x0]
80003bde:	f0 1f 01 ab 	mcall	80004288 <phy_rx_func+0xbdc>
80003be2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003be4:	c0 71       	brne	80003bf2 <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
80003be6:	30 09       	mov	r9,0
80003be8:	fe f8 06 c0 	ld.w	r8,pc[1728]
80003bec:	91 09       	st.w	r8[0x0],r9
80003bee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bf2:	fe f9 06 be 	ld.w	r9,pc[1726]
80003bf6:	72 08       	ld.w	r8,r9[0x0]
80003bf8:	20 18       	sub	r8,1
80003bfa:	93 08       	st.w	r9[0x0],r8
80003bfc:	c0 71       	brne	80003c0a <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
80003bfe:	30 09       	mov	r9,0
80003c00:	fe f8 06 a8 	ld.w	r8,pc[1704]
80003c04:	91 09       	st.w	r8[0x0],r9
80003c06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003c0a:	fe f8 06 be 	ld.w	r8,pc[1726]
80003c0e:	fe f9 06 96 	ld.w	r9,pc[1686]
80003c12:	72 0a       	ld.w	r10,r9[0x0]
80003c14:	70 09       	ld.w	r9,r8[0x0]
80003c16:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003c1a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c1e:	70 09       	ld.w	r9,r8[0x0]
80003c20:	2f f9       	sub	r9,-1
80003c22:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c24:	e0 49 01 ff 	cp.w	r9,511
80003c28:	e0 88 00 16 	brls	80003c54 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c2c:	30 09       	mov	r9,0
80003c2e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c30:	fe f6 06 74 	ld.w	r6,pc[1652]
80003c34:	6c 0c       	ld.w	r12,r6[0x0]
80003c36:	f0 1f 01 a7 	mcall	800042d0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c3a:	fe f8 06 66 	ld.w	r8,pc[1638]
80003c3e:	70 0c       	ld.w	r12,r8[0x0]
80003c40:	f0 1f 01 92 	mcall	80004288 <phy_rx_func+0xbdc>
80003c44:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c46:	c0 71       	brne	80003c54 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003c48:	30 09       	mov	r9,0
80003c4a:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003c4e:	91 09       	st.w	r8[0x0],r9
80003c50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c54:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003c58:	72 08       	ld.w	r8,r9[0x0]
80003c5a:	20 18       	sub	r8,1
80003c5c:	93 08       	st.w	r9[0x0],r8
80003c5e:	c0 71       	brne	80003c6c <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003c60:	30 09       	mov	r9,0
80003c62:	fe f8 06 46 	ld.w	r8,pc[1606]
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003c6c:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003c70:	fe f9 06 34 	ld.w	r9,pc[1588]
80003c74:	72 0a       	ld.w	r10,r9[0x0]
80003c76:	70 09       	ld.w	r9,r8[0x0]
80003c78:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003c7c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c80:	70 09       	ld.w	r9,r8[0x0]
80003c82:	2f f9       	sub	r9,-1
80003c84:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c86:	e0 49 01 ff 	cp.w	r9,511
80003c8a:	e0 88 00 16 	brls	80003cb6 <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c8e:	30 09       	mov	r9,0
80003c90:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c92:	fe f6 06 12 	ld.w	r6,pc[1554]
80003c96:	6c 0c       	ld.w	r12,r6[0x0]
80003c98:	f0 1f 01 8e 	mcall	800042d0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c9c:	fe f8 06 04 	ld.w	r8,pc[1540]
80003ca0:	70 0c       	ld.w	r12,r8[0x0]
80003ca2:	f0 1f 01 7a 	mcall	80004288 <phy_rx_func+0xbdc>
80003ca6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ca8:	c0 71       	brne	80003cb6 <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
80003caa:	30 09       	mov	r9,0
80003cac:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003cb0:	91 09       	st.w	r8[0x0],r9
80003cb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003cb6:	fe f9 05 fa 	ld.w	r9,pc[1530]
80003cba:	72 08       	ld.w	r8,r9[0x0]
80003cbc:	20 18       	sub	r8,1
80003cbe:	93 08       	st.w	r9[0x0],r8
80003cc0:	c0 71       	brne	80003cce <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003cc2:	30 09       	mov	r9,0
80003cc4:	fe f8 05 e4 	ld.w	r8,pc[1508]
80003cc8:	91 09       	st.w	r8[0x0],r9
80003cca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003cce:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003cd2:	fe f9 05 d2 	ld.w	r9,pc[1490]
80003cd6:	72 0a       	ld.w	r10,r9[0x0]
80003cd8:	70 09       	ld.w	r9,r8[0x0]
80003cda:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003cde:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ce2:	70 09       	ld.w	r9,r8[0x0]
80003ce4:	2f f9       	sub	r9,-1
80003ce6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ce8:	e0 49 01 ff 	cp.w	r9,511
80003cec:	e0 88 00 16 	brls	80003d18 <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
80003cf0:	30 09       	mov	r9,0
80003cf2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003cf4:	fe f6 05 b0 	ld.w	r6,pc[1456]
80003cf8:	6c 0c       	ld.w	r12,r6[0x0]
80003cfa:	f0 1f 01 76 	mcall	800042d0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003cfe:	fe f8 05 a2 	ld.w	r8,pc[1442]
80003d02:	70 0c       	ld.w	r12,r8[0x0]
80003d04:	f0 1f 01 61 	mcall	80004288 <phy_rx_func+0xbdc>
80003d08:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d0a:	c0 71       	brne	80003d18 <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
80003d0c:	30 09       	mov	r9,0
80003d0e:	fe f8 05 9a 	ld.w	r8,pc[1434]
80003d12:	91 09       	st.w	r8[0x0],r9
80003d14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d18:	fe f9 05 98 	ld.w	r9,pc[1432]
80003d1c:	72 08       	ld.w	r8,r9[0x0]
80003d1e:	20 18       	sub	r8,1
80003d20:	93 08       	st.w	r9[0x0],r8
80003d22:	c0 71       	brne	80003d30 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
80003d24:	30 09       	mov	r9,0
80003d26:	fe f8 05 82 	ld.w	r8,pc[1410]
80003d2a:	91 09       	st.w	r8[0x0],r9
80003d2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003d30:	fe f8 05 98 	ld.w	r8,pc[1432]
80003d34:	fe f9 05 70 	ld.w	r9,pc[1392]
80003d38:	72 0a       	ld.w	r10,r9[0x0]
80003d3a:	70 09       	ld.w	r9,r8[0x0]
80003d3c:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d40:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d44:	70 09       	ld.w	r9,r8[0x0]
80003d46:	2f f9       	sub	r9,-1
80003d48:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d4a:	e0 49 01 ff 	cp.w	r9,511
80003d4e:	e0 88 00 16 	brls	80003d7a <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d52:	30 09       	mov	r9,0
80003d54:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d56:	fe f7 05 4e 	ld.w	r7,pc[1358]
80003d5a:	6e 0c       	ld.w	r12,r7[0x0]
80003d5c:	f0 1f 01 5d 	mcall	800042d0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d60:	fe f8 05 40 	ld.w	r8,pc[1344]
80003d64:	70 0c       	ld.w	r12,r8[0x0]
80003d66:	f0 1f 01 49 	mcall	80004288 <phy_rx_func+0xbdc>
80003d6a:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d6c:	c0 71       	brne	80003d7a <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003d6e:	30 09       	mov	r9,0
80003d70:	fe f8 05 38 	ld.w	r8,pc[1336]
80003d74:	91 09       	st.w	r8[0x0],r9
80003d76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d7a:	fe f9 05 36 	ld.w	r9,pc[1334]
80003d7e:	72 08       	ld.w	r8,r9[0x0]
80003d80:	20 18       	sub	r8,1
80003d82:	93 08       	st.w	r9[0x0],r8
80003d84:	e0 81 02 74 	brne	8000426c <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003d88:	30 09       	mov	r9,0
80003d8a:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003d8e:	91 09       	st.w	r8[0x0],r9
80003d90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003d94:	30 09       	mov	r9,0
80003d96:	fe f8 05 12 	ld.w	r8,pc[1298]
80003d9a:	91 09       	st.w	r8[0x0],r9
80003d9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003da0:	fe f8 05 20 	ld.w	r8,pc[1312]
80003da4:	11 89       	ld.ub	r9,r8[0x0]
80003da6:	3f 28       	mov	r8,-14
80003da8:	f0 09 18 00 	cp.b	r9,r8
80003dac:	c4 31       	brne	80003e32 <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003dae:	8e 49       	ld.sh	r9,r7[0x8]
80003db0:	fe f8 05 40 	ld.w	r8,pc[1344]
80003db4:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003db6:	fe f8 05 12 	ld.w	r8,pc[1298]
80003dba:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003dbe:	72 0a       	ld.w	r10,r9[0x0]
80003dc0:	70 09       	ld.w	r9,r8[0x0]
80003dc2:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003dc6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dca:	70 09       	ld.w	r9,r8[0x0]
80003dcc:	2f f9       	sub	r9,-1
80003dce:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dd0:	e0 49 01 ff 	cp.w	r9,511
80003dd4:	e0 88 00 16 	brls	80003e00 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
80003dd8:	30 09       	mov	r9,0
80003dda:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ddc:	fe f7 04 c8 	ld.w	r7,pc[1224]
80003de0:	6e 0c       	ld.w	r12,r7[0x0]
80003de2:	f0 1f 01 3c 	mcall	800042d0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003de6:	fe f8 04 ba 	ld.w	r8,pc[1210]
80003dea:	70 0c       	ld.w	r12,r8[0x0]
80003dec:	f0 1f 01 27 	mcall	80004288 <phy_rx_func+0xbdc>
80003df0:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003df2:	c0 71       	brne	80003e00 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
80003df4:	30 09       	mov	r9,0
80003df6:	fe f8 04 b2 	ld.w	r8,pc[1202]
80003dfa:	91 09       	st.w	r8[0x0],r9
80003dfc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e00:	fe f9 04 b0 	ld.w	r9,pc[1200]
80003e04:	72 08       	ld.w	r8,r9[0x0]
80003e06:	20 18       	sub	r8,1
80003e08:	93 08       	st.w	r9[0x0],r8
80003e0a:	c0 71       	brne	80003e18 <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
80003e0c:	30 09       	mov	r9,0
80003e0e:	fe f8 04 9a 	ld.w	r8,pc[1178]
80003e12:	91 09       	st.w	r8[0x0],r9
80003e14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003e18:	20 18       	sub	r8,1
80003e1a:	fe f9 04 96 	ld.w	r9,pc[1174]
80003e1e:	93 08       	st.w	r9[0x0],r8
80003e20:	58 08       	cp.w	r8,0
80003e22:	e0 81 02 25 	brne	8000426c <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
80003e26:	30 09       	mov	r9,0
80003e28:	fe f8 04 80 	ld.w	r8,pc[1152]
80003e2c:	91 09       	st.w	r8[0x0],r9
80003e2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003e32:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003e36:	11 89       	ld.ub	r9,r8[0x0]
80003e38:	3f 38       	mov	r8,-13
80003e3a:	f0 09 18 00 	cp.b	r9,r8
80003e3e:	e0 81 01 0c 	brne	80004056 <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003e42:	8e 49       	ld.sh	r9,r7[0x8]
80003e44:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003e48:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003e4a:	8e 59       	ld.sh	r9,r7[0xa]
80003e4c:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003e4e:	8e 69       	ld.sh	r9,r7[0xc]
80003e50:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003e52:	fe f8 04 76 	ld.w	r8,pc[1142]
80003e56:	fe f9 04 4e 	ld.w	r9,pc[1102]
80003e5a:	72 0a       	ld.w	r10,r9[0x0]
80003e5c:	70 09       	ld.w	r9,r8[0x0]
80003e5e:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003e62:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e66:	70 09       	ld.w	r9,r8[0x0]
80003e68:	2f f9       	sub	r9,-1
80003e6a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e6c:	e0 49 01 ff 	cp.w	r9,511
80003e70:	e0 88 00 16 	brls	80003e9c <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e74:	30 09       	mov	r9,0
80003e76:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e78:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003e7c:	6c 0c       	ld.w	r12,r6[0x0]
80003e7e:	f0 1f 01 15 	mcall	800042d0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e82:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003e86:	70 0c       	ld.w	r12,r8[0x0]
80003e88:	f0 1f 01 00 	mcall	80004288 <phy_rx_func+0xbdc>
80003e8c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e8e:	c0 71       	brne	80003e9c <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003e90:	30 09       	mov	r9,0
80003e92:	fe f8 04 16 	ld.w	r8,pc[1046]
80003e96:	91 09       	st.w	r8[0x0],r9
80003e98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e9c:	fe f9 04 14 	ld.w	r9,pc[1044]
80003ea0:	72 08       	ld.w	r8,r9[0x0]
80003ea2:	20 18       	sub	r8,1
80003ea4:	93 08       	st.w	r9[0x0],r8
80003ea6:	c0 71       	brne	80003eb4 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
80003ea8:	30 09       	mov	r9,0
80003eaa:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003eae:	91 09       	st.w	r8[0x0],r9
80003eb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003eb4:	fe f8 04 14 	ld.w	r8,pc[1044]
80003eb8:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003ebc:	72 0a       	ld.w	r10,r9[0x0]
80003ebe:	70 09       	ld.w	r9,r8[0x0]
80003ec0:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003ec4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ec8:	70 09       	ld.w	r9,r8[0x0]
80003eca:	2f f9       	sub	r9,-1
80003ecc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ece:	e0 49 01 ff 	cp.w	r9,511
80003ed2:	e0 88 00 16 	brls	80003efe <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ed6:	30 09       	mov	r9,0
80003ed8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003eda:	fe f6 03 ca 	ld.w	r6,pc[970]
80003ede:	6c 0c       	ld.w	r12,r6[0x0]
80003ee0:	f0 1f 00 fc 	mcall	800042d0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ee4:	fe f8 03 bc 	ld.w	r8,pc[956]
80003ee8:	70 0c       	ld.w	r12,r8[0x0]
80003eea:	f0 1f 00 e8 	mcall	80004288 <phy_rx_func+0xbdc>
80003eee:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ef0:	c0 71       	brne	80003efe <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
80003ef2:	30 09       	mov	r9,0
80003ef4:	fe f8 03 b4 	ld.w	r8,pc[948]
80003ef8:	91 09       	st.w	r8[0x0],r9
80003efa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003efe:	fe f9 03 b2 	ld.w	r9,pc[946]
80003f02:	72 08       	ld.w	r8,r9[0x0]
80003f04:	20 18       	sub	r8,1
80003f06:	93 08       	st.w	r9[0x0],r8
80003f08:	c0 71       	brne	80003f16 <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
80003f0a:	30 09       	mov	r9,0
80003f0c:	fe f8 03 9c 	ld.w	r8,pc[924]
80003f10:	91 09       	st.w	r8[0x0],r9
80003f12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003f16:	fe f8 03 b2 	ld.w	r8,pc[946]
80003f1a:	fe f9 03 8a 	ld.w	r9,pc[906]
80003f1e:	72 0a       	ld.w	r10,r9[0x0]
80003f20:	70 09       	ld.w	r9,r8[0x0]
80003f22:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003f26:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f2a:	70 09       	ld.w	r9,r8[0x0]
80003f2c:	2f f9       	sub	r9,-1
80003f2e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f30:	e0 49 01 ff 	cp.w	r9,511
80003f34:	e0 88 00 16 	brls	80003f60 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f38:	30 09       	mov	r9,0
80003f3a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f3c:	fe f6 03 68 	ld.w	r6,pc[872]
80003f40:	6c 0c       	ld.w	r12,r6[0x0]
80003f42:	f0 1f 00 e4 	mcall	800042d0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f46:	fe f8 03 5a 	ld.w	r8,pc[858]
80003f4a:	70 0c       	ld.w	r12,r8[0x0]
80003f4c:	f0 1f 00 cf 	mcall	80004288 <phy_rx_func+0xbdc>
80003f50:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f52:	c0 71       	brne	80003f60 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003f54:	30 09       	mov	r9,0
80003f56:	fe f8 03 52 	ld.w	r8,pc[850]
80003f5a:	91 09       	st.w	r8[0x0],r9
80003f5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f60:	fe f9 03 50 	ld.w	r9,pc[848]
80003f64:	72 08       	ld.w	r8,r9[0x0]
80003f66:	20 18       	sub	r8,1
80003f68:	93 08       	st.w	r9[0x0],r8
80003f6a:	c0 71       	brne	80003f78 <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003f6c:	30 09       	mov	r9,0
80003f6e:	fe f8 03 3a 	ld.w	r8,pc[826]
80003f72:	91 09       	st.w	r8[0x0],r9
80003f74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003f78:	fe f8 03 50 	ld.w	r8,pc[848]
80003f7c:	fe f9 03 28 	ld.w	r9,pc[808]
80003f80:	72 0a       	ld.w	r10,r9[0x0]
80003f82:	70 09       	ld.w	r9,r8[0x0]
80003f84:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f88:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f8c:	70 09       	ld.w	r9,r8[0x0]
80003f8e:	2f f9       	sub	r9,-1
80003f90:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f92:	e0 49 01 ff 	cp.w	r9,511
80003f96:	e0 88 00 16 	brls	80003fc2 <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f9a:	30 09       	mov	r9,0
80003f9c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f9e:	fe f6 03 06 	ld.w	r6,pc[774]
80003fa2:	6c 0c       	ld.w	r12,r6[0x0]
80003fa4:	f0 1f 00 cb 	mcall	800042d0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fa8:	fe f8 02 f8 	ld.w	r8,pc[760]
80003fac:	70 0c       	ld.w	r12,r8[0x0]
80003fae:	f0 1f 00 b7 	mcall	80004288 <phy_rx_func+0xbdc>
80003fb2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fb4:	c0 71       	brne	80003fc2 <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
80003fb6:	30 09       	mov	r9,0
80003fb8:	fe f8 02 f0 	ld.w	r8,pc[752]
80003fbc:	91 09       	st.w	r8[0x0],r9
80003fbe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003fc2:	fe f9 02 ee 	ld.w	r9,pc[750]
80003fc6:	72 08       	ld.w	r8,r9[0x0]
80003fc8:	20 18       	sub	r8,1
80003fca:	93 08       	st.w	r9[0x0],r8
80003fcc:	c0 71       	brne	80003fda <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
80003fce:	30 09       	mov	r9,0
80003fd0:	fe f8 02 d8 	ld.w	r8,pc[728]
80003fd4:	91 09       	st.w	r8[0x0],r9
80003fd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003fda:	fe f8 02 ee 	ld.w	r8,pc[750]
80003fde:	fe f9 02 c6 	ld.w	r9,pc[710]
80003fe2:	72 0a       	ld.w	r10,r9[0x0]
80003fe4:	70 09       	ld.w	r9,r8[0x0]
80003fe6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003fea:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003fee:	70 09       	ld.w	r9,r8[0x0]
80003ff0:	2f f9       	sub	r9,-1
80003ff2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ff4:	e0 49 01 ff 	cp.w	r9,511
80003ff8:	e0 88 00 16 	brls	80004024 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ffc:	30 09       	mov	r9,0
80003ffe:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004000:	fe f7 02 a4 	ld.w	r7,pc[676]
80004004:	6e 0c       	ld.w	r12,r7[0x0]
80004006:	f0 1f 00 b3 	mcall	800042d0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000400a:	fe f8 02 96 	ld.w	r8,pc[662]
8000400e:	70 0c       	ld.w	r12,r8[0x0]
80004010:	f0 1f 00 9e 	mcall	80004288 <phy_rx_func+0xbdc>
80004014:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004016:	c0 71       	brne	80004024 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
80004018:	30 09       	mov	r9,0
8000401a:	fe f8 02 8e 	ld.w	r8,pc[654]
8000401e:	91 09       	st.w	r8[0x0],r9
80004020:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004024:	fe f9 02 8c 	ld.w	r9,pc[652]
80004028:	72 08       	ld.w	r8,r9[0x0]
8000402a:	20 18       	sub	r8,1
8000402c:	93 08       	st.w	r9[0x0],r8
8000402e:	c0 71       	brne	8000403c <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
80004030:	30 09       	mov	r9,0
80004032:	fe f8 02 76 	ld.w	r8,pc[630]
80004036:	91 09       	st.w	r8[0x0],r9
80004038:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000403c:	20 18       	sub	r8,1
8000403e:	fe f9 02 72 	ld.w	r9,pc[626]
80004042:	93 08       	st.w	r9[0x0],r8
80004044:	58 08       	cp.w	r8,0
80004046:	e0 81 01 13 	brne	8000426c <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000404a:	30 09       	mov	r9,0
8000404c:	fe f8 02 5c 	ld.w	r8,pc[604]
80004050:	91 09       	st.w	r8[0x0],r9
80004052:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004056:	fe f8 02 6a 	ld.w	r8,pc[618]
8000405a:	11 89       	ld.ub	r9,r8[0x0]
8000405c:	30 48       	mov	r8,4
8000405e:	f0 09 18 00 	cp.b	r9,r8
80004062:	c0 80       	breq	80004072 <phy_rx_func+0x9c6>
80004064:	fe f8 02 5c 	ld.w	r8,pc[604]
80004068:	11 89       	ld.ub	r9,r8[0x0]
8000406a:	30 38       	mov	r8,3
8000406c:	f0 09 18 00 	cp.b	r9,r8
80004070:	c1 41       	brne	80004098 <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004072:	6e 29       	ld.w	r9,r7[0x8]
80004074:	fe f8 02 74 	ld.w	r8,pc[628]
80004078:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
8000407a:	6e 39       	ld.w	r9,r7[0xc]
8000407c:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
8000407e:	fe f9 02 32 	ld.w	r9,pc[562]
80004082:	72 08       	ld.w	r8,r9[0x0]
80004084:	20 88       	sub	r8,8
80004086:	93 08       	st.w	r9[0x0],r8
80004088:	e0 81 00 f2 	brne	8000426c <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
8000408c:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
8000408e:	fe f9 02 1a 	ld.w	r9,pc[538]
80004092:	93 08       	st.w	r9[0x0],r8
80004094:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80004098:	fe f8 02 28 	ld.w	r8,pc[552]
8000409c:	11 89       	ld.ub	r9,r8[0x0]
8000409e:	31 38       	mov	r8,19
800040a0:	f0 09 18 00 	cp.b	r9,r8
800040a4:	e0 81 00 9c 	brne	800041dc <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
800040a8:	fe f8 02 4c 	ld.w	r8,pc[588]
800040ac:	11 88       	ld.ub	r8,r8[0x0]
800040ae:	30 c9       	mov	r9,12
800040b0:	f2 08 18 00 	cp.b	r8,r9
800040b4:	e0 81 00 7b 	brne	800041aa <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800040b8:	8e 49       	ld.sh	r9,r7[0x8]
800040ba:	fe f8 02 3e 	ld.w	r8,pc[574]
800040be:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800040c2:	30 09       	mov	r9,0
800040c4:	fe f8 02 30 	ld.w	r8,pc[560]
800040c8:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040ca:	ef 39 00 0d 	ld.ub	r9,r7[13]
800040ce:	3f 38       	mov	r8,-13
800040d0:	f0 09 18 00 	cp.b	r9,r8
800040d4:	c6 61       	brne	800041a0 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800040d6:	10 99       	mov	r9,r8
800040d8:	4f a8       	lddpc	r8,800042c0 <phy_rx_func+0xc14>
800040da:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800040dc:	ef 39 00 0c 	ld.ub	r9,r7[12]
800040e0:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800040e4:	4f 38       	lddpc	r8,800042b0 <phy_rx_func+0xc04>
800040e6:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800040e8:	30 19       	mov	r9,1
800040ea:	fe f8 02 12 	ld.w	r8,pc[530]
800040ee:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800040f0:	8e 79       	ld.sh	r9,r7[0xe]
800040f2:	fe f8 01 fe 	ld.w	r8,pc[510]
800040f6:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800040f8:	4f 48       	lddpc	r8,800042c8 <phy_rx_func+0xc1c>
800040fa:	4e b9       	lddpc	r9,800042a4 <phy_rx_func+0xbf8>
800040fc:	72 0a       	ld.w	r10,r9[0x0]
800040fe:	70 09       	ld.w	r9,r8[0x0]
80004100:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004104:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004108:	70 09       	ld.w	r9,r8[0x0]
8000410a:	2f f9       	sub	r9,-1
8000410c:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000410e:	e0 49 01 ff 	cp.w	r9,511
80004112:	e0 88 00 13 	brls	80004138 <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80004116:	30 09       	mov	r9,0
80004118:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000411a:	4e 36       	lddpc	r6,800042a4 <phy_rx_func+0xbf8>
8000411c:	6c 0c       	ld.w	r12,r6[0x0]
8000411e:	f0 1f 00 6d 	mcall	800042d0 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80004122:	4e 08       	lddpc	r8,800042a0 <phy_rx_func+0xbf4>
80004124:	70 0c       	ld.w	r12,r8[0x0]
80004126:	f0 1f 00 59 	mcall	80004288 <phy_rx_func+0xbdc>
8000412a:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000412c:	c0 61       	brne	80004138 <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
8000412e:	30 09       	mov	r9,0
80004130:	4d e8       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
80004132:	91 09       	st.w	r8[0x0],r9
80004134:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004138:	4d e9       	lddpc	r9,800042b0 <phy_rx_func+0xc04>
8000413a:	72 08       	ld.w	r8,r9[0x0]
8000413c:	20 18       	sub	r8,1
8000413e:	93 08       	st.w	r9[0x0],r8
80004140:	c0 61       	brne	8000414c <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80004142:	30 09       	mov	r9,0
80004144:	4d 98       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
80004146:	91 09       	st.w	r8[0x0],r9
80004148:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
8000414c:	4d f8       	lddpc	r8,800042c8 <phy_rx_func+0xc1c>
8000414e:	4d 69       	lddpc	r9,800042a4 <phy_rx_func+0xbf8>
80004150:	72 0a       	ld.w	r10,r9[0x0]
80004152:	70 09       	ld.w	r9,r8[0x0]
80004154:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004158:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000415c:	70 09       	ld.w	r9,r8[0x0]
8000415e:	2f f9       	sub	r9,-1
80004160:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004162:	e0 49 01 ff 	cp.w	r9,511
80004166:	e0 88 00 13 	brls	8000418c <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
8000416a:	30 09       	mov	r9,0
8000416c:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
8000416e:	4c e7       	lddpc	r7,800042a4 <phy_rx_func+0xbf8>
80004170:	6e 0c       	ld.w	r12,r7[0x0]
80004172:	f0 1f 00 58 	mcall	800042d0 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80004176:	4c b8       	lddpc	r8,800042a0 <phy_rx_func+0xbf4>
80004178:	70 0c       	ld.w	r12,r8[0x0]
8000417a:	f0 1f 00 44 	mcall	80004288 <phy_rx_func+0xbdc>
8000417e:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004180:	c0 61       	brne	8000418c <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80004182:	30 09       	mov	r9,0
80004184:	4c 98       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
80004186:	91 09       	st.w	r8[0x0],r9
80004188:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000418c:	4c 99       	lddpc	r9,800042b0 <phy_rx_func+0xc04>
8000418e:	72 08       	ld.w	r8,r9[0x0]
80004190:	20 18       	sub	r8,1
80004192:	93 08       	st.w	r9[0x0],r8
80004194:	c6 c1       	brne	8000426c <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80004196:	30 09       	mov	r9,0
80004198:	4c 48       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
8000419a:	91 09       	st.w	r8[0x0],r9
8000419c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800041a0:	30 09       	mov	r9,0
800041a2:	4c 28       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
800041a4:	91 09       	st.w	r8[0x0],r9
800041a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800041aa:	8e 4a       	ld.sh	r10,r7[0x8]
800041ac:	4d 39       	lddpc	r9,800042f8 <phy_rx_func+0xc4c>
800041ae:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800041b2:	4d 1a       	lddpc	r10,800042f4 <phy_rx_func+0xc48>
800041b4:	15 88       	ld.ub	r8,r10[0x0]
800041b6:	f0 cb ff ff 	sub	r11,r8,-1
800041ba:	8e 5c       	ld.sh	r12,r7[0xa]
800041bc:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800041c0:	f0 cb ff fe 	sub	r11,r8,-2
800041c4:	8e 6c       	ld.sh	r12,r7[0xc]
800041c6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800041ca:	f0 cb ff fd 	sub	r11,r8,-3
800041ce:	8e 7c       	ld.sh	r12,r7[0xe]
800041d0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
800041d4:	2f c8       	sub	r8,-4
800041d6:	b4 88       	st.b	r10[0x0],r8
800041d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800041dc:	30 09       	mov	r9,0
800041de:	4b 38       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
800041e0:	91 09       	st.w	r8[0x0],r9
800041e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800041e6:	4b f8       	lddpc	r8,800042e0 <phy_rx_func+0xc34>
800041e8:	70 09       	ld.w	r9,r8[0x0]
800041ea:	8e 4b       	ld.sh	r11,r7[0x8]
800041ec:	4b ea       	lddpc	r10,800042e4 <phy_rx_func+0xc38>
800041ee:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800041f2:	2f f9       	sub	r9,-1
800041f4:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800041f6:	4b 48       	lddpc	r8,800042c4 <phy_rx_func+0xc18>
800041f8:	70 09       	ld.w	r9,r8[0x0]
800041fa:	20 29       	sub	r9,2
800041fc:	91 09       	st.w	r8[0x0],r9
800041fe:	70 08       	ld.w	r8,r8[0x0]
80004200:	58 08       	cp.w	r8,0
80004202:	c2 f1       	brne	80004260 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80004204:	30 09       	mov	r9,0
80004206:	4b 78       	lddpc	r8,800042e0 <phy_rx_func+0xc34>
80004208:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000420a:	8e 59       	ld.sh	r9,r7[0xa]
8000420c:	fe 78 82 12 	mov	r8,-32238
80004210:	f0 09 19 00 	cp.h	r9,r8
80004214:	c2 11       	brne	80004256 <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80004216:	ef 3c 00 0d 	ld.ub	r12,r7[13]
8000421a:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000421e:	4a e8       	lddpc	r8,800042d4 <phy_rx_func+0xc28>
80004220:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80004222:	8e 59       	ld.sh	r9,r7[0xa]
80004224:	4a d8       	lddpc	r8,800042d8 <phy_rx_func+0xc2c>
80004226:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80004228:	8e 69       	ld.sh	r9,r7[0xc]
8000422a:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
8000422c:	f0 1f 00 2c 	mcall	800042dc <phy_rx_func+0xc30>
80004230:	49 f8       	lddpc	r8,800042ac <phy_rx_func+0xc00>
80004232:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004234:	ef 39 00 0f 	ld.ub	r9,r7[15]
80004238:	31 38       	mov	r8,19
8000423a:	f0 09 18 00 	cp.b	r9,r8
8000423e:	c0 71       	brne	8000424c <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004240:	10 99       	mov	r9,r8
80004242:	4a 08       	lddpc	r8,800042c0 <phy_rx_func+0xc14>
80004244:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80004246:	30 09       	mov	r9,0
80004248:	49 a8       	lddpc	r8,800042b0 <phy_rx_func+0xc04>
8000424a:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
8000424c:	30 49       	mov	r9,4
8000424e:	49 78       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
80004250:	91 09       	st.w	r8[0x0],r9
80004252:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80004256:	30 09       	mov	r9,0
80004258:	49 48       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
8000425a:	91 09       	st.w	r8[0x0],r9
8000425c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004260:	4a 8c       	lddpc	r12,80004300 <phy_rx_func+0xc54>
80004262:	f0 1f 00 16 	mcall	800042b8 <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80004266:	30 09       	mov	r9,0
80004268:	49 08       	lddpc	r8,800042a8 <phy_rx_func+0xbfc>
8000426a:	91 09       	st.w	r8[0x0],r9
8000426c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004270:	00 00       	add	r0,r0
80004272:	0a c0       	st.b	r5++,r0
80004274:	00 00       	add	r0,r0
80004276:	0a b8       	st.h	r5++,r8
80004278:	00 00       	add	r0,r0
8000427a:	0a 8c       	andn	r12,r5
8000427c:	00 00       	add	r0,r0
8000427e:	0a 68       	and	r8,r5
80004280:	00 00       	add	r0,r0
80004282:	0a d2       	st.w	--r5,r2
80004284:	00 00       	add	r0,r0
80004286:	0a 98       	mov	r8,r5
80004288:	80 00       	ld.sh	r0,r0[0x0]
8000428a:	30 78       	mov	r8,7
8000428c:	00 00       	add	r0,r0
8000428e:	0a 78       	tst	r8,r5
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	5c fc       	rol	r12
80004294:	00 00       	add	r0,r0
80004296:	0a 94       	mov	r4,r5
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	2f c4       	sub	r4,-4
8000429c:	00 00       	add	r0,r0
8000429e:	0a a8       	st.w	r5++,r8
800042a0:	00 00       	add	r0,r0
800042a2:	0a 74       	tst	r4,r5
800042a4:	00 00       	add	r0,r0
800042a6:	0a b0       	st.h	r5++,r0
800042a8:	00 00       	add	r0,r0
800042aa:	0a 84       	andn	r4,r5
800042ac:	00 00       	add	r0,r0
800042ae:	0a 70       	tst	r0,r5
800042b0:	00 00       	add	r0,r0
800042b2:	0a 9c       	mov	r12,r5
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	d9 84       	*unknown*
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	6d 9c       	ld.w	r12,r6[0x64]
800042bc:	00 00       	add	r0,r0
800042be:	0a 54       	eor	r4,r5
800042c0:	00 00       	add	r0,r0
800042c2:	0a d0       	st.w	--r5,r0
800042c4:	00 00       	add	r0,r0
800042c6:	0a 6c       	and	r12,r5
800042c8:	00 00       	add	r0,r0
800042ca:	0a ac       	st.w	r5++,r12
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	76 12       	ld.w	r2,r11[0x4]
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	36 4c       	mov	r12,100
800042d4:	00 00       	add	r0,r0
800042d6:	0a 56       	eor	r6,r5
800042d8:	00 00       	add	r0,r0
800042da:	1e 8c       	andn	r12,pc
800042dc:	80 00       	ld.sh	r0,r0[0x0]
800042de:	2f 08       	sub	r8,-16
800042e0:	00 00       	add	r0,r0
800042e2:	0a c8       	st.b	r5++,r8
800042e4:	00 00       	add	r0,r0
800042e6:	1d 90       	ld.ub	r0,lr[0x1]
800042e8:	00 00       	add	r0,r0
800042ea:	0a d4       	st.w	--r5,r4
800042ec:	00 00       	add	r0,r0
800042ee:	0a 4c       	or	r12,r5
800042f0:	00 00       	add	r0,r0
800042f2:	1d 88       	ld.ub	r8,lr[0x0]
800042f4:	00 00       	add	r0,r0
800042f6:	0a 88       	andn	r8,r5
800042f8:	00 00       	add	r0,r0
800042fa:	1e 90       	mov	r0,pc
800042fc:	00 00       	add	r0,r0
800042fe:	0a 41       	or	r1,r5
80004300:	80 00       	ld.sh	r0,r0[0x0]
80004302:	d9 9c       	*unknown*

80004304 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004304:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004306:	49 88       	lddpc	r8,80004364 <pdca_int_handler+0x60>
80004308:	11 89       	ld.ub	r9,r8[0x0]
8000430a:	ec 19 00 01 	eorl	r9,0x1
8000430e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004310:	11 89       	ld.ub	r9,r8[0x0]
80004312:	a5 69       	lsl	r9,0x4
80004314:	2f c9       	sub	r9,-4
80004316:	49 5a       	lddpc	r10,80004368 <pdca_int_handler+0x64>
80004318:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000431a:	fe 7a 00 40 	mov	r10,-65472
8000431e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004320:	30 39       	mov	r9,3
80004322:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004324:	11 8a       	ld.ub	r10,r8[0x0]
80004326:	a5 6a       	lsl	r10,0x4
80004328:	2f ca       	sub	r10,-4
8000432a:	49 18       	lddpc	r8,8000436c <pdca_int_handler+0x68>
8000432c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000432e:	fe 78 00 00 	mov	r8,-65536
80004332:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004334:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004336:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004338:	48 e8       	lddpc	r8,80004370 <pdca_int_handler+0x6c>
8000433a:	70 08       	ld.w	r8,r8[0x0]
8000433c:	58 08       	cp.w	r8,0
8000433e:	c0 70       	breq	8000434c <pdca_int_handler+0x48>
80004340:	48 99       	lddpc	r9,80004364 <pdca_int_handler+0x60>
80004342:	13 89       	ld.ub	r9,r9[0x0]
80004344:	a5 69       	lsl	r9,0x4
80004346:	48 ac       	lddpc	r12,8000436c <pdca_int_handler+0x68>
80004348:	12 0c       	add	r12,r9
8000434a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
8000434c:	48 a8       	lddpc	r8,80004374 <pdca_int_handler+0x70>
8000434e:	70 08       	ld.w	r8,r8[0x0]
80004350:	58 08       	cp.w	r8,0
80004352:	c0 70       	breq	80004360 <pdca_int_handler+0x5c>
80004354:	48 49       	lddpc	r9,80004364 <pdca_int_handler+0x60>
80004356:	13 89       	ld.ub	r9,r9[0x0]
80004358:	a5 69       	lsl	r9,0x4
8000435a:	48 4c       	lddpc	r12,80004368 <pdca_int_handler+0x64>
8000435c:	12 0c       	add	r12,r9
8000435e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004360:	d4 02       	popm	lr
80004362:	d6 03       	rete
80004364:	00 00       	add	r0,r0
80004366:	50 b0       	stdsp	sp[0x2c],r0
80004368:	00 00       	add	r0,r0
8000436a:	50 d8       	stdsp	sp[0x34],r8
8000436c:	00 00       	add	r0,r0
8000436e:	50 b8       	stdsp	sp[0x2c],r8
80004370:	00 00       	add	r0,r0
80004372:	0a dc       	st.w	--r5,r12
80004374:	00 00       	add	r0,r0
80004376:	0a e0       	st.h	--r5,r0

80004378 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004378:	fe 78 10 00 	mov	r8,-61440
8000437c:	e0 69 0d c0 	mov	r9,3520
80004380:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004384:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004388:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
8000438c:	fe 78 34 00 	mov	r8,-52224
80004390:	e0 69 80 00 	mov	r9,32768
80004394:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004396:	30 09       	mov	r9,0
80004398:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000439a:	e0 69 04 21 	mov	r9,1057
8000439e:	ea 19 3f 20 	orh	r9,0x3f20
800043a2:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
800043a4:	e0 69 02 9f 	mov	r9,671
800043a8:	ea 19 01 00 	orh	r9,0x100
800043ac:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
800043ae:	e0 6a 04 02 	mov	r10,1026
800043b2:	ea 1a 3f 20 	orh	r10,0x3f20
800043b6:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
800043b8:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800043ba:	5e fc       	retal	r12

800043bc <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800043bc:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800043be:	30 19       	mov	r9,1
800043c0:	49 78       	lddpc	r8,8000441c <local_start_PDC+0x60>
800043c2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800043c4:	fe 78 00 00 	mov	r8,-65536
800043c8:	30 7b       	mov	r11,7
800043ca:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800043cc:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800043ce:	49 59       	lddpc	r9,80004420 <local_start_PDC+0x64>
800043d0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800043d4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800043d6:	30 3a       	mov	r10,3
800043d8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800043da:	30 1c       	mov	r12,1
800043dc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800043de:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800043e0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800043e2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800043e4:	30 2c       	mov	r12,2
800043e6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800043e8:	48 f9       	lddpc	r9,80004424 <local_start_PDC+0x68>
800043ea:	e0 68 5a 5a 	mov	r8,23130
800043ee:	ea 18 ab cd 	orh	r8,0xabcd
800043f2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800043f4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800043f6:	30 0e       	mov	lr,0
800043f8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800043fa:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800043fc:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800043fe:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004400:	fe 78 00 40 	mov	r8,-65472
80004404:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004406:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004408:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
8000440c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000440e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004410:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004412:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004414:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004416:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004418:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000441a:	d8 02       	popm	pc
8000441c:	00 00       	add	r0,r0
8000441e:	50 b0       	stdsp	sp[0x2c],r0
80004420:	00 00       	add	r0,r0
80004422:	50 b8       	stdsp	sp[0x2c],r8
80004424:	00 00       	add	r0,r0
80004426:	50 d8       	stdsp	sp[0x34],r8

80004428 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004428:	48 38       	lddpc	r8,80004434 <register_rx_tx_func+0xc>
8000442a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
8000442c:	48 38       	lddpc	r8,80004438 <register_rx_tx_func+0x10>
8000442e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004430:	5e fc       	retal	r12
80004432:	00 00       	add	r0,r0
80004434:	00 00       	add	r0,r0
80004436:	0a dc       	st.w	--r5,r12
80004438:	00 00       	add	r0,r0
8000443a:	0a e0       	st.h	--r5,r0

8000443c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
8000443c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000443e:	fe 78 10 00 	mov	r8,-61440
80004442:	30 29       	mov	r9,2
80004444:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004448:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000444c:	10 99       	mov	r9,r8
8000444e:	f2 f8 01 60 	ld.w	r8,r9[352]
80004452:	e2 18 00 02 	andl	r8,0x2,COH
80004456:	cf c0       	breq	8000444e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004458:	fe 79 10 00 	mov	r9,-61440
8000445c:	f2 f8 01 60 	ld.w	r8,r9[352]
80004460:	e2 18 00 02 	andl	r8,0x2,COH
80004464:	cf c1       	brne	8000445c <ssc_init+0x20>
				
    INTC_register_interrupt (
80004466:	30 3a       	mov	r10,3
80004468:	36 0b       	mov	r11,96
8000446a:	48 bc       	lddpc	r12,80004494 <ssc_init+0x58>
8000446c:	f0 1f 00 0b 	mcall	80004498 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004470:	f0 1f 00 0b 	mcall	8000449c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80004474:	f0 1f 00 0b 	mcall	800044a0 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004478:	fe 79 00 00 	mov	r9,-65536
8000447c:	30 18       	mov	r8,1
8000447e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004480:	fe 7a 00 40 	mov	r10,-65472
80004484:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004486:	e0 6b 01 01 	mov	r11,257
8000448a:	fe 7a 34 00 	mov	r10,-52224
8000448e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004490:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004492:	d8 02       	popm	pc
80004494:	80 00       	ld.sh	r0,r0[0x0]
80004496:	43 04       	lddsp	r4,sp[0xc0]
80004498:	80 00       	ld.sh	r0,r0[0x0]
8000449a:	54 50       	stdsp	sp[0x114],r0
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	43 78       	lddsp	r8,sp[0xdc]
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	43 bc       	lddsp	r12,sp[0xec]

800044a4 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800044a4:	48 28       	lddpc	r8,800044ac <xcmp_register_app_list+0x8>
800044a6:	91 0c       	st.w	r8[0x0],r12
}
800044a8:	5e fc       	retal	r12
800044aa:	00 00       	add	r0,r0
800044ac:	00 00       	add	r0,r0
800044ae:	50 f8       	stdsp	sp[0x3c],r8

800044b0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800044b0:	eb cd 40 80 	pushm	r7,lr
800044b4:	fa cd 01 00 	sub	sp,sp,256
800044b8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800044ba:	16 98       	mov	r8,r11
800044bc:	2f 08       	sub	r8,-16
800044be:	af a8       	sbr	r8,0xe
800044c0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800044c2:	3f f8       	mov	r8,-1
800044c4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800044c6:	30 b9       	mov	r9,11
800044c8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800044ca:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800044cc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800044ce:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800044d0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800044d2:	f6 ca ff fe 	sub	r10,r11,-2
800044d6:	18 9b       	mov	r11,r12
800044d8:	fa cc ff f0 	sub	r12,sp,-16
800044dc:	f0 1f 00 05 	mcall	800044f0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800044e0:	2f e7       	sub	r7,-2
800044e2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800044e4:	1a 9c       	mov	r12,sp
800044e6:	f0 1f 00 04 	mcall	800044f4 <xcmp_tx+0x44>
}
800044ea:	2c 0d       	sub	sp,-256
800044ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800044f0:	80 00       	ld.sh	r0,r0[0x0]
800044f2:	74 ca       	ld.w	r10,r10[0x30]
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	49 b0       	lddpc	r0,80004560 <xcmp_audio_route_AMBE+0x3c>

800044f8 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
800044f8:	d4 01       	pushm	lr
800044fa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
800044fe:	e0 68 04 21 	mov	r8,1057
80004502:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80004504:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80004508:	30 19       	mov	r9,1
8000450a:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
8000450c:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
8000450e:	30 39       	mov	r9,3
80004510:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80004512:	30 3b       	mov	r11,3
80004514:	fa cc ff fe 	sub	r12,sp,-2
80004518:	f0 1f 00 02 	mcall	80004520 <xcmp_enter_device_control_mode+0x28>
}
8000451c:	2c dd       	sub	sp,-204
8000451e:	d8 02       	popm	pc
80004520:	80 00       	ld.sh	r0,r0[0x0]
80004522:	44 b0       	lddsp	r0,sp[0x12c]

80004524 <xcmp_audio_route_AMBE>:
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
}


void xcmp_audio_route_AMBE(void)
{
80004524:	d4 01       	pushm	lr
80004526:	fa cd 00 cc 	sub	sp,sp,204

	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
8000452a:	e0 68 04 14 	mov	r8,1044
8000452e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004530:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80004534:	30 19       	mov	r9,1
80004536:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;// 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004538:	30 09       	mov	r9,0
8000453a:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
8000453c:	30 69       	mov	r9,6
8000453e:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80004540:	30 fa       	mov	r10,15
80004542:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004544:	30 c9       	mov	r9,12
80004546:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80004548:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
8000454a:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
8000454c:	31 0a       	mov	r10,16
8000454e:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004550:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
80004554:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
80004558:	f1 6a 00 0a 	st.b	r8[10],r10
	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
8000455c:	31 1a       	mov	r10,17
8000455e:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
80004562:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80004566:	31 3a       	mov	r10,19
80004568:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
8000456c:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80004570:	30 fb       	mov	r11,15
80004572:	fa cc ff fe 	sub	r12,sp,-2
80004576:	f0 1f 00 03 	mcall	80004580 <xcmp_audio_route_AMBE+0x5c>

	
}
8000457a:	2c dd       	sub	sp,-204
8000457c:	d8 02       	popm	pc
8000457e:	00 00       	add	r0,r0
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	44 b0       	lddsp	r0,sp[0x12c]

80004584 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80004584:	d4 01       	pushm	lr
80004586:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
8000458a:	e0 68 04 65 	mov	r8,1125
8000458e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80004590:	fa cc ff fe 	sub	r12,sp,-2
80004594:	30 18       	mov	r8,1
80004596:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80004598:	30 1b       	mov	r11,1
8000459a:	f0 1f 00 03 	mcall	800045a4 <xcmp_enter_enhanced_OB_mode+0x20>
}
8000459e:	2c dd       	sub	sp,-204
800045a0:	d8 02       	popm	pc
800045a2:	00 00       	add	r0,r0
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	44 b0       	lddsp	r0,sp[0x12c]

800045a8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800045a8:	d4 01       	pushm	lr
800045aa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800045ae:	fe 78 b4 00 	mov	r8,-19456
800045b2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800045b4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800045b8:	30 89       	mov	r9,8
800045ba:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800045bc:	30 19       	mov	r9,1
800045be:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800045c0:	30 09       	mov	r9,0
800045c2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800045c4:	30 5a       	mov	r10,5
800045c6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800045c8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800045ca:	30 7a       	mov	r10,7
800045cc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800045ce:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800045d0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800045d2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800045d6:	30 9b       	mov	r11,9
800045d8:	fa cc ff fe 	sub	r12,sp,-2
800045dc:	f0 1f 00 02 	mcall	800045e4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800045e0:	2c dd       	sub	sp,-204
800045e2:	d8 02       	popm	pc
800045e4:	80 00       	ld.sh	r0,r0[0x0]
800045e6:	44 b0       	lddsp	r0,sp[0x12c]

800045e8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800045e8:	d4 01       	pushm	lr
800045ea:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800045ee:	fe 78 80 00 	mov	r8,-32768
800045f2:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800045f4:	30 38       	mov	r8,3
800045f6:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800045f8:	30 1b       	mov	r11,1
800045fa:	fa cc ff fe 	sub	r12,sp,-2
800045fe:	f0 1f 00 03 	mcall	80004608 <xcmp_opcode_not_supported+0x20>
}
80004602:	2c dd       	sub	sp,-204
80004604:	d8 02       	popm	pc
80004606:	00 00       	add	r0,r0
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	44 b0       	lddsp	r0,sp[0x12c]

8000460c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
8000460c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000460e:	96 88       	ld.uh	r8,r11[0x0]
80004610:	e2 18 f0 00 	andl	r8,0xf000,COH
80004614:	e0 48 80 00 	cp.w	r8,32768
80004618:	c0 f0       	breq	80004636 <xcmp_exec_func+0x2a>
8000461a:	e0 48 b0 00 	cp.w	r8,45056
8000461e:	c1 20       	breq	80004642 <xcmp_exec_func+0x36>
80004620:	58 08       	cp.w	r8,0
80004622:	c1 51       	brne	8000464c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004624:	78 08       	ld.w	r8,r12[0x0]
80004626:	58 08       	cp.w	r8,0
80004628:	c0 40       	breq	80004630 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000462a:	16 9c       	mov	r12,r11
8000462c:	5d 18       	icall	r8
8000462e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004630:	f0 1f 00 08 	mcall	80004650 <xcmp_exec_func+0x44>
80004634:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004636:	78 18       	ld.w	r8,r12[0x4]
80004638:	58 08       	cp.w	r8,0
8000463a:	c0 90       	breq	8000464c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000463c:	16 9c       	mov	r12,r11
8000463e:	5d 18       	icall	r8
80004640:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004642:	78 28       	ld.w	r8,r12[0x8]
80004644:	58 08       	cp.w	r8,0
80004646:	c0 30       	breq	8000464c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004648:	16 9c       	mov	r12,r11
8000464a:	5d 18       	icall	r8
8000464c:	d8 02       	popm	pc
8000464e:	00 00       	add	r0,r0
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	45 e8       	lddsp	r8,sp[0x178]

80004654 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004654:	d4 01       	pushm	lr
80004656:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000465a:	e0 68 04 09 	mov	r8,1033
8000465e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004660:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004664:	30 19       	mov	r9,1
80004666:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80004668:	30 09       	mov	r9,0
8000466a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
8000466c:	30 ca       	mov	r10,12
8000466e:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004670:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004672:	fb 69 00 08 	st.b	sp[8],r9
80004676:	fa c8 ff f7 	sub	r8,sp,-9
8000467a:	b0 89       	st.b	r8[0x0],r9
8000467c:	fa c8 ff f6 	sub	r8,sp,-10
80004680:	b0 89       	st.b	r8[0x0],r9
80004682:	fa c8 ff f5 	sub	r8,sp,-11
80004686:	b0 89       	st.b	r8[0x0],r9
80004688:	fa c8 ff f4 	sub	r8,sp,-12
8000468c:	b0 89       	st.b	r8[0x0],r9
8000468e:	fa c8 ff f3 	sub	r8,sp,-13
80004692:	b0 89       	st.b	r8[0x0],r9
80004694:	fa c8 ff f2 	sub	r8,sp,-14
80004698:	b0 89       	st.b	r8[0x0],r9
8000469a:	fa c8 ff f1 	sub	r8,sp,-15
8000469e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800046a0:	30 cb       	mov	r11,12
800046a2:	fa cc ff fe 	sub	r12,sp,-2
800046a6:	f0 1f 00 03 	mcall	800046b0 <xcmp_IdleTestTone+0x5c>
}
800046aa:	2c dd       	sub	sp,-204
800046ac:	d8 02       	popm	pc
800046ae:	00 00       	add	r0,r0
800046b0:	80 00       	ld.sh	r0,r0[0x0]
800046b2:	44 b0       	lddsp	r0,sp[0x12c]

800046b4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800046b4:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800046b6:	48 dc       	lddpc	r12,800046e8 <xcmp_init+0x34>
800046b8:	f0 1f 00 0d 	mcall	800046ec <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800046bc:	30 4b       	mov	r11,4
800046be:	31 4c       	mov	r12,20
800046c0:	f0 1f 00 0c 	mcall	800046f0 <xcmp_init+0x3c>
800046c4:	48 c8       	lddpc	r8,800046f4 <xcmp_init+0x40>
800046c6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800046c8:	30 09       	mov	r9,0
800046ca:	1a d9       	st.w	--sp,r9
800046cc:	1a d9       	st.w	--sp,r9
800046ce:	1a d9       	st.w	--sp,r9
800046d0:	30 38       	mov	r8,3
800046d2:	e0 6a 01 80 	mov	r10,384
800046d6:	48 9b       	lddpc	r11,800046f8 <xcmp_init+0x44>
800046d8:	48 9c       	lddpc	r12,800046fc <xcmp_init+0x48>
800046da:	f0 1f 00 0a 	mcall	80004700 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800046de:	f0 1f 00 0a 	mcall	80004704 <xcmp_init+0x50>
800046e2:	2f dd       	sub	sp,-12
	
}
800046e4:	d8 02       	popm	pc
800046e6:	00 00       	add	r0,r0
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	48 04       	lddpc	r4,800046e8 <xcmp_init+0x34>
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	48 50       	lddpc	r0,80004700 <xcmp_init+0x4c>
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	61 78       	ld.w	r8,r0[0x5c]
800046f4:	00 00       	add	r0,r0
800046f6:	0a f0       	st.b	--r5,r0
800046f8:	80 00       	ld.sh	r0,r0[0x0]
800046fa:	d9 c8       	*unknown*
800046fc:	80 00       	ld.sh	r0,r0[0x0]
800046fe:	47 08       	lddsp	r8,sp[0x1c0]
80004700:	80 00       	ld.sh	r0,r0[0x0]
80004702:	68 4c       	ld.w	r12,r4[0x10]
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	4a 94       	lddpc	r4,800047a8 <xcmp_rx_process+0xa0>

80004708 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004708:	d4 31       	pushm	r0-r7,lr
8000470a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000470c:	4b 16       	lddpc	r6,800047d0 <xcmp_rx_process+0xc8>
8000470e:	30 05       	mov	r5,0
80004710:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004712:	4b 13       	lddpc	r3,800047d4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004714:	4b 12       	lddpc	r2,800047d8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004716:	4b 21       	lddpc	r1,800047dc <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004718:	4b 20       	lddpc	r0,800047e0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000471a:	6c 0c       	ld.w	r12,r6[0x0]
8000471c:	0a 99       	mov	r9,r5
8000471e:	08 9a       	mov	r10,r4
80004720:	1a 9b       	mov	r11,sp
80004722:	f0 1f 00 31 	mcall	800047e4 <xcmp_rx_process+0xdc>
80004726:	58 1c       	cp.w	r12,1
80004728:	cf 91       	brne	8000471a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000472a:	40 0b       	lddsp	r11,sp[0x0]
8000472c:	58 0b       	cp.w	r11,0
8000472e:	cf 60       	breq	8000471a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004730:	96 0a       	ld.sh	r10,r11[0x0]
80004732:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004736:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000473a:	59 c8       	cp.w	r8,28
8000473c:	c1 e0       	breq	80004778 <xcmp_rx_process+0x70>
8000473e:	e0 89 00 07 	brgt	8000474c <xcmp_rx_process+0x44>
80004742:	58 e8       	cp.w	r8,14
80004744:	c0 e0       	breq	80004760 <xcmp_rx_process+0x58>
80004746:	58 f8       	cp.w	r8,15
80004748:	c2 41       	brne	80004790 <xcmp_rx_process+0x88>
8000474a:	c0 f8       	rjmp	80004768 <xcmp_rx_process+0x60>
8000474c:	e0 48 01 09 	cp.w	r8,265
80004750:	c1 80       	breq	80004780 <xcmp_rx_process+0x78>
80004752:	e0 48 01 0a 	cp.w	r8,266
80004756:	c1 90       	breq	80004788 <xcmp_rx_process+0x80>
80004758:	e0 48 00 2c 	cp.w	r8,44
8000475c:	c1 a1       	brne	80004790 <xcmp_rx_process+0x88>
8000475e:	c0 98       	rjmp	80004770 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004760:	4a 2c       	lddpc	r12,800047e8 <xcmp_rx_process+0xe0>
80004762:	f0 1f 00 23 	mcall	800047ec <xcmp_rx_process+0xe4>
					break;
80004766:	c2 f8       	rjmp	800047c4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004768:	4a 2c       	lddpc	r12,800047f0 <xcmp_rx_process+0xe8>
8000476a:	f0 1f 00 21 	mcall	800047ec <xcmp_rx_process+0xe4>
					break;
8000476e:	c2 b8       	rjmp	800047c4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004770:	4a 1c       	lddpc	r12,800047f4 <xcmp_rx_process+0xec>
80004772:	f0 1f 00 1f 	mcall	800047ec <xcmp_rx_process+0xe4>
					break;
80004776:	c2 78       	rjmp	800047c4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004778:	04 9c       	mov	r12,r2
8000477a:	f0 1f 00 1d 	mcall	800047ec <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000477e:	c2 38       	rjmp	800047c4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004780:	02 9c       	mov	r12,r1
80004782:	f0 1f 00 1b 	mcall	800047ec <xcmp_rx_process+0xe4>
					break;
80004786:	c1 f8       	rjmp	800047c4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004788:	00 9c       	mov	r12,r0
8000478a:	f0 1f 00 19 	mcall	800047ec <xcmp_rx_process+0xe4>
					break;
8000478e:	c1 b8       	rjmp	800047c4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004790:	12 98       	mov	r8,r9
80004792:	e2 18 04 00 	andl	r8,0x400,COH
80004796:	c0 70       	breq	800047a4 <xcmp_rx_process+0x9c>
80004798:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000479c:	e0 48 00 68 	cp.w	r8,104
800047a0:	e0 8a 00 08 	brle	800047b0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800047a4:	e2 19 f0 00 	andl	r9,0xf000,COH
800047a8:	c0 e1       	brne	800047c4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800047aa:	f0 1f 00 14 	mcall	800047f8 <xcmp_rx_process+0xf0>
800047ae:	c0 b8       	rjmp	800047c4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800047b0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800047b4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800047b8:	49 19       	lddpc	r9,800047fc <xcmp_rx_process+0xf4>
800047ba:	72 08       	ld.w	r8,r9[0x0]
800047bc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800047c0:	f0 1f 00 0b 	mcall	800047ec <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800047c4:	66 0c       	ld.w	r12,r3[0x0]
800047c6:	40 0b       	lddsp	r11,sp[0x0]
800047c8:	f0 1f 00 0e 	mcall	80004800 <xcmp_rx_process+0xf8>
800047cc:	ca 7b       	rjmp	8000471a <xcmp_rx_process+0x12>
800047ce:	00 00       	add	r0,r0
800047d0:	00 00       	add	r0,r0
800047d2:	0a f0       	st.b	--r5,r0
800047d4:	00 00       	add	r0,r0
800047d6:	0a 98       	mov	r8,r5
800047d8:	00 00       	add	r0,r0
800047da:	0b 00       	ld.w	r0,r5++
800047dc:	00 00       	add	r0,r0
800047de:	0a f4       	st.b	--r5,r4
800047e0:	00 00       	add	r0,r0
800047e2:	0b 0c       	ld.w	r12,r5++
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	5e 6c       	retmi	r12
800047e8:	00 00       	add	r0,r0
800047ea:	0b 24       	ld.uh	r4,r5++
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	46 0c       	lddsp	r12,sp[0x180]
800047f0:	00 00       	add	r0,r0
800047f2:	0a e4       	st.h	--r5,r4
800047f4:	00 00       	add	r0,r0
800047f6:	0b 18       	ld.sh	r8,r5++
800047f8:	80 00       	ld.sh	r0,r0[0x0]
800047fa:	45 e8       	lddsp	r8,sp[0x178]
800047fc:	00 00       	add	r0,r0
800047fe:	50 f8       	stdsp	sp[0x3c],r8
80004800:	80 00       	ld.sh	r0,r0[0x0]
80004802:	2f fc       	sub	r12,-1

80004804 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004804:	eb cd 40 90 	pushm	r4,r7,lr
80004808:	20 1d       	sub	sp,4
8000480a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000480e:	48 c8       	lddpc	r8,8000483c <xcmp_rx+0x38>
80004810:	70 0c       	ld.w	r12,r8[0x0]
80004812:	f0 1f 00 0c 	mcall	80004840 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004816:	c1 00       	breq	80004836 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004818:	fa c7 ff fc 	sub	r7,sp,-4
8000481c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000481e:	e0 6a 00 ca 	mov	r10,202
80004822:	08 9b       	mov	r11,r4
80004824:	f0 1f 00 08 	mcall	80004844 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004828:	48 88       	lddpc	r8,80004848 <xcmp_rx+0x44>
8000482a:	70 0c       	ld.w	r12,r8[0x0]
8000482c:	30 09       	mov	r9,0
8000482e:	12 9a       	mov	r10,r9
80004830:	1a 9b       	mov	r11,sp
80004832:	f0 1f 00 07 	mcall	8000484c <xcmp_rx+0x48>
	}	
}
80004836:	2f fd       	sub	sp,-4
80004838:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000483c:	00 00       	add	r0,r0
8000483e:	0a 98       	mov	r8,r5
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	35 68       	mov	r8,86
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	74 ca       	ld.w	r10,r10[0x30]
80004848:	00 00       	add	r0,r0
8000484a:	0a f0       	st.b	--r5,r0
8000484c:	80 00       	ld.sh	r0,r0[0x0]
8000484e:	60 78       	ld.w	r8,r0[0x1c]

80004850 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004850:	48 28       	lddpc	r8,80004858 <xnl_register_xcmp_func+0x8>
80004852:	91 0c       	st.w	r8[0x0],r12
}
80004854:	5e fc       	retal	r12
80004856:	00 00       	add	r0,r0
80004858:	00 00       	add	r0,r0
8000485a:	0b 50       	ld.sh	r0,--r5

8000485c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000485c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000485e:	48 88       	lddpc	r8,8000487c <xnl_get_msg_ack_func+0x20>
80004860:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004862:	98 49       	ld.sh	r9,r12[0x8]
80004864:	f0 09 19 00 	cp.h	r9,r8
80004868:	c0 81       	brne	80004878 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000486a:	48 68       	lddpc	r8,80004880 <xnl_get_msg_ack_func+0x24>
8000486c:	70 0c       	ld.w	r12,r8[0x0]
8000486e:	30 09       	mov	r9,0
80004870:	12 9a       	mov	r10,r9
80004872:	12 9b       	mov	r11,r9
80004874:	f0 1f 00 04 	mcall	80004884 <xnl_get_msg_ack_func+0x28>
80004878:	d8 02       	popm	pc
8000487a:	00 00       	add	r0,r0
8000487c:	00 00       	add	r0,r0
8000487e:	0b 36       	ld.ub	r6,r5++
80004880:	00 00       	add	r0,r0
80004882:	0b 30       	ld.ub	r0,r5++
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	60 78       	ld.w	r8,r0[0x1c]

80004888 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004888:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000488a:	4a 86       	lddpc	r6,80004928 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000488c:	4a 82       	lddpc	r2,8000492c <xnl_tx_process+0xa4>
8000488e:	4a 94       	lddpc	r4,80004930 <xnl_tx_process+0xa8>
80004890:	30 07       	mov	r7,0
80004892:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004894:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004896:	4a 85       	lddpc	r5,80004934 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004898:	4a 83       	lddpc	r3,80004938 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000489a:	6c 08       	ld.w	r8,r6[0x0]
8000489c:	58 08       	cp.w	r8,0
8000489e:	c0 40       	breq	800048a6 <xnl_tx_process+0x1e>
800048a0:	58 18       	cp.w	r8,1
800048a2:	cf d1       	brne	8000489c <xnl_tx_process+0x14>
800048a4:	c2 08       	rjmp	800048e4 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800048a6:	64 0c       	ld.w	r12,r2[0x0]
800048a8:	0e 99       	mov	r9,r7
800048aa:	02 9a       	mov	r10,r1
800048ac:	08 9b       	mov	r11,r4
800048ae:	f0 1f 00 24 	mcall	8000493c <xnl_tx_process+0xb4>
800048b2:	58 1c       	cp.w	r12,1
800048b4:	cf 31       	brne	8000489a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800048b6:	68 0c       	ld.w	r12,r4[0x0]
800048b8:	58 0c       	cp.w	r12,0
800048ba:	cf 00       	breq	8000489a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800048bc:	98 28       	ld.sh	r8,r12[0x4]
800048be:	e0 08 19 00 	cp.h	r8,r0
800048c2:	c0 41       	brne	800048ca <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800048c4:	f0 1f 00 1f 	mcall	80004940 <xnl_tx_process+0xb8>
						break;
800048c8:	ce 9b       	rjmp	8000489a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800048ca:	f0 1f 00 1f 	mcall	80004944 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800048ce:	30 18       	mov	r8,1
800048d0:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800048d2:	66 0c       	ld.w	r12,r3[0x0]
800048d4:	0e 99       	mov	r9,r7
800048d6:	0e 9a       	mov	r10,r7
800048d8:	0e 9b       	mov	r11,r7
800048da:	f0 1f 00 19 	mcall	8000493c <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800048de:	30 18       	mov	r8,1
800048e0:	8d 08       	st.w	r6[0x0],r8
800048e2:	cd cb       	rjmp	8000489a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800048e4:	66 0c       	ld.w	r12,r3[0x0]
800048e6:	0e 99       	mov	r9,r7
800048e8:	36 4a       	mov	r10,100
800048ea:	0e 9b       	mov	r11,r7
800048ec:	f0 1f 00 14 	mcall	8000493c <xnl_tx_process+0xb4>
800048f0:	58 1c       	cp.w	r12,1
800048f2:	c0 81       	brne	80004902 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800048f4:	49 58       	lddpc	r8,80004948 <xnl_tx_process+0xc0>
800048f6:	70 0c       	ld.w	r12,r8[0x0]
800048f8:	68 0b       	ld.w	r11,r4[0x0]
800048fa:	f0 1f 00 15 	mcall	8000494c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800048fe:	8d 07       	st.w	r6[0x0],r7
80004900:	cc db       	rjmp	8000489a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004902:	6a 08       	ld.w	r8,r5[0x0]
80004904:	58 38       	cp.w	r8,3
80004906:	e0 89 00 09 	brgt	80004918 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000490a:	68 0c       	ld.w	r12,r4[0x0]
8000490c:	f0 1f 00 0e 	mcall	80004944 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004910:	6a 08       	ld.w	r8,r5[0x0]
80004912:	2f f8       	sub	r8,-1
80004914:	8b 08       	st.w	r5[0x0],r8
80004916:	cc 2b       	rjmp	8000489a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004918:	48 c8       	lddpc	r8,80004948 <xnl_tx_process+0xc0>
8000491a:	70 0c       	ld.w	r12,r8[0x0]
8000491c:	68 0b       	ld.w	r11,r4[0x0]
8000491e:	f0 1f 00 0c 	mcall	8000494c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004922:	8d 07       	st.w	r6[0x0],r7
80004924:	cb bb       	rjmp	8000489a <xnl_tx_process+0x12>
80004926:	00 00       	add	r0,r0
80004928:	00 00       	add	r0,r0
8000492a:	0b 4c       	ld.w	r12,--r5
8000492c:	00 00       	add	r0,r0
8000492e:	0b 40       	ld.w	r0,--r5
80004930:	00 00       	add	r0,r0
80004932:	0b 44       	ld.w	r4,--r5
80004934:	00 00       	add	r0,r0
80004936:	0b 48       	ld.w	r8,--r5
80004938:	00 00       	add	r0,r0
8000493a:	0b 30       	ld.ub	r0,r5++
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	5e 6c       	retmi	r12
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	5c fc       	rol	r12
80004944:	80 00       	ld.sh	r0,r0[0x0]
80004946:	30 1c       	mov	r12,1
80004948:	00 00       	add	r0,r0
8000494a:	0a 98       	mov	r8,r5
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	2f fc       	sub	r12,-1

80004950 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004950:	eb cd 40 fe 	pushm	r1-r7,lr
80004954:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004956:	49 26       	lddpc	r6,8000499c <xnl_rx_process+0x4c>
80004958:	30 05       	mov	r5,0
8000495a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000495c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000495e:	49 11       	lddpc	r1,800049a0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004960:	49 12       	lddpc	r2,800049a4 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004962:	6c 0c       	ld.w	r12,r6[0x0]
80004964:	0a 99       	mov	r9,r5
80004966:	08 9a       	mov	r10,r4
80004968:	1a 9b       	mov	r11,sp
8000496a:	f0 1f 00 10 	mcall	800049a8 <xnl_rx_process+0x58>
8000496e:	58 1c       	cp.w	r12,1
80004970:	cf 91       	brne	80004962 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004972:	40 0c       	lddsp	r12,sp[0x0]
80004974:	58 0c       	cp.w	r12,0
80004976:	cf 60       	breq	80004962 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004978:	98 28       	ld.sh	r8,r12[0x4]
8000497a:	e6 08 19 00 	cp.h	r8,r3
8000497e:	e0 8b 00 0a 	brhi	80004992 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004982:	5c 78       	castu.h	r8
80004984:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004988:	58 09       	cp.w	r9,0
8000498a:	c0 40       	breq	80004992 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000498c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004990:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004992:	62 0c       	ld.w	r12,r1[0x0]
80004994:	40 0b       	lddsp	r11,sp[0x0]
80004996:	f0 1f 00 06 	mcall	800049ac <xnl_rx_process+0x5c>
8000499a:	ce 4b       	rjmp	80004962 <xnl_rx_process+0x12>
8000499c:	00 00       	add	r0,r0
8000499e:	0a c0       	st.b	r5++,r0
800049a0:	00 00       	add	r0,r0
800049a2:	0a 98       	mov	r8,r5
800049a4:	00 00       	add	r0,r0
800049a6:	04 f0       	st.b	--r2,r0
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	5e 6c       	retmi	r12
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	2f fc       	sub	r12,-1

800049b0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800049b0:	eb cd 40 c0 	pushm	r6-r7,lr
800049b4:	20 1d       	sub	sp,4
800049b6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800049b8:	98 39       	ld.sh	r9,r12[0x6]
800049ba:	3f f8       	mov	r8,-1
800049bc:	f0 09 19 00 	cp.h	r9,r8
800049c0:	c0 a1       	brne	800049d4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800049c2:	4a e9       	lddpc	r9,80004a78 <xnl_tx+0xc8>
800049c4:	13 88       	ld.ub	r8,r9[0x0]
800049c6:	2f f8       	sub	r8,-1
800049c8:	5c 58       	castu.b	r8
800049ca:	b2 88       	st.b	r9[0x0],r8
800049cc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800049d0:	a9 a8       	sbr	r8,0x8
800049d2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800049d4:	8c 49       	ld.sh	r9,r6[0x8]
800049d6:	3f f8       	mov	r8,-1
800049d8:	f0 09 19 00 	cp.h	r9,r8
800049dc:	c0 41       	brne	800049e4 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800049de:	4a 88       	lddpc	r8,80004a7c <xnl_tx+0xcc>
800049e0:	90 18       	ld.sh	r8,r8[0x2]
800049e2:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800049e4:	8c 59       	ld.sh	r9,r6[0xa]
800049e6:	3f f8       	mov	r8,-1
800049e8:	f0 09 19 00 	cp.h	r9,r8
800049ec:	c0 41       	brne	800049f4 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800049ee:	4a 48       	lddpc	r8,80004a7c <xnl_tx+0xcc>
800049f0:	90 28       	ld.sh	r8,r8[0x4]
800049f2:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800049f4:	8c 69       	ld.sh	r9,r6[0xc]
800049f6:	3f f8       	mov	r8,-1
800049f8:	f0 09 19 00 	cp.h	r9,r8
800049fc:	c0 e1       	brne	80004a18 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800049fe:	4a 08       	lddpc	r8,80004a7c <xnl_tx+0xcc>
80004a00:	90 49       	ld.sh	r9,r8[0x8]
80004a02:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004a04:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004a06:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004a08:	90 49       	ld.sh	r9,r8[0x8]
80004a0a:	e0 19 ff 00 	andl	r9,0xff00
80004a0e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004a12:	f3 e8 10 08 	or	r8,r9,r8
80004a16:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004a18:	0d 98       	ld.ub	r8,r6[0x1]
80004a1a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004a1c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004a20:	10 0c       	add	r12,r8
80004a22:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004a24:	58 0c       	cp.w	r12,0
80004a26:	e0 89 00 04 	brgt	80004a2e <xnl_tx+0x7e>
80004a2a:	30 09       	mov	r9,0
80004a2c:	c0 d8       	rjmp	80004a46 <xnl_tx+0x96>
80004a2e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004a32:	2f ec       	sub	r12,-2
80004a34:	30 09       	mov	r9,0
80004a36:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004a38:	15 1b       	ld.sh	r11,r10++
80004a3a:	f6 09 00 09 	add	r9,r11,r9
80004a3e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004a40:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004a42:	18 38       	cp.w	r8,r12
80004a44:	cf a1       	brne	80004a38 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004a46:	5c 39       	neg	r9
80004a48:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a4a:	48 e8       	lddpc	r8,80004a80 <xnl_tx+0xd0>
80004a4c:	70 0c       	ld.w	r12,r8[0x0]
80004a4e:	f0 1f 00 0e 	mcall	80004a84 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004a52:	c1 00       	breq	80004a72 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004a54:	fa c7 ff fc 	sub	r7,sp,-4
80004a58:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004a5a:	e0 6a 01 00 	mov	r10,256
80004a5e:	0c 9b       	mov	r11,r6
80004a60:	f0 1f 00 0a 	mcall	80004a88 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004a64:	48 a8       	lddpc	r8,80004a8c <xnl_tx+0xdc>
80004a66:	70 0c       	ld.w	r12,r8[0x0]
80004a68:	30 09       	mov	r9,0
80004a6a:	12 9a       	mov	r10,r9
80004a6c:	1a 9b       	mov	r11,sp
80004a6e:	f0 1f 00 09 	mcall	80004a90 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004a72:	2f fd       	sub	sp,-4
80004a74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a78:	00 00       	add	r0,r0
80004a7a:	0b 34       	ld.ub	r4,r5++
80004a7c:	00 00       	add	r0,r0
80004a7e:	0b 36       	ld.ub	r6,r5++
80004a80:	00 00       	add	r0,r0
80004a82:	0a 98       	mov	r8,r5
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	35 68       	mov	r8,86
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	74 ca       	ld.w	r10,r10[0x30]
80004a8c:	00 00       	add	r0,r0
80004a8e:	0b 40       	ld.w	r0,--r5
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	60 78       	ld.w	r8,r0[0x1c]

80004a94 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004a94:	eb cd 40 80 	pushm	r7,lr
80004a98:	fa cd 01 00 	sub	sp,sp,256
	
	xnl_information.is_connected = FALSE;
80004a9c:	30 09       	mov	r9,0
80004a9e:	4a 78       	lddpc	r8,80004b38 <xnl_init+0xa4>
80004aa0:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004aa2:	30 0b       	mov	r11,0
80004aa4:	30 1c       	mov	r12,1
80004aa6:	f0 1f 00 26 	mcall	80004b3c <xnl_init+0xa8>
80004aaa:	4a 68       	lddpc	r8,80004b40 <xnl_init+0xac>
80004aac:	91 0c       	st.w	r8[0x0],r12
80004aae:	70 08       	ld.w	r8,r8[0x0]
80004ab0:	58 08       	cp.w	r8,0
80004ab2:	c0 80       	breq	80004ac2 <xnl_init+0x2e>
80004ab4:	4a 38       	lddpc	r8,80004b40 <xnl_init+0xac>
80004ab6:	70 0c       	ld.w	r12,r8[0x0]
80004ab8:	30 09       	mov	r9,0
80004aba:	12 9a       	mov	r10,r9
80004abc:	12 9b       	mov	r11,r9
80004abe:	f0 1f 00 22 	mcall	80004b44 <xnl_init+0xb0>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004ac2:	30 4b       	mov	r11,4
80004ac4:	31 4c       	mov	r12,20
80004ac6:	f0 1f 00 1e 	mcall	80004b3c <xnl_init+0xa8>
80004aca:	4a 08       	lddpc	r8,80004b48 <xnl_init+0xb4>
80004acc:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004ace:	30 07       	mov	r7,0
80004ad0:	1a d7       	st.w	--sp,r7
80004ad2:	1a d7       	st.w	--sp,r7
80004ad4:	1a d7       	st.w	--sp,r7
80004ad6:	30 38       	mov	r8,3
80004ad8:	0e 99       	mov	r9,r7
80004ada:	e0 6a 02 00 	mov	r10,512
80004ade:	49 cb       	lddpc	r11,80004b4c <xnl_init+0xb8>
80004ae0:	49 cc       	lddpc	r12,80004b50 <xnl_init+0xbc>
80004ae2:	f0 1f 00 1d 	mcall	80004b54 <xnl_init+0xc0>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004ae6:	1a d7       	st.w	--sp,r7
80004ae8:	1a d7       	st.w	--sp,r7
80004aea:	1a d7       	st.w	--sp,r7
80004aec:	30 38       	mov	r8,3
80004aee:	0e 99       	mov	r9,r7
80004af0:	e0 6a 03 20 	mov	r10,800
80004af4:	49 9b       	lddpc	r11,80004b58 <xnl_init+0xc4>
80004af6:	49 ac       	lddpc	r12,80004b5c <xnl_init+0xc8>
80004af8:	f0 1f 00 17 	mcall	80004b54 <xnl_init+0xc0>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004afc:	e0 68 40 0e 	mov	r8,16398
80004b00:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b04:	3f f8       	mov	r8,-1
80004b06:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004b0a:	30 38       	mov	r8,3
80004b0c:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004b10:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004b14:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004b18:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004b1c:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004b20:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b24:	fa cc ff e8 	sub	r12,sp,-24
80004b28:	f0 1f 00 0e 	mcall	80004b60 <xnl_init+0xcc>
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
	
	/*initialize the physical layer*/
	phy_init();
80004b2c:	f0 1f 00 0e 	mcall	80004b64 <xnl_init+0xd0>
80004b30:	2f ad       	sub	sp,-24
}
80004b32:	2c 0d       	sub	sp,-256
80004b34:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b38:	00 00       	add	r0,r0
80004b3a:	0b 36       	ld.ub	r6,r5++
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	61 78       	ld.w	r8,r0[0x5c]
80004b40:	00 00       	add	r0,r0
80004b42:	0b 30       	ld.ub	r0,r5++
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	60 78       	ld.w	r8,r0[0x1c]
80004b48:	00 00       	add	r0,r0
80004b4a:	0b 40       	ld.w	r0,--r5
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	d9 d0       	acall	0x9d
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	49 50       	lddpc	r0,80004ba4 <xnl_data_msg_func+0x3c>
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	68 4c       	ld.w	r12,r4[0x10]
80004b58:	80 00       	ld.sh	r0,r0[0x0]
80004b5a:	cc 00       	breq	80004ada <xnl_init+0x46>
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	48 88       	lddpc	r8,80004b7c <xnl_data_msg_func+0x14>
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	49 b0       	lddpc	r0,80004bcc <xnl_device_auth_reply_func+0x4>
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	35 90       	mov	r0,89

80004b68 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004b68:	eb cd 40 80 	pushm	r7,lr
80004b6c:	fa cd 01 00 	sub	sp,sp,256
80004b70:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b72:	e0 68 40 0e 	mov	r8,16398
80004b76:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b78:	3f f8       	mov	r8,-1
80004b7a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004b7c:	30 c8       	mov	r8,12
80004b7e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004b80:	98 38       	ld.sh	r8,r12[0x6]
80004b82:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004b84:	98 58       	ld.sh	r8,r12[0xa]
80004b86:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004b88:	98 48       	ld.sh	r8,r12[0x8]
80004b8a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004b8c:	98 68       	ld.sh	r8,r12[0xc]
80004b8e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004b90:	30 08       	mov	r8,0
80004b92:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b94:	1a 9c       	mov	r12,sp
80004b96:	f0 1f 00 0a 	mcall	80004bbc <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004b9a:	fa cd 00 cc 	sub	sp,sp,204
80004b9e:	e0 6a 00 ca 	mov	r10,202
80004ba2:	ee cb ff f0 	sub	r11,r7,-16
80004ba6:	1a 9c       	mov	r12,sp
80004ba8:	f0 1f 00 06 	mcall	80004bc0 <xnl_data_msg_func+0x58>
80004bac:	48 68       	lddpc	r8,80004bc4 <xnl_data_msg_func+0x5c>
80004bae:	70 08       	ld.w	r8,r8[0x0]
80004bb0:	5d 18       	icall	r8
80004bb2:	fa cd ff 34 	sub	sp,sp,-204
}
80004bb6:	2c 0d       	sub	sp,-256
80004bb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	49 b0       	lddpc	r0,80004c28 <xnl_device_auth_reply_func+0x60>
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	74 ca       	ld.w	r10,r10[0x30]
80004bc4:	00 00       	add	r0,r0
80004bc6:	0b 50       	ld.sh	r0,--r5

80004bc8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004bc8:	d4 21       	pushm	r4-r7,lr
80004bca:	fa cd 01 00 	sub	sp,sp,256
80004bce:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004bd0:	4c 28       	lddpc	r8,80004cd8 <xnl_device_auth_reply_func+0x110>
80004bd2:	11 88       	ld.ub	r8,r8[0x0]
80004bd4:	58 08       	cp.w	r8,0
80004bd6:	c7 e1       	brne	80004cd2 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004bd8:	4c 18       	lddpc	r8,80004cdc <xnl_device_auth_reply_func+0x114>
80004bda:	70 0c       	ld.w	r12,r8[0x0]
80004bdc:	30 09       	mov	r9,0
80004bde:	12 9a       	mov	r10,r9
80004be0:	12 9b       	mov	r11,r9
80004be2:	f0 1f 00 40 	mcall	80004ce0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004be6:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004bea:	4b c8       	lddpc	r8,80004cd8 <xnl_device_auth_reply_func+0x110>
80004bec:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004bee:	ef 39 00 12 	ld.ub	r9,r7[18]
80004bf2:	ef 38 00 13 	ld.ub	r8,r7[19]
80004bf6:	b1 68       	lsl	r8,0x10
80004bf8:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004bfc:	ef 38 00 15 	ld.ub	r8,r7[21]
80004c00:	f3 e8 10 08 	or	r8,r9,r8
80004c04:	ef 39 00 14 	ld.ub	r9,r7[20]
80004c08:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004c0c:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004c10:	ef 38 00 17 	ld.ub	r8,r7[23]
80004c14:	b1 68       	lsl	r8,0x10
80004c16:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004c1a:	ef 38 00 19 	ld.ub	r8,r7[25]
80004c1e:	f5 e8 10 08 	or	r8,r10,r8
80004c22:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004c26:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004c2a:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c2c:	e0 64 79 b9 	mov	r4,31161
80004c30:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c34:	e0 65 45 07 	mov	r5,17671
80004c38:	ea 15 8a bd 	orh	r5,0x8abd
80004c3c:	e0 66 f9 3d 	mov	r6,63805
80004c40:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c44:	e0 6e b8 cf 	mov	lr,47311
80004c48:	ea 1e 36 83 	orh	lr,0x3683
80004c4c:	e0 67 aa 1c 	mov	r7,43548
80004c50:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c54:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c56:	f4 08 00 0c 	add	r12,r10,r8
80004c5a:	f0 0b 15 04 	lsl	r11,r8,0x4
80004c5e:	0a 0b       	add	r11,r5
80004c60:	f9 eb 20 0b 	eor	r11,r12,r11
80004c64:	f0 0c 16 05 	lsr	r12,r8,0x5
80004c68:	0c 0c       	add	r12,r6
80004c6a:	18 5b       	eor	r11,r12
80004c6c:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c6e:	f2 0c 15 04 	lsl	r12,r9,0x4
80004c72:	1c 0c       	add	r12,lr
80004c74:	f2 0b 16 05 	lsr	r11,r9,0x5
80004c78:	0e 0b       	add	r11,r7
80004c7a:	f9 eb 20 0b 	eor	r11,r12,r11
80004c7e:	f2 0a 00 0c 	add	r12,r9,r10
80004c82:	18 5b       	eor	r11,r12
80004c84:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004c86:	e0 6b 37 20 	mov	r11,14112
80004c8a:	ea 1b c6 ef 	orh	r11,0xc6ef
80004c8e:	16 3a       	cp.w	r10,r11
80004c90:	ce 21       	brne	80004c54 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004c92:	e0 6a 40 1a 	mov	r10,16410
80004c96:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004c98:	3f fa       	mov	r10,-1
80004c9a:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004c9c:	30 6b       	mov	r11,6
80004c9e:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004ca0:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004ca2:	48 eb       	lddpc	r11,80004cd8 <xnl_device_auth_reply_func+0x110>
80004ca4:	96 1c       	ld.sh	r12,r11[0x2]
80004ca6:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004ca8:	96 2b       	ld.sh	r11,r11[0x4]
80004caa:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004cac:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004cae:	30 ca       	mov	r10,12
80004cb0:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004cb2:	30 0a       	mov	r10,0
80004cb4:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004cb8:	30 7a       	mov	r10,7
80004cba:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004cbe:	30 2a       	mov	r10,2
80004cc0:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cc4:	fa ca ff ec 	sub	r10,sp,-20
80004cc8:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cca:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004ccc:	1a 9c       	mov	r12,sp
80004cce:	f0 1f 00 06 	mcall	80004ce4 <xnl_device_auth_reply_func+0x11c>
}
80004cd2:	2c 0d       	sub	sp,-256
80004cd4:	d8 22       	popm	r4-r7,pc
80004cd6:	00 00       	add	r0,r0
80004cd8:	00 00       	add	r0,r0
80004cda:	0b 36       	ld.ub	r6,r5++
80004cdc:	00 00       	add	r0,r0
80004cde:	0b 30       	ld.ub	r0,r5++
80004ce0:	80 00       	ld.sh	r0,r0[0x0]
80004ce2:	60 78       	ld.w	r8,r0[0x1c]
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	49 b0       	lddpc	r0,80004d50 <xnl_device_conn_reply_func+0x8>

80004ce8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004ce8:	eb cd 40 80 	pushm	r7,lr
80004cec:	fa cd 01 00 	sub	sp,sp,256
80004cf0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004cf2:	49 28       	lddpc	r8,80004d38 <xnl_master_status_brdcst_func+0x50>
80004cf4:	11 88       	ld.ub	r8,r8[0x0]
80004cf6:	58 08       	cp.w	r8,0
80004cf8:	c1 c1       	brne	80004d30 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004cfa:	49 18       	lddpc	r8,80004d3c <xnl_master_status_brdcst_func+0x54>
80004cfc:	70 0c       	ld.w	r12,r8[0x0]
80004cfe:	30 09       	mov	r9,0
80004d00:	12 9a       	mov	r10,r9
80004d02:	12 9b       	mov	r11,r9
80004d04:	f0 1f 00 0f 	mcall	80004d40 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004d08:	8e 58       	ld.sh	r8,r7[0xa]
80004d0a:	48 c9       	lddpc	r9,80004d38 <xnl_master_status_brdcst_func+0x50>
80004d0c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004d0e:	e0 68 40 0e 	mov	r8,16398
80004d12:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004d14:	3f f8       	mov	r8,-1
80004d16:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004d18:	30 4a       	mov	r10,4
80004d1a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004d1c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004d1e:	92 19       	ld.sh	r9,r9[0x2]
80004d20:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004d22:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004d24:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004d26:	30 08       	mov	r8,0
80004d28:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004d2a:	1a 9c       	mov	r12,sp
80004d2c:	f0 1f 00 06 	mcall	80004d44 <xnl_master_status_brdcst_func+0x5c>
}
80004d30:	2c 0d       	sub	sp,-256
80004d32:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d36:	00 00       	add	r0,r0
80004d38:	00 00       	add	r0,r0
80004d3a:	0b 36       	ld.ub	r6,r5++
80004d3c:	00 00       	add	r0,r0
80004d3e:	0b 30       	ld.ub	r0,r5++
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	60 78       	ld.w	r8,r0[0x1c]
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	49 b0       	lddpc	r0,80004db0 <local_start_pll0+0xc>

80004d48 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004d48:	eb cd 40 80 	pushm	r7,lr
80004d4c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004d4e:	49 28       	lddpc	r8,80004d94 <xnl_device_conn_reply_func+0x4c>
80004d50:	70 0c       	ld.w	r12,r8[0x0]
80004d52:	30 09       	mov	r9,0
80004d54:	12 9a       	mov	r10,r9
80004d56:	12 9b       	mov	r11,r9
80004d58:	f0 1f 00 10 	mcall	80004d98 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004d5c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004d60:	10 99       	mov	r9,r8
80004d62:	e2 19 ff 00 	andl	r9,0xff00,COH
80004d66:	e0 49 01 00 	cp.w	r9,256
80004d6a:	c0 60       	breq	80004d76 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004d6c:	0e 9c       	mov	r12,r7
80004d6e:	f0 1f 00 0c 	mcall	80004d9c <xnl_device_conn_reply_func+0x54>
80004d72:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004d76:	a9 68       	lsl	r8,0x8
80004d78:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004d7c:	48 98       	lddpc	r8,80004da0 <xnl_device_conn_reply_func+0x58>
80004d7e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004d80:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004d84:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004d86:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004d8a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004d8c:	30 19       	mov	r9,1
80004d8e:	b0 89       	st.b	r8[0x0],r9
80004d90:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d94:	00 00       	add	r0,r0
80004d96:	0b 30       	ld.ub	r0,r5++
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	60 78       	ld.w	r8,r0[0x1c]
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	4c e8       	lddpc	r8,80004ed4 <playback_voice_data+0xa4>
80004da0:	00 00       	add	r0,r0
80004da2:	0b 36       	ld.ub	r6,r5++

80004da4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004da4:	fe 78 0c 00 	mov	r8,-62464
80004da8:	e0 69 03 07 	mov	r9,775
80004dac:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004dae:	30 49       	mov	r9,4
80004db0:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004db2:	71 59       	ld.w	r9,r8[0x54]
80004db4:	e2 19 00 80 	andl	r9,0x80,COH
80004db8:	cf d0       	breq	80004db2 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004dba:	fe 78 0c 00 	mov	r8,-62464
80004dbe:	30 59       	mov	r9,5
80004dc0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004dc2:	e0 69 01 0d 	mov	r9,269
80004dc6:	ea 19 10 07 	orh	r9,0x1007
80004dca:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004dcc:	71 59       	ld.w	r9,r8[0x54]
80004dce:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004dd2:	cf d0       	breq	80004dcc <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004dd4:	fe 78 0c 00 	mov	r8,-62464
80004dd8:	fc 19 00 80 	movh	r9,0x80
80004ddc:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004dde:	34 0a       	mov	r10,64
80004de0:	fe 69 14 00 	mov	r9,-125952
80004de4:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004de6:	30 69       	mov	r9,6
80004de8:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004dea:	30 19       	mov	r9,1
80004dec:	fe 68 10 00 	mov	r8,-126976
80004df0:	91 19       	st.w	r8[0x4],r9
}
80004df2:	5e fc       	retal	r12

80004df4 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004df4:	fe 78 10 00 	mov	r8,-61440
80004df8:	fc 19 00 10 	movh	r9,0x10
80004dfc:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004dfe:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004e00:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004e02:	30 39       	mov	r9,3
80004e04:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004e08:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004e0c:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004e10:	fe 78 38 00 	mov	r8,-51200
80004e14:	30 49       	mov	r9,4
80004e16:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004e1a:	e0 69 91 0d 	mov	r9,37133
80004e1e:	ea 19 00 52 	orh	r9,0x52
80004e22:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004e24:	32 09       	mov	r9,32
80004e26:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004e28:	30 59       	mov	r9,5
80004e2a:	91 09       	st.w	r8[0x0],r9
}
80004e2c:	5e fc       	retal	r12
80004e2e:	d7 03       	nop

80004e30 <playback_voice_data>:
* 20-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
U8 PLAYBACK_BUF[512];
Bool playback_voice_data(U32 voice_index)
{
80004e30:	d4 31       	pushm	r0-r7,lr
80004e32:	21 2d       	sub	sp,72
80004e34:	18 97       	mov	r7,r12
	if(!list_init_success_flag)return FALSE;
80004e36:	4b 98       	lddpc	r8,80004f18 <playback_voice_data+0xe8>
80004e38:	11 89       	ld.ub	r9,r8[0x0]
80004e3a:	30 08       	mov	r8,0
80004e3c:	f0 09 18 00 	cp.b	r9,r8
80004e40:	c6 40       	breq	80004f08 <playback_voice_data+0xd8>
	
	/* check input parameter */
	if (voice_index > current_voice_index)
80004e42:	4b 78       	lddpc	r8,80004f1c <playback_voice_data+0xec>
80004e44:	90 88       	ld.uh	r8,r8[0x0]
80004e46:	18 38       	cp.w	r8,r12
80004e48:	c6 23       	brcs	80004f0c <playback_voice_data+0xdc>
		return -1;
	}
	df_status_t return_code = DF_OK;
	unsigned int address =0x00000000;
	char str[VOICE_INFO_LENGTH];
	memset(str, 0x00, sizeof(str));
80004e4a:	1a 9a       	mov	r10,sp
80004e4c:	30 08       	mov	r8,0
80004e4e:	30 09       	mov	r9,0
80004e50:	fa e9 00 00 	st.d	sp[0],r8
80004e54:	fa e9 00 08 	st.d	sp[8],r8
80004e58:	fa e9 00 10 	st.d	sp[16],r8
80004e5c:	fa e9 00 18 	st.d	sp[24],r8
80004e60:	fa e9 00 20 	st.d	sp[32],r8
80004e64:	fa e9 00 28 	st.d	sp[40],r8
80004e68:	fa e9 00 30 	st.d	sp[48],r8
80004e6c:	fa e9 00 38 	st.d	sp[56],r8
80004e70:	fa e9 00 40 	st.d	sp[64],r8
	//find the voice storage info by voice_index
	address = START_ADDRESS_OF_VOICE_INFO + ((voice_index -1)*VOICE_INFO_LENGTH);
	return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80004e74:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80004e78:	a3 7c       	lsl	r12,0x3
80004e7a:	34 8b       	mov	r11,72
80004e7c:	23 8c       	sub	r12,56
80004e7e:	f0 1f 00 29 	mcall	80004f20 <playback_voice_data+0xf0>
	if (return_code == DF_OK)
80004e82:	c4 51       	brne	80004f0c <playback_voice_data+0xdc>
	{
		U16 bytes_remained;
		VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
		if(ptr->numb == voice_index)
80004e84:	9a 88       	ld.uh	r8,sp[0x0]
80004e86:	0e 38       	cp.w	r8,r7
80004e88:	c4 21       	brne	80004f0c <playback_voice_data+0xdc>
		{
			bytes_remained = ptr->offset;
80004e8a:	41 18       	lddsp	r8,sp[0x44]
80004e8c:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			address = ptr->address;
80004e90:	fb 16 00 42 	ld.uh	r6,sp[66]
80004e94:	b1 88       	lsr	r8,0x10
80004e96:	f1 e6 11 06 	or	r6,r8,r6<<0x10
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004e9a:	58 07       	cp.w	r7,0
80004e9c:	c3 b0       	breq	80004f12 <playback_voice_data+0xe2>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80004e9e:	e0 65 01 ff 	mov	r5,511
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
80004ea2:	4a 13       	lddpc	r3,80004f24 <playback_voice_data+0xf4>
80004ea4:	e0 62 02 00 	mov	r2,512
		if(ptr->numb == voice_index)
		{
			bytes_remained = ptr->offset;
			address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004ea8:	30 04       	mov	r4,0
80004eaa:	08 91       	mov	r1,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80004eac:	ea 07 19 00 	cp.h	r7,r5
80004eb0:	e0 8b 00 11 	brhi	80004ed2 <playback_voice_data+0xa2>
				{
					return_code = data_flash_read_block(address, bytes_remained, PLAYBACK_BUF);
80004eb4:	49 c5       	lddpc	r5,80004f24 <playback_voice_data+0xf4>
80004eb6:	0a 9a       	mov	r10,r5
80004eb8:	0e 9b       	mov	r11,r7
80004eba:	5c 7b       	castu.h	r11
80004ebc:	0c 9c       	mov	r12,r6
80004ebe:	f0 1f 00 19 	mcall	80004f20 <playback_voice_data+0xf0>
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
					bytes_remained-=DF_DATA_SPACE_SIZE;
					address+=DF_DATA_SPACE_SIZE;
					
				}
				memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
80004ec2:	e0 6a 02 00 	mov	r10,512
80004ec6:	30 0b       	mov	r11,0
80004ec8:	0a 9c       	mov	r12,r5
80004eca:	f0 1f 00 18 	mcall	80004f28 <playback_voice_data+0xf8>
80004ece:	30 1c       	mov	r12,1
80004ed0:	c2 28       	rjmp	80004f14 <playback_voice_data+0xe4>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
80004ed2:	06 9a       	mov	r10,r3
80004ed4:	04 9b       	mov	r11,r2
80004ed6:	0c 9c       	mov	r12,r6
80004ed8:	f0 1f 00 12 	mcall	80004f20 <playback_voice_data+0xf0>
80004edc:	18 90       	mov	r0,r12
					bytes_remained-=DF_DATA_SPACE_SIZE;
80004ede:	ee c7 02 00 	sub	r7,r7,512
80004ee2:	5c 87       	casts.h	r7
					address+=DF_DATA_SPACE_SIZE;
					
				}
				memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
80004ee4:	04 9a       	mov	r10,r2
80004ee6:	30 0b       	mov	r11,0
80004ee8:	06 9c       	mov	r12,r3
80004eea:	f0 1f 00 10 	mcall	80004f28 <playback_voice_data+0xf8>
		if(ptr->numb == voice_index)
		{
			bytes_remained = ptr->offset;
			address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80004eee:	e8 07 19 00 	cp.h	r7,r4
80004ef2:	5f 19       	srne	r9
80004ef4:	58 00       	cp.w	r0,0
80004ef6:	5f 08       	sreq	r8
80004ef8:	f3 e8 00 08 	and	r8,r9,r8
80004efc:	e2 08 18 00 	cp.b	r8,r1
80004f00:	c0 90       	breq	80004f12 <playback_voice_data+0xe2>
				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(address, DF_DATA_SPACE_SIZE, PLAYBACK_BUF);
					bytes_remained-=DF_DATA_SPACE_SIZE;
					address+=DF_DATA_SPACE_SIZE;
80004f02:	ec c6 fe 00 	sub	r6,r6,-512
80004f06:	cd 3b       	rjmp	80004eac <playback_voice_data+0x7c>
80004f08:	30 0c       	mov	r12,0
80004f0a:	c0 58       	rjmp	80004f14 <playback_voice_data+0xe4>
80004f0c:	e0 6c 00 ff 	mov	r12,255
80004f10:	c0 28       	rjmp	80004f14 <playback_voice_data+0xe4>
80004f12:	30 1c       	mov	r12,1
		}
	}
	
	return -1;
	
}
80004f14:	2e ed       	sub	sp,-72
80004f16:	d8 32       	popm	r0-r7,pc
80004f18:	00 00       	add	r0,r0
80004f1a:	0b 56       	ld.sh	r6,--r5
80004f1c:	00 00       	add	r0,r0
80004f1e:	0b 54       	ld.sh	r4,--r5
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	2a a0       	sub	r0,-86
80004f24:	00 00       	add	r0,r0
80004f26:	60 fc       	ld.w	r12,r0[0x3c]
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	76 12       	ld.w	r2,r11[0x4]

80004f2c <voc_save_info>:
	return TRUE;

}

Bool voc_save_info(VoiceList_Info_t * voice)
{
80004f2c:	d4 01       	pushm	lr
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	//if(voice_end_flag == TRUE)//save a voice-info into list at the end of the recording
	{
		//current_voice_index++;
		voice->numb		= current_voice_index;
80004f2e:	49 d9       	lddpc	r9,80004fa0 <voc_save_info+0x74>
80004f30:	13 88       	ld.ub	r8,r9[0x0]
80004f32:	b8 88       	st.b	r12[0x0],r8
80004f34:	13 98       	ld.ub	r8,r9[0x1]
80004f36:	b8 98       	st.b	r12[0x1],r8
		voice->address	= (current_save_voice_offset - current_bytes_remained);
80004f38:	49 b8       	lddpc	r8,80004fa4 <voc_save_info+0x78>
80004f3a:	70 0a       	ld.w	r10,r8[0x0]
80004f3c:	49 b8       	lddpc	r8,80004fa8 <voc_save_info+0x7c>
80004f3e:	70 08       	ld.w	r8,r8[0x0]
80004f40:	14 18       	sub	r8,r10
80004f42:	f0 0b 16 18 	lsr	r11,r8,0x18
80004f46:	f9 6b 00 42 	st.b	r12[66],r11
80004f4a:	f0 0b 16 10 	lsr	r11,r8,0x10
80004f4e:	f9 6b 00 43 	st.b	r12[67],r11
80004f52:	f0 0b 16 08 	lsr	r11,r8,0x8
80004f56:	f9 6b 00 44 	st.b	r12[68],r11
80004f5a:	f9 68 00 45 	st.b	r12[69],r8
		voice->offset		= current_bytes_remained;
80004f5e:	f1 da c0 10 	bfextu	r8,r10,0x0,0x10
80004f62:	f0 0a 16 08 	lsr	r10,r8,0x8
80004f66:	f9 6a 00 46 	st.b	r12[70],r10
80004f6a:	f9 68 00 47 	st.b	r12[71],r8
		
		address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80004f6e:	92 8b       	ld.uh	r11,r9[0x0]
80004f70:	20 1b       	sub	r11,1
80004f72:	f6 0b 00 3b 	add	r11,r11,r11<<0x3
80004f76:	a3 7b       	lsl	r11,0x3
80004f78:	2f 0b       	sub	r11,-16
		if(address > VOICE_LIST_BOUNDARY)//The number of messages is out of bounds
80004f7a:	e8 4b 00 00 	cp.w	r11,524288
80004f7e:	e0 8b 00 10 	brhi	80004f9e <voc_save_info+0x72>
		{
			return FALSE;
			log("\r\n----info list is Out of bounds!!!\r\n----");
		}
		//set a voice info by current_voice_index
		return_code = data_flash_write((U8 *)voice, address, VOICE_INFO_LENGTH);
80004f82:	34 8a       	mov	r10,72
80004f84:	f0 1f 00 0a 	mcall	80004fac <voc_save_info+0x80>
		//set voice numbers
		return_code = data_flash_write(&current_voice_index, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80004f88:	30 2a       	mov	r10,2
80004f8a:	30 ab       	mov	r11,10
80004f8c:	48 5c       	lddpc	r12,80004fa0 <voc_save_info+0x74>
80004f8e:	f0 1f 00 08 	mcall	80004fac <voc_save_info+0x80>
		if(return_code != DF_WRITE_COMPLETED)
80004f92:	58 7c       	cp.w	r12,7
80004f94:	c0 51       	brne	80004f9e <voc_save_info+0x72>
		{
			return FALSE;
		}
		
		current_bytes_remained = 0;//reset 0
80004f96:	30 09       	mov	r9,0
80004f98:	48 38       	lddpc	r8,80004fa4 <voc_save_info+0x78>
80004f9a:	91 09       	st.w	r8[0x0],r9
80004f9c:	da 0a       	popm	pc,r12=1
	}
	
	return TRUE;
80004f9e:	d8 0a       	popm	pc,r12=0
80004fa0:	00 00       	add	r0,r0
80004fa2:	0b 54       	ld.sh	r4,--r5
80004fa4:	00 00       	add	r0,r0
80004fa6:	0b 58       	ld.sh	r8,--r5
80004fa8:	00 00       	add	r0,r0
80004faa:	05 2c       	ld.uh	r12,r2++
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	2c d0       	sub	r0,-51

80004fb0 <voc_save_data>:
*
*******************************************************************************/
static U32 current_bytes_remained = 0;

Bool voc_save_data(void *data_ptr, U16 data_len, U8 voice_end_flag)
{
80004fb0:	eb cd 40 c0 	pushm	r6-r7,lr
80004fb4:	14 96       	mov	r6,r10
	if(!list_init_success_flag)return FALSE;
80004fb6:	49 f8       	lddpc	r8,80005030 <voc_save_data+0x80>
80004fb8:	11 89       	ld.ub	r9,r8[0x0]
80004fba:	30 08       	mov	r8,0
80004fbc:	f0 09 18 00 	cp.b	r9,r8
80004fc0:	c3 50       	breq	8000502a <voc_save_data+0x7a>
	
	U32 address = 0;
	//static U32 bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	current_bytes_remained+=data_len;//accumulate
80004fc2:	ef db c0 10 	bfextu	r7,r11,0x0,0x10
80004fc6:	49 c8       	lddpc	r8,80005034 <voc_save_data+0x84>
80004fc8:	70 09       	ld.w	r9,r8[0x0]
80004fca:	ee 09 00 09 	add	r9,r7,r9
80004fce:	91 09       	st.w	r8[0x0],r9
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x1000)
80004fd0:	58 0c       	cp.w	r12,0
80004fd2:	5f 0a       	sreq	r10
80004fd4:	e0 68 10 00 	mov	r8,4096
80004fd8:	f0 0b 19 00 	cp.h	r11,r8
80004fdc:	5f b8       	srhi	r8
80004fde:	f5 e8 10 08 	or	r8,r10,r8
80004fe2:	c2 41       	brne	8000502a <voc_save_data+0x7a>
	{
		return FALSE;
	}
	if(current_bytes_remained > 0xFFFF)//data size > 65535bytes == 64k,overout
80004fe4:	e0 49 ff ff 	cp.w	r9,65535
80004fe8:	e0 8b 00 21 	brhi	8000502a <voc_save_data+0x7a>
	{
		//current_bytes_remained = 0;
		return FALSE;
	}
	//save data
	if(current_save_voice_offset > DF_MAX_ADDR)//The voice data is out of bounds
80004fec:	49 38       	lddpc	r8,80005038 <voc_save_data+0x88>
80004fee:	70 08       	ld.w	r8,r8[0x0]
80004ff0:	e0 69 ff ff 	mov	r9,65535
80004ff4:	ea 19 00 7f 	orh	r9,0x7f
80004ff8:	12 38       	cp.w	r8,r9
80004ffa:	e0 8b 00 18 	brhi	8000502a <voc_save_data+0x7a>
	{
		return FALSE;
		log("\r\n----voice data is Out of bounds!!!\r\n----");
	}
	return_code = data_flash_write((U8 *)data_ptr, current_save_voice_offset, data_len);
80004ffe:	0e 9a       	mov	r10,r7
80005000:	10 9b       	mov	r11,r8
80005002:	f0 1f 00 0f 	mcall	8000503c <voc_save_data+0x8c>
	if(return_code != DF_WRITE_COMPLETED)
80005006:	58 7c       	cp.w	r12,7
80005008:	c1 11       	brne	8000502a <voc_save_data+0x7a>
	{
		return FALSE;
	}
	current_save_voice_offset+=data_len;
8000500a:	48 c8       	lddpc	r8,80005038 <voc_save_data+0x88>
8000500c:	70 09       	ld.w	r9,r8[0x0]
8000500e:	12 07       	add	r7,r9
80005010:	91 07       	st.w	r8[0x0],r7
	
	
	//VoiceList_Info_t *ptr = malloc(sizeof(VoiceList_Info_t));
	//if(ptr ==NULL)return FALSE;
	
	if(voice_end_flag == TRUE)//save a voice-info into list at the end of the recording
80005012:	30 18       	mov	r8,1
80005014:	f0 06 18 00 	cp.b	r6,r8
80005018:	c0 30       	breq	8000501e <voc_save_data+0x6e>
8000501a:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
	{
		current_voice_index++;
8000501e:	48 98       	lddpc	r8,80005040 <voc_save_data+0x90>
80005020:	90 09       	ld.sh	r9,r8[0x0]
80005022:	2f f9       	sub	r9,-1
80005024:	b0 09       	st.h	r8[0x0],r9
80005026:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000502a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000502e:	00 00       	add	r0,r0
80005030:	00 00       	add	r0,r0
80005032:	0b 56       	ld.sh	r6,--r5
80005034:	00 00       	add	r0,r0
80005036:	0b 58       	ld.sh	r8,--r5
80005038:	00 00       	add	r0,r0
8000503a:	05 2c       	ld.uh	r12,r2++
8000503c:	80 00       	ld.sh	r0,r0[0x0]
8000503e:	2c d0       	sub	r0,-51
80005040:	00 00       	add	r0,r0
80005042:	0b 54       	ld.sh	r4,--r5

80005044 <voc_read_info>:

}


Bool voc_read_info( unsigned int voice_index,  VoiceList_Info_t * voice)
{
80005044:	eb cd 40 c0 	pushm	r6-r7,lr
80005048:	21 2d       	sub	sp,72
8000504a:	18 97       	mov	r7,r12
8000504c:	16 96       	mov	r6,r11
	if(!list_init_success_flag)return FALSE;
8000504e:	49 d8       	lddpc	r8,800050c0 <voc_read_info+0x7c>
80005050:	11 89       	ld.ub	r9,r8[0x0]
80005052:	30 08       	mov	r8,0
80005054:	f0 09 18 00 	cp.b	r9,r8
80005058:	c2 f0       	breq	800050b6 <voc_read_info+0x72>
		
	/* check input parameter */
	if (voice_index > current_voice_index)
8000505a:	49 b8       	lddpc	r8,800050c4 <voc_read_info+0x80>
8000505c:	90 88       	ld.uh	r8,r8[0x0]
8000505e:	18 38       	cp.w	r8,r12
80005060:	c0 42       	brcc	80005068 <voc_read_info+0x24>
80005062:	e0 6c 00 ff 	mov	r12,255
80005066:	c2 98       	rjmp	800050b8 <voc_read_info+0x74>
		return -1;
	}
	
	df_status_t return_code = DF_OK;
	char str[VOICE_INFO_LENGTH];
	memset(str, 0x00, sizeof(str));
80005068:	1a 9a       	mov	r10,sp
8000506a:	30 08       	mov	r8,0
8000506c:	30 09       	mov	r9,0
8000506e:	fa e9 00 00 	st.d	sp[0],r8
80005072:	fa e9 00 08 	st.d	sp[8],r8
80005076:	fa e9 00 10 	st.d	sp[16],r8
8000507a:	fa e9 00 18 	st.d	sp[24],r8
8000507e:	fa e9 00 20 	st.d	sp[32],r8
80005082:	fa e9 00 28 	st.d	sp[40],r8
80005086:	fa e9 00 30 	st.d	sp[48],r8
8000508a:	fa e9 00 38 	st.d	sp[56],r8
8000508e:	fa e9 00 40 	st.d	sp[64],r8
	unsigned int address =0x00000000;
	//find the voice storage info by voice_index
	address = START_ADDRESS_OF_VOICE_INFO + ((voice_index -1)*VOICE_INFO_LENGTH);
	return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80005092:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80005096:	a3 7c       	lsl	r12,0x3
80005098:	34 8b       	mov	r11,72
8000509a:	23 8c       	sub	r12,56
8000509c:	f0 1f 00 0b 	mcall	800050c8 <voc_read_info+0x84>
	if (return_code == DF_OK)
800050a0:	c0 b1       	brne	800050b6 <voc_read_info+0x72>
	{
		if(((VoiceList_Info_t *)str)->numb == voice_index)
800050a2:	9a 88       	ld.uh	r8,sp[0x0]
800050a4:	0e 38       	cp.w	r8,r7
800050a6:	c0 81       	brne	800050b6 <voc_read_info+0x72>
		{
			memcpy(voice, str, sizeof(VoiceList_Info_t));
800050a8:	34 8a       	mov	r10,72
800050aa:	1a 9b       	mov	r11,sp
800050ac:	0c 9c       	mov	r12,r6
800050ae:	f0 1f 00 08 	mcall	800050cc <voc_read_info+0x88>
800050b2:	30 1c       	mov	r12,1
			return TRUE;
800050b4:	c0 28       	rjmp	800050b8 <voc_read_info+0x74>
800050b6:	30 0c       	mov	r12,0
			return FALSE;
	}
	else
		return FALSE;
	
}
800050b8:	2e ed       	sub	sp,-72
800050ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050be:	00 00       	add	r0,r0
800050c0:	00 00       	add	r0,r0
800050c2:	0b 56       	ld.sh	r6,--r5
800050c4:	00 00       	add	r0,r0
800050c6:	0b 54       	ld.sh	r4,--r5
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	2a a0       	sub	r0,-86
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	74 ca       	ld.w	r10,r10[0x30]

800050d0 <voc_read_write_test>:

VoiceList_Info_t voice_ptr;
VoiceList_Info_t voice_temp;

void voc_read_write_test(void)
{
800050d0:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 status = 0xff;
	
	/**save**/
	voc_save_data(AMBE_AudioData, 600, TRUE);
800050d4:	4b 26       	lddpc	r6,8000519c <voc_read_write_test+0xcc>
800050d6:	30 1a       	mov	r10,1
800050d8:	e0 6b 02 58 	mov	r11,600
800050dc:	0c 9c       	mov	r12,r6
800050de:	f0 1f 00 31 	mcall	800051a0 <voc_read_write_test+0xd0>
	//save voice information
	voc_save_info(&voice_ptr);
800050e2:	4b 17       	lddpc	r7,800051a4 <voc_read_write_test+0xd4>
800050e4:	0e 9c       	mov	r12,r7
800050e6:	f0 1f 00 31 	mcall	800051a8 <voc_read_write_test+0xd8>
	
	voc_save_data(&AMBE_AudioData[600], 300, FALSE);
800050ea:	30 0a       	mov	r10,0
800050ec:	e0 6b 01 2c 	mov	r11,300
800050f0:	ec cc fd a8 	sub	r12,r6,-600
800050f4:	f0 1f 00 2b 	mcall	800051a0 <voc_read_write_test+0xd0>
	voc_save_data(&AMBE_AudioData[950], 500, TRUE);
800050f8:	30 1a       	mov	r10,1
800050fa:	e0 6b 01 f4 	mov	r11,500
800050fe:	ec cc fc 4a 	sub	r12,r6,-950
80005102:	f0 1f 00 28 	mcall	800051a0 <voc_read_write_test+0xd0>
	memset(&voice_ptr, 0x00, sizeof(voice_ptr));
80005106:	34 8a       	mov	r10,72
80005108:	30 0b       	mov	r11,0
8000510a:	0e 9c       	mov	r12,r7
8000510c:	f0 1f 00 28 	mcall	800051ac <voc_read_write_test+0xdc>
	voice_ptr.Header.Header = 0xABCD5A5A;
80005110:	3a b8       	mov	r8,-85
80005112:	ae a8       	st.b	r7[0x2],r8
80005114:	3c d8       	mov	r8,-51
80005116:	ae b8       	st.b	r7[0x3],r8
80005118:	35 a8       	mov	r8,90
8000511a:	ae c8       	st.b	r7[0x4],r8
8000511c:	ae d8       	st.b	r7[0x5],r8
	//save voice information
	voc_save_info(&voice_ptr);
8000511e:	0e 9c       	mov	r12,r7
80005120:	f0 1f 00 22 	mcall	800051a8 <voc_read_write_test+0xd8>
	
	
	voc_save_data(AMBE_AudioData, 1024, TRUE);
80005124:	30 1a       	mov	r10,1
80005126:	e0 6b 04 00 	mov	r11,1024
8000512a:	0c 9c       	mov	r12,r6
8000512c:	f0 1f 00 1d 	mcall	800051a0 <voc_read_write_test+0xd0>
	//save voice information
	voc_save_info(&voice_ptr);
80005130:	0e 9c       	mov	r12,r7
80005132:	f0 1f 00 1e 	mcall	800051a8 <voc_read_write_test+0xd8>
	
	
	/**read**/
	status = voc_read_info(1, &voice_temp);
80005136:	49 fb       	lddpc	r11,800051b0 <voc_read_write_test+0xe0>
80005138:	30 1c       	mov	r12,1
8000513a:	f0 1f 00 1f 	mcall	800051b4 <voc_read_write_test+0xe4>
	if(status ==TRUE){
8000513e:	30 18       	mov	r8,1
80005140:	f0 0c 18 00 	cp.b	r12,r8
80005144:	c0 91       	brne	80005156 <voc_read_write_test+0x86>
		
		playback_voice_data(1);
80005146:	30 1c       	mov	r12,1
80005148:	f0 1f 00 1c 	mcall	800051b8 <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
8000514c:	34 8a       	mov	r10,72
8000514e:	30 0b       	mov	r11,0
80005150:	49 8c       	lddpc	r12,800051b0 <voc_read_write_test+0xe0>
80005152:	f0 1f 00 17 	mcall	800051ac <voc_read_write_test+0xdc>
		
	}
	
	status = voc_read_info(3, &voice_temp);
80005156:	49 7b       	lddpc	r11,800051b0 <voc_read_write_test+0xe0>
80005158:	30 3c       	mov	r12,3
8000515a:	f0 1f 00 17 	mcall	800051b4 <voc_read_write_test+0xe4>
	if(status ==TRUE){
8000515e:	30 18       	mov	r8,1
80005160:	f0 0c 18 00 	cp.b	r12,r8
80005164:	c0 91       	brne	80005176 <voc_read_write_test+0xa6>
		
		playback_voice_data(3);
80005166:	30 3c       	mov	r12,3
80005168:	f0 1f 00 14 	mcall	800051b8 <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
8000516c:	34 8a       	mov	r10,72
8000516e:	30 0b       	mov	r11,0
80005170:	49 0c       	lddpc	r12,800051b0 <voc_read_write_test+0xe0>
80005172:	f0 1f 00 0f 	mcall	800051ac <voc_read_write_test+0xdc>
		
	}
	
	status = voc_read_info(20, &voice_temp);
80005176:	48 fb       	lddpc	r11,800051b0 <voc_read_write_test+0xe0>
80005178:	31 4c       	mov	r12,20
8000517a:	f0 1f 00 0f 	mcall	800051b4 <voc_read_write_test+0xe4>
	if(status ==TRUE){
8000517e:	30 18       	mov	r8,1
80005180:	f0 0c 18 00 	cp.b	r12,r8
80005184:	c0 91       	brne	80005196 <voc_read_write_test+0xc6>
			
		playback_voice_data(20);
80005186:	31 4c       	mov	r12,20
80005188:	f0 1f 00 0c 	mcall	800051b8 <voc_read_write_test+0xe8>
		memset(&voice_temp, 0x00, sizeof(voice_temp));
8000518c:	34 8a       	mov	r10,72
8000518e:	30 0b       	mov	r11,0
80005190:	48 8c       	lddpc	r12,800051b0 <voc_read_write_test+0xe0>
80005192:	f0 1f 00 07 	mcall	800051ac <voc_read_write_test+0xdc>
80005196:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000519a:	00 00       	add	r0,r0
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	d3 a8       	*unknown*
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	4f b0       	lddpc	r0,8000538c <voc_init+0x1d0>
800051a4:	00 00       	add	r0,r0
800051a6:	62 fc       	ld.w	r12,r1[0x3c]
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	4f 2c       	lddpc	r12,80005370 <voc_init+0x1b4>
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	76 12       	ld.w	r2,r11[0x4]
800051b0:	00 00       	add	r0,r0
800051b2:	63 44       	ld.w	r4,r1[0x50]
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	50 44       	stdsp	sp[0x10],r4
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	4e 30       	lddpc	r0,80005344 <voc_init+0x188>

800051bc <voc_init>:
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
{
800051bc:	d4 31       	pushm	r0-r7,lr
800051be:	21 4d       	sub	sp,80
	data_flash_init();
800051c0:	f0 1f 00 64 	mcall	80005350 <voc_init+0x194>
{
	df_status_t return_code = DF_OK;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	char str[80];
	memset(str, 0x00, sizeof(str));
800051c4:	30 08       	mov	r8,0
800051c6:	30 09       	mov	r9,0
800051c8:	fa e9 00 00 	st.d	sp[0],r8
800051cc:	fa e9 00 08 	st.d	sp[8],r8
800051d0:	fa e9 00 10 	st.d	sp[16],r8
800051d4:	fa e9 00 18 	st.d	sp[24],r8
800051d8:	fa e9 00 20 	st.d	sp[32],r8
800051dc:	fa e9 00 28 	st.d	sp[40],r8
800051e0:	fa e9 00 30 	st.d	sp[48],r8
800051e4:	fa e9 00 38 	st.d	sp[56],r8
800051e8:	fa e9 00 40 	st.d	sp[64],r8
800051ec:	fa e9 00 48 	st.d	sp[72],r8
800051f0:	30 05       	mov	r5,0
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
800051f2:	1a 97       	mov	r7,sp
800051f4:	30 73       	mov	r3,7
800051f6:	0a 94       	mov	r4,r5
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
800051f8:	4d 72       	lddpc	r2,80005354 <voc_init+0x198>
			log("\r\n----create voice info锛 okay!----\r\n");
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
800051fa:	4d 86       	lddpc	r6,80005358 <voc_init+0x19c>
800051fc:	30 21       	mov	r1,2
800051fe:	30 a0       	mov	r0,10
	memset(str, 0x00, sizeof(str));
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005200:	1a 9a       	mov	r10,sp
80005202:	06 9b       	mov	r11,r3
80005204:	08 9c       	mov	r12,r4
80005206:	f0 1f 00 56 	mcall	8000535c <voc_init+0x1a0>
	if(return_code == DF_OK)
8000520a:	e0 81 00 9f 	brne	80005348 <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
8000520e:	06 9a       	mov	r10,r3
80005210:	1a 9b       	mov	r11,sp
80005212:	04 9c       	mov	r12,r2
80005214:	f0 1f 00 53 	mcall	80005360 <voc_init+0x1a4>
80005218:	c3 60       	breq	80005284 <voc_init+0xc8>
8000521a:	c8 78       	rjmp	80005328 <voc_init+0x16c>
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
				if(return_code != DF_ERASE_COMPLETED)
				{
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
8000521c:	fe 35 00 00 	sub	r5,-65536
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005220:	0e 9b       	mov	r11,r7
80005222:	0a 9c       	mov	r12,r5
80005224:	f0 1f 00 50 	mcall	80005364 <voc_init+0x1a8>
				if(return_code != DF_ERASE_COMPLETED)
80005228:	58 5c       	cp.w	r12,5
8000522a:	e0 81 00 8f 	brne	80005348 <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
8000522e:	0c 35       	cp.w	r5,r6
80005230:	cf 61       	brne	8000521c <voc_init+0x60>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005232:	30 7a       	mov	r10,7
80005234:	30 0b       	mov	r11,0
80005236:	4c 8c       	lddpc	r12,80005354 <voc_init+0x198>
80005238:	f0 1f 00 4c 	mcall	80005368 <voc_init+0x1ac>
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
8000523c:	1a 9c       	mov	r12,sp
8000523e:	30 08       	mov	r8,0
80005240:	30 09       	mov	r9,0
80005242:	fa e9 00 00 	st.d	sp[0],r8
80005246:	fa e9 00 08 	st.d	sp[8],r8
8000524a:	fa e9 00 10 	st.d	sp[16],r8
8000524e:	fa e9 00 18 	st.d	sp[24],r8
80005252:	fa e9 00 20 	st.d	sp[32],r8
80005256:	fa e9 00 28 	st.d	sp[40],r8
8000525a:	fa e9 00 30 	st.d	sp[48],r8
8000525e:	fa e9 00 38 	st.d	sp[56],r8
80005262:	fa e9 00 40 	st.d	sp[64],r8
80005266:	fa e9 00 48 	st.d	sp[72],r8
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
8000526a:	30 2a       	mov	r10,2
8000526c:	30 ab       	mov	r11,10
8000526e:	f0 1f 00 3f 	mcall	80005368 <voc_init+0x1ac>
			if(return_code != DF_WRITE_COMPLETED)
80005272:	58 7c       	cp.w	r12,7
80005274:	c6 a1       	brne	80005348 <voc_init+0x18c>
			{
				return FALSE;
			}
			current_voice_index = 0;
80005276:	30 09       	mov	r9,0
80005278:	4b 88       	lddpc	r8,80005358 <voc_init+0x19c>
8000527a:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create voice info锛 okay!----\r\n");
8000527c:	4b cc       	lddpc	r12,8000536c <voc_init+0x1b0>
8000527e:	f0 1f 00 3d 	mcall	80005370 <voc_init+0x1b4>
80005282:	c5 c8       	rjmp	8000533a <voc_init+0x17e>
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80005284:	0c 9a       	mov	r10,r6
80005286:	02 9b       	mov	r11,r1
80005288:	00 9c       	mov	r12,r0
8000528a:	f0 1f 00 35 	mcall	8000535c <voc_init+0x1a0>
			if(return_code == DF_OK)
8000528e:	c5 d1       	brne	80005348 <voc_init+0x18c>
			{
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80005290:	8c 08       	ld.sh	r8,r6[0x0]
80005292:	58 08       	cp.w	r8,0
80005294:	c5 00       	breq	80005334 <voc_init+0x178>
					
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80005296:	5c 78       	castu.h	r8
80005298:	20 18       	sub	r8,1
8000529a:	f0 08 00 38 	add	r8,r8,r8<<0x3
8000529e:	f0 05 15 03 	lsl	r5,r8,0x3
800052a2:	2f 05       	sub	r5,-16
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
800052a4:	1a 9a       	mov	r10,sp
800052a6:	34 8b       	mov	r11,72
800052a8:	0a 9c       	mov	r12,r5
800052aa:	f0 1f 00 2d 	mcall	8000535c <voc_init+0x1a0>
					return_code = data_flash_read_block(LABEL_ADDRESS, 512, (U8 *)TEMP_BUF);
800052ae:	4b 2a       	lddpc	r10,80005374 <voc_init+0x1b8>
800052b0:	e0 6b 02 00 	mov	r11,512
800052b4:	08 9c       	mov	r12,r4
800052b6:	f0 1f 00 2a 	mcall	8000535c <voc_init+0x1a0>
					if(return_code == DF_OK)
800052ba:	c3 d1       	brne	80005334 <voc_init+0x178>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
						if(ptr->numb == current_voice_index)
800052bc:	0f 89       	ld.ub	r9,r7[0x0]
800052be:	0f 98       	ld.ub	r8,r7[0x1]
800052c0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800052c4:	8c 09       	ld.sh	r9,r6[0x0]
800052c6:	f0 09 19 00 	cp.h	r9,r8
800052ca:	c2 c1       	brne	80005322 <voc_init+0x166>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
800052cc:	ef 39 00 46 	ld.ub	r9,r7[70]
800052d0:	ef 38 00 47 	ld.ub	r8,r7[71]
800052d4:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800052d8:	ef 3a 00 42 	ld.ub	r10,r7[66]
800052dc:	ef 38 00 43 	ld.ub	r8,r7[67]
800052e0:	b1 68       	lsl	r8,0x10
800052e2:	f1 ea 11 88 	or	r8,r8,r10<<0x18
800052e6:	ef 3a 00 44 	ld.ub	r10,r7[68]
800052ea:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800052ee:	ef 3a 00 45 	ld.ub	r10,r7[69]
800052f2:	f5 e8 10 08 	or	r8,r10,r8
800052f6:	f2 08 00 08 	add	r8,r9,r8
800052fa:	4a 09       	lddpc	r9,80005378 <voc_init+0x1bc>
800052fc:	93 08       	st.w	r9[0x0],r8
							if(current_save_voice_offset > 0x7bc000){
800052fe:	e0 69 c0 00 	mov	r9,49152
80005302:	ea 19 00 7b 	orh	r9,0x7b
80005306:	12 38       	cp.w	r8,r9
80005308:	e0 88 00 16 	brls	80005334 <voc_init+0x178>
								
								log("\r\n----voice storage is full!!!----\r\n");
8000530c:	49 cc       	lddpc	r12,8000537c <voc_init+0x1c0>
8000530e:	f0 1f 00 19 	mcall	80005370 <voc_init+0x1b4>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005312:	30 4b       	mov	r11,4
80005314:	08 9c       	mov	r12,r4
80005316:	f0 1f 00 14 	mcall	80005364 <voc_init+0x1a8>
								if(return_code == DF_ERASE_COMPLETED)goto start;
8000531a:	58 5c       	cp.w	r12,5
8000531c:	fe 90 ff 72 	breq	80005200 <voc_init+0x44>
80005320:	c1 48       	rjmp	80005348 <voc_init+0x18c>
								return FALSE;
							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
80005322:	49 8c       	lddpc	r12,80005380 <voc_init+0x1c4>
80005324:	f0 1f 00 13 	mcall	80005370 <voc_init+0x1b4>
	
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
80005328:	e6 78 00 00 	mov	r8,458752
8000532c:	ea 08 00 06 	add	r6,r5,r8
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005330:	30 37       	mov	r7,3
80005332:	c7 7b       	rjmp	80005220 <voc_init+0x64>
							goto ERASE;
							//return FALSE;
						}
					}
				}
				log("\r\n----read voice info锛 okay!----\r\n");
80005334:	49 4c       	lddpc	r12,80005384 <voc_init+0x1c8>
80005336:	f0 1f 00 0f 	mcall	80005370 <voc_init+0x1b4>
			}
			else
			return FALSE;
		}
		
		memcpy(voice_count_ptr, &current_voice_index, sizeof(current_voice_index));
8000533a:	48 88       	lddpc	r8,80005358 <voc_init+0x19c>
8000533c:	90 09       	ld.sh	r9,r8[0x0]
8000533e:	49 38       	lddpc	r8,80005388 <voc_init+0x1cc>
80005340:	b0 09       	st.h	r8[0x0],r9
		list_init_success_flag = 1;
80005342:	30 19       	mov	r9,1
80005344:	49 28       	lddpc	r8,8000538c <voc_init+0x1d0>
80005346:	b0 89       	st.b	r8[0x0],r9
	// then read address 0x00001002 every 5s and report to radio with failure
	//test_data_flash(FALSE);
	//create_data_flash_test_task();
	voice_list_info_init(Current_total_voice);
	
	voc_read_write_test();
80005348:	f0 1f 00 12 	mcall	80005390 <voc_init+0x1d4>

8000534c:	2e cd       	sub	sp,-80
8000534e:	d8 32       	popm	r0-r7,pc
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	2d c0       	sub	r0,-36
80005354:	00 00       	add	r0,r0
80005356:	05 24       	ld.uh	r4,r2++
80005358:	00 00       	add	r0,r0
8000535a:	0b 54       	ld.sh	r4,--r5
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	2a a0       	sub	r0,-86
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	74 a4       	ld.w	r4,r10[0x28]
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	2c 34       	sub	r4,-61
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	2c d0       	sub	r0,-51
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	d9 d8       	*unknown*
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	6c 10       	ld.w	r0,r6[0x4]
80005374:	00 00       	add	r0,r0
80005376:	50 fc       	stdsp	sp[0x3c],r12
80005378:	00 00       	add	r0,r0
8000537a:	05 2c       	ld.uh	r12,r2++
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	da 00       	acall	0xa0
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	da 28       	*unknown*
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	da 4c       	*unknown*
80005388:	00 00       	add	r0,r0
8000538a:	0b 5c       	ld.sh	r12,--r5
8000538c:	00 00       	add	r0,r0
8000538e:	0b 56       	ld.sh	r6,--r5
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	50 d0       	stdsp	sp[0x34],r0

80005394 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005394:	f8 08 16 05 	lsr	r8,r12,0x5
80005398:	a9 68       	lsl	r8,0x8
8000539a:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000539e:	58 1b       	cp.w	r11,1
800053a0:	c0 d0       	breq	800053ba <gpio_enable_module_pin+0x26>
800053a2:	c0 63       	brcs	800053ae <gpio_enable_module_pin+0x1a>
800053a4:	58 2b       	cp.w	r11,2
800053a6:	c1 00       	breq	800053c6 <gpio_enable_module_pin+0x32>
800053a8:	58 3b       	cp.w	r11,3
800053aa:	c1 40       	breq	800053d2 <gpio_enable_module_pin+0x3e>
800053ac:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800053ae:	30 19       	mov	r9,1
800053b0:	f2 0c 09 49 	lsl	r9,r9,r12
800053b4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800053b6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053b8:	c1 28       	rjmp	800053dc <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053ba:	30 19       	mov	r9,1
800053bc:	f2 0c 09 49 	lsl	r9,r9,r12
800053c0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800053c2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053c4:	c0 c8       	rjmp	800053dc <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800053c6:	30 19       	mov	r9,1
800053c8:	f2 0c 09 49 	lsl	r9,r9,r12
800053cc:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053ce:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053d0:	c0 68       	rjmp	800053dc <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053d2:	30 19       	mov	r9,1
800053d4:	f2 0c 09 49 	lsl	r9,r9,r12
800053d8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053da:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800053dc:	30 19       	mov	r9,1
800053de:	f2 0c 09 4c 	lsl	r12,r9,r12
800053e2:	91 2c       	st.w	r8[0x8],r12
800053e4:	5e fd       	retal	0
800053e6:	d7 03       	nop

800053e8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800053e8:	d4 21       	pushm	r4-r7,lr
800053ea:	18 97       	mov	r7,r12
800053ec:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053ee:	58 0b       	cp.w	r11,0
800053f0:	c0 31       	brne	800053f6 <gpio_enable_module+0xe>
800053f2:	30 05       	mov	r5,0
800053f4:	c0 d8       	rjmp	8000540e <gpio_enable_module+0x26>
800053f6:	30 06       	mov	r6,0
800053f8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800053fa:	6e 1b       	ld.w	r11,r7[0x4]
800053fc:	6e 0c       	ld.w	r12,r7[0x0]
800053fe:	f0 1f 00 06 	mcall	80005414 <gpio_enable_module+0x2c>
80005402:	18 45       	or	r5,r12
		gpiomap++;
80005404:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005406:	2f f6       	sub	r6,-1
80005408:	0c 34       	cp.w	r4,r6
8000540a:	fe 9b ff f8 	brhi	800053fa <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000540e:	0a 9c       	mov	r12,r5
80005410:	d8 22       	popm	r4-r7,pc
80005412:	00 00       	add	r0,r0
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	53 94       	stdsp	sp[0xe4],r4

80005418 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005418:	f8 08 16 05 	lsr	r8,r12,0x5
8000541c:	a9 68       	lsl	r8,0x8
8000541e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005422:	30 19       	mov	r9,1
80005424:	f2 0c 09 4c 	lsl	r12,r9,r12
80005428:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000542c:	91 1c       	st.w	r8[0x4],r12
}
8000542e:	5e fc       	retal	r12

80005430 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005430:	f8 08 16 05 	lsr	r8,r12,0x5
80005434:	a9 68       	lsl	r8,0x8
80005436:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000543a:	30 19       	mov	r9,1
8000543c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005440:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005444:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005448:	91 1c       	st.w	r8[0x4],r12
}
8000544a:	5e fc       	retal	r12

8000544c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000544c:	c0 08       	rjmp	8000544c <_unhandled_interrupt>
8000544e:	d7 03       	nop

80005450 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005450:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005454:	49 99       	lddpc	r9,800054b8 <INTC_register_interrupt+0x68>
80005456:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000545a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000545e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005460:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005464:	58 0a       	cp.w	r10,0
80005466:	c0 91       	brne	80005478 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005468:	49 59       	lddpc	r9,800054bc <INTC_register_interrupt+0x6c>
8000546a:	49 6a       	lddpc	r10,800054c0 <INTC_register_interrupt+0x70>
8000546c:	12 1a       	sub	r10,r9
8000546e:	fe 79 08 00 	mov	r9,-63488
80005472:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005476:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005478:	58 1a       	cp.w	r10,1
8000547a:	c0 a1       	brne	8000548e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000547c:	49 09       	lddpc	r9,800054bc <INTC_register_interrupt+0x6c>
8000547e:	49 2a       	lddpc	r10,800054c4 <INTC_register_interrupt+0x74>
80005480:	12 1a       	sub	r10,r9
80005482:	bf aa       	sbr	r10,0x1e
80005484:	fe 79 08 00 	mov	r9,-63488
80005488:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000548c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000548e:	58 2a       	cp.w	r10,2
80005490:	c0 a1       	brne	800054a4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005492:	48 b9       	lddpc	r9,800054bc <INTC_register_interrupt+0x6c>
80005494:	48 da       	lddpc	r10,800054c8 <INTC_register_interrupt+0x78>
80005496:	12 1a       	sub	r10,r9
80005498:	bf ba       	sbr	r10,0x1f
8000549a:	fe 79 08 00 	mov	r9,-63488
8000549e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054a2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800054a4:	48 69       	lddpc	r9,800054bc <INTC_register_interrupt+0x6c>
800054a6:	48 aa       	lddpc	r10,800054cc <INTC_register_interrupt+0x7c>
800054a8:	12 1a       	sub	r10,r9
800054aa:	ea 1a c0 00 	orh	r10,0xc000
800054ae:	fe 79 08 00 	mov	r9,-63488
800054b2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054b6:	5e fc       	retal	r12
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	da 74       	*unknown*
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	ca 00       	breq	800053fe <gpio_enable_module+0x16>
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	cb 04       	brge	80005422 <gpio_enable_gpio_pin+0xa>
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	cb 12       	brcc	80005428 <gpio_enable_gpio_pin+0x10>
800054c8:	80 00       	ld.sh	r0,r0[0x0]
800054ca:	cb 20       	breq	8000542e <gpio_enable_gpio_pin+0x16>
800054cc:	80 00       	ld.sh	r0,r0[0x0]
800054ce:	cb 2e       	rcall	80005232 <voc_init+0x76>

800054d0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800054d0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054d2:	49 18       	lddpc	r8,80005514 <INTC_init_interrupts+0x44>
800054d4:	e3 b8 00 01 	mtsr	0x4,r8
800054d8:	49 0e       	lddpc	lr,80005518 <INTC_init_interrupts+0x48>
800054da:	30 07       	mov	r7,0
800054dc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054de:	49 0c       	lddpc	r12,8000551c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054e0:	49 05       	lddpc	r5,80005520 <INTC_init_interrupts+0x50>
800054e2:	10 15       	sub	r5,r8
800054e4:	fe 76 08 00 	mov	r6,-63488
800054e8:	c1 08       	rjmp	80005508 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054ea:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054ec:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054ee:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054f0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054f4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054f6:	10 3a       	cp.w	r10,r8
800054f8:	fe 9b ff fc 	brhi	800054f0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054fc:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005500:	2f f7       	sub	r7,-1
80005502:	2f 8e       	sub	lr,-8
80005504:	59 37       	cp.w	r7,19
80005506:	c0 50       	breq	80005510 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005508:	7c 08       	ld.w	r8,lr[0x0]
8000550a:	58 08       	cp.w	r8,0
8000550c:	ce f1       	brne	800054ea <INTC_init_interrupts+0x1a>
8000550e:	cf 7b       	rjmp	800054fc <INTC_init_interrupts+0x2c>
80005510:	d8 22       	popm	r4-r7,pc
80005512:	00 00       	add	r0,r0
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	ca 00       	breq	80005456 <INTC_register_interrupt+0x6>
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	da 74       	*unknown*
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	54 4c       	stdsp	sp[0x110],r12
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	cb 04       	brge	80005482 <INTC_register_interrupt+0x32>

80005524 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005524:	fe 78 08 00 	mov	r8,-63488
80005528:	e0 69 00 83 	mov	r9,131
8000552c:	f2 0c 01 0c 	sub	r12,r9,r12
80005530:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005534:	f2 ca ff c0 	sub	r10,r9,-64
80005538:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000553c:	58 08       	cp.w	r8,0
8000553e:	c0 21       	brne	80005542 <_get_interrupt_handler+0x1e>
80005540:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005542:	f0 08 12 00 	clz	r8,r8
80005546:	48 5a       	lddpc	r10,80005558 <_get_interrupt_handler+0x34>
80005548:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000554c:	f0 08 11 1f 	rsub	r8,r8,31
80005550:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005552:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005556:	5e fc       	retal	r12
80005558:	80 00       	ld.sh	r0,r0[0x0]
8000555a:	da 74       	*unknown*

8000555c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000555c:	f8 c8 00 01 	sub	r8,r12,1
80005560:	f0 0b 00 0b 	add	r11,r8,r11
80005564:	f6 0c 0d 0a 	divu	r10,r11,r12
80005568:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000556a:	f4 c8 00 01 	sub	r8,r10,1
8000556e:	e0 48 00 fe 	cp.w	r8,254
80005572:	e0 88 00 03 	brls	80005578 <getBaudDiv+0x1c>
80005576:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005578:	5c 8c       	casts.h	r12
}
8000557a:	5e fc       	retal	r12

8000557c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000557c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005580:	30 18       	mov	r8,1
80005582:	f0 09 18 00 	cp.b	r9,r8
80005586:	e0 88 00 04 	brls	8000558e <spi_initMaster+0x12>
8000558a:	30 2c       	mov	r12,2
8000558c:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000558e:	e0 68 00 80 	mov	r8,128
80005592:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005594:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005596:	30 19       	mov	r9,1
80005598:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000559c:	f7 39 00 0d 	ld.ub	r9,r11[13]
800055a0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800055a4:	30 09       	mov	r9,0
800055a6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800055aa:	30 fa       	mov	r10,15
800055ac:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800055b0:	99 18       	st.w	r12[0x4],r8
800055b2:	5e f9       	retal	r9

800055b4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800055b4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800055b6:	30 18       	mov	r8,1
800055b8:	f0 0b 18 00 	cp.b	r11,r8
800055bc:	5f be       	srhi	lr
800055be:	f0 0a 18 00 	cp.b	r10,r8
800055c2:	5f b8       	srhi	r8
800055c4:	fd e8 10 08 	or	r8,lr,r8
800055c8:	c0 30       	breq	800055ce <spi_selectionMode+0x1a>
800055ca:	30 2c       	mov	r12,2
800055cc:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800055ce:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800055d0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800055d4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800055d8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800055dc:	99 18       	st.w	r12[0x4],r8
800055de:	d8 0a       	popm	pc,r12=0

800055e0 <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800055e0:	78 18       	ld.w	r8,r12[0x4]
800055e2:	ea 18 00 0f 	orh	r8,0xf
800055e6:	99 18       	st.w	r12[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800055e8:	78 18       	ld.w	r8,r12[0x4]
800055ea:	e2 18 00 04 	andl	r8,0x4,COH
800055ee:	c0 f0       	breq	8000560c <spi_selectChip+0x2c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800055f0:	30 e8       	mov	r8,14
800055f2:	f0 0b 18 00 	cp.b	r11,r8
800055f6:	e0 8b 00 19 	brhi	80005628 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800055fa:	78 18       	ld.w	r8,r12[0x4]
800055fc:	b1 6b       	lsl	r11,0x10
800055fe:	ea 1b ff f0 	orh	r11,0xfff0
80005602:	e8 1b ff ff 	orl	r11,0xffff
80005606:	10 6b       	and	r11,r8
80005608:	99 1b       	st.w	r12[0x4],r11
8000560a:	5e fd       	retal	0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
8000560c:	30 38       	mov	r8,3
8000560e:	f0 0b 18 00 	cp.b	r11,r8
80005612:	e0 8b 00 0b 	brhi	80005628 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005616:	78 18       	ld.w	r8,r12[0x4]
80005618:	2f 0b       	sub	r11,-16
8000561a:	30 19       	mov	r9,1
8000561c:	f2 0b 09 4b 	lsl	r11,r9,r11
80005620:	5c db       	com	r11
80005622:	10 6b       	and	r11,r8
80005624:	99 1b       	st.w	r12[0x4],r11
80005626:	5e fd       	retal	0
80005628:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
8000562a:	5e fc       	retal	r12

8000562c <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000562c:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005630:	c0 58       	rjmp	8000563a <spi_unselectChip+0xe>
		if (!timeout--) {
80005632:	58 08       	cp.w	r8,0
80005634:	c0 21       	brne	80005638 <spi_unselectChip+0xc>
80005636:	5e ff       	retal	1
80005638:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000563a:	78 49       	ld.w	r9,r12[0x10]
8000563c:	e2 19 02 00 	andl	r9,0x200,COH
80005640:	cf 90       	breq	80005632 <spi_unselectChip+0x6>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005642:	78 18       	ld.w	r8,r12[0x4]
80005644:	ea 18 00 0f 	orh	r8,0xf
80005648:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000564a:	fc 18 01 00 	movh	r8,0x100
8000564e:	99 08       	st.w	r12[0x0],r8
80005650:	5e fd       	retal	0
80005652:	d7 03       	nop

80005654 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005654:	eb cd 40 f8 	pushm	r3-r7,lr
80005658:	18 95       	mov	r5,r12
8000565a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000565c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005660:	30 38       	mov	r8,3
80005662:	f0 06 18 00 	cp.b	r6,r8
80005666:	e0 8b 00 4d 	brhi	80005700 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
8000566a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000566e:	30 18       	mov	r8,1
80005670:	f0 04 18 00 	cp.b	r4,r8
80005674:	e0 8b 00 46 	brhi	80005700 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005678:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000567c:	30 78       	mov	r8,7
8000567e:	f0 03 18 00 	cp.b	r3,r8
80005682:	e0 88 00 3f 	brls	80005700 <spi_setupChipReg+0xac>
80005686:	31 08       	mov	r8,16
80005688:	f0 03 18 00 	cp.b	r3,r8
8000568c:	e0 8b 00 3a 	brhi	80005700 <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005690:	14 9b       	mov	r11,r10
80005692:	6e 1c       	ld.w	r12,r7[0x4]
80005694:	f0 1f 00 1d 	mcall	80005708 <spi_setupChipReg+0xb4>

	if (baudDiv < 0) {
80005698:	c3 45       	brlt	80005700 <spi_setupChipReg+0xac>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000569a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000569c:	ec 09 16 01 	lsr	r9,r6,0x1
800056a0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800056a4:	ec 16 00 01 	eorl	r6,0x1
800056a8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800056ac:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800056b0:	20 83       	sub	r3,8
800056b2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800056b6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800056ba:	ef 39 00 09 	ld.ub	r9,r7[9]
800056be:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800056c2:	ef 39 00 0a 	ld.ub	r9,r7[10]
800056c6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800056ca:	0f 89       	ld.ub	r9,r7[0x0]
800056cc:	30 1a       	mov	r10,1
800056ce:	f4 09 18 00 	cp.b	r9,r10
800056d2:	c0 e0       	breq	800056ee <spi_setupChipReg+0x9a>
800056d4:	c0 a3       	brcs	800056e8 <spi_setupChipReg+0x94>
800056d6:	30 2a       	mov	r10,2
800056d8:	f4 09 18 00 	cp.b	r9,r10
800056dc:	c0 c0       	breq	800056f4 <spi_setupChipReg+0xa0>
800056de:	30 3a       	mov	r10,3
800056e0:	f4 09 18 00 	cp.b	r9,r10
800056e4:	c0 e1       	brne	80005700 <spi_setupChipReg+0xac>
800056e6:	c0 a8       	rjmp	800056fa <spi_setupChipReg+0xa6>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800056e8:	8b c8       	st.w	r5[0x30],r8
800056ea:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800056ee:	8b d8       	st.w	r5[0x34],r8
800056f0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800056f4:	8b e8       	st.w	r5[0x38],r8
800056f6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800056fa:	8b f8       	st.w	r5[0x3c],r8
800056fc:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;
80005700:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
80005702:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005706:	00 00       	add	r0,r0
80005708:	80 00       	ld.sh	r0,r0[0x0]
8000570a:	55 5c       	stdsp	sp[0x154],r12

8000570c <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000570c:	30 18       	mov	r8,1
8000570e:	99 08       	st.w	r12[0x0],r8
}
80005710:	5e fc       	retal	r12

80005712 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005712:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005716:	c0 58       	rjmp	80005720 <spi_write+0xe>
		if (!timeout--) {
80005718:	58 08       	cp.w	r8,0
8000571a:	c0 21       	brne	8000571e <spi_write+0xc>
8000571c:	5e ff       	retal	1
8000571e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005720:	78 49       	ld.w	r9,r12[0x10]
80005722:	e2 19 00 02 	andl	r9,0x2,COH
80005726:	cf 90       	breq	80005718 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005728:	5c 7b       	castu.h	r11
8000572a:	99 3b       	st.w	r12[0xc],r11
8000572c:	5e fd       	retal	0

8000572e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000572e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005732:	c0 58       	rjmp	8000573c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005734:	58 08       	cp.w	r8,0
80005736:	c0 21       	brne	8000573a <spi_read+0xc>
80005738:	5e ff       	retal	1
8000573a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000573c:	78 49       	ld.w	r9,r12[0x10]
8000573e:	e2 19 02 01 	andl	r9,0x201,COH
80005742:	e0 49 02 01 	cp.w	r9,513
80005746:	cf 71       	brne	80005734 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005748:	78 28       	ld.w	r8,r12[0x8]
8000574a:	b6 08       	st.h	r11[0x0],r8
8000574c:	5e fd       	retal	0

8000574e <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000574e:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005750:	f6 08 15 04 	lsl	r8,r11,0x4
80005754:	14 38       	cp.w	r8,r10
80005756:	f9 b8 08 10 	movls	r8,16
8000575a:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000575e:	f0 0b 02 4b 	mul	r11,r8,r11
80005762:	f6 09 16 01 	lsr	r9,r11,0x1
80005766:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000576a:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000576e:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005772:	f2 cb 00 01 	sub	r11,r9,1
80005776:	e0 4b ff fe 	cp.w	r11,65534
8000577a:	e0 88 00 03 	brls	80005780 <usart_set_async_baudrate+0x32>
8000577e:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005780:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005782:	e8 6e 00 00 	mov	lr,524288
80005786:	59 08       	cp.w	r8,16
80005788:	fc 08 17 10 	movne	r8,lr
8000578c:	f9 b8 00 00 	moveq	r8,0
80005790:	e4 1b ff f7 	andh	r11,0xfff7
80005794:	e0 1b fe cf 	andl	r11,0xfecf
80005798:	16 48       	or	r8,r11
8000579a:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000579c:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800057a0:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800057a4:	99 89       	st.w	r12[0x20],r9
800057a6:	d8 0a       	popm	pc,r12=0

800057a8 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800057a8:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800057aa:	e2 18 00 02 	andl	r8,0x2,COH
800057ae:	c0 31       	brne	800057b4 <usart_write_char+0xc>
800057b0:	30 2c       	mov	r12,2
800057b2:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800057b4:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800057b8:	99 7b       	st.w	r12[0x1c],r11
800057ba:	5e fd       	retal	0

800057bc <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800057bc:	eb cd 40 e0 	pushm	r5-r7,lr
800057c0:	18 96       	mov	r6,r12
800057c2:	16 95       	mov	r5,r11
800057c4:	e0 67 27 0f 	mov	r7,9999
800057c8:	c0 68       	rjmp	800057d4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800057ca:	58 07       	cp.w	r7,0
800057cc:	c0 31       	brne	800057d2 <usart_putchar+0x16>
800057ce:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800057d2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800057d4:	0a 9b       	mov	r11,r5
800057d6:	0c 9c       	mov	r12,r6
800057d8:	f0 1f 00 03 	mcall	800057e4 <usart_putchar+0x28>
800057dc:	cf 71       	brne	800057ca <usart_putchar+0xe>

  return USART_SUCCESS;
}
800057de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800057e2:	00 00       	add	r0,r0
800057e4:	80 00       	ld.sh	r0,r0[0x0]
800057e6:	57 a8       	stdsp	sp[0x1e8],r8

800057e8 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800057e8:	78 58       	ld.w	r8,r12[0x14]
800057ea:	e2 18 00 e0 	andl	r8,0xe0,COH
800057ee:	c0 30       	breq	800057f4 <usart_read_char+0xc>
800057f0:	30 4c       	mov	r12,4
800057f2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800057f4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800057f6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800057fa:	c0 31       	brne	80005800 <usart_read_char+0x18>
800057fc:	30 3c       	mov	r12,3
800057fe:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005800:	78 68       	ld.w	r8,r12[0x18]
80005802:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005806:	97 08       	st.w	r11[0x0],r8
80005808:	5e fd       	retal	0
8000580a:	d7 03       	nop

8000580c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
8000580c:	eb cd 40 c0 	pushm	r6-r7,lr
80005810:	20 1d       	sub	sp,4
80005812:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005814:	1a 97       	mov	r7,sp
80005816:	1a 9b       	mov	r11,sp
80005818:	0c 9c       	mov	r12,r6
8000581a:	f0 1f 00 07 	mcall	80005834 <usart_getchar+0x28>
8000581e:	58 3c       	cp.w	r12,3
80005820:	cf b0       	breq	80005816 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005822:	58 4c       	cp.w	r12,4
80005824:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005828:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
8000582c:	2f fd       	sub	sp,-4
8000582e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005832:	00 00       	add	r0,r0
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	57 e8       	stdsp	sp[0x1f8],r8

80005838 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005838:	eb cd 40 c0 	pushm	r6-r7,lr
8000583c:	18 96       	mov	r6,r12
8000583e:	16 97       	mov	r7,r11
  while (*string != '\0')
80005840:	17 8b       	ld.ub	r11,r11[0x0]
80005842:	58 0b       	cp.w	r11,0
80005844:	c0 80       	breq	80005854 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005846:	2f f7       	sub	r7,-1
80005848:	0c 9c       	mov	r12,r6
8000584a:	f0 1f 00 04 	mcall	80005858 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000584e:	0f 8b       	ld.ub	r11,r7[0x0]
80005850:	58 0b       	cp.w	r11,0
80005852:	cf a1       	brne	80005846 <usart_write_line+0xe>
80005854:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005858:	80 00       	ld.sh	r0,r0[0x0]
8000585a:	57 bc       	stdsp	sp[0x1ec],r12

8000585c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000585c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005860:	e6 18 00 01 	andh	r8,0x1,COH
80005864:	c0 71       	brne	80005872 <usart_reset+0x16>
80005866:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005868:	3f f8       	mov	r8,-1
8000586a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000586c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000586e:	d5 03       	csrf	0x10
80005870:	c0 48       	rjmp	80005878 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005872:	3f f8       	mov	r8,-1
80005874:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005876:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005878:	30 08       	mov	r8,0
8000587a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
8000587c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000587e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005880:	ea 68 61 0c 	mov	r8,680204
80005884:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005886:	5e fc       	retal	r12

80005888 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005888:	eb cd 40 e0 	pushm	r5-r7,lr
8000588c:	18 96       	mov	r6,r12
8000588e:	16 97       	mov	r7,r11
80005890:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005892:	f0 1f 00 2f 	mcall	8000594c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005896:	58 07       	cp.w	r7,0
80005898:	c5 80       	breq	80005948 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000589a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000589c:	30 49       	mov	r9,4
8000589e:	f2 08 18 00 	cp.b	r8,r9
800058a2:	e0 88 00 53 	brls	80005948 <usart_init_rs232+0xc0>
800058a6:	30 99       	mov	r9,9
800058a8:	f2 08 18 00 	cp.b	r8,r9
800058ac:	e0 8b 00 4e 	brhi	80005948 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800058b0:	0f d9       	ld.ub	r9,r7[0x5]
800058b2:	30 78       	mov	r8,7
800058b4:	f0 09 18 00 	cp.b	r9,r8
800058b8:	e0 8b 00 48 	brhi	80005948 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800058bc:	8e 39       	ld.sh	r9,r7[0x6]
800058be:	e0 68 01 01 	mov	r8,257
800058c2:	f0 09 19 00 	cp.h	r9,r8
800058c6:	e0 8b 00 41 	brhi	80005948 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800058ca:	ef 39 00 08 	ld.ub	r9,r7[8]
800058ce:	30 38       	mov	r8,3
800058d0:	f0 09 18 00 	cp.b	r9,r8
800058d4:	e0 8b 00 3a 	brhi	80005948 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800058d8:	0a 9a       	mov	r10,r5
800058da:	6e 0b       	ld.w	r11,r7[0x0]
800058dc:	0c 9c       	mov	r12,r6
800058de:	f0 1f 00 1d 	mcall	80005950 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800058e2:	58 1c       	cp.w	r12,1
800058e4:	c3 20       	breq	80005948 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800058e6:	0f c8       	ld.ub	r8,r7[0x4]
800058e8:	30 99       	mov	r9,9
800058ea:	f2 08 18 00 	cp.b	r8,r9
800058ee:	c0 51       	brne	800058f8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800058f0:	6c 18       	ld.w	r8,r6[0x4]
800058f2:	b1 b8       	sbr	r8,0x11
800058f4:	8d 18       	st.w	r6[0x4],r8
800058f6:	c0 68       	rjmp	80005902 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800058f8:	6c 19       	ld.w	r9,r6[0x4]
800058fa:	20 58       	sub	r8,5
800058fc:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005900:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005902:	6c 19       	ld.w	r9,r6[0x4]
80005904:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005908:	0f d8       	ld.ub	r8,r7[0x5]
8000590a:	a9 78       	lsl	r8,0x9
8000590c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005910:	12 48       	or	r8,r9
80005912:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005914:	8e 38       	ld.sh	r8,r7[0x6]
80005916:	30 29       	mov	r9,2
80005918:	f2 08 19 00 	cp.h	r8,r9
8000591c:	e0 88 00 09 	brls	8000592e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005920:	6c 18       	ld.w	r8,r6[0x4]
80005922:	ad b8       	sbr	r8,0xd
80005924:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005926:	8e b8       	ld.uh	r8,r7[0x6]
80005928:	20 28       	sub	r8,2
8000592a:	8d a8       	st.w	r6[0x28],r8
8000592c:	c0 68       	rjmp	80005938 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000592e:	6c 19       	ld.w	r9,r6[0x4]
80005930:	5c 78       	castu.h	r8
80005932:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005936:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005938:	6c 18       	ld.w	r8,r6[0x4]
8000593a:	e0 18 ff f0 	andl	r8,0xfff0
8000593e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005940:	35 08       	mov	r8,80
80005942:	8d 08       	st.w	r6[0x0],r8
80005944:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005948:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	58 5c       	cp.w	r12,5
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	57 4e       	stdsp	sp[0x1d0],lr

80005954 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005954:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005958:	fe c0 8f 58 	sub	r0,pc,-28840

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000595c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005960:	d5 53       	csrf	0x15
  cp      r0, r1
80005962:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005964:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005968:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000596a:	c0 62       	brcc	80005976 <idata_load_loop_end>
  cp      r0, r1
8000596c:	48 92       	lddpc	r2,80005990 <udata_clear_loop_end+0x4>

8000596e <idata_load_loop>:
  brlo    idata_load_loop
8000596e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005970:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005972:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005974:	cf d3       	brcs	8000596e <idata_load_loop>

80005976 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005976:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000597a:	e0 61 63 98 	mov	r1,25496
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000597e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005980:	c0 62       	brcc	8000598c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005982:	30 02       	mov	r2,0
80005984:	30 03       	mov	r3,0

80005986 <udata_clear_loop>:
80005986:	a1 22       	st.d	r0++,r2
80005988:	02 30       	cp.w	r0,r1
8000598a:	cf e3       	brcs	80005986 <udata_clear_loop>

8000598c <udata_clear_loop_end>:
8000598c:	fe cf e9 c4 	sub	pc,pc,-5692
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	e3 a8 f8 c8 	cop	cp7,cr8,cr12,cr8,0x31

80005994 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005994:	f8 c8 ff f8 	sub	r8,r12,-8
80005998:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000599a:	3f f9       	mov	r9,-1
8000599c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000599e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800059a0:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800059a2:	30 08       	mov	r8,0
800059a4:	99 08       	st.w	r12[0x0],r8
}
800059a6:	5e fc       	retal	r12

800059a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800059a8:	30 08       	mov	r8,0
800059aa:	99 48       	st.w	r12[0x10],r8
}
800059ac:	5e fc       	retal	r12

800059ae <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800059ae:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800059b0:	70 19       	ld.w	r9,r8[0x4]
800059b2:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800059b4:	78 19       	ld.w	r9,r12[0x4]
800059b6:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800059b8:	70 19       	ld.w	r9,r8[0x4]
800059ba:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800059bc:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800059be:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800059c0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800059c2:	78 08       	ld.w	r8,r12[0x0]
800059c4:	2f f8       	sub	r8,-1
800059c6:	99 08       	st.w	r12[0x0],r8
}
800059c8:	5e fc       	retal	r12

800059ca <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800059ca:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800059cc:	5b fa       	cp.w	r10,-1
800059ce:	c0 31       	brne	800059d4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800059d0:	78 48       	ld.w	r8,r12[0x10]
800059d2:	c0 c8       	rjmp	800059ea <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800059d4:	f8 c8 ff f8 	sub	r8,r12,-8
800059d8:	70 19       	ld.w	r9,r8[0x4]
800059da:	72 09       	ld.w	r9,r9[0x0]
800059dc:	12 3a       	cp.w	r10,r9
800059de:	c0 63       	brcs	800059ea <vListInsert+0x20>
800059e0:	70 18       	ld.w	r8,r8[0x4]
800059e2:	70 19       	ld.w	r9,r8[0x4]
800059e4:	72 09       	ld.w	r9,r9[0x0]
800059e6:	12 3a       	cp.w	r10,r9
800059e8:	cf c2       	brcc	800059e0 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800059ea:	70 19       	ld.w	r9,r8[0x4]
800059ec:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800059ee:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800059f0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800059f2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800059f4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800059f6:	78 08       	ld.w	r8,r12[0x0]
800059f8:	2f f8       	sub	r8,-1
800059fa:	99 08       	st.w	r12[0x0],r8
}
800059fc:	5e fc       	retal	r12

800059fe <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800059fe:	78 18       	ld.w	r8,r12[0x4]
80005a00:	78 29       	ld.w	r9,r12[0x8]
80005a02:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005a04:	78 28       	ld.w	r8,r12[0x8]
80005a06:	78 19       	ld.w	r9,r12[0x4]
80005a08:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005a0a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005a0c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005a0e:	18 39       	cp.w	r9,r12
80005a10:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005a14:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005a18:	30 09       	mov	r9,0
80005a1a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005a1c:	70 09       	ld.w	r9,r8[0x0]
80005a1e:	20 19       	sub	r9,1
80005a20:	91 09       	st.w	r8[0x0],r9
}
80005a22:	5e fc       	retal	r12

80005a24 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005a24:	e0 68 08 08 	mov	r8,2056
80005a28:	ea 18 08 08 	orh	r8,0x808
80005a2c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005a2e:	e0 68 09 09 	mov	r8,2313
80005a32:	ea 18 09 09 	orh	r8,0x909
80005a36:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005a38:	e0 68 0a 0a 	mov	r8,2570
80005a3c:	ea 18 0a 0a 	orh	r8,0xa0a
80005a40:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005a42:	e0 68 0b 0b 	mov	r8,2827
80005a46:	ea 18 0b 0b 	orh	r8,0xb0b
80005a4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005a4c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005a4e:	e0 68 be ef 	mov	r8,48879
80005a52:	ea 18 de ad 	orh	r8,0xdead
80005a56:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005a58:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005a5a:	fc 18 00 40 	movh	r8,0x40
80005a5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005a60:	e0 68 00 ff 	mov	r8,255
80005a64:	ea 18 ff 00 	orh	r8,0xff00
80005a68:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005a6a:	e0 68 01 01 	mov	r8,257
80005a6e:	ea 18 01 01 	orh	r8,0x101
80005a72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005a74:	e0 68 02 02 	mov	r8,514
80005a78:	ea 18 02 02 	orh	r8,0x202
80005a7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005a7e:	e0 68 03 03 	mov	r8,771
80005a82:	ea 18 03 03 	orh	r8,0x303
80005a86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005a88:	e0 68 04 04 	mov	r8,1028
80005a8c:	ea 18 04 04 	orh	r8,0x404
80005a90:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005a92:	e0 68 05 05 	mov	r8,1285
80005a96:	ea 18 05 05 	orh	r8,0x505
80005a9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005a9c:	e0 68 06 06 	mov	r8,1542
80005aa0:	ea 18 06 06 	orh	r8,0x606
80005aa4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005aa6:	e0 68 07 07 	mov	r8,1799
80005aaa:	ea 18 07 07 	orh	r8,0x707
80005aae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005ab0:	30 08       	mov	r8,0
80005ab2:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005ab4:	5e fc       	retal	r12
80005ab6:	d7 03       	nop

80005ab8 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005ab8:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005aba:	48 38       	lddpc	r8,80005ac4 <vPortEnterCritical+0xc>
80005abc:	70 09       	ld.w	r9,r8[0x0]
80005abe:	2f f9       	sub	r9,-1
80005ac0:	91 09       	st.w	r8[0x0],r9
}
80005ac2:	5e fc       	retal	r12
80005ac4:	00 00       	add	r0,r0
80005ac6:	05 30       	ld.ub	r0,r2++

80005ac8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005ac8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005aca:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005acc:	30 0a       	mov	r10,0
80005ace:	14 9b       	mov	r11,r10
80005ad0:	49 2c       	lddpc	r12,80005b18 <xPortStartScheduler+0x50>
80005ad2:	f0 1f 00 13 	mcall	80005b1c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005ad6:	e0 68 5d c0 	mov	r8,24000
80005ada:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005ade:	30 08       	mov	r8,0
80005ae0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005ae4:	e0 68 0c d8 	mov	r8,3288
80005ae8:	ea 18 00 00 	orh	r8,0x0
80005aec:	70 00       	ld.w	r0,r8[0x0]
80005aee:	60 0d       	ld.w	sp,r0[0x0]
80005af0:	1b 00       	ld.w	r0,sp++
80005af2:	e0 68 05 30 	mov	r8,1328
80005af6:	ea 18 00 00 	orh	r8,0x0
80005afa:	91 00       	st.w	r8[0x0],r0
80005afc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005b00:	2f ed       	sub	sp,-8
80005b02:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005b06:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005b0a:	e3 b0 00 00 	mtsr	0x0,r0
80005b0e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005b12:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005b16:	d8 0a       	popm	pc,r12=0
80005b18:	80 00       	ld.sh	r0,r0[0x0]
80005b1a:	5b e4       	cp.w	r4,-2
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	54 50       	stdsp	sp[0x114],r0

80005b20 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005b20:	20 6d       	sub	sp,24
80005b22:	eb cd 00 ff 	pushm	r0-r7
80005b26:	fa c7 ff c0 	sub	r7,sp,-64
80005b2a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005b2e:	ef 40 ff e0 	st.w	r7[-32],r0
80005b32:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005b36:	ef 40 ff e4 	st.w	r7[-28],r0
80005b3a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005b3e:	e0 68 05 30 	mov	r8,1328
80005b42:	ea 18 00 00 	orh	r8,0x0
80005b46:	70 00       	ld.w	r0,r8[0x0]
80005b48:	1a d0       	st.w	--sp,r0
80005b4a:	f0 1f 00 1a 	mcall	80005bb0 <LABEL_RET_SCALL_263+0x14>
80005b4e:	e0 68 0c d8 	mov	r8,3288
80005b52:	ea 18 00 00 	orh	r8,0x0
80005b56:	70 00       	ld.w	r0,r8[0x0]
80005b58:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005b5a:	f0 1f 00 17 	mcall	80005bb4 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005b5e:	e0 68 0c d8 	mov	r8,3288
80005b62:	ea 18 00 00 	orh	r8,0x0
80005b66:	70 00       	ld.w	r0,r8[0x0]
80005b68:	60 0d       	ld.w	sp,r0[0x0]
80005b6a:	1b 00       	ld.w	r0,sp++
80005b6c:	e0 68 05 30 	mov	r8,1328
80005b70:	ea 18 00 00 	orh	r8,0x0
80005b74:	91 00       	st.w	r8[0x0],r0
80005b76:	fa c7 ff d8 	sub	r7,sp,-40
80005b7a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005b7e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005b82:	e0 61 05 30 	mov	r1,1328
80005b86:	ea 11 00 00 	orh	r1,0x0
80005b8a:	62 02       	ld.w	r2,r1[0x0]
80005b8c:	58 02       	cp.w	r2,0
80005b8e:	c0 70       	breq	80005b9c <LABEL_RET_SCALL_263>
80005b90:	e4 c2 00 01 	sub	r2,r2,1
80005b94:	83 02       	st.w	r1[0x0],r2
80005b96:	58 02       	cp.w	r2,0
80005b98:	c0 21       	brne	80005b9c <LABEL_RET_SCALL_263>
80005b9a:	b1 c0       	cbr	r0,0x10

80005b9c <LABEL_RET_SCALL_263>:
80005b9c:	ef 40 ff f8 	st.w	r7[-8],r0
80005ba0:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005ba4:	ef 40 ff fc 	st.w	r7[-4],r0
80005ba8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005bac:	2f ad       	sub	sp,-24
80005bae:	d6 13       	rets
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	5a b8       	cp.w	r8,-21
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	61 fc       	ld.w	r12,r0[0x7c]

80005bb8 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005bb8:	e1 b8 00 43 	mfsr	r8,0x10c
80005bbc:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005bc0:	5e fc       	retal	r12
80005bc2:	d7 03       	nop

80005bc4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005bc4:	48 78       	lddpc	r8,80005be0 <vPortExitCritical+0x1c>
80005bc6:	70 08       	ld.w	r8,r8[0x0]
80005bc8:	58 08       	cp.w	r8,0
80005bca:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005bcc:	48 58       	lddpc	r8,80005be0 <vPortExitCritical+0x1c>
80005bce:	70 09       	ld.w	r9,r8[0x0]
80005bd0:	20 19       	sub	r9,1
80005bd2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005bd4:	70 08       	ld.w	r8,r8[0x0]
80005bd6:	58 08       	cp.w	r8,0
80005bd8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005bda:	d5 03       	csrf	0x10
80005bdc:	5e fc       	retal	r12
80005bde:	00 00       	add	r0,r0
80005be0:	00 00       	add	r0,r0
80005be2:	05 30       	ld.ub	r0,r2++

80005be4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005be4:	eb cd 00 ff 	pushm	r0-r7
80005be8:	e0 68 05 30 	mov	r8,1328
80005bec:	ea 18 00 00 	orh	r8,0x0
80005bf0:	70 00       	ld.w	r0,r8[0x0]
80005bf2:	1a d0       	st.w	--sp,r0
80005bf4:	7a 90       	ld.w	r0,sp[0x24]
80005bf6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005bfa:	58 10       	cp.w	r0,1
80005bfc:	e0 8b 00 08 	brhi	80005c0c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005c00:	e0 68 0c d8 	mov	r8,3288
80005c04:	ea 18 00 00 	orh	r8,0x0
80005c08:	70 00       	ld.w	r0,r8[0x0]
80005c0a:	81 0d       	st.w	r0[0x0],sp

80005c0c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005c0c:	f0 1f 00 12 	mcall	80005c54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005c10:	f0 1f 00 12 	mcall	80005c58 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005c14:	f0 1f 00 12 	mcall	80005c5c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005c18:	f0 1f 00 12 	mcall	80005c60 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005c1c:	7a 90       	ld.w	r0,sp[0x24]
80005c1e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005c22:	58 10       	cp.w	r0,1
80005c24:	e0 8b 00 0e 	brhi	80005c40 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005c28:	f0 1f 00 0c 	mcall	80005c58 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005c2c:	f0 1f 00 0e 	mcall	80005c64 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005c30:	f0 1f 00 0c 	mcall	80005c60 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005c34:	e0 68 0c d8 	mov	r8,3288
80005c38:	ea 18 00 00 	orh	r8,0x0
80005c3c:	70 00       	ld.w	r0,r8[0x0]
80005c3e:	60 0d       	ld.w	sp,r0[0x0]

80005c40 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005c40:	1b 00       	ld.w	r0,sp++
80005c42:	e0 68 05 30 	mov	r8,1328
80005c46:	ea 18 00 00 	orh	r8,0x0
80005c4a:	91 00       	st.w	r8[0x0],r0
80005c4c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c50:	d6 03       	rete
80005c52:	00 00       	add	r0,r0
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	5b b8       	cp.w	r8,-5
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	5a b8       	cp.w	r8,-21
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	64 00       	ld.w	r0,r2[0x0]
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	5b c4       	cp.w	r4,-4
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	61 fc       	ld.w	r12,r0[0x7c]

80005c68 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005c68:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005c6a:	f0 1f 00 02 	mcall	80005c70 <__malloc_lock+0x8>
}
80005c6e:	d8 02       	popm	pc
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	61 ec       	ld.w	r12,r0[0x78]

80005c74 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005c74:	d4 01       	pushm	lr
	xTaskResumeAll();
80005c76:	f0 1f 00 02 	mcall	80005c7c <__malloc_unlock+0x8>
}
80005c7a:	d8 02       	popm	pc
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	65 a8       	ld.w	r8,r2[0x68]

80005c80 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005c80:	d4 21       	pushm	r4-r7,lr
80005c82:	16 95       	mov	r5,r11
80005c84:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005c86:	58 0c       	cp.w	r12,0
80005c88:	c0 30       	breq	80005c8e <_read+0xe>
80005c8a:	3f f7       	mov	r7,-1
80005c8c:	c1 48       	rjmp	80005cb4 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005c8e:	58 0a       	cp.w	r10,0
80005c90:	e0 89 00 04 	brgt	80005c98 <_read+0x18>
80005c94:	30 07       	mov	r7,0
80005c96:	c0 f8       	rjmp	80005cb4 <_read+0x34>
80005c98:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005c9a:	48 84       	lddpc	r4,80005cb8 <_read+0x38>
80005c9c:	68 0c       	ld.w	r12,r4[0x0]
80005c9e:	f0 1f 00 08 	mcall	80005cbc <_read+0x3c>
    if (c < 0)
80005ca2:	c0 95       	brlt	80005cb4 <_read+0x34>
      break;

    *ptr++ = c;
80005ca4:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005ca8:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005caa:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005cae:	58 08       	cp.w	r8,0
80005cb0:	fe 99 ff f6 	brgt	80005c9c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005cb4:	0e 9c       	mov	r12,r7
80005cb6:	d8 22       	popm	r4-r7,pc
80005cb8:	00 00       	add	r0,r0
80005cba:	63 8c       	ld.w	r12,r1[0x60]
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	58 0c       	cp.w	r12,0

80005cc0 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005cc0:	d4 21       	pushm	r4-r7,lr
80005cc2:	16 95       	mov	r5,r11
80005cc4:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005cc6:	20 1c       	sub	r12,1
80005cc8:	58 2c       	cp.w	r12,2
80005cca:	e0 8b 00 12 	brhi	80005cee <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005cce:	58 0a       	cp.w	r10,0
80005cd0:	c0 31       	brne	80005cd6 <_write+0x16>
80005cd2:	30 07       	mov	r7,0
80005cd4:	c0 e8       	rjmp	80005cf0 <_write+0x30>
80005cd6:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005cd8:	48 74       	lddpc	r4,80005cf4 <_write+0x34>
80005cda:	68 0c       	ld.w	r12,r4[0x0]
80005cdc:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005ce0:	f0 1f 00 06 	mcall	80005cf8 <_write+0x38>
80005ce4:	c0 55       	brlt	80005cee <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005ce6:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005ce8:	0e 36       	cp.w	r6,r7
80005cea:	cf 81       	brne	80005cda <_write+0x1a>
80005cec:	c0 28       	rjmp	80005cf0 <_write+0x30>
80005cee:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005cf0:	0e 9c       	mov	r12,r7
80005cf2:	d8 22       	popm	r4-r7,pc
80005cf4:	00 00       	add	r0,r0
80005cf6:	63 8c       	ld.w	r12,r1[0x60]
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	57 bc       	stdsp	sp[0x1ec],r12

80005cfc <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005cfc:	eb cd 40 80 	pushm	r7,lr
80005d00:	18 97       	mov	r7,r12
	if( pv )
80005d02:	58 0c       	cp.w	r12,0
80005d04:	c0 80       	breq	80005d14 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005d06:	f0 1f 00 05 	mcall	80005d18 <vPortFree+0x1c>
		{
			free( pv );
80005d0a:	0e 9c       	mov	r12,r7
80005d0c:	f0 1f 00 04 	mcall	80005d1c <vPortFree+0x20>
		}
		xTaskResumeAll();
80005d10:	f0 1f 00 04 	mcall	80005d20 <vPortFree+0x24>
80005d14:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	61 ec       	ld.w	r12,r0[0x78]
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	70 4c       	ld.w	r12,r8[0x10]
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	65 a8       	ld.w	r8,r2[0x68]

80005d24 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005d24:	eb cd 40 80 	pushm	r7,lr
80005d28:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005d2a:	f0 1f 00 06 	mcall	80005d40 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005d2e:	0e 9c       	mov	r12,r7
80005d30:	f0 1f 00 05 	mcall	80005d44 <pvPortMalloc+0x20>
80005d34:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005d36:	f0 1f 00 05 	mcall	80005d48 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005d3a:	0e 9c       	mov	r12,r7
80005d3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	61 ec       	ld.w	r12,r0[0x78]
80005d44:	80 00       	ld.sh	r0,r0[0x0]
80005d46:	70 5c       	ld.w	r12,r8[0x14]
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	65 a8       	ld.w	r8,r2[0x68]

80005d4c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005d4c:	d4 01       	pushm	lr
80005d4e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005d50:	78 09       	ld.w	r9,r12[0x0]
80005d52:	58 09       	cp.w	r9,0
80005d54:	c1 10       	breq	80005d76 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005d56:	78 3a       	ld.w	r10,r12[0xc]
80005d58:	79 09       	ld.w	r9,r12[0x40]
80005d5a:	f4 09 00 09 	add	r9,r10,r9
80005d5e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005d60:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005d62:	14 39       	cp.w	r9,r10
80005d64:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005d68:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005d6c:	79 0a       	ld.w	r10,r12[0x40]
80005d6e:	78 3b       	ld.w	r11,r12[0xc]
80005d70:	10 9c       	mov	r12,r8
80005d72:	f0 1f 00 02 	mcall	80005d78 <prvCopyDataFromQueue+0x2c>
80005d76:	d8 02       	popm	pc
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	74 ca       	ld.w	r10,r10[0x30]

80005d7c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005d7c:	eb cd 40 c0 	pushm	r6-r7,lr
80005d80:	18 97       	mov	r7,r12
80005d82:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005d84:	78 e8       	ld.w	r8,r12[0x38]
80005d86:	58 08       	cp.w	r8,0
80005d88:	c0 31       	brne	80005d8e <xQueueReceiveFromISR+0x12>
80005d8a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005d8e:	f0 1f 00 0e 	mcall	80005dc4 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005d92:	6e e8       	ld.w	r8,r7[0x38]
80005d94:	20 18       	sub	r8,1
80005d96:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005d98:	6f 18       	ld.w	r8,r7[0x44]
80005d9a:	5b f8       	cp.w	r8,-1
80005d9c:	c0 d1       	brne	80005db6 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005d9e:	6e 48       	ld.w	r8,r7[0x10]
80005da0:	58 08       	cp.w	r8,0
80005da2:	c0 f0       	breq	80005dc0 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005da4:	ee cc ff f0 	sub	r12,r7,-16
80005da8:	f0 1f 00 08 	mcall	80005dc8 <xQueueReceiveFromISR+0x4c>
80005dac:	c0 a0       	breq	80005dc0 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005dae:	30 1c       	mov	r12,1
80005db0:	8d 0c       	st.w	r6[0x0],r12
80005db2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005db6:	2f f8       	sub	r8,-1
80005db8:	ef 48 00 44 	st.w	r7[68],r8
80005dbc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005dc0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	5d 4c       	*unknown*
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	63 84       	ld.w	r4,r1[0x60]

80005dcc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005dcc:	eb cd 40 c0 	pushm	r6-r7,lr
80005dd0:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005dd2:	f0 1f 00 23 	mcall	80005e5c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005dd6:	6f 28       	ld.w	r8,r7[0x48]
80005dd8:	58 08       	cp.w	r8,0
80005dda:	e0 8a 00 18 	brle	80005e0a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005dde:	6e 98       	ld.w	r8,r7[0x24]
80005de0:	58 08       	cp.w	r8,0
80005de2:	c1 40       	breq	80005e0a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005de4:	ee c6 ff dc 	sub	r6,r7,-36
80005de8:	c0 48       	rjmp	80005df0 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005dea:	6e 98       	ld.w	r8,r7[0x24]
80005dec:	58 08       	cp.w	r8,0
80005dee:	c0 e0       	breq	80005e0a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005df0:	0c 9c       	mov	r12,r6
80005df2:	f0 1f 00 1c 	mcall	80005e60 <prvUnlockQueue+0x94>
80005df6:	c0 30       	breq	80005dfc <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005df8:	f0 1f 00 1b 	mcall	80005e64 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005dfc:	6f 28       	ld.w	r8,r7[0x48]
80005dfe:	20 18       	sub	r8,1
80005e00:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005e04:	58 08       	cp.w	r8,0
80005e06:	fe 99 ff f2 	brgt	80005dea <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005e0a:	3f f8       	mov	r8,-1
80005e0c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005e10:	f0 1f 00 16 	mcall	80005e68 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005e14:	f0 1f 00 12 	mcall	80005e5c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005e18:	6f 18       	ld.w	r8,r7[0x44]
80005e1a:	58 08       	cp.w	r8,0
80005e1c:	e0 8a 00 18 	brle	80005e4c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005e20:	6e 48       	ld.w	r8,r7[0x10]
80005e22:	58 08       	cp.w	r8,0
80005e24:	c1 40       	breq	80005e4c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005e26:	ee c6 ff f0 	sub	r6,r7,-16
80005e2a:	c0 48       	rjmp	80005e32 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005e2c:	6e 48       	ld.w	r8,r7[0x10]
80005e2e:	58 08       	cp.w	r8,0
80005e30:	c0 e0       	breq	80005e4c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005e32:	0c 9c       	mov	r12,r6
80005e34:	f0 1f 00 0b 	mcall	80005e60 <prvUnlockQueue+0x94>
80005e38:	c0 30       	breq	80005e3e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005e3a:	f0 1f 00 0b 	mcall	80005e64 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005e3e:	6f 18       	ld.w	r8,r7[0x44]
80005e40:	20 18       	sub	r8,1
80005e42:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005e46:	58 08       	cp.w	r8,0
80005e48:	fe 99 ff f2 	brgt	80005e2c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005e4c:	3f f8       	mov	r8,-1
80005e4e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005e52:	f0 1f 00 06 	mcall	80005e68 <prvUnlockQueue+0x9c>
}
80005e56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e5a:	00 00       	add	r0,r0
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	5a b8       	cp.w	r8,-21
80005e60:	80 00       	ld.sh	r0,r0[0x0]
80005e62:	63 84       	ld.w	r4,r1[0x60]
80005e64:	80 00       	ld.sh	r0,r0[0x0]
80005e66:	62 90       	ld.w	r0,r1[0x24]
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	5b c4       	cp.w	r4,-4

80005e6c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005e6c:	d4 31       	pushm	r0-r7,lr
80005e6e:	20 5d       	sub	sp,20
80005e70:	18 97       	mov	r7,r12
80005e72:	50 0b       	stdsp	sp[0x0],r11
80005e74:	50 2a       	stdsp	sp[0x8],r10
80005e76:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005e78:	f8 c2 ff dc 	sub	r2,r12,-36
80005e7c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e7e:	fa c4 ff f4 	sub	r4,sp,-12
80005e82:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005e84:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e86:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005e8a:	f0 1f 00 3e 	mcall	80005f80 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005e8e:	6e e8       	ld.w	r8,r7[0x38]
80005e90:	58 08       	cp.w	r8,0
80005e92:	c2 a0       	breq	80005ee6 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005e94:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005e96:	40 0b       	lddsp	r11,sp[0x0]
80005e98:	0e 9c       	mov	r12,r7
80005e9a:	f0 1f 00 3b 	mcall	80005f84 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005e9e:	40 18       	lddsp	r8,sp[0x4]
80005ea0:	58 08       	cp.w	r8,0
80005ea2:	c1 51       	brne	80005ecc <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005ea4:	6e e8       	ld.w	r8,r7[0x38]
80005ea6:	20 18       	sub	r8,1
80005ea8:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005eaa:	6e 08       	ld.w	r8,r7[0x0]
80005eac:	58 08       	cp.w	r8,0
80005eae:	c0 41       	brne	80005eb6 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005eb0:	f0 1f 00 36 	mcall	80005f88 <xQueueGenericReceive+0x11c>
80005eb4:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005eb6:	6e 48       	ld.w	r8,r7[0x10]
80005eb8:	58 08       	cp.w	r8,0
80005eba:	c1 20       	breq	80005ede <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005ebc:	ee cc ff f0 	sub	r12,r7,-16
80005ec0:	f0 1f 00 33 	mcall	80005f8c <xQueueGenericReceive+0x120>
80005ec4:	58 1c       	cp.w	r12,1
80005ec6:	c0 c1       	brne	80005ede <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005ec8:	d7 33       	scall
80005eca:	c0 a8       	rjmp	80005ede <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005ecc:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ece:	6e 98       	ld.w	r8,r7[0x24]
80005ed0:	58 08       	cp.w	r8,0
80005ed2:	c0 60       	breq	80005ede <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ed4:	04 9c       	mov	r12,r2
80005ed6:	f0 1f 00 2e 	mcall	80005f8c <xQueueGenericReceive+0x120>
80005eda:	c0 20       	breq	80005ede <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005edc:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005ede:	f0 1f 00 2d 	mcall	80005f90 <xQueueGenericReceive+0x124>
80005ee2:	30 1c       	mov	r12,1
				return pdPASS;
80005ee4:	c4 c8       	rjmp	80005f7c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005ee6:	40 28       	lddsp	r8,sp[0x8]
80005ee8:	58 08       	cp.w	r8,0
80005eea:	c0 51       	brne	80005ef4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005eec:	f0 1f 00 29 	mcall	80005f90 <xQueueGenericReceive+0x124>
80005ef0:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005ef2:	c4 58       	rjmp	80005f7c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005ef4:	58 05       	cp.w	r5,0
80005ef6:	c0 51       	brne	80005f00 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005ef8:	08 9c       	mov	r12,r4
80005efa:	f0 1f 00 27 	mcall	80005f94 <xQueueGenericReceive+0x128>
80005efe:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005f00:	f0 1f 00 24 	mcall	80005f90 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005f04:	f0 1f 00 25 	mcall	80005f98 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005f08:	f0 1f 00 1e 	mcall	80005f80 <xQueueGenericReceive+0x114>
80005f0c:	6f 18       	ld.w	r8,r7[0x44]
80005f0e:	5b f8       	cp.w	r8,-1
80005f10:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005f14:	6f 28       	ld.w	r8,r7[0x48]
80005f16:	5b f8       	cp.w	r8,-1
80005f18:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005f1c:	f0 1f 00 1d 	mcall	80005f90 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005f20:	06 9b       	mov	r11,r3
80005f22:	08 9c       	mov	r12,r4
80005f24:	f0 1f 00 1e 	mcall	80005f9c <xQueueGenericReceive+0x130>
80005f28:	c2 41       	brne	80005f70 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005f2a:	f0 1f 00 16 	mcall	80005f80 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005f2e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005f30:	f0 1f 00 18 	mcall	80005f90 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005f34:	58 06       	cp.w	r6,0
80005f36:	c1 71       	brne	80005f64 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005f38:	6e 08       	ld.w	r8,r7[0x0]
80005f3a:	58 08       	cp.w	r8,0
80005f3c:	c0 81       	brne	80005f4c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005f3e:	f0 1f 00 11 	mcall	80005f80 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005f42:	6e 1c       	ld.w	r12,r7[0x4]
80005f44:	f0 1f 00 17 	mcall	80005fa0 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005f48:	f0 1f 00 12 	mcall	80005f90 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005f4c:	40 2b       	lddsp	r11,sp[0x8]
80005f4e:	04 9c       	mov	r12,r2
80005f50:	f0 1f 00 15 	mcall	80005fa4 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005f54:	0e 9c       	mov	r12,r7
80005f56:	f0 1f 00 15 	mcall	80005fa8 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005f5a:	f0 1f 00 15 	mcall	80005fac <xQueueGenericReceive+0x140>
80005f5e:	c9 61       	brne	80005e8a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005f60:	d7 33       	scall
80005f62:	c9 4b       	rjmp	80005e8a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005f64:	0e 9c       	mov	r12,r7
80005f66:	f0 1f 00 11 	mcall	80005fa8 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005f6a:	f0 1f 00 11 	mcall	80005fac <xQueueGenericReceive+0x140>
80005f6e:	c8 eb       	rjmp	80005e8a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005f70:	0e 9c       	mov	r12,r7
80005f72:	f0 1f 00 0e 	mcall	80005fa8 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005f76:	f0 1f 00 0e 	mcall	80005fac <xQueueGenericReceive+0x140>
80005f7a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005f7c:	2f bd       	sub	sp,-20
80005f7e:	d8 32       	popm	r0-r7,pc
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	5a b8       	cp.w	r8,-21
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	5d 4c       	*unknown*
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	62 9c       	ld.w	r12,r1[0x24]
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	63 84       	ld.w	r4,r1[0x60]
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	5b c4       	cp.w	r4,-4
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	62 78       	ld.w	r8,r1[0x1c]
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	61 ec       	ld.w	r12,r0[0x78]
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	65 14       	ld.w	r4,r2[0x44]
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	63 00       	ld.w	r0,r1[0x40]
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	67 6c       	ld.w	r12,r3[0x58]
80005fa8:	80 00       	ld.sh	r0,r0[0x0]
80005faa:	5d cc       	*unknown*
80005fac:	80 00       	ld.sh	r0,r0[0x0]
80005fae:	65 a8       	ld.w	r8,r2[0x68]

80005fb0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005fb0:	eb cd 40 80 	pushm	r7,lr
80005fb4:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005fb6:	79 08       	ld.w	r8,r12[0x40]
80005fb8:	58 08       	cp.w	r8,0
80005fba:	c0 a1       	brne	80005fce <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005fbc:	78 08       	ld.w	r8,r12[0x0]
80005fbe:	58 08       	cp.w	r8,0
80005fc0:	c2 b1       	brne	80006016 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005fc2:	78 1c       	ld.w	r12,r12[0x4]
80005fc4:	f0 1f 00 17 	mcall	80006020 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005fc8:	30 08       	mov	r8,0
80005fca:	8f 18       	st.w	r7[0x4],r8
80005fcc:	c2 58       	rjmp	80006016 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005fce:	58 0a       	cp.w	r10,0
80005fd0:	c1 01       	brne	80005ff0 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005fd2:	10 9a       	mov	r10,r8
80005fd4:	78 2c       	ld.w	r12,r12[0x8]
80005fd6:	f0 1f 00 14 	mcall	80006024 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005fda:	6e 29       	ld.w	r9,r7[0x8]
80005fdc:	6f 08       	ld.w	r8,r7[0x40]
80005fde:	f2 08 00 08 	add	r8,r9,r8
80005fe2:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005fe4:	6e 19       	ld.w	r9,r7[0x4]
80005fe6:	12 38       	cp.w	r8,r9
80005fe8:	c1 73       	brcs	80006016 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005fea:	6e 08       	ld.w	r8,r7[0x0]
80005fec:	8f 28       	st.w	r7[0x8],r8
80005fee:	c1 48       	rjmp	80006016 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005ff0:	10 9a       	mov	r10,r8
80005ff2:	78 3c       	ld.w	r12,r12[0xc]
80005ff4:	f0 1f 00 0c 	mcall	80006024 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005ff8:	6f 08       	ld.w	r8,r7[0x40]
80005ffa:	6e 39       	ld.w	r9,r7[0xc]
80005ffc:	f2 08 01 08 	sub	r8,r9,r8
80006000:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006002:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006004:	12 38       	cp.w	r8,r9
80006006:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000600a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000600e:	f3 d8 e3 19 	subcs	r9,r9,r8
80006012:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006016:	6e e8       	ld.w	r8,r7[0x38]
80006018:	2f f8       	sub	r8,-1
8000601a:	8f e8       	st.w	r7[0x38],r8
}
8000601c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006020:	80 00       	ld.sh	r0,r0[0x0]
80006022:	62 a8       	ld.w	r8,r1[0x28]
80006024:	80 00       	ld.sh	r0,r0[0x0]
80006026:	74 ca       	ld.w	r10,r10[0x30]

80006028 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006028:	eb cd 40 c0 	pushm	r6-r7,lr
8000602c:	18 97       	mov	r7,r12
8000602e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006030:	78 ec       	ld.w	r12,r12[0x38]
80006032:	6e f8       	ld.w	r8,r7[0x3c]
80006034:	10 3c       	cp.w	r12,r8
80006036:	c0 33       	brcs	8000603c <xQueueGenericSendFromISR+0x14>
80006038:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000603c:	12 9a       	mov	r10,r9
8000603e:	0e 9c       	mov	r12,r7
80006040:	f0 1f 00 0c 	mcall	80006070 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006044:	6f 28       	ld.w	r8,r7[0x48]
80006046:	5b f8       	cp.w	r8,-1
80006048:	c0 d1       	brne	80006062 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000604a:	6e 98       	ld.w	r8,r7[0x24]
8000604c:	58 08       	cp.w	r8,0
8000604e:	c0 f0       	breq	8000606c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006050:	ee cc ff dc 	sub	r12,r7,-36
80006054:	f0 1f 00 08 	mcall	80006074 <xQueueGenericSendFromISR+0x4c>
80006058:	c0 a0       	breq	8000606c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000605a:	30 1c       	mov	r12,1
8000605c:	8d 0c       	st.w	r6[0x0],r12
8000605e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006062:	2f f8       	sub	r8,-1
80006064:	ef 48 00 48 	st.w	r7[72],r8
80006068:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000606c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006070:	80 00       	ld.sh	r0,r0[0x0]
80006072:	5f b0       	srhi	r0
80006074:	80 00       	ld.sh	r0,r0[0x0]
80006076:	63 84       	ld.w	r4,r1[0x60]

80006078 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006078:	d4 31       	pushm	r0-r7,lr
8000607a:	20 5d       	sub	sp,20
8000607c:	18 97       	mov	r7,r12
8000607e:	50 0b       	stdsp	sp[0x0],r11
80006080:	50 2a       	stdsp	sp[0x8],r10
80006082:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006084:	f8 c0 ff f0 	sub	r0,r12,-16
80006088:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000608a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000608e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006090:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006094:	f0 1f 00 2f 	mcall	80006150 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006098:	6e e9       	ld.w	r9,r7[0x38]
8000609a:	6e f8       	ld.w	r8,r7[0x3c]
8000609c:	10 39       	cp.w	r9,r8
8000609e:	c1 42       	brcc	800060c6 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800060a0:	40 1a       	lddsp	r10,sp[0x4]
800060a2:	40 0b       	lddsp	r11,sp[0x0]
800060a4:	0e 9c       	mov	r12,r7
800060a6:	f0 1f 00 2c 	mcall	80006154 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800060aa:	6e 98       	ld.w	r8,r7[0x24]
800060ac:	58 08       	cp.w	r8,0
800060ae:	c0 80       	breq	800060be <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800060b0:	ee cc ff dc 	sub	r12,r7,-36
800060b4:	f0 1f 00 29 	mcall	80006158 <xQueueGenericSend+0xe0>
800060b8:	58 1c       	cp.w	r12,1
800060ba:	c0 21       	brne	800060be <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800060bc:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800060be:	f0 1f 00 28 	mcall	8000615c <xQueueGenericSend+0xe4>
800060c2:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800060c4:	c4 38       	rjmp	8000614a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800060c6:	40 28       	lddsp	r8,sp[0x8]
800060c8:	58 08       	cp.w	r8,0
800060ca:	c0 51       	brne	800060d4 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800060cc:	f0 1f 00 24 	mcall	8000615c <xQueueGenericSend+0xe4>
800060d0:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800060d2:	c3 c8       	rjmp	8000614a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800060d4:	58 04       	cp.w	r4,0
800060d6:	c0 51       	brne	800060e0 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800060d8:	06 9c       	mov	r12,r3
800060da:	f0 1f 00 22 	mcall	80006160 <xQueueGenericSend+0xe8>
800060de:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800060e0:	f0 1f 00 1f 	mcall	8000615c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800060e4:	f0 1f 00 20 	mcall	80006164 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800060e8:	f0 1f 00 1a 	mcall	80006150 <xQueueGenericSend+0xd8>
800060ec:	6f 18       	ld.w	r8,r7[0x44]
800060ee:	5b f8       	cp.w	r8,-1
800060f0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800060f4:	6f 28       	ld.w	r8,r7[0x48]
800060f6:	5b f8       	cp.w	r8,-1
800060f8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800060fc:	f0 1f 00 18 	mcall	8000615c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006100:	04 9b       	mov	r11,r2
80006102:	06 9c       	mov	r12,r3
80006104:	f0 1f 00 19 	mcall	80006168 <xQueueGenericSend+0xf0>
80006108:	c1 b1       	brne	8000613e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000610a:	f0 1f 00 12 	mcall	80006150 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000610e:	6e e5       	ld.w	r5,r7[0x38]
80006110:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006112:	f0 1f 00 13 	mcall	8000615c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006116:	0c 35       	cp.w	r5,r6
80006118:	c0 d1       	brne	80006132 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000611a:	40 2b       	lddsp	r11,sp[0x8]
8000611c:	00 9c       	mov	r12,r0
8000611e:	f0 1f 00 14 	mcall	8000616c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006122:	0e 9c       	mov	r12,r7
80006124:	f0 1f 00 13 	mcall	80006170 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006128:	f0 1f 00 13 	mcall	80006174 <xQueueGenericSend+0xfc>
8000612c:	cb 41       	brne	80006094 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000612e:	d7 33       	scall
80006130:	cb 2b       	rjmp	80006094 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006132:	0e 9c       	mov	r12,r7
80006134:	f0 1f 00 0f 	mcall	80006170 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006138:	f0 1f 00 0f 	mcall	80006174 <xQueueGenericSend+0xfc>
8000613c:	ca cb       	rjmp	80006094 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000613e:	0e 9c       	mov	r12,r7
80006140:	f0 1f 00 0c 	mcall	80006170 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006144:	f0 1f 00 0c 	mcall	80006174 <xQueueGenericSend+0xfc>
80006148:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000614a:	2f bd       	sub	sp,-20
8000614c:	d8 32       	popm	r0-r7,pc
8000614e:	00 00       	add	r0,r0
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	5a b8       	cp.w	r8,-21
80006154:	80 00       	ld.sh	r0,r0[0x0]
80006156:	5f b0       	srhi	r0
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	63 84       	ld.w	r4,r1[0x60]
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	5b c4       	cp.w	r4,-4
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	62 78       	ld.w	r8,r1[0x1c]
80006164:	80 00       	ld.sh	r0,r0[0x0]
80006166:	61 ec       	ld.w	r12,r0[0x78]
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	65 14       	ld.w	r4,r2[0x44]
8000616c:	80 00       	ld.sh	r0,r0[0x0]
8000616e:	67 6c       	ld.w	r12,r3[0x58]
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	5d cc       	*unknown*
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	65 a8       	ld.w	r8,r2[0x68]

80006178 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006178:	d4 21       	pushm	r4-r7,lr
8000617a:	18 97       	mov	r7,r12
8000617c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000617e:	58 0c       	cp.w	r12,0
80006180:	c2 f0       	breq	800061de <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006182:	34 cc       	mov	r12,76
80006184:	f0 1f 00 17 	mcall	800061e0 <xQueueCreate+0x68>
80006188:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000618a:	c2 a0       	breq	800061de <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000618c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006190:	e8 cc ff ff 	sub	r12,r4,-1
80006194:	f0 1f 00 13 	mcall	800061e0 <xQueueCreate+0x68>
80006198:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000619a:	c1 e0       	breq	800061d6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000619c:	f8 04 00 04 	add	r4,r12,r4
800061a0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800061a2:	30 08       	mov	r8,0
800061a4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800061a6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800061a8:	ee c8 00 01 	sub	r8,r7,1
800061ac:	ad 38       	mul	r8,r6
800061ae:	10 0c       	add	r12,r8
800061b0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800061b2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800061b4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800061b8:	3f f8       	mov	r8,-1
800061ba:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800061be:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800061c2:	ea cc ff f0 	sub	r12,r5,-16
800061c6:	f0 1f 00 08 	mcall	800061e4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800061ca:	ea cc ff dc 	sub	r12,r5,-36
800061ce:	f0 1f 00 06 	mcall	800061e4 <xQueueCreate+0x6c>
800061d2:	0a 9c       	mov	r12,r5
800061d4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800061d6:	0a 9c       	mov	r12,r5
800061d8:	f0 1f 00 04 	mcall	800061e8 <xQueueCreate+0x70>
800061dc:	d8 2a       	popm	r4-r7,pc,r12=0
800061de:	d8 2a       	popm	r4-r7,pc,r12=0
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	5d 24       	mustr	r4
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	59 94       	cp.w	r4,25
800061e8:	80 00       	ld.sh	r0,r0[0x0]
800061ea:	5c fc       	rol	r12

800061ec <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800061ec:	48 38       	lddpc	r8,800061f8 <vTaskSuspendAll+0xc>
800061ee:	70 09       	ld.w	r9,r8[0x0]
800061f0:	2f f9       	sub	r9,-1
800061f2:	91 09       	st.w	r8[0x0],r9
}
800061f4:	5e fc       	retal	r12
800061f6:	00 00       	add	r0,r0
800061f8:	00 00       	add	r0,r0
800061fa:	0d 08       	ld.w	r8,r6++

800061fc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800061fc:	49 a8       	lddpc	r8,80006264 <vTaskSwitchContext+0x68>
800061fe:	70 08       	ld.w	r8,r8[0x0]
80006200:	58 08       	cp.w	r8,0
80006202:	c0 b1       	brne	80006218 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006204:	49 98       	lddpc	r8,80006268 <vTaskSwitchContext+0x6c>
80006206:	70 08       	ld.w	r8,r8[0x0]
80006208:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000620c:	49 89       	lddpc	r9,8000626c <vTaskSwitchContext+0x70>
8000620e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006212:	58 08       	cp.w	r8,0
80006214:	c0 60       	breq	80006220 <vTaskSwitchContext+0x24>
80006216:	c1 18       	rjmp	80006238 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006218:	30 19       	mov	r9,1
8000621a:	49 68       	lddpc	r8,80006270 <vTaskSwitchContext+0x74>
8000621c:	91 09       	st.w	r8[0x0],r9
8000621e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006220:	49 28       	lddpc	r8,80006268 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006222:	49 3a       	lddpc	r10,8000626c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006224:	70 09       	ld.w	r9,r8[0x0]
80006226:	20 19       	sub	r9,1
80006228:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000622a:	70 09       	ld.w	r9,r8[0x0]
8000622c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006230:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006234:	58 09       	cp.w	r9,0
80006236:	cf 70       	breq	80006224 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006238:	48 c8       	lddpc	r8,80006268 <vTaskSwitchContext+0x6c>
8000623a:	70 08       	ld.w	r8,r8[0x0]
8000623c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006240:	48 b9       	lddpc	r9,8000626c <vTaskSwitchContext+0x70>
80006242:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006246:	70 19       	ld.w	r9,r8[0x4]
80006248:	72 19       	ld.w	r9,r9[0x4]
8000624a:	91 19       	st.w	r8[0x4],r9
8000624c:	f0 ca ff f8 	sub	r10,r8,-8
80006250:	14 39       	cp.w	r9,r10
80006252:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006256:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000625a:	70 18       	ld.w	r8,r8[0x4]
8000625c:	70 39       	ld.w	r9,r8[0xc]
8000625e:	48 68       	lddpc	r8,80006274 <vTaskSwitchContext+0x78>
80006260:	91 09       	st.w	r8[0x0],r9
80006262:	5e fc       	retal	r12
80006264:	00 00       	add	r0,r0
80006266:	0d 08       	ld.w	r8,r6++
80006268:	00 00       	add	r0,r0
8000626a:	0d 40       	ld.w	r0,--r6
8000626c:	00 00       	add	r0,r0
8000626e:	0c 24       	rsub	r4,r6
80006270:	00 00       	add	r0,r0
80006272:	0d 28       	ld.uh	r8,r6++
80006274:	00 00       	add	r0,r0
80006276:	0c d8       	st.w	--r6,r8

80006278 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006278:	48 48       	lddpc	r8,80006288 <vTaskSetTimeOutState+0x10>
8000627a:	70 08       	ld.w	r8,r8[0x0]
8000627c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000627e:	48 48       	lddpc	r8,8000628c <vTaskSetTimeOutState+0x14>
80006280:	70 08       	ld.w	r8,r8[0x0]
80006282:	99 18       	st.w	r12[0x4],r8
}
80006284:	5e fc       	retal	r12
80006286:	00 00       	add	r0,r0
80006288:	00 00       	add	r0,r0
8000628a:	0c 1c       	sub	r12,r6
8000628c:	00 00       	add	r0,r0
8000628e:	0d 04       	ld.w	r4,r6++

80006290 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006290:	30 19       	mov	r9,1
80006292:	48 28       	lddpc	r8,80006298 <vTaskMissedYield+0x8>
80006294:	91 09       	st.w	r8[0x0],r9
}
80006296:	5e fc       	retal	r12
80006298:	00 00       	add	r0,r0
8000629a:	0d 28       	ld.uh	r8,r6++

8000629c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000629c:	48 28       	lddpc	r8,800062a4 <xTaskGetCurrentTaskHandle+0x8>
8000629e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800062a0:	5e fc       	retal	r12
800062a2:	00 00       	add	r0,r0
800062a4:	00 00       	add	r0,r0
800062a6:	0c d8       	st.w	--r6,r8

800062a8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800062a8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800062ac:	58 0c       	cp.w	r12,0
800062ae:	c1 f0       	breq	800062ec <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800062b0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800062b2:	78 b9       	ld.w	r9,r12[0x2c]
800062b4:	79 18       	ld.w	r8,r12[0x44]
800062b6:	10 39       	cp.w	r9,r8
800062b8:	c1 a0       	breq	800062ec <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800062ba:	f8 c6 ff fc 	sub	r6,r12,-4
800062be:	0c 9c       	mov	r12,r6
800062c0:	f0 1f 00 0c 	mcall	800062f0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800062c4:	6f 1c       	ld.w	r12,r7[0x44]
800062c6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800062c8:	f8 08 11 08 	rsub	r8,r12,8
800062cc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800062ce:	48 a8       	lddpc	r8,800062f4 <vTaskPriorityDisinherit+0x4c>
800062d0:	70 08       	ld.w	r8,r8[0x0]
800062d2:	10 3c       	cp.w	r12,r8
800062d4:	e0 88 00 04 	brls	800062dc <vTaskPriorityDisinherit+0x34>
800062d8:	48 78       	lddpc	r8,800062f4 <vTaskPriorityDisinherit+0x4c>
800062da:	91 0c       	st.w	r8[0x0],r12
800062dc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800062e0:	0c 9b       	mov	r11,r6
800062e2:	48 68       	lddpc	r8,800062f8 <vTaskPriorityDisinherit+0x50>
800062e4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800062e8:	f0 1f 00 05 	mcall	800062fc <vTaskPriorityDisinherit+0x54>
800062ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062f0:	80 00       	ld.sh	r0,r0[0x0]
800062f2:	59 fe       	cp.w	lr,31
800062f4:	00 00       	add	r0,r0
800062f6:	0d 40       	ld.w	r0,--r6
800062f8:	00 00       	add	r0,r0
800062fa:	0c 24       	rsub	r4,r6
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	59 ae       	cp.w	lr,26

80006300 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006300:	eb cd 40 c0 	pushm	r6-r7,lr
80006304:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006306:	49 b8       	lddpc	r8,80006370 <vTaskPriorityInherit+0x70>
80006308:	70 08       	ld.w	r8,r8[0x0]
8000630a:	78 b9       	ld.w	r9,r12[0x2c]
8000630c:	70 b8       	ld.w	r8,r8[0x2c]
8000630e:	10 39       	cp.w	r9,r8
80006310:	c2 d2       	brcc	8000636a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006312:	49 88       	lddpc	r8,80006370 <vTaskPriorityInherit+0x70>
80006314:	70 08       	ld.w	r8,r8[0x0]
80006316:	70 b8       	ld.w	r8,r8[0x2c]
80006318:	f0 08 11 08 	rsub	r8,r8,8
8000631c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000631e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006322:	49 59       	lddpc	r9,80006374 <vTaskPriorityInherit+0x74>
80006324:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006328:	78 59       	ld.w	r9,r12[0x14]
8000632a:	10 39       	cp.w	r9,r8
8000632c:	c1 b1       	brne	80006362 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000632e:	f8 c6 ff fc 	sub	r6,r12,-4
80006332:	0c 9c       	mov	r12,r6
80006334:	f0 1f 00 11 	mcall	80006378 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006338:	48 e8       	lddpc	r8,80006370 <vTaskPriorityInherit+0x70>
8000633a:	70 08       	ld.w	r8,r8[0x0]
8000633c:	70 bc       	ld.w	r12,r8[0x2c]
8000633e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006340:	48 f8       	lddpc	r8,8000637c <vTaskPriorityInherit+0x7c>
80006342:	70 08       	ld.w	r8,r8[0x0]
80006344:	10 3c       	cp.w	r12,r8
80006346:	e0 88 00 04 	brls	8000634e <vTaskPriorityInherit+0x4e>
8000634a:	48 d8       	lddpc	r8,8000637c <vTaskPriorityInherit+0x7c>
8000634c:	91 0c       	st.w	r8[0x0],r12
8000634e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006352:	0c 9b       	mov	r11,r6
80006354:	48 88       	lddpc	r8,80006374 <vTaskPriorityInherit+0x74>
80006356:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000635a:	f0 1f 00 0a 	mcall	80006380 <vTaskPriorityInherit+0x80>
8000635e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006362:	48 48       	lddpc	r8,80006370 <vTaskPriorityInherit+0x70>
80006364:	70 08       	ld.w	r8,r8[0x0]
80006366:	70 b8       	ld.w	r8,r8[0x2c]
80006368:	99 b8       	st.w	r12[0x2c],r8
8000636a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000636e:	00 00       	add	r0,r0
80006370:	00 00       	add	r0,r0
80006372:	0c d8       	st.w	--r6,r8
80006374:	00 00       	add	r0,r0
80006376:	0c 24       	rsub	r4,r6
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	59 fe       	cp.w	lr,31
8000637c:	00 00       	add	r0,r0
8000637e:	0d 40       	ld.w	r0,--r6
80006380:	80 00       	ld.sh	r0,r0[0x0]
80006382:	59 ae       	cp.w	lr,26

80006384 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006384:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006388:	78 38       	ld.w	r8,r12[0xc]
8000638a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000638c:	ee c6 ff e8 	sub	r6,r7,-24
80006390:	0c 9c       	mov	r12,r6
80006392:	f0 1f 00 15 	mcall	800063e4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006396:	49 58       	lddpc	r8,800063e8 <xTaskRemoveFromEventList+0x64>
80006398:	70 08       	ld.w	r8,r8[0x0]
8000639a:	58 08       	cp.w	r8,0
8000639c:	c1 71       	brne	800063ca <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000639e:	ee c6 ff fc 	sub	r6,r7,-4
800063a2:	0c 9c       	mov	r12,r6
800063a4:	f0 1f 00 10 	mcall	800063e4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800063a8:	6e bc       	ld.w	r12,r7[0x2c]
800063aa:	49 18       	lddpc	r8,800063ec <xTaskRemoveFromEventList+0x68>
800063ac:	70 08       	ld.w	r8,r8[0x0]
800063ae:	10 3c       	cp.w	r12,r8
800063b0:	e0 88 00 04 	brls	800063b8 <xTaskRemoveFromEventList+0x34>
800063b4:	48 e8       	lddpc	r8,800063ec <xTaskRemoveFromEventList+0x68>
800063b6:	91 0c       	st.w	r8[0x0],r12
800063b8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800063bc:	0c 9b       	mov	r11,r6
800063be:	48 d8       	lddpc	r8,800063f0 <xTaskRemoveFromEventList+0x6c>
800063c0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800063c4:	f0 1f 00 0c 	mcall	800063f4 <xTaskRemoveFromEventList+0x70>
800063c8:	c0 58       	rjmp	800063d2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800063ca:	0c 9b       	mov	r11,r6
800063cc:	48 bc       	lddpc	r12,800063f8 <xTaskRemoveFromEventList+0x74>
800063ce:	f0 1f 00 0a 	mcall	800063f4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800063d2:	48 b8       	lddpc	r8,800063fc <xTaskRemoveFromEventList+0x78>
800063d4:	70 08       	ld.w	r8,r8[0x0]
800063d6:	6e b9       	ld.w	r9,r7[0x2c]
800063d8:	70 b8       	ld.w	r8,r8[0x2c]
800063da:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800063dc:	5f 2c       	srhs	r12
800063de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063e2:	00 00       	add	r0,r0
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	59 fe       	cp.w	lr,31
800063e8:	00 00       	add	r0,r0
800063ea:	0d 08       	ld.w	r8,r6++
800063ec:	00 00       	add	r0,r0
800063ee:	0d 40       	ld.w	r0,--r6
800063f0:	00 00       	add	r0,r0
800063f2:	0c 24       	rsub	r4,r6
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	59 ae       	cp.w	lr,26
800063f8:	00 00       	add	r0,r0
800063fa:	0c dc       	st.w	--r6,r12
800063fc:	00 00       	add	r0,r0
800063fe:	0c d8       	st.w	--r6,r8

80006400 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006400:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006404:	4b 98       	lddpc	r8,800064e8 <vTaskIncrementTick+0xe8>
80006406:	70 08       	ld.w	r8,r8[0x0]
80006408:	58 08       	cp.w	r8,0
8000640a:	c6 91       	brne	800064dc <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000640c:	4b 88       	lddpc	r8,800064ec <vTaskIncrementTick+0xec>
8000640e:	70 09       	ld.w	r9,r8[0x0]
80006410:	2f f9       	sub	r9,-1
80006412:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006414:	70 08       	ld.w	r8,r8[0x0]
80006416:	58 08       	cp.w	r8,0
80006418:	c1 a1       	brne	8000644c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000641a:	4b 68       	lddpc	r8,800064f0 <vTaskIncrementTick+0xf0>
8000641c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000641e:	4b 69       	lddpc	r9,800064f4 <vTaskIncrementTick+0xf4>
80006420:	72 0b       	ld.w	r11,r9[0x0]
80006422:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006424:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006426:	4b 59       	lddpc	r9,800064f8 <vTaskIncrementTick+0xf8>
80006428:	72 0a       	ld.w	r10,r9[0x0]
8000642a:	2f fa       	sub	r10,-1
8000642c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000642e:	70 08       	ld.w	r8,r8[0x0]
80006430:	70 08       	ld.w	r8,r8[0x0]
80006432:	58 08       	cp.w	r8,0
80006434:	c0 51       	brne	8000643e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006436:	3f f9       	mov	r9,-1
80006438:	4b 18       	lddpc	r8,800064fc <vTaskIncrementTick+0xfc>
8000643a:	91 09       	st.w	r8[0x0],r9
8000643c:	c0 88       	rjmp	8000644c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000643e:	4a d8       	lddpc	r8,800064f0 <vTaskIncrementTick+0xf0>
80006440:	70 08       	ld.w	r8,r8[0x0]
80006442:	70 38       	ld.w	r8,r8[0xc]
80006444:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006446:	70 19       	ld.w	r9,r8[0x4]
80006448:	4a d8       	lddpc	r8,800064fc <vTaskIncrementTick+0xfc>
8000644a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000644c:	4a 88       	lddpc	r8,800064ec <vTaskIncrementTick+0xec>
8000644e:	70 09       	ld.w	r9,r8[0x0]
80006450:	4a b8       	lddpc	r8,800064fc <vTaskIncrementTick+0xfc>
80006452:	70 08       	ld.w	r8,r8[0x0]
80006454:	10 39       	cp.w	r9,r8
80006456:	c4 73       	brcs	800064e4 <vTaskIncrementTick+0xe4>
80006458:	4a 68       	lddpc	r8,800064f0 <vTaskIncrementTick+0xf0>
8000645a:	70 08       	ld.w	r8,r8[0x0]
8000645c:	70 08       	ld.w	r8,r8[0x0]
8000645e:	58 08       	cp.w	r8,0
80006460:	c0 c0       	breq	80006478 <vTaskIncrementTick+0x78>
80006462:	4a 48       	lddpc	r8,800064f0 <vTaskIncrementTick+0xf0>
80006464:	70 08       	ld.w	r8,r8[0x0]
80006466:	70 38       	ld.w	r8,r8[0xc]
80006468:	70 37       	ld.w	r7,r8[0xc]
8000646a:	6e 18       	ld.w	r8,r7[0x4]
8000646c:	4a 09       	lddpc	r9,800064ec <vTaskIncrementTick+0xec>
8000646e:	72 09       	ld.w	r9,r9[0x0]
80006470:	12 38       	cp.w	r8,r9
80006472:	e0 88 00 14 	brls	8000649a <vTaskIncrementTick+0x9a>
80006476:	c0 e8       	rjmp	80006492 <vTaskIncrementTick+0x92>
80006478:	3f f9       	mov	r9,-1
8000647a:	4a 18       	lddpc	r8,800064fc <vTaskIncrementTick+0xfc>
8000647c:	91 09       	st.w	r8[0x0],r9
8000647e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006482:	6a 08       	ld.w	r8,r5[0x0]
80006484:	70 38       	ld.w	r8,r8[0xc]
80006486:	70 37       	ld.w	r7,r8[0xc]
80006488:	6e 18       	ld.w	r8,r7[0x4]
8000648a:	64 09       	ld.w	r9,r2[0x0]
8000648c:	12 38       	cp.w	r8,r9
8000648e:	e0 88 00 0a 	brls	800064a2 <vTaskIncrementTick+0xa2>
80006492:	49 b9       	lddpc	r9,800064fc <vTaskIncrementTick+0xfc>
80006494:	93 08       	st.w	r9[0x0],r8
80006496:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000649a:	49 a4       	lddpc	r4,80006500 <vTaskIncrementTick+0x100>
8000649c:	49 a3       	lddpc	r3,80006504 <vTaskIncrementTick+0x104>
8000649e:	49 55       	lddpc	r5,800064f0 <vTaskIncrementTick+0xf0>
800064a0:	49 32       	lddpc	r2,800064ec <vTaskIncrementTick+0xec>
800064a2:	ee c6 ff fc 	sub	r6,r7,-4
800064a6:	0c 9c       	mov	r12,r6
800064a8:	f0 1f 00 18 	mcall	80006508 <vTaskIncrementTick+0x108>
800064ac:	6e a8       	ld.w	r8,r7[0x28]
800064ae:	58 08       	cp.w	r8,0
800064b0:	c0 50       	breq	800064ba <vTaskIncrementTick+0xba>
800064b2:	ee cc ff e8 	sub	r12,r7,-24
800064b6:	f0 1f 00 15 	mcall	80006508 <vTaskIncrementTick+0x108>
800064ba:	6e bc       	ld.w	r12,r7[0x2c]
800064bc:	68 08       	ld.w	r8,r4[0x0]
800064be:	10 3c       	cp.w	r12,r8
800064c0:	e9 fc ba 00 	st.whi	r4[0x0],r12
800064c4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064c8:	0c 9b       	mov	r11,r6
800064ca:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800064ce:	f0 1f 00 10 	mcall	8000650c <vTaskIncrementTick+0x10c>
800064d2:	6a 08       	ld.w	r8,r5[0x0]
800064d4:	70 08       	ld.w	r8,r8[0x0]
800064d6:	58 08       	cp.w	r8,0
800064d8:	cd 51       	brne	80006482 <vTaskIncrementTick+0x82>
800064da:	cc fb       	rjmp	80006478 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800064dc:	48 d8       	lddpc	r8,80006510 <vTaskIncrementTick+0x110>
800064de:	70 09       	ld.w	r9,r8[0x0]
800064e0:	2f f9       	sub	r9,-1
800064e2:	91 09       	st.w	r8[0x0],r9
800064e4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800064e8:	00 00       	add	r0,r0
800064ea:	0d 08       	ld.w	r8,r6++
800064ec:	00 00       	add	r0,r0
800064ee:	0d 04       	ld.w	r4,r6++
800064f0:	00 00       	add	r0,r0
800064f2:	0c 10       	sub	r0,r6
800064f4:	00 00       	add	r0,r0
800064f6:	0c 20       	rsub	r0,r6
800064f8:	00 00       	add	r0,r0
800064fa:	0c 1c       	sub	r12,r6
800064fc:	00 00       	add	r0,r0
800064fe:	05 34       	ld.ub	r4,r2++
80006500:	00 00       	add	r0,r0
80006502:	0d 40       	ld.w	r0,--r6
80006504:	00 00       	add	r0,r0
80006506:	0c 24       	rsub	r4,r6
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	59 fe       	cp.w	lr,31
8000650c:	80 00       	ld.sh	r0,r0[0x0]
8000650e:	59 ae       	cp.w	lr,26
80006510:	00 00       	add	r0,r0
80006512:	0c 08       	add	r8,r6

80006514 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006514:	eb cd 40 c0 	pushm	r6-r7,lr
80006518:	18 97       	mov	r7,r12
8000651a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000651c:	f0 1f 00 15 	mcall	80006570 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006520:	6c 08       	ld.w	r8,r6[0x0]
80006522:	5b f8       	cp.w	r8,-1
80006524:	c0 31       	brne	8000652a <xTaskCheckForTimeOut+0x16>
80006526:	30 07       	mov	r7,0
80006528:	c1 f8       	rjmp	80006566 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000652a:	49 39       	lddpc	r9,80006574 <xTaskCheckForTimeOut+0x60>
8000652c:	72 09       	ld.w	r9,r9[0x0]
8000652e:	6e 0a       	ld.w	r10,r7[0x0]
80006530:	12 3a       	cp.w	r10,r9
80006532:	c0 70       	breq	80006540 <xTaskCheckForTimeOut+0x2c>
80006534:	49 19       	lddpc	r9,80006578 <xTaskCheckForTimeOut+0x64>
80006536:	72 09       	ld.w	r9,r9[0x0]
80006538:	6e 1a       	ld.w	r10,r7[0x4]
8000653a:	12 3a       	cp.w	r10,r9
8000653c:	e0 88 00 14 	brls	80006564 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006540:	48 e9       	lddpc	r9,80006578 <xTaskCheckForTimeOut+0x64>
80006542:	72 0a       	ld.w	r10,r9[0x0]
80006544:	6e 19       	ld.w	r9,r7[0x4]
80006546:	12 1a       	sub	r10,r9
80006548:	14 38       	cp.w	r8,r10
8000654a:	e0 88 00 0d 	brls	80006564 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000654e:	48 ba       	lddpc	r10,80006578 <xTaskCheckForTimeOut+0x64>
80006550:	74 0a       	ld.w	r10,r10[0x0]
80006552:	14 19       	sub	r9,r10
80006554:	f2 08 00 08 	add	r8,r9,r8
80006558:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000655a:	0e 9c       	mov	r12,r7
8000655c:	f0 1f 00 08 	mcall	8000657c <xTaskCheckForTimeOut+0x68>
80006560:	30 07       	mov	r7,0
80006562:	c0 28       	rjmp	80006566 <xTaskCheckForTimeOut+0x52>
80006564:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006566:	f0 1f 00 07 	mcall	80006580 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000656a:	0e 9c       	mov	r12,r7
8000656c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	5a b8       	cp.w	r8,-21
80006574:	00 00       	add	r0,r0
80006576:	0c 1c       	sub	r12,r6
80006578:	00 00       	add	r0,r0
8000657a:	0d 04       	ld.w	r4,r6++
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	62 78       	ld.w	r8,r1[0x1c]
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	5b c4       	cp.w	r4,-4

80006584 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006584:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006588:	f0 1f 00 05 	mcall	8000659c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000658c:	48 58       	lddpc	r8,800065a0 <xTaskGetTickCount+0x1c>
8000658e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006590:	f0 1f 00 05 	mcall	800065a4 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006594:	0e 9c       	mov	r12,r7
80006596:	e3 cd 80 80 	ldm	sp++,r7,pc
8000659a:	00 00       	add	r0,r0
8000659c:	80 00       	ld.sh	r0,r0[0x0]
8000659e:	5a b8       	cp.w	r8,-21
800065a0:	00 00       	add	r0,r0
800065a2:	0d 04       	ld.w	r4,r6++
800065a4:	80 00       	ld.sh	r0,r0[0x0]
800065a6:	5b c4       	cp.w	r4,-4

800065a8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800065a8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800065ac:	f0 1f 00 2c 	mcall	8000665c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800065b0:	4a c8       	lddpc	r8,80006660 <xTaskResumeAll+0xb8>
800065b2:	70 09       	ld.w	r9,r8[0x0]
800065b4:	20 19       	sub	r9,1
800065b6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800065b8:	70 08       	ld.w	r8,r8[0x0]
800065ba:	58 08       	cp.w	r8,0
800065bc:	c4 91       	brne	8000664e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800065be:	4a a8       	lddpc	r8,80006664 <xTaskResumeAll+0xbc>
800065c0:	70 08       	ld.w	r8,r8[0x0]
800065c2:	58 08       	cp.w	r8,0
800065c4:	c4 50       	breq	8000664e <xTaskResumeAll+0xa6>
800065c6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800065c8:	4a 85       	lddpc	r5,80006668 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800065ca:	4a 93       	lddpc	r3,8000666c <xTaskResumeAll+0xc4>
800065cc:	4a 92       	lddpc	r2,80006670 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800065ce:	4a a1       	lddpc	r1,80006674 <xTaskResumeAll+0xcc>
800065d0:	c1 e8       	rjmp	8000660c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800065d2:	6a 38       	ld.w	r8,r5[0xc]
800065d4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800065d6:	ee cc ff e8 	sub	r12,r7,-24
800065da:	f0 1f 00 28 	mcall	80006678 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800065de:	ee c6 ff fc 	sub	r6,r7,-4
800065e2:	0c 9c       	mov	r12,r6
800065e4:	f0 1f 00 25 	mcall	80006678 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800065e8:	6e bc       	ld.w	r12,r7[0x2c]
800065ea:	66 08       	ld.w	r8,r3[0x0]
800065ec:	10 3c       	cp.w	r12,r8
800065ee:	e7 fc ba 00 	st.whi	r3[0x0],r12
800065f2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800065f6:	0c 9b       	mov	r11,r6
800065f8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800065fc:	f0 1f 00 20 	mcall	8000667c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006600:	62 08       	ld.w	r8,r1[0x0]
80006602:	6e b9       	ld.w	r9,r7[0x2c]
80006604:	70 b8       	ld.w	r8,r8[0x2c]
80006606:	10 39       	cp.w	r9,r8
80006608:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000660c:	6a 08       	ld.w	r8,r5[0x0]
8000660e:	58 08       	cp.w	r8,0
80006610:	ce 11       	brne	800065d2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006612:	49 c8       	lddpc	r8,80006680 <xTaskResumeAll+0xd8>
80006614:	70 08       	ld.w	r8,r8[0x0]
80006616:	58 08       	cp.w	r8,0
80006618:	c0 f0       	breq	80006636 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000661a:	49 a8       	lddpc	r8,80006680 <xTaskResumeAll+0xd8>
8000661c:	70 08       	ld.w	r8,r8[0x0]
8000661e:	58 08       	cp.w	r8,0
80006620:	c1 10       	breq	80006642 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006622:	49 87       	lddpc	r7,80006680 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006624:	f0 1f 00 18 	mcall	80006684 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006628:	6e 08       	ld.w	r8,r7[0x0]
8000662a:	20 18       	sub	r8,1
8000662c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000662e:	6e 08       	ld.w	r8,r7[0x0]
80006630:	58 08       	cp.w	r8,0
80006632:	cf 91       	brne	80006624 <xTaskResumeAll+0x7c>
80006634:	c0 78       	rjmp	80006642 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006636:	58 14       	cp.w	r4,1
80006638:	c0 50       	breq	80006642 <xTaskResumeAll+0x9a>
8000663a:	49 48       	lddpc	r8,80006688 <xTaskResumeAll+0xe0>
8000663c:	70 08       	ld.w	r8,r8[0x0]
8000663e:	58 18       	cp.w	r8,1
80006640:	c0 71       	brne	8000664e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006642:	30 09       	mov	r9,0
80006644:	49 18       	lddpc	r8,80006688 <xTaskResumeAll+0xe0>
80006646:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006648:	d7 33       	scall
8000664a:	30 17       	mov	r7,1
8000664c:	c0 28       	rjmp	80006650 <xTaskResumeAll+0xa8>
8000664e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006650:	f0 1f 00 0f 	mcall	8000668c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006654:	0e 9c       	mov	r12,r7
80006656:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000665a:	00 00       	add	r0,r0
8000665c:	80 00       	ld.sh	r0,r0[0x0]
8000665e:	5a b8       	cp.w	r8,-21
80006660:	00 00       	add	r0,r0
80006662:	0d 08       	ld.w	r8,r6++
80006664:	00 00       	add	r0,r0
80006666:	0d 24       	ld.uh	r4,r6++
80006668:	00 00       	add	r0,r0
8000666a:	0c dc       	st.w	--r6,r12
8000666c:	00 00       	add	r0,r0
8000666e:	0d 40       	ld.w	r0,--r6
80006670:	00 00       	add	r0,r0
80006672:	0c 24       	rsub	r4,r6
80006674:	00 00       	add	r0,r0
80006676:	0c d8       	st.w	--r6,r8
80006678:	80 00       	ld.sh	r0,r0[0x0]
8000667a:	59 fe       	cp.w	lr,31
8000667c:	80 00       	ld.sh	r0,r0[0x0]
8000667e:	59 ae       	cp.w	lr,26
80006680:	00 00       	add	r0,r0
80006682:	0c 08       	add	r8,r6
80006684:	80 00       	ld.sh	r0,r0[0x0]
80006686:	64 00       	ld.w	r0,r2[0x0]
80006688:	00 00       	add	r0,r0
8000668a:	0d 28       	ld.uh	r8,r6++
8000668c:	80 00       	ld.sh	r0,r0[0x0]
8000668e:	5b c4       	cp.w	r4,-4

80006690 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006690:	eb cd 40 80 	pushm	r7,lr
80006694:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006696:	49 08       	lddpc	r8,800066d4 <prvAddCurrentTaskToDelayedList+0x44>
80006698:	70 08       	ld.w	r8,r8[0x0]
8000669a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
8000669c:	48 f8       	lddpc	r8,800066d8 <prvAddCurrentTaskToDelayedList+0x48>
8000669e:	70 08       	ld.w	r8,r8[0x0]
800066a0:	10 3c       	cp.w	r12,r8
800066a2:	c0 a2       	brcc	800066b6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800066a4:	48 c8       	lddpc	r8,800066d4 <prvAddCurrentTaskToDelayedList+0x44>
800066a6:	70 0b       	ld.w	r11,r8[0x0]
800066a8:	48 d8       	lddpc	r8,800066dc <prvAddCurrentTaskToDelayedList+0x4c>
800066aa:	70 0c       	ld.w	r12,r8[0x0]
800066ac:	2f cb       	sub	r11,-4
800066ae:	f0 1f 00 0d 	mcall	800066e0 <prvAddCurrentTaskToDelayedList+0x50>
800066b2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800066b6:	48 88       	lddpc	r8,800066d4 <prvAddCurrentTaskToDelayedList+0x44>
800066b8:	70 0b       	ld.w	r11,r8[0x0]
800066ba:	48 b8       	lddpc	r8,800066e4 <prvAddCurrentTaskToDelayedList+0x54>
800066bc:	70 0c       	ld.w	r12,r8[0x0]
800066be:	2f cb       	sub	r11,-4
800066c0:	f0 1f 00 08 	mcall	800066e0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800066c4:	48 98       	lddpc	r8,800066e8 <prvAddCurrentTaskToDelayedList+0x58>
800066c6:	70 08       	ld.w	r8,r8[0x0]
800066c8:	10 37       	cp.w	r7,r8
800066ca:	c0 32       	brcc	800066d0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800066cc:	48 78       	lddpc	r8,800066e8 <prvAddCurrentTaskToDelayedList+0x58>
800066ce:	91 07       	st.w	r8[0x0],r7
800066d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800066d4:	00 00       	add	r0,r0
800066d6:	0c d8       	st.w	--r6,r8
800066d8:	00 00       	add	r0,r0
800066da:	0d 04       	ld.w	r4,r6++
800066dc:	00 00       	add	r0,r0
800066de:	0c 20       	rsub	r0,r6
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	59 ca       	cp.w	r10,28
800066e4:	00 00       	add	r0,r0
800066e6:	0c 10       	sub	r0,r6
800066e8:	00 00       	add	r0,r0
800066ea:	05 34       	ld.ub	r4,r2++

800066ec <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800066ec:	eb cd 40 c0 	pushm	r6-r7,lr
800066f0:	18 96       	mov	r6,r12
800066f2:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800066f4:	f0 1f 00 18 	mcall	80006754 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800066f8:	6c 08       	ld.w	r8,r6[0x0]
800066fa:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800066fc:	49 79       	lddpc	r9,80006758 <vTaskDelayUntil+0x6c>
800066fe:	72 09       	ld.w	r9,r9[0x0]
80006700:	12 38       	cp.w	r8,r9
80006702:	e0 88 00 0c 	brls	8000671a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006706:	0e 38       	cp.w	r8,r7
80006708:	e0 88 00 22 	brls	8000674c <vTaskDelayUntil+0x60>
8000670c:	49 38       	lddpc	r8,80006758 <vTaskDelayUntil+0x6c>
8000670e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006710:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006712:	10 37       	cp.w	r7,r8
80006714:	e0 88 00 14 	brls	8000673c <vTaskDelayUntil+0x50>
80006718:	c0 a8       	rjmp	8000672c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000671a:	0e 38       	cp.w	r8,r7
8000671c:	e0 8b 00 16 	brhi	80006748 <vTaskDelayUntil+0x5c>
80006720:	48 e8       	lddpc	r8,80006758 <vTaskDelayUntil+0x6c>
80006722:	70 08       	ld.w	r8,r8[0x0]
80006724:	10 37       	cp.w	r7,r8
80006726:	e0 8b 00 11 	brhi	80006748 <vTaskDelayUntil+0x5c>
8000672a:	c1 18       	rjmp	8000674c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000672c:	48 c8       	lddpc	r8,8000675c <vTaskDelayUntil+0x70>
8000672e:	70 0c       	ld.w	r12,r8[0x0]
80006730:	2f cc       	sub	r12,-4
80006732:	f0 1f 00 0c 	mcall	80006760 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006736:	0e 9c       	mov	r12,r7
80006738:	f0 1f 00 0b 	mcall	80006764 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
8000673c:	f0 1f 00 0b 	mcall	80006768 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006740:	c0 81       	brne	80006750 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006742:	d7 33       	scall
80006744:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006748:	8d 07       	st.w	r6[0x0],r7
8000674a:	cf 1b       	rjmp	8000672c <vTaskDelayUntil+0x40>
8000674c:	8d 07       	st.w	r6[0x0],r7
8000674e:	cf 7b       	rjmp	8000673c <vTaskDelayUntil+0x50>
80006750:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006754:	80 00       	ld.sh	r0,r0[0x0]
80006756:	61 ec       	ld.w	r12,r0[0x78]
80006758:	00 00       	add	r0,r0
8000675a:	0d 04       	ld.w	r4,r6++
8000675c:	00 00       	add	r0,r0
8000675e:	0c d8       	st.w	--r6,r8
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	59 fe       	cp.w	lr,31
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	66 90       	ld.w	r0,r3[0x24]
80006768:	80 00       	ld.sh	r0,r0[0x0]
8000676a:	65 a8       	ld.w	r8,r2[0x68]

8000676c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000676c:	eb cd 40 c0 	pushm	r6-r7,lr
80006770:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006772:	48 e7       	lddpc	r7,800067a8 <vTaskPlaceOnEventList+0x3c>
80006774:	6e 0b       	ld.w	r11,r7[0x0]
80006776:	2e 8b       	sub	r11,-24
80006778:	f0 1f 00 0d 	mcall	800067ac <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000677c:	6e 0c       	ld.w	r12,r7[0x0]
8000677e:	2f cc       	sub	r12,-4
80006780:	f0 1f 00 0c 	mcall	800067b0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006784:	5b f6       	cp.w	r6,-1
80006786:	c0 81       	brne	80006796 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006788:	6e 0b       	ld.w	r11,r7[0x0]
8000678a:	2f cb       	sub	r11,-4
8000678c:	48 ac       	lddpc	r12,800067b4 <vTaskPlaceOnEventList+0x48>
8000678e:	f0 1f 00 0b 	mcall	800067b8 <vTaskPlaceOnEventList+0x4c>
80006792:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006796:	48 a8       	lddpc	r8,800067bc <vTaskPlaceOnEventList+0x50>
80006798:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000679a:	ec 0c 00 0c 	add	r12,r6,r12
8000679e:	f0 1f 00 09 	mcall	800067c0 <vTaskPlaceOnEventList+0x54>
800067a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067a6:	00 00       	add	r0,r0
800067a8:	00 00       	add	r0,r0
800067aa:	0c d8       	st.w	--r6,r8
800067ac:	80 00       	ld.sh	r0,r0[0x0]
800067ae:	59 ca       	cp.w	r10,28
800067b0:	80 00       	ld.sh	r0,r0[0x0]
800067b2:	59 fe       	cp.w	lr,31
800067b4:	00 00       	add	r0,r0
800067b6:	0d 2c       	ld.uh	r12,r6++
800067b8:	80 00       	ld.sh	r0,r0[0x0]
800067ba:	59 ae       	cp.w	lr,26
800067bc:	00 00       	add	r0,r0
800067be:	0d 04       	ld.w	r4,r6++
800067c0:	80 00       	ld.sh	r0,r0[0x0]
800067c2:	66 90       	ld.w	r0,r3[0x24]

800067c4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800067c4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800067c8:	49 67       	lddpc	r7,80006820 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800067ca:	49 74       	lddpc	r4,80006824 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800067cc:	49 73       	lddpc	r3,80006828 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800067ce:	49 85       	lddpc	r5,8000682c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800067d0:	6e 08       	ld.w	r8,r7[0x0]
800067d2:	58 08       	cp.w	r8,0
800067d4:	c1 e0       	breq	80006810 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800067d6:	f0 1f 00 17 	mcall	80006830 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800067da:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800067dc:	f0 1f 00 16 	mcall	80006834 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800067e0:	58 06       	cp.w	r6,0
800067e2:	c1 70       	breq	80006810 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800067e4:	f0 1f 00 15 	mcall	80006838 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800067e8:	68 38       	ld.w	r8,r4[0xc]
800067ea:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800067ec:	ec cc ff fc 	sub	r12,r6,-4
800067f0:	f0 1f 00 13 	mcall	8000683c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800067f4:	66 08       	ld.w	r8,r3[0x0]
800067f6:	20 18       	sub	r8,1
800067f8:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800067fa:	6e 08       	ld.w	r8,r7[0x0]
800067fc:	20 18       	sub	r8,1
800067fe:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006800:	f0 1f 00 10 	mcall	80006840 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006804:	6c cc       	ld.w	r12,r6[0x30]
80006806:	f0 1f 00 10 	mcall	80006844 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000680a:	0c 9c       	mov	r12,r6
8000680c:	f0 1f 00 0e 	mcall	80006844 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006810:	6a 08       	ld.w	r8,r5[0x0]
80006812:	58 18       	cp.w	r8,1
80006814:	e0 88 00 03 	brls	8000681a <prvIdleTask+0x56>
			{
				taskYIELD();
80006818:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000681a:	f0 1f 00 0c 	mcall	80006848 <prvIdleTask+0x84>
		}
		#endif
	}
8000681e:	cd 9b       	rjmp	800067d0 <prvIdleTask+0xc>
80006820:	00 00       	add	r0,r0
80006822:	0c 18       	sub	r8,r6
80006824:	00 00       	add	r0,r0
80006826:	0c c4       	st.b	r6++,r4
80006828:	00 00       	add	r0,r0
8000682a:	0d 24       	ld.uh	r4,r6++
8000682c:	00 00       	add	r0,r0
8000682e:	0c 24       	rsub	r4,r6
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	61 ec       	ld.w	r12,r0[0x78]
80006834:	80 00       	ld.sh	r0,r0[0x0]
80006836:	65 a8       	ld.w	r8,r2[0x68]
80006838:	80 00       	ld.sh	r0,r0[0x0]
8000683a:	5a b8       	cp.w	r8,-21
8000683c:	80 00       	ld.sh	r0,r0[0x0]
8000683e:	59 fe       	cp.w	lr,31
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	5b c4       	cp.w	r4,-4
80006844:	80 00       	ld.sh	r0,r0[0x0]
80006846:	5c fc       	rol	r12
80006848:	80 00       	ld.sh	r0,r0[0x0]
8000684a:	20 2c       	sub	r12,2

8000684c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
8000684c:	d4 31       	pushm	r0-r7,lr
8000684e:	20 1d       	sub	sp,4
80006850:	fa c4 ff d8 	sub	r4,sp,-40
80006854:	50 0c       	stdsp	sp[0x0],r12
80006856:	16 91       	mov	r1,r11
80006858:	14 97       	mov	r7,r10
8000685a:	12 90       	mov	r0,r9
8000685c:	10 93       	mov	r3,r8
8000685e:	68 02       	ld.w	r2,r4[0x0]
80006860:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006862:	34 8c       	mov	r12,72
80006864:	f0 1f 00 5c 	mcall	800069d4 <xTaskGenericCreate+0x188>
80006868:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000686a:	c0 31       	brne	80006870 <xTaskGenericCreate+0x24>
8000686c:	3f fc       	mov	r12,-1
8000686e:	ca f8       	rjmp	800069cc <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006870:	58 06       	cp.w	r6,0
80006872:	e0 81 00 af 	brne	800069d0 <xTaskGenericCreate+0x184>
80006876:	0e 9c       	mov	r12,r7
80006878:	5c 7c       	castu.h	r12
8000687a:	a3 6c       	lsl	r12,0x2
8000687c:	f0 1f 00 56 	mcall	800069d4 <xTaskGenericCreate+0x188>
80006880:	18 96       	mov	r6,r12
80006882:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006884:	c0 61       	brne	80006890 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006886:	0a 9c       	mov	r12,r5
80006888:	f0 1f 00 54 	mcall	800069d8 <xTaskGenericCreate+0x18c>
8000688c:	3f fc       	mov	r12,-1
8000688e:	c9 f8       	rjmp	800069cc <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006890:	5c 77       	castu.h	r7
80006892:	ee 0a 15 02 	lsl	r10,r7,0x2
80006896:	e0 6b 00 a5 	mov	r11,165
8000689a:	0c 9c       	mov	r12,r6
8000689c:	f0 1f 00 50 	mcall	800069dc <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800068a0:	ee c6 00 01 	sub	r6,r7,1
800068a4:	6a c8       	ld.w	r8,r5[0x30]
800068a6:	f0 06 00 26 	add	r6,r8,r6<<0x2
800068aa:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800068ae:	31 0a       	mov	r10,16
800068b0:	02 9b       	mov	r11,r1
800068b2:	ea cc ff cc 	sub	r12,r5,-52
800068b6:	f0 1f 00 4b 	mcall	800069e0 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800068ba:	30 08       	mov	r8,0
800068bc:	eb 68 00 43 	st.b	r5[67],r8
800068c0:	58 73       	cp.w	r3,7
800068c2:	e6 07 17 80 	movls	r7,r3
800068c6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800068ca:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800068cc:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800068d0:	ea c4 ff fc 	sub	r4,r5,-4
800068d4:	08 9c       	mov	r12,r4
800068d6:	f0 1f 00 44 	mcall	800069e4 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800068da:	ea cc ff e8 	sub	r12,r5,-24
800068de:	f0 1f 00 42 	mcall	800069e4 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800068e2:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800068e4:	ee 07 11 08 	rsub	r7,r7,8
800068e8:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800068ea:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800068ec:	00 9a       	mov	r10,r0
800068ee:	40 0b       	lddsp	r11,sp[0x0]
800068f0:	0c 9c       	mov	r12,r6
800068f2:	f0 1f 00 3e 	mcall	800069e8 <xTaskGenericCreate+0x19c>
800068f6:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800068f8:	58 02       	cp.w	r2,0
800068fa:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800068fe:	f0 1f 00 3c 	mcall	800069ec <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006902:	4b c8       	lddpc	r8,800069f0 <xTaskGenericCreate+0x1a4>
80006904:	70 09       	ld.w	r9,r8[0x0]
80006906:	2f f9       	sub	r9,-1
80006908:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000690a:	4b b8       	lddpc	r8,800069f4 <xTaskGenericCreate+0x1a8>
8000690c:	70 08       	ld.w	r8,r8[0x0]
8000690e:	58 08       	cp.w	r8,0
80006910:	c2 61       	brne	8000695c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006912:	4b 98       	lddpc	r8,800069f4 <xTaskGenericCreate+0x1a8>
80006914:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006916:	4b 78       	lddpc	r8,800069f0 <xTaskGenericCreate+0x1a4>
80006918:	70 08       	ld.w	r8,r8[0x0]
8000691a:	58 18       	cp.w	r8,1
8000691c:	c2 b1       	brne	80006972 <xTaskGenericCreate+0x126>
8000691e:	4b 77       	lddpc	r7,800069f8 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006920:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006924:	0e 9c       	mov	r12,r7
80006926:	f0 1f 00 36 	mcall	800069fc <xTaskGenericCreate+0x1b0>
8000692a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000692c:	0c 37       	cp.w	r7,r6
8000692e:	cf b1       	brne	80006924 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006930:	4b 47       	lddpc	r7,80006a00 <xTaskGenericCreate+0x1b4>
80006932:	0e 9c       	mov	r12,r7
80006934:	f0 1f 00 32 	mcall	800069fc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006938:	4b 36       	lddpc	r6,80006a04 <xTaskGenericCreate+0x1b8>
8000693a:	0c 9c       	mov	r12,r6
8000693c:	f0 1f 00 30 	mcall	800069fc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006940:	4b 2c       	lddpc	r12,80006a08 <xTaskGenericCreate+0x1bc>
80006942:	f0 1f 00 2f 	mcall	800069fc <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006946:	4b 2c       	lddpc	r12,80006a0c <xTaskGenericCreate+0x1c0>
80006948:	f0 1f 00 2d 	mcall	800069fc <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000694c:	4b 1c       	lddpc	r12,80006a10 <xTaskGenericCreate+0x1c4>
8000694e:	f0 1f 00 2c 	mcall	800069fc <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006952:	4b 18       	lddpc	r8,80006a14 <xTaskGenericCreate+0x1c8>
80006954:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006956:	4b 18       	lddpc	r8,80006a18 <xTaskGenericCreate+0x1cc>
80006958:	91 06       	st.w	r8[0x0],r6
8000695a:	c0 c8       	rjmp	80006972 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
8000695c:	4b 08       	lddpc	r8,80006a1c <xTaskGenericCreate+0x1d0>
8000695e:	70 08       	ld.w	r8,r8[0x0]
80006960:	58 08       	cp.w	r8,0
80006962:	c0 81       	brne	80006972 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006964:	4a 48       	lddpc	r8,800069f4 <xTaskGenericCreate+0x1a8>
80006966:	70 08       	ld.w	r8,r8[0x0]
80006968:	70 b8       	ld.w	r8,r8[0x2c]
8000696a:	10 33       	cp.w	r3,r8
8000696c:	c0 33       	brcs	80006972 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
8000696e:	4a 28       	lddpc	r8,800069f4 <xTaskGenericCreate+0x1a8>
80006970:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006972:	6a b8       	ld.w	r8,r5[0x2c]
80006974:	4a b9       	lddpc	r9,80006a20 <xTaskGenericCreate+0x1d4>
80006976:	72 09       	ld.w	r9,r9[0x0]
80006978:	12 38       	cp.w	r8,r9
8000697a:	e0 88 00 04 	brls	80006982 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000697e:	4a 99       	lddpc	r9,80006a20 <xTaskGenericCreate+0x1d4>
80006980:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006982:	4a 98       	lddpc	r8,80006a24 <xTaskGenericCreate+0x1d8>
80006984:	70 09       	ld.w	r9,r8[0x0]
80006986:	2f f9       	sub	r9,-1
80006988:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000698a:	6a b8       	ld.w	r8,r5[0x2c]
8000698c:	4a 79       	lddpc	r9,80006a28 <xTaskGenericCreate+0x1dc>
8000698e:	72 09       	ld.w	r9,r9[0x0]
80006990:	12 38       	cp.w	r8,r9
80006992:	e0 88 00 04 	brls	8000699a <xTaskGenericCreate+0x14e>
80006996:	4a 59       	lddpc	r9,80006a28 <xTaskGenericCreate+0x1dc>
80006998:	93 08       	st.w	r9[0x0],r8
8000699a:	6a bc       	ld.w	r12,r5[0x2c]
8000699c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800069a0:	08 9b       	mov	r11,r4
800069a2:	49 68       	lddpc	r8,800069f8 <xTaskGenericCreate+0x1ac>
800069a4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800069a8:	f0 1f 00 21 	mcall	80006a2c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800069ac:	f0 1f 00 21 	mcall	80006a30 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800069b0:	49 b8       	lddpc	r8,80006a1c <xTaskGenericCreate+0x1d0>
800069b2:	70 08       	ld.w	r8,r8[0x0]
800069b4:	58 08       	cp.w	r8,0
800069b6:	c0 a0       	breq	800069ca <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800069b8:	48 f8       	lddpc	r8,800069f4 <xTaskGenericCreate+0x1a8>
800069ba:	70 08       	ld.w	r8,r8[0x0]
800069bc:	70 b8       	ld.w	r8,r8[0x2c]
800069be:	10 33       	cp.w	r3,r8
800069c0:	e0 88 00 05 	brls	800069ca <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800069c4:	d7 33       	scall
800069c6:	30 1c       	mov	r12,1
800069c8:	c0 28       	rjmp	800069cc <xTaskGenericCreate+0x180>
800069ca:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800069cc:	2f fd       	sub	sp,-4
800069ce:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800069d0:	99 c6       	st.w	r12[0x30],r6
800069d2:	c5 fb       	rjmp	80006890 <xTaskGenericCreate+0x44>
800069d4:	80 00       	ld.sh	r0,r0[0x0]
800069d6:	5d 24       	mustr	r4
800069d8:	80 00       	ld.sh	r0,r0[0x0]
800069da:	5c fc       	rol	r12
800069dc:	80 00       	ld.sh	r0,r0[0x0]
800069de:	76 12       	ld.w	r2,r11[0x4]
800069e0:	80 00       	ld.sh	r0,r0[0x0]
800069e2:	79 3c       	ld.w	r12,r12[0x4c]
800069e4:	80 00       	ld.sh	r0,r0[0x0]
800069e6:	59 a8       	cp.w	r8,26
800069e8:	80 00       	ld.sh	r0,r0[0x0]
800069ea:	5a 24       	cp.w	r4,-30
800069ec:	80 00       	ld.sh	r0,r0[0x0]
800069ee:	5a b8       	cp.w	r8,-21
800069f0:	00 00       	add	r0,r0
800069f2:	0d 24       	ld.uh	r4,r6++
800069f4:	00 00       	add	r0,r0
800069f6:	0c d8       	st.w	--r6,r8
800069f8:	00 00       	add	r0,r0
800069fa:	0c 24       	rsub	r4,r6
800069fc:	80 00       	ld.sh	r0,r0[0x0]
800069fe:	59 94       	cp.w	r4,25
80006a00:	00 00       	add	r0,r0
80006a02:	0c f0       	st.b	--r6,r0
80006a04:	00 00       	add	r0,r0
80006a06:	0d 0c       	ld.w	r12,r6++
80006a08:	00 00       	add	r0,r0
80006a0a:	0c dc       	st.w	--r6,r12
80006a0c:	00 00       	add	r0,r0
80006a0e:	0c c4       	st.b	r6++,r4
80006a10:	00 00       	add	r0,r0
80006a12:	0d 2c       	ld.uh	r12,r6++
80006a14:	00 00       	add	r0,r0
80006a16:	0c 10       	sub	r0,r6
80006a18:	00 00       	add	r0,r0
80006a1a:	0c 20       	rsub	r0,r6
80006a1c:	00 00       	add	r0,r0
80006a1e:	0c 14       	sub	r4,r6
80006a20:	00 00       	add	r0,r0
80006a22:	0c 0c       	add	r12,r6
80006a24:	00 00       	add	r0,r0
80006a26:	0d 20       	ld.uh	r0,r6++
80006a28:	00 00       	add	r0,r0
80006a2a:	0d 40       	ld.w	r0,--r6
80006a2c:	80 00       	ld.sh	r0,r0[0x0]
80006a2e:	59 ae       	cp.w	lr,26
80006a30:	80 00       	ld.sh	r0,r0[0x0]
80006a32:	5b c4       	cp.w	r4,-4

80006a34 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006a34:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006a36:	30 09       	mov	r9,0
80006a38:	1a d9       	st.w	--sp,r9
80006a3a:	1a d9       	st.w	--sp,r9
80006a3c:	1a d9       	st.w	--sp,r9
80006a3e:	12 98       	mov	r8,r9
80006a40:	e0 6a 01 00 	mov	r10,256
80006a44:	48 9b       	lddpc	r11,80006a68 <vTaskStartScheduler+0x34>
80006a46:	48 ac       	lddpc	r12,80006a6c <vTaskStartScheduler+0x38>
80006a48:	f0 1f 00 0a 	mcall	80006a70 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006a4c:	2f dd       	sub	sp,-12
80006a4e:	58 1c       	cp.w	r12,1
80006a50:	c0 a1       	brne	80006a64 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006a52:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006a54:	30 19       	mov	r9,1
80006a56:	48 88       	lddpc	r8,80006a74 <vTaskStartScheduler+0x40>
80006a58:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006a5a:	30 09       	mov	r9,0
80006a5c:	48 78       	lddpc	r8,80006a78 <vTaskStartScheduler+0x44>
80006a5e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006a60:	f0 1f 00 07 	mcall	80006a7c <vTaskStartScheduler+0x48>
80006a64:	d8 02       	popm	pc
80006a66:	00 00       	add	r0,r0
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	db 0c       	*unknown*
80006a6c:	80 00       	ld.sh	r0,r0[0x0]
80006a6e:	67 c4       	ld.w	r4,r3[0x70]
80006a70:	80 00       	ld.sh	r0,r0[0x0]
80006a72:	68 4c       	ld.w	r12,r4[0x10]
80006a74:	00 00       	add	r0,r0
80006a76:	0c 14       	sub	r4,r6
80006a78:	00 00       	add	r0,r0
80006a7a:	0d 04       	ld.w	r4,r6++
80006a7c:	80 00       	ld.sh	r0,r0[0x0]
80006a7e:	5a c8       	cp.w	r8,-20

80006a80 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006a80:	16 cc       	st.b	r11++,r12
	return str;
}
80006a82:	5e fb       	retal	r11

80006a84 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006a84:	eb cd 40 c0 	pushm	r6-r7,lr
80006a88:	20 3d       	sub	sp,12
80006a8a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006a8c:	30 06       	mov	r6,0
80006a8e:	30 07       	mov	r7,0
80006a90:	fa e7 00 00 	st.d	sp[0],r6
80006a94:	30 0c       	mov	r12,0
80006a96:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006a98:	58 08       	cp.w	r8,0
80006a9a:	c1 30       	breq	80006ac0 <PrintHex+0x3c>
80006a9c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006a9e:	1a 9c       	mov	r12,sp
80006aa0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006aa4:	58 9e       	cp.w	lr,9
80006aa6:	e0 8a 00 04 	brle	80006aae <PrintHex+0x2a>
80006aaa:	2c 9e       	sub	lr,-55
80006aac:	c0 48       	rjmp	80006ab4 <PrintHex+0x30>
80006aae:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006ab2:	2d 0e       	sub	lr,-48
80006ab4:	f8 09 0b 0e 	st.b	r12[r9],lr
80006ab8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006aba:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006abc:	cf 21       	brne	80006aa0 <PrintHex+0x1c>
80006abe:	c0 48       	rjmp	80006ac6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006ac0:	33 08       	mov	r8,48
80006ac2:	ba 88       	st.b	sp[0x0],r8
80006ac4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006ac6:	f6 09 01 08 	sub	r8,r11,r9
80006aca:	58 08       	cp.w	r8,0
80006acc:	e0 8a 00 13 	brle	80006af2 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006ad0:	12 1b       	sub	r11,r9
80006ad2:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006ad6:	18 9e       	mov	lr,r12
80006ad8:	58 0c       	cp.w	r12,0
80006ada:	e0 8a 00 0c 	brle	80006af2 <PrintHex+0x6e>
80006ade:	1a 9b       	mov	r11,sp
80006ae0:	12 0b       	add	r11,r9
80006ae2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006ae4:	33 07       	mov	r7,48
80006ae6:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006ae8:	2f f8       	sub	r8,-1
80006aea:	1c 38       	cp.w	r8,lr
80006aec:	cf d5       	brlt	80006ae6 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006aee:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006af2:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006af6:	f0 cb ff ff 	sub	r11,r8,-1
80006afa:	58 0b       	cp.w	r11,0
80006afc:	e0 8a 00 19 	brle	80006b2e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006b00:	fa cb ff f4 	sub	r11,sp,-12
80006b04:	f6 09 00 09 	add	r9,r11,r9
80006b08:	37 8b       	mov	r11,120
80006b0a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006b0e:	fa c9 ff f4 	sub	r9,sp,-12
80006b12:	10 09       	add	r9,r8
80006b14:	33 0b       	mov	r11,48
80006b16:	f3 6b ff f4 	st.b	r9[-12],r11
80006b1a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006b1e:	fa ce 00 01 	sub	lr,sp,1
80006b22:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006b24:	11 8b       	ld.ub	r11,r8[0x0]
80006b26:	12 cb       	st.b	r9++,r11
80006b28:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006b2a:	1c 38       	cp.w	r8,lr
80006b2c:	cf c1       	brne	80006b24 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006b2e:	14 9c       	mov	r12,r10
80006b30:	2f dd       	sub	sp,-12
80006b32:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006b36 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006b36:	d4 21       	pushm	r4-r7,lr
80006b38:	20 3d       	sub	sp,12
80006b3a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006b3c:	30 06       	mov	r6,0
80006b3e:	30 07       	mov	r7,0
80006b40:	fa e7 00 00 	st.d	sp[0],r6
80006b44:	30 0c       	mov	r12,0
80006b46:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006b48:	58 08       	cp.w	r8,0
80006b4a:	c0 35       	brlt	80006b50 <PrintDec+0x1a>
80006b4c:	14 97       	mov	r7,r10
80006b4e:	c0 58       	rjmp	80006b58 <PrintDec+0x22>
	{
		*p++ = '-';
80006b50:	14 97       	mov	r7,r10
80006b52:	32 d9       	mov	r9,45
80006b54:	0e c9       	st.b	r7++,r9
		i = -i;
80006b56:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006b58:	58 08       	cp.w	r8,0
80006b5a:	c0 51       	brne	80006b64 <PrintDec+0x2e>
80006b5c:	33 08       	mov	r8,48
80006b5e:	ba 88       	st.b	sp[0x0],r8
80006b60:	30 1e       	mov	lr,1
80006b62:	c2 f8       	rjmp	80006bc0 <PrintDec+0x8a>
	
	int ten = i%10;
80006b64:	e0 65 66 67 	mov	r5,26215
80006b68:	ea 15 66 66 	orh	r5,0x6666
80006b6c:	f0 05 04 44 	muls.d	r4,r8,r5
80006b70:	ea 0c 14 02 	asr	r12,r5,0x2
80006b74:	f0 09 14 1f 	asr	r9,r8,0x1f
80006b78:	f8 09 01 09 	sub	r9,r12,r9
80006b7c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006b80:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006b84:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006b86:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006b88:	e0 66 66 67 	mov	r6,26215
80006b8c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006b90:	2d 09       	sub	r9,-48
80006b92:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006b96:	2f fe       	sub	lr,-1
		i /= 10;
80006b98:	f0 06 04 44 	muls.d	r4,r8,r6
80006b9c:	ea 09 14 02 	asr	r9,r5,0x2
80006ba0:	bf 58       	asr	r8,0x1f
80006ba2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006ba6:	f0 06 04 44 	muls.d	r4,r8,r6
80006baa:	ea 09 14 02 	asr	r9,r5,0x2
80006bae:	f0 05 14 1f 	asr	r5,r8,0x1f
80006bb2:	0a 19       	sub	r9,r5
80006bb4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006bb8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006bbc:	58 08       	cp.w	r8,0
80006bbe:	ce 91       	brne	80006b90 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006bc0:	f6 0e 01 08 	sub	r8,r11,lr
80006bc4:	58 08       	cp.w	r8,0
80006bc6:	e0 89 00 06 	brgt	80006bd2 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006bca:	58 0e       	cp.w	lr,0
80006bcc:	e0 89 00 14 	brgt	80006bf4 <PrintDec+0xbe>
80006bd0:	c1 d8       	rjmp	80006c0a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006bd2:	1c 1b       	sub	r11,lr
80006bd4:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006bd6:	16 9c       	mov	r12,r11
80006bd8:	58 0b       	cp.w	r11,0
80006bda:	fe 9a ff f8 	brle	80006bca <PrintDec+0x94>
80006bde:	1a 99       	mov	r9,sp
80006be0:	1c 09       	add	r9,lr
80006be2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006be4:	33 06       	mov	r6,48
80006be6:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006be8:	2f f8       	sub	r8,-1
80006bea:	18 38       	cp.w	r8,r12
80006bec:	cf d5       	brlt	80006be6 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006bee:	f6 0e 00 0e 	add	lr,r11,lr
80006bf2:	ce cb       	rjmp	80006bca <PrintDec+0x94>
80006bf4:	fa c8 ff f4 	sub	r8,sp,-12
80006bf8:	1c 08       	add	r8,lr
80006bfa:	20 d8       	sub	r8,13
80006bfc:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006c00:	11 89       	ld.ub	r9,r8[0x0]
80006c02:	0e c9       	st.b	r7++,r9
80006c04:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006c06:	16 38       	cp.w	r8,r11
80006c08:	cf c1       	brne	80006c00 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006c0a:	14 9c       	mov	r12,r10
80006c0c:	2f dd       	sub	sp,-12
80006c0e:	d8 22       	popm	r4-r7,pc

80006c10 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006c10:	d4 31       	pushm	r0-r7,lr
80006c12:	fa cd 02 08 	sub	sp,sp,520
80006c16:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006c18:	e0 6a 01 00 	mov	r10,256
80006c1c:	30 0b       	mov	r11,0
80006c1e:	fa cc fe f8 	sub	r12,sp,-264
80006c22:	f0 1f 00 4e 	mcall	80006d58 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006c26:	fa c4 fd d4 	sub	r4,sp,-556
80006c2a:	30 0a       	mov	r10,0
80006c2c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006c2e:	fa c3 ff fc 	sub	r3,sp,-4
80006c32:	e0 61 01 00 	mov	r1,256
80006c36:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006c38:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006c3a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006c3e:	02 9a       	mov	r10,r1
80006c40:	00 9b       	mov	r11,r0
80006c42:	06 9c       	mov	r12,r3
80006c44:	f0 1f 00 45 	mcall	80006d58 <log+0x148>
			
					if(*str == '%')
80006c48:	0f 88       	ld.ub	r8,r7[0x0]
80006c4a:	e4 08 18 00 	cp.b	r8,r2
80006c4e:	c5 71       	brne	80006cfc <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006c50:	ee c8 ff ff 	sub	r8,r7,-1
80006c54:	11 89       	ld.ub	r9,r8[0x0]
80006c56:	4c 2a       	lddpc	r10,80006d5c <log+0x14c>
80006c58:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006c5a:	23 09       	sub	r9,48
80006c5c:	30 9a       	mov	r10,9
80006c5e:	f4 09 18 00 	cp.b	r9,r10
80006c62:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006c66:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006c6a:	f7 b9 08 30 	subls	r9,48
80006c6e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006c72:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006c76:	0f 88       	ld.ub	r8,r7[0x0]
80006c78:	22 58       	sub	r8,37
80006c7a:	e0 48 00 53 	cp.w	r8,83
80006c7e:	e0 8b 00 31 	brhi	80006ce0 <log+0xd0>
80006c82:	4b 89       	lddpc	r9,80006d60 <log+0x150>
80006c84:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006c88:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006c8c:	06 9a       	mov	r10,r3
80006c8e:	40 0b       	lddsp	r11,sp[0x0]
80006c90:	5c 5b       	castu.b	r11
80006c92:	68 0c       	ld.w	r12,r4[0x0]
80006c94:	f0 1f 00 34 	mcall	80006d64 <log+0x154>
							break;
80006c98:	c2 98       	rjmp	80006cea <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006c9a:	4b 4c       	lddpc	r12,80006d68 <log+0x158>
80006c9c:	f0 1f 00 34 	mcall	80006d6c <log+0x15c>
80006ca0:	08 95       	mov	r5,r4
80006ca2:	06 9c       	mov	r12,r3
							break;
80006ca4:	c2 38       	rjmp	80006cea <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006ca6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006caa:	06 9a       	mov	r10,r3
80006cac:	40 0b       	lddsp	r11,sp[0x0]
80006cae:	5c 5b       	castu.b	r11
80006cb0:	68 0c       	ld.w	r12,r4[0x0]
80006cb2:	f0 1f 00 30 	mcall	80006d70 <log+0x160>
80006cb6:	06 9c       	mov	r12,r3
							break;
80006cb8:	c1 98       	rjmp	80006cea <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006cba:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006cbe:	06 9b       	mov	r11,r3
80006cc0:	09 bc       	ld.ub	r12,r4[0x3]
80006cc2:	f0 1f 00 2d 	mcall	80006d74 <log+0x164>
80006cc6:	06 9c       	mov	r12,r3
							break;
80006cc8:	c1 18       	rjmp	80006cea <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006cca:	e8 c5 ff fc 	sub	r5,r4,-4
80006cce:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006cd0:	c0 d8       	rjmp	80006cea <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006cd2:	06 9b       	mov	r11,r3
80006cd4:	32 5c       	mov	r12,37
80006cd6:	f0 1f 00 28 	mcall	80006d74 <log+0x164>
80006cda:	08 95       	mov	r5,r4
80006cdc:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006cde:	c0 68       	rjmp	80006cea <log+0xda>
							
							default:
							log("I need relax.");
80006ce0:	4a 6c       	lddpc	r12,80006d78 <log+0x168>
80006ce2:	f0 1f 00 23 	mcall	80006d6c <log+0x15c>
80006ce6:	08 95       	mov	r5,r4
80006ce8:	06 9c       	mov	r12,r3
						}
						str++;
80006cea:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006cec:	1a dc       	st.w	--sp,r12
80006cee:	1a d6       	st.w	--sp,r6
80006cf0:	4a 3b       	lddpc	r11,80006d7c <log+0x16c>
80006cf2:	0c 9c       	mov	r12,r6
80006cf4:	f0 1f 00 23 	mcall	80006d80 <log+0x170>
80006cf8:	2f ed       	sub	sp,-8
80006cfa:	c0 a8       	rjmp	80006d0e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006cfc:	2f f7       	sub	r7,-1
80006cfe:	1a d8       	st.w	--sp,r8
80006d00:	1a d6       	st.w	--sp,r6
80006d02:	4a 1b       	lddpc	r11,80006d84 <log+0x174>
80006d04:	0c 9c       	mov	r12,r6
80006d06:	f0 1f 00 1f 	mcall	80006d80 <log+0x170>
80006d0a:	08 95       	mov	r5,r4
80006d0c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006d0e:	0f 89       	ld.ub	r9,r7[0x0]
80006d10:	30 08       	mov	r8,0
80006d12:	f0 09 18 00 	cp.b	r9,r8
80006d16:	c0 30       	breq	80006d1c <log+0x10c>
80006d18:	0a 94       	mov	r4,r5
80006d1a:	c9 2b       	rjmp	80006c3e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006d1c:	fa c7 fe f8 	sub	r7,sp,-264
80006d20:	1a d7       	st.w	--sp,r7
80006d22:	49 ab       	lddpc	r11,80006d88 <log+0x178>
80006d24:	0e 9c       	mov	r12,r7
80006d26:	f0 1f 00 17 	mcall	80006d80 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006d2a:	5c 5c       	castu.b	r12
80006d2c:	f8 c6 ff ff 	sub	r6,r12,-1
80006d30:	0c 9c       	mov	r12,r6
80006d32:	f0 1f 00 17 	mcall	80006d8c <log+0x17c>
80006d36:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006d38:	0c 9a       	mov	r10,r6
80006d3a:	0e 9b       	mov	r11,r7
80006d3c:	f0 1f 00 15 	mcall	80006d90 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006d40:	30 09       	mov	r9,0
80006d42:	30 5a       	mov	r10,5
80006d44:	fa cb fe f8 	sub	r11,sp,-264
80006d48:	49 38       	lddpc	r8,80006d94 <log+0x184>
80006d4a:	70 0c       	ld.w	r12,r8[0x0]
80006d4c:	f0 1f 00 13 	mcall	80006d98 <log+0x188>
80006d50:	2f fd       	sub	sp,-4
	
	
}
80006d52:	fe 3d fd f8 	sub	sp,-520
80006d56:	d8 32       	popm	r0-r7,pc
80006d58:	80 00       	ld.sh	r0,r0[0x0]
80006d5a:	76 12       	ld.w	r2,r11[0x4]
80006d5c:	00 00       	add	r0,r0
80006d5e:	0d 44       	ld.w	r4,--r6
80006d60:	80 00       	ld.sh	r0,r0[0x0]
80006d62:	db 14       	*unknown*
80006d64:	80 00       	ld.sh	r0,r0[0x0]
80006d66:	6b 36       	ld.w	r6,r5[0x4c]
80006d68:	80 00       	ld.sh	r0,r0[0x0]
80006d6a:	dd c0       	acall	0xdc
80006d6c:	80 00       	ld.sh	r0,r0[0x0]
80006d6e:	6c 10       	ld.w	r0,r6[0x4]
80006d70:	80 00       	ld.sh	r0,r0[0x0]
80006d72:	6a 84       	ld.w	r4,r5[0x20]
80006d74:	80 00       	ld.sh	r0,r0[0x0]
80006d76:	6a 80       	ld.w	r0,r5[0x20]
80006d78:	80 00       	ld.sh	r0,r0[0x0]
80006d7a:	dd d0       	acall	0xdd
80006d7c:	80 00       	ld.sh	r0,r0[0x0]
80006d7e:	dd e0       	acall	0xde
80006d80:	80 00       	ld.sh	r0,r0[0x0]
80006d82:	79 00       	ld.w	r0,r12[0x40]
80006d84:	80 00       	ld.sh	r0,r0[0x0]
80006d86:	dd e8       	*unknown*
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	dd f0       	acall	0xdf
80006d8c:	80 00       	ld.sh	r0,r0[0x0]
80006d8e:	5d 24       	mustr	r4
80006d90:	80 00       	ld.sh	r0,r0[0x0]
80006d92:	74 ca       	ld.w	r10,r10[0x30]
80006d94:	00 00       	add	r0,r0
80006d96:	63 90       	ld.w	r0,r1[0x64]
80006d98:	80 00       	ld.sh	r0,r0[0x0]
80006d9a:	60 78       	ld.w	r8,r0[0x1c]

80006d9c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006d9c:	d4 31       	pushm	r0-r7,lr
80006d9e:	fa cd 02 0c 	sub	sp,sp,524
80006da2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006da4:	e0 6a 01 00 	mov	r10,256
80006da8:	30 0b       	mov	r11,0
80006daa:	fa cc fe f4 	sub	r12,sp,-268
80006dae:	f0 1f 00 4c 	mcall	80006edc <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006db2:	fa c4 fd d0 	sub	r4,sp,-560
80006db6:	30 0a       	mov	r10,0
80006db8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006dba:	fa c3 ff fc 	sub	r3,sp,-4
80006dbe:	e0 61 01 00 	mov	r1,256
80006dc2:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006dc4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006dc6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006dca:	02 9a       	mov	r10,r1
80006dcc:	00 9b       	mov	r11,r0
80006dce:	06 9c       	mov	r12,r3
80006dd0:	f0 1f 00 43 	mcall	80006edc <logFromISR+0x140>
			
			if(*str == '%')
80006dd4:	0f 88       	ld.ub	r8,r7[0x0]
80006dd6:	e4 08 18 00 	cp.b	r8,r2
80006dda:	c5 11       	brne	80006e7c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006ddc:	ee c8 ff ff 	sub	r8,r7,-1
80006de0:	11 89       	ld.ub	r9,r8[0x0]
80006de2:	4c 0a       	lddpc	r10,80006ee0 <logFromISR+0x144>
80006de4:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006de6:	23 09       	sub	r9,48
80006de8:	30 9a       	mov	r10,9
80006dea:	f4 09 18 00 	cp.b	r9,r10
80006dee:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006df2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006df6:	f7 b9 08 30 	subls	r9,48
80006dfa:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006dfe:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006e02:	0f 88       	ld.ub	r8,r7[0x0]
80006e04:	22 58       	sub	r8,37
80006e06:	e0 48 00 53 	cp.w	r8,83
80006e0a:	e0 8b 00 2b 	brhi	80006e60 <logFromISR+0xc4>
80006e0e:	4b 69       	lddpc	r9,80006ee4 <logFromISR+0x148>
80006e10:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006e14:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006e18:	06 9a       	mov	r10,r3
80006e1a:	40 0b       	lddsp	r11,sp[0x0]
80006e1c:	5c 5b       	castu.b	r11
80006e1e:	68 0c       	ld.w	r12,r4[0x0]
80006e20:	f0 1f 00 32 	mcall	80006ee8 <logFromISR+0x14c>
					break;
80006e24:	c2 38       	rjmp	80006e6a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006e26:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006e2a:	06 9a       	mov	r10,r3
80006e2c:	40 0b       	lddsp	r11,sp[0x0]
80006e2e:	5c 5b       	castu.b	r11
80006e30:	68 0c       	ld.w	r12,r4[0x0]
80006e32:	f0 1f 00 2f 	mcall	80006eec <logFromISR+0x150>
80006e36:	06 9c       	mov	r12,r3
					break;
80006e38:	c1 98       	rjmp	80006e6a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006e3a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006e3e:	06 9b       	mov	r11,r3
80006e40:	09 bc       	ld.ub	r12,r4[0x3]
80006e42:	f0 1f 00 2c 	mcall	80006ef0 <logFromISR+0x154>
80006e46:	06 9c       	mov	r12,r3
					break;
80006e48:	c1 18       	rjmp	80006e6a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006e4a:	e8 c5 ff fc 	sub	r5,r4,-4
80006e4e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006e50:	c0 d8       	rjmp	80006e6a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006e52:	06 9b       	mov	r11,r3
80006e54:	32 5c       	mov	r12,37
80006e56:	f0 1f 00 27 	mcall	80006ef0 <logFromISR+0x154>
80006e5a:	08 95       	mov	r5,r4
80006e5c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006e5e:	c0 68       	rjmp	80006e6a <logFromISR+0xce>
					default:
					log("I need relax.");
80006e60:	4a 5c       	lddpc	r12,80006ef4 <logFromISR+0x158>
80006e62:	f0 1f 00 26 	mcall	80006ef8 <logFromISR+0x15c>
80006e66:	08 95       	mov	r5,r4
80006e68:	06 9c       	mov	r12,r3
				}
				str++;
80006e6a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006e6c:	1a dc       	st.w	--sp,r12
80006e6e:	1a d6       	st.w	--sp,r6
80006e70:	4a 3b       	lddpc	r11,80006efc <logFromISR+0x160>
80006e72:	0c 9c       	mov	r12,r6
80006e74:	f0 1f 00 23 	mcall	80006f00 <logFromISR+0x164>
80006e78:	2f ed       	sub	sp,-8
80006e7a:	c0 a8       	rjmp	80006e8e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e7c:	2f f7       	sub	r7,-1
80006e7e:	1a d8       	st.w	--sp,r8
80006e80:	1a d6       	st.w	--sp,r6
80006e82:	4a 1b       	lddpc	r11,80006f04 <logFromISR+0x168>
80006e84:	0c 9c       	mov	r12,r6
80006e86:	f0 1f 00 1f 	mcall	80006f00 <logFromISR+0x164>
80006e8a:	08 95       	mov	r5,r4
80006e8c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006e8e:	0f 89       	ld.ub	r9,r7[0x0]
80006e90:	30 08       	mov	r8,0
80006e92:	f0 09 18 00 	cp.b	r9,r8
80006e96:	c0 30       	breq	80006e9c <logFromISR+0x100>
80006e98:	0a 94       	mov	r4,r5
80006e9a:	c9 8b       	rjmp	80006dca <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006e9c:	fa c7 fe f4 	sub	r7,sp,-268
80006ea0:	1a d7       	st.w	--sp,r7
80006ea2:	49 ab       	lddpc	r11,80006f08 <logFromISR+0x16c>
80006ea4:	0e 9c       	mov	r12,r7
80006ea6:	f0 1f 00 17 	mcall	80006f00 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006eaa:	5c 5c       	castu.b	r12
80006eac:	f8 c6 ff ff 	sub	r6,r12,-1
80006eb0:	0c 9c       	mov	r12,r6
80006eb2:	f0 1f 00 17 	mcall	80006f0c <logFromISR+0x170>
80006eb6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006eb8:	0c 9a       	mov	r10,r6
80006eba:	0e 9b       	mov	r11,r7
80006ebc:	f0 1f 00 15 	mcall	80006f10 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006ec0:	30 09       	mov	r9,0
80006ec2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006ec4:	fa ca fe f8 	sub	r10,sp,-264
80006ec8:	fa cb fe f4 	sub	r11,sp,-268
80006ecc:	49 28       	lddpc	r8,80006f14 <logFromISR+0x178>
80006ece:	70 0c       	ld.w	r12,r8[0x0]
80006ed0:	f0 1f 00 12 	mcall	80006f18 <logFromISR+0x17c>
80006ed4:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006ed6:	fe 3d fd f4 	sub	sp,-524
80006eda:	d8 32       	popm	r0-r7,pc
80006edc:	80 00       	ld.sh	r0,r0[0x0]
80006ede:	76 12       	ld.w	r2,r11[0x4]
80006ee0:	00 00       	add	r0,r0
80006ee2:	0d 45       	ld.w	r5,--r6
80006ee4:	80 00       	ld.sh	r0,r0[0x0]
80006ee6:	dc 64       	*unknown*
80006ee8:	80 00       	ld.sh	r0,r0[0x0]
80006eea:	6b 36       	ld.w	r6,r5[0x4c]
80006eec:	80 00       	ld.sh	r0,r0[0x0]
80006eee:	6a 84       	ld.w	r4,r5[0x20]
80006ef0:	80 00       	ld.sh	r0,r0[0x0]
80006ef2:	6a 80       	ld.w	r0,r5[0x20]
80006ef4:	80 00       	ld.sh	r0,r0[0x0]
80006ef6:	dd d0       	acall	0xdd
80006ef8:	80 00       	ld.sh	r0,r0[0x0]
80006efa:	6c 10       	ld.w	r0,r6[0x4]
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	dd e0       	acall	0xde
80006f00:	80 00       	ld.sh	r0,r0[0x0]
80006f02:	79 00       	ld.w	r0,r12[0x40]
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	dd e8       	*unknown*
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	dd f0       	acall	0xdf
80006f0c:	80 00       	ld.sh	r0,r0[0x0]
80006f0e:	5d 24       	mustr	r4
80006f10:	80 00       	ld.sh	r0,r0[0x0]
80006f12:	74 ca       	ld.w	r10,r10[0x30]
80006f14:	00 00       	add	r0,r0
80006f16:	63 90       	ld.w	r0,r1[0x64]
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	60 28       	ld.w	r8,r0[0x8]

80006f1c <log_init>:
		
	return str;
}

void log_init(void)
{
80006f1c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006f1e:	30 2b       	mov	r11,2
80006f20:	49 0c       	lddpc	r12,80006f60 <log_init+0x44>
80006f22:	f0 1f 00 11 	mcall	80006f64 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006f26:	e0 6a 36 00 	mov	r10,13824
80006f2a:	ea 1a 01 6e 	orh	r10,0x16e
80006f2e:	48 fb       	lddpc	r11,80006f68 <log_init+0x4c>
80006f30:	fe 7c 18 00 	mov	r12,-59392
80006f34:	f0 1f 00 0e 	mcall	80006f6c <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006f38:	30 4b       	mov	r11,4
80006f3a:	33 2c       	mov	r12,50
80006f3c:	f0 1f 00 0d 	mcall	80006f70 <log_init+0x54>
80006f40:	48 d8       	lddpc	r8,80006f74 <log_init+0x58>
80006f42:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006f44:	30 09       	mov	r9,0
80006f46:	1a d9       	st.w	--sp,r9
80006f48:	1a d9       	st.w	--sp,r9
80006f4a:	1a d9       	st.w	--sp,r9
80006f4c:	30 28       	mov	r8,2
80006f4e:	e0 6a 01 80 	mov	r10,384
80006f52:	48 ab       	lddpc	r11,80006f78 <log_init+0x5c>
80006f54:	48 ac       	lddpc	r12,80006f7c <log_init+0x60>
80006f56:	f0 1f 00 0b 	mcall	80006f80 <log_init+0x64>
80006f5a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006f5c:	d8 02       	popm	pc
80006f5e:	00 00       	add	r0,r0
80006f60:	80 00       	ld.sh	r0,r0[0x0]
80006f62:	dd fc       	*unknown*
80006f64:	80 00       	ld.sh	r0,r0[0x0]
80006f66:	53 e8       	stdsp	sp[0xf8],r8
80006f68:	80 00       	ld.sh	r0,r0[0x0]
80006f6a:	dd b4       	*unknown*
80006f6c:	80 00       	ld.sh	r0,r0[0x0]
80006f6e:	58 88       	cp.w	r8,8
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	61 78       	ld.w	r8,r0[0x5c]
80006f74:	00 00       	add	r0,r0
80006f76:	63 90       	ld.w	r0,r1[0x64]
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	dd f8       	*unknown*
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	6f 84       	ld.w	r4,r7[0x60]
80006f80:	80 00       	ld.sh	r0,r0[0x0]
80006f82:	68 4c       	ld.w	r12,r4[0x10]

80006f84 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006f84:	eb cd 40 f8 	pushm	r3-r7,lr
80006f88:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006f8a:	48 c7       	lddpc	r7,80006fb8 <task_log+0x34>
80006f8c:	30 05       	mov	r5,0
80006f8e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006f90:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006f94:	0a 99       	mov	r9,r5
80006f96:	08 9a       	mov	r10,r4
80006f98:	1a 9b       	mov	r11,sp
80006f9a:	6e 0c       	ld.w	r12,r7[0x0]
80006f9c:	f0 1f 00 08 	mcall	80006fbc <task_log+0x38>
80006fa0:	58 1c       	cp.w	r12,1
80006fa2:	cf 91       	brne	80006f94 <task_log+0x10>
		{
			if( NULL != str)
80006fa4:	40 0b       	lddsp	r11,sp[0x0]
80006fa6:	58 0b       	cp.w	r11,0
80006fa8:	cf 60       	breq	80006f94 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006faa:	06 9c       	mov	r12,r3
80006fac:	f0 1f 00 05 	mcall	80006fc0 <task_log+0x3c>
				vPortFree(str);
80006fb0:	40 0c       	lddsp	r12,sp[0x0]
80006fb2:	f0 1f 00 05 	mcall	80006fc4 <task_log+0x40>
80006fb6:	ce fb       	rjmp	80006f94 <task_log+0x10>
80006fb8:	00 00       	add	r0,r0
80006fba:	63 90       	ld.w	r0,r1[0x64]
80006fbc:	80 00       	ld.sh	r0,r0[0x0]
80006fbe:	5e 6c       	retmi	r12
80006fc0:	80 00       	ld.sh	r0,r0[0x0]
80006fc2:	58 38       	cp.w	r8,3
80006fc4:	80 00       	ld.sh	r0,r0[0x0]
80006fc6:	5c fc       	rol	r12

80006fc8 <main>:
#include "voice.h"

#include "app.h"

int main (void)
{
80006fc8:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006fca:	fe 78 10 00 	mov	r8,-61440
80006fce:	30 19       	mov	r9,1
80006fd0:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006fd4:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006fd8:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006fdc:	d3 03       	ssrf	0x10
	local_start_pll0();
80006fde:	f0 1f 00 12 	mcall	80007024 <main+0x5c>
		
	INTC_init_interrupts();
80006fe2:	f0 1f 00 12 	mcall	80007028 <main+0x60>
		
	log_init();
80006fe6:	f0 1f 00 12 	mcall	8000702c <main+0x64>
	log("----start debug----");
80006fea:	49 2c       	lddpc	r12,80007030 <main+0x68>
80006fec:	f0 1f 00 12 	mcall	80007034 <main+0x6c>
		
	voc_init();
80006ff0:	f0 1f 00 12 	mcall	80007038 <main+0x70>

	//tc_init();
		
	app_init();
80006ff4:	f0 1f 00 12 	mcall	8000703c <main+0x74>
		
	xcmp_init();
80006ff8:	f0 1f 00 12 	mcall	80007040 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006ffc:	fe 79 10 00 	mov	r9,-61440
80007000:	f2 f8 01 60 	ld.w	r8,r9[352]
80007004:	e2 18 00 02 	andl	r8,0x2,COH
80007008:	cf c0       	breq	80007000 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000700a:	fe 79 10 00 	mov	r9,-61440
8000700e:	f2 f8 01 60 	ld.w	r8,r9[352]
80007012:	e2 18 00 02 	andl	r8,0x2,COH
80007016:	cf c1       	brne	8000700e <main+0x46>
	local_start_timer();
80007018:	f0 1f 00 0b 	mcall	80007044 <main+0x7c>
		
	Enable_global_interrupt();
8000701c:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
8000701e:	f0 1f 00 0b 	mcall	80007048 <main+0x80>
	return 0;
	
}
80007022:	d8 0a       	popm	pc,r12=0
80007024:	80 00       	ld.sh	r0,r0[0x0]
80007026:	4d a4       	lddpc	r4,8000718c <_malloc_r+0x120>
80007028:	80 00       	ld.sh	r0,r0[0x0]
8000702a:	54 d0       	stdsp	sp[0x134],r0
8000702c:	80 00       	ld.sh	r0,r0[0x0]
8000702e:	6f 1c       	ld.w	r12,r7[0x44]
80007030:	80 00       	ld.sh	r0,r0[0x0]
80007032:	de 0c       	*unknown*
80007034:	80 00       	ld.sh	r0,r0[0x0]
80007036:	6c 10       	ld.w	r0,r6[0x4]
80007038:	80 00       	ld.sh	r0,r0[0x0]
8000703a:	51 bc       	stdsp	sp[0x6c],r12
8000703c:	80 00       	ld.sh	r0,r0[0x0]
8000703e:	20 3c       	sub	r12,3
80007040:	80 00       	ld.sh	r0,r0[0x0]
80007042:	46 b4       	lddsp	r4,sp[0x1ac]
80007044:	80 00       	ld.sh	r0,r0[0x0]
80007046:	4d f4       	lddpc	r4,800071c0 <_malloc_r+0x154>
80007048:	80 00       	ld.sh	r0,r0[0x0]
8000704a:	6a 34       	ld.w	r4,r5[0xc]

8000704c <free>:
8000704c:	d4 01       	pushm	lr
8000704e:	e0 68 0a 38 	mov	r8,2616
80007052:	18 9b       	mov	r11,r12
80007054:	70 0c       	ld.w	r12,r8[0x0]
80007056:	e0 a0 1e 73 	rcall	8000ad3c <_free_r>
8000705a:	d8 02       	popm	pc

8000705c <malloc>:
8000705c:	d4 01       	pushm	lr
8000705e:	e0 68 0a 38 	mov	r8,2616
80007062:	18 9b       	mov	r11,r12
80007064:	70 0c       	ld.w	r12,r8[0x0]
80007066:	c0 3c       	rcall	8000706c <_malloc_r>
80007068:	d8 02       	popm	pc
8000706a:	d7 03       	nop

8000706c <_malloc_r>:
8000706c:	d4 31       	pushm	r0-r7,lr
8000706e:	f6 c8 ff f5 	sub	r8,r11,-11
80007072:	18 95       	mov	r5,r12
80007074:	10 97       	mov	r7,r8
80007076:	e0 17 ff f8 	andl	r7,0xfff8
8000707a:	59 68       	cp.w	r8,22
8000707c:	f9 b7 08 10 	movls	r7,16
80007080:	16 37       	cp.w	r7,r11
80007082:	5f 38       	srlo	r8
80007084:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007088:	c0 50       	breq	80007092 <_malloc_r+0x26>
8000708a:	30 c8       	mov	r8,12
8000708c:	99 38       	st.w	r12[0xc],r8
8000708e:	e0 8f 01 fa 	bral	80007482 <_malloc_r+0x416>
80007092:	fe b0 f5 eb 	rcall	80005c68 <__malloc_lock>
80007096:	e0 47 01 f7 	cp.w	r7,503
8000709a:	e0 8b 00 1d 	brhi	800070d4 <_malloc_r+0x68>
8000709e:	ee 03 16 03 	lsr	r3,r7,0x3
800070a2:	e0 68 05 38 	mov	r8,1336
800070a6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800070aa:	70 36       	ld.w	r6,r8[0xc]
800070ac:	10 36       	cp.w	r6,r8
800070ae:	c0 61       	brne	800070ba <_malloc_r+0x4e>
800070b0:	ec c8 ff f8 	sub	r8,r6,-8
800070b4:	70 36       	ld.w	r6,r8[0xc]
800070b6:	10 36       	cp.w	r6,r8
800070b8:	c0 c0       	breq	800070d0 <_malloc_r+0x64>
800070ba:	6c 18       	ld.w	r8,r6[0x4]
800070bc:	e0 18 ff fc 	andl	r8,0xfffc
800070c0:	6c 3a       	ld.w	r10,r6[0xc]
800070c2:	ec 08 00 09 	add	r9,r6,r8
800070c6:	0a 9c       	mov	r12,r5
800070c8:	6c 28       	ld.w	r8,r6[0x8]
800070ca:	95 28       	st.w	r10[0x8],r8
800070cc:	91 3a       	st.w	r8[0xc],r10
800070ce:	c4 78       	rjmp	8000715c <_malloc_r+0xf0>
800070d0:	2f e3       	sub	r3,-2
800070d2:	c4 d8       	rjmp	8000716c <_malloc_r+0x100>
800070d4:	ee 03 16 09 	lsr	r3,r7,0x9
800070d8:	c0 41       	brne	800070e0 <_malloc_r+0x74>
800070da:	ee 03 16 03 	lsr	r3,r7,0x3
800070de:	c2 68       	rjmp	8000712a <_malloc_r+0xbe>
800070e0:	58 43       	cp.w	r3,4
800070e2:	e0 8b 00 06 	brhi	800070ee <_malloc_r+0x82>
800070e6:	ee 03 16 06 	lsr	r3,r7,0x6
800070ea:	2c 83       	sub	r3,-56
800070ec:	c1 f8       	rjmp	8000712a <_malloc_r+0xbe>
800070ee:	59 43       	cp.w	r3,20
800070f0:	e0 8b 00 04 	brhi	800070f8 <_malloc_r+0x8c>
800070f4:	2a 53       	sub	r3,-91
800070f6:	c1 a8       	rjmp	8000712a <_malloc_r+0xbe>
800070f8:	e0 43 00 54 	cp.w	r3,84
800070fc:	e0 8b 00 06 	brhi	80007108 <_malloc_r+0x9c>
80007100:	ee 03 16 0c 	lsr	r3,r7,0xc
80007104:	29 23       	sub	r3,-110
80007106:	c1 28       	rjmp	8000712a <_malloc_r+0xbe>
80007108:	e0 43 01 54 	cp.w	r3,340
8000710c:	e0 8b 00 06 	brhi	80007118 <_malloc_r+0xac>
80007110:	ee 03 16 0f 	lsr	r3,r7,0xf
80007114:	28 93       	sub	r3,-119
80007116:	c0 a8       	rjmp	8000712a <_malloc_r+0xbe>
80007118:	e0 43 05 54 	cp.w	r3,1364
8000711c:	e0 88 00 04 	brls	80007124 <_malloc_r+0xb8>
80007120:	37 e3       	mov	r3,126
80007122:	c0 48       	rjmp	8000712a <_malloc_r+0xbe>
80007124:	ee 03 16 12 	lsr	r3,r7,0x12
80007128:	28 43       	sub	r3,-124
8000712a:	e0 6a 05 38 	mov	r10,1336
8000712e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007132:	74 36       	ld.w	r6,r10[0xc]
80007134:	c1 98       	rjmp	80007166 <_malloc_r+0xfa>
80007136:	6c 19       	ld.w	r9,r6[0x4]
80007138:	e0 19 ff fc 	andl	r9,0xfffc
8000713c:	f2 07 01 0b 	sub	r11,r9,r7
80007140:	58 fb       	cp.w	r11,15
80007142:	e0 8a 00 04 	brle	8000714a <_malloc_r+0xde>
80007146:	20 13       	sub	r3,1
80007148:	c1 18       	rjmp	8000716a <_malloc_r+0xfe>
8000714a:	6c 38       	ld.w	r8,r6[0xc]
8000714c:	58 0b       	cp.w	r11,0
8000714e:	c0 b5       	brlt	80007164 <_malloc_r+0xf8>
80007150:	6c 2a       	ld.w	r10,r6[0x8]
80007152:	ec 09 00 09 	add	r9,r6,r9
80007156:	0a 9c       	mov	r12,r5
80007158:	91 2a       	st.w	r8[0x8],r10
8000715a:	95 38       	st.w	r10[0xc],r8
8000715c:	72 18       	ld.w	r8,r9[0x4]
8000715e:	a1 a8       	sbr	r8,0x0
80007160:	93 18       	st.w	r9[0x4],r8
80007162:	cb c8       	rjmp	800072da <_malloc_r+0x26e>
80007164:	10 96       	mov	r6,r8
80007166:	14 36       	cp.w	r6,r10
80007168:	ce 71       	brne	80007136 <_malloc_r+0xca>
8000716a:	2f f3       	sub	r3,-1
8000716c:	e0 6a 05 38 	mov	r10,1336
80007170:	f4 cc ff f8 	sub	r12,r10,-8
80007174:	78 26       	ld.w	r6,r12[0x8]
80007176:	18 36       	cp.w	r6,r12
80007178:	c6 c0       	breq	80007250 <_malloc_r+0x1e4>
8000717a:	6c 19       	ld.w	r9,r6[0x4]
8000717c:	e0 19 ff fc 	andl	r9,0xfffc
80007180:	f2 07 01 08 	sub	r8,r9,r7
80007184:	58 f8       	cp.w	r8,15
80007186:	e0 89 00 8f 	brgt	800072a4 <_malloc_r+0x238>
8000718a:	99 3c       	st.w	r12[0xc],r12
8000718c:	99 2c       	st.w	r12[0x8],r12
8000718e:	58 08       	cp.w	r8,0
80007190:	c0 55       	brlt	8000719a <_malloc_r+0x12e>
80007192:	ec 09 00 09 	add	r9,r6,r9
80007196:	0a 9c       	mov	r12,r5
80007198:	ce 2b       	rjmp	8000715c <_malloc_r+0xf0>
8000719a:	e0 49 01 ff 	cp.w	r9,511
8000719e:	e0 8b 00 13 	brhi	800071c4 <_malloc_r+0x158>
800071a2:	a3 99       	lsr	r9,0x3
800071a4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800071a8:	70 2b       	ld.w	r11,r8[0x8]
800071aa:	8d 38       	st.w	r6[0xc],r8
800071ac:	8d 2b       	st.w	r6[0x8],r11
800071ae:	97 36       	st.w	r11[0xc],r6
800071b0:	91 26       	st.w	r8[0x8],r6
800071b2:	a3 49       	asr	r9,0x2
800071b4:	74 18       	ld.w	r8,r10[0x4]
800071b6:	30 1b       	mov	r11,1
800071b8:	f6 09 09 49 	lsl	r9,r11,r9
800071bc:	f1 e9 10 09 	or	r9,r8,r9
800071c0:	95 19       	st.w	r10[0x4],r9
800071c2:	c4 78       	rjmp	80007250 <_malloc_r+0x1e4>
800071c4:	f2 0a 16 09 	lsr	r10,r9,0x9
800071c8:	58 4a       	cp.w	r10,4
800071ca:	e0 8b 00 07 	brhi	800071d8 <_malloc_r+0x16c>
800071ce:	f2 0a 16 06 	lsr	r10,r9,0x6
800071d2:	2c 8a       	sub	r10,-56
800071d4:	c2 08       	rjmp	80007214 <_malloc_r+0x1a8>
800071d6:	d7 03       	nop
800071d8:	59 4a       	cp.w	r10,20
800071da:	e0 8b 00 04 	brhi	800071e2 <_malloc_r+0x176>
800071de:	2a 5a       	sub	r10,-91
800071e0:	c1 a8       	rjmp	80007214 <_malloc_r+0x1a8>
800071e2:	e0 4a 00 54 	cp.w	r10,84
800071e6:	e0 8b 00 06 	brhi	800071f2 <_malloc_r+0x186>
800071ea:	f2 0a 16 0c 	lsr	r10,r9,0xc
800071ee:	29 2a       	sub	r10,-110
800071f0:	c1 28       	rjmp	80007214 <_malloc_r+0x1a8>
800071f2:	e0 4a 01 54 	cp.w	r10,340
800071f6:	e0 8b 00 06 	brhi	80007202 <_malloc_r+0x196>
800071fa:	f2 0a 16 0f 	lsr	r10,r9,0xf
800071fe:	28 9a       	sub	r10,-119
80007200:	c0 a8       	rjmp	80007214 <_malloc_r+0x1a8>
80007202:	e0 4a 05 54 	cp.w	r10,1364
80007206:	e0 88 00 04 	brls	8000720e <_malloc_r+0x1a2>
8000720a:	37 ea       	mov	r10,126
8000720c:	c0 48       	rjmp	80007214 <_malloc_r+0x1a8>
8000720e:	f2 0a 16 12 	lsr	r10,r9,0x12
80007212:	28 4a       	sub	r10,-124
80007214:	e0 6b 05 38 	mov	r11,1336
80007218:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000721c:	68 28       	ld.w	r8,r4[0x8]
8000721e:	08 38       	cp.w	r8,r4
80007220:	c0 e1       	brne	8000723c <_malloc_r+0x1d0>
80007222:	76 19       	ld.w	r9,r11[0x4]
80007224:	a3 4a       	asr	r10,0x2
80007226:	30 1e       	mov	lr,1
80007228:	fc 0a 09 4a 	lsl	r10,lr,r10
8000722c:	f3 ea 10 0a 	or	r10,r9,r10
80007230:	10 99       	mov	r9,r8
80007232:	97 1a       	st.w	r11[0x4],r10
80007234:	c0 a8       	rjmp	80007248 <_malloc_r+0x1dc>
80007236:	70 28       	ld.w	r8,r8[0x8]
80007238:	08 38       	cp.w	r8,r4
8000723a:	c0 60       	breq	80007246 <_malloc_r+0x1da>
8000723c:	70 1a       	ld.w	r10,r8[0x4]
8000723e:	e0 1a ff fc 	andl	r10,0xfffc
80007242:	14 39       	cp.w	r9,r10
80007244:	cf 93       	brcs	80007236 <_malloc_r+0x1ca>
80007246:	70 39       	ld.w	r9,r8[0xc]
80007248:	8d 39       	st.w	r6[0xc],r9
8000724a:	8d 28       	st.w	r6[0x8],r8
8000724c:	91 36       	st.w	r8[0xc],r6
8000724e:	93 26       	st.w	r9[0x8],r6
80007250:	e6 08 14 02 	asr	r8,r3,0x2
80007254:	30 1b       	mov	r11,1
80007256:	e0 64 05 38 	mov	r4,1336
8000725a:	f6 08 09 4b 	lsl	r11,r11,r8
8000725e:	68 18       	ld.w	r8,r4[0x4]
80007260:	10 3b       	cp.w	r11,r8
80007262:	e0 8b 00 6b 	brhi	80007338 <_malloc_r+0x2cc>
80007266:	f7 e8 00 09 	and	r9,r11,r8
8000726a:	c0 b1       	brne	80007280 <_malloc_r+0x214>
8000726c:	e0 13 ff fc 	andl	r3,0xfffc
80007270:	a1 7b       	lsl	r11,0x1
80007272:	2f c3       	sub	r3,-4
80007274:	c0 38       	rjmp	8000727a <_malloc_r+0x20e>
80007276:	2f c3       	sub	r3,-4
80007278:	a1 7b       	lsl	r11,0x1
8000727a:	f7 e8 00 09 	and	r9,r11,r8
8000727e:	cf c0       	breq	80007276 <_malloc_r+0x20a>
80007280:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007284:	06 92       	mov	r2,r3
80007286:	1c 91       	mov	r1,lr
80007288:	62 36       	ld.w	r6,r1[0xc]
8000728a:	c2 e8       	rjmp	800072e6 <_malloc_r+0x27a>
8000728c:	6c 1a       	ld.w	r10,r6[0x4]
8000728e:	e0 1a ff fc 	andl	r10,0xfffc
80007292:	f4 07 01 08 	sub	r8,r10,r7
80007296:	58 f8       	cp.w	r8,15
80007298:	e0 8a 00 15 	brle	800072c2 <_malloc_r+0x256>
8000729c:	6c 3a       	ld.w	r10,r6[0xc]
8000729e:	6c 29       	ld.w	r9,r6[0x8]
800072a0:	95 29       	st.w	r10[0x8],r9
800072a2:	93 3a       	st.w	r9[0xc],r10
800072a4:	0e 99       	mov	r9,r7
800072a6:	ec 07 00 07 	add	r7,r6,r7
800072aa:	a1 a9       	sbr	r9,0x0
800072ac:	99 37       	st.w	r12[0xc],r7
800072ae:	99 27       	st.w	r12[0x8],r7
800072b0:	8d 19       	st.w	r6[0x4],r9
800072b2:	ee 08 09 08 	st.w	r7[r8],r8
800072b6:	8f 2c       	st.w	r7[0x8],r12
800072b8:	8f 3c       	st.w	r7[0xc],r12
800072ba:	a1 a8       	sbr	r8,0x0
800072bc:	0a 9c       	mov	r12,r5
800072be:	8f 18       	st.w	r7[0x4],r8
800072c0:	c0 d8       	rjmp	800072da <_malloc_r+0x26e>
800072c2:	6c 39       	ld.w	r9,r6[0xc]
800072c4:	58 08       	cp.w	r8,0
800072c6:	c0 f5       	brlt	800072e4 <_malloc_r+0x278>
800072c8:	ec 0a 00 0a 	add	r10,r6,r10
800072cc:	74 18       	ld.w	r8,r10[0x4]
800072ce:	a1 a8       	sbr	r8,0x0
800072d0:	0a 9c       	mov	r12,r5
800072d2:	95 18       	st.w	r10[0x4],r8
800072d4:	6c 28       	ld.w	r8,r6[0x8]
800072d6:	93 28       	st.w	r9[0x8],r8
800072d8:	91 39       	st.w	r8[0xc],r9
800072da:	fe b0 f4 cd 	rcall	80005c74 <__malloc_unlock>
800072de:	ec cc ff f8 	sub	r12,r6,-8
800072e2:	d8 32       	popm	r0-r7,pc
800072e4:	12 96       	mov	r6,r9
800072e6:	02 36       	cp.w	r6,r1
800072e8:	cd 21       	brne	8000728c <_malloc_r+0x220>
800072ea:	2f f2       	sub	r2,-1
800072ec:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800072f0:	c0 30       	breq	800072f6 <_malloc_r+0x28a>
800072f2:	2f 81       	sub	r1,-8
800072f4:	cc ab       	rjmp	80007288 <_malloc_r+0x21c>
800072f6:	1c 98       	mov	r8,lr
800072f8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800072fc:	c0 81       	brne	8000730c <_malloc_r+0x2a0>
800072fe:	68 19       	ld.w	r9,r4[0x4]
80007300:	f6 08 11 ff 	rsub	r8,r11,-1
80007304:	f3 e8 00 08 	and	r8,r9,r8
80007308:	89 18       	st.w	r4[0x4],r8
8000730a:	c0 78       	rjmp	80007318 <_malloc_r+0x2ac>
8000730c:	f0 c9 00 08 	sub	r9,r8,8
80007310:	20 13       	sub	r3,1
80007312:	70 08       	ld.w	r8,r8[0x0]
80007314:	12 38       	cp.w	r8,r9
80007316:	cf 10       	breq	800072f8 <_malloc_r+0x28c>
80007318:	a1 7b       	lsl	r11,0x1
8000731a:	68 18       	ld.w	r8,r4[0x4]
8000731c:	10 3b       	cp.w	r11,r8
8000731e:	e0 8b 00 0d 	brhi	80007338 <_malloc_r+0x2cc>
80007322:	58 0b       	cp.w	r11,0
80007324:	c0 a0       	breq	80007338 <_malloc_r+0x2cc>
80007326:	04 93       	mov	r3,r2
80007328:	c0 38       	rjmp	8000732e <_malloc_r+0x2c2>
8000732a:	2f c3       	sub	r3,-4
8000732c:	a1 7b       	lsl	r11,0x1
8000732e:	f7 e8 00 09 	and	r9,r11,r8
80007332:	ca 71       	brne	80007280 <_malloc_r+0x214>
80007334:	cf bb       	rjmp	8000732a <_malloc_r+0x2be>
80007336:	d7 03       	nop
80007338:	68 23       	ld.w	r3,r4[0x8]
8000733a:	66 12       	ld.w	r2,r3[0x4]
8000733c:	e0 12 ff fc 	andl	r2,0xfffc
80007340:	0e 32       	cp.w	r2,r7
80007342:	5f 39       	srlo	r9
80007344:	e4 07 01 08 	sub	r8,r2,r7
80007348:	58 f8       	cp.w	r8,15
8000734a:	5f aa       	srle	r10
8000734c:	f5 e9 10 09 	or	r9,r10,r9
80007350:	e0 80 00 9a 	breq	80007484 <_malloc_r+0x418>
80007354:	e0 68 0d 50 	mov	r8,3408
80007358:	70 01       	ld.w	r1,r8[0x0]
8000735a:	e0 68 09 44 	mov	r8,2372
8000735e:	2f 01       	sub	r1,-16
80007360:	70 08       	ld.w	r8,r8[0x0]
80007362:	0e 01       	add	r1,r7
80007364:	5b f8       	cp.w	r8,-1
80007366:	c0 40       	breq	8000736e <_malloc_r+0x302>
80007368:	28 11       	sub	r1,-127
8000736a:	e0 11 ff 80 	andl	r1,0xff80
8000736e:	02 9b       	mov	r11,r1
80007370:	0a 9c       	mov	r12,r5
80007372:	e0 a0 02 b7 	rcall	800078e0 <_sbrk_r>
80007376:	18 96       	mov	r6,r12
80007378:	5b fc       	cp.w	r12,-1
8000737a:	c7 50       	breq	80007464 <_malloc_r+0x3f8>
8000737c:	e6 02 00 08 	add	r8,r3,r2
80007380:	10 3c       	cp.w	r12,r8
80007382:	c0 32       	brcc	80007388 <_malloc_r+0x31c>
80007384:	08 33       	cp.w	r3,r4
80007386:	c6 f1       	brne	80007464 <_malloc_r+0x3f8>
80007388:	e0 6a 0d 54 	mov	r10,3412
8000738c:	74 09       	ld.w	r9,r10[0x0]
8000738e:	e2 09 00 09 	add	r9,r1,r9
80007392:	95 09       	st.w	r10[0x0],r9
80007394:	10 36       	cp.w	r6,r8
80007396:	c0 a1       	brne	800073aa <_malloc_r+0x33e>
80007398:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000739c:	c0 71       	brne	800073aa <_malloc_r+0x33e>
8000739e:	e2 02 00 02 	add	r2,r1,r2
800073a2:	68 28       	ld.w	r8,r4[0x8]
800073a4:	a1 a2       	sbr	r2,0x0
800073a6:	91 12       	st.w	r8[0x4],r2
800073a8:	c4 f8       	rjmp	80007446 <_malloc_r+0x3da>
800073aa:	e0 6a 09 44 	mov	r10,2372
800073ae:	74 0b       	ld.w	r11,r10[0x0]
800073b0:	5b fb       	cp.w	r11,-1
800073b2:	c0 31       	brne	800073b8 <_malloc_r+0x34c>
800073b4:	95 06       	st.w	r10[0x0],r6
800073b6:	c0 78       	rjmp	800073c4 <_malloc_r+0x358>
800073b8:	ec 09 00 09 	add	r9,r6,r9
800073bc:	e0 6a 0d 54 	mov	r10,3412
800073c0:	10 19       	sub	r9,r8
800073c2:	95 09       	st.w	r10[0x0],r9
800073c4:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800073c8:	f0 09 11 08 	rsub	r9,r8,8
800073cc:	58 08       	cp.w	r8,0
800073ce:	f2 08 17 10 	movne	r8,r9
800073d2:	ed d8 e1 06 	addne	r6,r6,r8
800073d6:	28 08       	sub	r8,-128
800073d8:	ec 01 00 01 	add	r1,r6,r1
800073dc:	0a 9c       	mov	r12,r5
800073de:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800073e2:	f0 01 01 01 	sub	r1,r8,r1
800073e6:	02 9b       	mov	r11,r1
800073e8:	e0 a0 02 7c 	rcall	800078e0 <_sbrk_r>
800073ec:	e0 68 0d 54 	mov	r8,3412
800073f0:	5b fc       	cp.w	r12,-1
800073f2:	ec 0c 17 00 	moveq	r12,r6
800073f6:	f9 b1 00 00 	moveq	r1,0
800073fa:	70 09       	ld.w	r9,r8[0x0]
800073fc:	0c 1c       	sub	r12,r6
800073fe:	89 26       	st.w	r4[0x8],r6
80007400:	02 0c       	add	r12,r1
80007402:	12 01       	add	r1,r9
80007404:	a1 ac       	sbr	r12,0x0
80007406:	91 01       	st.w	r8[0x0],r1
80007408:	8d 1c       	st.w	r6[0x4],r12
8000740a:	08 33       	cp.w	r3,r4
8000740c:	c1 d0       	breq	80007446 <_malloc_r+0x3da>
8000740e:	58 f2       	cp.w	r2,15
80007410:	e0 8b 00 05 	brhi	8000741a <_malloc_r+0x3ae>
80007414:	30 18       	mov	r8,1
80007416:	8d 18       	st.w	r6[0x4],r8
80007418:	c2 68       	rjmp	80007464 <_malloc_r+0x3f8>
8000741a:	30 59       	mov	r9,5
8000741c:	20 c2       	sub	r2,12
8000741e:	e0 12 ff f8 	andl	r2,0xfff8
80007422:	e6 02 00 08 	add	r8,r3,r2
80007426:	91 29       	st.w	r8[0x8],r9
80007428:	91 19       	st.w	r8[0x4],r9
8000742a:	66 18       	ld.w	r8,r3[0x4]
8000742c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007430:	e5 e8 10 08 	or	r8,r2,r8
80007434:	87 18       	st.w	r3[0x4],r8
80007436:	58 f2       	cp.w	r2,15
80007438:	e0 88 00 07 	brls	80007446 <_malloc_r+0x3da>
8000743c:	e6 cb ff f8 	sub	r11,r3,-8
80007440:	0a 9c       	mov	r12,r5
80007442:	e0 a0 1c 7d 	rcall	8000ad3c <_free_r>
80007446:	e0 69 0d 4c 	mov	r9,3404
8000744a:	72 0a       	ld.w	r10,r9[0x0]
8000744c:	e0 68 0d 54 	mov	r8,3412
80007450:	70 08       	ld.w	r8,r8[0x0]
80007452:	14 38       	cp.w	r8,r10
80007454:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007458:	e0 69 0d 48 	mov	r9,3400
8000745c:	72 0a       	ld.w	r10,r9[0x0]
8000745e:	14 38       	cp.w	r8,r10
80007460:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007464:	68 28       	ld.w	r8,r4[0x8]
80007466:	70 18       	ld.w	r8,r8[0x4]
80007468:	e0 18 ff fc 	andl	r8,0xfffc
8000746c:	0e 38       	cp.w	r8,r7
8000746e:	5f 39       	srlo	r9
80007470:	0e 18       	sub	r8,r7
80007472:	58 f8       	cp.w	r8,15
80007474:	5f aa       	srle	r10
80007476:	f5 e9 10 09 	or	r9,r10,r9
8000747a:	c0 50       	breq	80007484 <_malloc_r+0x418>
8000747c:	0a 9c       	mov	r12,r5
8000747e:	fe b0 f3 fb 	rcall	80005c74 <__malloc_unlock>
80007482:	d8 3a       	popm	r0-r7,pc,r12=0
80007484:	68 26       	ld.w	r6,r4[0x8]
80007486:	a1 a8       	sbr	r8,0x0
80007488:	0e 99       	mov	r9,r7
8000748a:	a1 a9       	sbr	r9,0x0
8000748c:	8d 19       	st.w	r6[0x4],r9
8000748e:	ec 07 00 07 	add	r7,r6,r7
80007492:	0a 9c       	mov	r12,r5
80007494:	89 27       	st.w	r4[0x8],r7
80007496:	8f 18       	st.w	r7[0x4],r8
80007498:	fe b0 f3 ee 	rcall	80005c74 <__malloc_unlock>
8000749c:	ec cc ff f8 	sub	r12,r6,-8
800074a0:	d8 32       	popm	r0-r7,pc
800074a2:	d7 03       	nop

800074a4 <memcmp>:
800074a4:	d4 01       	pushm	lr
800074a6:	30 08       	mov	r8,0
800074a8:	c0 d8       	rjmp	800074c2 <memcmp+0x1e>
800074aa:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800074ae:	f6 08 07 09 	ld.ub	r9,r11[r8]
800074b2:	20 1a       	sub	r10,1
800074b4:	2f f8       	sub	r8,-1
800074b6:	f2 0e 18 00 	cp.b	lr,r9
800074ba:	c0 40       	breq	800074c2 <memcmp+0x1e>
800074bc:	fc 09 01 0c 	sub	r12,lr,r9
800074c0:	d8 02       	popm	pc
800074c2:	58 0a       	cp.w	r10,0
800074c4:	cf 31       	brne	800074aa <memcmp+0x6>
800074c6:	14 9c       	mov	r12,r10
800074c8:	d8 02       	popm	pc

800074ca <memcpy>:
800074ca:	58 8a       	cp.w	r10,8
800074cc:	c2 f5       	brlt	8000752a <memcpy+0x60>
800074ce:	f9 eb 10 09 	or	r9,r12,r11
800074d2:	e2 19 00 03 	andl	r9,0x3,COH
800074d6:	e0 81 00 97 	brne	80007604 <memcpy+0x13a>
800074da:	e0 4a 00 20 	cp.w	r10,32
800074de:	c3 b4       	brge	80007554 <memcpy+0x8a>
800074e0:	f4 08 14 02 	asr	r8,r10,0x2
800074e4:	f0 09 11 08 	rsub	r9,r8,8
800074e8:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800074ec:	76 69       	ld.w	r9,r11[0x18]
800074ee:	99 69       	st.w	r12[0x18],r9
800074f0:	76 59       	ld.w	r9,r11[0x14]
800074f2:	99 59       	st.w	r12[0x14],r9
800074f4:	76 49       	ld.w	r9,r11[0x10]
800074f6:	99 49       	st.w	r12[0x10],r9
800074f8:	76 39       	ld.w	r9,r11[0xc]
800074fa:	99 39       	st.w	r12[0xc],r9
800074fc:	76 29       	ld.w	r9,r11[0x8]
800074fe:	99 29       	st.w	r12[0x8],r9
80007500:	76 19       	ld.w	r9,r11[0x4]
80007502:	99 19       	st.w	r12[0x4],r9
80007504:	76 09       	ld.w	r9,r11[0x0]
80007506:	99 09       	st.w	r12[0x0],r9
80007508:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000750c:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007510:	e0 1a 00 03 	andl	r10,0x3
80007514:	f4 0a 11 04 	rsub	r10,r10,4
80007518:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000751c:	17 a9       	ld.ub	r9,r11[0x2]
8000751e:	b0 a9       	st.b	r8[0x2],r9
80007520:	17 99       	ld.ub	r9,r11[0x1]
80007522:	b0 99       	st.b	r8[0x1],r9
80007524:	17 89       	ld.ub	r9,r11[0x0]
80007526:	b0 89       	st.b	r8[0x0],r9
80007528:	5e fc       	retal	r12
8000752a:	f4 0a 11 09 	rsub	r10,r10,9
8000752e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007532:	17 f9       	ld.ub	r9,r11[0x7]
80007534:	b8 f9       	st.b	r12[0x7],r9
80007536:	17 e9       	ld.ub	r9,r11[0x6]
80007538:	b8 e9       	st.b	r12[0x6],r9
8000753a:	17 d9       	ld.ub	r9,r11[0x5]
8000753c:	b8 d9       	st.b	r12[0x5],r9
8000753e:	17 c9       	ld.ub	r9,r11[0x4]
80007540:	b8 c9       	st.b	r12[0x4],r9
80007542:	17 b9       	ld.ub	r9,r11[0x3]
80007544:	b8 b9       	st.b	r12[0x3],r9
80007546:	17 a9       	ld.ub	r9,r11[0x2]
80007548:	b8 a9       	st.b	r12[0x2],r9
8000754a:	17 99       	ld.ub	r9,r11[0x1]
8000754c:	b8 99       	st.b	r12[0x1],r9
8000754e:	17 89       	ld.ub	r9,r11[0x0]
80007550:	b8 89       	st.b	r12[0x0],r9
80007552:	5e fc       	retal	r12
80007554:	eb cd 40 c0 	pushm	r6-r7,lr
80007558:	18 99       	mov	r9,r12
8000755a:	22 0a       	sub	r10,32
8000755c:	b7 07       	ld.d	r6,r11++
8000755e:	b3 26       	st.d	r9++,r6
80007560:	b7 07       	ld.d	r6,r11++
80007562:	b3 26       	st.d	r9++,r6
80007564:	b7 07       	ld.d	r6,r11++
80007566:	b3 26       	st.d	r9++,r6
80007568:	b7 07       	ld.d	r6,r11++
8000756a:	b3 26       	st.d	r9++,r6
8000756c:	22 0a       	sub	r10,32
8000756e:	cf 74       	brge	8000755c <memcpy+0x92>
80007570:	2f 0a       	sub	r10,-16
80007572:	c0 65       	brlt	8000757e <memcpy+0xb4>
80007574:	b7 07       	ld.d	r6,r11++
80007576:	b3 26       	st.d	r9++,r6
80007578:	b7 07       	ld.d	r6,r11++
8000757a:	b3 26       	st.d	r9++,r6
8000757c:	21 0a       	sub	r10,16
8000757e:	5c 3a       	neg	r10
80007580:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007584:	d7 03       	nop
80007586:	d7 03       	nop
80007588:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000758c:	f3 66 00 0e 	st.b	r9[14],r6
80007590:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007594:	f3 66 00 0d 	st.b	r9[13],r6
80007598:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000759c:	f3 66 00 0c 	st.b	r9[12],r6
800075a0:	f7 36 00 0b 	ld.ub	r6,r11[11]
800075a4:	f3 66 00 0b 	st.b	r9[11],r6
800075a8:	f7 36 00 0a 	ld.ub	r6,r11[10]
800075ac:	f3 66 00 0a 	st.b	r9[10],r6
800075b0:	f7 36 00 09 	ld.ub	r6,r11[9]
800075b4:	f3 66 00 09 	st.b	r9[9],r6
800075b8:	f7 36 00 08 	ld.ub	r6,r11[8]
800075bc:	f3 66 00 08 	st.b	r9[8],r6
800075c0:	f7 36 00 07 	ld.ub	r6,r11[7]
800075c4:	f3 66 00 07 	st.b	r9[7],r6
800075c8:	f7 36 00 06 	ld.ub	r6,r11[6]
800075cc:	f3 66 00 06 	st.b	r9[6],r6
800075d0:	f7 36 00 05 	ld.ub	r6,r11[5]
800075d4:	f3 66 00 05 	st.b	r9[5],r6
800075d8:	f7 36 00 04 	ld.ub	r6,r11[4]
800075dc:	f3 66 00 04 	st.b	r9[4],r6
800075e0:	f7 36 00 03 	ld.ub	r6,r11[3]
800075e4:	f3 66 00 03 	st.b	r9[3],r6
800075e8:	f7 36 00 02 	ld.ub	r6,r11[2]
800075ec:	f3 66 00 02 	st.b	r9[2],r6
800075f0:	f7 36 00 01 	ld.ub	r6,r11[1]
800075f4:	f3 66 00 01 	st.b	r9[1],r6
800075f8:	f7 36 00 00 	ld.ub	r6,r11[0]
800075fc:	f3 66 00 00 	st.b	r9[0],r6
80007600:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007604:	20 1a       	sub	r10,1
80007606:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000760a:	f8 0a 0b 09 	st.b	r12[r10],r9
8000760e:	cf b1       	brne	80007604 <memcpy+0x13a>
80007610:	5e fc       	retal	r12

80007612 <memset>:
80007612:	18 98       	mov	r8,r12
80007614:	c0 38       	rjmp	8000761a <memset+0x8>
80007616:	10 cb       	st.b	r8++,r11
80007618:	20 1a       	sub	r10,1
8000761a:	58 0a       	cp.w	r10,0
8000761c:	cf d1       	brne	80007616 <memset+0x4>
8000761e:	5e fc       	retal	r12

80007620 <_realloc_r>:
80007620:	d4 31       	pushm	r0-r7,lr
80007622:	20 1d       	sub	sp,4
80007624:	16 94       	mov	r4,r11
80007626:	18 92       	mov	r2,r12
80007628:	14 9b       	mov	r11,r10
8000762a:	58 04       	cp.w	r4,0
8000762c:	c0 51       	brne	80007636 <_realloc_r+0x16>
8000762e:	fe b0 fd 1f 	rcall	8000706c <_malloc_r>
80007632:	18 95       	mov	r5,r12
80007634:	c5 39       	rjmp	800078da <_realloc_r+0x2ba>
80007636:	50 0a       	stdsp	sp[0x0],r10
80007638:	fe b0 f3 18 	rcall	80005c68 <__malloc_lock>
8000763c:	40 0b       	lddsp	r11,sp[0x0]
8000763e:	f6 c8 ff f5 	sub	r8,r11,-11
80007642:	e8 c1 00 08 	sub	r1,r4,8
80007646:	10 96       	mov	r6,r8
80007648:	62 1c       	ld.w	r12,r1[0x4]
8000764a:	e0 16 ff f8 	andl	r6,0xfff8
8000764e:	59 68       	cp.w	r8,22
80007650:	f9 b6 08 10 	movls	r6,16
80007654:	16 36       	cp.w	r6,r11
80007656:	5f 38       	srlo	r8
80007658:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000765c:	c0 50       	breq	80007666 <_realloc_r+0x46>
8000765e:	30 c8       	mov	r8,12
80007660:	30 05       	mov	r5,0
80007662:	85 38       	st.w	r2[0xc],r8
80007664:	c3 b9       	rjmp	800078da <_realloc_r+0x2ba>
80007666:	18 90       	mov	r0,r12
80007668:	e0 10 ff fc 	andl	r0,0xfffc
8000766c:	0c 30       	cp.w	r0,r6
8000766e:	e0 84 01 0b 	brge	80007884 <_realloc_r+0x264>
80007672:	e0 68 05 38 	mov	r8,1336
80007676:	e2 00 00 09 	add	r9,r1,r0
8000767a:	70 25       	ld.w	r5,r8[0x8]
8000767c:	0a 39       	cp.w	r9,r5
8000767e:	c0 90       	breq	80007690 <_realloc_r+0x70>
80007680:	72 1a       	ld.w	r10,r9[0x4]
80007682:	a1 ca       	cbr	r10,0x0
80007684:	f2 0a 00 0a 	add	r10,r9,r10
80007688:	74 1a       	ld.w	r10,r10[0x4]
8000768a:	ed ba 00 00 	bld	r10,0x0
8000768e:	c2 20       	breq	800076d2 <_realloc_r+0xb2>
80007690:	72 1a       	ld.w	r10,r9[0x4]
80007692:	e0 1a ff fc 	andl	r10,0xfffc
80007696:	f4 00 00 03 	add	r3,r10,r0
8000769a:	0a 39       	cp.w	r9,r5
8000769c:	c1 31       	brne	800076c2 <_realloc_r+0xa2>
8000769e:	ec c7 ff f0 	sub	r7,r6,-16
800076a2:	0e 33       	cp.w	r3,r7
800076a4:	c1 95       	brlt	800076d6 <_realloc_r+0xb6>
800076a6:	e2 06 00 09 	add	r9,r1,r6
800076aa:	0c 13       	sub	r3,r6
800076ac:	a1 a3       	sbr	r3,0x0
800076ae:	93 13       	st.w	r9[0x4],r3
800076b0:	91 29       	st.w	r8[0x8],r9
800076b2:	04 9c       	mov	r12,r2
800076b4:	62 18       	ld.w	r8,r1[0x4]
800076b6:	08 95       	mov	r5,r4
800076b8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800076bc:	10 46       	or	r6,r8
800076be:	83 16       	st.w	r1[0x4],r6
800076c0:	c0 b9       	rjmp	800078d6 <_realloc_r+0x2b6>
800076c2:	0c 33       	cp.w	r3,r6
800076c4:	c0 95       	brlt	800076d6 <_realloc_r+0xb6>
800076c6:	72 28       	ld.w	r8,r9[0x8]
800076c8:	02 97       	mov	r7,r1
800076ca:	72 39       	ld.w	r9,r9[0xc]
800076cc:	93 28       	st.w	r9[0x8],r8
800076ce:	91 39       	st.w	r8[0xc],r9
800076d0:	cd c8       	rjmp	80007888 <_realloc_r+0x268>
800076d2:	30 0a       	mov	r10,0
800076d4:	14 99       	mov	r9,r10
800076d6:	ed bc 00 00 	bld	r12,0x0
800076da:	e0 80 00 95 	breq	80007804 <_realloc_r+0x1e4>
800076de:	62 07       	ld.w	r7,r1[0x0]
800076e0:	e2 07 01 07 	sub	r7,r1,r7
800076e4:	6e 1c       	ld.w	r12,r7[0x4]
800076e6:	e0 1c ff fc 	andl	r12,0xfffc
800076ea:	58 09       	cp.w	r9,0
800076ec:	c5 60       	breq	80007798 <_realloc_r+0x178>
800076ee:	f8 00 00 03 	add	r3,r12,r0
800076f2:	0a 39       	cp.w	r9,r5
800076f4:	c4 81       	brne	80007784 <_realloc_r+0x164>
800076f6:	14 03       	add	r3,r10
800076f8:	ec c9 ff f0 	sub	r9,r6,-16
800076fc:	12 33       	cp.w	r3,r9
800076fe:	c4 d5       	brlt	80007798 <_realloc_r+0x178>
80007700:	6e 3a       	ld.w	r10,r7[0xc]
80007702:	6e 29       	ld.w	r9,r7[0x8]
80007704:	95 29       	st.w	r10[0x8],r9
80007706:	93 3a       	st.w	r9[0xc],r10
80007708:	ee c5 ff f8 	sub	r5,r7,-8
8000770c:	e0 ca 00 04 	sub	r10,r0,4
80007710:	e0 4a 00 24 	cp.w	r10,36
80007714:	e0 8b 00 25 	brhi	8000775e <_realloc_r+0x13e>
80007718:	0a 99       	mov	r9,r5
8000771a:	59 3a       	cp.w	r10,19
8000771c:	e0 88 00 1a 	brls	80007750 <_realloc_r+0x130>
80007720:	09 09       	ld.w	r9,r4++
80007722:	8b 09       	st.w	r5[0x0],r9
80007724:	09 09       	ld.w	r9,r4++
80007726:	8f 39       	st.w	r7[0xc],r9
80007728:	ee c9 ff f0 	sub	r9,r7,-16
8000772c:	59 ba       	cp.w	r10,27
8000772e:	e0 88 00 11 	brls	80007750 <_realloc_r+0x130>
80007732:	09 0b       	ld.w	r11,r4++
80007734:	93 0b       	st.w	r9[0x0],r11
80007736:	09 09       	ld.w	r9,r4++
80007738:	8f 59       	st.w	r7[0x14],r9
8000773a:	ee c9 ff e8 	sub	r9,r7,-24
8000773e:	e0 4a 00 24 	cp.w	r10,36
80007742:	c0 71       	brne	80007750 <_realloc_r+0x130>
80007744:	09 0a       	ld.w	r10,r4++
80007746:	93 0a       	st.w	r9[0x0],r10
80007748:	ee c9 ff e0 	sub	r9,r7,-32
8000774c:	09 0a       	ld.w	r10,r4++
8000774e:	8f 7a       	st.w	r7[0x1c],r10
80007750:	09 0a       	ld.w	r10,r4++
80007752:	12 aa       	st.w	r9++,r10
80007754:	68 0a       	ld.w	r10,r4[0x0]
80007756:	93 0a       	st.w	r9[0x0],r10
80007758:	68 1a       	ld.w	r10,r4[0x4]
8000775a:	93 1a       	st.w	r9[0x4],r10
8000775c:	c0 78       	rjmp	8000776a <_realloc_r+0x14a>
8000775e:	50 08       	stdsp	sp[0x0],r8
80007760:	08 9b       	mov	r11,r4
80007762:	0a 9c       	mov	r12,r5
80007764:	e0 a0 1d 8f 	rcall	8000b282 <memmove>
80007768:	40 08       	lddsp	r8,sp[0x0]
8000776a:	ee 06 00 09 	add	r9,r7,r6
8000776e:	0c 13       	sub	r3,r6
80007770:	a1 a3       	sbr	r3,0x0
80007772:	93 13       	st.w	r9[0x4],r3
80007774:	91 29       	st.w	r8[0x8],r9
80007776:	04 9c       	mov	r12,r2
80007778:	6e 18       	ld.w	r8,r7[0x4]
8000777a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000777e:	10 46       	or	r6,r8
80007780:	8f 16       	st.w	r7[0x4],r6
80007782:	ca a8       	rjmp	800078d6 <_realloc_r+0x2b6>
80007784:	14 03       	add	r3,r10
80007786:	0c 33       	cp.w	r3,r6
80007788:	c0 85       	brlt	80007798 <_realloc_r+0x178>
8000778a:	72 28       	ld.w	r8,r9[0x8]
8000778c:	72 39       	ld.w	r9,r9[0xc]
8000778e:	93 28       	st.w	r9[0x8],r8
80007790:	91 39       	st.w	r8[0xc],r9
80007792:	6e 28       	ld.w	r8,r7[0x8]
80007794:	6e 39       	ld.w	r9,r7[0xc]
80007796:	c0 78       	rjmp	800077a4 <_realloc_r+0x184>
80007798:	f8 00 00 03 	add	r3,r12,r0
8000779c:	0c 33       	cp.w	r3,r6
8000779e:	c3 35       	brlt	80007804 <_realloc_r+0x1e4>
800077a0:	6e 39       	ld.w	r9,r7[0xc]
800077a2:	6e 28       	ld.w	r8,r7[0x8]
800077a4:	93 28       	st.w	r9[0x8],r8
800077a6:	91 39       	st.w	r8[0xc],r9
800077a8:	e0 ca 00 04 	sub	r10,r0,4
800077ac:	ee cc ff f8 	sub	r12,r7,-8
800077b0:	e0 4a 00 24 	cp.w	r10,36
800077b4:	e0 8b 00 24 	brhi	800077fc <_realloc_r+0x1dc>
800077b8:	59 3a       	cp.w	r10,19
800077ba:	e0 88 00 1a 	brls	800077ee <_realloc_r+0x1ce>
800077be:	09 08       	ld.w	r8,r4++
800077c0:	99 08       	st.w	r12[0x0],r8
800077c2:	09 08       	ld.w	r8,r4++
800077c4:	8f 38       	st.w	r7[0xc],r8
800077c6:	ee cc ff f0 	sub	r12,r7,-16
800077ca:	59 ba       	cp.w	r10,27
800077cc:	e0 88 00 11 	brls	800077ee <_realloc_r+0x1ce>
800077d0:	09 08       	ld.w	r8,r4++
800077d2:	99 08       	st.w	r12[0x0],r8
800077d4:	09 08       	ld.w	r8,r4++
800077d6:	8f 58       	st.w	r7[0x14],r8
800077d8:	ee cc ff e8 	sub	r12,r7,-24
800077dc:	e0 4a 00 24 	cp.w	r10,36
800077e0:	c0 71       	brne	800077ee <_realloc_r+0x1ce>
800077e2:	09 08       	ld.w	r8,r4++
800077e4:	99 08       	st.w	r12[0x0],r8
800077e6:	ee cc ff e0 	sub	r12,r7,-32
800077ea:	09 08       	ld.w	r8,r4++
800077ec:	8f 78       	st.w	r7[0x1c],r8
800077ee:	09 08       	ld.w	r8,r4++
800077f0:	18 a8       	st.w	r12++,r8
800077f2:	68 08       	ld.w	r8,r4[0x0]
800077f4:	99 08       	st.w	r12[0x0],r8
800077f6:	68 18       	ld.w	r8,r4[0x4]
800077f8:	99 18       	st.w	r12[0x4],r8
800077fa:	c4 78       	rjmp	80007888 <_realloc_r+0x268>
800077fc:	08 9b       	mov	r11,r4
800077fe:	e0 a0 1d 42 	rcall	8000b282 <memmove>
80007802:	c4 38       	rjmp	80007888 <_realloc_r+0x268>
80007804:	04 9c       	mov	r12,r2
80007806:	fe b0 fc 33 	rcall	8000706c <_malloc_r>
8000780a:	18 95       	mov	r5,r12
8000780c:	c3 a0       	breq	80007880 <_realloc_r+0x260>
8000780e:	62 18       	ld.w	r8,r1[0x4]
80007810:	f8 c9 00 08 	sub	r9,r12,8
80007814:	a1 c8       	cbr	r8,0x0
80007816:	e2 08 00 08 	add	r8,r1,r8
8000781a:	10 39       	cp.w	r9,r8
8000781c:	c0 71       	brne	8000782a <_realloc_r+0x20a>
8000781e:	72 13       	ld.w	r3,r9[0x4]
80007820:	02 97       	mov	r7,r1
80007822:	e0 13 ff fc 	andl	r3,0xfffc
80007826:	00 03       	add	r3,r0
80007828:	c3 08       	rjmp	80007888 <_realloc_r+0x268>
8000782a:	e0 ca 00 04 	sub	r10,r0,4
8000782e:	e0 4a 00 24 	cp.w	r10,36
80007832:	e0 8b 00 20 	brhi	80007872 <_realloc_r+0x252>
80007836:	08 99       	mov	r9,r4
80007838:	18 98       	mov	r8,r12
8000783a:	59 3a       	cp.w	r10,19
8000783c:	e0 88 00 14 	brls	80007864 <_realloc_r+0x244>
80007840:	13 0b       	ld.w	r11,r9++
80007842:	10 ab       	st.w	r8++,r11
80007844:	13 0b       	ld.w	r11,r9++
80007846:	10 ab       	st.w	r8++,r11
80007848:	59 ba       	cp.w	r10,27
8000784a:	e0 88 00 0d 	brls	80007864 <_realloc_r+0x244>
8000784e:	13 0b       	ld.w	r11,r9++
80007850:	10 ab       	st.w	r8++,r11
80007852:	13 0b       	ld.w	r11,r9++
80007854:	10 ab       	st.w	r8++,r11
80007856:	e0 4a 00 24 	cp.w	r10,36
8000785a:	c0 51       	brne	80007864 <_realloc_r+0x244>
8000785c:	13 0a       	ld.w	r10,r9++
8000785e:	10 aa       	st.w	r8++,r10
80007860:	13 0a       	ld.w	r10,r9++
80007862:	10 aa       	st.w	r8++,r10
80007864:	13 0a       	ld.w	r10,r9++
80007866:	10 aa       	st.w	r8++,r10
80007868:	72 0a       	ld.w	r10,r9[0x0]
8000786a:	91 0a       	st.w	r8[0x0],r10
8000786c:	72 19       	ld.w	r9,r9[0x4]
8000786e:	91 19       	st.w	r8[0x4],r9
80007870:	c0 48       	rjmp	80007878 <_realloc_r+0x258>
80007872:	08 9b       	mov	r11,r4
80007874:	e0 a0 1d 07 	rcall	8000b282 <memmove>
80007878:	08 9b       	mov	r11,r4
8000787a:	04 9c       	mov	r12,r2
8000787c:	e0 a0 1a 60 	rcall	8000ad3c <_free_r>
80007880:	04 9c       	mov	r12,r2
80007882:	c2 a8       	rjmp	800078d6 <_realloc_r+0x2b6>
80007884:	00 93       	mov	r3,r0
80007886:	02 97       	mov	r7,r1
80007888:	e6 06 01 09 	sub	r9,r3,r6
8000788c:	6e 18       	ld.w	r8,r7[0x4]
8000788e:	58 f9       	cp.w	r9,15
80007890:	e0 88 00 16 	brls	800078bc <_realloc_r+0x29c>
80007894:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007898:	ed e8 10 08 	or	r8,r6,r8
8000789c:	8f 18       	st.w	r7[0x4],r8
8000789e:	12 98       	mov	r8,r9
800078a0:	a1 a8       	sbr	r8,0x0
800078a2:	ee 06 00 0b 	add	r11,r7,r6
800078a6:	f6 09 00 09 	add	r9,r11,r9
800078aa:	97 18       	st.w	r11[0x4],r8
800078ac:	72 18       	ld.w	r8,r9[0x4]
800078ae:	a1 a8       	sbr	r8,0x0
800078b0:	2f 8b       	sub	r11,-8
800078b2:	93 18       	st.w	r9[0x4],r8
800078b4:	04 9c       	mov	r12,r2
800078b6:	e0 a0 1a 43 	rcall	8000ad3c <_free_r>
800078ba:	c0 b8       	rjmp	800078d0 <_realloc_r+0x2b0>
800078bc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800078c0:	e7 e8 10 08 	or	r8,r3,r8
800078c4:	8f 18       	st.w	r7[0x4],r8
800078c6:	ee 03 00 03 	add	r3,r7,r3
800078ca:	66 18       	ld.w	r8,r3[0x4]
800078cc:	a1 a8       	sbr	r8,0x0
800078ce:	87 18       	st.w	r3[0x4],r8
800078d0:	04 9c       	mov	r12,r2
800078d2:	ee c5 ff f8 	sub	r5,r7,-8
800078d6:	fe b0 f1 cf 	rcall	80005c74 <__malloc_unlock>
800078da:	0a 9c       	mov	r12,r5
800078dc:	2f fd       	sub	sp,-4
800078de:	d8 32       	popm	r0-r7,pc

800078e0 <_sbrk_r>:
800078e0:	d4 21       	pushm	r4-r7,lr
800078e2:	30 08       	mov	r8,0
800078e4:	18 97       	mov	r7,r12
800078e6:	e0 66 63 94 	mov	r6,25492
800078ea:	16 9c       	mov	r12,r11
800078ec:	8d 08       	st.w	r6[0x0],r8
800078ee:	c8 5c       	rcall	800079f8 <_sbrk>
800078f0:	5b fc       	cp.w	r12,-1
800078f2:	c0 51       	brne	800078fc <_sbrk_r+0x1c>
800078f4:	6c 08       	ld.w	r8,r6[0x0]
800078f6:	58 08       	cp.w	r8,0
800078f8:	ef f8 1a 03 	st.wne	r7[0xc],r8
800078fc:	d8 22       	popm	r4-r7,pc
800078fe:	d7 03       	nop

80007900 <sprintf>:
80007900:	d4 01       	pushm	lr
80007902:	21 7d       	sub	sp,92
80007904:	e0 68 ff ff 	mov	r8,65535
80007908:	ea 18 7f ff 	orh	r8,0x7fff
8000790c:	50 58       	stdsp	sp[0x14],r8
8000790e:	50 28       	stdsp	sp[0x8],r8
80007910:	e0 68 02 08 	mov	r8,520
80007914:	ba 68       	st.h	sp[0xc],r8
80007916:	3f f8       	mov	r8,-1
80007918:	ba 78       	st.h	sp[0xe],r8
8000791a:	e0 68 0a 38 	mov	r8,2616
8000791e:	50 4c       	stdsp	sp[0x10],r12
80007920:	16 9a       	mov	r10,r11
80007922:	50 0c       	stdsp	sp[0x0],r12
80007924:	fa c9 ff a0 	sub	r9,sp,-96
80007928:	70 0c       	ld.w	r12,r8[0x0]
8000792a:	1a 9b       	mov	r11,sp
8000792c:	e0 a0 02 1a 	rcall	80007d60 <_vfprintf_r>
80007930:	30 09       	mov	r9,0
80007932:	40 08       	lddsp	r8,sp[0x0]
80007934:	b0 89       	st.b	r8[0x0],r9
80007936:	2e 9d       	sub	sp,-92
80007938:	d8 02       	popm	pc
8000793a:	d7 03       	nop

8000793c <strncpy>:
8000793c:	30 08       	mov	r8,0
8000793e:	10 3a       	cp.w	r10,r8
80007940:	5e 0c       	reteq	r12
80007942:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007946:	f8 08 0b 09 	st.b	r12[r8],r9
8000794a:	2f f8       	sub	r8,-1
8000794c:	58 09       	cp.w	r9,0
8000794e:	cf 81       	brne	8000793e <strncpy+0x2>
80007950:	10 3a       	cp.w	r10,r8
80007952:	5e 0c       	reteq	r12
80007954:	f8 08 0b 09 	st.b	r12[r8],r9
80007958:	2f f8       	sub	r8,-1
8000795a:	cf bb       	rjmp	80007950 <strncpy+0x14>

8000795c <_close>:
8000795c:	30 28       	mov	r8,2
8000795e:	d6 73       	breakpoint
80007960:	3f fc       	mov	r12,-1
80007962:	35 8b       	mov	r11,88
80007964:	58 0c       	cp.w	r12,0
80007966:	5e 4c       	retge	r12
80007968:	e0 6a 63 94 	mov	r10,25492
8000796c:	95 0b       	st.w	r10[0x0],r11
8000796e:	5e fc       	retal	r12

80007970 <_lseek>:
80007970:	30 58       	mov	r8,5
80007972:	d6 73       	breakpoint
80007974:	3f fc       	mov	r12,-1
80007976:	35 8b       	mov	r11,88
80007978:	58 0c       	cp.w	r12,0
8000797a:	5e 4c       	retge	r12
8000797c:	e0 6a 63 94 	mov	r10,25492
80007980:	95 0b       	st.w	r10[0x0],r11
80007982:	5e fc       	retal	r12

80007984 <isatty>:
80007984:	30 b8       	mov	r8,11
80007986:	d6 73       	breakpoint
80007988:	3f fc       	mov	r12,-1
8000798a:	35 8b       	mov	r11,88
8000798c:	58 0c       	cp.w	r12,0
8000798e:	5e 4c       	retge	r12
80007990:	e0 6a 63 94 	mov	r10,25492
80007994:	95 0b       	st.w	r10[0x0],r11
80007996:	5e fc       	retal	r12

80007998 <_fstat_host>:
80007998:	30 98       	mov	r8,9
8000799a:	d6 73       	breakpoint
8000799c:	3f fc       	mov	r12,-1
8000799e:	35 8b       	mov	r11,88
800079a0:	58 0c       	cp.w	r12,0
800079a2:	5e 4c       	retge	r12
800079a4:	e0 6a 63 94 	mov	r10,25492
800079a8:	95 0b       	st.w	r10[0x0],r11
800079aa:	5e fc       	retal	r12

800079ac <_fstat>:
800079ac:	d4 21       	pushm	r4-r7,lr
800079ae:	21 0d       	sub	sp,64
800079b0:	16 97       	mov	r7,r11
800079b2:	1a 9b       	mov	r11,sp
800079b4:	cf 2f       	rcall	80007998 <_fstat_host>
800079b6:	c0 34       	brge	800079bc <_fstat+0x10>
800079b8:	3f fc       	mov	r12,-1
800079ba:	c1 c8       	rjmp	800079f2 <_fstat+0x46>
800079bc:	40 08       	lddsp	r8,sp[0x0]
800079be:	ae 08       	st.h	r7[0x0],r8
800079c0:	40 18       	lddsp	r8,sp[0x4]
800079c2:	ae 18       	st.h	r7[0x2],r8
800079c4:	40 28       	lddsp	r8,sp[0x8]
800079c6:	8f 18       	st.w	r7[0x4],r8
800079c8:	40 38       	lddsp	r8,sp[0xc]
800079ca:	ae 48       	st.h	r7[0x8],r8
800079cc:	40 48       	lddsp	r8,sp[0x10]
800079ce:	ae 58       	st.h	r7[0xa],r8
800079d0:	40 58       	lddsp	r8,sp[0x14]
800079d2:	ae 68       	st.h	r7[0xc],r8
800079d4:	40 68       	lddsp	r8,sp[0x18]
800079d6:	ae 78       	st.h	r7[0xe],r8
800079d8:	40 88       	lddsp	r8,sp[0x20]
800079da:	8f 48       	st.w	r7[0x10],r8
800079dc:	40 a8       	lddsp	r8,sp[0x28]
800079de:	8f b8       	st.w	r7[0x2c],r8
800079e0:	40 c8       	lddsp	r8,sp[0x30]
800079e2:	8f c8       	st.w	r7[0x30],r8
800079e4:	40 d8       	lddsp	r8,sp[0x34]
800079e6:	8f 58       	st.w	r7[0x14],r8
800079e8:	40 e8       	lddsp	r8,sp[0x38]
800079ea:	30 0c       	mov	r12,0
800079ec:	8f 78       	st.w	r7[0x1c],r8
800079ee:	40 f8       	lddsp	r8,sp[0x3c]
800079f0:	8f 98       	st.w	r7[0x24],r8
800079f2:	2f 0d       	sub	sp,-64
800079f4:	d8 22       	popm	r4-r7,pc
800079f6:	d7 03       	nop

800079f8 <_sbrk>:
800079f8:	d4 01       	pushm	lr
800079fa:	e0 68 0d 7c 	mov	r8,3452
800079fe:	70 09       	ld.w	r9,r8[0x0]
80007a00:	58 09       	cp.w	r9,0
80007a02:	c0 41       	brne	80007a0a <_sbrk+0x12>
80007a04:	e0 69 63 98 	mov	r9,25496
80007a08:	91 09       	st.w	r8[0x0],r9
80007a0a:	e0 69 0d 7c 	mov	r9,3452
80007a0e:	e0 7a 70 00 	mov	r10,94208
80007a12:	72 08       	ld.w	r8,r9[0x0]
80007a14:	f0 0c 00 0c 	add	r12,r8,r12
80007a18:	14 3c       	cp.w	r12,r10
80007a1a:	e0 8b 00 04 	brhi	80007a22 <_sbrk+0x2a>
80007a1e:	93 0c       	st.w	r9[0x0],r12
80007a20:	c0 68       	rjmp	80007a2c <_sbrk+0x34>
80007a22:	e0 a0 18 15 	rcall	8000aa4c <__errno>
80007a26:	30 c8       	mov	r8,12
80007a28:	99 08       	st.w	r12[0x0],r8
80007a2a:	3f f8       	mov	r8,-1
80007a2c:	10 9c       	mov	r12,r8
80007a2e:	d8 02       	popm	pc

80007a30 <get_arg>:
80007a30:	d4 31       	pushm	r0-r7,lr
80007a32:	20 8d       	sub	sp,32
80007a34:	fa c4 ff bc 	sub	r4,sp,-68
80007a38:	50 4b       	stdsp	sp[0x10],r11
80007a3a:	68 2e       	ld.w	lr,r4[0x8]
80007a3c:	50 58       	stdsp	sp[0x14],r8
80007a3e:	12 96       	mov	r6,r9
80007a40:	7c 0b       	ld.w	r11,lr[0x0]
80007a42:	70 05       	ld.w	r5,r8[0x0]
80007a44:	50 6e       	stdsp	sp[0x18],lr
80007a46:	58 0b       	cp.w	r11,0
80007a48:	f4 0b 17 00 	moveq	r11,r10
80007a4c:	68 03       	ld.w	r3,r4[0x0]
80007a4e:	68 11       	ld.w	r1,r4[0x4]
80007a50:	40 49       	lddsp	r9,sp[0x10]
80007a52:	30 08       	mov	r8,0
80007a54:	c2 89       	rjmp	80007ca4 <get_arg+0x274>
80007a56:	2f fb       	sub	r11,-1
80007a58:	32 5c       	mov	r12,37
80007a5a:	17 8a       	ld.ub	r10,r11[0x0]
80007a5c:	f8 0a 18 00 	cp.b	r10,r12
80007a60:	5f 1e       	srne	lr
80007a62:	f0 0a 18 00 	cp.b	r10,r8
80007a66:	5f 1c       	srne	r12
80007a68:	fd ec 00 0c 	and	r12,lr,r12
80007a6c:	f0 0c 18 00 	cp.b	r12,r8
80007a70:	cf 31       	brne	80007a56 <get_arg+0x26>
80007a72:	58 0a       	cp.w	r10,0
80007a74:	e0 80 01 25 	breq	80007cbe <get_arg+0x28e>
80007a78:	30 0c       	mov	r12,0
80007a7a:	3f fa       	mov	r10,-1
80007a7c:	18 90       	mov	r0,r12
80007a7e:	50 3a       	stdsp	sp[0xc],r10
80007a80:	18 94       	mov	r4,r12
80007a82:	18 92       	mov	r2,r12
80007a84:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007a88:	16 97       	mov	r7,r11
80007a8a:	50 7c       	stdsp	sp[0x1c],r12
80007a8c:	fe cc 99 98 	sub	r12,pc,-26216
80007a90:	0f 3a       	ld.ub	r10,r7++
80007a92:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007a96:	40 7c       	lddsp	r12,sp[0x1c]
80007a98:	1c 0c       	add	r12,lr
80007a9a:	fe ce 9a 6e 	sub	lr,pc,-26002
80007a9e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007aa2:	20 1e       	sub	lr,1
80007aa4:	50 0e       	stdsp	sp[0x0],lr
80007aa6:	fe ce 9a e6 	sub	lr,pc,-25882
80007aaa:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007aae:	50 7c       	stdsp	sp[0x1c],r12
80007ab0:	40 0c       	lddsp	r12,sp[0x0]
80007ab2:	58 7c       	cp.w	r12,7
80007ab4:	e0 8b 00 f1 	brhi	80007c96 <get_arg+0x266>
80007ab8:	fe ce 9c 98 	sub	lr,pc,-25448
80007abc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007ac0:	36 8b       	mov	r11,104
80007ac2:	f6 0a 18 00 	cp.b	r10,r11
80007ac6:	e0 80 00 e8 	breq	80007c96 <get_arg+0x266>
80007aca:	37 1b       	mov	r11,113
80007acc:	f6 0a 18 00 	cp.b	r10,r11
80007ad0:	c0 70       	breq	80007ade <get_arg+0xae>
80007ad2:	34 cb       	mov	r11,76
80007ad4:	f6 0a 18 00 	cp.b	r10,r11
80007ad8:	c0 51       	brne	80007ae2 <get_arg+0xb2>
80007ada:	a3 b4       	sbr	r4,0x3
80007adc:	cd d8       	rjmp	80007c96 <get_arg+0x266>
80007ade:	a5 b4       	sbr	r4,0x5
80007ae0:	cd b8       	rjmp	80007c96 <get_arg+0x266>
80007ae2:	08 9a       	mov	r10,r4
80007ae4:	0e 9b       	mov	r11,r7
80007ae6:	a5 aa       	sbr	r10,0x4
80007ae8:	17 3c       	ld.ub	r12,r11++
80007aea:	a5 b4       	sbr	r4,0x5
80007aec:	36 ce       	mov	lr,108
80007aee:	fc 0c 18 00 	cp.b	r12,lr
80007af2:	e0 80 00 d3 	breq	80007c98 <get_arg+0x268>
80007af6:	14 94       	mov	r4,r10
80007af8:	cc f8       	rjmp	80007c96 <get_arg+0x266>
80007afa:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007afe:	36 7c       	mov	r12,103
80007b00:	f8 0a 18 00 	cp.b	r10,r12
80007b04:	e0 8b 00 27 	brhi	80007b52 <get_arg+0x122>
80007b08:	36 5b       	mov	r11,101
80007b0a:	f6 0a 18 00 	cp.b	r10,r11
80007b0e:	c4 82       	brcc	80007b9e <get_arg+0x16e>
80007b10:	34 fb       	mov	r11,79
80007b12:	f6 0a 18 00 	cp.b	r10,r11
80007b16:	c4 80       	breq	80007ba6 <get_arg+0x176>
80007b18:	e0 8b 00 0c 	brhi	80007b30 <get_arg+0x100>
80007b1c:	34 5b       	mov	r11,69
80007b1e:	f6 0a 18 00 	cp.b	r10,r11
80007b22:	c3 e0       	breq	80007b9e <get_arg+0x16e>
80007b24:	34 7b       	mov	r11,71
80007b26:	f6 0a 18 00 	cp.b	r10,r11
80007b2a:	c3 a0       	breq	80007b9e <get_arg+0x16e>
80007b2c:	34 4b       	mov	r11,68
80007b2e:	c0 88       	rjmp	80007b3e <get_arg+0x10e>
80007b30:	35 8b       	mov	r11,88
80007b32:	f6 0a 18 00 	cp.b	r10,r11
80007b36:	c2 c0       	breq	80007b8e <get_arg+0x15e>
80007b38:	e0 8b 00 07 	brhi	80007b46 <get_arg+0x116>
80007b3c:	35 5b       	mov	r11,85
80007b3e:	f6 0a 18 00 	cp.b	r10,r11
80007b42:	c3 51       	brne	80007bac <get_arg+0x17c>
80007b44:	c3 18       	rjmp	80007ba6 <get_arg+0x176>
80007b46:	36 3b       	mov	r11,99
80007b48:	f6 0a 18 00 	cp.b	r10,r11
80007b4c:	c2 f0       	breq	80007baa <get_arg+0x17a>
80007b4e:	36 4b       	mov	r11,100
80007b50:	c0 e8       	rjmp	80007b6c <get_arg+0x13c>
80007b52:	37 0b       	mov	r11,112
80007b54:	f6 0a 18 00 	cp.b	r10,r11
80007b58:	c2 50       	breq	80007ba2 <get_arg+0x172>
80007b5a:	e0 8b 00 0d 	brhi	80007b74 <get_arg+0x144>
80007b5e:	36 eb       	mov	r11,110
80007b60:	f6 0a 18 00 	cp.b	r10,r11
80007b64:	c1 f0       	breq	80007ba2 <get_arg+0x172>
80007b66:	e0 8b 00 14 	brhi	80007b8e <get_arg+0x15e>
80007b6a:	36 9b       	mov	r11,105
80007b6c:	f6 0a 18 00 	cp.b	r10,r11
80007b70:	c1 e1       	brne	80007bac <get_arg+0x17c>
80007b72:	c0 e8       	rjmp	80007b8e <get_arg+0x15e>
80007b74:	37 5b       	mov	r11,117
80007b76:	f6 0a 18 00 	cp.b	r10,r11
80007b7a:	c0 a0       	breq	80007b8e <get_arg+0x15e>
80007b7c:	37 8b       	mov	r11,120
80007b7e:	f6 0a 18 00 	cp.b	r10,r11
80007b82:	c0 60       	breq	80007b8e <get_arg+0x15e>
80007b84:	37 3b       	mov	r11,115
80007b86:	f6 0a 18 00 	cp.b	r10,r11
80007b8a:	c1 11       	brne	80007bac <get_arg+0x17c>
80007b8c:	c0 b8       	rjmp	80007ba2 <get_arg+0x172>
80007b8e:	ed b4 00 04 	bld	r4,0x4
80007b92:	c0 a0       	breq	80007ba6 <get_arg+0x176>
80007b94:	ed b4 00 05 	bld	r4,0x5
80007b98:	c0 91       	brne	80007baa <get_arg+0x17a>
80007b9a:	30 20       	mov	r0,2
80007b9c:	c0 88       	rjmp	80007bac <get_arg+0x17c>
80007b9e:	30 40       	mov	r0,4
80007ba0:	c0 68       	rjmp	80007bac <get_arg+0x17c>
80007ba2:	30 30       	mov	r0,3
80007ba4:	c0 48       	rjmp	80007bac <get_arg+0x17c>
80007ba6:	30 10       	mov	r0,1
80007ba8:	c0 28       	rjmp	80007bac <get_arg+0x17c>
80007baa:	30 00       	mov	r0,0
80007bac:	40 3b       	lddsp	r11,sp[0xc]
80007bae:	5b fb       	cp.w	r11,-1
80007bb0:	c0 40       	breq	80007bb8 <get_arg+0x188>
80007bb2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007bb6:	c7 08       	rjmp	80007c96 <get_arg+0x266>
80007bb8:	58 60       	cp.w	r0,6
80007bba:	e0 8b 00 6e 	brhi	80007c96 <get_arg+0x266>
80007bbe:	6c 0a       	ld.w	r10,r6[0x0]
80007bc0:	ea cc ff ff 	sub	r12,r5,-1
80007bc4:	fe ce 9d 84 	sub	lr,pc,-25212
80007bc8:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007bcc:	f4 cb ff f8 	sub	r11,r10,-8
80007bd0:	8d 0b       	st.w	r6[0x0],r11
80007bd2:	f4 ea 00 00 	ld.d	r10,r10[0]
80007bd6:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007bda:	c0 f8       	rjmp	80007bf8 <get_arg+0x1c8>
80007bdc:	f4 cb ff fc 	sub	r11,r10,-4
80007be0:	8d 0b       	st.w	r6[0x0],r11
80007be2:	74 0a       	ld.w	r10,r10[0x0]
80007be4:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007be8:	c0 88       	rjmp	80007bf8 <get_arg+0x1c8>
80007bea:	f4 cb ff f8 	sub	r11,r10,-8
80007bee:	8d 0b       	st.w	r6[0x0],r11
80007bf0:	f4 ea 00 00 	ld.d	r10,r10[0]
80007bf4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007bf8:	0e 9b       	mov	r11,r7
80007bfa:	18 95       	mov	r5,r12
80007bfc:	c4 e8       	rjmp	80007c98 <get_arg+0x268>
80007bfe:	62 0a       	ld.w	r10,r1[0x0]
80007c00:	5b fa       	cp.w	r10,-1
80007c02:	c0 b1       	brne	80007c18 <get_arg+0x1e8>
80007c04:	50 19       	stdsp	sp[0x4],r9
80007c06:	50 28       	stdsp	sp[0x8],r8
80007c08:	e0 6a 00 80 	mov	r10,128
80007c0c:	30 0b       	mov	r11,0
80007c0e:	02 9c       	mov	r12,r1
80007c10:	fe b0 fd 01 	rcall	80007612 <memset>
80007c14:	40 28       	lddsp	r8,sp[0x8]
80007c16:	40 19       	lddsp	r9,sp[0x4]
80007c18:	e4 cc 00 01 	sub	r12,r2,1
80007c1c:	0e 9b       	mov	r11,r7
80007c1e:	50 3c       	stdsp	sp[0xc],r12
80007c20:	f2 0c 0c 49 	max	r9,r9,r12
80007c24:	c3 a8       	rjmp	80007c98 <get_arg+0x268>
80007c26:	62 0a       	ld.w	r10,r1[0x0]
80007c28:	5b fa       	cp.w	r10,-1
80007c2a:	c0 b1       	brne	80007c40 <get_arg+0x210>
80007c2c:	50 19       	stdsp	sp[0x4],r9
80007c2e:	50 28       	stdsp	sp[0x8],r8
80007c30:	e0 6a 00 80 	mov	r10,128
80007c34:	30 0b       	mov	r11,0
80007c36:	02 9c       	mov	r12,r1
80007c38:	fe b0 fc ed 	rcall	80007612 <memset>
80007c3c:	40 28       	lddsp	r8,sp[0x8]
80007c3e:	40 19       	lddsp	r9,sp[0x4]
80007c40:	20 12       	sub	r2,1
80007c42:	30 0a       	mov	r10,0
80007c44:	0e 9b       	mov	r11,r7
80007c46:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007c4a:	f2 02 0c 49 	max	r9,r9,r2
80007c4e:	c2 58       	rjmp	80007c98 <get_arg+0x268>
80007c50:	16 97       	mov	r7,r11
80007c52:	6c 0a       	ld.w	r10,r6[0x0]
80007c54:	f4 cb ff fc 	sub	r11,r10,-4
80007c58:	8d 0b       	st.w	r6[0x0],r11
80007c5a:	74 0a       	ld.w	r10,r10[0x0]
80007c5c:	0e 9b       	mov	r11,r7
80007c5e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007c62:	2f f5       	sub	r5,-1
80007c64:	c1 a8       	rjmp	80007c98 <get_arg+0x268>
80007c66:	f4 c2 00 30 	sub	r2,r10,48
80007c6a:	c0 68       	rjmp	80007c76 <get_arg+0x246>
80007c6c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007c70:	2f f7       	sub	r7,-1
80007c72:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007c76:	0f 8a       	ld.ub	r10,r7[0x0]
80007c78:	58 0a       	cp.w	r10,0
80007c7a:	c0 e0       	breq	80007c96 <get_arg+0x266>
80007c7c:	23 0a       	sub	r10,48
80007c7e:	58 9a       	cp.w	r10,9
80007c80:	fe 98 ff f6 	brls	80007c6c <get_arg+0x23c>
80007c84:	c0 98       	rjmp	80007c96 <get_arg+0x266>
80007c86:	2f f7       	sub	r7,-1
80007c88:	0f 8a       	ld.ub	r10,r7[0x0]
80007c8a:	58 0a       	cp.w	r10,0
80007c8c:	c0 50       	breq	80007c96 <get_arg+0x266>
80007c8e:	23 0a       	sub	r10,48
80007c90:	58 9a       	cp.w	r10,9
80007c92:	fe 98 ff fa 	brls	80007c86 <get_arg+0x256>
80007c96:	0e 9b       	mov	r11,r7
80007c98:	40 7c       	lddsp	r12,sp[0x1c]
80007c9a:	30 ba       	mov	r10,11
80007c9c:	f4 0c 18 00 	cp.b	r12,r10
80007ca0:	fe 91 fe f2 	brne	80007a84 <get_arg+0x54>
80007ca4:	40 42       	lddsp	r2,sp[0x10]
80007ca6:	17 8c       	ld.ub	r12,r11[0x0]
80007ca8:	0a 32       	cp.w	r2,r5
80007caa:	5f 4a       	srge	r10
80007cac:	f0 0c 18 00 	cp.b	r12,r8
80007cb0:	5f 1c       	srne	r12
80007cb2:	f9 ea 00 0a 	and	r10,r12,r10
80007cb6:	f0 0a 18 00 	cp.b	r10,r8
80007cba:	fe 91 fe cf 	brne	80007a58 <get_arg+0x28>
80007cbe:	30 08       	mov	r8,0
80007cc0:	40 4e       	lddsp	lr,sp[0x10]
80007cc2:	17 8a       	ld.ub	r10,r11[0x0]
80007cc4:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007cc8:	f0 0a 18 00 	cp.b	r10,r8
80007ccc:	fc 09 17 10 	movne	r9,lr
80007cd0:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007cd4:	06 9e       	mov	lr,r3
80007cd6:	c2 a8       	rjmp	80007d2a <get_arg+0x2fa>
80007cd8:	62 0a       	ld.w	r10,r1[0x0]
80007cda:	58 3a       	cp.w	r10,3
80007cdc:	c1 e0       	breq	80007d18 <get_arg+0x2e8>
80007cde:	e0 89 00 07 	brgt	80007cec <get_arg+0x2bc>
80007ce2:	58 1a       	cp.w	r10,1
80007ce4:	c1 a0       	breq	80007d18 <get_arg+0x2e8>
80007ce6:	58 2a       	cp.w	r10,2
80007ce8:	c1 81       	brne	80007d18 <get_arg+0x2e8>
80007cea:	c0 58       	rjmp	80007cf4 <get_arg+0x2c4>
80007cec:	58 5a       	cp.w	r10,5
80007cee:	c0 c0       	breq	80007d06 <get_arg+0x2d6>
80007cf0:	c0 b5       	brlt	80007d06 <get_arg+0x2d6>
80007cf2:	c1 38       	rjmp	80007d18 <get_arg+0x2e8>
80007cf4:	6c 0a       	ld.w	r10,r6[0x0]
80007cf6:	f4 cc ff f8 	sub	r12,r10,-8
80007cfa:	8d 0c       	st.w	r6[0x0],r12
80007cfc:	f4 e2 00 00 	ld.d	r2,r10[0]
80007d00:	f0 e3 00 00 	st.d	r8[0],r2
80007d04:	c1 08       	rjmp	80007d24 <get_arg+0x2f4>
80007d06:	6c 0a       	ld.w	r10,r6[0x0]
80007d08:	f4 cc ff f8 	sub	r12,r10,-8
80007d0c:	8d 0c       	st.w	r6[0x0],r12
80007d0e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007d12:	f0 e3 00 00 	st.d	r8[0],r2
80007d16:	c0 78       	rjmp	80007d24 <get_arg+0x2f4>
80007d18:	6c 0a       	ld.w	r10,r6[0x0]
80007d1a:	f4 cc ff fc 	sub	r12,r10,-4
80007d1e:	8d 0c       	st.w	r6[0x0],r12
80007d20:	74 0a       	ld.w	r10,r10[0x0]
80007d22:	91 0a       	st.w	r8[0x0],r10
80007d24:	2f f5       	sub	r5,-1
80007d26:	2f 88       	sub	r8,-8
80007d28:	2f c1       	sub	r1,-4
80007d2a:	12 35       	cp.w	r5,r9
80007d2c:	fe 9a ff d6 	brle	80007cd8 <get_arg+0x2a8>
80007d30:	1c 93       	mov	r3,lr
80007d32:	40 52       	lddsp	r2,sp[0x14]
80007d34:	40 6e       	lddsp	lr,sp[0x18]
80007d36:	85 05       	st.w	r2[0x0],r5
80007d38:	9d 0b       	st.w	lr[0x0],r11
80007d3a:	40 4b       	lddsp	r11,sp[0x10]
80007d3c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007d40:	2f 8d       	sub	sp,-32
80007d42:	d8 32       	popm	r0-r7,pc

80007d44 <__sprint_r>:
80007d44:	d4 21       	pushm	r4-r7,lr
80007d46:	14 97       	mov	r7,r10
80007d48:	74 28       	ld.w	r8,r10[0x8]
80007d4a:	58 08       	cp.w	r8,0
80007d4c:	c0 41       	brne	80007d54 <__sprint_r+0x10>
80007d4e:	95 18       	st.w	r10[0x4],r8
80007d50:	10 9c       	mov	r12,r8
80007d52:	d8 22       	popm	r4-r7,pc
80007d54:	e0 a0 18 ba 	rcall	8000aec8 <__sfvwrite_r>
80007d58:	30 08       	mov	r8,0
80007d5a:	8f 18       	st.w	r7[0x4],r8
80007d5c:	8f 28       	st.w	r7[0x8],r8
80007d5e:	d8 22       	popm	r4-r7,pc

80007d60 <_vfprintf_r>:
80007d60:	d4 31       	pushm	r0-r7,lr
80007d62:	fa cd 06 bc 	sub	sp,sp,1724
80007d66:	51 09       	stdsp	sp[0x40],r9
80007d68:	16 91       	mov	r1,r11
80007d6a:	14 97       	mov	r7,r10
80007d6c:	18 95       	mov	r5,r12
80007d6e:	e0 a0 1a 1d 	rcall	8000b1a8 <_localeconv_r>
80007d72:	78 0c       	ld.w	r12,r12[0x0]
80007d74:	50 cc       	stdsp	sp[0x30],r12
80007d76:	58 05       	cp.w	r5,0
80007d78:	c0 70       	breq	80007d86 <_vfprintf_r+0x26>
80007d7a:	6a 68       	ld.w	r8,r5[0x18]
80007d7c:	58 08       	cp.w	r8,0
80007d7e:	c0 41       	brne	80007d86 <_vfprintf_r+0x26>
80007d80:	0a 9c       	mov	r12,r5
80007d82:	e0 a0 17 43 	rcall	8000ac08 <__sinit>
80007d86:	fe c8 9b 82 	sub	r8,pc,-25726
80007d8a:	10 31       	cp.w	r1,r8
80007d8c:	c0 31       	brne	80007d92 <_vfprintf_r+0x32>
80007d8e:	6a 01       	ld.w	r1,r5[0x0]
80007d90:	c0 c8       	rjmp	80007da8 <_vfprintf_r+0x48>
80007d92:	fe c8 9b 6e 	sub	r8,pc,-25746
80007d96:	10 31       	cp.w	r1,r8
80007d98:	c0 31       	brne	80007d9e <_vfprintf_r+0x3e>
80007d9a:	6a 11       	ld.w	r1,r5[0x4]
80007d9c:	c0 68       	rjmp	80007da8 <_vfprintf_r+0x48>
80007d9e:	fe c8 9b 5a 	sub	r8,pc,-25766
80007da2:	10 31       	cp.w	r1,r8
80007da4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007da8:	82 68       	ld.sh	r8,r1[0xc]
80007daa:	ed b8 00 03 	bld	r8,0x3
80007dae:	c0 41       	brne	80007db6 <_vfprintf_r+0x56>
80007db0:	62 48       	ld.w	r8,r1[0x10]
80007db2:	58 08       	cp.w	r8,0
80007db4:	c0 71       	brne	80007dc2 <_vfprintf_r+0x62>
80007db6:	02 9b       	mov	r11,r1
80007db8:	0a 9c       	mov	r12,r5
80007dba:	e0 a0 0f 5d 	rcall	80009c74 <__swsetup_r>
80007dbe:	e0 81 0f 54 	brne	80009c66 <_vfprintf_r+0x1f06>
80007dc2:	82 68       	ld.sh	r8,r1[0xc]
80007dc4:	10 99       	mov	r9,r8
80007dc6:	e2 19 00 1a 	andl	r9,0x1a,COH
80007dca:	58 a9       	cp.w	r9,10
80007dcc:	c3 c1       	brne	80007e44 <_vfprintf_r+0xe4>
80007dce:	82 79       	ld.sh	r9,r1[0xe]
80007dd0:	30 0a       	mov	r10,0
80007dd2:	f4 09 19 00 	cp.h	r9,r10
80007dd6:	c3 75       	brlt	80007e44 <_vfprintf_r+0xe4>
80007dd8:	a1 d8       	cbr	r8,0x1
80007dda:	fb 58 05 d0 	st.h	sp[1488],r8
80007dde:	62 88       	ld.w	r8,r1[0x20]
80007de0:	fb 48 05 e4 	st.w	sp[1508],r8
80007de4:	62 a8       	ld.w	r8,r1[0x28]
80007de6:	fb 48 05 ec 	st.w	sp[1516],r8
80007dea:	fa c8 ff bc 	sub	r8,sp,-68
80007dee:	fb 48 05 d4 	st.w	sp[1492],r8
80007df2:	fb 48 05 c4 	st.w	sp[1476],r8
80007df6:	e0 68 04 00 	mov	r8,1024
80007dfa:	fb 48 05 d8 	st.w	sp[1496],r8
80007dfe:	fb 48 05 cc 	st.w	sp[1484],r8
80007e02:	30 08       	mov	r8,0
80007e04:	fb 59 05 d2 	st.h	sp[1490],r9
80007e08:	0e 9a       	mov	r10,r7
80007e0a:	41 09       	lddsp	r9,sp[0x40]
80007e0c:	fa c7 fa 3c 	sub	r7,sp,-1476
80007e10:	fb 48 05 dc 	st.w	sp[1500],r8
80007e14:	0a 9c       	mov	r12,r5
80007e16:	0e 9b       	mov	r11,r7
80007e18:	ca 4f       	rcall	80007d60 <_vfprintf_r>
80007e1a:	50 bc       	stdsp	sp[0x2c],r12
80007e1c:	c0 95       	brlt	80007e2e <_vfprintf_r+0xce>
80007e1e:	0e 9b       	mov	r11,r7
80007e20:	0a 9c       	mov	r12,r5
80007e22:	e0 a0 16 1b 	rcall	8000aa58 <_fflush_r>
80007e26:	40 be       	lddsp	lr,sp[0x2c]
80007e28:	f9 be 01 ff 	movne	lr,-1
80007e2c:	50 be       	stdsp	sp[0x2c],lr
80007e2e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007e32:	ed b8 00 06 	bld	r8,0x6
80007e36:	e0 81 0f 1a 	brne	80009c6a <_vfprintf_r+0x1f0a>
80007e3a:	82 68       	ld.sh	r8,r1[0xc]
80007e3c:	a7 a8       	sbr	r8,0x6
80007e3e:	a2 68       	st.h	r1[0xc],r8
80007e40:	e0 8f 0f 15 	bral	80009c6a <_vfprintf_r+0x1f0a>
80007e44:	30 08       	mov	r8,0
80007e46:	fb 48 06 b4 	st.w	sp[1716],r8
80007e4a:	fb 48 06 90 	st.w	sp[1680],r8
80007e4e:	fb 48 06 8c 	st.w	sp[1676],r8
80007e52:	fb 48 06 b0 	st.w	sp[1712],r8
80007e56:	30 08       	mov	r8,0
80007e58:	30 09       	mov	r9,0
80007e5a:	50 a7       	stdsp	sp[0x28],r7
80007e5c:	50 78       	stdsp	sp[0x1c],r8
80007e5e:	fa c3 f9 e0 	sub	r3,sp,-1568
80007e62:	3f f8       	mov	r8,-1
80007e64:	50 59       	stdsp	sp[0x14],r9
80007e66:	fb 43 06 88 	st.w	sp[1672],r3
80007e6a:	fb 48 05 44 	st.w	sp[1348],r8
80007e6e:	12 9c       	mov	r12,r9
80007e70:	50 69       	stdsp	sp[0x18],r9
80007e72:	50 d9       	stdsp	sp[0x34],r9
80007e74:	50 e9       	stdsp	sp[0x38],r9
80007e76:	50 b9       	stdsp	sp[0x2c],r9
80007e78:	12 97       	mov	r7,r9
80007e7a:	0a 94       	mov	r4,r5
80007e7c:	40 a2       	lddsp	r2,sp[0x28]
80007e7e:	32 5a       	mov	r10,37
80007e80:	30 08       	mov	r8,0
80007e82:	c0 28       	rjmp	80007e86 <_vfprintf_r+0x126>
80007e84:	2f f2       	sub	r2,-1
80007e86:	05 89       	ld.ub	r9,r2[0x0]
80007e88:	f0 09 18 00 	cp.b	r9,r8
80007e8c:	5f 1b       	srne	r11
80007e8e:	f4 09 18 00 	cp.b	r9,r10
80007e92:	5f 19       	srne	r9
80007e94:	f3 eb 00 0b 	and	r11,r9,r11
80007e98:	f0 0b 18 00 	cp.b	r11,r8
80007e9c:	cf 41       	brne	80007e84 <_vfprintf_r+0x124>
80007e9e:	40 ab       	lddsp	r11,sp[0x28]
80007ea0:	e4 0b 01 06 	sub	r6,r2,r11
80007ea4:	c1 e0       	breq	80007ee0 <_vfprintf_r+0x180>
80007ea6:	fa f8 06 90 	ld.w	r8,sp[1680]
80007eaa:	0c 08       	add	r8,r6
80007eac:	87 0b       	st.w	r3[0x0],r11
80007eae:	fb 48 06 90 	st.w	sp[1680],r8
80007eb2:	87 16       	st.w	r3[0x4],r6
80007eb4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007eb8:	2f f8       	sub	r8,-1
80007eba:	fb 48 06 8c 	st.w	sp[1676],r8
80007ebe:	58 78       	cp.w	r8,7
80007ec0:	e0 89 00 04 	brgt	80007ec8 <_vfprintf_r+0x168>
80007ec4:	2f 83       	sub	r3,-8
80007ec6:	c0 a8       	rjmp	80007eda <_vfprintf_r+0x17a>
80007ec8:	fa ca f9 78 	sub	r10,sp,-1672
80007ecc:	02 9b       	mov	r11,r1
80007ece:	08 9c       	mov	r12,r4
80007ed0:	c3 af       	rcall	80007d44 <__sprint_r>
80007ed2:	e0 81 0e c6 	brne	80009c5e <_vfprintf_r+0x1efe>
80007ed6:	fa c3 f9 e0 	sub	r3,sp,-1568
80007eda:	40 ba       	lddsp	r10,sp[0x2c]
80007edc:	0c 0a       	add	r10,r6
80007ede:	50 ba       	stdsp	sp[0x2c],r10
80007ee0:	05 89       	ld.ub	r9,r2[0x0]
80007ee2:	30 08       	mov	r8,0
80007ee4:	f0 09 18 00 	cp.b	r9,r8
80007ee8:	e0 80 0e aa 	breq	80009c3c <_vfprintf_r+0x1edc>
80007eec:	30 09       	mov	r9,0
80007eee:	fb 68 06 bb 	st.b	sp[1723],r8
80007ef2:	0e 96       	mov	r6,r7
80007ef4:	e4 c8 ff ff 	sub	r8,r2,-1
80007ef8:	3f fe       	mov	lr,-1
80007efa:	50 93       	stdsp	sp[0x24],r3
80007efc:	50 41       	stdsp	sp[0x10],r1
80007efe:	0e 93       	mov	r3,r7
80007f00:	04 91       	mov	r1,r2
80007f02:	50 89       	stdsp	sp[0x20],r9
80007f04:	50 a8       	stdsp	sp[0x28],r8
80007f06:	50 2e       	stdsp	sp[0x8],lr
80007f08:	50 39       	stdsp	sp[0xc],r9
80007f0a:	12 95       	mov	r5,r9
80007f0c:	12 90       	mov	r0,r9
80007f0e:	10 97       	mov	r7,r8
80007f10:	08 92       	mov	r2,r4
80007f12:	c0 78       	rjmp	80007f20 <_vfprintf_r+0x1c0>
80007f14:	3f fc       	mov	r12,-1
80007f16:	08 97       	mov	r7,r4
80007f18:	50 2c       	stdsp	sp[0x8],r12
80007f1a:	c0 38       	rjmp	80007f20 <_vfprintf_r+0x1c0>
80007f1c:	30 0b       	mov	r11,0
80007f1e:	50 3b       	stdsp	sp[0xc],r11
80007f20:	0f 38       	ld.ub	r8,r7++
80007f22:	c0 28       	rjmp	80007f26 <_vfprintf_r+0x1c6>
80007f24:	12 90       	mov	r0,r9
80007f26:	f0 c9 00 20 	sub	r9,r8,32
80007f2a:	e0 49 00 58 	cp.w	r9,88
80007f2e:	e0 8b 0a 30 	brhi	8000938e <_vfprintf_r+0x162e>
80007f32:	fe ca a0 d6 	sub	r10,pc,-24362
80007f36:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007f3a:	50 a7       	stdsp	sp[0x28],r7
80007f3c:	50 80       	stdsp	sp[0x20],r0
80007f3e:	0c 97       	mov	r7,r6
80007f40:	04 94       	mov	r4,r2
80007f42:	06 96       	mov	r6,r3
80007f44:	02 92       	mov	r2,r1
80007f46:	fe c9 9e ae 	sub	r9,pc,-24914
80007f4a:	40 93       	lddsp	r3,sp[0x24]
80007f4c:	10 90       	mov	r0,r8
80007f4e:	40 41       	lddsp	r1,sp[0x10]
80007f50:	50 d9       	stdsp	sp[0x34],r9
80007f52:	e0 8f 08 8e 	bral	8000906e <_vfprintf_r+0x130e>
80007f56:	30 08       	mov	r8,0
80007f58:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007f5c:	f0 09 18 00 	cp.b	r9,r8
80007f60:	ce 01       	brne	80007f20 <_vfprintf_r+0x1c0>
80007f62:	32 08       	mov	r8,32
80007f64:	c6 e8       	rjmp	80008040 <_vfprintf_r+0x2e0>
80007f66:	a1 a5       	sbr	r5,0x0
80007f68:	cd cb       	rjmp	80007f20 <_vfprintf_r+0x1c0>
80007f6a:	0f 89       	ld.ub	r9,r7[0x0]
80007f6c:	f2 c8 00 30 	sub	r8,r9,48
80007f70:	58 98       	cp.w	r8,9
80007f72:	e0 8b 00 1d 	brhi	80007fac <_vfprintf_r+0x24c>
80007f76:	ee c8 ff ff 	sub	r8,r7,-1
80007f7a:	30 0b       	mov	r11,0
80007f7c:	23 09       	sub	r9,48
80007f7e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007f82:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007f86:	11 39       	ld.ub	r9,r8++
80007f88:	f2 ca 00 30 	sub	r10,r9,48
80007f8c:	58 9a       	cp.w	r10,9
80007f8e:	fe 98 ff f7 	brls	80007f7c <_vfprintf_r+0x21c>
80007f92:	e0 49 00 24 	cp.w	r9,36
80007f96:	cc 31       	brne	80007f1c <_vfprintf_r+0x1bc>
80007f98:	e0 4b 00 20 	cp.w	r11,32
80007f9c:	e0 89 0e 60 	brgt	80009c5c <_vfprintf_r+0x1efc>
80007fa0:	20 1b       	sub	r11,1
80007fa2:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007fa6:	12 3b       	cp.w	r11,r9
80007fa8:	c0 95       	brlt	80007fba <_vfprintf_r+0x25a>
80007faa:	c1 08       	rjmp	80007fca <_vfprintf_r+0x26a>
80007fac:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007fb0:	ec ca ff ff 	sub	r10,r6,-1
80007fb4:	12 36       	cp.w	r6,r9
80007fb6:	c1 f5       	brlt	80007ff4 <_vfprintf_r+0x294>
80007fb8:	c2 68       	rjmp	80008004 <_vfprintf_r+0x2a4>
80007fba:	fa ce f9 44 	sub	lr,sp,-1724
80007fbe:	10 97       	mov	r7,r8
80007fc0:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007fc4:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007fc8:	c3 58       	rjmp	80008032 <_vfprintf_r+0x2d2>
80007fca:	10 97       	mov	r7,r8
80007fcc:	fa c8 f9 50 	sub	r8,sp,-1712
80007fd0:	1a d8       	st.w	--sp,r8
80007fd2:	fa c8 fa b8 	sub	r8,sp,-1352
80007fd6:	1a d8       	st.w	--sp,r8
80007fd8:	fa c8 fb b4 	sub	r8,sp,-1100
80007fdc:	02 9a       	mov	r10,r1
80007fde:	1a d8       	st.w	--sp,r8
80007fe0:	04 9c       	mov	r12,r2
80007fe2:	fa c8 f9 40 	sub	r8,sp,-1728
80007fe6:	fa c9 ff b4 	sub	r9,sp,-76
80007fea:	fe b0 fd 23 	rcall	80007a30 <get_arg>
80007fee:	2f dd       	sub	sp,-12
80007ff0:	78 00       	ld.w	r0,r12[0x0]
80007ff2:	c2 08       	rjmp	80008032 <_vfprintf_r+0x2d2>
80007ff4:	fa cc f9 44 	sub	r12,sp,-1724
80007ff8:	14 96       	mov	r6,r10
80007ffa:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007ffe:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008002:	c1 88       	rjmp	80008032 <_vfprintf_r+0x2d2>
80008004:	41 08       	lddsp	r8,sp[0x40]
80008006:	59 f9       	cp.w	r9,31
80008008:	e0 89 00 11 	brgt	8000802a <_vfprintf_r+0x2ca>
8000800c:	f0 cb ff fc 	sub	r11,r8,-4
80008010:	51 0b       	stdsp	sp[0x40],r11
80008012:	70 00       	ld.w	r0,r8[0x0]
80008014:	fa cb f9 44 	sub	r11,sp,-1724
80008018:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000801c:	f1 40 fd 88 	st.w	r8[-632],r0
80008020:	2f f9       	sub	r9,-1
80008022:	14 96       	mov	r6,r10
80008024:	fb 49 06 b4 	st.w	sp[1716],r9
80008028:	c0 58       	rjmp	80008032 <_vfprintf_r+0x2d2>
8000802a:	70 00       	ld.w	r0,r8[0x0]
8000802c:	14 96       	mov	r6,r10
8000802e:	2f c8       	sub	r8,-4
80008030:	51 08       	stdsp	sp[0x40],r8
80008032:	58 00       	cp.w	r0,0
80008034:	fe 94 ff 76 	brge	80007f20 <_vfprintf_r+0x1c0>
80008038:	5c 30       	neg	r0
8000803a:	a3 a5       	sbr	r5,0x2
8000803c:	c7 2b       	rjmp	80007f20 <_vfprintf_r+0x1c0>
8000803e:	32 b8       	mov	r8,43
80008040:	fb 68 06 bb 	st.b	sp[1723],r8
80008044:	c6 eb       	rjmp	80007f20 <_vfprintf_r+0x1c0>
80008046:	0f 38       	ld.ub	r8,r7++
80008048:	e0 48 00 2a 	cp.w	r8,42
8000804c:	c0 30       	breq	80008052 <_vfprintf_r+0x2f2>
8000804e:	30 09       	mov	r9,0
80008050:	c7 98       	rjmp	80008142 <_vfprintf_r+0x3e2>
80008052:	0f 88       	ld.ub	r8,r7[0x0]
80008054:	f0 c9 00 30 	sub	r9,r8,48
80008058:	58 99       	cp.w	r9,9
8000805a:	e0 8b 00 1f 	brhi	80008098 <_vfprintf_r+0x338>
8000805e:	ee c4 ff ff 	sub	r4,r7,-1
80008062:	30 0b       	mov	r11,0
80008064:	23 08       	sub	r8,48
80008066:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000806a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000806e:	09 38       	ld.ub	r8,r4++
80008070:	f0 c9 00 30 	sub	r9,r8,48
80008074:	58 99       	cp.w	r9,9
80008076:	fe 98 ff f7 	brls	80008064 <_vfprintf_r+0x304>
8000807a:	e0 48 00 24 	cp.w	r8,36
8000807e:	fe 91 ff 4f 	brne	80007f1c <_vfprintf_r+0x1bc>
80008082:	e0 4b 00 20 	cp.w	r11,32
80008086:	e0 89 0d eb 	brgt	80009c5c <_vfprintf_r+0x1efc>
8000808a:	20 1b       	sub	r11,1
8000808c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008090:	10 3b       	cp.w	r11,r8
80008092:	c0 a5       	brlt	800080a6 <_vfprintf_r+0x346>
80008094:	c1 18       	rjmp	800080b6 <_vfprintf_r+0x356>
80008096:	d7 03       	nop
80008098:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000809c:	ec c9 ff ff 	sub	r9,r6,-1
800080a0:	14 36       	cp.w	r6,r10
800080a2:	c1 f5       	brlt	800080e0 <_vfprintf_r+0x380>
800080a4:	c2 88       	rjmp	800080f4 <_vfprintf_r+0x394>
800080a6:	fa ca f9 44 	sub	r10,sp,-1724
800080aa:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800080ae:	f6 fb fd 88 	ld.w	r11,r11[-632]
800080b2:	50 2b       	stdsp	sp[0x8],r11
800080b4:	c3 c8       	rjmp	8000812c <_vfprintf_r+0x3cc>
800080b6:	fa c8 f9 50 	sub	r8,sp,-1712
800080ba:	1a d8       	st.w	--sp,r8
800080bc:	fa c8 fa b8 	sub	r8,sp,-1352
800080c0:	1a d8       	st.w	--sp,r8
800080c2:	fa c8 fb b4 	sub	r8,sp,-1100
800080c6:	02 9a       	mov	r10,r1
800080c8:	1a d8       	st.w	--sp,r8
800080ca:	04 9c       	mov	r12,r2
800080cc:	fa c8 f9 40 	sub	r8,sp,-1728
800080d0:	fa c9 ff b4 	sub	r9,sp,-76
800080d4:	fe b0 fc ae 	rcall	80007a30 <get_arg>
800080d8:	2f dd       	sub	sp,-12
800080da:	78 0c       	ld.w	r12,r12[0x0]
800080dc:	50 2c       	stdsp	sp[0x8],r12
800080de:	c2 78       	rjmp	8000812c <_vfprintf_r+0x3cc>
800080e0:	12 96       	mov	r6,r9
800080e2:	0e 94       	mov	r4,r7
800080e4:	fa c9 f9 44 	sub	r9,sp,-1724
800080e8:	f2 03 00 38 	add	r8,r9,r3<<0x3
800080ec:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800080f0:	50 28       	stdsp	sp[0x8],r8
800080f2:	c1 d8       	rjmp	8000812c <_vfprintf_r+0x3cc>
800080f4:	41 08       	lddsp	r8,sp[0x40]
800080f6:	59 fa       	cp.w	r10,31
800080f8:	e0 89 00 14 	brgt	80008120 <_vfprintf_r+0x3c0>
800080fc:	f0 cb ff fc 	sub	r11,r8,-4
80008100:	70 08       	ld.w	r8,r8[0x0]
80008102:	51 0b       	stdsp	sp[0x40],r11
80008104:	50 28       	stdsp	sp[0x8],r8
80008106:	fa c6 f9 44 	sub	r6,sp,-1724
8000810a:	40 2e       	lddsp	lr,sp[0x8]
8000810c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008110:	f1 4e fd 88 	st.w	r8[-632],lr
80008114:	2f fa       	sub	r10,-1
80008116:	0e 94       	mov	r4,r7
80008118:	fb 4a 06 b4 	st.w	sp[1716],r10
8000811c:	12 96       	mov	r6,r9
8000811e:	c0 78       	rjmp	8000812c <_vfprintf_r+0x3cc>
80008120:	70 0c       	ld.w	r12,r8[0x0]
80008122:	0e 94       	mov	r4,r7
80008124:	2f c8       	sub	r8,-4
80008126:	50 2c       	stdsp	sp[0x8],r12
80008128:	12 96       	mov	r6,r9
8000812a:	51 08       	stdsp	sp[0x40],r8
8000812c:	40 2b       	lddsp	r11,sp[0x8]
8000812e:	58 0b       	cp.w	r11,0
80008130:	fe 95 fe f2 	brlt	80007f14 <_vfprintf_r+0x1b4>
80008134:	08 97       	mov	r7,r4
80008136:	cf 5a       	rjmp	80007f20 <_vfprintf_r+0x1c0>
80008138:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000813c:	0f 38       	ld.ub	r8,r7++
8000813e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008142:	f0 ca 00 30 	sub	r10,r8,48
80008146:	58 9a       	cp.w	r10,9
80008148:	fe 98 ff f8 	brls	80008138 <_vfprintf_r+0x3d8>
8000814c:	3f fa       	mov	r10,-1
8000814e:	f2 0a 0c 49 	max	r9,r9,r10
80008152:	50 29       	stdsp	sp[0x8],r9
80008154:	ce 9a       	rjmp	80007f26 <_vfprintf_r+0x1c6>
80008156:	a7 b5       	sbr	r5,0x7
80008158:	ce 4a       	rjmp	80007f20 <_vfprintf_r+0x1c0>
8000815a:	30 09       	mov	r9,0
8000815c:	23 08       	sub	r8,48
8000815e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008162:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008166:	0f 38       	ld.ub	r8,r7++
80008168:	f0 ca 00 30 	sub	r10,r8,48
8000816c:	58 9a       	cp.w	r10,9
8000816e:	fe 98 ff f7 	brls	8000815c <_vfprintf_r+0x3fc>
80008172:	e0 48 00 24 	cp.w	r8,36
80008176:	fe 91 fe d7 	brne	80007f24 <_vfprintf_r+0x1c4>
8000817a:	e0 49 00 20 	cp.w	r9,32
8000817e:	e0 89 0d 6f 	brgt	80009c5c <_vfprintf_r+0x1efc>
80008182:	f2 c3 00 01 	sub	r3,r9,1
80008186:	30 19       	mov	r9,1
80008188:	50 39       	stdsp	sp[0xc],r9
8000818a:	cc ba       	rjmp	80007f20 <_vfprintf_r+0x1c0>
8000818c:	a3 b5       	sbr	r5,0x3
8000818e:	cc 9a       	rjmp	80007f20 <_vfprintf_r+0x1c0>
80008190:	a7 a5       	sbr	r5,0x6
80008192:	cc 7a       	rjmp	80007f20 <_vfprintf_r+0x1c0>
80008194:	0a 98       	mov	r8,r5
80008196:	a5 b5       	sbr	r5,0x5
80008198:	a5 a8       	sbr	r8,0x4
8000819a:	0f 89       	ld.ub	r9,r7[0x0]
8000819c:	36 ce       	mov	lr,108
8000819e:	fc 09 18 00 	cp.b	r9,lr
800081a2:	f7 b7 00 ff 	subeq	r7,-1
800081a6:	f0 05 17 10 	movne	r5,r8
800081aa:	cb ba       	rjmp	80007f20 <_vfprintf_r+0x1c0>
800081ac:	a5 b5       	sbr	r5,0x5
800081ae:	cb 9a       	rjmp	80007f20 <_vfprintf_r+0x1c0>
800081b0:	50 a7       	stdsp	sp[0x28],r7
800081b2:	50 80       	stdsp	sp[0x20],r0
800081b4:	0c 97       	mov	r7,r6
800081b6:	10 90       	mov	r0,r8
800081b8:	06 96       	mov	r6,r3
800081ba:	04 94       	mov	r4,r2
800081bc:	40 93       	lddsp	r3,sp[0x24]
800081be:	02 92       	mov	r2,r1
800081c0:	0e 99       	mov	r9,r7
800081c2:	40 41       	lddsp	r1,sp[0x10]
800081c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081c8:	40 3c       	lddsp	r12,sp[0xc]
800081ca:	58 0c       	cp.w	r12,0
800081cc:	c1 d0       	breq	80008206 <_vfprintf_r+0x4a6>
800081ce:	10 36       	cp.w	r6,r8
800081d0:	c0 64       	brge	800081dc <_vfprintf_r+0x47c>
800081d2:	fa cb f9 44 	sub	r11,sp,-1724
800081d6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081da:	c1 d8       	rjmp	80008214 <_vfprintf_r+0x4b4>
800081dc:	fa c8 f9 50 	sub	r8,sp,-1712
800081e0:	1a d8       	st.w	--sp,r8
800081e2:	fa c8 fa b8 	sub	r8,sp,-1352
800081e6:	1a d8       	st.w	--sp,r8
800081e8:	fa c8 fb b4 	sub	r8,sp,-1100
800081ec:	1a d8       	st.w	--sp,r8
800081ee:	fa c8 f9 40 	sub	r8,sp,-1728
800081f2:	fa c9 ff b4 	sub	r9,sp,-76
800081f6:	04 9a       	mov	r10,r2
800081f8:	0c 9b       	mov	r11,r6
800081fa:	08 9c       	mov	r12,r4
800081fc:	fe b0 fc 1a 	rcall	80007a30 <get_arg>
80008200:	2f dd       	sub	sp,-12
80008202:	19 b8       	ld.ub	r8,r12[0x3]
80008204:	c2 28       	rjmp	80008248 <_vfprintf_r+0x4e8>
80008206:	2f f7       	sub	r7,-1
80008208:	10 39       	cp.w	r9,r8
8000820a:	c0 84       	brge	8000821a <_vfprintf_r+0x4ba>
8000820c:	fa ca f9 44 	sub	r10,sp,-1724
80008210:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008214:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008218:	c1 88       	rjmp	80008248 <_vfprintf_r+0x4e8>
8000821a:	41 09       	lddsp	r9,sp[0x40]
8000821c:	59 f8       	cp.w	r8,31
8000821e:	e0 89 00 12 	brgt	80008242 <_vfprintf_r+0x4e2>
80008222:	f2 ca ff fc 	sub	r10,r9,-4
80008226:	51 0a       	stdsp	sp[0x40],r10
80008228:	72 09       	ld.w	r9,r9[0x0]
8000822a:	fa c6 f9 44 	sub	r6,sp,-1724
8000822e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008232:	2f f8       	sub	r8,-1
80008234:	f5 49 fd 88 	st.w	r10[-632],r9
80008238:	fb 48 06 b4 	st.w	sp[1716],r8
8000823c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008240:	c0 48       	rjmp	80008248 <_vfprintf_r+0x4e8>
80008242:	13 b8       	ld.ub	r8,r9[0x3]
80008244:	2f c9       	sub	r9,-4
80008246:	51 09       	stdsp	sp[0x40],r9
80008248:	fb 68 06 60 	st.b	sp[1632],r8
8000824c:	30 0e       	mov	lr,0
8000824e:	30 08       	mov	r8,0
80008250:	30 12       	mov	r2,1
80008252:	fb 68 06 bb 	st.b	sp[1723],r8
80008256:	50 2e       	stdsp	sp[0x8],lr
80008258:	e0 8f 08 ad 	bral	800093b2 <_vfprintf_r+0x1652>
8000825c:	50 a7       	stdsp	sp[0x28],r7
8000825e:	50 80       	stdsp	sp[0x20],r0
80008260:	0c 97       	mov	r7,r6
80008262:	04 94       	mov	r4,r2
80008264:	06 96       	mov	r6,r3
80008266:	02 92       	mov	r2,r1
80008268:	40 93       	lddsp	r3,sp[0x24]
8000826a:	10 90       	mov	r0,r8
8000826c:	40 41       	lddsp	r1,sp[0x10]
8000826e:	a5 a5       	sbr	r5,0x4
80008270:	c0 a8       	rjmp	80008284 <_vfprintf_r+0x524>
80008272:	50 a7       	stdsp	sp[0x28],r7
80008274:	50 80       	stdsp	sp[0x20],r0
80008276:	0c 97       	mov	r7,r6
80008278:	04 94       	mov	r4,r2
8000827a:	06 96       	mov	r6,r3
8000827c:	02 92       	mov	r2,r1
8000827e:	40 93       	lddsp	r3,sp[0x24]
80008280:	10 90       	mov	r0,r8
80008282:	40 41       	lddsp	r1,sp[0x10]
80008284:	ed b5 00 05 	bld	r5,0x5
80008288:	c5 11       	brne	8000832a <_vfprintf_r+0x5ca>
8000828a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000828e:	40 3c       	lddsp	r12,sp[0xc]
80008290:	58 0c       	cp.w	r12,0
80008292:	c1 e0       	breq	800082ce <_vfprintf_r+0x56e>
80008294:	10 36       	cp.w	r6,r8
80008296:	c0 64       	brge	800082a2 <_vfprintf_r+0x542>
80008298:	fa cb f9 44 	sub	r11,sp,-1724
8000829c:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082a0:	c2 08       	rjmp	800082e0 <_vfprintf_r+0x580>
800082a2:	fa c8 f9 50 	sub	r8,sp,-1712
800082a6:	1a d8       	st.w	--sp,r8
800082a8:	fa c8 fa b8 	sub	r8,sp,-1352
800082ac:	0c 9b       	mov	r11,r6
800082ae:	1a d8       	st.w	--sp,r8
800082b0:	fa c8 fb b4 	sub	r8,sp,-1100
800082b4:	1a d8       	st.w	--sp,r8
800082b6:	fa c9 ff b4 	sub	r9,sp,-76
800082ba:	fa c8 f9 40 	sub	r8,sp,-1728
800082be:	04 9a       	mov	r10,r2
800082c0:	08 9c       	mov	r12,r4
800082c2:	fe b0 fb b7 	rcall	80007a30 <get_arg>
800082c6:	2f dd       	sub	sp,-12
800082c8:	78 1b       	ld.w	r11,r12[0x4]
800082ca:	78 09       	ld.w	r9,r12[0x0]
800082cc:	c2 b8       	rjmp	80008322 <_vfprintf_r+0x5c2>
800082ce:	ee ca ff ff 	sub	r10,r7,-1
800082d2:	10 37       	cp.w	r7,r8
800082d4:	c0 b4       	brge	800082ea <_vfprintf_r+0x58a>
800082d6:	fa c9 f9 44 	sub	r9,sp,-1724
800082da:	14 97       	mov	r7,r10
800082dc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082e0:	ec fb fd 8c 	ld.w	r11,r6[-628]
800082e4:	ec f9 fd 88 	ld.w	r9,r6[-632]
800082e8:	c1 d8       	rjmp	80008322 <_vfprintf_r+0x5c2>
800082ea:	41 09       	lddsp	r9,sp[0x40]
800082ec:	59 f8       	cp.w	r8,31
800082ee:	e0 89 00 14 	brgt	80008316 <_vfprintf_r+0x5b6>
800082f2:	f2 cb ff f8 	sub	r11,r9,-8
800082f6:	51 0b       	stdsp	sp[0x40],r11
800082f8:	fa c6 f9 44 	sub	r6,sp,-1724
800082fc:	72 1b       	ld.w	r11,r9[0x4]
800082fe:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008302:	72 09       	ld.w	r9,r9[0x0]
80008304:	f9 4b fd 8c 	st.w	r12[-628],r11
80008308:	f9 49 fd 88 	st.w	r12[-632],r9
8000830c:	2f f8       	sub	r8,-1
8000830e:	14 97       	mov	r7,r10
80008310:	fb 48 06 b4 	st.w	sp[1716],r8
80008314:	c0 78       	rjmp	80008322 <_vfprintf_r+0x5c2>
80008316:	f2 c8 ff f8 	sub	r8,r9,-8
8000831a:	72 1b       	ld.w	r11,r9[0x4]
8000831c:	14 97       	mov	r7,r10
8000831e:	51 08       	stdsp	sp[0x40],r8
80008320:	72 09       	ld.w	r9,r9[0x0]
80008322:	16 98       	mov	r8,r11
80008324:	fa e9 00 00 	st.d	sp[0],r8
80008328:	ca e8       	rjmp	80008484 <_vfprintf_r+0x724>
8000832a:	ed b5 00 04 	bld	r5,0x4
8000832e:	c1 71       	brne	8000835c <_vfprintf_r+0x5fc>
80008330:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008334:	40 3e       	lddsp	lr,sp[0xc]
80008336:	58 0e       	cp.w	lr,0
80008338:	c0 80       	breq	80008348 <_vfprintf_r+0x5e8>
8000833a:	10 36       	cp.w	r6,r8
8000833c:	c6 94       	brge	8000840e <_vfprintf_r+0x6ae>
8000833e:	fa cc f9 44 	sub	r12,sp,-1724
80008342:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008346:	c8 28       	rjmp	8000844a <_vfprintf_r+0x6ea>
80008348:	ee ca ff ff 	sub	r10,r7,-1
8000834c:	10 37       	cp.w	r7,r8
8000834e:	e0 84 00 81 	brge	80008450 <_vfprintf_r+0x6f0>
80008352:	fa cb f9 44 	sub	r11,sp,-1724
80008356:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000835a:	c7 78       	rjmp	80008448 <_vfprintf_r+0x6e8>
8000835c:	ed b5 00 06 	bld	r5,0x6
80008360:	c4 b1       	brne	800083f6 <_vfprintf_r+0x696>
80008362:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008366:	40 3c       	lddsp	r12,sp[0xc]
80008368:	58 0c       	cp.w	r12,0
8000836a:	c1 d0       	breq	800083a4 <_vfprintf_r+0x644>
8000836c:	10 36       	cp.w	r6,r8
8000836e:	c0 64       	brge	8000837a <_vfprintf_r+0x61a>
80008370:	fa cb f9 44 	sub	r11,sp,-1724
80008374:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008378:	c1 f8       	rjmp	800083b6 <_vfprintf_r+0x656>
8000837a:	fa c8 f9 50 	sub	r8,sp,-1712
8000837e:	1a d8       	st.w	--sp,r8
80008380:	fa c8 fa b8 	sub	r8,sp,-1352
80008384:	1a d8       	st.w	--sp,r8
80008386:	fa c8 fb b4 	sub	r8,sp,-1100
8000838a:	1a d8       	st.w	--sp,r8
8000838c:	fa c8 f9 40 	sub	r8,sp,-1728
80008390:	fa c9 ff b4 	sub	r9,sp,-76
80008394:	04 9a       	mov	r10,r2
80008396:	0c 9b       	mov	r11,r6
80008398:	08 9c       	mov	r12,r4
8000839a:	fe b0 fb 4b 	rcall	80007a30 <get_arg>
8000839e:	2f dd       	sub	sp,-12
800083a0:	98 18       	ld.sh	r8,r12[0x2]
800083a2:	c2 68       	rjmp	800083ee <_vfprintf_r+0x68e>
800083a4:	ee ca ff ff 	sub	r10,r7,-1
800083a8:	10 37       	cp.w	r7,r8
800083aa:	c0 94       	brge	800083bc <_vfprintf_r+0x65c>
800083ac:	fa c9 f9 44 	sub	r9,sp,-1724
800083b0:	14 97       	mov	r7,r10
800083b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083b6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800083ba:	c1 a8       	rjmp	800083ee <_vfprintf_r+0x68e>
800083bc:	41 09       	lddsp	r9,sp[0x40]
800083be:	59 f8       	cp.w	r8,31
800083c0:	e0 89 00 13 	brgt	800083e6 <_vfprintf_r+0x686>
800083c4:	f2 cb ff fc 	sub	r11,r9,-4
800083c8:	51 0b       	stdsp	sp[0x40],r11
800083ca:	72 09       	ld.w	r9,r9[0x0]
800083cc:	fa c6 f9 44 	sub	r6,sp,-1724
800083d0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800083d4:	2f f8       	sub	r8,-1
800083d6:	f7 49 fd 88 	st.w	r11[-632],r9
800083da:	fb 48 06 b4 	st.w	sp[1716],r8
800083de:	14 97       	mov	r7,r10
800083e0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800083e4:	c0 58       	rjmp	800083ee <_vfprintf_r+0x68e>
800083e6:	92 18       	ld.sh	r8,r9[0x2]
800083e8:	14 97       	mov	r7,r10
800083ea:	2f c9       	sub	r9,-4
800083ec:	51 09       	stdsp	sp[0x40],r9
800083ee:	50 18       	stdsp	sp[0x4],r8
800083f0:	bf 58       	asr	r8,0x1f
800083f2:	50 08       	stdsp	sp[0x0],r8
800083f4:	c4 88       	rjmp	80008484 <_vfprintf_r+0x724>
800083f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083fa:	40 3c       	lddsp	r12,sp[0xc]
800083fc:	58 0c       	cp.w	r12,0
800083fe:	c1 d0       	breq	80008438 <_vfprintf_r+0x6d8>
80008400:	10 36       	cp.w	r6,r8
80008402:	c0 64       	brge	8000840e <_vfprintf_r+0x6ae>
80008404:	fa cb f9 44 	sub	r11,sp,-1724
80008408:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000840c:	c1 f8       	rjmp	8000844a <_vfprintf_r+0x6ea>
8000840e:	fa c8 f9 50 	sub	r8,sp,-1712
80008412:	1a d8       	st.w	--sp,r8
80008414:	fa c8 fa b8 	sub	r8,sp,-1352
80008418:	0c 9b       	mov	r11,r6
8000841a:	1a d8       	st.w	--sp,r8
8000841c:	fa c8 fb b4 	sub	r8,sp,-1100
80008420:	04 9a       	mov	r10,r2
80008422:	1a d8       	st.w	--sp,r8
80008424:	08 9c       	mov	r12,r4
80008426:	fa c8 f9 40 	sub	r8,sp,-1728
8000842a:	fa c9 ff b4 	sub	r9,sp,-76
8000842e:	fe b0 fb 01 	rcall	80007a30 <get_arg>
80008432:	2f dd       	sub	sp,-12
80008434:	78 0b       	ld.w	r11,r12[0x0]
80008436:	c2 48       	rjmp	8000847e <_vfprintf_r+0x71e>
80008438:	ee ca ff ff 	sub	r10,r7,-1
8000843c:	10 37       	cp.w	r7,r8
8000843e:	c0 94       	brge	80008450 <_vfprintf_r+0x6f0>
80008440:	fa c9 f9 44 	sub	r9,sp,-1724
80008444:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008448:	14 97       	mov	r7,r10
8000844a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000844e:	c1 88       	rjmp	8000847e <_vfprintf_r+0x71e>
80008450:	41 09       	lddsp	r9,sp[0x40]
80008452:	59 f8       	cp.w	r8,31
80008454:	e0 89 00 11 	brgt	80008476 <_vfprintf_r+0x716>
80008458:	f2 cb ff fc 	sub	r11,r9,-4
8000845c:	51 0b       	stdsp	sp[0x40],r11
8000845e:	fa c6 f9 44 	sub	r6,sp,-1724
80008462:	72 0b       	ld.w	r11,r9[0x0]
80008464:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008468:	f3 4b fd 88 	st.w	r9[-632],r11
8000846c:	2f f8       	sub	r8,-1
8000846e:	14 97       	mov	r7,r10
80008470:	fb 48 06 b4 	st.w	sp[1716],r8
80008474:	c0 58       	rjmp	8000847e <_vfprintf_r+0x71e>
80008476:	72 0b       	ld.w	r11,r9[0x0]
80008478:	14 97       	mov	r7,r10
8000847a:	2f c9       	sub	r9,-4
8000847c:	51 09       	stdsp	sp[0x40],r9
8000847e:	50 1b       	stdsp	sp[0x4],r11
80008480:	bf 5b       	asr	r11,0x1f
80008482:	50 0b       	stdsp	sp[0x0],r11
80008484:	fa ea 00 00 	ld.d	r10,sp[0]
80008488:	58 0a       	cp.w	r10,0
8000848a:	5c 2b       	cpc	r11
8000848c:	c0 e4       	brge	800084a8 <_vfprintf_r+0x748>
8000848e:	30 08       	mov	r8,0
80008490:	fa ea 00 00 	ld.d	r10,sp[0]
80008494:	30 09       	mov	r9,0
80008496:	f0 0a 01 0a 	sub	r10,r8,r10
8000849a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000849e:	32 d8       	mov	r8,45
800084a0:	fa eb 00 00 	st.d	sp[0],r10
800084a4:	fb 68 06 bb 	st.b	sp[1723],r8
800084a8:	30 18       	mov	r8,1
800084aa:	e0 8f 06 fa 	bral	8000929e <_vfprintf_r+0x153e>
800084ae:	50 a7       	stdsp	sp[0x28],r7
800084b0:	50 80       	stdsp	sp[0x20],r0
800084b2:	0c 97       	mov	r7,r6
800084b4:	04 94       	mov	r4,r2
800084b6:	06 96       	mov	r6,r3
800084b8:	02 92       	mov	r2,r1
800084ba:	40 93       	lddsp	r3,sp[0x24]
800084bc:	10 90       	mov	r0,r8
800084be:	40 41       	lddsp	r1,sp[0x10]
800084c0:	0e 99       	mov	r9,r7
800084c2:	ed b5 00 03 	bld	r5,0x3
800084c6:	c4 11       	brne	80008548 <_vfprintf_r+0x7e8>
800084c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084cc:	40 3a       	lddsp	r10,sp[0xc]
800084ce:	58 0a       	cp.w	r10,0
800084d0:	c1 90       	breq	80008502 <_vfprintf_r+0x7a2>
800084d2:	10 36       	cp.w	r6,r8
800084d4:	c6 45       	brlt	8000859c <_vfprintf_r+0x83c>
800084d6:	fa c8 f9 50 	sub	r8,sp,-1712
800084da:	1a d8       	st.w	--sp,r8
800084dc:	fa c8 fa b8 	sub	r8,sp,-1352
800084e0:	1a d8       	st.w	--sp,r8
800084e2:	fa c8 fb b4 	sub	r8,sp,-1100
800084e6:	0c 9b       	mov	r11,r6
800084e8:	1a d8       	st.w	--sp,r8
800084ea:	04 9a       	mov	r10,r2
800084ec:	fa c8 f9 40 	sub	r8,sp,-1728
800084f0:	fa c9 ff b4 	sub	r9,sp,-76
800084f4:	08 9c       	mov	r12,r4
800084f6:	fe b0 fa 9d 	rcall	80007a30 <get_arg>
800084fa:	2f dd       	sub	sp,-12
800084fc:	78 16       	ld.w	r6,r12[0x4]
800084fe:	50 76       	stdsp	sp[0x1c],r6
80008500:	c4 88       	rjmp	80008590 <_vfprintf_r+0x830>
80008502:	2f f7       	sub	r7,-1
80008504:	10 39       	cp.w	r9,r8
80008506:	c0 c4       	brge	8000851e <_vfprintf_r+0x7be>
80008508:	fa ce f9 44 	sub	lr,sp,-1724
8000850c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008510:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008514:	50 7c       	stdsp	sp[0x1c],r12
80008516:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000851a:	50 56       	stdsp	sp[0x14],r6
8000851c:	c6 68       	rjmp	800085e8 <_vfprintf_r+0x888>
8000851e:	41 09       	lddsp	r9,sp[0x40]
80008520:	59 f8       	cp.w	r8,31
80008522:	e0 89 00 10 	brgt	80008542 <_vfprintf_r+0x7e2>
80008526:	f2 ca ff f8 	sub	r10,r9,-8
8000852a:	72 1b       	ld.w	r11,r9[0x4]
8000852c:	51 0a       	stdsp	sp[0x40],r10
8000852e:	72 09       	ld.w	r9,r9[0x0]
80008530:	fa ca f9 44 	sub	r10,sp,-1724
80008534:	50 7b       	stdsp	sp[0x1c],r11
80008536:	50 59       	stdsp	sp[0x14],r9
80008538:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000853c:	40 5b       	lddsp	r11,sp[0x14]
8000853e:	40 7a       	lddsp	r10,sp[0x1c]
80008540:	c4 78       	rjmp	800085ce <_vfprintf_r+0x86e>
80008542:	72 18       	ld.w	r8,r9[0x4]
80008544:	50 78       	stdsp	sp[0x1c],r8
80008546:	c4 c8       	rjmp	800085de <_vfprintf_r+0x87e>
80008548:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000854c:	40 3e       	lddsp	lr,sp[0xc]
8000854e:	58 0e       	cp.w	lr,0
80008550:	c2 30       	breq	80008596 <_vfprintf_r+0x836>
80008552:	10 36       	cp.w	r6,r8
80008554:	c0 94       	brge	80008566 <_vfprintf_r+0x806>
80008556:	fa cc f9 44 	sub	r12,sp,-1724
8000855a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000855e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008562:	50 7b       	stdsp	sp[0x1c],r11
80008564:	cd 9b       	rjmp	80008516 <_vfprintf_r+0x7b6>
80008566:	fa c8 f9 50 	sub	r8,sp,-1712
8000856a:	1a d8       	st.w	--sp,r8
8000856c:	fa c8 fa b8 	sub	r8,sp,-1352
80008570:	04 9a       	mov	r10,r2
80008572:	1a d8       	st.w	--sp,r8
80008574:	fa c8 fb b4 	sub	r8,sp,-1100
80008578:	0c 9b       	mov	r11,r6
8000857a:	1a d8       	st.w	--sp,r8
8000857c:	08 9c       	mov	r12,r4
8000857e:	fa c8 f9 40 	sub	r8,sp,-1728
80008582:	fa c9 ff b4 	sub	r9,sp,-76
80008586:	fe b0 fa 55 	rcall	80007a30 <get_arg>
8000858a:	2f dd       	sub	sp,-12
8000858c:	78 1a       	ld.w	r10,r12[0x4]
8000858e:	50 7a       	stdsp	sp[0x1c],r10
80008590:	78 0c       	ld.w	r12,r12[0x0]
80008592:	50 5c       	stdsp	sp[0x14],r12
80008594:	c2 a8       	rjmp	800085e8 <_vfprintf_r+0x888>
80008596:	2f f7       	sub	r7,-1
80008598:	10 39       	cp.w	r9,r8
8000859a:	c0 94       	brge	800085ac <_vfprintf_r+0x84c>
8000859c:	fa c9 f9 44 	sub	r9,sp,-1724
800085a0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085a4:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800085a8:	50 78       	stdsp	sp[0x1c],r8
800085aa:	cb 6b       	rjmp	80008516 <_vfprintf_r+0x7b6>
800085ac:	41 09       	lddsp	r9,sp[0x40]
800085ae:	59 f8       	cp.w	r8,31
800085b0:	e0 89 00 15 	brgt	800085da <_vfprintf_r+0x87a>
800085b4:	f2 ca ff f8 	sub	r10,r9,-8
800085b8:	72 16       	ld.w	r6,r9[0x4]
800085ba:	72 09       	ld.w	r9,r9[0x0]
800085bc:	51 0a       	stdsp	sp[0x40],r10
800085be:	50 59       	stdsp	sp[0x14],r9
800085c0:	fa ce f9 44 	sub	lr,sp,-1724
800085c4:	50 76       	stdsp	sp[0x1c],r6
800085c6:	fc 08 00 39 	add	r9,lr,r8<<0x3
800085ca:	40 5b       	lddsp	r11,sp[0x14]
800085cc:	0c 9a       	mov	r10,r6
800085ce:	f2 eb fd 88 	st.d	r9[-632],r10
800085d2:	2f f8       	sub	r8,-1
800085d4:	fb 48 06 b4 	st.w	sp[1716],r8
800085d8:	c0 88       	rjmp	800085e8 <_vfprintf_r+0x888>
800085da:	72 1c       	ld.w	r12,r9[0x4]
800085dc:	50 7c       	stdsp	sp[0x1c],r12
800085de:	f2 c8 ff f8 	sub	r8,r9,-8
800085e2:	51 08       	stdsp	sp[0x40],r8
800085e4:	72 09       	ld.w	r9,r9[0x0]
800085e6:	50 59       	stdsp	sp[0x14],r9
800085e8:	40 5b       	lddsp	r11,sp[0x14]
800085ea:	40 7a       	lddsp	r10,sp[0x1c]
800085ec:	e0 a0 19 54 	rcall	8000b894 <__isinfd>
800085f0:	18 96       	mov	r6,r12
800085f2:	c1 70       	breq	80008620 <_vfprintf_r+0x8c0>
800085f4:	30 08       	mov	r8,0
800085f6:	30 09       	mov	r9,0
800085f8:	40 5b       	lddsp	r11,sp[0x14]
800085fa:	40 7a       	lddsp	r10,sp[0x1c]
800085fc:	e0 a0 1d b4 	rcall	8000c164 <__avr32_f64_cmp_lt>
80008600:	c0 40       	breq	80008608 <_vfprintf_r+0x8a8>
80008602:	32 d8       	mov	r8,45
80008604:	fb 68 06 bb 	st.b	sp[1723],r8
80008608:	fe c8 a5 5c 	sub	r8,pc,-23204
8000860c:	fe c6 a5 5c 	sub	r6,pc,-23204
80008610:	a7 d5       	cbr	r5,0x7
80008612:	e0 40 00 47 	cp.w	r0,71
80008616:	f0 06 17 a0 	movle	r6,r8
8000861a:	30 32       	mov	r2,3
8000861c:	e0 8f 06 ce 	bral	800093b8 <_vfprintf_r+0x1658>
80008620:	40 5b       	lddsp	r11,sp[0x14]
80008622:	40 7a       	lddsp	r10,sp[0x1c]
80008624:	e0 a0 19 4d 	rcall	8000b8be <__isnand>
80008628:	c0 e0       	breq	80008644 <_vfprintf_r+0x8e4>
8000862a:	50 26       	stdsp	sp[0x8],r6
8000862c:	fe c8 a5 78 	sub	r8,pc,-23176
80008630:	fe c6 a5 78 	sub	r6,pc,-23176
80008634:	a7 d5       	cbr	r5,0x7
80008636:	e0 40 00 47 	cp.w	r0,71
8000863a:	f0 06 17 a0 	movle	r6,r8
8000863e:	30 32       	mov	r2,3
80008640:	e0 8f 06 c2 	bral	800093c4 <_vfprintf_r+0x1664>
80008644:	40 2a       	lddsp	r10,sp[0x8]
80008646:	5b fa       	cp.w	r10,-1
80008648:	c0 41       	brne	80008650 <_vfprintf_r+0x8f0>
8000864a:	30 69       	mov	r9,6
8000864c:	50 29       	stdsp	sp[0x8],r9
8000864e:	c1 18       	rjmp	80008670 <_vfprintf_r+0x910>
80008650:	e0 40 00 47 	cp.w	r0,71
80008654:	5f 09       	sreq	r9
80008656:	e0 40 00 67 	cp.w	r0,103
8000865a:	5f 08       	sreq	r8
8000865c:	f3 e8 10 08 	or	r8,r9,r8
80008660:	f8 08 18 00 	cp.b	r8,r12
80008664:	c0 60       	breq	80008670 <_vfprintf_r+0x910>
80008666:	40 28       	lddsp	r8,sp[0x8]
80008668:	58 08       	cp.w	r8,0
8000866a:	f9 b8 00 01 	moveq	r8,1
8000866e:	50 28       	stdsp	sp[0x8],r8
80008670:	40 78       	lddsp	r8,sp[0x1c]
80008672:	40 59       	lddsp	r9,sp[0x14]
80008674:	fa e9 06 94 	st.d	sp[1684],r8
80008678:	a9 a5       	sbr	r5,0x8
8000867a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000867e:	58 08       	cp.w	r8,0
80008680:	c0 65       	brlt	8000868c <_vfprintf_r+0x92c>
80008682:	40 5e       	lddsp	lr,sp[0x14]
80008684:	30 0c       	mov	r12,0
80008686:	50 6e       	stdsp	sp[0x18],lr
80008688:	50 9c       	stdsp	sp[0x24],r12
8000868a:	c0 78       	rjmp	80008698 <_vfprintf_r+0x938>
8000868c:	40 5b       	lddsp	r11,sp[0x14]
8000868e:	32 da       	mov	r10,45
80008690:	ee 1b 80 00 	eorh	r11,0x8000
80008694:	50 9a       	stdsp	sp[0x24],r10
80008696:	50 6b       	stdsp	sp[0x18],r11
80008698:	e0 40 00 46 	cp.w	r0,70
8000869c:	5f 09       	sreq	r9
8000869e:	e0 40 00 66 	cp.w	r0,102
800086a2:	5f 08       	sreq	r8
800086a4:	f3 e8 10 08 	or	r8,r9,r8
800086a8:	50 48       	stdsp	sp[0x10],r8
800086aa:	c0 40       	breq	800086b2 <_vfprintf_r+0x952>
800086ac:	40 22       	lddsp	r2,sp[0x8]
800086ae:	30 39       	mov	r9,3
800086b0:	c1 08       	rjmp	800086d0 <_vfprintf_r+0x970>
800086b2:	e0 40 00 45 	cp.w	r0,69
800086b6:	5f 09       	sreq	r9
800086b8:	e0 40 00 65 	cp.w	r0,101
800086bc:	5f 08       	sreq	r8
800086be:	40 22       	lddsp	r2,sp[0x8]
800086c0:	10 49       	or	r9,r8
800086c2:	2f f2       	sub	r2,-1
800086c4:	40 46       	lddsp	r6,sp[0x10]
800086c6:	ec 09 18 00 	cp.b	r9,r6
800086ca:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800086ce:	30 29       	mov	r9,2
800086d0:	fa c8 f9 5c 	sub	r8,sp,-1700
800086d4:	1a d8       	st.w	--sp,r8
800086d6:	fa c8 f9 54 	sub	r8,sp,-1708
800086da:	1a d8       	st.w	--sp,r8
800086dc:	fa c8 f9 4c 	sub	r8,sp,-1716
800086e0:	08 9c       	mov	r12,r4
800086e2:	1a d8       	st.w	--sp,r8
800086e4:	04 98       	mov	r8,r2
800086e6:	40 9b       	lddsp	r11,sp[0x24]
800086e8:	40 aa       	lddsp	r10,sp[0x28]
800086ea:	e0 a0 0b c3 	rcall	80009e70 <_dtoa_r>
800086ee:	e0 40 00 47 	cp.w	r0,71
800086f2:	5f 19       	srne	r9
800086f4:	e0 40 00 67 	cp.w	r0,103
800086f8:	5f 18       	srne	r8
800086fa:	18 96       	mov	r6,r12
800086fc:	2f dd       	sub	sp,-12
800086fe:	f3 e8 00 08 	and	r8,r9,r8
80008702:	c0 41       	brne	8000870a <_vfprintf_r+0x9aa>
80008704:	ed b5 00 00 	bld	r5,0x0
80008708:	c3 01       	brne	80008768 <_vfprintf_r+0xa08>
8000870a:	ec 02 00 0e 	add	lr,r6,r2
8000870e:	50 3e       	stdsp	sp[0xc],lr
80008710:	40 4c       	lddsp	r12,sp[0x10]
80008712:	58 0c       	cp.w	r12,0
80008714:	c1 50       	breq	8000873e <_vfprintf_r+0x9de>
80008716:	0d 89       	ld.ub	r9,r6[0x0]
80008718:	33 08       	mov	r8,48
8000871a:	f0 09 18 00 	cp.b	r9,r8
8000871e:	c0 b1       	brne	80008734 <_vfprintf_r+0x9d4>
80008720:	30 08       	mov	r8,0
80008722:	30 09       	mov	r9,0
80008724:	40 6b       	lddsp	r11,sp[0x18]
80008726:	40 7a       	lddsp	r10,sp[0x1c]
80008728:	e0 a0 1c d7 	rcall	8000c0d6 <__avr32_f64_cmp_eq>
8000872c:	fb b2 00 01 	rsubeq	r2,1
80008730:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008734:	40 3b       	lddsp	r11,sp[0xc]
80008736:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000873a:	10 0b       	add	r11,r8
8000873c:	50 3b       	stdsp	sp[0xc],r11
8000873e:	40 6b       	lddsp	r11,sp[0x18]
80008740:	30 08       	mov	r8,0
80008742:	30 09       	mov	r9,0
80008744:	40 7a       	lddsp	r10,sp[0x1c]
80008746:	e0 a0 1c c8 	rcall	8000c0d6 <__avr32_f64_cmp_eq>
8000874a:	c0 90       	breq	8000875c <_vfprintf_r+0x9fc>
8000874c:	40 3a       	lddsp	r10,sp[0xc]
8000874e:	fb 4a 06 a4 	st.w	sp[1700],r10
80008752:	c0 58       	rjmp	8000875c <_vfprintf_r+0x9fc>
80008754:	10 c9       	st.b	r8++,r9
80008756:	fb 48 06 a4 	st.w	sp[1700],r8
8000875a:	c0 28       	rjmp	8000875e <_vfprintf_r+0x9fe>
8000875c:	33 09       	mov	r9,48
8000875e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008762:	40 3e       	lddsp	lr,sp[0xc]
80008764:	1c 38       	cp.w	r8,lr
80008766:	cf 73       	brcs	80008754 <_vfprintf_r+0x9f4>
80008768:	e0 40 00 47 	cp.w	r0,71
8000876c:	5f 09       	sreq	r9
8000876e:	e0 40 00 67 	cp.w	r0,103
80008772:	5f 08       	sreq	r8
80008774:	f3 e8 10 08 	or	r8,r9,r8
80008778:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000877c:	0c 19       	sub	r9,r6
8000877e:	50 69       	stdsp	sp[0x18],r9
80008780:	58 08       	cp.w	r8,0
80008782:	c0 b0       	breq	80008798 <_vfprintf_r+0xa38>
80008784:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008788:	5b d8       	cp.w	r8,-3
8000878a:	c0 55       	brlt	80008794 <_vfprintf_r+0xa34>
8000878c:	40 2c       	lddsp	r12,sp[0x8]
8000878e:	18 38       	cp.w	r8,r12
80008790:	e0 8a 00 6a 	brle	80008864 <_vfprintf_r+0xb04>
80008794:	20 20       	sub	r0,2
80008796:	c0 58       	rjmp	800087a0 <_vfprintf_r+0xa40>
80008798:	e0 40 00 65 	cp.w	r0,101
8000879c:	e0 89 00 46 	brgt	80008828 <_vfprintf_r+0xac8>
800087a0:	fa fb 06 ac 	ld.w	r11,sp[1708]
800087a4:	fb 60 06 9c 	st.b	sp[1692],r0
800087a8:	20 1b       	sub	r11,1
800087aa:	fb 4b 06 ac 	st.w	sp[1708],r11
800087ae:	c0 47       	brpl	800087b6 <_vfprintf_r+0xa56>
800087b0:	5c 3b       	neg	r11
800087b2:	32 d8       	mov	r8,45
800087b4:	c0 28       	rjmp	800087b8 <_vfprintf_r+0xa58>
800087b6:	32 b8       	mov	r8,43
800087b8:	fb 68 06 9d 	st.b	sp[1693],r8
800087bc:	58 9b       	cp.w	r11,9
800087be:	e0 8a 00 1d 	brle	800087f8 <_vfprintf_r+0xa98>
800087c2:	fa c9 fa 35 	sub	r9,sp,-1483
800087c6:	30 aa       	mov	r10,10
800087c8:	12 98       	mov	r8,r9
800087ca:	0e 9c       	mov	r12,r7
800087cc:	0c 92       	mov	r2,r6
800087ce:	f6 0a 0c 06 	divs	r6,r11,r10
800087d2:	0e 9b       	mov	r11,r7
800087d4:	2d 0b       	sub	r11,-48
800087d6:	10 fb       	st.b	--r8,r11
800087d8:	0c 9b       	mov	r11,r6
800087da:	58 96       	cp.w	r6,9
800087dc:	fe 99 ff f9 	brgt	800087ce <_vfprintf_r+0xa6e>
800087e0:	2d 0b       	sub	r11,-48
800087e2:	18 97       	mov	r7,r12
800087e4:	04 96       	mov	r6,r2
800087e6:	10 fb       	st.b	--r8,r11
800087e8:	fa ca f9 62 	sub	r10,sp,-1694
800087ec:	c0 38       	rjmp	800087f2 <_vfprintf_r+0xa92>
800087ee:	11 3b       	ld.ub	r11,r8++
800087f0:	14 cb       	st.b	r10++,r11
800087f2:	12 38       	cp.w	r8,r9
800087f4:	cf d3       	brcs	800087ee <_vfprintf_r+0xa8e>
800087f6:	c0 98       	rjmp	80008808 <_vfprintf_r+0xaa8>
800087f8:	2d 0b       	sub	r11,-48
800087fa:	33 08       	mov	r8,48
800087fc:	fb 6b 06 9f 	st.b	sp[1695],r11
80008800:	fb 68 06 9e 	st.b	sp[1694],r8
80008804:	fa ca f9 60 	sub	r10,sp,-1696
80008808:	fa c8 f9 64 	sub	r8,sp,-1692
8000880c:	f4 08 01 08 	sub	r8,r10,r8
80008810:	50 e8       	stdsp	sp[0x38],r8
80008812:	10 92       	mov	r2,r8
80008814:	40 6b       	lddsp	r11,sp[0x18]
80008816:	16 02       	add	r2,r11
80008818:	58 1b       	cp.w	r11,1
8000881a:	e0 89 00 05 	brgt	80008824 <_vfprintf_r+0xac4>
8000881e:	ed b5 00 00 	bld	r5,0x0
80008822:	c3 51       	brne	8000888c <_vfprintf_r+0xb2c>
80008824:	2f f2       	sub	r2,-1
80008826:	c3 38       	rjmp	8000888c <_vfprintf_r+0xb2c>
80008828:	e0 40 00 66 	cp.w	r0,102
8000882c:	c1 c1       	brne	80008864 <_vfprintf_r+0xb04>
8000882e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008832:	58 02       	cp.w	r2,0
80008834:	e0 8a 00 0c 	brle	8000884c <_vfprintf_r+0xaec>
80008838:	40 2a       	lddsp	r10,sp[0x8]
8000883a:	58 0a       	cp.w	r10,0
8000883c:	c0 41       	brne	80008844 <_vfprintf_r+0xae4>
8000883e:	ed b5 00 00 	bld	r5,0x0
80008842:	c2 51       	brne	8000888c <_vfprintf_r+0xb2c>
80008844:	2f f2       	sub	r2,-1
80008846:	40 29       	lddsp	r9,sp[0x8]
80008848:	12 02       	add	r2,r9
8000884a:	c0 b8       	rjmp	80008860 <_vfprintf_r+0xb00>
8000884c:	40 28       	lddsp	r8,sp[0x8]
8000884e:	58 08       	cp.w	r8,0
80008850:	c0 61       	brne	8000885c <_vfprintf_r+0xafc>
80008852:	ed b5 00 00 	bld	r5,0x0
80008856:	c0 30       	breq	8000885c <_vfprintf_r+0xafc>
80008858:	30 12       	mov	r2,1
8000885a:	c1 98       	rjmp	8000888c <_vfprintf_r+0xb2c>
8000885c:	40 22       	lddsp	r2,sp[0x8]
8000885e:	2f e2       	sub	r2,-2
80008860:	36 60       	mov	r0,102
80008862:	c1 58       	rjmp	8000888c <_vfprintf_r+0xb2c>
80008864:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008868:	40 6e       	lddsp	lr,sp[0x18]
8000886a:	1c 32       	cp.w	r2,lr
8000886c:	c0 65       	brlt	80008878 <_vfprintf_r+0xb18>
8000886e:	ed b5 00 00 	bld	r5,0x0
80008872:	f7 b2 00 ff 	subeq	r2,-1
80008876:	c0 a8       	rjmp	8000888a <_vfprintf_r+0xb2a>
80008878:	e4 08 11 02 	rsub	r8,r2,2
8000887c:	40 6c       	lddsp	r12,sp[0x18]
8000887e:	58 02       	cp.w	r2,0
80008880:	f0 02 17 a0 	movle	r2,r8
80008884:	f9 b2 09 01 	movgt	r2,1
80008888:	18 02       	add	r2,r12
8000888a:	36 70       	mov	r0,103
8000888c:	40 9b       	lddsp	r11,sp[0x24]
8000888e:	58 0b       	cp.w	r11,0
80008890:	e0 80 05 94 	breq	800093b8 <_vfprintf_r+0x1658>
80008894:	32 d8       	mov	r8,45
80008896:	fb 68 06 bb 	st.b	sp[1723],r8
8000889a:	e0 8f 05 93 	bral	800093c0 <_vfprintf_r+0x1660>
8000889e:	50 a7       	stdsp	sp[0x28],r7
800088a0:	04 94       	mov	r4,r2
800088a2:	0c 97       	mov	r7,r6
800088a4:	02 92       	mov	r2,r1
800088a6:	06 96       	mov	r6,r3
800088a8:	40 41       	lddsp	r1,sp[0x10]
800088aa:	40 93       	lddsp	r3,sp[0x24]
800088ac:	0e 99       	mov	r9,r7
800088ae:	ed b5 00 05 	bld	r5,0x5
800088b2:	c4 81       	brne	80008942 <_vfprintf_r+0xbe2>
800088b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088b8:	40 3e       	lddsp	lr,sp[0xc]
800088ba:	58 0e       	cp.w	lr,0
800088bc:	c1 d0       	breq	800088f6 <_vfprintf_r+0xb96>
800088be:	10 36       	cp.w	r6,r8
800088c0:	c0 64       	brge	800088cc <_vfprintf_r+0xb6c>
800088c2:	fa cc f9 44 	sub	r12,sp,-1724
800088c6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800088ca:	c1 d8       	rjmp	80008904 <_vfprintf_r+0xba4>
800088cc:	fa c8 f9 50 	sub	r8,sp,-1712
800088d0:	1a d8       	st.w	--sp,r8
800088d2:	fa c8 fa b8 	sub	r8,sp,-1352
800088d6:	04 9a       	mov	r10,r2
800088d8:	1a d8       	st.w	--sp,r8
800088da:	fa c8 fb b4 	sub	r8,sp,-1100
800088de:	0c 9b       	mov	r11,r6
800088e0:	1a d8       	st.w	--sp,r8
800088e2:	08 9c       	mov	r12,r4
800088e4:	fa c8 f9 40 	sub	r8,sp,-1728
800088e8:	fa c9 ff b4 	sub	r9,sp,-76
800088ec:	fe b0 f8 a2 	rcall	80007a30 <get_arg>
800088f0:	2f dd       	sub	sp,-12
800088f2:	78 0a       	ld.w	r10,r12[0x0]
800088f4:	c2 08       	rjmp	80008934 <_vfprintf_r+0xbd4>
800088f6:	2f f7       	sub	r7,-1
800088f8:	10 39       	cp.w	r9,r8
800088fa:	c0 84       	brge	8000890a <_vfprintf_r+0xbaa>
800088fc:	fa cb f9 44 	sub	r11,sp,-1724
80008900:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008904:	ec fa fd 88 	ld.w	r10,r6[-632]
80008908:	c1 68       	rjmp	80008934 <_vfprintf_r+0xbd4>
8000890a:	41 09       	lddsp	r9,sp[0x40]
8000890c:	59 f8       	cp.w	r8,31
8000890e:	e0 89 00 10 	brgt	8000892e <_vfprintf_r+0xbce>
80008912:	f2 ca ff fc 	sub	r10,r9,-4
80008916:	51 0a       	stdsp	sp[0x40],r10
80008918:	fa c6 f9 44 	sub	r6,sp,-1724
8000891c:	72 0a       	ld.w	r10,r9[0x0]
8000891e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008922:	f3 4a fd 88 	st.w	r9[-632],r10
80008926:	2f f8       	sub	r8,-1
80008928:	fb 48 06 b4 	st.w	sp[1716],r8
8000892c:	c0 48       	rjmp	80008934 <_vfprintf_r+0xbd4>
8000892e:	72 0a       	ld.w	r10,r9[0x0]
80008930:	2f c9       	sub	r9,-4
80008932:	51 09       	stdsp	sp[0x40],r9
80008934:	40 be       	lddsp	lr,sp[0x2c]
80008936:	1c 98       	mov	r8,lr
80008938:	95 1e       	st.w	r10[0x4],lr
8000893a:	bf 58       	asr	r8,0x1f
8000893c:	95 08       	st.w	r10[0x0],r8
8000893e:	fe 9f fa 9f 	bral	80007e7c <_vfprintf_r+0x11c>
80008942:	ed b5 00 04 	bld	r5,0x4
80008946:	c4 80       	breq	800089d6 <_vfprintf_r+0xc76>
80008948:	e2 15 00 40 	andl	r5,0x40,COH
8000894c:	c4 50       	breq	800089d6 <_vfprintf_r+0xc76>
8000894e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008952:	40 3c       	lddsp	r12,sp[0xc]
80008954:	58 0c       	cp.w	r12,0
80008956:	c1 d0       	breq	80008990 <_vfprintf_r+0xc30>
80008958:	10 36       	cp.w	r6,r8
8000895a:	c0 64       	brge	80008966 <_vfprintf_r+0xc06>
8000895c:	fa cb f9 44 	sub	r11,sp,-1724
80008960:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008964:	c1 d8       	rjmp	8000899e <_vfprintf_r+0xc3e>
80008966:	fa c8 f9 50 	sub	r8,sp,-1712
8000896a:	1a d8       	st.w	--sp,r8
8000896c:	fa c8 fa b8 	sub	r8,sp,-1352
80008970:	04 9a       	mov	r10,r2
80008972:	1a d8       	st.w	--sp,r8
80008974:	fa c8 fb b4 	sub	r8,sp,-1100
80008978:	0c 9b       	mov	r11,r6
8000897a:	1a d8       	st.w	--sp,r8
8000897c:	08 9c       	mov	r12,r4
8000897e:	fa c8 f9 40 	sub	r8,sp,-1728
80008982:	fa c9 ff b4 	sub	r9,sp,-76
80008986:	fe b0 f8 55 	rcall	80007a30 <get_arg>
8000898a:	2f dd       	sub	sp,-12
8000898c:	78 0a       	ld.w	r10,r12[0x0]
8000898e:	c2 08       	rjmp	800089ce <_vfprintf_r+0xc6e>
80008990:	2f f7       	sub	r7,-1
80008992:	10 39       	cp.w	r9,r8
80008994:	c0 84       	brge	800089a4 <_vfprintf_r+0xc44>
80008996:	fa ca f9 44 	sub	r10,sp,-1724
8000899a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000899e:	ec fa fd 88 	ld.w	r10,r6[-632]
800089a2:	c1 68       	rjmp	800089ce <_vfprintf_r+0xc6e>
800089a4:	41 09       	lddsp	r9,sp[0x40]
800089a6:	59 f8       	cp.w	r8,31
800089a8:	e0 89 00 10 	brgt	800089c8 <_vfprintf_r+0xc68>
800089ac:	f2 ca ff fc 	sub	r10,r9,-4
800089b0:	51 0a       	stdsp	sp[0x40],r10
800089b2:	fa c6 f9 44 	sub	r6,sp,-1724
800089b6:	72 0a       	ld.w	r10,r9[0x0]
800089b8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089bc:	f3 4a fd 88 	st.w	r9[-632],r10
800089c0:	2f f8       	sub	r8,-1
800089c2:	fb 48 06 b4 	st.w	sp[1716],r8
800089c6:	c0 48       	rjmp	800089ce <_vfprintf_r+0xc6e>
800089c8:	72 0a       	ld.w	r10,r9[0x0]
800089ca:	2f c9       	sub	r9,-4
800089cc:	51 09       	stdsp	sp[0x40],r9
800089ce:	40 be       	lddsp	lr,sp[0x2c]
800089d0:	b4 0e       	st.h	r10[0x0],lr
800089d2:	fe 9f fa 55 	bral	80007e7c <_vfprintf_r+0x11c>
800089d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089da:	40 3c       	lddsp	r12,sp[0xc]
800089dc:	58 0c       	cp.w	r12,0
800089de:	c1 d0       	breq	80008a18 <_vfprintf_r+0xcb8>
800089e0:	10 36       	cp.w	r6,r8
800089e2:	c0 64       	brge	800089ee <_vfprintf_r+0xc8e>
800089e4:	fa cb f9 44 	sub	r11,sp,-1724
800089e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089ec:	c1 d8       	rjmp	80008a26 <_vfprintf_r+0xcc6>
800089ee:	fa c8 f9 50 	sub	r8,sp,-1712
800089f2:	1a d8       	st.w	--sp,r8
800089f4:	fa c8 fa b8 	sub	r8,sp,-1352
800089f8:	04 9a       	mov	r10,r2
800089fa:	1a d8       	st.w	--sp,r8
800089fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008a00:	0c 9b       	mov	r11,r6
80008a02:	1a d8       	st.w	--sp,r8
80008a04:	08 9c       	mov	r12,r4
80008a06:	fa c8 f9 40 	sub	r8,sp,-1728
80008a0a:	fa c9 ff b4 	sub	r9,sp,-76
80008a0e:	fe b0 f8 11 	rcall	80007a30 <get_arg>
80008a12:	2f dd       	sub	sp,-12
80008a14:	78 0a       	ld.w	r10,r12[0x0]
80008a16:	c2 08       	rjmp	80008a56 <_vfprintf_r+0xcf6>
80008a18:	2f f7       	sub	r7,-1
80008a1a:	10 39       	cp.w	r9,r8
80008a1c:	c0 84       	brge	80008a2c <_vfprintf_r+0xccc>
80008a1e:	fa ca f9 44 	sub	r10,sp,-1724
80008a22:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a26:	ec fa fd 88 	ld.w	r10,r6[-632]
80008a2a:	c1 68       	rjmp	80008a56 <_vfprintf_r+0xcf6>
80008a2c:	41 09       	lddsp	r9,sp[0x40]
80008a2e:	59 f8       	cp.w	r8,31
80008a30:	e0 89 00 10 	brgt	80008a50 <_vfprintf_r+0xcf0>
80008a34:	f2 ca ff fc 	sub	r10,r9,-4
80008a38:	51 0a       	stdsp	sp[0x40],r10
80008a3a:	fa c6 f9 44 	sub	r6,sp,-1724
80008a3e:	72 0a       	ld.w	r10,r9[0x0]
80008a40:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a44:	f3 4a fd 88 	st.w	r9[-632],r10
80008a48:	2f f8       	sub	r8,-1
80008a4a:	fb 48 06 b4 	st.w	sp[1716],r8
80008a4e:	c0 48       	rjmp	80008a56 <_vfprintf_r+0xcf6>
80008a50:	72 0a       	ld.w	r10,r9[0x0]
80008a52:	2f c9       	sub	r9,-4
80008a54:	51 09       	stdsp	sp[0x40],r9
80008a56:	40 be       	lddsp	lr,sp[0x2c]
80008a58:	95 0e       	st.w	r10[0x0],lr
80008a5a:	fe 9f fa 11 	bral	80007e7c <_vfprintf_r+0x11c>
80008a5e:	50 a7       	stdsp	sp[0x28],r7
80008a60:	50 80       	stdsp	sp[0x20],r0
80008a62:	0c 97       	mov	r7,r6
80008a64:	04 94       	mov	r4,r2
80008a66:	06 96       	mov	r6,r3
80008a68:	02 92       	mov	r2,r1
80008a6a:	40 93       	lddsp	r3,sp[0x24]
80008a6c:	10 90       	mov	r0,r8
80008a6e:	40 41       	lddsp	r1,sp[0x10]
80008a70:	a5 a5       	sbr	r5,0x4
80008a72:	c0 a8       	rjmp	80008a86 <_vfprintf_r+0xd26>
80008a74:	50 a7       	stdsp	sp[0x28],r7
80008a76:	50 80       	stdsp	sp[0x20],r0
80008a78:	0c 97       	mov	r7,r6
80008a7a:	04 94       	mov	r4,r2
80008a7c:	06 96       	mov	r6,r3
80008a7e:	02 92       	mov	r2,r1
80008a80:	40 93       	lddsp	r3,sp[0x24]
80008a82:	10 90       	mov	r0,r8
80008a84:	40 41       	lddsp	r1,sp[0x10]
80008a86:	ed b5 00 05 	bld	r5,0x5
80008a8a:	c5 d1       	brne	80008b44 <_vfprintf_r+0xde4>
80008a8c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a90:	40 3c       	lddsp	r12,sp[0xc]
80008a92:	58 0c       	cp.w	r12,0
80008a94:	c2 60       	breq	80008ae0 <_vfprintf_r+0xd80>
80008a96:	10 36       	cp.w	r6,r8
80008a98:	c0 a4       	brge	80008aac <_vfprintf_r+0xd4c>
80008a9a:	fa cb f9 44 	sub	r11,sp,-1724
80008a9e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008aa2:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008aa6:	fa e9 00 00 	st.d	sp[0],r8
80008aaa:	c1 88       	rjmp	80008ada <_vfprintf_r+0xd7a>
80008aac:	fa c8 f9 50 	sub	r8,sp,-1712
80008ab0:	1a d8       	st.w	--sp,r8
80008ab2:	fa c8 fa b8 	sub	r8,sp,-1352
80008ab6:	04 9a       	mov	r10,r2
80008ab8:	1a d8       	st.w	--sp,r8
80008aba:	0c 9b       	mov	r11,r6
80008abc:	fa c8 fb b4 	sub	r8,sp,-1100
80008ac0:	08 9c       	mov	r12,r4
80008ac2:	1a d8       	st.w	--sp,r8
80008ac4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ac8:	fa c9 ff b4 	sub	r9,sp,-76
80008acc:	fe b0 f7 b2 	rcall	80007a30 <get_arg>
80008ad0:	2f dd       	sub	sp,-12
80008ad2:	f8 ea 00 00 	ld.d	r10,r12[0]
80008ad6:	fa eb 00 00 	st.d	sp[0],r10
80008ada:	30 08       	mov	r8,0
80008adc:	e0 8f 03 de 	bral	80009298 <_vfprintf_r+0x1538>
80008ae0:	ee ca ff ff 	sub	r10,r7,-1
80008ae4:	10 37       	cp.w	r7,r8
80008ae6:	c0 b4       	brge	80008afc <_vfprintf_r+0xd9c>
80008ae8:	fa c9 f9 44 	sub	r9,sp,-1724
80008aec:	14 97       	mov	r7,r10
80008aee:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008af2:	ec ea fd 88 	ld.d	r10,r6[-632]
80008af6:	fa eb 00 00 	st.d	sp[0],r10
80008afa:	c1 88       	rjmp	80008b2a <_vfprintf_r+0xdca>
80008afc:	41 09       	lddsp	r9,sp[0x40]
80008afe:	59 f8       	cp.w	r8,31
80008b00:	e0 89 00 18 	brgt	80008b30 <_vfprintf_r+0xdd0>
80008b04:	f2 e6 00 00 	ld.d	r6,r9[0]
80008b08:	f2 cb ff f8 	sub	r11,r9,-8
80008b0c:	fa e7 00 00 	st.d	sp[0],r6
80008b10:	51 0b       	stdsp	sp[0x40],r11
80008b12:	fa c6 f9 44 	sub	r6,sp,-1724
80008b16:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b1a:	fa e6 00 00 	ld.d	r6,sp[0]
80008b1e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008b22:	2f f8       	sub	r8,-1
80008b24:	14 97       	mov	r7,r10
80008b26:	fb 48 06 b4 	st.w	sp[1716],r8
80008b2a:	40 38       	lddsp	r8,sp[0xc]
80008b2c:	e0 8f 03 b6 	bral	80009298 <_vfprintf_r+0x1538>
80008b30:	f2 e6 00 00 	ld.d	r6,r9[0]
80008b34:	40 38       	lddsp	r8,sp[0xc]
80008b36:	fa e7 00 00 	st.d	sp[0],r6
80008b3a:	2f 89       	sub	r9,-8
80008b3c:	14 97       	mov	r7,r10
80008b3e:	51 09       	stdsp	sp[0x40],r9
80008b40:	e0 8f 03 ac 	bral	80009298 <_vfprintf_r+0x1538>
80008b44:	ed b5 00 04 	bld	r5,0x4
80008b48:	c1 61       	brne	80008b74 <_vfprintf_r+0xe14>
80008b4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b4e:	40 3e       	lddsp	lr,sp[0xc]
80008b50:	58 0e       	cp.w	lr,0
80008b52:	c0 80       	breq	80008b62 <_vfprintf_r+0xe02>
80008b54:	10 36       	cp.w	r6,r8
80008b56:	c6 74       	brge	80008c24 <_vfprintf_r+0xec4>
80008b58:	fa cc f9 44 	sub	r12,sp,-1724
80008b5c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008b60:	c8 08       	rjmp	80008c60 <_vfprintf_r+0xf00>
80008b62:	ee ca ff ff 	sub	r10,r7,-1
80008b66:	10 37       	cp.w	r7,r8
80008b68:	c7 f4       	brge	80008c66 <_vfprintf_r+0xf06>
80008b6a:	fa cb f9 44 	sub	r11,sp,-1724
80008b6e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b72:	c7 68       	rjmp	80008c5e <_vfprintf_r+0xefe>
80008b74:	ed b5 00 06 	bld	r5,0x6
80008b78:	c4 a1       	brne	80008c0c <_vfprintf_r+0xeac>
80008b7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b7e:	40 3c       	lddsp	r12,sp[0xc]
80008b80:	58 0c       	cp.w	r12,0
80008b82:	c1 d0       	breq	80008bbc <_vfprintf_r+0xe5c>
80008b84:	10 36       	cp.w	r6,r8
80008b86:	c0 64       	brge	80008b92 <_vfprintf_r+0xe32>
80008b88:	fa cb f9 44 	sub	r11,sp,-1724
80008b8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b90:	c1 f8       	rjmp	80008bce <_vfprintf_r+0xe6e>
80008b92:	fa c8 f9 50 	sub	r8,sp,-1712
80008b96:	1a d8       	st.w	--sp,r8
80008b98:	fa c8 fa b8 	sub	r8,sp,-1352
80008b9c:	1a d8       	st.w	--sp,r8
80008b9e:	fa c8 fb b4 	sub	r8,sp,-1100
80008ba2:	1a d8       	st.w	--sp,r8
80008ba4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ba8:	fa c9 ff b4 	sub	r9,sp,-76
80008bac:	04 9a       	mov	r10,r2
80008bae:	0c 9b       	mov	r11,r6
80008bb0:	08 9c       	mov	r12,r4
80008bb2:	fe b0 f7 3f 	rcall	80007a30 <get_arg>
80008bb6:	2f dd       	sub	sp,-12
80008bb8:	98 18       	ld.sh	r8,r12[0x2]
80008bba:	c2 68       	rjmp	80008c06 <_vfprintf_r+0xea6>
80008bbc:	ee ca ff ff 	sub	r10,r7,-1
80008bc0:	10 37       	cp.w	r7,r8
80008bc2:	c0 94       	brge	80008bd4 <_vfprintf_r+0xe74>
80008bc4:	fa c9 f9 44 	sub	r9,sp,-1724
80008bc8:	14 97       	mov	r7,r10
80008bca:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008bce:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008bd2:	c1 a8       	rjmp	80008c06 <_vfprintf_r+0xea6>
80008bd4:	41 09       	lddsp	r9,sp[0x40]
80008bd6:	59 f8       	cp.w	r8,31
80008bd8:	e0 89 00 13 	brgt	80008bfe <_vfprintf_r+0xe9e>
80008bdc:	f2 cb ff fc 	sub	r11,r9,-4
80008be0:	51 0b       	stdsp	sp[0x40],r11
80008be2:	72 09       	ld.w	r9,r9[0x0]
80008be4:	fa c6 f9 44 	sub	r6,sp,-1724
80008be8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008bec:	2f f8       	sub	r8,-1
80008bee:	f7 49 fd 88 	st.w	r11[-632],r9
80008bf2:	fb 48 06 b4 	st.w	sp[1716],r8
80008bf6:	14 97       	mov	r7,r10
80008bf8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008bfc:	c0 58       	rjmp	80008c06 <_vfprintf_r+0xea6>
80008bfe:	92 18       	ld.sh	r8,r9[0x2]
80008c00:	14 97       	mov	r7,r10
80008c02:	2f c9       	sub	r9,-4
80008c04:	51 09       	stdsp	sp[0x40],r9
80008c06:	5c 78       	castu.h	r8
80008c08:	50 18       	stdsp	sp[0x4],r8
80008c0a:	c4 68       	rjmp	80008c96 <_vfprintf_r+0xf36>
80008c0c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c10:	40 3c       	lddsp	r12,sp[0xc]
80008c12:	58 0c       	cp.w	r12,0
80008c14:	c1 d0       	breq	80008c4e <_vfprintf_r+0xeee>
80008c16:	10 36       	cp.w	r6,r8
80008c18:	c0 64       	brge	80008c24 <_vfprintf_r+0xec4>
80008c1a:	fa cb f9 44 	sub	r11,sp,-1724
80008c1e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c22:	c1 f8       	rjmp	80008c60 <_vfprintf_r+0xf00>
80008c24:	fa c8 f9 50 	sub	r8,sp,-1712
80008c28:	1a d8       	st.w	--sp,r8
80008c2a:	fa c8 fa b8 	sub	r8,sp,-1352
80008c2e:	0c 9b       	mov	r11,r6
80008c30:	1a d8       	st.w	--sp,r8
80008c32:	fa c8 fb b4 	sub	r8,sp,-1100
80008c36:	04 9a       	mov	r10,r2
80008c38:	1a d8       	st.w	--sp,r8
80008c3a:	08 9c       	mov	r12,r4
80008c3c:	fa c8 f9 40 	sub	r8,sp,-1728
80008c40:	fa c9 ff b4 	sub	r9,sp,-76
80008c44:	fe b0 f6 f6 	rcall	80007a30 <get_arg>
80008c48:	2f dd       	sub	sp,-12
80008c4a:	78 0b       	ld.w	r11,r12[0x0]
80008c4c:	c2 48       	rjmp	80008c94 <_vfprintf_r+0xf34>
80008c4e:	ee ca ff ff 	sub	r10,r7,-1
80008c52:	10 37       	cp.w	r7,r8
80008c54:	c0 94       	brge	80008c66 <_vfprintf_r+0xf06>
80008c56:	fa c9 f9 44 	sub	r9,sp,-1724
80008c5a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c5e:	14 97       	mov	r7,r10
80008c60:	ec fb fd 88 	ld.w	r11,r6[-632]
80008c64:	c1 88       	rjmp	80008c94 <_vfprintf_r+0xf34>
80008c66:	41 09       	lddsp	r9,sp[0x40]
80008c68:	59 f8       	cp.w	r8,31
80008c6a:	e0 89 00 11 	brgt	80008c8c <_vfprintf_r+0xf2c>
80008c6e:	f2 cb ff fc 	sub	r11,r9,-4
80008c72:	51 0b       	stdsp	sp[0x40],r11
80008c74:	fa c6 f9 44 	sub	r6,sp,-1724
80008c78:	72 0b       	ld.w	r11,r9[0x0]
80008c7a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c7e:	f3 4b fd 88 	st.w	r9[-632],r11
80008c82:	2f f8       	sub	r8,-1
80008c84:	14 97       	mov	r7,r10
80008c86:	fb 48 06 b4 	st.w	sp[1716],r8
80008c8a:	c0 58       	rjmp	80008c94 <_vfprintf_r+0xf34>
80008c8c:	72 0b       	ld.w	r11,r9[0x0]
80008c8e:	14 97       	mov	r7,r10
80008c90:	2f c9       	sub	r9,-4
80008c92:	51 09       	stdsp	sp[0x40],r9
80008c94:	50 1b       	stdsp	sp[0x4],r11
80008c96:	30 0e       	mov	lr,0
80008c98:	50 0e       	stdsp	sp[0x0],lr
80008c9a:	1c 98       	mov	r8,lr
80008c9c:	e0 8f 02 fe 	bral	80009298 <_vfprintf_r+0x1538>
80008ca0:	50 a7       	stdsp	sp[0x28],r7
80008ca2:	50 80       	stdsp	sp[0x20],r0
80008ca4:	0c 97       	mov	r7,r6
80008ca6:	04 94       	mov	r4,r2
80008ca8:	06 96       	mov	r6,r3
80008caa:	02 92       	mov	r2,r1
80008cac:	40 93       	lddsp	r3,sp[0x24]
80008cae:	40 41       	lddsp	r1,sp[0x10]
80008cb0:	0e 99       	mov	r9,r7
80008cb2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cb6:	40 3c       	lddsp	r12,sp[0xc]
80008cb8:	58 0c       	cp.w	r12,0
80008cba:	c1 d0       	breq	80008cf4 <_vfprintf_r+0xf94>
80008cbc:	10 36       	cp.w	r6,r8
80008cbe:	c0 64       	brge	80008cca <_vfprintf_r+0xf6a>
80008cc0:	fa cb f9 44 	sub	r11,sp,-1724
80008cc4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cc8:	c1 d8       	rjmp	80008d02 <_vfprintf_r+0xfa2>
80008cca:	fa c8 f9 50 	sub	r8,sp,-1712
80008cce:	1a d8       	st.w	--sp,r8
80008cd0:	fa c8 fa b8 	sub	r8,sp,-1352
80008cd4:	1a d8       	st.w	--sp,r8
80008cd6:	fa c8 fb b4 	sub	r8,sp,-1100
80008cda:	1a d8       	st.w	--sp,r8
80008cdc:	fa c9 ff b4 	sub	r9,sp,-76
80008ce0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ce4:	04 9a       	mov	r10,r2
80008ce6:	0c 9b       	mov	r11,r6
80008ce8:	08 9c       	mov	r12,r4
80008cea:	fe b0 f6 a3 	rcall	80007a30 <get_arg>
80008cee:	2f dd       	sub	sp,-12
80008cf0:	78 09       	ld.w	r9,r12[0x0]
80008cf2:	c2 18       	rjmp	80008d34 <_vfprintf_r+0xfd4>
80008cf4:	2f f7       	sub	r7,-1
80008cf6:	10 39       	cp.w	r9,r8
80008cf8:	c0 84       	brge	80008d08 <_vfprintf_r+0xfa8>
80008cfa:	fa ca f9 44 	sub	r10,sp,-1724
80008cfe:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d02:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008d06:	c1 78       	rjmp	80008d34 <_vfprintf_r+0xfd4>
80008d08:	41 09       	lddsp	r9,sp[0x40]
80008d0a:	59 f8       	cp.w	r8,31
80008d0c:	e0 89 00 10 	brgt	80008d2c <_vfprintf_r+0xfcc>
80008d10:	f2 ca ff fc 	sub	r10,r9,-4
80008d14:	51 0a       	stdsp	sp[0x40],r10
80008d16:	fa c6 f9 44 	sub	r6,sp,-1724
80008d1a:	72 09       	ld.w	r9,r9[0x0]
80008d1c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008d20:	f5 49 fd 88 	st.w	r10[-632],r9
80008d24:	2f f8       	sub	r8,-1
80008d26:	fb 48 06 b4 	st.w	sp[1716],r8
80008d2a:	c0 58       	rjmp	80008d34 <_vfprintf_r+0xfd4>
80008d2c:	f2 c8 ff fc 	sub	r8,r9,-4
80008d30:	51 08       	stdsp	sp[0x40],r8
80008d32:	72 09       	ld.w	r9,r9[0x0]
80008d34:	33 08       	mov	r8,48
80008d36:	fb 68 06 b8 	st.b	sp[1720],r8
80008d3a:	37 88       	mov	r8,120
80008d3c:	30 0e       	mov	lr,0
80008d3e:	fb 68 06 b9 	st.b	sp[1721],r8
80008d42:	fe cc ac 86 	sub	r12,pc,-21370
80008d46:	50 19       	stdsp	sp[0x4],r9
80008d48:	a1 b5       	sbr	r5,0x1
80008d4a:	50 0e       	stdsp	sp[0x0],lr
80008d4c:	50 dc       	stdsp	sp[0x34],r12
80008d4e:	30 28       	mov	r8,2
80008d50:	37 80       	mov	r0,120
80008d52:	e0 8f 02 a3 	bral	80009298 <_vfprintf_r+0x1538>
80008d56:	50 a7       	stdsp	sp[0x28],r7
80008d58:	50 80       	stdsp	sp[0x20],r0
80008d5a:	10 90       	mov	r0,r8
80008d5c:	30 08       	mov	r8,0
80008d5e:	fb 68 06 bb 	st.b	sp[1723],r8
80008d62:	0c 97       	mov	r7,r6
80008d64:	04 94       	mov	r4,r2
80008d66:	06 96       	mov	r6,r3
80008d68:	02 92       	mov	r2,r1
80008d6a:	40 93       	lddsp	r3,sp[0x24]
80008d6c:	40 41       	lddsp	r1,sp[0x10]
80008d6e:	0e 99       	mov	r9,r7
80008d70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d74:	40 3b       	lddsp	r11,sp[0xc]
80008d76:	58 0b       	cp.w	r11,0
80008d78:	c1 d0       	breq	80008db2 <_vfprintf_r+0x1052>
80008d7a:	10 36       	cp.w	r6,r8
80008d7c:	c0 64       	brge	80008d88 <_vfprintf_r+0x1028>
80008d7e:	fa ca f9 44 	sub	r10,sp,-1724
80008d82:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d86:	c1 d8       	rjmp	80008dc0 <_vfprintf_r+0x1060>
80008d88:	fa c8 f9 50 	sub	r8,sp,-1712
80008d8c:	1a d8       	st.w	--sp,r8
80008d8e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d92:	1a d8       	st.w	--sp,r8
80008d94:	fa c8 fb b4 	sub	r8,sp,-1100
80008d98:	0c 9b       	mov	r11,r6
80008d9a:	1a d8       	st.w	--sp,r8
80008d9c:	04 9a       	mov	r10,r2
80008d9e:	fa c8 f9 40 	sub	r8,sp,-1728
80008da2:	fa c9 ff b4 	sub	r9,sp,-76
80008da6:	08 9c       	mov	r12,r4
80008da8:	fe b0 f6 44 	rcall	80007a30 <get_arg>
80008dac:	2f dd       	sub	sp,-12
80008dae:	78 06       	ld.w	r6,r12[0x0]
80008db0:	c2 08       	rjmp	80008df0 <_vfprintf_r+0x1090>
80008db2:	2f f7       	sub	r7,-1
80008db4:	10 39       	cp.w	r9,r8
80008db6:	c0 84       	brge	80008dc6 <_vfprintf_r+0x1066>
80008db8:	fa c9 f9 44 	sub	r9,sp,-1724
80008dbc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dc0:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008dc4:	c1 68       	rjmp	80008df0 <_vfprintf_r+0x1090>
80008dc6:	41 09       	lddsp	r9,sp[0x40]
80008dc8:	59 f8       	cp.w	r8,31
80008dca:	e0 89 00 10 	brgt	80008dea <_vfprintf_r+0x108a>
80008dce:	f2 ca ff fc 	sub	r10,r9,-4
80008dd2:	51 0a       	stdsp	sp[0x40],r10
80008dd4:	72 06       	ld.w	r6,r9[0x0]
80008dd6:	fa ce f9 44 	sub	lr,sp,-1724
80008dda:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008dde:	f3 46 fd 88 	st.w	r9[-632],r6
80008de2:	2f f8       	sub	r8,-1
80008de4:	fb 48 06 b4 	st.w	sp[1716],r8
80008de8:	c0 48       	rjmp	80008df0 <_vfprintf_r+0x1090>
80008dea:	72 06       	ld.w	r6,r9[0x0]
80008dec:	2f c9       	sub	r9,-4
80008dee:	51 09       	stdsp	sp[0x40],r9
80008df0:	40 2c       	lddsp	r12,sp[0x8]
80008df2:	58 0c       	cp.w	r12,0
80008df4:	c1 05       	brlt	80008e14 <_vfprintf_r+0x10b4>
80008df6:	18 9a       	mov	r10,r12
80008df8:	30 0b       	mov	r11,0
80008dfa:	0c 9c       	mov	r12,r6
80008dfc:	e0 a0 12 38 	rcall	8000b26c <memchr>
80008e00:	e0 80 02 df 	breq	800093be <_vfprintf_r+0x165e>
80008e04:	f8 06 01 02 	sub	r2,r12,r6
80008e08:	40 2b       	lddsp	r11,sp[0x8]
80008e0a:	16 32       	cp.w	r2,r11
80008e0c:	e0 89 02 d9 	brgt	800093be <_vfprintf_r+0x165e>
80008e10:	e0 8f 02 d4 	bral	800093b8 <_vfprintf_r+0x1658>
80008e14:	30 0a       	mov	r10,0
80008e16:	0c 9c       	mov	r12,r6
80008e18:	50 2a       	stdsp	sp[0x8],r10
80008e1a:	e0 a0 15 99 	rcall	8000b94c <strlen>
80008e1e:	18 92       	mov	r2,r12
80008e20:	e0 8f 02 d2 	bral	800093c4 <_vfprintf_r+0x1664>
80008e24:	50 a7       	stdsp	sp[0x28],r7
80008e26:	50 80       	stdsp	sp[0x20],r0
80008e28:	0c 97       	mov	r7,r6
80008e2a:	04 94       	mov	r4,r2
80008e2c:	06 96       	mov	r6,r3
80008e2e:	02 92       	mov	r2,r1
80008e30:	40 93       	lddsp	r3,sp[0x24]
80008e32:	10 90       	mov	r0,r8
80008e34:	40 41       	lddsp	r1,sp[0x10]
80008e36:	a5 a5       	sbr	r5,0x4
80008e38:	c0 a8       	rjmp	80008e4c <_vfprintf_r+0x10ec>
80008e3a:	50 a7       	stdsp	sp[0x28],r7
80008e3c:	50 80       	stdsp	sp[0x20],r0
80008e3e:	0c 97       	mov	r7,r6
80008e40:	04 94       	mov	r4,r2
80008e42:	06 96       	mov	r6,r3
80008e44:	02 92       	mov	r2,r1
80008e46:	40 93       	lddsp	r3,sp[0x24]
80008e48:	10 90       	mov	r0,r8
80008e4a:	40 41       	lddsp	r1,sp[0x10]
80008e4c:	ed b5 00 05 	bld	r5,0x5
80008e50:	c5 61       	brne	80008efc <_vfprintf_r+0x119c>
80008e52:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e56:	40 39       	lddsp	r9,sp[0xc]
80008e58:	58 09       	cp.w	r9,0
80008e5a:	c2 10       	breq	80008e9c <_vfprintf_r+0x113c>
80008e5c:	10 36       	cp.w	r6,r8
80008e5e:	c0 74       	brge	80008e6c <_vfprintf_r+0x110c>
80008e60:	fa c8 f9 44 	sub	r8,sp,-1724
80008e64:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008e68:	c2 38       	rjmp	80008eae <_vfprintf_r+0x114e>
80008e6a:	d7 03       	nop
80008e6c:	fa c8 f9 50 	sub	r8,sp,-1712
80008e70:	1a d8       	st.w	--sp,r8
80008e72:	fa c8 fa b8 	sub	r8,sp,-1352
80008e76:	1a d8       	st.w	--sp,r8
80008e78:	fa c8 fb b4 	sub	r8,sp,-1100
80008e7c:	1a d8       	st.w	--sp,r8
80008e7e:	fa c8 f9 40 	sub	r8,sp,-1728
80008e82:	fa c9 ff b4 	sub	r9,sp,-76
80008e86:	04 9a       	mov	r10,r2
80008e88:	0c 9b       	mov	r11,r6
80008e8a:	08 9c       	mov	r12,r4
80008e8c:	fe b0 f5 d2 	rcall	80007a30 <get_arg>
80008e90:	2f dd       	sub	sp,-12
80008e92:	f8 e8 00 00 	ld.d	r8,r12[0]
80008e96:	fa e9 00 00 	st.d	sp[0],r8
80008e9a:	c2 e8       	rjmp	80008ef6 <_vfprintf_r+0x1196>
80008e9c:	ee ca ff ff 	sub	r10,r7,-1
80008ea0:	10 37       	cp.w	r7,r8
80008ea2:	c0 b4       	brge	80008eb8 <_vfprintf_r+0x1158>
80008ea4:	fa c8 f9 44 	sub	r8,sp,-1724
80008ea8:	14 97       	mov	r7,r10
80008eaa:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008eae:	ec ea fd 88 	ld.d	r10,r6[-632]
80008eb2:	fa eb 00 00 	st.d	sp[0],r10
80008eb6:	c2 08       	rjmp	80008ef6 <_vfprintf_r+0x1196>
80008eb8:	41 09       	lddsp	r9,sp[0x40]
80008eba:	59 f8       	cp.w	r8,31
80008ebc:	e0 89 00 16 	brgt	80008ee8 <_vfprintf_r+0x1188>
80008ec0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ec4:	f2 cb ff f8 	sub	r11,r9,-8
80008ec8:	fa e7 00 00 	st.d	sp[0],r6
80008ecc:	51 0b       	stdsp	sp[0x40],r11
80008ece:	fa c6 f9 44 	sub	r6,sp,-1724
80008ed2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ed6:	fa e6 00 00 	ld.d	r6,sp[0]
80008eda:	f2 e7 fd 88 	st.d	r9[-632],r6
80008ede:	2f f8       	sub	r8,-1
80008ee0:	14 97       	mov	r7,r10
80008ee2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ee6:	c0 88       	rjmp	80008ef6 <_vfprintf_r+0x1196>
80008ee8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008eec:	2f 89       	sub	r9,-8
80008eee:	fa e7 00 00 	st.d	sp[0],r6
80008ef2:	51 09       	stdsp	sp[0x40],r9
80008ef4:	14 97       	mov	r7,r10
80008ef6:	30 18       	mov	r8,1
80008ef8:	e0 8f 01 d0 	bral	80009298 <_vfprintf_r+0x1538>
80008efc:	ed b5 00 04 	bld	r5,0x4
80008f00:	c1 61       	brne	80008f2c <_vfprintf_r+0x11cc>
80008f02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f06:	40 3e       	lddsp	lr,sp[0xc]
80008f08:	58 0e       	cp.w	lr,0
80008f0a:	c0 80       	breq	80008f1a <_vfprintf_r+0x11ba>
80008f0c:	10 36       	cp.w	r6,r8
80008f0e:	c6 74       	brge	80008fdc <_vfprintf_r+0x127c>
80008f10:	fa cc f9 44 	sub	r12,sp,-1724
80008f14:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f18:	c8 08       	rjmp	80009018 <_vfprintf_r+0x12b8>
80008f1a:	ee ca ff ff 	sub	r10,r7,-1
80008f1e:	10 37       	cp.w	r7,r8
80008f20:	c7 f4       	brge	8000901e <_vfprintf_r+0x12be>
80008f22:	fa cb f9 44 	sub	r11,sp,-1724
80008f26:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f2a:	c7 68       	rjmp	80009016 <_vfprintf_r+0x12b6>
80008f2c:	ed b5 00 06 	bld	r5,0x6
80008f30:	c4 a1       	brne	80008fc4 <_vfprintf_r+0x1264>
80008f32:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f36:	40 3c       	lddsp	r12,sp[0xc]
80008f38:	58 0c       	cp.w	r12,0
80008f3a:	c1 d0       	breq	80008f74 <_vfprintf_r+0x1214>
80008f3c:	10 36       	cp.w	r6,r8
80008f3e:	c0 64       	brge	80008f4a <_vfprintf_r+0x11ea>
80008f40:	fa cb f9 44 	sub	r11,sp,-1724
80008f44:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f48:	c1 f8       	rjmp	80008f86 <_vfprintf_r+0x1226>
80008f4a:	fa c8 f9 50 	sub	r8,sp,-1712
80008f4e:	1a d8       	st.w	--sp,r8
80008f50:	fa c8 fa b8 	sub	r8,sp,-1352
80008f54:	1a d8       	st.w	--sp,r8
80008f56:	fa c8 fb b4 	sub	r8,sp,-1100
80008f5a:	1a d8       	st.w	--sp,r8
80008f5c:	fa c8 f9 40 	sub	r8,sp,-1728
80008f60:	fa c9 ff b4 	sub	r9,sp,-76
80008f64:	04 9a       	mov	r10,r2
80008f66:	0c 9b       	mov	r11,r6
80008f68:	08 9c       	mov	r12,r4
80008f6a:	fe b0 f5 63 	rcall	80007a30 <get_arg>
80008f6e:	2f dd       	sub	sp,-12
80008f70:	98 18       	ld.sh	r8,r12[0x2]
80008f72:	c2 68       	rjmp	80008fbe <_vfprintf_r+0x125e>
80008f74:	ee ca ff ff 	sub	r10,r7,-1
80008f78:	10 37       	cp.w	r7,r8
80008f7a:	c0 94       	brge	80008f8c <_vfprintf_r+0x122c>
80008f7c:	fa c9 f9 44 	sub	r9,sp,-1724
80008f80:	14 97       	mov	r7,r10
80008f82:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f86:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f8a:	c1 a8       	rjmp	80008fbe <_vfprintf_r+0x125e>
80008f8c:	41 09       	lddsp	r9,sp[0x40]
80008f8e:	59 f8       	cp.w	r8,31
80008f90:	e0 89 00 13 	brgt	80008fb6 <_vfprintf_r+0x1256>
80008f94:	f2 cb ff fc 	sub	r11,r9,-4
80008f98:	51 0b       	stdsp	sp[0x40],r11
80008f9a:	72 09       	ld.w	r9,r9[0x0]
80008f9c:	fa c6 f9 44 	sub	r6,sp,-1724
80008fa0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008fa4:	2f f8       	sub	r8,-1
80008fa6:	f7 49 fd 88 	st.w	r11[-632],r9
80008faa:	fb 48 06 b4 	st.w	sp[1716],r8
80008fae:	14 97       	mov	r7,r10
80008fb0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008fb4:	c0 58       	rjmp	80008fbe <_vfprintf_r+0x125e>
80008fb6:	92 18       	ld.sh	r8,r9[0x2]
80008fb8:	14 97       	mov	r7,r10
80008fba:	2f c9       	sub	r9,-4
80008fbc:	51 09       	stdsp	sp[0x40],r9
80008fbe:	5c 78       	castu.h	r8
80008fc0:	50 18       	stdsp	sp[0x4],r8
80008fc2:	c4 68       	rjmp	8000904e <_vfprintf_r+0x12ee>
80008fc4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fc8:	40 3c       	lddsp	r12,sp[0xc]
80008fca:	58 0c       	cp.w	r12,0
80008fcc:	c1 d0       	breq	80009006 <_vfprintf_r+0x12a6>
80008fce:	10 36       	cp.w	r6,r8
80008fd0:	c0 64       	brge	80008fdc <_vfprintf_r+0x127c>
80008fd2:	fa cb f9 44 	sub	r11,sp,-1724
80008fd6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fda:	c1 f8       	rjmp	80009018 <_vfprintf_r+0x12b8>
80008fdc:	fa c8 f9 50 	sub	r8,sp,-1712
80008fe0:	1a d8       	st.w	--sp,r8
80008fe2:	fa c8 fa b8 	sub	r8,sp,-1352
80008fe6:	0c 9b       	mov	r11,r6
80008fe8:	1a d8       	st.w	--sp,r8
80008fea:	fa c8 fb b4 	sub	r8,sp,-1100
80008fee:	04 9a       	mov	r10,r2
80008ff0:	1a d8       	st.w	--sp,r8
80008ff2:	08 9c       	mov	r12,r4
80008ff4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ff8:	fa c9 ff b4 	sub	r9,sp,-76
80008ffc:	fe b0 f5 1a 	rcall	80007a30 <get_arg>
80009000:	2f dd       	sub	sp,-12
80009002:	78 0b       	ld.w	r11,r12[0x0]
80009004:	c2 48       	rjmp	8000904c <_vfprintf_r+0x12ec>
80009006:	ee ca ff ff 	sub	r10,r7,-1
8000900a:	10 37       	cp.w	r7,r8
8000900c:	c0 94       	brge	8000901e <_vfprintf_r+0x12be>
8000900e:	fa c9 f9 44 	sub	r9,sp,-1724
80009012:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009016:	14 97       	mov	r7,r10
80009018:	ec fb fd 88 	ld.w	r11,r6[-632]
8000901c:	c1 88       	rjmp	8000904c <_vfprintf_r+0x12ec>
8000901e:	41 09       	lddsp	r9,sp[0x40]
80009020:	59 f8       	cp.w	r8,31
80009022:	e0 89 00 11 	brgt	80009044 <_vfprintf_r+0x12e4>
80009026:	f2 cb ff fc 	sub	r11,r9,-4
8000902a:	51 0b       	stdsp	sp[0x40],r11
8000902c:	fa c6 f9 44 	sub	r6,sp,-1724
80009030:	72 0b       	ld.w	r11,r9[0x0]
80009032:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009036:	f3 4b fd 88 	st.w	r9[-632],r11
8000903a:	2f f8       	sub	r8,-1
8000903c:	14 97       	mov	r7,r10
8000903e:	fb 48 06 b4 	st.w	sp[1716],r8
80009042:	c0 58       	rjmp	8000904c <_vfprintf_r+0x12ec>
80009044:	72 0b       	ld.w	r11,r9[0x0]
80009046:	14 97       	mov	r7,r10
80009048:	2f c9       	sub	r9,-4
8000904a:	51 09       	stdsp	sp[0x40],r9
8000904c:	50 1b       	stdsp	sp[0x4],r11
8000904e:	30 0e       	mov	lr,0
80009050:	30 18       	mov	r8,1
80009052:	50 0e       	stdsp	sp[0x0],lr
80009054:	c2 29       	rjmp	80009298 <_vfprintf_r+0x1538>
80009056:	50 a7       	stdsp	sp[0x28],r7
80009058:	50 80       	stdsp	sp[0x20],r0
8000905a:	0c 97       	mov	r7,r6
8000905c:	04 94       	mov	r4,r2
8000905e:	06 96       	mov	r6,r3
80009060:	02 92       	mov	r2,r1
80009062:	fe cc af a6 	sub	r12,pc,-20570
80009066:	40 93       	lddsp	r3,sp[0x24]
80009068:	10 90       	mov	r0,r8
8000906a:	40 41       	lddsp	r1,sp[0x10]
8000906c:	50 dc       	stdsp	sp[0x34],r12
8000906e:	ed b5 00 05 	bld	r5,0x5
80009072:	c5 51       	brne	8000911c <_vfprintf_r+0x13bc>
80009074:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009078:	40 3b       	lddsp	r11,sp[0xc]
8000907a:	58 0b       	cp.w	r11,0
8000907c:	c2 20       	breq	800090c0 <_vfprintf_r+0x1360>
8000907e:	10 36       	cp.w	r6,r8
80009080:	c0 a4       	brge	80009094 <_vfprintf_r+0x1334>
80009082:	fa ca f9 44 	sub	r10,sp,-1724
80009086:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000908a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000908e:	fa e9 00 00 	st.d	sp[0],r8
80009092:	cf 28       	rjmp	80009276 <_vfprintf_r+0x1516>
80009094:	fa c8 f9 50 	sub	r8,sp,-1712
80009098:	1a d8       	st.w	--sp,r8
8000909a:	fa c8 fa b8 	sub	r8,sp,-1352
8000909e:	04 9a       	mov	r10,r2
800090a0:	1a d8       	st.w	--sp,r8
800090a2:	0c 9b       	mov	r11,r6
800090a4:	fa c8 fb b4 	sub	r8,sp,-1100
800090a8:	08 9c       	mov	r12,r4
800090aa:	1a d8       	st.w	--sp,r8
800090ac:	fa c8 f9 40 	sub	r8,sp,-1728
800090b0:	fa c9 ff b4 	sub	r9,sp,-76
800090b4:	fe b0 f4 be 	rcall	80007a30 <get_arg>
800090b8:	2f dd       	sub	sp,-12
800090ba:	f8 ea 00 00 	ld.d	r10,r12[0]
800090be:	c0 c8       	rjmp	800090d6 <_vfprintf_r+0x1376>
800090c0:	ee ca ff ff 	sub	r10,r7,-1
800090c4:	10 37       	cp.w	r7,r8
800090c6:	c0 b4       	brge	800090dc <_vfprintf_r+0x137c>
800090c8:	fa c9 f9 44 	sub	r9,sp,-1724
800090cc:	14 97       	mov	r7,r10
800090ce:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090d2:	ec ea fd 88 	ld.d	r10,r6[-632]
800090d6:	fa eb 00 00 	st.d	sp[0],r10
800090da:	cc e8       	rjmp	80009276 <_vfprintf_r+0x1516>
800090dc:	41 09       	lddsp	r9,sp[0x40]
800090de:	59 f8       	cp.w	r8,31
800090e0:	e0 89 00 16 	brgt	8000910c <_vfprintf_r+0x13ac>
800090e4:	f2 e6 00 00 	ld.d	r6,r9[0]
800090e8:	f2 cb ff f8 	sub	r11,r9,-8
800090ec:	fa e7 00 00 	st.d	sp[0],r6
800090f0:	51 0b       	stdsp	sp[0x40],r11
800090f2:	fa c6 f9 44 	sub	r6,sp,-1724
800090f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800090fa:	fa e6 00 00 	ld.d	r6,sp[0]
800090fe:	f2 e7 fd 88 	st.d	r9[-632],r6
80009102:	2f f8       	sub	r8,-1
80009104:	14 97       	mov	r7,r10
80009106:	fb 48 06 b4 	st.w	sp[1716],r8
8000910a:	cb 68       	rjmp	80009276 <_vfprintf_r+0x1516>
8000910c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009110:	2f 89       	sub	r9,-8
80009112:	fa e7 00 00 	st.d	sp[0],r6
80009116:	51 09       	stdsp	sp[0x40],r9
80009118:	14 97       	mov	r7,r10
8000911a:	ca e8       	rjmp	80009276 <_vfprintf_r+0x1516>
8000911c:	ed b5 00 04 	bld	r5,0x4
80009120:	c1 71       	brne	8000914e <_vfprintf_r+0x13ee>
80009122:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009126:	40 3e       	lddsp	lr,sp[0xc]
80009128:	58 0e       	cp.w	lr,0
8000912a:	c0 80       	breq	8000913a <_vfprintf_r+0x13da>
8000912c:	10 36       	cp.w	r6,r8
8000912e:	c6 94       	brge	80009200 <_vfprintf_r+0x14a0>
80009130:	fa cc f9 44 	sub	r12,sp,-1724
80009134:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009138:	c8 28       	rjmp	8000923c <_vfprintf_r+0x14dc>
8000913a:	ee ca ff ff 	sub	r10,r7,-1
8000913e:	10 37       	cp.w	r7,r8
80009140:	e0 84 00 81 	brge	80009242 <_vfprintf_r+0x14e2>
80009144:	fa cb f9 44 	sub	r11,sp,-1724
80009148:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000914c:	c7 78       	rjmp	8000923a <_vfprintf_r+0x14da>
8000914e:	ed b5 00 06 	bld	r5,0x6
80009152:	c4 b1       	brne	800091e8 <_vfprintf_r+0x1488>
80009154:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009158:	40 3c       	lddsp	r12,sp[0xc]
8000915a:	58 0c       	cp.w	r12,0
8000915c:	c1 d0       	breq	80009196 <_vfprintf_r+0x1436>
8000915e:	10 36       	cp.w	r6,r8
80009160:	c0 64       	brge	8000916c <_vfprintf_r+0x140c>
80009162:	fa cb f9 44 	sub	r11,sp,-1724
80009166:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000916a:	c1 f8       	rjmp	800091a8 <_vfprintf_r+0x1448>
8000916c:	fa c8 f9 50 	sub	r8,sp,-1712
80009170:	1a d8       	st.w	--sp,r8
80009172:	fa c8 fa b8 	sub	r8,sp,-1352
80009176:	1a d8       	st.w	--sp,r8
80009178:	fa c8 fb b4 	sub	r8,sp,-1100
8000917c:	1a d8       	st.w	--sp,r8
8000917e:	fa c8 f9 40 	sub	r8,sp,-1728
80009182:	fa c9 ff b4 	sub	r9,sp,-76
80009186:	04 9a       	mov	r10,r2
80009188:	0c 9b       	mov	r11,r6
8000918a:	08 9c       	mov	r12,r4
8000918c:	fe b0 f4 52 	rcall	80007a30 <get_arg>
80009190:	2f dd       	sub	sp,-12
80009192:	98 18       	ld.sh	r8,r12[0x2]
80009194:	c2 78       	rjmp	800091e2 <_vfprintf_r+0x1482>
80009196:	ee ca ff ff 	sub	r10,r7,-1
8000919a:	10 37       	cp.w	r7,r8
8000919c:	c0 a4       	brge	800091b0 <_vfprintf_r+0x1450>
8000919e:	fa c9 f9 44 	sub	r9,sp,-1724
800091a2:	14 97       	mov	r7,r10
800091a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091a8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800091ac:	c1 b8       	rjmp	800091e2 <_vfprintf_r+0x1482>
800091ae:	d7 03       	nop
800091b0:	41 09       	lddsp	r9,sp[0x40]
800091b2:	59 f8       	cp.w	r8,31
800091b4:	e0 89 00 13 	brgt	800091da <_vfprintf_r+0x147a>
800091b8:	f2 cb ff fc 	sub	r11,r9,-4
800091bc:	51 0b       	stdsp	sp[0x40],r11
800091be:	72 09       	ld.w	r9,r9[0x0]
800091c0:	fa c6 f9 44 	sub	r6,sp,-1724
800091c4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800091c8:	2f f8       	sub	r8,-1
800091ca:	f7 49 fd 88 	st.w	r11[-632],r9
800091ce:	fb 48 06 b4 	st.w	sp[1716],r8
800091d2:	14 97       	mov	r7,r10
800091d4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800091d8:	c0 58       	rjmp	800091e2 <_vfprintf_r+0x1482>
800091da:	92 18       	ld.sh	r8,r9[0x2]
800091dc:	14 97       	mov	r7,r10
800091de:	2f c9       	sub	r9,-4
800091e0:	51 09       	stdsp	sp[0x40],r9
800091e2:	5c 78       	castu.h	r8
800091e4:	50 18       	stdsp	sp[0x4],r8
800091e6:	c4 68       	rjmp	80009272 <_vfprintf_r+0x1512>
800091e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091ec:	40 3c       	lddsp	r12,sp[0xc]
800091ee:	58 0c       	cp.w	r12,0
800091f0:	c1 d0       	breq	8000922a <_vfprintf_r+0x14ca>
800091f2:	10 36       	cp.w	r6,r8
800091f4:	c0 64       	brge	80009200 <_vfprintf_r+0x14a0>
800091f6:	fa cb f9 44 	sub	r11,sp,-1724
800091fa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091fe:	c1 f8       	rjmp	8000923c <_vfprintf_r+0x14dc>
80009200:	fa c8 f9 50 	sub	r8,sp,-1712
80009204:	1a d8       	st.w	--sp,r8
80009206:	fa c8 fa b8 	sub	r8,sp,-1352
8000920a:	0c 9b       	mov	r11,r6
8000920c:	1a d8       	st.w	--sp,r8
8000920e:	fa c8 fb b4 	sub	r8,sp,-1100
80009212:	04 9a       	mov	r10,r2
80009214:	1a d8       	st.w	--sp,r8
80009216:	08 9c       	mov	r12,r4
80009218:	fa c8 f9 40 	sub	r8,sp,-1728
8000921c:	fa c9 ff b4 	sub	r9,sp,-76
80009220:	fe b0 f4 08 	rcall	80007a30 <get_arg>
80009224:	2f dd       	sub	sp,-12
80009226:	78 0b       	ld.w	r11,r12[0x0]
80009228:	c2 48       	rjmp	80009270 <_vfprintf_r+0x1510>
8000922a:	ee ca ff ff 	sub	r10,r7,-1
8000922e:	10 37       	cp.w	r7,r8
80009230:	c0 94       	brge	80009242 <_vfprintf_r+0x14e2>
80009232:	fa c9 f9 44 	sub	r9,sp,-1724
80009236:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000923a:	14 97       	mov	r7,r10
8000923c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009240:	c1 88       	rjmp	80009270 <_vfprintf_r+0x1510>
80009242:	41 09       	lddsp	r9,sp[0x40]
80009244:	59 f8       	cp.w	r8,31
80009246:	e0 89 00 11 	brgt	80009268 <_vfprintf_r+0x1508>
8000924a:	f2 cb ff fc 	sub	r11,r9,-4
8000924e:	51 0b       	stdsp	sp[0x40],r11
80009250:	fa c6 f9 44 	sub	r6,sp,-1724
80009254:	72 0b       	ld.w	r11,r9[0x0]
80009256:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000925a:	f3 4b fd 88 	st.w	r9[-632],r11
8000925e:	2f f8       	sub	r8,-1
80009260:	14 97       	mov	r7,r10
80009262:	fb 48 06 b4 	st.w	sp[1716],r8
80009266:	c0 58       	rjmp	80009270 <_vfprintf_r+0x1510>
80009268:	72 0b       	ld.w	r11,r9[0x0]
8000926a:	14 97       	mov	r7,r10
8000926c:	2f c9       	sub	r9,-4
8000926e:	51 09       	stdsp	sp[0x40],r9
80009270:	50 1b       	stdsp	sp[0x4],r11
80009272:	30 0e       	mov	lr,0
80009274:	50 0e       	stdsp	sp[0x0],lr
80009276:	40 08       	lddsp	r8,sp[0x0]
80009278:	40 1c       	lddsp	r12,sp[0x4]
8000927a:	18 48       	or	r8,r12
8000927c:	5f 19       	srne	r9
8000927e:	0a 98       	mov	r8,r5
80009280:	eb e9 00 09 	and	r9,r5,r9
80009284:	a1 b8       	sbr	r8,0x1
80009286:	58 09       	cp.w	r9,0
80009288:	c0 70       	breq	80009296 <_vfprintf_r+0x1536>
8000928a:	10 95       	mov	r5,r8
8000928c:	fb 60 06 b9 	st.b	sp[1721],r0
80009290:	33 08       	mov	r8,48
80009292:	fb 68 06 b8 	st.b	sp[1720],r8
80009296:	30 28       	mov	r8,2
80009298:	30 09       	mov	r9,0
8000929a:	fb 69 06 bb 	st.b	sp[1723],r9
8000929e:	0a 99       	mov	r9,r5
800092a0:	a7 d9       	cbr	r9,0x7
800092a2:	40 2b       	lddsp	r11,sp[0x8]
800092a4:	40 16       	lddsp	r6,sp[0x4]
800092a6:	58 0b       	cp.w	r11,0
800092a8:	5f 1a       	srne	r10
800092aa:	f2 05 17 40 	movge	r5,r9
800092ae:	fa c2 f9 78 	sub	r2,sp,-1672
800092b2:	40 09       	lddsp	r9,sp[0x0]
800092b4:	0c 49       	or	r9,r6
800092b6:	5f 19       	srne	r9
800092b8:	f5 e9 10 09 	or	r9,r10,r9
800092bc:	c5 c0       	breq	80009374 <_vfprintf_r+0x1614>
800092be:	30 19       	mov	r9,1
800092c0:	f2 08 18 00 	cp.b	r8,r9
800092c4:	c0 60       	breq	800092d0 <_vfprintf_r+0x1570>
800092c6:	30 29       	mov	r9,2
800092c8:	f2 08 18 00 	cp.b	r8,r9
800092cc:	c0 41       	brne	800092d4 <_vfprintf_r+0x1574>
800092ce:	c3 c8       	rjmp	80009346 <_vfprintf_r+0x15e6>
800092d0:	04 96       	mov	r6,r2
800092d2:	c3 08       	rjmp	80009332 <_vfprintf_r+0x15d2>
800092d4:	04 96       	mov	r6,r2
800092d6:	fa e8 00 00 	ld.d	r8,sp[0]
800092da:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800092de:	2d 0a       	sub	r10,-48
800092e0:	0c fa       	st.b	--r6,r10
800092e2:	f0 0b 16 03 	lsr	r11,r8,0x3
800092e6:	f2 0c 16 03 	lsr	r12,r9,0x3
800092ea:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800092ee:	18 99       	mov	r9,r12
800092f0:	16 98       	mov	r8,r11
800092f2:	58 08       	cp.w	r8,0
800092f4:	5c 29       	cpc	r9
800092f6:	cf 21       	brne	800092da <_vfprintf_r+0x157a>
800092f8:	fa e9 00 00 	st.d	sp[0],r8
800092fc:	ed b5 00 00 	bld	r5,0x0
80009300:	c4 51       	brne	8000938a <_vfprintf_r+0x162a>
80009302:	33 09       	mov	r9,48
80009304:	f2 0a 18 00 	cp.b	r10,r9
80009308:	c4 10       	breq	8000938a <_vfprintf_r+0x162a>
8000930a:	0c f9       	st.b	--r6,r9
8000930c:	c3 f8       	rjmp	8000938a <_vfprintf_r+0x162a>
8000930e:	fa ea 00 00 	ld.d	r10,sp[0]
80009312:	30 a8       	mov	r8,10
80009314:	30 09       	mov	r9,0
80009316:	e0 a0 1a 19 	rcall	8000c748 <__avr32_umod64>
8000931a:	30 a8       	mov	r8,10
8000931c:	2d 0a       	sub	r10,-48
8000931e:	30 09       	mov	r9,0
80009320:	ac 8a       	st.b	r6[0x0],r10
80009322:	fa ea 00 00 	ld.d	r10,sp[0]
80009326:	e0 a0 18 df 	rcall	8000c4e4 <__avr32_udiv64>
8000932a:	16 99       	mov	r9,r11
8000932c:	14 98       	mov	r8,r10
8000932e:	fa e9 00 00 	st.d	sp[0],r8
80009332:	20 16       	sub	r6,1
80009334:	fa ea 00 00 	ld.d	r10,sp[0]
80009338:	58 9a       	cp.w	r10,9
8000933a:	5c 2b       	cpc	r11
8000933c:	fe 9b ff e9 	brhi	8000930e <_vfprintf_r+0x15ae>
80009340:	1b f8       	ld.ub	r8,sp[0x7]
80009342:	2d 08       	sub	r8,-48
80009344:	c2 08       	rjmp	80009384 <_vfprintf_r+0x1624>
80009346:	04 96       	mov	r6,r2
80009348:	fa e8 00 00 	ld.d	r8,sp[0]
8000934c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009350:	40 de       	lddsp	lr,sp[0x34]
80009352:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009356:	0c fa       	st.b	--r6,r10
80009358:	f2 0b 16 04 	lsr	r11,r9,0x4
8000935c:	f0 0a 16 04 	lsr	r10,r8,0x4
80009360:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009364:	16 99       	mov	r9,r11
80009366:	14 98       	mov	r8,r10
80009368:	58 08       	cp.w	r8,0
8000936a:	5c 29       	cpc	r9
8000936c:	cf 01       	brne	8000934c <_vfprintf_r+0x15ec>
8000936e:	fa e9 00 00 	st.d	sp[0],r8
80009372:	c0 c8       	rjmp	8000938a <_vfprintf_r+0x162a>
80009374:	58 08       	cp.w	r8,0
80009376:	c0 91       	brne	80009388 <_vfprintf_r+0x1628>
80009378:	ed b5 00 00 	bld	r5,0x0
8000937c:	c0 61       	brne	80009388 <_vfprintf_r+0x1628>
8000937e:	fa c6 f9 79 	sub	r6,sp,-1671
80009382:	33 08       	mov	r8,48
80009384:	ac 88       	st.b	r6[0x0],r8
80009386:	c0 28       	rjmp	8000938a <_vfprintf_r+0x162a>
80009388:	04 96       	mov	r6,r2
8000938a:	0c 12       	sub	r2,r6
8000938c:	c1 c8       	rjmp	800093c4 <_vfprintf_r+0x1664>
8000938e:	50 a7       	stdsp	sp[0x28],r7
80009390:	50 80       	stdsp	sp[0x20],r0
80009392:	40 93       	lddsp	r3,sp[0x24]
80009394:	0c 97       	mov	r7,r6
80009396:	10 90       	mov	r0,r8
80009398:	04 94       	mov	r4,r2
8000939a:	40 41       	lddsp	r1,sp[0x10]
8000939c:	58 08       	cp.w	r8,0
8000939e:	e0 80 04 4f 	breq	80009c3c <_vfprintf_r+0x1edc>
800093a2:	fb 68 06 60 	st.b	sp[1632],r8
800093a6:	30 0c       	mov	r12,0
800093a8:	30 08       	mov	r8,0
800093aa:	30 12       	mov	r2,1
800093ac:	fb 68 06 bb 	st.b	sp[1723],r8
800093b0:	50 2c       	stdsp	sp[0x8],r12
800093b2:	fa c6 f9 a0 	sub	r6,sp,-1632
800093b6:	c0 78       	rjmp	800093c4 <_vfprintf_r+0x1664>
800093b8:	30 0b       	mov	r11,0
800093ba:	50 2b       	stdsp	sp[0x8],r11
800093bc:	c0 48       	rjmp	800093c4 <_vfprintf_r+0x1664>
800093be:	40 22       	lddsp	r2,sp[0x8]
800093c0:	30 0a       	mov	r10,0
800093c2:	50 2a       	stdsp	sp[0x8],r10
800093c4:	40 29       	lddsp	r9,sp[0x8]
800093c6:	e4 09 0c 49 	max	r9,r2,r9
800093ca:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800093ce:	50 39       	stdsp	sp[0xc],r9
800093d0:	0a 9e       	mov	lr,r5
800093d2:	30 09       	mov	r9,0
800093d4:	e2 1e 00 02 	andl	lr,0x2,COH
800093d8:	f2 08 18 00 	cp.b	r8,r9
800093dc:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800093e0:	f7 b8 01 ff 	subne	r8,-1
800093e4:	fb f8 1a 03 	st.wne	sp[0xc],r8
800093e8:	0a 9b       	mov	r11,r5
800093ea:	58 0e       	cp.w	lr,0
800093ec:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800093f0:	f7 bc 01 fe 	subne	r12,-2
800093f4:	fb fc 1a 03 	st.wne	sp[0xc],r12
800093f8:	e2 1b 00 84 	andl	r11,0x84,COH
800093fc:	50 fe       	stdsp	sp[0x3c],lr
800093fe:	50 9b       	stdsp	sp[0x24],r11
80009400:	c4 71       	brne	8000948e <_vfprintf_r+0x172e>
80009402:	40 8a       	lddsp	r10,sp[0x20]
80009404:	40 39       	lddsp	r9,sp[0xc]
80009406:	12 1a       	sub	r10,r9
80009408:	50 4a       	stdsp	sp[0x10],r10
8000940a:	58 0a       	cp.w	r10,0
8000940c:	e0 89 00 20 	brgt	8000944c <_vfprintf_r+0x16ec>
80009410:	c3 f8       	rjmp	8000948e <_vfprintf_r+0x172e>
80009412:	2f 09       	sub	r9,-16
80009414:	2f f8       	sub	r8,-1
80009416:	fe ce b3 42 	sub	lr,pc,-19646
8000941a:	31 0c       	mov	r12,16
8000941c:	fb 49 06 90 	st.w	sp[1680],r9
80009420:	87 0e       	st.w	r3[0x0],lr
80009422:	87 1c       	st.w	r3[0x4],r12
80009424:	fb 48 06 8c 	st.w	sp[1676],r8
80009428:	58 78       	cp.w	r8,7
8000942a:	e0 89 00 04 	brgt	80009432 <_vfprintf_r+0x16d2>
8000942e:	2f 83       	sub	r3,-8
80009430:	c0 b8       	rjmp	80009446 <_vfprintf_r+0x16e6>
80009432:	fa ca f9 78 	sub	r10,sp,-1672
80009436:	02 9b       	mov	r11,r1
80009438:	08 9c       	mov	r12,r4
8000943a:	fe b0 f4 85 	rcall	80007d44 <__sprint_r>
8000943e:	e0 81 04 10 	brne	80009c5e <_vfprintf_r+0x1efe>
80009442:	fa c3 f9 e0 	sub	r3,sp,-1568
80009446:	40 4b       	lddsp	r11,sp[0x10]
80009448:	21 0b       	sub	r11,16
8000944a:	50 4b       	stdsp	sp[0x10],r11
8000944c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009450:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009454:	fe ca b3 80 	sub	r10,pc,-19584
80009458:	40 4e       	lddsp	lr,sp[0x10]
8000945a:	59 0e       	cp.w	lr,16
8000945c:	fe 99 ff db 	brgt	80009412 <_vfprintf_r+0x16b2>
80009460:	1c 09       	add	r9,lr
80009462:	2f f8       	sub	r8,-1
80009464:	87 0a       	st.w	r3[0x0],r10
80009466:	fb 49 06 90 	st.w	sp[1680],r9
8000946a:	87 1e       	st.w	r3[0x4],lr
8000946c:	fb 48 06 8c 	st.w	sp[1676],r8
80009470:	58 78       	cp.w	r8,7
80009472:	e0 89 00 04 	brgt	8000947a <_vfprintf_r+0x171a>
80009476:	2f 83       	sub	r3,-8
80009478:	c0 b8       	rjmp	8000948e <_vfprintf_r+0x172e>
8000947a:	fa ca f9 78 	sub	r10,sp,-1672
8000947e:	02 9b       	mov	r11,r1
80009480:	08 9c       	mov	r12,r4
80009482:	fe b0 f4 61 	rcall	80007d44 <__sprint_r>
80009486:	e0 81 03 ec 	brne	80009c5e <_vfprintf_r+0x1efe>
8000948a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000948e:	30 09       	mov	r9,0
80009490:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009494:	f2 08 18 00 	cp.b	r8,r9
80009498:	c1 f0       	breq	800094d6 <_vfprintf_r+0x1776>
8000949a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000949e:	fa c9 f9 45 	sub	r9,sp,-1723
800094a2:	2f f8       	sub	r8,-1
800094a4:	87 09       	st.w	r3[0x0],r9
800094a6:	fb 48 06 90 	st.w	sp[1680],r8
800094aa:	30 19       	mov	r9,1
800094ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094b0:	87 19       	st.w	r3[0x4],r9
800094b2:	2f f8       	sub	r8,-1
800094b4:	fb 48 06 8c 	st.w	sp[1676],r8
800094b8:	58 78       	cp.w	r8,7
800094ba:	e0 89 00 04 	brgt	800094c2 <_vfprintf_r+0x1762>
800094be:	2f 83       	sub	r3,-8
800094c0:	c0 b8       	rjmp	800094d6 <_vfprintf_r+0x1776>
800094c2:	fa ca f9 78 	sub	r10,sp,-1672
800094c6:	02 9b       	mov	r11,r1
800094c8:	08 9c       	mov	r12,r4
800094ca:	fe b0 f4 3d 	rcall	80007d44 <__sprint_r>
800094ce:	e0 81 03 c8 	brne	80009c5e <_vfprintf_r+0x1efe>
800094d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800094d6:	40 fc       	lddsp	r12,sp[0x3c]
800094d8:	58 0c       	cp.w	r12,0
800094da:	c1 f0       	breq	80009518 <_vfprintf_r+0x17b8>
800094dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800094e0:	fa c9 f9 48 	sub	r9,sp,-1720
800094e4:	2f e8       	sub	r8,-2
800094e6:	87 09       	st.w	r3[0x0],r9
800094e8:	fb 48 06 90 	st.w	sp[1680],r8
800094ec:	30 29       	mov	r9,2
800094ee:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094f2:	87 19       	st.w	r3[0x4],r9
800094f4:	2f f8       	sub	r8,-1
800094f6:	fb 48 06 8c 	st.w	sp[1676],r8
800094fa:	58 78       	cp.w	r8,7
800094fc:	e0 89 00 04 	brgt	80009504 <_vfprintf_r+0x17a4>
80009500:	2f 83       	sub	r3,-8
80009502:	c0 b8       	rjmp	80009518 <_vfprintf_r+0x17b8>
80009504:	fa ca f9 78 	sub	r10,sp,-1672
80009508:	02 9b       	mov	r11,r1
8000950a:	08 9c       	mov	r12,r4
8000950c:	fe b0 f4 1c 	rcall	80007d44 <__sprint_r>
80009510:	e0 81 03 a7 	brne	80009c5e <_vfprintf_r+0x1efe>
80009514:	fa c3 f9 e0 	sub	r3,sp,-1568
80009518:	40 9b       	lddsp	r11,sp[0x24]
8000951a:	e0 4b 00 80 	cp.w	r11,128
8000951e:	c4 71       	brne	800095ac <_vfprintf_r+0x184c>
80009520:	40 8a       	lddsp	r10,sp[0x20]
80009522:	40 39       	lddsp	r9,sp[0xc]
80009524:	12 1a       	sub	r10,r9
80009526:	50 4a       	stdsp	sp[0x10],r10
80009528:	58 0a       	cp.w	r10,0
8000952a:	e0 89 00 20 	brgt	8000956a <_vfprintf_r+0x180a>
8000952e:	c3 f8       	rjmp	800095ac <_vfprintf_r+0x184c>
80009530:	2f 09       	sub	r9,-16
80009532:	2f f8       	sub	r8,-1
80009534:	fe ce b4 50 	sub	lr,pc,-19376
80009538:	31 0c       	mov	r12,16
8000953a:	fb 49 06 90 	st.w	sp[1680],r9
8000953e:	87 0e       	st.w	r3[0x0],lr
80009540:	87 1c       	st.w	r3[0x4],r12
80009542:	fb 48 06 8c 	st.w	sp[1676],r8
80009546:	58 78       	cp.w	r8,7
80009548:	e0 89 00 04 	brgt	80009550 <_vfprintf_r+0x17f0>
8000954c:	2f 83       	sub	r3,-8
8000954e:	c0 b8       	rjmp	80009564 <_vfprintf_r+0x1804>
80009550:	fa ca f9 78 	sub	r10,sp,-1672
80009554:	02 9b       	mov	r11,r1
80009556:	08 9c       	mov	r12,r4
80009558:	fe b0 f3 f6 	rcall	80007d44 <__sprint_r>
8000955c:	e0 81 03 81 	brne	80009c5e <_vfprintf_r+0x1efe>
80009560:	fa c3 f9 e0 	sub	r3,sp,-1568
80009564:	40 4b       	lddsp	r11,sp[0x10]
80009566:	21 0b       	sub	r11,16
80009568:	50 4b       	stdsp	sp[0x10],r11
8000956a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000956e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009572:	fe ca b4 8e 	sub	r10,pc,-19314
80009576:	40 4e       	lddsp	lr,sp[0x10]
80009578:	59 0e       	cp.w	lr,16
8000957a:	fe 99 ff db 	brgt	80009530 <_vfprintf_r+0x17d0>
8000957e:	1c 09       	add	r9,lr
80009580:	2f f8       	sub	r8,-1
80009582:	87 0a       	st.w	r3[0x0],r10
80009584:	fb 49 06 90 	st.w	sp[1680],r9
80009588:	87 1e       	st.w	r3[0x4],lr
8000958a:	fb 48 06 8c 	st.w	sp[1676],r8
8000958e:	58 78       	cp.w	r8,7
80009590:	e0 89 00 04 	brgt	80009598 <_vfprintf_r+0x1838>
80009594:	2f 83       	sub	r3,-8
80009596:	c0 b8       	rjmp	800095ac <_vfprintf_r+0x184c>
80009598:	fa ca f9 78 	sub	r10,sp,-1672
8000959c:	02 9b       	mov	r11,r1
8000959e:	08 9c       	mov	r12,r4
800095a0:	fe b0 f3 d2 	rcall	80007d44 <__sprint_r>
800095a4:	e0 81 03 5d 	brne	80009c5e <_vfprintf_r+0x1efe>
800095a8:	fa c3 f9 e0 	sub	r3,sp,-1568
800095ac:	40 2c       	lddsp	r12,sp[0x8]
800095ae:	04 1c       	sub	r12,r2
800095b0:	50 2c       	stdsp	sp[0x8],r12
800095b2:	58 0c       	cp.w	r12,0
800095b4:	e0 89 00 20 	brgt	800095f4 <_vfprintf_r+0x1894>
800095b8:	c3 f8       	rjmp	80009636 <_vfprintf_r+0x18d6>
800095ba:	2f 09       	sub	r9,-16
800095bc:	2f f8       	sub	r8,-1
800095be:	fe cb b4 da 	sub	r11,pc,-19238
800095c2:	31 0a       	mov	r10,16
800095c4:	fb 49 06 90 	st.w	sp[1680],r9
800095c8:	87 0b       	st.w	r3[0x0],r11
800095ca:	87 1a       	st.w	r3[0x4],r10
800095cc:	fb 48 06 8c 	st.w	sp[1676],r8
800095d0:	58 78       	cp.w	r8,7
800095d2:	e0 89 00 04 	brgt	800095da <_vfprintf_r+0x187a>
800095d6:	2f 83       	sub	r3,-8
800095d8:	c0 b8       	rjmp	800095ee <_vfprintf_r+0x188e>
800095da:	fa ca f9 78 	sub	r10,sp,-1672
800095de:	02 9b       	mov	r11,r1
800095e0:	08 9c       	mov	r12,r4
800095e2:	fe b0 f3 b1 	rcall	80007d44 <__sprint_r>
800095e6:	e0 81 03 3c 	brne	80009c5e <_vfprintf_r+0x1efe>
800095ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800095ee:	40 29       	lddsp	r9,sp[0x8]
800095f0:	21 09       	sub	r9,16
800095f2:	50 29       	stdsp	sp[0x8],r9
800095f4:	fa f9 06 90 	ld.w	r9,sp[1680]
800095f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095fc:	fe ca b5 18 	sub	r10,pc,-19176
80009600:	40 2e       	lddsp	lr,sp[0x8]
80009602:	59 0e       	cp.w	lr,16
80009604:	fe 99 ff db 	brgt	800095ba <_vfprintf_r+0x185a>
80009608:	1c 09       	add	r9,lr
8000960a:	2f f8       	sub	r8,-1
8000960c:	87 0a       	st.w	r3[0x0],r10
8000960e:	fb 49 06 90 	st.w	sp[1680],r9
80009612:	87 1e       	st.w	r3[0x4],lr
80009614:	fb 48 06 8c 	st.w	sp[1676],r8
80009618:	58 78       	cp.w	r8,7
8000961a:	e0 89 00 04 	brgt	80009622 <_vfprintf_r+0x18c2>
8000961e:	2f 83       	sub	r3,-8
80009620:	c0 b8       	rjmp	80009636 <_vfprintf_r+0x18d6>
80009622:	fa ca f9 78 	sub	r10,sp,-1672
80009626:	02 9b       	mov	r11,r1
80009628:	08 9c       	mov	r12,r4
8000962a:	fe b0 f3 8d 	rcall	80007d44 <__sprint_r>
8000962e:	e0 81 03 18 	brne	80009c5e <_vfprintf_r+0x1efe>
80009632:	fa c3 f9 e0 	sub	r3,sp,-1568
80009636:	ed b5 00 08 	bld	r5,0x8
8000963a:	c0 b0       	breq	80009650 <_vfprintf_r+0x18f0>
8000963c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009640:	87 12       	st.w	r3[0x4],r2
80009642:	87 06       	st.w	r3[0x0],r6
80009644:	f0 02 00 02 	add	r2,r8,r2
80009648:	fb 42 06 90 	st.w	sp[1680],r2
8000964c:	e0 8f 01 d4 	bral	800099f4 <_vfprintf_r+0x1c94>
80009650:	e0 40 00 65 	cp.w	r0,101
80009654:	e0 8a 01 d6 	brle	80009a00 <_vfprintf_r+0x1ca0>
80009658:	30 08       	mov	r8,0
8000965a:	30 09       	mov	r9,0
8000965c:	40 5b       	lddsp	r11,sp[0x14]
8000965e:	40 7a       	lddsp	r10,sp[0x1c]
80009660:	e0 a0 15 3b 	rcall	8000c0d6 <__avr32_f64_cmp_eq>
80009664:	c7 90       	breq	80009756 <_vfprintf_r+0x19f6>
80009666:	fa f8 06 90 	ld.w	r8,sp[1680]
8000966a:	fe c9 b5 9a 	sub	r9,pc,-19046
8000966e:	2f f8       	sub	r8,-1
80009670:	87 09       	st.w	r3[0x0],r9
80009672:	fb 48 06 90 	st.w	sp[1680],r8
80009676:	30 19       	mov	r9,1
80009678:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000967c:	87 19       	st.w	r3[0x4],r9
8000967e:	2f f8       	sub	r8,-1
80009680:	fb 48 06 8c 	st.w	sp[1676],r8
80009684:	58 78       	cp.w	r8,7
80009686:	e0 89 00 05 	brgt	80009690 <_vfprintf_r+0x1930>
8000968a:	2f 83       	sub	r3,-8
8000968c:	c0 c8       	rjmp	800096a4 <_vfprintf_r+0x1944>
8000968e:	d7 03       	nop
80009690:	fa ca f9 78 	sub	r10,sp,-1672
80009694:	02 9b       	mov	r11,r1
80009696:	08 9c       	mov	r12,r4
80009698:	fe b0 f3 56 	rcall	80007d44 <__sprint_r>
8000969c:	e0 81 02 e1 	brne	80009c5e <_vfprintf_r+0x1efe>
800096a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800096a4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800096a8:	40 6c       	lddsp	r12,sp[0x18]
800096aa:	18 38       	cp.w	r8,r12
800096ac:	c0 55       	brlt	800096b6 <_vfprintf_r+0x1956>
800096ae:	ed b5 00 00 	bld	r5,0x0
800096b2:	e0 81 02 6b 	brne	80009b88 <_vfprintf_r+0x1e28>
800096b6:	fa f8 06 90 	ld.w	r8,sp[1680]
800096ba:	2f f8       	sub	r8,-1
800096bc:	40 cb       	lddsp	r11,sp[0x30]
800096be:	fb 48 06 90 	st.w	sp[1680],r8
800096c2:	30 19       	mov	r9,1
800096c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096c8:	87 0b       	st.w	r3[0x0],r11
800096ca:	2f f8       	sub	r8,-1
800096cc:	87 19       	st.w	r3[0x4],r9
800096ce:	fb 48 06 8c 	st.w	sp[1676],r8
800096d2:	58 78       	cp.w	r8,7
800096d4:	e0 89 00 04 	brgt	800096dc <_vfprintf_r+0x197c>
800096d8:	2f 83       	sub	r3,-8
800096da:	c0 b8       	rjmp	800096f0 <_vfprintf_r+0x1990>
800096dc:	fa ca f9 78 	sub	r10,sp,-1672
800096e0:	02 9b       	mov	r11,r1
800096e2:	08 9c       	mov	r12,r4
800096e4:	fe b0 f3 30 	rcall	80007d44 <__sprint_r>
800096e8:	e0 81 02 bb 	brne	80009c5e <_vfprintf_r+0x1efe>
800096ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800096f0:	40 66       	lddsp	r6,sp[0x18]
800096f2:	20 16       	sub	r6,1
800096f4:	58 06       	cp.w	r6,0
800096f6:	e0 89 00 1d 	brgt	80009730 <_vfprintf_r+0x19d0>
800096fa:	e0 8f 02 47 	bral	80009b88 <_vfprintf_r+0x1e28>
800096fe:	2f 09       	sub	r9,-16
80009700:	2f f8       	sub	r8,-1
80009702:	fb 49 06 90 	st.w	sp[1680],r9
80009706:	87 02       	st.w	r3[0x0],r2
80009708:	87 10       	st.w	r3[0x4],r0
8000970a:	fb 48 06 8c 	st.w	sp[1676],r8
8000970e:	58 78       	cp.w	r8,7
80009710:	e0 89 00 04 	brgt	80009718 <_vfprintf_r+0x19b8>
80009714:	2f 83       	sub	r3,-8
80009716:	c0 b8       	rjmp	8000972c <_vfprintf_r+0x19cc>
80009718:	fa ca f9 78 	sub	r10,sp,-1672
8000971c:	02 9b       	mov	r11,r1
8000971e:	08 9c       	mov	r12,r4
80009720:	fe b0 f3 12 	rcall	80007d44 <__sprint_r>
80009724:	e0 81 02 9d 	brne	80009c5e <_vfprintf_r+0x1efe>
80009728:	fa c3 f9 e0 	sub	r3,sp,-1568
8000972c:	21 06       	sub	r6,16
8000972e:	c0 48       	rjmp	80009736 <_vfprintf_r+0x19d6>
80009730:	fe c2 b6 4c 	sub	r2,pc,-18868
80009734:	31 00       	mov	r0,16
80009736:	fa f9 06 90 	ld.w	r9,sp[1680]
8000973a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000973e:	fe ca b6 5a 	sub	r10,pc,-18854
80009742:	59 06       	cp.w	r6,16
80009744:	fe 99 ff dd 	brgt	800096fe <_vfprintf_r+0x199e>
80009748:	0c 09       	add	r9,r6
8000974a:	87 0a       	st.w	r3[0x0],r10
8000974c:	fb 49 06 90 	st.w	sp[1680],r9
80009750:	2f f8       	sub	r8,-1
80009752:	87 16       	st.w	r3[0x4],r6
80009754:	c5 39       	rjmp	800099fa <_vfprintf_r+0x1c9a>
80009756:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000975a:	58 0a       	cp.w	r10,0
8000975c:	e0 89 00 92 	brgt	80009880 <_vfprintf_r+0x1b20>
80009760:	fa f8 06 90 	ld.w	r8,sp[1680]
80009764:	fe c9 b6 94 	sub	r9,pc,-18796
80009768:	2f f8       	sub	r8,-1
8000976a:	87 09       	st.w	r3[0x0],r9
8000976c:	fb 48 06 90 	st.w	sp[1680],r8
80009770:	30 19       	mov	r9,1
80009772:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009776:	87 19       	st.w	r3[0x4],r9
80009778:	2f f8       	sub	r8,-1
8000977a:	fb 48 06 8c 	st.w	sp[1676],r8
8000977e:	58 78       	cp.w	r8,7
80009780:	e0 89 00 04 	brgt	80009788 <_vfprintf_r+0x1a28>
80009784:	2f 83       	sub	r3,-8
80009786:	c0 b8       	rjmp	8000979c <_vfprintf_r+0x1a3c>
80009788:	fa ca f9 78 	sub	r10,sp,-1672
8000978c:	02 9b       	mov	r11,r1
8000978e:	08 9c       	mov	r12,r4
80009790:	fe b0 f2 da 	rcall	80007d44 <__sprint_r>
80009794:	e0 81 02 65 	brne	80009c5e <_vfprintf_r+0x1efe>
80009798:	fa c3 f9 e0 	sub	r3,sp,-1568
8000979c:	fa f8 06 ac 	ld.w	r8,sp[1708]
800097a0:	58 08       	cp.w	r8,0
800097a2:	c0 81       	brne	800097b2 <_vfprintf_r+0x1a52>
800097a4:	40 6a       	lddsp	r10,sp[0x18]
800097a6:	58 0a       	cp.w	r10,0
800097a8:	c0 51       	brne	800097b2 <_vfprintf_r+0x1a52>
800097aa:	ed b5 00 00 	bld	r5,0x0
800097ae:	e0 81 01 ed 	brne	80009b88 <_vfprintf_r+0x1e28>
800097b2:	40 c9       	lddsp	r9,sp[0x30]
800097b4:	fa f8 06 90 	ld.w	r8,sp[1680]
800097b8:	2f f8       	sub	r8,-1
800097ba:	87 09       	st.w	r3[0x0],r9
800097bc:	fb 48 06 90 	st.w	sp[1680],r8
800097c0:	30 19       	mov	r9,1
800097c2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097c6:	87 19       	st.w	r3[0x4],r9
800097c8:	2f f8       	sub	r8,-1
800097ca:	fb 48 06 8c 	st.w	sp[1676],r8
800097ce:	58 78       	cp.w	r8,7
800097d0:	e0 89 00 04 	brgt	800097d8 <_vfprintf_r+0x1a78>
800097d4:	2f 83       	sub	r3,-8
800097d6:	c0 b8       	rjmp	800097ec <_vfprintf_r+0x1a8c>
800097d8:	fa ca f9 78 	sub	r10,sp,-1672
800097dc:	02 9b       	mov	r11,r1
800097de:	08 9c       	mov	r12,r4
800097e0:	fe b0 f2 b2 	rcall	80007d44 <__sprint_r>
800097e4:	e0 81 02 3d 	brne	80009c5e <_vfprintf_r+0x1efe>
800097e8:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ec:	fa f2 06 ac 	ld.w	r2,sp[1708]
800097f0:	5c 32       	neg	r2
800097f2:	58 02       	cp.w	r2,0
800097f4:	e0 89 00 1d 	brgt	8000982e <_vfprintf_r+0x1ace>
800097f8:	c3 d8       	rjmp	80009872 <_vfprintf_r+0x1b12>
800097fa:	2f 09       	sub	r9,-16
800097fc:	2f f8       	sub	r8,-1
800097fe:	31 0e       	mov	lr,16
80009800:	fb 49 06 90 	st.w	sp[1680],r9
80009804:	87 00       	st.w	r3[0x0],r0
80009806:	87 1e       	st.w	r3[0x4],lr
80009808:	fb 48 06 8c 	st.w	sp[1676],r8
8000980c:	58 78       	cp.w	r8,7
8000980e:	e0 89 00 04 	brgt	80009816 <_vfprintf_r+0x1ab6>
80009812:	2f 83       	sub	r3,-8
80009814:	c0 b8       	rjmp	8000982a <_vfprintf_r+0x1aca>
80009816:	fa ca f9 78 	sub	r10,sp,-1672
8000981a:	02 9b       	mov	r11,r1
8000981c:	08 9c       	mov	r12,r4
8000981e:	fe b0 f2 93 	rcall	80007d44 <__sprint_r>
80009822:	e0 81 02 1e 	brne	80009c5e <_vfprintf_r+0x1efe>
80009826:	fa c3 f9 e0 	sub	r3,sp,-1568
8000982a:	21 02       	sub	r2,16
8000982c:	c0 38       	rjmp	80009832 <_vfprintf_r+0x1ad2>
8000982e:	fe c0 b7 4a 	sub	r0,pc,-18614
80009832:	fa f9 06 90 	ld.w	r9,sp[1680]
80009836:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000983a:	fe ca b7 56 	sub	r10,pc,-18602
8000983e:	59 02       	cp.w	r2,16
80009840:	fe 99 ff dd 	brgt	800097fa <_vfprintf_r+0x1a9a>
80009844:	04 09       	add	r9,r2
80009846:	2f f8       	sub	r8,-1
80009848:	87 0a       	st.w	r3[0x0],r10
8000984a:	fb 49 06 90 	st.w	sp[1680],r9
8000984e:	87 12       	st.w	r3[0x4],r2
80009850:	fb 48 06 8c 	st.w	sp[1676],r8
80009854:	58 78       	cp.w	r8,7
80009856:	e0 89 00 04 	brgt	8000985e <_vfprintf_r+0x1afe>
8000985a:	2f 83       	sub	r3,-8
8000985c:	c0 b8       	rjmp	80009872 <_vfprintf_r+0x1b12>
8000985e:	fa ca f9 78 	sub	r10,sp,-1672
80009862:	02 9b       	mov	r11,r1
80009864:	08 9c       	mov	r12,r4
80009866:	fe b0 f2 6f 	rcall	80007d44 <__sprint_r>
8000986a:	e0 81 01 fa 	brne	80009c5e <_vfprintf_r+0x1efe>
8000986e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009872:	40 6c       	lddsp	r12,sp[0x18]
80009874:	fa f8 06 90 	ld.w	r8,sp[1680]
80009878:	87 06       	st.w	r3[0x0],r6
8000987a:	87 1c       	st.w	r3[0x4],r12
8000987c:	18 08       	add	r8,r12
8000987e:	cb 98       	rjmp	800099f0 <_vfprintf_r+0x1c90>
80009880:	fa f9 06 90 	ld.w	r9,sp[1680]
80009884:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009888:	40 6b       	lddsp	r11,sp[0x18]
8000988a:	16 3a       	cp.w	r10,r11
8000988c:	c6 f5       	brlt	8000996a <_vfprintf_r+0x1c0a>
8000988e:	16 09       	add	r9,r11
80009890:	2f f8       	sub	r8,-1
80009892:	87 06       	st.w	r3[0x0],r6
80009894:	fb 49 06 90 	st.w	sp[1680],r9
80009898:	87 1b       	st.w	r3[0x4],r11
8000989a:	fb 48 06 8c 	st.w	sp[1676],r8
8000989e:	58 78       	cp.w	r8,7
800098a0:	e0 89 00 04 	brgt	800098a8 <_vfprintf_r+0x1b48>
800098a4:	2f 83       	sub	r3,-8
800098a6:	c0 b8       	rjmp	800098bc <_vfprintf_r+0x1b5c>
800098a8:	fa ca f9 78 	sub	r10,sp,-1672
800098ac:	02 9b       	mov	r11,r1
800098ae:	08 9c       	mov	r12,r4
800098b0:	fe b0 f2 4a 	rcall	80007d44 <__sprint_r>
800098b4:	e0 81 01 d5 	brne	80009c5e <_vfprintf_r+0x1efe>
800098b8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098bc:	fa f6 06 ac 	ld.w	r6,sp[1708]
800098c0:	40 6a       	lddsp	r10,sp[0x18]
800098c2:	14 16       	sub	r6,r10
800098c4:	58 06       	cp.w	r6,0
800098c6:	e0 89 00 1c 	brgt	800098fe <_vfprintf_r+0x1b9e>
800098ca:	c3 d8       	rjmp	80009944 <_vfprintf_r+0x1be4>
800098cc:	2f 09       	sub	r9,-16
800098ce:	2f f8       	sub	r8,-1
800098d0:	fb 49 06 90 	st.w	sp[1680],r9
800098d4:	87 02       	st.w	r3[0x0],r2
800098d6:	87 10       	st.w	r3[0x4],r0
800098d8:	fb 48 06 8c 	st.w	sp[1676],r8
800098dc:	58 78       	cp.w	r8,7
800098de:	e0 89 00 04 	brgt	800098e6 <_vfprintf_r+0x1b86>
800098e2:	2f 83       	sub	r3,-8
800098e4:	c0 b8       	rjmp	800098fa <_vfprintf_r+0x1b9a>
800098e6:	fa ca f9 78 	sub	r10,sp,-1672
800098ea:	02 9b       	mov	r11,r1
800098ec:	08 9c       	mov	r12,r4
800098ee:	fe b0 f2 2b 	rcall	80007d44 <__sprint_r>
800098f2:	e0 81 01 b6 	brne	80009c5e <_vfprintf_r+0x1efe>
800098f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800098fa:	21 06       	sub	r6,16
800098fc:	c0 48       	rjmp	80009904 <_vfprintf_r+0x1ba4>
800098fe:	fe c2 b8 1a 	sub	r2,pc,-18406
80009902:	31 00       	mov	r0,16
80009904:	fa f9 06 90 	ld.w	r9,sp[1680]
80009908:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000990c:	fe ca b8 28 	sub	r10,pc,-18392
80009910:	59 06       	cp.w	r6,16
80009912:	fe 99 ff dd 	brgt	800098cc <_vfprintf_r+0x1b6c>
80009916:	0c 09       	add	r9,r6
80009918:	2f f8       	sub	r8,-1
8000991a:	87 0a       	st.w	r3[0x0],r10
8000991c:	fb 49 06 90 	st.w	sp[1680],r9
80009920:	87 16       	st.w	r3[0x4],r6
80009922:	fb 48 06 8c 	st.w	sp[1676],r8
80009926:	58 78       	cp.w	r8,7
80009928:	e0 89 00 04 	brgt	80009930 <_vfprintf_r+0x1bd0>
8000992c:	2f 83       	sub	r3,-8
8000992e:	c0 b8       	rjmp	80009944 <_vfprintf_r+0x1be4>
80009930:	fa ca f9 78 	sub	r10,sp,-1672
80009934:	02 9b       	mov	r11,r1
80009936:	08 9c       	mov	r12,r4
80009938:	fe b0 f2 06 	rcall	80007d44 <__sprint_r>
8000993c:	e0 81 01 91 	brne	80009c5e <_vfprintf_r+0x1efe>
80009940:	fa c3 f9 e0 	sub	r3,sp,-1568
80009944:	ed b5 00 00 	bld	r5,0x0
80009948:	e0 81 01 20 	brne	80009b88 <_vfprintf_r+0x1e28>
8000994c:	40 c9       	lddsp	r9,sp[0x30]
8000994e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009952:	2f f8       	sub	r8,-1
80009954:	87 09       	st.w	r3[0x0],r9
80009956:	fb 48 06 90 	st.w	sp[1680],r8
8000995a:	30 19       	mov	r9,1
8000995c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009960:	87 19       	st.w	r3[0x4],r9
80009962:	2f f8       	sub	r8,-1
80009964:	fb 48 06 8c 	st.w	sp[1676],r8
80009968:	c0 29       	rjmp	80009b6c <_vfprintf_r+0x1e0c>
8000996a:	14 09       	add	r9,r10
8000996c:	2f f8       	sub	r8,-1
8000996e:	fb 49 06 90 	st.w	sp[1680],r9
80009972:	87 06       	st.w	r3[0x0],r6
80009974:	87 1a       	st.w	r3[0x4],r10
80009976:	fb 48 06 8c 	st.w	sp[1676],r8
8000997a:	58 78       	cp.w	r8,7
8000997c:	e0 89 00 04 	brgt	80009984 <_vfprintf_r+0x1c24>
80009980:	2f 83       	sub	r3,-8
80009982:	c0 b8       	rjmp	80009998 <_vfprintf_r+0x1c38>
80009984:	fa ca f9 78 	sub	r10,sp,-1672
80009988:	02 9b       	mov	r11,r1
8000998a:	08 9c       	mov	r12,r4
8000998c:	fe b0 f1 dc 	rcall	80007d44 <__sprint_r>
80009990:	e0 81 01 67 	brne	80009c5e <_vfprintf_r+0x1efe>
80009994:	fa c3 f9 e0 	sub	r3,sp,-1568
80009998:	40 c8       	lddsp	r8,sp[0x30]
8000999a:	87 08       	st.w	r3[0x0],r8
8000999c:	fa f8 06 90 	ld.w	r8,sp[1680]
800099a0:	2f f8       	sub	r8,-1
800099a2:	30 19       	mov	r9,1
800099a4:	fb 48 06 90 	st.w	sp[1680],r8
800099a8:	87 19       	st.w	r3[0x4],r9
800099aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099ae:	2f f8       	sub	r8,-1
800099b0:	fb 48 06 8c 	st.w	sp[1676],r8
800099b4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800099b8:	58 78       	cp.w	r8,7
800099ba:	e0 89 00 04 	brgt	800099c2 <_vfprintf_r+0x1c62>
800099be:	2f 83       	sub	r3,-8
800099c0:	c0 b8       	rjmp	800099d6 <_vfprintf_r+0x1c76>
800099c2:	fa ca f9 78 	sub	r10,sp,-1672
800099c6:	02 9b       	mov	r11,r1
800099c8:	08 9c       	mov	r12,r4
800099ca:	fe b0 f1 bd 	rcall	80007d44 <__sprint_r>
800099ce:	e0 81 01 48 	brne	80009c5e <_vfprintf_r+0x1efe>
800099d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d6:	04 06       	add	r6,r2
800099d8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800099dc:	87 06       	st.w	r3[0x0],r6
800099de:	fa f9 06 90 	ld.w	r9,sp[1680]
800099e2:	40 66       	lddsp	r6,sp[0x18]
800099e4:	40 6e       	lddsp	lr,sp[0x18]
800099e6:	10 16       	sub	r6,r8
800099e8:	f2 08 01 08 	sub	r8,r9,r8
800099ec:	87 16       	st.w	r3[0x4],r6
800099ee:	1c 08       	add	r8,lr
800099f0:	fb 48 06 90 	st.w	sp[1680],r8
800099f4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099f8:	2f f8       	sub	r8,-1
800099fa:	fb 48 06 8c 	st.w	sp[1676],r8
800099fe:	cb 78       	rjmp	80009b6c <_vfprintf_r+0x1e0c>
80009a00:	40 6c       	lddsp	r12,sp[0x18]
80009a02:	58 1c       	cp.w	r12,1
80009a04:	e0 89 00 06 	brgt	80009a10 <_vfprintf_r+0x1cb0>
80009a08:	ed b5 00 00 	bld	r5,0x0
80009a0c:	e0 81 00 85 	brne	80009b16 <_vfprintf_r+0x1db6>
80009a10:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a14:	2f f8       	sub	r8,-1
80009a16:	30 19       	mov	r9,1
80009a18:	fb 48 06 90 	st.w	sp[1680],r8
80009a1c:	87 06       	st.w	r3[0x0],r6
80009a1e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a22:	87 19       	st.w	r3[0x4],r9
80009a24:	2f f8       	sub	r8,-1
80009a26:	fb 48 06 8c 	st.w	sp[1676],r8
80009a2a:	58 78       	cp.w	r8,7
80009a2c:	e0 89 00 04 	brgt	80009a34 <_vfprintf_r+0x1cd4>
80009a30:	2f 83       	sub	r3,-8
80009a32:	c0 b8       	rjmp	80009a48 <_vfprintf_r+0x1ce8>
80009a34:	fa ca f9 78 	sub	r10,sp,-1672
80009a38:	02 9b       	mov	r11,r1
80009a3a:	08 9c       	mov	r12,r4
80009a3c:	fe b0 f1 84 	rcall	80007d44 <__sprint_r>
80009a40:	e0 81 01 0f 	brne	80009c5e <_vfprintf_r+0x1efe>
80009a44:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a48:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a4c:	2f f8       	sub	r8,-1
80009a4e:	40 cb       	lddsp	r11,sp[0x30]
80009a50:	fb 48 06 90 	st.w	sp[1680],r8
80009a54:	30 19       	mov	r9,1
80009a56:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a5a:	87 0b       	st.w	r3[0x0],r11
80009a5c:	2f f8       	sub	r8,-1
80009a5e:	87 19       	st.w	r3[0x4],r9
80009a60:	fb 48 06 8c 	st.w	sp[1676],r8
80009a64:	58 78       	cp.w	r8,7
80009a66:	e0 89 00 05 	brgt	80009a70 <_vfprintf_r+0x1d10>
80009a6a:	2f 83       	sub	r3,-8
80009a6c:	c0 c8       	rjmp	80009a84 <_vfprintf_r+0x1d24>
80009a6e:	d7 03       	nop
80009a70:	fa ca f9 78 	sub	r10,sp,-1672
80009a74:	02 9b       	mov	r11,r1
80009a76:	08 9c       	mov	r12,r4
80009a78:	fe b0 f1 66 	rcall	80007d44 <__sprint_r>
80009a7c:	e0 81 00 f1 	brne	80009c5e <_vfprintf_r+0x1efe>
80009a80:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a84:	30 08       	mov	r8,0
80009a86:	30 09       	mov	r9,0
80009a88:	40 5b       	lddsp	r11,sp[0x14]
80009a8a:	40 7a       	lddsp	r10,sp[0x1c]
80009a8c:	e0 a0 13 25 	rcall	8000c0d6 <__avr32_f64_cmp_eq>
80009a90:	40 68       	lddsp	r8,sp[0x18]
80009a92:	20 18       	sub	r8,1
80009a94:	58 0c       	cp.w	r12,0
80009a96:	c0 d1       	brne	80009ab0 <_vfprintf_r+0x1d50>
80009a98:	2f f6       	sub	r6,-1
80009a9a:	87 18       	st.w	r3[0x4],r8
80009a9c:	87 06       	st.w	r3[0x0],r6
80009a9e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009aa2:	10 06       	add	r6,r8
80009aa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aa8:	fb 46 06 90 	st.w	sp[1680],r6
80009aac:	2f f8       	sub	r8,-1
80009aae:	c3 18       	rjmp	80009b10 <_vfprintf_r+0x1db0>
80009ab0:	10 96       	mov	r6,r8
80009ab2:	58 08       	cp.w	r8,0
80009ab4:	e0 89 00 1c 	brgt	80009aec <_vfprintf_r+0x1d8c>
80009ab8:	c4 b8       	rjmp	80009b4e <_vfprintf_r+0x1dee>
80009aba:	2f 09       	sub	r9,-16
80009abc:	2f f8       	sub	r8,-1
80009abe:	fb 49 06 90 	st.w	sp[1680],r9
80009ac2:	87 02       	st.w	r3[0x0],r2
80009ac4:	87 10       	st.w	r3[0x4],r0
80009ac6:	fb 48 06 8c 	st.w	sp[1676],r8
80009aca:	58 78       	cp.w	r8,7
80009acc:	e0 89 00 04 	brgt	80009ad4 <_vfprintf_r+0x1d74>
80009ad0:	2f 83       	sub	r3,-8
80009ad2:	c0 b8       	rjmp	80009ae8 <_vfprintf_r+0x1d88>
80009ad4:	fa ca f9 78 	sub	r10,sp,-1672
80009ad8:	02 9b       	mov	r11,r1
80009ada:	08 9c       	mov	r12,r4
80009adc:	fe b0 f1 34 	rcall	80007d44 <__sprint_r>
80009ae0:	e0 81 00 bf 	brne	80009c5e <_vfprintf_r+0x1efe>
80009ae4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ae8:	21 06       	sub	r6,16
80009aea:	c0 48       	rjmp	80009af2 <_vfprintf_r+0x1d92>
80009aec:	fe c2 ba 08 	sub	r2,pc,-17912
80009af0:	31 00       	mov	r0,16
80009af2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009af6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009afa:	fe ca ba 16 	sub	r10,pc,-17898
80009afe:	59 06       	cp.w	r6,16
80009b00:	fe 99 ff dd 	brgt	80009aba <_vfprintf_r+0x1d5a>
80009b04:	0c 09       	add	r9,r6
80009b06:	87 0a       	st.w	r3[0x0],r10
80009b08:	fb 49 06 90 	st.w	sp[1680],r9
80009b0c:	2f f8       	sub	r8,-1
80009b0e:	87 16       	st.w	r3[0x4],r6
80009b10:	fb 48 06 8c 	st.w	sp[1676],r8
80009b14:	c0 e8       	rjmp	80009b30 <_vfprintf_r+0x1dd0>
80009b16:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b1a:	2f f8       	sub	r8,-1
80009b1c:	30 19       	mov	r9,1
80009b1e:	fb 48 06 90 	st.w	sp[1680],r8
80009b22:	87 06       	st.w	r3[0x0],r6
80009b24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b28:	87 19       	st.w	r3[0x4],r9
80009b2a:	2f f8       	sub	r8,-1
80009b2c:	fb 48 06 8c 	st.w	sp[1676],r8
80009b30:	58 78       	cp.w	r8,7
80009b32:	e0 89 00 04 	brgt	80009b3a <_vfprintf_r+0x1dda>
80009b36:	2f 83       	sub	r3,-8
80009b38:	c0 b8       	rjmp	80009b4e <_vfprintf_r+0x1dee>
80009b3a:	fa ca f9 78 	sub	r10,sp,-1672
80009b3e:	02 9b       	mov	r11,r1
80009b40:	08 9c       	mov	r12,r4
80009b42:	fe b0 f1 01 	rcall	80007d44 <__sprint_r>
80009b46:	e0 81 00 8c 	brne	80009c5e <_vfprintf_r+0x1efe>
80009b4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b4e:	40 ea       	lddsp	r10,sp[0x38]
80009b50:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b54:	14 08       	add	r8,r10
80009b56:	fa c9 f9 64 	sub	r9,sp,-1692
80009b5a:	fb 48 06 90 	st.w	sp[1680],r8
80009b5e:	87 1a       	st.w	r3[0x4],r10
80009b60:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b64:	87 09       	st.w	r3[0x0],r9
80009b66:	2f f8       	sub	r8,-1
80009b68:	fb 48 06 8c 	st.w	sp[1676],r8
80009b6c:	58 78       	cp.w	r8,7
80009b6e:	e0 89 00 04 	brgt	80009b76 <_vfprintf_r+0x1e16>
80009b72:	2f 83       	sub	r3,-8
80009b74:	c0 a8       	rjmp	80009b88 <_vfprintf_r+0x1e28>
80009b76:	fa ca f9 78 	sub	r10,sp,-1672
80009b7a:	02 9b       	mov	r11,r1
80009b7c:	08 9c       	mov	r12,r4
80009b7e:	fe b0 f0 e3 	rcall	80007d44 <__sprint_r>
80009b82:	c6 e1       	brne	80009c5e <_vfprintf_r+0x1efe>
80009b84:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b88:	e2 15 00 04 	andl	r5,0x4,COH
80009b8c:	c3 f0       	breq	80009c0a <_vfprintf_r+0x1eaa>
80009b8e:	40 86       	lddsp	r6,sp[0x20]
80009b90:	40 39       	lddsp	r9,sp[0xc]
80009b92:	12 16       	sub	r6,r9
80009b94:	58 06       	cp.w	r6,0
80009b96:	e0 89 00 1a 	brgt	80009bca <_vfprintf_r+0x1e6a>
80009b9a:	c3 88       	rjmp	80009c0a <_vfprintf_r+0x1eaa>
80009b9c:	2f 09       	sub	r9,-16
80009b9e:	2f f8       	sub	r8,-1
80009ba0:	fb 49 06 90 	st.w	sp[1680],r9
80009ba4:	87 05       	st.w	r3[0x0],r5
80009ba6:	87 12       	st.w	r3[0x4],r2
80009ba8:	fb 48 06 8c 	st.w	sp[1676],r8
80009bac:	58 78       	cp.w	r8,7
80009bae:	e0 89 00 04 	brgt	80009bb6 <_vfprintf_r+0x1e56>
80009bb2:	2f 83       	sub	r3,-8
80009bb4:	c0 98       	rjmp	80009bc6 <_vfprintf_r+0x1e66>
80009bb6:	00 9a       	mov	r10,r0
80009bb8:	02 9b       	mov	r11,r1
80009bba:	08 9c       	mov	r12,r4
80009bbc:	fe b0 f0 c4 	rcall	80007d44 <__sprint_r>
80009bc0:	c4 f1       	brne	80009c5e <_vfprintf_r+0x1efe>
80009bc2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bc6:	21 06       	sub	r6,16
80009bc8:	c0 68       	rjmp	80009bd4 <_vfprintf_r+0x1e74>
80009bca:	fe c5 ba f6 	sub	r5,pc,-17674
80009bce:	31 02       	mov	r2,16
80009bd0:	fa c0 f9 78 	sub	r0,sp,-1672
80009bd4:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bd8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bdc:	fe ca bb 08 	sub	r10,pc,-17656
80009be0:	59 06       	cp.w	r6,16
80009be2:	fe 99 ff dd 	brgt	80009b9c <_vfprintf_r+0x1e3c>
80009be6:	0c 09       	add	r9,r6
80009be8:	2f f8       	sub	r8,-1
80009bea:	87 0a       	st.w	r3[0x0],r10
80009bec:	87 16       	st.w	r3[0x4],r6
80009bee:	fb 49 06 90 	st.w	sp[1680],r9
80009bf2:	fb 48 06 8c 	st.w	sp[1676],r8
80009bf6:	58 78       	cp.w	r8,7
80009bf8:	e0 8a 00 09 	brle	80009c0a <_vfprintf_r+0x1eaa>
80009bfc:	fa ca f9 78 	sub	r10,sp,-1672
80009c00:	02 9b       	mov	r11,r1
80009c02:	08 9c       	mov	r12,r4
80009c04:	fe b0 f0 a0 	rcall	80007d44 <__sprint_r>
80009c08:	c2 b1       	brne	80009c5e <_vfprintf_r+0x1efe>
80009c0a:	40 bc       	lddsp	r12,sp[0x2c]
80009c0c:	40 36       	lddsp	r6,sp[0xc]
80009c0e:	40 8e       	lddsp	lr,sp[0x20]
80009c10:	ec 0e 0c 48 	max	r8,r6,lr
80009c14:	10 0c       	add	r12,r8
80009c16:	50 bc       	stdsp	sp[0x2c],r12
80009c18:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c1c:	58 08       	cp.w	r8,0
80009c1e:	c0 80       	breq	80009c2e <_vfprintf_r+0x1ece>
80009c20:	fa ca f9 78 	sub	r10,sp,-1672
80009c24:	02 9b       	mov	r11,r1
80009c26:	08 9c       	mov	r12,r4
80009c28:	fe b0 f0 8e 	rcall	80007d44 <__sprint_r>
80009c2c:	c1 91       	brne	80009c5e <_vfprintf_r+0x1efe>
80009c2e:	30 0b       	mov	r11,0
80009c30:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c34:	fb 4b 06 8c 	st.w	sp[1676],r11
80009c38:	fe 9f f1 22 	bral	80007e7c <_vfprintf_r+0x11c>
80009c3c:	08 95       	mov	r5,r4
80009c3e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c42:	58 08       	cp.w	r8,0
80009c44:	c0 80       	breq	80009c54 <_vfprintf_r+0x1ef4>
80009c46:	08 9c       	mov	r12,r4
80009c48:	fa ca f9 78 	sub	r10,sp,-1672
80009c4c:	02 9b       	mov	r11,r1
80009c4e:	fe b0 f0 7b 	rcall	80007d44 <__sprint_r>
80009c52:	c0 61       	brne	80009c5e <_vfprintf_r+0x1efe>
80009c54:	30 08       	mov	r8,0
80009c56:	fb 48 06 8c 	st.w	sp[1676],r8
80009c5a:	c0 28       	rjmp	80009c5e <_vfprintf_r+0x1efe>
80009c5c:	40 41       	lddsp	r1,sp[0x10]
80009c5e:	82 68       	ld.sh	r8,r1[0xc]
80009c60:	ed b8 00 06 	bld	r8,0x6
80009c64:	c0 31       	brne	80009c6a <_vfprintf_r+0x1f0a>
80009c66:	3f fa       	mov	r10,-1
80009c68:	50 ba       	stdsp	sp[0x2c],r10
80009c6a:	40 bc       	lddsp	r12,sp[0x2c]
80009c6c:	fe 3d f9 44 	sub	sp,-1724
80009c70:	d8 32       	popm	r0-r7,pc
80009c72:	d7 03       	nop

80009c74 <__swsetup_r>:
80009c74:	d4 21       	pushm	r4-r7,lr
80009c76:	e0 68 0a 38 	mov	r8,2616
80009c7a:	18 96       	mov	r6,r12
80009c7c:	16 97       	mov	r7,r11
80009c7e:	70 0c       	ld.w	r12,r8[0x0]
80009c80:	58 0c       	cp.w	r12,0
80009c82:	c0 60       	breq	80009c8e <__swsetup_r+0x1a>
80009c84:	78 68       	ld.w	r8,r12[0x18]
80009c86:	58 08       	cp.w	r8,0
80009c88:	c0 31       	brne	80009c8e <__swsetup_r+0x1a>
80009c8a:	e0 a0 07 bf 	rcall	8000ac08 <__sinit>
80009c8e:	fe c8 ba 8a 	sub	r8,pc,-17782
80009c92:	10 37       	cp.w	r7,r8
80009c94:	c0 61       	brne	80009ca0 <__swsetup_r+0x2c>
80009c96:	e0 68 0a 38 	mov	r8,2616
80009c9a:	70 08       	ld.w	r8,r8[0x0]
80009c9c:	70 07       	ld.w	r7,r8[0x0]
80009c9e:	c1 28       	rjmp	80009cc2 <__swsetup_r+0x4e>
80009ca0:	fe c8 ba 7c 	sub	r8,pc,-17796
80009ca4:	10 37       	cp.w	r7,r8
80009ca6:	c0 61       	brne	80009cb2 <__swsetup_r+0x3e>
80009ca8:	e0 68 0a 38 	mov	r8,2616
80009cac:	70 08       	ld.w	r8,r8[0x0]
80009cae:	70 17       	ld.w	r7,r8[0x4]
80009cb0:	c0 98       	rjmp	80009cc2 <__swsetup_r+0x4e>
80009cb2:	fe c8 ba 6e 	sub	r8,pc,-17810
80009cb6:	10 37       	cp.w	r7,r8
80009cb8:	c0 51       	brne	80009cc2 <__swsetup_r+0x4e>
80009cba:	e0 68 0a 38 	mov	r8,2616
80009cbe:	70 08       	ld.w	r8,r8[0x0]
80009cc0:	70 27       	ld.w	r7,r8[0x8]
80009cc2:	8e 68       	ld.sh	r8,r7[0xc]
80009cc4:	ed b8 00 03 	bld	r8,0x3
80009cc8:	c1 e0       	breq	80009d04 <__swsetup_r+0x90>
80009cca:	ed b8 00 04 	bld	r8,0x4
80009cce:	c3 e1       	brne	80009d4a <__swsetup_r+0xd6>
80009cd0:	ed b8 00 02 	bld	r8,0x2
80009cd4:	c1 51       	brne	80009cfe <__swsetup_r+0x8a>
80009cd6:	6e db       	ld.w	r11,r7[0x34]
80009cd8:	58 0b       	cp.w	r11,0
80009cda:	c0 a0       	breq	80009cee <__swsetup_r+0x7a>
80009cdc:	ee c8 ff bc 	sub	r8,r7,-68
80009ce0:	10 3b       	cp.w	r11,r8
80009ce2:	c0 40       	breq	80009cea <__swsetup_r+0x76>
80009ce4:	0c 9c       	mov	r12,r6
80009ce6:	e0 a0 08 2b 	rcall	8000ad3c <_free_r>
80009cea:	30 08       	mov	r8,0
80009cec:	8f d8       	st.w	r7[0x34],r8
80009cee:	8e 68       	ld.sh	r8,r7[0xc]
80009cf0:	e0 18 ff db 	andl	r8,0xffdb
80009cf4:	ae 68       	st.h	r7[0xc],r8
80009cf6:	30 08       	mov	r8,0
80009cf8:	8f 18       	st.w	r7[0x4],r8
80009cfa:	6e 48       	ld.w	r8,r7[0x10]
80009cfc:	8f 08       	st.w	r7[0x0],r8
80009cfe:	8e 68       	ld.sh	r8,r7[0xc]
80009d00:	a3 b8       	sbr	r8,0x3
80009d02:	ae 68       	st.h	r7[0xc],r8
80009d04:	6e 48       	ld.w	r8,r7[0x10]
80009d06:	58 08       	cp.w	r8,0
80009d08:	c0 b1       	brne	80009d1e <__swsetup_r+0xaa>
80009d0a:	8e 68       	ld.sh	r8,r7[0xc]
80009d0c:	e2 18 02 80 	andl	r8,0x280,COH
80009d10:	e0 48 02 00 	cp.w	r8,512
80009d14:	c0 50       	breq	80009d1e <__swsetup_r+0xaa>
80009d16:	0c 9c       	mov	r12,r6
80009d18:	0e 9b       	mov	r11,r7
80009d1a:	e0 a0 0a 4b 	rcall	8000b1b0 <__smakebuf_r>
80009d1e:	8e 69       	ld.sh	r9,r7[0xc]
80009d20:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009d24:	c0 70       	breq	80009d32 <__swsetup_r+0xbe>
80009d26:	30 08       	mov	r8,0
80009d28:	8f 28       	st.w	r7[0x8],r8
80009d2a:	6e 58       	ld.w	r8,r7[0x14]
80009d2c:	5c 38       	neg	r8
80009d2e:	8f 68       	st.w	r7[0x18],r8
80009d30:	c0 68       	rjmp	80009d3c <__swsetup_r+0xc8>
80009d32:	ed b9 00 01 	bld	r9,0x1
80009d36:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009d3a:	8f 28       	st.w	r7[0x8],r8
80009d3c:	6e 48       	ld.w	r8,r7[0x10]
80009d3e:	58 08       	cp.w	r8,0
80009d40:	c0 61       	brne	80009d4c <__swsetup_r+0xd8>
80009d42:	8e 68       	ld.sh	r8,r7[0xc]
80009d44:	ed b8 00 07 	bld	r8,0x7
80009d48:	c0 21       	brne	80009d4c <__swsetup_r+0xd8>
80009d4a:	dc 2a       	popm	r4-r7,pc,r12=-1
80009d4c:	d8 2a       	popm	r4-r7,pc,r12=0
80009d4e:	d7 03       	nop

80009d50 <quorem>:
80009d50:	d4 31       	pushm	r0-r7,lr
80009d52:	20 2d       	sub	sp,8
80009d54:	18 97       	mov	r7,r12
80009d56:	78 48       	ld.w	r8,r12[0x10]
80009d58:	76 46       	ld.w	r6,r11[0x10]
80009d5a:	0c 38       	cp.w	r8,r6
80009d5c:	c0 34       	brge	80009d62 <quorem+0x12>
80009d5e:	30 0c       	mov	r12,0
80009d60:	c8 58       	rjmp	80009e6a <quorem+0x11a>
80009d62:	ec c2 ff fc 	sub	r2,r6,-4
80009d66:	f6 c3 ff ec 	sub	r3,r11,-20
80009d6a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009d6e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009d72:	2f f9       	sub	r9,-1
80009d74:	20 16       	sub	r6,1
80009d76:	f8 09 0d 08 	divu	r8,r12,r9
80009d7a:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009d7e:	ee c4 ff ec 	sub	r4,r7,-20
80009d82:	10 95       	mov	r5,r8
80009d84:	58 08       	cp.w	r8,0
80009d86:	c4 10       	breq	80009e08 <quorem+0xb8>
80009d88:	30 09       	mov	r9,0
80009d8a:	06 9a       	mov	r10,r3
80009d8c:	08 98       	mov	r8,r4
80009d8e:	12 91       	mov	r1,r9
80009d90:	50 0b       	stdsp	sp[0x0],r11
80009d92:	70 0e       	ld.w	lr,r8[0x0]
80009d94:	b1 8e       	lsr	lr,0x10
80009d96:	50 1e       	stdsp	sp[0x4],lr
80009d98:	15 0e       	ld.w	lr,r10++
80009d9a:	fc 00 16 10 	lsr	r0,lr,0x10
80009d9e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009da2:	ea 0e 03 41 	mac	r1,r5,lr
80009da6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009daa:	b1 81       	lsr	r1,0x10
80009dac:	40 1b       	lddsp	r11,sp[0x4]
80009dae:	ea 00 02 40 	mul	r0,r5,r0
80009db2:	e2 00 00 00 	add	r0,r1,r0
80009db6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009dba:	02 1b       	sub	r11,r1
80009dbc:	50 1b       	stdsp	sp[0x4],r11
80009dbe:	70 0b       	ld.w	r11,r8[0x0]
80009dc0:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009dc4:	02 09       	add	r9,r1
80009dc6:	f2 0e 01 0e 	sub	lr,r9,lr
80009dca:	b0 1e       	st.h	r8[0x2],lr
80009dcc:	fc 09 14 10 	asr	r9,lr,0x10
80009dd0:	40 1e       	lddsp	lr,sp[0x4]
80009dd2:	fc 09 00 09 	add	r9,lr,r9
80009dd6:	b0 09       	st.h	r8[0x0],r9
80009dd8:	e0 01 16 10 	lsr	r1,r0,0x10
80009ddc:	2f c8       	sub	r8,-4
80009dde:	b1 49       	asr	r9,0x10
80009de0:	04 3a       	cp.w	r10,r2
80009de2:	fe 98 ff d8 	brls	80009d92 <quorem+0x42>
80009de6:	40 0b       	lddsp	r11,sp[0x0]
80009de8:	58 0c       	cp.w	r12,0
80009dea:	c0 f1       	brne	80009e08 <quorem+0xb8>
80009dec:	ec c8 ff fb 	sub	r8,r6,-5
80009df0:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009df4:	c0 28       	rjmp	80009df8 <quorem+0xa8>
80009df6:	20 16       	sub	r6,1
80009df8:	20 48       	sub	r8,4
80009dfa:	08 38       	cp.w	r8,r4
80009dfc:	e0 88 00 05 	brls	80009e06 <quorem+0xb6>
80009e00:	70 09       	ld.w	r9,r8[0x0]
80009e02:	58 09       	cp.w	r9,0
80009e04:	cf 90       	breq	80009df6 <quorem+0xa6>
80009e06:	8f 46       	st.w	r7[0x10],r6
80009e08:	0e 9c       	mov	r12,r7
80009e0a:	e0 a0 0a d2 	rcall	8000b3ae <__mcmp>
80009e0e:	c2 d5       	brlt	80009e68 <quorem+0x118>
80009e10:	2f f5       	sub	r5,-1
80009e12:	08 98       	mov	r8,r4
80009e14:	30 09       	mov	r9,0
80009e16:	07 0b       	ld.w	r11,r3++
80009e18:	f6 0a 16 10 	lsr	r10,r11,0x10
80009e1c:	70 0c       	ld.w	r12,r8[0x0]
80009e1e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009e22:	f8 0e 16 10 	lsr	lr,r12,0x10
80009e26:	14 1e       	sub	lr,r10
80009e28:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009e2c:	16 1a       	sub	r10,r11
80009e2e:	12 0a       	add	r10,r9
80009e30:	b0 1a       	st.h	r8[0x2],r10
80009e32:	b1 4a       	asr	r10,0x10
80009e34:	fc 0a 00 09 	add	r9,lr,r10
80009e38:	b0 09       	st.h	r8[0x0],r9
80009e3a:	2f c8       	sub	r8,-4
80009e3c:	b1 49       	asr	r9,0x10
80009e3e:	04 33       	cp.w	r3,r2
80009e40:	fe 98 ff eb 	brls	80009e16 <quorem+0xc6>
80009e44:	ec c8 ff fb 	sub	r8,r6,-5
80009e48:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009e4c:	58 09       	cp.w	r9,0
80009e4e:	c0 d1       	brne	80009e68 <quorem+0x118>
80009e50:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009e54:	c0 28       	rjmp	80009e58 <quorem+0x108>
80009e56:	20 16       	sub	r6,1
80009e58:	20 48       	sub	r8,4
80009e5a:	08 38       	cp.w	r8,r4
80009e5c:	e0 88 00 05 	brls	80009e66 <quorem+0x116>
80009e60:	70 09       	ld.w	r9,r8[0x0]
80009e62:	58 09       	cp.w	r9,0
80009e64:	cf 90       	breq	80009e56 <quorem+0x106>
80009e66:	8f 46       	st.w	r7[0x10],r6
80009e68:	0a 9c       	mov	r12,r5
80009e6a:	2f ed       	sub	sp,-8
80009e6c:	d8 32       	popm	r0-r7,pc
80009e6e:	d7 03       	nop

80009e70 <_dtoa_r>:
80009e70:	d4 31       	pushm	r0-r7,lr
80009e72:	21 ad       	sub	sp,104
80009e74:	fa c4 ff 74 	sub	r4,sp,-140
80009e78:	18 97       	mov	r7,r12
80009e7a:	16 95       	mov	r5,r11
80009e7c:	68 2c       	ld.w	r12,r4[0x8]
80009e7e:	50 c9       	stdsp	sp[0x30],r9
80009e80:	68 16       	ld.w	r6,r4[0x4]
80009e82:	68 09       	ld.w	r9,r4[0x0]
80009e84:	50 e8       	stdsp	sp[0x38],r8
80009e86:	14 94       	mov	r4,r10
80009e88:	51 2c       	stdsp	sp[0x48],r12
80009e8a:	fa e5 00 08 	st.d	sp[8],r4
80009e8e:	51 59       	stdsp	sp[0x54],r9
80009e90:	6e 95       	ld.w	r5,r7[0x24]
80009e92:	58 05       	cp.w	r5,0
80009e94:	c0 91       	brne	80009ea6 <_dtoa_r+0x36>
80009e96:	31 0c       	mov	r12,16
80009e98:	fe b0 e8 e2 	rcall	8000705c <malloc>
80009e9c:	99 35       	st.w	r12[0xc],r5
80009e9e:	8f 9c       	st.w	r7[0x24],r12
80009ea0:	99 15       	st.w	r12[0x4],r5
80009ea2:	99 25       	st.w	r12[0x8],r5
80009ea4:	99 05       	st.w	r12[0x0],r5
80009ea6:	6e 99       	ld.w	r9,r7[0x24]
80009ea8:	72 08       	ld.w	r8,r9[0x0]
80009eaa:	58 08       	cp.w	r8,0
80009eac:	c0 f0       	breq	80009eca <_dtoa_r+0x5a>
80009eae:	72 1a       	ld.w	r10,r9[0x4]
80009eb0:	91 1a       	st.w	r8[0x4],r10
80009eb2:	30 1a       	mov	r10,1
80009eb4:	72 19       	ld.w	r9,r9[0x4]
80009eb6:	f4 09 09 49 	lsl	r9,r10,r9
80009eba:	10 9b       	mov	r11,r8
80009ebc:	91 29       	st.w	r8[0x8],r9
80009ebe:	0e 9c       	mov	r12,r7
80009ec0:	e0 a0 0a 90 	rcall	8000b3e0 <_Bfree>
80009ec4:	6e 98       	ld.w	r8,r7[0x24]
80009ec6:	30 09       	mov	r9,0
80009ec8:	91 09       	st.w	r8[0x0],r9
80009eca:	40 28       	lddsp	r8,sp[0x8]
80009ecc:	10 94       	mov	r4,r8
80009ece:	58 08       	cp.w	r8,0
80009ed0:	c0 64       	brge	80009edc <_dtoa_r+0x6c>
80009ed2:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009ed6:	50 28       	stdsp	sp[0x8],r8
80009ed8:	30 18       	mov	r8,1
80009eda:	c0 28       	rjmp	80009ede <_dtoa_r+0x6e>
80009edc:	30 08       	mov	r8,0
80009ede:	8d 08       	st.w	r6[0x0],r8
80009ee0:	fc 1c 7f f0 	movh	r12,0x7ff0
80009ee4:	40 26       	lddsp	r6,sp[0x8]
80009ee6:	0c 98       	mov	r8,r6
80009ee8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009eec:	18 38       	cp.w	r8,r12
80009eee:	c2 01       	brne	80009f2e <_dtoa_r+0xbe>
80009ef0:	e0 68 27 0f 	mov	r8,9999
80009ef4:	41 5b       	lddsp	r11,sp[0x54]
80009ef6:	97 08       	st.w	r11[0x0],r8
80009ef8:	40 3a       	lddsp	r10,sp[0xc]
80009efa:	58 0a       	cp.w	r10,0
80009efc:	c0 71       	brne	80009f0a <_dtoa_r+0x9a>
80009efe:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009f02:	c0 41       	brne	80009f0a <_dtoa_r+0x9a>
80009f04:	fe cc bd 10 	sub	r12,pc,-17136
80009f08:	c0 38       	rjmp	80009f0e <_dtoa_r+0x9e>
80009f0a:	fe cc bd 0a 	sub	r12,pc,-17142
80009f0e:	41 29       	lddsp	r9,sp[0x48]
80009f10:	58 09       	cp.w	r9,0
80009f12:	e0 80 05 9a 	breq	8000aa46 <_dtoa_r+0xbd6>
80009f16:	f8 c8 ff fd 	sub	r8,r12,-3
80009f1a:	f8 c9 ff f8 	sub	r9,r12,-8
80009f1e:	11 8b       	ld.ub	r11,r8[0x0]
80009f20:	30 0a       	mov	r10,0
80009f22:	41 25       	lddsp	r5,sp[0x48]
80009f24:	f4 0b 18 00 	cp.b	r11,r10
80009f28:	f2 08 17 10 	movne	r8,r9
80009f2c:	c1 68       	rjmp	80009f58 <_dtoa_r+0xe8>
80009f2e:	fa ea 00 08 	ld.d	r10,sp[8]
80009f32:	30 08       	mov	r8,0
80009f34:	fa eb 00 3c 	st.d	sp[60],r10
80009f38:	30 09       	mov	r9,0
80009f3a:	e0 a0 10 ce 	rcall	8000c0d6 <__avr32_f64_cmp_eq>
80009f3e:	c1 00       	breq	80009f5e <_dtoa_r+0xee>
80009f40:	30 18       	mov	r8,1
80009f42:	41 5a       	lddsp	r10,sp[0x54]
80009f44:	95 08       	st.w	r10[0x0],r8
80009f46:	fe cc be 76 	sub	r12,pc,-16778
80009f4a:	41 29       	lddsp	r9,sp[0x48]
80009f4c:	f8 08 00 08 	add	r8,r12,r8
80009f50:	58 09       	cp.w	r9,0
80009f52:	e0 80 05 7a 	breq	8000aa46 <_dtoa_r+0xbd6>
80009f56:	12 95       	mov	r5,r9
80009f58:	8b 08       	st.w	r5[0x0],r8
80009f5a:	e0 8f 05 76 	bral	8000aa46 <_dtoa_r+0xbd6>
80009f5e:	fa c8 ff 9c 	sub	r8,sp,-100
80009f62:	fa c9 ff a0 	sub	r9,sp,-96
80009f66:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f6a:	0e 9c       	mov	r12,r7
80009f6c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009f70:	e0 a0 0a 8a 	rcall	8000b484 <__d2b>
80009f74:	18 93       	mov	r3,r12
80009f76:	58 05       	cp.w	r5,0
80009f78:	c0 d0       	breq	80009f92 <_dtoa_r+0x122>
80009f7a:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f7e:	30 04       	mov	r4,0
80009f80:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009f84:	ea c5 03 ff 	sub	r5,r5,1023
80009f88:	10 9b       	mov	r11,r8
80009f8a:	51 74       	stdsp	sp[0x5c],r4
80009f8c:	ea 1b 3f f0 	orh	r11,0x3ff0
80009f90:	c2 58       	rjmp	80009fda <_dtoa_r+0x16a>
80009f92:	41 88       	lddsp	r8,sp[0x60]
80009f94:	41 9c       	lddsp	r12,sp[0x64]
80009f96:	10 0c       	add	r12,r8
80009f98:	f8 c5 fb ce 	sub	r5,r12,-1074
80009f9c:	e0 45 00 20 	cp.w	r5,32
80009fa0:	e0 8a 00 0e 	brle	80009fbc <_dtoa_r+0x14c>
80009fa4:	f8 cc fb ee 	sub	r12,r12,-1042
80009fa8:	40 3b       	lddsp	r11,sp[0xc]
80009faa:	ea 08 11 40 	rsub	r8,r5,64
80009fae:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009fb2:	ec 08 09 46 	lsl	r6,r6,r8
80009fb6:	0c 4c       	or	r12,r6
80009fb8:	c0 78       	rjmp	80009fc6 <_dtoa_r+0x156>
80009fba:	d7 03       	nop
80009fbc:	ea 0c 11 20 	rsub	r12,r5,32
80009fc0:	40 3a       	lddsp	r10,sp[0xc]
80009fc2:	f4 0c 09 4c 	lsl	r12,r10,r12
80009fc6:	e0 a0 10 14 	rcall	8000bfee <__avr32_u32_to_f64>
80009fca:	fc 18 fe 10 	movh	r8,0xfe10
80009fce:	30 19       	mov	r9,1
80009fd0:	ea c5 04 33 	sub	r5,r5,1075
80009fd4:	f0 0b 00 0b 	add	r11,r8,r11
80009fd8:	51 79       	stdsp	sp[0x5c],r9
80009fda:	30 08       	mov	r8,0
80009fdc:	fc 19 3f f8 	movh	r9,0x3ff8
80009fe0:	e0 a0 0e 9c 	rcall	8000bd18 <__avr32_f64_sub>
80009fe4:	e0 68 43 61 	mov	r8,17249
80009fe8:	ea 18 63 6f 	orh	r8,0x636f
80009fec:	e0 69 87 a7 	mov	r9,34727
80009ff0:	ea 19 3f d2 	orh	r9,0x3fd2
80009ff4:	e0 a0 0d a6 	rcall	8000bb40 <__avr32_f64_mul>
80009ff8:	e0 68 c8 b3 	mov	r8,51379
80009ffc:	ea 18 8b 60 	orh	r8,0x8b60
8000a000:	e0 69 8a 28 	mov	r9,35368
8000a004:	ea 19 3f c6 	orh	r9,0x3fc6
8000a008:	e0 a0 0f 56 	rcall	8000beb4 <__avr32_f64_add>
8000a00c:	0a 9c       	mov	r12,r5
8000a00e:	14 90       	mov	r0,r10
8000a010:	16 91       	mov	r1,r11
8000a012:	e0 a0 0f f2 	rcall	8000bff6 <__avr32_s32_to_f64>
8000a016:	e0 68 79 fb 	mov	r8,31227
8000a01a:	ea 18 50 9f 	orh	r8,0x509f
8000a01e:	e0 69 44 13 	mov	r9,17427
8000a022:	ea 19 3f d3 	orh	r9,0x3fd3
8000a026:	e0 a0 0d 8d 	rcall	8000bb40 <__avr32_f64_mul>
8000a02a:	14 98       	mov	r8,r10
8000a02c:	16 99       	mov	r9,r11
8000a02e:	00 9a       	mov	r10,r0
8000a030:	02 9b       	mov	r11,r1
8000a032:	e0 a0 0f 41 	rcall	8000beb4 <__avr32_f64_add>
8000a036:	14 90       	mov	r0,r10
8000a038:	16 91       	mov	r1,r11
8000a03a:	e0 a0 0f c7 	rcall	8000bfc8 <__avr32_f64_to_s32>
8000a03e:	30 08       	mov	r8,0
8000a040:	18 96       	mov	r6,r12
8000a042:	30 09       	mov	r9,0
8000a044:	00 9a       	mov	r10,r0
8000a046:	02 9b       	mov	r11,r1
8000a048:	e0 a0 10 8e 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a04c:	c0 c0       	breq	8000a064 <_dtoa_r+0x1f4>
8000a04e:	0c 9c       	mov	r12,r6
8000a050:	e0 a0 0f d3 	rcall	8000bff6 <__avr32_s32_to_f64>
8000a054:	14 98       	mov	r8,r10
8000a056:	16 99       	mov	r9,r11
8000a058:	00 9a       	mov	r10,r0
8000a05a:	02 9b       	mov	r11,r1
8000a05c:	e0 a0 10 3d 	rcall	8000c0d6 <__avr32_f64_cmp_eq>
8000a060:	f7 b6 00 01 	subeq	r6,1
8000a064:	59 66       	cp.w	r6,22
8000a066:	e0 88 00 05 	brls	8000a070 <_dtoa_r+0x200>
8000a06a:	30 18       	mov	r8,1
8000a06c:	51 48       	stdsp	sp[0x50],r8
8000a06e:	c1 38       	rjmp	8000a094 <_dtoa_r+0x224>
8000a070:	fe c8 bd bc 	sub	r8,pc,-16964
8000a074:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a078:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a07c:	e0 a0 10 74 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a080:	f9 b4 00 00 	moveq	r4,0
8000a084:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a088:	f7 b6 01 01 	subne	r6,1
8000a08c:	f9 bc 01 00 	movne	r12,0
8000a090:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a094:	41 90       	lddsp	r0,sp[0x64]
8000a096:	20 10       	sub	r0,1
8000a098:	0a 10       	sub	r0,r5
8000a09a:	c0 46       	brmi	8000a0a2 <_dtoa_r+0x232>
8000a09c:	50 40       	stdsp	sp[0x10],r0
8000a09e:	30 00       	mov	r0,0
8000a0a0:	c0 48       	rjmp	8000a0a8 <_dtoa_r+0x238>
8000a0a2:	30 0b       	mov	r11,0
8000a0a4:	5c 30       	neg	r0
8000a0a6:	50 4b       	stdsp	sp[0x10],r11
8000a0a8:	ec 02 11 00 	rsub	r2,r6,0
8000a0ac:	58 06       	cp.w	r6,0
8000a0ae:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a0b2:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a0b6:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a0ba:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a0be:	f9 b2 04 00 	movge	r2,0
8000a0c2:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a0c6:	f9 b9 05 00 	movlt	r9,0
8000a0ca:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a0ce:	40 c8       	lddsp	r8,sp[0x30]
8000a0d0:	58 98       	cp.w	r8,9
8000a0d2:	e0 8b 00 20 	brhi	8000a112 <_dtoa_r+0x2a2>
8000a0d6:	58 58       	cp.w	r8,5
8000a0d8:	f9 b4 0a 01 	movle	r4,1
8000a0dc:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a0e0:	f7 b5 09 04 	subgt	r5,4
8000a0e4:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a0e8:	f9 b4 09 00 	movgt	r4,0
8000a0ec:	40 cc       	lddsp	r12,sp[0x30]
8000a0ee:	58 3c       	cp.w	r12,3
8000a0f0:	c2 d0       	breq	8000a14a <_dtoa_r+0x2da>
8000a0f2:	e0 89 00 05 	brgt	8000a0fc <_dtoa_r+0x28c>
8000a0f6:	58 2c       	cp.w	r12,2
8000a0f8:	c1 01       	brne	8000a118 <_dtoa_r+0x2a8>
8000a0fa:	c1 88       	rjmp	8000a12a <_dtoa_r+0x2ba>
8000a0fc:	40 cb       	lddsp	r11,sp[0x30]
8000a0fe:	58 4b       	cp.w	r11,4
8000a100:	c0 60       	breq	8000a10c <_dtoa_r+0x29c>
8000a102:	58 5b       	cp.w	r11,5
8000a104:	c0 a1       	brne	8000a118 <_dtoa_r+0x2a8>
8000a106:	30 1a       	mov	r10,1
8000a108:	50 da       	stdsp	sp[0x34],r10
8000a10a:	c2 28       	rjmp	8000a14e <_dtoa_r+0x2de>
8000a10c:	30 19       	mov	r9,1
8000a10e:	50 d9       	stdsp	sp[0x34],r9
8000a110:	c0 f8       	rjmp	8000a12e <_dtoa_r+0x2be>
8000a112:	30 08       	mov	r8,0
8000a114:	30 14       	mov	r4,1
8000a116:	50 c8       	stdsp	sp[0x30],r8
8000a118:	3f f5       	mov	r5,-1
8000a11a:	30 1c       	mov	r12,1
8000a11c:	30 0b       	mov	r11,0
8000a11e:	50 95       	stdsp	sp[0x24],r5
8000a120:	50 dc       	stdsp	sp[0x34],r12
8000a122:	0a 91       	mov	r1,r5
8000a124:	31 28       	mov	r8,18
8000a126:	50 eb       	stdsp	sp[0x38],r11
8000a128:	c2 08       	rjmp	8000a168 <_dtoa_r+0x2f8>
8000a12a:	30 0a       	mov	r10,0
8000a12c:	50 da       	stdsp	sp[0x34],r10
8000a12e:	40 e9       	lddsp	r9,sp[0x38]
8000a130:	58 09       	cp.w	r9,0
8000a132:	e0 89 00 07 	brgt	8000a140 <_dtoa_r+0x2d0>
8000a136:	30 18       	mov	r8,1
8000a138:	50 98       	stdsp	sp[0x24],r8
8000a13a:	10 91       	mov	r1,r8
8000a13c:	50 e8       	stdsp	sp[0x38],r8
8000a13e:	c1 58       	rjmp	8000a168 <_dtoa_r+0x2f8>
8000a140:	40 e5       	lddsp	r5,sp[0x38]
8000a142:	50 95       	stdsp	sp[0x24],r5
8000a144:	0a 91       	mov	r1,r5
8000a146:	0a 98       	mov	r8,r5
8000a148:	c1 08       	rjmp	8000a168 <_dtoa_r+0x2f8>
8000a14a:	30 0c       	mov	r12,0
8000a14c:	50 dc       	stdsp	sp[0x34],r12
8000a14e:	40 eb       	lddsp	r11,sp[0x38]
8000a150:	ec 0b 00 0b 	add	r11,r6,r11
8000a154:	50 9b       	stdsp	sp[0x24],r11
8000a156:	16 98       	mov	r8,r11
8000a158:	2f f8       	sub	r8,-1
8000a15a:	58 08       	cp.w	r8,0
8000a15c:	e0 89 00 05 	brgt	8000a166 <_dtoa_r+0x2f6>
8000a160:	10 91       	mov	r1,r8
8000a162:	30 18       	mov	r8,1
8000a164:	c0 28       	rjmp	8000a168 <_dtoa_r+0x2f8>
8000a166:	10 91       	mov	r1,r8
8000a168:	30 09       	mov	r9,0
8000a16a:	6e 9a       	ld.w	r10,r7[0x24]
8000a16c:	95 19       	st.w	r10[0x4],r9
8000a16e:	30 49       	mov	r9,4
8000a170:	c0 68       	rjmp	8000a17c <_dtoa_r+0x30c>
8000a172:	d7 03       	nop
8000a174:	6a 1a       	ld.w	r10,r5[0x4]
8000a176:	a1 79       	lsl	r9,0x1
8000a178:	2f fa       	sub	r10,-1
8000a17a:	8b 1a       	st.w	r5[0x4],r10
8000a17c:	6e 95       	ld.w	r5,r7[0x24]
8000a17e:	f2 ca ff ec 	sub	r10,r9,-20
8000a182:	10 3a       	cp.w	r10,r8
8000a184:	fe 98 ff f8 	brls	8000a174 <_dtoa_r+0x304>
8000a188:	6a 1b       	ld.w	r11,r5[0x4]
8000a18a:	0e 9c       	mov	r12,r7
8000a18c:	e0 a0 09 44 	rcall	8000b414 <_Balloc>
8000a190:	58 e1       	cp.w	r1,14
8000a192:	5f 88       	srls	r8
8000a194:	8b 0c       	st.w	r5[0x0],r12
8000a196:	f1 e4 00 04 	and	r4,r8,r4
8000a19a:	6e 98       	ld.w	r8,r7[0x24]
8000a19c:	70 08       	ld.w	r8,r8[0x0]
8000a19e:	50 88       	stdsp	sp[0x20],r8
8000a1a0:	e0 80 01 82 	breq	8000a4a4 <_dtoa_r+0x634>
8000a1a4:	58 06       	cp.w	r6,0
8000a1a6:	e0 8a 00 43 	brle	8000a22c <_dtoa_r+0x3bc>
8000a1aa:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a1ae:	fe c8 be fa 	sub	r8,pc,-16646
8000a1b2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a1b6:	fa e5 00 18 	st.d	sp[24],r4
8000a1ba:	ec 04 14 04 	asr	r4,r6,0x4
8000a1be:	ed b4 00 04 	bld	r4,0x4
8000a1c2:	c0 30       	breq	8000a1c8 <_dtoa_r+0x358>
8000a1c4:	30 25       	mov	r5,2
8000a1c6:	c1 08       	rjmp	8000a1e6 <_dtoa_r+0x376>
8000a1c8:	fe c8 be 4c 	sub	r8,pc,-16820
8000a1cc:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a1d0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1d4:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a1d8:	e0 a0 0f fa 	rcall	8000c1cc <__avr32_f64_div>
8000a1dc:	30 35       	mov	r5,3
8000a1de:	14 98       	mov	r8,r10
8000a1e0:	16 99       	mov	r9,r11
8000a1e2:	fa e9 00 08 	st.d	sp[8],r8
8000a1e6:	fe cc be 6a 	sub	r12,pc,-16790
8000a1ea:	50 a3       	stdsp	sp[0x28],r3
8000a1ec:	0c 93       	mov	r3,r6
8000a1ee:	18 96       	mov	r6,r12
8000a1f0:	c0 f8       	rjmp	8000a20e <_dtoa_r+0x39e>
8000a1f2:	fa ea 00 18 	ld.d	r10,sp[24]
8000a1f6:	ed b4 00 00 	bld	r4,0x0
8000a1fa:	c0 81       	brne	8000a20a <_dtoa_r+0x39a>
8000a1fc:	ec e8 00 00 	ld.d	r8,r6[0]
8000a200:	2f f5       	sub	r5,-1
8000a202:	e0 a0 0c 9f 	rcall	8000bb40 <__avr32_f64_mul>
8000a206:	fa eb 00 18 	st.d	sp[24],r10
8000a20a:	a1 54       	asr	r4,0x1
8000a20c:	2f 86       	sub	r6,-8
8000a20e:	58 04       	cp.w	r4,0
8000a210:	cf 11       	brne	8000a1f2 <_dtoa_r+0x382>
8000a212:	fa e8 00 18 	ld.d	r8,sp[24]
8000a216:	fa ea 00 08 	ld.d	r10,sp[8]
8000a21a:	06 96       	mov	r6,r3
8000a21c:	e0 a0 0f d8 	rcall	8000c1cc <__avr32_f64_div>
8000a220:	40 a3       	lddsp	r3,sp[0x28]
8000a222:	14 98       	mov	r8,r10
8000a224:	16 99       	mov	r9,r11
8000a226:	fa e9 00 08 	st.d	sp[8],r8
8000a22a:	c2 f8       	rjmp	8000a288 <_dtoa_r+0x418>
8000a22c:	ec 08 11 00 	rsub	r8,r6,0
8000a230:	c0 31       	brne	8000a236 <_dtoa_r+0x3c6>
8000a232:	30 25       	mov	r5,2
8000a234:	c2 a8       	rjmp	8000a288 <_dtoa_r+0x418>
8000a236:	fe cc be ba 	sub	r12,pc,-16710
8000a23a:	f0 04 14 04 	asr	r4,r8,0x4
8000a23e:	50 1c       	stdsp	sp[0x4],r12
8000a240:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a244:	fe c9 bf 90 	sub	r9,pc,-16496
8000a248:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a24c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a250:	e0 a0 0c 78 	rcall	8000bb40 <__avr32_f64_mul>
8000a254:	40 1c       	lddsp	r12,sp[0x4]
8000a256:	50 63       	stdsp	sp[0x18],r3
8000a258:	30 25       	mov	r5,2
8000a25a:	0c 93       	mov	r3,r6
8000a25c:	fa eb 00 08 	st.d	sp[8],r10
8000a260:	18 96       	mov	r6,r12
8000a262:	c0 f8       	rjmp	8000a280 <_dtoa_r+0x410>
8000a264:	fa ea 00 08 	ld.d	r10,sp[8]
8000a268:	ed b4 00 00 	bld	r4,0x0
8000a26c:	c0 81       	brne	8000a27c <_dtoa_r+0x40c>
8000a26e:	ec e8 00 00 	ld.d	r8,r6[0]
8000a272:	2f f5       	sub	r5,-1
8000a274:	e0 a0 0c 66 	rcall	8000bb40 <__avr32_f64_mul>
8000a278:	fa eb 00 08 	st.d	sp[8],r10
8000a27c:	a1 54       	asr	r4,0x1
8000a27e:	2f 86       	sub	r6,-8
8000a280:	58 04       	cp.w	r4,0
8000a282:	cf 11       	brne	8000a264 <_dtoa_r+0x3f4>
8000a284:	06 96       	mov	r6,r3
8000a286:	40 63       	lddsp	r3,sp[0x18]
8000a288:	41 4a       	lddsp	r10,sp[0x50]
8000a28a:	58 0a       	cp.w	r10,0
8000a28c:	c2 a0       	breq	8000a2e0 <_dtoa_r+0x470>
8000a28e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a292:	58 01       	cp.w	r1,0
8000a294:	5f 94       	srgt	r4
8000a296:	fa e9 00 18 	st.d	sp[24],r8
8000a29a:	30 08       	mov	r8,0
8000a29c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a2a0:	fa ea 00 18 	ld.d	r10,sp[24]
8000a2a4:	e0 a0 0f 60 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a2a8:	f9 bc 00 00 	moveq	r12,0
8000a2ac:	f9 bc 01 01 	movne	r12,1
8000a2b0:	e9 ec 00 0c 	and	r12,r4,r12
8000a2b4:	c1 60       	breq	8000a2e0 <_dtoa_r+0x470>
8000a2b6:	40 98       	lddsp	r8,sp[0x24]
8000a2b8:	58 08       	cp.w	r8,0
8000a2ba:	e0 8a 00 f1 	brle	8000a49c <_dtoa_r+0x62c>
8000a2be:	30 08       	mov	r8,0
8000a2c0:	fc 19 40 24 	movh	r9,0x4024
8000a2c4:	ec c4 00 01 	sub	r4,r6,1
8000a2c8:	fa ea 00 18 	ld.d	r10,sp[24]
8000a2cc:	2f f5       	sub	r5,-1
8000a2ce:	50 64       	stdsp	sp[0x18],r4
8000a2d0:	e0 a0 0c 38 	rcall	8000bb40 <__avr32_f64_mul>
8000a2d4:	40 94       	lddsp	r4,sp[0x24]
8000a2d6:	14 98       	mov	r8,r10
8000a2d8:	16 99       	mov	r9,r11
8000a2da:	fa e9 00 08 	st.d	sp[8],r8
8000a2de:	c0 38       	rjmp	8000a2e4 <_dtoa_r+0x474>
8000a2e0:	50 66       	stdsp	sp[0x18],r6
8000a2e2:	02 94       	mov	r4,r1
8000a2e4:	0a 9c       	mov	r12,r5
8000a2e6:	e0 a0 0e 88 	rcall	8000bff6 <__avr32_s32_to_f64>
8000a2ea:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2ee:	e0 a0 0c 29 	rcall	8000bb40 <__avr32_f64_mul>
8000a2f2:	30 08       	mov	r8,0
8000a2f4:	fc 19 40 1c 	movh	r9,0x401c
8000a2f8:	e0 a0 0d de 	rcall	8000beb4 <__avr32_f64_add>
8000a2fc:	14 98       	mov	r8,r10
8000a2fe:	16 99       	mov	r9,r11
8000a300:	fa e9 00 28 	st.d	sp[40],r8
8000a304:	fc 18 fc c0 	movh	r8,0xfcc0
8000a308:	40 a5       	lddsp	r5,sp[0x28]
8000a30a:	10 05       	add	r5,r8
8000a30c:	50 a5       	stdsp	sp[0x28],r5
8000a30e:	58 04       	cp.w	r4,0
8000a310:	c2 11       	brne	8000a352 <_dtoa_r+0x4e2>
8000a312:	fa ea 00 08 	ld.d	r10,sp[8]
8000a316:	30 08       	mov	r8,0
8000a318:	fc 19 40 14 	movh	r9,0x4014
8000a31c:	e0 a0 0c fe 	rcall	8000bd18 <__avr32_f64_sub>
8000a320:	40 bc       	lddsp	r12,sp[0x2c]
8000a322:	fa eb 00 08 	st.d	sp[8],r10
8000a326:	14 98       	mov	r8,r10
8000a328:	16 99       	mov	r9,r11
8000a32a:	18 9a       	mov	r10,r12
8000a32c:	0a 9b       	mov	r11,r5
8000a32e:	e0 a0 0f 1b 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a332:	e0 81 02 54 	brne	8000a7da <_dtoa_r+0x96a>
8000a336:	0a 98       	mov	r8,r5
8000a338:	40 b9       	lddsp	r9,sp[0x2c]
8000a33a:	ee 18 80 00 	eorh	r8,0x8000
8000a33e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a342:	10 95       	mov	r5,r8
8000a344:	12 98       	mov	r8,r9
8000a346:	0a 99       	mov	r9,r5
8000a348:	e0 a0 0f 0e 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a34c:	e0 81 02 3e 	brne	8000a7c8 <_dtoa_r+0x958>
8000a350:	ca 68       	rjmp	8000a49c <_dtoa_r+0x62c>
8000a352:	fe c9 c0 9e 	sub	r9,pc,-16226
8000a356:	e8 c8 00 01 	sub	r8,r4,1
8000a35a:	40 d5       	lddsp	r5,sp[0x34]
8000a35c:	58 05       	cp.w	r5,0
8000a35e:	c4 f0       	breq	8000a3fc <_dtoa_r+0x58c>
8000a360:	30 0c       	mov	r12,0
8000a362:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a366:	51 3c       	stdsp	sp[0x4c],r12
8000a368:	30 0a       	mov	r10,0
8000a36a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a36e:	e0 a0 0f 2f 	rcall	8000c1cc <__avr32_f64_div>
8000a372:	fa e8 00 28 	ld.d	r8,sp[40]
8000a376:	40 85       	lddsp	r5,sp[0x20]
8000a378:	e0 a0 0c d0 	rcall	8000bd18 <__avr32_f64_sub>
8000a37c:	fa eb 00 28 	st.d	sp[40],r10
8000a380:	fa ea 00 08 	ld.d	r10,sp[8]
8000a384:	e0 a0 0e 22 	rcall	8000bfc8 <__avr32_f64_to_s32>
8000a388:	51 6c       	stdsp	sp[0x58],r12
8000a38a:	e0 a0 0e 36 	rcall	8000bff6 <__avr32_s32_to_f64>
8000a38e:	14 98       	mov	r8,r10
8000a390:	16 99       	mov	r9,r11
8000a392:	fa ea 00 08 	ld.d	r10,sp[8]
8000a396:	e0 a0 0c c1 	rcall	8000bd18 <__avr32_f64_sub>
8000a39a:	fa eb 00 08 	st.d	sp[8],r10
8000a39e:	41 68       	lddsp	r8,sp[0x58]
8000a3a0:	2d 08       	sub	r8,-48
8000a3a2:	0a c8       	st.b	r5++,r8
8000a3a4:	41 39       	lddsp	r9,sp[0x4c]
8000a3a6:	2f f9       	sub	r9,-1
8000a3a8:	51 39       	stdsp	sp[0x4c],r9
8000a3aa:	fa e8 00 28 	ld.d	r8,sp[40]
8000a3ae:	e0 a0 0e db 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a3b2:	e0 81 03 39 	brne	8000aa24 <_dtoa_r+0xbb4>
8000a3b6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3ba:	30 0a       	mov	r10,0
8000a3bc:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a3c0:	e0 a0 0c ac 	rcall	8000bd18 <__avr32_f64_sub>
8000a3c4:	fa e8 00 28 	ld.d	r8,sp[40]
8000a3c8:	e0 a0 0e ce 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a3cc:	fa ea 00 28 	ld.d	r10,sp[40]
8000a3d0:	30 08       	mov	r8,0
8000a3d2:	fc 19 40 24 	movh	r9,0x4024
8000a3d6:	e0 81 00 da 	brne	8000a58a <_dtoa_r+0x71a>
8000a3da:	41 3c       	lddsp	r12,sp[0x4c]
8000a3dc:	08 3c       	cp.w	r12,r4
8000a3de:	c5 f4       	brge	8000a49c <_dtoa_r+0x62c>
8000a3e0:	e0 a0 0b b0 	rcall	8000bb40 <__avr32_f64_mul>
8000a3e4:	30 08       	mov	r8,0
8000a3e6:	fa eb 00 28 	st.d	sp[40],r10
8000a3ea:	fc 19 40 24 	movh	r9,0x4024
8000a3ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3f2:	e0 a0 0b a7 	rcall	8000bb40 <__avr32_f64_mul>
8000a3f6:	fa eb 00 08 	st.d	sp[8],r10
8000a3fa:	cc 3b       	rjmp	8000a380 <_dtoa_r+0x510>
8000a3fc:	40 85       	lddsp	r5,sp[0x20]
8000a3fe:	08 05       	add	r5,r4
8000a400:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a404:	51 35       	stdsp	sp[0x4c],r5
8000a406:	fa e8 00 28 	ld.d	r8,sp[40]
8000a40a:	40 85       	lddsp	r5,sp[0x20]
8000a40c:	e0 a0 0b 9a 	rcall	8000bb40 <__avr32_f64_mul>
8000a410:	fa eb 00 28 	st.d	sp[40],r10
8000a414:	fa ea 00 08 	ld.d	r10,sp[8]
8000a418:	e0 a0 0d d8 	rcall	8000bfc8 <__avr32_f64_to_s32>
8000a41c:	51 6c       	stdsp	sp[0x58],r12
8000a41e:	e0 a0 0d ec 	rcall	8000bff6 <__avr32_s32_to_f64>
8000a422:	14 98       	mov	r8,r10
8000a424:	16 99       	mov	r9,r11
8000a426:	fa ea 00 08 	ld.d	r10,sp[8]
8000a42a:	e0 a0 0c 77 	rcall	8000bd18 <__avr32_f64_sub>
8000a42e:	fa eb 00 08 	st.d	sp[8],r10
8000a432:	41 68       	lddsp	r8,sp[0x58]
8000a434:	2d 08       	sub	r8,-48
8000a436:	0a c8       	st.b	r5++,r8
8000a438:	41 3c       	lddsp	r12,sp[0x4c]
8000a43a:	18 35       	cp.w	r5,r12
8000a43c:	c2 81       	brne	8000a48c <_dtoa_r+0x61c>
8000a43e:	30 08       	mov	r8,0
8000a440:	fc 19 3f e0 	movh	r9,0x3fe0
8000a444:	fa ea 00 28 	ld.d	r10,sp[40]
8000a448:	e0 a0 0d 36 	rcall	8000beb4 <__avr32_f64_add>
8000a44c:	40 85       	lddsp	r5,sp[0x20]
8000a44e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a452:	08 05       	add	r5,r4
8000a454:	e0 a0 0e 88 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a458:	e0 81 00 99 	brne	8000a58a <_dtoa_r+0x71a>
8000a45c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a460:	30 0a       	mov	r10,0
8000a462:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a466:	e0 a0 0c 59 	rcall	8000bd18 <__avr32_f64_sub>
8000a46a:	14 98       	mov	r8,r10
8000a46c:	16 99       	mov	r9,r11
8000a46e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a472:	e0 a0 0e 79 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a476:	c1 30       	breq	8000a49c <_dtoa_r+0x62c>
8000a478:	33 09       	mov	r9,48
8000a47a:	0a 98       	mov	r8,r5
8000a47c:	11 7a       	ld.ub	r10,--r8
8000a47e:	f2 0a 18 00 	cp.b	r10,r9
8000a482:	e0 81 02 d1 	brne	8000aa24 <_dtoa_r+0xbb4>
8000a486:	10 95       	mov	r5,r8
8000a488:	cf 9b       	rjmp	8000a47a <_dtoa_r+0x60a>
8000a48a:	d7 03       	nop
8000a48c:	30 08       	mov	r8,0
8000a48e:	fc 19 40 24 	movh	r9,0x4024
8000a492:	e0 a0 0b 57 	rcall	8000bb40 <__avr32_f64_mul>
8000a496:	fa eb 00 08 	st.d	sp[8],r10
8000a49a:	cb db       	rjmp	8000a414 <_dtoa_r+0x5a4>
8000a49c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a4a0:	fa eb 00 08 	st.d	sp[8],r10
8000a4a4:	58 e6       	cp.w	r6,14
8000a4a6:	5f ab       	srle	r11
8000a4a8:	41 8a       	lddsp	r10,sp[0x60]
8000a4aa:	30 08       	mov	r8,0
8000a4ac:	f4 09 11 ff 	rsub	r9,r10,-1
8000a4b0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a4b4:	f0 09 18 00 	cp.b	r9,r8
8000a4b8:	e0 80 00 82 	breq	8000a5bc <_dtoa_r+0x74c>
8000a4bc:	40 ea       	lddsp	r10,sp[0x38]
8000a4be:	58 01       	cp.w	r1,0
8000a4c0:	5f a9       	srle	r9
8000a4c2:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a4c6:	fe ca c2 12 	sub	r10,pc,-15854
8000a4ca:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a4ce:	fa e5 00 10 	st.d	sp[16],r4
8000a4d2:	f0 09 18 00 	cp.b	r9,r8
8000a4d6:	c1 40       	breq	8000a4fe <_dtoa_r+0x68e>
8000a4d8:	58 01       	cp.w	r1,0
8000a4da:	e0 81 01 77 	brne	8000a7c8 <_dtoa_r+0x958>
8000a4de:	30 08       	mov	r8,0
8000a4e0:	fc 19 40 14 	movh	r9,0x4014
8000a4e4:	08 9a       	mov	r10,r4
8000a4e6:	0a 9b       	mov	r11,r5
8000a4e8:	e0 a0 0b 2c 	rcall	8000bb40 <__avr32_f64_mul>
8000a4ec:	fa e8 00 08 	ld.d	r8,sp[8]
8000a4f0:	e0 a0 0e 06 	rcall	8000c0fc <__avr32_f64_cmp_ge>
8000a4f4:	e0 81 01 6a 	brne	8000a7c8 <_dtoa_r+0x958>
8000a4f8:	02 92       	mov	r2,r1
8000a4fa:	e0 8f 01 72 	bral	8000a7de <_dtoa_r+0x96e>
8000a4fe:	40 85       	lddsp	r5,sp[0x20]
8000a500:	30 14       	mov	r4,1
8000a502:	fa e8 00 10 	ld.d	r8,sp[16]
8000a506:	fa ea 00 08 	ld.d	r10,sp[8]
8000a50a:	e0 a0 0e 61 	rcall	8000c1cc <__avr32_f64_div>
8000a50e:	e0 a0 0d 5d 	rcall	8000bfc8 <__avr32_f64_to_s32>
8000a512:	18 92       	mov	r2,r12
8000a514:	e0 a0 0d 71 	rcall	8000bff6 <__avr32_s32_to_f64>
8000a518:	fa e8 00 10 	ld.d	r8,sp[16]
8000a51c:	e0 a0 0b 12 	rcall	8000bb40 <__avr32_f64_mul>
8000a520:	14 98       	mov	r8,r10
8000a522:	16 99       	mov	r9,r11
8000a524:	fa ea 00 08 	ld.d	r10,sp[8]
8000a528:	e0 a0 0b f8 	rcall	8000bd18 <__avr32_f64_sub>
8000a52c:	fa eb 00 08 	st.d	sp[8],r10
8000a530:	e4 c8 ff d0 	sub	r8,r2,-48
8000a534:	0a c8       	st.b	r5++,r8
8000a536:	fc 19 40 24 	movh	r9,0x4024
8000a53a:	30 08       	mov	r8,0
8000a53c:	02 34       	cp.w	r4,r1
8000a53e:	c3 31       	brne	8000a5a4 <_dtoa_r+0x734>
8000a540:	fa e8 00 08 	ld.d	r8,sp[8]
8000a544:	e0 a0 0c b8 	rcall	8000beb4 <__avr32_f64_add>
8000a548:	16 91       	mov	r1,r11
8000a54a:	14 90       	mov	r0,r10
8000a54c:	14 98       	mov	r8,r10
8000a54e:	02 99       	mov	r9,r1
8000a550:	fa ea 00 10 	ld.d	r10,sp[16]
8000a554:	e0 a0 0e 08 	rcall	8000c164 <__avr32_f64_cmp_lt>
8000a558:	c1 a1       	brne	8000a58c <_dtoa_r+0x71c>
8000a55a:	fa e8 00 10 	ld.d	r8,sp[16]
8000a55e:	00 9a       	mov	r10,r0
8000a560:	02 9b       	mov	r11,r1
8000a562:	e0 a0 0d ba 	rcall	8000c0d6 <__avr32_f64_cmp_eq>
8000a566:	e0 80 02 5e 	breq	8000aa22 <_dtoa_r+0xbb2>
8000a56a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a56e:	c0 f1       	brne	8000a58c <_dtoa_r+0x71c>
8000a570:	e0 8f 02 59 	bral	8000aa22 <_dtoa_r+0xbb2>
8000a574:	40 8a       	lddsp	r10,sp[0x20]
8000a576:	14 38       	cp.w	r8,r10
8000a578:	c0 30       	breq	8000a57e <_dtoa_r+0x70e>
8000a57a:	10 95       	mov	r5,r8
8000a57c:	c0 98       	rjmp	8000a58e <_dtoa_r+0x71e>
8000a57e:	33 08       	mov	r8,48
8000a580:	40 89       	lddsp	r9,sp[0x20]
8000a582:	2f f6       	sub	r6,-1
8000a584:	b2 88       	st.b	r9[0x0],r8
8000a586:	40 88       	lddsp	r8,sp[0x20]
8000a588:	c0 88       	rjmp	8000a598 <_dtoa_r+0x728>
8000a58a:	40 66       	lddsp	r6,sp[0x18]
8000a58c:	33 99       	mov	r9,57
8000a58e:	0a 98       	mov	r8,r5
8000a590:	11 7a       	ld.ub	r10,--r8
8000a592:	f2 0a 18 00 	cp.b	r10,r9
8000a596:	ce f0       	breq	8000a574 <_dtoa_r+0x704>
8000a598:	50 66       	stdsp	sp[0x18],r6
8000a59a:	11 89       	ld.ub	r9,r8[0x0]
8000a59c:	2f f9       	sub	r9,-1
8000a59e:	b0 89       	st.b	r8[0x0],r9
8000a5a0:	e0 8f 02 42 	bral	8000aa24 <_dtoa_r+0xbb4>
8000a5a4:	e0 a0 0a ce 	rcall	8000bb40 <__avr32_f64_mul>
8000a5a8:	2f f4       	sub	r4,-1
8000a5aa:	fa eb 00 08 	st.d	sp[8],r10
8000a5ae:	30 08       	mov	r8,0
8000a5b0:	30 09       	mov	r9,0
8000a5b2:	e0 a0 0d 92 	rcall	8000c0d6 <__avr32_f64_cmp_eq>
8000a5b6:	ca 60       	breq	8000a502 <_dtoa_r+0x692>
8000a5b8:	e0 8f 02 35 	bral	8000aa22 <_dtoa_r+0xbb2>
8000a5bc:	40 d8       	lddsp	r8,sp[0x34]
8000a5be:	58 08       	cp.w	r8,0
8000a5c0:	c0 51       	brne	8000a5ca <_dtoa_r+0x75a>
8000a5c2:	04 98       	mov	r8,r2
8000a5c4:	00 95       	mov	r5,r0
8000a5c6:	40 d4       	lddsp	r4,sp[0x34]
8000a5c8:	c3 78       	rjmp	8000a636 <_dtoa_r+0x7c6>
8000a5ca:	40 c5       	lddsp	r5,sp[0x30]
8000a5cc:	58 15       	cp.w	r5,1
8000a5ce:	e0 89 00 0f 	brgt	8000a5ec <_dtoa_r+0x77c>
8000a5d2:	41 74       	lddsp	r4,sp[0x5c]
8000a5d4:	58 04       	cp.w	r4,0
8000a5d6:	c0 40       	breq	8000a5de <_dtoa_r+0x76e>
8000a5d8:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a5dc:	c0 48       	rjmp	8000a5e4 <_dtoa_r+0x774>
8000a5de:	41 99       	lddsp	r9,sp[0x64]
8000a5e0:	f2 09 11 36 	rsub	r9,r9,54
8000a5e4:	04 98       	mov	r8,r2
8000a5e6:	00 95       	mov	r5,r0
8000a5e8:	c1 c8       	rjmp	8000a620 <_dtoa_r+0x7b0>
8000a5ea:	d7 03       	nop
8000a5ec:	e2 c8 00 01 	sub	r8,r1,1
8000a5f0:	58 01       	cp.w	r1,0
8000a5f2:	e0 05 17 40 	movge	r5,r0
8000a5f6:	e2 09 17 40 	movge	r9,r1
8000a5fa:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a5fe:	f9 b9 05 00 	movlt	r9,0
8000a602:	10 32       	cp.w	r2,r8
8000a604:	e5 d8 e4 18 	subge	r8,r2,r8
8000a608:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a60c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a610:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a614:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a618:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a61c:	f9 b8 05 00 	movlt	r8,0
8000a620:	40 4b       	lddsp	r11,sp[0x10]
8000a622:	12 0b       	add	r11,r9
8000a624:	50 08       	stdsp	sp[0x0],r8
8000a626:	50 4b       	stdsp	sp[0x10],r11
8000a628:	12 00       	add	r0,r9
8000a62a:	30 1b       	mov	r11,1
8000a62c:	0e 9c       	mov	r12,r7
8000a62e:	e0 a0 08 a7 	rcall	8000b77c <__i2b>
8000a632:	40 08       	lddsp	r8,sp[0x0]
8000a634:	18 94       	mov	r4,r12
8000a636:	40 4a       	lddsp	r10,sp[0x10]
8000a638:	58 05       	cp.w	r5,0
8000a63a:	5f 99       	srgt	r9
8000a63c:	58 0a       	cp.w	r10,0
8000a63e:	5f 9a       	srgt	r10
8000a640:	f5 e9 00 09 	and	r9,r10,r9
8000a644:	c0 80       	breq	8000a654 <_dtoa_r+0x7e4>
8000a646:	40 4c       	lddsp	r12,sp[0x10]
8000a648:	f8 05 0d 49 	min	r9,r12,r5
8000a64c:	12 1c       	sub	r12,r9
8000a64e:	12 10       	sub	r0,r9
8000a650:	50 4c       	stdsp	sp[0x10],r12
8000a652:	12 15       	sub	r5,r9
8000a654:	58 02       	cp.w	r2,0
8000a656:	e0 8a 00 27 	brle	8000a6a4 <_dtoa_r+0x834>
8000a65a:	40 db       	lddsp	r11,sp[0x34]
8000a65c:	58 0b       	cp.w	r11,0
8000a65e:	c1 d0       	breq	8000a698 <_dtoa_r+0x828>
8000a660:	58 08       	cp.w	r8,0
8000a662:	e0 8a 00 17 	brle	8000a690 <_dtoa_r+0x820>
8000a666:	10 9a       	mov	r10,r8
8000a668:	50 08       	stdsp	sp[0x0],r8
8000a66a:	08 9b       	mov	r11,r4
8000a66c:	0e 9c       	mov	r12,r7
8000a66e:	e0 a0 08 cd 	rcall	8000b808 <__pow5mult>
8000a672:	06 9a       	mov	r10,r3
8000a674:	18 9b       	mov	r11,r12
8000a676:	18 94       	mov	r4,r12
8000a678:	0e 9c       	mov	r12,r7
8000a67a:	e0 a0 08 01 	rcall	8000b67c <__multiply>
8000a67e:	18 99       	mov	r9,r12
8000a680:	06 9b       	mov	r11,r3
8000a682:	50 19       	stdsp	sp[0x4],r9
8000a684:	0e 9c       	mov	r12,r7
8000a686:	e0 a0 06 ad 	rcall	8000b3e0 <_Bfree>
8000a68a:	40 19       	lddsp	r9,sp[0x4]
8000a68c:	40 08       	lddsp	r8,sp[0x0]
8000a68e:	12 93       	mov	r3,r9
8000a690:	e4 08 01 0a 	sub	r10,r2,r8
8000a694:	c0 80       	breq	8000a6a4 <_dtoa_r+0x834>
8000a696:	c0 28       	rjmp	8000a69a <_dtoa_r+0x82a>
8000a698:	04 9a       	mov	r10,r2
8000a69a:	06 9b       	mov	r11,r3
8000a69c:	0e 9c       	mov	r12,r7
8000a69e:	e0 a0 08 b5 	rcall	8000b808 <__pow5mult>
8000a6a2:	18 93       	mov	r3,r12
8000a6a4:	30 1b       	mov	r11,1
8000a6a6:	0e 9c       	mov	r12,r7
8000a6a8:	e0 a0 08 6a 	rcall	8000b77c <__i2b>
8000a6ac:	41 1a       	lddsp	r10,sp[0x44]
8000a6ae:	18 92       	mov	r2,r12
8000a6b0:	58 0a       	cp.w	r10,0
8000a6b2:	e0 8a 00 07 	brle	8000a6c0 <_dtoa_r+0x850>
8000a6b6:	18 9b       	mov	r11,r12
8000a6b8:	0e 9c       	mov	r12,r7
8000a6ba:	e0 a0 08 a7 	rcall	8000b808 <__pow5mult>
8000a6be:	18 92       	mov	r2,r12
8000a6c0:	40 c9       	lddsp	r9,sp[0x30]
8000a6c2:	58 19       	cp.w	r9,1
8000a6c4:	e0 89 00 14 	brgt	8000a6ec <_dtoa_r+0x87c>
8000a6c8:	40 38       	lddsp	r8,sp[0xc]
8000a6ca:	58 08       	cp.w	r8,0
8000a6cc:	c1 01       	brne	8000a6ec <_dtoa_r+0x87c>
8000a6ce:	40 29       	lddsp	r9,sp[0x8]
8000a6d0:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a6d4:	c0 c1       	brne	8000a6ec <_dtoa_r+0x87c>
8000a6d6:	12 98       	mov	r8,r9
8000a6d8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a6dc:	c0 80       	breq	8000a6ec <_dtoa_r+0x87c>
8000a6de:	40 4c       	lddsp	r12,sp[0x10]
8000a6e0:	30 1b       	mov	r11,1
8000a6e2:	2f fc       	sub	r12,-1
8000a6e4:	2f f0       	sub	r0,-1
8000a6e6:	50 4c       	stdsp	sp[0x10],r12
8000a6e8:	50 6b       	stdsp	sp[0x18],r11
8000a6ea:	c0 38       	rjmp	8000a6f0 <_dtoa_r+0x880>
8000a6ec:	30 0a       	mov	r10,0
8000a6ee:	50 6a       	stdsp	sp[0x18],r10
8000a6f0:	41 19       	lddsp	r9,sp[0x44]
8000a6f2:	58 09       	cp.w	r9,0
8000a6f4:	c0 31       	brne	8000a6fa <_dtoa_r+0x88a>
8000a6f6:	30 1c       	mov	r12,1
8000a6f8:	c0 98       	rjmp	8000a70a <_dtoa_r+0x89a>
8000a6fa:	64 48       	ld.w	r8,r2[0x10]
8000a6fc:	2f c8       	sub	r8,-4
8000a6fe:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a702:	e0 a0 05 df 	rcall	8000b2c0 <__hi0bits>
8000a706:	f8 0c 11 20 	rsub	r12,r12,32
8000a70a:	40 4b       	lddsp	r11,sp[0x10]
8000a70c:	f8 0b 00 08 	add	r8,r12,r11
8000a710:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a714:	c0 c0       	breq	8000a72c <_dtoa_r+0x8bc>
8000a716:	f0 08 11 20 	rsub	r8,r8,32
8000a71a:	58 48       	cp.w	r8,4
8000a71c:	e0 8a 00 06 	brle	8000a728 <_dtoa_r+0x8b8>
8000a720:	20 48       	sub	r8,4
8000a722:	10 0b       	add	r11,r8
8000a724:	50 4b       	stdsp	sp[0x10],r11
8000a726:	c0 78       	rjmp	8000a734 <_dtoa_r+0x8c4>
8000a728:	58 48       	cp.w	r8,4
8000a72a:	c0 70       	breq	8000a738 <_dtoa_r+0x8c8>
8000a72c:	40 4a       	lddsp	r10,sp[0x10]
8000a72e:	2e 48       	sub	r8,-28
8000a730:	10 0a       	add	r10,r8
8000a732:	50 4a       	stdsp	sp[0x10],r10
8000a734:	10 00       	add	r0,r8
8000a736:	10 05       	add	r5,r8
8000a738:	58 00       	cp.w	r0,0
8000a73a:	e0 8a 00 08 	brle	8000a74a <_dtoa_r+0x8da>
8000a73e:	06 9b       	mov	r11,r3
8000a740:	00 9a       	mov	r10,r0
8000a742:	0e 9c       	mov	r12,r7
8000a744:	e0 a0 07 58 	rcall	8000b5f4 <__lshift>
8000a748:	18 93       	mov	r3,r12
8000a74a:	40 49       	lddsp	r9,sp[0x10]
8000a74c:	58 09       	cp.w	r9,0
8000a74e:	e0 8a 00 08 	brle	8000a75e <_dtoa_r+0x8ee>
8000a752:	04 9b       	mov	r11,r2
8000a754:	12 9a       	mov	r10,r9
8000a756:	0e 9c       	mov	r12,r7
8000a758:	e0 a0 07 4e 	rcall	8000b5f4 <__lshift>
8000a75c:	18 92       	mov	r2,r12
8000a75e:	41 48       	lddsp	r8,sp[0x50]
8000a760:	58 08       	cp.w	r8,0
8000a762:	c1 b0       	breq	8000a798 <_dtoa_r+0x928>
8000a764:	04 9b       	mov	r11,r2
8000a766:	06 9c       	mov	r12,r3
8000a768:	e0 a0 06 23 	rcall	8000b3ae <__mcmp>
8000a76c:	c1 64       	brge	8000a798 <_dtoa_r+0x928>
8000a76e:	06 9b       	mov	r11,r3
8000a770:	30 09       	mov	r9,0
8000a772:	30 aa       	mov	r10,10
8000a774:	0e 9c       	mov	r12,r7
8000a776:	e0 a0 08 0b 	rcall	8000b78c <__multadd>
8000a77a:	20 16       	sub	r6,1
8000a77c:	18 93       	mov	r3,r12
8000a77e:	40 dc       	lddsp	r12,sp[0x34]
8000a780:	58 0c       	cp.w	r12,0
8000a782:	c0 31       	brne	8000a788 <_dtoa_r+0x918>
8000a784:	40 91       	lddsp	r1,sp[0x24]
8000a786:	c0 98       	rjmp	8000a798 <_dtoa_r+0x928>
8000a788:	08 9b       	mov	r11,r4
8000a78a:	40 91       	lddsp	r1,sp[0x24]
8000a78c:	30 09       	mov	r9,0
8000a78e:	30 aa       	mov	r10,10
8000a790:	0e 9c       	mov	r12,r7
8000a792:	e0 a0 07 fd 	rcall	8000b78c <__multadd>
8000a796:	18 94       	mov	r4,r12
8000a798:	58 01       	cp.w	r1,0
8000a79a:	5f a9       	srle	r9
8000a79c:	40 cb       	lddsp	r11,sp[0x30]
8000a79e:	58 2b       	cp.w	r11,2
8000a7a0:	5f 98       	srgt	r8
8000a7a2:	f3 e8 00 08 	and	r8,r9,r8
8000a7a6:	c2 50       	breq	8000a7f0 <_dtoa_r+0x980>
8000a7a8:	58 01       	cp.w	r1,0
8000a7aa:	c1 11       	brne	8000a7cc <_dtoa_r+0x95c>
8000a7ac:	04 9b       	mov	r11,r2
8000a7ae:	02 99       	mov	r9,r1
8000a7b0:	30 5a       	mov	r10,5
8000a7b2:	0e 9c       	mov	r12,r7
8000a7b4:	e0 a0 07 ec 	rcall	8000b78c <__multadd>
8000a7b8:	18 92       	mov	r2,r12
8000a7ba:	18 9b       	mov	r11,r12
8000a7bc:	06 9c       	mov	r12,r3
8000a7be:	e0 a0 05 f8 	rcall	8000b3ae <__mcmp>
8000a7c2:	e0 89 00 0f 	brgt	8000a7e0 <_dtoa_r+0x970>
8000a7c6:	c0 38       	rjmp	8000a7cc <_dtoa_r+0x95c>
8000a7c8:	30 02       	mov	r2,0
8000a7ca:	04 94       	mov	r4,r2
8000a7cc:	40 ea       	lddsp	r10,sp[0x38]
8000a7ce:	30 09       	mov	r9,0
8000a7d0:	5c da       	com	r10
8000a7d2:	40 85       	lddsp	r5,sp[0x20]
8000a7d4:	50 6a       	stdsp	sp[0x18],r10
8000a7d6:	50 49       	stdsp	sp[0x10],r9
8000a7d8:	c0 f9       	rjmp	8000a9f6 <_dtoa_r+0xb86>
8000a7da:	08 92       	mov	r2,r4
8000a7dc:	40 66       	lddsp	r6,sp[0x18]
8000a7de:	04 94       	mov	r4,r2
8000a7e0:	2f f6       	sub	r6,-1
8000a7e2:	50 66       	stdsp	sp[0x18],r6
8000a7e4:	33 18       	mov	r8,49
8000a7e6:	40 85       	lddsp	r5,sp[0x20]
8000a7e8:	0a c8       	st.b	r5++,r8
8000a7ea:	30 08       	mov	r8,0
8000a7ec:	50 48       	stdsp	sp[0x10],r8
8000a7ee:	c0 49       	rjmp	8000a9f6 <_dtoa_r+0xb86>
8000a7f0:	40 dc       	lddsp	r12,sp[0x34]
8000a7f2:	58 0c       	cp.w	r12,0
8000a7f4:	e0 80 00 b5 	breq	8000a95e <_dtoa_r+0xaee>
8000a7f8:	58 05       	cp.w	r5,0
8000a7fa:	e0 8a 00 08 	brle	8000a80a <_dtoa_r+0x99a>
8000a7fe:	08 9b       	mov	r11,r4
8000a800:	0a 9a       	mov	r10,r5
8000a802:	0e 9c       	mov	r12,r7
8000a804:	e0 a0 06 f8 	rcall	8000b5f4 <__lshift>
8000a808:	18 94       	mov	r4,r12
8000a80a:	40 6b       	lddsp	r11,sp[0x18]
8000a80c:	58 0b       	cp.w	r11,0
8000a80e:	c0 31       	brne	8000a814 <_dtoa_r+0x9a4>
8000a810:	08 9c       	mov	r12,r4
8000a812:	c1 38       	rjmp	8000a838 <_dtoa_r+0x9c8>
8000a814:	68 1b       	ld.w	r11,r4[0x4]
8000a816:	0e 9c       	mov	r12,r7
8000a818:	e0 a0 05 fe 	rcall	8000b414 <_Balloc>
8000a81c:	68 4a       	ld.w	r10,r4[0x10]
8000a81e:	18 95       	mov	r5,r12
8000a820:	e8 cb ff f4 	sub	r11,r4,-12
8000a824:	2f ea       	sub	r10,-2
8000a826:	2f 4c       	sub	r12,-12
8000a828:	a3 6a       	lsl	r10,0x2
8000a82a:	fe b0 e6 50 	rcall	800074ca <memcpy>
8000a82e:	0a 9b       	mov	r11,r5
8000a830:	30 1a       	mov	r10,1
8000a832:	0e 9c       	mov	r12,r7
8000a834:	e0 a0 06 e0 	rcall	8000b5f4 <__lshift>
8000a838:	50 44       	stdsp	sp[0x10],r4
8000a83a:	40 3a       	lddsp	r10,sp[0xc]
8000a83c:	30 19       	mov	r9,1
8000a83e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a842:	18 94       	mov	r4,r12
8000a844:	50 da       	stdsp	sp[0x34],r10
8000a846:	40 85       	lddsp	r5,sp[0x20]
8000a848:	50 99       	stdsp	sp[0x24],r9
8000a84a:	50 26       	stdsp	sp[0x8],r6
8000a84c:	50 e1       	stdsp	sp[0x38],r1
8000a84e:	04 9b       	mov	r11,r2
8000a850:	06 9c       	mov	r12,r3
8000a852:	fe b0 fa 7f 	rcall	80009d50 <quorem>
8000a856:	40 4b       	lddsp	r11,sp[0x10]
8000a858:	f8 c0 ff d0 	sub	r0,r12,-48
8000a85c:	06 9c       	mov	r12,r3
8000a85e:	e0 a0 05 a8 	rcall	8000b3ae <__mcmp>
8000a862:	08 9a       	mov	r10,r4
8000a864:	50 6c       	stdsp	sp[0x18],r12
8000a866:	04 9b       	mov	r11,r2
8000a868:	0e 9c       	mov	r12,r7
8000a86a:	e0 a0 06 5d 	rcall	8000b524 <__mdiff>
8000a86e:	18 91       	mov	r1,r12
8000a870:	78 38       	ld.w	r8,r12[0xc]
8000a872:	58 08       	cp.w	r8,0
8000a874:	c0 30       	breq	8000a87a <_dtoa_r+0xa0a>
8000a876:	30 16       	mov	r6,1
8000a878:	c0 68       	rjmp	8000a884 <_dtoa_r+0xa14>
8000a87a:	18 9b       	mov	r11,r12
8000a87c:	06 9c       	mov	r12,r3
8000a87e:	e0 a0 05 98 	rcall	8000b3ae <__mcmp>
8000a882:	18 96       	mov	r6,r12
8000a884:	0e 9c       	mov	r12,r7
8000a886:	02 9b       	mov	r11,r1
8000a888:	e0 a0 05 ac 	rcall	8000b3e0 <_Bfree>
8000a88c:	40 cc       	lddsp	r12,sp[0x30]
8000a88e:	ed ec 10 08 	or	r8,r6,r12
8000a892:	c0 d1       	brne	8000a8ac <_dtoa_r+0xa3c>
8000a894:	40 db       	lddsp	r11,sp[0x34]
8000a896:	58 0b       	cp.w	r11,0
8000a898:	c0 a1       	brne	8000a8ac <_dtoa_r+0xa3c>
8000a89a:	40 26       	lddsp	r6,sp[0x8]
8000a89c:	e0 40 00 39 	cp.w	r0,57
8000a8a0:	c3 00       	breq	8000a900 <_dtoa_r+0xa90>
8000a8a2:	40 6a       	lddsp	r10,sp[0x18]
8000a8a4:	58 0a       	cp.w	r10,0
8000a8a6:	e0 89 00 24 	brgt	8000a8ee <_dtoa_r+0xa7e>
8000a8aa:	c2 f8       	rjmp	8000a908 <_dtoa_r+0xa98>
8000a8ac:	40 69       	lddsp	r9,sp[0x18]
8000a8ae:	58 09       	cp.w	r9,0
8000a8b0:	c0 85       	brlt	8000a8c0 <_dtoa_r+0xa50>
8000a8b2:	12 98       	mov	r8,r9
8000a8b4:	40 cc       	lddsp	r12,sp[0x30]
8000a8b6:	18 48       	or	r8,r12
8000a8b8:	c1 d1       	brne	8000a8f2 <_dtoa_r+0xa82>
8000a8ba:	40 db       	lddsp	r11,sp[0x34]
8000a8bc:	58 0b       	cp.w	r11,0
8000a8be:	c1 a1       	brne	8000a8f2 <_dtoa_r+0xa82>
8000a8c0:	0c 99       	mov	r9,r6
8000a8c2:	40 26       	lddsp	r6,sp[0x8]
8000a8c4:	58 09       	cp.w	r9,0
8000a8c6:	e0 8a 00 21 	brle	8000a908 <_dtoa_r+0xa98>
8000a8ca:	06 9b       	mov	r11,r3
8000a8cc:	30 1a       	mov	r10,1
8000a8ce:	0e 9c       	mov	r12,r7
8000a8d0:	e0 a0 06 92 	rcall	8000b5f4 <__lshift>
8000a8d4:	04 9b       	mov	r11,r2
8000a8d6:	18 93       	mov	r3,r12
8000a8d8:	e0 a0 05 6b 	rcall	8000b3ae <__mcmp>
8000a8dc:	e0 89 00 06 	brgt	8000a8e8 <_dtoa_r+0xa78>
8000a8e0:	c1 41       	brne	8000a908 <_dtoa_r+0xa98>
8000a8e2:	ed b0 00 00 	bld	r0,0x0
8000a8e6:	c1 11       	brne	8000a908 <_dtoa_r+0xa98>
8000a8e8:	e0 40 00 39 	cp.w	r0,57
8000a8ec:	c0 a0       	breq	8000a900 <_dtoa_r+0xa90>
8000a8ee:	2f f0       	sub	r0,-1
8000a8f0:	c0 c8       	rjmp	8000a908 <_dtoa_r+0xa98>
8000a8f2:	58 06       	cp.w	r6,0
8000a8f4:	e0 8a 00 0c 	brle	8000a90c <_dtoa_r+0xa9c>
8000a8f8:	40 26       	lddsp	r6,sp[0x8]
8000a8fa:	e0 40 00 39 	cp.w	r0,57
8000a8fe:	c0 41       	brne	8000a906 <_dtoa_r+0xa96>
8000a900:	33 98       	mov	r8,57
8000a902:	0a c8       	st.b	r5++,r8
8000a904:	c6 78       	rjmp	8000a9d2 <_dtoa_r+0xb62>
8000a906:	2f f0       	sub	r0,-1
8000a908:	0a c0       	st.b	r5++,r0
8000a90a:	c7 58       	rjmp	8000a9f4 <_dtoa_r+0xb84>
8000a90c:	0a c0       	st.b	r5++,r0
8000a90e:	40 9a       	lddsp	r10,sp[0x24]
8000a910:	40 e9       	lddsp	r9,sp[0x38]
8000a912:	12 3a       	cp.w	r10,r9
8000a914:	c4 30       	breq	8000a99a <_dtoa_r+0xb2a>
8000a916:	06 9b       	mov	r11,r3
8000a918:	30 09       	mov	r9,0
8000a91a:	30 aa       	mov	r10,10
8000a91c:	0e 9c       	mov	r12,r7
8000a91e:	e0 a0 07 37 	rcall	8000b78c <__multadd>
8000a922:	40 48       	lddsp	r8,sp[0x10]
8000a924:	18 93       	mov	r3,r12
8000a926:	08 38       	cp.w	r8,r4
8000a928:	c0 91       	brne	8000a93a <_dtoa_r+0xaca>
8000a92a:	10 9b       	mov	r11,r8
8000a92c:	30 09       	mov	r9,0
8000a92e:	30 aa       	mov	r10,10
8000a930:	0e 9c       	mov	r12,r7
8000a932:	e0 a0 07 2d 	rcall	8000b78c <__multadd>
8000a936:	50 4c       	stdsp	sp[0x10],r12
8000a938:	c0 e8       	rjmp	8000a954 <_dtoa_r+0xae4>
8000a93a:	40 4b       	lddsp	r11,sp[0x10]
8000a93c:	30 09       	mov	r9,0
8000a93e:	30 aa       	mov	r10,10
8000a940:	0e 9c       	mov	r12,r7
8000a942:	e0 a0 07 25 	rcall	8000b78c <__multadd>
8000a946:	08 9b       	mov	r11,r4
8000a948:	50 4c       	stdsp	sp[0x10],r12
8000a94a:	30 09       	mov	r9,0
8000a94c:	30 aa       	mov	r10,10
8000a94e:	0e 9c       	mov	r12,r7
8000a950:	e0 a0 07 1e 	rcall	8000b78c <__multadd>
8000a954:	18 94       	mov	r4,r12
8000a956:	40 9c       	lddsp	r12,sp[0x24]
8000a958:	2f fc       	sub	r12,-1
8000a95a:	50 9c       	stdsp	sp[0x24],r12
8000a95c:	c7 9b       	rjmp	8000a84e <_dtoa_r+0x9de>
8000a95e:	30 18       	mov	r8,1
8000a960:	06 90       	mov	r0,r3
8000a962:	40 85       	lddsp	r5,sp[0x20]
8000a964:	08 93       	mov	r3,r4
8000a966:	0c 94       	mov	r4,r6
8000a968:	10 96       	mov	r6,r8
8000a96a:	04 9b       	mov	r11,r2
8000a96c:	00 9c       	mov	r12,r0
8000a96e:	fe b0 f9 f1 	rcall	80009d50 <quorem>
8000a972:	2d 0c       	sub	r12,-48
8000a974:	0a cc       	st.b	r5++,r12
8000a976:	02 36       	cp.w	r6,r1
8000a978:	c0 a4       	brge	8000a98c <_dtoa_r+0xb1c>
8000a97a:	00 9b       	mov	r11,r0
8000a97c:	30 09       	mov	r9,0
8000a97e:	30 aa       	mov	r10,10
8000a980:	0e 9c       	mov	r12,r7
8000a982:	2f f6       	sub	r6,-1
8000a984:	e0 a0 07 04 	rcall	8000b78c <__multadd>
8000a988:	18 90       	mov	r0,r12
8000a98a:	cf 0b       	rjmp	8000a96a <_dtoa_r+0xafa>
8000a98c:	08 96       	mov	r6,r4
8000a98e:	30 0b       	mov	r11,0
8000a990:	06 94       	mov	r4,r3
8000a992:	50 4b       	stdsp	sp[0x10],r11
8000a994:	00 93       	mov	r3,r0
8000a996:	18 90       	mov	r0,r12
8000a998:	c0 28       	rjmp	8000a99c <_dtoa_r+0xb2c>
8000a99a:	40 26       	lddsp	r6,sp[0x8]
8000a99c:	06 9b       	mov	r11,r3
8000a99e:	30 1a       	mov	r10,1
8000a9a0:	0e 9c       	mov	r12,r7
8000a9a2:	e0 a0 06 29 	rcall	8000b5f4 <__lshift>
8000a9a6:	04 9b       	mov	r11,r2
8000a9a8:	18 93       	mov	r3,r12
8000a9aa:	e0 a0 05 02 	rcall	8000b3ae <__mcmp>
8000a9ae:	e0 89 00 12 	brgt	8000a9d2 <_dtoa_r+0xb62>
8000a9b2:	c1 b1       	brne	8000a9e8 <_dtoa_r+0xb78>
8000a9b4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a9b8:	c0 d1       	brne	8000a9d2 <_dtoa_r+0xb62>
8000a9ba:	c1 78       	rjmp	8000a9e8 <_dtoa_r+0xb78>
8000a9bc:	40 89       	lddsp	r9,sp[0x20]
8000a9be:	12 38       	cp.w	r8,r9
8000a9c0:	c0 30       	breq	8000a9c6 <_dtoa_r+0xb56>
8000a9c2:	10 95       	mov	r5,r8
8000a9c4:	c0 88       	rjmp	8000a9d4 <_dtoa_r+0xb64>
8000a9c6:	2f f6       	sub	r6,-1
8000a9c8:	50 66       	stdsp	sp[0x18],r6
8000a9ca:	33 18       	mov	r8,49
8000a9cc:	40 8c       	lddsp	r12,sp[0x20]
8000a9ce:	b8 88       	st.b	r12[0x0],r8
8000a9d0:	c1 38       	rjmp	8000a9f6 <_dtoa_r+0xb86>
8000a9d2:	33 9a       	mov	r10,57
8000a9d4:	0a 98       	mov	r8,r5
8000a9d6:	11 79       	ld.ub	r9,--r8
8000a9d8:	f4 09 18 00 	cp.b	r9,r10
8000a9dc:	cf 00       	breq	8000a9bc <_dtoa_r+0xb4c>
8000a9de:	2f f9       	sub	r9,-1
8000a9e0:	b0 89       	st.b	r8[0x0],r9
8000a9e2:	c0 98       	rjmp	8000a9f4 <_dtoa_r+0xb84>
8000a9e4:	10 95       	mov	r5,r8
8000a9e6:	c0 28       	rjmp	8000a9ea <_dtoa_r+0xb7a>
8000a9e8:	33 09       	mov	r9,48
8000a9ea:	0a 98       	mov	r8,r5
8000a9ec:	11 7a       	ld.ub	r10,--r8
8000a9ee:	f2 0a 18 00 	cp.b	r10,r9
8000a9f2:	cf 90       	breq	8000a9e4 <_dtoa_r+0xb74>
8000a9f4:	50 66       	stdsp	sp[0x18],r6
8000a9f6:	04 9b       	mov	r11,r2
8000a9f8:	0e 9c       	mov	r12,r7
8000a9fa:	e0 a0 04 f3 	rcall	8000b3e0 <_Bfree>
8000a9fe:	58 04       	cp.w	r4,0
8000aa00:	c1 20       	breq	8000aa24 <_dtoa_r+0xbb4>
8000aa02:	40 4b       	lddsp	r11,sp[0x10]
8000aa04:	08 3b       	cp.w	r11,r4
8000aa06:	5f 19       	srne	r9
8000aa08:	58 0b       	cp.w	r11,0
8000aa0a:	5f 18       	srne	r8
8000aa0c:	f3 e8 00 08 	and	r8,r9,r8
8000aa10:	c0 40       	breq	8000aa18 <_dtoa_r+0xba8>
8000aa12:	0e 9c       	mov	r12,r7
8000aa14:	e0 a0 04 e6 	rcall	8000b3e0 <_Bfree>
8000aa18:	08 9b       	mov	r11,r4
8000aa1a:	0e 9c       	mov	r12,r7
8000aa1c:	e0 a0 04 e2 	rcall	8000b3e0 <_Bfree>
8000aa20:	c0 28       	rjmp	8000aa24 <_dtoa_r+0xbb4>
8000aa22:	50 66       	stdsp	sp[0x18],r6
8000aa24:	0e 9c       	mov	r12,r7
8000aa26:	06 9b       	mov	r11,r3
8000aa28:	e0 a0 04 dc 	rcall	8000b3e0 <_Bfree>
8000aa2c:	30 08       	mov	r8,0
8000aa2e:	aa 88       	st.b	r5[0x0],r8
8000aa30:	40 68       	lddsp	r8,sp[0x18]
8000aa32:	41 5a       	lddsp	r10,sp[0x54]
8000aa34:	2f f8       	sub	r8,-1
8000aa36:	41 29       	lddsp	r9,sp[0x48]
8000aa38:	95 08       	st.w	r10[0x0],r8
8000aa3a:	40 8c       	lddsp	r12,sp[0x20]
8000aa3c:	58 09       	cp.w	r9,0
8000aa3e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000aa42:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000aa46:	2e 6d       	sub	sp,-104
8000aa48:	d8 32       	popm	r0-r7,pc
8000aa4a:	d7 03       	nop

8000aa4c <__errno>:
8000aa4c:	e0 68 0a 38 	mov	r8,2616
8000aa50:	70 0c       	ld.w	r12,r8[0x0]
8000aa52:	2f 4c       	sub	r12,-12
8000aa54:	5e fc       	retal	r12
8000aa56:	d7 03       	nop

8000aa58 <_fflush_r>:
8000aa58:	d4 21       	pushm	r4-r7,lr
8000aa5a:	16 97       	mov	r7,r11
8000aa5c:	18 96       	mov	r6,r12
8000aa5e:	76 48       	ld.w	r8,r11[0x10]
8000aa60:	58 08       	cp.w	r8,0
8000aa62:	c7 f0       	breq	8000ab60 <_fflush_r+0x108>
8000aa64:	58 0c       	cp.w	r12,0
8000aa66:	c0 50       	breq	8000aa70 <_fflush_r+0x18>
8000aa68:	78 68       	ld.w	r8,r12[0x18]
8000aa6a:	58 08       	cp.w	r8,0
8000aa6c:	c0 21       	brne	8000aa70 <_fflush_r+0x18>
8000aa6e:	cc dc       	rcall	8000ac08 <__sinit>
8000aa70:	fe c8 c8 6c 	sub	r8,pc,-14228
8000aa74:	10 37       	cp.w	r7,r8
8000aa76:	c0 31       	brne	8000aa7c <_fflush_r+0x24>
8000aa78:	6c 07       	ld.w	r7,r6[0x0]
8000aa7a:	c0 c8       	rjmp	8000aa92 <_fflush_r+0x3a>
8000aa7c:	fe c8 c8 58 	sub	r8,pc,-14248
8000aa80:	10 37       	cp.w	r7,r8
8000aa82:	c0 31       	brne	8000aa88 <_fflush_r+0x30>
8000aa84:	6c 17       	ld.w	r7,r6[0x4]
8000aa86:	c0 68       	rjmp	8000aa92 <_fflush_r+0x3a>
8000aa88:	fe c8 c8 44 	sub	r8,pc,-14268
8000aa8c:	10 37       	cp.w	r7,r8
8000aa8e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aa92:	8e 6a       	ld.sh	r10,r7[0xc]
8000aa94:	14 98       	mov	r8,r10
8000aa96:	ed ba 00 03 	bld	r10,0x3
8000aa9a:	c4 20       	breq	8000ab1e <_fflush_r+0xc6>
8000aa9c:	ab ba       	sbr	r10,0xb
8000aa9e:	ae 6a       	st.h	r7[0xc],r10
8000aaa0:	6e 18       	ld.w	r8,r7[0x4]
8000aaa2:	58 08       	cp.w	r8,0
8000aaa4:	e0 89 00 06 	brgt	8000aab0 <_fflush_r+0x58>
8000aaa8:	6f 08       	ld.w	r8,r7[0x40]
8000aaaa:	58 08       	cp.w	r8,0
8000aaac:	e0 8a 00 5a 	brle	8000ab60 <_fflush_r+0x108>
8000aab0:	6e b8       	ld.w	r8,r7[0x2c]
8000aab2:	58 08       	cp.w	r8,0
8000aab4:	c5 60       	breq	8000ab60 <_fflush_r+0x108>
8000aab6:	e2 1a 10 00 	andl	r10,0x1000,COH
8000aaba:	c0 30       	breq	8000aac0 <_fflush_r+0x68>
8000aabc:	6f 55       	ld.w	r5,r7[0x54]
8000aabe:	c0 f8       	rjmp	8000aadc <_fflush_r+0x84>
8000aac0:	30 19       	mov	r9,1
8000aac2:	6e 8b       	ld.w	r11,r7[0x20]
8000aac4:	0c 9c       	mov	r12,r6
8000aac6:	5d 18       	icall	r8
8000aac8:	18 95       	mov	r5,r12
8000aaca:	5b fc       	cp.w	r12,-1
8000aacc:	c0 81       	brne	8000aadc <_fflush_r+0x84>
8000aace:	6c 38       	ld.w	r8,r6[0xc]
8000aad0:	59 d8       	cp.w	r8,29
8000aad2:	c4 70       	breq	8000ab60 <_fflush_r+0x108>
8000aad4:	8e 68       	ld.sh	r8,r7[0xc]
8000aad6:	a7 a8       	sbr	r8,0x6
8000aad8:	ae 68       	st.h	r7[0xc],r8
8000aada:	d8 22       	popm	r4-r7,pc
8000aadc:	8e 68       	ld.sh	r8,r7[0xc]
8000aade:	ed b8 00 02 	bld	r8,0x2
8000aae2:	c0 91       	brne	8000aaf4 <_fflush_r+0x9c>
8000aae4:	6e 18       	ld.w	r8,r7[0x4]
8000aae6:	10 15       	sub	r5,r8
8000aae8:	6e d8       	ld.w	r8,r7[0x34]
8000aaea:	58 08       	cp.w	r8,0
8000aaec:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000aaf0:	eb d8 e1 15 	subne	r5,r5,r8
8000aaf4:	6e b8       	ld.w	r8,r7[0x2c]
8000aaf6:	0c 9c       	mov	r12,r6
8000aaf8:	30 09       	mov	r9,0
8000aafa:	0a 9a       	mov	r10,r5
8000aafc:	6e 8b       	ld.w	r11,r7[0x20]
8000aafe:	5d 18       	icall	r8
8000ab00:	8e 68       	ld.sh	r8,r7[0xc]
8000ab02:	0a 3c       	cp.w	r12,r5
8000ab04:	c2 61       	brne	8000ab50 <_fflush_r+0xf8>
8000ab06:	ab d8       	cbr	r8,0xb
8000ab08:	30 0c       	mov	r12,0
8000ab0a:	6e 49       	ld.w	r9,r7[0x10]
8000ab0c:	ae 68       	st.h	r7[0xc],r8
8000ab0e:	8f 1c       	st.w	r7[0x4],r12
8000ab10:	8f 09       	st.w	r7[0x0],r9
8000ab12:	ed b8 00 0c 	bld	r8,0xc
8000ab16:	c2 51       	brne	8000ab60 <_fflush_r+0x108>
8000ab18:	ef 45 00 54 	st.w	r7[84],r5
8000ab1c:	d8 22       	popm	r4-r7,pc
8000ab1e:	6e 45       	ld.w	r5,r7[0x10]
8000ab20:	58 05       	cp.w	r5,0
8000ab22:	c1 f0       	breq	8000ab60 <_fflush_r+0x108>
8000ab24:	6e 04       	ld.w	r4,r7[0x0]
8000ab26:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ab2a:	8f 05       	st.w	r7[0x0],r5
8000ab2c:	f9 b8 01 00 	movne	r8,0
8000ab30:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ab34:	0a 14       	sub	r4,r5
8000ab36:	8f 28       	st.w	r7[0x8],r8
8000ab38:	c1 18       	rjmp	8000ab5a <_fflush_r+0x102>
8000ab3a:	08 99       	mov	r9,r4
8000ab3c:	0a 9a       	mov	r10,r5
8000ab3e:	6e a8       	ld.w	r8,r7[0x28]
8000ab40:	6e 8b       	ld.w	r11,r7[0x20]
8000ab42:	0c 9c       	mov	r12,r6
8000ab44:	5d 18       	icall	r8
8000ab46:	18 14       	sub	r4,r12
8000ab48:	58 0c       	cp.w	r12,0
8000ab4a:	e0 89 00 07 	brgt	8000ab58 <_fflush_r+0x100>
8000ab4e:	8e 68       	ld.sh	r8,r7[0xc]
8000ab50:	a7 a8       	sbr	r8,0x6
8000ab52:	3f fc       	mov	r12,-1
8000ab54:	ae 68       	st.h	r7[0xc],r8
8000ab56:	d8 22       	popm	r4-r7,pc
8000ab58:	18 05       	add	r5,r12
8000ab5a:	58 04       	cp.w	r4,0
8000ab5c:	fe 99 ff ef 	brgt	8000ab3a <_fflush_r+0xe2>
8000ab60:	d8 2a       	popm	r4-r7,pc,r12=0
8000ab62:	d7 03       	nop

8000ab64 <__sfp_lock_acquire>:
8000ab64:	5e fc       	retal	r12

8000ab66 <__sfp_lock_release>:
8000ab66:	5e fc       	retal	r12

8000ab68 <_cleanup_r>:
8000ab68:	d4 01       	pushm	lr
8000ab6a:	fe cb f0 ae 	sub	r11,pc,-3922
8000ab6e:	e0 a0 02 f7 	rcall	8000b15c <_fwalk>
8000ab72:	d8 02       	popm	pc

8000ab74 <__sfmoreglue>:
8000ab74:	d4 21       	pushm	r4-r7,lr
8000ab76:	16 95       	mov	r5,r11
8000ab78:	f6 06 10 5c 	mul	r6,r11,92
8000ab7c:	ec cb ff f4 	sub	r11,r6,-12
8000ab80:	fe b0 e2 76 	rcall	8000706c <_malloc_r>
8000ab84:	18 97       	mov	r7,r12
8000ab86:	c0 90       	breq	8000ab98 <__sfmoreglue+0x24>
8000ab88:	99 15       	st.w	r12[0x4],r5
8000ab8a:	30 0b       	mov	r11,0
8000ab8c:	2f 4c       	sub	r12,-12
8000ab8e:	0c 9a       	mov	r10,r6
8000ab90:	8f 2c       	st.w	r7[0x8],r12
8000ab92:	8f 0b       	st.w	r7[0x0],r11
8000ab94:	fe b0 e5 3f 	rcall	80007612 <memset>
8000ab98:	0e 9c       	mov	r12,r7
8000ab9a:	d8 22       	popm	r4-r7,pc

8000ab9c <__sfp>:
8000ab9c:	d4 21       	pushm	r4-r7,lr
8000ab9e:	fe c8 c9 36 	sub	r8,pc,-14026
8000aba2:	18 96       	mov	r6,r12
8000aba4:	70 07       	ld.w	r7,r8[0x0]
8000aba6:	6e 68       	ld.w	r8,r7[0x18]
8000aba8:	58 08       	cp.w	r8,0
8000abaa:	c0 31       	brne	8000abb0 <__sfp+0x14>
8000abac:	0e 9c       	mov	r12,r7
8000abae:	c2 dc       	rcall	8000ac08 <__sinit>
8000abb0:	ee c7 ff 28 	sub	r7,r7,-216
8000abb4:	30 05       	mov	r5,0
8000abb6:	6e 2c       	ld.w	r12,r7[0x8]
8000abb8:	6e 18       	ld.w	r8,r7[0x4]
8000abba:	c0 68       	rjmp	8000abc6 <__sfp+0x2a>
8000abbc:	98 69       	ld.sh	r9,r12[0xc]
8000abbe:	ea 09 19 00 	cp.h	r9,r5
8000abc2:	c1 10       	breq	8000abe4 <__sfp+0x48>
8000abc4:	2a 4c       	sub	r12,-92
8000abc6:	20 18       	sub	r8,1
8000abc8:	cf a7       	brpl	8000abbc <__sfp+0x20>
8000abca:	6e 08       	ld.w	r8,r7[0x0]
8000abcc:	58 08       	cp.w	r8,0
8000abce:	c0 61       	brne	8000abda <__sfp+0x3e>
8000abd0:	30 4b       	mov	r11,4
8000abd2:	0c 9c       	mov	r12,r6
8000abd4:	cd 0f       	rcall	8000ab74 <__sfmoreglue>
8000abd6:	8f 0c       	st.w	r7[0x0],r12
8000abd8:	c0 30       	breq	8000abde <__sfp+0x42>
8000abda:	6e 07       	ld.w	r7,r7[0x0]
8000abdc:	ce db       	rjmp	8000abb6 <__sfp+0x1a>
8000abde:	30 c8       	mov	r8,12
8000abe0:	8d 38       	st.w	r6[0xc],r8
8000abe2:	d8 22       	popm	r4-r7,pc
8000abe4:	30 08       	mov	r8,0
8000abe6:	f9 48 00 4c 	st.w	r12[76],r8
8000abea:	99 08       	st.w	r12[0x0],r8
8000abec:	99 28       	st.w	r12[0x8],r8
8000abee:	99 18       	st.w	r12[0x4],r8
8000abf0:	99 48       	st.w	r12[0x10],r8
8000abf2:	99 58       	st.w	r12[0x14],r8
8000abf4:	99 68       	st.w	r12[0x18],r8
8000abf6:	99 d8       	st.w	r12[0x34],r8
8000abf8:	99 e8       	st.w	r12[0x38],r8
8000abfa:	f9 48 00 48 	st.w	r12[72],r8
8000abfe:	3f f8       	mov	r8,-1
8000ac00:	b8 78       	st.h	r12[0xe],r8
8000ac02:	30 18       	mov	r8,1
8000ac04:	b8 68       	st.h	r12[0xc],r8
8000ac06:	d8 22       	popm	r4-r7,pc

8000ac08 <__sinit>:
8000ac08:	d4 21       	pushm	r4-r7,lr
8000ac0a:	18 96       	mov	r6,r12
8000ac0c:	78 67       	ld.w	r7,r12[0x18]
8000ac0e:	58 07       	cp.w	r7,0
8000ac10:	c4 91       	brne	8000aca2 <__sinit+0x9a>
8000ac12:	fe c8 00 aa 	sub	r8,pc,170
8000ac16:	30 15       	mov	r5,1
8000ac18:	99 a8       	st.w	r12[0x28],r8
8000ac1a:	f9 47 00 d8 	st.w	r12[216],r7
8000ac1e:	f9 47 00 dc 	st.w	r12[220],r7
8000ac22:	f9 47 00 e0 	st.w	r12[224],r7
8000ac26:	99 65       	st.w	r12[0x18],r5
8000ac28:	cb af       	rcall	8000ab9c <__sfp>
8000ac2a:	8d 0c       	st.w	r6[0x0],r12
8000ac2c:	0c 9c       	mov	r12,r6
8000ac2e:	cb 7f       	rcall	8000ab9c <__sfp>
8000ac30:	8d 1c       	st.w	r6[0x4],r12
8000ac32:	0c 9c       	mov	r12,r6
8000ac34:	cb 4f       	rcall	8000ab9c <__sfp>
8000ac36:	6c 09       	ld.w	r9,r6[0x0]
8000ac38:	30 48       	mov	r8,4
8000ac3a:	93 07       	st.w	r9[0x0],r7
8000ac3c:	b2 68       	st.h	r9[0xc],r8
8000ac3e:	93 17       	st.w	r9[0x4],r7
8000ac40:	93 27       	st.w	r9[0x8],r7
8000ac42:	6c 18       	ld.w	r8,r6[0x4]
8000ac44:	b2 77       	st.h	r9[0xe],r7
8000ac46:	93 47       	st.w	r9[0x10],r7
8000ac48:	93 57       	st.w	r9[0x14],r7
8000ac4a:	93 67       	st.w	r9[0x18],r7
8000ac4c:	93 89       	st.w	r9[0x20],r9
8000ac4e:	91 07       	st.w	r8[0x0],r7
8000ac50:	91 17       	st.w	r8[0x4],r7
8000ac52:	91 27       	st.w	r8[0x8],r7
8000ac54:	fe ce f3 24 	sub	lr,pc,-3292
8000ac58:	fe cb f3 54 	sub	r11,pc,-3244
8000ac5c:	93 9e       	st.w	r9[0x24],lr
8000ac5e:	93 ab       	st.w	r9[0x28],r11
8000ac60:	fe ca f3 7c 	sub	r10,pc,-3204
8000ac64:	fe c4 f3 88 	sub	r4,pc,-3192
8000ac68:	93 ba       	st.w	r9[0x2c],r10
8000ac6a:	93 c4       	st.w	r9[0x30],r4
8000ac6c:	30 99       	mov	r9,9
8000ac6e:	b0 69       	st.h	r8[0xc],r9
8000ac70:	b0 75       	st.h	r8[0xe],r5
8000ac72:	91 c4       	st.w	r8[0x30],r4
8000ac74:	91 47       	st.w	r8[0x10],r7
8000ac76:	91 57       	st.w	r8[0x14],r7
8000ac78:	91 67       	st.w	r8[0x18],r7
8000ac7a:	91 88       	st.w	r8[0x20],r8
8000ac7c:	91 9e       	st.w	r8[0x24],lr
8000ac7e:	91 ab       	st.w	r8[0x28],r11
8000ac80:	91 ba       	st.w	r8[0x2c],r10
8000ac82:	8d 2c       	st.w	r6[0x8],r12
8000ac84:	31 28       	mov	r8,18
8000ac86:	99 07       	st.w	r12[0x0],r7
8000ac88:	b8 68       	st.h	r12[0xc],r8
8000ac8a:	99 17       	st.w	r12[0x4],r7
8000ac8c:	99 27       	st.w	r12[0x8],r7
8000ac8e:	30 28       	mov	r8,2
8000ac90:	b8 78       	st.h	r12[0xe],r8
8000ac92:	99 c4       	st.w	r12[0x30],r4
8000ac94:	99 67       	st.w	r12[0x18],r7
8000ac96:	99 9e       	st.w	r12[0x24],lr
8000ac98:	99 ab       	st.w	r12[0x28],r11
8000ac9a:	99 ba       	st.w	r12[0x2c],r10
8000ac9c:	99 47       	st.w	r12[0x10],r7
8000ac9e:	99 57       	st.w	r12[0x14],r7
8000aca0:	99 8c       	st.w	r12[0x20],r12
8000aca2:	d8 22       	popm	r4-r7,pc

8000aca4 <_malloc_trim_r>:
8000aca4:	d4 21       	pushm	r4-r7,lr
8000aca6:	16 95       	mov	r5,r11
8000aca8:	18 97       	mov	r7,r12
8000acaa:	fe b0 d7 df 	rcall	80005c68 <__malloc_lock>
8000acae:	e0 64 05 38 	mov	r4,1336
8000acb2:	68 28       	ld.w	r8,r4[0x8]
8000acb4:	70 16       	ld.w	r6,r8[0x4]
8000acb6:	e0 16 ff fc 	andl	r6,0xfffc
8000acba:	ec c8 ff 91 	sub	r8,r6,-111
8000acbe:	f0 05 01 05 	sub	r5,r8,r5
8000acc2:	e0 15 ff 80 	andl	r5,0xff80
8000acc6:	ea c5 00 80 	sub	r5,r5,128
8000acca:	e0 45 00 7f 	cp.w	r5,127
8000acce:	e0 8a 00 25 	brle	8000ad18 <_malloc_trim_r+0x74>
8000acd2:	30 0b       	mov	r11,0
8000acd4:	0e 9c       	mov	r12,r7
8000acd6:	fe b0 e6 05 	rcall	800078e0 <_sbrk_r>
8000acda:	68 28       	ld.w	r8,r4[0x8]
8000acdc:	0c 08       	add	r8,r6
8000acde:	10 3c       	cp.w	r12,r8
8000ace0:	c1 c1       	brne	8000ad18 <_malloc_trim_r+0x74>
8000ace2:	ea 0b 11 00 	rsub	r11,r5,0
8000ace6:	0e 9c       	mov	r12,r7
8000ace8:	fe b0 e5 fc 	rcall	800078e0 <_sbrk_r>
8000acec:	5b fc       	cp.w	r12,-1
8000acee:	c1 91       	brne	8000ad20 <_malloc_trim_r+0x7c>
8000acf0:	30 0b       	mov	r11,0
8000acf2:	0e 9c       	mov	r12,r7
8000acf4:	fe b0 e5 f6 	rcall	800078e0 <_sbrk_r>
8000acf8:	68 28       	ld.w	r8,r4[0x8]
8000acfa:	f8 08 01 09 	sub	r9,r12,r8
8000acfe:	58 f9       	cp.w	r9,15
8000ad00:	e0 8a 00 0c 	brle	8000ad18 <_malloc_trim_r+0x74>
8000ad04:	a1 a9       	sbr	r9,0x0
8000ad06:	91 19       	st.w	r8[0x4],r9
8000ad08:	e0 68 09 44 	mov	r8,2372
8000ad0c:	70 09       	ld.w	r9,r8[0x0]
8000ad0e:	e0 68 0d 54 	mov	r8,3412
8000ad12:	f8 09 01 09 	sub	r9,r12,r9
8000ad16:	91 09       	st.w	r8[0x0],r9
8000ad18:	0e 9c       	mov	r12,r7
8000ad1a:	fe b0 d7 ad 	rcall	80005c74 <__malloc_unlock>
8000ad1e:	d8 2a       	popm	r4-r7,pc,r12=0
8000ad20:	68 28       	ld.w	r8,r4[0x8]
8000ad22:	0a 16       	sub	r6,r5
8000ad24:	a1 a6       	sbr	r6,0x0
8000ad26:	91 16       	st.w	r8[0x4],r6
8000ad28:	e0 68 0d 54 	mov	r8,3412
8000ad2c:	70 09       	ld.w	r9,r8[0x0]
8000ad2e:	0a 19       	sub	r9,r5
8000ad30:	0e 9c       	mov	r12,r7
8000ad32:	91 09       	st.w	r8[0x0],r9
8000ad34:	fe b0 d7 a0 	rcall	80005c74 <__malloc_unlock>
8000ad38:	da 2a       	popm	r4-r7,pc,r12=1
8000ad3a:	d7 03       	nop

8000ad3c <_free_r>:
8000ad3c:	d4 21       	pushm	r4-r7,lr
8000ad3e:	16 96       	mov	r6,r11
8000ad40:	18 97       	mov	r7,r12
8000ad42:	58 0b       	cp.w	r11,0
8000ad44:	e0 80 00 c0 	breq	8000aec4 <_free_r+0x188>
8000ad48:	fe b0 d7 90 	rcall	80005c68 <__malloc_lock>
8000ad4c:	20 86       	sub	r6,8
8000ad4e:	e0 6a 05 38 	mov	r10,1336
8000ad52:	6c 18       	ld.w	r8,r6[0x4]
8000ad54:	74 2e       	ld.w	lr,r10[0x8]
8000ad56:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ad5a:	a1 c8       	cbr	r8,0x0
8000ad5c:	ec 08 00 09 	add	r9,r6,r8
8000ad60:	72 1b       	ld.w	r11,r9[0x4]
8000ad62:	e0 1b ff fc 	andl	r11,0xfffc
8000ad66:	1c 39       	cp.w	r9,lr
8000ad68:	c1 e1       	brne	8000ada4 <_free_r+0x68>
8000ad6a:	f6 08 00 08 	add	r8,r11,r8
8000ad6e:	58 0c       	cp.w	r12,0
8000ad70:	c0 81       	brne	8000ad80 <_free_r+0x44>
8000ad72:	6c 09       	ld.w	r9,r6[0x0]
8000ad74:	12 16       	sub	r6,r9
8000ad76:	12 08       	add	r8,r9
8000ad78:	6c 3b       	ld.w	r11,r6[0xc]
8000ad7a:	6c 29       	ld.w	r9,r6[0x8]
8000ad7c:	97 29       	st.w	r11[0x8],r9
8000ad7e:	93 3b       	st.w	r9[0xc],r11
8000ad80:	10 99       	mov	r9,r8
8000ad82:	95 26       	st.w	r10[0x8],r6
8000ad84:	a1 a9       	sbr	r9,0x0
8000ad86:	8d 19       	st.w	r6[0x4],r9
8000ad88:	e0 69 09 40 	mov	r9,2368
8000ad8c:	72 09       	ld.w	r9,r9[0x0]
8000ad8e:	12 38       	cp.w	r8,r9
8000ad90:	c0 63       	brcs	8000ad9c <_free_r+0x60>
8000ad92:	e0 68 0d 50 	mov	r8,3408
8000ad96:	0e 9c       	mov	r12,r7
8000ad98:	70 0b       	ld.w	r11,r8[0x0]
8000ad9a:	c8 5f       	rcall	8000aca4 <_malloc_trim_r>
8000ad9c:	0e 9c       	mov	r12,r7
8000ad9e:	fe b0 d7 6b 	rcall	80005c74 <__malloc_unlock>
8000ada2:	d8 22       	popm	r4-r7,pc
8000ada4:	93 1b       	st.w	r9[0x4],r11
8000ada6:	58 0c       	cp.w	r12,0
8000ada8:	c0 30       	breq	8000adae <_free_r+0x72>
8000adaa:	30 0c       	mov	r12,0
8000adac:	c1 08       	rjmp	8000adcc <_free_r+0x90>
8000adae:	6c 0e       	ld.w	lr,r6[0x0]
8000adb0:	f4 c5 ff f8 	sub	r5,r10,-8
8000adb4:	1c 16       	sub	r6,lr
8000adb6:	1c 08       	add	r8,lr
8000adb8:	6c 2e       	ld.w	lr,r6[0x8]
8000adba:	0a 3e       	cp.w	lr,r5
8000adbc:	f9 bc 00 01 	moveq	r12,1
8000adc0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000adc4:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000adc8:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000adcc:	f2 0b 00 0e 	add	lr,r9,r11
8000add0:	7c 1e       	ld.w	lr,lr[0x4]
8000add2:	ed be 00 00 	bld	lr,0x0
8000add6:	c1 40       	breq	8000adfe <_free_r+0xc2>
8000add8:	16 08       	add	r8,r11
8000adda:	58 0c       	cp.w	r12,0
8000addc:	c0 d1       	brne	8000adf6 <_free_r+0xba>
8000adde:	e0 6e 05 38 	mov	lr,1336
8000ade2:	72 2b       	ld.w	r11,r9[0x8]
8000ade4:	2f 8e       	sub	lr,-8
8000ade6:	1c 3b       	cp.w	r11,lr
8000ade8:	c0 71       	brne	8000adf6 <_free_r+0xba>
8000adea:	97 36       	st.w	r11[0xc],r6
8000adec:	97 26       	st.w	r11[0x8],r6
8000adee:	8d 2b       	st.w	r6[0x8],r11
8000adf0:	8d 3b       	st.w	r6[0xc],r11
8000adf2:	30 1c       	mov	r12,1
8000adf4:	c0 58       	rjmp	8000adfe <_free_r+0xc2>
8000adf6:	72 2b       	ld.w	r11,r9[0x8]
8000adf8:	72 39       	ld.w	r9,r9[0xc]
8000adfa:	93 2b       	st.w	r9[0x8],r11
8000adfc:	97 39       	st.w	r11[0xc],r9
8000adfe:	10 99       	mov	r9,r8
8000ae00:	ec 08 09 08 	st.w	r6[r8],r8
8000ae04:	a1 a9       	sbr	r9,0x0
8000ae06:	8d 19       	st.w	r6[0x4],r9
8000ae08:	58 0c       	cp.w	r12,0
8000ae0a:	c5 a1       	brne	8000aebe <_free_r+0x182>
8000ae0c:	e0 48 01 ff 	cp.w	r8,511
8000ae10:	e0 8b 00 13 	brhi	8000ae36 <_free_r+0xfa>
8000ae14:	a3 98       	lsr	r8,0x3
8000ae16:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ae1a:	72 2b       	ld.w	r11,r9[0x8]
8000ae1c:	8d 39       	st.w	r6[0xc],r9
8000ae1e:	8d 2b       	st.w	r6[0x8],r11
8000ae20:	97 36       	st.w	r11[0xc],r6
8000ae22:	93 26       	st.w	r9[0x8],r6
8000ae24:	a3 48       	asr	r8,0x2
8000ae26:	74 19       	ld.w	r9,r10[0x4]
8000ae28:	30 1b       	mov	r11,1
8000ae2a:	f6 08 09 48 	lsl	r8,r11,r8
8000ae2e:	f3 e8 10 08 	or	r8,r9,r8
8000ae32:	95 18       	st.w	r10[0x4],r8
8000ae34:	c4 58       	rjmp	8000aebe <_free_r+0x182>
8000ae36:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ae3a:	58 4b       	cp.w	r11,4
8000ae3c:	e0 8b 00 06 	brhi	8000ae48 <_free_r+0x10c>
8000ae40:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ae44:	2c 8b       	sub	r11,-56
8000ae46:	c2 08       	rjmp	8000ae86 <_free_r+0x14a>
8000ae48:	59 4b       	cp.w	r11,20
8000ae4a:	e0 8b 00 04 	brhi	8000ae52 <_free_r+0x116>
8000ae4e:	2a 5b       	sub	r11,-91
8000ae50:	c1 b8       	rjmp	8000ae86 <_free_r+0x14a>
8000ae52:	e0 4b 00 54 	cp.w	r11,84
8000ae56:	e0 8b 00 06 	brhi	8000ae62 <_free_r+0x126>
8000ae5a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ae5e:	29 2b       	sub	r11,-110
8000ae60:	c1 38       	rjmp	8000ae86 <_free_r+0x14a>
8000ae62:	e0 4b 01 54 	cp.w	r11,340
8000ae66:	e0 8b 00 06 	brhi	8000ae72 <_free_r+0x136>
8000ae6a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ae6e:	28 9b       	sub	r11,-119
8000ae70:	c0 b8       	rjmp	8000ae86 <_free_r+0x14a>
8000ae72:	e0 4b 05 54 	cp.w	r11,1364
8000ae76:	e0 88 00 05 	brls	8000ae80 <_free_r+0x144>
8000ae7a:	37 eb       	mov	r11,126
8000ae7c:	c0 58       	rjmp	8000ae86 <_free_r+0x14a>
8000ae7e:	d7 03       	nop
8000ae80:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ae84:	28 4b       	sub	r11,-124
8000ae86:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ae8a:	78 29       	ld.w	r9,r12[0x8]
8000ae8c:	18 39       	cp.w	r9,r12
8000ae8e:	c0 e1       	brne	8000aeaa <_free_r+0x16e>
8000ae90:	74 18       	ld.w	r8,r10[0x4]
8000ae92:	a3 4b       	asr	r11,0x2
8000ae94:	30 1c       	mov	r12,1
8000ae96:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ae9a:	f1 eb 10 0b 	or	r11,r8,r11
8000ae9e:	12 98       	mov	r8,r9
8000aea0:	95 1b       	st.w	r10[0x4],r11
8000aea2:	c0 a8       	rjmp	8000aeb6 <_free_r+0x17a>
8000aea4:	72 29       	ld.w	r9,r9[0x8]
8000aea6:	18 39       	cp.w	r9,r12
8000aea8:	c0 60       	breq	8000aeb4 <_free_r+0x178>
8000aeaa:	72 1a       	ld.w	r10,r9[0x4]
8000aeac:	e0 1a ff fc 	andl	r10,0xfffc
8000aeb0:	14 38       	cp.w	r8,r10
8000aeb2:	cf 93       	brcs	8000aea4 <_free_r+0x168>
8000aeb4:	72 38       	ld.w	r8,r9[0xc]
8000aeb6:	8d 38       	st.w	r6[0xc],r8
8000aeb8:	8d 29       	st.w	r6[0x8],r9
8000aeba:	93 36       	st.w	r9[0xc],r6
8000aebc:	91 26       	st.w	r8[0x8],r6
8000aebe:	0e 9c       	mov	r12,r7
8000aec0:	fe b0 d6 da 	rcall	80005c74 <__malloc_unlock>
8000aec4:	d8 22       	popm	r4-r7,pc
8000aec6:	d7 03       	nop

8000aec8 <__sfvwrite_r>:
8000aec8:	d4 31       	pushm	r0-r7,lr
8000aeca:	20 3d       	sub	sp,12
8000aecc:	14 94       	mov	r4,r10
8000aece:	18 95       	mov	r5,r12
8000aed0:	16 97       	mov	r7,r11
8000aed2:	74 28       	ld.w	r8,r10[0x8]
8000aed4:	58 08       	cp.w	r8,0
8000aed6:	e0 80 01 40 	breq	8000b156 <__sfvwrite_r+0x28e>
8000aeda:	96 68       	ld.sh	r8,r11[0xc]
8000aedc:	ed b8 00 03 	bld	r8,0x3
8000aee0:	c0 41       	brne	8000aee8 <__sfvwrite_r+0x20>
8000aee2:	76 48       	ld.w	r8,r11[0x10]
8000aee4:	58 08       	cp.w	r8,0
8000aee6:	c0 c1       	brne	8000aefe <__sfvwrite_r+0x36>
8000aee8:	0e 9b       	mov	r11,r7
8000aeea:	0a 9c       	mov	r12,r5
8000aeec:	fe b0 f6 c4 	rcall	80009c74 <__swsetup_r>
8000aef0:	c0 70       	breq	8000aefe <__sfvwrite_r+0x36>
8000aef2:	8e 68       	ld.sh	r8,r7[0xc]
8000aef4:	a7 a8       	sbr	r8,0x6
8000aef6:	ae 68       	st.h	r7[0xc],r8
8000aef8:	30 98       	mov	r8,9
8000aefa:	8b 38       	st.w	r5[0xc],r8
8000aefc:	c2 b9       	rjmp	8000b152 <__sfvwrite_r+0x28a>
8000aefe:	8e 63       	ld.sh	r3,r7[0xc]
8000af00:	68 00       	ld.w	r0,r4[0x0]
8000af02:	06 96       	mov	r6,r3
8000af04:	e2 16 00 02 	andl	r6,0x2,COH
8000af08:	c2 10       	breq	8000af4a <__sfvwrite_r+0x82>
8000af0a:	30 03       	mov	r3,0
8000af0c:	e0 62 04 00 	mov	r2,1024
8000af10:	06 96       	mov	r6,r3
8000af12:	c0 48       	rjmp	8000af1a <__sfvwrite_r+0x52>
8000af14:	60 03       	ld.w	r3,r0[0x0]
8000af16:	60 16       	ld.w	r6,r0[0x4]
8000af18:	2f 80       	sub	r0,-8
8000af1a:	58 06       	cp.w	r6,0
8000af1c:	cf c0       	breq	8000af14 <__sfvwrite_r+0x4c>
8000af1e:	e0 46 04 00 	cp.w	r6,1024
8000af22:	ec 09 17 80 	movls	r9,r6
8000af26:	e4 09 17 b0 	movhi	r9,r2
8000af2a:	06 9a       	mov	r10,r3
8000af2c:	6e a8       	ld.w	r8,r7[0x28]
8000af2e:	6e 8b       	ld.w	r11,r7[0x20]
8000af30:	0a 9c       	mov	r12,r5
8000af32:	5d 18       	icall	r8
8000af34:	18 16       	sub	r6,r12
8000af36:	58 0c       	cp.w	r12,0
8000af38:	e0 8a 01 0a 	brle	8000b14c <__sfvwrite_r+0x284>
8000af3c:	68 28       	ld.w	r8,r4[0x8]
8000af3e:	18 18       	sub	r8,r12
8000af40:	89 28       	st.w	r4[0x8],r8
8000af42:	e0 80 01 0a 	breq	8000b156 <__sfvwrite_r+0x28e>
8000af46:	18 03       	add	r3,r12
8000af48:	ce 9b       	rjmp	8000af1a <__sfvwrite_r+0x52>
8000af4a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000af4e:	c0 70       	breq	8000af5c <__sfvwrite_r+0x94>
8000af50:	50 06       	stdsp	sp[0x0],r6
8000af52:	0c 93       	mov	r3,r6
8000af54:	0c 91       	mov	r1,r6
8000af56:	50 15       	stdsp	sp[0x4],r5
8000af58:	08 92       	mov	r2,r4
8000af5a:	c9 c8       	rjmp	8000b092 <__sfvwrite_r+0x1ca>
8000af5c:	06 96       	mov	r6,r3
8000af5e:	08 91       	mov	r1,r4
8000af60:	c0 48       	rjmp	8000af68 <__sfvwrite_r+0xa0>
8000af62:	60 03       	ld.w	r3,r0[0x0]
8000af64:	60 16       	ld.w	r6,r0[0x4]
8000af66:	2f 80       	sub	r0,-8
8000af68:	58 06       	cp.w	r6,0
8000af6a:	cf c0       	breq	8000af62 <__sfvwrite_r+0x9a>
8000af6c:	8e 68       	ld.sh	r8,r7[0xc]
8000af6e:	6e 24       	ld.w	r4,r7[0x8]
8000af70:	10 99       	mov	r9,r8
8000af72:	e2 19 02 00 	andl	r9,0x200,COH
8000af76:	c5 50       	breq	8000b020 <__sfvwrite_r+0x158>
8000af78:	08 36       	cp.w	r6,r4
8000af7a:	c4 43       	brcs	8000b002 <__sfvwrite_r+0x13a>
8000af7c:	10 99       	mov	r9,r8
8000af7e:	e2 19 04 80 	andl	r9,0x480,COH
8000af82:	c4 00       	breq	8000b002 <__sfvwrite_r+0x13a>
8000af84:	6e 4b       	ld.w	r11,r7[0x10]
8000af86:	6e 09       	ld.w	r9,r7[0x0]
8000af88:	16 19       	sub	r9,r11
8000af8a:	50 09       	stdsp	sp[0x0],r9
8000af8c:	6e 59       	ld.w	r9,r7[0x14]
8000af8e:	10 9c       	mov	r12,r8
8000af90:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000af94:	30 28       	mov	r8,2
8000af96:	f4 08 0c 08 	divs	r8,r10,r8
8000af9a:	fa e9 00 04 	st.d	sp[4],r8
8000af9e:	10 94       	mov	r4,r8
8000afa0:	40 09       	lddsp	r9,sp[0x0]
8000afa2:	e2 1c 04 00 	andl	r12,0x400,COH
8000afa6:	2f f9       	sub	r9,-1
8000afa8:	0c 09       	add	r9,r6
8000afaa:	12 38       	cp.w	r8,r9
8000afac:	f2 04 17 30 	movlo	r4,r9
8000afb0:	58 0c       	cp.w	r12,0
8000afb2:	c1 10       	breq	8000afd4 <__sfvwrite_r+0x10c>
8000afb4:	08 9b       	mov	r11,r4
8000afb6:	0a 9c       	mov	r12,r5
8000afb8:	fe b0 e0 5a 	rcall	8000706c <_malloc_r>
8000afbc:	18 92       	mov	r2,r12
8000afbe:	c1 40       	breq	8000afe6 <__sfvwrite_r+0x11e>
8000afc0:	40 0a       	lddsp	r10,sp[0x0]
8000afc2:	6e 4b       	ld.w	r11,r7[0x10]
8000afc4:	fe b0 e2 83 	rcall	800074ca <memcpy>
8000afc8:	8e 68       	ld.sh	r8,r7[0xc]
8000afca:	e0 18 fb 7f 	andl	r8,0xfb7f
8000afce:	a7 b8       	sbr	r8,0x7
8000afd0:	ae 68       	st.h	r7[0xc],r8
8000afd2:	c0 d8       	rjmp	8000afec <__sfvwrite_r+0x124>
8000afd4:	08 9a       	mov	r10,r4
8000afd6:	0a 9c       	mov	r12,r5
8000afd8:	fe b0 e3 24 	rcall	80007620 <_realloc_r>
8000afdc:	18 92       	mov	r2,r12
8000afde:	c0 71       	brne	8000afec <__sfvwrite_r+0x124>
8000afe0:	6e 4b       	ld.w	r11,r7[0x10]
8000afe2:	0a 9c       	mov	r12,r5
8000afe4:	ca ce       	rcall	8000ad3c <_free_r>
8000afe6:	30 c8       	mov	r8,12
8000afe8:	8b 38       	st.w	r5[0xc],r8
8000afea:	cb 18       	rjmp	8000b14c <__sfvwrite_r+0x284>
8000afec:	40 0a       	lddsp	r10,sp[0x0]
8000afee:	40 09       	lddsp	r9,sp[0x0]
8000aff0:	e8 0a 01 0a 	sub	r10,r4,r10
8000aff4:	e4 09 00 08 	add	r8,r2,r9
8000aff8:	8f 54       	st.w	r7[0x14],r4
8000affa:	8f 2a       	st.w	r7[0x8],r10
8000affc:	8f 08       	st.w	r7[0x0],r8
8000affe:	8f 42       	st.w	r7[0x10],r2
8000b000:	0c 94       	mov	r4,r6
8000b002:	08 36       	cp.w	r6,r4
8000b004:	ec 04 17 30 	movlo	r4,r6
8000b008:	06 9b       	mov	r11,r3
8000b00a:	08 9a       	mov	r10,r4
8000b00c:	6e 0c       	ld.w	r12,r7[0x0]
8000b00e:	c3 ad       	rcall	8000b282 <memmove>
8000b010:	6e 08       	ld.w	r8,r7[0x0]
8000b012:	08 08       	add	r8,r4
8000b014:	8f 08       	st.w	r7[0x0],r8
8000b016:	6e 28       	ld.w	r8,r7[0x8]
8000b018:	08 18       	sub	r8,r4
8000b01a:	0c 94       	mov	r4,r6
8000b01c:	8f 28       	st.w	r7[0x8],r8
8000b01e:	c2 e8       	rjmp	8000b07a <__sfvwrite_r+0x1b2>
8000b020:	08 36       	cp.w	r6,r4
8000b022:	5f ba       	srhi	r10
8000b024:	6e 0c       	ld.w	r12,r7[0x0]
8000b026:	6e 48       	ld.w	r8,r7[0x10]
8000b028:	10 3c       	cp.w	r12,r8
8000b02a:	5f b8       	srhi	r8
8000b02c:	f5 e8 00 08 	and	r8,r10,r8
8000b030:	f2 08 18 00 	cp.b	r8,r9
8000b034:	c0 d0       	breq	8000b04e <__sfvwrite_r+0x186>
8000b036:	06 9b       	mov	r11,r3
8000b038:	08 9a       	mov	r10,r4
8000b03a:	c2 4d       	rcall	8000b282 <memmove>
8000b03c:	6e 08       	ld.w	r8,r7[0x0]
8000b03e:	08 08       	add	r8,r4
8000b040:	0e 9b       	mov	r11,r7
8000b042:	8f 08       	st.w	r7[0x0],r8
8000b044:	0a 9c       	mov	r12,r5
8000b046:	fe b0 fd 09 	rcall	8000aa58 <_fflush_r>
8000b04a:	c1 80       	breq	8000b07a <__sfvwrite_r+0x1b2>
8000b04c:	c8 08       	rjmp	8000b14c <__sfvwrite_r+0x284>
8000b04e:	6e 59       	ld.w	r9,r7[0x14]
8000b050:	12 36       	cp.w	r6,r9
8000b052:	c0 a3       	brcs	8000b066 <__sfvwrite_r+0x19e>
8000b054:	6e a8       	ld.w	r8,r7[0x28]
8000b056:	06 9a       	mov	r10,r3
8000b058:	6e 8b       	ld.w	r11,r7[0x20]
8000b05a:	0a 9c       	mov	r12,r5
8000b05c:	5d 18       	icall	r8
8000b05e:	18 94       	mov	r4,r12
8000b060:	e0 89 00 0d 	brgt	8000b07a <__sfvwrite_r+0x1b2>
8000b064:	c7 48       	rjmp	8000b14c <__sfvwrite_r+0x284>
8000b066:	0c 9a       	mov	r10,r6
8000b068:	06 9b       	mov	r11,r3
8000b06a:	c0 cd       	rcall	8000b282 <memmove>
8000b06c:	6e 08       	ld.w	r8,r7[0x0]
8000b06e:	0c 08       	add	r8,r6
8000b070:	0c 94       	mov	r4,r6
8000b072:	8f 08       	st.w	r7[0x0],r8
8000b074:	6e 28       	ld.w	r8,r7[0x8]
8000b076:	0c 18       	sub	r8,r6
8000b078:	8f 28       	st.w	r7[0x8],r8
8000b07a:	62 28       	ld.w	r8,r1[0x8]
8000b07c:	08 18       	sub	r8,r4
8000b07e:	83 28       	st.w	r1[0x8],r8
8000b080:	c6 b0       	breq	8000b156 <__sfvwrite_r+0x28e>
8000b082:	08 16       	sub	r6,r4
8000b084:	08 03       	add	r3,r4
8000b086:	c7 1b       	rjmp	8000af68 <__sfvwrite_r+0xa0>
8000b088:	60 03       	ld.w	r3,r0[0x0]
8000b08a:	60 11       	ld.w	r1,r0[0x4]
8000b08c:	30 08       	mov	r8,0
8000b08e:	2f 80       	sub	r0,-8
8000b090:	50 08       	stdsp	sp[0x0],r8
8000b092:	58 01       	cp.w	r1,0
8000b094:	cf a0       	breq	8000b088 <__sfvwrite_r+0x1c0>
8000b096:	40 0a       	lddsp	r10,sp[0x0]
8000b098:	58 0a       	cp.w	r10,0
8000b09a:	c1 41       	brne	8000b0c2 <__sfvwrite_r+0x1fa>
8000b09c:	e2 c6 ff ff 	sub	r6,r1,-1
8000b0a0:	02 9a       	mov	r10,r1
8000b0a2:	30 ab       	mov	r11,10
8000b0a4:	06 9c       	mov	r12,r3
8000b0a6:	ce 3c       	rcall	8000b26c <memchr>
8000b0a8:	f8 c8 ff ff 	sub	r8,r12,-1
8000b0ac:	58 0c       	cp.w	r12,0
8000b0ae:	f1 d3 e1 16 	subne	r6,r8,r3
8000b0b2:	f9 b9 01 01 	movne	r9,1
8000b0b6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b0ba:	f9 b8 00 01 	moveq	r8,1
8000b0be:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b0c2:	02 36       	cp.w	r6,r1
8000b0c4:	ec 04 17 80 	movls	r4,r6
8000b0c8:	e2 04 17 b0 	movhi	r4,r1
8000b0cc:	6e 59       	ld.w	r9,r7[0x14]
8000b0ce:	6e 25       	ld.w	r5,r7[0x8]
8000b0d0:	f2 05 00 05 	add	r5,r9,r5
8000b0d4:	0a 34       	cp.w	r4,r5
8000b0d6:	5f 9a       	srgt	r10
8000b0d8:	6e 0c       	ld.w	r12,r7[0x0]
8000b0da:	6e 48       	ld.w	r8,r7[0x10]
8000b0dc:	10 3c       	cp.w	r12,r8
8000b0de:	5f b8       	srhi	r8
8000b0e0:	f5 e8 00 08 	and	r8,r10,r8
8000b0e4:	30 0a       	mov	r10,0
8000b0e6:	f4 08 18 00 	cp.b	r8,r10
8000b0ea:	c0 d0       	breq	8000b104 <__sfvwrite_r+0x23c>
8000b0ec:	06 9b       	mov	r11,r3
8000b0ee:	0a 9a       	mov	r10,r5
8000b0f0:	cc 9c       	rcall	8000b282 <memmove>
8000b0f2:	6e 08       	ld.w	r8,r7[0x0]
8000b0f4:	0a 08       	add	r8,r5
8000b0f6:	0e 9b       	mov	r11,r7
8000b0f8:	8f 08       	st.w	r7[0x0],r8
8000b0fa:	40 1c       	lddsp	r12,sp[0x4]
8000b0fc:	fe b0 fc ae 	rcall	8000aa58 <_fflush_r>
8000b100:	c1 70       	breq	8000b12e <__sfvwrite_r+0x266>
8000b102:	c2 58       	rjmp	8000b14c <__sfvwrite_r+0x284>
8000b104:	12 34       	cp.w	r4,r9
8000b106:	c0 a5       	brlt	8000b11a <__sfvwrite_r+0x252>
8000b108:	6e a8       	ld.w	r8,r7[0x28]
8000b10a:	06 9a       	mov	r10,r3
8000b10c:	6e 8b       	ld.w	r11,r7[0x20]
8000b10e:	40 1c       	lddsp	r12,sp[0x4]
8000b110:	5d 18       	icall	r8
8000b112:	18 95       	mov	r5,r12
8000b114:	e0 89 00 0d 	brgt	8000b12e <__sfvwrite_r+0x266>
8000b118:	c1 a8       	rjmp	8000b14c <__sfvwrite_r+0x284>
8000b11a:	08 9a       	mov	r10,r4
8000b11c:	06 9b       	mov	r11,r3
8000b11e:	cb 2c       	rcall	8000b282 <memmove>
8000b120:	6e 08       	ld.w	r8,r7[0x0]
8000b122:	08 08       	add	r8,r4
8000b124:	08 95       	mov	r5,r4
8000b126:	8f 08       	st.w	r7[0x0],r8
8000b128:	6e 28       	ld.w	r8,r7[0x8]
8000b12a:	08 18       	sub	r8,r4
8000b12c:	8f 28       	st.w	r7[0x8],r8
8000b12e:	0a 16       	sub	r6,r5
8000b130:	c0 71       	brne	8000b13e <__sfvwrite_r+0x276>
8000b132:	0e 9b       	mov	r11,r7
8000b134:	40 1c       	lddsp	r12,sp[0x4]
8000b136:	fe b0 fc 91 	rcall	8000aa58 <_fflush_r>
8000b13a:	c0 91       	brne	8000b14c <__sfvwrite_r+0x284>
8000b13c:	50 06       	stdsp	sp[0x0],r6
8000b13e:	64 28       	ld.w	r8,r2[0x8]
8000b140:	0a 18       	sub	r8,r5
8000b142:	85 28       	st.w	r2[0x8],r8
8000b144:	c0 90       	breq	8000b156 <__sfvwrite_r+0x28e>
8000b146:	0a 11       	sub	r1,r5
8000b148:	0a 03       	add	r3,r5
8000b14a:	ca 4b       	rjmp	8000b092 <__sfvwrite_r+0x1ca>
8000b14c:	8e 68       	ld.sh	r8,r7[0xc]
8000b14e:	a7 a8       	sbr	r8,0x6
8000b150:	ae 68       	st.h	r7[0xc],r8
8000b152:	3f fc       	mov	r12,-1
8000b154:	c0 28       	rjmp	8000b158 <__sfvwrite_r+0x290>
8000b156:	30 0c       	mov	r12,0
8000b158:	2f dd       	sub	sp,-12
8000b15a:	d8 32       	popm	r0-r7,pc

8000b15c <_fwalk>:
8000b15c:	d4 31       	pushm	r0-r7,lr
8000b15e:	30 05       	mov	r5,0
8000b160:	16 91       	mov	r1,r11
8000b162:	f8 c7 ff 28 	sub	r7,r12,-216
8000b166:	0a 92       	mov	r2,r5
8000b168:	fe b0 fc fe 	rcall	8000ab64 <__sfp_lock_acquire>
8000b16c:	3f f3       	mov	r3,-1
8000b16e:	c1 68       	rjmp	8000b19a <_fwalk+0x3e>
8000b170:	6e 26       	ld.w	r6,r7[0x8]
8000b172:	6e 14       	ld.w	r4,r7[0x4]
8000b174:	2f 46       	sub	r6,-12
8000b176:	c0 c8       	rjmp	8000b18e <_fwalk+0x32>
8000b178:	8c 08       	ld.sh	r8,r6[0x0]
8000b17a:	e4 08 19 00 	cp.h	r8,r2
8000b17e:	c0 70       	breq	8000b18c <_fwalk+0x30>
8000b180:	8c 18       	ld.sh	r8,r6[0x2]
8000b182:	e6 08 19 00 	cp.h	r8,r3
8000b186:	c0 30       	breq	8000b18c <_fwalk+0x30>
8000b188:	5d 11       	icall	r1
8000b18a:	18 45       	or	r5,r12
8000b18c:	2a 46       	sub	r6,-92
8000b18e:	20 14       	sub	r4,1
8000b190:	ec cc 00 0c 	sub	r12,r6,12
8000b194:	58 04       	cp.w	r4,0
8000b196:	cf 14       	brge	8000b178 <_fwalk+0x1c>
8000b198:	6e 07       	ld.w	r7,r7[0x0]
8000b19a:	58 07       	cp.w	r7,0
8000b19c:	ce a1       	brne	8000b170 <_fwalk+0x14>
8000b19e:	fe b0 fc e4 	rcall	8000ab66 <__sfp_lock_release>
8000b1a2:	0a 9c       	mov	r12,r5
8000b1a4:	d8 32       	popm	r0-r7,pc
8000b1a6:	d7 03       	nop

8000b1a8 <_localeconv_r>:
8000b1a8:	fe cc cf 3c 	sub	r12,pc,-12484
8000b1ac:	5e fc       	retal	r12
8000b1ae:	d7 03       	nop

8000b1b0 <__smakebuf_r>:
8000b1b0:	d4 21       	pushm	r4-r7,lr
8000b1b2:	20 fd       	sub	sp,60
8000b1b4:	96 68       	ld.sh	r8,r11[0xc]
8000b1b6:	16 97       	mov	r7,r11
8000b1b8:	18 96       	mov	r6,r12
8000b1ba:	e2 18 00 02 	andl	r8,0x2,COH
8000b1be:	c3 d1       	brne	8000b238 <__smakebuf_r+0x88>
8000b1c0:	96 7b       	ld.sh	r11,r11[0xe]
8000b1c2:	f0 0b 19 00 	cp.h	r11,r8
8000b1c6:	c0 55       	brlt	8000b1d0 <__smakebuf_r+0x20>
8000b1c8:	1a 9a       	mov	r10,sp
8000b1ca:	e0 a0 04 81 	rcall	8000bacc <_fstat_r>
8000b1ce:	c0 f4       	brge	8000b1ec <__smakebuf_r+0x3c>
8000b1d0:	8e 65       	ld.sh	r5,r7[0xc]
8000b1d2:	0a 98       	mov	r8,r5
8000b1d4:	ab b8       	sbr	r8,0xb
8000b1d6:	e2 15 00 80 	andl	r5,0x80,COH
8000b1da:	ae 68       	st.h	r7[0xc],r8
8000b1dc:	30 04       	mov	r4,0
8000b1de:	e0 68 04 00 	mov	r8,1024
8000b1e2:	f9 b5 01 40 	movne	r5,64
8000b1e6:	f0 05 17 00 	moveq	r5,r8
8000b1ea:	c1 c8       	rjmp	8000b222 <__smakebuf_r+0x72>
8000b1ec:	40 18       	lddsp	r8,sp[0x4]
8000b1ee:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b1f2:	e0 48 20 00 	cp.w	r8,8192
8000b1f6:	5f 04       	sreq	r4
8000b1f8:	e0 48 80 00 	cp.w	r8,32768
8000b1fc:	c0 e1       	brne	8000b218 <__smakebuf_r+0x68>
8000b1fe:	6e b9       	ld.w	r9,r7[0x2c]
8000b200:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b204:	10 39       	cp.w	r9,r8
8000b206:	c0 91       	brne	8000b218 <__smakebuf_r+0x68>
8000b208:	8e 68       	ld.sh	r8,r7[0xc]
8000b20a:	e0 65 04 00 	mov	r5,1024
8000b20e:	ab a8       	sbr	r8,0xa
8000b210:	ef 45 00 50 	st.w	r7[80],r5
8000b214:	ae 68       	st.h	r7[0xc],r8
8000b216:	c0 68       	rjmp	8000b222 <__smakebuf_r+0x72>
8000b218:	8e 68       	ld.sh	r8,r7[0xc]
8000b21a:	e0 65 04 00 	mov	r5,1024
8000b21e:	ab b8       	sbr	r8,0xb
8000b220:	ae 68       	st.h	r7[0xc],r8
8000b222:	0a 9b       	mov	r11,r5
8000b224:	0c 9c       	mov	r12,r6
8000b226:	fe b0 df 23 	rcall	8000706c <_malloc_r>
8000b22a:	8e 68       	ld.sh	r8,r7[0xc]
8000b22c:	c0 d1       	brne	8000b246 <__smakebuf_r+0x96>
8000b22e:	ed b8 00 09 	bld	r8,0x9
8000b232:	c1 b0       	breq	8000b268 <__smakebuf_r+0xb8>
8000b234:	a1 b8       	sbr	r8,0x1
8000b236:	ae 68       	st.h	r7[0xc],r8
8000b238:	ee c8 ff b9 	sub	r8,r7,-71
8000b23c:	8f 48       	st.w	r7[0x10],r8
8000b23e:	8f 08       	st.w	r7[0x0],r8
8000b240:	30 18       	mov	r8,1
8000b242:	8f 58       	st.w	r7[0x14],r8
8000b244:	c1 28       	rjmp	8000b268 <__smakebuf_r+0xb8>
8000b246:	a7 b8       	sbr	r8,0x7
8000b248:	8f 4c       	st.w	r7[0x10],r12
8000b24a:	ae 68       	st.h	r7[0xc],r8
8000b24c:	8f 55       	st.w	r7[0x14],r5
8000b24e:	fe c8 06 e6 	sub	r8,pc,1766
8000b252:	8f 0c       	st.w	r7[0x0],r12
8000b254:	8d a8       	st.w	r6[0x28],r8
8000b256:	58 04       	cp.w	r4,0
8000b258:	c0 80       	breq	8000b268 <__smakebuf_r+0xb8>
8000b25a:	8e 7c       	ld.sh	r12,r7[0xe]
8000b25c:	fe b0 e3 94 	rcall	80007984 <isatty>
8000b260:	c0 40       	breq	8000b268 <__smakebuf_r+0xb8>
8000b262:	8e 68       	ld.sh	r8,r7[0xc]
8000b264:	a1 a8       	sbr	r8,0x0
8000b266:	ae 68       	st.h	r7[0xc],r8
8000b268:	2f 1d       	sub	sp,-60
8000b26a:	d8 22       	popm	r4-r7,pc

8000b26c <memchr>:
8000b26c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b270:	c0 68       	rjmp	8000b27c <memchr+0x10>
8000b272:	20 1a       	sub	r10,1
8000b274:	19 88       	ld.ub	r8,r12[0x0]
8000b276:	16 38       	cp.w	r8,r11
8000b278:	5e 0c       	reteq	r12
8000b27a:	2f fc       	sub	r12,-1
8000b27c:	58 0a       	cp.w	r10,0
8000b27e:	cf a1       	brne	8000b272 <memchr+0x6>
8000b280:	5e fa       	retal	r10

8000b282 <memmove>:
8000b282:	d4 01       	pushm	lr
8000b284:	18 3b       	cp.w	r11,r12
8000b286:	c1 92       	brcc	8000b2b8 <memmove+0x36>
8000b288:	f6 0a 00 09 	add	r9,r11,r10
8000b28c:	12 3c       	cp.w	r12,r9
8000b28e:	c1 52       	brcc	8000b2b8 <memmove+0x36>
8000b290:	f8 0a 00 0b 	add	r11,r12,r10
8000b294:	30 08       	mov	r8,0
8000b296:	c0 68       	rjmp	8000b2a2 <memmove+0x20>
8000b298:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b29c:	20 1a       	sub	r10,1
8000b29e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b2a2:	20 18       	sub	r8,1
8000b2a4:	58 0a       	cp.w	r10,0
8000b2a6:	cf 91       	brne	8000b298 <memmove+0x16>
8000b2a8:	d8 02       	popm	pc
8000b2aa:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b2ae:	20 1a       	sub	r10,1
8000b2b0:	f8 08 0b 09 	st.b	r12[r8],r9
8000b2b4:	2f f8       	sub	r8,-1
8000b2b6:	c0 28       	rjmp	8000b2ba <memmove+0x38>
8000b2b8:	30 08       	mov	r8,0
8000b2ba:	58 0a       	cp.w	r10,0
8000b2bc:	cf 71       	brne	8000b2aa <memmove+0x28>
8000b2be:	d8 02       	popm	pc

8000b2c0 <__hi0bits>:
8000b2c0:	18 98       	mov	r8,r12
8000b2c2:	e0 1c 00 00 	andl	r12,0x0
8000b2c6:	f0 09 15 10 	lsl	r9,r8,0x10
8000b2ca:	58 0c       	cp.w	r12,0
8000b2cc:	f2 08 17 00 	moveq	r8,r9
8000b2d0:	f9 bc 00 10 	moveq	r12,16
8000b2d4:	f9 bc 01 00 	movne	r12,0
8000b2d8:	10 9a       	mov	r10,r8
8000b2da:	f0 09 15 08 	lsl	r9,r8,0x8
8000b2de:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b2e2:	f7 bc 00 f8 	subeq	r12,-8
8000b2e6:	f2 08 17 00 	moveq	r8,r9
8000b2ea:	10 9a       	mov	r10,r8
8000b2ec:	f0 09 15 04 	lsl	r9,r8,0x4
8000b2f0:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b2f4:	f7 bc 00 fc 	subeq	r12,-4
8000b2f8:	f2 08 17 00 	moveq	r8,r9
8000b2fc:	10 9a       	mov	r10,r8
8000b2fe:	f0 09 15 02 	lsl	r9,r8,0x2
8000b302:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b306:	f7 bc 00 fe 	subeq	r12,-2
8000b30a:	f2 08 17 00 	moveq	r8,r9
8000b30e:	58 08       	cp.w	r8,0
8000b310:	5e 5c       	retlt	r12
8000b312:	ed b8 00 1e 	bld	r8,0x1e
8000b316:	f9 bc 01 20 	movne	r12,32
8000b31a:	f7 bc 00 ff 	subeq	r12,-1
8000b31e:	5e fc       	retal	r12

8000b320 <__lo0bits>:
8000b320:	18 99       	mov	r9,r12
8000b322:	78 08       	ld.w	r8,r12[0x0]
8000b324:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b328:	c1 50       	breq	8000b352 <__lo0bits+0x32>
8000b32a:	ed b8 00 00 	bld	r8,0x0
8000b32e:	c0 21       	brne	8000b332 <__lo0bits+0x12>
8000b330:	5e fd       	retal	0
8000b332:	10 9b       	mov	r11,r8
8000b334:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b338:	e2 1b 00 02 	andl	r11,0x2,COH
8000b33c:	a3 88       	lsr	r8,0x2
8000b33e:	58 0b       	cp.w	r11,0
8000b340:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b344:	f9 bc 01 01 	movne	r12,1
8000b348:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b34c:	f9 bc 00 02 	moveq	r12,2
8000b350:	5e fc       	retal	r12
8000b352:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b356:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b35a:	58 0a       	cp.w	r10,0
8000b35c:	f6 08 17 00 	moveq	r8,r11
8000b360:	f9 bc 00 10 	moveq	r12,16
8000b364:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b368:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b36c:	58 0b       	cp.w	r11,0
8000b36e:	f7 bc 00 f8 	subeq	r12,-8
8000b372:	f4 08 17 00 	moveq	r8,r10
8000b376:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b37a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b37e:	58 0b       	cp.w	r11,0
8000b380:	f7 bc 00 fc 	subeq	r12,-4
8000b384:	f4 08 17 00 	moveq	r8,r10
8000b388:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b38c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b390:	58 0b       	cp.w	r11,0
8000b392:	f7 bc 00 fe 	subeq	r12,-2
8000b396:	f4 08 17 00 	moveq	r8,r10
8000b39a:	ed b8 00 00 	bld	r8,0x0
8000b39e:	c0 60       	breq	8000b3aa <__lo0bits+0x8a>
8000b3a0:	a1 98       	lsr	r8,0x1
8000b3a2:	c0 31       	brne	8000b3a8 <__lo0bits+0x88>
8000b3a4:	32 0c       	mov	r12,32
8000b3a6:	5e fc       	retal	r12
8000b3a8:	2f fc       	sub	r12,-1
8000b3aa:	93 08       	st.w	r9[0x0],r8
8000b3ac:	5e fc       	retal	r12

8000b3ae <__mcmp>:
8000b3ae:	d4 01       	pushm	lr
8000b3b0:	18 98       	mov	r8,r12
8000b3b2:	76 49       	ld.w	r9,r11[0x10]
8000b3b4:	78 4c       	ld.w	r12,r12[0x10]
8000b3b6:	12 1c       	sub	r12,r9
8000b3b8:	c1 31       	brne	8000b3de <__mcmp+0x30>
8000b3ba:	2f b9       	sub	r9,-5
8000b3bc:	a3 69       	lsl	r9,0x2
8000b3be:	12 0b       	add	r11,r9
8000b3c0:	f0 09 00 09 	add	r9,r8,r9
8000b3c4:	2e c8       	sub	r8,-20
8000b3c6:	13 4e       	ld.w	lr,--r9
8000b3c8:	17 4a       	ld.w	r10,--r11
8000b3ca:	14 3e       	cp.w	lr,r10
8000b3cc:	c0 60       	breq	8000b3d8 <__mcmp+0x2a>
8000b3ce:	f9 bc 03 ff 	movlo	r12,-1
8000b3d2:	f9 bc 02 01 	movhs	r12,1
8000b3d6:	d8 02       	popm	pc
8000b3d8:	10 39       	cp.w	r9,r8
8000b3da:	fe 9b ff f6 	brhi	8000b3c6 <__mcmp+0x18>
8000b3de:	d8 02       	popm	pc

8000b3e0 <_Bfree>:
8000b3e0:	d4 21       	pushm	r4-r7,lr
8000b3e2:	18 97       	mov	r7,r12
8000b3e4:	16 95       	mov	r5,r11
8000b3e6:	78 96       	ld.w	r6,r12[0x24]
8000b3e8:	58 06       	cp.w	r6,0
8000b3ea:	c0 91       	brne	8000b3fc <_Bfree+0x1c>
8000b3ec:	31 0c       	mov	r12,16
8000b3ee:	fe b0 de 37 	rcall	8000705c <malloc>
8000b3f2:	99 36       	st.w	r12[0xc],r6
8000b3f4:	8f 9c       	st.w	r7[0x24],r12
8000b3f6:	99 16       	st.w	r12[0x4],r6
8000b3f8:	99 26       	st.w	r12[0x8],r6
8000b3fa:	99 06       	st.w	r12[0x0],r6
8000b3fc:	58 05       	cp.w	r5,0
8000b3fe:	c0 90       	breq	8000b410 <_Bfree+0x30>
8000b400:	6a 19       	ld.w	r9,r5[0x4]
8000b402:	6e 98       	ld.w	r8,r7[0x24]
8000b404:	70 38       	ld.w	r8,r8[0xc]
8000b406:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b40a:	8b 0a       	st.w	r5[0x0],r10
8000b40c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b410:	d8 22       	popm	r4-r7,pc
8000b412:	d7 03       	nop

8000b414 <_Balloc>:
8000b414:	d4 21       	pushm	r4-r7,lr
8000b416:	18 97       	mov	r7,r12
8000b418:	16 96       	mov	r6,r11
8000b41a:	78 95       	ld.w	r5,r12[0x24]
8000b41c:	58 05       	cp.w	r5,0
8000b41e:	c0 91       	brne	8000b430 <_Balloc+0x1c>
8000b420:	31 0c       	mov	r12,16
8000b422:	fe b0 de 1d 	rcall	8000705c <malloc>
8000b426:	99 35       	st.w	r12[0xc],r5
8000b428:	8f 9c       	st.w	r7[0x24],r12
8000b42a:	99 15       	st.w	r12[0x4],r5
8000b42c:	99 25       	st.w	r12[0x8],r5
8000b42e:	99 05       	st.w	r12[0x0],r5
8000b430:	6e 95       	ld.w	r5,r7[0x24]
8000b432:	6a 38       	ld.w	r8,r5[0xc]
8000b434:	58 08       	cp.w	r8,0
8000b436:	c0 b1       	brne	8000b44c <_Balloc+0x38>
8000b438:	31 0a       	mov	r10,16
8000b43a:	30 4b       	mov	r11,4
8000b43c:	0e 9c       	mov	r12,r7
8000b43e:	e0 a0 02 a7 	rcall	8000b98c <_calloc_r>
8000b442:	8b 3c       	st.w	r5[0xc],r12
8000b444:	6e 98       	ld.w	r8,r7[0x24]
8000b446:	70 3c       	ld.w	r12,r8[0xc]
8000b448:	58 0c       	cp.w	r12,0
8000b44a:	c1 b0       	breq	8000b480 <_Balloc+0x6c>
8000b44c:	6e 98       	ld.w	r8,r7[0x24]
8000b44e:	70 38       	ld.w	r8,r8[0xc]
8000b450:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b454:	70 0c       	ld.w	r12,r8[0x0]
8000b456:	58 0c       	cp.w	r12,0
8000b458:	c0 40       	breq	8000b460 <_Balloc+0x4c>
8000b45a:	78 09       	ld.w	r9,r12[0x0]
8000b45c:	91 09       	st.w	r8[0x0],r9
8000b45e:	c0 e8       	rjmp	8000b47a <_Balloc+0x66>
8000b460:	0e 9c       	mov	r12,r7
8000b462:	30 17       	mov	r7,1
8000b464:	0e 9b       	mov	r11,r7
8000b466:	ee 06 09 47 	lsl	r7,r7,r6
8000b46a:	ee ca ff fb 	sub	r10,r7,-5
8000b46e:	a3 6a       	lsl	r10,0x2
8000b470:	e0 a0 02 8e 	rcall	8000b98c <_calloc_r>
8000b474:	c0 60       	breq	8000b480 <_Balloc+0x6c>
8000b476:	99 16       	st.w	r12[0x4],r6
8000b478:	99 27       	st.w	r12[0x8],r7
8000b47a:	30 08       	mov	r8,0
8000b47c:	99 38       	st.w	r12[0xc],r8
8000b47e:	99 48       	st.w	r12[0x10],r8
8000b480:	d8 22       	popm	r4-r7,pc
8000b482:	d7 03       	nop

8000b484 <__d2b>:
8000b484:	d4 31       	pushm	r0-r7,lr
8000b486:	20 2d       	sub	sp,8
8000b488:	16 93       	mov	r3,r11
8000b48a:	12 96       	mov	r6,r9
8000b48c:	10 95       	mov	r5,r8
8000b48e:	14 92       	mov	r2,r10
8000b490:	30 1b       	mov	r11,1
8000b492:	cc 1f       	rcall	8000b414 <_Balloc>
8000b494:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b498:	50 09       	stdsp	sp[0x0],r9
8000b49a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b49e:	b5 a9       	sbr	r9,0x14
8000b4a0:	f0 01 16 14 	lsr	r1,r8,0x14
8000b4a4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b4a8:	18 94       	mov	r4,r12
8000b4aa:	58 02       	cp.w	r2,0
8000b4ac:	c1 d0       	breq	8000b4e6 <__d2b+0x62>
8000b4ae:	fa cc ff f8 	sub	r12,sp,-8
8000b4b2:	18 d2       	st.w	--r12,r2
8000b4b4:	c3 6f       	rcall	8000b320 <__lo0bits>
8000b4b6:	40 18       	lddsp	r8,sp[0x4]
8000b4b8:	c0 d0       	breq	8000b4d2 <__d2b+0x4e>
8000b4ba:	40 09       	lddsp	r9,sp[0x0]
8000b4bc:	f8 0a 11 20 	rsub	r10,r12,32
8000b4c0:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b4c4:	f5 e8 10 08 	or	r8,r10,r8
8000b4c8:	89 58       	st.w	r4[0x14],r8
8000b4ca:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b4ce:	50 09       	stdsp	sp[0x0],r9
8000b4d0:	c0 28       	rjmp	8000b4d4 <__d2b+0x50>
8000b4d2:	89 58       	st.w	r4[0x14],r8
8000b4d4:	40 08       	lddsp	r8,sp[0x0]
8000b4d6:	58 08       	cp.w	r8,0
8000b4d8:	f9 b3 01 02 	movne	r3,2
8000b4dc:	f9 b3 00 01 	moveq	r3,1
8000b4e0:	89 68       	st.w	r4[0x18],r8
8000b4e2:	89 43       	st.w	r4[0x10],r3
8000b4e4:	c0 88       	rjmp	8000b4f4 <__d2b+0x70>
8000b4e6:	1a 9c       	mov	r12,sp
8000b4e8:	c1 cf       	rcall	8000b320 <__lo0bits>
8000b4ea:	30 13       	mov	r3,1
8000b4ec:	40 08       	lddsp	r8,sp[0x0]
8000b4ee:	2e 0c       	sub	r12,-32
8000b4f0:	89 43       	st.w	r4[0x10],r3
8000b4f2:	89 58       	st.w	r4[0x14],r8
8000b4f4:	58 01       	cp.w	r1,0
8000b4f6:	c0 90       	breq	8000b508 <__d2b+0x84>
8000b4f8:	e2 c1 04 33 	sub	r1,r1,1075
8000b4fc:	18 01       	add	r1,r12
8000b4fe:	8d 01       	st.w	r6[0x0],r1
8000b500:	f8 0c 11 35 	rsub	r12,r12,53
8000b504:	8b 0c       	st.w	r5[0x0],r12
8000b506:	c0 c8       	rjmp	8000b51e <__d2b+0x9a>
8000b508:	e6 c8 ff fc 	sub	r8,r3,-4
8000b50c:	f8 cc 04 32 	sub	r12,r12,1074
8000b510:	a5 73       	lsl	r3,0x5
8000b512:	8d 0c       	st.w	r6[0x0],r12
8000b514:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b518:	cd 4e       	rcall	8000b2c0 <__hi0bits>
8000b51a:	18 13       	sub	r3,r12
8000b51c:	8b 03       	st.w	r5[0x0],r3
8000b51e:	08 9c       	mov	r12,r4
8000b520:	2f ed       	sub	sp,-8
8000b522:	d8 32       	popm	r0-r7,pc

8000b524 <__mdiff>:
8000b524:	d4 31       	pushm	r0-r7,lr
8000b526:	74 48       	ld.w	r8,r10[0x10]
8000b528:	76 45       	ld.w	r5,r11[0x10]
8000b52a:	16 97       	mov	r7,r11
8000b52c:	14 96       	mov	r6,r10
8000b52e:	10 15       	sub	r5,r8
8000b530:	c1 31       	brne	8000b556 <__mdiff+0x32>
8000b532:	2f b8       	sub	r8,-5
8000b534:	ee ce ff ec 	sub	lr,r7,-20
8000b538:	a3 68       	lsl	r8,0x2
8000b53a:	f4 08 00 0b 	add	r11,r10,r8
8000b53e:	ee 08 00 08 	add	r8,r7,r8
8000b542:	11 4a       	ld.w	r10,--r8
8000b544:	17 49       	ld.w	r9,--r11
8000b546:	12 3a       	cp.w	r10,r9
8000b548:	c0 30       	breq	8000b54e <__mdiff+0x2a>
8000b54a:	c0 e2       	brcc	8000b566 <__mdiff+0x42>
8000b54c:	c0 78       	rjmp	8000b55a <__mdiff+0x36>
8000b54e:	1c 38       	cp.w	r8,lr
8000b550:	fe 9b ff f9 	brhi	8000b542 <__mdiff+0x1e>
8000b554:	c4 98       	rjmp	8000b5e6 <__mdiff+0xc2>
8000b556:	58 05       	cp.w	r5,0
8000b558:	c0 64       	brge	8000b564 <__mdiff+0x40>
8000b55a:	0e 98       	mov	r8,r7
8000b55c:	30 15       	mov	r5,1
8000b55e:	0c 97       	mov	r7,r6
8000b560:	10 96       	mov	r6,r8
8000b562:	c0 28       	rjmp	8000b566 <__mdiff+0x42>
8000b564:	30 05       	mov	r5,0
8000b566:	6e 1b       	ld.w	r11,r7[0x4]
8000b568:	c5 6f       	rcall	8000b414 <_Balloc>
8000b56a:	6e 49       	ld.w	r9,r7[0x10]
8000b56c:	6c 44       	ld.w	r4,r6[0x10]
8000b56e:	99 35       	st.w	r12[0xc],r5
8000b570:	2f b4       	sub	r4,-5
8000b572:	f2 c5 ff fb 	sub	r5,r9,-5
8000b576:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b57a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b57e:	2e c6       	sub	r6,-20
8000b580:	2e c7       	sub	r7,-20
8000b582:	f8 c8 ff ec 	sub	r8,r12,-20
8000b586:	30 0a       	mov	r10,0
8000b588:	0f 0e       	ld.w	lr,r7++
8000b58a:	0d 0b       	ld.w	r11,r6++
8000b58c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b590:	f6 03 16 10 	lsr	r3,r11,0x10
8000b594:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b598:	e4 03 01 03 	sub	r3,r2,r3
8000b59c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b5a0:	fc 0b 01 0b 	sub	r11,lr,r11
8000b5a4:	f6 0a 00 0a 	add	r10,r11,r10
8000b5a8:	b0 1a       	st.h	r8[0x2],r10
8000b5aa:	b1 4a       	asr	r10,0x10
8000b5ac:	e6 0a 00 0a 	add	r10,r3,r10
8000b5b0:	b0 0a       	st.h	r8[0x0],r10
8000b5b2:	2f c8       	sub	r8,-4
8000b5b4:	b1 4a       	asr	r10,0x10
8000b5b6:	08 36       	cp.w	r6,r4
8000b5b8:	ce 83       	brcs	8000b588 <__mdiff+0x64>
8000b5ba:	c0 d8       	rjmp	8000b5d4 <__mdiff+0xb0>
8000b5bc:	0f 0b       	ld.w	r11,r7++
8000b5be:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b5c2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b5c6:	16 0a       	add	r10,r11
8000b5c8:	b0 1a       	st.h	r8[0x2],r10
8000b5ca:	b1 4a       	asr	r10,0x10
8000b5cc:	1c 0a       	add	r10,lr
8000b5ce:	b0 0a       	st.h	r8[0x0],r10
8000b5d0:	2f c8       	sub	r8,-4
8000b5d2:	b1 4a       	asr	r10,0x10
8000b5d4:	0a 37       	cp.w	r7,r5
8000b5d6:	cf 33       	brcs	8000b5bc <__mdiff+0x98>
8000b5d8:	c0 28       	rjmp	8000b5dc <__mdiff+0xb8>
8000b5da:	20 19       	sub	r9,1
8000b5dc:	11 4a       	ld.w	r10,--r8
8000b5de:	58 0a       	cp.w	r10,0
8000b5e0:	cf d0       	breq	8000b5da <__mdiff+0xb6>
8000b5e2:	99 49       	st.w	r12[0x10],r9
8000b5e4:	d8 32       	popm	r0-r7,pc
8000b5e6:	30 0b       	mov	r11,0
8000b5e8:	c1 6f       	rcall	8000b414 <_Balloc>
8000b5ea:	30 18       	mov	r8,1
8000b5ec:	99 48       	st.w	r12[0x10],r8
8000b5ee:	30 08       	mov	r8,0
8000b5f0:	99 58       	st.w	r12[0x14],r8
8000b5f2:	d8 32       	popm	r0-r7,pc

8000b5f4 <__lshift>:
8000b5f4:	d4 31       	pushm	r0-r7,lr
8000b5f6:	16 97       	mov	r7,r11
8000b5f8:	76 46       	ld.w	r6,r11[0x10]
8000b5fa:	f4 02 14 05 	asr	r2,r10,0x5
8000b5fe:	2f f6       	sub	r6,-1
8000b600:	14 93       	mov	r3,r10
8000b602:	18 94       	mov	r4,r12
8000b604:	04 06       	add	r6,r2
8000b606:	76 1b       	ld.w	r11,r11[0x4]
8000b608:	6e 28       	ld.w	r8,r7[0x8]
8000b60a:	c0 38       	rjmp	8000b610 <__lshift+0x1c>
8000b60c:	2f fb       	sub	r11,-1
8000b60e:	a1 78       	lsl	r8,0x1
8000b610:	10 36       	cp.w	r6,r8
8000b612:	fe 99 ff fd 	brgt	8000b60c <__lshift+0x18>
8000b616:	08 9c       	mov	r12,r4
8000b618:	cf ee       	rcall	8000b414 <_Balloc>
8000b61a:	30 09       	mov	r9,0
8000b61c:	18 95       	mov	r5,r12
8000b61e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b622:	12 9a       	mov	r10,r9
8000b624:	c0 38       	rjmp	8000b62a <__lshift+0x36>
8000b626:	10 aa       	st.w	r8++,r10
8000b628:	2f f9       	sub	r9,-1
8000b62a:	04 39       	cp.w	r9,r2
8000b62c:	cf d5       	brlt	8000b626 <__lshift+0x32>
8000b62e:	6e 4b       	ld.w	r11,r7[0x10]
8000b630:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b634:	2f bb       	sub	r11,-5
8000b636:	ee c9 ff ec 	sub	r9,r7,-20
8000b63a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b63e:	58 03       	cp.w	r3,0
8000b640:	c1 30       	breq	8000b666 <__lshift+0x72>
8000b642:	e6 0c 11 20 	rsub	r12,r3,32
8000b646:	30 0a       	mov	r10,0
8000b648:	72 02       	ld.w	r2,r9[0x0]
8000b64a:	e4 03 09 42 	lsl	r2,r2,r3
8000b64e:	04 4a       	or	r10,r2
8000b650:	10 aa       	st.w	r8++,r10
8000b652:	13 0a       	ld.w	r10,r9++
8000b654:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b658:	16 39       	cp.w	r9,r11
8000b65a:	cf 73       	brcs	8000b648 <__lshift+0x54>
8000b65c:	91 0a       	st.w	r8[0x0],r10
8000b65e:	58 0a       	cp.w	r10,0
8000b660:	c0 70       	breq	8000b66e <__lshift+0x7a>
8000b662:	2f f6       	sub	r6,-1
8000b664:	c0 58       	rjmp	8000b66e <__lshift+0x7a>
8000b666:	13 0a       	ld.w	r10,r9++
8000b668:	10 aa       	st.w	r8++,r10
8000b66a:	16 39       	cp.w	r9,r11
8000b66c:	cf d3       	brcs	8000b666 <__lshift+0x72>
8000b66e:	08 9c       	mov	r12,r4
8000b670:	20 16       	sub	r6,1
8000b672:	0e 9b       	mov	r11,r7
8000b674:	8b 46       	st.w	r5[0x10],r6
8000b676:	cb 5e       	rcall	8000b3e0 <_Bfree>
8000b678:	0a 9c       	mov	r12,r5
8000b67a:	d8 32       	popm	r0-r7,pc

8000b67c <__multiply>:
8000b67c:	d4 31       	pushm	r0-r7,lr
8000b67e:	20 2d       	sub	sp,8
8000b680:	76 49       	ld.w	r9,r11[0x10]
8000b682:	74 48       	ld.w	r8,r10[0x10]
8000b684:	16 96       	mov	r6,r11
8000b686:	14 95       	mov	r5,r10
8000b688:	10 39       	cp.w	r9,r8
8000b68a:	ec 08 17 50 	movlt	r8,r6
8000b68e:	ea 06 17 50 	movlt	r6,r5
8000b692:	f0 05 17 50 	movlt	r5,r8
8000b696:	6c 28       	ld.w	r8,r6[0x8]
8000b698:	76 43       	ld.w	r3,r11[0x10]
8000b69a:	74 42       	ld.w	r2,r10[0x10]
8000b69c:	76 1b       	ld.w	r11,r11[0x4]
8000b69e:	e4 03 00 07 	add	r7,r2,r3
8000b6a2:	10 37       	cp.w	r7,r8
8000b6a4:	f7 bb 09 ff 	subgt	r11,-1
8000b6a8:	cb 6e       	rcall	8000b414 <_Balloc>
8000b6aa:	ee c4 ff fb 	sub	r4,r7,-5
8000b6ae:	f8 c9 ff ec 	sub	r9,r12,-20
8000b6b2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b6b6:	30 0a       	mov	r10,0
8000b6b8:	12 98       	mov	r8,r9
8000b6ba:	c0 28       	rjmp	8000b6be <__multiply+0x42>
8000b6bc:	10 aa       	st.w	r8++,r10
8000b6be:	08 38       	cp.w	r8,r4
8000b6c0:	cf e3       	brcs	8000b6bc <__multiply+0x40>
8000b6c2:	2f b3       	sub	r3,-5
8000b6c4:	2f b2       	sub	r2,-5
8000b6c6:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b6ca:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b6ce:	ec cb ff ec 	sub	r11,r6,-20
8000b6d2:	50 12       	stdsp	sp[0x4],r2
8000b6d4:	ea ca ff ec 	sub	r10,r5,-20
8000b6d8:	c4 48       	rjmp	8000b760 <__multiply+0xe4>
8000b6da:	94 95       	ld.uh	r5,r10[0x2]
8000b6dc:	58 05       	cp.w	r5,0
8000b6de:	c2 00       	breq	8000b71e <__multiply+0xa2>
8000b6e0:	12 98       	mov	r8,r9
8000b6e2:	16 96       	mov	r6,r11
8000b6e4:	30 0e       	mov	lr,0
8000b6e6:	50 09       	stdsp	sp[0x0],r9
8000b6e8:	0d 02       	ld.w	r2,r6++
8000b6ea:	e4 00 16 10 	lsr	r0,r2,0x10
8000b6ee:	70 01       	ld.w	r1,r8[0x0]
8000b6f0:	70 09       	ld.w	r9,r8[0x0]
8000b6f2:	b1 81       	lsr	r1,0x10
8000b6f4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b6f8:	e0 05 03 41 	mac	r1,r0,r5
8000b6fc:	ab 32       	mul	r2,r5
8000b6fe:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b702:	00 02       	add	r2,r0
8000b704:	e4 0e 00 0e 	add	lr,r2,lr
8000b708:	b0 1e       	st.h	r8[0x2],lr
8000b70a:	b1 8e       	lsr	lr,0x10
8000b70c:	1c 01       	add	r1,lr
8000b70e:	b0 01       	st.h	r8[0x0],r1
8000b710:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b714:	2f c8       	sub	r8,-4
8000b716:	06 36       	cp.w	r6,r3
8000b718:	ce 83       	brcs	8000b6e8 <__multiply+0x6c>
8000b71a:	40 09       	lddsp	r9,sp[0x0]
8000b71c:	91 0e       	st.w	r8[0x0],lr
8000b71e:	94 86       	ld.uh	r6,r10[0x0]
8000b720:	58 06       	cp.w	r6,0
8000b722:	c1 d0       	breq	8000b75c <__multiply+0xe0>
8000b724:	72 02       	ld.w	r2,r9[0x0]
8000b726:	12 98       	mov	r8,r9
8000b728:	16 9e       	mov	lr,r11
8000b72a:	30 05       	mov	r5,0
8000b72c:	b0 12       	st.h	r8[0x2],r2
8000b72e:	1d 01       	ld.w	r1,lr++
8000b730:	90 82       	ld.uh	r2,r8[0x0]
8000b732:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b736:	ad 30       	mul	r0,r6
8000b738:	e0 02 00 02 	add	r2,r0,r2
8000b73c:	e4 05 00 05 	add	r5,r2,r5
8000b740:	b0 05       	st.h	r8[0x0],r5
8000b742:	b1 85       	lsr	r5,0x10
8000b744:	b1 81       	lsr	r1,0x10
8000b746:	2f c8       	sub	r8,-4
8000b748:	ad 31       	mul	r1,r6
8000b74a:	90 92       	ld.uh	r2,r8[0x2]
8000b74c:	e2 02 00 02 	add	r2,r1,r2
8000b750:	0a 02       	add	r2,r5
8000b752:	e4 05 16 10 	lsr	r5,r2,0x10
8000b756:	06 3e       	cp.w	lr,r3
8000b758:	ce a3       	brcs	8000b72c <__multiply+0xb0>
8000b75a:	91 02       	st.w	r8[0x0],r2
8000b75c:	2f ca       	sub	r10,-4
8000b75e:	2f c9       	sub	r9,-4
8000b760:	40 18       	lddsp	r8,sp[0x4]
8000b762:	10 3a       	cp.w	r10,r8
8000b764:	cb b3       	brcs	8000b6da <__multiply+0x5e>
8000b766:	c0 28       	rjmp	8000b76a <__multiply+0xee>
8000b768:	20 17       	sub	r7,1
8000b76a:	58 07       	cp.w	r7,0
8000b76c:	e0 8a 00 05 	brle	8000b776 <__multiply+0xfa>
8000b770:	09 48       	ld.w	r8,--r4
8000b772:	58 08       	cp.w	r8,0
8000b774:	cf a0       	breq	8000b768 <__multiply+0xec>
8000b776:	99 47       	st.w	r12[0x10],r7
8000b778:	2f ed       	sub	sp,-8
8000b77a:	d8 32       	popm	r0-r7,pc

8000b77c <__i2b>:
8000b77c:	d4 21       	pushm	r4-r7,lr
8000b77e:	16 97       	mov	r7,r11
8000b780:	30 1b       	mov	r11,1
8000b782:	c4 9e       	rcall	8000b414 <_Balloc>
8000b784:	30 19       	mov	r9,1
8000b786:	99 57       	st.w	r12[0x14],r7
8000b788:	99 49       	st.w	r12[0x10],r9
8000b78a:	d8 22       	popm	r4-r7,pc

8000b78c <__multadd>:
8000b78c:	d4 31       	pushm	r0-r7,lr
8000b78e:	30 08       	mov	r8,0
8000b790:	12 95       	mov	r5,r9
8000b792:	16 97       	mov	r7,r11
8000b794:	18 96       	mov	r6,r12
8000b796:	76 44       	ld.w	r4,r11[0x10]
8000b798:	f6 c9 ff ec 	sub	r9,r11,-20
8000b79c:	72 0b       	ld.w	r11,r9[0x0]
8000b79e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b7a2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b7a6:	f4 0c 02 4c 	mul	r12,r10,r12
8000b7aa:	f4 0b 03 45 	mac	r5,r10,r11
8000b7ae:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b7b2:	b1 85       	lsr	r5,0x10
8000b7b4:	18 05       	add	r5,r12
8000b7b6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b7ba:	f8 0b 00 0b 	add	r11,r12,r11
8000b7be:	12 ab       	st.w	r9++,r11
8000b7c0:	2f f8       	sub	r8,-1
8000b7c2:	b1 85       	lsr	r5,0x10
8000b7c4:	08 38       	cp.w	r8,r4
8000b7c6:	ce b5       	brlt	8000b79c <__multadd+0x10>
8000b7c8:	58 05       	cp.w	r5,0
8000b7ca:	c1 c0       	breq	8000b802 <__multadd+0x76>
8000b7cc:	6e 28       	ld.w	r8,r7[0x8]
8000b7ce:	10 34       	cp.w	r4,r8
8000b7d0:	c1 35       	brlt	8000b7f6 <__multadd+0x6a>
8000b7d2:	6e 1b       	ld.w	r11,r7[0x4]
8000b7d4:	0c 9c       	mov	r12,r6
8000b7d6:	2f fb       	sub	r11,-1
8000b7d8:	c1 ee       	rcall	8000b414 <_Balloc>
8000b7da:	6e 4a       	ld.w	r10,r7[0x10]
8000b7dc:	ee cb ff f4 	sub	r11,r7,-12
8000b7e0:	18 93       	mov	r3,r12
8000b7e2:	2f ea       	sub	r10,-2
8000b7e4:	2f 4c       	sub	r12,-12
8000b7e6:	a3 6a       	lsl	r10,0x2
8000b7e8:	fe b0 de 71 	rcall	800074ca <memcpy>
8000b7ec:	0e 9b       	mov	r11,r7
8000b7ee:	0c 9c       	mov	r12,r6
8000b7f0:	fe b0 fd f8 	rcall	8000b3e0 <_Bfree>
8000b7f4:	06 97       	mov	r7,r3
8000b7f6:	e8 c8 ff ff 	sub	r8,r4,-1
8000b7fa:	2f b4       	sub	r4,-5
8000b7fc:	8f 48       	st.w	r7[0x10],r8
8000b7fe:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b802:	0e 9c       	mov	r12,r7
8000b804:	d8 32       	popm	r0-r7,pc
8000b806:	d7 03       	nop

8000b808 <__pow5mult>:
8000b808:	d4 31       	pushm	r0-r7,lr
8000b80a:	14 96       	mov	r6,r10
8000b80c:	18 97       	mov	r7,r12
8000b80e:	16 94       	mov	r4,r11
8000b810:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b814:	c0 90       	breq	8000b826 <__pow5mult+0x1e>
8000b816:	20 18       	sub	r8,1
8000b818:	fe c9 d5 70 	sub	r9,pc,-10896
8000b81c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b820:	30 09       	mov	r9,0
8000b822:	cb 5f       	rcall	8000b78c <__multadd>
8000b824:	18 94       	mov	r4,r12
8000b826:	a3 46       	asr	r6,0x2
8000b828:	c3 40       	breq	8000b890 <__pow5mult+0x88>
8000b82a:	6e 95       	ld.w	r5,r7[0x24]
8000b82c:	58 05       	cp.w	r5,0
8000b82e:	c0 91       	brne	8000b840 <__pow5mult+0x38>
8000b830:	31 0c       	mov	r12,16
8000b832:	fe b0 dc 15 	rcall	8000705c <malloc>
8000b836:	99 35       	st.w	r12[0xc],r5
8000b838:	8f 9c       	st.w	r7[0x24],r12
8000b83a:	99 15       	st.w	r12[0x4],r5
8000b83c:	99 25       	st.w	r12[0x8],r5
8000b83e:	99 05       	st.w	r12[0x0],r5
8000b840:	6e 93       	ld.w	r3,r7[0x24]
8000b842:	66 25       	ld.w	r5,r3[0x8]
8000b844:	58 05       	cp.w	r5,0
8000b846:	c0 c1       	brne	8000b85e <__pow5mult+0x56>
8000b848:	e0 6b 02 71 	mov	r11,625
8000b84c:	0e 9c       	mov	r12,r7
8000b84e:	c9 7f       	rcall	8000b77c <__i2b>
8000b850:	87 2c       	st.w	r3[0x8],r12
8000b852:	30 08       	mov	r8,0
8000b854:	18 95       	mov	r5,r12
8000b856:	99 08       	st.w	r12[0x0],r8
8000b858:	c0 38       	rjmp	8000b85e <__pow5mult+0x56>
8000b85a:	06 9c       	mov	r12,r3
8000b85c:	18 95       	mov	r5,r12
8000b85e:	ed b6 00 00 	bld	r6,0x0
8000b862:	c0 b1       	brne	8000b878 <__pow5mult+0x70>
8000b864:	08 9b       	mov	r11,r4
8000b866:	0a 9a       	mov	r10,r5
8000b868:	0e 9c       	mov	r12,r7
8000b86a:	c0 9f       	rcall	8000b67c <__multiply>
8000b86c:	08 9b       	mov	r11,r4
8000b86e:	18 93       	mov	r3,r12
8000b870:	0e 9c       	mov	r12,r7
8000b872:	06 94       	mov	r4,r3
8000b874:	fe b0 fd b6 	rcall	8000b3e0 <_Bfree>
8000b878:	a1 56       	asr	r6,0x1
8000b87a:	c0 b0       	breq	8000b890 <__pow5mult+0x88>
8000b87c:	6a 03       	ld.w	r3,r5[0x0]
8000b87e:	58 03       	cp.w	r3,0
8000b880:	ce d1       	brne	8000b85a <__pow5mult+0x52>
8000b882:	0a 9a       	mov	r10,r5
8000b884:	0a 9b       	mov	r11,r5
8000b886:	0e 9c       	mov	r12,r7
8000b888:	cf ae       	rcall	8000b67c <__multiply>
8000b88a:	8b 0c       	st.w	r5[0x0],r12
8000b88c:	99 03       	st.w	r12[0x0],r3
8000b88e:	ce 7b       	rjmp	8000b85c <__pow5mult+0x54>
8000b890:	08 9c       	mov	r12,r4
8000b892:	d8 32       	popm	r0-r7,pc

8000b894 <__isinfd>:
8000b894:	14 98       	mov	r8,r10
8000b896:	fc 19 7f f0 	movh	r9,0x7ff0
8000b89a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b89e:	f0 0b 11 00 	rsub	r11,r8,0
8000b8a2:	f7 e8 10 08 	or	r8,r11,r8
8000b8a6:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b8aa:	f2 08 01 08 	sub	r8,r9,r8
8000b8ae:	f0 0c 11 00 	rsub	r12,r8,0
8000b8b2:	f9 e8 10 08 	or	r8,r12,r8
8000b8b6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b8ba:	2f fc       	sub	r12,-1
8000b8bc:	5e fc       	retal	r12

8000b8be <__isnand>:
8000b8be:	14 98       	mov	r8,r10
8000b8c0:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b8c4:	f0 0c 11 00 	rsub	r12,r8,0
8000b8c8:	10 4c       	or	r12,r8
8000b8ca:	fc 18 7f f0 	movh	r8,0x7ff0
8000b8ce:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b8d2:	f0 0c 01 0c 	sub	r12,r8,r12
8000b8d6:	bf 9c       	lsr	r12,0x1f
8000b8d8:	5e fc       	retal	r12
8000b8da:	d7 03       	nop

8000b8dc <__sclose>:
8000b8dc:	d4 01       	pushm	lr
8000b8de:	96 7b       	ld.sh	r11,r11[0xe]
8000b8e0:	c8 2c       	rcall	8000b9e4 <_close_r>
8000b8e2:	d8 02       	popm	pc

8000b8e4 <__sseek>:
8000b8e4:	d4 21       	pushm	r4-r7,lr
8000b8e6:	16 97       	mov	r7,r11
8000b8e8:	96 7b       	ld.sh	r11,r11[0xe]
8000b8ea:	c0 3d       	rcall	8000baf0 <_lseek_r>
8000b8ec:	8e 68       	ld.sh	r8,r7[0xc]
8000b8ee:	10 99       	mov	r9,r8
8000b8f0:	ad c8       	cbr	r8,0xc
8000b8f2:	ad a9       	sbr	r9,0xc
8000b8f4:	5b fc       	cp.w	r12,-1
8000b8f6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b8fa:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b8fe:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b902:	d8 22       	popm	r4-r7,pc

8000b904 <__swrite>:
8000b904:	d4 21       	pushm	r4-r7,lr
8000b906:	96 68       	ld.sh	r8,r11[0xc]
8000b908:	16 97       	mov	r7,r11
8000b90a:	14 95       	mov	r5,r10
8000b90c:	12 94       	mov	r4,r9
8000b90e:	e2 18 01 00 	andl	r8,0x100,COH
8000b912:	18 96       	mov	r6,r12
8000b914:	c0 50       	breq	8000b91e <__swrite+0x1a>
8000b916:	30 29       	mov	r9,2
8000b918:	30 0a       	mov	r10,0
8000b91a:	96 7b       	ld.sh	r11,r11[0xe]
8000b91c:	ce ac       	rcall	8000baf0 <_lseek_r>
8000b91e:	8e 68       	ld.sh	r8,r7[0xc]
8000b920:	ad c8       	cbr	r8,0xc
8000b922:	08 99       	mov	r9,r4
8000b924:	0a 9a       	mov	r10,r5
8000b926:	8e 7b       	ld.sh	r11,r7[0xe]
8000b928:	0c 9c       	mov	r12,r6
8000b92a:	ae 68       	st.h	r7[0xc],r8
8000b92c:	c1 cc       	rcall	8000b964 <_write_r>
8000b92e:	d8 22       	popm	r4-r7,pc

8000b930 <__sread>:
8000b930:	d4 21       	pushm	r4-r7,lr
8000b932:	16 97       	mov	r7,r11
8000b934:	96 7b       	ld.sh	r11,r11[0xe]
8000b936:	cf 1c       	rcall	8000bb18 <_read_r>
8000b938:	c0 65       	brlt	8000b944 <__sread+0x14>
8000b93a:	6f 58       	ld.w	r8,r7[0x54]
8000b93c:	18 08       	add	r8,r12
8000b93e:	ef 48 00 54 	st.w	r7[84],r8
8000b942:	d8 22       	popm	r4-r7,pc
8000b944:	8e 68       	ld.sh	r8,r7[0xc]
8000b946:	ad c8       	cbr	r8,0xc
8000b948:	ae 68       	st.h	r7[0xc],r8
8000b94a:	d8 22       	popm	r4-r7,pc

8000b94c <strlen>:
8000b94c:	30 09       	mov	r9,0
8000b94e:	18 98       	mov	r8,r12
8000b950:	c0 28       	rjmp	8000b954 <strlen+0x8>
8000b952:	2f f8       	sub	r8,-1
8000b954:	11 8a       	ld.ub	r10,r8[0x0]
8000b956:	f2 0a 18 00 	cp.b	r10,r9
8000b95a:	cf c1       	brne	8000b952 <strlen+0x6>
8000b95c:	f0 0c 01 0c 	sub	r12,r8,r12
8000b960:	5e fc       	retal	r12
8000b962:	d7 03       	nop

8000b964 <_write_r>:
8000b964:	d4 21       	pushm	r4-r7,lr
8000b966:	16 98       	mov	r8,r11
8000b968:	18 97       	mov	r7,r12
8000b96a:	10 9c       	mov	r12,r8
8000b96c:	30 08       	mov	r8,0
8000b96e:	14 9b       	mov	r11,r10
8000b970:	e0 66 63 94 	mov	r6,25492
8000b974:	12 9a       	mov	r10,r9
8000b976:	8d 08       	st.w	r6[0x0],r8
8000b978:	fe b0 d1 a4 	rcall	80005cc0 <_write>
8000b97c:	5b fc       	cp.w	r12,-1
8000b97e:	c0 51       	brne	8000b988 <_write_r+0x24>
8000b980:	6c 08       	ld.w	r8,r6[0x0]
8000b982:	58 08       	cp.w	r8,0
8000b984:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b988:	d8 22       	popm	r4-r7,pc
8000b98a:	d7 03       	nop

8000b98c <_calloc_r>:
8000b98c:	d4 21       	pushm	r4-r7,lr
8000b98e:	f4 0b 02 4b 	mul	r11,r10,r11
8000b992:	fe b0 db 6d 	rcall	8000706c <_malloc_r>
8000b996:	18 97       	mov	r7,r12
8000b998:	c2 30       	breq	8000b9de <_calloc_r+0x52>
8000b99a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b99e:	e0 1a ff fc 	andl	r10,0xfffc
8000b9a2:	20 4a       	sub	r10,4
8000b9a4:	e0 4a 00 24 	cp.w	r10,36
8000b9a8:	e0 8b 00 18 	brhi	8000b9d8 <_calloc_r+0x4c>
8000b9ac:	18 98       	mov	r8,r12
8000b9ae:	59 3a       	cp.w	r10,19
8000b9b0:	e0 88 00 0f 	brls	8000b9ce <_calloc_r+0x42>
8000b9b4:	30 09       	mov	r9,0
8000b9b6:	10 a9       	st.w	r8++,r9
8000b9b8:	10 a9       	st.w	r8++,r9
8000b9ba:	59 ba       	cp.w	r10,27
8000b9bc:	e0 88 00 09 	brls	8000b9ce <_calloc_r+0x42>
8000b9c0:	10 a9       	st.w	r8++,r9
8000b9c2:	10 a9       	st.w	r8++,r9
8000b9c4:	e0 4a 00 24 	cp.w	r10,36
8000b9c8:	c0 31       	brne	8000b9ce <_calloc_r+0x42>
8000b9ca:	10 a9       	st.w	r8++,r9
8000b9cc:	10 a9       	st.w	r8++,r9
8000b9ce:	30 09       	mov	r9,0
8000b9d0:	10 a9       	st.w	r8++,r9
8000b9d2:	91 19       	st.w	r8[0x4],r9
8000b9d4:	91 09       	st.w	r8[0x0],r9
8000b9d6:	c0 48       	rjmp	8000b9de <_calloc_r+0x52>
8000b9d8:	30 0b       	mov	r11,0
8000b9da:	fe b0 de 1c 	rcall	80007612 <memset>
8000b9de:	0e 9c       	mov	r12,r7
8000b9e0:	d8 22       	popm	r4-r7,pc
8000b9e2:	d7 03       	nop

8000b9e4 <_close_r>:
8000b9e4:	d4 21       	pushm	r4-r7,lr
8000b9e6:	30 08       	mov	r8,0
8000b9e8:	18 97       	mov	r7,r12
8000b9ea:	e0 66 63 94 	mov	r6,25492
8000b9ee:	16 9c       	mov	r12,r11
8000b9f0:	8d 08       	st.w	r6[0x0],r8
8000b9f2:	fe b0 df b5 	rcall	8000795c <_close>
8000b9f6:	5b fc       	cp.w	r12,-1
8000b9f8:	c0 51       	brne	8000ba02 <_close_r+0x1e>
8000b9fa:	6c 08       	ld.w	r8,r6[0x0]
8000b9fc:	58 08       	cp.w	r8,0
8000b9fe:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ba02:	d8 22       	popm	r4-r7,pc

8000ba04 <_fclose_r>:
8000ba04:	d4 21       	pushm	r4-r7,lr
8000ba06:	18 96       	mov	r6,r12
8000ba08:	16 97       	mov	r7,r11
8000ba0a:	58 0b       	cp.w	r11,0
8000ba0c:	c0 31       	brne	8000ba12 <_fclose_r+0xe>
8000ba0e:	16 95       	mov	r5,r11
8000ba10:	c5 38       	rjmp	8000bab6 <_fclose_r+0xb2>
8000ba12:	fe b0 f8 a9 	rcall	8000ab64 <__sfp_lock_acquire>
8000ba16:	58 06       	cp.w	r6,0
8000ba18:	c0 70       	breq	8000ba26 <_fclose_r+0x22>
8000ba1a:	6c 68       	ld.w	r8,r6[0x18]
8000ba1c:	58 08       	cp.w	r8,0
8000ba1e:	c0 41       	brne	8000ba26 <_fclose_r+0x22>
8000ba20:	0c 9c       	mov	r12,r6
8000ba22:	fe b0 f8 f3 	rcall	8000ac08 <__sinit>
8000ba26:	fe c8 d8 22 	sub	r8,pc,-10206
8000ba2a:	10 37       	cp.w	r7,r8
8000ba2c:	c0 31       	brne	8000ba32 <_fclose_r+0x2e>
8000ba2e:	6c 07       	ld.w	r7,r6[0x0]
8000ba30:	c0 c8       	rjmp	8000ba48 <_fclose_r+0x44>
8000ba32:	fe c8 d8 0e 	sub	r8,pc,-10226
8000ba36:	10 37       	cp.w	r7,r8
8000ba38:	c0 31       	brne	8000ba3e <_fclose_r+0x3a>
8000ba3a:	6c 17       	ld.w	r7,r6[0x4]
8000ba3c:	c0 68       	rjmp	8000ba48 <_fclose_r+0x44>
8000ba3e:	fe c8 d7 fa 	sub	r8,pc,-10246
8000ba42:	10 37       	cp.w	r7,r8
8000ba44:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ba48:	8e 69       	ld.sh	r9,r7[0xc]
8000ba4a:	30 08       	mov	r8,0
8000ba4c:	f0 09 19 00 	cp.h	r9,r8
8000ba50:	c0 51       	brne	8000ba5a <_fclose_r+0x56>
8000ba52:	fe b0 f8 8a 	rcall	8000ab66 <__sfp_lock_release>
8000ba56:	30 05       	mov	r5,0
8000ba58:	c2 f8       	rjmp	8000bab6 <_fclose_r+0xb2>
8000ba5a:	0e 9b       	mov	r11,r7
8000ba5c:	0c 9c       	mov	r12,r6
8000ba5e:	fe b0 f7 fd 	rcall	8000aa58 <_fflush_r>
8000ba62:	6e c8       	ld.w	r8,r7[0x30]
8000ba64:	18 95       	mov	r5,r12
8000ba66:	58 08       	cp.w	r8,0
8000ba68:	c0 60       	breq	8000ba74 <_fclose_r+0x70>
8000ba6a:	6e 8b       	ld.w	r11,r7[0x20]
8000ba6c:	0c 9c       	mov	r12,r6
8000ba6e:	5d 18       	icall	r8
8000ba70:	f9 b5 05 ff 	movlt	r5,-1
8000ba74:	8e 68       	ld.sh	r8,r7[0xc]
8000ba76:	ed b8 00 07 	bld	r8,0x7
8000ba7a:	c0 51       	brne	8000ba84 <_fclose_r+0x80>
8000ba7c:	6e 4b       	ld.w	r11,r7[0x10]
8000ba7e:	0c 9c       	mov	r12,r6
8000ba80:	fe b0 f9 5e 	rcall	8000ad3c <_free_r>
8000ba84:	6e db       	ld.w	r11,r7[0x34]
8000ba86:	58 0b       	cp.w	r11,0
8000ba88:	c0 a0       	breq	8000ba9c <_fclose_r+0x98>
8000ba8a:	ee c8 ff bc 	sub	r8,r7,-68
8000ba8e:	10 3b       	cp.w	r11,r8
8000ba90:	c0 40       	breq	8000ba98 <_fclose_r+0x94>
8000ba92:	0c 9c       	mov	r12,r6
8000ba94:	fe b0 f9 54 	rcall	8000ad3c <_free_r>
8000ba98:	30 08       	mov	r8,0
8000ba9a:	8f d8       	st.w	r7[0x34],r8
8000ba9c:	6f 2b       	ld.w	r11,r7[0x48]
8000ba9e:	58 0b       	cp.w	r11,0
8000baa0:	c0 70       	breq	8000baae <_fclose_r+0xaa>
8000baa2:	0c 9c       	mov	r12,r6
8000baa4:	fe b0 f9 4c 	rcall	8000ad3c <_free_r>
8000baa8:	30 08       	mov	r8,0
8000baaa:	ef 48 00 48 	st.w	r7[72],r8
8000baae:	30 08       	mov	r8,0
8000bab0:	ae 68       	st.h	r7[0xc],r8
8000bab2:	fe b0 f8 5a 	rcall	8000ab66 <__sfp_lock_release>
8000bab6:	0a 9c       	mov	r12,r5
8000bab8:	d8 22       	popm	r4-r7,pc
8000baba:	d7 03       	nop

8000babc <fclose>:
8000babc:	d4 01       	pushm	lr
8000babe:	e0 68 0a 38 	mov	r8,2616
8000bac2:	18 9b       	mov	r11,r12
8000bac4:	70 0c       	ld.w	r12,r8[0x0]
8000bac6:	c9 ff       	rcall	8000ba04 <_fclose_r>
8000bac8:	d8 02       	popm	pc
8000baca:	d7 03       	nop

8000bacc <_fstat_r>:
8000bacc:	d4 21       	pushm	r4-r7,lr
8000bace:	16 98       	mov	r8,r11
8000bad0:	18 97       	mov	r7,r12
8000bad2:	10 9c       	mov	r12,r8
8000bad4:	30 08       	mov	r8,0
8000bad6:	e0 66 63 94 	mov	r6,25492
8000bada:	14 9b       	mov	r11,r10
8000badc:	8d 08       	st.w	r6[0x0],r8
8000bade:	fe b0 df 67 	rcall	800079ac <_fstat>
8000bae2:	5b fc       	cp.w	r12,-1
8000bae4:	c0 51       	brne	8000baee <_fstat_r+0x22>
8000bae6:	6c 08       	ld.w	r8,r6[0x0]
8000bae8:	58 08       	cp.w	r8,0
8000baea:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000baee:	d8 22       	popm	r4-r7,pc

8000baf0 <_lseek_r>:
8000baf0:	d4 21       	pushm	r4-r7,lr
8000baf2:	16 98       	mov	r8,r11
8000baf4:	18 97       	mov	r7,r12
8000baf6:	10 9c       	mov	r12,r8
8000baf8:	30 08       	mov	r8,0
8000bafa:	14 9b       	mov	r11,r10
8000bafc:	e0 66 63 94 	mov	r6,25492
8000bb00:	12 9a       	mov	r10,r9
8000bb02:	8d 08       	st.w	r6[0x0],r8
8000bb04:	fe b0 df 36 	rcall	80007970 <_lseek>
8000bb08:	5b fc       	cp.w	r12,-1
8000bb0a:	c0 51       	brne	8000bb14 <_lseek_r+0x24>
8000bb0c:	6c 08       	ld.w	r8,r6[0x0]
8000bb0e:	58 08       	cp.w	r8,0
8000bb10:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bb14:	d8 22       	popm	r4-r7,pc
8000bb16:	d7 03       	nop

8000bb18 <_read_r>:
8000bb18:	d4 21       	pushm	r4-r7,lr
8000bb1a:	16 98       	mov	r8,r11
8000bb1c:	18 97       	mov	r7,r12
8000bb1e:	10 9c       	mov	r12,r8
8000bb20:	30 08       	mov	r8,0
8000bb22:	14 9b       	mov	r11,r10
8000bb24:	e0 66 63 94 	mov	r6,25492
8000bb28:	12 9a       	mov	r10,r9
8000bb2a:	8d 08       	st.w	r6[0x0],r8
8000bb2c:	fe b0 d0 aa 	rcall	80005c80 <_read>
8000bb30:	5b fc       	cp.w	r12,-1
8000bb32:	c0 51       	brne	8000bb3c <_read_r+0x24>
8000bb34:	6c 08       	ld.w	r8,r6[0x0]
8000bb36:	58 08       	cp.w	r8,0
8000bb38:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bb3c:	d8 22       	popm	r4-r7,pc
8000bb3e:	d7 03       	nop

8000bb40 <__avr32_f64_mul>:
8000bb40:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bb44:	e0 80 00 dc 	breq	8000bcfc <__avr32_f64_mul_op1_zero>
8000bb48:	d4 21       	pushm	r4-r7,lr
8000bb4a:	f7 e9 20 0e 	eor	lr,r11,r9
8000bb4e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bb52:	30 15       	mov	r5,1
8000bb54:	c4 30       	breq	8000bbda <__avr32_f64_mul_op1_subnormal>
8000bb56:	ab 6b       	lsl	r11,0xa
8000bb58:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bb5c:	ab 6a       	lsl	r10,0xa
8000bb5e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bb62:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bb66:	c5 c0       	breq	8000bc1e <__avr32_f64_mul_op2_subnormal>
8000bb68:	a1 78       	lsl	r8,0x1
8000bb6a:	5c f9       	rol	r9
8000bb6c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bb70:	e0 47 07 ff 	cp.w	r7,2047
8000bb74:	c7 70       	breq	8000bc62 <__avr32_f64_mul_op_nan_or_inf>
8000bb76:	e0 46 07 ff 	cp.w	r6,2047
8000bb7a:	c7 40       	breq	8000bc62 <__avr32_f64_mul_op_nan_or_inf>
8000bb7c:	ee 06 00 0c 	add	r12,r7,r6
8000bb80:	e0 2c 03 fe 	sub	r12,1022
8000bb84:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bb88:	f4 09 07 44 	macu.d	r4,r10,r9
8000bb8c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bb90:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bb94:	08 07       	add	r7,r4
8000bb96:	f4 05 00 4a 	adc	r10,r10,r5
8000bb9a:	5c 0b       	acr	r11
8000bb9c:	ed bb 00 14 	bld	r11,0x14
8000bba0:	c0 50       	breq	8000bbaa <__avr32_f64_mul+0x6a>
8000bba2:	a1 77       	lsl	r7,0x1
8000bba4:	5c fa       	rol	r10
8000bba6:	5c fb       	rol	r11
8000bba8:	20 1c       	sub	r12,1
8000bbaa:	58 0c       	cp.w	r12,0
8000bbac:	e0 8a 00 6f 	brle	8000bc8a <__avr32_f64_mul_res_subnormal>
8000bbb0:	e0 4c 07 ff 	cp.w	r12,2047
8000bbb4:	e0 84 00 9c 	brge	8000bcec <__avr32_f64_mul_res_inf>
8000bbb8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bbbc:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bbc0:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bbc4:	ee 17 80 00 	eorh	r7,0x8000
8000bbc8:	f1 b7 04 20 	satu	r7,0x1
8000bbcc:	0e 0a       	add	r10,r7
8000bbce:	5c 0b       	acr	r11
8000bbd0:	ed be 00 1f 	bld	lr,0x1f
8000bbd4:	ef bb 00 1f 	bst	r11,0x1f
8000bbd8:	d8 22       	popm	r4-r7,pc

8000bbda <__avr32_f64_mul_op1_subnormal>:
8000bbda:	e4 1b 00 0f 	andh	r11,0xf
8000bbde:	f4 0c 12 00 	clz	r12,r10
8000bbe2:	f6 06 12 00 	clz	r6,r11
8000bbe6:	f7 bc 03 e1 	sublo	r12,-31
8000bbea:	f8 06 17 30 	movlo	r6,r12
8000bbee:	f7 b6 02 01 	subhs	r6,1
8000bbf2:	e0 46 00 20 	cp.w	r6,32
8000bbf6:	c0 d4       	brge	8000bc10 <__avr32_f64_mul_op1_subnormal+0x36>
8000bbf8:	ec 0c 11 20 	rsub	r12,r6,32
8000bbfc:	f6 06 09 4b 	lsl	r11,r11,r6
8000bc00:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bc04:	18 4b       	or	r11,r12
8000bc06:	f4 06 09 4a 	lsl	r10,r10,r6
8000bc0a:	20 b6       	sub	r6,11
8000bc0c:	0c 17       	sub	r7,r6
8000bc0e:	ca ab       	rjmp	8000bb62 <__avr32_f64_mul+0x22>
8000bc10:	f4 06 09 4b 	lsl	r11,r10,r6
8000bc14:	c6 40       	breq	8000bcdc <__avr32_f64_mul_res_zero>
8000bc16:	30 0a       	mov	r10,0
8000bc18:	20 b6       	sub	r6,11
8000bc1a:	0c 17       	sub	r7,r6
8000bc1c:	ca 3b       	rjmp	8000bb62 <__avr32_f64_mul+0x22>

8000bc1e <__avr32_f64_mul_op2_subnormal>:
8000bc1e:	e4 19 00 0f 	andh	r9,0xf
8000bc22:	f0 0c 12 00 	clz	r12,r8
8000bc26:	f2 05 12 00 	clz	r5,r9
8000bc2a:	f7 bc 03 ea 	sublo	r12,-22
8000bc2e:	f8 05 17 30 	movlo	r5,r12
8000bc32:	f7 b5 02 0a 	subhs	r5,10
8000bc36:	e0 45 00 20 	cp.w	r5,32
8000bc3a:	c0 d4       	brge	8000bc54 <__avr32_f64_mul_op2_subnormal+0x36>
8000bc3c:	ea 0c 11 20 	rsub	r12,r5,32
8000bc40:	f2 05 09 49 	lsl	r9,r9,r5
8000bc44:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bc48:	18 49       	or	r9,r12
8000bc4a:	f0 05 09 48 	lsl	r8,r8,r5
8000bc4e:	20 25       	sub	r5,2
8000bc50:	0a 16       	sub	r6,r5
8000bc52:	c8 fb       	rjmp	8000bb70 <__avr32_f64_mul+0x30>
8000bc54:	f0 05 09 49 	lsl	r9,r8,r5
8000bc58:	c4 20       	breq	8000bcdc <__avr32_f64_mul_res_zero>
8000bc5a:	30 08       	mov	r8,0
8000bc5c:	20 25       	sub	r5,2
8000bc5e:	0a 16       	sub	r6,r5
8000bc60:	c8 8b       	rjmp	8000bb70 <__avr32_f64_mul+0x30>

8000bc62 <__avr32_f64_mul_op_nan_or_inf>:
8000bc62:	e4 19 00 0f 	andh	r9,0xf
8000bc66:	e4 1b 00 0f 	andh	r11,0xf
8000bc6a:	14 4b       	or	r11,r10
8000bc6c:	10 49       	or	r9,r8
8000bc6e:	e0 47 07 ff 	cp.w	r7,2047
8000bc72:	c0 91       	brne	8000bc84 <__avr32_f64_mul_op1_not_naninf>
8000bc74:	58 0b       	cp.w	r11,0
8000bc76:	c3 81       	brne	8000bce6 <__avr32_f64_mul_res_nan>
8000bc78:	e0 46 07 ff 	cp.w	r6,2047
8000bc7c:	c3 81       	brne	8000bcec <__avr32_f64_mul_res_inf>
8000bc7e:	58 09       	cp.w	r9,0
8000bc80:	c3 60       	breq	8000bcec <__avr32_f64_mul_res_inf>
8000bc82:	c3 28       	rjmp	8000bce6 <__avr32_f64_mul_res_nan>

8000bc84 <__avr32_f64_mul_op1_not_naninf>:
8000bc84:	58 09       	cp.w	r9,0
8000bc86:	c3 30       	breq	8000bcec <__avr32_f64_mul_res_inf>
8000bc88:	c2 f8       	rjmp	8000bce6 <__avr32_f64_mul_res_nan>

8000bc8a <__avr32_f64_mul_res_subnormal>:
8000bc8a:	5c 3c       	neg	r12
8000bc8c:	2f fc       	sub	r12,-1
8000bc8e:	f1 bc 04 c0 	satu	r12,0x6
8000bc92:	e0 4c 00 20 	cp.w	r12,32
8000bc96:	c1 14       	brge	8000bcb8 <__avr32_f64_mul_res_subnormal+0x2e>
8000bc98:	f8 08 11 20 	rsub	r8,r12,32
8000bc9c:	0e 46       	or	r6,r7
8000bc9e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bca2:	f4 08 09 49 	lsl	r9,r10,r8
8000bca6:	12 47       	or	r7,r9
8000bca8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bcac:	f6 08 09 49 	lsl	r9,r11,r8
8000bcb0:	12 4a       	or	r10,r9
8000bcb2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bcb6:	c8 3b       	rjmp	8000bbbc <__avr32_f64_mul+0x7c>
8000bcb8:	f8 08 11 20 	rsub	r8,r12,32
8000bcbc:	f9 b9 00 00 	moveq	r9,0
8000bcc0:	c0 30       	breq	8000bcc6 <__avr32_f64_mul_res_subnormal+0x3c>
8000bcc2:	f6 08 09 49 	lsl	r9,r11,r8
8000bcc6:	0e 46       	or	r6,r7
8000bcc8:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bccc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bcd0:	f3 ea 10 07 	or	r7,r9,r10
8000bcd4:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bcd8:	30 0b       	mov	r11,0
8000bcda:	c7 1b       	rjmp	8000bbbc <__avr32_f64_mul+0x7c>

8000bcdc <__avr32_f64_mul_res_zero>:
8000bcdc:	1c 9b       	mov	r11,lr
8000bcde:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bce2:	30 0a       	mov	r10,0
8000bce4:	d8 22       	popm	r4-r7,pc

8000bce6 <__avr32_f64_mul_res_nan>:
8000bce6:	3f fb       	mov	r11,-1
8000bce8:	3f fa       	mov	r10,-1
8000bcea:	d8 22       	popm	r4-r7,pc

8000bcec <__avr32_f64_mul_res_inf>:
8000bcec:	f0 6b 00 00 	mov	r11,-1048576
8000bcf0:	ed be 00 1f 	bld	lr,0x1f
8000bcf4:	ef bb 00 1f 	bst	r11,0x1f
8000bcf8:	30 0a       	mov	r10,0
8000bcfa:	d8 22       	popm	r4-r7,pc

8000bcfc <__avr32_f64_mul_op1_zero>:
8000bcfc:	f7 e9 20 0b 	eor	r11,r11,r9
8000bd00:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bd04:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bd08:	e0 4c 07 ff 	cp.w	r12,2047
8000bd0c:	5e 1c       	retne	r12
8000bd0e:	3f fa       	mov	r10,-1
8000bd10:	3f fb       	mov	r11,-1
8000bd12:	5e fc       	retal	r12

8000bd14 <__avr32_f64_sub_from_add>:
8000bd14:	ee 19 80 00 	eorh	r9,0x8000

8000bd18 <__avr32_f64_sub>:
8000bd18:	f7 e9 20 0c 	eor	r12,r11,r9
8000bd1c:	e0 86 00 ca 	brmi	8000beb0 <__avr32_f64_add_from_sub>
8000bd20:	eb cd 40 e0 	pushm	r5-r7,lr
8000bd24:	16 9c       	mov	r12,r11
8000bd26:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bd2a:	bf db       	cbr	r11,0x1f
8000bd2c:	bf d9       	cbr	r9,0x1f
8000bd2e:	10 3a       	cp.w	r10,r8
8000bd30:	f2 0b 13 00 	cpc	r11,r9
8000bd34:	c0 92       	brcc	8000bd46 <__avr32_f64_sub+0x2e>
8000bd36:	16 97       	mov	r7,r11
8000bd38:	12 9b       	mov	r11,r9
8000bd3a:	0e 99       	mov	r9,r7
8000bd3c:	14 97       	mov	r7,r10
8000bd3e:	10 9a       	mov	r10,r8
8000bd40:	0e 98       	mov	r8,r7
8000bd42:	ee 1c 80 00 	eorh	r12,0x8000
8000bd46:	f6 07 16 14 	lsr	r7,r11,0x14
8000bd4a:	ab 7b       	lsl	r11,0xb
8000bd4c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bd50:	ab 7a       	lsl	r10,0xb
8000bd52:	bf bb       	sbr	r11,0x1f
8000bd54:	f2 06 16 14 	lsr	r6,r9,0x14
8000bd58:	c4 40       	breq	8000bde0 <__avr32_f64_sub_opL_subnormal>
8000bd5a:	ab 79       	lsl	r9,0xb
8000bd5c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bd60:	ab 78       	lsl	r8,0xb
8000bd62:	bf b9       	sbr	r9,0x1f

8000bd64 <__avr32_f64_sub_opL_subnormal_done>:
8000bd64:	e0 47 07 ff 	cp.w	r7,2047
8000bd68:	c4 f0       	breq	8000be06 <__avr32_f64_sub_opH_nan_or_inf>
8000bd6a:	0e 26       	rsub	r6,r7
8000bd6c:	c1 20       	breq	8000bd90 <__avr32_f64_sub_shift_done>
8000bd6e:	ec 05 11 20 	rsub	r5,r6,32
8000bd72:	e0 46 00 20 	cp.w	r6,32
8000bd76:	c7 c2       	brcc	8000be6e <__avr32_f64_sub_longshift>
8000bd78:	f0 05 09 4e 	lsl	lr,r8,r5
8000bd7c:	f2 05 09 45 	lsl	r5,r9,r5
8000bd80:	f0 06 0a 48 	lsr	r8,r8,r6
8000bd84:	f2 06 0a 49 	lsr	r9,r9,r6
8000bd88:	0a 48       	or	r8,r5
8000bd8a:	58 0e       	cp.w	lr,0
8000bd8c:	5f 1e       	srne	lr
8000bd8e:	1c 48       	or	r8,lr

8000bd90 <__avr32_f64_sub_shift_done>:
8000bd90:	10 1a       	sub	r10,r8
8000bd92:	f6 09 01 4b 	sbc	r11,r11,r9
8000bd96:	f6 06 12 00 	clz	r6,r11
8000bd9a:	c0 e0       	breq	8000bdb6 <__avr32_f64_sub_longnormalize_done>
8000bd9c:	c7 83       	brcs	8000be8c <__avr32_f64_sub_longnormalize>
8000bd9e:	ec 0e 11 20 	rsub	lr,r6,32
8000bda2:	f6 06 09 4b 	lsl	r11,r11,r6
8000bda6:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bdaa:	1c 4b       	or	r11,lr
8000bdac:	f4 06 09 4a 	lsl	r10,r10,r6
8000bdb0:	0c 17       	sub	r7,r6
8000bdb2:	e0 8a 00 39 	brle	8000be24 <__avr32_f64_sub_subnormal_result>

8000bdb6 <__avr32_f64_sub_longnormalize_done>:
8000bdb6:	f4 09 15 15 	lsl	r9,r10,0x15
8000bdba:	ab 9a       	lsr	r10,0xb
8000bdbc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bdc0:	ab 9b       	lsr	r11,0xb
8000bdc2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bdc6:	18 4b       	or	r11,r12

8000bdc8 <__avr32_f64_sub_round>:
8000bdc8:	fc 17 80 00 	movh	r7,0x8000
8000bdcc:	ed ba 00 00 	bld	r10,0x0
8000bdd0:	f7 b7 01 ff 	subne	r7,-1
8000bdd4:	0e 39       	cp.w	r9,r7
8000bdd6:	5f 29       	srhs	r9
8000bdd8:	12 0a       	add	r10,r9
8000bdda:	5c 0b       	acr	r11
8000bddc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bde0 <__avr32_f64_sub_opL_subnormal>:
8000bde0:	ab 79       	lsl	r9,0xb
8000bde2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bde6:	ab 78       	lsl	r8,0xb
8000bde8:	f3 e8 10 0e 	or	lr,r9,r8
8000bdec:	f9 b6 01 01 	movne	r6,1
8000bdf0:	ee 0e 11 00 	rsub	lr,r7,0
8000bdf4:	f9 b7 00 01 	moveq	r7,1
8000bdf8:	ef bb 00 1f 	bst	r11,0x1f
8000bdfc:	f7 ea 10 0e 	or	lr,r11,r10
8000be00:	f9 b7 00 00 	moveq	r7,0
8000be04:	cb 0b       	rjmp	8000bd64 <__avr32_f64_sub_opL_subnormal_done>

8000be06 <__avr32_f64_sub_opH_nan_or_inf>:
8000be06:	bf db       	cbr	r11,0x1f
8000be08:	f7 ea 10 0e 	or	lr,r11,r10
8000be0c:	c0 81       	brne	8000be1c <__avr32_f64_sub_return_nan>
8000be0e:	e0 46 07 ff 	cp.w	r6,2047
8000be12:	c0 50       	breq	8000be1c <__avr32_f64_sub_return_nan>
8000be14:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000be18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000be1c <__avr32_f64_sub_return_nan>:
8000be1c:	3f fa       	mov	r10,-1
8000be1e:	3f fb       	mov	r11,-1
8000be20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000be24 <__avr32_f64_sub_subnormal_result>:
8000be24:	5c 37       	neg	r7
8000be26:	2f f7       	sub	r7,-1
8000be28:	f1 b7 04 c0 	satu	r7,0x6
8000be2c:	e0 47 00 20 	cp.w	r7,32
8000be30:	c1 14       	brge	8000be52 <__avr32_f64_sub_subnormal_result+0x2e>
8000be32:	ee 08 11 20 	rsub	r8,r7,32
8000be36:	f4 08 09 49 	lsl	r9,r10,r8
8000be3a:	5f 16       	srne	r6
8000be3c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000be40:	0c 4a       	or	r10,r6
8000be42:	f6 08 09 49 	lsl	r9,r11,r8
8000be46:	f5 e9 10 0a 	or	r10,r10,r9
8000be4a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000be4e:	30 07       	mov	r7,0
8000be50:	cb 3b       	rjmp	8000bdb6 <__avr32_f64_sub_longnormalize_done>
8000be52:	ee 08 11 40 	rsub	r8,r7,64
8000be56:	f6 08 09 49 	lsl	r9,r11,r8
8000be5a:	14 49       	or	r9,r10
8000be5c:	5f 16       	srne	r6
8000be5e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000be62:	0c 4a       	or	r10,r6
8000be64:	30 0b       	mov	r11,0
8000be66:	30 07       	mov	r7,0
8000be68:	ca 7b       	rjmp	8000bdb6 <__avr32_f64_sub_longnormalize_done>
8000be6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000be6e <__avr32_f64_sub_longshift>:
8000be6e:	f1 b6 04 c0 	satu	r6,0x6
8000be72:	f0 0e 17 00 	moveq	lr,r8
8000be76:	c0 40       	breq	8000be7e <__avr32_f64_sub_longshift+0x10>
8000be78:	f2 05 09 4e 	lsl	lr,r9,r5
8000be7c:	10 4e       	or	lr,r8
8000be7e:	f2 06 0a 48 	lsr	r8,r9,r6
8000be82:	30 09       	mov	r9,0
8000be84:	58 0e       	cp.w	lr,0
8000be86:	5f 1e       	srne	lr
8000be88:	1c 48       	or	r8,lr
8000be8a:	c8 3b       	rjmp	8000bd90 <__avr32_f64_sub_shift_done>

8000be8c <__avr32_f64_sub_longnormalize>:
8000be8c:	f4 06 12 00 	clz	r6,r10
8000be90:	f9 b7 03 00 	movlo	r7,0
8000be94:	f9 b6 03 00 	movlo	r6,0
8000be98:	f9 bc 03 00 	movlo	r12,0
8000be9c:	f7 b6 02 e0 	subhs	r6,-32
8000bea0:	f4 06 09 4b 	lsl	r11,r10,r6
8000bea4:	30 0a       	mov	r10,0
8000bea6:	0c 17       	sub	r7,r6
8000bea8:	fe 9a ff be 	brle	8000be24 <__avr32_f64_sub_subnormal_result>
8000beac:	c8 5b       	rjmp	8000bdb6 <__avr32_f64_sub_longnormalize_done>
8000beae:	d7 03       	nop

8000beb0 <__avr32_f64_add_from_sub>:
8000beb0:	ee 19 80 00 	eorh	r9,0x8000

8000beb4 <__avr32_f64_add>:
8000beb4:	f7 e9 20 0c 	eor	r12,r11,r9
8000beb8:	fe 96 ff 2e 	brmi	8000bd14 <__avr32_f64_sub_from_add>
8000bebc:	eb cd 40 e0 	pushm	r5-r7,lr
8000bec0:	16 9c       	mov	r12,r11
8000bec2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bec6:	bf db       	cbr	r11,0x1f
8000bec8:	bf d9       	cbr	r9,0x1f
8000beca:	12 3b       	cp.w	r11,r9
8000becc:	c0 72       	brcc	8000beda <__avr32_f64_add+0x26>
8000bece:	16 97       	mov	r7,r11
8000bed0:	12 9b       	mov	r11,r9
8000bed2:	0e 99       	mov	r9,r7
8000bed4:	14 97       	mov	r7,r10
8000bed6:	10 9a       	mov	r10,r8
8000bed8:	0e 98       	mov	r8,r7
8000beda:	30 0e       	mov	lr,0
8000bedc:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bee0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bee4:	b5 ab       	sbr	r11,0x14
8000bee6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000beea:	c6 20       	breq	8000bfae <__avr32_f64_add_op2_subnormal>
8000beec:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bef0:	b5 a9       	sbr	r9,0x14
8000bef2:	e0 47 07 ff 	cp.w	r7,2047
8000bef6:	c2 80       	breq	8000bf46 <__avr32_f64_add_opH_nan_or_inf>
8000bef8:	0e 26       	rsub	r6,r7
8000befa:	c1 20       	breq	8000bf1e <__avr32_f64_add_shift_done>
8000befc:	e0 46 00 36 	cp.w	r6,54
8000bf00:	c1 52       	brcc	8000bf2a <__avr32_f64_add_res_of_done>
8000bf02:	ec 05 11 20 	rsub	r5,r6,32
8000bf06:	e0 46 00 20 	cp.w	r6,32
8000bf0a:	c3 52       	brcc	8000bf74 <__avr32_f64_add_longshift>
8000bf0c:	f0 05 09 4e 	lsl	lr,r8,r5
8000bf10:	f2 05 09 45 	lsl	r5,r9,r5
8000bf14:	f0 06 0a 48 	lsr	r8,r8,r6
8000bf18:	f2 06 0a 49 	lsr	r9,r9,r6
8000bf1c:	0a 48       	or	r8,r5

8000bf1e <__avr32_f64_add_shift_done>:
8000bf1e:	10 0a       	add	r10,r8
8000bf20:	f6 09 00 4b 	adc	r11,r11,r9
8000bf24:	ed bb 00 15 	bld	r11,0x15
8000bf28:	c3 40       	breq	8000bf90 <__avr32_f64_add_res_of>

8000bf2a <__avr32_f64_add_res_of_done>:
8000bf2a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bf2e:	18 4b       	or	r11,r12

8000bf30 <__avr32_f64_add_round>:
8000bf30:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bf34:	18 4e       	or	lr,r12
8000bf36:	ee 1e 80 00 	eorh	lr,0x8000
8000bf3a:	f1 be 04 20 	satu	lr,0x1
8000bf3e:	1c 0a       	add	r10,lr
8000bf40:	5c 0b       	acr	r11
8000bf42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf46 <__avr32_f64_add_opH_nan_or_inf>:
8000bf46:	b5 cb       	cbr	r11,0x14
8000bf48:	f7 ea 10 0e 	or	lr,r11,r10
8000bf4c:	c1 01       	brne	8000bf6c <__avr32_f64_add_return_nan>
8000bf4e:	e0 46 07 ff 	cp.w	r6,2047
8000bf52:	c0 30       	breq	8000bf58 <__avr32_f64_add_opL_nan_or_inf>
8000bf54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf58 <__avr32_f64_add_opL_nan_or_inf>:
8000bf58:	b5 c9       	cbr	r9,0x14
8000bf5a:	f3 e8 10 0e 	or	lr,r9,r8
8000bf5e:	c0 71       	brne	8000bf6c <__avr32_f64_add_return_nan>
8000bf60:	30 0a       	mov	r10,0
8000bf62:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bf66:	18 4b       	or	r11,r12
8000bf68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf6c <__avr32_f64_add_return_nan>:
8000bf6c:	3f fa       	mov	r10,-1
8000bf6e:	3f fb       	mov	r11,-1
8000bf70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf74 <__avr32_f64_add_longshift>:
8000bf74:	f1 b6 04 c0 	satu	r6,0x6
8000bf78:	f0 0e 17 00 	moveq	lr,r8
8000bf7c:	c0 60       	breq	8000bf88 <__avr32_f64_add_longshift+0x14>
8000bf7e:	f2 05 09 4e 	lsl	lr,r9,r5
8000bf82:	58 08       	cp.w	r8,0
8000bf84:	5f 18       	srne	r8
8000bf86:	10 4e       	or	lr,r8
8000bf88:	f2 06 0a 48 	lsr	r8,r9,r6
8000bf8c:	30 09       	mov	r9,0
8000bf8e:	cc 8b       	rjmp	8000bf1e <__avr32_f64_add_shift_done>

8000bf90 <__avr32_f64_add_res_of>:
8000bf90:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bf94:	a1 9b       	lsr	r11,0x1
8000bf96:	5d 0a       	ror	r10
8000bf98:	5d 0e       	ror	lr
8000bf9a:	2f f7       	sub	r7,-1
8000bf9c:	e0 47 07 ff 	cp.w	r7,2047
8000bfa0:	f9 ba 00 00 	moveq	r10,0
8000bfa4:	f9 bb 00 00 	moveq	r11,0
8000bfa8:	f9 be 00 00 	moveq	lr,0
8000bfac:	cb fb       	rjmp	8000bf2a <__avr32_f64_add_res_of_done>

8000bfae <__avr32_f64_add_op2_subnormal>:
8000bfae:	30 16       	mov	r6,1
8000bfb0:	58 07       	cp.w	r7,0
8000bfb2:	ca 01       	brne	8000bef2 <__avr32_f64_add+0x3e>
8000bfb4:	b5 cb       	cbr	r11,0x14
8000bfb6:	10 0a       	add	r10,r8
8000bfb8:	f6 09 00 4b 	adc	r11,r11,r9
8000bfbc:	18 4b       	or	r11,r12
8000bfbe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bfc2:	d7 03       	nop

8000bfc4 <__avr32_f64_to_u32>:
8000bfc4:	58 0b       	cp.w	r11,0
8000bfc6:	5e 6d       	retmi	0

8000bfc8 <__avr32_f64_to_s32>:
8000bfc8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bfcc:	b5 9c       	lsr	r12,0x15
8000bfce:	e0 2c 03 ff 	sub	r12,1023
8000bfd2:	5e 3d       	retlo	0
8000bfd4:	f8 0c 11 1f 	rsub	r12,r12,31
8000bfd8:	16 99       	mov	r9,r11
8000bfda:	ab 7b       	lsl	r11,0xb
8000bfdc:	bf bb       	sbr	r11,0x1f
8000bfde:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bfe2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bfe6:	a1 79       	lsl	r9,0x1
8000bfe8:	5e 2b       	reths	r11
8000bfea:	5c 3b       	neg	r11
8000bfec:	5e fb       	retal	r11

8000bfee <__avr32_u32_to_f64>:
8000bfee:	f8 cb 00 00 	sub	r11,r12,0
8000bff2:	30 0c       	mov	r12,0
8000bff4:	c0 38       	rjmp	8000bffa <__avr32_s32_to_f64+0x4>

8000bff6 <__avr32_s32_to_f64>:
8000bff6:	18 9b       	mov	r11,r12
8000bff8:	5c 4b       	abs	r11
8000bffa:	30 0a       	mov	r10,0
8000bffc:	5e 0b       	reteq	r11
8000bffe:	d4 01       	pushm	lr
8000c000:	e0 69 04 1e 	mov	r9,1054
8000c004:	f6 08 12 00 	clz	r8,r11
8000c008:	c1 70       	breq	8000c036 <__avr32_s32_to_f64+0x40>
8000c00a:	c0 c3       	brcs	8000c022 <__avr32_s32_to_f64+0x2c>
8000c00c:	f0 0e 11 20 	rsub	lr,r8,32
8000c010:	f6 08 09 4b 	lsl	r11,r11,r8
8000c014:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c018:	1c 4b       	or	r11,lr
8000c01a:	f4 08 09 4a 	lsl	r10,r10,r8
8000c01e:	10 19       	sub	r9,r8
8000c020:	c0 b8       	rjmp	8000c036 <__avr32_s32_to_f64+0x40>
8000c022:	f4 08 12 00 	clz	r8,r10
8000c026:	f9 b8 03 00 	movlo	r8,0
8000c02a:	f7 b8 02 e0 	subhs	r8,-32
8000c02e:	f4 08 09 4b 	lsl	r11,r10,r8
8000c032:	30 0a       	mov	r10,0
8000c034:	10 19       	sub	r9,r8
8000c036:	58 09       	cp.w	r9,0
8000c038:	e0 89 00 30 	brgt	8000c098 <__avr32_s32_to_f64+0xa2>
8000c03c:	5c 39       	neg	r9
8000c03e:	2f f9       	sub	r9,-1
8000c040:	e0 49 00 36 	cp.w	r9,54
8000c044:	c0 43       	brcs	8000c04c <__avr32_s32_to_f64+0x56>
8000c046:	30 0b       	mov	r11,0
8000c048:	30 0a       	mov	r10,0
8000c04a:	c2 68       	rjmp	8000c096 <__avr32_s32_to_f64+0xa0>
8000c04c:	2f 69       	sub	r9,-10
8000c04e:	f2 08 11 20 	rsub	r8,r9,32
8000c052:	e0 49 00 20 	cp.w	r9,32
8000c056:	c0 b2       	brcc	8000c06c <__avr32_s32_to_f64+0x76>
8000c058:	f4 08 09 4e 	lsl	lr,r10,r8
8000c05c:	f6 08 09 48 	lsl	r8,r11,r8
8000c060:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c064:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c068:	10 4b       	or	r11,r8
8000c06a:	c0 88       	rjmp	8000c07a <__avr32_s32_to_f64+0x84>
8000c06c:	f6 08 09 4e 	lsl	lr,r11,r8
8000c070:	14 4e       	or	lr,r10
8000c072:	16 9a       	mov	r10,r11
8000c074:	30 0b       	mov	r11,0
8000c076:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c07a:	ed ba 00 00 	bld	r10,0x0
8000c07e:	c0 92       	brcc	8000c090 <__avr32_s32_to_f64+0x9a>
8000c080:	1c 7e       	tst	lr,lr
8000c082:	c0 41       	brne	8000c08a <__avr32_s32_to_f64+0x94>
8000c084:	ed ba 00 01 	bld	r10,0x1
8000c088:	c0 42       	brcc	8000c090 <__avr32_s32_to_f64+0x9a>
8000c08a:	2f fa       	sub	r10,-1
8000c08c:	f7 bb 02 ff 	subhs	r11,-1
8000c090:	5c fc       	rol	r12
8000c092:	5d 0b       	ror	r11
8000c094:	5d 0a       	ror	r10
8000c096:	d8 02       	popm	pc
8000c098:	e0 68 03 ff 	mov	r8,1023
8000c09c:	ed ba 00 0b 	bld	r10,0xb
8000c0a0:	f7 b8 00 ff 	subeq	r8,-1
8000c0a4:	10 0a       	add	r10,r8
8000c0a6:	5c 0b       	acr	r11
8000c0a8:	f7 b9 03 fe 	sublo	r9,-2
8000c0ac:	e0 49 07 ff 	cp.w	r9,2047
8000c0b0:	c0 55       	brlt	8000c0ba <__avr32_s32_to_f64+0xc4>
8000c0b2:	30 0a       	mov	r10,0
8000c0b4:	fc 1b ff e0 	movh	r11,0xffe0
8000c0b8:	c0 c8       	rjmp	8000c0d0 <__floatsidf_return_op1>
8000c0ba:	ed bb 00 1f 	bld	r11,0x1f
8000c0be:	f7 b9 01 01 	subne	r9,1
8000c0c2:	ab 9a       	lsr	r10,0xb
8000c0c4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c0c8:	a1 7b       	lsl	r11,0x1
8000c0ca:	ab 9b       	lsr	r11,0xb
8000c0cc:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c0d0 <__floatsidf_return_op1>:
8000c0d0:	a1 7c       	lsl	r12,0x1
8000c0d2:	5d 0b       	ror	r11
8000c0d4:	d8 02       	popm	pc

8000c0d6 <__avr32_f64_cmp_eq>:
8000c0d6:	10 3a       	cp.w	r10,r8
8000c0d8:	f2 0b 13 00 	cpc	r11,r9
8000c0dc:	c0 80       	breq	8000c0ec <__avr32_f64_cmp_eq+0x16>
8000c0de:	a1 7b       	lsl	r11,0x1
8000c0e0:	a1 79       	lsl	r9,0x1
8000c0e2:	14 4b       	or	r11,r10
8000c0e4:	12 4b       	or	r11,r9
8000c0e6:	10 4b       	or	r11,r8
8000c0e8:	5e 0f       	reteq	1
8000c0ea:	5e fd       	retal	0
8000c0ec:	a1 7b       	lsl	r11,0x1
8000c0ee:	fc 1c ff e0 	movh	r12,0xffe0
8000c0f2:	58 0a       	cp.w	r10,0
8000c0f4:	f8 0b 13 00 	cpc	r11,r12
8000c0f8:	5e 8f       	retls	1
8000c0fa:	5e fd       	retal	0

8000c0fc <__avr32_f64_cmp_ge>:
8000c0fc:	1a de       	st.w	--sp,lr
8000c0fe:	1a d7       	st.w	--sp,r7
8000c100:	a1 7b       	lsl	r11,0x1
8000c102:	5f 3c       	srlo	r12
8000c104:	a1 79       	lsl	r9,0x1
8000c106:	5f 37       	srlo	r7
8000c108:	5c fc       	rol	r12
8000c10a:	fc 1e ff e0 	movh	lr,0xffe0
8000c10e:	58 0a       	cp.w	r10,0
8000c110:	fc 0b 13 00 	cpc	r11,lr
8000c114:	e0 8b 00 1d 	brhi	8000c14e <__avr32_f64_cmp_ge+0x52>
8000c118:	58 08       	cp.w	r8,0
8000c11a:	fc 09 13 00 	cpc	r9,lr
8000c11e:	e0 8b 00 18 	brhi	8000c14e <__avr32_f64_cmp_ge+0x52>
8000c122:	58 0b       	cp.w	r11,0
8000c124:	f5 ba 00 00 	subfeq	r10,0
8000c128:	c1 50       	breq	8000c152 <__avr32_f64_cmp_ge+0x56>
8000c12a:	1b 07       	ld.w	r7,sp++
8000c12c:	1b 0e       	ld.w	lr,sp++
8000c12e:	58 3c       	cp.w	r12,3
8000c130:	c0 a0       	breq	8000c144 <__avr32_f64_cmp_ge+0x48>
8000c132:	58 1c       	cp.w	r12,1
8000c134:	c0 33       	brcs	8000c13a <__avr32_f64_cmp_ge+0x3e>
8000c136:	5e 0f       	reteq	1
8000c138:	5e 1d       	retne	0
8000c13a:	10 3a       	cp.w	r10,r8
8000c13c:	f2 0b 13 00 	cpc	r11,r9
8000c140:	5e 2f       	reths	1
8000c142:	5e 3d       	retlo	0
8000c144:	14 38       	cp.w	r8,r10
8000c146:	f6 09 13 00 	cpc	r9,r11
8000c14a:	5e 2f       	reths	1
8000c14c:	5e 3d       	retlo	0
8000c14e:	1b 07       	ld.w	r7,sp++
8000c150:	d8 0a       	popm	pc,r12=0
8000c152:	58 17       	cp.w	r7,1
8000c154:	5f 0c       	sreq	r12
8000c156:	58 09       	cp.w	r9,0
8000c158:	f5 b8 00 00 	subfeq	r8,0
8000c15c:	1b 07       	ld.w	r7,sp++
8000c15e:	1b 0e       	ld.w	lr,sp++
8000c160:	5e 0f       	reteq	1
8000c162:	5e fc       	retal	r12

8000c164 <__avr32_f64_cmp_lt>:
8000c164:	1a de       	st.w	--sp,lr
8000c166:	1a d7       	st.w	--sp,r7
8000c168:	a1 7b       	lsl	r11,0x1
8000c16a:	5f 3c       	srlo	r12
8000c16c:	a1 79       	lsl	r9,0x1
8000c16e:	5f 37       	srlo	r7
8000c170:	5c fc       	rol	r12
8000c172:	fc 1e ff e0 	movh	lr,0xffe0
8000c176:	58 0a       	cp.w	r10,0
8000c178:	fc 0b 13 00 	cpc	r11,lr
8000c17c:	e0 8b 00 1d 	brhi	8000c1b6 <__avr32_f64_cmp_lt+0x52>
8000c180:	58 08       	cp.w	r8,0
8000c182:	fc 09 13 00 	cpc	r9,lr
8000c186:	e0 8b 00 18 	brhi	8000c1b6 <__avr32_f64_cmp_lt+0x52>
8000c18a:	58 0b       	cp.w	r11,0
8000c18c:	f5 ba 00 00 	subfeq	r10,0
8000c190:	c1 50       	breq	8000c1ba <__avr32_f64_cmp_lt+0x56>
8000c192:	1b 07       	ld.w	r7,sp++
8000c194:	1b 0e       	ld.w	lr,sp++
8000c196:	58 3c       	cp.w	r12,3
8000c198:	c0 a0       	breq	8000c1ac <__avr32_f64_cmp_lt+0x48>
8000c19a:	58 1c       	cp.w	r12,1
8000c19c:	c0 33       	brcs	8000c1a2 <__avr32_f64_cmp_lt+0x3e>
8000c19e:	5e 0d       	reteq	0
8000c1a0:	5e 1f       	retne	1
8000c1a2:	10 3a       	cp.w	r10,r8
8000c1a4:	f2 0b 13 00 	cpc	r11,r9
8000c1a8:	5e 2d       	reths	0
8000c1aa:	5e 3f       	retlo	1
8000c1ac:	14 38       	cp.w	r8,r10
8000c1ae:	f6 09 13 00 	cpc	r9,r11
8000c1b2:	5e 2d       	reths	0
8000c1b4:	5e 3f       	retlo	1
8000c1b6:	1b 07       	ld.w	r7,sp++
8000c1b8:	d8 0a       	popm	pc,r12=0
8000c1ba:	58 17       	cp.w	r7,1
8000c1bc:	5f 1c       	srne	r12
8000c1be:	58 09       	cp.w	r9,0
8000c1c0:	f5 b8 00 00 	subfeq	r8,0
8000c1c4:	1b 07       	ld.w	r7,sp++
8000c1c6:	1b 0e       	ld.w	lr,sp++
8000c1c8:	5e 0d       	reteq	0
8000c1ca:	5e fc       	retal	r12

8000c1cc <__avr32_f64_div>:
8000c1cc:	eb cd 40 ff 	pushm	r0-r7,lr
8000c1d0:	f7 e9 20 0e 	eor	lr,r11,r9
8000c1d4:	f6 07 16 14 	lsr	r7,r11,0x14
8000c1d8:	a9 7b       	lsl	r11,0x9
8000c1da:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c1de:	a9 7a       	lsl	r10,0x9
8000c1e0:	bd bb       	sbr	r11,0x1d
8000c1e2:	e4 1b 3f ff 	andh	r11,0x3fff
8000c1e6:	ab d7       	cbr	r7,0xb
8000c1e8:	e0 80 00 cc 	breq	8000c380 <__avr32_f64_div_round_subnormal+0x54>
8000c1ec:	e0 47 07 ff 	cp.w	r7,2047
8000c1f0:	e0 84 00 b5 	brge	8000c35a <__avr32_f64_div_round_subnormal+0x2e>
8000c1f4:	f2 06 16 14 	lsr	r6,r9,0x14
8000c1f8:	a9 79       	lsl	r9,0x9
8000c1fa:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c1fe:	a9 78       	lsl	r8,0x9
8000c200:	bd b9       	sbr	r9,0x1d
8000c202:	e4 19 3f ff 	andh	r9,0x3fff
8000c206:	ab d6       	cbr	r6,0xb
8000c208:	e0 80 00 e2 	breq	8000c3cc <__avr32_f64_div_round_subnormal+0xa0>
8000c20c:	e0 46 07 ff 	cp.w	r6,2047
8000c210:	e0 84 00 b2 	brge	8000c374 <__avr32_f64_div_round_subnormal+0x48>
8000c214:	0c 17       	sub	r7,r6
8000c216:	fe 37 fc 01 	sub	r7,-1023
8000c21a:	fc 1c 80 00 	movh	r12,0x8000
8000c21e:	f8 03 16 01 	lsr	r3,r12,0x1
8000c222:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c226:	5c d4       	com	r4
8000c228:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c22c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c230:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c234:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c238:	ea 03 15 02 	lsl	r3,r5,0x2
8000c23c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c240:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c244:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c248:	ea 03 15 02 	lsl	r3,r5,0x2
8000c24c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c250:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c254:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c258:	ea 03 15 02 	lsl	r3,r5,0x2
8000c25c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c260:	e4 09 07 40 	macu.d	r0,r2,r9
8000c264:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c268:	02 04       	add	r4,r1
8000c26a:	5c 05       	acr	r5
8000c26c:	a3 65       	lsl	r5,0x2
8000c26e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c272:	a3 64       	lsl	r4,0x2
8000c274:	5c 34       	neg	r4
8000c276:	f8 05 01 45 	sbc	r5,r12,r5
8000c27a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c27e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c282:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c286:	02 04       	add	r4,r1
8000c288:	5c 05       	acr	r5
8000c28a:	ea 03 15 02 	lsl	r3,r5,0x2
8000c28e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c292:	e8 02 15 02 	lsl	r2,r4,0x2
8000c296:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c29a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c29e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c2a2:	02 04       	add	r4,r1
8000c2a4:	5c 05       	acr	r5
8000c2a6:	a3 65       	lsl	r5,0x2
8000c2a8:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c2ac:	a3 64       	lsl	r4,0x2
8000c2ae:	5c 34       	neg	r4
8000c2b0:	f8 05 01 45 	sbc	r5,r12,r5
8000c2b4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c2b8:	e4 05 07 40 	macu.d	r0,r2,r5
8000c2bc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c2c0:	02 04       	add	r4,r1
8000c2c2:	5c 05       	acr	r5
8000c2c4:	ea 03 15 02 	lsl	r3,r5,0x2
8000c2c8:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c2cc:	e8 02 15 02 	lsl	r2,r4,0x2
8000c2d0:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c2d4:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c2d8:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c2dc:	02 02       	add	r2,r1
8000c2de:	5c 03       	acr	r3
8000c2e0:	ed b3 00 1c 	bld	r3,0x1c
8000c2e4:	c0 90       	breq	8000c2f6 <__avr32_f64_div+0x12a>
8000c2e6:	a1 72       	lsl	r2,0x1
8000c2e8:	5c f3       	rol	r3
8000c2ea:	20 17       	sub	r7,1
8000c2ec:	a3 9a       	lsr	r10,0x3
8000c2ee:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c2f2:	a3 9b       	lsr	r11,0x3
8000c2f4:	c0 58       	rjmp	8000c2fe <__avr32_f64_div+0x132>
8000c2f6:	a5 8a       	lsr	r10,0x4
8000c2f8:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c2fc:	a5 8b       	lsr	r11,0x4
8000c2fe:	58 07       	cp.w	r7,0
8000c300:	e0 8a 00 8b 	brle	8000c416 <__avr32_f64_div_res_subnormal>
8000c304:	e0 12 ff 00 	andl	r2,0xff00
8000c308:	e8 12 00 80 	orl	r2,0x80
8000c30c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c310:	e4 09 07 40 	macu.d	r0,r2,r9
8000c314:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c318:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c31c:	00 05       	add	r5,r0
8000c31e:	f0 01 00 48 	adc	r8,r8,r1
8000c322:	5c 09       	acr	r9
8000c324:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c328:	58 04       	cp.w	r4,0
8000c32a:	5c 25       	cpc	r5

8000c32c <__avr32_f64_div_round_subnormal>:
8000c32c:	f4 08 13 00 	cpc	r8,r10
8000c330:	f6 09 13 00 	cpc	r9,r11
8000c334:	5f 36       	srlo	r6
8000c336:	f8 06 17 00 	moveq	r6,r12
8000c33a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c33e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c342:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c346:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c34a:	ed be 00 1f 	bld	lr,0x1f
8000c34e:	ef bb 00 1f 	bst	r11,0x1f
8000c352:	0c 0a       	add	r10,r6
8000c354:	5c 0b       	acr	r11
8000c356:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c35a:	e4 1b 00 0f 	andh	r11,0xf
8000c35e:	14 4b       	or	r11,r10
8000c360:	e0 81 00 a7 	brne	8000c4ae <__avr32_f64_div_res_subnormal+0x98>
8000c364:	f2 06 16 14 	lsr	r6,r9,0x14
8000c368:	ab d6       	cbr	r6,0xb
8000c36a:	e0 46 07 ff 	cp.w	r6,2047
8000c36e:	e0 81 00 a4 	brne	8000c4b6 <__avr32_f64_div_res_subnormal+0xa0>
8000c372:	c9 e8       	rjmp	8000c4ae <__avr32_f64_div_res_subnormal+0x98>
8000c374:	e4 19 00 0f 	andh	r9,0xf
8000c378:	10 49       	or	r9,r8
8000c37a:	e0 81 00 9a 	brne	8000c4ae <__avr32_f64_div_res_subnormal+0x98>
8000c37e:	c9 28       	rjmp	8000c4a2 <__avr32_f64_div_res_subnormal+0x8c>
8000c380:	a3 7b       	lsl	r11,0x3
8000c382:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c386:	a3 7a       	lsl	r10,0x3
8000c388:	f5 eb 10 04 	or	r4,r10,r11
8000c38c:	e0 80 00 a0 	breq	8000c4cc <__avr32_f64_div_op1_zero>
8000c390:	f6 04 12 00 	clz	r4,r11
8000c394:	c1 70       	breq	8000c3c2 <__avr32_f64_div_round_subnormal+0x96>
8000c396:	c0 c3       	brcs	8000c3ae <__avr32_f64_div_round_subnormal+0x82>
8000c398:	e8 05 11 20 	rsub	r5,r4,32
8000c39c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c3a0:	f4 05 0a 45 	lsr	r5,r10,r5
8000c3a4:	0a 4b       	or	r11,r5
8000c3a6:	f4 04 09 4a 	lsl	r10,r10,r4
8000c3aa:	08 17       	sub	r7,r4
8000c3ac:	c0 b8       	rjmp	8000c3c2 <__avr32_f64_div_round_subnormal+0x96>
8000c3ae:	f4 04 12 00 	clz	r4,r10
8000c3b2:	f9 b4 03 00 	movlo	r4,0
8000c3b6:	f7 b4 02 e0 	subhs	r4,-32
8000c3ba:	f4 04 09 4b 	lsl	r11,r10,r4
8000c3be:	30 0a       	mov	r10,0
8000c3c0:	08 17       	sub	r7,r4
8000c3c2:	a3 8a       	lsr	r10,0x2
8000c3c4:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c3c8:	a3 8b       	lsr	r11,0x2
8000c3ca:	c1 1b       	rjmp	8000c1ec <__avr32_f64_div+0x20>
8000c3cc:	a3 79       	lsl	r9,0x3
8000c3ce:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c3d2:	a3 78       	lsl	r8,0x3
8000c3d4:	f3 e8 10 04 	or	r4,r9,r8
8000c3d8:	c6 f0       	breq	8000c4b6 <__avr32_f64_div_res_subnormal+0xa0>
8000c3da:	f2 04 12 00 	clz	r4,r9
8000c3de:	c1 70       	breq	8000c40c <__avr32_f64_div_round_subnormal+0xe0>
8000c3e0:	c0 c3       	brcs	8000c3f8 <__avr32_f64_div_round_subnormal+0xcc>
8000c3e2:	e8 05 11 20 	rsub	r5,r4,32
8000c3e6:	f2 04 09 49 	lsl	r9,r9,r4
8000c3ea:	f0 05 0a 45 	lsr	r5,r8,r5
8000c3ee:	0a 49       	or	r9,r5
8000c3f0:	f0 04 09 48 	lsl	r8,r8,r4
8000c3f4:	08 16       	sub	r6,r4
8000c3f6:	c0 b8       	rjmp	8000c40c <__avr32_f64_div_round_subnormal+0xe0>
8000c3f8:	f0 04 12 00 	clz	r4,r8
8000c3fc:	f9 b4 03 00 	movlo	r4,0
8000c400:	f7 b4 02 e0 	subhs	r4,-32
8000c404:	f0 04 09 49 	lsl	r9,r8,r4
8000c408:	30 08       	mov	r8,0
8000c40a:	08 16       	sub	r6,r4
8000c40c:	a3 88       	lsr	r8,0x2
8000c40e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c412:	a3 89       	lsr	r9,0x2
8000c414:	cf ca       	rjmp	8000c20c <__avr32_f64_div+0x40>

8000c416 <__avr32_f64_div_res_subnormal>:
8000c416:	5c 37       	neg	r7
8000c418:	2f f7       	sub	r7,-1
8000c41a:	f1 b7 04 c0 	satu	r7,0x6
8000c41e:	e0 47 00 20 	cp.w	r7,32
8000c422:	c1 54       	brge	8000c44c <__avr32_f64_div_res_subnormal+0x36>
8000c424:	ee 06 11 20 	rsub	r6,r7,32
8000c428:	e4 07 0a 42 	lsr	r2,r2,r7
8000c42c:	e6 06 09 4c 	lsl	r12,r3,r6
8000c430:	18 42       	or	r2,r12
8000c432:	e6 07 0a 43 	lsr	r3,r3,r7
8000c436:	f4 06 09 41 	lsl	r1,r10,r6
8000c43a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c43e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c442:	18 4a       	or	r10,r12
8000c444:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c448:	30 00       	mov	r0,0
8000c44a:	c1 58       	rjmp	8000c474 <__avr32_f64_div_res_subnormal+0x5e>
8000c44c:	ee 06 11 20 	rsub	r6,r7,32
8000c450:	f9 b0 00 00 	moveq	r0,0
8000c454:	f9 bc 00 00 	moveq	r12,0
8000c458:	c0 50       	breq	8000c462 <__avr32_f64_div_res_subnormal+0x4c>
8000c45a:	f4 06 09 40 	lsl	r0,r10,r6
8000c45e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c462:	e6 07 0a 42 	lsr	r2,r3,r7
8000c466:	30 03       	mov	r3,0
8000c468:	f4 07 0a 41 	lsr	r1,r10,r7
8000c46c:	18 41       	or	r1,r12
8000c46e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c472:	30 0b       	mov	r11,0
8000c474:	e0 12 ff 00 	andl	r2,0xff00
8000c478:	e8 12 00 80 	orl	r2,0x80
8000c47c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c480:	e4 09 07 46 	macu.d	r6,r2,r9
8000c484:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c488:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c48c:	0c 05       	add	r5,r6
8000c48e:	f0 07 00 48 	adc	r8,r8,r7
8000c492:	5c 09       	acr	r9
8000c494:	30 07       	mov	r7,0
8000c496:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c49a:	00 34       	cp.w	r4,r0
8000c49c:	e2 05 13 00 	cpc	r5,r1
8000c4a0:	c4 6b       	rjmp	8000c32c <__avr32_f64_div_round_subnormal>
8000c4a2:	1c 9b       	mov	r11,lr
8000c4a4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c4a8:	30 0a       	mov	r10,0
8000c4aa:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c4ae:	3f fb       	mov	r11,-1
8000c4b0:	30 0a       	mov	r10,0
8000c4b2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c4b6:	f5 eb 10 04 	or	r4,r10,r11
8000c4ba:	c0 90       	breq	8000c4cc <__avr32_f64_div_op1_zero>
8000c4bc:	1c 9b       	mov	r11,lr
8000c4be:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c4c2:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c4c6:	30 0a       	mov	r10,0
8000c4c8:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c4cc <__avr32_f64_div_op1_zero>:
8000c4cc:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c4d0:	ce f0       	breq	8000c4ae <__avr32_f64_div_res_subnormal+0x98>
8000c4d2:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c4d6:	e0 44 07 ff 	cp.w	r4,2047
8000c4da:	ce 41       	brne	8000c4a2 <__avr32_f64_div_res_subnormal+0x8c>
8000c4dc:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c4e0:	ce 10       	breq	8000c4a2 <__avr32_f64_div_res_subnormal+0x8c>
8000c4e2:	ce 6b       	rjmp	8000c4ae <__avr32_f64_div_res_subnormal+0x98>

8000c4e4 <__avr32_udiv64>:
8000c4e4:	d4 31       	pushm	r0-r7,lr
8000c4e6:	1a 97       	mov	r7,sp
8000c4e8:	20 3d       	sub	sp,12
8000c4ea:	10 9c       	mov	r12,r8
8000c4ec:	12 9e       	mov	lr,r9
8000c4ee:	14 93       	mov	r3,r10
8000c4f0:	58 09       	cp.w	r9,0
8000c4f2:	e0 81 00 bd 	brne	8000c66c <__avr32_udiv64+0x188>
8000c4f6:	16 38       	cp.w	r8,r11
8000c4f8:	e0 88 00 40 	brls	8000c578 <__avr32_udiv64+0x94>
8000c4fc:	f0 08 12 00 	clz	r8,r8
8000c500:	c0 d0       	breq	8000c51a <__avr32_udiv64+0x36>
8000c502:	f6 08 09 4b 	lsl	r11,r11,r8
8000c506:	f0 09 11 20 	rsub	r9,r8,32
8000c50a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c50e:	f4 09 0a 49 	lsr	r9,r10,r9
8000c512:	f4 08 09 43 	lsl	r3,r10,r8
8000c516:	f3 eb 10 0b 	or	r11,r9,r11
8000c51a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c51e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c522:	f6 0e 0d 00 	divu	r0,r11,lr
8000c526:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c52a:	00 99       	mov	r9,r0
8000c52c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c530:	e0 0a 02 48 	mul	r8,r0,r10
8000c534:	10 3b       	cp.w	r11,r8
8000c536:	c0 a2       	brcc	8000c54a <__avr32_udiv64+0x66>
8000c538:	20 19       	sub	r9,1
8000c53a:	18 0b       	add	r11,r12
8000c53c:	18 3b       	cp.w	r11,r12
8000c53e:	c0 63       	brcs	8000c54a <__avr32_udiv64+0x66>
8000c540:	10 3b       	cp.w	r11,r8
8000c542:	f7 b9 03 01 	sublo	r9,1
8000c546:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c54a:	f6 08 01 01 	sub	r1,r11,r8
8000c54e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c552:	e2 0e 0d 00 	divu	r0,r1,lr
8000c556:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c55a:	00 98       	mov	r8,r0
8000c55c:	e0 0a 02 4a 	mul	r10,r0,r10
8000c560:	14 33       	cp.w	r3,r10
8000c562:	c0 82       	brcc	8000c572 <__avr32_udiv64+0x8e>
8000c564:	20 18       	sub	r8,1
8000c566:	18 03       	add	r3,r12
8000c568:	18 33       	cp.w	r3,r12
8000c56a:	c0 43       	brcs	8000c572 <__avr32_udiv64+0x8e>
8000c56c:	14 33       	cp.w	r3,r10
8000c56e:	f7 b8 03 01 	sublo	r8,1
8000c572:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c576:	cd f8       	rjmp	8000c734 <__avr32_udiv64+0x250>
8000c578:	58 08       	cp.w	r8,0
8000c57a:	c0 51       	brne	8000c584 <__avr32_udiv64+0xa0>
8000c57c:	30 19       	mov	r9,1
8000c57e:	f2 08 0d 08 	divu	r8,r9,r8
8000c582:	10 9c       	mov	r12,r8
8000c584:	f8 06 12 00 	clz	r6,r12
8000c588:	c0 41       	brne	8000c590 <__avr32_udiv64+0xac>
8000c58a:	18 1b       	sub	r11,r12
8000c58c:	30 19       	mov	r9,1
8000c58e:	c4 08       	rjmp	8000c60e <__avr32_udiv64+0x12a>
8000c590:	ec 01 11 20 	rsub	r1,r6,32
8000c594:	f4 01 0a 49 	lsr	r9,r10,r1
8000c598:	f8 06 09 4c 	lsl	r12,r12,r6
8000c59c:	f6 06 09 48 	lsl	r8,r11,r6
8000c5a0:	f6 01 0a 41 	lsr	r1,r11,r1
8000c5a4:	f3 e8 10 08 	or	r8,r9,r8
8000c5a8:	f8 03 16 10 	lsr	r3,r12,0x10
8000c5ac:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c5b0:	e2 03 0d 00 	divu	r0,r1,r3
8000c5b4:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c5b8:	00 9e       	mov	lr,r0
8000c5ba:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c5be:	e0 05 02 49 	mul	r9,r0,r5
8000c5c2:	12 3b       	cp.w	r11,r9
8000c5c4:	c0 a2       	brcc	8000c5d8 <__avr32_udiv64+0xf4>
8000c5c6:	20 1e       	sub	lr,1
8000c5c8:	18 0b       	add	r11,r12
8000c5ca:	18 3b       	cp.w	r11,r12
8000c5cc:	c0 63       	brcs	8000c5d8 <__avr32_udiv64+0xf4>
8000c5ce:	12 3b       	cp.w	r11,r9
8000c5d0:	f7 be 03 01 	sublo	lr,1
8000c5d4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c5d8:	12 1b       	sub	r11,r9
8000c5da:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c5de:	f6 03 0d 02 	divu	r2,r11,r3
8000c5e2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c5e6:	04 99       	mov	r9,r2
8000c5e8:	e4 05 02 4b 	mul	r11,r2,r5
8000c5ec:	16 38       	cp.w	r8,r11
8000c5ee:	c0 a2       	brcc	8000c602 <__avr32_udiv64+0x11e>
8000c5f0:	20 19       	sub	r9,1
8000c5f2:	18 08       	add	r8,r12
8000c5f4:	18 38       	cp.w	r8,r12
8000c5f6:	c0 63       	brcs	8000c602 <__avr32_udiv64+0x11e>
8000c5f8:	16 38       	cp.w	r8,r11
8000c5fa:	f7 b9 03 01 	sublo	r9,1
8000c5fe:	f1 dc e3 08 	addcs	r8,r8,r12
8000c602:	f4 06 09 43 	lsl	r3,r10,r6
8000c606:	f0 0b 01 0b 	sub	r11,r8,r11
8000c60a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c60e:	f8 06 16 10 	lsr	r6,r12,0x10
8000c612:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c616:	f6 06 0d 00 	divu	r0,r11,r6
8000c61a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c61e:	00 9a       	mov	r10,r0
8000c620:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c624:	e0 0e 02 48 	mul	r8,r0,lr
8000c628:	10 3b       	cp.w	r11,r8
8000c62a:	c0 a2       	brcc	8000c63e <__avr32_udiv64+0x15a>
8000c62c:	20 1a       	sub	r10,1
8000c62e:	18 0b       	add	r11,r12
8000c630:	18 3b       	cp.w	r11,r12
8000c632:	c0 63       	brcs	8000c63e <__avr32_udiv64+0x15a>
8000c634:	10 3b       	cp.w	r11,r8
8000c636:	f7 ba 03 01 	sublo	r10,1
8000c63a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c63e:	f6 08 01 01 	sub	r1,r11,r8
8000c642:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c646:	e2 06 0d 00 	divu	r0,r1,r6
8000c64a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c64e:	00 98       	mov	r8,r0
8000c650:	e0 0e 02 4b 	mul	r11,r0,lr
8000c654:	16 33       	cp.w	r3,r11
8000c656:	c0 82       	brcc	8000c666 <__avr32_udiv64+0x182>
8000c658:	20 18       	sub	r8,1
8000c65a:	18 03       	add	r3,r12
8000c65c:	18 33       	cp.w	r3,r12
8000c65e:	c0 43       	brcs	8000c666 <__avr32_udiv64+0x182>
8000c660:	16 33       	cp.w	r3,r11
8000c662:	f7 b8 03 01 	sublo	r8,1
8000c666:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c66a:	c6 98       	rjmp	8000c73c <__avr32_udiv64+0x258>
8000c66c:	16 39       	cp.w	r9,r11
8000c66e:	e0 8b 00 65 	brhi	8000c738 <__avr32_udiv64+0x254>
8000c672:	f2 09 12 00 	clz	r9,r9
8000c676:	c0 b1       	brne	8000c68c <__avr32_udiv64+0x1a8>
8000c678:	10 3a       	cp.w	r10,r8
8000c67a:	5f 2a       	srhs	r10
8000c67c:	1c 3b       	cp.w	r11,lr
8000c67e:	5f b8       	srhi	r8
8000c680:	10 4a       	or	r10,r8
8000c682:	f2 0a 18 00 	cp.b	r10,r9
8000c686:	c5 90       	breq	8000c738 <__avr32_udiv64+0x254>
8000c688:	30 18       	mov	r8,1
8000c68a:	c5 98       	rjmp	8000c73c <__avr32_udiv64+0x258>
8000c68c:	f0 09 09 46 	lsl	r6,r8,r9
8000c690:	f2 03 11 20 	rsub	r3,r9,32
8000c694:	fc 09 09 4e 	lsl	lr,lr,r9
8000c698:	f0 03 0a 48 	lsr	r8,r8,r3
8000c69c:	f6 09 09 4c 	lsl	r12,r11,r9
8000c6a0:	f4 03 0a 42 	lsr	r2,r10,r3
8000c6a4:	ef 46 ff f4 	st.w	r7[-12],r6
8000c6a8:	f6 03 0a 43 	lsr	r3,r11,r3
8000c6ac:	18 42       	or	r2,r12
8000c6ae:	f1 ee 10 0c 	or	r12,r8,lr
8000c6b2:	f8 01 16 10 	lsr	r1,r12,0x10
8000c6b6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c6ba:	e6 01 0d 04 	divu	r4,r3,r1
8000c6be:	e4 03 16 10 	lsr	r3,r2,0x10
8000c6c2:	08 9e       	mov	lr,r4
8000c6c4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c6c8:	e8 06 02 48 	mul	r8,r4,r6
8000c6cc:	10 33       	cp.w	r3,r8
8000c6ce:	c0 a2       	brcc	8000c6e2 <__avr32_udiv64+0x1fe>
8000c6d0:	20 1e       	sub	lr,1
8000c6d2:	18 03       	add	r3,r12
8000c6d4:	18 33       	cp.w	r3,r12
8000c6d6:	c0 63       	brcs	8000c6e2 <__avr32_udiv64+0x1fe>
8000c6d8:	10 33       	cp.w	r3,r8
8000c6da:	f7 be 03 01 	sublo	lr,1
8000c6de:	e7 dc e3 03 	addcs	r3,r3,r12
8000c6e2:	10 13       	sub	r3,r8
8000c6e4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c6e8:	e6 01 0d 00 	divu	r0,r3,r1
8000c6ec:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c6f0:	00 98       	mov	r8,r0
8000c6f2:	e0 06 02 46 	mul	r6,r0,r6
8000c6f6:	0c 3b       	cp.w	r11,r6
8000c6f8:	c0 a2       	brcc	8000c70c <__avr32_udiv64+0x228>
8000c6fa:	20 18       	sub	r8,1
8000c6fc:	18 0b       	add	r11,r12
8000c6fe:	18 3b       	cp.w	r11,r12
8000c700:	c0 63       	brcs	8000c70c <__avr32_udiv64+0x228>
8000c702:	0c 3b       	cp.w	r11,r6
8000c704:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c708:	f7 b8 03 01 	sublo	r8,1
8000c70c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c710:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c714:	0c 1b       	sub	r11,r6
8000c716:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c71a:	06 95       	mov	r5,r3
8000c71c:	16 35       	cp.w	r5,r11
8000c71e:	e0 8b 00 0a 	brhi	8000c732 <__avr32_udiv64+0x24e>
8000c722:	5f 0b       	sreq	r11
8000c724:	f4 09 09 49 	lsl	r9,r10,r9
8000c728:	12 32       	cp.w	r2,r9
8000c72a:	5f b9       	srhi	r9
8000c72c:	f7 e9 00 09 	and	r9,r11,r9
8000c730:	c0 60       	breq	8000c73c <__avr32_udiv64+0x258>
8000c732:	20 18       	sub	r8,1
8000c734:	30 09       	mov	r9,0
8000c736:	c0 38       	rjmp	8000c73c <__avr32_udiv64+0x258>
8000c738:	30 09       	mov	r9,0
8000c73a:	12 98       	mov	r8,r9
8000c73c:	10 9a       	mov	r10,r8
8000c73e:	12 93       	mov	r3,r9
8000c740:	10 92       	mov	r2,r8
8000c742:	12 9b       	mov	r11,r9
8000c744:	2f dd       	sub	sp,-12
8000c746:	d8 32       	popm	r0-r7,pc

8000c748 <__avr32_umod64>:
8000c748:	d4 31       	pushm	r0-r7,lr
8000c74a:	1a 97       	mov	r7,sp
8000c74c:	20 3d       	sub	sp,12
8000c74e:	10 9c       	mov	r12,r8
8000c750:	12 95       	mov	r5,r9
8000c752:	14 9e       	mov	lr,r10
8000c754:	16 91       	mov	r1,r11
8000c756:	16 96       	mov	r6,r11
8000c758:	58 09       	cp.w	r9,0
8000c75a:	e0 81 00 81 	brne	8000c85c <__avr32_umod64+0x114>
8000c75e:	16 38       	cp.w	r8,r11
8000c760:	e0 88 00 12 	brls	8000c784 <__avr32_umod64+0x3c>
8000c764:	f0 08 12 00 	clz	r8,r8
8000c768:	c4 e0       	breq	8000c804 <__avr32_umod64+0xbc>
8000c76a:	f6 08 09 46 	lsl	r6,r11,r8
8000c76e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c772:	f0 0b 11 20 	rsub	r11,r8,32
8000c776:	f4 08 09 4e 	lsl	lr,r10,r8
8000c77a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c77e:	f7 e6 10 06 	or	r6,r11,r6
8000c782:	c4 18       	rjmp	8000c804 <__avr32_umod64+0xbc>
8000c784:	58 08       	cp.w	r8,0
8000c786:	c0 51       	brne	8000c790 <__avr32_umod64+0x48>
8000c788:	30 19       	mov	r9,1
8000c78a:	f2 08 0d 08 	divu	r8,r9,r8
8000c78e:	10 9c       	mov	r12,r8
8000c790:	f8 08 12 00 	clz	r8,r12
8000c794:	c0 31       	brne	8000c79a <__avr32_umod64+0x52>
8000c796:	18 16       	sub	r6,r12
8000c798:	c3 68       	rjmp	8000c804 <__avr32_umod64+0xbc>
8000c79a:	f0 03 11 20 	rsub	r3,r8,32
8000c79e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c7a2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c7a6:	ec 08 09 49 	lsl	r9,r6,r8
8000c7aa:	ec 03 0a 43 	lsr	r3,r6,r3
8000c7ae:	f7 e9 10 09 	or	r9,r11,r9
8000c7b2:	f8 05 16 10 	lsr	r5,r12,0x10
8000c7b6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c7ba:	e6 05 0d 02 	divu	r2,r3,r5
8000c7be:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c7c2:	ec 02 02 4b 	mul	r11,r6,r2
8000c7c6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c7ca:	16 3e       	cp.w	lr,r11
8000c7cc:	c0 72       	brcc	8000c7da <__avr32_umod64+0x92>
8000c7ce:	18 0e       	add	lr,r12
8000c7d0:	18 3e       	cp.w	lr,r12
8000c7d2:	c0 43       	brcs	8000c7da <__avr32_umod64+0x92>
8000c7d4:	16 3e       	cp.w	lr,r11
8000c7d6:	fd dc e3 0e 	addcs	lr,lr,r12
8000c7da:	fc 0b 01 03 	sub	r3,lr,r11
8000c7de:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c7e2:	e6 05 0d 02 	divu	r2,r3,r5
8000c7e6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c7ea:	a5 36       	mul	r6,r2
8000c7ec:	0c 39       	cp.w	r9,r6
8000c7ee:	c0 72       	brcc	8000c7fc <__avr32_umod64+0xb4>
8000c7f0:	18 09       	add	r9,r12
8000c7f2:	18 39       	cp.w	r9,r12
8000c7f4:	c0 43       	brcs	8000c7fc <__avr32_umod64+0xb4>
8000c7f6:	0c 39       	cp.w	r9,r6
8000c7f8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c7fc:	f2 06 01 06 	sub	r6,r9,r6
8000c800:	f4 08 09 4e 	lsl	lr,r10,r8
8000c804:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c808:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c80c:	ec 0a 0d 02 	divu	r2,r6,r10
8000c810:	fc 09 16 10 	lsr	r9,lr,0x10
8000c814:	ea 02 02 4b 	mul	r11,r5,r2
8000c818:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c81c:	16 39       	cp.w	r9,r11
8000c81e:	c0 72       	brcc	8000c82c <__avr32_umod64+0xe4>
8000c820:	18 09       	add	r9,r12
8000c822:	18 39       	cp.w	r9,r12
8000c824:	c0 43       	brcs	8000c82c <__avr32_umod64+0xe4>
8000c826:	16 39       	cp.w	r9,r11
8000c828:	f3 dc e3 09 	addcs	r9,r9,r12
8000c82c:	f2 0b 01 0b 	sub	r11,r9,r11
8000c830:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c834:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c838:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c83c:	ea 0a 02 4a 	mul	r10,r5,r10
8000c840:	14 3e       	cp.w	lr,r10
8000c842:	c0 72       	brcc	8000c850 <__avr32_umod64+0x108>
8000c844:	18 0e       	add	lr,r12
8000c846:	18 3e       	cp.w	lr,r12
8000c848:	c0 43       	brcs	8000c850 <__avr32_umod64+0x108>
8000c84a:	14 3e       	cp.w	lr,r10
8000c84c:	fd dc e3 0e 	addcs	lr,lr,r12
8000c850:	fc 0a 01 0a 	sub	r10,lr,r10
8000c854:	30 0b       	mov	r11,0
8000c856:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c85a:	c7 b8       	rjmp	8000c950 <__avr32_umod64+0x208>
8000c85c:	16 39       	cp.w	r9,r11
8000c85e:	e0 8b 00 79 	brhi	8000c950 <__avr32_umod64+0x208>
8000c862:	f2 09 12 00 	clz	r9,r9
8000c866:	c1 21       	brne	8000c88a <__avr32_umod64+0x142>
8000c868:	10 3a       	cp.w	r10,r8
8000c86a:	5f 2b       	srhs	r11
8000c86c:	0a 31       	cp.w	r1,r5
8000c86e:	5f ba       	srhi	r10
8000c870:	f7 ea 10 0a 	or	r10,r11,r10
8000c874:	f2 0a 18 00 	cp.b	r10,r9
8000c878:	c0 60       	breq	8000c884 <__avr32_umod64+0x13c>
8000c87a:	fc 08 01 0c 	sub	r12,lr,r8
8000c87e:	e2 05 01 46 	sbc	r6,r1,r5
8000c882:	18 9e       	mov	lr,r12
8000c884:	0c 9b       	mov	r11,r6
8000c886:	1c 9a       	mov	r10,lr
8000c888:	c6 48       	rjmp	8000c950 <__avr32_umod64+0x208>
8000c88a:	ea 09 09 4c 	lsl	r12,r5,r9
8000c88e:	f2 06 11 20 	rsub	r6,r9,32
8000c892:	f6 09 09 4b 	lsl	r11,r11,r9
8000c896:	f0 09 09 42 	lsl	r2,r8,r9
8000c89a:	ef 46 ff f4 	st.w	r7[-12],r6
8000c89e:	f0 06 0a 48 	lsr	r8,r8,r6
8000c8a2:	18 48       	or	r8,r12
8000c8a4:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c8a8:	f4 09 09 43 	lsl	r3,r10,r9
8000c8ac:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c8b0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c8b4:	16 4a       	or	r10,r11
8000c8b6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c8ba:	f8 0b 0d 04 	divu	r4,r12,r11
8000c8be:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c8c2:	08 91       	mov	r1,r4
8000c8c4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c8c8:	e8 0e 02 46 	mul	r6,r4,lr
8000c8cc:	0c 3c       	cp.w	r12,r6
8000c8ce:	c0 a2       	brcc	8000c8e2 <__avr32_umod64+0x19a>
8000c8d0:	20 11       	sub	r1,1
8000c8d2:	10 0c       	add	r12,r8
8000c8d4:	10 3c       	cp.w	r12,r8
8000c8d6:	c0 63       	brcs	8000c8e2 <__avr32_umod64+0x19a>
8000c8d8:	0c 3c       	cp.w	r12,r6
8000c8da:	f7 b1 03 01 	sublo	r1,1
8000c8de:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c8e2:	0c 1c       	sub	r12,r6
8000c8e4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c8e8:	f8 0b 0d 04 	divu	r4,r12,r11
8000c8ec:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c8f0:	08 96       	mov	r6,r4
8000c8f2:	e8 0e 02 4e 	mul	lr,r4,lr
8000c8f6:	1c 3b       	cp.w	r11,lr
8000c8f8:	c0 a2       	brcc	8000c90c <__avr32_umod64+0x1c4>
8000c8fa:	20 16       	sub	r6,1
8000c8fc:	10 0b       	add	r11,r8
8000c8fe:	10 3b       	cp.w	r11,r8
8000c900:	c0 63       	brcs	8000c90c <__avr32_umod64+0x1c4>
8000c902:	1c 3b       	cp.w	r11,lr
8000c904:	f7 b6 03 01 	sublo	r6,1
8000c908:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c90c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c910:	1c 1b       	sub	r11,lr
8000c912:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c916:	00 9e       	mov	lr,r0
8000c918:	02 9c       	mov	r12,r1
8000c91a:	16 3c       	cp.w	r12,r11
8000c91c:	e0 8b 00 08 	brhi	8000c92c <__avr32_umod64+0x1e4>
8000c920:	5f 06       	sreq	r6
8000c922:	06 30       	cp.w	r0,r3
8000c924:	5f ba       	srhi	r10
8000c926:	ed ea 00 0a 	and	r10,r6,r10
8000c92a:	c0 60       	breq	8000c936 <__avr32_umod64+0x1ee>
8000c92c:	fc 02 01 04 	sub	r4,lr,r2
8000c930:	f8 08 01 4c 	sbc	r12,r12,r8
8000c934:	08 9e       	mov	lr,r4
8000c936:	e6 0e 01 0a 	sub	r10,r3,lr
8000c93a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c93e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c942:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c946:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c94a:	f8 01 09 4c 	lsl	r12,r12,r1
8000c94e:	18 4a       	or	r10,r12
8000c950:	2f dd       	sub	sp,-12
8000c952:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ca00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ca00:	c0 08       	rjmp	8000ca00 <_evba>
	...

8000ca04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ca04:	c0 08       	rjmp	8000ca04 <_handle_TLB_Multiple_Hit>
	...

8000ca08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ca08:	c0 08       	rjmp	8000ca08 <_handle_Bus_Error_Data_Fetch>
	...

8000ca0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ca0c:	c0 08       	rjmp	8000ca0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ca10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ca10:	c0 08       	rjmp	8000ca10 <_handle_NMI>
	...

8000ca14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ca14:	c0 08       	rjmp	8000ca14 <_handle_Instruction_Address>
	...

8000ca18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ca18:	c0 08       	rjmp	8000ca18 <_handle_ITLB_Protection>
	...

8000ca1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ca1c:	c0 08       	rjmp	8000ca1c <_handle_Breakpoint>
	...

8000ca20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ca20:	c0 08       	rjmp	8000ca20 <_handle_Illegal_Opcode>
	...

8000ca24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ca24:	c0 08       	rjmp	8000ca24 <_handle_Unimplemented_Instruction>
	...

8000ca28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ca28:	c0 08       	rjmp	8000ca28 <_handle_Privilege_Violation>
	...

8000ca2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ca2c:	c0 08       	rjmp	8000ca2c <_handle_Floating_Point>
	...

8000ca30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ca30:	c0 08       	rjmp	8000ca30 <_handle_Coprocessor_Absent>
	...

8000ca34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ca34:	c0 08       	rjmp	8000ca34 <_handle_Data_Address_Read>
	...

8000ca38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ca38:	c0 08       	rjmp	8000ca38 <_handle_Data_Address_Write>
	...

8000ca3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ca3c:	c0 08       	rjmp	8000ca3c <_handle_DTLB_Protection_Read>
	...

8000ca40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ca40:	c0 08       	rjmp	8000ca40 <_handle_DTLB_Protection_Write>
	...

8000ca44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ca44:	c0 08       	rjmp	8000ca44 <_handle_DTLB_Modified>
	...

8000ca50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ca50:	c0 08       	rjmp	8000ca50 <_handle_ITLB_Miss>
	...

8000ca60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ca60:	c0 08       	rjmp	8000ca60 <_handle_DTLB_Miss_Read>
	...

8000ca70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ca70:	c0 08       	rjmp	8000ca70 <_handle_DTLB_Miss_Write>
	...

8000cb00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cb00:	fe cf 6f e0 	sub	pc,pc,28640

8000cb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cb04:	30 0c       	mov	r12,0
8000cb06:	fe b0 c5 0f 	rcall	80005524 <_get_interrupt_handler>
8000cb0a:	58 0c       	cp.w	r12,0
8000cb0c:	f8 0f 17 10 	movne	pc,r12
8000cb10:	d6 03       	rete

8000cb12 <_int1>:
8000cb12:	30 1c       	mov	r12,1
8000cb14:	fe b0 c5 08 	rcall	80005524 <_get_interrupt_handler>
8000cb18:	58 0c       	cp.w	r12,0
8000cb1a:	f8 0f 17 10 	movne	pc,r12
8000cb1e:	d6 03       	rete

8000cb20 <_int2>:
8000cb20:	30 2c       	mov	r12,2
8000cb22:	fe b0 c5 01 	rcall	80005524 <_get_interrupt_handler>
8000cb26:	58 0c       	cp.w	r12,0
8000cb28:	f8 0f 17 10 	movne	pc,r12
8000cb2c:	d6 03       	rete

8000cb2e <_int3>:
8000cb2e:	30 3c       	mov	r12,3
8000cb30:	fe b0 c4 fa 	rcall	80005524 <_get_interrupt_handler>
8000cb34:	58 0c       	cp.w	r12,0
8000cb36:	f8 0f 17 10 	movne	pc,r12
8000cb3a:	d6 03       	rete

8000cb3c <ipr_val>:
8000cb3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cb4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cb9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cbfc:	d7 03 d7 03                                         ....
