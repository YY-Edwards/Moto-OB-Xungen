
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000bc84  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000de00  8000de00  0000e200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001624  8000e000  8000e000  0000e400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000f624  8000f624  0000fa24  2**0
                  ALLOC
  6 .data         00000a54  00000004  8000f628  0000fc04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000b2f8  00000a58  8001007c  00010658  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  00010658  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001798  00000000  00000000  00010688  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00003844  00000000  00000000  00011e20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002e241  00000000  00000000  00015664  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000781b  00000000  00000000  000438a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000dc9e  00000000  00000000  0004b0c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000040e4  00000000  00000000  00058d60  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000082df  00000000  00000000  0005ce44  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000ff71  00000000  00000000  00065123  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001848  00000000  00000000  00075098  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b4 08 	sub	pc,pc,-19448

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0e 20       	rsub	r0,r7

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 70       	tst	r0,r5

8000203c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000203c:	d4 01       	pushm	lr
  log("R");
8000203e:	48 3c       	lddpc	r12,80002048 <app_payload_tx_proc+0xc>
80002040:	f0 1f 00 03 	mcall	8000204c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002044:	d8 02       	popm	pc
80002046:	00 00       	add	r0,r0
80002048:	80 00       	ld.sh	r0,r0[0x0]
8000204a:	e0 00       	*unknown*
8000204c:	80 00       	ld.sh	r0,r0[0x0]
8000204e:	7f 54       	ld.w	r4,pc[0x54]

80002050 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
80002050:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
80002052:	48 99       	lddpc	r9,80002074 <app_payload_rx_proc+0x24>
80002054:	13 88       	ld.ub	r8,r9[0x0]
80002056:	2f f8       	sub	r8,-1
80002058:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000205a:	30 39       	mov	r9,3
8000205c:	f2 08 18 00 	cp.b	r8,r9
80002060:	c0 71       	brne	8000206e <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
80002062:	30 09       	mov	r9,0
80002064:	48 48       	lddpc	r8,80002074 <app_payload_rx_proc+0x24>
80002066:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002068:	48 4c       	lddpc	r12,80002078 <app_payload_rx_proc+0x28>
8000206a:	f0 1f 00 05 	mcall	8000207c <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000206e:	48 58       	lddpc	r8,80002080 <app_payload_rx_proc+0x30>
80002070:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
80002072:	d8 02       	popm	pc
80002074:	00 00       	add	r0,r0
80002076:	0a 5e       	eor	lr,r5
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	e0 04       	*unknown*
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	7f 54       	ld.w	r4,pc[0x54]
80002080:	00 00       	add	r0,r0
80002082:	0a 5f       	eor	pc,r5

80002084 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002084:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002086:	48 3c       	lddpc	r12,80002090 <FD_brdcst_func+0xc>
80002088:	f0 1f 00 03 	mcall	80002094 <FD_brdcst_func+0x10>
	
}
8000208c:	d8 02       	popm	pc
8000208e:	00 00       	add	r0,r0
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	e0 10 80 00 	andl	r0,0x8000
80002096:	7f 54       	ld.w	r4,pc[0x54]

80002098 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_reply_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_reply_func+0x10>
	
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	e0 30 80 00 	sub	r0,98304
800020aa:	7f 54       	ld.w	r4,pc[0x54]

800020ac <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_request_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_request_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	e0 4c 80 00 	cp.w	r12,32768
800020be:	7f 54       	ld.w	r4,pc[0x54]

800020c0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <EnOB_brdcst_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <EnOB_brdcst_func+0x10>
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	e0 68 80 00 	mov	r8,32768
800020d2:	7f 54       	ld.w	r4,pc[0x54]

800020d4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020d4:	eb cd 40 80 	pushm	r7,lr
800020d8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020da:	19 a9       	ld.ub	r9,r12[0x2]
800020dc:	30 08       	mov	r8,0
800020de:	f0 09 18 00 	cp.b	r9,r8
800020e2:	c1 91       	brne	80002114 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020e4:	19 b8       	ld.ub	r8,r12[0x3]
800020e6:	30 19       	mov	r9,1
800020e8:	f2 08 18 00 	cp.b	r8,r9
800020ec:	c0 61       	brne	800020f8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800020ee:	49 0c       	lddpc	r12,8000212c <EnOB_reply_func+0x58>
800020f0:	f0 1f 00 10 	mcall	80002130 <EnOB_reply_func+0x5c>
800020f4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800020f8:	58 08       	cp.w	r8,0
800020fa:	c0 61       	brne	80002106 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800020fc:	48 ec       	lddpc	r12,80002134 <EnOB_reply_func+0x60>
800020fe:	f0 1f 00 0d 	mcall	80002130 <EnOB_reply_func+0x5c>
80002102:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002106:	1a d8       	st.w	--sp,r8
80002108:	48 cc       	lddpc	r12,80002138 <EnOB_reply_func+0x64>
8000210a:	f0 1f 00 0a 	mcall	80002130 <EnOB_reply_func+0x5c>
8000210e:	2f fd       	sub	sp,-4
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002114:	48 ac       	lddpc	r12,8000213c <EnOB_reply_func+0x68>
80002116:	f0 1f 00 07 	mcall	80002130 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000211a:	0f a8       	ld.ub	r8,r7[0x2]
8000211c:	1a d8       	st.w	--sp,r8
8000211e:	48 9c       	lddpc	r12,80002140 <EnOB_reply_func+0x6c>
80002120:	f0 1f 00 04 	mcall	80002130 <EnOB_reply_func+0x5c>
80002124:	2f fd       	sub	sp,-4
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	e0 80 80 00 	breq	8001212e <_data_lma+0x2b06>
80002132:	7f 54       	ld.w	r4,pc[0x54]
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	e0 98 80 00 	brls	80032136 <_data_lma+0x22b0e>
8000213a:	e0 ac       	*unknown*
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	e0 c4 80 00 	sub	r4,r0,-32768
80002142:	e0 e0 eb cd 	ld.d	r0,r0[-5171]

80002144 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	eb cd 40 80 	pushm	r7,lr
80002148:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000214a:	19 a9       	ld.ub	r9,r12[0x2]
8000214c:	31 18       	mov	r8,17
8000214e:	f0 09 18 00 	cp.b	r9,r8
80002152:	c0 91       	brne	80002164 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002154:	48 ac       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x38>
80002156:	f0 1f 00 0b 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
8000215a:	30 19       	mov	r9,1
8000215c:	48 a8       	lddpc	r8,80002184 <SingleDetection_brdcst_func+0x40>
8000215e:	b0 89       	st.b	r8[0x0],r9
80002160:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002164:	48 9c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x44>
80002166:	f0 1f 00 07 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
8000216a:	0f a8       	ld.ub	r8,r7[0x2]
8000216c:	1a d8       	st.w	--sp,r8
8000216e:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x48>
80002170:	f0 1f 00 04 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	e0 f8 80 00 	ld.w	r8,r0[-32768]
80002182:	7f 54       	ld.w	r4,pc[0x54]
80002184:	00 00       	add	r0,r0
80002186:	00 08       	add	r8,r0
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	e1 0c 80 00 	ld.sh	r12,r0[-32768]
8000218e:	e1 1c d4 31 	ld.uh	r12,r0[-11215]

80002190 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002190:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002192:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002196:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002198:	4a bc       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xb4>
8000219a:	f0 1f 00 2c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000219e:	0f 88       	ld.ub	r8,r7[0x0]
800021a0:	1a d8       	st.w	--sp,r8
800021a2:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xbc>
800021a4:	f0 1f 00 29 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021a8:	1a d5       	st.w	--sp,r5
800021aa:	4a ac       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xc0>
800021ac:	f0 1f 00 27 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b0:	0f a8       	ld.ub	r8,r7[0x2]
800021b2:	1a d8       	st.w	--sp,r8
800021b4:	4a 8c       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xc4>
800021b6:	f0 1f 00 25 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ba:	2f dd       	sub	sp,-12
800021bc:	58 05       	cp.w	r5,0
800021be:	c4 10       	breq	80002240 <ButtonConfig_brdcst_func+0xb0>
800021c0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c2:	4a 64       	lddpc	r4,80002258 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021c4:	4a 63       	lddpc	r3,8000225c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021c6:	4a 72       	lddpc	r2,80002260 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021c8:	4a 71       	lddpc	r1,80002264 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ca:	4a 80       	lddpc	r0,80002268 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021cc:	0f b9       	ld.ub	r9,r7[0x3]
800021ce:	0f c8       	ld.ub	r8,r7[0x4]
800021d0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d4:	1a d8       	st.w	--sp,r8
800021d6:	1a d6       	st.w	--sp,r6
800021d8:	08 9c       	mov	r12,r4
800021da:	f0 1f 00 1c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021de:	0f d9       	ld.ub	r9,r7[0x5]
800021e0:	0f e8       	ld.ub	r8,r7[0x6]
800021e2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e6:	1a d8       	st.w	--sp,r8
800021e8:	1a d6       	st.w	--sp,r6
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 17 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f0:	0f f9       	ld.ub	r9,r7[0x7]
800021f2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021f6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fa:	1a d8       	st.w	--sp,r8
800021fc:	1a d6       	st.w	--sp,r6
800021fe:	04 9c       	mov	r12,r2
80002200:	f0 1f 00 12 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002204:	ef 39 00 09 	ld.ub	r9,r7[9]
80002208:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000220c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002210:	1a d8       	st.w	--sp,r8
80002212:	1a d6       	st.w	--sp,r6
80002214:	02 9c       	mov	r12,r1
80002216:	f0 1f 00 0d 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221a:	2f 8d       	sub	sp,-32
8000221c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002220:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	00 9c       	mov	r12,r0
8000222e:	f0 1f 00 07 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
80002232:	2f f6       	sub	r6,-1
80002234:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002236:	2f ed       	sub	sp,-8
80002238:	ec 05 18 00 	cp.b	r5,r6
8000223c:	fe 9b ff c8 	brhi	800021cc <ButtonConfig_brdcst_func+0x3c>
80002240:	d8 32       	popm	r0-r7,pc
80002242:	00 00       	add	r0,r0
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	e1 30 80 00 	ld.ub	r0,r0[-32768]
8000224a:	7f 54       	ld.w	r4,pc[0x54]
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	e1 50 80 00 	st.h	r0[-32768],r0
80002252:	e1 64 80 00 	st.b	r0[-32768],r4
80002256:	e1 7c 80 00 	stcond	r0[-32768],r12
8000225a:	e1 9c       	*unknown*
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	e1 c4 80 00 	ldm	r4,pc
80002262:	e1 ec 80 00 	sthh.w	r0[r0],r0:b,r12:b
80002266:	e2 10 80 00 	andl	r0,0x8000,COH
8000226a:	e2 38 eb cd 	sub	r8,256973

8000226c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000226c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002270:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002274:	0f 89       	ld.ub	r9,r7[0x0]
80002276:	30 08       	mov	r8,0
80002278:	f0 09 18 00 	cp.b	r9,r8
8000227c:	c0 c1       	brne	80002294 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000227e:	48 9c       	lddpc	r12,800022a0 <ButtonConfig_reply_func+0x34>
80002280:	f0 1f 00 09 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002284:	0f 98       	ld.ub	r8,r7[0x1]
80002286:	1a d8       	st.w	--sp,r8
80002288:	48 8c       	lddpc	r12,800022a8 <ButtonConfig_reply_func+0x3c>
8000228a:	f0 1f 00 07 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000228e:	2f fd       	sub	sp,-4
80002290:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002294:	48 6c       	lddpc	r12,800022ac <ButtonConfig_reply_func+0x40>
80002296:	f0 1f 00 04 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000229a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000229e:	00 00       	add	r0,r0
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	e2 5c 80 00 	cp.w	r12,229376
800022a6:	7f 54       	ld.w	r4,pc[0x54]
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	e1 50 80 00 	st.h	r0[-32768],r0
800022ae:	e2 74 eb cd 	mov	r4,256973

800022b0 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022b4:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022b8:	0f 89       	ld.ub	r9,r7[0x0]
800022ba:	30 08       	mov	r8,0
800022bc:	f0 09 18 00 	cp.b	r9,r8
800022c0:	c0 40       	breq	800022c8 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022c2:	48 5c       	lddpc	r12,800022d4 <BatteryLevel_brdcst_func+0x24>
800022c4:	f0 1f 00 05 	mcall	800022d8 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	48 58       	lddpc	r8,800022dc <BatteryLevel_brdcst_func+0x2c>
800022cc:	b0 89       	st.b	r8[0x0],r9

}
800022ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	e2 90 80 00 	breq	800722d6 <_data_lma+0x62cae>
800022da:	7f 54       	ld.w	r4,pc[0x54]
800022dc:	00 00       	add	r0,r0
800022de:	0a 88       	andn	r8,r5

800022e0 <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022e2:	19 a8       	ld.ub	r8,r12[0x2]
800022e4:	30 19       	mov	r9,1
800022e6:	f2 08 18 00 	cp.b	r8,r9
800022ea:	c0 51       	brne	800022f4 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
800022ec:	48 6c       	lddpc	r12,80002304 <ShutDown_brdcst_func+0x24>
800022ee:	f0 1f 00 07 	mcall	80002308 <ShutDown_brdcst_func+0x28>
800022f2:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
800022f4:	30 29       	mov	r9,2
800022f6:	f2 08 18 00 	cp.b	r8,r9
800022fa:	c0 41       	brne	80002302 <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
800022fc:	48 4c       	lddpc	r12,8000230c <ShutDown_brdcst_func+0x2c>
800022fe:	f0 1f 00 03 	mcall	80002308 <ShutDown_brdcst_func+0x28>
80002302:	d8 02       	popm	pc
80002304:	80 00       	ld.sh	r0,r0[0x0]
80002306:	e2 a4       	*unknown*
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	7f 54       	ld.w	r4,pc[0x54]
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	e2 b8       	*unknown*

80002310 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002310:	eb cd 40 80 	pushm	r7,lr
80002314:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002316:	19 a9       	ld.ub	r9,r12[0x2]
80002318:	30 08       	mov	r8,0
8000231a:	f0 09 18 00 	cp.b	r9,r8
8000231e:	c0 61       	brne	8000232a <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
80002320:	48 dc       	lddpc	r12,80002354 <DataSession_reply_func+0x44>
80002322:	f0 1f 00 0e 	mcall	80002358 <DataSession_reply_func+0x48>
80002326:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
8000232a:	48 dc       	lddpc	r12,8000235c <DataSession_reply_func+0x4c>
8000232c:	f0 1f 00 0b 	mcall	80002358 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
80002330:	0f a8       	ld.ub	r8,r7[0x2]
80002332:	1a d8       	st.w	--sp,r8
80002334:	48 bc       	lddpc	r12,80002360 <DataSession_reply_func+0x50>
80002336:	f0 1f 00 09 	mcall	80002358 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
8000233a:	0f b8       	ld.ub	r8,r7[0x3]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ac       	lddpc	r12,80002364 <DataSession_reply_func+0x54>
80002340:	f0 1f 00 06 	mcall	80002358 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002344:	0f c8       	ld.ub	r8,r7[0x4]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 8c       	lddpc	r12,80002368 <DataSession_reply_func+0x58>
8000234a:	f0 1f 00 04 	mcall	80002358 <DataSession_reply_func+0x48>
8000234e:	2f dd       	sub	sp,-12
80002350:	e3 cd 80 80 	ldm	sp++,r7,pc
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	e2 c8 80 00 	sub	r8,r1,-32768
8000235a:	7f 54       	ld.w	r4,pc[0x54]
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	e2 d8 80 00 	satsub.w	r8,r1,-32768
80002362:	e2 e8 80 00 	ld.d	r8,r1[-32768]
80002366:	e2 f8 80 00 	ld.w	r8,r1[-32768]
8000236a:	e3 04 eb cd 	ld.sh	r4,r1[-5171]

8000236c <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000236c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002370:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002374:	0f 98       	ld.ub	r8,r7[0x1]
80002376:	1a d8       	st.w	--sp,r8
80002378:	48 bc       	lddpc	r12,800023a4 <CallControl_brdcst_func+0x38>
8000237a:	f0 1f 00 0c 	mcall	800023a8 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000237e:	2f fd       	sub	sp,-4
80002380:	0f 99       	ld.ub	r9,r7[0x1]
80002382:	30 38       	mov	r8,3
80002384:	f0 09 18 00 	cp.b	r9,r8
80002388:	c0 41       	brne	80002390 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000238a:	30 09       	mov	r9,0
8000238c:	48 88       	lddpc	r8,800023ac <CallControl_brdcst_func+0x40>
8000238e:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002390:	0f 99       	ld.ub	r9,r7[0x1]
80002392:	30 48       	mov	r8,4
80002394:	f0 09 18 00 	cp.b	r9,r8
80002398:	c0 41       	brne	800023a0 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000239a:	30 19       	mov	r9,1
8000239c:	48 48       	lddpc	r8,800023ac <CallControl_brdcst_func+0x40>
8000239e:	b0 89       	st.b	r8[0x0],r9
800023a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	e3 10 80 00 	ld.uh	r0,r1[-32768]
800023aa:	7f 54       	ld.w	r4,pc[0x54]
800023ac:	00 00       	add	r0,r0
800023ae:	0a 8a       	andn	r10,r5

800023b0 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023b4:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023b8:	0f 99       	ld.ub	r9,r7[0x1]
800023ba:	30 08       	mov	r8,0
800023bc:	f0 09 18 00 	cp.b	r9,r8
800023c0:	c0 71       	brne	800023ce <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023c2:	48 ac       	lddpc	r12,800023e8 <TransmitControl_brdcst_func+0x38>
800023c4:	f0 1f 00 0a 	mcall	800023ec <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023c8:	30 09       	mov	r9,0
800023ca:	48 a8       	lddpc	r8,800023f0 <TransmitControl_brdcst_func+0x40>
800023cc:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ce:	0f 99       	ld.ub	r9,r7[0x1]
800023d0:	30 18       	mov	r8,1
800023d2:	f0 09 18 00 	cp.b	r9,r8
800023d6:	c0 71       	brne	800023e4 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023d8:	48 7c       	lddpc	r12,800023f4 <TransmitControl_brdcst_func+0x44>
800023da:	f0 1f 00 05 	mcall	800023ec <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023de:	30 19       	mov	r9,1
800023e0:	48 48       	lddpc	r8,800023f0 <TransmitControl_brdcst_func+0x40>
800023e2:	b0 89       	st.b	r8[0x0],r9
800023e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	e3 28 80 00 	ld.sb	r8,r1[-32768]
800023ee:	7f 54       	ld.w	r4,pc[0x54]
800023f0:	00 00       	add	r0,r0
800023f2:	0a 5c       	eor	r12,r5
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	e3 40 eb cd 	st.w	r1[-5171],r0

800023f8 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800023f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800023fc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002400:	0f 89       	ld.ub	r9,r7[0x0]
80002402:	30 08       	mov	r8,0
80002404:	f0 09 18 00 	cp.b	r9,r8
80002408:	c1 61       	brne	80002434 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000240a:	48 ec       	lddpc	r12,80002440 <TransmitControl_reply_func+0x48>
8000240c:	f0 1f 00 0e 	mcall	80002444 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002410:	0f 98       	ld.ub	r8,r7[0x1]
80002412:	1a d8       	st.w	--sp,r8
80002414:	48 dc       	lddpc	r12,80002448 <TransmitControl_reply_func+0x50>
80002416:	f0 1f 00 0c 	mcall	80002444 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000241a:	0f a8       	ld.ub	r8,r7[0x2]
8000241c:	1a d8       	st.w	--sp,r8
8000241e:	48 cc       	lddpc	r12,8000244c <TransmitControl_reply_func+0x54>
80002420:	f0 1f 00 09 	mcall	80002444 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002424:	0f b8       	ld.ub	r8,r7[0x3]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 ac       	lddpc	r12,80002450 <TransmitControl_reply_func+0x58>
8000242a:	f0 1f 00 07 	mcall	80002444 <TransmitControl_reply_func+0x4c>
8000242e:	2f dd       	sub	sp,-12
80002430:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002434:	48 8c       	lddpc	r12,80002454 <TransmitControl_reply_func+0x5c>
80002436:	f0 1f 00 04 	mcall	80002444 <TransmitControl_reply_func+0x4c>
8000243a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000243e:	00 00       	add	r0,r0
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	e3 54 80 00 	st.h	r1[-32768],r4
80002446:	7f 54       	ld.w	r4,pc[0x54]
80002448:	80 00       	ld.sh	r0,r0[0x0]
8000244a:	e3 70 80 00 	stcond	r1[-32768],r0
8000244e:	e3 84       	*unknown*
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	e3 a0 80 00 	cop	cp4,cr0,cr0,cr0,0x20
80002456:	e3 b0       	*unknown*

80002458 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002458:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000245a:	19 a9       	ld.ub	r9,r12[0x2]
8000245c:	30 08       	mov	r8,0
8000245e:	f0 09 18 00 	cp.b	r9,r8
80002462:	c0 51       	brne	8000246c <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002464:	48 4c       	lddpc	r12,80002474 <AudioRoutingControl_reply_func+0x1c>
80002466:	f0 1f 00 05 	mcall	80002478 <AudioRoutingControl_reply_func+0x20>
8000246a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000246c:	48 4c       	lddpc	r12,8000247c <AudioRoutingControl_reply_func+0x24>
8000246e:	f0 1f 00 03 	mcall	80002478 <AudioRoutingControl_reply_func+0x20>
80002472:	d8 02       	popm	pc
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	e3 c8 80 00 	ldm	r8++,pc
8000247a:	7f 54       	ld.w	r4,pc[0x54]
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	e3 d8       	*unknown*

80002480 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002480:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002484:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002488:	0f 89       	ld.ub	r9,r7[0x0]
8000248a:	30 08       	mov	r8,0
8000248c:	f0 09 18 00 	cp.b	r9,r8
80002490:	c1 b1       	brne	800024c6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002492:	0f b8       	ld.ub	r8,r7[0x3]
80002494:	31 09       	mov	r9,16
80002496:	f2 08 18 00 	cp.b	r8,r9
8000249a:	c0 f1       	brne	800024b8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000249c:	48 dc       	lddpc	r12,800024d0 <Volume_reply_func+0x50>
8000249e:	f0 1f 00 0e 	mcall	800024d4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024a2:	0f 99       	ld.ub	r9,r7[0x1]
800024a4:	0f a8       	ld.ub	r8,r7[0x2]
800024a6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024aa:	1a d8       	st.w	--sp,r8
800024ac:	48 bc       	lddpc	r12,800024d8 <Volume_reply_func+0x58>
800024ae:	f0 1f 00 0a 	mcall	800024d4 <Volume_reply_func+0x54>
800024b2:	2f fd       	sub	sp,-4
800024b4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024b8:	1a d8       	st.w	--sp,r8
800024ba:	48 9c       	lddpc	r12,800024dc <Volume_reply_func+0x5c>
800024bc:	f0 1f 00 06 	mcall	800024d4 <Volume_reply_func+0x54>
800024c0:	2f fd       	sub	sp,-4
800024c2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024c6:	48 7c       	lddpc	r12,800024e0 <Volume_reply_func+0x60>
800024c8:	f0 1f 00 03 	mcall	800024d4 <Volume_reply_func+0x54>
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	e3 ec 80 00 	sthh.w	r0[r0],r1:b,r12:b
800024d6:	7f 54       	ld.w	r4,pc[0x54]
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	e4 00       	*unknown*
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	e4 1c 80 00 	andh	r12,0x8000
800024e2:	e4 34 d4 01 	sub	r4,381953

800024e4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024e4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024e6:	19 d9       	ld.ub	r9,r12[0x5]
800024e8:	30 08       	mov	r8,0
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 81       	brne	800024fe <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024f0:	10 99       	mov	r9,r8
800024f2:	48 78       	lddpc	r8,8000250c <spk_brdcst_func+0x28>
800024f4:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800024f6:	48 7c       	lddpc	r12,80002510 <spk_brdcst_func+0x2c>
800024f8:	f0 1f 00 07 	mcall	80002514 <spk_brdcst_func+0x30>
800024fc:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800024fe:	30 19       	mov	r9,1
80002500:	48 38       	lddpc	r8,8000250c <spk_brdcst_func+0x28>
80002502:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002504:	48 5c       	lddpc	r12,80002518 <spk_brdcst_func+0x34>
80002506:	f0 1f 00 04 	mcall	80002514 <spk_brdcst_func+0x30>
8000250a:	d8 02       	popm	pc
8000250c:	00 00       	add	r0,r0
8000250e:	0a 7d       	tst	sp,r5
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	e4 4c 80 00 	cp.w	r12,294912
80002516:	7f 54       	ld.w	r4,pc[0x54]
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	e4 5c d4 01 	cp.w	r12,381953

8000251c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000251e:	19 a9       	ld.ub	r9,r12[0x2]
80002520:	30 08       	mov	r8,0
80002522:	f0 09 18 00 	cp.b	r9,r8
80002526:	c0 f1       	brne	80002544 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002528:	19 e9       	ld.ub	r9,r12[0x6]
8000252a:	f0 09 18 00 	cp.b	r9,r8
8000252e:	c0 40       	breq	80002536 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002530:	30 19       	mov	r9,1
80002532:	48 98       	lddpc	r8,80002554 <spk_reply_func+0x38>
80002534:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002536:	19 e8       	ld.ub	r8,r12[0x6]
80002538:	1a d8       	st.w	--sp,r8
8000253a:	48 8c       	lddpc	r12,80002558 <spk_reply_func+0x3c>
8000253c:	f0 1f 00 08 	mcall	8000255c <spk_reply_func+0x40>
80002540:	2f fd       	sub	sp,-4
80002542:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002544:	30 09       	mov	r9,0
80002546:	48 48       	lddpc	r8,80002554 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000254a:	48 6c       	lddpc	r12,80002560 <spk_reply_func+0x44>
8000254c:	f0 1f 00 04 	mcall	8000255c <spk_reply_func+0x40>
80002550:	d8 02       	popm	pc
80002552:	00 00       	add	r0,r0
80002554:	00 00       	add	r0,r0
80002556:	0a 7d       	tst	sp,r5
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	e4 68 80 00 	mov	r8,294912
8000255e:	7f 54       	ld.w	r4,pc[0x54]
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	e4 78 eb cd 	mov	r8,388045

80002564 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002564:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002568:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000256c:	0f a9       	ld.ub	r9,r7[0x2]
8000256e:	30 08       	mov	r8,0
80002570:	f0 09 18 00 	cp.b	r9,r8
80002574:	c0 71       	brne	80002582 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002576:	48 dc       	lddpc	r12,800025a8 <mic_brdcst_func+0x44>
80002578:	f0 1f 00 0d 	mcall	800025ac <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000257c:	30 09       	mov	r9,0
8000257e:	48 d8       	lddpc	r8,800025b0 <mic_brdcst_func+0x4c>
80002580:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002582:	0f a9       	ld.ub	r9,r7[0x2]
80002584:	31 18       	mov	r8,17
80002586:	f0 09 18 00 	cp.b	r9,r8
8000258a:	c0 d1       	brne	800025a4 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000258c:	48 ac       	lddpc	r12,800025b4 <mic_brdcst_func+0x50>
8000258e:	f0 1f 00 08 	mcall	800025ac <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002592:	48 89       	lddpc	r9,800025b0 <mic_brdcst_func+0x4c>
80002594:	30 18       	mov	r8,1
80002596:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002598:	13 89       	ld.ub	r9,r9[0x0]
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 31       	brne	800025a4 <mic_brdcst_func+0x40>
800025a0:	48 68       	lddpc	r8,800025b8 <mic_brdcst_func+0x54>
800025a2:	11 88       	ld.ub	r8,r8[0x0]
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	e4 84 80 00 	brge	800925aa <_data_lma+0x82f82>
800025ae:	7f 54       	ld.w	r4,pc[0x54]
800025b0:	00 00       	add	r0,r0
800025b2:	0a 7c       	tst	r12,r5
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	e4 98 00 00 	brls	800a25b6 <_data_lma+0x92f8e>
800025ba:	0a 8a       	andn	r10,r5

800025bc <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025bc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025c0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025c4:	49 ac       	lddpc	r12,8000262c <mic_reply_func+0x70>
800025c6:	f0 1f 00 1b 	mcall	80002630 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025ca:	0f 89       	ld.ub	r9,r7[0x0]
800025cc:	30 08       	mov	r8,0
800025ce:	f0 09 18 00 	cp.b	r9,r8
800025d2:	c2 71       	brne	80002620 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025d4:	0f 98       	ld.ub	r8,r7[0x1]
800025d6:	30 29       	mov	r9,2
800025d8:	f2 08 18 00 	cp.b	r8,r9
800025dc:	c1 b1       	brne	80002612 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025de:	49 6c       	lddpc	r12,80002634 <mic_reply_func+0x78>
800025e0:	f0 1f 00 14 	mcall	80002630 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025e4:	0f a8       	ld.ub	r8,r7[0x2]
800025e6:	1a d8       	st.w	--sp,r8
800025e8:	49 4c       	lddpc	r12,80002638 <mic_reply_func+0x7c>
800025ea:	f0 1f 00 12 	mcall	80002630 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025ee:	0f b8       	ld.ub	r8,r7[0x3]
800025f0:	1a d8       	st.w	--sp,r8
800025f2:	49 3c       	lddpc	r12,8000263c <mic_reply_func+0x80>
800025f4:	f0 1f 00 0f 	mcall	80002630 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800025f8:	0f c8       	ld.ub	r8,r7[0x4]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 1c       	lddpc	r12,80002640 <mic_reply_func+0x84>
800025fe:	f0 1f 00 0d 	mcall	80002630 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002602:	0f d8       	ld.ub	r8,r7[0x5]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 0c       	lddpc	r12,80002644 <mic_reply_func+0x88>
80002608:	f0 1f 00 0a 	mcall	80002630 <mic_reply_func+0x74>
8000260c:	2f cd       	sub	sp,-16
8000260e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002612:	1a d8       	st.w	--sp,r8
80002614:	48 dc       	lddpc	r12,80002648 <mic_reply_func+0x8c>
80002616:	f0 1f 00 07 	mcall	80002630 <mic_reply_func+0x74>
8000261a:	2f fd       	sub	sp,-4
8000261c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002620:	48 bc       	lddpc	r12,8000264c <mic_reply_func+0x90>
80002622:	f0 1f 00 04 	mcall	80002630 <mic_reply_func+0x74>
80002626:	e3 cd 80 80 	ldm	sp++,r7,pc
8000262a:	00 00       	add	r0,r0
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	e4 ac       	*unknown*
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	7f 54       	ld.w	r4,pc[0x54]
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	e4 bc       	*unknown*
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	e4 d0 80 00 	satsub.w	r0,r2,-32768
8000263e:	e4 e4 80 00 	ld.d	r4,r2[-32768]
80002642:	e5 00 80 00 	ld.sh	r0,r2[-32768]
80002646:	e5 18 80 00 	ld.uh	r8,r2[-32768]
8000264a:	e5 30 80 00 	ld.ub	r0,r2[-32768]
8000264e:	e5 48 eb cd 	st.w	r2[-5171],r8

80002650 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002650:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002654:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002658:	48 bc       	lddpc	r12,80002684 <dcm_brdcst_func+0x34>
8000265a:	f0 1f 00 0c 	mcall	80002688 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000265e:	0f 88       	ld.ub	r8,r7[0x0]
80002660:	1a d8       	st.w	--sp,r8
80002662:	48 bc       	lddpc	r12,8000268c <dcm_brdcst_func+0x3c>
80002664:	f0 1f 00 09 	mcall	80002688 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002668:	0f a8       	ld.ub	r8,r7[0x2]
8000266a:	1a d8       	st.w	--sp,r8
8000266c:	48 9c       	lddpc	r12,80002690 <dcm_brdcst_func+0x40>
8000266e:	f0 1f 00 07 	mcall	80002688 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002672:	0f 98       	ld.ub	r8,r7[0x1]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 8c       	lddpc	r12,80002694 <dcm_brdcst_func+0x44>
80002678:	f0 1f 00 04 	mcall	80002688 <dcm_brdcst_func+0x38>
8000267c:	2f dd       	sub	sp,-12
	
	
}
8000267e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002682:	00 00       	add	r0,r0
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	e5 58 80 00 	st.h	r2[-32768],r8
8000268a:	7f 54       	ld.w	r4,pc[0x54]
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	e5 6c 80 00 	st.b	r2[-32768],r12
80002692:	e5 80       	*unknown*
80002694:	80 00       	ld.sh	r0,r0[0x0]
80002696:	e5 98       	*unknown*

80002698 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002698:	eb cd 40 80 	pushm	r7,lr
8000269c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000269e:	19 a9       	ld.ub	r9,r12[0x2]
800026a0:	30 08       	mov	r8,0
800026a2:	f0 09 18 00 	cp.b	r9,r8
800026a6:	c1 b1       	brne	800026dc <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026a8:	19 b8       	ld.ub	r8,r12[0x3]
800026aa:	30 19       	mov	r9,1
800026ac:	f2 08 18 00 	cp.b	r8,r9
800026b0:	c0 51       	brne	800026ba <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026b2:	48 ec       	lddpc	r12,800026e8 <dcm_reply_func+0x50>
800026b4:	f0 1f 00 0e 	mcall	800026ec <dcm_reply_func+0x54>
800026b8:	c0 a8       	rjmp	800026cc <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ba:	58 08       	cp.w	r8,0
800026bc:	c0 51       	brne	800026c6 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026be:	48 dc       	lddpc	r12,800026f0 <dcm_reply_func+0x58>
800026c0:	f0 1f 00 0b 	mcall	800026ec <dcm_reply_func+0x54>
800026c4:	c0 48       	rjmp	800026cc <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026c6:	48 cc       	lddpc	r12,800026f4 <dcm_reply_func+0x5c>
800026c8:	f0 1f 00 09 	mcall	800026ec <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026cc:	0f d8       	ld.ub	r8,r7[0x5]
800026ce:	1a d8       	st.w	--sp,r8
800026d0:	48 ac       	lddpc	r12,800026f8 <dcm_reply_func+0x60>
800026d2:	f0 1f 00 07 	mcall	800026ec <dcm_reply_func+0x54>
800026d6:	2f fd       	sub	sp,-4
800026d8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026dc:	48 8c       	lddpc	r12,800026fc <dcm_reply_func+0x64>
800026de:	f0 1f 00 04 	mcall	800026ec <dcm_reply_func+0x54>
800026e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800026e6:	00 00       	add	r0,r0
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	e5 b4       	*unknown*
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	7f 54       	ld.w	r4,pc[0x54]
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	e5 c8 80 00 	ldmts	r8,pc
800026f6:	e5 dc 80 00 	ldswp.w	r12,r2[0]
800026fa:	e5 f0 80 00 	ld.wls	r0,r2[0x0]
800026fe:	e5 fc d4 01 	ld.shvc	r12,r2[0x2]

80002700 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002700:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002702:	19 a9       	ld.ub	r9,r12[0x2]
80002704:	30 08       	mov	r8,0
80002706:	f0 09 18 00 	cp.b	r9,r8
8000270a:	c0 51       	brne	80002714 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
8000270c:	48 4c       	lddpc	r12,8000271c <ToneControl_reply_func+0x1c>
8000270e:	f0 1f 00 05 	mcall	80002720 <ToneControl_reply_func+0x20>
80002712:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002714:	48 4c       	lddpc	r12,80002724 <ToneControl_reply_func+0x24>
80002716:	f0 1f 00 03 	mcall	80002720 <ToneControl_reply_func+0x20>
8000271a:	d8 02       	popm	pc
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	e6 08       	*unknown*
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	7f 54       	ld.w	r4,pc[0x54]
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	e6 14 eb cd 	andh	r4,0xebcd,COH

80002728 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002728:	eb cd 40 c0 	pushm	r6-r7,lr
	xcmp_register_app_list(the_app_list);
8000272c:	49 7c       	lddpc	r12,80002788 <app_init+0x60>
8000272e:	f0 1f 00 18 	mcall	8000278c <app_init+0x64>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002732:	49 8b       	lddpc	r11,80002790 <app_init+0x68>
80002734:	49 8c       	lddpc	r12,80002794 <app_init+0x6c>
80002736:	f0 1f 00 19 	mcall	80002798 <app_init+0x70>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
8000273a:	f0 1f 00 19 	mcall	8000279c <app_init+0x74>
8000273e:	49 98       	lddpc	r8,800027a0 <app_init+0x78>
80002740:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
80002742:	70 08       	ld.w	r8,r8[0x0]
80002744:	58 08       	cp.w	r8,0
80002746:	c0 41       	brne	8000274e <app_init+0x26>
	{
		log("Create the count_mutex semaphore failure\n");
80002748:	49 7c       	lddpc	r12,800027a4 <app_init+0x7c>
8000274a:	f0 1f 00 18 	mcall	800027a8 <app_init+0x80>
	}
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000274e:	30 07       	mov	r7,0
80002750:	1a d7       	st.w	--sp,r7
80002752:	1a d7       	st.w	--sp,r7
80002754:	1a d7       	st.w	--sp,r7
80002756:	30 28       	mov	r8,2
80002758:	0e 99       	mov	r9,r7
8000275a:	e0 6a 02 ee 	mov	r10,750
8000275e:	49 4b       	lddpc	r11,800027ac <app_init+0x84>
80002760:	49 4c       	lddpc	r12,800027b0 <app_init+0x88>
80002762:	f0 1f 00 15 	mcall	800027b4 <app_init+0x8c>
80002766:	49 56       	lddpc	r6,800027b8 <app_init+0x90>
80002768:	8d 0c       	st.w	r6[0x0],r12
	,  750//1024//800//384
	,  NULL
	,  2
	,  NULL );
	
	 res = xTaskCreate(
8000276a:	1a d7       	st.w	--sp,r7
8000276c:	1a d7       	st.w	--sp,r7
8000276e:	1a d7       	st.w	--sp,r7
80002770:	30 18       	mov	r8,1
80002772:	0e 99       	mov	r9,r7
80002774:	e0 6a 03 84 	mov	r10,900
80002778:	49 1b       	lddpc	r11,800027bc <app_init+0x94>
8000277a:	49 2c       	lddpc	r12,800027c0 <app_init+0x98>
8000277c:	f0 1f 00 0e 	mcall	800027b4 <app_init+0x8c>
80002780:	8d 0c       	st.w	r6[0x0],r12
80002782:	2f ad       	sub	sp,-24
	 ,  900
	 ,  NULL
	 ,  1
	 ,  NULL );
	
}
80002784:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002788:	00 00       	add	r0,r0
8000278a:	00 10       	sub	r0,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	48 0c       	lddpc	r12,8000278c <app_init+0x64>
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	20 3c       	sub	r12,3
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 50       	sub	r0,5
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	34 b4       	mov	r4,75
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	74 1c       	ld.w	r12,r10[0x4]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 78       	tst	r8,r5
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	e6 20 80 00 	sub	r0,425984
800027aa:	7f 54       	ld.w	r4,pc[0x54]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	e6 4c 80 00 	cp.w	r12,425984
800027b2:	29 00       	sub	r0,-112
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	7b 90       	ld.w	r0,sp[0x64]
800027b8:	00 00       	add	r0,r0
800027ba:	0a 58       	eor	r8,r5
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	e6 54 80 00 	cp.w	r4,491520
800027c2:	27 c4       	sub	r4,124

800027c4 <send_message>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static void send_message(void * pvParameters)
{
800027c4:	d4 31       	pushm	r0-r7,lr
	static U16 message_count =0;
	U32 destination = DEST;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c6:	32 0c       	mov	r12,32
800027c8:	f0 1f 00 36 	mcall	800028a0 <send_message+0xdc>
800027cc:	18 94       	mov	r4,r12
	static xgflash_status_t status = XG_ERROR;
	
	xLastWakeTime = xTaskGetTickCount();
800027ce:	f0 1f 00 36 	mcall	800028a4 <send_message+0xe0>
800027d2:	4b 68       	lddpc	r8,800028a8 <send_message+0xe4>
800027d4:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
800027d6:	4b 65       	lddpc	r5,800028ac <send_message+0xe8>
			{
				log("get message err : %d\n", status);
			}
		
		}
		else if (Battery_Flag == Battery_Low)
800027d8:	4b 67       	lddpc	r7,800028b0 <send_message+0xec>
800027da:	30 16       	mov	r6,1
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
800027dc:	4b 63       	lddpc	r3,800028b4 <send_message+0xf0>
		{
			log("Current_total_message_count: %d\n", message_count);
800027de:	4b 70       	lddpc	r0,800028b8 <send_message+0xf4>
			if(m_buff==NULL)break;
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
800027e0:	30 12       	mov	r2,1
800027e2:	4b 71       	lddpc	r1,800028bc <send_message+0xf8>
	static  portTickType water_value;
		
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
800027e4:	f0 1f 00 37 	mcall	800028c0 <send_message+0xfc>
800027e8:	5c 8c       	casts.h	r12
800027ea:	aa 0c       	st.h	r5[0x0],r12
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
800027ec:	c4 c0       	breq	80002884 <send_message+0xc0>
800027ee:	0f 88       	ld.ub	r8,r7[0x0]
800027f0:	58 08       	cp.w	r8,0
800027f2:	c4 91       	brne	80002884 <send_message+0xc0>
800027f4:	07 88       	ld.ub	r8,r3[0x0]
800027f6:	58 08       	cp.w	r8,0
800027f8:	c4 60       	breq	80002884 <send_message+0xc0>
		{
			log("Current_total_message_count: %d\n", message_count);
800027fa:	5c 7c       	castu.h	r12
800027fc:	1a dc       	st.w	--sp,r12
800027fe:	00 9c       	mov	r12,r0
80002800:	f0 1f 00 31 	mcall	800028c4 <send_message+0x100>
			if(m_buff==NULL)break;
80002804:	2f fd       	sub	sp,-4
80002806:	58 04       	cp.w	r4,0
80002808:	c4 b0       	breq	8000289e <send_message+0xda>
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
8000280a:	04 9a       	mov	r10,r2
8000280c:	08 9b       	mov	r11,r4
8000280e:	8a 8c       	ld.uh	r12,r5[0x0]
80002810:	f0 1f 00 2e 	mcall	800028c8 <send_message+0x104>
80002814:	83 0c       	st.w	r1[0x0],r12
			if(status == XG_OK)
80002816:	c3 11       	brne	80002878 <send_message+0xb4>
			{
				xcmp_data_session_req(m_buff, (sizeof(Message_Protocol_t)), destination);//send message
80002818:	36 4a       	mov	r10,100
8000281a:	32 0b       	mov	r11,32
8000281c:	08 9c       	mov	r12,r4
8000281e:	f0 1f 00 2c 	mcall	800028cc <send_message+0x108>
				
				//if(xSemaphoreTake(SendM_CountingSemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
				if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
80002822:	4a c8       	lddpc	r8,800028d0 <send_message+0x10c>
80002824:	70 0c       	ld.w	r12,r8[0x0]
80002826:	30 09       	mov	r9,0
80002828:	e0 6a 9c 40 	mov	r10,40000
8000282c:	12 9b       	mov	r11,r9
8000282e:	f0 1f 00 2a 	mcall	800028d4 <send_message+0x110>
80002832:	58 1c       	cp.w	r12,1
80002834:	c0 91       	brne	80002846 <send_message+0x82>
				{
					log("xSemaphoreTake okay!\n");
80002836:	4a 9c       	lddpc	r12,800028d8 <send_message+0x114>
80002838:	f0 1f 00 23 	mcall	800028c4 <send_message+0x100>
					vTaskDelay((1500*2) / portTICK_RATE_MS);
8000283c:	e0 6c 0b b8 	mov	r12,3000
80002840:	f0 1f 00 27 	mcall	800028dc <send_message+0x118>
80002844:	c2 78       	rjmp	80002892 <send_message+0xce>
				}
				else//短信丢失，手台未响应，超时后默认再次重发
				{
					log("xSemaphoreTake failure!\n");
80002846:	4a 7c       	lddpc	r12,800028e0 <send_message+0x11c>
80002848:	f0 1f 00 1f 	mcall	800028c4 <send_message+0x100>
					xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
8000284c:	e0 6b 00 b7 	mov	r11,183
80002850:	04 9c       	mov	r12,r2
80002852:	f0 1f 00 25 	mcall	800028e4 <send_message+0x120>
					status = xgflash_message_save(m_buff, sizeof(Message_Protocol_t), TRUE);
80002856:	04 9a       	mov	r10,r2
80002858:	32 0b       	mov	r11,32
8000285a:	08 9c       	mov	r12,r4
8000285c:	f0 1f 00 23 	mcall	800028e8 <send_message+0x124>
80002860:	83 0c       	st.w	r1[0x0],r12
					if(status == XG_OK)
80002862:	c0 51       	brne	8000286c <send_message+0xa8>
					{
						log("save message-2 okay\n");
80002864:	4a 2c       	lddpc	r12,800028ec <send_message+0x128>
80002866:	f0 1f 00 18 	mcall	800028c4 <send_message+0x100>
8000286a:	c1 48       	rjmp	80002892 <send_message+0xce>
					}
					else
					{
						log("!!!save message err : %d\n", status);
8000286c:	1a dc       	st.w	--sp,r12
8000286e:	4a 1c       	lddpc	r12,800028f0 <send_message+0x12c>
80002870:	f0 1f 00 15 	mcall	800028c4 <send_message+0x100>
80002874:	2f fd       	sub	sp,-4
80002876:	c0 e8       	rjmp	80002892 <send_message+0xce>
				
				}
			}
			else
			{
				log("get message err : %d\n", status);
80002878:	1a dc       	st.w	--sp,r12
8000287a:	49 fc       	lddpc	r12,800028f4 <send_message+0x130>
8000287c:	f0 1f 00 12 	mcall	800028c4 <send_message+0x100>
80002880:	2f fd       	sub	sp,-4
80002882:	c0 88       	rjmp	80002892 <send_message+0xce>
			}
		
		}
		else if (Battery_Flag == Battery_Low)
80002884:	0f 88       	ld.ub	r8,r7[0x0]
80002886:	ec 08 18 00 	cp.b	r8,r6
8000288a:	c0 41       	brne	80002892 <send_message+0xce>
		{
			log("The device battery level is low !\n");
8000288c:	49 bc       	lddpc	r12,800028f8 <send_message+0x134>
8000288e:	f0 1f 00 0e 	mcall	800028c4 <send_message+0x100>
		}
		
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("send-thread water_value: %d\n", water_value);
		vTaskDelayUntil( &xLastWakeTime, (5000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002892:	e0 6b 27 10 	mov	r11,10000
80002896:	48 5c       	lddpc	r12,800028a8 <send_message+0xe4>
80002898:	f0 1f 00 19 	mcall	800028fc <send_message+0x138>
	
	}
8000289c:	ca 4b       	rjmp	800027e4 <send_message+0x20>
8000289e:	d8 32       	popm	r0-r7,pc
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	6f c8       	ld.w	r8,r7[0x70]
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	78 80       	ld.w	r0,r12[0x20]
800028a8:	00 00       	add	r0,r0
800028aa:	0a 64       	and	r4,r5
800028ac:	00 00       	add	r0,r0
800028ae:	0a 60       	and	r0,r5
800028b0:	00 00       	add	r0,r0
800028b2:	0a 88       	andn	r8,r5
800028b4:	00 00       	add	r0,r0
800028b6:	0a 68       	and	r8,r5
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	e6 5c 00 00 	cp.w	r12,458752
800028be:	00 0c       	add	r12,r0
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	62 8c       	ld.w	r12,r1[0x20]
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	7f 54       	ld.w	r4,pc[0x54]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	5f ac       	srle	r12
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	48 60       	lddpc	r0,800028e4 <send_message+0x120>
800028d0:	00 00       	add	r0,r0
800028d2:	0b a4       	ld.ub	r4,r5[0x2]
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	71 10       	ld.w	r0,r8[0x44]
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	e6 80 80 00 	breq	800d28da <_data_lma+0xc32b2>
800028de:	79 e8       	ld.w	r8,r12[0x78]
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	e6 98 80 00 	brls	800f28e2 <_data_lma+0xe32ba>
800028e6:	49 9c       	lddpc	r12,80002948 <app_cfg+0x48>
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	60 fc       	ld.w	r12,r0[0x3c]
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	e6 b4       	*unknown*
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	e6 cc 80 00 	sub	r12,r3,-32768
800028f6:	e6 e8 80 00 	ld.d	r8,r3[-32768]
800028fa:	e7 00 80 00 	ld.sh	r0,r3[-32768]
800028fe:	7a 30       	ld.w	r0,sp[0xc]

80002900 <app_cfg>:
}

static __app_Thread_(app_cfg)
{
80002900:	d4 31       	pushm	r0-r7,lr
80002902:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
80002904:	f0 1f 00 4d 	mcall	80002a38 <app_cfg+0x138>
80002908:	4c d8       	lddpc	r8,80002a3c <app_cfg+0x13c>
8000290a:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
8000290c:	4c d7       	lddpc	r7,80002a40 <app_cfg+0x140>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000290e:	4c e5       	lddpc	r5,80002a44 <app_cfg+0x144>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
80002910:	32 01       	mov	r1,32
80002912:	30 06       	mov	r6,0
						}
			break;
			case OB_WAITINGAPPTASK:
			
					//if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, 0))
80002914:	4c d4       	lddpc	r4,80002a48 <app_cfg+0x148>
	xLastWakeTime = xTaskGetTickCount();
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002916:	6e 08       	ld.w	r8,r7[0x0]
80002918:	58 28       	cp.w	r8,2
8000291a:	c3 90       	breq	8000298c <app_cfg+0x8c>
8000291c:	58 38       	cp.w	r8,3
8000291e:	c4 60       	breq	800029aa <app_cfg+0xaa>
80002920:	58 08       	cp.w	r8,0
80002922:	e0 81 00 84 	brne	80002a2a <app_cfg+0x12a>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002926:	4c a8       	lddpc	r8,80002a4c <app_cfg+0x14c>
80002928:	70 08       	ld.w	r8,r8[0x0]
8000292a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000292e:	58 38       	cp.w	r8,3
80002930:	c1 61       	brne	8000295c <app_cfg+0x5c>
80002932:	4c 88       	lddpc	r8,80002a50 <app_cfg+0x150>
80002934:	11 88       	ld.ub	r8,r8[0x0]
80002936:	58 08       	cp.w	r8,0
80002938:	c1 21       	brne	8000295c <app_cfg+0x5c>
				{
					connect_flag=1;
8000293a:	30 19       	mov	r9,1
8000293c:	4c 58       	lddpc	r8,80002a50 <app_cfg+0x150>
8000293e:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002940:	30 cb       	mov	r11,12
80002942:	30 1c       	mov	r12,1
80002944:	f0 1f 00 44 	mcall	80002a54 <app_cfg+0x154>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002948:	30 cb       	mov	r11,12
8000294a:	30 1c       	mov	r12,1
8000294c:	f0 1f 00 42 	mcall	80002a54 <app_cfg+0x154>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002950:	30 28       	mov	r8,2
80002952:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
80002954:	4c 1c       	lddpc	r12,80002a58 <app_cfg+0x158>
80002956:	f0 1f 00 42 	mcall	80002a5c <app_cfg+0x15c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000295a:	c6 88       	rjmp	80002a2a <app_cfg+0x12a>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
8000295c:	d7 03       	nop
					nop();
8000295e:	d7 03       	nop
					nop();
80002960:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002962:	4c 0c       	lddpc	r12,80002a60 <app_cfg+0x160>
80002964:	f0 1f 00 3e 	mcall	80002a5c <app_cfg+0x15c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
80002968:	4b f8       	lddpc	r8,80002a64 <app_cfg+0x164>
8000296a:	11 d2       	ld.ub	r2,r8[0x5]
8000296c:	11 cc       	ld.ub	r12,r8[0x4]
8000296e:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
80002970:	11 aa       	ld.ub	r10,r8[0x2]
80002972:	11 99       	ld.ub	r9,r8[0x1]
80002974:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
80002976:	1a d2       	st.w	--sp,r2
80002978:	1a dc       	st.w	--sp,r12
8000297a:	1a db       	st.w	--sp,r11
8000297c:	1a da       	st.w	--sp,r10
8000297e:	1a d9       	st.w	--sp,r9
80002980:	1a d8       	st.w	--sp,r8
80002982:	4b ac       	lddpc	r12,80002a68 <app_cfg+0x168>
80002984:	f0 1f 00 36 	mcall	80002a5c <app_cfg+0x15c>
80002988:	2f ad       	sub	sp,-24
8000298a:	c5 08       	rjmp	80002a2a <app_cfg+0x12a>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000298c:	0b 88       	ld.ub	r8,r5[0x0]
8000298e:	58 08       	cp.w	r8,0
80002990:	c0 70       	breq	8000299e <app_cfg+0x9e>
							
							OB_State = OB_WAITINGAPPTASK;
80002992:	30 38       	mov	r8,3
80002994:	8f 08       	st.w	r7[0x0],r8
							log("get time okay!\n");
80002996:	4b 6c       	lddpc	r12,80002a6c <app_cfg+0x16c>
80002998:	f0 1f 00 31 	mcall	80002a5c <app_cfg+0x15c>
8000299c:	c4 78       	rjmp	80002a2a <app_cfg+0x12a>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000299e:	36 4a       	mov	r10,100
800029a0:	02 9b       	mov	r11,r1
800029a2:	0c 9c       	mov	r12,r6
800029a4:	f0 1f 00 33 	mcall	80002a70 <app_cfg+0x170>
800029a8:	c4 18       	rjmp	80002a2a <app_cfg+0x12a>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					//if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, 0))
800029aa:	68 0c       	ld.w	r12,r4[0x0]
800029ac:	0c 99       	mov	r9,r6
800029ae:	0c 9a       	mov	r10,r6
800029b0:	1a 9b       	mov	r11,sp
800029b2:	f0 1f 00 31 	mcall	80002a74 <app_cfg+0x174>
800029b6:	58 1c       	cp.w	r12,1
800029b8:	c3 51       	brne	80002a22 <app_cfg+0x122>
					{
						if(data_ptr!=NULL){//save message
800029ba:	40 08       	lddsp	r8,sp[0x0]
800029bc:	58 08       	cp.w	r8,0
800029be:	c3 20       	breq	80002a22 <app_cfg+0x122>
							
							log("receive okay!\n");
800029c0:	4a ec       	lddpc	r12,80002a78 <app_cfg+0x178>
800029c2:	f0 1f 00 27 	mcall	80002a5c <app_cfg+0x15c>
							xSemaphoreTake(count_mutex, portMAX_DELAY);
800029c6:	4a e0       	lddpc	r0,80002a7c <app_cfg+0x17c>
800029c8:	60 0c       	ld.w	r12,r0[0x0]
800029ca:	0c 99       	mov	r9,r6
800029cc:	3f fa       	mov	r10,-1
800029ce:	0c 9b       	mov	r11,r6
800029d0:	f0 1f 00 29 	mcall	80002a74 <app_cfg+0x174>
							global_count--;
800029d4:	4a b2       	lddpc	r2,80002a80 <app_cfg+0x180>
800029d6:	64 08       	ld.w	r8,r2[0x0]
800029d8:	20 18       	sub	r8,1
800029da:	85 08       	st.w	r2[0x0],r8
							xSemaphoreGive(count_mutex);
800029dc:	60 0c       	ld.w	r12,r0[0x0]
800029de:	0c 99       	mov	r9,r6
800029e0:	0c 9a       	mov	r10,r6
800029e2:	0c 9b       	mov	r11,r6
800029e4:	f0 1f 00 28 	mcall	80002a84 <app_cfg+0x184>
							log("global_count:%d\n", global_count);
800029e8:	64 08       	ld.w	r8,r2[0x0]
800029ea:	1a d8       	st.w	--sp,r8
800029ec:	4a 7c       	lddpc	r12,80002a88 <app_cfg+0x188>
800029ee:	f0 1f 00 1c 	mcall	80002a5c <app_cfg+0x15c>
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							status = xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
800029f2:	30 1a       	mov	r10,1
800029f4:	02 9b       	mov	r11,r1
800029f6:	40 1c       	lddsp	r12,sp[0x4]
800029f8:	f0 1f 00 25 	mcall	80002a8c <app_cfg+0x18c>
800029fc:	4a 58       	lddpc	r8,80002a90 <app_cfg+0x190>
800029fe:	91 0c       	st.w	r8[0x0],r12
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
							if(status == XG_OK)
80002a00:	2f fd       	sub	sp,-4
80002a02:	58 0c       	cp.w	r12,0
80002a04:	c0 51       	brne	80002a0e <app_cfg+0x10e>
							{
								log("save message okay\n");
80002a06:	4a 4c       	lddpc	r12,80002a94 <app_cfg+0x194>
80002a08:	f0 1f 00 15 	mcall	80002a5c <app_cfg+0x15c>
80002a0c:	c0 68       	rjmp	80002a18 <app_cfg+0x118>
							}
							else
							{
								log("!!! save message err : %d\n", status);
80002a0e:	1a dc       	st.w	--sp,r12
80002a10:	4a 2c       	lddpc	r12,80002a98 <app_cfg+0x198>
80002a12:	f0 1f 00 13 	mcall	80002a5c <app_cfg+0x15c>
80002a16:	2f fd       	sub	sp,-4
									
							}
							set_message_store(data_ptr);
80002a18:	4a 18       	lddpc	r8,80002a9c <app_cfg+0x19c>
80002a1a:	70 0c       	ld.w	r12,r8[0x0]
80002a1c:	40 0b       	lddsp	r11,sp[0x0]
80002a1e:	f0 1f 00 21 	mcall	80002aa0 <app_cfg+0x1a0>
							
						}
						
					}						
											
					nop();
80002a22:	d7 03       	nop
					//water_value = uxTaskGetStackHighWaterMark(NULL);
					//log("app-thread water_value: %d\n", water_value);
					log("app task run!\n");
80002a24:	4a 0c       	lddpc	r12,80002aa4 <app_cfg+0x1a4>
80002a26:	f0 1f 00 0e 	mcall	80002a5c <app_cfg+0x15c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (1500*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002a2a:	e0 6b 0b b8 	mov	r11,3000
80002a2e:	48 4c       	lddpc	r12,80002a3c <app_cfg+0x13c>
80002a30:	f0 1f 00 1e 	mcall	80002aa8 <app_cfg+0x1a8>
	}
80002a34:	c7 1b       	rjmp	80002916 <app_cfg+0x16>
80002a36:	00 00       	add	r0,r0
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	78 80       	ld.w	r0,r12[0x20]
80002a3c:	00 00       	add	r0,r0
80002a3e:	0a 80       	andn	r0,r5
80002a40:	00 00       	add	r0,r0
80002a42:	0a 6c       	and	r12,r5
80002a44:	00 00       	add	r0,r0
80002a46:	00 08       	add	r8,r0
80002a48:	00 00       	add	r0,r0
80002a4a:	0b 94       	ld.ub	r4,r5[0x1]
80002a4c:	00 00       	add	r0,r0
80002a4e:	0e 20       	rsub	r0,r7
80002a50:	00 00       	add	r0,r0
80002a52:	0a 68       	and	r8,r5
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	49 9c       	lddpc	r12,80002ab8 <Phyuserinput_brdcst_func+0xc>
80002a58:	80 00       	ld.sh	r0,r0[0x0]
80002a5a:	e7 24 80 00 	ld.sb	r4,r3[-32768]
80002a5e:	7f 54       	ld.w	r4,pc[0x54]
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	e7 38 00 00 	ld.ub	r8,r3[0]
80002a66:	0e 24       	rsub	r4,r7
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	e7 48 80 00 	st.w	r3[-32768],r8
80002a6e:	e7 74 80 00 	stcond	r3[-32768],r4
80002a72:	48 60       	lddpc	r0,80002a88 <app_cfg+0x188>
80002a74:	80 00       	ld.sh	r0,r0[0x0]
80002a76:	71 10       	ld.w	r0,r8[0x44]
80002a78:	80 00       	ld.sh	r0,r0[0x0]
80002a7a:	e7 84       	*unknown*
80002a7c:	00 00       	add	r0,r0
80002a7e:	0a 78       	tst	r8,r5
80002a80:	00 00       	add	r0,r0
80002a82:	0a 84       	andn	r4,r5
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	73 1c       	ld.w	r12,r9[0x44]
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	e7 94       	*unknown*
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	60 fc       	ld.w	r12,r0[0x3c]
80002a90:	00 00       	add	r0,r0
80002a92:	00 04       	add	r4,r0
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	e7 a8 80 00 	cop	cp4,cr0,cr0,cr0,0x70
80002a9a:	e7 bc 00 00 	mtdr	0x0,r12
80002a9e:	0b a0       	ld.ub	r0,r5[0x2]
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	35 34       	mov	r4,83
80002aa4:	80 00       	ld.sh	r0,r0[0x0]
80002aa6:	e7 d8 80 00 	ldswp.w	r8,r3[0]
80002aaa:	7a 30       	ld.w	r0,sp[0xc]

80002aac <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002aac:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002ab0:	19 c7       	ld.ub	r7,r12[0x4]
80002ab2:	19 d8       	ld.ub	r8,r12[0x5]
80002ab4:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002ab8:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002aba:	48 dc       	lddpc	r12,80002aec <Phyuserinput_brdcst_func+0x40>
80002abc:	f0 1f 00 0d 	mcall	80002af0 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002ac0:	36 08       	mov	r8,96
80002ac2:	f0 07 19 00 	cp.h	r7,r8
80002ac6:	c1 11       	brne	80002ae8 <Phyuserinput_brdcst_func+0x3c>
80002ac8:	48 b8       	lddpc	r8,80002af4 <Phyuserinput_brdcst_func+0x48>
80002aca:	11 89       	ld.ub	r9,r8[0x0]
80002acc:	30 18       	mov	r8,1
80002ace:	f0 09 18 00 	cp.b	r9,r8
80002ad2:	c0 b1       	brne	80002ae8 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002ad4:	34 5b       	mov	r11,69
80002ad6:	30 1c       	mov	r12,1
80002ad8:	f0 1f 00 08 	mcall	80002af8 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002adc:	e0 6c 07 d0 	mov	r12,2000
80002ae0:	f0 1f 00 07 	mcall	80002afc <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message		
		scan_rfid_save_message();
80002ae4:	f0 1f 00 07 	mcall	80002b00 <Phyuserinput_brdcst_func+0x54>
80002ae8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002aec:	80 00       	ld.sh	r0,r0[0x0]
80002aee:	e7 e8 80 00 	sthh.w	r0[r0],r3:b,r8:b
80002af2:	7f 54       	ld.w	r4,pc[0x54]
80002af4:	00 00       	add	r0,r0
80002af6:	0a 68       	and	r8,r5
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	49 9c       	lddpc	r12,80002b5c <DataSession_brdcst_func+0x58>
80002afc:	80 00       	ld.sh	r0,r0[0x0]
80002afe:	79 e8       	ld.w	r8,r12[0x78]
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	59 dc       	cp.w	r12,29

80002b04 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b04:	d4 21       	pushm	r4-r7,lr
80002b06:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002b08:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002b0c:	0d 88       	ld.ub	r8,r6[0x0]
80002b0e:	32 49       	mov	r9,36
80002b10:	f2 08 18 00 	cp.b	r8,r9
80002b14:	c2 a1       	brne	80002b68 <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002b16:	4c fc       	lddpc	r12,80002c50 <DataSession_brdcst_func+0x14c>
80002b18:	f0 1f 00 4f 	mcall	80002c54 <DataSession_brdcst_func+0x150>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002b1c:	0d a5       	ld.ub	r5,r6[0x2]
80002b1e:	0d b8       	ld.ub	r8,r6[0x3]
80002b20:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002b24:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002b26:	0d 98       	ld.ub	r8,r6[0x1]
80002b28:	1a d8       	st.w	--sp,r8
80002b2a:	4c cc       	lddpc	r12,80002c58 <DataSession_brdcst_func+0x154>
80002b2c:	f0 1f 00 4a 	mcall	80002c54 <DataSession_brdcst_func+0x150>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002b30:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002b34:	1a d8       	st.w	--sp,r8
80002b36:	4c ac       	lddpc	r12,80002c5c <DataSession_brdcst_func+0x158>
80002b38:	f0 1f 00 47 	mcall	80002c54 <DataSession_brdcst_func+0x150>
		for(i=0; i<data_length; i++)
80002b3c:	2f ed       	sub	sp,-8
80002b3e:	58 05       	cp.w	r5,0
80002b40:	e0 80 00 85 	breq	80002c4a <DataSession_brdcst_func+0x146>
80002b44:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002b46:	4c 74       	lddpc	r4,80002c60 <DataSession_brdcst_func+0x15c>
80002b48:	ec 07 00 08 	add	r8,r6,r7
80002b4c:	11 c8       	ld.ub	r8,r8[0x4]
80002b4e:	1a d8       	st.w	--sp,r8
80002b50:	1a d7       	st.w	--sp,r7
80002b52:	08 9c       	mov	r12,r4
80002b54:	f0 1f 00 40 	mcall	80002c54 <DataSession_brdcst_func+0x150>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002b58:	2f f7       	sub	r7,-1
80002b5a:	5c 57       	castu.b	r7
80002b5c:	2f ed       	sub	sp,-8
80002b5e:	ee 05 19 00 	cp.h	r5,r7
80002b62:	fe 9b ff f3 	brhi	80002b48 <DataSession_brdcst_func+0x44>
80002b66:	c7 28       	rjmp	80002c4a <DataSession_brdcst_func+0x146>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002b68:	1a d8       	st.w	--sp,r8
80002b6a:	4b fc       	lddpc	r12,80002c64 <DataSession_brdcst_func+0x160>
80002b6c:	f0 1f 00 3a 	mcall	80002c54 <DataSession_brdcst_func+0x150>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002b70:	0d 88       	ld.ub	r8,r6[0x0]
80002b72:	2f fd       	sub	sp,-4
80002b74:	30 39       	mov	r9,3
80002b76:	f2 08 18 00 	cp.b	r8,r9
80002b7a:	c0 d1       	brne	80002b94 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002b7c:	4b bc       	lddpc	r12,80002c68 <DataSession_brdcst_func+0x164>
80002b7e:	f0 1f 00 36 	mcall	80002c54 <DataSession_brdcst_func+0x150>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002b82:	e0 6c 07 d0 	mov	r12,2000
80002b86:	f0 1f 00 3a 	mcall	80002c6c <DataSession_brdcst_func+0x168>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002b8a:	37 7b       	mov	r11,119
80002b8c:	30 1c       	mov	r12,1
80002b8e:	f0 1f 00 39 	mcall	80002c70 <DataSession_brdcst_func+0x16c>
80002b92:	c4 98       	rjmp	80002c24 <DataSession_brdcst_func+0x120>

		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002b94:	30 49       	mov	r9,4
80002b96:	f2 08 18 00 	cp.b	r8,r9
80002b9a:	c4 51       	brne	80002c24 <DataSession_brdcst_func+0x120>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002b9c:	32 0a       	mov	r10,32
80002b9e:	ec cb ff fc 	sub	r11,r6,-4
80002ba2:	1a 9c       	mov	r12,sp
80002ba4:	f0 1f 00 34 	mcall	80002c74 <DataSession_brdcst_func+0x170>
			//log("data transmit failure\n");
			//log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			Message_Protocol_t * myptr = get_message_store();	
80002ba8:	4b 48       	lddpc	r8,80002c78 <DataSession_brdcst_func+0x174>
80002baa:	70 0c       	ld.w	r12,r8[0x0]
80002bac:	f0 1f 00 34 	mcall	80002c7c <DataSession_brdcst_func+0x178>
80002bb0:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002bb2:	c3 10       	breq	80002c14 <DataSession_brdcst_func+0x110>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002bb4:	32 0a       	mov	r10,32
80002bb6:	1a 9b       	mov	r11,sp
80002bb8:	f0 1f 00 2f 	mcall	80002c74 <DataSession_brdcst_func+0x170>
				//xQueueSend(xg_resend_queue, &myptr, 0);
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002bbc:	4b 18       	lddpc	r8,80002c80 <DataSession_brdcst_func+0x17c>
80002bbe:	70 0c       	ld.w	r12,r8[0x0]
80002bc0:	30 09       	mov	r9,0
80002bc2:	12 9a       	mov	r10,r9
80002bc4:	fa cb ff e0 	sub	r11,sp,-32
80002bc8:	f0 1f 00 2f 	mcall	80002c84 <DataSession_brdcst_func+0x180>
80002bcc:	58 1c       	cp.w	r12,1
80002bce:	c1 10       	breq	80002bf0 <DataSession_brdcst_func+0xec>
				{
					log("xg_resend_queue: full\n" );
80002bd0:	4a ec       	lddpc	r12,80002c88 <DataSession_brdcst_func+0x184>
80002bd2:	f0 1f 00 21 	mcall	80002c54 <DataSession_brdcst_func+0x150>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002bd6:	32 3b       	mov	r11,35
80002bd8:	30 1c       	mov	r12,1
80002bda:	f0 1f 00 26 	mcall	80002c70 <DataSession_brdcst_func+0x16c>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002bde:	e0 6c 17 70 	mov	r12,6000
80002be2:	f0 1f 00 23 	mcall	80002c6c <DataSession_brdcst_func+0x168>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002be6:	32 3b       	mov	r11,35
80002be8:	30 0c       	mov	r12,0
80002bea:	f0 1f 00 22 	mcall	80002c70 <DataSession_brdcst_func+0x16c>
80002bee:	c1 68       	rjmp	80002c1a <DataSession_brdcst_func+0x116>
				}
				else
				{
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002bf0:	4a 77       	lddpc	r7,80002c8c <DataSession_brdcst_func+0x188>
80002bf2:	6e 0c       	ld.w	r12,r7[0x0]
80002bf4:	30 09       	mov	r9,0
80002bf6:	3f fa       	mov	r10,-1
80002bf8:	12 9b       	mov	r11,r9
80002bfa:	f0 1f 00 26 	mcall	80002c90 <DataSession_brdcst_func+0x18c>
					global_count++;
80002bfe:	4a 68       	lddpc	r8,80002c94 <DataSession_brdcst_func+0x190>
80002c00:	70 09       	ld.w	r9,r8[0x0]
80002c02:	2f f9       	sub	r9,-1
80002c04:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002c06:	6e 0c       	ld.w	r12,r7[0x0]
80002c08:	30 09       	mov	r9,0
80002c0a:	12 9a       	mov	r10,r9
80002c0c:	12 9b       	mov	r11,r9
80002c0e:	f0 1f 00 1e 	mcall	80002c84 <DataSession_brdcst_func+0x180>
80002c12:	c0 48       	rjmp	80002c1a <DataSession_brdcst_func+0x116>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002c14:	4a 1c       	lddpc	r12,80002c98 <DataSession_brdcst_func+0x194>
80002c16:	f0 1f 00 10 	mcall	80002c54 <DataSession_brdcst_func+0x150>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002c1a:	e0 6b 00 b7 	mov	r11,183
80002c1e:	30 1c       	mov	r12,1
80002c20:	f0 1f 00 14 	mcall	80002c70 <DataSession_brdcst_func+0x16c>
			
		}
		
		if((ptr->State == DATA_SESSION_TX_Fail) || (ptr->State == DATA_SESSION_TX_Suc))
80002c24:	0d 89       	ld.ub	r9,r6[0x0]
80002c26:	20 39       	sub	r9,3
80002c28:	30 18       	mov	r8,1
80002c2a:	f0 09 18 00 	cp.b	r9,r8
80002c2e:	e0 8b 00 0e 	brhi	80002c4a <DataSession_brdcst_func+0x146>
		{		
			//if( xSemaphoreGive( SendM_CountingSemaphore ) != pdTRUE )
			if( xSemaphoreGive( xBinarySemaphore ) != pdTRUE )
80002c32:	49 b8       	lddpc	r8,80002c9c <DataSession_brdcst_func+0x198>
80002c34:	70 0c       	ld.w	r12,r8[0x0]
80002c36:	30 09       	mov	r9,0
80002c38:	12 9a       	mov	r10,r9
80002c3a:	12 9b       	mov	r11,r9
80002c3c:	f0 1f 00 12 	mcall	80002c84 <DataSession_brdcst_func+0x180>
80002c40:	58 1c       	cp.w	r12,1
80002c42:	c0 40       	breq	80002c4a <DataSession_brdcst_func+0x146>
			{
				log("xSemaphoreGive: err\n\r" );
80002c44:	49 7c       	lddpc	r12,80002ca0 <DataSession_brdcst_func+0x19c>
80002c46:	f0 1f 00 04 	mcall	80002c54 <DataSession_brdcst_func+0x150>
				//
		//}
		
	}
	
}
80002c4a:	2f 7d       	sub	sp,-36
80002c4c:	d8 22       	popm	r4-r7,pc
80002c4e:	00 00       	add	r0,r0
80002c50:	80 00       	ld.sh	r0,r0[0x0]
80002c52:	e8 08       	*unknown*
80002c54:	80 00       	ld.sh	r0,r0[0x0]
80002c56:	7f 54       	ld.w	r4,pc[0x54]
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	e8 1c 80 00 	orl	r12,0x8000
80002c5e:	e8 34 80 00 	sub	r4,622592
80002c62:	e8 50 80 00 	cp.w	r0,622592
80002c66:	e8 68 80 00 	mov	r8,557056
80002c6a:	e8 74 80 00 	mov	r4,622592
80002c6e:	79 e8       	ld.w	r8,r12[0x78]
80002c70:	80 00       	ld.sh	r0,r0[0x0]
80002c72:	49 9c       	lddpc	r12,80002cd4 <DeviceInitializationStatus_brdcst_func+0x30>
80002c74:	80 00       	ld.sh	r0,r0[0x0]
80002c76:	87 fe       	st.w	r3[0x3c],lr
80002c78:	00 00       	add	r0,r0
80002c7a:	0b a0       	ld.ub	r0,r5[0x2]
80002c7c:	80 00       	ld.sh	r0,r0[0x0]
80002c7e:	36 e0       	mov	r0,110
80002c80:	00 00       	add	r0,r0
80002c82:	0b 94       	ld.ub	r4,r5[0x1]
80002c84:	80 00       	ld.sh	r0,r0[0x0]
80002c86:	73 1c       	ld.w	r12,r9[0x44]
80002c88:	80 00       	ld.sh	r0,r0[0x0]
80002c8a:	e8 8c 00 00 	brvs	80102c8a <_data_lma+0xf3662>
80002c8e:	0a 78       	tst	r8,r5
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	71 10       	ld.w	r0,r8[0x44]
80002c94:	00 00       	add	r0,r0
80002c96:	0a 84       	andn	r4,r5
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	e8 a4       	*unknown*
80002c9c:	00 00       	add	r0,r0
80002c9e:	0b a4       	ld.ub	r4,r5[0x2]
80002ca0:	80 00       	ld.sh	r0,r0[0x0]
80002ca2:	e8 b4       	*unknown*

80002ca4 <DeviceInitializationStatus_brdcst_func>:
volatile xSemaphoreHandle count_mutex = NULL;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002ca4:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002ca6:	19 e8       	ld.ub	r8,r12[0x6]
80002ca8:	30 19       	mov	r9,1
80002caa:	f2 08 18 00 	cp.b	r8,r9
80002cae:	c0 61       	brne	80002cba <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002cb0:	48 98       	lddpc	r8,80002cd4 <DeviceInitializationStatus_brdcst_func+0x30>
80002cb2:	70 09       	ld.w	r9,r8[0x0]
80002cb4:	a1 a9       	sbr	r9,0x0
80002cb6:	91 09       	st.w	r8[0x0],r9
80002cb8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002cba:	30 29       	mov	r9,2
80002cbc:	f2 08 18 00 	cp.b	r8,r9
80002cc0:	c0 80       	breq	80002cd0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002cc2:	48 58       	lddpc	r8,80002cd4 <DeviceInitializationStatus_brdcst_func+0x30>
80002cc4:	70 09       	ld.w	r9,r8[0x0]
80002cc6:	e0 19 ff fc 	andl	r9,0xfffc
80002cca:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002ccc:	f0 1f 00 03 	mcall	80002cd8 <DeviceInitializationStatus_brdcst_func+0x34>
80002cd0:	d8 02       	popm	pc
80002cd2:	00 00       	add	r0,r0
80002cd4:	00 00       	add	r0,r0
80002cd6:	0e 20       	rsub	r0,r7
80002cd8:	80 00       	ld.sh	r0,r0[0x0]
80002cda:	48 f0       	lddpc	r0,80002d14 <send_flash_command+0x38>

80002cdc <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002cdc:	eb cd 40 fc 	pushm	r2-r7,lr
80002ce0:	20 1d       	sub	sp,4
80002ce2:	18 97       	mov	r7,r12
80002ce4:	14 95       	mov	r5,r10
80002ce6:	12 96       	mov	r6,r9
	U16 status = 1;
80002ce8:	30 18       	mov	r8,1
80002cea:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002cec:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002cf0:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002cf4:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002cf8:	30 1b       	mov	r11,1
80002cfa:	4e 58       	lddpc	r8,80002e8c <send_flash_command+0x1b0>
80002cfc:	70 0c       	ld.w	r12,r8[0x0]
80002cfe:	f0 1f 00 65 	mcall	80002e90 <send_flash_command+0x1b4>

    switch (command)
80002d02:	30 58       	mov	r8,5
80002d04:	f0 07 19 00 	cp.h	r7,r8
80002d08:	c3 40       	breq	80002d70 <send_flash_command+0x94>
80002d0a:	e0 8b 00 18 	brhi	80002d3a <send_flash_command+0x5e>
80002d0e:	30 28       	mov	r8,2
80002d10:	f0 07 19 00 	cp.h	r7,r8
80002d14:	c5 e0       	breq	80002dd0 <send_flash_command+0xf4>
80002d16:	e0 8b 00 08 	brhi	80002d26 <send_flash_command+0x4a>
80002d1a:	30 18       	mov	r8,1
80002d1c:	f0 07 19 00 	cp.h	r7,r8
80002d20:	e0 81 00 ad 	brne	80002e7a <send_flash_command+0x19e>
80002d24:	c9 e8       	rjmp	80002e60 <send_flash_command+0x184>
80002d26:	30 38       	mov	r8,3
80002d28:	f0 07 19 00 	cp.h	r7,r8
80002d2c:	c7 20       	breq	80002e10 <send_flash_command+0x134>
80002d2e:	30 48       	mov	r8,4
80002d30:	f0 07 19 00 	cp.h	r7,r8
80002d34:	e0 81 00 a3 	brne	80002e7a <send_flash_command+0x19e>
80002d38:	c2 c8       	rjmp	80002d90 <send_flash_command+0xb4>
80002d3a:	35 28       	mov	r8,82
80002d3c:	f0 07 19 00 	cp.h	r7,r8
80002d40:	c2 f0       	breq	80002d9e <send_flash_command+0xc2>
80002d42:	e0 8b 00 0c 	brhi	80002d5a <send_flash_command+0x7e>
80002d46:	30 68       	mov	r8,6
80002d48:	f0 07 19 00 	cp.h	r7,r8
80002d4c:	c2 20       	breq	80002d90 <send_flash_command+0xb4>
80002d4e:	32 08       	mov	r8,32
80002d50:	f0 07 19 00 	cp.h	r7,r8
80002d54:	e0 81 00 93 	brne	80002e7a <send_flash_command+0x19e>
80002d58:	c2 38       	rjmp	80002d9e <send_flash_command+0xc2>
80002d5a:	36 08       	mov	r8,96
80002d5c:	f0 07 19 00 	cp.h	r7,r8
80002d60:	c3 20       	breq	80002dc4 <send_flash_command+0xe8>
80002d62:	e0 68 00 d8 	mov	r8,216
80002d66:	f0 07 19 00 	cp.h	r7,r8
80002d6a:	e0 81 00 88 	brne	80002e7a <send_flash_command+0x19e>
80002d6e:	c1 88       	rjmp	80002d9e <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002d70:	4c 77       	lddpc	r7,80002e8c <send_flash_command+0x1b0>
80002d72:	30 5b       	mov	r11,5
80002d74:	6e 0c       	ld.w	r12,r7[0x0]
80002d76:	f0 1f 00 48 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_dummy();
80002d7a:	e0 6b 00 ff 	mov	r11,255
80002d7e:	6e 0c       	ld.w	r12,r7[0x0]
80002d80:	f0 1f 00 45 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002d84:	fa cb ff fe 	sub	r11,sp,-2
80002d88:	6e 0c       	ld.w	r12,r7[0x0]
80002d8a:	f0 1f 00 44 	mcall	80002e98 <send_flash_command+0x1bc>
			break;
80002d8e:	c7 68       	rjmp	80002e7a <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002d90:	0e 9b       	mov	r11,r7
80002d92:	5c 7b       	castu.h	r11
80002d94:	4b e8       	lddpc	r8,80002e8c <send_flash_command+0x1b0>
80002d96:	70 0c       	ld.w	r12,r8[0x0]
80002d98:	f0 1f 00 3f 	mcall	80002e94 <send_flash_command+0x1b8>
			break;
80002d9c:	c6 f8       	rjmp	80002e7a <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002d9e:	4b c6       	lddpc	r6,80002e8c <send_flash_command+0x1b0>
80002da0:	0e 9b       	mov	r11,r7
80002da2:	5c 7b       	castu.h	r11
80002da4:	6c 0c       	ld.w	r12,r6[0x0]
80002da6:	f0 1f 00 3c 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002daa:	08 9b       	mov	r11,r4
80002dac:	6c 0c       	ld.w	r12,r6[0x0]
80002dae:	f0 1f 00 3a 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002db2:	06 9b       	mov	r11,r3
80002db4:	6c 0c       	ld.w	r12,r6[0x0]
80002db6:	f0 1f 00 38 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002dba:	04 9b       	mov	r11,r2
80002dbc:	6c 0c       	ld.w	r12,r6[0x0]
80002dbe:	f0 1f 00 36 	mcall	80002e94 <send_flash_command+0x1b8>
			break;
80002dc2:	c5 c8       	rjmp	80002e7a <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002dc4:	36 0b       	mov	r11,96
80002dc6:	4b 28       	lddpc	r8,80002e8c <send_flash_command+0x1b0>
80002dc8:	70 0c       	ld.w	r12,r8[0x0]
80002dca:	f0 1f 00 33 	mcall	80002e94 <send_flash_command+0x1b8>
			break;
80002dce:	c5 68       	rjmp	80002e7a <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002dd0:	4a f7       	lddpc	r7,80002e8c <send_flash_command+0x1b0>
80002dd2:	30 2b       	mov	r11,2
80002dd4:	6e 0c       	ld.w	r12,r7[0x0]
80002dd6:	f0 1f 00 30 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002dda:	08 9b       	mov	r11,r4
80002ddc:	6e 0c       	ld.w	r12,r7[0x0]
80002dde:	f0 1f 00 2e 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002de2:	06 9b       	mov	r11,r3
80002de4:	6e 0c       	ld.w	r12,r7[0x0]
80002de6:	f0 1f 00 2c 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002dea:	04 9b       	mov	r11,r2
80002dec:	6e 0c       	ld.w	r12,r7[0x0]
80002dee:	f0 1f 00 2a 	mcall	80002e94 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002df2:	58 06       	cp.w	r6,0
80002df4:	c4 30       	breq	80002e7a <send_flash_command+0x19e>
80002df6:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002df8:	4a 54       	lddpc	r4,80002e8c <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002dfa:	0f 3b       	ld.ub	r11,r7++
80002dfc:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002dfe:	68 0c       	ld.w	r12,r4[0x0]
80002e00:	f0 1f 00 25 	mcall	80002e94 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002e04:	0e 98       	mov	r8,r7
80002e06:	0a 18       	sub	r8,r5
80002e08:	ec 08 19 00 	cp.h	r8,r6
80002e0c:	cf 73       	brcs	80002dfa <send_flash_command+0x11e>
80002e0e:	c3 68       	rjmp	80002e7a <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002e10:	49 f7       	lddpc	r7,80002e8c <send_flash_command+0x1b0>
80002e12:	30 3b       	mov	r11,3
80002e14:	6e 0c       	ld.w	r12,r7[0x0]
80002e16:	f0 1f 00 20 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002e1a:	08 9b       	mov	r11,r4
80002e1c:	6e 0c       	ld.w	r12,r7[0x0]
80002e1e:	f0 1f 00 1e 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002e22:	06 9b       	mov	r11,r3
80002e24:	6e 0c       	ld.w	r12,r7[0x0]
80002e26:	f0 1f 00 1c 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e2a:	04 9b       	mov	r11,r2
80002e2c:	6e 0c       	ld.w	r12,r7[0x0]
80002e2e:	f0 1f 00 1a 	mcall	80002e94 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002e32:	58 06       	cp.w	r6,0
80002e34:	c2 30       	breq	80002e7a <send_flash_command+0x19e>
80002e36:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002e38:	49 54       	lddpc	r4,80002e8c <send_flash_command+0x1b0>
80002e3a:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002e3e:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002e40:	06 9b       	mov	r11,r3
80002e42:	68 0c       	ld.w	r12,r4[0x0]
80002e44:	f0 1f 00 14 	mcall	80002e94 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002e48:	1a 9b       	mov	r11,sp
80002e4a:	68 0c       	ld.w	r12,r4[0x0]
80002e4c:	f0 1f 00 13 	mcall	80002e98 <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002e50:	9a 08       	ld.sh	r8,sp[0x0]
80002e52:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002e54:	0e 98       	mov	r8,r7
80002e56:	0a 18       	sub	r8,r5
80002e58:	ec 08 19 00 	cp.h	r8,r6
80002e5c:	cf 23       	brcs	80002e40 <send_flash_command+0x164>
80002e5e:	c0 e8       	rjmp	80002e7a <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002e60:	48 b7       	lddpc	r7,80002e8c <send_flash_command+0x1b0>
80002e62:	30 1b       	mov	r11,1
80002e64:	6e 0c       	ld.w	r12,r7[0x0]
80002e66:	f0 1f 00 0c 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002e6a:	30 0b       	mov	r11,0
80002e6c:	6e 0c       	ld.w	r12,r7[0x0]
80002e6e:	f0 1f 00 0a 	mcall	80002e94 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002e72:	30 0b       	mov	r11,0
80002e74:	6e 0c       	ld.w	r12,r7[0x0]
80002e76:	f0 1f 00 08 	mcall	80002e94 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002e7a:	30 1b       	mov	r11,1
80002e7c:	48 48       	lddpc	r8,80002e8c <send_flash_command+0x1b0>
80002e7e:	70 0c       	ld.w	r12,r8[0x0]
80002e80:	f0 1f 00 07 	mcall	80002e9c <send_flash_command+0x1c0>

	return status;
}
80002e84:	9a 1c       	ld.sh	r12,sp[0x2]
80002e86:	2f fd       	sub	sp,-4
80002e88:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002e8c:	00 00       	add	r0,r0
80002e8e:	1e 2c       	rsub	r12,pc
80002e90:	80 00       	ld.sh	r0,r0[0x0]
80002e92:	69 78       	ld.w	r8,r4[0x5c]
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	68 12       	ld.w	r2,r4[0x4]
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	68 2e       	ld.w	lr,r4[0x8]
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	69 38       	ld.w	r8,r4[0x4c]

80002ea0 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002ea0:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002ea2:	58 0a       	cp.w	r10,0
80002ea4:	5f 09       	sreq	r9
80002ea6:	e0 68 ff fe 	mov	r8,65534
80002eaa:	ea 18 00 7f 	orh	r8,0x7f
80002eae:	10 3c       	cp.w	r12,r8
80002eb0:	5f b8       	srhi	r8
80002eb2:	f3 e8 10 08 	or	r8,r9,r8
80002eb6:	c0 e1       	brne	80002ed2 <data_flash_read_block+0x32>
80002eb8:	e0 68 10 00 	mov	r8,4096
80002ebc:	f0 0b 19 00 	cp.h	r11,r8
80002ec0:	e0 8b 00 09 	brhi	80002ed2 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002ec4:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002ec8:	18 9b       	mov	r11,r12
80002eca:	30 3c       	mov	r12,3
80002ecc:	f0 1f 00 02 	mcall	80002ed4 <data_flash_read_block+0x34>
80002ed0:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002ed2:	da 0a       	popm	pc,r12=1
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	2c dc       	sub	r12,-51

80002ed8 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002ed8:	eb cd 40 fc 	pushm	r2-r7,lr
80002edc:	18 94       	mov	r4,r12
80002ede:	16 93       	mov	r3,r11
80002ee0:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002ee2:	58 0c       	cp.w	r12,0
80002ee4:	5f 09       	sreq	r9
80002ee6:	e0 68 ff fe 	mov	r8,65534
80002eea:	ea 18 00 7f 	orh	r8,0x7f
80002eee:	10 3b       	cp.w	r11,r8
80002ef0:	5f b8       	srhi	r8
80002ef2:	f3 e8 10 08 	or	r8,r9,r8
80002ef6:	c3 a1       	brne	80002f6a <data_flash_write_page+0x92>
80002ef8:	e0 68 01 00 	mov	r8,256
80002efc:	f0 0a 19 00 	cp.h	r10,r8
80002f00:	e0 8b 00 35 	brhi	80002f6a <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002f04:	30 06       	mov	r6,0
80002f06:	30 55       	mov	r5,5
80002f08:	30 17       	mov	r7,1
80002f0a:	0c 99       	mov	r9,r6
80002f0c:	0c 9a       	mov	r10,r6
80002f0e:	0c 9b       	mov	r11,r6
80002f10:	0a 9c       	mov	r12,r5
80002f12:	f0 1f 00 19 	mcall	80002f74 <data_flash_write_page+0x9c>
80002f16:	ee 0c 19 00 	cp.h	r12,r7
80002f1a:	cf 80       	breq	80002f0a <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002f1c:	30 09       	mov	r9,0
80002f1e:	12 9a       	mov	r10,r9
80002f20:	12 9b       	mov	r11,r9
80002f22:	30 6c       	mov	r12,6
80002f24:	f0 1f 00 14 	mcall	80002f74 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002f28:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002f2c:	08 9a       	mov	r10,r4
80002f2e:	06 9b       	mov	r11,r3
80002f30:	30 2c       	mov	r12,2
80002f32:	f0 1f 00 11 	mcall	80002f74 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002f36:	30 06       	mov	r6,0
80002f38:	30 57       	mov	r7,5
80002f3a:	0c 99       	mov	r9,r6
80002f3c:	0c 9a       	mov	r10,r6
80002f3e:	0c 9b       	mov	r11,r6
80002f40:	0e 9c       	mov	r12,r7
80002f42:	f0 1f 00 0d 	mcall	80002f74 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002f46:	5c 7c       	castu.h	r12
80002f48:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002f4c:	cf 71       	brne	80002f3a <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002f4e:	18 97       	mov	r7,r12
80002f50:	e2 17 00 20 	andl	r7,0x20,COH
80002f54:	f9 b7 01 06 	movne	r7,6
80002f58:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002f5c:	30 09       	mov	r9,0
80002f5e:	12 9a       	mov	r10,r9
80002f60:	12 9b       	mov	r11,r9
80002f62:	30 4c       	mov	r12,4
80002f64:	f0 1f 00 04 	mcall	80002f74 <data_flash_write_page+0x9c>

	return return_code;
80002f68:	c0 28       	rjmp	80002f6c <data_flash_write_page+0x94>
80002f6a:	30 17       	mov	r7,1
}
80002f6c:	0e 9c       	mov	r12,r7
80002f6e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002f72:	00 00       	add	r0,r0
80002f74:	80 00       	ld.sh	r0,r0[0x0]
80002f76:	2c dc       	sub	r12,-51

80002f78 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002f78:	d4 31       	pushm	r0-r7,lr
80002f7a:	18 94       	mov	r4,r12
80002f7c:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002f80:	16 97       	mov	r7,r11
80002f82:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002f84:	30 03       	mov	r3,0
80002f86:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002f88:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002f8c:	c4 98       	rjmp	8000301e <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002f8e:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002f92:	c1 b1       	brne	80002fc8 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002f94:	e0 06 19 00 	cp.h	r6,r0
80002f98:	e0 8b 00 0a 	brhi	80002fac <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002f9c:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002fa0:	0e 9b       	mov	r11,r7
80002fa2:	08 9c       	mov	r12,r4
80002fa4:	f0 1f 00 24 	mcall	80003034 <data_flash_write_block+0xbc>
80002fa8:	30 06       	mov	r6,0
80002faa:	c3 a8       	rjmp	8000301e <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002fac:	e0 6a 01 00 	mov	r10,256
80002fb0:	0e 9b       	mov	r11,r7
80002fb2:	08 9c       	mov	r12,r4
80002fb4:	f0 1f 00 20 	mcall	80003034 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002fb8:	ec c6 01 00 	sub	r6,r6,256
80002fbc:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002fbe:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002fc2:	ee c7 ff 00 	sub	r7,r7,-256
80002fc6:	c2 c8       	rjmp	8000301e <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002fc8:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002fcc:	0e 09       	add	r9,r7
80002fce:	0e 98       	mov	r8,r7
80002fd0:	e4 18 00 7f 	andh	r8,0x7f
80002fd4:	e0 18 ff 00 	andl	r8,0xff00
80002fd8:	f0 c8 ff 00 	sub	r8,r8,-256
80002fdc:	10 39       	cp.w	r9,r8
80002fde:	e0 88 00 19 	brls	80003010 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002fe2:	0e 91       	mov	r1,r7
80002fe4:	5c 51       	castu.b	r1
80002fe6:	e0 6a 01 00 	mov	r10,256
80002fea:	02 1a       	sub	r10,r1
80002fec:	5c 7a       	castu.h	r10
80002fee:	0e 9b       	mov	r11,r7
80002ff0:	08 9c       	mov	r12,r4
80002ff2:	f0 1f 00 11 	mcall	80003034 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002ff6:	ec c6 01 00 	sub	r6,r6,256
80002ffa:	02 06       	add	r6,r1
80002ffc:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002ffe:	e0 68 01 00 	mov	r8,256
80003002:	f0 05 01 05 	sub	r5,r8,r5
80003006:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80003008:	e0 17 ff 00 	andl	r7,0xff00
8000300c:	10 07       	add	r7,r8
8000300e:	c0 88       	rjmp	8000301e <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80003010:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80003014:	0e 9b       	mov	r11,r7
80003016:	08 9c       	mov	r12,r4
80003018:	f0 1f 00 07 	mcall	80003034 <data_flash_write_block+0xbc>
8000301c:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
8000301e:	e6 06 19 00 	cp.h	r6,r3
80003022:	5f 19       	srne	r9
80003024:	58 7c       	cp.w	r12,7
80003026:	5f 08       	sreq	r8
80003028:	f3 e8 00 08 	and	r8,r9,r8
8000302c:	e4 08 18 00 	cp.b	r8,r2
80003030:	ca f1       	brne	80002f8e <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80003032:	d8 32       	popm	r0-r7,pc
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	2e d8       	sub	r8,-19

80003038 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80003038:	eb cd 40 f8 	pushm	r3-r7,lr
8000303c:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
8000303e:	e0 68 ff fe 	mov	r8,65534
80003042:	ea 18 00 7f 	orh	r8,0x7f
80003046:	10 3c       	cp.w	r12,r8
80003048:	e0 88 00 04 	brls	80003050 <data_flash_erase_block+0x18>
8000304c:	30 17       	mov	r7,1
8000304e:	c3 f8       	rjmp	800030cc <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80003050:	58 1b       	cp.w	r11,1
80003052:	c0 31       	brne	80003058 <data_flash_erase_block+0x20>
80003054:	32 03       	mov	r3,32
80003056:	c0 a8       	rjmp	8000306a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80003058:	58 2b       	cp.w	r11,2
8000305a:	c0 31       	brne	80003060 <data_flash_erase_block+0x28>
8000305c:	35 23       	mov	r3,82
8000305e:	c0 68       	rjmp	8000306a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80003060:	e0 63 00 d8 	mov	r3,216
80003064:	58 3b       	cp.w	r11,3
80003066:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
8000306a:	30 06       	mov	r6,0
8000306c:	30 55       	mov	r5,5
8000306e:	30 17       	mov	r7,1
80003070:	0c 99       	mov	r9,r6
80003072:	0c 9a       	mov	r10,r6
80003074:	0c 9b       	mov	r11,r6
80003076:	0a 9c       	mov	r12,r5
80003078:	f0 1f 00 17 	mcall	800030d4 <data_flash_erase_block+0x9c>
8000307c:	ee 0c 19 00 	cp.h	r12,r7
80003080:	cf 80       	breq	80003070 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80003082:	30 09       	mov	r9,0
80003084:	12 9a       	mov	r10,r9
80003086:	12 9b       	mov	r11,r9
80003088:	30 6c       	mov	r12,6
8000308a:	f0 1f 00 13 	mcall	800030d4 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
8000308e:	30 09       	mov	r9,0
80003090:	12 9a       	mov	r10,r9
80003092:	08 9b       	mov	r11,r4
80003094:	06 9c       	mov	r12,r3
80003096:	f0 1f 00 10 	mcall	800030d4 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
8000309a:	30 06       	mov	r6,0
8000309c:	30 57       	mov	r7,5
8000309e:	0c 99       	mov	r9,r6
800030a0:	0c 9a       	mov	r10,r6
800030a2:	0c 9b       	mov	r11,r6
800030a4:	0e 9c       	mov	r12,r7
800030a6:	f0 1f 00 0c 	mcall	800030d4 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
800030aa:	5c 7c       	castu.h	r12
800030ac:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800030b0:	cf 71       	brne	8000309e <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
800030b2:	18 97       	mov	r7,r12
800030b4:	e2 17 00 20 	andl	r7,0x20,COH
800030b8:	f9 b7 01 04 	movne	r7,4
800030bc:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
800030c0:	30 09       	mov	r9,0
800030c2:	12 9a       	mov	r10,r9
800030c4:	12 9b       	mov	r11,r9
800030c6:	30 4c       	mov	r12,4
800030c8:	f0 1f 00 03 	mcall	800030d4 <data_flash_erase_block+0x9c>

	return return_code;
}
800030cc:	0e 9c       	mov	r12,r7
800030ce:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800030d2:	00 00       	add	r0,r0
800030d4:	80 00       	ld.sh	r0,r0[0x0]
800030d6:	2c dc       	sub	r12,-51

800030d8 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
800030d8:	d4 31       	pushm	r0-r7,lr
800030da:	20 3d       	sub	sp,12
800030dc:	50 0c       	stdsp	sp[0x0],r12
800030de:	16 91       	mov	r1,r11
800030e0:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
800030e2:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
800030e6:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
800030e8:	e0 69 10 00 	mov	r9,4096
800030ec:	f2 0a 01 07 	sub	r7,r9,r10
800030f0:	ea 07 19 00 	cp.h	r7,r5
800030f4:	ea 07 17 b0 	movhi	r7,r5
800030f8:	5c 87       	casts.h	r7
800030fa:	16 92       	mov	r2,r11
800030fc:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80003100:	4a e4       	lddpc	r4,800031b8 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80003102:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80003104:	e8 c8 ff ff 	sub	r8,r4,-1
80003108:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
8000310a:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
8000310c:	08 9a       	mov	r10,r4
8000310e:	e0 6b 10 00 	mov	r11,4096
80003112:	04 9c       	mov	r12,r2
80003114:	f0 1f 00 2a 	mcall	800031bc <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80003118:	58 07       	cp.w	r7,0
8000311a:	c3 00       	breq	8000317a <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
8000311c:	40 13       	lddsp	r3,sp[0x4]
8000311e:	5c 73       	castu.h	r3
80003120:	e8 03 07 08 	ld.ub	r8,r4[r3]
80003124:	ec 08 18 00 	cp.b	r8,r6
80003128:	c1 11       	brne	8000314a <data_flash_write+0x72>
8000312a:	e6 c9 ff ff 	sub	r9,r3,-1
8000312e:	08 09       	add	r9,r4
80003130:	30 08       	mov	r8,0
80003132:	c0 58       	rjmp	8000313c <data_flash_write+0x64>
80003134:	13 3a       	ld.ub	r10,r9++
80003136:	ec 0a 18 00 	cp.b	r10,r6
8000313a:	c0 81       	brne	8000314a <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
8000313c:	2f f8       	sub	r8,-1
8000313e:	5c 88       	casts.h	r8
80003140:	f0 07 19 00 	cp.h	r7,r8
80003144:	fe 9b ff f8 	brhi	80003134 <data_flash_write+0x5c>
80003148:	c1 98       	rjmp	8000317a <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
8000314a:	30 1b       	mov	r11,1
8000314c:	04 9c       	mov	r12,r2
8000314e:	f0 1f 00 1d 	mcall	800031c0 <data_flash_write+0xe8>
80003152:	40 08       	lddsp	r8,sp[0x0]
80003154:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80003156:	40 2a       	lddsp	r10,sp[0x8]
80003158:	40 19       	lddsp	r9,sp[0x4]
8000315a:	12 0a       	add	r10,r9
8000315c:	0e 99       	mov	r9,r7
8000315e:	20 19       	sub	r9,1
80003160:	5c 79       	castu.h	r9
80003162:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80003164:	11 39       	ld.ub	r9,r8++
80003166:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80003168:	14 33       	cp.w	r3,r10
8000316a:	cf d1       	brne	80003164 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
8000316c:	e0 6a 10 00 	mov	r10,4096
80003170:	04 9b       	mov	r11,r2
80003172:	08 9c       	mov	r12,r4
80003174:	f0 1f 00 14 	mcall	800031c4 <data_flash_write+0xec>
80003178:	c0 78       	rjmp	80003186 <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
8000317a:	0e 9a       	mov	r10,r7
8000317c:	5c 7a       	castu.h	r10
8000317e:	02 9b       	mov	r11,r1
80003180:	40 0c       	lddsp	r12,sp[0x0]
80003182:	f0 1f 00 11 	mcall	800031c4 <data_flash_write+0xec>
80003186:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
8000318a:	0e 98       	mov	r8,r7
8000318c:	ee 05 19 00 	cp.h	r5,r7
80003190:	c1 20       	breq	800031b4 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80003192:	5c 78       	castu.h	r8
80003194:	40 0a       	lddsp	r10,sp[0x0]
80003196:	10 0a       	add	r10,r8
80003198:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
8000319a:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
8000319c:	0e 15       	sub	r5,r7
8000319e:	5c 85       	casts.h	r5
800031a0:	e0 05 19 00 	cp.h	r5,r0
800031a4:	ea 07 17 80 	movls	r7,r5
800031a8:	e0 07 17 b0 	movhi	r7,r0
800031ac:	5c 87       	casts.h	r7
800031ae:	30 09       	mov	r9,0
800031b0:	50 19       	stdsp	sp[0x4],r9
800031b2:	ca db       	rjmp	8000310c <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
800031b4:	2f dd       	sub	sp,-12
800031b6:	d8 32       	popm	r0-r7,pc
800031b8:	00 00       	add	r0,r0
800031ba:	0e 2c       	rsub	r12,r7
800031bc:	80 00       	ld.sh	r0,r0[0x0]
800031be:	2e a0       	sub	r0,-22
800031c0:	80 00       	ld.sh	r0,r0[0x0]
800031c2:	30 38       	mov	r8,3
800031c4:	80 00       	ld.sh	r0,r0[0x0]
800031c6:	2f 78       	sub	r8,-9

800031c8 <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800031c8:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800031ca:	48 78       	lddpc	r8,800031e4 <W25Q64_SPI_SetSpeed+0x1c>
800031cc:	70 09       	ld.w	r9,r8[0x0]
800031ce:	72 da       	ld.w	r10,r9[0x34]
800031d0:	5c 7c       	castu.h	r12
800031d2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800031d6:	f9 ea 10 0a 	or	r10,r12,r10
800031da:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
800031dc:	70 0c       	ld.w	r12,r8[0x0]
800031de:	f0 1f 00 03 	mcall	800031e8 <W25Q64_SPI_SetSpeed+0x20>
	
	
}
800031e2:	d8 02       	popm	pc
800031e4:	00 00       	add	r0,r0
800031e6:	1e 2c       	rsub	r12,pc
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	68 0c       	ld.w	r12,r4[0x0]

800031ec <W25Q64_SPI_SetSpeedLow>:
void W25Q64_SPI_SetSpeedLow(void)
{
800031ec:	d4 01       	pushm	lr
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
800031ee:	e0 6c 02 00 	mov	r12,512
800031f2:	f0 1f 00 02 	mcall	800031f8 <W25Q64_SPI_SetSpeedLow+0xc>
	
}
800031f6:	d8 02       	popm	pc
800031f8:	80 00       	ld.sh	r0,r0[0x0]
800031fa:	31 c8       	mov	r8,28

800031fc <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
800031fc:	eb cd 40 c0 	pushm	r6-r7,lr
80003200:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80003202:	4b a8       	lddpc	r8,800032e8 <data_flash_init+0xec>
80003204:	fa c6 ff fc 	sub	r6,sp,-4
80003208:	f0 ea 00 00 	ld.d	r10,r8[0]
8000320c:	ec eb 00 00 	st.d	r6[0],r10
80003210:	f0 e8 00 08 	ld.d	r8,r8[8]
80003214:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80003218:	30 4b       	mov	r11,4
8000321a:	4b 5c       	lddpc	r12,800032ec <data_flash_init+0xf0>
8000321c:	f0 1f 00 35 	mcall	800032f0 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
80003220:	4b 57       	lddpc	r7,800032f4 <data_flash_init+0xf8>
80003222:	fe 7c 24 00 	mov	r12,-56320
80003226:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80003228:	0c 9b       	mov	r11,r6
8000322a:	f0 1f 00 34 	mcall	800032f8 <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
8000322e:	30 09       	mov	r9,0
80003230:	12 9a       	mov	r10,r9
80003232:	12 9b       	mov	r11,r9
80003234:	6e 0c       	ld.w	r12,r7[0x0]
80003236:	f0 1f 00 32 	mcall	800032fc <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
8000323a:	6e 0c       	ld.w	r12,r7[0x0]
8000323c:	f0 1f 00 31 	mcall	80003300 <data_flash_init+0x104>

	W25Q64_SPI_SetSpeedLow();
80003240:	f0 1f 00 31 	mcall	80003304 <data_flash_init+0x108>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80003244:	e0 6a 36 00 	mov	r10,13824
80003248:	ea 1a 01 6e 	orh	r10,0x16e
8000324c:	0c 9b       	mov	r11,r6
8000324e:	6e 0c       	ld.w	r12,r7[0x0]
80003250:	f0 1f 00 2e 	mcall	80003308 <data_flash_init+0x10c>
80003254:	c0 50       	breq	8000325e <data_flash_init+0x62>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80003256:	30 29       	mov	r9,2
80003258:	4a d8       	lddpc	r8,8000330c <data_flash_init+0x110>
8000325a:	b0 89       	st.b	r8[0x0],r9
		return;
8000325c:	c4 28       	rjmp	800032e0 <data_flash_init+0xe4>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
8000325e:	1a 96       	mov	r6,sp
80003260:	30 4a       	mov	r10,4
80003262:	4a cb       	lddpc	r11,80003310 <data_flash_init+0x114>
80003264:	1a 9c       	mov	r12,sp
80003266:	f0 1f 00 2c 	mcall	80003314 <data_flash_init+0x118>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
8000326a:	4a 37       	lddpc	r7,800032f4 <data_flash_init+0xf8>
8000326c:	30 1b       	mov	r11,1
8000326e:	6e 0c       	ld.w	r12,r7[0x0]
80003270:	f0 1f 00 2a 	mcall	80003318 <data_flash_init+0x11c>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80003274:	e0 6b 00 90 	mov	r11,144
80003278:	6e 0c       	ld.w	r12,r7[0x0]
8000327a:	f0 1f 00 29 	mcall	8000331c <data_flash_init+0x120>
	spi_write_zero();
8000327e:	30 0b       	mov	r11,0
80003280:	6e 0c       	ld.w	r12,r7[0x0]
80003282:	f0 1f 00 27 	mcall	8000331c <data_flash_init+0x120>
	spi_write_zero();
80003286:	30 0b       	mov	r11,0
80003288:	6e 0c       	ld.w	r12,r7[0x0]
8000328a:	f0 1f 00 25 	mcall	8000331c <data_flash_init+0x120>
	spi_write_zero();
8000328e:	30 0b       	mov	r11,0
80003290:	6e 0c       	ld.w	r12,r7[0x0]
80003292:	f0 1f 00 23 	mcall	8000331c <data_flash_init+0x120>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
80003296:	e0 6b 00 ff 	mov	r11,255
8000329a:	6e 0c       	ld.w	r12,r7[0x0]
8000329c:	f0 1f 00 20 	mcall	8000331c <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[0]);
800032a0:	1a 9b       	mov	r11,sp
800032a2:	6e 0c       	ld.w	r12,r7[0x0]
800032a4:	f0 1f 00 1f 	mcall	80003320 <data_flash_init+0x124>
	
	spi_write_dummy();
800032a8:	e0 6b 00 ff 	mov	r11,255
800032ac:	6e 0c       	ld.w	r12,r7[0x0]
800032ae:	f0 1f 00 1c 	mcall	8000331c <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[1]);
800032b2:	fa cb ff fe 	sub	r11,sp,-2
800032b6:	6e 0c       	ld.w	r12,r7[0x0]
800032b8:	f0 1f 00 1a 	mcall	80003320 <data_flash_init+0x124>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
800032bc:	30 1b       	mov	r11,1
800032be:	6e 0c       	ld.w	r12,r7[0x0]
800032c0:	f0 1f 00 19 	mcall	80003324 <data_flash_init+0x128>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
800032c4:	e0 68 00 ef 	mov	r8,239
800032c8:	9a 09       	ld.sh	r9,sp[0x0]
800032ca:	f0 09 19 00 	cp.h	r9,r8
800032ce:	c0 61       	brne	800032da <data_flash_init+0xde>
800032d0:	31 68       	mov	r8,22
800032d2:	9a 19       	ld.sh	r9,sp[0x2]
800032d4:	f0 09 19 00 	cp.h	r9,r8
800032d8:	c0 40       	breq	800032e0 <data_flash_init+0xe4>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
800032da:	30 39       	mov	r9,3
800032dc:	48 c8       	lddpc	r8,8000330c <data_flash_init+0x110>
800032de:	b0 89       	st.b	r8[0x0],r9
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
800032e0:	2f bd       	sub	sp,-20
800032e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800032e6:	00 00       	add	r0,r0
800032e8:	80 00       	ld.sh	r0,r0[0x0]
800032ea:	e8 f0 80 00 	ld.w	r0,r4[-32768]
800032ee:	e8 cc 80 00 	sub	r12,r4,-32768
800032f2:	63 38       	ld.w	r8,r1[0x4c]
800032f4:	00 00       	add	r0,r0
800032f6:	1e 2c       	rsub	r12,pc
800032f8:	80 00       	ld.sh	r0,r0[0x0]
800032fa:	67 a8       	ld.w	r8,r3[0x68]
800032fc:	80 00       	ld.sh	r0,r0[0x0]
800032fe:	67 e0       	ld.w	r0,r3[0x78]
80003300:	80 00       	ld.sh	r0,r0[0x0]
80003302:	68 0c       	ld.w	r12,r4[0x0]
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	31 ec       	mov	r12,30
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	68 50       	ld.w	r0,r4[0x14]
8000330c:	00 00       	add	r0,r0
8000330e:	0a 8b       	andn	r11,r5
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	e8 ec 80 00 	ld.d	r12,r4[-32768]
80003316:	87 fe       	st.w	r3[0x3c],lr
80003318:	80 00       	ld.sh	r0,r0[0x0]
8000331a:	69 78       	ld.w	r8,r4[0x5c]
8000331c:	80 00       	ld.sh	r0,r0[0x0]
8000331e:	68 12       	ld.w	r2,r4[0x4]
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	68 2e       	ld.w	lr,r4[0x8]
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	69 38       	ld.w	r8,r4[0x4c]

80003328 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80003328:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
8000332a:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
8000332c:	30 0a       	mov	r10,0
8000332e:	32 8b       	mov	r11,40
80003330:	49 5c       	lddpc	r12,80003384 <xg_rtc_init+0x5c>
80003332:	f0 1f 00 16 	mcall	80003388 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80003336:	30 ea       	mov	r10,14
80003338:	30 1b       	mov	r11,1
8000333a:	fe 7c 0d 00 	mov	r12,-62208
8000333e:	f0 1f 00 14 	mcall	8000338c <xg_rtc_init+0x64>
80003342:	c0 41       	brne	8000334a <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80003344:	49 3c       	lddpc	r12,80003390 <xg_rtc_init+0x68>
80003346:	f0 1f 00 14 	mcall	80003394 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
8000334a:	30 0b       	mov	r11,0
8000334c:	fe 7c 0d 00 	mov	r12,-62208
80003350:	f0 1f 00 12 	mcall	80003398 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80003354:	fe 7c 0d 00 	mov	r12,-62208
80003358:	f0 1f 00 11 	mcall	8000339c <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
8000335c:	fe 7c 0d 00 	mov	r12,-62208
80003360:	f0 1f 00 10 	mcall	800033a0 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80003364:	49 08       	lddpc	r8,800033a4 <xg_rtc_init+0x7c>
80003366:	31 09       	mov	r9,16
80003368:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
8000336a:	30 29       	mov	r9,2
8000336c:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
8000336e:	31 d9       	mov	r9,29
80003370:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80003372:	31 79       	mov	r9,23
80003374:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80003376:	33 b9       	mov	r9,59
80003378:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
8000337a:	32 89       	mov	r9,40
8000337c:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
8000337e:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80003380:	d8 02       	popm	pc
80003382:	00 00       	add	r0,r0
80003384:	80 00       	ld.sh	r0,r0[0x0]
80003386:	33 a8       	mov	r8,58
80003388:	80 00       	ld.sh	r0,r0[0x0]
8000338a:	63 bc       	ld.w	r12,r1[0x6c]
8000338c:	80 00       	ld.sh	r0,r0[0x0]
8000338e:	67 08       	ld.w	r8,r3[0x40]
80003390:	80 00       	ld.sh	r0,r0[0x0]
80003392:	e9 00 80 00 	ld.sh	r0,r4[-32768]
80003396:	7f 54       	ld.w	r4,pc[0x54]
80003398:	80 00       	ld.sh	r0,r0[0x0]
8000339a:	66 c4       	ld.w	r4,r3[0x30]
8000339c:	80 00       	ld.sh	r0,r0[0x0]
8000339e:	66 bc       	ld.w	r12,r3[0x2c]
800033a0:	80 00       	ld.sh	r0,r0[0x0]
800033a2:	66 98       	ld.w	r8,r3[0x24]
800033a4:	00 00       	add	r0,r0
800033a6:	0e 24       	rsub	r4,r7

800033a8 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
800033a8:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
800033aa:	4b 98       	lddpc	r8,8000348c <rtc_irq+0xe4>
800033ac:	11 d9       	ld.ub	r9,r8[0x5]
800033ae:	2f f9       	sub	r9,-1
800033b0:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
800033b2:	11 d9       	ld.ub	r9,r8[0x5]
800033b4:	33 b8       	mov	r8,59
800033b6:	f0 09 18 00 	cp.b	r9,r8
800033ba:	e0 88 00 5f 	brls	80003478 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
800033be:	4b 48       	lddpc	r8,8000348c <rtc_irq+0xe4>
800033c0:	30 09       	mov	r9,0
800033c2:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800033c4:	11 c9       	ld.ub	r9,r8[0x4]
800033c6:	2f f9       	sub	r9,-1
800033c8:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800033ca:	11 c9       	ld.ub	r9,r8[0x4]
800033cc:	33 b8       	mov	r8,59
800033ce:	f0 09 18 00 	cp.b	r9,r8
800033d2:	e0 88 00 53 	brls	80003478 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800033d6:	4a e8       	lddpc	r8,8000348c <rtc_irq+0xe4>
800033d8:	30 09       	mov	r9,0
800033da:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
800033dc:	11 b9       	ld.ub	r9,r8[0x3]
800033de:	2f f9       	sub	r9,-1
800033e0:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
800033e2:	11 b9       	ld.ub	r9,r8[0x3]
800033e4:	31 78       	mov	r8,23
800033e6:	f0 09 18 00 	cp.b	r9,r8
800033ea:	e0 88 00 47 	brls	80003478 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
800033ee:	4a 88       	lddpc	r8,8000348c <rtc_irq+0xe4>
800033f0:	30 09       	mov	r9,0
800033f2:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
800033f4:	11 88       	ld.ub	r8,r8[0x0]
800033f6:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800033fa:	e0 69 01 6e 	mov	r9,366
800033fe:	e0 6a 01 6d 	mov	r10,365
80003402:	f4 08 17 10 	movne	r8,r10
80003406:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
8000340a:	4a 19       	lddpc	r9,8000348c <rtc_irq+0xe4>
8000340c:	13 9a       	ld.ub	r10,r9[0x1]
8000340e:	30 29       	mov	r9,2
80003410:	f2 0a 18 00 	cp.b	r10,r9
80003414:	c0 b0       	breq	8000342a <rtc_irq+0x82>
80003416:	49 e8       	lddpc	r8,8000348c <rtc_irq+0xe4>
80003418:	11 99       	ld.ub	r9,r8[0x1]
8000341a:	11 9a       	ld.ub	r10,r8[0x1]
8000341c:	a3 9a       	lsr	r10,0x3
8000341e:	12 0a       	add	r10,r9
80003420:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003424:	2e 2a       	sub	r10,-30
80003426:	5c 5a       	castu.b	r10
80003428:	c0 58       	rjmp	80003432 <rtc_irq+0x8a>
8000342a:	f0 c8 01 51 	sub	r8,r8,337
8000342e:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80003432:	49 78       	lddpc	r8,8000348c <rtc_irq+0xe4>
80003434:	11 a9       	ld.ub	r9,r8[0x2]
80003436:	2f f9       	sub	r9,-1
80003438:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
8000343a:	11 a8       	ld.ub	r8,r8[0x2]
8000343c:	f0 0a 18 00 	cp.b	r10,r8
80003440:	c1 c2       	brcc	80003478 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80003442:	49 38       	lddpc	r8,8000348c <rtc_irq+0xe4>
80003444:	30 19       	mov	r9,1
80003446:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80003448:	11 99       	ld.ub	r9,r8[0x1]
8000344a:	2f f9       	sub	r9,-1
8000344c:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
8000344e:	11 99       	ld.ub	r9,r8[0x1]
80003450:	30 c8       	mov	r8,12
80003452:	f0 09 18 00 	cp.b	r9,r8
80003456:	e0 88 00 11 	brls	80003478 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
8000345a:	48 d8       	lddpc	r8,8000348c <rtc_irq+0xe4>
8000345c:	30 19       	mov	r9,1
8000345e:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80003460:	11 89       	ld.ub	r9,r8[0x0]
80003462:	2f f9       	sub	r9,-1
80003464:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80003466:	11 89       	ld.ub	r9,r8[0x0]
80003468:	39 68       	mov	r8,-106
8000346a:	f0 09 18 00 	cp.b	r9,r8
8000346e:	e0 88 00 05 	brls	80003478 <rtc_irq+0xd0>
80003472:	30 09       	mov	r9,0
80003474:	48 68       	lddpc	r8,8000348c <rtc_irq+0xe4>
80003476:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80003478:	fe 7c 0d 00 	mov	r12,-62208
8000347c:	f0 1f 00 05 	mcall	80003490 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80003480:	30 19       	mov	r9,1
80003482:	48 58       	lddpc	r8,80003494 <rtc_irq+0xec>
80003484:	91 09       	st.w	r8[0x0],r9
}
80003486:	d4 02       	popm	lr
80003488:	d6 03       	rete
8000348a:	00 00       	add	r0,r0
8000348c:	00 00       	add	r0,r0
8000348e:	0e 24       	rsub	r4,r7
80003490:	80 00       	ld.sh	r0,r0[0x0]
80003492:	66 e8       	ld.w	r8,r3[0x38]
80003494:	00 00       	add	r0,r0
80003496:	04 fc       	st.b	--r2,r12

80003498 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003498:	20 1c       	sub	r12,1
8000349a:	5c 5c       	castu.b	r12
8000349c:	31 18       	mov	r8,17
8000349e:	f0 0c 18 00 	cp.b	r12,r8
800034a2:	e0 88 00 03 	brls	800034a8 <CalculateBurst+0x10>
800034a6:	5e fd       	retal	0
800034a8:	48 28       	lddpc	r8,800034b0 <CalculateBurst+0x18>
800034aa:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800034ae:	5e fc       	retal	r12
800034b0:	80 00       	ld.sh	r0,r0[0x0]
800034b2:	e9 20 48 38 	ld.sb	r0,r4[18488]

800034b4 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
800034b4:	48 38       	lddpc	r8,800034c0 <payload_init+0xc>
800034b6:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800034b8:	48 38       	lddpc	r8,800034c4 <payload_init+0x10>
800034ba:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
800034bc:	5e fc       	retal	r12
800034be:	00 00       	add	r0,r0
800034c0:	00 00       	add	r0,r0
800034c2:	0a 8c       	andn	r12,r5
800034c4:	00 00       	add	r0,r0
800034c6:	0a 90       	mov	r0,r5

800034c8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800034c8:	d4 01       	pushm	lr
800034ca:	20 2d       	sub	sp,8
800034cc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800034ce:	30 09       	mov	r9,0
800034d0:	fa ca ff f8 	sub	r10,sp,-8
800034d4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800034d6:	1a 9b       	mov	r11,sp
800034d8:	f0 1f 00 02 	mcall	800034e0 <set_idle_store_isr+0x18>
}
800034dc:	2f ed       	sub	sp,-8
800034de:	d8 02       	popm	pc
800034e0:	80 00       	ld.sh	r0,r0[0x0]
800034e2:	72 cc       	ld.w	r12,r9[0x30]

800034e4 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
800034e4:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
800034e6:	48 48       	lddpc	r8,800034f4 <payload_rx+0x10>
800034e8:	70 08       	ld.w	r8,r8[0x0]
800034ea:	18 9b       	mov	r11,r12
800034ec:	10 9c       	mov	r12,r8
800034ee:	f0 1f 00 03 	mcall	800034f8 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
800034f2:	d8 02       	popm	pc
800034f4:	00 00       	add	r0,r0
800034f6:	0a c8       	st.b	r5++,r8
800034f8:	80 00       	ld.sh	r0,r0[0x0]
800034fa:	34 c8       	mov	r8,76

800034fc <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800034fc:	d4 01       	pushm	lr
800034fe:	20 2d       	sub	sp,8
80003500:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003502:	58 0c       	cp.w	r12,0
80003504:	c1 10       	breq	80003526 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003506:	30 08       	mov	r8,0
80003508:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
8000350a:	98 88       	ld.uh	r8,r12[0x0]
8000350c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003510:	e0 48 40 00 	cp.w	r8,16384
80003514:	c0 91       	brne	80003526 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003516:	48 68       	lddpc	r8,8000352c <phy_rx+0x30>
80003518:	70 0c       	ld.w	r12,r8[0x0]
8000351a:	30 09       	mov	r9,0
8000351c:	fa ca ff fc 	sub	r10,sp,-4
80003520:	1a 9b       	mov	r11,sp
80003522:	f0 1f 00 04 	mcall	80003530 <phy_rx+0x34>
		}	

    }
		
 
}
80003526:	2f ed       	sub	sp,-8
80003528:	d8 02       	popm	pc
8000352a:	00 00       	add	r0,r0
8000352c:	00 00       	add	r0,r0
8000352e:	0a d4       	st.w	--r5,r4
80003530:	80 00       	ld.sh	r0,r0[0x0]
80003532:	72 cc       	ld.w	r12,r9[0x30]

80003534 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003534:	eb cd 40 80 	pushm	r7,lr
80003538:	20 1d       	sub	sp,4
8000353a:	fa c7 ff fc 	sub	r7,sp,-4
8000353e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003540:	30 09       	mov	r9,0
80003542:	12 9a       	mov	r10,r9
80003544:	1a 9b       	mov	r11,sp
80003546:	f0 1f 00 03 	mcall	80003550 <set_idle_store+0x1c>
}
8000354a:	2f fd       	sub	sp,-4
8000354c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003550:	80 00       	ld.sh	r0,r0[0x0]
80003552:	73 1c       	ld.w	r12,r9[0x44]

80003554 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003554:	d4 01       	pushm	lr
80003556:	20 1d       	sub	sp,4
80003558:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
8000355a:	98 88       	ld.uh	r8,r12[0x0]
8000355c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003560:	e0 48 40 00 	cp.w	r8,16384
80003564:	c0 d1       	brne	8000357e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003566:	49 08       	lddpc	r8,800035a4 <phy_tx+0x50>
80003568:	70 08       	ld.w	r8,r8[0x0]
8000356a:	58 08       	cp.w	r8,0
8000356c:	c1 a0       	breq	800035a0 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
8000356e:	48 e8       	lddpc	r8,800035a4 <phy_tx+0x50>
80003570:	70 0c       	ld.w	r12,r8[0x0]
80003572:	30 09       	mov	r9,0
80003574:	12 9a       	mov	r10,r9
80003576:	1a 9b       	mov	r11,sp
80003578:	f0 1f 00 0c 	mcall	800035a8 <phy_tx+0x54>
8000357c:	c1 28       	rjmp	800035a0 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000357e:	e0 48 10 00 	cp.w	r8,4096
80003582:	5f 0a       	sreq	r10
80003584:	e0 48 20 00 	cp.w	r8,8192
80003588:	5f 09       	sreq	r9
8000358a:	f5 e9 10 09 	or	r9,r10,r9
8000358e:	c0 71       	brne	8000359c <phy_tx+0x48>
80003590:	e0 48 50 00 	cp.w	r8,20480
80003594:	c0 40       	breq	8000359c <phy_tx+0x48>
80003596:	e0 48 60 00 	cp.w	r8,24576
8000359a:	c0 31       	brne	800035a0 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
8000359c:	48 48       	lddpc	r8,800035ac <phy_tx+0x58>
8000359e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
800035a0:	2f fd       	sub	sp,-4
800035a2:	d8 02       	popm	pc
800035a4:	00 00       	add	r0,r0
800035a6:	0a f4       	st.b	--r5,r4
800035a8:	80 00       	ld.sh	r0,r0[0x0]
800035aa:	73 1c       	ld.w	r12,r9[0x44]
800035ac:	00 00       	add	r0,r0
800035ae:	0a e8       	st.h	--r5,r8

800035b0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
800035b0:	d4 01       	pushm	lr
800035b2:	20 2d       	sub	sp,8
	void * ptr = NULL;
800035b4:	30 08       	mov	r8,0
800035b6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800035b8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
800035ba:	1a 9a       	mov	r10,sp
800035bc:	fa cb ff fc 	sub	r11,sp,-4
800035c0:	f0 1f 00 05 	mcall	800035d4 <get_idle_store_isr+0x24>
800035c4:	58 1c       	cp.w	r12,1
800035c6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800035ca:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
800035ce:	2f ed       	sub	sp,-8
800035d0:	d8 02       	popm	pc
800035d2:	00 00       	add	r0,r0
800035d4:	80 00       	ld.sh	r0,r0[0x0]
800035d6:	70 20       	ld.w	r0,r8[0x8]

800035d8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
800035d8:	eb cd 40 c0 	pushm	r6-r7,lr
800035dc:	20 1d       	sub	sp,4
800035de:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
800035e0:	4b a8       	lddpc	r8,800036c8 <phy_tx_func+0xf0>
800035e2:	70 08       	ld.w	r8,r8[0x0]
800035e4:	58 08       	cp.w	r8,0
800035e6:	c6 60       	breq	800036b2 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
800035e8:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800035ea:	30 08       	mov	r8,0
800035ec:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800035ee:	4b 88       	lddpc	r8,800036cc <phy_tx_func+0xf4>
800035f0:	70 08       	ld.w	r8,r8[0x0]
800035f2:	58 18       	cp.w	r8,1
800035f4:	c2 60       	breq	80003640 <phy_tx_func+0x68>
800035f6:	c0 43       	brcs	800035fe <phy_tx_func+0x26>
800035f8:	58 28       	cp.w	r8,2
800035fa:	c5 c1       	brne	800036b2 <phy_tx_func+0xda>
800035fc:	c5 58       	rjmp	800036a6 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800035fe:	4b 38       	lddpc	r8,800036c8 <phy_tx_func+0xf0>
80003600:	70 0c       	ld.w	r12,r8[0x0]
80003602:	1a 9a       	mov	r10,sp
80003604:	4b 3b       	lddpc	r11,800036d0 <phy_tx_func+0xf8>
80003606:	f0 1f 00 34 	mcall	800036d4 <phy_tx_func+0xfc>
8000360a:	58 1c       	cp.w	r12,1
8000360c:	c1 41       	brne	80003634 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
8000360e:	4b 18       	lddpc	r8,800036d0 <phy_tx_func+0xf8>
80003610:	70 08       	ld.w	r8,r8[0x0]
80003612:	90 08       	ld.sh	r8,r8[0x0]
80003614:	10 9a       	mov	r10,r8
80003616:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000361a:	4b 09       	lddpc	r9,800036d8 <phy_tx_func+0x100>
8000361c:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
8000361e:	5c 78       	castu.h	r8
80003620:	ea 18 ab cd 	orh	r8,0xabcd
80003624:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003626:	30 19       	mov	r9,1
80003628:	4a d8       	lddpc	r8,800036dc <phy_tx_func+0x104>
8000362a:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
8000362c:	30 19       	mov	r9,1
8000362e:	4a 88       	lddpc	r8,800036cc <phy_tx_func+0xf4>
80003630:	91 09       	st.w	r8[0x0],r9
80003632:	c4 08       	rjmp	800036b2 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003634:	e0 68 5a 5a 	mov	r8,23130
80003638:	ea 18 ab cd 	orh	r8,0xabcd
8000363c:	8f 18       	st.w	r7[0x4],r8
8000363e:	c3 a8       	rjmp	800036b2 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003640:	4a 7a       	lddpc	r10,800036dc <phy_tx_func+0x104>
80003642:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003644:	4a 39       	lddpc	r9,800036d0 <phy_tx_func+0xf8>
80003646:	72 09       	ld.w	r9,r9[0x0]
80003648:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
8000364c:	b1 69       	lsl	r9,0x10
8000364e:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003650:	2f f8       	sub	r8,-1
80003652:	5c 58       	castu.b	r8
80003654:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80003656:	4a 1b       	lddpc	r11,800036d8 <phy_tx_func+0x100>
80003658:	96 0c       	ld.sh	r12,r11[0x0]
8000365a:	20 2c       	sub	r12,2
8000365c:	5c 8c       	casts.h	r12
8000365e:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80003662:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003664:	30 0b       	mov	r11,0
80003666:	f6 0a 19 00 	cp.h	r10,r11
8000366a:	e0 89 00 09 	brgt	8000367c <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
8000366e:	e8 19 00 ba 	orl	r9,0xba
80003672:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80003674:	30 09       	mov	r9,0
80003676:	49 68       	lddpc	r8,800036cc <phy_tx_func+0xf4>
80003678:	91 09       	st.w	r8[0x0],r9
8000367a:	c1 c8       	rjmp	800036b2 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
8000367c:	49 5a       	lddpc	r10,800036d0 <phy_tx_func+0xf8>
8000367e:	74 0a       	ld.w	r10,r10[0x0]
80003680:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003684:	14 49       	or	r9,r10
80003686:	8f 19       	st.w	r7[0x4],r9
80003688:	2f f8       	sub	r8,-1
8000368a:	49 59       	lddpc	r9,800036dc <phy_tx_func+0x104>
8000368c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000368e:	20 2c       	sub	r12,2
80003690:	49 28       	lddpc	r8,800036d8 <phy_tx_func+0x100>
80003692:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003694:	30 08       	mov	r8,0
80003696:	f0 0c 19 00 	cp.h	r12,r8
8000369a:	e0 89 00 0c 	brgt	800036b2 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
8000369e:	30 29       	mov	r9,2
800036a0:	48 b8       	lddpc	r8,800036cc <phy_tx_func+0xf4>
800036a2:	91 09       	st.w	r8[0x0],r9
800036a4:	c0 78       	rjmp	800036b2 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
800036a6:	fc 18 00 ba 	movh	r8,0xba
800036aa:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
800036ac:	30 09       	mov	r9,0
800036ae:	48 88       	lddpc	r8,800036cc <phy_tx_func+0xf4>
800036b0:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
800036b2:	e0 68 5a 5a 	mov	r8,23130
800036b6:	ea 18 ab cd 	orh	r8,0xabcd
800036ba:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
800036bc:	30 08       	mov	r8,0
800036be:	8f 38       	st.w	r7[0xc],r8
}
800036c0:	2f fd       	sub	sp,-4
800036c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800036c6:	00 00       	add	r0,r0
800036c8:	00 00       	add	r0,r0
800036ca:	0a f4       	st.b	--r5,r4
800036cc:	00 00       	add	r0,r0
800036ce:	0a b4       	st.h	r5++,r4
800036d0:	00 00       	add	r0,r0
800036d2:	0a c0       	st.b	r5++,r0
800036d4:	80 00       	ld.sh	r0,r0[0x0]
800036d6:	70 20       	ld.w	r0,r8[0x8]
800036d8:	00 00       	add	r0,r0
800036da:	0a dc       	st.w	--r5,r12
800036dc:	00 00       	add	r0,r0
800036de:	0a 94       	mov	r4,r5

800036e0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800036e0:	d4 01       	pushm	lr
800036e2:	20 1d       	sub	sp,4
	void * ptr = NULL;
800036e4:	30 0a       	mov	r10,0
800036e6:	fa cb ff fc 	sub	r11,sp,-4
800036ea:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800036ec:	14 99       	mov	r9,r10
800036ee:	1a 9b       	mov	r11,sp
800036f0:	f0 1f 00 05 	mcall	80003704 <get_idle_store+0x24>
800036f4:	58 1c       	cp.w	r12,1
800036f6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800036fa:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800036fe:	2f fd       	sub	sp,-4
80003700:	d8 02       	popm	pc
80003702:	00 00       	add	r0,r0
80003704:	80 00       	ld.sh	r0,r0[0x0]
80003706:	71 10       	ld.w	r0,r8[0x44]

80003708 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003708:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000370a:	48 5b       	lddpc	r11,8000371c <phy_init+0x14>
8000370c:	48 5c       	lddpc	r12,80003720 <phy_init+0x18>
8000370e:	f0 1f 00 06 	mcall	80003724 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80003712:	f0 1f 00 06 	mcall	80003728 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80003716:	f0 1f 00 06 	mcall	8000372c <phy_init+0x24>
	
}
8000371a:	d8 02       	popm	pc
8000371c:	80 00       	ld.sh	r0,r0[0x0]
8000371e:	35 d8       	mov	r8,93
80003720:	80 00       	ld.sh	r0,r0[0x0]
80003722:	37 30       	mov	r0,115
80003724:	80 00       	ld.sh	r0,r0[0x0]
80003726:	47 84       	lddsp	r4,sp[0x1e0]
80003728:	80 00       	ld.sh	r0,r0[0x0]
8000372a:	47 98       	lddsp	r8,sp[0x1e4]
8000372c:	80 00       	ld.sh	r0,r0[0x0]
8000372e:	51 48       	stdsp	sp[0x50],r8

80003730 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003730:	eb cd 40 e0 	pushm	r5-r7,lr
80003734:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003736:	fe f8 0e 7a 	ld.w	r8,pc[3706]
8000373a:	70 08       	ld.w	r8,r8[0x0]
8000373c:	58 08       	cp.w	r8,0
8000373e:	e0 80 01 08 	breq	8000394e <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003742:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003744:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003748:	70 09       	ld.w	r9,r8[0x0]
8000374a:	2f f9       	sub	r9,-1
8000374c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000374e:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80003752:	70 08       	ld.w	r8,r8[0x0]
80003754:	58 18       	cp.w	r8,1
80003756:	e0 80 00 85 	breq	80003860 <phy_rx_func+0x130>
8000375a:	c0 73       	brcs	80003768 <phy_rx_func+0x38>
8000375c:	58 28       	cp.w	r8,2
8000375e:	c5 c0       	breq	80003816 <phy_rx_func+0xe6>
80003760:	58 38       	cp.w	r8,3
80003762:	e0 81 00 f6 	brne	8000394e <phy_rx_func+0x21e>
80003766:	cd 58       	rjmp	80003910 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003768:	e0 6a 5a 5a 	mov	r10,23130
8000376c:	ea 1a ab cd 	orh	r10,0xabcd
80003770:	14 36       	cp.w	r6,r10
80003772:	e0 80 00 ee 	breq	8000394e <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003776:	ec 08 16 10 	lsr	r8,r6,0x10
8000377a:	e0 48 ab cd 	cp.w	r8,43981
8000377e:	e0 81 00 e8 	brne	8000394e <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003782:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003786:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000378a:	20 28       	sub	r8,2
8000378c:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003790:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003792:	30 09       	mov	r9,0
80003794:	f2 08 19 00 	cp.h	r8,r9
80003798:	e0 8a 00 db 	brle	8000394e <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
8000379c:	fe f8 0e 24 	ld.w	r8,pc[3620]
800037a0:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
800037a2:	fe f8 0e 22 	ld.w	r8,pc[3618]
800037a6:	70 0c       	ld.w	r12,r8[0x0]
800037a8:	f0 1f 03 88 	mcall	800045c8 <phy_rx_func+0xe98>
800037ac:	fe f8 0e 20 	ld.w	r8,pc[3616]
800037b0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800037b2:	58 0c       	cp.w	r12,0
800037b4:	e0 80 00 cd 	breq	8000394e <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800037b8:	fe f8 0e 08 	ld.w	r8,pc[3592]
800037bc:	90 09       	ld.sh	r9,r8[0x0]
800037be:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800037c2:	2f f9       	sub	r9,-1
800037c4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800037c6:	fe fa 0e 06 	ld.w	r10,pc[3590]
800037ca:	74 0a       	ld.w	r10,r10[0x0]
800037cc:	fe fb 0d e8 	ld.w	r11,pc[3560]
800037d0:	76 0b       	ld.w	r11,r11[0x0]
800037d2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800037d6:	2f f9       	sub	r9,-1
800037d8:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800037da:	e2 16 0f 00 	andl	r6,0xf00,COH
800037de:	e0 46 01 00 	cp.w	r6,256
800037e2:	c0 c0       	breq	800037fa <phy_rx_func+0xca>
800037e4:	e0 8b 00 05 	brhi	800037ee <phy_rx_func+0xbe>
800037e8:	58 06       	cp.w	r6,0
800037ea:	c0 80       	breq	800037fa <phy_rx_func+0xca>
800037ec:	c0 c8       	rjmp	80003804 <phy_rx_func+0xd4>
800037ee:	e0 46 02 00 	cp.w	r6,512
800037f2:	c0 40       	breq	800037fa <phy_rx_func+0xca>
800037f4:	e0 46 03 00 	cp.w	r6,768
800037f8:	c0 61       	brne	80003804 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800037fa:	30 29       	mov	r9,2
800037fc:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003800:	91 09       	st.w	r8[0x0],r9
80003802:	ca 68       	rjmp	8000394e <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003804:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003808:	70 0c       	ld.w	r12,r8[0x0]
8000380a:	fe f8 0d c2 	ld.w	r8,pc[3522]
8000380e:	70 0b       	ld.w	r11,r8[0x0]
80003810:	f0 1f 03 70 	mcall	800045d0 <phy_rx_func+0xea0>
80003814:	c9 d8       	rjmp	8000394e <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003816:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000381a:	b1 86       	lsr	r6,0x10
8000381c:	14 06       	add	r6,r10
8000381e:	fe f8 0d b6 	ld.w	r8,pc[3510]
80003822:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003824:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003828:	90 09       	ld.sh	r9,r8[0x0]
8000382a:	fe fb 0d a2 	ld.w	r11,pc[3490]
8000382e:	76 0b       	ld.w	r11,r11[0x0]
80003830:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003834:	2f f9       	sub	r9,-1
80003836:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003838:	fe f9 0d 84 	ld.w	r9,pc[3460]
8000383c:	92 08       	ld.sh	r8,r9[0x0]
8000383e:	20 28       	sub	r8,2
80003840:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003842:	30 09       	mov	r9,0
80003844:	f2 08 19 00 	cp.h	r8,r9
80003848:	e0 8a 00 07 	brle	80003856 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000384c:	30 19       	mov	r9,1
8000384e:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003852:	91 09       	st.w	r8[0x0],r9
80003854:	c7 d8       	rjmp	8000394e <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003856:	30 39       	mov	r9,3
80003858:	fe f8 0d 60 	ld.w	r8,pc[3424]
8000385c:	91 09       	st.w	r8[0x0],r9
8000385e:	c7 88       	rjmp	8000394e <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003860:	ec 0a 14 10 	asr	r10,r6,0x10
80003864:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003868:	90 09       	ld.sh	r9,r8[0x0]
8000386a:	14 09       	add	r9,r10
8000386c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000386e:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003872:	92 08       	ld.sh	r8,r9[0x0]
80003874:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003878:	76 0b       	ld.w	r11,r11[0x0]
8000387a:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000387e:	2f f8       	sub	r8,-1
80003880:	5c 88       	casts.h	r8
80003882:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003884:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003888:	94 09       	ld.sh	r9,r10[0x0]
8000388a:	20 29       	sub	r9,2
8000388c:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000388e:	30 0a       	mov	r10,0
80003890:	f4 09 19 00 	cp.h	r9,r10
80003894:	e0 89 00 20 	brgt	800038d4 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003898:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000389c:	e0 46 00 ba 	cp.w	r6,186
800038a0:	c0 d1       	brne	800038ba <phy_rx_func+0x18a>
800038a2:	fe f8 0d 32 	ld.w	r8,pc[3378]
800038a6:	90 09       	ld.sh	r9,r8[0x0]
800038a8:	f4 09 19 00 	cp.h	r9,r10
800038ac:	c0 71       	brne	800038ba <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800038ae:	fe f8 0d 1e 	ld.w	r8,pc[3358]
800038b2:	70 0c       	ld.w	r12,r8[0x0]
800038b4:	f0 1f 03 49 	mcall	800045d8 <phy_rx_func+0xea8>
800038b8:	c0 98       	rjmp	800038ca <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
800038ba:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800038be:	70 0c       	ld.w	r12,r8[0x0]
800038c0:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800038c4:	70 0b       	ld.w	r11,r8[0x0]
800038c6:	f0 1f 03 43 	mcall	800045d0 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800038ca:	30 09       	mov	r9,0
800038cc:	fe f8 0c ec 	ld.w	r8,pc[3308]
800038d0:	91 09       	st.w	r8[0x0],r9
800038d2:	c3 e8       	rjmp	8000394e <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800038d4:	5c 86       	casts.h	r6
800038d6:	fe f9 0c fe 	ld.w	r9,pc[3326]
800038da:	92 0a       	ld.sh	r10,r9[0x0]
800038dc:	0c 0a       	add	r10,r6
800038de:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800038e0:	fe f9 0c ec 	ld.w	r9,pc[3308]
800038e4:	72 09       	ld.w	r9,r9[0x0]
800038e6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800038ea:	2f f8       	sub	r8,-1
800038ec:	fe f9 0c d4 	ld.w	r9,pc[3284]
800038f0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800038f2:	fe f9 0c ca 	ld.w	r9,pc[3274]
800038f6:	92 08       	ld.sh	r8,r9[0x0]
800038f8:	20 28       	sub	r8,2
800038fa:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800038fc:	30 09       	mov	r9,0
800038fe:	f2 08 19 00 	cp.h	r8,r9
80003902:	e0 89 00 26 	brgt	8000394e <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003906:	30 39       	mov	r9,3
80003908:	fe f8 0c b0 	ld.w	r8,pc[3248]
8000390c:	91 09       	st.w	r8[0x0],r9
8000390e:	c2 08       	rjmp	8000394e <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003910:	e6 16 00 ff 	andh	r6,0xff,COH
80003914:	fc 19 00 ba 	movh	r9,0xba
80003918:	12 36       	cp.w	r6,r9
8000391a:	c0 e1       	brne	80003936 <phy_rx_func+0x206>
8000391c:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003920:	90 09       	ld.sh	r9,r8[0x0]
80003922:	30 08       	mov	r8,0
80003924:	f0 09 19 00 	cp.h	r9,r8
80003928:	c0 71       	brne	80003936 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000392a:	fe f8 0c a2 	ld.w	r8,pc[3234]
8000392e:	70 0c       	ld.w	r12,r8[0x0]
80003930:	f0 1f 03 2a 	mcall	800045d8 <phy_rx_func+0xea8>
80003934:	c0 98       	rjmp	80003946 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80003936:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000393a:	70 0c       	ld.w	r12,r8[0x0]
8000393c:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003940:	70 0b       	ld.w	r11,r8[0x0]
80003942:	f0 1f 03 24 	mcall	800045d0 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003946:	30 09       	mov	r9,0
80003948:	fe f8 0c 70 	ld.w	r8,pc[3184]
8000394c:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
8000394e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003952:	11 89       	ld.ub	r9,r8[0x0]
80003954:	30 08       	mov	r8,0
80003956:	f0 09 18 00 	cp.b	r9,r8
8000395a:	c1 31       	brne	80003980 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
8000395c:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003960:	6c 0c       	ld.w	r12,r6[0x0]
80003962:	f0 1f 03 1a 	mcall	800045c8 <phy_rx_func+0xe98>
80003966:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000396a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000396c:	6c 0c       	ld.w	r12,r6[0x0]
8000396e:	f0 1f 03 17 	mcall	800045c8 <phy_rx_func+0xe98>
80003972:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003976:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003978:	30 19       	mov	r9,1
8000397a:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000397e:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003980:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003984:	70 08       	ld.w	r8,r8[0x0]
80003986:	58 28       	cp.w	r8,2
80003988:	e0 80 01 98 	breq	80003cb8 <phy_rx_func+0x588>
8000398c:	e0 8b 00 06 	brhi	80003998 <phy_rx_func+0x268>
80003990:	58 08       	cp.w	r8,0
80003992:	c0 b0       	breq	800039a8 <phy_rx_func+0x278>
80003994:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003998:	58 38       	cp.w	r8,3
8000399a:	e0 80 05 c5 	breq	80004524 <phy_rx_func+0xdf4>
8000399e:	58 48       	cp.w	r8,4
800039a0:	e0 81 06 05 	brne	800045aa <phy_rx_func+0xe7a>
800039a4:	e0 8f 02 4b 	bral	80003e3a <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800039a8:	6e 28       	ld.w	r8,r7[0x8]
800039aa:	e0 6a 5a 5a 	mov	r10,23130
800039ae:	ea 1a ab cd 	orh	r10,0xabcd
800039b2:	14 38       	cp.w	r8,r10
800039b4:	c0 71       	brne	800039c2 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800039b6:	30 09       	mov	r9,0
800039b8:	fe f8 0c 38 	ld.w	r8,pc[3128]
800039bc:	91 09       	st.w	r8[0x0],r9
800039be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800039c2:	10 99       	mov	r9,r8
800039c4:	e0 19 00 00 	andl	r9,0x0
800039c8:	fc 1a ab cd 	movh	r10,0xabcd
800039cc:	14 39       	cp.w	r9,r10
800039ce:	e0 81 05 ee 	brne	800045aa <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800039d2:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800039d6:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800039da:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800039dc:	6e 29       	ld.w	r9,r7[0x8]
800039de:	e2 19 f0 00 	andl	r9,0xf000,COH
800039e2:	e0 49 c0 00 	cp.w	r9,49152
800039e6:	e0 81 00 ce 	brne	80003b82 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800039ea:	30 1a       	mov	r10,1
800039ec:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800039f0:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800039f2:	fe f9 0b f6 	ld.w	r9,pc[3062]
800039f6:	72 09       	ld.w	r9,r9[0x0]
800039f8:	58 09       	cp.w	r9,0
800039fa:	c0 71       	brne	80003a08 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800039fc:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003a00:	f0 1f 03 00 	mcall	80004600 <phy_rx_func+0xed0>
80003a04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003a08:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003a0c:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003a10:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003a12:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a16:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003a1a:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003a1e:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003a20:	13 89       	ld.ub	r9,r9[0x0]
80003a22:	37 fa       	mov	r10,127
80003a24:	f4 09 18 00 	cp.b	r9,r10
80003a28:	c6 d0       	breq	80003b02 <phy_rx_func+0x3d2>
80003a2a:	e0 8b 00 0c 	brhi	80003a42 <phy_rx_func+0x312>
80003a2e:	31 2a       	mov	r10,18
80003a30:	f4 09 18 00 	cp.b	r9,r10
80003a34:	c4 20       	breq	80003ab8 <phy_rx_func+0x388>
80003a36:	31 3a       	mov	r10,19
80003a38:	f4 09 18 00 	cp.b	r9,r10
80003a3c:	e0 81 00 83 	brne	80003b42 <phy_rx_func+0x412>
80003a40:	c5 b8       	rjmp	80003af6 <phy_rx_func+0x3c6>
80003a42:	2f 09       	sub	r9,-16
80003a44:	30 1a       	mov	r10,1
80003a46:	f4 09 18 00 	cp.b	r9,r10
80003a4a:	e0 8b 00 7c 	brhi	80003b42 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003a4e:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003a52:	e2 18 00 f0 	andl	r8,0xf0,COH
80003a56:	59 08       	cp.w	r8,16
80003a58:	c0 71       	brne	80003a66 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003a5a:	30 19       	mov	r9,1
80003a5c:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003a60:	91 09       	st.w	r8[0x0],r9
80003a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003a66:	e0 48 00 20 	cp.w	r8,32
80003a6a:	c2 11       	brne	80003aac <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003a6c:	30 a9       	mov	r9,10
80003a6e:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003a72:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003a74:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003a78:	6c 08       	ld.w	r8,r6[0x0]
80003a7a:	f0 0a 11 ff 	rsub	r10,r8,-1
80003a7e:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003a82:	2f f8       	sub	r8,-1
80003a84:	6e 0c       	ld.w	r12,r7[0x0]
80003a86:	f4 ca fe 00 	sub	r10,r10,-512
80003a8a:	30 0b       	mov	r11,0
80003a8c:	10 0c       	add	r12,r8
80003a8e:	f0 1f 02 e1 	mcall	80004610 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003a92:	30 08       	mov	r8,0
80003a94:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003a96:	6e 0c       	ld.w	r12,r7[0x0]
80003a98:	f0 1f 02 df 	mcall	80004614 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a9c:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003aa0:	70 0c       	ld.w	r12,r8[0x0]
80003aa2:	f0 1f 02 ca 	mcall	800045c8 <phy_rx_func+0xe98>
80003aa6:	8f 0c       	st.w	r7[0x0],r12
80003aa8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003aac:	30 09       	mov	r9,0
80003aae:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003ab2:	91 09       	st.w	r8[0x0],r9
80003ab4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003ab8:	20 48       	sub	r8,4
80003aba:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003abe:	93 08       	st.w	r9[0x0],r8
80003ac0:	58 08       	cp.w	r8,0
80003ac2:	e0 80 05 74 	breq	800045aa <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003ac6:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003aca:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003ace:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003ad2:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003ad4:	8e 69       	ld.sh	r9,r7[0xc]
80003ad6:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003ada:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003adc:	8e 79       	ld.sh	r9,r7[0xe]
80003ade:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003ae0:	f0 1f 02 d0 	mcall	80004620 <phy_rx_func+0xef0>
80003ae4:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003ae8:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003aea:	30 49       	mov	r9,4
80003aec:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003af0:	91 09       	st.w	r8[0x0],r9
80003af2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003af6:	30 09       	mov	r9,0
80003af8:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003afc:	91 09       	st.w	r8[0x0],r9
80003afe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003b02:	20 48       	sub	r8,4
80003b04:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003b08:	93 08       	st.w	r9[0x0],r8
80003b0a:	58 08       	cp.w	r8,0
80003b0c:	e0 80 05 4f 	breq	800045aa <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003b10:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003b14:	70 09       	ld.w	r9,r8[0x0]
80003b16:	8e 7b       	ld.sh	r11,r7[0xe]
80003b18:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003b1c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003b20:	2f f9       	sub	r9,-1
80003b22:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003b24:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003b28:	70 09       	ld.w	r9,r8[0x0]
80003b2a:	20 29       	sub	r9,2
80003b2c:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003b2e:	30 29       	mov	r9,2
80003b30:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003b34:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003b36:	30 39       	mov	r9,3
80003b38:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003b3c:	91 09       	st.w	r8[0x0],r9
80003b3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003b42:	30 3a       	mov	r10,3
80003b44:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003b48:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003b4a:	6e 2a       	ld.w	r10,r7[0x8]
80003b4c:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003b50:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003b52:	6e 3a       	ld.w	r10,r7[0xc]
80003b54:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003b56:	59 48       	cp.w	r8,20
80003b58:	c0 61       	brne	80003b64 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003b5a:	31 89       	mov	r9,24
80003b5c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003b60:	91 09       	st.w	r8[0x0],r9
80003b62:	c0 a8       	rjmp	80003b76 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003b64:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003b68:	70 08       	ld.w	r8,r8[0x0]
80003b6a:	59 08       	cp.w	r8,16
80003b6c:	c0 51       	brne	80003b76 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003b6e:	31 09       	mov	r9,16
80003b70:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003b74:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003b76:	30 49       	mov	r9,4
80003b78:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003b7c:	91 09       	st.w	r8[0x0],r9
80003b7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003b82:	e0 49 10 00 	cp.w	r9,4096
80003b86:	5f 1a       	srne	r10
80003b88:	e0 49 20 00 	cp.w	r9,8192
80003b8c:	5f 19       	srne	r9
80003b8e:	f5 e9 00 09 	and	r9,r10,r9
80003b92:	e0 81 05 0c 	brne	800045aa <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003b96:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003b9a:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003b9c:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003ba0:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003ba2:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003ba6:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003ba8:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003bac:	72 09       	ld.w	r9,r9[0x0]
80003bae:	58 09       	cp.w	r9,0
80003bb0:	c0 71       	brne	80003bbe <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003bb2:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003bb6:	f0 1f 02 93 	mcall	80004600 <phy_rx_func+0xed0>
80003bba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bbe:	6e 2a       	ld.w	r10,r7[0x8]
80003bc0:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003bc4:	58 1a       	cp.w	r10,1
80003bc6:	e0 8b 00 4d 	brhi	80003c60 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003bca:	20 48       	sub	r8,4
80003bcc:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003bd0:	93 08       	st.w	r9[0x0],r8
80003bd2:	58 08       	cp.w	r8,0
80003bd4:	e0 80 04 eb 	breq	800045aa <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003bd8:	8e 68       	ld.sh	r8,r7[0xc]
80003bda:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003bde:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003be2:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003be4:	30 09       	mov	r9,0
80003be6:	f2 08 19 00 	cp.h	r8,r9
80003bea:	c0 70       	breq	80003bf8 <phy_rx_func+0x4c8>
80003bec:	30 19       	mov	r9,1
80003bee:	f2 08 19 00 	cp.h	r8,r9
80003bf2:	e0 81 04 dc 	brne	800045aa <phy_rx_func+0xe7a>
80003bf6:	c2 68       	rjmp	80003c42 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003bf8:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003bfc:	70 0a       	ld.w	r10,r8[0x0]
80003bfe:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003c02:	72 09       	ld.w	r9,r9[0x0]
80003c04:	8e 7b       	ld.sh	r11,r7[0xe]
80003c06:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003c0a:	70 09       	ld.w	r9,r8[0x0]
80003c0c:	2f f9       	sub	r9,-1
80003c0e:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c10:	e0 49 00 ff 	cp.w	r9,255
80003c14:	e0 88 00 11 	brls	80003c36 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003c18:	30 09       	mov	r9,0
80003c1a:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003c1c:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003c20:	6e 0c       	ld.w	r12,r7[0x0]
80003c22:	f0 1f 02 7d 	mcall	80004614 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003c26:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003c2a:	70 0c       	ld.w	r12,r8[0x0]
80003c2c:	f0 1f 02 67 	mcall	800045c8 <phy_rx_func+0xe98>
80003c30:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003c32:	e0 80 04 bc 	breq	800045aa <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003c36:	30 29       	mov	r9,2
80003c38:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003c3c:	91 09       	st.w	r8[0x0],r9
80003c3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c42:	8e 79       	ld.sh	r9,r7[0xe]
80003c44:	30 38       	mov	r8,3
80003c46:	f0 09 19 00 	cp.h	r9,r8
80003c4a:	c0 51       	brne	80003c54 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003c4c:	30 19       	mov	r9,1
80003c4e:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003c52:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003c54:	30 29       	mov	r9,2
80003c56:	fe f8 09 96 	ld.w	r8,pc[2454]
80003c5a:	91 09       	st.w	r8[0x0],r9
80003c5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003c60:	58 18       	cp.w	r8,1
80003c62:	e0 88 04 a4 	brls	800045aa <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003c66:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003c6a:	70 0a       	ld.w	r10,r8[0x0]
80003c6c:	6e 3b       	ld.w	r11,r7[0xc]
80003c6e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003c72:	70 09       	ld.w	r9,r8[0x0]
80003c74:	2f f9       	sub	r9,-1
80003c76:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c78:	e0 49 00 ff 	cp.w	r9,255
80003c7c:	e0 88 00 11 	brls	80003c9e <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003c80:	30 09       	mov	r9,0
80003c82:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003c84:	fe f7 09 60 	ld.w	r7,pc[2400]
80003c88:	6e 0c       	ld.w	r12,r7[0x0]
80003c8a:	f0 1f 02 63 	mcall	80004614 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003c8e:	fe f8 09 52 	ld.w	r8,pc[2386]
80003c92:	70 0c       	ld.w	r12,r8[0x0]
80003c94:	f0 1f 02 4d 	mcall	800045c8 <phy_rx_func+0xe98>
80003c98:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003c9a:	e0 80 04 88 	breq	800045aa <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003c9e:	fe f9 09 56 	ld.w	r9,pc[2390]
80003ca2:	72 08       	ld.w	r8,r9[0x0]
80003ca4:	20 28       	sub	r8,2
80003ca6:	93 08       	st.w	r9[0x0],r8
80003ca8:	e0 80 04 81 	breq	800045aa <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003cac:	30 29       	mov	r9,2
80003cae:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003cb2:	91 09       	st.w	r8[0x0],r9
80003cb4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003cb8:	fe f8 09 84 	ld.w	r8,pc[2436]
80003cbc:	70 0a       	ld.w	r10,r8[0x0]
80003cbe:	fe f9 09 26 	ld.w	r9,pc[2342]
80003cc2:	72 09       	ld.w	r9,r9[0x0]
80003cc4:	8e 4b       	ld.sh	r11,r7[0x8]
80003cc6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003cca:	70 09       	ld.w	r9,r8[0x0]
80003ccc:	2f f9       	sub	r9,-1
80003cce:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003cd0:	e0 49 00 ff 	cp.w	r9,255
80003cd4:	e0 88 00 16 	brls	80003d00 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003cd8:	30 09       	mov	r9,0
80003cda:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003cdc:	fe f6 09 08 	ld.w	r6,pc[2312]
80003ce0:	6c 0c       	ld.w	r12,r6[0x0]
80003ce2:	f0 1f 02 4d 	mcall	80004614 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003ce6:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003cea:	70 0c       	ld.w	r12,r8[0x0]
80003cec:	f0 1f 02 37 	mcall	800045c8 <phy_rx_func+0xe98>
80003cf0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003cf2:	c0 71       	brne	80003d00 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003cf4:	30 09       	mov	r9,0
80003cf6:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003cfa:	91 09       	st.w	r8[0x0],r9
80003cfc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003d00:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003d04:	72 08       	ld.w	r8,r9[0x0]
80003d06:	20 28       	sub	r8,2
80003d08:	93 08       	st.w	r9[0x0],r8
80003d0a:	c0 71       	brne	80003d18 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003d0c:	30 09       	mov	r9,0
80003d0e:	fe f8 08 de 	ld.w	r8,pc[2270]
80003d12:	91 09       	st.w	r8[0x0],r9
80003d14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003d18:	fe f8 09 24 	ld.w	r8,pc[2340]
80003d1c:	70 0a       	ld.w	r10,r8[0x0]
80003d1e:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003d22:	72 09       	ld.w	r9,r9[0x0]
80003d24:	8e 5b       	ld.sh	r11,r7[0xa]
80003d26:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003d2a:	70 09       	ld.w	r9,r8[0x0]
80003d2c:	2f f9       	sub	r9,-1
80003d2e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d30:	e0 49 00 ff 	cp.w	r9,255
80003d34:	e0 88 00 16 	brls	80003d60 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003d38:	30 09       	mov	r9,0
80003d3a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d3c:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003d40:	6c 0c       	ld.w	r12,r6[0x0]
80003d42:	f0 1f 02 35 	mcall	80004614 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d46:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003d4a:	70 0c       	ld.w	r12,r8[0x0]
80003d4c:	f0 1f 02 1f 	mcall	800045c8 <phy_rx_func+0xe98>
80003d50:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003d52:	c0 71       	brne	80003d60 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003d54:	30 09       	mov	r9,0
80003d56:	fe f8 08 96 	ld.w	r8,pc[2198]
80003d5a:	91 09       	st.w	r8[0x0],r9
80003d5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003d60:	fe f9 08 94 	ld.w	r9,pc[2196]
80003d64:	72 08       	ld.w	r8,r9[0x0]
80003d66:	20 28       	sub	r8,2
80003d68:	93 08       	st.w	r9[0x0],r8
80003d6a:	c0 71       	brne	80003d78 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003d6c:	30 09       	mov	r9,0
80003d6e:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003d72:	91 09       	st.w	r8[0x0],r9
80003d74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003d78:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003d7c:	70 0a       	ld.w	r10,r8[0x0]
80003d7e:	fe f9 08 66 	ld.w	r9,pc[2150]
80003d82:	72 09       	ld.w	r9,r9[0x0]
80003d84:	8e 6b       	ld.sh	r11,r7[0xc]
80003d86:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003d8a:	70 09       	ld.w	r9,r8[0x0]
80003d8c:	2f f9       	sub	r9,-1
80003d8e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d90:	e0 49 00 ff 	cp.w	r9,255
80003d94:	e0 88 00 16 	brls	80003dc0 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003d98:	30 09       	mov	r9,0
80003d9a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d9c:	fe f6 08 48 	ld.w	r6,pc[2120]
80003da0:	6c 0c       	ld.w	r12,r6[0x0]
80003da2:	f0 1f 02 1d 	mcall	80004614 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003da6:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003daa:	70 0c       	ld.w	r12,r8[0x0]
80003dac:	f0 1f 02 07 	mcall	800045c8 <phy_rx_func+0xe98>
80003db0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003db2:	c0 71       	brne	80003dc0 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003db4:	30 09       	mov	r9,0
80003db6:	fe f8 08 36 	ld.w	r8,pc[2102]
80003dba:	91 09       	st.w	r8[0x0],r9
80003dbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003dc0:	fe f9 08 34 	ld.w	r9,pc[2100]
80003dc4:	72 08       	ld.w	r8,r9[0x0]
80003dc6:	20 28       	sub	r8,2
80003dc8:	93 08       	st.w	r9[0x0],r8
80003dca:	c0 71       	brne	80003dd8 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003dcc:	30 09       	mov	r9,0
80003dce:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003dd2:	91 09       	st.w	r8[0x0],r9
80003dd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003dd8:	fe f8 08 64 	ld.w	r8,pc[2148]
80003ddc:	70 0a       	ld.w	r10,r8[0x0]
80003dde:	fe f9 08 06 	ld.w	r9,pc[2054]
80003de2:	72 09       	ld.w	r9,r9[0x0]
80003de4:	8e 7b       	ld.sh	r11,r7[0xe]
80003de6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003dea:	70 09       	ld.w	r9,r8[0x0]
80003dec:	2f f9       	sub	r9,-1
80003dee:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003df0:	e0 49 00 ff 	cp.w	r9,255
80003df4:	e0 88 00 16 	brls	80003e20 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003df8:	30 09       	mov	r9,0
80003dfa:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003dfc:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003e00:	6e 0c       	ld.w	r12,r7[0x0]
80003e02:	f0 1f 02 05 	mcall	80004614 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003e06:	fe f8 07 da 	ld.w	r8,pc[2010]
80003e0a:	70 0c       	ld.w	r12,r8[0x0]
80003e0c:	f0 1f 01 ef 	mcall	800045c8 <phy_rx_func+0xe98>
80003e10:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003e12:	c0 71       	brne	80003e20 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003e14:	30 09       	mov	r9,0
80003e16:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003e1a:	91 09       	st.w	r8[0x0],r9
80003e1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003e20:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003e24:	72 08       	ld.w	r8,r9[0x0]
80003e26:	20 28       	sub	r8,2
80003e28:	93 08       	st.w	r9[0x0],r8
80003e2a:	e0 81 03 c0 	brne	800045aa <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003e2e:	30 09       	mov	r9,0
80003e30:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003e34:	91 09       	st.w	r8[0x0],r9
80003e36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003e3a:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003e3e:	11 89       	ld.ub	r9,r8[0x0]
80003e40:	31 28       	mov	r8,18
80003e42:	f0 09 18 00 	cp.b	r9,r8
80003e46:	e0 81 01 4c 	brne	800040de <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003e4a:	ef 39 00 09 	ld.ub	r9,r7[9]
80003e4e:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003e52:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003e54:	11 89       	ld.ub	r9,r8[0x0]
80003e56:	3f 28       	mov	r8,-14
80003e58:	f0 09 18 00 	cp.b	r9,r8
80003e5c:	e0 81 01 3b 	brne	800040d2 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003e60:	30 19       	mov	r9,1
80003e62:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003e66:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003e68:	6e 29       	ld.w	r9,r7[0x8]
80003e6a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003e6e:	fe f8 07 86 	ld.w	r8,pc[1926]
80003e72:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003e74:	8e 59       	ld.sh	r9,r7[0xa]
80003e76:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003e7a:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003e7c:	8e 69       	ld.sh	r9,r7[0xc]
80003e7e:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003e80:	8e 79       	ld.sh	r9,r7[0xe]
80003e82:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003e84:	fe f8 07 88 	ld.w	r8,pc[1928]
80003e88:	fe f9 07 60 	ld.w	r9,pc[1888]
80003e8c:	72 0a       	ld.w	r10,r9[0x0]
80003e8e:	70 09       	ld.w	r9,r8[0x0]
80003e90:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003e94:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003e98:	70 09       	ld.w	r9,r8[0x0]
80003e9a:	2f f9       	sub	r9,-1
80003e9c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e9e:	e0 49 01 ff 	cp.w	r9,511
80003ea2:	e0 88 00 16 	brls	80003ece <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ea6:	30 09       	mov	r9,0
80003ea8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003eaa:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003eae:	6c 0c       	ld.w	r12,r6[0x0]
80003eb0:	f0 1f 01 d9 	mcall	80004614 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003eb4:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003eb8:	70 0c       	ld.w	r12,r8[0x0]
80003eba:	f0 1f 01 c4 	mcall	800045c8 <phy_rx_func+0xe98>
80003ebe:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ec0:	c0 71       	brne	80003ece <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003ec2:	30 09       	mov	r9,0
80003ec4:	fe f8 07 28 	ld.w	r8,pc[1832]
80003ec8:	91 09       	st.w	r8[0x0],r9
80003eca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003ece:	fe f9 07 26 	ld.w	r9,pc[1830]
80003ed2:	72 08       	ld.w	r8,r9[0x0]
80003ed4:	20 18       	sub	r8,1
80003ed6:	93 08       	st.w	r9[0x0],r8
80003ed8:	c0 71       	brne	80003ee6 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003eda:	30 09       	mov	r9,0
80003edc:	fe f8 07 10 	ld.w	r8,pc[1808]
80003ee0:	91 09       	st.w	r8[0x0],r9
80003ee2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003ee6:	fe f8 07 26 	ld.w	r8,pc[1830]
80003eea:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003eee:	72 0a       	ld.w	r10,r9[0x0]
80003ef0:	70 09       	ld.w	r9,r8[0x0]
80003ef2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003ef6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003efa:	70 09       	ld.w	r9,r8[0x0]
80003efc:	2f f9       	sub	r9,-1
80003efe:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f00:	e0 49 01 ff 	cp.w	r9,511
80003f04:	e0 88 00 16 	brls	80003f30 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f08:	30 09       	mov	r9,0
80003f0a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f0c:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003f10:	6c 0c       	ld.w	r12,r6[0x0]
80003f12:	f0 1f 01 c1 	mcall	80004614 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f16:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003f1a:	70 0c       	ld.w	r12,r8[0x0]
80003f1c:	f0 1f 01 ab 	mcall	800045c8 <phy_rx_func+0xe98>
80003f20:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f22:	c0 71       	brne	80003f30 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003f24:	30 09       	mov	r9,0
80003f26:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003f2a:	91 09       	st.w	r8[0x0],r9
80003f2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f30:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003f34:	72 08       	ld.w	r8,r9[0x0]
80003f36:	20 18       	sub	r8,1
80003f38:	93 08       	st.w	r9[0x0],r8
80003f3a:	c0 71       	brne	80003f48 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003f3c:	30 09       	mov	r9,0
80003f3e:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003f42:	91 09       	st.w	r8[0x0],r9
80003f44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003f48:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003f4c:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003f50:	72 0a       	ld.w	r10,r9[0x0]
80003f52:	70 09       	ld.w	r9,r8[0x0]
80003f54:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003f58:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f5c:	70 09       	ld.w	r9,r8[0x0]
80003f5e:	2f f9       	sub	r9,-1
80003f60:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f62:	e0 49 01 ff 	cp.w	r9,511
80003f66:	e0 88 00 16 	brls	80003f92 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f6a:	30 09       	mov	r9,0
80003f6c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f6e:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003f72:	6c 0c       	ld.w	r12,r6[0x0]
80003f74:	f0 1f 01 a8 	mcall	80004614 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f78:	fe f8 06 68 	ld.w	r8,pc[1640]
80003f7c:	70 0c       	ld.w	r12,r8[0x0]
80003f7e:	f0 1f 01 93 	mcall	800045c8 <phy_rx_func+0xe98>
80003f82:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f84:	c0 71       	brne	80003f92 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003f86:	30 09       	mov	r9,0
80003f88:	fe f8 06 64 	ld.w	r8,pc[1636]
80003f8c:	91 09       	st.w	r8[0x0],r9
80003f8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f92:	fe f9 06 62 	ld.w	r9,pc[1634]
80003f96:	72 08       	ld.w	r8,r9[0x0]
80003f98:	20 18       	sub	r8,1
80003f9a:	93 08       	st.w	r9[0x0],r8
80003f9c:	c0 71       	brne	80003faa <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003f9e:	30 09       	mov	r9,0
80003fa0:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003fa4:	91 09       	st.w	r8[0x0],r9
80003fa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003faa:	fe f8 06 62 	ld.w	r8,pc[1634]
80003fae:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003fb2:	72 0a       	ld.w	r10,r9[0x0]
80003fb4:	70 09       	ld.w	r9,r8[0x0]
80003fb6:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003fba:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003fbe:	70 09       	ld.w	r9,r8[0x0]
80003fc0:	2f f9       	sub	r9,-1
80003fc2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fc4:	e0 49 01 ff 	cp.w	r9,511
80003fc8:	e0 88 00 16 	brls	80003ff4 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003fcc:	30 09       	mov	r9,0
80003fce:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003fd0:	fe f6 06 18 	ld.w	r6,pc[1560]
80003fd4:	6c 0c       	ld.w	r12,r6[0x0]
80003fd6:	f0 1f 01 90 	mcall	80004614 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003fda:	fe f8 06 06 	ld.w	r8,pc[1542]
80003fde:	70 0c       	ld.w	r12,r8[0x0]
80003fe0:	f0 1f 01 7a 	mcall	800045c8 <phy_rx_func+0xe98>
80003fe4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003fe6:	c0 71       	brne	80003ff4 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003fe8:	30 09       	mov	r9,0
80003fea:	fe f8 06 02 	ld.w	r8,pc[1538]
80003fee:	91 09       	st.w	r8[0x0],r9
80003ff0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003ff4:	fe f9 06 00 	ld.w	r9,pc[1536]
80003ff8:	72 08       	ld.w	r8,r9[0x0]
80003ffa:	20 18       	sub	r8,1
80003ffc:	93 08       	st.w	r9[0x0],r8
80003ffe:	c0 71       	brne	8000400c <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80004000:	30 09       	mov	r9,0
80004002:	fe f8 05 ea 	ld.w	r8,pc[1514]
80004006:	91 09       	st.w	r8[0x0],r9
80004008:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000400c:	fe f8 06 00 	ld.w	r8,pc[1536]
80004010:	fe f9 05 d8 	ld.w	r9,pc[1496]
80004014:	72 0a       	ld.w	r10,r9[0x0]
80004016:	70 09       	ld.w	r9,r8[0x0]
80004018:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000401c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004020:	70 09       	ld.w	r9,r8[0x0]
80004022:	2f f9       	sub	r9,-1
80004024:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004026:	e0 49 01 ff 	cp.w	r9,511
8000402a:	e0 88 00 16 	brls	80004056 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000402e:	30 09       	mov	r9,0
80004030:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004032:	fe f6 05 b6 	ld.w	r6,pc[1462]
80004036:	6c 0c       	ld.w	r12,r6[0x0]
80004038:	f0 1f 01 77 	mcall	80004614 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000403c:	fe f8 05 a4 	ld.w	r8,pc[1444]
80004040:	70 0c       	ld.w	r12,r8[0x0]
80004042:	f0 1f 01 62 	mcall	800045c8 <phy_rx_func+0xe98>
80004046:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004048:	c0 71       	brne	80004056 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000404a:	30 09       	mov	r9,0
8000404c:	fe f8 05 a0 	ld.w	r8,pc[1440]
80004050:	91 09       	st.w	r8[0x0],r9
80004052:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004056:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000405a:	72 08       	ld.w	r8,r9[0x0]
8000405c:	20 18       	sub	r8,1
8000405e:	93 08       	st.w	r9[0x0],r8
80004060:	c0 71       	brne	8000406e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80004062:	30 09       	mov	r9,0
80004064:	fe f8 05 88 	ld.w	r8,pc[1416]
80004068:	91 09       	st.w	r8[0x0],r9
8000406a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000406e:	fe f8 05 9e 	ld.w	r8,pc[1438]
80004072:	fe f9 05 76 	ld.w	r9,pc[1398]
80004076:	72 0a       	ld.w	r10,r9[0x0]
80004078:	70 09       	ld.w	r9,r8[0x0]
8000407a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000407e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004082:	70 09       	ld.w	r9,r8[0x0]
80004084:	2f f9       	sub	r9,-1
80004086:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004088:	e0 49 01 ff 	cp.w	r9,511
8000408c:	e0 88 00 16 	brls	800040b8 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80004090:	30 09       	mov	r9,0
80004092:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004094:	fe f7 05 54 	ld.w	r7,pc[1364]
80004098:	6e 0c       	ld.w	r12,r7[0x0]
8000409a:	f0 1f 01 5f 	mcall	80004614 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000409e:	fe f8 05 42 	ld.w	r8,pc[1346]
800040a2:	70 0c       	ld.w	r12,r8[0x0]
800040a4:	f0 1f 01 49 	mcall	800045c8 <phy_rx_func+0xe98>
800040a8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800040aa:	c0 71       	brne	800040b8 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800040ac:	30 09       	mov	r9,0
800040ae:	fe f8 05 3e 	ld.w	r8,pc[1342]
800040b2:	91 09       	st.w	r8[0x0],r9
800040b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800040b8:	fe f9 05 3c 	ld.w	r9,pc[1340]
800040bc:	72 08       	ld.w	r8,r9[0x0]
800040be:	20 18       	sub	r8,1
800040c0:	93 08       	st.w	r9[0x0],r8
800040c2:	e0 81 02 74 	brne	800045aa <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800040c6:	30 09       	mov	r9,0
800040c8:	fe f8 05 24 	ld.w	r8,pc[1316]
800040cc:	91 09       	st.w	r8[0x0],r9
800040ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800040d2:	30 09       	mov	r9,0
800040d4:	fe f8 05 18 	ld.w	r8,pc[1304]
800040d8:	91 09       	st.w	r8[0x0],r9
800040da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800040de:	fe f8 05 26 	ld.w	r8,pc[1318]
800040e2:	11 89       	ld.ub	r9,r8[0x0]
800040e4:	3f 28       	mov	r8,-14
800040e6:	f0 09 18 00 	cp.b	r9,r8
800040ea:	c4 31       	brne	80004170 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800040ec:	8e 49       	ld.sh	r9,r7[0x8]
800040ee:	fe f8 05 56 	ld.w	r8,pc[1366]
800040f2:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800040f4:	fe f8 05 18 	ld.w	r8,pc[1304]
800040f8:	fe f9 04 f0 	ld.w	r9,pc[1264]
800040fc:	72 0a       	ld.w	r10,r9[0x0]
800040fe:	70 09       	ld.w	r9,r8[0x0]
80004100:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004104:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004108:	70 09       	ld.w	r9,r8[0x0]
8000410a:	2f f9       	sub	r9,-1
8000410c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000410e:	e0 49 01 ff 	cp.w	r9,511
80004112:	e0 88 00 16 	brls	8000413e <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80004116:	30 09       	mov	r9,0
80004118:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000411a:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000411e:	6e 0c       	ld.w	r12,r7[0x0]
80004120:	f0 1f 01 3d 	mcall	80004614 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004124:	fe f8 04 bc 	ld.w	r8,pc[1212]
80004128:	70 0c       	ld.w	r12,r8[0x0]
8000412a:	f0 1f 01 28 	mcall	800045c8 <phy_rx_func+0xe98>
8000412e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004130:	c0 71       	brne	8000413e <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80004132:	30 09       	mov	r9,0
80004134:	fe f8 04 b8 	ld.w	r8,pc[1208]
80004138:	91 09       	st.w	r8[0x0],r9
8000413a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000413e:	fe f9 04 b6 	ld.w	r9,pc[1206]
80004142:	72 08       	ld.w	r8,r9[0x0]
80004144:	20 18       	sub	r8,1
80004146:	93 08       	st.w	r9[0x0],r8
80004148:	c0 71       	brne	80004156 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
8000414a:	30 09       	mov	r9,0
8000414c:	fe f8 04 a0 	ld.w	r8,pc[1184]
80004150:	91 09       	st.w	r8[0x0],r9
80004152:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80004156:	20 18       	sub	r8,1
80004158:	fe f9 04 9c 	ld.w	r9,pc[1180]
8000415c:	93 08       	st.w	r9[0x0],r8
8000415e:	58 08       	cp.w	r8,0
80004160:	e0 81 02 25 	brne	800045aa <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80004164:	30 09       	mov	r9,0
80004166:	fe f8 04 86 	ld.w	r8,pc[1158]
8000416a:	91 09       	st.w	r8[0x0],r9
8000416c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80004170:	fe f8 04 94 	ld.w	r8,pc[1172]
80004174:	11 89       	ld.ub	r9,r8[0x0]
80004176:	3f 38       	mov	r8,-13
80004178:	f0 09 18 00 	cp.b	r9,r8
8000417c:	e0 81 01 0c 	brne	80004394 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80004180:	8e 49       	ld.sh	r9,r7[0x8]
80004182:	fe f8 04 c2 	ld.w	r8,pc[1218]
80004186:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80004188:	8e 59       	ld.sh	r9,r7[0xa]
8000418a:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000418c:	8e 69       	ld.sh	r9,r7[0xc]
8000418e:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80004190:	fe f8 04 7c 	ld.w	r8,pc[1148]
80004194:	fe f9 04 54 	ld.w	r9,pc[1108]
80004198:	72 0a       	ld.w	r10,r9[0x0]
8000419a:	70 09       	ld.w	r9,r8[0x0]
8000419c:	ef 3b 00 08 	ld.ub	r11,r7[8]
800041a0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800041a4:	70 09       	ld.w	r9,r8[0x0]
800041a6:	2f f9       	sub	r9,-1
800041a8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800041aa:	e0 49 01 ff 	cp.w	r9,511
800041ae:	e0 88 00 16 	brls	800041da <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800041b2:	30 09       	mov	r9,0
800041b4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800041b6:	fe f6 04 32 	ld.w	r6,pc[1074]
800041ba:	6c 0c       	ld.w	r12,r6[0x0]
800041bc:	f0 1f 01 16 	mcall	80004614 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800041c0:	fe f8 04 20 	ld.w	r8,pc[1056]
800041c4:	70 0c       	ld.w	r12,r8[0x0]
800041c6:	f0 1f 01 01 	mcall	800045c8 <phy_rx_func+0xe98>
800041ca:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800041cc:	c0 71       	brne	800041da <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800041ce:	30 09       	mov	r9,0
800041d0:	fe f8 04 1c 	ld.w	r8,pc[1052]
800041d4:	91 09       	st.w	r8[0x0],r9
800041d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800041da:	fe f9 04 1a 	ld.w	r9,pc[1050]
800041de:	72 08       	ld.w	r8,r9[0x0]
800041e0:	20 18       	sub	r8,1
800041e2:	93 08       	st.w	r9[0x0],r8
800041e4:	c0 71       	brne	800041f2 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800041e6:	30 09       	mov	r9,0
800041e8:	fe f8 04 04 	ld.w	r8,pc[1028]
800041ec:	91 09       	st.w	r8[0x0],r9
800041ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800041f2:	fe f8 04 1a 	ld.w	r8,pc[1050]
800041f6:	fe f9 03 f2 	ld.w	r9,pc[1010]
800041fa:	72 0a       	ld.w	r10,r9[0x0]
800041fc:	70 09       	ld.w	r9,r8[0x0]
800041fe:	ef 3b 00 09 	ld.ub	r11,r7[9]
80004202:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004206:	70 09       	ld.w	r9,r8[0x0]
80004208:	2f f9       	sub	r9,-1
8000420a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000420c:	e0 49 01 ff 	cp.w	r9,511
80004210:	e0 88 00 16 	brls	8000423c <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80004214:	30 09       	mov	r9,0
80004216:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004218:	fe f6 03 d0 	ld.w	r6,pc[976]
8000421c:	6c 0c       	ld.w	r12,r6[0x0]
8000421e:	f0 1f 00 fe 	mcall	80004614 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004222:	fe f8 03 be 	ld.w	r8,pc[958]
80004226:	70 0c       	ld.w	r12,r8[0x0]
80004228:	f0 1f 00 e8 	mcall	800045c8 <phy_rx_func+0xe98>
8000422c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000422e:	c0 71       	brne	8000423c <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80004230:	30 09       	mov	r9,0
80004232:	fe f8 03 ba 	ld.w	r8,pc[954]
80004236:	91 09       	st.w	r8[0x0],r9
80004238:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000423c:	fe f9 03 b8 	ld.w	r9,pc[952]
80004240:	72 08       	ld.w	r8,r9[0x0]
80004242:	20 18       	sub	r8,1
80004244:	93 08       	st.w	r9[0x0],r8
80004246:	c0 71       	brne	80004254 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80004248:	30 09       	mov	r9,0
8000424a:	fe f8 03 a2 	ld.w	r8,pc[930]
8000424e:	91 09       	st.w	r8[0x0],r9
80004250:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80004254:	fe f8 03 b8 	ld.w	r8,pc[952]
80004258:	fe f9 03 90 	ld.w	r9,pc[912]
8000425c:	72 0a       	ld.w	r10,r9[0x0]
8000425e:	70 09       	ld.w	r9,r8[0x0]
80004260:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004264:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004268:	70 09       	ld.w	r9,r8[0x0]
8000426a:	2f f9       	sub	r9,-1
8000426c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000426e:	e0 49 01 ff 	cp.w	r9,511
80004272:	e0 88 00 16 	brls	8000429e <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80004276:	30 09       	mov	r9,0
80004278:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000427a:	fe f6 03 6e 	ld.w	r6,pc[878]
8000427e:	6c 0c       	ld.w	r12,r6[0x0]
80004280:	f0 1f 00 e5 	mcall	80004614 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004284:	fe f8 03 5c 	ld.w	r8,pc[860]
80004288:	70 0c       	ld.w	r12,r8[0x0]
8000428a:	f0 1f 00 d0 	mcall	800045c8 <phy_rx_func+0xe98>
8000428e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004290:	c0 71       	brne	8000429e <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80004292:	30 09       	mov	r9,0
80004294:	fe f8 03 58 	ld.w	r8,pc[856]
80004298:	91 09       	st.w	r8[0x0],r9
8000429a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000429e:	fe f9 03 56 	ld.w	r9,pc[854]
800042a2:	72 08       	ld.w	r8,r9[0x0]
800042a4:	20 18       	sub	r8,1
800042a6:	93 08       	st.w	r9[0x0],r8
800042a8:	c0 71       	brne	800042b6 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800042aa:	30 09       	mov	r9,0
800042ac:	fe f8 03 40 	ld.w	r8,pc[832]
800042b0:	91 09       	st.w	r8[0x0],r9
800042b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800042b6:	fe f8 03 56 	ld.w	r8,pc[854]
800042ba:	fe f9 03 2e 	ld.w	r9,pc[814]
800042be:	72 0a       	ld.w	r10,r9[0x0]
800042c0:	70 09       	ld.w	r9,r8[0x0]
800042c2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800042c6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800042ca:	70 09       	ld.w	r9,r8[0x0]
800042cc:	2f f9       	sub	r9,-1
800042ce:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800042d0:	e0 49 01 ff 	cp.w	r9,511
800042d4:	e0 88 00 16 	brls	80004300 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800042d8:	30 09       	mov	r9,0
800042da:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800042dc:	fe f6 03 0c 	ld.w	r6,pc[780]
800042e0:	6c 0c       	ld.w	r12,r6[0x0]
800042e2:	f0 1f 00 cd 	mcall	80004614 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800042e6:	fe f8 02 fa 	ld.w	r8,pc[762]
800042ea:	70 0c       	ld.w	r12,r8[0x0]
800042ec:	f0 1f 00 b7 	mcall	800045c8 <phy_rx_func+0xe98>
800042f0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800042f2:	c0 71       	brne	80004300 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800042f4:	30 09       	mov	r9,0
800042f6:	fe f8 02 f6 	ld.w	r8,pc[758]
800042fa:	91 09       	st.w	r8[0x0],r9
800042fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004300:	fe f9 02 f4 	ld.w	r9,pc[756]
80004304:	72 08       	ld.w	r8,r9[0x0]
80004306:	20 18       	sub	r8,1
80004308:	93 08       	st.w	r9[0x0],r8
8000430a:	c0 71       	brne	80004318 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
8000430c:	30 09       	mov	r9,0
8000430e:	fe f8 02 de 	ld.w	r8,pc[734]
80004312:	91 09       	st.w	r8[0x0],r9
80004314:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80004318:	fe f8 02 f4 	ld.w	r8,pc[756]
8000431c:	fe f9 02 cc 	ld.w	r9,pc[716]
80004320:	72 0a       	ld.w	r10,r9[0x0]
80004322:	70 09       	ld.w	r9,r8[0x0]
80004324:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004328:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000432c:	70 09       	ld.w	r9,r8[0x0]
8000432e:	2f f9       	sub	r9,-1
80004330:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004332:	e0 49 01 ff 	cp.w	r9,511
80004336:	e0 88 00 16 	brls	80004362 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
8000433a:	30 09       	mov	r9,0
8000433c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000433e:	fe f7 02 aa 	ld.w	r7,pc[682]
80004342:	6e 0c       	ld.w	r12,r7[0x0]
80004344:	f0 1f 00 b4 	mcall	80004614 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004348:	fe f8 02 98 	ld.w	r8,pc[664]
8000434c:	70 0c       	ld.w	r12,r8[0x0]
8000434e:	f0 1f 00 9f 	mcall	800045c8 <phy_rx_func+0xe98>
80004352:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004354:	c0 71       	brne	80004362 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80004356:	30 09       	mov	r9,0
80004358:	fe f8 02 94 	ld.w	r8,pc[660]
8000435c:	91 09       	st.w	r8[0x0],r9
8000435e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004362:	fe f9 02 92 	ld.w	r9,pc[658]
80004366:	72 08       	ld.w	r8,r9[0x0]
80004368:	20 18       	sub	r8,1
8000436a:	93 08       	st.w	r9[0x0],r8
8000436c:	c0 71       	brne	8000437a <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000436e:	30 09       	mov	r9,0
80004370:	fe f8 02 7c 	ld.w	r8,pc[636]
80004374:	91 09       	st.w	r8[0x0],r9
80004376:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000437a:	20 18       	sub	r8,1
8000437c:	fe f9 02 78 	ld.w	r9,pc[632]
80004380:	93 08       	st.w	r9[0x0],r8
80004382:	58 08       	cp.w	r8,0
80004384:	e0 81 01 13 	brne	800045aa <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80004388:	30 09       	mov	r9,0
8000438a:	fe f8 02 62 	ld.w	r8,pc[610]
8000438e:	91 09       	st.w	r8[0x0],r9
80004390:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004394:	fe f8 02 70 	ld.w	r8,pc[624]
80004398:	11 89       	ld.ub	r9,r8[0x0]
8000439a:	30 48       	mov	r8,4
8000439c:	f0 09 18 00 	cp.b	r9,r8
800043a0:	c0 80       	breq	800043b0 <phy_rx_func+0xc80>
800043a2:	fe f8 02 62 	ld.w	r8,pc[610]
800043a6:	11 89       	ld.ub	r9,r8[0x0]
800043a8:	30 38       	mov	r8,3
800043aa:	f0 09 18 00 	cp.b	r9,r8
800043ae:	c1 41       	brne	800043d6 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800043b0:	6e 29       	ld.w	r9,r7[0x8]
800043b2:	fe f8 02 7a 	ld.w	r8,pc[634]
800043b6:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800043b8:	6e 39       	ld.w	r9,r7[0xc]
800043ba:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800043bc:	fe f9 02 38 	ld.w	r9,pc[568]
800043c0:	72 08       	ld.w	r8,r9[0x0]
800043c2:	20 88       	sub	r8,8
800043c4:	93 08       	st.w	r9[0x0],r8
800043c6:	e0 81 00 f2 	brne	800045aa <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800043ca:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800043cc:	fe f9 02 20 	ld.w	r9,pc[544]
800043d0:	93 08       	st.w	r9[0x0],r8
800043d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800043d6:	fe f8 02 2e 	ld.w	r8,pc[558]
800043da:	11 89       	ld.ub	r9,r8[0x0]
800043dc:	31 38       	mov	r8,19
800043de:	f0 09 18 00 	cp.b	r9,r8
800043e2:	e0 81 00 9c 	brne	8000451a <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800043e6:	fe f8 02 62 	ld.w	r8,pc[610]
800043ea:	11 88       	ld.ub	r8,r8[0x0]
800043ec:	30 c9       	mov	r9,12
800043ee:	f2 08 18 00 	cp.b	r8,r9
800043f2:	e0 81 00 7b 	brne	800044e8 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800043f6:	8e 49       	ld.sh	r9,r7[0x8]
800043f8:	fe f8 02 54 	ld.w	r8,pc[596]
800043fc:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80004400:	30 09       	mov	r9,0
80004402:	fe f8 02 46 	ld.w	r8,pc[582]
80004406:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004408:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000440c:	3f 38       	mov	r8,-13
8000440e:	f0 09 18 00 	cp.b	r9,r8
80004412:	c6 61       	brne	800044de <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80004414:	10 99       	mov	r9,r8
80004416:	4f c8       	lddpc	r8,80004604 <phy_rx_func+0xed4>
80004418:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
8000441a:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000441e:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80004422:	4f 58       	lddpc	r8,800045f4 <phy_rx_func+0xec4>
80004424:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80004426:	30 19       	mov	r9,1
80004428:	fe f8 02 0c 	ld.w	r8,pc[524]
8000442c:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
8000442e:	8e 79       	ld.sh	r9,r7[0xe]
80004430:	fe f8 02 14 	ld.w	r8,pc[532]
80004434:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80004436:	4f 68       	lddpc	r8,8000460c <phy_rx_func+0xedc>
80004438:	4e c9       	lddpc	r9,800045e8 <phy_rx_func+0xeb8>
8000443a:	72 0a       	ld.w	r10,r9[0x0]
8000443c:	70 09       	ld.w	r9,r8[0x0]
8000443e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004442:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004446:	70 09       	ld.w	r9,r8[0x0]
80004448:	2f f9       	sub	r9,-1
8000444a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000444c:	e0 49 01 ff 	cp.w	r9,511
80004450:	e0 88 00 13 	brls	80004476 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80004454:	30 09       	mov	r9,0
80004456:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004458:	4e 46       	lddpc	r6,800045e8 <phy_rx_func+0xeb8>
8000445a:	6c 0c       	ld.w	r12,r6[0x0]
8000445c:	f0 1f 00 6e 	mcall	80004614 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80004460:	4e 08       	lddpc	r8,800045e0 <phy_rx_func+0xeb0>
80004462:	70 0c       	ld.w	r12,r8[0x0]
80004464:	f0 1f 00 59 	mcall	800045c8 <phy_rx_func+0xe98>
80004468:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000446a:	c0 61       	brne	80004476 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
8000446c:	30 09       	mov	r9,0
8000446e:	4e 08       	lddpc	r8,800045ec <phy_rx_func+0xebc>
80004470:	91 09       	st.w	r8[0x0],r9
80004472:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004476:	4e 09       	lddpc	r9,800045f4 <phy_rx_func+0xec4>
80004478:	72 08       	ld.w	r8,r9[0x0]
8000447a:	20 18       	sub	r8,1
8000447c:	93 08       	st.w	r9[0x0],r8
8000447e:	c0 61       	brne	8000448a <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80004480:	30 09       	mov	r9,0
80004482:	4d b8       	lddpc	r8,800045ec <phy_rx_func+0xebc>
80004484:	91 09       	st.w	r8[0x0],r9
80004486:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
8000448a:	4e 18       	lddpc	r8,8000460c <phy_rx_func+0xedc>
8000448c:	4d 79       	lddpc	r9,800045e8 <phy_rx_func+0xeb8>
8000448e:	72 0a       	ld.w	r10,r9[0x0]
80004490:	70 09       	ld.w	r9,r8[0x0]
80004492:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004496:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000449a:	70 09       	ld.w	r9,r8[0x0]
8000449c:	2f f9       	sub	r9,-1
8000449e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800044a0:	e0 49 01 ff 	cp.w	r9,511
800044a4:	e0 88 00 13 	brls	800044ca <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800044a8:	30 09       	mov	r9,0
800044aa:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800044ac:	4c f7       	lddpc	r7,800045e8 <phy_rx_func+0xeb8>
800044ae:	6e 0c       	ld.w	r12,r7[0x0]
800044b0:	f0 1f 00 59 	mcall	80004614 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800044b4:	4c b8       	lddpc	r8,800045e0 <phy_rx_func+0xeb0>
800044b6:	70 0c       	ld.w	r12,r8[0x0]
800044b8:	f0 1f 00 44 	mcall	800045c8 <phy_rx_func+0xe98>
800044bc:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800044be:	c0 61       	brne	800044ca <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800044c0:	30 09       	mov	r9,0
800044c2:	4c b8       	lddpc	r8,800045ec <phy_rx_func+0xebc>
800044c4:	91 09       	st.w	r8[0x0],r9
800044c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800044ca:	4c b9       	lddpc	r9,800045f4 <phy_rx_func+0xec4>
800044cc:	72 08       	ld.w	r8,r9[0x0]
800044ce:	20 18       	sub	r8,1
800044d0:	93 08       	st.w	r9[0x0],r8
800044d2:	c6 c1       	brne	800045aa <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800044d4:	30 09       	mov	r9,0
800044d6:	4c 68       	lddpc	r8,800045ec <phy_rx_func+0xebc>
800044d8:	91 09       	st.w	r8[0x0],r9
800044da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800044de:	30 09       	mov	r9,0
800044e0:	4c 38       	lddpc	r8,800045ec <phy_rx_func+0xebc>
800044e2:	91 09       	st.w	r8[0x0],r9
800044e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800044e8:	8e 4a       	ld.sh	r10,r7[0x8]
800044ea:	4d 99       	lddpc	r9,8000464c <phy_rx_func+0xf1c>
800044ec:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800044f0:	4d 6a       	lddpc	r10,80004648 <phy_rx_func+0xf18>
800044f2:	15 88       	ld.ub	r8,r10[0x0]
800044f4:	f0 cb ff ff 	sub	r11,r8,-1
800044f8:	8e 5c       	ld.sh	r12,r7[0xa]
800044fa:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800044fe:	f0 cb ff fe 	sub	r11,r8,-2
80004502:	8e 6c       	ld.sh	r12,r7[0xc]
80004504:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004508:	f0 cb ff fd 	sub	r11,r8,-3
8000450c:	8e 7c       	ld.sh	r12,r7[0xe]
8000450e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80004512:	2f c8       	sub	r8,-4
80004514:	b4 88       	st.b	r10[0x0],r8
80004516:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
8000451a:	30 09       	mov	r9,0
8000451c:	4b 48       	lddpc	r8,800045ec <phy_rx_func+0xebc>
8000451e:	91 09       	st.w	r8[0x0],r9
80004520:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80004524:	4c 08       	lddpc	r8,80004624 <phy_rx_func+0xef4>
80004526:	70 09       	ld.w	r9,r8[0x0]
80004528:	8e 4b       	ld.sh	r11,r7[0x8]
8000452a:	4c 0a       	lddpc	r10,80004628 <phy_rx_func+0xef8>
8000452c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80004530:	2f f9       	sub	r9,-1
80004532:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80004534:	4b 58       	lddpc	r8,80004608 <phy_rx_func+0xed8>
80004536:	70 09       	ld.w	r9,r8[0x0]
80004538:	20 29       	sub	r9,2
8000453a:	91 09       	st.w	r8[0x0],r9
8000453c:	70 08       	ld.w	r8,r8[0x0]
8000453e:	58 08       	cp.w	r8,0
80004540:	c2 f1       	brne	8000459e <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80004542:	30 09       	mov	r9,0
80004544:	4b 88       	lddpc	r8,80004624 <phy_rx_func+0xef4>
80004546:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004548:	8e 59       	ld.sh	r9,r7[0xa]
8000454a:	fe 78 82 12 	mov	r8,-32238
8000454e:	f0 09 19 00 	cp.h	r9,r8
80004552:	c2 11       	brne	80004594 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80004554:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80004558:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000455c:	4a f8       	lddpc	r8,80004618 <phy_rx_func+0xee8>
8000455e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80004560:	8e 59       	ld.sh	r9,r7[0xa]
80004562:	4a f8       	lddpc	r8,8000461c <phy_rx_func+0xeec>
80004564:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80004566:	8e 69       	ld.sh	r9,r7[0xc]
80004568:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
8000456a:	f0 1f 00 2e 	mcall	80004620 <phy_rx_func+0xef0>
8000456e:	4a 18       	lddpc	r8,800045f0 <phy_rx_func+0xec0>
80004570:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004572:	ef 39 00 0f 	ld.ub	r9,r7[15]
80004576:	31 38       	mov	r8,19
80004578:	f0 09 18 00 	cp.b	r9,r8
8000457c:	c0 71       	brne	8000458a <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
8000457e:	10 99       	mov	r9,r8
80004580:	4a 18       	lddpc	r8,80004604 <phy_rx_func+0xed4>
80004582:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80004584:	30 09       	mov	r9,0
80004586:	49 c8       	lddpc	r8,800045f4 <phy_rx_func+0xec4>
80004588:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
8000458a:	30 49       	mov	r9,4
8000458c:	49 88       	lddpc	r8,800045ec <phy_rx_func+0xebc>
8000458e:	91 09       	st.w	r8[0x0],r9
80004590:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80004594:	30 09       	mov	r9,0
80004596:	49 68       	lddpc	r8,800045ec <phy_rx_func+0xebc>
80004598:	91 09       	st.w	r8[0x0],r9
8000459a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
8000459e:	4a dc       	lddpc	r12,80004650 <phy_rx_func+0xf20>
800045a0:	f0 1f 00 18 	mcall	80004600 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
800045a4:	30 09       	mov	r9,0
800045a6:	49 28       	lddpc	r8,800045ec <phy_rx_func+0xebc>
800045a8:	91 09       	st.w	r8[0x0],r9
800045aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800045ae:	00 00       	add	r0,r0
800045b0:	00 00       	add	r0,r0
800045b2:	0a d4       	st.w	--r5,r4
800045b4:	00 00       	add	r0,r0
800045b6:	0a ec       	st.h	--r5,r12
800045b8:	00 00       	add	r0,r0
800045ba:	0a cc       	st.b	r5++,r12
800045bc:	00 00       	add	r0,r0
800045be:	0a ae       	st.w	r5++,lr
800045c0:	00 00       	add	r0,r0
800045c2:	0a 9c       	mov	r12,r5
800045c4:	00 00       	add	r0,r0
800045c6:	0a c4       	st.b	r5++,r4
800045c8:	80 00       	ld.sh	r0,r0[0x0]
800045ca:	35 b0       	mov	r0,91
800045cc:	00 00       	add	r0,r0
800045ce:	0a bc       	st.h	r5++,r12
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	34 c8       	mov	r8,76
800045d4:	00 00       	add	r0,r0
800045d6:	0a d0       	st.w	--r5,r0
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	34 fc       	mov	r12,79
800045dc:	00 00       	add	r0,r0
800045de:	0a ad       	st.w	r5++,sp
800045e0:	00 00       	add	r0,r0
800045e2:	0a c8       	st.b	r5++,r8
800045e4:	00 00       	add	r0,r0
800045e6:	0a d8       	st.w	--r5,r8
800045e8:	00 00       	add	r0,r0
800045ea:	0a b0       	st.h	r5++,r0
800045ec:	00 00       	add	r0,r0
800045ee:	0a f8       	st.b	--r5,r8
800045f0:	00 00       	add	r0,r0
800045f2:	0a e0       	st.h	--r5,r0
800045f4:	00 00       	add	r0,r0
800045f6:	0a 98       	mov	r8,r5
800045f8:	00 00       	add	r0,r0
800045fa:	0a 5d       	eor	sp,r5
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	e9 68 80 00 	st.b	r4[-32768],r8
80004602:	80 e0       	ld.uh	r0,r0[0xc]
80004604:	00 00       	add	r0,r0
80004606:	0a ac       	st.w	r5++,r12
80004608:	00 00       	add	r0,r0
8000460a:	0b 04       	ld.w	r4,r5++
8000460c:	00 00       	add	r0,r0
8000460e:	0a e4       	st.h	--r5,r4
80004610:	80 00       	ld.sh	r0,r0[0x0]
80004612:	89 46       	st.w	r4[0x10],r6
80004614:	80 00       	ld.sh	r0,r0[0x0]
80004616:	34 e4       	mov	r4,78
80004618:	00 00       	add	r0,r0
8000461a:	0a 74       	tst	r4,r5
8000461c:	00 00       	add	r0,r0
8000461e:	1f 34       	ld.ub	r4,pc++
80004620:	80 00       	ld.sh	r0,r0[0x0]
80004622:	34 98       	mov	r8,73
80004624:	00 00       	add	r0,r0
80004626:	0a a0       	st.w	r5++,r0
80004628:	00 00       	add	r0,r0
8000462a:	1e 38       	cp.w	r8,pc
8000462c:	00 00       	add	r0,r0
8000462e:	0a a4       	st.w	r5++,r4
80004630:	00 00       	add	r0,r0
80004632:	0a 5f       	eor	pc,r5
80004634:	00 00       	add	r0,r0
80004636:	0a 7e       	tst	lr,r5
80004638:	00 00       	add	r0,r0
8000463a:	0a fc       	st.b	--r5,r12
8000463c:	00 00       	add	r0,r0
8000463e:	0a b8       	st.h	r5++,r8
80004640:	00 00       	add	r0,r0
80004642:	0a 89       	andn	r9,r5
80004644:	00 00       	add	r0,r0
80004646:	1e 30       	cp.w	r0,pc
80004648:	00 00       	add	r0,r0
8000464a:	0a f0       	st.b	--r5,r0
8000464c:	00 00       	add	r0,r0
8000464e:	1f 38       	ld.ub	r8,pc++
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	e9 80       	*unknown*

80004654 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004654:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80004656:	49 a8       	lddpc	r8,800046bc <pdca_int_handler+0x68>
80004658:	70 09       	ld.w	r9,r8[0x0]
8000465a:	2f f9       	sub	r9,-1
8000465c:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000465e:	49 98       	lddpc	r8,800046c0 <pdca_int_handler+0x6c>
80004660:	11 89       	ld.ub	r9,r8[0x0]
80004662:	ec 19 00 01 	eorl	r9,0x1
80004666:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004668:	11 89       	ld.ub	r9,r8[0x0]
8000466a:	a5 69       	lsl	r9,0x4
8000466c:	2f c9       	sub	r9,-4
8000466e:	49 6a       	lddpc	r10,800046c4 <pdca_int_handler+0x70>
80004670:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004672:	fe 7a 00 40 	mov	r10,-65472
80004676:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004678:	30 39       	mov	r9,3
8000467a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
8000467c:	11 8a       	ld.ub	r10,r8[0x0]
8000467e:	a5 6a       	lsl	r10,0x4
80004680:	2f ca       	sub	r10,-4
80004682:	49 28       	lddpc	r8,800046c8 <pdca_int_handler+0x74>
80004684:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004686:	fe 78 00 00 	mov	r8,-65536
8000468a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000468c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000468e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004690:	48 f8       	lddpc	r8,800046cc <pdca_int_handler+0x78>
80004692:	70 08       	ld.w	r8,r8[0x0]
80004694:	58 08       	cp.w	r8,0
80004696:	c0 70       	breq	800046a4 <pdca_int_handler+0x50>
80004698:	48 a9       	lddpc	r9,800046c0 <pdca_int_handler+0x6c>
8000469a:	13 89       	ld.ub	r9,r9[0x0]
8000469c:	a5 69       	lsl	r9,0x4
8000469e:	48 bc       	lddpc	r12,800046c8 <pdca_int_handler+0x74>
800046a0:	12 0c       	add	r12,r9
800046a2:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800046a4:	48 b8       	lddpc	r8,800046d0 <pdca_int_handler+0x7c>
800046a6:	70 08       	ld.w	r8,r8[0x0]
800046a8:	58 08       	cp.w	r8,0
800046aa:	c0 70       	breq	800046b8 <pdca_int_handler+0x64>
800046ac:	48 59       	lddpc	r9,800046c0 <pdca_int_handler+0x6c>
800046ae:	13 89       	ld.ub	r9,r9[0x0]
800046b0:	a5 69       	lsl	r9,0x4
800046b2:	48 5c       	lddpc	r12,800046c4 <pdca_int_handler+0x70>
800046b4:	12 0c       	add	r12,r9
800046b6:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800046b8:	d4 02       	popm	lr
800046ba:	d6 03       	rete
800046bc:	00 00       	add	r0,r0
800046be:	0b 0c       	ld.w	r12,r5++
800046c0:	00 00       	add	r0,r0
800046c2:	97 58       	st.w	r11[0x14],r8
800046c4:	00 00       	add	r0,r0
800046c6:	97 80       	st.w	r11[0x20],r0
800046c8:	00 00       	add	r0,r0
800046ca:	97 60       	st.w	r11[0x18],r0
800046cc:	00 00       	add	r0,r0
800046ce:	0b 08       	ld.w	r8,r5++
800046d0:	00 00       	add	r0,r0
800046d2:	0b 10       	ld.sh	r0,r5++

800046d4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800046d4:	fe 78 10 00 	mov	r8,-61440
800046d8:	e0 69 0d c0 	mov	r9,3520
800046dc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800046e0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800046e4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800046e8:	fe 78 34 00 	mov	r8,-52224
800046ec:	e0 69 80 00 	mov	r9,32768
800046f0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
800046f2:	30 09       	mov	r9,0
800046f4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
800046f6:	e0 69 04 21 	mov	r9,1057
800046fa:	ea 19 3f 20 	orh	r9,0x3f20
800046fe:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80004700:	e0 69 02 9f 	mov	r9,671
80004704:	ea 19 01 00 	orh	r9,0x100
80004708:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
8000470a:	e0 6a 04 02 	mov	r10,1026
8000470e:	ea 1a 3f 20 	orh	r10,0x3f20
80004712:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80004714:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004716:	5e fc       	retal	r12

80004718 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004718:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000471a:	30 19       	mov	r9,1
8000471c:	49 78       	lddpc	r8,80004778 <local_start_PDC+0x60>
8000471e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004720:	fe 78 00 00 	mov	r8,-65536
80004724:	30 7b       	mov	r11,7
80004726:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004728:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000472a:	49 59       	lddpc	r9,8000477c <local_start_PDC+0x64>
8000472c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004730:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004732:	30 3a       	mov	r10,3
80004734:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004736:	30 1c       	mov	r12,1
80004738:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000473a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000473c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000473e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004740:	30 2c       	mov	r12,2
80004742:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004744:	48 f9       	lddpc	r9,80004780 <local_start_PDC+0x68>
80004746:	e0 68 5a 5a 	mov	r8,23130
8000474a:	ea 18 ab cd 	orh	r8,0xabcd
8000474e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004750:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004752:	30 0e       	mov	lr,0
80004754:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004756:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004758:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000475a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000475c:	fe 78 00 40 	mov	r8,-65472
80004760:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004762:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004764:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004768:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000476a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8000476c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000476e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004770:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004772:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004774:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004776:	d8 02       	popm	pc
80004778:	00 00       	add	r0,r0
8000477a:	97 58       	st.w	r11[0x14],r8
8000477c:	00 00       	add	r0,r0
8000477e:	97 60       	st.w	r11[0x18],r0
80004780:	00 00       	add	r0,r0
80004782:	97 80       	st.w	r11[0x20],r0

80004784 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004784:	48 38       	lddpc	r8,80004790 <register_rx_tx_func+0xc>
80004786:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004788:	48 38       	lddpc	r8,80004794 <register_rx_tx_func+0x10>
8000478a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
8000478c:	5e fc       	retal	r12
8000478e:	00 00       	add	r0,r0
80004790:	00 00       	add	r0,r0
80004792:	0b 08       	ld.w	r8,r5++
80004794:	00 00       	add	r0,r0
80004796:	0b 10       	ld.sh	r0,r5++

80004798 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004798:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000479a:	fe 78 10 00 	mov	r8,-61440
8000479e:	30 29       	mov	r9,2
800047a0:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800047a4:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
800047a8:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
800047aa:	30 3a       	mov	r10,3
800047ac:	36 0b       	mov	r11,96
800047ae:	49 4c       	lddpc	r12,800047fc <ssc_init+0x64>
800047b0:	f0 1f 00 14 	mcall	80004800 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
800047b4:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800047b6:	fe 79 10 00 	mov	r9,-61440
800047ba:	f2 f8 01 60 	ld.w	r8,r9[352]
800047be:	e2 18 00 02 	andl	r8,0x2,COH
800047c2:	cf c0       	breq	800047ba <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800047c4:	fe 79 10 00 	mov	r9,-61440
800047c8:	f2 f8 01 60 	ld.w	r8,r9[352]
800047cc:	e2 18 00 02 	andl	r8,0x2,COH
800047d0:	cf c1       	brne	800047c8 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
800047d2:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
800047d4:	f0 1f 00 0c 	mcall	80004804 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
800047d8:	f0 1f 00 0c 	mcall	80004808 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800047dc:	fe 79 00 00 	mov	r9,-65536
800047e0:	30 18       	mov	r8,1
800047e2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800047e4:	fe 7a 00 40 	mov	r10,-65472
800047e8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800047ea:	e0 6b 01 01 	mov	r11,257
800047ee:	fe 7a 34 00 	mov	r10,-52224
800047f2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
800047f4:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
800047f6:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
800047f8:	d8 02       	popm	pc
800047fa:	00 00       	add	r0,r0
800047fc:	80 00       	ld.sh	r0,r0[0x0]
800047fe:	46 54       	lddsp	r4,sp[0x194]
80004800:	80 00       	ld.sh	r0,r0[0x0]
80004802:	63 bc       	ld.w	r12,r1[0x6c]
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	46 d4       	lddsp	r4,sp[0x1b4]
80004808:	80 00       	ld.sh	r0,r0[0x0]
8000480a:	47 18       	lddsp	r8,sp[0x1c4]

8000480c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
8000480c:	48 28       	lddpc	r8,80004814 <xcmp_register_app_list+0x8>
8000480e:	91 0c       	st.w	r8[0x0],r12
}
80004810:	5e fc       	retal	r12
80004812:	00 00       	add	r0,r0
80004814:	00 00       	add	r0,r0
80004816:	97 a0       	st.w	r11[0x28],r0

80004818 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004818:	eb cd 40 80 	pushm	r7,lr
8000481c:	fa cd 01 00 	sub	sp,sp,256
80004820:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004822:	16 98       	mov	r8,r11
80004824:	2f 08       	sub	r8,-16
80004826:	af a8       	sbr	r8,0xe
80004828:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000482a:	3f f8       	mov	r8,-1
8000482c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000482e:	30 b9       	mov	r9,11
80004830:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004832:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004834:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004836:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004838:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000483a:	f6 ca ff fe 	sub	r10,r11,-2
8000483e:	18 9b       	mov	r11,r12
80004840:	fa cc ff f0 	sub	r12,sp,-16
80004844:	f0 1f 00 05 	mcall	80004858 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004848:	2f e7       	sub	r7,-2
8000484a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
8000484c:	1a 9c       	mov	r12,sp
8000484e:	f0 1f 00 04 	mcall	8000485c <xcmp_tx+0x44>
}
80004852:	2c 0d       	sub	sp,-256
80004854:	e3 cd 80 80 	ldm	sp++,r7,pc
80004858:	80 00       	ld.sh	r0,r0[0x0]
8000485a:	87 fe       	st.w	r3[0x3c],lr
8000485c:	80 00       	ld.sh	r0,r0[0x0]
8000485e:	4e 28       	lddpc	r8,800049e4 <xcmp_IdleTestTone+0x48>

80004860 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80004860:	d4 21       	pushm	r4-r7,lr
80004862:	fa cd 00 d0 	sub	sp,sp,208
80004866:	18 94       	mov	r4,r12
80004868:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
8000486a:	e0 68 01 00 	mov	r8,256
8000486e:	f0 0b 19 00 	cp.h	r11,r8
80004872:	e0 8b 00 38 	brhi	800048e2 <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80004876:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
8000487a:	e0 68 04 1d 	mov	r8,1053
8000487e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004880:	30 18       	mov	r8,1
80004882:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004884:	32 08       	mov	r8,32
80004886:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80004888:	30 28       	mov	r8,2
8000488a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
8000488c:	30 48       	mov	r8,4
8000488e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004890:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80004894:	ea 1a 0c 00 	orh	r10,0xc00
80004898:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
8000489a:	30 4a       	mov	r10,4
8000489c:	1a 9b       	mov	r11,sp
8000489e:	fa cc ff f4 	sub	r12,sp,-12
800048a2:	f0 1f 00 12 	mcall	800048e8 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
800048a6:	30 f8       	mov	r8,15
800048a8:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800048ac:	3a 78       	mov	r8,-89
800048ae:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800048b2:	30 08       	mov	r8,0
800048b4:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800048b8:	0e 9a       	mov	r10,r7
800048ba:	5c 7a       	castu.h	r10
800048bc:	f4 08 16 08 	lsr	r8,r10,0x8
800048c0:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800048c4:	0e 96       	mov	r6,r7
800048c6:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800048ca:	08 9b       	mov	r11,r4
800048cc:	fa cc ff eb 	sub	r12,sp,-21
800048d0:	f0 1f 00 06 	mcall	800048e8 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
800048d4:	ee cb ff f3 	sub	r11,r7,-13
800048d8:	5c 5b       	castu.b	r11
800048da:	fa cc ff fa 	sub	r12,sp,-6
800048de:	f0 1f 00 04 	mcall	800048ec <xcmp_data_session_req+0x8c>
}
800048e2:	2c cd       	sub	sp,-208
800048e4:	d8 22       	popm	r4-r7,pc
800048e6:	00 00       	add	r0,r0
800048e8:	80 00       	ld.sh	r0,r0[0x0]
800048ea:	87 fe       	st.w	r3[0x3c],lr
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	48 18       	lddpc	r8,800048f0 <xcmp_DeviceInitializationStatus_request>

800048f0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800048f0:	d4 01       	pushm	lr
800048f2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800048f6:	fe 78 b4 00 	mov	r8,-19456
800048fa:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800048fc:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004900:	30 89       	mov	r9,8
80004902:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004904:	30 19       	mov	r9,1
80004906:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004908:	30 09       	mov	r9,0
8000490a:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
8000490c:	30 5a       	mov	r10,5
8000490e:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004910:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004912:	30 7a       	mov	r10,7
80004914:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004916:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004918:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000491a:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000491e:	30 9b       	mov	r11,9
80004920:	fa cc ff fe 	sub	r12,sp,-2
80004924:	f0 1f 00 02 	mcall	8000492c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004928:	2c dd       	sub	sp,-204
8000492a:	d8 02       	popm	pc
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	48 18       	lddpc	r8,80004930 <xcmp_opcode_not_supported>

80004930 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004930:	d4 01       	pushm	lr
80004932:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004936:	fe 78 80 00 	mov	r8,-32768
8000493a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000493c:	30 38       	mov	r8,3
8000493e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004940:	30 1b       	mov	r11,1
80004942:	fa cc ff fe 	sub	r12,sp,-2
80004946:	f0 1f 00 03 	mcall	80004950 <xcmp_opcode_not_supported+0x20>
}
8000494a:	2c dd       	sub	sp,-204
8000494c:	d8 02       	popm	pc
8000494e:	00 00       	add	r0,r0
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	48 18       	lddpc	r8,80004954 <xcmp_exec_func>

80004954 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004954:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004956:	96 88       	ld.uh	r8,r11[0x0]
80004958:	e2 18 f0 00 	andl	r8,0xf000,COH
8000495c:	e0 48 80 00 	cp.w	r8,32768
80004960:	c0 f0       	breq	8000497e <xcmp_exec_func+0x2a>
80004962:	e0 48 b0 00 	cp.w	r8,45056
80004966:	c1 20       	breq	8000498a <xcmp_exec_func+0x36>
80004968:	58 08       	cp.w	r8,0
8000496a:	c1 51       	brne	80004994 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000496c:	78 08       	ld.w	r8,r12[0x0]
8000496e:	58 08       	cp.w	r8,0
80004970:	c0 40       	breq	80004978 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004972:	16 9c       	mov	r12,r11
80004974:	5d 18       	icall	r8
80004976:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004978:	f0 1f 00 08 	mcall	80004998 <xcmp_exec_func+0x44>
8000497c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000497e:	78 18       	ld.w	r8,r12[0x4]
80004980:	58 08       	cp.w	r8,0
80004982:	c0 90       	breq	80004994 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004984:	16 9c       	mov	r12,r11
80004986:	5d 18       	icall	r8
80004988:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000498a:	78 28       	ld.w	r8,r12[0x8]
8000498c:	58 08       	cp.w	r8,0
8000498e:	c0 30       	breq	80004994 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004990:	16 9c       	mov	r12,r11
80004992:	5d 18       	icall	r8
80004994:	d8 02       	popm	pc
80004996:	00 00       	add	r0,r0
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	49 30       	lddpc	r0,800049e4 <xcmp_IdleTestTone+0x48>

8000499c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000499c:	d4 01       	pushm	lr
8000499e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800049a2:	e0 68 04 09 	mov	r8,1033
800049a6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800049a8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
800049ac:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
800049ae:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
800049b2:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
800049b4:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800049b6:	30 09       	mov	r9,0
800049b8:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800049ba:	fb 69 00 08 	st.b	sp[8],r9
800049be:	fa c8 ff f7 	sub	r8,sp,-9
800049c2:	b0 89       	st.b	r8[0x0],r9
800049c4:	fa c8 ff f6 	sub	r8,sp,-10
800049c8:	b0 89       	st.b	r8[0x0],r9
800049ca:	fa c8 ff f5 	sub	r8,sp,-11
800049ce:	b0 89       	st.b	r8[0x0],r9
800049d0:	fa c8 ff f4 	sub	r8,sp,-12
800049d4:	b0 89       	st.b	r8[0x0],r9
800049d6:	fa c8 ff f3 	sub	r8,sp,-13
800049da:	b0 89       	st.b	r8[0x0],r9
800049dc:	fa c8 ff f2 	sub	r8,sp,-14
800049e0:	b0 89       	st.b	r8[0x0],r9
800049e2:	fa c8 ff f1 	sub	r8,sp,-15
800049e6:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800049e8:	30 cb       	mov	r11,12
800049ea:	fa cc ff fe 	sub	r12,sp,-2
800049ee:	f0 1f 00 03 	mcall	800049f8 <xcmp_IdleTestTone+0x5c>
}
800049f2:	2c dd       	sub	sp,-204
800049f4:	d8 02       	popm	pc
800049f6:	00 00       	add	r0,r0
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	48 18       	lddpc	r8,800049fc <xcmp_init>

800049fc <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800049fc:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800049fe:	48 dc       	lddpc	r12,80004a30 <xcmp_init+0x34>
80004a00:	f0 1f 00 0d 	mcall	80004a34 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004a04:	30 4b       	mov	r11,4
80004a06:	31 4c       	mov	r12,20
80004a08:	f0 1f 00 0c 	mcall	80004a38 <xcmp_init+0x3c>
80004a0c:	48 c8       	lddpc	r8,80004a3c <xcmp_init+0x40>
80004a0e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004a10:	30 09       	mov	r9,0
80004a12:	1a d9       	st.w	--sp,r9
80004a14:	1a d9       	st.w	--sp,r9
80004a16:	1a d9       	st.w	--sp,r9
80004a18:	30 38       	mov	r8,3
80004a1a:	e0 6a 04 00 	mov	r10,1024
80004a1e:	48 9b       	lddpc	r11,80004a40 <xcmp_init+0x44>
80004a20:	48 9c       	lddpc	r12,80004a44 <xcmp_init+0x48>
80004a22:	f0 1f 00 0a 	mcall	80004a48 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004a26:	f0 1f 00 0a 	mcall	80004a4c <xcmp_init+0x50>
80004a2a:	2f dd       	sub	sp,-12
	
}
80004a2c:	d8 02       	popm	pc
80004a2e:	00 00       	add	r0,r0
80004a30:	80 00       	ld.sh	r0,r0[0x0]
80004a32:	4b 4c       	lddpc	r12,80004b00 <xcmp_rx_process+0xb0>
80004a34:	80 00       	ld.sh	r0,r0[0x0]
80004a36:	4b 98       	lddpc	r8,80004b18 <xcmp_rx_process+0xc8>
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	74 74       	ld.w	r4,r10[0x1c]
80004a3c:	00 00       	add	r0,r0
80004a3e:	0b 2c       	ld.uh	r12,r5++
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	e9 ac 80 00 	ldc.w	cp4,cr0,r12[0x0]
80004a46:	4a 50       	lddpc	r0,80004ad8 <xcmp_rx_process+0x88>
80004a48:	80 00       	ld.sh	r0,r0[0x0]
80004a4a:	7b 90       	ld.w	r0,sp[0x64]
80004a4c:	80 00       	ld.sh	r0,r0[0x0]
80004a4e:	4b d0       	lddpc	r0,80004b40 <xcmp_rx_process+0xf0>

80004a50 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004a50:	d4 31       	pushm	r0-r7,lr
80004a52:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004a54:	4b 16       	lddpc	r6,80004b18 <xcmp_rx_process+0xc8>
80004a56:	30 05       	mov	r5,0
80004a58:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004a5a:	4b 13       	lddpc	r3,80004b1c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004a5c:	4b 12       	lddpc	r2,80004b20 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004a5e:	4b 21       	lddpc	r1,80004b24 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004a60:	4b 20       	lddpc	r0,80004b28 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004a62:	6c 0c       	ld.w	r12,r6[0x0]
80004a64:	0a 99       	mov	r9,r5
80004a66:	08 9a       	mov	r10,r4
80004a68:	1a 9b       	mov	r11,sp
80004a6a:	f0 1f 00 31 	mcall	80004b2c <xcmp_rx_process+0xdc>
80004a6e:	58 1c       	cp.w	r12,1
80004a70:	cf 91       	brne	80004a62 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004a72:	40 0b       	lddsp	r11,sp[0x0]
80004a74:	58 0b       	cp.w	r11,0
80004a76:	cf 60       	breq	80004a62 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004a78:	96 0a       	ld.sh	r10,r11[0x0]
80004a7a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004a7e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004a82:	59 c8       	cp.w	r8,28
80004a84:	c1 e0       	breq	80004ac0 <xcmp_rx_process+0x70>
80004a86:	e0 89 00 07 	brgt	80004a94 <xcmp_rx_process+0x44>
80004a8a:	58 e8       	cp.w	r8,14
80004a8c:	c0 e0       	breq	80004aa8 <xcmp_rx_process+0x58>
80004a8e:	58 f8       	cp.w	r8,15
80004a90:	c2 41       	brne	80004ad8 <xcmp_rx_process+0x88>
80004a92:	c0 f8       	rjmp	80004ab0 <xcmp_rx_process+0x60>
80004a94:	e0 48 01 09 	cp.w	r8,265
80004a98:	c1 80       	breq	80004ac8 <xcmp_rx_process+0x78>
80004a9a:	e0 48 01 0a 	cp.w	r8,266
80004a9e:	c1 90       	breq	80004ad0 <xcmp_rx_process+0x80>
80004aa0:	e0 48 00 2c 	cp.w	r8,44
80004aa4:	c1 a1       	brne	80004ad8 <xcmp_rx_process+0x88>
80004aa6:	c0 98       	rjmp	80004ab8 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004aa8:	4a 2c       	lddpc	r12,80004b30 <xcmp_rx_process+0xe0>
80004aaa:	f0 1f 00 23 	mcall	80004b34 <xcmp_rx_process+0xe4>
					break;
80004aae:	c2 f8       	rjmp	80004b0c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004ab0:	4a 2c       	lddpc	r12,80004b38 <xcmp_rx_process+0xe8>
80004ab2:	f0 1f 00 21 	mcall	80004b34 <xcmp_rx_process+0xe4>
					break;
80004ab6:	c2 b8       	rjmp	80004b0c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004ab8:	4a 1c       	lddpc	r12,80004b3c <xcmp_rx_process+0xec>
80004aba:	f0 1f 00 1f 	mcall	80004b34 <xcmp_rx_process+0xe4>
					break;
80004abe:	c2 78       	rjmp	80004b0c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004ac0:	04 9c       	mov	r12,r2
80004ac2:	f0 1f 00 1d 	mcall	80004b34 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004ac6:	c2 38       	rjmp	80004b0c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004ac8:	02 9c       	mov	r12,r1
80004aca:	f0 1f 00 1b 	mcall	80004b34 <xcmp_rx_process+0xe4>
					break;
80004ace:	c1 f8       	rjmp	80004b0c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004ad0:	00 9c       	mov	r12,r0
80004ad2:	f0 1f 00 19 	mcall	80004b34 <xcmp_rx_process+0xe4>
					break;
80004ad6:	c1 b8       	rjmp	80004b0c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004ad8:	12 98       	mov	r8,r9
80004ada:	e2 18 04 00 	andl	r8,0x400,COH
80004ade:	c0 70       	breq	80004aec <xcmp_rx_process+0x9c>
80004ae0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004ae4:	e0 48 00 68 	cp.w	r8,104
80004ae8:	e0 8a 00 08 	brle	80004af8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004aec:	e2 19 f0 00 	andl	r9,0xf000,COH
80004af0:	c0 e1       	brne	80004b0c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004af2:	f0 1f 00 14 	mcall	80004b40 <xcmp_rx_process+0xf0>
80004af6:	c0 b8       	rjmp	80004b0c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004af8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004afc:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004b00:	49 19       	lddpc	r9,80004b44 <xcmp_rx_process+0xf4>
80004b02:	72 08       	ld.w	r8,r9[0x0]
80004b04:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004b08:	f0 1f 00 0b 	mcall	80004b34 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004b0c:	66 0c       	ld.w	r12,r3[0x0]
80004b0e:	40 0b       	lddsp	r11,sp[0x0]
80004b10:	f0 1f 00 0e 	mcall	80004b48 <xcmp_rx_process+0xf8>
80004b14:	ca 7b       	rjmp	80004a62 <xcmp_rx_process+0x12>
80004b16:	00 00       	add	r0,r0
80004b18:	00 00       	add	r0,r0
80004b1a:	0b 2c       	ld.uh	r12,r5++
80004b1c:	00 00       	add	r0,r0
80004b1e:	0a c4       	st.b	r5++,r4
80004b20:	00 00       	add	r0,r0
80004b22:	0b 3c       	ld.ub	r12,r5++
80004b24:	00 00       	add	r0,r0
80004b26:	0b 30       	ld.ub	r0,r5++
80004b28:	00 00       	add	r0,r0
80004b2a:	0b 20       	ld.uh	r0,r5++
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	71 10       	ld.w	r0,r8[0x44]
80004b30:	00 00       	add	r0,r0
80004b32:	0b 54       	ld.sh	r4,--r5
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	49 54       	lddpc	r4,80004b88 <xcmp_rx+0x3c>
80004b38:	00 00       	add	r0,r0
80004b3a:	0b 14       	ld.sh	r4,r5++
80004b3c:	00 00       	add	r0,r0
80004b3e:	0b 48       	ld.w	r8,--r5
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	49 30       	lddpc	r0,80004b8c <xcmp_rx+0x40>
80004b44:	00 00       	add	r0,r0
80004b46:	97 a0       	st.w	r11[0x28],r0
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	35 34       	mov	r4,83

80004b4c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004b4c:	eb cd 40 90 	pushm	r4,r7,lr
80004b50:	20 1d       	sub	sp,4
80004b52:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004b56:	48 c8       	lddpc	r8,80004b84 <xcmp_rx+0x38>
80004b58:	70 0c       	ld.w	r12,r8[0x0]
80004b5a:	f0 1f 00 0c 	mcall	80004b88 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004b5e:	c1 00       	breq	80004b7e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004b60:	fa c7 ff fc 	sub	r7,sp,-4
80004b64:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004b66:	e0 6a 00 ca 	mov	r10,202
80004b6a:	08 9b       	mov	r11,r4
80004b6c:	f0 1f 00 08 	mcall	80004b8c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004b70:	48 88       	lddpc	r8,80004b90 <xcmp_rx+0x44>
80004b72:	70 0c       	ld.w	r12,r8[0x0]
80004b74:	30 09       	mov	r9,0
80004b76:	12 9a       	mov	r10,r9
80004b78:	1a 9b       	mov	r11,sp
80004b7a:	f0 1f 00 07 	mcall	80004b94 <xcmp_rx+0x48>
	}	
}
80004b7e:	2f fd       	sub	sp,-4
80004b80:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004b84:	00 00       	add	r0,r0
80004b86:	0a c4       	st.b	r5++,r4
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	36 e0       	mov	r0,110
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	87 fe       	st.w	r3[0x3c],lr
80004b90:	00 00       	add	r0,r0
80004b92:	0b 2c       	ld.uh	r12,r5++
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	73 1c       	ld.w	r12,r9[0x44]

80004b98 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004b98:	48 28       	lddpc	r8,80004ba0 <xnl_register_xcmp_func+0x8>
80004b9a:	91 0c       	st.w	r8[0x0],r12
}
80004b9c:	5e fc       	retal	r12
80004b9e:	00 00       	add	r0,r0
80004ba0:	00 00       	add	r0,r0
80004ba2:	0b 80       	ld.ub	r0,r5[0x0]

80004ba4 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004ba4:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004ba6:	48 88       	lddpc	r8,80004bc4 <xnl_get_msg_ack_func+0x20>
80004ba8:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004baa:	98 49       	ld.sh	r9,r12[0x8]
80004bac:	f0 09 19 00 	cp.h	r9,r8
80004bb0:	c0 81       	brne	80004bc0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004bb2:	48 68       	lddpc	r8,80004bc8 <xnl_get_msg_ack_func+0x24>
80004bb4:	70 0c       	ld.w	r12,r8[0x0]
80004bb6:	30 09       	mov	r9,0
80004bb8:	12 9a       	mov	r10,r9
80004bba:	12 9b       	mov	r11,r9
80004bbc:	f0 1f 00 04 	mcall	80004bcc <xnl_get_msg_ack_func+0x28>
80004bc0:	d8 02       	popm	pc
80004bc2:	00 00       	add	r0,r0
80004bc4:	00 00       	add	r0,r0
80004bc6:	0b 66       	ld.uh	r6,--r5
80004bc8:	00 00       	add	r0,r0
80004bca:	0b 60       	ld.uh	r0,--r5
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	73 1c       	ld.w	r12,r9[0x44]

80004bd0 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004bd0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004bd4:	30 09       	mov	r9,0
80004bd6:	4b 78       	lddpc	r8,80004cb0 <xnl_init+0xe0>
80004bd8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004bda:	30 0b       	mov	r11,0
80004bdc:	30 1c       	mov	r12,1
80004bde:	f0 1f 00 36 	mcall	80004cb4 <xnl_init+0xe4>
80004be2:	4b 68       	lddpc	r8,80004cb8 <xnl_init+0xe8>
80004be4:	91 0c       	st.w	r8[0x0],r12
80004be6:	70 08       	ld.w	r8,r8[0x0]
80004be8:	58 08       	cp.w	r8,0
80004bea:	c0 80       	breq	80004bfa <xnl_init+0x2a>
80004bec:	4b 38       	lddpc	r8,80004cb8 <xnl_init+0xe8>
80004bee:	70 0c       	ld.w	r12,r8[0x0]
80004bf0:	30 09       	mov	r9,0
80004bf2:	12 9a       	mov	r10,r9
80004bf4:	12 9b       	mov	r11,r9
80004bf6:	f0 1f 00 32 	mcall	80004cbc <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004bfa:	30 4b       	mov	r11,4
80004bfc:	33 cc       	mov	r12,60
80004bfe:	f0 1f 00 2e 	mcall	80004cb4 <xnl_init+0xe4>
80004c02:	4b 08       	lddpc	r8,80004cc0 <xnl_init+0xf0>
80004c04:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004c06:	30 4b       	mov	r11,4
80004c08:	36 4c       	mov	r12,100
80004c0a:	f0 1f 00 2b 	mcall	80004cb4 <xnl_init+0xe4>
80004c0e:	4a e8       	lddpc	r8,80004cc4 <xnl_init+0xf4>
80004c10:	91 0c       	st.w	r8[0x0],r12
80004c12:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004c14:	10 96       	mov	r6,r8
80004c16:	4a d5       	lddpc	r5,80004cc8 <xnl_init+0xf8>
80004c18:	6c 0c       	ld.w	r12,r6[0x0]
80004c1a:	ea 07 00 0b 	add	r11,r5,r7
80004c1e:	f0 1f 00 2c 	mcall	80004ccc <xnl_init+0xfc>
80004c22:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004c26:	e0 47 64 00 	cp.w	r7,25600
80004c2a:	cf 71       	brne	80004c18 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c2c:	30 4b       	mov	r11,4
80004c2e:	33 2c       	mov	r12,50
80004c30:	f0 1f 00 21 	mcall	80004cb4 <xnl_init+0xe4>
80004c34:	4a 78       	lddpc	r8,80004cd0 <xnl_init+0x100>
80004c36:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c38:	30 4b       	mov	r11,4
80004c3a:	32 8c       	mov	r12,40
80004c3c:	f0 1f 00 1e 	mcall	80004cb4 <xnl_init+0xe4>
80004c40:	4a 58       	lddpc	r8,80004cd4 <xnl_init+0x104>
80004c42:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004c44:	30 4b       	mov	r11,4
80004c46:	30 ac       	mov	r12,10
80004c48:	f0 1f 00 1b 	mcall	80004cb4 <xnl_init+0xe4>
80004c4c:	4a 38       	lddpc	r8,80004cd8 <xnl_init+0x108>
80004c4e:	91 0c       	st.w	r8[0x0],r12
80004c50:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004c52:	10 96       	mov	r6,r8
80004c54:	4a 25       	lddpc	r5,80004cdc <xnl_init+0x10c>
80004c56:	6c 0c       	ld.w	r12,r6[0x0]
80004c58:	ea 07 00 0b 	add	r11,r5,r7
80004c5c:	f0 1f 00 1c 	mcall	80004ccc <xnl_init+0xfc>
80004c60:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004c64:	e0 47 14 00 	cp.w	r7,5120
80004c68:	cf 71       	brne	80004c56 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004c6a:	30 4b       	mov	r11,4
80004c6c:	30 5c       	mov	r12,5
80004c6e:	f0 1f 00 12 	mcall	80004cb4 <xnl_init+0xe4>
80004c72:	49 c8       	lddpc	r8,80004ce0 <xnl_init+0x110>
80004c74:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004c76:	30 07       	mov	r7,0
80004c78:	1a d7       	st.w	--sp,r7
80004c7a:	1a d7       	st.w	--sp,r7
80004c7c:	1a d7       	st.w	--sp,r7
80004c7e:	30 38       	mov	r8,3
80004c80:	0e 99       	mov	r9,r7
80004c82:	e0 6a 00 dc 	mov	r10,220
80004c86:	49 8b       	lddpc	r11,80004ce4 <xnl_init+0x114>
80004c88:	49 8c       	lddpc	r12,80004ce8 <xnl_init+0x118>
80004c8a:	f0 1f 00 19 	mcall	80004cec <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004c8e:	1a d7       	st.w	--sp,r7
80004c90:	1a d7       	st.w	--sp,r7
80004c92:	1a d7       	st.w	--sp,r7
80004c94:	30 38       	mov	r8,3
80004c96:	0e 99       	mov	r9,r7
80004c98:	e0 6a 00 82 	mov	r10,130
80004c9c:	49 5b       	lddpc	r11,80004cf0 <xnl_init+0x120>
80004c9e:	49 6c       	lddpc	r12,80004cf4 <xnl_init+0x124>
80004ca0:	f0 1f 00 13 	mcall	80004cec <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004ca4:	f0 1f 00 15 	mcall	80004cf8 <xnl_init+0x128>
80004ca8:	2f ad       	sub	sp,-24
}
80004caa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004cae:	00 00       	add	r0,r0
80004cb0:	00 00       	add	r0,r0
80004cb2:	0b 66       	ld.uh	r6,--r5
80004cb4:	80 00       	ld.sh	r0,r0[0x0]
80004cb6:	74 74       	ld.w	r4,r10[0x1c]
80004cb8:	00 00       	add	r0,r0
80004cba:	0b 60       	ld.uh	r0,--r5
80004cbc:	80 00       	ld.sh	r0,r0[0x0]
80004cbe:	73 1c       	ld.w	r12,r9[0x44]
80004cc0:	00 00       	add	r0,r0
80004cc2:	0b 74       	ld.ub	r4,--r5
80004cc4:	00 00       	add	r0,r0
80004cc6:	0a c4       	st.b	r5++,r4
80004cc8:	00 00       	add	r0,r0
80004cca:	33 52       	mov	r2,53
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	35 34       	mov	r4,83
80004cd0:	00 00       	add	r0,r0
80004cd2:	0a f4       	st.b	--r5,r4
80004cd4:	00 00       	add	r0,r0
80004cd6:	0a d4       	st.w	--r5,r4
80004cd8:	00 00       	add	r0,r0
80004cda:	0a c8       	st.b	r5++,r8
80004cdc:	00 00       	add	r0,r0
80004cde:	1f 52       	ld.sh	r2,--pc
80004ce0:	00 00       	add	r0,r0
80004ce2:	0b 00       	ld.w	r0,r5++
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	e9 b4       	*unknown*
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	4c fc       	lddpc	r12,80004e24 <xnl_tx_process+0xc8>
80004cec:	80 00       	ld.sh	r0,r0[0x0]
80004cee:	7b 90       	ld.w	r0,sp[0x64]
80004cf0:	80 00       	ld.sh	r0,r0[0x0]
80004cf2:	e9 bc       	*unknown*
80004cf4:	80 00       	ld.sh	r0,r0[0x0]
80004cf6:	4d 5c       	lddpc	r12,80004e48 <xnl_tx+0x20>
80004cf8:	80 00       	ld.sh	r0,r0[0x0]
80004cfa:	37 08       	mov	r8,112

80004cfc <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004cfc:	eb cd 40 fe 	pushm	r1-r7,lr
80004d00:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d02:	49 26       	lddpc	r6,80004d48 <xnl_rx_process+0x4c>
80004d04:	30 05       	mov	r5,0
80004d06:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d08:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004d0a:	49 11       	lddpc	r1,80004d4c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004d0c:	49 12       	lddpc	r2,80004d50 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d0e:	6c 0c       	ld.w	r12,r6[0x0]
80004d10:	0a 99       	mov	r9,r5
80004d12:	08 9a       	mov	r10,r4
80004d14:	1a 9b       	mov	r11,sp
80004d16:	f0 1f 00 10 	mcall	80004d54 <xnl_rx_process+0x58>
80004d1a:	58 1c       	cp.w	r12,1
80004d1c:	cf 91       	brne	80004d0e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004d1e:	40 0c       	lddsp	r12,sp[0x0]
80004d20:	58 0c       	cp.w	r12,0
80004d22:	cf 60       	breq	80004d0e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d24:	98 28       	ld.sh	r8,r12[0x4]
80004d26:	e6 08 19 00 	cp.h	r8,r3
80004d2a:	e0 8b 00 0a 	brhi	80004d3e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004d2e:	5c 78       	castu.h	r8
80004d30:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004d34:	58 09       	cp.w	r9,0
80004d36:	c0 40       	breq	80004d3e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004d38:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004d3c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004d3e:	62 0c       	ld.w	r12,r1[0x0]
80004d40:	40 0b       	lddsp	r11,sp[0x0]
80004d42:	f0 1f 00 06 	mcall	80004d58 <xnl_rx_process+0x5c>
80004d46:	ce 4b       	rjmp	80004d0e <xnl_rx_process+0x12>
80004d48:	00 00       	add	r0,r0
80004d4a:	0a d4       	st.w	--r5,r4
80004d4c:	00 00       	add	r0,r0
80004d4e:	0a c4       	st.b	r5++,r4
80004d50:	00 00       	add	r0,r0
80004d52:	05 00       	ld.w	r0,r2++
80004d54:	80 00       	ld.sh	r0,r0[0x0]
80004d56:	71 10       	ld.w	r0,r8[0x44]
80004d58:	80 00       	ld.sh	r0,r0[0x0]
80004d5a:	35 34       	mov	r4,83

80004d5c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004d5c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004d5e:	4a a6       	lddpc	r6,80004e04 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004d60:	4a a2       	lddpc	r2,80004e08 <xnl_tx_process+0xac>
80004d62:	4a b4       	lddpc	r4,80004e0c <xnl_tx_process+0xb0>
80004d64:	30 07       	mov	r7,0
80004d66:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004d68:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004d6a:	4a a5       	lddpc	r5,80004e10 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004d6c:	4a a3       	lddpc	r3,80004e14 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004d6e:	6c 08       	ld.w	r8,r6[0x0]
80004d70:	58 08       	cp.w	r8,0
80004d72:	c0 40       	breq	80004d7a <xnl_tx_process+0x1e>
80004d74:	58 18       	cp.w	r8,1
80004d76:	cf d1       	brne	80004d70 <xnl_tx_process+0x14>
80004d78:	c2 48       	rjmp	80004dc0 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004d7a:	64 0c       	ld.w	r12,r2[0x0]
80004d7c:	0e 99       	mov	r9,r7
80004d7e:	02 9a       	mov	r10,r1
80004d80:	08 9b       	mov	r11,r4
80004d82:	f0 1f 00 26 	mcall	80004e18 <xnl_tx_process+0xbc>
80004d86:	58 1c       	cp.w	r12,1
80004d88:	cf 31       	brne	80004d6e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004d8a:	68 0b       	ld.w	r11,r4[0x0]
80004d8c:	58 0b       	cp.w	r11,0
80004d8e:	cf 00       	breq	80004d6e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004d90:	96 28       	ld.sh	r8,r11[0x4]
80004d92:	e0 08 19 00 	cp.h	r8,r0
80004d96:	c0 71       	brne	80004da4 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004d98:	4a 18       	lddpc	r8,80004e1c <xnl_tx_process+0xc0>
80004d9a:	70 08       	ld.w	r8,r8[0x0]
80004d9c:	10 9c       	mov	r12,r8
80004d9e:	f0 1f 00 21 	mcall	80004e20 <xnl_tx_process+0xc4>
						break;
80004da2:	ce 6b       	rjmp	80004d6e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004da4:	16 9c       	mov	r12,r11
80004da6:	f0 1f 00 20 	mcall	80004e24 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004daa:	30 18       	mov	r8,1
80004dac:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004dae:	66 0c       	ld.w	r12,r3[0x0]
80004db0:	0e 99       	mov	r9,r7
80004db2:	0e 9a       	mov	r10,r7
80004db4:	0e 9b       	mov	r11,r7
80004db6:	f0 1f 00 19 	mcall	80004e18 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004dba:	30 18       	mov	r8,1
80004dbc:	8d 08       	st.w	r6[0x0],r8
80004dbe:	cd 8b       	rjmp	80004d6e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004dc0:	66 0c       	ld.w	r12,r3[0x0]
80004dc2:	0e 99       	mov	r9,r7
80004dc4:	36 4a       	mov	r10,100
80004dc6:	0e 9b       	mov	r11,r7
80004dc8:	f0 1f 00 14 	mcall	80004e18 <xnl_tx_process+0xbc>
80004dcc:	58 1c       	cp.w	r12,1
80004dce:	c0 81       	brne	80004dde <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004dd0:	49 38       	lddpc	r8,80004e1c <xnl_tx_process+0xc0>
80004dd2:	70 0c       	ld.w	r12,r8[0x0]
80004dd4:	68 0b       	ld.w	r11,r4[0x0]
80004dd6:	f0 1f 00 13 	mcall	80004e20 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004dda:	8d 07       	st.w	r6[0x0],r7
80004ddc:	cc 9b       	rjmp	80004d6e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004dde:	6a 08       	ld.w	r8,r5[0x0]
80004de0:	58 38       	cp.w	r8,3
80004de2:	e0 89 00 09 	brgt	80004df4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004de6:	68 0c       	ld.w	r12,r4[0x0]
80004de8:	f0 1f 00 0f 	mcall	80004e24 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004dec:	6a 08       	ld.w	r8,r5[0x0]
80004dee:	2f f8       	sub	r8,-1
80004df0:	8b 08       	st.w	r5[0x0],r8
80004df2:	cb eb       	rjmp	80004d6e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004df4:	48 a8       	lddpc	r8,80004e1c <xnl_tx_process+0xc0>
80004df6:	70 0c       	ld.w	r12,r8[0x0]
80004df8:	68 0b       	ld.w	r11,r4[0x0]
80004dfa:	f0 1f 00 0a 	mcall	80004e20 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004dfe:	8d 07       	st.w	r6[0x0],r7
80004e00:	cb 7b       	rjmp	80004d6e <xnl_tx_process+0x12>
80004e02:	00 00       	add	r0,r0
80004e04:	00 00       	add	r0,r0
80004e06:	0b 70       	ld.ub	r0,--r5
80004e08:	00 00       	add	r0,r0
80004e0a:	0b 74       	ld.ub	r4,--r5
80004e0c:	00 00       	add	r0,r0
80004e0e:	0b 7c       	ld.ub	r12,--r5
80004e10:	00 00       	add	r0,r0
80004e12:	0b 78       	ld.ub	r8,--r5
80004e14:	00 00       	add	r0,r0
80004e16:	0b 60       	ld.uh	r0,--r5
80004e18:	80 00       	ld.sh	r0,r0[0x0]
80004e1a:	71 10       	ld.w	r0,r8[0x44]
80004e1c:	00 00       	add	r0,r0
80004e1e:	0a c4       	st.b	r5++,r4
80004e20:	80 00       	ld.sh	r0,r0[0x0]
80004e22:	35 34       	mov	r4,83
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	35 54       	mov	r4,85

80004e28 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004e28:	eb cd 40 c0 	pushm	r6-r7,lr
80004e2c:	20 1d       	sub	sp,4
80004e2e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004e30:	98 39       	ld.sh	r9,r12[0x6]
80004e32:	3f f8       	mov	r8,-1
80004e34:	f0 09 19 00 	cp.h	r9,r8
80004e38:	c0 a1       	brne	80004e4c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004e3a:	4a e9       	lddpc	r9,80004ef0 <xnl_tx+0xc8>
80004e3c:	13 88       	ld.ub	r8,r9[0x0]
80004e3e:	2f f8       	sub	r8,-1
80004e40:	5c 58       	castu.b	r8
80004e42:	b2 88       	st.b	r9[0x0],r8
80004e44:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004e48:	a9 a8       	sbr	r8,0x8
80004e4a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004e4c:	8c 49       	ld.sh	r9,r6[0x8]
80004e4e:	3f f8       	mov	r8,-1
80004e50:	f0 09 19 00 	cp.h	r9,r8
80004e54:	c0 41       	brne	80004e5c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004e56:	4a 88       	lddpc	r8,80004ef4 <xnl_tx+0xcc>
80004e58:	90 18       	ld.sh	r8,r8[0x2]
80004e5a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004e5c:	8c 59       	ld.sh	r9,r6[0xa]
80004e5e:	3f f8       	mov	r8,-1
80004e60:	f0 09 19 00 	cp.h	r9,r8
80004e64:	c0 41       	brne	80004e6c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004e66:	4a 48       	lddpc	r8,80004ef4 <xnl_tx+0xcc>
80004e68:	90 28       	ld.sh	r8,r8[0x4]
80004e6a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004e6c:	8c 69       	ld.sh	r9,r6[0xc]
80004e6e:	3f f8       	mov	r8,-1
80004e70:	f0 09 19 00 	cp.h	r9,r8
80004e74:	c0 e1       	brne	80004e90 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004e76:	4a 08       	lddpc	r8,80004ef4 <xnl_tx+0xcc>
80004e78:	90 49       	ld.sh	r9,r8[0x8]
80004e7a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004e7c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004e7e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004e80:	90 49       	ld.sh	r9,r8[0x8]
80004e82:	e0 19 ff 00 	andl	r9,0xff00
80004e86:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004e8a:	f3 e8 10 08 	or	r8,r9,r8
80004e8e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004e90:	0d 98       	ld.ub	r8,r6[0x1]
80004e92:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004e94:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004e98:	10 0c       	add	r12,r8
80004e9a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004e9c:	58 0c       	cp.w	r12,0
80004e9e:	e0 89 00 04 	brgt	80004ea6 <xnl_tx+0x7e>
80004ea2:	30 09       	mov	r9,0
80004ea4:	c0 d8       	rjmp	80004ebe <xnl_tx+0x96>
80004ea6:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004eaa:	2f ec       	sub	r12,-2
80004eac:	30 09       	mov	r9,0
80004eae:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004eb0:	15 1b       	ld.sh	r11,r10++
80004eb2:	f6 09 00 09 	add	r9,r11,r9
80004eb6:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004eb8:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004eba:	18 38       	cp.w	r8,r12
80004ebc:	cf a1       	brne	80004eb0 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004ebe:	5c 39       	neg	r9
80004ec0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004ec2:	48 e8       	lddpc	r8,80004ef8 <xnl_tx+0xd0>
80004ec4:	70 0c       	ld.w	r12,r8[0x0]
80004ec6:	f0 1f 00 0e 	mcall	80004efc <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004eca:	c1 00       	breq	80004eea <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004ecc:	fa c7 ff fc 	sub	r7,sp,-4
80004ed0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004ed2:	e0 6a 01 00 	mov	r10,256
80004ed6:	0c 9b       	mov	r11,r6
80004ed8:	f0 1f 00 0a 	mcall	80004f00 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004edc:	48 a8       	lddpc	r8,80004f04 <xnl_tx+0xdc>
80004ede:	70 0c       	ld.w	r12,r8[0x0]
80004ee0:	30 09       	mov	r9,0
80004ee2:	12 9a       	mov	r10,r9
80004ee4:	1a 9b       	mov	r11,sp
80004ee6:	f0 1f 00 09 	mcall	80004f08 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004eea:	2f fd       	sub	sp,-4
80004eec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ef0:	00 00       	add	r0,r0
80004ef2:	0b 64       	ld.uh	r4,--r5
80004ef4:	00 00       	add	r0,r0
80004ef6:	0b 66       	ld.uh	r6,--r5
80004ef8:	00 00       	add	r0,r0
80004efa:	0a c4       	st.b	r5++,r4
80004efc:	80 00       	ld.sh	r0,r0[0x0]
80004efe:	36 e0       	mov	r0,110
80004f00:	80 00       	ld.sh	r0,r0[0x0]
80004f02:	87 fe       	st.w	r3[0x3c],lr
80004f04:	00 00       	add	r0,r0
80004f06:	0b 74       	ld.ub	r4,--r5
80004f08:	80 00       	ld.sh	r0,r0[0x0]
80004f0a:	73 1c       	ld.w	r12,r9[0x44]

80004f0c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004f0c:	eb cd 40 80 	pushm	r7,lr
80004f10:	fa cd 01 00 	sub	sp,sp,256
80004f14:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004f16:	e0 68 40 0e 	mov	r8,16398
80004f1a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004f1c:	3f f8       	mov	r8,-1
80004f1e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004f20:	30 c8       	mov	r8,12
80004f22:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004f24:	98 38       	ld.sh	r8,r12[0x6]
80004f26:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004f28:	98 58       	ld.sh	r8,r12[0xa]
80004f2a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004f2c:	98 48       	ld.sh	r8,r12[0x8]
80004f2e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004f30:	98 68       	ld.sh	r8,r12[0xc]
80004f32:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004f34:	30 08       	mov	r8,0
80004f36:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004f38:	1a 9c       	mov	r12,sp
80004f3a:	f0 1f 00 0a 	mcall	80004f60 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004f3e:	fa cd 00 cc 	sub	sp,sp,204
80004f42:	e0 6a 00 ca 	mov	r10,202
80004f46:	ee cb ff f0 	sub	r11,r7,-16
80004f4a:	1a 9c       	mov	r12,sp
80004f4c:	f0 1f 00 06 	mcall	80004f64 <xnl_data_msg_func+0x58>
80004f50:	48 68       	lddpc	r8,80004f68 <xnl_data_msg_func+0x5c>
80004f52:	70 08       	ld.w	r8,r8[0x0]
80004f54:	5d 18       	icall	r8
80004f56:	fa cd ff 34 	sub	sp,sp,-204
}
80004f5a:	2c 0d       	sub	sp,-256
80004f5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f60:	80 00       	ld.sh	r0,r0[0x0]
80004f62:	4e 28       	lddpc	r8,800050e8 <xnl_master_status_brdcst_func+0x5c>
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	87 fe       	st.w	r3[0x3c],lr
80004f68:	00 00       	add	r0,r0
80004f6a:	0b 80       	ld.ub	r0,r5[0x0]

80004f6c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004f6c:	d4 21       	pushm	r4-r7,lr
80004f6e:	fa cd 01 00 	sub	sp,sp,256
80004f72:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004f74:	4c 28       	lddpc	r8,8000507c <xnl_device_auth_reply_func+0x110>
80004f76:	11 88       	ld.ub	r8,r8[0x0]
80004f78:	58 08       	cp.w	r8,0
80004f7a:	e0 81 00 7f 	brne	80005078 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004f7e:	4c 18       	lddpc	r8,80005080 <xnl_device_auth_reply_func+0x114>
80004f80:	70 0c       	ld.w	r12,r8[0x0]
80004f82:	30 09       	mov	r9,0
80004f84:	12 9a       	mov	r10,r9
80004f86:	12 9b       	mov	r11,r9
80004f88:	f0 1f 00 3f 	mcall	80005084 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004f8c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004f90:	4b b8       	lddpc	r8,8000507c <xnl_device_auth_reply_func+0x110>
80004f92:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004f94:	ef 39 00 12 	ld.ub	r9,r7[18]
80004f98:	ef 38 00 13 	ld.ub	r8,r7[19]
80004f9c:	b1 68       	lsl	r8,0x10
80004f9e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004fa2:	ef 38 00 15 	ld.ub	r8,r7[21]
80004fa6:	f3 e8 10 08 	or	r8,r9,r8
80004faa:	ef 39 00 14 	ld.ub	r9,r7[20]
80004fae:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004fb2:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004fb6:	ef 38 00 17 	ld.ub	r8,r7[23]
80004fba:	b1 68       	lsl	r8,0x10
80004fbc:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004fc0:	ef 38 00 19 	ld.ub	r8,r7[25]
80004fc4:	f5 e8 10 08 	or	r8,r10,r8
80004fc8:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004fcc:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004fd0:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004fd2:	e0 64 79 b9 	mov	r4,31161
80004fd6:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004fda:	e0 65 45 07 	mov	r5,17671
80004fde:	ea 15 8a bd 	orh	r5,0x8abd
80004fe2:	e0 66 f9 3d 	mov	r6,63805
80004fe6:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004fea:	e0 6e b8 cf 	mov	lr,47311
80004fee:	ea 1e 36 83 	orh	lr,0x3683
80004ff2:	e0 67 aa 1c 	mov	r7,43548
80004ff6:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004ffa:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004ffc:	f4 08 00 0c 	add	r12,r10,r8
80005000:	f0 0b 15 04 	lsl	r11,r8,0x4
80005004:	0a 0b       	add	r11,r5
80005006:	f9 eb 20 0b 	eor	r11,r12,r11
8000500a:	f0 0c 16 05 	lsr	r12,r8,0x5
8000500e:	0c 0c       	add	r12,r6
80005010:	18 5b       	eor	r11,r12
80005012:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005014:	f2 0c 15 04 	lsl	r12,r9,0x4
80005018:	1c 0c       	add	r12,lr
8000501a:	f2 0b 16 05 	lsr	r11,r9,0x5
8000501e:	0e 0b       	add	r11,r7
80005020:	f9 eb 20 0b 	eor	r11,r12,r11
80005024:	f2 0a 00 0c 	add	r12,r9,r10
80005028:	18 5b       	eor	r11,r12
8000502a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000502c:	e0 6b 37 20 	mov	r11,14112
80005030:	ea 1b c6 ef 	orh	r11,0xc6ef
80005034:	16 3a       	cp.w	r10,r11
80005036:	ce 21       	brne	80004ffa <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80005038:	e0 6a 40 1a 	mov	r10,16410
8000503c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000503e:	3f fa       	mov	r10,-1
80005040:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80005042:	30 6b       	mov	r11,6
80005044:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005046:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005048:	48 db       	lddpc	r11,8000507c <xnl_device_auth_reply_func+0x110>
8000504a:	96 1c       	ld.sh	r12,r11[0x2]
8000504c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000504e:	96 2b       	ld.sh	r11,r11[0x4]
80005050:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005052:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80005054:	30 ca       	mov	r10,12
80005056:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80005058:	30 0a       	mov	r10,0
8000505a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000505e:	30 7a       	mov	r10,7
80005060:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80005064:	30 2a       	mov	r10,2
80005066:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000506a:	fa ca ff ec 	sub	r10,sp,-20
8000506e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005070:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005072:	1a 9c       	mov	r12,sp
80005074:	f0 1f 00 05 	mcall	80005088 <xnl_device_auth_reply_func+0x11c>
}
80005078:	2c 0d       	sub	sp,-256
8000507a:	d8 22       	popm	r4-r7,pc
8000507c:	00 00       	add	r0,r0
8000507e:	0b 66       	ld.uh	r6,--r5
80005080:	00 00       	add	r0,r0
80005082:	0b 60       	ld.uh	r0,--r5
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	73 1c       	ld.w	r12,r9[0x44]
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	4e 28       	lddpc	r8,80005210 <WriteRawRC+0x8>

8000508c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000508c:	eb cd 40 80 	pushm	r7,lr
80005090:	fa cd 01 00 	sub	sp,sp,256
80005094:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80005096:	49 28       	lddpc	r8,800050dc <xnl_master_status_brdcst_func+0x50>
80005098:	11 88       	ld.ub	r8,r8[0x0]
8000509a:	58 08       	cp.w	r8,0
8000509c:	c1 c1       	brne	800050d4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000509e:	49 18       	lddpc	r8,800050e0 <xnl_master_status_brdcst_func+0x54>
800050a0:	70 0c       	ld.w	r12,r8[0x0]
800050a2:	30 09       	mov	r9,0
800050a4:	12 9a       	mov	r10,r9
800050a6:	12 9b       	mov	r11,r9
800050a8:	f0 1f 00 0f 	mcall	800050e4 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800050ac:	8e 58       	ld.sh	r8,r7[0xa]
800050ae:	48 c9       	lddpc	r9,800050dc <xnl_master_status_brdcst_func+0x50>
800050b0:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800050b2:	e0 68 40 0e 	mov	r8,16398
800050b6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800050b8:	3f f8       	mov	r8,-1
800050ba:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800050bc:	30 4a       	mov	r10,4
800050be:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800050c0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800050c2:	92 19       	ld.sh	r9,r9[0x2]
800050c4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800050c6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800050c8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800050ca:	30 08       	mov	r8,0
800050cc:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800050ce:	1a 9c       	mov	r12,sp
800050d0:	f0 1f 00 06 	mcall	800050e8 <xnl_master_status_brdcst_func+0x5c>
}
800050d4:	2c 0d       	sub	sp,-256
800050d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800050da:	00 00       	add	r0,r0
800050dc:	00 00       	add	r0,r0
800050de:	0b 66       	ld.uh	r6,--r5
800050e0:	00 00       	add	r0,r0
800050e2:	0b 60       	ld.uh	r0,--r5
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	73 1c       	ld.w	r12,r9[0x44]
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	4e 28       	lddpc	r8,80005270 <PcdReset+0x28>

800050ec <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800050ec:	eb cd 40 80 	pushm	r7,lr
800050f0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800050f2:	49 28       	lddpc	r8,80005138 <xnl_device_conn_reply_func+0x4c>
800050f4:	70 0c       	ld.w	r12,r8[0x0]
800050f6:	30 09       	mov	r9,0
800050f8:	12 9a       	mov	r10,r9
800050fa:	12 9b       	mov	r11,r9
800050fc:	f0 1f 00 10 	mcall	8000513c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005100:	ef 18 00 10 	ld.uh	r8,r7[16]
80005104:	10 99       	mov	r9,r8
80005106:	e2 19 ff 00 	andl	r9,0xff00,COH
8000510a:	e0 49 01 00 	cp.w	r9,256
8000510e:	c0 60       	breq	8000511a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005110:	0e 9c       	mov	r12,r7
80005112:	f0 1f 00 0c 	mcall	80005140 <xnl_device_conn_reply_func+0x54>
80005116:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000511a:	a9 68       	lsl	r8,0x8
8000511c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005120:	48 98       	lddpc	r8,80005144 <xnl_device_conn_reply_func+0x58>
80005122:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005124:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80005128:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000512a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000512e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80005130:	30 19       	mov	r9,1
80005132:	b0 89       	st.b	r8[0x0],r9
80005134:	e3 cd 80 80 	ldm	sp++,r7,pc
80005138:	00 00       	add	r0,r0
8000513a:	0b 60       	ld.uh	r0,--r5
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	73 1c       	ld.w	r12,r9[0x44]
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	50 8c       	stdsp	sp[0x20],r12
80005144:	00 00       	add	r0,r0
80005146:	0b 66       	ld.uh	r6,--r5

80005148 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80005148:	d4 01       	pushm	lr
8000514a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000514e:	e0 68 40 0e 	mov	r8,16398
80005152:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005154:	3f f8       	mov	r8,-1
80005156:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80005158:	30 38       	mov	r8,3
8000515a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000515c:	30 08       	mov	r8,0
8000515e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80005160:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80005162:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80005164:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80005166:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005168:	1a 9c       	mov	r12,sp
8000516a:	f0 1f 00 03 	mcall	80005174 <xnl_send_device_master_query+0x2c>
}
8000516e:	2c 0d       	sub	sp,-256
80005170:	d8 02       	popm	pc
80005172:	00 00       	add	r0,r0
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	4e 28       	lddpc	r8,800052fc <ReadRawRC+0x34>

80005178 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80005178:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000517a:	48 78       	lddpc	r8,80005194 <RC522_SPI_SetSpeed+0x1c>
8000517c:	70 09       	ld.w	r9,r8[0x0]
8000517e:	72 ca       	ld.w	r10,r9[0x30]
80005180:	5c 7c       	castu.h	r12
80005182:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80005186:	f9 ea 10 0a 	or	r10,r12,r10
8000518a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000518c:	70 0c       	ld.w	r12,r8[0x0]
8000518e:	f0 1f 00 03 	mcall	80005198 <RC522_SPI_SetSpeed+0x20>
		
	
}
80005192:	d8 02       	popm	pc
80005194:	00 00       	add	r0,r0
80005196:	1e 2c       	rsub	r12,pc
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	68 0c       	ld.w	r12,r4[0x0]

8000519c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000519c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000519e:	e0 6c 0a 00 	mov	r12,2560
800051a2:	f0 1f 00 02 	mcall	800051a8 <RC522_SPI_SetSpeedLow+0xc>
	
}
800051a6:	d8 02       	popm	pc
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	51 78       	stdsp	sp[0x5c],r8

800051ac <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800051ac:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800051b0:	48 76       	lddpc	r6,800051cc <RC522_ReadByte+0x20>
800051b2:	e0 6b 00 ff 	mov	r11,255
800051b6:	6c 0c       	ld.w	r12,r6[0x0]
800051b8:	f0 1f 00 06 	mcall	800051d0 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800051bc:	30 07       	mov	r7,0
800051be:	0e 9b       	mov	r11,r7
800051c0:	6c 0c       	ld.w	r12,r6[0x0]
800051c2:	f0 1f 00 05 	mcall	800051d4 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800051c6:	0f 9c       	ld.ub	r12,r7[0x1]
800051c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800051cc:	00 00       	add	r0,r0
800051ce:	1e 2c       	rsub	r12,pc
800051d0:	80 00       	ld.sh	r0,r0[0x0]
800051d2:	68 12       	ld.w	r2,r4[0x4]
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	68 2e       	ld.w	lr,r4[0x8]

800051d8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800051d8:	eb cd 40 80 	pushm	r7,lr
800051dc:	20 1d       	sub	sp,4
800051de:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800051e0:	48 77       	lddpc	r7,800051fc <RC522_WriteByte+0x24>
800051e2:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800051e6:	6e 0c       	ld.w	r12,r7[0x0]
800051e8:	f0 1f 00 06 	mcall	80005200 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800051ec:	1a 9b       	mov	r11,sp
800051ee:	6e 0c       	ld.w	r12,r7[0x0]
800051f0:	f0 1f 00 05 	mcall	80005204 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800051f4:	5c 5c       	castu.b	r12
800051f6:	2f fd       	sub	sp,-4
800051f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800051fc:	00 00       	add	r0,r0
800051fe:	1e 2c       	rsub	r12,pc
80005200:	80 00       	ld.sh	r0,r0[0x0]
80005202:	68 12       	ld.w	r2,r4[0x4]
80005204:	80 00       	ld.sh	r0,r0[0x0]
80005206:	68 2e       	ld.w	lr,r4[0x8]

80005208 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80005208:	eb cd 40 e0 	pushm	r5-r7,lr
8000520c:	18 96       	mov	r6,r12
8000520e:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80005210:	48 a7       	lddpc	r7,80005238 <WriteRawRC+0x30>
80005212:	30 0b       	mov	r11,0
80005214:	6e 0c       	ld.w	r12,r7[0x0]
80005216:	f0 1f 00 0a 	mcall	8000523c <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000521a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000521e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80005222:	f0 1f 00 08 	mcall	80005240 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80005226:	0a 9c       	mov	r12,r5
80005228:	f0 1f 00 06 	mcall	80005240 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000522c:	30 0b       	mov	r11,0
8000522e:	6e 0c       	ld.w	r12,r7[0x0]
80005230:	f0 1f 00 05 	mcall	80005244 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80005234:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005238:	00 00       	add	r0,r0
8000523a:	1e 2c       	rsub	r12,pc
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	69 78       	ld.w	r8,r4[0x5c]
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	51 d8       	stdsp	sp[0x74],r8
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	69 38       	ld.w	r8,r4[0x4c]

80005248 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80005248:	d4 01       	pushm	lr

	SET_RC522RST;
8000524a:	31 9c       	mov	r12,25
8000524c:	f0 1f 00 1b 	mcall	800052b8 <PcdReset+0x70>
	delay_ns(10);
80005250:	30 ac       	mov	r12,10
80005252:	f0 1f 00 1b 	mcall	800052bc <PcdReset+0x74>

	CLR_RC522RST;
80005256:	31 9c       	mov	r12,25
80005258:	f0 1f 00 1a 	mcall	800052c0 <PcdReset+0x78>
	delay_ns(10);
8000525c:	30 ac       	mov	r12,10
8000525e:	f0 1f 00 18 	mcall	800052bc <PcdReset+0x74>

	SET_RC522RST;
80005262:	31 9c       	mov	r12,25
80005264:	f0 1f 00 15 	mcall	800052b8 <PcdReset+0x70>
	delay_ns(10);
80005268:	30 ac       	mov	r12,10
8000526a:	f0 1f 00 15 	mcall	800052bc <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000526e:	30 fb       	mov	r11,15
80005270:	30 1c       	mov	r12,1
80005272:	f0 1f 00 15 	mcall	800052c4 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80005276:	30 fb       	mov	r11,15
80005278:	30 1c       	mov	r12,1
8000527a:	f0 1f 00 13 	mcall	800052c4 <PcdReset+0x7c>
	delay_ns(10);
8000527e:	30 ac       	mov	r12,10
80005280:	f0 1f 00 0f 	mcall	800052bc <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80005284:	33 db       	mov	r11,61
80005286:	31 1c       	mov	r12,17
80005288:	f0 1f 00 0f 	mcall	800052c4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000528c:	31 eb       	mov	r11,30
8000528e:	32 dc       	mov	r12,45
80005290:	f0 1f 00 0d 	mcall	800052c4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80005294:	30 0b       	mov	r11,0
80005296:	32 cc       	mov	r12,44
80005298:	f0 1f 00 0b 	mcall	800052c4 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000529c:	e0 6b 00 8d 	mov	r11,141
800052a0:	32 ac       	mov	r12,42
800052a2:	f0 1f 00 09 	mcall	800052c4 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800052a6:	33 eb       	mov	r11,62
800052a8:	32 bc       	mov	r12,43
800052aa:	f0 1f 00 07 	mcall	800052c4 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800052ae:	34 0b       	mov	r11,64
800052b0:	31 5c       	mov	r12,21
800052b2:	f0 1f 00 05 	mcall	800052c4 <PcdReset+0x7c>
	
	return MI_OK;
}
800052b6:	d8 0a       	popm	pc,r12=0
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	63 80       	ld.w	r0,r1[0x60]
800052bc:	80 00       	ld.sh	r0,r0[0x0]
800052be:	5b e0       	cp.w	r0,-2
800052c0:	80 00       	ld.sh	r0,r0[0x0]
800052c2:	63 9c       	ld.w	r12,r1[0x64]
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	52 08       	stdsp	sp[0x80],r8

800052c8 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800052c8:	eb cd 40 c0 	pushm	r6-r7,lr
800052cc:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800052ce:	48 c7       	lddpc	r7,800052fc <ReadRawRC+0x34>
800052d0:	30 0b       	mov	r11,0
800052d2:	6e 0c       	ld.w	r12,r7[0x0]
800052d4:	f0 1f 00 0b 	mcall	80005300 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800052d8:	a1 76       	lsl	r6,0x1
800052da:	0c 9c       	mov	r12,r6
800052dc:	e2 1c 00 7e 	andl	r12,0x7e,COH
800052e0:	a7 bc       	sbr	r12,0x7
800052e2:	f0 1f 00 09 	mcall	80005304 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800052e6:	f0 1f 00 09 	mcall	80005308 <ReadRawRC+0x40>
800052ea:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800052ec:	30 0b       	mov	r11,0
800052ee:	6e 0c       	ld.w	r12,r7[0x0]
800052f0:	f0 1f 00 07 	mcall	8000530c <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800052f4:	0c 9c       	mov	r12,r6
800052f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800052fa:	00 00       	add	r0,r0
800052fc:	00 00       	add	r0,r0
800052fe:	1e 2c       	rsub	r12,pc
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	69 78       	ld.w	r8,r4[0x5c]
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	51 d8       	stdsp	sp[0x74],r8
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	51 ac       	stdsp	sp[0x68],r12
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	69 38       	ld.w	r8,r4[0x4c]

80005310 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80005310:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80005312:	30 1c       	mov	r12,1
80005314:	f0 1f 00 02 	mcall	8000531c <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80005318:	d8 02       	popm	pc
8000531a:	00 00       	add	r0,r0
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	52 c8       	stdsp	sp[0xb0],r8

80005320 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80005320:	eb cd 40 80 	pushm	r7,lr
80005324:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80005326:	30 1c       	mov	r12,1
80005328:	f0 1f 00 0d 	mcall	8000535c <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
8000532c:	30 18       	mov	r8,1
8000532e:	f0 07 18 00 	cp.b	r7,r8
80005332:	c0 91       	brne	80005344 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80005334:	18 9b       	mov	r11,r12
80005336:	a5 ab       	sbr	r11,0x4
80005338:	5c 5b       	castu.b	r11
8000533a:	30 1c       	mov	r12,1
8000533c:	f0 1f 00 09 	mcall	80005360 <Powerdown_RC522+0x40>
80005340:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80005344:	18 9b       	mov	r11,r12
80005346:	30 1c       	mov	r12,1
80005348:	f0 1f 00 06 	mcall	80005360 <Powerdown_RC522+0x40>
		delay_ns(2);
8000534c:	30 2c       	mov	r12,2
8000534e:	f0 1f 00 06 	mcall	80005364 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80005352:	f0 1f 00 06 	mcall	80005368 <Powerdown_RC522+0x48>
80005356:	e3 cd 80 80 	ldm	sp++,r7,pc
8000535a:	00 00       	add	r0,r0
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	52 c8       	stdsp	sp[0xb0],r8
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	52 08       	stdsp	sp[0x80],r8
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	5b e0       	cp.w	r0,-2
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	53 10       	stdsp	sp[0xc4],r0

8000536c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
8000536c:	eb cd 40 c0 	pushm	r6-r7,lr
80005370:	18 97       	mov	r7,r12
80005372:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80005374:	f0 1f 00 05 	mcall	80005388 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80005378:	f9 e6 10 0b 	or	r11,r12,r6
8000537c:	5c 5b       	castu.b	r11
8000537e:	0e 9c       	mov	r12,r7
80005380:	f0 1f 00 03 	mcall	8000538c <SetBitMask+0x20>
}
80005384:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	52 c8       	stdsp	sp[0xb0],r8
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	52 08       	stdsp	sp[0x80],r8

80005390 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80005390:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80005392:	31 4c       	mov	r12,20
80005394:	f0 1f 00 05 	mcall	800053a8 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80005398:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
8000539c:	c0 51       	brne	800053a6 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000539e:	30 3b       	mov	r11,3
800053a0:	31 4c       	mov	r12,20
800053a2:	f0 1f 00 03 	mcall	800053ac <PcdAntennaOn+0x1c>
800053a6:	d8 02       	popm	pc
800053a8:	80 00       	ld.sh	r0,r0[0x0]
800053aa:	52 c8       	stdsp	sp[0xb0],r8
800053ac:	80 00       	ld.sh	r0,r0[0x0]
800053ae:	53 6c       	stdsp	sp[0xd8],r12

800053b0 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800053b0:	eb cd 40 c0 	pushm	r6-r7,lr
800053b4:	18 97       	mov	r7,r12
800053b6:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800053b8:	f0 1f 00 06 	mcall	800053d0 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800053bc:	5c d6       	com	r6
800053be:	f9 e6 00 06 	and	r6,r12,r6
800053c2:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800053c6:	0e 9c       	mov	r12,r7
800053c8:	f0 1f 00 03 	mcall	800053d4 <ClearBitMask+0x24>
	
}
800053cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	52 c8       	stdsp	sp[0xb0],r8
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	52 08       	stdsp	sp[0x80],r8

800053d8 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800053d8:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800053da:	30 3b       	mov	r11,3
800053dc:	31 4c       	mov	r12,20
800053de:	f0 1f 00 02 	mcall	800053e4 <PcdAntennaOff+0xc>
}
800053e2:	d8 02       	popm	pc
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	53 b0       	stdsp	sp[0xec],r0

800053e8 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800053e8:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800053ea:	34 18       	mov	r8,65
800053ec:	f0 0c 18 00 	cp.b	r12,r8
800053f0:	c0 20       	breq	800053f4 <M500PcdConfigISOType+0xc>
800053f2:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800053f4:	30 8b       	mov	r11,8
800053f6:	16 9c       	mov	r12,r11
800053f8:	f0 1f 00 14 	mcall	80005448 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800053fc:	33 db       	mov	r11,61
800053fe:	31 1c       	mov	r12,17
80005400:	f0 1f 00 13 	mcall	8000544c <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80005404:	e0 6b 00 86 	mov	r11,134
80005408:	31 7c       	mov	r12,23
8000540a:	f0 1f 00 11 	mcall	8000544c <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
8000540e:	37 fb       	mov	r11,127
80005410:	32 6c       	mov	r12,38
80005412:	f0 1f 00 0f 	mcall	8000544c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80005416:	31 eb       	mov	r11,30
80005418:	32 dc       	mov	r12,45
8000541a:	f0 1f 00 0d 	mcall	8000544c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
8000541e:	30 0b       	mov	r11,0
80005420:	32 cc       	mov	r12,44
80005422:	f0 1f 00 0b 	mcall	8000544c <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80005426:	e0 6b 00 8d 	mov	r11,141
8000542a:	32 ac       	mov	r12,42
8000542c:	f0 1f 00 08 	mcall	8000544c <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80005430:	33 eb       	mov	r11,62
80005432:	32 bc       	mov	r12,43
80005434:	f0 1f 00 06 	mcall	8000544c <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80005438:	e0 6c 03 e8 	mov	r12,1000
8000543c:	f0 1f 00 05 	mcall	80005450 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80005440:	f0 1f 00 05 	mcall	80005454 <M500PcdConfigISOType+0x6c>
80005444:	d8 0a       	popm	pc,r12=0
80005446:	00 00       	add	r0,r0
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	53 b0       	stdsp	sp[0xec],r0
8000544c:	80 00       	ld.sh	r0,r0[0x0]
8000544e:	52 08       	stdsp	sp[0x80],r8
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	5b e0       	cp.w	r0,-2
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	53 90       	stdsp	sp[0xe4],r0

80005458 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80005458:	eb cd 40 80 	pushm	r7,lr
8000545c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000545e:	49 d8       	lddpc	r8,800054d0 <rc522_init+0x78>
80005460:	1a 97       	mov	r7,sp
80005462:	f0 ea 00 00 	ld.d	r10,r8[0]
80005466:	fa eb 00 00 	st.d	sp[0],r10
8000546a:	f0 e8 00 08 	ld.d	r8,r8[8]
8000546e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80005472:	30 1b       	mov	r11,1
80005474:	49 8c       	lddpc	r12,800054d4 <rc522_init+0x7c>
80005476:	f0 1f 00 19 	mcall	800054d8 <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000547a:	31 9c       	mov	r12,25
8000547c:	f0 1f 00 18 	mcall	800054dc <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80005480:	31 9c       	mov	r12,25
80005482:	f0 1f 00 18 	mcall	800054e0 <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80005486:	fe 7c 24 00 	mov	r12,-56320
8000548a:	49 78       	lddpc	r8,800054e4 <rc522_init+0x8c>
8000548c:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
8000548e:	e0 6a 36 00 	mov	r10,13824
80005492:	ea 1a 01 6e 	orh	r10,0x16e
80005496:	1a 9b       	mov	r11,sp
80005498:	f0 1f 00 14 	mcall	800054e8 <rc522_init+0x90>
8000549c:	c0 50       	breq	800054a6 <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
8000549e:	30 29       	mov	r9,2
800054a0:	49 38       	lddpc	r8,800054ec <rc522_init+0x94>
800054a2:	b0 89       	st.b	r8[0x0],r9
800054a4:	c0 38       	rjmp	800054aa <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800054a6:	f0 1f 00 13 	mcall	800054f0 <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800054aa:	f0 1f 00 13 	mcall	800054f4 <rc522_init+0x9c>
	
	PcdAntennaOff();
800054ae:	f0 1f 00 13 	mcall	800054f8 <rc522_init+0xa0>
	
	delay_ms(2); 
800054b2:	30 2c       	mov	r12,2
800054b4:	f0 1f 00 12 	mcall	800054fc <rc522_init+0xa4>
	
	PcdAntennaOn();
800054b8:	f0 1f 00 12 	mcall	80005500 <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
800054bc:	34 1c       	mov	r12,65
800054be:	f0 1f 00 12 	mcall	80005504 <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
800054c2:	30 1c       	mov	r12,1
800054c4:	f0 1f 00 11 	mcall	80005508 <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

800054c8:	2f cd       	sub	sp,-16
800054ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800054ce:	00 00       	add	r0,r0
800054d0:	80 00       	ld.sh	r0,r0[0x0]
800054d2:	e9 cc 80 00 	stm	r12,pc
800054d6:	e9 dc 80 00 	ldswp.w	r12,r4[0]
800054da:	63 38       	ld.w	r8,r1[0x4c]
800054dc:	80 00       	ld.sh	r0,r0[0x0]
800054de:	63 68       	ld.w	r8,r1[0x58]
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	63 80       	ld.w	r0,r1[0x60]
800054e4:	00 00       	add	r0,r0
800054e6:	1e 2c       	rsub	r12,pc
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	68 50       	ld.w	r0,r4[0x14]
800054ec:	00 00       	add	r0,r0
800054ee:	0b 84       	ld.ub	r4,r5[0x0]
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	51 9c       	stdsp	sp[0x64],r12
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	52 48       	stdsp	sp[0x90],r8
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	53 d8       	stdsp	sp[0xf4],r8
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	5c 20       	cpc	r0
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	53 90       	stdsp	sp[0xe4],r0
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	53 e8       	stdsp	sp[0xf8],r8
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	53 20       	stdsp	sp[0xc8],r0

8000550c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
8000550c:	d4 31       	pushm	r0-r7,lr
8000550e:	20 1d       	sub	sp,4
80005510:	18 92       	mov	r2,r12
80005512:	16 95       	mov	r5,r11
80005514:	14 96       	mov	r6,r10
80005516:	50 09       	stdsp	sp[0x0],r9
80005518:	10 90       	mov	r0,r8
8000551a:	f8 c8 00 0c 	sub	r8,r12,12
8000551e:	5c 58       	castu.b	r8
80005520:	30 29       	mov	r9,2
80005522:	f2 08 18 00 	cp.b	r8,r9
80005526:	e0 88 00 05 	brls	80005530 <PcdComMF522+0x24>
8000552a:	30 03       	mov	r3,0
8000552c:	06 91       	mov	r1,r3
8000552e:	c0 78       	rjmp	8000553c <PcdComMF522+0x30>
80005530:	4c f9       	lddpc	r9,8000566c <PcdComMF522+0x160>
80005532:	f2 08 07 01 	ld.ub	r1,r9[r8]
80005536:	4c f9       	lddpc	r9,80005670 <PcdComMF522+0x164>
80005538:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
8000553c:	02 9b       	mov	r11,r1
8000553e:	a7 bb       	sbr	r11,0x7
80005540:	30 2c       	mov	r12,2
80005542:	f0 1f 00 4d 	mcall	80005674 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80005546:	e0 6b 00 80 	mov	r11,128
8000554a:	30 4c       	mov	r12,4
8000554c:	f0 1f 00 4b 	mcall	80005678 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80005550:	30 0b       	mov	r11,0
80005552:	30 1c       	mov	r12,1
80005554:	f0 1f 00 48 	mcall	80005674 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80005558:	e0 6b 00 80 	mov	r11,128
8000555c:	30 ac       	mov	r12,10
8000555e:	f0 1f 00 48 	mcall	8000567c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80005562:	58 06       	cp.w	r6,0
80005564:	c0 c0       	breq	8000557c <PcdComMF522+0x70>
80005566:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80005568:	30 94       	mov	r4,9
8000556a:	0f 3b       	ld.ub	r11,r7++
8000556c:	08 9c       	mov	r12,r4
8000556e:	f0 1f 00 42 	mcall	80005674 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80005572:	0e 98       	mov	r8,r7
80005574:	0a 18       	sub	r8,r5
80005576:	ec 08 19 00 	cp.h	r8,r6
8000557a:	cf 83       	brcs	8000556a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
8000557c:	04 9b       	mov	r11,r2
8000557e:	30 1c       	mov	r12,1
80005580:	f0 1f 00 3d 	mcall	80005674 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80005584:	30 c8       	mov	r8,12
80005586:	f0 02 18 00 	cp.b	r2,r8
8000558a:	c0 61       	brne	80005596 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
8000558c:	e0 6b 00 80 	mov	r11,128
80005590:	30 dc       	mov	r12,13
80005592:	f0 1f 00 3b 	mcall	8000567c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80005596:	30 4c       	mov	r12,4
80005598:	f0 1f 00 3a 	mcall	80005680 <PcdComMF522+0x174>
8000559c:	18 97       	mov	r7,r12
8000559e:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800055a2:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800055a4:	30 44       	mov	r4,4
800055a6:	c0 88       	rjmp	800055b6 <PcdComMF522+0xaa>
800055a8:	08 9c       	mov	r12,r4
800055aa:	f0 1f 00 36 	mcall	80005680 <PcdComMF522+0x174>
800055ae:	18 97       	mov	r7,r12
		i--;
800055b0:	20 16       	sub	r6,1
800055b2:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800055b4:	c0 a0       	breq	800055c8 <PcdComMF522+0xbc>
800055b6:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800055ba:	c4 c1       	brne	80005652 <PcdComMF522+0x146>
800055bc:	ef e3 00 08 	and	r8,r7,r3
800055c0:	ea 08 18 00 	cp.b	r8,r5
800055c4:	cf 20       	breq	800055a8 <PcdComMF522+0x9c>
800055c6:	c4 68       	rjmp	80005652 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
800055c8:	e0 6b 00 80 	mov	r11,128
800055cc:	30 dc       	mov	r12,13
800055ce:	f0 1f 00 2b 	mcall	80005678 <PcdComMF522+0x16c>
800055d2:	30 27       	mov	r7,2
800055d4:	c3 38       	rjmp	8000563a <PcdComMF522+0x12e>
800055d6:	02 67       	and	r7,r1
800055d8:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
800055dc:	30 c8       	mov	r8,12
800055de:	f0 02 18 00 	cp.b	r2,r8
800055e2:	c2 c1       	brne	8000563a <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
800055e4:	30 ac       	mov	r12,10
800055e6:	f0 1f 00 27 	mcall	80005680 <PcdComMF522+0x174>
800055ea:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
800055ec:	30 cc       	mov	r12,12
800055ee:	f0 1f 00 25 	mcall	80005680 <PcdComMF522+0x174>
800055f2:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
800055f6:	c0 70       	breq	80005604 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
800055f8:	08 98       	mov	r8,r4
800055fa:	20 18       	sub	r8,1
800055fc:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80005600:	a0 8c       	st.b	r0[0x0],r12
80005602:	c0 48       	rjmp	8000560a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80005604:	e8 08 15 03 	lsl	r8,r4,0x3
80005608:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
8000560a:	58 04       	cp.w	r4,0
8000560c:	c0 61       	brne	80005618 <PcdComMF522+0x10c>
8000560e:	30 14       	mov	r4,1
80005610:	40 05       	lddsp	r5,sp[0x0]
80005612:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005614:	30 93       	mov	r3,9
80005616:	c0 98       	rjmp	80005628 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80005618:	31 28       	mov	r8,18
8000561a:	f0 04 18 00 	cp.b	r4,r8
8000561e:	f9 b4 0b 12 	movhi	r4,18
80005622:	58 04       	cp.w	r4,0
80005624:	cf 61       	brne	80005610 <PcdComMF522+0x104>
80005626:	c0 a8       	rjmp	8000563a <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005628:	06 9c       	mov	r12,r3
8000562a:	f0 1f 00 16 	mcall	80005680 <PcdComMF522+0x174>
8000562e:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80005630:	ec 05 01 08 	sub	r8,r6,r5
80005634:	e8 08 19 00 	cp.h	r8,r4
80005638:	cf 83       	brcs	80005628 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
8000563a:	e0 6b 00 80 	mov	r11,128
8000563e:	30 cc       	mov	r12,12
80005640:	f0 1f 00 0f 	mcall	8000567c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80005644:	30 0b       	mov	r11,0
80005646:	30 1c       	mov	r12,1
80005648:	f0 1f 00 0b 	mcall	80005674 <PcdComMF522+0x168>
	return status;
}
8000564c:	0e 9c       	mov	r12,r7
8000564e:	2f fd       	sub	sp,-4
80005650:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80005652:	e0 6b 00 80 	mov	r11,128
80005656:	30 dc       	mov	r12,13
80005658:	f0 1f 00 08 	mcall	80005678 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
8000565c:	30 6c       	mov	r12,6
8000565e:	f0 1f 00 09 	mcall	80005680 <PcdComMF522+0x174>
80005662:	e2 1c 00 1b 	andl	r12,0x1b,COH
80005666:	cb 80       	breq	800055d6 <PcdComMF522+0xca>
80005668:	30 27       	mov	r7,2
8000566a:	ce 8b       	rjmp	8000563a <PcdComMF522+0x12e>
8000566c:	80 00       	ld.sh	r0,r0[0x0]
8000566e:	e9 c4 80 00 	stm	r4,pc
80005672:	e9 c8 80 00 	stm	r8,pc
80005676:	52 08       	stdsp	sp[0x80],r8
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	53 b0       	stdsp	sp[0xec],r0
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	53 6c       	stdsp	sp[0xd8],r12
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	52 c8       	stdsp	sp[0xb0],r8

80005684 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80005684:	eb cd 40 c0 	pushm	r6-r7,lr
80005688:	20 5d       	sub	sp,20
8000568a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
8000568c:	30 8b       	mov	r11,8
8000568e:	16 9c       	mov	r12,r11
80005690:	f0 1f 00 1a 	mcall	800056f8 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80005694:	30 0b       	mov	r11,0
80005696:	30 dc       	mov	r12,13
80005698:	f0 1f 00 19 	mcall	800056fc <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
8000569c:	e0 6b 00 80 	mov	r11,128
800056a0:	30 ec       	mov	r12,14
800056a2:	f0 1f 00 16 	mcall	800056f8 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800056a6:	39 38       	mov	r8,-109
800056a8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
800056aa:	32 08       	mov	r8,32
800056ac:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
800056ae:	1a 9b       	mov	r11,sp
800056b0:	fa c8 ff ed 	sub	r8,sp,-19
800056b4:	1a 99       	mov	r9,sp
800056b6:	30 2a       	mov	r10,2
800056b8:	30 cc       	mov	r12,12
800056ba:	f0 1f 00 12 	mcall	80005700 <PcdAnticoll+0x7c>
800056be:	18 97       	mov	r7,r12

	if (status == MI_OK)
800056c0:	c1 21       	brne	800056e4 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056c2:	1b 89       	ld.ub	r9,sp[0x0]
800056c4:	ac 89       	st.b	r6[0x0],r9
800056c6:	1b 98       	ld.ub	r8,sp[0x1]
800056c8:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
800056ca:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056cc:	1b a8       	ld.ub	r8,sp[0x2]
800056ce:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
800056d0:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800056d4:	1b b9       	ld.ub	r9,sp[0x3]
800056d6:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
800056d8:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
800056da:	1b c9       	ld.ub	r9,sp[0x4]
800056dc:	f0 09 18 00 	cp.b	r9,r8
800056e0:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
800056e4:	e0 6b 00 80 	mov	r11,128
800056e8:	30 ec       	mov	r12,14
800056ea:	f0 1f 00 07 	mcall	80005704 <PcdAnticoll+0x80>
	return status;
}
800056ee:	0e 9c       	mov	r12,r7
800056f0:	2f bd       	sub	sp,-20
800056f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056f6:	00 00       	add	r0,r0
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	53 b0       	stdsp	sp[0xec],r0
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	52 08       	stdsp	sp[0x80],r8
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	55 0c       	stdsp	sp[0x140],r12
80005704:	80 00       	ld.sh	r0,r0[0x0]
80005706:	53 6c       	stdsp	sp[0xd8],r12

80005708 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80005708:	eb cd 40 c0 	pushm	r6-r7,lr
8000570c:	20 5d       	sub	sp,20
8000570e:	18 97       	mov	r7,r12
80005710:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80005712:	30 8b       	mov	r11,8
80005714:	16 9c       	mov	r12,r11
80005716:	f0 1f 00 12 	mcall	8000575c <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
8000571a:	30 7b       	mov	r11,7
8000571c:	30 dc       	mov	r12,13
8000571e:	f0 1f 00 11 	mcall	80005760 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80005722:	30 3b       	mov	r11,3
80005724:	31 4c       	mov	r12,20
80005726:	f0 1f 00 10 	mcall	80005764 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
8000572a:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
8000572c:	1a 9b       	mov	r11,sp
8000572e:	fa c8 ff ed 	sub	r8,sp,-19
80005732:	1a 99       	mov	r9,sp
80005734:	30 1a       	mov	r10,1
80005736:	30 cc       	mov	r12,12
80005738:	f0 1f 00 0c 	mcall	80005768 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
8000573c:	c0 c1       	brne	80005754 <PcdRequest+0x4c>
8000573e:	31 08       	mov	r8,16
80005740:	fb 39 00 13 	ld.ub	r9,sp[19]
80005744:	f0 09 18 00 	cp.b	r9,r8
80005748:	c0 61       	brne	80005754 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
8000574a:	1b 88       	ld.ub	r8,sp[0x0]
8000574c:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
8000574e:	1b 98       	ld.ub	r8,sp[0x1]
80005750:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80005752:	c0 28       	rjmp	80005756 <PcdRequest+0x4e>
80005754:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80005756:	2f bd       	sub	sp,-20
80005758:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	53 b0       	stdsp	sp[0xec],r0
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	52 08       	stdsp	sp[0x80],r8
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	53 6c       	stdsp	sp[0xd8],r12
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	55 0c       	stdsp	sp[0x140],r12

8000576c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
8000576c:	eb cd 40 f8 	pushm	r3-r7,lr
80005770:	18 95       	mov	r5,r12
80005772:	16 96       	mov	r6,r11
80005774:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80005776:	30 4b       	mov	r11,4
80005778:	30 5c       	mov	r12,5
8000577a:	f0 1f 00 1c 	mcall	800057e8 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000577e:	30 0b       	mov	r11,0
80005780:	30 1c       	mov	r12,1
80005782:	f0 1f 00 1b 	mcall	800057ec <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80005786:	e0 6b 00 80 	mov	r11,128
8000578a:	30 ac       	mov	r12,10
8000578c:	f0 1f 00 19 	mcall	800057f0 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80005790:	58 06       	cp.w	r6,0
80005792:	c0 c0       	breq	800057aa <CalulateCRC+0x3e>
80005794:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80005796:	30 94       	mov	r4,9
80005798:	0f 3b       	ld.ub	r11,r7++
8000579a:	08 9c       	mov	r12,r4
8000579c:	f0 1f 00 14 	mcall	800057ec <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
800057a0:	0e 98       	mov	r8,r7
800057a2:	0a 18       	sub	r8,r5
800057a4:	ec 08 18 00 	cp.b	r8,r6
800057a8:	cf 83       	brcs	80005798 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
800057aa:	30 3b       	mov	r11,3
800057ac:	30 1c       	mov	r12,1
800057ae:	f0 1f 00 10 	mcall	800057ec <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
800057b2:	30 5c       	mov	r12,5
800057b4:	f0 1f 00 10 	mcall	800057f4 <CalulateCRC+0x88>
800057b8:	e0 67 00 fe 	mov	r7,254
800057bc:	30 56       	mov	r6,5
800057be:	c0 78       	rjmp	800057cc <CalulateCRC+0x60>
800057c0:	0c 9c       	mov	r12,r6
800057c2:	f0 1f 00 0d 	mcall	800057f4 <CalulateCRC+0x88>
		i--;
800057c6:	20 17       	sub	r7,1
800057c8:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
800057ca:	c0 40       	breq	800057d2 <CalulateCRC+0x66>
800057cc:	e2 1c 00 04 	andl	r12,0x4,COH
800057d0:	cf 80       	breq	800057c0 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
800057d2:	32 2c       	mov	r12,34
800057d4:	f0 1f 00 08 	mcall	800057f4 <CalulateCRC+0x88>
800057d8:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
800057da:	32 1c       	mov	r12,33
800057dc:	f0 1f 00 06 	mcall	800057f4 <CalulateCRC+0x88>
800057e0:	a6 9c       	st.b	r3[0x1],r12
}
800057e2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800057e6:	00 00       	add	r0,r0
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	53 b0       	stdsp	sp[0xec],r0
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	52 08       	stdsp	sp[0x80],r8
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	53 6c       	stdsp	sp[0xd8],r12
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	52 c8       	stdsp	sp[0xb0],r8

800057f8 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
800057f8:	eb cd 40 80 	pushm	r7,lr
800057fc:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800057fe:	39 38       	mov	r8,-109
80005800:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80005802:	37 08       	mov	r8,112
80005804:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80005806:	30 08       	mov	r8,0
80005808:	ba e8       	st.b	sp[0x6],r8
8000580a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000580e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80005812:	19 89       	ld.ub	r9,r12[0x0]
80005814:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80005816:	19 3a       	ld.ub	r10,r12++
80005818:	1b e9       	ld.ub	r9,sp[0x6]
8000581a:	f5 e9 20 09 	eor	r9,r10,r9
8000581e:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80005820:	16 38       	cp.w	r8,r11
80005822:	cf 81       	brne	80005812 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80005824:	1a 97       	mov	r7,sp
80005826:	fa ca ff f9 	sub	r10,sp,-7
8000582a:	30 7b       	mov	r11,7
8000582c:	1a 9c       	mov	r12,sp
8000582e:	f0 1f 00 0d 	mcall	80005860 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80005832:	30 8b       	mov	r11,8
80005834:	16 9c       	mov	r12,r11
80005836:	f0 1f 00 0c 	mcall	80005864 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
8000583a:	fa c8 ff ed 	sub	r8,sp,-19
8000583e:	1a 99       	mov	r9,sp
80005840:	30 9a       	mov	r10,9
80005842:	1a 9b       	mov	r11,sp
80005844:	30 cc       	mov	r12,12
80005846:	f0 1f 00 09 	mcall	80005868 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
8000584a:	c0 71       	brne	80005858 <PcdSelect+0x60>
8000584c:	31 88       	mov	r8,24
8000584e:	fb 39 00 13 	ld.ub	r9,sp[19]
80005852:	f0 09 18 00 	cp.b	r9,r8
80005856:	c0 20       	breq	8000585a <PcdSelect+0x62>
80005858:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
8000585a:	2f bd       	sub	sp,-20
8000585c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	57 6c       	stdsp	sp[0x1d8],r12
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	53 b0       	stdsp	sp[0xec],r0
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	55 0c       	stdsp	sp[0x140],r12

8000586c <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
8000586c:	eb cd 40 c0 	pushm	r6-r7,lr
80005870:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80005872:	f0 1f 00 37 	mcall	8000594c <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80005876:	4b 7b       	lddpc	r11,80005950 <rfid_auto_reader+0xe4>
80005878:	35 2c       	mov	r12,82
8000587a:	f0 1f 00 37 	mcall	80005954 <rfid_auto_reader+0xe8>
8000587e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80005880:	c6 31       	brne	80005946 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005882:	4b 48       	lddpc	r8,80005950 <rfid_auto_reader+0xe4>
80005884:	11 88       	ld.ub	r8,r8[0x0]
80005886:	30 49       	mov	r9,4
80005888:	f2 08 18 00 	cp.b	r8,r9
8000588c:	c0 b1       	brne	800058a2 <rfid_auto_reader+0x36>
8000588e:	4b 19       	lddpc	r9,80005950 <rfid_auto_reader+0xe4>
80005890:	13 9a       	ld.ub	r10,r9[0x1]
80005892:	30 09       	mov	r9,0
80005894:	f2 0a 18 00 	cp.b	r10,r9
80005898:	c0 51       	brne	800058a2 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
8000589a:	4b 0c       	lddpc	r12,80005958 <rfid_auto_reader+0xec>
8000589c:	f0 1f 00 30 	mcall	8000595c <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800058a0:	c3 c8       	rjmp	80005918 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800058a2:	30 29       	mov	r9,2
800058a4:	f2 08 18 00 	cp.b	r8,r9
800058a8:	c0 b1       	brne	800058be <rfid_auto_reader+0x52>
800058aa:	4a a9       	lddpc	r9,80005950 <rfid_auto_reader+0xe4>
800058ac:	13 9a       	ld.ub	r10,r9[0x1]
800058ae:	30 09       	mov	r9,0
800058b0:	f2 0a 18 00 	cp.b	r10,r9
800058b4:	c0 51       	brne	800058be <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
800058b6:	4a bc       	lddpc	r12,80005960 <rfid_auto_reader+0xf4>
800058b8:	f0 1f 00 29 	mcall	8000595c <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800058bc:	c2 e8       	rjmp	80005918 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800058be:	34 49       	mov	r9,68
800058c0:	f2 08 18 00 	cp.b	r8,r9
800058c4:	c0 b1       	brne	800058da <rfid_auto_reader+0x6e>
800058c6:	4a 39       	lddpc	r9,80005950 <rfid_auto_reader+0xe4>
800058c8:	13 9a       	ld.ub	r10,r9[0x1]
800058ca:	30 09       	mov	r9,0
800058cc:	f2 0a 18 00 	cp.b	r10,r9
800058d0:	c0 51       	brne	800058da <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
800058d2:	4a 5c       	lddpc	r12,80005964 <rfid_auto_reader+0xf8>
800058d4:	f0 1f 00 22 	mcall	8000595c <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800058d8:	c2 08       	rjmp	80005918 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800058da:	30 89       	mov	r9,8
800058dc:	f2 08 18 00 	cp.b	r8,r9
800058e0:	c0 b1       	brne	800058f6 <rfid_auto_reader+0x8a>
800058e2:	49 c9       	lddpc	r9,80005950 <rfid_auto_reader+0xe4>
800058e4:	13 9a       	ld.ub	r10,r9[0x1]
800058e6:	30 09       	mov	r9,0
800058e8:	f2 0a 18 00 	cp.b	r10,r9
800058ec:	c0 51       	brne	800058f6 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
800058ee:	49 fc       	lddpc	r12,80005968 <rfid_auto_reader+0xfc>
800058f0:	f0 1f 00 1b 	mcall	8000595c <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800058f4:	c1 28       	rjmp	80005918 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
800058f6:	34 49       	mov	r9,68
800058f8:	f2 08 18 00 	cp.b	r8,r9
800058fc:	c0 b1       	brne	80005912 <rfid_auto_reader+0xa6>
800058fe:	49 58       	lddpc	r8,80005950 <rfid_auto_reader+0xe4>
80005900:	11 99       	ld.ub	r9,r8[0x1]
80005902:	30 38       	mov	r8,3
80005904:	f0 09 18 00 	cp.b	r9,r8
80005908:	c0 51       	brne	80005912 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000590a:	49 9c       	lddpc	r12,8000596c <rfid_auto_reader+0x100>
8000590c:	f0 1f 00 14 	mcall	8000595c <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005910:	c0 48       	rjmp	80005918 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005912:	49 8c       	lddpc	r12,80005970 <rfid_auto_reader+0x104>
80005914:	f0 1f 00 12 	mcall	8000595c <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005918:	49 7c       	lddpc	r12,80005974 <rfid_auto_reader+0x108>
8000591a:	f0 1f 00 18 	mcall	80005978 <rfid_auto_reader+0x10c>
8000591e:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005920:	c0 60       	breq	8000592c <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
80005922:	34 fb       	mov	r11,79
80005924:	30 1c       	mov	r12,1
80005926:	f0 1f 00 16 	mcall	8000597c <rfid_auto_reader+0x110>
		return status;
8000592a:	c0 e8       	rjmp	80005946 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
8000592c:	49 2c       	lddpc	r12,80005974 <rfid_auto_reader+0x108>
8000592e:	f0 1f 00 15 	mcall	80005980 <rfid_auto_reader+0x114>
80005932:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005934:	c0 91       	brne	80005946 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80005936:	30 4a       	mov	r10,4
80005938:	48 fb       	lddpc	r11,80005974 <rfid_auto_reader+0x108>
8000593a:	0c 9c       	mov	r12,r6
8000593c:	f0 1f 00 12 	mcall	80005984 <rfid_auto_reader+0x118>
		log("select okay\n");
80005940:	49 2c       	lddpc	r12,80005988 <rfid_auto_reader+0x11c>
80005942:	f0 1f 00 07 	mcall	8000595c <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80005946:	0e 9c       	mov	r12,r7
80005948:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	52 48       	stdsp	sp[0x90],r8
80005950:	00 00       	add	r0,r0
80005952:	97 b4       	st.w	r11[0x2c],r4
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	57 08       	stdsp	sp[0x1c0],r8
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	e9 e4 80 00 	sthh.w	r0[r0],r4:b,r4:b
8000595e:	7f 54       	ld.w	r4,pc[0x54]
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	e9 f0 80 00 	ld.wls	r0,r4[0x0]
80005966:	e9 fc 80 00 	ld.wls	r12,r4[0x0]
8000596a:	ea 0c       	*unknown*
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	ea 14 80 00 	orh	r4,0x8000
80005972:	ea 20 00 00 	sub	r0,655360
80005976:	97 b8       	st.w	r11[0x2c],r8
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	56 84       	stdsp	sp[0x1a0],r4
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	49 9c       	lddpc	r12,800059e0 <scan_rfid_save_message+0x4>
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	57 f8       	stdsp	sp[0x1fc],r8
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	87 fe       	st.w	r3[0x3c],lr
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	ea 2c eb cd 	sub	r12,715725

8000598c <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
8000598c:	eb cd 40 80 	pushm	r7,lr
80005990:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005992:	f0 1f 00 0d 	mcall	800059c4 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80005996:	30 0c       	mov	r12,0
80005998:	f0 1f 00 0c 	mcall	800059c8 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
8000599c:	0e 9c       	mov	r12,r7
8000599e:	f0 1f 00 0c 	mcall	800059cc <scan_patrol+0x40>
800059a2:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
800059a4:	30 1c       	mov	r12,1
800059a6:	f0 1f 00 09 	mcall	800059c8 <scan_patrol+0x3c>
	if(return_err == 0)
800059aa:	58 07       	cp.w	r7,0
800059ac:	c0 51       	brne	800059b6 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
800059ae:	48 9c       	lddpc	r12,800059d0 <scan_patrol+0x44>
800059b0:	f0 1f 00 09 	mcall	800059d4 <scan_patrol+0x48>
800059b4:	c0 48       	rjmp	800059bc <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
800059b6:	48 9c       	lddpc	r12,800059d8 <scan_patrol+0x4c>
800059b8:	f0 1f 00 07 	mcall	800059d4 <scan_patrol+0x48>
		
	return return_err;

}
800059bc:	0e 9c       	mov	r12,r7
800059be:	e3 cd 80 80 	ldm	sp++,r7,pc
800059c2:	00 00       	add	r0,r0
800059c4:	80 00       	ld.sh	r0,r0[0x0]
800059c6:	52 48       	stdsp	sp[0x90],r8
800059c8:	80 00       	ld.sh	r0,r0[0x0]
800059ca:	53 20       	stdsp	sp[0xc8],r0
800059cc:	80 00       	ld.sh	r0,r0[0x0]
800059ce:	58 6c       	cp.w	r12,6
800059d0:	80 00       	ld.sh	r0,r0[0x0]
800059d2:	ea 3c 80 00 	sub	r12,753664
800059d6:	7f 54       	ld.w	r4,pc[0x54]
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	ea 50 eb cd 	cp.w	r0,781261

800059dc <scan_rfid_save_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
{
800059dc:	eb cd 40 e0 	pushm	r5-r7,lr
800059e0:	21 dd       	sub	sp,116
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
800059e2:	4e 9c       	lddpc	r12,80005b84 <scan_rfid_save_message+0x1a8>
800059e4:	30 08       	mov	r8,0
800059e6:	30 09       	mov	r9,0
800059e8:	f8 e9 00 00 	st.d	r12[0],r8
800059ec:	30 0a       	mov	r10,0
800059ee:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800059f0:	fa e9 00 24 	st.d	sp[36],r8
800059f4:	fa e9 00 2c 	st.d	sp[44],r8
800059f8:	fa e9 00 34 	st.d	sp[52],r8
800059fc:	fa e9 00 3c 	st.d	sp[60],r8
80005a00:	fa e9 00 44 	st.d	sp[68],r8
80005a04:	fa e9 00 4c 	st.d	sp[76],r8
80005a08:	fa e9 00 54 	st.d	sp[84],r8
80005a0c:	fa e9 00 5c 	st.d	sp[92],r8
80005a10:	fa e9 00 64 	st.d	sp[100],r8
80005a14:	fa e9 00 6c 	st.d	sp[108],r8
	
	return_err = scan_patrol(SN);
80005a18:	f0 1f 00 5c 	mcall	80005b88 <scan_rfid_save_message+0x1ac>
80005a1c:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005a1e:	e0 81 00 a7 	brne	80005b6c <scan_rfid_save_message+0x190>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005a22:	4d 96       	lddpc	r6,80005b84 <scan_rfid_save_message+0x1a8>
80005a24:	0d b8       	ld.ub	r8,r6[0x3]
80005a26:	1a d8       	st.w	--sp,r8
80005a28:	0d a8       	ld.ub	r8,r6[0x2]
80005a2a:	1a d8       	st.w	--sp,r8
80005a2c:	0d 98       	ld.ub	r8,r6[0x1]
80005a2e:	1a d8       	st.w	--sp,r8
80005a30:	0d 88       	ld.ub	r8,r6[0x0]
80005a32:	1a d8       	st.w	--sp,r8
80005a34:	4d 6c       	lddpc	r12,80005b8c <scan_rfid_save_message+0x1b0>
80005a36:	f0 1f 00 57 	mcall	80005b90 <scan_rfid_save_message+0x1b4>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
80005a3a:	34 4b       	mov	r11,68
80005a3c:	30 1c       	mov	r12,1
80005a3e:	f0 1f 00 56 	mcall	80005b94 <scan_rfid_save_message+0x1b8>
80005a42:	fa c8 ff ec 	sub	r8,sp,-20
80005a46:	fa c9 ff ea 	sub	r9,sp,-22
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
80005a4a:	ec c5 ff fc 	sub	r5,r6,-4
80005a4e:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005a50:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005a52:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005a54:	0d 8a       	ld.ub	r10,r6[0x0]
80005a56:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005a5a:	fc 0b 18 00 	cp.b	r11,lr
80005a5e:	f7 bb 08 d0 	subls	r11,-48
80005a62:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005a66:	f7 bb 0b a9 	subhi	r11,-87
80005a6a:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005a6e:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005a70:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005a74:	fc 0a 18 00 	cp.b	r10,lr
80005a78:	f7 ba 08 d0 	subls	r10,-48
80005a7c:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005a80:	f7 ba 0b a9 	subhi	r10,-87
80005a84:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005a88:	b0 bc       	st.b	r8[0x3],r12
80005a8a:	2f f6       	sub	r6,-1
80005a8c:	2f c8       	sub	r8,-4
80005a8e:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005a90:	0a 36       	cp.w	r6,r5
80005a92:	ce 11       	brne	80005a54 <scan_rfid_save_message+0x78>
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			data_buffer.RFID_ID[i*4+3] = 0x00;
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005a94:	30 6a       	mov	r10,6
80005a96:	4c 1b       	lddpc	r11,80005b98 <scan_rfid_save_message+0x1bc>
80005a98:	fa cc ff ec 	sub	r12,sp,-20
80005a9c:	f0 1f 00 40 	mcall	80005b9c <scan_rfid_save_message+0x1c0>
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80005aa0:	4c 08       	lddpc	r8,80005ba0 <scan_rfid_save_message+0x1c4>
80005aa2:	11 89       	ld.ub	r9,r8[0x0]
80005aa4:	39 f8       	mov	r8,-97
80005aa6:	f0 09 18 00 	cp.b	r9,r8
80005aaa:	e0 88 00 05 	brls	80005ab4 <scan_rfid_save_message+0xd8>
80005aae:	38 09       	mov	r9,-128
80005ab0:	4b c8       	lddpc	r8,80005ba0 <scan_rfid_save_message+0x1c4>
80005ab2:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80005ab4:	4b b8       	lddpc	r8,80005ba0 <scan_rfid_save_message+0x1c4>
80005ab6:	11 86       	ld.ub	r6,r8[0x0]
80005ab8:	2f f6       	sub	r6,-1
80005aba:	5c 56       	castu.b	r6
80005abc:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005abe:	30 5a       	mov	r10,5
80005ac0:	4b 9b       	lddpc	r11,80005ba4 <scan_rfid_save_message+0x1c8>
80005ac2:	fa cc ff e1 	sub	r12,sp,-31
80005ac6:	f0 1f 00 36 	mcall	80005b9c <scan_rfid_save_message+0x1c0>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005aca:	31 e8       	mov	r8,30
80005acc:	fb 58 00 1a 	st.h	sp[26],r8
80005ad0:	fb 66 00 1e 	st.b	sp[30],r6
80005ad4:	fe 78 e0 00 	mov	r8,-8192
80005ad8:	fb 58 00 1c 	st.h	sp[28],r8
80005adc:	30 aa       	mov	r10,10
80005ade:	fa cb ff e6 	sub	r11,sp,-26
80005ae2:	fa cc ff dc 	sub	r12,sp,-36
80005ae6:	f0 1f 00 2e 	mcall	80005b9c <scan_rfid_save_message+0x1c0>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005aea:	31 6a       	mov	r10,22
80005aec:	fa cb ff fc 	sub	r11,sp,-4
80005af0:	fa cc ff d2 	sub	r12,sp,-46
80005af4:	f0 1f 00 2a 	mcall	80005b9c <scan_rfid_save_message+0x1c0>
		
		//xgflash_message_save(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), TRUE);
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t * myptr = get_message_store();
80005af8:	4a c8       	lddpc	r8,80005ba8 <scan_rfid_save_message+0x1cc>
80005afa:	70 0c       	ld.w	r12,r8[0x0]
80005afc:	f0 1f 00 2c 	mcall	80005bac <scan_rfid_save_message+0x1d0>
80005b00:	50 0c       	stdsp	sp[0x0],r12
		if(NULL != myptr)
80005b02:	c3 10       	breq	80005b64 <scan_rfid_save_message+0x188>
		{
			memcpy(myptr, message, sizeof(Message_Protocol_t));
80005b04:	32 0a       	mov	r10,32
80005b06:	fa cb ff dc 	sub	r11,sp,-36
80005b0a:	f0 1f 00 25 	mcall	80005b9c <scan_rfid_save_message+0x1c0>
			//xQueueSend(xg_resend_queue, &myptr, 0);
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005b0e:	4a 98       	lddpc	r8,80005bb0 <scan_rfid_save_message+0x1d4>
80005b10:	70 0c       	ld.w	r12,r8[0x0]
80005b12:	30 09       	mov	r9,0
80005b14:	12 9a       	mov	r10,r9
80005b16:	1a 9b       	mov	r11,sp
80005b18:	f0 1f 00 27 	mcall	80005bb4 <scan_rfid_save_message+0x1d8>
80005b1c:	58 1c       	cp.w	r12,1
80005b1e:	c1 10       	breq	80005b40 <scan_rfid_save_message+0x164>
			{
				log("xg_resend_queue: full\n" );
80005b20:	4a 6c       	lddpc	r12,80005bb8 <scan_rfid_save_message+0x1dc>
80005b22:	f0 1f 00 1c 	mcall	80005b90 <scan_rfid_save_message+0x1b4>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80005b26:	32 3b       	mov	r11,35
80005b28:	30 1c       	mov	r12,1
80005b2a:	f0 1f 00 1b 	mcall	80005b94 <scan_rfid_save_message+0x1b8>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
80005b2e:	e0 6c 17 70 	mov	r12,6000
80005b32:	f0 1f 00 23 	mcall	80005bbc <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80005b36:	32 3b       	mov	r11,35
80005b38:	30 0c       	mov	r12,0
80005b3a:	f0 1f 00 17 	mcall	80005b94 <scan_rfid_save_message+0x1b8>
80005b3e:	c1 e8       	rjmp	80005b7a <scan_rfid_save_message+0x19e>
			}
			else
			{
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005b40:	4a 06       	lddpc	r6,80005bc0 <scan_rfid_save_message+0x1e4>
80005b42:	6c 0c       	ld.w	r12,r6[0x0]
80005b44:	30 09       	mov	r9,0
80005b46:	3f fa       	mov	r10,-1
80005b48:	12 9b       	mov	r11,r9
80005b4a:	f0 1f 00 1f 	mcall	80005bc4 <scan_rfid_save_message+0x1e8>
				global_count++;
80005b4e:	49 f8       	lddpc	r8,80005bc8 <scan_rfid_save_message+0x1ec>
80005b50:	70 09       	ld.w	r9,r8[0x0]
80005b52:	2f f9       	sub	r9,-1
80005b54:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
80005b56:	6c 0c       	ld.w	r12,r6[0x0]
80005b58:	30 09       	mov	r9,0
80005b5a:	12 9a       	mov	r10,r9
80005b5c:	12 9b       	mov	r11,r9
80005b5e:	f0 1f 00 16 	mcall	80005bb4 <scan_rfid_save_message+0x1d8>
80005b62:	c0 c8       	rjmp	80005b7a <scan_rfid_save_message+0x19e>
			}
		}
		else
		{
			log("myptr: err\n\r" );
80005b64:	49 ac       	lddpc	r12,80005bcc <scan_rfid_save_message+0x1f0>
80005b66:	f0 1f 00 0b 	mcall	80005b90 <scan_rfid_save_message+0x1b4>
80005b6a:	c0 88       	rjmp	80005b7a <scan_rfid_save_message+0x19e>
		
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005b6c:	34 fb       	mov	r11,79
80005b6e:	30 1c       	mov	r12,1
80005b70:	f0 1f 00 09 	mcall	80005b94 <scan_rfid_save_message+0x1b8>
		log("no card find...\n");
80005b74:	49 7c       	lddpc	r12,80005bd0 <scan_rfid_save_message+0x1f4>
80005b76:	f0 1f 00 07 	mcall	80005b90 <scan_rfid_save_message+0x1b4>
	}
	
	return return_err;
	

}
80005b7a:	0e 9c       	mov	r12,r7
80005b7c:	2e 3d       	sub	sp,-116
80005b7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b82:	00 00       	add	r0,r0
80005b84:	00 00       	add	r0,r0
80005b86:	0b 88       	ld.ub	r8,r5[0x0]
80005b88:	80 00       	ld.sh	r0,r0[0x0]
80005b8a:	59 8c       	cp.w	r12,24
80005b8c:	80 00       	ld.sh	r0,r0[0x0]
80005b8e:	ea 64 80 00 	mov	r4,688128
80005b92:	7f 54       	ld.w	r4,pc[0x54]
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	49 9c       	lddpc	r12,80005bf8 <delay_us>
80005b98:	00 00       	add	r0,r0
80005b9a:	0e 24       	rsub	r4,r7
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	87 fe       	st.w	r3[0x3c],lr
80005ba0:	00 00       	add	r0,r0
80005ba2:	05 3c       	ld.ub	r12,r2++
80005ba4:	00 00       	add	r0,r0
80005ba6:	05 34       	ld.ub	r4,r2++
80005ba8:	00 00       	add	r0,r0
80005baa:	0b a0       	ld.ub	r0,r5[0x2]
80005bac:	80 00       	ld.sh	r0,r0[0x0]
80005bae:	36 e0       	mov	r0,110
80005bb0:	00 00       	add	r0,r0
80005bb2:	0b 94       	ld.ub	r4,r5[0x1]
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	73 1c       	ld.w	r12,r9[0x44]
80005bb8:	80 00       	ld.sh	r0,r0[0x0]
80005bba:	e8 8c 80 00 	brvs	80115bba <_data_lma+0x106592>
80005bbe:	79 e8       	ld.w	r8,r12[0x78]
80005bc0:	00 00       	add	r0,r0
80005bc2:	0a 78       	tst	r8,r5
80005bc4:	80 00       	ld.sh	r0,r0[0x0]
80005bc6:	71 10       	ld.w	r0,r8[0x44]
80005bc8:	00 00       	add	r0,r0
80005bca:	0a 84       	andn	r4,r5
80005bcc:	80 00       	ld.sh	r0,r0[0x0]
80005bce:	e8 a4       	*unknown*
80005bd0:	80 00       	ld.sh	r0,r0[0x0]
80005bd2:	ea 80 d4 01 	breq	801603d4 <_data_lma+0x150dac>

80005bd4 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
80005bd4:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80005bd6:	f0 1f 00 02 	mcall	80005bdc <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005bda:	d8 02       	popm	pc
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	54 58       	stdsp	sp[0x114],r8

80005be0 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005be0:	58 0c       	cp.w	r12,0
80005be2:	5e 0c       	reteq	r12
80005be4:	30 08       	mov	r8,0
	{
		nop();
80005be6:	d7 03       	nop
		nop();
80005be8:	d7 03       	nop
		nop();
80005bea:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005bec:	2f f8       	sub	r8,-1
80005bee:	10 3c       	cp.w	r12,r8
80005bf0:	fe 9b ff fb 	brhi	80005be6 <delay_ns+0x6>
80005bf4:	5e fc       	retal	r12
80005bf6:	d7 03       	nop

80005bf8 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005bf8:	eb cd 40 e0 	pushm	r5-r7,lr
80005bfc:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005bfe:	58 0c       	cp.w	r12,0
80005c00:	c0 b0       	breq	80005c16 <delay_us+0x1e>
80005c02:	30 07       	mov	r7,0
		delay_ns(1000);
80005c04:	e0 65 03 e8 	mov	r5,1000
80005c08:	0a 9c       	mov	r12,r5
80005c0a:	f0 1f 00 05 	mcall	80005c1c <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005c0e:	2f f7       	sub	r7,-1
80005c10:	0e 36       	cp.w	r6,r7
80005c12:	fe 9b ff fb 	brhi	80005c08 <delay_us+0x10>
80005c16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c1a:	00 00       	add	r0,r0
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	5b e0       	cp.w	r0,-2

80005c20 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005c20:	eb cd 40 e0 	pushm	r5-r7,lr
80005c24:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005c26:	58 0c       	cp.w	r12,0
80005c28:	c0 b0       	breq	80005c3e <delay_ms+0x1e>
80005c2a:	30 07       	mov	r7,0
		delay_us(1000);
80005c2c:	e0 65 03 e8 	mov	r5,1000
80005c30:	0a 9c       	mov	r12,r5
80005c32:	f0 1f 00 05 	mcall	80005c44 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005c36:	2f f7       	sub	r7,-1
80005c38:	0e 36       	cp.w	r6,r7
80005c3a:	fe 9b ff fb 	brhi	80005c30 <delay_ms+0x10>
80005c3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c42:	00 00       	add	r0,r0
80005c44:	80 00       	ld.sh	r0,r0[0x0]
80005c46:	5b f8       	cp.w	r8,-1

80005c48 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005c48:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005c4a:	30 3b       	mov	r11,3
80005c4c:	48 8c       	lddpc	r12,80005c6c <local_start_timer+0x24>
80005c4e:	f0 1f 00 09 	mcall	80005c70 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005c52:	fe 78 38 00 	mov	r8,-51200
80005c56:	e0 69 91 0d 	mov	r9,37133
80005c5a:	ea 19 00 52 	orh	r9,0x52
80005c5e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005c60:	32 09       	mov	r9,32
80005c62:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005c64:	30 59       	mov	r9,5
80005c66:	91 09       	st.w	r8[0x0],r9
}
80005c68:	d8 02       	popm	pc
80005c6a:	00 00       	add	r0,r0
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	ea 94 80 00 	brge	80175c6e <_data_lma+0x166646>
80005c72:	63 38       	ld.w	r8,r1[0x4c]

80005c74 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005c74:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005c76:	30 3a       	mov	r10,3
80005c78:	e0 6b 1b 00 	mov	r11,6912
80005c7c:	ea 1b 00 b7 	orh	r11,0xb7
80005c80:	fe 7c 0c 00 	mov	r12,-62464
80005c84:	f0 1f 00 19 	mcall	80005ce8 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005c88:	31 08       	mov	r8,16
80005c8a:	1a d8       	st.w	--sp,r8
80005c8c:	30 08       	mov	r8,0
80005c8e:	30 19       	mov	r9,1
80005c90:	30 7a       	mov	r10,7
80005c92:	10 9b       	mov	r11,r8
80005c94:	fe 7c 0c 00 	mov	r12,-62464
80005c98:	f0 1f 00 15 	mcall	80005cec <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005c9c:	30 08       	mov	r8,0
80005c9e:	30 19       	mov	r9,1
80005ca0:	12 9a       	mov	r10,r9
80005ca2:	10 9b       	mov	r11,r8
80005ca4:	fe 7c 0c 00 	mov	r12,-62464
80005ca8:	f0 1f 00 12 	mcall	80005cf0 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005cac:	30 0b       	mov	r11,0
80005cae:	fe 7c 0c 00 	mov	r12,-62464
80005cb2:	f0 1f 00 11 	mcall	80005cf4 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005cb6:	fe 7c 0c 00 	mov	r12,-62464
80005cba:	f0 1f 00 10 	mcall	80005cf8 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005cbe:	30 0a       	mov	r10,0
80005cc0:	1a da       	st.w	--sp,r10
80005cc2:	1a da       	st.w	--sp,r10
80005cc4:	14 98       	mov	r8,r10
80005cc6:	14 99       	mov	r9,r10
80005cc8:	30 1b       	mov	r11,1
80005cca:	fe 7c 0c 00 	mov	r12,-62464
80005cce:	f0 1f 00 0c 	mcall	80005cfc <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005cd2:	30 1c       	mov	r12,1
80005cd4:	f0 1f 00 0b 	mcall	80005d00 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005cd8:	30 2b       	mov	r11,2
80005cda:	fe 7c 0c 00 	mov	r12,-62464
80005cde:	f0 1f 00 0a 	mcall	80005d04 <local_start_pll0+0x90>
80005ce2:	2f dd       	sub	sp,-12
/****/
}
80005ce4:	d8 02       	popm	pc
80005ce6:	00 00       	add	r0,r0
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	66 40       	ld.w	r0,r3[0x10]
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	65 e2       	ld.w	r2,r2[0x78]
80005cf0:	80 00       	ld.sh	r0,r0[0x0]
80005cf2:	66 04       	ld.w	r4,r3[0x0]
80005cf4:	80 00       	ld.sh	r0,r0[0x0]
80005cf6:	66 1e       	ld.w	lr,r3[0x4]
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	66 2c       	ld.w	r12,r3[0x8]
80005cfc:	80 00       	ld.sh	r0,r0[0x0]
80005cfe:	65 9c       	ld.w	r12,r2[0x64]
80005d00:	80 00       	ld.sh	r0,r0[0x0]
80005d02:	62 d8       	ld.w	r8,r1[0x34]
80005d04:	80 00       	ld.sh	r0,r0[0x0]
80005d06:	66 36       	ld.w	r6,r3[0xc]

80005d08 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005d08:	d4 31       	pushm	r0-r7,lr
80005d0a:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005d0c:	f0 1f 00 8a 	mcall	80005f34 <xg_flashc_init+0x22c>
80005d10:	fe f8 02 28 	ld.w	r8,pc[552]
80005d14:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005d16:	70 08       	ld.w	r8,r8[0x0]
80005d18:	58 08       	cp.w	r8,0
80005d1a:	c0 51       	brne	80005d24 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005d1c:	fe fc 02 20 	ld.w	r12,pc[544]
80005d20:	f0 1f 00 88 	mcall	80005f40 <xg_flashc_init+0x238>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005d24:	30 0b       	mov	r11,0
80005d26:	30 1c       	mov	r12,1
80005d28:	f0 1f 00 87 	mcall	80005f44 <xg_flashc_init+0x23c>
80005d2c:	fe f8 02 1c 	ld.w	r8,pc[540]
80005d30:	91 0c       	st.w	r8[0x0],r12
80005d32:	70 08       	ld.w	r8,r8[0x0]
80005d34:	58 08       	cp.w	r8,0
80005d36:	c0 90       	breq	80005d48 <xg_flashc_init+0x40>
80005d38:	fe f8 02 10 	ld.w	r8,pc[528]
80005d3c:	70 0c       	ld.w	r12,r8[0x0]
80005d3e:	30 09       	mov	r9,0
80005d40:	12 9a       	mov	r10,r9
80005d42:	12 9b       	mov	r11,r9
80005d44:	f0 1f 00 82 	mcall	80005f4c <xg_flashc_init+0x244>
	if (xBinarySemaphore == NULL)
80005d48:	fe f8 02 00 	ld.w	r8,pc[512]
80005d4c:	70 08       	ld.w	r8,r8[0x0]
80005d4e:	58 08       	cp.w	r8,0
80005d50:	c0 51       	brne	80005d5a <xg_flashc_init+0x52>
	{
		log("Create the xBinarySemaphore semaphore failure\n");
80005d52:	fe fc 01 fe 	ld.w	r12,pc[510]
80005d56:	f0 1f 00 7b 	mcall	80005f40 <xg_flashc_init+0x238>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	
	xg_resend_queue = xQueueCreate(270, sizeof(U32));
80005d5a:	30 4b       	mov	r11,4
80005d5c:	e0 6c 01 0e 	mov	r12,270
80005d60:	f0 1f 00 79 	mcall	80005f44 <xg_flashc_init+0x23c>
80005d64:	4f c8       	lddpc	r8,80005f54 <xg_flashc_init+0x24c>
80005d66:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005d68:	30 4b       	mov	r11,4
80005d6a:	e0 6c 01 2c 	mov	r12,300
80005d6e:	f0 1f 00 76 	mcall	80005f44 <xg_flashc_init+0x23c>
80005d72:	4f a8       	lddpc	r8,80005f58 <xg_flashc_init+0x250>
80005d74:	91 0c       	st.w	r8[0x0],r12
80005d76:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005d78:	10 96       	mov	r6,r8
80005d7a:	4f 95       	lddpc	r5,80005f5c <xg_flashc_init+0x254>
80005d7c:	6c 0c       	ld.w	r12,r6[0x0]
80005d7e:	ea 07 00 0b 	add	r11,r5,r7
80005d82:	f0 1f 00 78 	mcall	80005f60 <xg_flashc_init+0x258>
80005d86:	2e 07       	sub	r7,-32
	//}
	
	xg_resend_queue = xQueueCreate(270, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005d88:	e0 47 25 80 	cp.w	r7,9600
80005d8c:	cf 81       	brne	80005d7c <xg_flashc_init+0x74>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80005d8e:	f0 1f 00 76 	mcall	80005f64 <xg_flashc_init+0x25c>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005d92:	30 0a       	mov	r10,0
80005d94:	30 0b       	mov	r11,0
80005d96:	4f 58       	lddpc	r8,80005f68 <xg_flashc_init+0x260>
80005d98:	b1 2a       	st.d	r8++,r10
80005d9a:	b1 2a       	st.d	r8++,r10
80005d9c:	b1 2a       	st.d	r8++,r10
80005d9e:	b1 2a       	st.d	r8++,r10
80005da0:	b1 2a       	st.d	r8++,r10
80005da2:	b1 2a       	st.d	r8++,r10
80005da4:	b1 2a       	st.d	r8++,r10
80005da6:	b1 2a       	st.d	r8++,r10
80005da8:	b1 2a       	st.d	r8++,r10
80005daa:	f0 eb 00 00 	st.d	r8[0],r10
80005dae:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005db0:	4e e7       	lddpc	r7,80005f68 <xg_flashc_init+0x260>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					log("current_message_index: %d\n", current_message_index);
					memset(str, 0x00, sizeof(str));	
80005db2:	ee c4 ff f8 	sub	r4,r7,-8
80005db6:	e8 c3 ff f8 	sub	r3,r4,-8
80005dba:	e6 c2 ff f8 	sub	r2,r3,-8
80005dbe:	e4 c1 ff f8 	sub	r1,r2,-8
80005dc2:	e2 c0 ff f8 	sub	r0,r1,-8
80005dc6:	e0 ca ff f8 	sub	r10,r0,-8
80005dca:	50 0a       	stdsp	sp[0x0],r10
80005dcc:	2f 8a       	sub	r10,-8
80005dce:	50 1a       	stdsp	sp[0x4],r10
80005dd0:	2f 8a       	sub	r10,-8
80005dd2:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005dd4:	0e 9a       	mov	r10,r7
80005dd6:	30 6b       	mov	r11,6
80005dd8:	30 0c       	mov	r12,0
80005dda:	f0 1f 00 65 	mcall	80005f6c <xg_flashc_init+0x264>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005dde:	30 6a       	mov	r10,6
80005de0:	0e 9b       	mov	r11,r7
80005de2:	4e 4c       	lddpc	r12,80005f70 <xg_flashc_init+0x268>
80005de4:	f0 1f 00 64 	mcall	80005f74 <xg_flashc_init+0x26c>
80005de8:	c1 c0       	breq	80005e20 <xg_flashc_init+0x118>
80005dea:	c8 b8       	rjmp	80005f00 <xg_flashc_init+0x1f8>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005dec:	30 6a       	mov	r10,6
80005dee:	30 0b       	mov	r11,0
80005df0:	4e 0c       	lddpc	r12,80005f70 <xg_flashc_init+0x268>
80005df2:	f0 1f 00 62 	mcall	80005f78 <xg_flashc_init+0x270>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005df6:	4d d7       	lddpc	r7,80005f68 <xg_flashc_init+0x260>
80005df8:	35 0a       	mov	r10,80
80005dfa:	30 0b       	mov	r11,0
80005dfc:	0e 9c       	mov	r12,r7
80005dfe:	f0 1f 00 60 	mcall	80005f7c <xg_flashc_init+0x274>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005e02:	30 2a       	mov	r10,2
80005e04:	30 6b       	mov	r11,6
80005e06:	0e 9c       	mov	r12,r7
80005e08:	f0 1f 00 5c 	mcall	80005f78 <xg_flashc_init+0x270>
			if(return_code != DF_WRITE_COMPLETED)
80005e0c:	58 7c       	cp.w	r12,7
80005e0e:	e0 81 00 90 	brne	80005f2e <xg_flashc_init+0x226>
			{
				return FALSE;
			}
			current_message_index = 0;
80005e12:	30 09       	mov	r9,0
80005e14:	4d b8       	lddpc	r8,80005f80 <xg_flashc_init+0x278>
80005e16:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005e18:	4d bc       	lddpc	r12,80005f84 <xg_flashc_init+0x27c>
80005e1a:	f0 1f 00 4a 	mcall	80005f40 <xg_flashc_init+0x238>
80005e1e:	c8 58       	rjmp	80005f28 <xg_flashc_init+0x220>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005e20:	1a d7       	st.w	--sp,r7
80005e22:	4d ac       	lddpc	r12,80005f88 <xg_flashc_init+0x280>
80005e24:	f0 1f 00 47 	mcall	80005f40 <xg_flashc_init+0x238>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80005e28:	4d 6a       	lddpc	r10,80005f80 <xg_flashc_init+0x278>
80005e2a:	30 2b       	mov	r11,2
80005e2c:	30 6c       	mov	r12,6
80005e2e:	f0 1f 00 50 	mcall	80005f6c <xg_flashc_init+0x264>
			if(return_code == DF_OK)
80005e32:	2f fd       	sub	sp,-4
80005e34:	58 0c       	cp.w	r12,0
80005e36:	e0 81 00 7c 	brne	80005f2e <xg_flashc_init+0x226>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005e3a:	4d 28       	lddpc	r8,80005f80 <xg_flashc_init+0x278>
80005e3c:	90 08       	ld.sh	r8,r8[0x0]
80005e3e:	58 08       	cp.w	r8,0
80005e40:	c7 10       	breq	80005f22 <xg_flashc_init+0x21a>
					
					log("current_message_index: %d\n", current_message_index);
80005e42:	5c 78       	castu.h	r8
80005e44:	1a d8       	st.w	--sp,r8
80005e46:	4d 2c       	lddpc	r12,80005f8c <xg_flashc_init+0x284>
80005e48:	f0 1f 00 3e 	mcall	80005f40 <xg_flashc_init+0x238>
					memset(str, 0x00, sizeof(str));	
80005e4c:	30 08       	mov	r8,0
80005e4e:	30 09       	mov	r9,0
80005e50:	ee e9 00 00 	st.d	r7[0],r8
80005e54:	e8 e9 00 00 	st.d	r4[0],r8
80005e58:	e6 e9 00 00 	st.d	r3[0],r8
80005e5c:	e4 e9 00 00 	st.d	r2[0],r8
80005e60:	e2 e9 00 00 	st.d	r1[0],r8
80005e64:	e0 e9 00 00 	st.d	r0[0],r8
80005e68:	40 1a       	lddsp	r10,sp[0x4]
80005e6a:	f4 e9 00 00 	st.d	r10[0],r8
80005e6e:	40 2a       	lddsp	r10,sp[0x8]
80005e70:	f4 e9 00 00 	st.d	r10[0],r8
80005e74:	40 3a       	lddsp	r10,sp[0xc]
80005e76:	b5 28       	st.d	r10++,r8
80005e78:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005e7c:	4c 18       	lddpc	r8,80005f80 <xg_flashc_init+0x278>
80005e7e:	90 85       	ld.uh	r5,r8[0x0]
80005e80:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80005e82:	0e 9a       	mov	r10,r7
80005e84:	30 8b       	mov	r11,8
80005e86:	0a 9c       	mov	r12,r5
80005e88:	f0 1f 00 39 	mcall	80005f6c <xg_flashc_init+0x264>
					if(return_code == DF_OK)
80005e8c:	2f fd       	sub	sp,-4
80005e8e:	58 0c       	cp.w	r12,0
80005e90:	c4 91       	brne	80005f22 <xg_flashc_init+0x21a>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005e92:	0f 89       	ld.ub	r9,r7[0x0]
80005e94:	0f 98       	ld.ub	r8,r7[0x1]
80005e96:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005e9a:	4b a9       	lddpc	r9,80005f80 <xg_flashc_init+0x278>
80005e9c:	92 09       	ld.sh	r9,r9[0x0]
80005e9e:	f0 09 19 00 	cp.h	r9,r8
80005ea2:	c2 c1       	brne	80005efa <xg_flashc_init+0x1f2>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005ea4:	0f e9       	ld.ub	r9,r7[0x6]
80005ea6:	0f f8       	ld.ub	r8,r7[0x7]
80005ea8:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005eac:	0f aa       	ld.ub	r10,r7[0x2]
80005eae:	0f b8       	ld.ub	r8,r7[0x3]
80005eb0:	b1 68       	lsl	r8,0x10
80005eb2:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005eb6:	0f ca       	ld.ub	r10,r7[0x4]
80005eb8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005ebc:	0f da       	ld.ub	r10,r7[0x5]
80005ebe:	f5 e8 10 08 	or	r8,r10,r8
80005ec2:	f2 08 00 08 	add	r8,r9,r8
80005ec6:	4b 36       	lddpc	r6,80005f90 <xg_flashc_init+0x288>
80005ec8:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005eca:	1a d8       	st.w	--sp,r8
80005ecc:	4b 2c       	lddpc	r12,80005f94 <xg_flashc_init+0x28c>
80005ece:	f0 1f 00 1d 	mcall	80005f40 <xg_flashc_init+0x238>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005ed2:	2f fd       	sub	sp,-4
80005ed4:	6c 08       	ld.w	r8,r6[0x0]
80005ed6:	e0 69 ff ff 	mov	r9,65535
80005eda:	ea 19 00 7f 	orh	r9,0x7f
80005ede:	12 38       	cp.w	r8,r9
80005ee0:	e0 88 00 21 	brls	80005f22 <xg_flashc_init+0x21a>
										
								log("\r\n----message storage is full!!!----\r\n");
80005ee4:	4a dc       	lddpc	r12,80005f98 <xg_flashc_init+0x290>
80005ee6:	f0 1f 00 17 	mcall	80005f40 <xg_flashc_init+0x238>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005eea:	30 4b       	mov	r11,4
80005eec:	30 0c       	mov	r12,0
80005eee:	f0 1f 00 2c 	mcall	80005f9c <xg_flashc_init+0x294>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80005ef2:	58 5c       	cp.w	r12,5
80005ef4:	fe 90 ff 70 	breq	80005dd4 <xg_flashc_init+0xcc>
80005ef8:	c1 b8       	rjmp	80005f2e <xg_flashc_init+0x226>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005efa:	4a ac       	lddpc	r12,80005fa0 <xg_flashc_init+0x298>
80005efc:	f0 1f 00 11 	mcall	80005f40 <xg_flashc_init+0x238>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005f00:	30 3b       	mov	r11,3
80005f02:	0a 9c       	mov	r12,r5
80005f04:	f0 1f 00 26 	mcall	80005f9c <xg_flashc_init+0x294>
				if(return_code != DF_ERASE_COMPLETED)
80005f08:	58 5c       	cp.w	r12,5
80005f0a:	c1 21       	brne	80005f2e <xg_flashc_init+0x226>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005f0c:	30 3b       	mov	r11,3
80005f0e:	e0 78 00 00 	mov	r8,65536
80005f12:	ea 08 00 0c 	add	r12,r5,r8
80005f16:	f0 1f 00 22 	mcall	80005f9c <xg_flashc_init+0x294>
				if(return_code != DF_ERASE_COMPLETED)
80005f1a:	58 5c       	cp.w	r12,5
80005f1c:	fe 90 ff 68 	breq	80005dec <xg_flashc_init+0xe4>
80005f20:	c0 78       	rjmp	80005f2e <xg_flashc_init+0x226>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005f22:	4a 1c       	lddpc	r12,80005fa4 <xg_flashc_init+0x29c>
80005f24:	f0 1f 00 07 	mcall	80005f40 <xg_flashc_init+0x238>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80005f28:	30 19       	mov	r9,1
80005f2a:	4a 08       	lddpc	r8,80005fa8 <xg_flashc_init+0x2a0>
80005f2c:	b0 89       	st.b	r8[0x0],r9
	
	xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005f2e:	2f dd       	sub	sp,-12
80005f30:	d8 32       	popm	r0-r7,pc
80005f32:	00 00       	add	r0,r0
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	74 1c       	ld.w	r12,r10[0x4]
80005f38:	00 00       	add	r0,r0
80005f3a:	0b 9c       	ld.ub	r12,r5[0x1]
80005f3c:	80 00       	ld.sh	r0,r0[0x0]
80005f3e:	ea ac       	*unknown*
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	7f 54       	ld.w	r4,pc[0x54]
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	74 74       	ld.w	r4,r10[0x1c]
80005f48:	00 00       	add	r0,r0
80005f4a:	0b a4       	ld.ub	r4,r5[0x2]
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	73 1c       	ld.w	r12,r9[0x44]
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	ea d8 00 00 	satsub.w	r8,r5,0
80005f56:	0b 94       	ld.ub	r4,r5[0x1]
80005f58:	00 00       	add	r0,r0
80005f5a:	0b a0       	ld.ub	r0,r5[0x2]
80005f5c:	00 00       	add	r0,r0
80005f5e:	97 bc       	st.w	r11[0x2c],r12
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	35 34       	mov	r4,83
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	31 fc       	mov	r12,31
80005f68:	00 00       	add	r0,r0
80005f6a:	0b ac       	ld.ub	r12,r5[0x2]
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	2e a0       	sub	r0,-22
80005f70:	00 00       	add	r0,r0
80005f72:	05 40       	ld.w	r0,--r2
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	87 d8       	st.w	r3[0x34],r8
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	30 d8       	mov	r8,13
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	89 46       	st.w	r4[0x10],r6
80005f80:	00 00       	add	r0,r0
80005f82:	0b a8       	ld.ub	r8,r5[0x2]
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	eb 08 80 00 	ld.sh	r8,r5[-32768]
80005f8a:	eb 34 80 00 	ld.ub	r4,r5[-32768]
80005f8e:	eb 40 00 00 	st.w	r5[0],r0
80005f92:	05 48       	ld.w	r8,--r2
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	eb 5c 80 00 	st.h	r5[-32768],r12
80005f9a:	eb 80       	*unknown*
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	30 38       	mov	r8,3
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	eb a8 80 00 	stc.w	cp4,r8[0x0],cr0
80005fa6:	eb d0 00 00 	ldins.h	r0:b,r5[0]
80005faa:	0b 98       	ld.ub	r8,r5[0x1]

80005fac <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
80005fac:	d4 31       	pushm	r0-r7,lr
80005fae:	20 2d       	sub	sp,8
80005fb0:	18 95       	mov	r5,r12
80005fb2:	16 96       	mov	r6,r11
80005fb4:	14 93       	mov	r3,r10
	xgflash_status_t status = XG_ERROR;
	
	if(!list_init_success_flag)return XG_ERROR;
80005fb6:	4c 78       	lddpc	r8,800060d0 <xgflash_get_message_data+0x124>
80005fb8:	11 89       	ld.ub	r9,r8[0x0]
80005fba:	30 08       	mov	r8,0
80005fbc:	f0 09 18 00 	cp.b	r9,r8
80005fc0:	c0 31       	brne	80005fc6 <xgflash_get_message_data+0x1a>
80005fc2:	3f f7       	mov	r7,-1
80005fc4:	c8 28       	rjmp	800060c8 <xgflash_get_message_data+0x11c>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80005fc6:	4c 48       	lddpc	r8,800060d4 <xgflash_get_message_data+0x128>
80005fc8:	70 0c       	ld.w	r12,r8[0x0]
80005fca:	30 09       	mov	r9,0
80005fcc:	3f fa       	mov	r10,-1
80005fce:	12 9b       	mov	r11,r9
80005fd0:	f0 1f 00 42 	mcall	800060d8 <xgflash_get_message_data+0x12c>
	/* check input parameter */
	if (message_index > current_message_index)
80005fd4:	4c 28       	lddpc	r8,800060dc <xgflash_get_message_data+0x130>
80005fd6:	90 88       	ld.uh	r8,r8[0x0]
80005fd8:	0a 38       	cp.w	r8,r5
80005fda:	c0 a2       	brcc	80005fee <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
80005fdc:	4b e8       	lddpc	r8,800060d4 <xgflash_get_message_data+0x128>
80005fde:	70 0c       	ld.w	r12,r8[0x0]
80005fe0:	30 09       	mov	r9,0
80005fe2:	12 9a       	mov	r10,r9
80005fe4:	12 9b       	mov	r11,r9
80005fe6:	f0 1f 00 3f 	mcall	800060e0 <xgflash_get_message_data+0x134>
80005fea:	30 17       	mov	r7,1
		return XG_INVALID_PARAM;
80005fec:	c6 e8       	rjmp	800060c8 <xgflash_get_message_data+0x11c>
	U32 data_address =0x00000000;
	U32 erase_address =0x00;
	U32 erase_length =0x00;
	
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
80005fee:	fa ca ff f8 	sub	r10,sp,-8
80005ff2:	30 08       	mov	r8,0
80005ff4:	30 09       	mov	r9,0
80005ff6:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
80005ff8:	1a 9a       	mov	r10,sp
80005ffa:	30 8b       	mov	r11,8
80005ffc:	ea 0c 15 03 	lsl	r12,r5,0x3
80006000:	f0 1f 00 39 	mcall	800060e4 <xgflash_get_message_data+0x138>
	if (return_code == DF_OK)
80006004:	c5 a1       	brne	800060b8 <xgflash_get_message_data+0x10c>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
80006006:	9a 88       	ld.uh	r8,sp[0x0]
80006008:	0a 38       	cp.w	r8,r5
8000600a:	c3 31       	brne	80006070 <xgflash_get_message_data+0xc4>
		{
			bytes_remained = ptr->offset;
8000600c:	40 18       	lddsp	r8,sp[0x4]
8000600e:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			erase_length = ptr->offset;
			
			data_address = ptr->address;
80006012:	9a 95       	ld.uh	r5,sp[0x2]
80006014:	b1 88       	lsr	r8,0x10
80006016:	f1 e5 11 05 	or	r5,r8,r5<<0x10
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
8000601a:	30 04       	mov	r4,0
8000601c:	08 92       	mov	r2,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
8000601e:	e0 61 01 ff 	mov	r1,511
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80006022:	e0 60 02 00 	mov	r0,512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80006026:	c1 98       	rjmp	80006058 <xgflash_get_message_data+0xac>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80006028:	e2 07 19 00 	cp.h	r7,r1
8000602c:	e0 8b 00 0a 	brhi	80006040 <xgflash_get_message_data+0x94>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
80006030:	0c 9a       	mov	r10,r6
80006032:	0e 9b       	mov	r11,r7
80006034:	5c 7b       	castu.h	r11
80006036:	0a 9c       	mov	r12,r5
80006038:	f0 1f 00 2b 	mcall	800060e4 <xgflash_get_message_data+0x138>
8000603c:	30 07       	mov	r7,0
8000603e:	c0 d8       	rjmp	80006058 <xgflash_get_message_data+0xac>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80006040:	0c 9a       	mov	r10,r6
80006042:	00 9b       	mov	r11,r0
80006044:	0a 9c       	mov	r12,r5
80006046:	f0 1f 00 28 	mcall	800060e4 <xgflash_get_message_data+0x138>
					bytes_remained-=DF_DATA_SPACE_SIZE;
8000604a:	ee c7 02 00 	sub	r7,r7,512
8000604e:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
80006050:	ea c5 fe 00 	sub	r5,r5,-512
					buff_ptr+=DF_DATA_SPACE_SIZE;
80006054:	ec c6 fe 00 	sub	r6,r6,-512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80006058:	e8 07 19 00 	cp.h	r7,r4
8000605c:	5f 19       	srne	r9
8000605e:	58 0c       	cp.w	r12,0
80006060:	5f 08       	sreq	r8
80006062:	f3 e8 00 08 	and	r8,r9,r8
80006066:	e4 08 18 00 	cp.b	r8,r2
8000606a:	cd f1       	brne	80006028 <xgflash_get_message_data+0x7c>
8000606c:	30 07       	mov	r7,0
8000606e:	c0 58       	rjmp	80006078 <xgflash_get_message_data+0xcc>
			}
			status = XG_OK;
		}
		else
		{
			log("Err flash data\n");
80006070:	49 ec       	lddpc	r12,800060e8 <xgflash_get_message_data+0x13c>
80006072:	f0 1f 00 1f 	mcall	800060ec <xgflash_get_message_data+0x140>
80006076:	30 87       	mov	r7,8
			
			//xSemaphoreGive(xgflash_mutex);//unlock
			status = 8;
			//return 7;
		}
		if(erase)//erase the message
80006078:	58 03       	cp.w	r3,0
8000607a:	c1 70       	breq	800060a8 <xgflash_get_message_data+0xfc>
		{
			memset(str, 0x00, sizeof(str));
8000607c:	30 08       	mov	r8,0
8000607e:	30 09       	mov	r9,0
80006080:	fa e9 00 00 	st.d	sp[0],r8
			//reset:current_message_index and erase info
			current_message_index-=1;
80006084:	49 6c       	lddpc	r12,800060dc <xgflash_get_message_data+0x130>
80006086:	98 08       	ld.sh	r8,r12[0x0]
80006088:	20 18       	sub	r8,1
8000608a:	b8 08       	st.h	r12[0x0],r8
			return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
8000608c:	30 2a       	mov	r10,2
8000608e:	30 6b       	mov	r11,6
80006090:	f0 1f 00 18 	mcall	800060f0 <xgflash_get_message_data+0x144>
			if (return_code != DF_WRITE_COMPLETED)
80006094:	58 7c       	cp.w	r12,7
80006096:	c0 50       	breq	800060a0 <xgflash_get_message_data+0xf4>
			{
				log("data_flash_write 1...\n");
80006098:	49 7c       	lddpc	r12,800060f4 <xgflash_get_message_data+0x148>
8000609a:	f0 1f 00 15 	mcall	800060ec <xgflash_get_message_data+0x140>
8000609e:	30 77       	mov	r7,7
				//status = XG_FLASH_WRITE_FAIL;
			//}
					//
			////erase data and reset:current_save_message_offset
			//return_code = data_flash_write((U8 *)str, erase_address, sizeof(str));
			current_save_message_offset-=32;//出错在这...如果掉线，未执行，则会出现存储碎片
800060a0:	49 68       	lddpc	r8,800060f8 <xgflash_get_message_data+0x14c>
800060a2:	70 09       	ld.w	r9,r8[0x0]
800060a4:	22 09       	sub	r9,32
800060a6:	91 09       	st.w	r8[0x0],r9
				//status = XG_FLASH_WRITE_FAIL;
			//}
					
		}
				
		xSemaphoreGive(xgflash_mutex);//unlock
800060a8:	48 b8       	lddpc	r8,800060d4 <xgflash_get_message_data+0x128>
800060aa:	70 0c       	ld.w	r12,r8[0x0]
800060ac:	30 09       	mov	r9,0
800060ae:	12 9a       	mov	r10,r9
800060b0:	12 9b       	mov	r11,r9
800060b2:	f0 1f 00 0c 	mcall	800060e0 <xgflash_get_message_data+0x134>
		//status = XG_OK;
		return status;
800060b6:	c0 98       	rjmp	800060c8 <xgflash_get_message_data+0x11c>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
800060b8:	48 78       	lddpc	r8,800060d4 <xgflash_get_message_data+0x128>
800060ba:	70 0c       	ld.w	r12,r8[0x0]
800060bc:	30 09       	mov	r9,0
800060be:	12 9a       	mov	r10,r9
800060c0:	12 9b       	mov	r11,r9
800060c2:	f0 1f 00 08 	mcall	800060e0 <xgflash_get_message_data+0x134>
800060c6:	30 67       	mov	r7,6
	return XG_FLASH_READ_FAIL;
		
}
800060c8:	0e 9c       	mov	r12,r7
800060ca:	2f ed       	sub	sp,-8
800060cc:	d8 32       	popm	r0-r7,pc
800060ce:	00 00       	add	r0,r0
800060d0:	00 00       	add	r0,r0
800060d2:	0b 98       	ld.ub	r8,r5[0x1]
800060d4:	00 00       	add	r0,r0
800060d6:	0b 9c       	ld.ub	r12,r5[0x1]
800060d8:	80 00       	ld.sh	r0,r0[0x0]
800060da:	71 10       	ld.w	r0,r8[0x44]
800060dc:	00 00       	add	r0,r0
800060de:	0b a8       	ld.ub	r8,r5[0x2]
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	73 1c       	ld.w	r12,r9[0x44]
800060e4:	80 00       	ld.sh	r0,r0[0x0]
800060e6:	2e a0       	sub	r0,-22
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	ec 0c       	*unknown*
800060ec:	80 00       	ld.sh	r0,r0[0x0]
800060ee:	7f 54       	ld.w	r4,pc[0x54]
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	30 d8       	mov	r8,13
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	ec 1c 00 00 	eorl	r12,0x0
800060fa:	05 48       	ld.w	r8,--r2

800060fc <xgflash_message_save>:
	
}

//static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
800060fc:	d4 21       	pushm	r4-r7,lr
800060fe:	20 2d       	sub	sp,8
80006100:	18 96       	mov	r6,r12
80006102:	16 97       	mov	r7,r11
80006104:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
80006106:	4d 68       	lddpc	r8,8000625c <xgflash_message_save+0x160>
80006108:	11 89       	ld.ub	r9,r8[0x0]
8000610a:	30 08       	mov	r8,0
8000610c:	f0 09 18 00 	cp.b	r9,r8
80006110:	c0 31       	brne	80006116 <xgflash_message_save+0x1a>
80006112:	3f fc       	mov	r12,-1
80006114:	ca 28       	rjmp	80006258 <xgflash_message_save+0x15c>
	U32 address = 0;
	static U32 bytes_remained = 0;
	static U32 current_bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock	
80006116:	4d 38       	lddpc	r8,80006260 <xgflash_message_save+0x164>
80006118:	70 0c       	ld.w	r12,r8[0x0]
8000611a:	30 09       	mov	r9,0
8000611c:	3f fa       	mov	r10,-1
8000611e:	12 9b       	mov	r11,r9
80006120:	f0 1f 00 51 	mcall	80006264 <xgflash_message_save+0x168>
	
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
80006124:	58 06       	cp.w	r6,0
80006126:	5f 09       	sreq	r9
80006128:	e0 68 02 00 	mov	r8,512
8000612c:	f0 07 19 00 	cp.h	r7,r8
80006130:	5f b8       	srhi	r8
80006132:	f3 e8 10 08 	or	r8,r9,r8
80006136:	c0 30       	breq	8000613c <xgflash_message_save+0x40>
80006138:	30 1c       	mov	r12,1
8000613a:	c8 f8       	rjmp	80006258 <xgflash_message_save+0x15c>
	{
		return XG_INVALID_PARAM;
	}
	
	current_bytes_remained+=data_len;//accumulate
8000613c:	0e 94       	mov	r4,r7
8000613e:	5c 74       	castu.h	r4
80006140:	4c a9       	lddpc	r9,80006268 <xgflash_message_save+0x16c>
80006142:	72 08       	ld.w	r8,r9[0x0]
80006144:	e8 08 00 08 	add	r8,r4,r8
80006148:	93 08       	st.w	r9[0x0],r8
	
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
8000614a:	e0 48 f0 00 	cp.w	r8,61440
8000614e:	e0 88 00 07 	brls	8000615c <xgflash_message_save+0x60>
	{
		current_bytes_remained = 0;
80006152:	30 09       	mov	r9,0
80006154:	4c 58       	lddpc	r8,80006268 <xgflash_message_save+0x16c>
80006156:	91 09       	st.w	r8[0x0],r9
80006158:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
8000615a:	c7 f8       	rjmp	80006258 <xgflash_message_save+0x15c>
	}
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
8000615c:	4c 48       	lddpc	r8,8000626c <xgflash_message_save+0x170>
8000615e:	70 0b       	ld.w	r11,r8[0x0]
80006160:	e0 68 ff ff 	mov	r8,65535
80006164:	ea 18 00 7f 	orh	r8,0x7f
80006168:	10 3b       	cp.w	r11,r8
8000616a:	e0 88 00 10 	brls	8000618a <xgflash_message_save+0x8e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
8000616e:	4c 1c       	lddpc	r12,80006270 <xgflash_message_save+0x174>
80006170:	f0 1f 00 41 	mcall	80006274 <xgflash_message_save+0x178>
		current_bytes_remained = 0;
80006174:	30 0b       	mov	r11,0
80006176:	4b d8       	lddpc	r8,80006268 <xgflash_message_save+0x16c>
80006178:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000617a:	4b a8       	lddpc	r8,80006260 <xgflash_message_save+0x164>
8000617c:	70 0c       	ld.w	r12,r8[0x0]
8000617e:	16 99       	mov	r9,r11
80006180:	16 9a       	mov	r10,r11
80006182:	f0 1f 00 3e 	mcall	80006278 <xgflash_message_save+0x17c>
80006186:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
80006188:	c6 88       	rjmp	80006258 <xgflash_message_save+0x15c>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
8000618a:	0e 9a       	mov	r10,r7
8000618c:	5c 7a       	castu.h	r10
8000618e:	0c 9c       	mov	r12,r6
80006190:	f0 1f 00 3b 	mcall	8000627c <xgflash_message_save+0x180>
	if(return_code != DF_WRITE_COMPLETED)
80006194:	58 7c       	cp.w	r12,7
80006196:	c0 c0       	breq	800061ae <xgflash_message_save+0xb2>
	{
		current_bytes_remained = 0;
80006198:	30 0b       	mov	r11,0
8000619a:	4b 48       	lddpc	r8,80006268 <xgflash_message_save+0x16c>
8000619c:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000619e:	4b 18       	lddpc	r8,80006260 <xgflash_message_save+0x164>
800061a0:	70 0c       	ld.w	r12,r8[0x0]
800061a2:	16 99       	mov	r9,r11
800061a4:	16 9a       	mov	r10,r11
800061a6:	f0 1f 00 35 	mcall	80006278 <xgflash_message_save+0x17c>
800061aa:	30 7c       	mov	r12,7
		return XG_FLASH_WRITE_FAIL;
800061ac:	c5 68       	rjmp	80006258 <xgflash_message_save+0x15c>
	}
	
	current_save_message_offset+=data_len;
800061ae:	4b 08       	lddpc	r8,8000626c <xgflash_message_save+0x170>
800061b0:	70 09       	ld.w	r9,r8[0x0]
800061b2:	12 04       	add	r4,r9
800061b4:	91 04       	st.w	r8[0x0],r4
	log("current_save_message_offset : %X\n", current_save_message_offset);
800061b6:	1a d4       	st.w	--sp,r4
800061b8:	4b 2c       	lddpc	r12,80006280 <xgflash_message_save+0x184>
800061ba:	f0 1f 00 2f 	mcall	80006274 <xgflash_message_save+0x178>
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
800061be:	2f fd       	sub	sp,-4
800061c0:	30 18       	mov	r8,1
800061c2:	f0 05 18 00 	cp.b	r5,r8
800061c6:	c4 11       	brne	80006248 <xgflash_message_save+0x14c>
	{
		current_message_index++;
800061c8:	4a f9       	lddpc	r9,80006284 <xgflash_message_save+0x188>
800061ca:	92 08       	ld.sh	r8,r9[0x0]
800061cc:	2f f8       	sub	r8,-1
800061ce:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
800061d0:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
800061d2:	4a 69       	lddpc	r9,80006268 <xgflash_message_save+0x16c>
800061d4:	72 09       	ld.w	r9,r9[0x0]
800061d6:	4a 6a       	lddpc	r10,8000626c <xgflash_message_save+0x170>
800061d8:	74 0a       	ld.w	r10,r10[0x0]
800061da:	12 1a       	sub	r10,r9
800061dc:	40 0b       	lddsp	r11,sp[0x0]
800061de:	e0 1b 00 00 	andl	r11,0x0
800061e2:	f7 ea 13 0b 	or	r11,r11,r10>>0x10
800061e6:	50 0b       	stdsp	sp[0x0],r11
800061e8:	ba 2a       	st.h	sp[0x4],r10
		ptr.offset		= current_bytes_remained;
800061ea:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
800061ec:	5c 78       	castu.h	r8
800061ee:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
800061f2:	e2 4b 00 00 	cp.w	r11,131072
800061f6:	e0 88 00 10 	brls	80006216 <xgflash_message_save+0x11a>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
800061fa:	4a 4c       	lddpc	r12,80006288 <xgflash_message_save+0x18c>
800061fc:	f0 1f 00 1e 	mcall	80006274 <xgflash_message_save+0x178>
			current_bytes_remained = 0;
80006200:	30 0b       	mov	r11,0
80006202:	49 a8       	lddpc	r8,80006268 <xgflash_message_save+0x16c>
80006204:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
80006206:	49 78       	lddpc	r8,80006260 <xgflash_message_save+0x164>
80006208:	70 0c       	ld.w	r12,r8[0x0]
8000620a:	16 99       	mov	r9,r11
8000620c:	16 9a       	mov	r10,r11
8000620e:	f0 1f 00 1b 	mcall	80006278 <xgflash_message_save+0x17c>
80006212:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
80006214:	c2 28       	rjmp	80006258 <xgflash_message_save+0x15c>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
80006216:	30 8a       	mov	r10,8
80006218:	1a 9c       	mov	r12,sp
8000621a:	f0 1f 00 19 	mcall	8000627c <xgflash_message_save+0x180>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
8000621e:	30 2a       	mov	r10,2
80006220:	30 6b       	mov	r11,6
80006222:	49 9c       	lddpc	r12,80006284 <xgflash_message_save+0x188>
80006224:	f0 1f 00 16 	mcall	8000627c <xgflash_message_save+0x180>
		if(return_code != DF_WRITE_COMPLETED)
80006228:	58 7c       	cp.w	r12,7
8000622a:	c0 c0       	breq	80006242 <xgflash_message_save+0x146>
		{
			current_bytes_remained = 0;
8000622c:	30 0b       	mov	r11,0
8000622e:	48 f8       	lddpc	r8,80006268 <xgflash_message_save+0x16c>
80006230:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
80006232:	48 c8       	lddpc	r8,80006260 <xgflash_message_save+0x164>
80006234:	70 0c       	ld.w	r12,r8[0x0]
80006236:	16 99       	mov	r9,r11
80006238:	16 9a       	mov	r10,r11
8000623a:	f0 1f 00 10 	mcall	80006278 <xgflash_message_save+0x17c>
8000623e:	30 7c       	mov	r12,7
			return XG_FLASH_WRITE_FAIL;
80006240:	c0 c8       	rjmp	80006258 <xgflash_message_save+0x15c>
		}
		
		current_bytes_remained = 0;//reset 0
80006242:	30 09       	mov	r9,0
80006244:	48 98       	lddpc	r8,80006268 <xgflash_message_save+0x16c>
80006246:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
80006248:	48 68       	lddpc	r8,80006260 <xgflash_message_save+0x164>
8000624a:	70 0c       	ld.w	r12,r8[0x0]
8000624c:	30 09       	mov	r9,0
8000624e:	12 9a       	mov	r10,r9
80006250:	12 9b       	mov	r11,r9
80006252:	f0 1f 00 0a 	mcall	80006278 <xgflash_message_save+0x17c>
80006256:	30 0c       	mov	r12,0
	return XG_OK;

}
80006258:	2f ed       	sub	sp,-8
8000625a:	d8 22       	popm	r4-r7,pc
8000625c:	00 00       	add	r0,r0
8000625e:	0b 98       	ld.ub	r8,r5[0x1]
80006260:	00 00       	add	r0,r0
80006262:	0b 9c       	ld.ub	r12,r5[0x1]
80006264:	80 00       	ld.sh	r0,r0[0x0]
80006266:	71 10       	ld.w	r0,r8[0x44]
80006268:	00 00       	add	r0,r0
8000626a:	0b fc       	ld.ub	r12,r5[0x7]
8000626c:	00 00       	add	r0,r0
8000626e:	05 48       	ld.w	r8,--r2
80006270:	80 00       	ld.sh	r0,r0[0x0]
80006272:	ec 34 80 00 	sub	r4,884736
80006276:	7f 54       	ld.w	r4,pc[0x54]
80006278:	80 00       	ld.sh	r0,r0[0x0]
8000627a:	73 1c       	ld.w	r12,r9[0x44]
8000627c:	80 00       	ld.sh	r0,r0[0x0]
8000627e:	30 d8       	mov	r8,13
80006280:	80 00       	ld.sh	r0,r0[0x0]
80006282:	eb 5c 00 00 	st.h	r5[0],r12
80006286:	0b a8       	ld.ub	r8,r5[0x2]
80006288:	80 00       	ld.sh	r0,r0[0x0]
8000628a:	ec 64 eb cd 	mov	r4,846797

8000628c <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
8000628c:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
80006290:	48 d8       	lddpc	r8,800062c4 <xgflash_get_message_count+0x38>
80006292:	11 89       	ld.ub	r9,r8[0x0]
80006294:	30 08       	mov	r8,0
80006296:	f0 09 18 00 	cp.b	r9,r8
8000629a:	c0 31       	brne	800062a0 <xgflash_get_message_count+0x14>
8000629c:	3f f7       	mov	r7,-1
8000629e:	c1 08       	rjmp	800062be <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
800062a0:	48 a6       	lddpc	r6,800062c8 <xgflash_get_message_count+0x3c>
800062a2:	6c 0c       	ld.w	r12,r6[0x0]
800062a4:	30 09       	mov	r9,0
800062a6:	3f fa       	mov	r10,-1
800062a8:	12 9b       	mov	r11,r9
800062aa:	f0 1f 00 09 	mcall	800062cc <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
800062ae:	48 98       	lddpc	r8,800062d0 <xgflash_get_message_count+0x44>
800062b0:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
800062b2:	6c 0c       	ld.w	r12,r6[0x0]
800062b4:	30 09       	mov	r9,0
800062b6:	12 9a       	mov	r10,r9
800062b8:	12 9b       	mov	r11,r9
800062ba:	f0 1f 00 07 	mcall	800062d4 <xgflash_get_message_count+0x48>

	return return_value;
	
}
800062be:	0e 9c       	mov	r12,r7
800062c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062c4:	00 00       	add	r0,r0
800062c6:	0b 98       	ld.ub	r8,r5[0x1]
800062c8:	00 00       	add	r0,r0
800062ca:	0b 9c       	ld.ub	r12,r5[0x1]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	71 10       	ld.w	r0,r8[0x44]
800062d0:	00 00       	add	r0,r0
800062d2:	0b a8       	ld.ub	r8,r5[0x2]
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	73 1c       	ld.w	r12,r9[0x44]

800062d8 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800062d8:	fe 68 14 00 	mov	r8,-125952
800062dc:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800062de:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800062e2:	91 09       	st.w	r8[0x0],r9
}
800062e4:	5e fc       	retal	r12

800062e6 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800062e6:	f8 08 16 05 	lsr	r8,r12,0x5
800062ea:	a9 68       	lsl	r8,0x8
800062ec:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800062f0:	58 1b       	cp.w	r11,1
800062f2:	c0 d0       	breq	8000630c <gpio_enable_module_pin+0x26>
800062f4:	c0 63       	brcs	80006300 <gpio_enable_module_pin+0x1a>
800062f6:	58 2b       	cp.w	r11,2
800062f8:	c1 00       	breq	80006318 <gpio_enable_module_pin+0x32>
800062fa:	58 3b       	cp.w	r11,3
800062fc:	c1 40       	breq	80006324 <gpio_enable_module_pin+0x3e>
800062fe:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006300:	30 19       	mov	r9,1
80006302:	f2 0c 09 49 	lsl	r9,r9,r12
80006306:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006308:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000630a:	c1 28       	rjmp	8000632e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000630c:	30 19       	mov	r9,1
8000630e:	f2 0c 09 49 	lsl	r9,r9,r12
80006312:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006314:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006316:	c0 c8       	rjmp	8000632e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006318:	30 19       	mov	r9,1
8000631a:	f2 0c 09 49 	lsl	r9,r9,r12
8000631e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006320:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006322:	c0 68       	rjmp	8000632e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006324:	30 19       	mov	r9,1
80006326:	f2 0c 09 49 	lsl	r9,r9,r12
8000632a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000632c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000632e:	30 19       	mov	r9,1
80006330:	f2 0c 09 4c 	lsl	r12,r9,r12
80006334:	91 2c       	st.w	r8[0x8],r12
80006336:	5e fd       	retal	0

80006338 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006338:	d4 21       	pushm	r4-r7,lr
8000633a:	18 97       	mov	r7,r12
8000633c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000633e:	58 0b       	cp.w	r11,0
80006340:	c0 31       	brne	80006346 <gpio_enable_module+0xe>
80006342:	30 05       	mov	r5,0
80006344:	c0 d8       	rjmp	8000635e <gpio_enable_module+0x26>
80006346:	30 06       	mov	r6,0
80006348:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000634a:	6e 1b       	ld.w	r11,r7[0x4]
8000634c:	6e 0c       	ld.w	r12,r7[0x0]
8000634e:	f0 1f 00 06 	mcall	80006364 <gpio_enable_module+0x2c>
80006352:	18 45       	or	r5,r12
		gpiomap++;
80006354:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006356:	2f f6       	sub	r6,-1
80006358:	0c 34       	cp.w	r4,r6
8000635a:	fe 9b ff f8 	brhi	8000634a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000635e:	0a 9c       	mov	r12,r5
80006360:	d8 22       	popm	r4-r7,pc
80006362:	00 00       	add	r0,r0
80006364:	80 00       	ld.sh	r0,r0[0x0]
80006366:	62 e6       	ld.w	r6,r1[0x38]

80006368 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006368:	f8 08 16 05 	lsr	r8,r12,0x5
8000636c:	a9 68       	lsl	r8,0x8
8000636e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006372:	30 19       	mov	r9,1
80006374:	f2 0c 09 4c 	lsl	r12,r9,r12
80006378:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000637c:	91 1c       	st.w	r8[0x4],r12
}
8000637e:	5e fc       	retal	r12

80006380 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006380:	f8 08 16 05 	lsr	r8,r12,0x5
80006384:	a9 68       	lsl	r8,0x8
80006386:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000638a:	30 19       	mov	r9,1
8000638c:	f2 0c 09 4c 	lsl	r12,r9,r12
80006390:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80006394:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006398:	91 1c       	st.w	r8[0x4],r12
}
8000639a:	5e fc       	retal	r12

8000639c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000639c:	f8 08 16 05 	lsr	r8,r12,0x5
800063a0:	a9 68       	lsl	r8,0x8
800063a2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800063a6:	30 19       	mov	r9,1
800063a8:	f2 0c 09 4c 	lsl	r12,r9,r12
800063ac:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800063b0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800063b4:	91 1c       	st.w	r8[0x4],r12
}
800063b6:	5e fc       	retal	r12

800063b8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800063b8:	c0 08       	rjmp	800063b8 <_unhandled_interrupt>
800063ba:	d7 03       	nop

800063bc <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800063bc:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800063c0:	49 99       	lddpc	r9,80006424 <INTC_register_interrupt+0x68>
800063c2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800063c6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800063ca:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800063cc:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800063d0:	58 0a       	cp.w	r10,0
800063d2:	c0 91       	brne	800063e4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800063d4:	49 59       	lddpc	r9,80006428 <INTC_register_interrupt+0x6c>
800063d6:	49 6a       	lddpc	r10,8000642c <INTC_register_interrupt+0x70>
800063d8:	12 1a       	sub	r10,r9
800063da:	fe 79 08 00 	mov	r9,-63488
800063de:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800063e2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800063e4:	58 1a       	cp.w	r10,1
800063e6:	c0 a1       	brne	800063fa <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800063e8:	49 09       	lddpc	r9,80006428 <INTC_register_interrupt+0x6c>
800063ea:	49 2a       	lddpc	r10,80006430 <INTC_register_interrupt+0x74>
800063ec:	12 1a       	sub	r10,r9
800063ee:	bf aa       	sbr	r10,0x1e
800063f0:	fe 79 08 00 	mov	r9,-63488
800063f4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800063f8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800063fa:	58 2a       	cp.w	r10,2
800063fc:	c0 a1       	brne	80006410 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800063fe:	48 b9       	lddpc	r9,80006428 <INTC_register_interrupt+0x6c>
80006400:	48 da       	lddpc	r10,80006434 <INTC_register_interrupt+0x78>
80006402:	12 1a       	sub	r10,r9
80006404:	bf ba       	sbr	r10,0x1f
80006406:	fe 79 08 00 	mov	r9,-63488
8000640a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000640e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80006410:	48 69       	lddpc	r9,80006428 <INTC_register_interrupt+0x6c>
80006412:	48 aa       	lddpc	r10,80006438 <INTC_register_interrupt+0x7c>
80006414:	12 1a       	sub	r10,r9
80006416:	ea 1a c0 00 	orh	r10,0xc000
8000641a:	fe 79 08 00 	mov	r9,-63488
8000641e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006422:	5e fc       	retal	r12
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	ec f4 80 00 	ld.w	r4,r6[-32768]
8000642a:	de 00       	acall	0xe0
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	df 04       	*unknown*
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	df 12       	popm	r0-r3,r11-r12,lr-pc
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	df 20       	acall	0xf2
80006438:	80 00       	ld.sh	r0,r0[0x0]
8000643a:	df 2e       	*unknown*

8000643c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000643c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000643e:	49 18       	lddpc	r8,80006480 <INTC_init_interrupts+0x44>
80006440:	e3 b8 00 01 	mtsr	0x4,r8
80006444:	49 0e       	lddpc	lr,80006484 <INTC_init_interrupts+0x48>
80006446:	30 07       	mov	r7,0
80006448:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000644a:	49 0c       	lddpc	r12,80006488 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000644c:	49 05       	lddpc	r5,8000648c <INTC_init_interrupts+0x50>
8000644e:	10 15       	sub	r5,r8
80006450:	fe 76 08 00 	mov	r6,-63488
80006454:	c1 08       	rjmp	80006474 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006456:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80006458:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000645a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000645c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006460:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006462:	10 3a       	cp.w	r10,r8
80006464:	fe 9b ff fc 	brhi	8000645c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006468:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000646c:	2f f7       	sub	r7,-1
8000646e:	2f 8e       	sub	lr,-8
80006470:	59 37       	cp.w	r7,19
80006472:	c0 50       	breq	8000647c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006474:	7c 08       	ld.w	r8,lr[0x0]
80006476:	58 08       	cp.w	r8,0
80006478:	ce f1       	brne	80006456 <INTC_init_interrupts+0x1a>
8000647a:	cf 7b       	rjmp	80006468 <INTC_init_interrupts+0x2c>
8000647c:	d8 22       	popm	r4-r7,pc
8000647e:	00 00       	add	r0,r0
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	de 00       	acall	0xe0
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	ec f4 80 00 	ld.w	r4,r6[-32768]
8000648a:	63 b8       	ld.w	r8,r1[0x6c]
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	df 04       	*unknown*

80006490 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006490:	fe 78 08 00 	mov	r8,-63488
80006494:	e0 69 00 83 	mov	r9,131
80006498:	f2 0c 01 0c 	sub	r12,r9,r12
8000649c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800064a0:	f2 ca ff c0 	sub	r10,r9,-64
800064a4:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800064a8:	58 08       	cp.w	r8,0
800064aa:	c0 21       	brne	800064ae <_get_interrupt_handler+0x1e>
800064ac:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800064ae:	f0 08 12 00 	clz	r8,r8
800064b2:	48 5a       	lddpc	r10,800064c4 <_get_interrupt_handler+0x34>
800064b4:	f4 09 00 39 	add	r9,r10,r9<<0x3
800064b8:	f0 08 11 1f 	rsub	r8,r8,31
800064bc:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800064be:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800064c2:	5e fc       	retal	r12
800064c4:	80 00       	ld.sh	r0,r0[0x0]
800064c6:	ec f4 78 a8 	ld.w	r4,r6[30888]

800064c8 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800064c8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800064ca:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800064ce:	99 a8       	st.w	r12[0x28],r8
}
800064d0:	5e fc       	retal	r12
800064d2:	d7 03       	nop

800064d4 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800064d4:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800064d6:	ec 5b bb 9f 	cp.w	r11,899999
800064da:	e0 8b 00 04 	brhi	800064e2 <pm_enable_osc0_crystal+0xe>
800064de:	30 4b       	mov	r11,4
800064e0:	c1 38       	rjmp	80006506 <pm_enable_osc0_crystal+0x32>
800064e2:	e0 68 c6 bf 	mov	r8,50879
800064e6:	ea 18 00 2d 	orh	r8,0x2d
800064ea:	10 3b       	cp.w	r11,r8
800064ec:	e0 8b 00 04 	brhi	800064f4 <pm_enable_osc0_crystal+0x20>
800064f0:	30 5b       	mov	r11,5
800064f2:	c0 a8       	rjmp	80006506 <pm_enable_osc0_crystal+0x32>
800064f4:	e0 68 12 00 	mov	r8,4608
800064f8:	ea 18 00 7a 	orh	r8,0x7a
800064fc:	10 3b       	cp.w	r11,r8
800064fe:	f9 bb 03 06 	movlo	r11,6
80006502:	f9 bb 02 07 	movhs	r11,7
80006506:	f0 1f 00 02 	mcall	8000650c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000650a:	d8 02       	popm	pc
8000650c:	80 00       	ld.sh	r0,r0[0x0]
8000650e:	64 c8       	ld.w	r8,r2[0x30]

80006510 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006510:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80006512:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006516:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80006518:	78 08       	ld.w	r8,r12[0x0]
8000651a:	a3 a8       	sbr	r8,0x2
8000651c:	99 08       	st.w	r12[0x0],r8
}
8000651e:	5e fc       	retal	r12

80006520 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006520:	79 58       	ld.w	r8,r12[0x54]
80006522:	e2 18 00 80 	andl	r8,0x80,COH
80006526:	cf d0       	breq	80006520 <pm_wait_for_clk0_ready>
}
80006528:	5e fc       	retal	r12
8000652a:	d7 03       	nop

8000652c <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000652c:	eb cd 40 80 	pushm	r7,lr
80006530:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80006532:	f0 1f 00 04 	mcall	80006540 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80006536:	0e 9c       	mov	r12,r7
80006538:	f0 1f 00 03 	mcall	80006544 <pm_enable_clk0+0x18>
}
8000653c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	65 10       	ld.w	r0,r2[0x44]
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	65 20       	ld.w	r0,r2[0x48]

80006548 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80006548:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
8000654a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000654e:	99 c8       	st.w	r12[0x30],r8
}
80006550:	5e fc       	retal	r12
80006552:	d7 03       	nop

80006554 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80006554:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80006556:	30 1b       	mov	r11,1
80006558:	f0 1f 00 02 	mcall	80006560 <pm_enable_osc32_crystal+0xc>
}
8000655c:	d8 02       	popm	pc
8000655e:	00 00       	add	r0,r0
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	65 48       	ld.w	r8,r2[0x50]

80006564 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80006564:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80006566:	30 19       	mov	r9,1
80006568:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
8000656c:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80006570:	99 c8       	st.w	r12[0x30],r8
}
80006572:	5e fc       	retal	r12

80006574 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80006574:	79 58       	ld.w	r8,r12[0x54]
80006576:	e2 18 02 00 	andl	r8,0x200,COH
8000657a:	cf d0       	breq	80006574 <pm_wait_for_clk32_ready>
}
8000657c:	5e fc       	retal	r12
8000657e:	d7 03       	nop

80006580 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80006580:	eb cd 40 80 	pushm	r7,lr
80006584:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80006586:	f0 1f 00 04 	mcall	80006594 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000658a:	0e 9c       	mov	r12,r7
8000658c:	f0 1f 00 03 	mcall	80006598 <pm_enable_clk32+0x18>
}
80006590:	e3 cd 80 80 	ldm	sp++,r7,pc
80006594:	80 00       	ld.sh	r0,r0[0x0]
80006596:	65 64       	ld.w	r4,r2[0x58]
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	65 74       	ld.w	r4,r2[0x5c]

8000659c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000659c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800065a0:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800065a4:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800065a6:	09 f7       	ld.ub	r7,r4[0x7]
800065a8:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800065ac:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800065b0:	09 b4       	ld.ub	r4,r4[0x3]
800065b2:	08 96       	mov	r6,r4
800065b4:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800065b8:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800065bc:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800065c0:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800065c4:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800065c8:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800065cc:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800065d0:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800065d4:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800065d6:	79 58       	ld.w	r8,r12[0x54]
800065d8:	e2 18 00 20 	andl	r8,0x20,COH
800065dc:	cf d0       	breq	800065d6 <pm_cksel+0x3a>
}
800065de:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800065e2 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800065e2:	eb cd 40 80 	pushm	r7,lr
800065e6:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800065e8:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800065ea:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800065ee:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800065f2:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800065f6:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800065fa:	2f 8b       	sub	r11,-8
800065fc:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006600:	e3 cd 80 80 	ldm	sp++,r7,pc

80006604 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006604:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80006606:	2f 8b       	sub	r11,-8
80006608:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000660c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80006610:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80006614:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80006618:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000661c:	d8 02       	popm	pc

8000661e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000661e:	2f 8b       	sub	r11,-8
80006620:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80006624:	a1 a8       	sbr	r8,0x0
80006626:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000662a:	5e fc       	retal	r12

8000662c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000662c:	79 58       	ld.w	r8,r12[0x54]
8000662e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006632:	cf d0       	breq	8000662c <pm_wait_for_pll0_locked>
}
80006634:	5e fc       	retal	r12

80006636 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80006636:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80006638:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000663c:	99 08       	st.w	r12[0x0],r8
}
8000663e:	5e fc       	retal	r12

80006640 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80006640:	eb cd 40 c0 	pushm	r6-r7,lr
80006644:	18 97       	mov	r7,r12
80006646:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80006648:	f0 1f 00 06 	mcall	80006660 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000664c:	0c 9b       	mov	r11,r6
8000664e:	0e 9c       	mov	r12,r7
80006650:	f0 1f 00 05 	mcall	80006664 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80006654:	30 1b       	mov	r11,1
80006656:	0e 9c       	mov	r12,r7
80006658:	f0 1f 00 04 	mcall	80006668 <pm_switch_to_osc0+0x28>
}
8000665c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006660:	80 00       	ld.sh	r0,r0[0x0]
80006662:	64 d4       	ld.w	r4,r2[0x34]
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	65 2c       	ld.w	r12,r2[0x48]
80006668:	80 00       	ld.sh	r0,r0[0x0]
8000666a:	66 36       	ld.w	r6,r3[0xc]

8000666c <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
8000666c:	78 0c       	ld.w	r12,r12[0x0]
}
8000666e:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80006672:	5e fc       	retal	r12

80006674 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80006674:	eb cd 40 c0 	pushm	r6-r7,lr
80006678:	18 97       	mov	r7,r12
8000667a:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
8000667c:	0e 9c       	mov	r12,r7
8000667e:	f0 1f 00 06 	mcall	80006694 <rtc_set_value+0x20>
80006682:	cf d1       	brne	8000667c <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80006684:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80006686:	0e 9c       	mov	r12,r7
80006688:	f0 1f 00 03 	mcall	80006694 <rtc_set_value+0x20>
8000668c:	cf d1       	brne	80006686 <rtc_set_value+0x12>
}
8000668e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006692:	00 00       	add	r0,r0
80006694:	80 00       	ld.sh	r0,r0[0x0]
80006696:	66 6c       	ld.w	r12,r3[0x18]

80006698 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80006698:	eb cd 40 80 	pushm	r7,lr
8000669c:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
8000669e:	0e 9c       	mov	r12,r7
800066a0:	f0 1f 00 06 	mcall	800066b8 <rtc_enable+0x20>
800066a4:	cf d1       	brne	8000669e <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800066a6:	6e 08       	ld.w	r8,r7[0x0]
800066a8:	a1 a8       	sbr	r8,0x0
800066aa:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
800066ac:	0e 9c       	mov	r12,r7
800066ae:	f0 1f 00 03 	mcall	800066b8 <rtc_enable+0x20>
800066b2:	cf d1       	brne	800066ac <rtc_enable+0x14>
}
800066b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800066b8:	80 00       	ld.sh	r0,r0[0x0]
800066ba:	66 6c       	ld.w	r12,r3[0x18]

800066bc <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
800066bc:	30 18       	mov	r8,1
800066be:	99 48       	st.w	r12[0x10],r8
}
800066c0:	5e fc       	retal	r12
800066c2:	d7 03       	nop

800066c4 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
800066c4:	eb cd 40 c0 	pushm	r6-r7,lr
800066c8:	18 97       	mov	r7,r12
800066ca:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800066cc:	0e 9c       	mov	r12,r7
800066ce:	f0 1f 00 06 	mcall	800066e4 <rtc_set_top_value+0x20>
800066d2:	cf d1       	brne	800066cc <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
800066d4:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800066d6:	0e 9c       	mov	r12,r7
800066d8:	f0 1f 00 03 	mcall	800066e4 <rtc_set_top_value+0x20>
800066dc:	cf d1       	brne	800066d6 <rtc_set_top_value+0x12>
}
800066de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066e2:	00 00       	add	r0,r0
800066e4:	80 00       	ld.sh	r0,r0[0x0]
800066e6:	66 6c       	ld.w	r12,r3[0x18]

800066e8 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800066e8:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
800066ec:	e6 18 00 01 	andh	r8,0x1,COH
800066f0:	c0 71       	brne	800066fe <rtc_clear_interrupt+0x16>
800066f2:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
800066f4:	30 18       	mov	r8,1
800066f6:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
800066f8:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
800066fa:	d5 03       	csrf	0x10
800066fc:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
800066fe:	30 18       	mov	r8,1
80006700:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006702:	78 78       	ld.w	r8,r12[0x1c]
80006704:	5e fc       	retal	r12
80006706:	d7 03       	nop

80006708 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80006708:	eb cd 40 e0 	pushm	r5-r7,lr
8000670c:	18 97       	mov	r7,r12
8000670e:	16 96       	mov	r6,r11
80006710:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80006712:	30 18       	mov	r8,1
80006714:	f0 0b 18 00 	cp.b	r11,r8
80006718:	5f b9       	srhi	r9
8000671a:	30 f8       	mov	r8,15
8000671c:	f0 0a 18 00 	cp.b	r10,r8
80006720:	5f b8       	srhi	r8
80006722:	f3 e8 10 08 	or	r8,r9,r8
80006726:	c0 30       	breq	8000672c <rtc_init+0x24>
80006728:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
8000672c:	30 18       	mov	r8,1
8000672e:	f0 0b 18 00 	cp.b	r11,r8
80006732:	c0 a1       	brne	80006746 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80006734:	fe 7c 0c 00 	mov	r12,-62464
80006738:	f0 1f 00 0f 	mcall	80006774 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
8000673c:	30 0b       	mov	r11,0
8000673e:	fe 7c 0c 00 	mov	r12,-62464
80006742:	f0 1f 00 0e 	mcall	80006778 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
80006746:	0e 9c       	mov	r12,r7
80006748:	f0 1f 00 0d 	mcall	8000677c <rtc_init+0x74>
8000674c:	cf d1       	brne	80006746 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
8000674e:	a3 76       	lsl	r6,0x3
80006750:	b1 a6       	sbr	r6,0x10
80006752:	ed e5 10 85 	or	r5,r6,r5<<0x8
80006756:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80006758:	0e 9c       	mov	r12,r7
8000675a:	f0 1f 00 09 	mcall	8000677c <rtc_init+0x74>
8000675e:	cf d1       	brne	80006758 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80006760:	30 0b       	mov	r11,0
80006762:	0e 9c       	mov	r12,r7
80006764:	f0 1f 00 07 	mcall	80006780 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80006768:	3f fb       	mov	r11,-1
8000676a:	0e 9c       	mov	r12,r7
8000676c:	f0 1f 00 06 	mcall	80006784 <rtc_init+0x7c>
80006770:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006774:	80 00       	ld.sh	r0,r0[0x0]
80006776:	65 54       	ld.w	r4,r2[0x54]
80006778:	80 00       	ld.sh	r0,r0[0x0]
8000677a:	65 80       	ld.w	r0,r2[0x60]
8000677c:	80 00       	ld.sh	r0,r0[0x0]
8000677e:	66 6c       	ld.w	r12,r3[0x18]
80006780:	80 00       	ld.sh	r0,r0[0x0]
80006782:	66 74       	ld.w	r4,r3[0x1c]
80006784:	80 00       	ld.sh	r0,r0[0x0]
80006786:	66 c4       	ld.w	r4,r3[0x30]

80006788 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80006788:	f8 c8 00 01 	sub	r8,r12,1
8000678c:	f0 0b 00 0b 	add	r11,r8,r11
80006790:	f6 0c 0d 0a 	divu	r10,r11,r12
80006794:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80006796:	f4 c8 00 01 	sub	r8,r10,1
8000679a:	e0 48 00 fe 	cp.w	r8,254
8000679e:	e0 88 00 03 	brls	800067a4 <getBaudDiv+0x1c>
800067a2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800067a4:	5c 8c       	casts.h	r12
}
800067a6:	5e fc       	retal	r12

800067a8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800067a8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800067ac:	30 18       	mov	r8,1
800067ae:	f0 09 18 00 	cp.b	r9,r8
800067b2:	e0 88 00 04 	brls	800067ba <spi_initMaster+0x12>
800067b6:	30 2c       	mov	r12,2
800067b8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800067ba:	e0 68 00 80 	mov	r8,128
800067be:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800067c0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800067c2:	30 19       	mov	r9,1
800067c4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800067c8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800067cc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800067d0:	30 09       	mov	r9,0
800067d2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800067d6:	30 fa       	mov	r10,15
800067d8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800067dc:	99 18       	st.w	r12[0x4],r8
800067de:	5e f9       	retal	r9

800067e0 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800067e0:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800067e2:	30 18       	mov	r8,1
800067e4:	f0 0b 18 00 	cp.b	r11,r8
800067e8:	5f be       	srhi	lr
800067ea:	f0 0a 18 00 	cp.b	r10,r8
800067ee:	5f b8       	srhi	r8
800067f0:	fd e8 10 08 	or	r8,lr,r8
800067f4:	c0 30       	breq	800067fa <spi_selectionMode+0x1a>
800067f6:	30 2c       	mov	r12,2
800067f8:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800067fa:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800067fc:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006800:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80006804:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80006808:	99 18       	st.w	r12[0x4],r8
8000680a:	d8 0a       	popm	pc,r12=0

8000680c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000680c:	30 18       	mov	r8,1
8000680e:	99 08       	st.w	r12[0x0],r8
}
80006810:	5e fc       	retal	r12

80006812 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80006812:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006816:	c0 58       	rjmp	80006820 <spi_write+0xe>
		if (!timeout--) {
80006818:	58 08       	cp.w	r8,0
8000681a:	c0 21       	brne	8000681e <spi_write+0xc>
8000681c:	5e ff       	retal	1
8000681e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006820:	78 49       	ld.w	r9,r12[0x10]
80006822:	e2 19 00 02 	andl	r9,0x2,COH
80006826:	cf 90       	breq	80006818 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80006828:	5c 7b       	castu.h	r11
8000682a:	99 3b       	st.w	r12[0xc],r11
8000682c:	5e fd       	retal	0

8000682e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000682e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006832:	c0 58       	rjmp	8000683c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80006834:	58 08       	cp.w	r8,0
80006836:	c0 21       	brne	8000683a <spi_read+0xc>
80006838:	5e ff       	retal	1
8000683a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000683c:	78 49       	ld.w	r9,r12[0x10]
8000683e:	e2 19 02 01 	andl	r9,0x201,COH
80006842:	e0 49 02 01 	cp.w	r9,513
80006846:	cf 71       	brne	80006834 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80006848:	78 28       	ld.w	r8,r12[0x8]
8000684a:	b6 08       	st.h	r11[0x0],r8
8000684c:	5e fd       	retal	0
8000684e:	d7 03       	nop

80006850 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80006850:	eb cd 40 f8 	pushm	r3-r7,lr
80006854:	18 95       	mov	r5,r12
80006856:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006858:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000685c:	30 38       	mov	r8,3
8000685e:	f0 06 18 00 	cp.b	r6,r8
80006862:	e0 8b 00 5e 	brhi	8000691e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80006866:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000686a:	30 18       	mov	r8,1
8000686c:	f0 04 18 00 	cp.b	r4,r8
80006870:	e0 8b 00 57 	brhi	8000691e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80006874:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006878:	30 78       	mov	r8,7
8000687a:	f0 03 18 00 	cp.b	r3,r8
8000687e:	e0 88 00 50 	brls	8000691e <spi_setupChipReg+0xce>
80006882:	31 08       	mov	r8,16
80006884:	f0 03 18 00 	cp.b	r3,r8
80006888:	e0 8b 00 4b 	brhi	8000691e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000688c:	14 9b       	mov	r11,r10
8000688e:	6e 1c       	ld.w	r12,r7[0x4]
80006890:	f0 1f 00 26 	mcall	80006928 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80006894:	c4 55       	brlt	8000691e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80006896:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80006898:	ec 09 16 01 	lsr	r9,r6,0x1
8000689c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800068a0:	ec 16 00 01 	eorl	r6,0x1
800068a4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800068a8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800068ac:	20 83       	sub	r3,8
800068ae:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800068b2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800068b6:	ef 39 00 09 	ld.ub	r9,r7[9]
800068ba:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800068be:	ef 39 00 0a 	ld.ub	r9,r7[10]
800068c2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800068c6:	0f 89       	ld.ub	r9,r7[0x0]
800068c8:	30 1a       	mov	r10,1
800068ca:	f4 09 18 00 	cp.b	r9,r10
800068ce:	c0 d0       	breq	800068e8 <spi_setupChipReg+0x98>
800068d0:	c0 a3       	brcs	800068e4 <spi_setupChipReg+0x94>
800068d2:	30 2a       	mov	r10,2
800068d4:	f4 09 18 00 	cp.b	r9,r10
800068d8:	c0 a0       	breq	800068ec <spi_setupChipReg+0x9c>
800068da:	30 3a       	mov	r10,3
800068dc:	f4 09 18 00 	cp.b	r9,r10
800068e0:	c1 f1       	brne	8000691e <spi_setupChipReg+0xce>
800068e2:	c0 78       	rjmp	800068f0 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800068e4:	8b c8       	st.w	r5[0x30],r8
		break;
800068e6:	c0 68       	rjmp	800068f2 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800068e8:	8b d8       	st.w	r5[0x34],r8
		break;
800068ea:	c0 48       	rjmp	800068f2 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800068ec:	8b e8       	st.w	r5[0x38],r8
		break;
800068ee:	c0 28       	rjmp	800068f2 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800068f0:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800068f2:	48 f8       	lddpc	r8,8000692c <spi_setupChipReg+0xdc>
800068f4:	70 08       	ld.w	r8,r8[0x0]
800068f6:	58 08       	cp.w	r8,0
800068f8:	c1 61       	brne	80006924 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800068fa:	30 0b       	mov	r11,0
800068fc:	30 1c       	mov	r12,1
800068fe:	f0 1f 00 0d 	mcall	80006930 <spi_setupChipReg+0xe0>
80006902:	48 b8       	lddpc	r8,8000692c <spi_setupChipReg+0xdc>
80006904:	91 0c       	st.w	r8[0x0],r12
80006906:	58 0c       	cp.w	r12,0
80006908:	c0 a0       	breq	8000691c <spi_setupChipReg+0xcc>
8000690a:	30 09       	mov	r9,0
8000690c:	12 9a       	mov	r10,r9
8000690e:	12 9b       	mov	r11,r9
80006910:	f0 1f 00 09 	mcall	80006934 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80006914:	48 68       	lddpc	r8,8000692c <spi_setupChipReg+0xdc>
80006916:	70 08       	ld.w	r8,r8[0x0]
80006918:	58 08       	cp.w	r8,0
8000691a:	c0 51       	brne	80006924 <spi_setupChipReg+0xd4>
8000691c:	c0 08       	rjmp	8000691c <spi_setupChipReg+0xcc>
8000691e:	30 2c       	mov	r12,2
80006920:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006924:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006928:	80 00       	ld.sh	r0,r0[0x0]
8000692a:	67 88       	ld.w	r8,r3[0x60]
8000692c:	00 00       	add	r0,r0
8000692e:	bd 40       	asr	r0,0x1c
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	74 74       	ld.w	r4,r10[0x1c]
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	73 1c       	ld.w	r12,r9[0x44]

80006938 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006938:	d4 01       	pushm	lr
8000693a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000693e:	c0 58       	rjmp	80006948 <spi_unselectChip+0x10>
		if (!timeout--) {
80006940:	58 08       	cp.w	r8,0
80006942:	c0 21       	brne	80006946 <spi_unselectChip+0xe>
80006944:	da 0a       	popm	pc,r12=1
80006946:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006948:	78 49       	ld.w	r9,r12[0x10]
8000694a:	e2 19 02 00 	andl	r9,0x200,COH
8000694e:	cf 90       	breq	80006940 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006950:	78 18       	ld.w	r8,r12[0x4]
80006952:	ea 18 00 0f 	orh	r8,0xf
80006956:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80006958:	fc 18 01 00 	movh	r8,0x100
8000695c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000695e:	30 09       	mov	r9,0
80006960:	12 9a       	mov	r10,r9
80006962:	12 9b       	mov	r11,r9
80006964:	48 38       	lddpc	r8,80006970 <spi_unselectChip+0x38>
80006966:	70 0c       	ld.w	r12,r8[0x0]
80006968:	f0 1f 00 03 	mcall	80006974 <spi_unselectChip+0x3c>
8000696c:	d8 0a       	popm	pc,r12=0
8000696e:	00 00       	add	r0,r0
80006970:	00 00       	add	r0,r0
80006972:	bd 40       	asr	r0,0x1c
80006974:	80 00       	ld.sh	r0,r0[0x0]
80006976:	73 1c       	ld.w	r12,r9[0x44]

80006978 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006978:	eb cd 40 f8 	pushm	r3-r7,lr
8000697c:	18 94       	mov	r4,r12
8000697e:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80006980:	49 a6       	lddpc	r6,800069e8 <spi_selectChip+0x70>
80006982:	30 07       	mov	r7,0
80006984:	31 45       	mov	r5,20
80006986:	0e 99       	mov	r9,r7
80006988:	0a 9a       	mov	r10,r5
8000698a:	0e 9b       	mov	r11,r7
8000698c:	6c 0c       	ld.w	r12,r6[0x0]
8000698e:	f0 1f 00 18 	mcall	800069ec <spi_selectChip+0x74>
80006992:	cf a0       	breq	80006986 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006994:	68 18       	ld.w	r8,r4[0x4]
80006996:	ea 18 00 0f 	orh	r8,0xf
8000699a:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000699c:	68 18       	ld.w	r8,r4[0x4]
8000699e:	e2 18 00 04 	andl	r8,0x4,COH
800069a2:	c1 10       	breq	800069c4 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800069a4:	30 e8       	mov	r8,14
800069a6:	f0 03 18 00 	cp.b	r3,r8
800069aa:	e0 8b 00 1c 	brhi	800069e2 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800069ae:	68 19       	ld.w	r9,r4[0x4]
800069b0:	e6 08 15 10 	lsl	r8,r3,0x10
800069b4:	ea 18 ff f0 	orh	r8,0xfff0
800069b8:	e8 18 ff ff 	orl	r8,0xffff
800069bc:	12 68       	and	r8,r9
800069be:	89 18       	st.w	r4[0x4],r8
800069c0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800069c4:	30 38       	mov	r8,3
800069c6:	f0 03 18 00 	cp.b	r3,r8
800069ca:	e0 8b 00 0c 	brhi	800069e2 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800069ce:	68 19       	ld.w	r9,r4[0x4]
800069d0:	2f 03       	sub	r3,-16
800069d2:	30 18       	mov	r8,1
800069d4:	f0 03 09 48 	lsl	r8,r8,r3
800069d8:	5c d8       	com	r8
800069da:	12 68       	and	r8,r9
800069dc:	89 18       	st.w	r4[0x4],r8
800069de:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800069e2:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800069e4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800069e8:	00 00       	add	r0,r0
800069ea:	bd 40       	asr	r0,0x1c
800069ec:	80 00       	ld.sh	r0,r0[0x0]
800069ee:	71 10       	ld.w	r0,r8[0x44]

800069f0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800069f0:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800069f2:	f6 08 15 04 	lsl	r8,r11,0x4
800069f6:	14 38       	cp.w	r8,r10
800069f8:	f9 b8 08 10 	movls	r8,16
800069fc:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006a00:	f0 0b 02 4b 	mul	r11,r8,r11
80006a04:	f6 09 16 01 	lsr	r9,r11,0x1
80006a08:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006a0c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006a10:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006a14:	f2 cb 00 01 	sub	r11,r9,1
80006a18:	e0 4b ff fe 	cp.w	r11,65534
80006a1c:	e0 88 00 03 	brls	80006a22 <usart_set_async_baudrate+0x32>
80006a20:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80006a22:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006a24:	e8 6e 00 00 	mov	lr,524288
80006a28:	59 08       	cp.w	r8,16
80006a2a:	fc 08 17 10 	movne	r8,lr
80006a2e:	f9 b8 00 00 	moveq	r8,0
80006a32:	e4 1b ff f7 	andh	r11,0xfff7
80006a36:	e0 1b fe cf 	andl	r11,0xfecf
80006a3a:	16 48       	or	r8,r11
80006a3c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006a3e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80006a42:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006a46:	99 89       	st.w	r12[0x20],r9
80006a48:	d8 0a       	popm	pc,r12=0

80006a4a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006a4a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006a4c:	e2 18 00 02 	andl	r8,0x2,COH
80006a50:	c0 31       	brne	80006a56 <usart_write_char+0xc>
80006a52:	30 2c       	mov	r12,2
80006a54:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006a56:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006a5a:	99 7b       	st.w	r12[0x1c],r11
80006a5c:	5e fd       	retal	0
80006a5e:	d7 03       	nop

80006a60 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006a60:	eb cd 40 e0 	pushm	r5-r7,lr
80006a64:	18 96       	mov	r6,r12
80006a66:	16 95       	mov	r5,r11
80006a68:	e0 67 27 0f 	mov	r7,9999
80006a6c:	c0 68       	rjmp	80006a78 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006a6e:	58 07       	cp.w	r7,0
80006a70:	c0 31       	brne	80006a76 <usart_putchar+0x16>
80006a72:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80006a76:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006a78:	0a 9b       	mov	r11,r5
80006a7a:	0c 9c       	mov	r12,r6
80006a7c:	f0 1f 00 03 	mcall	80006a88 <usart_putchar+0x28>
80006a80:	cf 71       	brne	80006a6e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80006a82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006a86:	00 00       	add	r0,r0
80006a88:	80 00       	ld.sh	r0,r0[0x0]
80006a8a:	6a 4a       	ld.w	r10,r5[0x10]

80006a8c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006a8c:	78 58       	ld.w	r8,r12[0x14]
80006a8e:	e2 18 00 e0 	andl	r8,0xe0,COH
80006a92:	c0 30       	breq	80006a98 <usart_read_char+0xc>
80006a94:	30 4c       	mov	r12,4
80006a96:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006a98:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006a9a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006a9e:	c0 31       	brne	80006aa4 <usart_read_char+0x18>
80006aa0:	30 3c       	mov	r12,3
80006aa2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80006aa4:	78 68       	ld.w	r8,r12[0x18]
80006aa6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006aaa:	97 08       	st.w	r11[0x0],r8
80006aac:	5e fd       	retal	0
80006aae:	d7 03       	nop

80006ab0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80006ab0:	eb cd 40 c0 	pushm	r6-r7,lr
80006ab4:	20 1d       	sub	sp,4
80006ab6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006ab8:	1a 97       	mov	r7,sp
80006aba:	1a 9b       	mov	r11,sp
80006abc:	0c 9c       	mov	r12,r6
80006abe:	f0 1f 00 07 	mcall	80006ad8 <usart_getchar+0x28>
80006ac2:	58 3c       	cp.w	r12,3
80006ac4:	cf b0       	breq	80006aba <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80006ac6:	58 4c       	cp.w	r12,4
80006ac8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006acc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006ad0:	2f fd       	sub	sp,-4
80006ad2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ad6:	00 00       	add	r0,r0
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	6a 8c       	ld.w	r12,r5[0x20]

80006adc <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006adc:	eb cd 40 c0 	pushm	r6-r7,lr
80006ae0:	18 96       	mov	r6,r12
80006ae2:	16 97       	mov	r7,r11
  while (*string != '\0')
80006ae4:	17 8b       	ld.ub	r11,r11[0x0]
80006ae6:	58 0b       	cp.w	r11,0
80006ae8:	c0 80       	breq	80006af8 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006aea:	2f f7       	sub	r7,-1
80006aec:	0c 9c       	mov	r12,r6
80006aee:	f0 1f 00 04 	mcall	80006afc <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80006af2:	0f 8b       	ld.ub	r11,r7[0x0]
80006af4:	58 0b       	cp.w	r11,0
80006af6:	cf a1       	brne	80006aea <usart_write_line+0xe>
80006af8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006afc:	80 00       	ld.sh	r0,r0[0x0]
80006afe:	6a 60       	ld.w	r0,r5[0x18]

80006b00 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006b00:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006b04:	e6 18 00 01 	andh	r8,0x1,COH
80006b08:	c0 71       	brne	80006b16 <usart_reset+0x16>
80006b0a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006b0c:	3f f8       	mov	r8,-1
80006b0e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006b10:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80006b12:	d5 03       	csrf	0x10
80006b14:	c0 48       	rjmp	80006b1c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006b16:	3f f8       	mov	r8,-1
80006b18:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006b1a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006b1c:	30 08       	mov	r8,0
80006b1e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006b20:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80006b22:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006b24:	ea 68 61 0c 	mov	r8,680204
80006b28:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006b2a:	5e fc       	retal	r12

80006b2c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006b2c:	eb cd 40 e0 	pushm	r5-r7,lr
80006b30:	18 96       	mov	r6,r12
80006b32:	16 97       	mov	r7,r11
80006b34:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006b36:	f0 1f 00 2f 	mcall	80006bf0 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006b3a:	58 07       	cp.w	r7,0
80006b3c:	c5 80       	breq	80006bec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006b3e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006b40:	30 49       	mov	r9,4
80006b42:	f2 08 18 00 	cp.b	r8,r9
80006b46:	e0 88 00 53 	brls	80006bec <usart_init_rs232+0xc0>
80006b4a:	30 99       	mov	r9,9
80006b4c:	f2 08 18 00 	cp.b	r8,r9
80006b50:	e0 8b 00 4e 	brhi	80006bec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80006b54:	0f d9       	ld.ub	r9,r7[0x5]
80006b56:	30 78       	mov	r8,7
80006b58:	f0 09 18 00 	cp.b	r9,r8
80006b5c:	e0 8b 00 48 	brhi	80006bec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006b60:	8e 39       	ld.sh	r9,r7[0x6]
80006b62:	e0 68 01 01 	mov	r8,257
80006b66:	f0 09 19 00 	cp.h	r9,r8
80006b6a:	e0 8b 00 41 	brhi	80006bec <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006b6e:	ef 39 00 08 	ld.ub	r9,r7[8]
80006b72:	30 38       	mov	r8,3
80006b74:	f0 09 18 00 	cp.b	r9,r8
80006b78:	e0 8b 00 3a 	brhi	80006bec <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006b7c:	0a 9a       	mov	r10,r5
80006b7e:	6e 0b       	ld.w	r11,r7[0x0]
80006b80:	0c 9c       	mov	r12,r6
80006b82:	f0 1f 00 1d 	mcall	80006bf4 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006b86:	58 1c       	cp.w	r12,1
80006b88:	c3 20       	breq	80006bec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006b8a:	0f c8       	ld.ub	r8,r7[0x4]
80006b8c:	30 99       	mov	r9,9
80006b8e:	f2 08 18 00 	cp.b	r8,r9
80006b92:	c0 51       	brne	80006b9c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006b94:	6c 18       	ld.w	r8,r6[0x4]
80006b96:	b1 b8       	sbr	r8,0x11
80006b98:	8d 18       	st.w	r6[0x4],r8
80006b9a:	c0 68       	rjmp	80006ba6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006b9c:	6c 19       	ld.w	r9,r6[0x4]
80006b9e:	20 58       	sub	r8,5
80006ba0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006ba4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006ba6:	6c 19       	ld.w	r9,r6[0x4]
80006ba8:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006bac:	0f d8       	ld.ub	r8,r7[0x5]
80006bae:	a9 78       	lsl	r8,0x9
80006bb0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006bb4:	12 48       	or	r8,r9
80006bb6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006bb8:	8e 38       	ld.sh	r8,r7[0x6]
80006bba:	30 29       	mov	r9,2
80006bbc:	f2 08 19 00 	cp.h	r8,r9
80006bc0:	e0 88 00 09 	brls	80006bd2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006bc4:	6c 18       	ld.w	r8,r6[0x4]
80006bc6:	ad b8       	sbr	r8,0xd
80006bc8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006bca:	8e b8       	ld.uh	r8,r7[0x6]
80006bcc:	20 28       	sub	r8,2
80006bce:	8d a8       	st.w	r6[0x28],r8
80006bd0:	c0 68       	rjmp	80006bdc <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80006bd2:	6c 19       	ld.w	r9,r6[0x4]
80006bd4:	5c 78       	castu.h	r8
80006bd6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006bda:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006bdc:	6c 18       	ld.w	r8,r6[0x4]
80006bde:	e0 18 ff f0 	andl	r8,0xfff0
80006be2:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006be4:	35 08       	mov	r8,80
80006be6:	8d 08       	st.w	r6[0x0],r8
80006be8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006bec:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	6b 00       	ld.w	r0,r5[0x40]
80006bf4:	80 00       	ld.sh	r0,r0[0x0]
80006bf6:	69 f0       	ld.w	r0,r4[0x7c]

80006bf8 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006bf8:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006bfc:	fe c0 8d fc 	sub	r0,pc,-29188

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006c00:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006c04:	d5 53       	csrf	0x15
  cp      r0, r1
80006c06:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006c08:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006c0c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006c0e:	c0 62       	brcc	80006c1a <idata_load_loop_end>
  cp      r0, r1
80006c10:	48 92       	lddpc	r2,80006c34 <udata_clear_loop_end+0x4>

80006c12 <idata_load_loop>:
  brlo    idata_load_loop
80006c12:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006c14:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006c16:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006c18:	cf d3       	brcs	80006c12 <idata_load_loop>

80006c1a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006c1a:	e0 60 0a 58 	mov	r0,2648
  mov     r2, 0
  mov     r3, 0
80006c1e:	e0 61 bd 50 	mov	r1,48464
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006c22:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006c24:	c0 62       	brcc	80006c30 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006c26:	30 02       	mov	r2,0
80006c28:	30 03       	mov	r3,0

80006c2a <udata_clear_loop>:
80006c2a:	a1 22       	st.d	r0++,r2
80006c2c:	02 30       	cp.w	r0,r1
80006c2e:	cf e3       	brcs	80006c2a <udata_clear_loop>

80006c30 <udata_clear_loop_end>:
80006c30:	fe cf e9 28 	sub	pc,pc,-5848
80006c34:	80 00       	ld.sh	r0,r0[0x0]
80006c36:	f6 28 f8 c8 	sub	r8,-591672

80006c38 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006c38:	f8 c8 ff f8 	sub	r8,r12,-8
80006c3c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006c3e:	3f f9       	mov	r9,-1
80006c40:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006c42:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006c44:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006c46:	30 08       	mov	r8,0
80006c48:	99 08       	st.w	r12[0x0],r8
}
80006c4a:	5e fc       	retal	r12

80006c4c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006c4c:	30 08       	mov	r8,0
80006c4e:	99 48       	st.w	r12[0x10],r8
}
80006c50:	5e fc       	retal	r12

80006c52 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006c52:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006c54:	70 19       	ld.w	r9,r8[0x4]
80006c56:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006c58:	78 19       	ld.w	r9,r12[0x4]
80006c5a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006c5c:	70 19       	ld.w	r9,r8[0x4]
80006c5e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006c60:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006c62:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006c64:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006c66:	78 08       	ld.w	r8,r12[0x0]
80006c68:	2f f8       	sub	r8,-1
80006c6a:	99 08       	st.w	r12[0x0],r8
}
80006c6c:	5e fc       	retal	r12

80006c6e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006c6e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006c70:	5b fa       	cp.w	r10,-1
80006c72:	c0 31       	brne	80006c78 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006c74:	78 48       	ld.w	r8,r12[0x10]
80006c76:	c0 c8       	rjmp	80006c8e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006c78:	f8 c8 ff f8 	sub	r8,r12,-8
80006c7c:	70 19       	ld.w	r9,r8[0x4]
80006c7e:	72 09       	ld.w	r9,r9[0x0]
80006c80:	12 3a       	cp.w	r10,r9
80006c82:	c0 63       	brcs	80006c8e <vListInsert+0x20>
80006c84:	70 18       	ld.w	r8,r8[0x4]
80006c86:	70 19       	ld.w	r9,r8[0x4]
80006c88:	72 09       	ld.w	r9,r9[0x0]
80006c8a:	12 3a       	cp.w	r10,r9
80006c8c:	cf c2       	brcc	80006c84 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006c8e:	70 19       	ld.w	r9,r8[0x4]
80006c90:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006c92:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80006c94:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006c96:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006c98:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006c9a:	78 08       	ld.w	r8,r12[0x0]
80006c9c:	2f f8       	sub	r8,-1
80006c9e:	99 08       	st.w	r12[0x0],r8
}
80006ca0:	5e fc       	retal	r12

80006ca2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006ca2:	78 18       	ld.w	r8,r12[0x4]
80006ca4:	78 29       	ld.w	r9,r12[0x8]
80006ca6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006ca8:	78 28       	ld.w	r8,r12[0x8]
80006caa:	78 19       	ld.w	r9,r12[0x4]
80006cac:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80006cae:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80006cb0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80006cb2:	18 39       	cp.w	r9,r12
80006cb4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80006cb8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006cbc:	30 09       	mov	r9,0
80006cbe:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80006cc0:	70 09       	ld.w	r9,r8[0x0]
80006cc2:	20 19       	sub	r9,1
80006cc4:	91 09       	st.w	r8[0x0],r9
}
80006cc6:	5e fc       	retal	r12

80006cc8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006cc8:	e0 68 08 08 	mov	r8,2056
80006ccc:	ea 18 08 08 	orh	r8,0x808
80006cd0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80006cd2:	e0 68 09 09 	mov	r8,2313
80006cd6:	ea 18 09 09 	orh	r8,0x909
80006cda:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006cdc:	e0 68 0a 0a 	mov	r8,2570
80006ce0:	ea 18 0a 0a 	orh	r8,0xa0a
80006ce4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80006ce6:	e0 68 0b 0b 	mov	r8,2827
80006cea:	ea 18 0b 0b 	orh	r8,0xb0b
80006cee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006cf0:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80006cf2:	e0 68 be ef 	mov	r8,48879
80006cf6:	ea 18 de ad 	orh	r8,0xdead
80006cfa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006cfc:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006cfe:	fc 18 00 40 	movh	r8,0x40
80006d02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80006d04:	e0 68 00 ff 	mov	r8,255
80006d08:	ea 18 ff 00 	orh	r8,0xff00
80006d0c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006d0e:	e0 68 01 01 	mov	r8,257
80006d12:	ea 18 01 01 	orh	r8,0x101
80006d16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006d18:	e0 68 02 02 	mov	r8,514
80006d1c:	ea 18 02 02 	orh	r8,0x202
80006d20:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006d22:	e0 68 03 03 	mov	r8,771
80006d26:	ea 18 03 03 	orh	r8,0x303
80006d2a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006d2c:	e0 68 04 04 	mov	r8,1028
80006d30:	ea 18 04 04 	orh	r8,0x404
80006d34:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80006d36:	e0 68 05 05 	mov	r8,1285
80006d3a:	ea 18 05 05 	orh	r8,0x505
80006d3e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006d40:	e0 68 06 06 	mov	r8,1542
80006d44:	ea 18 06 06 	orh	r8,0x606
80006d48:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006d4a:	e0 68 07 07 	mov	r8,1799
80006d4e:	ea 18 07 07 	orh	r8,0x707
80006d52:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006d54:	30 08       	mov	r8,0
80006d56:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006d58:	5e fc       	retal	r12
80006d5a:	d7 03       	nop

80006d5c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006d5c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006d5e:	48 38       	lddpc	r8,80006d68 <vPortEnterCritical+0xc>
80006d60:	70 09       	ld.w	r9,r8[0x0]
80006d62:	2f f9       	sub	r9,-1
80006d64:	91 09       	st.w	r8[0x0],r9
}
80006d66:	5e fc       	retal	r12
80006d68:	00 00       	add	r0,r0
80006d6a:	05 4c       	ld.w	r12,--r2

80006d6c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006d6c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006d6e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006d70:	30 0a       	mov	r10,0
80006d72:	14 9b       	mov	r11,r10
80006d74:	49 2c       	lddpc	r12,80006dbc <xPortStartScheduler+0x50>
80006d76:	f0 1f 00 13 	mcall	80006dc0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006d7a:	e0 68 5d c0 	mov	r8,24000
80006d7e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006d82:	30 08       	mov	r8,0
80006d84:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006d88:	e0 68 0d 78 	mov	r8,3448
80006d8c:	ea 18 00 00 	orh	r8,0x0
80006d90:	70 00       	ld.w	r0,r8[0x0]
80006d92:	60 0d       	ld.w	sp,r0[0x0]
80006d94:	1b 00       	ld.w	r0,sp++
80006d96:	e0 68 05 4c 	mov	r8,1356
80006d9a:	ea 18 00 00 	orh	r8,0x0
80006d9e:	91 00       	st.w	r8[0x0],r0
80006da0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006da4:	2f ed       	sub	sp,-8
80006da6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006daa:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006dae:	e3 b0 00 00 	mtsr	0x0,r0
80006db2:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006db6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006dba:	d8 0a       	popm	pc,r12=0
80006dbc:	80 00       	ld.sh	r0,r0[0x0]
80006dbe:	6e 88       	ld.w	r8,r7[0x20]
80006dc0:	80 00       	ld.sh	r0,r0[0x0]
80006dc2:	63 bc       	ld.w	r12,r1[0x6c]

80006dc4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006dc4:	20 6d       	sub	sp,24
80006dc6:	eb cd 00 ff 	pushm	r0-r7
80006dca:	fa c7 ff c0 	sub	r7,sp,-64
80006dce:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006dd2:	ef 40 ff e0 	st.w	r7[-32],r0
80006dd6:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006dda:	ef 40 ff e4 	st.w	r7[-28],r0
80006dde:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006de2:	e0 68 05 4c 	mov	r8,1356
80006de6:	ea 18 00 00 	orh	r8,0x0
80006dea:	70 00       	ld.w	r0,r8[0x0]
80006dec:	1a d0       	st.w	--sp,r0
80006dee:	f0 1f 00 1a 	mcall	80006e54 <LABEL_RET_SCALL_263+0x14>
80006df2:	e0 68 0d 78 	mov	r8,3448
80006df6:	ea 18 00 00 	orh	r8,0x0
80006dfa:	70 00       	ld.w	r0,r8[0x0]
80006dfc:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006dfe:	f0 1f 00 17 	mcall	80006e58 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006e02:	e0 68 0d 78 	mov	r8,3448
80006e06:	ea 18 00 00 	orh	r8,0x0
80006e0a:	70 00       	ld.w	r0,r8[0x0]
80006e0c:	60 0d       	ld.w	sp,r0[0x0]
80006e0e:	1b 00       	ld.w	r0,sp++
80006e10:	e0 68 05 4c 	mov	r8,1356
80006e14:	ea 18 00 00 	orh	r8,0x0
80006e18:	91 00       	st.w	r8[0x0],r0
80006e1a:	fa c7 ff d8 	sub	r7,sp,-40
80006e1e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006e22:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006e26:	e0 61 05 4c 	mov	r1,1356
80006e2a:	ea 11 00 00 	orh	r1,0x0
80006e2e:	62 02       	ld.w	r2,r1[0x0]
80006e30:	58 02       	cp.w	r2,0
80006e32:	c0 70       	breq	80006e40 <LABEL_RET_SCALL_263>
80006e34:	e4 c2 00 01 	sub	r2,r2,1
80006e38:	83 02       	st.w	r1[0x0],r2
80006e3a:	58 02       	cp.w	r2,0
80006e3c:	c0 21       	brne	80006e40 <LABEL_RET_SCALL_263>
80006e3e:	b1 c0       	cbr	r0,0x10

80006e40 <LABEL_RET_SCALL_263>:
80006e40:	ef 40 ff f8 	st.w	r7[-8],r0
80006e44:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006e48:	ef 40 ff fc 	st.w	r7[-4],r0
80006e4c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006e50:	2f ad       	sub	sp,-24
80006e52:	d6 13       	rets
80006e54:	80 00       	ld.sh	r0,r0[0x0]
80006e56:	6d 5c       	ld.w	r12,r6[0x54]
80006e58:	80 00       	ld.sh	r0,r0[0x0]
80006e5a:	74 f8       	ld.w	r8,r10[0x3c]

80006e5c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006e5c:	e1 b8 00 43 	mfsr	r8,0x10c
80006e60:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006e64:	5e fc       	retal	r12
80006e66:	d7 03       	nop

80006e68 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006e68:	48 78       	lddpc	r8,80006e84 <vPortExitCritical+0x1c>
80006e6a:	70 08       	ld.w	r8,r8[0x0]
80006e6c:	58 08       	cp.w	r8,0
80006e6e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006e70:	48 58       	lddpc	r8,80006e84 <vPortExitCritical+0x1c>
80006e72:	70 09       	ld.w	r9,r8[0x0]
80006e74:	20 19       	sub	r9,1
80006e76:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006e78:	70 08       	ld.w	r8,r8[0x0]
80006e7a:	58 08       	cp.w	r8,0
80006e7c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006e7e:	d5 03       	csrf	0x10
80006e80:	5e fc       	retal	r12
80006e82:	00 00       	add	r0,r0
80006e84:	00 00       	add	r0,r0
80006e86:	05 4c       	ld.w	r12,--r2

80006e88 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006e88:	eb cd 00 ff 	pushm	r0-r7
80006e8c:	e0 68 05 4c 	mov	r8,1356
80006e90:	ea 18 00 00 	orh	r8,0x0
80006e94:	70 00       	ld.w	r0,r8[0x0]
80006e96:	1a d0       	st.w	--sp,r0
80006e98:	7a 90       	ld.w	r0,sp[0x24]
80006e9a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006e9e:	58 10       	cp.w	r0,1
80006ea0:	e0 8b 00 08 	brhi	80006eb0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006ea4:	e0 68 0d 78 	mov	r8,3448
80006ea8:	ea 18 00 00 	orh	r8,0x0
80006eac:	70 00       	ld.w	r0,r8[0x0]
80006eae:	81 0d       	st.w	r0[0x0],sp

80006eb0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006eb0:	f0 1f 00 12 	mcall	80006ef8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006eb4:	f0 1f 00 12 	mcall	80006efc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006eb8:	f0 1f 00 12 	mcall	80006f00 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006ebc:	f0 1f 00 12 	mcall	80006f04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006ec0:	7a 90       	ld.w	r0,sp[0x24]
80006ec2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006ec6:	58 10       	cp.w	r0,1
80006ec8:	e0 8b 00 0e 	brhi	80006ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006ecc:	f0 1f 00 0c 	mcall	80006efc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006ed0:	f0 1f 00 0e 	mcall	80006f08 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006ed4:	f0 1f 00 0c 	mcall	80006f04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006ed8:	e0 68 0d 78 	mov	r8,3448
80006edc:	ea 18 00 00 	orh	r8,0x0
80006ee0:	70 00       	ld.w	r0,r8[0x0]
80006ee2:	60 0d       	ld.w	sp,r0[0x0]

80006ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006ee4:	1b 00       	ld.w	r0,sp++
80006ee6:	e0 68 05 4c 	mov	r8,1356
80006eea:	ea 18 00 00 	orh	r8,0x0
80006eee:	91 00       	st.w	r8[0x0],r0
80006ef0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006ef4:	d6 03       	rete
80006ef6:	00 00       	add	r0,r0
80006ef8:	80 00       	ld.sh	r0,r0[0x0]
80006efa:	6e 5c       	ld.w	r12,r7[0x14]
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	6d 5c       	ld.w	r12,r6[0x54]
80006f00:	80 00       	ld.sh	r0,r0[0x0]
80006f02:	76 fc       	ld.w	r12,r11[0x3c]
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	6e 68       	ld.w	r8,r7[0x18]
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	74 f8       	ld.w	r8,r10[0x3c]

80006f0c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006f0c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006f0e:	f0 1f 00 02 	mcall	80006f14 <__malloc_lock+0x8>
}
80006f12:	d8 02       	popm	pc
80006f14:	80 00       	ld.sh	r0,r0[0x0]
80006f16:	74 e8       	ld.w	r8,r10[0x38]

80006f18 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006f18:	d4 01       	pushm	lr
	xTaskResumeAll();
80006f1a:	f0 1f 00 02 	mcall	80006f20 <__malloc_unlock+0x8>
}
80006f1e:	d8 02       	popm	pc
80006f20:	80 00       	ld.sh	r0,r0[0x0]
80006f22:	78 a4       	ld.w	r4,r12[0x28]

80006f24 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006f24:	d4 21       	pushm	r4-r7,lr
80006f26:	16 95       	mov	r5,r11
80006f28:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006f2a:	58 0c       	cp.w	r12,0
80006f2c:	c0 30       	breq	80006f32 <_read+0xe>
80006f2e:	3f f7       	mov	r7,-1
80006f30:	c1 48       	rjmp	80006f58 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006f32:	58 0a       	cp.w	r10,0
80006f34:	e0 89 00 04 	brgt	80006f3c <_read+0x18>
80006f38:	30 07       	mov	r7,0
80006f3a:	c0 f8       	rjmp	80006f58 <_read+0x34>
80006f3c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006f3e:	48 84       	lddpc	r4,80006f5c <_read+0x38>
80006f40:	68 0c       	ld.w	r12,r4[0x0]
80006f42:	f0 1f 00 08 	mcall	80006f60 <_read+0x3c>
    if (c < 0)
80006f46:	c0 95       	brlt	80006f58 <_read+0x34>
      break;

    *ptr++ = c;
80006f48:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006f4c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006f4e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006f52:	58 08       	cp.w	r8,0
80006f54:	fe 99 ff f6 	brgt	80006f40 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006f58:	0e 9c       	mov	r12,r7
80006f5a:	d8 22       	popm	r4-r7,pc
80006f5c:	00 00       	add	r0,r0
80006f5e:	bd 44       	asr	r4,0x1c
80006f60:	80 00       	ld.sh	r0,r0[0x0]
80006f62:	6a b0       	ld.w	r0,r5[0x2c]

80006f64 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006f64:	d4 21       	pushm	r4-r7,lr
80006f66:	16 95       	mov	r5,r11
80006f68:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006f6a:	20 1c       	sub	r12,1
80006f6c:	58 2c       	cp.w	r12,2
80006f6e:	e0 8b 00 12 	brhi	80006f92 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006f72:	58 0a       	cp.w	r10,0
80006f74:	c0 31       	brne	80006f7a <_write+0x16>
80006f76:	30 07       	mov	r7,0
80006f78:	c0 e8       	rjmp	80006f94 <_write+0x30>
80006f7a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006f7c:	48 74       	lddpc	r4,80006f98 <_write+0x34>
80006f7e:	68 0c       	ld.w	r12,r4[0x0]
80006f80:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006f84:	f0 1f 00 06 	mcall	80006f9c <_write+0x38>
80006f88:	c0 55       	brlt	80006f92 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006f8a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006f8c:	0e 36       	cp.w	r6,r7
80006f8e:	cf 81       	brne	80006f7e <_write+0x1a>
80006f90:	c0 28       	rjmp	80006f94 <_write+0x30>
80006f92:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006f94:	0e 9c       	mov	r12,r7
80006f96:	d8 22       	popm	r4-r7,pc
80006f98:	00 00       	add	r0,r0
80006f9a:	bd 44       	asr	r4,0x1c
80006f9c:	80 00       	ld.sh	r0,r0[0x0]
80006f9e:	6a 60       	ld.w	r0,r5[0x18]

80006fa0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006fa0:	eb cd 40 80 	pushm	r7,lr
80006fa4:	18 97       	mov	r7,r12
	if( pv )
80006fa6:	58 0c       	cp.w	r12,0
80006fa8:	c0 80       	breq	80006fb8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006faa:	f0 1f 00 05 	mcall	80006fbc <vPortFree+0x1c>
		{
			free( pv );
80006fae:	0e 9c       	mov	r12,r7
80006fb0:	f0 1f 00 04 	mcall	80006fc0 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006fb4:	f0 1f 00 04 	mcall	80006fc4 <vPortFree+0x24>
80006fb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fbc:	80 00       	ld.sh	r0,r0[0x0]
80006fbe:	74 e8       	ld.w	r8,r10[0x38]
80006fc0:	80 00       	ld.sh	r0,r0[0x0]
80006fc2:	83 80       	st.w	r1[0x20],r0
80006fc4:	80 00       	ld.sh	r0,r0[0x0]
80006fc6:	78 a4       	ld.w	r4,r12[0x28]

80006fc8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006fc8:	eb cd 40 80 	pushm	r7,lr
80006fcc:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006fce:	f0 1f 00 06 	mcall	80006fe4 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006fd2:	0e 9c       	mov	r12,r7
80006fd4:	f0 1f 00 05 	mcall	80006fe8 <pvPortMalloc+0x20>
80006fd8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006fda:	f0 1f 00 05 	mcall	80006fec <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006fde:	0e 9c       	mov	r12,r7
80006fe0:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fe4:	80 00       	ld.sh	r0,r0[0x0]
80006fe6:	74 e8       	ld.w	r8,r10[0x38]
80006fe8:	80 00       	ld.sh	r0,r0[0x0]
80006fea:	83 90       	st.w	r1[0x24],r0
80006fec:	80 00       	ld.sh	r0,r0[0x0]
80006fee:	78 a4       	ld.w	r4,r12[0x28]

80006ff0 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006ff0:	d4 01       	pushm	lr
80006ff2:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006ff4:	78 09       	ld.w	r9,r12[0x0]
80006ff6:	58 09       	cp.w	r9,0
80006ff8:	c1 10       	breq	8000701a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006ffa:	78 3a       	ld.w	r10,r12[0xc]
80006ffc:	79 09       	ld.w	r9,r12[0x40]
80006ffe:	f4 09 00 09 	add	r9,r10,r9
80007002:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80007004:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80007006:	14 39       	cp.w	r9,r10
80007008:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000700c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80007010:	79 0a       	ld.w	r10,r12[0x40]
80007012:	78 3b       	ld.w	r11,r12[0xc]
80007014:	10 9c       	mov	r12,r8
80007016:	f0 1f 00 02 	mcall	8000701c <prvCopyDataFromQueue+0x2c>
8000701a:	d8 02       	popm	pc
8000701c:	80 00       	ld.sh	r0,r0[0x0]
8000701e:	87 fe       	st.w	r3[0x3c],lr

80007020 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80007020:	eb cd 40 c0 	pushm	r6-r7,lr
80007024:	18 97       	mov	r7,r12
80007026:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80007028:	78 e8       	ld.w	r8,r12[0x38]
8000702a:	58 08       	cp.w	r8,0
8000702c:	c0 31       	brne	80007032 <xQueueReceiveFromISR+0x12>
8000702e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80007032:	f0 1f 00 0e 	mcall	80007068 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80007036:	6e e8       	ld.w	r8,r7[0x38]
80007038:	20 18       	sub	r8,1
8000703a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000703c:	6f 18       	ld.w	r8,r7[0x44]
8000703e:	5b f8       	cp.w	r8,-1
80007040:	c0 d1       	brne	8000705a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007042:	6e 48       	ld.w	r8,r7[0x10]
80007044:	58 08       	cp.w	r8,0
80007046:	c0 f0       	breq	80007064 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007048:	ee cc ff f0 	sub	r12,r7,-16
8000704c:	f0 1f 00 08 	mcall	8000706c <xQueueReceiveFromISR+0x4c>
80007050:	c0 a0       	breq	80007064 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80007052:	30 1c       	mov	r12,1
80007054:	8d 0c       	st.w	r6[0x0],r12
80007056:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000705a:	2f f8       	sub	r8,-1
8000705c:	ef 48 00 44 	st.w	r7[68],r8
80007060:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007064:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007068:	80 00       	ld.sh	r0,r0[0x0]
8000706a:	6f f0       	ld.w	r0,r7[0x7c]
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	76 80       	ld.w	r0,r11[0x20]

80007070 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80007070:	eb cd 40 c0 	pushm	r6-r7,lr
80007074:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80007076:	f0 1f 00 23 	mcall	80007100 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000707a:	6f 28       	ld.w	r8,r7[0x48]
8000707c:	58 08       	cp.w	r8,0
8000707e:	e0 8a 00 18 	brle	800070ae <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007082:	6e 98       	ld.w	r8,r7[0x24]
80007084:	58 08       	cp.w	r8,0
80007086:	c1 40       	breq	800070ae <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007088:	ee c6 ff dc 	sub	r6,r7,-36
8000708c:	c0 48       	rjmp	80007094 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000708e:	6e 98       	ld.w	r8,r7[0x24]
80007090:	58 08       	cp.w	r8,0
80007092:	c0 e0       	breq	800070ae <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007094:	0c 9c       	mov	r12,r6
80007096:	f0 1f 00 1c 	mcall	80007104 <prvUnlockQueue+0x94>
8000709a:	c0 30       	breq	800070a0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000709c:	f0 1f 00 1b 	mcall	80007108 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800070a0:	6f 28       	ld.w	r8,r7[0x48]
800070a2:	20 18       	sub	r8,1
800070a4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800070a8:	58 08       	cp.w	r8,0
800070aa:	fe 99 ff f2 	brgt	8000708e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800070ae:	3f f8       	mov	r8,-1
800070b0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800070b4:	f0 1f 00 16 	mcall	8000710c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800070b8:	f0 1f 00 12 	mcall	80007100 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800070bc:	6f 18       	ld.w	r8,r7[0x44]
800070be:	58 08       	cp.w	r8,0
800070c0:	e0 8a 00 18 	brle	800070f0 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800070c4:	6e 48       	ld.w	r8,r7[0x10]
800070c6:	58 08       	cp.w	r8,0
800070c8:	c1 40       	breq	800070f0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800070ca:	ee c6 ff f0 	sub	r6,r7,-16
800070ce:	c0 48       	rjmp	800070d6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800070d0:	6e 48       	ld.w	r8,r7[0x10]
800070d2:	58 08       	cp.w	r8,0
800070d4:	c0 e0       	breq	800070f0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800070d6:	0c 9c       	mov	r12,r6
800070d8:	f0 1f 00 0b 	mcall	80007104 <prvUnlockQueue+0x94>
800070dc:	c0 30       	breq	800070e2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800070de:	f0 1f 00 0b 	mcall	80007108 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800070e2:	6f 18       	ld.w	r8,r7[0x44]
800070e4:	20 18       	sub	r8,1
800070e6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800070ea:	58 08       	cp.w	r8,0
800070ec:	fe 99 ff f2 	brgt	800070d0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800070f0:	3f f8       	mov	r8,-1
800070f2:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800070f6:	f0 1f 00 06 	mcall	8000710c <prvUnlockQueue+0x9c>
}
800070fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800070fe:	00 00       	add	r0,r0
80007100:	80 00       	ld.sh	r0,r0[0x0]
80007102:	6d 5c       	ld.w	r12,r6[0x54]
80007104:	80 00       	ld.sh	r0,r0[0x0]
80007106:	76 80       	ld.w	r0,r11[0x20]
80007108:	80 00       	ld.sh	r0,r0[0x0]
8000710a:	75 8c       	ld.w	r12,r10[0x60]
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	6e 68       	ld.w	r8,r7[0x18]

80007110 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80007110:	d4 31       	pushm	r0-r7,lr
80007112:	20 5d       	sub	sp,20
80007114:	18 97       	mov	r7,r12
80007116:	50 0b       	stdsp	sp[0x0],r11
80007118:	50 2a       	stdsp	sp[0x8],r10
8000711a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000711c:	f8 c2 ff dc 	sub	r2,r12,-36
80007120:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007122:	fa c4 ff f4 	sub	r4,sp,-12
80007126:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80007128:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000712a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000712e:	f0 1f 00 3e 	mcall	80007224 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80007132:	6e e8       	ld.w	r8,r7[0x38]
80007134:	58 08       	cp.w	r8,0
80007136:	c2 a0       	breq	8000718a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80007138:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000713a:	40 0b       	lddsp	r11,sp[0x0]
8000713c:	0e 9c       	mov	r12,r7
8000713e:	f0 1f 00 3b 	mcall	80007228 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80007142:	40 18       	lddsp	r8,sp[0x4]
80007144:	58 08       	cp.w	r8,0
80007146:	c1 51       	brne	80007170 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80007148:	6e e8       	ld.w	r8,r7[0x38]
8000714a:	20 18       	sub	r8,1
8000714c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000714e:	6e 08       	ld.w	r8,r7[0x0]
80007150:	58 08       	cp.w	r8,0
80007152:	c0 41       	brne	8000715a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80007154:	f0 1f 00 36 	mcall	8000722c <xQueueGenericReceive+0x11c>
80007158:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000715a:	6e 48       	ld.w	r8,r7[0x10]
8000715c:	58 08       	cp.w	r8,0
8000715e:	c1 20       	breq	80007182 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80007160:	ee cc ff f0 	sub	r12,r7,-16
80007164:	f0 1f 00 33 	mcall	80007230 <xQueueGenericReceive+0x120>
80007168:	58 1c       	cp.w	r12,1
8000716a:	c0 c1       	brne	80007182 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
8000716c:	d7 33       	scall
8000716e:	c0 a8       	rjmp	80007182 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80007170:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007172:	6e 98       	ld.w	r8,r7[0x24]
80007174:	58 08       	cp.w	r8,0
80007176:	c0 60       	breq	80007182 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007178:	04 9c       	mov	r12,r2
8000717a:	f0 1f 00 2e 	mcall	80007230 <xQueueGenericReceive+0x120>
8000717e:	c0 20       	breq	80007182 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80007180:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80007182:	f0 1f 00 2d 	mcall	80007234 <xQueueGenericReceive+0x124>
80007186:	30 1c       	mov	r12,1
				return pdPASS;
80007188:	c4 c8       	rjmp	80007220 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000718a:	40 28       	lddsp	r8,sp[0x8]
8000718c:	58 08       	cp.w	r8,0
8000718e:	c0 51       	brne	80007198 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007190:	f0 1f 00 29 	mcall	80007234 <xQueueGenericReceive+0x124>
80007194:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80007196:	c4 58       	rjmp	80007220 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80007198:	58 05       	cp.w	r5,0
8000719a:	c0 51       	brne	800071a4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000719c:	08 9c       	mov	r12,r4
8000719e:	f0 1f 00 27 	mcall	80007238 <xQueueGenericReceive+0x128>
800071a2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800071a4:	f0 1f 00 24 	mcall	80007234 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800071a8:	f0 1f 00 25 	mcall	8000723c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800071ac:	f0 1f 00 1e 	mcall	80007224 <xQueueGenericReceive+0x114>
800071b0:	6f 18       	ld.w	r8,r7[0x44]
800071b2:	5b f8       	cp.w	r8,-1
800071b4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800071b8:	6f 28       	ld.w	r8,r7[0x48]
800071ba:	5b f8       	cp.w	r8,-1
800071bc:	ef f1 0a 12 	st.weq	r7[0x48],r1
800071c0:	f0 1f 00 1d 	mcall	80007234 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800071c4:	06 9b       	mov	r11,r3
800071c6:	08 9c       	mov	r12,r4
800071c8:	f0 1f 00 1e 	mcall	80007240 <xQueueGenericReceive+0x130>
800071cc:	c2 41       	brne	80007214 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800071ce:	f0 1f 00 16 	mcall	80007224 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800071d2:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800071d4:	f0 1f 00 18 	mcall	80007234 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800071d8:	58 06       	cp.w	r6,0
800071da:	c1 71       	brne	80007208 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800071dc:	6e 08       	ld.w	r8,r7[0x0]
800071de:	58 08       	cp.w	r8,0
800071e0:	c0 81       	brne	800071f0 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800071e2:	f0 1f 00 11 	mcall	80007224 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800071e6:	6e 1c       	ld.w	r12,r7[0x4]
800071e8:	f0 1f 00 17 	mcall	80007244 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800071ec:	f0 1f 00 12 	mcall	80007234 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800071f0:	40 2b       	lddsp	r11,sp[0x8]
800071f2:	04 9c       	mov	r12,r2
800071f4:	f0 1f 00 15 	mcall	80007248 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800071f8:	0e 9c       	mov	r12,r7
800071fa:	f0 1f 00 15 	mcall	8000724c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800071fe:	f0 1f 00 15 	mcall	80007250 <xQueueGenericReceive+0x140>
80007202:	c9 61       	brne	8000712e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80007204:	d7 33       	scall
80007206:	c9 4b       	rjmp	8000712e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80007208:	0e 9c       	mov	r12,r7
8000720a:	f0 1f 00 11 	mcall	8000724c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000720e:	f0 1f 00 11 	mcall	80007250 <xQueueGenericReceive+0x140>
80007212:	c8 eb       	rjmp	8000712e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80007214:	0e 9c       	mov	r12,r7
80007216:	f0 1f 00 0e 	mcall	8000724c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000721a:	f0 1f 00 0e 	mcall	80007250 <xQueueGenericReceive+0x140>
8000721e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80007220:	2f bd       	sub	sp,-20
80007222:	d8 32       	popm	r0-r7,pc
80007224:	80 00       	ld.sh	r0,r0[0x0]
80007226:	6d 5c       	ld.w	r12,r6[0x54]
80007228:	80 00       	ld.sh	r0,r0[0x0]
8000722a:	6f f0       	ld.w	r0,r7[0x7c]
8000722c:	80 00       	ld.sh	r0,r0[0x0]
8000722e:	75 98       	ld.w	r8,r10[0x64]
80007230:	80 00       	ld.sh	r0,r0[0x0]
80007232:	76 80       	ld.w	r0,r11[0x20]
80007234:	80 00       	ld.sh	r0,r0[0x0]
80007236:	6e 68       	ld.w	r8,r7[0x18]
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	75 74       	ld.w	r4,r10[0x5c]
8000723c:	80 00       	ld.sh	r0,r0[0x0]
8000723e:	74 e8       	ld.w	r8,r10[0x38]
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	78 10       	ld.w	r0,r12[0x4]
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	75 fc       	ld.w	r12,r10[0x7c]
80007248:	80 00       	ld.sh	r0,r0[0x0]
8000724a:	7a b0       	ld.w	r0,sp[0x2c]
8000724c:	80 00       	ld.sh	r0,r0[0x0]
8000724e:	70 70       	ld.w	r0,r8[0x1c]
80007250:	80 00       	ld.sh	r0,r0[0x0]
80007252:	78 a4       	ld.w	r4,r12[0x28]

80007254 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80007254:	eb cd 40 80 	pushm	r7,lr
80007258:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000725a:	79 08       	ld.w	r8,r12[0x40]
8000725c:	58 08       	cp.w	r8,0
8000725e:	c0 a1       	brne	80007272 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007260:	78 08       	ld.w	r8,r12[0x0]
80007262:	58 08       	cp.w	r8,0
80007264:	c2 b1       	brne	800072ba <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80007266:	78 1c       	ld.w	r12,r12[0x4]
80007268:	f0 1f 00 17 	mcall	800072c4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
8000726c:	30 08       	mov	r8,0
8000726e:	8f 18       	st.w	r7[0x4],r8
80007270:	c2 58       	rjmp	800072ba <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80007272:	58 0a       	cp.w	r10,0
80007274:	c1 01       	brne	80007294 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80007276:	10 9a       	mov	r10,r8
80007278:	78 2c       	ld.w	r12,r12[0x8]
8000727a:	f0 1f 00 14 	mcall	800072c8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000727e:	6e 29       	ld.w	r9,r7[0x8]
80007280:	6f 08       	ld.w	r8,r7[0x40]
80007282:	f2 08 00 08 	add	r8,r9,r8
80007286:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80007288:	6e 19       	ld.w	r9,r7[0x4]
8000728a:	12 38       	cp.w	r8,r9
8000728c:	c1 73       	brcs	800072ba <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000728e:	6e 08       	ld.w	r8,r7[0x0]
80007290:	8f 28       	st.w	r7[0x8],r8
80007292:	c1 48       	rjmp	800072ba <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80007294:	10 9a       	mov	r10,r8
80007296:	78 3c       	ld.w	r12,r12[0xc]
80007298:	f0 1f 00 0c 	mcall	800072c8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000729c:	6f 08       	ld.w	r8,r7[0x40]
8000729e:	6e 39       	ld.w	r9,r7[0xc]
800072a0:	f2 08 01 08 	sub	r8,r9,r8
800072a4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800072a6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800072a8:	12 38       	cp.w	r8,r9
800072aa:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800072ae:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800072b2:	f3 d8 e3 19 	subcs	r9,r9,r8
800072b6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800072ba:	6e e8       	ld.w	r8,r7[0x38]
800072bc:	2f f8       	sub	r8,-1
800072be:	8f e8       	st.w	r7[0x38],r8
}
800072c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	75 a4       	ld.w	r4,r10[0x68]
800072c8:	80 00       	ld.sh	r0,r0[0x0]
800072ca:	87 fe       	st.w	r3[0x3c],lr

800072cc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800072cc:	eb cd 40 c0 	pushm	r6-r7,lr
800072d0:	18 97       	mov	r7,r12
800072d2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800072d4:	78 ec       	ld.w	r12,r12[0x38]
800072d6:	6e f8       	ld.w	r8,r7[0x3c]
800072d8:	10 3c       	cp.w	r12,r8
800072da:	c0 33       	brcs	800072e0 <xQueueGenericSendFromISR+0x14>
800072dc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800072e0:	12 9a       	mov	r10,r9
800072e2:	0e 9c       	mov	r12,r7
800072e4:	f0 1f 00 0c 	mcall	80007314 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800072e8:	6f 28       	ld.w	r8,r7[0x48]
800072ea:	5b f8       	cp.w	r8,-1
800072ec:	c0 d1       	brne	80007306 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800072ee:	6e 98       	ld.w	r8,r7[0x24]
800072f0:	58 08       	cp.w	r8,0
800072f2:	c0 f0       	breq	80007310 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800072f4:	ee cc ff dc 	sub	r12,r7,-36
800072f8:	f0 1f 00 08 	mcall	80007318 <xQueueGenericSendFromISR+0x4c>
800072fc:	c0 a0       	breq	80007310 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800072fe:	30 1c       	mov	r12,1
80007300:	8d 0c       	st.w	r6[0x0],r12
80007302:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80007306:	2f f8       	sub	r8,-1
80007308:	ef 48 00 48 	st.w	r7[72],r8
8000730c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007310:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80007314:	80 00       	ld.sh	r0,r0[0x0]
80007316:	72 54       	ld.w	r4,r9[0x14]
80007318:	80 00       	ld.sh	r0,r0[0x0]
8000731a:	76 80       	ld.w	r0,r11[0x20]

8000731c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000731c:	d4 31       	pushm	r0-r7,lr
8000731e:	20 5d       	sub	sp,20
80007320:	18 97       	mov	r7,r12
80007322:	50 0b       	stdsp	sp[0x0],r11
80007324:	50 2a       	stdsp	sp[0x8],r10
80007326:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80007328:	f8 c0 ff f0 	sub	r0,r12,-16
8000732c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000732e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80007332:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80007334:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80007338:	f0 1f 00 2f 	mcall	800073f4 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000733c:	6e e9       	ld.w	r9,r7[0x38]
8000733e:	6e f8       	ld.w	r8,r7[0x3c]
80007340:	10 39       	cp.w	r9,r8
80007342:	c1 42       	brcc	8000736a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007344:	40 1a       	lddsp	r10,sp[0x4]
80007346:	40 0b       	lddsp	r11,sp[0x0]
80007348:	0e 9c       	mov	r12,r7
8000734a:	f0 1f 00 2c 	mcall	800073f8 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000734e:	6e 98       	ld.w	r8,r7[0x24]
80007350:	58 08       	cp.w	r8,0
80007352:	c0 80       	breq	80007362 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80007354:	ee cc ff dc 	sub	r12,r7,-36
80007358:	f0 1f 00 29 	mcall	800073fc <xQueueGenericSend+0xe0>
8000735c:	58 1c       	cp.w	r12,1
8000735e:	c0 21       	brne	80007362 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80007360:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80007362:	f0 1f 00 28 	mcall	80007400 <xQueueGenericSend+0xe4>
80007366:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80007368:	c4 38       	rjmp	800073ee <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000736a:	40 28       	lddsp	r8,sp[0x8]
8000736c:	58 08       	cp.w	r8,0
8000736e:	c0 51       	brne	80007378 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007370:	f0 1f 00 24 	mcall	80007400 <xQueueGenericSend+0xe4>
80007374:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80007376:	c3 c8       	rjmp	800073ee <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80007378:	58 04       	cp.w	r4,0
8000737a:	c0 51       	brne	80007384 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000737c:	06 9c       	mov	r12,r3
8000737e:	f0 1f 00 22 	mcall	80007404 <xQueueGenericSend+0xe8>
80007382:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80007384:	f0 1f 00 1f 	mcall	80007400 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80007388:	f0 1f 00 20 	mcall	80007408 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000738c:	f0 1f 00 1a 	mcall	800073f4 <xQueueGenericSend+0xd8>
80007390:	6f 18       	ld.w	r8,r7[0x44]
80007392:	5b f8       	cp.w	r8,-1
80007394:	ef f1 0a 11 	st.weq	r7[0x44],r1
80007398:	6f 28       	ld.w	r8,r7[0x48]
8000739a:	5b f8       	cp.w	r8,-1
8000739c:	ef f1 0a 12 	st.weq	r7[0x48],r1
800073a0:	f0 1f 00 18 	mcall	80007400 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800073a4:	04 9b       	mov	r11,r2
800073a6:	06 9c       	mov	r12,r3
800073a8:	f0 1f 00 19 	mcall	8000740c <xQueueGenericSend+0xf0>
800073ac:	c1 b1       	brne	800073e2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800073ae:	f0 1f 00 12 	mcall	800073f4 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800073b2:	6e e5       	ld.w	r5,r7[0x38]
800073b4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800073b6:	f0 1f 00 13 	mcall	80007400 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800073ba:	0c 35       	cp.w	r5,r6
800073bc:	c0 d1       	brne	800073d6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800073be:	40 2b       	lddsp	r11,sp[0x8]
800073c0:	00 9c       	mov	r12,r0
800073c2:	f0 1f 00 14 	mcall	80007410 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800073c6:	0e 9c       	mov	r12,r7
800073c8:	f0 1f 00 13 	mcall	80007414 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800073cc:	f0 1f 00 13 	mcall	80007418 <xQueueGenericSend+0xfc>
800073d0:	cb 41       	brne	80007338 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800073d2:	d7 33       	scall
800073d4:	cb 2b       	rjmp	80007338 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800073d6:	0e 9c       	mov	r12,r7
800073d8:	f0 1f 00 0f 	mcall	80007414 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800073dc:	f0 1f 00 0f 	mcall	80007418 <xQueueGenericSend+0xfc>
800073e0:	ca cb       	rjmp	80007338 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800073e2:	0e 9c       	mov	r12,r7
800073e4:	f0 1f 00 0c 	mcall	80007414 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800073e8:	f0 1f 00 0c 	mcall	80007418 <xQueueGenericSend+0xfc>
800073ec:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800073ee:	2f bd       	sub	sp,-20
800073f0:	d8 32       	popm	r0-r7,pc
800073f2:	00 00       	add	r0,r0
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	6d 5c       	ld.w	r12,r6[0x54]
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	72 54       	ld.w	r4,r9[0x14]
800073fc:	80 00       	ld.sh	r0,r0[0x0]
800073fe:	76 80       	ld.w	r0,r11[0x20]
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	6e 68       	ld.w	r8,r7[0x18]
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	75 74       	ld.w	r4,r10[0x5c]
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	74 e8       	ld.w	r8,r10[0x38]
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	78 10       	ld.w	r0,r12[0x4]
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	7a b0       	ld.w	r0,sp[0x2c]
80007414:	80 00       	ld.sh	r0,r0[0x0]
80007416:	70 70       	ld.w	r0,r8[0x1c]
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	78 a4       	ld.w	r4,r12[0x28]

8000741c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000741c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80007420:	34 cc       	mov	r12,76
80007422:	f0 1f 00 12 	mcall	80007468 <xQueueCreateMutex+0x4c>
80007426:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80007428:	c1 d0       	breq	80007462 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000742a:	30 06       	mov	r6,0
8000742c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000742e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80007430:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80007432:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80007434:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80007436:	30 18       	mov	r8,1
80007438:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000743a:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
8000743e:	3f f8       	mov	r8,-1
80007440:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80007444:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80007448:	2f 0c       	sub	r12,-16
8000744a:	f0 1f 00 09 	mcall	8000746c <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000744e:	ee cc ff dc 	sub	r12,r7,-36
80007452:	f0 1f 00 07 	mcall	8000746c <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80007456:	0c 99       	mov	r9,r6
80007458:	0c 9a       	mov	r10,r6
8000745a:	0c 9b       	mov	r11,r6
8000745c:	0e 9c       	mov	r12,r7
8000745e:	f0 1f 00 05 	mcall	80007470 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80007462:	0e 9c       	mov	r12,r7
80007464:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007468:	80 00       	ld.sh	r0,r0[0x0]
8000746a:	6f c8       	ld.w	r8,r7[0x70]
8000746c:	80 00       	ld.sh	r0,r0[0x0]
8000746e:	6c 38       	ld.w	r8,r6[0xc]
80007470:	80 00       	ld.sh	r0,r0[0x0]
80007472:	73 1c       	ld.w	r12,r9[0x44]

80007474 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80007474:	d4 21       	pushm	r4-r7,lr
80007476:	18 97       	mov	r7,r12
80007478:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000747a:	58 0c       	cp.w	r12,0
8000747c:	c2 f0       	breq	800074da <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000747e:	34 cc       	mov	r12,76
80007480:	f0 1f 00 17 	mcall	800074dc <xQueueCreate+0x68>
80007484:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80007486:	c2 a0       	breq	800074da <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80007488:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000748c:	e8 cc ff ff 	sub	r12,r4,-1
80007490:	f0 1f 00 13 	mcall	800074dc <xQueueCreate+0x68>
80007494:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80007496:	c1 e0       	breq	800074d2 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80007498:	f8 04 00 04 	add	r4,r12,r4
8000749c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000749e:	30 08       	mov	r8,0
800074a0:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800074a2:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800074a4:	ee c8 00 01 	sub	r8,r7,1
800074a8:	ad 38       	mul	r8,r6
800074aa:	10 0c       	add	r12,r8
800074ac:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800074ae:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800074b0:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800074b4:	3f f8       	mov	r8,-1
800074b6:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800074ba:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800074be:	ea cc ff f0 	sub	r12,r5,-16
800074c2:	f0 1f 00 08 	mcall	800074e0 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800074c6:	ea cc ff dc 	sub	r12,r5,-36
800074ca:	f0 1f 00 06 	mcall	800074e0 <xQueueCreate+0x6c>
800074ce:	0a 9c       	mov	r12,r5
800074d0:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800074d2:	0a 9c       	mov	r12,r5
800074d4:	f0 1f 00 04 	mcall	800074e4 <xQueueCreate+0x70>
800074d8:	d8 2a       	popm	r4-r7,pc,r12=0
800074da:	d8 2a       	popm	r4-r7,pc,r12=0
800074dc:	80 00       	ld.sh	r0,r0[0x0]
800074de:	6f c8       	ld.w	r8,r7[0x70]
800074e0:	80 00       	ld.sh	r0,r0[0x0]
800074e2:	6c 38       	ld.w	r8,r6[0xc]
800074e4:	80 00       	ld.sh	r0,r0[0x0]
800074e6:	6f a0       	ld.w	r0,r7[0x68]

800074e8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800074e8:	48 38       	lddpc	r8,800074f4 <vTaskSuspendAll+0xc>
800074ea:	70 09       	ld.w	r9,r8[0x0]
800074ec:	2f f9       	sub	r9,-1
800074ee:	91 09       	st.w	r8[0x0],r9
}
800074f0:	5e fc       	retal	r12
800074f2:	00 00       	add	r0,r0
800074f4:	00 00       	add	r0,r0
800074f6:	0d a8       	ld.ub	r8,r6[0x2]

800074f8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800074f8:	49 a8       	lddpc	r8,80007560 <vTaskSwitchContext+0x68>
800074fa:	70 08       	ld.w	r8,r8[0x0]
800074fc:	58 08       	cp.w	r8,0
800074fe:	c0 b1       	brne	80007514 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007500:	49 98       	lddpc	r8,80007564 <vTaskSwitchContext+0x6c>
80007502:	70 08       	ld.w	r8,r8[0x0]
80007504:	f0 08 00 28 	add	r8,r8,r8<<0x2
80007508:	49 89       	lddpc	r9,80007568 <vTaskSwitchContext+0x70>
8000750a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000750e:	58 08       	cp.w	r8,0
80007510:	c0 60       	breq	8000751c <vTaskSwitchContext+0x24>
80007512:	c1 18       	rjmp	80007534 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80007514:	30 19       	mov	r9,1
80007516:	49 68       	lddpc	r8,8000756c <vTaskSwitchContext+0x74>
80007518:	91 09       	st.w	r8[0x0],r9
8000751a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000751c:	49 28       	lddpc	r8,80007564 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000751e:	49 3a       	lddpc	r10,80007568 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80007520:	70 09       	ld.w	r9,r8[0x0]
80007522:	20 19       	sub	r9,1
80007524:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007526:	70 09       	ld.w	r9,r8[0x0]
80007528:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000752c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80007530:	58 09       	cp.w	r9,0
80007532:	cf 70       	breq	80007520 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80007534:	48 c8       	lddpc	r8,80007564 <vTaskSwitchContext+0x6c>
80007536:	70 08       	ld.w	r8,r8[0x0]
80007538:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000753c:	48 b9       	lddpc	r9,80007568 <vTaskSwitchContext+0x70>
8000753e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007542:	70 19       	ld.w	r9,r8[0x4]
80007544:	72 19       	ld.w	r9,r9[0x4]
80007546:	91 19       	st.w	r8[0x4],r9
80007548:	f0 ca ff f8 	sub	r10,r8,-8
8000754c:	14 39       	cp.w	r9,r10
8000754e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80007552:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80007556:	70 18       	ld.w	r8,r8[0x4]
80007558:	70 39       	ld.w	r9,r8[0xc]
8000755a:	48 68       	lddpc	r8,80007570 <vTaskSwitchContext+0x78>
8000755c:	91 09       	st.w	r8[0x0],r9
8000755e:	5e fc       	retal	r12
80007560:	00 00       	add	r0,r0
80007562:	0d a8       	ld.ub	r8,r6[0x2]
80007564:	00 00       	add	r0,r0
80007566:	0d e0       	ld.ub	r0,r6[0x6]
80007568:	00 00       	add	r0,r0
8000756a:	0c c4       	st.b	r6++,r4
8000756c:	00 00       	add	r0,r0
8000756e:	0d c8       	ld.ub	r8,r6[0x4]
80007570:	00 00       	add	r0,r0
80007572:	0d 78       	ld.ub	r8,--r6

80007574 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80007574:	48 48       	lddpc	r8,80007584 <vTaskSetTimeOutState+0x10>
80007576:	70 08       	ld.w	r8,r8[0x0]
80007578:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000757a:	48 48       	lddpc	r8,80007588 <vTaskSetTimeOutState+0x14>
8000757c:	70 08       	ld.w	r8,r8[0x0]
8000757e:	99 18       	st.w	r12[0x4],r8
}
80007580:	5e fc       	retal	r12
80007582:	00 00       	add	r0,r0
80007584:	00 00       	add	r0,r0
80007586:	0c bc       	st.h	r6++,r12
80007588:	00 00       	add	r0,r0
8000758a:	0d a4       	ld.ub	r4,r6[0x2]

8000758c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000758c:	30 19       	mov	r9,1
8000758e:	48 28       	lddpc	r8,80007594 <vTaskMissedYield+0x8>
80007590:	91 09       	st.w	r8[0x0],r9
}
80007592:	5e fc       	retal	r12
80007594:	00 00       	add	r0,r0
80007596:	0d c8       	ld.ub	r8,r6[0x4]

80007598 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80007598:	48 28       	lddpc	r8,800075a0 <xTaskGetCurrentTaskHandle+0x8>
8000759a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000759c:	5e fc       	retal	r12
8000759e:	00 00       	add	r0,r0
800075a0:	00 00       	add	r0,r0
800075a2:	0d 78       	ld.ub	r8,--r6

800075a4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800075a4:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800075a8:	58 0c       	cp.w	r12,0
800075aa:	c1 f0       	breq	800075e8 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800075ac:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800075ae:	78 b9       	ld.w	r9,r12[0x2c]
800075b0:	79 18       	ld.w	r8,r12[0x44]
800075b2:	10 39       	cp.w	r9,r8
800075b4:	c1 a0       	breq	800075e8 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800075b6:	f8 c6 ff fc 	sub	r6,r12,-4
800075ba:	0c 9c       	mov	r12,r6
800075bc:	f0 1f 00 0c 	mcall	800075ec <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800075c0:	6f 1c       	ld.w	r12,r7[0x44]
800075c2:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800075c4:	f8 08 11 08 	rsub	r8,r12,8
800075c8:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800075ca:	48 a8       	lddpc	r8,800075f0 <vTaskPriorityDisinherit+0x4c>
800075cc:	70 08       	ld.w	r8,r8[0x0]
800075ce:	10 3c       	cp.w	r12,r8
800075d0:	e0 88 00 04 	brls	800075d8 <vTaskPriorityDisinherit+0x34>
800075d4:	48 78       	lddpc	r8,800075f0 <vTaskPriorityDisinherit+0x4c>
800075d6:	91 0c       	st.w	r8[0x0],r12
800075d8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800075dc:	0c 9b       	mov	r11,r6
800075de:	48 68       	lddpc	r8,800075f4 <vTaskPriorityDisinherit+0x50>
800075e0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800075e4:	f0 1f 00 05 	mcall	800075f8 <vTaskPriorityDisinherit+0x54>
800075e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800075ec:	80 00       	ld.sh	r0,r0[0x0]
800075ee:	6c a2       	ld.w	r2,r6[0x28]
800075f0:	00 00       	add	r0,r0
800075f2:	0d e0       	ld.ub	r0,r6[0x6]
800075f4:	00 00       	add	r0,r0
800075f6:	0c c4       	st.b	r6++,r4
800075f8:	80 00       	ld.sh	r0,r0[0x0]
800075fa:	6c 52       	ld.w	r2,r6[0x14]

800075fc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800075fc:	eb cd 40 c0 	pushm	r6-r7,lr
80007600:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80007602:	49 b8       	lddpc	r8,8000766c <vTaskPriorityInherit+0x70>
80007604:	70 08       	ld.w	r8,r8[0x0]
80007606:	78 b9       	ld.w	r9,r12[0x2c]
80007608:	70 b8       	ld.w	r8,r8[0x2c]
8000760a:	10 39       	cp.w	r9,r8
8000760c:	c2 d2       	brcc	80007666 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000760e:	49 88       	lddpc	r8,8000766c <vTaskPriorityInherit+0x70>
80007610:	70 08       	ld.w	r8,r8[0x0]
80007612:	70 b8       	ld.w	r8,r8[0x2c]
80007614:	f0 08 11 08 	rsub	r8,r8,8
80007618:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000761a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000761e:	49 59       	lddpc	r9,80007670 <vTaskPriorityInherit+0x74>
80007620:	f2 08 00 28 	add	r8,r9,r8<<0x2
80007624:	78 59       	ld.w	r9,r12[0x14]
80007626:	10 39       	cp.w	r9,r8
80007628:	c1 b1       	brne	8000765e <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000762a:	f8 c6 ff fc 	sub	r6,r12,-4
8000762e:	0c 9c       	mov	r12,r6
80007630:	f0 1f 00 11 	mcall	80007674 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80007634:	48 e8       	lddpc	r8,8000766c <vTaskPriorityInherit+0x70>
80007636:	70 08       	ld.w	r8,r8[0x0]
80007638:	70 bc       	ld.w	r12,r8[0x2c]
8000763a:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
8000763c:	48 f8       	lddpc	r8,80007678 <vTaskPriorityInherit+0x7c>
8000763e:	70 08       	ld.w	r8,r8[0x0]
80007640:	10 3c       	cp.w	r12,r8
80007642:	e0 88 00 04 	brls	8000764a <vTaskPriorityInherit+0x4e>
80007646:	48 d8       	lddpc	r8,80007678 <vTaskPriorityInherit+0x7c>
80007648:	91 0c       	st.w	r8[0x0],r12
8000764a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000764e:	0c 9b       	mov	r11,r6
80007650:	48 88       	lddpc	r8,80007670 <vTaskPriorityInherit+0x74>
80007652:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007656:	f0 1f 00 0a 	mcall	8000767c <vTaskPriorityInherit+0x80>
8000765a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000765e:	48 48       	lddpc	r8,8000766c <vTaskPriorityInherit+0x70>
80007660:	70 08       	ld.w	r8,r8[0x0]
80007662:	70 b8       	ld.w	r8,r8[0x2c]
80007664:	99 b8       	st.w	r12[0x2c],r8
80007666:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000766a:	00 00       	add	r0,r0
8000766c:	00 00       	add	r0,r0
8000766e:	0d 78       	ld.ub	r8,--r6
80007670:	00 00       	add	r0,r0
80007672:	0c c4       	st.b	r6++,r4
80007674:	80 00       	ld.sh	r0,r0[0x0]
80007676:	6c a2       	ld.w	r2,r6[0x28]
80007678:	00 00       	add	r0,r0
8000767a:	0d e0       	ld.ub	r0,r6[0x6]
8000767c:	80 00       	ld.sh	r0,r0[0x0]
8000767e:	6c 52       	ld.w	r2,r6[0x14]

80007680 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80007680:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80007684:	78 38       	ld.w	r8,r12[0xc]
80007686:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80007688:	ee c6 ff e8 	sub	r6,r7,-24
8000768c:	0c 9c       	mov	r12,r6
8000768e:	f0 1f 00 15 	mcall	800076e0 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007692:	49 58       	lddpc	r8,800076e4 <xTaskRemoveFromEventList+0x64>
80007694:	70 08       	ld.w	r8,r8[0x0]
80007696:	58 08       	cp.w	r8,0
80007698:	c1 71       	brne	800076c6 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000769a:	ee c6 ff fc 	sub	r6,r7,-4
8000769e:	0c 9c       	mov	r12,r6
800076a0:	f0 1f 00 10 	mcall	800076e0 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800076a4:	6e bc       	ld.w	r12,r7[0x2c]
800076a6:	49 18       	lddpc	r8,800076e8 <xTaskRemoveFromEventList+0x68>
800076a8:	70 08       	ld.w	r8,r8[0x0]
800076aa:	10 3c       	cp.w	r12,r8
800076ac:	e0 88 00 04 	brls	800076b4 <xTaskRemoveFromEventList+0x34>
800076b0:	48 e8       	lddpc	r8,800076e8 <xTaskRemoveFromEventList+0x68>
800076b2:	91 0c       	st.w	r8[0x0],r12
800076b4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800076b8:	0c 9b       	mov	r11,r6
800076ba:	48 d8       	lddpc	r8,800076ec <xTaskRemoveFromEventList+0x6c>
800076bc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800076c0:	f0 1f 00 0c 	mcall	800076f0 <xTaskRemoveFromEventList+0x70>
800076c4:	c0 58       	rjmp	800076ce <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800076c6:	0c 9b       	mov	r11,r6
800076c8:	48 bc       	lddpc	r12,800076f4 <xTaskRemoveFromEventList+0x74>
800076ca:	f0 1f 00 0a 	mcall	800076f0 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800076ce:	48 b8       	lddpc	r8,800076f8 <xTaskRemoveFromEventList+0x78>
800076d0:	70 08       	ld.w	r8,r8[0x0]
800076d2:	6e b9       	ld.w	r9,r7[0x2c]
800076d4:	70 b8       	ld.w	r8,r8[0x2c]
800076d6:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800076d8:	5f 2c       	srhs	r12
800076da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800076de:	00 00       	add	r0,r0
800076e0:	80 00       	ld.sh	r0,r0[0x0]
800076e2:	6c a2       	ld.w	r2,r6[0x28]
800076e4:	00 00       	add	r0,r0
800076e6:	0d a8       	ld.ub	r8,r6[0x2]
800076e8:	00 00       	add	r0,r0
800076ea:	0d e0       	ld.ub	r0,r6[0x6]
800076ec:	00 00       	add	r0,r0
800076ee:	0c c4       	st.b	r6++,r4
800076f0:	80 00       	ld.sh	r0,r0[0x0]
800076f2:	6c 52       	ld.w	r2,r6[0x14]
800076f4:	00 00       	add	r0,r0
800076f6:	0d 7c       	ld.ub	r12,--r6
800076f8:	00 00       	add	r0,r0
800076fa:	0d 78       	ld.ub	r8,--r6

800076fc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800076fc:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007700:	4b 98       	lddpc	r8,800077e4 <vTaskIncrementTick+0xe8>
80007702:	70 08       	ld.w	r8,r8[0x0]
80007704:	58 08       	cp.w	r8,0
80007706:	c6 91       	brne	800077d8 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80007708:	4b 88       	lddpc	r8,800077e8 <vTaskIncrementTick+0xec>
8000770a:	70 09       	ld.w	r9,r8[0x0]
8000770c:	2f f9       	sub	r9,-1
8000770e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80007710:	70 08       	ld.w	r8,r8[0x0]
80007712:	58 08       	cp.w	r8,0
80007714:	c1 a1       	brne	80007748 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80007716:	4b 68       	lddpc	r8,800077ec <vTaskIncrementTick+0xf0>
80007718:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000771a:	4b 69       	lddpc	r9,800077f0 <vTaskIncrementTick+0xf4>
8000771c:	72 0b       	ld.w	r11,r9[0x0]
8000771e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80007720:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80007722:	4b 59       	lddpc	r9,800077f4 <vTaskIncrementTick+0xf8>
80007724:	72 0a       	ld.w	r10,r9[0x0]
80007726:	2f fa       	sub	r10,-1
80007728:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000772a:	70 08       	ld.w	r8,r8[0x0]
8000772c:	70 08       	ld.w	r8,r8[0x0]
8000772e:	58 08       	cp.w	r8,0
80007730:	c0 51       	brne	8000773a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80007732:	3f f9       	mov	r9,-1
80007734:	4b 18       	lddpc	r8,800077f8 <vTaskIncrementTick+0xfc>
80007736:	91 09       	st.w	r8[0x0],r9
80007738:	c0 88       	rjmp	80007748 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000773a:	4a d8       	lddpc	r8,800077ec <vTaskIncrementTick+0xf0>
8000773c:	70 08       	ld.w	r8,r8[0x0]
8000773e:	70 38       	ld.w	r8,r8[0xc]
80007740:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80007742:	70 19       	ld.w	r9,r8[0x4]
80007744:	4a d8       	lddpc	r8,800077f8 <vTaskIncrementTick+0xfc>
80007746:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80007748:	4a 88       	lddpc	r8,800077e8 <vTaskIncrementTick+0xec>
8000774a:	70 09       	ld.w	r9,r8[0x0]
8000774c:	4a b8       	lddpc	r8,800077f8 <vTaskIncrementTick+0xfc>
8000774e:	70 08       	ld.w	r8,r8[0x0]
80007750:	10 39       	cp.w	r9,r8
80007752:	c4 73       	brcs	800077e0 <vTaskIncrementTick+0xe4>
80007754:	4a 68       	lddpc	r8,800077ec <vTaskIncrementTick+0xf0>
80007756:	70 08       	ld.w	r8,r8[0x0]
80007758:	70 08       	ld.w	r8,r8[0x0]
8000775a:	58 08       	cp.w	r8,0
8000775c:	c0 c0       	breq	80007774 <vTaskIncrementTick+0x78>
8000775e:	4a 48       	lddpc	r8,800077ec <vTaskIncrementTick+0xf0>
80007760:	70 08       	ld.w	r8,r8[0x0]
80007762:	70 38       	ld.w	r8,r8[0xc]
80007764:	70 37       	ld.w	r7,r8[0xc]
80007766:	6e 18       	ld.w	r8,r7[0x4]
80007768:	4a 09       	lddpc	r9,800077e8 <vTaskIncrementTick+0xec>
8000776a:	72 09       	ld.w	r9,r9[0x0]
8000776c:	12 38       	cp.w	r8,r9
8000776e:	e0 88 00 14 	brls	80007796 <vTaskIncrementTick+0x9a>
80007772:	c0 e8       	rjmp	8000778e <vTaskIncrementTick+0x92>
80007774:	3f f9       	mov	r9,-1
80007776:	4a 18       	lddpc	r8,800077f8 <vTaskIncrementTick+0xfc>
80007778:	91 09       	st.w	r8[0x0],r9
8000777a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000777e:	6a 08       	ld.w	r8,r5[0x0]
80007780:	70 38       	ld.w	r8,r8[0xc]
80007782:	70 37       	ld.w	r7,r8[0xc]
80007784:	6e 18       	ld.w	r8,r7[0x4]
80007786:	64 09       	ld.w	r9,r2[0x0]
80007788:	12 38       	cp.w	r8,r9
8000778a:	e0 88 00 0a 	brls	8000779e <vTaskIncrementTick+0xa2>
8000778e:	49 b9       	lddpc	r9,800077f8 <vTaskIncrementTick+0xfc>
80007790:	93 08       	st.w	r9[0x0],r8
80007792:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007796:	49 a4       	lddpc	r4,800077fc <vTaskIncrementTick+0x100>
80007798:	49 a3       	lddpc	r3,80007800 <vTaskIncrementTick+0x104>
8000779a:	49 55       	lddpc	r5,800077ec <vTaskIncrementTick+0xf0>
8000779c:	49 32       	lddpc	r2,800077e8 <vTaskIncrementTick+0xec>
8000779e:	ee c6 ff fc 	sub	r6,r7,-4
800077a2:	0c 9c       	mov	r12,r6
800077a4:	f0 1f 00 18 	mcall	80007804 <vTaskIncrementTick+0x108>
800077a8:	6e a8       	ld.w	r8,r7[0x28]
800077aa:	58 08       	cp.w	r8,0
800077ac:	c0 50       	breq	800077b6 <vTaskIncrementTick+0xba>
800077ae:	ee cc ff e8 	sub	r12,r7,-24
800077b2:	f0 1f 00 15 	mcall	80007804 <vTaskIncrementTick+0x108>
800077b6:	6e bc       	ld.w	r12,r7[0x2c]
800077b8:	68 08       	ld.w	r8,r4[0x0]
800077ba:	10 3c       	cp.w	r12,r8
800077bc:	e9 fc ba 00 	st.whi	r4[0x0],r12
800077c0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800077c4:	0c 9b       	mov	r11,r6
800077c6:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800077ca:	f0 1f 00 10 	mcall	80007808 <vTaskIncrementTick+0x10c>
800077ce:	6a 08       	ld.w	r8,r5[0x0]
800077d0:	70 08       	ld.w	r8,r8[0x0]
800077d2:	58 08       	cp.w	r8,0
800077d4:	cd 51       	brne	8000777e <vTaskIncrementTick+0x82>
800077d6:	cc fb       	rjmp	80007774 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800077d8:	48 d8       	lddpc	r8,8000780c <vTaskIncrementTick+0x110>
800077da:	70 09       	ld.w	r9,r8[0x0]
800077dc:	2f f9       	sub	r9,-1
800077de:	91 09       	st.w	r8[0x0],r9
800077e0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800077e4:	00 00       	add	r0,r0
800077e6:	0d a8       	ld.ub	r8,r6[0x2]
800077e8:	00 00       	add	r0,r0
800077ea:	0d a4       	ld.ub	r4,r6[0x2]
800077ec:	00 00       	add	r0,r0
800077ee:	0c b0       	st.h	r6++,r0
800077f0:	00 00       	add	r0,r0
800077f2:	0c c0       	st.b	r6++,r0
800077f4:	00 00       	add	r0,r0
800077f6:	0c bc       	st.h	r6++,r12
800077f8:	00 00       	add	r0,r0
800077fa:	05 50       	ld.sh	r0,--r2
800077fc:	00 00       	add	r0,r0
800077fe:	0d e0       	ld.ub	r0,r6[0x6]
80007800:	00 00       	add	r0,r0
80007802:	0c c4       	st.b	r6++,r4
80007804:	80 00       	ld.sh	r0,r0[0x0]
80007806:	6c a2       	ld.w	r2,r6[0x28]
80007808:	80 00       	ld.sh	r0,r0[0x0]
8000780a:	6c 52       	ld.w	r2,r6[0x14]
8000780c:	00 00       	add	r0,r0
8000780e:	0c a8       	st.w	r6++,r8

80007810 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80007810:	eb cd 40 c0 	pushm	r6-r7,lr
80007814:	18 97       	mov	r7,r12
80007816:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80007818:	f0 1f 00 15 	mcall	8000786c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000781c:	6c 08       	ld.w	r8,r6[0x0]
8000781e:	5b f8       	cp.w	r8,-1
80007820:	c0 31       	brne	80007826 <xTaskCheckForTimeOut+0x16>
80007822:	30 07       	mov	r7,0
80007824:	c1 f8       	rjmp	80007862 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80007826:	49 39       	lddpc	r9,80007870 <xTaskCheckForTimeOut+0x60>
80007828:	72 09       	ld.w	r9,r9[0x0]
8000782a:	6e 0a       	ld.w	r10,r7[0x0]
8000782c:	12 3a       	cp.w	r10,r9
8000782e:	c0 70       	breq	8000783c <xTaskCheckForTimeOut+0x2c>
80007830:	49 19       	lddpc	r9,80007874 <xTaskCheckForTimeOut+0x64>
80007832:	72 09       	ld.w	r9,r9[0x0]
80007834:	6e 1a       	ld.w	r10,r7[0x4]
80007836:	12 3a       	cp.w	r10,r9
80007838:	e0 88 00 14 	brls	80007860 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000783c:	48 e9       	lddpc	r9,80007874 <xTaskCheckForTimeOut+0x64>
8000783e:	72 0a       	ld.w	r10,r9[0x0]
80007840:	6e 19       	ld.w	r9,r7[0x4]
80007842:	12 1a       	sub	r10,r9
80007844:	14 38       	cp.w	r8,r10
80007846:	e0 88 00 0d 	brls	80007860 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000784a:	48 ba       	lddpc	r10,80007874 <xTaskCheckForTimeOut+0x64>
8000784c:	74 0a       	ld.w	r10,r10[0x0]
8000784e:	14 19       	sub	r9,r10
80007850:	f2 08 00 08 	add	r8,r9,r8
80007854:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80007856:	0e 9c       	mov	r12,r7
80007858:	f0 1f 00 08 	mcall	80007878 <xTaskCheckForTimeOut+0x68>
8000785c:	30 07       	mov	r7,0
8000785e:	c0 28       	rjmp	80007862 <xTaskCheckForTimeOut+0x52>
80007860:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80007862:	f0 1f 00 07 	mcall	8000787c <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80007866:	0e 9c       	mov	r12,r7
80007868:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000786c:	80 00       	ld.sh	r0,r0[0x0]
8000786e:	6d 5c       	ld.w	r12,r6[0x54]
80007870:	00 00       	add	r0,r0
80007872:	0c bc       	st.h	r6++,r12
80007874:	00 00       	add	r0,r0
80007876:	0d a4       	ld.ub	r4,r6[0x2]
80007878:	80 00       	ld.sh	r0,r0[0x0]
8000787a:	75 74       	ld.w	r4,r10[0x5c]
8000787c:	80 00       	ld.sh	r0,r0[0x0]
8000787e:	6e 68       	ld.w	r8,r7[0x18]

80007880 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80007880:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80007884:	f0 1f 00 05 	mcall	80007898 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80007888:	48 58       	lddpc	r8,8000789c <xTaskGetTickCount+0x1c>
8000788a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000788c:	f0 1f 00 05 	mcall	800078a0 <xTaskGetTickCount+0x20>

	return xTicks;
}
80007890:	0e 9c       	mov	r12,r7
80007892:	e3 cd 80 80 	ldm	sp++,r7,pc
80007896:	00 00       	add	r0,r0
80007898:	80 00       	ld.sh	r0,r0[0x0]
8000789a:	6d 5c       	ld.w	r12,r6[0x54]
8000789c:	00 00       	add	r0,r0
8000789e:	0d a4       	ld.ub	r4,r6[0x2]
800078a0:	80 00       	ld.sh	r0,r0[0x0]
800078a2:	6e 68       	ld.w	r8,r7[0x18]

800078a4 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800078a4:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800078a8:	f0 1f 00 2c 	mcall	80007958 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800078ac:	4a c8       	lddpc	r8,8000795c <xTaskResumeAll+0xb8>
800078ae:	70 09       	ld.w	r9,r8[0x0]
800078b0:	20 19       	sub	r9,1
800078b2:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800078b4:	70 08       	ld.w	r8,r8[0x0]
800078b6:	58 08       	cp.w	r8,0
800078b8:	c4 91       	brne	8000794a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800078ba:	4a a8       	lddpc	r8,80007960 <xTaskResumeAll+0xbc>
800078bc:	70 08       	ld.w	r8,r8[0x0]
800078be:	58 08       	cp.w	r8,0
800078c0:	c4 50       	breq	8000794a <xTaskResumeAll+0xa6>
800078c2:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800078c4:	4a 85       	lddpc	r5,80007964 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800078c6:	4a 93       	lddpc	r3,80007968 <xTaskResumeAll+0xc4>
800078c8:	4a 92       	lddpc	r2,8000796c <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800078ca:	4a a1       	lddpc	r1,80007970 <xTaskResumeAll+0xcc>
800078cc:	c1 e8       	rjmp	80007908 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800078ce:	6a 38       	ld.w	r8,r5[0xc]
800078d0:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800078d2:	ee cc ff e8 	sub	r12,r7,-24
800078d6:	f0 1f 00 28 	mcall	80007974 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800078da:	ee c6 ff fc 	sub	r6,r7,-4
800078de:	0c 9c       	mov	r12,r6
800078e0:	f0 1f 00 25 	mcall	80007974 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800078e4:	6e bc       	ld.w	r12,r7[0x2c]
800078e6:	66 08       	ld.w	r8,r3[0x0]
800078e8:	10 3c       	cp.w	r12,r8
800078ea:	e7 fc ba 00 	st.whi	r3[0x0],r12
800078ee:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800078f2:	0c 9b       	mov	r11,r6
800078f4:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800078f8:	f0 1f 00 20 	mcall	80007978 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800078fc:	62 08       	ld.w	r8,r1[0x0]
800078fe:	6e b9       	ld.w	r9,r7[0x2c]
80007900:	70 b8       	ld.w	r8,r8[0x2c]
80007902:	10 39       	cp.w	r9,r8
80007904:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80007908:	6a 08       	ld.w	r8,r5[0x0]
8000790a:	58 08       	cp.w	r8,0
8000790c:	ce 11       	brne	800078ce <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000790e:	49 c8       	lddpc	r8,8000797c <xTaskResumeAll+0xd8>
80007910:	70 08       	ld.w	r8,r8[0x0]
80007912:	58 08       	cp.w	r8,0
80007914:	c0 f0       	breq	80007932 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007916:	49 a8       	lddpc	r8,8000797c <xTaskResumeAll+0xd8>
80007918:	70 08       	ld.w	r8,r8[0x0]
8000791a:	58 08       	cp.w	r8,0
8000791c:	c1 10       	breq	8000793e <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000791e:	49 87       	lddpc	r7,8000797c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80007920:	f0 1f 00 18 	mcall	80007980 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80007924:	6e 08       	ld.w	r8,r7[0x0]
80007926:	20 18       	sub	r8,1
80007928:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000792a:	6e 08       	ld.w	r8,r7[0x0]
8000792c:	58 08       	cp.w	r8,0
8000792e:	cf 91       	brne	80007920 <xTaskResumeAll+0x7c>
80007930:	c0 78       	rjmp	8000793e <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80007932:	58 14       	cp.w	r4,1
80007934:	c0 50       	breq	8000793e <xTaskResumeAll+0x9a>
80007936:	49 48       	lddpc	r8,80007984 <xTaskResumeAll+0xe0>
80007938:	70 08       	ld.w	r8,r8[0x0]
8000793a:	58 18       	cp.w	r8,1
8000793c:	c0 71       	brne	8000794a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000793e:	30 09       	mov	r9,0
80007940:	49 18       	lddpc	r8,80007984 <xTaskResumeAll+0xe0>
80007942:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80007944:	d7 33       	scall
80007946:	30 17       	mov	r7,1
80007948:	c0 28       	rjmp	8000794c <xTaskResumeAll+0xa8>
8000794a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000794c:	f0 1f 00 0f 	mcall	80007988 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80007950:	0e 9c       	mov	r12,r7
80007952:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80007956:	00 00       	add	r0,r0
80007958:	80 00       	ld.sh	r0,r0[0x0]
8000795a:	6d 5c       	ld.w	r12,r6[0x54]
8000795c:	00 00       	add	r0,r0
8000795e:	0d a8       	ld.ub	r8,r6[0x2]
80007960:	00 00       	add	r0,r0
80007962:	0d c4       	ld.ub	r4,r6[0x4]
80007964:	00 00       	add	r0,r0
80007966:	0d 7c       	ld.ub	r12,--r6
80007968:	00 00       	add	r0,r0
8000796a:	0d e0       	ld.ub	r0,r6[0x6]
8000796c:	00 00       	add	r0,r0
8000796e:	0c c4       	st.b	r6++,r4
80007970:	00 00       	add	r0,r0
80007972:	0d 78       	ld.ub	r8,--r6
80007974:	80 00       	ld.sh	r0,r0[0x0]
80007976:	6c a2       	ld.w	r2,r6[0x28]
80007978:	80 00       	ld.sh	r0,r0[0x0]
8000797a:	6c 52       	ld.w	r2,r6[0x14]
8000797c:	00 00       	add	r0,r0
8000797e:	0c a8       	st.w	r6++,r8
80007980:	80 00       	ld.sh	r0,r0[0x0]
80007982:	76 fc       	ld.w	r12,r11[0x3c]
80007984:	00 00       	add	r0,r0
80007986:	0d c8       	ld.ub	r8,r6[0x4]
80007988:	80 00       	ld.sh	r0,r0[0x0]
8000798a:	6e 68       	ld.w	r8,r7[0x18]

8000798c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
8000798c:	eb cd 40 80 	pushm	r7,lr
80007990:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80007992:	49 08       	lddpc	r8,800079d0 <prvAddCurrentTaskToDelayedList+0x44>
80007994:	70 08       	ld.w	r8,r8[0x0]
80007996:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80007998:	48 f8       	lddpc	r8,800079d4 <prvAddCurrentTaskToDelayedList+0x48>
8000799a:	70 08       	ld.w	r8,r8[0x0]
8000799c:	10 3c       	cp.w	r12,r8
8000799e:	c0 a2       	brcc	800079b2 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800079a0:	48 c8       	lddpc	r8,800079d0 <prvAddCurrentTaskToDelayedList+0x44>
800079a2:	70 0b       	ld.w	r11,r8[0x0]
800079a4:	48 d8       	lddpc	r8,800079d8 <prvAddCurrentTaskToDelayedList+0x4c>
800079a6:	70 0c       	ld.w	r12,r8[0x0]
800079a8:	2f cb       	sub	r11,-4
800079aa:	f0 1f 00 0d 	mcall	800079dc <prvAddCurrentTaskToDelayedList+0x50>
800079ae:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800079b2:	48 88       	lddpc	r8,800079d0 <prvAddCurrentTaskToDelayedList+0x44>
800079b4:	70 0b       	ld.w	r11,r8[0x0]
800079b6:	48 b8       	lddpc	r8,800079e0 <prvAddCurrentTaskToDelayedList+0x54>
800079b8:	70 0c       	ld.w	r12,r8[0x0]
800079ba:	2f cb       	sub	r11,-4
800079bc:	f0 1f 00 08 	mcall	800079dc <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800079c0:	48 98       	lddpc	r8,800079e4 <prvAddCurrentTaskToDelayedList+0x58>
800079c2:	70 08       	ld.w	r8,r8[0x0]
800079c4:	10 37       	cp.w	r7,r8
800079c6:	c0 32       	brcc	800079cc <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800079c8:	48 78       	lddpc	r8,800079e4 <prvAddCurrentTaskToDelayedList+0x58>
800079ca:	91 07       	st.w	r8[0x0],r7
800079cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800079d0:	00 00       	add	r0,r0
800079d2:	0d 78       	ld.ub	r8,--r6
800079d4:	00 00       	add	r0,r0
800079d6:	0d a4       	ld.ub	r4,r6[0x2]
800079d8:	00 00       	add	r0,r0
800079da:	0c c0       	st.b	r6++,r0
800079dc:	80 00       	ld.sh	r0,r0[0x0]
800079de:	6c 6e       	ld.w	lr,r6[0x18]
800079e0:	00 00       	add	r0,r0
800079e2:	0c b0       	st.h	r6++,r0
800079e4:	00 00       	add	r0,r0
800079e6:	05 50       	ld.sh	r0,--r2

800079e8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800079e8:	eb cd 40 c0 	pushm	r6-r7,lr
800079ec:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800079ee:	58 0c       	cp.w	r12,0
800079f0:	c1 10       	breq	80007a12 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800079f2:	f0 1f 00 0a 	mcall	80007a18 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800079f6:	48 a8       	lddpc	r8,80007a1c <vTaskDelay+0x34>
800079f8:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800079fa:	48 a8       	lddpc	r8,80007a20 <vTaskDelay+0x38>
800079fc:	70 0c       	ld.w	r12,r8[0x0]
800079fe:	2f cc       	sub	r12,-4
80007a00:	f0 1f 00 09 	mcall	80007a24 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a04:	ee 06 00 0c 	add	r12,r7,r6
80007a08:	f0 1f 00 08 	mcall	80007a28 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80007a0c:	f0 1f 00 08 	mcall	80007a2c <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007a10:	c0 21       	brne	80007a14 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80007a12:	d7 33       	scall
80007a14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a18:	80 00       	ld.sh	r0,r0[0x0]
80007a1a:	74 e8       	ld.w	r8,r10[0x38]
80007a1c:	00 00       	add	r0,r0
80007a1e:	0d a4       	ld.ub	r4,r6[0x2]
80007a20:	00 00       	add	r0,r0
80007a22:	0d 78       	ld.ub	r8,--r6
80007a24:	80 00       	ld.sh	r0,r0[0x0]
80007a26:	6c a2       	ld.w	r2,r6[0x28]
80007a28:	80 00       	ld.sh	r0,r0[0x0]
80007a2a:	79 8c       	ld.w	r12,r12[0x60]
80007a2c:	80 00       	ld.sh	r0,r0[0x0]
80007a2e:	78 a4       	ld.w	r4,r12[0x28]

80007a30 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80007a30:	eb cd 40 c0 	pushm	r6-r7,lr
80007a34:	18 96       	mov	r6,r12
80007a36:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007a38:	f0 1f 00 18 	mcall	80007a98 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007a3c:	6c 08       	ld.w	r8,r6[0x0]
80007a3e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80007a40:	49 79       	lddpc	r9,80007a9c <vTaskDelayUntil+0x6c>
80007a42:	72 09       	ld.w	r9,r9[0x0]
80007a44:	12 38       	cp.w	r8,r9
80007a46:	e0 88 00 0c 	brls	80007a5e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80007a4a:	0e 38       	cp.w	r8,r7
80007a4c:	e0 88 00 22 	brls	80007a90 <vTaskDelayUntil+0x60>
80007a50:	49 38       	lddpc	r8,80007a9c <vTaskDelayUntil+0x6c>
80007a52:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007a54:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80007a56:	10 37       	cp.w	r7,r8
80007a58:	e0 88 00 14 	brls	80007a80 <vTaskDelayUntil+0x50>
80007a5c:	c0 a8       	rjmp	80007a70 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80007a5e:	0e 38       	cp.w	r8,r7
80007a60:	e0 8b 00 16 	brhi	80007a8c <vTaskDelayUntil+0x5c>
80007a64:	48 e8       	lddpc	r8,80007a9c <vTaskDelayUntil+0x6c>
80007a66:	70 08       	ld.w	r8,r8[0x0]
80007a68:	10 37       	cp.w	r7,r8
80007a6a:	e0 8b 00 11 	brhi	80007a8c <vTaskDelayUntil+0x5c>
80007a6e:	c1 18       	rjmp	80007a90 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007a70:	48 c8       	lddpc	r8,80007aa0 <vTaskDelayUntil+0x70>
80007a72:	70 0c       	ld.w	r12,r8[0x0]
80007a74:	2f cc       	sub	r12,-4
80007a76:	f0 1f 00 0c 	mcall	80007aa4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007a7a:	0e 9c       	mov	r12,r7
80007a7c:	f0 1f 00 0b 	mcall	80007aa8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007a80:	f0 1f 00 0b 	mcall	80007aac <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007a84:	c0 81       	brne	80007a94 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80007a86:	d7 33       	scall
80007a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007a8c:	8d 07       	st.w	r6[0x0],r7
80007a8e:	cf 1b       	rjmp	80007a70 <vTaskDelayUntil+0x40>
80007a90:	8d 07       	st.w	r6[0x0],r7
80007a92:	cf 7b       	rjmp	80007a80 <vTaskDelayUntil+0x50>
80007a94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a98:	80 00       	ld.sh	r0,r0[0x0]
80007a9a:	74 e8       	ld.w	r8,r10[0x38]
80007a9c:	00 00       	add	r0,r0
80007a9e:	0d a4       	ld.ub	r4,r6[0x2]
80007aa0:	00 00       	add	r0,r0
80007aa2:	0d 78       	ld.ub	r8,--r6
80007aa4:	80 00       	ld.sh	r0,r0[0x0]
80007aa6:	6c a2       	ld.w	r2,r6[0x28]
80007aa8:	80 00       	ld.sh	r0,r0[0x0]
80007aaa:	79 8c       	ld.w	r12,r12[0x60]
80007aac:	80 00       	ld.sh	r0,r0[0x0]
80007aae:	78 a4       	ld.w	r4,r12[0x28]

80007ab0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80007ab0:	eb cd 40 c0 	pushm	r6-r7,lr
80007ab4:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80007ab6:	48 e7       	lddpc	r7,80007aec <vTaskPlaceOnEventList+0x3c>
80007ab8:	6e 0b       	ld.w	r11,r7[0x0]
80007aba:	2e 8b       	sub	r11,-24
80007abc:	f0 1f 00 0d 	mcall	80007af0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007ac0:	6e 0c       	ld.w	r12,r7[0x0]
80007ac2:	2f cc       	sub	r12,-4
80007ac4:	f0 1f 00 0c 	mcall	80007af4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80007ac8:	5b f6       	cp.w	r6,-1
80007aca:	c0 81       	brne	80007ada <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007acc:	6e 0b       	ld.w	r11,r7[0x0]
80007ace:	2f cb       	sub	r11,-4
80007ad0:	48 ac       	lddpc	r12,80007af8 <vTaskPlaceOnEventList+0x48>
80007ad2:	f0 1f 00 0b 	mcall	80007afc <vTaskPlaceOnEventList+0x4c>
80007ad6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80007ada:	48 a8       	lddpc	r8,80007b00 <vTaskPlaceOnEventList+0x50>
80007adc:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80007ade:	ec 0c 00 0c 	add	r12,r6,r12
80007ae2:	f0 1f 00 09 	mcall	80007b04 <vTaskPlaceOnEventList+0x54>
80007ae6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007aea:	00 00       	add	r0,r0
80007aec:	00 00       	add	r0,r0
80007aee:	0d 78       	ld.ub	r8,--r6
80007af0:	80 00       	ld.sh	r0,r0[0x0]
80007af2:	6c 6e       	ld.w	lr,r6[0x18]
80007af4:	80 00       	ld.sh	r0,r0[0x0]
80007af6:	6c a2       	ld.w	r2,r6[0x28]
80007af8:	00 00       	add	r0,r0
80007afa:	0d cc       	ld.ub	r12,r6[0x4]
80007afc:	80 00       	ld.sh	r0,r0[0x0]
80007afe:	6c 52       	ld.w	r2,r6[0x14]
80007b00:	00 00       	add	r0,r0
80007b02:	0d a4       	ld.ub	r4,r6[0x2]
80007b04:	80 00       	ld.sh	r0,r0[0x0]
80007b06:	79 8c       	ld.w	r12,r12[0x60]

80007b08 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007b08:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007b0c:	49 67       	lddpc	r7,80007b64 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007b0e:	49 74       	lddpc	r4,80007b68 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80007b10:	49 73       	lddpc	r3,80007b6c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007b12:	49 85       	lddpc	r5,80007b70 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007b14:	6e 08       	ld.w	r8,r7[0x0]
80007b16:	58 08       	cp.w	r8,0
80007b18:	c1 e0       	breq	80007b54 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80007b1a:	f0 1f 00 17 	mcall	80007b74 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007b1e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80007b20:	f0 1f 00 16 	mcall	80007b78 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007b24:	58 06       	cp.w	r6,0
80007b26:	c1 70       	breq	80007b54 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007b28:	f0 1f 00 15 	mcall	80007b7c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007b2c:	68 38       	ld.w	r8,r4[0xc]
80007b2e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80007b30:	ec cc ff fc 	sub	r12,r6,-4
80007b34:	f0 1f 00 13 	mcall	80007b80 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007b38:	66 08       	ld.w	r8,r3[0x0]
80007b3a:	20 18       	sub	r8,1
80007b3c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80007b3e:	6e 08       	ld.w	r8,r7[0x0]
80007b40:	20 18       	sub	r8,1
80007b42:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007b44:	f0 1f 00 10 	mcall	80007b84 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007b48:	6c cc       	ld.w	r12,r6[0x30]
80007b4a:	f0 1f 00 10 	mcall	80007b88 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80007b4e:	0c 9c       	mov	r12,r6
80007b50:	f0 1f 00 0e 	mcall	80007b88 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007b54:	6a 08       	ld.w	r8,r5[0x0]
80007b56:	58 18       	cp.w	r8,1
80007b58:	e0 88 00 03 	brls	80007b5e <prvIdleTask+0x56>
			{
				taskYIELD();
80007b5c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80007b5e:	f0 1f 00 0c 	mcall	80007b8c <prvIdleTask+0x84>
		}
		#endif
	}
80007b62:	cd 9b       	rjmp	80007b14 <prvIdleTask+0xc>
80007b64:	00 00       	add	r0,r0
80007b66:	0c b8       	st.h	r6++,r8
80007b68:	00 00       	add	r0,r0
80007b6a:	0d 64       	ld.uh	r4,--r6
80007b6c:	00 00       	add	r0,r0
80007b6e:	0d c4       	ld.ub	r4,r6[0x4]
80007b70:	00 00       	add	r0,r0
80007b72:	0c c4       	st.b	r6++,r4
80007b74:	80 00       	ld.sh	r0,r0[0x0]
80007b76:	74 e8       	ld.w	r8,r10[0x38]
80007b78:	80 00       	ld.sh	r0,r0[0x0]
80007b7a:	78 a4       	ld.w	r4,r12[0x28]
80007b7c:	80 00       	ld.sh	r0,r0[0x0]
80007b7e:	6d 5c       	ld.w	r12,r6[0x54]
80007b80:	80 00       	ld.sh	r0,r0[0x0]
80007b82:	6c a2       	ld.w	r2,r6[0x28]
80007b84:	80 00       	ld.sh	r0,r0[0x0]
80007b86:	6e 68       	ld.w	r8,r7[0x18]
80007b88:	80 00       	ld.sh	r0,r0[0x0]
80007b8a:	6f a0       	ld.w	r0,r7[0x68]
80007b8c:	80 00       	ld.sh	r0,r0[0x0]
80007b8e:	20 2c       	sub	r12,2

80007b90 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007b90:	d4 31       	pushm	r0-r7,lr
80007b92:	20 1d       	sub	sp,4
80007b94:	fa c4 ff d8 	sub	r4,sp,-40
80007b98:	50 0c       	stdsp	sp[0x0],r12
80007b9a:	16 91       	mov	r1,r11
80007b9c:	14 97       	mov	r7,r10
80007b9e:	12 90       	mov	r0,r9
80007ba0:	10 93       	mov	r3,r8
80007ba2:	68 02       	ld.w	r2,r4[0x0]
80007ba4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80007ba6:	34 8c       	mov	r12,72
80007ba8:	f0 1f 00 5c 	mcall	80007d18 <xTaskGenericCreate+0x188>
80007bac:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80007bae:	c0 31       	brne	80007bb4 <xTaskGenericCreate+0x24>
80007bb0:	3f fc       	mov	r12,-1
80007bb2:	ca f8       	rjmp	80007d10 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007bb4:	58 06       	cp.w	r6,0
80007bb6:	e0 81 00 af 	brne	80007d14 <xTaskGenericCreate+0x184>
80007bba:	0e 9c       	mov	r12,r7
80007bbc:	5c 7c       	castu.h	r12
80007bbe:	a3 6c       	lsl	r12,0x2
80007bc0:	f0 1f 00 56 	mcall	80007d18 <xTaskGenericCreate+0x188>
80007bc4:	18 96       	mov	r6,r12
80007bc6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80007bc8:	c0 61       	brne	80007bd4 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80007bca:	0a 9c       	mov	r12,r5
80007bcc:	f0 1f 00 54 	mcall	80007d1c <xTaskGenericCreate+0x18c>
80007bd0:	3f fc       	mov	r12,-1
80007bd2:	c9 f8       	rjmp	80007d10 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80007bd4:	5c 77       	castu.h	r7
80007bd6:	ee 0a 15 02 	lsl	r10,r7,0x2
80007bda:	e0 6b 00 a5 	mov	r11,165
80007bde:	0c 9c       	mov	r12,r6
80007be0:	f0 1f 00 50 	mcall	80007d20 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007be4:	ee c6 00 01 	sub	r6,r7,1
80007be8:	6a c8       	ld.w	r8,r5[0x30]
80007bea:	f0 06 00 26 	add	r6,r8,r6<<0x2
80007bee:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80007bf2:	31 0a       	mov	r10,16
80007bf4:	02 9b       	mov	r11,r1
80007bf6:	ea cc ff cc 	sub	r12,r5,-52
80007bfa:	f0 1f 00 4b 	mcall	80007d24 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007bfe:	30 08       	mov	r8,0
80007c00:	eb 68 00 43 	st.b	r5[67],r8
80007c04:	58 73       	cp.w	r3,7
80007c06:	e6 07 17 80 	movls	r7,r3
80007c0a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007c0e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007c10:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007c14:	ea c4 ff fc 	sub	r4,r5,-4
80007c18:	08 9c       	mov	r12,r4
80007c1a:	f0 1f 00 44 	mcall	80007d28 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007c1e:	ea cc ff e8 	sub	r12,r5,-24
80007c22:	f0 1f 00 42 	mcall	80007d28 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007c26:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007c28:	ee 07 11 08 	rsub	r7,r7,8
80007c2c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007c2e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007c30:	00 9a       	mov	r10,r0
80007c32:	40 0b       	lddsp	r11,sp[0x0]
80007c34:	0c 9c       	mov	r12,r6
80007c36:	f0 1f 00 3e 	mcall	80007d2c <xTaskGenericCreate+0x19c>
80007c3a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007c3c:	58 02       	cp.w	r2,0
80007c3e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007c42:	f0 1f 00 3c 	mcall	80007d30 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007c46:	4b c8       	lddpc	r8,80007d34 <xTaskGenericCreate+0x1a4>
80007c48:	70 09       	ld.w	r9,r8[0x0]
80007c4a:	2f f9       	sub	r9,-1
80007c4c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007c4e:	4b b8       	lddpc	r8,80007d38 <xTaskGenericCreate+0x1a8>
80007c50:	70 08       	ld.w	r8,r8[0x0]
80007c52:	58 08       	cp.w	r8,0
80007c54:	c2 61       	brne	80007ca0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007c56:	4b 98       	lddpc	r8,80007d38 <xTaskGenericCreate+0x1a8>
80007c58:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007c5a:	4b 78       	lddpc	r8,80007d34 <xTaskGenericCreate+0x1a4>
80007c5c:	70 08       	ld.w	r8,r8[0x0]
80007c5e:	58 18       	cp.w	r8,1
80007c60:	c2 b1       	brne	80007cb6 <xTaskGenericCreate+0x126>
80007c62:	4b 77       	lddpc	r7,80007d3c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007c64:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007c68:	0e 9c       	mov	r12,r7
80007c6a:	f0 1f 00 36 	mcall	80007d40 <xTaskGenericCreate+0x1b0>
80007c6e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007c70:	0c 37       	cp.w	r7,r6
80007c72:	cf b1       	brne	80007c68 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007c74:	4b 47       	lddpc	r7,80007d44 <xTaskGenericCreate+0x1b4>
80007c76:	0e 9c       	mov	r12,r7
80007c78:	f0 1f 00 32 	mcall	80007d40 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007c7c:	4b 36       	lddpc	r6,80007d48 <xTaskGenericCreate+0x1b8>
80007c7e:	0c 9c       	mov	r12,r6
80007c80:	f0 1f 00 30 	mcall	80007d40 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007c84:	4b 2c       	lddpc	r12,80007d4c <xTaskGenericCreate+0x1bc>
80007c86:	f0 1f 00 2f 	mcall	80007d40 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80007c8a:	4b 2c       	lddpc	r12,80007d50 <xTaskGenericCreate+0x1c0>
80007c8c:	f0 1f 00 2d 	mcall	80007d40 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007c90:	4b 1c       	lddpc	r12,80007d54 <xTaskGenericCreate+0x1c4>
80007c92:	f0 1f 00 2c 	mcall	80007d40 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80007c96:	4b 18       	lddpc	r8,80007d58 <xTaskGenericCreate+0x1c8>
80007c98:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007c9a:	4b 18       	lddpc	r8,80007d5c <xTaskGenericCreate+0x1cc>
80007c9c:	91 06       	st.w	r8[0x0],r6
80007c9e:	c0 c8       	rjmp	80007cb6 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007ca0:	4b 08       	lddpc	r8,80007d60 <xTaskGenericCreate+0x1d0>
80007ca2:	70 08       	ld.w	r8,r8[0x0]
80007ca4:	58 08       	cp.w	r8,0
80007ca6:	c0 81       	brne	80007cb6 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007ca8:	4a 48       	lddpc	r8,80007d38 <xTaskGenericCreate+0x1a8>
80007caa:	70 08       	ld.w	r8,r8[0x0]
80007cac:	70 b8       	ld.w	r8,r8[0x2c]
80007cae:	10 33       	cp.w	r3,r8
80007cb0:	c0 33       	brcs	80007cb6 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80007cb2:	4a 28       	lddpc	r8,80007d38 <xTaskGenericCreate+0x1a8>
80007cb4:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007cb6:	6a b8       	ld.w	r8,r5[0x2c]
80007cb8:	4a b9       	lddpc	r9,80007d64 <xTaskGenericCreate+0x1d4>
80007cba:	72 09       	ld.w	r9,r9[0x0]
80007cbc:	12 38       	cp.w	r8,r9
80007cbe:	e0 88 00 04 	brls	80007cc6 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80007cc2:	4a 99       	lddpc	r9,80007d64 <xTaskGenericCreate+0x1d4>
80007cc4:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80007cc6:	4a 98       	lddpc	r8,80007d68 <xTaskGenericCreate+0x1d8>
80007cc8:	70 09       	ld.w	r9,r8[0x0]
80007cca:	2f f9       	sub	r9,-1
80007ccc:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80007cce:	6a b8       	ld.w	r8,r5[0x2c]
80007cd0:	4a 79       	lddpc	r9,80007d6c <xTaskGenericCreate+0x1dc>
80007cd2:	72 09       	ld.w	r9,r9[0x0]
80007cd4:	12 38       	cp.w	r8,r9
80007cd6:	e0 88 00 04 	brls	80007cde <xTaskGenericCreate+0x14e>
80007cda:	4a 59       	lddpc	r9,80007d6c <xTaskGenericCreate+0x1dc>
80007cdc:	93 08       	st.w	r9[0x0],r8
80007cde:	6a bc       	ld.w	r12,r5[0x2c]
80007ce0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007ce4:	08 9b       	mov	r11,r4
80007ce6:	49 68       	lddpc	r8,80007d3c <xTaskGenericCreate+0x1ac>
80007ce8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007cec:	f0 1f 00 21 	mcall	80007d70 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007cf0:	f0 1f 00 21 	mcall	80007d74 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007cf4:	49 b8       	lddpc	r8,80007d60 <xTaskGenericCreate+0x1d0>
80007cf6:	70 08       	ld.w	r8,r8[0x0]
80007cf8:	58 08       	cp.w	r8,0
80007cfa:	c0 a0       	breq	80007d0e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007cfc:	48 f8       	lddpc	r8,80007d38 <xTaskGenericCreate+0x1a8>
80007cfe:	70 08       	ld.w	r8,r8[0x0]
80007d00:	70 b8       	ld.w	r8,r8[0x2c]
80007d02:	10 33       	cp.w	r3,r8
80007d04:	e0 88 00 05 	brls	80007d0e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007d08:	d7 33       	scall
80007d0a:	30 1c       	mov	r12,1
80007d0c:	c0 28       	rjmp	80007d10 <xTaskGenericCreate+0x180>
80007d0e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007d10:	2f fd       	sub	sp,-4
80007d12:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007d14:	99 c6       	st.w	r12[0x30],r6
80007d16:	c5 fb       	rjmp	80007bd4 <xTaskGenericCreate+0x44>
80007d18:	80 00       	ld.sh	r0,r0[0x0]
80007d1a:	6f c8       	ld.w	r8,r7[0x70]
80007d1c:	80 00       	ld.sh	r0,r0[0x0]
80007d1e:	6f a0       	ld.w	r0,r7[0x68]
80007d20:	80 00       	ld.sh	r0,r0[0x0]
80007d22:	89 46       	st.w	r4[0x10],r6
80007d24:	80 00       	ld.sh	r0,r0[0x0]
80007d26:	8c 70       	ld.sh	r0,r6[0xe]
80007d28:	80 00       	ld.sh	r0,r0[0x0]
80007d2a:	6c 4c       	ld.w	r12,r6[0x10]
80007d2c:	80 00       	ld.sh	r0,r0[0x0]
80007d2e:	6c c8       	ld.w	r8,r6[0x30]
80007d30:	80 00       	ld.sh	r0,r0[0x0]
80007d32:	6d 5c       	ld.w	r12,r6[0x54]
80007d34:	00 00       	add	r0,r0
80007d36:	0d c4       	ld.ub	r4,r6[0x4]
80007d38:	00 00       	add	r0,r0
80007d3a:	0d 78       	ld.ub	r8,--r6
80007d3c:	00 00       	add	r0,r0
80007d3e:	0c c4       	st.b	r6++,r4
80007d40:	80 00       	ld.sh	r0,r0[0x0]
80007d42:	6c 38       	ld.w	r8,r6[0xc]
80007d44:	00 00       	add	r0,r0
80007d46:	0d 90       	ld.ub	r0,r6[0x1]
80007d48:	00 00       	add	r0,r0
80007d4a:	0d ac       	ld.ub	r12,r6[0x2]
80007d4c:	00 00       	add	r0,r0
80007d4e:	0d 7c       	ld.ub	r12,--r6
80007d50:	00 00       	add	r0,r0
80007d52:	0d 64       	ld.uh	r4,--r6
80007d54:	00 00       	add	r0,r0
80007d56:	0d cc       	ld.ub	r12,r6[0x4]
80007d58:	00 00       	add	r0,r0
80007d5a:	0c b0       	st.h	r6++,r0
80007d5c:	00 00       	add	r0,r0
80007d5e:	0c c0       	st.b	r6++,r0
80007d60:	00 00       	add	r0,r0
80007d62:	0c b4       	st.h	r6++,r4
80007d64:	00 00       	add	r0,r0
80007d66:	0c ac       	st.w	r6++,r12
80007d68:	00 00       	add	r0,r0
80007d6a:	0d c0       	ld.ub	r0,r6[0x4]
80007d6c:	00 00       	add	r0,r0
80007d6e:	0d e0       	ld.ub	r0,r6[0x6]
80007d70:	80 00       	ld.sh	r0,r0[0x0]
80007d72:	6c 52       	ld.w	r2,r6[0x14]
80007d74:	80 00       	ld.sh	r0,r0[0x0]
80007d76:	6e 68       	ld.w	r8,r7[0x18]

80007d78 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007d78:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007d7a:	30 09       	mov	r9,0
80007d7c:	1a d9       	st.w	--sp,r9
80007d7e:	1a d9       	st.w	--sp,r9
80007d80:	1a d9       	st.w	--sp,r9
80007d82:	12 98       	mov	r8,r9
80007d84:	e0 6a 01 00 	mov	r10,256
80007d88:	48 9b       	lddpc	r11,80007dac <vTaskStartScheduler+0x34>
80007d8a:	48 ac       	lddpc	r12,80007db0 <vTaskStartScheduler+0x38>
80007d8c:	f0 1f 00 0a 	mcall	80007db4 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007d90:	2f dd       	sub	sp,-12
80007d92:	58 1c       	cp.w	r12,1
80007d94:	c0 a1       	brne	80007da8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007d96:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007d98:	30 19       	mov	r9,1
80007d9a:	48 88       	lddpc	r8,80007db8 <vTaskStartScheduler+0x40>
80007d9c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80007d9e:	30 09       	mov	r9,0
80007da0:	48 78       	lddpc	r8,80007dbc <vTaskStartScheduler+0x44>
80007da2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007da4:	f0 1f 00 07 	mcall	80007dc0 <vTaskStartScheduler+0x48>
80007da8:	d8 02       	popm	pc
80007daa:	00 00       	add	r0,r0
80007dac:	80 00       	ld.sh	r0,r0[0x0]
80007dae:	ed 8c       	*unknown*
80007db0:	80 00       	ld.sh	r0,r0[0x0]
80007db2:	7b 08       	ld.w	r8,sp[0x40]
80007db4:	80 00       	ld.sh	r0,r0[0x0]
80007db6:	7b 90       	ld.w	r0,sp[0x64]
80007db8:	00 00       	add	r0,r0
80007dba:	0c b4       	st.h	r6++,r4
80007dbc:	00 00       	add	r0,r0
80007dbe:	0d a4       	ld.ub	r4,r6[0x2]
80007dc0:	80 00       	ld.sh	r0,r0[0x0]
80007dc2:	6d 6c       	ld.w	r12,r6[0x58]

80007dc4 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80007dc4:	16 cc       	st.b	r11++,r12
	return str;
}
80007dc6:	5e fb       	retal	r11

80007dc8 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80007dc8:	eb cd 40 c0 	pushm	r6-r7,lr
80007dcc:	20 3d       	sub	sp,12
80007dce:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80007dd0:	30 06       	mov	r6,0
80007dd2:	30 07       	mov	r7,0
80007dd4:	fa e7 00 00 	st.d	sp[0],r6
80007dd8:	30 0c       	mov	r12,0
80007dda:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007ddc:	58 08       	cp.w	r8,0
80007dde:	c1 30       	breq	80007e04 <PrintHex+0x3c>
80007de0:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80007de2:	1a 9c       	mov	r12,sp
80007de4:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007de8:	58 9e       	cp.w	lr,9
80007dea:	e0 8a 00 04 	brle	80007df2 <PrintHex+0x2a>
80007dee:	2c 9e       	sub	lr,-55
80007df0:	c0 48       	rjmp	80007df8 <PrintHex+0x30>
80007df2:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007df6:	2d 0e       	sub	lr,-48
80007df8:	f8 09 0b 0e 	st.b	r12[r9],lr
80007dfc:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007dfe:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007e00:	cf 21       	brne	80007de4 <PrintHex+0x1c>
80007e02:	c0 48       	rjmp	80007e0a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007e04:	33 08       	mov	r8,48
80007e06:	ba 88       	st.b	sp[0x0],r8
80007e08:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007e0a:	f6 09 01 08 	sub	r8,r11,r9
80007e0e:	58 08       	cp.w	r8,0
80007e10:	e0 8a 00 13 	brle	80007e36 <PrintHex+0x6e>
	{
		char num = len - cnt;
80007e14:	12 1b       	sub	r11,r9
80007e16:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007e1a:	18 9e       	mov	lr,r12
80007e1c:	58 0c       	cp.w	r12,0
80007e1e:	e0 8a 00 0c 	brle	80007e36 <PrintHex+0x6e>
80007e22:	1a 9b       	mov	r11,sp
80007e24:	12 0b       	add	r11,r9
80007e26:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007e28:	33 07       	mov	r7,48
80007e2a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007e2c:	2f f8       	sub	r8,-1
80007e2e:	1c 38       	cp.w	r8,lr
80007e30:	cf d5       	brlt	80007e2a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007e32:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007e36:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007e3a:	f0 cb ff ff 	sub	r11,r8,-1
80007e3e:	58 0b       	cp.w	r11,0
80007e40:	e0 8a 00 19 	brle	80007e72 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007e44:	fa cb ff f4 	sub	r11,sp,-12
80007e48:	f6 09 00 09 	add	r9,r11,r9
80007e4c:	37 8b       	mov	r11,120
80007e4e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007e52:	fa c9 ff f4 	sub	r9,sp,-12
80007e56:	10 09       	add	r9,r8
80007e58:	33 0b       	mov	r11,48
80007e5a:	f3 6b ff f4 	st.b	r9[-12],r11
80007e5e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007e62:	fa ce 00 01 	sub	lr,sp,1
80007e66:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007e68:	11 8b       	ld.ub	r11,r8[0x0]
80007e6a:	12 cb       	st.b	r9++,r11
80007e6c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007e6e:	1c 38       	cp.w	r8,lr
80007e70:	cf c1       	brne	80007e68 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007e72:	14 9c       	mov	r12,r10
80007e74:	2f dd       	sub	sp,-12
80007e76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007e7a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007e7a:	d4 21       	pushm	r4-r7,lr
80007e7c:	20 3d       	sub	sp,12
80007e7e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007e80:	30 06       	mov	r6,0
80007e82:	30 07       	mov	r7,0
80007e84:	fa e7 00 00 	st.d	sp[0],r6
80007e88:	30 0c       	mov	r12,0
80007e8a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007e8c:	58 08       	cp.w	r8,0
80007e8e:	c0 35       	brlt	80007e94 <PrintDec+0x1a>
80007e90:	14 97       	mov	r7,r10
80007e92:	c0 58       	rjmp	80007e9c <PrintDec+0x22>
	{
		*p++ = '-';
80007e94:	14 97       	mov	r7,r10
80007e96:	32 d9       	mov	r9,45
80007e98:	0e c9       	st.b	r7++,r9
		i = -i;
80007e9a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007e9c:	58 08       	cp.w	r8,0
80007e9e:	c0 51       	brne	80007ea8 <PrintDec+0x2e>
80007ea0:	33 08       	mov	r8,48
80007ea2:	ba 88       	st.b	sp[0x0],r8
80007ea4:	30 1e       	mov	lr,1
80007ea6:	c2 f8       	rjmp	80007f04 <PrintDec+0x8a>
	
	int ten = i%10;
80007ea8:	e0 65 66 67 	mov	r5,26215
80007eac:	ea 15 66 66 	orh	r5,0x6666
80007eb0:	f0 05 04 44 	muls.d	r4,r8,r5
80007eb4:	ea 0c 14 02 	asr	r12,r5,0x2
80007eb8:	f0 09 14 1f 	asr	r9,r8,0x1f
80007ebc:	f8 09 01 09 	sub	r9,r12,r9
80007ec0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ec4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80007ec8:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80007eca:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80007ecc:	e0 66 66 67 	mov	r6,26215
80007ed0:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007ed4:	2d 09       	sub	r9,-48
80007ed6:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007eda:	2f fe       	sub	lr,-1
		i /= 10;
80007edc:	f0 06 04 44 	muls.d	r4,r8,r6
80007ee0:	ea 09 14 02 	asr	r9,r5,0x2
80007ee4:	bf 58       	asr	r8,0x1f
80007ee6:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007eea:	f0 06 04 44 	muls.d	r4,r8,r6
80007eee:	ea 09 14 02 	asr	r9,r5,0x2
80007ef2:	f0 05 14 1f 	asr	r5,r8,0x1f
80007ef6:	0a 19       	sub	r9,r5
80007ef8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007efc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007f00:	58 08       	cp.w	r8,0
80007f02:	ce 91       	brne	80007ed4 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007f04:	f6 0e 01 08 	sub	r8,r11,lr
80007f08:	58 08       	cp.w	r8,0
80007f0a:	e0 89 00 06 	brgt	80007f16 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007f0e:	58 0e       	cp.w	lr,0
80007f10:	e0 89 00 14 	brgt	80007f38 <PrintDec+0xbe>
80007f14:	c1 d8       	rjmp	80007f4e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007f16:	1c 1b       	sub	r11,lr
80007f18:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007f1a:	16 9c       	mov	r12,r11
80007f1c:	58 0b       	cp.w	r11,0
80007f1e:	fe 9a ff f8 	brle	80007f0e <PrintDec+0x94>
80007f22:	1a 99       	mov	r9,sp
80007f24:	1c 09       	add	r9,lr
80007f26:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007f28:	33 06       	mov	r6,48
80007f2a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007f2c:	2f f8       	sub	r8,-1
80007f2e:	18 38       	cp.w	r8,r12
80007f30:	cf d5       	brlt	80007f2a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007f32:	f6 0e 00 0e 	add	lr,r11,lr
80007f36:	ce cb       	rjmp	80007f0e <PrintDec+0x94>
80007f38:	fa c8 ff f4 	sub	r8,sp,-12
80007f3c:	1c 08       	add	r8,lr
80007f3e:	20 d8       	sub	r8,13
80007f40:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007f44:	11 89       	ld.ub	r9,r8[0x0]
80007f46:	0e c9       	st.b	r7++,r9
80007f48:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007f4a:	16 38       	cp.w	r8,r11
80007f4c:	cf c1       	brne	80007f44 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007f4e:	14 9c       	mov	r12,r10
80007f50:	2f dd       	sub	sp,-12
80007f52:	d8 22       	popm	r4-r7,pc

80007f54 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007f54:	d4 31       	pushm	r0-r7,lr
80007f56:	fa cd 02 08 	sub	sp,sp,520
80007f5a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007f5c:	e0 6a 01 00 	mov	r10,256
80007f60:	30 0b       	mov	r11,0
80007f62:	fa cc fe f8 	sub	r12,sp,-264
80007f66:	f0 1f 00 4e 	mcall	8000809c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007f6a:	fa c4 fd d4 	sub	r4,sp,-556
80007f6e:	30 0a       	mov	r10,0
80007f70:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f72:	fa c3 ff fc 	sub	r3,sp,-4
80007f76:	e0 61 01 00 	mov	r1,256
80007f7a:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007f7c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007f7e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f82:	02 9a       	mov	r10,r1
80007f84:	00 9b       	mov	r11,r0
80007f86:	06 9c       	mov	r12,r3
80007f88:	f0 1f 00 45 	mcall	8000809c <log+0x148>
			
					if(*str == '%')
80007f8c:	0f 88       	ld.ub	r8,r7[0x0]
80007f8e:	e4 08 18 00 	cp.b	r8,r2
80007f92:	c5 71       	brne	80008040 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007f94:	ee c8 ff ff 	sub	r8,r7,-1
80007f98:	11 89       	ld.ub	r9,r8[0x0]
80007f9a:	4c 2a       	lddpc	r10,800080a0 <log+0x14c>
80007f9c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007f9e:	23 09       	sub	r9,48
80007fa0:	30 9a       	mov	r10,9
80007fa2:	f4 09 18 00 	cp.b	r9,r10
80007fa6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007faa:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007fae:	f7 b9 08 30 	subls	r9,48
80007fb2:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007fb6:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007fba:	0f 88       	ld.ub	r8,r7[0x0]
80007fbc:	22 58       	sub	r8,37
80007fbe:	e0 48 00 53 	cp.w	r8,83
80007fc2:	e0 8b 00 31 	brhi	80008024 <log+0xd0>
80007fc6:	4b 89       	lddpc	r9,800080a4 <log+0x150>
80007fc8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007fcc:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007fd0:	06 9a       	mov	r10,r3
80007fd2:	40 0b       	lddsp	r11,sp[0x0]
80007fd4:	5c 5b       	castu.b	r11
80007fd6:	68 0c       	ld.w	r12,r4[0x0]
80007fd8:	f0 1f 00 34 	mcall	800080a8 <log+0x154>
							break;
80007fdc:	c2 98       	rjmp	8000802e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80007fde:	4b 4c       	lddpc	r12,800080ac <log+0x158>
80007fe0:	f0 1f 00 34 	mcall	800080b0 <log+0x15c>
80007fe4:	08 95       	mov	r5,r4
80007fe6:	06 9c       	mov	r12,r3
							break;
80007fe8:	c2 38       	rjmp	8000802e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007fea:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80007fee:	06 9a       	mov	r10,r3
80007ff0:	40 0b       	lddsp	r11,sp[0x0]
80007ff2:	5c 5b       	castu.b	r11
80007ff4:	68 0c       	ld.w	r12,r4[0x0]
80007ff6:	f0 1f 00 30 	mcall	800080b4 <log+0x160>
80007ffa:	06 9c       	mov	r12,r3
							break;
80007ffc:	c1 98       	rjmp	8000802e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80007ffe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80008002:	06 9b       	mov	r11,r3
80008004:	09 bc       	ld.ub	r12,r4[0x3]
80008006:	f0 1f 00 2d 	mcall	800080b8 <log+0x164>
8000800a:	06 9c       	mov	r12,r3
							break;
8000800c:	c1 18       	rjmp	8000802e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000800e:	e8 c5 ff fc 	sub	r5,r4,-4
80008012:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80008014:	c0 d8       	rjmp	8000802e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80008016:	06 9b       	mov	r11,r3
80008018:	32 5c       	mov	r12,37
8000801a:	f0 1f 00 28 	mcall	800080b8 <log+0x164>
8000801e:	08 95       	mov	r5,r4
80008020:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80008022:	c0 68       	rjmp	8000802e <log+0xda>
							
							default:
							log("I need relax.");
80008024:	4a 6c       	lddpc	r12,800080bc <log+0x168>
80008026:	f0 1f 00 23 	mcall	800080b0 <log+0x15c>
8000802a:	08 95       	mov	r5,r4
8000802c:	06 9c       	mov	r12,r3
						}
						str++;
8000802e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80008030:	1a dc       	st.w	--sp,r12
80008032:	1a d6       	st.w	--sp,r6
80008034:	4a 3b       	lddpc	r11,800080c0 <log+0x16c>
80008036:	0c 9c       	mov	r12,r6
80008038:	f0 1f 00 23 	mcall	800080c4 <log+0x170>
8000803c:	2f ed       	sub	sp,-8
8000803e:	c0 a8       	rjmp	80008052 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80008040:	2f f7       	sub	r7,-1
80008042:	1a d8       	st.w	--sp,r8
80008044:	1a d6       	st.w	--sp,r6
80008046:	4a 1b       	lddpc	r11,800080c8 <log+0x174>
80008048:	0c 9c       	mov	r12,r6
8000804a:	f0 1f 00 1f 	mcall	800080c4 <log+0x170>
8000804e:	08 95       	mov	r5,r4
80008050:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80008052:	0f 89       	ld.ub	r9,r7[0x0]
80008054:	30 08       	mov	r8,0
80008056:	f0 09 18 00 	cp.b	r9,r8
8000805a:	c0 30       	breq	80008060 <log+0x10c>
8000805c:	0a 94       	mov	r4,r5
8000805e:	c9 2b       	rjmp	80007f82 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80008060:	fa c7 fe f8 	sub	r7,sp,-264
80008064:	1a d7       	st.w	--sp,r7
80008066:	49 ab       	lddpc	r11,800080cc <log+0x178>
80008068:	0e 9c       	mov	r12,r7
8000806a:	f0 1f 00 17 	mcall	800080c4 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000806e:	5c 5c       	castu.b	r12
80008070:	f8 c6 ff ff 	sub	r6,r12,-1
80008074:	0c 9c       	mov	r12,r6
80008076:	f0 1f 00 17 	mcall	800080d0 <log+0x17c>
8000807a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000807c:	0c 9a       	mov	r10,r6
8000807e:	0e 9b       	mov	r11,r7
80008080:	f0 1f 00 15 	mcall	800080d4 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80008084:	30 09       	mov	r9,0
80008086:	30 5a       	mov	r10,5
80008088:	fa cb fe f8 	sub	r11,sp,-264
8000808c:	49 38       	lddpc	r8,800080d8 <log+0x184>
8000808e:	70 0c       	ld.w	r12,r8[0x0]
80008090:	f0 1f 00 13 	mcall	800080dc <log+0x188>
80008094:	2f fd       	sub	sp,-4
	
	
}
80008096:	fe 3d fd f8 	sub	sp,-520
8000809a:	d8 32       	popm	r0-r7,pc
8000809c:	80 00       	ld.sh	r0,r0[0x0]
8000809e:	89 46       	st.w	r4[0x10],r6
800080a0:	00 00       	add	r0,r0
800080a2:	0d e4       	ld.ub	r4,r6[0x6]
800080a4:	80 00       	ld.sh	r0,r0[0x0]
800080a6:	ed 94       	*unknown*
800080a8:	80 00       	ld.sh	r0,r0[0x0]
800080aa:	7e 7a       	ld.w	r10,pc[0x1c]
800080ac:	80 00       	ld.sh	r0,r0[0x0]
800080ae:	f0 40 80 00 	cp.w	r0,-1015808
800080b2:	7f 54       	ld.w	r4,pc[0x54]
800080b4:	80 00       	ld.sh	r0,r0[0x0]
800080b6:	7d c8       	ld.w	r8,lr[0x70]
800080b8:	80 00       	ld.sh	r0,r0[0x0]
800080ba:	7d c4       	ld.w	r4,lr[0x70]
800080bc:	80 00       	ld.sh	r0,r0[0x0]
800080be:	f0 50 80 00 	cp.w	r0,-950272
800080c2:	f0 60 80 00 	mov	r0,-1015808
800080c6:	8c 34       	ld.sh	r4,r6[0x6]
800080c8:	80 00       	ld.sh	r0,r0[0x0]
800080ca:	f0 68 80 00 	mov	r8,-1015808
800080ce:	f0 70 80 00 	mov	r0,-950272
800080d2:	6f c8       	ld.w	r8,r7[0x70]
800080d4:	80 00       	ld.sh	r0,r0[0x0]
800080d6:	87 fe       	st.w	r3[0x3c],lr
800080d8:	00 00       	add	r0,r0
800080da:	bd 48       	asr	r8,0x1c
800080dc:	80 00       	ld.sh	r0,r0[0x0]
800080de:	73 1c       	ld.w	r12,r9[0x44]

800080e0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800080e0:	d4 31       	pushm	r0-r7,lr
800080e2:	fa cd 02 0c 	sub	sp,sp,524
800080e6:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800080e8:	e0 6a 01 00 	mov	r10,256
800080ec:	30 0b       	mov	r11,0
800080ee:	fa cc fe f4 	sub	r12,sp,-268
800080f2:	f0 1f 00 4c 	mcall	80008220 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800080f6:	fa c4 fd d0 	sub	r4,sp,-560
800080fa:	30 0a       	mov	r10,0
800080fc:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800080fe:	fa c3 ff fc 	sub	r3,sp,-4
80008102:	e0 61 01 00 	mov	r1,256
80008106:	14 90       	mov	r0,r10
			
			if(*str == '%')
80008108:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000810a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000810e:	02 9a       	mov	r10,r1
80008110:	00 9b       	mov	r11,r0
80008112:	06 9c       	mov	r12,r3
80008114:	f0 1f 00 43 	mcall	80008220 <logFromISR+0x140>
			
			if(*str == '%')
80008118:	0f 88       	ld.ub	r8,r7[0x0]
8000811a:	e4 08 18 00 	cp.b	r8,r2
8000811e:	c5 11       	brne	800081c0 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80008120:	ee c8 ff ff 	sub	r8,r7,-1
80008124:	11 89       	ld.ub	r9,r8[0x0]
80008126:	4c 0a       	lddpc	r10,80008224 <logFromISR+0x144>
80008128:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000812a:	23 09       	sub	r9,48
8000812c:	30 9a       	mov	r10,9
8000812e:	f4 09 18 00 	cp.b	r9,r10
80008132:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80008136:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000813a:	f7 b9 08 30 	subls	r9,48
8000813e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80008142:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80008146:	0f 88       	ld.ub	r8,r7[0x0]
80008148:	22 58       	sub	r8,37
8000814a:	e0 48 00 53 	cp.w	r8,83
8000814e:	e0 8b 00 2b 	brhi	800081a4 <logFromISR+0xc4>
80008152:	4b 69       	lddpc	r9,80008228 <logFromISR+0x148>
80008154:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80008158:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000815c:	06 9a       	mov	r10,r3
8000815e:	40 0b       	lddsp	r11,sp[0x0]
80008160:	5c 5b       	castu.b	r11
80008162:	68 0c       	ld.w	r12,r4[0x0]
80008164:	f0 1f 00 32 	mcall	8000822c <logFromISR+0x14c>
					break;
80008168:	c2 38       	rjmp	800081ae <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000816a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000816e:	06 9a       	mov	r10,r3
80008170:	40 0b       	lddsp	r11,sp[0x0]
80008172:	5c 5b       	castu.b	r11
80008174:	68 0c       	ld.w	r12,r4[0x0]
80008176:	f0 1f 00 2f 	mcall	80008230 <logFromISR+0x150>
8000817a:	06 9c       	mov	r12,r3
					break;
8000817c:	c1 98       	rjmp	800081ae <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000817e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80008182:	06 9b       	mov	r11,r3
80008184:	09 bc       	ld.ub	r12,r4[0x3]
80008186:	f0 1f 00 2c 	mcall	80008234 <logFromISR+0x154>
8000818a:	06 9c       	mov	r12,r3
					break;
8000818c:	c1 18       	rjmp	800081ae <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000818e:	e8 c5 ff fc 	sub	r5,r4,-4
80008192:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80008194:	c0 d8       	rjmp	800081ae <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80008196:	06 9b       	mov	r11,r3
80008198:	32 5c       	mov	r12,37
8000819a:	f0 1f 00 27 	mcall	80008234 <logFromISR+0x154>
8000819e:	08 95       	mov	r5,r4
800081a0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800081a2:	c0 68       	rjmp	800081ae <logFromISR+0xce>
					default:
					log("I need relax.");
800081a4:	4a 5c       	lddpc	r12,80008238 <logFromISR+0x158>
800081a6:	f0 1f 00 26 	mcall	8000823c <logFromISR+0x15c>
800081aa:	08 95       	mov	r5,r4
800081ac:	06 9c       	mov	r12,r3
				}
				str++;
800081ae:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800081b0:	1a dc       	st.w	--sp,r12
800081b2:	1a d6       	st.w	--sp,r6
800081b4:	4a 3b       	lddpc	r11,80008240 <logFromISR+0x160>
800081b6:	0c 9c       	mov	r12,r6
800081b8:	f0 1f 00 23 	mcall	80008244 <logFromISR+0x164>
800081bc:	2f ed       	sub	sp,-8
800081be:	c0 a8       	rjmp	800081d2 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800081c0:	2f f7       	sub	r7,-1
800081c2:	1a d8       	st.w	--sp,r8
800081c4:	1a d6       	st.w	--sp,r6
800081c6:	4a 1b       	lddpc	r11,80008248 <logFromISR+0x168>
800081c8:	0c 9c       	mov	r12,r6
800081ca:	f0 1f 00 1f 	mcall	80008244 <logFromISR+0x164>
800081ce:	08 95       	mov	r5,r4
800081d0:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800081d2:	0f 89       	ld.ub	r9,r7[0x0]
800081d4:	30 08       	mov	r8,0
800081d6:	f0 09 18 00 	cp.b	r9,r8
800081da:	c0 30       	breq	800081e0 <logFromISR+0x100>
800081dc:	0a 94       	mov	r4,r5
800081de:	c9 8b       	rjmp	8000810e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800081e0:	fa c7 fe f4 	sub	r7,sp,-268
800081e4:	1a d7       	st.w	--sp,r7
800081e6:	49 ab       	lddpc	r11,8000824c <logFromISR+0x16c>
800081e8:	0e 9c       	mov	r12,r7
800081ea:	f0 1f 00 17 	mcall	80008244 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800081ee:	5c 5c       	castu.b	r12
800081f0:	f8 c6 ff ff 	sub	r6,r12,-1
800081f4:	0c 9c       	mov	r12,r6
800081f6:	f0 1f 00 17 	mcall	80008250 <logFromISR+0x170>
800081fa:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800081fc:	0c 9a       	mov	r10,r6
800081fe:	0e 9b       	mov	r11,r7
80008200:	f0 1f 00 15 	mcall	80008254 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80008204:	30 09       	mov	r9,0
80008206:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80008208:	fa ca fe f8 	sub	r10,sp,-264
8000820c:	fa cb fe f4 	sub	r11,sp,-268
80008210:	49 28       	lddpc	r8,80008258 <logFromISR+0x178>
80008212:	70 0c       	ld.w	r12,r8[0x0]
80008214:	f0 1f 00 12 	mcall	8000825c <logFromISR+0x17c>
80008218:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000821a:	fe 3d fd f4 	sub	sp,-524
8000821e:	d8 32       	popm	r0-r7,pc
80008220:	80 00       	ld.sh	r0,r0[0x0]
80008222:	89 46       	st.w	r4[0x10],r6
80008224:	00 00       	add	r0,r0
80008226:	0d e5       	ld.ub	r5,r6[0x6]
80008228:	80 00       	ld.sh	r0,r0[0x0]
8000822a:	ee e4 80 00 	ld.d	r4,r7[-32768]
8000822e:	7e 7a       	ld.w	r10,pc[0x1c]
80008230:	80 00       	ld.sh	r0,r0[0x0]
80008232:	7d c8       	ld.w	r8,lr[0x70]
80008234:	80 00       	ld.sh	r0,r0[0x0]
80008236:	7d c4       	ld.w	r4,lr[0x70]
80008238:	80 00       	ld.sh	r0,r0[0x0]
8000823a:	f0 50 80 00 	cp.w	r0,-950272
8000823e:	7f 54       	ld.w	r4,pc[0x54]
80008240:	80 00       	ld.sh	r0,r0[0x0]
80008242:	f0 60 80 00 	mov	r0,-1015808
80008246:	8c 34       	ld.sh	r4,r6[0x6]
80008248:	80 00       	ld.sh	r0,r0[0x0]
8000824a:	f0 68 80 00 	mov	r8,-1015808
8000824e:	f0 70 80 00 	mov	r0,-950272
80008252:	6f c8       	ld.w	r8,r7[0x70]
80008254:	80 00       	ld.sh	r0,r0[0x0]
80008256:	87 fe       	st.w	r3[0x3c],lr
80008258:	00 00       	add	r0,r0
8000825a:	bd 48       	asr	r8,0x1c
8000825c:	80 00       	ld.sh	r0,r0[0x0]
8000825e:	72 cc       	ld.w	r12,r9[0x30]

80008260 <log_init>:
		
	return str;
}

void log_init(void)
{
80008260:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80008262:	30 2b       	mov	r11,2
80008264:	48 fc       	lddpc	r12,800082a0 <log_init+0x40>
80008266:	f0 1f 00 10 	mcall	800082a4 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000826a:	e0 6a 36 00 	mov	r10,13824
8000826e:	ea 1a 01 6e 	orh	r10,0x16e
80008272:	48 eb       	lddpc	r11,800082a8 <log_init+0x48>
80008274:	fe 7c 18 00 	mov	r12,-59392
80008278:	f0 1f 00 0d 	mcall	800082ac <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000827c:	30 4b       	mov	r11,4
8000827e:	33 2c       	mov	r12,50
80008280:	f0 1f 00 0c 	mcall	800082b0 <log_init+0x50>
80008284:	48 c8       	lddpc	r8,800082b4 <log_init+0x54>
80008286:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80008288:	30 09       	mov	r9,0
8000828a:	1a d9       	st.w	--sp,r9
8000828c:	1a d9       	st.w	--sp,r9
8000828e:	1a d9       	st.w	--sp,r9
80008290:	30 28       	mov	r8,2
80008292:	36 4a       	mov	r10,100
80008294:	48 9b       	lddpc	r11,800082b8 <log_init+0x58>
80008296:	48 ac       	lddpc	r12,800082bc <log_init+0x5c>
80008298:	f0 1f 00 0a 	mcall	800082c0 <log_init+0x60>
8000829c:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000829e:	d8 02       	popm	pc
800082a0:	80 00       	ld.sh	r0,r0[0x0]
800082a2:	f0 7c 80 00 	mov	r12,-950272
800082a6:	63 38       	ld.w	r8,r1[0x4c]
800082a8:	80 00       	ld.sh	r0,r0[0x0]
800082aa:	f0 34 80 00 	sub	r4,-950272
800082ae:	6b 2c       	ld.w	r12,r5[0x48]
800082b0:	80 00       	ld.sh	r0,r0[0x0]
800082b2:	74 74       	ld.w	r4,r10[0x1c]
800082b4:	00 00       	add	r0,r0
800082b6:	bd 48       	asr	r8,0x1c
800082b8:	80 00       	ld.sh	r0,r0[0x0]
800082ba:	f0 78 80 00 	mov	r8,-950272
800082be:	82 c4       	ld.uh	r4,r1[0x8]
800082c0:	80 00       	ld.sh	r0,r0[0x0]
800082c2:	7b 90       	ld.w	r0,sp[0x64]

800082c4 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800082c4:	eb cd 40 f8 	pushm	r3-r7,lr
800082c8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800082ca:	48 c7       	lddpc	r7,800082f8 <task_log+0x34>
800082cc:	30 05       	mov	r5,0
800082ce:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800082d0:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800082d4:	0a 99       	mov	r9,r5
800082d6:	08 9a       	mov	r10,r4
800082d8:	1a 9b       	mov	r11,sp
800082da:	6e 0c       	ld.w	r12,r7[0x0]
800082dc:	f0 1f 00 08 	mcall	800082fc <task_log+0x38>
800082e0:	58 1c       	cp.w	r12,1
800082e2:	cf 91       	brne	800082d4 <task_log+0x10>
		{
			if( NULL != str)
800082e4:	40 0b       	lddsp	r11,sp[0x0]
800082e6:	58 0b       	cp.w	r11,0
800082e8:	cf 60       	breq	800082d4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800082ea:	06 9c       	mov	r12,r3
800082ec:	f0 1f 00 05 	mcall	80008300 <task_log+0x3c>
				vPortFree(str);
800082f0:	40 0c       	lddsp	r12,sp[0x0]
800082f2:	f0 1f 00 05 	mcall	80008304 <task_log+0x40>
800082f6:	ce fb       	rjmp	800082d4 <task_log+0x10>
800082f8:	00 00       	add	r0,r0
800082fa:	bd 48       	asr	r8,0x1c
800082fc:	80 00       	ld.sh	r0,r0[0x0]
800082fe:	71 10       	ld.w	r0,r8[0x44]
80008300:	80 00       	ld.sh	r0,r0[0x0]
80008302:	6a dc       	ld.w	r12,r5[0x34]
80008304:	80 00       	ld.sh	r0,r0[0x0]
80008306:	6f a0       	ld.w	r0,r7[0x68]

80008308 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80008308:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000830a:	fe 78 10 00 	mov	r8,-61440
8000830e:	30 19       	mov	r9,1
80008310:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80008314:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80008318:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
8000831c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000831e:	f0 1f 00 0d 	mcall	80008350 <main+0x48>
		
	INTC_init_interrupts();
80008322:	f0 1f 00 0d 	mcall	80008354 <main+0x4c>
		
	log_init();
80008326:	f0 1f 00 0d 	mcall	80008358 <main+0x50>
	log("----start debug----");
8000832a:	48 dc       	lddpc	r12,8000835c <main+0x54>
8000832c:	f0 1f 00 0d 	mcall	80008360 <main+0x58>
	
	xg_flashc_init();
80008330:	f0 1f 00 0d 	mcall	80008364 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80008334:	f0 1f 00 0d 	mcall	80008368 <main+0x60>
		
	app_init();
80008338:	f0 1f 00 0d 	mcall	8000836c <main+0x64>
	
	xg_rtc_init();
8000833c:	f0 1f 00 0d 	mcall	80008370 <main+0x68>
		
	xcmp_init();
80008340:	f0 1f 00 0d 	mcall	80008374 <main+0x6c>

	local_start_timer();
80008344:	f0 1f 00 0d 	mcall	80008378 <main+0x70>
		
	vTaskStartScheduler();
80008348:	f0 1f 00 0d 	mcall	8000837c <main+0x74>
	return 0;
	
}
8000834c:	d8 0a       	popm	pc,r12=0
8000834e:	00 00       	add	r0,r0
80008350:	80 00       	ld.sh	r0,r0[0x0]
80008352:	5c 74       	castu.h	r4
80008354:	80 00       	ld.sh	r0,r0[0x0]
80008356:	64 3c       	ld.w	r12,r2[0xc]
80008358:	80 00       	ld.sh	r0,r0[0x0]
8000835a:	82 60       	ld.sh	r0,r1[0xc]
8000835c:	80 00       	ld.sh	r0,r0[0x0]
8000835e:	f0 8c 80 00 	brvs	7fe1835e <_estack+0x7fe0035e>
80008362:	7f 54       	ld.w	r4,pc[0x54]
80008364:	80 00       	ld.sh	r0,r0[0x0]
80008366:	5d 08       	ror	r8
80008368:	80 00       	ld.sh	r0,r0[0x0]
8000836a:	5b d4       	cp.w	r4,-3
8000836c:	80 00       	ld.sh	r0,r0[0x0]
8000836e:	27 28       	sub	r8,114
80008370:	80 00       	ld.sh	r0,r0[0x0]
80008372:	33 28       	mov	r8,50
80008374:	80 00       	ld.sh	r0,r0[0x0]
80008376:	49 fc       	lddpc	r12,800083f0 <_malloc_r+0x50>
80008378:	80 00       	ld.sh	r0,r0[0x0]
8000837a:	5c 48       	abs	r8
8000837c:	80 00       	ld.sh	r0,r0[0x0]
8000837e:	7d 78       	ld.w	r8,lr[0x5c]

80008380 <free>:
80008380:	d4 01       	pushm	lr
80008382:	e0 68 0a 54 	mov	r8,2644
80008386:	18 9b       	mov	r11,r12
80008388:	70 0c       	ld.w	r12,r8[0x0]
8000838a:	e0 a0 1e 73 	rcall	8000c070 <_free_r>
8000838e:	d8 02       	popm	pc

80008390 <malloc>:
80008390:	d4 01       	pushm	lr
80008392:	e0 68 0a 54 	mov	r8,2644
80008396:	18 9b       	mov	r11,r12
80008398:	70 0c       	ld.w	r12,r8[0x0]
8000839a:	c0 3c       	rcall	800083a0 <_malloc_r>
8000839c:	d8 02       	popm	pc
8000839e:	d7 03       	nop

800083a0 <_malloc_r>:
800083a0:	d4 31       	pushm	r0-r7,lr
800083a2:	f6 c8 ff f5 	sub	r8,r11,-11
800083a6:	18 95       	mov	r5,r12
800083a8:	10 97       	mov	r7,r8
800083aa:	e0 17 ff f8 	andl	r7,0xfff8
800083ae:	59 68       	cp.w	r8,22
800083b0:	f9 b7 08 10 	movls	r7,16
800083b4:	16 37       	cp.w	r7,r11
800083b6:	5f 38       	srlo	r8
800083b8:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800083bc:	c0 50       	breq	800083c6 <_malloc_r+0x26>
800083be:	30 c8       	mov	r8,12
800083c0:	99 38       	st.w	r12[0xc],r8
800083c2:	e0 8f 01 fa 	bral	800087b6 <_malloc_r+0x416>
800083c6:	fe b0 f5 a3 	rcall	80006f0c <__malloc_lock>
800083ca:	e0 47 01 f7 	cp.w	r7,503
800083ce:	e0 8b 00 1d 	brhi	80008408 <_malloc_r+0x68>
800083d2:	ee 03 16 03 	lsr	r3,r7,0x3
800083d6:	e0 68 05 54 	mov	r8,1364
800083da:	f0 03 00 38 	add	r8,r8,r3<<0x3
800083de:	70 36       	ld.w	r6,r8[0xc]
800083e0:	10 36       	cp.w	r6,r8
800083e2:	c0 61       	brne	800083ee <_malloc_r+0x4e>
800083e4:	ec c8 ff f8 	sub	r8,r6,-8
800083e8:	70 36       	ld.w	r6,r8[0xc]
800083ea:	10 36       	cp.w	r6,r8
800083ec:	c0 c0       	breq	80008404 <_malloc_r+0x64>
800083ee:	6c 18       	ld.w	r8,r6[0x4]
800083f0:	e0 18 ff fc 	andl	r8,0xfffc
800083f4:	6c 3a       	ld.w	r10,r6[0xc]
800083f6:	ec 08 00 09 	add	r9,r6,r8
800083fa:	0a 9c       	mov	r12,r5
800083fc:	6c 28       	ld.w	r8,r6[0x8]
800083fe:	95 28       	st.w	r10[0x8],r8
80008400:	91 3a       	st.w	r8[0xc],r10
80008402:	c4 78       	rjmp	80008490 <_malloc_r+0xf0>
80008404:	2f e3       	sub	r3,-2
80008406:	c4 d8       	rjmp	800084a0 <_malloc_r+0x100>
80008408:	ee 03 16 09 	lsr	r3,r7,0x9
8000840c:	c0 41       	brne	80008414 <_malloc_r+0x74>
8000840e:	ee 03 16 03 	lsr	r3,r7,0x3
80008412:	c2 68       	rjmp	8000845e <_malloc_r+0xbe>
80008414:	58 43       	cp.w	r3,4
80008416:	e0 8b 00 06 	brhi	80008422 <_malloc_r+0x82>
8000841a:	ee 03 16 06 	lsr	r3,r7,0x6
8000841e:	2c 83       	sub	r3,-56
80008420:	c1 f8       	rjmp	8000845e <_malloc_r+0xbe>
80008422:	59 43       	cp.w	r3,20
80008424:	e0 8b 00 04 	brhi	8000842c <_malloc_r+0x8c>
80008428:	2a 53       	sub	r3,-91
8000842a:	c1 a8       	rjmp	8000845e <_malloc_r+0xbe>
8000842c:	e0 43 00 54 	cp.w	r3,84
80008430:	e0 8b 00 06 	brhi	8000843c <_malloc_r+0x9c>
80008434:	ee 03 16 0c 	lsr	r3,r7,0xc
80008438:	29 23       	sub	r3,-110
8000843a:	c1 28       	rjmp	8000845e <_malloc_r+0xbe>
8000843c:	e0 43 01 54 	cp.w	r3,340
80008440:	e0 8b 00 06 	brhi	8000844c <_malloc_r+0xac>
80008444:	ee 03 16 0f 	lsr	r3,r7,0xf
80008448:	28 93       	sub	r3,-119
8000844a:	c0 a8       	rjmp	8000845e <_malloc_r+0xbe>
8000844c:	e0 43 05 54 	cp.w	r3,1364
80008450:	e0 88 00 04 	brls	80008458 <_malloc_r+0xb8>
80008454:	37 e3       	mov	r3,126
80008456:	c0 48       	rjmp	8000845e <_malloc_r+0xbe>
80008458:	ee 03 16 12 	lsr	r3,r7,0x12
8000845c:	28 43       	sub	r3,-124
8000845e:	e0 6a 05 54 	mov	r10,1364
80008462:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80008466:	74 36       	ld.w	r6,r10[0xc]
80008468:	c1 98       	rjmp	8000849a <_malloc_r+0xfa>
8000846a:	6c 19       	ld.w	r9,r6[0x4]
8000846c:	e0 19 ff fc 	andl	r9,0xfffc
80008470:	f2 07 01 0b 	sub	r11,r9,r7
80008474:	58 fb       	cp.w	r11,15
80008476:	e0 8a 00 04 	brle	8000847e <_malloc_r+0xde>
8000847a:	20 13       	sub	r3,1
8000847c:	c1 18       	rjmp	8000849e <_malloc_r+0xfe>
8000847e:	6c 38       	ld.w	r8,r6[0xc]
80008480:	58 0b       	cp.w	r11,0
80008482:	c0 b5       	brlt	80008498 <_malloc_r+0xf8>
80008484:	6c 2a       	ld.w	r10,r6[0x8]
80008486:	ec 09 00 09 	add	r9,r6,r9
8000848a:	0a 9c       	mov	r12,r5
8000848c:	91 2a       	st.w	r8[0x8],r10
8000848e:	95 38       	st.w	r10[0xc],r8
80008490:	72 18       	ld.w	r8,r9[0x4]
80008492:	a1 a8       	sbr	r8,0x0
80008494:	93 18       	st.w	r9[0x4],r8
80008496:	cb c8       	rjmp	8000860e <_malloc_r+0x26e>
80008498:	10 96       	mov	r6,r8
8000849a:	14 36       	cp.w	r6,r10
8000849c:	ce 71       	brne	8000846a <_malloc_r+0xca>
8000849e:	2f f3       	sub	r3,-1
800084a0:	e0 6a 05 54 	mov	r10,1364
800084a4:	f4 cc ff f8 	sub	r12,r10,-8
800084a8:	78 26       	ld.w	r6,r12[0x8]
800084aa:	18 36       	cp.w	r6,r12
800084ac:	c6 c0       	breq	80008584 <_malloc_r+0x1e4>
800084ae:	6c 19       	ld.w	r9,r6[0x4]
800084b0:	e0 19 ff fc 	andl	r9,0xfffc
800084b4:	f2 07 01 08 	sub	r8,r9,r7
800084b8:	58 f8       	cp.w	r8,15
800084ba:	e0 89 00 8f 	brgt	800085d8 <_malloc_r+0x238>
800084be:	99 3c       	st.w	r12[0xc],r12
800084c0:	99 2c       	st.w	r12[0x8],r12
800084c2:	58 08       	cp.w	r8,0
800084c4:	c0 55       	brlt	800084ce <_malloc_r+0x12e>
800084c6:	ec 09 00 09 	add	r9,r6,r9
800084ca:	0a 9c       	mov	r12,r5
800084cc:	ce 2b       	rjmp	80008490 <_malloc_r+0xf0>
800084ce:	e0 49 01 ff 	cp.w	r9,511
800084d2:	e0 8b 00 13 	brhi	800084f8 <_malloc_r+0x158>
800084d6:	a3 99       	lsr	r9,0x3
800084d8:	f4 09 00 38 	add	r8,r10,r9<<0x3
800084dc:	70 2b       	ld.w	r11,r8[0x8]
800084de:	8d 38       	st.w	r6[0xc],r8
800084e0:	8d 2b       	st.w	r6[0x8],r11
800084e2:	97 36       	st.w	r11[0xc],r6
800084e4:	91 26       	st.w	r8[0x8],r6
800084e6:	a3 49       	asr	r9,0x2
800084e8:	74 18       	ld.w	r8,r10[0x4]
800084ea:	30 1b       	mov	r11,1
800084ec:	f6 09 09 49 	lsl	r9,r11,r9
800084f0:	f1 e9 10 09 	or	r9,r8,r9
800084f4:	95 19       	st.w	r10[0x4],r9
800084f6:	c4 78       	rjmp	80008584 <_malloc_r+0x1e4>
800084f8:	f2 0a 16 09 	lsr	r10,r9,0x9
800084fc:	58 4a       	cp.w	r10,4
800084fe:	e0 8b 00 07 	brhi	8000850c <_malloc_r+0x16c>
80008502:	f2 0a 16 06 	lsr	r10,r9,0x6
80008506:	2c 8a       	sub	r10,-56
80008508:	c2 08       	rjmp	80008548 <_malloc_r+0x1a8>
8000850a:	d7 03       	nop
8000850c:	59 4a       	cp.w	r10,20
8000850e:	e0 8b 00 04 	brhi	80008516 <_malloc_r+0x176>
80008512:	2a 5a       	sub	r10,-91
80008514:	c1 a8       	rjmp	80008548 <_malloc_r+0x1a8>
80008516:	e0 4a 00 54 	cp.w	r10,84
8000851a:	e0 8b 00 06 	brhi	80008526 <_malloc_r+0x186>
8000851e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80008522:	29 2a       	sub	r10,-110
80008524:	c1 28       	rjmp	80008548 <_malloc_r+0x1a8>
80008526:	e0 4a 01 54 	cp.w	r10,340
8000852a:	e0 8b 00 06 	brhi	80008536 <_malloc_r+0x196>
8000852e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80008532:	28 9a       	sub	r10,-119
80008534:	c0 a8       	rjmp	80008548 <_malloc_r+0x1a8>
80008536:	e0 4a 05 54 	cp.w	r10,1364
8000853a:	e0 88 00 04 	brls	80008542 <_malloc_r+0x1a2>
8000853e:	37 ea       	mov	r10,126
80008540:	c0 48       	rjmp	80008548 <_malloc_r+0x1a8>
80008542:	f2 0a 16 12 	lsr	r10,r9,0x12
80008546:	28 4a       	sub	r10,-124
80008548:	e0 6b 05 54 	mov	r11,1364
8000854c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80008550:	68 28       	ld.w	r8,r4[0x8]
80008552:	08 38       	cp.w	r8,r4
80008554:	c0 e1       	brne	80008570 <_malloc_r+0x1d0>
80008556:	76 19       	ld.w	r9,r11[0x4]
80008558:	a3 4a       	asr	r10,0x2
8000855a:	30 1e       	mov	lr,1
8000855c:	fc 0a 09 4a 	lsl	r10,lr,r10
80008560:	f3 ea 10 0a 	or	r10,r9,r10
80008564:	10 99       	mov	r9,r8
80008566:	97 1a       	st.w	r11[0x4],r10
80008568:	c0 a8       	rjmp	8000857c <_malloc_r+0x1dc>
8000856a:	70 28       	ld.w	r8,r8[0x8]
8000856c:	08 38       	cp.w	r8,r4
8000856e:	c0 60       	breq	8000857a <_malloc_r+0x1da>
80008570:	70 1a       	ld.w	r10,r8[0x4]
80008572:	e0 1a ff fc 	andl	r10,0xfffc
80008576:	14 39       	cp.w	r9,r10
80008578:	cf 93       	brcs	8000856a <_malloc_r+0x1ca>
8000857a:	70 39       	ld.w	r9,r8[0xc]
8000857c:	8d 39       	st.w	r6[0xc],r9
8000857e:	8d 28       	st.w	r6[0x8],r8
80008580:	91 36       	st.w	r8[0xc],r6
80008582:	93 26       	st.w	r9[0x8],r6
80008584:	e6 08 14 02 	asr	r8,r3,0x2
80008588:	30 1b       	mov	r11,1
8000858a:	e0 64 05 54 	mov	r4,1364
8000858e:	f6 08 09 4b 	lsl	r11,r11,r8
80008592:	68 18       	ld.w	r8,r4[0x4]
80008594:	10 3b       	cp.w	r11,r8
80008596:	e0 8b 00 6b 	brhi	8000866c <_malloc_r+0x2cc>
8000859a:	f7 e8 00 09 	and	r9,r11,r8
8000859e:	c0 b1       	brne	800085b4 <_malloc_r+0x214>
800085a0:	e0 13 ff fc 	andl	r3,0xfffc
800085a4:	a1 7b       	lsl	r11,0x1
800085a6:	2f c3       	sub	r3,-4
800085a8:	c0 38       	rjmp	800085ae <_malloc_r+0x20e>
800085aa:	2f c3       	sub	r3,-4
800085ac:	a1 7b       	lsl	r11,0x1
800085ae:	f7 e8 00 09 	and	r9,r11,r8
800085b2:	cf c0       	breq	800085aa <_malloc_r+0x20a>
800085b4:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800085b8:	06 92       	mov	r2,r3
800085ba:	1c 91       	mov	r1,lr
800085bc:	62 36       	ld.w	r6,r1[0xc]
800085be:	c2 e8       	rjmp	8000861a <_malloc_r+0x27a>
800085c0:	6c 1a       	ld.w	r10,r6[0x4]
800085c2:	e0 1a ff fc 	andl	r10,0xfffc
800085c6:	f4 07 01 08 	sub	r8,r10,r7
800085ca:	58 f8       	cp.w	r8,15
800085cc:	e0 8a 00 15 	brle	800085f6 <_malloc_r+0x256>
800085d0:	6c 3a       	ld.w	r10,r6[0xc]
800085d2:	6c 29       	ld.w	r9,r6[0x8]
800085d4:	95 29       	st.w	r10[0x8],r9
800085d6:	93 3a       	st.w	r9[0xc],r10
800085d8:	0e 99       	mov	r9,r7
800085da:	ec 07 00 07 	add	r7,r6,r7
800085de:	a1 a9       	sbr	r9,0x0
800085e0:	99 37       	st.w	r12[0xc],r7
800085e2:	99 27       	st.w	r12[0x8],r7
800085e4:	8d 19       	st.w	r6[0x4],r9
800085e6:	ee 08 09 08 	st.w	r7[r8],r8
800085ea:	8f 2c       	st.w	r7[0x8],r12
800085ec:	8f 3c       	st.w	r7[0xc],r12
800085ee:	a1 a8       	sbr	r8,0x0
800085f0:	0a 9c       	mov	r12,r5
800085f2:	8f 18       	st.w	r7[0x4],r8
800085f4:	c0 d8       	rjmp	8000860e <_malloc_r+0x26e>
800085f6:	6c 39       	ld.w	r9,r6[0xc]
800085f8:	58 08       	cp.w	r8,0
800085fa:	c0 f5       	brlt	80008618 <_malloc_r+0x278>
800085fc:	ec 0a 00 0a 	add	r10,r6,r10
80008600:	74 18       	ld.w	r8,r10[0x4]
80008602:	a1 a8       	sbr	r8,0x0
80008604:	0a 9c       	mov	r12,r5
80008606:	95 18       	st.w	r10[0x4],r8
80008608:	6c 28       	ld.w	r8,r6[0x8]
8000860a:	93 28       	st.w	r9[0x8],r8
8000860c:	91 39       	st.w	r8[0xc],r9
8000860e:	fe b0 f4 85 	rcall	80006f18 <__malloc_unlock>
80008612:	ec cc ff f8 	sub	r12,r6,-8
80008616:	d8 32       	popm	r0-r7,pc
80008618:	12 96       	mov	r6,r9
8000861a:	02 36       	cp.w	r6,r1
8000861c:	cd 21       	brne	800085c0 <_malloc_r+0x220>
8000861e:	2f f2       	sub	r2,-1
80008620:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80008624:	c0 30       	breq	8000862a <_malloc_r+0x28a>
80008626:	2f 81       	sub	r1,-8
80008628:	cc ab       	rjmp	800085bc <_malloc_r+0x21c>
8000862a:	1c 98       	mov	r8,lr
8000862c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80008630:	c0 81       	brne	80008640 <_malloc_r+0x2a0>
80008632:	68 19       	ld.w	r9,r4[0x4]
80008634:	f6 08 11 ff 	rsub	r8,r11,-1
80008638:	f3 e8 00 08 	and	r8,r9,r8
8000863c:	89 18       	st.w	r4[0x4],r8
8000863e:	c0 78       	rjmp	8000864c <_malloc_r+0x2ac>
80008640:	f0 c9 00 08 	sub	r9,r8,8
80008644:	20 13       	sub	r3,1
80008646:	70 08       	ld.w	r8,r8[0x0]
80008648:	12 38       	cp.w	r8,r9
8000864a:	cf 10       	breq	8000862c <_malloc_r+0x28c>
8000864c:	a1 7b       	lsl	r11,0x1
8000864e:	68 18       	ld.w	r8,r4[0x4]
80008650:	10 3b       	cp.w	r11,r8
80008652:	e0 8b 00 0d 	brhi	8000866c <_malloc_r+0x2cc>
80008656:	58 0b       	cp.w	r11,0
80008658:	c0 a0       	breq	8000866c <_malloc_r+0x2cc>
8000865a:	04 93       	mov	r3,r2
8000865c:	c0 38       	rjmp	80008662 <_malloc_r+0x2c2>
8000865e:	2f c3       	sub	r3,-4
80008660:	a1 7b       	lsl	r11,0x1
80008662:	f7 e8 00 09 	and	r9,r11,r8
80008666:	ca 71       	brne	800085b4 <_malloc_r+0x214>
80008668:	cf bb       	rjmp	8000865e <_malloc_r+0x2be>
8000866a:	d7 03       	nop
8000866c:	68 23       	ld.w	r3,r4[0x8]
8000866e:	66 12       	ld.w	r2,r3[0x4]
80008670:	e0 12 ff fc 	andl	r2,0xfffc
80008674:	0e 32       	cp.w	r2,r7
80008676:	5f 39       	srlo	r9
80008678:	e4 07 01 08 	sub	r8,r2,r7
8000867c:	58 f8       	cp.w	r8,15
8000867e:	5f aa       	srle	r10
80008680:	f5 e9 10 09 	or	r9,r10,r9
80008684:	e0 80 00 9a 	breq	800087b8 <_malloc_r+0x418>
80008688:	e0 68 0d f0 	mov	r8,3568
8000868c:	70 01       	ld.w	r1,r8[0x0]
8000868e:	e0 68 09 60 	mov	r8,2400
80008692:	2f 01       	sub	r1,-16
80008694:	70 08       	ld.w	r8,r8[0x0]
80008696:	0e 01       	add	r1,r7
80008698:	5b f8       	cp.w	r8,-1
8000869a:	c0 40       	breq	800086a2 <_malloc_r+0x302>
8000869c:	28 11       	sub	r1,-127
8000869e:	e0 11 ff 80 	andl	r1,0xff80
800086a2:	02 9b       	mov	r11,r1
800086a4:	0a 9c       	mov	r12,r5
800086a6:	e0 a0 02 b7 	rcall	80008c14 <_sbrk_r>
800086aa:	18 96       	mov	r6,r12
800086ac:	5b fc       	cp.w	r12,-1
800086ae:	c7 50       	breq	80008798 <_malloc_r+0x3f8>
800086b0:	e6 02 00 08 	add	r8,r3,r2
800086b4:	10 3c       	cp.w	r12,r8
800086b6:	c0 32       	brcc	800086bc <_malloc_r+0x31c>
800086b8:	08 33       	cp.w	r3,r4
800086ba:	c6 f1       	brne	80008798 <_malloc_r+0x3f8>
800086bc:	e0 6a 0d f4 	mov	r10,3572
800086c0:	74 09       	ld.w	r9,r10[0x0]
800086c2:	e2 09 00 09 	add	r9,r1,r9
800086c6:	95 09       	st.w	r10[0x0],r9
800086c8:	10 36       	cp.w	r6,r8
800086ca:	c0 a1       	brne	800086de <_malloc_r+0x33e>
800086cc:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800086d0:	c0 71       	brne	800086de <_malloc_r+0x33e>
800086d2:	e2 02 00 02 	add	r2,r1,r2
800086d6:	68 28       	ld.w	r8,r4[0x8]
800086d8:	a1 a2       	sbr	r2,0x0
800086da:	91 12       	st.w	r8[0x4],r2
800086dc:	c4 f8       	rjmp	8000877a <_malloc_r+0x3da>
800086de:	e0 6a 09 60 	mov	r10,2400
800086e2:	74 0b       	ld.w	r11,r10[0x0]
800086e4:	5b fb       	cp.w	r11,-1
800086e6:	c0 31       	brne	800086ec <_malloc_r+0x34c>
800086e8:	95 06       	st.w	r10[0x0],r6
800086ea:	c0 78       	rjmp	800086f8 <_malloc_r+0x358>
800086ec:	ec 09 00 09 	add	r9,r6,r9
800086f0:	e0 6a 0d f4 	mov	r10,3572
800086f4:	10 19       	sub	r9,r8
800086f6:	95 09       	st.w	r10[0x0],r9
800086f8:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800086fc:	f0 09 11 08 	rsub	r9,r8,8
80008700:	58 08       	cp.w	r8,0
80008702:	f2 08 17 10 	movne	r8,r9
80008706:	ed d8 e1 06 	addne	r6,r6,r8
8000870a:	28 08       	sub	r8,-128
8000870c:	ec 01 00 01 	add	r1,r6,r1
80008710:	0a 9c       	mov	r12,r5
80008712:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80008716:	f0 01 01 01 	sub	r1,r8,r1
8000871a:	02 9b       	mov	r11,r1
8000871c:	e0 a0 02 7c 	rcall	80008c14 <_sbrk_r>
80008720:	e0 68 0d f4 	mov	r8,3572
80008724:	5b fc       	cp.w	r12,-1
80008726:	ec 0c 17 00 	moveq	r12,r6
8000872a:	f9 b1 00 00 	moveq	r1,0
8000872e:	70 09       	ld.w	r9,r8[0x0]
80008730:	0c 1c       	sub	r12,r6
80008732:	89 26       	st.w	r4[0x8],r6
80008734:	02 0c       	add	r12,r1
80008736:	12 01       	add	r1,r9
80008738:	a1 ac       	sbr	r12,0x0
8000873a:	91 01       	st.w	r8[0x0],r1
8000873c:	8d 1c       	st.w	r6[0x4],r12
8000873e:	08 33       	cp.w	r3,r4
80008740:	c1 d0       	breq	8000877a <_malloc_r+0x3da>
80008742:	58 f2       	cp.w	r2,15
80008744:	e0 8b 00 05 	brhi	8000874e <_malloc_r+0x3ae>
80008748:	30 18       	mov	r8,1
8000874a:	8d 18       	st.w	r6[0x4],r8
8000874c:	c2 68       	rjmp	80008798 <_malloc_r+0x3f8>
8000874e:	30 59       	mov	r9,5
80008750:	20 c2       	sub	r2,12
80008752:	e0 12 ff f8 	andl	r2,0xfff8
80008756:	e6 02 00 08 	add	r8,r3,r2
8000875a:	91 29       	st.w	r8[0x8],r9
8000875c:	91 19       	st.w	r8[0x4],r9
8000875e:	66 18       	ld.w	r8,r3[0x4]
80008760:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008764:	e5 e8 10 08 	or	r8,r2,r8
80008768:	87 18       	st.w	r3[0x4],r8
8000876a:	58 f2       	cp.w	r2,15
8000876c:	e0 88 00 07 	brls	8000877a <_malloc_r+0x3da>
80008770:	e6 cb ff f8 	sub	r11,r3,-8
80008774:	0a 9c       	mov	r12,r5
80008776:	e0 a0 1c 7d 	rcall	8000c070 <_free_r>
8000877a:	e0 69 0d ec 	mov	r9,3564
8000877e:	72 0a       	ld.w	r10,r9[0x0]
80008780:	e0 68 0d f4 	mov	r8,3572
80008784:	70 08       	ld.w	r8,r8[0x0]
80008786:	14 38       	cp.w	r8,r10
80008788:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000878c:	e0 69 0d e8 	mov	r9,3560
80008790:	72 0a       	ld.w	r10,r9[0x0]
80008792:	14 38       	cp.w	r8,r10
80008794:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008798:	68 28       	ld.w	r8,r4[0x8]
8000879a:	70 18       	ld.w	r8,r8[0x4]
8000879c:	e0 18 ff fc 	andl	r8,0xfffc
800087a0:	0e 38       	cp.w	r8,r7
800087a2:	5f 39       	srlo	r9
800087a4:	0e 18       	sub	r8,r7
800087a6:	58 f8       	cp.w	r8,15
800087a8:	5f aa       	srle	r10
800087aa:	f5 e9 10 09 	or	r9,r10,r9
800087ae:	c0 50       	breq	800087b8 <_malloc_r+0x418>
800087b0:	0a 9c       	mov	r12,r5
800087b2:	fe b0 f3 b3 	rcall	80006f18 <__malloc_unlock>
800087b6:	d8 3a       	popm	r0-r7,pc,r12=0
800087b8:	68 26       	ld.w	r6,r4[0x8]
800087ba:	a1 a8       	sbr	r8,0x0
800087bc:	0e 99       	mov	r9,r7
800087be:	a1 a9       	sbr	r9,0x0
800087c0:	8d 19       	st.w	r6[0x4],r9
800087c2:	ec 07 00 07 	add	r7,r6,r7
800087c6:	0a 9c       	mov	r12,r5
800087c8:	89 27       	st.w	r4[0x8],r7
800087ca:	8f 18       	st.w	r7[0x4],r8
800087cc:	fe b0 f3 a6 	rcall	80006f18 <__malloc_unlock>
800087d0:	ec cc ff f8 	sub	r12,r6,-8
800087d4:	d8 32       	popm	r0-r7,pc
800087d6:	d7 03       	nop

800087d8 <memcmp>:
800087d8:	d4 01       	pushm	lr
800087da:	30 08       	mov	r8,0
800087dc:	c0 d8       	rjmp	800087f6 <memcmp+0x1e>
800087de:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800087e2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800087e6:	20 1a       	sub	r10,1
800087e8:	2f f8       	sub	r8,-1
800087ea:	f2 0e 18 00 	cp.b	lr,r9
800087ee:	c0 40       	breq	800087f6 <memcmp+0x1e>
800087f0:	fc 09 01 0c 	sub	r12,lr,r9
800087f4:	d8 02       	popm	pc
800087f6:	58 0a       	cp.w	r10,0
800087f8:	cf 31       	brne	800087de <memcmp+0x6>
800087fa:	14 9c       	mov	r12,r10
800087fc:	d8 02       	popm	pc

800087fe <memcpy>:
800087fe:	58 8a       	cp.w	r10,8
80008800:	c2 f5       	brlt	8000885e <memcpy+0x60>
80008802:	f9 eb 10 09 	or	r9,r12,r11
80008806:	e2 19 00 03 	andl	r9,0x3,COH
8000880a:	e0 81 00 97 	brne	80008938 <memcpy+0x13a>
8000880e:	e0 4a 00 20 	cp.w	r10,32
80008812:	c3 b4       	brge	80008888 <memcpy+0x8a>
80008814:	f4 08 14 02 	asr	r8,r10,0x2
80008818:	f0 09 11 08 	rsub	r9,r8,8
8000881c:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80008820:	76 69       	ld.w	r9,r11[0x18]
80008822:	99 69       	st.w	r12[0x18],r9
80008824:	76 59       	ld.w	r9,r11[0x14]
80008826:	99 59       	st.w	r12[0x14],r9
80008828:	76 49       	ld.w	r9,r11[0x10]
8000882a:	99 49       	st.w	r12[0x10],r9
8000882c:	76 39       	ld.w	r9,r11[0xc]
8000882e:	99 39       	st.w	r12[0xc],r9
80008830:	76 29       	ld.w	r9,r11[0x8]
80008832:	99 29       	st.w	r12[0x8],r9
80008834:	76 19       	ld.w	r9,r11[0x4]
80008836:	99 19       	st.w	r12[0x4],r9
80008838:	76 09       	ld.w	r9,r11[0x0]
8000883a:	99 09       	st.w	r12[0x0],r9
8000883c:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80008840:	f8 08 00 28 	add	r8,r12,r8<<0x2
80008844:	e0 1a 00 03 	andl	r10,0x3
80008848:	f4 0a 11 04 	rsub	r10,r10,4
8000884c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008850:	17 a9       	ld.ub	r9,r11[0x2]
80008852:	b0 a9       	st.b	r8[0x2],r9
80008854:	17 99       	ld.ub	r9,r11[0x1]
80008856:	b0 99       	st.b	r8[0x1],r9
80008858:	17 89       	ld.ub	r9,r11[0x0]
8000885a:	b0 89       	st.b	r8[0x0],r9
8000885c:	5e fc       	retal	r12
8000885e:	f4 0a 11 09 	rsub	r10,r10,9
80008862:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008866:	17 f9       	ld.ub	r9,r11[0x7]
80008868:	b8 f9       	st.b	r12[0x7],r9
8000886a:	17 e9       	ld.ub	r9,r11[0x6]
8000886c:	b8 e9       	st.b	r12[0x6],r9
8000886e:	17 d9       	ld.ub	r9,r11[0x5]
80008870:	b8 d9       	st.b	r12[0x5],r9
80008872:	17 c9       	ld.ub	r9,r11[0x4]
80008874:	b8 c9       	st.b	r12[0x4],r9
80008876:	17 b9       	ld.ub	r9,r11[0x3]
80008878:	b8 b9       	st.b	r12[0x3],r9
8000887a:	17 a9       	ld.ub	r9,r11[0x2]
8000887c:	b8 a9       	st.b	r12[0x2],r9
8000887e:	17 99       	ld.ub	r9,r11[0x1]
80008880:	b8 99       	st.b	r12[0x1],r9
80008882:	17 89       	ld.ub	r9,r11[0x0]
80008884:	b8 89       	st.b	r12[0x0],r9
80008886:	5e fc       	retal	r12
80008888:	eb cd 40 c0 	pushm	r6-r7,lr
8000888c:	18 99       	mov	r9,r12
8000888e:	22 0a       	sub	r10,32
80008890:	b7 07       	ld.d	r6,r11++
80008892:	b3 26       	st.d	r9++,r6
80008894:	b7 07       	ld.d	r6,r11++
80008896:	b3 26       	st.d	r9++,r6
80008898:	b7 07       	ld.d	r6,r11++
8000889a:	b3 26       	st.d	r9++,r6
8000889c:	b7 07       	ld.d	r6,r11++
8000889e:	b3 26       	st.d	r9++,r6
800088a0:	22 0a       	sub	r10,32
800088a2:	cf 74       	brge	80008890 <memcpy+0x92>
800088a4:	2f 0a       	sub	r10,-16
800088a6:	c0 65       	brlt	800088b2 <memcpy+0xb4>
800088a8:	b7 07       	ld.d	r6,r11++
800088aa:	b3 26       	st.d	r9++,r6
800088ac:	b7 07       	ld.d	r6,r11++
800088ae:	b3 26       	st.d	r9++,r6
800088b0:	21 0a       	sub	r10,16
800088b2:	5c 3a       	neg	r10
800088b4:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800088b8:	d7 03       	nop
800088ba:	d7 03       	nop
800088bc:	f7 36 00 0e 	ld.ub	r6,r11[14]
800088c0:	f3 66 00 0e 	st.b	r9[14],r6
800088c4:	f7 36 00 0d 	ld.ub	r6,r11[13]
800088c8:	f3 66 00 0d 	st.b	r9[13],r6
800088cc:	f7 36 00 0c 	ld.ub	r6,r11[12]
800088d0:	f3 66 00 0c 	st.b	r9[12],r6
800088d4:	f7 36 00 0b 	ld.ub	r6,r11[11]
800088d8:	f3 66 00 0b 	st.b	r9[11],r6
800088dc:	f7 36 00 0a 	ld.ub	r6,r11[10]
800088e0:	f3 66 00 0a 	st.b	r9[10],r6
800088e4:	f7 36 00 09 	ld.ub	r6,r11[9]
800088e8:	f3 66 00 09 	st.b	r9[9],r6
800088ec:	f7 36 00 08 	ld.ub	r6,r11[8]
800088f0:	f3 66 00 08 	st.b	r9[8],r6
800088f4:	f7 36 00 07 	ld.ub	r6,r11[7]
800088f8:	f3 66 00 07 	st.b	r9[7],r6
800088fc:	f7 36 00 06 	ld.ub	r6,r11[6]
80008900:	f3 66 00 06 	st.b	r9[6],r6
80008904:	f7 36 00 05 	ld.ub	r6,r11[5]
80008908:	f3 66 00 05 	st.b	r9[5],r6
8000890c:	f7 36 00 04 	ld.ub	r6,r11[4]
80008910:	f3 66 00 04 	st.b	r9[4],r6
80008914:	f7 36 00 03 	ld.ub	r6,r11[3]
80008918:	f3 66 00 03 	st.b	r9[3],r6
8000891c:	f7 36 00 02 	ld.ub	r6,r11[2]
80008920:	f3 66 00 02 	st.b	r9[2],r6
80008924:	f7 36 00 01 	ld.ub	r6,r11[1]
80008928:	f3 66 00 01 	st.b	r9[1],r6
8000892c:	f7 36 00 00 	ld.ub	r6,r11[0]
80008930:	f3 66 00 00 	st.b	r9[0],r6
80008934:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008938:	20 1a       	sub	r10,1
8000893a:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000893e:	f8 0a 0b 09 	st.b	r12[r10],r9
80008942:	cf b1       	brne	80008938 <memcpy+0x13a>
80008944:	5e fc       	retal	r12

80008946 <memset>:
80008946:	18 98       	mov	r8,r12
80008948:	c0 38       	rjmp	8000894e <memset+0x8>
8000894a:	10 cb       	st.b	r8++,r11
8000894c:	20 1a       	sub	r10,1
8000894e:	58 0a       	cp.w	r10,0
80008950:	cf d1       	brne	8000894a <memset+0x4>
80008952:	5e fc       	retal	r12

80008954 <_realloc_r>:
80008954:	d4 31       	pushm	r0-r7,lr
80008956:	20 1d       	sub	sp,4
80008958:	16 94       	mov	r4,r11
8000895a:	18 92       	mov	r2,r12
8000895c:	14 9b       	mov	r11,r10
8000895e:	58 04       	cp.w	r4,0
80008960:	c0 51       	brne	8000896a <_realloc_r+0x16>
80008962:	fe b0 fd 1f 	rcall	800083a0 <_malloc_r>
80008966:	18 95       	mov	r5,r12
80008968:	c5 39       	rjmp	80008c0e <_realloc_r+0x2ba>
8000896a:	50 0a       	stdsp	sp[0x0],r10
8000896c:	fe b0 f2 d0 	rcall	80006f0c <__malloc_lock>
80008970:	40 0b       	lddsp	r11,sp[0x0]
80008972:	f6 c8 ff f5 	sub	r8,r11,-11
80008976:	e8 c1 00 08 	sub	r1,r4,8
8000897a:	10 96       	mov	r6,r8
8000897c:	62 1c       	ld.w	r12,r1[0x4]
8000897e:	e0 16 ff f8 	andl	r6,0xfff8
80008982:	59 68       	cp.w	r8,22
80008984:	f9 b6 08 10 	movls	r6,16
80008988:	16 36       	cp.w	r6,r11
8000898a:	5f 38       	srlo	r8
8000898c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80008990:	c0 50       	breq	8000899a <_realloc_r+0x46>
80008992:	30 c8       	mov	r8,12
80008994:	30 05       	mov	r5,0
80008996:	85 38       	st.w	r2[0xc],r8
80008998:	c3 b9       	rjmp	80008c0e <_realloc_r+0x2ba>
8000899a:	18 90       	mov	r0,r12
8000899c:	e0 10 ff fc 	andl	r0,0xfffc
800089a0:	0c 30       	cp.w	r0,r6
800089a2:	e0 84 01 0b 	brge	80008bb8 <_realloc_r+0x264>
800089a6:	e0 68 05 54 	mov	r8,1364
800089aa:	e2 00 00 09 	add	r9,r1,r0
800089ae:	70 25       	ld.w	r5,r8[0x8]
800089b0:	0a 39       	cp.w	r9,r5
800089b2:	c0 90       	breq	800089c4 <_realloc_r+0x70>
800089b4:	72 1a       	ld.w	r10,r9[0x4]
800089b6:	a1 ca       	cbr	r10,0x0
800089b8:	f2 0a 00 0a 	add	r10,r9,r10
800089bc:	74 1a       	ld.w	r10,r10[0x4]
800089be:	ed ba 00 00 	bld	r10,0x0
800089c2:	c2 20       	breq	80008a06 <_realloc_r+0xb2>
800089c4:	72 1a       	ld.w	r10,r9[0x4]
800089c6:	e0 1a ff fc 	andl	r10,0xfffc
800089ca:	f4 00 00 03 	add	r3,r10,r0
800089ce:	0a 39       	cp.w	r9,r5
800089d0:	c1 31       	brne	800089f6 <_realloc_r+0xa2>
800089d2:	ec c7 ff f0 	sub	r7,r6,-16
800089d6:	0e 33       	cp.w	r3,r7
800089d8:	c1 95       	brlt	80008a0a <_realloc_r+0xb6>
800089da:	e2 06 00 09 	add	r9,r1,r6
800089de:	0c 13       	sub	r3,r6
800089e0:	a1 a3       	sbr	r3,0x0
800089e2:	93 13       	st.w	r9[0x4],r3
800089e4:	91 29       	st.w	r8[0x8],r9
800089e6:	04 9c       	mov	r12,r2
800089e8:	62 18       	ld.w	r8,r1[0x4]
800089ea:	08 95       	mov	r5,r4
800089ec:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800089f0:	10 46       	or	r6,r8
800089f2:	83 16       	st.w	r1[0x4],r6
800089f4:	c0 b9       	rjmp	80008c0a <_realloc_r+0x2b6>
800089f6:	0c 33       	cp.w	r3,r6
800089f8:	c0 95       	brlt	80008a0a <_realloc_r+0xb6>
800089fa:	72 28       	ld.w	r8,r9[0x8]
800089fc:	02 97       	mov	r7,r1
800089fe:	72 39       	ld.w	r9,r9[0xc]
80008a00:	93 28       	st.w	r9[0x8],r8
80008a02:	91 39       	st.w	r8[0xc],r9
80008a04:	cd c8       	rjmp	80008bbc <_realloc_r+0x268>
80008a06:	30 0a       	mov	r10,0
80008a08:	14 99       	mov	r9,r10
80008a0a:	ed bc 00 00 	bld	r12,0x0
80008a0e:	e0 80 00 95 	breq	80008b38 <_realloc_r+0x1e4>
80008a12:	62 07       	ld.w	r7,r1[0x0]
80008a14:	e2 07 01 07 	sub	r7,r1,r7
80008a18:	6e 1c       	ld.w	r12,r7[0x4]
80008a1a:	e0 1c ff fc 	andl	r12,0xfffc
80008a1e:	58 09       	cp.w	r9,0
80008a20:	c5 60       	breq	80008acc <_realloc_r+0x178>
80008a22:	f8 00 00 03 	add	r3,r12,r0
80008a26:	0a 39       	cp.w	r9,r5
80008a28:	c4 81       	brne	80008ab8 <_realloc_r+0x164>
80008a2a:	14 03       	add	r3,r10
80008a2c:	ec c9 ff f0 	sub	r9,r6,-16
80008a30:	12 33       	cp.w	r3,r9
80008a32:	c4 d5       	brlt	80008acc <_realloc_r+0x178>
80008a34:	6e 3a       	ld.w	r10,r7[0xc]
80008a36:	6e 29       	ld.w	r9,r7[0x8]
80008a38:	95 29       	st.w	r10[0x8],r9
80008a3a:	93 3a       	st.w	r9[0xc],r10
80008a3c:	ee c5 ff f8 	sub	r5,r7,-8
80008a40:	e0 ca 00 04 	sub	r10,r0,4
80008a44:	e0 4a 00 24 	cp.w	r10,36
80008a48:	e0 8b 00 25 	brhi	80008a92 <_realloc_r+0x13e>
80008a4c:	0a 99       	mov	r9,r5
80008a4e:	59 3a       	cp.w	r10,19
80008a50:	e0 88 00 1a 	brls	80008a84 <_realloc_r+0x130>
80008a54:	09 09       	ld.w	r9,r4++
80008a56:	8b 09       	st.w	r5[0x0],r9
80008a58:	09 09       	ld.w	r9,r4++
80008a5a:	8f 39       	st.w	r7[0xc],r9
80008a5c:	ee c9 ff f0 	sub	r9,r7,-16
80008a60:	59 ba       	cp.w	r10,27
80008a62:	e0 88 00 11 	brls	80008a84 <_realloc_r+0x130>
80008a66:	09 0b       	ld.w	r11,r4++
80008a68:	93 0b       	st.w	r9[0x0],r11
80008a6a:	09 09       	ld.w	r9,r4++
80008a6c:	8f 59       	st.w	r7[0x14],r9
80008a6e:	ee c9 ff e8 	sub	r9,r7,-24
80008a72:	e0 4a 00 24 	cp.w	r10,36
80008a76:	c0 71       	brne	80008a84 <_realloc_r+0x130>
80008a78:	09 0a       	ld.w	r10,r4++
80008a7a:	93 0a       	st.w	r9[0x0],r10
80008a7c:	ee c9 ff e0 	sub	r9,r7,-32
80008a80:	09 0a       	ld.w	r10,r4++
80008a82:	8f 7a       	st.w	r7[0x1c],r10
80008a84:	09 0a       	ld.w	r10,r4++
80008a86:	12 aa       	st.w	r9++,r10
80008a88:	68 0a       	ld.w	r10,r4[0x0]
80008a8a:	93 0a       	st.w	r9[0x0],r10
80008a8c:	68 1a       	ld.w	r10,r4[0x4]
80008a8e:	93 1a       	st.w	r9[0x4],r10
80008a90:	c0 78       	rjmp	80008a9e <_realloc_r+0x14a>
80008a92:	50 08       	stdsp	sp[0x0],r8
80008a94:	08 9b       	mov	r11,r4
80008a96:	0a 9c       	mov	r12,r5
80008a98:	e0 a0 1d 8f 	rcall	8000c5b6 <memmove>
80008a9c:	40 08       	lddsp	r8,sp[0x0]
80008a9e:	ee 06 00 09 	add	r9,r7,r6
80008aa2:	0c 13       	sub	r3,r6
80008aa4:	a1 a3       	sbr	r3,0x0
80008aa6:	93 13       	st.w	r9[0x4],r3
80008aa8:	91 29       	st.w	r8[0x8],r9
80008aaa:	04 9c       	mov	r12,r2
80008aac:	6e 18       	ld.w	r8,r7[0x4]
80008aae:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008ab2:	10 46       	or	r6,r8
80008ab4:	8f 16       	st.w	r7[0x4],r6
80008ab6:	ca a8       	rjmp	80008c0a <_realloc_r+0x2b6>
80008ab8:	14 03       	add	r3,r10
80008aba:	0c 33       	cp.w	r3,r6
80008abc:	c0 85       	brlt	80008acc <_realloc_r+0x178>
80008abe:	72 28       	ld.w	r8,r9[0x8]
80008ac0:	72 39       	ld.w	r9,r9[0xc]
80008ac2:	93 28       	st.w	r9[0x8],r8
80008ac4:	91 39       	st.w	r8[0xc],r9
80008ac6:	6e 28       	ld.w	r8,r7[0x8]
80008ac8:	6e 39       	ld.w	r9,r7[0xc]
80008aca:	c0 78       	rjmp	80008ad8 <_realloc_r+0x184>
80008acc:	f8 00 00 03 	add	r3,r12,r0
80008ad0:	0c 33       	cp.w	r3,r6
80008ad2:	c3 35       	brlt	80008b38 <_realloc_r+0x1e4>
80008ad4:	6e 39       	ld.w	r9,r7[0xc]
80008ad6:	6e 28       	ld.w	r8,r7[0x8]
80008ad8:	93 28       	st.w	r9[0x8],r8
80008ada:	91 39       	st.w	r8[0xc],r9
80008adc:	e0 ca 00 04 	sub	r10,r0,4
80008ae0:	ee cc ff f8 	sub	r12,r7,-8
80008ae4:	e0 4a 00 24 	cp.w	r10,36
80008ae8:	e0 8b 00 24 	brhi	80008b30 <_realloc_r+0x1dc>
80008aec:	59 3a       	cp.w	r10,19
80008aee:	e0 88 00 1a 	brls	80008b22 <_realloc_r+0x1ce>
80008af2:	09 08       	ld.w	r8,r4++
80008af4:	99 08       	st.w	r12[0x0],r8
80008af6:	09 08       	ld.w	r8,r4++
80008af8:	8f 38       	st.w	r7[0xc],r8
80008afa:	ee cc ff f0 	sub	r12,r7,-16
80008afe:	59 ba       	cp.w	r10,27
80008b00:	e0 88 00 11 	brls	80008b22 <_realloc_r+0x1ce>
80008b04:	09 08       	ld.w	r8,r4++
80008b06:	99 08       	st.w	r12[0x0],r8
80008b08:	09 08       	ld.w	r8,r4++
80008b0a:	8f 58       	st.w	r7[0x14],r8
80008b0c:	ee cc ff e8 	sub	r12,r7,-24
80008b10:	e0 4a 00 24 	cp.w	r10,36
80008b14:	c0 71       	brne	80008b22 <_realloc_r+0x1ce>
80008b16:	09 08       	ld.w	r8,r4++
80008b18:	99 08       	st.w	r12[0x0],r8
80008b1a:	ee cc ff e0 	sub	r12,r7,-32
80008b1e:	09 08       	ld.w	r8,r4++
80008b20:	8f 78       	st.w	r7[0x1c],r8
80008b22:	09 08       	ld.w	r8,r4++
80008b24:	18 a8       	st.w	r12++,r8
80008b26:	68 08       	ld.w	r8,r4[0x0]
80008b28:	99 08       	st.w	r12[0x0],r8
80008b2a:	68 18       	ld.w	r8,r4[0x4]
80008b2c:	99 18       	st.w	r12[0x4],r8
80008b2e:	c4 78       	rjmp	80008bbc <_realloc_r+0x268>
80008b30:	08 9b       	mov	r11,r4
80008b32:	e0 a0 1d 42 	rcall	8000c5b6 <memmove>
80008b36:	c4 38       	rjmp	80008bbc <_realloc_r+0x268>
80008b38:	04 9c       	mov	r12,r2
80008b3a:	fe b0 fc 33 	rcall	800083a0 <_malloc_r>
80008b3e:	18 95       	mov	r5,r12
80008b40:	c3 a0       	breq	80008bb4 <_realloc_r+0x260>
80008b42:	62 18       	ld.w	r8,r1[0x4]
80008b44:	f8 c9 00 08 	sub	r9,r12,8
80008b48:	a1 c8       	cbr	r8,0x0
80008b4a:	e2 08 00 08 	add	r8,r1,r8
80008b4e:	10 39       	cp.w	r9,r8
80008b50:	c0 71       	brne	80008b5e <_realloc_r+0x20a>
80008b52:	72 13       	ld.w	r3,r9[0x4]
80008b54:	02 97       	mov	r7,r1
80008b56:	e0 13 ff fc 	andl	r3,0xfffc
80008b5a:	00 03       	add	r3,r0
80008b5c:	c3 08       	rjmp	80008bbc <_realloc_r+0x268>
80008b5e:	e0 ca 00 04 	sub	r10,r0,4
80008b62:	e0 4a 00 24 	cp.w	r10,36
80008b66:	e0 8b 00 20 	brhi	80008ba6 <_realloc_r+0x252>
80008b6a:	08 99       	mov	r9,r4
80008b6c:	18 98       	mov	r8,r12
80008b6e:	59 3a       	cp.w	r10,19
80008b70:	e0 88 00 14 	brls	80008b98 <_realloc_r+0x244>
80008b74:	13 0b       	ld.w	r11,r9++
80008b76:	10 ab       	st.w	r8++,r11
80008b78:	13 0b       	ld.w	r11,r9++
80008b7a:	10 ab       	st.w	r8++,r11
80008b7c:	59 ba       	cp.w	r10,27
80008b7e:	e0 88 00 0d 	brls	80008b98 <_realloc_r+0x244>
80008b82:	13 0b       	ld.w	r11,r9++
80008b84:	10 ab       	st.w	r8++,r11
80008b86:	13 0b       	ld.w	r11,r9++
80008b88:	10 ab       	st.w	r8++,r11
80008b8a:	e0 4a 00 24 	cp.w	r10,36
80008b8e:	c0 51       	brne	80008b98 <_realloc_r+0x244>
80008b90:	13 0a       	ld.w	r10,r9++
80008b92:	10 aa       	st.w	r8++,r10
80008b94:	13 0a       	ld.w	r10,r9++
80008b96:	10 aa       	st.w	r8++,r10
80008b98:	13 0a       	ld.w	r10,r9++
80008b9a:	10 aa       	st.w	r8++,r10
80008b9c:	72 0a       	ld.w	r10,r9[0x0]
80008b9e:	91 0a       	st.w	r8[0x0],r10
80008ba0:	72 19       	ld.w	r9,r9[0x4]
80008ba2:	91 19       	st.w	r8[0x4],r9
80008ba4:	c0 48       	rjmp	80008bac <_realloc_r+0x258>
80008ba6:	08 9b       	mov	r11,r4
80008ba8:	e0 a0 1d 07 	rcall	8000c5b6 <memmove>
80008bac:	08 9b       	mov	r11,r4
80008bae:	04 9c       	mov	r12,r2
80008bb0:	e0 a0 1a 60 	rcall	8000c070 <_free_r>
80008bb4:	04 9c       	mov	r12,r2
80008bb6:	c2 a8       	rjmp	80008c0a <_realloc_r+0x2b6>
80008bb8:	00 93       	mov	r3,r0
80008bba:	02 97       	mov	r7,r1
80008bbc:	e6 06 01 09 	sub	r9,r3,r6
80008bc0:	6e 18       	ld.w	r8,r7[0x4]
80008bc2:	58 f9       	cp.w	r9,15
80008bc4:	e0 88 00 16 	brls	80008bf0 <_realloc_r+0x29c>
80008bc8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008bcc:	ed e8 10 08 	or	r8,r6,r8
80008bd0:	8f 18       	st.w	r7[0x4],r8
80008bd2:	12 98       	mov	r8,r9
80008bd4:	a1 a8       	sbr	r8,0x0
80008bd6:	ee 06 00 0b 	add	r11,r7,r6
80008bda:	f6 09 00 09 	add	r9,r11,r9
80008bde:	97 18       	st.w	r11[0x4],r8
80008be0:	72 18       	ld.w	r8,r9[0x4]
80008be2:	a1 a8       	sbr	r8,0x0
80008be4:	2f 8b       	sub	r11,-8
80008be6:	93 18       	st.w	r9[0x4],r8
80008be8:	04 9c       	mov	r12,r2
80008bea:	e0 a0 1a 43 	rcall	8000c070 <_free_r>
80008bee:	c0 b8       	rjmp	80008c04 <_realloc_r+0x2b0>
80008bf0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008bf4:	e7 e8 10 08 	or	r8,r3,r8
80008bf8:	8f 18       	st.w	r7[0x4],r8
80008bfa:	ee 03 00 03 	add	r3,r7,r3
80008bfe:	66 18       	ld.w	r8,r3[0x4]
80008c00:	a1 a8       	sbr	r8,0x0
80008c02:	87 18       	st.w	r3[0x4],r8
80008c04:	04 9c       	mov	r12,r2
80008c06:	ee c5 ff f8 	sub	r5,r7,-8
80008c0a:	fe b0 f1 87 	rcall	80006f18 <__malloc_unlock>
80008c0e:	0a 9c       	mov	r12,r5
80008c10:	2f fd       	sub	sp,-4
80008c12:	d8 32       	popm	r0-r7,pc

80008c14 <_sbrk_r>:
80008c14:	d4 21       	pushm	r4-r7,lr
80008c16:	30 08       	mov	r8,0
80008c18:	18 97       	mov	r7,r12
80008c1a:	e0 66 bd 4c 	mov	r6,48460
80008c1e:	16 9c       	mov	r12,r11
80008c20:	8d 08       	st.w	r6[0x0],r8
80008c22:	c8 5c       	rcall	80008d2c <_sbrk>
80008c24:	5b fc       	cp.w	r12,-1
80008c26:	c0 51       	brne	80008c30 <_sbrk_r+0x1c>
80008c28:	6c 08       	ld.w	r8,r6[0x0]
80008c2a:	58 08       	cp.w	r8,0
80008c2c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008c30:	d8 22       	popm	r4-r7,pc
80008c32:	d7 03       	nop

80008c34 <sprintf>:
80008c34:	d4 01       	pushm	lr
80008c36:	21 7d       	sub	sp,92
80008c38:	e0 68 ff ff 	mov	r8,65535
80008c3c:	ea 18 7f ff 	orh	r8,0x7fff
80008c40:	50 58       	stdsp	sp[0x14],r8
80008c42:	50 28       	stdsp	sp[0x8],r8
80008c44:	e0 68 02 08 	mov	r8,520
80008c48:	ba 68       	st.h	sp[0xc],r8
80008c4a:	3f f8       	mov	r8,-1
80008c4c:	ba 78       	st.h	sp[0xe],r8
80008c4e:	e0 68 0a 54 	mov	r8,2644
80008c52:	50 4c       	stdsp	sp[0x10],r12
80008c54:	16 9a       	mov	r10,r11
80008c56:	50 0c       	stdsp	sp[0x0],r12
80008c58:	fa c9 ff a0 	sub	r9,sp,-96
80008c5c:	70 0c       	ld.w	r12,r8[0x0]
80008c5e:	1a 9b       	mov	r11,sp
80008c60:	e0 a0 02 1a 	rcall	80009094 <_vfprintf_r>
80008c64:	30 09       	mov	r9,0
80008c66:	40 08       	lddsp	r8,sp[0x0]
80008c68:	b0 89       	st.b	r8[0x0],r9
80008c6a:	2e 9d       	sub	sp,-92
80008c6c:	d8 02       	popm	pc
80008c6e:	d7 03       	nop

80008c70 <strncpy>:
80008c70:	30 08       	mov	r8,0
80008c72:	10 3a       	cp.w	r10,r8
80008c74:	5e 0c       	reteq	r12
80008c76:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008c7a:	f8 08 0b 09 	st.b	r12[r8],r9
80008c7e:	2f f8       	sub	r8,-1
80008c80:	58 09       	cp.w	r9,0
80008c82:	cf 81       	brne	80008c72 <strncpy+0x2>
80008c84:	10 3a       	cp.w	r10,r8
80008c86:	5e 0c       	reteq	r12
80008c88:	f8 08 0b 09 	st.b	r12[r8],r9
80008c8c:	2f f8       	sub	r8,-1
80008c8e:	cf bb       	rjmp	80008c84 <strncpy+0x14>

80008c90 <_close>:
80008c90:	30 28       	mov	r8,2
80008c92:	d6 73       	breakpoint
80008c94:	3f fc       	mov	r12,-1
80008c96:	35 8b       	mov	r11,88
80008c98:	58 0c       	cp.w	r12,0
80008c9a:	5e 4c       	retge	r12
80008c9c:	e0 6a bd 4c 	mov	r10,48460
80008ca0:	95 0b       	st.w	r10[0x0],r11
80008ca2:	5e fc       	retal	r12

80008ca4 <_lseek>:
80008ca4:	30 58       	mov	r8,5
80008ca6:	d6 73       	breakpoint
80008ca8:	3f fc       	mov	r12,-1
80008caa:	35 8b       	mov	r11,88
80008cac:	58 0c       	cp.w	r12,0
80008cae:	5e 4c       	retge	r12
80008cb0:	e0 6a bd 4c 	mov	r10,48460
80008cb4:	95 0b       	st.w	r10[0x0],r11
80008cb6:	5e fc       	retal	r12

80008cb8 <isatty>:
80008cb8:	30 b8       	mov	r8,11
80008cba:	d6 73       	breakpoint
80008cbc:	3f fc       	mov	r12,-1
80008cbe:	35 8b       	mov	r11,88
80008cc0:	58 0c       	cp.w	r12,0
80008cc2:	5e 4c       	retge	r12
80008cc4:	e0 6a bd 4c 	mov	r10,48460
80008cc8:	95 0b       	st.w	r10[0x0],r11
80008cca:	5e fc       	retal	r12

80008ccc <_fstat_host>:
80008ccc:	30 98       	mov	r8,9
80008cce:	d6 73       	breakpoint
80008cd0:	3f fc       	mov	r12,-1
80008cd2:	35 8b       	mov	r11,88
80008cd4:	58 0c       	cp.w	r12,0
80008cd6:	5e 4c       	retge	r12
80008cd8:	e0 6a bd 4c 	mov	r10,48460
80008cdc:	95 0b       	st.w	r10[0x0],r11
80008cde:	5e fc       	retal	r12

80008ce0 <_fstat>:
80008ce0:	d4 21       	pushm	r4-r7,lr
80008ce2:	21 0d       	sub	sp,64
80008ce4:	16 97       	mov	r7,r11
80008ce6:	1a 9b       	mov	r11,sp
80008ce8:	cf 2f       	rcall	80008ccc <_fstat_host>
80008cea:	c0 34       	brge	80008cf0 <_fstat+0x10>
80008cec:	3f fc       	mov	r12,-1
80008cee:	c1 c8       	rjmp	80008d26 <_fstat+0x46>
80008cf0:	40 08       	lddsp	r8,sp[0x0]
80008cf2:	ae 08       	st.h	r7[0x0],r8
80008cf4:	40 18       	lddsp	r8,sp[0x4]
80008cf6:	ae 18       	st.h	r7[0x2],r8
80008cf8:	40 28       	lddsp	r8,sp[0x8]
80008cfa:	8f 18       	st.w	r7[0x4],r8
80008cfc:	40 38       	lddsp	r8,sp[0xc]
80008cfe:	ae 48       	st.h	r7[0x8],r8
80008d00:	40 48       	lddsp	r8,sp[0x10]
80008d02:	ae 58       	st.h	r7[0xa],r8
80008d04:	40 58       	lddsp	r8,sp[0x14]
80008d06:	ae 68       	st.h	r7[0xc],r8
80008d08:	40 68       	lddsp	r8,sp[0x18]
80008d0a:	ae 78       	st.h	r7[0xe],r8
80008d0c:	40 88       	lddsp	r8,sp[0x20]
80008d0e:	8f 48       	st.w	r7[0x10],r8
80008d10:	40 a8       	lddsp	r8,sp[0x28]
80008d12:	8f b8       	st.w	r7[0x2c],r8
80008d14:	40 c8       	lddsp	r8,sp[0x30]
80008d16:	8f c8       	st.w	r7[0x30],r8
80008d18:	40 d8       	lddsp	r8,sp[0x34]
80008d1a:	8f 58       	st.w	r7[0x14],r8
80008d1c:	40 e8       	lddsp	r8,sp[0x38]
80008d1e:	30 0c       	mov	r12,0
80008d20:	8f 78       	st.w	r7[0x1c],r8
80008d22:	40 f8       	lddsp	r8,sp[0x3c]
80008d24:	8f 98       	st.w	r7[0x24],r8
80008d26:	2f 0d       	sub	sp,-64
80008d28:	d8 22       	popm	r4-r7,pc
80008d2a:	d7 03       	nop

80008d2c <_sbrk>:
80008d2c:	d4 01       	pushm	lr
80008d2e:	e0 68 0e 1c 	mov	r8,3612
80008d32:	70 09       	ld.w	r9,r8[0x0]
80008d34:	58 09       	cp.w	r9,0
80008d36:	c0 41       	brne	80008d3e <_sbrk+0x12>
80008d38:	e0 69 bd 50 	mov	r9,48464
80008d3c:	91 09       	st.w	r8[0x0],r9
80008d3e:	e0 69 0e 1c 	mov	r9,3612
80008d42:	e0 7a 70 00 	mov	r10,94208
80008d46:	72 08       	ld.w	r8,r9[0x0]
80008d48:	f0 0c 00 0c 	add	r12,r8,r12
80008d4c:	14 3c       	cp.w	r12,r10
80008d4e:	e0 8b 00 04 	brhi	80008d56 <_sbrk+0x2a>
80008d52:	93 0c       	st.w	r9[0x0],r12
80008d54:	c0 68       	rjmp	80008d60 <_sbrk+0x34>
80008d56:	e0 a0 18 15 	rcall	8000bd80 <__errno>
80008d5a:	30 c8       	mov	r8,12
80008d5c:	99 08       	st.w	r12[0x0],r8
80008d5e:	3f f8       	mov	r8,-1
80008d60:	10 9c       	mov	r12,r8
80008d62:	d8 02       	popm	pc

80008d64 <get_arg>:
80008d64:	d4 31       	pushm	r0-r7,lr
80008d66:	20 8d       	sub	sp,32
80008d68:	fa c4 ff bc 	sub	r4,sp,-68
80008d6c:	50 4b       	stdsp	sp[0x10],r11
80008d6e:	68 2e       	ld.w	lr,r4[0x8]
80008d70:	50 58       	stdsp	sp[0x14],r8
80008d72:	12 96       	mov	r6,r9
80008d74:	7c 0b       	ld.w	r11,lr[0x0]
80008d76:	70 05       	ld.w	r5,r8[0x0]
80008d78:	50 6e       	stdsp	sp[0x18],lr
80008d7a:	58 0b       	cp.w	r11,0
80008d7c:	f4 0b 17 00 	moveq	r11,r10
80008d80:	68 03       	ld.w	r3,r4[0x0]
80008d82:	68 11       	ld.w	r1,r4[0x4]
80008d84:	40 49       	lddsp	r9,sp[0x10]
80008d86:	30 08       	mov	r8,0
80008d88:	c2 89       	rjmp	80008fd8 <get_arg+0x274>
80008d8a:	2f fb       	sub	r11,-1
80008d8c:	32 5c       	mov	r12,37
80008d8e:	17 8a       	ld.ub	r10,r11[0x0]
80008d90:	f8 0a 18 00 	cp.b	r10,r12
80008d94:	5f 1e       	srne	lr
80008d96:	f0 0a 18 00 	cp.b	r10,r8
80008d9a:	5f 1c       	srne	r12
80008d9c:	fd ec 00 0c 	and	r12,lr,r12
80008da0:	f0 0c 18 00 	cp.b	r12,r8
80008da4:	cf 31       	brne	80008d8a <get_arg+0x26>
80008da6:	58 0a       	cp.w	r10,0
80008da8:	e0 80 01 25 	breq	80008ff2 <get_arg+0x28e>
80008dac:	30 0c       	mov	r12,0
80008dae:	3f fa       	mov	r10,-1
80008db0:	18 90       	mov	r0,r12
80008db2:	50 3a       	stdsp	sp[0xc],r10
80008db4:	18 94       	mov	r4,r12
80008db6:	18 92       	mov	r2,r12
80008db8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008dbc:	16 97       	mov	r7,r11
80008dbe:	50 7c       	stdsp	sp[0x1c],r12
80008dc0:	fe cc 9a 4c 	sub	r12,pc,-26036
80008dc4:	0f 3a       	ld.ub	r10,r7++
80008dc6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80008dca:	40 7c       	lddsp	r12,sp[0x1c]
80008dcc:	1c 0c       	add	r12,lr
80008dce:	fe ce 9b 22 	sub	lr,pc,-25822
80008dd2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80008dd6:	20 1e       	sub	lr,1
80008dd8:	50 0e       	stdsp	sp[0x0],lr
80008dda:	fe ce 9b 9a 	sub	lr,pc,-25702
80008dde:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008de2:	50 7c       	stdsp	sp[0x1c],r12
80008de4:	40 0c       	lddsp	r12,sp[0x0]
80008de6:	58 7c       	cp.w	r12,7
80008de8:	e0 8b 00 f1 	brhi	80008fca <get_arg+0x266>
80008dec:	fe ce 9d 4c 	sub	lr,pc,-25268
80008df0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008df4:	36 8b       	mov	r11,104
80008df6:	f6 0a 18 00 	cp.b	r10,r11
80008dfa:	e0 80 00 e8 	breq	80008fca <get_arg+0x266>
80008dfe:	37 1b       	mov	r11,113
80008e00:	f6 0a 18 00 	cp.b	r10,r11
80008e04:	c0 70       	breq	80008e12 <get_arg+0xae>
80008e06:	34 cb       	mov	r11,76
80008e08:	f6 0a 18 00 	cp.b	r10,r11
80008e0c:	c0 51       	brne	80008e16 <get_arg+0xb2>
80008e0e:	a3 b4       	sbr	r4,0x3
80008e10:	cd d8       	rjmp	80008fca <get_arg+0x266>
80008e12:	a5 b4       	sbr	r4,0x5
80008e14:	cd b8       	rjmp	80008fca <get_arg+0x266>
80008e16:	08 9a       	mov	r10,r4
80008e18:	0e 9b       	mov	r11,r7
80008e1a:	a5 aa       	sbr	r10,0x4
80008e1c:	17 3c       	ld.ub	r12,r11++
80008e1e:	a5 b4       	sbr	r4,0x5
80008e20:	36 ce       	mov	lr,108
80008e22:	fc 0c 18 00 	cp.b	r12,lr
80008e26:	e0 80 00 d3 	breq	80008fcc <get_arg+0x268>
80008e2a:	14 94       	mov	r4,r10
80008e2c:	cc f8       	rjmp	80008fca <get_arg+0x266>
80008e2e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008e32:	36 7c       	mov	r12,103
80008e34:	f8 0a 18 00 	cp.b	r10,r12
80008e38:	e0 8b 00 27 	brhi	80008e86 <get_arg+0x122>
80008e3c:	36 5b       	mov	r11,101
80008e3e:	f6 0a 18 00 	cp.b	r10,r11
80008e42:	c4 82       	brcc	80008ed2 <get_arg+0x16e>
80008e44:	34 fb       	mov	r11,79
80008e46:	f6 0a 18 00 	cp.b	r10,r11
80008e4a:	c4 80       	breq	80008eda <get_arg+0x176>
80008e4c:	e0 8b 00 0c 	brhi	80008e64 <get_arg+0x100>
80008e50:	34 5b       	mov	r11,69
80008e52:	f6 0a 18 00 	cp.b	r10,r11
80008e56:	c3 e0       	breq	80008ed2 <get_arg+0x16e>
80008e58:	34 7b       	mov	r11,71
80008e5a:	f6 0a 18 00 	cp.b	r10,r11
80008e5e:	c3 a0       	breq	80008ed2 <get_arg+0x16e>
80008e60:	34 4b       	mov	r11,68
80008e62:	c0 88       	rjmp	80008e72 <get_arg+0x10e>
80008e64:	35 8b       	mov	r11,88
80008e66:	f6 0a 18 00 	cp.b	r10,r11
80008e6a:	c2 c0       	breq	80008ec2 <get_arg+0x15e>
80008e6c:	e0 8b 00 07 	brhi	80008e7a <get_arg+0x116>
80008e70:	35 5b       	mov	r11,85
80008e72:	f6 0a 18 00 	cp.b	r10,r11
80008e76:	c3 51       	brne	80008ee0 <get_arg+0x17c>
80008e78:	c3 18       	rjmp	80008eda <get_arg+0x176>
80008e7a:	36 3b       	mov	r11,99
80008e7c:	f6 0a 18 00 	cp.b	r10,r11
80008e80:	c2 f0       	breq	80008ede <get_arg+0x17a>
80008e82:	36 4b       	mov	r11,100
80008e84:	c0 e8       	rjmp	80008ea0 <get_arg+0x13c>
80008e86:	37 0b       	mov	r11,112
80008e88:	f6 0a 18 00 	cp.b	r10,r11
80008e8c:	c2 50       	breq	80008ed6 <get_arg+0x172>
80008e8e:	e0 8b 00 0d 	brhi	80008ea8 <get_arg+0x144>
80008e92:	36 eb       	mov	r11,110
80008e94:	f6 0a 18 00 	cp.b	r10,r11
80008e98:	c1 f0       	breq	80008ed6 <get_arg+0x172>
80008e9a:	e0 8b 00 14 	brhi	80008ec2 <get_arg+0x15e>
80008e9e:	36 9b       	mov	r11,105
80008ea0:	f6 0a 18 00 	cp.b	r10,r11
80008ea4:	c1 e1       	brne	80008ee0 <get_arg+0x17c>
80008ea6:	c0 e8       	rjmp	80008ec2 <get_arg+0x15e>
80008ea8:	37 5b       	mov	r11,117
80008eaa:	f6 0a 18 00 	cp.b	r10,r11
80008eae:	c0 a0       	breq	80008ec2 <get_arg+0x15e>
80008eb0:	37 8b       	mov	r11,120
80008eb2:	f6 0a 18 00 	cp.b	r10,r11
80008eb6:	c0 60       	breq	80008ec2 <get_arg+0x15e>
80008eb8:	37 3b       	mov	r11,115
80008eba:	f6 0a 18 00 	cp.b	r10,r11
80008ebe:	c1 11       	brne	80008ee0 <get_arg+0x17c>
80008ec0:	c0 b8       	rjmp	80008ed6 <get_arg+0x172>
80008ec2:	ed b4 00 04 	bld	r4,0x4
80008ec6:	c0 a0       	breq	80008eda <get_arg+0x176>
80008ec8:	ed b4 00 05 	bld	r4,0x5
80008ecc:	c0 91       	brne	80008ede <get_arg+0x17a>
80008ece:	30 20       	mov	r0,2
80008ed0:	c0 88       	rjmp	80008ee0 <get_arg+0x17c>
80008ed2:	30 40       	mov	r0,4
80008ed4:	c0 68       	rjmp	80008ee0 <get_arg+0x17c>
80008ed6:	30 30       	mov	r0,3
80008ed8:	c0 48       	rjmp	80008ee0 <get_arg+0x17c>
80008eda:	30 10       	mov	r0,1
80008edc:	c0 28       	rjmp	80008ee0 <get_arg+0x17c>
80008ede:	30 00       	mov	r0,0
80008ee0:	40 3b       	lddsp	r11,sp[0xc]
80008ee2:	5b fb       	cp.w	r11,-1
80008ee4:	c0 40       	breq	80008eec <get_arg+0x188>
80008ee6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008eea:	c7 08       	rjmp	80008fca <get_arg+0x266>
80008eec:	58 60       	cp.w	r0,6
80008eee:	e0 8b 00 6e 	brhi	80008fca <get_arg+0x266>
80008ef2:	6c 0a       	ld.w	r10,r6[0x0]
80008ef4:	ea cc ff ff 	sub	r12,r5,-1
80008ef8:	fe ce 9e 38 	sub	lr,pc,-25032
80008efc:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008f00:	f4 cb ff f8 	sub	r11,r10,-8
80008f04:	8d 0b       	st.w	r6[0x0],r11
80008f06:	f4 ea 00 00 	ld.d	r10,r10[0]
80008f0a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008f0e:	c0 f8       	rjmp	80008f2c <get_arg+0x1c8>
80008f10:	f4 cb ff fc 	sub	r11,r10,-4
80008f14:	8d 0b       	st.w	r6[0x0],r11
80008f16:	74 0a       	ld.w	r10,r10[0x0]
80008f18:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008f1c:	c0 88       	rjmp	80008f2c <get_arg+0x1c8>
80008f1e:	f4 cb ff f8 	sub	r11,r10,-8
80008f22:	8d 0b       	st.w	r6[0x0],r11
80008f24:	f4 ea 00 00 	ld.d	r10,r10[0]
80008f28:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008f2c:	0e 9b       	mov	r11,r7
80008f2e:	18 95       	mov	r5,r12
80008f30:	c4 e8       	rjmp	80008fcc <get_arg+0x268>
80008f32:	62 0a       	ld.w	r10,r1[0x0]
80008f34:	5b fa       	cp.w	r10,-1
80008f36:	c0 b1       	brne	80008f4c <get_arg+0x1e8>
80008f38:	50 19       	stdsp	sp[0x4],r9
80008f3a:	50 28       	stdsp	sp[0x8],r8
80008f3c:	e0 6a 00 80 	mov	r10,128
80008f40:	30 0b       	mov	r11,0
80008f42:	02 9c       	mov	r12,r1
80008f44:	fe b0 fd 01 	rcall	80008946 <memset>
80008f48:	40 28       	lddsp	r8,sp[0x8]
80008f4a:	40 19       	lddsp	r9,sp[0x4]
80008f4c:	e4 cc 00 01 	sub	r12,r2,1
80008f50:	0e 9b       	mov	r11,r7
80008f52:	50 3c       	stdsp	sp[0xc],r12
80008f54:	f2 0c 0c 49 	max	r9,r9,r12
80008f58:	c3 a8       	rjmp	80008fcc <get_arg+0x268>
80008f5a:	62 0a       	ld.w	r10,r1[0x0]
80008f5c:	5b fa       	cp.w	r10,-1
80008f5e:	c0 b1       	brne	80008f74 <get_arg+0x210>
80008f60:	50 19       	stdsp	sp[0x4],r9
80008f62:	50 28       	stdsp	sp[0x8],r8
80008f64:	e0 6a 00 80 	mov	r10,128
80008f68:	30 0b       	mov	r11,0
80008f6a:	02 9c       	mov	r12,r1
80008f6c:	fe b0 fc ed 	rcall	80008946 <memset>
80008f70:	40 28       	lddsp	r8,sp[0x8]
80008f72:	40 19       	lddsp	r9,sp[0x4]
80008f74:	20 12       	sub	r2,1
80008f76:	30 0a       	mov	r10,0
80008f78:	0e 9b       	mov	r11,r7
80008f7a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008f7e:	f2 02 0c 49 	max	r9,r9,r2
80008f82:	c2 58       	rjmp	80008fcc <get_arg+0x268>
80008f84:	16 97       	mov	r7,r11
80008f86:	6c 0a       	ld.w	r10,r6[0x0]
80008f88:	f4 cb ff fc 	sub	r11,r10,-4
80008f8c:	8d 0b       	st.w	r6[0x0],r11
80008f8e:	74 0a       	ld.w	r10,r10[0x0]
80008f90:	0e 9b       	mov	r11,r7
80008f92:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008f96:	2f f5       	sub	r5,-1
80008f98:	c1 a8       	rjmp	80008fcc <get_arg+0x268>
80008f9a:	f4 c2 00 30 	sub	r2,r10,48
80008f9e:	c0 68       	rjmp	80008faa <get_arg+0x246>
80008fa0:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008fa4:	2f f7       	sub	r7,-1
80008fa6:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008faa:	0f 8a       	ld.ub	r10,r7[0x0]
80008fac:	58 0a       	cp.w	r10,0
80008fae:	c0 e0       	breq	80008fca <get_arg+0x266>
80008fb0:	23 0a       	sub	r10,48
80008fb2:	58 9a       	cp.w	r10,9
80008fb4:	fe 98 ff f6 	brls	80008fa0 <get_arg+0x23c>
80008fb8:	c0 98       	rjmp	80008fca <get_arg+0x266>
80008fba:	2f f7       	sub	r7,-1
80008fbc:	0f 8a       	ld.ub	r10,r7[0x0]
80008fbe:	58 0a       	cp.w	r10,0
80008fc0:	c0 50       	breq	80008fca <get_arg+0x266>
80008fc2:	23 0a       	sub	r10,48
80008fc4:	58 9a       	cp.w	r10,9
80008fc6:	fe 98 ff fa 	brls	80008fba <get_arg+0x256>
80008fca:	0e 9b       	mov	r11,r7
80008fcc:	40 7c       	lddsp	r12,sp[0x1c]
80008fce:	30 ba       	mov	r10,11
80008fd0:	f4 0c 18 00 	cp.b	r12,r10
80008fd4:	fe 91 fe f2 	brne	80008db8 <get_arg+0x54>
80008fd8:	40 42       	lddsp	r2,sp[0x10]
80008fda:	17 8c       	ld.ub	r12,r11[0x0]
80008fdc:	0a 32       	cp.w	r2,r5
80008fde:	5f 4a       	srge	r10
80008fe0:	f0 0c 18 00 	cp.b	r12,r8
80008fe4:	5f 1c       	srne	r12
80008fe6:	f9 ea 00 0a 	and	r10,r12,r10
80008fea:	f0 0a 18 00 	cp.b	r10,r8
80008fee:	fe 91 fe cf 	brne	80008d8c <get_arg+0x28>
80008ff2:	30 08       	mov	r8,0
80008ff4:	40 4e       	lddsp	lr,sp[0x10]
80008ff6:	17 8a       	ld.ub	r10,r11[0x0]
80008ff8:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008ffc:	f0 0a 18 00 	cp.b	r10,r8
80009000:	fc 09 17 10 	movne	r9,lr
80009004:	e6 05 00 38 	add	r8,r3,r5<<0x3
80009008:	06 9e       	mov	lr,r3
8000900a:	c2 a8       	rjmp	8000905e <get_arg+0x2fa>
8000900c:	62 0a       	ld.w	r10,r1[0x0]
8000900e:	58 3a       	cp.w	r10,3
80009010:	c1 e0       	breq	8000904c <get_arg+0x2e8>
80009012:	e0 89 00 07 	brgt	80009020 <get_arg+0x2bc>
80009016:	58 1a       	cp.w	r10,1
80009018:	c1 a0       	breq	8000904c <get_arg+0x2e8>
8000901a:	58 2a       	cp.w	r10,2
8000901c:	c1 81       	brne	8000904c <get_arg+0x2e8>
8000901e:	c0 58       	rjmp	80009028 <get_arg+0x2c4>
80009020:	58 5a       	cp.w	r10,5
80009022:	c0 c0       	breq	8000903a <get_arg+0x2d6>
80009024:	c0 b5       	brlt	8000903a <get_arg+0x2d6>
80009026:	c1 38       	rjmp	8000904c <get_arg+0x2e8>
80009028:	6c 0a       	ld.w	r10,r6[0x0]
8000902a:	f4 cc ff f8 	sub	r12,r10,-8
8000902e:	8d 0c       	st.w	r6[0x0],r12
80009030:	f4 e2 00 00 	ld.d	r2,r10[0]
80009034:	f0 e3 00 00 	st.d	r8[0],r2
80009038:	c1 08       	rjmp	80009058 <get_arg+0x2f4>
8000903a:	6c 0a       	ld.w	r10,r6[0x0]
8000903c:	f4 cc ff f8 	sub	r12,r10,-8
80009040:	8d 0c       	st.w	r6[0x0],r12
80009042:	f4 e2 00 00 	ld.d	r2,r10[0]
80009046:	f0 e3 00 00 	st.d	r8[0],r2
8000904a:	c0 78       	rjmp	80009058 <get_arg+0x2f4>
8000904c:	6c 0a       	ld.w	r10,r6[0x0]
8000904e:	f4 cc ff fc 	sub	r12,r10,-4
80009052:	8d 0c       	st.w	r6[0x0],r12
80009054:	74 0a       	ld.w	r10,r10[0x0]
80009056:	91 0a       	st.w	r8[0x0],r10
80009058:	2f f5       	sub	r5,-1
8000905a:	2f 88       	sub	r8,-8
8000905c:	2f c1       	sub	r1,-4
8000905e:	12 35       	cp.w	r5,r9
80009060:	fe 9a ff d6 	brle	8000900c <get_arg+0x2a8>
80009064:	1c 93       	mov	r3,lr
80009066:	40 52       	lddsp	r2,sp[0x14]
80009068:	40 6e       	lddsp	lr,sp[0x18]
8000906a:	85 05       	st.w	r2[0x0],r5
8000906c:	9d 0b       	st.w	lr[0x0],r11
8000906e:	40 4b       	lddsp	r11,sp[0x10]
80009070:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80009074:	2f 8d       	sub	sp,-32
80009076:	d8 32       	popm	r0-r7,pc

80009078 <__sprint_r>:
80009078:	d4 21       	pushm	r4-r7,lr
8000907a:	14 97       	mov	r7,r10
8000907c:	74 28       	ld.w	r8,r10[0x8]
8000907e:	58 08       	cp.w	r8,0
80009080:	c0 41       	brne	80009088 <__sprint_r+0x10>
80009082:	95 18       	st.w	r10[0x4],r8
80009084:	10 9c       	mov	r12,r8
80009086:	d8 22       	popm	r4-r7,pc
80009088:	e0 a0 18 ba 	rcall	8000c1fc <__sfvwrite_r>
8000908c:	30 08       	mov	r8,0
8000908e:	8f 18       	st.w	r7[0x4],r8
80009090:	8f 28       	st.w	r7[0x8],r8
80009092:	d8 22       	popm	r4-r7,pc

80009094 <_vfprintf_r>:
80009094:	d4 31       	pushm	r0-r7,lr
80009096:	fa cd 06 bc 	sub	sp,sp,1724
8000909a:	51 09       	stdsp	sp[0x40],r9
8000909c:	16 91       	mov	r1,r11
8000909e:	14 97       	mov	r7,r10
800090a0:	18 95       	mov	r5,r12
800090a2:	e0 a0 1a 1d 	rcall	8000c4dc <_localeconv_r>
800090a6:	78 0c       	ld.w	r12,r12[0x0]
800090a8:	50 cc       	stdsp	sp[0x30],r12
800090aa:	58 05       	cp.w	r5,0
800090ac:	c0 70       	breq	800090ba <_vfprintf_r+0x26>
800090ae:	6a 68       	ld.w	r8,r5[0x18]
800090b0:	58 08       	cp.w	r8,0
800090b2:	c0 41       	brne	800090ba <_vfprintf_r+0x26>
800090b4:	0a 9c       	mov	r12,r5
800090b6:	e0 a0 17 43 	rcall	8000bf3c <__sinit>
800090ba:	fe c8 9c 36 	sub	r8,pc,-25546
800090be:	10 31       	cp.w	r1,r8
800090c0:	c0 31       	brne	800090c6 <_vfprintf_r+0x32>
800090c2:	6a 01       	ld.w	r1,r5[0x0]
800090c4:	c0 c8       	rjmp	800090dc <_vfprintf_r+0x48>
800090c6:	fe c8 9c 22 	sub	r8,pc,-25566
800090ca:	10 31       	cp.w	r1,r8
800090cc:	c0 31       	brne	800090d2 <_vfprintf_r+0x3e>
800090ce:	6a 11       	ld.w	r1,r5[0x4]
800090d0:	c0 68       	rjmp	800090dc <_vfprintf_r+0x48>
800090d2:	fe c8 9c 0e 	sub	r8,pc,-25586
800090d6:	10 31       	cp.w	r1,r8
800090d8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800090dc:	82 68       	ld.sh	r8,r1[0xc]
800090de:	ed b8 00 03 	bld	r8,0x3
800090e2:	c0 41       	brne	800090ea <_vfprintf_r+0x56>
800090e4:	62 48       	ld.w	r8,r1[0x10]
800090e6:	58 08       	cp.w	r8,0
800090e8:	c0 71       	brne	800090f6 <_vfprintf_r+0x62>
800090ea:	02 9b       	mov	r11,r1
800090ec:	0a 9c       	mov	r12,r5
800090ee:	e0 a0 0f 5d 	rcall	8000afa8 <__swsetup_r>
800090f2:	e0 81 0f 54 	brne	8000af9a <_vfprintf_r+0x1f06>
800090f6:	82 68       	ld.sh	r8,r1[0xc]
800090f8:	10 99       	mov	r9,r8
800090fa:	e2 19 00 1a 	andl	r9,0x1a,COH
800090fe:	58 a9       	cp.w	r9,10
80009100:	c3 c1       	brne	80009178 <_vfprintf_r+0xe4>
80009102:	82 79       	ld.sh	r9,r1[0xe]
80009104:	30 0a       	mov	r10,0
80009106:	f4 09 19 00 	cp.h	r9,r10
8000910a:	c3 75       	brlt	80009178 <_vfprintf_r+0xe4>
8000910c:	a1 d8       	cbr	r8,0x1
8000910e:	fb 58 05 d0 	st.h	sp[1488],r8
80009112:	62 88       	ld.w	r8,r1[0x20]
80009114:	fb 48 05 e4 	st.w	sp[1508],r8
80009118:	62 a8       	ld.w	r8,r1[0x28]
8000911a:	fb 48 05 ec 	st.w	sp[1516],r8
8000911e:	fa c8 ff bc 	sub	r8,sp,-68
80009122:	fb 48 05 d4 	st.w	sp[1492],r8
80009126:	fb 48 05 c4 	st.w	sp[1476],r8
8000912a:	e0 68 04 00 	mov	r8,1024
8000912e:	fb 48 05 d8 	st.w	sp[1496],r8
80009132:	fb 48 05 cc 	st.w	sp[1484],r8
80009136:	30 08       	mov	r8,0
80009138:	fb 59 05 d2 	st.h	sp[1490],r9
8000913c:	0e 9a       	mov	r10,r7
8000913e:	41 09       	lddsp	r9,sp[0x40]
80009140:	fa c7 fa 3c 	sub	r7,sp,-1476
80009144:	fb 48 05 dc 	st.w	sp[1500],r8
80009148:	0a 9c       	mov	r12,r5
8000914a:	0e 9b       	mov	r11,r7
8000914c:	ca 4f       	rcall	80009094 <_vfprintf_r>
8000914e:	50 bc       	stdsp	sp[0x2c],r12
80009150:	c0 95       	brlt	80009162 <_vfprintf_r+0xce>
80009152:	0e 9b       	mov	r11,r7
80009154:	0a 9c       	mov	r12,r5
80009156:	e0 a0 16 1b 	rcall	8000bd8c <_fflush_r>
8000915a:	40 be       	lddsp	lr,sp[0x2c]
8000915c:	f9 be 01 ff 	movne	lr,-1
80009160:	50 be       	stdsp	sp[0x2c],lr
80009162:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80009166:	ed b8 00 06 	bld	r8,0x6
8000916a:	e0 81 0f 1a 	brne	8000af9e <_vfprintf_r+0x1f0a>
8000916e:	82 68       	ld.sh	r8,r1[0xc]
80009170:	a7 a8       	sbr	r8,0x6
80009172:	a2 68       	st.h	r1[0xc],r8
80009174:	e0 8f 0f 15 	bral	8000af9e <_vfprintf_r+0x1f0a>
80009178:	30 08       	mov	r8,0
8000917a:	fb 48 06 b4 	st.w	sp[1716],r8
8000917e:	fb 48 06 90 	st.w	sp[1680],r8
80009182:	fb 48 06 8c 	st.w	sp[1676],r8
80009186:	fb 48 06 b0 	st.w	sp[1712],r8
8000918a:	30 08       	mov	r8,0
8000918c:	30 09       	mov	r9,0
8000918e:	50 a7       	stdsp	sp[0x28],r7
80009190:	50 78       	stdsp	sp[0x1c],r8
80009192:	fa c3 f9 e0 	sub	r3,sp,-1568
80009196:	3f f8       	mov	r8,-1
80009198:	50 59       	stdsp	sp[0x14],r9
8000919a:	fb 43 06 88 	st.w	sp[1672],r3
8000919e:	fb 48 05 44 	st.w	sp[1348],r8
800091a2:	12 9c       	mov	r12,r9
800091a4:	50 69       	stdsp	sp[0x18],r9
800091a6:	50 d9       	stdsp	sp[0x34],r9
800091a8:	50 e9       	stdsp	sp[0x38],r9
800091aa:	50 b9       	stdsp	sp[0x2c],r9
800091ac:	12 97       	mov	r7,r9
800091ae:	0a 94       	mov	r4,r5
800091b0:	40 a2       	lddsp	r2,sp[0x28]
800091b2:	32 5a       	mov	r10,37
800091b4:	30 08       	mov	r8,0
800091b6:	c0 28       	rjmp	800091ba <_vfprintf_r+0x126>
800091b8:	2f f2       	sub	r2,-1
800091ba:	05 89       	ld.ub	r9,r2[0x0]
800091bc:	f0 09 18 00 	cp.b	r9,r8
800091c0:	5f 1b       	srne	r11
800091c2:	f4 09 18 00 	cp.b	r9,r10
800091c6:	5f 19       	srne	r9
800091c8:	f3 eb 00 0b 	and	r11,r9,r11
800091cc:	f0 0b 18 00 	cp.b	r11,r8
800091d0:	cf 41       	brne	800091b8 <_vfprintf_r+0x124>
800091d2:	40 ab       	lddsp	r11,sp[0x28]
800091d4:	e4 0b 01 06 	sub	r6,r2,r11
800091d8:	c1 e0       	breq	80009214 <_vfprintf_r+0x180>
800091da:	fa f8 06 90 	ld.w	r8,sp[1680]
800091de:	0c 08       	add	r8,r6
800091e0:	87 0b       	st.w	r3[0x0],r11
800091e2:	fb 48 06 90 	st.w	sp[1680],r8
800091e6:	87 16       	st.w	r3[0x4],r6
800091e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091ec:	2f f8       	sub	r8,-1
800091ee:	fb 48 06 8c 	st.w	sp[1676],r8
800091f2:	58 78       	cp.w	r8,7
800091f4:	e0 89 00 04 	brgt	800091fc <_vfprintf_r+0x168>
800091f8:	2f 83       	sub	r3,-8
800091fa:	c0 a8       	rjmp	8000920e <_vfprintf_r+0x17a>
800091fc:	fa ca f9 78 	sub	r10,sp,-1672
80009200:	02 9b       	mov	r11,r1
80009202:	08 9c       	mov	r12,r4
80009204:	c3 af       	rcall	80009078 <__sprint_r>
80009206:	e0 81 0e c6 	brne	8000af92 <_vfprintf_r+0x1efe>
8000920a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000920e:	40 ba       	lddsp	r10,sp[0x2c]
80009210:	0c 0a       	add	r10,r6
80009212:	50 ba       	stdsp	sp[0x2c],r10
80009214:	05 89       	ld.ub	r9,r2[0x0]
80009216:	30 08       	mov	r8,0
80009218:	f0 09 18 00 	cp.b	r9,r8
8000921c:	e0 80 0e aa 	breq	8000af70 <_vfprintf_r+0x1edc>
80009220:	30 09       	mov	r9,0
80009222:	fb 68 06 bb 	st.b	sp[1723],r8
80009226:	0e 96       	mov	r6,r7
80009228:	e4 c8 ff ff 	sub	r8,r2,-1
8000922c:	3f fe       	mov	lr,-1
8000922e:	50 93       	stdsp	sp[0x24],r3
80009230:	50 41       	stdsp	sp[0x10],r1
80009232:	0e 93       	mov	r3,r7
80009234:	04 91       	mov	r1,r2
80009236:	50 89       	stdsp	sp[0x20],r9
80009238:	50 a8       	stdsp	sp[0x28],r8
8000923a:	50 2e       	stdsp	sp[0x8],lr
8000923c:	50 39       	stdsp	sp[0xc],r9
8000923e:	12 95       	mov	r5,r9
80009240:	12 90       	mov	r0,r9
80009242:	10 97       	mov	r7,r8
80009244:	08 92       	mov	r2,r4
80009246:	c0 78       	rjmp	80009254 <_vfprintf_r+0x1c0>
80009248:	3f fc       	mov	r12,-1
8000924a:	08 97       	mov	r7,r4
8000924c:	50 2c       	stdsp	sp[0x8],r12
8000924e:	c0 38       	rjmp	80009254 <_vfprintf_r+0x1c0>
80009250:	30 0b       	mov	r11,0
80009252:	50 3b       	stdsp	sp[0xc],r11
80009254:	0f 38       	ld.ub	r8,r7++
80009256:	c0 28       	rjmp	8000925a <_vfprintf_r+0x1c6>
80009258:	12 90       	mov	r0,r9
8000925a:	f0 c9 00 20 	sub	r9,r8,32
8000925e:	e0 49 00 58 	cp.w	r9,88
80009262:	e0 8b 0a 30 	brhi	8000a6c2 <_vfprintf_r+0x162e>
80009266:	fe ca a1 8a 	sub	r10,pc,-24182
8000926a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000926e:	50 a7       	stdsp	sp[0x28],r7
80009270:	50 80       	stdsp	sp[0x20],r0
80009272:	0c 97       	mov	r7,r6
80009274:	04 94       	mov	r4,r2
80009276:	06 96       	mov	r6,r3
80009278:	02 92       	mov	r2,r1
8000927a:	fe c9 9f 62 	sub	r9,pc,-24734
8000927e:	40 93       	lddsp	r3,sp[0x24]
80009280:	10 90       	mov	r0,r8
80009282:	40 41       	lddsp	r1,sp[0x10]
80009284:	50 d9       	stdsp	sp[0x34],r9
80009286:	e0 8f 08 8e 	bral	8000a3a2 <_vfprintf_r+0x130e>
8000928a:	30 08       	mov	r8,0
8000928c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80009290:	f0 09 18 00 	cp.b	r9,r8
80009294:	ce 01       	brne	80009254 <_vfprintf_r+0x1c0>
80009296:	32 08       	mov	r8,32
80009298:	c6 e8       	rjmp	80009374 <_vfprintf_r+0x2e0>
8000929a:	a1 a5       	sbr	r5,0x0
8000929c:	cd cb       	rjmp	80009254 <_vfprintf_r+0x1c0>
8000929e:	0f 89       	ld.ub	r9,r7[0x0]
800092a0:	f2 c8 00 30 	sub	r8,r9,48
800092a4:	58 98       	cp.w	r8,9
800092a6:	e0 8b 00 1d 	brhi	800092e0 <_vfprintf_r+0x24c>
800092aa:	ee c8 ff ff 	sub	r8,r7,-1
800092ae:	30 0b       	mov	r11,0
800092b0:	23 09       	sub	r9,48
800092b2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800092b6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800092ba:	11 39       	ld.ub	r9,r8++
800092bc:	f2 ca 00 30 	sub	r10,r9,48
800092c0:	58 9a       	cp.w	r10,9
800092c2:	fe 98 ff f7 	brls	800092b0 <_vfprintf_r+0x21c>
800092c6:	e0 49 00 24 	cp.w	r9,36
800092ca:	cc 31       	brne	80009250 <_vfprintf_r+0x1bc>
800092cc:	e0 4b 00 20 	cp.w	r11,32
800092d0:	e0 89 0e 60 	brgt	8000af90 <_vfprintf_r+0x1efc>
800092d4:	20 1b       	sub	r11,1
800092d6:	fa f9 06 b4 	ld.w	r9,sp[1716]
800092da:	12 3b       	cp.w	r11,r9
800092dc:	c0 95       	brlt	800092ee <_vfprintf_r+0x25a>
800092de:	c1 08       	rjmp	800092fe <_vfprintf_r+0x26a>
800092e0:	fa f9 06 b4 	ld.w	r9,sp[1716]
800092e4:	ec ca ff ff 	sub	r10,r6,-1
800092e8:	12 36       	cp.w	r6,r9
800092ea:	c1 f5       	brlt	80009328 <_vfprintf_r+0x294>
800092ec:	c2 68       	rjmp	80009338 <_vfprintf_r+0x2a4>
800092ee:	fa ce f9 44 	sub	lr,sp,-1724
800092f2:	10 97       	mov	r7,r8
800092f4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800092f8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800092fc:	c3 58       	rjmp	80009366 <_vfprintf_r+0x2d2>
800092fe:	10 97       	mov	r7,r8
80009300:	fa c8 f9 50 	sub	r8,sp,-1712
80009304:	1a d8       	st.w	--sp,r8
80009306:	fa c8 fa b8 	sub	r8,sp,-1352
8000930a:	1a d8       	st.w	--sp,r8
8000930c:	fa c8 fb b4 	sub	r8,sp,-1100
80009310:	02 9a       	mov	r10,r1
80009312:	1a d8       	st.w	--sp,r8
80009314:	04 9c       	mov	r12,r2
80009316:	fa c8 f9 40 	sub	r8,sp,-1728
8000931a:	fa c9 ff b4 	sub	r9,sp,-76
8000931e:	fe b0 fd 23 	rcall	80008d64 <get_arg>
80009322:	2f dd       	sub	sp,-12
80009324:	78 00       	ld.w	r0,r12[0x0]
80009326:	c2 08       	rjmp	80009366 <_vfprintf_r+0x2d2>
80009328:	fa cc f9 44 	sub	r12,sp,-1724
8000932c:	14 96       	mov	r6,r10
8000932e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80009332:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80009336:	c1 88       	rjmp	80009366 <_vfprintf_r+0x2d2>
80009338:	41 08       	lddsp	r8,sp[0x40]
8000933a:	59 f9       	cp.w	r9,31
8000933c:	e0 89 00 11 	brgt	8000935e <_vfprintf_r+0x2ca>
80009340:	f0 cb ff fc 	sub	r11,r8,-4
80009344:	51 0b       	stdsp	sp[0x40],r11
80009346:	70 00       	ld.w	r0,r8[0x0]
80009348:	fa cb f9 44 	sub	r11,sp,-1724
8000934c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80009350:	f1 40 fd 88 	st.w	r8[-632],r0
80009354:	2f f9       	sub	r9,-1
80009356:	14 96       	mov	r6,r10
80009358:	fb 49 06 b4 	st.w	sp[1716],r9
8000935c:	c0 58       	rjmp	80009366 <_vfprintf_r+0x2d2>
8000935e:	70 00       	ld.w	r0,r8[0x0]
80009360:	14 96       	mov	r6,r10
80009362:	2f c8       	sub	r8,-4
80009364:	51 08       	stdsp	sp[0x40],r8
80009366:	58 00       	cp.w	r0,0
80009368:	fe 94 ff 76 	brge	80009254 <_vfprintf_r+0x1c0>
8000936c:	5c 30       	neg	r0
8000936e:	a3 a5       	sbr	r5,0x2
80009370:	c7 2b       	rjmp	80009254 <_vfprintf_r+0x1c0>
80009372:	32 b8       	mov	r8,43
80009374:	fb 68 06 bb 	st.b	sp[1723],r8
80009378:	c6 eb       	rjmp	80009254 <_vfprintf_r+0x1c0>
8000937a:	0f 38       	ld.ub	r8,r7++
8000937c:	e0 48 00 2a 	cp.w	r8,42
80009380:	c0 30       	breq	80009386 <_vfprintf_r+0x2f2>
80009382:	30 09       	mov	r9,0
80009384:	c7 98       	rjmp	80009476 <_vfprintf_r+0x3e2>
80009386:	0f 88       	ld.ub	r8,r7[0x0]
80009388:	f0 c9 00 30 	sub	r9,r8,48
8000938c:	58 99       	cp.w	r9,9
8000938e:	e0 8b 00 1f 	brhi	800093cc <_vfprintf_r+0x338>
80009392:	ee c4 ff ff 	sub	r4,r7,-1
80009396:	30 0b       	mov	r11,0
80009398:	23 08       	sub	r8,48
8000939a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000939e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800093a2:	09 38       	ld.ub	r8,r4++
800093a4:	f0 c9 00 30 	sub	r9,r8,48
800093a8:	58 99       	cp.w	r9,9
800093aa:	fe 98 ff f7 	brls	80009398 <_vfprintf_r+0x304>
800093ae:	e0 48 00 24 	cp.w	r8,36
800093b2:	fe 91 ff 4f 	brne	80009250 <_vfprintf_r+0x1bc>
800093b6:	e0 4b 00 20 	cp.w	r11,32
800093ba:	e0 89 0d eb 	brgt	8000af90 <_vfprintf_r+0x1efc>
800093be:	20 1b       	sub	r11,1
800093c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093c4:	10 3b       	cp.w	r11,r8
800093c6:	c0 a5       	brlt	800093da <_vfprintf_r+0x346>
800093c8:	c1 18       	rjmp	800093ea <_vfprintf_r+0x356>
800093ca:	d7 03       	nop
800093cc:	fa fa 06 b4 	ld.w	r10,sp[1716]
800093d0:	ec c9 ff ff 	sub	r9,r6,-1
800093d4:	14 36       	cp.w	r6,r10
800093d6:	c1 f5       	brlt	80009414 <_vfprintf_r+0x380>
800093d8:	c2 88       	rjmp	80009428 <_vfprintf_r+0x394>
800093da:	fa ca f9 44 	sub	r10,sp,-1724
800093de:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800093e2:	f6 fb fd 88 	ld.w	r11,r11[-632]
800093e6:	50 2b       	stdsp	sp[0x8],r11
800093e8:	c3 c8       	rjmp	80009460 <_vfprintf_r+0x3cc>
800093ea:	fa c8 f9 50 	sub	r8,sp,-1712
800093ee:	1a d8       	st.w	--sp,r8
800093f0:	fa c8 fa b8 	sub	r8,sp,-1352
800093f4:	1a d8       	st.w	--sp,r8
800093f6:	fa c8 fb b4 	sub	r8,sp,-1100
800093fa:	02 9a       	mov	r10,r1
800093fc:	1a d8       	st.w	--sp,r8
800093fe:	04 9c       	mov	r12,r2
80009400:	fa c8 f9 40 	sub	r8,sp,-1728
80009404:	fa c9 ff b4 	sub	r9,sp,-76
80009408:	fe b0 fc ae 	rcall	80008d64 <get_arg>
8000940c:	2f dd       	sub	sp,-12
8000940e:	78 0c       	ld.w	r12,r12[0x0]
80009410:	50 2c       	stdsp	sp[0x8],r12
80009412:	c2 78       	rjmp	80009460 <_vfprintf_r+0x3cc>
80009414:	12 96       	mov	r6,r9
80009416:	0e 94       	mov	r4,r7
80009418:	fa c9 f9 44 	sub	r9,sp,-1724
8000941c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80009420:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80009424:	50 28       	stdsp	sp[0x8],r8
80009426:	c1 d8       	rjmp	80009460 <_vfprintf_r+0x3cc>
80009428:	41 08       	lddsp	r8,sp[0x40]
8000942a:	59 fa       	cp.w	r10,31
8000942c:	e0 89 00 14 	brgt	80009454 <_vfprintf_r+0x3c0>
80009430:	f0 cb ff fc 	sub	r11,r8,-4
80009434:	70 08       	ld.w	r8,r8[0x0]
80009436:	51 0b       	stdsp	sp[0x40],r11
80009438:	50 28       	stdsp	sp[0x8],r8
8000943a:	fa c6 f9 44 	sub	r6,sp,-1724
8000943e:	40 2e       	lddsp	lr,sp[0x8]
80009440:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80009444:	f1 4e fd 88 	st.w	r8[-632],lr
80009448:	2f fa       	sub	r10,-1
8000944a:	0e 94       	mov	r4,r7
8000944c:	fb 4a 06 b4 	st.w	sp[1716],r10
80009450:	12 96       	mov	r6,r9
80009452:	c0 78       	rjmp	80009460 <_vfprintf_r+0x3cc>
80009454:	70 0c       	ld.w	r12,r8[0x0]
80009456:	0e 94       	mov	r4,r7
80009458:	2f c8       	sub	r8,-4
8000945a:	50 2c       	stdsp	sp[0x8],r12
8000945c:	12 96       	mov	r6,r9
8000945e:	51 08       	stdsp	sp[0x40],r8
80009460:	40 2b       	lddsp	r11,sp[0x8]
80009462:	58 0b       	cp.w	r11,0
80009464:	fe 95 fe f2 	brlt	80009248 <_vfprintf_r+0x1b4>
80009468:	08 97       	mov	r7,r4
8000946a:	cf 5a       	rjmp	80009254 <_vfprintf_r+0x1c0>
8000946c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009470:	0f 38       	ld.ub	r8,r7++
80009472:	f4 09 00 19 	add	r9,r10,r9<<0x1
80009476:	f0 ca 00 30 	sub	r10,r8,48
8000947a:	58 9a       	cp.w	r10,9
8000947c:	fe 98 ff f8 	brls	8000946c <_vfprintf_r+0x3d8>
80009480:	3f fa       	mov	r10,-1
80009482:	f2 0a 0c 49 	max	r9,r9,r10
80009486:	50 29       	stdsp	sp[0x8],r9
80009488:	ce 9a       	rjmp	8000925a <_vfprintf_r+0x1c6>
8000948a:	a7 b5       	sbr	r5,0x7
8000948c:	ce 4a       	rjmp	80009254 <_vfprintf_r+0x1c0>
8000948e:	30 09       	mov	r9,0
80009490:	23 08       	sub	r8,48
80009492:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009496:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000949a:	0f 38       	ld.ub	r8,r7++
8000949c:	f0 ca 00 30 	sub	r10,r8,48
800094a0:	58 9a       	cp.w	r10,9
800094a2:	fe 98 ff f7 	brls	80009490 <_vfprintf_r+0x3fc>
800094a6:	e0 48 00 24 	cp.w	r8,36
800094aa:	fe 91 fe d7 	brne	80009258 <_vfprintf_r+0x1c4>
800094ae:	e0 49 00 20 	cp.w	r9,32
800094b2:	e0 89 0d 6f 	brgt	8000af90 <_vfprintf_r+0x1efc>
800094b6:	f2 c3 00 01 	sub	r3,r9,1
800094ba:	30 19       	mov	r9,1
800094bc:	50 39       	stdsp	sp[0xc],r9
800094be:	cc ba       	rjmp	80009254 <_vfprintf_r+0x1c0>
800094c0:	a3 b5       	sbr	r5,0x3
800094c2:	cc 9a       	rjmp	80009254 <_vfprintf_r+0x1c0>
800094c4:	a7 a5       	sbr	r5,0x6
800094c6:	cc 7a       	rjmp	80009254 <_vfprintf_r+0x1c0>
800094c8:	0a 98       	mov	r8,r5
800094ca:	a5 b5       	sbr	r5,0x5
800094cc:	a5 a8       	sbr	r8,0x4
800094ce:	0f 89       	ld.ub	r9,r7[0x0]
800094d0:	36 ce       	mov	lr,108
800094d2:	fc 09 18 00 	cp.b	r9,lr
800094d6:	f7 b7 00 ff 	subeq	r7,-1
800094da:	f0 05 17 10 	movne	r5,r8
800094de:	cb ba       	rjmp	80009254 <_vfprintf_r+0x1c0>
800094e0:	a5 b5       	sbr	r5,0x5
800094e2:	cb 9a       	rjmp	80009254 <_vfprintf_r+0x1c0>
800094e4:	50 a7       	stdsp	sp[0x28],r7
800094e6:	50 80       	stdsp	sp[0x20],r0
800094e8:	0c 97       	mov	r7,r6
800094ea:	10 90       	mov	r0,r8
800094ec:	06 96       	mov	r6,r3
800094ee:	04 94       	mov	r4,r2
800094f0:	40 93       	lddsp	r3,sp[0x24]
800094f2:	02 92       	mov	r2,r1
800094f4:	0e 99       	mov	r9,r7
800094f6:	40 41       	lddsp	r1,sp[0x10]
800094f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094fc:	40 3c       	lddsp	r12,sp[0xc]
800094fe:	58 0c       	cp.w	r12,0
80009500:	c1 d0       	breq	8000953a <_vfprintf_r+0x4a6>
80009502:	10 36       	cp.w	r6,r8
80009504:	c0 64       	brge	80009510 <_vfprintf_r+0x47c>
80009506:	fa cb f9 44 	sub	r11,sp,-1724
8000950a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000950e:	c1 d8       	rjmp	80009548 <_vfprintf_r+0x4b4>
80009510:	fa c8 f9 50 	sub	r8,sp,-1712
80009514:	1a d8       	st.w	--sp,r8
80009516:	fa c8 fa b8 	sub	r8,sp,-1352
8000951a:	1a d8       	st.w	--sp,r8
8000951c:	fa c8 fb b4 	sub	r8,sp,-1100
80009520:	1a d8       	st.w	--sp,r8
80009522:	fa c8 f9 40 	sub	r8,sp,-1728
80009526:	fa c9 ff b4 	sub	r9,sp,-76
8000952a:	04 9a       	mov	r10,r2
8000952c:	0c 9b       	mov	r11,r6
8000952e:	08 9c       	mov	r12,r4
80009530:	fe b0 fc 1a 	rcall	80008d64 <get_arg>
80009534:	2f dd       	sub	sp,-12
80009536:	19 b8       	ld.ub	r8,r12[0x3]
80009538:	c2 28       	rjmp	8000957c <_vfprintf_r+0x4e8>
8000953a:	2f f7       	sub	r7,-1
8000953c:	10 39       	cp.w	r9,r8
8000953e:	c0 84       	brge	8000954e <_vfprintf_r+0x4ba>
80009540:	fa ca f9 44 	sub	r10,sp,-1724
80009544:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009548:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000954c:	c1 88       	rjmp	8000957c <_vfprintf_r+0x4e8>
8000954e:	41 09       	lddsp	r9,sp[0x40]
80009550:	59 f8       	cp.w	r8,31
80009552:	e0 89 00 12 	brgt	80009576 <_vfprintf_r+0x4e2>
80009556:	f2 ca ff fc 	sub	r10,r9,-4
8000955a:	51 0a       	stdsp	sp[0x40],r10
8000955c:	72 09       	ld.w	r9,r9[0x0]
8000955e:	fa c6 f9 44 	sub	r6,sp,-1724
80009562:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009566:	2f f8       	sub	r8,-1
80009568:	f5 49 fd 88 	st.w	r10[-632],r9
8000956c:	fb 48 06 b4 	st.w	sp[1716],r8
80009570:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80009574:	c0 48       	rjmp	8000957c <_vfprintf_r+0x4e8>
80009576:	13 b8       	ld.ub	r8,r9[0x3]
80009578:	2f c9       	sub	r9,-4
8000957a:	51 09       	stdsp	sp[0x40],r9
8000957c:	fb 68 06 60 	st.b	sp[1632],r8
80009580:	30 0e       	mov	lr,0
80009582:	30 08       	mov	r8,0
80009584:	30 12       	mov	r2,1
80009586:	fb 68 06 bb 	st.b	sp[1723],r8
8000958a:	50 2e       	stdsp	sp[0x8],lr
8000958c:	e0 8f 08 ad 	bral	8000a6e6 <_vfprintf_r+0x1652>
80009590:	50 a7       	stdsp	sp[0x28],r7
80009592:	50 80       	stdsp	sp[0x20],r0
80009594:	0c 97       	mov	r7,r6
80009596:	04 94       	mov	r4,r2
80009598:	06 96       	mov	r6,r3
8000959a:	02 92       	mov	r2,r1
8000959c:	40 93       	lddsp	r3,sp[0x24]
8000959e:	10 90       	mov	r0,r8
800095a0:	40 41       	lddsp	r1,sp[0x10]
800095a2:	a5 a5       	sbr	r5,0x4
800095a4:	c0 a8       	rjmp	800095b8 <_vfprintf_r+0x524>
800095a6:	50 a7       	stdsp	sp[0x28],r7
800095a8:	50 80       	stdsp	sp[0x20],r0
800095aa:	0c 97       	mov	r7,r6
800095ac:	04 94       	mov	r4,r2
800095ae:	06 96       	mov	r6,r3
800095b0:	02 92       	mov	r2,r1
800095b2:	40 93       	lddsp	r3,sp[0x24]
800095b4:	10 90       	mov	r0,r8
800095b6:	40 41       	lddsp	r1,sp[0x10]
800095b8:	ed b5 00 05 	bld	r5,0x5
800095bc:	c5 11       	brne	8000965e <_vfprintf_r+0x5ca>
800095be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095c2:	40 3c       	lddsp	r12,sp[0xc]
800095c4:	58 0c       	cp.w	r12,0
800095c6:	c1 e0       	breq	80009602 <_vfprintf_r+0x56e>
800095c8:	10 36       	cp.w	r6,r8
800095ca:	c0 64       	brge	800095d6 <_vfprintf_r+0x542>
800095cc:	fa cb f9 44 	sub	r11,sp,-1724
800095d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095d4:	c2 08       	rjmp	80009614 <_vfprintf_r+0x580>
800095d6:	fa c8 f9 50 	sub	r8,sp,-1712
800095da:	1a d8       	st.w	--sp,r8
800095dc:	fa c8 fa b8 	sub	r8,sp,-1352
800095e0:	0c 9b       	mov	r11,r6
800095e2:	1a d8       	st.w	--sp,r8
800095e4:	fa c8 fb b4 	sub	r8,sp,-1100
800095e8:	1a d8       	st.w	--sp,r8
800095ea:	fa c9 ff b4 	sub	r9,sp,-76
800095ee:	fa c8 f9 40 	sub	r8,sp,-1728
800095f2:	04 9a       	mov	r10,r2
800095f4:	08 9c       	mov	r12,r4
800095f6:	fe b0 fb b7 	rcall	80008d64 <get_arg>
800095fa:	2f dd       	sub	sp,-12
800095fc:	78 1b       	ld.w	r11,r12[0x4]
800095fe:	78 09       	ld.w	r9,r12[0x0]
80009600:	c2 b8       	rjmp	80009656 <_vfprintf_r+0x5c2>
80009602:	ee ca ff ff 	sub	r10,r7,-1
80009606:	10 37       	cp.w	r7,r8
80009608:	c0 b4       	brge	8000961e <_vfprintf_r+0x58a>
8000960a:	fa c9 f9 44 	sub	r9,sp,-1724
8000960e:	14 97       	mov	r7,r10
80009610:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009614:	ec fb fd 8c 	ld.w	r11,r6[-628]
80009618:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000961c:	c1 d8       	rjmp	80009656 <_vfprintf_r+0x5c2>
8000961e:	41 09       	lddsp	r9,sp[0x40]
80009620:	59 f8       	cp.w	r8,31
80009622:	e0 89 00 14 	brgt	8000964a <_vfprintf_r+0x5b6>
80009626:	f2 cb ff f8 	sub	r11,r9,-8
8000962a:	51 0b       	stdsp	sp[0x40],r11
8000962c:	fa c6 f9 44 	sub	r6,sp,-1724
80009630:	72 1b       	ld.w	r11,r9[0x4]
80009632:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80009636:	72 09       	ld.w	r9,r9[0x0]
80009638:	f9 4b fd 8c 	st.w	r12[-628],r11
8000963c:	f9 49 fd 88 	st.w	r12[-632],r9
80009640:	2f f8       	sub	r8,-1
80009642:	14 97       	mov	r7,r10
80009644:	fb 48 06 b4 	st.w	sp[1716],r8
80009648:	c0 78       	rjmp	80009656 <_vfprintf_r+0x5c2>
8000964a:	f2 c8 ff f8 	sub	r8,r9,-8
8000964e:	72 1b       	ld.w	r11,r9[0x4]
80009650:	14 97       	mov	r7,r10
80009652:	51 08       	stdsp	sp[0x40],r8
80009654:	72 09       	ld.w	r9,r9[0x0]
80009656:	16 98       	mov	r8,r11
80009658:	fa e9 00 00 	st.d	sp[0],r8
8000965c:	ca e8       	rjmp	800097b8 <_vfprintf_r+0x724>
8000965e:	ed b5 00 04 	bld	r5,0x4
80009662:	c1 71       	brne	80009690 <_vfprintf_r+0x5fc>
80009664:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009668:	40 3e       	lddsp	lr,sp[0xc]
8000966a:	58 0e       	cp.w	lr,0
8000966c:	c0 80       	breq	8000967c <_vfprintf_r+0x5e8>
8000966e:	10 36       	cp.w	r6,r8
80009670:	c6 94       	brge	80009742 <_vfprintf_r+0x6ae>
80009672:	fa cc f9 44 	sub	r12,sp,-1724
80009676:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000967a:	c8 28       	rjmp	8000977e <_vfprintf_r+0x6ea>
8000967c:	ee ca ff ff 	sub	r10,r7,-1
80009680:	10 37       	cp.w	r7,r8
80009682:	e0 84 00 81 	brge	80009784 <_vfprintf_r+0x6f0>
80009686:	fa cb f9 44 	sub	r11,sp,-1724
8000968a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000968e:	c7 78       	rjmp	8000977c <_vfprintf_r+0x6e8>
80009690:	ed b5 00 06 	bld	r5,0x6
80009694:	c4 b1       	brne	8000972a <_vfprintf_r+0x696>
80009696:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000969a:	40 3c       	lddsp	r12,sp[0xc]
8000969c:	58 0c       	cp.w	r12,0
8000969e:	c1 d0       	breq	800096d8 <_vfprintf_r+0x644>
800096a0:	10 36       	cp.w	r6,r8
800096a2:	c0 64       	brge	800096ae <_vfprintf_r+0x61a>
800096a4:	fa cb f9 44 	sub	r11,sp,-1724
800096a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096ac:	c1 f8       	rjmp	800096ea <_vfprintf_r+0x656>
800096ae:	fa c8 f9 50 	sub	r8,sp,-1712
800096b2:	1a d8       	st.w	--sp,r8
800096b4:	fa c8 fa b8 	sub	r8,sp,-1352
800096b8:	1a d8       	st.w	--sp,r8
800096ba:	fa c8 fb b4 	sub	r8,sp,-1100
800096be:	1a d8       	st.w	--sp,r8
800096c0:	fa c8 f9 40 	sub	r8,sp,-1728
800096c4:	fa c9 ff b4 	sub	r9,sp,-76
800096c8:	04 9a       	mov	r10,r2
800096ca:	0c 9b       	mov	r11,r6
800096cc:	08 9c       	mov	r12,r4
800096ce:	fe b0 fb 4b 	rcall	80008d64 <get_arg>
800096d2:	2f dd       	sub	sp,-12
800096d4:	98 18       	ld.sh	r8,r12[0x2]
800096d6:	c2 68       	rjmp	80009722 <_vfprintf_r+0x68e>
800096d8:	ee ca ff ff 	sub	r10,r7,-1
800096dc:	10 37       	cp.w	r7,r8
800096de:	c0 94       	brge	800096f0 <_vfprintf_r+0x65c>
800096e0:	fa c9 f9 44 	sub	r9,sp,-1724
800096e4:	14 97       	mov	r7,r10
800096e6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096ea:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800096ee:	c1 a8       	rjmp	80009722 <_vfprintf_r+0x68e>
800096f0:	41 09       	lddsp	r9,sp[0x40]
800096f2:	59 f8       	cp.w	r8,31
800096f4:	e0 89 00 13 	brgt	8000971a <_vfprintf_r+0x686>
800096f8:	f2 cb ff fc 	sub	r11,r9,-4
800096fc:	51 0b       	stdsp	sp[0x40],r11
800096fe:	72 09       	ld.w	r9,r9[0x0]
80009700:	fa c6 f9 44 	sub	r6,sp,-1724
80009704:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009708:	2f f8       	sub	r8,-1
8000970a:	f7 49 fd 88 	st.w	r11[-632],r9
8000970e:	fb 48 06 b4 	st.w	sp[1716],r8
80009712:	14 97       	mov	r7,r10
80009714:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009718:	c0 58       	rjmp	80009722 <_vfprintf_r+0x68e>
8000971a:	92 18       	ld.sh	r8,r9[0x2]
8000971c:	14 97       	mov	r7,r10
8000971e:	2f c9       	sub	r9,-4
80009720:	51 09       	stdsp	sp[0x40],r9
80009722:	50 18       	stdsp	sp[0x4],r8
80009724:	bf 58       	asr	r8,0x1f
80009726:	50 08       	stdsp	sp[0x0],r8
80009728:	c4 88       	rjmp	800097b8 <_vfprintf_r+0x724>
8000972a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000972e:	40 3c       	lddsp	r12,sp[0xc]
80009730:	58 0c       	cp.w	r12,0
80009732:	c1 d0       	breq	8000976c <_vfprintf_r+0x6d8>
80009734:	10 36       	cp.w	r6,r8
80009736:	c0 64       	brge	80009742 <_vfprintf_r+0x6ae>
80009738:	fa cb f9 44 	sub	r11,sp,-1724
8000973c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009740:	c1 f8       	rjmp	8000977e <_vfprintf_r+0x6ea>
80009742:	fa c8 f9 50 	sub	r8,sp,-1712
80009746:	1a d8       	st.w	--sp,r8
80009748:	fa c8 fa b8 	sub	r8,sp,-1352
8000974c:	0c 9b       	mov	r11,r6
8000974e:	1a d8       	st.w	--sp,r8
80009750:	fa c8 fb b4 	sub	r8,sp,-1100
80009754:	04 9a       	mov	r10,r2
80009756:	1a d8       	st.w	--sp,r8
80009758:	08 9c       	mov	r12,r4
8000975a:	fa c8 f9 40 	sub	r8,sp,-1728
8000975e:	fa c9 ff b4 	sub	r9,sp,-76
80009762:	fe b0 fb 01 	rcall	80008d64 <get_arg>
80009766:	2f dd       	sub	sp,-12
80009768:	78 0b       	ld.w	r11,r12[0x0]
8000976a:	c2 48       	rjmp	800097b2 <_vfprintf_r+0x71e>
8000976c:	ee ca ff ff 	sub	r10,r7,-1
80009770:	10 37       	cp.w	r7,r8
80009772:	c0 94       	brge	80009784 <_vfprintf_r+0x6f0>
80009774:	fa c9 f9 44 	sub	r9,sp,-1724
80009778:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000977c:	14 97       	mov	r7,r10
8000977e:	ec fb fd 88 	ld.w	r11,r6[-632]
80009782:	c1 88       	rjmp	800097b2 <_vfprintf_r+0x71e>
80009784:	41 09       	lddsp	r9,sp[0x40]
80009786:	59 f8       	cp.w	r8,31
80009788:	e0 89 00 11 	brgt	800097aa <_vfprintf_r+0x716>
8000978c:	f2 cb ff fc 	sub	r11,r9,-4
80009790:	51 0b       	stdsp	sp[0x40],r11
80009792:	fa c6 f9 44 	sub	r6,sp,-1724
80009796:	72 0b       	ld.w	r11,r9[0x0]
80009798:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000979c:	f3 4b fd 88 	st.w	r9[-632],r11
800097a0:	2f f8       	sub	r8,-1
800097a2:	14 97       	mov	r7,r10
800097a4:	fb 48 06 b4 	st.w	sp[1716],r8
800097a8:	c0 58       	rjmp	800097b2 <_vfprintf_r+0x71e>
800097aa:	72 0b       	ld.w	r11,r9[0x0]
800097ac:	14 97       	mov	r7,r10
800097ae:	2f c9       	sub	r9,-4
800097b0:	51 09       	stdsp	sp[0x40],r9
800097b2:	50 1b       	stdsp	sp[0x4],r11
800097b4:	bf 5b       	asr	r11,0x1f
800097b6:	50 0b       	stdsp	sp[0x0],r11
800097b8:	fa ea 00 00 	ld.d	r10,sp[0]
800097bc:	58 0a       	cp.w	r10,0
800097be:	5c 2b       	cpc	r11
800097c0:	c0 e4       	brge	800097dc <_vfprintf_r+0x748>
800097c2:	30 08       	mov	r8,0
800097c4:	fa ea 00 00 	ld.d	r10,sp[0]
800097c8:	30 09       	mov	r9,0
800097ca:	f0 0a 01 0a 	sub	r10,r8,r10
800097ce:	f2 0b 01 4b 	sbc	r11,r9,r11
800097d2:	32 d8       	mov	r8,45
800097d4:	fa eb 00 00 	st.d	sp[0],r10
800097d8:	fb 68 06 bb 	st.b	sp[1723],r8
800097dc:	30 18       	mov	r8,1
800097de:	e0 8f 06 fa 	bral	8000a5d2 <_vfprintf_r+0x153e>
800097e2:	50 a7       	stdsp	sp[0x28],r7
800097e4:	50 80       	stdsp	sp[0x20],r0
800097e6:	0c 97       	mov	r7,r6
800097e8:	04 94       	mov	r4,r2
800097ea:	06 96       	mov	r6,r3
800097ec:	02 92       	mov	r2,r1
800097ee:	40 93       	lddsp	r3,sp[0x24]
800097f0:	10 90       	mov	r0,r8
800097f2:	40 41       	lddsp	r1,sp[0x10]
800097f4:	0e 99       	mov	r9,r7
800097f6:	ed b5 00 03 	bld	r5,0x3
800097fa:	c4 11       	brne	8000987c <_vfprintf_r+0x7e8>
800097fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009800:	40 3a       	lddsp	r10,sp[0xc]
80009802:	58 0a       	cp.w	r10,0
80009804:	c1 90       	breq	80009836 <_vfprintf_r+0x7a2>
80009806:	10 36       	cp.w	r6,r8
80009808:	c6 45       	brlt	800098d0 <_vfprintf_r+0x83c>
8000980a:	fa c8 f9 50 	sub	r8,sp,-1712
8000980e:	1a d8       	st.w	--sp,r8
80009810:	fa c8 fa b8 	sub	r8,sp,-1352
80009814:	1a d8       	st.w	--sp,r8
80009816:	fa c8 fb b4 	sub	r8,sp,-1100
8000981a:	0c 9b       	mov	r11,r6
8000981c:	1a d8       	st.w	--sp,r8
8000981e:	04 9a       	mov	r10,r2
80009820:	fa c8 f9 40 	sub	r8,sp,-1728
80009824:	fa c9 ff b4 	sub	r9,sp,-76
80009828:	08 9c       	mov	r12,r4
8000982a:	fe b0 fa 9d 	rcall	80008d64 <get_arg>
8000982e:	2f dd       	sub	sp,-12
80009830:	78 16       	ld.w	r6,r12[0x4]
80009832:	50 76       	stdsp	sp[0x1c],r6
80009834:	c4 88       	rjmp	800098c4 <_vfprintf_r+0x830>
80009836:	2f f7       	sub	r7,-1
80009838:	10 39       	cp.w	r9,r8
8000983a:	c0 c4       	brge	80009852 <_vfprintf_r+0x7be>
8000983c:	fa ce f9 44 	sub	lr,sp,-1724
80009840:	fc 06 00 36 	add	r6,lr,r6<<0x3
80009844:	ec fc fd 8c 	ld.w	r12,r6[-628]
80009848:	50 7c       	stdsp	sp[0x1c],r12
8000984a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000984e:	50 56       	stdsp	sp[0x14],r6
80009850:	c6 68       	rjmp	8000991c <_vfprintf_r+0x888>
80009852:	41 09       	lddsp	r9,sp[0x40]
80009854:	59 f8       	cp.w	r8,31
80009856:	e0 89 00 10 	brgt	80009876 <_vfprintf_r+0x7e2>
8000985a:	f2 ca ff f8 	sub	r10,r9,-8
8000985e:	72 1b       	ld.w	r11,r9[0x4]
80009860:	51 0a       	stdsp	sp[0x40],r10
80009862:	72 09       	ld.w	r9,r9[0x0]
80009864:	fa ca f9 44 	sub	r10,sp,-1724
80009868:	50 7b       	stdsp	sp[0x1c],r11
8000986a:	50 59       	stdsp	sp[0x14],r9
8000986c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009870:	40 5b       	lddsp	r11,sp[0x14]
80009872:	40 7a       	lddsp	r10,sp[0x1c]
80009874:	c4 78       	rjmp	80009902 <_vfprintf_r+0x86e>
80009876:	72 18       	ld.w	r8,r9[0x4]
80009878:	50 78       	stdsp	sp[0x1c],r8
8000987a:	c4 c8       	rjmp	80009912 <_vfprintf_r+0x87e>
8000987c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009880:	40 3e       	lddsp	lr,sp[0xc]
80009882:	58 0e       	cp.w	lr,0
80009884:	c2 30       	breq	800098ca <_vfprintf_r+0x836>
80009886:	10 36       	cp.w	r6,r8
80009888:	c0 94       	brge	8000989a <_vfprintf_r+0x806>
8000988a:	fa cc f9 44 	sub	r12,sp,-1724
8000988e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009892:	ec fb fd 8c 	ld.w	r11,r6[-628]
80009896:	50 7b       	stdsp	sp[0x1c],r11
80009898:	cd 9b       	rjmp	8000984a <_vfprintf_r+0x7b6>
8000989a:	fa c8 f9 50 	sub	r8,sp,-1712
8000989e:	1a d8       	st.w	--sp,r8
800098a0:	fa c8 fa b8 	sub	r8,sp,-1352
800098a4:	04 9a       	mov	r10,r2
800098a6:	1a d8       	st.w	--sp,r8
800098a8:	fa c8 fb b4 	sub	r8,sp,-1100
800098ac:	0c 9b       	mov	r11,r6
800098ae:	1a d8       	st.w	--sp,r8
800098b0:	08 9c       	mov	r12,r4
800098b2:	fa c8 f9 40 	sub	r8,sp,-1728
800098b6:	fa c9 ff b4 	sub	r9,sp,-76
800098ba:	fe b0 fa 55 	rcall	80008d64 <get_arg>
800098be:	2f dd       	sub	sp,-12
800098c0:	78 1a       	ld.w	r10,r12[0x4]
800098c2:	50 7a       	stdsp	sp[0x1c],r10
800098c4:	78 0c       	ld.w	r12,r12[0x0]
800098c6:	50 5c       	stdsp	sp[0x14],r12
800098c8:	c2 a8       	rjmp	8000991c <_vfprintf_r+0x888>
800098ca:	2f f7       	sub	r7,-1
800098cc:	10 39       	cp.w	r9,r8
800098ce:	c0 94       	brge	800098e0 <_vfprintf_r+0x84c>
800098d0:	fa c9 f9 44 	sub	r9,sp,-1724
800098d4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800098d8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800098dc:	50 78       	stdsp	sp[0x1c],r8
800098de:	cb 6b       	rjmp	8000984a <_vfprintf_r+0x7b6>
800098e0:	41 09       	lddsp	r9,sp[0x40]
800098e2:	59 f8       	cp.w	r8,31
800098e4:	e0 89 00 15 	brgt	8000990e <_vfprintf_r+0x87a>
800098e8:	f2 ca ff f8 	sub	r10,r9,-8
800098ec:	72 16       	ld.w	r6,r9[0x4]
800098ee:	72 09       	ld.w	r9,r9[0x0]
800098f0:	51 0a       	stdsp	sp[0x40],r10
800098f2:	50 59       	stdsp	sp[0x14],r9
800098f4:	fa ce f9 44 	sub	lr,sp,-1724
800098f8:	50 76       	stdsp	sp[0x1c],r6
800098fa:	fc 08 00 39 	add	r9,lr,r8<<0x3
800098fe:	40 5b       	lddsp	r11,sp[0x14]
80009900:	0c 9a       	mov	r10,r6
80009902:	f2 eb fd 88 	st.d	r9[-632],r10
80009906:	2f f8       	sub	r8,-1
80009908:	fb 48 06 b4 	st.w	sp[1716],r8
8000990c:	c0 88       	rjmp	8000991c <_vfprintf_r+0x888>
8000990e:	72 1c       	ld.w	r12,r9[0x4]
80009910:	50 7c       	stdsp	sp[0x1c],r12
80009912:	f2 c8 ff f8 	sub	r8,r9,-8
80009916:	51 08       	stdsp	sp[0x40],r8
80009918:	72 09       	ld.w	r9,r9[0x0]
8000991a:	50 59       	stdsp	sp[0x14],r9
8000991c:	40 5b       	lddsp	r11,sp[0x14]
8000991e:	40 7a       	lddsp	r10,sp[0x1c]
80009920:	e0 a0 19 54 	rcall	8000cbc8 <__isinfd>
80009924:	18 96       	mov	r6,r12
80009926:	c1 70       	breq	80009954 <_vfprintf_r+0x8c0>
80009928:	30 08       	mov	r8,0
8000992a:	30 09       	mov	r9,0
8000992c:	40 5b       	lddsp	r11,sp[0x14]
8000992e:	40 7a       	lddsp	r10,sp[0x1c]
80009930:	e0 a0 1d b4 	rcall	8000d498 <__avr32_f64_cmp_lt>
80009934:	c0 40       	breq	8000993c <_vfprintf_r+0x8a8>
80009936:	32 d8       	mov	r8,45
80009938:	fb 68 06 bb 	st.b	sp[1723],r8
8000993c:	fe c8 a6 10 	sub	r8,pc,-23024
80009940:	fe c6 a6 10 	sub	r6,pc,-23024
80009944:	a7 d5       	cbr	r5,0x7
80009946:	e0 40 00 47 	cp.w	r0,71
8000994a:	f0 06 17 a0 	movle	r6,r8
8000994e:	30 32       	mov	r2,3
80009950:	e0 8f 06 ce 	bral	8000a6ec <_vfprintf_r+0x1658>
80009954:	40 5b       	lddsp	r11,sp[0x14]
80009956:	40 7a       	lddsp	r10,sp[0x1c]
80009958:	e0 a0 19 4d 	rcall	8000cbf2 <__isnand>
8000995c:	c0 e0       	breq	80009978 <_vfprintf_r+0x8e4>
8000995e:	50 26       	stdsp	sp[0x8],r6
80009960:	fe c8 a6 2c 	sub	r8,pc,-22996
80009964:	fe c6 a6 2c 	sub	r6,pc,-22996
80009968:	a7 d5       	cbr	r5,0x7
8000996a:	e0 40 00 47 	cp.w	r0,71
8000996e:	f0 06 17 a0 	movle	r6,r8
80009972:	30 32       	mov	r2,3
80009974:	e0 8f 06 c2 	bral	8000a6f8 <_vfprintf_r+0x1664>
80009978:	40 2a       	lddsp	r10,sp[0x8]
8000997a:	5b fa       	cp.w	r10,-1
8000997c:	c0 41       	brne	80009984 <_vfprintf_r+0x8f0>
8000997e:	30 69       	mov	r9,6
80009980:	50 29       	stdsp	sp[0x8],r9
80009982:	c1 18       	rjmp	800099a4 <_vfprintf_r+0x910>
80009984:	e0 40 00 47 	cp.w	r0,71
80009988:	5f 09       	sreq	r9
8000998a:	e0 40 00 67 	cp.w	r0,103
8000998e:	5f 08       	sreq	r8
80009990:	f3 e8 10 08 	or	r8,r9,r8
80009994:	f8 08 18 00 	cp.b	r8,r12
80009998:	c0 60       	breq	800099a4 <_vfprintf_r+0x910>
8000999a:	40 28       	lddsp	r8,sp[0x8]
8000999c:	58 08       	cp.w	r8,0
8000999e:	f9 b8 00 01 	moveq	r8,1
800099a2:	50 28       	stdsp	sp[0x8],r8
800099a4:	40 78       	lddsp	r8,sp[0x1c]
800099a6:	40 59       	lddsp	r9,sp[0x14]
800099a8:	fa e9 06 94 	st.d	sp[1684],r8
800099ac:	a9 a5       	sbr	r5,0x8
800099ae:	fa f8 06 94 	ld.w	r8,sp[1684]
800099b2:	58 08       	cp.w	r8,0
800099b4:	c0 65       	brlt	800099c0 <_vfprintf_r+0x92c>
800099b6:	40 5e       	lddsp	lr,sp[0x14]
800099b8:	30 0c       	mov	r12,0
800099ba:	50 6e       	stdsp	sp[0x18],lr
800099bc:	50 9c       	stdsp	sp[0x24],r12
800099be:	c0 78       	rjmp	800099cc <_vfprintf_r+0x938>
800099c0:	40 5b       	lddsp	r11,sp[0x14]
800099c2:	32 da       	mov	r10,45
800099c4:	ee 1b 80 00 	eorh	r11,0x8000
800099c8:	50 9a       	stdsp	sp[0x24],r10
800099ca:	50 6b       	stdsp	sp[0x18],r11
800099cc:	e0 40 00 46 	cp.w	r0,70
800099d0:	5f 09       	sreq	r9
800099d2:	e0 40 00 66 	cp.w	r0,102
800099d6:	5f 08       	sreq	r8
800099d8:	f3 e8 10 08 	or	r8,r9,r8
800099dc:	50 48       	stdsp	sp[0x10],r8
800099de:	c0 40       	breq	800099e6 <_vfprintf_r+0x952>
800099e0:	40 22       	lddsp	r2,sp[0x8]
800099e2:	30 39       	mov	r9,3
800099e4:	c1 08       	rjmp	80009a04 <_vfprintf_r+0x970>
800099e6:	e0 40 00 45 	cp.w	r0,69
800099ea:	5f 09       	sreq	r9
800099ec:	e0 40 00 65 	cp.w	r0,101
800099f0:	5f 08       	sreq	r8
800099f2:	40 22       	lddsp	r2,sp[0x8]
800099f4:	10 49       	or	r9,r8
800099f6:	2f f2       	sub	r2,-1
800099f8:	40 46       	lddsp	r6,sp[0x10]
800099fa:	ec 09 18 00 	cp.b	r9,r6
800099fe:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80009a02:	30 29       	mov	r9,2
80009a04:	fa c8 f9 5c 	sub	r8,sp,-1700
80009a08:	1a d8       	st.w	--sp,r8
80009a0a:	fa c8 f9 54 	sub	r8,sp,-1708
80009a0e:	1a d8       	st.w	--sp,r8
80009a10:	fa c8 f9 4c 	sub	r8,sp,-1716
80009a14:	08 9c       	mov	r12,r4
80009a16:	1a d8       	st.w	--sp,r8
80009a18:	04 98       	mov	r8,r2
80009a1a:	40 9b       	lddsp	r11,sp[0x24]
80009a1c:	40 aa       	lddsp	r10,sp[0x28]
80009a1e:	e0 a0 0b c3 	rcall	8000b1a4 <_dtoa_r>
80009a22:	e0 40 00 47 	cp.w	r0,71
80009a26:	5f 19       	srne	r9
80009a28:	e0 40 00 67 	cp.w	r0,103
80009a2c:	5f 18       	srne	r8
80009a2e:	18 96       	mov	r6,r12
80009a30:	2f dd       	sub	sp,-12
80009a32:	f3 e8 00 08 	and	r8,r9,r8
80009a36:	c0 41       	brne	80009a3e <_vfprintf_r+0x9aa>
80009a38:	ed b5 00 00 	bld	r5,0x0
80009a3c:	c3 01       	brne	80009a9c <_vfprintf_r+0xa08>
80009a3e:	ec 02 00 0e 	add	lr,r6,r2
80009a42:	50 3e       	stdsp	sp[0xc],lr
80009a44:	40 4c       	lddsp	r12,sp[0x10]
80009a46:	58 0c       	cp.w	r12,0
80009a48:	c1 50       	breq	80009a72 <_vfprintf_r+0x9de>
80009a4a:	0d 89       	ld.ub	r9,r6[0x0]
80009a4c:	33 08       	mov	r8,48
80009a4e:	f0 09 18 00 	cp.b	r9,r8
80009a52:	c0 b1       	brne	80009a68 <_vfprintf_r+0x9d4>
80009a54:	30 08       	mov	r8,0
80009a56:	30 09       	mov	r9,0
80009a58:	40 6b       	lddsp	r11,sp[0x18]
80009a5a:	40 7a       	lddsp	r10,sp[0x1c]
80009a5c:	e0 a0 1c d7 	rcall	8000d40a <__avr32_f64_cmp_eq>
80009a60:	fb b2 00 01 	rsubeq	r2,1
80009a64:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80009a68:	40 3b       	lddsp	r11,sp[0xc]
80009a6a:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a6e:	10 0b       	add	r11,r8
80009a70:	50 3b       	stdsp	sp[0xc],r11
80009a72:	40 6b       	lddsp	r11,sp[0x18]
80009a74:	30 08       	mov	r8,0
80009a76:	30 09       	mov	r9,0
80009a78:	40 7a       	lddsp	r10,sp[0x1c]
80009a7a:	e0 a0 1c c8 	rcall	8000d40a <__avr32_f64_cmp_eq>
80009a7e:	c0 90       	breq	80009a90 <_vfprintf_r+0x9fc>
80009a80:	40 3a       	lddsp	r10,sp[0xc]
80009a82:	fb 4a 06 a4 	st.w	sp[1700],r10
80009a86:	c0 58       	rjmp	80009a90 <_vfprintf_r+0x9fc>
80009a88:	10 c9       	st.b	r8++,r9
80009a8a:	fb 48 06 a4 	st.w	sp[1700],r8
80009a8e:	c0 28       	rjmp	80009a92 <_vfprintf_r+0x9fe>
80009a90:	33 09       	mov	r9,48
80009a92:	fa f8 06 a4 	ld.w	r8,sp[1700]
80009a96:	40 3e       	lddsp	lr,sp[0xc]
80009a98:	1c 38       	cp.w	r8,lr
80009a9a:	cf 73       	brcs	80009a88 <_vfprintf_r+0x9f4>
80009a9c:	e0 40 00 47 	cp.w	r0,71
80009aa0:	5f 09       	sreq	r9
80009aa2:	e0 40 00 67 	cp.w	r0,103
80009aa6:	5f 08       	sreq	r8
80009aa8:	f3 e8 10 08 	or	r8,r9,r8
80009aac:	fa f9 06 a4 	ld.w	r9,sp[1700]
80009ab0:	0c 19       	sub	r9,r6
80009ab2:	50 69       	stdsp	sp[0x18],r9
80009ab4:	58 08       	cp.w	r8,0
80009ab6:	c0 b0       	breq	80009acc <_vfprintf_r+0xa38>
80009ab8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009abc:	5b d8       	cp.w	r8,-3
80009abe:	c0 55       	brlt	80009ac8 <_vfprintf_r+0xa34>
80009ac0:	40 2c       	lddsp	r12,sp[0x8]
80009ac2:	18 38       	cp.w	r8,r12
80009ac4:	e0 8a 00 6a 	brle	80009b98 <_vfprintf_r+0xb04>
80009ac8:	20 20       	sub	r0,2
80009aca:	c0 58       	rjmp	80009ad4 <_vfprintf_r+0xa40>
80009acc:	e0 40 00 65 	cp.w	r0,101
80009ad0:	e0 89 00 46 	brgt	80009b5c <_vfprintf_r+0xac8>
80009ad4:	fa fb 06 ac 	ld.w	r11,sp[1708]
80009ad8:	fb 60 06 9c 	st.b	sp[1692],r0
80009adc:	20 1b       	sub	r11,1
80009ade:	fb 4b 06 ac 	st.w	sp[1708],r11
80009ae2:	c0 47       	brpl	80009aea <_vfprintf_r+0xa56>
80009ae4:	5c 3b       	neg	r11
80009ae6:	32 d8       	mov	r8,45
80009ae8:	c0 28       	rjmp	80009aec <_vfprintf_r+0xa58>
80009aea:	32 b8       	mov	r8,43
80009aec:	fb 68 06 9d 	st.b	sp[1693],r8
80009af0:	58 9b       	cp.w	r11,9
80009af2:	e0 8a 00 1d 	brle	80009b2c <_vfprintf_r+0xa98>
80009af6:	fa c9 fa 35 	sub	r9,sp,-1483
80009afa:	30 aa       	mov	r10,10
80009afc:	12 98       	mov	r8,r9
80009afe:	0e 9c       	mov	r12,r7
80009b00:	0c 92       	mov	r2,r6
80009b02:	f6 0a 0c 06 	divs	r6,r11,r10
80009b06:	0e 9b       	mov	r11,r7
80009b08:	2d 0b       	sub	r11,-48
80009b0a:	10 fb       	st.b	--r8,r11
80009b0c:	0c 9b       	mov	r11,r6
80009b0e:	58 96       	cp.w	r6,9
80009b10:	fe 99 ff f9 	brgt	80009b02 <_vfprintf_r+0xa6e>
80009b14:	2d 0b       	sub	r11,-48
80009b16:	18 97       	mov	r7,r12
80009b18:	04 96       	mov	r6,r2
80009b1a:	10 fb       	st.b	--r8,r11
80009b1c:	fa ca f9 62 	sub	r10,sp,-1694
80009b20:	c0 38       	rjmp	80009b26 <_vfprintf_r+0xa92>
80009b22:	11 3b       	ld.ub	r11,r8++
80009b24:	14 cb       	st.b	r10++,r11
80009b26:	12 38       	cp.w	r8,r9
80009b28:	cf d3       	brcs	80009b22 <_vfprintf_r+0xa8e>
80009b2a:	c0 98       	rjmp	80009b3c <_vfprintf_r+0xaa8>
80009b2c:	2d 0b       	sub	r11,-48
80009b2e:	33 08       	mov	r8,48
80009b30:	fb 6b 06 9f 	st.b	sp[1695],r11
80009b34:	fb 68 06 9e 	st.b	sp[1694],r8
80009b38:	fa ca f9 60 	sub	r10,sp,-1696
80009b3c:	fa c8 f9 64 	sub	r8,sp,-1692
80009b40:	f4 08 01 08 	sub	r8,r10,r8
80009b44:	50 e8       	stdsp	sp[0x38],r8
80009b46:	10 92       	mov	r2,r8
80009b48:	40 6b       	lddsp	r11,sp[0x18]
80009b4a:	16 02       	add	r2,r11
80009b4c:	58 1b       	cp.w	r11,1
80009b4e:	e0 89 00 05 	brgt	80009b58 <_vfprintf_r+0xac4>
80009b52:	ed b5 00 00 	bld	r5,0x0
80009b56:	c3 51       	brne	80009bc0 <_vfprintf_r+0xb2c>
80009b58:	2f f2       	sub	r2,-1
80009b5a:	c3 38       	rjmp	80009bc0 <_vfprintf_r+0xb2c>
80009b5c:	e0 40 00 66 	cp.w	r0,102
80009b60:	c1 c1       	brne	80009b98 <_vfprintf_r+0xb04>
80009b62:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b66:	58 02       	cp.w	r2,0
80009b68:	e0 8a 00 0c 	brle	80009b80 <_vfprintf_r+0xaec>
80009b6c:	40 2a       	lddsp	r10,sp[0x8]
80009b6e:	58 0a       	cp.w	r10,0
80009b70:	c0 41       	brne	80009b78 <_vfprintf_r+0xae4>
80009b72:	ed b5 00 00 	bld	r5,0x0
80009b76:	c2 51       	brne	80009bc0 <_vfprintf_r+0xb2c>
80009b78:	2f f2       	sub	r2,-1
80009b7a:	40 29       	lddsp	r9,sp[0x8]
80009b7c:	12 02       	add	r2,r9
80009b7e:	c0 b8       	rjmp	80009b94 <_vfprintf_r+0xb00>
80009b80:	40 28       	lddsp	r8,sp[0x8]
80009b82:	58 08       	cp.w	r8,0
80009b84:	c0 61       	brne	80009b90 <_vfprintf_r+0xafc>
80009b86:	ed b5 00 00 	bld	r5,0x0
80009b8a:	c0 30       	breq	80009b90 <_vfprintf_r+0xafc>
80009b8c:	30 12       	mov	r2,1
80009b8e:	c1 98       	rjmp	80009bc0 <_vfprintf_r+0xb2c>
80009b90:	40 22       	lddsp	r2,sp[0x8]
80009b92:	2f e2       	sub	r2,-2
80009b94:	36 60       	mov	r0,102
80009b96:	c1 58       	rjmp	80009bc0 <_vfprintf_r+0xb2c>
80009b98:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b9c:	40 6e       	lddsp	lr,sp[0x18]
80009b9e:	1c 32       	cp.w	r2,lr
80009ba0:	c0 65       	brlt	80009bac <_vfprintf_r+0xb18>
80009ba2:	ed b5 00 00 	bld	r5,0x0
80009ba6:	f7 b2 00 ff 	subeq	r2,-1
80009baa:	c0 a8       	rjmp	80009bbe <_vfprintf_r+0xb2a>
80009bac:	e4 08 11 02 	rsub	r8,r2,2
80009bb0:	40 6c       	lddsp	r12,sp[0x18]
80009bb2:	58 02       	cp.w	r2,0
80009bb4:	f0 02 17 a0 	movle	r2,r8
80009bb8:	f9 b2 09 01 	movgt	r2,1
80009bbc:	18 02       	add	r2,r12
80009bbe:	36 70       	mov	r0,103
80009bc0:	40 9b       	lddsp	r11,sp[0x24]
80009bc2:	58 0b       	cp.w	r11,0
80009bc4:	e0 80 05 94 	breq	8000a6ec <_vfprintf_r+0x1658>
80009bc8:	32 d8       	mov	r8,45
80009bca:	fb 68 06 bb 	st.b	sp[1723],r8
80009bce:	e0 8f 05 93 	bral	8000a6f4 <_vfprintf_r+0x1660>
80009bd2:	50 a7       	stdsp	sp[0x28],r7
80009bd4:	04 94       	mov	r4,r2
80009bd6:	0c 97       	mov	r7,r6
80009bd8:	02 92       	mov	r2,r1
80009bda:	06 96       	mov	r6,r3
80009bdc:	40 41       	lddsp	r1,sp[0x10]
80009bde:	40 93       	lddsp	r3,sp[0x24]
80009be0:	0e 99       	mov	r9,r7
80009be2:	ed b5 00 05 	bld	r5,0x5
80009be6:	c4 81       	brne	80009c76 <_vfprintf_r+0xbe2>
80009be8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009bec:	40 3e       	lddsp	lr,sp[0xc]
80009bee:	58 0e       	cp.w	lr,0
80009bf0:	c1 d0       	breq	80009c2a <_vfprintf_r+0xb96>
80009bf2:	10 36       	cp.w	r6,r8
80009bf4:	c0 64       	brge	80009c00 <_vfprintf_r+0xb6c>
80009bf6:	fa cc f9 44 	sub	r12,sp,-1724
80009bfa:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009bfe:	c1 d8       	rjmp	80009c38 <_vfprintf_r+0xba4>
80009c00:	fa c8 f9 50 	sub	r8,sp,-1712
80009c04:	1a d8       	st.w	--sp,r8
80009c06:	fa c8 fa b8 	sub	r8,sp,-1352
80009c0a:	04 9a       	mov	r10,r2
80009c0c:	1a d8       	st.w	--sp,r8
80009c0e:	fa c8 fb b4 	sub	r8,sp,-1100
80009c12:	0c 9b       	mov	r11,r6
80009c14:	1a d8       	st.w	--sp,r8
80009c16:	08 9c       	mov	r12,r4
80009c18:	fa c8 f9 40 	sub	r8,sp,-1728
80009c1c:	fa c9 ff b4 	sub	r9,sp,-76
80009c20:	fe b0 f8 a2 	rcall	80008d64 <get_arg>
80009c24:	2f dd       	sub	sp,-12
80009c26:	78 0a       	ld.w	r10,r12[0x0]
80009c28:	c2 08       	rjmp	80009c68 <_vfprintf_r+0xbd4>
80009c2a:	2f f7       	sub	r7,-1
80009c2c:	10 39       	cp.w	r9,r8
80009c2e:	c0 84       	brge	80009c3e <_vfprintf_r+0xbaa>
80009c30:	fa cb f9 44 	sub	r11,sp,-1724
80009c34:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c38:	ec fa fd 88 	ld.w	r10,r6[-632]
80009c3c:	c1 68       	rjmp	80009c68 <_vfprintf_r+0xbd4>
80009c3e:	41 09       	lddsp	r9,sp[0x40]
80009c40:	59 f8       	cp.w	r8,31
80009c42:	e0 89 00 10 	brgt	80009c62 <_vfprintf_r+0xbce>
80009c46:	f2 ca ff fc 	sub	r10,r9,-4
80009c4a:	51 0a       	stdsp	sp[0x40],r10
80009c4c:	fa c6 f9 44 	sub	r6,sp,-1724
80009c50:	72 0a       	ld.w	r10,r9[0x0]
80009c52:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c56:	f3 4a fd 88 	st.w	r9[-632],r10
80009c5a:	2f f8       	sub	r8,-1
80009c5c:	fb 48 06 b4 	st.w	sp[1716],r8
80009c60:	c0 48       	rjmp	80009c68 <_vfprintf_r+0xbd4>
80009c62:	72 0a       	ld.w	r10,r9[0x0]
80009c64:	2f c9       	sub	r9,-4
80009c66:	51 09       	stdsp	sp[0x40],r9
80009c68:	40 be       	lddsp	lr,sp[0x2c]
80009c6a:	1c 98       	mov	r8,lr
80009c6c:	95 1e       	st.w	r10[0x4],lr
80009c6e:	bf 58       	asr	r8,0x1f
80009c70:	95 08       	st.w	r10[0x0],r8
80009c72:	fe 9f fa 9f 	bral	800091b0 <_vfprintf_r+0x11c>
80009c76:	ed b5 00 04 	bld	r5,0x4
80009c7a:	c4 80       	breq	80009d0a <_vfprintf_r+0xc76>
80009c7c:	e2 15 00 40 	andl	r5,0x40,COH
80009c80:	c4 50       	breq	80009d0a <_vfprintf_r+0xc76>
80009c82:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c86:	40 3c       	lddsp	r12,sp[0xc]
80009c88:	58 0c       	cp.w	r12,0
80009c8a:	c1 d0       	breq	80009cc4 <_vfprintf_r+0xc30>
80009c8c:	10 36       	cp.w	r6,r8
80009c8e:	c0 64       	brge	80009c9a <_vfprintf_r+0xc06>
80009c90:	fa cb f9 44 	sub	r11,sp,-1724
80009c94:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c98:	c1 d8       	rjmp	80009cd2 <_vfprintf_r+0xc3e>
80009c9a:	fa c8 f9 50 	sub	r8,sp,-1712
80009c9e:	1a d8       	st.w	--sp,r8
80009ca0:	fa c8 fa b8 	sub	r8,sp,-1352
80009ca4:	04 9a       	mov	r10,r2
80009ca6:	1a d8       	st.w	--sp,r8
80009ca8:	fa c8 fb b4 	sub	r8,sp,-1100
80009cac:	0c 9b       	mov	r11,r6
80009cae:	1a d8       	st.w	--sp,r8
80009cb0:	08 9c       	mov	r12,r4
80009cb2:	fa c8 f9 40 	sub	r8,sp,-1728
80009cb6:	fa c9 ff b4 	sub	r9,sp,-76
80009cba:	fe b0 f8 55 	rcall	80008d64 <get_arg>
80009cbe:	2f dd       	sub	sp,-12
80009cc0:	78 0a       	ld.w	r10,r12[0x0]
80009cc2:	c2 08       	rjmp	80009d02 <_vfprintf_r+0xc6e>
80009cc4:	2f f7       	sub	r7,-1
80009cc6:	10 39       	cp.w	r9,r8
80009cc8:	c0 84       	brge	80009cd8 <_vfprintf_r+0xc44>
80009cca:	fa ca f9 44 	sub	r10,sp,-1724
80009cce:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009cd2:	ec fa fd 88 	ld.w	r10,r6[-632]
80009cd6:	c1 68       	rjmp	80009d02 <_vfprintf_r+0xc6e>
80009cd8:	41 09       	lddsp	r9,sp[0x40]
80009cda:	59 f8       	cp.w	r8,31
80009cdc:	e0 89 00 10 	brgt	80009cfc <_vfprintf_r+0xc68>
80009ce0:	f2 ca ff fc 	sub	r10,r9,-4
80009ce4:	51 0a       	stdsp	sp[0x40],r10
80009ce6:	fa c6 f9 44 	sub	r6,sp,-1724
80009cea:	72 0a       	ld.w	r10,r9[0x0]
80009cec:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009cf0:	f3 4a fd 88 	st.w	r9[-632],r10
80009cf4:	2f f8       	sub	r8,-1
80009cf6:	fb 48 06 b4 	st.w	sp[1716],r8
80009cfa:	c0 48       	rjmp	80009d02 <_vfprintf_r+0xc6e>
80009cfc:	72 0a       	ld.w	r10,r9[0x0]
80009cfe:	2f c9       	sub	r9,-4
80009d00:	51 09       	stdsp	sp[0x40],r9
80009d02:	40 be       	lddsp	lr,sp[0x2c]
80009d04:	b4 0e       	st.h	r10[0x0],lr
80009d06:	fe 9f fa 55 	bral	800091b0 <_vfprintf_r+0x11c>
80009d0a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d0e:	40 3c       	lddsp	r12,sp[0xc]
80009d10:	58 0c       	cp.w	r12,0
80009d12:	c1 d0       	breq	80009d4c <_vfprintf_r+0xcb8>
80009d14:	10 36       	cp.w	r6,r8
80009d16:	c0 64       	brge	80009d22 <_vfprintf_r+0xc8e>
80009d18:	fa cb f9 44 	sub	r11,sp,-1724
80009d1c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d20:	c1 d8       	rjmp	80009d5a <_vfprintf_r+0xcc6>
80009d22:	fa c8 f9 50 	sub	r8,sp,-1712
80009d26:	1a d8       	st.w	--sp,r8
80009d28:	fa c8 fa b8 	sub	r8,sp,-1352
80009d2c:	04 9a       	mov	r10,r2
80009d2e:	1a d8       	st.w	--sp,r8
80009d30:	fa c8 fb b4 	sub	r8,sp,-1100
80009d34:	0c 9b       	mov	r11,r6
80009d36:	1a d8       	st.w	--sp,r8
80009d38:	08 9c       	mov	r12,r4
80009d3a:	fa c8 f9 40 	sub	r8,sp,-1728
80009d3e:	fa c9 ff b4 	sub	r9,sp,-76
80009d42:	fe b0 f8 11 	rcall	80008d64 <get_arg>
80009d46:	2f dd       	sub	sp,-12
80009d48:	78 0a       	ld.w	r10,r12[0x0]
80009d4a:	c2 08       	rjmp	80009d8a <_vfprintf_r+0xcf6>
80009d4c:	2f f7       	sub	r7,-1
80009d4e:	10 39       	cp.w	r9,r8
80009d50:	c0 84       	brge	80009d60 <_vfprintf_r+0xccc>
80009d52:	fa ca f9 44 	sub	r10,sp,-1724
80009d56:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009d5a:	ec fa fd 88 	ld.w	r10,r6[-632]
80009d5e:	c1 68       	rjmp	80009d8a <_vfprintf_r+0xcf6>
80009d60:	41 09       	lddsp	r9,sp[0x40]
80009d62:	59 f8       	cp.w	r8,31
80009d64:	e0 89 00 10 	brgt	80009d84 <_vfprintf_r+0xcf0>
80009d68:	f2 ca ff fc 	sub	r10,r9,-4
80009d6c:	51 0a       	stdsp	sp[0x40],r10
80009d6e:	fa c6 f9 44 	sub	r6,sp,-1724
80009d72:	72 0a       	ld.w	r10,r9[0x0]
80009d74:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009d78:	f3 4a fd 88 	st.w	r9[-632],r10
80009d7c:	2f f8       	sub	r8,-1
80009d7e:	fb 48 06 b4 	st.w	sp[1716],r8
80009d82:	c0 48       	rjmp	80009d8a <_vfprintf_r+0xcf6>
80009d84:	72 0a       	ld.w	r10,r9[0x0]
80009d86:	2f c9       	sub	r9,-4
80009d88:	51 09       	stdsp	sp[0x40],r9
80009d8a:	40 be       	lddsp	lr,sp[0x2c]
80009d8c:	95 0e       	st.w	r10[0x0],lr
80009d8e:	fe 9f fa 11 	bral	800091b0 <_vfprintf_r+0x11c>
80009d92:	50 a7       	stdsp	sp[0x28],r7
80009d94:	50 80       	stdsp	sp[0x20],r0
80009d96:	0c 97       	mov	r7,r6
80009d98:	04 94       	mov	r4,r2
80009d9a:	06 96       	mov	r6,r3
80009d9c:	02 92       	mov	r2,r1
80009d9e:	40 93       	lddsp	r3,sp[0x24]
80009da0:	10 90       	mov	r0,r8
80009da2:	40 41       	lddsp	r1,sp[0x10]
80009da4:	a5 a5       	sbr	r5,0x4
80009da6:	c0 a8       	rjmp	80009dba <_vfprintf_r+0xd26>
80009da8:	50 a7       	stdsp	sp[0x28],r7
80009daa:	50 80       	stdsp	sp[0x20],r0
80009dac:	0c 97       	mov	r7,r6
80009dae:	04 94       	mov	r4,r2
80009db0:	06 96       	mov	r6,r3
80009db2:	02 92       	mov	r2,r1
80009db4:	40 93       	lddsp	r3,sp[0x24]
80009db6:	10 90       	mov	r0,r8
80009db8:	40 41       	lddsp	r1,sp[0x10]
80009dba:	ed b5 00 05 	bld	r5,0x5
80009dbe:	c5 d1       	brne	80009e78 <_vfprintf_r+0xde4>
80009dc0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009dc4:	40 3c       	lddsp	r12,sp[0xc]
80009dc6:	58 0c       	cp.w	r12,0
80009dc8:	c2 60       	breq	80009e14 <_vfprintf_r+0xd80>
80009dca:	10 36       	cp.w	r6,r8
80009dcc:	c0 a4       	brge	80009de0 <_vfprintf_r+0xd4c>
80009dce:	fa cb f9 44 	sub	r11,sp,-1724
80009dd2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009dd6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009dda:	fa e9 00 00 	st.d	sp[0],r8
80009dde:	c1 88       	rjmp	80009e0e <_vfprintf_r+0xd7a>
80009de0:	fa c8 f9 50 	sub	r8,sp,-1712
80009de4:	1a d8       	st.w	--sp,r8
80009de6:	fa c8 fa b8 	sub	r8,sp,-1352
80009dea:	04 9a       	mov	r10,r2
80009dec:	1a d8       	st.w	--sp,r8
80009dee:	0c 9b       	mov	r11,r6
80009df0:	fa c8 fb b4 	sub	r8,sp,-1100
80009df4:	08 9c       	mov	r12,r4
80009df6:	1a d8       	st.w	--sp,r8
80009df8:	fa c8 f9 40 	sub	r8,sp,-1728
80009dfc:	fa c9 ff b4 	sub	r9,sp,-76
80009e00:	fe b0 f7 b2 	rcall	80008d64 <get_arg>
80009e04:	2f dd       	sub	sp,-12
80009e06:	f8 ea 00 00 	ld.d	r10,r12[0]
80009e0a:	fa eb 00 00 	st.d	sp[0],r10
80009e0e:	30 08       	mov	r8,0
80009e10:	e0 8f 03 de 	bral	8000a5cc <_vfprintf_r+0x1538>
80009e14:	ee ca ff ff 	sub	r10,r7,-1
80009e18:	10 37       	cp.w	r7,r8
80009e1a:	c0 b4       	brge	80009e30 <_vfprintf_r+0xd9c>
80009e1c:	fa c9 f9 44 	sub	r9,sp,-1724
80009e20:	14 97       	mov	r7,r10
80009e22:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009e26:	ec ea fd 88 	ld.d	r10,r6[-632]
80009e2a:	fa eb 00 00 	st.d	sp[0],r10
80009e2e:	c1 88       	rjmp	80009e5e <_vfprintf_r+0xdca>
80009e30:	41 09       	lddsp	r9,sp[0x40]
80009e32:	59 f8       	cp.w	r8,31
80009e34:	e0 89 00 18 	brgt	80009e64 <_vfprintf_r+0xdd0>
80009e38:	f2 e6 00 00 	ld.d	r6,r9[0]
80009e3c:	f2 cb ff f8 	sub	r11,r9,-8
80009e40:	fa e7 00 00 	st.d	sp[0],r6
80009e44:	51 0b       	stdsp	sp[0x40],r11
80009e46:	fa c6 f9 44 	sub	r6,sp,-1724
80009e4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009e4e:	fa e6 00 00 	ld.d	r6,sp[0]
80009e52:	f2 e7 fd 88 	st.d	r9[-632],r6
80009e56:	2f f8       	sub	r8,-1
80009e58:	14 97       	mov	r7,r10
80009e5a:	fb 48 06 b4 	st.w	sp[1716],r8
80009e5e:	40 38       	lddsp	r8,sp[0xc]
80009e60:	e0 8f 03 b6 	bral	8000a5cc <_vfprintf_r+0x1538>
80009e64:	f2 e6 00 00 	ld.d	r6,r9[0]
80009e68:	40 38       	lddsp	r8,sp[0xc]
80009e6a:	fa e7 00 00 	st.d	sp[0],r6
80009e6e:	2f 89       	sub	r9,-8
80009e70:	14 97       	mov	r7,r10
80009e72:	51 09       	stdsp	sp[0x40],r9
80009e74:	e0 8f 03 ac 	bral	8000a5cc <_vfprintf_r+0x1538>
80009e78:	ed b5 00 04 	bld	r5,0x4
80009e7c:	c1 61       	brne	80009ea8 <_vfprintf_r+0xe14>
80009e7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e82:	40 3e       	lddsp	lr,sp[0xc]
80009e84:	58 0e       	cp.w	lr,0
80009e86:	c0 80       	breq	80009e96 <_vfprintf_r+0xe02>
80009e88:	10 36       	cp.w	r6,r8
80009e8a:	c6 74       	brge	80009f58 <_vfprintf_r+0xec4>
80009e8c:	fa cc f9 44 	sub	r12,sp,-1724
80009e90:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009e94:	c8 08       	rjmp	80009f94 <_vfprintf_r+0xf00>
80009e96:	ee ca ff ff 	sub	r10,r7,-1
80009e9a:	10 37       	cp.w	r7,r8
80009e9c:	c7 f4       	brge	80009f9a <_vfprintf_r+0xf06>
80009e9e:	fa cb f9 44 	sub	r11,sp,-1724
80009ea2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ea6:	c7 68       	rjmp	80009f92 <_vfprintf_r+0xefe>
80009ea8:	ed b5 00 06 	bld	r5,0x6
80009eac:	c4 a1       	brne	80009f40 <_vfprintf_r+0xeac>
80009eae:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009eb2:	40 3c       	lddsp	r12,sp[0xc]
80009eb4:	58 0c       	cp.w	r12,0
80009eb6:	c1 d0       	breq	80009ef0 <_vfprintf_r+0xe5c>
80009eb8:	10 36       	cp.w	r6,r8
80009eba:	c0 64       	brge	80009ec6 <_vfprintf_r+0xe32>
80009ebc:	fa cb f9 44 	sub	r11,sp,-1724
80009ec0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ec4:	c1 f8       	rjmp	80009f02 <_vfprintf_r+0xe6e>
80009ec6:	fa c8 f9 50 	sub	r8,sp,-1712
80009eca:	1a d8       	st.w	--sp,r8
80009ecc:	fa c8 fa b8 	sub	r8,sp,-1352
80009ed0:	1a d8       	st.w	--sp,r8
80009ed2:	fa c8 fb b4 	sub	r8,sp,-1100
80009ed6:	1a d8       	st.w	--sp,r8
80009ed8:	fa c8 f9 40 	sub	r8,sp,-1728
80009edc:	fa c9 ff b4 	sub	r9,sp,-76
80009ee0:	04 9a       	mov	r10,r2
80009ee2:	0c 9b       	mov	r11,r6
80009ee4:	08 9c       	mov	r12,r4
80009ee6:	fe b0 f7 3f 	rcall	80008d64 <get_arg>
80009eea:	2f dd       	sub	sp,-12
80009eec:	98 18       	ld.sh	r8,r12[0x2]
80009eee:	c2 68       	rjmp	80009f3a <_vfprintf_r+0xea6>
80009ef0:	ee ca ff ff 	sub	r10,r7,-1
80009ef4:	10 37       	cp.w	r7,r8
80009ef6:	c0 94       	brge	80009f08 <_vfprintf_r+0xe74>
80009ef8:	fa c9 f9 44 	sub	r9,sp,-1724
80009efc:	14 97       	mov	r7,r10
80009efe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009f02:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009f06:	c1 a8       	rjmp	80009f3a <_vfprintf_r+0xea6>
80009f08:	41 09       	lddsp	r9,sp[0x40]
80009f0a:	59 f8       	cp.w	r8,31
80009f0c:	e0 89 00 13 	brgt	80009f32 <_vfprintf_r+0xe9e>
80009f10:	f2 cb ff fc 	sub	r11,r9,-4
80009f14:	51 0b       	stdsp	sp[0x40],r11
80009f16:	72 09       	ld.w	r9,r9[0x0]
80009f18:	fa c6 f9 44 	sub	r6,sp,-1724
80009f1c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009f20:	2f f8       	sub	r8,-1
80009f22:	f7 49 fd 88 	st.w	r11[-632],r9
80009f26:	fb 48 06 b4 	st.w	sp[1716],r8
80009f2a:	14 97       	mov	r7,r10
80009f2c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009f30:	c0 58       	rjmp	80009f3a <_vfprintf_r+0xea6>
80009f32:	92 18       	ld.sh	r8,r9[0x2]
80009f34:	14 97       	mov	r7,r10
80009f36:	2f c9       	sub	r9,-4
80009f38:	51 09       	stdsp	sp[0x40],r9
80009f3a:	5c 78       	castu.h	r8
80009f3c:	50 18       	stdsp	sp[0x4],r8
80009f3e:	c4 68       	rjmp	80009fca <_vfprintf_r+0xf36>
80009f40:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009f44:	40 3c       	lddsp	r12,sp[0xc]
80009f46:	58 0c       	cp.w	r12,0
80009f48:	c1 d0       	breq	80009f82 <_vfprintf_r+0xeee>
80009f4a:	10 36       	cp.w	r6,r8
80009f4c:	c0 64       	brge	80009f58 <_vfprintf_r+0xec4>
80009f4e:	fa cb f9 44 	sub	r11,sp,-1724
80009f52:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009f56:	c1 f8       	rjmp	80009f94 <_vfprintf_r+0xf00>
80009f58:	fa c8 f9 50 	sub	r8,sp,-1712
80009f5c:	1a d8       	st.w	--sp,r8
80009f5e:	fa c8 fa b8 	sub	r8,sp,-1352
80009f62:	0c 9b       	mov	r11,r6
80009f64:	1a d8       	st.w	--sp,r8
80009f66:	fa c8 fb b4 	sub	r8,sp,-1100
80009f6a:	04 9a       	mov	r10,r2
80009f6c:	1a d8       	st.w	--sp,r8
80009f6e:	08 9c       	mov	r12,r4
80009f70:	fa c8 f9 40 	sub	r8,sp,-1728
80009f74:	fa c9 ff b4 	sub	r9,sp,-76
80009f78:	fe b0 f6 f6 	rcall	80008d64 <get_arg>
80009f7c:	2f dd       	sub	sp,-12
80009f7e:	78 0b       	ld.w	r11,r12[0x0]
80009f80:	c2 48       	rjmp	80009fc8 <_vfprintf_r+0xf34>
80009f82:	ee ca ff ff 	sub	r10,r7,-1
80009f86:	10 37       	cp.w	r7,r8
80009f88:	c0 94       	brge	80009f9a <_vfprintf_r+0xf06>
80009f8a:	fa c9 f9 44 	sub	r9,sp,-1724
80009f8e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009f92:	14 97       	mov	r7,r10
80009f94:	ec fb fd 88 	ld.w	r11,r6[-632]
80009f98:	c1 88       	rjmp	80009fc8 <_vfprintf_r+0xf34>
80009f9a:	41 09       	lddsp	r9,sp[0x40]
80009f9c:	59 f8       	cp.w	r8,31
80009f9e:	e0 89 00 11 	brgt	80009fc0 <_vfprintf_r+0xf2c>
80009fa2:	f2 cb ff fc 	sub	r11,r9,-4
80009fa6:	51 0b       	stdsp	sp[0x40],r11
80009fa8:	fa c6 f9 44 	sub	r6,sp,-1724
80009fac:	72 0b       	ld.w	r11,r9[0x0]
80009fae:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009fb2:	f3 4b fd 88 	st.w	r9[-632],r11
80009fb6:	2f f8       	sub	r8,-1
80009fb8:	14 97       	mov	r7,r10
80009fba:	fb 48 06 b4 	st.w	sp[1716],r8
80009fbe:	c0 58       	rjmp	80009fc8 <_vfprintf_r+0xf34>
80009fc0:	72 0b       	ld.w	r11,r9[0x0]
80009fc2:	14 97       	mov	r7,r10
80009fc4:	2f c9       	sub	r9,-4
80009fc6:	51 09       	stdsp	sp[0x40],r9
80009fc8:	50 1b       	stdsp	sp[0x4],r11
80009fca:	30 0e       	mov	lr,0
80009fcc:	50 0e       	stdsp	sp[0x0],lr
80009fce:	1c 98       	mov	r8,lr
80009fd0:	e0 8f 02 fe 	bral	8000a5cc <_vfprintf_r+0x1538>
80009fd4:	50 a7       	stdsp	sp[0x28],r7
80009fd6:	50 80       	stdsp	sp[0x20],r0
80009fd8:	0c 97       	mov	r7,r6
80009fda:	04 94       	mov	r4,r2
80009fdc:	06 96       	mov	r6,r3
80009fde:	02 92       	mov	r2,r1
80009fe0:	40 93       	lddsp	r3,sp[0x24]
80009fe2:	40 41       	lddsp	r1,sp[0x10]
80009fe4:	0e 99       	mov	r9,r7
80009fe6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009fea:	40 3c       	lddsp	r12,sp[0xc]
80009fec:	58 0c       	cp.w	r12,0
80009fee:	c1 d0       	breq	8000a028 <_vfprintf_r+0xf94>
80009ff0:	10 36       	cp.w	r6,r8
80009ff2:	c0 64       	brge	80009ffe <_vfprintf_r+0xf6a>
80009ff4:	fa cb f9 44 	sub	r11,sp,-1724
80009ff8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ffc:	c1 d8       	rjmp	8000a036 <_vfprintf_r+0xfa2>
80009ffe:	fa c8 f9 50 	sub	r8,sp,-1712
8000a002:	1a d8       	st.w	--sp,r8
8000a004:	fa c8 fa b8 	sub	r8,sp,-1352
8000a008:	1a d8       	st.w	--sp,r8
8000a00a:	fa c8 fb b4 	sub	r8,sp,-1100
8000a00e:	1a d8       	st.w	--sp,r8
8000a010:	fa c9 ff b4 	sub	r9,sp,-76
8000a014:	fa c8 f9 40 	sub	r8,sp,-1728
8000a018:	04 9a       	mov	r10,r2
8000a01a:	0c 9b       	mov	r11,r6
8000a01c:	08 9c       	mov	r12,r4
8000a01e:	fe b0 f6 a3 	rcall	80008d64 <get_arg>
8000a022:	2f dd       	sub	sp,-12
8000a024:	78 09       	ld.w	r9,r12[0x0]
8000a026:	c2 18       	rjmp	8000a068 <_vfprintf_r+0xfd4>
8000a028:	2f f7       	sub	r7,-1
8000a02a:	10 39       	cp.w	r9,r8
8000a02c:	c0 84       	brge	8000a03c <_vfprintf_r+0xfa8>
8000a02e:	fa ca f9 44 	sub	r10,sp,-1724
8000a032:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a036:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000a03a:	c1 78       	rjmp	8000a068 <_vfprintf_r+0xfd4>
8000a03c:	41 09       	lddsp	r9,sp[0x40]
8000a03e:	59 f8       	cp.w	r8,31
8000a040:	e0 89 00 10 	brgt	8000a060 <_vfprintf_r+0xfcc>
8000a044:	f2 ca ff fc 	sub	r10,r9,-4
8000a048:	51 0a       	stdsp	sp[0x40],r10
8000a04a:	fa c6 f9 44 	sub	r6,sp,-1724
8000a04e:	72 09       	ld.w	r9,r9[0x0]
8000a050:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000a054:	f5 49 fd 88 	st.w	r10[-632],r9
8000a058:	2f f8       	sub	r8,-1
8000a05a:	fb 48 06 b4 	st.w	sp[1716],r8
8000a05e:	c0 58       	rjmp	8000a068 <_vfprintf_r+0xfd4>
8000a060:	f2 c8 ff fc 	sub	r8,r9,-4
8000a064:	51 08       	stdsp	sp[0x40],r8
8000a066:	72 09       	ld.w	r9,r9[0x0]
8000a068:	33 08       	mov	r8,48
8000a06a:	fb 68 06 b8 	st.b	sp[1720],r8
8000a06e:	37 88       	mov	r8,120
8000a070:	30 0e       	mov	lr,0
8000a072:	fb 68 06 b9 	st.b	sp[1721],r8
8000a076:	fe cc ad 3a 	sub	r12,pc,-21190
8000a07a:	50 19       	stdsp	sp[0x4],r9
8000a07c:	a1 b5       	sbr	r5,0x1
8000a07e:	50 0e       	stdsp	sp[0x0],lr
8000a080:	50 dc       	stdsp	sp[0x34],r12
8000a082:	30 28       	mov	r8,2
8000a084:	37 80       	mov	r0,120
8000a086:	e0 8f 02 a3 	bral	8000a5cc <_vfprintf_r+0x1538>
8000a08a:	50 a7       	stdsp	sp[0x28],r7
8000a08c:	50 80       	stdsp	sp[0x20],r0
8000a08e:	10 90       	mov	r0,r8
8000a090:	30 08       	mov	r8,0
8000a092:	fb 68 06 bb 	st.b	sp[1723],r8
8000a096:	0c 97       	mov	r7,r6
8000a098:	04 94       	mov	r4,r2
8000a09a:	06 96       	mov	r6,r3
8000a09c:	02 92       	mov	r2,r1
8000a09e:	40 93       	lddsp	r3,sp[0x24]
8000a0a0:	40 41       	lddsp	r1,sp[0x10]
8000a0a2:	0e 99       	mov	r9,r7
8000a0a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a0a8:	40 3b       	lddsp	r11,sp[0xc]
8000a0aa:	58 0b       	cp.w	r11,0
8000a0ac:	c1 d0       	breq	8000a0e6 <_vfprintf_r+0x1052>
8000a0ae:	10 36       	cp.w	r6,r8
8000a0b0:	c0 64       	brge	8000a0bc <_vfprintf_r+0x1028>
8000a0b2:	fa ca f9 44 	sub	r10,sp,-1724
8000a0b6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a0ba:	c1 d8       	rjmp	8000a0f4 <_vfprintf_r+0x1060>
8000a0bc:	fa c8 f9 50 	sub	r8,sp,-1712
8000a0c0:	1a d8       	st.w	--sp,r8
8000a0c2:	fa c8 fa b8 	sub	r8,sp,-1352
8000a0c6:	1a d8       	st.w	--sp,r8
8000a0c8:	fa c8 fb b4 	sub	r8,sp,-1100
8000a0cc:	0c 9b       	mov	r11,r6
8000a0ce:	1a d8       	st.w	--sp,r8
8000a0d0:	04 9a       	mov	r10,r2
8000a0d2:	fa c8 f9 40 	sub	r8,sp,-1728
8000a0d6:	fa c9 ff b4 	sub	r9,sp,-76
8000a0da:	08 9c       	mov	r12,r4
8000a0dc:	fe b0 f6 44 	rcall	80008d64 <get_arg>
8000a0e0:	2f dd       	sub	sp,-12
8000a0e2:	78 06       	ld.w	r6,r12[0x0]
8000a0e4:	c2 08       	rjmp	8000a124 <_vfprintf_r+0x1090>
8000a0e6:	2f f7       	sub	r7,-1
8000a0e8:	10 39       	cp.w	r9,r8
8000a0ea:	c0 84       	brge	8000a0fa <_vfprintf_r+0x1066>
8000a0ec:	fa c9 f9 44 	sub	r9,sp,-1724
8000a0f0:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a0f4:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000a0f8:	c1 68       	rjmp	8000a124 <_vfprintf_r+0x1090>
8000a0fa:	41 09       	lddsp	r9,sp[0x40]
8000a0fc:	59 f8       	cp.w	r8,31
8000a0fe:	e0 89 00 10 	brgt	8000a11e <_vfprintf_r+0x108a>
8000a102:	f2 ca ff fc 	sub	r10,r9,-4
8000a106:	51 0a       	stdsp	sp[0x40],r10
8000a108:	72 06       	ld.w	r6,r9[0x0]
8000a10a:	fa ce f9 44 	sub	lr,sp,-1724
8000a10e:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000a112:	f3 46 fd 88 	st.w	r9[-632],r6
8000a116:	2f f8       	sub	r8,-1
8000a118:	fb 48 06 b4 	st.w	sp[1716],r8
8000a11c:	c0 48       	rjmp	8000a124 <_vfprintf_r+0x1090>
8000a11e:	72 06       	ld.w	r6,r9[0x0]
8000a120:	2f c9       	sub	r9,-4
8000a122:	51 09       	stdsp	sp[0x40],r9
8000a124:	40 2c       	lddsp	r12,sp[0x8]
8000a126:	58 0c       	cp.w	r12,0
8000a128:	c1 05       	brlt	8000a148 <_vfprintf_r+0x10b4>
8000a12a:	18 9a       	mov	r10,r12
8000a12c:	30 0b       	mov	r11,0
8000a12e:	0c 9c       	mov	r12,r6
8000a130:	e0 a0 12 38 	rcall	8000c5a0 <memchr>
8000a134:	e0 80 02 df 	breq	8000a6f2 <_vfprintf_r+0x165e>
8000a138:	f8 06 01 02 	sub	r2,r12,r6
8000a13c:	40 2b       	lddsp	r11,sp[0x8]
8000a13e:	16 32       	cp.w	r2,r11
8000a140:	e0 89 02 d9 	brgt	8000a6f2 <_vfprintf_r+0x165e>
8000a144:	e0 8f 02 d4 	bral	8000a6ec <_vfprintf_r+0x1658>
8000a148:	30 0a       	mov	r10,0
8000a14a:	0c 9c       	mov	r12,r6
8000a14c:	50 2a       	stdsp	sp[0x8],r10
8000a14e:	e0 a0 15 99 	rcall	8000cc80 <strlen>
8000a152:	18 92       	mov	r2,r12
8000a154:	e0 8f 02 d2 	bral	8000a6f8 <_vfprintf_r+0x1664>
8000a158:	50 a7       	stdsp	sp[0x28],r7
8000a15a:	50 80       	stdsp	sp[0x20],r0
8000a15c:	0c 97       	mov	r7,r6
8000a15e:	04 94       	mov	r4,r2
8000a160:	06 96       	mov	r6,r3
8000a162:	02 92       	mov	r2,r1
8000a164:	40 93       	lddsp	r3,sp[0x24]
8000a166:	10 90       	mov	r0,r8
8000a168:	40 41       	lddsp	r1,sp[0x10]
8000a16a:	a5 a5       	sbr	r5,0x4
8000a16c:	c0 a8       	rjmp	8000a180 <_vfprintf_r+0x10ec>
8000a16e:	50 a7       	stdsp	sp[0x28],r7
8000a170:	50 80       	stdsp	sp[0x20],r0
8000a172:	0c 97       	mov	r7,r6
8000a174:	04 94       	mov	r4,r2
8000a176:	06 96       	mov	r6,r3
8000a178:	02 92       	mov	r2,r1
8000a17a:	40 93       	lddsp	r3,sp[0x24]
8000a17c:	10 90       	mov	r0,r8
8000a17e:	40 41       	lddsp	r1,sp[0x10]
8000a180:	ed b5 00 05 	bld	r5,0x5
8000a184:	c5 61       	brne	8000a230 <_vfprintf_r+0x119c>
8000a186:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a18a:	40 39       	lddsp	r9,sp[0xc]
8000a18c:	58 09       	cp.w	r9,0
8000a18e:	c2 10       	breq	8000a1d0 <_vfprintf_r+0x113c>
8000a190:	10 36       	cp.w	r6,r8
8000a192:	c0 74       	brge	8000a1a0 <_vfprintf_r+0x110c>
8000a194:	fa c8 f9 44 	sub	r8,sp,-1724
8000a198:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a19c:	c2 38       	rjmp	8000a1e2 <_vfprintf_r+0x114e>
8000a19e:	d7 03       	nop
8000a1a0:	fa c8 f9 50 	sub	r8,sp,-1712
8000a1a4:	1a d8       	st.w	--sp,r8
8000a1a6:	fa c8 fa b8 	sub	r8,sp,-1352
8000a1aa:	1a d8       	st.w	--sp,r8
8000a1ac:	fa c8 fb b4 	sub	r8,sp,-1100
8000a1b0:	1a d8       	st.w	--sp,r8
8000a1b2:	fa c8 f9 40 	sub	r8,sp,-1728
8000a1b6:	fa c9 ff b4 	sub	r9,sp,-76
8000a1ba:	04 9a       	mov	r10,r2
8000a1bc:	0c 9b       	mov	r11,r6
8000a1be:	08 9c       	mov	r12,r4
8000a1c0:	fe b0 f5 d2 	rcall	80008d64 <get_arg>
8000a1c4:	2f dd       	sub	sp,-12
8000a1c6:	f8 e8 00 00 	ld.d	r8,r12[0]
8000a1ca:	fa e9 00 00 	st.d	sp[0],r8
8000a1ce:	c2 e8       	rjmp	8000a22a <_vfprintf_r+0x1196>
8000a1d0:	ee ca ff ff 	sub	r10,r7,-1
8000a1d4:	10 37       	cp.w	r7,r8
8000a1d6:	c0 b4       	brge	8000a1ec <_vfprintf_r+0x1158>
8000a1d8:	fa c8 f9 44 	sub	r8,sp,-1724
8000a1dc:	14 97       	mov	r7,r10
8000a1de:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a1e2:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a1e6:	fa eb 00 00 	st.d	sp[0],r10
8000a1ea:	c2 08       	rjmp	8000a22a <_vfprintf_r+0x1196>
8000a1ec:	41 09       	lddsp	r9,sp[0x40]
8000a1ee:	59 f8       	cp.w	r8,31
8000a1f0:	e0 89 00 16 	brgt	8000a21c <_vfprintf_r+0x1188>
8000a1f4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a1f8:	f2 cb ff f8 	sub	r11,r9,-8
8000a1fc:	fa e7 00 00 	st.d	sp[0],r6
8000a200:	51 0b       	stdsp	sp[0x40],r11
8000a202:	fa c6 f9 44 	sub	r6,sp,-1724
8000a206:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a20a:	fa e6 00 00 	ld.d	r6,sp[0]
8000a20e:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a212:	2f f8       	sub	r8,-1
8000a214:	14 97       	mov	r7,r10
8000a216:	fb 48 06 b4 	st.w	sp[1716],r8
8000a21a:	c0 88       	rjmp	8000a22a <_vfprintf_r+0x1196>
8000a21c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a220:	2f 89       	sub	r9,-8
8000a222:	fa e7 00 00 	st.d	sp[0],r6
8000a226:	51 09       	stdsp	sp[0x40],r9
8000a228:	14 97       	mov	r7,r10
8000a22a:	30 18       	mov	r8,1
8000a22c:	e0 8f 01 d0 	bral	8000a5cc <_vfprintf_r+0x1538>
8000a230:	ed b5 00 04 	bld	r5,0x4
8000a234:	c1 61       	brne	8000a260 <_vfprintf_r+0x11cc>
8000a236:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a23a:	40 3e       	lddsp	lr,sp[0xc]
8000a23c:	58 0e       	cp.w	lr,0
8000a23e:	c0 80       	breq	8000a24e <_vfprintf_r+0x11ba>
8000a240:	10 36       	cp.w	r6,r8
8000a242:	c6 74       	brge	8000a310 <_vfprintf_r+0x127c>
8000a244:	fa cc f9 44 	sub	r12,sp,-1724
8000a248:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a24c:	c8 08       	rjmp	8000a34c <_vfprintf_r+0x12b8>
8000a24e:	ee ca ff ff 	sub	r10,r7,-1
8000a252:	10 37       	cp.w	r7,r8
8000a254:	c7 f4       	brge	8000a352 <_vfprintf_r+0x12be>
8000a256:	fa cb f9 44 	sub	r11,sp,-1724
8000a25a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a25e:	c7 68       	rjmp	8000a34a <_vfprintf_r+0x12b6>
8000a260:	ed b5 00 06 	bld	r5,0x6
8000a264:	c4 a1       	brne	8000a2f8 <_vfprintf_r+0x1264>
8000a266:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a26a:	40 3c       	lddsp	r12,sp[0xc]
8000a26c:	58 0c       	cp.w	r12,0
8000a26e:	c1 d0       	breq	8000a2a8 <_vfprintf_r+0x1214>
8000a270:	10 36       	cp.w	r6,r8
8000a272:	c0 64       	brge	8000a27e <_vfprintf_r+0x11ea>
8000a274:	fa cb f9 44 	sub	r11,sp,-1724
8000a278:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a27c:	c1 f8       	rjmp	8000a2ba <_vfprintf_r+0x1226>
8000a27e:	fa c8 f9 50 	sub	r8,sp,-1712
8000a282:	1a d8       	st.w	--sp,r8
8000a284:	fa c8 fa b8 	sub	r8,sp,-1352
8000a288:	1a d8       	st.w	--sp,r8
8000a28a:	fa c8 fb b4 	sub	r8,sp,-1100
8000a28e:	1a d8       	st.w	--sp,r8
8000a290:	fa c8 f9 40 	sub	r8,sp,-1728
8000a294:	fa c9 ff b4 	sub	r9,sp,-76
8000a298:	04 9a       	mov	r10,r2
8000a29a:	0c 9b       	mov	r11,r6
8000a29c:	08 9c       	mov	r12,r4
8000a29e:	fe b0 f5 63 	rcall	80008d64 <get_arg>
8000a2a2:	2f dd       	sub	sp,-12
8000a2a4:	98 18       	ld.sh	r8,r12[0x2]
8000a2a6:	c2 68       	rjmp	8000a2f2 <_vfprintf_r+0x125e>
8000a2a8:	ee ca ff ff 	sub	r10,r7,-1
8000a2ac:	10 37       	cp.w	r7,r8
8000a2ae:	c0 94       	brge	8000a2c0 <_vfprintf_r+0x122c>
8000a2b0:	fa c9 f9 44 	sub	r9,sp,-1724
8000a2b4:	14 97       	mov	r7,r10
8000a2b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a2ba:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a2be:	c1 a8       	rjmp	8000a2f2 <_vfprintf_r+0x125e>
8000a2c0:	41 09       	lddsp	r9,sp[0x40]
8000a2c2:	59 f8       	cp.w	r8,31
8000a2c4:	e0 89 00 13 	brgt	8000a2ea <_vfprintf_r+0x1256>
8000a2c8:	f2 cb ff fc 	sub	r11,r9,-4
8000a2cc:	51 0b       	stdsp	sp[0x40],r11
8000a2ce:	72 09       	ld.w	r9,r9[0x0]
8000a2d0:	fa c6 f9 44 	sub	r6,sp,-1724
8000a2d4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a2d8:	2f f8       	sub	r8,-1
8000a2da:	f7 49 fd 88 	st.w	r11[-632],r9
8000a2de:	fb 48 06 b4 	st.w	sp[1716],r8
8000a2e2:	14 97       	mov	r7,r10
8000a2e4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a2e8:	c0 58       	rjmp	8000a2f2 <_vfprintf_r+0x125e>
8000a2ea:	92 18       	ld.sh	r8,r9[0x2]
8000a2ec:	14 97       	mov	r7,r10
8000a2ee:	2f c9       	sub	r9,-4
8000a2f0:	51 09       	stdsp	sp[0x40],r9
8000a2f2:	5c 78       	castu.h	r8
8000a2f4:	50 18       	stdsp	sp[0x4],r8
8000a2f6:	c4 68       	rjmp	8000a382 <_vfprintf_r+0x12ee>
8000a2f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a2fc:	40 3c       	lddsp	r12,sp[0xc]
8000a2fe:	58 0c       	cp.w	r12,0
8000a300:	c1 d0       	breq	8000a33a <_vfprintf_r+0x12a6>
8000a302:	10 36       	cp.w	r6,r8
8000a304:	c0 64       	brge	8000a310 <_vfprintf_r+0x127c>
8000a306:	fa cb f9 44 	sub	r11,sp,-1724
8000a30a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a30e:	c1 f8       	rjmp	8000a34c <_vfprintf_r+0x12b8>
8000a310:	fa c8 f9 50 	sub	r8,sp,-1712
8000a314:	1a d8       	st.w	--sp,r8
8000a316:	fa c8 fa b8 	sub	r8,sp,-1352
8000a31a:	0c 9b       	mov	r11,r6
8000a31c:	1a d8       	st.w	--sp,r8
8000a31e:	fa c8 fb b4 	sub	r8,sp,-1100
8000a322:	04 9a       	mov	r10,r2
8000a324:	1a d8       	st.w	--sp,r8
8000a326:	08 9c       	mov	r12,r4
8000a328:	fa c8 f9 40 	sub	r8,sp,-1728
8000a32c:	fa c9 ff b4 	sub	r9,sp,-76
8000a330:	fe b0 f5 1a 	rcall	80008d64 <get_arg>
8000a334:	2f dd       	sub	sp,-12
8000a336:	78 0b       	ld.w	r11,r12[0x0]
8000a338:	c2 48       	rjmp	8000a380 <_vfprintf_r+0x12ec>
8000a33a:	ee ca ff ff 	sub	r10,r7,-1
8000a33e:	10 37       	cp.w	r7,r8
8000a340:	c0 94       	brge	8000a352 <_vfprintf_r+0x12be>
8000a342:	fa c9 f9 44 	sub	r9,sp,-1724
8000a346:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a34a:	14 97       	mov	r7,r10
8000a34c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a350:	c1 88       	rjmp	8000a380 <_vfprintf_r+0x12ec>
8000a352:	41 09       	lddsp	r9,sp[0x40]
8000a354:	59 f8       	cp.w	r8,31
8000a356:	e0 89 00 11 	brgt	8000a378 <_vfprintf_r+0x12e4>
8000a35a:	f2 cb ff fc 	sub	r11,r9,-4
8000a35e:	51 0b       	stdsp	sp[0x40],r11
8000a360:	fa c6 f9 44 	sub	r6,sp,-1724
8000a364:	72 0b       	ld.w	r11,r9[0x0]
8000a366:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a36a:	f3 4b fd 88 	st.w	r9[-632],r11
8000a36e:	2f f8       	sub	r8,-1
8000a370:	14 97       	mov	r7,r10
8000a372:	fb 48 06 b4 	st.w	sp[1716],r8
8000a376:	c0 58       	rjmp	8000a380 <_vfprintf_r+0x12ec>
8000a378:	72 0b       	ld.w	r11,r9[0x0]
8000a37a:	14 97       	mov	r7,r10
8000a37c:	2f c9       	sub	r9,-4
8000a37e:	51 09       	stdsp	sp[0x40],r9
8000a380:	50 1b       	stdsp	sp[0x4],r11
8000a382:	30 0e       	mov	lr,0
8000a384:	30 18       	mov	r8,1
8000a386:	50 0e       	stdsp	sp[0x0],lr
8000a388:	c2 29       	rjmp	8000a5cc <_vfprintf_r+0x1538>
8000a38a:	50 a7       	stdsp	sp[0x28],r7
8000a38c:	50 80       	stdsp	sp[0x20],r0
8000a38e:	0c 97       	mov	r7,r6
8000a390:	04 94       	mov	r4,r2
8000a392:	06 96       	mov	r6,r3
8000a394:	02 92       	mov	r2,r1
8000a396:	fe cc b0 5a 	sub	r12,pc,-20390
8000a39a:	40 93       	lddsp	r3,sp[0x24]
8000a39c:	10 90       	mov	r0,r8
8000a39e:	40 41       	lddsp	r1,sp[0x10]
8000a3a0:	50 dc       	stdsp	sp[0x34],r12
8000a3a2:	ed b5 00 05 	bld	r5,0x5
8000a3a6:	c5 51       	brne	8000a450 <_vfprintf_r+0x13bc>
8000a3a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a3ac:	40 3b       	lddsp	r11,sp[0xc]
8000a3ae:	58 0b       	cp.w	r11,0
8000a3b0:	c2 20       	breq	8000a3f4 <_vfprintf_r+0x1360>
8000a3b2:	10 36       	cp.w	r6,r8
8000a3b4:	c0 a4       	brge	8000a3c8 <_vfprintf_r+0x1334>
8000a3b6:	fa ca f9 44 	sub	r10,sp,-1724
8000a3ba:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a3be:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000a3c2:	fa e9 00 00 	st.d	sp[0],r8
8000a3c6:	cf 28       	rjmp	8000a5aa <_vfprintf_r+0x1516>
8000a3c8:	fa c8 f9 50 	sub	r8,sp,-1712
8000a3cc:	1a d8       	st.w	--sp,r8
8000a3ce:	fa c8 fa b8 	sub	r8,sp,-1352
8000a3d2:	04 9a       	mov	r10,r2
8000a3d4:	1a d8       	st.w	--sp,r8
8000a3d6:	0c 9b       	mov	r11,r6
8000a3d8:	fa c8 fb b4 	sub	r8,sp,-1100
8000a3dc:	08 9c       	mov	r12,r4
8000a3de:	1a d8       	st.w	--sp,r8
8000a3e0:	fa c8 f9 40 	sub	r8,sp,-1728
8000a3e4:	fa c9 ff b4 	sub	r9,sp,-76
8000a3e8:	fe b0 f4 be 	rcall	80008d64 <get_arg>
8000a3ec:	2f dd       	sub	sp,-12
8000a3ee:	f8 ea 00 00 	ld.d	r10,r12[0]
8000a3f2:	c0 c8       	rjmp	8000a40a <_vfprintf_r+0x1376>
8000a3f4:	ee ca ff ff 	sub	r10,r7,-1
8000a3f8:	10 37       	cp.w	r7,r8
8000a3fa:	c0 b4       	brge	8000a410 <_vfprintf_r+0x137c>
8000a3fc:	fa c9 f9 44 	sub	r9,sp,-1724
8000a400:	14 97       	mov	r7,r10
8000a402:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a406:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a40a:	fa eb 00 00 	st.d	sp[0],r10
8000a40e:	cc e8       	rjmp	8000a5aa <_vfprintf_r+0x1516>
8000a410:	41 09       	lddsp	r9,sp[0x40]
8000a412:	59 f8       	cp.w	r8,31
8000a414:	e0 89 00 16 	brgt	8000a440 <_vfprintf_r+0x13ac>
8000a418:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a41c:	f2 cb ff f8 	sub	r11,r9,-8
8000a420:	fa e7 00 00 	st.d	sp[0],r6
8000a424:	51 0b       	stdsp	sp[0x40],r11
8000a426:	fa c6 f9 44 	sub	r6,sp,-1724
8000a42a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a42e:	fa e6 00 00 	ld.d	r6,sp[0]
8000a432:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a436:	2f f8       	sub	r8,-1
8000a438:	14 97       	mov	r7,r10
8000a43a:	fb 48 06 b4 	st.w	sp[1716],r8
8000a43e:	cb 68       	rjmp	8000a5aa <_vfprintf_r+0x1516>
8000a440:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a444:	2f 89       	sub	r9,-8
8000a446:	fa e7 00 00 	st.d	sp[0],r6
8000a44a:	51 09       	stdsp	sp[0x40],r9
8000a44c:	14 97       	mov	r7,r10
8000a44e:	ca e8       	rjmp	8000a5aa <_vfprintf_r+0x1516>
8000a450:	ed b5 00 04 	bld	r5,0x4
8000a454:	c1 71       	brne	8000a482 <_vfprintf_r+0x13ee>
8000a456:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a45a:	40 3e       	lddsp	lr,sp[0xc]
8000a45c:	58 0e       	cp.w	lr,0
8000a45e:	c0 80       	breq	8000a46e <_vfprintf_r+0x13da>
8000a460:	10 36       	cp.w	r6,r8
8000a462:	c6 94       	brge	8000a534 <_vfprintf_r+0x14a0>
8000a464:	fa cc f9 44 	sub	r12,sp,-1724
8000a468:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a46c:	c8 28       	rjmp	8000a570 <_vfprintf_r+0x14dc>
8000a46e:	ee ca ff ff 	sub	r10,r7,-1
8000a472:	10 37       	cp.w	r7,r8
8000a474:	e0 84 00 81 	brge	8000a576 <_vfprintf_r+0x14e2>
8000a478:	fa cb f9 44 	sub	r11,sp,-1724
8000a47c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a480:	c7 78       	rjmp	8000a56e <_vfprintf_r+0x14da>
8000a482:	ed b5 00 06 	bld	r5,0x6
8000a486:	c4 b1       	brne	8000a51c <_vfprintf_r+0x1488>
8000a488:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a48c:	40 3c       	lddsp	r12,sp[0xc]
8000a48e:	58 0c       	cp.w	r12,0
8000a490:	c1 d0       	breq	8000a4ca <_vfprintf_r+0x1436>
8000a492:	10 36       	cp.w	r6,r8
8000a494:	c0 64       	brge	8000a4a0 <_vfprintf_r+0x140c>
8000a496:	fa cb f9 44 	sub	r11,sp,-1724
8000a49a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a49e:	c1 f8       	rjmp	8000a4dc <_vfprintf_r+0x1448>
8000a4a0:	fa c8 f9 50 	sub	r8,sp,-1712
8000a4a4:	1a d8       	st.w	--sp,r8
8000a4a6:	fa c8 fa b8 	sub	r8,sp,-1352
8000a4aa:	1a d8       	st.w	--sp,r8
8000a4ac:	fa c8 fb b4 	sub	r8,sp,-1100
8000a4b0:	1a d8       	st.w	--sp,r8
8000a4b2:	fa c8 f9 40 	sub	r8,sp,-1728
8000a4b6:	fa c9 ff b4 	sub	r9,sp,-76
8000a4ba:	04 9a       	mov	r10,r2
8000a4bc:	0c 9b       	mov	r11,r6
8000a4be:	08 9c       	mov	r12,r4
8000a4c0:	fe b0 f4 52 	rcall	80008d64 <get_arg>
8000a4c4:	2f dd       	sub	sp,-12
8000a4c6:	98 18       	ld.sh	r8,r12[0x2]
8000a4c8:	c2 78       	rjmp	8000a516 <_vfprintf_r+0x1482>
8000a4ca:	ee ca ff ff 	sub	r10,r7,-1
8000a4ce:	10 37       	cp.w	r7,r8
8000a4d0:	c0 a4       	brge	8000a4e4 <_vfprintf_r+0x1450>
8000a4d2:	fa c9 f9 44 	sub	r9,sp,-1724
8000a4d6:	14 97       	mov	r7,r10
8000a4d8:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a4dc:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a4e0:	c1 b8       	rjmp	8000a516 <_vfprintf_r+0x1482>
8000a4e2:	d7 03       	nop
8000a4e4:	41 09       	lddsp	r9,sp[0x40]
8000a4e6:	59 f8       	cp.w	r8,31
8000a4e8:	e0 89 00 13 	brgt	8000a50e <_vfprintf_r+0x147a>
8000a4ec:	f2 cb ff fc 	sub	r11,r9,-4
8000a4f0:	51 0b       	stdsp	sp[0x40],r11
8000a4f2:	72 09       	ld.w	r9,r9[0x0]
8000a4f4:	fa c6 f9 44 	sub	r6,sp,-1724
8000a4f8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a4fc:	2f f8       	sub	r8,-1
8000a4fe:	f7 49 fd 88 	st.w	r11[-632],r9
8000a502:	fb 48 06 b4 	st.w	sp[1716],r8
8000a506:	14 97       	mov	r7,r10
8000a508:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a50c:	c0 58       	rjmp	8000a516 <_vfprintf_r+0x1482>
8000a50e:	92 18       	ld.sh	r8,r9[0x2]
8000a510:	14 97       	mov	r7,r10
8000a512:	2f c9       	sub	r9,-4
8000a514:	51 09       	stdsp	sp[0x40],r9
8000a516:	5c 78       	castu.h	r8
8000a518:	50 18       	stdsp	sp[0x4],r8
8000a51a:	c4 68       	rjmp	8000a5a6 <_vfprintf_r+0x1512>
8000a51c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a520:	40 3c       	lddsp	r12,sp[0xc]
8000a522:	58 0c       	cp.w	r12,0
8000a524:	c1 d0       	breq	8000a55e <_vfprintf_r+0x14ca>
8000a526:	10 36       	cp.w	r6,r8
8000a528:	c0 64       	brge	8000a534 <_vfprintf_r+0x14a0>
8000a52a:	fa cb f9 44 	sub	r11,sp,-1724
8000a52e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a532:	c1 f8       	rjmp	8000a570 <_vfprintf_r+0x14dc>
8000a534:	fa c8 f9 50 	sub	r8,sp,-1712
8000a538:	1a d8       	st.w	--sp,r8
8000a53a:	fa c8 fa b8 	sub	r8,sp,-1352
8000a53e:	0c 9b       	mov	r11,r6
8000a540:	1a d8       	st.w	--sp,r8
8000a542:	fa c8 fb b4 	sub	r8,sp,-1100
8000a546:	04 9a       	mov	r10,r2
8000a548:	1a d8       	st.w	--sp,r8
8000a54a:	08 9c       	mov	r12,r4
8000a54c:	fa c8 f9 40 	sub	r8,sp,-1728
8000a550:	fa c9 ff b4 	sub	r9,sp,-76
8000a554:	fe b0 f4 08 	rcall	80008d64 <get_arg>
8000a558:	2f dd       	sub	sp,-12
8000a55a:	78 0b       	ld.w	r11,r12[0x0]
8000a55c:	c2 48       	rjmp	8000a5a4 <_vfprintf_r+0x1510>
8000a55e:	ee ca ff ff 	sub	r10,r7,-1
8000a562:	10 37       	cp.w	r7,r8
8000a564:	c0 94       	brge	8000a576 <_vfprintf_r+0x14e2>
8000a566:	fa c9 f9 44 	sub	r9,sp,-1724
8000a56a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a56e:	14 97       	mov	r7,r10
8000a570:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a574:	c1 88       	rjmp	8000a5a4 <_vfprintf_r+0x1510>
8000a576:	41 09       	lddsp	r9,sp[0x40]
8000a578:	59 f8       	cp.w	r8,31
8000a57a:	e0 89 00 11 	brgt	8000a59c <_vfprintf_r+0x1508>
8000a57e:	f2 cb ff fc 	sub	r11,r9,-4
8000a582:	51 0b       	stdsp	sp[0x40],r11
8000a584:	fa c6 f9 44 	sub	r6,sp,-1724
8000a588:	72 0b       	ld.w	r11,r9[0x0]
8000a58a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a58e:	f3 4b fd 88 	st.w	r9[-632],r11
8000a592:	2f f8       	sub	r8,-1
8000a594:	14 97       	mov	r7,r10
8000a596:	fb 48 06 b4 	st.w	sp[1716],r8
8000a59a:	c0 58       	rjmp	8000a5a4 <_vfprintf_r+0x1510>
8000a59c:	72 0b       	ld.w	r11,r9[0x0]
8000a59e:	14 97       	mov	r7,r10
8000a5a0:	2f c9       	sub	r9,-4
8000a5a2:	51 09       	stdsp	sp[0x40],r9
8000a5a4:	50 1b       	stdsp	sp[0x4],r11
8000a5a6:	30 0e       	mov	lr,0
8000a5a8:	50 0e       	stdsp	sp[0x0],lr
8000a5aa:	40 08       	lddsp	r8,sp[0x0]
8000a5ac:	40 1c       	lddsp	r12,sp[0x4]
8000a5ae:	18 48       	or	r8,r12
8000a5b0:	5f 19       	srne	r9
8000a5b2:	0a 98       	mov	r8,r5
8000a5b4:	eb e9 00 09 	and	r9,r5,r9
8000a5b8:	a1 b8       	sbr	r8,0x1
8000a5ba:	58 09       	cp.w	r9,0
8000a5bc:	c0 70       	breq	8000a5ca <_vfprintf_r+0x1536>
8000a5be:	10 95       	mov	r5,r8
8000a5c0:	fb 60 06 b9 	st.b	sp[1721],r0
8000a5c4:	33 08       	mov	r8,48
8000a5c6:	fb 68 06 b8 	st.b	sp[1720],r8
8000a5ca:	30 28       	mov	r8,2
8000a5cc:	30 09       	mov	r9,0
8000a5ce:	fb 69 06 bb 	st.b	sp[1723],r9
8000a5d2:	0a 99       	mov	r9,r5
8000a5d4:	a7 d9       	cbr	r9,0x7
8000a5d6:	40 2b       	lddsp	r11,sp[0x8]
8000a5d8:	40 16       	lddsp	r6,sp[0x4]
8000a5da:	58 0b       	cp.w	r11,0
8000a5dc:	5f 1a       	srne	r10
8000a5de:	f2 05 17 40 	movge	r5,r9
8000a5e2:	fa c2 f9 78 	sub	r2,sp,-1672
8000a5e6:	40 09       	lddsp	r9,sp[0x0]
8000a5e8:	0c 49       	or	r9,r6
8000a5ea:	5f 19       	srne	r9
8000a5ec:	f5 e9 10 09 	or	r9,r10,r9
8000a5f0:	c5 c0       	breq	8000a6a8 <_vfprintf_r+0x1614>
8000a5f2:	30 19       	mov	r9,1
8000a5f4:	f2 08 18 00 	cp.b	r8,r9
8000a5f8:	c0 60       	breq	8000a604 <_vfprintf_r+0x1570>
8000a5fa:	30 29       	mov	r9,2
8000a5fc:	f2 08 18 00 	cp.b	r8,r9
8000a600:	c0 41       	brne	8000a608 <_vfprintf_r+0x1574>
8000a602:	c3 c8       	rjmp	8000a67a <_vfprintf_r+0x15e6>
8000a604:	04 96       	mov	r6,r2
8000a606:	c3 08       	rjmp	8000a666 <_vfprintf_r+0x15d2>
8000a608:	04 96       	mov	r6,r2
8000a60a:	fa e8 00 00 	ld.d	r8,sp[0]
8000a60e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000a612:	2d 0a       	sub	r10,-48
8000a614:	0c fa       	st.b	--r6,r10
8000a616:	f0 0b 16 03 	lsr	r11,r8,0x3
8000a61a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000a61e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000a622:	18 99       	mov	r9,r12
8000a624:	16 98       	mov	r8,r11
8000a626:	58 08       	cp.w	r8,0
8000a628:	5c 29       	cpc	r9
8000a62a:	cf 21       	brne	8000a60e <_vfprintf_r+0x157a>
8000a62c:	fa e9 00 00 	st.d	sp[0],r8
8000a630:	ed b5 00 00 	bld	r5,0x0
8000a634:	c4 51       	brne	8000a6be <_vfprintf_r+0x162a>
8000a636:	33 09       	mov	r9,48
8000a638:	f2 0a 18 00 	cp.b	r10,r9
8000a63c:	c4 10       	breq	8000a6be <_vfprintf_r+0x162a>
8000a63e:	0c f9       	st.b	--r6,r9
8000a640:	c3 f8       	rjmp	8000a6be <_vfprintf_r+0x162a>
8000a642:	fa ea 00 00 	ld.d	r10,sp[0]
8000a646:	30 a8       	mov	r8,10
8000a648:	30 09       	mov	r9,0
8000a64a:	e0 a0 1a 19 	rcall	8000da7c <__avr32_umod64>
8000a64e:	30 a8       	mov	r8,10
8000a650:	2d 0a       	sub	r10,-48
8000a652:	30 09       	mov	r9,0
8000a654:	ac 8a       	st.b	r6[0x0],r10
8000a656:	fa ea 00 00 	ld.d	r10,sp[0]
8000a65a:	e0 a0 18 df 	rcall	8000d818 <__avr32_udiv64>
8000a65e:	16 99       	mov	r9,r11
8000a660:	14 98       	mov	r8,r10
8000a662:	fa e9 00 00 	st.d	sp[0],r8
8000a666:	20 16       	sub	r6,1
8000a668:	fa ea 00 00 	ld.d	r10,sp[0]
8000a66c:	58 9a       	cp.w	r10,9
8000a66e:	5c 2b       	cpc	r11
8000a670:	fe 9b ff e9 	brhi	8000a642 <_vfprintf_r+0x15ae>
8000a674:	1b f8       	ld.ub	r8,sp[0x7]
8000a676:	2d 08       	sub	r8,-48
8000a678:	c2 08       	rjmp	8000a6b8 <_vfprintf_r+0x1624>
8000a67a:	04 96       	mov	r6,r2
8000a67c:	fa e8 00 00 	ld.d	r8,sp[0]
8000a680:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000a684:	40 de       	lddsp	lr,sp[0x34]
8000a686:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000a68a:	0c fa       	st.b	--r6,r10
8000a68c:	f2 0b 16 04 	lsr	r11,r9,0x4
8000a690:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a694:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000a698:	16 99       	mov	r9,r11
8000a69a:	14 98       	mov	r8,r10
8000a69c:	58 08       	cp.w	r8,0
8000a69e:	5c 29       	cpc	r9
8000a6a0:	cf 01       	brne	8000a680 <_vfprintf_r+0x15ec>
8000a6a2:	fa e9 00 00 	st.d	sp[0],r8
8000a6a6:	c0 c8       	rjmp	8000a6be <_vfprintf_r+0x162a>
8000a6a8:	58 08       	cp.w	r8,0
8000a6aa:	c0 91       	brne	8000a6bc <_vfprintf_r+0x1628>
8000a6ac:	ed b5 00 00 	bld	r5,0x0
8000a6b0:	c0 61       	brne	8000a6bc <_vfprintf_r+0x1628>
8000a6b2:	fa c6 f9 79 	sub	r6,sp,-1671
8000a6b6:	33 08       	mov	r8,48
8000a6b8:	ac 88       	st.b	r6[0x0],r8
8000a6ba:	c0 28       	rjmp	8000a6be <_vfprintf_r+0x162a>
8000a6bc:	04 96       	mov	r6,r2
8000a6be:	0c 12       	sub	r2,r6
8000a6c0:	c1 c8       	rjmp	8000a6f8 <_vfprintf_r+0x1664>
8000a6c2:	50 a7       	stdsp	sp[0x28],r7
8000a6c4:	50 80       	stdsp	sp[0x20],r0
8000a6c6:	40 93       	lddsp	r3,sp[0x24]
8000a6c8:	0c 97       	mov	r7,r6
8000a6ca:	10 90       	mov	r0,r8
8000a6cc:	04 94       	mov	r4,r2
8000a6ce:	40 41       	lddsp	r1,sp[0x10]
8000a6d0:	58 08       	cp.w	r8,0
8000a6d2:	e0 80 04 4f 	breq	8000af70 <_vfprintf_r+0x1edc>
8000a6d6:	fb 68 06 60 	st.b	sp[1632],r8
8000a6da:	30 0c       	mov	r12,0
8000a6dc:	30 08       	mov	r8,0
8000a6de:	30 12       	mov	r2,1
8000a6e0:	fb 68 06 bb 	st.b	sp[1723],r8
8000a6e4:	50 2c       	stdsp	sp[0x8],r12
8000a6e6:	fa c6 f9 a0 	sub	r6,sp,-1632
8000a6ea:	c0 78       	rjmp	8000a6f8 <_vfprintf_r+0x1664>
8000a6ec:	30 0b       	mov	r11,0
8000a6ee:	50 2b       	stdsp	sp[0x8],r11
8000a6f0:	c0 48       	rjmp	8000a6f8 <_vfprintf_r+0x1664>
8000a6f2:	40 22       	lddsp	r2,sp[0x8]
8000a6f4:	30 0a       	mov	r10,0
8000a6f6:	50 2a       	stdsp	sp[0x8],r10
8000a6f8:	40 29       	lddsp	r9,sp[0x8]
8000a6fa:	e4 09 0c 49 	max	r9,r2,r9
8000a6fe:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a702:	50 39       	stdsp	sp[0xc],r9
8000a704:	0a 9e       	mov	lr,r5
8000a706:	30 09       	mov	r9,0
8000a708:	e2 1e 00 02 	andl	lr,0x2,COH
8000a70c:	f2 08 18 00 	cp.b	r8,r9
8000a710:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000a714:	f7 b8 01 ff 	subne	r8,-1
8000a718:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000a71c:	0a 9b       	mov	r11,r5
8000a71e:	58 0e       	cp.w	lr,0
8000a720:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000a724:	f7 bc 01 fe 	subne	r12,-2
8000a728:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000a72c:	e2 1b 00 84 	andl	r11,0x84,COH
8000a730:	50 fe       	stdsp	sp[0x3c],lr
8000a732:	50 9b       	stdsp	sp[0x24],r11
8000a734:	c4 71       	brne	8000a7c2 <_vfprintf_r+0x172e>
8000a736:	40 8a       	lddsp	r10,sp[0x20]
8000a738:	40 39       	lddsp	r9,sp[0xc]
8000a73a:	12 1a       	sub	r10,r9
8000a73c:	50 4a       	stdsp	sp[0x10],r10
8000a73e:	58 0a       	cp.w	r10,0
8000a740:	e0 89 00 20 	brgt	8000a780 <_vfprintf_r+0x16ec>
8000a744:	c3 f8       	rjmp	8000a7c2 <_vfprintf_r+0x172e>
8000a746:	2f 09       	sub	r9,-16
8000a748:	2f f8       	sub	r8,-1
8000a74a:	fe ce b3 f6 	sub	lr,pc,-19466
8000a74e:	31 0c       	mov	r12,16
8000a750:	fb 49 06 90 	st.w	sp[1680],r9
8000a754:	87 0e       	st.w	r3[0x0],lr
8000a756:	87 1c       	st.w	r3[0x4],r12
8000a758:	fb 48 06 8c 	st.w	sp[1676],r8
8000a75c:	58 78       	cp.w	r8,7
8000a75e:	e0 89 00 04 	brgt	8000a766 <_vfprintf_r+0x16d2>
8000a762:	2f 83       	sub	r3,-8
8000a764:	c0 b8       	rjmp	8000a77a <_vfprintf_r+0x16e6>
8000a766:	fa ca f9 78 	sub	r10,sp,-1672
8000a76a:	02 9b       	mov	r11,r1
8000a76c:	08 9c       	mov	r12,r4
8000a76e:	fe b0 f4 85 	rcall	80009078 <__sprint_r>
8000a772:	e0 81 04 10 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a776:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a77a:	40 4b       	lddsp	r11,sp[0x10]
8000a77c:	21 0b       	sub	r11,16
8000a77e:	50 4b       	stdsp	sp[0x10],r11
8000a780:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a784:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a788:	fe ca b4 34 	sub	r10,pc,-19404
8000a78c:	40 4e       	lddsp	lr,sp[0x10]
8000a78e:	59 0e       	cp.w	lr,16
8000a790:	fe 99 ff db 	brgt	8000a746 <_vfprintf_r+0x16b2>
8000a794:	1c 09       	add	r9,lr
8000a796:	2f f8       	sub	r8,-1
8000a798:	87 0a       	st.w	r3[0x0],r10
8000a79a:	fb 49 06 90 	st.w	sp[1680],r9
8000a79e:	87 1e       	st.w	r3[0x4],lr
8000a7a0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7a4:	58 78       	cp.w	r8,7
8000a7a6:	e0 89 00 04 	brgt	8000a7ae <_vfprintf_r+0x171a>
8000a7aa:	2f 83       	sub	r3,-8
8000a7ac:	c0 b8       	rjmp	8000a7c2 <_vfprintf_r+0x172e>
8000a7ae:	fa ca f9 78 	sub	r10,sp,-1672
8000a7b2:	02 9b       	mov	r11,r1
8000a7b4:	08 9c       	mov	r12,r4
8000a7b6:	fe b0 f4 61 	rcall	80009078 <__sprint_r>
8000a7ba:	e0 81 03 ec 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a7be:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7c2:	30 09       	mov	r9,0
8000a7c4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a7c8:	f2 08 18 00 	cp.b	r8,r9
8000a7cc:	c1 f0       	breq	8000a80a <_vfprintf_r+0x1776>
8000a7ce:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a7d2:	fa c9 f9 45 	sub	r9,sp,-1723
8000a7d6:	2f f8       	sub	r8,-1
8000a7d8:	87 09       	st.w	r3[0x0],r9
8000a7da:	fb 48 06 90 	st.w	sp[1680],r8
8000a7de:	30 19       	mov	r9,1
8000a7e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7e4:	87 19       	st.w	r3[0x4],r9
8000a7e6:	2f f8       	sub	r8,-1
8000a7e8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7ec:	58 78       	cp.w	r8,7
8000a7ee:	e0 89 00 04 	brgt	8000a7f6 <_vfprintf_r+0x1762>
8000a7f2:	2f 83       	sub	r3,-8
8000a7f4:	c0 b8       	rjmp	8000a80a <_vfprintf_r+0x1776>
8000a7f6:	fa ca f9 78 	sub	r10,sp,-1672
8000a7fa:	02 9b       	mov	r11,r1
8000a7fc:	08 9c       	mov	r12,r4
8000a7fe:	fe b0 f4 3d 	rcall	80009078 <__sprint_r>
8000a802:	e0 81 03 c8 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a806:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a80a:	40 fc       	lddsp	r12,sp[0x3c]
8000a80c:	58 0c       	cp.w	r12,0
8000a80e:	c1 f0       	breq	8000a84c <_vfprintf_r+0x17b8>
8000a810:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a814:	fa c9 f9 48 	sub	r9,sp,-1720
8000a818:	2f e8       	sub	r8,-2
8000a81a:	87 09       	st.w	r3[0x0],r9
8000a81c:	fb 48 06 90 	st.w	sp[1680],r8
8000a820:	30 29       	mov	r9,2
8000a822:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a826:	87 19       	st.w	r3[0x4],r9
8000a828:	2f f8       	sub	r8,-1
8000a82a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a82e:	58 78       	cp.w	r8,7
8000a830:	e0 89 00 04 	brgt	8000a838 <_vfprintf_r+0x17a4>
8000a834:	2f 83       	sub	r3,-8
8000a836:	c0 b8       	rjmp	8000a84c <_vfprintf_r+0x17b8>
8000a838:	fa ca f9 78 	sub	r10,sp,-1672
8000a83c:	02 9b       	mov	r11,r1
8000a83e:	08 9c       	mov	r12,r4
8000a840:	fe b0 f4 1c 	rcall	80009078 <__sprint_r>
8000a844:	e0 81 03 a7 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a848:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a84c:	40 9b       	lddsp	r11,sp[0x24]
8000a84e:	e0 4b 00 80 	cp.w	r11,128
8000a852:	c4 71       	brne	8000a8e0 <_vfprintf_r+0x184c>
8000a854:	40 8a       	lddsp	r10,sp[0x20]
8000a856:	40 39       	lddsp	r9,sp[0xc]
8000a858:	12 1a       	sub	r10,r9
8000a85a:	50 4a       	stdsp	sp[0x10],r10
8000a85c:	58 0a       	cp.w	r10,0
8000a85e:	e0 89 00 20 	brgt	8000a89e <_vfprintf_r+0x180a>
8000a862:	c3 f8       	rjmp	8000a8e0 <_vfprintf_r+0x184c>
8000a864:	2f 09       	sub	r9,-16
8000a866:	2f f8       	sub	r8,-1
8000a868:	fe ce b5 04 	sub	lr,pc,-19196
8000a86c:	31 0c       	mov	r12,16
8000a86e:	fb 49 06 90 	st.w	sp[1680],r9
8000a872:	87 0e       	st.w	r3[0x0],lr
8000a874:	87 1c       	st.w	r3[0x4],r12
8000a876:	fb 48 06 8c 	st.w	sp[1676],r8
8000a87a:	58 78       	cp.w	r8,7
8000a87c:	e0 89 00 04 	brgt	8000a884 <_vfprintf_r+0x17f0>
8000a880:	2f 83       	sub	r3,-8
8000a882:	c0 b8       	rjmp	8000a898 <_vfprintf_r+0x1804>
8000a884:	fa ca f9 78 	sub	r10,sp,-1672
8000a888:	02 9b       	mov	r11,r1
8000a88a:	08 9c       	mov	r12,r4
8000a88c:	fe b0 f3 f6 	rcall	80009078 <__sprint_r>
8000a890:	e0 81 03 81 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a894:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a898:	40 4b       	lddsp	r11,sp[0x10]
8000a89a:	21 0b       	sub	r11,16
8000a89c:	50 4b       	stdsp	sp[0x10],r11
8000a89e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a8a2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a8a6:	fe ca b5 42 	sub	r10,pc,-19134
8000a8aa:	40 4e       	lddsp	lr,sp[0x10]
8000a8ac:	59 0e       	cp.w	lr,16
8000a8ae:	fe 99 ff db 	brgt	8000a864 <_vfprintf_r+0x17d0>
8000a8b2:	1c 09       	add	r9,lr
8000a8b4:	2f f8       	sub	r8,-1
8000a8b6:	87 0a       	st.w	r3[0x0],r10
8000a8b8:	fb 49 06 90 	st.w	sp[1680],r9
8000a8bc:	87 1e       	st.w	r3[0x4],lr
8000a8be:	fb 48 06 8c 	st.w	sp[1676],r8
8000a8c2:	58 78       	cp.w	r8,7
8000a8c4:	e0 89 00 04 	brgt	8000a8cc <_vfprintf_r+0x1838>
8000a8c8:	2f 83       	sub	r3,-8
8000a8ca:	c0 b8       	rjmp	8000a8e0 <_vfprintf_r+0x184c>
8000a8cc:	fa ca f9 78 	sub	r10,sp,-1672
8000a8d0:	02 9b       	mov	r11,r1
8000a8d2:	08 9c       	mov	r12,r4
8000a8d4:	fe b0 f3 d2 	rcall	80009078 <__sprint_r>
8000a8d8:	e0 81 03 5d 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a8dc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8e0:	40 2c       	lddsp	r12,sp[0x8]
8000a8e2:	04 1c       	sub	r12,r2
8000a8e4:	50 2c       	stdsp	sp[0x8],r12
8000a8e6:	58 0c       	cp.w	r12,0
8000a8e8:	e0 89 00 20 	brgt	8000a928 <_vfprintf_r+0x1894>
8000a8ec:	c3 f8       	rjmp	8000a96a <_vfprintf_r+0x18d6>
8000a8ee:	2f 09       	sub	r9,-16
8000a8f0:	2f f8       	sub	r8,-1
8000a8f2:	fe cb b5 8e 	sub	r11,pc,-19058
8000a8f6:	31 0a       	mov	r10,16
8000a8f8:	fb 49 06 90 	st.w	sp[1680],r9
8000a8fc:	87 0b       	st.w	r3[0x0],r11
8000a8fe:	87 1a       	st.w	r3[0x4],r10
8000a900:	fb 48 06 8c 	st.w	sp[1676],r8
8000a904:	58 78       	cp.w	r8,7
8000a906:	e0 89 00 04 	brgt	8000a90e <_vfprintf_r+0x187a>
8000a90a:	2f 83       	sub	r3,-8
8000a90c:	c0 b8       	rjmp	8000a922 <_vfprintf_r+0x188e>
8000a90e:	fa ca f9 78 	sub	r10,sp,-1672
8000a912:	02 9b       	mov	r11,r1
8000a914:	08 9c       	mov	r12,r4
8000a916:	fe b0 f3 b1 	rcall	80009078 <__sprint_r>
8000a91a:	e0 81 03 3c 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a91e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a922:	40 29       	lddsp	r9,sp[0x8]
8000a924:	21 09       	sub	r9,16
8000a926:	50 29       	stdsp	sp[0x8],r9
8000a928:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a92c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a930:	fe ca b5 cc 	sub	r10,pc,-18996
8000a934:	40 2e       	lddsp	lr,sp[0x8]
8000a936:	59 0e       	cp.w	lr,16
8000a938:	fe 99 ff db 	brgt	8000a8ee <_vfprintf_r+0x185a>
8000a93c:	1c 09       	add	r9,lr
8000a93e:	2f f8       	sub	r8,-1
8000a940:	87 0a       	st.w	r3[0x0],r10
8000a942:	fb 49 06 90 	st.w	sp[1680],r9
8000a946:	87 1e       	st.w	r3[0x4],lr
8000a948:	fb 48 06 8c 	st.w	sp[1676],r8
8000a94c:	58 78       	cp.w	r8,7
8000a94e:	e0 89 00 04 	brgt	8000a956 <_vfprintf_r+0x18c2>
8000a952:	2f 83       	sub	r3,-8
8000a954:	c0 b8       	rjmp	8000a96a <_vfprintf_r+0x18d6>
8000a956:	fa ca f9 78 	sub	r10,sp,-1672
8000a95a:	02 9b       	mov	r11,r1
8000a95c:	08 9c       	mov	r12,r4
8000a95e:	fe b0 f3 8d 	rcall	80009078 <__sprint_r>
8000a962:	e0 81 03 18 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a966:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a96a:	ed b5 00 08 	bld	r5,0x8
8000a96e:	c0 b0       	breq	8000a984 <_vfprintf_r+0x18f0>
8000a970:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a974:	87 12       	st.w	r3[0x4],r2
8000a976:	87 06       	st.w	r3[0x0],r6
8000a978:	f0 02 00 02 	add	r2,r8,r2
8000a97c:	fb 42 06 90 	st.w	sp[1680],r2
8000a980:	e0 8f 01 d4 	bral	8000ad28 <_vfprintf_r+0x1c94>
8000a984:	e0 40 00 65 	cp.w	r0,101
8000a988:	e0 8a 01 d6 	brle	8000ad34 <_vfprintf_r+0x1ca0>
8000a98c:	30 08       	mov	r8,0
8000a98e:	30 09       	mov	r9,0
8000a990:	40 5b       	lddsp	r11,sp[0x14]
8000a992:	40 7a       	lddsp	r10,sp[0x1c]
8000a994:	e0 a0 15 3b 	rcall	8000d40a <__avr32_f64_cmp_eq>
8000a998:	c7 90       	breq	8000aa8a <_vfprintf_r+0x19f6>
8000a99a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a99e:	fe c9 b6 4e 	sub	r9,pc,-18866
8000a9a2:	2f f8       	sub	r8,-1
8000a9a4:	87 09       	st.w	r3[0x0],r9
8000a9a6:	fb 48 06 90 	st.w	sp[1680],r8
8000a9aa:	30 19       	mov	r9,1
8000a9ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a9b0:	87 19       	st.w	r3[0x4],r9
8000a9b2:	2f f8       	sub	r8,-1
8000a9b4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9b8:	58 78       	cp.w	r8,7
8000a9ba:	e0 89 00 05 	brgt	8000a9c4 <_vfprintf_r+0x1930>
8000a9be:	2f 83       	sub	r3,-8
8000a9c0:	c0 c8       	rjmp	8000a9d8 <_vfprintf_r+0x1944>
8000a9c2:	d7 03       	nop
8000a9c4:	fa ca f9 78 	sub	r10,sp,-1672
8000a9c8:	02 9b       	mov	r11,r1
8000a9ca:	08 9c       	mov	r12,r4
8000a9cc:	fe b0 f3 56 	rcall	80009078 <__sprint_r>
8000a9d0:	e0 81 02 e1 	brne	8000af92 <_vfprintf_r+0x1efe>
8000a9d4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a9d8:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a9dc:	40 6c       	lddsp	r12,sp[0x18]
8000a9de:	18 38       	cp.w	r8,r12
8000a9e0:	c0 55       	brlt	8000a9ea <_vfprintf_r+0x1956>
8000a9e2:	ed b5 00 00 	bld	r5,0x0
8000a9e6:	e0 81 02 6b 	brne	8000aebc <_vfprintf_r+0x1e28>
8000a9ea:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a9ee:	2f f8       	sub	r8,-1
8000a9f0:	40 cb       	lddsp	r11,sp[0x30]
8000a9f2:	fb 48 06 90 	st.w	sp[1680],r8
8000a9f6:	30 19       	mov	r9,1
8000a9f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a9fc:	87 0b       	st.w	r3[0x0],r11
8000a9fe:	2f f8       	sub	r8,-1
8000aa00:	87 19       	st.w	r3[0x4],r9
8000aa02:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa06:	58 78       	cp.w	r8,7
8000aa08:	e0 89 00 04 	brgt	8000aa10 <_vfprintf_r+0x197c>
8000aa0c:	2f 83       	sub	r3,-8
8000aa0e:	c0 b8       	rjmp	8000aa24 <_vfprintf_r+0x1990>
8000aa10:	fa ca f9 78 	sub	r10,sp,-1672
8000aa14:	02 9b       	mov	r11,r1
8000aa16:	08 9c       	mov	r12,r4
8000aa18:	fe b0 f3 30 	rcall	80009078 <__sprint_r>
8000aa1c:	e0 81 02 bb 	brne	8000af92 <_vfprintf_r+0x1efe>
8000aa20:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa24:	40 66       	lddsp	r6,sp[0x18]
8000aa26:	20 16       	sub	r6,1
8000aa28:	58 06       	cp.w	r6,0
8000aa2a:	e0 89 00 1d 	brgt	8000aa64 <_vfprintf_r+0x19d0>
8000aa2e:	e0 8f 02 47 	bral	8000aebc <_vfprintf_r+0x1e28>
8000aa32:	2f 09       	sub	r9,-16
8000aa34:	2f f8       	sub	r8,-1
8000aa36:	fb 49 06 90 	st.w	sp[1680],r9
8000aa3a:	87 02       	st.w	r3[0x0],r2
8000aa3c:	87 10       	st.w	r3[0x4],r0
8000aa3e:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa42:	58 78       	cp.w	r8,7
8000aa44:	e0 89 00 04 	brgt	8000aa4c <_vfprintf_r+0x19b8>
8000aa48:	2f 83       	sub	r3,-8
8000aa4a:	c0 b8       	rjmp	8000aa60 <_vfprintf_r+0x19cc>
8000aa4c:	fa ca f9 78 	sub	r10,sp,-1672
8000aa50:	02 9b       	mov	r11,r1
8000aa52:	08 9c       	mov	r12,r4
8000aa54:	fe b0 f3 12 	rcall	80009078 <__sprint_r>
8000aa58:	e0 81 02 9d 	brne	8000af92 <_vfprintf_r+0x1efe>
8000aa5c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa60:	21 06       	sub	r6,16
8000aa62:	c0 48       	rjmp	8000aa6a <_vfprintf_r+0x19d6>
8000aa64:	fe c2 b7 00 	sub	r2,pc,-18688
8000aa68:	31 00       	mov	r0,16
8000aa6a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aa6e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa72:	fe ca b7 0e 	sub	r10,pc,-18674
8000aa76:	59 06       	cp.w	r6,16
8000aa78:	fe 99 ff dd 	brgt	8000aa32 <_vfprintf_r+0x199e>
8000aa7c:	0c 09       	add	r9,r6
8000aa7e:	87 0a       	st.w	r3[0x0],r10
8000aa80:	fb 49 06 90 	st.w	sp[1680],r9
8000aa84:	2f f8       	sub	r8,-1
8000aa86:	87 16       	st.w	r3[0x4],r6
8000aa88:	c5 39       	rjmp	8000ad2e <_vfprintf_r+0x1c9a>
8000aa8a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000aa8e:	58 0a       	cp.w	r10,0
8000aa90:	e0 89 00 92 	brgt	8000abb4 <_vfprintf_r+0x1b20>
8000aa94:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aa98:	fe c9 b7 48 	sub	r9,pc,-18616
8000aa9c:	2f f8       	sub	r8,-1
8000aa9e:	87 09       	st.w	r3[0x0],r9
8000aaa0:	fb 48 06 90 	st.w	sp[1680],r8
8000aaa4:	30 19       	mov	r9,1
8000aaa6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aaaa:	87 19       	st.w	r3[0x4],r9
8000aaac:	2f f8       	sub	r8,-1
8000aaae:	fb 48 06 8c 	st.w	sp[1676],r8
8000aab2:	58 78       	cp.w	r8,7
8000aab4:	e0 89 00 04 	brgt	8000aabc <_vfprintf_r+0x1a28>
8000aab8:	2f 83       	sub	r3,-8
8000aaba:	c0 b8       	rjmp	8000aad0 <_vfprintf_r+0x1a3c>
8000aabc:	fa ca f9 78 	sub	r10,sp,-1672
8000aac0:	02 9b       	mov	r11,r1
8000aac2:	08 9c       	mov	r12,r4
8000aac4:	fe b0 f2 da 	rcall	80009078 <__sprint_r>
8000aac8:	e0 81 02 65 	brne	8000af92 <_vfprintf_r+0x1efe>
8000aacc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aad0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000aad4:	58 08       	cp.w	r8,0
8000aad6:	c0 81       	brne	8000aae6 <_vfprintf_r+0x1a52>
8000aad8:	40 6a       	lddsp	r10,sp[0x18]
8000aada:	58 0a       	cp.w	r10,0
8000aadc:	c0 51       	brne	8000aae6 <_vfprintf_r+0x1a52>
8000aade:	ed b5 00 00 	bld	r5,0x0
8000aae2:	e0 81 01 ed 	brne	8000aebc <_vfprintf_r+0x1e28>
8000aae6:	40 c9       	lddsp	r9,sp[0x30]
8000aae8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aaec:	2f f8       	sub	r8,-1
8000aaee:	87 09       	st.w	r3[0x0],r9
8000aaf0:	fb 48 06 90 	st.w	sp[1680],r8
8000aaf4:	30 19       	mov	r9,1
8000aaf6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aafa:	87 19       	st.w	r3[0x4],r9
8000aafc:	2f f8       	sub	r8,-1
8000aafe:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab02:	58 78       	cp.w	r8,7
8000ab04:	e0 89 00 04 	brgt	8000ab0c <_vfprintf_r+0x1a78>
8000ab08:	2f 83       	sub	r3,-8
8000ab0a:	c0 b8       	rjmp	8000ab20 <_vfprintf_r+0x1a8c>
8000ab0c:	fa ca f9 78 	sub	r10,sp,-1672
8000ab10:	02 9b       	mov	r11,r1
8000ab12:	08 9c       	mov	r12,r4
8000ab14:	fe b0 f2 b2 	rcall	80009078 <__sprint_r>
8000ab18:	e0 81 02 3d 	brne	8000af92 <_vfprintf_r+0x1efe>
8000ab1c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab20:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ab24:	5c 32       	neg	r2
8000ab26:	58 02       	cp.w	r2,0
8000ab28:	e0 89 00 1d 	brgt	8000ab62 <_vfprintf_r+0x1ace>
8000ab2c:	c3 d8       	rjmp	8000aba6 <_vfprintf_r+0x1b12>
8000ab2e:	2f 09       	sub	r9,-16
8000ab30:	2f f8       	sub	r8,-1
8000ab32:	31 0e       	mov	lr,16
8000ab34:	fb 49 06 90 	st.w	sp[1680],r9
8000ab38:	87 00       	st.w	r3[0x0],r0
8000ab3a:	87 1e       	st.w	r3[0x4],lr
8000ab3c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab40:	58 78       	cp.w	r8,7
8000ab42:	e0 89 00 04 	brgt	8000ab4a <_vfprintf_r+0x1ab6>
8000ab46:	2f 83       	sub	r3,-8
8000ab48:	c0 b8       	rjmp	8000ab5e <_vfprintf_r+0x1aca>
8000ab4a:	fa ca f9 78 	sub	r10,sp,-1672
8000ab4e:	02 9b       	mov	r11,r1
8000ab50:	08 9c       	mov	r12,r4
8000ab52:	fe b0 f2 93 	rcall	80009078 <__sprint_r>
8000ab56:	e0 81 02 1e 	brne	8000af92 <_vfprintf_r+0x1efe>
8000ab5a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab5e:	21 02       	sub	r2,16
8000ab60:	c0 38       	rjmp	8000ab66 <_vfprintf_r+0x1ad2>
8000ab62:	fe c0 b7 fe 	sub	r0,pc,-18434
8000ab66:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ab6a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab6e:	fe ca b8 0a 	sub	r10,pc,-18422
8000ab72:	59 02       	cp.w	r2,16
8000ab74:	fe 99 ff dd 	brgt	8000ab2e <_vfprintf_r+0x1a9a>
8000ab78:	04 09       	add	r9,r2
8000ab7a:	2f f8       	sub	r8,-1
8000ab7c:	87 0a       	st.w	r3[0x0],r10
8000ab7e:	fb 49 06 90 	st.w	sp[1680],r9
8000ab82:	87 12       	st.w	r3[0x4],r2
8000ab84:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab88:	58 78       	cp.w	r8,7
8000ab8a:	e0 89 00 04 	brgt	8000ab92 <_vfprintf_r+0x1afe>
8000ab8e:	2f 83       	sub	r3,-8
8000ab90:	c0 b8       	rjmp	8000aba6 <_vfprintf_r+0x1b12>
8000ab92:	fa ca f9 78 	sub	r10,sp,-1672
8000ab96:	02 9b       	mov	r11,r1
8000ab98:	08 9c       	mov	r12,r4
8000ab9a:	fe b0 f2 6f 	rcall	80009078 <__sprint_r>
8000ab9e:	e0 81 01 fa 	brne	8000af92 <_vfprintf_r+0x1efe>
8000aba2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aba6:	40 6c       	lddsp	r12,sp[0x18]
8000aba8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000abac:	87 06       	st.w	r3[0x0],r6
8000abae:	87 1c       	st.w	r3[0x4],r12
8000abb0:	18 08       	add	r8,r12
8000abb2:	cb 98       	rjmp	8000ad24 <_vfprintf_r+0x1c90>
8000abb4:	fa f9 06 90 	ld.w	r9,sp[1680]
8000abb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000abbc:	40 6b       	lddsp	r11,sp[0x18]
8000abbe:	16 3a       	cp.w	r10,r11
8000abc0:	c6 f5       	brlt	8000ac9e <_vfprintf_r+0x1c0a>
8000abc2:	16 09       	add	r9,r11
8000abc4:	2f f8       	sub	r8,-1
8000abc6:	87 06       	st.w	r3[0x0],r6
8000abc8:	fb 49 06 90 	st.w	sp[1680],r9
8000abcc:	87 1b       	st.w	r3[0x4],r11
8000abce:	fb 48 06 8c 	st.w	sp[1676],r8
8000abd2:	58 78       	cp.w	r8,7
8000abd4:	e0 89 00 04 	brgt	8000abdc <_vfprintf_r+0x1b48>
8000abd8:	2f 83       	sub	r3,-8
8000abda:	c0 b8       	rjmp	8000abf0 <_vfprintf_r+0x1b5c>
8000abdc:	fa ca f9 78 	sub	r10,sp,-1672
8000abe0:	02 9b       	mov	r11,r1
8000abe2:	08 9c       	mov	r12,r4
8000abe4:	fe b0 f2 4a 	rcall	80009078 <__sprint_r>
8000abe8:	e0 81 01 d5 	brne	8000af92 <_vfprintf_r+0x1efe>
8000abec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000abf0:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000abf4:	40 6a       	lddsp	r10,sp[0x18]
8000abf6:	14 16       	sub	r6,r10
8000abf8:	58 06       	cp.w	r6,0
8000abfa:	e0 89 00 1c 	brgt	8000ac32 <_vfprintf_r+0x1b9e>
8000abfe:	c3 d8       	rjmp	8000ac78 <_vfprintf_r+0x1be4>
8000ac00:	2f 09       	sub	r9,-16
8000ac02:	2f f8       	sub	r8,-1
8000ac04:	fb 49 06 90 	st.w	sp[1680],r9
8000ac08:	87 02       	st.w	r3[0x0],r2
8000ac0a:	87 10       	st.w	r3[0x4],r0
8000ac0c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac10:	58 78       	cp.w	r8,7
8000ac12:	e0 89 00 04 	brgt	8000ac1a <_vfprintf_r+0x1b86>
8000ac16:	2f 83       	sub	r3,-8
8000ac18:	c0 b8       	rjmp	8000ac2e <_vfprintf_r+0x1b9a>
8000ac1a:	fa ca f9 78 	sub	r10,sp,-1672
8000ac1e:	02 9b       	mov	r11,r1
8000ac20:	08 9c       	mov	r12,r4
8000ac22:	fe b0 f2 2b 	rcall	80009078 <__sprint_r>
8000ac26:	e0 81 01 b6 	brne	8000af92 <_vfprintf_r+0x1efe>
8000ac2a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac2e:	21 06       	sub	r6,16
8000ac30:	c0 48       	rjmp	8000ac38 <_vfprintf_r+0x1ba4>
8000ac32:	fe c2 b8 ce 	sub	r2,pc,-18226
8000ac36:	31 00       	mov	r0,16
8000ac38:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ac3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac40:	fe ca b8 dc 	sub	r10,pc,-18212
8000ac44:	59 06       	cp.w	r6,16
8000ac46:	fe 99 ff dd 	brgt	8000ac00 <_vfprintf_r+0x1b6c>
8000ac4a:	0c 09       	add	r9,r6
8000ac4c:	2f f8       	sub	r8,-1
8000ac4e:	87 0a       	st.w	r3[0x0],r10
8000ac50:	fb 49 06 90 	st.w	sp[1680],r9
8000ac54:	87 16       	st.w	r3[0x4],r6
8000ac56:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac5a:	58 78       	cp.w	r8,7
8000ac5c:	e0 89 00 04 	brgt	8000ac64 <_vfprintf_r+0x1bd0>
8000ac60:	2f 83       	sub	r3,-8
8000ac62:	c0 b8       	rjmp	8000ac78 <_vfprintf_r+0x1be4>
8000ac64:	fa ca f9 78 	sub	r10,sp,-1672
8000ac68:	02 9b       	mov	r11,r1
8000ac6a:	08 9c       	mov	r12,r4
8000ac6c:	fe b0 f2 06 	rcall	80009078 <__sprint_r>
8000ac70:	e0 81 01 91 	brne	8000af92 <_vfprintf_r+0x1efe>
8000ac74:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac78:	ed b5 00 00 	bld	r5,0x0
8000ac7c:	e0 81 01 20 	brne	8000aebc <_vfprintf_r+0x1e28>
8000ac80:	40 c9       	lddsp	r9,sp[0x30]
8000ac82:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ac86:	2f f8       	sub	r8,-1
8000ac88:	87 09       	st.w	r3[0x0],r9
8000ac8a:	fb 48 06 90 	st.w	sp[1680],r8
8000ac8e:	30 19       	mov	r9,1
8000ac90:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac94:	87 19       	st.w	r3[0x4],r9
8000ac96:	2f f8       	sub	r8,-1
8000ac98:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac9c:	c0 29       	rjmp	8000aea0 <_vfprintf_r+0x1e0c>
8000ac9e:	14 09       	add	r9,r10
8000aca0:	2f f8       	sub	r8,-1
8000aca2:	fb 49 06 90 	st.w	sp[1680],r9
8000aca6:	87 06       	st.w	r3[0x0],r6
8000aca8:	87 1a       	st.w	r3[0x4],r10
8000acaa:	fb 48 06 8c 	st.w	sp[1676],r8
8000acae:	58 78       	cp.w	r8,7
8000acb0:	e0 89 00 04 	brgt	8000acb8 <_vfprintf_r+0x1c24>
8000acb4:	2f 83       	sub	r3,-8
8000acb6:	c0 b8       	rjmp	8000accc <_vfprintf_r+0x1c38>
8000acb8:	fa ca f9 78 	sub	r10,sp,-1672
8000acbc:	02 9b       	mov	r11,r1
8000acbe:	08 9c       	mov	r12,r4
8000acc0:	fe b0 f1 dc 	rcall	80009078 <__sprint_r>
8000acc4:	e0 81 01 67 	brne	8000af92 <_vfprintf_r+0x1efe>
8000acc8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000accc:	40 c8       	lddsp	r8,sp[0x30]
8000acce:	87 08       	st.w	r3[0x0],r8
8000acd0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000acd4:	2f f8       	sub	r8,-1
8000acd6:	30 19       	mov	r9,1
8000acd8:	fb 48 06 90 	st.w	sp[1680],r8
8000acdc:	87 19       	st.w	r3[0x4],r9
8000acde:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ace2:	2f f8       	sub	r8,-1
8000ace4:	fb 48 06 8c 	st.w	sp[1676],r8
8000ace8:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000acec:	58 78       	cp.w	r8,7
8000acee:	e0 89 00 04 	brgt	8000acf6 <_vfprintf_r+0x1c62>
8000acf2:	2f 83       	sub	r3,-8
8000acf4:	c0 b8       	rjmp	8000ad0a <_vfprintf_r+0x1c76>
8000acf6:	fa ca f9 78 	sub	r10,sp,-1672
8000acfa:	02 9b       	mov	r11,r1
8000acfc:	08 9c       	mov	r12,r4
8000acfe:	fe b0 f1 bd 	rcall	80009078 <__sprint_r>
8000ad02:	e0 81 01 48 	brne	8000af92 <_vfprintf_r+0x1efe>
8000ad06:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad0a:	04 06       	add	r6,r2
8000ad0c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ad10:	87 06       	st.w	r3[0x0],r6
8000ad12:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ad16:	40 66       	lddsp	r6,sp[0x18]
8000ad18:	40 6e       	lddsp	lr,sp[0x18]
8000ad1a:	10 16       	sub	r6,r8
8000ad1c:	f2 08 01 08 	sub	r8,r9,r8
8000ad20:	87 16       	st.w	r3[0x4],r6
8000ad22:	1c 08       	add	r8,lr
8000ad24:	fb 48 06 90 	st.w	sp[1680],r8
8000ad28:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad2c:	2f f8       	sub	r8,-1
8000ad2e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad32:	cb 78       	rjmp	8000aea0 <_vfprintf_r+0x1e0c>
8000ad34:	40 6c       	lddsp	r12,sp[0x18]
8000ad36:	58 1c       	cp.w	r12,1
8000ad38:	e0 89 00 06 	brgt	8000ad44 <_vfprintf_r+0x1cb0>
8000ad3c:	ed b5 00 00 	bld	r5,0x0
8000ad40:	e0 81 00 85 	brne	8000ae4a <_vfprintf_r+0x1db6>
8000ad44:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad48:	2f f8       	sub	r8,-1
8000ad4a:	30 19       	mov	r9,1
8000ad4c:	fb 48 06 90 	st.w	sp[1680],r8
8000ad50:	87 06       	st.w	r3[0x0],r6
8000ad52:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad56:	87 19       	st.w	r3[0x4],r9
8000ad58:	2f f8       	sub	r8,-1
8000ad5a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad5e:	58 78       	cp.w	r8,7
8000ad60:	e0 89 00 04 	brgt	8000ad68 <_vfprintf_r+0x1cd4>
8000ad64:	2f 83       	sub	r3,-8
8000ad66:	c0 b8       	rjmp	8000ad7c <_vfprintf_r+0x1ce8>
8000ad68:	fa ca f9 78 	sub	r10,sp,-1672
8000ad6c:	02 9b       	mov	r11,r1
8000ad6e:	08 9c       	mov	r12,r4
8000ad70:	fe b0 f1 84 	rcall	80009078 <__sprint_r>
8000ad74:	e0 81 01 0f 	brne	8000af92 <_vfprintf_r+0x1efe>
8000ad78:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad7c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad80:	2f f8       	sub	r8,-1
8000ad82:	40 cb       	lddsp	r11,sp[0x30]
8000ad84:	fb 48 06 90 	st.w	sp[1680],r8
8000ad88:	30 19       	mov	r9,1
8000ad8a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad8e:	87 0b       	st.w	r3[0x0],r11
8000ad90:	2f f8       	sub	r8,-1
8000ad92:	87 19       	st.w	r3[0x4],r9
8000ad94:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad98:	58 78       	cp.w	r8,7
8000ad9a:	e0 89 00 05 	brgt	8000ada4 <_vfprintf_r+0x1d10>
8000ad9e:	2f 83       	sub	r3,-8
8000ada0:	c0 c8       	rjmp	8000adb8 <_vfprintf_r+0x1d24>
8000ada2:	d7 03       	nop
8000ada4:	fa ca f9 78 	sub	r10,sp,-1672
8000ada8:	02 9b       	mov	r11,r1
8000adaa:	08 9c       	mov	r12,r4
8000adac:	fe b0 f1 66 	rcall	80009078 <__sprint_r>
8000adb0:	e0 81 00 f1 	brne	8000af92 <_vfprintf_r+0x1efe>
8000adb4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000adb8:	30 08       	mov	r8,0
8000adba:	30 09       	mov	r9,0
8000adbc:	40 5b       	lddsp	r11,sp[0x14]
8000adbe:	40 7a       	lddsp	r10,sp[0x1c]
8000adc0:	e0 a0 13 25 	rcall	8000d40a <__avr32_f64_cmp_eq>
8000adc4:	40 68       	lddsp	r8,sp[0x18]
8000adc6:	20 18       	sub	r8,1
8000adc8:	58 0c       	cp.w	r12,0
8000adca:	c0 d1       	brne	8000ade4 <_vfprintf_r+0x1d50>
8000adcc:	2f f6       	sub	r6,-1
8000adce:	87 18       	st.w	r3[0x4],r8
8000add0:	87 06       	st.w	r3[0x0],r6
8000add2:	fa f6 06 90 	ld.w	r6,sp[1680]
8000add6:	10 06       	add	r6,r8
8000add8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000addc:	fb 46 06 90 	st.w	sp[1680],r6
8000ade0:	2f f8       	sub	r8,-1
8000ade2:	c3 18       	rjmp	8000ae44 <_vfprintf_r+0x1db0>
8000ade4:	10 96       	mov	r6,r8
8000ade6:	58 08       	cp.w	r8,0
8000ade8:	e0 89 00 1c 	brgt	8000ae20 <_vfprintf_r+0x1d8c>
8000adec:	c4 b8       	rjmp	8000ae82 <_vfprintf_r+0x1dee>
8000adee:	2f 09       	sub	r9,-16
8000adf0:	2f f8       	sub	r8,-1
8000adf2:	fb 49 06 90 	st.w	sp[1680],r9
8000adf6:	87 02       	st.w	r3[0x0],r2
8000adf8:	87 10       	st.w	r3[0x4],r0
8000adfa:	fb 48 06 8c 	st.w	sp[1676],r8
8000adfe:	58 78       	cp.w	r8,7
8000ae00:	e0 89 00 04 	brgt	8000ae08 <_vfprintf_r+0x1d74>
8000ae04:	2f 83       	sub	r3,-8
8000ae06:	c0 b8       	rjmp	8000ae1c <_vfprintf_r+0x1d88>
8000ae08:	fa ca f9 78 	sub	r10,sp,-1672
8000ae0c:	02 9b       	mov	r11,r1
8000ae0e:	08 9c       	mov	r12,r4
8000ae10:	fe b0 f1 34 	rcall	80009078 <__sprint_r>
8000ae14:	e0 81 00 bf 	brne	8000af92 <_vfprintf_r+0x1efe>
8000ae18:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae1c:	21 06       	sub	r6,16
8000ae1e:	c0 48       	rjmp	8000ae26 <_vfprintf_r+0x1d92>
8000ae20:	fe c2 ba bc 	sub	r2,pc,-17732
8000ae24:	31 00       	mov	r0,16
8000ae26:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ae2a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae2e:	fe ca ba ca 	sub	r10,pc,-17718
8000ae32:	59 06       	cp.w	r6,16
8000ae34:	fe 99 ff dd 	brgt	8000adee <_vfprintf_r+0x1d5a>
8000ae38:	0c 09       	add	r9,r6
8000ae3a:	87 0a       	st.w	r3[0x0],r10
8000ae3c:	fb 49 06 90 	st.w	sp[1680],r9
8000ae40:	2f f8       	sub	r8,-1
8000ae42:	87 16       	st.w	r3[0x4],r6
8000ae44:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae48:	c0 e8       	rjmp	8000ae64 <_vfprintf_r+0x1dd0>
8000ae4a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae4e:	2f f8       	sub	r8,-1
8000ae50:	30 19       	mov	r9,1
8000ae52:	fb 48 06 90 	st.w	sp[1680],r8
8000ae56:	87 06       	st.w	r3[0x0],r6
8000ae58:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae5c:	87 19       	st.w	r3[0x4],r9
8000ae5e:	2f f8       	sub	r8,-1
8000ae60:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae64:	58 78       	cp.w	r8,7
8000ae66:	e0 89 00 04 	brgt	8000ae6e <_vfprintf_r+0x1dda>
8000ae6a:	2f 83       	sub	r3,-8
8000ae6c:	c0 b8       	rjmp	8000ae82 <_vfprintf_r+0x1dee>
8000ae6e:	fa ca f9 78 	sub	r10,sp,-1672
8000ae72:	02 9b       	mov	r11,r1
8000ae74:	08 9c       	mov	r12,r4
8000ae76:	fe b0 f1 01 	rcall	80009078 <__sprint_r>
8000ae7a:	e0 81 00 8c 	brne	8000af92 <_vfprintf_r+0x1efe>
8000ae7e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ae82:	40 ea       	lddsp	r10,sp[0x38]
8000ae84:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae88:	14 08       	add	r8,r10
8000ae8a:	fa c9 f9 64 	sub	r9,sp,-1692
8000ae8e:	fb 48 06 90 	st.w	sp[1680],r8
8000ae92:	87 1a       	st.w	r3[0x4],r10
8000ae94:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ae98:	87 09       	st.w	r3[0x0],r9
8000ae9a:	2f f8       	sub	r8,-1
8000ae9c:	fb 48 06 8c 	st.w	sp[1676],r8
8000aea0:	58 78       	cp.w	r8,7
8000aea2:	e0 89 00 04 	brgt	8000aeaa <_vfprintf_r+0x1e16>
8000aea6:	2f 83       	sub	r3,-8
8000aea8:	c0 a8       	rjmp	8000aebc <_vfprintf_r+0x1e28>
8000aeaa:	fa ca f9 78 	sub	r10,sp,-1672
8000aeae:	02 9b       	mov	r11,r1
8000aeb0:	08 9c       	mov	r12,r4
8000aeb2:	fe b0 f0 e3 	rcall	80009078 <__sprint_r>
8000aeb6:	c6 e1       	brne	8000af92 <_vfprintf_r+0x1efe>
8000aeb8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aebc:	e2 15 00 04 	andl	r5,0x4,COH
8000aec0:	c3 f0       	breq	8000af3e <_vfprintf_r+0x1eaa>
8000aec2:	40 86       	lddsp	r6,sp[0x20]
8000aec4:	40 39       	lddsp	r9,sp[0xc]
8000aec6:	12 16       	sub	r6,r9
8000aec8:	58 06       	cp.w	r6,0
8000aeca:	e0 89 00 1a 	brgt	8000aefe <_vfprintf_r+0x1e6a>
8000aece:	c3 88       	rjmp	8000af3e <_vfprintf_r+0x1eaa>
8000aed0:	2f 09       	sub	r9,-16
8000aed2:	2f f8       	sub	r8,-1
8000aed4:	fb 49 06 90 	st.w	sp[1680],r9
8000aed8:	87 05       	st.w	r3[0x0],r5
8000aeda:	87 12       	st.w	r3[0x4],r2
8000aedc:	fb 48 06 8c 	st.w	sp[1676],r8
8000aee0:	58 78       	cp.w	r8,7
8000aee2:	e0 89 00 04 	brgt	8000aeea <_vfprintf_r+0x1e56>
8000aee6:	2f 83       	sub	r3,-8
8000aee8:	c0 98       	rjmp	8000aefa <_vfprintf_r+0x1e66>
8000aeea:	00 9a       	mov	r10,r0
8000aeec:	02 9b       	mov	r11,r1
8000aeee:	08 9c       	mov	r12,r4
8000aef0:	fe b0 f0 c4 	rcall	80009078 <__sprint_r>
8000aef4:	c4 f1       	brne	8000af92 <_vfprintf_r+0x1efe>
8000aef6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aefa:	21 06       	sub	r6,16
8000aefc:	c0 68       	rjmp	8000af08 <_vfprintf_r+0x1e74>
8000aefe:	fe c5 bb aa 	sub	r5,pc,-17494
8000af02:	31 02       	mov	r2,16
8000af04:	fa c0 f9 78 	sub	r0,sp,-1672
8000af08:	fa f9 06 90 	ld.w	r9,sp[1680]
8000af0c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000af10:	fe ca bb bc 	sub	r10,pc,-17476
8000af14:	59 06       	cp.w	r6,16
8000af16:	fe 99 ff dd 	brgt	8000aed0 <_vfprintf_r+0x1e3c>
8000af1a:	0c 09       	add	r9,r6
8000af1c:	2f f8       	sub	r8,-1
8000af1e:	87 0a       	st.w	r3[0x0],r10
8000af20:	87 16       	st.w	r3[0x4],r6
8000af22:	fb 49 06 90 	st.w	sp[1680],r9
8000af26:	fb 48 06 8c 	st.w	sp[1676],r8
8000af2a:	58 78       	cp.w	r8,7
8000af2c:	e0 8a 00 09 	brle	8000af3e <_vfprintf_r+0x1eaa>
8000af30:	fa ca f9 78 	sub	r10,sp,-1672
8000af34:	02 9b       	mov	r11,r1
8000af36:	08 9c       	mov	r12,r4
8000af38:	fe b0 f0 a0 	rcall	80009078 <__sprint_r>
8000af3c:	c2 b1       	brne	8000af92 <_vfprintf_r+0x1efe>
8000af3e:	40 bc       	lddsp	r12,sp[0x2c]
8000af40:	40 36       	lddsp	r6,sp[0xc]
8000af42:	40 8e       	lddsp	lr,sp[0x20]
8000af44:	ec 0e 0c 48 	max	r8,r6,lr
8000af48:	10 0c       	add	r12,r8
8000af4a:	50 bc       	stdsp	sp[0x2c],r12
8000af4c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af50:	58 08       	cp.w	r8,0
8000af52:	c0 80       	breq	8000af62 <_vfprintf_r+0x1ece>
8000af54:	fa ca f9 78 	sub	r10,sp,-1672
8000af58:	02 9b       	mov	r11,r1
8000af5a:	08 9c       	mov	r12,r4
8000af5c:	fe b0 f0 8e 	rcall	80009078 <__sprint_r>
8000af60:	c1 91       	brne	8000af92 <_vfprintf_r+0x1efe>
8000af62:	30 0b       	mov	r11,0
8000af64:	fa c3 f9 e0 	sub	r3,sp,-1568
8000af68:	fb 4b 06 8c 	st.w	sp[1676],r11
8000af6c:	fe 9f f1 22 	bral	800091b0 <_vfprintf_r+0x11c>
8000af70:	08 95       	mov	r5,r4
8000af72:	fa f8 06 90 	ld.w	r8,sp[1680]
8000af76:	58 08       	cp.w	r8,0
8000af78:	c0 80       	breq	8000af88 <_vfprintf_r+0x1ef4>
8000af7a:	08 9c       	mov	r12,r4
8000af7c:	fa ca f9 78 	sub	r10,sp,-1672
8000af80:	02 9b       	mov	r11,r1
8000af82:	fe b0 f0 7b 	rcall	80009078 <__sprint_r>
8000af86:	c0 61       	brne	8000af92 <_vfprintf_r+0x1efe>
8000af88:	30 08       	mov	r8,0
8000af8a:	fb 48 06 8c 	st.w	sp[1676],r8
8000af8e:	c0 28       	rjmp	8000af92 <_vfprintf_r+0x1efe>
8000af90:	40 41       	lddsp	r1,sp[0x10]
8000af92:	82 68       	ld.sh	r8,r1[0xc]
8000af94:	ed b8 00 06 	bld	r8,0x6
8000af98:	c0 31       	brne	8000af9e <_vfprintf_r+0x1f0a>
8000af9a:	3f fa       	mov	r10,-1
8000af9c:	50 ba       	stdsp	sp[0x2c],r10
8000af9e:	40 bc       	lddsp	r12,sp[0x2c]
8000afa0:	fe 3d f9 44 	sub	sp,-1724
8000afa4:	d8 32       	popm	r0-r7,pc
8000afa6:	d7 03       	nop

8000afa8 <__swsetup_r>:
8000afa8:	d4 21       	pushm	r4-r7,lr
8000afaa:	e0 68 0a 54 	mov	r8,2644
8000afae:	18 96       	mov	r6,r12
8000afb0:	16 97       	mov	r7,r11
8000afb2:	70 0c       	ld.w	r12,r8[0x0]
8000afb4:	58 0c       	cp.w	r12,0
8000afb6:	c0 60       	breq	8000afc2 <__swsetup_r+0x1a>
8000afb8:	78 68       	ld.w	r8,r12[0x18]
8000afba:	58 08       	cp.w	r8,0
8000afbc:	c0 31       	brne	8000afc2 <__swsetup_r+0x1a>
8000afbe:	e0 a0 07 bf 	rcall	8000bf3c <__sinit>
8000afc2:	fe c8 bb 3e 	sub	r8,pc,-17602
8000afc6:	10 37       	cp.w	r7,r8
8000afc8:	c0 61       	brne	8000afd4 <__swsetup_r+0x2c>
8000afca:	e0 68 0a 54 	mov	r8,2644
8000afce:	70 08       	ld.w	r8,r8[0x0]
8000afd0:	70 07       	ld.w	r7,r8[0x0]
8000afd2:	c1 28       	rjmp	8000aff6 <__swsetup_r+0x4e>
8000afd4:	fe c8 bb 30 	sub	r8,pc,-17616
8000afd8:	10 37       	cp.w	r7,r8
8000afda:	c0 61       	brne	8000afe6 <__swsetup_r+0x3e>
8000afdc:	e0 68 0a 54 	mov	r8,2644
8000afe0:	70 08       	ld.w	r8,r8[0x0]
8000afe2:	70 17       	ld.w	r7,r8[0x4]
8000afe4:	c0 98       	rjmp	8000aff6 <__swsetup_r+0x4e>
8000afe6:	fe c8 bb 22 	sub	r8,pc,-17630
8000afea:	10 37       	cp.w	r7,r8
8000afec:	c0 51       	brne	8000aff6 <__swsetup_r+0x4e>
8000afee:	e0 68 0a 54 	mov	r8,2644
8000aff2:	70 08       	ld.w	r8,r8[0x0]
8000aff4:	70 27       	ld.w	r7,r8[0x8]
8000aff6:	8e 68       	ld.sh	r8,r7[0xc]
8000aff8:	ed b8 00 03 	bld	r8,0x3
8000affc:	c1 e0       	breq	8000b038 <__swsetup_r+0x90>
8000affe:	ed b8 00 04 	bld	r8,0x4
8000b002:	c3 e1       	brne	8000b07e <__swsetup_r+0xd6>
8000b004:	ed b8 00 02 	bld	r8,0x2
8000b008:	c1 51       	brne	8000b032 <__swsetup_r+0x8a>
8000b00a:	6e db       	ld.w	r11,r7[0x34]
8000b00c:	58 0b       	cp.w	r11,0
8000b00e:	c0 a0       	breq	8000b022 <__swsetup_r+0x7a>
8000b010:	ee c8 ff bc 	sub	r8,r7,-68
8000b014:	10 3b       	cp.w	r11,r8
8000b016:	c0 40       	breq	8000b01e <__swsetup_r+0x76>
8000b018:	0c 9c       	mov	r12,r6
8000b01a:	e0 a0 08 2b 	rcall	8000c070 <_free_r>
8000b01e:	30 08       	mov	r8,0
8000b020:	8f d8       	st.w	r7[0x34],r8
8000b022:	8e 68       	ld.sh	r8,r7[0xc]
8000b024:	e0 18 ff db 	andl	r8,0xffdb
8000b028:	ae 68       	st.h	r7[0xc],r8
8000b02a:	30 08       	mov	r8,0
8000b02c:	8f 18       	st.w	r7[0x4],r8
8000b02e:	6e 48       	ld.w	r8,r7[0x10]
8000b030:	8f 08       	st.w	r7[0x0],r8
8000b032:	8e 68       	ld.sh	r8,r7[0xc]
8000b034:	a3 b8       	sbr	r8,0x3
8000b036:	ae 68       	st.h	r7[0xc],r8
8000b038:	6e 48       	ld.w	r8,r7[0x10]
8000b03a:	58 08       	cp.w	r8,0
8000b03c:	c0 b1       	brne	8000b052 <__swsetup_r+0xaa>
8000b03e:	8e 68       	ld.sh	r8,r7[0xc]
8000b040:	e2 18 02 80 	andl	r8,0x280,COH
8000b044:	e0 48 02 00 	cp.w	r8,512
8000b048:	c0 50       	breq	8000b052 <__swsetup_r+0xaa>
8000b04a:	0c 9c       	mov	r12,r6
8000b04c:	0e 9b       	mov	r11,r7
8000b04e:	e0 a0 0a 4b 	rcall	8000c4e4 <__smakebuf_r>
8000b052:	8e 69       	ld.sh	r9,r7[0xc]
8000b054:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000b058:	c0 70       	breq	8000b066 <__swsetup_r+0xbe>
8000b05a:	30 08       	mov	r8,0
8000b05c:	8f 28       	st.w	r7[0x8],r8
8000b05e:	6e 58       	ld.w	r8,r7[0x14]
8000b060:	5c 38       	neg	r8
8000b062:	8f 68       	st.w	r7[0x18],r8
8000b064:	c0 68       	rjmp	8000b070 <__swsetup_r+0xc8>
8000b066:	ed b9 00 01 	bld	r9,0x1
8000b06a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000b06e:	8f 28       	st.w	r7[0x8],r8
8000b070:	6e 48       	ld.w	r8,r7[0x10]
8000b072:	58 08       	cp.w	r8,0
8000b074:	c0 61       	brne	8000b080 <__swsetup_r+0xd8>
8000b076:	8e 68       	ld.sh	r8,r7[0xc]
8000b078:	ed b8 00 07 	bld	r8,0x7
8000b07c:	c0 21       	brne	8000b080 <__swsetup_r+0xd8>
8000b07e:	dc 2a       	popm	r4-r7,pc,r12=-1
8000b080:	d8 2a       	popm	r4-r7,pc,r12=0
8000b082:	d7 03       	nop

8000b084 <quorem>:
8000b084:	d4 31       	pushm	r0-r7,lr
8000b086:	20 2d       	sub	sp,8
8000b088:	18 97       	mov	r7,r12
8000b08a:	78 48       	ld.w	r8,r12[0x10]
8000b08c:	76 46       	ld.w	r6,r11[0x10]
8000b08e:	0c 38       	cp.w	r8,r6
8000b090:	c0 34       	brge	8000b096 <quorem+0x12>
8000b092:	30 0c       	mov	r12,0
8000b094:	c8 58       	rjmp	8000b19e <quorem+0x11a>
8000b096:	ec c2 ff fc 	sub	r2,r6,-4
8000b09a:	f6 c3 ff ec 	sub	r3,r11,-20
8000b09e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000b0a2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000b0a6:	2f f9       	sub	r9,-1
8000b0a8:	20 16       	sub	r6,1
8000b0aa:	f8 09 0d 08 	divu	r8,r12,r9
8000b0ae:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000b0b2:	ee c4 ff ec 	sub	r4,r7,-20
8000b0b6:	10 95       	mov	r5,r8
8000b0b8:	58 08       	cp.w	r8,0
8000b0ba:	c4 10       	breq	8000b13c <quorem+0xb8>
8000b0bc:	30 09       	mov	r9,0
8000b0be:	06 9a       	mov	r10,r3
8000b0c0:	08 98       	mov	r8,r4
8000b0c2:	12 91       	mov	r1,r9
8000b0c4:	50 0b       	stdsp	sp[0x0],r11
8000b0c6:	70 0e       	ld.w	lr,r8[0x0]
8000b0c8:	b1 8e       	lsr	lr,0x10
8000b0ca:	50 1e       	stdsp	sp[0x4],lr
8000b0cc:	15 0e       	ld.w	lr,r10++
8000b0ce:	fc 00 16 10 	lsr	r0,lr,0x10
8000b0d2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b0d6:	ea 0e 03 41 	mac	r1,r5,lr
8000b0da:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000b0de:	b1 81       	lsr	r1,0x10
8000b0e0:	40 1b       	lddsp	r11,sp[0x4]
8000b0e2:	ea 00 02 40 	mul	r0,r5,r0
8000b0e6:	e2 00 00 00 	add	r0,r1,r0
8000b0ea:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000b0ee:	02 1b       	sub	r11,r1
8000b0f0:	50 1b       	stdsp	sp[0x4],r11
8000b0f2:	70 0b       	ld.w	r11,r8[0x0]
8000b0f4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000b0f8:	02 09       	add	r9,r1
8000b0fa:	f2 0e 01 0e 	sub	lr,r9,lr
8000b0fe:	b0 1e       	st.h	r8[0x2],lr
8000b100:	fc 09 14 10 	asr	r9,lr,0x10
8000b104:	40 1e       	lddsp	lr,sp[0x4]
8000b106:	fc 09 00 09 	add	r9,lr,r9
8000b10a:	b0 09       	st.h	r8[0x0],r9
8000b10c:	e0 01 16 10 	lsr	r1,r0,0x10
8000b110:	2f c8       	sub	r8,-4
8000b112:	b1 49       	asr	r9,0x10
8000b114:	04 3a       	cp.w	r10,r2
8000b116:	fe 98 ff d8 	brls	8000b0c6 <quorem+0x42>
8000b11a:	40 0b       	lddsp	r11,sp[0x0]
8000b11c:	58 0c       	cp.w	r12,0
8000b11e:	c0 f1       	brne	8000b13c <quorem+0xb8>
8000b120:	ec c8 ff fb 	sub	r8,r6,-5
8000b124:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b128:	c0 28       	rjmp	8000b12c <quorem+0xa8>
8000b12a:	20 16       	sub	r6,1
8000b12c:	20 48       	sub	r8,4
8000b12e:	08 38       	cp.w	r8,r4
8000b130:	e0 88 00 05 	brls	8000b13a <quorem+0xb6>
8000b134:	70 09       	ld.w	r9,r8[0x0]
8000b136:	58 09       	cp.w	r9,0
8000b138:	cf 90       	breq	8000b12a <quorem+0xa6>
8000b13a:	8f 46       	st.w	r7[0x10],r6
8000b13c:	0e 9c       	mov	r12,r7
8000b13e:	e0 a0 0a d2 	rcall	8000c6e2 <__mcmp>
8000b142:	c2 d5       	brlt	8000b19c <quorem+0x118>
8000b144:	2f f5       	sub	r5,-1
8000b146:	08 98       	mov	r8,r4
8000b148:	30 09       	mov	r9,0
8000b14a:	07 0b       	ld.w	r11,r3++
8000b14c:	f6 0a 16 10 	lsr	r10,r11,0x10
8000b150:	70 0c       	ld.w	r12,r8[0x0]
8000b152:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b156:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b15a:	14 1e       	sub	lr,r10
8000b15c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b160:	16 1a       	sub	r10,r11
8000b162:	12 0a       	add	r10,r9
8000b164:	b0 1a       	st.h	r8[0x2],r10
8000b166:	b1 4a       	asr	r10,0x10
8000b168:	fc 0a 00 09 	add	r9,lr,r10
8000b16c:	b0 09       	st.h	r8[0x0],r9
8000b16e:	2f c8       	sub	r8,-4
8000b170:	b1 49       	asr	r9,0x10
8000b172:	04 33       	cp.w	r3,r2
8000b174:	fe 98 ff eb 	brls	8000b14a <quorem+0xc6>
8000b178:	ec c8 ff fb 	sub	r8,r6,-5
8000b17c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000b180:	58 09       	cp.w	r9,0
8000b182:	c0 d1       	brne	8000b19c <quorem+0x118>
8000b184:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b188:	c0 28       	rjmp	8000b18c <quorem+0x108>
8000b18a:	20 16       	sub	r6,1
8000b18c:	20 48       	sub	r8,4
8000b18e:	08 38       	cp.w	r8,r4
8000b190:	e0 88 00 05 	brls	8000b19a <quorem+0x116>
8000b194:	70 09       	ld.w	r9,r8[0x0]
8000b196:	58 09       	cp.w	r9,0
8000b198:	cf 90       	breq	8000b18a <quorem+0x106>
8000b19a:	8f 46       	st.w	r7[0x10],r6
8000b19c:	0a 9c       	mov	r12,r5
8000b19e:	2f ed       	sub	sp,-8
8000b1a0:	d8 32       	popm	r0-r7,pc
8000b1a2:	d7 03       	nop

8000b1a4 <_dtoa_r>:
8000b1a4:	d4 31       	pushm	r0-r7,lr
8000b1a6:	21 ad       	sub	sp,104
8000b1a8:	fa c4 ff 74 	sub	r4,sp,-140
8000b1ac:	18 97       	mov	r7,r12
8000b1ae:	16 95       	mov	r5,r11
8000b1b0:	68 2c       	ld.w	r12,r4[0x8]
8000b1b2:	50 c9       	stdsp	sp[0x30],r9
8000b1b4:	68 16       	ld.w	r6,r4[0x4]
8000b1b6:	68 09       	ld.w	r9,r4[0x0]
8000b1b8:	50 e8       	stdsp	sp[0x38],r8
8000b1ba:	14 94       	mov	r4,r10
8000b1bc:	51 2c       	stdsp	sp[0x48],r12
8000b1be:	fa e5 00 08 	st.d	sp[8],r4
8000b1c2:	51 59       	stdsp	sp[0x54],r9
8000b1c4:	6e 95       	ld.w	r5,r7[0x24]
8000b1c6:	58 05       	cp.w	r5,0
8000b1c8:	c0 91       	brne	8000b1da <_dtoa_r+0x36>
8000b1ca:	31 0c       	mov	r12,16
8000b1cc:	fe b0 e8 e2 	rcall	80008390 <malloc>
8000b1d0:	99 35       	st.w	r12[0xc],r5
8000b1d2:	8f 9c       	st.w	r7[0x24],r12
8000b1d4:	99 15       	st.w	r12[0x4],r5
8000b1d6:	99 25       	st.w	r12[0x8],r5
8000b1d8:	99 05       	st.w	r12[0x0],r5
8000b1da:	6e 99       	ld.w	r9,r7[0x24]
8000b1dc:	72 08       	ld.w	r8,r9[0x0]
8000b1de:	58 08       	cp.w	r8,0
8000b1e0:	c0 f0       	breq	8000b1fe <_dtoa_r+0x5a>
8000b1e2:	72 1a       	ld.w	r10,r9[0x4]
8000b1e4:	91 1a       	st.w	r8[0x4],r10
8000b1e6:	30 1a       	mov	r10,1
8000b1e8:	72 19       	ld.w	r9,r9[0x4]
8000b1ea:	f4 09 09 49 	lsl	r9,r10,r9
8000b1ee:	10 9b       	mov	r11,r8
8000b1f0:	91 29       	st.w	r8[0x8],r9
8000b1f2:	0e 9c       	mov	r12,r7
8000b1f4:	e0 a0 0a 90 	rcall	8000c714 <_Bfree>
8000b1f8:	6e 98       	ld.w	r8,r7[0x24]
8000b1fa:	30 09       	mov	r9,0
8000b1fc:	91 09       	st.w	r8[0x0],r9
8000b1fe:	40 28       	lddsp	r8,sp[0x8]
8000b200:	10 94       	mov	r4,r8
8000b202:	58 08       	cp.w	r8,0
8000b204:	c0 64       	brge	8000b210 <_dtoa_r+0x6c>
8000b206:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000b20a:	50 28       	stdsp	sp[0x8],r8
8000b20c:	30 18       	mov	r8,1
8000b20e:	c0 28       	rjmp	8000b212 <_dtoa_r+0x6e>
8000b210:	30 08       	mov	r8,0
8000b212:	8d 08       	st.w	r6[0x0],r8
8000b214:	fc 1c 7f f0 	movh	r12,0x7ff0
8000b218:	40 26       	lddsp	r6,sp[0x8]
8000b21a:	0c 98       	mov	r8,r6
8000b21c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b220:	18 38       	cp.w	r8,r12
8000b222:	c2 01       	brne	8000b262 <_dtoa_r+0xbe>
8000b224:	e0 68 27 0f 	mov	r8,9999
8000b228:	41 5b       	lddsp	r11,sp[0x54]
8000b22a:	97 08       	st.w	r11[0x0],r8
8000b22c:	40 3a       	lddsp	r10,sp[0xc]
8000b22e:	58 0a       	cp.w	r10,0
8000b230:	c0 71       	brne	8000b23e <_dtoa_r+0x9a>
8000b232:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000b236:	c0 41       	brne	8000b23e <_dtoa_r+0x9a>
8000b238:	fe cc bd c4 	sub	r12,pc,-16956
8000b23c:	c0 38       	rjmp	8000b242 <_dtoa_r+0x9e>
8000b23e:	fe cc bd be 	sub	r12,pc,-16962
8000b242:	41 29       	lddsp	r9,sp[0x48]
8000b244:	58 09       	cp.w	r9,0
8000b246:	e0 80 05 9a 	breq	8000bd7a <_dtoa_r+0xbd6>
8000b24a:	f8 c8 ff fd 	sub	r8,r12,-3
8000b24e:	f8 c9 ff f8 	sub	r9,r12,-8
8000b252:	11 8b       	ld.ub	r11,r8[0x0]
8000b254:	30 0a       	mov	r10,0
8000b256:	41 25       	lddsp	r5,sp[0x48]
8000b258:	f4 0b 18 00 	cp.b	r11,r10
8000b25c:	f2 08 17 10 	movne	r8,r9
8000b260:	c1 68       	rjmp	8000b28c <_dtoa_r+0xe8>
8000b262:	fa ea 00 08 	ld.d	r10,sp[8]
8000b266:	30 08       	mov	r8,0
8000b268:	fa eb 00 3c 	st.d	sp[60],r10
8000b26c:	30 09       	mov	r9,0
8000b26e:	e0 a0 10 ce 	rcall	8000d40a <__avr32_f64_cmp_eq>
8000b272:	c1 00       	breq	8000b292 <_dtoa_r+0xee>
8000b274:	30 18       	mov	r8,1
8000b276:	41 5a       	lddsp	r10,sp[0x54]
8000b278:	95 08       	st.w	r10[0x0],r8
8000b27a:	fe cc bf 2a 	sub	r12,pc,-16598
8000b27e:	41 29       	lddsp	r9,sp[0x48]
8000b280:	f8 08 00 08 	add	r8,r12,r8
8000b284:	58 09       	cp.w	r9,0
8000b286:	e0 80 05 7a 	breq	8000bd7a <_dtoa_r+0xbd6>
8000b28a:	12 95       	mov	r5,r9
8000b28c:	8b 08       	st.w	r5[0x0],r8
8000b28e:	e0 8f 05 76 	bral	8000bd7a <_dtoa_r+0xbd6>
8000b292:	fa c8 ff 9c 	sub	r8,sp,-100
8000b296:	fa c9 ff a0 	sub	r9,sp,-96
8000b29a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b29e:	0e 9c       	mov	r12,r7
8000b2a0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000b2a4:	e0 a0 0a 8a 	rcall	8000c7b8 <__d2b>
8000b2a8:	18 93       	mov	r3,r12
8000b2aa:	58 05       	cp.w	r5,0
8000b2ac:	c0 d0       	breq	8000b2c6 <_dtoa_r+0x122>
8000b2ae:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b2b2:	30 04       	mov	r4,0
8000b2b4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000b2b8:	ea c5 03 ff 	sub	r5,r5,1023
8000b2bc:	10 9b       	mov	r11,r8
8000b2be:	51 74       	stdsp	sp[0x5c],r4
8000b2c0:	ea 1b 3f f0 	orh	r11,0x3ff0
8000b2c4:	c2 58       	rjmp	8000b30e <_dtoa_r+0x16a>
8000b2c6:	41 88       	lddsp	r8,sp[0x60]
8000b2c8:	41 9c       	lddsp	r12,sp[0x64]
8000b2ca:	10 0c       	add	r12,r8
8000b2cc:	f8 c5 fb ce 	sub	r5,r12,-1074
8000b2d0:	e0 45 00 20 	cp.w	r5,32
8000b2d4:	e0 8a 00 0e 	brle	8000b2f0 <_dtoa_r+0x14c>
8000b2d8:	f8 cc fb ee 	sub	r12,r12,-1042
8000b2dc:	40 3b       	lddsp	r11,sp[0xc]
8000b2de:	ea 08 11 40 	rsub	r8,r5,64
8000b2e2:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000b2e6:	ec 08 09 46 	lsl	r6,r6,r8
8000b2ea:	0c 4c       	or	r12,r6
8000b2ec:	c0 78       	rjmp	8000b2fa <_dtoa_r+0x156>
8000b2ee:	d7 03       	nop
8000b2f0:	ea 0c 11 20 	rsub	r12,r5,32
8000b2f4:	40 3a       	lddsp	r10,sp[0xc]
8000b2f6:	f4 0c 09 4c 	lsl	r12,r10,r12
8000b2fa:	e0 a0 10 14 	rcall	8000d322 <__avr32_u32_to_f64>
8000b2fe:	fc 18 fe 10 	movh	r8,0xfe10
8000b302:	30 19       	mov	r9,1
8000b304:	ea c5 04 33 	sub	r5,r5,1075
8000b308:	f0 0b 00 0b 	add	r11,r8,r11
8000b30c:	51 79       	stdsp	sp[0x5c],r9
8000b30e:	30 08       	mov	r8,0
8000b310:	fc 19 3f f8 	movh	r9,0x3ff8
8000b314:	e0 a0 0e 9c 	rcall	8000d04c <__avr32_f64_sub>
8000b318:	e0 68 43 61 	mov	r8,17249
8000b31c:	ea 18 63 6f 	orh	r8,0x636f
8000b320:	e0 69 87 a7 	mov	r9,34727
8000b324:	ea 19 3f d2 	orh	r9,0x3fd2
8000b328:	e0 a0 0d a6 	rcall	8000ce74 <__avr32_f64_mul>
8000b32c:	e0 68 c8 b3 	mov	r8,51379
8000b330:	ea 18 8b 60 	orh	r8,0x8b60
8000b334:	e0 69 8a 28 	mov	r9,35368
8000b338:	ea 19 3f c6 	orh	r9,0x3fc6
8000b33c:	e0 a0 0f 56 	rcall	8000d1e8 <__avr32_f64_add>
8000b340:	0a 9c       	mov	r12,r5
8000b342:	14 90       	mov	r0,r10
8000b344:	16 91       	mov	r1,r11
8000b346:	e0 a0 0f f2 	rcall	8000d32a <__avr32_s32_to_f64>
8000b34a:	e0 68 79 fb 	mov	r8,31227
8000b34e:	ea 18 50 9f 	orh	r8,0x509f
8000b352:	e0 69 44 13 	mov	r9,17427
8000b356:	ea 19 3f d3 	orh	r9,0x3fd3
8000b35a:	e0 a0 0d 8d 	rcall	8000ce74 <__avr32_f64_mul>
8000b35e:	14 98       	mov	r8,r10
8000b360:	16 99       	mov	r9,r11
8000b362:	00 9a       	mov	r10,r0
8000b364:	02 9b       	mov	r11,r1
8000b366:	e0 a0 0f 41 	rcall	8000d1e8 <__avr32_f64_add>
8000b36a:	14 90       	mov	r0,r10
8000b36c:	16 91       	mov	r1,r11
8000b36e:	e0 a0 0f c7 	rcall	8000d2fc <__avr32_f64_to_s32>
8000b372:	30 08       	mov	r8,0
8000b374:	18 96       	mov	r6,r12
8000b376:	30 09       	mov	r9,0
8000b378:	00 9a       	mov	r10,r0
8000b37a:	02 9b       	mov	r11,r1
8000b37c:	e0 a0 10 8e 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b380:	c0 c0       	breq	8000b398 <_dtoa_r+0x1f4>
8000b382:	0c 9c       	mov	r12,r6
8000b384:	e0 a0 0f d3 	rcall	8000d32a <__avr32_s32_to_f64>
8000b388:	14 98       	mov	r8,r10
8000b38a:	16 99       	mov	r9,r11
8000b38c:	00 9a       	mov	r10,r0
8000b38e:	02 9b       	mov	r11,r1
8000b390:	e0 a0 10 3d 	rcall	8000d40a <__avr32_f64_cmp_eq>
8000b394:	f7 b6 00 01 	subeq	r6,1
8000b398:	59 66       	cp.w	r6,22
8000b39a:	e0 88 00 05 	brls	8000b3a4 <_dtoa_r+0x200>
8000b39e:	30 18       	mov	r8,1
8000b3a0:	51 48       	stdsp	sp[0x50],r8
8000b3a2:	c1 38       	rjmp	8000b3c8 <_dtoa_r+0x224>
8000b3a4:	fe c8 be 70 	sub	r8,pc,-16784
8000b3a8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b3ac:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000b3b0:	e0 a0 10 74 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b3b4:	f9 b4 00 00 	moveq	r4,0
8000b3b8:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000b3bc:	f7 b6 01 01 	subne	r6,1
8000b3c0:	f9 bc 01 00 	movne	r12,0
8000b3c4:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000b3c8:	41 90       	lddsp	r0,sp[0x64]
8000b3ca:	20 10       	sub	r0,1
8000b3cc:	0a 10       	sub	r0,r5
8000b3ce:	c0 46       	brmi	8000b3d6 <_dtoa_r+0x232>
8000b3d0:	50 40       	stdsp	sp[0x10],r0
8000b3d2:	30 00       	mov	r0,0
8000b3d4:	c0 48       	rjmp	8000b3dc <_dtoa_r+0x238>
8000b3d6:	30 0b       	mov	r11,0
8000b3d8:	5c 30       	neg	r0
8000b3da:	50 4b       	stdsp	sp[0x10],r11
8000b3dc:	ec 02 11 00 	rsub	r2,r6,0
8000b3e0:	58 06       	cp.w	r6,0
8000b3e2:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000b3e6:	f5 d6 e4 0a 	addge	r10,r10,r6
8000b3ea:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000b3ee:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000b3f2:	f9 b2 04 00 	movge	r2,0
8000b3f6:	e1 d6 e5 10 	sublt	r0,r0,r6
8000b3fa:	f9 b9 05 00 	movlt	r9,0
8000b3fe:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000b402:	40 c8       	lddsp	r8,sp[0x30]
8000b404:	58 98       	cp.w	r8,9
8000b406:	e0 8b 00 20 	brhi	8000b446 <_dtoa_r+0x2a2>
8000b40a:	58 58       	cp.w	r8,5
8000b40c:	f9 b4 0a 01 	movle	r4,1
8000b410:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000b414:	f7 b5 09 04 	subgt	r5,4
8000b418:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000b41c:	f9 b4 09 00 	movgt	r4,0
8000b420:	40 cc       	lddsp	r12,sp[0x30]
8000b422:	58 3c       	cp.w	r12,3
8000b424:	c2 d0       	breq	8000b47e <_dtoa_r+0x2da>
8000b426:	e0 89 00 05 	brgt	8000b430 <_dtoa_r+0x28c>
8000b42a:	58 2c       	cp.w	r12,2
8000b42c:	c1 01       	brne	8000b44c <_dtoa_r+0x2a8>
8000b42e:	c1 88       	rjmp	8000b45e <_dtoa_r+0x2ba>
8000b430:	40 cb       	lddsp	r11,sp[0x30]
8000b432:	58 4b       	cp.w	r11,4
8000b434:	c0 60       	breq	8000b440 <_dtoa_r+0x29c>
8000b436:	58 5b       	cp.w	r11,5
8000b438:	c0 a1       	brne	8000b44c <_dtoa_r+0x2a8>
8000b43a:	30 1a       	mov	r10,1
8000b43c:	50 da       	stdsp	sp[0x34],r10
8000b43e:	c2 28       	rjmp	8000b482 <_dtoa_r+0x2de>
8000b440:	30 19       	mov	r9,1
8000b442:	50 d9       	stdsp	sp[0x34],r9
8000b444:	c0 f8       	rjmp	8000b462 <_dtoa_r+0x2be>
8000b446:	30 08       	mov	r8,0
8000b448:	30 14       	mov	r4,1
8000b44a:	50 c8       	stdsp	sp[0x30],r8
8000b44c:	3f f5       	mov	r5,-1
8000b44e:	30 1c       	mov	r12,1
8000b450:	30 0b       	mov	r11,0
8000b452:	50 95       	stdsp	sp[0x24],r5
8000b454:	50 dc       	stdsp	sp[0x34],r12
8000b456:	0a 91       	mov	r1,r5
8000b458:	31 28       	mov	r8,18
8000b45a:	50 eb       	stdsp	sp[0x38],r11
8000b45c:	c2 08       	rjmp	8000b49c <_dtoa_r+0x2f8>
8000b45e:	30 0a       	mov	r10,0
8000b460:	50 da       	stdsp	sp[0x34],r10
8000b462:	40 e9       	lddsp	r9,sp[0x38]
8000b464:	58 09       	cp.w	r9,0
8000b466:	e0 89 00 07 	brgt	8000b474 <_dtoa_r+0x2d0>
8000b46a:	30 18       	mov	r8,1
8000b46c:	50 98       	stdsp	sp[0x24],r8
8000b46e:	10 91       	mov	r1,r8
8000b470:	50 e8       	stdsp	sp[0x38],r8
8000b472:	c1 58       	rjmp	8000b49c <_dtoa_r+0x2f8>
8000b474:	40 e5       	lddsp	r5,sp[0x38]
8000b476:	50 95       	stdsp	sp[0x24],r5
8000b478:	0a 91       	mov	r1,r5
8000b47a:	0a 98       	mov	r8,r5
8000b47c:	c1 08       	rjmp	8000b49c <_dtoa_r+0x2f8>
8000b47e:	30 0c       	mov	r12,0
8000b480:	50 dc       	stdsp	sp[0x34],r12
8000b482:	40 eb       	lddsp	r11,sp[0x38]
8000b484:	ec 0b 00 0b 	add	r11,r6,r11
8000b488:	50 9b       	stdsp	sp[0x24],r11
8000b48a:	16 98       	mov	r8,r11
8000b48c:	2f f8       	sub	r8,-1
8000b48e:	58 08       	cp.w	r8,0
8000b490:	e0 89 00 05 	brgt	8000b49a <_dtoa_r+0x2f6>
8000b494:	10 91       	mov	r1,r8
8000b496:	30 18       	mov	r8,1
8000b498:	c0 28       	rjmp	8000b49c <_dtoa_r+0x2f8>
8000b49a:	10 91       	mov	r1,r8
8000b49c:	30 09       	mov	r9,0
8000b49e:	6e 9a       	ld.w	r10,r7[0x24]
8000b4a0:	95 19       	st.w	r10[0x4],r9
8000b4a2:	30 49       	mov	r9,4
8000b4a4:	c0 68       	rjmp	8000b4b0 <_dtoa_r+0x30c>
8000b4a6:	d7 03       	nop
8000b4a8:	6a 1a       	ld.w	r10,r5[0x4]
8000b4aa:	a1 79       	lsl	r9,0x1
8000b4ac:	2f fa       	sub	r10,-1
8000b4ae:	8b 1a       	st.w	r5[0x4],r10
8000b4b0:	6e 95       	ld.w	r5,r7[0x24]
8000b4b2:	f2 ca ff ec 	sub	r10,r9,-20
8000b4b6:	10 3a       	cp.w	r10,r8
8000b4b8:	fe 98 ff f8 	brls	8000b4a8 <_dtoa_r+0x304>
8000b4bc:	6a 1b       	ld.w	r11,r5[0x4]
8000b4be:	0e 9c       	mov	r12,r7
8000b4c0:	e0 a0 09 44 	rcall	8000c748 <_Balloc>
8000b4c4:	58 e1       	cp.w	r1,14
8000b4c6:	5f 88       	srls	r8
8000b4c8:	8b 0c       	st.w	r5[0x0],r12
8000b4ca:	f1 e4 00 04 	and	r4,r8,r4
8000b4ce:	6e 98       	ld.w	r8,r7[0x24]
8000b4d0:	70 08       	ld.w	r8,r8[0x0]
8000b4d2:	50 88       	stdsp	sp[0x20],r8
8000b4d4:	e0 80 01 82 	breq	8000b7d8 <_dtoa_r+0x634>
8000b4d8:	58 06       	cp.w	r6,0
8000b4da:	e0 8a 00 43 	brle	8000b560 <_dtoa_r+0x3bc>
8000b4de:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000b4e2:	fe c8 bf ae 	sub	r8,pc,-16466
8000b4e6:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000b4ea:	fa e5 00 18 	st.d	sp[24],r4
8000b4ee:	ec 04 14 04 	asr	r4,r6,0x4
8000b4f2:	ed b4 00 04 	bld	r4,0x4
8000b4f6:	c0 30       	breq	8000b4fc <_dtoa_r+0x358>
8000b4f8:	30 25       	mov	r5,2
8000b4fa:	c1 08       	rjmp	8000b51a <_dtoa_r+0x376>
8000b4fc:	fe c8 bf 00 	sub	r8,pc,-16640
8000b500:	f0 e8 00 20 	ld.d	r8,r8[32]
8000b504:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b508:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000b50c:	e0 a0 0f fa 	rcall	8000d500 <__avr32_f64_div>
8000b510:	30 35       	mov	r5,3
8000b512:	14 98       	mov	r8,r10
8000b514:	16 99       	mov	r9,r11
8000b516:	fa e9 00 08 	st.d	sp[8],r8
8000b51a:	fe cc bf 1e 	sub	r12,pc,-16610
8000b51e:	50 a3       	stdsp	sp[0x28],r3
8000b520:	0c 93       	mov	r3,r6
8000b522:	18 96       	mov	r6,r12
8000b524:	c0 f8       	rjmp	8000b542 <_dtoa_r+0x39e>
8000b526:	fa ea 00 18 	ld.d	r10,sp[24]
8000b52a:	ed b4 00 00 	bld	r4,0x0
8000b52e:	c0 81       	brne	8000b53e <_dtoa_r+0x39a>
8000b530:	ec e8 00 00 	ld.d	r8,r6[0]
8000b534:	2f f5       	sub	r5,-1
8000b536:	e0 a0 0c 9f 	rcall	8000ce74 <__avr32_f64_mul>
8000b53a:	fa eb 00 18 	st.d	sp[24],r10
8000b53e:	a1 54       	asr	r4,0x1
8000b540:	2f 86       	sub	r6,-8
8000b542:	58 04       	cp.w	r4,0
8000b544:	cf 11       	brne	8000b526 <_dtoa_r+0x382>
8000b546:	fa e8 00 18 	ld.d	r8,sp[24]
8000b54a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b54e:	06 96       	mov	r6,r3
8000b550:	e0 a0 0f d8 	rcall	8000d500 <__avr32_f64_div>
8000b554:	40 a3       	lddsp	r3,sp[0x28]
8000b556:	14 98       	mov	r8,r10
8000b558:	16 99       	mov	r9,r11
8000b55a:	fa e9 00 08 	st.d	sp[8],r8
8000b55e:	c2 f8       	rjmp	8000b5bc <_dtoa_r+0x418>
8000b560:	ec 08 11 00 	rsub	r8,r6,0
8000b564:	c0 31       	brne	8000b56a <_dtoa_r+0x3c6>
8000b566:	30 25       	mov	r5,2
8000b568:	c2 a8       	rjmp	8000b5bc <_dtoa_r+0x418>
8000b56a:	fe cc bf 6e 	sub	r12,pc,-16530
8000b56e:	f0 04 14 04 	asr	r4,r8,0x4
8000b572:	50 1c       	stdsp	sp[0x4],r12
8000b574:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000b578:	fe c9 c0 44 	sub	r9,pc,-16316
8000b57c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b580:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b584:	e0 a0 0c 78 	rcall	8000ce74 <__avr32_f64_mul>
8000b588:	40 1c       	lddsp	r12,sp[0x4]
8000b58a:	50 63       	stdsp	sp[0x18],r3
8000b58c:	30 25       	mov	r5,2
8000b58e:	0c 93       	mov	r3,r6
8000b590:	fa eb 00 08 	st.d	sp[8],r10
8000b594:	18 96       	mov	r6,r12
8000b596:	c0 f8       	rjmp	8000b5b4 <_dtoa_r+0x410>
8000b598:	fa ea 00 08 	ld.d	r10,sp[8]
8000b59c:	ed b4 00 00 	bld	r4,0x0
8000b5a0:	c0 81       	brne	8000b5b0 <_dtoa_r+0x40c>
8000b5a2:	ec e8 00 00 	ld.d	r8,r6[0]
8000b5a6:	2f f5       	sub	r5,-1
8000b5a8:	e0 a0 0c 66 	rcall	8000ce74 <__avr32_f64_mul>
8000b5ac:	fa eb 00 08 	st.d	sp[8],r10
8000b5b0:	a1 54       	asr	r4,0x1
8000b5b2:	2f 86       	sub	r6,-8
8000b5b4:	58 04       	cp.w	r4,0
8000b5b6:	cf 11       	brne	8000b598 <_dtoa_r+0x3f4>
8000b5b8:	06 96       	mov	r6,r3
8000b5ba:	40 63       	lddsp	r3,sp[0x18]
8000b5bc:	41 4a       	lddsp	r10,sp[0x50]
8000b5be:	58 0a       	cp.w	r10,0
8000b5c0:	c2 a0       	breq	8000b614 <_dtoa_r+0x470>
8000b5c2:	fa e8 00 08 	ld.d	r8,sp[8]
8000b5c6:	58 01       	cp.w	r1,0
8000b5c8:	5f 94       	srgt	r4
8000b5ca:	fa e9 00 18 	st.d	sp[24],r8
8000b5ce:	30 08       	mov	r8,0
8000b5d0:	fc 19 3f f0 	movh	r9,0x3ff0
8000b5d4:	fa ea 00 18 	ld.d	r10,sp[24]
8000b5d8:	e0 a0 0f 60 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b5dc:	f9 bc 00 00 	moveq	r12,0
8000b5e0:	f9 bc 01 01 	movne	r12,1
8000b5e4:	e9 ec 00 0c 	and	r12,r4,r12
8000b5e8:	c1 60       	breq	8000b614 <_dtoa_r+0x470>
8000b5ea:	40 98       	lddsp	r8,sp[0x24]
8000b5ec:	58 08       	cp.w	r8,0
8000b5ee:	e0 8a 00 f1 	brle	8000b7d0 <_dtoa_r+0x62c>
8000b5f2:	30 08       	mov	r8,0
8000b5f4:	fc 19 40 24 	movh	r9,0x4024
8000b5f8:	ec c4 00 01 	sub	r4,r6,1
8000b5fc:	fa ea 00 18 	ld.d	r10,sp[24]
8000b600:	2f f5       	sub	r5,-1
8000b602:	50 64       	stdsp	sp[0x18],r4
8000b604:	e0 a0 0c 38 	rcall	8000ce74 <__avr32_f64_mul>
8000b608:	40 94       	lddsp	r4,sp[0x24]
8000b60a:	14 98       	mov	r8,r10
8000b60c:	16 99       	mov	r9,r11
8000b60e:	fa e9 00 08 	st.d	sp[8],r8
8000b612:	c0 38       	rjmp	8000b618 <_dtoa_r+0x474>
8000b614:	50 66       	stdsp	sp[0x18],r6
8000b616:	02 94       	mov	r4,r1
8000b618:	0a 9c       	mov	r12,r5
8000b61a:	e0 a0 0e 88 	rcall	8000d32a <__avr32_s32_to_f64>
8000b61e:	fa e8 00 08 	ld.d	r8,sp[8]
8000b622:	e0 a0 0c 29 	rcall	8000ce74 <__avr32_f64_mul>
8000b626:	30 08       	mov	r8,0
8000b628:	fc 19 40 1c 	movh	r9,0x401c
8000b62c:	e0 a0 0d de 	rcall	8000d1e8 <__avr32_f64_add>
8000b630:	14 98       	mov	r8,r10
8000b632:	16 99       	mov	r9,r11
8000b634:	fa e9 00 28 	st.d	sp[40],r8
8000b638:	fc 18 fc c0 	movh	r8,0xfcc0
8000b63c:	40 a5       	lddsp	r5,sp[0x28]
8000b63e:	10 05       	add	r5,r8
8000b640:	50 a5       	stdsp	sp[0x28],r5
8000b642:	58 04       	cp.w	r4,0
8000b644:	c2 11       	brne	8000b686 <_dtoa_r+0x4e2>
8000b646:	fa ea 00 08 	ld.d	r10,sp[8]
8000b64a:	30 08       	mov	r8,0
8000b64c:	fc 19 40 14 	movh	r9,0x4014
8000b650:	e0 a0 0c fe 	rcall	8000d04c <__avr32_f64_sub>
8000b654:	40 bc       	lddsp	r12,sp[0x2c]
8000b656:	fa eb 00 08 	st.d	sp[8],r10
8000b65a:	14 98       	mov	r8,r10
8000b65c:	16 99       	mov	r9,r11
8000b65e:	18 9a       	mov	r10,r12
8000b660:	0a 9b       	mov	r11,r5
8000b662:	e0 a0 0f 1b 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b666:	e0 81 02 54 	brne	8000bb0e <_dtoa_r+0x96a>
8000b66a:	0a 98       	mov	r8,r5
8000b66c:	40 b9       	lddsp	r9,sp[0x2c]
8000b66e:	ee 18 80 00 	eorh	r8,0x8000
8000b672:	fa ea 00 08 	ld.d	r10,sp[8]
8000b676:	10 95       	mov	r5,r8
8000b678:	12 98       	mov	r8,r9
8000b67a:	0a 99       	mov	r9,r5
8000b67c:	e0 a0 0f 0e 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b680:	e0 81 02 3e 	brne	8000bafc <_dtoa_r+0x958>
8000b684:	ca 68       	rjmp	8000b7d0 <_dtoa_r+0x62c>
8000b686:	fe c9 c1 52 	sub	r9,pc,-16046
8000b68a:	e8 c8 00 01 	sub	r8,r4,1
8000b68e:	40 d5       	lddsp	r5,sp[0x34]
8000b690:	58 05       	cp.w	r5,0
8000b692:	c4 f0       	breq	8000b730 <_dtoa_r+0x58c>
8000b694:	30 0c       	mov	r12,0
8000b696:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b69a:	51 3c       	stdsp	sp[0x4c],r12
8000b69c:	30 0a       	mov	r10,0
8000b69e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b6a2:	e0 a0 0f 2f 	rcall	8000d500 <__avr32_f64_div>
8000b6a6:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6aa:	40 85       	lddsp	r5,sp[0x20]
8000b6ac:	e0 a0 0c d0 	rcall	8000d04c <__avr32_f64_sub>
8000b6b0:	fa eb 00 28 	st.d	sp[40],r10
8000b6b4:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6b8:	e0 a0 0e 22 	rcall	8000d2fc <__avr32_f64_to_s32>
8000b6bc:	51 6c       	stdsp	sp[0x58],r12
8000b6be:	e0 a0 0e 36 	rcall	8000d32a <__avr32_s32_to_f64>
8000b6c2:	14 98       	mov	r8,r10
8000b6c4:	16 99       	mov	r9,r11
8000b6c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6ca:	e0 a0 0c c1 	rcall	8000d04c <__avr32_f64_sub>
8000b6ce:	fa eb 00 08 	st.d	sp[8],r10
8000b6d2:	41 68       	lddsp	r8,sp[0x58]
8000b6d4:	2d 08       	sub	r8,-48
8000b6d6:	0a c8       	st.b	r5++,r8
8000b6d8:	41 39       	lddsp	r9,sp[0x4c]
8000b6da:	2f f9       	sub	r9,-1
8000b6dc:	51 39       	stdsp	sp[0x4c],r9
8000b6de:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6e2:	e0 a0 0e db 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b6e6:	e0 81 03 39 	brne	8000bd58 <_dtoa_r+0xbb4>
8000b6ea:	fa e8 00 08 	ld.d	r8,sp[8]
8000b6ee:	30 0a       	mov	r10,0
8000b6f0:	fc 1b 3f f0 	movh	r11,0x3ff0
8000b6f4:	e0 a0 0c ac 	rcall	8000d04c <__avr32_f64_sub>
8000b6f8:	fa e8 00 28 	ld.d	r8,sp[40]
8000b6fc:	e0 a0 0e ce 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b700:	fa ea 00 28 	ld.d	r10,sp[40]
8000b704:	30 08       	mov	r8,0
8000b706:	fc 19 40 24 	movh	r9,0x4024
8000b70a:	e0 81 00 da 	brne	8000b8be <_dtoa_r+0x71a>
8000b70e:	41 3c       	lddsp	r12,sp[0x4c]
8000b710:	08 3c       	cp.w	r12,r4
8000b712:	c5 f4       	brge	8000b7d0 <_dtoa_r+0x62c>
8000b714:	e0 a0 0b b0 	rcall	8000ce74 <__avr32_f64_mul>
8000b718:	30 08       	mov	r8,0
8000b71a:	fa eb 00 28 	st.d	sp[40],r10
8000b71e:	fc 19 40 24 	movh	r9,0x4024
8000b722:	fa ea 00 08 	ld.d	r10,sp[8]
8000b726:	e0 a0 0b a7 	rcall	8000ce74 <__avr32_f64_mul>
8000b72a:	fa eb 00 08 	st.d	sp[8],r10
8000b72e:	cc 3b       	rjmp	8000b6b4 <_dtoa_r+0x510>
8000b730:	40 85       	lddsp	r5,sp[0x20]
8000b732:	08 05       	add	r5,r4
8000b734:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000b738:	51 35       	stdsp	sp[0x4c],r5
8000b73a:	fa e8 00 28 	ld.d	r8,sp[40]
8000b73e:	40 85       	lddsp	r5,sp[0x20]
8000b740:	e0 a0 0b 9a 	rcall	8000ce74 <__avr32_f64_mul>
8000b744:	fa eb 00 28 	st.d	sp[40],r10
8000b748:	fa ea 00 08 	ld.d	r10,sp[8]
8000b74c:	e0 a0 0d d8 	rcall	8000d2fc <__avr32_f64_to_s32>
8000b750:	51 6c       	stdsp	sp[0x58],r12
8000b752:	e0 a0 0d ec 	rcall	8000d32a <__avr32_s32_to_f64>
8000b756:	14 98       	mov	r8,r10
8000b758:	16 99       	mov	r9,r11
8000b75a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b75e:	e0 a0 0c 77 	rcall	8000d04c <__avr32_f64_sub>
8000b762:	fa eb 00 08 	st.d	sp[8],r10
8000b766:	41 68       	lddsp	r8,sp[0x58]
8000b768:	2d 08       	sub	r8,-48
8000b76a:	0a c8       	st.b	r5++,r8
8000b76c:	41 3c       	lddsp	r12,sp[0x4c]
8000b76e:	18 35       	cp.w	r5,r12
8000b770:	c2 81       	brne	8000b7c0 <_dtoa_r+0x61c>
8000b772:	30 08       	mov	r8,0
8000b774:	fc 19 3f e0 	movh	r9,0x3fe0
8000b778:	fa ea 00 28 	ld.d	r10,sp[40]
8000b77c:	e0 a0 0d 36 	rcall	8000d1e8 <__avr32_f64_add>
8000b780:	40 85       	lddsp	r5,sp[0x20]
8000b782:	fa e8 00 08 	ld.d	r8,sp[8]
8000b786:	08 05       	add	r5,r4
8000b788:	e0 a0 0e 88 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b78c:	e0 81 00 99 	brne	8000b8be <_dtoa_r+0x71a>
8000b790:	fa e8 00 28 	ld.d	r8,sp[40]
8000b794:	30 0a       	mov	r10,0
8000b796:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b79a:	e0 a0 0c 59 	rcall	8000d04c <__avr32_f64_sub>
8000b79e:	14 98       	mov	r8,r10
8000b7a0:	16 99       	mov	r9,r11
8000b7a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b7a6:	e0 a0 0e 79 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b7aa:	c1 30       	breq	8000b7d0 <_dtoa_r+0x62c>
8000b7ac:	33 09       	mov	r9,48
8000b7ae:	0a 98       	mov	r8,r5
8000b7b0:	11 7a       	ld.ub	r10,--r8
8000b7b2:	f2 0a 18 00 	cp.b	r10,r9
8000b7b6:	e0 81 02 d1 	brne	8000bd58 <_dtoa_r+0xbb4>
8000b7ba:	10 95       	mov	r5,r8
8000b7bc:	cf 9b       	rjmp	8000b7ae <_dtoa_r+0x60a>
8000b7be:	d7 03       	nop
8000b7c0:	30 08       	mov	r8,0
8000b7c2:	fc 19 40 24 	movh	r9,0x4024
8000b7c6:	e0 a0 0b 57 	rcall	8000ce74 <__avr32_f64_mul>
8000b7ca:	fa eb 00 08 	st.d	sp[8],r10
8000b7ce:	cb db       	rjmp	8000b748 <_dtoa_r+0x5a4>
8000b7d0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b7d4:	fa eb 00 08 	st.d	sp[8],r10
8000b7d8:	58 e6       	cp.w	r6,14
8000b7da:	5f ab       	srle	r11
8000b7dc:	41 8a       	lddsp	r10,sp[0x60]
8000b7de:	30 08       	mov	r8,0
8000b7e0:	f4 09 11 ff 	rsub	r9,r10,-1
8000b7e4:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b7e8:	f0 09 18 00 	cp.b	r9,r8
8000b7ec:	e0 80 00 82 	breq	8000b8f0 <_dtoa_r+0x74c>
8000b7f0:	40 ea       	lddsp	r10,sp[0x38]
8000b7f2:	58 01       	cp.w	r1,0
8000b7f4:	5f a9       	srle	r9
8000b7f6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b7fa:	fe ca c2 c6 	sub	r10,pc,-15674
8000b7fe:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b802:	fa e5 00 10 	st.d	sp[16],r4
8000b806:	f0 09 18 00 	cp.b	r9,r8
8000b80a:	c1 40       	breq	8000b832 <_dtoa_r+0x68e>
8000b80c:	58 01       	cp.w	r1,0
8000b80e:	e0 81 01 77 	brne	8000bafc <_dtoa_r+0x958>
8000b812:	30 08       	mov	r8,0
8000b814:	fc 19 40 14 	movh	r9,0x4014
8000b818:	08 9a       	mov	r10,r4
8000b81a:	0a 9b       	mov	r11,r5
8000b81c:	e0 a0 0b 2c 	rcall	8000ce74 <__avr32_f64_mul>
8000b820:	fa e8 00 08 	ld.d	r8,sp[8]
8000b824:	e0 a0 0e 06 	rcall	8000d430 <__avr32_f64_cmp_ge>
8000b828:	e0 81 01 6a 	brne	8000bafc <_dtoa_r+0x958>
8000b82c:	02 92       	mov	r2,r1
8000b82e:	e0 8f 01 72 	bral	8000bb12 <_dtoa_r+0x96e>
8000b832:	40 85       	lddsp	r5,sp[0x20]
8000b834:	30 14       	mov	r4,1
8000b836:	fa e8 00 10 	ld.d	r8,sp[16]
8000b83a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b83e:	e0 a0 0e 61 	rcall	8000d500 <__avr32_f64_div>
8000b842:	e0 a0 0d 5d 	rcall	8000d2fc <__avr32_f64_to_s32>
8000b846:	18 92       	mov	r2,r12
8000b848:	e0 a0 0d 71 	rcall	8000d32a <__avr32_s32_to_f64>
8000b84c:	fa e8 00 10 	ld.d	r8,sp[16]
8000b850:	e0 a0 0b 12 	rcall	8000ce74 <__avr32_f64_mul>
8000b854:	14 98       	mov	r8,r10
8000b856:	16 99       	mov	r9,r11
8000b858:	fa ea 00 08 	ld.d	r10,sp[8]
8000b85c:	e0 a0 0b f8 	rcall	8000d04c <__avr32_f64_sub>
8000b860:	fa eb 00 08 	st.d	sp[8],r10
8000b864:	e4 c8 ff d0 	sub	r8,r2,-48
8000b868:	0a c8       	st.b	r5++,r8
8000b86a:	fc 19 40 24 	movh	r9,0x4024
8000b86e:	30 08       	mov	r8,0
8000b870:	02 34       	cp.w	r4,r1
8000b872:	c3 31       	brne	8000b8d8 <_dtoa_r+0x734>
8000b874:	fa e8 00 08 	ld.d	r8,sp[8]
8000b878:	e0 a0 0c b8 	rcall	8000d1e8 <__avr32_f64_add>
8000b87c:	16 91       	mov	r1,r11
8000b87e:	14 90       	mov	r0,r10
8000b880:	14 98       	mov	r8,r10
8000b882:	02 99       	mov	r9,r1
8000b884:	fa ea 00 10 	ld.d	r10,sp[16]
8000b888:	e0 a0 0e 08 	rcall	8000d498 <__avr32_f64_cmp_lt>
8000b88c:	c1 a1       	brne	8000b8c0 <_dtoa_r+0x71c>
8000b88e:	fa e8 00 10 	ld.d	r8,sp[16]
8000b892:	00 9a       	mov	r10,r0
8000b894:	02 9b       	mov	r11,r1
8000b896:	e0 a0 0d ba 	rcall	8000d40a <__avr32_f64_cmp_eq>
8000b89a:	e0 80 02 5e 	breq	8000bd56 <_dtoa_r+0xbb2>
8000b89e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b8a2:	c0 f1       	brne	8000b8c0 <_dtoa_r+0x71c>
8000b8a4:	e0 8f 02 59 	bral	8000bd56 <_dtoa_r+0xbb2>
8000b8a8:	40 8a       	lddsp	r10,sp[0x20]
8000b8aa:	14 38       	cp.w	r8,r10
8000b8ac:	c0 30       	breq	8000b8b2 <_dtoa_r+0x70e>
8000b8ae:	10 95       	mov	r5,r8
8000b8b0:	c0 98       	rjmp	8000b8c2 <_dtoa_r+0x71e>
8000b8b2:	33 08       	mov	r8,48
8000b8b4:	40 89       	lddsp	r9,sp[0x20]
8000b8b6:	2f f6       	sub	r6,-1
8000b8b8:	b2 88       	st.b	r9[0x0],r8
8000b8ba:	40 88       	lddsp	r8,sp[0x20]
8000b8bc:	c0 88       	rjmp	8000b8cc <_dtoa_r+0x728>
8000b8be:	40 66       	lddsp	r6,sp[0x18]
8000b8c0:	33 99       	mov	r9,57
8000b8c2:	0a 98       	mov	r8,r5
8000b8c4:	11 7a       	ld.ub	r10,--r8
8000b8c6:	f2 0a 18 00 	cp.b	r10,r9
8000b8ca:	ce f0       	breq	8000b8a8 <_dtoa_r+0x704>
8000b8cc:	50 66       	stdsp	sp[0x18],r6
8000b8ce:	11 89       	ld.ub	r9,r8[0x0]
8000b8d0:	2f f9       	sub	r9,-1
8000b8d2:	b0 89       	st.b	r8[0x0],r9
8000b8d4:	e0 8f 02 42 	bral	8000bd58 <_dtoa_r+0xbb4>
8000b8d8:	e0 a0 0a ce 	rcall	8000ce74 <__avr32_f64_mul>
8000b8dc:	2f f4       	sub	r4,-1
8000b8de:	fa eb 00 08 	st.d	sp[8],r10
8000b8e2:	30 08       	mov	r8,0
8000b8e4:	30 09       	mov	r9,0
8000b8e6:	e0 a0 0d 92 	rcall	8000d40a <__avr32_f64_cmp_eq>
8000b8ea:	ca 60       	breq	8000b836 <_dtoa_r+0x692>
8000b8ec:	e0 8f 02 35 	bral	8000bd56 <_dtoa_r+0xbb2>
8000b8f0:	40 d8       	lddsp	r8,sp[0x34]
8000b8f2:	58 08       	cp.w	r8,0
8000b8f4:	c0 51       	brne	8000b8fe <_dtoa_r+0x75a>
8000b8f6:	04 98       	mov	r8,r2
8000b8f8:	00 95       	mov	r5,r0
8000b8fa:	40 d4       	lddsp	r4,sp[0x34]
8000b8fc:	c3 78       	rjmp	8000b96a <_dtoa_r+0x7c6>
8000b8fe:	40 c5       	lddsp	r5,sp[0x30]
8000b900:	58 15       	cp.w	r5,1
8000b902:	e0 89 00 0f 	brgt	8000b920 <_dtoa_r+0x77c>
8000b906:	41 74       	lddsp	r4,sp[0x5c]
8000b908:	58 04       	cp.w	r4,0
8000b90a:	c0 40       	breq	8000b912 <_dtoa_r+0x76e>
8000b90c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b910:	c0 48       	rjmp	8000b918 <_dtoa_r+0x774>
8000b912:	41 99       	lddsp	r9,sp[0x64]
8000b914:	f2 09 11 36 	rsub	r9,r9,54
8000b918:	04 98       	mov	r8,r2
8000b91a:	00 95       	mov	r5,r0
8000b91c:	c1 c8       	rjmp	8000b954 <_dtoa_r+0x7b0>
8000b91e:	d7 03       	nop
8000b920:	e2 c8 00 01 	sub	r8,r1,1
8000b924:	58 01       	cp.w	r1,0
8000b926:	e0 05 17 40 	movge	r5,r0
8000b92a:	e2 09 17 40 	movge	r9,r1
8000b92e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b932:	f9 b9 05 00 	movlt	r9,0
8000b936:	10 32       	cp.w	r2,r8
8000b938:	e5 d8 e4 18 	subge	r8,r2,r8
8000b93c:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b940:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b944:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b948:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b94c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b950:	f9 b8 05 00 	movlt	r8,0
8000b954:	40 4b       	lddsp	r11,sp[0x10]
8000b956:	12 0b       	add	r11,r9
8000b958:	50 08       	stdsp	sp[0x0],r8
8000b95a:	50 4b       	stdsp	sp[0x10],r11
8000b95c:	12 00       	add	r0,r9
8000b95e:	30 1b       	mov	r11,1
8000b960:	0e 9c       	mov	r12,r7
8000b962:	e0 a0 08 a7 	rcall	8000cab0 <__i2b>
8000b966:	40 08       	lddsp	r8,sp[0x0]
8000b968:	18 94       	mov	r4,r12
8000b96a:	40 4a       	lddsp	r10,sp[0x10]
8000b96c:	58 05       	cp.w	r5,0
8000b96e:	5f 99       	srgt	r9
8000b970:	58 0a       	cp.w	r10,0
8000b972:	5f 9a       	srgt	r10
8000b974:	f5 e9 00 09 	and	r9,r10,r9
8000b978:	c0 80       	breq	8000b988 <_dtoa_r+0x7e4>
8000b97a:	40 4c       	lddsp	r12,sp[0x10]
8000b97c:	f8 05 0d 49 	min	r9,r12,r5
8000b980:	12 1c       	sub	r12,r9
8000b982:	12 10       	sub	r0,r9
8000b984:	50 4c       	stdsp	sp[0x10],r12
8000b986:	12 15       	sub	r5,r9
8000b988:	58 02       	cp.w	r2,0
8000b98a:	e0 8a 00 27 	brle	8000b9d8 <_dtoa_r+0x834>
8000b98e:	40 db       	lddsp	r11,sp[0x34]
8000b990:	58 0b       	cp.w	r11,0
8000b992:	c1 d0       	breq	8000b9cc <_dtoa_r+0x828>
8000b994:	58 08       	cp.w	r8,0
8000b996:	e0 8a 00 17 	brle	8000b9c4 <_dtoa_r+0x820>
8000b99a:	10 9a       	mov	r10,r8
8000b99c:	50 08       	stdsp	sp[0x0],r8
8000b99e:	08 9b       	mov	r11,r4
8000b9a0:	0e 9c       	mov	r12,r7
8000b9a2:	e0 a0 08 cd 	rcall	8000cb3c <__pow5mult>
8000b9a6:	06 9a       	mov	r10,r3
8000b9a8:	18 9b       	mov	r11,r12
8000b9aa:	18 94       	mov	r4,r12
8000b9ac:	0e 9c       	mov	r12,r7
8000b9ae:	e0 a0 08 01 	rcall	8000c9b0 <__multiply>
8000b9b2:	18 99       	mov	r9,r12
8000b9b4:	06 9b       	mov	r11,r3
8000b9b6:	50 19       	stdsp	sp[0x4],r9
8000b9b8:	0e 9c       	mov	r12,r7
8000b9ba:	e0 a0 06 ad 	rcall	8000c714 <_Bfree>
8000b9be:	40 19       	lddsp	r9,sp[0x4]
8000b9c0:	40 08       	lddsp	r8,sp[0x0]
8000b9c2:	12 93       	mov	r3,r9
8000b9c4:	e4 08 01 0a 	sub	r10,r2,r8
8000b9c8:	c0 80       	breq	8000b9d8 <_dtoa_r+0x834>
8000b9ca:	c0 28       	rjmp	8000b9ce <_dtoa_r+0x82a>
8000b9cc:	04 9a       	mov	r10,r2
8000b9ce:	06 9b       	mov	r11,r3
8000b9d0:	0e 9c       	mov	r12,r7
8000b9d2:	e0 a0 08 b5 	rcall	8000cb3c <__pow5mult>
8000b9d6:	18 93       	mov	r3,r12
8000b9d8:	30 1b       	mov	r11,1
8000b9da:	0e 9c       	mov	r12,r7
8000b9dc:	e0 a0 08 6a 	rcall	8000cab0 <__i2b>
8000b9e0:	41 1a       	lddsp	r10,sp[0x44]
8000b9e2:	18 92       	mov	r2,r12
8000b9e4:	58 0a       	cp.w	r10,0
8000b9e6:	e0 8a 00 07 	brle	8000b9f4 <_dtoa_r+0x850>
8000b9ea:	18 9b       	mov	r11,r12
8000b9ec:	0e 9c       	mov	r12,r7
8000b9ee:	e0 a0 08 a7 	rcall	8000cb3c <__pow5mult>
8000b9f2:	18 92       	mov	r2,r12
8000b9f4:	40 c9       	lddsp	r9,sp[0x30]
8000b9f6:	58 19       	cp.w	r9,1
8000b9f8:	e0 89 00 14 	brgt	8000ba20 <_dtoa_r+0x87c>
8000b9fc:	40 38       	lddsp	r8,sp[0xc]
8000b9fe:	58 08       	cp.w	r8,0
8000ba00:	c1 01       	brne	8000ba20 <_dtoa_r+0x87c>
8000ba02:	40 29       	lddsp	r9,sp[0x8]
8000ba04:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000ba08:	c0 c1       	brne	8000ba20 <_dtoa_r+0x87c>
8000ba0a:	12 98       	mov	r8,r9
8000ba0c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ba10:	c0 80       	breq	8000ba20 <_dtoa_r+0x87c>
8000ba12:	40 4c       	lddsp	r12,sp[0x10]
8000ba14:	30 1b       	mov	r11,1
8000ba16:	2f fc       	sub	r12,-1
8000ba18:	2f f0       	sub	r0,-1
8000ba1a:	50 4c       	stdsp	sp[0x10],r12
8000ba1c:	50 6b       	stdsp	sp[0x18],r11
8000ba1e:	c0 38       	rjmp	8000ba24 <_dtoa_r+0x880>
8000ba20:	30 0a       	mov	r10,0
8000ba22:	50 6a       	stdsp	sp[0x18],r10
8000ba24:	41 19       	lddsp	r9,sp[0x44]
8000ba26:	58 09       	cp.w	r9,0
8000ba28:	c0 31       	brne	8000ba2e <_dtoa_r+0x88a>
8000ba2a:	30 1c       	mov	r12,1
8000ba2c:	c0 98       	rjmp	8000ba3e <_dtoa_r+0x89a>
8000ba2e:	64 48       	ld.w	r8,r2[0x10]
8000ba30:	2f c8       	sub	r8,-4
8000ba32:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000ba36:	e0 a0 05 df 	rcall	8000c5f4 <__hi0bits>
8000ba3a:	f8 0c 11 20 	rsub	r12,r12,32
8000ba3e:	40 4b       	lddsp	r11,sp[0x10]
8000ba40:	f8 0b 00 08 	add	r8,r12,r11
8000ba44:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ba48:	c0 c0       	breq	8000ba60 <_dtoa_r+0x8bc>
8000ba4a:	f0 08 11 20 	rsub	r8,r8,32
8000ba4e:	58 48       	cp.w	r8,4
8000ba50:	e0 8a 00 06 	brle	8000ba5c <_dtoa_r+0x8b8>
8000ba54:	20 48       	sub	r8,4
8000ba56:	10 0b       	add	r11,r8
8000ba58:	50 4b       	stdsp	sp[0x10],r11
8000ba5a:	c0 78       	rjmp	8000ba68 <_dtoa_r+0x8c4>
8000ba5c:	58 48       	cp.w	r8,4
8000ba5e:	c0 70       	breq	8000ba6c <_dtoa_r+0x8c8>
8000ba60:	40 4a       	lddsp	r10,sp[0x10]
8000ba62:	2e 48       	sub	r8,-28
8000ba64:	10 0a       	add	r10,r8
8000ba66:	50 4a       	stdsp	sp[0x10],r10
8000ba68:	10 00       	add	r0,r8
8000ba6a:	10 05       	add	r5,r8
8000ba6c:	58 00       	cp.w	r0,0
8000ba6e:	e0 8a 00 08 	brle	8000ba7e <_dtoa_r+0x8da>
8000ba72:	06 9b       	mov	r11,r3
8000ba74:	00 9a       	mov	r10,r0
8000ba76:	0e 9c       	mov	r12,r7
8000ba78:	e0 a0 07 58 	rcall	8000c928 <__lshift>
8000ba7c:	18 93       	mov	r3,r12
8000ba7e:	40 49       	lddsp	r9,sp[0x10]
8000ba80:	58 09       	cp.w	r9,0
8000ba82:	e0 8a 00 08 	brle	8000ba92 <_dtoa_r+0x8ee>
8000ba86:	04 9b       	mov	r11,r2
8000ba88:	12 9a       	mov	r10,r9
8000ba8a:	0e 9c       	mov	r12,r7
8000ba8c:	e0 a0 07 4e 	rcall	8000c928 <__lshift>
8000ba90:	18 92       	mov	r2,r12
8000ba92:	41 48       	lddsp	r8,sp[0x50]
8000ba94:	58 08       	cp.w	r8,0
8000ba96:	c1 b0       	breq	8000bacc <_dtoa_r+0x928>
8000ba98:	04 9b       	mov	r11,r2
8000ba9a:	06 9c       	mov	r12,r3
8000ba9c:	e0 a0 06 23 	rcall	8000c6e2 <__mcmp>
8000baa0:	c1 64       	brge	8000bacc <_dtoa_r+0x928>
8000baa2:	06 9b       	mov	r11,r3
8000baa4:	30 09       	mov	r9,0
8000baa6:	30 aa       	mov	r10,10
8000baa8:	0e 9c       	mov	r12,r7
8000baaa:	e0 a0 08 0b 	rcall	8000cac0 <__multadd>
8000baae:	20 16       	sub	r6,1
8000bab0:	18 93       	mov	r3,r12
8000bab2:	40 dc       	lddsp	r12,sp[0x34]
8000bab4:	58 0c       	cp.w	r12,0
8000bab6:	c0 31       	brne	8000babc <_dtoa_r+0x918>
8000bab8:	40 91       	lddsp	r1,sp[0x24]
8000baba:	c0 98       	rjmp	8000bacc <_dtoa_r+0x928>
8000babc:	08 9b       	mov	r11,r4
8000babe:	40 91       	lddsp	r1,sp[0x24]
8000bac0:	30 09       	mov	r9,0
8000bac2:	30 aa       	mov	r10,10
8000bac4:	0e 9c       	mov	r12,r7
8000bac6:	e0 a0 07 fd 	rcall	8000cac0 <__multadd>
8000baca:	18 94       	mov	r4,r12
8000bacc:	58 01       	cp.w	r1,0
8000bace:	5f a9       	srle	r9
8000bad0:	40 cb       	lddsp	r11,sp[0x30]
8000bad2:	58 2b       	cp.w	r11,2
8000bad4:	5f 98       	srgt	r8
8000bad6:	f3 e8 00 08 	and	r8,r9,r8
8000bada:	c2 50       	breq	8000bb24 <_dtoa_r+0x980>
8000badc:	58 01       	cp.w	r1,0
8000bade:	c1 11       	brne	8000bb00 <_dtoa_r+0x95c>
8000bae0:	04 9b       	mov	r11,r2
8000bae2:	02 99       	mov	r9,r1
8000bae4:	30 5a       	mov	r10,5
8000bae6:	0e 9c       	mov	r12,r7
8000bae8:	e0 a0 07 ec 	rcall	8000cac0 <__multadd>
8000baec:	18 92       	mov	r2,r12
8000baee:	18 9b       	mov	r11,r12
8000baf0:	06 9c       	mov	r12,r3
8000baf2:	e0 a0 05 f8 	rcall	8000c6e2 <__mcmp>
8000baf6:	e0 89 00 0f 	brgt	8000bb14 <_dtoa_r+0x970>
8000bafa:	c0 38       	rjmp	8000bb00 <_dtoa_r+0x95c>
8000bafc:	30 02       	mov	r2,0
8000bafe:	04 94       	mov	r4,r2
8000bb00:	40 ea       	lddsp	r10,sp[0x38]
8000bb02:	30 09       	mov	r9,0
8000bb04:	5c da       	com	r10
8000bb06:	40 85       	lddsp	r5,sp[0x20]
8000bb08:	50 6a       	stdsp	sp[0x18],r10
8000bb0a:	50 49       	stdsp	sp[0x10],r9
8000bb0c:	c0 f9       	rjmp	8000bd2a <_dtoa_r+0xb86>
8000bb0e:	08 92       	mov	r2,r4
8000bb10:	40 66       	lddsp	r6,sp[0x18]
8000bb12:	04 94       	mov	r4,r2
8000bb14:	2f f6       	sub	r6,-1
8000bb16:	50 66       	stdsp	sp[0x18],r6
8000bb18:	33 18       	mov	r8,49
8000bb1a:	40 85       	lddsp	r5,sp[0x20]
8000bb1c:	0a c8       	st.b	r5++,r8
8000bb1e:	30 08       	mov	r8,0
8000bb20:	50 48       	stdsp	sp[0x10],r8
8000bb22:	c0 49       	rjmp	8000bd2a <_dtoa_r+0xb86>
8000bb24:	40 dc       	lddsp	r12,sp[0x34]
8000bb26:	58 0c       	cp.w	r12,0
8000bb28:	e0 80 00 b5 	breq	8000bc92 <_dtoa_r+0xaee>
8000bb2c:	58 05       	cp.w	r5,0
8000bb2e:	e0 8a 00 08 	brle	8000bb3e <_dtoa_r+0x99a>
8000bb32:	08 9b       	mov	r11,r4
8000bb34:	0a 9a       	mov	r10,r5
8000bb36:	0e 9c       	mov	r12,r7
8000bb38:	e0 a0 06 f8 	rcall	8000c928 <__lshift>
8000bb3c:	18 94       	mov	r4,r12
8000bb3e:	40 6b       	lddsp	r11,sp[0x18]
8000bb40:	58 0b       	cp.w	r11,0
8000bb42:	c0 31       	brne	8000bb48 <_dtoa_r+0x9a4>
8000bb44:	08 9c       	mov	r12,r4
8000bb46:	c1 38       	rjmp	8000bb6c <_dtoa_r+0x9c8>
8000bb48:	68 1b       	ld.w	r11,r4[0x4]
8000bb4a:	0e 9c       	mov	r12,r7
8000bb4c:	e0 a0 05 fe 	rcall	8000c748 <_Balloc>
8000bb50:	68 4a       	ld.w	r10,r4[0x10]
8000bb52:	18 95       	mov	r5,r12
8000bb54:	e8 cb ff f4 	sub	r11,r4,-12
8000bb58:	2f ea       	sub	r10,-2
8000bb5a:	2f 4c       	sub	r12,-12
8000bb5c:	a3 6a       	lsl	r10,0x2
8000bb5e:	fe b0 e6 50 	rcall	800087fe <memcpy>
8000bb62:	0a 9b       	mov	r11,r5
8000bb64:	30 1a       	mov	r10,1
8000bb66:	0e 9c       	mov	r12,r7
8000bb68:	e0 a0 06 e0 	rcall	8000c928 <__lshift>
8000bb6c:	50 44       	stdsp	sp[0x10],r4
8000bb6e:	40 3a       	lddsp	r10,sp[0xc]
8000bb70:	30 19       	mov	r9,1
8000bb72:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000bb76:	18 94       	mov	r4,r12
8000bb78:	50 da       	stdsp	sp[0x34],r10
8000bb7a:	40 85       	lddsp	r5,sp[0x20]
8000bb7c:	50 99       	stdsp	sp[0x24],r9
8000bb7e:	50 26       	stdsp	sp[0x8],r6
8000bb80:	50 e1       	stdsp	sp[0x38],r1
8000bb82:	04 9b       	mov	r11,r2
8000bb84:	06 9c       	mov	r12,r3
8000bb86:	fe b0 fa 7f 	rcall	8000b084 <quorem>
8000bb8a:	40 4b       	lddsp	r11,sp[0x10]
8000bb8c:	f8 c0 ff d0 	sub	r0,r12,-48
8000bb90:	06 9c       	mov	r12,r3
8000bb92:	e0 a0 05 a8 	rcall	8000c6e2 <__mcmp>
8000bb96:	08 9a       	mov	r10,r4
8000bb98:	50 6c       	stdsp	sp[0x18],r12
8000bb9a:	04 9b       	mov	r11,r2
8000bb9c:	0e 9c       	mov	r12,r7
8000bb9e:	e0 a0 06 5d 	rcall	8000c858 <__mdiff>
8000bba2:	18 91       	mov	r1,r12
8000bba4:	78 38       	ld.w	r8,r12[0xc]
8000bba6:	58 08       	cp.w	r8,0
8000bba8:	c0 30       	breq	8000bbae <_dtoa_r+0xa0a>
8000bbaa:	30 16       	mov	r6,1
8000bbac:	c0 68       	rjmp	8000bbb8 <_dtoa_r+0xa14>
8000bbae:	18 9b       	mov	r11,r12
8000bbb0:	06 9c       	mov	r12,r3
8000bbb2:	e0 a0 05 98 	rcall	8000c6e2 <__mcmp>
8000bbb6:	18 96       	mov	r6,r12
8000bbb8:	0e 9c       	mov	r12,r7
8000bbba:	02 9b       	mov	r11,r1
8000bbbc:	e0 a0 05 ac 	rcall	8000c714 <_Bfree>
8000bbc0:	40 cc       	lddsp	r12,sp[0x30]
8000bbc2:	ed ec 10 08 	or	r8,r6,r12
8000bbc6:	c0 d1       	brne	8000bbe0 <_dtoa_r+0xa3c>
8000bbc8:	40 db       	lddsp	r11,sp[0x34]
8000bbca:	58 0b       	cp.w	r11,0
8000bbcc:	c0 a1       	brne	8000bbe0 <_dtoa_r+0xa3c>
8000bbce:	40 26       	lddsp	r6,sp[0x8]
8000bbd0:	e0 40 00 39 	cp.w	r0,57
8000bbd4:	c3 00       	breq	8000bc34 <_dtoa_r+0xa90>
8000bbd6:	40 6a       	lddsp	r10,sp[0x18]
8000bbd8:	58 0a       	cp.w	r10,0
8000bbda:	e0 89 00 24 	brgt	8000bc22 <_dtoa_r+0xa7e>
8000bbde:	c2 f8       	rjmp	8000bc3c <_dtoa_r+0xa98>
8000bbe0:	40 69       	lddsp	r9,sp[0x18]
8000bbe2:	58 09       	cp.w	r9,0
8000bbe4:	c0 85       	brlt	8000bbf4 <_dtoa_r+0xa50>
8000bbe6:	12 98       	mov	r8,r9
8000bbe8:	40 cc       	lddsp	r12,sp[0x30]
8000bbea:	18 48       	or	r8,r12
8000bbec:	c1 d1       	brne	8000bc26 <_dtoa_r+0xa82>
8000bbee:	40 db       	lddsp	r11,sp[0x34]
8000bbf0:	58 0b       	cp.w	r11,0
8000bbf2:	c1 a1       	brne	8000bc26 <_dtoa_r+0xa82>
8000bbf4:	0c 99       	mov	r9,r6
8000bbf6:	40 26       	lddsp	r6,sp[0x8]
8000bbf8:	58 09       	cp.w	r9,0
8000bbfa:	e0 8a 00 21 	brle	8000bc3c <_dtoa_r+0xa98>
8000bbfe:	06 9b       	mov	r11,r3
8000bc00:	30 1a       	mov	r10,1
8000bc02:	0e 9c       	mov	r12,r7
8000bc04:	e0 a0 06 92 	rcall	8000c928 <__lshift>
8000bc08:	04 9b       	mov	r11,r2
8000bc0a:	18 93       	mov	r3,r12
8000bc0c:	e0 a0 05 6b 	rcall	8000c6e2 <__mcmp>
8000bc10:	e0 89 00 06 	brgt	8000bc1c <_dtoa_r+0xa78>
8000bc14:	c1 41       	brne	8000bc3c <_dtoa_r+0xa98>
8000bc16:	ed b0 00 00 	bld	r0,0x0
8000bc1a:	c1 11       	brne	8000bc3c <_dtoa_r+0xa98>
8000bc1c:	e0 40 00 39 	cp.w	r0,57
8000bc20:	c0 a0       	breq	8000bc34 <_dtoa_r+0xa90>
8000bc22:	2f f0       	sub	r0,-1
8000bc24:	c0 c8       	rjmp	8000bc3c <_dtoa_r+0xa98>
8000bc26:	58 06       	cp.w	r6,0
8000bc28:	e0 8a 00 0c 	brle	8000bc40 <_dtoa_r+0xa9c>
8000bc2c:	40 26       	lddsp	r6,sp[0x8]
8000bc2e:	e0 40 00 39 	cp.w	r0,57
8000bc32:	c0 41       	brne	8000bc3a <_dtoa_r+0xa96>
8000bc34:	33 98       	mov	r8,57
8000bc36:	0a c8       	st.b	r5++,r8
8000bc38:	c6 78       	rjmp	8000bd06 <_dtoa_r+0xb62>
8000bc3a:	2f f0       	sub	r0,-1
8000bc3c:	0a c0       	st.b	r5++,r0
8000bc3e:	c7 58       	rjmp	8000bd28 <_dtoa_r+0xb84>
8000bc40:	0a c0       	st.b	r5++,r0
8000bc42:	40 9a       	lddsp	r10,sp[0x24]
8000bc44:	40 e9       	lddsp	r9,sp[0x38]
8000bc46:	12 3a       	cp.w	r10,r9
8000bc48:	c4 30       	breq	8000bcce <_dtoa_r+0xb2a>
8000bc4a:	06 9b       	mov	r11,r3
8000bc4c:	30 09       	mov	r9,0
8000bc4e:	30 aa       	mov	r10,10
8000bc50:	0e 9c       	mov	r12,r7
8000bc52:	e0 a0 07 37 	rcall	8000cac0 <__multadd>
8000bc56:	40 48       	lddsp	r8,sp[0x10]
8000bc58:	18 93       	mov	r3,r12
8000bc5a:	08 38       	cp.w	r8,r4
8000bc5c:	c0 91       	brne	8000bc6e <_dtoa_r+0xaca>
8000bc5e:	10 9b       	mov	r11,r8
8000bc60:	30 09       	mov	r9,0
8000bc62:	30 aa       	mov	r10,10
8000bc64:	0e 9c       	mov	r12,r7
8000bc66:	e0 a0 07 2d 	rcall	8000cac0 <__multadd>
8000bc6a:	50 4c       	stdsp	sp[0x10],r12
8000bc6c:	c0 e8       	rjmp	8000bc88 <_dtoa_r+0xae4>
8000bc6e:	40 4b       	lddsp	r11,sp[0x10]
8000bc70:	30 09       	mov	r9,0
8000bc72:	30 aa       	mov	r10,10
8000bc74:	0e 9c       	mov	r12,r7
8000bc76:	e0 a0 07 25 	rcall	8000cac0 <__multadd>
8000bc7a:	08 9b       	mov	r11,r4
8000bc7c:	50 4c       	stdsp	sp[0x10],r12
8000bc7e:	30 09       	mov	r9,0
8000bc80:	30 aa       	mov	r10,10
8000bc82:	0e 9c       	mov	r12,r7
8000bc84:	e0 a0 07 1e 	rcall	8000cac0 <__multadd>
8000bc88:	18 94       	mov	r4,r12
8000bc8a:	40 9c       	lddsp	r12,sp[0x24]
8000bc8c:	2f fc       	sub	r12,-1
8000bc8e:	50 9c       	stdsp	sp[0x24],r12
8000bc90:	c7 9b       	rjmp	8000bb82 <_dtoa_r+0x9de>
8000bc92:	30 18       	mov	r8,1
8000bc94:	06 90       	mov	r0,r3
8000bc96:	40 85       	lddsp	r5,sp[0x20]
8000bc98:	08 93       	mov	r3,r4
8000bc9a:	0c 94       	mov	r4,r6
8000bc9c:	10 96       	mov	r6,r8
8000bc9e:	04 9b       	mov	r11,r2
8000bca0:	00 9c       	mov	r12,r0
8000bca2:	fe b0 f9 f1 	rcall	8000b084 <quorem>
8000bca6:	2d 0c       	sub	r12,-48
8000bca8:	0a cc       	st.b	r5++,r12
8000bcaa:	02 36       	cp.w	r6,r1
8000bcac:	c0 a4       	brge	8000bcc0 <_dtoa_r+0xb1c>
8000bcae:	00 9b       	mov	r11,r0
8000bcb0:	30 09       	mov	r9,0
8000bcb2:	30 aa       	mov	r10,10
8000bcb4:	0e 9c       	mov	r12,r7
8000bcb6:	2f f6       	sub	r6,-1
8000bcb8:	e0 a0 07 04 	rcall	8000cac0 <__multadd>
8000bcbc:	18 90       	mov	r0,r12
8000bcbe:	cf 0b       	rjmp	8000bc9e <_dtoa_r+0xafa>
8000bcc0:	08 96       	mov	r6,r4
8000bcc2:	30 0b       	mov	r11,0
8000bcc4:	06 94       	mov	r4,r3
8000bcc6:	50 4b       	stdsp	sp[0x10],r11
8000bcc8:	00 93       	mov	r3,r0
8000bcca:	18 90       	mov	r0,r12
8000bccc:	c0 28       	rjmp	8000bcd0 <_dtoa_r+0xb2c>
8000bcce:	40 26       	lddsp	r6,sp[0x8]
8000bcd0:	06 9b       	mov	r11,r3
8000bcd2:	30 1a       	mov	r10,1
8000bcd4:	0e 9c       	mov	r12,r7
8000bcd6:	e0 a0 06 29 	rcall	8000c928 <__lshift>
8000bcda:	04 9b       	mov	r11,r2
8000bcdc:	18 93       	mov	r3,r12
8000bcde:	e0 a0 05 02 	rcall	8000c6e2 <__mcmp>
8000bce2:	e0 89 00 12 	brgt	8000bd06 <_dtoa_r+0xb62>
8000bce6:	c1 b1       	brne	8000bd1c <_dtoa_r+0xb78>
8000bce8:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000bcec:	c0 d1       	brne	8000bd06 <_dtoa_r+0xb62>
8000bcee:	c1 78       	rjmp	8000bd1c <_dtoa_r+0xb78>
8000bcf0:	40 89       	lddsp	r9,sp[0x20]
8000bcf2:	12 38       	cp.w	r8,r9
8000bcf4:	c0 30       	breq	8000bcfa <_dtoa_r+0xb56>
8000bcf6:	10 95       	mov	r5,r8
8000bcf8:	c0 88       	rjmp	8000bd08 <_dtoa_r+0xb64>
8000bcfa:	2f f6       	sub	r6,-1
8000bcfc:	50 66       	stdsp	sp[0x18],r6
8000bcfe:	33 18       	mov	r8,49
8000bd00:	40 8c       	lddsp	r12,sp[0x20]
8000bd02:	b8 88       	st.b	r12[0x0],r8
8000bd04:	c1 38       	rjmp	8000bd2a <_dtoa_r+0xb86>
8000bd06:	33 9a       	mov	r10,57
8000bd08:	0a 98       	mov	r8,r5
8000bd0a:	11 79       	ld.ub	r9,--r8
8000bd0c:	f4 09 18 00 	cp.b	r9,r10
8000bd10:	cf 00       	breq	8000bcf0 <_dtoa_r+0xb4c>
8000bd12:	2f f9       	sub	r9,-1
8000bd14:	b0 89       	st.b	r8[0x0],r9
8000bd16:	c0 98       	rjmp	8000bd28 <_dtoa_r+0xb84>
8000bd18:	10 95       	mov	r5,r8
8000bd1a:	c0 28       	rjmp	8000bd1e <_dtoa_r+0xb7a>
8000bd1c:	33 09       	mov	r9,48
8000bd1e:	0a 98       	mov	r8,r5
8000bd20:	11 7a       	ld.ub	r10,--r8
8000bd22:	f2 0a 18 00 	cp.b	r10,r9
8000bd26:	cf 90       	breq	8000bd18 <_dtoa_r+0xb74>
8000bd28:	50 66       	stdsp	sp[0x18],r6
8000bd2a:	04 9b       	mov	r11,r2
8000bd2c:	0e 9c       	mov	r12,r7
8000bd2e:	e0 a0 04 f3 	rcall	8000c714 <_Bfree>
8000bd32:	58 04       	cp.w	r4,0
8000bd34:	c1 20       	breq	8000bd58 <_dtoa_r+0xbb4>
8000bd36:	40 4b       	lddsp	r11,sp[0x10]
8000bd38:	08 3b       	cp.w	r11,r4
8000bd3a:	5f 19       	srne	r9
8000bd3c:	58 0b       	cp.w	r11,0
8000bd3e:	5f 18       	srne	r8
8000bd40:	f3 e8 00 08 	and	r8,r9,r8
8000bd44:	c0 40       	breq	8000bd4c <_dtoa_r+0xba8>
8000bd46:	0e 9c       	mov	r12,r7
8000bd48:	e0 a0 04 e6 	rcall	8000c714 <_Bfree>
8000bd4c:	08 9b       	mov	r11,r4
8000bd4e:	0e 9c       	mov	r12,r7
8000bd50:	e0 a0 04 e2 	rcall	8000c714 <_Bfree>
8000bd54:	c0 28       	rjmp	8000bd58 <_dtoa_r+0xbb4>
8000bd56:	50 66       	stdsp	sp[0x18],r6
8000bd58:	0e 9c       	mov	r12,r7
8000bd5a:	06 9b       	mov	r11,r3
8000bd5c:	e0 a0 04 dc 	rcall	8000c714 <_Bfree>
8000bd60:	30 08       	mov	r8,0
8000bd62:	aa 88       	st.b	r5[0x0],r8
8000bd64:	40 68       	lddsp	r8,sp[0x18]
8000bd66:	41 5a       	lddsp	r10,sp[0x54]
8000bd68:	2f f8       	sub	r8,-1
8000bd6a:	41 29       	lddsp	r9,sp[0x48]
8000bd6c:	95 08       	st.w	r10[0x0],r8
8000bd6e:	40 8c       	lddsp	r12,sp[0x20]
8000bd70:	58 09       	cp.w	r9,0
8000bd72:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000bd76:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000bd7a:	2e 6d       	sub	sp,-104
8000bd7c:	d8 32       	popm	r0-r7,pc
8000bd7e:	d7 03       	nop

8000bd80 <__errno>:
8000bd80:	e0 68 0a 54 	mov	r8,2644
8000bd84:	70 0c       	ld.w	r12,r8[0x0]
8000bd86:	2f 4c       	sub	r12,-12
8000bd88:	5e fc       	retal	r12
8000bd8a:	d7 03       	nop

8000bd8c <_fflush_r>:
8000bd8c:	d4 21       	pushm	r4-r7,lr
8000bd8e:	16 97       	mov	r7,r11
8000bd90:	18 96       	mov	r6,r12
8000bd92:	76 48       	ld.w	r8,r11[0x10]
8000bd94:	58 08       	cp.w	r8,0
8000bd96:	c7 f0       	breq	8000be94 <_fflush_r+0x108>
8000bd98:	58 0c       	cp.w	r12,0
8000bd9a:	c0 50       	breq	8000bda4 <_fflush_r+0x18>
8000bd9c:	78 68       	ld.w	r8,r12[0x18]
8000bd9e:	58 08       	cp.w	r8,0
8000bda0:	c0 21       	brne	8000bda4 <_fflush_r+0x18>
8000bda2:	cc dc       	rcall	8000bf3c <__sinit>
8000bda4:	fe c8 c9 20 	sub	r8,pc,-14048
8000bda8:	10 37       	cp.w	r7,r8
8000bdaa:	c0 31       	brne	8000bdb0 <_fflush_r+0x24>
8000bdac:	6c 07       	ld.w	r7,r6[0x0]
8000bdae:	c0 c8       	rjmp	8000bdc6 <_fflush_r+0x3a>
8000bdb0:	fe c8 c9 0c 	sub	r8,pc,-14068
8000bdb4:	10 37       	cp.w	r7,r8
8000bdb6:	c0 31       	brne	8000bdbc <_fflush_r+0x30>
8000bdb8:	6c 17       	ld.w	r7,r6[0x4]
8000bdba:	c0 68       	rjmp	8000bdc6 <_fflush_r+0x3a>
8000bdbc:	fe c8 c8 f8 	sub	r8,pc,-14088
8000bdc0:	10 37       	cp.w	r7,r8
8000bdc2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bdc6:	8e 6a       	ld.sh	r10,r7[0xc]
8000bdc8:	14 98       	mov	r8,r10
8000bdca:	ed ba 00 03 	bld	r10,0x3
8000bdce:	c4 20       	breq	8000be52 <_fflush_r+0xc6>
8000bdd0:	ab ba       	sbr	r10,0xb
8000bdd2:	ae 6a       	st.h	r7[0xc],r10
8000bdd4:	6e 18       	ld.w	r8,r7[0x4]
8000bdd6:	58 08       	cp.w	r8,0
8000bdd8:	e0 89 00 06 	brgt	8000bde4 <_fflush_r+0x58>
8000bddc:	6f 08       	ld.w	r8,r7[0x40]
8000bdde:	58 08       	cp.w	r8,0
8000bde0:	e0 8a 00 5a 	brle	8000be94 <_fflush_r+0x108>
8000bde4:	6e b8       	ld.w	r8,r7[0x2c]
8000bde6:	58 08       	cp.w	r8,0
8000bde8:	c5 60       	breq	8000be94 <_fflush_r+0x108>
8000bdea:	e2 1a 10 00 	andl	r10,0x1000,COH
8000bdee:	c0 30       	breq	8000bdf4 <_fflush_r+0x68>
8000bdf0:	6f 55       	ld.w	r5,r7[0x54]
8000bdf2:	c0 f8       	rjmp	8000be10 <_fflush_r+0x84>
8000bdf4:	30 19       	mov	r9,1
8000bdf6:	6e 8b       	ld.w	r11,r7[0x20]
8000bdf8:	0c 9c       	mov	r12,r6
8000bdfa:	5d 18       	icall	r8
8000bdfc:	18 95       	mov	r5,r12
8000bdfe:	5b fc       	cp.w	r12,-1
8000be00:	c0 81       	brne	8000be10 <_fflush_r+0x84>
8000be02:	6c 38       	ld.w	r8,r6[0xc]
8000be04:	59 d8       	cp.w	r8,29
8000be06:	c4 70       	breq	8000be94 <_fflush_r+0x108>
8000be08:	8e 68       	ld.sh	r8,r7[0xc]
8000be0a:	a7 a8       	sbr	r8,0x6
8000be0c:	ae 68       	st.h	r7[0xc],r8
8000be0e:	d8 22       	popm	r4-r7,pc
8000be10:	8e 68       	ld.sh	r8,r7[0xc]
8000be12:	ed b8 00 02 	bld	r8,0x2
8000be16:	c0 91       	brne	8000be28 <_fflush_r+0x9c>
8000be18:	6e 18       	ld.w	r8,r7[0x4]
8000be1a:	10 15       	sub	r5,r8
8000be1c:	6e d8       	ld.w	r8,r7[0x34]
8000be1e:	58 08       	cp.w	r8,0
8000be20:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000be24:	eb d8 e1 15 	subne	r5,r5,r8
8000be28:	6e b8       	ld.w	r8,r7[0x2c]
8000be2a:	0c 9c       	mov	r12,r6
8000be2c:	30 09       	mov	r9,0
8000be2e:	0a 9a       	mov	r10,r5
8000be30:	6e 8b       	ld.w	r11,r7[0x20]
8000be32:	5d 18       	icall	r8
8000be34:	8e 68       	ld.sh	r8,r7[0xc]
8000be36:	0a 3c       	cp.w	r12,r5
8000be38:	c2 61       	brne	8000be84 <_fflush_r+0xf8>
8000be3a:	ab d8       	cbr	r8,0xb
8000be3c:	30 0c       	mov	r12,0
8000be3e:	6e 49       	ld.w	r9,r7[0x10]
8000be40:	ae 68       	st.h	r7[0xc],r8
8000be42:	8f 1c       	st.w	r7[0x4],r12
8000be44:	8f 09       	st.w	r7[0x0],r9
8000be46:	ed b8 00 0c 	bld	r8,0xc
8000be4a:	c2 51       	brne	8000be94 <_fflush_r+0x108>
8000be4c:	ef 45 00 54 	st.w	r7[84],r5
8000be50:	d8 22       	popm	r4-r7,pc
8000be52:	6e 45       	ld.w	r5,r7[0x10]
8000be54:	58 05       	cp.w	r5,0
8000be56:	c1 f0       	breq	8000be94 <_fflush_r+0x108>
8000be58:	6e 04       	ld.w	r4,r7[0x0]
8000be5a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000be5e:	8f 05       	st.w	r7[0x0],r5
8000be60:	f9 b8 01 00 	movne	r8,0
8000be64:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000be68:	0a 14       	sub	r4,r5
8000be6a:	8f 28       	st.w	r7[0x8],r8
8000be6c:	c1 18       	rjmp	8000be8e <_fflush_r+0x102>
8000be6e:	08 99       	mov	r9,r4
8000be70:	0a 9a       	mov	r10,r5
8000be72:	6e a8       	ld.w	r8,r7[0x28]
8000be74:	6e 8b       	ld.w	r11,r7[0x20]
8000be76:	0c 9c       	mov	r12,r6
8000be78:	5d 18       	icall	r8
8000be7a:	18 14       	sub	r4,r12
8000be7c:	58 0c       	cp.w	r12,0
8000be7e:	e0 89 00 07 	brgt	8000be8c <_fflush_r+0x100>
8000be82:	8e 68       	ld.sh	r8,r7[0xc]
8000be84:	a7 a8       	sbr	r8,0x6
8000be86:	3f fc       	mov	r12,-1
8000be88:	ae 68       	st.h	r7[0xc],r8
8000be8a:	d8 22       	popm	r4-r7,pc
8000be8c:	18 05       	add	r5,r12
8000be8e:	58 04       	cp.w	r4,0
8000be90:	fe 99 ff ef 	brgt	8000be6e <_fflush_r+0xe2>
8000be94:	d8 2a       	popm	r4-r7,pc,r12=0
8000be96:	d7 03       	nop

8000be98 <__sfp_lock_acquire>:
8000be98:	5e fc       	retal	r12

8000be9a <__sfp_lock_release>:
8000be9a:	5e fc       	retal	r12

8000be9c <_cleanup_r>:
8000be9c:	d4 01       	pushm	lr
8000be9e:	fe cb f0 ae 	sub	r11,pc,-3922
8000bea2:	e0 a0 02 f7 	rcall	8000c490 <_fwalk>
8000bea6:	d8 02       	popm	pc

8000bea8 <__sfmoreglue>:
8000bea8:	d4 21       	pushm	r4-r7,lr
8000beaa:	16 95       	mov	r5,r11
8000beac:	f6 06 10 5c 	mul	r6,r11,92
8000beb0:	ec cb ff f4 	sub	r11,r6,-12
8000beb4:	fe b0 e2 76 	rcall	800083a0 <_malloc_r>
8000beb8:	18 97       	mov	r7,r12
8000beba:	c0 90       	breq	8000becc <__sfmoreglue+0x24>
8000bebc:	99 15       	st.w	r12[0x4],r5
8000bebe:	30 0b       	mov	r11,0
8000bec0:	2f 4c       	sub	r12,-12
8000bec2:	0c 9a       	mov	r10,r6
8000bec4:	8f 2c       	st.w	r7[0x8],r12
8000bec6:	8f 0b       	st.w	r7[0x0],r11
8000bec8:	fe b0 e5 3f 	rcall	80008946 <memset>
8000becc:	0e 9c       	mov	r12,r7
8000bece:	d8 22       	popm	r4-r7,pc

8000bed0 <__sfp>:
8000bed0:	d4 21       	pushm	r4-r7,lr
8000bed2:	fe c8 c9 ea 	sub	r8,pc,-13846
8000bed6:	18 96       	mov	r6,r12
8000bed8:	70 07       	ld.w	r7,r8[0x0]
8000beda:	6e 68       	ld.w	r8,r7[0x18]
8000bedc:	58 08       	cp.w	r8,0
8000bede:	c0 31       	brne	8000bee4 <__sfp+0x14>
8000bee0:	0e 9c       	mov	r12,r7
8000bee2:	c2 dc       	rcall	8000bf3c <__sinit>
8000bee4:	ee c7 ff 28 	sub	r7,r7,-216
8000bee8:	30 05       	mov	r5,0
8000beea:	6e 2c       	ld.w	r12,r7[0x8]
8000beec:	6e 18       	ld.w	r8,r7[0x4]
8000beee:	c0 68       	rjmp	8000befa <__sfp+0x2a>
8000bef0:	98 69       	ld.sh	r9,r12[0xc]
8000bef2:	ea 09 19 00 	cp.h	r9,r5
8000bef6:	c1 10       	breq	8000bf18 <__sfp+0x48>
8000bef8:	2a 4c       	sub	r12,-92
8000befa:	20 18       	sub	r8,1
8000befc:	cf a7       	brpl	8000bef0 <__sfp+0x20>
8000befe:	6e 08       	ld.w	r8,r7[0x0]
8000bf00:	58 08       	cp.w	r8,0
8000bf02:	c0 61       	brne	8000bf0e <__sfp+0x3e>
8000bf04:	30 4b       	mov	r11,4
8000bf06:	0c 9c       	mov	r12,r6
8000bf08:	cd 0f       	rcall	8000bea8 <__sfmoreglue>
8000bf0a:	8f 0c       	st.w	r7[0x0],r12
8000bf0c:	c0 30       	breq	8000bf12 <__sfp+0x42>
8000bf0e:	6e 07       	ld.w	r7,r7[0x0]
8000bf10:	ce db       	rjmp	8000beea <__sfp+0x1a>
8000bf12:	30 c8       	mov	r8,12
8000bf14:	8d 38       	st.w	r6[0xc],r8
8000bf16:	d8 22       	popm	r4-r7,pc
8000bf18:	30 08       	mov	r8,0
8000bf1a:	f9 48 00 4c 	st.w	r12[76],r8
8000bf1e:	99 08       	st.w	r12[0x0],r8
8000bf20:	99 28       	st.w	r12[0x8],r8
8000bf22:	99 18       	st.w	r12[0x4],r8
8000bf24:	99 48       	st.w	r12[0x10],r8
8000bf26:	99 58       	st.w	r12[0x14],r8
8000bf28:	99 68       	st.w	r12[0x18],r8
8000bf2a:	99 d8       	st.w	r12[0x34],r8
8000bf2c:	99 e8       	st.w	r12[0x38],r8
8000bf2e:	f9 48 00 48 	st.w	r12[72],r8
8000bf32:	3f f8       	mov	r8,-1
8000bf34:	b8 78       	st.h	r12[0xe],r8
8000bf36:	30 18       	mov	r8,1
8000bf38:	b8 68       	st.h	r12[0xc],r8
8000bf3a:	d8 22       	popm	r4-r7,pc

8000bf3c <__sinit>:
8000bf3c:	d4 21       	pushm	r4-r7,lr
8000bf3e:	18 96       	mov	r6,r12
8000bf40:	78 67       	ld.w	r7,r12[0x18]
8000bf42:	58 07       	cp.w	r7,0
8000bf44:	c4 91       	brne	8000bfd6 <__sinit+0x9a>
8000bf46:	fe c8 00 aa 	sub	r8,pc,170
8000bf4a:	30 15       	mov	r5,1
8000bf4c:	99 a8       	st.w	r12[0x28],r8
8000bf4e:	f9 47 00 d8 	st.w	r12[216],r7
8000bf52:	f9 47 00 dc 	st.w	r12[220],r7
8000bf56:	f9 47 00 e0 	st.w	r12[224],r7
8000bf5a:	99 65       	st.w	r12[0x18],r5
8000bf5c:	cb af       	rcall	8000bed0 <__sfp>
8000bf5e:	8d 0c       	st.w	r6[0x0],r12
8000bf60:	0c 9c       	mov	r12,r6
8000bf62:	cb 7f       	rcall	8000bed0 <__sfp>
8000bf64:	8d 1c       	st.w	r6[0x4],r12
8000bf66:	0c 9c       	mov	r12,r6
8000bf68:	cb 4f       	rcall	8000bed0 <__sfp>
8000bf6a:	6c 09       	ld.w	r9,r6[0x0]
8000bf6c:	30 48       	mov	r8,4
8000bf6e:	93 07       	st.w	r9[0x0],r7
8000bf70:	b2 68       	st.h	r9[0xc],r8
8000bf72:	93 17       	st.w	r9[0x4],r7
8000bf74:	93 27       	st.w	r9[0x8],r7
8000bf76:	6c 18       	ld.w	r8,r6[0x4]
8000bf78:	b2 77       	st.h	r9[0xe],r7
8000bf7a:	93 47       	st.w	r9[0x10],r7
8000bf7c:	93 57       	st.w	r9[0x14],r7
8000bf7e:	93 67       	st.w	r9[0x18],r7
8000bf80:	93 89       	st.w	r9[0x20],r9
8000bf82:	91 07       	st.w	r8[0x0],r7
8000bf84:	91 17       	st.w	r8[0x4],r7
8000bf86:	91 27       	st.w	r8[0x8],r7
8000bf88:	fe ce f3 24 	sub	lr,pc,-3292
8000bf8c:	fe cb f3 54 	sub	r11,pc,-3244
8000bf90:	93 9e       	st.w	r9[0x24],lr
8000bf92:	93 ab       	st.w	r9[0x28],r11
8000bf94:	fe ca f3 7c 	sub	r10,pc,-3204
8000bf98:	fe c4 f3 88 	sub	r4,pc,-3192
8000bf9c:	93 ba       	st.w	r9[0x2c],r10
8000bf9e:	93 c4       	st.w	r9[0x30],r4
8000bfa0:	30 99       	mov	r9,9
8000bfa2:	b0 69       	st.h	r8[0xc],r9
8000bfa4:	b0 75       	st.h	r8[0xe],r5
8000bfa6:	91 c4       	st.w	r8[0x30],r4
8000bfa8:	91 47       	st.w	r8[0x10],r7
8000bfaa:	91 57       	st.w	r8[0x14],r7
8000bfac:	91 67       	st.w	r8[0x18],r7
8000bfae:	91 88       	st.w	r8[0x20],r8
8000bfb0:	91 9e       	st.w	r8[0x24],lr
8000bfb2:	91 ab       	st.w	r8[0x28],r11
8000bfb4:	91 ba       	st.w	r8[0x2c],r10
8000bfb6:	8d 2c       	st.w	r6[0x8],r12
8000bfb8:	31 28       	mov	r8,18
8000bfba:	99 07       	st.w	r12[0x0],r7
8000bfbc:	b8 68       	st.h	r12[0xc],r8
8000bfbe:	99 17       	st.w	r12[0x4],r7
8000bfc0:	99 27       	st.w	r12[0x8],r7
8000bfc2:	30 28       	mov	r8,2
8000bfc4:	b8 78       	st.h	r12[0xe],r8
8000bfc6:	99 c4       	st.w	r12[0x30],r4
8000bfc8:	99 67       	st.w	r12[0x18],r7
8000bfca:	99 9e       	st.w	r12[0x24],lr
8000bfcc:	99 ab       	st.w	r12[0x28],r11
8000bfce:	99 ba       	st.w	r12[0x2c],r10
8000bfd0:	99 47       	st.w	r12[0x10],r7
8000bfd2:	99 57       	st.w	r12[0x14],r7
8000bfd4:	99 8c       	st.w	r12[0x20],r12
8000bfd6:	d8 22       	popm	r4-r7,pc

8000bfd8 <_malloc_trim_r>:
8000bfd8:	d4 21       	pushm	r4-r7,lr
8000bfda:	16 95       	mov	r5,r11
8000bfdc:	18 97       	mov	r7,r12
8000bfde:	fe b0 d7 97 	rcall	80006f0c <__malloc_lock>
8000bfe2:	e0 64 05 54 	mov	r4,1364
8000bfe6:	68 28       	ld.w	r8,r4[0x8]
8000bfe8:	70 16       	ld.w	r6,r8[0x4]
8000bfea:	e0 16 ff fc 	andl	r6,0xfffc
8000bfee:	ec c8 ff 91 	sub	r8,r6,-111
8000bff2:	f0 05 01 05 	sub	r5,r8,r5
8000bff6:	e0 15 ff 80 	andl	r5,0xff80
8000bffa:	ea c5 00 80 	sub	r5,r5,128
8000bffe:	e0 45 00 7f 	cp.w	r5,127
8000c002:	e0 8a 00 25 	brle	8000c04c <_malloc_trim_r+0x74>
8000c006:	30 0b       	mov	r11,0
8000c008:	0e 9c       	mov	r12,r7
8000c00a:	fe b0 e6 05 	rcall	80008c14 <_sbrk_r>
8000c00e:	68 28       	ld.w	r8,r4[0x8]
8000c010:	0c 08       	add	r8,r6
8000c012:	10 3c       	cp.w	r12,r8
8000c014:	c1 c1       	brne	8000c04c <_malloc_trim_r+0x74>
8000c016:	ea 0b 11 00 	rsub	r11,r5,0
8000c01a:	0e 9c       	mov	r12,r7
8000c01c:	fe b0 e5 fc 	rcall	80008c14 <_sbrk_r>
8000c020:	5b fc       	cp.w	r12,-1
8000c022:	c1 91       	brne	8000c054 <_malloc_trim_r+0x7c>
8000c024:	30 0b       	mov	r11,0
8000c026:	0e 9c       	mov	r12,r7
8000c028:	fe b0 e5 f6 	rcall	80008c14 <_sbrk_r>
8000c02c:	68 28       	ld.w	r8,r4[0x8]
8000c02e:	f8 08 01 09 	sub	r9,r12,r8
8000c032:	58 f9       	cp.w	r9,15
8000c034:	e0 8a 00 0c 	brle	8000c04c <_malloc_trim_r+0x74>
8000c038:	a1 a9       	sbr	r9,0x0
8000c03a:	91 19       	st.w	r8[0x4],r9
8000c03c:	e0 68 09 60 	mov	r8,2400
8000c040:	70 09       	ld.w	r9,r8[0x0]
8000c042:	e0 68 0d f4 	mov	r8,3572
8000c046:	f8 09 01 09 	sub	r9,r12,r9
8000c04a:	91 09       	st.w	r8[0x0],r9
8000c04c:	0e 9c       	mov	r12,r7
8000c04e:	fe b0 d7 65 	rcall	80006f18 <__malloc_unlock>
8000c052:	d8 2a       	popm	r4-r7,pc,r12=0
8000c054:	68 28       	ld.w	r8,r4[0x8]
8000c056:	0a 16       	sub	r6,r5
8000c058:	a1 a6       	sbr	r6,0x0
8000c05a:	91 16       	st.w	r8[0x4],r6
8000c05c:	e0 68 0d f4 	mov	r8,3572
8000c060:	70 09       	ld.w	r9,r8[0x0]
8000c062:	0a 19       	sub	r9,r5
8000c064:	0e 9c       	mov	r12,r7
8000c066:	91 09       	st.w	r8[0x0],r9
8000c068:	fe b0 d7 58 	rcall	80006f18 <__malloc_unlock>
8000c06c:	da 2a       	popm	r4-r7,pc,r12=1
8000c06e:	d7 03       	nop

8000c070 <_free_r>:
8000c070:	d4 21       	pushm	r4-r7,lr
8000c072:	16 96       	mov	r6,r11
8000c074:	18 97       	mov	r7,r12
8000c076:	58 0b       	cp.w	r11,0
8000c078:	e0 80 00 c0 	breq	8000c1f8 <_free_r+0x188>
8000c07c:	fe b0 d7 48 	rcall	80006f0c <__malloc_lock>
8000c080:	20 86       	sub	r6,8
8000c082:	e0 6a 05 54 	mov	r10,1364
8000c086:	6c 18       	ld.w	r8,r6[0x4]
8000c088:	74 2e       	ld.w	lr,r10[0x8]
8000c08a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000c08e:	a1 c8       	cbr	r8,0x0
8000c090:	ec 08 00 09 	add	r9,r6,r8
8000c094:	72 1b       	ld.w	r11,r9[0x4]
8000c096:	e0 1b ff fc 	andl	r11,0xfffc
8000c09a:	1c 39       	cp.w	r9,lr
8000c09c:	c1 e1       	brne	8000c0d8 <_free_r+0x68>
8000c09e:	f6 08 00 08 	add	r8,r11,r8
8000c0a2:	58 0c       	cp.w	r12,0
8000c0a4:	c0 81       	brne	8000c0b4 <_free_r+0x44>
8000c0a6:	6c 09       	ld.w	r9,r6[0x0]
8000c0a8:	12 16       	sub	r6,r9
8000c0aa:	12 08       	add	r8,r9
8000c0ac:	6c 3b       	ld.w	r11,r6[0xc]
8000c0ae:	6c 29       	ld.w	r9,r6[0x8]
8000c0b0:	97 29       	st.w	r11[0x8],r9
8000c0b2:	93 3b       	st.w	r9[0xc],r11
8000c0b4:	10 99       	mov	r9,r8
8000c0b6:	95 26       	st.w	r10[0x8],r6
8000c0b8:	a1 a9       	sbr	r9,0x0
8000c0ba:	8d 19       	st.w	r6[0x4],r9
8000c0bc:	e0 69 09 5c 	mov	r9,2396
8000c0c0:	72 09       	ld.w	r9,r9[0x0]
8000c0c2:	12 38       	cp.w	r8,r9
8000c0c4:	c0 63       	brcs	8000c0d0 <_free_r+0x60>
8000c0c6:	e0 68 0d f0 	mov	r8,3568
8000c0ca:	0e 9c       	mov	r12,r7
8000c0cc:	70 0b       	ld.w	r11,r8[0x0]
8000c0ce:	c8 5f       	rcall	8000bfd8 <_malloc_trim_r>
8000c0d0:	0e 9c       	mov	r12,r7
8000c0d2:	fe b0 d7 23 	rcall	80006f18 <__malloc_unlock>
8000c0d6:	d8 22       	popm	r4-r7,pc
8000c0d8:	93 1b       	st.w	r9[0x4],r11
8000c0da:	58 0c       	cp.w	r12,0
8000c0dc:	c0 30       	breq	8000c0e2 <_free_r+0x72>
8000c0de:	30 0c       	mov	r12,0
8000c0e0:	c1 08       	rjmp	8000c100 <_free_r+0x90>
8000c0e2:	6c 0e       	ld.w	lr,r6[0x0]
8000c0e4:	f4 c5 ff f8 	sub	r5,r10,-8
8000c0e8:	1c 16       	sub	r6,lr
8000c0ea:	1c 08       	add	r8,lr
8000c0ec:	6c 2e       	ld.w	lr,r6[0x8]
8000c0ee:	0a 3e       	cp.w	lr,r5
8000c0f0:	f9 bc 00 01 	moveq	r12,1
8000c0f4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000c0f8:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000c0fc:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000c100:	f2 0b 00 0e 	add	lr,r9,r11
8000c104:	7c 1e       	ld.w	lr,lr[0x4]
8000c106:	ed be 00 00 	bld	lr,0x0
8000c10a:	c1 40       	breq	8000c132 <_free_r+0xc2>
8000c10c:	16 08       	add	r8,r11
8000c10e:	58 0c       	cp.w	r12,0
8000c110:	c0 d1       	brne	8000c12a <_free_r+0xba>
8000c112:	e0 6e 05 54 	mov	lr,1364
8000c116:	72 2b       	ld.w	r11,r9[0x8]
8000c118:	2f 8e       	sub	lr,-8
8000c11a:	1c 3b       	cp.w	r11,lr
8000c11c:	c0 71       	brne	8000c12a <_free_r+0xba>
8000c11e:	97 36       	st.w	r11[0xc],r6
8000c120:	97 26       	st.w	r11[0x8],r6
8000c122:	8d 2b       	st.w	r6[0x8],r11
8000c124:	8d 3b       	st.w	r6[0xc],r11
8000c126:	30 1c       	mov	r12,1
8000c128:	c0 58       	rjmp	8000c132 <_free_r+0xc2>
8000c12a:	72 2b       	ld.w	r11,r9[0x8]
8000c12c:	72 39       	ld.w	r9,r9[0xc]
8000c12e:	93 2b       	st.w	r9[0x8],r11
8000c130:	97 39       	st.w	r11[0xc],r9
8000c132:	10 99       	mov	r9,r8
8000c134:	ec 08 09 08 	st.w	r6[r8],r8
8000c138:	a1 a9       	sbr	r9,0x0
8000c13a:	8d 19       	st.w	r6[0x4],r9
8000c13c:	58 0c       	cp.w	r12,0
8000c13e:	c5 a1       	brne	8000c1f2 <_free_r+0x182>
8000c140:	e0 48 01 ff 	cp.w	r8,511
8000c144:	e0 8b 00 13 	brhi	8000c16a <_free_r+0xfa>
8000c148:	a3 98       	lsr	r8,0x3
8000c14a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000c14e:	72 2b       	ld.w	r11,r9[0x8]
8000c150:	8d 39       	st.w	r6[0xc],r9
8000c152:	8d 2b       	st.w	r6[0x8],r11
8000c154:	97 36       	st.w	r11[0xc],r6
8000c156:	93 26       	st.w	r9[0x8],r6
8000c158:	a3 48       	asr	r8,0x2
8000c15a:	74 19       	ld.w	r9,r10[0x4]
8000c15c:	30 1b       	mov	r11,1
8000c15e:	f6 08 09 48 	lsl	r8,r11,r8
8000c162:	f3 e8 10 08 	or	r8,r9,r8
8000c166:	95 18       	st.w	r10[0x4],r8
8000c168:	c4 58       	rjmp	8000c1f2 <_free_r+0x182>
8000c16a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000c16e:	58 4b       	cp.w	r11,4
8000c170:	e0 8b 00 06 	brhi	8000c17c <_free_r+0x10c>
8000c174:	f0 0b 16 06 	lsr	r11,r8,0x6
8000c178:	2c 8b       	sub	r11,-56
8000c17a:	c2 08       	rjmp	8000c1ba <_free_r+0x14a>
8000c17c:	59 4b       	cp.w	r11,20
8000c17e:	e0 8b 00 04 	brhi	8000c186 <_free_r+0x116>
8000c182:	2a 5b       	sub	r11,-91
8000c184:	c1 b8       	rjmp	8000c1ba <_free_r+0x14a>
8000c186:	e0 4b 00 54 	cp.w	r11,84
8000c18a:	e0 8b 00 06 	brhi	8000c196 <_free_r+0x126>
8000c18e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000c192:	29 2b       	sub	r11,-110
8000c194:	c1 38       	rjmp	8000c1ba <_free_r+0x14a>
8000c196:	e0 4b 01 54 	cp.w	r11,340
8000c19a:	e0 8b 00 06 	brhi	8000c1a6 <_free_r+0x136>
8000c19e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000c1a2:	28 9b       	sub	r11,-119
8000c1a4:	c0 b8       	rjmp	8000c1ba <_free_r+0x14a>
8000c1a6:	e0 4b 05 54 	cp.w	r11,1364
8000c1aa:	e0 88 00 05 	brls	8000c1b4 <_free_r+0x144>
8000c1ae:	37 eb       	mov	r11,126
8000c1b0:	c0 58       	rjmp	8000c1ba <_free_r+0x14a>
8000c1b2:	d7 03       	nop
8000c1b4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000c1b8:	28 4b       	sub	r11,-124
8000c1ba:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000c1be:	78 29       	ld.w	r9,r12[0x8]
8000c1c0:	18 39       	cp.w	r9,r12
8000c1c2:	c0 e1       	brne	8000c1de <_free_r+0x16e>
8000c1c4:	74 18       	ld.w	r8,r10[0x4]
8000c1c6:	a3 4b       	asr	r11,0x2
8000c1c8:	30 1c       	mov	r12,1
8000c1ca:	f8 0b 09 4b 	lsl	r11,r12,r11
8000c1ce:	f1 eb 10 0b 	or	r11,r8,r11
8000c1d2:	12 98       	mov	r8,r9
8000c1d4:	95 1b       	st.w	r10[0x4],r11
8000c1d6:	c0 a8       	rjmp	8000c1ea <_free_r+0x17a>
8000c1d8:	72 29       	ld.w	r9,r9[0x8]
8000c1da:	18 39       	cp.w	r9,r12
8000c1dc:	c0 60       	breq	8000c1e8 <_free_r+0x178>
8000c1de:	72 1a       	ld.w	r10,r9[0x4]
8000c1e0:	e0 1a ff fc 	andl	r10,0xfffc
8000c1e4:	14 38       	cp.w	r8,r10
8000c1e6:	cf 93       	brcs	8000c1d8 <_free_r+0x168>
8000c1e8:	72 38       	ld.w	r8,r9[0xc]
8000c1ea:	8d 38       	st.w	r6[0xc],r8
8000c1ec:	8d 29       	st.w	r6[0x8],r9
8000c1ee:	93 36       	st.w	r9[0xc],r6
8000c1f0:	91 26       	st.w	r8[0x8],r6
8000c1f2:	0e 9c       	mov	r12,r7
8000c1f4:	fe b0 d6 92 	rcall	80006f18 <__malloc_unlock>
8000c1f8:	d8 22       	popm	r4-r7,pc
8000c1fa:	d7 03       	nop

8000c1fc <__sfvwrite_r>:
8000c1fc:	d4 31       	pushm	r0-r7,lr
8000c1fe:	20 3d       	sub	sp,12
8000c200:	14 94       	mov	r4,r10
8000c202:	18 95       	mov	r5,r12
8000c204:	16 97       	mov	r7,r11
8000c206:	74 28       	ld.w	r8,r10[0x8]
8000c208:	58 08       	cp.w	r8,0
8000c20a:	e0 80 01 40 	breq	8000c48a <__sfvwrite_r+0x28e>
8000c20e:	96 68       	ld.sh	r8,r11[0xc]
8000c210:	ed b8 00 03 	bld	r8,0x3
8000c214:	c0 41       	brne	8000c21c <__sfvwrite_r+0x20>
8000c216:	76 48       	ld.w	r8,r11[0x10]
8000c218:	58 08       	cp.w	r8,0
8000c21a:	c0 c1       	brne	8000c232 <__sfvwrite_r+0x36>
8000c21c:	0e 9b       	mov	r11,r7
8000c21e:	0a 9c       	mov	r12,r5
8000c220:	fe b0 f6 c4 	rcall	8000afa8 <__swsetup_r>
8000c224:	c0 70       	breq	8000c232 <__sfvwrite_r+0x36>
8000c226:	8e 68       	ld.sh	r8,r7[0xc]
8000c228:	a7 a8       	sbr	r8,0x6
8000c22a:	ae 68       	st.h	r7[0xc],r8
8000c22c:	30 98       	mov	r8,9
8000c22e:	8b 38       	st.w	r5[0xc],r8
8000c230:	c2 b9       	rjmp	8000c486 <__sfvwrite_r+0x28a>
8000c232:	8e 63       	ld.sh	r3,r7[0xc]
8000c234:	68 00       	ld.w	r0,r4[0x0]
8000c236:	06 96       	mov	r6,r3
8000c238:	e2 16 00 02 	andl	r6,0x2,COH
8000c23c:	c2 10       	breq	8000c27e <__sfvwrite_r+0x82>
8000c23e:	30 03       	mov	r3,0
8000c240:	e0 62 04 00 	mov	r2,1024
8000c244:	06 96       	mov	r6,r3
8000c246:	c0 48       	rjmp	8000c24e <__sfvwrite_r+0x52>
8000c248:	60 03       	ld.w	r3,r0[0x0]
8000c24a:	60 16       	ld.w	r6,r0[0x4]
8000c24c:	2f 80       	sub	r0,-8
8000c24e:	58 06       	cp.w	r6,0
8000c250:	cf c0       	breq	8000c248 <__sfvwrite_r+0x4c>
8000c252:	e0 46 04 00 	cp.w	r6,1024
8000c256:	ec 09 17 80 	movls	r9,r6
8000c25a:	e4 09 17 b0 	movhi	r9,r2
8000c25e:	06 9a       	mov	r10,r3
8000c260:	6e a8       	ld.w	r8,r7[0x28]
8000c262:	6e 8b       	ld.w	r11,r7[0x20]
8000c264:	0a 9c       	mov	r12,r5
8000c266:	5d 18       	icall	r8
8000c268:	18 16       	sub	r6,r12
8000c26a:	58 0c       	cp.w	r12,0
8000c26c:	e0 8a 01 0a 	brle	8000c480 <__sfvwrite_r+0x284>
8000c270:	68 28       	ld.w	r8,r4[0x8]
8000c272:	18 18       	sub	r8,r12
8000c274:	89 28       	st.w	r4[0x8],r8
8000c276:	e0 80 01 0a 	breq	8000c48a <__sfvwrite_r+0x28e>
8000c27a:	18 03       	add	r3,r12
8000c27c:	ce 9b       	rjmp	8000c24e <__sfvwrite_r+0x52>
8000c27e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000c282:	c0 70       	breq	8000c290 <__sfvwrite_r+0x94>
8000c284:	50 06       	stdsp	sp[0x0],r6
8000c286:	0c 93       	mov	r3,r6
8000c288:	0c 91       	mov	r1,r6
8000c28a:	50 15       	stdsp	sp[0x4],r5
8000c28c:	08 92       	mov	r2,r4
8000c28e:	c9 c8       	rjmp	8000c3c6 <__sfvwrite_r+0x1ca>
8000c290:	06 96       	mov	r6,r3
8000c292:	08 91       	mov	r1,r4
8000c294:	c0 48       	rjmp	8000c29c <__sfvwrite_r+0xa0>
8000c296:	60 03       	ld.w	r3,r0[0x0]
8000c298:	60 16       	ld.w	r6,r0[0x4]
8000c29a:	2f 80       	sub	r0,-8
8000c29c:	58 06       	cp.w	r6,0
8000c29e:	cf c0       	breq	8000c296 <__sfvwrite_r+0x9a>
8000c2a0:	8e 68       	ld.sh	r8,r7[0xc]
8000c2a2:	6e 24       	ld.w	r4,r7[0x8]
8000c2a4:	10 99       	mov	r9,r8
8000c2a6:	e2 19 02 00 	andl	r9,0x200,COH
8000c2aa:	c5 50       	breq	8000c354 <__sfvwrite_r+0x158>
8000c2ac:	08 36       	cp.w	r6,r4
8000c2ae:	c4 43       	brcs	8000c336 <__sfvwrite_r+0x13a>
8000c2b0:	10 99       	mov	r9,r8
8000c2b2:	e2 19 04 80 	andl	r9,0x480,COH
8000c2b6:	c4 00       	breq	8000c336 <__sfvwrite_r+0x13a>
8000c2b8:	6e 4b       	ld.w	r11,r7[0x10]
8000c2ba:	6e 09       	ld.w	r9,r7[0x0]
8000c2bc:	16 19       	sub	r9,r11
8000c2be:	50 09       	stdsp	sp[0x0],r9
8000c2c0:	6e 59       	ld.w	r9,r7[0x14]
8000c2c2:	10 9c       	mov	r12,r8
8000c2c4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000c2c8:	30 28       	mov	r8,2
8000c2ca:	f4 08 0c 08 	divs	r8,r10,r8
8000c2ce:	fa e9 00 04 	st.d	sp[4],r8
8000c2d2:	10 94       	mov	r4,r8
8000c2d4:	40 09       	lddsp	r9,sp[0x0]
8000c2d6:	e2 1c 04 00 	andl	r12,0x400,COH
8000c2da:	2f f9       	sub	r9,-1
8000c2dc:	0c 09       	add	r9,r6
8000c2de:	12 38       	cp.w	r8,r9
8000c2e0:	f2 04 17 30 	movlo	r4,r9
8000c2e4:	58 0c       	cp.w	r12,0
8000c2e6:	c1 10       	breq	8000c308 <__sfvwrite_r+0x10c>
8000c2e8:	08 9b       	mov	r11,r4
8000c2ea:	0a 9c       	mov	r12,r5
8000c2ec:	fe b0 e0 5a 	rcall	800083a0 <_malloc_r>
8000c2f0:	18 92       	mov	r2,r12
8000c2f2:	c1 40       	breq	8000c31a <__sfvwrite_r+0x11e>
8000c2f4:	40 0a       	lddsp	r10,sp[0x0]
8000c2f6:	6e 4b       	ld.w	r11,r7[0x10]
8000c2f8:	fe b0 e2 83 	rcall	800087fe <memcpy>
8000c2fc:	8e 68       	ld.sh	r8,r7[0xc]
8000c2fe:	e0 18 fb 7f 	andl	r8,0xfb7f
8000c302:	a7 b8       	sbr	r8,0x7
8000c304:	ae 68       	st.h	r7[0xc],r8
8000c306:	c0 d8       	rjmp	8000c320 <__sfvwrite_r+0x124>
8000c308:	08 9a       	mov	r10,r4
8000c30a:	0a 9c       	mov	r12,r5
8000c30c:	fe b0 e3 24 	rcall	80008954 <_realloc_r>
8000c310:	18 92       	mov	r2,r12
8000c312:	c0 71       	brne	8000c320 <__sfvwrite_r+0x124>
8000c314:	6e 4b       	ld.w	r11,r7[0x10]
8000c316:	0a 9c       	mov	r12,r5
8000c318:	ca ce       	rcall	8000c070 <_free_r>
8000c31a:	30 c8       	mov	r8,12
8000c31c:	8b 38       	st.w	r5[0xc],r8
8000c31e:	cb 18       	rjmp	8000c480 <__sfvwrite_r+0x284>
8000c320:	40 0a       	lddsp	r10,sp[0x0]
8000c322:	40 09       	lddsp	r9,sp[0x0]
8000c324:	e8 0a 01 0a 	sub	r10,r4,r10
8000c328:	e4 09 00 08 	add	r8,r2,r9
8000c32c:	8f 54       	st.w	r7[0x14],r4
8000c32e:	8f 2a       	st.w	r7[0x8],r10
8000c330:	8f 08       	st.w	r7[0x0],r8
8000c332:	8f 42       	st.w	r7[0x10],r2
8000c334:	0c 94       	mov	r4,r6
8000c336:	08 36       	cp.w	r6,r4
8000c338:	ec 04 17 30 	movlo	r4,r6
8000c33c:	06 9b       	mov	r11,r3
8000c33e:	08 9a       	mov	r10,r4
8000c340:	6e 0c       	ld.w	r12,r7[0x0]
8000c342:	c3 ad       	rcall	8000c5b6 <memmove>
8000c344:	6e 08       	ld.w	r8,r7[0x0]
8000c346:	08 08       	add	r8,r4
8000c348:	8f 08       	st.w	r7[0x0],r8
8000c34a:	6e 28       	ld.w	r8,r7[0x8]
8000c34c:	08 18       	sub	r8,r4
8000c34e:	0c 94       	mov	r4,r6
8000c350:	8f 28       	st.w	r7[0x8],r8
8000c352:	c2 e8       	rjmp	8000c3ae <__sfvwrite_r+0x1b2>
8000c354:	08 36       	cp.w	r6,r4
8000c356:	5f ba       	srhi	r10
8000c358:	6e 0c       	ld.w	r12,r7[0x0]
8000c35a:	6e 48       	ld.w	r8,r7[0x10]
8000c35c:	10 3c       	cp.w	r12,r8
8000c35e:	5f b8       	srhi	r8
8000c360:	f5 e8 00 08 	and	r8,r10,r8
8000c364:	f2 08 18 00 	cp.b	r8,r9
8000c368:	c0 d0       	breq	8000c382 <__sfvwrite_r+0x186>
8000c36a:	06 9b       	mov	r11,r3
8000c36c:	08 9a       	mov	r10,r4
8000c36e:	c2 4d       	rcall	8000c5b6 <memmove>
8000c370:	6e 08       	ld.w	r8,r7[0x0]
8000c372:	08 08       	add	r8,r4
8000c374:	0e 9b       	mov	r11,r7
8000c376:	8f 08       	st.w	r7[0x0],r8
8000c378:	0a 9c       	mov	r12,r5
8000c37a:	fe b0 fd 09 	rcall	8000bd8c <_fflush_r>
8000c37e:	c1 80       	breq	8000c3ae <__sfvwrite_r+0x1b2>
8000c380:	c8 08       	rjmp	8000c480 <__sfvwrite_r+0x284>
8000c382:	6e 59       	ld.w	r9,r7[0x14]
8000c384:	12 36       	cp.w	r6,r9
8000c386:	c0 a3       	brcs	8000c39a <__sfvwrite_r+0x19e>
8000c388:	6e a8       	ld.w	r8,r7[0x28]
8000c38a:	06 9a       	mov	r10,r3
8000c38c:	6e 8b       	ld.w	r11,r7[0x20]
8000c38e:	0a 9c       	mov	r12,r5
8000c390:	5d 18       	icall	r8
8000c392:	18 94       	mov	r4,r12
8000c394:	e0 89 00 0d 	brgt	8000c3ae <__sfvwrite_r+0x1b2>
8000c398:	c7 48       	rjmp	8000c480 <__sfvwrite_r+0x284>
8000c39a:	0c 9a       	mov	r10,r6
8000c39c:	06 9b       	mov	r11,r3
8000c39e:	c0 cd       	rcall	8000c5b6 <memmove>
8000c3a0:	6e 08       	ld.w	r8,r7[0x0]
8000c3a2:	0c 08       	add	r8,r6
8000c3a4:	0c 94       	mov	r4,r6
8000c3a6:	8f 08       	st.w	r7[0x0],r8
8000c3a8:	6e 28       	ld.w	r8,r7[0x8]
8000c3aa:	0c 18       	sub	r8,r6
8000c3ac:	8f 28       	st.w	r7[0x8],r8
8000c3ae:	62 28       	ld.w	r8,r1[0x8]
8000c3b0:	08 18       	sub	r8,r4
8000c3b2:	83 28       	st.w	r1[0x8],r8
8000c3b4:	c6 b0       	breq	8000c48a <__sfvwrite_r+0x28e>
8000c3b6:	08 16       	sub	r6,r4
8000c3b8:	08 03       	add	r3,r4
8000c3ba:	c7 1b       	rjmp	8000c29c <__sfvwrite_r+0xa0>
8000c3bc:	60 03       	ld.w	r3,r0[0x0]
8000c3be:	60 11       	ld.w	r1,r0[0x4]
8000c3c0:	30 08       	mov	r8,0
8000c3c2:	2f 80       	sub	r0,-8
8000c3c4:	50 08       	stdsp	sp[0x0],r8
8000c3c6:	58 01       	cp.w	r1,0
8000c3c8:	cf a0       	breq	8000c3bc <__sfvwrite_r+0x1c0>
8000c3ca:	40 0a       	lddsp	r10,sp[0x0]
8000c3cc:	58 0a       	cp.w	r10,0
8000c3ce:	c1 41       	brne	8000c3f6 <__sfvwrite_r+0x1fa>
8000c3d0:	e2 c6 ff ff 	sub	r6,r1,-1
8000c3d4:	02 9a       	mov	r10,r1
8000c3d6:	30 ab       	mov	r11,10
8000c3d8:	06 9c       	mov	r12,r3
8000c3da:	ce 3c       	rcall	8000c5a0 <memchr>
8000c3dc:	f8 c8 ff ff 	sub	r8,r12,-1
8000c3e0:	58 0c       	cp.w	r12,0
8000c3e2:	f1 d3 e1 16 	subne	r6,r8,r3
8000c3e6:	f9 b9 01 01 	movne	r9,1
8000c3ea:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c3ee:	f9 b8 00 01 	moveq	r8,1
8000c3f2:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000c3f6:	02 36       	cp.w	r6,r1
8000c3f8:	ec 04 17 80 	movls	r4,r6
8000c3fc:	e2 04 17 b0 	movhi	r4,r1
8000c400:	6e 59       	ld.w	r9,r7[0x14]
8000c402:	6e 25       	ld.w	r5,r7[0x8]
8000c404:	f2 05 00 05 	add	r5,r9,r5
8000c408:	0a 34       	cp.w	r4,r5
8000c40a:	5f 9a       	srgt	r10
8000c40c:	6e 0c       	ld.w	r12,r7[0x0]
8000c40e:	6e 48       	ld.w	r8,r7[0x10]
8000c410:	10 3c       	cp.w	r12,r8
8000c412:	5f b8       	srhi	r8
8000c414:	f5 e8 00 08 	and	r8,r10,r8
8000c418:	30 0a       	mov	r10,0
8000c41a:	f4 08 18 00 	cp.b	r8,r10
8000c41e:	c0 d0       	breq	8000c438 <__sfvwrite_r+0x23c>
8000c420:	06 9b       	mov	r11,r3
8000c422:	0a 9a       	mov	r10,r5
8000c424:	cc 9c       	rcall	8000c5b6 <memmove>
8000c426:	6e 08       	ld.w	r8,r7[0x0]
8000c428:	0a 08       	add	r8,r5
8000c42a:	0e 9b       	mov	r11,r7
8000c42c:	8f 08       	st.w	r7[0x0],r8
8000c42e:	40 1c       	lddsp	r12,sp[0x4]
8000c430:	fe b0 fc ae 	rcall	8000bd8c <_fflush_r>
8000c434:	c1 70       	breq	8000c462 <__sfvwrite_r+0x266>
8000c436:	c2 58       	rjmp	8000c480 <__sfvwrite_r+0x284>
8000c438:	12 34       	cp.w	r4,r9
8000c43a:	c0 a5       	brlt	8000c44e <__sfvwrite_r+0x252>
8000c43c:	6e a8       	ld.w	r8,r7[0x28]
8000c43e:	06 9a       	mov	r10,r3
8000c440:	6e 8b       	ld.w	r11,r7[0x20]
8000c442:	40 1c       	lddsp	r12,sp[0x4]
8000c444:	5d 18       	icall	r8
8000c446:	18 95       	mov	r5,r12
8000c448:	e0 89 00 0d 	brgt	8000c462 <__sfvwrite_r+0x266>
8000c44c:	c1 a8       	rjmp	8000c480 <__sfvwrite_r+0x284>
8000c44e:	08 9a       	mov	r10,r4
8000c450:	06 9b       	mov	r11,r3
8000c452:	cb 2c       	rcall	8000c5b6 <memmove>
8000c454:	6e 08       	ld.w	r8,r7[0x0]
8000c456:	08 08       	add	r8,r4
8000c458:	08 95       	mov	r5,r4
8000c45a:	8f 08       	st.w	r7[0x0],r8
8000c45c:	6e 28       	ld.w	r8,r7[0x8]
8000c45e:	08 18       	sub	r8,r4
8000c460:	8f 28       	st.w	r7[0x8],r8
8000c462:	0a 16       	sub	r6,r5
8000c464:	c0 71       	brne	8000c472 <__sfvwrite_r+0x276>
8000c466:	0e 9b       	mov	r11,r7
8000c468:	40 1c       	lddsp	r12,sp[0x4]
8000c46a:	fe b0 fc 91 	rcall	8000bd8c <_fflush_r>
8000c46e:	c0 91       	brne	8000c480 <__sfvwrite_r+0x284>
8000c470:	50 06       	stdsp	sp[0x0],r6
8000c472:	64 28       	ld.w	r8,r2[0x8]
8000c474:	0a 18       	sub	r8,r5
8000c476:	85 28       	st.w	r2[0x8],r8
8000c478:	c0 90       	breq	8000c48a <__sfvwrite_r+0x28e>
8000c47a:	0a 11       	sub	r1,r5
8000c47c:	0a 03       	add	r3,r5
8000c47e:	ca 4b       	rjmp	8000c3c6 <__sfvwrite_r+0x1ca>
8000c480:	8e 68       	ld.sh	r8,r7[0xc]
8000c482:	a7 a8       	sbr	r8,0x6
8000c484:	ae 68       	st.h	r7[0xc],r8
8000c486:	3f fc       	mov	r12,-1
8000c488:	c0 28       	rjmp	8000c48c <__sfvwrite_r+0x290>
8000c48a:	30 0c       	mov	r12,0
8000c48c:	2f dd       	sub	sp,-12
8000c48e:	d8 32       	popm	r0-r7,pc

8000c490 <_fwalk>:
8000c490:	d4 31       	pushm	r0-r7,lr
8000c492:	30 05       	mov	r5,0
8000c494:	16 91       	mov	r1,r11
8000c496:	f8 c7 ff 28 	sub	r7,r12,-216
8000c49a:	0a 92       	mov	r2,r5
8000c49c:	fe b0 fc fe 	rcall	8000be98 <__sfp_lock_acquire>
8000c4a0:	3f f3       	mov	r3,-1
8000c4a2:	c1 68       	rjmp	8000c4ce <_fwalk+0x3e>
8000c4a4:	6e 26       	ld.w	r6,r7[0x8]
8000c4a6:	6e 14       	ld.w	r4,r7[0x4]
8000c4a8:	2f 46       	sub	r6,-12
8000c4aa:	c0 c8       	rjmp	8000c4c2 <_fwalk+0x32>
8000c4ac:	8c 08       	ld.sh	r8,r6[0x0]
8000c4ae:	e4 08 19 00 	cp.h	r8,r2
8000c4b2:	c0 70       	breq	8000c4c0 <_fwalk+0x30>
8000c4b4:	8c 18       	ld.sh	r8,r6[0x2]
8000c4b6:	e6 08 19 00 	cp.h	r8,r3
8000c4ba:	c0 30       	breq	8000c4c0 <_fwalk+0x30>
8000c4bc:	5d 11       	icall	r1
8000c4be:	18 45       	or	r5,r12
8000c4c0:	2a 46       	sub	r6,-92
8000c4c2:	20 14       	sub	r4,1
8000c4c4:	ec cc 00 0c 	sub	r12,r6,12
8000c4c8:	58 04       	cp.w	r4,0
8000c4ca:	cf 14       	brge	8000c4ac <_fwalk+0x1c>
8000c4cc:	6e 07       	ld.w	r7,r7[0x0]
8000c4ce:	58 07       	cp.w	r7,0
8000c4d0:	ce a1       	brne	8000c4a4 <_fwalk+0x14>
8000c4d2:	fe b0 fc e4 	rcall	8000be9a <__sfp_lock_release>
8000c4d6:	0a 9c       	mov	r12,r5
8000c4d8:	d8 32       	popm	r0-r7,pc
8000c4da:	d7 03       	nop

8000c4dc <_localeconv_r>:
8000c4dc:	fe cc cf f0 	sub	r12,pc,-12304
8000c4e0:	5e fc       	retal	r12
8000c4e2:	d7 03       	nop

8000c4e4 <__smakebuf_r>:
8000c4e4:	d4 21       	pushm	r4-r7,lr
8000c4e6:	20 fd       	sub	sp,60
8000c4e8:	96 68       	ld.sh	r8,r11[0xc]
8000c4ea:	16 97       	mov	r7,r11
8000c4ec:	18 96       	mov	r6,r12
8000c4ee:	e2 18 00 02 	andl	r8,0x2,COH
8000c4f2:	c3 d1       	brne	8000c56c <__smakebuf_r+0x88>
8000c4f4:	96 7b       	ld.sh	r11,r11[0xe]
8000c4f6:	f0 0b 19 00 	cp.h	r11,r8
8000c4fa:	c0 55       	brlt	8000c504 <__smakebuf_r+0x20>
8000c4fc:	1a 9a       	mov	r10,sp
8000c4fe:	e0 a0 04 81 	rcall	8000ce00 <_fstat_r>
8000c502:	c0 f4       	brge	8000c520 <__smakebuf_r+0x3c>
8000c504:	8e 65       	ld.sh	r5,r7[0xc]
8000c506:	0a 98       	mov	r8,r5
8000c508:	ab b8       	sbr	r8,0xb
8000c50a:	e2 15 00 80 	andl	r5,0x80,COH
8000c50e:	ae 68       	st.h	r7[0xc],r8
8000c510:	30 04       	mov	r4,0
8000c512:	e0 68 04 00 	mov	r8,1024
8000c516:	f9 b5 01 40 	movne	r5,64
8000c51a:	f0 05 17 00 	moveq	r5,r8
8000c51e:	c1 c8       	rjmp	8000c556 <__smakebuf_r+0x72>
8000c520:	40 18       	lddsp	r8,sp[0x4]
8000c522:	e2 18 f0 00 	andl	r8,0xf000,COH
8000c526:	e0 48 20 00 	cp.w	r8,8192
8000c52a:	5f 04       	sreq	r4
8000c52c:	e0 48 80 00 	cp.w	r8,32768
8000c530:	c0 e1       	brne	8000c54c <__smakebuf_r+0x68>
8000c532:	6e b9       	ld.w	r9,r7[0x2c]
8000c534:	fe c8 f9 1c 	sub	r8,pc,-1764
8000c538:	10 39       	cp.w	r9,r8
8000c53a:	c0 91       	brne	8000c54c <__smakebuf_r+0x68>
8000c53c:	8e 68       	ld.sh	r8,r7[0xc]
8000c53e:	e0 65 04 00 	mov	r5,1024
8000c542:	ab a8       	sbr	r8,0xa
8000c544:	ef 45 00 50 	st.w	r7[80],r5
8000c548:	ae 68       	st.h	r7[0xc],r8
8000c54a:	c0 68       	rjmp	8000c556 <__smakebuf_r+0x72>
8000c54c:	8e 68       	ld.sh	r8,r7[0xc]
8000c54e:	e0 65 04 00 	mov	r5,1024
8000c552:	ab b8       	sbr	r8,0xb
8000c554:	ae 68       	st.h	r7[0xc],r8
8000c556:	0a 9b       	mov	r11,r5
8000c558:	0c 9c       	mov	r12,r6
8000c55a:	fe b0 df 23 	rcall	800083a0 <_malloc_r>
8000c55e:	8e 68       	ld.sh	r8,r7[0xc]
8000c560:	c0 d1       	brne	8000c57a <__smakebuf_r+0x96>
8000c562:	ed b8 00 09 	bld	r8,0x9
8000c566:	c1 b0       	breq	8000c59c <__smakebuf_r+0xb8>
8000c568:	a1 b8       	sbr	r8,0x1
8000c56a:	ae 68       	st.h	r7[0xc],r8
8000c56c:	ee c8 ff b9 	sub	r8,r7,-71
8000c570:	8f 48       	st.w	r7[0x10],r8
8000c572:	8f 08       	st.w	r7[0x0],r8
8000c574:	30 18       	mov	r8,1
8000c576:	8f 58       	st.w	r7[0x14],r8
8000c578:	c1 28       	rjmp	8000c59c <__smakebuf_r+0xb8>
8000c57a:	a7 b8       	sbr	r8,0x7
8000c57c:	8f 4c       	st.w	r7[0x10],r12
8000c57e:	ae 68       	st.h	r7[0xc],r8
8000c580:	8f 55       	st.w	r7[0x14],r5
8000c582:	fe c8 06 e6 	sub	r8,pc,1766
8000c586:	8f 0c       	st.w	r7[0x0],r12
8000c588:	8d a8       	st.w	r6[0x28],r8
8000c58a:	58 04       	cp.w	r4,0
8000c58c:	c0 80       	breq	8000c59c <__smakebuf_r+0xb8>
8000c58e:	8e 7c       	ld.sh	r12,r7[0xe]
8000c590:	fe b0 e3 94 	rcall	80008cb8 <isatty>
8000c594:	c0 40       	breq	8000c59c <__smakebuf_r+0xb8>
8000c596:	8e 68       	ld.sh	r8,r7[0xc]
8000c598:	a1 a8       	sbr	r8,0x0
8000c59a:	ae 68       	st.h	r7[0xc],r8
8000c59c:	2f 1d       	sub	sp,-60
8000c59e:	d8 22       	popm	r4-r7,pc

8000c5a0 <memchr>:
8000c5a0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000c5a4:	c0 68       	rjmp	8000c5b0 <memchr+0x10>
8000c5a6:	20 1a       	sub	r10,1
8000c5a8:	19 88       	ld.ub	r8,r12[0x0]
8000c5aa:	16 38       	cp.w	r8,r11
8000c5ac:	5e 0c       	reteq	r12
8000c5ae:	2f fc       	sub	r12,-1
8000c5b0:	58 0a       	cp.w	r10,0
8000c5b2:	cf a1       	brne	8000c5a6 <memchr+0x6>
8000c5b4:	5e fa       	retal	r10

8000c5b6 <memmove>:
8000c5b6:	d4 01       	pushm	lr
8000c5b8:	18 3b       	cp.w	r11,r12
8000c5ba:	c1 92       	brcc	8000c5ec <memmove+0x36>
8000c5bc:	f6 0a 00 09 	add	r9,r11,r10
8000c5c0:	12 3c       	cp.w	r12,r9
8000c5c2:	c1 52       	brcc	8000c5ec <memmove+0x36>
8000c5c4:	f8 0a 00 0b 	add	r11,r12,r10
8000c5c8:	30 08       	mov	r8,0
8000c5ca:	c0 68       	rjmp	8000c5d6 <memmove+0x20>
8000c5cc:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000c5d0:	20 1a       	sub	r10,1
8000c5d2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000c5d6:	20 18       	sub	r8,1
8000c5d8:	58 0a       	cp.w	r10,0
8000c5da:	cf 91       	brne	8000c5cc <memmove+0x16>
8000c5dc:	d8 02       	popm	pc
8000c5de:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000c5e2:	20 1a       	sub	r10,1
8000c5e4:	f8 08 0b 09 	st.b	r12[r8],r9
8000c5e8:	2f f8       	sub	r8,-1
8000c5ea:	c0 28       	rjmp	8000c5ee <memmove+0x38>
8000c5ec:	30 08       	mov	r8,0
8000c5ee:	58 0a       	cp.w	r10,0
8000c5f0:	cf 71       	brne	8000c5de <memmove+0x28>
8000c5f2:	d8 02       	popm	pc

8000c5f4 <__hi0bits>:
8000c5f4:	18 98       	mov	r8,r12
8000c5f6:	e0 1c 00 00 	andl	r12,0x0
8000c5fa:	f0 09 15 10 	lsl	r9,r8,0x10
8000c5fe:	58 0c       	cp.w	r12,0
8000c600:	f2 08 17 00 	moveq	r8,r9
8000c604:	f9 bc 00 10 	moveq	r12,16
8000c608:	f9 bc 01 00 	movne	r12,0
8000c60c:	10 9a       	mov	r10,r8
8000c60e:	f0 09 15 08 	lsl	r9,r8,0x8
8000c612:	e6 1a ff 00 	andh	r10,0xff00,COH
8000c616:	f7 bc 00 f8 	subeq	r12,-8
8000c61a:	f2 08 17 00 	moveq	r8,r9
8000c61e:	10 9a       	mov	r10,r8
8000c620:	f0 09 15 04 	lsl	r9,r8,0x4
8000c624:	e6 1a f0 00 	andh	r10,0xf000,COH
8000c628:	f7 bc 00 fc 	subeq	r12,-4
8000c62c:	f2 08 17 00 	moveq	r8,r9
8000c630:	10 9a       	mov	r10,r8
8000c632:	f0 09 15 02 	lsl	r9,r8,0x2
8000c636:	e6 1a c0 00 	andh	r10,0xc000,COH
8000c63a:	f7 bc 00 fe 	subeq	r12,-2
8000c63e:	f2 08 17 00 	moveq	r8,r9
8000c642:	58 08       	cp.w	r8,0
8000c644:	5e 5c       	retlt	r12
8000c646:	ed b8 00 1e 	bld	r8,0x1e
8000c64a:	f9 bc 01 20 	movne	r12,32
8000c64e:	f7 bc 00 ff 	subeq	r12,-1
8000c652:	5e fc       	retal	r12

8000c654 <__lo0bits>:
8000c654:	18 99       	mov	r9,r12
8000c656:	78 08       	ld.w	r8,r12[0x0]
8000c658:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000c65c:	c1 50       	breq	8000c686 <__lo0bits+0x32>
8000c65e:	ed b8 00 00 	bld	r8,0x0
8000c662:	c0 21       	brne	8000c666 <__lo0bits+0x12>
8000c664:	5e fd       	retal	0
8000c666:	10 9b       	mov	r11,r8
8000c668:	f0 0a 16 01 	lsr	r10,r8,0x1
8000c66c:	e2 1b 00 02 	andl	r11,0x2,COH
8000c670:	a3 88       	lsr	r8,0x2
8000c672:	58 0b       	cp.w	r11,0
8000c674:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000c678:	f9 bc 01 01 	movne	r12,1
8000c67c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000c680:	f9 bc 00 02 	moveq	r12,2
8000c684:	5e fc       	retal	r12
8000c686:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000c68a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c68e:	58 0a       	cp.w	r10,0
8000c690:	f6 08 17 00 	moveq	r8,r11
8000c694:	f9 bc 00 10 	moveq	r12,16
8000c698:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000c69c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000c6a0:	58 0b       	cp.w	r11,0
8000c6a2:	f7 bc 00 f8 	subeq	r12,-8
8000c6a6:	f4 08 17 00 	moveq	r8,r10
8000c6aa:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000c6ae:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c6b2:	58 0b       	cp.w	r11,0
8000c6b4:	f7 bc 00 fc 	subeq	r12,-4
8000c6b8:	f4 08 17 00 	moveq	r8,r10
8000c6bc:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000c6c0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000c6c4:	58 0b       	cp.w	r11,0
8000c6c6:	f7 bc 00 fe 	subeq	r12,-2
8000c6ca:	f4 08 17 00 	moveq	r8,r10
8000c6ce:	ed b8 00 00 	bld	r8,0x0
8000c6d2:	c0 60       	breq	8000c6de <__lo0bits+0x8a>
8000c6d4:	a1 98       	lsr	r8,0x1
8000c6d6:	c0 31       	brne	8000c6dc <__lo0bits+0x88>
8000c6d8:	32 0c       	mov	r12,32
8000c6da:	5e fc       	retal	r12
8000c6dc:	2f fc       	sub	r12,-1
8000c6de:	93 08       	st.w	r9[0x0],r8
8000c6e0:	5e fc       	retal	r12

8000c6e2 <__mcmp>:
8000c6e2:	d4 01       	pushm	lr
8000c6e4:	18 98       	mov	r8,r12
8000c6e6:	76 49       	ld.w	r9,r11[0x10]
8000c6e8:	78 4c       	ld.w	r12,r12[0x10]
8000c6ea:	12 1c       	sub	r12,r9
8000c6ec:	c1 31       	brne	8000c712 <__mcmp+0x30>
8000c6ee:	2f b9       	sub	r9,-5
8000c6f0:	a3 69       	lsl	r9,0x2
8000c6f2:	12 0b       	add	r11,r9
8000c6f4:	f0 09 00 09 	add	r9,r8,r9
8000c6f8:	2e c8       	sub	r8,-20
8000c6fa:	13 4e       	ld.w	lr,--r9
8000c6fc:	17 4a       	ld.w	r10,--r11
8000c6fe:	14 3e       	cp.w	lr,r10
8000c700:	c0 60       	breq	8000c70c <__mcmp+0x2a>
8000c702:	f9 bc 03 ff 	movlo	r12,-1
8000c706:	f9 bc 02 01 	movhs	r12,1
8000c70a:	d8 02       	popm	pc
8000c70c:	10 39       	cp.w	r9,r8
8000c70e:	fe 9b ff f6 	brhi	8000c6fa <__mcmp+0x18>
8000c712:	d8 02       	popm	pc

8000c714 <_Bfree>:
8000c714:	d4 21       	pushm	r4-r7,lr
8000c716:	18 97       	mov	r7,r12
8000c718:	16 95       	mov	r5,r11
8000c71a:	78 96       	ld.w	r6,r12[0x24]
8000c71c:	58 06       	cp.w	r6,0
8000c71e:	c0 91       	brne	8000c730 <_Bfree+0x1c>
8000c720:	31 0c       	mov	r12,16
8000c722:	fe b0 de 37 	rcall	80008390 <malloc>
8000c726:	99 36       	st.w	r12[0xc],r6
8000c728:	8f 9c       	st.w	r7[0x24],r12
8000c72a:	99 16       	st.w	r12[0x4],r6
8000c72c:	99 26       	st.w	r12[0x8],r6
8000c72e:	99 06       	st.w	r12[0x0],r6
8000c730:	58 05       	cp.w	r5,0
8000c732:	c0 90       	breq	8000c744 <_Bfree+0x30>
8000c734:	6a 19       	ld.w	r9,r5[0x4]
8000c736:	6e 98       	ld.w	r8,r7[0x24]
8000c738:	70 38       	ld.w	r8,r8[0xc]
8000c73a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000c73e:	8b 0a       	st.w	r5[0x0],r10
8000c740:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000c744:	d8 22       	popm	r4-r7,pc
8000c746:	d7 03       	nop

8000c748 <_Balloc>:
8000c748:	d4 21       	pushm	r4-r7,lr
8000c74a:	18 97       	mov	r7,r12
8000c74c:	16 96       	mov	r6,r11
8000c74e:	78 95       	ld.w	r5,r12[0x24]
8000c750:	58 05       	cp.w	r5,0
8000c752:	c0 91       	brne	8000c764 <_Balloc+0x1c>
8000c754:	31 0c       	mov	r12,16
8000c756:	fe b0 de 1d 	rcall	80008390 <malloc>
8000c75a:	99 35       	st.w	r12[0xc],r5
8000c75c:	8f 9c       	st.w	r7[0x24],r12
8000c75e:	99 15       	st.w	r12[0x4],r5
8000c760:	99 25       	st.w	r12[0x8],r5
8000c762:	99 05       	st.w	r12[0x0],r5
8000c764:	6e 95       	ld.w	r5,r7[0x24]
8000c766:	6a 38       	ld.w	r8,r5[0xc]
8000c768:	58 08       	cp.w	r8,0
8000c76a:	c0 b1       	brne	8000c780 <_Balloc+0x38>
8000c76c:	31 0a       	mov	r10,16
8000c76e:	30 4b       	mov	r11,4
8000c770:	0e 9c       	mov	r12,r7
8000c772:	e0 a0 02 a7 	rcall	8000ccc0 <_calloc_r>
8000c776:	8b 3c       	st.w	r5[0xc],r12
8000c778:	6e 98       	ld.w	r8,r7[0x24]
8000c77a:	70 3c       	ld.w	r12,r8[0xc]
8000c77c:	58 0c       	cp.w	r12,0
8000c77e:	c1 b0       	breq	8000c7b4 <_Balloc+0x6c>
8000c780:	6e 98       	ld.w	r8,r7[0x24]
8000c782:	70 38       	ld.w	r8,r8[0xc]
8000c784:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c788:	70 0c       	ld.w	r12,r8[0x0]
8000c78a:	58 0c       	cp.w	r12,0
8000c78c:	c0 40       	breq	8000c794 <_Balloc+0x4c>
8000c78e:	78 09       	ld.w	r9,r12[0x0]
8000c790:	91 09       	st.w	r8[0x0],r9
8000c792:	c0 e8       	rjmp	8000c7ae <_Balloc+0x66>
8000c794:	0e 9c       	mov	r12,r7
8000c796:	30 17       	mov	r7,1
8000c798:	0e 9b       	mov	r11,r7
8000c79a:	ee 06 09 47 	lsl	r7,r7,r6
8000c79e:	ee ca ff fb 	sub	r10,r7,-5
8000c7a2:	a3 6a       	lsl	r10,0x2
8000c7a4:	e0 a0 02 8e 	rcall	8000ccc0 <_calloc_r>
8000c7a8:	c0 60       	breq	8000c7b4 <_Balloc+0x6c>
8000c7aa:	99 16       	st.w	r12[0x4],r6
8000c7ac:	99 27       	st.w	r12[0x8],r7
8000c7ae:	30 08       	mov	r8,0
8000c7b0:	99 38       	st.w	r12[0xc],r8
8000c7b2:	99 48       	st.w	r12[0x10],r8
8000c7b4:	d8 22       	popm	r4-r7,pc
8000c7b6:	d7 03       	nop

8000c7b8 <__d2b>:
8000c7b8:	d4 31       	pushm	r0-r7,lr
8000c7ba:	20 2d       	sub	sp,8
8000c7bc:	16 93       	mov	r3,r11
8000c7be:	12 96       	mov	r6,r9
8000c7c0:	10 95       	mov	r5,r8
8000c7c2:	14 92       	mov	r2,r10
8000c7c4:	30 1b       	mov	r11,1
8000c7c6:	cc 1f       	rcall	8000c748 <_Balloc>
8000c7c8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c7cc:	50 09       	stdsp	sp[0x0],r9
8000c7ce:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c7d2:	b5 a9       	sbr	r9,0x14
8000c7d4:	f0 01 16 14 	lsr	r1,r8,0x14
8000c7d8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c7dc:	18 94       	mov	r4,r12
8000c7de:	58 02       	cp.w	r2,0
8000c7e0:	c1 d0       	breq	8000c81a <__d2b+0x62>
8000c7e2:	fa cc ff f8 	sub	r12,sp,-8
8000c7e6:	18 d2       	st.w	--r12,r2
8000c7e8:	c3 6f       	rcall	8000c654 <__lo0bits>
8000c7ea:	40 18       	lddsp	r8,sp[0x4]
8000c7ec:	c0 d0       	breq	8000c806 <__d2b+0x4e>
8000c7ee:	40 09       	lddsp	r9,sp[0x0]
8000c7f0:	f8 0a 11 20 	rsub	r10,r12,32
8000c7f4:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c7f8:	f5 e8 10 08 	or	r8,r10,r8
8000c7fc:	89 58       	st.w	r4[0x14],r8
8000c7fe:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c802:	50 09       	stdsp	sp[0x0],r9
8000c804:	c0 28       	rjmp	8000c808 <__d2b+0x50>
8000c806:	89 58       	st.w	r4[0x14],r8
8000c808:	40 08       	lddsp	r8,sp[0x0]
8000c80a:	58 08       	cp.w	r8,0
8000c80c:	f9 b3 01 02 	movne	r3,2
8000c810:	f9 b3 00 01 	moveq	r3,1
8000c814:	89 68       	st.w	r4[0x18],r8
8000c816:	89 43       	st.w	r4[0x10],r3
8000c818:	c0 88       	rjmp	8000c828 <__d2b+0x70>
8000c81a:	1a 9c       	mov	r12,sp
8000c81c:	c1 cf       	rcall	8000c654 <__lo0bits>
8000c81e:	30 13       	mov	r3,1
8000c820:	40 08       	lddsp	r8,sp[0x0]
8000c822:	2e 0c       	sub	r12,-32
8000c824:	89 43       	st.w	r4[0x10],r3
8000c826:	89 58       	st.w	r4[0x14],r8
8000c828:	58 01       	cp.w	r1,0
8000c82a:	c0 90       	breq	8000c83c <__d2b+0x84>
8000c82c:	e2 c1 04 33 	sub	r1,r1,1075
8000c830:	18 01       	add	r1,r12
8000c832:	8d 01       	st.w	r6[0x0],r1
8000c834:	f8 0c 11 35 	rsub	r12,r12,53
8000c838:	8b 0c       	st.w	r5[0x0],r12
8000c83a:	c0 c8       	rjmp	8000c852 <__d2b+0x9a>
8000c83c:	e6 c8 ff fc 	sub	r8,r3,-4
8000c840:	f8 cc 04 32 	sub	r12,r12,1074
8000c844:	a5 73       	lsl	r3,0x5
8000c846:	8d 0c       	st.w	r6[0x0],r12
8000c848:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c84c:	cd 4e       	rcall	8000c5f4 <__hi0bits>
8000c84e:	18 13       	sub	r3,r12
8000c850:	8b 03       	st.w	r5[0x0],r3
8000c852:	08 9c       	mov	r12,r4
8000c854:	2f ed       	sub	sp,-8
8000c856:	d8 32       	popm	r0-r7,pc

8000c858 <__mdiff>:
8000c858:	d4 31       	pushm	r0-r7,lr
8000c85a:	74 48       	ld.w	r8,r10[0x10]
8000c85c:	76 45       	ld.w	r5,r11[0x10]
8000c85e:	16 97       	mov	r7,r11
8000c860:	14 96       	mov	r6,r10
8000c862:	10 15       	sub	r5,r8
8000c864:	c1 31       	brne	8000c88a <__mdiff+0x32>
8000c866:	2f b8       	sub	r8,-5
8000c868:	ee ce ff ec 	sub	lr,r7,-20
8000c86c:	a3 68       	lsl	r8,0x2
8000c86e:	f4 08 00 0b 	add	r11,r10,r8
8000c872:	ee 08 00 08 	add	r8,r7,r8
8000c876:	11 4a       	ld.w	r10,--r8
8000c878:	17 49       	ld.w	r9,--r11
8000c87a:	12 3a       	cp.w	r10,r9
8000c87c:	c0 30       	breq	8000c882 <__mdiff+0x2a>
8000c87e:	c0 e2       	brcc	8000c89a <__mdiff+0x42>
8000c880:	c0 78       	rjmp	8000c88e <__mdiff+0x36>
8000c882:	1c 38       	cp.w	r8,lr
8000c884:	fe 9b ff f9 	brhi	8000c876 <__mdiff+0x1e>
8000c888:	c4 98       	rjmp	8000c91a <__mdiff+0xc2>
8000c88a:	58 05       	cp.w	r5,0
8000c88c:	c0 64       	brge	8000c898 <__mdiff+0x40>
8000c88e:	0e 98       	mov	r8,r7
8000c890:	30 15       	mov	r5,1
8000c892:	0c 97       	mov	r7,r6
8000c894:	10 96       	mov	r6,r8
8000c896:	c0 28       	rjmp	8000c89a <__mdiff+0x42>
8000c898:	30 05       	mov	r5,0
8000c89a:	6e 1b       	ld.w	r11,r7[0x4]
8000c89c:	c5 6f       	rcall	8000c748 <_Balloc>
8000c89e:	6e 49       	ld.w	r9,r7[0x10]
8000c8a0:	6c 44       	ld.w	r4,r6[0x10]
8000c8a2:	99 35       	st.w	r12[0xc],r5
8000c8a4:	2f b4       	sub	r4,-5
8000c8a6:	f2 c5 ff fb 	sub	r5,r9,-5
8000c8aa:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c8ae:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c8b2:	2e c6       	sub	r6,-20
8000c8b4:	2e c7       	sub	r7,-20
8000c8b6:	f8 c8 ff ec 	sub	r8,r12,-20
8000c8ba:	30 0a       	mov	r10,0
8000c8bc:	0f 0e       	ld.w	lr,r7++
8000c8be:	0d 0b       	ld.w	r11,r6++
8000c8c0:	fc 02 16 10 	lsr	r2,lr,0x10
8000c8c4:	f6 03 16 10 	lsr	r3,r11,0x10
8000c8c8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c8cc:	e4 03 01 03 	sub	r3,r2,r3
8000c8d0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c8d4:	fc 0b 01 0b 	sub	r11,lr,r11
8000c8d8:	f6 0a 00 0a 	add	r10,r11,r10
8000c8dc:	b0 1a       	st.h	r8[0x2],r10
8000c8de:	b1 4a       	asr	r10,0x10
8000c8e0:	e6 0a 00 0a 	add	r10,r3,r10
8000c8e4:	b0 0a       	st.h	r8[0x0],r10
8000c8e6:	2f c8       	sub	r8,-4
8000c8e8:	b1 4a       	asr	r10,0x10
8000c8ea:	08 36       	cp.w	r6,r4
8000c8ec:	ce 83       	brcs	8000c8bc <__mdiff+0x64>
8000c8ee:	c0 d8       	rjmp	8000c908 <__mdiff+0xb0>
8000c8f0:	0f 0b       	ld.w	r11,r7++
8000c8f2:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c8f6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c8fa:	16 0a       	add	r10,r11
8000c8fc:	b0 1a       	st.h	r8[0x2],r10
8000c8fe:	b1 4a       	asr	r10,0x10
8000c900:	1c 0a       	add	r10,lr
8000c902:	b0 0a       	st.h	r8[0x0],r10
8000c904:	2f c8       	sub	r8,-4
8000c906:	b1 4a       	asr	r10,0x10
8000c908:	0a 37       	cp.w	r7,r5
8000c90a:	cf 33       	brcs	8000c8f0 <__mdiff+0x98>
8000c90c:	c0 28       	rjmp	8000c910 <__mdiff+0xb8>
8000c90e:	20 19       	sub	r9,1
8000c910:	11 4a       	ld.w	r10,--r8
8000c912:	58 0a       	cp.w	r10,0
8000c914:	cf d0       	breq	8000c90e <__mdiff+0xb6>
8000c916:	99 49       	st.w	r12[0x10],r9
8000c918:	d8 32       	popm	r0-r7,pc
8000c91a:	30 0b       	mov	r11,0
8000c91c:	c1 6f       	rcall	8000c748 <_Balloc>
8000c91e:	30 18       	mov	r8,1
8000c920:	99 48       	st.w	r12[0x10],r8
8000c922:	30 08       	mov	r8,0
8000c924:	99 58       	st.w	r12[0x14],r8
8000c926:	d8 32       	popm	r0-r7,pc

8000c928 <__lshift>:
8000c928:	d4 31       	pushm	r0-r7,lr
8000c92a:	16 97       	mov	r7,r11
8000c92c:	76 46       	ld.w	r6,r11[0x10]
8000c92e:	f4 02 14 05 	asr	r2,r10,0x5
8000c932:	2f f6       	sub	r6,-1
8000c934:	14 93       	mov	r3,r10
8000c936:	18 94       	mov	r4,r12
8000c938:	04 06       	add	r6,r2
8000c93a:	76 1b       	ld.w	r11,r11[0x4]
8000c93c:	6e 28       	ld.w	r8,r7[0x8]
8000c93e:	c0 38       	rjmp	8000c944 <__lshift+0x1c>
8000c940:	2f fb       	sub	r11,-1
8000c942:	a1 78       	lsl	r8,0x1
8000c944:	10 36       	cp.w	r6,r8
8000c946:	fe 99 ff fd 	brgt	8000c940 <__lshift+0x18>
8000c94a:	08 9c       	mov	r12,r4
8000c94c:	cf ee       	rcall	8000c748 <_Balloc>
8000c94e:	30 09       	mov	r9,0
8000c950:	18 95       	mov	r5,r12
8000c952:	f8 c8 ff ec 	sub	r8,r12,-20
8000c956:	12 9a       	mov	r10,r9
8000c958:	c0 38       	rjmp	8000c95e <__lshift+0x36>
8000c95a:	10 aa       	st.w	r8++,r10
8000c95c:	2f f9       	sub	r9,-1
8000c95e:	04 39       	cp.w	r9,r2
8000c960:	cf d5       	brlt	8000c95a <__lshift+0x32>
8000c962:	6e 4b       	ld.w	r11,r7[0x10]
8000c964:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c968:	2f bb       	sub	r11,-5
8000c96a:	ee c9 ff ec 	sub	r9,r7,-20
8000c96e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c972:	58 03       	cp.w	r3,0
8000c974:	c1 30       	breq	8000c99a <__lshift+0x72>
8000c976:	e6 0c 11 20 	rsub	r12,r3,32
8000c97a:	30 0a       	mov	r10,0
8000c97c:	72 02       	ld.w	r2,r9[0x0]
8000c97e:	e4 03 09 42 	lsl	r2,r2,r3
8000c982:	04 4a       	or	r10,r2
8000c984:	10 aa       	st.w	r8++,r10
8000c986:	13 0a       	ld.w	r10,r9++
8000c988:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c98c:	16 39       	cp.w	r9,r11
8000c98e:	cf 73       	brcs	8000c97c <__lshift+0x54>
8000c990:	91 0a       	st.w	r8[0x0],r10
8000c992:	58 0a       	cp.w	r10,0
8000c994:	c0 70       	breq	8000c9a2 <__lshift+0x7a>
8000c996:	2f f6       	sub	r6,-1
8000c998:	c0 58       	rjmp	8000c9a2 <__lshift+0x7a>
8000c99a:	13 0a       	ld.w	r10,r9++
8000c99c:	10 aa       	st.w	r8++,r10
8000c99e:	16 39       	cp.w	r9,r11
8000c9a0:	cf d3       	brcs	8000c99a <__lshift+0x72>
8000c9a2:	08 9c       	mov	r12,r4
8000c9a4:	20 16       	sub	r6,1
8000c9a6:	0e 9b       	mov	r11,r7
8000c9a8:	8b 46       	st.w	r5[0x10],r6
8000c9aa:	cb 5e       	rcall	8000c714 <_Bfree>
8000c9ac:	0a 9c       	mov	r12,r5
8000c9ae:	d8 32       	popm	r0-r7,pc

8000c9b0 <__multiply>:
8000c9b0:	d4 31       	pushm	r0-r7,lr
8000c9b2:	20 2d       	sub	sp,8
8000c9b4:	76 49       	ld.w	r9,r11[0x10]
8000c9b6:	74 48       	ld.w	r8,r10[0x10]
8000c9b8:	16 96       	mov	r6,r11
8000c9ba:	14 95       	mov	r5,r10
8000c9bc:	10 39       	cp.w	r9,r8
8000c9be:	ec 08 17 50 	movlt	r8,r6
8000c9c2:	ea 06 17 50 	movlt	r6,r5
8000c9c6:	f0 05 17 50 	movlt	r5,r8
8000c9ca:	6c 28       	ld.w	r8,r6[0x8]
8000c9cc:	76 43       	ld.w	r3,r11[0x10]
8000c9ce:	74 42       	ld.w	r2,r10[0x10]
8000c9d0:	76 1b       	ld.w	r11,r11[0x4]
8000c9d2:	e4 03 00 07 	add	r7,r2,r3
8000c9d6:	10 37       	cp.w	r7,r8
8000c9d8:	f7 bb 09 ff 	subgt	r11,-1
8000c9dc:	cb 6e       	rcall	8000c748 <_Balloc>
8000c9de:	ee c4 ff fb 	sub	r4,r7,-5
8000c9e2:	f8 c9 ff ec 	sub	r9,r12,-20
8000c9e6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c9ea:	30 0a       	mov	r10,0
8000c9ec:	12 98       	mov	r8,r9
8000c9ee:	c0 28       	rjmp	8000c9f2 <__multiply+0x42>
8000c9f0:	10 aa       	st.w	r8++,r10
8000c9f2:	08 38       	cp.w	r8,r4
8000c9f4:	cf e3       	brcs	8000c9f0 <__multiply+0x40>
8000c9f6:	2f b3       	sub	r3,-5
8000c9f8:	2f b2       	sub	r2,-5
8000c9fa:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c9fe:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ca02:	ec cb ff ec 	sub	r11,r6,-20
8000ca06:	50 12       	stdsp	sp[0x4],r2
8000ca08:	ea ca ff ec 	sub	r10,r5,-20
8000ca0c:	c4 48       	rjmp	8000ca94 <__multiply+0xe4>
8000ca0e:	94 95       	ld.uh	r5,r10[0x2]
8000ca10:	58 05       	cp.w	r5,0
8000ca12:	c2 00       	breq	8000ca52 <__multiply+0xa2>
8000ca14:	12 98       	mov	r8,r9
8000ca16:	16 96       	mov	r6,r11
8000ca18:	30 0e       	mov	lr,0
8000ca1a:	50 09       	stdsp	sp[0x0],r9
8000ca1c:	0d 02       	ld.w	r2,r6++
8000ca1e:	e4 00 16 10 	lsr	r0,r2,0x10
8000ca22:	70 01       	ld.w	r1,r8[0x0]
8000ca24:	70 09       	ld.w	r9,r8[0x0]
8000ca26:	b1 81       	lsr	r1,0x10
8000ca28:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ca2c:	e0 05 03 41 	mac	r1,r0,r5
8000ca30:	ab 32       	mul	r2,r5
8000ca32:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ca36:	00 02       	add	r2,r0
8000ca38:	e4 0e 00 0e 	add	lr,r2,lr
8000ca3c:	b0 1e       	st.h	r8[0x2],lr
8000ca3e:	b1 8e       	lsr	lr,0x10
8000ca40:	1c 01       	add	r1,lr
8000ca42:	b0 01       	st.h	r8[0x0],r1
8000ca44:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ca48:	2f c8       	sub	r8,-4
8000ca4a:	06 36       	cp.w	r6,r3
8000ca4c:	ce 83       	brcs	8000ca1c <__multiply+0x6c>
8000ca4e:	40 09       	lddsp	r9,sp[0x0]
8000ca50:	91 0e       	st.w	r8[0x0],lr
8000ca52:	94 86       	ld.uh	r6,r10[0x0]
8000ca54:	58 06       	cp.w	r6,0
8000ca56:	c1 d0       	breq	8000ca90 <__multiply+0xe0>
8000ca58:	72 02       	ld.w	r2,r9[0x0]
8000ca5a:	12 98       	mov	r8,r9
8000ca5c:	16 9e       	mov	lr,r11
8000ca5e:	30 05       	mov	r5,0
8000ca60:	b0 12       	st.h	r8[0x2],r2
8000ca62:	1d 01       	ld.w	r1,lr++
8000ca64:	90 82       	ld.uh	r2,r8[0x0]
8000ca66:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ca6a:	ad 30       	mul	r0,r6
8000ca6c:	e0 02 00 02 	add	r2,r0,r2
8000ca70:	e4 05 00 05 	add	r5,r2,r5
8000ca74:	b0 05       	st.h	r8[0x0],r5
8000ca76:	b1 85       	lsr	r5,0x10
8000ca78:	b1 81       	lsr	r1,0x10
8000ca7a:	2f c8       	sub	r8,-4
8000ca7c:	ad 31       	mul	r1,r6
8000ca7e:	90 92       	ld.uh	r2,r8[0x2]
8000ca80:	e2 02 00 02 	add	r2,r1,r2
8000ca84:	0a 02       	add	r2,r5
8000ca86:	e4 05 16 10 	lsr	r5,r2,0x10
8000ca8a:	06 3e       	cp.w	lr,r3
8000ca8c:	ce a3       	brcs	8000ca60 <__multiply+0xb0>
8000ca8e:	91 02       	st.w	r8[0x0],r2
8000ca90:	2f ca       	sub	r10,-4
8000ca92:	2f c9       	sub	r9,-4
8000ca94:	40 18       	lddsp	r8,sp[0x4]
8000ca96:	10 3a       	cp.w	r10,r8
8000ca98:	cb b3       	brcs	8000ca0e <__multiply+0x5e>
8000ca9a:	c0 28       	rjmp	8000ca9e <__multiply+0xee>
8000ca9c:	20 17       	sub	r7,1
8000ca9e:	58 07       	cp.w	r7,0
8000caa0:	e0 8a 00 05 	brle	8000caaa <__multiply+0xfa>
8000caa4:	09 48       	ld.w	r8,--r4
8000caa6:	58 08       	cp.w	r8,0
8000caa8:	cf a0       	breq	8000ca9c <__multiply+0xec>
8000caaa:	99 47       	st.w	r12[0x10],r7
8000caac:	2f ed       	sub	sp,-8
8000caae:	d8 32       	popm	r0-r7,pc

8000cab0 <__i2b>:
8000cab0:	d4 21       	pushm	r4-r7,lr
8000cab2:	16 97       	mov	r7,r11
8000cab4:	30 1b       	mov	r11,1
8000cab6:	c4 9e       	rcall	8000c748 <_Balloc>
8000cab8:	30 19       	mov	r9,1
8000caba:	99 57       	st.w	r12[0x14],r7
8000cabc:	99 49       	st.w	r12[0x10],r9
8000cabe:	d8 22       	popm	r4-r7,pc

8000cac0 <__multadd>:
8000cac0:	d4 31       	pushm	r0-r7,lr
8000cac2:	30 08       	mov	r8,0
8000cac4:	12 95       	mov	r5,r9
8000cac6:	16 97       	mov	r7,r11
8000cac8:	18 96       	mov	r6,r12
8000caca:	76 44       	ld.w	r4,r11[0x10]
8000cacc:	f6 c9 ff ec 	sub	r9,r11,-20
8000cad0:	72 0b       	ld.w	r11,r9[0x0]
8000cad2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000cad6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000cada:	f4 0c 02 4c 	mul	r12,r10,r12
8000cade:	f4 0b 03 45 	mac	r5,r10,r11
8000cae2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000cae6:	b1 85       	lsr	r5,0x10
8000cae8:	18 05       	add	r5,r12
8000caea:	ea 0c 15 10 	lsl	r12,r5,0x10
8000caee:	f8 0b 00 0b 	add	r11,r12,r11
8000caf2:	12 ab       	st.w	r9++,r11
8000caf4:	2f f8       	sub	r8,-1
8000caf6:	b1 85       	lsr	r5,0x10
8000caf8:	08 38       	cp.w	r8,r4
8000cafa:	ce b5       	brlt	8000cad0 <__multadd+0x10>
8000cafc:	58 05       	cp.w	r5,0
8000cafe:	c1 c0       	breq	8000cb36 <__multadd+0x76>
8000cb00:	6e 28       	ld.w	r8,r7[0x8]
8000cb02:	10 34       	cp.w	r4,r8
8000cb04:	c1 35       	brlt	8000cb2a <__multadd+0x6a>
8000cb06:	6e 1b       	ld.w	r11,r7[0x4]
8000cb08:	0c 9c       	mov	r12,r6
8000cb0a:	2f fb       	sub	r11,-1
8000cb0c:	c1 ee       	rcall	8000c748 <_Balloc>
8000cb0e:	6e 4a       	ld.w	r10,r7[0x10]
8000cb10:	ee cb ff f4 	sub	r11,r7,-12
8000cb14:	18 93       	mov	r3,r12
8000cb16:	2f ea       	sub	r10,-2
8000cb18:	2f 4c       	sub	r12,-12
8000cb1a:	a3 6a       	lsl	r10,0x2
8000cb1c:	fe b0 de 71 	rcall	800087fe <memcpy>
8000cb20:	0e 9b       	mov	r11,r7
8000cb22:	0c 9c       	mov	r12,r6
8000cb24:	fe b0 fd f8 	rcall	8000c714 <_Bfree>
8000cb28:	06 97       	mov	r7,r3
8000cb2a:	e8 c8 ff ff 	sub	r8,r4,-1
8000cb2e:	2f b4       	sub	r4,-5
8000cb30:	8f 48       	st.w	r7[0x10],r8
8000cb32:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000cb36:	0e 9c       	mov	r12,r7
8000cb38:	d8 32       	popm	r0-r7,pc
8000cb3a:	d7 03       	nop

8000cb3c <__pow5mult>:
8000cb3c:	d4 31       	pushm	r0-r7,lr
8000cb3e:	14 96       	mov	r6,r10
8000cb40:	18 97       	mov	r7,r12
8000cb42:	16 94       	mov	r4,r11
8000cb44:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000cb48:	c0 90       	breq	8000cb5a <__pow5mult+0x1e>
8000cb4a:	20 18       	sub	r8,1
8000cb4c:	fe c9 d6 24 	sub	r9,pc,-10716
8000cb50:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000cb54:	30 09       	mov	r9,0
8000cb56:	cb 5f       	rcall	8000cac0 <__multadd>
8000cb58:	18 94       	mov	r4,r12
8000cb5a:	a3 46       	asr	r6,0x2
8000cb5c:	c3 40       	breq	8000cbc4 <__pow5mult+0x88>
8000cb5e:	6e 95       	ld.w	r5,r7[0x24]
8000cb60:	58 05       	cp.w	r5,0
8000cb62:	c0 91       	brne	8000cb74 <__pow5mult+0x38>
8000cb64:	31 0c       	mov	r12,16
8000cb66:	fe b0 dc 15 	rcall	80008390 <malloc>
8000cb6a:	99 35       	st.w	r12[0xc],r5
8000cb6c:	8f 9c       	st.w	r7[0x24],r12
8000cb6e:	99 15       	st.w	r12[0x4],r5
8000cb70:	99 25       	st.w	r12[0x8],r5
8000cb72:	99 05       	st.w	r12[0x0],r5
8000cb74:	6e 93       	ld.w	r3,r7[0x24]
8000cb76:	66 25       	ld.w	r5,r3[0x8]
8000cb78:	58 05       	cp.w	r5,0
8000cb7a:	c0 c1       	brne	8000cb92 <__pow5mult+0x56>
8000cb7c:	e0 6b 02 71 	mov	r11,625
8000cb80:	0e 9c       	mov	r12,r7
8000cb82:	c9 7f       	rcall	8000cab0 <__i2b>
8000cb84:	87 2c       	st.w	r3[0x8],r12
8000cb86:	30 08       	mov	r8,0
8000cb88:	18 95       	mov	r5,r12
8000cb8a:	99 08       	st.w	r12[0x0],r8
8000cb8c:	c0 38       	rjmp	8000cb92 <__pow5mult+0x56>
8000cb8e:	06 9c       	mov	r12,r3
8000cb90:	18 95       	mov	r5,r12
8000cb92:	ed b6 00 00 	bld	r6,0x0
8000cb96:	c0 b1       	brne	8000cbac <__pow5mult+0x70>
8000cb98:	08 9b       	mov	r11,r4
8000cb9a:	0a 9a       	mov	r10,r5
8000cb9c:	0e 9c       	mov	r12,r7
8000cb9e:	c0 9f       	rcall	8000c9b0 <__multiply>
8000cba0:	08 9b       	mov	r11,r4
8000cba2:	18 93       	mov	r3,r12
8000cba4:	0e 9c       	mov	r12,r7
8000cba6:	06 94       	mov	r4,r3
8000cba8:	fe b0 fd b6 	rcall	8000c714 <_Bfree>
8000cbac:	a1 56       	asr	r6,0x1
8000cbae:	c0 b0       	breq	8000cbc4 <__pow5mult+0x88>
8000cbb0:	6a 03       	ld.w	r3,r5[0x0]
8000cbb2:	58 03       	cp.w	r3,0
8000cbb4:	ce d1       	brne	8000cb8e <__pow5mult+0x52>
8000cbb6:	0a 9a       	mov	r10,r5
8000cbb8:	0a 9b       	mov	r11,r5
8000cbba:	0e 9c       	mov	r12,r7
8000cbbc:	cf ae       	rcall	8000c9b0 <__multiply>
8000cbbe:	8b 0c       	st.w	r5[0x0],r12
8000cbc0:	99 03       	st.w	r12[0x0],r3
8000cbc2:	ce 7b       	rjmp	8000cb90 <__pow5mult+0x54>
8000cbc4:	08 9c       	mov	r12,r4
8000cbc6:	d8 32       	popm	r0-r7,pc

8000cbc8 <__isinfd>:
8000cbc8:	14 98       	mov	r8,r10
8000cbca:	fc 19 7f f0 	movh	r9,0x7ff0
8000cbce:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cbd2:	f0 0b 11 00 	rsub	r11,r8,0
8000cbd6:	f7 e8 10 08 	or	r8,r11,r8
8000cbda:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000cbde:	f2 08 01 08 	sub	r8,r9,r8
8000cbe2:	f0 0c 11 00 	rsub	r12,r8,0
8000cbe6:	f9 e8 10 08 	or	r8,r12,r8
8000cbea:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000cbee:	2f fc       	sub	r12,-1
8000cbf0:	5e fc       	retal	r12

8000cbf2 <__isnand>:
8000cbf2:	14 98       	mov	r8,r10
8000cbf4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000cbf8:	f0 0c 11 00 	rsub	r12,r8,0
8000cbfc:	10 4c       	or	r12,r8
8000cbfe:	fc 18 7f f0 	movh	r8,0x7ff0
8000cc02:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000cc06:	f0 0c 01 0c 	sub	r12,r8,r12
8000cc0a:	bf 9c       	lsr	r12,0x1f
8000cc0c:	5e fc       	retal	r12
8000cc0e:	d7 03       	nop

8000cc10 <__sclose>:
8000cc10:	d4 01       	pushm	lr
8000cc12:	96 7b       	ld.sh	r11,r11[0xe]
8000cc14:	c8 2c       	rcall	8000cd18 <_close_r>
8000cc16:	d8 02       	popm	pc

8000cc18 <__sseek>:
8000cc18:	d4 21       	pushm	r4-r7,lr
8000cc1a:	16 97       	mov	r7,r11
8000cc1c:	96 7b       	ld.sh	r11,r11[0xe]
8000cc1e:	c0 3d       	rcall	8000ce24 <_lseek_r>
8000cc20:	8e 68       	ld.sh	r8,r7[0xc]
8000cc22:	10 99       	mov	r9,r8
8000cc24:	ad c8       	cbr	r8,0xc
8000cc26:	ad a9       	sbr	r9,0xc
8000cc28:	5b fc       	cp.w	r12,-1
8000cc2a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000cc2e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000cc32:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000cc36:	d8 22       	popm	r4-r7,pc

8000cc38 <__swrite>:
8000cc38:	d4 21       	pushm	r4-r7,lr
8000cc3a:	96 68       	ld.sh	r8,r11[0xc]
8000cc3c:	16 97       	mov	r7,r11
8000cc3e:	14 95       	mov	r5,r10
8000cc40:	12 94       	mov	r4,r9
8000cc42:	e2 18 01 00 	andl	r8,0x100,COH
8000cc46:	18 96       	mov	r6,r12
8000cc48:	c0 50       	breq	8000cc52 <__swrite+0x1a>
8000cc4a:	30 29       	mov	r9,2
8000cc4c:	30 0a       	mov	r10,0
8000cc4e:	96 7b       	ld.sh	r11,r11[0xe]
8000cc50:	ce ac       	rcall	8000ce24 <_lseek_r>
8000cc52:	8e 68       	ld.sh	r8,r7[0xc]
8000cc54:	ad c8       	cbr	r8,0xc
8000cc56:	08 99       	mov	r9,r4
8000cc58:	0a 9a       	mov	r10,r5
8000cc5a:	8e 7b       	ld.sh	r11,r7[0xe]
8000cc5c:	0c 9c       	mov	r12,r6
8000cc5e:	ae 68       	st.h	r7[0xc],r8
8000cc60:	c1 cc       	rcall	8000cc98 <_write_r>
8000cc62:	d8 22       	popm	r4-r7,pc

8000cc64 <__sread>:
8000cc64:	d4 21       	pushm	r4-r7,lr
8000cc66:	16 97       	mov	r7,r11
8000cc68:	96 7b       	ld.sh	r11,r11[0xe]
8000cc6a:	cf 1c       	rcall	8000ce4c <_read_r>
8000cc6c:	c0 65       	brlt	8000cc78 <__sread+0x14>
8000cc6e:	6f 58       	ld.w	r8,r7[0x54]
8000cc70:	18 08       	add	r8,r12
8000cc72:	ef 48 00 54 	st.w	r7[84],r8
8000cc76:	d8 22       	popm	r4-r7,pc
8000cc78:	8e 68       	ld.sh	r8,r7[0xc]
8000cc7a:	ad c8       	cbr	r8,0xc
8000cc7c:	ae 68       	st.h	r7[0xc],r8
8000cc7e:	d8 22       	popm	r4-r7,pc

8000cc80 <strlen>:
8000cc80:	30 09       	mov	r9,0
8000cc82:	18 98       	mov	r8,r12
8000cc84:	c0 28       	rjmp	8000cc88 <strlen+0x8>
8000cc86:	2f f8       	sub	r8,-1
8000cc88:	11 8a       	ld.ub	r10,r8[0x0]
8000cc8a:	f2 0a 18 00 	cp.b	r10,r9
8000cc8e:	cf c1       	brne	8000cc86 <strlen+0x6>
8000cc90:	f0 0c 01 0c 	sub	r12,r8,r12
8000cc94:	5e fc       	retal	r12
8000cc96:	d7 03       	nop

8000cc98 <_write_r>:
8000cc98:	d4 21       	pushm	r4-r7,lr
8000cc9a:	16 98       	mov	r8,r11
8000cc9c:	18 97       	mov	r7,r12
8000cc9e:	10 9c       	mov	r12,r8
8000cca0:	30 08       	mov	r8,0
8000cca2:	14 9b       	mov	r11,r10
8000cca4:	e0 66 bd 4c 	mov	r6,48460
8000cca8:	12 9a       	mov	r10,r9
8000ccaa:	8d 08       	st.w	r6[0x0],r8
8000ccac:	fe b0 d1 5c 	rcall	80006f64 <_write>
8000ccb0:	5b fc       	cp.w	r12,-1
8000ccb2:	c0 51       	brne	8000ccbc <_write_r+0x24>
8000ccb4:	6c 08       	ld.w	r8,r6[0x0]
8000ccb6:	58 08       	cp.w	r8,0
8000ccb8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ccbc:	d8 22       	popm	r4-r7,pc
8000ccbe:	d7 03       	nop

8000ccc0 <_calloc_r>:
8000ccc0:	d4 21       	pushm	r4-r7,lr
8000ccc2:	f4 0b 02 4b 	mul	r11,r10,r11
8000ccc6:	fe b0 db 6d 	rcall	800083a0 <_malloc_r>
8000ccca:	18 97       	mov	r7,r12
8000cccc:	c2 30       	breq	8000cd12 <_calloc_r+0x52>
8000ccce:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ccd2:	e0 1a ff fc 	andl	r10,0xfffc
8000ccd6:	20 4a       	sub	r10,4
8000ccd8:	e0 4a 00 24 	cp.w	r10,36
8000ccdc:	e0 8b 00 18 	brhi	8000cd0c <_calloc_r+0x4c>
8000cce0:	18 98       	mov	r8,r12
8000cce2:	59 3a       	cp.w	r10,19
8000cce4:	e0 88 00 0f 	brls	8000cd02 <_calloc_r+0x42>
8000cce8:	30 09       	mov	r9,0
8000ccea:	10 a9       	st.w	r8++,r9
8000ccec:	10 a9       	st.w	r8++,r9
8000ccee:	59 ba       	cp.w	r10,27
8000ccf0:	e0 88 00 09 	brls	8000cd02 <_calloc_r+0x42>
8000ccf4:	10 a9       	st.w	r8++,r9
8000ccf6:	10 a9       	st.w	r8++,r9
8000ccf8:	e0 4a 00 24 	cp.w	r10,36
8000ccfc:	c0 31       	brne	8000cd02 <_calloc_r+0x42>
8000ccfe:	10 a9       	st.w	r8++,r9
8000cd00:	10 a9       	st.w	r8++,r9
8000cd02:	30 09       	mov	r9,0
8000cd04:	10 a9       	st.w	r8++,r9
8000cd06:	91 19       	st.w	r8[0x4],r9
8000cd08:	91 09       	st.w	r8[0x0],r9
8000cd0a:	c0 48       	rjmp	8000cd12 <_calloc_r+0x52>
8000cd0c:	30 0b       	mov	r11,0
8000cd0e:	fe b0 de 1c 	rcall	80008946 <memset>
8000cd12:	0e 9c       	mov	r12,r7
8000cd14:	d8 22       	popm	r4-r7,pc
8000cd16:	d7 03       	nop

8000cd18 <_close_r>:
8000cd18:	d4 21       	pushm	r4-r7,lr
8000cd1a:	30 08       	mov	r8,0
8000cd1c:	18 97       	mov	r7,r12
8000cd1e:	e0 66 bd 4c 	mov	r6,48460
8000cd22:	16 9c       	mov	r12,r11
8000cd24:	8d 08       	st.w	r6[0x0],r8
8000cd26:	fe b0 df b5 	rcall	80008c90 <_close>
8000cd2a:	5b fc       	cp.w	r12,-1
8000cd2c:	c0 51       	brne	8000cd36 <_close_r+0x1e>
8000cd2e:	6c 08       	ld.w	r8,r6[0x0]
8000cd30:	58 08       	cp.w	r8,0
8000cd32:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cd36:	d8 22       	popm	r4-r7,pc

8000cd38 <_fclose_r>:
8000cd38:	d4 21       	pushm	r4-r7,lr
8000cd3a:	18 96       	mov	r6,r12
8000cd3c:	16 97       	mov	r7,r11
8000cd3e:	58 0b       	cp.w	r11,0
8000cd40:	c0 31       	brne	8000cd46 <_fclose_r+0xe>
8000cd42:	16 95       	mov	r5,r11
8000cd44:	c5 38       	rjmp	8000cdea <_fclose_r+0xb2>
8000cd46:	fe b0 f8 a9 	rcall	8000be98 <__sfp_lock_acquire>
8000cd4a:	58 06       	cp.w	r6,0
8000cd4c:	c0 70       	breq	8000cd5a <_fclose_r+0x22>
8000cd4e:	6c 68       	ld.w	r8,r6[0x18]
8000cd50:	58 08       	cp.w	r8,0
8000cd52:	c0 41       	brne	8000cd5a <_fclose_r+0x22>
8000cd54:	0c 9c       	mov	r12,r6
8000cd56:	fe b0 f8 f3 	rcall	8000bf3c <__sinit>
8000cd5a:	fe c8 d8 d6 	sub	r8,pc,-10026
8000cd5e:	10 37       	cp.w	r7,r8
8000cd60:	c0 31       	brne	8000cd66 <_fclose_r+0x2e>
8000cd62:	6c 07       	ld.w	r7,r6[0x0]
8000cd64:	c0 c8       	rjmp	8000cd7c <_fclose_r+0x44>
8000cd66:	fe c8 d8 c2 	sub	r8,pc,-10046
8000cd6a:	10 37       	cp.w	r7,r8
8000cd6c:	c0 31       	brne	8000cd72 <_fclose_r+0x3a>
8000cd6e:	6c 17       	ld.w	r7,r6[0x4]
8000cd70:	c0 68       	rjmp	8000cd7c <_fclose_r+0x44>
8000cd72:	fe c8 d8 ae 	sub	r8,pc,-10066
8000cd76:	10 37       	cp.w	r7,r8
8000cd78:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000cd7c:	8e 69       	ld.sh	r9,r7[0xc]
8000cd7e:	30 08       	mov	r8,0
8000cd80:	f0 09 19 00 	cp.h	r9,r8
8000cd84:	c0 51       	brne	8000cd8e <_fclose_r+0x56>
8000cd86:	fe b0 f8 8a 	rcall	8000be9a <__sfp_lock_release>
8000cd8a:	30 05       	mov	r5,0
8000cd8c:	c2 f8       	rjmp	8000cdea <_fclose_r+0xb2>
8000cd8e:	0e 9b       	mov	r11,r7
8000cd90:	0c 9c       	mov	r12,r6
8000cd92:	fe b0 f7 fd 	rcall	8000bd8c <_fflush_r>
8000cd96:	6e c8       	ld.w	r8,r7[0x30]
8000cd98:	18 95       	mov	r5,r12
8000cd9a:	58 08       	cp.w	r8,0
8000cd9c:	c0 60       	breq	8000cda8 <_fclose_r+0x70>
8000cd9e:	6e 8b       	ld.w	r11,r7[0x20]
8000cda0:	0c 9c       	mov	r12,r6
8000cda2:	5d 18       	icall	r8
8000cda4:	f9 b5 05 ff 	movlt	r5,-1
8000cda8:	8e 68       	ld.sh	r8,r7[0xc]
8000cdaa:	ed b8 00 07 	bld	r8,0x7
8000cdae:	c0 51       	brne	8000cdb8 <_fclose_r+0x80>
8000cdb0:	6e 4b       	ld.w	r11,r7[0x10]
8000cdb2:	0c 9c       	mov	r12,r6
8000cdb4:	fe b0 f9 5e 	rcall	8000c070 <_free_r>
8000cdb8:	6e db       	ld.w	r11,r7[0x34]
8000cdba:	58 0b       	cp.w	r11,0
8000cdbc:	c0 a0       	breq	8000cdd0 <_fclose_r+0x98>
8000cdbe:	ee c8 ff bc 	sub	r8,r7,-68
8000cdc2:	10 3b       	cp.w	r11,r8
8000cdc4:	c0 40       	breq	8000cdcc <_fclose_r+0x94>
8000cdc6:	0c 9c       	mov	r12,r6
8000cdc8:	fe b0 f9 54 	rcall	8000c070 <_free_r>
8000cdcc:	30 08       	mov	r8,0
8000cdce:	8f d8       	st.w	r7[0x34],r8
8000cdd0:	6f 2b       	ld.w	r11,r7[0x48]
8000cdd2:	58 0b       	cp.w	r11,0
8000cdd4:	c0 70       	breq	8000cde2 <_fclose_r+0xaa>
8000cdd6:	0c 9c       	mov	r12,r6
8000cdd8:	fe b0 f9 4c 	rcall	8000c070 <_free_r>
8000cddc:	30 08       	mov	r8,0
8000cdde:	ef 48 00 48 	st.w	r7[72],r8
8000cde2:	30 08       	mov	r8,0
8000cde4:	ae 68       	st.h	r7[0xc],r8
8000cde6:	fe b0 f8 5a 	rcall	8000be9a <__sfp_lock_release>
8000cdea:	0a 9c       	mov	r12,r5
8000cdec:	d8 22       	popm	r4-r7,pc
8000cdee:	d7 03       	nop

8000cdf0 <fclose>:
8000cdf0:	d4 01       	pushm	lr
8000cdf2:	e0 68 0a 54 	mov	r8,2644
8000cdf6:	18 9b       	mov	r11,r12
8000cdf8:	70 0c       	ld.w	r12,r8[0x0]
8000cdfa:	c9 ff       	rcall	8000cd38 <_fclose_r>
8000cdfc:	d8 02       	popm	pc
8000cdfe:	d7 03       	nop

8000ce00 <_fstat_r>:
8000ce00:	d4 21       	pushm	r4-r7,lr
8000ce02:	16 98       	mov	r8,r11
8000ce04:	18 97       	mov	r7,r12
8000ce06:	10 9c       	mov	r12,r8
8000ce08:	30 08       	mov	r8,0
8000ce0a:	e0 66 bd 4c 	mov	r6,48460
8000ce0e:	14 9b       	mov	r11,r10
8000ce10:	8d 08       	st.w	r6[0x0],r8
8000ce12:	fe b0 df 67 	rcall	80008ce0 <_fstat>
8000ce16:	5b fc       	cp.w	r12,-1
8000ce18:	c0 51       	brne	8000ce22 <_fstat_r+0x22>
8000ce1a:	6c 08       	ld.w	r8,r6[0x0]
8000ce1c:	58 08       	cp.w	r8,0
8000ce1e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce22:	d8 22       	popm	r4-r7,pc

8000ce24 <_lseek_r>:
8000ce24:	d4 21       	pushm	r4-r7,lr
8000ce26:	16 98       	mov	r8,r11
8000ce28:	18 97       	mov	r7,r12
8000ce2a:	10 9c       	mov	r12,r8
8000ce2c:	30 08       	mov	r8,0
8000ce2e:	14 9b       	mov	r11,r10
8000ce30:	e0 66 bd 4c 	mov	r6,48460
8000ce34:	12 9a       	mov	r10,r9
8000ce36:	8d 08       	st.w	r6[0x0],r8
8000ce38:	fe b0 df 36 	rcall	80008ca4 <_lseek>
8000ce3c:	5b fc       	cp.w	r12,-1
8000ce3e:	c0 51       	brne	8000ce48 <_lseek_r+0x24>
8000ce40:	6c 08       	ld.w	r8,r6[0x0]
8000ce42:	58 08       	cp.w	r8,0
8000ce44:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce48:	d8 22       	popm	r4-r7,pc
8000ce4a:	d7 03       	nop

8000ce4c <_read_r>:
8000ce4c:	d4 21       	pushm	r4-r7,lr
8000ce4e:	16 98       	mov	r8,r11
8000ce50:	18 97       	mov	r7,r12
8000ce52:	10 9c       	mov	r12,r8
8000ce54:	30 08       	mov	r8,0
8000ce56:	14 9b       	mov	r11,r10
8000ce58:	e0 66 bd 4c 	mov	r6,48460
8000ce5c:	12 9a       	mov	r10,r9
8000ce5e:	8d 08       	st.w	r6[0x0],r8
8000ce60:	fe b0 d0 62 	rcall	80006f24 <_read>
8000ce64:	5b fc       	cp.w	r12,-1
8000ce66:	c0 51       	brne	8000ce70 <_read_r+0x24>
8000ce68:	6c 08       	ld.w	r8,r6[0x0]
8000ce6a:	58 08       	cp.w	r8,0
8000ce6c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ce70:	d8 22       	popm	r4-r7,pc
8000ce72:	d7 03       	nop

8000ce74 <__avr32_f64_mul>:
8000ce74:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ce78:	e0 80 00 dc 	breq	8000d030 <__avr32_f64_mul_op1_zero>
8000ce7c:	d4 21       	pushm	r4-r7,lr
8000ce7e:	f7 e9 20 0e 	eor	lr,r11,r9
8000ce82:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ce86:	30 15       	mov	r5,1
8000ce88:	c4 30       	breq	8000cf0e <__avr32_f64_mul_op1_subnormal>
8000ce8a:	ab 6b       	lsl	r11,0xa
8000ce8c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ce90:	ab 6a       	lsl	r10,0xa
8000ce92:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ce96:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ce9a:	c5 c0       	breq	8000cf52 <__avr32_f64_mul_op2_subnormal>
8000ce9c:	a1 78       	lsl	r8,0x1
8000ce9e:	5c f9       	rol	r9
8000cea0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000cea4:	e0 47 07 ff 	cp.w	r7,2047
8000cea8:	c7 70       	breq	8000cf96 <__avr32_f64_mul_op_nan_or_inf>
8000ceaa:	e0 46 07 ff 	cp.w	r6,2047
8000ceae:	c7 40       	breq	8000cf96 <__avr32_f64_mul_op_nan_or_inf>
8000ceb0:	ee 06 00 0c 	add	r12,r7,r6
8000ceb4:	e0 2c 03 fe 	sub	r12,1022
8000ceb8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000cebc:	f4 09 07 44 	macu.d	r4,r10,r9
8000cec0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000cec4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000cec8:	08 07       	add	r7,r4
8000ceca:	f4 05 00 4a 	adc	r10,r10,r5
8000cece:	5c 0b       	acr	r11
8000ced0:	ed bb 00 14 	bld	r11,0x14
8000ced4:	c0 50       	breq	8000cede <__avr32_f64_mul+0x6a>
8000ced6:	a1 77       	lsl	r7,0x1
8000ced8:	5c fa       	rol	r10
8000ceda:	5c fb       	rol	r11
8000cedc:	20 1c       	sub	r12,1
8000cede:	58 0c       	cp.w	r12,0
8000cee0:	e0 8a 00 6f 	brle	8000cfbe <__avr32_f64_mul_res_subnormal>
8000cee4:	e0 4c 07 ff 	cp.w	r12,2047
8000cee8:	e0 84 00 9c 	brge	8000d020 <__avr32_f64_mul_res_inf>
8000ceec:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000cef0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000cef4:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000cef8:	ee 17 80 00 	eorh	r7,0x8000
8000cefc:	f1 b7 04 20 	satu	r7,0x1
8000cf00:	0e 0a       	add	r10,r7
8000cf02:	5c 0b       	acr	r11
8000cf04:	ed be 00 1f 	bld	lr,0x1f
8000cf08:	ef bb 00 1f 	bst	r11,0x1f
8000cf0c:	d8 22       	popm	r4-r7,pc

8000cf0e <__avr32_f64_mul_op1_subnormal>:
8000cf0e:	e4 1b 00 0f 	andh	r11,0xf
8000cf12:	f4 0c 12 00 	clz	r12,r10
8000cf16:	f6 06 12 00 	clz	r6,r11
8000cf1a:	f7 bc 03 e1 	sublo	r12,-31
8000cf1e:	f8 06 17 30 	movlo	r6,r12
8000cf22:	f7 b6 02 01 	subhs	r6,1
8000cf26:	e0 46 00 20 	cp.w	r6,32
8000cf2a:	c0 d4       	brge	8000cf44 <__avr32_f64_mul_op1_subnormal+0x36>
8000cf2c:	ec 0c 11 20 	rsub	r12,r6,32
8000cf30:	f6 06 09 4b 	lsl	r11,r11,r6
8000cf34:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000cf38:	18 4b       	or	r11,r12
8000cf3a:	f4 06 09 4a 	lsl	r10,r10,r6
8000cf3e:	20 b6       	sub	r6,11
8000cf40:	0c 17       	sub	r7,r6
8000cf42:	ca ab       	rjmp	8000ce96 <__avr32_f64_mul+0x22>
8000cf44:	f4 06 09 4b 	lsl	r11,r10,r6
8000cf48:	c6 40       	breq	8000d010 <__avr32_f64_mul_res_zero>
8000cf4a:	30 0a       	mov	r10,0
8000cf4c:	20 b6       	sub	r6,11
8000cf4e:	0c 17       	sub	r7,r6
8000cf50:	ca 3b       	rjmp	8000ce96 <__avr32_f64_mul+0x22>

8000cf52 <__avr32_f64_mul_op2_subnormal>:
8000cf52:	e4 19 00 0f 	andh	r9,0xf
8000cf56:	f0 0c 12 00 	clz	r12,r8
8000cf5a:	f2 05 12 00 	clz	r5,r9
8000cf5e:	f7 bc 03 ea 	sublo	r12,-22
8000cf62:	f8 05 17 30 	movlo	r5,r12
8000cf66:	f7 b5 02 0a 	subhs	r5,10
8000cf6a:	e0 45 00 20 	cp.w	r5,32
8000cf6e:	c0 d4       	brge	8000cf88 <__avr32_f64_mul_op2_subnormal+0x36>
8000cf70:	ea 0c 11 20 	rsub	r12,r5,32
8000cf74:	f2 05 09 49 	lsl	r9,r9,r5
8000cf78:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000cf7c:	18 49       	or	r9,r12
8000cf7e:	f0 05 09 48 	lsl	r8,r8,r5
8000cf82:	20 25       	sub	r5,2
8000cf84:	0a 16       	sub	r6,r5
8000cf86:	c8 fb       	rjmp	8000cea4 <__avr32_f64_mul+0x30>
8000cf88:	f0 05 09 49 	lsl	r9,r8,r5
8000cf8c:	c4 20       	breq	8000d010 <__avr32_f64_mul_res_zero>
8000cf8e:	30 08       	mov	r8,0
8000cf90:	20 25       	sub	r5,2
8000cf92:	0a 16       	sub	r6,r5
8000cf94:	c8 8b       	rjmp	8000cea4 <__avr32_f64_mul+0x30>

8000cf96 <__avr32_f64_mul_op_nan_or_inf>:
8000cf96:	e4 19 00 0f 	andh	r9,0xf
8000cf9a:	e4 1b 00 0f 	andh	r11,0xf
8000cf9e:	14 4b       	or	r11,r10
8000cfa0:	10 49       	or	r9,r8
8000cfa2:	e0 47 07 ff 	cp.w	r7,2047
8000cfa6:	c0 91       	brne	8000cfb8 <__avr32_f64_mul_op1_not_naninf>
8000cfa8:	58 0b       	cp.w	r11,0
8000cfaa:	c3 81       	brne	8000d01a <__avr32_f64_mul_res_nan>
8000cfac:	e0 46 07 ff 	cp.w	r6,2047
8000cfb0:	c3 81       	brne	8000d020 <__avr32_f64_mul_res_inf>
8000cfb2:	58 09       	cp.w	r9,0
8000cfb4:	c3 60       	breq	8000d020 <__avr32_f64_mul_res_inf>
8000cfb6:	c3 28       	rjmp	8000d01a <__avr32_f64_mul_res_nan>

8000cfb8 <__avr32_f64_mul_op1_not_naninf>:
8000cfb8:	58 09       	cp.w	r9,0
8000cfba:	c3 30       	breq	8000d020 <__avr32_f64_mul_res_inf>
8000cfbc:	c2 f8       	rjmp	8000d01a <__avr32_f64_mul_res_nan>

8000cfbe <__avr32_f64_mul_res_subnormal>:
8000cfbe:	5c 3c       	neg	r12
8000cfc0:	2f fc       	sub	r12,-1
8000cfc2:	f1 bc 04 c0 	satu	r12,0x6
8000cfc6:	e0 4c 00 20 	cp.w	r12,32
8000cfca:	c1 14       	brge	8000cfec <__avr32_f64_mul_res_subnormal+0x2e>
8000cfcc:	f8 08 11 20 	rsub	r8,r12,32
8000cfd0:	0e 46       	or	r6,r7
8000cfd2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000cfd6:	f4 08 09 49 	lsl	r9,r10,r8
8000cfda:	12 47       	or	r7,r9
8000cfdc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000cfe0:	f6 08 09 49 	lsl	r9,r11,r8
8000cfe4:	12 4a       	or	r10,r9
8000cfe6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000cfea:	c8 3b       	rjmp	8000cef0 <__avr32_f64_mul+0x7c>
8000cfec:	f8 08 11 20 	rsub	r8,r12,32
8000cff0:	f9 b9 00 00 	moveq	r9,0
8000cff4:	c0 30       	breq	8000cffa <__avr32_f64_mul_res_subnormal+0x3c>
8000cff6:	f6 08 09 49 	lsl	r9,r11,r8
8000cffa:	0e 46       	or	r6,r7
8000cffc:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000d000:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000d004:	f3 ea 10 07 	or	r7,r9,r10
8000d008:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000d00c:	30 0b       	mov	r11,0
8000d00e:	c7 1b       	rjmp	8000cef0 <__avr32_f64_mul+0x7c>

8000d010 <__avr32_f64_mul_res_zero>:
8000d010:	1c 9b       	mov	r11,lr
8000d012:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d016:	30 0a       	mov	r10,0
8000d018:	d8 22       	popm	r4-r7,pc

8000d01a <__avr32_f64_mul_res_nan>:
8000d01a:	3f fb       	mov	r11,-1
8000d01c:	3f fa       	mov	r10,-1
8000d01e:	d8 22       	popm	r4-r7,pc

8000d020 <__avr32_f64_mul_res_inf>:
8000d020:	f0 6b 00 00 	mov	r11,-1048576
8000d024:	ed be 00 1f 	bld	lr,0x1f
8000d028:	ef bb 00 1f 	bst	r11,0x1f
8000d02c:	30 0a       	mov	r10,0
8000d02e:	d8 22       	popm	r4-r7,pc

8000d030 <__avr32_f64_mul_op1_zero>:
8000d030:	f7 e9 20 0b 	eor	r11,r11,r9
8000d034:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d038:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000d03c:	e0 4c 07 ff 	cp.w	r12,2047
8000d040:	5e 1c       	retne	r12
8000d042:	3f fa       	mov	r10,-1
8000d044:	3f fb       	mov	r11,-1
8000d046:	5e fc       	retal	r12

8000d048 <__avr32_f64_sub_from_add>:
8000d048:	ee 19 80 00 	eorh	r9,0x8000

8000d04c <__avr32_f64_sub>:
8000d04c:	f7 e9 20 0c 	eor	r12,r11,r9
8000d050:	e0 86 00 ca 	brmi	8000d1e4 <__avr32_f64_add_from_sub>
8000d054:	eb cd 40 e0 	pushm	r5-r7,lr
8000d058:	16 9c       	mov	r12,r11
8000d05a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d05e:	bf db       	cbr	r11,0x1f
8000d060:	bf d9       	cbr	r9,0x1f
8000d062:	10 3a       	cp.w	r10,r8
8000d064:	f2 0b 13 00 	cpc	r11,r9
8000d068:	c0 92       	brcc	8000d07a <__avr32_f64_sub+0x2e>
8000d06a:	16 97       	mov	r7,r11
8000d06c:	12 9b       	mov	r11,r9
8000d06e:	0e 99       	mov	r9,r7
8000d070:	14 97       	mov	r7,r10
8000d072:	10 9a       	mov	r10,r8
8000d074:	0e 98       	mov	r8,r7
8000d076:	ee 1c 80 00 	eorh	r12,0x8000
8000d07a:	f6 07 16 14 	lsr	r7,r11,0x14
8000d07e:	ab 7b       	lsl	r11,0xb
8000d080:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d084:	ab 7a       	lsl	r10,0xb
8000d086:	bf bb       	sbr	r11,0x1f
8000d088:	f2 06 16 14 	lsr	r6,r9,0x14
8000d08c:	c4 40       	breq	8000d114 <__avr32_f64_sub_opL_subnormal>
8000d08e:	ab 79       	lsl	r9,0xb
8000d090:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d094:	ab 78       	lsl	r8,0xb
8000d096:	bf b9       	sbr	r9,0x1f

8000d098 <__avr32_f64_sub_opL_subnormal_done>:
8000d098:	e0 47 07 ff 	cp.w	r7,2047
8000d09c:	c4 f0       	breq	8000d13a <__avr32_f64_sub_opH_nan_or_inf>
8000d09e:	0e 26       	rsub	r6,r7
8000d0a0:	c1 20       	breq	8000d0c4 <__avr32_f64_sub_shift_done>
8000d0a2:	ec 05 11 20 	rsub	r5,r6,32
8000d0a6:	e0 46 00 20 	cp.w	r6,32
8000d0aa:	c7 c2       	brcc	8000d1a2 <__avr32_f64_sub_longshift>
8000d0ac:	f0 05 09 4e 	lsl	lr,r8,r5
8000d0b0:	f2 05 09 45 	lsl	r5,r9,r5
8000d0b4:	f0 06 0a 48 	lsr	r8,r8,r6
8000d0b8:	f2 06 0a 49 	lsr	r9,r9,r6
8000d0bc:	0a 48       	or	r8,r5
8000d0be:	58 0e       	cp.w	lr,0
8000d0c0:	5f 1e       	srne	lr
8000d0c2:	1c 48       	or	r8,lr

8000d0c4 <__avr32_f64_sub_shift_done>:
8000d0c4:	10 1a       	sub	r10,r8
8000d0c6:	f6 09 01 4b 	sbc	r11,r11,r9
8000d0ca:	f6 06 12 00 	clz	r6,r11
8000d0ce:	c0 e0       	breq	8000d0ea <__avr32_f64_sub_longnormalize_done>
8000d0d0:	c7 83       	brcs	8000d1c0 <__avr32_f64_sub_longnormalize>
8000d0d2:	ec 0e 11 20 	rsub	lr,r6,32
8000d0d6:	f6 06 09 4b 	lsl	r11,r11,r6
8000d0da:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d0de:	1c 4b       	or	r11,lr
8000d0e0:	f4 06 09 4a 	lsl	r10,r10,r6
8000d0e4:	0c 17       	sub	r7,r6
8000d0e6:	e0 8a 00 39 	brle	8000d158 <__avr32_f64_sub_subnormal_result>

8000d0ea <__avr32_f64_sub_longnormalize_done>:
8000d0ea:	f4 09 15 15 	lsl	r9,r10,0x15
8000d0ee:	ab 9a       	lsr	r10,0xb
8000d0f0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d0f4:	ab 9b       	lsr	r11,0xb
8000d0f6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d0fa:	18 4b       	or	r11,r12

8000d0fc <__avr32_f64_sub_round>:
8000d0fc:	fc 17 80 00 	movh	r7,0x8000
8000d100:	ed ba 00 00 	bld	r10,0x0
8000d104:	f7 b7 01 ff 	subne	r7,-1
8000d108:	0e 39       	cp.w	r9,r7
8000d10a:	5f 29       	srhs	r9
8000d10c:	12 0a       	add	r10,r9
8000d10e:	5c 0b       	acr	r11
8000d110:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d114 <__avr32_f64_sub_opL_subnormal>:
8000d114:	ab 79       	lsl	r9,0xb
8000d116:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000d11a:	ab 78       	lsl	r8,0xb
8000d11c:	f3 e8 10 0e 	or	lr,r9,r8
8000d120:	f9 b6 01 01 	movne	r6,1
8000d124:	ee 0e 11 00 	rsub	lr,r7,0
8000d128:	f9 b7 00 01 	moveq	r7,1
8000d12c:	ef bb 00 1f 	bst	r11,0x1f
8000d130:	f7 ea 10 0e 	or	lr,r11,r10
8000d134:	f9 b7 00 00 	moveq	r7,0
8000d138:	cb 0b       	rjmp	8000d098 <__avr32_f64_sub_opL_subnormal_done>

8000d13a <__avr32_f64_sub_opH_nan_or_inf>:
8000d13a:	bf db       	cbr	r11,0x1f
8000d13c:	f7 ea 10 0e 	or	lr,r11,r10
8000d140:	c0 81       	brne	8000d150 <__avr32_f64_sub_return_nan>
8000d142:	e0 46 07 ff 	cp.w	r6,2047
8000d146:	c0 50       	breq	8000d150 <__avr32_f64_sub_return_nan>
8000d148:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000d14c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d150 <__avr32_f64_sub_return_nan>:
8000d150:	3f fa       	mov	r10,-1
8000d152:	3f fb       	mov	r11,-1
8000d154:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d158 <__avr32_f64_sub_subnormal_result>:
8000d158:	5c 37       	neg	r7
8000d15a:	2f f7       	sub	r7,-1
8000d15c:	f1 b7 04 c0 	satu	r7,0x6
8000d160:	e0 47 00 20 	cp.w	r7,32
8000d164:	c1 14       	brge	8000d186 <__avr32_f64_sub_subnormal_result+0x2e>
8000d166:	ee 08 11 20 	rsub	r8,r7,32
8000d16a:	f4 08 09 49 	lsl	r9,r10,r8
8000d16e:	5f 16       	srne	r6
8000d170:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d174:	0c 4a       	or	r10,r6
8000d176:	f6 08 09 49 	lsl	r9,r11,r8
8000d17a:	f5 e9 10 0a 	or	r10,r10,r9
8000d17e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000d182:	30 07       	mov	r7,0
8000d184:	cb 3b       	rjmp	8000d0ea <__avr32_f64_sub_longnormalize_done>
8000d186:	ee 08 11 40 	rsub	r8,r7,64
8000d18a:	f6 08 09 49 	lsl	r9,r11,r8
8000d18e:	14 49       	or	r9,r10
8000d190:	5f 16       	srne	r6
8000d192:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d196:	0c 4a       	or	r10,r6
8000d198:	30 0b       	mov	r11,0
8000d19a:	30 07       	mov	r7,0
8000d19c:	ca 7b       	rjmp	8000d0ea <__avr32_f64_sub_longnormalize_done>
8000d19e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d1a2 <__avr32_f64_sub_longshift>:
8000d1a2:	f1 b6 04 c0 	satu	r6,0x6
8000d1a6:	f0 0e 17 00 	moveq	lr,r8
8000d1aa:	c0 40       	breq	8000d1b2 <__avr32_f64_sub_longshift+0x10>
8000d1ac:	f2 05 09 4e 	lsl	lr,r9,r5
8000d1b0:	10 4e       	or	lr,r8
8000d1b2:	f2 06 0a 48 	lsr	r8,r9,r6
8000d1b6:	30 09       	mov	r9,0
8000d1b8:	58 0e       	cp.w	lr,0
8000d1ba:	5f 1e       	srne	lr
8000d1bc:	1c 48       	or	r8,lr
8000d1be:	c8 3b       	rjmp	8000d0c4 <__avr32_f64_sub_shift_done>

8000d1c0 <__avr32_f64_sub_longnormalize>:
8000d1c0:	f4 06 12 00 	clz	r6,r10
8000d1c4:	f9 b7 03 00 	movlo	r7,0
8000d1c8:	f9 b6 03 00 	movlo	r6,0
8000d1cc:	f9 bc 03 00 	movlo	r12,0
8000d1d0:	f7 b6 02 e0 	subhs	r6,-32
8000d1d4:	f4 06 09 4b 	lsl	r11,r10,r6
8000d1d8:	30 0a       	mov	r10,0
8000d1da:	0c 17       	sub	r7,r6
8000d1dc:	fe 9a ff be 	brle	8000d158 <__avr32_f64_sub_subnormal_result>
8000d1e0:	c8 5b       	rjmp	8000d0ea <__avr32_f64_sub_longnormalize_done>
8000d1e2:	d7 03       	nop

8000d1e4 <__avr32_f64_add_from_sub>:
8000d1e4:	ee 19 80 00 	eorh	r9,0x8000

8000d1e8 <__avr32_f64_add>:
8000d1e8:	f7 e9 20 0c 	eor	r12,r11,r9
8000d1ec:	fe 96 ff 2e 	brmi	8000d048 <__avr32_f64_sub_from_add>
8000d1f0:	eb cd 40 e0 	pushm	r5-r7,lr
8000d1f4:	16 9c       	mov	r12,r11
8000d1f6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d1fa:	bf db       	cbr	r11,0x1f
8000d1fc:	bf d9       	cbr	r9,0x1f
8000d1fe:	12 3b       	cp.w	r11,r9
8000d200:	c0 72       	brcc	8000d20e <__avr32_f64_add+0x26>
8000d202:	16 97       	mov	r7,r11
8000d204:	12 9b       	mov	r11,r9
8000d206:	0e 99       	mov	r9,r7
8000d208:	14 97       	mov	r7,r10
8000d20a:	10 9a       	mov	r10,r8
8000d20c:	0e 98       	mov	r8,r7
8000d20e:	30 0e       	mov	lr,0
8000d210:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000d214:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000d218:	b5 ab       	sbr	r11,0x14
8000d21a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000d21e:	c6 20       	breq	8000d2e2 <__avr32_f64_add_op2_subnormal>
8000d220:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000d224:	b5 a9       	sbr	r9,0x14
8000d226:	e0 47 07 ff 	cp.w	r7,2047
8000d22a:	c2 80       	breq	8000d27a <__avr32_f64_add_opH_nan_or_inf>
8000d22c:	0e 26       	rsub	r6,r7
8000d22e:	c1 20       	breq	8000d252 <__avr32_f64_add_shift_done>
8000d230:	e0 46 00 36 	cp.w	r6,54
8000d234:	c1 52       	brcc	8000d25e <__avr32_f64_add_res_of_done>
8000d236:	ec 05 11 20 	rsub	r5,r6,32
8000d23a:	e0 46 00 20 	cp.w	r6,32
8000d23e:	c3 52       	brcc	8000d2a8 <__avr32_f64_add_longshift>
8000d240:	f0 05 09 4e 	lsl	lr,r8,r5
8000d244:	f2 05 09 45 	lsl	r5,r9,r5
8000d248:	f0 06 0a 48 	lsr	r8,r8,r6
8000d24c:	f2 06 0a 49 	lsr	r9,r9,r6
8000d250:	0a 48       	or	r8,r5

8000d252 <__avr32_f64_add_shift_done>:
8000d252:	10 0a       	add	r10,r8
8000d254:	f6 09 00 4b 	adc	r11,r11,r9
8000d258:	ed bb 00 15 	bld	r11,0x15
8000d25c:	c3 40       	breq	8000d2c4 <__avr32_f64_add_res_of>

8000d25e <__avr32_f64_add_res_of_done>:
8000d25e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d262:	18 4b       	or	r11,r12

8000d264 <__avr32_f64_add_round>:
8000d264:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000d268:	18 4e       	or	lr,r12
8000d26a:	ee 1e 80 00 	eorh	lr,0x8000
8000d26e:	f1 be 04 20 	satu	lr,0x1
8000d272:	1c 0a       	add	r10,lr
8000d274:	5c 0b       	acr	r11
8000d276:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d27a <__avr32_f64_add_opH_nan_or_inf>:
8000d27a:	b5 cb       	cbr	r11,0x14
8000d27c:	f7 ea 10 0e 	or	lr,r11,r10
8000d280:	c1 01       	brne	8000d2a0 <__avr32_f64_add_return_nan>
8000d282:	e0 46 07 ff 	cp.w	r6,2047
8000d286:	c0 30       	breq	8000d28c <__avr32_f64_add_opL_nan_or_inf>
8000d288:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d28c <__avr32_f64_add_opL_nan_or_inf>:
8000d28c:	b5 c9       	cbr	r9,0x14
8000d28e:	f3 e8 10 0e 	or	lr,r9,r8
8000d292:	c0 71       	brne	8000d2a0 <__avr32_f64_add_return_nan>
8000d294:	30 0a       	mov	r10,0
8000d296:	fc 1b 7f f0 	movh	r11,0x7ff0
8000d29a:	18 4b       	or	r11,r12
8000d29c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2a0 <__avr32_f64_add_return_nan>:
8000d2a0:	3f fa       	mov	r10,-1
8000d2a2:	3f fb       	mov	r11,-1
8000d2a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d2a8 <__avr32_f64_add_longshift>:
8000d2a8:	f1 b6 04 c0 	satu	r6,0x6
8000d2ac:	f0 0e 17 00 	moveq	lr,r8
8000d2b0:	c0 60       	breq	8000d2bc <__avr32_f64_add_longshift+0x14>
8000d2b2:	f2 05 09 4e 	lsl	lr,r9,r5
8000d2b6:	58 08       	cp.w	r8,0
8000d2b8:	5f 18       	srne	r8
8000d2ba:	10 4e       	or	lr,r8
8000d2bc:	f2 06 0a 48 	lsr	r8,r9,r6
8000d2c0:	30 09       	mov	r9,0
8000d2c2:	cc 8b       	rjmp	8000d252 <__avr32_f64_add_shift_done>

8000d2c4 <__avr32_f64_add_res_of>:
8000d2c4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000d2c8:	a1 9b       	lsr	r11,0x1
8000d2ca:	5d 0a       	ror	r10
8000d2cc:	5d 0e       	ror	lr
8000d2ce:	2f f7       	sub	r7,-1
8000d2d0:	e0 47 07 ff 	cp.w	r7,2047
8000d2d4:	f9 ba 00 00 	moveq	r10,0
8000d2d8:	f9 bb 00 00 	moveq	r11,0
8000d2dc:	f9 be 00 00 	moveq	lr,0
8000d2e0:	cb fb       	rjmp	8000d25e <__avr32_f64_add_res_of_done>

8000d2e2 <__avr32_f64_add_op2_subnormal>:
8000d2e2:	30 16       	mov	r6,1
8000d2e4:	58 07       	cp.w	r7,0
8000d2e6:	ca 01       	brne	8000d226 <__avr32_f64_add+0x3e>
8000d2e8:	b5 cb       	cbr	r11,0x14
8000d2ea:	10 0a       	add	r10,r8
8000d2ec:	f6 09 00 4b 	adc	r11,r11,r9
8000d2f0:	18 4b       	or	r11,r12
8000d2f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000d2f6:	d7 03       	nop

8000d2f8 <__avr32_f64_to_u32>:
8000d2f8:	58 0b       	cp.w	r11,0
8000d2fa:	5e 6d       	retmi	0

8000d2fc <__avr32_f64_to_s32>:
8000d2fc:	f6 0c 15 01 	lsl	r12,r11,0x1
8000d300:	b5 9c       	lsr	r12,0x15
8000d302:	e0 2c 03 ff 	sub	r12,1023
8000d306:	5e 3d       	retlo	0
8000d308:	f8 0c 11 1f 	rsub	r12,r12,31
8000d30c:	16 99       	mov	r9,r11
8000d30e:	ab 7b       	lsl	r11,0xb
8000d310:	bf bb       	sbr	r11,0x1f
8000d312:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d316:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000d31a:	a1 79       	lsl	r9,0x1
8000d31c:	5e 2b       	reths	r11
8000d31e:	5c 3b       	neg	r11
8000d320:	5e fb       	retal	r11

8000d322 <__avr32_u32_to_f64>:
8000d322:	f8 cb 00 00 	sub	r11,r12,0
8000d326:	30 0c       	mov	r12,0
8000d328:	c0 38       	rjmp	8000d32e <__avr32_s32_to_f64+0x4>

8000d32a <__avr32_s32_to_f64>:
8000d32a:	18 9b       	mov	r11,r12
8000d32c:	5c 4b       	abs	r11
8000d32e:	30 0a       	mov	r10,0
8000d330:	5e 0b       	reteq	r11
8000d332:	d4 01       	pushm	lr
8000d334:	e0 69 04 1e 	mov	r9,1054
8000d338:	f6 08 12 00 	clz	r8,r11
8000d33c:	c1 70       	breq	8000d36a <__avr32_s32_to_f64+0x40>
8000d33e:	c0 c3       	brcs	8000d356 <__avr32_s32_to_f64+0x2c>
8000d340:	f0 0e 11 20 	rsub	lr,r8,32
8000d344:	f6 08 09 4b 	lsl	r11,r11,r8
8000d348:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d34c:	1c 4b       	or	r11,lr
8000d34e:	f4 08 09 4a 	lsl	r10,r10,r8
8000d352:	10 19       	sub	r9,r8
8000d354:	c0 b8       	rjmp	8000d36a <__avr32_s32_to_f64+0x40>
8000d356:	f4 08 12 00 	clz	r8,r10
8000d35a:	f9 b8 03 00 	movlo	r8,0
8000d35e:	f7 b8 02 e0 	subhs	r8,-32
8000d362:	f4 08 09 4b 	lsl	r11,r10,r8
8000d366:	30 0a       	mov	r10,0
8000d368:	10 19       	sub	r9,r8
8000d36a:	58 09       	cp.w	r9,0
8000d36c:	e0 89 00 30 	brgt	8000d3cc <__avr32_s32_to_f64+0xa2>
8000d370:	5c 39       	neg	r9
8000d372:	2f f9       	sub	r9,-1
8000d374:	e0 49 00 36 	cp.w	r9,54
8000d378:	c0 43       	brcs	8000d380 <__avr32_s32_to_f64+0x56>
8000d37a:	30 0b       	mov	r11,0
8000d37c:	30 0a       	mov	r10,0
8000d37e:	c2 68       	rjmp	8000d3ca <__avr32_s32_to_f64+0xa0>
8000d380:	2f 69       	sub	r9,-10
8000d382:	f2 08 11 20 	rsub	r8,r9,32
8000d386:	e0 49 00 20 	cp.w	r9,32
8000d38a:	c0 b2       	brcc	8000d3a0 <__avr32_s32_to_f64+0x76>
8000d38c:	f4 08 09 4e 	lsl	lr,r10,r8
8000d390:	f6 08 09 48 	lsl	r8,r11,r8
8000d394:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d398:	f6 09 0a 4b 	lsr	r11,r11,r9
8000d39c:	10 4b       	or	r11,r8
8000d39e:	c0 88       	rjmp	8000d3ae <__avr32_s32_to_f64+0x84>
8000d3a0:	f6 08 09 4e 	lsl	lr,r11,r8
8000d3a4:	14 4e       	or	lr,r10
8000d3a6:	16 9a       	mov	r10,r11
8000d3a8:	30 0b       	mov	r11,0
8000d3aa:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d3ae:	ed ba 00 00 	bld	r10,0x0
8000d3b2:	c0 92       	brcc	8000d3c4 <__avr32_s32_to_f64+0x9a>
8000d3b4:	1c 7e       	tst	lr,lr
8000d3b6:	c0 41       	brne	8000d3be <__avr32_s32_to_f64+0x94>
8000d3b8:	ed ba 00 01 	bld	r10,0x1
8000d3bc:	c0 42       	brcc	8000d3c4 <__avr32_s32_to_f64+0x9a>
8000d3be:	2f fa       	sub	r10,-1
8000d3c0:	f7 bb 02 ff 	subhs	r11,-1
8000d3c4:	5c fc       	rol	r12
8000d3c6:	5d 0b       	ror	r11
8000d3c8:	5d 0a       	ror	r10
8000d3ca:	d8 02       	popm	pc
8000d3cc:	e0 68 03 ff 	mov	r8,1023
8000d3d0:	ed ba 00 0b 	bld	r10,0xb
8000d3d4:	f7 b8 00 ff 	subeq	r8,-1
8000d3d8:	10 0a       	add	r10,r8
8000d3da:	5c 0b       	acr	r11
8000d3dc:	f7 b9 03 fe 	sublo	r9,-2
8000d3e0:	e0 49 07 ff 	cp.w	r9,2047
8000d3e4:	c0 55       	brlt	8000d3ee <__avr32_s32_to_f64+0xc4>
8000d3e6:	30 0a       	mov	r10,0
8000d3e8:	fc 1b ff e0 	movh	r11,0xffe0
8000d3ec:	c0 c8       	rjmp	8000d404 <__floatsidf_return_op1>
8000d3ee:	ed bb 00 1f 	bld	r11,0x1f
8000d3f2:	f7 b9 01 01 	subne	r9,1
8000d3f6:	ab 9a       	lsr	r10,0xb
8000d3f8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d3fc:	a1 7b       	lsl	r11,0x1
8000d3fe:	ab 9b       	lsr	r11,0xb
8000d400:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000d404 <__floatsidf_return_op1>:
8000d404:	a1 7c       	lsl	r12,0x1
8000d406:	5d 0b       	ror	r11
8000d408:	d8 02       	popm	pc

8000d40a <__avr32_f64_cmp_eq>:
8000d40a:	10 3a       	cp.w	r10,r8
8000d40c:	f2 0b 13 00 	cpc	r11,r9
8000d410:	c0 80       	breq	8000d420 <__avr32_f64_cmp_eq+0x16>
8000d412:	a1 7b       	lsl	r11,0x1
8000d414:	a1 79       	lsl	r9,0x1
8000d416:	14 4b       	or	r11,r10
8000d418:	12 4b       	or	r11,r9
8000d41a:	10 4b       	or	r11,r8
8000d41c:	5e 0f       	reteq	1
8000d41e:	5e fd       	retal	0
8000d420:	a1 7b       	lsl	r11,0x1
8000d422:	fc 1c ff e0 	movh	r12,0xffe0
8000d426:	58 0a       	cp.w	r10,0
8000d428:	f8 0b 13 00 	cpc	r11,r12
8000d42c:	5e 8f       	retls	1
8000d42e:	5e fd       	retal	0

8000d430 <__avr32_f64_cmp_ge>:
8000d430:	1a de       	st.w	--sp,lr
8000d432:	1a d7       	st.w	--sp,r7
8000d434:	a1 7b       	lsl	r11,0x1
8000d436:	5f 3c       	srlo	r12
8000d438:	a1 79       	lsl	r9,0x1
8000d43a:	5f 37       	srlo	r7
8000d43c:	5c fc       	rol	r12
8000d43e:	fc 1e ff e0 	movh	lr,0xffe0
8000d442:	58 0a       	cp.w	r10,0
8000d444:	fc 0b 13 00 	cpc	r11,lr
8000d448:	e0 8b 00 1d 	brhi	8000d482 <__avr32_f64_cmp_ge+0x52>
8000d44c:	58 08       	cp.w	r8,0
8000d44e:	fc 09 13 00 	cpc	r9,lr
8000d452:	e0 8b 00 18 	brhi	8000d482 <__avr32_f64_cmp_ge+0x52>
8000d456:	58 0b       	cp.w	r11,0
8000d458:	f5 ba 00 00 	subfeq	r10,0
8000d45c:	c1 50       	breq	8000d486 <__avr32_f64_cmp_ge+0x56>
8000d45e:	1b 07       	ld.w	r7,sp++
8000d460:	1b 0e       	ld.w	lr,sp++
8000d462:	58 3c       	cp.w	r12,3
8000d464:	c0 a0       	breq	8000d478 <__avr32_f64_cmp_ge+0x48>
8000d466:	58 1c       	cp.w	r12,1
8000d468:	c0 33       	brcs	8000d46e <__avr32_f64_cmp_ge+0x3e>
8000d46a:	5e 0f       	reteq	1
8000d46c:	5e 1d       	retne	0
8000d46e:	10 3a       	cp.w	r10,r8
8000d470:	f2 0b 13 00 	cpc	r11,r9
8000d474:	5e 2f       	reths	1
8000d476:	5e 3d       	retlo	0
8000d478:	14 38       	cp.w	r8,r10
8000d47a:	f6 09 13 00 	cpc	r9,r11
8000d47e:	5e 2f       	reths	1
8000d480:	5e 3d       	retlo	0
8000d482:	1b 07       	ld.w	r7,sp++
8000d484:	d8 0a       	popm	pc,r12=0
8000d486:	58 17       	cp.w	r7,1
8000d488:	5f 0c       	sreq	r12
8000d48a:	58 09       	cp.w	r9,0
8000d48c:	f5 b8 00 00 	subfeq	r8,0
8000d490:	1b 07       	ld.w	r7,sp++
8000d492:	1b 0e       	ld.w	lr,sp++
8000d494:	5e 0f       	reteq	1
8000d496:	5e fc       	retal	r12

8000d498 <__avr32_f64_cmp_lt>:
8000d498:	1a de       	st.w	--sp,lr
8000d49a:	1a d7       	st.w	--sp,r7
8000d49c:	a1 7b       	lsl	r11,0x1
8000d49e:	5f 3c       	srlo	r12
8000d4a0:	a1 79       	lsl	r9,0x1
8000d4a2:	5f 37       	srlo	r7
8000d4a4:	5c fc       	rol	r12
8000d4a6:	fc 1e ff e0 	movh	lr,0xffe0
8000d4aa:	58 0a       	cp.w	r10,0
8000d4ac:	fc 0b 13 00 	cpc	r11,lr
8000d4b0:	e0 8b 00 1d 	brhi	8000d4ea <__avr32_f64_cmp_lt+0x52>
8000d4b4:	58 08       	cp.w	r8,0
8000d4b6:	fc 09 13 00 	cpc	r9,lr
8000d4ba:	e0 8b 00 18 	brhi	8000d4ea <__avr32_f64_cmp_lt+0x52>
8000d4be:	58 0b       	cp.w	r11,0
8000d4c0:	f5 ba 00 00 	subfeq	r10,0
8000d4c4:	c1 50       	breq	8000d4ee <__avr32_f64_cmp_lt+0x56>
8000d4c6:	1b 07       	ld.w	r7,sp++
8000d4c8:	1b 0e       	ld.w	lr,sp++
8000d4ca:	58 3c       	cp.w	r12,3
8000d4cc:	c0 a0       	breq	8000d4e0 <__avr32_f64_cmp_lt+0x48>
8000d4ce:	58 1c       	cp.w	r12,1
8000d4d0:	c0 33       	brcs	8000d4d6 <__avr32_f64_cmp_lt+0x3e>
8000d4d2:	5e 0d       	reteq	0
8000d4d4:	5e 1f       	retne	1
8000d4d6:	10 3a       	cp.w	r10,r8
8000d4d8:	f2 0b 13 00 	cpc	r11,r9
8000d4dc:	5e 2d       	reths	0
8000d4de:	5e 3f       	retlo	1
8000d4e0:	14 38       	cp.w	r8,r10
8000d4e2:	f6 09 13 00 	cpc	r9,r11
8000d4e6:	5e 2d       	reths	0
8000d4e8:	5e 3f       	retlo	1
8000d4ea:	1b 07       	ld.w	r7,sp++
8000d4ec:	d8 0a       	popm	pc,r12=0
8000d4ee:	58 17       	cp.w	r7,1
8000d4f0:	5f 1c       	srne	r12
8000d4f2:	58 09       	cp.w	r9,0
8000d4f4:	f5 b8 00 00 	subfeq	r8,0
8000d4f8:	1b 07       	ld.w	r7,sp++
8000d4fa:	1b 0e       	ld.w	lr,sp++
8000d4fc:	5e 0d       	reteq	0
8000d4fe:	5e fc       	retal	r12

8000d500 <__avr32_f64_div>:
8000d500:	eb cd 40 ff 	pushm	r0-r7,lr
8000d504:	f7 e9 20 0e 	eor	lr,r11,r9
8000d508:	f6 07 16 14 	lsr	r7,r11,0x14
8000d50c:	a9 7b       	lsl	r11,0x9
8000d50e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000d512:	a9 7a       	lsl	r10,0x9
8000d514:	bd bb       	sbr	r11,0x1d
8000d516:	e4 1b 3f ff 	andh	r11,0x3fff
8000d51a:	ab d7       	cbr	r7,0xb
8000d51c:	e0 80 00 cc 	breq	8000d6b4 <__avr32_f64_div_round_subnormal+0x54>
8000d520:	e0 47 07 ff 	cp.w	r7,2047
8000d524:	e0 84 00 b5 	brge	8000d68e <__avr32_f64_div_round_subnormal+0x2e>
8000d528:	f2 06 16 14 	lsr	r6,r9,0x14
8000d52c:	a9 79       	lsl	r9,0x9
8000d52e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000d532:	a9 78       	lsl	r8,0x9
8000d534:	bd b9       	sbr	r9,0x1d
8000d536:	e4 19 3f ff 	andh	r9,0x3fff
8000d53a:	ab d6       	cbr	r6,0xb
8000d53c:	e0 80 00 e2 	breq	8000d700 <__avr32_f64_div_round_subnormal+0xa0>
8000d540:	e0 46 07 ff 	cp.w	r6,2047
8000d544:	e0 84 00 b2 	brge	8000d6a8 <__avr32_f64_div_round_subnormal+0x48>
8000d548:	0c 17       	sub	r7,r6
8000d54a:	fe 37 fc 01 	sub	r7,-1023
8000d54e:	fc 1c 80 00 	movh	r12,0x8000
8000d552:	f8 03 16 01 	lsr	r3,r12,0x1
8000d556:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000d55a:	5c d4       	com	r4
8000d55c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000d560:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d564:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d568:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d56c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d570:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d574:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d578:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d57c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d580:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d584:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d588:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d58c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d590:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d594:	e4 09 07 40 	macu.d	r0,r2,r9
8000d598:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d59c:	02 04       	add	r4,r1
8000d59e:	5c 05       	acr	r5
8000d5a0:	a3 65       	lsl	r5,0x2
8000d5a2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d5a6:	a3 64       	lsl	r4,0x2
8000d5a8:	5c 34       	neg	r4
8000d5aa:	f8 05 01 45 	sbc	r5,r12,r5
8000d5ae:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d5b2:	e4 05 07 40 	macu.d	r0,r2,r5
8000d5b6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d5ba:	02 04       	add	r4,r1
8000d5bc:	5c 05       	acr	r5
8000d5be:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5c2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d5c6:	e8 02 15 02 	lsl	r2,r4,0x2
8000d5ca:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d5ce:	e4 09 07 40 	macu.d	r0,r2,r9
8000d5d2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d5d6:	02 04       	add	r4,r1
8000d5d8:	5c 05       	acr	r5
8000d5da:	a3 65       	lsl	r5,0x2
8000d5dc:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d5e0:	a3 64       	lsl	r4,0x2
8000d5e2:	5c 34       	neg	r4
8000d5e4:	f8 05 01 45 	sbc	r5,r12,r5
8000d5e8:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d5ec:	e4 05 07 40 	macu.d	r0,r2,r5
8000d5f0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d5f4:	02 04       	add	r4,r1
8000d5f6:	5c 05       	acr	r5
8000d5f8:	ea 03 15 02 	lsl	r3,r5,0x2
8000d5fc:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d600:	e8 02 15 02 	lsl	r2,r4,0x2
8000d604:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000d608:	e4 0b 07 40 	macu.d	r0,r2,r11
8000d60c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000d610:	02 02       	add	r2,r1
8000d612:	5c 03       	acr	r3
8000d614:	ed b3 00 1c 	bld	r3,0x1c
8000d618:	c0 90       	breq	8000d62a <__avr32_f64_div+0x12a>
8000d61a:	a1 72       	lsl	r2,0x1
8000d61c:	5c f3       	rol	r3
8000d61e:	20 17       	sub	r7,1
8000d620:	a3 9a       	lsr	r10,0x3
8000d622:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000d626:	a3 9b       	lsr	r11,0x3
8000d628:	c0 58       	rjmp	8000d632 <__avr32_f64_div+0x132>
8000d62a:	a5 8a       	lsr	r10,0x4
8000d62c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000d630:	a5 8b       	lsr	r11,0x4
8000d632:	58 07       	cp.w	r7,0
8000d634:	e0 8a 00 8b 	brle	8000d74a <__avr32_f64_div_res_subnormal>
8000d638:	e0 12 ff 00 	andl	r2,0xff00
8000d63c:	e8 12 00 80 	orl	r2,0x80
8000d640:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d644:	e4 09 07 40 	macu.d	r0,r2,r9
8000d648:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d64c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d650:	00 05       	add	r5,r0
8000d652:	f0 01 00 48 	adc	r8,r8,r1
8000d656:	5c 09       	acr	r9
8000d658:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d65c:	58 04       	cp.w	r4,0
8000d65e:	5c 25       	cpc	r5

8000d660 <__avr32_f64_div_round_subnormal>:
8000d660:	f4 08 13 00 	cpc	r8,r10
8000d664:	f6 09 13 00 	cpc	r9,r11
8000d668:	5f 36       	srlo	r6
8000d66a:	f8 06 17 00 	moveq	r6,r12
8000d66e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000d672:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000d676:	e6 0b 16 08 	lsr	r11,r3,0x8
8000d67a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d67e:	ed be 00 1f 	bld	lr,0x1f
8000d682:	ef bb 00 1f 	bst	r11,0x1f
8000d686:	0c 0a       	add	r10,r6
8000d688:	5c 0b       	acr	r11
8000d68a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d68e:	e4 1b 00 0f 	andh	r11,0xf
8000d692:	14 4b       	or	r11,r10
8000d694:	e0 81 00 a7 	brne	8000d7e2 <__avr32_f64_div_res_subnormal+0x98>
8000d698:	f2 06 16 14 	lsr	r6,r9,0x14
8000d69c:	ab d6       	cbr	r6,0xb
8000d69e:	e0 46 07 ff 	cp.w	r6,2047
8000d6a2:	e0 81 00 a4 	brne	8000d7ea <__avr32_f64_div_res_subnormal+0xa0>
8000d6a6:	c9 e8       	rjmp	8000d7e2 <__avr32_f64_div_res_subnormal+0x98>
8000d6a8:	e4 19 00 0f 	andh	r9,0xf
8000d6ac:	10 49       	or	r9,r8
8000d6ae:	e0 81 00 9a 	brne	8000d7e2 <__avr32_f64_div_res_subnormal+0x98>
8000d6b2:	c9 28       	rjmp	8000d7d6 <__avr32_f64_div_res_subnormal+0x8c>
8000d6b4:	a3 7b       	lsl	r11,0x3
8000d6b6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000d6ba:	a3 7a       	lsl	r10,0x3
8000d6bc:	f5 eb 10 04 	or	r4,r10,r11
8000d6c0:	e0 80 00 a0 	breq	8000d800 <__avr32_f64_div_op1_zero>
8000d6c4:	f6 04 12 00 	clz	r4,r11
8000d6c8:	c1 70       	breq	8000d6f6 <__avr32_f64_div_round_subnormal+0x96>
8000d6ca:	c0 c3       	brcs	8000d6e2 <__avr32_f64_div_round_subnormal+0x82>
8000d6cc:	e8 05 11 20 	rsub	r5,r4,32
8000d6d0:	f6 04 09 4b 	lsl	r11,r11,r4
8000d6d4:	f4 05 0a 45 	lsr	r5,r10,r5
8000d6d8:	0a 4b       	or	r11,r5
8000d6da:	f4 04 09 4a 	lsl	r10,r10,r4
8000d6de:	08 17       	sub	r7,r4
8000d6e0:	c0 b8       	rjmp	8000d6f6 <__avr32_f64_div_round_subnormal+0x96>
8000d6e2:	f4 04 12 00 	clz	r4,r10
8000d6e6:	f9 b4 03 00 	movlo	r4,0
8000d6ea:	f7 b4 02 e0 	subhs	r4,-32
8000d6ee:	f4 04 09 4b 	lsl	r11,r10,r4
8000d6f2:	30 0a       	mov	r10,0
8000d6f4:	08 17       	sub	r7,r4
8000d6f6:	a3 8a       	lsr	r10,0x2
8000d6f8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000d6fc:	a3 8b       	lsr	r11,0x2
8000d6fe:	c1 1b       	rjmp	8000d520 <__avr32_f64_div+0x20>
8000d700:	a3 79       	lsl	r9,0x3
8000d702:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000d706:	a3 78       	lsl	r8,0x3
8000d708:	f3 e8 10 04 	or	r4,r9,r8
8000d70c:	c6 f0       	breq	8000d7ea <__avr32_f64_div_res_subnormal+0xa0>
8000d70e:	f2 04 12 00 	clz	r4,r9
8000d712:	c1 70       	breq	8000d740 <__avr32_f64_div_round_subnormal+0xe0>
8000d714:	c0 c3       	brcs	8000d72c <__avr32_f64_div_round_subnormal+0xcc>
8000d716:	e8 05 11 20 	rsub	r5,r4,32
8000d71a:	f2 04 09 49 	lsl	r9,r9,r4
8000d71e:	f0 05 0a 45 	lsr	r5,r8,r5
8000d722:	0a 49       	or	r9,r5
8000d724:	f0 04 09 48 	lsl	r8,r8,r4
8000d728:	08 16       	sub	r6,r4
8000d72a:	c0 b8       	rjmp	8000d740 <__avr32_f64_div_round_subnormal+0xe0>
8000d72c:	f0 04 12 00 	clz	r4,r8
8000d730:	f9 b4 03 00 	movlo	r4,0
8000d734:	f7 b4 02 e0 	subhs	r4,-32
8000d738:	f0 04 09 49 	lsl	r9,r8,r4
8000d73c:	30 08       	mov	r8,0
8000d73e:	08 16       	sub	r6,r4
8000d740:	a3 88       	lsr	r8,0x2
8000d742:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000d746:	a3 89       	lsr	r9,0x2
8000d748:	cf ca       	rjmp	8000d540 <__avr32_f64_div+0x40>

8000d74a <__avr32_f64_div_res_subnormal>:
8000d74a:	5c 37       	neg	r7
8000d74c:	2f f7       	sub	r7,-1
8000d74e:	f1 b7 04 c0 	satu	r7,0x6
8000d752:	e0 47 00 20 	cp.w	r7,32
8000d756:	c1 54       	brge	8000d780 <__avr32_f64_div_res_subnormal+0x36>
8000d758:	ee 06 11 20 	rsub	r6,r7,32
8000d75c:	e4 07 0a 42 	lsr	r2,r2,r7
8000d760:	e6 06 09 4c 	lsl	r12,r3,r6
8000d764:	18 42       	or	r2,r12
8000d766:	e6 07 0a 43 	lsr	r3,r3,r7
8000d76a:	f4 06 09 41 	lsl	r1,r10,r6
8000d76e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d772:	f6 06 09 4c 	lsl	r12,r11,r6
8000d776:	18 4a       	or	r10,r12
8000d778:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d77c:	30 00       	mov	r0,0
8000d77e:	c1 58       	rjmp	8000d7a8 <__avr32_f64_div_res_subnormal+0x5e>
8000d780:	ee 06 11 20 	rsub	r6,r7,32
8000d784:	f9 b0 00 00 	moveq	r0,0
8000d788:	f9 bc 00 00 	moveq	r12,0
8000d78c:	c0 50       	breq	8000d796 <__avr32_f64_div_res_subnormal+0x4c>
8000d78e:	f4 06 09 40 	lsl	r0,r10,r6
8000d792:	f6 06 09 4c 	lsl	r12,r11,r6
8000d796:	e6 07 0a 42 	lsr	r2,r3,r7
8000d79a:	30 03       	mov	r3,0
8000d79c:	f4 07 0a 41 	lsr	r1,r10,r7
8000d7a0:	18 41       	or	r1,r12
8000d7a2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d7a6:	30 0b       	mov	r11,0
8000d7a8:	e0 12 ff 00 	andl	r2,0xff00
8000d7ac:	e8 12 00 80 	orl	r2,0x80
8000d7b0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d7b4:	e4 09 07 46 	macu.d	r6,r2,r9
8000d7b8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d7bc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d7c0:	0c 05       	add	r5,r6
8000d7c2:	f0 07 00 48 	adc	r8,r8,r7
8000d7c6:	5c 09       	acr	r9
8000d7c8:	30 07       	mov	r7,0
8000d7ca:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d7ce:	00 34       	cp.w	r4,r0
8000d7d0:	e2 05 13 00 	cpc	r5,r1
8000d7d4:	c4 6b       	rjmp	8000d660 <__avr32_f64_div_round_subnormal>
8000d7d6:	1c 9b       	mov	r11,lr
8000d7d8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d7dc:	30 0a       	mov	r10,0
8000d7de:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d7e2:	3f fb       	mov	r11,-1
8000d7e4:	30 0a       	mov	r10,0
8000d7e6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d7ea:	f5 eb 10 04 	or	r4,r10,r11
8000d7ee:	c0 90       	breq	8000d800 <__avr32_f64_div_op1_zero>
8000d7f0:	1c 9b       	mov	r11,lr
8000d7f2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d7f6:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d7fa:	30 0a       	mov	r10,0
8000d7fc:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d800 <__avr32_f64_div_op1_zero>:
8000d800:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d804:	ce f0       	breq	8000d7e2 <__avr32_f64_div_res_subnormal+0x98>
8000d806:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d80a:	e0 44 07 ff 	cp.w	r4,2047
8000d80e:	ce 41       	brne	8000d7d6 <__avr32_f64_div_res_subnormal+0x8c>
8000d810:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d814:	ce 10       	breq	8000d7d6 <__avr32_f64_div_res_subnormal+0x8c>
8000d816:	ce 6b       	rjmp	8000d7e2 <__avr32_f64_div_res_subnormal+0x98>

8000d818 <__avr32_udiv64>:
8000d818:	d4 31       	pushm	r0-r7,lr
8000d81a:	1a 97       	mov	r7,sp
8000d81c:	20 3d       	sub	sp,12
8000d81e:	10 9c       	mov	r12,r8
8000d820:	12 9e       	mov	lr,r9
8000d822:	14 93       	mov	r3,r10
8000d824:	58 09       	cp.w	r9,0
8000d826:	e0 81 00 bd 	brne	8000d9a0 <__avr32_udiv64+0x188>
8000d82a:	16 38       	cp.w	r8,r11
8000d82c:	e0 88 00 40 	brls	8000d8ac <__avr32_udiv64+0x94>
8000d830:	f0 08 12 00 	clz	r8,r8
8000d834:	c0 d0       	breq	8000d84e <__avr32_udiv64+0x36>
8000d836:	f6 08 09 4b 	lsl	r11,r11,r8
8000d83a:	f0 09 11 20 	rsub	r9,r8,32
8000d83e:	f8 08 09 4c 	lsl	r12,r12,r8
8000d842:	f4 09 0a 49 	lsr	r9,r10,r9
8000d846:	f4 08 09 43 	lsl	r3,r10,r8
8000d84a:	f3 eb 10 0b 	or	r11,r9,r11
8000d84e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d852:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d856:	f6 0e 0d 00 	divu	r0,r11,lr
8000d85a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d85e:	00 99       	mov	r9,r0
8000d860:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d864:	e0 0a 02 48 	mul	r8,r0,r10
8000d868:	10 3b       	cp.w	r11,r8
8000d86a:	c0 a2       	brcc	8000d87e <__avr32_udiv64+0x66>
8000d86c:	20 19       	sub	r9,1
8000d86e:	18 0b       	add	r11,r12
8000d870:	18 3b       	cp.w	r11,r12
8000d872:	c0 63       	brcs	8000d87e <__avr32_udiv64+0x66>
8000d874:	10 3b       	cp.w	r11,r8
8000d876:	f7 b9 03 01 	sublo	r9,1
8000d87a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d87e:	f6 08 01 01 	sub	r1,r11,r8
8000d882:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d886:	e2 0e 0d 00 	divu	r0,r1,lr
8000d88a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d88e:	00 98       	mov	r8,r0
8000d890:	e0 0a 02 4a 	mul	r10,r0,r10
8000d894:	14 33       	cp.w	r3,r10
8000d896:	c0 82       	brcc	8000d8a6 <__avr32_udiv64+0x8e>
8000d898:	20 18       	sub	r8,1
8000d89a:	18 03       	add	r3,r12
8000d89c:	18 33       	cp.w	r3,r12
8000d89e:	c0 43       	brcs	8000d8a6 <__avr32_udiv64+0x8e>
8000d8a0:	14 33       	cp.w	r3,r10
8000d8a2:	f7 b8 03 01 	sublo	r8,1
8000d8a6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d8aa:	cd f8       	rjmp	8000da68 <__avr32_udiv64+0x250>
8000d8ac:	58 08       	cp.w	r8,0
8000d8ae:	c0 51       	brne	8000d8b8 <__avr32_udiv64+0xa0>
8000d8b0:	30 19       	mov	r9,1
8000d8b2:	f2 08 0d 08 	divu	r8,r9,r8
8000d8b6:	10 9c       	mov	r12,r8
8000d8b8:	f8 06 12 00 	clz	r6,r12
8000d8bc:	c0 41       	brne	8000d8c4 <__avr32_udiv64+0xac>
8000d8be:	18 1b       	sub	r11,r12
8000d8c0:	30 19       	mov	r9,1
8000d8c2:	c4 08       	rjmp	8000d942 <__avr32_udiv64+0x12a>
8000d8c4:	ec 01 11 20 	rsub	r1,r6,32
8000d8c8:	f4 01 0a 49 	lsr	r9,r10,r1
8000d8cc:	f8 06 09 4c 	lsl	r12,r12,r6
8000d8d0:	f6 06 09 48 	lsl	r8,r11,r6
8000d8d4:	f6 01 0a 41 	lsr	r1,r11,r1
8000d8d8:	f3 e8 10 08 	or	r8,r9,r8
8000d8dc:	f8 03 16 10 	lsr	r3,r12,0x10
8000d8e0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d8e4:	e2 03 0d 00 	divu	r0,r1,r3
8000d8e8:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d8ec:	00 9e       	mov	lr,r0
8000d8ee:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d8f2:	e0 05 02 49 	mul	r9,r0,r5
8000d8f6:	12 3b       	cp.w	r11,r9
8000d8f8:	c0 a2       	brcc	8000d90c <__avr32_udiv64+0xf4>
8000d8fa:	20 1e       	sub	lr,1
8000d8fc:	18 0b       	add	r11,r12
8000d8fe:	18 3b       	cp.w	r11,r12
8000d900:	c0 63       	brcs	8000d90c <__avr32_udiv64+0xf4>
8000d902:	12 3b       	cp.w	r11,r9
8000d904:	f7 be 03 01 	sublo	lr,1
8000d908:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d90c:	12 1b       	sub	r11,r9
8000d90e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d912:	f6 03 0d 02 	divu	r2,r11,r3
8000d916:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d91a:	04 99       	mov	r9,r2
8000d91c:	e4 05 02 4b 	mul	r11,r2,r5
8000d920:	16 38       	cp.w	r8,r11
8000d922:	c0 a2       	brcc	8000d936 <__avr32_udiv64+0x11e>
8000d924:	20 19       	sub	r9,1
8000d926:	18 08       	add	r8,r12
8000d928:	18 38       	cp.w	r8,r12
8000d92a:	c0 63       	brcs	8000d936 <__avr32_udiv64+0x11e>
8000d92c:	16 38       	cp.w	r8,r11
8000d92e:	f7 b9 03 01 	sublo	r9,1
8000d932:	f1 dc e3 08 	addcs	r8,r8,r12
8000d936:	f4 06 09 43 	lsl	r3,r10,r6
8000d93a:	f0 0b 01 0b 	sub	r11,r8,r11
8000d93e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d942:	f8 06 16 10 	lsr	r6,r12,0x10
8000d946:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d94a:	f6 06 0d 00 	divu	r0,r11,r6
8000d94e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d952:	00 9a       	mov	r10,r0
8000d954:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d958:	e0 0e 02 48 	mul	r8,r0,lr
8000d95c:	10 3b       	cp.w	r11,r8
8000d95e:	c0 a2       	brcc	8000d972 <__avr32_udiv64+0x15a>
8000d960:	20 1a       	sub	r10,1
8000d962:	18 0b       	add	r11,r12
8000d964:	18 3b       	cp.w	r11,r12
8000d966:	c0 63       	brcs	8000d972 <__avr32_udiv64+0x15a>
8000d968:	10 3b       	cp.w	r11,r8
8000d96a:	f7 ba 03 01 	sublo	r10,1
8000d96e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d972:	f6 08 01 01 	sub	r1,r11,r8
8000d976:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d97a:	e2 06 0d 00 	divu	r0,r1,r6
8000d97e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d982:	00 98       	mov	r8,r0
8000d984:	e0 0e 02 4b 	mul	r11,r0,lr
8000d988:	16 33       	cp.w	r3,r11
8000d98a:	c0 82       	brcc	8000d99a <__avr32_udiv64+0x182>
8000d98c:	20 18       	sub	r8,1
8000d98e:	18 03       	add	r3,r12
8000d990:	18 33       	cp.w	r3,r12
8000d992:	c0 43       	brcs	8000d99a <__avr32_udiv64+0x182>
8000d994:	16 33       	cp.w	r3,r11
8000d996:	f7 b8 03 01 	sublo	r8,1
8000d99a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d99e:	c6 98       	rjmp	8000da70 <__avr32_udiv64+0x258>
8000d9a0:	16 39       	cp.w	r9,r11
8000d9a2:	e0 8b 00 65 	brhi	8000da6c <__avr32_udiv64+0x254>
8000d9a6:	f2 09 12 00 	clz	r9,r9
8000d9aa:	c0 b1       	brne	8000d9c0 <__avr32_udiv64+0x1a8>
8000d9ac:	10 3a       	cp.w	r10,r8
8000d9ae:	5f 2a       	srhs	r10
8000d9b0:	1c 3b       	cp.w	r11,lr
8000d9b2:	5f b8       	srhi	r8
8000d9b4:	10 4a       	or	r10,r8
8000d9b6:	f2 0a 18 00 	cp.b	r10,r9
8000d9ba:	c5 90       	breq	8000da6c <__avr32_udiv64+0x254>
8000d9bc:	30 18       	mov	r8,1
8000d9be:	c5 98       	rjmp	8000da70 <__avr32_udiv64+0x258>
8000d9c0:	f0 09 09 46 	lsl	r6,r8,r9
8000d9c4:	f2 03 11 20 	rsub	r3,r9,32
8000d9c8:	fc 09 09 4e 	lsl	lr,lr,r9
8000d9cc:	f0 03 0a 48 	lsr	r8,r8,r3
8000d9d0:	f6 09 09 4c 	lsl	r12,r11,r9
8000d9d4:	f4 03 0a 42 	lsr	r2,r10,r3
8000d9d8:	ef 46 ff f4 	st.w	r7[-12],r6
8000d9dc:	f6 03 0a 43 	lsr	r3,r11,r3
8000d9e0:	18 42       	or	r2,r12
8000d9e2:	f1 ee 10 0c 	or	r12,r8,lr
8000d9e6:	f8 01 16 10 	lsr	r1,r12,0x10
8000d9ea:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d9ee:	e6 01 0d 04 	divu	r4,r3,r1
8000d9f2:	e4 03 16 10 	lsr	r3,r2,0x10
8000d9f6:	08 9e       	mov	lr,r4
8000d9f8:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000d9fc:	e8 06 02 48 	mul	r8,r4,r6
8000da00:	10 33       	cp.w	r3,r8
8000da02:	c0 a2       	brcc	8000da16 <__avr32_udiv64+0x1fe>
8000da04:	20 1e       	sub	lr,1
8000da06:	18 03       	add	r3,r12
8000da08:	18 33       	cp.w	r3,r12
8000da0a:	c0 63       	brcs	8000da16 <__avr32_udiv64+0x1fe>
8000da0c:	10 33       	cp.w	r3,r8
8000da0e:	f7 be 03 01 	sublo	lr,1
8000da12:	e7 dc e3 03 	addcs	r3,r3,r12
8000da16:	10 13       	sub	r3,r8
8000da18:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000da1c:	e6 01 0d 00 	divu	r0,r3,r1
8000da20:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000da24:	00 98       	mov	r8,r0
8000da26:	e0 06 02 46 	mul	r6,r0,r6
8000da2a:	0c 3b       	cp.w	r11,r6
8000da2c:	c0 a2       	brcc	8000da40 <__avr32_udiv64+0x228>
8000da2e:	20 18       	sub	r8,1
8000da30:	18 0b       	add	r11,r12
8000da32:	18 3b       	cp.w	r11,r12
8000da34:	c0 63       	brcs	8000da40 <__avr32_udiv64+0x228>
8000da36:	0c 3b       	cp.w	r11,r6
8000da38:	f7 dc e3 0b 	addcs	r11,r11,r12
8000da3c:	f7 b8 03 01 	sublo	r8,1
8000da40:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000da44:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000da48:	0c 1b       	sub	r11,r6
8000da4a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000da4e:	06 95       	mov	r5,r3
8000da50:	16 35       	cp.w	r5,r11
8000da52:	e0 8b 00 0a 	brhi	8000da66 <__avr32_udiv64+0x24e>
8000da56:	5f 0b       	sreq	r11
8000da58:	f4 09 09 49 	lsl	r9,r10,r9
8000da5c:	12 32       	cp.w	r2,r9
8000da5e:	5f b9       	srhi	r9
8000da60:	f7 e9 00 09 	and	r9,r11,r9
8000da64:	c0 60       	breq	8000da70 <__avr32_udiv64+0x258>
8000da66:	20 18       	sub	r8,1
8000da68:	30 09       	mov	r9,0
8000da6a:	c0 38       	rjmp	8000da70 <__avr32_udiv64+0x258>
8000da6c:	30 09       	mov	r9,0
8000da6e:	12 98       	mov	r8,r9
8000da70:	10 9a       	mov	r10,r8
8000da72:	12 93       	mov	r3,r9
8000da74:	10 92       	mov	r2,r8
8000da76:	12 9b       	mov	r11,r9
8000da78:	2f dd       	sub	sp,-12
8000da7a:	d8 32       	popm	r0-r7,pc

8000da7c <__avr32_umod64>:
8000da7c:	d4 31       	pushm	r0-r7,lr
8000da7e:	1a 97       	mov	r7,sp
8000da80:	20 3d       	sub	sp,12
8000da82:	10 9c       	mov	r12,r8
8000da84:	12 95       	mov	r5,r9
8000da86:	14 9e       	mov	lr,r10
8000da88:	16 91       	mov	r1,r11
8000da8a:	16 96       	mov	r6,r11
8000da8c:	58 09       	cp.w	r9,0
8000da8e:	e0 81 00 81 	brne	8000db90 <__avr32_umod64+0x114>
8000da92:	16 38       	cp.w	r8,r11
8000da94:	e0 88 00 12 	brls	8000dab8 <__avr32_umod64+0x3c>
8000da98:	f0 08 12 00 	clz	r8,r8
8000da9c:	c4 e0       	breq	8000db38 <__avr32_umod64+0xbc>
8000da9e:	f6 08 09 46 	lsl	r6,r11,r8
8000daa2:	f8 08 09 4c 	lsl	r12,r12,r8
8000daa6:	f0 0b 11 20 	rsub	r11,r8,32
8000daaa:	f4 08 09 4e 	lsl	lr,r10,r8
8000daae:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000dab2:	f7 e6 10 06 	or	r6,r11,r6
8000dab6:	c4 18       	rjmp	8000db38 <__avr32_umod64+0xbc>
8000dab8:	58 08       	cp.w	r8,0
8000daba:	c0 51       	brne	8000dac4 <__avr32_umod64+0x48>
8000dabc:	30 19       	mov	r9,1
8000dabe:	f2 08 0d 08 	divu	r8,r9,r8
8000dac2:	10 9c       	mov	r12,r8
8000dac4:	f8 08 12 00 	clz	r8,r12
8000dac8:	c0 31       	brne	8000dace <__avr32_umod64+0x52>
8000daca:	18 16       	sub	r6,r12
8000dacc:	c3 68       	rjmp	8000db38 <__avr32_umod64+0xbc>
8000dace:	f0 03 11 20 	rsub	r3,r8,32
8000dad2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000dad6:	f8 08 09 4c 	lsl	r12,r12,r8
8000dada:	ec 08 09 49 	lsl	r9,r6,r8
8000dade:	ec 03 0a 43 	lsr	r3,r6,r3
8000dae2:	f7 e9 10 09 	or	r9,r11,r9
8000dae6:	f8 05 16 10 	lsr	r5,r12,0x10
8000daea:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000daee:	e6 05 0d 02 	divu	r2,r3,r5
8000daf2:	f2 0e 16 10 	lsr	lr,r9,0x10
8000daf6:	ec 02 02 4b 	mul	r11,r6,r2
8000dafa:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000dafe:	16 3e       	cp.w	lr,r11
8000db00:	c0 72       	brcc	8000db0e <__avr32_umod64+0x92>
8000db02:	18 0e       	add	lr,r12
8000db04:	18 3e       	cp.w	lr,r12
8000db06:	c0 43       	brcs	8000db0e <__avr32_umod64+0x92>
8000db08:	16 3e       	cp.w	lr,r11
8000db0a:	fd dc e3 0e 	addcs	lr,lr,r12
8000db0e:	fc 0b 01 03 	sub	r3,lr,r11
8000db12:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000db16:	e6 05 0d 02 	divu	r2,r3,r5
8000db1a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000db1e:	a5 36       	mul	r6,r2
8000db20:	0c 39       	cp.w	r9,r6
8000db22:	c0 72       	brcc	8000db30 <__avr32_umod64+0xb4>
8000db24:	18 09       	add	r9,r12
8000db26:	18 39       	cp.w	r9,r12
8000db28:	c0 43       	brcs	8000db30 <__avr32_umod64+0xb4>
8000db2a:	0c 39       	cp.w	r9,r6
8000db2c:	f3 dc e3 09 	addcs	r9,r9,r12
8000db30:	f2 06 01 06 	sub	r6,r9,r6
8000db34:	f4 08 09 4e 	lsl	lr,r10,r8
8000db38:	f8 0a 16 10 	lsr	r10,r12,0x10
8000db3c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000db40:	ec 0a 0d 02 	divu	r2,r6,r10
8000db44:	fc 09 16 10 	lsr	r9,lr,0x10
8000db48:	ea 02 02 4b 	mul	r11,r5,r2
8000db4c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000db50:	16 39       	cp.w	r9,r11
8000db52:	c0 72       	brcc	8000db60 <__avr32_umod64+0xe4>
8000db54:	18 09       	add	r9,r12
8000db56:	18 39       	cp.w	r9,r12
8000db58:	c0 43       	brcs	8000db60 <__avr32_umod64+0xe4>
8000db5a:	16 39       	cp.w	r9,r11
8000db5c:	f3 dc e3 09 	addcs	r9,r9,r12
8000db60:	f2 0b 01 0b 	sub	r11,r9,r11
8000db64:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000db68:	f6 0a 0d 0a 	divu	r10,r11,r10
8000db6c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000db70:	ea 0a 02 4a 	mul	r10,r5,r10
8000db74:	14 3e       	cp.w	lr,r10
8000db76:	c0 72       	brcc	8000db84 <__avr32_umod64+0x108>
8000db78:	18 0e       	add	lr,r12
8000db7a:	18 3e       	cp.w	lr,r12
8000db7c:	c0 43       	brcs	8000db84 <__avr32_umod64+0x108>
8000db7e:	14 3e       	cp.w	lr,r10
8000db80:	fd dc e3 0e 	addcs	lr,lr,r12
8000db84:	fc 0a 01 0a 	sub	r10,lr,r10
8000db88:	30 0b       	mov	r11,0
8000db8a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000db8e:	c7 b8       	rjmp	8000dc84 <__avr32_umod64+0x208>
8000db90:	16 39       	cp.w	r9,r11
8000db92:	e0 8b 00 79 	brhi	8000dc84 <__avr32_umod64+0x208>
8000db96:	f2 09 12 00 	clz	r9,r9
8000db9a:	c1 21       	brne	8000dbbe <__avr32_umod64+0x142>
8000db9c:	10 3a       	cp.w	r10,r8
8000db9e:	5f 2b       	srhs	r11
8000dba0:	0a 31       	cp.w	r1,r5
8000dba2:	5f ba       	srhi	r10
8000dba4:	f7 ea 10 0a 	or	r10,r11,r10
8000dba8:	f2 0a 18 00 	cp.b	r10,r9
8000dbac:	c0 60       	breq	8000dbb8 <__avr32_umod64+0x13c>
8000dbae:	fc 08 01 0c 	sub	r12,lr,r8
8000dbb2:	e2 05 01 46 	sbc	r6,r1,r5
8000dbb6:	18 9e       	mov	lr,r12
8000dbb8:	0c 9b       	mov	r11,r6
8000dbba:	1c 9a       	mov	r10,lr
8000dbbc:	c6 48       	rjmp	8000dc84 <__avr32_umod64+0x208>
8000dbbe:	ea 09 09 4c 	lsl	r12,r5,r9
8000dbc2:	f2 06 11 20 	rsub	r6,r9,32
8000dbc6:	f6 09 09 4b 	lsl	r11,r11,r9
8000dbca:	f0 09 09 42 	lsl	r2,r8,r9
8000dbce:	ef 46 ff f4 	st.w	r7[-12],r6
8000dbd2:	f0 06 0a 48 	lsr	r8,r8,r6
8000dbd6:	18 48       	or	r8,r12
8000dbd8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000dbdc:	f4 09 09 43 	lsl	r3,r10,r9
8000dbe0:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000dbe4:	f4 06 0a 4a 	lsr	r10,r10,r6
8000dbe8:	16 4a       	or	r10,r11
8000dbea:	f0 0b 16 10 	lsr	r11,r8,0x10
8000dbee:	f8 0b 0d 04 	divu	r4,r12,r11
8000dbf2:	f4 0c 16 10 	lsr	r12,r10,0x10
8000dbf6:	08 91       	mov	r1,r4
8000dbf8:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000dbfc:	e8 0e 02 46 	mul	r6,r4,lr
8000dc00:	0c 3c       	cp.w	r12,r6
8000dc02:	c0 a2       	brcc	8000dc16 <__avr32_umod64+0x19a>
8000dc04:	20 11       	sub	r1,1
8000dc06:	10 0c       	add	r12,r8
8000dc08:	10 3c       	cp.w	r12,r8
8000dc0a:	c0 63       	brcs	8000dc16 <__avr32_umod64+0x19a>
8000dc0c:	0c 3c       	cp.w	r12,r6
8000dc0e:	f7 b1 03 01 	sublo	r1,1
8000dc12:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000dc16:	0c 1c       	sub	r12,r6
8000dc18:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000dc1c:	f8 0b 0d 04 	divu	r4,r12,r11
8000dc20:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000dc24:	08 96       	mov	r6,r4
8000dc26:	e8 0e 02 4e 	mul	lr,r4,lr
8000dc2a:	1c 3b       	cp.w	r11,lr
8000dc2c:	c0 a2       	brcc	8000dc40 <__avr32_umod64+0x1c4>
8000dc2e:	20 16       	sub	r6,1
8000dc30:	10 0b       	add	r11,r8
8000dc32:	10 3b       	cp.w	r11,r8
8000dc34:	c0 63       	brcs	8000dc40 <__avr32_umod64+0x1c4>
8000dc36:	1c 3b       	cp.w	r11,lr
8000dc38:	f7 b6 03 01 	sublo	r6,1
8000dc3c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000dc40:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000dc44:	1c 1b       	sub	r11,lr
8000dc46:	e2 02 06 40 	mulu.d	r0,r1,r2
8000dc4a:	00 9e       	mov	lr,r0
8000dc4c:	02 9c       	mov	r12,r1
8000dc4e:	16 3c       	cp.w	r12,r11
8000dc50:	e0 8b 00 08 	brhi	8000dc60 <__avr32_umod64+0x1e4>
8000dc54:	5f 06       	sreq	r6
8000dc56:	06 30       	cp.w	r0,r3
8000dc58:	5f ba       	srhi	r10
8000dc5a:	ed ea 00 0a 	and	r10,r6,r10
8000dc5e:	c0 60       	breq	8000dc6a <__avr32_umod64+0x1ee>
8000dc60:	fc 02 01 04 	sub	r4,lr,r2
8000dc64:	f8 08 01 4c 	sbc	r12,r12,r8
8000dc68:	08 9e       	mov	lr,r4
8000dc6a:	e6 0e 01 0a 	sub	r10,r3,lr
8000dc6e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000dc72:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000dc76:	f8 09 0a 4b 	lsr	r11,r12,r9
8000dc7a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000dc7e:	f8 01 09 4c 	lsl	r12,r12,r1
8000dc82:	18 4a       	or	r10,r12
8000dc84:	2f dd       	sub	sp,-12
8000dc86:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000de00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000de00:	c0 08       	rjmp	8000de00 <_evba>
	...

8000de04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000de04:	c0 08       	rjmp	8000de04 <_handle_TLB_Multiple_Hit>
	...

8000de08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000de08:	c0 08       	rjmp	8000de08 <_handle_Bus_Error_Data_Fetch>
	...

8000de0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000de0c:	c0 08       	rjmp	8000de0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000de10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000de10:	c0 08       	rjmp	8000de10 <_handle_NMI>
	...

8000de14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000de14:	c0 08       	rjmp	8000de14 <_handle_Instruction_Address>
	...

8000de18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000de18:	c0 08       	rjmp	8000de18 <_handle_ITLB_Protection>
	...

8000de1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000de1c:	c0 08       	rjmp	8000de1c <_handle_Breakpoint>
	...

8000de20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000de20:	c0 08       	rjmp	8000de20 <_handle_Illegal_Opcode>
	...

8000de24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000de24:	c0 08       	rjmp	8000de24 <_handle_Unimplemented_Instruction>
	...

8000de28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000de28:	c0 08       	rjmp	8000de28 <_handle_Privilege_Violation>
	...

8000de2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000de2c:	c0 08       	rjmp	8000de2c <_handle_Floating_Point>
	...

8000de30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000de30:	c0 08       	rjmp	8000de30 <_handle_Coprocessor_Absent>
	...

8000de34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000de34:	c0 08       	rjmp	8000de34 <_handle_Data_Address_Read>
	...

8000de38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000de38:	c0 08       	rjmp	8000de38 <_handle_Data_Address_Write>
	...

8000de3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000de3c:	c0 08       	rjmp	8000de3c <_handle_DTLB_Protection_Read>
	...

8000de40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000de40:	c0 08       	rjmp	8000de40 <_handle_DTLB_Protection_Write>
	...

8000de44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000de44:	c0 08       	rjmp	8000de44 <_handle_DTLB_Modified>
	...

8000de50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000de50:	c0 08       	rjmp	8000de50 <_handle_ITLB_Miss>
	...

8000de60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000de60:	c0 08       	rjmp	8000de60 <_handle_DTLB_Miss_Read>
	...

8000de70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000de70:	c0 08       	rjmp	8000de70 <_handle_DTLB_Miss_Write>
	...

8000df00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000df00:	fe cf 71 3c 	sub	pc,pc,28988

8000df04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000df04:	30 0c       	mov	r12,0
8000df06:	fe b0 c2 c5 	rcall	80006490 <_get_interrupt_handler>
8000df0a:	58 0c       	cp.w	r12,0
8000df0c:	f8 0f 17 10 	movne	pc,r12
8000df10:	d6 03       	rete

8000df12 <_int1>:
8000df12:	30 1c       	mov	r12,1
8000df14:	fe b0 c2 be 	rcall	80006490 <_get_interrupt_handler>
8000df18:	58 0c       	cp.w	r12,0
8000df1a:	f8 0f 17 10 	movne	pc,r12
8000df1e:	d6 03       	rete

8000df20 <_int2>:
8000df20:	30 2c       	mov	r12,2
8000df22:	fe b0 c2 b7 	rcall	80006490 <_get_interrupt_handler>
8000df26:	58 0c       	cp.w	r12,0
8000df28:	f8 0f 17 10 	movne	pc,r12
8000df2c:	d6 03       	rete

8000df2e <_int3>:
8000df2e:	30 3c       	mov	r12,3
8000df30:	fe b0 c2 b0 	rcall	80006490 <_get_interrupt_handler>
8000df34:	58 0c       	cp.w	r12,0
8000df36:	f8 0f 17 10 	movne	pc,r12
8000df3a:	d6 03       	rete

8000df3c <ipr_val>:
8000df3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000df4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000df9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dffc:	d7 03 d7 03                                         ....
