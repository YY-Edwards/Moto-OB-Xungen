
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000acf0  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012b8  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a40  00000004  8000e2b8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a44  8000ecf8  0000f244  2**0
                  ALLOC
  7 .bss          00004988  00000a48  8000ecf8  0000f248  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f244  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001738  00000000  00000000  0000f278  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000376c  00000000  00000000  000109b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002dcc3  00000000  00000000  0001411c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000076c0  00000000  00000000  00041ddf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d918  00000000  00000000  0004949f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003eb0  00000000  00000000  00056db8  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000080f6  00000000  00000000  0005ac68  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f760  00000000  00000000  00062d5e  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 000017f0  00000000  00000000  000724c0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 78 	sub	pc,pc,-15496

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 98       	ld.ub	r8,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3e f0       	mov	r0,-17
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2b 8c       	sub	r12,-72
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d0 00       	acall	0x0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6c 20       	ld.w	r0,r6[0x8]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 60       	and	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d0 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6f e4       	ld.w	r4,r7[0x78]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 54       	eor	r4,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6f e4       	ld.w	r4,r7[0x78]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 4b       	or	r11,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d0 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6f e4       	ld.w	r4,r7[0x78]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d0 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6f e4       	ld.w	r4,r7[0x78]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d0 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6f e4       	ld.w	r4,r7[0x78]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d0 70       	acall	0x7
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6f e4       	ld.w	r4,r7[0x78]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d0 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6f e4       	ld.w	r4,r7[0x78]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d0 a0       	acall	0xa
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d0 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d0 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d0 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	d1 00       	acall	0x10
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	6f e4       	ld.w	r4,r7[0x78]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	d1 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	d1 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	d1 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	6f e4       	ld.w	r4,r7[0x78]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d1 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	d1 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d1 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d1 a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	d1 cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	d1 f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d2 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d2 40       	acall	0x24

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d2 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	6f e4       	ld.w	r4,r7[0x78]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d1 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d2 7c       	*unknown*

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	d2 98       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	6f e4       	ld.w	r4,r7[0x78]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	d2 a8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d2 b4       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d2 c0       	acall	0x2c
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	d2 d0       	acall	0x2d
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d2 e0       	acall	0x2e
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d2 ec       	*unknown*

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	d2 f8       	*unknown*
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	6f e4       	ld.w	r4,r7[0x78]
800023c0:	00 00       	add	r0,r0
800023c2:	0a 4d       	or	sp,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d3 10       	acall	0x31
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	6f e4       	ld.w	r4,r7[0x78]
80002404:	00 00       	add	r0,r0
80002406:	0a 4c       	or	r12,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d3 28       	*unknown*

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d3 3c       	*unknown*
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	6f e4       	ld.w	r4,r7[0x78]
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 58       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d3 6c       	*unknown*
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d3 88       	*unknown*
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d3 98       	*unknown*

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d3 b0       	acall	0x3b
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	6f e4       	ld.w	r4,r7[0x78]
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d3 c0       	acall	0x3c

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d3 d4       	*unknown*
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	6f e4       	ld.w	r4,r7[0x78]
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d3 e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d4 04       	*unknown*
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d4 1c       	*unknown*

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 48       	or	r8,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d4 34       	*unknown*
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	6f e4       	ld.w	r4,r7[0x78]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d4 44       	*unknown*

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 48       	or	r8,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d4 50       	acall	0x45
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	6f e4       	ld.w	r4,r7[0x78]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d4 60       	acall	0x46

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	d4 6c       	*unknown*
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	6f e4       	ld.w	r4,r7[0x78]
800025c4:	00 00       	add	r0,r0
800025c6:	0a 5c       	eor	r12,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	d4 80       	acall	0x48
800025cc:	00 00       	add	r0,r0
800025ce:	0a 4d       	or	sp,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	d4 94       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	6f e4       	ld.w	r4,r7[0x78]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 a4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	d4 b8       	*unknown*
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d4 cc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d4 e8       	*unknown*
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d5 00       	acall	0x50
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d5 18       	*unknown*
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d5 30       	acall	0x53

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d5 40       	acall	0x54
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	6f e4       	ld.w	r4,r7[0x78]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 54       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	d5 68       	*unknown*
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d5 80       	acall	0x58

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d5 9c       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	6f e4       	ld.w	r4,r7[0x78]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d5 b0       	acall	0x5b
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d5 c4       	*unknown*
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d5 d8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d5 e4       	*unknown*

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d5 f0       	acall	0x5f
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	6f e4       	ld.w	r4,r7[0x78]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d5 fc       	*unknown*

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 39 	mcall	80002824 <app_cfg+0xe8>
80002744:	4b 98       	lddpc	r8,80002828 <app_cfg+0xec>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4b 97       	lddpc	r7,8000282c <app_cfg+0xf0>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b a5       	lddpc	r5,80002830 <app_cfg+0xf4>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4b 84       	lddpc	r4,80002834 <app_cfg+0xf8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c3 40       	breq	800027c2 <app_cfg+0x86>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c4 00       	breq	800027de <app_cfg+0xa2>
80002760:	58 08       	cp.w	r8,0
80002762:	c5 a1       	brne	80002816 <app_cfg+0xda>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4b 58       	lddpc	r8,80002838 <app_cfg+0xfc>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4b 38       	lddpc	r8,8000283c <app_cfg+0x100>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4b 18       	lddpc	r8,8000283c <app_cfg+0x100>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 30 	mcall	80002840 <app_cfg+0x104>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
8000278a:	4a fc       	lddpc	r12,80002844 <app_cfg+0x108>
8000278c:	f0 1f 00 2f 	mcall	80002848 <app_cfg+0x10c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c4 38       	rjmp	80002816 <app_cfg+0xda>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a dc       	lddpc	r12,8000284c <app_cfg+0x110>
8000279a:	f0 1f 00 2c 	mcall	80002848 <app_cfg+0x10c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
8000279e:	4a d8       	lddpc	r8,80002850 <app_cfg+0x114>
800027a0:	11 de       	ld.ub	lr,r8[0x5]
800027a2:	11 cc       	ld.ub	r12,r8[0x4]
800027a4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027a6:	11 aa       	ld.ub	r10,r8[0x2]
800027a8:	11 99       	ld.ub	r9,r8[0x1]
800027aa:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ac:	1a de       	st.w	--sp,lr
800027ae:	1a dc       	st.w	--sp,r12
800027b0:	1a db       	st.w	--sp,r11
800027b2:	1a da       	st.w	--sp,r10
800027b4:	1a d9       	st.w	--sp,r9
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	4a 7c       	lddpc	r12,80002854 <app_cfg+0x118>
800027ba:	f0 1f 00 24 	mcall	80002848 <app_cfg+0x10c>
800027be:	2f ad       	sub	sp,-24
800027c0:	c2 b8       	rjmp	80002816 <app_cfg+0xda>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027c2:	0b 88       	ld.ub	r8,r5[0x0]
800027c4:	58 08       	cp.w	r8,0
800027c6:	c0 60       	breq	800027d2 <app_cfg+0x96>
							
							OB_State = OB_WAITINGAPPTASK;
800027c8:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027ca:	4a 4c       	lddpc	r12,80002858 <app_cfg+0x11c>
800027cc:	f0 1f 00 1f 	mcall	80002848 <app_cfg+0x10c>
800027d0:	c2 38       	rjmp	80002816 <app_cfg+0xda>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027d2:	04 9a       	mov	r10,r2
800027d4:	02 9b       	mov	r11,r1
800027d6:	0c 9c       	mov	r12,r6
800027d8:	f0 1f 00 21 	mcall	8000285c <app_cfg+0x120>
800027dc:	c1 d8       	rjmp	80002816 <app_cfg+0xda>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027de:	68 0c       	ld.w	r12,r4[0x0]
800027e0:	0c 99       	mov	r9,r6
800027e2:	e0 6a 0f a0 	mov	r10,4000
800027e6:	1a 9b       	mov	r11,sp
800027e8:	f0 1f 00 1e 	mcall	80002860 <app_cfg+0x124>
800027ec:	58 1c       	cp.w	r12,1
800027ee:	c1 01       	brne	8000280e <app_cfg+0xd2>
					{
						if(data_ptr!=NULL){//Resend message
800027f0:	40 0c       	lddsp	r12,sp[0x0]
800027f2:	58 0c       	cp.w	r12,0
800027f4:	c0 d0       	breq	8000280e <app_cfg+0xd2>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027f6:	04 9a       	mov	r10,r2
800027f8:	02 9b       	mov	r11,r1
800027fa:	f0 1f 00 19 	mcall	8000285c <app_cfg+0x120>
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
800027fe:	49 a8       	lddpc	r8,80002864 <app_cfg+0x128>
80002800:	70 0c       	ld.w	r12,r8[0x0]
80002802:	40 0b       	lddsp	r11,sp[0x0]
80002804:	f0 1f 00 19 	mcall	80002868 <app_cfg+0x12c>
							log("receive okay!\n");
80002808:	49 9c       	lddpc	r12,8000286c <app_cfg+0x130>
8000280a:	f0 1f 00 10 	mcall	80002848 <app_cfg+0x10c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
8000280e:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002810:	49 8c       	lddpc	r12,80002870 <app_cfg+0x134>
80002812:	f0 1f 00 0e 	mcall	80002848 <app_cfg+0x10c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002816:	e0 6b 0f a0 	mov	r11,4000
8000281a:	48 4c       	lddpc	r12,80002828 <app_cfg+0xec>
8000281c:	f0 1f 00 16 	mcall	80002874 <app_cfg+0x138>
	}
80002820:	c9 bb       	rjmp	80002756 <app_cfg+0x1a>
80002822:	00 00       	add	r0,r0
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	69 10       	ld.w	r0,r4[0x44]
80002828:	00 00       	add	r0,r0
8000282a:	0a 58       	eor	r8,r5
8000282c:	00 00       	add	r0,r0
8000282e:	0a 50       	eor	r0,r5
80002830:	00 00       	add	r0,r0
80002832:	00 04       	add	r4,r0
80002834:	00 00       	add	r0,r0
80002836:	0b 6c       	ld.uh	r12,--r5
80002838:	00 00       	add	r0,r0
8000283a:	0d 98       	ld.ub	r8,r6[0x1]
8000283c:	00 00       	add	r0,r0
8000283e:	0a 56       	eor	r6,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	40 7c       	lddsp	r12,sp[0x1c]
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	d6 08       	*unknown*
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	6f e4       	ld.w	r4,r7[0x78]
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	d6 1c       	*unknown*
80002850:	00 00       	add	r0,r0
80002852:	0d 9c       	ld.ub	r12,r6[0x1]
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	d6 2c       	*unknown*
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	d6 58       	*unknown*
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	3f 44       	mov	r4,-12
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	61 a0       	ld.w	r0,r0[0x68]
80002864:	00 00       	add	r0,r0
80002866:	0b 74       	ld.ub	r4,--r5
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	2c 0c       	sub	r12,-64
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	d6 68       	*unknown*
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	d6 78       	*unknown*
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	6a c0       	ld.w	r0,r5[0x30]

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	d6 88       	*unknown*
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	6f e4       	ld.w	r4,r7[0x78]
800028c0:	00 00       	add	r0,r0
800028c2:	0a 56       	eor	r6,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	40 7c       	lddsp	r12,sp[0x1c]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	6a 78       	ld.w	r8,r5[0x1c]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	50 2c       	stdsp	sp[0x8],r12

800028d0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028d0:	d4 21       	pushm	r4-r7,lr
800028d2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028d4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028d8:	0d 88       	ld.ub	r8,r6[0x0]
800028da:	32 49       	mov	r9,36
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c2 91       	brne	80002932 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028e2:	4a dc       	lddpc	r12,80002994 <DataSession_brdcst_func+0xc4>
800028e4:	f0 1f 00 2d 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028e8:	0d a5       	ld.ub	r5,r6[0x2]
800028ea:	0d b8       	ld.ub	r8,r6[0x3]
800028ec:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028f0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028f2:	0d 98       	ld.ub	r8,r6[0x1]
800028f4:	1a d8       	st.w	--sp,r8
800028f6:	4a ac       	lddpc	r12,8000299c <DataSession_brdcst_func+0xcc>
800028f8:	f0 1f 00 28 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028fc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002900:	1a d8       	st.w	--sp,r8
80002902:	4a 8c       	lddpc	r12,800029a0 <DataSession_brdcst_func+0xd0>
80002904:	f0 1f 00 25 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002908:	2f ed       	sub	sp,-8
8000290a:	58 05       	cp.w	r5,0
8000290c:	c4 10       	breq	8000298e <DataSession_brdcst_func+0xbe>
8000290e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002910:	4a 54       	lddpc	r4,800029a4 <DataSession_brdcst_func+0xd4>
80002912:	ec 07 00 08 	add	r8,r6,r7
80002916:	11 c8       	ld.ub	r8,r8[0x4]
80002918:	1a d8       	st.w	--sp,r8
8000291a:	1a d7       	st.w	--sp,r7
8000291c:	08 9c       	mov	r12,r4
8000291e:	f0 1f 00 1f 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002922:	2f f7       	sub	r7,-1
80002924:	5c 57       	castu.b	r7
80002926:	2f ed       	sub	sp,-8
80002928:	ee 05 19 00 	cp.h	r5,r7
8000292c:	fe 9b ff f3 	brhi	80002912 <DataSession_brdcst_func+0x42>
80002930:	c2 f8       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002932:	1a d8       	st.w	--sp,r8
80002934:	49 dc       	lddpc	r12,800029a8 <DataSession_brdcst_func+0xd8>
80002936:	f0 1f 00 19 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000293a:	0d 88       	ld.ub	r8,r6[0x0]
8000293c:	2f fd       	sub	sp,-4
8000293e:	30 39       	mov	r9,3
80002940:	f2 08 18 00 	cp.b	r8,r9
80002944:	c0 51       	brne	8000294e <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002946:	49 ac       	lddpc	r12,800029ac <DataSession_brdcst_func+0xdc>
80002948:	f0 1f 00 14 	mcall	80002998 <DataSession_brdcst_func+0xc8>
8000294c:	c2 18       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000294e:	30 49       	mov	r9,4
80002950:	f2 08 18 00 	cp.b	r8,r9
80002954:	c1 d1       	brne	8000298e <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002956:	32 0a       	mov	r10,32
80002958:	ec cb ff fc 	sub	r11,r6,-4
8000295c:	1a 9c       	mov	r12,sp
8000295e:	f0 1f 00 15 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002962:	49 58       	lddpc	r8,800029b4 <DataSession_brdcst_func+0xe4>
80002964:	70 0c       	ld.w	r12,r8[0x0]
80002966:	f0 1f 00 15 	mcall	800029b8 <DataSession_brdcst_func+0xe8>
8000296a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
8000296c:	c0 e0       	breq	80002988 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000296e:	32 0a       	mov	r10,32
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 10 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002976:	49 28       	lddpc	r8,800029bc <DataSession_brdcst_func+0xec>
80002978:	70 0c       	ld.w	r12,r8[0x0]
8000297a:	30 09       	mov	r9,0
8000297c:	12 9a       	mov	r10,r9
8000297e:	fa cb ff e0 	sub	r11,sp,-32
80002982:	f0 1f 00 10 	mcall	800029c0 <DataSession_brdcst_func+0xf0>
80002986:	c0 48       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002988:	48 fc       	lddpc	r12,800029c4 <DataSession_brdcst_func+0xf4>
8000298a:	f0 1f 00 04 	mcall	80002998 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000298e:	2f 7d       	sub	sp,-36
80002990:	d8 22       	popm	r4-r7,pc
80002992:	00 00       	add	r0,r0
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	d6 a8       	*unknown*
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	6f e4       	ld.w	r4,r7[0x78]
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	d6 bc       	*unknown*
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	d6 d4       	*unknown*
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	d6 f0       	acall	0x6f
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	d7 08       	*unknown*
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	d7 14       	*unknown*
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	78 68       	ld.w	r8,r12[0x18]
800029b4:	00 00       	add	r0,r0
800029b6:	0b 74       	ld.ub	r4,--r5
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	2d b8       	sub	r8,-37
800029bc:	00 00       	add	r0,r0
800029be:	0b 6c       	ld.uh	r12,--r5
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	63 ac       	ld.w	r12,r1[0x68]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	d7 2c       	*unknown*

800029c8 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029c8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ca:	19 e8       	ld.ub	r8,r12[0x6]
800029cc:	30 19       	mov	r9,1
800029ce:	f2 08 18 00 	cp.b	r8,r9
800029d2:	c0 61       	brne	800029de <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029d4:	48 98       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029d6:	70 09       	ld.w	r9,r8[0x0]
800029d8:	a1 a9       	sbr	r9,0x0
800029da:	91 09       	st.w	r8[0x0],r9
800029dc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029de:	30 29       	mov	r9,2
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c0 80       	breq	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029e6:	48 58       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029e8:	70 09       	ld.w	r9,r8[0x0]
800029ea:	e0 19 ff fc 	andl	r9,0xfffc
800029ee:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029f0:	f0 1f 00 03 	mcall	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029f4:	d8 02       	popm	pc
800029f6:	00 00       	add	r0,r0
800029f8:	00 00       	add	r0,r0
800029fa:	0d 98       	ld.ub	r8,r6[0x1]
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	3f d0       	mov	r0,-3

80002a00 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80002a00:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
80002a02:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80002a04:	30 0a       	mov	r10,0
80002a06:	32 8b       	mov	r11,40
80002a08:	49 5c       	lddpc	r12,80002a5c <xg_rtc_init+0x5c>
80002a0a:	f0 1f 00 16 	mcall	80002a60 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80002a0e:	30 ea       	mov	r10,14
80002a10:	30 1b       	mov	r11,1
80002a12:	fe 7c 0d 00 	mov	r12,-62208
80002a16:	f0 1f 00 14 	mcall	80002a64 <xg_rtc_init+0x64>
80002a1a:	c0 41       	brne	80002a22 <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80002a1c:	49 3c       	lddpc	r12,80002a68 <xg_rtc_init+0x68>
80002a1e:	f0 1f 00 14 	mcall	80002a6c <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
80002a22:	30 0b       	mov	r11,0
80002a24:	fe 7c 0d 00 	mov	r12,-62208
80002a28:	f0 1f 00 12 	mcall	80002a70 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80002a2c:	fe 7c 0d 00 	mov	r12,-62208
80002a30:	f0 1f 00 11 	mcall	80002a74 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80002a34:	fe 7c 0d 00 	mov	r12,-62208
80002a38:	f0 1f 00 10 	mcall	80002a78 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80002a3c:	49 08       	lddpc	r8,80002a7c <xg_rtc_init+0x7c>
80002a3e:	31 09       	mov	r9,16
80002a40:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80002a42:	30 29       	mov	r9,2
80002a44:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80002a46:	31 d9       	mov	r9,29
80002a48:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002a4a:	31 79       	mov	r9,23
80002a4c:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002a4e:	33 b9       	mov	r9,59
80002a50:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80002a52:	32 89       	mov	r9,40
80002a54:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80002a56:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002a58:	d8 02       	popm	pc
80002a5a:	00 00       	add	r0,r0
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	2a 80       	sub	r0,-88
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	54 4c       	stdsp	sp[0x110],r12
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	57 98       	stdsp	sp[0x1e4],r8
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	d7 3c       	*unknown*
80002a6c:	80 00       	ld.sh	r0,r0[0x0]
80002a6e:	6f e4       	ld.w	r4,r7[0x78]
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	57 54       	stdsp	sp[0x1d4],r4
80002a74:	80 00       	ld.sh	r0,r0[0x0]
80002a76:	57 4c       	stdsp	sp[0x1d0],r12
80002a78:	80 00       	ld.sh	r0,r0[0x0]
80002a7a:	57 28       	stdsp	sp[0x1c8],r8
80002a7c:	00 00       	add	r0,r0
80002a7e:	0d 9c       	ld.ub	r12,r6[0x1]

80002a80 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002a80:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80002a82:	4b 98       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002a84:	11 d9       	ld.ub	r9,r8[0x5]
80002a86:	2f f9       	sub	r9,-1
80002a88:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80002a8a:	11 d9       	ld.ub	r9,r8[0x5]
80002a8c:	33 b8       	mov	r8,59
80002a8e:	f0 09 18 00 	cp.b	r9,r8
80002a92:	e0 88 00 5f 	brls	80002b50 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80002a96:	4b 48       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002a98:	30 09       	mov	r9,0
80002a9a:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80002a9c:	11 c9       	ld.ub	r9,r8[0x4]
80002a9e:	2f f9       	sub	r9,-1
80002aa0:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80002aa2:	11 c9       	ld.ub	r9,r8[0x4]
80002aa4:	33 b8       	mov	r8,59
80002aa6:	f0 09 18 00 	cp.b	r9,r8
80002aaa:	e0 88 00 53 	brls	80002b50 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
80002aae:	4a e8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002ab0:	30 09       	mov	r9,0
80002ab2:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80002ab4:	11 b9       	ld.ub	r9,r8[0x3]
80002ab6:	2f f9       	sub	r9,-1
80002ab8:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80002aba:	11 b9       	ld.ub	r9,r8[0x3]
80002abc:	31 78       	mov	r8,23
80002abe:	f0 09 18 00 	cp.b	r9,r8
80002ac2:	e0 88 00 47 	brls	80002b50 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80002ac6:	4a 88       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002ac8:	30 09       	mov	r9,0
80002aca:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80002acc:	11 88       	ld.ub	r8,r8[0x0]
80002ace:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002ad2:	e0 69 01 6e 	mov	r9,366
80002ad6:	e0 6a 01 6d 	mov	r10,365
80002ada:	f4 08 17 10 	movne	r8,r10
80002ade:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80002ae2:	4a 19       	lddpc	r9,80002b64 <rtc_irq+0xe4>
80002ae4:	13 9a       	ld.ub	r10,r9[0x1]
80002ae6:	30 29       	mov	r9,2
80002ae8:	f2 0a 18 00 	cp.b	r10,r9
80002aec:	c0 b0       	breq	80002b02 <rtc_irq+0x82>
80002aee:	49 e8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002af0:	11 99       	ld.ub	r9,r8[0x1]
80002af2:	11 9a       	ld.ub	r10,r8[0x1]
80002af4:	a3 9a       	lsr	r10,0x3
80002af6:	12 0a       	add	r10,r9
80002af8:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80002afc:	2e 2a       	sub	r10,-30
80002afe:	5c 5a       	castu.b	r10
80002b00:	c0 58       	rjmp	80002b0a <rtc_irq+0x8a>
80002b02:	f0 c8 01 51 	sub	r8,r8,337
80002b06:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80002b0a:	49 78       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b0c:	11 a9       	ld.ub	r9,r8[0x2]
80002b0e:	2f f9       	sub	r9,-1
80002b10:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80002b12:	11 a8       	ld.ub	r8,r8[0x2]
80002b14:	f0 0a 18 00 	cp.b	r10,r8
80002b18:	c1 c2       	brcc	80002b50 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80002b1a:	49 38       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b1c:	30 19       	mov	r9,1
80002b1e:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80002b20:	11 99       	ld.ub	r9,r8[0x1]
80002b22:	2f f9       	sub	r9,-1
80002b24:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80002b26:	11 99       	ld.ub	r9,r8[0x1]
80002b28:	30 c8       	mov	r8,12
80002b2a:	f0 09 18 00 	cp.b	r9,r8
80002b2e:	e0 88 00 11 	brls	80002b50 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80002b32:	48 d8       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b34:	30 19       	mov	r9,1
80002b36:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80002b38:	11 89       	ld.ub	r9,r8[0x0]
80002b3a:	2f f9       	sub	r9,-1
80002b3c:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80002b3e:	11 89       	ld.ub	r9,r8[0x0]
80002b40:	39 68       	mov	r8,-106
80002b42:	f0 09 18 00 	cp.b	r9,r8
80002b46:	e0 88 00 05 	brls	80002b50 <rtc_irq+0xd0>
80002b4a:	30 09       	mov	r9,0
80002b4c:	48 68       	lddpc	r8,80002b64 <rtc_irq+0xe4>
80002b4e:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002b50:	fe 7c 0d 00 	mov	r12,-62208
80002b54:	f0 1f 00 05 	mcall	80002b68 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80002b58:	30 19       	mov	r9,1
80002b5a:	48 58       	lddpc	r8,80002b6c <rtc_irq+0xec>
80002b5c:	91 09       	st.w	r8[0x0],r9
}
80002b5e:	d4 02       	popm	lr
80002b60:	d6 03       	rete
80002b62:	00 00       	add	r0,r0
80002b64:	00 00       	add	r0,r0
80002b66:	0d 9c       	ld.ub	r12,r6[0x1]
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	57 78       	stdsp	sp[0x1dc],r8
80002b6c:	00 00       	add	r0,r0
80002b6e:	04 f4       	st.b	--r2,r4

80002b70 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b70:	20 1c       	sub	r12,1
80002b72:	5c 5c       	castu.b	r12
80002b74:	31 18       	mov	r8,17
80002b76:	f0 0c 18 00 	cp.b	r12,r8
80002b7a:	e0 88 00 03 	brls	80002b80 <CalculateBurst+0x10>
80002b7e:	5e fd       	retal	0
80002b80:	48 28       	lddpc	r8,80002b88 <CalculateBurst+0x18>
80002b82:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002b86:	5e fc       	retal	r12
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	d7 5c       	*unknown*

80002b8c <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002b8c:	48 38       	lddpc	r8,80002b98 <payload_init+0xc>
80002b8e:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002b90:	48 38       	lddpc	r8,80002b9c <payload_init+0x10>
80002b92:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002b94:	5e fc       	retal	r12
80002b96:	00 00       	add	r0,r0
80002b98:	00 00       	add	r0,r0
80002b9a:	0a 6c       	and	r12,r5
80002b9c:	00 00       	add	r0,r0
80002b9e:	0a 70       	tst	r0,r5

80002ba0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002ba0:	d4 01       	pushm	lr
80002ba2:	20 2d       	sub	sp,8
80002ba4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ba6:	30 09       	mov	r9,0
80002ba8:	fa ca ff f8 	sub	r10,sp,-8
80002bac:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002bae:	1a 9b       	mov	r11,sp
80002bb0:	f0 1f 00 02 	mcall	80002bb8 <set_idle_store_isr+0x18>
}
80002bb4:	2f ed       	sub	sp,-8
80002bb6:	d8 02       	popm	pc
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	63 5c       	ld.w	r12,r1[0x54]

80002bbc <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002bbc:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002bbe:	48 48       	lddpc	r8,80002bcc <payload_rx+0x10>
80002bc0:	70 08       	ld.w	r8,r8[0x0]
80002bc2:	18 9b       	mov	r11,r12
80002bc4:	10 9c       	mov	r12,r8
80002bc6:	f0 1f 00 03 	mcall	80002bd0 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002bca:	d8 02       	popm	pc
80002bcc:	00 00       	add	r0,r0
80002bce:	0a a8       	st.w	r5++,r8
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	2b a0       	sub	r0,-70

80002bd4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002bd4:	d4 01       	pushm	lr
80002bd6:	20 2d       	sub	sp,8
80002bd8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002bda:	58 0c       	cp.w	r12,0
80002bdc:	c1 10       	breq	80002bfe <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bde:	30 08       	mov	r8,0
80002be0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002be2:	98 88       	ld.uh	r8,r12[0x0]
80002be4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002be8:	e0 48 40 00 	cp.w	r8,16384
80002bec:	c0 91       	brne	80002bfe <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002bee:	48 68       	lddpc	r8,80002c04 <phy_rx+0x30>
80002bf0:	70 0c       	ld.w	r12,r8[0x0]
80002bf2:	30 09       	mov	r9,0
80002bf4:	fa ca ff fc 	sub	r10,sp,-4
80002bf8:	1a 9b       	mov	r11,sp
80002bfa:	f0 1f 00 04 	mcall	80002c08 <phy_rx+0x34>
		}	

    }
		
 
}
80002bfe:	2f ed       	sub	sp,-8
80002c00:	d8 02       	popm	pc
80002c02:	00 00       	add	r0,r0
80002c04:	00 00       	add	r0,r0
80002c06:	0a b4       	st.h	r5++,r4
80002c08:	80 00       	ld.sh	r0,r0[0x0]
80002c0a:	63 5c       	ld.w	r12,r1[0x54]

80002c0c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002c0c:	eb cd 40 80 	pushm	r7,lr
80002c10:	20 1d       	sub	sp,4
80002c12:	fa c7 ff fc 	sub	r7,sp,-4
80002c16:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002c18:	30 09       	mov	r9,0
80002c1a:	12 9a       	mov	r10,r9
80002c1c:	1a 9b       	mov	r11,sp
80002c1e:	f0 1f 00 03 	mcall	80002c28 <set_idle_store+0x1c>
}
80002c22:	2f fd       	sub	sp,-4
80002c24:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c28:	80 00       	ld.sh	r0,r0[0x0]
80002c2a:	63 ac       	ld.w	r12,r1[0x68]

80002c2c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c2c:	d4 01       	pushm	lr
80002c2e:	20 1d       	sub	sp,4
80002c30:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002c32:	98 88       	ld.uh	r8,r12[0x0]
80002c34:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c38:	e0 48 40 00 	cp.w	r8,16384
80002c3c:	c0 d1       	brne	80002c56 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c3e:	49 08       	lddpc	r8,80002c7c <phy_tx+0x50>
80002c40:	70 08       	ld.w	r8,r8[0x0]
80002c42:	58 08       	cp.w	r8,0
80002c44:	c1 a0       	breq	80002c78 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c46:	48 e8       	lddpc	r8,80002c7c <phy_tx+0x50>
80002c48:	70 0c       	ld.w	r12,r8[0x0]
80002c4a:	30 09       	mov	r9,0
80002c4c:	12 9a       	mov	r10,r9
80002c4e:	1a 9b       	mov	r11,sp
80002c50:	f0 1f 00 0c 	mcall	80002c80 <phy_tx+0x54>
80002c54:	c1 28       	rjmp	80002c78 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c56:	e0 48 10 00 	cp.w	r8,4096
80002c5a:	5f 0a       	sreq	r10
80002c5c:	e0 48 20 00 	cp.w	r8,8192
80002c60:	5f 09       	sreq	r9
80002c62:	f5 e9 10 09 	or	r9,r10,r9
80002c66:	c0 71       	brne	80002c74 <phy_tx+0x48>
80002c68:	e0 48 50 00 	cp.w	r8,20480
80002c6c:	c0 40       	breq	80002c74 <phy_tx+0x48>
80002c6e:	e0 48 60 00 	cp.w	r8,24576
80002c72:	c0 31       	brne	80002c78 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c74:	48 48       	lddpc	r8,80002c84 <phy_tx+0x58>
80002c76:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c78:	2f fd       	sub	sp,-4
80002c7a:	d8 02       	popm	pc
80002c7c:	00 00       	add	r0,r0
80002c7e:	0a d4       	st.w	--r5,r4
80002c80:	80 00       	ld.sh	r0,r0[0x0]
80002c82:	63 ac       	ld.w	r12,r1[0x68]
80002c84:	00 00       	add	r0,r0
80002c86:	0a c8       	st.b	r5++,r8

80002c88 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002c88:	d4 01       	pushm	lr
80002c8a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002c8c:	30 08       	mov	r8,0
80002c8e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c90:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002c92:	1a 9a       	mov	r10,sp
80002c94:	fa cb ff fc 	sub	r11,sp,-4
80002c98:	f0 1f 00 05 	mcall	80002cac <get_idle_store_isr+0x24>
80002c9c:	58 1c       	cp.w	r12,1
80002c9e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002ca2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002ca6:	2f ed       	sub	sp,-8
80002ca8:	d8 02       	popm	pc
80002caa:	00 00       	add	r0,r0
80002cac:	80 00       	ld.sh	r0,r0[0x0]
80002cae:	60 b0       	ld.w	r0,r0[0x2c]

80002cb0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002cb0:	eb cd 40 c0 	pushm	r6-r7,lr
80002cb4:	20 1d       	sub	sp,4
80002cb6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002cb8:	4b a8       	lddpc	r8,80002da0 <phy_tx_func+0xf0>
80002cba:	70 08       	ld.w	r8,r8[0x0]
80002cbc:	58 08       	cp.w	r8,0
80002cbe:	c6 60       	breq	80002d8a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002cc0:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002cc2:	30 08       	mov	r8,0
80002cc4:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002cc6:	4b 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002cc8:	70 08       	ld.w	r8,r8[0x0]
80002cca:	58 18       	cp.w	r8,1
80002ccc:	c2 60       	breq	80002d18 <phy_tx_func+0x68>
80002cce:	c0 43       	brcs	80002cd6 <phy_tx_func+0x26>
80002cd0:	58 28       	cp.w	r8,2
80002cd2:	c5 c1       	brne	80002d8a <phy_tx_func+0xda>
80002cd4:	c5 58       	rjmp	80002d7e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002cd6:	4b 38       	lddpc	r8,80002da0 <phy_tx_func+0xf0>
80002cd8:	70 0c       	ld.w	r12,r8[0x0]
80002cda:	1a 9a       	mov	r10,sp
80002cdc:	4b 3b       	lddpc	r11,80002da8 <phy_tx_func+0xf8>
80002cde:	f0 1f 00 34 	mcall	80002dac <phy_tx_func+0xfc>
80002ce2:	58 1c       	cp.w	r12,1
80002ce4:	c1 41       	brne	80002d0c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ce6:	4b 18       	lddpc	r8,80002da8 <phy_tx_func+0xf8>
80002ce8:	70 08       	ld.w	r8,r8[0x0]
80002cea:	90 08       	ld.sh	r8,r8[0x0]
80002cec:	10 9a       	mov	r10,r8
80002cee:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002cf2:	4b 09       	lddpc	r9,80002db0 <phy_tx_func+0x100>
80002cf4:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002cf6:	5c 78       	castu.h	r8
80002cf8:	ea 18 ab cd 	orh	r8,0xabcd
80002cfc:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002cfe:	30 19       	mov	r9,1
80002d00:	4a d8       	lddpc	r8,80002db4 <phy_tx_func+0x104>
80002d02:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002d04:	30 19       	mov	r9,1
80002d06:	4a 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d08:	91 09       	st.w	r8[0x0],r9
80002d0a:	c4 08       	rjmp	80002d8a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002d0c:	e0 68 5a 5a 	mov	r8,23130
80002d10:	ea 18 ab cd 	orh	r8,0xabcd
80002d14:	8f 18       	st.w	r7[0x4],r8
80002d16:	c3 a8       	rjmp	80002d8a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d18:	4a 7a       	lddpc	r10,80002db4 <phy_tx_func+0x104>
80002d1a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002d1c:	4a 39       	lddpc	r9,80002da8 <phy_tx_func+0xf8>
80002d1e:	72 09       	ld.w	r9,r9[0x0]
80002d20:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002d24:	b1 69       	lsl	r9,0x10
80002d26:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d28:	2f f8       	sub	r8,-1
80002d2a:	5c 58       	castu.b	r8
80002d2c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d2e:	4a 1b       	lddpc	r11,80002db0 <phy_tx_func+0x100>
80002d30:	96 0c       	ld.sh	r12,r11[0x0]
80002d32:	20 2c       	sub	r12,2
80002d34:	5c 8c       	casts.h	r12
80002d36:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d3a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d3c:	30 0b       	mov	r11,0
80002d3e:	f6 0a 19 00 	cp.h	r10,r11
80002d42:	e0 89 00 09 	brgt	80002d54 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d46:	e8 19 00 ba 	orl	r9,0xba
80002d4a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d4c:	30 09       	mov	r9,0
80002d4e:	49 68       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d50:	91 09       	st.w	r8[0x0],r9
80002d52:	c1 c8       	rjmp	80002d8a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d54:	49 5a       	lddpc	r10,80002da8 <phy_tx_func+0xf8>
80002d56:	74 0a       	ld.w	r10,r10[0x0]
80002d58:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d5c:	14 49       	or	r9,r10
80002d5e:	8f 19       	st.w	r7[0x4],r9
80002d60:	2f f8       	sub	r8,-1
80002d62:	49 59       	lddpc	r9,80002db4 <phy_tx_func+0x104>
80002d64:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d66:	20 2c       	sub	r12,2
80002d68:	49 28       	lddpc	r8,80002db0 <phy_tx_func+0x100>
80002d6a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d6c:	30 08       	mov	r8,0
80002d6e:	f0 0c 19 00 	cp.h	r12,r8
80002d72:	e0 89 00 0c 	brgt	80002d8a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d76:	30 29       	mov	r9,2
80002d78:	48 b8       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d7a:	91 09       	st.w	r8[0x0],r9
80002d7c:	c0 78       	rjmp	80002d8a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002d7e:	fc 18 00 ba 	movh	r8,0xba
80002d82:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002d84:	30 09       	mov	r9,0
80002d86:	48 88       	lddpc	r8,80002da4 <phy_tx_func+0xf4>
80002d88:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002d8a:	e0 68 5a 5a 	mov	r8,23130
80002d8e:	ea 18 ab cd 	orh	r8,0xabcd
80002d92:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002d94:	30 08       	mov	r8,0
80002d96:	8f 38       	st.w	r7[0xc],r8
}
80002d98:	2f fd       	sub	sp,-4
80002d9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d9e:	00 00       	add	r0,r0
80002da0:	00 00       	add	r0,r0
80002da2:	0a d4       	st.w	--r5,r4
80002da4:	00 00       	add	r0,r0
80002da6:	0a 94       	mov	r4,r5
80002da8:	00 00       	add	r0,r0
80002daa:	0a a0       	st.w	r5++,r0
80002dac:	80 00       	ld.sh	r0,r0[0x0]
80002dae:	60 b0       	ld.w	r0,r0[0x2c]
80002db0:	00 00       	add	r0,r0
80002db2:	0a bc       	st.h	r5++,r12
80002db4:	00 00       	add	r0,r0
80002db6:	0a 74       	tst	r4,r5

80002db8 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002db8:	d4 01       	pushm	lr
80002dba:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002dbc:	30 0a       	mov	r10,0
80002dbe:	fa cb ff fc 	sub	r11,sp,-4
80002dc2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002dc4:	14 99       	mov	r9,r10
80002dc6:	1a 9b       	mov	r11,sp
80002dc8:	f0 1f 00 05 	mcall	80002ddc <get_idle_store+0x24>
80002dcc:	58 1c       	cp.w	r12,1
80002dce:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002dd2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002dd6:	2f fd       	sub	sp,-4
80002dd8:	d8 02       	popm	pc
80002dda:	00 00       	add	r0,r0
80002ddc:	80 00       	ld.sh	r0,r0[0x0]
80002dde:	61 a0       	ld.w	r0,r0[0x68]

80002de0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002de0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002de2:	48 5b       	lddpc	r11,80002df4 <phy_init+0x14>
80002de4:	48 5c       	lddpc	r12,80002df8 <phy_init+0x18>
80002de6:	f0 1f 00 06 	mcall	80002dfc <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002dea:	f0 1f 00 06 	mcall	80002e00 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002dee:	f0 1f 00 06 	mcall	80002e04 <phy_init+0x24>
	
}
80002df2:	d8 02       	popm	pc
80002df4:	80 00       	ld.sh	r0,r0[0x0]
80002df6:	2c b0       	sub	r0,-53
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2e 08       	sub	r8,-32
80002dfc:	80 00       	ld.sh	r0,r0[0x0]
80002dfe:	3e 68       	mov	r8,-26
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	3e 7c       	mov	r12,-25
80002e04:	80 00       	ld.sh	r0,r0[0x0]
80002e06:	48 28       	lddpc	r8,80002e0c <phy_rx_func+0x4>

80002e08 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002e08:	eb cd 40 e0 	pushm	r5-r7,lr
80002e0c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002e0e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002e12:	70 08       	ld.w	r8,r8[0x0]
80002e14:	58 08       	cp.w	r8,0
80002e16:	e0 80 01 08 	breq	80003026 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002e1a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002e1c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002e20:	70 09       	ld.w	r9,r8[0x0]
80002e22:	2f f9       	sub	r9,-1
80002e24:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002e26:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002e2a:	70 08       	ld.w	r8,r8[0x0]
80002e2c:	58 18       	cp.w	r8,1
80002e2e:	e0 80 00 85 	breq	80002f38 <phy_rx_func+0x130>
80002e32:	c0 73       	brcs	80002e40 <phy_rx_func+0x38>
80002e34:	58 28       	cp.w	r8,2
80002e36:	c5 c0       	breq	80002eee <phy_rx_func+0xe6>
80002e38:	58 38       	cp.w	r8,3
80002e3a:	e0 81 00 f6 	brne	80003026 <phy_rx_func+0x21e>
80002e3e:	cd 58       	rjmp	80002fe8 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e40:	e0 6a 5a 5a 	mov	r10,23130
80002e44:	ea 1a ab cd 	orh	r10,0xabcd
80002e48:	14 36       	cp.w	r6,r10
80002e4a:	e0 80 00 ee 	breq	80003026 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e4e:	ec 08 16 10 	lsr	r8,r6,0x10
80002e52:	e0 48 ab cd 	cp.w	r8,43981
80002e56:	e0 81 00 e8 	brne	80003026 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e5a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e5e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e62:	20 28       	sub	r8,2
80002e64:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e68:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e6a:	30 09       	mov	r9,0
80002e6c:	f2 08 19 00 	cp.h	r8,r9
80002e70:	e0 8a 00 db 	brle	80003026 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e74:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e78:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e7a:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002e7e:	70 0c       	ld.w	r12,r8[0x0]
80002e80:	f0 1f 03 88 	mcall	80003ca0 <phy_rx_func+0xe98>
80002e84:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002e88:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002e8a:	58 0c       	cp.w	r12,0
80002e8c:	e0 80 00 cd 	breq	80003026 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002e90:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002e94:	90 09       	ld.sh	r9,r8[0x0]
80002e96:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002e9a:	2f f9       	sub	r9,-1
80002e9c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e9e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002ea2:	74 0a       	ld.w	r10,r10[0x0]
80002ea4:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002ea8:	76 0b       	ld.w	r11,r11[0x0]
80002eaa:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002eae:	2f f9       	sub	r9,-1
80002eb0:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002eb2:	e2 16 0f 00 	andl	r6,0xf00,COH
80002eb6:	e0 46 01 00 	cp.w	r6,256
80002eba:	c0 c0       	breq	80002ed2 <phy_rx_func+0xca>
80002ebc:	e0 8b 00 05 	brhi	80002ec6 <phy_rx_func+0xbe>
80002ec0:	58 06       	cp.w	r6,0
80002ec2:	c0 80       	breq	80002ed2 <phy_rx_func+0xca>
80002ec4:	c0 c8       	rjmp	80002edc <phy_rx_func+0xd4>
80002ec6:	e0 46 02 00 	cp.w	r6,512
80002eca:	c0 40       	breq	80002ed2 <phy_rx_func+0xca>
80002ecc:	e0 46 03 00 	cp.w	r6,768
80002ed0:	c0 61       	brne	80002edc <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002ed2:	30 29       	mov	r9,2
80002ed4:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002ed8:	91 09       	st.w	r8[0x0],r9
80002eda:	ca 68       	rjmp	80003026 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002edc:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002ee0:	70 0c       	ld.w	r12,r8[0x0]
80002ee2:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002ee6:	70 0b       	ld.w	r11,r8[0x0]
80002ee8:	f0 1f 03 70 	mcall	80003ca8 <phy_rx_func+0xea0>
80002eec:	c9 d8       	rjmp	80003026 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002eee:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002ef2:	b1 86       	lsr	r6,0x10
80002ef4:	14 06       	add	r6,r10
80002ef6:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002efa:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002efc:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002f00:	90 09       	ld.sh	r9,r8[0x0]
80002f02:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002f06:	76 0b       	ld.w	r11,r11[0x0]
80002f08:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002f0c:	2f f9       	sub	r9,-1
80002f0e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002f10:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002f14:	92 08       	ld.sh	r8,r9[0x0]
80002f16:	20 28       	sub	r8,2
80002f18:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002f1a:	30 09       	mov	r9,0
80002f1c:	f2 08 19 00 	cp.h	r8,r9
80002f20:	e0 8a 00 07 	brle	80002f2e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002f24:	30 19       	mov	r9,1
80002f26:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002f2a:	91 09       	st.w	r8[0x0],r9
80002f2c:	c7 d8       	rjmp	80003026 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f2e:	30 39       	mov	r9,3
80002f30:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002f34:	91 09       	st.w	r8[0x0],r9
80002f36:	c7 88       	rjmp	80003026 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f38:	ec 0a 14 10 	asr	r10,r6,0x10
80002f3c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f40:	90 09       	ld.sh	r9,r8[0x0]
80002f42:	14 09       	add	r9,r10
80002f44:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f46:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f4a:	92 08       	ld.sh	r8,r9[0x0]
80002f4c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f50:	76 0b       	ld.w	r11,r11[0x0]
80002f52:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f56:	2f f8       	sub	r8,-1
80002f58:	5c 88       	casts.h	r8
80002f5a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f5c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f60:	94 09       	ld.sh	r9,r10[0x0]
80002f62:	20 29       	sub	r9,2
80002f64:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f66:	30 0a       	mov	r10,0
80002f68:	f4 09 19 00 	cp.h	r9,r10
80002f6c:	e0 89 00 20 	brgt	80002fac <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f70:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f74:	e0 46 00 ba 	cp.w	r6,186
80002f78:	c0 d1       	brne	80002f92 <phy_rx_func+0x18a>
80002f7a:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002f7e:	90 09       	ld.sh	r9,r8[0x0]
80002f80:	f4 09 19 00 	cp.h	r9,r10
80002f84:	c0 71       	brne	80002f92 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002f86:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002f8a:	70 0c       	ld.w	r12,r8[0x0]
80002f8c:	f0 1f 03 49 	mcall	80003cb0 <phy_rx_func+0xea8>
80002f90:	c0 98       	rjmp	80002fa2 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002f92:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002f96:	70 0c       	ld.w	r12,r8[0x0]
80002f98:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002f9c:	70 0b       	ld.w	r11,r8[0x0]
80002f9e:	f0 1f 03 43 	mcall	80003ca8 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002fa2:	30 09       	mov	r9,0
80002fa4:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002fa8:	91 09       	st.w	r8[0x0],r9
80002faa:	c3 e8       	rjmp	80003026 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002fac:	5c 86       	casts.h	r6
80002fae:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002fb2:	92 0a       	ld.sh	r10,r9[0x0]
80002fb4:	0c 0a       	add	r10,r6
80002fb6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002fb8:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002fbc:	72 09       	ld.w	r9,r9[0x0]
80002fbe:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002fc2:	2f f8       	sub	r8,-1
80002fc4:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002fc8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002fca:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002fce:	92 08       	ld.sh	r8,r9[0x0]
80002fd0:	20 28       	sub	r8,2
80002fd2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002fd4:	30 09       	mov	r9,0
80002fd6:	f2 08 19 00 	cp.h	r8,r9
80002fda:	e0 89 00 26 	brgt	80003026 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002fde:	30 39       	mov	r9,3
80002fe0:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002fe4:	91 09       	st.w	r8[0x0],r9
80002fe6:	c2 08       	rjmp	80003026 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002fe8:	e6 16 00 ff 	andh	r6,0xff,COH
80002fec:	fc 19 00 ba 	movh	r9,0xba
80002ff0:	12 36       	cp.w	r6,r9
80002ff2:	c0 e1       	brne	8000300e <phy_rx_func+0x206>
80002ff4:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002ff8:	90 09       	ld.sh	r9,r8[0x0]
80002ffa:	30 08       	mov	r8,0
80002ffc:	f0 09 19 00 	cp.h	r9,r8
80003000:	c0 71       	brne	8000300e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003002:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003006:	70 0c       	ld.w	r12,r8[0x0]
80003008:	f0 1f 03 2a 	mcall	80003cb0 <phy_rx_func+0xea8>
8000300c:	c0 98       	rjmp	8000301e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000300e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003012:	70 0c       	ld.w	r12,r8[0x0]
80003014:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003018:	70 0b       	ld.w	r11,r8[0x0]
8000301a:	f0 1f 03 24 	mcall	80003ca8 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000301e:	30 09       	mov	r9,0
80003020:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003024:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003026:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000302a:	11 89       	ld.ub	r9,r8[0x0]
8000302c:	30 08       	mov	r8,0
8000302e:	f0 09 18 00 	cp.b	r9,r8
80003032:	c1 31       	brne	80003058 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003034:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003038:	6c 0c       	ld.w	r12,r6[0x0]
8000303a:	f0 1f 03 1a 	mcall	80003ca0 <phy_rx_func+0xe98>
8000303e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003042:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003044:	6c 0c       	ld.w	r12,r6[0x0]
80003046:	f0 1f 03 17 	mcall	80003ca0 <phy_rx_func+0xe98>
8000304a:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000304e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003050:	30 19       	mov	r9,1
80003052:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003056:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003058:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000305c:	70 08       	ld.w	r8,r8[0x0]
8000305e:	58 28       	cp.w	r8,2
80003060:	e0 80 01 98 	breq	80003390 <phy_rx_func+0x588>
80003064:	e0 8b 00 06 	brhi	80003070 <phy_rx_func+0x268>
80003068:	58 08       	cp.w	r8,0
8000306a:	c0 b0       	breq	80003080 <phy_rx_func+0x278>
8000306c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003070:	58 38       	cp.w	r8,3
80003072:	e0 80 05 c5 	breq	80003bfc <phy_rx_func+0xdf4>
80003076:	58 48       	cp.w	r8,4
80003078:	e0 81 06 05 	brne	80003c82 <phy_rx_func+0xe7a>
8000307c:	e0 8f 02 4b 	bral	80003512 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003080:	6e 28       	ld.w	r8,r7[0x8]
80003082:	e0 6a 5a 5a 	mov	r10,23130
80003086:	ea 1a ab cd 	orh	r10,0xabcd
8000308a:	14 38       	cp.w	r8,r10
8000308c:	c0 71       	brne	8000309a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000308e:	30 09       	mov	r9,0
80003090:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003094:	91 09       	st.w	r8[0x0],r9
80003096:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000309a:	10 99       	mov	r9,r8
8000309c:	e0 19 00 00 	andl	r9,0x0
800030a0:	fc 1a ab cd 	movh	r10,0xabcd
800030a4:	14 39       	cp.w	r9,r10
800030a6:	e0 81 05 ee 	brne	80003c82 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800030aa:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800030ae:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800030b2:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800030b4:	6e 29       	ld.w	r9,r7[0x8]
800030b6:	e2 19 f0 00 	andl	r9,0xf000,COH
800030ba:	e0 49 c0 00 	cp.w	r9,49152
800030be:	e0 81 00 ce 	brne	8000325a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800030c2:	30 1a       	mov	r10,1
800030c4:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800030c8:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800030ca:	fe f9 0b f6 	ld.w	r9,pc[3062]
800030ce:	72 09       	ld.w	r9,r9[0x0]
800030d0:	58 09       	cp.w	r9,0
800030d2:	c0 71       	brne	800030e0 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030d4:	fe fc 0c 00 	ld.w	r12,pc[3072]
800030d8:	f0 1f 03 00 	mcall	80003cd8 <phy_rx_func+0xed0>
800030dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800030e0:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800030e4:	fe f9 0b f8 	ld.w	r9,pc[3064]
800030e8:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800030ea:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800030ee:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800030f2:	fe fa 0b ee 	ld.w	r10,pc[3054]
800030f6:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800030f8:	13 89       	ld.ub	r9,r9[0x0]
800030fa:	37 fa       	mov	r10,127
800030fc:	f4 09 18 00 	cp.b	r9,r10
80003100:	c6 d0       	breq	800031da <phy_rx_func+0x3d2>
80003102:	e0 8b 00 0c 	brhi	8000311a <phy_rx_func+0x312>
80003106:	31 2a       	mov	r10,18
80003108:	f4 09 18 00 	cp.b	r9,r10
8000310c:	c4 20       	breq	80003190 <phy_rx_func+0x388>
8000310e:	31 3a       	mov	r10,19
80003110:	f4 09 18 00 	cp.b	r9,r10
80003114:	e0 81 00 83 	brne	8000321a <phy_rx_func+0x412>
80003118:	c5 b8       	rjmp	800031ce <phy_rx_func+0x3c6>
8000311a:	2f 09       	sub	r9,-16
8000311c:	30 1a       	mov	r10,1
8000311e:	f4 09 18 00 	cp.b	r9,r10
80003122:	e0 8b 00 7c 	brhi	8000321a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003126:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000312a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000312e:	59 08       	cp.w	r8,16
80003130:	c0 71       	brne	8000313e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003132:	30 19       	mov	r9,1
80003134:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003138:	91 09       	st.w	r8[0x0],r9
8000313a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000313e:	e0 48 00 20 	cp.w	r8,32
80003142:	c2 11       	brne	80003184 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003144:	30 a9       	mov	r9,10
80003146:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000314a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000314c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003150:	6c 08       	ld.w	r8,r6[0x0]
80003152:	f0 0a 11 ff 	rsub	r10,r8,-1
80003156:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000315a:	2f f8       	sub	r8,-1
8000315c:	6e 0c       	ld.w	r12,r7[0x0]
8000315e:	f4 ca fe 00 	sub	r10,r10,-512
80003162:	30 0b       	mov	r11,0
80003164:	10 0c       	add	r12,r8
80003166:	f0 1f 02 e1 	mcall	80003ce8 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000316a:	30 08       	mov	r8,0
8000316c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000316e:	6e 0c       	ld.w	r12,r7[0x0]
80003170:	f0 1f 02 df 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003174:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003178:	70 0c       	ld.w	r12,r8[0x0]
8000317a:	f0 1f 02 ca 	mcall	80003ca0 <phy_rx_func+0xe98>
8000317e:	8f 0c       	st.w	r7[0x0],r12
80003180:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003184:	30 09       	mov	r9,0
80003186:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000318a:	91 09       	st.w	r8[0x0],r9
8000318c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003190:	20 48       	sub	r8,4
80003192:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003196:	93 08       	st.w	r9[0x0],r8
80003198:	58 08       	cp.w	r8,0
8000319a:	e0 80 05 74 	breq	80003c82 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000319e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800031a2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800031a6:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800031aa:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800031ac:	8e 69       	ld.sh	r9,r7[0xc]
800031ae:	fe f8 0b 46 	ld.w	r8,pc[2886]
800031b2:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800031b4:	8e 79       	ld.sh	r9,r7[0xe]
800031b6:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800031b8:	f0 1f 02 d0 	mcall	80003cf8 <phy_rx_func+0xef0>
800031bc:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800031c0:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800031c2:	30 49       	mov	r9,4
800031c4:	fe f8 0b 00 	ld.w	r8,pc[2816]
800031c8:	91 09       	st.w	r8[0x0],r9
800031ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800031ce:	30 09       	mov	r9,0
800031d0:	fe f8 0a f8 	ld.w	r8,pc[2808]
800031d4:	91 09       	st.w	r8[0x0],r9
800031d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031da:	20 48       	sub	r8,4
800031dc:	fe f9 0a f0 	ld.w	r9,pc[2800]
800031e0:	93 08       	st.w	r9[0x0],r8
800031e2:	58 08       	cp.w	r8,0
800031e4:	e0 80 05 4f 	breq	80003c82 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800031e8:	fe f8 0b 14 	ld.w	r8,pc[2836]
800031ec:	70 09       	ld.w	r9,r8[0x0]
800031ee:	8e 7b       	ld.sh	r11,r7[0xe]
800031f0:	fe fa 0b 10 	ld.w	r10,pc[2832]
800031f4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800031f8:	2f f9       	sub	r9,-1
800031fa:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800031fc:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003200:	70 09       	ld.w	r9,r8[0x0]
80003202:	20 29       	sub	r9,2
80003204:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003206:	30 29       	mov	r9,2
80003208:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000320c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000320e:	30 39       	mov	r9,3
80003210:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003214:	91 09       	st.w	r8[0x0],r9
80003216:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000321a:	30 3a       	mov	r10,3
8000321c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003220:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003222:	6e 2a       	ld.w	r10,r7[0x8]
80003224:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003228:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000322a:	6e 3a       	ld.w	r10,r7[0xc]
8000322c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000322e:	59 48       	cp.w	r8,20
80003230:	c0 61       	brne	8000323c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003232:	31 89       	mov	r9,24
80003234:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003238:	91 09       	st.w	r8[0x0],r9
8000323a:	c0 a8       	rjmp	8000324e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000323c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003240:	70 08       	ld.w	r8,r8[0x0]
80003242:	59 08       	cp.w	r8,16
80003244:	c0 51       	brne	8000324e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003246:	31 09       	mov	r9,16
80003248:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000324c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000324e:	30 49       	mov	r9,4
80003250:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003254:	91 09       	st.w	r8[0x0],r9
80003256:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000325a:	e0 49 10 00 	cp.w	r9,4096
8000325e:	5f 1a       	srne	r10
80003260:	e0 49 20 00 	cp.w	r9,8192
80003264:	5f 19       	srne	r9
80003266:	f5 e9 00 09 	and	r9,r10,r9
8000326a:	e0 81 05 0c 	brne	80003c82 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000326e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003272:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003274:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003278:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000327a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000327e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003280:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003284:	72 09       	ld.w	r9,r9[0x0]
80003286:	58 09       	cp.w	r9,0
80003288:	c0 71       	brne	80003296 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000328a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000328e:	f0 1f 02 93 	mcall	80003cd8 <phy_rx_func+0xed0>
80003292:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003296:	6e 2a       	ld.w	r10,r7[0x8]
80003298:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000329c:	58 1a       	cp.w	r10,1
8000329e:	e0 8b 00 4d 	brhi	80003338 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800032a2:	20 48       	sub	r8,4
800032a4:	fe f9 0a 28 	ld.w	r9,pc[2600]
800032a8:	93 08       	st.w	r9[0x0],r8
800032aa:	58 08       	cp.w	r8,0
800032ac:	e0 80 04 eb 	breq	80003c82 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800032b0:	8e 68       	ld.sh	r8,r7[0xc]
800032b2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800032b6:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800032ba:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800032bc:	30 09       	mov	r9,0
800032be:	f2 08 19 00 	cp.h	r8,r9
800032c2:	c0 70       	breq	800032d0 <phy_rx_func+0x4c8>
800032c4:	30 19       	mov	r9,1
800032c6:	f2 08 19 00 	cp.h	r8,r9
800032ca:	e0 81 04 dc 	brne	80003c82 <phy_rx_func+0xe7a>
800032ce:	c2 68       	rjmp	8000331a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032d0:	fe f8 0a 44 	ld.w	r8,pc[2628]
800032d4:	70 0a       	ld.w	r10,r8[0x0]
800032d6:	fe f9 09 e6 	ld.w	r9,pc[2534]
800032da:	72 09       	ld.w	r9,r9[0x0]
800032dc:	8e 7b       	ld.sh	r11,r7[0xe]
800032de:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800032e2:	70 09       	ld.w	r9,r8[0x0]
800032e4:	2f f9       	sub	r9,-1
800032e6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032e8:	e0 49 00 ff 	cp.w	r9,255
800032ec:	e0 88 00 11 	brls	8000330e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800032f0:	30 09       	mov	r9,0
800032f2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800032f4:	fe f7 09 c8 	ld.w	r7,pc[2504]
800032f8:	6e 0c       	ld.w	r12,r7[0x0]
800032fa:	f0 1f 02 7d 	mcall	80003cec <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800032fe:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003302:	70 0c       	ld.w	r12,r8[0x0]
80003304:	f0 1f 02 67 	mcall	80003ca0 <phy_rx_func+0xe98>
80003308:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000330a:	e0 80 04 bc 	breq	80003c82 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000330e:	30 29       	mov	r9,2
80003310:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003314:	91 09       	st.w	r8[0x0],r9
80003316:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000331a:	8e 79       	ld.sh	r9,r7[0xe]
8000331c:	30 38       	mov	r8,3
8000331e:	f0 09 19 00 	cp.h	r9,r8
80003322:	c0 51       	brne	8000332c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003324:	30 19       	mov	r9,1
80003326:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000332a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000332c:	30 29       	mov	r9,2
8000332e:	fe f8 09 96 	ld.w	r8,pc[2454]
80003332:	91 09       	st.w	r8[0x0],r9
80003334:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003338:	58 18       	cp.w	r8,1
8000333a:	e0 88 04 a4 	brls	80003c82 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000333e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003342:	70 0a       	ld.w	r10,r8[0x0]
80003344:	6e 3b       	ld.w	r11,r7[0xc]
80003346:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000334a:	70 09       	ld.w	r9,r8[0x0]
8000334c:	2f f9       	sub	r9,-1
8000334e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003350:	e0 49 00 ff 	cp.w	r9,255
80003354:	e0 88 00 11 	brls	80003376 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003358:	30 09       	mov	r9,0
8000335a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000335c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003360:	6e 0c       	ld.w	r12,r7[0x0]
80003362:	f0 1f 02 63 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003366:	fe f8 09 52 	ld.w	r8,pc[2386]
8000336a:	70 0c       	ld.w	r12,r8[0x0]
8000336c:	f0 1f 02 4d 	mcall	80003ca0 <phy_rx_func+0xe98>
80003370:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003372:	e0 80 04 88 	breq	80003c82 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003376:	fe f9 09 56 	ld.w	r9,pc[2390]
8000337a:	72 08       	ld.w	r8,r9[0x0]
8000337c:	20 28       	sub	r8,2
8000337e:	93 08       	st.w	r9[0x0],r8
80003380:	e0 80 04 81 	breq	80003c82 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003384:	30 29       	mov	r9,2
80003386:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000338a:	91 09       	st.w	r8[0x0],r9
8000338c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003390:	fe f8 09 84 	ld.w	r8,pc[2436]
80003394:	70 0a       	ld.w	r10,r8[0x0]
80003396:	fe f9 09 26 	ld.w	r9,pc[2342]
8000339a:	72 09       	ld.w	r9,r9[0x0]
8000339c:	8e 4b       	ld.sh	r11,r7[0x8]
8000339e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800033a2:	70 09       	ld.w	r9,r8[0x0]
800033a4:	2f f9       	sub	r9,-1
800033a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033a8:	e0 49 00 ff 	cp.w	r9,255
800033ac:	e0 88 00 16 	brls	800033d8 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800033b0:	30 09       	mov	r9,0
800033b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033b4:	fe f6 09 08 	ld.w	r6,pc[2312]
800033b8:	6c 0c       	ld.w	r12,r6[0x0]
800033ba:	f0 1f 02 4d 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033be:	fe f8 08 fa 	ld.w	r8,pc[2298]
800033c2:	70 0c       	ld.w	r12,r8[0x0]
800033c4:	f0 1f 02 37 	mcall	80003ca0 <phy_rx_func+0xe98>
800033c8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033ca:	c0 71       	brne	800033d8 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800033cc:	30 09       	mov	r9,0
800033ce:	fe f8 08 f6 	ld.w	r8,pc[2294]
800033d2:	91 09       	st.w	r8[0x0],r9
800033d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800033d8:	fe f9 08 f4 	ld.w	r9,pc[2292]
800033dc:	72 08       	ld.w	r8,r9[0x0]
800033de:	20 28       	sub	r8,2
800033e0:	93 08       	st.w	r9[0x0],r8
800033e2:	c0 71       	brne	800033f0 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800033e4:	30 09       	mov	r9,0
800033e6:	fe f8 08 de 	ld.w	r8,pc[2270]
800033ea:	91 09       	st.w	r8[0x0],r9
800033ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800033f0:	fe f8 09 24 	ld.w	r8,pc[2340]
800033f4:	70 0a       	ld.w	r10,r8[0x0]
800033f6:	fe f9 08 c6 	ld.w	r9,pc[2246]
800033fa:	72 09       	ld.w	r9,r9[0x0]
800033fc:	8e 5b       	ld.sh	r11,r7[0xa]
800033fe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003402:	70 09       	ld.w	r9,r8[0x0]
80003404:	2f f9       	sub	r9,-1
80003406:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003408:	e0 49 00 ff 	cp.w	r9,255
8000340c:	e0 88 00 16 	brls	80003438 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003410:	30 09       	mov	r9,0
80003412:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003414:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003418:	6c 0c       	ld.w	r12,r6[0x0]
8000341a:	f0 1f 02 35 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000341e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003422:	70 0c       	ld.w	r12,r8[0x0]
80003424:	f0 1f 02 1f 	mcall	80003ca0 <phy_rx_func+0xe98>
80003428:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000342a:	c0 71       	brne	80003438 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000342c:	30 09       	mov	r9,0
8000342e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003432:	91 09       	st.w	r8[0x0],r9
80003434:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003438:	fe f9 08 94 	ld.w	r9,pc[2196]
8000343c:	72 08       	ld.w	r8,r9[0x0]
8000343e:	20 28       	sub	r8,2
80003440:	93 08       	st.w	r9[0x0],r8
80003442:	c0 71       	brne	80003450 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003444:	30 09       	mov	r9,0
80003446:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000344a:	91 09       	st.w	r8[0x0],r9
8000344c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003450:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003454:	70 0a       	ld.w	r10,r8[0x0]
80003456:	fe f9 08 66 	ld.w	r9,pc[2150]
8000345a:	72 09       	ld.w	r9,r9[0x0]
8000345c:	8e 6b       	ld.sh	r11,r7[0xc]
8000345e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003462:	70 09       	ld.w	r9,r8[0x0]
80003464:	2f f9       	sub	r9,-1
80003466:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003468:	e0 49 00 ff 	cp.w	r9,255
8000346c:	e0 88 00 16 	brls	80003498 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003470:	30 09       	mov	r9,0
80003472:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003474:	fe f6 08 48 	ld.w	r6,pc[2120]
80003478:	6c 0c       	ld.w	r12,r6[0x0]
8000347a:	f0 1f 02 1d 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000347e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003482:	70 0c       	ld.w	r12,r8[0x0]
80003484:	f0 1f 02 07 	mcall	80003ca0 <phy_rx_func+0xe98>
80003488:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000348a:	c0 71       	brne	80003498 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
8000348c:	30 09       	mov	r9,0
8000348e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003492:	91 09       	st.w	r8[0x0],r9
80003494:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003498:	fe f9 08 34 	ld.w	r9,pc[2100]
8000349c:	72 08       	ld.w	r8,r9[0x0]
8000349e:	20 28       	sub	r8,2
800034a0:	93 08       	st.w	r9[0x0],r8
800034a2:	c0 71       	brne	800034b0 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800034a4:	30 09       	mov	r9,0
800034a6:	fe f8 08 1e 	ld.w	r8,pc[2078]
800034aa:	91 09       	st.w	r8[0x0],r9
800034ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034b0:	fe f8 08 64 	ld.w	r8,pc[2148]
800034b4:	70 0a       	ld.w	r10,r8[0x0]
800034b6:	fe f9 08 06 	ld.w	r9,pc[2054]
800034ba:	72 09       	ld.w	r9,r9[0x0]
800034bc:	8e 7b       	ld.sh	r11,r7[0xe]
800034be:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034c2:	70 09       	ld.w	r9,r8[0x0]
800034c4:	2f f9       	sub	r9,-1
800034c6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034c8:	e0 49 00 ff 	cp.w	r9,255
800034cc:	e0 88 00 16 	brls	800034f8 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800034d0:	30 09       	mov	r9,0
800034d2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034d4:	fe f7 07 e8 	ld.w	r7,pc[2024]
800034d8:	6e 0c       	ld.w	r12,r7[0x0]
800034da:	f0 1f 02 05 	mcall	80003cec <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034de:	fe f8 07 da 	ld.w	r8,pc[2010]
800034e2:	70 0c       	ld.w	r12,r8[0x0]
800034e4:	f0 1f 01 ef 	mcall	80003ca0 <phy_rx_func+0xe98>
800034e8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800034ea:	c0 71       	brne	800034f8 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800034ec:	30 09       	mov	r9,0
800034ee:	fe f8 07 d6 	ld.w	r8,pc[2006]
800034f2:	91 09       	st.w	r8[0x0],r9
800034f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034f8:	fe f9 07 d4 	ld.w	r9,pc[2004]
800034fc:	72 08       	ld.w	r8,r9[0x0]
800034fe:	20 28       	sub	r8,2
80003500:	93 08       	st.w	r9[0x0],r8
80003502:	e0 81 03 c0 	brne	80003c82 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003506:	30 09       	mov	r9,0
80003508:	fe f8 07 bc 	ld.w	r8,pc[1980]
8000350c:	91 09       	st.w	r8[0x0],r9
8000350e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003512:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003516:	11 89       	ld.ub	r9,r8[0x0]
80003518:	31 28       	mov	r8,18
8000351a:	f0 09 18 00 	cp.b	r9,r8
8000351e:	e0 81 01 4c 	brne	800037b6 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003522:	ef 39 00 09 	ld.ub	r9,r7[9]
80003526:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000352a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000352c:	11 89       	ld.ub	r9,r8[0x0]
8000352e:	3f 28       	mov	r8,-14
80003530:	f0 09 18 00 	cp.b	r9,r8
80003534:	e0 81 01 3b 	brne	800037aa <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003538:	30 19       	mov	r9,1
8000353a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000353e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003540:	6e 29       	ld.w	r9,r7[0x8]
80003542:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003546:	fe f8 07 86 	ld.w	r8,pc[1926]
8000354a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000354c:	8e 59       	ld.sh	r9,r7[0xa]
8000354e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003552:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003554:	8e 69       	ld.sh	r9,r7[0xc]
80003556:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003558:	8e 79       	ld.sh	r9,r7[0xe]
8000355a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000355c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003560:	fe f9 07 60 	ld.w	r9,pc[1888]
80003564:	72 0a       	ld.w	r10,r9[0x0]
80003566:	70 09       	ld.w	r9,r8[0x0]
80003568:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000356c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003570:	70 09       	ld.w	r9,r8[0x0]
80003572:	2f f9       	sub	r9,-1
80003574:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003576:	e0 49 01 ff 	cp.w	r9,511
8000357a:	e0 88 00 16 	brls	800035a6 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000357e:	30 09       	mov	r9,0
80003580:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003582:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003586:	6c 0c       	ld.w	r12,r6[0x0]
80003588:	f0 1f 01 d9 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000358c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003590:	70 0c       	ld.w	r12,r8[0x0]
80003592:	f0 1f 01 c4 	mcall	80003ca0 <phy_rx_func+0xe98>
80003596:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003598:	c0 71       	brne	800035a6 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000359a:	30 09       	mov	r9,0
8000359c:	fe f8 07 28 	ld.w	r8,pc[1832]
800035a0:	91 09       	st.w	r8[0x0],r9
800035a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035a6:	fe f9 07 26 	ld.w	r9,pc[1830]
800035aa:	72 08       	ld.w	r8,r9[0x0]
800035ac:	20 18       	sub	r8,1
800035ae:	93 08       	st.w	r9[0x0],r8
800035b0:	c0 71       	brne	800035be <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800035b2:	30 09       	mov	r9,0
800035b4:	fe f8 07 10 	ld.w	r8,pc[1808]
800035b8:	91 09       	st.w	r8[0x0],r9
800035ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800035be:	fe f8 07 26 	ld.w	r8,pc[1830]
800035c2:	fe f9 06 fe 	ld.w	r9,pc[1790]
800035c6:	72 0a       	ld.w	r10,r9[0x0]
800035c8:	70 09       	ld.w	r9,r8[0x0]
800035ca:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800035ce:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035d2:	70 09       	ld.w	r9,r8[0x0]
800035d4:	2f f9       	sub	r9,-1
800035d6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035d8:	e0 49 01 ff 	cp.w	r9,511
800035dc:	e0 88 00 16 	brls	80003608 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800035e0:	30 09       	mov	r9,0
800035e2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035e4:	fe f6 06 dc 	ld.w	r6,pc[1756]
800035e8:	6c 0c       	ld.w	r12,r6[0x0]
800035ea:	f0 1f 01 c1 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ee:	fe f8 06 ca 	ld.w	r8,pc[1738]
800035f2:	70 0c       	ld.w	r12,r8[0x0]
800035f4:	f0 1f 01 ab 	mcall	80003ca0 <phy_rx_func+0xe98>
800035f8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035fa:	c0 71       	brne	80003608 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800035fc:	30 09       	mov	r9,0
800035fe:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003602:	91 09       	st.w	r8[0x0],r9
80003604:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003608:	fe f9 06 c4 	ld.w	r9,pc[1732]
8000360c:	72 08       	ld.w	r8,r9[0x0]
8000360e:	20 18       	sub	r8,1
80003610:	93 08       	st.w	r9[0x0],r8
80003612:	c0 71       	brne	80003620 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003614:	30 09       	mov	r9,0
80003616:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000361a:	91 09       	st.w	r8[0x0],r9
8000361c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003620:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003624:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003628:	72 0a       	ld.w	r10,r9[0x0]
8000362a:	70 09       	ld.w	r9,r8[0x0]
8000362c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003630:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003634:	70 09       	ld.w	r9,r8[0x0]
80003636:	2f f9       	sub	r9,-1
80003638:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000363a:	e0 49 01 ff 	cp.w	r9,511
8000363e:	e0 88 00 16 	brls	8000366a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003642:	30 09       	mov	r9,0
80003644:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003646:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000364a:	6c 0c       	ld.w	r12,r6[0x0]
8000364c:	f0 1f 01 a8 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003650:	fe f8 06 68 	ld.w	r8,pc[1640]
80003654:	70 0c       	ld.w	r12,r8[0x0]
80003656:	f0 1f 01 93 	mcall	80003ca0 <phy_rx_func+0xe98>
8000365a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000365c:	c0 71       	brne	8000366a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000365e:	30 09       	mov	r9,0
80003660:	fe f8 06 64 	ld.w	r8,pc[1636]
80003664:	91 09       	st.w	r8[0x0],r9
80003666:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000366a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000366e:	72 08       	ld.w	r8,r9[0x0]
80003670:	20 18       	sub	r8,1
80003672:	93 08       	st.w	r9[0x0],r8
80003674:	c0 71       	brne	80003682 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003676:	30 09       	mov	r9,0
80003678:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000367c:	91 09       	st.w	r8[0x0],r9
8000367e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003682:	fe f8 06 62 	ld.w	r8,pc[1634]
80003686:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000368a:	72 0a       	ld.w	r10,r9[0x0]
8000368c:	70 09       	ld.w	r9,r8[0x0]
8000368e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003692:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003696:	70 09       	ld.w	r9,r8[0x0]
80003698:	2f f9       	sub	r9,-1
8000369a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000369c:	e0 49 01 ff 	cp.w	r9,511
800036a0:	e0 88 00 16 	brls	800036cc <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800036a4:	30 09       	mov	r9,0
800036a6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036a8:	fe f6 06 18 	ld.w	r6,pc[1560]
800036ac:	6c 0c       	ld.w	r12,r6[0x0]
800036ae:	f0 1f 01 90 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036b2:	fe f8 06 06 	ld.w	r8,pc[1542]
800036b6:	70 0c       	ld.w	r12,r8[0x0]
800036b8:	f0 1f 01 7a 	mcall	80003ca0 <phy_rx_func+0xe98>
800036bc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036be:	c0 71       	brne	800036cc <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800036c0:	30 09       	mov	r9,0
800036c2:	fe f8 06 02 	ld.w	r8,pc[1538]
800036c6:	91 09       	st.w	r8[0x0],r9
800036c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036cc:	fe f9 06 00 	ld.w	r9,pc[1536]
800036d0:	72 08       	ld.w	r8,r9[0x0]
800036d2:	20 18       	sub	r8,1
800036d4:	93 08       	st.w	r9[0x0],r8
800036d6:	c0 71       	brne	800036e4 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800036d8:	30 09       	mov	r9,0
800036da:	fe f8 05 ea 	ld.w	r8,pc[1514]
800036de:	91 09       	st.w	r8[0x0],r9
800036e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036e4:	fe f8 06 00 	ld.w	r8,pc[1536]
800036e8:	fe f9 05 d8 	ld.w	r9,pc[1496]
800036ec:	72 0a       	ld.w	r10,r9[0x0]
800036ee:	70 09       	ld.w	r9,r8[0x0]
800036f0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036f4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036f8:	70 09       	ld.w	r9,r8[0x0]
800036fa:	2f f9       	sub	r9,-1
800036fc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036fe:	e0 49 01 ff 	cp.w	r9,511
80003702:	e0 88 00 16 	brls	8000372e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003706:	30 09       	mov	r9,0
80003708:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000370a:	fe f6 05 b6 	ld.w	r6,pc[1462]
8000370e:	6c 0c       	ld.w	r12,r6[0x0]
80003710:	f0 1f 01 77 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003714:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003718:	70 0c       	ld.w	r12,r8[0x0]
8000371a:	f0 1f 01 62 	mcall	80003ca0 <phy_rx_func+0xe98>
8000371e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003720:	c0 71       	brne	8000372e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003722:	30 09       	mov	r9,0
80003724:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003728:	91 09       	st.w	r8[0x0],r9
8000372a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000372e:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003732:	72 08       	ld.w	r8,r9[0x0]
80003734:	20 18       	sub	r8,1
80003736:	93 08       	st.w	r9[0x0],r8
80003738:	c0 71       	brne	80003746 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000373a:	30 09       	mov	r9,0
8000373c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003740:	91 09       	st.w	r8[0x0],r9
80003742:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003746:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000374a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000374e:	72 0a       	ld.w	r10,r9[0x0]
80003750:	70 09       	ld.w	r9,r8[0x0]
80003752:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003756:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000375a:	70 09       	ld.w	r9,r8[0x0]
8000375c:	2f f9       	sub	r9,-1
8000375e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003760:	e0 49 01 ff 	cp.w	r9,511
80003764:	e0 88 00 16 	brls	80003790 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003768:	30 09       	mov	r9,0
8000376a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000376c:	fe f7 05 54 	ld.w	r7,pc[1364]
80003770:	6e 0c       	ld.w	r12,r7[0x0]
80003772:	f0 1f 01 5f 	mcall	80003cec <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003776:	fe f8 05 42 	ld.w	r8,pc[1346]
8000377a:	70 0c       	ld.w	r12,r8[0x0]
8000377c:	f0 1f 01 49 	mcall	80003ca0 <phy_rx_func+0xe98>
80003780:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003782:	c0 71       	brne	80003790 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003784:	30 09       	mov	r9,0
80003786:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000378a:	91 09       	st.w	r8[0x0],r9
8000378c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003790:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003794:	72 08       	ld.w	r8,r9[0x0]
80003796:	20 18       	sub	r8,1
80003798:	93 08       	st.w	r9[0x0],r8
8000379a:	e0 81 02 74 	brne	80003c82 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000379e:	30 09       	mov	r9,0
800037a0:	fe f8 05 24 	ld.w	r8,pc[1316]
800037a4:	91 09       	st.w	r8[0x0],r9
800037a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800037aa:	30 09       	mov	r9,0
800037ac:	fe f8 05 18 	ld.w	r8,pc[1304]
800037b0:	91 09       	st.w	r8[0x0],r9
800037b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800037b6:	fe f8 05 26 	ld.w	r8,pc[1318]
800037ba:	11 89       	ld.ub	r9,r8[0x0]
800037bc:	3f 28       	mov	r8,-14
800037be:	f0 09 18 00 	cp.b	r9,r8
800037c2:	c4 31       	brne	80003848 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800037c4:	8e 49       	ld.sh	r9,r7[0x8]
800037c6:	fe f8 05 56 	ld.w	r8,pc[1366]
800037ca:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800037cc:	fe f8 05 18 	ld.w	r8,pc[1304]
800037d0:	fe f9 04 f0 	ld.w	r9,pc[1264]
800037d4:	72 0a       	ld.w	r10,r9[0x0]
800037d6:	70 09       	ld.w	r9,r8[0x0]
800037d8:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037dc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037e0:	70 09       	ld.w	r9,r8[0x0]
800037e2:	2f f9       	sub	r9,-1
800037e4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037e6:	e0 49 01 ff 	cp.w	r9,511
800037ea:	e0 88 00 16 	brls	80003816 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037ee:	30 09       	mov	r9,0
800037f0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037f2:	fe f7 04 ce 	ld.w	r7,pc[1230]
800037f6:	6e 0c       	ld.w	r12,r7[0x0]
800037f8:	f0 1f 01 3d 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037fc:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003800:	70 0c       	ld.w	r12,r8[0x0]
80003802:	f0 1f 01 28 	mcall	80003ca0 <phy_rx_func+0xe98>
80003806:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003808:	c0 71       	brne	80003816 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000380a:	30 09       	mov	r9,0
8000380c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003810:	91 09       	st.w	r8[0x0],r9
80003812:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003816:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000381a:	72 08       	ld.w	r8,r9[0x0]
8000381c:	20 18       	sub	r8,1
8000381e:	93 08       	st.w	r9[0x0],r8
80003820:	c0 71       	brne	8000382e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003822:	30 09       	mov	r9,0
80003824:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003828:	91 09       	st.w	r8[0x0],r9
8000382a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000382e:	20 18       	sub	r8,1
80003830:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003834:	93 08       	st.w	r9[0x0],r8
80003836:	58 08       	cp.w	r8,0
80003838:	e0 81 02 25 	brne	80003c82 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
8000383c:	30 09       	mov	r9,0
8000383e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003842:	91 09       	st.w	r8[0x0],r9
80003844:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003848:	fe f8 04 94 	ld.w	r8,pc[1172]
8000384c:	11 89       	ld.ub	r9,r8[0x0]
8000384e:	3f 38       	mov	r8,-13
80003850:	f0 09 18 00 	cp.b	r9,r8
80003854:	e0 81 01 0c 	brne	80003a6c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003858:	8e 49       	ld.sh	r9,r7[0x8]
8000385a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000385e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003860:	8e 59       	ld.sh	r9,r7[0xa]
80003862:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003864:	8e 69       	ld.sh	r9,r7[0xc]
80003866:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003868:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000386c:	fe f9 04 54 	ld.w	r9,pc[1108]
80003870:	72 0a       	ld.w	r10,r9[0x0]
80003872:	70 09       	ld.w	r9,r8[0x0]
80003874:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003878:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000387c:	70 09       	ld.w	r9,r8[0x0]
8000387e:	2f f9       	sub	r9,-1
80003880:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003882:	e0 49 01 ff 	cp.w	r9,511
80003886:	e0 88 00 16 	brls	800038b2 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000388a:	30 09       	mov	r9,0
8000388c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000388e:	fe f6 04 32 	ld.w	r6,pc[1074]
80003892:	6c 0c       	ld.w	r12,r6[0x0]
80003894:	f0 1f 01 16 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003898:	fe f8 04 20 	ld.w	r8,pc[1056]
8000389c:	70 0c       	ld.w	r12,r8[0x0]
8000389e:	f0 1f 01 01 	mcall	80003ca0 <phy_rx_func+0xe98>
800038a2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038a4:	c0 71       	brne	800038b2 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800038a6:	30 09       	mov	r9,0
800038a8:	fe f8 04 1c 	ld.w	r8,pc[1052]
800038ac:	91 09       	st.w	r8[0x0],r9
800038ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038b2:	fe f9 04 1a 	ld.w	r9,pc[1050]
800038b6:	72 08       	ld.w	r8,r9[0x0]
800038b8:	20 18       	sub	r8,1
800038ba:	93 08       	st.w	r9[0x0],r8
800038bc:	c0 71       	brne	800038ca <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800038be:	30 09       	mov	r9,0
800038c0:	fe f8 04 04 	ld.w	r8,pc[1028]
800038c4:	91 09       	st.w	r8[0x0],r9
800038c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800038ca:	fe f8 04 1a 	ld.w	r8,pc[1050]
800038ce:	fe f9 03 f2 	ld.w	r9,pc[1010]
800038d2:	72 0a       	ld.w	r10,r9[0x0]
800038d4:	70 09       	ld.w	r9,r8[0x0]
800038d6:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038da:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038de:	70 09       	ld.w	r9,r8[0x0]
800038e0:	2f f9       	sub	r9,-1
800038e2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038e4:	e0 49 01 ff 	cp.w	r9,511
800038e8:	e0 88 00 16 	brls	80003914 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800038ec:	30 09       	mov	r9,0
800038ee:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038f0:	fe f6 03 d0 	ld.w	r6,pc[976]
800038f4:	6c 0c       	ld.w	r12,r6[0x0]
800038f6:	f0 1f 00 fe 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038fa:	fe f8 03 be 	ld.w	r8,pc[958]
800038fe:	70 0c       	ld.w	r12,r8[0x0]
80003900:	f0 1f 00 e8 	mcall	80003ca0 <phy_rx_func+0xe98>
80003904:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003906:	c0 71       	brne	80003914 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003908:	30 09       	mov	r9,0
8000390a:	fe f8 03 ba 	ld.w	r8,pc[954]
8000390e:	91 09       	st.w	r8[0x0],r9
80003910:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003914:	fe f9 03 b8 	ld.w	r9,pc[952]
80003918:	72 08       	ld.w	r8,r9[0x0]
8000391a:	20 18       	sub	r8,1
8000391c:	93 08       	st.w	r9[0x0],r8
8000391e:	c0 71       	brne	8000392c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003920:	30 09       	mov	r9,0
80003922:	fe f8 03 a2 	ld.w	r8,pc[930]
80003926:	91 09       	st.w	r8[0x0],r9
80003928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
8000392c:	fe f8 03 b8 	ld.w	r8,pc[952]
80003930:	fe f9 03 90 	ld.w	r9,pc[912]
80003934:	72 0a       	ld.w	r10,r9[0x0]
80003936:	70 09       	ld.w	r9,r8[0x0]
80003938:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000393c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003940:	70 09       	ld.w	r9,r8[0x0]
80003942:	2f f9       	sub	r9,-1
80003944:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003946:	e0 49 01 ff 	cp.w	r9,511
8000394a:	e0 88 00 16 	brls	80003976 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000394e:	30 09       	mov	r9,0
80003950:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003952:	fe f6 03 6e 	ld.w	r6,pc[878]
80003956:	6c 0c       	ld.w	r12,r6[0x0]
80003958:	f0 1f 00 e5 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000395c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003960:	70 0c       	ld.w	r12,r8[0x0]
80003962:	f0 1f 00 d0 	mcall	80003ca0 <phy_rx_func+0xe98>
80003966:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003968:	c0 71       	brne	80003976 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000396a:	30 09       	mov	r9,0
8000396c:	fe f8 03 58 	ld.w	r8,pc[856]
80003970:	91 09       	st.w	r8[0x0],r9
80003972:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003976:	fe f9 03 56 	ld.w	r9,pc[854]
8000397a:	72 08       	ld.w	r8,r9[0x0]
8000397c:	20 18       	sub	r8,1
8000397e:	93 08       	st.w	r9[0x0],r8
80003980:	c0 71       	brne	8000398e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003982:	30 09       	mov	r9,0
80003984:	fe f8 03 40 	ld.w	r8,pc[832]
80003988:	91 09       	st.w	r8[0x0],r9
8000398a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000398e:	fe f8 03 56 	ld.w	r8,pc[854]
80003992:	fe f9 03 2e 	ld.w	r9,pc[814]
80003996:	72 0a       	ld.w	r10,r9[0x0]
80003998:	70 09       	ld.w	r9,r8[0x0]
8000399a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000399e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039a2:	70 09       	ld.w	r9,r8[0x0]
800039a4:	2f f9       	sub	r9,-1
800039a6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039a8:	e0 49 01 ff 	cp.w	r9,511
800039ac:	e0 88 00 16 	brls	800039d8 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800039b0:	30 09       	mov	r9,0
800039b2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039b4:	fe f6 03 0c 	ld.w	r6,pc[780]
800039b8:	6c 0c       	ld.w	r12,r6[0x0]
800039ba:	f0 1f 00 cd 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039be:	fe f8 02 fa 	ld.w	r8,pc[762]
800039c2:	70 0c       	ld.w	r12,r8[0x0]
800039c4:	f0 1f 00 b7 	mcall	80003ca0 <phy_rx_func+0xe98>
800039c8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039ca:	c0 71       	brne	800039d8 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800039cc:	30 09       	mov	r9,0
800039ce:	fe f8 02 f6 	ld.w	r8,pc[758]
800039d2:	91 09       	st.w	r8[0x0],r9
800039d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039d8:	fe f9 02 f4 	ld.w	r9,pc[756]
800039dc:	72 08       	ld.w	r8,r9[0x0]
800039de:	20 18       	sub	r8,1
800039e0:	93 08       	st.w	r9[0x0],r8
800039e2:	c0 71       	brne	800039f0 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800039e4:	30 09       	mov	r9,0
800039e6:	fe f8 02 de 	ld.w	r8,pc[734]
800039ea:	91 09       	st.w	r8[0x0],r9
800039ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039f0:	fe f8 02 f4 	ld.w	r8,pc[756]
800039f4:	fe f9 02 cc 	ld.w	r9,pc[716]
800039f8:	72 0a       	ld.w	r10,r9[0x0]
800039fa:	70 09       	ld.w	r9,r8[0x0]
800039fc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a00:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a04:	70 09       	ld.w	r9,r8[0x0]
80003a06:	2f f9       	sub	r9,-1
80003a08:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a0a:	e0 49 01 ff 	cp.w	r9,511
80003a0e:	e0 88 00 16 	brls	80003a3a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a12:	30 09       	mov	r9,0
80003a14:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a16:	fe f7 02 aa 	ld.w	r7,pc[682]
80003a1a:	6e 0c       	ld.w	r12,r7[0x0]
80003a1c:	f0 1f 00 b4 	mcall	80003cec <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a20:	fe f8 02 98 	ld.w	r8,pc[664]
80003a24:	70 0c       	ld.w	r12,r8[0x0]
80003a26:	f0 1f 00 9f 	mcall	80003ca0 <phy_rx_func+0xe98>
80003a2a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a2c:	c0 71       	brne	80003a3a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a2e:	30 09       	mov	r9,0
80003a30:	fe f8 02 94 	ld.w	r8,pc[660]
80003a34:	91 09       	st.w	r8[0x0],r9
80003a36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a3a:	fe f9 02 92 	ld.w	r9,pc[658]
80003a3e:	72 08       	ld.w	r8,r9[0x0]
80003a40:	20 18       	sub	r8,1
80003a42:	93 08       	st.w	r9[0x0],r8
80003a44:	c0 71       	brne	80003a52 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a46:	30 09       	mov	r9,0
80003a48:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a4c:	91 09       	st.w	r8[0x0],r9
80003a4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a52:	20 18       	sub	r8,1
80003a54:	fe f9 02 78 	ld.w	r9,pc[632]
80003a58:	93 08       	st.w	r9[0x0],r8
80003a5a:	58 08       	cp.w	r8,0
80003a5c:	e0 81 01 13 	brne	80003c82 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a60:	30 09       	mov	r9,0
80003a62:	fe f8 02 62 	ld.w	r8,pc[610]
80003a66:	91 09       	st.w	r8[0x0],r9
80003a68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a6c:	fe f8 02 70 	ld.w	r8,pc[624]
80003a70:	11 89       	ld.ub	r9,r8[0x0]
80003a72:	30 48       	mov	r8,4
80003a74:	f0 09 18 00 	cp.b	r9,r8
80003a78:	c0 80       	breq	80003a88 <phy_rx_func+0xc80>
80003a7a:	fe f8 02 62 	ld.w	r8,pc[610]
80003a7e:	11 89       	ld.ub	r9,r8[0x0]
80003a80:	30 38       	mov	r8,3
80003a82:	f0 09 18 00 	cp.b	r9,r8
80003a86:	c1 41       	brne	80003aae <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a88:	6e 29       	ld.w	r9,r7[0x8]
80003a8a:	fe f8 02 7a 	ld.w	r8,pc[634]
80003a8e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a90:	6e 39       	ld.w	r9,r7[0xc]
80003a92:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a94:	fe f9 02 38 	ld.w	r9,pc[568]
80003a98:	72 08       	ld.w	r8,r9[0x0]
80003a9a:	20 88       	sub	r8,8
80003a9c:	93 08       	st.w	r9[0x0],r8
80003a9e:	e0 81 00 f2 	brne	80003c82 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003aa2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003aa4:	fe f9 02 20 	ld.w	r9,pc[544]
80003aa8:	93 08       	st.w	r9[0x0],r8
80003aaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003aae:	fe f8 02 2e 	ld.w	r8,pc[558]
80003ab2:	11 89       	ld.ub	r9,r8[0x0]
80003ab4:	31 38       	mov	r8,19
80003ab6:	f0 09 18 00 	cp.b	r9,r8
80003aba:	e0 81 00 9c 	brne	80003bf2 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003abe:	fe f8 02 62 	ld.w	r8,pc[610]
80003ac2:	11 88       	ld.ub	r8,r8[0x0]
80003ac4:	30 c9       	mov	r9,12
80003ac6:	f2 08 18 00 	cp.b	r8,r9
80003aca:	e0 81 00 7b 	brne	80003bc0 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003ace:	8e 49       	ld.sh	r9,r7[0x8]
80003ad0:	fe f8 02 54 	ld.w	r8,pc[596]
80003ad4:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003ad8:	30 09       	mov	r9,0
80003ada:	fe f8 02 46 	ld.w	r8,pc[582]
80003ade:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ae0:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003ae4:	3f 38       	mov	r8,-13
80003ae6:	f0 09 18 00 	cp.b	r9,r8
80003aea:	c6 61       	brne	80003bb6 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003aec:	10 99       	mov	r9,r8
80003aee:	4f c8       	lddpc	r8,80003cdc <phy_rx_func+0xed4>
80003af0:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003af2:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003af6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003afa:	4f 58       	lddpc	r8,80003ccc <phy_rx_func+0xec4>
80003afc:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003afe:	30 19       	mov	r9,1
80003b00:	fe f8 02 0c 	ld.w	r8,pc[524]
80003b04:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003b06:	8e 79       	ld.sh	r9,r7[0xe]
80003b08:	fe f8 02 14 	ld.w	r8,pc[532]
80003b0c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003b0e:	4f 68       	lddpc	r8,80003ce4 <phy_rx_func+0xedc>
80003b10:	4e c9       	lddpc	r9,80003cc0 <phy_rx_func+0xeb8>
80003b12:	72 0a       	ld.w	r10,r9[0x0]
80003b14:	70 09       	ld.w	r9,r8[0x0]
80003b16:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b1a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b1e:	70 09       	ld.w	r9,r8[0x0]
80003b20:	2f f9       	sub	r9,-1
80003b22:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b24:	e0 49 01 ff 	cp.w	r9,511
80003b28:	e0 88 00 13 	brls	80003b4e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b2c:	30 09       	mov	r9,0
80003b2e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b30:	4e 46       	lddpc	r6,80003cc0 <phy_rx_func+0xeb8>
80003b32:	6c 0c       	ld.w	r12,r6[0x0]
80003b34:	f0 1f 00 6e 	mcall	80003cec <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b38:	4e 08       	lddpc	r8,80003cb8 <phy_rx_func+0xeb0>
80003b3a:	70 0c       	ld.w	r12,r8[0x0]
80003b3c:	f0 1f 00 59 	mcall	80003ca0 <phy_rx_func+0xe98>
80003b40:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b42:	c0 61       	brne	80003b4e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b44:	30 09       	mov	r9,0
80003b46:	4e 08       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b48:	91 09       	st.w	r8[0x0],r9
80003b4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b4e:	4e 09       	lddpc	r9,80003ccc <phy_rx_func+0xec4>
80003b50:	72 08       	ld.w	r8,r9[0x0]
80003b52:	20 18       	sub	r8,1
80003b54:	93 08       	st.w	r9[0x0],r8
80003b56:	c0 61       	brne	80003b62 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b58:	30 09       	mov	r9,0
80003b5a:	4d b8       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b5c:	91 09       	st.w	r8[0x0],r9
80003b5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b62:	4e 18       	lddpc	r8,80003ce4 <phy_rx_func+0xedc>
80003b64:	4d 79       	lddpc	r9,80003cc0 <phy_rx_func+0xeb8>
80003b66:	72 0a       	ld.w	r10,r9[0x0]
80003b68:	70 09       	ld.w	r9,r8[0x0]
80003b6a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b6e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b72:	70 09       	ld.w	r9,r8[0x0]
80003b74:	2f f9       	sub	r9,-1
80003b76:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b78:	e0 49 01 ff 	cp.w	r9,511
80003b7c:	e0 88 00 13 	brls	80003ba2 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b80:	30 09       	mov	r9,0
80003b82:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b84:	4c f7       	lddpc	r7,80003cc0 <phy_rx_func+0xeb8>
80003b86:	6e 0c       	ld.w	r12,r7[0x0]
80003b88:	f0 1f 00 59 	mcall	80003cec <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b8c:	4c b8       	lddpc	r8,80003cb8 <phy_rx_func+0xeb0>
80003b8e:	70 0c       	ld.w	r12,r8[0x0]
80003b90:	f0 1f 00 44 	mcall	80003ca0 <phy_rx_func+0xe98>
80003b94:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b96:	c0 61       	brne	80003ba2 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003b98:	30 09       	mov	r9,0
80003b9a:	4c b8       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003b9c:	91 09       	st.w	r8[0x0],r9
80003b9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003ba2:	4c b9       	lddpc	r9,80003ccc <phy_rx_func+0xec4>
80003ba4:	72 08       	ld.w	r8,r9[0x0]
80003ba6:	20 18       	sub	r8,1
80003ba8:	93 08       	st.w	r9[0x0],r8
80003baa:	c6 c1       	brne	80003c82 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003bac:	30 09       	mov	r9,0
80003bae:	4c 68       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bb0:	91 09       	st.w	r8[0x0],r9
80003bb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003bb6:	30 09       	mov	r9,0
80003bb8:	4c 38       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bba:	91 09       	st.w	r8[0x0],r9
80003bbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003bc0:	8e 4a       	ld.sh	r10,r7[0x8]
80003bc2:	4d 99       	lddpc	r9,80003d24 <phy_rx_func+0xf1c>
80003bc4:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003bc8:	4d 6a       	lddpc	r10,80003d20 <phy_rx_func+0xf18>
80003bca:	15 88       	ld.ub	r8,r10[0x0]
80003bcc:	f0 cb ff ff 	sub	r11,r8,-1
80003bd0:	8e 5c       	ld.sh	r12,r7[0xa]
80003bd2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003bd6:	f0 cb ff fe 	sub	r11,r8,-2
80003bda:	8e 6c       	ld.sh	r12,r7[0xc]
80003bdc:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003be0:	f0 cb ff fd 	sub	r11,r8,-3
80003be4:	8e 7c       	ld.sh	r12,r7[0xe]
80003be6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003bea:	2f c8       	sub	r8,-4
80003bec:	b4 88       	st.b	r10[0x0],r8
80003bee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bf2:	30 09       	mov	r9,0
80003bf4:	4b 48       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003bf6:	91 09       	st.w	r8[0x0],r9
80003bf8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bfc:	4c 08       	lddpc	r8,80003cfc <phy_rx_func+0xef4>
80003bfe:	70 09       	ld.w	r9,r8[0x0]
80003c00:	8e 4b       	ld.sh	r11,r7[0x8]
80003c02:	4c 0a       	lddpc	r10,80003d00 <phy_rx_func+0xef8>
80003c04:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003c08:	2f f9       	sub	r9,-1
80003c0a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003c0c:	4b 58       	lddpc	r8,80003ce0 <phy_rx_func+0xed8>
80003c0e:	70 09       	ld.w	r9,r8[0x0]
80003c10:	20 29       	sub	r9,2
80003c12:	91 09       	st.w	r8[0x0],r9
80003c14:	70 08       	ld.w	r8,r8[0x0]
80003c16:	58 08       	cp.w	r8,0
80003c18:	c2 f1       	brne	80003c76 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003c1a:	30 09       	mov	r9,0
80003c1c:	4b 88       	lddpc	r8,80003cfc <phy_rx_func+0xef4>
80003c1e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c20:	8e 59       	ld.sh	r9,r7[0xa]
80003c22:	fe 78 82 12 	mov	r8,-32238
80003c26:	f0 09 19 00 	cp.h	r9,r8
80003c2a:	c2 11       	brne	80003c6c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c2c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003c30:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c34:	4a f8       	lddpc	r8,80003cf0 <phy_rx_func+0xee8>
80003c36:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c38:	8e 59       	ld.sh	r9,r7[0xa]
80003c3a:	4a f8       	lddpc	r8,80003cf4 <phy_rx_func+0xeec>
80003c3c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c3e:	8e 69       	ld.sh	r9,r7[0xc]
80003c40:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c42:	f0 1f 00 2e 	mcall	80003cf8 <phy_rx_func+0xef0>
80003c46:	4a 18       	lddpc	r8,80003cc8 <phy_rx_func+0xec0>
80003c48:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c4a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c4e:	31 38       	mov	r8,19
80003c50:	f0 09 18 00 	cp.b	r9,r8
80003c54:	c0 71       	brne	80003c62 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c56:	10 99       	mov	r9,r8
80003c58:	4a 18       	lddpc	r8,80003cdc <phy_rx_func+0xed4>
80003c5a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c5c:	30 09       	mov	r9,0
80003c5e:	49 c8       	lddpc	r8,80003ccc <phy_rx_func+0xec4>
80003c60:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c62:	30 49       	mov	r9,4
80003c64:	49 88       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c6c:	30 09       	mov	r9,0
80003c6e:	49 68       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c70:	91 09       	st.w	r8[0x0],r9
80003c72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c76:	4a dc       	lddpc	r12,80003d28 <phy_rx_func+0xf20>
80003c78:	f0 1f 00 18 	mcall	80003cd8 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003c7c:	30 09       	mov	r9,0
80003c7e:	49 28       	lddpc	r8,80003cc4 <phy_rx_func+0xebc>
80003c80:	91 09       	st.w	r8[0x0],r9
80003c82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c86:	00 00       	add	r0,r0
80003c88:	00 00       	add	r0,r0
80003c8a:	0a b4       	st.h	r5++,r4
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a cc       	st.b	r5++,r12
80003c90:	00 00       	add	r0,r0
80003c92:	0a ac       	st.w	r5++,r12
80003c94:	00 00       	add	r0,r0
80003c96:	0a 8e       	andn	lr,r5
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 7c       	tst	r12,r5
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a a4       	st.w	r5++,r4
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	2c 88       	sub	r8,-56
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a 9c       	mov	r12,r5
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	2b a0       	sub	r0,-70
80003cac:	00 00       	add	r0,r0
80003cae:	0a b0       	st.h	r5++,r0
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	2b d4       	sub	r4,-67
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a 8d       	andn	sp,r5
80003cb8:	00 00       	add	r0,r0
80003cba:	0a a8       	st.w	r5++,r8
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a b8       	st.h	r5++,r8
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a 90       	mov	r0,r5
80003cc4:	00 00       	add	r0,r0
80003cc6:	0a d8       	st.w	--r5,r8
80003cc8:	00 00       	add	r0,r0
80003cca:	0a c0       	st.b	r5++,r0
80003ccc:	00 00       	add	r0,r0
80003cce:	0a 78       	tst	r8,r5
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a 55       	eor	r5,r5
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	d7 a4       	*unknown*
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	71 70       	ld.w	r0,r8[0x5c]
80003cdc:	00 00       	add	r0,r0
80003cde:	0a 8c       	andn	r12,r5
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a e4       	st.h	--r5,r4
80003ce4:	00 00       	add	r0,r0
80003ce6:	0a c4       	st.b	r5++,r4
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	79 b0       	ld.w	r0,r12[0x6c]
80003cec:	80 00       	ld.sh	r0,r0[0x0]
80003cee:	2b bc       	sub	r12,-69
80003cf0:	00 00       	add	r0,r0
80003cf2:	0a 4a       	or	r10,r5
80003cf4:	00 00       	add	r0,r0
80003cf6:	21 2c       	sub	r12,18
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	2b 70       	sub	r0,-73
80003cfc:	00 00       	add	r0,r0
80003cfe:	0a 80       	andn	r0,r5
80003d00:	00 00       	add	r0,r0
80003d02:	20 30       	sub	r0,3
80003d04:	00 00       	add	r0,r0
80003d06:	0a 84       	andn	r4,r5
80003d08:	00 00       	add	r0,r0
80003d0a:	0a 4b       	or	r11,r5
80003d0c:	00 00       	add	r0,r0
80003d0e:	0a 49       	or	r9,r5
80003d10:	00 00       	add	r0,r0
80003d12:	0a dc       	st.w	--r5,r12
80003d14:	00 00       	add	r0,r0
80003d16:	0a 98       	mov	r8,r5
80003d18:	00 00       	add	r0,r0
80003d1a:	0a 64       	and	r4,r5
80003d1c:	00 00       	add	r0,r0
80003d1e:	20 28       	sub	r8,2
80003d20:	00 00       	add	r0,r0
80003d22:	0a d0       	st.w	--r5,r0
80003d24:	00 00       	add	r0,r0
80003d26:	21 30       	sub	r0,19
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	d7 bc       	*unknown*

80003d2c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d2c:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
80003d2e:	30 09       	mov	r9,0
80003d30:	49 b8       	lddpc	r8,80003d9c <pdca_int_handler+0x70>
80003d32:	91 09       	st.w	r8[0x0],r9
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d34:	49 b8       	lddpc	r8,80003da0 <pdca_int_handler+0x74>
80003d36:	70 09       	ld.w	r9,r8[0x0]
80003d38:	2f f9       	sub	r9,-1
80003d3a:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d3c:	49 a8       	lddpc	r8,80003da4 <pdca_int_handler+0x78>
80003d3e:	11 89       	ld.ub	r9,r8[0x0]
80003d40:	ec 19 00 01 	eorl	r9,0x1
80003d44:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d46:	11 89       	ld.ub	r9,r8[0x0]
80003d48:	a5 69       	lsl	r9,0x4
80003d4a:	2f c9       	sub	r9,-4
80003d4c:	49 7a       	lddpc	r10,80003da8 <pdca_int_handler+0x7c>
80003d4e:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d50:	fe 7a 00 40 	mov	r10,-65472
80003d54:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d56:	30 39       	mov	r9,3
80003d58:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d5a:	11 8a       	ld.ub	r10,r8[0x0]
80003d5c:	a5 6a       	lsl	r10,0x4
80003d5e:	2f ca       	sub	r10,-4
80003d60:	49 38       	lddpc	r8,80003dac <pdca_int_handler+0x80>
80003d62:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d64:	fe 78 00 00 	mov	r8,-65536
80003d68:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d6a:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d6c:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d6e:	49 18       	lddpc	r8,80003db0 <pdca_int_handler+0x84>
80003d70:	70 08       	ld.w	r8,r8[0x0]
80003d72:	58 08       	cp.w	r8,0
80003d74:	c0 70       	breq	80003d82 <pdca_int_handler+0x56>
80003d76:	48 c9       	lddpc	r9,80003da4 <pdca_int_handler+0x78>
80003d78:	13 89       	ld.ub	r9,r9[0x0]
80003d7a:	a5 69       	lsl	r9,0x4
80003d7c:	48 cc       	lddpc	r12,80003dac <pdca_int_handler+0x80>
80003d7e:	12 0c       	add	r12,r9
80003d80:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d82:	48 d8       	lddpc	r8,80003db4 <pdca_int_handler+0x88>
80003d84:	70 08       	ld.w	r8,r8[0x0]
80003d86:	58 08       	cp.w	r8,0
80003d88:	c0 70       	breq	80003d96 <pdca_int_handler+0x6a>
80003d8a:	48 79       	lddpc	r9,80003da4 <pdca_int_handler+0x78>
80003d8c:	13 89       	ld.ub	r9,r9[0x0]
80003d8e:	a5 69       	lsl	r9,0x4
80003d90:	48 6c       	lddpc	r12,80003da8 <pdca_int_handler+0x7c>
80003d92:	12 0c       	add	r12,r9
80003d94:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d96:	d4 02       	popm	lr
80003d98:	d6 03       	rete
80003d9a:	00 00       	add	r0,r0
80003d9c:	00 00       	add	r0,r0
80003d9e:	0a ec       	st.h	--r5,r12
80003da0:	00 00       	add	r0,r0
80003da2:	0a f0       	st.b	--r5,r0
80003da4:	00 00       	add	r0,r0
80003da6:	53 50       	stdsp	sp[0xd4],r0
80003da8:	00 00       	add	r0,r0
80003daa:	53 78       	stdsp	sp[0xdc],r8
80003dac:	00 00       	add	r0,r0
80003dae:	53 58       	stdsp	sp[0xd4],r8
80003db0:	00 00       	add	r0,r0
80003db2:	0a e8       	st.h	--r5,r8
80003db4:	00 00       	add	r0,r0
80003db6:	0a f4       	st.b	--r5,r4

80003db8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003db8:	fe 78 10 00 	mov	r8,-61440
80003dbc:	e0 69 0d c0 	mov	r9,3520
80003dc0:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003dc4:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003dc8:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003dcc:	fe 78 34 00 	mov	r8,-52224
80003dd0:	e0 69 80 00 	mov	r9,32768
80003dd4:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003dd6:	30 09       	mov	r9,0
80003dd8:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003dda:	e0 69 04 21 	mov	r9,1057
80003dde:	ea 19 3f 20 	orh	r9,0x3f20
80003de2:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003de4:	e0 69 02 9f 	mov	r9,671
80003de8:	ea 19 01 00 	orh	r9,0x100
80003dec:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003dee:	e0 6a 04 02 	mov	r10,1026
80003df2:	ea 1a 3f 20 	orh	r10,0x3f20
80003df6:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003df8:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003dfa:	5e fc       	retal	r12

80003dfc <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003dfc:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003dfe:	30 19       	mov	r9,1
80003e00:	49 78       	lddpc	r8,80003e5c <local_start_PDC+0x60>
80003e02:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003e04:	fe 78 00 00 	mov	r8,-65536
80003e08:	30 7b       	mov	r11,7
80003e0a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003e0c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003e0e:	49 59       	lddpc	r9,80003e60 <local_start_PDC+0x64>
80003e10:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003e14:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003e16:	30 3a       	mov	r10,3
80003e18:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003e1a:	30 1c       	mov	r12,1
80003e1c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003e1e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003e20:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e22:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e24:	30 2c       	mov	r12,2
80003e26:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003e28:	48 f9       	lddpc	r9,80003e64 <local_start_PDC+0x68>
80003e2a:	e0 68 5a 5a 	mov	r8,23130
80003e2e:	ea 18 ab cd 	orh	r8,0xabcd
80003e32:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e34:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e36:	30 0e       	mov	lr,0
80003e38:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e3a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e3c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e3e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e40:	fe 78 00 40 	mov	r8,-65472
80003e44:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e46:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e48:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e4c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e4e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e50:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e52:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e54:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e56:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e58:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e5a:	d8 02       	popm	pc
80003e5c:	00 00       	add	r0,r0
80003e5e:	53 50       	stdsp	sp[0xd4],r0
80003e60:	00 00       	add	r0,r0
80003e62:	53 58       	stdsp	sp[0xd4],r8
80003e64:	00 00       	add	r0,r0
80003e66:	53 78       	stdsp	sp[0xdc],r8

80003e68 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e68:	48 38       	lddpc	r8,80003e74 <register_rx_tx_func+0xc>
80003e6a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e6c:	48 38       	lddpc	r8,80003e78 <register_rx_tx_func+0x10>
80003e6e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e70:	5e fc       	retal	r12
80003e72:	00 00       	add	r0,r0
80003e74:	00 00       	add	r0,r0
80003e76:	0a e8       	st.h	--r5,r8
80003e78:	00 00       	add	r0,r0
80003e7a:	0a f4       	st.b	--r5,r4

80003e7c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e7c:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e7e:	fe 78 10 00 	mov	r8,-61440
80003e82:	30 29       	mov	r9,2
80003e84:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e88:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003e8c:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003e8e:	30 3a       	mov	r10,3
80003e90:	36 0b       	mov	r11,96
80003e92:	49 4c       	lddpc	r12,80003ee0 <ssc_init+0x64>
80003e94:	f0 1f 00 14 	mcall	80003ee4 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003e98:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e9a:	fe 79 10 00 	mov	r9,-61440
80003e9e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ea2:	e2 18 00 02 	andl	r8,0x2,COH
80003ea6:	cf c0       	breq	80003e9e <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003ea8:	fe 79 10 00 	mov	r9,-61440
80003eac:	f2 f8 01 60 	ld.w	r8,r9[352]
80003eb0:	e2 18 00 02 	andl	r8,0x2,COH
80003eb4:	cf c1       	brne	80003eac <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003eb6:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003eb8:	f0 1f 00 0c 	mcall	80003ee8 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003ebc:	f0 1f 00 0c 	mcall	80003eec <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ec0:	fe 79 00 00 	mov	r9,-65536
80003ec4:	30 18       	mov	r8,1
80003ec6:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ec8:	fe 7a 00 40 	mov	r10,-65472
80003ecc:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003ece:	e0 6b 01 01 	mov	r11,257
80003ed2:	fe 7a 34 00 	mov	r10,-52224
80003ed6:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ed8:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003eda:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003edc:	d8 02       	popm	pc
80003ede:	00 00       	add	r0,r0
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	3d 2c       	mov	r12,-46
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	54 4c       	stdsp	sp[0x110],r12
80003ee8:	80 00       	ld.sh	r0,r0[0x0]
80003eea:	3d b8       	mov	r8,-37
80003eec:	80 00       	ld.sh	r0,r0[0x0]
80003eee:	3d fc       	mov	r12,-33

80003ef0 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003ef0:	48 28       	lddpc	r8,80003ef8 <xcmp_register_app_list+0x8>
80003ef2:	91 0c       	st.w	r8[0x0],r12
}
80003ef4:	5e fc       	retal	r12
80003ef6:	00 00       	add	r0,r0
80003ef8:	00 00       	add	r0,r0
80003efa:	53 98       	stdsp	sp[0xe4],r8

80003efc <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003efc:	eb cd 40 80 	pushm	r7,lr
80003f00:	fa cd 01 00 	sub	sp,sp,256
80003f04:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003f06:	16 98       	mov	r8,r11
80003f08:	2f 08       	sub	r8,-16
80003f0a:	af a8       	sbr	r8,0xe
80003f0c:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003f0e:	3f f8       	mov	r8,-1
80003f10:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003f12:	30 b9       	mov	r9,11
80003f14:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003f16:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003f18:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003f1a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003f1c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003f1e:	f6 ca ff fe 	sub	r10,r11,-2
80003f22:	18 9b       	mov	r11,r12
80003f24:	fa cc ff f0 	sub	r12,sp,-16
80003f28:	f0 1f 00 05 	mcall	80003f3c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003f2c:	2f e7       	sub	r7,-2
80003f2e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003f30:	1a 9c       	mov	r12,sp
80003f32:	f0 1f 00 04 	mcall	80003f40 <xcmp_tx+0x44>
}
80003f36:	2c 0d       	sub	sp,-256
80003f38:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	78 68       	ld.w	r8,r12[0x18]
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	45 08       	lddsp	r8,sp[0x140]

80003f44 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003f44:	d4 21       	pushm	r4-r7,lr
80003f46:	fa cd 00 d0 	sub	sp,sp,208
80003f4a:	18 94       	mov	r4,r12
80003f4c:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f4e:	e0 68 01 00 	mov	r8,256
80003f52:	f0 0b 19 00 	cp.h	r11,r8
80003f56:	e0 8b 00 36 	brhi	80003fc2 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f5a:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f5e:	e0 68 04 1d 	mov	r8,1053
80003f62:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f64:	30 18       	mov	r8,1
80003f66:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f68:	32 08       	mov	r8,32
80003f6a:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f6c:	30 28       	mov	r8,2
80003f6e:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f70:	30 48       	mov	r8,4
80003f72:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f74:	ea 1a 0c 00 	orh	r10,0xc00
80003f78:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f7a:	30 4a       	mov	r10,4
80003f7c:	1a 9b       	mov	r11,sp
80003f7e:	fa cc ff f4 	sub	r12,sp,-12
80003f82:	f0 1f 00 12 	mcall	80003fc8 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003f86:	30 f8       	mov	r8,15
80003f88:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003f8c:	3a 78       	mov	r8,-89
80003f8e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003f92:	30 08       	mov	r8,0
80003f94:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003f98:	0e 9a       	mov	r10,r7
80003f9a:	5c 7a       	castu.h	r10
80003f9c:	f4 08 16 08 	lsr	r8,r10,0x8
80003fa0:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003fa4:	0e 96       	mov	r6,r7
80003fa6:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003faa:	08 9b       	mov	r11,r4
80003fac:	fa cc ff eb 	sub	r12,sp,-21
80003fb0:	f0 1f 00 06 	mcall	80003fc8 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003fb4:	ee cb ff f3 	sub	r11,r7,-13
80003fb8:	5c 5b       	castu.b	r11
80003fba:	fa cc ff fa 	sub	r12,sp,-6
80003fbe:	f0 1f 00 04 	mcall	80003fcc <xcmp_data_session_req+0x88>
}
80003fc2:	2c cd       	sub	sp,-208
80003fc4:	d8 22       	popm	r4-r7,pc
80003fc6:	00 00       	add	r0,r0
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	78 68       	ld.w	r8,r12[0x18]
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	3e fc       	mov	r12,-17

80003fd0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003fd0:	d4 01       	pushm	lr
80003fd2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003fd6:	fe 78 b4 00 	mov	r8,-19456
80003fda:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fdc:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fe0:	30 89       	mov	r9,8
80003fe2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fe4:	30 19       	mov	r9,1
80003fe6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fe8:	30 09       	mov	r9,0
80003fea:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fec:	30 5a       	mov	r10,5
80003fee:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003ff0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003ff2:	30 7a       	mov	r10,7
80003ff4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003ff6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003ff8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003ffa:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003ffe:	30 9b       	mov	r11,9
80004000:	fa cc ff fe 	sub	r12,sp,-2
80004004:	f0 1f 00 02 	mcall	8000400c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004008:	2c dd       	sub	sp,-204
8000400a:	d8 02       	popm	pc
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	3e fc       	mov	r12,-17

80004010 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004010:	d4 01       	pushm	lr
80004012:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004016:	fe 78 80 00 	mov	r8,-32768
8000401a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000401c:	30 38       	mov	r8,3
8000401e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004020:	30 1b       	mov	r11,1
80004022:	fa cc ff fe 	sub	r12,sp,-2
80004026:	f0 1f 00 03 	mcall	80004030 <xcmp_opcode_not_supported+0x20>
}
8000402a:	2c dd       	sub	sp,-204
8000402c:	d8 02       	popm	pc
8000402e:	00 00       	add	r0,r0
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	3e fc       	mov	r12,-17

80004034 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004034:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004036:	96 88       	ld.uh	r8,r11[0x0]
80004038:	e2 18 f0 00 	andl	r8,0xf000,COH
8000403c:	e0 48 80 00 	cp.w	r8,32768
80004040:	c0 f0       	breq	8000405e <xcmp_exec_func+0x2a>
80004042:	e0 48 b0 00 	cp.w	r8,45056
80004046:	c1 20       	breq	8000406a <xcmp_exec_func+0x36>
80004048:	58 08       	cp.w	r8,0
8000404a:	c1 51       	brne	80004074 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000404c:	78 08       	ld.w	r8,r12[0x0]
8000404e:	58 08       	cp.w	r8,0
80004050:	c0 40       	breq	80004058 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004052:	16 9c       	mov	r12,r11
80004054:	5d 18       	icall	r8
80004056:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004058:	f0 1f 00 08 	mcall	80004078 <xcmp_exec_func+0x44>
8000405c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000405e:	78 18       	ld.w	r8,r12[0x4]
80004060:	58 08       	cp.w	r8,0
80004062:	c0 90       	breq	80004074 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004064:	16 9c       	mov	r12,r11
80004066:	5d 18       	icall	r8
80004068:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000406a:	78 28       	ld.w	r8,r12[0x8]
8000406c:	58 08       	cp.w	r8,0
8000406e:	c0 30       	breq	80004074 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004070:	16 9c       	mov	r12,r11
80004072:	5d 18       	icall	r8
80004074:	d8 02       	popm	pc
80004076:	00 00       	add	r0,r0
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	40 10       	lddsp	r0,sp[0x4]

8000407c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000407c:	d4 01       	pushm	lr
8000407e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004082:	e0 68 04 09 	mov	r8,1033
80004086:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004088:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
8000408c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000408e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004092:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004094:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004096:	30 09       	mov	r9,0
80004098:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000409a:	fb 69 00 08 	st.b	sp[8],r9
8000409e:	fa c8 ff f7 	sub	r8,sp,-9
800040a2:	b0 89       	st.b	r8[0x0],r9
800040a4:	fa c8 ff f6 	sub	r8,sp,-10
800040a8:	b0 89       	st.b	r8[0x0],r9
800040aa:	fa c8 ff f5 	sub	r8,sp,-11
800040ae:	b0 89       	st.b	r8[0x0],r9
800040b0:	fa c8 ff f4 	sub	r8,sp,-12
800040b4:	b0 89       	st.b	r8[0x0],r9
800040b6:	fa c8 ff f3 	sub	r8,sp,-13
800040ba:	b0 89       	st.b	r8[0x0],r9
800040bc:	fa c8 ff f2 	sub	r8,sp,-14
800040c0:	b0 89       	st.b	r8[0x0],r9
800040c2:	fa c8 ff f1 	sub	r8,sp,-15
800040c6:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800040c8:	30 cb       	mov	r11,12
800040ca:	fa cc ff fe 	sub	r12,sp,-2
800040ce:	f0 1f 00 03 	mcall	800040d8 <xcmp_IdleTestTone+0x5c>
}
800040d2:	2c dd       	sub	sp,-204
800040d4:	d8 02       	popm	pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	3e fc       	mov	r12,-17

800040dc <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040dc:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040de:	48 dc       	lddpc	r12,80004110 <xcmp_init+0x34>
800040e0:	f0 1f 00 0d 	mcall	80004114 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040e4:	30 4b       	mov	r11,4
800040e6:	31 4c       	mov	r12,20
800040e8:	f0 1f 00 0c 	mcall	80004118 <xcmp_init+0x3c>
800040ec:	48 c8       	lddpc	r8,8000411c <xcmp_init+0x40>
800040ee:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040f0:	30 09       	mov	r9,0
800040f2:	1a d9       	st.w	--sp,r9
800040f4:	1a d9       	st.w	--sp,r9
800040f6:	1a d9       	st.w	--sp,r9
800040f8:	30 38       	mov	r8,3
800040fa:	e0 6a 04 00 	mov	r10,1024
800040fe:	48 9b       	lddpc	r11,80004120 <xcmp_init+0x44>
80004100:	48 9c       	lddpc	r12,80004124 <xcmp_init+0x48>
80004102:	f0 1f 00 0a 	mcall	80004128 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004106:	f0 1f 00 0a 	mcall	8000412c <xcmp_init+0x50>
8000410a:	2f dd       	sub	sp,-12
	
}
8000410c:	d8 02       	popm	pc
8000410e:	00 00       	add	r0,r0
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	42 2c       	lddsp	r12,sp[0x88]
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	42 78       	lddsp	r8,sp[0x9c]
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	65 04       	ld.w	r4,r2[0x40]
8000411c:	00 00       	add	r0,r0
8000411e:	0b 10       	ld.sh	r0,r5++
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	d7 e8       	*unknown*
80004124:	80 00       	ld.sh	r0,r0[0x0]
80004126:	41 30       	lddsp	r0,sp[0x4c]
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	6c 20       	ld.w	r0,r6[0x8]
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	42 b0       	lddsp	r0,sp[0xac]

80004130 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004130:	d4 31       	pushm	r0-r7,lr
80004132:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004134:	4b 16       	lddpc	r6,800041f8 <xcmp_rx_process+0xc8>
80004136:	30 05       	mov	r5,0
80004138:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000413a:	4b 13       	lddpc	r3,800041fc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000413c:	4b 12       	lddpc	r2,80004200 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000413e:	4b 21       	lddpc	r1,80004204 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004140:	4b 20       	lddpc	r0,80004208 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004142:	6c 0c       	ld.w	r12,r6[0x0]
80004144:	0a 99       	mov	r9,r5
80004146:	08 9a       	mov	r10,r4
80004148:	1a 9b       	mov	r11,sp
8000414a:	f0 1f 00 31 	mcall	8000420c <xcmp_rx_process+0xdc>
8000414e:	58 1c       	cp.w	r12,1
80004150:	cf 91       	brne	80004142 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004152:	40 0b       	lddsp	r11,sp[0x0]
80004154:	58 0b       	cp.w	r11,0
80004156:	cf 60       	breq	80004142 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004158:	96 0a       	ld.sh	r10,r11[0x0]
8000415a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000415e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004162:	59 c8       	cp.w	r8,28
80004164:	c1 e0       	breq	800041a0 <xcmp_rx_process+0x70>
80004166:	e0 89 00 07 	brgt	80004174 <xcmp_rx_process+0x44>
8000416a:	58 e8       	cp.w	r8,14
8000416c:	c0 e0       	breq	80004188 <xcmp_rx_process+0x58>
8000416e:	58 f8       	cp.w	r8,15
80004170:	c2 41       	brne	800041b8 <xcmp_rx_process+0x88>
80004172:	c0 f8       	rjmp	80004190 <xcmp_rx_process+0x60>
80004174:	e0 48 01 09 	cp.w	r8,265
80004178:	c1 80       	breq	800041a8 <xcmp_rx_process+0x78>
8000417a:	e0 48 01 0a 	cp.w	r8,266
8000417e:	c1 90       	breq	800041b0 <xcmp_rx_process+0x80>
80004180:	e0 48 00 2c 	cp.w	r8,44
80004184:	c1 a1       	brne	800041b8 <xcmp_rx_process+0x88>
80004186:	c0 98       	rjmp	80004198 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004188:	4a 2c       	lddpc	r12,80004210 <xcmp_rx_process+0xe0>
8000418a:	f0 1f 00 23 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
8000418e:	c2 f8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004190:	4a 2c       	lddpc	r12,80004218 <xcmp_rx_process+0xe8>
80004192:	f0 1f 00 21 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
80004196:	c2 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004198:	4a 1c       	lddpc	r12,8000421c <xcmp_rx_process+0xec>
8000419a:	f0 1f 00 1f 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
8000419e:	c2 78       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041a0:	04 9c       	mov	r12,r2
800041a2:	f0 1f 00 1d 	mcall	80004214 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800041a6:	c2 38       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041a8:	02 9c       	mov	r12,r1
800041aa:	f0 1f 00 1b 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
800041ae:	c1 f8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800041b0:	00 9c       	mov	r12,r0
800041b2:	f0 1f 00 19 	mcall	80004214 <xcmp_rx_process+0xe4>
					break;
800041b6:	c1 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800041b8:	12 98       	mov	r8,r9
800041ba:	e2 18 04 00 	andl	r8,0x400,COH
800041be:	c0 70       	breq	800041cc <xcmp_rx_process+0x9c>
800041c0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800041c4:	e0 48 00 68 	cp.w	r8,104
800041c8:	e0 8a 00 08 	brle	800041d8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800041cc:	e2 19 f0 00 	andl	r9,0xf000,COH
800041d0:	c0 e1       	brne	800041ec <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800041d2:	f0 1f 00 14 	mcall	80004220 <xcmp_rx_process+0xf0>
800041d6:	c0 b8       	rjmp	800041ec <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041d8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041dc:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041e0:	49 19       	lddpc	r9,80004224 <xcmp_rx_process+0xf4>
800041e2:	72 08       	ld.w	r8,r9[0x0]
800041e4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041e8:	f0 1f 00 0b 	mcall	80004214 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041ec:	66 0c       	ld.w	r12,r3[0x0]
800041ee:	40 0b       	lddsp	r11,sp[0x0]
800041f0:	f0 1f 00 0e 	mcall	80004228 <xcmp_rx_process+0xf8>
800041f4:	ca 7b       	rjmp	80004142 <xcmp_rx_process+0x12>
800041f6:	00 00       	add	r0,r0
800041f8:	00 00       	add	r0,r0
800041fa:	0b 10       	ld.sh	r0,r5++
800041fc:	00 00       	add	r0,r0
800041fe:	0a a4       	st.w	r5++,r4
80004200:	00 00       	add	r0,r0
80004202:	0b 20       	ld.uh	r0,r5++
80004204:	00 00       	add	r0,r0
80004206:	0b 14       	ld.sh	r4,r5++
80004208:	00 00       	add	r0,r0
8000420a:	0b 04       	ld.w	r4,r5++
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	61 a0       	ld.w	r0,r0[0x68]
80004210:	00 00       	add	r0,r0
80004212:	0b 38       	ld.ub	r8,r5++
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	40 34       	lddsp	r4,sp[0xc]
80004218:	00 00       	add	r0,r0
8000421a:	0a f8       	st.b	--r5,r8
8000421c:	00 00       	add	r0,r0
8000421e:	0b 2c       	ld.uh	r12,r5++
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	40 10       	lddsp	r0,sp[0x4]
80004224:	00 00       	add	r0,r0
80004226:	53 98       	stdsp	sp[0xe4],r8
80004228:	80 00       	ld.sh	r0,r0[0x0]
8000422a:	2c 0c       	sub	r12,-64

8000422c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000422c:	eb cd 40 90 	pushm	r4,r7,lr
80004230:	20 1d       	sub	sp,4
80004232:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004236:	48 c8       	lddpc	r8,80004264 <xcmp_rx+0x38>
80004238:	70 0c       	ld.w	r12,r8[0x0]
8000423a:	f0 1f 00 0c 	mcall	80004268 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000423e:	c1 00       	breq	8000425e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004240:	fa c7 ff fc 	sub	r7,sp,-4
80004244:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004246:	e0 6a 00 ca 	mov	r10,202
8000424a:	08 9b       	mov	r11,r4
8000424c:	f0 1f 00 08 	mcall	8000426c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004250:	48 88       	lddpc	r8,80004270 <xcmp_rx+0x44>
80004252:	70 0c       	ld.w	r12,r8[0x0]
80004254:	30 09       	mov	r9,0
80004256:	12 9a       	mov	r10,r9
80004258:	1a 9b       	mov	r11,sp
8000425a:	f0 1f 00 07 	mcall	80004274 <xcmp_rx+0x48>
	}	
}
8000425e:	2f fd       	sub	sp,-4
80004260:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004264:	00 00       	add	r0,r0
80004266:	0a a4       	st.w	r5++,r4
80004268:	80 00       	ld.sh	r0,r0[0x0]
8000426a:	2d b8       	sub	r8,-37
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	78 68       	ld.w	r8,r12[0x18]
80004270:	00 00       	add	r0,r0
80004272:	0b 10       	ld.sh	r0,r5++
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	63 ac       	ld.w	r12,r1[0x68]

80004278 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004278:	48 28       	lddpc	r8,80004280 <xnl_register_xcmp_func+0x8>
8000427a:	91 0c       	st.w	r8[0x0],r12
}
8000427c:	5e fc       	retal	r12
8000427e:	00 00       	add	r0,r0
80004280:	00 00       	add	r0,r0
80004282:	0b 64       	ld.uh	r4,--r5

80004284 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004284:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004286:	48 88       	lddpc	r8,800042a4 <xnl_get_msg_ack_func+0x20>
80004288:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000428a:	98 49       	ld.sh	r9,r12[0x8]
8000428c:	f0 09 19 00 	cp.h	r9,r8
80004290:	c0 81       	brne	800042a0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004292:	48 68       	lddpc	r8,800042a8 <xnl_get_msg_ack_func+0x24>
80004294:	70 0c       	ld.w	r12,r8[0x0]
80004296:	30 09       	mov	r9,0
80004298:	12 9a       	mov	r10,r9
8000429a:	12 9b       	mov	r11,r9
8000429c:	f0 1f 00 04 	mcall	800042ac <xnl_get_msg_ack_func+0x28>
800042a0:	d8 02       	popm	pc
800042a2:	00 00       	add	r0,r0
800042a4:	00 00       	add	r0,r0
800042a6:	0b 4a       	ld.w	r10,--r5
800042a8:	00 00       	add	r0,r0
800042aa:	0b 44       	ld.w	r4,--r5
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	63 ac       	ld.w	r12,r1[0x68]

800042b0 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800042b0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800042b4:	30 09       	mov	r9,0
800042b6:	4b 78       	lddpc	r8,80004390 <xnl_init+0xe0>
800042b8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800042ba:	30 0b       	mov	r11,0
800042bc:	30 1c       	mov	r12,1
800042be:	f0 1f 00 36 	mcall	80004394 <xnl_init+0xe4>
800042c2:	4b 68       	lddpc	r8,80004398 <xnl_init+0xe8>
800042c4:	91 0c       	st.w	r8[0x0],r12
800042c6:	70 08       	ld.w	r8,r8[0x0]
800042c8:	58 08       	cp.w	r8,0
800042ca:	c0 80       	breq	800042da <xnl_init+0x2a>
800042cc:	4b 38       	lddpc	r8,80004398 <xnl_init+0xe8>
800042ce:	70 0c       	ld.w	r12,r8[0x0]
800042d0:	30 09       	mov	r9,0
800042d2:	12 9a       	mov	r10,r9
800042d4:	12 9b       	mov	r11,r9
800042d6:	f0 1f 00 32 	mcall	8000439c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042da:	30 4b       	mov	r11,4
800042dc:	31 4c       	mov	r12,20
800042de:	f0 1f 00 2e 	mcall	80004394 <xnl_init+0xe4>
800042e2:	4b 08       	lddpc	r8,800043a0 <xnl_init+0xf0>
800042e4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800042e6:	30 4b       	mov	r11,4
800042e8:	31 ec       	mov	r12,30
800042ea:	f0 1f 00 2b 	mcall	80004394 <xnl_init+0xe4>
800042ee:	4a e8       	lddpc	r8,800043a4 <xnl_init+0xf4>
800042f0:	91 0c       	st.w	r8[0x0],r12
800042f2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800042f4:	10 96       	mov	r6,r8
800042f6:	4a d5       	lddpc	r5,800043a8 <xnl_init+0xf8>
800042f8:	6c 0c       	ld.w	r12,r6[0x0]
800042fa:	ea 07 00 0b 	add	r11,r5,r7
800042fe:	f0 1f 00 2c 	mcall	800043ac <xnl_init+0xfc>
80004302:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004306:	e0 47 1e 00 	cp.w	r7,7680
8000430a:	cf 71       	brne	800042f8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000430c:	30 4b       	mov	r11,4
8000430e:	31 4c       	mov	r12,20
80004310:	f0 1f 00 21 	mcall	80004394 <xnl_init+0xe4>
80004314:	4a 78       	lddpc	r8,800043b0 <xnl_init+0x100>
80004316:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004318:	30 4b       	mov	r11,4
8000431a:	30 ac       	mov	r12,10
8000431c:	f0 1f 00 1e 	mcall	80004394 <xnl_init+0xe4>
80004320:	4a 58       	lddpc	r8,800043b4 <xnl_init+0x104>
80004322:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004324:	30 4b       	mov	r11,4
80004326:	30 ac       	mov	r12,10
80004328:	f0 1f 00 1b 	mcall	80004394 <xnl_init+0xe4>
8000432c:	4a 38       	lddpc	r8,800043b8 <xnl_init+0x108>
8000432e:	91 0c       	st.w	r8[0x0],r12
80004330:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004332:	10 96       	mov	r6,r8
80004334:	4a 25       	lddpc	r5,800043bc <xnl_init+0x10c>
80004336:	6c 0c       	ld.w	r12,r6[0x0]
80004338:	ea 07 00 0b 	add	r11,r5,r7
8000433c:	f0 1f 00 1c 	mcall	800043ac <xnl_init+0xfc>
80004340:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004344:	e0 47 14 00 	cp.w	r7,5120
80004348:	cf 71       	brne	80004336 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000434a:	30 4b       	mov	r11,4
8000434c:	30 5c       	mov	r12,5
8000434e:	f0 1f 00 12 	mcall	80004394 <xnl_init+0xe4>
80004352:	49 c8       	lddpc	r8,800043c0 <xnl_init+0x110>
80004354:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004356:	30 07       	mov	r7,0
80004358:	1a d7       	st.w	--sp,r7
8000435a:	1a d7       	st.w	--sp,r7
8000435c:	1a d7       	st.w	--sp,r7
8000435e:	30 38       	mov	r8,3
80004360:	0e 99       	mov	r9,r7
80004362:	e0 6a 00 dc 	mov	r10,220
80004366:	49 8b       	lddpc	r11,800043c4 <xnl_init+0x114>
80004368:	49 8c       	lddpc	r12,800043c8 <xnl_init+0x118>
8000436a:	f0 1f 00 19 	mcall	800043cc <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000436e:	1a d7       	st.w	--sp,r7
80004370:	1a d7       	st.w	--sp,r7
80004372:	1a d7       	st.w	--sp,r7
80004374:	30 38       	mov	r8,3
80004376:	0e 99       	mov	r9,r7
80004378:	e0 6a 00 82 	mov	r10,130
8000437c:	49 5b       	lddpc	r11,800043d0 <xnl_init+0x120>
8000437e:	49 6c       	lddpc	r12,800043d4 <xnl_init+0x124>
80004380:	f0 1f 00 13 	mcall	800043cc <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004384:	f0 1f 00 15 	mcall	800043d8 <xnl_init+0x128>
80004388:	2f ad       	sub	sp,-24
}
8000438a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000438e:	00 00       	add	r0,r0
80004390:	00 00       	add	r0,r0
80004392:	0b 4a       	ld.w	r10,--r5
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	65 04       	ld.w	r4,r2[0x40]
80004398:	00 00       	add	r0,r0
8000439a:	0b 44       	ld.w	r4,--r5
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	63 ac       	ld.w	r12,r1[0x68]
800043a0:	00 00       	add	r0,r0
800043a2:	0b 58       	ld.sh	r8,--r5
800043a4:	00 00       	add	r0,r0
800043a6:	0a a4       	st.w	r5++,r4
800043a8:	00 00       	add	r0,r0
800043aa:	35 4a       	mov	r10,84
800043ac:	80 00       	ld.sh	r0,r0[0x0]
800043ae:	2c 0c       	sub	r12,-64
800043b0:	00 00       	add	r0,r0
800043b2:	0a d4       	st.w	--r5,r4
800043b4:	00 00       	add	r0,r0
800043b6:	0a b4       	st.h	r5++,r4
800043b8:	00 00       	add	r0,r0
800043ba:	0a a8       	st.w	r5++,r8
800043bc:	00 00       	add	r0,r0
800043be:	21 4a       	sub	r10,20
800043c0:	00 00       	add	r0,r0
800043c2:	0a e0       	st.h	--r5,r0
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	d7 f0       	acall	0x7f
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	43 dc       	lddsp	r12,sp[0xf4]
800043cc:	80 00       	ld.sh	r0,r0[0x0]
800043ce:	6c 20       	ld.w	r0,r6[0x8]
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	d7 f8       	*unknown*
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	44 3c       	lddsp	r12,sp[0x10c]
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	2d e0       	sub	r0,-34

800043dc <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800043dc:	eb cd 40 fe 	pushm	r1-r7,lr
800043e0:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043e2:	49 26       	lddpc	r6,80004428 <xnl_rx_process+0x4c>
800043e4:	30 05       	mov	r5,0
800043e6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043e8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043ea:	49 11       	lddpc	r1,8000442c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043ec:	49 12       	lddpc	r2,80004430 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043ee:	6c 0c       	ld.w	r12,r6[0x0]
800043f0:	0a 99       	mov	r9,r5
800043f2:	08 9a       	mov	r10,r4
800043f4:	1a 9b       	mov	r11,sp
800043f6:	f0 1f 00 10 	mcall	80004434 <xnl_rx_process+0x58>
800043fa:	58 1c       	cp.w	r12,1
800043fc:	cf 91       	brne	800043ee <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800043fe:	40 0c       	lddsp	r12,sp[0x0]
80004400:	58 0c       	cp.w	r12,0
80004402:	cf 60       	breq	800043ee <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004404:	98 28       	ld.sh	r8,r12[0x4]
80004406:	e6 08 19 00 	cp.h	r8,r3
8000440a:	e0 8b 00 0a 	brhi	8000441e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000440e:	5c 78       	castu.h	r8
80004410:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004414:	58 09       	cp.w	r9,0
80004416:	c0 40       	breq	8000441e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004418:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000441c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000441e:	62 0c       	ld.w	r12,r1[0x0]
80004420:	40 0b       	lddsp	r11,sp[0x0]
80004422:	f0 1f 00 06 	mcall	80004438 <xnl_rx_process+0x5c>
80004426:	ce 4b       	rjmp	800043ee <xnl_rx_process+0x12>
80004428:	00 00       	add	r0,r0
8000442a:	0a b4       	st.h	r5++,r4
8000442c:	00 00       	add	r0,r0
8000442e:	0a a4       	st.w	r5++,r4
80004430:	00 00       	add	r0,r0
80004432:	04 f8       	st.b	--r2,r8
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	61 a0       	ld.w	r0,r0[0x68]
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	2c 0c       	sub	r12,-64

8000443c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
8000443c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000443e:	4a a6       	lddpc	r6,800044e4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004440:	4a a2       	lddpc	r2,800044e8 <xnl_tx_process+0xac>
80004442:	4a b4       	lddpc	r4,800044ec <xnl_tx_process+0xb0>
80004444:	30 07       	mov	r7,0
80004446:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004448:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000444a:	4a a5       	lddpc	r5,800044f0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000444c:	4a a3       	lddpc	r3,800044f4 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000444e:	6c 08       	ld.w	r8,r6[0x0]
80004450:	58 08       	cp.w	r8,0
80004452:	c0 40       	breq	8000445a <xnl_tx_process+0x1e>
80004454:	58 18       	cp.w	r8,1
80004456:	cf d1       	brne	80004450 <xnl_tx_process+0x14>
80004458:	c2 48       	rjmp	800044a0 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000445a:	64 0c       	ld.w	r12,r2[0x0]
8000445c:	0e 99       	mov	r9,r7
8000445e:	02 9a       	mov	r10,r1
80004460:	08 9b       	mov	r11,r4
80004462:	f0 1f 00 26 	mcall	800044f8 <xnl_tx_process+0xbc>
80004466:	58 1c       	cp.w	r12,1
80004468:	cf 31       	brne	8000444e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000446a:	68 0b       	ld.w	r11,r4[0x0]
8000446c:	58 0b       	cp.w	r11,0
8000446e:	cf 00       	breq	8000444e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004470:	96 28       	ld.sh	r8,r11[0x4]
80004472:	e0 08 19 00 	cp.h	r8,r0
80004476:	c0 71       	brne	80004484 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004478:	4a 18       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
8000447a:	70 08       	ld.w	r8,r8[0x0]
8000447c:	10 9c       	mov	r12,r8
8000447e:	f0 1f 00 21 	mcall	80004500 <xnl_tx_process+0xc4>
						break;
80004482:	ce 6b       	rjmp	8000444e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004484:	16 9c       	mov	r12,r11
80004486:	f0 1f 00 20 	mcall	80004504 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000448a:	30 18       	mov	r8,1
8000448c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000448e:	66 0c       	ld.w	r12,r3[0x0]
80004490:	0e 99       	mov	r9,r7
80004492:	0e 9a       	mov	r10,r7
80004494:	0e 9b       	mov	r11,r7
80004496:	f0 1f 00 19 	mcall	800044f8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000449a:	30 18       	mov	r8,1
8000449c:	8d 08       	st.w	r6[0x0],r8
8000449e:	cd 8b       	rjmp	8000444e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800044a0:	66 0c       	ld.w	r12,r3[0x0]
800044a2:	0e 99       	mov	r9,r7
800044a4:	36 4a       	mov	r10,100
800044a6:	0e 9b       	mov	r11,r7
800044a8:	f0 1f 00 14 	mcall	800044f8 <xnl_tx_process+0xbc>
800044ac:	58 1c       	cp.w	r12,1
800044ae:	c0 81       	brne	800044be <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800044b0:	49 38       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
800044b2:	70 0c       	ld.w	r12,r8[0x0]
800044b4:	68 0b       	ld.w	r11,r4[0x0]
800044b6:	f0 1f 00 13 	mcall	80004500 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800044ba:	8d 07       	st.w	r6[0x0],r7
800044bc:	cc 9b       	rjmp	8000444e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800044be:	6a 08       	ld.w	r8,r5[0x0]
800044c0:	58 38       	cp.w	r8,3
800044c2:	e0 89 00 09 	brgt	800044d4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800044c6:	68 0c       	ld.w	r12,r4[0x0]
800044c8:	f0 1f 00 0f 	mcall	80004504 <xnl_tx_process+0xc8>
						xnl_send_times++;
800044cc:	6a 08       	ld.w	r8,r5[0x0]
800044ce:	2f f8       	sub	r8,-1
800044d0:	8b 08       	st.w	r5[0x0],r8
800044d2:	cb eb       	rjmp	8000444e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800044d4:	48 a8       	lddpc	r8,800044fc <xnl_tx_process+0xc0>
800044d6:	70 0c       	ld.w	r12,r8[0x0]
800044d8:	68 0b       	ld.w	r11,r4[0x0]
800044da:	f0 1f 00 0a 	mcall	80004500 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044de:	8d 07       	st.w	r6[0x0],r7
800044e0:	cb 7b       	rjmp	8000444e <xnl_tx_process+0x12>
800044e2:	00 00       	add	r0,r0
800044e4:	00 00       	add	r0,r0
800044e6:	0b 54       	ld.sh	r4,--r5
800044e8:	00 00       	add	r0,r0
800044ea:	0b 58       	ld.sh	r8,--r5
800044ec:	00 00       	add	r0,r0
800044ee:	0b 60       	ld.uh	r0,--r5
800044f0:	00 00       	add	r0,r0
800044f2:	0b 5c       	ld.sh	r12,--r5
800044f4:	00 00       	add	r0,r0
800044f6:	0b 44       	ld.w	r4,--r5
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	61 a0       	ld.w	r0,r0[0x68]
800044fc:	00 00       	add	r0,r0
800044fe:	0a a4       	st.w	r5++,r4
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	2c 0c       	sub	r12,-64
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	2c 2c       	sub	r12,-62

80004508 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004508:	eb cd 40 c0 	pushm	r6-r7,lr
8000450c:	20 1d       	sub	sp,4
8000450e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004510:	98 39       	ld.sh	r9,r12[0x6]
80004512:	3f f8       	mov	r8,-1
80004514:	f0 09 19 00 	cp.h	r9,r8
80004518:	c0 a1       	brne	8000452c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000451a:	4a e9       	lddpc	r9,800045d0 <xnl_tx+0xc8>
8000451c:	13 88       	ld.ub	r8,r9[0x0]
8000451e:	2f f8       	sub	r8,-1
80004520:	5c 58       	castu.b	r8
80004522:	b2 88       	st.b	r9[0x0],r8
80004524:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004528:	a9 a8       	sbr	r8,0x8
8000452a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
8000452c:	8c 49       	ld.sh	r9,r6[0x8]
8000452e:	3f f8       	mov	r8,-1
80004530:	f0 09 19 00 	cp.h	r9,r8
80004534:	c0 41       	brne	8000453c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004536:	4a 88       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004538:	90 18       	ld.sh	r8,r8[0x2]
8000453a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000453c:	8c 59       	ld.sh	r9,r6[0xa]
8000453e:	3f f8       	mov	r8,-1
80004540:	f0 09 19 00 	cp.h	r9,r8
80004544:	c0 41       	brne	8000454c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004546:	4a 48       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004548:	90 28       	ld.sh	r8,r8[0x4]
8000454a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000454c:	8c 69       	ld.sh	r9,r6[0xc]
8000454e:	3f f8       	mov	r8,-1
80004550:	f0 09 19 00 	cp.h	r9,r8
80004554:	c0 e1       	brne	80004570 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004556:	4a 08       	lddpc	r8,800045d4 <xnl_tx+0xcc>
80004558:	90 49       	ld.sh	r9,r8[0x8]
8000455a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000455c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000455e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004560:	90 49       	ld.sh	r9,r8[0x8]
80004562:	e0 19 ff 00 	andl	r9,0xff00
80004566:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000456a:	f3 e8 10 08 	or	r8,r9,r8
8000456e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004570:	0d 98       	ld.ub	r8,r6[0x1]
80004572:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004574:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004578:	10 0c       	add	r12,r8
8000457a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000457c:	58 0c       	cp.w	r12,0
8000457e:	e0 89 00 04 	brgt	80004586 <xnl_tx+0x7e>
80004582:	30 09       	mov	r9,0
80004584:	c0 d8       	rjmp	8000459e <xnl_tx+0x96>
80004586:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000458a:	2f ec       	sub	r12,-2
8000458c:	30 09       	mov	r9,0
8000458e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004590:	15 1b       	ld.sh	r11,r10++
80004592:	f6 09 00 09 	add	r9,r11,r9
80004596:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004598:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000459a:	18 38       	cp.w	r8,r12
8000459c:	cf a1       	brne	80004590 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000459e:	5c 39       	neg	r9
800045a0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045a2:	48 e8       	lddpc	r8,800045d8 <xnl_tx+0xd0>
800045a4:	70 0c       	ld.w	r12,r8[0x0]
800045a6:	f0 1f 00 0e 	mcall	800045dc <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800045aa:	c1 00       	breq	800045ca <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045ac:	fa c7 ff fc 	sub	r7,sp,-4
800045b0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800045b2:	e0 6a 01 00 	mov	r10,256
800045b6:	0c 9b       	mov	r11,r6
800045b8:	f0 1f 00 0a 	mcall	800045e0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800045bc:	48 a8       	lddpc	r8,800045e4 <xnl_tx+0xdc>
800045be:	70 0c       	ld.w	r12,r8[0x0]
800045c0:	30 09       	mov	r9,0
800045c2:	12 9a       	mov	r10,r9
800045c4:	1a 9b       	mov	r11,sp
800045c6:	f0 1f 00 09 	mcall	800045e8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800045ca:	2f fd       	sub	sp,-4
800045cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045d0:	00 00       	add	r0,r0
800045d2:	0b 48       	ld.w	r8,--r5
800045d4:	00 00       	add	r0,r0
800045d6:	0b 4a       	ld.w	r10,--r5
800045d8:	00 00       	add	r0,r0
800045da:	0a a4       	st.w	r5++,r4
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	2d b8       	sub	r8,-37
800045e0:	80 00       	ld.sh	r0,r0[0x0]
800045e2:	78 68       	ld.w	r8,r12[0x18]
800045e4:	00 00       	add	r0,r0
800045e6:	0b 58       	ld.sh	r8,--r5
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	63 ac       	ld.w	r12,r1[0x68]

800045ec <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800045ec:	eb cd 40 80 	pushm	r7,lr
800045f0:	fa cd 01 00 	sub	sp,sp,256
800045f4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045f6:	e0 68 40 0e 	mov	r8,16398
800045fa:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045fc:	3f f8       	mov	r8,-1
800045fe:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004600:	30 c8       	mov	r8,12
80004602:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004604:	98 38       	ld.sh	r8,r12[0x6]
80004606:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004608:	98 58       	ld.sh	r8,r12[0xa]
8000460a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000460c:	98 48       	ld.sh	r8,r12[0x8]
8000460e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004610:	98 68       	ld.sh	r8,r12[0xc]
80004612:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004614:	30 08       	mov	r8,0
80004616:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004618:	1a 9c       	mov	r12,sp
8000461a:	f0 1f 00 0a 	mcall	80004640 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000461e:	fa cd 00 cc 	sub	sp,sp,204
80004622:	e0 6a 00 ca 	mov	r10,202
80004626:	ee cb ff f0 	sub	r11,r7,-16
8000462a:	1a 9c       	mov	r12,sp
8000462c:	f0 1f 00 06 	mcall	80004644 <xnl_data_msg_func+0x58>
80004630:	48 68       	lddpc	r8,80004648 <xnl_data_msg_func+0x5c>
80004632:	70 08       	ld.w	r8,r8[0x0]
80004634:	5d 18       	icall	r8
80004636:	fa cd ff 34 	sub	sp,sp,-204
}
8000463a:	2c 0d       	sub	sp,-256
8000463c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	45 08       	lddsp	r8,sp[0x140]
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	78 68       	ld.w	r8,r12[0x18]
80004648:	00 00       	add	r0,r0
8000464a:	0b 64       	ld.uh	r4,--r5

8000464c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000464c:	d4 21       	pushm	r4-r7,lr
8000464e:	fa cd 01 00 	sub	sp,sp,256
80004652:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004654:	4c 28       	lddpc	r8,8000475c <xnl_device_auth_reply_func+0x110>
80004656:	11 88       	ld.ub	r8,r8[0x0]
80004658:	58 08       	cp.w	r8,0
8000465a:	e0 81 00 7f 	brne	80004758 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000465e:	4c 18       	lddpc	r8,80004760 <xnl_device_auth_reply_func+0x114>
80004660:	70 0c       	ld.w	r12,r8[0x0]
80004662:	30 09       	mov	r9,0
80004664:	12 9a       	mov	r10,r9
80004666:	12 9b       	mov	r11,r9
80004668:	f0 1f 00 3f 	mcall	80004764 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000466c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004670:	4b b8       	lddpc	r8,8000475c <xnl_device_auth_reply_func+0x110>
80004672:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004674:	ef 39 00 12 	ld.ub	r9,r7[18]
80004678:	ef 38 00 13 	ld.ub	r8,r7[19]
8000467c:	b1 68       	lsl	r8,0x10
8000467e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004682:	ef 38 00 15 	ld.ub	r8,r7[21]
80004686:	f3 e8 10 08 	or	r8,r9,r8
8000468a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000468e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004692:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004696:	ef 38 00 17 	ld.ub	r8,r7[23]
8000469a:	b1 68       	lsl	r8,0x10
8000469c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800046a0:	ef 38 00 19 	ld.ub	r8,r7[25]
800046a4:	f5 e8 10 08 	or	r8,r10,r8
800046a8:	ef 3a 00 18 	ld.ub	r10,r7[24]
800046ac:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800046b0:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046b2:	e0 64 79 b9 	mov	r4,31161
800046b6:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046ba:	e0 65 45 07 	mov	r5,17671
800046be:	ea 15 8a bd 	orh	r5,0x8abd
800046c2:	e0 66 f9 3d 	mov	r6,63805
800046c6:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046ca:	e0 6e b8 cf 	mov	lr,47311
800046ce:	ea 1e 36 83 	orh	lr,0x3683
800046d2:	e0 67 aa 1c 	mov	r7,43548
800046d6:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046da:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046dc:	f4 08 00 0c 	add	r12,r10,r8
800046e0:	f0 0b 15 04 	lsl	r11,r8,0x4
800046e4:	0a 0b       	add	r11,r5
800046e6:	f9 eb 20 0b 	eor	r11,r12,r11
800046ea:	f0 0c 16 05 	lsr	r12,r8,0x5
800046ee:	0c 0c       	add	r12,r6
800046f0:	18 5b       	eor	r11,r12
800046f2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046f4:	f2 0c 15 04 	lsl	r12,r9,0x4
800046f8:	1c 0c       	add	r12,lr
800046fa:	f2 0b 16 05 	lsr	r11,r9,0x5
800046fe:	0e 0b       	add	r11,r7
80004700:	f9 eb 20 0b 	eor	r11,r12,r11
80004704:	f2 0a 00 0c 	add	r12,r9,r10
80004708:	18 5b       	eor	r11,r12
8000470a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000470c:	e0 6b 37 20 	mov	r11,14112
80004710:	ea 1b c6 ef 	orh	r11,0xc6ef
80004714:	16 3a       	cp.w	r10,r11
80004716:	ce 21       	brne	800046da <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004718:	e0 6a 40 1a 	mov	r10,16410
8000471c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000471e:	3f fa       	mov	r10,-1
80004720:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004722:	30 6b       	mov	r11,6
80004724:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004726:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004728:	48 db       	lddpc	r11,8000475c <xnl_device_auth_reply_func+0x110>
8000472a:	96 1c       	ld.sh	r12,r11[0x2]
8000472c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000472e:	96 2b       	ld.sh	r11,r11[0x4]
80004730:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004732:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004734:	30 ca       	mov	r10,12
80004736:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004738:	30 0a       	mov	r10,0
8000473a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000473e:	30 7a       	mov	r10,7
80004740:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004744:	30 2a       	mov	r10,2
80004746:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000474a:	fa ca ff ec 	sub	r10,sp,-20
8000474e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004750:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004752:	1a 9c       	mov	r12,sp
80004754:	f0 1f 00 05 	mcall	80004768 <xnl_device_auth_reply_func+0x11c>
}
80004758:	2c 0d       	sub	sp,-256
8000475a:	d8 22       	popm	r4-r7,pc
8000475c:	00 00       	add	r0,r0
8000475e:	0b 4a       	ld.w	r10,--r5
80004760:	00 00       	add	r0,r0
80004762:	0b 44       	ld.w	r4,--r5
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	63 ac       	ld.w	r12,r1[0x68]
80004768:	80 00       	ld.sh	r0,r0[0x0]
8000476a:	45 08       	lddsp	r8,sp[0x140]

8000476c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000476c:	eb cd 40 80 	pushm	r7,lr
80004770:	fa cd 01 00 	sub	sp,sp,256
80004774:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004776:	49 28       	lddpc	r8,800047bc <xnl_master_status_brdcst_func+0x50>
80004778:	11 88       	ld.ub	r8,r8[0x0]
8000477a:	58 08       	cp.w	r8,0
8000477c:	c1 c1       	brne	800047b4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000477e:	49 18       	lddpc	r8,800047c0 <xnl_master_status_brdcst_func+0x54>
80004780:	70 0c       	ld.w	r12,r8[0x0]
80004782:	30 09       	mov	r9,0
80004784:	12 9a       	mov	r10,r9
80004786:	12 9b       	mov	r11,r9
80004788:	f0 1f 00 0f 	mcall	800047c4 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000478c:	8e 58       	ld.sh	r8,r7[0xa]
8000478e:	48 c9       	lddpc	r9,800047bc <xnl_master_status_brdcst_func+0x50>
80004790:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004792:	e0 68 40 0e 	mov	r8,16398
80004796:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004798:	3f f8       	mov	r8,-1
8000479a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000479c:	30 4a       	mov	r10,4
8000479e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047a0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047a2:	92 19       	ld.sh	r9,r9[0x2]
800047a4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800047a6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047a8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800047aa:	30 08       	mov	r8,0
800047ac:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800047ae:	1a 9c       	mov	r12,sp
800047b0:	f0 1f 00 06 	mcall	800047c8 <xnl_master_status_brdcst_func+0x5c>
}
800047b4:	2c 0d       	sub	sp,-256
800047b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800047ba:	00 00       	add	r0,r0
800047bc:	00 00       	add	r0,r0
800047be:	0b 4a       	ld.w	r10,--r5
800047c0:	00 00       	add	r0,r0
800047c2:	0b 44       	ld.w	r4,--r5
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	63 ac       	ld.w	r12,r1[0x68]
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	45 08       	lddsp	r8,sp[0x140]

800047cc <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800047cc:	eb cd 40 80 	pushm	r7,lr
800047d0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800047d2:	49 28       	lddpc	r8,80004818 <xnl_device_conn_reply_func+0x4c>
800047d4:	70 0c       	ld.w	r12,r8[0x0]
800047d6:	30 09       	mov	r9,0
800047d8:	12 9a       	mov	r10,r9
800047da:	12 9b       	mov	r11,r9
800047dc:	f0 1f 00 10 	mcall	8000481c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800047e0:	ef 18 00 10 	ld.uh	r8,r7[16]
800047e4:	10 99       	mov	r9,r8
800047e6:	e2 19 ff 00 	andl	r9,0xff00,COH
800047ea:	e0 49 01 00 	cp.w	r9,256
800047ee:	c0 60       	breq	800047fa <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800047f0:	0e 9c       	mov	r12,r7
800047f2:	f0 1f 00 0c 	mcall	80004820 <xnl_device_conn_reply_func+0x54>
800047f6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800047fa:	a9 68       	lsl	r8,0x8
800047fc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004800:	48 98       	lddpc	r8,80004824 <xnl_device_conn_reply_func+0x58>
80004802:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004804:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004808:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000480a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000480e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004810:	30 19       	mov	r9,1
80004812:	b0 89       	st.b	r8[0x0],r9
80004814:	e3 cd 80 80 	ldm	sp++,r7,pc
80004818:	00 00       	add	r0,r0
8000481a:	0b 44       	ld.w	r4,--r5
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	63 ac       	ld.w	r12,r1[0x68]
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	47 6c       	lddsp	r12,sp[0x1d8]
80004824:	00 00       	add	r0,r0
80004826:	0b 4a       	ld.w	r10,--r5

80004828 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004828:	d4 01       	pushm	lr
8000482a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000482e:	e0 68 40 0e 	mov	r8,16398
80004832:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004834:	3f f8       	mov	r8,-1
80004836:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004838:	30 38       	mov	r8,3
8000483a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000483c:	30 08       	mov	r8,0
8000483e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004840:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004842:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004844:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004846:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004848:	1a 9c       	mov	r12,sp
8000484a:	f0 1f 00 03 	mcall	80004854 <xnl_send_device_master_query+0x2c>
}
8000484e:	2c 0d       	sub	sp,-256
80004850:	d8 02       	popm	pc
80004852:	00 00       	add	r0,r0
80004854:	80 00       	ld.sh	r0,r0[0x0]
80004856:	45 08       	lddsp	r8,sp[0x140]

80004858 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004858:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000485a:	48 78       	lddpc	r8,80004874 <RC522_SPI_SetSpeed+0x1c>
8000485c:	70 09       	ld.w	r9,r8[0x0]
8000485e:	72 ca       	ld.w	r10,r9[0x30]
80004860:	5c 7c       	castu.h	r12
80004862:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004866:	f9 ea 10 0a 	or	r10,r12,r10
8000486a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000486c:	70 0c       	ld.w	r12,r8[0x0]
8000486e:	f0 1f 00 03 	mcall	80004878 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004872:	d8 02       	popm	pc
80004874:	00 00       	add	r0,r0
80004876:	20 24       	sub	r4,2
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	58 9c       	cp.w	r12,9

8000487c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000487c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
8000487e:	e0 6c 04 00 	mov	r12,1024
80004882:	f0 1f 00 02 	mcall	80004888 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004886:	d8 02       	popm	pc
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	48 58       	lddpc	r8,8000489c <RC522_ReadByte+0x10>

8000488c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000488c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004890:	48 76       	lddpc	r6,800048ac <RC522_ReadByte+0x20>
80004892:	e0 6b 00 ff 	mov	r11,255
80004896:	6c 0c       	ld.w	r12,r6[0x0]
80004898:	f0 1f 00 06 	mcall	800048b0 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000489c:	30 07       	mov	r7,0
8000489e:	0e 9b       	mov	r11,r7
800048a0:	6c 0c       	ld.w	r12,r6[0x0]
800048a2:	f0 1f 00 05 	mcall	800048b4 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800048a6:	0f 9c       	ld.ub	r12,r7[0x1]
800048a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048ac:	00 00       	add	r0,r0
800048ae:	20 24       	sub	r4,2
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	58 a2       	cp.w	r2,10
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	58 be       	cp.w	lr,11

800048b8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800048b8:	eb cd 40 80 	pushm	r7,lr
800048bc:	20 1d       	sub	sp,4
800048be:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800048c0:	48 77       	lddpc	r7,800048dc <RC522_WriteByte+0x24>
800048c2:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800048c6:	6e 0c       	ld.w	r12,r7[0x0]
800048c8:	f0 1f 00 06 	mcall	800048e0 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800048cc:	1a 9b       	mov	r11,sp
800048ce:	6e 0c       	ld.w	r12,r7[0x0]
800048d0:	f0 1f 00 05 	mcall	800048e4 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048d4:	5c 5c       	castu.b	r12
800048d6:	2f fd       	sub	sp,-4
800048d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800048dc:	00 00       	add	r0,r0
800048de:	20 24       	sub	r4,2
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	58 a2       	cp.w	r2,10
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	58 be       	cp.w	lr,11

800048e8 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800048e8:	eb cd 40 e0 	pushm	r5-r7,lr
800048ec:	18 96       	mov	r6,r12
800048ee:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048f0:	48 a7       	lddpc	r7,80004918 <WriteRawRC+0x30>
800048f2:	30 0b       	mov	r11,0
800048f4:	6e 0c       	ld.w	r12,r7[0x0]
800048f6:	f0 1f 00 0a 	mcall	8000491c <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800048fa:	ec 0c 15 01 	lsl	r12,r6,0x1
800048fe:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004902:	f0 1f 00 08 	mcall	80004920 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80004906:	0a 9c       	mov	r12,r5
80004908:	f0 1f 00 06 	mcall	80004920 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000490c:	30 0b       	mov	r11,0
8000490e:	6e 0c       	ld.w	r12,r7[0x0]
80004910:	f0 1f 00 05 	mcall	80004924 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004914:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004918:	00 00       	add	r0,r0
8000491a:	20 24       	sub	r4,2
8000491c:	80 00       	ld.sh	r0,r0[0x0]
8000491e:	5a 08       	cp.w	r8,-32
80004920:	80 00       	ld.sh	r0,r0[0x0]
80004922:	48 b8       	lddpc	r8,8000494c <PcdReset+0x24>
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	59 c8       	cp.w	r8,28

80004928 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004928:	d4 01       	pushm	lr

	SET_RC522RST;
8000492a:	31 9c       	mov	r12,25
8000492c:	f0 1f 00 1b 	mcall	80004998 <PcdReset+0x70>
	delay_ns(10);
80004930:	30 ac       	mov	r12,10
80004932:	f0 1f 00 1b 	mcall	8000499c <PcdReset+0x74>

	CLR_RC522RST;
80004936:	31 9c       	mov	r12,25
80004938:	f0 1f 00 1a 	mcall	800049a0 <PcdReset+0x78>
	delay_ns(10);
8000493c:	30 ac       	mov	r12,10
8000493e:	f0 1f 00 18 	mcall	8000499c <PcdReset+0x74>

	SET_RC522RST;
80004942:	31 9c       	mov	r12,25
80004944:	f0 1f 00 15 	mcall	80004998 <PcdReset+0x70>
	delay_ns(10);
80004948:	30 ac       	mov	r12,10
8000494a:	f0 1f 00 15 	mcall	8000499c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000494e:	30 fb       	mov	r11,15
80004950:	30 1c       	mov	r12,1
80004952:	f0 1f 00 15 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004956:	30 fb       	mov	r11,15
80004958:	30 1c       	mov	r12,1
8000495a:	f0 1f 00 13 	mcall	800049a4 <PcdReset+0x7c>
	delay_ns(10);
8000495e:	30 ac       	mov	r12,10
80004960:	f0 1f 00 0f 	mcall	8000499c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004964:	33 db       	mov	r11,61
80004966:	31 1c       	mov	r12,17
80004968:	f0 1f 00 0f 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000496c:	31 eb       	mov	r11,30
8000496e:	32 dc       	mov	r12,45
80004970:	f0 1f 00 0d 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004974:	30 0b       	mov	r11,0
80004976:	32 cc       	mov	r12,44
80004978:	f0 1f 00 0b 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000497c:	e0 6b 00 8d 	mov	r11,141
80004980:	32 ac       	mov	r12,42
80004982:	f0 1f 00 09 	mcall	800049a4 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004986:	33 eb       	mov	r11,62
80004988:	32 bc       	mov	r12,43
8000498a:	f0 1f 00 07 	mcall	800049a4 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000498e:	34 0b       	mov	r11,64
80004990:	31 5c       	mov	r12,21
80004992:	f0 1f 00 05 	mcall	800049a4 <PcdReset+0x7c>
	
	return MI_OK;
}
80004996:	d8 0a       	popm	pc,r12=0
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	54 10       	stdsp	sp[0x104],r0
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	51 a8       	stdsp	sp[0x68],r8
800049a0:	80 00       	ld.sh	r0,r0[0x0]
800049a2:	54 2c       	stdsp	sp[0x108],r12
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	48 e8       	lddpc	r8,800049dc <ReadRawRC+0x34>

800049a8 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800049a8:	eb cd 40 c0 	pushm	r6-r7,lr
800049ac:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800049ae:	48 c7       	lddpc	r7,800049dc <ReadRawRC+0x34>
800049b0:	30 0b       	mov	r11,0
800049b2:	6e 0c       	ld.w	r12,r7[0x0]
800049b4:	f0 1f 00 0b 	mcall	800049e0 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800049b8:	a1 76       	lsl	r6,0x1
800049ba:	0c 9c       	mov	r12,r6
800049bc:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049c0:	a7 bc       	sbr	r12,0x7
800049c2:	f0 1f 00 09 	mcall	800049e4 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800049c6:	f0 1f 00 09 	mcall	800049e8 <ReadRawRC+0x40>
800049ca:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800049cc:	30 0b       	mov	r11,0
800049ce:	6e 0c       	ld.w	r12,r7[0x0]
800049d0:	f0 1f 00 07 	mcall	800049ec <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800049d4:	0c 9c       	mov	r12,r6
800049d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049da:	00 00       	add	r0,r0
800049dc:	00 00       	add	r0,r0
800049de:	20 24       	sub	r4,2
800049e0:	80 00       	ld.sh	r0,r0[0x0]
800049e2:	5a 08       	cp.w	r8,-32
800049e4:	80 00       	ld.sh	r0,r0[0x0]
800049e6:	48 b8       	lddpc	r8,80004a10 <SetBitMask+0x20>
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	48 8c       	lddpc	r12,80004a08 <SetBitMask+0x18>
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	59 c8       	cp.w	r8,28

800049f0 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800049f0:	eb cd 40 c0 	pushm	r6-r7,lr
800049f4:	18 97       	mov	r7,r12
800049f6:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800049f8:	f0 1f 00 05 	mcall	80004a0c <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800049fc:	f9 e6 10 0b 	or	r11,r12,r6
80004a00:	5c 5b       	castu.b	r11
80004a02:	0e 9c       	mov	r12,r7
80004a04:	f0 1f 00 03 	mcall	80004a10 <SetBitMask+0x20>
}
80004a08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	49 a8       	lddpc	r8,80004a74 <M500PcdConfigISOType+0x8>
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	48 e8       	lddpc	r8,80004a48 <ClearBitMask+0x14>

80004a14 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a14:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a16:	31 4c       	mov	r12,20
80004a18:	f0 1f 00 05 	mcall	80004a2c <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a1c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a20:	c0 51       	brne	80004a2a <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a22:	30 3b       	mov	r11,3
80004a24:	31 4c       	mov	r12,20
80004a26:	f0 1f 00 03 	mcall	80004a30 <PcdAntennaOn+0x1c>
80004a2a:	d8 02       	popm	pc
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	49 a8       	lddpc	r8,80004a94 <M500PcdConfigISOType+0x28>
80004a30:	80 00       	ld.sh	r0,r0[0x0]
80004a32:	49 f0       	lddpc	r0,80004aac <M500PcdConfigISOType+0x40>

80004a34 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004a34:	eb cd 40 c0 	pushm	r6-r7,lr
80004a38:	18 97       	mov	r7,r12
80004a3a:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004a3c:	f0 1f 00 06 	mcall	80004a54 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004a40:	5c d6       	com	r6
80004a42:	f9 e6 00 06 	and	r6,r12,r6
80004a46:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004a4a:	0e 9c       	mov	r12,r7
80004a4c:	f0 1f 00 03 	mcall	80004a58 <ClearBitMask+0x24>
	
}
80004a50:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	49 a8       	lddpc	r8,80004abc <M500PcdConfigISOType+0x50>
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	48 e8       	lddpc	r8,80004a90 <M500PcdConfigISOType+0x24>

80004a5c <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004a5c:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004a5e:	30 3b       	mov	r11,3
80004a60:	31 4c       	mov	r12,20
80004a62:	f0 1f 00 02 	mcall	80004a68 <PcdAntennaOff+0xc>
}
80004a66:	d8 02       	popm	pc
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	4a 34       	lddpc	r4,80004af4 <rc522_init+0x18>

80004a6c <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004a6c:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004a6e:	34 18       	mov	r8,65
80004a70:	f0 0c 18 00 	cp.b	r12,r8
80004a74:	c0 20       	breq	80004a78 <M500PcdConfigISOType+0xc>
80004a76:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004a78:	30 8b       	mov	r11,8
80004a7a:	16 9c       	mov	r12,r11
80004a7c:	f0 1f 00 14 	mcall	80004acc <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004a80:	33 db       	mov	r11,61
80004a82:	31 1c       	mov	r12,17
80004a84:	f0 1f 00 13 	mcall	80004ad0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004a88:	e0 6b 00 86 	mov	r11,134
80004a8c:	31 7c       	mov	r12,23
80004a8e:	f0 1f 00 11 	mcall	80004ad0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004a92:	37 fb       	mov	r11,127
80004a94:	32 6c       	mov	r12,38
80004a96:	f0 1f 00 0f 	mcall	80004ad0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004a9a:	31 eb       	mov	r11,30
80004a9c:	32 dc       	mov	r12,45
80004a9e:	f0 1f 00 0d 	mcall	80004ad0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004aa2:	30 0b       	mov	r11,0
80004aa4:	32 cc       	mov	r12,44
80004aa6:	f0 1f 00 0b 	mcall	80004ad0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004aaa:	e0 6b 00 8d 	mov	r11,141
80004aae:	32 ac       	mov	r12,42
80004ab0:	f0 1f 00 08 	mcall	80004ad0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004ab4:	33 eb       	mov	r11,62
80004ab6:	32 bc       	mov	r12,43
80004ab8:	f0 1f 00 06 	mcall	80004ad0 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004abc:	e0 6c 03 e8 	mov	r12,1000
80004ac0:	f0 1f 00 05 	mcall	80004ad4 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004ac4:	f0 1f 00 05 	mcall	80004ad8 <M500PcdConfigISOType+0x6c>
80004ac8:	d8 0a       	popm	pc,r12=0
80004aca:	00 00       	add	r0,r0
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	4a 34       	lddpc	r4,80004b58 <rc522_init+0x7c>
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	48 e8       	lddpc	r8,80004b08 <rc522_init+0x2c>
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	51 a8       	stdsp	sp[0x68],r8
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	4a 14       	lddpc	r4,80004b5c <rc522_init+0x80>

80004adc <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004adc:	eb cd 40 c0 	pushm	r6-r7,lr
80004ae0:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004ae2:	4a 28       	lddpc	r8,80004b68 <rc522_init+0x8c>
80004ae4:	1a 96       	mov	r6,sp
80004ae6:	f0 ea 00 00 	ld.d	r10,r8[0]
80004aea:	fa eb 00 00 	st.d	sp[0],r10
80004aee:	f0 e8 00 08 	ld.d	r8,r8[8]
80004af2:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004af6:	30 4b       	mov	r11,4
80004af8:	49 dc       	lddpc	r12,80004b6c <rc522_init+0x90>
80004afa:	f0 1f 00 1e 	mcall	80004b70 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004afe:	31 9c       	mov	r12,25
80004b00:	f0 1f 00 1d 	mcall	80004b74 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004b04:	31 9c       	mov	r12,25
80004b06:	f0 1f 00 1d 	mcall	80004b78 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004b0a:	49 d7       	lddpc	r7,80004b7c <rc522_init+0xa0>
80004b0c:	fe 7c 24 00 	mov	r12,-56320
80004b10:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004b12:	1a 9b       	mov	r11,sp
80004b14:	f0 1f 00 1b 	mcall	80004b80 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b18:	30 09       	mov	r9,0
80004b1a:	12 9a       	mov	r10,r9
80004b1c:	12 9b       	mov	r11,r9
80004b1e:	6e 0c       	ld.w	r12,r7[0x0]
80004b20:	f0 1f 00 19 	mcall	80004b84 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004b24:	6e 0c       	ld.w	r12,r7[0x0]
80004b26:	f0 1f 00 19 	mcall	80004b88 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004b2a:	e0 6a 36 00 	mov	r10,13824
80004b2e:	ea 1a 01 6e 	orh	r10,0x16e
80004b32:	1a 9b       	mov	r11,sp
80004b34:	6e 0c       	ld.w	r12,r7[0x0]
80004b36:	f0 1f 00 16 	mcall	80004b8c <rc522_init+0xb0>
80004b3a:	c0 50       	breq	80004b44 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004b3c:	30 29       	mov	r9,2
80004b3e:	49 58       	lddpc	r8,80004b90 <rc522_init+0xb4>
80004b40:	b0 89       	st.b	r8[0x0],r9
80004b42:	c0 38       	rjmp	80004b48 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004b44:	f0 1f 00 14 	mcall	80004b94 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004b48:	f0 1f 00 14 	mcall	80004b98 <rc522_init+0xbc>
	
	PcdAntennaOff();
80004b4c:	f0 1f 00 14 	mcall	80004b9c <rc522_init+0xc0>
	
	delay_ms(2); 
80004b50:	30 2c       	mov	r12,2
80004b52:	f0 1f 00 14 	mcall	80004ba0 <rc522_init+0xc4>
	
	PcdAntennaOn();
80004b56:	f0 1f 00 14 	mcall	80004ba4 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004b5a:	34 1c       	mov	r12,65
80004b5c:	f0 1f 00 13 	mcall	80004ba8 <rc522_init+0xcc>
	

80004b60:	2f cd       	sub	sp,-16
80004b62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b66:	00 00       	add	r0,r0
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	d8 24       	*unknown*
80004b6c:	80 00       	ld.sh	r0,r0[0x0]
80004b6e:	d8 04       	*unknown*
80004b70:	80 00       	ld.sh	r0,r0[0x0]
80004b72:	53 c8       	stdsp	sp[0xf0],r8
80004b74:	80 00       	ld.sh	r0,r0[0x0]
80004b76:	53 f8       	stdsp	sp[0xfc],r8
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	54 10       	stdsp	sp[0x104],r0
80004b7c:	00 00       	add	r0,r0
80004b7e:	20 24       	sub	r4,2
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	58 38       	cp.w	r8,3
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	58 70       	cp.w	r0,7
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	58 9c       	cp.w	r12,9
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	58 e0       	cp.w	r0,14
80004b90:	00 00       	add	r0,r0
80004b92:	0b 68       	ld.uh	r8,--r5
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	48 7c       	lddpc	r12,80004bb0 <PcdComMF522+0x4>
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	49 28       	lddpc	r8,80004be0 <PcdComMF522+0x34>
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	4a 5c       	lddpc	r12,80004c30 <PcdComMF522+0x84>
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	51 e8       	stdsp	sp[0x78],r8
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	4a 14       	lddpc	r4,80004c28 <PcdComMF522+0x7c>
80004ba8:	80 00       	ld.sh	r0,r0[0x0]
80004baa:	4a 6c       	lddpc	r12,80004c40 <PcdComMF522+0x94>

80004bac <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004bac:	d4 31       	pushm	r0-r7,lr
80004bae:	20 1d       	sub	sp,4
80004bb0:	18 92       	mov	r2,r12
80004bb2:	16 95       	mov	r5,r11
80004bb4:	14 96       	mov	r6,r10
80004bb6:	50 09       	stdsp	sp[0x0],r9
80004bb8:	10 90       	mov	r0,r8
80004bba:	f8 c8 00 0c 	sub	r8,r12,12
80004bbe:	5c 58       	castu.b	r8
80004bc0:	30 29       	mov	r9,2
80004bc2:	f2 08 18 00 	cp.b	r8,r9
80004bc6:	e0 88 00 05 	brls	80004bd0 <PcdComMF522+0x24>
80004bca:	30 03       	mov	r3,0
80004bcc:	06 91       	mov	r1,r3
80004bce:	c0 78       	rjmp	80004bdc <PcdComMF522+0x30>
80004bd0:	4c f9       	lddpc	r9,80004d0c <PcdComMF522+0x160>
80004bd2:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004bd6:	4c f9       	lddpc	r9,80004d10 <PcdComMF522+0x164>
80004bd8:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004bdc:	02 9b       	mov	r11,r1
80004bde:	a7 bb       	sbr	r11,0x7
80004be0:	30 2c       	mov	r12,2
80004be2:	f0 1f 00 4d 	mcall	80004d14 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004be6:	e0 6b 00 80 	mov	r11,128
80004bea:	30 4c       	mov	r12,4
80004bec:	f0 1f 00 4b 	mcall	80004d18 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004bf0:	30 0b       	mov	r11,0
80004bf2:	30 1c       	mov	r12,1
80004bf4:	f0 1f 00 48 	mcall	80004d14 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004bf8:	e0 6b 00 80 	mov	r11,128
80004bfc:	30 ac       	mov	r12,10
80004bfe:	f0 1f 00 48 	mcall	80004d1c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004c02:	58 06       	cp.w	r6,0
80004c04:	c0 c0       	breq	80004c1c <PcdComMF522+0x70>
80004c06:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004c08:	30 94       	mov	r4,9
80004c0a:	0f 3b       	ld.ub	r11,r7++
80004c0c:	08 9c       	mov	r12,r4
80004c0e:	f0 1f 00 42 	mcall	80004d14 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c12:	0e 98       	mov	r8,r7
80004c14:	0a 18       	sub	r8,r5
80004c16:	ec 08 19 00 	cp.h	r8,r6
80004c1a:	cf 83       	brcs	80004c0a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c1c:	04 9b       	mov	r11,r2
80004c1e:	30 1c       	mov	r12,1
80004c20:	f0 1f 00 3d 	mcall	80004d14 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c24:	30 c8       	mov	r8,12
80004c26:	f0 02 18 00 	cp.b	r2,r8
80004c2a:	c0 61       	brne	80004c36 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004c2c:	e0 6b 00 80 	mov	r11,128
80004c30:	30 dc       	mov	r12,13
80004c32:	f0 1f 00 3b 	mcall	80004d1c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c36:	30 4c       	mov	r12,4
80004c38:	f0 1f 00 3a 	mcall	80004d20 <PcdComMF522+0x174>
80004c3c:	18 97       	mov	r7,r12
80004c3e:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c42:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c44:	30 44       	mov	r4,4
80004c46:	c0 88       	rjmp	80004c56 <PcdComMF522+0xaa>
80004c48:	08 9c       	mov	r12,r4
80004c4a:	f0 1f 00 36 	mcall	80004d20 <PcdComMF522+0x174>
80004c4e:	18 97       	mov	r7,r12
		i--;
80004c50:	20 16       	sub	r6,1
80004c52:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c54:	c0 a0       	breq	80004c68 <PcdComMF522+0xbc>
80004c56:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004c5a:	c4 c1       	brne	80004cf2 <PcdComMF522+0x146>
80004c5c:	ef e3 00 08 	and	r8,r7,r3
80004c60:	ea 08 18 00 	cp.b	r8,r5
80004c64:	cf 20       	breq	80004c48 <PcdComMF522+0x9c>
80004c66:	c4 68       	rjmp	80004cf2 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004c68:	e0 6b 00 80 	mov	r11,128
80004c6c:	30 dc       	mov	r12,13
80004c6e:	f0 1f 00 2b 	mcall	80004d18 <PcdComMF522+0x16c>
80004c72:	30 27       	mov	r7,2
80004c74:	c3 38       	rjmp	80004cda <PcdComMF522+0x12e>
80004c76:	02 67       	and	r7,r1
80004c78:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004c7c:	30 c8       	mov	r8,12
80004c7e:	f0 02 18 00 	cp.b	r2,r8
80004c82:	c2 c1       	brne	80004cda <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004c84:	30 ac       	mov	r12,10
80004c86:	f0 1f 00 27 	mcall	80004d20 <PcdComMF522+0x174>
80004c8a:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004c8c:	30 cc       	mov	r12,12
80004c8e:	f0 1f 00 25 	mcall	80004d20 <PcdComMF522+0x174>
80004c92:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004c96:	c0 70       	breq	80004ca4 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004c98:	08 98       	mov	r8,r4
80004c9a:	20 18       	sub	r8,1
80004c9c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004ca0:	a0 8c       	st.b	r0[0x0],r12
80004ca2:	c0 48       	rjmp	80004caa <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004ca4:	e8 08 15 03 	lsl	r8,r4,0x3
80004ca8:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004caa:	58 04       	cp.w	r4,0
80004cac:	c0 61       	brne	80004cb8 <PcdComMF522+0x10c>
80004cae:	30 14       	mov	r4,1
80004cb0:	40 05       	lddsp	r5,sp[0x0]
80004cb2:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004cb4:	30 93       	mov	r3,9
80004cb6:	c0 98       	rjmp	80004cc8 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004cb8:	31 28       	mov	r8,18
80004cba:	f0 04 18 00 	cp.b	r4,r8
80004cbe:	f9 b4 0b 12 	movhi	r4,18
80004cc2:	58 04       	cp.w	r4,0
80004cc4:	cf 61       	brne	80004cb0 <PcdComMF522+0x104>
80004cc6:	c0 a8       	rjmp	80004cda <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004cc8:	06 9c       	mov	r12,r3
80004cca:	f0 1f 00 16 	mcall	80004d20 <PcdComMF522+0x174>
80004cce:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004cd0:	ec 05 01 08 	sub	r8,r6,r5
80004cd4:	e8 08 19 00 	cp.h	r8,r4
80004cd8:	cf 83       	brcs	80004cc8 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004cda:	e0 6b 00 80 	mov	r11,128
80004cde:	30 cc       	mov	r12,12
80004ce0:	f0 1f 00 0f 	mcall	80004d1c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004ce4:	30 0b       	mov	r11,0
80004ce6:	30 1c       	mov	r12,1
80004ce8:	f0 1f 00 0b 	mcall	80004d14 <PcdComMF522+0x168>
	return status;
}
80004cec:	0e 9c       	mov	r12,r7
80004cee:	2f fd       	sub	sp,-4
80004cf0:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004cf2:	e0 6b 00 80 	mov	r11,128
80004cf6:	30 dc       	mov	r12,13
80004cf8:	f0 1f 00 08 	mcall	80004d18 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004cfc:	30 6c       	mov	r12,6
80004cfe:	f0 1f 00 09 	mcall	80004d20 <PcdComMF522+0x174>
80004d02:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004d06:	cb 80       	breq	80004c76 <PcdComMF522+0xca>
80004d08:	30 27       	mov	r7,2
80004d0a:	ce 8b       	rjmp	80004cda <PcdComMF522+0x12e>
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	d8 34       	*unknown*
80004d10:	80 00       	ld.sh	r0,r0[0x0]
80004d12:	d8 00       	acall	0x80
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	48 e8       	lddpc	r8,80004d4c <PcdAnticoll+0x28>
80004d18:	80 00       	ld.sh	r0,r0[0x0]
80004d1a:	4a 34       	lddpc	r4,80004da4 <PcdAnticoll+0x80>
80004d1c:	80 00       	ld.sh	r0,r0[0x0]
80004d1e:	49 f0       	lddpc	r0,80004d98 <PcdAnticoll+0x74>
80004d20:	80 00       	ld.sh	r0,r0[0x0]
80004d22:	49 a8       	lddpc	r8,80004d88 <PcdAnticoll+0x64>

80004d24 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d24:	eb cd 40 c0 	pushm	r6-r7,lr
80004d28:	20 5d       	sub	sp,20
80004d2a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004d2c:	30 8b       	mov	r11,8
80004d2e:	16 9c       	mov	r12,r11
80004d30:	f0 1f 00 1a 	mcall	80004d98 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004d34:	30 0b       	mov	r11,0
80004d36:	30 dc       	mov	r12,13
80004d38:	f0 1f 00 19 	mcall	80004d9c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004d3c:	e0 6b 00 80 	mov	r11,128
80004d40:	30 ec       	mov	r12,14
80004d42:	f0 1f 00 16 	mcall	80004d98 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d46:	39 38       	mov	r8,-109
80004d48:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004d4a:	32 08       	mov	r8,32
80004d4c:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004d4e:	1a 9b       	mov	r11,sp
80004d50:	fa c8 ff ed 	sub	r8,sp,-19
80004d54:	1a 99       	mov	r9,sp
80004d56:	30 2a       	mov	r10,2
80004d58:	30 cc       	mov	r12,12
80004d5a:	f0 1f 00 12 	mcall	80004da0 <PcdAnticoll+0x7c>
80004d5e:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004d60:	c1 21       	brne	80004d84 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d62:	1b 89       	ld.ub	r9,sp[0x0]
80004d64:	ac 89       	st.b	r6[0x0],r9
80004d66:	1b 98       	ld.ub	r8,sp[0x1]
80004d68:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004d6a:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d6c:	1b a8       	ld.ub	r8,sp[0x2]
80004d6e:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004d70:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d74:	1b b9       	ld.ub	r9,sp[0x3]
80004d76:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004d78:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004d7a:	1b c9       	ld.ub	r9,sp[0x4]
80004d7c:	f0 09 18 00 	cp.b	r9,r8
80004d80:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004d84:	e0 6b 00 80 	mov	r11,128
80004d88:	30 ec       	mov	r12,14
80004d8a:	f0 1f 00 07 	mcall	80004da4 <PcdAnticoll+0x80>
	return status;
}
80004d8e:	0e 9c       	mov	r12,r7
80004d90:	2f bd       	sub	sp,-20
80004d92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d96:	00 00       	add	r0,r0
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	4a 34       	lddpc	r4,80004e24 <CalulateCRC+0x18>
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	48 e8       	lddpc	r8,80004dd4 <PcdRequest+0x2c>
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	4b ac       	lddpc	r12,80004e88 <CalulateCRC+0x7c>
80004da4:	80 00       	ld.sh	r0,r0[0x0]
80004da6:	49 f0       	lddpc	r0,80004e20 <CalulateCRC+0x14>

80004da8 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004da8:	eb cd 40 c0 	pushm	r6-r7,lr
80004dac:	20 5d       	sub	sp,20
80004dae:	18 97       	mov	r7,r12
80004db0:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004db2:	30 8b       	mov	r11,8
80004db4:	16 9c       	mov	r12,r11
80004db6:	f0 1f 00 12 	mcall	80004dfc <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004dba:	30 7b       	mov	r11,7
80004dbc:	30 dc       	mov	r12,13
80004dbe:	f0 1f 00 11 	mcall	80004e00 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004dc2:	30 3b       	mov	r11,3
80004dc4:	31 4c       	mov	r12,20
80004dc6:	f0 1f 00 10 	mcall	80004e04 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004dca:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004dcc:	1a 9b       	mov	r11,sp
80004dce:	fa c8 ff ed 	sub	r8,sp,-19
80004dd2:	1a 99       	mov	r9,sp
80004dd4:	30 1a       	mov	r10,1
80004dd6:	30 cc       	mov	r12,12
80004dd8:	f0 1f 00 0c 	mcall	80004e08 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004ddc:	c0 c1       	brne	80004df4 <PcdRequest+0x4c>
80004dde:	31 08       	mov	r8,16
80004de0:	fb 39 00 13 	ld.ub	r9,sp[19]
80004de4:	f0 09 18 00 	cp.b	r9,r8
80004de8:	c0 61       	brne	80004df4 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004dea:	1b 88       	ld.ub	r8,sp[0x0]
80004dec:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004dee:	1b 98       	ld.ub	r8,sp[0x1]
80004df0:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004df2:	c0 28       	rjmp	80004df6 <PcdRequest+0x4e>
80004df4:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004df6:	2f bd       	sub	sp,-20
80004df8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	4a 34       	lddpc	r4,80004e88 <CalulateCRC+0x7c>
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	48 e8       	lddpc	r8,80004e38 <CalulateCRC+0x2c>
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	49 f0       	lddpc	r0,80004e80 <CalulateCRC+0x74>
80004e08:	80 00       	ld.sh	r0,r0[0x0]
80004e0a:	4b ac       	lddpc	r12,80004ef0 <PcdSelect+0x58>

80004e0c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004e0c:	eb cd 40 f8 	pushm	r3-r7,lr
80004e10:	18 95       	mov	r5,r12
80004e12:	16 96       	mov	r6,r11
80004e14:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e16:	30 4b       	mov	r11,4
80004e18:	30 5c       	mov	r12,5
80004e1a:	f0 1f 00 1c 	mcall	80004e88 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e1e:	30 0b       	mov	r11,0
80004e20:	30 1c       	mov	r12,1
80004e22:	f0 1f 00 1b 	mcall	80004e8c <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e26:	e0 6b 00 80 	mov	r11,128
80004e2a:	30 ac       	mov	r12,10
80004e2c:	f0 1f 00 19 	mcall	80004e90 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004e30:	58 06       	cp.w	r6,0
80004e32:	c0 c0       	breq	80004e4a <CalulateCRC+0x3e>
80004e34:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004e36:	30 94       	mov	r4,9
80004e38:	0f 3b       	ld.ub	r11,r7++
80004e3a:	08 9c       	mov	r12,r4
80004e3c:	f0 1f 00 14 	mcall	80004e8c <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004e40:	0e 98       	mov	r8,r7
80004e42:	0a 18       	sub	r8,r5
80004e44:	ec 08 18 00 	cp.b	r8,r6
80004e48:	cf 83       	brcs	80004e38 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004e4a:	30 3b       	mov	r11,3
80004e4c:	30 1c       	mov	r12,1
80004e4e:	f0 1f 00 10 	mcall	80004e8c <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004e52:	30 5c       	mov	r12,5
80004e54:	f0 1f 00 10 	mcall	80004e94 <CalulateCRC+0x88>
80004e58:	e0 67 00 fe 	mov	r7,254
80004e5c:	30 56       	mov	r6,5
80004e5e:	c0 78       	rjmp	80004e6c <CalulateCRC+0x60>
80004e60:	0c 9c       	mov	r12,r6
80004e62:	f0 1f 00 0d 	mcall	80004e94 <CalulateCRC+0x88>
		i--;
80004e66:	20 17       	sub	r7,1
80004e68:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004e6a:	c0 40       	breq	80004e72 <CalulateCRC+0x66>
80004e6c:	e2 1c 00 04 	andl	r12,0x4,COH
80004e70:	cf 80       	breq	80004e60 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004e72:	32 2c       	mov	r12,34
80004e74:	f0 1f 00 08 	mcall	80004e94 <CalulateCRC+0x88>
80004e78:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004e7a:	32 1c       	mov	r12,33
80004e7c:	f0 1f 00 06 	mcall	80004e94 <CalulateCRC+0x88>
80004e80:	a6 9c       	st.b	r3[0x1],r12
}
80004e82:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004e86:	00 00       	add	r0,r0
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	4a 34       	lddpc	r4,80004f14 <rfid_auto_reader+0x8>
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	48 e8       	lddpc	r8,80004ec4 <PcdSelect+0x2c>
80004e90:	80 00       	ld.sh	r0,r0[0x0]
80004e92:	49 f0       	lddpc	r0,80004f0c <rfid_auto_reader>
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	49 a8       	lddpc	r8,80004efc <PcdSelect+0x64>

80004e98 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004e98:	eb cd 40 80 	pushm	r7,lr
80004e9c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e9e:	39 38       	mov	r8,-109
80004ea0:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004ea2:	37 08       	mov	r8,112
80004ea4:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004ea6:	30 08       	mov	r8,0
80004ea8:	ba e8       	st.b	sp[0x6],r8
80004eaa:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004eae:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004eb2:	19 89       	ld.ub	r9,r12[0x0]
80004eb4:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004eb6:	19 3a       	ld.ub	r10,r12++
80004eb8:	1b e9       	ld.ub	r9,sp[0x6]
80004eba:	f5 e9 20 09 	eor	r9,r10,r9
80004ebe:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004ec0:	16 38       	cp.w	r8,r11
80004ec2:	cf 81       	brne	80004eb2 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004ec4:	1a 97       	mov	r7,sp
80004ec6:	fa ca ff f9 	sub	r10,sp,-7
80004eca:	30 7b       	mov	r11,7
80004ecc:	1a 9c       	mov	r12,sp
80004ece:	f0 1f 00 0d 	mcall	80004f00 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004ed2:	30 8b       	mov	r11,8
80004ed4:	16 9c       	mov	r12,r11
80004ed6:	f0 1f 00 0c 	mcall	80004f04 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004eda:	fa c8 ff ed 	sub	r8,sp,-19
80004ede:	1a 99       	mov	r9,sp
80004ee0:	30 9a       	mov	r10,9
80004ee2:	1a 9b       	mov	r11,sp
80004ee4:	30 cc       	mov	r12,12
80004ee6:	f0 1f 00 09 	mcall	80004f08 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004eea:	c0 71       	brne	80004ef8 <PcdSelect+0x60>
80004eec:	31 88       	mov	r8,24
80004eee:	fb 39 00 13 	ld.ub	r9,sp[19]
80004ef2:	f0 09 18 00 	cp.b	r9,r8
80004ef6:	c0 20       	breq	80004efa <PcdSelect+0x62>
80004ef8:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004efa:	2f bd       	sub	sp,-20
80004efc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f00:	80 00       	ld.sh	r0,r0[0x0]
80004f02:	4e 0c       	lddpc	r12,80005080 <rfid_sendID_message+0x54>
80004f04:	80 00       	ld.sh	r0,r0[0x0]
80004f06:	4a 34       	lddpc	r4,80004f90 <rfid_auto_reader+0x84>
80004f08:	80 00       	ld.sh	r0,r0[0x0]
80004f0a:	4b ac       	lddpc	r12,80004ff0 <rfid_auto_reader+0xe4>

80004f0c <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004f0c:	eb cd 40 c0 	pushm	r6-r7,lr
80004f10:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f12:	f0 1f 00 37 	mcall	80004fec <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f16:	4b 7b       	lddpc	r11,80004ff0 <rfid_auto_reader+0xe4>
80004f18:	35 2c       	mov	r12,82
80004f1a:	f0 1f 00 37 	mcall	80004ff4 <rfid_auto_reader+0xe8>
80004f1e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f20:	c6 31       	brne	80004fe6 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f22:	4b 48       	lddpc	r8,80004ff0 <rfid_auto_reader+0xe4>
80004f24:	11 88       	ld.ub	r8,r8[0x0]
80004f26:	30 49       	mov	r9,4
80004f28:	f2 08 18 00 	cp.b	r8,r9
80004f2c:	c0 b1       	brne	80004f42 <rfid_auto_reader+0x36>
80004f2e:	4b 19       	lddpc	r9,80004ff0 <rfid_auto_reader+0xe4>
80004f30:	13 9a       	ld.ub	r10,r9[0x1]
80004f32:	30 09       	mov	r9,0
80004f34:	f2 0a 18 00 	cp.b	r10,r9
80004f38:	c0 51       	brne	80004f42 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f3a:	4b 0c       	lddpc	r12,80004ff8 <rfid_auto_reader+0xec>
80004f3c:	f0 1f 00 30 	mcall	80004ffc <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f40:	c3 c8       	rjmp	80004fb8 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f42:	30 29       	mov	r9,2
80004f44:	f2 08 18 00 	cp.b	r8,r9
80004f48:	c0 b1       	brne	80004f5e <rfid_auto_reader+0x52>
80004f4a:	4a a9       	lddpc	r9,80004ff0 <rfid_auto_reader+0xe4>
80004f4c:	13 9a       	ld.ub	r10,r9[0x1]
80004f4e:	30 09       	mov	r9,0
80004f50:	f2 0a 18 00 	cp.b	r10,r9
80004f54:	c0 51       	brne	80004f5e <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004f56:	4a bc       	lddpc	r12,80005000 <rfid_auto_reader+0xf4>
80004f58:	f0 1f 00 29 	mcall	80004ffc <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f5c:	c2 e8       	rjmp	80004fb8 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f5e:	34 49       	mov	r9,68
80004f60:	f2 08 18 00 	cp.b	r8,r9
80004f64:	c0 b1       	brne	80004f7a <rfid_auto_reader+0x6e>
80004f66:	4a 39       	lddpc	r9,80004ff0 <rfid_auto_reader+0xe4>
80004f68:	13 9a       	ld.ub	r10,r9[0x1]
80004f6a:	30 09       	mov	r9,0
80004f6c:	f2 0a 18 00 	cp.b	r10,r9
80004f70:	c0 51       	brne	80004f7a <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004f72:	4a 5c       	lddpc	r12,80005004 <rfid_auto_reader+0xf8>
80004f74:	f0 1f 00 22 	mcall	80004ffc <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f78:	c2 08       	rjmp	80004fb8 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f7a:	30 89       	mov	r9,8
80004f7c:	f2 08 18 00 	cp.b	r8,r9
80004f80:	c0 b1       	brne	80004f96 <rfid_auto_reader+0x8a>
80004f82:	49 c9       	lddpc	r9,80004ff0 <rfid_auto_reader+0xe4>
80004f84:	13 9a       	ld.ub	r10,r9[0x1]
80004f86:	30 09       	mov	r9,0
80004f88:	f2 0a 18 00 	cp.b	r10,r9
80004f8c:	c0 51       	brne	80004f96 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004f8e:	49 fc       	lddpc	r12,80005008 <rfid_auto_reader+0xfc>
80004f90:	f0 1f 00 1b 	mcall	80004ffc <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f94:	c1 28       	rjmp	80004fb8 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f96:	34 49       	mov	r9,68
80004f98:	f2 08 18 00 	cp.b	r8,r9
80004f9c:	c0 b1       	brne	80004fb2 <rfid_auto_reader+0xa6>
80004f9e:	49 58       	lddpc	r8,80004ff0 <rfid_auto_reader+0xe4>
80004fa0:	11 99       	ld.ub	r9,r8[0x1]
80004fa2:	30 38       	mov	r8,3
80004fa4:	f0 09 18 00 	cp.b	r9,r8
80004fa8:	c0 51       	brne	80004fb2 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004faa:	49 9c       	lddpc	r12,8000500c <rfid_auto_reader+0x100>
80004fac:	f0 1f 00 14 	mcall	80004ffc <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004fb0:	c0 48       	rjmp	80004fb8 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004fb2:	49 8c       	lddpc	r12,80005010 <rfid_auto_reader+0x104>
80004fb4:	f0 1f 00 12 	mcall	80004ffc <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004fb8:	49 7c       	lddpc	r12,80005014 <rfid_auto_reader+0x108>
80004fba:	f0 1f 00 18 	mcall	80005018 <rfid_auto_reader+0x10c>
80004fbe:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004fc0:	c0 60       	breq	80004fcc <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004fc2:	37 8b       	mov	r11,120
80004fc4:	30 1c       	mov	r12,1
80004fc6:	f0 1f 00 16 	mcall	8000501c <rfid_auto_reader+0x110>
		return status;
80004fca:	c0 e8       	rjmp	80004fe6 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004fcc:	49 2c       	lddpc	r12,80005014 <rfid_auto_reader+0x108>
80004fce:	f0 1f 00 15 	mcall	80005020 <rfid_auto_reader+0x114>
80004fd2:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004fd4:	c0 91       	brne	80004fe6 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004fd6:	30 4a       	mov	r10,4
80004fd8:	48 fb       	lddpc	r11,80005014 <rfid_auto_reader+0x108>
80004fda:	0c 9c       	mov	r12,r6
80004fdc:	f0 1f 00 12 	mcall	80005024 <rfid_auto_reader+0x118>
		log("select okay\n");
80004fe0:	49 2c       	lddpc	r12,80005028 <rfid_auto_reader+0x11c>
80004fe2:	f0 1f 00 07 	mcall	80004ffc <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004fe6:	0e 9c       	mov	r12,r7
80004fe8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fec:	80 00       	ld.sh	r0,r0[0x0]
80004fee:	49 28       	lddpc	r8,80005034 <rfid_sendID_message+0x8>
80004ff0:	00 00       	add	r0,r0
80004ff2:	53 ac       	stdsp	sp[0xe8],r12
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	4d a8       	lddpc	r8,8000515c <rfid_sendID_message+0x130>
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	d8 38       	*unknown*
80004ffc:	80 00       	ld.sh	r0,r0[0x0]
80004ffe:	6f e4       	ld.w	r4,r7[0x78]
80005000:	80 00       	ld.sh	r0,r0[0x0]
80005002:	d8 44       	*unknown*
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	d8 50       	acall	0x85
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	d8 60       	acall	0x86
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	d8 68       	*unknown*
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	d8 74       	*unknown*
80005014:	00 00       	add	r0,r0
80005016:	53 b0       	stdsp	sp[0xec],r0
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	4d 24       	lddpc	r4,80005160 <rfid_sendID_message+0x134>
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	40 7c       	lddsp	r12,sp[0x1c]
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	4e 98       	lddpc	r8,800051c4 <delay_us+0x4>
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	78 68       	ld.w	r8,r12[0x18]
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	d8 80       	acall	0x88

8000502c <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
8000502c:	eb cd 40 e0 	pushm	r5-r7,lr
80005030:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80005032:	fa cc ff 90 	sub	r12,sp,-112
80005036:	30 08       	mov	r8,0
80005038:	30 09       	mov	r9,0
8000503a:	f8 e9 00 00 	st.d	r12[0],r8
8000503e:	30 0a       	mov	r10,0
80005040:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005042:	fa e9 00 20 	st.d	sp[32],r8
80005046:	fa e9 00 28 	st.d	sp[40],r8
8000504a:	fa e9 00 30 	st.d	sp[48],r8
8000504e:	fa e9 00 38 	st.d	sp[56],r8
80005052:	fa e9 00 40 	st.d	sp[64],r8
80005056:	fa e9 00 48 	st.d	sp[72],r8
8000505a:	fa e9 00 50 	st.d	sp[80],r8
8000505e:	fa e9 00 58 	st.d	sp[88],r8
80005062:	fa e9 00 60 	st.d	sp[96],r8
80005066:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
8000506a:	f0 1f 00 43 	mcall	80005174 <rfid_sendID_message+0x148>
8000506e:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005070:	c7 61       	brne	8000515c <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005072:	fb 38 00 73 	ld.ub	r8,sp[115]
80005076:	1a d8       	st.w	--sp,r8
80005078:	fb 38 00 76 	ld.ub	r8,sp[118]
8000507c:	1a d8       	st.w	--sp,r8
8000507e:	fb 38 00 79 	ld.ub	r8,sp[121]
80005082:	1a d8       	st.w	--sp,r8
80005084:	fb 38 00 7c 	ld.ub	r8,sp[124]
80005088:	1a d8       	st.w	--sp,r8
8000508a:	4b cc       	lddpc	r12,80005178 <rfid_sendID_message+0x14c>
8000508c:	f0 1f 00 3c 	mcall	8000517c <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80005090:	37 7b       	mov	r11,119
80005092:	30 1c       	mov	r12,1
80005094:	f0 1f 00 3b 	mcall	80005180 <rfid_sendID_message+0x154>
80005098:	fa c9 ff 80 	sub	r9,sp,-128
8000509c:	fa c8 ff f0 	sub	r8,sp,-16
800050a0:	fa ca ff ee 	sub	r10,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
800050a4:	fa c5 ff 7c 	sub	r5,sp,-132
800050a8:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800050aa:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
800050ac:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
800050ae:	13 8b       	ld.ub	r11,r9[0x0]
800050b0:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800050b4:	fc 0c 18 00 	cp.b	r12,lr
800050b8:	f7 bc 08 d0 	subls	r12,-48
800050bc:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
800050c0:	f7 bc 0b a9 	subhi	r12,-87
800050c4:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
800050c8:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
800050ca:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
800050ce:	fc 0b 18 00 	cp.b	r11,lr
800050d2:	f7 bb 08 d0 	subls	r11,-48
800050d6:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
800050da:	f7 bb 0b a9 	subhi	r11,-87
800050de:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
800050e2:	b0 b6       	st.b	r8[0x3],r6
800050e4:	2f f9       	sub	r9,-1
800050e6:	2f c8       	sub	r8,-4
800050e8:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
800050ea:	0a 39       	cp.w	r9,r5
800050ec:	ce 11       	brne	800050ae <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
800050ee:	30 6a       	mov	r10,6
800050f0:	4a 5b       	lddpc	r11,80005184 <rfid_sendID_message+0x158>
800050f2:	fa cc ff f0 	sub	r12,sp,-16
800050f6:	f0 1f 00 25 	mcall	80005188 <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
800050fa:	4a 58       	lddpc	r8,8000518c <rfid_sendID_message+0x160>
800050fc:	11 89       	ld.ub	r9,r8[0x0]
800050fe:	39 f8       	mov	r8,-97
80005100:	f0 09 18 00 	cp.b	r9,r8
80005104:	e0 88 00 05 	brls	8000510e <rfid_sendID_message+0xe2>
80005108:	38 09       	mov	r9,-128
8000510a:	4a 18       	lddpc	r8,8000518c <rfid_sendID_message+0x160>
8000510c:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
8000510e:	4a 08       	lddpc	r8,8000518c <rfid_sendID_message+0x160>
80005110:	11 86       	ld.ub	r6,r8[0x0]
80005112:	2f f6       	sub	r6,-1
80005114:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005116:	30 5a       	mov	r10,5
80005118:	49 eb       	lddpc	r11,80005190 <rfid_sendID_message+0x164>
8000511a:	fa cc ff e5 	sub	r12,sp,-27
8000511e:	f0 1f 00 1b 	mcall	80005188 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005122:	31 e8       	mov	r8,30
80005124:	fb 58 00 16 	st.h	sp[22],r8
80005128:	fb 66 00 1a 	st.b	sp[26],r6
8000512c:	fe 78 e0 00 	mov	r8,-8192
80005130:	fb 58 00 18 	st.h	sp[24],r8
80005134:	fa c6 ff e0 	sub	r6,sp,-32
80005138:	30 aa       	mov	r10,10
8000513a:	fa cb ff ea 	sub	r11,sp,-22
8000513e:	0c 9c       	mov	r12,r6
80005140:	f0 1f 00 12 	mcall	80005188 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005144:	31 6a       	mov	r10,22
80005146:	1a 9b       	mov	r11,sp
80005148:	fa cc ff d6 	sub	r12,sp,-42
8000514c:	f0 1f 00 0f 	mcall	80005188 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80005150:	30 9a       	mov	r10,9
80005152:	32 0b       	mov	r11,32
80005154:	0c 9c       	mov	r12,r6
80005156:	f0 1f 00 10 	mcall	80005194 <rfid_sendID_message+0x168>
8000515a:	c0 88       	rjmp	8000516a <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
8000515c:	37 8b       	mov	r11,120
8000515e:	30 1c       	mov	r12,1
80005160:	f0 1f 00 08 	mcall	80005180 <rfid_sendID_message+0x154>
		log("no card find...\n");
80005164:	48 dc       	lddpc	r12,80005198 <rfid_sendID_message+0x16c>
80005166:	f0 1f 00 06 	mcall	8000517c <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
8000516a:	0e 9c       	mov	r12,r7
8000516c:	2e 1d       	sub	sp,-124
8000516e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005172:	00 00       	add	r0,r0
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	4f 0c       	lddpc	r12,80005334 <xg_flashc_init+0x64>
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	d8 90       	acall	0x89
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	6f e4       	ld.w	r4,r7[0x78]
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	40 7c       	lddsp	r12,sp[0x1c]
80005184:	00 00       	add	r0,r0
80005186:	0d 9c       	ld.ub	r12,r6[0x1]
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	78 68       	ld.w	r8,r12[0x18]
8000518c:	00 00       	add	r0,r0
8000518e:	05 34       	ld.ub	r4,r2++
80005190:	00 00       	add	r0,r0
80005192:	05 2c       	ld.uh	r12,r2++
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	3f 44       	mov	r4,-12
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	d8 ac       	*unknown*

8000519c <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
8000519c:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000519e:	f0 1f 00 02 	mcall	800051a4 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
800051a2:	d8 02       	popm	pc
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	4a dc       	lddpc	r12,80005258 <local_start_pll0+0x1c>

800051a8 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051a8:	58 0c       	cp.w	r12,0
800051aa:	5e 0c       	reteq	r12
800051ac:	30 08       	mov	r8,0
	{
		nop();
800051ae:	d7 03       	nop
		nop();
800051b0:	d7 03       	nop
		nop();
800051b2:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051b4:	2f f8       	sub	r8,-1
800051b6:	10 3c       	cp.w	r12,r8
800051b8:	fe 9b ff fb 	brhi	800051ae <delay_ns+0x6>
800051bc:	5e fc       	retal	r12
800051be:	d7 03       	nop

800051c0 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800051c0:	eb cd 40 e0 	pushm	r5-r7,lr
800051c4:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800051c6:	58 0c       	cp.w	r12,0
800051c8:	c0 b0       	breq	800051de <delay_us+0x1e>
800051ca:	30 07       	mov	r7,0
		delay_ns(1000);
800051cc:	e0 65 03 e8 	mov	r5,1000
800051d0:	0a 9c       	mov	r12,r5
800051d2:	f0 1f 00 05 	mcall	800051e4 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800051d6:	2f f7       	sub	r7,-1
800051d8:	0e 36       	cp.w	r6,r7
800051da:	fe 9b ff fb 	brhi	800051d0 <delay_us+0x10>
800051de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051e2:	00 00       	add	r0,r0
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	51 a8       	stdsp	sp[0x68],r8

800051e8 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800051e8:	eb cd 40 e0 	pushm	r5-r7,lr
800051ec:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800051ee:	58 0c       	cp.w	r12,0
800051f0:	c0 b0       	breq	80005206 <delay_ms+0x1e>
800051f2:	30 07       	mov	r7,0
		delay_us(1000);
800051f4:	e0 65 03 e8 	mov	r5,1000
800051f8:	0a 9c       	mov	r12,r5
800051fa:	f0 1f 00 05 	mcall	8000520c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800051fe:	2f f7       	sub	r7,-1
80005200:	0e 36       	cp.w	r6,r7
80005202:	fe 9b ff fb 	brhi	800051f8 <delay_ms+0x10>
80005206:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000520a:	00 00       	add	r0,r0
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	51 c0       	stdsp	sp[0x70],r0

80005210 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005210:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005212:	30 3b       	mov	r11,3
80005214:	48 8c       	lddpc	r12,80005234 <local_start_timer+0x24>
80005216:	f0 1f 00 09 	mcall	80005238 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000521a:	fe 78 38 00 	mov	r8,-51200
8000521e:	e0 69 91 0d 	mov	r9,37133
80005222:	ea 19 00 52 	orh	r9,0x52
80005226:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005228:	32 09       	mov	r9,32
8000522a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000522c:	30 59       	mov	r9,5
8000522e:	91 09       	st.w	r8[0x0],r9
}
80005230:	d8 02       	popm	pc
80005232:	00 00       	add	r0,r0
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	d8 c0       	acall	0x8c
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	53 c8       	stdsp	sp[0xf0],r8

8000523c <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
8000523c:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
8000523e:	30 3a       	mov	r10,3
80005240:	e0 6b 1b 00 	mov	r11,6912
80005244:	ea 1b 00 b7 	orh	r11,0xb7
80005248:	fe 7c 0c 00 	mov	r12,-62464
8000524c:	f0 1f 00 19 	mcall	800052b0 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005250:	31 08       	mov	r8,16
80005252:	1a d8       	st.w	--sp,r8
80005254:	30 08       	mov	r8,0
80005256:	30 19       	mov	r9,1
80005258:	30 7a       	mov	r10,7
8000525a:	10 9b       	mov	r11,r8
8000525c:	fe 7c 0c 00 	mov	r12,-62464
80005260:	f0 1f 00 15 	mcall	800052b4 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005264:	30 08       	mov	r8,0
80005266:	30 19       	mov	r9,1
80005268:	12 9a       	mov	r10,r9
8000526a:	10 9b       	mov	r11,r8
8000526c:	fe 7c 0c 00 	mov	r12,-62464
80005270:	f0 1f 00 12 	mcall	800052b8 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005274:	30 0b       	mov	r11,0
80005276:	fe 7c 0c 00 	mov	r12,-62464
8000527a:	f0 1f 00 11 	mcall	800052bc <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000527e:	fe 7c 0c 00 	mov	r12,-62464
80005282:	f0 1f 00 10 	mcall	800052c0 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005286:	30 0a       	mov	r10,0
80005288:	1a da       	st.w	--sp,r10
8000528a:	1a da       	st.w	--sp,r10
8000528c:	14 98       	mov	r8,r10
8000528e:	14 99       	mov	r9,r10
80005290:	30 1b       	mov	r11,1
80005292:	fe 7c 0c 00 	mov	r12,-62464
80005296:	f0 1f 00 0c 	mcall	800052c4 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
8000529a:	30 1c       	mov	r12,1
8000529c:	f0 1f 00 0b 	mcall	800052c8 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800052a0:	30 2b       	mov	r11,2
800052a2:	fe 7c 0c 00 	mov	r12,-62464
800052a6:	f0 1f 00 0a 	mcall	800052cc <local_start_pll0+0x90>
800052aa:	2f dd       	sub	sp,-12
/****/
}
800052ac:	d8 02       	popm	pc
800052ae:	00 00       	add	r0,r0
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	56 d0       	stdsp	sp[0x1b4],r0
800052b4:	80 00       	ld.sh	r0,r0[0x0]
800052b6:	56 72       	stdsp	sp[0x19c],r2
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	56 94       	stdsp	sp[0x1a4],r4
800052bc:	80 00       	ld.sh	r0,r0[0x0]
800052be:	56 ae       	stdsp	sp[0x1a8],lr
800052c0:	80 00       	ld.sh	r0,r0[0x0]
800052c2:	56 bc       	stdsp	sp[0x1ac],r12
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	56 2c       	stdsp	sp[0x188],r12
800052c8:	80 00       	ld.sh	r0,r0[0x0]
800052ca:	53 68       	stdsp	sp[0xd8],r8
800052cc:	80 00       	ld.sh	r0,r0[0x0]
800052ce:	56 c6       	stdsp	sp[0x1b0],r6

800052d0 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800052d0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
800052d4:	f0 1f 00 1a 	mcall	8000533c <xg_flashc_init+0x6c>
800052d8:	49 a8       	lddpc	r8,80005340 <xg_flashc_init+0x70>
800052da:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
800052dc:	70 08       	ld.w	r8,r8[0x0]
800052de:	58 08       	cp.w	r8,0
800052e0:	c0 41       	brne	800052e8 <xg_flashc_init+0x18>
	{
		log("Create the xgflash_mutex semaphore failure\n");
800052e2:	49 9c       	lddpc	r12,80005344 <xg_flashc_init+0x74>
800052e4:	f0 1f 00 19 	mcall	80005348 <xg_flashc_init+0x78>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800052e8:	30 0b       	mov	r11,0
800052ea:	30 1c       	mov	r12,1
800052ec:	f0 1f 00 18 	mcall	8000534c <xg_flashc_init+0x7c>
800052f0:	49 88       	lddpc	r8,80005350 <xg_flashc_init+0x80>
800052f2:	91 0c       	st.w	r8[0x0],r12
800052f4:	70 08       	ld.w	r8,r8[0x0]
800052f6:	58 08       	cp.w	r8,0
800052f8:	c0 80       	breq	80005308 <xg_flashc_init+0x38>
800052fa:	49 68       	lddpc	r8,80005350 <xg_flashc_init+0x80>
800052fc:	70 0c       	ld.w	r12,r8[0x0]
800052fe:	30 09       	mov	r9,0
80005300:	12 9a       	mov	r10,r9
80005302:	12 9b       	mov	r11,r9
80005304:	f0 1f 00 14 	mcall	80005354 <xg_flashc_init+0x84>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
80005308:	30 4b       	mov	r11,4
8000530a:	31 4c       	mov	r12,20
8000530c:	f0 1f 00 10 	mcall	8000534c <xg_flashc_init+0x7c>
80005310:	49 28       	lddpc	r8,80005358 <xg_flashc_init+0x88>
80005312:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80005314:	30 4b       	mov	r11,4
80005316:	31 4c       	mov	r12,20
80005318:	f0 1f 00 0d 	mcall	8000534c <xg_flashc_init+0x7c>
8000531c:	49 08       	lddpc	r8,8000535c <xg_flashc_init+0x8c>
8000531e:	91 0c       	st.w	r8[0x0],r12
80005320:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005322:	10 96       	mov	r6,r8
80005324:	48 f5       	lddpc	r5,80005360 <xg_flashc_init+0x90>
80005326:	6c 0c       	ld.w	r12,r6[0x0]
80005328:	ea 07 00 0b 	add	r11,r5,r7
8000532c:	f0 1f 00 0e 	mcall	80005364 <xg_flashc_init+0x94>
80005330:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005332:	e0 47 02 80 	cp.w	r7,640
80005336:	cf 81       	brne	80005326 <xg_flashc_init+0x56>
	
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	//create_xg_flash_test_task();

}
80005338:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	64 ac       	ld.w	r12,r2[0x28]
80005340:	00 00       	add	r0,r0
80005342:	0b 70       	ld.ub	r0,--r5
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	d8 d8       	*unknown*
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	6f e4       	ld.w	r4,r7[0x78]
8000534c:	80 00       	ld.sh	r0,r0[0x0]
8000534e:	65 04       	ld.w	r4,r2[0x40]
80005350:	00 00       	add	r0,r0
80005352:	53 b4       	stdsp	sp[0xec],r4
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	63 ac       	ld.w	r12,r1[0x68]
80005358:	00 00       	add	r0,r0
8000535a:	0b 6c       	ld.uh	r12,--r5
8000535c:	00 00       	add	r0,r0
8000535e:	0b 74       	ld.ub	r4,--r5
80005360:	00 00       	add	r0,r0
80005362:	0d a2       	ld.ub	r2,r6[0x2]
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	2c 0c       	sub	r12,-64

80005368 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005368:	fe 68 14 00 	mov	r8,-125952
8000536c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000536e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005372:	91 09       	st.w	r8[0x0],r9
}
80005374:	5e fc       	retal	r12

80005376 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005376:	f8 08 16 05 	lsr	r8,r12,0x5
8000537a:	a9 68       	lsl	r8,0x8
8000537c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005380:	58 1b       	cp.w	r11,1
80005382:	c0 d0       	breq	8000539c <gpio_enable_module_pin+0x26>
80005384:	c0 63       	brcs	80005390 <gpio_enable_module_pin+0x1a>
80005386:	58 2b       	cp.w	r11,2
80005388:	c1 00       	breq	800053a8 <gpio_enable_module_pin+0x32>
8000538a:	58 3b       	cp.w	r11,3
8000538c:	c1 40       	breq	800053b4 <gpio_enable_module_pin+0x3e>
8000538e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005390:	30 19       	mov	r9,1
80005392:	f2 0c 09 49 	lsl	r9,r9,r12
80005396:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005398:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000539a:	c1 28       	rjmp	800053be <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000539c:	30 19       	mov	r9,1
8000539e:	f2 0c 09 49 	lsl	r9,r9,r12
800053a2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800053a4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053a6:	c0 c8       	rjmp	800053be <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800053a8:	30 19       	mov	r9,1
800053aa:	f2 0c 09 49 	lsl	r9,r9,r12
800053ae:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053b0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053b2:	c0 68       	rjmp	800053be <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053b4:	30 19       	mov	r9,1
800053b6:	f2 0c 09 49 	lsl	r9,r9,r12
800053ba:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053bc:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800053be:	30 19       	mov	r9,1
800053c0:	f2 0c 09 4c 	lsl	r12,r9,r12
800053c4:	91 2c       	st.w	r8[0x8],r12
800053c6:	5e fd       	retal	0

800053c8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800053c8:	d4 21       	pushm	r4-r7,lr
800053ca:	18 97       	mov	r7,r12
800053cc:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053ce:	58 0b       	cp.w	r11,0
800053d0:	c0 31       	brne	800053d6 <gpio_enable_module+0xe>
800053d2:	30 05       	mov	r5,0
800053d4:	c0 d8       	rjmp	800053ee <gpio_enable_module+0x26>
800053d6:	30 06       	mov	r6,0
800053d8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800053da:	6e 1b       	ld.w	r11,r7[0x4]
800053dc:	6e 0c       	ld.w	r12,r7[0x0]
800053de:	f0 1f 00 06 	mcall	800053f4 <gpio_enable_module+0x2c>
800053e2:	18 45       	or	r5,r12
		gpiomap++;
800053e4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053e6:	2f f6       	sub	r6,-1
800053e8:	0c 34       	cp.w	r4,r6
800053ea:	fe 9b ff f8 	brhi	800053da <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800053ee:	0a 9c       	mov	r12,r5
800053f0:	d8 22       	popm	r4-r7,pc
800053f2:	00 00       	add	r0,r0
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	53 76       	stdsp	sp[0xdc],r6

800053f8 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800053f8:	f8 08 16 05 	lsr	r8,r12,0x5
800053fc:	a9 68       	lsl	r8,0x8
800053fe:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005402:	30 19       	mov	r9,1
80005404:	f2 0c 09 4c 	lsl	r12,r9,r12
80005408:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000540c:	91 1c       	st.w	r8[0x4],r12
}
8000540e:	5e fc       	retal	r12

80005410 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005410:	f8 08 16 05 	lsr	r8,r12,0x5
80005414:	a9 68       	lsl	r8,0x8
80005416:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000541a:	30 19       	mov	r9,1
8000541c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005420:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005424:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005428:	91 1c       	st.w	r8[0x4],r12
}
8000542a:	5e fc       	retal	r12

8000542c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000542c:	f8 08 16 05 	lsr	r8,r12,0x5
80005430:	a9 68       	lsl	r8,0x8
80005432:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005436:	30 19       	mov	r9,1
80005438:	f2 0c 09 4c 	lsl	r12,r9,r12
8000543c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005440:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005444:	91 1c       	st.w	r8[0x4],r12
}
80005446:	5e fc       	retal	r12

80005448 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005448:	c0 08       	rjmp	80005448 <_unhandled_interrupt>
8000544a:	d7 03       	nop

8000544c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000544c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005450:	49 99       	lddpc	r9,800054b4 <INTC_register_interrupt+0x68>
80005452:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005456:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000545a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000545c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005460:	58 0a       	cp.w	r10,0
80005462:	c0 91       	brne	80005474 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005464:	49 59       	lddpc	r9,800054b8 <INTC_register_interrupt+0x6c>
80005466:	49 6a       	lddpc	r10,800054bc <INTC_register_interrupt+0x70>
80005468:	12 1a       	sub	r10,r9
8000546a:	fe 79 08 00 	mov	r9,-63488
8000546e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005472:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005474:	58 1a       	cp.w	r10,1
80005476:	c0 a1       	brne	8000548a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005478:	49 09       	lddpc	r9,800054b8 <INTC_register_interrupt+0x6c>
8000547a:	49 2a       	lddpc	r10,800054c0 <INTC_register_interrupt+0x74>
8000547c:	12 1a       	sub	r10,r9
8000547e:	bf aa       	sbr	r10,0x1e
80005480:	fe 79 08 00 	mov	r9,-63488
80005484:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005488:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000548a:	58 2a       	cp.w	r10,2
8000548c:	c0 a1       	brne	800054a0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000548e:	48 b9       	lddpc	r9,800054b8 <INTC_register_interrupt+0x6c>
80005490:	48 da       	lddpc	r10,800054c4 <INTC_register_interrupt+0x78>
80005492:	12 1a       	sub	r10,r9
80005494:	bf ba       	sbr	r10,0x1f
80005496:	fe 79 08 00 	mov	r9,-63488
8000549a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000549e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800054a0:	48 69       	lddpc	r9,800054b8 <INTC_register_interrupt+0x6c>
800054a2:	48 aa       	lddpc	r10,800054c8 <INTC_register_interrupt+0x7c>
800054a4:	12 1a       	sub	r10,r9
800054a6:	ea 1a c0 00 	orh	r10,0xc000
800054aa:	fe 79 08 00 	mov	r9,-63488
800054ae:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054b2:	5e fc       	retal	r12
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	d9 88       	*unknown*
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	ce 00       	breq	8000547a <INTC_register_interrupt+0x2e>
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	cf 04       	brge	8000549e <INTC_register_interrupt+0x52>
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	cf 12       	brcc	800054a4 <INTC_register_interrupt+0x58>
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	cf 20       	breq	800054aa <INTC_register_interrupt+0x5e>
800054c8:	80 00       	ld.sh	r0,r0[0x0]
800054ca:	cf 2e       	rcall	800052ae <local_start_pll0+0x72>

800054cc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800054cc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054ce:	49 18       	lddpc	r8,80005510 <INTC_init_interrupts+0x44>
800054d0:	e3 b8 00 01 	mtsr	0x4,r8
800054d4:	49 0e       	lddpc	lr,80005514 <INTC_init_interrupts+0x48>
800054d6:	30 07       	mov	r7,0
800054d8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054da:	49 0c       	lddpc	r12,80005518 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054dc:	49 05       	lddpc	r5,8000551c <INTC_init_interrupts+0x50>
800054de:	10 15       	sub	r5,r8
800054e0:	fe 76 08 00 	mov	r6,-63488
800054e4:	c1 08       	rjmp	80005504 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054e6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054e8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054ea:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054ec:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054f0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054f2:	10 3a       	cp.w	r10,r8
800054f4:	fe 9b ff fc 	brhi	800054ec <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054f8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800054fc:	2f f7       	sub	r7,-1
800054fe:	2f 8e       	sub	lr,-8
80005500:	59 37       	cp.w	r7,19
80005502:	c0 50       	breq	8000550c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005504:	7c 08       	ld.w	r8,lr[0x0]
80005506:	58 08       	cp.w	r8,0
80005508:	ce f1       	brne	800054e6 <INTC_init_interrupts+0x1a>
8000550a:	cf 7b       	rjmp	800054f8 <INTC_init_interrupts+0x2c>
8000550c:	d8 22       	popm	r4-r7,pc
8000550e:	00 00       	add	r0,r0
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	ce 00       	breq	800054d2 <INTC_init_interrupts+0x6>
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	d9 88       	*unknown*
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	54 48       	stdsp	sp[0x110],r8
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	cf 04       	brge	800054fe <INTC_init_interrupts+0x32>

80005520 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005520:	fe 78 08 00 	mov	r8,-63488
80005524:	e0 69 00 83 	mov	r9,131
80005528:	f2 0c 01 0c 	sub	r12,r9,r12
8000552c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005530:	f2 ca ff c0 	sub	r10,r9,-64
80005534:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005538:	58 08       	cp.w	r8,0
8000553a:	c0 21       	brne	8000553e <_get_interrupt_handler+0x1e>
8000553c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000553e:	f0 08 12 00 	clz	r8,r8
80005542:	48 5a       	lddpc	r10,80005554 <_get_interrupt_handler+0x34>
80005544:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005548:	f0 08 11 1f 	rsub	r8,r8,31
8000554c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000554e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005552:	5e fc       	retal	r12
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	d9 88       	*unknown*

80005558 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005558:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000555a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000555e:	99 a8       	st.w	r12[0x28],r8
}
80005560:	5e fc       	retal	r12
80005562:	d7 03       	nop

80005564 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005564:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005566:	ec 5b bb 9f 	cp.w	r11,899999
8000556a:	e0 8b 00 04 	brhi	80005572 <pm_enable_osc0_crystal+0xe>
8000556e:	30 4b       	mov	r11,4
80005570:	c1 38       	rjmp	80005596 <pm_enable_osc0_crystal+0x32>
80005572:	e0 68 c6 bf 	mov	r8,50879
80005576:	ea 18 00 2d 	orh	r8,0x2d
8000557a:	10 3b       	cp.w	r11,r8
8000557c:	e0 8b 00 04 	brhi	80005584 <pm_enable_osc0_crystal+0x20>
80005580:	30 5b       	mov	r11,5
80005582:	c0 a8       	rjmp	80005596 <pm_enable_osc0_crystal+0x32>
80005584:	e0 68 12 00 	mov	r8,4608
80005588:	ea 18 00 7a 	orh	r8,0x7a
8000558c:	10 3b       	cp.w	r11,r8
8000558e:	f9 bb 03 06 	movlo	r11,6
80005592:	f9 bb 02 07 	movhs	r11,7
80005596:	f0 1f 00 02 	mcall	8000559c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000559a:	d8 02       	popm	pc
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	55 58       	stdsp	sp[0x154],r8

800055a0 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800055a0:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800055a2:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800055a6:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800055a8:	78 08       	ld.w	r8,r12[0x0]
800055aa:	a3 a8       	sbr	r8,0x2
800055ac:	99 08       	st.w	r12[0x0],r8
}
800055ae:	5e fc       	retal	r12

800055b0 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800055b0:	79 58       	ld.w	r8,r12[0x54]
800055b2:	e2 18 00 80 	andl	r8,0x80,COH
800055b6:	cf d0       	breq	800055b0 <pm_wait_for_clk0_ready>
}
800055b8:	5e fc       	retal	r12
800055ba:	d7 03       	nop

800055bc <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800055bc:	eb cd 40 80 	pushm	r7,lr
800055c0:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800055c2:	f0 1f 00 04 	mcall	800055d0 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800055c6:	0e 9c       	mov	r12,r7
800055c8:	f0 1f 00 03 	mcall	800055d4 <pm_enable_clk0+0x18>
}
800055cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800055d0:	80 00       	ld.sh	r0,r0[0x0]
800055d2:	55 a0       	stdsp	sp[0x168],r0
800055d4:	80 00       	ld.sh	r0,r0[0x0]
800055d6:	55 b0       	stdsp	sp[0x16c],r0

800055d8 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800055d8:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800055da:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800055de:	99 c8       	st.w	r12[0x30],r8
}
800055e0:	5e fc       	retal	r12
800055e2:	d7 03       	nop

800055e4 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
800055e4:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
800055e6:	30 1b       	mov	r11,1
800055e8:	f0 1f 00 02 	mcall	800055f0 <pm_enable_osc32_crystal+0xc>
}
800055ec:	d8 02       	popm	pc
800055ee:	00 00       	add	r0,r0
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	55 d8       	stdsp	sp[0x174],r8

800055f4 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800055f4:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
800055f6:	30 19       	mov	r9,1
800055f8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
800055fc:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005600:	99 c8       	st.w	r12[0x30],r8
}
80005602:	5e fc       	retal	r12

80005604 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80005604:	79 58       	ld.w	r8,r12[0x54]
80005606:	e2 18 02 00 	andl	r8,0x200,COH
8000560a:	cf d0       	breq	80005604 <pm_wait_for_clk32_ready>
}
8000560c:	5e fc       	retal	r12
8000560e:	d7 03       	nop

80005610 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80005610:	eb cd 40 80 	pushm	r7,lr
80005614:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80005616:	f0 1f 00 04 	mcall	80005624 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000561a:	0e 9c       	mov	r12,r7
8000561c:	f0 1f 00 03 	mcall	80005628 <pm_enable_clk32+0x18>
}
80005620:	e3 cd 80 80 	ldm	sp++,r7,pc
80005624:	80 00       	ld.sh	r0,r0[0x0]
80005626:	55 f4       	stdsp	sp[0x17c],r4
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	56 04       	stdsp	sp[0x180],r4

8000562c <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
8000562c:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005630:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005634:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005636:	09 f7       	ld.ub	r7,r4[0x7]
80005638:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
8000563c:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005640:	09 b4       	ld.ub	r4,r4[0x3]
80005642:	08 96       	mov	r6,r4
80005644:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005648:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000564c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005650:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005654:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005658:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000565c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005660:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005664:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005666:	79 58       	ld.w	r8,r12[0x54]
80005668:	e2 18 00 20 	andl	r8,0x20,COH
8000566c:	cf d0       	breq	80005666 <pm_cksel+0x3a>
}
8000566e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005672 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005672:	eb cd 40 80 	pushm	r7,lr
80005676:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005678:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000567a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000567e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005682:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005686:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000568a:	2f 8b       	sub	r11,-8
8000568c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005690:	e3 cd 80 80 	ldm	sp++,r7,pc

80005694 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005694:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005696:	2f 8b       	sub	r11,-8
80005698:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000569c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800056a0:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800056a4:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800056a8:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800056ac:	d8 02       	popm	pc

800056ae <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800056ae:	2f 8b       	sub	r11,-8
800056b0:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800056b4:	a1 a8       	sbr	r8,0x0
800056b6:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800056ba:	5e fc       	retal	r12

800056bc <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800056bc:	79 58       	ld.w	r8,r12[0x54]
800056be:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800056c2:	cf d0       	breq	800056bc <pm_wait_for_pll0_locked>
}
800056c4:	5e fc       	retal	r12

800056c6 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800056c6:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800056c8:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800056cc:	99 08       	st.w	r12[0x0],r8
}
800056ce:	5e fc       	retal	r12

800056d0 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800056d0:	eb cd 40 c0 	pushm	r6-r7,lr
800056d4:	18 97       	mov	r7,r12
800056d6:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800056d8:	f0 1f 00 06 	mcall	800056f0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800056dc:	0c 9b       	mov	r11,r6
800056de:	0e 9c       	mov	r12,r7
800056e0:	f0 1f 00 05 	mcall	800056f4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800056e4:	30 1b       	mov	r11,1
800056e6:	0e 9c       	mov	r12,r7
800056e8:	f0 1f 00 04 	mcall	800056f8 <pm_switch_to_osc0+0x28>
}
800056ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	55 64       	stdsp	sp[0x158],r4
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	55 bc       	stdsp	sp[0x16c],r12
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	56 c6       	stdsp	sp[0x1b0],r6

800056fc <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
800056fc:	78 0c       	ld.w	r12,r12[0x0]
}
800056fe:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80005702:	5e fc       	retal	r12

80005704 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80005704:	eb cd 40 c0 	pushm	r6-r7,lr
80005708:	18 97       	mov	r7,r12
8000570a:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
8000570c:	0e 9c       	mov	r12,r7
8000570e:	f0 1f 00 06 	mcall	80005724 <rtc_set_value+0x20>
80005712:	cf d1       	brne	8000570c <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80005714:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005716:	0e 9c       	mov	r12,r7
80005718:	f0 1f 00 03 	mcall	80005724 <rtc_set_value+0x20>
8000571c:	cf d1       	brne	80005716 <rtc_set_value+0x12>
}
8000571e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005722:	00 00       	add	r0,r0
80005724:	80 00       	ld.sh	r0,r0[0x0]
80005726:	56 fc       	stdsp	sp[0x1bc],r12

80005728 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80005728:	eb cd 40 80 	pushm	r7,lr
8000572c:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
8000572e:	0e 9c       	mov	r12,r7
80005730:	f0 1f 00 06 	mcall	80005748 <rtc_enable+0x20>
80005734:	cf d1       	brne	8000572e <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80005736:	6e 08       	ld.w	r8,r7[0x0]
80005738:	a1 a8       	sbr	r8,0x0
8000573a:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000573c:	0e 9c       	mov	r12,r7
8000573e:	f0 1f 00 03 	mcall	80005748 <rtc_enable+0x20>
80005742:	cf d1       	brne	8000573c <rtc_enable+0x14>
}
80005744:	e3 cd 80 80 	ldm	sp++,r7,pc
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	56 fc       	stdsp	sp[0x1bc],r12

8000574c <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
8000574c:	30 18       	mov	r8,1
8000574e:	99 48       	st.w	r12[0x10],r8
}
80005750:	5e fc       	retal	r12
80005752:	d7 03       	nop

80005754 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80005754:	eb cd 40 c0 	pushm	r6-r7,lr
80005758:	18 97       	mov	r7,r12
8000575a:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
8000575c:	0e 9c       	mov	r12,r7
8000575e:	f0 1f 00 06 	mcall	80005774 <rtc_set_top_value+0x20>
80005762:	cf d1       	brne	8000575c <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80005764:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005766:	0e 9c       	mov	r12,r7
80005768:	f0 1f 00 03 	mcall	80005774 <rtc_set_top_value+0x20>
8000576c:	cf d1       	brne	80005766 <rtc_set_top_value+0x12>
}
8000576e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005772:	00 00       	add	r0,r0
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	56 fc       	stdsp	sp[0x1bc],r12

80005778 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005778:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
8000577c:	e6 18 00 01 	andh	r8,0x1,COH
80005780:	c0 71       	brne	8000578e <rtc_clear_interrupt+0x16>
80005782:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005784:	30 18       	mov	r8,1
80005786:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005788:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
8000578a:	d5 03       	csrf	0x10
8000578c:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000578e:	30 18       	mov	r8,1
80005790:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005792:	78 78       	ld.w	r8,r12[0x1c]
80005794:	5e fc       	retal	r12
80005796:	d7 03       	nop

80005798 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80005798:	eb cd 40 e0 	pushm	r5-r7,lr
8000579c:	18 97       	mov	r7,r12
8000579e:	16 96       	mov	r6,r11
800057a0:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
800057a2:	30 18       	mov	r8,1
800057a4:	f0 0b 18 00 	cp.b	r11,r8
800057a8:	5f b9       	srhi	r9
800057aa:	30 f8       	mov	r8,15
800057ac:	f0 0a 18 00 	cp.b	r10,r8
800057b0:	5f b8       	srhi	r8
800057b2:	f3 e8 10 08 	or	r8,r9,r8
800057b6:	c0 30       	breq	800057bc <rtc_init+0x24>
800057b8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
800057bc:	30 18       	mov	r8,1
800057be:	f0 0b 18 00 	cp.b	r11,r8
800057c2:	c0 a1       	brne	800057d6 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800057c4:	fe 7c 0c 00 	mov	r12,-62464
800057c8:	f0 1f 00 0f 	mcall	80005804 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800057cc:	30 0b       	mov	r11,0
800057ce:	fe 7c 0c 00 	mov	r12,-62464
800057d2:	f0 1f 00 0e 	mcall	80005808 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
800057d6:	0e 9c       	mov	r12,r7
800057d8:	f0 1f 00 0d 	mcall	8000580c <rtc_init+0x74>
800057dc:	cf d1       	brne	800057d6 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
800057de:	a3 76       	lsl	r6,0x3
800057e0:	b1 a6       	sbr	r6,0x10
800057e2:	ed e5 10 85 	or	r5,r6,r5<<0x8
800057e6:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
800057e8:	0e 9c       	mov	r12,r7
800057ea:	f0 1f 00 09 	mcall	8000580c <rtc_init+0x74>
800057ee:	cf d1       	brne	800057e8 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
800057f0:	30 0b       	mov	r11,0
800057f2:	0e 9c       	mov	r12,r7
800057f4:	f0 1f 00 07 	mcall	80005810 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
800057f8:	3f fb       	mov	r11,-1
800057fa:	0e 9c       	mov	r12,r7
800057fc:	f0 1f 00 06 	mcall	80005814 <rtc_init+0x7c>
80005800:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	55 e4       	stdsp	sp[0x178],r4
80005808:	80 00       	ld.sh	r0,r0[0x0]
8000580a:	56 10       	stdsp	sp[0x184],r0
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	56 fc       	stdsp	sp[0x1bc],r12
80005810:	80 00       	ld.sh	r0,r0[0x0]
80005812:	57 04       	stdsp	sp[0x1c0],r4
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	57 54       	stdsp	sp[0x1d4],r4

80005818 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005818:	f8 c8 00 01 	sub	r8,r12,1
8000581c:	f0 0b 00 0b 	add	r11,r8,r11
80005820:	f6 0c 0d 0a 	divu	r10,r11,r12
80005824:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005826:	f4 c8 00 01 	sub	r8,r10,1
8000582a:	e0 48 00 fe 	cp.w	r8,254
8000582e:	e0 88 00 03 	brls	80005834 <getBaudDiv+0x1c>
80005832:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005834:	5c 8c       	casts.h	r12
}
80005836:	5e fc       	retal	r12

80005838 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005838:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000583c:	30 18       	mov	r8,1
8000583e:	f0 09 18 00 	cp.b	r9,r8
80005842:	e0 88 00 04 	brls	8000584a <spi_initMaster+0x12>
80005846:	30 2c       	mov	r12,2
80005848:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000584a:	e0 68 00 80 	mov	r8,128
8000584e:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005850:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005852:	30 19       	mov	r9,1
80005854:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005858:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000585c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005860:	30 09       	mov	r9,0
80005862:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005866:	30 fa       	mov	r10,15
80005868:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000586c:	99 18       	st.w	r12[0x4],r8
8000586e:	5e f9       	retal	r9

80005870 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005870:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005872:	30 18       	mov	r8,1
80005874:	f0 0b 18 00 	cp.b	r11,r8
80005878:	5f be       	srhi	lr
8000587a:	f0 0a 18 00 	cp.b	r10,r8
8000587e:	5f b8       	srhi	r8
80005880:	fd e8 10 08 	or	r8,lr,r8
80005884:	c0 30       	breq	8000588a <spi_selectionMode+0x1a>
80005886:	30 2c       	mov	r12,2
80005888:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000588a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000588c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005890:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005894:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005898:	99 18       	st.w	r12[0x4],r8
8000589a:	d8 0a       	popm	pc,r12=0

8000589c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000589c:	30 18       	mov	r8,1
8000589e:	99 08       	st.w	r12[0x0],r8
}
800058a0:	5e fc       	retal	r12

800058a2 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800058a2:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800058a6:	c0 58       	rjmp	800058b0 <spi_write+0xe>
		if (!timeout--) {
800058a8:	58 08       	cp.w	r8,0
800058aa:	c0 21       	brne	800058ae <spi_write+0xc>
800058ac:	5e ff       	retal	1
800058ae:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800058b0:	78 49       	ld.w	r9,r12[0x10]
800058b2:	e2 19 00 02 	andl	r9,0x2,COH
800058b6:	cf 90       	breq	800058a8 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800058b8:	5c 7b       	castu.h	r11
800058ba:	99 3b       	st.w	r12[0xc],r11
800058bc:	5e fd       	retal	0

800058be <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800058be:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058c2:	c0 58       	rjmp	800058cc <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800058c4:	58 08       	cp.w	r8,0
800058c6:	c0 21       	brne	800058ca <spi_read+0xc>
800058c8:	5e ff       	retal	1
800058ca:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058cc:	78 49       	ld.w	r9,r12[0x10]
800058ce:	e2 19 02 01 	andl	r9,0x201,COH
800058d2:	e0 49 02 01 	cp.w	r9,513
800058d6:	cf 71       	brne	800058c4 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800058d8:	78 28       	ld.w	r8,r12[0x8]
800058da:	b6 08       	st.h	r11[0x0],r8
800058dc:	5e fd       	retal	0
800058de:	d7 03       	nop

800058e0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800058e0:	eb cd 40 f8 	pushm	r3-r7,lr
800058e4:	18 95       	mov	r5,r12
800058e6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058e8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800058ec:	30 38       	mov	r8,3
800058ee:	f0 06 18 00 	cp.b	r6,r8
800058f2:	e0 8b 00 5e 	brhi	800059ae <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800058f6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058fa:	30 18       	mov	r8,1
800058fc:	f0 04 18 00 	cp.b	r4,r8
80005900:	e0 8b 00 57 	brhi	800059ae <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005904:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005908:	30 78       	mov	r8,7
8000590a:	f0 03 18 00 	cp.b	r3,r8
8000590e:	e0 88 00 50 	brls	800059ae <spi_setupChipReg+0xce>
80005912:	31 08       	mov	r8,16
80005914:	f0 03 18 00 	cp.b	r3,r8
80005918:	e0 8b 00 4b 	brhi	800059ae <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000591c:	14 9b       	mov	r11,r10
8000591e:	6e 1c       	ld.w	r12,r7[0x4]
80005920:	f0 1f 00 26 	mcall	800059b8 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005924:	c4 55       	brlt	800059ae <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005926:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005928:	ec 09 16 01 	lsr	r9,r6,0x1
8000592c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005930:	ec 16 00 01 	eorl	r6,0x1
80005934:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005938:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000593c:	20 83       	sub	r3,8
8000593e:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005942:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005946:	ef 39 00 09 	ld.ub	r9,r7[9]
8000594a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000594e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005952:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005956:	0f 89       	ld.ub	r9,r7[0x0]
80005958:	30 1a       	mov	r10,1
8000595a:	f4 09 18 00 	cp.b	r9,r10
8000595e:	c0 d0       	breq	80005978 <spi_setupChipReg+0x98>
80005960:	c0 a3       	brcs	80005974 <spi_setupChipReg+0x94>
80005962:	30 2a       	mov	r10,2
80005964:	f4 09 18 00 	cp.b	r9,r10
80005968:	c0 a0       	breq	8000597c <spi_setupChipReg+0x9c>
8000596a:	30 3a       	mov	r10,3
8000596c:	f4 09 18 00 	cp.b	r9,r10
80005970:	c1 f1       	brne	800059ae <spi_setupChipReg+0xce>
80005972:	c0 78       	rjmp	80005980 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005974:	8b c8       	st.w	r5[0x30],r8
		break;
80005976:	c0 68       	rjmp	80005982 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005978:	8b d8       	st.w	r5[0x34],r8
		break;
8000597a:	c0 48       	rjmp	80005982 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000597c:	8b e8       	st.w	r5[0x38],r8
		break;
8000597e:	c0 28       	rjmp	80005982 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005980:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005982:	48 f8       	lddpc	r8,800059bc <spi_setupChipReg+0xdc>
80005984:	70 08       	ld.w	r8,r8[0x0]
80005986:	58 08       	cp.w	r8,0
80005988:	c1 61       	brne	800059b4 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000598a:	30 0b       	mov	r11,0
8000598c:	30 1c       	mov	r12,1
8000598e:	f0 1f 00 0d 	mcall	800059c0 <spi_setupChipReg+0xe0>
80005992:	48 b8       	lddpc	r8,800059bc <spi_setupChipReg+0xdc>
80005994:	91 0c       	st.w	r8[0x0],r12
80005996:	58 0c       	cp.w	r12,0
80005998:	c0 a0       	breq	800059ac <spi_setupChipReg+0xcc>
8000599a:	30 09       	mov	r9,0
8000599c:	12 9a       	mov	r10,r9
8000599e:	12 9b       	mov	r11,r9
800059a0:	f0 1f 00 09 	mcall	800059c4 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800059a4:	48 68       	lddpc	r8,800059bc <spi_setupChipReg+0xdc>
800059a6:	70 08       	ld.w	r8,r8[0x0]
800059a8:	58 08       	cp.w	r8,0
800059aa:	c0 51       	brne	800059b4 <spi_setupChipReg+0xd4>
800059ac:	c0 08       	rjmp	800059ac <spi_setupChipReg+0xcc>
800059ae:	30 2c       	mov	r12,2
800059b0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800059b4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800059b8:	80 00       	ld.sh	r0,r0[0x0]
800059ba:	58 18       	cp.w	r8,1
800059bc:	00 00       	add	r0,r0
800059be:	53 bc       	stdsp	sp[0xec],r12
800059c0:	80 00       	ld.sh	r0,r0[0x0]
800059c2:	65 04       	ld.w	r4,r2[0x40]
800059c4:	80 00       	ld.sh	r0,r0[0x0]
800059c6:	63 ac       	ld.w	r12,r1[0x68]

800059c8 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059c8:	d4 01       	pushm	lr
800059ca:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059ce:	c0 58       	rjmp	800059d8 <spi_unselectChip+0x10>
		if (!timeout--) {
800059d0:	58 08       	cp.w	r8,0
800059d2:	c0 21       	brne	800059d6 <spi_unselectChip+0xe>
800059d4:	da 0a       	popm	pc,r12=1
800059d6:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059d8:	78 49       	ld.w	r9,r12[0x10]
800059da:	e2 19 02 00 	andl	r9,0x200,COH
800059de:	cf 90       	breq	800059d0 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800059e0:	78 18       	ld.w	r8,r12[0x4]
800059e2:	ea 18 00 0f 	orh	r8,0xf
800059e6:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800059e8:	fc 18 01 00 	movh	r8,0x100
800059ec:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800059ee:	30 09       	mov	r9,0
800059f0:	12 9a       	mov	r10,r9
800059f2:	12 9b       	mov	r11,r9
800059f4:	48 38       	lddpc	r8,80005a00 <spi_unselectChip+0x38>
800059f6:	70 0c       	ld.w	r12,r8[0x0]
800059f8:	f0 1f 00 03 	mcall	80005a04 <spi_unselectChip+0x3c>
800059fc:	d8 0a       	popm	pc,r12=0
800059fe:	00 00       	add	r0,r0
80005a00:	00 00       	add	r0,r0
80005a02:	53 bc       	stdsp	sp[0xec],r12
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	63 ac       	ld.w	r12,r1[0x68]

80005a08 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a08:	eb cd 40 f8 	pushm	r3-r7,lr
80005a0c:	18 94       	mov	r4,r12
80005a0e:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005a10:	49 a6       	lddpc	r6,80005a78 <spi_selectChip+0x70>
80005a12:	30 07       	mov	r7,0
80005a14:	31 45       	mov	r5,20
80005a16:	0e 99       	mov	r9,r7
80005a18:	0a 9a       	mov	r10,r5
80005a1a:	0e 9b       	mov	r11,r7
80005a1c:	6c 0c       	ld.w	r12,r6[0x0]
80005a1e:	f0 1f 00 18 	mcall	80005a7c <spi_selectChip+0x74>
80005a22:	cf a0       	breq	80005a16 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a24:	68 18       	ld.w	r8,r4[0x4]
80005a26:	ea 18 00 0f 	orh	r8,0xf
80005a2a:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005a2c:	68 18       	ld.w	r8,r4[0x4]
80005a2e:	e2 18 00 04 	andl	r8,0x4,COH
80005a32:	c1 10       	breq	80005a54 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005a34:	30 e8       	mov	r8,14
80005a36:	f0 03 18 00 	cp.b	r3,r8
80005a3a:	e0 8b 00 1c 	brhi	80005a72 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005a3e:	68 19       	ld.w	r9,r4[0x4]
80005a40:	e6 08 15 10 	lsl	r8,r3,0x10
80005a44:	ea 18 ff f0 	orh	r8,0xfff0
80005a48:	e8 18 ff ff 	orl	r8,0xffff
80005a4c:	12 68       	and	r8,r9
80005a4e:	89 18       	st.w	r4[0x4],r8
80005a50:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005a54:	30 38       	mov	r8,3
80005a56:	f0 03 18 00 	cp.b	r3,r8
80005a5a:	e0 8b 00 0c 	brhi	80005a72 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005a5e:	68 19       	ld.w	r9,r4[0x4]
80005a60:	2f 03       	sub	r3,-16
80005a62:	30 18       	mov	r8,1
80005a64:	f0 03 09 48 	lsl	r8,r8,r3
80005a68:	5c d8       	com	r8
80005a6a:	12 68       	and	r8,r9
80005a6c:	89 18       	st.w	r4[0x4],r8
80005a6e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a72:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005a74:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a78:	00 00       	add	r0,r0
80005a7a:	53 bc       	stdsp	sp[0xec],r12
80005a7c:	80 00       	ld.sh	r0,r0[0x0]
80005a7e:	61 a0       	ld.w	r0,r0[0x68]

80005a80 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005a80:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005a82:	f6 08 15 04 	lsl	r8,r11,0x4
80005a86:	14 38       	cp.w	r8,r10
80005a88:	f9 b8 08 10 	movls	r8,16
80005a8c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005a90:	f0 0b 02 4b 	mul	r11,r8,r11
80005a94:	f6 09 16 01 	lsr	r9,r11,0x1
80005a98:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005a9c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005aa0:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005aa4:	f2 cb 00 01 	sub	r11,r9,1
80005aa8:	e0 4b ff fe 	cp.w	r11,65534
80005aac:	e0 88 00 03 	brls	80005ab2 <usart_set_async_baudrate+0x32>
80005ab0:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005ab2:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005ab4:	e8 6e 00 00 	mov	lr,524288
80005ab8:	59 08       	cp.w	r8,16
80005aba:	fc 08 17 10 	movne	r8,lr
80005abe:	f9 b8 00 00 	moveq	r8,0
80005ac2:	e4 1b ff f7 	andh	r11,0xfff7
80005ac6:	e0 1b fe cf 	andl	r11,0xfecf
80005aca:	16 48       	or	r8,r11
80005acc:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005ace:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005ad2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005ad6:	99 89       	st.w	r12[0x20],r9
80005ad8:	d8 0a       	popm	pc,r12=0

80005ada <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005ada:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005adc:	e2 18 00 02 	andl	r8,0x2,COH
80005ae0:	c0 31       	brne	80005ae6 <usart_write_char+0xc>
80005ae2:	30 2c       	mov	r12,2
80005ae4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005ae6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005aea:	99 7b       	st.w	r12[0x1c],r11
80005aec:	5e fd       	retal	0
80005aee:	d7 03       	nop

80005af0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005af0:	eb cd 40 e0 	pushm	r5-r7,lr
80005af4:	18 96       	mov	r6,r12
80005af6:	16 95       	mov	r5,r11
80005af8:	e0 67 27 0f 	mov	r7,9999
80005afc:	c0 68       	rjmp	80005b08 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005afe:	58 07       	cp.w	r7,0
80005b00:	c0 31       	brne	80005b06 <usart_putchar+0x16>
80005b02:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005b06:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005b08:	0a 9b       	mov	r11,r5
80005b0a:	0c 9c       	mov	r12,r6
80005b0c:	f0 1f 00 03 	mcall	80005b18 <usart_putchar+0x28>
80005b10:	cf 71       	brne	80005afe <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005b12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b16:	00 00       	add	r0,r0
80005b18:	80 00       	ld.sh	r0,r0[0x0]
80005b1a:	5a da       	cp.w	r10,-19

80005b1c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005b1c:	78 58       	ld.w	r8,r12[0x14]
80005b1e:	e2 18 00 e0 	andl	r8,0xe0,COH
80005b22:	c0 30       	breq	80005b28 <usart_read_char+0xc>
80005b24:	30 4c       	mov	r12,4
80005b26:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005b28:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005b2a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005b2e:	c0 31       	brne	80005b34 <usart_read_char+0x18>
80005b30:	30 3c       	mov	r12,3
80005b32:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005b34:	78 68       	ld.w	r8,r12[0x18]
80005b36:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005b3a:	97 08       	st.w	r11[0x0],r8
80005b3c:	5e fd       	retal	0
80005b3e:	d7 03       	nop

80005b40 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005b40:	eb cd 40 c0 	pushm	r6-r7,lr
80005b44:	20 1d       	sub	sp,4
80005b46:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005b48:	1a 97       	mov	r7,sp
80005b4a:	1a 9b       	mov	r11,sp
80005b4c:	0c 9c       	mov	r12,r6
80005b4e:	f0 1f 00 07 	mcall	80005b68 <usart_getchar+0x28>
80005b52:	58 3c       	cp.w	r12,3
80005b54:	cf b0       	breq	80005b4a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005b56:	58 4c       	cp.w	r12,4
80005b58:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005b5c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005b60:	2f fd       	sub	sp,-4
80005b62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b66:	00 00       	add	r0,r0
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	5b 1c       	cp.w	r12,-15

80005b6c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005b6c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b70:	18 96       	mov	r6,r12
80005b72:	16 97       	mov	r7,r11
  while (*string != '\0')
80005b74:	17 8b       	ld.ub	r11,r11[0x0]
80005b76:	58 0b       	cp.w	r11,0
80005b78:	c0 80       	breq	80005b88 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005b7a:	2f f7       	sub	r7,-1
80005b7c:	0c 9c       	mov	r12,r6
80005b7e:	f0 1f 00 04 	mcall	80005b8c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005b82:	0f 8b       	ld.ub	r11,r7[0x0]
80005b84:	58 0b       	cp.w	r11,0
80005b86:	cf a1       	brne	80005b7a <usart_write_line+0xe>
80005b88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b8c:	80 00       	ld.sh	r0,r0[0x0]
80005b8e:	5a f0       	cp.w	r0,-17

80005b90 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005b90:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005b94:	e6 18 00 01 	andh	r8,0x1,COH
80005b98:	c0 71       	brne	80005ba6 <usart_reset+0x16>
80005b9a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005b9c:	3f f8       	mov	r8,-1
80005b9e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005ba0:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005ba2:	d5 03       	csrf	0x10
80005ba4:	c0 48       	rjmp	80005bac <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005ba6:	3f f8       	mov	r8,-1
80005ba8:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005baa:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005bac:	30 08       	mov	r8,0
80005bae:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005bb0:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005bb2:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005bb4:	ea 68 61 0c 	mov	r8,680204
80005bb8:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005bba:	5e fc       	retal	r12

80005bbc <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005bbc:	eb cd 40 e0 	pushm	r5-r7,lr
80005bc0:	18 96       	mov	r6,r12
80005bc2:	16 97       	mov	r7,r11
80005bc4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005bc6:	f0 1f 00 2f 	mcall	80005c80 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005bca:	58 07       	cp.w	r7,0
80005bcc:	c5 80       	breq	80005c7c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005bce:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005bd0:	30 49       	mov	r9,4
80005bd2:	f2 08 18 00 	cp.b	r8,r9
80005bd6:	e0 88 00 53 	brls	80005c7c <usart_init_rs232+0xc0>
80005bda:	30 99       	mov	r9,9
80005bdc:	f2 08 18 00 	cp.b	r8,r9
80005be0:	e0 8b 00 4e 	brhi	80005c7c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005be4:	0f d9       	ld.ub	r9,r7[0x5]
80005be6:	30 78       	mov	r8,7
80005be8:	f0 09 18 00 	cp.b	r9,r8
80005bec:	e0 8b 00 48 	brhi	80005c7c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005bf0:	8e 39       	ld.sh	r9,r7[0x6]
80005bf2:	e0 68 01 01 	mov	r8,257
80005bf6:	f0 09 19 00 	cp.h	r9,r8
80005bfa:	e0 8b 00 41 	brhi	80005c7c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005bfe:	ef 39 00 08 	ld.ub	r9,r7[8]
80005c02:	30 38       	mov	r8,3
80005c04:	f0 09 18 00 	cp.b	r9,r8
80005c08:	e0 8b 00 3a 	brhi	80005c7c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005c0c:	0a 9a       	mov	r10,r5
80005c0e:	6e 0b       	ld.w	r11,r7[0x0]
80005c10:	0c 9c       	mov	r12,r6
80005c12:	f0 1f 00 1d 	mcall	80005c84 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c16:	58 1c       	cp.w	r12,1
80005c18:	c3 20       	breq	80005c7c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005c1a:	0f c8       	ld.ub	r8,r7[0x4]
80005c1c:	30 99       	mov	r9,9
80005c1e:	f2 08 18 00 	cp.b	r8,r9
80005c22:	c0 51       	brne	80005c2c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005c24:	6c 18       	ld.w	r8,r6[0x4]
80005c26:	b1 b8       	sbr	r8,0x11
80005c28:	8d 18       	st.w	r6[0x4],r8
80005c2a:	c0 68       	rjmp	80005c36 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005c2c:	6c 19       	ld.w	r9,r6[0x4]
80005c2e:	20 58       	sub	r8,5
80005c30:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005c34:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005c36:	6c 19       	ld.w	r9,r6[0x4]
80005c38:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005c3c:	0f d8       	ld.ub	r8,r7[0x5]
80005c3e:	a9 78       	lsl	r8,0x9
80005c40:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005c44:	12 48       	or	r8,r9
80005c46:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005c48:	8e 38       	ld.sh	r8,r7[0x6]
80005c4a:	30 29       	mov	r9,2
80005c4c:	f2 08 19 00 	cp.h	r8,r9
80005c50:	e0 88 00 09 	brls	80005c62 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005c54:	6c 18       	ld.w	r8,r6[0x4]
80005c56:	ad b8       	sbr	r8,0xd
80005c58:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005c5a:	8e b8       	ld.uh	r8,r7[0x6]
80005c5c:	20 28       	sub	r8,2
80005c5e:	8d a8       	st.w	r6[0x28],r8
80005c60:	c0 68       	rjmp	80005c6c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005c62:	6c 19       	ld.w	r9,r6[0x4]
80005c64:	5c 78       	castu.h	r8
80005c66:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005c6a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005c6c:	6c 18       	ld.w	r8,r6[0x4]
80005c6e:	e0 18 ff f0 	andl	r8,0xfff0
80005c72:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005c74:	35 08       	mov	r8,80
80005c76:	8d 08       	st.w	r6[0x0],r8
80005c78:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005c7c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005c80:	80 00       	ld.sh	r0,r0[0x0]
80005c82:	5b 90       	cp.w	r0,-7
80005c84:	80 00       	ld.sh	r0,r0[0x0]
80005c86:	5a 80       	cp.w	r0,-24

80005c88 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005c88:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005c8c:	fe c0 8e 8c 	sub	r0,pc,-29044

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005c90:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005c94:	d5 53       	csrf	0x15
  cp      r0, r1
80005c96:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005c98:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005c9c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005c9e:	c0 62       	brcc	80005caa <idata_load_loop_end>
  cp      r0, r1
80005ca0:	48 92       	lddpc	r2,80005cc4 <udata_clear_loop_end+0x4>

80005ca2 <idata_load_loop>:
  brlo    idata_load_loop
80005ca2:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005ca4:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005ca6:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005ca8:	cf d3       	brcs	80005ca2 <idata_load_loop>

80005caa <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005caa:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
80005cae:	e0 61 53 d0 	mov	r1,21456
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005cb2:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005cb4:	c0 62       	brcc	80005cc0 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005cb6:	30 02       	mov	r2,0
80005cb8:	30 03       	mov	r3,0

80005cba <udata_clear_loop>:
80005cba:	a1 22       	st.d	r0++,r2
80005cbc:	02 30       	cp.w	r0,r1
80005cbe:	cf e3       	brcs	80005cba <udata_clear_loop>

80005cc0 <udata_clear_loop_end>:
80005cc0:	fe cf e9 28 	sub	pc,pc,-5848
80005cc4:	80 00       	ld.sh	r0,r0[0x0]
80005cc6:	e2 b8       	*unknown*

80005cc8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005cc8:	f8 c8 ff f8 	sub	r8,r12,-8
80005ccc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005cce:	3f f9       	mov	r9,-1
80005cd0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005cd2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005cd4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005cd6:	30 08       	mov	r8,0
80005cd8:	99 08       	st.w	r12[0x0],r8
}
80005cda:	5e fc       	retal	r12

80005cdc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005cdc:	30 08       	mov	r8,0
80005cde:	99 48       	st.w	r12[0x10],r8
}
80005ce0:	5e fc       	retal	r12

80005ce2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005ce2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005ce4:	70 19       	ld.w	r9,r8[0x4]
80005ce6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005ce8:	78 19       	ld.w	r9,r12[0x4]
80005cea:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005cec:	70 19       	ld.w	r9,r8[0x4]
80005cee:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005cf0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005cf2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005cf4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005cf6:	78 08       	ld.w	r8,r12[0x0]
80005cf8:	2f f8       	sub	r8,-1
80005cfa:	99 08       	st.w	r12[0x0],r8
}
80005cfc:	5e fc       	retal	r12

80005cfe <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005cfe:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005d00:	5b fa       	cp.w	r10,-1
80005d02:	c0 31       	brne	80005d08 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005d04:	78 48       	ld.w	r8,r12[0x10]
80005d06:	c0 c8       	rjmp	80005d1e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005d08:	f8 c8 ff f8 	sub	r8,r12,-8
80005d0c:	70 19       	ld.w	r9,r8[0x4]
80005d0e:	72 09       	ld.w	r9,r9[0x0]
80005d10:	12 3a       	cp.w	r10,r9
80005d12:	c0 63       	brcs	80005d1e <vListInsert+0x20>
80005d14:	70 18       	ld.w	r8,r8[0x4]
80005d16:	70 19       	ld.w	r9,r8[0x4]
80005d18:	72 09       	ld.w	r9,r9[0x0]
80005d1a:	12 3a       	cp.w	r10,r9
80005d1c:	cf c2       	brcc	80005d14 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005d1e:	70 19       	ld.w	r9,r8[0x4]
80005d20:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d22:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005d24:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d26:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d28:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d2a:	78 08       	ld.w	r8,r12[0x0]
80005d2c:	2f f8       	sub	r8,-1
80005d2e:	99 08       	st.w	r12[0x0],r8
}
80005d30:	5e fc       	retal	r12

80005d32 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005d32:	78 18       	ld.w	r8,r12[0x4]
80005d34:	78 29       	ld.w	r9,r12[0x8]
80005d36:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005d38:	78 28       	ld.w	r8,r12[0x8]
80005d3a:	78 19       	ld.w	r9,r12[0x4]
80005d3c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005d3e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005d40:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005d42:	18 39       	cp.w	r9,r12
80005d44:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005d48:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005d4c:	30 09       	mov	r9,0
80005d4e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005d50:	70 09       	ld.w	r9,r8[0x0]
80005d52:	20 19       	sub	r9,1
80005d54:	91 09       	st.w	r8[0x0],r9
}
80005d56:	5e fc       	retal	r12

80005d58 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005d58:	e0 68 08 08 	mov	r8,2056
80005d5c:	ea 18 08 08 	orh	r8,0x808
80005d60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005d62:	e0 68 09 09 	mov	r8,2313
80005d66:	ea 18 09 09 	orh	r8,0x909
80005d6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005d6c:	e0 68 0a 0a 	mov	r8,2570
80005d70:	ea 18 0a 0a 	orh	r8,0xa0a
80005d74:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005d76:	e0 68 0b 0b 	mov	r8,2827
80005d7a:	ea 18 0b 0b 	orh	r8,0xb0b
80005d7e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005d80:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005d82:	e0 68 be ef 	mov	r8,48879
80005d86:	ea 18 de ad 	orh	r8,0xdead
80005d8a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005d8c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005d8e:	fc 18 00 40 	movh	r8,0x40
80005d92:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005d94:	e0 68 00 ff 	mov	r8,255
80005d98:	ea 18 ff 00 	orh	r8,0xff00
80005d9c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005d9e:	e0 68 01 01 	mov	r8,257
80005da2:	ea 18 01 01 	orh	r8,0x101
80005da6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005da8:	e0 68 02 02 	mov	r8,514
80005dac:	ea 18 02 02 	orh	r8,0x202
80005db0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005db2:	e0 68 03 03 	mov	r8,771
80005db6:	ea 18 03 03 	orh	r8,0x303
80005dba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005dbc:	e0 68 04 04 	mov	r8,1028
80005dc0:	ea 18 04 04 	orh	r8,0x404
80005dc4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005dc6:	e0 68 05 05 	mov	r8,1285
80005dca:	ea 18 05 05 	orh	r8,0x505
80005dce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005dd0:	e0 68 06 06 	mov	r8,1542
80005dd4:	ea 18 06 06 	orh	r8,0x606
80005dd8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005dda:	e0 68 07 07 	mov	r8,1799
80005dde:	ea 18 07 07 	orh	r8,0x707
80005de2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005de4:	30 08       	mov	r8,0
80005de6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005de8:	5e fc       	retal	r12
80005dea:	d7 03       	nop

80005dec <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005dec:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005dee:	48 38       	lddpc	r8,80005df8 <vPortEnterCritical+0xc>
80005df0:	70 09       	ld.w	r9,r8[0x0]
80005df2:	2f f9       	sub	r9,-1
80005df4:	91 09       	st.w	r8[0x0],r9
}
80005df6:	5e fc       	retal	r12
80005df8:	00 00       	add	r0,r0
80005dfa:	05 38       	ld.ub	r8,r2++

80005dfc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005dfc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005dfe:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005e00:	30 0a       	mov	r10,0
80005e02:	14 9b       	mov	r11,r10
80005e04:	49 2c       	lddpc	r12,80005e4c <xPortStartScheduler+0x50>
80005e06:	f0 1f 00 13 	mcall	80005e50 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005e0a:	e0 68 5d c0 	mov	r8,24000
80005e0e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005e12:	30 08       	mov	r8,0
80005e14:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005e18:	e0 68 0c f0 	mov	r8,3312
80005e1c:	ea 18 00 00 	orh	r8,0x0
80005e20:	70 00       	ld.w	r0,r8[0x0]
80005e22:	60 0d       	ld.w	sp,r0[0x0]
80005e24:	1b 00       	ld.w	r0,sp++
80005e26:	e0 68 05 38 	mov	r8,1336
80005e2a:	ea 18 00 00 	orh	r8,0x0
80005e2e:	91 00       	st.w	r8[0x0],r0
80005e30:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e34:	2f ed       	sub	sp,-8
80005e36:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005e3a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005e3e:	e3 b0 00 00 	mtsr	0x0,r0
80005e42:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005e46:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005e4a:	d8 0a       	popm	pc,r12=0
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	5f 18       	srne	r8
80005e50:	80 00       	ld.sh	r0,r0[0x0]
80005e52:	54 4c       	stdsp	sp[0x110],r12

80005e54 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005e54:	20 6d       	sub	sp,24
80005e56:	eb cd 00 ff 	pushm	r0-r7
80005e5a:	fa c7 ff c0 	sub	r7,sp,-64
80005e5e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005e62:	ef 40 ff e0 	st.w	r7[-32],r0
80005e66:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005e6a:	ef 40 ff e4 	st.w	r7[-28],r0
80005e6e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005e72:	e0 68 05 38 	mov	r8,1336
80005e76:	ea 18 00 00 	orh	r8,0x0
80005e7a:	70 00       	ld.w	r0,r8[0x0]
80005e7c:	1a d0       	st.w	--sp,r0
80005e7e:	f0 1f 00 1a 	mcall	80005ee4 <LABEL_RET_SCALL_263+0x14>
80005e82:	e0 68 0c f0 	mov	r8,3312
80005e86:	ea 18 00 00 	orh	r8,0x0
80005e8a:	70 00       	ld.w	r0,r8[0x0]
80005e8c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005e8e:	f0 1f 00 17 	mcall	80005ee8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005e92:	e0 68 0c f0 	mov	r8,3312
80005e96:	ea 18 00 00 	orh	r8,0x0
80005e9a:	70 00       	ld.w	r0,r8[0x0]
80005e9c:	60 0d       	ld.w	sp,r0[0x0]
80005e9e:	1b 00       	ld.w	r0,sp++
80005ea0:	e0 68 05 38 	mov	r8,1336
80005ea4:	ea 18 00 00 	orh	r8,0x0
80005ea8:	91 00       	st.w	r8[0x0],r0
80005eaa:	fa c7 ff d8 	sub	r7,sp,-40
80005eae:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005eb2:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005eb6:	e0 61 05 38 	mov	r1,1336
80005eba:	ea 11 00 00 	orh	r1,0x0
80005ebe:	62 02       	ld.w	r2,r1[0x0]
80005ec0:	58 02       	cp.w	r2,0
80005ec2:	c0 70       	breq	80005ed0 <LABEL_RET_SCALL_263>
80005ec4:	e4 c2 00 01 	sub	r2,r2,1
80005ec8:	83 02       	st.w	r1[0x0],r2
80005eca:	58 02       	cp.w	r2,0
80005ecc:	c0 21       	brne	80005ed0 <LABEL_RET_SCALL_263>
80005ece:	b1 c0       	cbr	r0,0x10

80005ed0 <LABEL_RET_SCALL_263>:
80005ed0:	ef 40 ff f8 	st.w	r7[-8],r0
80005ed4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005ed8:	ef 40 ff fc 	st.w	r7[-4],r0
80005edc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ee0:	2f ad       	sub	sp,-24
80005ee2:	d6 13       	rets
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	5d ec       	*unknown*
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	65 88       	ld.w	r8,r2[0x60]

80005eec <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005eec:	e1 b8 00 43 	mfsr	r8,0x10c
80005ef0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005ef4:	5e fc       	retal	r12
80005ef6:	d7 03       	nop

80005ef8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005ef8:	48 78       	lddpc	r8,80005f14 <vPortExitCritical+0x1c>
80005efa:	70 08       	ld.w	r8,r8[0x0]
80005efc:	58 08       	cp.w	r8,0
80005efe:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005f00:	48 58       	lddpc	r8,80005f14 <vPortExitCritical+0x1c>
80005f02:	70 09       	ld.w	r9,r8[0x0]
80005f04:	20 19       	sub	r9,1
80005f06:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005f08:	70 08       	ld.w	r8,r8[0x0]
80005f0a:	58 08       	cp.w	r8,0
80005f0c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005f0e:	d5 03       	csrf	0x10
80005f10:	5e fc       	retal	r12
80005f12:	00 00       	add	r0,r0
80005f14:	00 00       	add	r0,r0
80005f16:	05 38       	ld.ub	r8,r2++

80005f18 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005f18:	eb cd 00 ff 	pushm	r0-r7
80005f1c:	e0 68 05 38 	mov	r8,1336
80005f20:	ea 18 00 00 	orh	r8,0x0
80005f24:	70 00       	ld.w	r0,r8[0x0]
80005f26:	1a d0       	st.w	--sp,r0
80005f28:	7a 90       	ld.w	r0,sp[0x24]
80005f2a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f2e:	58 10       	cp.w	r0,1
80005f30:	e0 8b 00 08 	brhi	80005f40 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005f34:	e0 68 0c f0 	mov	r8,3312
80005f38:	ea 18 00 00 	orh	r8,0x0
80005f3c:	70 00       	ld.w	r0,r8[0x0]
80005f3e:	81 0d       	st.w	r0[0x0],sp

80005f40 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005f40:	f0 1f 00 12 	mcall	80005f88 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005f44:	f0 1f 00 12 	mcall	80005f8c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005f48:	f0 1f 00 12 	mcall	80005f90 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005f4c:	f0 1f 00 12 	mcall	80005f94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005f50:	7a 90       	ld.w	r0,sp[0x24]
80005f52:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f56:	58 10       	cp.w	r0,1
80005f58:	e0 8b 00 0e 	brhi	80005f74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005f5c:	f0 1f 00 0c 	mcall	80005f8c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005f60:	f0 1f 00 0e 	mcall	80005f98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005f64:	f0 1f 00 0c 	mcall	80005f94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005f68:	e0 68 0c f0 	mov	r8,3312
80005f6c:	ea 18 00 00 	orh	r8,0x0
80005f70:	70 00       	ld.w	r0,r8[0x0]
80005f72:	60 0d       	ld.w	sp,r0[0x0]

80005f74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005f74:	1b 00       	ld.w	r0,sp++
80005f76:	e0 68 05 38 	mov	r8,1336
80005f7a:	ea 18 00 00 	orh	r8,0x0
80005f7e:	91 00       	st.w	r8[0x0],r0
80005f80:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f84:	d6 03       	rete
80005f86:	00 00       	add	r0,r0
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	5e ec       	retqs	r12
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	5d ec       	*unknown*
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	67 8c       	ld.w	r12,r3[0x60]
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	5e f8       	retal	r8
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	65 88       	ld.w	r8,r2[0x60]

80005f9c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005f9c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005f9e:	f0 1f 00 02 	mcall	80005fa4 <__malloc_lock+0x8>
}
80005fa2:	d8 02       	popm	pc
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	65 78       	ld.w	r8,r2[0x5c]

80005fa8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005fa8:	d4 01       	pushm	lr
	xTaskResumeAll();
80005faa:	f0 1f 00 02 	mcall	80005fb0 <__malloc_unlock+0x8>
}
80005fae:	d8 02       	popm	pc
80005fb0:	80 00       	ld.sh	r0,r0[0x0]
80005fb2:	69 34       	ld.w	r4,r4[0x4c]

80005fb4 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005fb4:	d4 21       	pushm	r4-r7,lr
80005fb6:	16 95       	mov	r5,r11
80005fb8:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005fba:	58 0c       	cp.w	r12,0
80005fbc:	c0 30       	breq	80005fc2 <_read+0xe>
80005fbe:	3f f7       	mov	r7,-1
80005fc0:	c1 48       	rjmp	80005fe8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005fc2:	58 0a       	cp.w	r10,0
80005fc4:	e0 89 00 04 	brgt	80005fcc <_read+0x18>
80005fc8:	30 07       	mov	r7,0
80005fca:	c0 f8       	rjmp	80005fe8 <_read+0x34>
80005fcc:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005fce:	48 84       	lddpc	r4,80005fec <_read+0x38>
80005fd0:	68 0c       	ld.w	r12,r4[0x0]
80005fd2:	f0 1f 00 08 	mcall	80005ff0 <_read+0x3c>
    if (c < 0)
80005fd6:	c0 95       	brlt	80005fe8 <_read+0x34>
      break;

    *ptr++ = c;
80005fd8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005fdc:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005fde:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005fe2:	58 08       	cp.w	r8,0
80005fe4:	fe 99 ff f6 	brgt	80005fd0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005fe8:	0e 9c       	mov	r12,r7
80005fea:	d8 22       	popm	r4-r7,pc
80005fec:	00 00       	add	r0,r0
80005fee:	53 c0       	stdsp	sp[0xf0],r0
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	5b 40       	cp.w	r0,-12

80005ff4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005ff4:	d4 21       	pushm	r4-r7,lr
80005ff6:	16 95       	mov	r5,r11
80005ff8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005ffa:	20 1c       	sub	r12,1
80005ffc:	58 2c       	cp.w	r12,2
80005ffe:	e0 8b 00 12 	brhi	80006022 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006002:	58 0a       	cp.w	r10,0
80006004:	c0 31       	brne	8000600a <_write+0x16>
80006006:	30 07       	mov	r7,0
80006008:	c0 e8       	rjmp	80006024 <_write+0x30>
8000600a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
8000600c:	48 74       	lddpc	r4,80006028 <_write+0x34>
8000600e:	68 0c       	ld.w	r12,r4[0x0]
80006010:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006014:	f0 1f 00 06 	mcall	8000602c <_write+0x38>
80006018:	c0 55       	brlt	80006022 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000601a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000601c:	0e 36       	cp.w	r6,r7
8000601e:	cf 81       	brne	8000600e <_write+0x1a>
80006020:	c0 28       	rjmp	80006024 <_write+0x30>
80006022:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006024:	0e 9c       	mov	r12,r7
80006026:	d8 22       	popm	r4-r7,pc
80006028:	00 00       	add	r0,r0
8000602a:	53 c0       	stdsp	sp[0xf0],r0
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	5a f0       	cp.w	r0,-17

80006030 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006030:	eb cd 40 80 	pushm	r7,lr
80006034:	18 97       	mov	r7,r12
	if( pv )
80006036:	58 0c       	cp.w	r12,0
80006038:	c0 80       	breq	80006048 <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000603a:	f0 1f 00 05 	mcall	8000604c <vPortFree+0x1c>
		{
			free( pv );
8000603e:	0e 9c       	mov	r12,r7
80006040:	f0 1f 00 04 	mcall	80006050 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006044:	f0 1f 00 04 	mcall	80006054 <vPortFree+0x24>
80006048:	e3 cd 80 80 	ldm	sp++,r7,pc
8000604c:	80 00       	ld.sh	r0,r0[0x0]
8000604e:	65 78       	ld.w	r8,r2[0x5c]
80006050:	80 00       	ld.sh	r0,r0[0x0]
80006052:	74 10       	ld.w	r0,r10[0x4]
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	69 34       	ld.w	r4,r4[0x4c]

80006058 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006058:	eb cd 40 80 	pushm	r7,lr
8000605c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000605e:	f0 1f 00 06 	mcall	80006074 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006062:	0e 9c       	mov	r12,r7
80006064:	f0 1f 00 05 	mcall	80006078 <pvPortMalloc+0x20>
80006068:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000606a:	f0 1f 00 05 	mcall	8000607c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000606e:	0e 9c       	mov	r12,r7
80006070:	e3 cd 80 80 	ldm	sp++,r7,pc
80006074:	80 00       	ld.sh	r0,r0[0x0]
80006076:	65 78       	ld.w	r8,r2[0x5c]
80006078:	80 00       	ld.sh	r0,r0[0x0]
8000607a:	74 20       	ld.w	r0,r10[0x8]
8000607c:	80 00       	ld.sh	r0,r0[0x0]
8000607e:	69 34       	ld.w	r4,r4[0x4c]

80006080 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006080:	d4 01       	pushm	lr
80006082:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006084:	78 09       	ld.w	r9,r12[0x0]
80006086:	58 09       	cp.w	r9,0
80006088:	c1 10       	breq	800060aa <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000608a:	78 3a       	ld.w	r10,r12[0xc]
8000608c:	79 09       	ld.w	r9,r12[0x40]
8000608e:	f4 09 00 09 	add	r9,r10,r9
80006092:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006094:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006096:	14 39       	cp.w	r9,r10
80006098:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000609c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800060a0:	79 0a       	ld.w	r10,r12[0x40]
800060a2:	78 3b       	ld.w	r11,r12[0xc]
800060a4:	10 9c       	mov	r12,r8
800060a6:	f0 1f 00 02 	mcall	800060ac <prvCopyDataFromQueue+0x2c>
800060aa:	d8 02       	popm	pc
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	78 68       	ld.w	r8,r12[0x18]

800060b0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800060b0:	eb cd 40 c0 	pushm	r6-r7,lr
800060b4:	18 97       	mov	r7,r12
800060b6:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800060b8:	78 e8       	ld.w	r8,r12[0x38]
800060ba:	58 08       	cp.w	r8,0
800060bc:	c0 31       	brne	800060c2 <xQueueReceiveFromISR+0x12>
800060be:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800060c2:	f0 1f 00 0e 	mcall	800060f8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800060c6:	6e e8       	ld.w	r8,r7[0x38]
800060c8:	20 18       	sub	r8,1
800060ca:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800060cc:	6f 18       	ld.w	r8,r7[0x44]
800060ce:	5b f8       	cp.w	r8,-1
800060d0:	c0 d1       	brne	800060ea <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060d2:	6e 48       	ld.w	r8,r7[0x10]
800060d4:	58 08       	cp.w	r8,0
800060d6:	c0 f0       	breq	800060f4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060d8:	ee cc ff f0 	sub	r12,r7,-16
800060dc:	f0 1f 00 08 	mcall	800060fc <xQueueReceiveFromISR+0x4c>
800060e0:	c0 a0       	breq	800060f4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800060e2:	30 1c       	mov	r12,1
800060e4:	8d 0c       	st.w	r6[0x0],r12
800060e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800060ea:	2f f8       	sub	r8,-1
800060ec:	ef 48 00 44 	st.w	r7[68],r8
800060f0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800060f4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	60 80       	ld.w	r0,r0[0x20]
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	67 10       	ld.w	r0,r3[0x44]

80006100 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006100:	eb cd 40 c0 	pushm	r6-r7,lr
80006104:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80006106:	f0 1f 00 23 	mcall	80006190 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000610a:	6f 28       	ld.w	r8,r7[0x48]
8000610c:	58 08       	cp.w	r8,0
8000610e:	e0 8a 00 18 	brle	8000613e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006112:	6e 98       	ld.w	r8,r7[0x24]
80006114:	58 08       	cp.w	r8,0
80006116:	c1 40       	breq	8000613e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006118:	ee c6 ff dc 	sub	r6,r7,-36
8000611c:	c0 48       	rjmp	80006124 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000611e:	6e 98       	ld.w	r8,r7[0x24]
80006120:	58 08       	cp.w	r8,0
80006122:	c0 e0       	breq	8000613e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006124:	0c 9c       	mov	r12,r6
80006126:	f0 1f 00 1c 	mcall	80006194 <prvUnlockQueue+0x94>
8000612a:	c0 30       	breq	80006130 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000612c:	f0 1f 00 1b 	mcall	80006198 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006130:	6f 28       	ld.w	r8,r7[0x48]
80006132:	20 18       	sub	r8,1
80006134:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006138:	58 08       	cp.w	r8,0
8000613a:	fe 99 ff f2 	brgt	8000611e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000613e:	3f f8       	mov	r8,-1
80006140:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006144:	f0 1f 00 16 	mcall	8000619c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006148:	f0 1f 00 12 	mcall	80006190 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000614c:	6f 18       	ld.w	r8,r7[0x44]
8000614e:	58 08       	cp.w	r8,0
80006150:	e0 8a 00 18 	brle	80006180 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006154:	6e 48       	ld.w	r8,r7[0x10]
80006156:	58 08       	cp.w	r8,0
80006158:	c1 40       	breq	80006180 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000615a:	ee c6 ff f0 	sub	r6,r7,-16
8000615e:	c0 48       	rjmp	80006166 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006160:	6e 48       	ld.w	r8,r7[0x10]
80006162:	58 08       	cp.w	r8,0
80006164:	c0 e0       	breq	80006180 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006166:	0c 9c       	mov	r12,r6
80006168:	f0 1f 00 0b 	mcall	80006194 <prvUnlockQueue+0x94>
8000616c:	c0 30       	breq	80006172 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000616e:	f0 1f 00 0b 	mcall	80006198 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006172:	6f 18       	ld.w	r8,r7[0x44]
80006174:	20 18       	sub	r8,1
80006176:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000617a:	58 08       	cp.w	r8,0
8000617c:	fe 99 ff f2 	brgt	80006160 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006180:	3f f8       	mov	r8,-1
80006182:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006186:	f0 1f 00 06 	mcall	8000619c <prvUnlockQueue+0x9c>
}
8000618a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000618e:	00 00       	add	r0,r0
80006190:	80 00       	ld.sh	r0,r0[0x0]
80006192:	5d ec       	*unknown*
80006194:	80 00       	ld.sh	r0,r0[0x0]
80006196:	67 10       	ld.w	r0,r3[0x44]
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	66 1c       	ld.w	r12,r3[0x4]
8000619c:	80 00       	ld.sh	r0,r0[0x0]
8000619e:	5e f8       	retal	r8

800061a0 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800061a0:	d4 31       	pushm	r0-r7,lr
800061a2:	20 5d       	sub	sp,20
800061a4:	18 97       	mov	r7,r12
800061a6:	50 0b       	stdsp	sp[0x0],r11
800061a8:	50 2a       	stdsp	sp[0x8],r10
800061aa:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800061ac:	f8 c2 ff dc 	sub	r2,r12,-36
800061b0:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061b2:	fa c4 ff f4 	sub	r4,sp,-12
800061b6:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061b8:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061ba:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800061be:	f0 1f 00 3e 	mcall	800062b4 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800061c2:	6e e8       	ld.w	r8,r7[0x38]
800061c4:	58 08       	cp.w	r8,0
800061c6:	c2 a0       	breq	8000621a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800061c8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800061ca:	40 0b       	lddsp	r11,sp[0x0]
800061cc:	0e 9c       	mov	r12,r7
800061ce:	f0 1f 00 3b 	mcall	800062b8 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800061d2:	40 18       	lddsp	r8,sp[0x4]
800061d4:	58 08       	cp.w	r8,0
800061d6:	c1 51       	brne	80006200 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800061d8:	6e e8       	ld.w	r8,r7[0x38]
800061da:	20 18       	sub	r8,1
800061dc:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800061de:	6e 08       	ld.w	r8,r7[0x0]
800061e0:	58 08       	cp.w	r8,0
800061e2:	c0 41       	brne	800061ea <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800061e4:	f0 1f 00 36 	mcall	800062bc <xQueueGenericReceive+0x11c>
800061e8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061ea:	6e 48       	ld.w	r8,r7[0x10]
800061ec:	58 08       	cp.w	r8,0
800061ee:	c1 20       	breq	80006212 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800061f0:	ee cc ff f0 	sub	r12,r7,-16
800061f4:	f0 1f 00 33 	mcall	800062c0 <xQueueGenericReceive+0x120>
800061f8:	58 1c       	cp.w	r12,1
800061fa:	c0 c1       	brne	80006212 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800061fc:	d7 33       	scall
800061fe:	c0 a8       	rjmp	80006212 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006200:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006202:	6e 98       	ld.w	r8,r7[0x24]
80006204:	58 08       	cp.w	r8,0
80006206:	c0 60       	breq	80006212 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006208:	04 9c       	mov	r12,r2
8000620a:	f0 1f 00 2e 	mcall	800062c0 <xQueueGenericReceive+0x120>
8000620e:	c0 20       	breq	80006212 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006210:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006212:	f0 1f 00 2d 	mcall	800062c4 <xQueueGenericReceive+0x124>
80006216:	30 1c       	mov	r12,1
				return pdPASS;
80006218:	c4 c8       	rjmp	800062b0 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000621a:	40 28       	lddsp	r8,sp[0x8]
8000621c:	58 08       	cp.w	r8,0
8000621e:	c0 51       	brne	80006228 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006220:	f0 1f 00 29 	mcall	800062c4 <xQueueGenericReceive+0x124>
80006224:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006226:	c4 58       	rjmp	800062b0 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006228:	58 05       	cp.w	r5,0
8000622a:	c0 51       	brne	80006234 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000622c:	08 9c       	mov	r12,r4
8000622e:	f0 1f 00 27 	mcall	800062c8 <xQueueGenericReceive+0x128>
80006232:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006234:	f0 1f 00 24 	mcall	800062c4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006238:	f0 1f 00 25 	mcall	800062cc <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000623c:	f0 1f 00 1e 	mcall	800062b4 <xQueueGenericReceive+0x114>
80006240:	6f 18       	ld.w	r8,r7[0x44]
80006242:	5b f8       	cp.w	r8,-1
80006244:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006248:	6f 28       	ld.w	r8,r7[0x48]
8000624a:	5b f8       	cp.w	r8,-1
8000624c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006250:	f0 1f 00 1d 	mcall	800062c4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006254:	06 9b       	mov	r11,r3
80006256:	08 9c       	mov	r12,r4
80006258:	f0 1f 00 1e 	mcall	800062d0 <xQueueGenericReceive+0x130>
8000625c:	c2 41       	brne	800062a4 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000625e:	f0 1f 00 16 	mcall	800062b4 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006262:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006264:	f0 1f 00 18 	mcall	800062c4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006268:	58 06       	cp.w	r6,0
8000626a:	c1 71       	brne	80006298 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000626c:	6e 08       	ld.w	r8,r7[0x0]
8000626e:	58 08       	cp.w	r8,0
80006270:	c0 81       	brne	80006280 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006272:	f0 1f 00 11 	mcall	800062b4 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006276:	6e 1c       	ld.w	r12,r7[0x4]
80006278:	f0 1f 00 17 	mcall	800062d4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000627c:	f0 1f 00 12 	mcall	800062c4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006280:	40 2b       	lddsp	r11,sp[0x8]
80006282:	04 9c       	mov	r12,r2
80006284:	f0 1f 00 15 	mcall	800062d8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006288:	0e 9c       	mov	r12,r7
8000628a:	f0 1f 00 15 	mcall	800062dc <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000628e:	f0 1f 00 15 	mcall	800062e0 <xQueueGenericReceive+0x140>
80006292:	c9 61       	brne	800061be <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006294:	d7 33       	scall
80006296:	c9 4b       	rjmp	800061be <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006298:	0e 9c       	mov	r12,r7
8000629a:	f0 1f 00 11 	mcall	800062dc <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000629e:	f0 1f 00 11 	mcall	800062e0 <xQueueGenericReceive+0x140>
800062a2:	c8 eb       	rjmp	800061be <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800062a4:	0e 9c       	mov	r12,r7
800062a6:	f0 1f 00 0e 	mcall	800062dc <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800062aa:	f0 1f 00 0e 	mcall	800062e0 <xQueueGenericReceive+0x140>
800062ae:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800062b0:	2f bd       	sub	sp,-20
800062b2:	d8 32       	popm	r0-r7,pc
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	5d ec       	*unknown*
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	60 80       	ld.w	r0,r0[0x20]
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	66 28       	ld.w	r8,r3[0x8]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	67 10       	ld.w	r0,r3[0x44]
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	5e f8       	retal	r8
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	66 04       	ld.w	r4,r3[0x0]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	65 78       	ld.w	r8,r2[0x5c]
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	68 a0       	ld.w	r0,r4[0x28]
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	66 8c       	ld.w	r12,r3[0x20]
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	6b 40       	ld.w	r0,r5[0x50]
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	61 00       	ld.w	r0,r0[0x40]
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	69 34       	ld.w	r4,r4[0x4c]

800062e4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800062e4:	eb cd 40 80 	pushm	r7,lr
800062e8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800062ea:	79 08       	ld.w	r8,r12[0x40]
800062ec:	58 08       	cp.w	r8,0
800062ee:	c0 a1       	brne	80006302 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800062f0:	78 08       	ld.w	r8,r12[0x0]
800062f2:	58 08       	cp.w	r8,0
800062f4:	c2 b1       	brne	8000634a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800062f6:	78 1c       	ld.w	r12,r12[0x4]
800062f8:	f0 1f 00 17 	mcall	80006354 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800062fc:	30 08       	mov	r8,0
800062fe:	8f 18       	st.w	r7[0x4],r8
80006300:	c2 58       	rjmp	8000634a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006302:	58 0a       	cp.w	r10,0
80006304:	c1 01       	brne	80006324 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006306:	10 9a       	mov	r10,r8
80006308:	78 2c       	ld.w	r12,r12[0x8]
8000630a:	f0 1f 00 14 	mcall	80006358 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000630e:	6e 29       	ld.w	r9,r7[0x8]
80006310:	6f 08       	ld.w	r8,r7[0x40]
80006312:	f2 08 00 08 	add	r8,r9,r8
80006316:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006318:	6e 19       	ld.w	r9,r7[0x4]
8000631a:	12 38       	cp.w	r8,r9
8000631c:	c1 73       	brcs	8000634a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000631e:	6e 08       	ld.w	r8,r7[0x0]
80006320:	8f 28       	st.w	r7[0x8],r8
80006322:	c1 48       	rjmp	8000634a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006324:	10 9a       	mov	r10,r8
80006326:	78 3c       	ld.w	r12,r12[0xc]
80006328:	f0 1f 00 0c 	mcall	80006358 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000632c:	6f 08       	ld.w	r8,r7[0x40]
8000632e:	6e 39       	ld.w	r9,r7[0xc]
80006330:	f2 08 01 08 	sub	r8,r9,r8
80006334:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006336:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006338:	12 38       	cp.w	r8,r9
8000633a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000633e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006342:	f3 d8 e3 19 	subcs	r9,r9,r8
80006346:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000634a:	6e e8       	ld.w	r8,r7[0x38]
8000634c:	2f f8       	sub	r8,-1
8000634e:	8f e8       	st.w	r7[0x38],r8
}
80006350:	e3 cd 80 80 	ldm	sp++,r7,pc
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	66 34       	ld.w	r4,r3[0xc]
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	78 68       	ld.w	r8,r12[0x18]

8000635c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000635c:	eb cd 40 c0 	pushm	r6-r7,lr
80006360:	18 97       	mov	r7,r12
80006362:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006364:	78 ec       	ld.w	r12,r12[0x38]
80006366:	6e f8       	ld.w	r8,r7[0x3c]
80006368:	10 3c       	cp.w	r12,r8
8000636a:	c0 33       	brcs	80006370 <xQueueGenericSendFromISR+0x14>
8000636c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006370:	12 9a       	mov	r10,r9
80006372:	0e 9c       	mov	r12,r7
80006374:	f0 1f 00 0c 	mcall	800063a4 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006378:	6f 28       	ld.w	r8,r7[0x48]
8000637a:	5b f8       	cp.w	r8,-1
8000637c:	c0 d1       	brne	80006396 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000637e:	6e 98       	ld.w	r8,r7[0x24]
80006380:	58 08       	cp.w	r8,0
80006382:	c0 f0       	breq	800063a0 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006384:	ee cc ff dc 	sub	r12,r7,-36
80006388:	f0 1f 00 08 	mcall	800063a8 <xQueueGenericSendFromISR+0x4c>
8000638c:	c0 a0       	breq	800063a0 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000638e:	30 1c       	mov	r12,1
80006390:	8d 0c       	st.w	r6[0x0],r12
80006392:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006396:	2f f8       	sub	r8,-1
80006398:	ef 48 00 48 	st.w	r7[72],r8
8000639c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800063a0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800063a4:	80 00       	ld.sh	r0,r0[0x0]
800063a6:	62 e4       	ld.w	r4,r1[0x38]
800063a8:	80 00       	ld.sh	r0,r0[0x0]
800063aa:	67 10       	ld.w	r0,r3[0x44]

800063ac <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800063ac:	d4 31       	pushm	r0-r7,lr
800063ae:	20 5d       	sub	sp,20
800063b0:	18 97       	mov	r7,r12
800063b2:	50 0b       	stdsp	sp[0x0],r11
800063b4:	50 2a       	stdsp	sp[0x8],r10
800063b6:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800063b8:	f8 c0 ff f0 	sub	r0,r12,-16
800063bc:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063be:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800063c2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063c4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800063c8:	f0 1f 00 2f 	mcall	80006484 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800063cc:	6e e9       	ld.w	r9,r7[0x38]
800063ce:	6e f8       	ld.w	r8,r7[0x3c]
800063d0:	10 39       	cp.w	r9,r8
800063d2:	c1 42       	brcc	800063fa <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063d4:	40 1a       	lddsp	r10,sp[0x4]
800063d6:	40 0b       	lddsp	r11,sp[0x0]
800063d8:	0e 9c       	mov	r12,r7
800063da:	f0 1f 00 2c 	mcall	80006488 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063de:	6e 98       	ld.w	r8,r7[0x24]
800063e0:	58 08       	cp.w	r8,0
800063e2:	c0 80       	breq	800063f2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800063e4:	ee cc ff dc 	sub	r12,r7,-36
800063e8:	f0 1f 00 29 	mcall	8000648c <xQueueGenericSend+0xe0>
800063ec:	58 1c       	cp.w	r12,1
800063ee:	c0 21       	brne	800063f2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800063f0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800063f2:	f0 1f 00 28 	mcall	80006490 <xQueueGenericSend+0xe4>
800063f6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800063f8:	c4 38       	rjmp	8000647e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800063fa:	40 28       	lddsp	r8,sp[0x8]
800063fc:	58 08       	cp.w	r8,0
800063fe:	c0 51       	brne	80006408 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006400:	f0 1f 00 24 	mcall	80006490 <xQueueGenericSend+0xe4>
80006404:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006406:	c3 c8       	rjmp	8000647e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006408:	58 04       	cp.w	r4,0
8000640a:	c0 51       	brne	80006414 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000640c:	06 9c       	mov	r12,r3
8000640e:	f0 1f 00 22 	mcall	80006494 <xQueueGenericSend+0xe8>
80006412:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006414:	f0 1f 00 1f 	mcall	80006490 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006418:	f0 1f 00 20 	mcall	80006498 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000641c:	f0 1f 00 1a 	mcall	80006484 <xQueueGenericSend+0xd8>
80006420:	6f 18       	ld.w	r8,r7[0x44]
80006422:	5b f8       	cp.w	r8,-1
80006424:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006428:	6f 28       	ld.w	r8,r7[0x48]
8000642a:	5b f8       	cp.w	r8,-1
8000642c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006430:	f0 1f 00 18 	mcall	80006490 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006434:	04 9b       	mov	r11,r2
80006436:	06 9c       	mov	r12,r3
80006438:	f0 1f 00 19 	mcall	8000649c <xQueueGenericSend+0xf0>
8000643c:	c1 b1       	brne	80006472 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000643e:	f0 1f 00 12 	mcall	80006484 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006442:	6e e5       	ld.w	r5,r7[0x38]
80006444:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006446:	f0 1f 00 13 	mcall	80006490 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000644a:	0c 35       	cp.w	r5,r6
8000644c:	c0 d1       	brne	80006466 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000644e:	40 2b       	lddsp	r11,sp[0x8]
80006450:	00 9c       	mov	r12,r0
80006452:	f0 1f 00 14 	mcall	800064a0 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006456:	0e 9c       	mov	r12,r7
80006458:	f0 1f 00 13 	mcall	800064a4 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000645c:	f0 1f 00 13 	mcall	800064a8 <xQueueGenericSend+0xfc>
80006460:	cb 41       	brne	800063c8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006462:	d7 33       	scall
80006464:	cb 2b       	rjmp	800063c8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006466:	0e 9c       	mov	r12,r7
80006468:	f0 1f 00 0f 	mcall	800064a4 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000646c:	f0 1f 00 0f 	mcall	800064a8 <xQueueGenericSend+0xfc>
80006470:	ca cb       	rjmp	800063c8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006472:	0e 9c       	mov	r12,r7
80006474:	f0 1f 00 0c 	mcall	800064a4 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006478:	f0 1f 00 0c 	mcall	800064a8 <xQueueGenericSend+0xfc>
8000647c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000647e:	2f bd       	sub	sp,-20
80006480:	d8 32       	popm	r0-r7,pc
80006482:	00 00       	add	r0,r0
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	5d ec       	*unknown*
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	62 e4       	ld.w	r4,r1[0x38]
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	67 10       	ld.w	r0,r3[0x44]
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	5e f8       	retal	r8
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	66 04       	ld.w	r4,r3[0x0]
80006498:	80 00       	ld.sh	r0,r0[0x0]
8000649a:	65 78       	ld.w	r8,r2[0x5c]
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	68 a0       	ld.w	r0,r4[0x28]
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	6b 40       	ld.w	r0,r5[0x50]
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	61 00       	ld.w	r0,r0[0x40]
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	69 34       	ld.w	r4,r4[0x4c]

800064ac <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800064ac:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800064b0:	34 cc       	mov	r12,76
800064b2:	f0 1f 00 12 	mcall	800064f8 <xQueueCreateMutex+0x4c>
800064b6:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800064b8:	c1 d0       	breq	800064f2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800064ba:	30 06       	mov	r6,0
800064bc:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800064be:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800064c0:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800064c2:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800064c4:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800064c6:	30 18       	mov	r8,1
800064c8:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800064ca:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800064ce:	3f f8       	mov	r8,-1
800064d0:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800064d4:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800064d8:	2f 0c       	sub	r12,-16
800064da:	f0 1f 00 09 	mcall	800064fc <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800064de:	ee cc ff dc 	sub	r12,r7,-36
800064e2:	f0 1f 00 07 	mcall	800064fc <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800064e6:	0c 99       	mov	r9,r6
800064e8:	0c 9a       	mov	r10,r6
800064ea:	0c 9b       	mov	r11,r6
800064ec:	0e 9c       	mov	r12,r7
800064ee:	f0 1f 00 05 	mcall	80006500 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800064f2:	0e 9c       	mov	r12,r7
800064f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	60 58       	ld.w	r8,r0[0x14]
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	5c c8       	swap.bh	r8
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	63 ac       	ld.w	r12,r1[0x68]

80006504 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006504:	d4 21       	pushm	r4-r7,lr
80006506:	18 97       	mov	r7,r12
80006508:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000650a:	58 0c       	cp.w	r12,0
8000650c:	c2 f0       	breq	8000656a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000650e:	34 cc       	mov	r12,76
80006510:	f0 1f 00 17 	mcall	8000656c <xQueueCreate+0x68>
80006514:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006516:	c2 a0       	breq	8000656a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006518:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000651c:	e8 cc ff ff 	sub	r12,r4,-1
80006520:	f0 1f 00 13 	mcall	8000656c <xQueueCreate+0x68>
80006524:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006526:	c1 e0       	breq	80006562 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006528:	f8 04 00 04 	add	r4,r12,r4
8000652c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000652e:	30 08       	mov	r8,0
80006530:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006532:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006534:	ee c8 00 01 	sub	r8,r7,1
80006538:	ad 38       	mul	r8,r6
8000653a:	10 0c       	add	r12,r8
8000653c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000653e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006540:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006544:	3f f8       	mov	r8,-1
80006546:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000654a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000654e:	ea cc ff f0 	sub	r12,r5,-16
80006552:	f0 1f 00 08 	mcall	80006570 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006556:	ea cc ff dc 	sub	r12,r5,-36
8000655a:	f0 1f 00 06 	mcall	80006570 <xQueueCreate+0x6c>
8000655e:	0a 9c       	mov	r12,r5
80006560:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006562:	0a 9c       	mov	r12,r5
80006564:	f0 1f 00 04 	mcall	80006574 <xQueueCreate+0x70>
80006568:	d8 2a       	popm	r4-r7,pc,r12=0
8000656a:	d8 2a       	popm	r4-r7,pc,r12=0
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	60 58       	ld.w	r8,r0[0x14]
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	5c c8       	swap.bh	r8
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	60 30       	ld.w	r0,r0[0xc]

80006578 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006578:	48 38       	lddpc	r8,80006584 <vTaskSuspendAll+0xc>
8000657a:	70 09       	ld.w	r9,r8[0x0]
8000657c:	2f f9       	sub	r9,-1
8000657e:	91 09       	st.w	r8[0x0],r9
}
80006580:	5e fc       	retal	r12
80006582:	00 00       	add	r0,r0
80006584:	00 00       	add	r0,r0
80006586:	0d 20       	ld.uh	r0,r6++

80006588 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006588:	49 a8       	lddpc	r8,800065f0 <vTaskSwitchContext+0x68>
8000658a:	70 08       	ld.w	r8,r8[0x0]
8000658c:	58 08       	cp.w	r8,0
8000658e:	c0 b1       	brne	800065a4 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006590:	49 98       	lddpc	r8,800065f4 <vTaskSwitchContext+0x6c>
80006592:	70 08       	ld.w	r8,r8[0x0]
80006594:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006598:	49 89       	lddpc	r9,800065f8 <vTaskSwitchContext+0x70>
8000659a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000659e:	58 08       	cp.w	r8,0
800065a0:	c0 60       	breq	800065ac <vTaskSwitchContext+0x24>
800065a2:	c1 18       	rjmp	800065c4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800065a4:	30 19       	mov	r9,1
800065a6:	49 68       	lddpc	r8,800065fc <vTaskSwitchContext+0x74>
800065a8:	91 09       	st.w	r8[0x0],r9
800065aa:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800065ac:	49 28       	lddpc	r8,800065f4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065ae:	49 3a       	lddpc	r10,800065f8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800065b0:	70 09       	ld.w	r9,r8[0x0]
800065b2:	20 19       	sub	r9,1
800065b4:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065b6:	70 09       	ld.w	r9,r8[0x0]
800065b8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800065bc:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800065c0:	58 09       	cp.w	r9,0
800065c2:	cf 70       	breq	800065b0 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800065c4:	48 c8       	lddpc	r8,800065f4 <vTaskSwitchContext+0x6c>
800065c6:	70 08       	ld.w	r8,r8[0x0]
800065c8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800065cc:	48 b9       	lddpc	r9,800065f8 <vTaskSwitchContext+0x70>
800065ce:	f2 08 00 28 	add	r8,r9,r8<<0x2
800065d2:	70 19       	ld.w	r9,r8[0x4]
800065d4:	72 19       	ld.w	r9,r9[0x4]
800065d6:	91 19       	st.w	r8[0x4],r9
800065d8:	f0 ca ff f8 	sub	r10,r8,-8
800065dc:	14 39       	cp.w	r9,r10
800065de:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800065e2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800065e6:	70 18       	ld.w	r8,r8[0x4]
800065e8:	70 39       	ld.w	r9,r8[0xc]
800065ea:	48 68       	lddpc	r8,80006600 <vTaskSwitchContext+0x78>
800065ec:	91 09       	st.w	r8[0x0],r9
800065ee:	5e fc       	retal	r12
800065f0:	00 00       	add	r0,r0
800065f2:	0d 20       	ld.uh	r0,r6++
800065f4:	00 00       	add	r0,r0
800065f6:	0d 58       	ld.sh	r8,--r6
800065f8:	00 00       	add	r0,r0
800065fa:	0c 3c       	cp.w	r12,r6
800065fc:	00 00       	add	r0,r0
800065fe:	0d 40       	ld.w	r0,--r6
80006600:	00 00       	add	r0,r0
80006602:	0c f0       	st.b	--r6,r0

80006604 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006604:	48 48       	lddpc	r8,80006614 <vTaskSetTimeOutState+0x10>
80006606:	70 08       	ld.w	r8,r8[0x0]
80006608:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000660a:	48 48       	lddpc	r8,80006618 <vTaskSetTimeOutState+0x14>
8000660c:	70 08       	ld.w	r8,r8[0x0]
8000660e:	99 18       	st.w	r12[0x4],r8
}
80006610:	5e fc       	retal	r12
80006612:	00 00       	add	r0,r0
80006614:	00 00       	add	r0,r0
80006616:	0c 34       	cp.w	r4,r6
80006618:	00 00       	add	r0,r0
8000661a:	0d 1c       	ld.sh	r12,r6++

8000661c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000661c:	30 19       	mov	r9,1
8000661e:	48 28       	lddpc	r8,80006624 <vTaskMissedYield+0x8>
80006620:	91 09       	st.w	r8[0x0],r9
}
80006622:	5e fc       	retal	r12
80006624:	00 00       	add	r0,r0
80006626:	0d 40       	ld.w	r0,--r6

80006628 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006628:	48 28       	lddpc	r8,80006630 <xTaskGetCurrentTaskHandle+0x8>
8000662a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000662c:	5e fc       	retal	r12
8000662e:	00 00       	add	r0,r0
80006630:	00 00       	add	r0,r0
80006632:	0c f0       	st.b	--r6,r0

80006634 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006634:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006638:	58 0c       	cp.w	r12,0
8000663a:	c1 f0       	breq	80006678 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000663c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000663e:	78 b9       	ld.w	r9,r12[0x2c]
80006640:	79 18       	ld.w	r8,r12[0x44]
80006642:	10 39       	cp.w	r9,r8
80006644:	c1 a0       	breq	80006678 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006646:	f8 c6 ff fc 	sub	r6,r12,-4
8000664a:	0c 9c       	mov	r12,r6
8000664c:	f0 1f 00 0c 	mcall	8000667c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006650:	6f 1c       	ld.w	r12,r7[0x44]
80006652:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006654:	f8 08 11 08 	rsub	r8,r12,8
80006658:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000665a:	48 a8       	lddpc	r8,80006680 <vTaskPriorityDisinherit+0x4c>
8000665c:	70 08       	ld.w	r8,r8[0x0]
8000665e:	10 3c       	cp.w	r12,r8
80006660:	e0 88 00 04 	brls	80006668 <vTaskPriorityDisinherit+0x34>
80006664:	48 78       	lddpc	r8,80006680 <vTaskPriorityDisinherit+0x4c>
80006666:	91 0c       	st.w	r8[0x0],r12
80006668:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000666c:	0c 9b       	mov	r11,r6
8000666e:	48 68       	lddpc	r8,80006684 <vTaskPriorityDisinherit+0x50>
80006670:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006674:	f0 1f 00 05 	mcall	80006688 <vTaskPriorityDisinherit+0x54>
80006678:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000667c:	80 00       	ld.sh	r0,r0[0x0]
8000667e:	5d 32       	musfr	r2
80006680:	00 00       	add	r0,r0
80006682:	0d 58       	ld.sh	r8,--r6
80006684:	00 00       	add	r0,r0
80006686:	0c 3c       	cp.w	r12,r6
80006688:	80 00       	ld.sh	r0,r0[0x0]
8000668a:	5c e2       	tnbz	r2

8000668c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000668c:	eb cd 40 c0 	pushm	r6-r7,lr
80006690:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006692:	49 b8       	lddpc	r8,800066fc <vTaskPriorityInherit+0x70>
80006694:	70 08       	ld.w	r8,r8[0x0]
80006696:	78 b9       	ld.w	r9,r12[0x2c]
80006698:	70 b8       	ld.w	r8,r8[0x2c]
8000669a:	10 39       	cp.w	r9,r8
8000669c:	c2 d2       	brcc	800066f6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000669e:	49 88       	lddpc	r8,800066fc <vTaskPriorityInherit+0x70>
800066a0:	70 08       	ld.w	r8,r8[0x0]
800066a2:	70 b8       	ld.w	r8,r8[0x2c]
800066a4:	f0 08 11 08 	rsub	r8,r8,8
800066a8:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800066aa:	f2 09 00 28 	add	r8,r9,r9<<0x2
800066ae:	49 59       	lddpc	r9,80006700 <vTaskPriorityInherit+0x74>
800066b0:	f2 08 00 28 	add	r8,r9,r8<<0x2
800066b4:	78 59       	ld.w	r9,r12[0x14]
800066b6:	10 39       	cp.w	r9,r8
800066b8:	c1 b1       	brne	800066ee <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800066ba:	f8 c6 ff fc 	sub	r6,r12,-4
800066be:	0c 9c       	mov	r12,r6
800066c0:	f0 1f 00 11 	mcall	80006704 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066c4:	48 e8       	lddpc	r8,800066fc <vTaskPriorityInherit+0x70>
800066c6:	70 08       	ld.w	r8,r8[0x0]
800066c8:	70 bc       	ld.w	r12,r8[0x2c]
800066ca:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800066cc:	48 f8       	lddpc	r8,80006708 <vTaskPriorityInherit+0x7c>
800066ce:	70 08       	ld.w	r8,r8[0x0]
800066d0:	10 3c       	cp.w	r12,r8
800066d2:	e0 88 00 04 	brls	800066da <vTaskPriorityInherit+0x4e>
800066d6:	48 d8       	lddpc	r8,80006708 <vTaskPriorityInherit+0x7c>
800066d8:	91 0c       	st.w	r8[0x0],r12
800066da:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066de:	0c 9b       	mov	r11,r6
800066e0:	48 88       	lddpc	r8,80006700 <vTaskPriorityInherit+0x74>
800066e2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066e6:	f0 1f 00 0a 	mcall	8000670c <vTaskPriorityInherit+0x80>
800066ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066ee:	48 48       	lddpc	r8,800066fc <vTaskPriorityInherit+0x70>
800066f0:	70 08       	ld.w	r8,r8[0x0]
800066f2:	70 b8       	ld.w	r8,r8[0x2c]
800066f4:	99 b8       	st.w	r12[0x2c],r8
800066f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066fa:	00 00       	add	r0,r0
800066fc:	00 00       	add	r0,r0
800066fe:	0c f0       	st.b	--r6,r0
80006700:	00 00       	add	r0,r0
80006702:	0c 3c       	cp.w	r12,r6
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	5d 32       	musfr	r2
80006708:	00 00       	add	r0,r0
8000670a:	0d 58       	ld.sh	r8,--r6
8000670c:	80 00       	ld.sh	r0,r0[0x0]
8000670e:	5c e2       	tnbz	r2

80006710 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006710:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006714:	78 38       	ld.w	r8,r12[0xc]
80006716:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006718:	ee c6 ff e8 	sub	r6,r7,-24
8000671c:	0c 9c       	mov	r12,r6
8000671e:	f0 1f 00 15 	mcall	80006770 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006722:	49 58       	lddpc	r8,80006774 <xTaskRemoveFromEventList+0x64>
80006724:	70 08       	ld.w	r8,r8[0x0]
80006726:	58 08       	cp.w	r8,0
80006728:	c1 71       	brne	80006756 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000672a:	ee c6 ff fc 	sub	r6,r7,-4
8000672e:	0c 9c       	mov	r12,r6
80006730:	f0 1f 00 10 	mcall	80006770 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006734:	6e bc       	ld.w	r12,r7[0x2c]
80006736:	49 18       	lddpc	r8,80006778 <xTaskRemoveFromEventList+0x68>
80006738:	70 08       	ld.w	r8,r8[0x0]
8000673a:	10 3c       	cp.w	r12,r8
8000673c:	e0 88 00 04 	brls	80006744 <xTaskRemoveFromEventList+0x34>
80006740:	48 e8       	lddpc	r8,80006778 <xTaskRemoveFromEventList+0x68>
80006742:	91 0c       	st.w	r8[0x0],r12
80006744:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006748:	0c 9b       	mov	r11,r6
8000674a:	48 d8       	lddpc	r8,8000677c <xTaskRemoveFromEventList+0x6c>
8000674c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006750:	f0 1f 00 0c 	mcall	80006780 <xTaskRemoveFromEventList+0x70>
80006754:	c0 58       	rjmp	8000675e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006756:	0c 9b       	mov	r11,r6
80006758:	48 bc       	lddpc	r12,80006784 <xTaskRemoveFromEventList+0x74>
8000675a:	f0 1f 00 0a 	mcall	80006780 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000675e:	48 b8       	lddpc	r8,80006788 <xTaskRemoveFromEventList+0x78>
80006760:	70 08       	ld.w	r8,r8[0x0]
80006762:	6e b9       	ld.w	r9,r7[0x2c]
80006764:	70 b8       	ld.w	r8,r8[0x2c]
80006766:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006768:	5f 2c       	srhs	r12
8000676a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000676e:	00 00       	add	r0,r0
80006770:	80 00       	ld.sh	r0,r0[0x0]
80006772:	5d 32       	musfr	r2
80006774:	00 00       	add	r0,r0
80006776:	0d 20       	ld.uh	r0,r6++
80006778:	00 00       	add	r0,r0
8000677a:	0d 58       	ld.sh	r8,--r6
8000677c:	00 00       	add	r0,r0
8000677e:	0c 3c       	cp.w	r12,r6
80006780:	80 00       	ld.sh	r0,r0[0x0]
80006782:	5c e2       	tnbz	r2
80006784:	00 00       	add	r0,r0
80006786:	0c f4       	st.b	--r6,r4
80006788:	00 00       	add	r0,r0
8000678a:	0c f0       	st.b	--r6,r0

8000678c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000678c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006790:	4b 98       	lddpc	r8,80006874 <vTaskIncrementTick+0xe8>
80006792:	70 08       	ld.w	r8,r8[0x0]
80006794:	58 08       	cp.w	r8,0
80006796:	c6 91       	brne	80006868 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006798:	4b 88       	lddpc	r8,80006878 <vTaskIncrementTick+0xec>
8000679a:	70 09       	ld.w	r9,r8[0x0]
8000679c:	2f f9       	sub	r9,-1
8000679e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800067a0:	70 08       	ld.w	r8,r8[0x0]
800067a2:	58 08       	cp.w	r8,0
800067a4:	c1 a1       	brne	800067d8 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800067a6:	4b 68       	lddpc	r8,8000687c <vTaskIncrementTick+0xf0>
800067a8:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800067aa:	4b 69       	lddpc	r9,80006880 <vTaskIncrementTick+0xf4>
800067ac:	72 0b       	ld.w	r11,r9[0x0]
800067ae:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800067b0:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800067b2:	4b 59       	lddpc	r9,80006884 <vTaskIncrementTick+0xf8>
800067b4:	72 0a       	ld.w	r10,r9[0x0]
800067b6:	2f fa       	sub	r10,-1
800067b8:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800067ba:	70 08       	ld.w	r8,r8[0x0]
800067bc:	70 08       	ld.w	r8,r8[0x0]
800067be:	58 08       	cp.w	r8,0
800067c0:	c0 51       	brne	800067ca <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800067c2:	3f f9       	mov	r9,-1
800067c4:	4b 18       	lddpc	r8,80006888 <vTaskIncrementTick+0xfc>
800067c6:	91 09       	st.w	r8[0x0],r9
800067c8:	c0 88       	rjmp	800067d8 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800067ca:	4a d8       	lddpc	r8,8000687c <vTaskIncrementTick+0xf0>
800067cc:	70 08       	ld.w	r8,r8[0x0]
800067ce:	70 38       	ld.w	r8,r8[0xc]
800067d0:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800067d2:	70 19       	ld.w	r9,r8[0x4]
800067d4:	4a d8       	lddpc	r8,80006888 <vTaskIncrementTick+0xfc>
800067d6:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800067d8:	4a 88       	lddpc	r8,80006878 <vTaskIncrementTick+0xec>
800067da:	70 09       	ld.w	r9,r8[0x0]
800067dc:	4a b8       	lddpc	r8,80006888 <vTaskIncrementTick+0xfc>
800067de:	70 08       	ld.w	r8,r8[0x0]
800067e0:	10 39       	cp.w	r9,r8
800067e2:	c4 73       	brcs	80006870 <vTaskIncrementTick+0xe4>
800067e4:	4a 68       	lddpc	r8,8000687c <vTaskIncrementTick+0xf0>
800067e6:	70 08       	ld.w	r8,r8[0x0]
800067e8:	70 08       	ld.w	r8,r8[0x0]
800067ea:	58 08       	cp.w	r8,0
800067ec:	c0 c0       	breq	80006804 <vTaskIncrementTick+0x78>
800067ee:	4a 48       	lddpc	r8,8000687c <vTaskIncrementTick+0xf0>
800067f0:	70 08       	ld.w	r8,r8[0x0]
800067f2:	70 38       	ld.w	r8,r8[0xc]
800067f4:	70 37       	ld.w	r7,r8[0xc]
800067f6:	6e 18       	ld.w	r8,r7[0x4]
800067f8:	4a 09       	lddpc	r9,80006878 <vTaskIncrementTick+0xec>
800067fa:	72 09       	ld.w	r9,r9[0x0]
800067fc:	12 38       	cp.w	r8,r9
800067fe:	e0 88 00 14 	brls	80006826 <vTaskIncrementTick+0x9a>
80006802:	c0 e8       	rjmp	8000681e <vTaskIncrementTick+0x92>
80006804:	3f f9       	mov	r9,-1
80006806:	4a 18       	lddpc	r8,80006888 <vTaskIncrementTick+0xfc>
80006808:	91 09       	st.w	r8[0x0],r9
8000680a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000680e:	6a 08       	ld.w	r8,r5[0x0]
80006810:	70 38       	ld.w	r8,r8[0xc]
80006812:	70 37       	ld.w	r7,r8[0xc]
80006814:	6e 18       	ld.w	r8,r7[0x4]
80006816:	64 09       	ld.w	r9,r2[0x0]
80006818:	12 38       	cp.w	r8,r9
8000681a:	e0 88 00 0a 	brls	8000682e <vTaskIncrementTick+0xa2>
8000681e:	49 b9       	lddpc	r9,80006888 <vTaskIncrementTick+0xfc>
80006820:	93 08       	st.w	r9[0x0],r8
80006822:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006826:	49 a4       	lddpc	r4,8000688c <vTaskIncrementTick+0x100>
80006828:	49 a3       	lddpc	r3,80006890 <vTaskIncrementTick+0x104>
8000682a:	49 55       	lddpc	r5,8000687c <vTaskIncrementTick+0xf0>
8000682c:	49 32       	lddpc	r2,80006878 <vTaskIncrementTick+0xec>
8000682e:	ee c6 ff fc 	sub	r6,r7,-4
80006832:	0c 9c       	mov	r12,r6
80006834:	f0 1f 00 18 	mcall	80006894 <vTaskIncrementTick+0x108>
80006838:	6e a8       	ld.w	r8,r7[0x28]
8000683a:	58 08       	cp.w	r8,0
8000683c:	c0 50       	breq	80006846 <vTaskIncrementTick+0xba>
8000683e:	ee cc ff e8 	sub	r12,r7,-24
80006842:	f0 1f 00 15 	mcall	80006894 <vTaskIncrementTick+0x108>
80006846:	6e bc       	ld.w	r12,r7[0x2c]
80006848:	68 08       	ld.w	r8,r4[0x0]
8000684a:	10 3c       	cp.w	r12,r8
8000684c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006850:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006854:	0c 9b       	mov	r11,r6
80006856:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000685a:	f0 1f 00 10 	mcall	80006898 <vTaskIncrementTick+0x10c>
8000685e:	6a 08       	ld.w	r8,r5[0x0]
80006860:	70 08       	ld.w	r8,r8[0x0]
80006862:	58 08       	cp.w	r8,0
80006864:	cd 51       	brne	8000680e <vTaskIncrementTick+0x82>
80006866:	cc fb       	rjmp	80006804 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006868:	48 d8       	lddpc	r8,8000689c <vTaskIncrementTick+0x110>
8000686a:	70 09       	ld.w	r9,r8[0x0]
8000686c:	2f f9       	sub	r9,-1
8000686e:	91 09       	st.w	r8[0x0],r9
80006870:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006874:	00 00       	add	r0,r0
80006876:	0d 20       	ld.uh	r0,r6++
80006878:	00 00       	add	r0,r0
8000687a:	0d 1c       	ld.sh	r12,r6++
8000687c:	00 00       	add	r0,r0
8000687e:	0c 28       	rsub	r8,r6
80006880:	00 00       	add	r0,r0
80006882:	0c 38       	cp.w	r8,r6
80006884:	00 00       	add	r0,r0
80006886:	0c 34       	cp.w	r4,r6
80006888:	00 00       	add	r0,r0
8000688a:	05 3c       	ld.ub	r12,r2++
8000688c:	00 00       	add	r0,r0
8000688e:	0d 58       	ld.sh	r8,--r6
80006890:	00 00       	add	r0,r0
80006892:	0c 3c       	cp.w	r12,r6
80006894:	80 00       	ld.sh	r0,r0[0x0]
80006896:	5d 32       	musfr	r2
80006898:	80 00       	ld.sh	r0,r0[0x0]
8000689a:	5c e2       	tnbz	r2
8000689c:	00 00       	add	r0,r0
8000689e:	0c 20       	rsub	r0,r6

800068a0 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800068a0:	eb cd 40 c0 	pushm	r6-r7,lr
800068a4:	18 97       	mov	r7,r12
800068a6:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800068a8:	f0 1f 00 15 	mcall	800068fc <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800068ac:	6c 08       	ld.w	r8,r6[0x0]
800068ae:	5b f8       	cp.w	r8,-1
800068b0:	c0 31       	brne	800068b6 <xTaskCheckForTimeOut+0x16>
800068b2:	30 07       	mov	r7,0
800068b4:	c1 f8       	rjmp	800068f2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800068b6:	49 39       	lddpc	r9,80006900 <xTaskCheckForTimeOut+0x60>
800068b8:	72 09       	ld.w	r9,r9[0x0]
800068ba:	6e 0a       	ld.w	r10,r7[0x0]
800068bc:	12 3a       	cp.w	r10,r9
800068be:	c0 70       	breq	800068cc <xTaskCheckForTimeOut+0x2c>
800068c0:	49 19       	lddpc	r9,80006904 <xTaskCheckForTimeOut+0x64>
800068c2:	72 09       	ld.w	r9,r9[0x0]
800068c4:	6e 1a       	ld.w	r10,r7[0x4]
800068c6:	12 3a       	cp.w	r10,r9
800068c8:	e0 88 00 14 	brls	800068f0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800068cc:	48 e9       	lddpc	r9,80006904 <xTaskCheckForTimeOut+0x64>
800068ce:	72 0a       	ld.w	r10,r9[0x0]
800068d0:	6e 19       	ld.w	r9,r7[0x4]
800068d2:	12 1a       	sub	r10,r9
800068d4:	14 38       	cp.w	r8,r10
800068d6:	e0 88 00 0d 	brls	800068f0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800068da:	48 ba       	lddpc	r10,80006904 <xTaskCheckForTimeOut+0x64>
800068dc:	74 0a       	ld.w	r10,r10[0x0]
800068de:	14 19       	sub	r9,r10
800068e0:	f2 08 00 08 	add	r8,r9,r8
800068e4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800068e6:	0e 9c       	mov	r12,r7
800068e8:	f0 1f 00 08 	mcall	80006908 <xTaskCheckForTimeOut+0x68>
800068ec:	30 07       	mov	r7,0
800068ee:	c0 28       	rjmp	800068f2 <xTaskCheckForTimeOut+0x52>
800068f0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800068f2:	f0 1f 00 07 	mcall	8000690c <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800068f6:	0e 9c       	mov	r12,r7
800068f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068fc:	80 00       	ld.sh	r0,r0[0x0]
800068fe:	5d ec       	*unknown*
80006900:	00 00       	add	r0,r0
80006902:	0c 34       	cp.w	r4,r6
80006904:	00 00       	add	r0,r0
80006906:	0d 1c       	ld.sh	r12,r6++
80006908:	80 00       	ld.sh	r0,r0[0x0]
8000690a:	66 04       	ld.w	r4,r3[0x0]
8000690c:	80 00       	ld.sh	r0,r0[0x0]
8000690e:	5e f8       	retal	r8

80006910 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006910:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006914:	f0 1f 00 05 	mcall	80006928 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006918:	48 58       	lddpc	r8,8000692c <xTaskGetTickCount+0x1c>
8000691a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000691c:	f0 1f 00 05 	mcall	80006930 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006920:	0e 9c       	mov	r12,r7
80006922:	e3 cd 80 80 	ldm	sp++,r7,pc
80006926:	00 00       	add	r0,r0
80006928:	80 00       	ld.sh	r0,r0[0x0]
8000692a:	5d ec       	*unknown*
8000692c:	00 00       	add	r0,r0
8000692e:	0d 1c       	ld.sh	r12,r6++
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	5e f8       	retal	r8

80006934 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006934:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006938:	f0 1f 00 2c 	mcall	800069e8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000693c:	4a c8       	lddpc	r8,800069ec <xTaskResumeAll+0xb8>
8000693e:	70 09       	ld.w	r9,r8[0x0]
80006940:	20 19       	sub	r9,1
80006942:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006944:	70 08       	ld.w	r8,r8[0x0]
80006946:	58 08       	cp.w	r8,0
80006948:	c4 91       	brne	800069da <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000694a:	4a a8       	lddpc	r8,800069f0 <xTaskResumeAll+0xbc>
8000694c:	70 08       	ld.w	r8,r8[0x0]
8000694e:	58 08       	cp.w	r8,0
80006950:	c4 50       	breq	800069da <xTaskResumeAll+0xa6>
80006952:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006954:	4a 85       	lddpc	r5,800069f4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006956:	4a 93       	lddpc	r3,800069f8 <xTaskResumeAll+0xc4>
80006958:	4a 92       	lddpc	r2,800069fc <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000695a:	4a a1       	lddpc	r1,80006a00 <xTaskResumeAll+0xcc>
8000695c:	c1 e8       	rjmp	80006998 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000695e:	6a 38       	ld.w	r8,r5[0xc]
80006960:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006962:	ee cc ff e8 	sub	r12,r7,-24
80006966:	f0 1f 00 28 	mcall	80006a04 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000696a:	ee c6 ff fc 	sub	r6,r7,-4
8000696e:	0c 9c       	mov	r12,r6
80006970:	f0 1f 00 25 	mcall	80006a04 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006974:	6e bc       	ld.w	r12,r7[0x2c]
80006976:	66 08       	ld.w	r8,r3[0x0]
80006978:	10 3c       	cp.w	r12,r8
8000697a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000697e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006982:	0c 9b       	mov	r11,r6
80006984:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006988:	f0 1f 00 20 	mcall	80006a08 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000698c:	62 08       	ld.w	r8,r1[0x0]
8000698e:	6e b9       	ld.w	r9,r7[0x2c]
80006990:	70 b8       	ld.w	r8,r8[0x2c]
80006992:	10 39       	cp.w	r9,r8
80006994:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006998:	6a 08       	ld.w	r8,r5[0x0]
8000699a:	58 08       	cp.w	r8,0
8000699c:	ce 11       	brne	8000695e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000699e:	49 c8       	lddpc	r8,80006a0c <xTaskResumeAll+0xd8>
800069a0:	70 08       	ld.w	r8,r8[0x0]
800069a2:	58 08       	cp.w	r8,0
800069a4:	c0 f0       	breq	800069c2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069a6:	49 a8       	lddpc	r8,80006a0c <xTaskResumeAll+0xd8>
800069a8:	70 08       	ld.w	r8,r8[0x0]
800069aa:	58 08       	cp.w	r8,0
800069ac:	c1 10       	breq	800069ce <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800069ae:	49 87       	lddpc	r7,80006a0c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800069b0:	f0 1f 00 18 	mcall	80006a10 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800069b4:	6e 08       	ld.w	r8,r7[0x0]
800069b6:	20 18       	sub	r8,1
800069b8:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800069ba:	6e 08       	ld.w	r8,r7[0x0]
800069bc:	58 08       	cp.w	r8,0
800069be:	cf 91       	brne	800069b0 <xTaskResumeAll+0x7c>
800069c0:	c0 78       	rjmp	800069ce <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800069c2:	58 14       	cp.w	r4,1
800069c4:	c0 50       	breq	800069ce <xTaskResumeAll+0x9a>
800069c6:	49 48       	lddpc	r8,80006a14 <xTaskResumeAll+0xe0>
800069c8:	70 08       	ld.w	r8,r8[0x0]
800069ca:	58 18       	cp.w	r8,1
800069cc:	c0 71       	brne	800069da <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800069ce:	30 09       	mov	r9,0
800069d0:	49 18       	lddpc	r8,80006a14 <xTaskResumeAll+0xe0>
800069d2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800069d4:	d7 33       	scall
800069d6:	30 17       	mov	r7,1
800069d8:	c0 28       	rjmp	800069dc <xTaskResumeAll+0xa8>
800069da:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800069dc:	f0 1f 00 0f 	mcall	80006a18 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800069e0:	0e 9c       	mov	r12,r7
800069e2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800069e6:	00 00       	add	r0,r0
800069e8:	80 00       	ld.sh	r0,r0[0x0]
800069ea:	5d ec       	*unknown*
800069ec:	00 00       	add	r0,r0
800069ee:	0d 20       	ld.uh	r0,r6++
800069f0:	00 00       	add	r0,r0
800069f2:	0d 3c       	ld.ub	r12,r6++
800069f4:	00 00       	add	r0,r0
800069f6:	0c f4       	st.b	--r6,r4
800069f8:	00 00       	add	r0,r0
800069fa:	0d 58       	ld.sh	r8,--r6
800069fc:	00 00       	add	r0,r0
800069fe:	0c 3c       	cp.w	r12,r6
80006a00:	00 00       	add	r0,r0
80006a02:	0c f0       	st.b	--r6,r0
80006a04:	80 00       	ld.sh	r0,r0[0x0]
80006a06:	5d 32       	musfr	r2
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	5c e2       	tnbz	r2
80006a0c:	00 00       	add	r0,r0
80006a0e:	0c 20       	rsub	r0,r6
80006a10:	80 00       	ld.sh	r0,r0[0x0]
80006a12:	67 8c       	ld.w	r12,r3[0x60]
80006a14:	00 00       	add	r0,r0
80006a16:	0d 40       	ld.w	r0,--r6
80006a18:	80 00       	ld.sh	r0,r0[0x0]
80006a1a:	5e f8       	retal	r8

80006a1c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006a1c:	eb cd 40 80 	pushm	r7,lr
80006a20:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a22:	49 08       	lddpc	r8,80006a60 <prvAddCurrentTaskToDelayedList+0x44>
80006a24:	70 08       	ld.w	r8,r8[0x0]
80006a26:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006a28:	48 f8       	lddpc	r8,80006a64 <prvAddCurrentTaskToDelayedList+0x48>
80006a2a:	70 08       	ld.w	r8,r8[0x0]
80006a2c:	10 3c       	cp.w	r12,r8
80006a2e:	c0 a2       	brcc	80006a42 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a30:	48 c8       	lddpc	r8,80006a60 <prvAddCurrentTaskToDelayedList+0x44>
80006a32:	70 0b       	ld.w	r11,r8[0x0]
80006a34:	48 d8       	lddpc	r8,80006a68 <prvAddCurrentTaskToDelayedList+0x4c>
80006a36:	70 0c       	ld.w	r12,r8[0x0]
80006a38:	2f cb       	sub	r11,-4
80006a3a:	f0 1f 00 0d 	mcall	80006a6c <prvAddCurrentTaskToDelayedList+0x50>
80006a3e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a42:	48 88       	lddpc	r8,80006a60 <prvAddCurrentTaskToDelayedList+0x44>
80006a44:	70 0b       	ld.w	r11,r8[0x0]
80006a46:	48 b8       	lddpc	r8,80006a70 <prvAddCurrentTaskToDelayedList+0x54>
80006a48:	70 0c       	ld.w	r12,r8[0x0]
80006a4a:	2f cb       	sub	r11,-4
80006a4c:	f0 1f 00 08 	mcall	80006a6c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006a50:	48 98       	lddpc	r8,80006a74 <prvAddCurrentTaskToDelayedList+0x58>
80006a52:	70 08       	ld.w	r8,r8[0x0]
80006a54:	10 37       	cp.w	r7,r8
80006a56:	c0 32       	brcc	80006a5c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006a58:	48 78       	lddpc	r8,80006a74 <prvAddCurrentTaskToDelayedList+0x58>
80006a5a:	91 07       	st.w	r8[0x0],r7
80006a5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a60:	00 00       	add	r0,r0
80006a62:	0c f0       	st.b	--r6,r0
80006a64:	00 00       	add	r0,r0
80006a66:	0d 1c       	ld.sh	r12,r6++
80006a68:	00 00       	add	r0,r0
80006a6a:	0c 38       	cp.w	r8,r6
80006a6c:	80 00       	ld.sh	r0,r0[0x0]
80006a6e:	5c fe       	rol	lr
80006a70:	00 00       	add	r0,r0
80006a72:	0c 28       	rsub	r8,r6
80006a74:	00 00       	add	r0,r0
80006a76:	05 3c       	ld.ub	r12,r2++

80006a78 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a78:	eb cd 40 c0 	pushm	r6-r7,lr
80006a7c:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006a7e:	58 0c       	cp.w	r12,0
80006a80:	c1 10       	breq	80006aa2 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006a82:	f0 1f 00 0a 	mcall	80006aa8 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006a86:	48 a8       	lddpc	r8,80006aac <vTaskDelay+0x34>
80006a88:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a8a:	48 a8       	lddpc	r8,80006ab0 <vTaskDelay+0x38>
80006a8c:	70 0c       	ld.w	r12,r8[0x0]
80006a8e:	2f cc       	sub	r12,-4
80006a90:	f0 1f 00 09 	mcall	80006ab4 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a94:	ee 06 00 0c 	add	r12,r7,r6
80006a98:	f0 1f 00 08 	mcall	80006ab8 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006a9c:	f0 1f 00 08 	mcall	80006abc <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006aa0:	c0 21       	brne	80006aa4 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006aa2:	d7 33       	scall
80006aa4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006aa8:	80 00       	ld.sh	r0,r0[0x0]
80006aaa:	65 78       	ld.w	r8,r2[0x5c]
80006aac:	00 00       	add	r0,r0
80006aae:	0d 1c       	ld.sh	r12,r6++
80006ab0:	00 00       	add	r0,r0
80006ab2:	0c f0       	st.b	--r6,r0
80006ab4:	80 00       	ld.sh	r0,r0[0x0]
80006ab6:	5d 32       	musfr	r2
80006ab8:	80 00       	ld.sh	r0,r0[0x0]
80006aba:	6a 1c       	ld.w	r12,r5[0x4]
80006abc:	80 00       	ld.sh	r0,r0[0x0]
80006abe:	69 34       	ld.w	r4,r4[0x4c]

80006ac0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006ac0:	eb cd 40 c0 	pushm	r6-r7,lr
80006ac4:	18 96       	mov	r6,r12
80006ac6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006ac8:	f0 1f 00 18 	mcall	80006b28 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006acc:	6c 08       	ld.w	r8,r6[0x0]
80006ace:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006ad0:	49 79       	lddpc	r9,80006b2c <vTaskDelayUntil+0x6c>
80006ad2:	72 09       	ld.w	r9,r9[0x0]
80006ad4:	12 38       	cp.w	r8,r9
80006ad6:	e0 88 00 0c 	brls	80006aee <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006ada:	0e 38       	cp.w	r8,r7
80006adc:	e0 88 00 22 	brls	80006b20 <vTaskDelayUntil+0x60>
80006ae0:	49 38       	lddpc	r8,80006b2c <vTaskDelayUntil+0x6c>
80006ae2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006ae4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006ae6:	10 37       	cp.w	r7,r8
80006ae8:	e0 88 00 14 	brls	80006b10 <vTaskDelayUntil+0x50>
80006aec:	c0 a8       	rjmp	80006b00 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006aee:	0e 38       	cp.w	r8,r7
80006af0:	e0 8b 00 16 	brhi	80006b1c <vTaskDelayUntil+0x5c>
80006af4:	48 e8       	lddpc	r8,80006b2c <vTaskDelayUntil+0x6c>
80006af6:	70 08       	ld.w	r8,r8[0x0]
80006af8:	10 37       	cp.w	r7,r8
80006afa:	e0 8b 00 11 	brhi	80006b1c <vTaskDelayUntil+0x5c>
80006afe:	c1 18       	rjmp	80006b20 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b00:	48 c8       	lddpc	r8,80006b30 <vTaskDelayUntil+0x70>
80006b02:	70 0c       	ld.w	r12,r8[0x0]
80006b04:	2f cc       	sub	r12,-4
80006b06:	f0 1f 00 0c 	mcall	80006b34 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b0a:	0e 9c       	mov	r12,r7
80006b0c:	f0 1f 00 0b 	mcall	80006b38 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006b10:	f0 1f 00 0b 	mcall	80006b3c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b14:	c0 81       	brne	80006b24 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006b16:	d7 33       	scall
80006b18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b1c:	8d 07       	st.w	r6[0x0],r7
80006b1e:	cf 1b       	rjmp	80006b00 <vTaskDelayUntil+0x40>
80006b20:	8d 07       	st.w	r6[0x0],r7
80006b22:	cf 7b       	rjmp	80006b10 <vTaskDelayUntil+0x50>
80006b24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	65 78       	ld.w	r8,r2[0x5c]
80006b2c:	00 00       	add	r0,r0
80006b2e:	0d 1c       	ld.sh	r12,r6++
80006b30:	00 00       	add	r0,r0
80006b32:	0c f0       	st.b	--r6,r0
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	5d 32       	musfr	r2
80006b38:	80 00       	ld.sh	r0,r0[0x0]
80006b3a:	6a 1c       	ld.w	r12,r5[0x4]
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	69 34       	ld.w	r4,r4[0x4c]

80006b40 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006b40:	eb cd 40 c0 	pushm	r6-r7,lr
80006b44:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006b46:	48 e7       	lddpc	r7,80006b7c <vTaskPlaceOnEventList+0x3c>
80006b48:	6e 0b       	ld.w	r11,r7[0x0]
80006b4a:	2e 8b       	sub	r11,-24
80006b4c:	f0 1f 00 0d 	mcall	80006b80 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b50:	6e 0c       	ld.w	r12,r7[0x0]
80006b52:	2f cc       	sub	r12,-4
80006b54:	f0 1f 00 0c 	mcall	80006b84 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006b58:	5b f6       	cp.w	r6,-1
80006b5a:	c0 81       	brne	80006b6a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b5c:	6e 0b       	ld.w	r11,r7[0x0]
80006b5e:	2f cb       	sub	r11,-4
80006b60:	48 ac       	lddpc	r12,80006b88 <vTaskPlaceOnEventList+0x48>
80006b62:	f0 1f 00 0b 	mcall	80006b8c <vTaskPlaceOnEventList+0x4c>
80006b66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006b6a:	48 a8       	lddpc	r8,80006b90 <vTaskPlaceOnEventList+0x50>
80006b6c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b6e:	ec 0c 00 0c 	add	r12,r6,r12
80006b72:	f0 1f 00 09 	mcall	80006b94 <vTaskPlaceOnEventList+0x54>
80006b76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b7a:	00 00       	add	r0,r0
80006b7c:	00 00       	add	r0,r0
80006b7e:	0c f0       	st.b	--r6,r0
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	5c fe       	rol	lr
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	5d 32       	musfr	r2
80006b88:	00 00       	add	r0,r0
80006b8a:	0d 44       	ld.w	r4,--r6
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	5c e2       	tnbz	r2
80006b90:	00 00       	add	r0,r0
80006b92:	0d 1c       	ld.sh	r12,r6++
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	6a 1c       	ld.w	r12,r5[0x4]

80006b98 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006b98:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b9c:	49 67       	lddpc	r7,80006bf4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b9e:	49 74       	lddpc	r4,80006bf8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006ba0:	49 73       	lddpc	r3,80006bfc <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006ba2:	49 85       	lddpc	r5,80006c00 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006ba4:	6e 08       	ld.w	r8,r7[0x0]
80006ba6:	58 08       	cp.w	r8,0
80006ba8:	c1 e0       	breq	80006be4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006baa:	f0 1f 00 17 	mcall	80006c04 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006bae:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006bb0:	f0 1f 00 16 	mcall	80006c08 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006bb4:	58 06       	cp.w	r6,0
80006bb6:	c1 70       	breq	80006be4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006bb8:	f0 1f 00 15 	mcall	80006c0c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006bbc:	68 38       	ld.w	r8,r4[0xc]
80006bbe:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006bc0:	ec cc ff fc 	sub	r12,r6,-4
80006bc4:	f0 1f 00 13 	mcall	80006c10 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006bc8:	66 08       	ld.w	r8,r3[0x0]
80006bca:	20 18       	sub	r8,1
80006bcc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006bce:	6e 08       	ld.w	r8,r7[0x0]
80006bd0:	20 18       	sub	r8,1
80006bd2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006bd4:	f0 1f 00 10 	mcall	80006c14 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006bd8:	6c cc       	ld.w	r12,r6[0x30]
80006bda:	f0 1f 00 10 	mcall	80006c18 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006bde:	0c 9c       	mov	r12,r6
80006be0:	f0 1f 00 0e 	mcall	80006c18 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006be4:	6a 08       	ld.w	r8,r5[0x0]
80006be6:	58 18       	cp.w	r8,1
80006be8:	e0 88 00 03 	brls	80006bee <prvIdleTask+0x56>
			{
				taskYIELD();
80006bec:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006bee:	f0 1f 00 0c 	mcall	80006c1c <prvIdleTask+0x84>
		}
		#endif
	}
80006bf2:	cd 9b       	rjmp	80006ba4 <prvIdleTask+0xc>
80006bf4:	00 00       	add	r0,r0
80006bf6:	0c 30       	cp.w	r0,r6
80006bf8:	00 00       	add	r0,r0
80006bfa:	0c dc       	st.w	--r6,r12
80006bfc:	00 00       	add	r0,r0
80006bfe:	0d 3c       	ld.ub	r12,r6++
80006c00:	00 00       	add	r0,r0
80006c02:	0c 3c       	cp.w	r12,r6
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	65 78       	ld.w	r8,r2[0x5c]
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	69 34       	ld.w	r4,r4[0x4c]
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	5d ec       	*unknown*
80006c10:	80 00       	ld.sh	r0,r0[0x0]
80006c12:	5d 32       	musfr	r2
80006c14:	80 00       	ld.sh	r0,r0[0x0]
80006c16:	5e f8       	retal	r8
80006c18:	80 00       	ld.sh	r0,r0[0x0]
80006c1a:	60 30       	ld.w	r0,r0[0xc]
80006c1c:	80 00       	ld.sh	r0,r0[0x0]
80006c1e:	20 2c       	sub	r12,2

80006c20 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006c20:	d4 31       	pushm	r0-r7,lr
80006c22:	20 1d       	sub	sp,4
80006c24:	fa c4 ff d8 	sub	r4,sp,-40
80006c28:	50 0c       	stdsp	sp[0x0],r12
80006c2a:	16 91       	mov	r1,r11
80006c2c:	14 97       	mov	r7,r10
80006c2e:	12 90       	mov	r0,r9
80006c30:	10 93       	mov	r3,r8
80006c32:	68 02       	ld.w	r2,r4[0x0]
80006c34:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006c36:	34 8c       	mov	r12,72
80006c38:	f0 1f 00 5c 	mcall	80006da8 <xTaskGenericCreate+0x188>
80006c3c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006c3e:	c0 31       	brne	80006c44 <xTaskGenericCreate+0x24>
80006c40:	3f fc       	mov	r12,-1
80006c42:	ca f8       	rjmp	80006da0 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006c44:	58 06       	cp.w	r6,0
80006c46:	e0 81 00 af 	brne	80006da4 <xTaskGenericCreate+0x184>
80006c4a:	0e 9c       	mov	r12,r7
80006c4c:	5c 7c       	castu.h	r12
80006c4e:	a3 6c       	lsl	r12,0x2
80006c50:	f0 1f 00 56 	mcall	80006da8 <xTaskGenericCreate+0x188>
80006c54:	18 96       	mov	r6,r12
80006c56:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006c58:	c0 61       	brne	80006c64 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006c5a:	0a 9c       	mov	r12,r5
80006c5c:	f0 1f 00 54 	mcall	80006dac <xTaskGenericCreate+0x18c>
80006c60:	3f fc       	mov	r12,-1
80006c62:	c9 f8       	rjmp	80006da0 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006c64:	5c 77       	castu.h	r7
80006c66:	ee 0a 15 02 	lsl	r10,r7,0x2
80006c6a:	e0 6b 00 a5 	mov	r11,165
80006c6e:	0c 9c       	mov	r12,r6
80006c70:	f0 1f 00 50 	mcall	80006db0 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006c74:	ee c6 00 01 	sub	r6,r7,1
80006c78:	6a c8       	ld.w	r8,r5[0x30]
80006c7a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006c7e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006c82:	31 0a       	mov	r10,16
80006c84:	02 9b       	mov	r11,r1
80006c86:	ea cc ff cc 	sub	r12,r5,-52
80006c8a:	f0 1f 00 4b 	mcall	80006db4 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006c8e:	30 08       	mov	r8,0
80006c90:	eb 68 00 43 	st.b	r5[67],r8
80006c94:	58 73       	cp.w	r3,7
80006c96:	e6 07 17 80 	movls	r7,r3
80006c9a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006c9e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006ca0:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006ca4:	ea c4 ff fc 	sub	r4,r5,-4
80006ca8:	08 9c       	mov	r12,r4
80006caa:	f0 1f 00 44 	mcall	80006db8 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006cae:	ea cc ff e8 	sub	r12,r5,-24
80006cb2:	f0 1f 00 42 	mcall	80006db8 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006cb6:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006cb8:	ee 07 11 08 	rsub	r7,r7,8
80006cbc:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006cbe:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006cc0:	00 9a       	mov	r10,r0
80006cc2:	40 0b       	lddsp	r11,sp[0x0]
80006cc4:	0c 9c       	mov	r12,r6
80006cc6:	f0 1f 00 3e 	mcall	80006dbc <xTaskGenericCreate+0x19c>
80006cca:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006ccc:	58 02       	cp.w	r2,0
80006cce:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006cd2:	f0 1f 00 3c 	mcall	80006dc0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006cd6:	4b c8       	lddpc	r8,80006dc4 <xTaskGenericCreate+0x1a4>
80006cd8:	70 09       	ld.w	r9,r8[0x0]
80006cda:	2f f9       	sub	r9,-1
80006cdc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006cde:	4b b8       	lddpc	r8,80006dc8 <xTaskGenericCreate+0x1a8>
80006ce0:	70 08       	ld.w	r8,r8[0x0]
80006ce2:	58 08       	cp.w	r8,0
80006ce4:	c2 61       	brne	80006d30 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006ce6:	4b 98       	lddpc	r8,80006dc8 <xTaskGenericCreate+0x1a8>
80006ce8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006cea:	4b 78       	lddpc	r8,80006dc4 <xTaskGenericCreate+0x1a4>
80006cec:	70 08       	ld.w	r8,r8[0x0]
80006cee:	58 18       	cp.w	r8,1
80006cf0:	c2 b1       	brne	80006d46 <xTaskGenericCreate+0x126>
80006cf2:	4b 77       	lddpc	r7,80006dcc <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006cf4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006cf8:	0e 9c       	mov	r12,r7
80006cfa:	f0 1f 00 36 	mcall	80006dd0 <xTaskGenericCreate+0x1b0>
80006cfe:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006d00:	0c 37       	cp.w	r7,r6
80006d02:	cf b1       	brne	80006cf8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006d04:	4b 47       	lddpc	r7,80006dd4 <xTaskGenericCreate+0x1b4>
80006d06:	0e 9c       	mov	r12,r7
80006d08:	f0 1f 00 32 	mcall	80006dd0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006d0c:	4b 36       	lddpc	r6,80006dd8 <xTaskGenericCreate+0x1b8>
80006d0e:	0c 9c       	mov	r12,r6
80006d10:	f0 1f 00 30 	mcall	80006dd0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006d14:	4b 2c       	lddpc	r12,80006ddc <xTaskGenericCreate+0x1bc>
80006d16:	f0 1f 00 2f 	mcall	80006dd0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006d1a:	4b 2c       	lddpc	r12,80006de0 <xTaskGenericCreate+0x1c0>
80006d1c:	f0 1f 00 2d 	mcall	80006dd0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006d20:	4b 1c       	lddpc	r12,80006de4 <xTaskGenericCreate+0x1c4>
80006d22:	f0 1f 00 2c 	mcall	80006dd0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006d26:	4b 18       	lddpc	r8,80006de8 <xTaskGenericCreate+0x1c8>
80006d28:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006d2a:	4b 18       	lddpc	r8,80006dec <xTaskGenericCreate+0x1cc>
80006d2c:	91 06       	st.w	r8[0x0],r6
80006d2e:	c0 c8       	rjmp	80006d46 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006d30:	4b 08       	lddpc	r8,80006df0 <xTaskGenericCreate+0x1d0>
80006d32:	70 08       	ld.w	r8,r8[0x0]
80006d34:	58 08       	cp.w	r8,0
80006d36:	c0 81       	brne	80006d46 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006d38:	4a 48       	lddpc	r8,80006dc8 <xTaskGenericCreate+0x1a8>
80006d3a:	70 08       	ld.w	r8,r8[0x0]
80006d3c:	70 b8       	ld.w	r8,r8[0x2c]
80006d3e:	10 33       	cp.w	r3,r8
80006d40:	c0 33       	brcs	80006d46 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006d42:	4a 28       	lddpc	r8,80006dc8 <xTaskGenericCreate+0x1a8>
80006d44:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006d46:	6a b8       	ld.w	r8,r5[0x2c]
80006d48:	4a b9       	lddpc	r9,80006df4 <xTaskGenericCreate+0x1d4>
80006d4a:	72 09       	ld.w	r9,r9[0x0]
80006d4c:	12 38       	cp.w	r8,r9
80006d4e:	e0 88 00 04 	brls	80006d56 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006d52:	4a 99       	lddpc	r9,80006df4 <xTaskGenericCreate+0x1d4>
80006d54:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006d56:	4a 98       	lddpc	r8,80006df8 <xTaskGenericCreate+0x1d8>
80006d58:	70 09       	ld.w	r9,r8[0x0]
80006d5a:	2f f9       	sub	r9,-1
80006d5c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006d5e:	6a b8       	ld.w	r8,r5[0x2c]
80006d60:	4a 79       	lddpc	r9,80006dfc <xTaskGenericCreate+0x1dc>
80006d62:	72 09       	ld.w	r9,r9[0x0]
80006d64:	12 38       	cp.w	r8,r9
80006d66:	e0 88 00 04 	brls	80006d6e <xTaskGenericCreate+0x14e>
80006d6a:	4a 59       	lddpc	r9,80006dfc <xTaskGenericCreate+0x1dc>
80006d6c:	93 08       	st.w	r9[0x0],r8
80006d6e:	6a bc       	ld.w	r12,r5[0x2c]
80006d70:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006d74:	08 9b       	mov	r11,r4
80006d76:	49 68       	lddpc	r8,80006dcc <xTaskGenericCreate+0x1ac>
80006d78:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006d7c:	f0 1f 00 21 	mcall	80006e00 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006d80:	f0 1f 00 21 	mcall	80006e04 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006d84:	49 b8       	lddpc	r8,80006df0 <xTaskGenericCreate+0x1d0>
80006d86:	70 08       	ld.w	r8,r8[0x0]
80006d88:	58 08       	cp.w	r8,0
80006d8a:	c0 a0       	breq	80006d9e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006d8c:	48 f8       	lddpc	r8,80006dc8 <xTaskGenericCreate+0x1a8>
80006d8e:	70 08       	ld.w	r8,r8[0x0]
80006d90:	70 b8       	ld.w	r8,r8[0x2c]
80006d92:	10 33       	cp.w	r3,r8
80006d94:	e0 88 00 05 	brls	80006d9e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006d98:	d7 33       	scall
80006d9a:	30 1c       	mov	r12,1
80006d9c:	c0 28       	rjmp	80006da0 <xTaskGenericCreate+0x180>
80006d9e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006da0:	2f fd       	sub	sp,-4
80006da2:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006da4:	99 c6       	st.w	r12[0x30],r6
80006da6:	c5 fb       	rjmp	80006c64 <xTaskGenericCreate+0x44>
80006da8:	80 00       	ld.sh	r0,r0[0x0]
80006daa:	60 58       	ld.w	r8,r0[0x14]
80006dac:	80 00       	ld.sh	r0,r0[0x0]
80006dae:	60 30       	ld.w	r0,r0[0xc]
80006db0:	80 00       	ld.sh	r0,r0[0x0]
80006db2:	79 b0       	ld.w	r0,r12[0x6c]
80006db4:	80 00       	ld.sh	r0,r0[0x0]
80006db6:	7c dc       	ld.w	r12,lr[0x34]
80006db8:	80 00       	ld.sh	r0,r0[0x0]
80006dba:	5c dc       	com	r12
80006dbc:	80 00       	ld.sh	r0,r0[0x0]
80006dbe:	5d 58       	*unknown*
80006dc0:	80 00       	ld.sh	r0,r0[0x0]
80006dc2:	5d ec       	*unknown*
80006dc4:	00 00       	add	r0,r0
80006dc6:	0d 3c       	ld.ub	r12,r6++
80006dc8:	00 00       	add	r0,r0
80006dca:	0c f0       	st.b	--r6,r0
80006dcc:	00 00       	add	r0,r0
80006dce:	0c 3c       	cp.w	r12,r6
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	5c c8       	swap.bh	r8
80006dd4:	00 00       	add	r0,r0
80006dd6:	0d 08       	ld.w	r8,r6++
80006dd8:	00 00       	add	r0,r0
80006dda:	0d 24       	ld.uh	r4,r6++
80006ddc:	00 00       	add	r0,r0
80006dde:	0c f4       	st.b	--r6,r4
80006de0:	00 00       	add	r0,r0
80006de2:	0c dc       	st.w	--r6,r12
80006de4:	00 00       	add	r0,r0
80006de6:	0d 44       	ld.w	r4,--r6
80006de8:	00 00       	add	r0,r0
80006dea:	0c 28       	rsub	r8,r6
80006dec:	00 00       	add	r0,r0
80006dee:	0c 38       	cp.w	r8,r6
80006df0:	00 00       	add	r0,r0
80006df2:	0c 2c       	rsub	r12,r6
80006df4:	00 00       	add	r0,r0
80006df6:	0c 24       	rsub	r4,r6
80006df8:	00 00       	add	r0,r0
80006dfa:	0d 38       	ld.ub	r8,r6++
80006dfc:	00 00       	add	r0,r0
80006dfe:	0d 58       	ld.sh	r8,--r6
80006e00:	80 00       	ld.sh	r0,r0[0x0]
80006e02:	5c e2       	tnbz	r2
80006e04:	80 00       	ld.sh	r0,r0[0x0]
80006e06:	5e f8       	retal	r8

80006e08 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006e08:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006e0a:	30 09       	mov	r9,0
80006e0c:	1a d9       	st.w	--sp,r9
80006e0e:	1a d9       	st.w	--sp,r9
80006e10:	1a d9       	st.w	--sp,r9
80006e12:	12 98       	mov	r8,r9
80006e14:	e0 6a 01 00 	mov	r10,256
80006e18:	48 9b       	lddpc	r11,80006e3c <vTaskStartScheduler+0x34>
80006e1a:	48 ac       	lddpc	r12,80006e40 <vTaskStartScheduler+0x38>
80006e1c:	f0 1f 00 0a 	mcall	80006e44 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006e20:	2f dd       	sub	sp,-12
80006e22:	58 1c       	cp.w	r12,1
80006e24:	c0 a1       	brne	80006e38 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006e26:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006e28:	30 19       	mov	r9,1
80006e2a:	48 88       	lddpc	r8,80006e48 <vTaskStartScheduler+0x40>
80006e2c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006e2e:	30 09       	mov	r9,0
80006e30:	48 78       	lddpc	r8,80006e4c <vTaskStartScheduler+0x44>
80006e32:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006e34:	f0 1f 00 07 	mcall	80006e50 <vTaskStartScheduler+0x48>
80006e38:	d8 02       	popm	pc
80006e3a:	00 00       	add	r0,r0
80006e3c:	80 00       	ld.sh	r0,r0[0x0]
80006e3e:	da 20       	acall	0xa2
80006e40:	80 00       	ld.sh	r0,r0[0x0]
80006e42:	6b 98       	ld.w	r8,r5[0x64]
80006e44:	80 00       	ld.sh	r0,r0[0x0]
80006e46:	6c 20       	ld.w	r0,r6[0x8]
80006e48:	00 00       	add	r0,r0
80006e4a:	0c 2c       	rsub	r12,r6
80006e4c:	00 00       	add	r0,r0
80006e4e:	0d 1c       	ld.sh	r12,r6++
80006e50:	80 00       	ld.sh	r0,r0[0x0]
80006e52:	5d fc       	*unknown*

80006e54 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006e54:	16 cc       	st.b	r11++,r12
	return str;
}
80006e56:	5e fb       	retal	r11

80006e58 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006e58:	eb cd 40 c0 	pushm	r6-r7,lr
80006e5c:	20 3d       	sub	sp,12
80006e5e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006e60:	30 06       	mov	r6,0
80006e62:	30 07       	mov	r7,0
80006e64:	fa e7 00 00 	st.d	sp[0],r6
80006e68:	30 0c       	mov	r12,0
80006e6a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006e6c:	58 08       	cp.w	r8,0
80006e6e:	c1 30       	breq	80006e94 <PrintHex+0x3c>
80006e70:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006e72:	1a 9c       	mov	r12,sp
80006e74:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e78:	58 9e       	cp.w	lr,9
80006e7a:	e0 8a 00 04 	brle	80006e82 <PrintHex+0x2a>
80006e7e:	2c 9e       	sub	lr,-55
80006e80:	c0 48       	rjmp	80006e88 <PrintHex+0x30>
80006e82:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e86:	2d 0e       	sub	lr,-48
80006e88:	f8 09 0b 0e 	st.b	r12[r9],lr
80006e8c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006e8e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006e90:	cf 21       	brne	80006e74 <PrintHex+0x1c>
80006e92:	c0 48       	rjmp	80006e9a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006e94:	33 08       	mov	r8,48
80006e96:	ba 88       	st.b	sp[0x0],r8
80006e98:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006e9a:	f6 09 01 08 	sub	r8,r11,r9
80006e9e:	58 08       	cp.w	r8,0
80006ea0:	e0 8a 00 13 	brle	80006ec6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006ea4:	12 1b       	sub	r11,r9
80006ea6:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006eaa:	18 9e       	mov	lr,r12
80006eac:	58 0c       	cp.w	r12,0
80006eae:	e0 8a 00 0c 	brle	80006ec6 <PrintHex+0x6e>
80006eb2:	1a 9b       	mov	r11,sp
80006eb4:	12 0b       	add	r11,r9
80006eb6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006eb8:	33 07       	mov	r7,48
80006eba:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006ebc:	2f f8       	sub	r8,-1
80006ebe:	1c 38       	cp.w	r8,lr
80006ec0:	cf d5       	brlt	80006eba <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ec2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ec6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006eca:	f0 cb ff ff 	sub	r11,r8,-1
80006ece:	58 0b       	cp.w	r11,0
80006ed0:	e0 8a 00 19 	brle	80006f02 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ed4:	fa cb ff f4 	sub	r11,sp,-12
80006ed8:	f6 09 00 09 	add	r9,r11,r9
80006edc:	37 8b       	mov	r11,120
80006ede:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006ee2:	fa c9 ff f4 	sub	r9,sp,-12
80006ee6:	10 09       	add	r9,r8
80006ee8:	33 0b       	mov	r11,48
80006eea:	f3 6b ff f4 	st.b	r9[-12],r11
80006eee:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ef2:	fa ce 00 01 	sub	lr,sp,1
80006ef6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006ef8:	11 8b       	ld.ub	r11,r8[0x0]
80006efa:	12 cb       	st.b	r9++,r11
80006efc:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006efe:	1c 38       	cp.w	r8,lr
80006f00:	cf c1       	brne	80006ef8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006f02:	14 9c       	mov	r12,r10
80006f04:	2f dd       	sub	sp,-12
80006f06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006f0a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006f0a:	d4 21       	pushm	r4-r7,lr
80006f0c:	20 3d       	sub	sp,12
80006f0e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006f10:	30 06       	mov	r6,0
80006f12:	30 07       	mov	r7,0
80006f14:	fa e7 00 00 	st.d	sp[0],r6
80006f18:	30 0c       	mov	r12,0
80006f1a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006f1c:	58 08       	cp.w	r8,0
80006f1e:	c0 35       	brlt	80006f24 <PrintDec+0x1a>
80006f20:	14 97       	mov	r7,r10
80006f22:	c0 58       	rjmp	80006f2c <PrintDec+0x22>
	{
		*p++ = '-';
80006f24:	14 97       	mov	r7,r10
80006f26:	32 d9       	mov	r9,45
80006f28:	0e c9       	st.b	r7++,r9
		i = -i;
80006f2a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006f2c:	58 08       	cp.w	r8,0
80006f2e:	c0 51       	brne	80006f38 <PrintDec+0x2e>
80006f30:	33 08       	mov	r8,48
80006f32:	ba 88       	st.b	sp[0x0],r8
80006f34:	30 1e       	mov	lr,1
80006f36:	c2 f8       	rjmp	80006f94 <PrintDec+0x8a>
	
	int ten = i%10;
80006f38:	e0 65 66 67 	mov	r5,26215
80006f3c:	ea 15 66 66 	orh	r5,0x6666
80006f40:	f0 05 04 44 	muls.d	r4,r8,r5
80006f44:	ea 0c 14 02 	asr	r12,r5,0x2
80006f48:	f0 09 14 1f 	asr	r9,r8,0x1f
80006f4c:	f8 09 01 09 	sub	r9,r12,r9
80006f50:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f54:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006f58:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006f5a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006f5c:	e0 66 66 67 	mov	r6,26215
80006f60:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006f64:	2d 09       	sub	r9,-48
80006f66:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006f6a:	2f fe       	sub	lr,-1
		i /= 10;
80006f6c:	f0 06 04 44 	muls.d	r4,r8,r6
80006f70:	ea 09 14 02 	asr	r9,r5,0x2
80006f74:	bf 58       	asr	r8,0x1f
80006f76:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006f7a:	f0 06 04 44 	muls.d	r4,r8,r6
80006f7e:	ea 09 14 02 	asr	r9,r5,0x2
80006f82:	f0 05 14 1f 	asr	r5,r8,0x1f
80006f86:	0a 19       	sub	r9,r5
80006f88:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f8c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006f90:	58 08       	cp.w	r8,0
80006f92:	ce 91       	brne	80006f64 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006f94:	f6 0e 01 08 	sub	r8,r11,lr
80006f98:	58 08       	cp.w	r8,0
80006f9a:	e0 89 00 06 	brgt	80006fa6 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f9e:	58 0e       	cp.w	lr,0
80006fa0:	e0 89 00 14 	brgt	80006fc8 <PrintDec+0xbe>
80006fa4:	c1 d8       	rjmp	80006fde <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006fa6:	1c 1b       	sub	r11,lr
80006fa8:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006faa:	16 9c       	mov	r12,r11
80006fac:	58 0b       	cp.w	r11,0
80006fae:	fe 9a ff f8 	brle	80006f9e <PrintDec+0x94>
80006fb2:	1a 99       	mov	r9,sp
80006fb4:	1c 09       	add	r9,lr
80006fb6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006fb8:	33 06       	mov	r6,48
80006fba:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006fbc:	2f f8       	sub	r8,-1
80006fbe:	18 38       	cp.w	r8,r12
80006fc0:	cf d5       	brlt	80006fba <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006fc2:	f6 0e 00 0e 	add	lr,r11,lr
80006fc6:	ce cb       	rjmp	80006f9e <PrintDec+0x94>
80006fc8:	fa c8 ff f4 	sub	r8,sp,-12
80006fcc:	1c 08       	add	r8,lr
80006fce:	20 d8       	sub	r8,13
80006fd0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006fd4:	11 89       	ld.ub	r9,r8[0x0]
80006fd6:	0e c9       	st.b	r7++,r9
80006fd8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006fda:	16 38       	cp.w	r8,r11
80006fdc:	cf c1       	brne	80006fd4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006fde:	14 9c       	mov	r12,r10
80006fe0:	2f dd       	sub	sp,-12
80006fe2:	d8 22       	popm	r4-r7,pc

80006fe4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006fe4:	d4 31       	pushm	r0-r7,lr
80006fe6:	fa cd 02 08 	sub	sp,sp,520
80006fea:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006fec:	e0 6a 01 00 	mov	r10,256
80006ff0:	30 0b       	mov	r11,0
80006ff2:	fa cc fe f8 	sub	r12,sp,-264
80006ff6:	f0 1f 00 4e 	mcall	8000712c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006ffa:	fa c4 fd d4 	sub	r4,sp,-556
80006ffe:	30 0a       	mov	r10,0
80007000:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007002:	fa c3 ff fc 	sub	r3,sp,-4
80007006:	e0 61 01 00 	mov	r1,256
8000700a:	14 90       	mov	r0,r10
			
					if(*str == '%')
8000700c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000700e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007012:	02 9a       	mov	r10,r1
80007014:	00 9b       	mov	r11,r0
80007016:	06 9c       	mov	r12,r3
80007018:	f0 1f 00 45 	mcall	8000712c <log+0x148>
			
					if(*str == '%')
8000701c:	0f 88       	ld.ub	r8,r7[0x0]
8000701e:	e4 08 18 00 	cp.b	r8,r2
80007022:	c5 71       	brne	800070d0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007024:	ee c8 ff ff 	sub	r8,r7,-1
80007028:	11 89       	ld.ub	r9,r8[0x0]
8000702a:	4c 2a       	lddpc	r10,80007130 <log+0x14c>
8000702c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000702e:	23 09       	sub	r9,48
80007030:	30 9a       	mov	r10,9
80007032:	f4 09 18 00 	cp.b	r9,r10
80007036:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000703a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000703e:	f7 b9 08 30 	subls	r9,48
80007042:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007046:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000704a:	0f 88       	ld.ub	r8,r7[0x0]
8000704c:	22 58       	sub	r8,37
8000704e:	e0 48 00 53 	cp.w	r8,83
80007052:	e0 8b 00 31 	brhi	800070b4 <log+0xd0>
80007056:	4b 89       	lddpc	r9,80007134 <log+0x150>
80007058:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000705c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007060:	06 9a       	mov	r10,r3
80007062:	40 0b       	lddsp	r11,sp[0x0]
80007064:	5c 5b       	castu.b	r11
80007066:	68 0c       	ld.w	r12,r4[0x0]
80007068:	f0 1f 00 34 	mcall	80007138 <log+0x154>
							break;
8000706c:	c2 98       	rjmp	800070be <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000706e:	4b 4c       	lddpc	r12,8000713c <log+0x158>
80007070:	f0 1f 00 34 	mcall	80007140 <log+0x15c>
80007074:	08 95       	mov	r5,r4
80007076:	06 9c       	mov	r12,r3
							break;
80007078:	c2 38       	rjmp	800070be <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000707a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000707e:	06 9a       	mov	r10,r3
80007080:	40 0b       	lddsp	r11,sp[0x0]
80007082:	5c 5b       	castu.b	r11
80007084:	68 0c       	ld.w	r12,r4[0x0]
80007086:	f0 1f 00 30 	mcall	80007144 <log+0x160>
8000708a:	06 9c       	mov	r12,r3
							break;
8000708c:	c1 98       	rjmp	800070be <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000708e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80007092:	06 9b       	mov	r11,r3
80007094:	09 bc       	ld.ub	r12,r4[0x3]
80007096:	f0 1f 00 2d 	mcall	80007148 <log+0x164>
8000709a:	06 9c       	mov	r12,r3
							break;
8000709c:	c1 18       	rjmp	800070be <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000709e:	e8 c5 ff fc 	sub	r5,r4,-4
800070a2:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800070a4:	c0 d8       	rjmp	800070be <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800070a6:	06 9b       	mov	r11,r3
800070a8:	32 5c       	mov	r12,37
800070aa:	f0 1f 00 28 	mcall	80007148 <log+0x164>
800070ae:	08 95       	mov	r5,r4
800070b0:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800070b2:	c0 68       	rjmp	800070be <log+0xda>
							
							default:
							log("I need relax.");
800070b4:	4a 6c       	lddpc	r12,8000714c <log+0x168>
800070b6:	f0 1f 00 23 	mcall	80007140 <log+0x15c>
800070ba:	08 95       	mov	r5,r4
800070bc:	06 9c       	mov	r12,r3
						}
						str++;
800070be:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800070c0:	1a dc       	st.w	--sp,r12
800070c2:	1a d6       	st.w	--sp,r6
800070c4:	4a 3b       	lddpc	r11,80007150 <log+0x16c>
800070c6:	0c 9c       	mov	r12,r6
800070c8:	f0 1f 00 23 	mcall	80007154 <log+0x170>
800070cc:	2f ed       	sub	sp,-8
800070ce:	c0 a8       	rjmp	800070e2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800070d0:	2f f7       	sub	r7,-1
800070d2:	1a d8       	st.w	--sp,r8
800070d4:	1a d6       	st.w	--sp,r6
800070d6:	4a 1b       	lddpc	r11,80007158 <log+0x174>
800070d8:	0c 9c       	mov	r12,r6
800070da:	f0 1f 00 1f 	mcall	80007154 <log+0x170>
800070de:	08 95       	mov	r5,r4
800070e0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800070e2:	0f 89       	ld.ub	r9,r7[0x0]
800070e4:	30 08       	mov	r8,0
800070e6:	f0 09 18 00 	cp.b	r9,r8
800070ea:	c0 30       	breq	800070f0 <log+0x10c>
800070ec:	0a 94       	mov	r4,r5
800070ee:	c9 2b       	rjmp	80007012 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800070f0:	fa c7 fe f8 	sub	r7,sp,-264
800070f4:	1a d7       	st.w	--sp,r7
800070f6:	49 ab       	lddpc	r11,8000715c <log+0x178>
800070f8:	0e 9c       	mov	r12,r7
800070fa:	f0 1f 00 17 	mcall	80007154 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800070fe:	5c 5c       	castu.b	r12
80007100:	f8 c6 ff ff 	sub	r6,r12,-1
80007104:	0c 9c       	mov	r12,r6
80007106:	f0 1f 00 17 	mcall	80007160 <log+0x17c>
8000710a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000710c:	0c 9a       	mov	r10,r6
8000710e:	0e 9b       	mov	r11,r7
80007110:	f0 1f 00 15 	mcall	80007164 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007114:	30 09       	mov	r9,0
80007116:	30 5a       	mov	r10,5
80007118:	fa cb fe f8 	sub	r11,sp,-264
8000711c:	49 38       	lddpc	r8,80007168 <log+0x184>
8000711e:	70 0c       	ld.w	r12,r8[0x0]
80007120:	f0 1f 00 13 	mcall	8000716c <log+0x188>
80007124:	2f fd       	sub	sp,-4
	
	
}
80007126:	fe 3d fd f8 	sub	sp,-520
8000712a:	d8 32       	popm	r0-r7,pc
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	79 b0       	ld.w	r0,r12[0x6c]
80007130:	00 00       	add	r0,r0
80007132:	0d 5c       	ld.sh	r12,--r6
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	da 28       	*unknown*
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	6f 0a       	ld.w	r10,r7[0x40]
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	dc d4       	*unknown*
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	6f e4       	ld.w	r4,r7[0x78]
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	6e 58       	ld.w	r8,r7[0x14]
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	6e 54       	ld.w	r4,r7[0x14]
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	dc e4       	*unknown*
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	dc f4       	*unknown*
80007154:	80 00       	ld.sh	r0,r0[0x0]
80007156:	7c a0       	ld.w	r0,lr[0x28]
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	dc fc       	*unknown*
8000715c:	80 00       	ld.sh	r0,r0[0x0]
8000715e:	dd 04       	*unknown*
80007160:	80 00       	ld.sh	r0,r0[0x0]
80007162:	60 58       	ld.w	r8,r0[0x14]
80007164:	80 00       	ld.sh	r0,r0[0x0]
80007166:	78 68       	ld.w	r8,r12[0x18]
80007168:	00 00       	add	r0,r0
8000716a:	53 c4       	stdsp	sp[0xf0],r4
8000716c:	80 00       	ld.sh	r0,r0[0x0]
8000716e:	63 ac       	ld.w	r12,r1[0x68]

80007170 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80007170:	d4 31       	pushm	r0-r7,lr
80007172:	fa cd 02 0c 	sub	sp,sp,524
80007176:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007178:	e0 6a 01 00 	mov	r10,256
8000717c:	30 0b       	mov	r11,0
8000717e:	fa cc fe f4 	sub	r12,sp,-268
80007182:	f0 1f 00 4c 	mcall	800072b0 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007186:	fa c4 fd d0 	sub	r4,sp,-560
8000718a:	30 0a       	mov	r10,0
8000718c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000718e:	fa c3 ff fc 	sub	r3,sp,-4
80007192:	e0 61 01 00 	mov	r1,256
80007196:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007198:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000719a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000719e:	02 9a       	mov	r10,r1
800071a0:	00 9b       	mov	r11,r0
800071a2:	06 9c       	mov	r12,r3
800071a4:	f0 1f 00 43 	mcall	800072b0 <logFromISR+0x140>
			
			if(*str == '%')
800071a8:	0f 88       	ld.ub	r8,r7[0x0]
800071aa:	e4 08 18 00 	cp.b	r8,r2
800071ae:	c5 11       	brne	80007250 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800071b0:	ee c8 ff ff 	sub	r8,r7,-1
800071b4:	11 89       	ld.ub	r9,r8[0x0]
800071b6:	4c 0a       	lddpc	r10,800072b4 <logFromISR+0x144>
800071b8:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800071ba:	23 09       	sub	r9,48
800071bc:	30 9a       	mov	r10,9
800071be:	f4 09 18 00 	cp.b	r9,r10
800071c2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800071c6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800071ca:	f7 b9 08 30 	subls	r9,48
800071ce:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800071d2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800071d6:	0f 88       	ld.ub	r8,r7[0x0]
800071d8:	22 58       	sub	r8,37
800071da:	e0 48 00 53 	cp.w	r8,83
800071de:	e0 8b 00 2b 	brhi	80007234 <logFromISR+0xc4>
800071e2:	4b 69       	lddpc	r9,800072b8 <logFromISR+0x148>
800071e4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800071e8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800071ec:	06 9a       	mov	r10,r3
800071ee:	40 0b       	lddsp	r11,sp[0x0]
800071f0:	5c 5b       	castu.b	r11
800071f2:	68 0c       	ld.w	r12,r4[0x0]
800071f4:	f0 1f 00 32 	mcall	800072bc <logFromISR+0x14c>
					break;
800071f8:	c2 38       	rjmp	8000723e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800071fa:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800071fe:	06 9a       	mov	r10,r3
80007200:	40 0b       	lddsp	r11,sp[0x0]
80007202:	5c 5b       	castu.b	r11
80007204:	68 0c       	ld.w	r12,r4[0x0]
80007206:	f0 1f 00 2f 	mcall	800072c0 <logFromISR+0x150>
8000720a:	06 9c       	mov	r12,r3
					break;
8000720c:	c1 98       	rjmp	8000723e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000720e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007212:	06 9b       	mov	r11,r3
80007214:	09 bc       	ld.ub	r12,r4[0x3]
80007216:	f0 1f 00 2c 	mcall	800072c4 <logFromISR+0x154>
8000721a:	06 9c       	mov	r12,r3
					break;
8000721c:	c1 18       	rjmp	8000723e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000721e:	e8 c5 ff fc 	sub	r5,r4,-4
80007222:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007224:	c0 d8       	rjmp	8000723e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007226:	06 9b       	mov	r11,r3
80007228:	32 5c       	mov	r12,37
8000722a:	f0 1f 00 27 	mcall	800072c4 <logFromISR+0x154>
8000722e:	08 95       	mov	r5,r4
80007230:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007232:	c0 68       	rjmp	8000723e <logFromISR+0xce>
					default:
					log("I need relax.");
80007234:	4a 5c       	lddpc	r12,800072c8 <logFromISR+0x158>
80007236:	f0 1f 00 26 	mcall	800072cc <logFromISR+0x15c>
8000723a:	08 95       	mov	r5,r4
8000723c:	06 9c       	mov	r12,r3
				}
				str++;
8000723e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007240:	1a dc       	st.w	--sp,r12
80007242:	1a d6       	st.w	--sp,r6
80007244:	4a 3b       	lddpc	r11,800072d0 <logFromISR+0x160>
80007246:	0c 9c       	mov	r12,r6
80007248:	f0 1f 00 23 	mcall	800072d4 <logFromISR+0x164>
8000724c:	2f ed       	sub	sp,-8
8000724e:	c0 a8       	rjmp	80007262 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007250:	2f f7       	sub	r7,-1
80007252:	1a d8       	st.w	--sp,r8
80007254:	1a d6       	st.w	--sp,r6
80007256:	4a 1b       	lddpc	r11,800072d8 <logFromISR+0x168>
80007258:	0c 9c       	mov	r12,r6
8000725a:	f0 1f 00 1f 	mcall	800072d4 <logFromISR+0x164>
8000725e:	08 95       	mov	r5,r4
80007260:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80007262:	0f 89       	ld.ub	r9,r7[0x0]
80007264:	30 08       	mov	r8,0
80007266:	f0 09 18 00 	cp.b	r9,r8
8000726a:	c0 30       	breq	80007270 <logFromISR+0x100>
8000726c:	0a 94       	mov	r4,r5
8000726e:	c9 8b       	rjmp	8000719e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007270:	fa c7 fe f4 	sub	r7,sp,-268
80007274:	1a d7       	st.w	--sp,r7
80007276:	49 ab       	lddpc	r11,800072dc <logFromISR+0x16c>
80007278:	0e 9c       	mov	r12,r7
8000727a:	f0 1f 00 17 	mcall	800072d4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000727e:	5c 5c       	castu.b	r12
80007280:	f8 c6 ff ff 	sub	r6,r12,-1
80007284:	0c 9c       	mov	r12,r6
80007286:	f0 1f 00 17 	mcall	800072e0 <logFromISR+0x170>
8000728a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000728c:	0c 9a       	mov	r10,r6
8000728e:	0e 9b       	mov	r11,r7
80007290:	f0 1f 00 15 	mcall	800072e4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007294:	30 09       	mov	r9,0
80007296:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007298:	fa ca fe f8 	sub	r10,sp,-264
8000729c:	fa cb fe f4 	sub	r11,sp,-268
800072a0:	49 28       	lddpc	r8,800072e8 <logFromISR+0x178>
800072a2:	70 0c       	ld.w	r12,r8[0x0]
800072a4:	f0 1f 00 12 	mcall	800072ec <logFromISR+0x17c>
800072a8:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800072aa:	fe 3d fd f4 	sub	sp,-524
800072ae:	d8 32       	popm	r0-r7,pc
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	79 b0       	ld.w	r0,r12[0x6c]
800072b4:	00 00       	add	r0,r0
800072b6:	0d 5d       	ld.sh	sp,--r6
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	db 78       	*unknown*
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	6f 0a       	ld.w	r10,r7[0x40]
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	6e 58       	ld.w	r8,r7[0x14]
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	6e 54       	ld.w	r4,r7[0x14]
800072c8:	80 00       	ld.sh	r0,r0[0x0]
800072ca:	dc e4       	*unknown*
800072cc:	80 00       	ld.sh	r0,r0[0x0]
800072ce:	6f e4       	ld.w	r4,r7[0x78]
800072d0:	80 00       	ld.sh	r0,r0[0x0]
800072d2:	dc f4       	*unknown*
800072d4:	80 00       	ld.sh	r0,r0[0x0]
800072d6:	7c a0       	ld.w	r0,lr[0x28]
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	dc fc       	*unknown*
800072dc:	80 00       	ld.sh	r0,r0[0x0]
800072de:	dd 04       	*unknown*
800072e0:	80 00       	ld.sh	r0,r0[0x0]
800072e2:	60 58       	ld.w	r8,r0[0x14]
800072e4:	80 00       	ld.sh	r0,r0[0x0]
800072e6:	78 68       	ld.w	r8,r12[0x18]
800072e8:	00 00       	add	r0,r0
800072ea:	53 c4       	stdsp	sp[0xf0],r4
800072ec:	80 00       	ld.sh	r0,r0[0x0]
800072ee:	63 5c       	ld.w	r12,r1[0x54]

800072f0 <log_init>:
		
	return str;
}

void log_init(void)
{
800072f0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800072f2:	30 2b       	mov	r11,2
800072f4:	48 fc       	lddpc	r12,80007330 <log_init+0x40>
800072f6:	f0 1f 00 10 	mcall	80007334 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800072fa:	e0 6a 36 00 	mov	r10,13824
800072fe:	ea 1a 01 6e 	orh	r10,0x16e
80007302:	48 eb       	lddpc	r11,80007338 <log_init+0x48>
80007304:	fe 7c 18 00 	mov	r12,-59392
80007308:	f0 1f 00 0d 	mcall	8000733c <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000730c:	30 4b       	mov	r11,4
8000730e:	33 2c       	mov	r12,50
80007310:	f0 1f 00 0c 	mcall	80007340 <log_init+0x50>
80007314:	48 c8       	lddpc	r8,80007344 <log_init+0x54>
80007316:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007318:	30 09       	mov	r9,0
8000731a:	1a d9       	st.w	--sp,r9
8000731c:	1a d9       	st.w	--sp,r9
8000731e:	1a d9       	st.w	--sp,r9
80007320:	30 28       	mov	r8,2
80007322:	36 4a       	mov	r10,100
80007324:	48 9b       	lddpc	r11,80007348 <log_init+0x58>
80007326:	48 ac       	lddpc	r12,8000734c <log_init+0x5c>
80007328:	f0 1f 00 0a 	mcall	80007350 <log_init+0x60>
8000732c:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000732e:	d8 02       	popm	pc
80007330:	80 00       	ld.sh	r0,r0[0x0]
80007332:	dd 10       	acall	0xd1
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	53 c8       	stdsp	sp[0xf0],r8
80007338:	80 00       	ld.sh	r0,r0[0x0]
8000733a:	dc c8       	*unknown*
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	5b bc       	cp.w	r12,-5
80007340:	80 00       	ld.sh	r0,r0[0x0]
80007342:	65 04       	ld.w	r4,r2[0x40]
80007344:	00 00       	add	r0,r0
80007346:	53 c4       	stdsp	sp[0xf0],r4
80007348:	80 00       	ld.sh	r0,r0[0x0]
8000734a:	dd 0c       	*unknown*
8000734c:	80 00       	ld.sh	r0,r0[0x0]
8000734e:	73 54       	ld.w	r4,r9[0x54]
80007350:	80 00       	ld.sh	r0,r0[0x0]
80007352:	6c 20       	ld.w	r0,r6[0x8]

80007354 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007354:	eb cd 40 f8 	pushm	r3-r7,lr
80007358:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000735a:	48 c7       	lddpc	r7,80007388 <task_log+0x34>
8000735c:	30 05       	mov	r5,0
8000735e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007360:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007364:	0a 99       	mov	r9,r5
80007366:	08 9a       	mov	r10,r4
80007368:	1a 9b       	mov	r11,sp
8000736a:	6e 0c       	ld.w	r12,r7[0x0]
8000736c:	f0 1f 00 08 	mcall	8000738c <task_log+0x38>
80007370:	58 1c       	cp.w	r12,1
80007372:	cf 91       	brne	80007364 <task_log+0x10>
		{
			if( NULL != str)
80007374:	40 0b       	lddsp	r11,sp[0x0]
80007376:	58 0b       	cp.w	r11,0
80007378:	cf 60       	breq	80007364 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000737a:	06 9c       	mov	r12,r3
8000737c:	f0 1f 00 05 	mcall	80007390 <task_log+0x3c>
				vPortFree(str);
80007380:	40 0c       	lddsp	r12,sp[0x0]
80007382:	f0 1f 00 05 	mcall	80007394 <task_log+0x40>
80007386:	ce fb       	rjmp	80007364 <task_log+0x10>
80007388:	00 00       	add	r0,r0
8000738a:	53 c4       	stdsp	sp[0xf0],r4
8000738c:	80 00       	ld.sh	r0,r0[0x0]
8000738e:	61 a0       	ld.w	r0,r0[0x68]
80007390:	80 00       	ld.sh	r0,r0[0x0]
80007392:	5b 6c       	cp.w	r12,-10
80007394:	80 00       	ld.sh	r0,r0[0x0]
80007396:	60 30       	ld.w	r0,r0[0xc]

80007398 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007398:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000739a:	fe 78 10 00 	mov	r8,-61440
8000739e:	30 19       	mov	r9,1
800073a0:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800073a4:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800073a8:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800073ac:	d3 03       	ssrf	0x10
	local_start_pll0();
800073ae:	f0 1f 00 0d 	mcall	800073e0 <main+0x48>
		
	INTC_init_interrupts();
800073b2:	f0 1f 00 0d 	mcall	800073e4 <main+0x4c>
		
	log_init();
800073b6:	f0 1f 00 0d 	mcall	800073e8 <main+0x50>
	log("----start debug----");
800073ba:	48 dc       	lddpc	r12,800073ec <main+0x54>
800073bc:	f0 1f 00 0d 	mcall	800073f0 <main+0x58>
	
	xg_flashc_init();
800073c0:	f0 1f 00 0d 	mcall	800073f4 <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800073c4:	f0 1f 00 0d 	mcall	800073f8 <main+0x60>
		
	app_init();
800073c8:	f0 1f 00 0d 	mcall	800073fc <main+0x64>
	
	xg_rtc_init();
800073cc:	f0 1f 00 0d 	mcall	80007400 <main+0x68>
		
	xcmp_init();
800073d0:	f0 1f 00 0d 	mcall	80007404 <main+0x6c>

	local_start_timer();
800073d4:	f0 1f 00 0d 	mcall	80007408 <main+0x70>
		
	vTaskStartScheduler();
800073d8:	f0 1f 00 0d 	mcall	8000740c <main+0x74>
	return 0;
	
}
800073dc:	d8 0a       	popm	pc,r12=0
800073de:	00 00       	add	r0,r0
800073e0:	80 00       	ld.sh	r0,r0[0x0]
800073e2:	52 3c       	stdsp	sp[0x8c],r12
800073e4:	80 00       	ld.sh	r0,r0[0x0]
800073e6:	54 cc       	stdsp	sp[0x130],r12
800073e8:	80 00       	ld.sh	r0,r0[0x0]
800073ea:	72 f0       	ld.w	r0,r9[0x3c]
800073ec:	80 00       	ld.sh	r0,r0[0x0]
800073ee:	dd 20       	acall	0xd2
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	6f e4       	ld.w	r4,r7[0x78]
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	52 d0       	stdsp	sp[0xb4],r0
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	51 9c       	stdsp	sp[0x64],r12
800073fc:	80 00       	ld.sh	r0,r0[0x0]
800073fe:	20 3c       	sub	r12,3
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	2a 00       	sub	r0,-96
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	40 dc       	lddsp	r12,sp[0x34]
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	52 10       	stdsp	sp[0x84],r0
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	6e 08       	ld.w	r8,r7[0x0]

80007410 <free>:
80007410:	d4 01       	pushm	lr
80007412:	e0 68 0a 40 	mov	r8,2624
80007416:	18 9b       	mov	r11,r12
80007418:	70 0c       	ld.w	r12,r8[0x0]
8000741a:	e0 a0 1e 61 	rcall	8000b0dc <_free_r>
8000741e:	d8 02       	popm	pc

80007420 <malloc>:
80007420:	d4 01       	pushm	lr
80007422:	e0 68 0a 40 	mov	r8,2624
80007426:	18 9b       	mov	r11,r12
80007428:	70 0c       	ld.w	r12,r8[0x0]
8000742a:	c0 3c       	rcall	80007430 <_malloc_r>
8000742c:	d8 02       	popm	pc
8000742e:	d7 03       	nop

80007430 <_malloc_r>:
80007430:	d4 31       	pushm	r0-r7,lr
80007432:	f6 c8 ff f5 	sub	r8,r11,-11
80007436:	18 95       	mov	r5,r12
80007438:	10 97       	mov	r7,r8
8000743a:	e0 17 ff f8 	andl	r7,0xfff8
8000743e:	59 68       	cp.w	r8,22
80007440:	f9 b7 08 10 	movls	r7,16
80007444:	16 37       	cp.w	r7,r11
80007446:	5f 38       	srlo	r8
80007448:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000744c:	c0 50       	breq	80007456 <_malloc_r+0x26>
8000744e:	30 c8       	mov	r8,12
80007450:	99 38       	st.w	r12[0xc],r8
80007452:	e0 8f 01 fa 	bral	80007846 <_malloc_r+0x416>
80007456:	fe b0 f5 a3 	rcall	80005f9c <__malloc_lock>
8000745a:	e0 47 01 f7 	cp.w	r7,503
8000745e:	e0 8b 00 1d 	brhi	80007498 <_malloc_r+0x68>
80007462:	ee 03 16 03 	lsr	r3,r7,0x3
80007466:	e0 68 05 40 	mov	r8,1344
8000746a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000746e:	70 36       	ld.w	r6,r8[0xc]
80007470:	10 36       	cp.w	r6,r8
80007472:	c0 61       	brne	8000747e <_malloc_r+0x4e>
80007474:	ec c8 ff f8 	sub	r8,r6,-8
80007478:	70 36       	ld.w	r6,r8[0xc]
8000747a:	10 36       	cp.w	r6,r8
8000747c:	c0 c0       	breq	80007494 <_malloc_r+0x64>
8000747e:	6c 18       	ld.w	r8,r6[0x4]
80007480:	e0 18 ff fc 	andl	r8,0xfffc
80007484:	6c 3a       	ld.w	r10,r6[0xc]
80007486:	ec 08 00 09 	add	r9,r6,r8
8000748a:	0a 9c       	mov	r12,r5
8000748c:	6c 28       	ld.w	r8,r6[0x8]
8000748e:	95 28       	st.w	r10[0x8],r8
80007490:	91 3a       	st.w	r8[0xc],r10
80007492:	c4 78       	rjmp	80007520 <_malloc_r+0xf0>
80007494:	2f e3       	sub	r3,-2
80007496:	c4 d8       	rjmp	80007530 <_malloc_r+0x100>
80007498:	ee 03 16 09 	lsr	r3,r7,0x9
8000749c:	c0 41       	brne	800074a4 <_malloc_r+0x74>
8000749e:	ee 03 16 03 	lsr	r3,r7,0x3
800074a2:	c2 68       	rjmp	800074ee <_malloc_r+0xbe>
800074a4:	58 43       	cp.w	r3,4
800074a6:	e0 8b 00 06 	brhi	800074b2 <_malloc_r+0x82>
800074aa:	ee 03 16 06 	lsr	r3,r7,0x6
800074ae:	2c 83       	sub	r3,-56
800074b0:	c1 f8       	rjmp	800074ee <_malloc_r+0xbe>
800074b2:	59 43       	cp.w	r3,20
800074b4:	e0 8b 00 04 	brhi	800074bc <_malloc_r+0x8c>
800074b8:	2a 53       	sub	r3,-91
800074ba:	c1 a8       	rjmp	800074ee <_malloc_r+0xbe>
800074bc:	e0 43 00 54 	cp.w	r3,84
800074c0:	e0 8b 00 06 	brhi	800074cc <_malloc_r+0x9c>
800074c4:	ee 03 16 0c 	lsr	r3,r7,0xc
800074c8:	29 23       	sub	r3,-110
800074ca:	c1 28       	rjmp	800074ee <_malloc_r+0xbe>
800074cc:	e0 43 01 54 	cp.w	r3,340
800074d0:	e0 8b 00 06 	brhi	800074dc <_malloc_r+0xac>
800074d4:	ee 03 16 0f 	lsr	r3,r7,0xf
800074d8:	28 93       	sub	r3,-119
800074da:	c0 a8       	rjmp	800074ee <_malloc_r+0xbe>
800074dc:	e0 43 05 54 	cp.w	r3,1364
800074e0:	e0 88 00 04 	brls	800074e8 <_malloc_r+0xb8>
800074e4:	37 e3       	mov	r3,126
800074e6:	c0 48       	rjmp	800074ee <_malloc_r+0xbe>
800074e8:	ee 03 16 12 	lsr	r3,r7,0x12
800074ec:	28 43       	sub	r3,-124
800074ee:	e0 6a 05 40 	mov	r10,1344
800074f2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800074f6:	74 36       	ld.w	r6,r10[0xc]
800074f8:	c1 98       	rjmp	8000752a <_malloc_r+0xfa>
800074fa:	6c 19       	ld.w	r9,r6[0x4]
800074fc:	e0 19 ff fc 	andl	r9,0xfffc
80007500:	f2 07 01 0b 	sub	r11,r9,r7
80007504:	58 fb       	cp.w	r11,15
80007506:	e0 8a 00 04 	brle	8000750e <_malloc_r+0xde>
8000750a:	20 13       	sub	r3,1
8000750c:	c1 18       	rjmp	8000752e <_malloc_r+0xfe>
8000750e:	6c 38       	ld.w	r8,r6[0xc]
80007510:	58 0b       	cp.w	r11,0
80007512:	c0 b5       	brlt	80007528 <_malloc_r+0xf8>
80007514:	6c 2a       	ld.w	r10,r6[0x8]
80007516:	ec 09 00 09 	add	r9,r6,r9
8000751a:	0a 9c       	mov	r12,r5
8000751c:	91 2a       	st.w	r8[0x8],r10
8000751e:	95 38       	st.w	r10[0xc],r8
80007520:	72 18       	ld.w	r8,r9[0x4]
80007522:	a1 a8       	sbr	r8,0x0
80007524:	93 18       	st.w	r9[0x4],r8
80007526:	cb c8       	rjmp	8000769e <_malloc_r+0x26e>
80007528:	10 96       	mov	r6,r8
8000752a:	14 36       	cp.w	r6,r10
8000752c:	ce 71       	brne	800074fa <_malloc_r+0xca>
8000752e:	2f f3       	sub	r3,-1
80007530:	e0 6a 05 40 	mov	r10,1344
80007534:	f4 cc ff f8 	sub	r12,r10,-8
80007538:	78 26       	ld.w	r6,r12[0x8]
8000753a:	18 36       	cp.w	r6,r12
8000753c:	c6 c0       	breq	80007614 <_malloc_r+0x1e4>
8000753e:	6c 19       	ld.w	r9,r6[0x4]
80007540:	e0 19 ff fc 	andl	r9,0xfffc
80007544:	f2 07 01 08 	sub	r8,r9,r7
80007548:	58 f8       	cp.w	r8,15
8000754a:	e0 89 00 8f 	brgt	80007668 <_malloc_r+0x238>
8000754e:	99 3c       	st.w	r12[0xc],r12
80007550:	99 2c       	st.w	r12[0x8],r12
80007552:	58 08       	cp.w	r8,0
80007554:	c0 55       	brlt	8000755e <_malloc_r+0x12e>
80007556:	ec 09 00 09 	add	r9,r6,r9
8000755a:	0a 9c       	mov	r12,r5
8000755c:	ce 2b       	rjmp	80007520 <_malloc_r+0xf0>
8000755e:	e0 49 01 ff 	cp.w	r9,511
80007562:	e0 8b 00 13 	brhi	80007588 <_malloc_r+0x158>
80007566:	a3 99       	lsr	r9,0x3
80007568:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000756c:	70 2b       	ld.w	r11,r8[0x8]
8000756e:	8d 38       	st.w	r6[0xc],r8
80007570:	8d 2b       	st.w	r6[0x8],r11
80007572:	97 36       	st.w	r11[0xc],r6
80007574:	91 26       	st.w	r8[0x8],r6
80007576:	a3 49       	asr	r9,0x2
80007578:	74 18       	ld.w	r8,r10[0x4]
8000757a:	30 1b       	mov	r11,1
8000757c:	f6 09 09 49 	lsl	r9,r11,r9
80007580:	f1 e9 10 09 	or	r9,r8,r9
80007584:	95 19       	st.w	r10[0x4],r9
80007586:	c4 78       	rjmp	80007614 <_malloc_r+0x1e4>
80007588:	f2 0a 16 09 	lsr	r10,r9,0x9
8000758c:	58 4a       	cp.w	r10,4
8000758e:	e0 8b 00 07 	brhi	8000759c <_malloc_r+0x16c>
80007592:	f2 0a 16 06 	lsr	r10,r9,0x6
80007596:	2c 8a       	sub	r10,-56
80007598:	c2 08       	rjmp	800075d8 <_malloc_r+0x1a8>
8000759a:	d7 03       	nop
8000759c:	59 4a       	cp.w	r10,20
8000759e:	e0 8b 00 04 	brhi	800075a6 <_malloc_r+0x176>
800075a2:	2a 5a       	sub	r10,-91
800075a4:	c1 a8       	rjmp	800075d8 <_malloc_r+0x1a8>
800075a6:	e0 4a 00 54 	cp.w	r10,84
800075aa:	e0 8b 00 06 	brhi	800075b6 <_malloc_r+0x186>
800075ae:	f2 0a 16 0c 	lsr	r10,r9,0xc
800075b2:	29 2a       	sub	r10,-110
800075b4:	c1 28       	rjmp	800075d8 <_malloc_r+0x1a8>
800075b6:	e0 4a 01 54 	cp.w	r10,340
800075ba:	e0 8b 00 06 	brhi	800075c6 <_malloc_r+0x196>
800075be:	f2 0a 16 0f 	lsr	r10,r9,0xf
800075c2:	28 9a       	sub	r10,-119
800075c4:	c0 a8       	rjmp	800075d8 <_malloc_r+0x1a8>
800075c6:	e0 4a 05 54 	cp.w	r10,1364
800075ca:	e0 88 00 04 	brls	800075d2 <_malloc_r+0x1a2>
800075ce:	37 ea       	mov	r10,126
800075d0:	c0 48       	rjmp	800075d8 <_malloc_r+0x1a8>
800075d2:	f2 0a 16 12 	lsr	r10,r9,0x12
800075d6:	28 4a       	sub	r10,-124
800075d8:	e0 6b 05 40 	mov	r11,1344
800075dc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800075e0:	68 28       	ld.w	r8,r4[0x8]
800075e2:	08 38       	cp.w	r8,r4
800075e4:	c0 e1       	brne	80007600 <_malloc_r+0x1d0>
800075e6:	76 19       	ld.w	r9,r11[0x4]
800075e8:	a3 4a       	asr	r10,0x2
800075ea:	30 1e       	mov	lr,1
800075ec:	fc 0a 09 4a 	lsl	r10,lr,r10
800075f0:	f3 ea 10 0a 	or	r10,r9,r10
800075f4:	10 99       	mov	r9,r8
800075f6:	97 1a       	st.w	r11[0x4],r10
800075f8:	c0 a8       	rjmp	8000760c <_malloc_r+0x1dc>
800075fa:	70 28       	ld.w	r8,r8[0x8]
800075fc:	08 38       	cp.w	r8,r4
800075fe:	c0 60       	breq	8000760a <_malloc_r+0x1da>
80007600:	70 1a       	ld.w	r10,r8[0x4]
80007602:	e0 1a ff fc 	andl	r10,0xfffc
80007606:	14 39       	cp.w	r9,r10
80007608:	cf 93       	brcs	800075fa <_malloc_r+0x1ca>
8000760a:	70 39       	ld.w	r9,r8[0xc]
8000760c:	8d 39       	st.w	r6[0xc],r9
8000760e:	8d 28       	st.w	r6[0x8],r8
80007610:	91 36       	st.w	r8[0xc],r6
80007612:	93 26       	st.w	r9[0x8],r6
80007614:	e6 08 14 02 	asr	r8,r3,0x2
80007618:	30 1b       	mov	r11,1
8000761a:	e0 64 05 40 	mov	r4,1344
8000761e:	f6 08 09 4b 	lsl	r11,r11,r8
80007622:	68 18       	ld.w	r8,r4[0x4]
80007624:	10 3b       	cp.w	r11,r8
80007626:	e0 8b 00 6b 	brhi	800076fc <_malloc_r+0x2cc>
8000762a:	f7 e8 00 09 	and	r9,r11,r8
8000762e:	c0 b1       	brne	80007644 <_malloc_r+0x214>
80007630:	e0 13 ff fc 	andl	r3,0xfffc
80007634:	a1 7b       	lsl	r11,0x1
80007636:	2f c3       	sub	r3,-4
80007638:	c0 38       	rjmp	8000763e <_malloc_r+0x20e>
8000763a:	2f c3       	sub	r3,-4
8000763c:	a1 7b       	lsl	r11,0x1
8000763e:	f7 e8 00 09 	and	r9,r11,r8
80007642:	cf c0       	breq	8000763a <_malloc_r+0x20a>
80007644:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007648:	06 92       	mov	r2,r3
8000764a:	1c 91       	mov	r1,lr
8000764c:	62 36       	ld.w	r6,r1[0xc]
8000764e:	c2 e8       	rjmp	800076aa <_malloc_r+0x27a>
80007650:	6c 1a       	ld.w	r10,r6[0x4]
80007652:	e0 1a ff fc 	andl	r10,0xfffc
80007656:	f4 07 01 08 	sub	r8,r10,r7
8000765a:	58 f8       	cp.w	r8,15
8000765c:	e0 8a 00 15 	brle	80007686 <_malloc_r+0x256>
80007660:	6c 3a       	ld.w	r10,r6[0xc]
80007662:	6c 29       	ld.w	r9,r6[0x8]
80007664:	95 29       	st.w	r10[0x8],r9
80007666:	93 3a       	st.w	r9[0xc],r10
80007668:	0e 99       	mov	r9,r7
8000766a:	ec 07 00 07 	add	r7,r6,r7
8000766e:	a1 a9       	sbr	r9,0x0
80007670:	99 37       	st.w	r12[0xc],r7
80007672:	99 27       	st.w	r12[0x8],r7
80007674:	8d 19       	st.w	r6[0x4],r9
80007676:	ee 08 09 08 	st.w	r7[r8],r8
8000767a:	8f 2c       	st.w	r7[0x8],r12
8000767c:	8f 3c       	st.w	r7[0xc],r12
8000767e:	a1 a8       	sbr	r8,0x0
80007680:	0a 9c       	mov	r12,r5
80007682:	8f 18       	st.w	r7[0x4],r8
80007684:	c0 d8       	rjmp	8000769e <_malloc_r+0x26e>
80007686:	6c 39       	ld.w	r9,r6[0xc]
80007688:	58 08       	cp.w	r8,0
8000768a:	c0 f5       	brlt	800076a8 <_malloc_r+0x278>
8000768c:	ec 0a 00 0a 	add	r10,r6,r10
80007690:	74 18       	ld.w	r8,r10[0x4]
80007692:	a1 a8       	sbr	r8,0x0
80007694:	0a 9c       	mov	r12,r5
80007696:	95 18       	st.w	r10[0x4],r8
80007698:	6c 28       	ld.w	r8,r6[0x8]
8000769a:	93 28       	st.w	r9[0x8],r8
8000769c:	91 39       	st.w	r8[0xc],r9
8000769e:	fe b0 f4 85 	rcall	80005fa8 <__malloc_unlock>
800076a2:	ec cc ff f8 	sub	r12,r6,-8
800076a6:	d8 32       	popm	r0-r7,pc
800076a8:	12 96       	mov	r6,r9
800076aa:	02 36       	cp.w	r6,r1
800076ac:	cd 21       	brne	80007650 <_malloc_r+0x220>
800076ae:	2f f2       	sub	r2,-1
800076b0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800076b4:	c0 30       	breq	800076ba <_malloc_r+0x28a>
800076b6:	2f 81       	sub	r1,-8
800076b8:	cc ab       	rjmp	8000764c <_malloc_r+0x21c>
800076ba:	1c 98       	mov	r8,lr
800076bc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800076c0:	c0 81       	brne	800076d0 <_malloc_r+0x2a0>
800076c2:	68 19       	ld.w	r9,r4[0x4]
800076c4:	f6 08 11 ff 	rsub	r8,r11,-1
800076c8:	f3 e8 00 08 	and	r8,r9,r8
800076cc:	89 18       	st.w	r4[0x4],r8
800076ce:	c0 78       	rjmp	800076dc <_malloc_r+0x2ac>
800076d0:	f0 c9 00 08 	sub	r9,r8,8
800076d4:	20 13       	sub	r3,1
800076d6:	70 08       	ld.w	r8,r8[0x0]
800076d8:	12 38       	cp.w	r8,r9
800076da:	cf 10       	breq	800076bc <_malloc_r+0x28c>
800076dc:	a1 7b       	lsl	r11,0x1
800076de:	68 18       	ld.w	r8,r4[0x4]
800076e0:	10 3b       	cp.w	r11,r8
800076e2:	e0 8b 00 0d 	brhi	800076fc <_malloc_r+0x2cc>
800076e6:	58 0b       	cp.w	r11,0
800076e8:	c0 a0       	breq	800076fc <_malloc_r+0x2cc>
800076ea:	04 93       	mov	r3,r2
800076ec:	c0 38       	rjmp	800076f2 <_malloc_r+0x2c2>
800076ee:	2f c3       	sub	r3,-4
800076f0:	a1 7b       	lsl	r11,0x1
800076f2:	f7 e8 00 09 	and	r9,r11,r8
800076f6:	ca 71       	brne	80007644 <_malloc_r+0x214>
800076f8:	cf bb       	rjmp	800076ee <_malloc_r+0x2be>
800076fa:	d7 03       	nop
800076fc:	68 23       	ld.w	r3,r4[0x8]
800076fe:	66 12       	ld.w	r2,r3[0x4]
80007700:	e0 12 ff fc 	andl	r2,0xfffc
80007704:	0e 32       	cp.w	r2,r7
80007706:	5f 39       	srlo	r9
80007708:	e4 07 01 08 	sub	r8,r2,r7
8000770c:	58 f8       	cp.w	r8,15
8000770e:	5f aa       	srle	r10
80007710:	f5 e9 10 09 	or	r9,r10,r9
80007714:	e0 80 00 9a 	breq	80007848 <_malloc_r+0x418>
80007718:	e0 68 0d 68 	mov	r8,3432
8000771c:	70 01       	ld.w	r1,r8[0x0]
8000771e:	e0 68 09 4c 	mov	r8,2380
80007722:	2f 01       	sub	r1,-16
80007724:	70 08       	ld.w	r8,r8[0x0]
80007726:	0e 01       	add	r1,r7
80007728:	5b f8       	cp.w	r8,-1
8000772a:	c0 40       	breq	80007732 <_malloc_r+0x302>
8000772c:	28 11       	sub	r1,-127
8000772e:	e0 11 ff 80 	andl	r1,0xff80
80007732:	02 9b       	mov	r11,r1
80007734:	0a 9c       	mov	r12,r5
80007736:	e0 a0 02 a5 	rcall	80007c80 <_sbrk_r>
8000773a:	18 96       	mov	r6,r12
8000773c:	5b fc       	cp.w	r12,-1
8000773e:	c7 50       	breq	80007828 <_malloc_r+0x3f8>
80007740:	e6 02 00 08 	add	r8,r3,r2
80007744:	10 3c       	cp.w	r12,r8
80007746:	c0 32       	brcc	8000774c <_malloc_r+0x31c>
80007748:	08 33       	cp.w	r3,r4
8000774a:	c6 f1       	brne	80007828 <_malloc_r+0x3f8>
8000774c:	e0 6a 0d 6c 	mov	r10,3436
80007750:	74 09       	ld.w	r9,r10[0x0]
80007752:	e2 09 00 09 	add	r9,r1,r9
80007756:	95 09       	st.w	r10[0x0],r9
80007758:	10 36       	cp.w	r6,r8
8000775a:	c0 a1       	brne	8000776e <_malloc_r+0x33e>
8000775c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007760:	c0 71       	brne	8000776e <_malloc_r+0x33e>
80007762:	e2 02 00 02 	add	r2,r1,r2
80007766:	68 28       	ld.w	r8,r4[0x8]
80007768:	a1 a2       	sbr	r2,0x0
8000776a:	91 12       	st.w	r8[0x4],r2
8000776c:	c4 f8       	rjmp	8000780a <_malloc_r+0x3da>
8000776e:	e0 6a 09 4c 	mov	r10,2380
80007772:	74 0b       	ld.w	r11,r10[0x0]
80007774:	5b fb       	cp.w	r11,-1
80007776:	c0 31       	brne	8000777c <_malloc_r+0x34c>
80007778:	95 06       	st.w	r10[0x0],r6
8000777a:	c0 78       	rjmp	80007788 <_malloc_r+0x358>
8000777c:	ec 09 00 09 	add	r9,r6,r9
80007780:	e0 6a 0d 6c 	mov	r10,3436
80007784:	10 19       	sub	r9,r8
80007786:	95 09       	st.w	r10[0x0],r9
80007788:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000778c:	f0 09 11 08 	rsub	r9,r8,8
80007790:	58 08       	cp.w	r8,0
80007792:	f2 08 17 10 	movne	r8,r9
80007796:	ed d8 e1 06 	addne	r6,r6,r8
8000779a:	28 08       	sub	r8,-128
8000779c:	ec 01 00 01 	add	r1,r6,r1
800077a0:	0a 9c       	mov	r12,r5
800077a2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800077a6:	f0 01 01 01 	sub	r1,r8,r1
800077aa:	02 9b       	mov	r11,r1
800077ac:	e0 a0 02 6a 	rcall	80007c80 <_sbrk_r>
800077b0:	e0 68 0d 6c 	mov	r8,3436
800077b4:	5b fc       	cp.w	r12,-1
800077b6:	ec 0c 17 00 	moveq	r12,r6
800077ba:	f9 b1 00 00 	moveq	r1,0
800077be:	70 09       	ld.w	r9,r8[0x0]
800077c0:	0c 1c       	sub	r12,r6
800077c2:	89 26       	st.w	r4[0x8],r6
800077c4:	02 0c       	add	r12,r1
800077c6:	12 01       	add	r1,r9
800077c8:	a1 ac       	sbr	r12,0x0
800077ca:	91 01       	st.w	r8[0x0],r1
800077cc:	8d 1c       	st.w	r6[0x4],r12
800077ce:	08 33       	cp.w	r3,r4
800077d0:	c1 d0       	breq	8000780a <_malloc_r+0x3da>
800077d2:	58 f2       	cp.w	r2,15
800077d4:	e0 8b 00 05 	brhi	800077de <_malloc_r+0x3ae>
800077d8:	30 18       	mov	r8,1
800077da:	8d 18       	st.w	r6[0x4],r8
800077dc:	c2 68       	rjmp	80007828 <_malloc_r+0x3f8>
800077de:	30 59       	mov	r9,5
800077e0:	20 c2       	sub	r2,12
800077e2:	e0 12 ff f8 	andl	r2,0xfff8
800077e6:	e6 02 00 08 	add	r8,r3,r2
800077ea:	91 29       	st.w	r8[0x8],r9
800077ec:	91 19       	st.w	r8[0x4],r9
800077ee:	66 18       	ld.w	r8,r3[0x4]
800077f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077f4:	e5 e8 10 08 	or	r8,r2,r8
800077f8:	87 18       	st.w	r3[0x4],r8
800077fa:	58 f2       	cp.w	r2,15
800077fc:	e0 88 00 07 	brls	8000780a <_malloc_r+0x3da>
80007800:	e6 cb ff f8 	sub	r11,r3,-8
80007804:	0a 9c       	mov	r12,r5
80007806:	e0 a0 1c 6b 	rcall	8000b0dc <_free_r>
8000780a:	e0 69 0d 64 	mov	r9,3428
8000780e:	72 0a       	ld.w	r10,r9[0x0]
80007810:	e0 68 0d 6c 	mov	r8,3436
80007814:	70 08       	ld.w	r8,r8[0x0]
80007816:	14 38       	cp.w	r8,r10
80007818:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000781c:	e0 69 0d 60 	mov	r9,3424
80007820:	72 0a       	ld.w	r10,r9[0x0]
80007822:	14 38       	cp.w	r8,r10
80007824:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007828:	68 28       	ld.w	r8,r4[0x8]
8000782a:	70 18       	ld.w	r8,r8[0x4]
8000782c:	e0 18 ff fc 	andl	r8,0xfffc
80007830:	0e 38       	cp.w	r8,r7
80007832:	5f 39       	srlo	r9
80007834:	0e 18       	sub	r8,r7
80007836:	58 f8       	cp.w	r8,15
80007838:	5f aa       	srle	r10
8000783a:	f5 e9 10 09 	or	r9,r10,r9
8000783e:	c0 50       	breq	80007848 <_malloc_r+0x418>
80007840:	0a 9c       	mov	r12,r5
80007842:	fe b0 f3 b3 	rcall	80005fa8 <__malloc_unlock>
80007846:	d8 3a       	popm	r0-r7,pc,r12=0
80007848:	68 26       	ld.w	r6,r4[0x8]
8000784a:	a1 a8       	sbr	r8,0x0
8000784c:	0e 99       	mov	r9,r7
8000784e:	a1 a9       	sbr	r9,0x0
80007850:	8d 19       	st.w	r6[0x4],r9
80007852:	ec 07 00 07 	add	r7,r6,r7
80007856:	0a 9c       	mov	r12,r5
80007858:	89 27       	st.w	r4[0x8],r7
8000785a:	8f 18       	st.w	r7[0x4],r8
8000785c:	fe b0 f3 a6 	rcall	80005fa8 <__malloc_unlock>
80007860:	ec cc ff f8 	sub	r12,r6,-8
80007864:	d8 32       	popm	r0-r7,pc
80007866:	d7 03       	nop

80007868 <memcpy>:
80007868:	58 8a       	cp.w	r10,8
8000786a:	c2 f5       	brlt	800078c8 <memcpy+0x60>
8000786c:	f9 eb 10 09 	or	r9,r12,r11
80007870:	e2 19 00 03 	andl	r9,0x3,COH
80007874:	e0 81 00 97 	brne	800079a2 <memcpy+0x13a>
80007878:	e0 4a 00 20 	cp.w	r10,32
8000787c:	c3 b4       	brge	800078f2 <memcpy+0x8a>
8000787e:	f4 08 14 02 	asr	r8,r10,0x2
80007882:	f0 09 11 08 	rsub	r9,r8,8
80007886:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000788a:	76 69       	ld.w	r9,r11[0x18]
8000788c:	99 69       	st.w	r12[0x18],r9
8000788e:	76 59       	ld.w	r9,r11[0x14]
80007890:	99 59       	st.w	r12[0x14],r9
80007892:	76 49       	ld.w	r9,r11[0x10]
80007894:	99 49       	st.w	r12[0x10],r9
80007896:	76 39       	ld.w	r9,r11[0xc]
80007898:	99 39       	st.w	r12[0xc],r9
8000789a:	76 29       	ld.w	r9,r11[0x8]
8000789c:	99 29       	st.w	r12[0x8],r9
8000789e:	76 19       	ld.w	r9,r11[0x4]
800078a0:	99 19       	st.w	r12[0x4],r9
800078a2:	76 09       	ld.w	r9,r11[0x0]
800078a4:	99 09       	st.w	r12[0x0],r9
800078a6:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800078aa:	f8 08 00 28 	add	r8,r12,r8<<0x2
800078ae:	e0 1a 00 03 	andl	r10,0x3
800078b2:	f4 0a 11 04 	rsub	r10,r10,4
800078b6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078ba:	17 a9       	ld.ub	r9,r11[0x2]
800078bc:	b0 a9       	st.b	r8[0x2],r9
800078be:	17 99       	ld.ub	r9,r11[0x1]
800078c0:	b0 99       	st.b	r8[0x1],r9
800078c2:	17 89       	ld.ub	r9,r11[0x0]
800078c4:	b0 89       	st.b	r8[0x0],r9
800078c6:	5e fc       	retal	r12
800078c8:	f4 0a 11 09 	rsub	r10,r10,9
800078cc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078d0:	17 f9       	ld.ub	r9,r11[0x7]
800078d2:	b8 f9       	st.b	r12[0x7],r9
800078d4:	17 e9       	ld.ub	r9,r11[0x6]
800078d6:	b8 e9       	st.b	r12[0x6],r9
800078d8:	17 d9       	ld.ub	r9,r11[0x5]
800078da:	b8 d9       	st.b	r12[0x5],r9
800078dc:	17 c9       	ld.ub	r9,r11[0x4]
800078de:	b8 c9       	st.b	r12[0x4],r9
800078e0:	17 b9       	ld.ub	r9,r11[0x3]
800078e2:	b8 b9       	st.b	r12[0x3],r9
800078e4:	17 a9       	ld.ub	r9,r11[0x2]
800078e6:	b8 a9       	st.b	r12[0x2],r9
800078e8:	17 99       	ld.ub	r9,r11[0x1]
800078ea:	b8 99       	st.b	r12[0x1],r9
800078ec:	17 89       	ld.ub	r9,r11[0x0]
800078ee:	b8 89       	st.b	r12[0x0],r9
800078f0:	5e fc       	retal	r12
800078f2:	eb cd 40 c0 	pushm	r6-r7,lr
800078f6:	18 99       	mov	r9,r12
800078f8:	22 0a       	sub	r10,32
800078fa:	b7 07       	ld.d	r6,r11++
800078fc:	b3 26       	st.d	r9++,r6
800078fe:	b7 07       	ld.d	r6,r11++
80007900:	b3 26       	st.d	r9++,r6
80007902:	b7 07       	ld.d	r6,r11++
80007904:	b3 26       	st.d	r9++,r6
80007906:	b7 07       	ld.d	r6,r11++
80007908:	b3 26       	st.d	r9++,r6
8000790a:	22 0a       	sub	r10,32
8000790c:	cf 74       	brge	800078fa <memcpy+0x92>
8000790e:	2f 0a       	sub	r10,-16
80007910:	c0 65       	brlt	8000791c <memcpy+0xb4>
80007912:	b7 07       	ld.d	r6,r11++
80007914:	b3 26       	st.d	r9++,r6
80007916:	b7 07       	ld.d	r6,r11++
80007918:	b3 26       	st.d	r9++,r6
8000791a:	21 0a       	sub	r10,16
8000791c:	5c 3a       	neg	r10
8000791e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007922:	d7 03       	nop
80007924:	d7 03       	nop
80007926:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000792a:	f3 66 00 0e 	st.b	r9[14],r6
8000792e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007932:	f3 66 00 0d 	st.b	r9[13],r6
80007936:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000793a:	f3 66 00 0c 	st.b	r9[12],r6
8000793e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007942:	f3 66 00 0b 	st.b	r9[11],r6
80007946:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000794a:	f3 66 00 0a 	st.b	r9[10],r6
8000794e:	f7 36 00 09 	ld.ub	r6,r11[9]
80007952:	f3 66 00 09 	st.b	r9[9],r6
80007956:	f7 36 00 08 	ld.ub	r6,r11[8]
8000795a:	f3 66 00 08 	st.b	r9[8],r6
8000795e:	f7 36 00 07 	ld.ub	r6,r11[7]
80007962:	f3 66 00 07 	st.b	r9[7],r6
80007966:	f7 36 00 06 	ld.ub	r6,r11[6]
8000796a:	f3 66 00 06 	st.b	r9[6],r6
8000796e:	f7 36 00 05 	ld.ub	r6,r11[5]
80007972:	f3 66 00 05 	st.b	r9[5],r6
80007976:	f7 36 00 04 	ld.ub	r6,r11[4]
8000797a:	f3 66 00 04 	st.b	r9[4],r6
8000797e:	f7 36 00 03 	ld.ub	r6,r11[3]
80007982:	f3 66 00 03 	st.b	r9[3],r6
80007986:	f7 36 00 02 	ld.ub	r6,r11[2]
8000798a:	f3 66 00 02 	st.b	r9[2],r6
8000798e:	f7 36 00 01 	ld.ub	r6,r11[1]
80007992:	f3 66 00 01 	st.b	r9[1],r6
80007996:	f7 36 00 00 	ld.ub	r6,r11[0]
8000799a:	f3 66 00 00 	st.b	r9[0],r6
8000799e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800079a2:	20 1a       	sub	r10,1
800079a4:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800079a8:	f8 0a 0b 09 	st.b	r12[r10],r9
800079ac:	cf b1       	brne	800079a2 <memcpy+0x13a>
800079ae:	5e fc       	retal	r12

800079b0 <memset>:
800079b0:	18 98       	mov	r8,r12
800079b2:	c0 38       	rjmp	800079b8 <memset+0x8>
800079b4:	10 cb       	st.b	r8++,r11
800079b6:	20 1a       	sub	r10,1
800079b8:	58 0a       	cp.w	r10,0
800079ba:	cf d1       	brne	800079b4 <memset+0x4>
800079bc:	5e fc       	retal	r12
800079be:	d7 03       	nop

800079c0 <_realloc_r>:
800079c0:	d4 31       	pushm	r0-r7,lr
800079c2:	20 1d       	sub	sp,4
800079c4:	16 94       	mov	r4,r11
800079c6:	18 92       	mov	r2,r12
800079c8:	14 9b       	mov	r11,r10
800079ca:	58 04       	cp.w	r4,0
800079cc:	c0 51       	brne	800079d6 <_realloc_r+0x16>
800079ce:	fe b0 fd 31 	rcall	80007430 <_malloc_r>
800079d2:	18 95       	mov	r5,r12
800079d4:	c5 39       	rjmp	80007c7a <_realloc_r+0x2ba>
800079d6:	50 0a       	stdsp	sp[0x0],r10
800079d8:	fe b0 f2 e2 	rcall	80005f9c <__malloc_lock>
800079dc:	40 0b       	lddsp	r11,sp[0x0]
800079de:	f6 c8 ff f5 	sub	r8,r11,-11
800079e2:	e8 c1 00 08 	sub	r1,r4,8
800079e6:	10 96       	mov	r6,r8
800079e8:	62 1c       	ld.w	r12,r1[0x4]
800079ea:	e0 16 ff f8 	andl	r6,0xfff8
800079ee:	59 68       	cp.w	r8,22
800079f0:	f9 b6 08 10 	movls	r6,16
800079f4:	16 36       	cp.w	r6,r11
800079f6:	5f 38       	srlo	r8
800079f8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800079fc:	c0 50       	breq	80007a06 <_realloc_r+0x46>
800079fe:	30 c8       	mov	r8,12
80007a00:	30 05       	mov	r5,0
80007a02:	85 38       	st.w	r2[0xc],r8
80007a04:	c3 b9       	rjmp	80007c7a <_realloc_r+0x2ba>
80007a06:	18 90       	mov	r0,r12
80007a08:	e0 10 ff fc 	andl	r0,0xfffc
80007a0c:	0c 30       	cp.w	r0,r6
80007a0e:	e0 84 01 0b 	brge	80007c24 <_realloc_r+0x264>
80007a12:	e0 68 05 40 	mov	r8,1344
80007a16:	e2 00 00 09 	add	r9,r1,r0
80007a1a:	70 25       	ld.w	r5,r8[0x8]
80007a1c:	0a 39       	cp.w	r9,r5
80007a1e:	c0 90       	breq	80007a30 <_realloc_r+0x70>
80007a20:	72 1a       	ld.w	r10,r9[0x4]
80007a22:	a1 ca       	cbr	r10,0x0
80007a24:	f2 0a 00 0a 	add	r10,r9,r10
80007a28:	74 1a       	ld.w	r10,r10[0x4]
80007a2a:	ed ba 00 00 	bld	r10,0x0
80007a2e:	c2 20       	breq	80007a72 <_realloc_r+0xb2>
80007a30:	72 1a       	ld.w	r10,r9[0x4]
80007a32:	e0 1a ff fc 	andl	r10,0xfffc
80007a36:	f4 00 00 03 	add	r3,r10,r0
80007a3a:	0a 39       	cp.w	r9,r5
80007a3c:	c1 31       	brne	80007a62 <_realloc_r+0xa2>
80007a3e:	ec c7 ff f0 	sub	r7,r6,-16
80007a42:	0e 33       	cp.w	r3,r7
80007a44:	c1 95       	brlt	80007a76 <_realloc_r+0xb6>
80007a46:	e2 06 00 09 	add	r9,r1,r6
80007a4a:	0c 13       	sub	r3,r6
80007a4c:	a1 a3       	sbr	r3,0x0
80007a4e:	93 13       	st.w	r9[0x4],r3
80007a50:	91 29       	st.w	r8[0x8],r9
80007a52:	04 9c       	mov	r12,r2
80007a54:	62 18       	ld.w	r8,r1[0x4]
80007a56:	08 95       	mov	r5,r4
80007a58:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a5c:	10 46       	or	r6,r8
80007a5e:	83 16       	st.w	r1[0x4],r6
80007a60:	c0 b9       	rjmp	80007c76 <_realloc_r+0x2b6>
80007a62:	0c 33       	cp.w	r3,r6
80007a64:	c0 95       	brlt	80007a76 <_realloc_r+0xb6>
80007a66:	72 28       	ld.w	r8,r9[0x8]
80007a68:	02 97       	mov	r7,r1
80007a6a:	72 39       	ld.w	r9,r9[0xc]
80007a6c:	93 28       	st.w	r9[0x8],r8
80007a6e:	91 39       	st.w	r8[0xc],r9
80007a70:	cd c8       	rjmp	80007c28 <_realloc_r+0x268>
80007a72:	30 0a       	mov	r10,0
80007a74:	14 99       	mov	r9,r10
80007a76:	ed bc 00 00 	bld	r12,0x0
80007a7a:	e0 80 00 95 	breq	80007ba4 <_realloc_r+0x1e4>
80007a7e:	62 07       	ld.w	r7,r1[0x0]
80007a80:	e2 07 01 07 	sub	r7,r1,r7
80007a84:	6e 1c       	ld.w	r12,r7[0x4]
80007a86:	e0 1c ff fc 	andl	r12,0xfffc
80007a8a:	58 09       	cp.w	r9,0
80007a8c:	c5 60       	breq	80007b38 <_realloc_r+0x178>
80007a8e:	f8 00 00 03 	add	r3,r12,r0
80007a92:	0a 39       	cp.w	r9,r5
80007a94:	c4 81       	brne	80007b24 <_realloc_r+0x164>
80007a96:	14 03       	add	r3,r10
80007a98:	ec c9 ff f0 	sub	r9,r6,-16
80007a9c:	12 33       	cp.w	r3,r9
80007a9e:	c4 d5       	brlt	80007b38 <_realloc_r+0x178>
80007aa0:	6e 3a       	ld.w	r10,r7[0xc]
80007aa2:	6e 29       	ld.w	r9,r7[0x8]
80007aa4:	95 29       	st.w	r10[0x8],r9
80007aa6:	93 3a       	st.w	r9[0xc],r10
80007aa8:	ee c5 ff f8 	sub	r5,r7,-8
80007aac:	e0 ca 00 04 	sub	r10,r0,4
80007ab0:	e0 4a 00 24 	cp.w	r10,36
80007ab4:	e0 8b 00 25 	brhi	80007afe <_realloc_r+0x13e>
80007ab8:	0a 99       	mov	r9,r5
80007aba:	59 3a       	cp.w	r10,19
80007abc:	e0 88 00 1a 	brls	80007af0 <_realloc_r+0x130>
80007ac0:	09 09       	ld.w	r9,r4++
80007ac2:	8b 09       	st.w	r5[0x0],r9
80007ac4:	09 09       	ld.w	r9,r4++
80007ac6:	8f 39       	st.w	r7[0xc],r9
80007ac8:	ee c9 ff f0 	sub	r9,r7,-16
80007acc:	59 ba       	cp.w	r10,27
80007ace:	e0 88 00 11 	brls	80007af0 <_realloc_r+0x130>
80007ad2:	09 0b       	ld.w	r11,r4++
80007ad4:	93 0b       	st.w	r9[0x0],r11
80007ad6:	09 09       	ld.w	r9,r4++
80007ad8:	8f 59       	st.w	r7[0x14],r9
80007ada:	ee c9 ff e8 	sub	r9,r7,-24
80007ade:	e0 4a 00 24 	cp.w	r10,36
80007ae2:	c0 71       	brne	80007af0 <_realloc_r+0x130>
80007ae4:	09 0a       	ld.w	r10,r4++
80007ae6:	93 0a       	st.w	r9[0x0],r10
80007ae8:	ee c9 ff e0 	sub	r9,r7,-32
80007aec:	09 0a       	ld.w	r10,r4++
80007aee:	8f 7a       	st.w	r7[0x1c],r10
80007af0:	09 0a       	ld.w	r10,r4++
80007af2:	12 aa       	st.w	r9++,r10
80007af4:	68 0a       	ld.w	r10,r4[0x0]
80007af6:	93 0a       	st.w	r9[0x0],r10
80007af8:	68 1a       	ld.w	r10,r4[0x4]
80007afa:	93 1a       	st.w	r9[0x4],r10
80007afc:	c0 78       	rjmp	80007b0a <_realloc_r+0x14a>
80007afe:	50 08       	stdsp	sp[0x0],r8
80007b00:	08 9b       	mov	r11,r4
80007b02:	0a 9c       	mov	r12,r5
80007b04:	e0 a0 1d 8f 	rcall	8000b622 <memmove>
80007b08:	40 08       	lddsp	r8,sp[0x0]
80007b0a:	ee 06 00 09 	add	r9,r7,r6
80007b0e:	0c 13       	sub	r3,r6
80007b10:	a1 a3       	sbr	r3,0x0
80007b12:	93 13       	st.w	r9[0x4],r3
80007b14:	91 29       	st.w	r8[0x8],r9
80007b16:	04 9c       	mov	r12,r2
80007b18:	6e 18       	ld.w	r8,r7[0x4]
80007b1a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b1e:	10 46       	or	r6,r8
80007b20:	8f 16       	st.w	r7[0x4],r6
80007b22:	ca a8       	rjmp	80007c76 <_realloc_r+0x2b6>
80007b24:	14 03       	add	r3,r10
80007b26:	0c 33       	cp.w	r3,r6
80007b28:	c0 85       	brlt	80007b38 <_realloc_r+0x178>
80007b2a:	72 28       	ld.w	r8,r9[0x8]
80007b2c:	72 39       	ld.w	r9,r9[0xc]
80007b2e:	93 28       	st.w	r9[0x8],r8
80007b30:	91 39       	st.w	r8[0xc],r9
80007b32:	6e 28       	ld.w	r8,r7[0x8]
80007b34:	6e 39       	ld.w	r9,r7[0xc]
80007b36:	c0 78       	rjmp	80007b44 <_realloc_r+0x184>
80007b38:	f8 00 00 03 	add	r3,r12,r0
80007b3c:	0c 33       	cp.w	r3,r6
80007b3e:	c3 35       	brlt	80007ba4 <_realloc_r+0x1e4>
80007b40:	6e 39       	ld.w	r9,r7[0xc]
80007b42:	6e 28       	ld.w	r8,r7[0x8]
80007b44:	93 28       	st.w	r9[0x8],r8
80007b46:	91 39       	st.w	r8[0xc],r9
80007b48:	e0 ca 00 04 	sub	r10,r0,4
80007b4c:	ee cc ff f8 	sub	r12,r7,-8
80007b50:	e0 4a 00 24 	cp.w	r10,36
80007b54:	e0 8b 00 24 	brhi	80007b9c <_realloc_r+0x1dc>
80007b58:	59 3a       	cp.w	r10,19
80007b5a:	e0 88 00 1a 	brls	80007b8e <_realloc_r+0x1ce>
80007b5e:	09 08       	ld.w	r8,r4++
80007b60:	99 08       	st.w	r12[0x0],r8
80007b62:	09 08       	ld.w	r8,r4++
80007b64:	8f 38       	st.w	r7[0xc],r8
80007b66:	ee cc ff f0 	sub	r12,r7,-16
80007b6a:	59 ba       	cp.w	r10,27
80007b6c:	e0 88 00 11 	brls	80007b8e <_realloc_r+0x1ce>
80007b70:	09 08       	ld.w	r8,r4++
80007b72:	99 08       	st.w	r12[0x0],r8
80007b74:	09 08       	ld.w	r8,r4++
80007b76:	8f 58       	st.w	r7[0x14],r8
80007b78:	ee cc ff e8 	sub	r12,r7,-24
80007b7c:	e0 4a 00 24 	cp.w	r10,36
80007b80:	c0 71       	brne	80007b8e <_realloc_r+0x1ce>
80007b82:	09 08       	ld.w	r8,r4++
80007b84:	99 08       	st.w	r12[0x0],r8
80007b86:	ee cc ff e0 	sub	r12,r7,-32
80007b8a:	09 08       	ld.w	r8,r4++
80007b8c:	8f 78       	st.w	r7[0x1c],r8
80007b8e:	09 08       	ld.w	r8,r4++
80007b90:	18 a8       	st.w	r12++,r8
80007b92:	68 08       	ld.w	r8,r4[0x0]
80007b94:	99 08       	st.w	r12[0x0],r8
80007b96:	68 18       	ld.w	r8,r4[0x4]
80007b98:	99 18       	st.w	r12[0x4],r8
80007b9a:	c4 78       	rjmp	80007c28 <_realloc_r+0x268>
80007b9c:	08 9b       	mov	r11,r4
80007b9e:	e0 a0 1d 42 	rcall	8000b622 <memmove>
80007ba2:	c4 38       	rjmp	80007c28 <_realloc_r+0x268>
80007ba4:	04 9c       	mov	r12,r2
80007ba6:	fe b0 fc 45 	rcall	80007430 <_malloc_r>
80007baa:	18 95       	mov	r5,r12
80007bac:	c3 a0       	breq	80007c20 <_realloc_r+0x260>
80007bae:	62 18       	ld.w	r8,r1[0x4]
80007bb0:	f8 c9 00 08 	sub	r9,r12,8
80007bb4:	a1 c8       	cbr	r8,0x0
80007bb6:	e2 08 00 08 	add	r8,r1,r8
80007bba:	10 39       	cp.w	r9,r8
80007bbc:	c0 71       	brne	80007bca <_realloc_r+0x20a>
80007bbe:	72 13       	ld.w	r3,r9[0x4]
80007bc0:	02 97       	mov	r7,r1
80007bc2:	e0 13 ff fc 	andl	r3,0xfffc
80007bc6:	00 03       	add	r3,r0
80007bc8:	c3 08       	rjmp	80007c28 <_realloc_r+0x268>
80007bca:	e0 ca 00 04 	sub	r10,r0,4
80007bce:	e0 4a 00 24 	cp.w	r10,36
80007bd2:	e0 8b 00 20 	brhi	80007c12 <_realloc_r+0x252>
80007bd6:	08 99       	mov	r9,r4
80007bd8:	18 98       	mov	r8,r12
80007bda:	59 3a       	cp.w	r10,19
80007bdc:	e0 88 00 14 	brls	80007c04 <_realloc_r+0x244>
80007be0:	13 0b       	ld.w	r11,r9++
80007be2:	10 ab       	st.w	r8++,r11
80007be4:	13 0b       	ld.w	r11,r9++
80007be6:	10 ab       	st.w	r8++,r11
80007be8:	59 ba       	cp.w	r10,27
80007bea:	e0 88 00 0d 	brls	80007c04 <_realloc_r+0x244>
80007bee:	13 0b       	ld.w	r11,r9++
80007bf0:	10 ab       	st.w	r8++,r11
80007bf2:	13 0b       	ld.w	r11,r9++
80007bf4:	10 ab       	st.w	r8++,r11
80007bf6:	e0 4a 00 24 	cp.w	r10,36
80007bfa:	c0 51       	brne	80007c04 <_realloc_r+0x244>
80007bfc:	13 0a       	ld.w	r10,r9++
80007bfe:	10 aa       	st.w	r8++,r10
80007c00:	13 0a       	ld.w	r10,r9++
80007c02:	10 aa       	st.w	r8++,r10
80007c04:	13 0a       	ld.w	r10,r9++
80007c06:	10 aa       	st.w	r8++,r10
80007c08:	72 0a       	ld.w	r10,r9[0x0]
80007c0a:	91 0a       	st.w	r8[0x0],r10
80007c0c:	72 19       	ld.w	r9,r9[0x4]
80007c0e:	91 19       	st.w	r8[0x4],r9
80007c10:	c0 48       	rjmp	80007c18 <_realloc_r+0x258>
80007c12:	08 9b       	mov	r11,r4
80007c14:	e0 a0 1d 07 	rcall	8000b622 <memmove>
80007c18:	08 9b       	mov	r11,r4
80007c1a:	04 9c       	mov	r12,r2
80007c1c:	e0 a0 1a 60 	rcall	8000b0dc <_free_r>
80007c20:	04 9c       	mov	r12,r2
80007c22:	c2 a8       	rjmp	80007c76 <_realloc_r+0x2b6>
80007c24:	00 93       	mov	r3,r0
80007c26:	02 97       	mov	r7,r1
80007c28:	e6 06 01 09 	sub	r9,r3,r6
80007c2c:	6e 18       	ld.w	r8,r7[0x4]
80007c2e:	58 f9       	cp.w	r9,15
80007c30:	e0 88 00 16 	brls	80007c5c <_realloc_r+0x29c>
80007c34:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c38:	ed e8 10 08 	or	r8,r6,r8
80007c3c:	8f 18       	st.w	r7[0x4],r8
80007c3e:	12 98       	mov	r8,r9
80007c40:	a1 a8       	sbr	r8,0x0
80007c42:	ee 06 00 0b 	add	r11,r7,r6
80007c46:	f6 09 00 09 	add	r9,r11,r9
80007c4a:	97 18       	st.w	r11[0x4],r8
80007c4c:	72 18       	ld.w	r8,r9[0x4]
80007c4e:	a1 a8       	sbr	r8,0x0
80007c50:	2f 8b       	sub	r11,-8
80007c52:	93 18       	st.w	r9[0x4],r8
80007c54:	04 9c       	mov	r12,r2
80007c56:	e0 a0 1a 43 	rcall	8000b0dc <_free_r>
80007c5a:	c0 b8       	rjmp	80007c70 <_realloc_r+0x2b0>
80007c5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c60:	e7 e8 10 08 	or	r8,r3,r8
80007c64:	8f 18       	st.w	r7[0x4],r8
80007c66:	ee 03 00 03 	add	r3,r7,r3
80007c6a:	66 18       	ld.w	r8,r3[0x4]
80007c6c:	a1 a8       	sbr	r8,0x0
80007c6e:	87 18       	st.w	r3[0x4],r8
80007c70:	04 9c       	mov	r12,r2
80007c72:	ee c5 ff f8 	sub	r5,r7,-8
80007c76:	fe b0 f1 99 	rcall	80005fa8 <__malloc_unlock>
80007c7a:	0a 9c       	mov	r12,r5
80007c7c:	2f fd       	sub	sp,-4
80007c7e:	d8 32       	popm	r0-r7,pc

80007c80 <_sbrk_r>:
80007c80:	d4 21       	pushm	r4-r7,lr
80007c82:	30 08       	mov	r8,0
80007c84:	18 97       	mov	r7,r12
80007c86:	e0 66 53 c8 	mov	r6,21448
80007c8a:	16 9c       	mov	r12,r11
80007c8c:	8d 08       	st.w	r6[0x0],r8
80007c8e:	c8 5c       	rcall	80007d98 <_sbrk>
80007c90:	5b fc       	cp.w	r12,-1
80007c92:	c0 51       	brne	80007c9c <_sbrk_r+0x1c>
80007c94:	6c 08       	ld.w	r8,r6[0x0]
80007c96:	58 08       	cp.w	r8,0
80007c98:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007c9c:	d8 22       	popm	r4-r7,pc
80007c9e:	d7 03       	nop

80007ca0 <sprintf>:
80007ca0:	d4 01       	pushm	lr
80007ca2:	21 7d       	sub	sp,92
80007ca4:	e0 68 ff ff 	mov	r8,65535
80007ca8:	ea 18 7f ff 	orh	r8,0x7fff
80007cac:	50 58       	stdsp	sp[0x14],r8
80007cae:	50 28       	stdsp	sp[0x8],r8
80007cb0:	e0 68 02 08 	mov	r8,520
80007cb4:	ba 68       	st.h	sp[0xc],r8
80007cb6:	3f f8       	mov	r8,-1
80007cb8:	ba 78       	st.h	sp[0xe],r8
80007cba:	e0 68 0a 40 	mov	r8,2624
80007cbe:	50 4c       	stdsp	sp[0x10],r12
80007cc0:	16 9a       	mov	r10,r11
80007cc2:	50 0c       	stdsp	sp[0x0],r12
80007cc4:	fa c9 ff a0 	sub	r9,sp,-96
80007cc8:	70 0c       	ld.w	r12,r8[0x0]
80007cca:	1a 9b       	mov	r11,sp
80007ccc:	e0 a0 02 1a 	rcall	80008100 <_vfprintf_r>
80007cd0:	30 09       	mov	r9,0
80007cd2:	40 08       	lddsp	r8,sp[0x0]
80007cd4:	b0 89       	st.b	r8[0x0],r9
80007cd6:	2e 9d       	sub	sp,-92
80007cd8:	d8 02       	popm	pc
80007cda:	d7 03       	nop

80007cdc <strncpy>:
80007cdc:	30 08       	mov	r8,0
80007cde:	10 3a       	cp.w	r10,r8
80007ce0:	5e 0c       	reteq	r12
80007ce2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007ce6:	f8 08 0b 09 	st.b	r12[r8],r9
80007cea:	2f f8       	sub	r8,-1
80007cec:	58 09       	cp.w	r9,0
80007cee:	cf 81       	brne	80007cde <strncpy+0x2>
80007cf0:	10 3a       	cp.w	r10,r8
80007cf2:	5e 0c       	reteq	r12
80007cf4:	f8 08 0b 09 	st.b	r12[r8],r9
80007cf8:	2f f8       	sub	r8,-1
80007cfa:	cf bb       	rjmp	80007cf0 <strncpy+0x14>

80007cfc <_close>:
80007cfc:	30 28       	mov	r8,2
80007cfe:	d6 73       	breakpoint
80007d00:	3f fc       	mov	r12,-1
80007d02:	35 8b       	mov	r11,88
80007d04:	58 0c       	cp.w	r12,0
80007d06:	5e 4c       	retge	r12
80007d08:	e0 6a 53 c8 	mov	r10,21448
80007d0c:	95 0b       	st.w	r10[0x0],r11
80007d0e:	5e fc       	retal	r12

80007d10 <_lseek>:
80007d10:	30 58       	mov	r8,5
80007d12:	d6 73       	breakpoint
80007d14:	3f fc       	mov	r12,-1
80007d16:	35 8b       	mov	r11,88
80007d18:	58 0c       	cp.w	r12,0
80007d1a:	5e 4c       	retge	r12
80007d1c:	e0 6a 53 c8 	mov	r10,21448
80007d20:	95 0b       	st.w	r10[0x0],r11
80007d22:	5e fc       	retal	r12

80007d24 <isatty>:
80007d24:	30 b8       	mov	r8,11
80007d26:	d6 73       	breakpoint
80007d28:	3f fc       	mov	r12,-1
80007d2a:	35 8b       	mov	r11,88
80007d2c:	58 0c       	cp.w	r12,0
80007d2e:	5e 4c       	retge	r12
80007d30:	e0 6a 53 c8 	mov	r10,21448
80007d34:	95 0b       	st.w	r10[0x0],r11
80007d36:	5e fc       	retal	r12

80007d38 <_fstat_host>:
80007d38:	30 98       	mov	r8,9
80007d3a:	d6 73       	breakpoint
80007d3c:	3f fc       	mov	r12,-1
80007d3e:	35 8b       	mov	r11,88
80007d40:	58 0c       	cp.w	r12,0
80007d42:	5e 4c       	retge	r12
80007d44:	e0 6a 53 c8 	mov	r10,21448
80007d48:	95 0b       	st.w	r10[0x0],r11
80007d4a:	5e fc       	retal	r12

80007d4c <_fstat>:
80007d4c:	d4 21       	pushm	r4-r7,lr
80007d4e:	21 0d       	sub	sp,64
80007d50:	16 97       	mov	r7,r11
80007d52:	1a 9b       	mov	r11,sp
80007d54:	cf 2f       	rcall	80007d38 <_fstat_host>
80007d56:	c0 34       	brge	80007d5c <_fstat+0x10>
80007d58:	3f fc       	mov	r12,-1
80007d5a:	c1 c8       	rjmp	80007d92 <_fstat+0x46>
80007d5c:	40 08       	lddsp	r8,sp[0x0]
80007d5e:	ae 08       	st.h	r7[0x0],r8
80007d60:	40 18       	lddsp	r8,sp[0x4]
80007d62:	ae 18       	st.h	r7[0x2],r8
80007d64:	40 28       	lddsp	r8,sp[0x8]
80007d66:	8f 18       	st.w	r7[0x4],r8
80007d68:	40 38       	lddsp	r8,sp[0xc]
80007d6a:	ae 48       	st.h	r7[0x8],r8
80007d6c:	40 48       	lddsp	r8,sp[0x10]
80007d6e:	ae 58       	st.h	r7[0xa],r8
80007d70:	40 58       	lddsp	r8,sp[0x14]
80007d72:	ae 68       	st.h	r7[0xc],r8
80007d74:	40 68       	lddsp	r8,sp[0x18]
80007d76:	ae 78       	st.h	r7[0xe],r8
80007d78:	40 88       	lddsp	r8,sp[0x20]
80007d7a:	8f 48       	st.w	r7[0x10],r8
80007d7c:	40 a8       	lddsp	r8,sp[0x28]
80007d7e:	8f b8       	st.w	r7[0x2c],r8
80007d80:	40 c8       	lddsp	r8,sp[0x30]
80007d82:	8f c8       	st.w	r7[0x30],r8
80007d84:	40 d8       	lddsp	r8,sp[0x34]
80007d86:	8f 58       	st.w	r7[0x14],r8
80007d88:	40 e8       	lddsp	r8,sp[0x38]
80007d8a:	30 0c       	mov	r12,0
80007d8c:	8f 78       	st.w	r7[0x1c],r8
80007d8e:	40 f8       	lddsp	r8,sp[0x3c]
80007d90:	8f 98       	st.w	r7[0x24],r8
80007d92:	2f 0d       	sub	sp,-64
80007d94:	d8 22       	popm	r4-r7,pc
80007d96:	d7 03       	nop

80007d98 <_sbrk>:
80007d98:	d4 01       	pushm	lr
80007d9a:	e0 68 0d 94 	mov	r8,3476
80007d9e:	70 09       	ld.w	r9,r8[0x0]
80007da0:	58 09       	cp.w	r9,0
80007da2:	c0 41       	brne	80007daa <_sbrk+0x12>
80007da4:	e0 69 53 d0 	mov	r9,21456
80007da8:	91 09       	st.w	r8[0x0],r9
80007daa:	e0 69 0d 94 	mov	r9,3476
80007dae:	e0 7a 70 00 	mov	r10,94208
80007db2:	72 08       	ld.w	r8,r9[0x0]
80007db4:	f0 0c 00 0c 	add	r12,r8,r12
80007db8:	14 3c       	cp.w	r12,r10
80007dba:	e0 8b 00 04 	brhi	80007dc2 <_sbrk+0x2a>
80007dbe:	93 0c       	st.w	r9[0x0],r12
80007dc0:	c0 68       	rjmp	80007dcc <_sbrk+0x34>
80007dc2:	e0 a0 18 15 	rcall	8000adec <__errno>
80007dc6:	30 c8       	mov	r8,12
80007dc8:	99 08       	st.w	r12[0x0],r8
80007dca:	3f f8       	mov	r8,-1
80007dcc:	10 9c       	mov	r12,r8
80007dce:	d8 02       	popm	pc

80007dd0 <get_arg>:
80007dd0:	d4 31       	pushm	r0-r7,lr
80007dd2:	20 8d       	sub	sp,32
80007dd4:	fa c4 ff bc 	sub	r4,sp,-68
80007dd8:	50 4b       	stdsp	sp[0x10],r11
80007dda:	68 2e       	ld.w	lr,r4[0x8]
80007ddc:	50 58       	stdsp	sp[0x14],r8
80007dde:	12 96       	mov	r6,r9
80007de0:	7c 0b       	ld.w	r11,lr[0x0]
80007de2:	70 05       	ld.w	r5,r8[0x0]
80007de4:	50 6e       	stdsp	sp[0x18],lr
80007de6:	58 0b       	cp.w	r11,0
80007de8:	f4 0b 17 00 	moveq	r11,r10
80007dec:	68 03       	ld.w	r3,r4[0x0]
80007dee:	68 11       	ld.w	r1,r4[0x4]
80007df0:	40 49       	lddsp	r9,sp[0x10]
80007df2:	30 08       	mov	r8,0
80007df4:	c2 89       	rjmp	80008044 <get_arg+0x274>
80007df6:	2f fb       	sub	r11,-1
80007df8:	32 5c       	mov	r12,37
80007dfa:	17 8a       	ld.ub	r10,r11[0x0]
80007dfc:	f8 0a 18 00 	cp.b	r10,r12
80007e00:	5f 1e       	srne	lr
80007e02:	f0 0a 18 00 	cp.b	r10,r8
80007e06:	5f 1c       	srne	r12
80007e08:	fd ec 00 0c 	and	r12,lr,r12
80007e0c:	f0 0c 18 00 	cp.b	r12,r8
80007e10:	cf 31       	brne	80007df6 <get_arg+0x26>
80007e12:	58 0a       	cp.w	r10,0
80007e14:	e0 80 01 25 	breq	8000805e <get_arg+0x28e>
80007e18:	30 0c       	mov	r12,0
80007e1a:	3f fa       	mov	r10,-1
80007e1c:	18 90       	mov	r0,r12
80007e1e:	50 3a       	stdsp	sp[0xc],r10
80007e20:	18 94       	mov	r4,r12
80007e22:	18 92       	mov	r2,r12
80007e24:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007e28:	16 97       	mov	r7,r11
80007e2a:	50 7c       	stdsp	sp[0x1c],r12
80007e2c:	fe cc 9e 24 	sub	r12,pc,-25052
80007e30:	0f 3a       	ld.ub	r10,r7++
80007e32:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007e36:	40 7c       	lddsp	r12,sp[0x1c]
80007e38:	1c 0c       	add	r12,lr
80007e3a:	fe ce 9e fa 	sub	lr,pc,-24838
80007e3e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007e42:	20 1e       	sub	lr,1
80007e44:	50 0e       	stdsp	sp[0x0],lr
80007e46:	fe ce 9f 72 	sub	lr,pc,-24718
80007e4a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007e4e:	50 7c       	stdsp	sp[0x1c],r12
80007e50:	40 0c       	lddsp	r12,sp[0x0]
80007e52:	58 7c       	cp.w	r12,7
80007e54:	e0 8b 00 f1 	brhi	80008036 <get_arg+0x266>
80007e58:	fe ce a1 24 	sub	lr,pc,-24284
80007e5c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007e60:	36 8b       	mov	r11,104
80007e62:	f6 0a 18 00 	cp.b	r10,r11
80007e66:	e0 80 00 e8 	breq	80008036 <get_arg+0x266>
80007e6a:	37 1b       	mov	r11,113
80007e6c:	f6 0a 18 00 	cp.b	r10,r11
80007e70:	c0 70       	breq	80007e7e <get_arg+0xae>
80007e72:	34 cb       	mov	r11,76
80007e74:	f6 0a 18 00 	cp.b	r10,r11
80007e78:	c0 51       	brne	80007e82 <get_arg+0xb2>
80007e7a:	a3 b4       	sbr	r4,0x3
80007e7c:	cd d8       	rjmp	80008036 <get_arg+0x266>
80007e7e:	a5 b4       	sbr	r4,0x5
80007e80:	cd b8       	rjmp	80008036 <get_arg+0x266>
80007e82:	08 9a       	mov	r10,r4
80007e84:	0e 9b       	mov	r11,r7
80007e86:	a5 aa       	sbr	r10,0x4
80007e88:	17 3c       	ld.ub	r12,r11++
80007e8a:	a5 b4       	sbr	r4,0x5
80007e8c:	36 ce       	mov	lr,108
80007e8e:	fc 0c 18 00 	cp.b	r12,lr
80007e92:	e0 80 00 d3 	breq	80008038 <get_arg+0x268>
80007e96:	14 94       	mov	r4,r10
80007e98:	cc f8       	rjmp	80008036 <get_arg+0x266>
80007e9a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007e9e:	36 7c       	mov	r12,103
80007ea0:	f8 0a 18 00 	cp.b	r10,r12
80007ea4:	e0 8b 00 27 	brhi	80007ef2 <get_arg+0x122>
80007ea8:	36 5b       	mov	r11,101
80007eaa:	f6 0a 18 00 	cp.b	r10,r11
80007eae:	c4 82       	brcc	80007f3e <get_arg+0x16e>
80007eb0:	34 fb       	mov	r11,79
80007eb2:	f6 0a 18 00 	cp.b	r10,r11
80007eb6:	c4 80       	breq	80007f46 <get_arg+0x176>
80007eb8:	e0 8b 00 0c 	brhi	80007ed0 <get_arg+0x100>
80007ebc:	34 5b       	mov	r11,69
80007ebe:	f6 0a 18 00 	cp.b	r10,r11
80007ec2:	c3 e0       	breq	80007f3e <get_arg+0x16e>
80007ec4:	34 7b       	mov	r11,71
80007ec6:	f6 0a 18 00 	cp.b	r10,r11
80007eca:	c3 a0       	breq	80007f3e <get_arg+0x16e>
80007ecc:	34 4b       	mov	r11,68
80007ece:	c0 88       	rjmp	80007ede <get_arg+0x10e>
80007ed0:	35 8b       	mov	r11,88
80007ed2:	f6 0a 18 00 	cp.b	r10,r11
80007ed6:	c2 c0       	breq	80007f2e <get_arg+0x15e>
80007ed8:	e0 8b 00 07 	brhi	80007ee6 <get_arg+0x116>
80007edc:	35 5b       	mov	r11,85
80007ede:	f6 0a 18 00 	cp.b	r10,r11
80007ee2:	c3 51       	brne	80007f4c <get_arg+0x17c>
80007ee4:	c3 18       	rjmp	80007f46 <get_arg+0x176>
80007ee6:	36 3b       	mov	r11,99
80007ee8:	f6 0a 18 00 	cp.b	r10,r11
80007eec:	c2 f0       	breq	80007f4a <get_arg+0x17a>
80007eee:	36 4b       	mov	r11,100
80007ef0:	c0 e8       	rjmp	80007f0c <get_arg+0x13c>
80007ef2:	37 0b       	mov	r11,112
80007ef4:	f6 0a 18 00 	cp.b	r10,r11
80007ef8:	c2 50       	breq	80007f42 <get_arg+0x172>
80007efa:	e0 8b 00 0d 	brhi	80007f14 <get_arg+0x144>
80007efe:	36 eb       	mov	r11,110
80007f00:	f6 0a 18 00 	cp.b	r10,r11
80007f04:	c1 f0       	breq	80007f42 <get_arg+0x172>
80007f06:	e0 8b 00 14 	brhi	80007f2e <get_arg+0x15e>
80007f0a:	36 9b       	mov	r11,105
80007f0c:	f6 0a 18 00 	cp.b	r10,r11
80007f10:	c1 e1       	brne	80007f4c <get_arg+0x17c>
80007f12:	c0 e8       	rjmp	80007f2e <get_arg+0x15e>
80007f14:	37 5b       	mov	r11,117
80007f16:	f6 0a 18 00 	cp.b	r10,r11
80007f1a:	c0 a0       	breq	80007f2e <get_arg+0x15e>
80007f1c:	37 8b       	mov	r11,120
80007f1e:	f6 0a 18 00 	cp.b	r10,r11
80007f22:	c0 60       	breq	80007f2e <get_arg+0x15e>
80007f24:	37 3b       	mov	r11,115
80007f26:	f6 0a 18 00 	cp.b	r10,r11
80007f2a:	c1 11       	brne	80007f4c <get_arg+0x17c>
80007f2c:	c0 b8       	rjmp	80007f42 <get_arg+0x172>
80007f2e:	ed b4 00 04 	bld	r4,0x4
80007f32:	c0 a0       	breq	80007f46 <get_arg+0x176>
80007f34:	ed b4 00 05 	bld	r4,0x5
80007f38:	c0 91       	brne	80007f4a <get_arg+0x17a>
80007f3a:	30 20       	mov	r0,2
80007f3c:	c0 88       	rjmp	80007f4c <get_arg+0x17c>
80007f3e:	30 40       	mov	r0,4
80007f40:	c0 68       	rjmp	80007f4c <get_arg+0x17c>
80007f42:	30 30       	mov	r0,3
80007f44:	c0 48       	rjmp	80007f4c <get_arg+0x17c>
80007f46:	30 10       	mov	r0,1
80007f48:	c0 28       	rjmp	80007f4c <get_arg+0x17c>
80007f4a:	30 00       	mov	r0,0
80007f4c:	40 3b       	lddsp	r11,sp[0xc]
80007f4e:	5b fb       	cp.w	r11,-1
80007f50:	c0 40       	breq	80007f58 <get_arg+0x188>
80007f52:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007f56:	c7 08       	rjmp	80008036 <get_arg+0x266>
80007f58:	58 60       	cp.w	r0,6
80007f5a:	e0 8b 00 6e 	brhi	80008036 <get_arg+0x266>
80007f5e:	6c 0a       	ld.w	r10,r6[0x0]
80007f60:	ea cc ff ff 	sub	r12,r5,-1
80007f64:	fe ce a2 10 	sub	lr,pc,-24048
80007f68:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007f6c:	f4 cb ff f8 	sub	r11,r10,-8
80007f70:	8d 0b       	st.w	r6[0x0],r11
80007f72:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f76:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f7a:	c0 f8       	rjmp	80007f98 <get_arg+0x1c8>
80007f7c:	f4 cb ff fc 	sub	r11,r10,-4
80007f80:	8d 0b       	st.w	r6[0x0],r11
80007f82:	74 0a       	ld.w	r10,r10[0x0]
80007f84:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f88:	c0 88       	rjmp	80007f98 <get_arg+0x1c8>
80007f8a:	f4 cb ff f8 	sub	r11,r10,-8
80007f8e:	8d 0b       	st.w	r6[0x0],r11
80007f90:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f94:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f98:	0e 9b       	mov	r11,r7
80007f9a:	18 95       	mov	r5,r12
80007f9c:	c4 e8       	rjmp	80008038 <get_arg+0x268>
80007f9e:	62 0a       	ld.w	r10,r1[0x0]
80007fa0:	5b fa       	cp.w	r10,-1
80007fa2:	c0 b1       	brne	80007fb8 <get_arg+0x1e8>
80007fa4:	50 19       	stdsp	sp[0x4],r9
80007fa6:	50 28       	stdsp	sp[0x8],r8
80007fa8:	e0 6a 00 80 	mov	r10,128
80007fac:	30 0b       	mov	r11,0
80007fae:	02 9c       	mov	r12,r1
80007fb0:	fe b0 fd 00 	rcall	800079b0 <memset>
80007fb4:	40 28       	lddsp	r8,sp[0x8]
80007fb6:	40 19       	lddsp	r9,sp[0x4]
80007fb8:	e4 cc 00 01 	sub	r12,r2,1
80007fbc:	0e 9b       	mov	r11,r7
80007fbe:	50 3c       	stdsp	sp[0xc],r12
80007fc0:	f2 0c 0c 49 	max	r9,r9,r12
80007fc4:	c3 a8       	rjmp	80008038 <get_arg+0x268>
80007fc6:	62 0a       	ld.w	r10,r1[0x0]
80007fc8:	5b fa       	cp.w	r10,-1
80007fca:	c0 b1       	brne	80007fe0 <get_arg+0x210>
80007fcc:	50 19       	stdsp	sp[0x4],r9
80007fce:	50 28       	stdsp	sp[0x8],r8
80007fd0:	e0 6a 00 80 	mov	r10,128
80007fd4:	30 0b       	mov	r11,0
80007fd6:	02 9c       	mov	r12,r1
80007fd8:	fe b0 fc ec 	rcall	800079b0 <memset>
80007fdc:	40 28       	lddsp	r8,sp[0x8]
80007fde:	40 19       	lddsp	r9,sp[0x4]
80007fe0:	20 12       	sub	r2,1
80007fe2:	30 0a       	mov	r10,0
80007fe4:	0e 9b       	mov	r11,r7
80007fe6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007fea:	f2 02 0c 49 	max	r9,r9,r2
80007fee:	c2 58       	rjmp	80008038 <get_arg+0x268>
80007ff0:	16 97       	mov	r7,r11
80007ff2:	6c 0a       	ld.w	r10,r6[0x0]
80007ff4:	f4 cb ff fc 	sub	r11,r10,-4
80007ff8:	8d 0b       	st.w	r6[0x0],r11
80007ffa:	74 0a       	ld.w	r10,r10[0x0]
80007ffc:	0e 9b       	mov	r11,r7
80007ffe:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008002:	2f f5       	sub	r5,-1
80008004:	c1 a8       	rjmp	80008038 <get_arg+0x268>
80008006:	f4 c2 00 30 	sub	r2,r10,48
8000800a:	c0 68       	rjmp	80008016 <get_arg+0x246>
8000800c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008010:	2f f7       	sub	r7,-1
80008012:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008016:	0f 8a       	ld.ub	r10,r7[0x0]
80008018:	58 0a       	cp.w	r10,0
8000801a:	c0 e0       	breq	80008036 <get_arg+0x266>
8000801c:	23 0a       	sub	r10,48
8000801e:	58 9a       	cp.w	r10,9
80008020:	fe 98 ff f6 	brls	8000800c <get_arg+0x23c>
80008024:	c0 98       	rjmp	80008036 <get_arg+0x266>
80008026:	2f f7       	sub	r7,-1
80008028:	0f 8a       	ld.ub	r10,r7[0x0]
8000802a:	58 0a       	cp.w	r10,0
8000802c:	c0 50       	breq	80008036 <get_arg+0x266>
8000802e:	23 0a       	sub	r10,48
80008030:	58 9a       	cp.w	r10,9
80008032:	fe 98 ff fa 	brls	80008026 <get_arg+0x256>
80008036:	0e 9b       	mov	r11,r7
80008038:	40 7c       	lddsp	r12,sp[0x1c]
8000803a:	30 ba       	mov	r10,11
8000803c:	f4 0c 18 00 	cp.b	r12,r10
80008040:	fe 91 fe f2 	brne	80007e24 <get_arg+0x54>
80008044:	40 42       	lddsp	r2,sp[0x10]
80008046:	17 8c       	ld.ub	r12,r11[0x0]
80008048:	0a 32       	cp.w	r2,r5
8000804a:	5f 4a       	srge	r10
8000804c:	f0 0c 18 00 	cp.b	r12,r8
80008050:	5f 1c       	srne	r12
80008052:	f9 ea 00 0a 	and	r10,r12,r10
80008056:	f0 0a 18 00 	cp.b	r10,r8
8000805a:	fe 91 fe cf 	brne	80007df8 <get_arg+0x28>
8000805e:	30 08       	mov	r8,0
80008060:	40 4e       	lddsp	lr,sp[0x10]
80008062:	17 8a       	ld.ub	r10,r11[0x0]
80008064:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008068:	f0 0a 18 00 	cp.b	r10,r8
8000806c:	fc 09 17 10 	movne	r9,lr
80008070:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008074:	06 9e       	mov	lr,r3
80008076:	c2 a8       	rjmp	800080ca <get_arg+0x2fa>
80008078:	62 0a       	ld.w	r10,r1[0x0]
8000807a:	58 3a       	cp.w	r10,3
8000807c:	c1 e0       	breq	800080b8 <get_arg+0x2e8>
8000807e:	e0 89 00 07 	brgt	8000808c <get_arg+0x2bc>
80008082:	58 1a       	cp.w	r10,1
80008084:	c1 a0       	breq	800080b8 <get_arg+0x2e8>
80008086:	58 2a       	cp.w	r10,2
80008088:	c1 81       	brne	800080b8 <get_arg+0x2e8>
8000808a:	c0 58       	rjmp	80008094 <get_arg+0x2c4>
8000808c:	58 5a       	cp.w	r10,5
8000808e:	c0 c0       	breq	800080a6 <get_arg+0x2d6>
80008090:	c0 b5       	brlt	800080a6 <get_arg+0x2d6>
80008092:	c1 38       	rjmp	800080b8 <get_arg+0x2e8>
80008094:	6c 0a       	ld.w	r10,r6[0x0]
80008096:	f4 cc ff f8 	sub	r12,r10,-8
8000809a:	8d 0c       	st.w	r6[0x0],r12
8000809c:	f4 e2 00 00 	ld.d	r2,r10[0]
800080a0:	f0 e3 00 00 	st.d	r8[0],r2
800080a4:	c1 08       	rjmp	800080c4 <get_arg+0x2f4>
800080a6:	6c 0a       	ld.w	r10,r6[0x0]
800080a8:	f4 cc ff f8 	sub	r12,r10,-8
800080ac:	8d 0c       	st.w	r6[0x0],r12
800080ae:	f4 e2 00 00 	ld.d	r2,r10[0]
800080b2:	f0 e3 00 00 	st.d	r8[0],r2
800080b6:	c0 78       	rjmp	800080c4 <get_arg+0x2f4>
800080b8:	6c 0a       	ld.w	r10,r6[0x0]
800080ba:	f4 cc ff fc 	sub	r12,r10,-4
800080be:	8d 0c       	st.w	r6[0x0],r12
800080c0:	74 0a       	ld.w	r10,r10[0x0]
800080c2:	91 0a       	st.w	r8[0x0],r10
800080c4:	2f f5       	sub	r5,-1
800080c6:	2f 88       	sub	r8,-8
800080c8:	2f c1       	sub	r1,-4
800080ca:	12 35       	cp.w	r5,r9
800080cc:	fe 9a ff d6 	brle	80008078 <get_arg+0x2a8>
800080d0:	1c 93       	mov	r3,lr
800080d2:	40 52       	lddsp	r2,sp[0x14]
800080d4:	40 6e       	lddsp	lr,sp[0x18]
800080d6:	85 05       	st.w	r2[0x0],r5
800080d8:	9d 0b       	st.w	lr[0x0],r11
800080da:	40 4b       	lddsp	r11,sp[0x10]
800080dc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800080e0:	2f 8d       	sub	sp,-32
800080e2:	d8 32       	popm	r0-r7,pc

800080e4 <__sprint_r>:
800080e4:	d4 21       	pushm	r4-r7,lr
800080e6:	14 97       	mov	r7,r10
800080e8:	74 28       	ld.w	r8,r10[0x8]
800080ea:	58 08       	cp.w	r8,0
800080ec:	c0 41       	brne	800080f4 <__sprint_r+0x10>
800080ee:	95 18       	st.w	r10[0x4],r8
800080f0:	10 9c       	mov	r12,r8
800080f2:	d8 22       	popm	r4-r7,pc
800080f4:	e0 a0 18 ba 	rcall	8000b268 <__sfvwrite_r>
800080f8:	30 08       	mov	r8,0
800080fa:	8f 18       	st.w	r7[0x4],r8
800080fc:	8f 28       	st.w	r7[0x8],r8
800080fe:	d8 22       	popm	r4-r7,pc

80008100 <_vfprintf_r>:
80008100:	d4 31       	pushm	r0-r7,lr
80008102:	fa cd 06 bc 	sub	sp,sp,1724
80008106:	51 09       	stdsp	sp[0x40],r9
80008108:	16 91       	mov	r1,r11
8000810a:	14 97       	mov	r7,r10
8000810c:	18 95       	mov	r5,r12
8000810e:	e0 a0 1a 1d 	rcall	8000b548 <_localeconv_r>
80008112:	78 0c       	ld.w	r12,r12[0x0]
80008114:	50 cc       	stdsp	sp[0x30],r12
80008116:	58 05       	cp.w	r5,0
80008118:	c0 70       	breq	80008126 <_vfprintf_r+0x26>
8000811a:	6a 68       	ld.w	r8,r5[0x18]
8000811c:	58 08       	cp.w	r8,0
8000811e:	c0 41       	brne	80008126 <_vfprintf_r+0x26>
80008120:	0a 9c       	mov	r12,r5
80008122:	e0 a0 17 43 	rcall	8000afa8 <__sinit>
80008126:	fe c8 a0 0e 	sub	r8,pc,-24562
8000812a:	10 31       	cp.w	r1,r8
8000812c:	c0 31       	brne	80008132 <_vfprintf_r+0x32>
8000812e:	6a 01       	ld.w	r1,r5[0x0]
80008130:	c0 c8       	rjmp	80008148 <_vfprintf_r+0x48>
80008132:	fe c8 9f fa 	sub	r8,pc,-24582
80008136:	10 31       	cp.w	r1,r8
80008138:	c0 31       	brne	8000813e <_vfprintf_r+0x3e>
8000813a:	6a 11       	ld.w	r1,r5[0x4]
8000813c:	c0 68       	rjmp	80008148 <_vfprintf_r+0x48>
8000813e:	fe c8 9f e6 	sub	r8,pc,-24602
80008142:	10 31       	cp.w	r1,r8
80008144:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008148:	82 68       	ld.sh	r8,r1[0xc]
8000814a:	ed b8 00 03 	bld	r8,0x3
8000814e:	c0 41       	brne	80008156 <_vfprintf_r+0x56>
80008150:	62 48       	ld.w	r8,r1[0x10]
80008152:	58 08       	cp.w	r8,0
80008154:	c0 71       	brne	80008162 <_vfprintf_r+0x62>
80008156:	02 9b       	mov	r11,r1
80008158:	0a 9c       	mov	r12,r5
8000815a:	e0 a0 0f 5d 	rcall	8000a014 <__swsetup_r>
8000815e:	e0 81 0f 54 	brne	8000a006 <_vfprintf_r+0x1f06>
80008162:	82 68       	ld.sh	r8,r1[0xc]
80008164:	10 99       	mov	r9,r8
80008166:	e2 19 00 1a 	andl	r9,0x1a,COH
8000816a:	58 a9       	cp.w	r9,10
8000816c:	c3 c1       	brne	800081e4 <_vfprintf_r+0xe4>
8000816e:	82 79       	ld.sh	r9,r1[0xe]
80008170:	30 0a       	mov	r10,0
80008172:	f4 09 19 00 	cp.h	r9,r10
80008176:	c3 75       	brlt	800081e4 <_vfprintf_r+0xe4>
80008178:	a1 d8       	cbr	r8,0x1
8000817a:	fb 58 05 d0 	st.h	sp[1488],r8
8000817e:	62 88       	ld.w	r8,r1[0x20]
80008180:	fb 48 05 e4 	st.w	sp[1508],r8
80008184:	62 a8       	ld.w	r8,r1[0x28]
80008186:	fb 48 05 ec 	st.w	sp[1516],r8
8000818a:	fa c8 ff bc 	sub	r8,sp,-68
8000818e:	fb 48 05 d4 	st.w	sp[1492],r8
80008192:	fb 48 05 c4 	st.w	sp[1476],r8
80008196:	e0 68 04 00 	mov	r8,1024
8000819a:	fb 48 05 d8 	st.w	sp[1496],r8
8000819e:	fb 48 05 cc 	st.w	sp[1484],r8
800081a2:	30 08       	mov	r8,0
800081a4:	fb 59 05 d2 	st.h	sp[1490],r9
800081a8:	0e 9a       	mov	r10,r7
800081aa:	41 09       	lddsp	r9,sp[0x40]
800081ac:	fa c7 fa 3c 	sub	r7,sp,-1476
800081b0:	fb 48 05 dc 	st.w	sp[1500],r8
800081b4:	0a 9c       	mov	r12,r5
800081b6:	0e 9b       	mov	r11,r7
800081b8:	ca 4f       	rcall	80008100 <_vfprintf_r>
800081ba:	50 bc       	stdsp	sp[0x2c],r12
800081bc:	c0 95       	brlt	800081ce <_vfprintf_r+0xce>
800081be:	0e 9b       	mov	r11,r7
800081c0:	0a 9c       	mov	r12,r5
800081c2:	e0 a0 16 1b 	rcall	8000adf8 <_fflush_r>
800081c6:	40 be       	lddsp	lr,sp[0x2c]
800081c8:	f9 be 01 ff 	movne	lr,-1
800081cc:	50 be       	stdsp	sp[0x2c],lr
800081ce:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800081d2:	ed b8 00 06 	bld	r8,0x6
800081d6:	e0 81 0f 1a 	brne	8000a00a <_vfprintf_r+0x1f0a>
800081da:	82 68       	ld.sh	r8,r1[0xc]
800081dc:	a7 a8       	sbr	r8,0x6
800081de:	a2 68       	st.h	r1[0xc],r8
800081e0:	e0 8f 0f 15 	bral	8000a00a <_vfprintf_r+0x1f0a>
800081e4:	30 08       	mov	r8,0
800081e6:	fb 48 06 b4 	st.w	sp[1716],r8
800081ea:	fb 48 06 90 	st.w	sp[1680],r8
800081ee:	fb 48 06 8c 	st.w	sp[1676],r8
800081f2:	fb 48 06 b0 	st.w	sp[1712],r8
800081f6:	30 08       	mov	r8,0
800081f8:	30 09       	mov	r9,0
800081fa:	50 a7       	stdsp	sp[0x28],r7
800081fc:	50 78       	stdsp	sp[0x1c],r8
800081fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008202:	3f f8       	mov	r8,-1
80008204:	50 59       	stdsp	sp[0x14],r9
80008206:	fb 43 06 88 	st.w	sp[1672],r3
8000820a:	fb 48 05 44 	st.w	sp[1348],r8
8000820e:	12 9c       	mov	r12,r9
80008210:	50 69       	stdsp	sp[0x18],r9
80008212:	50 d9       	stdsp	sp[0x34],r9
80008214:	50 e9       	stdsp	sp[0x38],r9
80008216:	50 b9       	stdsp	sp[0x2c],r9
80008218:	12 97       	mov	r7,r9
8000821a:	0a 94       	mov	r4,r5
8000821c:	40 a2       	lddsp	r2,sp[0x28]
8000821e:	32 5a       	mov	r10,37
80008220:	30 08       	mov	r8,0
80008222:	c0 28       	rjmp	80008226 <_vfprintf_r+0x126>
80008224:	2f f2       	sub	r2,-1
80008226:	05 89       	ld.ub	r9,r2[0x0]
80008228:	f0 09 18 00 	cp.b	r9,r8
8000822c:	5f 1b       	srne	r11
8000822e:	f4 09 18 00 	cp.b	r9,r10
80008232:	5f 19       	srne	r9
80008234:	f3 eb 00 0b 	and	r11,r9,r11
80008238:	f0 0b 18 00 	cp.b	r11,r8
8000823c:	cf 41       	brne	80008224 <_vfprintf_r+0x124>
8000823e:	40 ab       	lddsp	r11,sp[0x28]
80008240:	e4 0b 01 06 	sub	r6,r2,r11
80008244:	c1 e0       	breq	80008280 <_vfprintf_r+0x180>
80008246:	fa f8 06 90 	ld.w	r8,sp[1680]
8000824a:	0c 08       	add	r8,r6
8000824c:	87 0b       	st.w	r3[0x0],r11
8000824e:	fb 48 06 90 	st.w	sp[1680],r8
80008252:	87 16       	st.w	r3[0x4],r6
80008254:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008258:	2f f8       	sub	r8,-1
8000825a:	fb 48 06 8c 	st.w	sp[1676],r8
8000825e:	58 78       	cp.w	r8,7
80008260:	e0 89 00 04 	brgt	80008268 <_vfprintf_r+0x168>
80008264:	2f 83       	sub	r3,-8
80008266:	c0 a8       	rjmp	8000827a <_vfprintf_r+0x17a>
80008268:	fa ca f9 78 	sub	r10,sp,-1672
8000826c:	02 9b       	mov	r11,r1
8000826e:	08 9c       	mov	r12,r4
80008270:	c3 af       	rcall	800080e4 <__sprint_r>
80008272:	e0 81 0e c6 	brne	80009ffe <_vfprintf_r+0x1efe>
80008276:	fa c3 f9 e0 	sub	r3,sp,-1568
8000827a:	40 ba       	lddsp	r10,sp[0x2c]
8000827c:	0c 0a       	add	r10,r6
8000827e:	50 ba       	stdsp	sp[0x2c],r10
80008280:	05 89       	ld.ub	r9,r2[0x0]
80008282:	30 08       	mov	r8,0
80008284:	f0 09 18 00 	cp.b	r9,r8
80008288:	e0 80 0e aa 	breq	80009fdc <_vfprintf_r+0x1edc>
8000828c:	30 09       	mov	r9,0
8000828e:	fb 68 06 bb 	st.b	sp[1723],r8
80008292:	0e 96       	mov	r6,r7
80008294:	e4 c8 ff ff 	sub	r8,r2,-1
80008298:	3f fe       	mov	lr,-1
8000829a:	50 93       	stdsp	sp[0x24],r3
8000829c:	50 41       	stdsp	sp[0x10],r1
8000829e:	0e 93       	mov	r3,r7
800082a0:	04 91       	mov	r1,r2
800082a2:	50 89       	stdsp	sp[0x20],r9
800082a4:	50 a8       	stdsp	sp[0x28],r8
800082a6:	50 2e       	stdsp	sp[0x8],lr
800082a8:	50 39       	stdsp	sp[0xc],r9
800082aa:	12 95       	mov	r5,r9
800082ac:	12 90       	mov	r0,r9
800082ae:	10 97       	mov	r7,r8
800082b0:	08 92       	mov	r2,r4
800082b2:	c0 78       	rjmp	800082c0 <_vfprintf_r+0x1c0>
800082b4:	3f fc       	mov	r12,-1
800082b6:	08 97       	mov	r7,r4
800082b8:	50 2c       	stdsp	sp[0x8],r12
800082ba:	c0 38       	rjmp	800082c0 <_vfprintf_r+0x1c0>
800082bc:	30 0b       	mov	r11,0
800082be:	50 3b       	stdsp	sp[0xc],r11
800082c0:	0f 38       	ld.ub	r8,r7++
800082c2:	c0 28       	rjmp	800082c6 <_vfprintf_r+0x1c6>
800082c4:	12 90       	mov	r0,r9
800082c6:	f0 c9 00 20 	sub	r9,r8,32
800082ca:	e0 49 00 58 	cp.w	r9,88
800082ce:	e0 8b 0a 30 	brhi	8000972e <_vfprintf_r+0x162e>
800082d2:	fe ca a5 62 	sub	r10,pc,-23198
800082d6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800082da:	50 a7       	stdsp	sp[0x28],r7
800082dc:	50 80       	stdsp	sp[0x20],r0
800082de:	0c 97       	mov	r7,r6
800082e0:	04 94       	mov	r4,r2
800082e2:	06 96       	mov	r6,r3
800082e4:	02 92       	mov	r2,r1
800082e6:	fe c9 a3 3a 	sub	r9,pc,-23750
800082ea:	40 93       	lddsp	r3,sp[0x24]
800082ec:	10 90       	mov	r0,r8
800082ee:	40 41       	lddsp	r1,sp[0x10]
800082f0:	50 d9       	stdsp	sp[0x34],r9
800082f2:	e0 8f 08 8e 	bral	8000940e <_vfprintf_r+0x130e>
800082f6:	30 08       	mov	r8,0
800082f8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800082fc:	f0 09 18 00 	cp.b	r9,r8
80008300:	ce 01       	brne	800082c0 <_vfprintf_r+0x1c0>
80008302:	32 08       	mov	r8,32
80008304:	c6 e8       	rjmp	800083e0 <_vfprintf_r+0x2e0>
80008306:	a1 a5       	sbr	r5,0x0
80008308:	cd cb       	rjmp	800082c0 <_vfprintf_r+0x1c0>
8000830a:	0f 89       	ld.ub	r9,r7[0x0]
8000830c:	f2 c8 00 30 	sub	r8,r9,48
80008310:	58 98       	cp.w	r8,9
80008312:	e0 8b 00 1d 	brhi	8000834c <_vfprintf_r+0x24c>
80008316:	ee c8 ff ff 	sub	r8,r7,-1
8000831a:	30 0b       	mov	r11,0
8000831c:	23 09       	sub	r9,48
8000831e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008322:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008326:	11 39       	ld.ub	r9,r8++
80008328:	f2 ca 00 30 	sub	r10,r9,48
8000832c:	58 9a       	cp.w	r10,9
8000832e:	fe 98 ff f7 	brls	8000831c <_vfprintf_r+0x21c>
80008332:	e0 49 00 24 	cp.w	r9,36
80008336:	cc 31       	brne	800082bc <_vfprintf_r+0x1bc>
80008338:	e0 4b 00 20 	cp.w	r11,32
8000833c:	e0 89 0e 60 	brgt	80009ffc <_vfprintf_r+0x1efc>
80008340:	20 1b       	sub	r11,1
80008342:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008346:	12 3b       	cp.w	r11,r9
80008348:	c0 95       	brlt	8000835a <_vfprintf_r+0x25a>
8000834a:	c1 08       	rjmp	8000836a <_vfprintf_r+0x26a>
8000834c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008350:	ec ca ff ff 	sub	r10,r6,-1
80008354:	12 36       	cp.w	r6,r9
80008356:	c1 f5       	brlt	80008394 <_vfprintf_r+0x294>
80008358:	c2 68       	rjmp	800083a4 <_vfprintf_r+0x2a4>
8000835a:	fa ce f9 44 	sub	lr,sp,-1724
8000835e:	10 97       	mov	r7,r8
80008360:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008364:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008368:	c3 58       	rjmp	800083d2 <_vfprintf_r+0x2d2>
8000836a:	10 97       	mov	r7,r8
8000836c:	fa c8 f9 50 	sub	r8,sp,-1712
80008370:	1a d8       	st.w	--sp,r8
80008372:	fa c8 fa b8 	sub	r8,sp,-1352
80008376:	1a d8       	st.w	--sp,r8
80008378:	fa c8 fb b4 	sub	r8,sp,-1100
8000837c:	02 9a       	mov	r10,r1
8000837e:	1a d8       	st.w	--sp,r8
80008380:	04 9c       	mov	r12,r2
80008382:	fa c8 f9 40 	sub	r8,sp,-1728
80008386:	fa c9 ff b4 	sub	r9,sp,-76
8000838a:	fe b0 fd 23 	rcall	80007dd0 <get_arg>
8000838e:	2f dd       	sub	sp,-12
80008390:	78 00       	ld.w	r0,r12[0x0]
80008392:	c2 08       	rjmp	800083d2 <_vfprintf_r+0x2d2>
80008394:	fa cc f9 44 	sub	r12,sp,-1724
80008398:	14 96       	mov	r6,r10
8000839a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000839e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800083a2:	c1 88       	rjmp	800083d2 <_vfprintf_r+0x2d2>
800083a4:	41 08       	lddsp	r8,sp[0x40]
800083a6:	59 f9       	cp.w	r9,31
800083a8:	e0 89 00 11 	brgt	800083ca <_vfprintf_r+0x2ca>
800083ac:	f0 cb ff fc 	sub	r11,r8,-4
800083b0:	51 0b       	stdsp	sp[0x40],r11
800083b2:	70 00       	ld.w	r0,r8[0x0]
800083b4:	fa cb f9 44 	sub	r11,sp,-1724
800083b8:	f6 09 00 38 	add	r8,r11,r9<<0x3
800083bc:	f1 40 fd 88 	st.w	r8[-632],r0
800083c0:	2f f9       	sub	r9,-1
800083c2:	14 96       	mov	r6,r10
800083c4:	fb 49 06 b4 	st.w	sp[1716],r9
800083c8:	c0 58       	rjmp	800083d2 <_vfprintf_r+0x2d2>
800083ca:	70 00       	ld.w	r0,r8[0x0]
800083cc:	14 96       	mov	r6,r10
800083ce:	2f c8       	sub	r8,-4
800083d0:	51 08       	stdsp	sp[0x40],r8
800083d2:	58 00       	cp.w	r0,0
800083d4:	fe 94 ff 76 	brge	800082c0 <_vfprintf_r+0x1c0>
800083d8:	5c 30       	neg	r0
800083da:	a3 a5       	sbr	r5,0x2
800083dc:	c7 2b       	rjmp	800082c0 <_vfprintf_r+0x1c0>
800083de:	32 b8       	mov	r8,43
800083e0:	fb 68 06 bb 	st.b	sp[1723],r8
800083e4:	c6 eb       	rjmp	800082c0 <_vfprintf_r+0x1c0>
800083e6:	0f 38       	ld.ub	r8,r7++
800083e8:	e0 48 00 2a 	cp.w	r8,42
800083ec:	c0 30       	breq	800083f2 <_vfprintf_r+0x2f2>
800083ee:	30 09       	mov	r9,0
800083f0:	c7 98       	rjmp	800084e2 <_vfprintf_r+0x3e2>
800083f2:	0f 88       	ld.ub	r8,r7[0x0]
800083f4:	f0 c9 00 30 	sub	r9,r8,48
800083f8:	58 99       	cp.w	r9,9
800083fa:	e0 8b 00 1f 	brhi	80008438 <_vfprintf_r+0x338>
800083fe:	ee c4 ff ff 	sub	r4,r7,-1
80008402:	30 0b       	mov	r11,0
80008404:	23 08       	sub	r8,48
80008406:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000840a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000840e:	09 38       	ld.ub	r8,r4++
80008410:	f0 c9 00 30 	sub	r9,r8,48
80008414:	58 99       	cp.w	r9,9
80008416:	fe 98 ff f7 	brls	80008404 <_vfprintf_r+0x304>
8000841a:	e0 48 00 24 	cp.w	r8,36
8000841e:	fe 91 ff 4f 	brne	800082bc <_vfprintf_r+0x1bc>
80008422:	e0 4b 00 20 	cp.w	r11,32
80008426:	e0 89 0d eb 	brgt	80009ffc <_vfprintf_r+0x1efc>
8000842a:	20 1b       	sub	r11,1
8000842c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008430:	10 3b       	cp.w	r11,r8
80008432:	c0 a5       	brlt	80008446 <_vfprintf_r+0x346>
80008434:	c1 18       	rjmp	80008456 <_vfprintf_r+0x356>
80008436:	d7 03       	nop
80008438:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000843c:	ec c9 ff ff 	sub	r9,r6,-1
80008440:	14 36       	cp.w	r6,r10
80008442:	c1 f5       	brlt	80008480 <_vfprintf_r+0x380>
80008444:	c2 88       	rjmp	80008494 <_vfprintf_r+0x394>
80008446:	fa ca f9 44 	sub	r10,sp,-1724
8000844a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000844e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008452:	50 2b       	stdsp	sp[0x8],r11
80008454:	c3 c8       	rjmp	800084cc <_vfprintf_r+0x3cc>
80008456:	fa c8 f9 50 	sub	r8,sp,-1712
8000845a:	1a d8       	st.w	--sp,r8
8000845c:	fa c8 fa b8 	sub	r8,sp,-1352
80008460:	1a d8       	st.w	--sp,r8
80008462:	fa c8 fb b4 	sub	r8,sp,-1100
80008466:	02 9a       	mov	r10,r1
80008468:	1a d8       	st.w	--sp,r8
8000846a:	04 9c       	mov	r12,r2
8000846c:	fa c8 f9 40 	sub	r8,sp,-1728
80008470:	fa c9 ff b4 	sub	r9,sp,-76
80008474:	fe b0 fc ae 	rcall	80007dd0 <get_arg>
80008478:	2f dd       	sub	sp,-12
8000847a:	78 0c       	ld.w	r12,r12[0x0]
8000847c:	50 2c       	stdsp	sp[0x8],r12
8000847e:	c2 78       	rjmp	800084cc <_vfprintf_r+0x3cc>
80008480:	12 96       	mov	r6,r9
80008482:	0e 94       	mov	r4,r7
80008484:	fa c9 f9 44 	sub	r9,sp,-1724
80008488:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000848c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008490:	50 28       	stdsp	sp[0x8],r8
80008492:	c1 d8       	rjmp	800084cc <_vfprintf_r+0x3cc>
80008494:	41 08       	lddsp	r8,sp[0x40]
80008496:	59 fa       	cp.w	r10,31
80008498:	e0 89 00 14 	brgt	800084c0 <_vfprintf_r+0x3c0>
8000849c:	f0 cb ff fc 	sub	r11,r8,-4
800084a0:	70 08       	ld.w	r8,r8[0x0]
800084a2:	51 0b       	stdsp	sp[0x40],r11
800084a4:	50 28       	stdsp	sp[0x8],r8
800084a6:	fa c6 f9 44 	sub	r6,sp,-1724
800084aa:	40 2e       	lddsp	lr,sp[0x8]
800084ac:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800084b0:	f1 4e fd 88 	st.w	r8[-632],lr
800084b4:	2f fa       	sub	r10,-1
800084b6:	0e 94       	mov	r4,r7
800084b8:	fb 4a 06 b4 	st.w	sp[1716],r10
800084bc:	12 96       	mov	r6,r9
800084be:	c0 78       	rjmp	800084cc <_vfprintf_r+0x3cc>
800084c0:	70 0c       	ld.w	r12,r8[0x0]
800084c2:	0e 94       	mov	r4,r7
800084c4:	2f c8       	sub	r8,-4
800084c6:	50 2c       	stdsp	sp[0x8],r12
800084c8:	12 96       	mov	r6,r9
800084ca:	51 08       	stdsp	sp[0x40],r8
800084cc:	40 2b       	lddsp	r11,sp[0x8]
800084ce:	58 0b       	cp.w	r11,0
800084d0:	fe 95 fe f2 	brlt	800082b4 <_vfprintf_r+0x1b4>
800084d4:	08 97       	mov	r7,r4
800084d6:	cf 5a       	rjmp	800082c0 <_vfprintf_r+0x1c0>
800084d8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800084dc:	0f 38       	ld.ub	r8,r7++
800084de:	f4 09 00 19 	add	r9,r10,r9<<0x1
800084e2:	f0 ca 00 30 	sub	r10,r8,48
800084e6:	58 9a       	cp.w	r10,9
800084e8:	fe 98 ff f8 	brls	800084d8 <_vfprintf_r+0x3d8>
800084ec:	3f fa       	mov	r10,-1
800084ee:	f2 0a 0c 49 	max	r9,r9,r10
800084f2:	50 29       	stdsp	sp[0x8],r9
800084f4:	ce 9a       	rjmp	800082c6 <_vfprintf_r+0x1c6>
800084f6:	a7 b5       	sbr	r5,0x7
800084f8:	ce 4a       	rjmp	800082c0 <_vfprintf_r+0x1c0>
800084fa:	30 09       	mov	r9,0
800084fc:	23 08       	sub	r8,48
800084fe:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008502:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008506:	0f 38       	ld.ub	r8,r7++
80008508:	f0 ca 00 30 	sub	r10,r8,48
8000850c:	58 9a       	cp.w	r10,9
8000850e:	fe 98 ff f7 	brls	800084fc <_vfprintf_r+0x3fc>
80008512:	e0 48 00 24 	cp.w	r8,36
80008516:	fe 91 fe d7 	brne	800082c4 <_vfprintf_r+0x1c4>
8000851a:	e0 49 00 20 	cp.w	r9,32
8000851e:	e0 89 0d 6f 	brgt	80009ffc <_vfprintf_r+0x1efc>
80008522:	f2 c3 00 01 	sub	r3,r9,1
80008526:	30 19       	mov	r9,1
80008528:	50 39       	stdsp	sp[0xc],r9
8000852a:	cc ba       	rjmp	800082c0 <_vfprintf_r+0x1c0>
8000852c:	a3 b5       	sbr	r5,0x3
8000852e:	cc 9a       	rjmp	800082c0 <_vfprintf_r+0x1c0>
80008530:	a7 a5       	sbr	r5,0x6
80008532:	cc 7a       	rjmp	800082c0 <_vfprintf_r+0x1c0>
80008534:	0a 98       	mov	r8,r5
80008536:	a5 b5       	sbr	r5,0x5
80008538:	a5 a8       	sbr	r8,0x4
8000853a:	0f 89       	ld.ub	r9,r7[0x0]
8000853c:	36 ce       	mov	lr,108
8000853e:	fc 09 18 00 	cp.b	r9,lr
80008542:	f7 b7 00 ff 	subeq	r7,-1
80008546:	f0 05 17 10 	movne	r5,r8
8000854a:	cb ba       	rjmp	800082c0 <_vfprintf_r+0x1c0>
8000854c:	a5 b5       	sbr	r5,0x5
8000854e:	cb 9a       	rjmp	800082c0 <_vfprintf_r+0x1c0>
80008550:	50 a7       	stdsp	sp[0x28],r7
80008552:	50 80       	stdsp	sp[0x20],r0
80008554:	0c 97       	mov	r7,r6
80008556:	10 90       	mov	r0,r8
80008558:	06 96       	mov	r6,r3
8000855a:	04 94       	mov	r4,r2
8000855c:	40 93       	lddsp	r3,sp[0x24]
8000855e:	02 92       	mov	r2,r1
80008560:	0e 99       	mov	r9,r7
80008562:	40 41       	lddsp	r1,sp[0x10]
80008564:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008568:	40 3c       	lddsp	r12,sp[0xc]
8000856a:	58 0c       	cp.w	r12,0
8000856c:	c1 d0       	breq	800085a6 <_vfprintf_r+0x4a6>
8000856e:	10 36       	cp.w	r6,r8
80008570:	c0 64       	brge	8000857c <_vfprintf_r+0x47c>
80008572:	fa cb f9 44 	sub	r11,sp,-1724
80008576:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000857a:	c1 d8       	rjmp	800085b4 <_vfprintf_r+0x4b4>
8000857c:	fa c8 f9 50 	sub	r8,sp,-1712
80008580:	1a d8       	st.w	--sp,r8
80008582:	fa c8 fa b8 	sub	r8,sp,-1352
80008586:	1a d8       	st.w	--sp,r8
80008588:	fa c8 fb b4 	sub	r8,sp,-1100
8000858c:	1a d8       	st.w	--sp,r8
8000858e:	fa c8 f9 40 	sub	r8,sp,-1728
80008592:	fa c9 ff b4 	sub	r9,sp,-76
80008596:	04 9a       	mov	r10,r2
80008598:	0c 9b       	mov	r11,r6
8000859a:	08 9c       	mov	r12,r4
8000859c:	fe b0 fc 1a 	rcall	80007dd0 <get_arg>
800085a0:	2f dd       	sub	sp,-12
800085a2:	19 b8       	ld.ub	r8,r12[0x3]
800085a4:	c2 28       	rjmp	800085e8 <_vfprintf_r+0x4e8>
800085a6:	2f f7       	sub	r7,-1
800085a8:	10 39       	cp.w	r9,r8
800085aa:	c0 84       	brge	800085ba <_vfprintf_r+0x4ba>
800085ac:	fa ca f9 44 	sub	r10,sp,-1724
800085b0:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085b4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800085b8:	c1 88       	rjmp	800085e8 <_vfprintf_r+0x4e8>
800085ba:	41 09       	lddsp	r9,sp[0x40]
800085bc:	59 f8       	cp.w	r8,31
800085be:	e0 89 00 12 	brgt	800085e2 <_vfprintf_r+0x4e2>
800085c2:	f2 ca ff fc 	sub	r10,r9,-4
800085c6:	51 0a       	stdsp	sp[0x40],r10
800085c8:	72 09       	ld.w	r9,r9[0x0]
800085ca:	fa c6 f9 44 	sub	r6,sp,-1724
800085ce:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085d2:	2f f8       	sub	r8,-1
800085d4:	f5 49 fd 88 	st.w	r10[-632],r9
800085d8:	fb 48 06 b4 	st.w	sp[1716],r8
800085dc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800085e0:	c0 48       	rjmp	800085e8 <_vfprintf_r+0x4e8>
800085e2:	13 b8       	ld.ub	r8,r9[0x3]
800085e4:	2f c9       	sub	r9,-4
800085e6:	51 09       	stdsp	sp[0x40],r9
800085e8:	fb 68 06 60 	st.b	sp[1632],r8
800085ec:	30 0e       	mov	lr,0
800085ee:	30 08       	mov	r8,0
800085f0:	30 12       	mov	r2,1
800085f2:	fb 68 06 bb 	st.b	sp[1723],r8
800085f6:	50 2e       	stdsp	sp[0x8],lr
800085f8:	e0 8f 08 ad 	bral	80009752 <_vfprintf_r+0x1652>
800085fc:	50 a7       	stdsp	sp[0x28],r7
800085fe:	50 80       	stdsp	sp[0x20],r0
80008600:	0c 97       	mov	r7,r6
80008602:	04 94       	mov	r4,r2
80008604:	06 96       	mov	r6,r3
80008606:	02 92       	mov	r2,r1
80008608:	40 93       	lddsp	r3,sp[0x24]
8000860a:	10 90       	mov	r0,r8
8000860c:	40 41       	lddsp	r1,sp[0x10]
8000860e:	a5 a5       	sbr	r5,0x4
80008610:	c0 a8       	rjmp	80008624 <_vfprintf_r+0x524>
80008612:	50 a7       	stdsp	sp[0x28],r7
80008614:	50 80       	stdsp	sp[0x20],r0
80008616:	0c 97       	mov	r7,r6
80008618:	04 94       	mov	r4,r2
8000861a:	06 96       	mov	r6,r3
8000861c:	02 92       	mov	r2,r1
8000861e:	40 93       	lddsp	r3,sp[0x24]
80008620:	10 90       	mov	r0,r8
80008622:	40 41       	lddsp	r1,sp[0x10]
80008624:	ed b5 00 05 	bld	r5,0x5
80008628:	c5 11       	brne	800086ca <_vfprintf_r+0x5ca>
8000862a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000862e:	40 3c       	lddsp	r12,sp[0xc]
80008630:	58 0c       	cp.w	r12,0
80008632:	c1 e0       	breq	8000866e <_vfprintf_r+0x56e>
80008634:	10 36       	cp.w	r6,r8
80008636:	c0 64       	brge	80008642 <_vfprintf_r+0x542>
80008638:	fa cb f9 44 	sub	r11,sp,-1724
8000863c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008640:	c2 08       	rjmp	80008680 <_vfprintf_r+0x580>
80008642:	fa c8 f9 50 	sub	r8,sp,-1712
80008646:	1a d8       	st.w	--sp,r8
80008648:	fa c8 fa b8 	sub	r8,sp,-1352
8000864c:	0c 9b       	mov	r11,r6
8000864e:	1a d8       	st.w	--sp,r8
80008650:	fa c8 fb b4 	sub	r8,sp,-1100
80008654:	1a d8       	st.w	--sp,r8
80008656:	fa c9 ff b4 	sub	r9,sp,-76
8000865a:	fa c8 f9 40 	sub	r8,sp,-1728
8000865e:	04 9a       	mov	r10,r2
80008660:	08 9c       	mov	r12,r4
80008662:	fe b0 fb b7 	rcall	80007dd0 <get_arg>
80008666:	2f dd       	sub	sp,-12
80008668:	78 1b       	ld.w	r11,r12[0x4]
8000866a:	78 09       	ld.w	r9,r12[0x0]
8000866c:	c2 b8       	rjmp	800086c2 <_vfprintf_r+0x5c2>
8000866e:	ee ca ff ff 	sub	r10,r7,-1
80008672:	10 37       	cp.w	r7,r8
80008674:	c0 b4       	brge	8000868a <_vfprintf_r+0x58a>
80008676:	fa c9 f9 44 	sub	r9,sp,-1724
8000867a:	14 97       	mov	r7,r10
8000867c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008680:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008684:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008688:	c1 d8       	rjmp	800086c2 <_vfprintf_r+0x5c2>
8000868a:	41 09       	lddsp	r9,sp[0x40]
8000868c:	59 f8       	cp.w	r8,31
8000868e:	e0 89 00 14 	brgt	800086b6 <_vfprintf_r+0x5b6>
80008692:	f2 cb ff f8 	sub	r11,r9,-8
80008696:	51 0b       	stdsp	sp[0x40],r11
80008698:	fa c6 f9 44 	sub	r6,sp,-1724
8000869c:	72 1b       	ld.w	r11,r9[0x4]
8000869e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800086a2:	72 09       	ld.w	r9,r9[0x0]
800086a4:	f9 4b fd 8c 	st.w	r12[-628],r11
800086a8:	f9 49 fd 88 	st.w	r12[-632],r9
800086ac:	2f f8       	sub	r8,-1
800086ae:	14 97       	mov	r7,r10
800086b0:	fb 48 06 b4 	st.w	sp[1716],r8
800086b4:	c0 78       	rjmp	800086c2 <_vfprintf_r+0x5c2>
800086b6:	f2 c8 ff f8 	sub	r8,r9,-8
800086ba:	72 1b       	ld.w	r11,r9[0x4]
800086bc:	14 97       	mov	r7,r10
800086be:	51 08       	stdsp	sp[0x40],r8
800086c0:	72 09       	ld.w	r9,r9[0x0]
800086c2:	16 98       	mov	r8,r11
800086c4:	fa e9 00 00 	st.d	sp[0],r8
800086c8:	ca e8       	rjmp	80008824 <_vfprintf_r+0x724>
800086ca:	ed b5 00 04 	bld	r5,0x4
800086ce:	c1 71       	brne	800086fc <_vfprintf_r+0x5fc>
800086d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086d4:	40 3e       	lddsp	lr,sp[0xc]
800086d6:	58 0e       	cp.w	lr,0
800086d8:	c0 80       	breq	800086e8 <_vfprintf_r+0x5e8>
800086da:	10 36       	cp.w	r6,r8
800086dc:	c6 94       	brge	800087ae <_vfprintf_r+0x6ae>
800086de:	fa cc f9 44 	sub	r12,sp,-1724
800086e2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086e6:	c8 28       	rjmp	800087ea <_vfprintf_r+0x6ea>
800086e8:	ee ca ff ff 	sub	r10,r7,-1
800086ec:	10 37       	cp.w	r7,r8
800086ee:	e0 84 00 81 	brge	800087f0 <_vfprintf_r+0x6f0>
800086f2:	fa cb f9 44 	sub	r11,sp,-1724
800086f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086fa:	c7 78       	rjmp	800087e8 <_vfprintf_r+0x6e8>
800086fc:	ed b5 00 06 	bld	r5,0x6
80008700:	c4 b1       	brne	80008796 <_vfprintf_r+0x696>
80008702:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008706:	40 3c       	lddsp	r12,sp[0xc]
80008708:	58 0c       	cp.w	r12,0
8000870a:	c1 d0       	breq	80008744 <_vfprintf_r+0x644>
8000870c:	10 36       	cp.w	r6,r8
8000870e:	c0 64       	brge	8000871a <_vfprintf_r+0x61a>
80008710:	fa cb f9 44 	sub	r11,sp,-1724
80008714:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008718:	c1 f8       	rjmp	80008756 <_vfprintf_r+0x656>
8000871a:	fa c8 f9 50 	sub	r8,sp,-1712
8000871e:	1a d8       	st.w	--sp,r8
80008720:	fa c8 fa b8 	sub	r8,sp,-1352
80008724:	1a d8       	st.w	--sp,r8
80008726:	fa c8 fb b4 	sub	r8,sp,-1100
8000872a:	1a d8       	st.w	--sp,r8
8000872c:	fa c8 f9 40 	sub	r8,sp,-1728
80008730:	fa c9 ff b4 	sub	r9,sp,-76
80008734:	04 9a       	mov	r10,r2
80008736:	0c 9b       	mov	r11,r6
80008738:	08 9c       	mov	r12,r4
8000873a:	fe b0 fb 4b 	rcall	80007dd0 <get_arg>
8000873e:	2f dd       	sub	sp,-12
80008740:	98 18       	ld.sh	r8,r12[0x2]
80008742:	c2 68       	rjmp	8000878e <_vfprintf_r+0x68e>
80008744:	ee ca ff ff 	sub	r10,r7,-1
80008748:	10 37       	cp.w	r7,r8
8000874a:	c0 94       	brge	8000875c <_vfprintf_r+0x65c>
8000874c:	fa c9 f9 44 	sub	r9,sp,-1724
80008750:	14 97       	mov	r7,r10
80008752:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008756:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000875a:	c1 a8       	rjmp	8000878e <_vfprintf_r+0x68e>
8000875c:	41 09       	lddsp	r9,sp[0x40]
8000875e:	59 f8       	cp.w	r8,31
80008760:	e0 89 00 13 	brgt	80008786 <_vfprintf_r+0x686>
80008764:	f2 cb ff fc 	sub	r11,r9,-4
80008768:	51 0b       	stdsp	sp[0x40],r11
8000876a:	72 09       	ld.w	r9,r9[0x0]
8000876c:	fa c6 f9 44 	sub	r6,sp,-1724
80008770:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008774:	2f f8       	sub	r8,-1
80008776:	f7 49 fd 88 	st.w	r11[-632],r9
8000877a:	fb 48 06 b4 	st.w	sp[1716],r8
8000877e:	14 97       	mov	r7,r10
80008780:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008784:	c0 58       	rjmp	8000878e <_vfprintf_r+0x68e>
80008786:	92 18       	ld.sh	r8,r9[0x2]
80008788:	14 97       	mov	r7,r10
8000878a:	2f c9       	sub	r9,-4
8000878c:	51 09       	stdsp	sp[0x40],r9
8000878e:	50 18       	stdsp	sp[0x4],r8
80008790:	bf 58       	asr	r8,0x1f
80008792:	50 08       	stdsp	sp[0x0],r8
80008794:	c4 88       	rjmp	80008824 <_vfprintf_r+0x724>
80008796:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000879a:	40 3c       	lddsp	r12,sp[0xc]
8000879c:	58 0c       	cp.w	r12,0
8000879e:	c1 d0       	breq	800087d8 <_vfprintf_r+0x6d8>
800087a0:	10 36       	cp.w	r6,r8
800087a2:	c0 64       	brge	800087ae <_vfprintf_r+0x6ae>
800087a4:	fa cb f9 44 	sub	r11,sp,-1724
800087a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087ac:	c1 f8       	rjmp	800087ea <_vfprintf_r+0x6ea>
800087ae:	fa c8 f9 50 	sub	r8,sp,-1712
800087b2:	1a d8       	st.w	--sp,r8
800087b4:	fa c8 fa b8 	sub	r8,sp,-1352
800087b8:	0c 9b       	mov	r11,r6
800087ba:	1a d8       	st.w	--sp,r8
800087bc:	fa c8 fb b4 	sub	r8,sp,-1100
800087c0:	04 9a       	mov	r10,r2
800087c2:	1a d8       	st.w	--sp,r8
800087c4:	08 9c       	mov	r12,r4
800087c6:	fa c8 f9 40 	sub	r8,sp,-1728
800087ca:	fa c9 ff b4 	sub	r9,sp,-76
800087ce:	fe b0 fb 01 	rcall	80007dd0 <get_arg>
800087d2:	2f dd       	sub	sp,-12
800087d4:	78 0b       	ld.w	r11,r12[0x0]
800087d6:	c2 48       	rjmp	8000881e <_vfprintf_r+0x71e>
800087d8:	ee ca ff ff 	sub	r10,r7,-1
800087dc:	10 37       	cp.w	r7,r8
800087de:	c0 94       	brge	800087f0 <_vfprintf_r+0x6f0>
800087e0:	fa c9 f9 44 	sub	r9,sp,-1724
800087e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087e8:	14 97       	mov	r7,r10
800087ea:	ec fb fd 88 	ld.w	r11,r6[-632]
800087ee:	c1 88       	rjmp	8000881e <_vfprintf_r+0x71e>
800087f0:	41 09       	lddsp	r9,sp[0x40]
800087f2:	59 f8       	cp.w	r8,31
800087f4:	e0 89 00 11 	brgt	80008816 <_vfprintf_r+0x716>
800087f8:	f2 cb ff fc 	sub	r11,r9,-4
800087fc:	51 0b       	stdsp	sp[0x40],r11
800087fe:	fa c6 f9 44 	sub	r6,sp,-1724
80008802:	72 0b       	ld.w	r11,r9[0x0]
80008804:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008808:	f3 4b fd 88 	st.w	r9[-632],r11
8000880c:	2f f8       	sub	r8,-1
8000880e:	14 97       	mov	r7,r10
80008810:	fb 48 06 b4 	st.w	sp[1716],r8
80008814:	c0 58       	rjmp	8000881e <_vfprintf_r+0x71e>
80008816:	72 0b       	ld.w	r11,r9[0x0]
80008818:	14 97       	mov	r7,r10
8000881a:	2f c9       	sub	r9,-4
8000881c:	51 09       	stdsp	sp[0x40],r9
8000881e:	50 1b       	stdsp	sp[0x4],r11
80008820:	bf 5b       	asr	r11,0x1f
80008822:	50 0b       	stdsp	sp[0x0],r11
80008824:	fa ea 00 00 	ld.d	r10,sp[0]
80008828:	58 0a       	cp.w	r10,0
8000882a:	5c 2b       	cpc	r11
8000882c:	c0 e4       	brge	80008848 <_vfprintf_r+0x748>
8000882e:	30 08       	mov	r8,0
80008830:	fa ea 00 00 	ld.d	r10,sp[0]
80008834:	30 09       	mov	r9,0
80008836:	f0 0a 01 0a 	sub	r10,r8,r10
8000883a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000883e:	32 d8       	mov	r8,45
80008840:	fa eb 00 00 	st.d	sp[0],r10
80008844:	fb 68 06 bb 	st.b	sp[1723],r8
80008848:	30 18       	mov	r8,1
8000884a:	e0 8f 06 fa 	bral	8000963e <_vfprintf_r+0x153e>
8000884e:	50 a7       	stdsp	sp[0x28],r7
80008850:	50 80       	stdsp	sp[0x20],r0
80008852:	0c 97       	mov	r7,r6
80008854:	04 94       	mov	r4,r2
80008856:	06 96       	mov	r6,r3
80008858:	02 92       	mov	r2,r1
8000885a:	40 93       	lddsp	r3,sp[0x24]
8000885c:	10 90       	mov	r0,r8
8000885e:	40 41       	lddsp	r1,sp[0x10]
80008860:	0e 99       	mov	r9,r7
80008862:	ed b5 00 03 	bld	r5,0x3
80008866:	c4 11       	brne	800088e8 <_vfprintf_r+0x7e8>
80008868:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000886c:	40 3a       	lddsp	r10,sp[0xc]
8000886e:	58 0a       	cp.w	r10,0
80008870:	c1 90       	breq	800088a2 <_vfprintf_r+0x7a2>
80008872:	10 36       	cp.w	r6,r8
80008874:	c6 45       	brlt	8000893c <_vfprintf_r+0x83c>
80008876:	fa c8 f9 50 	sub	r8,sp,-1712
8000887a:	1a d8       	st.w	--sp,r8
8000887c:	fa c8 fa b8 	sub	r8,sp,-1352
80008880:	1a d8       	st.w	--sp,r8
80008882:	fa c8 fb b4 	sub	r8,sp,-1100
80008886:	0c 9b       	mov	r11,r6
80008888:	1a d8       	st.w	--sp,r8
8000888a:	04 9a       	mov	r10,r2
8000888c:	fa c8 f9 40 	sub	r8,sp,-1728
80008890:	fa c9 ff b4 	sub	r9,sp,-76
80008894:	08 9c       	mov	r12,r4
80008896:	fe b0 fa 9d 	rcall	80007dd0 <get_arg>
8000889a:	2f dd       	sub	sp,-12
8000889c:	78 16       	ld.w	r6,r12[0x4]
8000889e:	50 76       	stdsp	sp[0x1c],r6
800088a0:	c4 88       	rjmp	80008930 <_vfprintf_r+0x830>
800088a2:	2f f7       	sub	r7,-1
800088a4:	10 39       	cp.w	r9,r8
800088a6:	c0 c4       	brge	800088be <_vfprintf_r+0x7be>
800088a8:	fa ce f9 44 	sub	lr,sp,-1724
800088ac:	fc 06 00 36 	add	r6,lr,r6<<0x3
800088b0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800088b4:	50 7c       	stdsp	sp[0x1c],r12
800088b6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800088ba:	50 56       	stdsp	sp[0x14],r6
800088bc:	c6 68       	rjmp	80008988 <_vfprintf_r+0x888>
800088be:	41 09       	lddsp	r9,sp[0x40]
800088c0:	59 f8       	cp.w	r8,31
800088c2:	e0 89 00 10 	brgt	800088e2 <_vfprintf_r+0x7e2>
800088c6:	f2 ca ff f8 	sub	r10,r9,-8
800088ca:	72 1b       	ld.w	r11,r9[0x4]
800088cc:	51 0a       	stdsp	sp[0x40],r10
800088ce:	72 09       	ld.w	r9,r9[0x0]
800088d0:	fa ca f9 44 	sub	r10,sp,-1724
800088d4:	50 7b       	stdsp	sp[0x1c],r11
800088d6:	50 59       	stdsp	sp[0x14],r9
800088d8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800088dc:	40 5b       	lddsp	r11,sp[0x14]
800088de:	40 7a       	lddsp	r10,sp[0x1c]
800088e0:	c4 78       	rjmp	8000896e <_vfprintf_r+0x86e>
800088e2:	72 18       	ld.w	r8,r9[0x4]
800088e4:	50 78       	stdsp	sp[0x1c],r8
800088e6:	c4 c8       	rjmp	8000897e <_vfprintf_r+0x87e>
800088e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088ec:	40 3e       	lddsp	lr,sp[0xc]
800088ee:	58 0e       	cp.w	lr,0
800088f0:	c2 30       	breq	80008936 <_vfprintf_r+0x836>
800088f2:	10 36       	cp.w	r6,r8
800088f4:	c0 94       	brge	80008906 <_vfprintf_r+0x806>
800088f6:	fa cc f9 44 	sub	r12,sp,-1724
800088fa:	f8 06 00 36 	add	r6,r12,r6<<0x3
800088fe:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008902:	50 7b       	stdsp	sp[0x1c],r11
80008904:	cd 9b       	rjmp	800088b6 <_vfprintf_r+0x7b6>
80008906:	fa c8 f9 50 	sub	r8,sp,-1712
8000890a:	1a d8       	st.w	--sp,r8
8000890c:	fa c8 fa b8 	sub	r8,sp,-1352
80008910:	04 9a       	mov	r10,r2
80008912:	1a d8       	st.w	--sp,r8
80008914:	fa c8 fb b4 	sub	r8,sp,-1100
80008918:	0c 9b       	mov	r11,r6
8000891a:	1a d8       	st.w	--sp,r8
8000891c:	08 9c       	mov	r12,r4
8000891e:	fa c8 f9 40 	sub	r8,sp,-1728
80008922:	fa c9 ff b4 	sub	r9,sp,-76
80008926:	fe b0 fa 55 	rcall	80007dd0 <get_arg>
8000892a:	2f dd       	sub	sp,-12
8000892c:	78 1a       	ld.w	r10,r12[0x4]
8000892e:	50 7a       	stdsp	sp[0x1c],r10
80008930:	78 0c       	ld.w	r12,r12[0x0]
80008932:	50 5c       	stdsp	sp[0x14],r12
80008934:	c2 a8       	rjmp	80008988 <_vfprintf_r+0x888>
80008936:	2f f7       	sub	r7,-1
80008938:	10 39       	cp.w	r9,r8
8000893a:	c0 94       	brge	8000894c <_vfprintf_r+0x84c>
8000893c:	fa c9 f9 44 	sub	r9,sp,-1724
80008940:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008944:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008948:	50 78       	stdsp	sp[0x1c],r8
8000894a:	cb 6b       	rjmp	800088b6 <_vfprintf_r+0x7b6>
8000894c:	41 09       	lddsp	r9,sp[0x40]
8000894e:	59 f8       	cp.w	r8,31
80008950:	e0 89 00 15 	brgt	8000897a <_vfprintf_r+0x87a>
80008954:	f2 ca ff f8 	sub	r10,r9,-8
80008958:	72 16       	ld.w	r6,r9[0x4]
8000895a:	72 09       	ld.w	r9,r9[0x0]
8000895c:	51 0a       	stdsp	sp[0x40],r10
8000895e:	50 59       	stdsp	sp[0x14],r9
80008960:	fa ce f9 44 	sub	lr,sp,-1724
80008964:	50 76       	stdsp	sp[0x1c],r6
80008966:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000896a:	40 5b       	lddsp	r11,sp[0x14]
8000896c:	0c 9a       	mov	r10,r6
8000896e:	f2 eb fd 88 	st.d	r9[-632],r10
80008972:	2f f8       	sub	r8,-1
80008974:	fb 48 06 b4 	st.w	sp[1716],r8
80008978:	c0 88       	rjmp	80008988 <_vfprintf_r+0x888>
8000897a:	72 1c       	ld.w	r12,r9[0x4]
8000897c:	50 7c       	stdsp	sp[0x1c],r12
8000897e:	f2 c8 ff f8 	sub	r8,r9,-8
80008982:	51 08       	stdsp	sp[0x40],r8
80008984:	72 09       	ld.w	r9,r9[0x0]
80008986:	50 59       	stdsp	sp[0x14],r9
80008988:	40 5b       	lddsp	r11,sp[0x14]
8000898a:	40 7a       	lddsp	r10,sp[0x1c]
8000898c:	e0 a0 19 54 	rcall	8000bc34 <__isinfd>
80008990:	18 96       	mov	r6,r12
80008992:	c1 70       	breq	800089c0 <_vfprintf_r+0x8c0>
80008994:	30 08       	mov	r8,0
80008996:	30 09       	mov	r9,0
80008998:	40 5b       	lddsp	r11,sp[0x14]
8000899a:	40 7a       	lddsp	r10,sp[0x1c]
8000899c:	e0 a0 1d b4 	rcall	8000c504 <__avr32_f64_cmp_lt>
800089a0:	c0 40       	breq	800089a8 <_vfprintf_r+0x8a8>
800089a2:	32 d8       	mov	r8,45
800089a4:	fb 68 06 bb 	st.b	sp[1723],r8
800089a8:	fe c8 a9 e8 	sub	r8,pc,-22040
800089ac:	fe c6 a9 e8 	sub	r6,pc,-22040
800089b0:	a7 d5       	cbr	r5,0x7
800089b2:	e0 40 00 47 	cp.w	r0,71
800089b6:	f0 06 17 a0 	movle	r6,r8
800089ba:	30 32       	mov	r2,3
800089bc:	e0 8f 06 ce 	bral	80009758 <_vfprintf_r+0x1658>
800089c0:	40 5b       	lddsp	r11,sp[0x14]
800089c2:	40 7a       	lddsp	r10,sp[0x1c]
800089c4:	e0 a0 19 4d 	rcall	8000bc5e <__isnand>
800089c8:	c0 e0       	breq	800089e4 <_vfprintf_r+0x8e4>
800089ca:	50 26       	stdsp	sp[0x8],r6
800089cc:	fe c8 aa 04 	sub	r8,pc,-22012
800089d0:	fe c6 aa 04 	sub	r6,pc,-22012
800089d4:	a7 d5       	cbr	r5,0x7
800089d6:	e0 40 00 47 	cp.w	r0,71
800089da:	f0 06 17 a0 	movle	r6,r8
800089de:	30 32       	mov	r2,3
800089e0:	e0 8f 06 c2 	bral	80009764 <_vfprintf_r+0x1664>
800089e4:	40 2a       	lddsp	r10,sp[0x8]
800089e6:	5b fa       	cp.w	r10,-1
800089e8:	c0 41       	brne	800089f0 <_vfprintf_r+0x8f0>
800089ea:	30 69       	mov	r9,6
800089ec:	50 29       	stdsp	sp[0x8],r9
800089ee:	c1 18       	rjmp	80008a10 <_vfprintf_r+0x910>
800089f0:	e0 40 00 47 	cp.w	r0,71
800089f4:	5f 09       	sreq	r9
800089f6:	e0 40 00 67 	cp.w	r0,103
800089fa:	5f 08       	sreq	r8
800089fc:	f3 e8 10 08 	or	r8,r9,r8
80008a00:	f8 08 18 00 	cp.b	r8,r12
80008a04:	c0 60       	breq	80008a10 <_vfprintf_r+0x910>
80008a06:	40 28       	lddsp	r8,sp[0x8]
80008a08:	58 08       	cp.w	r8,0
80008a0a:	f9 b8 00 01 	moveq	r8,1
80008a0e:	50 28       	stdsp	sp[0x8],r8
80008a10:	40 78       	lddsp	r8,sp[0x1c]
80008a12:	40 59       	lddsp	r9,sp[0x14]
80008a14:	fa e9 06 94 	st.d	sp[1684],r8
80008a18:	a9 a5       	sbr	r5,0x8
80008a1a:	fa f8 06 94 	ld.w	r8,sp[1684]
80008a1e:	58 08       	cp.w	r8,0
80008a20:	c0 65       	brlt	80008a2c <_vfprintf_r+0x92c>
80008a22:	40 5e       	lddsp	lr,sp[0x14]
80008a24:	30 0c       	mov	r12,0
80008a26:	50 6e       	stdsp	sp[0x18],lr
80008a28:	50 9c       	stdsp	sp[0x24],r12
80008a2a:	c0 78       	rjmp	80008a38 <_vfprintf_r+0x938>
80008a2c:	40 5b       	lddsp	r11,sp[0x14]
80008a2e:	32 da       	mov	r10,45
80008a30:	ee 1b 80 00 	eorh	r11,0x8000
80008a34:	50 9a       	stdsp	sp[0x24],r10
80008a36:	50 6b       	stdsp	sp[0x18],r11
80008a38:	e0 40 00 46 	cp.w	r0,70
80008a3c:	5f 09       	sreq	r9
80008a3e:	e0 40 00 66 	cp.w	r0,102
80008a42:	5f 08       	sreq	r8
80008a44:	f3 e8 10 08 	or	r8,r9,r8
80008a48:	50 48       	stdsp	sp[0x10],r8
80008a4a:	c0 40       	breq	80008a52 <_vfprintf_r+0x952>
80008a4c:	40 22       	lddsp	r2,sp[0x8]
80008a4e:	30 39       	mov	r9,3
80008a50:	c1 08       	rjmp	80008a70 <_vfprintf_r+0x970>
80008a52:	e0 40 00 45 	cp.w	r0,69
80008a56:	5f 09       	sreq	r9
80008a58:	e0 40 00 65 	cp.w	r0,101
80008a5c:	5f 08       	sreq	r8
80008a5e:	40 22       	lddsp	r2,sp[0x8]
80008a60:	10 49       	or	r9,r8
80008a62:	2f f2       	sub	r2,-1
80008a64:	40 46       	lddsp	r6,sp[0x10]
80008a66:	ec 09 18 00 	cp.b	r9,r6
80008a6a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008a6e:	30 29       	mov	r9,2
80008a70:	fa c8 f9 5c 	sub	r8,sp,-1700
80008a74:	1a d8       	st.w	--sp,r8
80008a76:	fa c8 f9 54 	sub	r8,sp,-1708
80008a7a:	1a d8       	st.w	--sp,r8
80008a7c:	fa c8 f9 4c 	sub	r8,sp,-1716
80008a80:	08 9c       	mov	r12,r4
80008a82:	1a d8       	st.w	--sp,r8
80008a84:	04 98       	mov	r8,r2
80008a86:	40 9b       	lddsp	r11,sp[0x24]
80008a88:	40 aa       	lddsp	r10,sp[0x28]
80008a8a:	e0 a0 0b c3 	rcall	8000a210 <_dtoa_r>
80008a8e:	e0 40 00 47 	cp.w	r0,71
80008a92:	5f 19       	srne	r9
80008a94:	e0 40 00 67 	cp.w	r0,103
80008a98:	5f 18       	srne	r8
80008a9a:	18 96       	mov	r6,r12
80008a9c:	2f dd       	sub	sp,-12
80008a9e:	f3 e8 00 08 	and	r8,r9,r8
80008aa2:	c0 41       	brne	80008aaa <_vfprintf_r+0x9aa>
80008aa4:	ed b5 00 00 	bld	r5,0x0
80008aa8:	c3 01       	brne	80008b08 <_vfprintf_r+0xa08>
80008aaa:	ec 02 00 0e 	add	lr,r6,r2
80008aae:	50 3e       	stdsp	sp[0xc],lr
80008ab0:	40 4c       	lddsp	r12,sp[0x10]
80008ab2:	58 0c       	cp.w	r12,0
80008ab4:	c1 50       	breq	80008ade <_vfprintf_r+0x9de>
80008ab6:	0d 89       	ld.ub	r9,r6[0x0]
80008ab8:	33 08       	mov	r8,48
80008aba:	f0 09 18 00 	cp.b	r9,r8
80008abe:	c0 b1       	brne	80008ad4 <_vfprintf_r+0x9d4>
80008ac0:	30 08       	mov	r8,0
80008ac2:	30 09       	mov	r9,0
80008ac4:	40 6b       	lddsp	r11,sp[0x18]
80008ac6:	40 7a       	lddsp	r10,sp[0x1c]
80008ac8:	e0 a0 1c d7 	rcall	8000c476 <__avr32_f64_cmp_eq>
80008acc:	fb b2 00 01 	rsubeq	r2,1
80008ad0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008ad4:	40 3b       	lddsp	r11,sp[0xc]
80008ad6:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ada:	10 0b       	add	r11,r8
80008adc:	50 3b       	stdsp	sp[0xc],r11
80008ade:	40 6b       	lddsp	r11,sp[0x18]
80008ae0:	30 08       	mov	r8,0
80008ae2:	30 09       	mov	r9,0
80008ae4:	40 7a       	lddsp	r10,sp[0x1c]
80008ae6:	e0 a0 1c c8 	rcall	8000c476 <__avr32_f64_cmp_eq>
80008aea:	c0 90       	breq	80008afc <_vfprintf_r+0x9fc>
80008aec:	40 3a       	lddsp	r10,sp[0xc]
80008aee:	fb 4a 06 a4 	st.w	sp[1700],r10
80008af2:	c0 58       	rjmp	80008afc <_vfprintf_r+0x9fc>
80008af4:	10 c9       	st.b	r8++,r9
80008af6:	fb 48 06 a4 	st.w	sp[1700],r8
80008afa:	c0 28       	rjmp	80008afe <_vfprintf_r+0x9fe>
80008afc:	33 09       	mov	r9,48
80008afe:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008b02:	40 3e       	lddsp	lr,sp[0xc]
80008b04:	1c 38       	cp.w	r8,lr
80008b06:	cf 73       	brcs	80008af4 <_vfprintf_r+0x9f4>
80008b08:	e0 40 00 47 	cp.w	r0,71
80008b0c:	5f 09       	sreq	r9
80008b0e:	e0 40 00 67 	cp.w	r0,103
80008b12:	5f 08       	sreq	r8
80008b14:	f3 e8 10 08 	or	r8,r9,r8
80008b18:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008b1c:	0c 19       	sub	r9,r6
80008b1e:	50 69       	stdsp	sp[0x18],r9
80008b20:	58 08       	cp.w	r8,0
80008b22:	c0 b0       	breq	80008b38 <_vfprintf_r+0xa38>
80008b24:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b28:	5b d8       	cp.w	r8,-3
80008b2a:	c0 55       	brlt	80008b34 <_vfprintf_r+0xa34>
80008b2c:	40 2c       	lddsp	r12,sp[0x8]
80008b2e:	18 38       	cp.w	r8,r12
80008b30:	e0 8a 00 6a 	brle	80008c04 <_vfprintf_r+0xb04>
80008b34:	20 20       	sub	r0,2
80008b36:	c0 58       	rjmp	80008b40 <_vfprintf_r+0xa40>
80008b38:	e0 40 00 65 	cp.w	r0,101
80008b3c:	e0 89 00 46 	brgt	80008bc8 <_vfprintf_r+0xac8>
80008b40:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008b44:	fb 60 06 9c 	st.b	sp[1692],r0
80008b48:	20 1b       	sub	r11,1
80008b4a:	fb 4b 06 ac 	st.w	sp[1708],r11
80008b4e:	c0 47       	brpl	80008b56 <_vfprintf_r+0xa56>
80008b50:	5c 3b       	neg	r11
80008b52:	32 d8       	mov	r8,45
80008b54:	c0 28       	rjmp	80008b58 <_vfprintf_r+0xa58>
80008b56:	32 b8       	mov	r8,43
80008b58:	fb 68 06 9d 	st.b	sp[1693],r8
80008b5c:	58 9b       	cp.w	r11,9
80008b5e:	e0 8a 00 1d 	brle	80008b98 <_vfprintf_r+0xa98>
80008b62:	fa c9 fa 35 	sub	r9,sp,-1483
80008b66:	30 aa       	mov	r10,10
80008b68:	12 98       	mov	r8,r9
80008b6a:	0e 9c       	mov	r12,r7
80008b6c:	0c 92       	mov	r2,r6
80008b6e:	f6 0a 0c 06 	divs	r6,r11,r10
80008b72:	0e 9b       	mov	r11,r7
80008b74:	2d 0b       	sub	r11,-48
80008b76:	10 fb       	st.b	--r8,r11
80008b78:	0c 9b       	mov	r11,r6
80008b7a:	58 96       	cp.w	r6,9
80008b7c:	fe 99 ff f9 	brgt	80008b6e <_vfprintf_r+0xa6e>
80008b80:	2d 0b       	sub	r11,-48
80008b82:	18 97       	mov	r7,r12
80008b84:	04 96       	mov	r6,r2
80008b86:	10 fb       	st.b	--r8,r11
80008b88:	fa ca f9 62 	sub	r10,sp,-1694
80008b8c:	c0 38       	rjmp	80008b92 <_vfprintf_r+0xa92>
80008b8e:	11 3b       	ld.ub	r11,r8++
80008b90:	14 cb       	st.b	r10++,r11
80008b92:	12 38       	cp.w	r8,r9
80008b94:	cf d3       	brcs	80008b8e <_vfprintf_r+0xa8e>
80008b96:	c0 98       	rjmp	80008ba8 <_vfprintf_r+0xaa8>
80008b98:	2d 0b       	sub	r11,-48
80008b9a:	33 08       	mov	r8,48
80008b9c:	fb 6b 06 9f 	st.b	sp[1695],r11
80008ba0:	fb 68 06 9e 	st.b	sp[1694],r8
80008ba4:	fa ca f9 60 	sub	r10,sp,-1696
80008ba8:	fa c8 f9 64 	sub	r8,sp,-1692
80008bac:	f4 08 01 08 	sub	r8,r10,r8
80008bb0:	50 e8       	stdsp	sp[0x38],r8
80008bb2:	10 92       	mov	r2,r8
80008bb4:	40 6b       	lddsp	r11,sp[0x18]
80008bb6:	16 02       	add	r2,r11
80008bb8:	58 1b       	cp.w	r11,1
80008bba:	e0 89 00 05 	brgt	80008bc4 <_vfprintf_r+0xac4>
80008bbe:	ed b5 00 00 	bld	r5,0x0
80008bc2:	c3 51       	brne	80008c2c <_vfprintf_r+0xb2c>
80008bc4:	2f f2       	sub	r2,-1
80008bc6:	c3 38       	rjmp	80008c2c <_vfprintf_r+0xb2c>
80008bc8:	e0 40 00 66 	cp.w	r0,102
80008bcc:	c1 c1       	brne	80008c04 <_vfprintf_r+0xb04>
80008bce:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008bd2:	58 02       	cp.w	r2,0
80008bd4:	e0 8a 00 0c 	brle	80008bec <_vfprintf_r+0xaec>
80008bd8:	40 2a       	lddsp	r10,sp[0x8]
80008bda:	58 0a       	cp.w	r10,0
80008bdc:	c0 41       	brne	80008be4 <_vfprintf_r+0xae4>
80008bde:	ed b5 00 00 	bld	r5,0x0
80008be2:	c2 51       	brne	80008c2c <_vfprintf_r+0xb2c>
80008be4:	2f f2       	sub	r2,-1
80008be6:	40 29       	lddsp	r9,sp[0x8]
80008be8:	12 02       	add	r2,r9
80008bea:	c0 b8       	rjmp	80008c00 <_vfprintf_r+0xb00>
80008bec:	40 28       	lddsp	r8,sp[0x8]
80008bee:	58 08       	cp.w	r8,0
80008bf0:	c0 61       	brne	80008bfc <_vfprintf_r+0xafc>
80008bf2:	ed b5 00 00 	bld	r5,0x0
80008bf6:	c0 30       	breq	80008bfc <_vfprintf_r+0xafc>
80008bf8:	30 12       	mov	r2,1
80008bfa:	c1 98       	rjmp	80008c2c <_vfprintf_r+0xb2c>
80008bfc:	40 22       	lddsp	r2,sp[0x8]
80008bfe:	2f e2       	sub	r2,-2
80008c00:	36 60       	mov	r0,102
80008c02:	c1 58       	rjmp	80008c2c <_vfprintf_r+0xb2c>
80008c04:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c08:	40 6e       	lddsp	lr,sp[0x18]
80008c0a:	1c 32       	cp.w	r2,lr
80008c0c:	c0 65       	brlt	80008c18 <_vfprintf_r+0xb18>
80008c0e:	ed b5 00 00 	bld	r5,0x0
80008c12:	f7 b2 00 ff 	subeq	r2,-1
80008c16:	c0 a8       	rjmp	80008c2a <_vfprintf_r+0xb2a>
80008c18:	e4 08 11 02 	rsub	r8,r2,2
80008c1c:	40 6c       	lddsp	r12,sp[0x18]
80008c1e:	58 02       	cp.w	r2,0
80008c20:	f0 02 17 a0 	movle	r2,r8
80008c24:	f9 b2 09 01 	movgt	r2,1
80008c28:	18 02       	add	r2,r12
80008c2a:	36 70       	mov	r0,103
80008c2c:	40 9b       	lddsp	r11,sp[0x24]
80008c2e:	58 0b       	cp.w	r11,0
80008c30:	e0 80 05 94 	breq	80009758 <_vfprintf_r+0x1658>
80008c34:	32 d8       	mov	r8,45
80008c36:	fb 68 06 bb 	st.b	sp[1723],r8
80008c3a:	e0 8f 05 93 	bral	80009760 <_vfprintf_r+0x1660>
80008c3e:	50 a7       	stdsp	sp[0x28],r7
80008c40:	04 94       	mov	r4,r2
80008c42:	0c 97       	mov	r7,r6
80008c44:	02 92       	mov	r2,r1
80008c46:	06 96       	mov	r6,r3
80008c48:	40 41       	lddsp	r1,sp[0x10]
80008c4a:	40 93       	lddsp	r3,sp[0x24]
80008c4c:	0e 99       	mov	r9,r7
80008c4e:	ed b5 00 05 	bld	r5,0x5
80008c52:	c4 81       	brne	80008ce2 <_vfprintf_r+0xbe2>
80008c54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c58:	40 3e       	lddsp	lr,sp[0xc]
80008c5a:	58 0e       	cp.w	lr,0
80008c5c:	c1 d0       	breq	80008c96 <_vfprintf_r+0xb96>
80008c5e:	10 36       	cp.w	r6,r8
80008c60:	c0 64       	brge	80008c6c <_vfprintf_r+0xb6c>
80008c62:	fa cc f9 44 	sub	r12,sp,-1724
80008c66:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c6a:	c1 d8       	rjmp	80008ca4 <_vfprintf_r+0xba4>
80008c6c:	fa c8 f9 50 	sub	r8,sp,-1712
80008c70:	1a d8       	st.w	--sp,r8
80008c72:	fa c8 fa b8 	sub	r8,sp,-1352
80008c76:	04 9a       	mov	r10,r2
80008c78:	1a d8       	st.w	--sp,r8
80008c7a:	fa c8 fb b4 	sub	r8,sp,-1100
80008c7e:	0c 9b       	mov	r11,r6
80008c80:	1a d8       	st.w	--sp,r8
80008c82:	08 9c       	mov	r12,r4
80008c84:	fa c8 f9 40 	sub	r8,sp,-1728
80008c88:	fa c9 ff b4 	sub	r9,sp,-76
80008c8c:	fe b0 f8 a2 	rcall	80007dd0 <get_arg>
80008c90:	2f dd       	sub	sp,-12
80008c92:	78 0a       	ld.w	r10,r12[0x0]
80008c94:	c2 08       	rjmp	80008cd4 <_vfprintf_r+0xbd4>
80008c96:	2f f7       	sub	r7,-1
80008c98:	10 39       	cp.w	r9,r8
80008c9a:	c0 84       	brge	80008caa <_vfprintf_r+0xbaa>
80008c9c:	fa cb f9 44 	sub	r11,sp,-1724
80008ca0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ca4:	ec fa fd 88 	ld.w	r10,r6[-632]
80008ca8:	c1 68       	rjmp	80008cd4 <_vfprintf_r+0xbd4>
80008caa:	41 09       	lddsp	r9,sp[0x40]
80008cac:	59 f8       	cp.w	r8,31
80008cae:	e0 89 00 10 	brgt	80008cce <_vfprintf_r+0xbce>
80008cb2:	f2 ca ff fc 	sub	r10,r9,-4
80008cb6:	51 0a       	stdsp	sp[0x40],r10
80008cb8:	fa c6 f9 44 	sub	r6,sp,-1724
80008cbc:	72 0a       	ld.w	r10,r9[0x0]
80008cbe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cc2:	f3 4a fd 88 	st.w	r9[-632],r10
80008cc6:	2f f8       	sub	r8,-1
80008cc8:	fb 48 06 b4 	st.w	sp[1716],r8
80008ccc:	c0 48       	rjmp	80008cd4 <_vfprintf_r+0xbd4>
80008cce:	72 0a       	ld.w	r10,r9[0x0]
80008cd0:	2f c9       	sub	r9,-4
80008cd2:	51 09       	stdsp	sp[0x40],r9
80008cd4:	40 be       	lddsp	lr,sp[0x2c]
80008cd6:	1c 98       	mov	r8,lr
80008cd8:	95 1e       	st.w	r10[0x4],lr
80008cda:	bf 58       	asr	r8,0x1f
80008cdc:	95 08       	st.w	r10[0x0],r8
80008cde:	fe 9f fa 9f 	bral	8000821c <_vfprintf_r+0x11c>
80008ce2:	ed b5 00 04 	bld	r5,0x4
80008ce6:	c4 80       	breq	80008d76 <_vfprintf_r+0xc76>
80008ce8:	e2 15 00 40 	andl	r5,0x40,COH
80008cec:	c4 50       	breq	80008d76 <_vfprintf_r+0xc76>
80008cee:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cf2:	40 3c       	lddsp	r12,sp[0xc]
80008cf4:	58 0c       	cp.w	r12,0
80008cf6:	c1 d0       	breq	80008d30 <_vfprintf_r+0xc30>
80008cf8:	10 36       	cp.w	r6,r8
80008cfa:	c0 64       	brge	80008d06 <_vfprintf_r+0xc06>
80008cfc:	fa cb f9 44 	sub	r11,sp,-1724
80008d00:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d04:	c1 d8       	rjmp	80008d3e <_vfprintf_r+0xc3e>
80008d06:	fa c8 f9 50 	sub	r8,sp,-1712
80008d0a:	1a d8       	st.w	--sp,r8
80008d0c:	fa c8 fa b8 	sub	r8,sp,-1352
80008d10:	04 9a       	mov	r10,r2
80008d12:	1a d8       	st.w	--sp,r8
80008d14:	fa c8 fb b4 	sub	r8,sp,-1100
80008d18:	0c 9b       	mov	r11,r6
80008d1a:	1a d8       	st.w	--sp,r8
80008d1c:	08 9c       	mov	r12,r4
80008d1e:	fa c8 f9 40 	sub	r8,sp,-1728
80008d22:	fa c9 ff b4 	sub	r9,sp,-76
80008d26:	fe b0 f8 55 	rcall	80007dd0 <get_arg>
80008d2a:	2f dd       	sub	sp,-12
80008d2c:	78 0a       	ld.w	r10,r12[0x0]
80008d2e:	c2 08       	rjmp	80008d6e <_vfprintf_r+0xc6e>
80008d30:	2f f7       	sub	r7,-1
80008d32:	10 39       	cp.w	r9,r8
80008d34:	c0 84       	brge	80008d44 <_vfprintf_r+0xc44>
80008d36:	fa ca f9 44 	sub	r10,sp,-1724
80008d3a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d3e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d42:	c1 68       	rjmp	80008d6e <_vfprintf_r+0xc6e>
80008d44:	41 09       	lddsp	r9,sp[0x40]
80008d46:	59 f8       	cp.w	r8,31
80008d48:	e0 89 00 10 	brgt	80008d68 <_vfprintf_r+0xc68>
80008d4c:	f2 ca ff fc 	sub	r10,r9,-4
80008d50:	51 0a       	stdsp	sp[0x40],r10
80008d52:	fa c6 f9 44 	sub	r6,sp,-1724
80008d56:	72 0a       	ld.w	r10,r9[0x0]
80008d58:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d5c:	f3 4a fd 88 	st.w	r9[-632],r10
80008d60:	2f f8       	sub	r8,-1
80008d62:	fb 48 06 b4 	st.w	sp[1716],r8
80008d66:	c0 48       	rjmp	80008d6e <_vfprintf_r+0xc6e>
80008d68:	72 0a       	ld.w	r10,r9[0x0]
80008d6a:	2f c9       	sub	r9,-4
80008d6c:	51 09       	stdsp	sp[0x40],r9
80008d6e:	40 be       	lddsp	lr,sp[0x2c]
80008d70:	b4 0e       	st.h	r10[0x0],lr
80008d72:	fe 9f fa 55 	bral	8000821c <_vfprintf_r+0x11c>
80008d76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d7a:	40 3c       	lddsp	r12,sp[0xc]
80008d7c:	58 0c       	cp.w	r12,0
80008d7e:	c1 d0       	breq	80008db8 <_vfprintf_r+0xcb8>
80008d80:	10 36       	cp.w	r6,r8
80008d82:	c0 64       	brge	80008d8e <_vfprintf_r+0xc8e>
80008d84:	fa cb f9 44 	sub	r11,sp,-1724
80008d88:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d8c:	c1 d8       	rjmp	80008dc6 <_vfprintf_r+0xcc6>
80008d8e:	fa c8 f9 50 	sub	r8,sp,-1712
80008d92:	1a d8       	st.w	--sp,r8
80008d94:	fa c8 fa b8 	sub	r8,sp,-1352
80008d98:	04 9a       	mov	r10,r2
80008d9a:	1a d8       	st.w	--sp,r8
80008d9c:	fa c8 fb b4 	sub	r8,sp,-1100
80008da0:	0c 9b       	mov	r11,r6
80008da2:	1a d8       	st.w	--sp,r8
80008da4:	08 9c       	mov	r12,r4
80008da6:	fa c8 f9 40 	sub	r8,sp,-1728
80008daa:	fa c9 ff b4 	sub	r9,sp,-76
80008dae:	fe b0 f8 11 	rcall	80007dd0 <get_arg>
80008db2:	2f dd       	sub	sp,-12
80008db4:	78 0a       	ld.w	r10,r12[0x0]
80008db6:	c2 08       	rjmp	80008df6 <_vfprintf_r+0xcf6>
80008db8:	2f f7       	sub	r7,-1
80008dba:	10 39       	cp.w	r9,r8
80008dbc:	c0 84       	brge	80008dcc <_vfprintf_r+0xccc>
80008dbe:	fa ca f9 44 	sub	r10,sp,-1724
80008dc2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008dc6:	ec fa fd 88 	ld.w	r10,r6[-632]
80008dca:	c1 68       	rjmp	80008df6 <_vfprintf_r+0xcf6>
80008dcc:	41 09       	lddsp	r9,sp[0x40]
80008dce:	59 f8       	cp.w	r8,31
80008dd0:	e0 89 00 10 	brgt	80008df0 <_vfprintf_r+0xcf0>
80008dd4:	f2 ca ff fc 	sub	r10,r9,-4
80008dd8:	51 0a       	stdsp	sp[0x40],r10
80008dda:	fa c6 f9 44 	sub	r6,sp,-1724
80008dde:	72 0a       	ld.w	r10,r9[0x0]
80008de0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008de4:	f3 4a fd 88 	st.w	r9[-632],r10
80008de8:	2f f8       	sub	r8,-1
80008dea:	fb 48 06 b4 	st.w	sp[1716],r8
80008dee:	c0 48       	rjmp	80008df6 <_vfprintf_r+0xcf6>
80008df0:	72 0a       	ld.w	r10,r9[0x0]
80008df2:	2f c9       	sub	r9,-4
80008df4:	51 09       	stdsp	sp[0x40],r9
80008df6:	40 be       	lddsp	lr,sp[0x2c]
80008df8:	95 0e       	st.w	r10[0x0],lr
80008dfa:	fe 9f fa 11 	bral	8000821c <_vfprintf_r+0x11c>
80008dfe:	50 a7       	stdsp	sp[0x28],r7
80008e00:	50 80       	stdsp	sp[0x20],r0
80008e02:	0c 97       	mov	r7,r6
80008e04:	04 94       	mov	r4,r2
80008e06:	06 96       	mov	r6,r3
80008e08:	02 92       	mov	r2,r1
80008e0a:	40 93       	lddsp	r3,sp[0x24]
80008e0c:	10 90       	mov	r0,r8
80008e0e:	40 41       	lddsp	r1,sp[0x10]
80008e10:	a5 a5       	sbr	r5,0x4
80008e12:	c0 a8       	rjmp	80008e26 <_vfprintf_r+0xd26>
80008e14:	50 a7       	stdsp	sp[0x28],r7
80008e16:	50 80       	stdsp	sp[0x20],r0
80008e18:	0c 97       	mov	r7,r6
80008e1a:	04 94       	mov	r4,r2
80008e1c:	06 96       	mov	r6,r3
80008e1e:	02 92       	mov	r2,r1
80008e20:	40 93       	lddsp	r3,sp[0x24]
80008e22:	10 90       	mov	r0,r8
80008e24:	40 41       	lddsp	r1,sp[0x10]
80008e26:	ed b5 00 05 	bld	r5,0x5
80008e2a:	c5 d1       	brne	80008ee4 <_vfprintf_r+0xde4>
80008e2c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e30:	40 3c       	lddsp	r12,sp[0xc]
80008e32:	58 0c       	cp.w	r12,0
80008e34:	c2 60       	breq	80008e80 <_vfprintf_r+0xd80>
80008e36:	10 36       	cp.w	r6,r8
80008e38:	c0 a4       	brge	80008e4c <_vfprintf_r+0xd4c>
80008e3a:	fa cb f9 44 	sub	r11,sp,-1724
80008e3e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e42:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e46:	fa e9 00 00 	st.d	sp[0],r8
80008e4a:	c1 88       	rjmp	80008e7a <_vfprintf_r+0xd7a>
80008e4c:	fa c8 f9 50 	sub	r8,sp,-1712
80008e50:	1a d8       	st.w	--sp,r8
80008e52:	fa c8 fa b8 	sub	r8,sp,-1352
80008e56:	04 9a       	mov	r10,r2
80008e58:	1a d8       	st.w	--sp,r8
80008e5a:	0c 9b       	mov	r11,r6
80008e5c:	fa c8 fb b4 	sub	r8,sp,-1100
80008e60:	08 9c       	mov	r12,r4
80008e62:	1a d8       	st.w	--sp,r8
80008e64:	fa c8 f9 40 	sub	r8,sp,-1728
80008e68:	fa c9 ff b4 	sub	r9,sp,-76
80008e6c:	fe b0 f7 b2 	rcall	80007dd0 <get_arg>
80008e70:	2f dd       	sub	sp,-12
80008e72:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e76:	fa eb 00 00 	st.d	sp[0],r10
80008e7a:	30 08       	mov	r8,0
80008e7c:	e0 8f 03 de 	bral	80009638 <_vfprintf_r+0x1538>
80008e80:	ee ca ff ff 	sub	r10,r7,-1
80008e84:	10 37       	cp.w	r7,r8
80008e86:	c0 b4       	brge	80008e9c <_vfprintf_r+0xd9c>
80008e88:	fa c9 f9 44 	sub	r9,sp,-1724
80008e8c:	14 97       	mov	r7,r10
80008e8e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e92:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e96:	fa eb 00 00 	st.d	sp[0],r10
80008e9a:	c1 88       	rjmp	80008eca <_vfprintf_r+0xdca>
80008e9c:	41 09       	lddsp	r9,sp[0x40]
80008e9e:	59 f8       	cp.w	r8,31
80008ea0:	e0 89 00 18 	brgt	80008ed0 <_vfprintf_r+0xdd0>
80008ea4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ea8:	f2 cb ff f8 	sub	r11,r9,-8
80008eac:	fa e7 00 00 	st.d	sp[0],r6
80008eb0:	51 0b       	stdsp	sp[0x40],r11
80008eb2:	fa c6 f9 44 	sub	r6,sp,-1724
80008eb6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008eba:	fa e6 00 00 	ld.d	r6,sp[0]
80008ebe:	f2 e7 fd 88 	st.d	r9[-632],r6
80008ec2:	2f f8       	sub	r8,-1
80008ec4:	14 97       	mov	r7,r10
80008ec6:	fb 48 06 b4 	st.w	sp[1716],r8
80008eca:	40 38       	lddsp	r8,sp[0xc]
80008ecc:	e0 8f 03 b6 	bral	80009638 <_vfprintf_r+0x1538>
80008ed0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ed4:	40 38       	lddsp	r8,sp[0xc]
80008ed6:	fa e7 00 00 	st.d	sp[0],r6
80008eda:	2f 89       	sub	r9,-8
80008edc:	14 97       	mov	r7,r10
80008ede:	51 09       	stdsp	sp[0x40],r9
80008ee0:	e0 8f 03 ac 	bral	80009638 <_vfprintf_r+0x1538>
80008ee4:	ed b5 00 04 	bld	r5,0x4
80008ee8:	c1 61       	brne	80008f14 <_vfprintf_r+0xe14>
80008eea:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008eee:	40 3e       	lddsp	lr,sp[0xc]
80008ef0:	58 0e       	cp.w	lr,0
80008ef2:	c0 80       	breq	80008f02 <_vfprintf_r+0xe02>
80008ef4:	10 36       	cp.w	r6,r8
80008ef6:	c6 74       	brge	80008fc4 <_vfprintf_r+0xec4>
80008ef8:	fa cc f9 44 	sub	r12,sp,-1724
80008efc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f00:	c8 08       	rjmp	80009000 <_vfprintf_r+0xf00>
80008f02:	ee ca ff ff 	sub	r10,r7,-1
80008f06:	10 37       	cp.w	r7,r8
80008f08:	c7 f4       	brge	80009006 <_vfprintf_r+0xf06>
80008f0a:	fa cb f9 44 	sub	r11,sp,-1724
80008f0e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f12:	c7 68       	rjmp	80008ffe <_vfprintf_r+0xefe>
80008f14:	ed b5 00 06 	bld	r5,0x6
80008f18:	c4 a1       	brne	80008fac <_vfprintf_r+0xeac>
80008f1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f1e:	40 3c       	lddsp	r12,sp[0xc]
80008f20:	58 0c       	cp.w	r12,0
80008f22:	c1 d0       	breq	80008f5c <_vfprintf_r+0xe5c>
80008f24:	10 36       	cp.w	r6,r8
80008f26:	c0 64       	brge	80008f32 <_vfprintf_r+0xe32>
80008f28:	fa cb f9 44 	sub	r11,sp,-1724
80008f2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f30:	c1 f8       	rjmp	80008f6e <_vfprintf_r+0xe6e>
80008f32:	fa c8 f9 50 	sub	r8,sp,-1712
80008f36:	1a d8       	st.w	--sp,r8
80008f38:	fa c8 fa b8 	sub	r8,sp,-1352
80008f3c:	1a d8       	st.w	--sp,r8
80008f3e:	fa c8 fb b4 	sub	r8,sp,-1100
80008f42:	1a d8       	st.w	--sp,r8
80008f44:	fa c8 f9 40 	sub	r8,sp,-1728
80008f48:	fa c9 ff b4 	sub	r9,sp,-76
80008f4c:	04 9a       	mov	r10,r2
80008f4e:	0c 9b       	mov	r11,r6
80008f50:	08 9c       	mov	r12,r4
80008f52:	fe b0 f7 3f 	rcall	80007dd0 <get_arg>
80008f56:	2f dd       	sub	sp,-12
80008f58:	98 18       	ld.sh	r8,r12[0x2]
80008f5a:	c2 68       	rjmp	80008fa6 <_vfprintf_r+0xea6>
80008f5c:	ee ca ff ff 	sub	r10,r7,-1
80008f60:	10 37       	cp.w	r7,r8
80008f62:	c0 94       	brge	80008f74 <_vfprintf_r+0xe74>
80008f64:	fa c9 f9 44 	sub	r9,sp,-1724
80008f68:	14 97       	mov	r7,r10
80008f6a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f6e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f72:	c1 a8       	rjmp	80008fa6 <_vfprintf_r+0xea6>
80008f74:	41 09       	lddsp	r9,sp[0x40]
80008f76:	59 f8       	cp.w	r8,31
80008f78:	e0 89 00 13 	brgt	80008f9e <_vfprintf_r+0xe9e>
80008f7c:	f2 cb ff fc 	sub	r11,r9,-4
80008f80:	51 0b       	stdsp	sp[0x40],r11
80008f82:	72 09       	ld.w	r9,r9[0x0]
80008f84:	fa c6 f9 44 	sub	r6,sp,-1724
80008f88:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f8c:	2f f8       	sub	r8,-1
80008f8e:	f7 49 fd 88 	st.w	r11[-632],r9
80008f92:	fb 48 06 b4 	st.w	sp[1716],r8
80008f96:	14 97       	mov	r7,r10
80008f98:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f9c:	c0 58       	rjmp	80008fa6 <_vfprintf_r+0xea6>
80008f9e:	92 18       	ld.sh	r8,r9[0x2]
80008fa0:	14 97       	mov	r7,r10
80008fa2:	2f c9       	sub	r9,-4
80008fa4:	51 09       	stdsp	sp[0x40],r9
80008fa6:	5c 78       	castu.h	r8
80008fa8:	50 18       	stdsp	sp[0x4],r8
80008faa:	c4 68       	rjmp	80009036 <_vfprintf_r+0xf36>
80008fac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fb0:	40 3c       	lddsp	r12,sp[0xc]
80008fb2:	58 0c       	cp.w	r12,0
80008fb4:	c1 d0       	breq	80008fee <_vfprintf_r+0xeee>
80008fb6:	10 36       	cp.w	r6,r8
80008fb8:	c0 64       	brge	80008fc4 <_vfprintf_r+0xec4>
80008fba:	fa cb f9 44 	sub	r11,sp,-1724
80008fbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fc2:	c1 f8       	rjmp	80009000 <_vfprintf_r+0xf00>
80008fc4:	fa c8 f9 50 	sub	r8,sp,-1712
80008fc8:	1a d8       	st.w	--sp,r8
80008fca:	fa c8 fa b8 	sub	r8,sp,-1352
80008fce:	0c 9b       	mov	r11,r6
80008fd0:	1a d8       	st.w	--sp,r8
80008fd2:	fa c8 fb b4 	sub	r8,sp,-1100
80008fd6:	04 9a       	mov	r10,r2
80008fd8:	1a d8       	st.w	--sp,r8
80008fda:	08 9c       	mov	r12,r4
80008fdc:	fa c8 f9 40 	sub	r8,sp,-1728
80008fe0:	fa c9 ff b4 	sub	r9,sp,-76
80008fe4:	fe b0 f6 f6 	rcall	80007dd0 <get_arg>
80008fe8:	2f dd       	sub	sp,-12
80008fea:	78 0b       	ld.w	r11,r12[0x0]
80008fec:	c2 48       	rjmp	80009034 <_vfprintf_r+0xf34>
80008fee:	ee ca ff ff 	sub	r10,r7,-1
80008ff2:	10 37       	cp.w	r7,r8
80008ff4:	c0 94       	brge	80009006 <_vfprintf_r+0xf06>
80008ff6:	fa c9 f9 44 	sub	r9,sp,-1724
80008ffa:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ffe:	14 97       	mov	r7,r10
80009000:	ec fb fd 88 	ld.w	r11,r6[-632]
80009004:	c1 88       	rjmp	80009034 <_vfprintf_r+0xf34>
80009006:	41 09       	lddsp	r9,sp[0x40]
80009008:	59 f8       	cp.w	r8,31
8000900a:	e0 89 00 11 	brgt	8000902c <_vfprintf_r+0xf2c>
8000900e:	f2 cb ff fc 	sub	r11,r9,-4
80009012:	51 0b       	stdsp	sp[0x40],r11
80009014:	fa c6 f9 44 	sub	r6,sp,-1724
80009018:	72 0b       	ld.w	r11,r9[0x0]
8000901a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000901e:	f3 4b fd 88 	st.w	r9[-632],r11
80009022:	2f f8       	sub	r8,-1
80009024:	14 97       	mov	r7,r10
80009026:	fb 48 06 b4 	st.w	sp[1716],r8
8000902a:	c0 58       	rjmp	80009034 <_vfprintf_r+0xf34>
8000902c:	72 0b       	ld.w	r11,r9[0x0]
8000902e:	14 97       	mov	r7,r10
80009030:	2f c9       	sub	r9,-4
80009032:	51 09       	stdsp	sp[0x40],r9
80009034:	50 1b       	stdsp	sp[0x4],r11
80009036:	30 0e       	mov	lr,0
80009038:	50 0e       	stdsp	sp[0x0],lr
8000903a:	1c 98       	mov	r8,lr
8000903c:	e0 8f 02 fe 	bral	80009638 <_vfprintf_r+0x1538>
80009040:	50 a7       	stdsp	sp[0x28],r7
80009042:	50 80       	stdsp	sp[0x20],r0
80009044:	0c 97       	mov	r7,r6
80009046:	04 94       	mov	r4,r2
80009048:	06 96       	mov	r6,r3
8000904a:	02 92       	mov	r2,r1
8000904c:	40 93       	lddsp	r3,sp[0x24]
8000904e:	40 41       	lddsp	r1,sp[0x10]
80009050:	0e 99       	mov	r9,r7
80009052:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009056:	40 3c       	lddsp	r12,sp[0xc]
80009058:	58 0c       	cp.w	r12,0
8000905a:	c1 d0       	breq	80009094 <_vfprintf_r+0xf94>
8000905c:	10 36       	cp.w	r6,r8
8000905e:	c0 64       	brge	8000906a <_vfprintf_r+0xf6a>
80009060:	fa cb f9 44 	sub	r11,sp,-1724
80009064:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009068:	c1 d8       	rjmp	800090a2 <_vfprintf_r+0xfa2>
8000906a:	fa c8 f9 50 	sub	r8,sp,-1712
8000906e:	1a d8       	st.w	--sp,r8
80009070:	fa c8 fa b8 	sub	r8,sp,-1352
80009074:	1a d8       	st.w	--sp,r8
80009076:	fa c8 fb b4 	sub	r8,sp,-1100
8000907a:	1a d8       	st.w	--sp,r8
8000907c:	fa c9 ff b4 	sub	r9,sp,-76
80009080:	fa c8 f9 40 	sub	r8,sp,-1728
80009084:	04 9a       	mov	r10,r2
80009086:	0c 9b       	mov	r11,r6
80009088:	08 9c       	mov	r12,r4
8000908a:	fe b0 f6 a3 	rcall	80007dd0 <get_arg>
8000908e:	2f dd       	sub	sp,-12
80009090:	78 09       	ld.w	r9,r12[0x0]
80009092:	c2 18       	rjmp	800090d4 <_vfprintf_r+0xfd4>
80009094:	2f f7       	sub	r7,-1
80009096:	10 39       	cp.w	r9,r8
80009098:	c0 84       	brge	800090a8 <_vfprintf_r+0xfa8>
8000909a:	fa ca f9 44 	sub	r10,sp,-1724
8000909e:	f4 06 00 36 	add	r6,r10,r6<<0x3
800090a2:	ec f9 fd 88 	ld.w	r9,r6[-632]
800090a6:	c1 78       	rjmp	800090d4 <_vfprintf_r+0xfd4>
800090a8:	41 09       	lddsp	r9,sp[0x40]
800090aa:	59 f8       	cp.w	r8,31
800090ac:	e0 89 00 10 	brgt	800090cc <_vfprintf_r+0xfcc>
800090b0:	f2 ca ff fc 	sub	r10,r9,-4
800090b4:	51 0a       	stdsp	sp[0x40],r10
800090b6:	fa c6 f9 44 	sub	r6,sp,-1724
800090ba:	72 09       	ld.w	r9,r9[0x0]
800090bc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800090c0:	f5 49 fd 88 	st.w	r10[-632],r9
800090c4:	2f f8       	sub	r8,-1
800090c6:	fb 48 06 b4 	st.w	sp[1716],r8
800090ca:	c0 58       	rjmp	800090d4 <_vfprintf_r+0xfd4>
800090cc:	f2 c8 ff fc 	sub	r8,r9,-4
800090d0:	51 08       	stdsp	sp[0x40],r8
800090d2:	72 09       	ld.w	r9,r9[0x0]
800090d4:	33 08       	mov	r8,48
800090d6:	fb 68 06 b8 	st.b	sp[1720],r8
800090da:	37 88       	mov	r8,120
800090dc:	30 0e       	mov	lr,0
800090de:	fb 68 06 b9 	st.b	sp[1721],r8
800090e2:	fe cc b1 12 	sub	r12,pc,-20206
800090e6:	50 19       	stdsp	sp[0x4],r9
800090e8:	a1 b5       	sbr	r5,0x1
800090ea:	50 0e       	stdsp	sp[0x0],lr
800090ec:	50 dc       	stdsp	sp[0x34],r12
800090ee:	30 28       	mov	r8,2
800090f0:	37 80       	mov	r0,120
800090f2:	e0 8f 02 a3 	bral	80009638 <_vfprintf_r+0x1538>
800090f6:	50 a7       	stdsp	sp[0x28],r7
800090f8:	50 80       	stdsp	sp[0x20],r0
800090fa:	10 90       	mov	r0,r8
800090fc:	30 08       	mov	r8,0
800090fe:	fb 68 06 bb 	st.b	sp[1723],r8
80009102:	0c 97       	mov	r7,r6
80009104:	04 94       	mov	r4,r2
80009106:	06 96       	mov	r6,r3
80009108:	02 92       	mov	r2,r1
8000910a:	40 93       	lddsp	r3,sp[0x24]
8000910c:	40 41       	lddsp	r1,sp[0x10]
8000910e:	0e 99       	mov	r9,r7
80009110:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009114:	40 3b       	lddsp	r11,sp[0xc]
80009116:	58 0b       	cp.w	r11,0
80009118:	c1 d0       	breq	80009152 <_vfprintf_r+0x1052>
8000911a:	10 36       	cp.w	r6,r8
8000911c:	c0 64       	brge	80009128 <_vfprintf_r+0x1028>
8000911e:	fa ca f9 44 	sub	r10,sp,-1724
80009122:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009126:	c1 d8       	rjmp	80009160 <_vfprintf_r+0x1060>
80009128:	fa c8 f9 50 	sub	r8,sp,-1712
8000912c:	1a d8       	st.w	--sp,r8
8000912e:	fa c8 fa b8 	sub	r8,sp,-1352
80009132:	1a d8       	st.w	--sp,r8
80009134:	fa c8 fb b4 	sub	r8,sp,-1100
80009138:	0c 9b       	mov	r11,r6
8000913a:	1a d8       	st.w	--sp,r8
8000913c:	04 9a       	mov	r10,r2
8000913e:	fa c8 f9 40 	sub	r8,sp,-1728
80009142:	fa c9 ff b4 	sub	r9,sp,-76
80009146:	08 9c       	mov	r12,r4
80009148:	fe b0 f6 44 	rcall	80007dd0 <get_arg>
8000914c:	2f dd       	sub	sp,-12
8000914e:	78 06       	ld.w	r6,r12[0x0]
80009150:	c2 08       	rjmp	80009190 <_vfprintf_r+0x1090>
80009152:	2f f7       	sub	r7,-1
80009154:	10 39       	cp.w	r9,r8
80009156:	c0 84       	brge	80009166 <_vfprintf_r+0x1066>
80009158:	fa c9 f9 44 	sub	r9,sp,-1724
8000915c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009160:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009164:	c1 68       	rjmp	80009190 <_vfprintf_r+0x1090>
80009166:	41 09       	lddsp	r9,sp[0x40]
80009168:	59 f8       	cp.w	r8,31
8000916a:	e0 89 00 10 	brgt	8000918a <_vfprintf_r+0x108a>
8000916e:	f2 ca ff fc 	sub	r10,r9,-4
80009172:	51 0a       	stdsp	sp[0x40],r10
80009174:	72 06       	ld.w	r6,r9[0x0]
80009176:	fa ce f9 44 	sub	lr,sp,-1724
8000917a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000917e:	f3 46 fd 88 	st.w	r9[-632],r6
80009182:	2f f8       	sub	r8,-1
80009184:	fb 48 06 b4 	st.w	sp[1716],r8
80009188:	c0 48       	rjmp	80009190 <_vfprintf_r+0x1090>
8000918a:	72 06       	ld.w	r6,r9[0x0]
8000918c:	2f c9       	sub	r9,-4
8000918e:	51 09       	stdsp	sp[0x40],r9
80009190:	40 2c       	lddsp	r12,sp[0x8]
80009192:	58 0c       	cp.w	r12,0
80009194:	c1 05       	brlt	800091b4 <_vfprintf_r+0x10b4>
80009196:	18 9a       	mov	r10,r12
80009198:	30 0b       	mov	r11,0
8000919a:	0c 9c       	mov	r12,r6
8000919c:	e0 a0 12 38 	rcall	8000b60c <memchr>
800091a0:	e0 80 02 df 	breq	8000975e <_vfprintf_r+0x165e>
800091a4:	f8 06 01 02 	sub	r2,r12,r6
800091a8:	40 2b       	lddsp	r11,sp[0x8]
800091aa:	16 32       	cp.w	r2,r11
800091ac:	e0 89 02 d9 	brgt	8000975e <_vfprintf_r+0x165e>
800091b0:	e0 8f 02 d4 	bral	80009758 <_vfprintf_r+0x1658>
800091b4:	30 0a       	mov	r10,0
800091b6:	0c 9c       	mov	r12,r6
800091b8:	50 2a       	stdsp	sp[0x8],r10
800091ba:	e0 a0 15 99 	rcall	8000bcec <strlen>
800091be:	18 92       	mov	r2,r12
800091c0:	e0 8f 02 d2 	bral	80009764 <_vfprintf_r+0x1664>
800091c4:	50 a7       	stdsp	sp[0x28],r7
800091c6:	50 80       	stdsp	sp[0x20],r0
800091c8:	0c 97       	mov	r7,r6
800091ca:	04 94       	mov	r4,r2
800091cc:	06 96       	mov	r6,r3
800091ce:	02 92       	mov	r2,r1
800091d0:	40 93       	lddsp	r3,sp[0x24]
800091d2:	10 90       	mov	r0,r8
800091d4:	40 41       	lddsp	r1,sp[0x10]
800091d6:	a5 a5       	sbr	r5,0x4
800091d8:	c0 a8       	rjmp	800091ec <_vfprintf_r+0x10ec>
800091da:	50 a7       	stdsp	sp[0x28],r7
800091dc:	50 80       	stdsp	sp[0x20],r0
800091de:	0c 97       	mov	r7,r6
800091e0:	04 94       	mov	r4,r2
800091e2:	06 96       	mov	r6,r3
800091e4:	02 92       	mov	r2,r1
800091e6:	40 93       	lddsp	r3,sp[0x24]
800091e8:	10 90       	mov	r0,r8
800091ea:	40 41       	lddsp	r1,sp[0x10]
800091ec:	ed b5 00 05 	bld	r5,0x5
800091f0:	c5 61       	brne	8000929c <_vfprintf_r+0x119c>
800091f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091f6:	40 39       	lddsp	r9,sp[0xc]
800091f8:	58 09       	cp.w	r9,0
800091fa:	c2 10       	breq	8000923c <_vfprintf_r+0x113c>
800091fc:	10 36       	cp.w	r6,r8
800091fe:	c0 74       	brge	8000920c <_vfprintf_r+0x110c>
80009200:	fa c8 f9 44 	sub	r8,sp,-1724
80009204:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009208:	c2 38       	rjmp	8000924e <_vfprintf_r+0x114e>
8000920a:	d7 03       	nop
8000920c:	fa c8 f9 50 	sub	r8,sp,-1712
80009210:	1a d8       	st.w	--sp,r8
80009212:	fa c8 fa b8 	sub	r8,sp,-1352
80009216:	1a d8       	st.w	--sp,r8
80009218:	fa c8 fb b4 	sub	r8,sp,-1100
8000921c:	1a d8       	st.w	--sp,r8
8000921e:	fa c8 f9 40 	sub	r8,sp,-1728
80009222:	fa c9 ff b4 	sub	r9,sp,-76
80009226:	04 9a       	mov	r10,r2
80009228:	0c 9b       	mov	r11,r6
8000922a:	08 9c       	mov	r12,r4
8000922c:	fe b0 f5 d2 	rcall	80007dd0 <get_arg>
80009230:	2f dd       	sub	sp,-12
80009232:	f8 e8 00 00 	ld.d	r8,r12[0]
80009236:	fa e9 00 00 	st.d	sp[0],r8
8000923a:	c2 e8       	rjmp	80009296 <_vfprintf_r+0x1196>
8000923c:	ee ca ff ff 	sub	r10,r7,-1
80009240:	10 37       	cp.w	r7,r8
80009242:	c0 b4       	brge	80009258 <_vfprintf_r+0x1158>
80009244:	fa c8 f9 44 	sub	r8,sp,-1724
80009248:	14 97       	mov	r7,r10
8000924a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000924e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009252:	fa eb 00 00 	st.d	sp[0],r10
80009256:	c2 08       	rjmp	80009296 <_vfprintf_r+0x1196>
80009258:	41 09       	lddsp	r9,sp[0x40]
8000925a:	59 f8       	cp.w	r8,31
8000925c:	e0 89 00 16 	brgt	80009288 <_vfprintf_r+0x1188>
80009260:	f2 e6 00 00 	ld.d	r6,r9[0]
80009264:	f2 cb ff f8 	sub	r11,r9,-8
80009268:	fa e7 00 00 	st.d	sp[0],r6
8000926c:	51 0b       	stdsp	sp[0x40],r11
8000926e:	fa c6 f9 44 	sub	r6,sp,-1724
80009272:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009276:	fa e6 00 00 	ld.d	r6,sp[0]
8000927a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000927e:	2f f8       	sub	r8,-1
80009280:	14 97       	mov	r7,r10
80009282:	fb 48 06 b4 	st.w	sp[1716],r8
80009286:	c0 88       	rjmp	80009296 <_vfprintf_r+0x1196>
80009288:	f2 e6 00 00 	ld.d	r6,r9[0]
8000928c:	2f 89       	sub	r9,-8
8000928e:	fa e7 00 00 	st.d	sp[0],r6
80009292:	51 09       	stdsp	sp[0x40],r9
80009294:	14 97       	mov	r7,r10
80009296:	30 18       	mov	r8,1
80009298:	e0 8f 01 d0 	bral	80009638 <_vfprintf_r+0x1538>
8000929c:	ed b5 00 04 	bld	r5,0x4
800092a0:	c1 61       	brne	800092cc <_vfprintf_r+0x11cc>
800092a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092a6:	40 3e       	lddsp	lr,sp[0xc]
800092a8:	58 0e       	cp.w	lr,0
800092aa:	c0 80       	breq	800092ba <_vfprintf_r+0x11ba>
800092ac:	10 36       	cp.w	r6,r8
800092ae:	c6 74       	brge	8000937c <_vfprintf_r+0x127c>
800092b0:	fa cc f9 44 	sub	r12,sp,-1724
800092b4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800092b8:	c8 08       	rjmp	800093b8 <_vfprintf_r+0x12b8>
800092ba:	ee ca ff ff 	sub	r10,r7,-1
800092be:	10 37       	cp.w	r7,r8
800092c0:	c7 f4       	brge	800093be <_vfprintf_r+0x12be>
800092c2:	fa cb f9 44 	sub	r11,sp,-1724
800092c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092ca:	c7 68       	rjmp	800093b6 <_vfprintf_r+0x12b6>
800092cc:	ed b5 00 06 	bld	r5,0x6
800092d0:	c4 a1       	brne	80009364 <_vfprintf_r+0x1264>
800092d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092d6:	40 3c       	lddsp	r12,sp[0xc]
800092d8:	58 0c       	cp.w	r12,0
800092da:	c1 d0       	breq	80009314 <_vfprintf_r+0x1214>
800092dc:	10 36       	cp.w	r6,r8
800092de:	c0 64       	brge	800092ea <_vfprintf_r+0x11ea>
800092e0:	fa cb f9 44 	sub	r11,sp,-1724
800092e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092e8:	c1 f8       	rjmp	80009326 <_vfprintf_r+0x1226>
800092ea:	fa c8 f9 50 	sub	r8,sp,-1712
800092ee:	1a d8       	st.w	--sp,r8
800092f0:	fa c8 fa b8 	sub	r8,sp,-1352
800092f4:	1a d8       	st.w	--sp,r8
800092f6:	fa c8 fb b4 	sub	r8,sp,-1100
800092fa:	1a d8       	st.w	--sp,r8
800092fc:	fa c8 f9 40 	sub	r8,sp,-1728
80009300:	fa c9 ff b4 	sub	r9,sp,-76
80009304:	04 9a       	mov	r10,r2
80009306:	0c 9b       	mov	r11,r6
80009308:	08 9c       	mov	r12,r4
8000930a:	fe b0 f5 63 	rcall	80007dd0 <get_arg>
8000930e:	2f dd       	sub	sp,-12
80009310:	98 18       	ld.sh	r8,r12[0x2]
80009312:	c2 68       	rjmp	8000935e <_vfprintf_r+0x125e>
80009314:	ee ca ff ff 	sub	r10,r7,-1
80009318:	10 37       	cp.w	r7,r8
8000931a:	c0 94       	brge	8000932c <_vfprintf_r+0x122c>
8000931c:	fa c9 f9 44 	sub	r9,sp,-1724
80009320:	14 97       	mov	r7,r10
80009322:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009326:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000932a:	c1 a8       	rjmp	8000935e <_vfprintf_r+0x125e>
8000932c:	41 09       	lddsp	r9,sp[0x40]
8000932e:	59 f8       	cp.w	r8,31
80009330:	e0 89 00 13 	brgt	80009356 <_vfprintf_r+0x1256>
80009334:	f2 cb ff fc 	sub	r11,r9,-4
80009338:	51 0b       	stdsp	sp[0x40],r11
8000933a:	72 09       	ld.w	r9,r9[0x0]
8000933c:	fa c6 f9 44 	sub	r6,sp,-1724
80009340:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009344:	2f f8       	sub	r8,-1
80009346:	f7 49 fd 88 	st.w	r11[-632],r9
8000934a:	fb 48 06 b4 	st.w	sp[1716],r8
8000934e:	14 97       	mov	r7,r10
80009350:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009354:	c0 58       	rjmp	8000935e <_vfprintf_r+0x125e>
80009356:	92 18       	ld.sh	r8,r9[0x2]
80009358:	14 97       	mov	r7,r10
8000935a:	2f c9       	sub	r9,-4
8000935c:	51 09       	stdsp	sp[0x40],r9
8000935e:	5c 78       	castu.h	r8
80009360:	50 18       	stdsp	sp[0x4],r8
80009362:	c4 68       	rjmp	800093ee <_vfprintf_r+0x12ee>
80009364:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009368:	40 3c       	lddsp	r12,sp[0xc]
8000936a:	58 0c       	cp.w	r12,0
8000936c:	c1 d0       	breq	800093a6 <_vfprintf_r+0x12a6>
8000936e:	10 36       	cp.w	r6,r8
80009370:	c0 64       	brge	8000937c <_vfprintf_r+0x127c>
80009372:	fa cb f9 44 	sub	r11,sp,-1724
80009376:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000937a:	c1 f8       	rjmp	800093b8 <_vfprintf_r+0x12b8>
8000937c:	fa c8 f9 50 	sub	r8,sp,-1712
80009380:	1a d8       	st.w	--sp,r8
80009382:	fa c8 fa b8 	sub	r8,sp,-1352
80009386:	0c 9b       	mov	r11,r6
80009388:	1a d8       	st.w	--sp,r8
8000938a:	fa c8 fb b4 	sub	r8,sp,-1100
8000938e:	04 9a       	mov	r10,r2
80009390:	1a d8       	st.w	--sp,r8
80009392:	08 9c       	mov	r12,r4
80009394:	fa c8 f9 40 	sub	r8,sp,-1728
80009398:	fa c9 ff b4 	sub	r9,sp,-76
8000939c:	fe b0 f5 1a 	rcall	80007dd0 <get_arg>
800093a0:	2f dd       	sub	sp,-12
800093a2:	78 0b       	ld.w	r11,r12[0x0]
800093a4:	c2 48       	rjmp	800093ec <_vfprintf_r+0x12ec>
800093a6:	ee ca ff ff 	sub	r10,r7,-1
800093aa:	10 37       	cp.w	r7,r8
800093ac:	c0 94       	brge	800093be <_vfprintf_r+0x12be>
800093ae:	fa c9 f9 44 	sub	r9,sp,-1724
800093b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093b6:	14 97       	mov	r7,r10
800093b8:	ec fb fd 88 	ld.w	r11,r6[-632]
800093bc:	c1 88       	rjmp	800093ec <_vfprintf_r+0x12ec>
800093be:	41 09       	lddsp	r9,sp[0x40]
800093c0:	59 f8       	cp.w	r8,31
800093c2:	e0 89 00 11 	brgt	800093e4 <_vfprintf_r+0x12e4>
800093c6:	f2 cb ff fc 	sub	r11,r9,-4
800093ca:	51 0b       	stdsp	sp[0x40],r11
800093cc:	fa c6 f9 44 	sub	r6,sp,-1724
800093d0:	72 0b       	ld.w	r11,r9[0x0]
800093d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093d6:	f3 4b fd 88 	st.w	r9[-632],r11
800093da:	2f f8       	sub	r8,-1
800093dc:	14 97       	mov	r7,r10
800093de:	fb 48 06 b4 	st.w	sp[1716],r8
800093e2:	c0 58       	rjmp	800093ec <_vfprintf_r+0x12ec>
800093e4:	72 0b       	ld.w	r11,r9[0x0]
800093e6:	14 97       	mov	r7,r10
800093e8:	2f c9       	sub	r9,-4
800093ea:	51 09       	stdsp	sp[0x40],r9
800093ec:	50 1b       	stdsp	sp[0x4],r11
800093ee:	30 0e       	mov	lr,0
800093f0:	30 18       	mov	r8,1
800093f2:	50 0e       	stdsp	sp[0x0],lr
800093f4:	c2 29       	rjmp	80009638 <_vfprintf_r+0x1538>
800093f6:	50 a7       	stdsp	sp[0x28],r7
800093f8:	50 80       	stdsp	sp[0x20],r0
800093fa:	0c 97       	mov	r7,r6
800093fc:	04 94       	mov	r4,r2
800093fe:	06 96       	mov	r6,r3
80009400:	02 92       	mov	r2,r1
80009402:	fe cc b4 32 	sub	r12,pc,-19406
80009406:	40 93       	lddsp	r3,sp[0x24]
80009408:	10 90       	mov	r0,r8
8000940a:	40 41       	lddsp	r1,sp[0x10]
8000940c:	50 dc       	stdsp	sp[0x34],r12
8000940e:	ed b5 00 05 	bld	r5,0x5
80009412:	c5 51       	brne	800094bc <_vfprintf_r+0x13bc>
80009414:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009418:	40 3b       	lddsp	r11,sp[0xc]
8000941a:	58 0b       	cp.w	r11,0
8000941c:	c2 20       	breq	80009460 <_vfprintf_r+0x1360>
8000941e:	10 36       	cp.w	r6,r8
80009420:	c0 a4       	brge	80009434 <_vfprintf_r+0x1334>
80009422:	fa ca f9 44 	sub	r10,sp,-1724
80009426:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000942a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000942e:	fa e9 00 00 	st.d	sp[0],r8
80009432:	cf 28       	rjmp	80009616 <_vfprintf_r+0x1516>
80009434:	fa c8 f9 50 	sub	r8,sp,-1712
80009438:	1a d8       	st.w	--sp,r8
8000943a:	fa c8 fa b8 	sub	r8,sp,-1352
8000943e:	04 9a       	mov	r10,r2
80009440:	1a d8       	st.w	--sp,r8
80009442:	0c 9b       	mov	r11,r6
80009444:	fa c8 fb b4 	sub	r8,sp,-1100
80009448:	08 9c       	mov	r12,r4
8000944a:	1a d8       	st.w	--sp,r8
8000944c:	fa c8 f9 40 	sub	r8,sp,-1728
80009450:	fa c9 ff b4 	sub	r9,sp,-76
80009454:	fe b0 f4 be 	rcall	80007dd0 <get_arg>
80009458:	2f dd       	sub	sp,-12
8000945a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000945e:	c0 c8       	rjmp	80009476 <_vfprintf_r+0x1376>
80009460:	ee ca ff ff 	sub	r10,r7,-1
80009464:	10 37       	cp.w	r7,r8
80009466:	c0 b4       	brge	8000947c <_vfprintf_r+0x137c>
80009468:	fa c9 f9 44 	sub	r9,sp,-1724
8000946c:	14 97       	mov	r7,r10
8000946e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009472:	ec ea fd 88 	ld.d	r10,r6[-632]
80009476:	fa eb 00 00 	st.d	sp[0],r10
8000947a:	cc e8       	rjmp	80009616 <_vfprintf_r+0x1516>
8000947c:	41 09       	lddsp	r9,sp[0x40]
8000947e:	59 f8       	cp.w	r8,31
80009480:	e0 89 00 16 	brgt	800094ac <_vfprintf_r+0x13ac>
80009484:	f2 e6 00 00 	ld.d	r6,r9[0]
80009488:	f2 cb ff f8 	sub	r11,r9,-8
8000948c:	fa e7 00 00 	st.d	sp[0],r6
80009490:	51 0b       	stdsp	sp[0x40],r11
80009492:	fa c6 f9 44 	sub	r6,sp,-1724
80009496:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000949a:	fa e6 00 00 	ld.d	r6,sp[0]
8000949e:	f2 e7 fd 88 	st.d	r9[-632],r6
800094a2:	2f f8       	sub	r8,-1
800094a4:	14 97       	mov	r7,r10
800094a6:	fb 48 06 b4 	st.w	sp[1716],r8
800094aa:	cb 68       	rjmp	80009616 <_vfprintf_r+0x1516>
800094ac:	f2 e6 00 00 	ld.d	r6,r9[0]
800094b0:	2f 89       	sub	r9,-8
800094b2:	fa e7 00 00 	st.d	sp[0],r6
800094b6:	51 09       	stdsp	sp[0x40],r9
800094b8:	14 97       	mov	r7,r10
800094ba:	ca e8       	rjmp	80009616 <_vfprintf_r+0x1516>
800094bc:	ed b5 00 04 	bld	r5,0x4
800094c0:	c1 71       	brne	800094ee <_vfprintf_r+0x13ee>
800094c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094c6:	40 3e       	lddsp	lr,sp[0xc]
800094c8:	58 0e       	cp.w	lr,0
800094ca:	c0 80       	breq	800094da <_vfprintf_r+0x13da>
800094cc:	10 36       	cp.w	r6,r8
800094ce:	c6 94       	brge	800095a0 <_vfprintf_r+0x14a0>
800094d0:	fa cc f9 44 	sub	r12,sp,-1724
800094d4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800094d8:	c8 28       	rjmp	800095dc <_vfprintf_r+0x14dc>
800094da:	ee ca ff ff 	sub	r10,r7,-1
800094de:	10 37       	cp.w	r7,r8
800094e0:	e0 84 00 81 	brge	800095e2 <_vfprintf_r+0x14e2>
800094e4:	fa cb f9 44 	sub	r11,sp,-1724
800094e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094ec:	c7 78       	rjmp	800095da <_vfprintf_r+0x14da>
800094ee:	ed b5 00 06 	bld	r5,0x6
800094f2:	c4 b1       	brne	80009588 <_vfprintf_r+0x1488>
800094f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094f8:	40 3c       	lddsp	r12,sp[0xc]
800094fa:	58 0c       	cp.w	r12,0
800094fc:	c1 d0       	breq	80009536 <_vfprintf_r+0x1436>
800094fe:	10 36       	cp.w	r6,r8
80009500:	c0 64       	brge	8000950c <_vfprintf_r+0x140c>
80009502:	fa cb f9 44 	sub	r11,sp,-1724
80009506:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000950a:	c1 f8       	rjmp	80009548 <_vfprintf_r+0x1448>
8000950c:	fa c8 f9 50 	sub	r8,sp,-1712
80009510:	1a d8       	st.w	--sp,r8
80009512:	fa c8 fa b8 	sub	r8,sp,-1352
80009516:	1a d8       	st.w	--sp,r8
80009518:	fa c8 fb b4 	sub	r8,sp,-1100
8000951c:	1a d8       	st.w	--sp,r8
8000951e:	fa c8 f9 40 	sub	r8,sp,-1728
80009522:	fa c9 ff b4 	sub	r9,sp,-76
80009526:	04 9a       	mov	r10,r2
80009528:	0c 9b       	mov	r11,r6
8000952a:	08 9c       	mov	r12,r4
8000952c:	fe b0 f4 52 	rcall	80007dd0 <get_arg>
80009530:	2f dd       	sub	sp,-12
80009532:	98 18       	ld.sh	r8,r12[0x2]
80009534:	c2 78       	rjmp	80009582 <_vfprintf_r+0x1482>
80009536:	ee ca ff ff 	sub	r10,r7,-1
8000953a:	10 37       	cp.w	r7,r8
8000953c:	c0 a4       	brge	80009550 <_vfprintf_r+0x1450>
8000953e:	fa c9 f9 44 	sub	r9,sp,-1724
80009542:	14 97       	mov	r7,r10
80009544:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009548:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000954c:	c1 b8       	rjmp	80009582 <_vfprintf_r+0x1482>
8000954e:	d7 03       	nop
80009550:	41 09       	lddsp	r9,sp[0x40]
80009552:	59 f8       	cp.w	r8,31
80009554:	e0 89 00 13 	brgt	8000957a <_vfprintf_r+0x147a>
80009558:	f2 cb ff fc 	sub	r11,r9,-4
8000955c:	51 0b       	stdsp	sp[0x40],r11
8000955e:	72 09       	ld.w	r9,r9[0x0]
80009560:	fa c6 f9 44 	sub	r6,sp,-1724
80009564:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009568:	2f f8       	sub	r8,-1
8000956a:	f7 49 fd 88 	st.w	r11[-632],r9
8000956e:	fb 48 06 b4 	st.w	sp[1716],r8
80009572:	14 97       	mov	r7,r10
80009574:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009578:	c0 58       	rjmp	80009582 <_vfprintf_r+0x1482>
8000957a:	92 18       	ld.sh	r8,r9[0x2]
8000957c:	14 97       	mov	r7,r10
8000957e:	2f c9       	sub	r9,-4
80009580:	51 09       	stdsp	sp[0x40],r9
80009582:	5c 78       	castu.h	r8
80009584:	50 18       	stdsp	sp[0x4],r8
80009586:	c4 68       	rjmp	80009612 <_vfprintf_r+0x1512>
80009588:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000958c:	40 3c       	lddsp	r12,sp[0xc]
8000958e:	58 0c       	cp.w	r12,0
80009590:	c1 d0       	breq	800095ca <_vfprintf_r+0x14ca>
80009592:	10 36       	cp.w	r6,r8
80009594:	c0 64       	brge	800095a0 <_vfprintf_r+0x14a0>
80009596:	fa cb f9 44 	sub	r11,sp,-1724
8000959a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000959e:	c1 f8       	rjmp	800095dc <_vfprintf_r+0x14dc>
800095a0:	fa c8 f9 50 	sub	r8,sp,-1712
800095a4:	1a d8       	st.w	--sp,r8
800095a6:	fa c8 fa b8 	sub	r8,sp,-1352
800095aa:	0c 9b       	mov	r11,r6
800095ac:	1a d8       	st.w	--sp,r8
800095ae:	fa c8 fb b4 	sub	r8,sp,-1100
800095b2:	04 9a       	mov	r10,r2
800095b4:	1a d8       	st.w	--sp,r8
800095b6:	08 9c       	mov	r12,r4
800095b8:	fa c8 f9 40 	sub	r8,sp,-1728
800095bc:	fa c9 ff b4 	sub	r9,sp,-76
800095c0:	fe b0 f4 08 	rcall	80007dd0 <get_arg>
800095c4:	2f dd       	sub	sp,-12
800095c6:	78 0b       	ld.w	r11,r12[0x0]
800095c8:	c2 48       	rjmp	80009610 <_vfprintf_r+0x1510>
800095ca:	ee ca ff ff 	sub	r10,r7,-1
800095ce:	10 37       	cp.w	r7,r8
800095d0:	c0 94       	brge	800095e2 <_vfprintf_r+0x14e2>
800095d2:	fa c9 f9 44 	sub	r9,sp,-1724
800095d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095da:	14 97       	mov	r7,r10
800095dc:	ec fb fd 88 	ld.w	r11,r6[-632]
800095e0:	c1 88       	rjmp	80009610 <_vfprintf_r+0x1510>
800095e2:	41 09       	lddsp	r9,sp[0x40]
800095e4:	59 f8       	cp.w	r8,31
800095e6:	e0 89 00 11 	brgt	80009608 <_vfprintf_r+0x1508>
800095ea:	f2 cb ff fc 	sub	r11,r9,-4
800095ee:	51 0b       	stdsp	sp[0x40],r11
800095f0:	fa c6 f9 44 	sub	r6,sp,-1724
800095f4:	72 0b       	ld.w	r11,r9[0x0]
800095f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095fa:	f3 4b fd 88 	st.w	r9[-632],r11
800095fe:	2f f8       	sub	r8,-1
80009600:	14 97       	mov	r7,r10
80009602:	fb 48 06 b4 	st.w	sp[1716],r8
80009606:	c0 58       	rjmp	80009610 <_vfprintf_r+0x1510>
80009608:	72 0b       	ld.w	r11,r9[0x0]
8000960a:	14 97       	mov	r7,r10
8000960c:	2f c9       	sub	r9,-4
8000960e:	51 09       	stdsp	sp[0x40],r9
80009610:	50 1b       	stdsp	sp[0x4],r11
80009612:	30 0e       	mov	lr,0
80009614:	50 0e       	stdsp	sp[0x0],lr
80009616:	40 08       	lddsp	r8,sp[0x0]
80009618:	40 1c       	lddsp	r12,sp[0x4]
8000961a:	18 48       	or	r8,r12
8000961c:	5f 19       	srne	r9
8000961e:	0a 98       	mov	r8,r5
80009620:	eb e9 00 09 	and	r9,r5,r9
80009624:	a1 b8       	sbr	r8,0x1
80009626:	58 09       	cp.w	r9,0
80009628:	c0 70       	breq	80009636 <_vfprintf_r+0x1536>
8000962a:	10 95       	mov	r5,r8
8000962c:	fb 60 06 b9 	st.b	sp[1721],r0
80009630:	33 08       	mov	r8,48
80009632:	fb 68 06 b8 	st.b	sp[1720],r8
80009636:	30 28       	mov	r8,2
80009638:	30 09       	mov	r9,0
8000963a:	fb 69 06 bb 	st.b	sp[1723],r9
8000963e:	0a 99       	mov	r9,r5
80009640:	a7 d9       	cbr	r9,0x7
80009642:	40 2b       	lddsp	r11,sp[0x8]
80009644:	40 16       	lddsp	r6,sp[0x4]
80009646:	58 0b       	cp.w	r11,0
80009648:	5f 1a       	srne	r10
8000964a:	f2 05 17 40 	movge	r5,r9
8000964e:	fa c2 f9 78 	sub	r2,sp,-1672
80009652:	40 09       	lddsp	r9,sp[0x0]
80009654:	0c 49       	or	r9,r6
80009656:	5f 19       	srne	r9
80009658:	f5 e9 10 09 	or	r9,r10,r9
8000965c:	c5 c0       	breq	80009714 <_vfprintf_r+0x1614>
8000965e:	30 19       	mov	r9,1
80009660:	f2 08 18 00 	cp.b	r8,r9
80009664:	c0 60       	breq	80009670 <_vfprintf_r+0x1570>
80009666:	30 29       	mov	r9,2
80009668:	f2 08 18 00 	cp.b	r8,r9
8000966c:	c0 41       	brne	80009674 <_vfprintf_r+0x1574>
8000966e:	c3 c8       	rjmp	800096e6 <_vfprintf_r+0x15e6>
80009670:	04 96       	mov	r6,r2
80009672:	c3 08       	rjmp	800096d2 <_vfprintf_r+0x15d2>
80009674:	04 96       	mov	r6,r2
80009676:	fa e8 00 00 	ld.d	r8,sp[0]
8000967a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000967e:	2d 0a       	sub	r10,-48
80009680:	0c fa       	st.b	--r6,r10
80009682:	f0 0b 16 03 	lsr	r11,r8,0x3
80009686:	f2 0c 16 03 	lsr	r12,r9,0x3
8000968a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000968e:	18 99       	mov	r9,r12
80009690:	16 98       	mov	r8,r11
80009692:	58 08       	cp.w	r8,0
80009694:	5c 29       	cpc	r9
80009696:	cf 21       	brne	8000967a <_vfprintf_r+0x157a>
80009698:	fa e9 00 00 	st.d	sp[0],r8
8000969c:	ed b5 00 00 	bld	r5,0x0
800096a0:	c4 51       	brne	8000972a <_vfprintf_r+0x162a>
800096a2:	33 09       	mov	r9,48
800096a4:	f2 0a 18 00 	cp.b	r10,r9
800096a8:	c4 10       	breq	8000972a <_vfprintf_r+0x162a>
800096aa:	0c f9       	st.b	--r6,r9
800096ac:	c3 f8       	rjmp	8000972a <_vfprintf_r+0x162a>
800096ae:	fa ea 00 00 	ld.d	r10,sp[0]
800096b2:	30 a8       	mov	r8,10
800096b4:	30 09       	mov	r9,0
800096b6:	e0 a0 1a 19 	rcall	8000cae8 <__avr32_umod64>
800096ba:	30 a8       	mov	r8,10
800096bc:	2d 0a       	sub	r10,-48
800096be:	30 09       	mov	r9,0
800096c0:	ac 8a       	st.b	r6[0x0],r10
800096c2:	fa ea 00 00 	ld.d	r10,sp[0]
800096c6:	e0 a0 18 df 	rcall	8000c884 <__avr32_udiv64>
800096ca:	16 99       	mov	r9,r11
800096cc:	14 98       	mov	r8,r10
800096ce:	fa e9 00 00 	st.d	sp[0],r8
800096d2:	20 16       	sub	r6,1
800096d4:	fa ea 00 00 	ld.d	r10,sp[0]
800096d8:	58 9a       	cp.w	r10,9
800096da:	5c 2b       	cpc	r11
800096dc:	fe 9b ff e9 	brhi	800096ae <_vfprintf_r+0x15ae>
800096e0:	1b f8       	ld.ub	r8,sp[0x7]
800096e2:	2d 08       	sub	r8,-48
800096e4:	c2 08       	rjmp	80009724 <_vfprintf_r+0x1624>
800096e6:	04 96       	mov	r6,r2
800096e8:	fa e8 00 00 	ld.d	r8,sp[0]
800096ec:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800096f0:	40 de       	lddsp	lr,sp[0x34]
800096f2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800096f6:	0c fa       	st.b	--r6,r10
800096f8:	f2 0b 16 04 	lsr	r11,r9,0x4
800096fc:	f0 0a 16 04 	lsr	r10,r8,0x4
80009700:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009704:	16 99       	mov	r9,r11
80009706:	14 98       	mov	r8,r10
80009708:	58 08       	cp.w	r8,0
8000970a:	5c 29       	cpc	r9
8000970c:	cf 01       	brne	800096ec <_vfprintf_r+0x15ec>
8000970e:	fa e9 00 00 	st.d	sp[0],r8
80009712:	c0 c8       	rjmp	8000972a <_vfprintf_r+0x162a>
80009714:	58 08       	cp.w	r8,0
80009716:	c0 91       	brne	80009728 <_vfprintf_r+0x1628>
80009718:	ed b5 00 00 	bld	r5,0x0
8000971c:	c0 61       	brne	80009728 <_vfprintf_r+0x1628>
8000971e:	fa c6 f9 79 	sub	r6,sp,-1671
80009722:	33 08       	mov	r8,48
80009724:	ac 88       	st.b	r6[0x0],r8
80009726:	c0 28       	rjmp	8000972a <_vfprintf_r+0x162a>
80009728:	04 96       	mov	r6,r2
8000972a:	0c 12       	sub	r2,r6
8000972c:	c1 c8       	rjmp	80009764 <_vfprintf_r+0x1664>
8000972e:	50 a7       	stdsp	sp[0x28],r7
80009730:	50 80       	stdsp	sp[0x20],r0
80009732:	40 93       	lddsp	r3,sp[0x24]
80009734:	0c 97       	mov	r7,r6
80009736:	10 90       	mov	r0,r8
80009738:	04 94       	mov	r4,r2
8000973a:	40 41       	lddsp	r1,sp[0x10]
8000973c:	58 08       	cp.w	r8,0
8000973e:	e0 80 04 4f 	breq	80009fdc <_vfprintf_r+0x1edc>
80009742:	fb 68 06 60 	st.b	sp[1632],r8
80009746:	30 0c       	mov	r12,0
80009748:	30 08       	mov	r8,0
8000974a:	30 12       	mov	r2,1
8000974c:	fb 68 06 bb 	st.b	sp[1723],r8
80009750:	50 2c       	stdsp	sp[0x8],r12
80009752:	fa c6 f9 a0 	sub	r6,sp,-1632
80009756:	c0 78       	rjmp	80009764 <_vfprintf_r+0x1664>
80009758:	30 0b       	mov	r11,0
8000975a:	50 2b       	stdsp	sp[0x8],r11
8000975c:	c0 48       	rjmp	80009764 <_vfprintf_r+0x1664>
8000975e:	40 22       	lddsp	r2,sp[0x8]
80009760:	30 0a       	mov	r10,0
80009762:	50 2a       	stdsp	sp[0x8],r10
80009764:	40 29       	lddsp	r9,sp[0x8]
80009766:	e4 09 0c 49 	max	r9,r2,r9
8000976a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000976e:	50 39       	stdsp	sp[0xc],r9
80009770:	0a 9e       	mov	lr,r5
80009772:	30 09       	mov	r9,0
80009774:	e2 1e 00 02 	andl	lr,0x2,COH
80009778:	f2 08 18 00 	cp.b	r8,r9
8000977c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009780:	f7 b8 01 ff 	subne	r8,-1
80009784:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009788:	0a 9b       	mov	r11,r5
8000978a:	58 0e       	cp.w	lr,0
8000978c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009790:	f7 bc 01 fe 	subne	r12,-2
80009794:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009798:	e2 1b 00 84 	andl	r11,0x84,COH
8000979c:	50 fe       	stdsp	sp[0x3c],lr
8000979e:	50 9b       	stdsp	sp[0x24],r11
800097a0:	c4 71       	brne	8000982e <_vfprintf_r+0x172e>
800097a2:	40 8a       	lddsp	r10,sp[0x20]
800097a4:	40 39       	lddsp	r9,sp[0xc]
800097a6:	12 1a       	sub	r10,r9
800097a8:	50 4a       	stdsp	sp[0x10],r10
800097aa:	58 0a       	cp.w	r10,0
800097ac:	e0 89 00 20 	brgt	800097ec <_vfprintf_r+0x16ec>
800097b0:	c3 f8       	rjmp	8000982e <_vfprintf_r+0x172e>
800097b2:	2f 09       	sub	r9,-16
800097b4:	2f f8       	sub	r8,-1
800097b6:	fe ce b7 ce 	sub	lr,pc,-18482
800097ba:	31 0c       	mov	r12,16
800097bc:	fb 49 06 90 	st.w	sp[1680],r9
800097c0:	87 0e       	st.w	r3[0x0],lr
800097c2:	87 1c       	st.w	r3[0x4],r12
800097c4:	fb 48 06 8c 	st.w	sp[1676],r8
800097c8:	58 78       	cp.w	r8,7
800097ca:	e0 89 00 04 	brgt	800097d2 <_vfprintf_r+0x16d2>
800097ce:	2f 83       	sub	r3,-8
800097d0:	c0 b8       	rjmp	800097e6 <_vfprintf_r+0x16e6>
800097d2:	fa ca f9 78 	sub	r10,sp,-1672
800097d6:	02 9b       	mov	r11,r1
800097d8:	08 9c       	mov	r12,r4
800097da:	fe b0 f4 85 	rcall	800080e4 <__sprint_r>
800097de:	e0 81 04 10 	brne	80009ffe <_vfprintf_r+0x1efe>
800097e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800097e6:	40 4b       	lddsp	r11,sp[0x10]
800097e8:	21 0b       	sub	r11,16
800097ea:	50 4b       	stdsp	sp[0x10],r11
800097ec:	fa f9 06 90 	ld.w	r9,sp[1680]
800097f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097f4:	fe ca b8 0c 	sub	r10,pc,-18420
800097f8:	40 4e       	lddsp	lr,sp[0x10]
800097fa:	59 0e       	cp.w	lr,16
800097fc:	fe 99 ff db 	brgt	800097b2 <_vfprintf_r+0x16b2>
80009800:	1c 09       	add	r9,lr
80009802:	2f f8       	sub	r8,-1
80009804:	87 0a       	st.w	r3[0x0],r10
80009806:	fb 49 06 90 	st.w	sp[1680],r9
8000980a:	87 1e       	st.w	r3[0x4],lr
8000980c:	fb 48 06 8c 	st.w	sp[1676],r8
80009810:	58 78       	cp.w	r8,7
80009812:	e0 89 00 04 	brgt	8000981a <_vfprintf_r+0x171a>
80009816:	2f 83       	sub	r3,-8
80009818:	c0 b8       	rjmp	8000982e <_vfprintf_r+0x172e>
8000981a:	fa ca f9 78 	sub	r10,sp,-1672
8000981e:	02 9b       	mov	r11,r1
80009820:	08 9c       	mov	r12,r4
80009822:	fe b0 f4 61 	rcall	800080e4 <__sprint_r>
80009826:	e0 81 03 ec 	brne	80009ffe <_vfprintf_r+0x1efe>
8000982a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000982e:	30 09       	mov	r9,0
80009830:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009834:	f2 08 18 00 	cp.b	r8,r9
80009838:	c1 f0       	breq	80009876 <_vfprintf_r+0x1776>
8000983a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000983e:	fa c9 f9 45 	sub	r9,sp,-1723
80009842:	2f f8       	sub	r8,-1
80009844:	87 09       	st.w	r3[0x0],r9
80009846:	fb 48 06 90 	st.w	sp[1680],r8
8000984a:	30 19       	mov	r9,1
8000984c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009850:	87 19       	st.w	r3[0x4],r9
80009852:	2f f8       	sub	r8,-1
80009854:	fb 48 06 8c 	st.w	sp[1676],r8
80009858:	58 78       	cp.w	r8,7
8000985a:	e0 89 00 04 	brgt	80009862 <_vfprintf_r+0x1762>
8000985e:	2f 83       	sub	r3,-8
80009860:	c0 b8       	rjmp	80009876 <_vfprintf_r+0x1776>
80009862:	fa ca f9 78 	sub	r10,sp,-1672
80009866:	02 9b       	mov	r11,r1
80009868:	08 9c       	mov	r12,r4
8000986a:	fe b0 f4 3d 	rcall	800080e4 <__sprint_r>
8000986e:	e0 81 03 c8 	brne	80009ffe <_vfprintf_r+0x1efe>
80009872:	fa c3 f9 e0 	sub	r3,sp,-1568
80009876:	40 fc       	lddsp	r12,sp[0x3c]
80009878:	58 0c       	cp.w	r12,0
8000987a:	c1 f0       	breq	800098b8 <_vfprintf_r+0x17b8>
8000987c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009880:	fa c9 f9 48 	sub	r9,sp,-1720
80009884:	2f e8       	sub	r8,-2
80009886:	87 09       	st.w	r3[0x0],r9
80009888:	fb 48 06 90 	st.w	sp[1680],r8
8000988c:	30 29       	mov	r9,2
8000988e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009892:	87 19       	st.w	r3[0x4],r9
80009894:	2f f8       	sub	r8,-1
80009896:	fb 48 06 8c 	st.w	sp[1676],r8
8000989a:	58 78       	cp.w	r8,7
8000989c:	e0 89 00 04 	brgt	800098a4 <_vfprintf_r+0x17a4>
800098a0:	2f 83       	sub	r3,-8
800098a2:	c0 b8       	rjmp	800098b8 <_vfprintf_r+0x17b8>
800098a4:	fa ca f9 78 	sub	r10,sp,-1672
800098a8:	02 9b       	mov	r11,r1
800098aa:	08 9c       	mov	r12,r4
800098ac:	fe b0 f4 1c 	rcall	800080e4 <__sprint_r>
800098b0:	e0 81 03 a7 	brne	80009ffe <_vfprintf_r+0x1efe>
800098b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800098b8:	40 9b       	lddsp	r11,sp[0x24]
800098ba:	e0 4b 00 80 	cp.w	r11,128
800098be:	c4 71       	brne	8000994c <_vfprintf_r+0x184c>
800098c0:	40 8a       	lddsp	r10,sp[0x20]
800098c2:	40 39       	lddsp	r9,sp[0xc]
800098c4:	12 1a       	sub	r10,r9
800098c6:	50 4a       	stdsp	sp[0x10],r10
800098c8:	58 0a       	cp.w	r10,0
800098ca:	e0 89 00 20 	brgt	8000990a <_vfprintf_r+0x180a>
800098ce:	c3 f8       	rjmp	8000994c <_vfprintf_r+0x184c>
800098d0:	2f 09       	sub	r9,-16
800098d2:	2f f8       	sub	r8,-1
800098d4:	fe ce b8 dc 	sub	lr,pc,-18212
800098d8:	31 0c       	mov	r12,16
800098da:	fb 49 06 90 	st.w	sp[1680],r9
800098de:	87 0e       	st.w	r3[0x0],lr
800098e0:	87 1c       	st.w	r3[0x4],r12
800098e2:	fb 48 06 8c 	st.w	sp[1676],r8
800098e6:	58 78       	cp.w	r8,7
800098e8:	e0 89 00 04 	brgt	800098f0 <_vfprintf_r+0x17f0>
800098ec:	2f 83       	sub	r3,-8
800098ee:	c0 b8       	rjmp	80009904 <_vfprintf_r+0x1804>
800098f0:	fa ca f9 78 	sub	r10,sp,-1672
800098f4:	02 9b       	mov	r11,r1
800098f6:	08 9c       	mov	r12,r4
800098f8:	fe b0 f3 f6 	rcall	800080e4 <__sprint_r>
800098fc:	e0 81 03 81 	brne	80009ffe <_vfprintf_r+0x1efe>
80009900:	fa c3 f9 e0 	sub	r3,sp,-1568
80009904:	40 4b       	lddsp	r11,sp[0x10]
80009906:	21 0b       	sub	r11,16
80009908:	50 4b       	stdsp	sp[0x10],r11
8000990a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000990e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009912:	fe ca b9 1a 	sub	r10,pc,-18150
80009916:	40 4e       	lddsp	lr,sp[0x10]
80009918:	59 0e       	cp.w	lr,16
8000991a:	fe 99 ff db 	brgt	800098d0 <_vfprintf_r+0x17d0>
8000991e:	1c 09       	add	r9,lr
80009920:	2f f8       	sub	r8,-1
80009922:	87 0a       	st.w	r3[0x0],r10
80009924:	fb 49 06 90 	st.w	sp[1680],r9
80009928:	87 1e       	st.w	r3[0x4],lr
8000992a:	fb 48 06 8c 	st.w	sp[1676],r8
8000992e:	58 78       	cp.w	r8,7
80009930:	e0 89 00 04 	brgt	80009938 <_vfprintf_r+0x1838>
80009934:	2f 83       	sub	r3,-8
80009936:	c0 b8       	rjmp	8000994c <_vfprintf_r+0x184c>
80009938:	fa ca f9 78 	sub	r10,sp,-1672
8000993c:	02 9b       	mov	r11,r1
8000993e:	08 9c       	mov	r12,r4
80009940:	fe b0 f3 d2 	rcall	800080e4 <__sprint_r>
80009944:	e0 81 03 5d 	brne	80009ffe <_vfprintf_r+0x1efe>
80009948:	fa c3 f9 e0 	sub	r3,sp,-1568
8000994c:	40 2c       	lddsp	r12,sp[0x8]
8000994e:	04 1c       	sub	r12,r2
80009950:	50 2c       	stdsp	sp[0x8],r12
80009952:	58 0c       	cp.w	r12,0
80009954:	e0 89 00 20 	brgt	80009994 <_vfprintf_r+0x1894>
80009958:	c3 f8       	rjmp	800099d6 <_vfprintf_r+0x18d6>
8000995a:	2f 09       	sub	r9,-16
8000995c:	2f f8       	sub	r8,-1
8000995e:	fe cb b9 66 	sub	r11,pc,-18074
80009962:	31 0a       	mov	r10,16
80009964:	fb 49 06 90 	st.w	sp[1680],r9
80009968:	87 0b       	st.w	r3[0x0],r11
8000996a:	87 1a       	st.w	r3[0x4],r10
8000996c:	fb 48 06 8c 	st.w	sp[1676],r8
80009970:	58 78       	cp.w	r8,7
80009972:	e0 89 00 04 	brgt	8000997a <_vfprintf_r+0x187a>
80009976:	2f 83       	sub	r3,-8
80009978:	c0 b8       	rjmp	8000998e <_vfprintf_r+0x188e>
8000997a:	fa ca f9 78 	sub	r10,sp,-1672
8000997e:	02 9b       	mov	r11,r1
80009980:	08 9c       	mov	r12,r4
80009982:	fe b0 f3 b1 	rcall	800080e4 <__sprint_r>
80009986:	e0 81 03 3c 	brne	80009ffe <_vfprintf_r+0x1efe>
8000998a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000998e:	40 29       	lddsp	r9,sp[0x8]
80009990:	21 09       	sub	r9,16
80009992:	50 29       	stdsp	sp[0x8],r9
80009994:	fa f9 06 90 	ld.w	r9,sp[1680]
80009998:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000999c:	fe ca b9 a4 	sub	r10,pc,-18012
800099a0:	40 2e       	lddsp	lr,sp[0x8]
800099a2:	59 0e       	cp.w	lr,16
800099a4:	fe 99 ff db 	brgt	8000995a <_vfprintf_r+0x185a>
800099a8:	1c 09       	add	r9,lr
800099aa:	2f f8       	sub	r8,-1
800099ac:	87 0a       	st.w	r3[0x0],r10
800099ae:	fb 49 06 90 	st.w	sp[1680],r9
800099b2:	87 1e       	st.w	r3[0x4],lr
800099b4:	fb 48 06 8c 	st.w	sp[1676],r8
800099b8:	58 78       	cp.w	r8,7
800099ba:	e0 89 00 04 	brgt	800099c2 <_vfprintf_r+0x18c2>
800099be:	2f 83       	sub	r3,-8
800099c0:	c0 b8       	rjmp	800099d6 <_vfprintf_r+0x18d6>
800099c2:	fa ca f9 78 	sub	r10,sp,-1672
800099c6:	02 9b       	mov	r11,r1
800099c8:	08 9c       	mov	r12,r4
800099ca:	fe b0 f3 8d 	rcall	800080e4 <__sprint_r>
800099ce:	e0 81 03 18 	brne	80009ffe <_vfprintf_r+0x1efe>
800099d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d6:	ed b5 00 08 	bld	r5,0x8
800099da:	c0 b0       	breq	800099f0 <_vfprintf_r+0x18f0>
800099dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800099e0:	87 12       	st.w	r3[0x4],r2
800099e2:	87 06       	st.w	r3[0x0],r6
800099e4:	f0 02 00 02 	add	r2,r8,r2
800099e8:	fb 42 06 90 	st.w	sp[1680],r2
800099ec:	e0 8f 01 d4 	bral	80009d94 <_vfprintf_r+0x1c94>
800099f0:	e0 40 00 65 	cp.w	r0,101
800099f4:	e0 8a 01 d6 	brle	80009da0 <_vfprintf_r+0x1ca0>
800099f8:	30 08       	mov	r8,0
800099fa:	30 09       	mov	r9,0
800099fc:	40 5b       	lddsp	r11,sp[0x14]
800099fe:	40 7a       	lddsp	r10,sp[0x1c]
80009a00:	e0 a0 15 3b 	rcall	8000c476 <__avr32_f64_cmp_eq>
80009a04:	c7 90       	breq	80009af6 <_vfprintf_r+0x19f6>
80009a06:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a0a:	fe c9 ba 26 	sub	r9,pc,-17882
80009a0e:	2f f8       	sub	r8,-1
80009a10:	87 09       	st.w	r3[0x0],r9
80009a12:	fb 48 06 90 	st.w	sp[1680],r8
80009a16:	30 19       	mov	r9,1
80009a18:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a1c:	87 19       	st.w	r3[0x4],r9
80009a1e:	2f f8       	sub	r8,-1
80009a20:	fb 48 06 8c 	st.w	sp[1676],r8
80009a24:	58 78       	cp.w	r8,7
80009a26:	e0 89 00 05 	brgt	80009a30 <_vfprintf_r+0x1930>
80009a2a:	2f 83       	sub	r3,-8
80009a2c:	c0 c8       	rjmp	80009a44 <_vfprintf_r+0x1944>
80009a2e:	d7 03       	nop
80009a30:	fa ca f9 78 	sub	r10,sp,-1672
80009a34:	02 9b       	mov	r11,r1
80009a36:	08 9c       	mov	r12,r4
80009a38:	fe b0 f3 56 	rcall	800080e4 <__sprint_r>
80009a3c:	e0 81 02 e1 	brne	80009ffe <_vfprintf_r+0x1efe>
80009a40:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a44:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a48:	40 6c       	lddsp	r12,sp[0x18]
80009a4a:	18 38       	cp.w	r8,r12
80009a4c:	c0 55       	brlt	80009a56 <_vfprintf_r+0x1956>
80009a4e:	ed b5 00 00 	bld	r5,0x0
80009a52:	e0 81 02 6b 	brne	80009f28 <_vfprintf_r+0x1e28>
80009a56:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a5a:	2f f8       	sub	r8,-1
80009a5c:	40 cb       	lddsp	r11,sp[0x30]
80009a5e:	fb 48 06 90 	st.w	sp[1680],r8
80009a62:	30 19       	mov	r9,1
80009a64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a68:	87 0b       	st.w	r3[0x0],r11
80009a6a:	2f f8       	sub	r8,-1
80009a6c:	87 19       	st.w	r3[0x4],r9
80009a6e:	fb 48 06 8c 	st.w	sp[1676],r8
80009a72:	58 78       	cp.w	r8,7
80009a74:	e0 89 00 04 	brgt	80009a7c <_vfprintf_r+0x197c>
80009a78:	2f 83       	sub	r3,-8
80009a7a:	c0 b8       	rjmp	80009a90 <_vfprintf_r+0x1990>
80009a7c:	fa ca f9 78 	sub	r10,sp,-1672
80009a80:	02 9b       	mov	r11,r1
80009a82:	08 9c       	mov	r12,r4
80009a84:	fe b0 f3 30 	rcall	800080e4 <__sprint_r>
80009a88:	e0 81 02 bb 	brne	80009ffe <_vfprintf_r+0x1efe>
80009a8c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a90:	40 66       	lddsp	r6,sp[0x18]
80009a92:	20 16       	sub	r6,1
80009a94:	58 06       	cp.w	r6,0
80009a96:	e0 89 00 1d 	brgt	80009ad0 <_vfprintf_r+0x19d0>
80009a9a:	e0 8f 02 47 	bral	80009f28 <_vfprintf_r+0x1e28>
80009a9e:	2f 09       	sub	r9,-16
80009aa0:	2f f8       	sub	r8,-1
80009aa2:	fb 49 06 90 	st.w	sp[1680],r9
80009aa6:	87 02       	st.w	r3[0x0],r2
80009aa8:	87 10       	st.w	r3[0x4],r0
80009aaa:	fb 48 06 8c 	st.w	sp[1676],r8
80009aae:	58 78       	cp.w	r8,7
80009ab0:	e0 89 00 04 	brgt	80009ab8 <_vfprintf_r+0x19b8>
80009ab4:	2f 83       	sub	r3,-8
80009ab6:	c0 b8       	rjmp	80009acc <_vfprintf_r+0x19cc>
80009ab8:	fa ca f9 78 	sub	r10,sp,-1672
80009abc:	02 9b       	mov	r11,r1
80009abe:	08 9c       	mov	r12,r4
80009ac0:	fe b0 f3 12 	rcall	800080e4 <__sprint_r>
80009ac4:	e0 81 02 9d 	brne	80009ffe <_vfprintf_r+0x1efe>
80009ac8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009acc:	21 06       	sub	r6,16
80009ace:	c0 48       	rjmp	80009ad6 <_vfprintf_r+0x19d6>
80009ad0:	fe c2 ba d8 	sub	r2,pc,-17704
80009ad4:	31 00       	mov	r0,16
80009ad6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ada:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ade:	fe ca ba e6 	sub	r10,pc,-17690
80009ae2:	59 06       	cp.w	r6,16
80009ae4:	fe 99 ff dd 	brgt	80009a9e <_vfprintf_r+0x199e>
80009ae8:	0c 09       	add	r9,r6
80009aea:	87 0a       	st.w	r3[0x0],r10
80009aec:	fb 49 06 90 	st.w	sp[1680],r9
80009af0:	2f f8       	sub	r8,-1
80009af2:	87 16       	st.w	r3[0x4],r6
80009af4:	c5 39       	rjmp	80009d9a <_vfprintf_r+0x1c9a>
80009af6:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009afa:	58 0a       	cp.w	r10,0
80009afc:	e0 89 00 92 	brgt	80009c20 <_vfprintf_r+0x1b20>
80009b00:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b04:	fe c9 bb 20 	sub	r9,pc,-17632
80009b08:	2f f8       	sub	r8,-1
80009b0a:	87 09       	st.w	r3[0x0],r9
80009b0c:	fb 48 06 90 	st.w	sp[1680],r8
80009b10:	30 19       	mov	r9,1
80009b12:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b16:	87 19       	st.w	r3[0x4],r9
80009b18:	2f f8       	sub	r8,-1
80009b1a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b1e:	58 78       	cp.w	r8,7
80009b20:	e0 89 00 04 	brgt	80009b28 <_vfprintf_r+0x1a28>
80009b24:	2f 83       	sub	r3,-8
80009b26:	c0 b8       	rjmp	80009b3c <_vfprintf_r+0x1a3c>
80009b28:	fa ca f9 78 	sub	r10,sp,-1672
80009b2c:	02 9b       	mov	r11,r1
80009b2e:	08 9c       	mov	r12,r4
80009b30:	fe b0 f2 da 	rcall	800080e4 <__sprint_r>
80009b34:	e0 81 02 65 	brne	80009ffe <_vfprintf_r+0x1efe>
80009b38:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b3c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b40:	58 08       	cp.w	r8,0
80009b42:	c0 81       	brne	80009b52 <_vfprintf_r+0x1a52>
80009b44:	40 6a       	lddsp	r10,sp[0x18]
80009b46:	58 0a       	cp.w	r10,0
80009b48:	c0 51       	brne	80009b52 <_vfprintf_r+0x1a52>
80009b4a:	ed b5 00 00 	bld	r5,0x0
80009b4e:	e0 81 01 ed 	brne	80009f28 <_vfprintf_r+0x1e28>
80009b52:	40 c9       	lddsp	r9,sp[0x30]
80009b54:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b58:	2f f8       	sub	r8,-1
80009b5a:	87 09       	st.w	r3[0x0],r9
80009b5c:	fb 48 06 90 	st.w	sp[1680],r8
80009b60:	30 19       	mov	r9,1
80009b62:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b66:	87 19       	st.w	r3[0x4],r9
80009b68:	2f f8       	sub	r8,-1
80009b6a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b6e:	58 78       	cp.w	r8,7
80009b70:	e0 89 00 04 	brgt	80009b78 <_vfprintf_r+0x1a78>
80009b74:	2f 83       	sub	r3,-8
80009b76:	c0 b8       	rjmp	80009b8c <_vfprintf_r+0x1a8c>
80009b78:	fa ca f9 78 	sub	r10,sp,-1672
80009b7c:	02 9b       	mov	r11,r1
80009b7e:	08 9c       	mov	r12,r4
80009b80:	fe b0 f2 b2 	rcall	800080e4 <__sprint_r>
80009b84:	e0 81 02 3d 	brne	80009ffe <_vfprintf_r+0x1efe>
80009b88:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b8c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b90:	5c 32       	neg	r2
80009b92:	58 02       	cp.w	r2,0
80009b94:	e0 89 00 1d 	brgt	80009bce <_vfprintf_r+0x1ace>
80009b98:	c3 d8       	rjmp	80009c12 <_vfprintf_r+0x1b12>
80009b9a:	2f 09       	sub	r9,-16
80009b9c:	2f f8       	sub	r8,-1
80009b9e:	31 0e       	mov	lr,16
80009ba0:	fb 49 06 90 	st.w	sp[1680],r9
80009ba4:	87 00       	st.w	r3[0x0],r0
80009ba6:	87 1e       	st.w	r3[0x4],lr
80009ba8:	fb 48 06 8c 	st.w	sp[1676],r8
80009bac:	58 78       	cp.w	r8,7
80009bae:	e0 89 00 04 	brgt	80009bb6 <_vfprintf_r+0x1ab6>
80009bb2:	2f 83       	sub	r3,-8
80009bb4:	c0 b8       	rjmp	80009bca <_vfprintf_r+0x1aca>
80009bb6:	fa ca f9 78 	sub	r10,sp,-1672
80009bba:	02 9b       	mov	r11,r1
80009bbc:	08 9c       	mov	r12,r4
80009bbe:	fe b0 f2 93 	rcall	800080e4 <__sprint_r>
80009bc2:	e0 81 02 1e 	brne	80009ffe <_vfprintf_r+0x1efe>
80009bc6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bca:	21 02       	sub	r2,16
80009bcc:	c0 38       	rjmp	80009bd2 <_vfprintf_r+0x1ad2>
80009bce:	fe c0 bb d6 	sub	r0,pc,-17450
80009bd2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bd6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bda:	fe ca bb e2 	sub	r10,pc,-17438
80009bde:	59 02       	cp.w	r2,16
80009be0:	fe 99 ff dd 	brgt	80009b9a <_vfprintf_r+0x1a9a>
80009be4:	04 09       	add	r9,r2
80009be6:	2f f8       	sub	r8,-1
80009be8:	87 0a       	st.w	r3[0x0],r10
80009bea:	fb 49 06 90 	st.w	sp[1680],r9
80009bee:	87 12       	st.w	r3[0x4],r2
80009bf0:	fb 48 06 8c 	st.w	sp[1676],r8
80009bf4:	58 78       	cp.w	r8,7
80009bf6:	e0 89 00 04 	brgt	80009bfe <_vfprintf_r+0x1afe>
80009bfa:	2f 83       	sub	r3,-8
80009bfc:	c0 b8       	rjmp	80009c12 <_vfprintf_r+0x1b12>
80009bfe:	fa ca f9 78 	sub	r10,sp,-1672
80009c02:	02 9b       	mov	r11,r1
80009c04:	08 9c       	mov	r12,r4
80009c06:	fe b0 f2 6f 	rcall	800080e4 <__sprint_r>
80009c0a:	e0 81 01 fa 	brne	80009ffe <_vfprintf_r+0x1efe>
80009c0e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c12:	40 6c       	lddsp	r12,sp[0x18]
80009c14:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c18:	87 06       	st.w	r3[0x0],r6
80009c1a:	87 1c       	st.w	r3[0x4],r12
80009c1c:	18 08       	add	r8,r12
80009c1e:	cb 98       	rjmp	80009d90 <_vfprintf_r+0x1c90>
80009c20:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c28:	40 6b       	lddsp	r11,sp[0x18]
80009c2a:	16 3a       	cp.w	r10,r11
80009c2c:	c6 f5       	brlt	80009d0a <_vfprintf_r+0x1c0a>
80009c2e:	16 09       	add	r9,r11
80009c30:	2f f8       	sub	r8,-1
80009c32:	87 06       	st.w	r3[0x0],r6
80009c34:	fb 49 06 90 	st.w	sp[1680],r9
80009c38:	87 1b       	st.w	r3[0x4],r11
80009c3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009c3e:	58 78       	cp.w	r8,7
80009c40:	e0 89 00 04 	brgt	80009c48 <_vfprintf_r+0x1b48>
80009c44:	2f 83       	sub	r3,-8
80009c46:	c0 b8       	rjmp	80009c5c <_vfprintf_r+0x1b5c>
80009c48:	fa ca f9 78 	sub	r10,sp,-1672
80009c4c:	02 9b       	mov	r11,r1
80009c4e:	08 9c       	mov	r12,r4
80009c50:	fe b0 f2 4a 	rcall	800080e4 <__sprint_r>
80009c54:	e0 81 01 d5 	brne	80009ffe <_vfprintf_r+0x1efe>
80009c58:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c5c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009c60:	40 6a       	lddsp	r10,sp[0x18]
80009c62:	14 16       	sub	r6,r10
80009c64:	58 06       	cp.w	r6,0
80009c66:	e0 89 00 1c 	brgt	80009c9e <_vfprintf_r+0x1b9e>
80009c6a:	c3 d8       	rjmp	80009ce4 <_vfprintf_r+0x1be4>
80009c6c:	2f 09       	sub	r9,-16
80009c6e:	2f f8       	sub	r8,-1
80009c70:	fb 49 06 90 	st.w	sp[1680],r9
80009c74:	87 02       	st.w	r3[0x0],r2
80009c76:	87 10       	st.w	r3[0x4],r0
80009c78:	fb 48 06 8c 	st.w	sp[1676],r8
80009c7c:	58 78       	cp.w	r8,7
80009c7e:	e0 89 00 04 	brgt	80009c86 <_vfprintf_r+0x1b86>
80009c82:	2f 83       	sub	r3,-8
80009c84:	c0 b8       	rjmp	80009c9a <_vfprintf_r+0x1b9a>
80009c86:	fa ca f9 78 	sub	r10,sp,-1672
80009c8a:	02 9b       	mov	r11,r1
80009c8c:	08 9c       	mov	r12,r4
80009c8e:	fe b0 f2 2b 	rcall	800080e4 <__sprint_r>
80009c92:	e0 81 01 b6 	brne	80009ffe <_vfprintf_r+0x1efe>
80009c96:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c9a:	21 06       	sub	r6,16
80009c9c:	c0 48       	rjmp	80009ca4 <_vfprintf_r+0x1ba4>
80009c9e:	fe c2 bc a6 	sub	r2,pc,-17242
80009ca2:	31 00       	mov	r0,16
80009ca4:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ca8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cac:	fe ca bc b4 	sub	r10,pc,-17228
80009cb0:	59 06       	cp.w	r6,16
80009cb2:	fe 99 ff dd 	brgt	80009c6c <_vfprintf_r+0x1b6c>
80009cb6:	0c 09       	add	r9,r6
80009cb8:	2f f8       	sub	r8,-1
80009cba:	87 0a       	st.w	r3[0x0],r10
80009cbc:	fb 49 06 90 	st.w	sp[1680],r9
80009cc0:	87 16       	st.w	r3[0x4],r6
80009cc2:	fb 48 06 8c 	st.w	sp[1676],r8
80009cc6:	58 78       	cp.w	r8,7
80009cc8:	e0 89 00 04 	brgt	80009cd0 <_vfprintf_r+0x1bd0>
80009ccc:	2f 83       	sub	r3,-8
80009cce:	c0 b8       	rjmp	80009ce4 <_vfprintf_r+0x1be4>
80009cd0:	fa ca f9 78 	sub	r10,sp,-1672
80009cd4:	02 9b       	mov	r11,r1
80009cd6:	08 9c       	mov	r12,r4
80009cd8:	fe b0 f2 06 	rcall	800080e4 <__sprint_r>
80009cdc:	e0 81 01 91 	brne	80009ffe <_vfprintf_r+0x1efe>
80009ce0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ce4:	ed b5 00 00 	bld	r5,0x0
80009ce8:	e0 81 01 20 	brne	80009f28 <_vfprintf_r+0x1e28>
80009cec:	40 c9       	lddsp	r9,sp[0x30]
80009cee:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cf2:	2f f8       	sub	r8,-1
80009cf4:	87 09       	st.w	r3[0x0],r9
80009cf6:	fb 48 06 90 	st.w	sp[1680],r8
80009cfa:	30 19       	mov	r9,1
80009cfc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d00:	87 19       	st.w	r3[0x4],r9
80009d02:	2f f8       	sub	r8,-1
80009d04:	fb 48 06 8c 	st.w	sp[1676],r8
80009d08:	c0 29       	rjmp	80009f0c <_vfprintf_r+0x1e0c>
80009d0a:	14 09       	add	r9,r10
80009d0c:	2f f8       	sub	r8,-1
80009d0e:	fb 49 06 90 	st.w	sp[1680],r9
80009d12:	87 06       	st.w	r3[0x0],r6
80009d14:	87 1a       	st.w	r3[0x4],r10
80009d16:	fb 48 06 8c 	st.w	sp[1676],r8
80009d1a:	58 78       	cp.w	r8,7
80009d1c:	e0 89 00 04 	brgt	80009d24 <_vfprintf_r+0x1c24>
80009d20:	2f 83       	sub	r3,-8
80009d22:	c0 b8       	rjmp	80009d38 <_vfprintf_r+0x1c38>
80009d24:	fa ca f9 78 	sub	r10,sp,-1672
80009d28:	02 9b       	mov	r11,r1
80009d2a:	08 9c       	mov	r12,r4
80009d2c:	fe b0 f1 dc 	rcall	800080e4 <__sprint_r>
80009d30:	e0 81 01 67 	brne	80009ffe <_vfprintf_r+0x1efe>
80009d34:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d38:	40 c8       	lddsp	r8,sp[0x30]
80009d3a:	87 08       	st.w	r3[0x0],r8
80009d3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d40:	2f f8       	sub	r8,-1
80009d42:	30 19       	mov	r9,1
80009d44:	fb 48 06 90 	st.w	sp[1680],r8
80009d48:	87 19       	st.w	r3[0x4],r9
80009d4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d4e:	2f f8       	sub	r8,-1
80009d50:	fb 48 06 8c 	st.w	sp[1676],r8
80009d54:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009d58:	58 78       	cp.w	r8,7
80009d5a:	e0 89 00 04 	brgt	80009d62 <_vfprintf_r+0x1c62>
80009d5e:	2f 83       	sub	r3,-8
80009d60:	c0 b8       	rjmp	80009d76 <_vfprintf_r+0x1c76>
80009d62:	fa ca f9 78 	sub	r10,sp,-1672
80009d66:	02 9b       	mov	r11,r1
80009d68:	08 9c       	mov	r12,r4
80009d6a:	fe b0 f1 bd 	rcall	800080e4 <__sprint_r>
80009d6e:	e0 81 01 48 	brne	80009ffe <_vfprintf_r+0x1efe>
80009d72:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d76:	04 06       	add	r6,r2
80009d78:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009d7c:	87 06       	st.w	r3[0x0],r6
80009d7e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d82:	40 66       	lddsp	r6,sp[0x18]
80009d84:	40 6e       	lddsp	lr,sp[0x18]
80009d86:	10 16       	sub	r6,r8
80009d88:	f2 08 01 08 	sub	r8,r9,r8
80009d8c:	87 16       	st.w	r3[0x4],r6
80009d8e:	1c 08       	add	r8,lr
80009d90:	fb 48 06 90 	st.w	sp[1680],r8
80009d94:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d98:	2f f8       	sub	r8,-1
80009d9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009d9e:	cb 78       	rjmp	80009f0c <_vfprintf_r+0x1e0c>
80009da0:	40 6c       	lddsp	r12,sp[0x18]
80009da2:	58 1c       	cp.w	r12,1
80009da4:	e0 89 00 06 	brgt	80009db0 <_vfprintf_r+0x1cb0>
80009da8:	ed b5 00 00 	bld	r5,0x0
80009dac:	e0 81 00 85 	brne	80009eb6 <_vfprintf_r+0x1db6>
80009db0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009db4:	2f f8       	sub	r8,-1
80009db6:	30 19       	mov	r9,1
80009db8:	fb 48 06 90 	st.w	sp[1680],r8
80009dbc:	87 06       	st.w	r3[0x0],r6
80009dbe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dc2:	87 19       	st.w	r3[0x4],r9
80009dc4:	2f f8       	sub	r8,-1
80009dc6:	fb 48 06 8c 	st.w	sp[1676],r8
80009dca:	58 78       	cp.w	r8,7
80009dcc:	e0 89 00 04 	brgt	80009dd4 <_vfprintf_r+0x1cd4>
80009dd0:	2f 83       	sub	r3,-8
80009dd2:	c0 b8       	rjmp	80009de8 <_vfprintf_r+0x1ce8>
80009dd4:	fa ca f9 78 	sub	r10,sp,-1672
80009dd8:	02 9b       	mov	r11,r1
80009dda:	08 9c       	mov	r12,r4
80009ddc:	fe b0 f1 84 	rcall	800080e4 <__sprint_r>
80009de0:	e0 81 01 0f 	brne	80009ffe <_vfprintf_r+0x1efe>
80009de4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009de8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dec:	2f f8       	sub	r8,-1
80009dee:	40 cb       	lddsp	r11,sp[0x30]
80009df0:	fb 48 06 90 	st.w	sp[1680],r8
80009df4:	30 19       	mov	r9,1
80009df6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dfa:	87 0b       	st.w	r3[0x0],r11
80009dfc:	2f f8       	sub	r8,-1
80009dfe:	87 19       	st.w	r3[0x4],r9
80009e00:	fb 48 06 8c 	st.w	sp[1676],r8
80009e04:	58 78       	cp.w	r8,7
80009e06:	e0 89 00 05 	brgt	80009e10 <_vfprintf_r+0x1d10>
80009e0a:	2f 83       	sub	r3,-8
80009e0c:	c0 c8       	rjmp	80009e24 <_vfprintf_r+0x1d24>
80009e0e:	d7 03       	nop
80009e10:	fa ca f9 78 	sub	r10,sp,-1672
80009e14:	02 9b       	mov	r11,r1
80009e16:	08 9c       	mov	r12,r4
80009e18:	fe b0 f1 66 	rcall	800080e4 <__sprint_r>
80009e1c:	e0 81 00 f1 	brne	80009ffe <_vfprintf_r+0x1efe>
80009e20:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e24:	30 08       	mov	r8,0
80009e26:	30 09       	mov	r9,0
80009e28:	40 5b       	lddsp	r11,sp[0x14]
80009e2a:	40 7a       	lddsp	r10,sp[0x1c]
80009e2c:	e0 a0 13 25 	rcall	8000c476 <__avr32_f64_cmp_eq>
80009e30:	40 68       	lddsp	r8,sp[0x18]
80009e32:	20 18       	sub	r8,1
80009e34:	58 0c       	cp.w	r12,0
80009e36:	c0 d1       	brne	80009e50 <_vfprintf_r+0x1d50>
80009e38:	2f f6       	sub	r6,-1
80009e3a:	87 18       	st.w	r3[0x4],r8
80009e3c:	87 06       	st.w	r3[0x0],r6
80009e3e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009e42:	10 06       	add	r6,r8
80009e44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e48:	fb 46 06 90 	st.w	sp[1680],r6
80009e4c:	2f f8       	sub	r8,-1
80009e4e:	c3 18       	rjmp	80009eb0 <_vfprintf_r+0x1db0>
80009e50:	10 96       	mov	r6,r8
80009e52:	58 08       	cp.w	r8,0
80009e54:	e0 89 00 1c 	brgt	80009e8c <_vfprintf_r+0x1d8c>
80009e58:	c4 b8       	rjmp	80009eee <_vfprintf_r+0x1dee>
80009e5a:	2f 09       	sub	r9,-16
80009e5c:	2f f8       	sub	r8,-1
80009e5e:	fb 49 06 90 	st.w	sp[1680],r9
80009e62:	87 02       	st.w	r3[0x0],r2
80009e64:	87 10       	st.w	r3[0x4],r0
80009e66:	fb 48 06 8c 	st.w	sp[1676],r8
80009e6a:	58 78       	cp.w	r8,7
80009e6c:	e0 89 00 04 	brgt	80009e74 <_vfprintf_r+0x1d74>
80009e70:	2f 83       	sub	r3,-8
80009e72:	c0 b8       	rjmp	80009e88 <_vfprintf_r+0x1d88>
80009e74:	fa ca f9 78 	sub	r10,sp,-1672
80009e78:	02 9b       	mov	r11,r1
80009e7a:	08 9c       	mov	r12,r4
80009e7c:	fe b0 f1 34 	rcall	800080e4 <__sprint_r>
80009e80:	e0 81 00 bf 	brne	80009ffe <_vfprintf_r+0x1efe>
80009e84:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e88:	21 06       	sub	r6,16
80009e8a:	c0 48       	rjmp	80009e92 <_vfprintf_r+0x1d92>
80009e8c:	fe c2 be 94 	sub	r2,pc,-16748
80009e90:	31 00       	mov	r0,16
80009e92:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e96:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e9a:	fe ca be a2 	sub	r10,pc,-16734
80009e9e:	59 06       	cp.w	r6,16
80009ea0:	fe 99 ff dd 	brgt	80009e5a <_vfprintf_r+0x1d5a>
80009ea4:	0c 09       	add	r9,r6
80009ea6:	87 0a       	st.w	r3[0x0],r10
80009ea8:	fb 49 06 90 	st.w	sp[1680],r9
80009eac:	2f f8       	sub	r8,-1
80009eae:	87 16       	st.w	r3[0x4],r6
80009eb0:	fb 48 06 8c 	st.w	sp[1676],r8
80009eb4:	c0 e8       	rjmp	80009ed0 <_vfprintf_r+0x1dd0>
80009eb6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009eba:	2f f8       	sub	r8,-1
80009ebc:	30 19       	mov	r9,1
80009ebe:	fb 48 06 90 	st.w	sp[1680],r8
80009ec2:	87 06       	st.w	r3[0x0],r6
80009ec4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ec8:	87 19       	st.w	r3[0x4],r9
80009eca:	2f f8       	sub	r8,-1
80009ecc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ed0:	58 78       	cp.w	r8,7
80009ed2:	e0 89 00 04 	brgt	80009eda <_vfprintf_r+0x1dda>
80009ed6:	2f 83       	sub	r3,-8
80009ed8:	c0 b8       	rjmp	80009eee <_vfprintf_r+0x1dee>
80009eda:	fa ca f9 78 	sub	r10,sp,-1672
80009ede:	02 9b       	mov	r11,r1
80009ee0:	08 9c       	mov	r12,r4
80009ee2:	fe b0 f1 01 	rcall	800080e4 <__sprint_r>
80009ee6:	e0 81 00 8c 	brne	80009ffe <_vfprintf_r+0x1efe>
80009eea:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eee:	40 ea       	lddsp	r10,sp[0x38]
80009ef0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ef4:	14 08       	add	r8,r10
80009ef6:	fa c9 f9 64 	sub	r9,sp,-1692
80009efa:	fb 48 06 90 	st.w	sp[1680],r8
80009efe:	87 1a       	st.w	r3[0x4],r10
80009f00:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f04:	87 09       	st.w	r3[0x0],r9
80009f06:	2f f8       	sub	r8,-1
80009f08:	fb 48 06 8c 	st.w	sp[1676],r8
80009f0c:	58 78       	cp.w	r8,7
80009f0e:	e0 89 00 04 	brgt	80009f16 <_vfprintf_r+0x1e16>
80009f12:	2f 83       	sub	r3,-8
80009f14:	c0 a8       	rjmp	80009f28 <_vfprintf_r+0x1e28>
80009f16:	fa ca f9 78 	sub	r10,sp,-1672
80009f1a:	02 9b       	mov	r11,r1
80009f1c:	08 9c       	mov	r12,r4
80009f1e:	fe b0 f0 e3 	rcall	800080e4 <__sprint_r>
80009f22:	c6 e1       	brne	80009ffe <_vfprintf_r+0x1efe>
80009f24:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f28:	e2 15 00 04 	andl	r5,0x4,COH
80009f2c:	c3 f0       	breq	80009faa <_vfprintf_r+0x1eaa>
80009f2e:	40 86       	lddsp	r6,sp[0x20]
80009f30:	40 39       	lddsp	r9,sp[0xc]
80009f32:	12 16       	sub	r6,r9
80009f34:	58 06       	cp.w	r6,0
80009f36:	e0 89 00 1a 	brgt	80009f6a <_vfprintf_r+0x1e6a>
80009f3a:	c3 88       	rjmp	80009faa <_vfprintf_r+0x1eaa>
80009f3c:	2f 09       	sub	r9,-16
80009f3e:	2f f8       	sub	r8,-1
80009f40:	fb 49 06 90 	st.w	sp[1680],r9
80009f44:	87 05       	st.w	r3[0x0],r5
80009f46:	87 12       	st.w	r3[0x4],r2
80009f48:	fb 48 06 8c 	st.w	sp[1676],r8
80009f4c:	58 78       	cp.w	r8,7
80009f4e:	e0 89 00 04 	brgt	80009f56 <_vfprintf_r+0x1e56>
80009f52:	2f 83       	sub	r3,-8
80009f54:	c0 98       	rjmp	80009f66 <_vfprintf_r+0x1e66>
80009f56:	00 9a       	mov	r10,r0
80009f58:	02 9b       	mov	r11,r1
80009f5a:	08 9c       	mov	r12,r4
80009f5c:	fe b0 f0 c4 	rcall	800080e4 <__sprint_r>
80009f60:	c4 f1       	brne	80009ffe <_vfprintf_r+0x1efe>
80009f62:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f66:	21 06       	sub	r6,16
80009f68:	c0 68       	rjmp	80009f74 <_vfprintf_r+0x1e74>
80009f6a:	fe c5 bf 82 	sub	r5,pc,-16510
80009f6e:	31 02       	mov	r2,16
80009f70:	fa c0 f9 78 	sub	r0,sp,-1672
80009f74:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f78:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f7c:	fe ca bf 94 	sub	r10,pc,-16492
80009f80:	59 06       	cp.w	r6,16
80009f82:	fe 99 ff dd 	brgt	80009f3c <_vfprintf_r+0x1e3c>
80009f86:	0c 09       	add	r9,r6
80009f88:	2f f8       	sub	r8,-1
80009f8a:	87 0a       	st.w	r3[0x0],r10
80009f8c:	87 16       	st.w	r3[0x4],r6
80009f8e:	fb 49 06 90 	st.w	sp[1680],r9
80009f92:	fb 48 06 8c 	st.w	sp[1676],r8
80009f96:	58 78       	cp.w	r8,7
80009f98:	e0 8a 00 09 	brle	80009faa <_vfprintf_r+0x1eaa>
80009f9c:	fa ca f9 78 	sub	r10,sp,-1672
80009fa0:	02 9b       	mov	r11,r1
80009fa2:	08 9c       	mov	r12,r4
80009fa4:	fe b0 f0 a0 	rcall	800080e4 <__sprint_r>
80009fa8:	c2 b1       	brne	80009ffe <_vfprintf_r+0x1efe>
80009faa:	40 bc       	lddsp	r12,sp[0x2c]
80009fac:	40 36       	lddsp	r6,sp[0xc]
80009fae:	40 8e       	lddsp	lr,sp[0x20]
80009fb0:	ec 0e 0c 48 	max	r8,r6,lr
80009fb4:	10 0c       	add	r12,r8
80009fb6:	50 bc       	stdsp	sp[0x2c],r12
80009fb8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fbc:	58 08       	cp.w	r8,0
80009fbe:	c0 80       	breq	80009fce <_vfprintf_r+0x1ece>
80009fc0:	fa ca f9 78 	sub	r10,sp,-1672
80009fc4:	02 9b       	mov	r11,r1
80009fc6:	08 9c       	mov	r12,r4
80009fc8:	fe b0 f0 8e 	rcall	800080e4 <__sprint_r>
80009fcc:	c1 91       	brne	80009ffe <_vfprintf_r+0x1efe>
80009fce:	30 0b       	mov	r11,0
80009fd0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fd4:	fb 4b 06 8c 	st.w	sp[1676],r11
80009fd8:	fe 9f f1 22 	bral	8000821c <_vfprintf_r+0x11c>
80009fdc:	08 95       	mov	r5,r4
80009fde:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fe2:	58 08       	cp.w	r8,0
80009fe4:	c0 80       	breq	80009ff4 <_vfprintf_r+0x1ef4>
80009fe6:	08 9c       	mov	r12,r4
80009fe8:	fa ca f9 78 	sub	r10,sp,-1672
80009fec:	02 9b       	mov	r11,r1
80009fee:	fe b0 f0 7b 	rcall	800080e4 <__sprint_r>
80009ff2:	c0 61       	brne	80009ffe <_vfprintf_r+0x1efe>
80009ff4:	30 08       	mov	r8,0
80009ff6:	fb 48 06 8c 	st.w	sp[1676],r8
80009ffa:	c0 28       	rjmp	80009ffe <_vfprintf_r+0x1efe>
80009ffc:	40 41       	lddsp	r1,sp[0x10]
80009ffe:	82 68       	ld.sh	r8,r1[0xc]
8000a000:	ed b8 00 06 	bld	r8,0x6
8000a004:	c0 31       	brne	8000a00a <_vfprintf_r+0x1f0a>
8000a006:	3f fa       	mov	r10,-1
8000a008:	50 ba       	stdsp	sp[0x2c],r10
8000a00a:	40 bc       	lddsp	r12,sp[0x2c]
8000a00c:	fe 3d f9 44 	sub	sp,-1724
8000a010:	d8 32       	popm	r0-r7,pc
8000a012:	d7 03       	nop

8000a014 <__swsetup_r>:
8000a014:	d4 21       	pushm	r4-r7,lr
8000a016:	e0 68 0a 40 	mov	r8,2624
8000a01a:	18 96       	mov	r6,r12
8000a01c:	16 97       	mov	r7,r11
8000a01e:	70 0c       	ld.w	r12,r8[0x0]
8000a020:	58 0c       	cp.w	r12,0
8000a022:	c0 60       	breq	8000a02e <__swsetup_r+0x1a>
8000a024:	78 68       	ld.w	r8,r12[0x18]
8000a026:	58 08       	cp.w	r8,0
8000a028:	c0 31       	brne	8000a02e <__swsetup_r+0x1a>
8000a02a:	e0 a0 07 bf 	rcall	8000afa8 <__sinit>
8000a02e:	fe c8 bf 16 	sub	r8,pc,-16618
8000a032:	10 37       	cp.w	r7,r8
8000a034:	c0 61       	brne	8000a040 <__swsetup_r+0x2c>
8000a036:	e0 68 0a 40 	mov	r8,2624
8000a03a:	70 08       	ld.w	r8,r8[0x0]
8000a03c:	70 07       	ld.w	r7,r8[0x0]
8000a03e:	c1 28       	rjmp	8000a062 <__swsetup_r+0x4e>
8000a040:	fe c8 bf 08 	sub	r8,pc,-16632
8000a044:	10 37       	cp.w	r7,r8
8000a046:	c0 61       	brne	8000a052 <__swsetup_r+0x3e>
8000a048:	e0 68 0a 40 	mov	r8,2624
8000a04c:	70 08       	ld.w	r8,r8[0x0]
8000a04e:	70 17       	ld.w	r7,r8[0x4]
8000a050:	c0 98       	rjmp	8000a062 <__swsetup_r+0x4e>
8000a052:	fe c8 be fa 	sub	r8,pc,-16646
8000a056:	10 37       	cp.w	r7,r8
8000a058:	c0 51       	brne	8000a062 <__swsetup_r+0x4e>
8000a05a:	e0 68 0a 40 	mov	r8,2624
8000a05e:	70 08       	ld.w	r8,r8[0x0]
8000a060:	70 27       	ld.w	r7,r8[0x8]
8000a062:	8e 68       	ld.sh	r8,r7[0xc]
8000a064:	ed b8 00 03 	bld	r8,0x3
8000a068:	c1 e0       	breq	8000a0a4 <__swsetup_r+0x90>
8000a06a:	ed b8 00 04 	bld	r8,0x4
8000a06e:	c3 e1       	brne	8000a0ea <__swsetup_r+0xd6>
8000a070:	ed b8 00 02 	bld	r8,0x2
8000a074:	c1 51       	brne	8000a09e <__swsetup_r+0x8a>
8000a076:	6e db       	ld.w	r11,r7[0x34]
8000a078:	58 0b       	cp.w	r11,0
8000a07a:	c0 a0       	breq	8000a08e <__swsetup_r+0x7a>
8000a07c:	ee c8 ff bc 	sub	r8,r7,-68
8000a080:	10 3b       	cp.w	r11,r8
8000a082:	c0 40       	breq	8000a08a <__swsetup_r+0x76>
8000a084:	0c 9c       	mov	r12,r6
8000a086:	e0 a0 08 2b 	rcall	8000b0dc <_free_r>
8000a08a:	30 08       	mov	r8,0
8000a08c:	8f d8       	st.w	r7[0x34],r8
8000a08e:	8e 68       	ld.sh	r8,r7[0xc]
8000a090:	e0 18 ff db 	andl	r8,0xffdb
8000a094:	ae 68       	st.h	r7[0xc],r8
8000a096:	30 08       	mov	r8,0
8000a098:	8f 18       	st.w	r7[0x4],r8
8000a09a:	6e 48       	ld.w	r8,r7[0x10]
8000a09c:	8f 08       	st.w	r7[0x0],r8
8000a09e:	8e 68       	ld.sh	r8,r7[0xc]
8000a0a0:	a3 b8       	sbr	r8,0x3
8000a0a2:	ae 68       	st.h	r7[0xc],r8
8000a0a4:	6e 48       	ld.w	r8,r7[0x10]
8000a0a6:	58 08       	cp.w	r8,0
8000a0a8:	c0 b1       	brne	8000a0be <__swsetup_r+0xaa>
8000a0aa:	8e 68       	ld.sh	r8,r7[0xc]
8000a0ac:	e2 18 02 80 	andl	r8,0x280,COH
8000a0b0:	e0 48 02 00 	cp.w	r8,512
8000a0b4:	c0 50       	breq	8000a0be <__swsetup_r+0xaa>
8000a0b6:	0c 9c       	mov	r12,r6
8000a0b8:	0e 9b       	mov	r11,r7
8000a0ba:	e0 a0 0a 4b 	rcall	8000b550 <__smakebuf_r>
8000a0be:	8e 69       	ld.sh	r9,r7[0xc]
8000a0c0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a0c4:	c0 70       	breq	8000a0d2 <__swsetup_r+0xbe>
8000a0c6:	30 08       	mov	r8,0
8000a0c8:	8f 28       	st.w	r7[0x8],r8
8000a0ca:	6e 58       	ld.w	r8,r7[0x14]
8000a0cc:	5c 38       	neg	r8
8000a0ce:	8f 68       	st.w	r7[0x18],r8
8000a0d0:	c0 68       	rjmp	8000a0dc <__swsetup_r+0xc8>
8000a0d2:	ed b9 00 01 	bld	r9,0x1
8000a0d6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a0da:	8f 28       	st.w	r7[0x8],r8
8000a0dc:	6e 48       	ld.w	r8,r7[0x10]
8000a0de:	58 08       	cp.w	r8,0
8000a0e0:	c0 61       	brne	8000a0ec <__swsetup_r+0xd8>
8000a0e2:	8e 68       	ld.sh	r8,r7[0xc]
8000a0e4:	ed b8 00 07 	bld	r8,0x7
8000a0e8:	c0 21       	brne	8000a0ec <__swsetup_r+0xd8>
8000a0ea:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a0ec:	d8 2a       	popm	r4-r7,pc,r12=0
8000a0ee:	d7 03       	nop

8000a0f0 <quorem>:
8000a0f0:	d4 31       	pushm	r0-r7,lr
8000a0f2:	20 2d       	sub	sp,8
8000a0f4:	18 97       	mov	r7,r12
8000a0f6:	78 48       	ld.w	r8,r12[0x10]
8000a0f8:	76 46       	ld.w	r6,r11[0x10]
8000a0fa:	0c 38       	cp.w	r8,r6
8000a0fc:	c0 34       	brge	8000a102 <quorem+0x12>
8000a0fe:	30 0c       	mov	r12,0
8000a100:	c8 58       	rjmp	8000a20a <quorem+0x11a>
8000a102:	ec c2 ff fc 	sub	r2,r6,-4
8000a106:	f6 c3 ff ec 	sub	r3,r11,-20
8000a10a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a10e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a112:	2f f9       	sub	r9,-1
8000a114:	20 16       	sub	r6,1
8000a116:	f8 09 0d 08 	divu	r8,r12,r9
8000a11a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a11e:	ee c4 ff ec 	sub	r4,r7,-20
8000a122:	10 95       	mov	r5,r8
8000a124:	58 08       	cp.w	r8,0
8000a126:	c4 10       	breq	8000a1a8 <quorem+0xb8>
8000a128:	30 09       	mov	r9,0
8000a12a:	06 9a       	mov	r10,r3
8000a12c:	08 98       	mov	r8,r4
8000a12e:	12 91       	mov	r1,r9
8000a130:	50 0b       	stdsp	sp[0x0],r11
8000a132:	70 0e       	ld.w	lr,r8[0x0]
8000a134:	b1 8e       	lsr	lr,0x10
8000a136:	50 1e       	stdsp	sp[0x4],lr
8000a138:	15 0e       	ld.w	lr,r10++
8000a13a:	fc 00 16 10 	lsr	r0,lr,0x10
8000a13e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a142:	ea 0e 03 41 	mac	r1,r5,lr
8000a146:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a14a:	b1 81       	lsr	r1,0x10
8000a14c:	40 1b       	lddsp	r11,sp[0x4]
8000a14e:	ea 00 02 40 	mul	r0,r5,r0
8000a152:	e2 00 00 00 	add	r0,r1,r0
8000a156:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a15a:	02 1b       	sub	r11,r1
8000a15c:	50 1b       	stdsp	sp[0x4],r11
8000a15e:	70 0b       	ld.w	r11,r8[0x0]
8000a160:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a164:	02 09       	add	r9,r1
8000a166:	f2 0e 01 0e 	sub	lr,r9,lr
8000a16a:	b0 1e       	st.h	r8[0x2],lr
8000a16c:	fc 09 14 10 	asr	r9,lr,0x10
8000a170:	40 1e       	lddsp	lr,sp[0x4]
8000a172:	fc 09 00 09 	add	r9,lr,r9
8000a176:	b0 09       	st.h	r8[0x0],r9
8000a178:	e0 01 16 10 	lsr	r1,r0,0x10
8000a17c:	2f c8       	sub	r8,-4
8000a17e:	b1 49       	asr	r9,0x10
8000a180:	04 3a       	cp.w	r10,r2
8000a182:	fe 98 ff d8 	brls	8000a132 <quorem+0x42>
8000a186:	40 0b       	lddsp	r11,sp[0x0]
8000a188:	58 0c       	cp.w	r12,0
8000a18a:	c0 f1       	brne	8000a1a8 <quorem+0xb8>
8000a18c:	ec c8 ff fb 	sub	r8,r6,-5
8000a190:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a194:	c0 28       	rjmp	8000a198 <quorem+0xa8>
8000a196:	20 16       	sub	r6,1
8000a198:	20 48       	sub	r8,4
8000a19a:	08 38       	cp.w	r8,r4
8000a19c:	e0 88 00 05 	brls	8000a1a6 <quorem+0xb6>
8000a1a0:	70 09       	ld.w	r9,r8[0x0]
8000a1a2:	58 09       	cp.w	r9,0
8000a1a4:	cf 90       	breq	8000a196 <quorem+0xa6>
8000a1a6:	8f 46       	st.w	r7[0x10],r6
8000a1a8:	0e 9c       	mov	r12,r7
8000a1aa:	e0 a0 0a d2 	rcall	8000b74e <__mcmp>
8000a1ae:	c2 d5       	brlt	8000a208 <quorem+0x118>
8000a1b0:	2f f5       	sub	r5,-1
8000a1b2:	08 98       	mov	r8,r4
8000a1b4:	30 09       	mov	r9,0
8000a1b6:	07 0b       	ld.w	r11,r3++
8000a1b8:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a1bc:	70 0c       	ld.w	r12,r8[0x0]
8000a1be:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a1c2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a1c6:	14 1e       	sub	lr,r10
8000a1c8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a1cc:	16 1a       	sub	r10,r11
8000a1ce:	12 0a       	add	r10,r9
8000a1d0:	b0 1a       	st.h	r8[0x2],r10
8000a1d2:	b1 4a       	asr	r10,0x10
8000a1d4:	fc 0a 00 09 	add	r9,lr,r10
8000a1d8:	b0 09       	st.h	r8[0x0],r9
8000a1da:	2f c8       	sub	r8,-4
8000a1dc:	b1 49       	asr	r9,0x10
8000a1de:	04 33       	cp.w	r3,r2
8000a1e0:	fe 98 ff eb 	brls	8000a1b6 <quorem+0xc6>
8000a1e4:	ec c8 ff fb 	sub	r8,r6,-5
8000a1e8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a1ec:	58 09       	cp.w	r9,0
8000a1ee:	c0 d1       	brne	8000a208 <quorem+0x118>
8000a1f0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a1f4:	c0 28       	rjmp	8000a1f8 <quorem+0x108>
8000a1f6:	20 16       	sub	r6,1
8000a1f8:	20 48       	sub	r8,4
8000a1fa:	08 38       	cp.w	r8,r4
8000a1fc:	e0 88 00 05 	brls	8000a206 <quorem+0x116>
8000a200:	70 09       	ld.w	r9,r8[0x0]
8000a202:	58 09       	cp.w	r9,0
8000a204:	cf 90       	breq	8000a1f6 <quorem+0x106>
8000a206:	8f 46       	st.w	r7[0x10],r6
8000a208:	0a 9c       	mov	r12,r5
8000a20a:	2f ed       	sub	sp,-8
8000a20c:	d8 32       	popm	r0-r7,pc
8000a20e:	d7 03       	nop

8000a210 <_dtoa_r>:
8000a210:	d4 31       	pushm	r0-r7,lr
8000a212:	21 ad       	sub	sp,104
8000a214:	fa c4 ff 74 	sub	r4,sp,-140
8000a218:	18 97       	mov	r7,r12
8000a21a:	16 95       	mov	r5,r11
8000a21c:	68 2c       	ld.w	r12,r4[0x8]
8000a21e:	50 c9       	stdsp	sp[0x30],r9
8000a220:	68 16       	ld.w	r6,r4[0x4]
8000a222:	68 09       	ld.w	r9,r4[0x0]
8000a224:	50 e8       	stdsp	sp[0x38],r8
8000a226:	14 94       	mov	r4,r10
8000a228:	51 2c       	stdsp	sp[0x48],r12
8000a22a:	fa e5 00 08 	st.d	sp[8],r4
8000a22e:	51 59       	stdsp	sp[0x54],r9
8000a230:	6e 95       	ld.w	r5,r7[0x24]
8000a232:	58 05       	cp.w	r5,0
8000a234:	c0 91       	brne	8000a246 <_dtoa_r+0x36>
8000a236:	31 0c       	mov	r12,16
8000a238:	fe b0 e8 f4 	rcall	80007420 <malloc>
8000a23c:	99 35       	st.w	r12[0xc],r5
8000a23e:	8f 9c       	st.w	r7[0x24],r12
8000a240:	99 15       	st.w	r12[0x4],r5
8000a242:	99 25       	st.w	r12[0x8],r5
8000a244:	99 05       	st.w	r12[0x0],r5
8000a246:	6e 99       	ld.w	r9,r7[0x24]
8000a248:	72 08       	ld.w	r8,r9[0x0]
8000a24a:	58 08       	cp.w	r8,0
8000a24c:	c0 f0       	breq	8000a26a <_dtoa_r+0x5a>
8000a24e:	72 1a       	ld.w	r10,r9[0x4]
8000a250:	91 1a       	st.w	r8[0x4],r10
8000a252:	30 1a       	mov	r10,1
8000a254:	72 19       	ld.w	r9,r9[0x4]
8000a256:	f4 09 09 49 	lsl	r9,r10,r9
8000a25a:	10 9b       	mov	r11,r8
8000a25c:	91 29       	st.w	r8[0x8],r9
8000a25e:	0e 9c       	mov	r12,r7
8000a260:	e0 a0 0a 90 	rcall	8000b780 <_Bfree>
8000a264:	6e 98       	ld.w	r8,r7[0x24]
8000a266:	30 09       	mov	r9,0
8000a268:	91 09       	st.w	r8[0x0],r9
8000a26a:	40 28       	lddsp	r8,sp[0x8]
8000a26c:	10 94       	mov	r4,r8
8000a26e:	58 08       	cp.w	r8,0
8000a270:	c0 64       	brge	8000a27c <_dtoa_r+0x6c>
8000a272:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a276:	50 28       	stdsp	sp[0x8],r8
8000a278:	30 18       	mov	r8,1
8000a27a:	c0 28       	rjmp	8000a27e <_dtoa_r+0x6e>
8000a27c:	30 08       	mov	r8,0
8000a27e:	8d 08       	st.w	r6[0x0],r8
8000a280:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a284:	40 26       	lddsp	r6,sp[0x8]
8000a286:	0c 98       	mov	r8,r6
8000a288:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a28c:	18 38       	cp.w	r8,r12
8000a28e:	c2 01       	brne	8000a2ce <_dtoa_r+0xbe>
8000a290:	e0 68 27 0f 	mov	r8,9999
8000a294:	41 5b       	lddsp	r11,sp[0x54]
8000a296:	97 08       	st.w	r11[0x0],r8
8000a298:	40 3a       	lddsp	r10,sp[0xc]
8000a29a:	58 0a       	cp.w	r10,0
8000a29c:	c0 71       	brne	8000a2aa <_dtoa_r+0x9a>
8000a29e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a2a2:	c0 41       	brne	8000a2aa <_dtoa_r+0x9a>
8000a2a4:	fe cc c1 9c 	sub	r12,pc,-15972
8000a2a8:	c0 38       	rjmp	8000a2ae <_dtoa_r+0x9e>
8000a2aa:	fe cc c1 96 	sub	r12,pc,-15978
8000a2ae:	41 29       	lddsp	r9,sp[0x48]
8000a2b0:	58 09       	cp.w	r9,0
8000a2b2:	e0 80 05 9a 	breq	8000ade6 <_dtoa_r+0xbd6>
8000a2b6:	f8 c8 ff fd 	sub	r8,r12,-3
8000a2ba:	f8 c9 ff f8 	sub	r9,r12,-8
8000a2be:	11 8b       	ld.ub	r11,r8[0x0]
8000a2c0:	30 0a       	mov	r10,0
8000a2c2:	41 25       	lddsp	r5,sp[0x48]
8000a2c4:	f4 0b 18 00 	cp.b	r11,r10
8000a2c8:	f2 08 17 10 	movne	r8,r9
8000a2cc:	c1 68       	rjmp	8000a2f8 <_dtoa_r+0xe8>
8000a2ce:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2d2:	30 08       	mov	r8,0
8000a2d4:	fa eb 00 3c 	st.d	sp[60],r10
8000a2d8:	30 09       	mov	r9,0
8000a2da:	e0 a0 10 ce 	rcall	8000c476 <__avr32_f64_cmp_eq>
8000a2de:	c1 00       	breq	8000a2fe <_dtoa_r+0xee>
8000a2e0:	30 18       	mov	r8,1
8000a2e2:	41 5a       	lddsp	r10,sp[0x54]
8000a2e4:	95 08       	st.w	r10[0x0],r8
8000a2e6:	fe cc c3 02 	sub	r12,pc,-15614
8000a2ea:	41 29       	lddsp	r9,sp[0x48]
8000a2ec:	f8 08 00 08 	add	r8,r12,r8
8000a2f0:	58 09       	cp.w	r9,0
8000a2f2:	e0 80 05 7a 	breq	8000ade6 <_dtoa_r+0xbd6>
8000a2f6:	12 95       	mov	r5,r9
8000a2f8:	8b 08       	st.w	r5[0x0],r8
8000a2fa:	e0 8f 05 76 	bral	8000ade6 <_dtoa_r+0xbd6>
8000a2fe:	fa c8 ff 9c 	sub	r8,sp,-100
8000a302:	fa c9 ff a0 	sub	r9,sp,-96
8000a306:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a30a:	0e 9c       	mov	r12,r7
8000a30c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a310:	e0 a0 0a 8a 	rcall	8000b824 <__d2b>
8000a314:	18 93       	mov	r3,r12
8000a316:	58 05       	cp.w	r5,0
8000a318:	c0 d0       	breq	8000a332 <_dtoa_r+0x122>
8000a31a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a31e:	30 04       	mov	r4,0
8000a320:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a324:	ea c5 03 ff 	sub	r5,r5,1023
8000a328:	10 9b       	mov	r11,r8
8000a32a:	51 74       	stdsp	sp[0x5c],r4
8000a32c:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a330:	c2 58       	rjmp	8000a37a <_dtoa_r+0x16a>
8000a332:	41 88       	lddsp	r8,sp[0x60]
8000a334:	41 9c       	lddsp	r12,sp[0x64]
8000a336:	10 0c       	add	r12,r8
8000a338:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a33c:	e0 45 00 20 	cp.w	r5,32
8000a340:	e0 8a 00 0e 	brle	8000a35c <_dtoa_r+0x14c>
8000a344:	f8 cc fb ee 	sub	r12,r12,-1042
8000a348:	40 3b       	lddsp	r11,sp[0xc]
8000a34a:	ea 08 11 40 	rsub	r8,r5,64
8000a34e:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a352:	ec 08 09 46 	lsl	r6,r6,r8
8000a356:	0c 4c       	or	r12,r6
8000a358:	c0 78       	rjmp	8000a366 <_dtoa_r+0x156>
8000a35a:	d7 03       	nop
8000a35c:	ea 0c 11 20 	rsub	r12,r5,32
8000a360:	40 3a       	lddsp	r10,sp[0xc]
8000a362:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a366:	e0 a0 10 14 	rcall	8000c38e <__avr32_u32_to_f64>
8000a36a:	fc 18 fe 10 	movh	r8,0xfe10
8000a36e:	30 19       	mov	r9,1
8000a370:	ea c5 04 33 	sub	r5,r5,1075
8000a374:	f0 0b 00 0b 	add	r11,r8,r11
8000a378:	51 79       	stdsp	sp[0x5c],r9
8000a37a:	30 08       	mov	r8,0
8000a37c:	fc 19 3f f8 	movh	r9,0x3ff8
8000a380:	e0 a0 0e 9c 	rcall	8000c0b8 <__avr32_f64_sub>
8000a384:	e0 68 43 61 	mov	r8,17249
8000a388:	ea 18 63 6f 	orh	r8,0x636f
8000a38c:	e0 69 87 a7 	mov	r9,34727
8000a390:	ea 19 3f d2 	orh	r9,0x3fd2
8000a394:	e0 a0 0d a6 	rcall	8000bee0 <__avr32_f64_mul>
8000a398:	e0 68 c8 b3 	mov	r8,51379
8000a39c:	ea 18 8b 60 	orh	r8,0x8b60
8000a3a0:	e0 69 8a 28 	mov	r9,35368
8000a3a4:	ea 19 3f c6 	orh	r9,0x3fc6
8000a3a8:	e0 a0 0f 56 	rcall	8000c254 <__avr32_f64_add>
8000a3ac:	0a 9c       	mov	r12,r5
8000a3ae:	14 90       	mov	r0,r10
8000a3b0:	16 91       	mov	r1,r11
8000a3b2:	e0 a0 0f f2 	rcall	8000c396 <__avr32_s32_to_f64>
8000a3b6:	e0 68 79 fb 	mov	r8,31227
8000a3ba:	ea 18 50 9f 	orh	r8,0x509f
8000a3be:	e0 69 44 13 	mov	r9,17427
8000a3c2:	ea 19 3f d3 	orh	r9,0x3fd3
8000a3c6:	e0 a0 0d 8d 	rcall	8000bee0 <__avr32_f64_mul>
8000a3ca:	14 98       	mov	r8,r10
8000a3cc:	16 99       	mov	r9,r11
8000a3ce:	00 9a       	mov	r10,r0
8000a3d0:	02 9b       	mov	r11,r1
8000a3d2:	e0 a0 0f 41 	rcall	8000c254 <__avr32_f64_add>
8000a3d6:	14 90       	mov	r0,r10
8000a3d8:	16 91       	mov	r1,r11
8000a3da:	e0 a0 0f c7 	rcall	8000c368 <__avr32_f64_to_s32>
8000a3de:	30 08       	mov	r8,0
8000a3e0:	18 96       	mov	r6,r12
8000a3e2:	30 09       	mov	r9,0
8000a3e4:	00 9a       	mov	r10,r0
8000a3e6:	02 9b       	mov	r11,r1
8000a3e8:	e0 a0 10 8e 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a3ec:	c0 c0       	breq	8000a404 <_dtoa_r+0x1f4>
8000a3ee:	0c 9c       	mov	r12,r6
8000a3f0:	e0 a0 0f d3 	rcall	8000c396 <__avr32_s32_to_f64>
8000a3f4:	14 98       	mov	r8,r10
8000a3f6:	16 99       	mov	r9,r11
8000a3f8:	00 9a       	mov	r10,r0
8000a3fa:	02 9b       	mov	r11,r1
8000a3fc:	e0 a0 10 3d 	rcall	8000c476 <__avr32_f64_cmp_eq>
8000a400:	f7 b6 00 01 	subeq	r6,1
8000a404:	59 66       	cp.w	r6,22
8000a406:	e0 88 00 05 	brls	8000a410 <_dtoa_r+0x200>
8000a40a:	30 18       	mov	r8,1
8000a40c:	51 48       	stdsp	sp[0x50],r8
8000a40e:	c1 38       	rjmp	8000a434 <_dtoa_r+0x224>
8000a410:	fe c8 c2 48 	sub	r8,pc,-15800
8000a414:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a418:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a41c:	e0 a0 10 74 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a420:	f9 b4 00 00 	moveq	r4,0
8000a424:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a428:	f7 b6 01 01 	subne	r6,1
8000a42c:	f9 bc 01 00 	movne	r12,0
8000a430:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a434:	41 90       	lddsp	r0,sp[0x64]
8000a436:	20 10       	sub	r0,1
8000a438:	0a 10       	sub	r0,r5
8000a43a:	c0 46       	brmi	8000a442 <_dtoa_r+0x232>
8000a43c:	50 40       	stdsp	sp[0x10],r0
8000a43e:	30 00       	mov	r0,0
8000a440:	c0 48       	rjmp	8000a448 <_dtoa_r+0x238>
8000a442:	30 0b       	mov	r11,0
8000a444:	5c 30       	neg	r0
8000a446:	50 4b       	stdsp	sp[0x10],r11
8000a448:	ec 02 11 00 	rsub	r2,r6,0
8000a44c:	58 06       	cp.w	r6,0
8000a44e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a452:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a456:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a45a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a45e:	f9 b2 04 00 	movge	r2,0
8000a462:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a466:	f9 b9 05 00 	movlt	r9,0
8000a46a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a46e:	40 c8       	lddsp	r8,sp[0x30]
8000a470:	58 98       	cp.w	r8,9
8000a472:	e0 8b 00 20 	brhi	8000a4b2 <_dtoa_r+0x2a2>
8000a476:	58 58       	cp.w	r8,5
8000a478:	f9 b4 0a 01 	movle	r4,1
8000a47c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a480:	f7 b5 09 04 	subgt	r5,4
8000a484:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a488:	f9 b4 09 00 	movgt	r4,0
8000a48c:	40 cc       	lddsp	r12,sp[0x30]
8000a48e:	58 3c       	cp.w	r12,3
8000a490:	c2 d0       	breq	8000a4ea <_dtoa_r+0x2da>
8000a492:	e0 89 00 05 	brgt	8000a49c <_dtoa_r+0x28c>
8000a496:	58 2c       	cp.w	r12,2
8000a498:	c1 01       	brne	8000a4b8 <_dtoa_r+0x2a8>
8000a49a:	c1 88       	rjmp	8000a4ca <_dtoa_r+0x2ba>
8000a49c:	40 cb       	lddsp	r11,sp[0x30]
8000a49e:	58 4b       	cp.w	r11,4
8000a4a0:	c0 60       	breq	8000a4ac <_dtoa_r+0x29c>
8000a4a2:	58 5b       	cp.w	r11,5
8000a4a4:	c0 a1       	brne	8000a4b8 <_dtoa_r+0x2a8>
8000a4a6:	30 1a       	mov	r10,1
8000a4a8:	50 da       	stdsp	sp[0x34],r10
8000a4aa:	c2 28       	rjmp	8000a4ee <_dtoa_r+0x2de>
8000a4ac:	30 19       	mov	r9,1
8000a4ae:	50 d9       	stdsp	sp[0x34],r9
8000a4b0:	c0 f8       	rjmp	8000a4ce <_dtoa_r+0x2be>
8000a4b2:	30 08       	mov	r8,0
8000a4b4:	30 14       	mov	r4,1
8000a4b6:	50 c8       	stdsp	sp[0x30],r8
8000a4b8:	3f f5       	mov	r5,-1
8000a4ba:	30 1c       	mov	r12,1
8000a4bc:	30 0b       	mov	r11,0
8000a4be:	50 95       	stdsp	sp[0x24],r5
8000a4c0:	50 dc       	stdsp	sp[0x34],r12
8000a4c2:	0a 91       	mov	r1,r5
8000a4c4:	31 28       	mov	r8,18
8000a4c6:	50 eb       	stdsp	sp[0x38],r11
8000a4c8:	c2 08       	rjmp	8000a508 <_dtoa_r+0x2f8>
8000a4ca:	30 0a       	mov	r10,0
8000a4cc:	50 da       	stdsp	sp[0x34],r10
8000a4ce:	40 e9       	lddsp	r9,sp[0x38]
8000a4d0:	58 09       	cp.w	r9,0
8000a4d2:	e0 89 00 07 	brgt	8000a4e0 <_dtoa_r+0x2d0>
8000a4d6:	30 18       	mov	r8,1
8000a4d8:	50 98       	stdsp	sp[0x24],r8
8000a4da:	10 91       	mov	r1,r8
8000a4dc:	50 e8       	stdsp	sp[0x38],r8
8000a4de:	c1 58       	rjmp	8000a508 <_dtoa_r+0x2f8>
8000a4e0:	40 e5       	lddsp	r5,sp[0x38]
8000a4e2:	50 95       	stdsp	sp[0x24],r5
8000a4e4:	0a 91       	mov	r1,r5
8000a4e6:	0a 98       	mov	r8,r5
8000a4e8:	c1 08       	rjmp	8000a508 <_dtoa_r+0x2f8>
8000a4ea:	30 0c       	mov	r12,0
8000a4ec:	50 dc       	stdsp	sp[0x34],r12
8000a4ee:	40 eb       	lddsp	r11,sp[0x38]
8000a4f0:	ec 0b 00 0b 	add	r11,r6,r11
8000a4f4:	50 9b       	stdsp	sp[0x24],r11
8000a4f6:	16 98       	mov	r8,r11
8000a4f8:	2f f8       	sub	r8,-1
8000a4fa:	58 08       	cp.w	r8,0
8000a4fc:	e0 89 00 05 	brgt	8000a506 <_dtoa_r+0x2f6>
8000a500:	10 91       	mov	r1,r8
8000a502:	30 18       	mov	r8,1
8000a504:	c0 28       	rjmp	8000a508 <_dtoa_r+0x2f8>
8000a506:	10 91       	mov	r1,r8
8000a508:	30 09       	mov	r9,0
8000a50a:	6e 9a       	ld.w	r10,r7[0x24]
8000a50c:	95 19       	st.w	r10[0x4],r9
8000a50e:	30 49       	mov	r9,4
8000a510:	c0 68       	rjmp	8000a51c <_dtoa_r+0x30c>
8000a512:	d7 03       	nop
8000a514:	6a 1a       	ld.w	r10,r5[0x4]
8000a516:	a1 79       	lsl	r9,0x1
8000a518:	2f fa       	sub	r10,-1
8000a51a:	8b 1a       	st.w	r5[0x4],r10
8000a51c:	6e 95       	ld.w	r5,r7[0x24]
8000a51e:	f2 ca ff ec 	sub	r10,r9,-20
8000a522:	10 3a       	cp.w	r10,r8
8000a524:	fe 98 ff f8 	brls	8000a514 <_dtoa_r+0x304>
8000a528:	6a 1b       	ld.w	r11,r5[0x4]
8000a52a:	0e 9c       	mov	r12,r7
8000a52c:	e0 a0 09 44 	rcall	8000b7b4 <_Balloc>
8000a530:	58 e1       	cp.w	r1,14
8000a532:	5f 88       	srls	r8
8000a534:	8b 0c       	st.w	r5[0x0],r12
8000a536:	f1 e4 00 04 	and	r4,r8,r4
8000a53a:	6e 98       	ld.w	r8,r7[0x24]
8000a53c:	70 08       	ld.w	r8,r8[0x0]
8000a53e:	50 88       	stdsp	sp[0x20],r8
8000a540:	e0 80 01 82 	breq	8000a844 <_dtoa_r+0x634>
8000a544:	58 06       	cp.w	r6,0
8000a546:	e0 8a 00 43 	brle	8000a5cc <_dtoa_r+0x3bc>
8000a54a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a54e:	fe c8 c3 86 	sub	r8,pc,-15482
8000a552:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a556:	fa e5 00 18 	st.d	sp[24],r4
8000a55a:	ec 04 14 04 	asr	r4,r6,0x4
8000a55e:	ed b4 00 04 	bld	r4,0x4
8000a562:	c0 30       	breq	8000a568 <_dtoa_r+0x358>
8000a564:	30 25       	mov	r5,2
8000a566:	c1 08       	rjmp	8000a586 <_dtoa_r+0x376>
8000a568:	fe c8 c2 d8 	sub	r8,pc,-15656
8000a56c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a570:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a574:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a578:	e0 a0 0f fa 	rcall	8000c56c <__avr32_f64_div>
8000a57c:	30 35       	mov	r5,3
8000a57e:	14 98       	mov	r8,r10
8000a580:	16 99       	mov	r9,r11
8000a582:	fa e9 00 08 	st.d	sp[8],r8
8000a586:	fe cc c2 f6 	sub	r12,pc,-15626
8000a58a:	50 a3       	stdsp	sp[0x28],r3
8000a58c:	0c 93       	mov	r3,r6
8000a58e:	18 96       	mov	r6,r12
8000a590:	c0 f8       	rjmp	8000a5ae <_dtoa_r+0x39e>
8000a592:	fa ea 00 18 	ld.d	r10,sp[24]
8000a596:	ed b4 00 00 	bld	r4,0x0
8000a59a:	c0 81       	brne	8000a5aa <_dtoa_r+0x39a>
8000a59c:	ec e8 00 00 	ld.d	r8,r6[0]
8000a5a0:	2f f5       	sub	r5,-1
8000a5a2:	e0 a0 0c 9f 	rcall	8000bee0 <__avr32_f64_mul>
8000a5a6:	fa eb 00 18 	st.d	sp[24],r10
8000a5aa:	a1 54       	asr	r4,0x1
8000a5ac:	2f 86       	sub	r6,-8
8000a5ae:	58 04       	cp.w	r4,0
8000a5b0:	cf 11       	brne	8000a592 <_dtoa_r+0x382>
8000a5b2:	fa e8 00 18 	ld.d	r8,sp[24]
8000a5b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5ba:	06 96       	mov	r6,r3
8000a5bc:	e0 a0 0f d8 	rcall	8000c56c <__avr32_f64_div>
8000a5c0:	40 a3       	lddsp	r3,sp[0x28]
8000a5c2:	14 98       	mov	r8,r10
8000a5c4:	16 99       	mov	r9,r11
8000a5c6:	fa e9 00 08 	st.d	sp[8],r8
8000a5ca:	c2 f8       	rjmp	8000a628 <_dtoa_r+0x418>
8000a5cc:	ec 08 11 00 	rsub	r8,r6,0
8000a5d0:	c0 31       	brne	8000a5d6 <_dtoa_r+0x3c6>
8000a5d2:	30 25       	mov	r5,2
8000a5d4:	c2 a8       	rjmp	8000a628 <_dtoa_r+0x418>
8000a5d6:	fe cc c3 46 	sub	r12,pc,-15546
8000a5da:	f0 04 14 04 	asr	r4,r8,0x4
8000a5de:	50 1c       	stdsp	sp[0x4],r12
8000a5e0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a5e4:	fe c9 c4 1c 	sub	r9,pc,-15332
8000a5e8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5ec:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a5f0:	e0 a0 0c 78 	rcall	8000bee0 <__avr32_f64_mul>
8000a5f4:	40 1c       	lddsp	r12,sp[0x4]
8000a5f6:	50 63       	stdsp	sp[0x18],r3
8000a5f8:	30 25       	mov	r5,2
8000a5fa:	0c 93       	mov	r3,r6
8000a5fc:	fa eb 00 08 	st.d	sp[8],r10
8000a600:	18 96       	mov	r6,r12
8000a602:	c0 f8       	rjmp	8000a620 <_dtoa_r+0x410>
8000a604:	fa ea 00 08 	ld.d	r10,sp[8]
8000a608:	ed b4 00 00 	bld	r4,0x0
8000a60c:	c0 81       	brne	8000a61c <_dtoa_r+0x40c>
8000a60e:	ec e8 00 00 	ld.d	r8,r6[0]
8000a612:	2f f5       	sub	r5,-1
8000a614:	e0 a0 0c 66 	rcall	8000bee0 <__avr32_f64_mul>
8000a618:	fa eb 00 08 	st.d	sp[8],r10
8000a61c:	a1 54       	asr	r4,0x1
8000a61e:	2f 86       	sub	r6,-8
8000a620:	58 04       	cp.w	r4,0
8000a622:	cf 11       	brne	8000a604 <_dtoa_r+0x3f4>
8000a624:	06 96       	mov	r6,r3
8000a626:	40 63       	lddsp	r3,sp[0x18]
8000a628:	41 4a       	lddsp	r10,sp[0x50]
8000a62a:	58 0a       	cp.w	r10,0
8000a62c:	c2 a0       	breq	8000a680 <_dtoa_r+0x470>
8000a62e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a632:	58 01       	cp.w	r1,0
8000a634:	5f 94       	srgt	r4
8000a636:	fa e9 00 18 	st.d	sp[24],r8
8000a63a:	30 08       	mov	r8,0
8000a63c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a640:	fa ea 00 18 	ld.d	r10,sp[24]
8000a644:	e0 a0 0f 60 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a648:	f9 bc 00 00 	moveq	r12,0
8000a64c:	f9 bc 01 01 	movne	r12,1
8000a650:	e9 ec 00 0c 	and	r12,r4,r12
8000a654:	c1 60       	breq	8000a680 <_dtoa_r+0x470>
8000a656:	40 98       	lddsp	r8,sp[0x24]
8000a658:	58 08       	cp.w	r8,0
8000a65a:	e0 8a 00 f1 	brle	8000a83c <_dtoa_r+0x62c>
8000a65e:	30 08       	mov	r8,0
8000a660:	fc 19 40 24 	movh	r9,0x4024
8000a664:	ec c4 00 01 	sub	r4,r6,1
8000a668:	fa ea 00 18 	ld.d	r10,sp[24]
8000a66c:	2f f5       	sub	r5,-1
8000a66e:	50 64       	stdsp	sp[0x18],r4
8000a670:	e0 a0 0c 38 	rcall	8000bee0 <__avr32_f64_mul>
8000a674:	40 94       	lddsp	r4,sp[0x24]
8000a676:	14 98       	mov	r8,r10
8000a678:	16 99       	mov	r9,r11
8000a67a:	fa e9 00 08 	st.d	sp[8],r8
8000a67e:	c0 38       	rjmp	8000a684 <_dtoa_r+0x474>
8000a680:	50 66       	stdsp	sp[0x18],r6
8000a682:	02 94       	mov	r4,r1
8000a684:	0a 9c       	mov	r12,r5
8000a686:	e0 a0 0e 88 	rcall	8000c396 <__avr32_s32_to_f64>
8000a68a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a68e:	e0 a0 0c 29 	rcall	8000bee0 <__avr32_f64_mul>
8000a692:	30 08       	mov	r8,0
8000a694:	fc 19 40 1c 	movh	r9,0x401c
8000a698:	e0 a0 0d de 	rcall	8000c254 <__avr32_f64_add>
8000a69c:	14 98       	mov	r8,r10
8000a69e:	16 99       	mov	r9,r11
8000a6a0:	fa e9 00 28 	st.d	sp[40],r8
8000a6a4:	fc 18 fc c0 	movh	r8,0xfcc0
8000a6a8:	40 a5       	lddsp	r5,sp[0x28]
8000a6aa:	10 05       	add	r5,r8
8000a6ac:	50 a5       	stdsp	sp[0x28],r5
8000a6ae:	58 04       	cp.w	r4,0
8000a6b0:	c2 11       	brne	8000a6f2 <_dtoa_r+0x4e2>
8000a6b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6b6:	30 08       	mov	r8,0
8000a6b8:	fc 19 40 14 	movh	r9,0x4014
8000a6bc:	e0 a0 0c fe 	rcall	8000c0b8 <__avr32_f64_sub>
8000a6c0:	40 bc       	lddsp	r12,sp[0x2c]
8000a6c2:	fa eb 00 08 	st.d	sp[8],r10
8000a6c6:	14 98       	mov	r8,r10
8000a6c8:	16 99       	mov	r9,r11
8000a6ca:	18 9a       	mov	r10,r12
8000a6cc:	0a 9b       	mov	r11,r5
8000a6ce:	e0 a0 0f 1b 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a6d2:	e0 81 02 54 	brne	8000ab7a <_dtoa_r+0x96a>
8000a6d6:	0a 98       	mov	r8,r5
8000a6d8:	40 b9       	lddsp	r9,sp[0x2c]
8000a6da:	ee 18 80 00 	eorh	r8,0x8000
8000a6de:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6e2:	10 95       	mov	r5,r8
8000a6e4:	12 98       	mov	r8,r9
8000a6e6:	0a 99       	mov	r9,r5
8000a6e8:	e0 a0 0f 0e 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a6ec:	e0 81 02 3e 	brne	8000ab68 <_dtoa_r+0x958>
8000a6f0:	ca 68       	rjmp	8000a83c <_dtoa_r+0x62c>
8000a6f2:	fe c9 c5 2a 	sub	r9,pc,-15062
8000a6f6:	e8 c8 00 01 	sub	r8,r4,1
8000a6fa:	40 d5       	lddsp	r5,sp[0x34]
8000a6fc:	58 05       	cp.w	r5,0
8000a6fe:	c4 f0       	breq	8000a79c <_dtoa_r+0x58c>
8000a700:	30 0c       	mov	r12,0
8000a702:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a706:	51 3c       	stdsp	sp[0x4c],r12
8000a708:	30 0a       	mov	r10,0
8000a70a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a70e:	e0 a0 0f 2f 	rcall	8000c56c <__avr32_f64_div>
8000a712:	fa e8 00 28 	ld.d	r8,sp[40]
8000a716:	40 85       	lddsp	r5,sp[0x20]
8000a718:	e0 a0 0c d0 	rcall	8000c0b8 <__avr32_f64_sub>
8000a71c:	fa eb 00 28 	st.d	sp[40],r10
8000a720:	fa ea 00 08 	ld.d	r10,sp[8]
8000a724:	e0 a0 0e 22 	rcall	8000c368 <__avr32_f64_to_s32>
8000a728:	51 6c       	stdsp	sp[0x58],r12
8000a72a:	e0 a0 0e 36 	rcall	8000c396 <__avr32_s32_to_f64>
8000a72e:	14 98       	mov	r8,r10
8000a730:	16 99       	mov	r9,r11
8000a732:	fa ea 00 08 	ld.d	r10,sp[8]
8000a736:	e0 a0 0c c1 	rcall	8000c0b8 <__avr32_f64_sub>
8000a73a:	fa eb 00 08 	st.d	sp[8],r10
8000a73e:	41 68       	lddsp	r8,sp[0x58]
8000a740:	2d 08       	sub	r8,-48
8000a742:	0a c8       	st.b	r5++,r8
8000a744:	41 39       	lddsp	r9,sp[0x4c]
8000a746:	2f f9       	sub	r9,-1
8000a748:	51 39       	stdsp	sp[0x4c],r9
8000a74a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a74e:	e0 a0 0e db 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a752:	e0 81 03 39 	brne	8000adc4 <_dtoa_r+0xbb4>
8000a756:	fa e8 00 08 	ld.d	r8,sp[8]
8000a75a:	30 0a       	mov	r10,0
8000a75c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a760:	e0 a0 0c ac 	rcall	8000c0b8 <__avr32_f64_sub>
8000a764:	fa e8 00 28 	ld.d	r8,sp[40]
8000a768:	e0 a0 0e ce 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a76c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a770:	30 08       	mov	r8,0
8000a772:	fc 19 40 24 	movh	r9,0x4024
8000a776:	e0 81 00 da 	brne	8000a92a <_dtoa_r+0x71a>
8000a77a:	41 3c       	lddsp	r12,sp[0x4c]
8000a77c:	08 3c       	cp.w	r12,r4
8000a77e:	c5 f4       	brge	8000a83c <_dtoa_r+0x62c>
8000a780:	e0 a0 0b b0 	rcall	8000bee0 <__avr32_f64_mul>
8000a784:	30 08       	mov	r8,0
8000a786:	fa eb 00 28 	st.d	sp[40],r10
8000a78a:	fc 19 40 24 	movh	r9,0x4024
8000a78e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a792:	e0 a0 0b a7 	rcall	8000bee0 <__avr32_f64_mul>
8000a796:	fa eb 00 08 	st.d	sp[8],r10
8000a79a:	cc 3b       	rjmp	8000a720 <_dtoa_r+0x510>
8000a79c:	40 85       	lddsp	r5,sp[0x20]
8000a79e:	08 05       	add	r5,r4
8000a7a0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a7a4:	51 35       	stdsp	sp[0x4c],r5
8000a7a6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7aa:	40 85       	lddsp	r5,sp[0x20]
8000a7ac:	e0 a0 0b 9a 	rcall	8000bee0 <__avr32_f64_mul>
8000a7b0:	fa eb 00 28 	st.d	sp[40],r10
8000a7b4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7b8:	e0 a0 0d d8 	rcall	8000c368 <__avr32_f64_to_s32>
8000a7bc:	51 6c       	stdsp	sp[0x58],r12
8000a7be:	e0 a0 0d ec 	rcall	8000c396 <__avr32_s32_to_f64>
8000a7c2:	14 98       	mov	r8,r10
8000a7c4:	16 99       	mov	r9,r11
8000a7c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7ca:	e0 a0 0c 77 	rcall	8000c0b8 <__avr32_f64_sub>
8000a7ce:	fa eb 00 08 	st.d	sp[8],r10
8000a7d2:	41 68       	lddsp	r8,sp[0x58]
8000a7d4:	2d 08       	sub	r8,-48
8000a7d6:	0a c8       	st.b	r5++,r8
8000a7d8:	41 3c       	lddsp	r12,sp[0x4c]
8000a7da:	18 35       	cp.w	r5,r12
8000a7dc:	c2 81       	brne	8000a82c <_dtoa_r+0x61c>
8000a7de:	30 08       	mov	r8,0
8000a7e0:	fc 19 3f e0 	movh	r9,0x3fe0
8000a7e4:	fa ea 00 28 	ld.d	r10,sp[40]
8000a7e8:	e0 a0 0d 36 	rcall	8000c254 <__avr32_f64_add>
8000a7ec:	40 85       	lddsp	r5,sp[0x20]
8000a7ee:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7f2:	08 05       	add	r5,r4
8000a7f4:	e0 a0 0e 88 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a7f8:	e0 81 00 99 	brne	8000a92a <_dtoa_r+0x71a>
8000a7fc:	fa e8 00 28 	ld.d	r8,sp[40]
8000a800:	30 0a       	mov	r10,0
8000a802:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a806:	e0 a0 0c 59 	rcall	8000c0b8 <__avr32_f64_sub>
8000a80a:	14 98       	mov	r8,r10
8000a80c:	16 99       	mov	r9,r11
8000a80e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a812:	e0 a0 0e 79 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a816:	c1 30       	breq	8000a83c <_dtoa_r+0x62c>
8000a818:	33 09       	mov	r9,48
8000a81a:	0a 98       	mov	r8,r5
8000a81c:	11 7a       	ld.ub	r10,--r8
8000a81e:	f2 0a 18 00 	cp.b	r10,r9
8000a822:	e0 81 02 d1 	brne	8000adc4 <_dtoa_r+0xbb4>
8000a826:	10 95       	mov	r5,r8
8000a828:	cf 9b       	rjmp	8000a81a <_dtoa_r+0x60a>
8000a82a:	d7 03       	nop
8000a82c:	30 08       	mov	r8,0
8000a82e:	fc 19 40 24 	movh	r9,0x4024
8000a832:	e0 a0 0b 57 	rcall	8000bee0 <__avr32_f64_mul>
8000a836:	fa eb 00 08 	st.d	sp[8],r10
8000a83a:	cb db       	rjmp	8000a7b4 <_dtoa_r+0x5a4>
8000a83c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a840:	fa eb 00 08 	st.d	sp[8],r10
8000a844:	58 e6       	cp.w	r6,14
8000a846:	5f ab       	srle	r11
8000a848:	41 8a       	lddsp	r10,sp[0x60]
8000a84a:	30 08       	mov	r8,0
8000a84c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a850:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a854:	f0 09 18 00 	cp.b	r9,r8
8000a858:	e0 80 00 82 	breq	8000a95c <_dtoa_r+0x74c>
8000a85c:	40 ea       	lddsp	r10,sp[0x38]
8000a85e:	58 01       	cp.w	r1,0
8000a860:	5f a9       	srle	r9
8000a862:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a866:	fe ca c6 9e 	sub	r10,pc,-14690
8000a86a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a86e:	fa e5 00 10 	st.d	sp[16],r4
8000a872:	f0 09 18 00 	cp.b	r9,r8
8000a876:	c1 40       	breq	8000a89e <_dtoa_r+0x68e>
8000a878:	58 01       	cp.w	r1,0
8000a87a:	e0 81 01 77 	brne	8000ab68 <_dtoa_r+0x958>
8000a87e:	30 08       	mov	r8,0
8000a880:	fc 19 40 14 	movh	r9,0x4014
8000a884:	08 9a       	mov	r10,r4
8000a886:	0a 9b       	mov	r11,r5
8000a888:	e0 a0 0b 2c 	rcall	8000bee0 <__avr32_f64_mul>
8000a88c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a890:	e0 a0 0e 06 	rcall	8000c49c <__avr32_f64_cmp_ge>
8000a894:	e0 81 01 6a 	brne	8000ab68 <_dtoa_r+0x958>
8000a898:	02 92       	mov	r2,r1
8000a89a:	e0 8f 01 72 	bral	8000ab7e <_dtoa_r+0x96e>
8000a89e:	40 85       	lddsp	r5,sp[0x20]
8000a8a0:	30 14       	mov	r4,1
8000a8a2:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8aa:	e0 a0 0e 61 	rcall	8000c56c <__avr32_f64_div>
8000a8ae:	e0 a0 0d 5d 	rcall	8000c368 <__avr32_f64_to_s32>
8000a8b2:	18 92       	mov	r2,r12
8000a8b4:	e0 a0 0d 71 	rcall	8000c396 <__avr32_s32_to_f64>
8000a8b8:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8bc:	e0 a0 0b 12 	rcall	8000bee0 <__avr32_f64_mul>
8000a8c0:	14 98       	mov	r8,r10
8000a8c2:	16 99       	mov	r9,r11
8000a8c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8c8:	e0 a0 0b f8 	rcall	8000c0b8 <__avr32_f64_sub>
8000a8cc:	fa eb 00 08 	st.d	sp[8],r10
8000a8d0:	e4 c8 ff d0 	sub	r8,r2,-48
8000a8d4:	0a c8       	st.b	r5++,r8
8000a8d6:	fc 19 40 24 	movh	r9,0x4024
8000a8da:	30 08       	mov	r8,0
8000a8dc:	02 34       	cp.w	r4,r1
8000a8de:	c3 31       	brne	8000a944 <_dtoa_r+0x734>
8000a8e0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8e4:	e0 a0 0c b8 	rcall	8000c254 <__avr32_f64_add>
8000a8e8:	16 91       	mov	r1,r11
8000a8ea:	14 90       	mov	r0,r10
8000a8ec:	14 98       	mov	r8,r10
8000a8ee:	02 99       	mov	r9,r1
8000a8f0:	fa ea 00 10 	ld.d	r10,sp[16]
8000a8f4:	e0 a0 0e 08 	rcall	8000c504 <__avr32_f64_cmp_lt>
8000a8f8:	c1 a1       	brne	8000a92c <_dtoa_r+0x71c>
8000a8fa:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8fe:	00 9a       	mov	r10,r0
8000a900:	02 9b       	mov	r11,r1
8000a902:	e0 a0 0d ba 	rcall	8000c476 <__avr32_f64_cmp_eq>
8000a906:	e0 80 02 5e 	breq	8000adc2 <_dtoa_r+0xbb2>
8000a90a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a90e:	c0 f1       	brne	8000a92c <_dtoa_r+0x71c>
8000a910:	e0 8f 02 59 	bral	8000adc2 <_dtoa_r+0xbb2>
8000a914:	40 8a       	lddsp	r10,sp[0x20]
8000a916:	14 38       	cp.w	r8,r10
8000a918:	c0 30       	breq	8000a91e <_dtoa_r+0x70e>
8000a91a:	10 95       	mov	r5,r8
8000a91c:	c0 98       	rjmp	8000a92e <_dtoa_r+0x71e>
8000a91e:	33 08       	mov	r8,48
8000a920:	40 89       	lddsp	r9,sp[0x20]
8000a922:	2f f6       	sub	r6,-1
8000a924:	b2 88       	st.b	r9[0x0],r8
8000a926:	40 88       	lddsp	r8,sp[0x20]
8000a928:	c0 88       	rjmp	8000a938 <_dtoa_r+0x728>
8000a92a:	40 66       	lddsp	r6,sp[0x18]
8000a92c:	33 99       	mov	r9,57
8000a92e:	0a 98       	mov	r8,r5
8000a930:	11 7a       	ld.ub	r10,--r8
8000a932:	f2 0a 18 00 	cp.b	r10,r9
8000a936:	ce f0       	breq	8000a914 <_dtoa_r+0x704>
8000a938:	50 66       	stdsp	sp[0x18],r6
8000a93a:	11 89       	ld.ub	r9,r8[0x0]
8000a93c:	2f f9       	sub	r9,-1
8000a93e:	b0 89       	st.b	r8[0x0],r9
8000a940:	e0 8f 02 42 	bral	8000adc4 <_dtoa_r+0xbb4>
8000a944:	e0 a0 0a ce 	rcall	8000bee0 <__avr32_f64_mul>
8000a948:	2f f4       	sub	r4,-1
8000a94a:	fa eb 00 08 	st.d	sp[8],r10
8000a94e:	30 08       	mov	r8,0
8000a950:	30 09       	mov	r9,0
8000a952:	e0 a0 0d 92 	rcall	8000c476 <__avr32_f64_cmp_eq>
8000a956:	ca 60       	breq	8000a8a2 <_dtoa_r+0x692>
8000a958:	e0 8f 02 35 	bral	8000adc2 <_dtoa_r+0xbb2>
8000a95c:	40 d8       	lddsp	r8,sp[0x34]
8000a95e:	58 08       	cp.w	r8,0
8000a960:	c0 51       	brne	8000a96a <_dtoa_r+0x75a>
8000a962:	04 98       	mov	r8,r2
8000a964:	00 95       	mov	r5,r0
8000a966:	40 d4       	lddsp	r4,sp[0x34]
8000a968:	c3 78       	rjmp	8000a9d6 <_dtoa_r+0x7c6>
8000a96a:	40 c5       	lddsp	r5,sp[0x30]
8000a96c:	58 15       	cp.w	r5,1
8000a96e:	e0 89 00 0f 	brgt	8000a98c <_dtoa_r+0x77c>
8000a972:	41 74       	lddsp	r4,sp[0x5c]
8000a974:	58 04       	cp.w	r4,0
8000a976:	c0 40       	breq	8000a97e <_dtoa_r+0x76e>
8000a978:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a97c:	c0 48       	rjmp	8000a984 <_dtoa_r+0x774>
8000a97e:	41 99       	lddsp	r9,sp[0x64]
8000a980:	f2 09 11 36 	rsub	r9,r9,54
8000a984:	04 98       	mov	r8,r2
8000a986:	00 95       	mov	r5,r0
8000a988:	c1 c8       	rjmp	8000a9c0 <_dtoa_r+0x7b0>
8000a98a:	d7 03       	nop
8000a98c:	e2 c8 00 01 	sub	r8,r1,1
8000a990:	58 01       	cp.w	r1,0
8000a992:	e0 05 17 40 	movge	r5,r0
8000a996:	e2 09 17 40 	movge	r9,r1
8000a99a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a99e:	f9 b9 05 00 	movlt	r9,0
8000a9a2:	10 32       	cp.w	r2,r8
8000a9a4:	e5 d8 e4 18 	subge	r8,r2,r8
8000a9a8:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a9ac:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a9b0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a9b4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a9b8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a9bc:	f9 b8 05 00 	movlt	r8,0
8000a9c0:	40 4b       	lddsp	r11,sp[0x10]
8000a9c2:	12 0b       	add	r11,r9
8000a9c4:	50 08       	stdsp	sp[0x0],r8
8000a9c6:	50 4b       	stdsp	sp[0x10],r11
8000a9c8:	12 00       	add	r0,r9
8000a9ca:	30 1b       	mov	r11,1
8000a9cc:	0e 9c       	mov	r12,r7
8000a9ce:	e0 a0 08 a7 	rcall	8000bb1c <__i2b>
8000a9d2:	40 08       	lddsp	r8,sp[0x0]
8000a9d4:	18 94       	mov	r4,r12
8000a9d6:	40 4a       	lddsp	r10,sp[0x10]
8000a9d8:	58 05       	cp.w	r5,0
8000a9da:	5f 99       	srgt	r9
8000a9dc:	58 0a       	cp.w	r10,0
8000a9de:	5f 9a       	srgt	r10
8000a9e0:	f5 e9 00 09 	and	r9,r10,r9
8000a9e4:	c0 80       	breq	8000a9f4 <_dtoa_r+0x7e4>
8000a9e6:	40 4c       	lddsp	r12,sp[0x10]
8000a9e8:	f8 05 0d 49 	min	r9,r12,r5
8000a9ec:	12 1c       	sub	r12,r9
8000a9ee:	12 10       	sub	r0,r9
8000a9f0:	50 4c       	stdsp	sp[0x10],r12
8000a9f2:	12 15       	sub	r5,r9
8000a9f4:	58 02       	cp.w	r2,0
8000a9f6:	e0 8a 00 27 	brle	8000aa44 <_dtoa_r+0x834>
8000a9fa:	40 db       	lddsp	r11,sp[0x34]
8000a9fc:	58 0b       	cp.w	r11,0
8000a9fe:	c1 d0       	breq	8000aa38 <_dtoa_r+0x828>
8000aa00:	58 08       	cp.w	r8,0
8000aa02:	e0 8a 00 17 	brle	8000aa30 <_dtoa_r+0x820>
8000aa06:	10 9a       	mov	r10,r8
8000aa08:	50 08       	stdsp	sp[0x0],r8
8000aa0a:	08 9b       	mov	r11,r4
8000aa0c:	0e 9c       	mov	r12,r7
8000aa0e:	e0 a0 08 cd 	rcall	8000bba8 <__pow5mult>
8000aa12:	06 9a       	mov	r10,r3
8000aa14:	18 9b       	mov	r11,r12
8000aa16:	18 94       	mov	r4,r12
8000aa18:	0e 9c       	mov	r12,r7
8000aa1a:	e0 a0 08 01 	rcall	8000ba1c <__multiply>
8000aa1e:	18 99       	mov	r9,r12
8000aa20:	06 9b       	mov	r11,r3
8000aa22:	50 19       	stdsp	sp[0x4],r9
8000aa24:	0e 9c       	mov	r12,r7
8000aa26:	e0 a0 06 ad 	rcall	8000b780 <_Bfree>
8000aa2a:	40 19       	lddsp	r9,sp[0x4]
8000aa2c:	40 08       	lddsp	r8,sp[0x0]
8000aa2e:	12 93       	mov	r3,r9
8000aa30:	e4 08 01 0a 	sub	r10,r2,r8
8000aa34:	c0 80       	breq	8000aa44 <_dtoa_r+0x834>
8000aa36:	c0 28       	rjmp	8000aa3a <_dtoa_r+0x82a>
8000aa38:	04 9a       	mov	r10,r2
8000aa3a:	06 9b       	mov	r11,r3
8000aa3c:	0e 9c       	mov	r12,r7
8000aa3e:	e0 a0 08 b5 	rcall	8000bba8 <__pow5mult>
8000aa42:	18 93       	mov	r3,r12
8000aa44:	30 1b       	mov	r11,1
8000aa46:	0e 9c       	mov	r12,r7
8000aa48:	e0 a0 08 6a 	rcall	8000bb1c <__i2b>
8000aa4c:	41 1a       	lddsp	r10,sp[0x44]
8000aa4e:	18 92       	mov	r2,r12
8000aa50:	58 0a       	cp.w	r10,0
8000aa52:	e0 8a 00 07 	brle	8000aa60 <_dtoa_r+0x850>
8000aa56:	18 9b       	mov	r11,r12
8000aa58:	0e 9c       	mov	r12,r7
8000aa5a:	e0 a0 08 a7 	rcall	8000bba8 <__pow5mult>
8000aa5e:	18 92       	mov	r2,r12
8000aa60:	40 c9       	lddsp	r9,sp[0x30]
8000aa62:	58 19       	cp.w	r9,1
8000aa64:	e0 89 00 14 	brgt	8000aa8c <_dtoa_r+0x87c>
8000aa68:	40 38       	lddsp	r8,sp[0xc]
8000aa6a:	58 08       	cp.w	r8,0
8000aa6c:	c1 01       	brne	8000aa8c <_dtoa_r+0x87c>
8000aa6e:	40 29       	lddsp	r9,sp[0x8]
8000aa70:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aa74:	c0 c1       	brne	8000aa8c <_dtoa_r+0x87c>
8000aa76:	12 98       	mov	r8,r9
8000aa78:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aa7c:	c0 80       	breq	8000aa8c <_dtoa_r+0x87c>
8000aa7e:	40 4c       	lddsp	r12,sp[0x10]
8000aa80:	30 1b       	mov	r11,1
8000aa82:	2f fc       	sub	r12,-1
8000aa84:	2f f0       	sub	r0,-1
8000aa86:	50 4c       	stdsp	sp[0x10],r12
8000aa88:	50 6b       	stdsp	sp[0x18],r11
8000aa8a:	c0 38       	rjmp	8000aa90 <_dtoa_r+0x880>
8000aa8c:	30 0a       	mov	r10,0
8000aa8e:	50 6a       	stdsp	sp[0x18],r10
8000aa90:	41 19       	lddsp	r9,sp[0x44]
8000aa92:	58 09       	cp.w	r9,0
8000aa94:	c0 31       	brne	8000aa9a <_dtoa_r+0x88a>
8000aa96:	30 1c       	mov	r12,1
8000aa98:	c0 98       	rjmp	8000aaaa <_dtoa_r+0x89a>
8000aa9a:	64 48       	ld.w	r8,r2[0x10]
8000aa9c:	2f c8       	sub	r8,-4
8000aa9e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aaa2:	e0 a0 05 df 	rcall	8000b660 <__hi0bits>
8000aaa6:	f8 0c 11 20 	rsub	r12,r12,32
8000aaaa:	40 4b       	lddsp	r11,sp[0x10]
8000aaac:	f8 0b 00 08 	add	r8,r12,r11
8000aab0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aab4:	c0 c0       	breq	8000aacc <_dtoa_r+0x8bc>
8000aab6:	f0 08 11 20 	rsub	r8,r8,32
8000aaba:	58 48       	cp.w	r8,4
8000aabc:	e0 8a 00 06 	brle	8000aac8 <_dtoa_r+0x8b8>
8000aac0:	20 48       	sub	r8,4
8000aac2:	10 0b       	add	r11,r8
8000aac4:	50 4b       	stdsp	sp[0x10],r11
8000aac6:	c0 78       	rjmp	8000aad4 <_dtoa_r+0x8c4>
8000aac8:	58 48       	cp.w	r8,4
8000aaca:	c0 70       	breq	8000aad8 <_dtoa_r+0x8c8>
8000aacc:	40 4a       	lddsp	r10,sp[0x10]
8000aace:	2e 48       	sub	r8,-28
8000aad0:	10 0a       	add	r10,r8
8000aad2:	50 4a       	stdsp	sp[0x10],r10
8000aad4:	10 00       	add	r0,r8
8000aad6:	10 05       	add	r5,r8
8000aad8:	58 00       	cp.w	r0,0
8000aada:	e0 8a 00 08 	brle	8000aaea <_dtoa_r+0x8da>
8000aade:	06 9b       	mov	r11,r3
8000aae0:	00 9a       	mov	r10,r0
8000aae2:	0e 9c       	mov	r12,r7
8000aae4:	e0 a0 07 58 	rcall	8000b994 <__lshift>
8000aae8:	18 93       	mov	r3,r12
8000aaea:	40 49       	lddsp	r9,sp[0x10]
8000aaec:	58 09       	cp.w	r9,0
8000aaee:	e0 8a 00 08 	brle	8000aafe <_dtoa_r+0x8ee>
8000aaf2:	04 9b       	mov	r11,r2
8000aaf4:	12 9a       	mov	r10,r9
8000aaf6:	0e 9c       	mov	r12,r7
8000aaf8:	e0 a0 07 4e 	rcall	8000b994 <__lshift>
8000aafc:	18 92       	mov	r2,r12
8000aafe:	41 48       	lddsp	r8,sp[0x50]
8000ab00:	58 08       	cp.w	r8,0
8000ab02:	c1 b0       	breq	8000ab38 <_dtoa_r+0x928>
8000ab04:	04 9b       	mov	r11,r2
8000ab06:	06 9c       	mov	r12,r3
8000ab08:	e0 a0 06 23 	rcall	8000b74e <__mcmp>
8000ab0c:	c1 64       	brge	8000ab38 <_dtoa_r+0x928>
8000ab0e:	06 9b       	mov	r11,r3
8000ab10:	30 09       	mov	r9,0
8000ab12:	30 aa       	mov	r10,10
8000ab14:	0e 9c       	mov	r12,r7
8000ab16:	e0 a0 08 0b 	rcall	8000bb2c <__multadd>
8000ab1a:	20 16       	sub	r6,1
8000ab1c:	18 93       	mov	r3,r12
8000ab1e:	40 dc       	lddsp	r12,sp[0x34]
8000ab20:	58 0c       	cp.w	r12,0
8000ab22:	c0 31       	brne	8000ab28 <_dtoa_r+0x918>
8000ab24:	40 91       	lddsp	r1,sp[0x24]
8000ab26:	c0 98       	rjmp	8000ab38 <_dtoa_r+0x928>
8000ab28:	08 9b       	mov	r11,r4
8000ab2a:	40 91       	lddsp	r1,sp[0x24]
8000ab2c:	30 09       	mov	r9,0
8000ab2e:	30 aa       	mov	r10,10
8000ab30:	0e 9c       	mov	r12,r7
8000ab32:	e0 a0 07 fd 	rcall	8000bb2c <__multadd>
8000ab36:	18 94       	mov	r4,r12
8000ab38:	58 01       	cp.w	r1,0
8000ab3a:	5f a9       	srle	r9
8000ab3c:	40 cb       	lddsp	r11,sp[0x30]
8000ab3e:	58 2b       	cp.w	r11,2
8000ab40:	5f 98       	srgt	r8
8000ab42:	f3 e8 00 08 	and	r8,r9,r8
8000ab46:	c2 50       	breq	8000ab90 <_dtoa_r+0x980>
8000ab48:	58 01       	cp.w	r1,0
8000ab4a:	c1 11       	brne	8000ab6c <_dtoa_r+0x95c>
8000ab4c:	04 9b       	mov	r11,r2
8000ab4e:	02 99       	mov	r9,r1
8000ab50:	30 5a       	mov	r10,5
8000ab52:	0e 9c       	mov	r12,r7
8000ab54:	e0 a0 07 ec 	rcall	8000bb2c <__multadd>
8000ab58:	18 92       	mov	r2,r12
8000ab5a:	18 9b       	mov	r11,r12
8000ab5c:	06 9c       	mov	r12,r3
8000ab5e:	e0 a0 05 f8 	rcall	8000b74e <__mcmp>
8000ab62:	e0 89 00 0f 	brgt	8000ab80 <_dtoa_r+0x970>
8000ab66:	c0 38       	rjmp	8000ab6c <_dtoa_r+0x95c>
8000ab68:	30 02       	mov	r2,0
8000ab6a:	04 94       	mov	r4,r2
8000ab6c:	40 ea       	lddsp	r10,sp[0x38]
8000ab6e:	30 09       	mov	r9,0
8000ab70:	5c da       	com	r10
8000ab72:	40 85       	lddsp	r5,sp[0x20]
8000ab74:	50 6a       	stdsp	sp[0x18],r10
8000ab76:	50 49       	stdsp	sp[0x10],r9
8000ab78:	c0 f9       	rjmp	8000ad96 <_dtoa_r+0xb86>
8000ab7a:	08 92       	mov	r2,r4
8000ab7c:	40 66       	lddsp	r6,sp[0x18]
8000ab7e:	04 94       	mov	r4,r2
8000ab80:	2f f6       	sub	r6,-1
8000ab82:	50 66       	stdsp	sp[0x18],r6
8000ab84:	33 18       	mov	r8,49
8000ab86:	40 85       	lddsp	r5,sp[0x20]
8000ab88:	0a c8       	st.b	r5++,r8
8000ab8a:	30 08       	mov	r8,0
8000ab8c:	50 48       	stdsp	sp[0x10],r8
8000ab8e:	c0 49       	rjmp	8000ad96 <_dtoa_r+0xb86>
8000ab90:	40 dc       	lddsp	r12,sp[0x34]
8000ab92:	58 0c       	cp.w	r12,0
8000ab94:	e0 80 00 b5 	breq	8000acfe <_dtoa_r+0xaee>
8000ab98:	58 05       	cp.w	r5,0
8000ab9a:	e0 8a 00 08 	brle	8000abaa <_dtoa_r+0x99a>
8000ab9e:	08 9b       	mov	r11,r4
8000aba0:	0a 9a       	mov	r10,r5
8000aba2:	0e 9c       	mov	r12,r7
8000aba4:	e0 a0 06 f8 	rcall	8000b994 <__lshift>
8000aba8:	18 94       	mov	r4,r12
8000abaa:	40 6b       	lddsp	r11,sp[0x18]
8000abac:	58 0b       	cp.w	r11,0
8000abae:	c0 31       	brne	8000abb4 <_dtoa_r+0x9a4>
8000abb0:	08 9c       	mov	r12,r4
8000abb2:	c1 38       	rjmp	8000abd8 <_dtoa_r+0x9c8>
8000abb4:	68 1b       	ld.w	r11,r4[0x4]
8000abb6:	0e 9c       	mov	r12,r7
8000abb8:	e0 a0 05 fe 	rcall	8000b7b4 <_Balloc>
8000abbc:	68 4a       	ld.w	r10,r4[0x10]
8000abbe:	18 95       	mov	r5,r12
8000abc0:	e8 cb ff f4 	sub	r11,r4,-12
8000abc4:	2f ea       	sub	r10,-2
8000abc6:	2f 4c       	sub	r12,-12
8000abc8:	a3 6a       	lsl	r10,0x2
8000abca:	fe b0 e6 4f 	rcall	80007868 <memcpy>
8000abce:	0a 9b       	mov	r11,r5
8000abd0:	30 1a       	mov	r10,1
8000abd2:	0e 9c       	mov	r12,r7
8000abd4:	e0 a0 06 e0 	rcall	8000b994 <__lshift>
8000abd8:	50 44       	stdsp	sp[0x10],r4
8000abda:	40 3a       	lddsp	r10,sp[0xc]
8000abdc:	30 19       	mov	r9,1
8000abde:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000abe2:	18 94       	mov	r4,r12
8000abe4:	50 da       	stdsp	sp[0x34],r10
8000abe6:	40 85       	lddsp	r5,sp[0x20]
8000abe8:	50 99       	stdsp	sp[0x24],r9
8000abea:	50 26       	stdsp	sp[0x8],r6
8000abec:	50 e1       	stdsp	sp[0x38],r1
8000abee:	04 9b       	mov	r11,r2
8000abf0:	06 9c       	mov	r12,r3
8000abf2:	fe b0 fa 7f 	rcall	8000a0f0 <quorem>
8000abf6:	40 4b       	lddsp	r11,sp[0x10]
8000abf8:	f8 c0 ff d0 	sub	r0,r12,-48
8000abfc:	06 9c       	mov	r12,r3
8000abfe:	e0 a0 05 a8 	rcall	8000b74e <__mcmp>
8000ac02:	08 9a       	mov	r10,r4
8000ac04:	50 6c       	stdsp	sp[0x18],r12
8000ac06:	04 9b       	mov	r11,r2
8000ac08:	0e 9c       	mov	r12,r7
8000ac0a:	e0 a0 06 5d 	rcall	8000b8c4 <__mdiff>
8000ac0e:	18 91       	mov	r1,r12
8000ac10:	78 38       	ld.w	r8,r12[0xc]
8000ac12:	58 08       	cp.w	r8,0
8000ac14:	c0 30       	breq	8000ac1a <_dtoa_r+0xa0a>
8000ac16:	30 16       	mov	r6,1
8000ac18:	c0 68       	rjmp	8000ac24 <_dtoa_r+0xa14>
8000ac1a:	18 9b       	mov	r11,r12
8000ac1c:	06 9c       	mov	r12,r3
8000ac1e:	e0 a0 05 98 	rcall	8000b74e <__mcmp>
8000ac22:	18 96       	mov	r6,r12
8000ac24:	0e 9c       	mov	r12,r7
8000ac26:	02 9b       	mov	r11,r1
8000ac28:	e0 a0 05 ac 	rcall	8000b780 <_Bfree>
8000ac2c:	40 cc       	lddsp	r12,sp[0x30]
8000ac2e:	ed ec 10 08 	or	r8,r6,r12
8000ac32:	c0 d1       	brne	8000ac4c <_dtoa_r+0xa3c>
8000ac34:	40 db       	lddsp	r11,sp[0x34]
8000ac36:	58 0b       	cp.w	r11,0
8000ac38:	c0 a1       	brne	8000ac4c <_dtoa_r+0xa3c>
8000ac3a:	40 26       	lddsp	r6,sp[0x8]
8000ac3c:	e0 40 00 39 	cp.w	r0,57
8000ac40:	c3 00       	breq	8000aca0 <_dtoa_r+0xa90>
8000ac42:	40 6a       	lddsp	r10,sp[0x18]
8000ac44:	58 0a       	cp.w	r10,0
8000ac46:	e0 89 00 24 	brgt	8000ac8e <_dtoa_r+0xa7e>
8000ac4a:	c2 f8       	rjmp	8000aca8 <_dtoa_r+0xa98>
8000ac4c:	40 69       	lddsp	r9,sp[0x18]
8000ac4e:	58 09       	cp.w	r9,0
8000ac50:	c0 85       	brlt	8000ac60 <_dtoa_r+0xa50>
8000ac52:	12 98       	mov	r8,r9
8000ac54:	40 cc       	lddsp	r12,sp[0x30]
8000ac56:	18 48       	or	r8,r12
8000ac58:	c1 d1       	brne	8000ac92 <_dtoa_r+0xa82>
8000ac5a:	40 db       	lddsp	r11,sp[0x34]
8000ac5c:	58 0b       	cp.w	r11,0
8000ac5e:	c1 a1       	brne	8000ac92 <_dtoa_r+0xa82>
8000ac60:	0c 99       	mov	r9,r6
8000ac62:	40 26       	lddsp	r6,sp[0x8]
8000ac64:	58 09       	cp.w	r9,0
8000ac66:	e0 8a 00 21 	brle	8000aca8 <_dtoa_r+0xa98>
8000ac6a:	06 9b       	mov	r11,r3
8000ac6c:	30 1a       	mov	r10,1
8000ac6e:	0e 9c       	mov	r12,r7
8000ac70:	e0 a0 06 92 	rcall	8000b994 <__lshift>
8000ac74:	04 9b       	mov	r11,r2
8000ac76:	18 93       	mov	r3,r12
8000ac78:	e0 a0 05 6b 	rcall	8000b74e <__mcmp>
8000ac7c:	e0 89 00 06 	brgt	8000ac88 <_dtoa_r+0xa78>
8000ac80:	c1 41       	brne	8000aca8 <_dtoa_r+0xa98>
8000ac82:	ed b0 00 00 	bld	r0,0x0
8000ac86:	c1 11       	brne	8000aca8 <_dtoa_r+0xa98>
8000ac88:	e0 40 00 39 	cp.w	r0,57
8000ac8c:	c0 a0       	breq	8000aca0 <_dtoa_r+0xa90>
8000ac8e:	2f f0       	sub	r0,-1
8000ac90:	c0 c8       	rjmp	8000aca8 <_dtoa_r+0xa98>
8000ac92:	58 06       	cp.w	r6,0
8000ac94:	e0 8a 00 0c 	brle	8000acac <_dtoa_r+0xa9c>
8000ac98:	40 26       	lddsp	r6,sp[0x8]
8000ac9a:	e0 40 00 39 	cp.w	r0,57
8000ac9e:	c0 41       	brne	8000aca6 <_dtoa_r+0xa96>
8000aca0:	33 98       	mov	r8,57
8000aca2:	0a c8       	st.b	r5++,r8
8000aca4:	c6 78       	rjmp	8000ad72 <_dtoa_r+0xb62>
8000aca6:	2f f0       	sub	r0,-1
8000aca8:	0a c0       	st.b	r5++,r0
8000acaa:	c7 58       	rjmp	8000ad94 <_dtoa_r+0xb84>
8000acac:	0a c0       	st.b	r5++,r0
8000acae:	40 9a       	lddsp	r10,sp[0x24]
8000acb0:	40 e9       	lddsp	r9,sp[0x38]
8000acb2:	12 3a       	cp.w	r10,r9
8000acb4:	c4 30       	breq	8000ad3a <_dtoa_r+0xb2a>
8000acb6:	06 9b       	mov	r11,r3
8000acb8:	30 09       	mov	r9,0
8000acba:	30 aa       	mov	r10,10
8000acbc:	0e 9c       	mov	r12,r7
8000acbe:	e0 a0 07 37 	rcall	8000bb2c <__multadd>
8000acc2:	40 48       	lddsp	r8,sp[0x10]
8000acc4:	18 93       	mov	r3,r12
8000acc6:	08 38       	cp.w	r8,r4
8000acc8:	c0 91       	brne	8000acda <_dtoa_r+0xaca>
8000acca:	10 9b       	mov	r11,r8
8000accc:	30 09       	mov	r9,0
8000acce:	30 aa       	mov	r10,10
8000acd0:	0e 9c       	mov	r12,r7
8000acd2:	e0 a0 07 2d 	rcall	8000bb2c <__multadd>
8000acd6:	50 4c       	stdsp	sp[0x10],r12
8000acd8:	c0 e8       	rjmp	8000acf4 <_dtoa_r+0xae4>
8000acda:	40 4b       	lddsp	r11,sp[0x10]
8000acdc:	30 09       	mov	r9,0
8000acde:	30 aa       	mov	r10,10
8000ace0:	0e 9c       	mov	r12,r7
8000ace2:	e0 a0 07 25 	rcall	8000bb2c <__multadd>
8000ace6:	08 9b       	mov	r11,r4
8000ace8:	50 4c       	stdsp	sp[0x10],r12
8000acea:	30 09       	mov	r9,0
8000acec:	30 aa       	mov	r10,10
8000acee:	0e 9c       	mov	r12,r7
8000acf0:	e0 a0 07 1e 	rcall	8000bb2c <__multadd>
8000acf4:	18 94       	mov	r4,r12
8000acf6:	40 9c       	lddsp	r12,sp[0x24]
8000acf8:	2f fc       	sub	r12,-1
8000acfa:	50 9c       	stdsp	sp[0x24],r12
8000acfc:	c7 9b       	rjmp	8000abee <_dtoa_r+0x9de>
8000acfe:	30 18       	mov	r8,1
8000ad00:	06 90       	mov	r0,r3
8000ad02:	40 85       	lddsp	r5,sp[0x20]
8000ad04:	08 93       	mov	r3,r4
8000ad06:	0c 94       	mov	r4,r6
8000ad08:	10 96       	mov	r6,r8
8000ad0a:	04 9b       	mov	r11,r2
8000ad0c:	00 9c       	mov	r12,r0
8000ad0e:	fe b0 f9 f1 	rcall	8000a0f0 <quorem>
8000ad12:	2d 0c       	sub	r12,-48
8000ad14:	0a cc       	st.b	r5++,r12
8000ad16:	02 36       	cp.w	r6,r1
8000ad18:	c0 a4       	brge	8000ad2c <_dtoa_r+0xb1c>
8000ad1a:	00 9b       	mov	r11,r0
8000ad1c:	30 09       	mov	r9,0
8000ad1e:	30 aa       	mov	r10,10
8000ad20:	0e 9c       	mov	r12,r7
8000ad22:	2f f6       	sub	r6,-1
8000ad24:	e0 a0 07 04 	rcall	8000bb2c <__multadd>
8000ad28:	18 90       	mov	r0,r12
8000ad2a:	cf 0b       	rjmp	8000ad0a <_dtoa_r+0xafa>
8000ad2c:	08 96       	mov	r6,r4
8000ad2e:	30 0b       	mov	r11,0
8000ad30:	06 94       	mov	r4,r3
8000ad32:	50 4b       	stdsp	sp[0x10],r11
8000ad34:	00 93       	mov	r3,r0
8000ad36:	18 90       	mov	r0,r12
8000ad38:	c0 28       	rjmp	8000ad3c <_dtoa_r+0xb2c>
8000ad3a:	40 26       	lddsp	r6,sp[0x8]
8000ad3c:	06 9b       	mov	r11,r3
8000ad3e:	30 1a       	mov	r10,1
8000ad40:	0e 9c       	mov	r12,r7
8000ad42:	e0 a0 06 29 	rcall	8000b994 <__lshift>
8000ad46:	04 9b       	mov	r11,r2
8000ad48:	18 93       	mov	r3,r12
8000ad4a:	e0 a0 05 02 	rcall	8000b74e <__mcmp>
8000ad4e:	e0 89 00 12 	brgt	8000ad72 <_dtoa_r+0xb62>
8000ad52:	c1 b1       	brne	8000ad88 <_dtoa_r+0xb78>
8000ad54:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ad58:	c0 d1       	brne	8000ad72 <_dtoa_r+0xb62>
8000ad5a:	c1 78       	rjmp	8000ad88 <_dtoa_r+0xb78>
8000ad5c:	40 89       	lddsp	r9,sp[0x20]
8000ad5e:	12 38       	cp.w	r8,r9
8000ad60:	c0 30       	breq	8000ad66 <_dtoa_r+0xb56>
8000ad62:	10 95       	mov	r5,r8
8000ad64:	c0 88       	rjmp	8000ad74 <_dtoa_r+0xb64>
8000ad66:	2f f6       	sub	r6,-1
8000ad68:	50 66       	stdsp	sp[0x18],r6
8000ad6a:	33 18       	mov	r8,49
8000ad6c:	40 8c       	lddsp	r12,sp[0x20]
8000ad6e:	b8 88       	st.b	r12[0x0],r8
8000ad70:	c1 38       	rjmp	8000ad96 <_dtoa_r+0xb86>
8000ad72:	33 9a       	mov	r10,57
8000ad74:	0a 98       	mov	r8,r5
8000ad76:	11 79       	ld.ub	r9,--r8
8000ad78:	f4 09 18 00 	cp.b	r9,r10
8000ad7c:	cf 00       	breq	8000ad5c <_dtoa_r+0xb4c>
8000ad7e:	2f f9       	sub	r9,-1
8000ad80:	b0 89       	st.b	r8[0x0],r9
8000ad82:	c0 98       	rjmp	8000ad94 <_dtoa_r+0xb84>
8000ad84:	10 95       	mov	r5,r8
8000ad86:	c0 28       	rjmp	8000ad8a <_dtoa_r+0xb7a>
8000ad88:	33 09       	mov	r9,48
8000ad8a:	0a 98       	mov	r8,r5
8000ad8c:	11 7a       	ld.ub	r10,--r8
8000ad8e:	f2 0a 18 00 	cp.b	r10,r9
8000ad92:	cf 90       	breq	8000ad84 <_dtoa_r+0xb74>
8000ad94:	50 66       	stdsp	sp[0x18],r6
8000ad96:	04 9b       	mov	r11,r2
8000ad98:	0e 9c       	mov	r12,r7
8000ad9a:	e0 a0 04 f3 	rcall	8000b780 <_Bfree>
8000ad9e:	58 04       	cp.w	r4,0
8000ada0:	c1 20       	breq	8000adc4 <_dtoa_r+0xbb4>
8000ada2:	40 4b       	lddsp	r11,sp[0x10]
8000ada4:	08 3b       	cp.w	r11,r4
8000ada6:	5f 19       	srne	r9
8000ada8:	58 0b       	cp.w	r11,0
8000adaa:	5f 18       	srne	r8
8000adac:	f3 e8 00 08 	and	r8,r9,r8
8000adb0:	c0 40       	breq	8000adb8 <_dtoa_r+0xba8>
8000adb2:	0e 9c       	mov	r12,r7
8000adb4:	e0 a0 04 e6 	rcall	8000b780 <_Bfree>
8000adb8:	08 9b       	mov	r11,r4
8000adba:	0e 9c       	mov	r12,r7
8000adbc:	e0 a0 04 e2 	rcall	8000b780 <_Bfree>
8000adc0:	c0 28       	rjmp	8000adc4 <_dtoa_r+0xbb4>
8000adc2:	50 66       	stdsp	sp[0x18],r6
8000adc4:	0e 9c       	mov	r12,r7
8000adc6:	06 9b       	mov	r11,r3
8000adc8:	e0 a0 04 dc 	rcall	8000b780 <_Bfree>
8000adcc:	30 08       	mov	r8,0
8000adce:	aa 88       	st.b	r5[0x0],r8
8000add0:	40 68       	lddsp	r8,sp[0x18]
8000add2:	41 5a       	lddsp	r10,sp[0x54]
8000add4:	2f f8       	sub	r8,-1
8000add6:	41 29       	lddsp	r9,sp[0x48]
8000add8:	95 08       	st.w	r10[0x0],r8
8000adda:	40 8c       	lddsp	r12,sp[0x20]
8000addc:	58 09       	cp.w	r9,0
8000adde:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ade2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ade6:	2e 6d       	sub	sp,-104
8000ade8:	d8 32       	popm	r0-r7,pc
8000adea:	d7 03       	nop

8000adec <__errno>:
8000adec:	e0 68 0a 40 	mov	r8,2624
8000adf0:	70 0c       	ld.w	r12,r8[0x0]
8000adf2:	2f 4c       	sub	r12,-12
8000adf4:	5e fc       	retal	r12
8000adf6:	d7 03       	nop

8000adf8 <_fflush_r>:
8000adf8:	d4 21       	pushm	r4-r7,lr
8000adfa:	16 97       	mov	r7,r11
8000adfc:	18 96       	mov	r6,r12
8000adfe:	76 48       	ld.w	r8,r11[0x10]
8000ae00:	58 08       	cp.w	r8,0
8000ae02:	c7 f0       	breq	8000af00 <_fflush_r+0x108>
8000ae04:	58 0c       	cp.w	r12,0
8000ae06:	c0 50       	breq	8000ae10 <_fflush_r+0x18>
8000ae08:	78 68       	ld.w	r8,r12[0x18]
8000ae0a:	58 08       	cp.w	r8,0
8000ae0c:	c0 21       	brne	8000ae10 <_fflush_r+0x18>
8000ae0e:	cc dc       	rcall	8000afa8 <__sinit>
8000ae10:	fe c8 cc f8 	sub	r8,pc,-13064
8000ae14:	10 37       	cp.w	r7,r8
8000ae16:	c0 31       	brne	8000ae1c <_fflush_r+0x24>
8000ae18:	6c 07       	ld.w	r7,r6[0x0]
8000ae1a:	c0 c8       	rjmp	8000ae32 <_fflush_r+0x3a>
8000ae1c:	fe c8 cc e4 	sub	r8,pc,-13084
8000ae20:	10 37       	cp.w	r7,r8
8000ae22:	c0 31       	brne	8000ae28 <_fflush_r+0x30>
8000ae24:	6c 17       	ld.w	r7,r6[0x4]
8000ae26:	c0 68       	rjmp	8000ae32 <_fflush_r+0x3a>
8000ae28:	fe c8 cc d0 	sub	r8,pc,-13104
8000ae2c:	10 37       	cp.w	r7,r8
8000ae2e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae32:	8e 6a       	ld.sh	r10,r7[0xc]
8000ae34:	14 98       	mov	r8,r10
8000ae36:	ed ba 00 03 	bld	r10,0x3
8000ae3a:	c4 20       	breq	8000aebe <_fflush_r+0xc6>
8000ae3c:	ab ba       	sbr	r10,0xb
8000ae3e:	ae 6a       	st.h	r7[0xc],r10
8000ae40:	6e 18       	ld.w	r8,r7[0x4]
8000ae42:	58 08       	cp.w	r8,0
8000ae44:	e0 89 00 06 	brgt	8000ae50 <_fflush_r+0x58>
8000ae48:	6f 08       	ld.w	r8,r7[0x40]
8000ae4a:	58 08       	cp.w	r8,0
8000ae4c:	e0 8a 00 5a 	brle	8000af00 <_fflush_r+0x108>
8000ae50:	6e b8       	ld.w	r8,r7[0x2c]
8000ae52:	58 08       	cp.w	r8,0
8000ae54:	c5 60       	breq	8000af00 <_fflush_r+0x108>
8000ae56:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ae5a:	c0 30       	breq	8000ae60 <_fflush_r+0x68>
8000ae5c:	6f 55       	ld.w	r5,r7[0x54]
8000ae5e:	c0 f8       	rjmp	8000ae7c <_fflush_r+0x84>
8000ae60:	30 19       	mov	r9,1
8000ae62:	6e 8b       	ld.w	r11,r7[0x20]
8000ae64:	0c 9c       	mov	r12,r6
8000ae66:	5d 18       	icall	r8
8000ae68:	18 95       	mov	r5,r12
8000ae6a:	5b fc       	cp.w	r12,-1
8000ae6c:	c0 81       	brne	8000ae7c <_fflush_r+0x84>
8000ae6e:	6c 38       	ld.w	r8,r6[0xc]
8000ae70:	59 d8       	cp.w	r8,29
8000ae72:	c4 70       	breq	8000af00 <_fflush_r+0x108>
8000ae74:	8e 68       	ld.sh	r8,r7[0xc]
8000ae76:	a7 a8       	sbr	r8,0x6
8000ae78:	ae 68       	st.h	r7[0xc],r8
8000ae7a:	d8 22       	popm	r4-r7,pc
8000ae7c:	8e 68       	ld.sh	r8,r7[0xc]
8000ae7e:	ed b8 00 02 	bld	r8,0x2
8000ae82:	c0 91       	brne	8000ae94 <_fflush_r+0x9c>
8000ae84:	6e 18       	ld.w	r8,r7[0x4]
8000ae86:	10 15       	sub	r5,r8
8000ae88:	6e d8       	ld.w	r8,r7[0x34]
8000ae8a:	58 08       	cp.w	r8,0
8000ae8c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ae90:	eb d8 e1 15 	subne	r5,r5,r8
8000ae94:	6e b8       	ld.w	r8,r7[0x2c]
8000ae96:	0c 9c       	mov	r12,r6
8000ae98:	30 09       	mov	r9,0
8000ae9a:	0a 9a       	mov	r10,r5
8000ae9c:	6e 8b       	ld.w	r11,r7[0x20]
8000ae9e:	5d 18       	icall	r8
8000aea0:	8e 68       	ld.sh	r8,r7[0xc]
8000aea2:	0a 3c       	cp.w	r12,r5
8000aea4:	c2 61       	brne	8000aef0 <_fflush_r+0xf8>
8000aea6:	ab d8       	cbr	r8,0xb
8000aea8:	30 0c       	mov	r12,0
8000aeaa:	6e 49       	ld.w	r9,r7[0x10]
8000aeac:	ae 68       	st.h	r7[0xc],r8
8000aeae:	8f 1c       	st.w	r7[0x4],r12
8000aeb0:	8f 09       	st.w	r7[0x0],r9
8000aeb2:	ed b8 00 0c 	bld	r8,0xc
8000aeb6:	c2 51       	brne	8000af00 <_fflush_r+0x108>
8000aeb8:	ef 45 00 54 	st.w	r7[84],r5
8000aebc:	d8 22       	popm	r4-r7,pc
8000aebe:	6e 45       	ld.w	r5,r7[0x10]
8000aec0:	58 05       	cp.w	r5,0
8000aec2:	c1 f0       	breq	8000af00 <_fflush_r+0x108>
8000aec4:	6e 04       	ld.w	r4,r7[0x0]
8000aec6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000aeca:	8f 05       	st.w	r7[0x0],r5
8000aecc:	f9 b8 01 00 	movne	r8,0
8000aed0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aed4:	0a 14       	sub	r4,r5
8000aed6:	8f 28       	st.w	r7[0x8],r8
8000aed8:	c1 18       	rjmp	8000aefa <_fflush_r+0x102>
8000aeda:	08 99       	mov	r9,r4
8000aedc:	0a 9a       	mov	r10,r5
8000aede:	6e a8       	ld.w	r8,r7[0x28]
8000aee0:	6e 8b       	ld.w	r11,r7[0x20]
8000aee2:	0c 9c       	mov	r12,r6
8000aee4:	5d 18       	icall	r8
8000aee6:	18 14       	sub	r4,r12
8000aee8:	58 0c       	cp.w	r12,0
8000aeea:	e0 89 00 07 	brgt	8000aef8 <_fflush_r+0x100>
8000aeee:	8e 68       	ld.sh	r8,r7[0xc]
8000aef0:	a7 a8       	sbr	r8,0x6
8000aef2:	3f fc       	mov	r12,-1
8000aef4:	ae 68       	st.h	r7[0xc],r8
8000aef6:	d8 22       	popm	r4-r7,pc
8000aef8:	18 05       	add	r5,r12
8000aefa:	58 04       	cp.w	r4,0
8000aefc:	fe 99 ff ef 	brgt	8000aeda <_fflush_r+0xe2>
8000af00:	d8 2a       	popm	r4-r7,pc,r12=0
8000af02:	d7 03       	nop

8000af04 <__sfp_lock_acquire>:
8000af04:	5e fc       	retal	r12

8000af06 <__sfp_lock_release>:
8000af06:	5e fc       	retal	r12

8000af08 <_cleanup_r>:
8000af08:	d4 01       	pushm	lr
8000af0a:	fe cb f0 ae 	sub	r11,pc,-3922
8000af0e:	e0 a0 02 f7 	rcall	8000b4fc <_fwalk>
8000af12:	d8 02       	popm	pc

8000af14 <__sfmoreglue>:
8000af14:	d4 21       	pushm	r4-r7,lr
8000af16:	16 95       	mov	r5,r11
8000af18:	f6 06 10 5c 	mul	r6,r11,92
8000af1c:	ec cb ff f4 	sub	r11,r6,-12
8000af20:	fe b0 e2 88 	rcall	80007430 <_malloc_r>
8000af24:	18 97       	mov	r7,r12
8000af26:	c0 90       	breq	8000af38 <__sfmoreglue+0x24>
8000af28:	99 15       	st.w	r12[0x4],r5
8000af2a:	30 0b       	mov	r11,0
8000af2c:	2f 4c       	sub	r12,-12
8000af2e:	0c 9a       	mov	r10,r6
8000af30:	8f 2c       	st.w	r7[0x8],r12
8000af32:	8f 0b       	st.w	r7[0x0],r11
8000af34:	fe b0 e5 3e 	rcall	800079b0 <memset>
8000af38:	0e 9c       	mov	r12,r7
8000af3a:	d8 22       	popm	r4-r7,pc

8000af3c <__sfp>:
8000af3c:	d4 21       	pushm	r4-r7,lr
8000af3e:	fe c8 cd c2 	sub	r8,pc,-12862
8000af42:	18 96       	mov	r6,r12
8000af44:	70 07       	ld.w	r7,r8[0x0]
8000af46:	6e 68       	ld.w	r8,r7[0x18]
8000af48:	58 08       	cp.w	r8,0
8000af4a:	c0 31       	brne	8000af50 <__sfp+0x14>
8000af4c:	0e 9c       	mov	r12,r7
8000af4e:	c2 dc       	rcall	8000afa8 <__sinit>
8000af50:	ee c7 ff 28 	sub	r7,r7,-216
8000af54:	30 05       	mov	r5,0
8000af56:	6e 2c       	ld.w	r12,r7[0x8]
8000af58:	6e 18       	ld.w	r8,r7[0x4]
8000af5a:	c0 68       	rjmp	8000af66 <__sfp+0x2a>
8000af5c:	98 69       	ld.sh	r9,r12[0xc]
8000af5e:	ea 09 19 00 	cp.h	r9,r5
8000af62:	c1 10       	breq	8000af84 <__sfp+0x48>
8000af64:	2a 4c       	sub	r12,-92
8000af66:	20 18       	sub	r8,1
8000af68:	cf a7       	brpl	8000af5c <__sfp+0x20>
8000af6a:	6e 08       	ld.w	r8,r7[0x0]
8000af6c:	58 08       	cp.w	r8,0
8000af6e:	c0 61       	brne	8000af7a <__sfp+0x3e>
8000af70:	30 4b       	mov	r11,4
8000af72:	0c 9c       	mov	r12,r6
8000af74:	cd 0f       	rcall	8000af14 <__sfmoreglue>
8000af76:	8f 0c       	st.w	r7[0x0],r12
8000af78:	c0 30       	breq	8000af7e <__sfp+0x42>
8000af7a:	6e 07       	ld.w	r7,r7[0x0]
8000af7c:	ce db       	rjmp	8000af56 <__sfp+0x1a>
8000af7e:	30 c8       	mov	r8,12
8000af80:	8d 38       	st.w	r6[0xc],r8
8000af82:	d8 22       	popm	r4-r7,pc
8000af84:	30 08       	mov	r8,0
8000af86:	f9 48 00 4c 	st.w	r12[76],r8
8000af8a:	99 08       	st.w	r12[0x0],r8
8000af8c:	99 28       	st.w	r12[0x8],r8
8000af8e:	99 18       	st.w	r12[0x4],r8
8000af90:	99 48       	st.w	r12[0x10],r8
8000af92:	99 58       	st.w	r12[0x14],r8
8000af94:	99 68       	st.w	r12[0x18],r8
8000af96:	99 d8       	st.w	r12[0x34],r8
8000af98:	99 e8       	st.w	r12[0x38],r8
8000af9a:	f9 48 00 48 	st.w	r12[72],r8
8000af9e:	3f f8       	mov	r8,-1
8000afa0:	b8 78       	st.h	r12[0xe],r8
8000afa2:	30 18       	mov	r8,1
8000afa4:	b8 68       	st.h	r12[0xc],r8
8000afa6:	d8 22       	popm	r4-r7,pc

8000afa8 <__sinit>:
8000afa8:	d4 21       	pushm	r4-r7,lr
8000afaa:	18 96       	mov	r6,r12
8000afac:	78 67       	ld.w	r7,r12[0x18]
8000afae:	58 07       	cp.w	r7,0
8000afb0:	c4 91       	brne	8000b042 <__sinit+0x9a>
8000afb2:	fe c8 00 aa 	sub	r8,pc,170
8000afb6:	30 15       	mov	r5,1
8000afb8:	99 a8       	st.w	r12[0x28],r8
8000afba:	f9 47 00 d8 	st.w	r12[216],r7
8000afbe:	f9 47 00 dc 	st.w	r12[220],r7
8000afc2:	f9 47 00 e0 	st.w	r12[224],r7
8000afc6:	99 65       	st.w	r12[0x18],r5
8000afc8:	cb af       	rcall	8000af3c <__sfp>
8000afca:	8d 0c       	st.w	r6[0x0],r12
8000afcc:	0c 9c       	mov	r12,r6
8000afce:	cb 7f       	rcall	8000af3c <__sfp>
8000afd0:	8d 1c       	st.w	r6[0x4],r12
8000afd2:	0c 9c       	mov	r12,r6
8000afd4:	cb 4f       	rcall	8000af3c <__sfp>
8000afd6:	6c 09       	ld.w	r9,r6[0x0]
8000afd8:	30 48       	mov	r8,4
8000afda:	93 07       	st.w	r9[0x0],r7
8000afdc:	b2 68       	st.h	r9[0xc],r8
8000afde:	93 17       	st.w	r9[0x4],r7
8000afe0:	93 27       	st.w	r9[0x8],r7
8000afe2:	6c 18       	ld.w	r8,r6[0x4]
8000afe4:	b2 77       	st.h	r9[0xe],r7
8000afe6:	93 47       	st.w	r9[0x10],r7
8000afe8:	93 57       	st.w	r9[0x14],r7
8000afea:	93 67       	st.w	r9[0x18],r7
8000afec:	93 89       	st.w	r9[0x20],r9
8000afee:	91 07       	st.w	r8[0x0],r7
8000aff0:	91 17       	st.w	r8[0x4],r7
8000aff2:	91 27       	st.w	r8[0x8],r7
8000aff4:	fe ce f3 24 	sub	lr,pc,-3292
8000aff8:	fe cb f3 54 	sub	r11,pc,-3244
8000affc:	93 9e       	st.w	r9[0x24],lr
8000affe:	93 ab       	st.w	r9[0x28],r11
8000b000:	fe ca f3 7c 	sub	r10,pc,-3204
8000b004:	fe c4 f3 88 	sub	r4,pc,-3192
8000b008:	93 ba       	st.w	r9[0x2c],r10
8000b00a:	93 c4       	st.w	r9[0x30],r4
8000b00c:	30 99       	mov	r9,9
8000b00e:	b0 69       	st.h	r8[0xc],r9
8000b010:	b0 75       	st.h	r8[0xe],r5
8000b012:	91 c4       	st.w	r8[0x30],r4
8000b014:	91 47       	st.w	r8[0x10],r7
8000b016:	91 57       	st.w	r8[0x14],r7
8000b018:	91 67       	st.w	r8[0x18],r7
8000b01a:	91 88       	st.w	r8[0x20],r8
8000b01c:	91 9e       	st.w	r8[0x24],lr
8000b01e:	91 ab       	st.w	r8[0x28],r11
8000b020:	91 ba       	st.w	r8[0x2c],r10
8000b022:	8d 2c       	st.w	r6[0x8],r12
8000b024:	31 28       	mov	r8,18
8000b026:	99 07       	st.w	r12[0x0],r7
8000b028:	b8 68       	st.h	r12[0xc],r8
8000b02a:	99 17       	st.w	r12[0x4],r7
8000b02c:	99 27       	st.w	r12[0x8],r7
8000b02e:	30 28       	mov	r8,2
8000b030:	b8 78       	st.h	r12[0xe],r8
8000b032:	99 c4       	st.w	r12[0x30],r4
8000b034:	99 67       	st.w	r12[0x18],r7
8000b036:	99 9e       	st.w	r12[0x24],lr
8000b038:	99 ab       	st.w	r12[0x28],r11
8000b03a:	99 ba       	st.w	r12[0x2c],r10
8000b03c:	99 47       	st.w	r12[0x10],r7
8000b03e:	99 57       	st.w	r12[0x14],r7
8000b040:	99 8c       	st.w	r12[0x20],r12
8000b042:	d8 22       	popm	r4-r7,pc

8000b044 <_malloc_trim_r>:
8000b044:	d4 21       	pushm	r4-r7,lr
8000b046:	16 95       	mov	r5,r11
8000b048:	18 97       	mov	r7,r12
8000b04a:	fe b0 d7 a9 	rcall	80005f9c <__malloc_lock>
8000b04e:	e0 64 05 40 	mov	r4,1344
8000b052:	68 28       	ld.w	r8,r4[0x8]
8000b054:	70 16       	ld.w	r6,r8[0x4]
8000b056:	e0 16 ff fc 	andl	r6,0xfffc
8000b05a:	ec c8 ff 91 	sub	r8,r6,-111
8000b05e:	f0 05 01 05 	sub	r5,r8,r5
8000b062:	e0 15 ff 80 	andl	r5,0xff80
8000b066:	ea c5 00 80 	sub	r5,r5,128
8000b06a:	e0 45 00 7f 	cp.w	r5,127
8000b06e:	e0 8a 00 25 	brle	8000b0b8 <_malloc_trim_r+0x74>
8000b072:	30 0b       	mov	r11,0
8000b074:	0e 9c       	mov	r12,r7
8000b076:	fe b0 e6 05 	rcall	80007c80 <_sbrk_r>
8000b07a:	68 28       	ld.w	r8,r4[0x8]
8000b07c:	0c 08       	add	r8,r6
8000b07e:	10 3c       	cp.w	r12,r8
8000b080:	c1 c1       	brne	8000b0b8 <_malloc_trim_r+0x74>
8000b082:	ea 0b 11 00 	rsub	r11,r5,0
8000b086:	0e 9c       	mov	r12,r7
8000b088:	fe b0 e5 fc 	rcall	80007c80 <_sbrk_r>
8000b08c:	5b fc       	cp.w	r12,-1
8000b08e:	c1 91       	brne	8000b0c0 <_malloc_trim_r+0x7c>
8000b090:	30 0b       	mov	r11,0
8000b092:	0e 9c       	mov	r12,r7
8000b094:	fe b0 e5 f6 	rcall	80007c80 <_sbrk_r>
8000b098:	68 28       	ld.w	r8,r4[0x8]
8000b09a:	f8 08 01 09 	sub	r9,r12,r8
8000b09e:	58 f9       	cp.w	r9,15
8000b0a0:	e0 8a 00 0c 	brle	8000b0b8 <_malloc_trim_r+0x74>
8000b0a4:	a1 a9       	sbr	r9,0x0
8000b0a6:	91 19       	st.w	r8[0x4],r9
8000b0a8:	e0 68 09 4c 	mov	r8,2380
8000b0ac:	70 09       	ld.w	r9,r8[0x0]
8000b0ae:	e0 68 0d 6c 	mov	r8,3436
8000b0b2:	f8 09 01 09 	sub	r9,r12,r9
8000b0b6:	91 09       	st.w	r8[0x0],r9
8000b0b8:	0e 9c       	mov	r12,r7
8000b0ba:	fe b0 d7 77 	rcall	80005fa8 <__malloc_unlock>
8000b0be:	d8 2a       	popm	r4-r7,pc,r12=0
8000b0c0:	68 28       	ld.w	r8,r4[0x8]
8000b0c2:	0a 16       	sub	r6,r5
8000b0c4:	a1 a6       	sbr	r6,0x0
8000b0c6:	91 16       	st.w	r8[0x4],r6
8000b0c8:	e0 68 0d 6c 	mov	r8,3436
8000b0cc:	70 09       	ld.w	r9,r8[0x0]
8000b0ce:	0a 19       	sub	r9,r5
8000b0d0:	0e 9c       	mov	r12,r7
8000b0d2:	91 09       	st.w	r8[0x0],r9
8000b0d4:	fe b0 d7 6a 	rcall	80005fa8 <__malloc_unlock>
8000b0d8:	da 2a       	popm	r4-r7,pc,r12=1
8000b0da:	d7 03       	nop

8000b0dc <_free_r>:
8000b0dc:	d4 21       	pushm	r4-r7,lr
8000b0de:	16 96       	mov	r6,r11
8000b0e0:	18 97       	mov	r7,r12
8000b0e2:	58 0b       	cp.w	r11,0
8000b0e4:	e0 80 00 c0 	breq	8000b264 <_free_r+0x188>
8000b0e8:	fe b0 d7 5a 	rcall	80005f9c <__malloc_lock>
8000b0ec:	20 86       	sub	r6,8
8000b0ee:	e0 6a 05 40 	mov	r10,1344
8000b0f2:	6c 18       	ld.w	r8,r6[0x4]
8000b0f4:	74 2e       	ld.w	lr,r10[0x8]
8000b0f6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b0fa:	a1 c8       	cbr	r8,0x0
8000b0fc:	ec 08 00 09 	add	r9,r6,r8
8000b100:	72 1b       	ld.w	r11,r9[0x4]
8000b102:	e0 1b ff fc 	andl	r11,0xfffc
8000b106:	1c 39       	cp.w	r9,lr
8000b108:	c1 e1       	brne	8000b144 <_free_r+0x68>
8000b10a:	f6 08 00 08 	add	r8,r11,r8
8000b10e:	58 0c       	cp.w	r12,0
8000b110:	c0 81       	brne	8000b120 <_free_r+0x44>
8000b112:	6c 09       	ld.w	r9,r6[0x0]
8000b114:	12 16       	sub	r6,r9
8000b116:	12 08       	add	r8,r9
8000b118:	6c 3b       	ld.w	r11,r6[0xc]
8000b11a:	6c 29       	ld.w	r9,r6[0x8]
8000b11c:	97 29       	st.w	r11[0x8],r9
8000b11e:	93 3b       	st.w	r9[0xc],r11
8000b120:	10 99       	mov	r9,r8
8000b122:	95 26       	st.w	r10[0x8],r6
8000b124:	a1 a9       	sbr	r9,0x0
8000b126:	8d 19       	st.w	r6[0x4],r9
8000b128:	e0 69 09 48 	mov	r9,2376
8000b12c:	72 09       	ld.w	r9,r9[0x0]
8000b12e:	12 38       	cp.w	r8,r9
8000b130:	c0 63       	brcs	8000b13c <_free_r+0x60>
8000b132:	e0 68 0d 68 	mov	r8,3432
8000b136:	0e 9c       	mov	r12,r7
8000b138:	70 0b       	ld.w	r11,r8[0x0]
8000b13a:	c8 5f       	rcall	8000b044 <_malloc_trim_r>
8000b13c:	0e 9c       	mov	r12,r7
8000b13e:	fe b0 d7 35 	rcall	80005fa8 <__malloc_unlock>
8000b142:	d8 22       	popm	r4-r7,pc
8000b144:	93 1b       	st.w	r9[0x4],r11
8000b146:	58 0c       	cp.w	r12,0
8000b148:	c0 30       	breq	8000b14e <_free_r+0x72>
8000b14a:	30 0c       	mov	r12,0
8000b14c:	c1 08       	rjmp	8000b16c <_free_r+0x90>
8000b14e:	6c 0e       	ld.w	lr,r6[0x0]
8000b150:	f4 c5 ff f8 	sub	r5,r10,-8
8000b154:	1c 16       	sub	r6,lr
8000b156:	1c 08       	add	r8,lr
8000b158:	6c 2e       	ld.w	lr,r6[0x8]
8000b15a:	0a 3e       	cp.w	lr,r5
8000b15c:	f9 bc 00 01 	moveq	r12,1
8000b160:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b164:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b168:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b16c:	f2 0b 00 0e 	add	lr,r9,r11
8000b170:	7c 1e       	ld.w	lr,lr[0x4]
8000b172:	ed be 00 00 	bld	lr,0x0
8000b176:	c1 40       	breq	8000b19e <_free_r+0xc2>
8000b178:	16 08       	add	r8,r11
8000b17a:	58 0c       	cp.w	r12,0
8000b17c:	c0 d1       	brne	8000b196 <_free_r+0xba>
8000b17e:	e0 6e 05 40 	mov	lr,1344
8000b182:	72 2b       	ld.w	r11,r9[0x8]
8000b184:	2f 8e       	sub	lr,-8
8000b186:	1c 3b       	cp.w	r11,lr
8000b188:	c0 71       	brne	8000b196 <_free_r+0xba>
8000b18a:	97 36       	st.w	r11[0xc],r6
8000b18c:	97 26       	st.w	r11[0x8],r6
8000b18e:	8d 2b       	st.w	r6[0x8],r11
8000b190:	8d 3b       	st.w	r6[0xc],r11
8000b192:	30 1c       	mov	r12,1
8000b194:	c0 58       	rjmp	8000b19e <_free_r+0xc2>
8000b196:	72 2b       	ld.w	r11,r9[0x8]
8000b198:	72 39       	ld.w	r9,r9[0xc]
8000b19a:	93 2b       	st.w	r9[0x8],r11
8000b19c:	97 39       	st.w	r11[0xc],r9
8000b19e:	10 99       	mov	r9,r8
8000b1a0:	ec 08 09 08 	st.w	r6[r8],r8
8000b1a4:	a1 a9       	sbr	r9,0x0
8000b1a6:	8d 19       	st.w	r6[0x4],r9
8000b1a8:	58 0c       	cp.w	r12,0
8000b1aa:	c5 a1       	brne	8000b25e <_free_r+0x182>
8000b1ac:	e0 48 01 ff 	cp.w	r8,511
8000b1b0:	e0 8b 00 13 	brhi	8000b1d6 <_free_r+0xfa>
8000b1b4:	a3 98       	lsr	r8,0x3
8000b1b6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b1ba:	72 2b       	ld.w	r11,r9[0x8]
8000b1bc:	8d 39       	st.w	r6[0xc],r9
8000b1be:	8d 2b       	st.w	r6[0x8],r11
8000b1c0:	97 36       	st.w	r11[0xc],r6
8000b1c2:	93 26       	st.w	r9[0x8],r6
8000b1c4:	a3 48       	asr	r8,0x2
8000b1c6:	74 19       	ld.w	r9,r10[0x4]
8000b1c8:	30 1b       	mov	r11,1
8000b1ca:	f6 08 09 48 	lsl	r8,r11,r8
8000b1ce:	f3 e8 10 08 	or	r8,r9,r8
8000b1d2:	95 18       	st.w	r10[0x4],r8
8000b1d4:	c4 58       	rjmp	8000b25e <_free_r+0x182>
8000b1d6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b1da:	58 4b       	cp.w	r11,4
8000b1dc:	e0 8b 00 06 	brhi	8000b1e8 <_free_r+0x10c>
8000b1e0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b1e4:	2c 8b       	sub	r11,-56
8000b1e6:	c2 08       	rjmp	8000b226 <_free_r+0x14a>
8000b1e8:	59 4b       	cp.w	r11,20
8000b1ea:	e0 8b 00 04 	brhi	8000b1f2 <_free_r+0x116>
8000b1ee:	2a 5b       	sub	r11,-91
8000b1f0:	c1 b8       	rjmp	8000b226 <_free_r+0x14a>
8000b1f2:	e0 4b 00 54 	cp.w	r11,84
8000b1f6:	e0 8b 00 06 	brhi	8000b202 <_free_r+0x126>
8000b1fa:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b1fe:	29 2b       	sub	r11,-110
8000b200:	c1 38       	rjmp	8000b226 <_free_r+0x14a>
8000b202:	e0 4b 01 54 	cp.w	r11,340
8000b206:	e0 8b 00 06 	brhi	8000b212 <_free_r+0x136>
8000b20a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b20e:	28 9b       	sub	r11,-119
8000b210:	c0 b8       	rjmp	8000b226 <_free_r+0x14a>
8000b212:	e0 4b 05 54 	cp.w	r11,1364
8000b216:	e0 88 00 05 	brls	8000b220 <_free_r+0x144>
8000b21a:	37 eb       	mov	r11,126
8000b21c:	c0 58       	rjmp	8000b226 <_free_r+0x14a>
8000b21e:	d7 03       	nop
8000b220:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b224:	28 4b       	sub	r11,-124
8000b226:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b22a:	78 29       	ld.w	r9,r12[0x8]
8000b22c:	18 39       	cp.w	r9,r12
8000b22e:	c0 e1       	brne	8000b24a <_free_r+0x16e>
8000b230:	74 18       	ld.w	r8,r10[0x4]
8000b232:	a3 4b       	asr	r11,0x2
8000b234:	30 1c       	mov	r12,1
8000b236:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b23a:	f1 eb 10 0b 	or	r11,r8,r11
8000b23e:	12 98       	mov	r8,r9
8000b240:	95 1b       	st.w	r10[0x4],r11
8000b242:	c0 a8       	rjmp	8000b256 <_free_r+0x17a>
8000b244:	72 29       	ld.w	r9,r9[0x8]
8000b246:	18 39       	cp.w	r9,r12
8000b248:	c0 60       	breq	8000b254 <_free_r+0x178>
8000b24a:	72 1a       	ld.w	r10,r9[0x4]
8000b24c:	e0 1a ff fc 	andl	r10,0xfffc
8000b250:	14 38       	cp.w	r8,r10
8000b252:	cf 93       	brcs	8000b244 <_free_r+0x168>
8000b254:	72 38       	ld.w	r8,r9[0xc]
8000b256:	8d 38       	st.w	r6[0xc],r8
8000b258:	8d 29       	st.w	r6[0x8],r9
8000b25a:	93 36       	st.w	r9[0xc],r6
8000b25c:	91 26       	st.w	r8[0x8],r6
8000b25e:	0e 9c       	mov	r12,r7
8000b260:	fe b0 d6 a4 	rcall	80005fa8 <__malloc_unlock>
8000b264:	d8 22       	popm	r4-r7,pc
8000b266:	d7 03       	nop

8000b268 <__sfvwrite_r>:
8000b268:	d4 31       	pushm	r0-r7,lr
8000b26a:	20 3d       	sub	sp,12
8000b26c:	14 94       	mov	r4,r10
8000b26e:	18 95       	mov	r5,r12
8000b270:	16 97       	mov	r7,r11
8000b272:	74 28       	ld.w	r8,r10[0x8]
8000b274:	58 08       	cp.w	r8,0
8000b276:	e0 80 01 40 	breq	8000b4f6 <__sfvwrite_r+0x28e>
8000b27a:	96 68       	ld.sh	r8,r11[0xc]
8000b27c:	ed b8 00 03 	bld	r8,0x3
8000b280:	c0 41       	brne	8000b288 <__sfvwrite_r+0x20>
8000b282:	76 48       	ld.w	r8,r11[0x10]
8000b284:	58 08       	cp.w	r8,0
8000b286:	c0 c1       	brne	8000b29e <__sfvwrite_r+0x36>
8000b288:	0e 9b       	mov	r11,r7
8000b28a:	0a 9c       	mov	r12,r5
8000b28c:	fe b0 f6 c4 	rcall	8000a014 <__swsetup_r>
8000b290:	c0 70       	breq	8000b29e <__sfvwrite_r+0x36>
8000b292:	8e 68       	ld.sh	r8,r7[0xc]
8000b294:	a7 a8       	sbr	r8,0x6
8000b296:	ae 68       	st.h	r7[0xc],r8
8000b298:	30 98       	mov	r8,9
8000b29a:	8b 38       	st.w	r5[0xc],r8
8000b29c:	c2 b9       	rjmp	8000b4f2 <__sfvwrite_r+0x28a>
8000b29e:	8e 63       	ld.sh	r3,r7[0xc]
8000b2a0:	68 00       	ld.w	r0,r4[0x0]
8000b2a2:	06 96       	mov	r6,r3
8000b2a4:	e2 16 00 02 	andl	r6,0x2,COH
8000b2a8:	c2 10       	breq	8000b2ea <__sfvwrite_r+0x82>
8000b2aa:	30 03       	mov	r3,0
8000b2ac:	e0 62 04 00 	mov	r2,1024
8000b2b0:	06 96       	mov	r6,r3
8000b2b2:	c0 48       	rjmp	8000b2ba <__sfvwrite_r+0x52>
8000b2b4:	60 03       	ld.w	r3,r0[0x0]
8000b2b6:	60 16       	ld.w	r6,r0[0x4]
8000b2b8:	2f 80       	sub	r0,-8
8000b2ba:	58 06       	cp.w	r6,0
8000b2bc:	cf c0       	breq	8000b2b4 <__sfvwrite_r+0x4c>
8000b2be:	e0 46 04 00 	cp.w	r6,1024
8000b2c2:	ec 09 17 80 	movls	r9,r6
8000b2c6:	e4 09 17 b0 	movhi	r9,r2
8000b2ca:	06 9a       	mov	r10,r3
8000b2cc:	6e a8       	ld.w	r8,r7[0x28]
8000b2ce:	6e 8b       	ld.w	r11,r7[0x20]
8000b2d0:	0a 9c       	mov	r12,r5
8000b2d2:	5d 18       	icall	r8
8000b2d4:	18 16       	sub	r6,r12
8000b2d6:	58 0c       	cp.w	r12,0
8000b2d8:	e0 8a 01 0a 	brle	8000b4ec <__sfvwrite_r+0x284>
8000b2dc:	68 28       	ld.w	r8,r4[0x8]
8000b2de:	18 18       	sub	r8,r12
8000b2e0:	89 28       	st.w	r4[0x8],r8
8000b2e2:	e0 80 01 0a 	breq	8000b4f6 <__sfvwrite_r+0x28e>
8000b2e6:	18 03       	add	r3,r12
8000b2e8:	ce 9b       	rjmp	8000b2ba <__sfvwrite_r+0x52>
8000b2ea:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b2ee:	c0 70       	breq	8000b2fc <__sfvwrite_r+0x94>
8000b2f0:	50 06       	stdsp	sp[0x0],r6
8000b2f2:	0c 93       	mov	r3,r6
8000b2f4:	0c 91       	mov	r1,r6
8000b2f6:	50 15       	stdsp	sp[0x4],r5
8000b2f8:	08 92       	mov	r2,r4
8000b2fa:	c9 c8       	rjmp	8000b432 <__sfvwrite_r+0x1ca>
8000b2fc:	06 96       	mov	r6,r3
8000b2fe:	08 91       	mov	r1,r4
8000b300:	c0 48       	rjmp	8000b308 <__sfvwrite_r+0xa0>
8000b302:	60 03       	ld.w	r3,r0[0x0]
8000b304:	60 16       	ld.w	r6,r0[0x4]
8000b306:	2f 80       	sub	r0,-8
8000b308:	58 06       	cp.w	r6,0
8000b30a:	cf c0       	breq	8000b302 <__sfvwrite_r+0x9a>
8000b30c:	8e 68       	ld.sh	r8,r7[0xc]
8000b30e:	6e 24       	ld.w	r4,r7[0x8]
8000b310:	10 99       	mov	r9,r8
8000b312:	e2 19 02 00 	andl	r9,0x200,COH
8000b316:	c5 50       	breq	8000b3c0 <__sfvwrite_r+0x158>
8000b318:	08 36       	cp.w	r6,r4
8000b31a:	c4 43       	brcs	8000b3a2 <__sfvwrite_r+0x13a>
8000b31c:	10 99       	mov	r9,r8
8000b31e:	e2 19 04 80 	andl	r9,0x480,COH
8000b322:	c4 00       	breq	8000b3a2 <__sfvwrite_r+0x13a>
8000b324:	6e 4b       	ld.w	r11,r7[0x10]
8000b326:	6e 09       	ld.w	r9,r7[0x0]
8000b328:	16 19       	sub	r9,r11
8000b32a:	50 09       	stdsp	sp[0x0],r9
8000b32c:	6e 59       	ld.w	r9,r7[0x14]
8000b32e:	10 9c       	mov	r12,r8
8000b330:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b334:	30 28       	mov	r8,2
8000b336:	f4 08 0c 08 	divs	r8,r10,r8
8000b33a:	fa e9 00 04 	st.d	sp[4],r8
8000b33e:	10 94       	mov	r4,r8
8000b340:	40 09       	lddsp	r9,sp[0x0]
8000b342:	e2 1c 04 00 	andl	r12,0x400,COH
8000b346:	2f f9       	sub	r9,-1
8000b348:	0c 09       	add	r9,r6
8000b34a:	12 38       	cp.w	r8,r9
8000b34c:	f2 04 17 30 	movlo	r4,r9
8000b350:	58 0c       	cp.w	r12,0
8000b352:	c1 10       	breq	8000b374 <__sfvwrite_r+0x10c>
8000b354:	08 9b       	mov	r11,r4
8000b356:	0a 9c       	mov	r12,r5
8000b358:	fe b0 e0 6c 	rcall	80007430 <_malloc_r>
8000b35c:	18 92       	mov	r2,r12
8000b35e:	c1 40       	breq	8000b386 <__sfvwrite_r+0x11e>
8000b360:	40 0a       	lddsp	r10,sp[0x0]
8000b362:	6e 4b       	ld.w	r11,r7[0x10]
8000b364:	fe b0 e2 82 	rcall	80007868 <memcpy>
8000b368:	8e 68       	ld.sh	r8,r7[0xc]
8000b36a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b36e:	a7 b8       	sbr	r8,0x7
8000b370:	ae 68       	st.h	r7[0xc],r8
8000b372:	c0 d8       	rjmp	8000b38c <__sfvwrite_r+0x124>
8000b374:	08 9a       	mov	r10,r4
8000b376:	0a 9c       	mov	r12,r5
8000b378:	fe b0 e3 24 	rcall	800079c0 <_realloc_r>
8000b37c:	18 92       	mov	r2,r12
8000b37e:	c0 71       	brne	8000b38c <__sfvwrite_r+0x124>
8000b380:	6e 4b       	ld.w	r11,r7[0x10]
8000b382:	0a 9c       	mov	r12,r5
8000b384:	ca ce       	rcall	8000b0dc <_free_r>
8000b386:	30 c8       	mov	r8,12
8000b388:	8b 38       	st.w	r5[0xc],r8
8000b38a:	cb 18       	rjmp	8000b4ec <__sfvwrite_r+0x284>
8000b38c:	40 0a       	lddsp	r10,sp[0x0]
8000b38e:	40 09       	lddsp	r9,sp[0x0]
8000b390:	e8 0a 01 0a 	sub	r10,r4,r10
8000b394:	e4 09 00 08 	add	r8,r2,r9
8000b398:	8f 54       	st.w	r7[0x14],r4
8000b39a:	8f 2a       	st.w	r7[0x8],r10
8000b39c:	8f 08       	st.w	r7[0x0],r8
8000b39e:	8f 42       	st.w	r7[0x10],r2
8000b3a0:	0c 94       	mov	r4,r6
8000b3a2:	08 36       	cp.w	r6,r4
8000b3a4:	ec 04 17 30 	movlo	r4,r6
8000b3a8:	06 9b       	mov	r11,r3
8000b3aa:	08 9a       	mov	r10,r4
8000b3ac:	6e 0c       	ld.w	r12,r7[0x0]
8000b3ae:	c3 ad       	rcall	8000b622 <memmove>
8000b3b0:	6e 08       	ld.w	r8,r7[0x0]
8000b3b2:	08 08       	add	r8,r4
8000b3b4:	8f 08       	st.w	r7[0x0],r8
8000b3b6:	6e 28       	ld.w	r8,r7[0x8]
8000b3b8:	08 18       	sub	r8,r4
8000b3ba:	0c 94       	mov	r4,r6
8000b3bc:	8f 28       	st.w	r7[0x8],r8
8000b3be:	c2 e8       	rjmp	8000b41a <__sfvwrite_r+0x1b2>
8000b3c0:	08 36       	cp.w	r6,r4
8000b3c2:	5f ba       	srhi	r10
8000b3c4:	6e 0c       	ld.w	r12,r7[0x0]
8000b3c6:	6e 48       	ld.w	r8,r7[0x10]
8000b3c8:	10 3c       	cp.w	r12,r8
8000b3ca:	5f b8       	srhi	r8
8000b3cc:	f5 e8 00 08 	and	r8,r10,r8
8000b3d0:	f2 08 18 00 	cp.b	r8,r9
8000b3d4:	c0 d0       	breq	8000b3ee <__sfvwrite_r+0x186>
8000b3d6:	06 9b       	mov	r11,r3
8000b3d8:	08 9a       	mov	r10,r4
8000b3da:	c2 4d       	rcall	8000b622 <memmove>
8000b3dc:	6e 08       	ld.w	r8,r7[0x0]
8000b3de:	08 08       	add	r8,r4
8000b3e0:	0e 9b       	mov	r11,r7
8000b3e2:	8f 08       	st.w	r7[0x0],r8
8000b3e4:	0a 9c       	mov	r12,r5
8000b3e6:	fe b0 fd 09 	rcall	8000adf8 <_fflush_r>
8000b3ea:	c1 80       	breq	8000b41a <__sfvwrite_r+0x1b2>
8000b3ec:	c8 08       	rjmp	8000b4ec <__sfvwrite_r+0x284>
8000b3ee:	6e 59       	ld.w	r9,r7[0x14]
8000b3f0:	12 36       	cp.w	r6,r9
8000b3f2:	c0 a3       	brcs	8000b406 <__sfvwrite_r+0x19e>
8000b3f4:	6e a8       	ld.w	r8,r7[0x28]
8000b3f6:	06 9a       	mov	r10,r3
8000b3f8:	6e 8b       	ld.w	r11,r7[0x20]
8000b3fa:	0a 9c       	mov	r12,r5
8000b3fc:	5d 18       	icall	r8
8000b3fe:	18 94       	mov	r4,r12
8000b400:	e0 89 00 0d 	brgt	8000b41a <__sfvwrite_r+0x1b2>
8000b404:	c7 48       	rjmp	8000b4ec <__sfvwrite_r+0x284>
8000b406:	0c 9a       	mov	r10,r6
8000b408:	06 9b       	mov	r11,r3
8000b40a:	c0 cd       	rcall	8000b622 <memmove>
8000b40c:	6e 08       	ld.w	r8,r7[0x0]
8000b40e:	0c 08       	add	r8,r6
8000b410:	0c 94       	mov	r4,r6
8000b412:	8f 08       	st.w	r7[0x0],r8
8000b414:	6e 28       	ld.w	r8,r7[0x8]
8000b416:	0c 18       	sub	r8,r6
8000b418:	8f 28       	st.w	r7[0x8],r8
8000b41a:	62 28       	ld.w	r8,r1[0x8]
8000b41c:	08 18       	sub	r8,r4
8000b41e:	83 28       	st.w	r1[0x8],r8
8000b420:	c6 b0       	breq	8000b4f6 <__sfvwrite_r+0x28e>
8000b422:	08 16       	sub	r6,r4
8000b424:	08 03       	add	r3,r4
8000b426:	c7 1b       	rjmp	8000b308 <__sfvwrite_r+0xa0>
8000b428:	60 03       	ld.w	r3,r0[0x0]
8000b42a:	60 11       	ld.w	r1,r0[0x4]
8000b42c:	30 08       	mov	r8,0
8000b42e:	2f 80       	sub	r0,-8
8000b430:	50 08       	stdsp	sp[0x0],r8
8000b432:	58 01       	cp.w	r1,0
8000b434:	cf a0       	breq	8000b428 <__sfvwrite_r+0x1c0>
8000b436:	40 0a       	lddsp	r10,sp[0x0]
8000b438:	58 0a       	cp.w	r10,0
8000b43a:	c1 41       	brne	8000b462 <__sfvwrite_r+0x1fa>
8000b43c:	e2 c6 ff ff 	sub	r6,r1,-1
8000b440:	02 9a       	mov	r10,r1
8000b442:	30 ab       	mov	r11,10
8000b444:	06 9c       	mov	r12,r3
8000b446:	ce 3c       	rcall	8000b60c <memchr>
8000b448:	f8 c8 ff ff 	sub	r8,r12,-1
8000b44c:	58 0c       	cp.w	r12,0
8000b44e:	f1 d3 e1 16 	subne	r6,r8,r3
8000b452:	f9 b9 01 01 	movne	r9,1
8000b456:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b45a:	f9 b8 00 01 	moveq	r8,1
8000b45e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b462:	02 36       	cp.w	r6,r1
8000b464:	ec 04 17 80 	movls	r4,r6
8000b468:	e2 04 17 b0 	movhi	r4,r1
8000b46c:	6e 59       	ld.w	r9,r7[0x14]
8000b46e:	6e 25       	ld.w	r5,r7[0x8]
8000b470:	f2 05 00 05 	add	r5,r9,r5
8000b474:	0a 34       	cp.w	r4,r5
8000b476:	5f 9a       	srgt	r10
8000b478:	6e 0c       	ld.w	r12,r7[0x0]
8000b47a:	6e 48       	ld.w	r8,r7[0x10]
8000b47c:	10 3c       	cp.w	r12,r8
8000b47e:	5f b8       	srhi	r8
8000b480:	f5 e8 00 08 	and	r8,r10,r8
8000b484:	30 0a       	mov	r10,0
8000b486:	f4 08 18 00 	cp.b	r8,r10
8000b48a:	c0 d0       	breq	8000b4a4 <__sfvwrite_r+0x23c>
8000b48c:	06 9b       	mov	r11,r3
8000b48e:	0a 9a       	mov	r10,r5
8000b490:	cc 9c       	rcall	8000b622 <memmove>
8000b492:	6e 08       	ld.w	r8,r7[0x0]
8000b494:	0a 08       	add	r8,r5
8000b496:	0e 9b       	mov	r11,r7
8000b498:	8f 08       	st.w	r7[0x0],r8
8000b49a:	40 1c       	lddsp	r12,sp[0x4]
8000b49c:	fe b0 fc ae 	rcall	8000adf8 <_fflush_r>
8000b4a0:	c1 70       	breq	8000b4ce <__sfvwrite_r+0x266>
8000b4a2:	c2 58       	rjmp	8000b4ec <__sfvwrite_r+0x284>
8000b4a4:	12 34       	cp.w	r4,r9
8000b4a6:	c0 a5       	brlt	8000b4ba <__sfvwrite_r+0x252>
8000b4a8:	6e a8       	ld.w	r8,r7[0x28]
8000b4aa:	06 9a       	mov	r10,r3
8000b4ac:	6e 8b       	ld.w	r11,r7[0x20]
8000b4ae:	40 1c       	lddsp	r12,sp[0x4]
8000b4b0:	5d 18       	icall	r8
8000b4b2:	18 95       	mov	r5,r12
8000b4b4:	e0 89 00 0d 	brgt	8000b4ce <__sfvwrite_r+0x266>
8000b4b8:	c1 a8       	rjmp	8000b4ec <__sfvwrite_r+0x284>
8000b4ba:	08 9a       	mov	r10,r4
8000b4bc:	06 9b       	mov	r11,r3
8000b4be:	cb 2c       	rcall	8000b622 <memmove>
8000b4c0:	6e 08       	ld.w	r8,r7[0x0]
8000b4c2:	08 08       	add	r8,r4
8000b4c4:	08 95       	mov	r5,r4
8000b4c6:	8f 08       	st.w	r7[0x0],r8
8000b4c8:	6e 28       	ld.w	r8,r7[0x8]
8000b4ca:	08 18       	sub	r8,r4
8000b4cc:	8f 28       	st.w	r7[0x8],r8
8000b4ce:	0a 16       	sub	r6,r5
8000b4d0:	c0 71       	brne	8000b4de <__sfvwrite_r+0x276>
8000b4d2:	0e 9b       	mov	r11,r7
8000b4d4:	40 1c       	lddsp	r12,sp[0x4]
8000b4d6:	fe b0 fc 91 	rcall	8000adf8 <_fflush_r>
8000b4da:	c0 91       	brne	8000b4ec <__sfvwrite_r+0x284>
8000b4dc:	50 06       	stdsp	sp[0x0],r6
8000b4de:	64 28       	ld.w	r8,r2[0x8]
8000b4e0:	0a 18       	sub	r8,r5
8000b4e2:	85 28       	st.w	r2[0x8],r8
8000b4e4:	c0 90       	breq	8000b4f6 <__sfvwrite_r+0x28e>
8000b4e6:	0a 11       	sub	r1,r5
8000b4e8:	0a 03       	add	r3,r5
8000b4ea:	ca 4b       	rjmp	8000b432 <__sfvwrite_r+0x1ca>
8000b4ec:	8e 68       	ld.sh	r8,r7[0xc]
8000b4ee:	a7 a8       	sbr	r8,0x6
8000b4f0:	ae 68       	st.h	r7[0xc],r8
8000b4f2:	3f fc       	mov	r12,-1
8000b4f4:	c0 28       	rjmp	8000b4f8 <__sfvwrite_r+0x290>
8000b4f6:	30 0c       	mov	r12,0
8000b4f8:	2f dd       	sub	sp,-12
8000b4fa:	d8 32       	popm	r0-r7,pc

8000b4fc <_fwalk>:
8000b4fc:	d4 31       	pushm	r0-r7,lr
8000b4fe:	30 05       	mov	r5,0
8000b500:	16 91       	mov	r1,r11
8000b502:	f8 c7 ff 28 	sub	r7,r12,-216
8000b506:	0a 92       	mov	r2,r5
8000b508:	fe b0 fc fe 	rcall	8000af04 <__sfp_lock_acquire>
8000b50c:	3f f3       	mov	r3,-1
8000b50e:	c1 68       	rjmp	8000b53a <_fwalk+0x3e>
8000b510:	6e 26       	ld.w	r6,r7[0x8]
8000b512:	6e 14       	ld.w	r4,r7[0x4]
8000b514:	2f 46       	sub	r6,-12
8000b516:	c0 c8       	rjmp	8000b52e <_fwalk+0x32>
8000b518:	8c 08       	ld.sh	r8,r6[0x0]
8000b51a:	e4 08 19 00 	cp.h	r8,r2
8000b51e:	c0 70       	breq	8000b52c <_fwalk+0x30>
8000b520:	8c 18       	ld.sh	r8,r6[0x2]
8000b522:	e6 08 19 00 	cp.h	r8,r3
8000b526:	c0 30       	breq	8000b52c <_fwalk+0x30>
8000b528:	5d 11       	icall	r1
8000b52a:	18 45       	or	r5,r12
8000b52c:	2a 46       	sub	r6,-92
8000b52e:	20 14       	sub	r4,1
8000b530:	ec cc 00 0c 	sub	r12,r6,12
8000b534:	58 04       	cp.w	r4,0
8000b536:	cf 14       	brge	8000b518 <_fwalk+0x1c>
8000b538:	6e 07       	ld.w	r7,r7[0x0]
8000b53a:	58 07       	cp.w	r7,0
8000b53c:	ce a1       	brne	8000b510 <_fwalk+0x14>
8000b53e:	fe b0 fc e4 	rcall	8000af06 <__sfp_lock_release>
8000b542:	0a 9c       	mov	r12,r5
8000b544:	d8 32       	popm	r0-r7,pc
8000b546:	d7 03       	nop

8000b548 <_localeconv_r>:
8000b548:	fe cc d3 c8 	sub	r12,pc,-11320
8000b54c:	5e fc       	retal	r12
8000b54e:	d7 03       	nop

8000b550 <__smakebuf_r>:
8000b550:	d4 21       	pushm	r4-r7,lr
8000b552:	20 fd       	sub	sp,60
8000b554:	96 68       	ld.sh	r8,r11[0xc]
8000b556:	16 97       	mov	r7,r11
8000b558:	18 96       	mov	r6,r12
8000b55a:	e2 18 00 02 	andl	r8,0x2,COH
8000b55e:	c3 d1       	brne	8000b5d8 <__smakebuf_r+0x88>
8000b560:	96 7b       	ld.sh	r11,r11[0xe]
8000b562:	f0 0b 19 00 	cp.h	r11,r8
8000b566:	c0 55       	brlt	8000b570 <__smakebuf_r+0x20>
8000b568:	1a 9a       	mov	r10,sp
8000b56a:	e0 a0 04 81 	rcall	8000be6c <_fstat_r>
8000b56e:	c0 f4       	brge	8000b58c <__smakebuf_r+0x3c>
8000b570:	8e 65       	ld.sh	r5,r7[0xc]
8000b572:	0a 98       	mov	r8,r5
8000b574:	ab b8       	sbr	r8,0xb
8000b576:	e2 15 00 80 	andl	r5,0x80,COH
8000b57a:	ae 68       	st.h	r7[0xc],r8
8000b57c:	30 04       	mov	r4,0
8000b57e:	e0 68 04 00 	mov	r8,1024
8000b582:	f9 b5 01 40 	movne	r5,64
8000b586:	f0 05 17 00 	moveq	r5,r8
8000b58a:	c1 c8       	rjmp	8000b5c2 <__smakebuf_r+0x72>
8000b58c:	40 18       	lddsp	r8,sp[0x4]
8000b58e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b592:	e0 48 20 00 	cp.w	r8,8192
8000b596:	5f 04       	sreq	r4
8000b598:	e0 48 80 00 	cp.w	r8,32768
8000b59c:	c0 e1       	brne	8000b5b8 <__smakebuf_r+0x68>
8000b59e:	6e b9       	ld.w	r9,r7[0x2c]
8000b5a0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b5a4:	10 39       	cp.w	r9,r8
8000b5a6:	c0 91       	brne	8000b5b8 <__smakebuf_r+0x68>
8000b5a8:	8e 68       	ld.sh	r8,r7[0xc]
8000b5aa:	e0 65 04 00 	mov	r5,1024
8000b5ae:	ab a8       	sbr	r8,0xa
8000b5b0:	ef 45 00 50 	st.w	r7[80],r5
8000b5b4:	ae 68       	st.h	r7[0xc],r8
8000b5b6:	c0 68       	rjmp	8000b5c2 <__smakebuf_r+0x72>
8000b5b8:	8e 68       	ld.sh	r8,r7[0xc]
8000b5ba:	e0 65 04 00 	mov	r5,1024
8000b5be:	ab b8       	sbr	r8,0xb
8000b5c0:	ae 68       	st.h	r7[0xc],r8
8000b5c2:	0a 9b       	mov	r11,r5
8000b5c4:	0c 9c       	mov	r12,r6
8000b5c6:	fe b0 df 35 	rcall	80007430 <_malloc_r>
8000b5ca:	8e 68       	ld.sh	r8,r7[0xc]
8000b5cc:	c0 d1       	brne	8000b5e6 <__smakebuf_r+0x96>
8000b5ce:	ed b8 00 09 	bld	r8,0x9
8000b5d2:	c1 b0       	breq	8000b608 <__smakebuf_r+0xb8>
8000b5d4:	a1 b8       	sbr	r8,0x1
8000b5d6:	ae 68       	st.h	r7[0xc],r8
8000b5d8:	ee c8 ff b9 	sub	r8,r7,-71
8000b5dc:	8f 48       	st.w	r7[0x10],r8
8000b5de:	8f 08       	st.w	r7[0x0],r8
8000b5e0:	30 18       	mov	r8,1
8000b5e2:	8f 58       	st.w	r7[0x14],r8
8000b5e4:	c1 28       	rjmp	8000b608 <__smakebuf_r+0xb8>
8000b5e6:	a7 b8       	sbr	r8,0x7
8000b5e8:	8f 4c       	st.w	r7[0x10],r12
8000b5ea:	ae 68       	st.h	r7[0xc],r8
8000b5ec:	8f 55       	st.w	r7[0x14],r5
8000b5ee:	fe c8 06 e6 	sub	r8,pc,1766
8000b5f2:	8f 0c       	st.w	r7[0x0],r12
8000b5f4:	8d a8       	st.w	r6[0x28],r8
8000b5f6:	58 04       	cp.w	r4,0
8000b5f8:	c0 80       	breq	8000b608 <__smakebuf_r+0xb8>
8000b5fa:	8e 7c       	ld.sh	r12,r7[0xe]
8000b5fc:	fe b0 e3 94 	rcall	80007d24 <isatty>
8000b600:	c0 40       	breq	8000b608 <__smakebuf_r+0xb8>
8000b602:	8e 68       	ld.sh	r8,r7[0xc]
8000b604:	a1 a8       	sbr	r8,0x0
8000b606:	ae 68       	st.h	r7[0xc],r8
8000b608:	2f 1d       	sub	sp,-60
8000b60a:	d8 22       	popm	r4-r7,pc

8000b60c <memchr>:
8000b60c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b610:	c0 68       	rjmp	8000b61c <memchr+0x10>
8000b612:	20 1a       	sub	r10,1
8000b614:	19 88       	ld.ub	r8,r12[0x0]
8000b616:	16 38       	cp.w	r8,r11
8000b618:	5e 0c       	reteq	r12
8000b61a:	2f fc       	sub	r12,-1
8000b61c:	58 0a       	cp.w	r10,0
8000b61e:	cf a1       	brne	8000b612 <memchr+0x6>
8000b620:	5e fa       	retal	r10

8000b622 <memmove>:
8000b622:	d4 01       	pushm	lr
8000b624:	18 3b       	cp.w	r11,r12
8000b626:	c1 92       	brcc	8000b658 <memmove+0x36>
8000b628:	f6 0a 00 09 	add	r9,r11,r10
8000b62c:	12 3c       	cp.w	r12,r9
8000b62e:	c1 52       	brcc	8000b658 <memmove+0x36>
8000b630:	f8 0a 00 0b 	add	r11,r12,r10
8000b634:	30 08       	mov	r8,0
8000b636:	c0 68       	rjmp	8000b642 <memmove+0x20>
8000b638:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b63c:	20 1a       	sub	r10,1
8000b63e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b642:	20 18       	sub	r8,1
8000b644:	58 0a       	cp.w	r10,0
8000b646:	cf 91       	brne	8000b638 <memmove+0x16>
8000b648:	d8 02       	popm	pc
8000b64a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b64e:	20 1a       	sub	r10,1
8000b650:	f8 08 0b 09 	st.b	r12[r8],r9
8000b654:	2f f8       	sub	r8,-1
8000b656:	c0 28       	rjmp	8000b65a <memmove+0x38>
8000b658:	30 08       	mov	r8,0
8000b65a:	58 0a       	cp.w	r10,0
8000b65c:	cf 71       	brne	8000b64a <memmove+0x28>
8000b65e:	d8 02       	popm	pc

8000b660 <__hi0bits>:
8000b660:	18 98       	mov	r8,r12
8000b662:	e0 1c 00 00 	andl	r12,0x0
8000b666:	f0 09 15 10 	lsl	r9,r8,0x10
8000b66a:	58 0c       	cp.w	r12,0
8000b66c:	f2 08 17 00 	moveq	r8,r9
8000b670:	f9 bc 00 10 	moveq	r12,16
8000b674:	f9 bc 01 00 	movne	r12,0
8000b678:	10 9a       	mov	r10,r8
8000b67a:	f0 09 15 08 	lsl	r9,r8,0x8
8000b67e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b682:	f7 bc 00 f8 	subeq	r12,-8
8000b686:	f2 08 17 00 	moveq	r8,r9
8000b68a:	10 9a       	mov	r10,r8
8000b68c:	f0 09 15 04 	lsl	r9,r8,0x4
8000b690:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b694:	f7 bc 00 fc 	subeq	r12,-4
8000b698:	f2 08 17 00 	moveq	r8,r9
8000b69c:	10 9a       	mov	r10,r8
8000b69e:	f0 09 15 02 	lsl	r9,r8,0x2
8000b6a2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b6a6:	f7 bc 00 fe 	subeq	r12,-2
8000b6aa:	f2 08 17 00 	moveq	r8,r9
8000b6ae:	58 08       	cp.w	r8,0
8000b6b0:	5e 5c       	retlt	r12
8000b6b2:	ed b8 00 1e 	bld	r8,0x1e
8000b6b6:	f9 bc 01 20 	movne	r12,32
8000b6ba:	f7 bc 00 ff 	subeq	r12,-1
8000b6be:	5e fc       	retal	r12

8000b6c0 <__lo0bits>:
8000b6c0:	18 99       	mov	r9,r12
8000b6c2:	78 08       	ld.w	r8,r12[0x0]
8000b6c4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b6c8:	c1 50       	breq	8000b6f2 <__lo0bits+0x32>
8000b6ca:	ed b8 00 00 	bld	r8,0x0
8000b6ce:	c0 21       	brne	8000b6d2 <__lo0bits+0x12>
8000b6d0:	5e fd       	retal	0
8000b6d2:	10 9b       	mov	r11,r8
8000b6d4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b6d8:	e2 1b 00 02 	andl	r11,0x2,COH
8000b6dc:	a3 88       	lsr	r8,0x2
8000b6de:	58 0b       	cp.w	r11,0
8000b6e0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b6e4:	f9 bc 01 01 	movne	r12,1
8000b6e8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b6ec:	f9 bc 00 02 	moveq	r12,2
8000b6f0:	5e fc       	retal	r12
8000b6f2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b6f6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b6fa:	58 0a       	cp.w	r10,0
8000b6fc:	f6 08 17 00 	moveq	r8,r11
8000b700:	f9 bc 00 10 	moveq	r12,16
8000b704:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b708:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b70c:	58 0b       	cp.w	r11,0
8000b70e:	f7 bc 00 f8 	subeq	r12,-8
8000b712:	f4 08 17 00 	moveq	r8,r10
8000b716:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b71a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b71e:	58 0b       	cp.w	r11,0
8000b720:	f7 bc 00 fc 	subeq	r12,-4
8000b724:	f4 08 17 00 	moveq	r8,r10
8000b728:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b72c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b730:	58 0b       	cp.w	r11,0
8000b732:	f7 bc 00 fe 	subeq	r12,-2
8000b736:	f4 08 17 00 	moveq	r8,r10
8000b73a:	ed b8 00 00 	bld	r8,0x0
8000b73e:	c0 60       	breq	8000b74a <__lo0bits+0x8a>
8000b740:	a1 98       	lsr	r8,0x1
8000b742:	c0 31       	brne	8000b748 <__lo0bits+0x88>
8000b744:	32 0c       	mov	r12,32
8000b746:	5e fc       	retal	r12
8000b748:	2f fc       	sub	r12,-1
8000b74a:	93 08       	st.w	r9[0x0],r8
8000b74c:	5e fc       	retal	r12

8000b74e <__mcmp>:
8000b74e:	d4 01       	pushm	lr
8000b750:	18 98       	mov	r8,r12
8000b752:	76 49       	ld.w	r9,r11[0x10]
8000b754:	78 4c       	ld.w	r12,r12[0x10]
8000b756:	12 1c       	sub	r12,r9
8000b758:	c1 31       	brne	8000b77e <__mcmp+0x30>
8000b75a:	2f b9       	sub	r9,-5
8000b75c:	a3 69       	lsl	r9,0x2
8000b75e:	12 0b       	add	r11,r9
8000b760:	f0 09 00 09 	add	r9,r8,r9
8000b764:	2e c8       	sub	r8,-20
8000b766:	13 4e       	ld.w	lr,--r9
8000b768:	17 4a       	ld.w	r10,--r11
8000b76a:	14 3e       	cp.w	lr,r10
8000b76c:	c0 60       	breq	8000b778 <__mcmp+0x2a>
8000b76e:	f9 bc 03 ff 	movlo	r12,-1
8000b772:	f9 bc 02 01 	movhs	r12,1
8000b776:	d8 02       	popm	pc
8000b778:	10 39       	cp.w	r9,r8
8000b77a:	fe 9b ff f6 	brhi	8000b766 <__mcmp+0x18>
8000b77e:	d8 02       	popm	pc

8000b780 <_Bfree>:
8000b780:	d4 21       	pushm	r4-r7,lr
8000b782:	18 97       	mov	r7,r12
8000b784:	16 95       	mov	r5,r11
8000b786:	78 96       	ld.w	r6,r12[0x24]
8000b788:	58 06       	cp.w	r6,0
8000b78a:	c0 91       	brne	8000b79c <_Bfree+0x1c>
8000b78c:	31 0c       	mov	r12,16
8000b78e:	fe b0 de 49 	rcall	80007420 <malloc>
8000b792:	99 36       	st.w	r12[0xc],r6
8000b794:	8f 9c       	st.w	r7[0x24],r12
8000b796:	99 16       	st.w	r12[0x4],r6
8000b798:	99 26       	st.w	r12[0x8],r6
8000b79a:	99 06       	st.w	r12[0x0],r6
8000b79c:	58 05       	cp.w	r5,0
8000b79e:	c0 90       	breq	8000b7b0 <_Bfree+0x30>
8000b7a0:	6a 19       	ld.w	r9,r5[0x4]
8000b7a2:	6e 98       	ld.w	r8,r7[0x24]
8000b7a4:	70 38       	ld.w	r8,r8[0xc]
8000b7a6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b7aa:	8b 0a       	st.w	r5[0x0],r10
8000b7ac:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b7b0:	d8 22       	popm	r4-r7,pc
8000b7b2:	d7 03       	nop

8000b7b4 <_Balloc>:
8000b7b4:	d4 21       	pushm	r4-r7,lr
8000b7b6:	18 97       	mov	r7,r12
8000b7b8:	16 96       	mov	r6,r11
8000b7ba:	78 95       	ld.w	r5,r12[0x24]
8000b7bc:	58 05       	cp.w	r5,0
8000b7be:	c0 91       	brne	8000b7d0 <_Balloc+0x1c>
8000b7c0:	31 0c       	mov	r12,16
8000b7c2:	fe b0 de 2f 	rcall	80007420 <malloc>
8000b7c6:	99 35       	st.w	r12[0xc],r5
8000b7c8:	8f 9c       	st.w	r7[0x24],r12
8000b7ca:	99 15       	st.w	r12[0x4],r5
8000b7cc:	99 25       	st.w	r12[0x8],r5
8000b7ce:	99 05       	st.w	r12[0x0],r5
8000b7d0:	6e 95       	ld.w	r5,r7[0x24]
8000b7d2:	6a 38       	ld.w	r8,r5[0xc]
8000b7d4:	58 08       	cp.w	r8,0
8000b7d6:	c0 b1       	brne	8000b7ec <_Balloc+0x38>
8000b7d8:	31 0a       	mov	r10,16
8000b7da:	30 4b       	mov	r11,4
8000b7dc:	0e 9c       	mov	r12,r7
8000b7de:	e0 a0 02 a7 	rcall	8000bd2c <_calloc_r>
8000b7e2:	8b 3c       	st.w	r5[0xc],r12
8000b7e4:	6e 98       	ld.w	r8,r7[0x24]
8000b7e6:	70 3c       	ld.w	r12,r8[0xc]
8000b7e8:	58 0c       	cp.w	r12,0
8000b7ea:	c1 b0       	breq	8000b820 <_Balloc+0x6c>
8000b7ec:	6e 98       	ld.w	r8,r7[0x24]
8000b7ee:	70 38       	ld.w	r8,r8[0xc]
8000b7f0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b7f4:	70 0c       	ld.w	r12,r8[0x0]
8000b7f6:	58 0c       	cp.w	r12,0
8000b7f8:	c0 40       	breq	8000b800 <_Balloc+0x4c>
8000b7fa:	78 09       	ld.w	r9,r12[0x0]
8000b7fc:	91 09       	st.w	r8[0x0],r9
8000b7fe:	c0 e8       	rjmp	8000b81a <_Balloc+0x66>
8000b800:	0e 9c       	mov	r12,r7
8000b802:	30 17       	mov	r7,1
8000b804:	0e 9b       	mov	r11,r7
8000b806:	ee 06 09 47 	lsl	r7,r7,r6
8000b80a:	ee ca ff fb 	sub	r10,r7,-5
8000b80e:	a3 6a       	lsl	r10,0x2
8000b810:	e0 a0 02 8e 	rcall	8000bd2c <_calloc_r>
8000b814:	c0 60       	breq	8000b820 <_Balloc+0x6c>
8000b816:	99 16       	st.w	r12[0x4],r6
8000b818:	99 27       	st.w	r12[0x8],r7
8000b81a:	30 08       	mov	r8,0
8000b81c:	99 38       	st.w	r12[0xc],r8
8000b81e:	99 48       	st.w	r12[0x10],r8
8000b820:	d8 22       	popm	r4-r7,pc
8000b822:	d7 03       	nop

8000b824 <__d2b>:
8000b824:	d4 31       	pushm	r0-r7,lr
8000b826:	20 2d       	sub	sp,8
8000b828:	16 93       	mov	r3,r11
8000b82a:	12 96       	mov	r6,r9
8000b82c:	10 95       	mov	r5,r8
8000b82e:	14 92       	mov	r2,r10
8000b830:	30 1b       	mov	r11,1
8000b832:	cc 1f       	rcall	8000b7b4 <_Balloc>
8000b834:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b838:	50 09       	stdsp	sp[0x0],r9
8000b83a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b83e:	b5 a9       	sbr	r9,0x14
8000b840:	f0 01 16 14 	lsr	r1,r8,0x14
8000b844:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b848:	18 94       	mov	r4,r12
8000b84a:	58 02       	cp.w	r2,0
8000b84c:	c1 d0       	breq	8000b886 <__d2b+0x62>
8000b84e:	fa cc ff f8 	sub	r12,sp,-8
8000b852:	18 d2       	st.w	--r12,r2
8000b854:	c3 6f       	rcall	8000b6c0 <__lo0bits>
8000b856:	40 18       	lddsp	r8,sp[0x4]
8000b858:	c0 d0       	breq	8000b872 <__d2b+0x4e>
8000b85a:	40 09       	lddsp	r9,sp[0x0]
8000b85c:	f8 0a 11 20 	rsub	r10,r12,32
8000b860:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b864:	f5 e8 10 08 	or	r8,r10,r8
8000b868:	89 58       	st.w	r4[0x14],r8
8000b86a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b86e:	50 09       	stdsp	sp[0x0],r9
8000b870:	c0 28       	rjmp	8000b874 <__d2b+0x50>
8000b872:	89 58       	st.w	r4[0x14],r8
8000b874:	40 08       	lddsp	r8,sp[0x0]
8000b876:	58 08       	cp.w	r8,0
8000b878:	f9 b3 01 02 	movne	r3,2
8000b87c:	f9 b3 00 01 	moveq	r3,1
8000b880:	89 68       	st.w	r4[0x18],r8
8000b882:	89 43       	st.w	r4[0x10],r3
8000b884:	c0 88       	rjmp	8000b894 <__d2b+0x70>
8000b886:	1a 9c       	mov	r12,sp
8000b888:	c1 cf       	rcall	8000b6c0 <__lo0bits>
8000b88a:	30 13       	mov	r3,1
8000b88c:	40 08       	lddsp	r8,sp[0x0]
8000b88e:	2e 0c       	sub	r12,-32
8000b890:	89 43       	st.w	r4[0x10],r3
8000b892:	89 58       	st.w	r4[0x14],r8
8000b894:	58 01       	cp.w	r1,0
8000b896:	c0 90       	breq	8000b8a8 <__d2b+0x84>
8000b898:	e2 c1 04 33 	sub	r1,r1,1075
8000b89c:	18 01       	add	r1,r12
8000b89e:	8d 01       	st.w	r6[0x0],r1
8000b8a0:	f8 0c 11 35 	rsub	r12,r12,53
8000b8a4:	8b 0c       	st.w	r5[0x0],r12
8000b8a6:	c0 c8       	rjmp	8000b8be <__d2b+0x9a>
8000b8a8:	e6 c8 ff fc 	sub	r8,r3,-4
8000b8ac:	f8 cc 04 32 	sub	r12,r12,1074
8000b8b0:	a5 73       	lsl	r3,0x5
8000b8b2:	8d 0c       	st.w	r6[0x0],r12
8000b8b4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b8b8:	cd 4e       	rcall	8000b660 <__hi0bits>
8000b8ba:	18 13       	sub	r3,r12
8000b8bc:	8b 03       	st.w	r5[0x0],r3
8000b8be:	08 9c       	mov	r12,r4
8000b8c0:	2f ed       	sub	sp,-8
8000b8c2:	d8 32       	popm	r0-r7,pc

8000b8c4 <__mdiff>:
8000b8c4:	d4 31       	pushm	r0-r7,lr
8000b8c6:	74 48       	ld.w	r8,r10[0x10]
8000b8c8:	76 45       	ld.w	r5,r11[0x10]
8000b8ca:	16 97       	mov	r7,r11
8000b8cc:	14 96       	mov	r6,r10
8000b8ce:	10 15       	sub	r5,r8
8000b8d0:	c1 31       	brne	8000b8f6 <__mdiff+0x32>
8000b8d2:	2f b8       	sub	r8,-5
8000b8d4:	ee ce ff ec 	sub	lr,r7,-20
8000b8d8:	a3 68       	lsl	r8,0x2
8000b8da:	f4 08 00 0b 	add	r11,r10,r8
8000b8de:	ee 08 00 08 	add	r8,r7,r8
8000b8e2:	11 4a       	ld.w	r10,--r8
8000b8e4:	17 49       	ld.w	r9,--r11
8000b8e6:	12 3a       	cp.w	r10,r9
8000b8e8:	c0 30       	breq	8000b8ee <__mdiff+0x2a>
8000b8ea:	c0 e2       	brcc	8000b906 <__mdiff+0x42>
8000b8ec:	c0 78       	rjmp	8000b8fa <__mdiff+0x36>
8000b8ee:	1c 38       	cp.w	r8,lr
8000b8f0:	fe 9b ff f9 	brhi	8000b8e2 <__mdiff+0x1e>
8000b8f4:	c4 98       	rjmp	8000b986 <__mdiff+0xc2>
8000b8f6:	58 05       	cp.w	r5,0
8000b8f8:	c0 64       	brge	8000b904 <__mdiff+0x40>
8000b8fa:	0e 98       	mov	r8,r7
8000b8fc:	30 15       	mov	r5,1
8000b8fe:	0c 97       	mov	r7,r6
8000b900:	10 96       	mov	r6,r8
8000b902:	c0 28       	rjmp	8000b906 <__mdiff+0x42>
8000b904:	30 05       	mov	r5,0
8000b906:	6e 1b       	ld.w	r11,r7[0x4]
8000b908:	c5 6f       	rcall	8000b7b4 <_Balloc>
8000b90a:	6e 49       	ld.w	r9,r7[0x10]
8000b90c:	6c 44       	ld.w	r4,r6[0x10]
8000b90e:	99 35       	st.w	r12[0xc],r5
8000b910:	2f b4       	sub	r4,-5
8000b912:	f2 c5 ff fb 	sub	r5,r9,-5
8000b916:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b91a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b91e:	2e c6       	sub	r6,-20
8000b920:	2e c7       	sub	r7,-20
8000b922:	f8 c8 ff ec 	sub	r8,r12,-20
8000b926:	30 0a       	mov	r10,0
8000b928:	0f 0e       	ld.w	lr,r7++
8000b92a:	0d 0b       	ld.w	r11,r6++
8000b92c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b930:	f6 03 16 10 	lsr	r3,r11,0x10
8000b934:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b938:	e4 03 01 03 	sub	r3,r2,r3
8000b93c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b940:	fc 0b 01 0b 	sub	r11,lr,r11
8000b944:	f6 0a 00 0a 	add	r10,r11,r10
8000b948:	b0 1a       	st.h	r8[0x2],r10
8000b94a:	b1 4a       	asr	r10,0x10
8000b94c:	e6 0a 00 0a 	add	r10,r3,r10
8000b950:	b0 0a       	st.h	r8[0x0],r10
8000b952:	2f c8       	sub	r8,-4
8000b954:	b1 4a       	asr	r10,0x10
8000b956:	08 36       	cp.w	r6,r4
8000b958:	ce 83       	brcs	8000b928 <__mdiff+0x64>
8000b95a:	c0 d8       	rjmp	8000b974 <__mdiff+0xb0>
8000b95c:	0f 0b       	ld.w	r11,r7++
8000b95e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b962:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b966:	16 0a       	add	r10,r11
8000b968:	b0 1a       	st.h	r8[0x2],r10
8000b96a:	b1 4a       	asr	r10,0x10
8000b96c:	1c 0a       	add	r10,lr
8000b96e:	b0 0a       	st.h	r8[0x0],r10
8000b970:	2f c8       	sub	r8,-4
8000b972:	b1 4a       	asr	r10,0x10
8000b974:	0a 37       	cp.w	r7,r5
8000b976:	cf 33       	brcs	8000b95c <__mdiff+0x98>
8000b978:	c0 28       	rjmp	8000b97c <__mdiff+0xb8>
8000b97a:	20 19       	sub	r9,1
8000b97c:	11 4a       	ld.w	r10,--r8
8000b97e:	58 0a       	cp.w	r10,0
8000b980:	cf d0       	breq	8000b97a <__mdiff+0xb6>
8000b982:	99 49       	st.w	r12[0x10],r9
8000b984:	d8 32       	popm	r0-r7,pc
8000b986:	30 0b       	mov	r11,0
8000b988:	c1 6f       	rcall	8000b7b4 <_Balloc>
8000b98a:	30 18       	mov	r8,1
8000b98c:	99 48       	st.w	r12[0x10],r8
8000b98e:	30 08       	mov	r8,0
8000b990:	99 58       	st.w	r12[0x14],r8
8000b992:	d8 32       	popm	r0-r7,pc

8000b994 <__lshift>:
8000b994:	d4 31       	pushm	r0-r7,lr
8000b996:	16 97       	mov	r7,r11
8000b998:	76 46       	ld.w	r6,r11[0x10]
8000b99a:	f4 02 14 05 	asr	r2,r10,0x5
8000b99e:	2f f6       	sub	r6,-1
8000b9a0:	14 93       	mov	r3,r10
8000b9a2:	18 94       	mov	r4,r12
8000b9a4:	04 06       	add	r6,r2
8000b9a6:	76 1b       	ld.w	r11,r11[0x4]
8000b9a8:	6e 28       	ld.w	r8,r7[0x8]
8000b9aa:	c0 38       	rjmp	8000b9b0 <__lshift+0x1c>
8000b9ac:	2f fb       	sub	r11,-1
8000b9ae:	a1 78       	lsl	r8,0x1
8000b9b0:	10 36       	cp.w	r6,r8
8000b9b2:	fe 99 ff fd 	brgt	8000b9ac <__lshift+0x18>
8000b9b6:	08 9c       	mov	r12,r4
8000b9b8:	cf ee       	rcall	8000b7b4 <_Balloc>
8000b9ba:	30 09       	mov	r9,0
8000b9bc:	18 95       	mov	r5,r12
8000b9be:	f8 c8 ff ec 	sub	r8,r12,-20
8000b9c2:	12 9a       	mov	r10,r9
8000b9c4:	c0 38       	rjmp	8000b9ca <__lshift+0x36>
8000b9c6:	10 aa       	st.w	r8++,r10
8000b9c8:	2f f9       	sub	r9,-1
8000b9ca:	04 39       	cp.w	r9,r2
8000b9cc:	cf d5       	brlt	8000b9c6 <__lshift+0x32>
8000b9ce:	6e 4b       	ld.w	r11,r7[0x10]
8000b9d0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b9d4:	2f bb       	sub	r11,-5
8000b9d6:	ee c9 ff ec 	sub	r9,r7,-20
8000b9da:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b9de:	58 03       	cp.w	r3,0
8000b9e0:	c1 30       	breq	8000ba06 <__lshift+0x72>
8000b9e2:	e6 0c 11 20 	rsub	r12,r3,32
8000b9e6:	30 0a       	mov	r10,0
8000b9e8:	72 02       	ld.w	r2,r9[0x0]
8000b9ea:	e4 03 09 42 	lsl	r2,r2,r3
8000b9ee:	04 4a       	or	r10,r2
8000b9f0:	10 aa       	st.w	r8++,r10
8000b9f2:	13 0a       	ld.w	r10,r9++
8000b9f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b9f8:	16 39       	cp.w	r9,r11
8000b9fa:	cf 73       	brcs	8000b9e8 <__lshift+0x54>
8000b9fc:	91 0a       	st.w	r8[0x0],r10
8000b9fe:	58 0a       	cp.w	r10,0
8000ba00:	c0 70       	breq	8000ba0e <__lshift+0x7a>
8000ba02:	2f f6       	sub	r6,-1
8000ba04:	c0 58       	rjmp	8000ba0e <__lshift+0x7a>
8000ba06:	13 0a       	ld.w	r10,r9++
8000ba08:	10 aa       	st.w	r8++,r10
8000ba0a:	16 39       	cp.w	r9,r11
8000ba0c:	cf d3       	brcs	8000ba06 <__lshift+0x72>
8000ba0e:	08 9c       	mov	r12,r4
8000ba10:	20 16       	sub	r6,1
8000ba12:	0e 9b       	mov	r11,r7
8000ba14:	8b 46       	st.w	r5[0x10],r6
8000ba16:	cb 5e       	rcall	8000b780 <_Bfree>
8000ba18:	0a 9c       	mov	r12,r5
8000ba1a:	d8 32       	popm	r0-r7,pc

8000ba1c <__multiply>:
8000ba1c:	d4 31       	pushm	r0-r7,lr
8000ba1e:	20 2d       	sub	sp,8
8000ba20:	76 49       	ld.w	r9,r11[0x10]
8000ba22:	74 48       	ld.w	r8,r10[0x10]
8000ba24:	16 96       	mov	r6,r11
8000ba26:	14 95       	mov	r5,r10
8000ba28:	10 39       	cp.w	r9,r8
8000ba2a:	ec 08 17 50 	movlt	r8,r6
8000ba2e:	ea 06 17 50 	movlt	r6,r5
8000ba32:	f0 05 17 50 	movlt	r5,r8
8000ba36:	6c 28       	ld.w	r8,r6[0x8]
8000ba38:	76 43       	ld.w	r3,r11[0x10]
8000ba3a:	74 42       	ld.w	r2,r10[0x10]
8000ba3c:	76 1b       	ld.w	r11,r11[0x4]
8000ba3e:	e4 03 00 07 	add	r7,r2,r3
8000ba42:	10 37       	cp.w	r7,r8
8000ba44:	f7 bb 09 ff 	subgt	r11,-1
8000ba48:	cb 6e       	rcall	8000b7b4 <_Balloc>
8000ba4a:	ee c4 ff fb 	sub	r4,r7,-5
8000ba4e:	f8 c9 ff ec 	sub	r9,r12,-20
8000ba52:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ba56:	30 0a       	mov	r10,0
8000ba58:	12 98       	mov	r8,r9
8000ba5a:	c0 28       	rjmp	8000ba5e <__multiply+0x42>
8000ba5c:	10 aa       	st.w	r8++,r10
8000ba5e:	08 38       	cp.w	r8,r4
8000ba60:	cf e3       	brcs	8000ba5c <__multiply+0x40>
8000ba62:	2f b3       	sub	r3,-5
8000ba64:	2f b2       	sub	r2,-5
8000ba66:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ba6a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ba6e:	ec cb ff ec 	sub	r11,r6,-20
8000ba72:	50 12       	stdsp	sp[0x4],r2
8000ba74:	ea ca ff ec 	sub	r10,r5,-20
8000ba78:	c4 48       	rjmp	8000bb00 <__multiply+0xe4>
8000ba7a:	94 95       	ld.uh	r5,r10[0x2]
8000ba7c:	58 05       	cp.w	r5,0
8000ba7e:	c2 00       	breq	8000babe <__multiply+0xa2>
8000ba80:	12 98       	mov	r8,r9
8000ba82:	16 96       	mov	r6,r11
8000ba84:	30 0e       	mov	lr,0
8000ba86:	50 09       	stdsp	sp[0x0],r9
8000ba88:	0d 02       	ld.w	r2,r6++
8000ba8a:	e4 00 16 10 	lsr	r0,r2,0x10
8000ba8e:	70 01       	ld.w	r1,r8[0x0]
8000ba90:	70 09       	ld.w	r9,r8[0x0]
8000ba92:	b1 81       	lsr	r1,0x10
8000ba94:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ba98:	e0 05 03 41 	mac	r1,r0,r5
8000ba9c:	ab 32       	mul	r2,r5
8000ba9e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000baa2:	00 02       	add	r2,r0
8000baa4:	e4 0e 00 0e 	add	lr,r2,lr
8000baa8:	b0 1e       	st.h	r8[0x2],lr
8000baaa:	b1 8e       	lsr	lr,0x10
8000baac:	1c 01       	add	r1,lr
8000baae:	b0 01       	st.h	r8[0x0],r1
8000bab0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bab4:	2f c8       	sub	r8,-4
8000bab6:	06 36       	cp.w	r6,r3
8000bab8:	ce 83       	brcs	8000ba88 <__multiply+0x6c>
8000baba:	40 09       	lddsp	r9,sp[0x0]
8000babc:	91 0e       	st.w	r8[0x0],lr
8000babe:	94 86       	ld.uh	r6,r10[0x0]
8000bac0:	58 06       	cp.w	r6,0
8000bac2:	c1 d0       	breq	8000bafc <__multiply+0xe0>
8000bac4:	72 02       	ld.w	r2,r9[0x0]
8000bac6:	12 98       	mov	r8,r9
8000bac8:	16 9e       	mov	lr,r11
8000baca:	30 05       	mov	r5,0
8000bacc:	b0 12       	st.h	r8[0x2],r2
8000bace:	1d 01       	ld.w	r1,lr++
8000bad0:	90 82       	ld.uh	r2,r8[0x0]
8000bad2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bad6:	ad 30       	mul	r0,r6
8000bad8:	e0 02 00 02 	add	r2,r0,r2
8000badc:	e4 05 00 05 	add	r5,r2,r5
8000bae0:	b0 05       	st.h	r8[0x0],r5
8000bae2:	b1 85       	lsr	r5,0x10
8000bae4:	b1 81       	lsr	r1,0x10
8000bae6:	2f c8       	sub	r8,-4
8000bae8:	ad 31       	mul	r1,r6
8000baea:	90 92       	ld.uh	r2,r8[0x2]
8000baec:	e2 02 00 02 	add	r2,r1,r2
8000baf0:	0a 02       	add	r2,r5
8000baf2:	e4 05 16 10 	lsr	r5,r2,0x10
8000baf6:	06 3e       	cp.w	lr,r3
8000baf8:	ce a3       	brcs	8000bacc <__multiply+0xb0>
8000bafa:	91 02       	st.w	r8[0x0],r2
8000bafc:	2f ca       	sub	r10,-4
8000bafe:	2f c9       	sub	r9,-4
8000bb00:	40 18       	lddsp	r8,sp[0x4]
8000bb02:	10 3a       	cp.w	r10,r8
8000bb04:	cb b3       	brcs	8000ba7a <__multiply+0x5e>
8000bb06:	c0 28       	rjmp	8000bb0a <__multiply+0xee>
8000bb08:	20 17       	sub	r7,1
8000bb0a:	58 07       	cp.w	r7,0
8000bb0c:	e0 8a 00 05 	brle	8000bb16 <__multiply+0xfa>
8000bb10:	09 48       	ld.w	r8,--r4
8000bb12:	58 08       	cp.w	r8,0
8000bb14:	cf a0       	breq	8000bb08 <__multiply+0xec>
8000bb16:	99 47       	st.w	r12[0x10],r7
8000bb18:	2f ed       	sub	sp,-8
8000bb1a:	d8 32       	popm	r0-r7,pc

8000bb1c <__i2b>:
8000bb1c:	d4 21       	pushm	r4-r7,lr
8000bb1e:	16 97       	mov	r7,r11
8000bb20:	30 1b       	mov	r11,1
8000bb22:	c4 9e       	rcall	8000b7b4 <_Balloc>
8000bb24:	30 19       	mov	r9,1
8000bb26:	99 57       	st.w	r12[0x14],r7
8000bb28:	99 49       	st.w	r12[0x10],r9
8000bb2a:	d8 22       	popm	r4-r7,pc

8000bb2c <__multadd>:
8000bb2c:	d4 31       	pushm	r0-r7,lr
8000bb2e:	30 08       	mov	r8,0
8000bb30:	12 95       	mov	r5,r9
8000bb32:	16 97       	mov	r7,r11
8000bb34:	18 96       	mov	r6,r12
8000bb36:	76 44       	ld.w	r4,r11[0x10]
8000bb38:	f6 c9 ff ec 	sub	r9,r11,-20
8000bb3c:	72 0b       	ld.w	r11,r9[0x0]
8000bb3e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bb42:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bb46:	f4 0c 02 4c 	mul	r12,r10,r12
8000bb4a:	f4 0b 03 45 	mac	r5,r10,r11
8000bb4e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bb52:	b1 85       	lsr	r5,0x10
8000bb54:	18 05       	add	r5,r12
8000bb56:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bb5a:	f8 0b 00 0b 	add	r11,r12,r11
8000bb5e:	12 ab       	st.w	r9++,r11
8000bb60:	2f f8       	sub	r8,-1
8000bb62:	b1 85       	lsr	r5,0x10
8000bb64:	08 38       	cp.w	r8,r4
8000bb66:	ce b5       	brlt	8000bb3c <__multadd+0x10>
8000bb68:	58 05       	cp.w	r5,0
8000bb6a:	c1 c0       	breq	8000bba2 <__multadd+0x76>
8000bb6c:	6e 28       	ld.w	r8,r7[0x8]
8000bb6e:	10 34       	cp.w	r4,r8
8000bb70:	c1 35       	brlt	8000bb96 <__multadd+0x6a>
8000bb72:	6e 1b       	ld.w	r11,r7[0x4]
8000bb74:	0c 9c       	mov	r12,r6
8000bb76:	2f fb       	sub	r11,-1
8000bb78:	c1 ee       	rcall	8000b7b4 <_Balloc>
8000bb7a:	6e 4a       	ld.w	r10,r7[0x10]
8000bb7c:	ee cb ff f4 	sub	r11,r7,-12
8000bb80:	18 93       	mov	r3,r12
8000bb82:	2f ea       	sub	r10,-2
8000bb84:	2f 4c       	sub	r12,-12
8000bb86:	a3 6a       	lsl	r10,0x2
8000bb88:	fe b0 de 70 	rcall	80007868 <memcpy>
8000bb8c:	0e 9b       	mov	r11,r7
8000bb8e:	0c 9c       	mov	r12,r6
8000bb90:	fe b0 fd f8 	rcall	8000b780 <_Bfree>
8000bb94:	06 97       	mov	r7,r3
8000bb96:	e8 c8 ff ff 	sub	r8,r4,-1
8000bb9a:	2f b4       	sub	r4,-5
8000bb9c:	8f 48       	st.w	r7[0x10],r8
8000bb9e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bba2:	0e 9c       	mov	r12,r7
8000bba4:	d8 32       	popm	r0-r7,pc
8000bba6:	d7 03       	nop

8000bba8 <__pow5mult>:
8000bba8:	d4 31       	pushm	r0-r7,lr
8000bbaa:	14 96       	mov	r6,r10
8000bbac:	18 97       	mov	r7,r12
8000bbae:	16 94       	mov	r4,r11
8000bbb0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bbb4:	c0 90       	breq	8000bbc6 <__pow5mult+0x1e>
8000bbb6:	20 18       	sub	r8,1
8000bbb8:	fe c9 d9 fc 	sub	r9,pc,-9732
8000bbbc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bbc0:	30 09       	mov	r9,0
8000bbc2:	cb 5f       	rcall	8000bb2c <__multadd>
8000bbc4:	18 94       	mov	r4,r12
8000bbc6:	a3 46       	asr	r6,0x2
8000bbc8:	c3 40       	breq	8000bc30 <__pow5mult+0x88>
8000bbca:	6e 95       	ld.w	r5,r7[0x24]
8000bbcc:	58 05       	cp.w	r5,0
8000bbce:	c0 91       	brne	8000bbe0 <__pow5mult+0x38>
8000bbd0:	31 0c       	mov	r12,16
8000bbd2:	fe b0 dc 27 	rcall	80007420 <malloc>
8000bbd6:	99 35       	st.w	r12[0xc],r5
8000bbd8:	8f 9c       	st.w	r7[0x24],r12
8000bbda:	99 15       	st.w	r12[0x4],r5
8000bbdc:	99 25       	st.w	r12[0x8],r5
8000bbde:	99 05       	st.w	r12[0x0],r5
8000bbe0:	6e 93       	ld.w	r3,r7[0x24]
8000bbe2:	66 25       	ld.w	r5,r3[0x8]
8000bbe4:	58 05       	cp.w	r5,0
8000bbe6:	c0 c1       	brne	8000bbfe <__pow5mult+0x56>
8000bbe8:	e0 6b 02 71 	mov	r11,625
8000bbec:	0e 9c       	mov	r12,r7
8000bbee:	c9 7f       	rcall	8000bb1c <__i2b>
8000bbf0:	87 2c       	st.w	r3[0x8],r12
8000bbf2:	30 08       	mov	r8,0
8000bbf4:	18 95       	mov	r5,r12
8000bbf6:	99 08       	st.w	r12[0x0],r8
8000bbf8:	c0 38       	rjmp	8000bbfe <__pow5mult+0x56>
8000bbfa:	06 9c       	mov	r12,r3
8000bbfc:	18 95       	mov	r5,r12
8000bbfe:	ed b6 00 00 	bld	r6,0x0
8000bc02:	c0 b1       	brne	8000bc18 <__pow5mult+0x70>
8000bc04:	08 9b       	mov	r11,r4
8000bc06:	0a 9a       	mov	r10,r5
8000bc08:	0e 9c       	mov	r12,r7
8000bc0a:	c0 9f       	rcall	8000ba1c <__multiply>
8000bc0c:	08 9b       	mov	r11,r4
8000bc0e:	18 93       	mov	r3,r12
8000bc10:	0e 9c       	mov	r12,r7
8000bc12:	06 94       	mov	r4,r3
8000bc14:	fe b0 fd b6 	rcall	8000b780 <_Bfree>
8000bc18:	a1 56       	asr	r6,0x1
8000bc1a:	c0 b0       	breq	8000bc30 <__pow5mult+0x88>
8000bc1c:	6a 03       	ld.w	r3,r5[0x0]
8000bc1e:	58 03       	cp.w	r3,0
8000bc20:	ce d1       	brne	8000bbfa <__pow5mult+0x52>
8000bc22:	0a 9a       	mov	r10,r5
8000bc24:	0a 9b       	mov	r11,r5
8000bc26:	0e 9c       	mov	r12,r7
8000bc28:	cf ae       	rcall	8000ba1c <__multiply>
8000bc2a:	8b 0c       	st.w	r5[0x0],r12
8000bc2c:	99 03       	st.w	r12[0x0],r3
8000bc2e:	ce 7b       	rjmp	8000bbfc <__pow5mult+0x54>
8000bc30:	08 9c       	mov	r12,r4
8000bc32:	d8 32       	popm	r0-r7,pc

8000bc34 <__isinfd>:
8000bc34:	14 98       	mov	r8,r10
8000bc36:	fc 19 7f f0 	movh	r9,0x7ff0
8000bc3a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc3e:	f0 0b 11 00 	rsub	r11,r8,0
8000bc42:	f7 e8 10 08 	or	r8,r11,r8
8000bc46:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bc4a:	f2 08 01 08 	sub	r8,r9,r8
8000bc4e:	f0 0c 11 00 	rsub	r12,r8,0
8000bc52:	f9 e8 10 08 	or	r8,r12,r8
8000bc56:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bc5a:	2f fc       	sub	r12,-1
8000bc5c:	5e fc       	retal	r12

8000bc5e <__isnand>:
8000bc5e:	14 98       	mov	r8,r10
8000bc60:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc64:	f0 0c 11 00 	rsub	r12,r8,0
8000bc68:	10 4c       	or	r12,r8
8000bc6a:	fc 18 7f f0 	movh	r8,0x7ff0
8000bc6e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bc72:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc76:	bf 9c       	lsr	r12,0x1f
8000bc78:	5e fc       	retal	r12
8000bc7a:	d7 03       	nop

8000bc7c <__sclose>:
8000bc7c:	d4 01       	pushm	lr
8000bc7e:	96 7b       	ld.sh	r11,r11[0xe]
8000bc80:	c8 2c       	rcall	8000bd84 <_close_r>
8000bc82:	d8 02       	popm	pc

8000bc84 <__sseek>:
8000bc84:	d4 21       	pushm	r4-r7,lr
8000bc86:	16 97       	mov	r7,r11
8000bc88:	96 7b       	ld.sh	r11,r11[0xe]
8000bc8a:	c0 3d       	rcall	8000be90 <_lseek_r>
8000bc8c:	8e 68       	ld.sh	r8,r7[0xc]
8000bc8e:	10 99       	mov	r9,r8
8000bc90:	ad c8       	cbr	r8,0xc
8000bc92:	ad a9       	sbr	r9,0xc
8000bc94:	5b fc       	cp.w	r12,-1
8000bc96:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bc9a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bc9e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bca2:	d8 22       	popm	r4-r7,pc

8000bca4 <__swrite>:
8000bca4:	d4 21       	pushm	r4-r7,lr
8000bca6:	96 68       	ld.sh	r8,r11[0xc]
8000bca8:	16 97       	mov	r7,r11
8000bcaa:	14 95       	mov	r5,r10
8000bcac:	12 94       	mov	r4,r9
8000bcae:	e2 18 01 00 	andl	r8,0x100,COH
8000bcb2:	18 96       	mov	r6,r12
8000bcb4:	c0 50       	breq	8000bcbe <__swrite+0x1a>
8000bcb6:	30 29       	mov	r9,2
8000bcb8:	30 0a       	mov	r10,0
8000bcba:	96 7b       	ld.sh	r11,r11[0xe]
8000bcbc:	ce ac       	rcall	8000be90 <_lseek_r>
8000bcbe:	8e 68       	ld.sh	r8,r7[0xc]
8000bcc0:	ad c8       	cbr	r8,0xc
8000bcc2:	08 99       	mov	r9,r4
8000bcc4:	0a 9a       	mov	r10,r5
8000bcc6:	8e 7b       	ld.sh	r11,r7[0xe]
8000bcc8:	0c 9c       	mov	r12,r6
8000bcca:	ae 68       	st.h	r7[0xc],r8
8000bccc:	c1 cc       	rcall	8000bd04 <_write_r>
8000bcce:	d8 22       	popm	r4-r7,pc

8000bcd0 <__sread>:
8000bcd0:	d4 21       	pushm	r4-r7,lr
8000bcd2:	16 97       	mov	r7,r11
8000bcd4:	96 7b       	ld.sh	r11,r11[0xe]
8000bcd6:	cf 1c       	rcall	8000beb8 <_read_r>
8000bcd8:	c0 65       	brlt	8000bce4 <__sread+0x14>
8000bcda:	6f 58       	ld.w	r8,r7[0x54]
8000bcdc:	18 08       	add	r8,r12
8000bcde:	ef 48 00 54 	st.w	r7[84],r8
8000bce2:	d8 22       	popm	r4-r7,pc
8000bce4:	8e 68       	ld.sh	r8,r7[0xc]
8000bce6:	ad c8       	cbr	r8,0xc
8000bce8:	ae 68       	st.h	r7[0xc],r8
8000bcea:	d8 22       	popm	r4-r7,pc

8000bcec <strlen>:
8000bcec:	30 09       	mov	r9,0
8000bcee:	18 98       	mov	r8,r12
8000bcf0:	c0 28       	rjmp	8000bcf4 <strlen+0x8>
8000bcf2:	2f f8       	sub	r8,-1
8000bcf4:	11 8a       	ld.ub	r10,r8[0x0]
8000bcf6:	f2 0a 18 00 	cp.b	r10,r9
8000bcfa:	cf c1       	brne	8000bcf2 <strlen+0x6>
8000bcfc:	f0 0c 01 0c 	sub	r12,r8,r12
8000bd00:	5e fc       	retal	r12
8000bd02:	d7 03       	nop

8000bd04 <_write_r>:
8000bd04:	d4 21       	pushm	r4-r7,lr
8000bd06:	16 98       	mov	r8,r11
8000bd08:	18 97       	mov	r7,r12
8000bd0a:	10 9c       	mov	r12,r8
8000bd0c:	30 08       	mov	r8,0
8000bd0e:	14 9b       	mov	r11,r10
8000bd10:	e0 66 53 c8 	mov	r6,21448
8000bd14:	12 9a       	mov	r10,r9
8000bd16:	8d 08       	st.w	r6[0x0],r8
8000bd18:	fe b0 d1 6e 	rcall	80005ff4 <_write>
8000bd1c:	5b fc       	cp.w	r12,-1
8000bd1e:	c0 51       	brne	8000bd28 <_write_r+0x24>
8000bd20:	6c 08       	ld.w	r8,r6[0x0]
8000bd22:	58 08       	cp.w	r8,0
8000bd24:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd28:	d8 22       	popm	r4-r7,pc
8000bd2a:	d7 03       	nop

8000bd2c <_calloc_r>:
8000bd2c:	d4 21       	pushm	r4-r7,lr
8000bd2e:	f4 0b 02 4b 	mul	r11,r10,r11
8000bd32:	fe b0 db 7f 	rcall	80007430 <_malloc_r>
8000bd36:	18 97       	mov	r7,r12
8000bd38:	c2 30       	breq	8000bd7e <_calloc_r+0x52>
8000bd3a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bd3e:	e0 1a ff fc 	andl	r10,0xfffc
8000bd42:	20 4a       	sub	r10,4
8000bd44:	e0 4a 00 24 	cp.w	r10,36
8000bd48:	e0 8b 00 18 	brhi	8000bd78 <_calloc_r+0x4c>
8000bd4c:	18 98       	mov	r8,r12
8000bd4e:	59 3a       	cp.w	r10,19
8000bd50:	e0 88 00 0f 	brls	8000bd6e <_calloc_r+0x42>
8000bd54:	30 09       	mov	r9,0
8000bd56:	10 a9       	st.w	r8++,r9
8000bd58:	10 a9       	st.w	r8++,r9
8000bd5a:	59 ba       	cp.w	r10,27
8000bd5c:	e0 88 00 09 	brls	8000bd6e <_calloc_r+0x42>
8000bd60:	10 a9       	st.w	r8++,r9
8000bd62:	10 a9       	st.w	r8++,r9
8000bd64:	e0 4a 00 24 	cp.w	r10,36
8000bd68:	c0 31       	brne	8000bd6e <_calloc_r+0x42>
8000bd6a:	10 a9       	st.w	r8++,r9
8000bd6c:	10 a9       	st.w	r8++,r9
8000bd6e:	30 09       	mov	r9,0
8000bd70:	10 a9       	st.w	r8++,r9
8000bd72:	91 19       	st.w	r8[0x4],r9
8000bd74:	91 09       	st.w	r8[0x0],r9
8000bd76:	c0 48       	rjmp	8000bd7e <_calloc_r+0x52>
8000bd78:	30 0b       	mov	r11,0
8000bd7a:	fe b0 de 1b 	rcall	800079b0 <memset>
8000bd7e:	0e 9c       	mov	r12,r7
8000bd80:	d8 22       	popm	r4-r7,pc
8000bd82:	d7 03       	nop

8000bd84 <_close_r>:
8000bd84:	d4 21       	pushm	r4-r7,lr
8000bd86:	30 08       	mov	r8,0
8000bd88:	18 97       	mov	r7,r12
8000bd8a:	e0 66 53 c8 	mov	r6,21448
8000bd8e:	16 9c       	mov	r12,r11
8000bd90:	8d 08       	st.w	r6[0x0],r8
8000bd92:	fe b0 df b5 	rcall	80007cfc <_close>
8000bd96:	5b fc       	cp.w	r12,-1
8000bd98:	c0 51       	brne	8000bda2 <_close_r+0x1e>
8000bd9a:	6c 08       	ld.w	r8,r6[0x0]
8000bd9c:	58 08       	cp.w	r8,0
8000bd9e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bda2:	d8 22       	popm	r4-r7,pc

8000bda4 <_fclose_r>:
8000bda4:	d4 21       	pushm	r4-r7,lr
8000bda6:	18 96       	mov	r6,r12
8000bda8:	16 97       	mov	r7,r11
8000bdaa:	58 0b       	cp.w	r11,0
8000bdac:	c0 31       	brne	8000bdb2 <_fclose_r+0xe>
8000bdae:	16 95       	mov	r5,r11
8000bdb0:	c5 38       	rjmp	8000be56 <_fclose_r+0xb2>
8000bdb2:	fe b0 f8 a9 	rcall	8000af04 <__sfp_lock_acquire>
8000bdb6:	58 06       	cp.w	r6,0
8000bdb8:	c0 70       	breq	8000bdc6 <_fclose_r+0x22>
8000bdba:	6c 68       	ld.w	r8,r6[0x18]
8000bdbc:	58 08       	cp.w	r8,0
8000bdbe:	c0 41       	brne	8000bdc6 <_fclose_r+0x22>
8000bdc0:	0c 9c       	mov	r12,r6
8000bdc2:	fe b0 f8 f3 	rcall	8000afa8 <__sinit>
8000bdc6:	fe c8 dc ae 	sub	r8,pc,-9042
8000bdca:	10 37       	cp.w	r7,r8
8000bdcc:	c0 31       	brne	8000bdd2 <_fclose_r+0x2e>
8000bdce:	6c 07       	ld.w	r7,r6[0x0]
8000bdd0:	c0 c8       	rjmp	8000bde8 <_fclose_r+0x44>
8000bdd2:	fe c8 dc 9a 	sub	r8,pc,-9062
8000bdd6:	10 37       	cp.w	r7,r8
8000bdd8:	c0 31       	brne	8000bdde <_fclose_r+0x3a>
8000bdda:	6c 17       	ld.w	r7,r6[0x4]
8000bddc:	c0 68       	rjmp	8000bde8 <_fclose_r+0x44>
8000bdde:	fe c8 dc 86 	sub	r8,pc,-9082
8000bde2:	10 37       	cp.w	r7,r8
8000bde4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bde8:	8e 69       	ld.sh	r9,r7[0xc]
8000bdea:	30 08       	mov	r8,0
8000bdec:	f0 09 19 00 	cp.h	r9,r8
8000bdf0:	c0 51       	brne	8000bdfa <_fclose_r+0x56>
8000bdf2:	fe b0 f8 8a 	rcall	8000af06 <__sfp_lock_release>
8000bdf6:	30 05       	mov	r5,0
8000bdf8:	c2 f8       	rjmp	8000be56 <_fclose_r+0xb2>
8000bdfa:	0e 9b       	mov	r11,r7
8000bdfc:	0c 9c       	mov	r12,r6
8000bdfe:	fe b0 f7 fd 	rcall	8000adf8 <_fflush_r>
8000be02:	6e c8       	ld.w	r8,r7[0x30]
8000be04:	18 95       	mov	r5,r12
8000be06:	58 08       	cp.w	r8,0
8000be08:	c0 60       	breq	8000be14 <_fclose_r+0x70>
8000be0a:	6e 8b       	ld.w	r11,r7[0x20]
8000be0c:	0c 9c       	mov	r12,r6
8000be0e:	5d 18       	icall	r8
8000be10:	f9 b5 05 ff 	movlt	r5,-1
8000be14:	8e 68       	ld.sh	r8,r7[0xc]
8000be16:	ed b8 00 07 	bld	r8,0x7
8000be1a:	c0 51       	brne	8000be24 <_fclose_r+0x80>
8000be1c:	6e 4b       	ld.w	r11,r7[0x10]
8000be1e:	0c 9c       	mov	r12,r6
8000be20:	fe b0 f9 5e 	rcall	8000b0dc <_free_r>
8000be24:	6e db       	ld.w	r11,r7[0x34]
8000be26:	58 0b       	cp.w	r11,0
8000be28:	c0 a0       	breq	8000be3c <_fclose_r+0x98>
8000be2a:	ee c8 ff bc 	sub	r8,r7,-68
8000be2e:	10 3b       	cp.w	r11,r8
8000be30:	c0 40       	breq	8000be38 <_fclose_r+0x94>
8000be32:	0c 9c       	mov	r12,r6
8000be34:	fe b0 f9 54 	rcall	8000b0dc <_free_r>
8000be38:	30 08       	mov	r8,0
8000be3a:	8f d8       	st.w	r7[0x34],r8
8000be3c:	6f 2b       	ld.w	r11,r7[0x48]
8000be3e:	58 0b       	cp.w	r11,0
8000be40:	c0 70       	breq	8000be4e <_fclose_r+0xaa>
8000be42:	0c 9c       	mov	r12,r6
8000be44:	fe b0 f9 4c 	rcall	8000b0dc <_free_r>
8000be48:	30 08       	mov	r8,0
8000be4a:	ef 48 00 48 	st.w	r7[72],r8
8000be4e:	30 08       	mov	r8,0
8000be50:	ae 68       	st.h	r7[0xc],r8
8000be52:	fe b0 f8 5a 	rcall	8000af06 <__sfp_lock_release>
8000be56:	0a 9c       	mov	r12,r5
8000be58:	d8 22       	popm	r4-r7,pc
8000be5a:	d7 03       	nop

8000be5c <fclose>:
8000be5c:	d4 01       	pushm	lr
8000be5e:	e0 68 0a 40 	mov	r8,2624
8000be62:	18 9b       	mov	r11,r12
8000be64:	70 0c       	ld.w	r12,r8[0x0]
8000be66:	c9 ff       	rcall	8000bda4 <_fclose_r>
8000be68:	d8 02       	popm	pc
8000be6a:	d7 03       	nop

8000be6c <_fstat_r>:
8000be6c:	d4 21       	pushm	r4-r7,lr
8000be6e:	16 98       	mov	r8,r11
8000be70:	18 97       	mov	r7,r12
8000be72:	10 9c       	mov	r12,r8
8000be74:	30 08       	mov	r8,0
8000be76:	e0 66 53 c8 	mov	r6,21448
8000be7a:	14 9b       	mov	r11,r10
8000be7c:	8d 08       	st.w	r6[0x0],r8
8000be7e:	fe b0 df 67 	rcall	80007d4c <_fstat>
8000be82:	5b fc       	cp.w	r12,-1
8000be84:	c0 51       	brne	8000be8e <_fstat_r+0x22>
8000be86:	6c 08       	ld.w	r8,r6[0x0]
8000be88:	58 08       	cp.w	r8,0
8000be8a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be8e:	d8 22       	popm	r4-r7,pc

8000be90 <_lseek_r>:
8000be90:	d4 21       	pushm	r4-r7,lr
8000be92:	16 98       	mov	r8,r11
8000be94:	18 97       	mov	r7,r12
8000be96:	10 9c       	mov	r12,r8
8000be98:	30 08       	mov	r8,0
8000be9a:	14 9b       	mov	r11,r10
8000be9c:	e0 66 53 c8 	mov	r6,21448
8000bea0:	12 9a       	mov	r10,r9
8000bea2:	8d 08       	st.w	r6[0x0],r8
8000bea4:	fe b0 df 36 	rcall	80007d10 <_lseek>
8000bea8:	5b fc       	cp.w	r12,-1
8000beaa:	c0 51       	brne	8000beb4 <_lseek_r+0x24>
8000beac:	6c 08       	ld.w	r8,r6[0x0]
8000beae:	58 08       	cp.w	r8,0
8000beb0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000beb4:	d8 22       	popm	r4-r7,pc
8000beb6:	d7 03       	nop

8000beb8 <_read_r>:
8000beb8:	d4 21       	pushm	r4-r7,lr
8000beba:	16 98       	mov	r8,r11
8000bebc:	18 97       	mov	r7,r12
8000bebe:	10 9c       	mov	r12,r8
8000bec0:	30 08       	mov	r8,0
8000bec2:	14 9b       	mov	r11,r10
8000bec4:	e0 66 53 c8 	mov	r6,21448
8000bec8:	12 9a       	mov	r10,r9
8000beca:	8d 08       	st.w	r6[0x0],r8
8000becc:	fe b0 d0 74 	rcall	80005fb4 <_read>
8000bed0:	5b fc       	cp.w	r12,-1
8000bed2:	c0 51       	brne	8000bedc <_read_r+0x24>
8000bed4:	6c 08       	ld.w	r8,r6[0x0]
8000bed6:	58 08       	cp.w	r8,0
8000bed8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bedc:	d8 22       	popm	r4-r7,pc
8000bede:	d7 03       	nop

8000bee0 <__avr32_f64_mul>:
8000bee0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bee4:	e0 80 00 dc 	breq	8000c09c <__avr32_f64_mul_op1_zero>
8000bee8:	d4 21       	pushm	r4-r7,lr
8000beea:	f7 e9 20 0e 	eor	lr,r11,r9
8000beee:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bef2:	30 15       	mov	r5,1
8000bef4:	c4 30       	breq	8000bf7a <__avr32_f64_mul_op1_subnormal>
8000bef6:	ab 6b       	lsl	r11,0xa
8000bef8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000befc:	ab 6a       	lsl	r10,0xa
8000befe:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bf02:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bf06:	c5 c0       	breq	8000bfbe <__avr32_f64_mul_op2_subnormal>
8000bf08:	a1 78       	lsl	r8,0x1
8000bf0a:	5c f9       	rol	r9
8000bf0c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bf10:	e0 47 07 ff 	cp.w	r7,2047
8000bf14:	c7 70       	breq	8000c002 <__avr32_f64_mul_op_nan_or_inf>
8000bf16:	e0 46 07 ff 	cp.w	r6,2047
8000bf1a:	c7 40       	breq	8000c002 <__avr32_f64_mul_op_nan_or_inf>
8000bf1c:	ee 06 00 0c 	add	r12,r7,r6
8000bf20:	e0 2c 03 fe 	sub	r12,1022
8000bf24:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bf28:	f4 09 07 44 	macu.d	r4,r10,r9
8000bf2c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bf30:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bf34:	08 07       	add	r7,r4
8000bf36:	f4 05 00 4a 	adc	r10,r10,r5
8000bf3a:	5c 0b       	acr	r11
8000bf3c:	ed bb 00 14 	bld	r11,0x14
8000bf40:	c0 50       	breq	8000bf4a <__avr32_f64_mul+0x6a>
8000bf42:	a1 77       	lsl	r7,0x1
8000bf44:	5c fa       	rol	r10
8000bf46:	5c fb       	rol	r11
8000bf48:	20 1c       	sub	r12,1
8000bf4a:	58 0c       	cp.w	r12,0
8000bf4c:	e0 8a 00 6f 	brle	8000c02a <__avr32_f64_mul_res_subnormal>
8000bf50:	e0 4c 07 ff 	cp.w	r12,2047
8000bf54:	e0 84 00 9c 	brge	8000c08c <__avr32_f64_mul_res_inf>
8000bf58:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bf5c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bf60:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bf64:	ee 17 80 00 	eorh	r7,0x8000
8000bf68:	f1 b7 04 20 	satu	r7,0x1
8000bf6c:	0e 0a       	add	r10,r7
8000bf6e:	5c 0b       	acr	r11
8000bf70:	ed be 00 1f 	bld	lr,0x1f
8000bf74:	ef bb 00 1f 	bst	r11,0x1f
8000bf78:	d8 22       	popm	r4-r7,pc

8000bf7a <__avr32_f64_mul_op1_subnormal>:
8000bf7a:	e4 1b 00 0f 	andh	r11,0xf
8000bf7e:	f4 0c 12 00 	clz	r12,r10
8000bf82:	f6 06 12 00 	clz	r6,r11
8000bf86:	f7 bc 03 e1 	sublo	r12,-31
8000bf8a:	f8 06 17 30 	movlo	r6,r12
8000bf8e:	f7 b6 02 01 	subhs	r6,1
8000bf92:	e0 46 00 20 	cp.w	r6,32
8000bf96:	c0 d4       	brge	8000bfb0 <__avr32_f64_mul_op1_subnormal+0x36>
8000bf98:	ec 0c 11 20 	rsub	r12,r6,32
8000bf9c:	f6 06 09 4b 	lsl	r11,r11,r6
8000bfa0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bfa4:	18 4b       	or	r11,r12
8000bfa6:	f4 06 09 4a 	lsl	r10,r10,r6
8000bfaa:	20 b6       	sub	r6,11
8000bfac:	0c 17       	sub	r7,r6
8000bfae:	ca ab       	rjmp	8000bf02 <__avr32_f64_mul+0x22>
8000bfb0:	f4 06 09 4b 	lsl	r11,r10,r6
8000bfb4:	c6 40       	breq	8000c07c <__avr32_f64_mul_res_zero>
8000bfb6:	30 0a       	mov	r10,0
8000bfb8:	20 b6       	sub	r6,11
8000bfba:	0c 17       	sub	r7,r6
8000bfbc:	ca 3b       	rjmp	8000bf02 <__avr32_f64_mul+0x22>

8000bfbe <__avr32_f64_mul_op2_subnormal>:
8000bfbe:	e4 19 00 0f 	andh	r9,0xf
8000bfc2:	f0 0c 12 00 	clz	r12,r8
8000bfc6:	f2 05 12 00 	clz	r5,r9
8000bfca:	f7 bc 03 ea 	sublo	r12,-22
8000bfce:	f8 05 17 30 	movlo	r5,r12
8000bfd2:	f7 b5 02 0a 	subhs	r5,10
8000bfd6:	e0 45 00 20 	cp.w	r5,32
8000bfda:	c0 d4       	brge	8000bff4 <__avr32_f64_mul_op2_subnormal+0x36>
8000bfdc:	ea 0c 11 20 	rsub	r12,r5,32
8000bfe0:	f2 05 09 49 	lsl	r9,r9,r5
8000bfe4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bfe8:	18 49       	or	r9,r12
8000bfea:	f0 05 09 48 	lsl	r8,r8,r5
8000bfee:	20 25       	sub	r5,2
8000bff0:	0a 16       	sub	r6,r5
8000bff2:	c8 fb       	rjmp	8000bf10 <__avr32_f64_mul+0x30>
8000bff4:	f0 05 09 49 	lsl	r9,r8,r5
8000bff8:	c4 20       	breq	8000c07c <__avr32_f64_mul_res_zero>
8000bffa:	30 08       	mov	r8,0
8000bffc:	20 25       	sub	r5,2
8000bffe:	0a 16       	sub	r6,r5
8000c000:	c8 8b       	rjmp	8000bf10 <__avr32_f64_mul+0x30>

8000c002 <__avr32_f64_mul_op_nan_or_inf>:
8000c002:	e4 19 00 0f 	andh	r9,0xf
8000c006:	e4 1b 00 0f 	andh	r11,0xf
8000c00a:	14 4b       	or	r11,r10
8000c00c:	10 49       	or	r9,r8
8000c00e:	e0 47 07 ff 	cp.w	r7,2047
8000c012:	c0 91       	brne	8000c024 <__avr32_f64_mul_op1_not_naninf>
8000c014:	58 0b       	cp.w	r11,0
8000c016:	c3 81       	brne	8000c086 <__avr32_f64_mul_res_nan>
8000c018:	e0 46 07 ff 	cp.w	r6,2047
8000c01c:	c3 81       	brne	8000c08c <__avr32_f64_mul_res_inf>
8000c01e:	58 09       	cp.w	r9,0
8000c020:	c3 60       	breq	8000c08c <__avr32_f64_mul_res_inf>
8000c022:	c3 28       	rjmp	8000c086 <__avr32_f64_mul_res_nan>

8000c024 <__avr32_f64_mul_op1_not_naninf>:
8000c024:	58 09       	cp.w	r9,0
8000c026:	c3 30       	breq	8000c08c <__avr32_f64_mul_res_inf>
8000c028:	c2 f8       	rjmp	8000c086 <__avr32_f64_mul_res_nan>

8000c02a <__avr32_f64_mul_res_subnormal>:
8000c02a:	5c 3c       	neg	r12
8000c02c:	2f fc       	sub	r12,-1
8000c02e:	f1 bc 04 c0 	satu	r12,0x6
8000c032:	e0 4c 00 20 	cp.w	r12,32
8000c036:	c1 14       	brge	8000c058 <__avr32_f64_mul_res_subnormal+0x2e>
8000c038:	f8 08 11 20 	rsub	r8,r12,32
8000c03c:	0e 46       	or	r6,r7
8000c03e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c042:	f4 08 09 49 	lsl	r9,r10,r8
8000c046:	12 47       	or	r7,r9
8000c048:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c04c:	f6 08 09 49 	lsl	r9,r11,r8
8000c050:	12 4a       	or	r10,r9
8000c052:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c056:	c8 3b       	rjmp	8000bf5c <__avr32_f64_mul+0x7c>
8000c058:	f8 08 11 20 	rsub	r8,r12,32
8000c05c:	f9 b9 00 00 	moveq	r9,0
8000c060:	c0 30       	breq	8000c066 <__avr32_f64_mul_res_subnormal+0x3c>
8000c062:	f6 08 09 49 	lsl	r9,r11,r8
8000c066:	0e 46       	or	r6,r7
8000c068:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c06c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c070:	f3 ea 10 07 	or	r7,r9,r10
8000c074:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c078:	30 0b       	mov	r11,0
8000c07a:	c7 1b       	rjmp	8000bf5c <__avr32_f64_mul+0x7c>

8000c07c <__avr32_f64_mul_res_zero>:
8000c07c:	1c 9b       	mov	r11,lr
8000c07e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c082:	30 0a       	mov	r10,0
8000c084:	d8 22       	popm	r4-r7,pc

8000c086 <__avr32_f64_mul_res_nan>:
8000c086:	3f fb       	mov	r11,-1
8000c088:	3f fa       	mov	r10,-1
8000c08a:	d8 22       	popm	r4-r7,pc

8000c08c <__avr32_f64_mul_res_inf>:
8000c08c:	f0 6b 00 00 	mov	r11,-1048576
8000c090:	ed be 00 1f 	bld	lr,0x1f
8000c094:	ef bb 00 1f 	bst	r11,0x1f
8000c098:	30 0a       	mov	r10,0
8000c09a:	d8 22       	popm	r4-r7,pc

8000c09c <__avr32_f64_mul_op1_zero>:
8000c09c:	f7 e9 20 0b 	eor	r11,r11,r9
8000c0a0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c0a4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c0a8:	e0 4c 07 ff 	cp.w	r12,2047
8000c0ac:	5e 1c       	retne	r12
8000c0ae:	3f fa       	mov	r10,-1
8000c0b0:	3f fb       	mov	r11,-1
8000c0b2:	5e fc       	retal	r12

8000c0b4 <__avr32_f64_sub_from_add>:
8000c0b4:	ee 19 80 00 	eorh	r9,0x8000

8000c0b8 <__avr32_f64_sub>:
8000c0b8:	f7 e9 20 0c 	eor	r12,r11,r9
8000c0bc:	e0 86 00 ca 	brmi	8000c250 <__avr32_f64_add_from_sub>
8000c0c0:	eb cd 40 e0 	pushm	r5-r7,lr
8000c0c4:	16 9c       	mov	r12,r11
8000c0c6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c0ca:	bf db       	cbr	r11,0x1f
8000c0cc:	bf d9       	cbr	r9,0x1f
8000c0ce:	10 3a       	cp.w	r10,r8
8000c0d0:	f2 0b 13 00 	cpc	r11,r9
8000c0d4:	c0 92       	brcc	8000c0e6 <__avr32_f64_sub+0x2e>
8000c0d6:	16 97       	mov	r7,r11
8000c0d8:	12 9b       	mov	r11,r9
8000c0da:	0e 99       	mov	r9,r7
8000c0dc:	14 97       	mov	r7,r10
8000c0de:	10 9a       	mov	r10,r8
8000c0e0:	0e 98       	mov	r8,r7
8000c0e2:	ee 1c 80 00 	eorh	r12,0x8000
8000c0e6:	f6 07 16 14 	lsr	r7,r11,0x14
8000c0ea:	ab 7b       	lsl	r11,0xb
8000c0ec:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c0f0:	ab 7a       	lsl	r10,0xb
8000c0f2:	bf bb       	sbr	r11,0x1f
8000c0f4:	f2 06 16 14 	lsr	r6,r9,0x14
8000c0f8:	c4 40       	breq	8000c180 <__avr32_f64_sub_opL_subnormal>
8000c0fa:	ab 79       	lsl	r9,0xb
8000c0fc:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c100:	ab 78       	lsl	r8,0xb
8000c102:	bf b9       	sbr	r9,0x1f

8000c104 <__avr32_f64_sub_opL_subnormal_done>:
8000c104:	e0 47 07 ff 	cp.w	r7,2047
8000c108:	c4 f0       	breq	8000c1a6 <__avr32_f64_sub_opH_nan_or_inf>
8000c10a:	0e 26       	rsub	r6,r7
8000c10c:	c1 20       	breq	8000c130 <__avr32_f64_sub_shift_done>
8000c10e:	ec 05 11 20 	rsub	r5,r6,32
8000c112:	e0 46 00 20 	cp.w	r6,32
8000c116:	c7 c2       	brcc	8000c20e <__avr32_f64_sub_longshift>
8000c118:	f0 05 09 4e 	lsl	lr,r8,r5
8000c11c:	f2 05 09 45 	lsl	r5,r9,r5
8000c120:	f0 06 0a 48 	lsr	r8,r8,r6
8000c124:	f2 06 0a 49 	lsr	r9,r9,r6
8000c128:	0a 48       	or	r8,r5
8000c12a:	58 0e       	cp.w	lr,0
8000c12c:	5f 1e       	srne	lr
8000c12e:	1c 48       	or	r8,lr

8000c130 <__avr32_f64_sub_shift_done>:
8000c130:	10 1a       	sub	r10,r8
8000c132:	f6 09 01 4b 	sbc	r11,r11,r9
8000c136:	f6 06 12 00 	clz	r6,r11
8000c13a:	c0 e0       	breq	8000c156 <__avr32_f64_sub_longnormalize_done>
8000c13c:	c7 83       	brcs	8000c22c <__avr32_f64_sub_longnormalize>
8000c13e:	ec 0e 11 20 	rsub	lr,r6,32
8000c142:	f6 06 09 4b 	lsl	r11,r11,r6
8000c146:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c14a:	1c 4b       	or	r11,lr
8000c14c:	f4 06 09 4a 	lsl	r10,r10,r6
8000c150:	0c 17       	sub	r7,r6
8000c152:	e0 8a 00 39 	brle	8000c1c4 <__avr32_f64_sub_subnormal_result>

8000c156 <__avr32_f64_sub_longnormalize_done>:
8000c156:	f4 09 15 15 	lsl	r9,r10,0x15
8000c15a:	ab 9a       	lsr	r10,0xb
8000c15c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c160:	ab 9b       	lsr	r11,0xb
8000c162:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c166:	18 4b       	or	r11,r12

8000c168 <__avr32_f64_sub_round>:
8000c168:	fc 17 80 00 	movh	r7,0x8000
8000c16c:	ed ba 00 00 	bld	r10,0x0
8000c170:	f7 b7 01 ff 	subne	r7,-1
8000c174:	0e 39       	cp.w	r9,r7
8000c176:	5f 29       	srhs	r9
8000c178:	12 0a       	add	r10,r9
8000c17a:	5c 0b       	acr	r11
8000c17c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c180 <__avr32_f64_sub_opL_subnormal>:
8000c180:	ab 79       	lsl	r9,0xb
8000c182:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c186:	ab 78       	lsl	r8,0xb
8000c188:	f3 e8 10 0e 	or	lr,r9,r8
8000c18c:	f9 b6 01 01 	movne	r6,1
8000c190:	ee 0e 11 00 	rsub	lr,r7,0
8000c194:	f9 b7 00 01 	moveq	r7,1
8000c198:	ef bb 00 1f 	bst	r11,0x1f
8000c19c:	f7 ea 10 0e 	or	lr,r11,r10
8000c1a0:	f9 b7 00 00 	moveq	r7,0
8000c1a4:	cb 0b       	rjmp	8000c104 <__avr32_f64_sub_opL_subnormal_done>

8000c1a6 <__avr32_f64_sub_opH_nan_or_inf>:
8000c1a6:	bf db       	cbr	r11,0x1f
8000c1a8:	f7 ea 10 0e 	or	lr,r11,r10
8000c1ac:	c0 81       	brne	8000c1bc <__avr32_f64_sub_return_nan>
8000c1ae:	e0 46 07 ff 	cp.w	r6,2047
8000c1b2:	c0 50       	breq	8000c1bc <__avr32_f64_sub_return_nan>
8000c1b4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c1b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1bc <__avr32_f64_sub_return_nan>:
8000c1bc:	3f fa       	mov	r10,-1
8000c1be:	3f fb       	mov	r11,-1
8000c1c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1c4 <__avr32_f64_sub_subnormal_result>:
8000c1c4:	5c 37       	neg	r7
8000c1c6:	2f f7       	sub	r7,-1
8000c1c8:	f1 b7 04 c0 	satu	r7,0x6
8000c1cc:	e0 47 00 20 	cp.w	r7,32
8000c1d0:	c1 14       	brge	8000c1f2 <__avr32_f64_sub_subnormal_result+0x2e>
8000c1d2:	ee 08 11 20 	rsub	r8,r7,32
8000c1d6:	f4 08 09 49 	lsl	r9,r10,r8
8000c1da:	5f 16       	srne	r6
8000c1dc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c1e0:	0c 4a       	or	r10,r6
8000c1e2:	f6 08 09 49 	lsl	r9,r11,r8
8000c1e6:	f5 e9 10 0a 	or	r10,r10,r9
8000c1ea:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c1ee:	30 07       	mov	r7,0
8000c1f0:	cb 3b       	rjmp	8000c156 <__avr32_f64_sub_longnormalize_done>
8000c1f2:	ee 08 11 40 	rsub	r8,r7,64
8000c1f6:	f6 08 09 49 	lsl	r9,r11,r8
8000c1fa:	14 49       	or	r9,r10
8000c1fc:	5f 16       	srne	r6
8000c1fe:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c202:	0c 4a       	or	r10,r6
8000c204:	30 0b       	mov	r11,0
8000c206:	30 07       	mov	r7,0
8000c208:	ca 7b       	rjmp	8000c156 <__avr32_f64_sub_longnormalize_done>
8000c20a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c20e <__avr32_f64_sub_longshift>:
8000c20e:	f1 b6 04 c0 	satu	r6,0x6
8000c212:	f0 0e 17 00 	moveq	lr,r8
8000c216:	c0 40       	breq	8000c21e <__avr32_f64_sub_longshift+0x10>
8000c218:	f2 05 09 4e 	lsl	lr,r9,r5
8000c21c:	10 4e       	or	lr,r8
8000c21e:	f2 06 0a 48 	lsr	r8,r9,r6
8000c222:	30 09       	mov	r9,0
8000c224:	58 0e       	cp.w	lr,0
8000c226:	5f 1e       	srne	lr
8000c228:	1c 48       	or	r8,lr
8000c22a:	c8 3b       	rjmp	8000c130 <__avr32_f64_sub_shift_done>

8000c22c <__avr32_f64_sub_longnormalize>:
8000c22c:	f4 06 12 00 	clz	r6,r10
8000c230:	f9 b7 03 00 	movlo	r7,0
8000c234:	f9 b6 03 00 	movlo	r6,0
8000c238:	f9 bc 03 00 	movlo	r12,0
8000c23c:	f7 b6 02 e0 	subhs	r6,-32
8000c240:	f4 06 09 4b 	lsl	r11,r10,r6
8000c244:	30 0a       	mov	r10,0
8000c246:	0c 17       	sub	r7,r6
8000c248:	fe 9a ff be 	brle	8000c1c4 <__avr32_f64_sub_subnormal_result>
8000c24c:	c8 5b       	rjmp	8000c156 <__avr32_f64_sub_longnormalize_done>
8000c24e:	d7 03       	nop

8000c250 <__avr32_f64_add_from_sub>:
8000c250:	ee 19 80 00 	eorh	r9,0x8000

8000c254 <__avr32_f64_add>:
8000c254:	f7 e9 20 0c 	eor	r12,r11,r9
8000c258:	fe 96 ff 2e 	brmi	8000c0b4 <__avr32_f64_sub_from_add>
8000c25c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c260:	16 9c       	mov	r12,r11
8000c262:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c266:	bf db       	cbr	r11,0x1f
8000c268:	bf d9       	cbr	r9,0x1f
8000c26a:	12 3b       	cp.w	r11,r9
8000c26c:	c0 72       	brcc	8000c27a <__avr32_f64_add+0x26>
8000c26e:	16 97       	mov	r7,r11
8000c270:	12 9b       	mov	r11,r9
8000c272:	0e 99       	mov	r9,r7
8000c274:	14 97       	mov	r7,r10
8000c276:	10 9a       	mov	r10,r8
8000c278:	0e 98       	mov	r8,r7
8000c27a:	30 0e       	mov	lr,0
8000c27c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c280:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c284:	b5 ab       	sbr	r11,0x14
8000c286:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c28a:	c6 20       	breq	8000c34e <__avr32_f64_add_op2_subnormal>
8000c28c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c290:	b5 a9       	sbr	r9,0x14
8000c292:	e0 47 07 ff 	cp.w	r7,2047
8000c296:	c2 80       	breq	8000c2e6 <__avr32_f64_add_opH_nan_or_inf>
8000c298:	0e 26       	rsub	r6,r7
8000c29a:	c1 20       	breq	8000c2be <__avr32_f64_add_shift_done>
8000c29c:	e0 46 00 36 	cp.w	r6,54
8000c2a0:	c1 52       	brcc	8000c2ca <__avr32_f64_add_res_of_done>
8000c2a2:	ec 05 11 20 	rsub	r5,r6,32
8000c2a6:	e0 46 00 20 	cp.w	r6,32
8000c2aa:	c3 52       	brcc	8000c314 <__avr32_f64_add_longshift>
8000c2ac:	f0 05 09 4e 	lsl	lr,r8,r5
8000c2b0:	f2 05 09 45 	lsl	r5,r9,r5
8000c2b4:	f0 06 0a 48 	lsr	r8,r8,r6
8000c2b8:	f2 06 0a 49 	lsr	r9,r9,r6
8000c2bc:	0a 48       	or	r8,r5

8000c2be <__avr32_f64_add_shift_done>:
8000c2be:	10 0a       	add	r10,r8
8000c2c0:	f6 09 00 4b 	adc	r11,r11,r9
8000c2c4:	ed bb 00 15 	bld	r11,0x15
8000c2c8:	c3 40       	breq	8000c330 <__avr32_f64_add_res_of>

8000c2ca <__avr32_f64_add_res_of_done>:
8000c2ca:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2ce:	18 4b       	or	r11,r12

8000c2d0 <__avr32_f64_add_round>:
8000c2d0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c2d4:	18 4e       	or	lr,r12
8000c2d6:	ee 1e 80 00 	eorh	lr,0x8000
8000c2da:	f1 be 04 20 	satu	lr,0x1
8000c2de:	1c 0a       	add	r10,lr
8000c2e0:	5c 0b       	acr	r11
8000c2e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2e6 <__avr32_f64_add_opH_nan_or_inf>:
8000c2e6:	b5 cb       	cbr	r11,0x14
8000c2e8:	f7 ea 10 0e 	or	lr,r11,r10
8000c2ec:	c1 01       	brne	8000c30c <__avr32_f64_add_return_nan>
8000c2ee:	e0 46 07 ff 	cp.w	r6,2047
8000c2f2:	c0 30       	breq	8000c2f8 <__avr32_f64_add_opL_nan_or_inf>
8000c2f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2f8 <__avr32_f64_add_opL_nan_or_inf>:
8000c2f8:	b5 c9       	cbr	r9,0x14
8000c2fa:	f3 e8 10 0e 	or	lr,r9,r8
8000c2fe:	c0 71       	brne	8000c30c <__avr32_f64_add_return_nan>
8000c300:	30 0a       	mov	r10,0
8000c302:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c306:	18 4b       	or	r11,r12
8000c308:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c30c <__avr32_f64_add_return_nan>:
8000c30c:	3f fa       	mov	r10,-1
8000c30e:	3f fb       	mov	r11,-1
8000c310:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c314 <__avr32_f64_add_longshift>:
8000c314:	f1 b6 04 c0 	satu	r6,0x6
8000c318:	f0 0e 17 00 	moveq	lr,r8
8000c31c:	c0 60       	breq	8000c328 <__avr32_f64_add_longshift+0x14>
8000c31e:	f2 05 09 4e 	lsl	lr,r9,r5
8000c322:	58 08       	cp.w	r8,0
8000c324:	5f 18       	srne	r8
8000c326:	10 4e       	or	lr,r8
8000c328:	f2 06 0a 48 	lsr	r8,r9,r6
8000c32c:	30 09       	mov	r9,0
8000c32e:	cc 8b       	rjmp	8000c2be <__avr32_f64_add_shift_done>

8000c330 <__avr32_f64_add_res_of>:
8000c330:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c334:	a1 9b       	lsr	r11,0x1
8000c336:	5d 0a       	ror	r10
8000c338:	5d 0e       	ror	lr
8000c33a:	2f f7       	sub	r7,-1
8000c33c:	e0 47 07 ff 	cp.w	r7,2047
8000c340:	f9 ba 00 00 	moveq	r10,0
8000c344:	f9 bb 00 00 	moveq	r11,0
8000c348:	f9 be 00 00 	moveq	lr,0
8000c34c:	cb fb       	rjmp	8000c2ca <__avr32_f64_add_res_of_done>

8000c34e <__avr32_f64_add_op2_subnormal>:
8000c34e:	30 16       	mov	r6,1
8000c350:	58 07       	cp.w	r7,0
8000c352:	ca 01       	brne	8000c292 <__avr32_f64_add+0x3e>
8000c354:	b5 cb       	cbr	r11,0x14
8000c356:	10 0a       	add	r10,r8
8000c358:	f6 09 00 4b 	adc	r11,r11,r9
8000c35c:	18 4b       	or	r11,r12
8000c35e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c362:	d7 03       	nop

8000c364 <__avr32_f64_to_u32>:
8000c364:	58 0b       	cp.w	r11,0
8000c366:	5e 6d       	retmi	0

8000c368 <__avr32_f64_to_s32>:
8000c368:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c36c:	b5 9c       	lsr	r12,0x15
8000c36e:	e0 2c 03 ff 	sub	r12,1023
8000c372:	5e 3d       	retlo	0
8000c374:	f8 0c 11 1f 	rsub	r12,r12,31
8000c378:	16 99       	mov	r9,r11
8000c37a:	ab 7b       	lsl	r11,0xb
8000c37c:	bf bb       	sbr	r11,0x1f
8000c37e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c382:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c386:	a1 79       	lsl	r9,0x1
8000c388:	5e 2b       	reths	r11
8000c38a:	5c 3b       	neg	r11
8000c38c:	5e fb       	retal	r11

8000c38e <__avr32_u32_to_f64>:
8000c38e:	f8 cb 00 00 	sub	r11,r12,0
8000c392:	30 0c       	mov	r12,0
8000c394:	c0 38       	rjmp	8000c39a <__avr32_s32_to_f64+0x4>

8000c396 <__avr32_s32_to_f64>:
8000c396:	18 9b       	mov	r11,r12
8000c398:	5c 4b       	abs	r11
8000c39a:	30 0a       	mov	r10,0
8000c39c:	5e 0b       	reteq	r11
8000c39e:	d4 01       	pushm	lr
8000c3a0:	e0 69 04 1e 	mov	r9,1054
8000c3a4:	f6 08 12 00 	clz	r8,r11
8000c3a8:	c1 70       	breq	8000c3d6 <__avr32_s32_to_f64+0x40>
8000c3aa:	c0 c3       	brcs	8000c3c2 <__avr32_s32_to_f64+0x2c>
8000c3ac:	f0 0e 11 20 	rsub	lr,r8,32
8000c3b0:	f6 08 09 4b 	lsl	r11,r11,r8
8000c3b4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c3b8:	1c 4b       	or	r11,lr
8000c3ba:	f4 08 09 4a 	lsl	r10,r10,r8
8000c3be:	10 19       	sub	r9,r8
8000c3c0:	c0 b8       	rjmp	8000c3d6 <__avr32_s32_to_f64+0x40>
8000c3c2:	f4 08 12 00 	clz	r8,r10
8000c3c6:	f9 b8 03 00 	movlo	r8,0
8000c3ca:	f7 b8 02 e0 	subhs	r8,-32
8000c3ce:	f4 08 09 4b 	lsl	r11,r10,r8
8000c3d2:	30 0a       	mov	r10,0
8000c3d4:	10 19       	sub	r9,r8
8000c3d6:	58 09       	cp.w	r9,0
8000c3d8:	e0 89 00 30 	brgt	8000c438 <__avr32_s32_to_f64+0xa2>
8000c3dc:	5c 39       	neg	r9
8000c3de:	2f f9       	sub	r9,-1
8000c3e0:	e0 49 00 36 	cp.w	r9,54
8000c3e4:	c0 43       	brcs	8000c3ec <__avr32_s32_to_f64+0x56>
8000c3e6:	30 0b       	mov	r11,0
8000c3e8:	30 0a       	mov	r10,0
8000c3ea:	c2 68       	rjmp	8000c436 <__avr32_s32_to_f64+0xa0>
8000c3ec:	2f 69       	sub	r9,-10
8000c3ee:	f2 08 11 20 	rsub	r8,r9,32
8000c3f2:	e0 49 00 20 	cp.w	r9,32
8000c3f6:	c0 b2       	brcc	8000c40c <__avr32_s32_to_f64+0x76>
8000c3f8:	f4 08 09 4e 	lsl	lr,r10,r8
8000c3fc:	f6 08 09 48 	lsl	r8,r11,r8
8000c400:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c404:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c408:	10 4b       	or	r11,r8
8000c40a:	c0 88       	rjmp	8000c41a <__avr32_s32_to_f64+0x84>
8000c40c:	f6 08 09 4e 	lsl	lr,r11,r8
8000c410:	14 4e       	or	lr,r10
8000c412:	16 9a       	mov	r10,r11
8000c414:	30 0b       	mov	r11,0
8000c416:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c41a:	ed ba 00 00 	bld	r10,0x0
8000c41e:	c0 92       	brcc	8000c430 <__avr32_s32_to_f64+0x9a>
8000c420:	1c 7e       	tst	lr,lr
8000c422:	c0 41       	brne	8000c42a <__avr32_s32_to_f64+0x94>
8000c424:	ed ba 00 01 	bld	r10,0x1
8000c428:	c0 42       	brcc	8000c430 <__avr32_s32_to_f64+0x9a>
8000c42a:	2f fa       	sub	r10,-1
8000c42c:	f7 bb 02 ff 	subhs	r11,-1
8000c430:	5c fc       	rol	r12
8000c432:	5d 0b       	ror	r11
8000c434:	5d 0a       	ror	r10
8000c436:	d8 02       	popm	pc
8000c438:	e0 68 03 ff 	mov	r8,1023
8000c43c:	ed ba 00 0b 	bld	r10,0xb
8000c440:	f7 b8 00 ff 	subeq	r8,-1
8000c444:	10 0a       	add	r10,r8
8000c446:	5c 0b       	acr	r11
8000c448:	f7 b9 03 fe 	sublo	r9,-2
8000c44c:	e0 49 07 ff 	cp.w	r9,2047
8000c450:	c0 55       	brlt	8000c45a <__avr32_s32_to_f64+0xc4>
8000c452:	30 0a       	mov	r10,0
8000c454:	fc 1b ff e0 	movh	r11,0xffe0
8000c458:	c0 c8       	rjmp	8000c470 <__floatsidf_return_op1>
8000c45a:	ed bb 00 1f 	bld	r11,0x1f
8000c45e:	f7 b9 01 01 	subne	r9,1
8000c462:	ab 9a       	lsr	r10,0xb
8000c464:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c468:	a1 7b       	lsl	r11,0x1
8000c46a:	ab 9b       	lsr	r11,0xb
8000c46c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c470 <__floatsidf_return_op1>:
8000c470:	a1 7c       	lsl	r12,0x1
8000c472:	5d 0b       	ror	r11
8000c474:	d8 02       	popm	pc

8000c476 <__avr32_f64_cmp_eq>:
8000c476:	10 3a       	cp.w	r10,r8
8000c478:	f2 0b 13 00 	cpc	r11,r9
8000c47c:	c0 80       	breq	8000c48c <__avr32_f64_cmp_eq+0x16>
8000c47e:	a1 7b       	lsl	r11,0x1
8000c480:	a1 79       	lsl	r9,0x1
8000c482:	14 4b       	or	r11,r10
8000c484:	12 4b       	or	r11,r9
8000c486:	10 4b       	or	r11,r8
8000c488:	5e 0f       	reteq	1
8000c48a:	5e fd       	retal	0
8000c48c:	a1 7b       	lsl	r11,0x1
8000c48e:	fc 1c ff e0 	movh	r12,0xffe0
8000c492:	58 0a       	cp.w	r10,0
8000c494:	f8 0b 13 00 	cpc	r11,r12
8000c498:	5e 8f       	retls	1
8000c49a:	5e fd       	retal	0

8000c49c <__avr32_f64_cmp_ge>:
8000c49c:	1a de       	st.w	--sp,lr
8000c49e:	1a d7       	st.w	--sp,r7
8000c4a0:	a1 7b       	lsl	r11,0x1
8000c4a2:	5f 3c       	srlo	r12
8000c4a4:	a1 79       	lsl	r9,0x1
8000c4a6:	5f 37       	srlo	r7
8000c4a8:	5c fc       	rol	r12
8000c4aa:	fc 1e ff e0 	movh	lr,0xffe0
8000c4ae:	58 0a       	cp.w	r10,0
8000c4b0:	fc 0b 13 00 	cpc	r11,lr
8000c4b4:	e0 8b 00 1d 	brhi	8000c4ee <__avr32_f64_cmp_ge+0x52>
8000c4b8:	58 08       	cp.w	r8,0
8000c4ba:	fc 09 13 00 	cpc	r9,lr
8000c4be:	e0 8b 00 18 	brhi	8000c4ee <__avr32_f64_cmp_ge+0x52>
8000c4c2:	58 0b       	cp.w	r11,0
8000c4c4:	f5 ba 00 00 	subfeq	r10,0
8000c4c8:	c1 50       	breq	8000c4f2 <__avr32_f64_cmp_ge+0x56>
8000c4ca:	1b 07       	ld.w	r7,sp++
8000c4cc:	1b 0e       	ld.w	lr,sp++
8000c4ce:	58 3c       	cp.w	r12,3
8000c4d0:	c0 a0       	breq	8000c4e4 <__avr32_f64_cmp_ge+0x48>
8000c4d2:	58 1c       	cp.w	r12,1
8000c4d4:	c0 33       	brcs	8000c4da <__avr32_f64_cmp_ge+0x3e>
8000c4d6:	5e 0f       	reteq	1
8000c4d8:	5e 1d       	retne	0
8000c4da:	10 3a       	cp.w	r10,r8
8000c4dc:	f2 0b 13 00 	cpc	r11,r9
8000c4e0:	5e 2f       	reths	1
8000c4e2:	5e 3d       	retlo	0
8000c4e4:	14 38       	cp.w	r8,r10
8000c4e6:	f6 09 13 00 	cpc	r9,r11
8000c4ea:	5e 2f       	reths	1
8000c4ec:	5e 3d       	retlo	0
8000c4ee:	1b 07       	ld.w	r7,sp++
8000c4f0:	d8 0a       	popm	pc,r12=0
8000c4f2:	58 17       	cp.w	r7,1
8000c4f4:	5f 0c       	sreq	r12
8000c4f6:	58 09       	cp.w	r9,0
8000c4f8:	f5 b8 00 00 	subfeq	r8,0
8000c4fc:	1b 07       	ld.w	r7,sp++
8000c4fe:	1b 0e       	ld.w	lr,sp++
8000c500:	5e 0f       	reteq	1
8000c502:	5e fc       	retal	r12

8000c504 <__avr32_f64_cmp_lt>:
8000c504:	1a de       	st.w	--sp,lr
8000c506:	1a d7       	st.w	--sp,r7
8000c508:	a1 7b       	lsl	r11,0x1
8000c50a:	5f 3c       	srlo	r12
8000c50c:	a1 79       	lsl	r9,0x1
8000c50e:	5f 37       	srlo	r7
8000c510:	5c fc       	rol	r12
8000c512:	fc 1e ff e0 	movh	lr,0xffe0
8000c516:	58 0a       	cp.w	r10,0
8000c518:	fc 0b 13 00 	cpc	r11,lr
8000c51c:	e0 8b 00 1d 	brhi	8000c556 <__avr32_f64_cmp_lt+0x52>
8000c520:	58 08       	cp.w	r8,0
8000c522:	fc 09 13 00 	cpc	r9,lr
8000c526:	e0 8b 00 18 	brhi	8000c556 <__avr32_f64_cmp_lt+0x52>
8000c52a:	58 0b       	cp.w	r11,0
8000c52c:	f5 ba 00 00 	subfeq	r10,0
8000c530:	c1 50       	breq	8000c55a <__avr32_f64_cmp_lt+0x56>
8000c532:	1b 07       	ld.w	r7,sp++
8000c534:	1b 0e       	ld.w	lr,sp++
8000c536:	58 3c       	cp.w	r12,3
8000c538:	c0 a0       	breq	8000c54c <__avr32_f64_cmp_lt+0x48>
8000c53a:	58 1c       	cp.w	r12,1
8000c53c:	c0 33       	brcs	8000c542 <__avr32_f64_cmp_lt+0x3e>
8000c53e:	5e 0d       	reteq	0
8000c540:	5e 1f       	retne	1
8000c542:	10 3a       	cp.w	r10,r8
8000c544:	f2 0b 13 00 	cpc	r11,r9
8000c548:	5e 2d       	reths	0
8000c54a:	5e 3f       	retlo	1
8000c54c:	14 38       	cp.w	r8,r10
8000c54e:	f6 09 13 00 	cpc	r9,r11
8000c552:	5e 2d       	reths	0
8000c554:	5e 3f       	retlo	1
8000c556:	1b 07       	ld.w	r7,sp++
8000c558:	d8 0a       	popm	pc,r12=0
8000c55a:	58 17       	cp.w	r7,1
8000c55c:	5f 1c       	srne	r12
8000c55e:	58 09       	cp.w	r9,0
8000c560:	f5 b8 00 00 	subfeq	r8,0
8000c564:	1b 07       	ld.w	r7,sp++
8000c566:	1b 0e       	ld.w	lr,sp++
8000c568:	5e 0d       	reteq	0
8000c56a:	5e fc       	retal	r12

8000c56c <__avr32_f64_div>:
8000c56c:	eb cd 40 ff 	pushm	r0-r7,lr
8000c570:	f7 e9 20 0e 	eor	lr,r11,r9
8000c574:	f6 07 16 14 	lsr	r7,r11,0x14
8000c578:	a9 7b       	lsl	r11,0x9
8000c57a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c57e:	a9 7a       	lsl	r10,0x9
8000c580:	bd bb       	sbr	r11,0x1d
8000c582:	e4 1b 3f ff 	andh	r11,0x3fff
8000c586:	ab d7       	cbr	r7,0xb
8000c588:	e0 80 00 cc 	breq	8000c720 <__avr32_f64_div_round_subnormal+0x54>
8000c58c:	e0 47 07 ff 	cp.w	r7,2047
8000c590:	e0 84 00 b5 	brge	8000c6fa <__avr32_f64_div_round_subnormal+0x2e>
8000c594:	f2 06 16 14 	lsr	r6,r9,0x14
8000c598:	a9 79       	lsl	r9,0x9
8000c59a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c59e:	a9 78       	lsl	r8,0x9
8000c5a0:	bd b9       	sbr	r9,0x1d
8000c5a2:	e4 19 3f ff 	andh	r9,0x3fff
8000c5a6:	ab d6       	cbr	r6,0xb
8000c5a8:	e0 80 00 e2 	breq	8000c76c <__avr32_f64_div_round_subnormal+0xa0>
8000c5ac:	e0 46 07 ff 	cp.w	r6,2047
8000c5b0:	e0 84 00 b2 	brge	8000c714 <__avr32_f64_div_round_subnormal+0x48>
8000c5b4:	0c 17       	sub	r7,r6
8000c5b6:	fe 37 fc 01 	sub	r7,-1023
8000c5ba:	fc 1c 80 00 	movh	r12,0x8000
8000c5be:	f8 03 16 01 	lsr	r3,r12,0x1
8000c5c2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c5c6:	5c d4       	com	r4
8000c5c8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c5cc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5d0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5d4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5d8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5dc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5e0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5e4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5e8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5ec:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5f0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5f4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5f8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5fc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c600:	e4 09 07 40 	macu.d	r0,r2,r9
8000c604:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c608:	02 04       	add	r4,r1
8000c60a:	5c 05       	acr	r5
8000c60c:	a3 65       	lsl	r5,0x2
8000c60e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c612:	a3 64       	lsl	r4,0x2
8000c614:	5c 34       	neg	r4
8000c616:	f8 05 01 45 	sbc	r5,r12,r5
8000c61a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c61e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c622:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c626:	02 04       	add	r4,r1
8000c628:	5c 05       	acr	r5
8000c62a:	ea 03 15 02 	lsl	r3,r5,0x2
8000c62e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c632:	e8 02 15 02 	lsl	r2,r4,0x2
8000c636:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c63a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c63e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c642:	02 04       	add	r4,r1
8000c644:	5c 05       	acr	r5
8000c646:	a3 65       	lsl	r5,0x2
8000c648:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c64c:	a3 64       	lsl	r4,0x2
8000c64e:	5c 34       	neg	r4
8000c650:	f8 05 01 45 	sbc	r5,r12,r5
8000c654:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c658:	e4 05 07 40 	macu.d	r0,r2,r5
8000c65c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c660:	02 04       	add	r4,r1
8000c662:	5c 05       	acr	r5
8000c664:	ea 03 15 02 	lsl	r3,r5,0x2
8000c668:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c66c:	e8 02 15 02 	lsl	r2,r4,0x2
8000c670:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c674:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c678:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c67c:	02 02       	add	r2,r1
8000c67e:	5c 03       	acr	r3
8000c680:	ed b3 00 1c 	bld	r3,0x1c
8000c684:	c0 90       	breq	8000c696 <__avr32_f64_div+0x12a>
8000c686:	a1 72       	lsl	r2,0x1
8000c688:	5c f3       	rol	r3
8000c68a:	20 17       	sub	r7,1
8000c68c:	a3 9a       	lsr	r10,0x3
8000c68e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c692:	a3 9b       	lsr	r11,0x3
8000c694:	c0 58       	rjmp	8000c69e <__avr32_f64_div+0x132>
8000c696:	a5 8a       	lsr	r10,0x4
8000c698:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c69c:	a5 8b       	lsr	r11,0x4
8000c69e:	58 07       	cp.w	r7,0
8000c6a0:	e0 8a 00 8b 	brle	8000c7b6 <__avr32_f64_div_res_subnormal>
8000c6a4:	e0 12 ff 00 	andl	r2,0xff00
8000c6a8:	e8 12 00 80 	orl	r2,0x80
8000c6ac:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c6b0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c6b4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c6b8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c6bc:	00 05       	add	r5,r0
8000c6be:	f0 01 00 48 	adc	r8,r8,r1
8000c6c2:	5c 09       	acr	r9
8000c6c4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c6c8:	58 04       	cp.w	r4,0
8000c6ca:	5c 25       	cpc	r5

8000c6cc <__avr32_f64_div_round_subnormal>:
8000c6cc:	f4 08 13 00 	cpc	r8,r10
8000c6d0:	f6 09 13 00 	cpc	r9,r11
8000c6d4:	5f 36       	srlo	r6
8000c6d6:	f8 06 17 00 	moveq	r6,r12
8000c6da:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c6de:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c6e2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c6e6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c6ea:	ed be 00 1f 	bld	lr,0x1f
8000c6ee:	ef bb 00 1f 	bst	r11,0x1f
8000c6f2:	0c 0a       	add	r10,r6
8000c6f4:	5c 0b       	acr	r11
8000c6f6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c6fa:	e4 1b 00 0f 	andh	r11,0xf
8000c6fe:	14 4b       	or	r11,r10
8000c700:	e0 81 00 a7 	brne	8000c84e <__avr32_f64_div_res_subnormal+0x98>
8000c704:	f2 06 16 14 	lsr	r6,r9,0x14
8000c708:	ab d6       	cbr	r6,0xb
8000c70a:	e0 46 07 ff 	cp.w	r6,2047
8000c70e:	e0 81 00 a4 	brne	8000c856 <__avr32_f64_div_res_subnormal+0xa0>
8000c712:	c9 e8       	rjmp	8000c84e <__avr32_f64_div_res_subnormal+0x98>
8000c714:	e4 19 00 0f 	andh	r9,0xf
8000c718:	10 49       	or	r9,r8
8000c71a:	e0 81 00 9a 	brne	8000c84e <__avr32_f64_div_res_subnormal+0x98>
8000c71e:	c9 28       	rjmp	8000c842 <__avr32_f64_div_res_subnormal+0x8c>
8000c720:	a3 7b       	lsl	r11,0x3
8000c722:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c726:	a3 7a       	lsl	r10,0x3
8000c728:	f5 eb 10 04 	or	r4,r10,r11
8000c72c:	e0 80 00 a0 	breq	8000c86c <__avr32_f64_div_op1_zero>
8000c730:	f6 04 12 00 	clz	r4,r11
8000c734:	c1 70       	breq	8000c762 <__avr32_f64_div_round_subnormal+0x96>
8000c736:	c0 c3       	brcs	8000c74e <__avr32_f64_div_round_subnormal+0x82>
8000c738:	e8 05 11 20 	rsub	r5,r4,32
8000c73c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c740:	f4 05 0a 45 	lsr	r5,r10,r5
8000c744:	0a 4b       	or	r11,r5
8000c746:	f4 04 09 4a 	lsl	r10,r10,r4
8000c74a:	08 17       	sub	r7,r4
8000c74c:	c0 b8       	rjmp	8000c762 <__avr32_f64_div_round_subnormal+0x96>
8000c74e:	f4 04 12 00 	clz	r4,r10
8000c752:	f9 b4 03 00 	movlo	r4,0
8000c756:	f7 b4 02 e0 	subhs	r4,-32
8000c75a:	f4 04 09 4b 	lsl	r11,r10,r4
8000c75e:	30 0a       	mov	r10,0
8000c760:	08 17       	sub	r7,r4
8000c762:	a3 8a       	lsr	r10,0x2
8000c764:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c768:	a3 8b       	lsr	r11,0x2
8000c76a:	c1 1b       	rjmp	8000c58c <__avr32_f64_div+0x20>
8000c76c:	a3 79       	lsl	r9,0x3
8000c76e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c772:	a3 78       	lsl	r8,0x3
8000c774:	f3 e8 10 04 	or	r4,r9,r8
8000c778:	c6 f0       	breq	8000c856 <__avr32_f64_div_res_subnormal+0xa0>
8000c77a:	f2 04 12 00 	clz	r4,r9
8000c77e:	c1 70       	breq	8000c7ac <__avr32_f64_div_round_subnormal+0xe0>
8000c780:	c0 c3       	brcs	8000c798 <__avr32_f64_div_round_subnormal+0xcc>
8000c782:	e8 05 11 20 	rsub	r5,r4,32
8000c786:	f2 04 09 49 	lsl	r9,r9,r4
8000c78a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c78e:	0a 49       	or	r9,r5
8000c790:	f0 04 09 48 	lsl	r8,r8,r4
8000c794:	08 16       	sub	r6,r4
8000c796:	c0 b8       	rjmp	8000c7ac <__avr32_f64_div_round_subnormal+0xe0>
8000c798:	f0 04 12 00 	clz	r4,r8
8000c79c:	f9 b4 03 00 	movlo	r4,0
8000c7a0:	f7 b4 02 e0 	subhs	r4,-32
8000c7a4:	f0 04 09 49 	lsl	r9,r8,r4
8000c7a8:	30 08       	mov	r8,0
8000c7aa:	08 16       	sub	r6,r4
8000c7ac:	a3 88       	lsr	r8,0x2
8000c7ae:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c7b2:	a3 89       	lsr	r9,0x2
8000c7b4:	cf ca       	rjmp	8000c5ac <__avr32_f64_div+0x40>

8000c7b6 <__avr32_f64_div_res_subnormal>:
8000c7b6:	5c 37       	neg	r7
8000c7b8:	2f f7       	sub	r7,-1
8000c7ba:	f1 b7 04 c0 	satu	r7,0x6
8000c7be:	e0 47 00 20 	cp.w	r7,32
8000c7c2:	c1 54       	brge	8000c7ec <__avr32_f64_div_res_subnormal+0x36>
8000c7c4:	ee 06 11 20 	rsub	r6,r7,32
8000c7c8:	e4 07 0a 42 	lsr	r2,r2,r7
8000c7cc:	e6 06 09 4c 	lsl	r12,r3,r6
8000c7d0:	18 42       	or	r2,r12
8000c7d2:	e6 07 0a 43 	lsr	r3,r3,r7
8000c7d6:	f4 06 09 41 	lsl	r1,r10,r6
8000c7da:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c7de:	f6 06 09 4c 	lsl	r12,r11,r6
8000c7e2:	18 4a       	or	r10,r12
8000c7e4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c7e8:	30 00       	mov	r0,0
8000c7ea:	c1 58       	rjmp	8000c814 <__avr32_f64_div_res_subnormal+0x5e>
8000c7ec:	ee 06 11 20 	rsub	r6,r7,32
8000c7f0:	f9 b0 00 00 	moveq	r0,0
8000c7f4:	f9 bc 00 00 	moveq	r12,0
8000c7f8:	c0 50       	breq	8000c802 <__avr32_f64_div_res_subnormal+0x4c>
8000c7fa:	f4 06 09 40 	lsl	r0,r10,r6
8000c7fe:	f6 06 09 4c 	lsl	r12,r11,r6
8000c802:	e6 07 0a 42 	lsr	r2,r3,r7
8000c806:	30 03       	mov	r3,0
8000c808:	f4 07 0a 41 	lsr	r1,r10,r7
8000c80c:	18 41       	or	r1,r12
8000c80e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c812:	30 0b       	mov	r11,0
8000c814:	e0 12 ff 00 	andl	r2,0xff00
8000c818:	e8 12 00 80 	orl	r2,0x80
8000c81c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c820:	e4 09 07 46 	macu.d	r6,r2,r9
8000c824:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c828:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c82c:	0c 05       	add	r5,r6
8000c82e:	f0 07 00 48 	adc	r8,r8,r7
8000c832:	5c 09       	acr	r9
8000c834:	30 07       	mov	r7,0
8000c836:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c83a:	00 34       	cp.w	r4,r0
8000c83c:	e2 05 13 00 	cpc	r5,r1
8000c840:	c4 6b       	rjmp	8000c6cc <__avr32_f64_div_round_subnormal>
8000c842:	1c 9b       	mov	r11,lr
8000c844:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c848:	30 0a       	mov	r10,0
8000c84a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c84e:	3f fb       	mov	r11,-1
8000c850:	30 0a       	mov	r10,0
8000c852:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c856:	f5 eb 10 04 	or	r4,r10,r11
8000c85a:	c0 90       	breq	8000c86c <__avr32_f64_div_op1_zero>
8000c85c:	1c 9b       	mov	r11,lr
8000c85e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c862:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c866:	30 0a       	mov	r10,0
8000c868:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c86c <__avr32_f64_div_op1_zero>:
8000c86c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c870:	ce f0       	breq	8000c84e <__avr32_f64_div_res_subnormal+0x98>
8000c872:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c876:	e0 44 07 ff 	cp.w	r4,2047
8000c87a:	ce 41       	brne	8000c842 <__avr32_f64_div_res_subnormal+0x8c>
8000c87c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c880:	ce 10       	breq	8000c842 <__avr32_f64_div_res_subnormal+0x8c>
8000c882:	ce 6b       	rjmp	8000c84e <__avr32_f64_div_res_subnormal+0x98>

8000c884 <__avr32_udiv64>:
8000c884:	d4 31       	pushm	r0-r7,lr
8000c886:	1a 97       	mov	r7,sp
8000c888:	20 3d       	sub	sp,12
8000c88a:	10 9c       	mov	r12,r8
8000c88c:	12 9e       	mov	lr,r9
8000c88e:	14 93       	mov	r3,r10
8000c890:	58 09       	cp.w	r9,0
8000c892:	e0 81 00 bd 	brne	8000ca0c <__avr32_udiv64+0x188>
8000c896:	16 38       	cp.w	r8,r11
8000c898:	e0 88 00 40 	brls	8000c918 <__avr32_udiv64+0x94>
8000c89c:	f0 08 12 00 	clz	r8,r8
8000c8a0:	c0 d0       	breq	8000c8ba <__avr32_udiv64+0x36>
8000c8a2:	f6 08 09 4b 	lsl	r11,r11,r8
8000c8a6:	f0 09 11 20 	rsub	r9,r8,32
8000c8aa:	f8 08 09 4c 	lsl	r12,r12,r8
8000c8ae:	f4 09 0a 49 	lsr	r9,r10,r9
8000c8b2:	f4 08 09 43 	lsl	r3,r10,r8
8000c8b6:	f3 eb 10 0b 	or	r11,r9,r11
8000c8ba:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c8be:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c8c2:	f6 0e 0d 00 	divu	r0,r11,lr
8000c8c6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c8ca:	00 99       	mov	r9,r0
8000c8cc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8d0:	e0 0a 02 48 	mul	r8,r0,r10
8000c8d4:	10 3b       	cp.w	r11,r8
8000c8d6:	c0 a2       	brcc	8000c8ea <__avr32_udiv64+0x66>
8000c8d8:	20 19       	sub	r9,1
8000c8da:	18 0b       	add	r11,r12
8000c8dc:	18 3b       	cp.w	r11,r12
8000c8de:	c0 63       	brcs	8000c8ea <__avr32_udiv64+0x66>
8000c8e0:	10 3b       	cp.w	r11,r8
8000c8e2:	f7 b9 03 01 	sublo	r9,1
8000c8e6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8ea:	f6 08 01 01 	sub	r1,r11,r8
8000c8ee:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c8f2:	e2 0e 0d 00 	divu	r0,r1,lr
8000c8f6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c8fa:	00 98       	mov	r8,r0
8000c8fc:	e0 0a 02 4a 	mul	r10,r0,r10
8000c900:	14 33       	cp.w	r3,r10
8000c902:	c0 82       	brcc	8000c912 <__avr32_udiv64+0x8e>
8000c904:	20 18       	sub	r8,1
8000c906:	18 03       	add	r3,r12
8000c908:	18 33       	cp.w	r3,r12
8000c90a:	c0 43       	brcs	8000c912 <__avr32_udiv64+0x8e>
8000c90c:	14 33       	cp.w	r3,r10
8000c90e:	f7 b8 03 01 	sublo	r8,1
8000c912:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c916:	cd f8       	rjmp	8000cad4 <__avr32_udiv64+0x250>
8000c918:	58 08       	cp.w	r8,0
8000c91a:	c0 51       	brne	8000c924 <__avr32_udiv64+0xa0>
8000c91c:	30 19       	mov	r9,1
8000c91e:	f2 08 0d 08 	divu	r8,r9,r8
8000c922:	10 9c       	mov	r12,r8
8000c924:	f8 06 12 00 	clz	r6,r12
8000c928:	c0 41       	brne	8000c930 <__avr32_udiv64+0xac>
8000c92a:	18 1b       	sub	r11,r12
8000c92c:	30 19       	mov	r9,1
8000c92e:	c4 08       	rjmp	8000c9ae <__avr32_udiv64+0x12a>
8000c930:	ec 01 11 20 	rsub	r1,r6,32
8000c934:	f4 01 0a 49 	lsr	r9,r10,r1
8000c938:	f8 06 09 4c 	lsl	r12,r12,r6
8000c93c:	f6 06 09 48 	lsl	r8,r11,r6
8000c940:	f6 01 0a 41 	lsr	r1,r11,r1
8000c944:	f3 e8 10 08 	or	r8,r9,r8
8000c948:	f8 03 16 10 	lsr	r3,r12,0x10
8000c94c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c950:	e2 03 0d 00 	divu	r0,r1,r3
8000c954:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c958:	00 9e       	mov	lr,r0
8000c95a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c95e:	e0 05 02 49 	mul	r9,r0,r5
8000c962:	12 3b       	cp.w	r11,r9
8000c964:	c0 a2       	brcc	8000c978 <__avr32_udiv64+0xf4>
8000c966:	20 1e       	sub	lr,1
8000c968:	18 0b       	add	r11,r12
8000c96a:	18 3b       	cp.w	r11,r12
8000c96c:	c0 63       	brcs	8000c978 <__avr32_udiv64+0xf4>
8000c96e:	12 3b       	cp.w	r11,r9
8000c970:	f7 be 03 01 	sublo	lr,1
8000c974:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c978:	12 1b       	sub	r11,r9
8000c97a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c97e:	f6 03 0d 02 	divu	r2,r11,r3
8000c982:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c986:	04 99       	mov	r9,r2
8000c988:	e4 05 02 4b 	mul	r11,r2,r5
8000c98c:	16 38       	cp.w	r8,r11
8000c98e:	c0 a2       	brcc	8000c9a2 <__avr32_udiv64+0x11e>
8000c990:	20 19       	sub	r9,1
8000c992:	18 08       	add	r8,r12
8000c994:	18 38       	cp.w	r8,r12
8000c996:	c0 63       	brcs	8000c9a2 <__avr32_udiv64+0x11e>
8000c998:	16 38       	cp.w	r8,r11
8000c99a:	f7 b9 03 01 	sublo	r9,1
8000c99e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c9a2:	f4 06 09 43 	lsl	r3,r10,r6
8000c9a6:	f0 0b 01 0b 	sub	r11,r8,r11
8000c9aa:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c9ae:	f8 06 16 10 	lsr	r6,r12,0x10
8000c9b2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c9b6:	f6 06 0d 00 	divu	r0,r11,r6
8000c9ba:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c9be:	00 9a       	mov	r10,r0
8000c9c0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9c4:	e0 0e 02 48 	mul	r8,r0,lr
8000c9c8:	10 3b       	cp.w	r11,r8
8000c9ca:	c0 a2       	brcc	8000c9de <__avr32_udiv64+0x15a>
8000c9cc:	20 1a       	sub	r10,1
8000c9ce:	18 0b       	add	r11,r12
8000c9d0:	18 3b       	cp.w	r11,r12
8000c9d2:	c0 63       	brcs	8000c9de <__avr32_udiv64+0x15a>
8000c9d4:	10 3b       	cp.w	r11,r8
8000c9d6:	f7 ba 03 01 	sublo	r10,1
8000c9da:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c9de:	f6 08 01 01 	sub	r1,r11,r8
8000c9e2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c9e6:	e2 06 0d 00 	divu	r0,r1,r6
8000c9ea:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c9ee:	00 98       	mov	r8,r0
8000c9f0:	e0 0e 02 4b 	mul	r11,r0,lr
8000c9f4:	16 33       	cp.w	r3,r11
8000c9f6:	c0 82       	brcc	8000ca06 <__avr32_udiv64+0x182>
8000c9f8:	20 18       	sub	r8,1
8000c9fa:	18 03       	add	r3,r12
8000c9fc:	18 33       	cp.w	r3,r12
8000c9fe:	c0 43       	brcs	8000ca06 <__avr32_udiv64+0x182>
8000ca00:	16 33       	cp.w	r3,r11
8000ca02:	f7 b8 03 01 	sublo	r8,1
8000ca06:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ca0a:	c6 98       	rjmp	8000cadc <__avr32_udiv64+0x258>
8000ca0c:	16 39       	cp.w	r9,r11
8000ca0e:	e0 8b 00 65 	brhi	8000cad8 <__avr32_udiv64+0x254>
8000ca12:	f2 09 12 00 	clz	r9,r9
8000ca16:	c0 b1       	brne	8000ca2c <__avr32_udiv64+0x1a8>
8000ca18:	10 3a       	cp.w	r10,r8
8000ca1a:	5f 2a       	srhs	r10
8000ca1c:	1c 3b       	cp.w	r11,lr
8000ca1e:	5f b8       	srhi	r8
8000ca20:	10 4a       	or	r10,r8
8000ca22:	f2 0a 18 00 	cp.b	r10,r9
8000ca26:	c5 90       	breq	8000cad8 <__avr32_udiv64+0x254>
8000ca28:	30 18       	mov	r8,1
8000ca2a:	c5 98       	rjmp	8000cadc <__avr32_udiv64+0x258>
8000ca2c:	f0 09 09 46 	lsl	r6,r8,r9
8000ca30:	f2 03 11 20 	rsub	r3,r9,32
8000ca34:	fc 09 09 4e 	lsl	lr,lr,r9
8000ca38:	f0 03 0a 48 	lsr	r8,r8,r3
8000ca3c:	f6 09 09 4c 	lsl	r12,r11,r9
8000ca40:	f4 03 0a 42 	lsr	r2,r10,r3
8000ca44:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca48:	f6 03 0a 43 	lsr	r3,r11,r3
8000ca4c:	18 42       	or	r2,r12
8000ca4e:	f1 ee 10 0c 	or	r12,r8,lr
8000ca52:	f8 01 16 10 	lsr	r1,r12,0x10
8000ca56:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca5a:	e6 01 0d 04 	divu	r4,r3,r1
8000ca5e:	e4 03 16 10 	lsr	r3,r2,0x10
8000ca62:	08 9e       	mov	lr,r4
8000ca64:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000ca68:	e8 06 02 48 	mul	r8,r4,r6
8000ca6c:	10 33       	cp.w	r3,r8
8000ca6e:	c0 a2       	brcc	8000ca82 <__avr32_udiv64+0x1fe>
8000ca70:	20 1e       	sub	lr,1
8000ca72:	18 03       	add	r3,r12
8000ca74:	18 33       	cp.w	r3,r12
8000ca76:	c0 63       	brcs	8000ca82 <__avr32_udiv64+0x1fe>
8000ca78:	10 33       	cp.w	r3,r8
8000ca7a:	f7 be 03 01 	sublo	lr,1
8000ca7e:	e7 dc e3 03 	addcs	r3,r3,r12
8000ca82:	10 13       	sub	r3,r8
8000ca84:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000ca88:	e6 01 0d 00 	divu	r0,r3,r1
8000ca8c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca90:	00 98       	mov	r8,r0
8000ca92:	e0 06 02 46 	mul	r6,r0,r6
8000ca96:	0c 3b       	cp.w	r11,r6
8000ca98:	c0 a2       	brcc	8000caac <__avr32_udiv64+0x228>
8000ca9a:	20 18       	sub	r8,1
8000ca9c:	18 0b       	add	r11,r12
8000ca9e:	18 3b       	cp.w	r11,r12
8000caa0:	c0 63       	brcs	8000caac <__avr32_udiv64+0x228>
8000caa2:	0c 3b       	cp.w	r11,r6
8000caa4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000caa8:	f7 b8 03 01 	sublo	r8,1
8000caac:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cab0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cab4:	0c 1b       	sub	r11,r6
8000cab6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000caba:	06 95       	mov	r5,r3
8000cabc:	16 35       	cp.w	r5,r11
8000cabe:	e0 8b 00 0a 	brhi	8000cad2 <__avr32_udiv64+0x24e>
8000cac2:	5f 0b       	sreq	r11
8000cac4:	f4 09 09 49 	lsl	r9,r10,r9
8000cac8:	12 32       	cp.w	r2,r9
8000caca:	5f b9       	srhi	r9
8000cacc:	f7 e9 00 09 	and	r9,r11,r9
8000cad0:	c0 60       	breq	8000cadc <__avr32_udiv64+0x258>
8000cad2:	20 18       	sub	r8,1
8000cad4:	30 09       	mov	r9,0
8000cad6:	c0 38       	rjmp	8000cadc <__avr32_udiv64+0x258>
8000cad8:	30 09       	mov	r9,0
8000cada:	12 98       	mov	r8,r9
8000cadc:	10 9a       	mov	r10,r8
8000cade:	12 93       	mov	r3,r9
8000cae0:	10 92       	mov	r2,r8
8000cae2:	12 9b       	mov	r11,r9
8000cae4:	2f dd       	sub	sp,-12
8000cae6:	d8 32       	popm	r0-r7,pc

8000cae8 <__avr32_umod64>:
8000cae8:	d4 31       	pushm	r0-r7,lr
8000caea:	1a 97       	mov	r7,sp
8000caec:	20 3d       	sub	sp,12
8000caee:	10 9c       	mov	r12,r8
8000caf0:	12 95       	mov	r5,r9
8000caf2:	14 9e       	mov	lr,r10
8000caf4:	16 91       	mov	r1,r11
8000caf6:	16 96       	mov	r6,r11
8000caf8:	58 09       	cp.w	r9,0
8000cafa:	e0 81 00 81 	brne	8000cbfc <__avr32_umod64+0x114>
8000cafe:	16 38       	cp.w	r8,r11
8000cb00:	e0 88 00 12 	brls	8000cb24 <__avr32_umod64+0x3c>
8000cb04:	f0 08 12 00 	clz	r8,r8
8000cb08:	c4 e0       	breq	8000cba4 <__avr32_umod64+0xbc>
8000cb0a:	f6 08 09 46 	lsl	r6,r11,r8
8000cb0e:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb12:	f0 0b 11 20 	rsub	r11,r8,32
8000cb16:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb1a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cb1e:	f7 e6 10 06 	or	r6,r11,r6
8000cb22:	c4 18       	rjmp	8000cba4 <__avr32_umod64+0xbc>
8000cb24:	58 08       	cp.w	r8,0
8000cb26:	c0 51       	brne	8000cb30 <__avr32_umod64+0x48>
8000cb28:	30 19       	mov	r9,1
8000cb2a:	f2 08 0d 08 	divu	r8,r9,r8
8000cb2e:	10 9c       	mov	r12,r8
8000cb30:	f8 08 12 00 	clz	r8,r12
8000cb34:	c0 31       	brne	8000cb3a <__avr32_umod64+0x52>
8000cb36:	18 16       	sub	r6,r12
8000cb38:	c3 68       	rjmp	8000cba4 <__avr32_umod64+0xbc>
8000cb3a:	f0 03 11 20 	rsub	r3,r8,32
8000cb3e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cb42:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb46:	ec 08 09 49 	lsl	r9,r6,r8
8000cb4a:	ec 03 0a 43 	lsr	r3,r6,r3
8000cb4e:	f7 e9 10 09 	or	r9,r11,r9
8000cb52:	f8 05 16 10 	lsr	r5,r12,0x10
8000cb56:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cb5a:	e6 05 0d 02 	divu	r2,r3,r5
8000cb5e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cb62:	ec 02 02 4b 	mul	r11,r6,r2
8000cb66:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cb6a:	16 3e       	cp.w	lr,r11
8000cb6c:	c0 72       	brcc	8000cb7a <__avr32_umod64+0x92>
8000cb6e:	18 0e       	add	lr,r12
8000cb70:	18 3e       	cp.w	lr,r12
8000cb72:	c0 43       	brcs	8000cb7a <__avr32_umod64+0x92>
8000cb74:	16 3e       	cp.w	lr,r11
8000cb76:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb7a:	fc 0b 01 03 	sub	r3,lr,r11
8000cb7e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cb82:	e6 05 0d 02 	divu	r2,r3,r5
8000cb86:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb8a:	a5 36       	mul	r6,r2
8000cb8c:	0c 39       	cp.w	r9,r6
8000cb8e:	c0 72       	brcc	8000cb9c <__avr32_umod64+0xb4>
8000cb90:	18 09       	add	r9,r12
8000cb92:	18 39       	cp.w	r9,r12
8000cb94:	c0 43       	brcs	8000cb9c <__avr32_umod64+0xb4>
8000cb96:	0c 39       	cp.w	r9,r6
8000cb98:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb9c:	f2 06 01 06 	sub	r6,r9,r6
8000cba0:	f4 08 09 4e 	lsl	lr,r10,r8
8000cba4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cba8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cbac:	ec 0a 0d 02 	divu	r2,r6,r10
8000cbb0:	fc 09 16 10 	lsr	r9,lr,0x10
8000cbb4:	ea 02 02 4b 	mul	r11,r5,r2
8000cbb8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cbbc:	16 39       	cp.w	r9,r11
8000cbbe:	c0 72       	brcc	8000cbcc <__avr32_umod64+0xe4>
8000cbc0:	18 09       	add	r9,r12
8000cbc2:	18 39       	cp.w	r9,r12
8000cbc4:	c0 43       	brcs	8000cbcc <__avr32_umod64+0xe4>
8000cbc6:	16 39       	cp.w	r9,r11
8000cbc8:	f3 dc e3 09 	addcs	r9,r9,r12
8000cbcc:	f2 0b 01 0b 	sub	r11,r9,r11
8000cbd0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cbd4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cbd8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cbdc:	ea 0a 02 4a 	mul	r10,r5,r10
8000cbe0:	14 3e       	cp.w	lr,r10
8000cbe2:	c0 72       	brcc	8000cbf0 <__avr32_umod64+0x108>
8000cbe4:	18 0e       	add	lr,r12
8000cbe6:	18 3e       	cp.w	lr,r12
8000cbe8:	c0 43       	brcs	8000cbf0 <__avr32_umod64+0x108>
8000cbea:	14 3e       	cp.w	lr,r10
8000cbec:	fd dc e3 0e 	addcs	lr,lr,r12
8000cbf0:	fc 0a 01 0a 	sub	r10,lr,r10
8000cbf4:	30 0b       	mov	r11,0
8000cbf6:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cbfa:	c7 b8       	rjmp	8000ccf0 <__avr32_umod64+0x208>
8000cbfc:	16 39       	cp.w	r9,r11
8000cbfe:	e0 8b 00 79 	brhi	8000ccf0 <__avr32_umod64+0x208>
8000cc02:	f2 09 12 00 	clz	r9,r9
8000cc06:	c1 21       	brne	8000cc2a <__avr32_umod64+0x142>
8000cc08:	10 3a       	cp.w	r10,r8
8000cc0a:	5f 2b       	srhs	r11
8000cc0c:	0a 31       	cp.w	r1,r5
8000cc0e:	5f ba       	srhi	r10
8000cc10:	f7 ea 10 0a 	or	r10,r11,r10
8000cc14:	f2 0a 18 00 	cp.b	r10,r9
8000cc18:	c0 60       	breq	8000cc24 <__avr32_umod64+0x13c>
8000cc1a:	fc 08 01 0c 	sub	r12,lr,r8
8000cc1e:	e2 05 01 46 	sbc	r6,r1,r5
8000cc22:	18 9e       	mov	lr,r12
8000cc24:	0c 9b       	mov	r11,r6
8000cc26:	1c 9a       	mov	r10,lr
8000cc28:	c6 48       	rjmp	8000ccf0 <__avr32_umod64+0x208>
8000cc2a:	ea 09 09 4c 	lsl	r12,r5,r9
8000cc2e:	f2 06 11 20 	rsub	r6,r9,32
8000cc32:	f6 09 09 4b 	lsl	r11,r11,r9
8000cc36:	f0 09 09 42 	lsl	r2,r8,r9
8000cc3a:	ef 46 ff f4 	st.w	r7[-12],r6
8000cc3e:	f0 06 0a 48 	lsr	r8,r8,r6
8000cc42:	18 48       	or	r8,r12
8000cc44:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cc48:	f4 09 09 43 	lsl	r3,r10,r9
8000cc4c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cc50:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cc54:	16 4a       	or	r10,r11
8000cc56:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cc5a:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc5e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cc62:	08 91       	mov	r1,r4
8000cc64:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cc68:	e8 0e 02 46 	mul	r6,r4,lr
8000cc6c:	0c 3c       	cp.w	r12,r6
8000cc6e:	c0 a2       	brcc	8000cc82 <__avr32_umod64+0x19a>
8000cc70:	20 11       	sub	r1,1
8000cc72:	10 0c       	add	r12,r8
8000cc74:	10 3c       	cp.w	r12,r8
8000cc76:	c0 63       	brcs	8000cc82 <__avr32_umod64+0x19a>
8000cc78:	0c 3c       	cp.w	r12,r6
8000cc7a:	f7 b1 03 01 	sublo	r1,1
8000cc7e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cc82:	0c 1c       	sub	r12,r6
8000cc84:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cc88:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc8c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cc90:	08 96       	mov	r6,r4
8000cc92:	e8 0e 02 4e 	mul	lr,r4,lr
8000cc96:	1c 3b       	cp.w	r11,lr
8000cc98:	c0 a2       	brcc	8000ccac <__avr32_umod64+0x1c4>
8000cc9a:	20 16       	sub	r6,1
8000cc9c:	10 0b       	add	r11,r8
8000cc9e:	10 3b       	cp.w	r11,r8
8000cca0:	c0 63       	brcs	8000ccac <__avr32_umod64+0x1c4>
8000cca2:	1c 3b       	cp.w	r11,lr
8000cca4:	f7 b6 03 01 	sublo	r6,1
8000cca8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ccac:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ccb0:	1c 1b       	sub	r11,lr
8000ccb2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ccb6:	00 9e       	mov	lr,r0
8000ccb8:	02 9c       	mov	r12,r1
8000ccba:	16 3c       	cp.w	r12,r11
8000ccbc:	e0 8b 00 08 	brhi	8000cccc <__avr32_umod64+0x1e4>
8000ccc0:	5f 06       	sreq	r6
8000ccc2:	06 30       	cp.w	r0,r3
8000ccc4:	5f ba       	srhi	r10
8000ccc6:	ed ea 00 0a 	and	r10,r6,r10
8000ccca:	c0 60       	breq	8000ccd6 <__avr32_umod64+0x1ee>
8000cccc:	fc 02 01 04 	sub	r4,lr,r2
8000ccd0:	f8 08 01 4c 	sbc	r12,r12,r8
8000ccd4:	08 9e       	mov	lr,r4
8000ccd6:	e6 0e 01 0a 	sub	r10,r3,lr
8000ccda:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ccde:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cce2:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cce6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ccea:	f8 01 09 4c 	lsl	r12,r12,r1
8000ccee:	18 4a       	or	r10,r12
8000ccf0:	2f dd       	sub	sp,-12
8000ccf2:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 ac 	sub	pc,pc,28844

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 0d 	rcall	80005520 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 06 	rcall	80005520 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c2 ff 	rcall	80005520 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c2 f8 	rcall	80005520 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
