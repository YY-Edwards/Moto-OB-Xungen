
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000acc8  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012a4  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e2a4  8000e2a4  0000e6a4  2**0
                  ALLOC
  6 .data         00000a3c  00000004  8000e2a8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000b5b0  00000a40  8000ece4  0000f240  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00003641  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c4a0  00000000  00000000  00013f39  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000728c  00000000  00000000  000403d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d44e  00000000  00000000  00047665  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003d10  00000000  00000000  00054ab4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007fb6  00000000  00000000  000587c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f385  00000000  00000000  0006077a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001750  00000000  00000000  0006fb00  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 98 	sub	pc,pc,-15464

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d a0       	ld.ub	r0,r6[0x2]

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000203c:	d4 01       	pushm	lr
  log("R");
8000203e:	48 3c       	lddpc	r12,80002048 <app_payload_tx_proc+0xc>
80002040:	f0 1f 00 03 	mcall	8000204c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002044:	d8 02       	popm	pc
80002046:	00 00       	add	r0,r0
80002048:	80 00       	ld.sh	r0,r0[0x0]
8000204a:	d0 00       	acall	0x0
8000204c:	80 00       	ld.sh	r0,r0[0x0]
8000204e:	6f c4       	ld.w	r4,r7[0x70]

80002050 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002050:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
80002052:	48 99       	lddpc	r9,80002074 <app_payload_rx_proc+0x24>
80002054:	13 88       	ld.ub	r8,r9[0x0]
80002056:	2f f8       	sub	r8,-1
80002058:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000205a:	30 39       	mov	r9,3
8000205c:	f2 08 18 00 	cp.b	r8,r9
80002060:	c0 71       	brne	8000206e <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
80002062:	30 09       	mov	r9,0
80002064:	48 48       	lddpc	r8,80002074 <app_payload_rx_proc+0x24>
80002066:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002068:	48 4c       	lddpc	r12,80002078 <app_payload_rx_proc+0x28>
8000206a:	f0 1f 00 05 	mcall	8000207c <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000206e:	48 58       	lddpc	r8,80002080 <app_payload_rx_proc+0x30>
80002070:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
80002072:	d8 02       	popm	pc
80002074:	00 00       	add	r0,r0
80002076:	0a 4f       	or	pc,r5
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	d0 04       	*unknown*
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	6f c4       	ld.w	r4,r7[0x70]
80002080:	00 00       	add	r0,r0
80002082:	0a 4c       	or	r12,r5

80002084 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002084:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002086:	48 3c       	lddpc	r12,80002090 <FD_brdcst_func+0xc>
80002088:	f0 1f 00 03 	mcall	80002094 <FD_brdcst_func+0x10>
	
}
8000208c:	d8 02       	popm	pc
8000208e:	00 00       	add	r0,r0
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	d0 10       	acall	0x1
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	6f c4       	ld.w	r4,r7[0x70]

80002098 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_reply_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_reply_func+0x10>
	
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	d0 30       	acall	0x3
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	6f c4       	ld.w	r4,r7[0x70]

800020ac <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_request_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_request_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	d0 4c       	*unknown*
800020bc:	80 00       	ld.sh	r0,r0[0x0]
800020be:	6f c4       	ld.w	r4,r7[0x70]

800020c0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <EnOB_brdcst_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <EnOB_brdcst_func+0x10>
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 68       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6f c4       	ld.w	r4,r7[0x70]

800020d4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020d4:	eb cd 40 80 	pushm	r7,lr
800020d8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020da:	19 a9       	ld.ub	r9,r12[0x2]
800020dc:	30 08       	mov	r8,0
800020de:	f0 09 18 00 	cp.b	r9,r8
800020e2:	c1 91       	brne	80002114 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020e4:	19 b8       	ld.ub	r8,r12[0x3]
800020e6:	30 19       	mov	r9,1
800020e8:	f2 08 18 00 	cp.b	r8,r9
800020ec:	c0 61       	brne	800020f8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800020ee:	49 0c       	lddpc	r12,8000212c <EnOB_reply_func+0x58>
800020f0:	f0 1f 00 10 	mcall	80002130 <EnOB_reply_func+0x5c>
800020f4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800020f8:	58 08       	cp.w	r8,0
800020fa:	c0 61       	brne	80002106 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800020fc:	48 ec       	lddpc	r12,80002134 <EnOB_reply_func+0x60>
800020fe:	f0 1f 00 0d 	mcall	80002130 <EnOB_reply_func+0x5c>
80002102:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002106:	1a d8       	st.w	--sp,r8
80002108:	48 cc       	lddpc	r12,80002138 <EnOB_reply_func+0x64>
8000210a:	f0 1f 00 0a 	mcall	80002130 <EnOB_reply_func+0x5c>
8000210e:	2f fd       	sub	sp,-4
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002114:	48 ac       	lddpc	r12,8000213c <EnOB_reply_func+0x68>
80002116:	f0 1f 00 07 	mcall	80002130 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000211a:	0f a8       	ld.ub	r8,r7[0x2]
8000211c:	1a d8       	st.w	--sp,r8
8000211e:	48 9c       	lddpc	r12,80002140 <EnOB_reply_func+0x6c>
80002120:	f0 1f 00 04 	mcall	80002130 <EnOB_reply_func+0x5c>
80002124:	2f fd       	sub	sp,-4
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	d0 80       	acall	0x8
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	6f c4       	ld.w	r4,r7[0x70]
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	d0 98       	*unknown*
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	d0 ac       	*unknown*
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	d0 c4       	*unknown*
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	d0 e0       	acall	0xe

80002144 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	eb cd 40 80 	pushm	r7,lr
80002148:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000214a:	19 a9       	ld.ub	r9,r12[0x2]
8000214c:	31 18       	mov	r8,17
8000214e:	f0 09 18 00 	cp.b	r9,r8
80002152:	c0 91       	brne	80002164 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002154:	48 ac       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x38>
80002156:	f0 1f 00 0b 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
8000215a:	30 19       	mov	r9,1
8000215c:	48 a8       	lddpc	r8,80002184 <SingleDetection_brdcst_func+0x40>
8000215e:	b0 89       	st.b	r8[0x0],r9
80002160:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002164:	48 9c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x44>
80002166:	f0 1f 00 07 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
8000216a:	0f a8       	ld.ub	r8,r7[0x2]
8000216c:	1a d8       	st.w	--sp,r8
8000216e:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x48>
80002170:	f0 1f 00 04 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	d0 f8       	*unknown*
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	6f c4       	ld.w	r4,r7[0x70]
80002184:	00 00       	add	r0,r0
80002186:	00 04       	add	r4,r0
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d1 0c       	*unknown*
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d1 1c       	*unknown*

80002190 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002190:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002192:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002196:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002198:	4a bc       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xb4>
8000219a:	f0 1f 00 2c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000219e:	0f 88       	ld.ub	r8,r7[0x0]
800021a0:	1a d8       	st.w	--sp,r8
800021a2:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xbc>
800021a4:	f0 1f 00 29 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021a8:	1a d5       	st.w	--sp,r5
800021aa:	4a ac       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xc0>
800021ac:	f0 1f 00 27 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b0:	0f a8       	ld.ub	r8,r7[0x2]
800021b2:	1a d8       	st.w	--sp,r8
800021b4:	4a 8c       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xc4>
800021b6:	f0 1f 00 25 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ba:	2f dd       	sub	sp,-12
800021bc:	58 05       	cp.w	r5,0
800021be:	c4 10       	breq	80002240 <ButtonConfig_brdcst_func+0xb0>
800021c0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c2:	4a 64       	lddpc	r4,80002258 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021c4:	4a 63       	lddpc	r3,8000225c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021c6:	4a 72       	lddpc	r2,80002260 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021c8:	4a 71       	lddpc	r1,80002264 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ca:	4a 80       	lddpc	r0,80002268 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021cc:	0f b9       	ld.ub	r9,r7[0x3]
800021ce:	0f c8       	ld.ub	r8,r7[0x4]
800021d0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d4:	1a d8       	st.w	--sp,r8
800021d6:	1a d6       	st.w	--sp,r6
800021d8:	08 9c       	mov	r12,r4
800021da:	f0 1f 00 1c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021de:	0f d9       	ld.ub	r9,r7[0x5]
800021e0:	0f e8       	ld.ub	r8,r7[0x6]
800021e2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e6:	1a d8       	st.w	--sp,r8
800021e8:	1a d6       	st.w	--sp,r6
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 17 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f0:	0f f9       	ld.ub	r9,r7[0x7]
800021f2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021f6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fa:	1a d8       	st.w	--sp,r8
800021fc:	1a d6       	st.w	--sp,r6
800021fe:	04 9c       	mov	r12,r2
80002200:	f0 1f 00 12 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002204:	ef 39 00 09 	ld.ub	r9,r7[9]
80002208:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000220c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002210:	1a d8       	st.w	--sp,r8
80002212:	1a d6       	st.w	--sp,r6
80002214:	02 9c       	mov	r12,r1
80002216:	f0 1f 00 0d 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221a:	2f 8d       	sub	sp,-32
8000221c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002220:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	00 9c       	mov	r12,r0
8000222e:	f0 1f 00 07 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
80002232:	2f f6       	sub	r6,-1
80002234:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002236:	2f ed       	sub	sp,-8
80002238:	ec 05 18 00 	cp.b	r5,r6
8000223c:	fe 9b ff c8 	brhi	800021cc <ButtonConfig_brdcst_func+0x3c>
80002240:	d8 32       	popm	r0-r7,pc
80002242:	00 00       	add	r0,r0
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	d1 30       	acall	0x13
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	6f c4       	ld.w	r4,r7[0x70]
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	d1 50       	acall	0x15
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	d1 64       	*unknown*
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	d1 7c       	*unknown*
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	d1 9c       	*unknown*
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	d1 c4       	*unknown*
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	d1 ec       	*unknown*
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	d2 10       	acall	0x21
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d2 38       	*unknown*

8000226c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000226c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002270:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002274:	0f 89       	ld.ub	r9,r7[0x0]
80002276:	30 08       	mov	r8,0
80002278:	f0 09 18 00 	cp.b	r9,r8
8000227c:	c0 c1       	brne	80002294 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000227e:	48 9c       	lddpc	r12,800022a0 <ButtonConfig_reply_func+0x34>
80002280:	f0 1f 00 09 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002284:	0f 98       	ld.ub	r8,r7[0x1]
80002286:	1a d8       	st.w	--sp,r8
80002288:	48 8c       	lddpc	r12,800022a8 <ButtonConfig_reply_func+0x3c>
8000228a:	f0 1f 00 07 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000228e:	2f fd       	sub	sp,-4
80002290:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002294:	48 6c       	lddpc	r12,800022ac <ButtonConfig_reply_func+0x40>
80002296:	f0 1f 00 04 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000229a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000229e:	00 00       	add	r0,r0
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d2 5c       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	6f c4       	ld.w	r4,r7[0x70]
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d1 50       	acall	0x15
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d2 74       	*unknown*

800022b0 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022b4:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022b8:	0f 89       	ld.ub	r9,r7[0x0]
800022ba:	30 08       	mov	r8,0
800022bc:	f0 09 18 00 	cp.b	r9,r8
800022c0:	c0 51       	brne	800022ca <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
800022c2:	48 7c       	lddpc	r12,800022dc <BatteryLevel_brdcst_func+0x2c>
800022c4:	f0 1f 00 07 	mcall	800022e0 <BatteryLevel_brdcst_func+0x30>
800022c8:	c0 48       	rjmp	800022d0 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
800022ca:	48 7c       	lddpc	r12,800022e4 <BatteryLevel_brdcst_func+0x34>
800022cc:	f0 1f 00 05 	mcall	800022e0 <BatteryLevel_brdcst_func+0x30>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022d0:	0f 89       	ld.ub	r9,r7[0x0]
800022d2:	48 68       	lddpc	r8,800022e8 <BatteryLevel_brdcst_func+0x38>
800022d4:	b0 89       	st.b	r8[0x0],r9

}
800022d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	d2 90       	acall	0x29
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	6f c4       	ld.w	r4,r7[0x70]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	d2 a0       	acall	0x2a
800022e8:	00 00       	add	r0,r0
800022ea:	0a 41       	or	r1,r5

800022ec <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022ec:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022ee:	19 a8       	ld.ub	r8,r12[0x2]
800022f0:	30 19       	mov	r9,1
800022f2:	f2 08 18 00 	cp.b	r8,r9
800022f6:	c0 51       	brne	80002300 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
800022f8:	48 6c       	lddpc	r12,80002310 <ShutDown_brdcst_func+0x24>
800022fa:	f0 1f 00 07 	mcall	80002314 <ShutDown_brdcst_func+0x28>
800022fe:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002300:	30 29       	mov	r9,2
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 41       	brne	8000230e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002308:	48 4c       	lddpc	r12,80002318 <ShutDown_brdcst_func+0x2c>
8000230a:	f0 1f 00 03 	mcall	80002314 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	d2 b4       	*unknown*
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	6f c4       	ld.w	r4,r7[0x70]
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	d2 c8       	*unknown*

8000231c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000231c:	eb cd 40 80 	pushm	r7,lr
80002320:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002322:	19 a9       	ld.ub	r9,r12[0x2]
80002324:	30 08       	mov	r8,0
80002326:	f0 09 18 00 	cp.b	r9,r8
8000232a:	c0 61       	brne	80002336 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000232c:	48 dc       	lddpc	r12,80002360 <DataSession_reply_func+0x44>
8000232e:	f0 1f 00 0e 	mcall	80002364 <DataSession_reply_func+0x48>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002336:	48 dc       	lddpc	r12,80002368 <DataSession_reply_func+0x4c>
80002338:	f0 1f 00 0b 	mcall	80002364 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000233c:	0f a8       	ld.ub	r8,r7[0x2]
8000233e:	1a d8       	st.w	--sp,r8
80002340:	48 bc       	lddpc	r12,8000236c <DataSession_reply_func+0x50>
80002342:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002346:	0f b8       	ld.ub	r8,r7[0x3]
80002348:	1a d8       	st.w	--sp,r8
8000234a:	48 ac       	lddpc	r12,80002370 <DataSession_reply_func+0x54>
8000234c:	f0 1f 00 06 	mcall	80002364 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002350:	0f c8       	ld.ub	r8,r7[0x4]
80002352:	1a d8       	st.w	--sp,r8
80002354:	48 8c       	lddpc	r12,80002374 <DataSession_reply_func+0x58>
80002356:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x48>
8000235a:	2f dd       	sub	sp,-12
8000235c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	d2 d8       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	6f c4       	ld.w	r4,r7[0x70]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	d2 e8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d2 f8       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d3 08       	*unknown*
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	d3 14       	*unknown*

80002378 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002378:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000237c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002380:	0f 98       	ld.ub	r8,r7[0x1]
80002382:	1a d8       	st.w	--sp,r8
80002384:	48 bc       	lddpc	r12,800023b0 <CallControl_brdcst_func+0x38>
80002386:	f0 1f 00 0c 	mcall	800023b4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000238a:	2f fd       	sub	sp,-4
8000238c:	0f 99       	ld.ub	r9,r7[0x1]
8000238e:	30 38       	mov	r8,3
80002390:	f0 09 18 00 	cp.b	r9,r8
80002394:	c0 41       	brne	8000239c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002396:	30 09       	mov	r9,0
80002398:	48 88       	lddpc	r8,800023b8 <CallControl_brdcst_func+0x40>
8000239a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 48       	mov	r8,4
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023a6:	30 19       	mov	r9,1
800023a8:	48 48       	lddpc	r8,800023b8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
800023ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	d3 20       	acall	0x32
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	6f c4       	ld.w	r4,r7[0x70]
800023b8:	00 00       	add	r0,r0
800023ba:	0a 4e       	or	lr,r5

800023bc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023bc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023c4:	0f 99       	ld.ub	r9,r7[0x1]
800023c6:	30 08       	mov	r8,0
800023c8:	f0 09 18 00 	cp.b	r9,r8
800023cc:	c0 71       	brne	800023da <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023ce:	48 ac       	lddpc	r12,800023f4 <TransmitControl_brdcst_func+0x38>
800023d0:	f0 1f 00 0a 	mcall	800023f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023d4:	30 09       	mov	r9,0
800023d6:	48 a8       	lddpc	r8,800023fc <TransmitControl_brdcst_func+0x40>
800023d8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023da:	0f 99       	ld.ub	r9,r7[0x1]
800023dc:	30 18       	mov	r8,1
800023de:	f0 09 18 00 	cp.b	r9,r8
800023e2:	c0 71       	brne	800023f0 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023e4:	48 7c       	lddpc	r12,80002400 <TransmitControl_brdcst_func+0x44>
800023e6:	f0 1f 00 05 	mcall	800023f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023ea:	30 19       	mov	r9,1
800023ec:	48 48       	lddpc	r8,800023fc <TransmitControl_brdcst_func+0x40>
800023ee:	b0 89       	st.b	r8[0x0],r9
800023f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d3 38       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	6f c4       	ld.w	r4,r7[0x70]
800023fc:	00 00       	add	r0,r0
800023fe:	0a 4d       	or	sp,r5
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d3 50       	acall	0x35

80002404 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002404:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002408:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000240c:	0f 89       	ld.ub	r9,r7[0x0]
8000240e:	30 08       	mov	r8,0
80002410:	f0 09 18 00 	cp.b	r9,r8
80002414:	c1 61       	brne	80002440 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002416:	48 ec       	lddpc	r12,8000244c <TransmitControl_reply_func+0x48>
80002418:	f0 1f 00 0e 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000241c:	0f 98       	ld.ub	r8,r7[0x1]
8000241e:	1a d8       	st.w	--sp,r8
80002420:	48 dc       	lddpc	r12,80002454 <TransmitControl_reply_func+0x50>
80002422:	f0 1f 00 0c 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002426:	0f a8       	ld.ub	r8,r7[0x2]
80002428:	1a d8       	st.w	--sp,r8
8000242a:	48 cc       	lddpc	r12,80002458 <TransmitControl_reply_func+0x54>
8000242c:	f0 1f 00 09 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002430:	0f b8       	ld.ub	r8,r7[0x3]
80002432:	1a d8       	st.w	--sp,r8
80002434:	48 ac       	lddpc	r12,8000245c <TransmitControl_reply_func+0x58>
80002436:	f0 1f 00 07 	mcall	80002450 <TransmitControl_reply_func+0x4c>
8000243a:	2f dd       	sub	sp,-12
8000243c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002440:	48 8c       	lddpc	r12,80002460 <TransmitControl_reply_func+0x5c>
80002442:	f0 1f 00 04 	mcall	80002450 <TransmitControl_reply_func+0x4c>
80002446:	e3 cd 80 80 	ldm	sp++,r7,pc
8000244a:	00 00       	add	r0,r0
8000244c:	80 00       	ld.sh	r0,r0[0x0]
8000244e:	d3 64       	*unknown*
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	6f c4       	ld.w	r4,r7[0x70]
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d3 80       	acall	0x38
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	d3 94       	*unknown*
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 b0       	acall	0x3b
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d3 c0       	acall	0x3c

80002464 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002466:	19 a9       	ld.ub	r9,r12[0x2]
80002468:	30 08       	mov	r8,0
8000246a:	f0 09 18 00 	cp.b	r9,r8
8000246e:	c0 51       	brne	80002478 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002470:	48 4c       	lddpc	r12,80002480 <AudioRoutingControl_reply_func+0x1c>
80002472:	f0 1f 00 05 	mcall	80002484 <AudioRoutingControl_reply_func+0x20>
80002476:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x24>
8000247a:	f0 1f 00 03 	mcall	80002484 <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	d3 d8       	*unknown*
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	6f c4       	ld.w	r4,r7[0x70]
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d3 e8       	*unknown*

8000248c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000248c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002490:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002494:	0f 89       	ld.ub	r9,r7[0x0]
80002496:	30 08       	mov	r8,0
80002498:	f0 09 18 00 	cp.b	r9,r8
8000249c:	c1 b1       	brne	800024d2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000249e:	0f b8       	ld.ub	r8,r7[0x3]
800024a0:	31 09       	mov	r9,16
800024a2:	f2 08 18 00 	cp.b	r8,r9
800024a6:	c0 f1       	brne	800024c4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024a8:	48 dc       	lddpc	r12,800024dc <Volume_reply_func+0x50>
800024aa:	f0 1f 00 0e 	mcall	800024e0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024ae:	0f 99       	ld.ub	r9,r7[0x1]
800024b0:	0f a8       	ld.ub	r8,r7[0x2]
800024b2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024b6:	1a d8       	st.w	--sp,r8
800024b8:	48 bc       	lddpc	r12,800024e4 <Volume_reply_func+0x58>
800024ba:	f0 1f 00 0a 	mcall	800024e0 <Volume_reply_func+0x54>
800024be:	2f fd       	sub	sp,-4
800024c0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024c4:	1a d8       	st.w	--sp,r8
800024c6:	48 9c       	lddpc	r12,800024e8 <Volume_reply_func+0x5c>
800024c8:	f0 1f 00 06 	mcall	800024e0 <Volume_reply_func+0x54>
800024cc:	2f fd       	sub	sp,-4
800024ce:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024d2:	48 7c       	lddpc	r12,800024ec <Volume_reply_func+0x60>
800024d4:	f0 1f 00 03 	mcall	800024e0 <Volume_reply_func+0x54>
800024d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d3 fc       	*unknown*
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	6f c4       	ld.w	r4,r7[0x70]
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d4 10       	acall	0x41
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	d4 2c       	*unknown*
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d4 44       	*unknown*

800024f0 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f0:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024f2:	19 d9       	ld.ub	r9,r12[0x5]
800024f4:	30 08       	mov	r8,0
800024f6:	f0 09 18 00 	cp.b	r9,r8
800024fa:	c0 81       	brne	8000250a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024fc:	10 99       	mov	r9,r8
800024fe:	48 78       	lddpc	r8,80002518 <spk_brdcst_func+0x28>
80002500:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002502:	48 7c       	lddpc	r12,8000251c <spk_brdcst_func+0x2c>
80002504:	f0 1f 00 07 	mcall	80002520 <spk_brdcst_func+0x30>
80002508:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000250a:	30 19       	mov	r9,1
8000250c:	48 38       	lddpc	r8,80002518 <spk_brdcst_func+0x28>
8000250e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002510:	48 5c       	lddpc	r12,80002524 <spk_brdcst_func+0x34>
80002512:	f0 1f 00 04 	mcall	80002520 <spk_brdcst_func+0x30>
80002516:	d8 02       	popm	pc
80002518:	00 00       	add	r0,r0
8000251a:	0a 40       	or	r0,r5
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	d4 5c       	*unknown*
80002520:	80 00       	ld.sh	r0,r0[0x0]
80002522:	6f c4       	ld.w	r4,r7[0x70]
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d4 6c       	*unknown*

80002528 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002528:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000252a:	19 a9       	ld.ub	r9,r12[0x2]
8000252c:	30 08       	mov	r8,0
8000252e:	f0 09 18 00 	cp.b	r9,r8
80002532:	c0 f1       	brne	80002550 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002534:	19 e9       	ld.ub	r9,r12[0x6]
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 40       	breq	80002542 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000253c:	30 19       	mov	r9,1
8000253e:	48 98       	lddpc	r8,80002560 <spk_reply_func+0x38>
80002540:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002542:	19 e8       	ld.ub	r8,r12[0x6]
80002544:	1a d8       	st.w	--sp,r8
80002546:	48 8c       	lddpc	r12,80002564 <spk_reply_func+0x3c>
80002548:	f0 1f 00 08 	mcall	80002568 <spk_reply_func+0x40>
8000254c:	2f fd       	sub	sp,-4
8000254e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002550:	30 09       	mov	r9,0
80002552:	48 48       	lddpc	r8,80002560 <spk_reply_func+0x38>
80002554:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002556:	48 6c       	lddpc	r12,8000256c <spk_reply_func+0x44>
80002558:	f0 1f 00 04 	mcall	80002568 <spk_reply_func+0x40>
8000255c:	d8 02       	popm	pc
8000255e:	00 00       	add	r0,r0
80002560:	00 00       	add	r0,r0
80002562:	0a 40       	or	r0,r5
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	d4 78       	*unknown*
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	6f c4       	ld.w	r4,r7[0x70]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d4 88       	*unknown*

80002570 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002570:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002574:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002578:	0f a9       	ld.ub	r9,r7[0x2]
8000257a:	30 08       	mov	r8,0
8000257c:	f0 09 18 00 	cp.b	r9,r8
80002580:	c0 71       	brne	8000258e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002582:	48 dc       	lddpc	r12,800025b4 <mic_brdcst_func+0x44>
80002584:	f0 1f 00 0d 	mcall	800025b8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002588:	30 09       	mov	r9,0
8000258a:	48 d8       	lddpc	r8,800025bc <mic_brdcst_func+0x4c>
8000258c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000258e:	0f a9       	ld.ub	r9,r7[0x2]
80002590:	31 18       	mov	r8,17
80002592:	f0 09 18 00 	cp.b	r9,r8
80002596:	c0 d1       	brne	800025b0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002598:	48 ac       	lddpc	r12,800025c0 <mic_brdcst_func+0x50>
8000259a:	f0 1f 00 08 	mcall	800025b8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
8000259e:	48 89       	lddpc	r9,800025bc <mic_brdcst_func+0x4c>
800025a0:	30 18       	mov	r8,1
800025a2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025a4:	13 89       	ld.ub	r9,r9[0x0]
800025a6:	f0 09 18 00 	cp.b	r9,r8
800025aa:	c0 31       	brne	800025b0 <mic_brdcst_func+0x40>
800025ac:	48 68       	lddpc	r8,800025c4 <mic_brdcst_func+0x54>
800025ae:	11 88       	ld.ub	r8,r8[0x0]
800025b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	d4 94       	*unknown*
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	6f c4       	ld.w	r4,r7[0x70]
800025bc:	00 00       	add	r0,r0
800025be:	0a 5c       	eor	r12,r5
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	d4 a8       	*unknown*
800025c4:	00 00       	add	r0,r0
800025c6:	0a 4e       	or	lr,r5

800025c8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025cc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d0:	49 ac       	lddpc	r12,80002638 <mic_reply_func+0x70>
800025d2:	f0 1f 00 1b 	mcall	8000263c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025d6:	0f 89       	ld.ub	r9,r7[0x0]
800025d8:	30 08       	mov	r8,0
800025da:	f0 09 18 00 	cp.b	r9,r8
800025de:	c2 71       	brne	8000262c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e0:	0f 98       	ld.ub	r8,r7[0x1]
800025e2:	30 29       	mov	r9,2
800025e4:	f2 08 18 00 	cp.b	r8,r9
800025e8:	c1 b1       	brne	8000261e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025ea:	49 6c       	lddpc	r12,80002640 <mic_reply_func+0x78>
800025ec:	f0 1f 00 14 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f0:	0f a8       	ld.ub	r8,r7[0x2]
800025f2:	1a d8       	st.w	--sp,r8
800025f4:	49 4c       	lddpc	r12,80002644 <mic_reply_func+0x7c>
800025f6:	f0 1f 00 12 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025fa:	0f b8       	ld.ub	r8,r7[0x3]
800025fc:	1a d8       	st.w	--sp,r8
800025fe:	49 3c       	lddpc	r12,80002648 <mic_reply_func+0x80>
80002600:	f0 1f 00 0f 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002604:	0f c8       	ld.ub	r8,r7[0x4]
80002606:	1a d8       	st.w	--sp,r8
80002608:	49 1c       	lddpc	r12,8000264c <mic_reply_func+0x84>
8000260a:	f0 1f 00 0d 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000260e:	0f d8       	ld.ub	r8,r7[0x5]
80002610:	1a d8       	st.w	--sp,r8
80002612:	49 0c       	lddpc	r12,80002650 <mic_reply_func+0x88>
80002614:	f0 1f 00 0a 	mcall	8000263c <mic_reply_func+0x74>
80002618:	2f cd       	sub	sp,-16
8000261a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000261e:	1a d8       	st.w	--sp,r8
80002620:	48 dc       	lddpc	r12,80002654 <mic_reply_func+0x8c>
80002622:	f0 1f 00 07 	mcall	8000263c <mic_reply_func+0x74>
80002626:	2f fd       	sub	sp,-4
80002628:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000262c:	48 bc       	lddpc	r12,80002658 <mic_reply_func+0x90>
8000262e:	f0 1f 00 04 	mcall	8000263c <mic_reply_func+0x74>
80002632:	e3 cd 80 80 	ldm	sp++,r7,pc
80002636:	00 00       	add	r0,r0
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	d4 bc       	*unknown*
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	6f c4       	ld.w	r4,r7[0x70]
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	d4 cc       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	d4 e0       	acall	0x4e
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 f4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	d5 10       	acall	0x51
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d5 28       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d5 40       	acall	0x54
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d5 58       	*unknown*

8000265c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000265c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002660:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002664:	48 bc       	lddpc	r12,80002690 <dcm_brdcst_func+0x34>
80002666:	f0 1f 00 0c 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000266a:	0f 88       	ld.ub	r8,r7[0x0]
8000266c:	1a d8       	st.w	--sp,r8
8000266e:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x3c>
80002670:	f0 1f 00 09 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002674:	0f a8       	ld.ub	r8,r7[0x2]
80002676:	1a d8       	st.w	--sp,r8
80002678:	48 9c       	lddpc	r12,8000269c <dcm_brdcst_func+0x40>
8000267a:	f0 1f 00 07 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000267e:	0f 98       	ld.ub	r8,r7[0x1]
80002680:	1a d8       	st.w	--sp,r8
80002682:	48 8c       	lddpc	r12,800026a0 <dcm_brdcst_func+0x44>
80002684:	f0 1f 00 04 	mcall	80002694 <dcm_brdcst_func+0x38>
80002688:	2f dd       	sub	sp,-12
	
	
}
8000268a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000268e:	00 00       	add	r0,r0
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	d5 68       	*unknown*
80002694:	80 00       	ld.sh	r0,r0[0x0]
80002696:	6f c4       	ld.w	r4,r7[0x70]
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d5 7c       	*unknown*
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	d5 90       	acall	0x59
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 a8       	*unknown*

800026a4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026a4:	eb cd 40 80 	pushm	r7,lr
800026a8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026aa:	19 a9       	ld.ub	r9,r12[0x2]
800026ac:	30 08       	mov	r8,0
800026ae:	f0 09 18 00 	cp.b	r9,r8
800026b2:	c1 b1       	brne	800026e8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026b4:	19 b8       	ld.ub	r8,r12[0x3]
800026b6:	30 19       	mov	r9,1
800026b8:	f2 08 18 00 	cp.b	r8,r9
800026bc:	c0 51       	brne	800026c6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026be:	48 ec       	lddpc	r12,800026f4 <dcm_reply_func+0x50>
800026c0:	f0 1f 00 0e 	mcall	800026f8 <dcm_reply_func+0x54>
800026c4:	c0 a8       	rjmp	800026d8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026c6:	58 08       	cp.w	r8,0
800026c8:	c0 51       	brne	800026d2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026ca:	48 dc       	lddpc	r12,800026fc <dcm_reply_func+0x58>
800026cc:	f0 1f 00 0b 	mcall	800026f8 <dcm_reply_func+0x54>
800026d0:	c0 48       	rjmp	800026d8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026d2:	48 cc       	lddpc	r12,80002700 <dcm_reply_func+0x5c>
800026d4:	f0 1f 00 09 	mcall	800026f8 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026d8:	0f d8       	ld.ub	r8,r7[0x5]
800026da:	1a d8       	st.w	--sp,r8
800026dc:	48 ac       	lddpc	r12,80002704 <dcm_reply_func+0x60>
800026de:	f0 1f 00 07 	mcall	800026f8 <dcm_reply_func+0x54>
800026e2:	2f fd       	sub	sp,-4
800026e4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026e8:	48 8c       	lddpc	r12,80002708 <dcm_reply_func+0x64>
800026ea:	f0 1f 00 04 	mcall	800026f8 <dcm_reply_func+0x54>
800026ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800026f2:	00 00       	add	r0,r0
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	d5 c4       	*unknown*
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	6f c4       	ld.w	r4,r7[0x70]
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d5 d8       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	d5 ec       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d6 00       	acall	0x60
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d6 0c       	*unknown*

8000270c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000270c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000270e:	19 a9       	ld.ub	r9,r12[0x2]
80002710:	30 08       	mov	r8,0
80002712:	f0 09 18 00 	cp.b	r9,r8
80002716:	c0 51       	brne	80002720 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002718:	48 4c       	lddpc	r12,80002728 <ToneControl_reply_func+0x1c>
8000271a:	f0 1f 00 05 	mcall	8000272c <ToneControl_reply_func+0x20>
8000271e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x24>
80002722:	f0 1f 00 03 	mcall	8000272c <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	d6 18       	*unknown*
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	6f c4       	ld.w	r4,r7[0x70]
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d6 24       	*unknown*

80002734 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002734:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002736:	49 1c       	lddpc	r12,80002778 <app_init+0x44>
80002738:	f0 1f 00 11 	mcall	8000277c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000273c:	49 1b       	lddpc	r11,80002780 <app_init+0x4c>
8000273e:	49 2c       	lddpc	r12,80002784 <app_init+0x50>
80002740:	f0 1f 00 12 	mcall	80002788 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002744:	f0 1f 00 12 	mcall	8000278c <app_init+0x58>
80002748:	49 28       	lddpc	r8,80002790 <app_init+0x5c>
8000274a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000274c:	70 08       	ld.w	r8,r8[0x0]
8000274e:	58 08       	cp.w	r8,0
80002750:	c0 41       	brne	80002758 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002752:	49 1c       	lddpc	r12,80002794 <app_init+0x60>
80002754:	f0 1f 00 11 	mcall	80002798 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002758:	30 09       	mov	r9,0
8000275a:	1a d9       	st.w	--sp,r9
8000275c:	1a d9       	st.w	--sp,r9
8000275e:	1a d9       	st.w	--sp,r9
80002760:	30 18       	mov	r8,1
80002762:	e0 6a 03 20 	mov	r10,800
80002766:	48 eb       	lddpc	r11,8000279c <app_init+0x68>
80002768:	48 ec       	lddpc	r12,800027a0 <app_init+0x6c>
8000276a:	f0 1f 00 0f 	mcall	800027a4 <app_init+0x70>
8000276e:	48 f8       	lddpc	r8,800027a8 <app_init+0x74>
80002770:	91 0c       	st.w	r8[0x0],r12
80002772:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002774:	d8 02       	popm	pc
80002776:	00 00       	add	r0,r0
80002778:	00 00       	add	r0,r0
8000277a:	00 08       	add	r8,r0
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	3f 08       	mov	r8,-16
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	20 3c       	sub	r12,3
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	20 50       	sub	r0,5
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	2b b0       	sub	r0,-69
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	64 8c       	ld.w	r12,r2[0x20]
80002790:	00 00       	add	r0,r0
80002792:	0a 60       	and	r0,r5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	d6 30       	acall	0x63
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	6f c4       	ld.w	r4,r7[0x70]
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	d6 5c       	*unknown*
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	27 ac       	sub	r12,122
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	6c 00       	ld.w	r0,r6[0x0]
800027a8:	00 00       	add	r0,r0
800027aa:	0a 58       	eor	r8,r5

800027ac <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027ac:	d4 31       	pushm	r0-r7,lr
800027ae:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027b0:	31 ac       	mov	r12,26
800027b2:	f0 1f 00 59 	mcall	80002914 <app_cfg+0x168>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027b6:	f0 1f 00 59 	mcall	80002918 <app_cfg+0x16c>
800027ba:	4d 98       	lddpc	r8,8000291c <app_cfg+0x170>
800027bc:	91 0c       	st.w	r8[0x0],r12
	
	/* 'Give' the semaphore to unblock the task. */
	 //if( xBinarySemaphore != NULL ){
		//xSemaphoreGive(xBinarySemaphore);
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
800027be:	4d 98       	lddpc	r8,80002920 <app_cfg+0x174>
800027c0:	70 0c       	ld.w	r12,r8[0x0]
800027c2:	30 09       	mov	r9,0
800027c4:	3f fa       	mov	r10,-1
800027c6:	12 9b       	mov	r11,r9
800027c8:	f0 1f 00 57 	mcall	80002924 <app_cfg+0x178>
		
	for(;;)
	{
		switch(OB_State)
800027cc:	4d 77       	lddpc	r7,80002928 <app_cfg+0x17c>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027ce:	4d 86       	lddpc	r6,8000292c <app_cfg+0x180>
				else
				{
					nop();
					nop();
					nop();
					log("connecting...\n");
800027d0:	4d 85       	lddpc	r5,80002930 <app_cfg+0x184>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027d2:	4d 93       	lddpc	r3,80002934 <app_cfg+0x188>
				{
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027d4:	30 c0       	mov	r0,12
800027d6:	30 11       	mov	r1,1
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
		
	for(;;)
	{
		switch(OB_State)
800027d8:	6e 08       	ld.w	r8,r7[0x0]
800027da:	58 08       	cp.w	r8,0
800027dc:	c0 50       	breq	800027e6 <app_cfg+0x3a>
800027de:	58 38       	cp.w	r8,3
800027e0:	e0 81 00 94 	brne	80002908 <app_cfg+0x15c>
800027e4:	c2 08       	rjmp	80002824 <app_cfg+0x78>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027e6:	6c 08       	ld.w	r8,r6[0x0]
800027e8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027ec:	58 38       	cp.w	r8,3
800027ee:	c1 41       	brne	80002816 <app_cfg+0x6a>
800027f0:	07 88       	ld.ub	r8,r3[0x0]
800027f2:	58 08       	cp.w	r8,0
800027f4:	c1 11       	brne	80002816 <app_cfg+0x6a>
				{
					connect_flag=1;
800027f6:	30 18       	mov	r8,1
800027f8:	a6 88       	st.b	r3[0x0],r8
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027fa:	00 9b       	mov	r11,r0
800027fc:	02 9c       	mov	r12,r1
800027fe:	f0 1f 00 4f 	mcall	80002938 <app_cfg+0x18c>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002802:	00 9b       	mov	r11,r0
80002804:	02 9c       	mov	r12,r1
80002806:	f0 1f 00 4d 	mcall	80002938 <app_cfg+0x18c>
					OB_State = OB_WAITINGAPPTASK;
8000280a:	30 38       	mov	r8,3
8000280c:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
8000280e:	4c cc       	lddpc	r12,8000293c <app_cfg+0x190>
80002810:	f0 1f 00 4c 	mcall	80002940 <app_cfg+0x194>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002814:	c7 a8       	rjmp	80002908 <app_cfg+0x15c>
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002816:	d7 03       	nop
					nop();
80002818:	d7 03       	nop
					nop();
8000281a:	d7 03       	nop
					log("connecting...\n");
8000281c:	0a 9c       	mov	r12,r5
8000281e:	f0 1f 00 49 	mcall	80002940 <app_cfg+0x194>
80002822:	c7 38       	rjmp	80002908 <app_cfg+0x15c>
						
					
					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (1000*2) / portTICK_RATE_MS))
80002824:	4c 88       	lddpc	r8,80002944 <app_cfg+0x198>
80002826:	70 0c       	ld.w	r12,r8[0x0]
80002828:	30 09       	mov	r9,0
8000282a:	e0 6a 07 d0 	mov	r10,2000
8000282e:	1a 9b       	mov	r11,sp
80002830:	f0 1f 00 3d 	mcall	80002924 <app_cfg+0x178>
80002834:	58 1c       	cp.w	r12,1
80002836:	c6 51       	brne	80002900 <app_cfg+0x154>
						{
							if(data_ptr!=NULL){//resend message
80002838:	40 08       	lddsp	r8,sp[0x0]
8000283a:	58 08       	cp.w	r8,0
8000283c:	c6 20       	breq	80002900 <app_cfg+0x154>
							
								log("receive Okay!\n");	
8000283e:	4c 3c       	lddpc	r12,80002948 <app_cfg+0x19c>
80002840:	f0 1f 00 40 	mcall	80002940 <app_cfg+0x194>
								xSemaphoreTake(count_mutex, portMAX_DELAY);
80002844:	4c 22       	lddpc	r2,8000294c <app_cfg+0x1a0>
80002846:	64 0c       	ld.w	r12,r2[0x0]
80002848:	30 09       	mov	r9,0
8000284a:	3f fa       	mov	r10,-1
8000284c:	12 9b       	mov	r11,r9
8000284e:	f0 1f 00 36 	mcall	80002924 <app_cfg+0x178>
								global_count--;
80002852:	4c 04       	lddpc	r4,80002950 <app_cfg+0x1a4>
80002854:	68 08       	ld.w	r8,r4[0x0]
80002856:	20 18       	sub	r8,1
80002858:	89 08       	st.w	r4[0x0],r8
								xSemaphoreGive(count_mutex);
8000285a:	64 0c       	ld.w	r12,r2[0x0]
8000285c:	30 09       	mov	r9,0
8000285e:	12 9a       	mov	r10,r9
80002860:	12 9b       	mov	r11,r9
80002862:	f0 1f 00 3d 	mcall	80002954 <app_cfg+0x1a8>
								log("global_count:%d\n", global_count);	
80002866:	68 08       	ld.w	r8,r4[0x0]
80002868:	1a d8       	st.w	--sp,r8
8000286a:	4b cc       	lddpc	r12,80002958 <app_cfg+0x1ac>
8000286c:	f0 1f 00 35 	mcall	80002940 <app_cfg+0x194>
																			
								xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);	
80002870:	36 4a       	mov	r10,100
80002872:	31 ab       	mov	r11,26
80002874:	40 1c       	lddsp	r12,sp[0x4]
80002876:	f0 1f 00 3a 	mcall	8000295c <app_cfg+0x1b0>
								if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) ==pdFALSE)
8000287a:	4a a8       	lddpc	r8,80002920 <app_cfg+0x174>
8000287c:	70 0c       	ld.w	r12,r8[0x0]
8000287e:	30 09       	mov	r9,0
80002880:	e0 6a 9c 40 	mov	r10,40000
80002884:	12 9b       	mov	r11,r9
80002886:	f0 1f 00 28 	mcall	80002924 <app_cfg+0x178>
8000288a:	2f fd       	sub	sp,-4
8000288c:	58 0c       	cp.w	r12,0
8000288e:	c3 11       	brne	800028f0 <app_cfg+0x144>
								{
									
									if (xQueueSend(xg_resend_queue, &data_ptr, 0) != pdPASS)
80002890:	4a d8       	lddpc	r8,80002944 <app_cfg+0x198>
80002892:	70 0c       	ld.w	r12,r8[0x0]
80002894:	30 09       	mov	r9,0
80002896:	12 9a       	mov	r10,r9
80002898:	1a 9b       	mov	r11,sp
8000289a:	f0 1f 00 2f 	mcall	80002954 <app_cfg+0x1a8>
8000289e:	58 1c       	cp.w	r12,1
800028a0:	c1 10       	breq	800028c2 <app_cfg+0x116>
									{
										log("xg_resend_queue: full\n" );
800028a2:	4b 0c       	lddpc	r12,80002960 <app_cfg+0x1b4>
800028a4:	f0 1f 00 27 	mcall	80002940 <app_cfg+0x194>
										xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
800028a8:	32 3b       	mov	r11,35
800028aa:	02 9c       	mov	r12,r1
800028ac:	f0 1f 00 23 	mcall	80002938 <app_cfg+0x18c>
										vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
800028b0:	e0 6c 17 70 	mov	r12,6000
800028b4:	f0 1f 00 2c 	mcall	80002964 <app_cfg+0x1b8>
										xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
800028b8:	32 3b       	mov	r11,35
800028ba:	30 0c       	mov	r12,0
800028bc:	f0 1f 00 1f 	mcall	80002938 <app_cfg+0x18c>
800028c0:	c2 08       	rjmp	80002900 <app_cfg+0x154>
									}
									else{
											
										xSemaphoreTake(count_mutex, portMAX_DELAY);
800028c2:	4a 34       	lddpc	r4,8000294c <app_cfg+0x1a0>
800028c4:	68 0c       	ld.w	r12,r4[0x0]
800028c6:	30 09       	mov	r9,0
800028c8:	3f fa       	mov	r10,-1
800028ca:	12 9b       	mov	r11,r9
800028cc:	f0 1f 00 16 	mcall	80002924 <app_cfg+0x178>
										global_count++;
800028d0:	4a 08       	lddpc	r8,80002950 <app_cfg+0x1a4>
800028d2:	70 09       	ld.w	r9,r8[0x0]
800028d4:	2f f9       	sub	r9,-1
800028d6:	91 09       	st.w	r8[0x0],r9
										xSemaphoreGive(count_mutex);
800028d8:	68 0c       	ld.w	r12,r4[0x0]
800028da:	30 09       	mov	r9,0
800028dc:	12 9a       	mov	r10,r9
800028de:	12 9b       	mov	r11,r9
800028e0:	f0 1f 00 1d 	mcall	80002954 <app_cfg+0x1a8>
										xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
800028e4:	e0 6b 00 b7 	mov	r11,183
800028e8:	02 9c       	mov	r12,r1
800028ea:	f0 1f 00 14 	mcall	80002938 <app_cfg+0x18c>
800028ee:	c0 98       	rjmp	80002900 <app_cfg+0x154>
									}
				
								}	
								else
								{
									set_message_store(data_ptr);
800028f0:	49 e8       	lddpc	r8,80002968 <app_cfg+0x1bc>
800028f2:	70 0c       	ld.w	r12,r8[0x0]
800028f4:	40 0b       	lddsp	r11,sp[0x0]
800028f6:	f0 1f 00 1e 	mcall	8000296c <app_cfg+0x1c0>
									log("send message\n");
800028fa:	49 ec       	lddpc	r12,80002970 <app_cfg+0x1c4>
800028fc:	f0 1f 00 11 	mcall	80002940 <app_cfg+0x194>
							}
						
						}
					}
										
					nop();
80002900:	d7 03       	nop
					log("app task run!\n");
80002902:	49 dc       	lddpc	r12,80002974 <app_cfg+0x1c8>
80002904:	f0 1f 00 0f 	mcall	80002940 <app_cfg+0x194>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002908:	e0 6b 07 d0 	mov	r11,2000
8000290c:	48 4c       	lddpc	r12,8000291c <app_cfg+0x170>
8000290e:	f0 1f 00 1b 	mcall	80002978 <app_cfg+0x1cc>
	}
80002912:	c6 3b       	rjmp	800027d8 <app_cfg+0x2c>
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	60 38       	ld.w	r8,r0[0xc]
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	68 f0       	ld.w	r0,r4[0x3c]
8000291c:	00 00       	add	r0,r0
8000291e:	0a 54       	eor	r4,r5
80002920:	00 00       	add	r0,r0
80002922:	0b 7c       	ld.ub	r12,--r5
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	61 80       	ld.w	r0,r0[0x60]
80002928:	00 00       	add	r0,r0
8000292a:	0a 48       	or	r8,r5
8000292c:	00 00       	add	r0,r0
8000292e:	0d a0       	ld.ub	r0,r6[0x2]
80002930:	80 00       	ld.sh	r0,r0[0x0]
80002932:	d6 78       	*unknown*
80002934:	00 00       	add	r0,r0
80002936:	0a 42       	or	r2,r5
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	40 98       	lddsp	r8,sp[0x24]
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	d6 64       	*unknown*
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	6f c4       	ld.w	r4,r7[0x70]
80002944:	00 00       	add	r0,r0
80002946:	0b 74       	ld.ub	r4,--r5
80002948:	80 00       	ld.sh	r0,r0[0x0]
8000294a:	d6 88       	*unknown*
8000294c:	00 00       	add	r0,r0
8000294e:	0a 60       	and	r0,r5
80002950:	00 00       	add	r0,r0
80002952:	0a 44       	or	r4,r5
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	63 8c       	ld.w	r12,r1[0x60]
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	d6 98       	*unknown*
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	3f 5c       	mov	r12,-11
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	d6 ac       	*unknown*
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	6a 58       	ld.w	r8,r5[0x14]
80002968:	00 00       	add	r0,r0
8000296a:	0b 78       	ld.ub	r8,--r5
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	2c 30       	sub	r0,-61
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	d6 c4       	*unknown*
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	d6 d4       	*unknown*
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	6a a0       	ld.w	r0,r5[0x28]

8000297c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000297c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002980:	19 c7       	ld.ub	r7,r12[0x4]
80002982:	19 d8       	ld.ub	r8,r12[0x5]
80002984:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002988:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000298a:	48 dc       	lddpc	r12,800029bc <Phyuserinput_brdcst_func+0x40>
8000298c:	f0 1f 00 0d 	mcall	800029c0 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002990:	36 08       	mov	r8,96
80002992:	f0 07 19 00 	cp.h	r7,r8
80002996:	c1 11       	brne	800029b8 <Phyuserinput_brdcst_func+0x3c>
80002998:	48 b8       	lddpc	r8,800029c4 <Phyuserinput_brdcst_func+0x48>
8000299a:	11 89       	ld.ub	r9,r8[0x0]
8000299c:	30 18       	mov	r8,1
8000299e:	f0 09 18 00 	cp.b	r9,r8
800029a2:	c0 b1       	brne	800029b8 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
800029a4:	34 5b       	mov	r11,69
800029a6:	30 1c       	mov	r12,1
800029a8:	f0 1f 00 08 	mcall	800029c8 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
800029ac:	e0 6c 07 d0 	mov	r12,2000
800029b0:	f0 1f 00 07 	mcall	800029cc <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message	
		scan_rfid_save_message();//scan and save message	
800029b4:	f0 1f 00 07 	mcall	800029d0 <Phyuserinput_brdcst_func+0x54>
800029b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	d6 e4       	*unknown*
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	6f c4       	ld.w	r4,r7[0x70]
800029c4:	00 00       	add	r0,r0
800029c6:	0a 42       	or	r2,r5
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	40 98       	lddsp	r8,sp[0x24]
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	6a 58       	ld.w	r8,r5[0x14]
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	50 fc       	stdsp	sp[0x3c],r12

800029d4 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800029d4:	d4 21       	pushm	r4-r7,lr
800029d6:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800029d8:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800029dc:	0d 88       	ld.ub	r8,r6[0x0]
800029de:	32 49       	mov	r9,36
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c2 a1       	brne	80002a38 <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800029e6:	4c ac       	lddpc	r12,80002b0c <DataSession_brdcst_func+0x138>
800029e8:	f0 1f 00 4a 	mcall	80002b10 <DataSession_brdcst_func+0x13c>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800029ec:	0d a5       	ld.ub	r5,r6[0x2]
800029ee:	0d b8       	ld.ub	r8,r6[0x3]
800029f0:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800029f4:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800029f6:	0d 98       	ld.ub	r8,r6[0x1]
800029f8:	1a d8       	st.w	--sp,r8
800029fa:	4c 7c       	lddpc	r12,80002b14 <DataSession_brdcst_func+0x140>
800029fc:	f0 1f 00 45 	mcall	80002b10 <DataSession_brdcst_func+0x13c>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002a00:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002a04:	1a d8       	st.w	--sp,r8
80002a06:	4c 5c       	lddpc	r12,80002b18 <DataSession_brdcst_func+0x144>
80002a08:	f0 1f 00 42 	mcall	80002b10 <DataSession_brdcst_func+0x13c>
		for(i=0; i<data_length; i++)
80002a0c:	2f ed       	sub	sp,-8
80002a0e:	58 05       	cp.w	r5,0
80002a10:	e0 80 00 7b 	breq	80002b06 <DataSession_brdcst_func+0x132>
80002a14:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002a16:	4c 24       	lddpc	r4,80002b1c <DataSession_brdcst_func+0x148>
80002a18:	ec 07 00 08 	add	r8,r6,r7
80002a1c:	11 c8       	ld.ub	r8,r8[0x4]
80002a1e:	1a d8       	st.w	--sp,r8
80002a20:	1a d7       	st.w	--sp,r7
80002a22:	08 9c       	mov	r12,r4
80002a24:	f0 1f 00 3b 	mcall	80002b10 <DataSession_brdcst_func+0x13c>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002a28:	2f f7       	sub	r7,-1
80002a2a:	5c 57       	castu.b	r7
80002a2c:	2f ed       	sub	sp,-8
80002a2e:	ee 05 19 00 	cp.h	r5,r7
80002a32:	fe 9b ff f3 	brhi	80002a18 <DataSession_brdcst_func+0x44>
80002a36:	c6 88       	rjmp	80002b06 <DataSession_brdcst_func+0x132>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002a38:	1a d8       	st.w	--sp,r8
80002a3a:	4b ac       	lddpc	r12,80002b20 <DataSession_brdcst_func+0x14c>
80002a3c:	f0 1f 00 35 	mcall	80002b10 <DataSession_brdcst_func+0x13c>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002a40:	0d 88       	ld.ub	r8,r6[0x0]
80002a42:	2f fd       	sub	sp,-4
80002a44:	30 39       	mov	r9,3
80002a46:	f2 08 18 00 	cp.b	r8,r9
80002a4a:	c0 d1       	brne	80002a64 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002a4c:	4b 6c       	lddpc	r12,80002b24 <DataSession_brdcst_func+0x150>
80002a4e:	f0 1f 00 31 	mcall	80002b10 <DataSession_brdcst_func+0x13c>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002a52:	e0 6c 07 d0 	mov	r12,2000
80002a56:	f0 1f 00 35 	mcall	80002b28 <DataSession_brdcst_func+0x154>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002a5a:	37 7b       	mov	r11,119
80002a5c:	30 1c       	mov	r12,1
80002a5e:	f0 1f 00 34 	mcall	80002b2c <DataSession_brdcst_func+0x158>
80002a62:	c4 b8       	rjmp	80002af8 <DataSession_brdcst_func+0x124>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002a64:	30 49       	mov	r9,4
80002a66:	f2 08 18 00 	cp.b	r8,r9
80002a6a:	c4 71       	brne	80002af8 <DataSession_brdcst_func+0x124>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002a6c:	31 aa       	mov	r10,26
80002a6e:	ec cb ff fc 	sub	r11,r6,-4
80002a72:	fa cc ff fe 	sub	r12,sp,-2
80002a76:	f0 1f 00 2f 	mcall	80002b30 <DataSession_brdcst_func+0x15c>

			Message_Protocol_t * myptr = get_message_store();	
80002a7a:	4a f8       	lddpc	r8,80002b34 <DataSession_brdcst_func+0x160>
80002a7c:	70 0c       	ld.w	r12,r8[0x0]
80002a7e:	f0 1f 00 2f 	mcall	80002b38 <DataSession_brdcst_func+0x164>
80002a82:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
80002a84:	c3 20       	breq	80002ae8 <DataSession_brdcst_func+0x114>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002a86:	31 aa       	mov	r10,26
80002a88:	fa cb ff fe 	sub	r11,sp,-2
80002a8c:	f0 1f 00 29 	mcall	80002b30 <DataSession_brdcst_func+0x15c>
				//xQueueSend(xg_resend_queue, &myptr, 0);			
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002a90:	4a b8       	lddpc	r8,80002b3c <DataSession_brdcst_func+0x168>
80002a92:	70 0c       	ld.w	r12,r8[0x0]
80002a94:	30 09       	mov	r9,0
80002a96:	12 9a       	mov	r10,r9
80002a98:	fa cb ff e4 	sub	r11,sp,-28
80002a9c:	f0 1f 00 29 	mcall	80002b40 <DataSession_brdcst_func+0x16c>
80002aa0:	58 1c       	cp.w	r12,1
80002aa2:	c1 10       	breq	80002ac4 <DataSession_brdcst_func+0xf0>
				{
					log("xg_resend_queue: full\n" );
80002aa4:	4a 8c       	lddpc	r12,80002b44 <DataSession_brdcst_func+0x170>
80002aa6:	f0 1f 00 1b 	mcall	80002b10 <DataSession_brdcst_func+0x13c>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002aaa:	32 3b       	mov	r11,35
80002aac:	30 1c       	mov	r12,1
80002aae:	f0 1f 00 20 	mcall	80002b2c <DataSession_brdcst_func+0x158>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002ab2:	e0 6c 17 70 	mov	r12,6000
80002ab6:	f0 1f 00 1d 	mcall	80002b28 <DataSession_brdcst_func+0x154>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002aba:	32 3b       	mov	r11,35
80002abc:	30 0c       	mov	r12,0
80002abe:	f0 1f 00 1c 	mcall	80002b2c <DataSession_brdcst_func+0x158>
80002ac2:	c1 68       	rjmp	80002aee <DataSession_brdcst_func+0x11a>
				}
				else{
					
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002ac4:	4a 17       	lddpc	r7,80002b48 <DataSession_brdcst_func+0x174>
80002ac6:	6e 0c       	ld.w	r12,r7[0x0]
80002ac8:	30 09       	mov	r9,0
80002aca:	3f fa       	mov	r10,-1
80002acc:	12 9b       	mov	r11,r9
80002ace:	f0 1f 00 20 	mcall	80002b4c <DataSession_brdcst_func+0x178>
					global_count++;
80002ad2:	4a 08       	lddpc	r8,80002b50 <DataSession_brdcst_func+0x17c>
80002ad4:	70 09       	ld.w	r9,r8[0x0]
80002ad6:	2f f9       	sub	r9,-1
80002ad8:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002ada:	6e 0c       	ld.w	r12,r7[0x0]
80002adc:	30 09       	mov	r9,0
80002ade:	12 9a       	mov	r10,r9
80002ae0:	12 9b       	mov	r11,r9
80002ae2:	f0 1f 00 18 	mcall	80002b40 <DataSession_brdcst_func+0x16c>
80002ae6:	c0 48       	rjmp	80002aee <DataSession_brdcst_func+0x11a>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002ae8:	49 bc       	lddpc	r12,80002b54 <DataSession_brdcst_func+0x180>
80002aea:	f0 1f 00 0a 	mcall	80002b10 <DataSession_brdcst_func+0x13c>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002aee:	e0 6b 00 b7 	mov	r11,183
80002af2:	30 1c       	mov	r12,1
80002af4:	f0 1f 00 0e 	mcall	80002b2c <DataSession_brdcst_func+0x158>
		}
		
		/* 'Give' the semaphore to unblock the task. */
		xSemaphoreGive(xBinarySemaphore);
80002af8:	49 88       	lddpc	r8,80002b58 <DataSession_brdcst_func+0x184>
80002afa:	70 0c       	ld.w	r12,r8[0x0]
80002afc:	30 09       	mov	r9,0
80002afe:	12 9a       	mov	r10,r9
80002b00:	12 9b       	mov	r11,r9
80002b02:	f0 1f 00 10 	mcall	80002b40 <DataSession_brdcst_func+0x16c>
				//
		//}
		
	}
	
}
80002b06:	2f 8d       	sub	sp,-32
80002b08:	d8 22       	popm	r4-r7,pc
80002b0a:	00 00       	add	r0,r0
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	d7 04       	*unknown*
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	6f c4       	ld.w	r4,r7[0x70]
80002b14:	80 00       	ld.sh	r0,r0[0x0]
80002b16:	d7 18       	*unknown*
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	d7 30       	acall	0x73
80002b1c:	80 00       	ld.sh	r0,r0[0x0]
80002b1e:	d7 4c       	*unknown*
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	d7 64       	*unknown*
80002b24:	80 00       	ld.sh	r0,r0[0x0]
80002b26:	d7 70       	acall	0x77
80002b28:	80 00       	ld.sh	r0,r0[0x0]
80002b2a:	6a 58       	ld.w	r8,r5[0x14]
80002b2c:	80 00       	ld.sh	r0,r0[0x0]
80002b2e:	40 98       	lddsp	r8,sp[0x24]
80002b30:	80 00       	ld.sh	r0,r0[0x0]
80002b32:	78 40       	ld.w	r0,r12[0x10]
80002b34:	00 00       	add	r0,r0
80002b36:	0b 78       	ld.ub	r8,--r5
80002b38:	80 00       	ld.sh	r0,r0[0x0]
80002b3a:	2d dc       	sub	r12,-35
80002b3c:	00 00       	add	r0,r0
80002b3e:	0b 74       	ld.ub	r4,--r5
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	63 8c       	ld.w	r12,r1[0x60]
80002b44:	80 00       	ld.sh	r0,r0[0x0]
80002b46:	d6 ac       	*unknown*
80002b48:	00 00       	add	r0,r0
80002b4a:	0a 60       	and	r0,r5
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	61 80       	ld.w	r0,r0[0x60]
80002b50:	00 00       	add	r0,r0
80002b52:	0a 44       	or	r4,r5
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	d7 88       	*unknown*
80002b58:	00 00       	add	r0,r0
80002b5a:	0b 7c       	ld.ub	r12,--r5

80002b5c <DeviceInitializationStatus_brdcst_func>:
volatile U32 global_count =0;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002b5c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002b5e:	19 e8       	ld.ub	r8,r12[0x6]
80002b60:	30 19       	mov	r9,1
80002b62:	f2 08 18 00 	cp.b	r8,r9
80002b66:	c0 61       	brne	80002b72 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002b68:	48 98       	lddpc	r8,80002b8c <DeviceInitializationStatus_brdcst_func+0x30>
80002b6a:	70 09       	ld.w	r9,r8[0x0]
80002b6c:	a1 a9       	sbr	r9,0x0
80002b6e:	91 09       	st.w	r8[0x0],r9
80002b70:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002b72:	30 29       	mov	r9,2
80002b74:	f2 08 18 00 	cp.b	r8,r9
80002b78:	c0 80       	breq	80002b88 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002b7a:	48 58       	lddpc	r8,80002b8c <DeviceInitializationStatus_brdcst_func+0x30>
80002b7c:	70 09       	ld.w	r9,r8[0x0]
80002b7e:	e0 19 ff fc 	andl	r9,0xfffc
80002b82:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002b84:	f0 1f 00 03 	mcall	80002b90 <DeviceInitializationStatus_brdcst_func+0x34>
80002b88:	d8 02       	popm	pc
80002b8a:	00 00       	add	r0,r0
80002b8c:	00 00       	add	r0,r0
80002b8e:	0d a0       	ld.ub	r0,r6[0x2]
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	3f ec       	mov	r12,-2

80002b94 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b94:	20 1c       	sub	r12,1
80002b96:	5c 5c       	castu.b	r12
80002b98:	31 18       	mov	r8,17
80002b9a:	f0 0c 18 00 	cp.b	r12,r8
80002b9e:	e0 88 00 03 	brls	80002ba4 <CalculateBurst+0x10>
80002ba2:	5e fd       	retal	0
80002ba4:	48 28       	lddpc	r8,80002bac <CalculateBurst+0x18>
80002ba6:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002baa:	5e fc       	retal	r12
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	d7 98       	*unknown*

80002bb0 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002bb0:	48 38       	lddpc	r8,80002bbc <payload_init+0xc>
80002bb2:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002bb4:	48 38       	lddpc	r8,80002bc0 <payload_init+0x10>
80002bb6:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002bb8:	5e fc       	retal	r12
80002bba:	00 00       	add	r0,r0
80002bbc:	00 00       	add	r0,r0
80002bbe:	0a 6c       	and	r12,r5
80002bc0:	00 00       	add	r0,r0
80002bc2:	0a 70       	tst	r0,r5

80002bc4 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002bc4:	d4 01       	pushm	lr
80002bc6:	20 2d       	sub	sp,8
80002bc8:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bca:	30 09       	mov	r9,0
80002bcc:	fa ca ff f8 	sub	r10,sp,-8
80002bd0:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002bd2:	1a 9b       	mov	r11,sp
80002bd4:	f0 1f 00 02 	mcall	80002bdc <set_idle_store_isr+0x18>
}
80002bd8:	2f ed       	sub	sp,-8
80002bda:	d8 02       	popm	pc
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	63 3c       	ld.w	r12,r1[0x4c]

80002be0 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002be0:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002be2:	48 48       	lddpc	r8,80002bf0 <payload_rx+0x10>
80002be4:	70 08       	ld.w	r8,r8[0x0]
80002be6:	18 9b       	mov	r11,r12
80002be8:	10 9c       	mov	r12,r8
80002bea:	f0 1f 00 03 	mcall	80002bf4 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002bee:	d8 02       	popm	pc
80002bf0:	00 00       	add	r0,r0
80002bf2:	0a a8       	st.w	r5++,r8
80002bf4:	80 00       	ld.sh	r0,r0[0x0]
80002bf6:	2b c4       	sub	r4,-68

80002bf8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002bf8:	d4 01       	pushm	lr
80002bfa:	20 2d       	sub	sp,8
80002bfc:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002bfe:	58 0c       	cp.w	r12,0
80002c00:	c1 10       	breq	80002c22 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c02:	30 08       	mov	r8,0
80002c04:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002c06:	98 88       	ld.uh	r8,r12[0x0]
80002c08:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c0c:	e0 48 40 00 	cp.w	r8,16384
80002c10:	c0 91       	brne	80002c22 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002c12:	48 68       	lddpc	r8,80002c28 <phy_rx+0x30>
80002c14:	70 0c       	ld.w	r12,r8[0x0]
80002c16:	30 09       	mov	r9,0
80002c18:	fa ca ff fc 	sub	r10,sp,-4
80002c1c:	1a 9b       	mov	r11,sp
80002c1e:	f0 1f 00 04 	mcall	80002c2c <phy_rx+0x34>
		}	

    }
		
 
}
80002c22:	2f ed       	sub	sp,-8
80002c24:	d8 02       	popm	pc
80002c26:	00 00       	add	r0,r0
80002c28:	00 00       	add	r0,r0
80002c2a:	0a b4       	st.h	r5++,r4
80002c2c:	80 00       	ld.sh	r0,r0[0x0]
80002c2e:	63 3c       	ld.w	r12,r1[0x4c]

80002c30 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002c30:	eb cd 40 80 	pushm	r7,lr
80002c34:	20 1d       	sub	sp,4
80002c36:	fa c7 ff fc 	sub	r7,sp,-4
80002c3a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002c3c:	30 09       	mov	r9,0
80002c3e:	12 9a       	mov	r10,r9
80002c40:	1a 9b       	mov	r11,sp
80002c42:	f0 1f 00 03 	mcall	80002c4c <set_idle_store+0x1c>
}
80002c46:	2f fd       	sub	sp,-4
80002c48:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c4c:	80 00       	ld.sh	r0,r0[0x0]
80002c4e:	63 8c       	ld.w	r12,r1[0x60]

80002c50 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c50:	d4 01       	pushm	lr
80002c52:	20 1d       	sub	sp,4
80002c54:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002c56:	98 88       	ld.uh	r8,r12[0x0]
80002c58:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c5c:	e0 48 40 00 	cp.w	r8,16384
80002c60:	c0 d1       	brne	80002c7a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c62:	49 08       	lddpc	r8,80002ca0 <phy_tx+0x50>
80002c64:	70 08       	ld.w	r8,r8[0x0]
80002c66:	58 08       	cp.w	r8,0
80002c68:	c1 a0       	breq	80002c9c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c6a:	48 e8       	lddpc	r8,80002ca0 <phy_tx+0x50>
80002c6c:	70 0c       	ld.w	r12,r8[0x0]
80002c6e:	30 09       	mov	r9,0
80002c70:	12 9a       	mov	r10,r9
80002c72:	1a 9b       	mov	r11,sp
80002c74:	f0 1f 00 0c 	mcall	80002ca4 <phy_tx+0x54>
80002c78:	c1 28       	rjmp	80002c9c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c7a:	e0 48 10 00 	cp.w	r8,4096
80002c7e:	5f 0a       	sreq	r10
80002c80:	e0 48 20 00 	cp.w	r8,8192
80002c84:	5f 09       	sreq	r9
80002c86:	f5 e9 10 09 	or	r9,r10,r9
80002c8a:	c0 71       	brne	80002c98 <phy_tx+0x48>
80002c8c:	e0 48 50 00 	cp.w	r8,20480
80002c90:	c0 40       	breq	80002c98 <phy_tx+0x48>
80002c92:	e0 48 60 00 	cp.w	r8,24576
80002c96:	c0 31       	brne	80002c9c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c98:	48 48       	lddpc	r8,80002ca8 <phy_tx+0x58>
80002c9a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c9c:	2f fd       	sub	sp,-4
80002c9e:	d8 02       	popm	pc
80002ca0:	00 00       	add	r0,r0
80002ca2:	0a d4       	st.w	--r5,r4
80002ca4:	80 00       	ld.sh	r0,r0[0x0]
80002ca6:	63 8c       	ld.w	r12,r1[0x60]
80002ca8:	00 00       	add	r0,r0
80002caa:	0a c8       	st.b	r5++,r8

80002cac <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002cac:	d4 01       	pushm	lr
80002cae:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002cb0:	30 08       	mov	r8,0
80002cb2:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002cb4:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002cb6:	1a 9a       	mov	r10,sp
80002cb8:	fa cb ff fc 	sub	r11,sp,-4
80002cbc:	f0 1f 00 05 	mcall	80002cd0 <get_idle_store_isr+0x24>
80002cc0:	58 1c       	cp.w	r12,1
80002cc2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002cc6:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002cca:	2f ed       	sub	sp,-8
80002ccc:	d8 02       	popm	pc
80002cce:	00 00       	add	r0,r0
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	60 90       	ld.w	r0,r0[0x24]

80002cd4 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002cd4:	eb cd 40 c0 	pushm	r6-r7,lr
80002cd8:	20 1d       	sub	sp,4
80002cda:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002cdc:	4b a8       	lddpc	r8,80002dc4 <phy_tx_func+0xf0>
80002cde:	70 08       	ld.w	r8,r8[0x0]
80002ce0:	58 08       	cp.w	r8,0
80002ce2:	c6 60       	breq	80002dae <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002ce4:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ce6:	30 08       	mov	r8,0
80002ce8:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002cea:	4b 88       	lddpc	r8,80002dc8 <phy_tx_func+0xf4>
80002cec:	70 08       	ld.w	r8,r8[0x0]
80002cee:	58 18       	cp.w	r8,1
80002cf0:	c2 60       	breq	80002d3c <phy_tx_func+0x68>
80002cf2:	c0 43       	brcs	80002cfa <phy_tx_func+0x26>
80002cf4:	58 28       	cp.w	r8,2
80002cf6:	c5 c1       	brne	80002dae <phy_tx_func+0xda>
80002cf8:	c5 58       	rjmp	80002da2 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002cfa:	4b 38       	lddpc	r8,80002dc4 <phy_tx_func+0xf0>
80002cfc:	70 0c       	ld.w	r12,r8[0x0]
80002cfe:	1a 9a       	mov	r10,sp
80002d00:	4b 3b       	lddpc	r11,80002dcc <phy_tx_func+0xf8>
80002d02:	f0 1f 00 34 	mcall	80002dd0 <phy_tx_func+0xfc>
80002d06:	58 1c       	cp.w	r12,1
80002d08:	c1 41       	brne	80002d30 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002d0a:	4b 18       	lddpc	r8,80002dcc <phy_tx_func+0xf8>
80002d0c:	70 08       	ld.w	r8,r8[0x0]
80002d0e:	90 08       	ld.sh	r8,r8[0x0]
80002d10:	10 9a       	mov	r10,r8
80002d12:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002d16:	4b 09       	lddpc	r9,80002dd4 <phy_tx_func+0x100>
80002d18:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002d1a:	5c 78       	castu.h	r8
80002d1c:	ea 18 ab cd 	orh	r8,0xabcd
80002d20:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002d22:	30 19       	mov	r9,1
80002d24:	4a d8       	lddpc	r8,80002dd8 <phy_tx_func+0x104>
80002d26:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002d28:	30 19       	mov	r9,1
80002d2a:	4a 88       	lddpc	r8,80002dc8 <phy_tx_func+0xf4>
80002d2c:	91 09       	st.w	r8[0x0],r9
80002d2e:	c4 08       	rjmp	80002dae <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002d30:	e0 68 5a 5a 	mov	r8,23130
80002d34:	ea 18 ab cd 	orh	r8,0xabcd
80002d38:	8f 18       	st.w	r7[0x4],r8
80002d3a:	c3 a8       	rjmp	80002dae <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d3c:	4a 7a       	lddpc	r10,80002dd8 <phy_tx_func+0x104>
80002d3e:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002d40:	4a 39       	lddpc	r9,80002dcc <phy_tx_func+0xf8>
80002d42:	72 09       	ld.w	r9,r9[0x0]
80002d44:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002d48:	b1 69       	lsl	r9,0x10
80002d4a:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d4c:	2f f8       	sub	r8,-1
80002d4e:	5c 58       	castu.b	r8
80002d50:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d52:	4a 1b       	lddpc	r11,80002dd4 <phy_tx_func+0x100>
80002d54:	96 0c       	ld.sh	r12,r11[0x0]
80002d56:	20 2c       	sub	r12,2
80002d58:	5c 8c       	casts.h	r12
80002d5a:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d5e:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d60:	30 0b       	mov	r11,0
80002d62:	f6 0a 19 00 	cp.h	r10,r11
80002d66:	e0 89 00 09 	brgt	80002d78 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d6a:	e8 19 00 ba 	orl	r9,0xba
80002d6e:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d70:	30 09       	mov	r9,0
80002d72:	49 68       	lddpc	r8,80002dc8 <phy_tx_func+0xf4>
80002d74:	91 09       	st.w	r8[0x0],r9
80002d76:	c1 c8       	rjmp	80002dae <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d78:	49 5a       	lddpc	r10,80002dcc <phy_tx_func+0xf8>
80002d7a:	74 0a       	ld.w	r10,r10[0x0]
80002d7c:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d80:	14 49       	or	r9,r10
80002d82:	8f 19       	st.w	r7[0x4],r9
80002d84:	2f f8       	sub	r8,-1
80002d86:	49 59       	lddpc	r9,80002dd8 <phy_tx_func+0x104>
80002d88:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d8a:	20 2c       	sub	r12,2
80002d8c:	49 28       	lddpc	r8,80002dd4 <phy_tx_func+0x100>
80002d8e:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d90:	30 08       	mov	r8,0
80002d92:	f0 0c 19 00 	cp.h	r12,r8
80002d96:	e0 89 00 0c 	brgt	80002dae <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d9a:	30 29       	mov	r9,2
80002d9c:	48 b8       	lddpc	r8,80002dc8 <phy_tx_func+0xf4>
80002d9e:	91 09       	st.w	r8[0x0],r9
80002da0:	c0 78       	rjmp	80002dae <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002da2:	fc 18 00 ba 	movh	r8,0xba
80002da6:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002da8:	30 09       	mov	r9,0
80002daa:	48 88       	lddpc	r8,80002dc8 <phy_tx_func+0xf4>
80002dac:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002dae:	e0 68 5a 5a 	mov	r8,23130
80002db2:	ea 18 ab cd 	orh	r8,0xabcd
80002db6:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002db8:	30 08       	mov	r8,0
80002dba:	8f 38       	st.w	r7[0xc],r8
}
80002dbc:	2f fd       	sub	sp,-4
80002dbe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002dc2:	00 00       	add	r0,r0
80002dc4:	00 00       	add	r0,r0
80002dc6:	0a d4       	st.w	--r5,r4
80002dc8:	00 00       	add	r0,r0
80002dca:	0a 94       	mov	r4,r5
80002dcc:	00 00       	add	r0,r0
80002dce:	0a a0       	st.w	r5++,r0
80002dd0:	80 00       	ld.sh	r0,r0[0x0]
80002dd2:	60 90       	ld.w	r0,r0[0x24]
80002dd4:	00 00       	add	r0,r0
80002dd6:	0a bc       	st.h	r5++,r12
80002dd8:	00 00       	add	r0,r0
80002dda:	0a 74       	tst	r4,r5

80002ddc <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002ddc:	d4 01       	pushm	lr
80002dde:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002de0:	30 0a       	mov	r10,0
80002de2:	fa cb ff fc 	sub	r11,sp,-4
80002de6:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002de8:	14 99       	mov	r9,r10
80002dea:	1a 9b       	mov	r11,sp
80002dec:	f0 1f 00 05 	mcall	80002e00 <get_idle_store+0x24>
80002df0:	58 1c       	cp.w	r12,1
80002df2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002df6:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002dfa:	2f fd       	sub	sp,-4
80002dfc:	d8 02       	popm	pc
80002dfe:	00 00       	add	r0,r0
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	61 80       	ld.w	r0,r0[0x60]

80002e04 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002e04:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002e06:	48 5b       	lddpc	r11,80002e18 <phy_init+0x14>
80002e08:	48 5c       	lddpc	r12,80002e1c <phy_init+0x18>
80002e0a:	f0 1f 00 06 	mcall	80002e20 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002e0e:	f0 1f 00 06 	mcall	80002e24 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002e12:	f0 1f 00 06 	mcall	80002e28 <phy_init+0x24>
	
}
80002e16:	d8 02       	popm	pc
80002e18:	80 00       	ld.sh	r0,r0[0x0]
80002e1a:	2c d4       	sub	r4,-51
80002e1c:	80 00       	ld.sh	r0,r0[0x0]
80002e1e:	2e 2c       	sub	r12,-30
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	3e 80       	mov	r0,-24
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	3e 94       	mov	r4,-23
80002e28:	80 00       	ld.sh	r0,r0[0x0]
80002e2a:	48 44       	lddpc	r4,80002e38 <phy_rx_func+0xc>

80002e2c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002e2c:	eb cd 40 e0 	pushm	r5-r7,lr
80002e30:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002e32:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002e36:	70 08       	ld.w	r8,r8[0x0]
80002e38:	58 08       	cp.w	r8,0
80002e3a:	e0 80 01 08 	breq	8000304a <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002e3e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002e40:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002e44:	70 09       	ld.w	r9,r8[0x0]
80002e46:	2f f9       	sub	r9,-1
80002e48:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002e4a:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002e4e:	70 08       	ld.w	r8,r8[0x0]
80002e50:	58 18       	cp.w	r8,1
80002e52:	e0 80 00 85 	breq	80002f5c <phy_rx_func+0x130>
80002e56:	c0 73       	brcs	80002e64 <phy_rx_func+0x38>
80002e58:	58 28       	cp.w	r8,2
80002e5a:	c5 c0       	breq	80002f12 <phy_rx_func+0xe6>
80002e5c:	58 38       	cp.w	r8,3
80002e5e:	e0 81 00 f6 	brne	8000304a <phy_rx_func+0x21e>
80002e62:	cd 58       	rjmp	8000300c <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e64:	e0 6a 5a 5a 	mov	r10,23130
80002e68:	ea 1a ab cd 	orh	r10,0xabcd
80002e6c:	14 36       	cp.w	r6,r10
80002e6e:	e0 80 00 ee 	breq	8000304a <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e72:	ec 08 16 10 	lsr	r8,r6,0x10
80002e76:	e0 48 ab cd 	cp.w	r8,43981
80002e7a:	e0 81 00 e8 	brne	8000304a <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e7e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e82:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e86:	20 28       	sub	r8,2
80002e88:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e8c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e8e:	30 09       	mov	r9,0
80002e90:	f2 08 19 00 	cp.h	r8,r9
80002e94:	e0 8a 00 db 	brle	8000304a <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e98:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e9c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e9e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002ea2:	70 0c       	ld.w	r12,r8[0x0]
80002ea4:	f0 1f 03 88 	mcall	80003cc4 <phy_rx_func+0xe98>
80002ea8:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002eac:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002eae:	58 0c       	cp.w	r12,0
80002eb0:	e0 80 00 cd 	breq	8000304a <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002eb4:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002eb8:	90 09       	ld.sh	r9,r8[0x0]
80002eba:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002ebe:	2f f9       	sub	r9,-1
80002ec0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002ec2:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002ec6:	74 0a       	ld.w	r10,r10[0x0]
80002ec8:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002ecc:	76 0b       	ld.w	r11,r11[0x0]
80002ece:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002ed2:	2f f9       	sub	r9,-1
80002ed4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002ed6:	e2 16 0f 00 	andl	r6,0xf00,COH
80002eda:	e0 46 01 00 	cp.w	r6,256
80002ede:	c0 c0       	breq	80002ef6 <phy_rx_func+0xca>
80002ee0:	e0 8b 00 05 	brhi	80002eea <phy_rx_func+0xbe>
80002ee4:	58 06       	cp.w	r6,0
80002ee6:	c0 80       	breq	80002ef6 <phy_rx_func+0xca>
80002ee8:	c0 c8       	rjmp	80002f00 <phy_rx_func+0xd4>
80002eea:	e0 46 02 00 	cp.w	r6,512
80002eee:	c0 40       	breq	80002ef6 <phy_rx_func+0xca>
80002ef0:	e0 46 03 00 	cp.w	r6,768
80002ef4:	c0 61       	brne	80002f00 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002ef6:	30 29       	mov	r9,2
80002ef8:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002efc:	91 09       	st.w	r8[0x0],r9
80002efe:	ca 68       	rjmp	8000304a <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002f00:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002f04:	70 0c       	ld.w	r12,r8[0x0]
80002f06:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002f0a:	70 0b       	ld.w	r11,r8[0x0]
80002f0c:	f0 1f 03 70 	mcall	80003ccc <phy_rx_func+0xea0>
80002f10:	c9 d8       	rjmp	8000304a <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002f12:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002f16:	b1 86       	lsr	r6,0x10
80002f18:	14 06       	add	r6,r10
80002f1a:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002f1e:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f20:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002f24:	90 09       	ld.sh	r9,r8[0x0]
80002f26:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002f2a:	76 0b       	ld.w	r11,r11[0x0]
80002f2c:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002f30:	2f f9       	sub	r9,-1
80002f32:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002f34:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002f38:	92 08       	ld.sh	r8,r9[0x0]
80002f3a:	20 28       	sub	r8,2
80002f3c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002f3e:	30 09       	mov	r9,0
80002f40:	f2 08 19 00 	cp.h	r8,r9
80002f44:	e0 8a 00 07 	brle	80002f52 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002f48:	30 19       	mov	r9,1
80002f4a:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002f4e:	91 09       	st.w	r8[0x0],r9
80002f50:	c7 d8       	rjmp	8000304a <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f52:	30 39       	mov	r9,3
80002f54:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002f58:	91 09       	st.w	r8[0x0],r9
80002f5a:	c7 88       	rjmp	8000304a <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f5c:	ec 0a 14 10 	asr	r10,r6,0x10
80002f60:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f64:	90 09       	ld.sh	r9,r8[0x0]
80002f66:	14 09       	add	r9,r10
80002f68:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f6a:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f6e:	92 08       	ld.sh	r8,r9[0x0]
80002f70:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f74:	76 0b       	ld.w	r11,r11[0x0]
80002f76:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f7a:	2f f8       	sub	r8,-1
80002f7c:	5c 88       	casts.h	r8
80002f7e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f80:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f84:	94 09       	ld.sh	r9,r10[0x0]
80002f86:	20 29       	sub	r9,2
80002f88:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f8a:	30 0a       	mov	r10,0
80002f8c:	f4 09 19 00 	cp.h	r9,r10
80002f90:	e0 89 00 20 	brgt	80002fd0 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f94:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f98:	e0 46 00 ba 	cp.w	r6,186
80002f9c:	c0 d1       	brne	80002fb6 <phy_rx_func+0x18a>
80002f9e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002fa2:	90 09       	ld.sh	r9,r8[0x0]
80002fa4:	f4 09 19 00 	cp.h	r9,r10
80002fa8:	c0 71       	brne	80002fb6 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002faa:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002fae:	70 0c       	ld.w	r12,r8[0x0]
80002fb0:	f0 1f 03 49 	mcall	80003cd4 <phy_rx_func+0xea8>
80002fb4:	c0 98       	rjmp	80002fc6 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002fb6:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002fba:	70 0c       	ld.w	r12,r8[0x0]
80002fbc:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002fc0:	70 0b       	ld.w	r11,r8[0x0]
80002fc2:	f0 1f 03 43 	mcall	80003ccc <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002fc6:	30 09       	mov	r9,0
80002fc8:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002fcc:	91 09       	st.w	r8[0x0],r9
80002fce:	c3 e8       	rjmp	8000304a <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002fd0:	5c 86       	casts.h	r6
80002fd2:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002fd6:	92 0a       	ld.sh	r10,r9[0x0]
80002fd8:	0c 0a       	add	r10,r6
80002fda:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002fdc:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002fe0:	72 09       	ld.w	r9,r9[0x0]
80002fe2:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002fe6:	2f f8       	sub	r8,-1
80002fe8:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002fec:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002fee:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002ff2:	92 08       	ld.sh	r8,r9[0x0]
80002ff4:	20 28       	sub	r8,2
80002ff6:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002ff8:	30 09       	mov	r9,0
80002ffa:	f2 08 19 00 	cp.h	r8,r9
80002ffe:	e0 89 00 26 	brgt	8000304a <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003002:	30 39       	mov	r9,3
80003004:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003008:	91 09       	st.w	r8[0x0],r9
8000300a:	c2 08       	rjmp	8000304a <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000300c:	e6 16 00 ff 	andh	r6,0xff,COH
80003010:	fc 19 00 ba 	movh	r9,0xba
80003014:	12 36       	cp.w	r6,r9
80003016:	c0 e1       	brne	80003032 <phy_rx_func+0x206>
80003018:	fe f8 0c b8 	ld.w	r8,pc[3256]
8000301c:	90 09       	ld.sh	r9,r8[0x0]
8000301e:	30 08       	mov	r8,0
80003020:	f0 09 19 00 	cp.h	r9,r8
80003024:	c0 71       	brne	80003032 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003026:	fe f8 0c a2 	ld.w	r8,pc[3234]
8000302a:	70 0c       	ld.w	r12,r8[0x0]
8000302c:	f0 1f 03 2a 	mcall	80003cd4 <phy_rx_func+0xea8>
80003030:	c0 98       	rjmp	80003042 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80003032:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003036:	70 0c       	ld.w	r12,r8[0x0]
80003038:	fe f8 0c 90 	ld.w	r8,pc[3216]
8000303c:	70 0b       	ld.w	r11,r8[0x0]
8000303e:	f0 1f 03 24 	mcall	80003ccc <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003042:	30 09       	mov	r9,0
80003044:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003048:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
8000304a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000304e:	11 89       	ld.ub	r9,r8[0x0]
80003050:	30 08       	mov	r8,0
80003052:	f0 09 18 00 	cp.b	r9,r8
80003056:	c1 31       	brne	8000307c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003058:	fe f6 0c 84 	ld.w	r6,pc[3204]
8000305c:	6c 0c       	ld.w	r12,r6[0x0]
8000305e:	f0 1f 03 1a 	mcall	80003cc4 <phy_rx_func+0xe98>
80003062:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003066:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003068:	6c 0c       	ld.w	r12,r6[0x0]
8000306a:	f0 1f 03 17 	mcall	80003cc4 <phy_rx_func+0xe98>
8000306e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003072:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003074:	30 19       	mov	r9,1
80003076:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000307a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000307c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003080:	70 08       	ld.w	r8,r8[0x0]
80003082:	58 28       	cp.w	r8,2
80003084:	e0 80 01 98 	breq	800033b4 <phy_rx_func+0x588>
80003088:	e0 8b 00 06 	brhi	80003094 <phy_rx_func+0x268>
8000308c:	58 08       	cp.w	r8,0
8000308e:	c0 b0       	breq	800030a4 <phy_rx_func+0x278>
80003090:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003094:	58 38       	cp.w	r8,3
80003096:	e0 80 05 c5 	breq	80003c20 <phy_rx_func+0xdf4>
8000309a:	58 48       	cp.w	r8,4
8000309c:	e0 81 06 05 	brne	80003ca6 <phy_rx_func+0xe7a>
800030a0:	e0 8f 02 4b 	bral	80003536 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800030a4:	6e 28       	ld.w	r8,r7[0x8]
800030a6:	e0 6a 5a 5a 	mov	r10,23130
800030aa:	ea 1a ab cd 	orh	r10,0xabcd
800030ae:	14 38       	cp.w	r8,r10
800030b0:	c0 71       	brne	800030be <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800030b2:	30 09       	mov	r9,0
800030b4:	fe f8 0c 38 	ld.w	r8,pc[3128]
800030b8:	91 09       	st.w	r8[0x0],r9
800030ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800030be:	10 99       	mov	r9,r8
800030c0:	e0 19 00 00 	andl	r9,0x0
800030c4:	fc 1a ab cd 	movh	r10,0xabcd
800030c8:	14 39       	cp.w	r9,r10
800030ca:	e0 81 05 ee 	brne	80003ca6 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800030ce:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800030d2:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800030d6:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800030d8:	6e 29       	ld.w	r9,r7[0x8]
800030da:	e2 19 f0 00 	andl	r9,0xf000,COH
800030de:	e0 49 c0 00 	cp.w	r9,49152
800030e2:	e0 81 00 ce 	brne	8000327e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800030e6:	30 1a       	mov	r10,1
800030e8:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800030ec:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800030ee:	fe f9 0b f6 	ld.w	r9,pc[3062]
800030f2:	72 09       	ld.w	r9,r9[0x0]
800030f4:	58 09       	cp.w	r9,0
800030f6:	c0 71       	brne	80003104 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030f8:	fe fc 0c 00 	ld.w	r12,pc[3072]
800030fc:	f0 1f 03 00 	mcall	80003cfc <phy_rx_func+0xed0>
80003100:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003104:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003108:	fe f9 0b f8 	ld.w	r9,pc[3064]
8000310c:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000310e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003112:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003116:	fe fa 0b ee 	ld.w	r10,pc[3054]
8000311a:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
8000311c:	13 89       	ld.ub	r9,r9[0x0]
8000311e:	37 fa       	mov	r10,127
80003120:	f4 09 18 00 	cp.b	r9,r10
80003124:	c6 d0       	breq	800031fe <phy_rx_func+0x3d2>
80003126:	e0 8b 00 0c 	brhi	8000313e <phy_rx_func+0x312>
8000312a:	31 2a       	mov	r10,18
8000312c:	f4 09 18 00 	cp.b	r9,r10
80003130:	c4 20       	breq	800031b4 <phy_rx_func+0x388>
80003132:	31 3a       	mov	r10,19
80003134:	f4 09 18 00 	cp.b	r9,r10
80003138:	e0 81 00 83 	brne	8000323e <phy_rx_func+0x412>
8000313c:	c5 b8       	rjmp	800031f2 <phy_rx_func+0x3c6>
8000313e:	2f 09       	sub	r9,-16
80003140:	30 1a       	mov	r10,1
80003142:	f4 09 18 00 	cp.b	r9,r10
80003146:	e0 8b 00 7c 	brhi	8000323e <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000314a:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000314e:	e2 18 00 f0 	andl	r8,0xf0,COH
80003152:	59 08       	cp.w	r8,16
80003154:	c0 71       	brne	80003162 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003156:	30 19       	mov	r9,1
80003158:	fe f8 0b 94 	ld.w	r8,pc[2964]
8000315c:	91 09       	st.w	r8[0x0],r9
8000315e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003162:	e0 48 00 20 	cp.w	r8,32
80003166:	c2 11       	brne	800031a8 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003168:	30 a9       	mov	r9,10
8000316a:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000316e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003170:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003174:	6c 08       	ld.w	r8,r6[0x0]
80003176:	f0 0a 11 ff 	rsub	r10,r8,-1
8000317a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000317e:	2f f8       	sub	r8,-1
80003180:	6e 0c       	ld.w	r12,r7[0x0]
80003182:	f4 ca fe 00 	sub	r10,r10,-512
80003186:	30 0b       	mov	r11,0
80003188:	10 0c       	add	r12,r8
8000318a:	f0 1f 02 e1 	mcall	80003d0c <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000318e:	30 08       	mov	r8,0
80003190:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003192:	6e 0c       	ld.w	r12,r7[0x0]
80003194:	f0 1f 02 df 	mcall	80003d10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003198:	fe f8 0b 44 	ld.w	r8,pc[2884]
8000319c:	70 0c       	ld.w	r12,r8[0x0]
8000319e:	f0 1f 02 ca 	mcall	80003cc4 <phy_rx_func+0xe98>
800031a2:	8f 0c       	st.w	r7[0x0],r12
800031a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800031a8:	30 09       	mov	r9,0
800031aa:	fe f8 0b 42 	ld.w	r8,pc[2882]
800031ae:	91 09       	st.w	r8[0x0],r9
800031b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031b4:	20 48       	sub	r8,4
800031b6:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800031ba:	93 08       	st.w	r9[0x0],r8
800031bc:	58 08       	cp.w	r8,0
800031be:	e0 80 05 74 	breq	80003ca6 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800031c2:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800031c6:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800031ca:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800031ce:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800031d0:	8e 69       	ld.sh	r9,r7[0xc]
800031d2:	fe f8 0b 46 	ld.w	r8,pc[2886]
800031d6:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800031d8:	8e 79       	ld.sh	r9,r7[0xe]
800031da:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800031dc:	f0 1f 02 d0 	mcall	80003d1c <phy_rx_func+0xef0>
800031e0:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800031e4:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800031e6:	30 49       	mov	r9,4
800031e8:	fe f8 0b 00 	ld.w	r8,pc[2816]
800031ec:	91 09       	st.w	r8[0x0],r9
800031ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800031f2:	30 09       	mov	r9,0
800031f4:	fe f8 0a f8 	ld.w	r8,pc[2808]
800031f8:	91 09       	st.w	r8[0x0],r9
800031fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031fe:	20 48       	sub	r8,4
80003200:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003204:	93 08       	st.w	r9[0x0],r8
80003206:	58 08       	cp.w	r8,0
80003208:	e0 80 05 4f 	breq	80003ca6 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000320c:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003210:	70 09       	ld.w	r9,r8[0x0]
80003212:	8e 7b       	ld.sh	r11,r7[0xe]
80003214:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003218:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000321c:	2f f9       	sub	r9,-1
8000321e:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003220:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003224:	70 09       	ld.w	r9,r8[0x0]
80003226:	20 29       	sub	r9,2
80003228:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000322a:	30 29       	mov	r9,2
8000322c:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003230:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003232:	30 39       	mov	r9,3
80003234:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003238:	91 09       	st.w	r8[0x0],r9
8000323a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000323e:	30 3a       	mov	r10,3
80003240:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003244:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003246:	6e 2a       	ld.w	r10,r7[0x8]
80003248:	fe f9 0a e0 	ld.w	r9,pc[2784]
8000324c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000324e:	6e 3a       	ld.w	r10,r7[0xc]
80003250:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003252:	59 48       	cp.w	r8,20
80003254:	c0 61       	brne	80003260 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003256:	31 89       	mov	r9,24
80003258:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000325c:	91 09       	st.w	r8[0x0],r9
8000325e:	c0 a8       	rjmp	80003272 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003260:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003264:	70 08       	ld.w	r8,r8[0x0]
80003266:	59 08       	cp.w	r8,16
80003268:	c0 51       	brne	80003272 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000326a:	31 09       	mov	r9,16
8000326c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003270:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003272:	30 49       	mov	r9,4
80003274:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003278:	91 09       	st.w	r8[0x0],r9
8000327a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000327e:	e0 49 10 00 	cp.w	r9,4096
80003282:	5f 1a       	srne	r10
80003284:	e0 49 20 00 	cp.w	r9,8192
80003288:	5f 19       	srne	r9
8000328a:	f5 e9 00 09 	and	r9,r10,r9
8000328e:	e0 81 05 0c 	brne	80003ca6 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003292:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003296:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003298:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000329c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000329e:	fe fa 0a 62 	ld.w	r10,pc[2658]
800032a2:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800032a4:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800032a8:	72 09       	ld.w	r9,r9[0x0]
800032aa:	58 09       	cp.w	r9,0
800032ac:	c0 71       	brne	800032ba <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032ae:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800032b2:	f0 1f 02 93 	mcall	80003cfc <phy_rx_func+0xed0>
800032b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032ba:	6e 2a       	ld.w	r10,r7[0x8]
800032bc:	e2 1a 0f 00 	andl	r10,0xf00,COH
800032c0:	58 1a       	cp.w	r10,1
800032c2:	e0 8b 00 4d 	brhi	8000335c <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800032c6:	20 48       	sub	r8,4
800032c8:	fe f9 0a 28 	ld.w	r9,pc[2600]
800032cc:	93 08       	st.w	r9[0x0],r8
800032ce:	58 08       	cp.w	r8,0
800032d0:	e0 80 04 eb 	breq	80003ca6 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800032d4:	8e 68       	ld.sh	r8,r7[0xc]
800032d6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800032da:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800032de:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800032e0:	30 09       	mov	r9,0
800032e2:	f2 08 19 00 	cp.h	r8,r9
800032e6:	c0 70       	breq	800032f4 <phy_rx_func+0x4c8>
800032e8:	30 19       	mov	r9,1
800032ea:	f2 08 19 00 	cp.h	r8,r9
800032ee:	e0 81 04 dc 	brne	80003ca6 <phy_rx_func+0xe7a>
800032f2:	c2 68       	rjmp	8000333e <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032f4:	fe f8 0a 44 	ld.w	r8,pc[2628]
800032f8:	70 0a       	ld.w	r10,r8[0x0]
800032fa:	fe f9 09 e6 	ld.w	r9,pc[2534]
800032fe:	72 09       	ld.w	r9,r9[0x0]
80003300:	8e 7b       	ld.sh	r11,r7[0xe]
80003302:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003306:	70 09       	ld.w	r9,r8[0x0]
80003308:	2f f9       	sub	r9,-1
8000330a:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000330c:	e0 49 00 ff 	cp.w	r9,255
80003310:	e0 88 00 11 	brls	80003332 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003314:	30 09       	mov	r9,0
80003316:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003318:	fe f7 09 c8 	ld.w	r7,pc[2504]
8000331c:	6e 0c       	ld.w	r12,r7[0x0]
8000331e:	f0 1f 02 7d 	mcall	80003d10 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003322:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003326:	70 0c       	ld.w	r12,r8[0x0]
80003328:	f0 1f 02 67 	mcall	80003cc4 <phy_rx_func+0xe98>
8000332c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000332e:	e0 80 04 bc 	breq	80003ca6 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003332:	30 29       	mov	r9,2
80003334:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003338:	91 09       	st.w	r8[0x0],r9
8000333a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000333e:	8e 79       	ld.sh	r9,r7[0xe]
80003340:	30 38       	mov	r8,3
80003342:	f0 09 19 00 	cp.h	r9,r8
80003346:	c0 51       	brne	80003350 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003348:	30 19       	mov	r9,1
8000334a:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000334e:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003350:	30 29       	mov	r9,2
80003352:	fe f8 09 96 	ld.w	r8,pc[2454]
80003356:	91 09       	st.w	r8[0x0],r9
80003358:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000335c:	58 18       	cp.w	r8,1
8000335e:	e0 88 04 a4 	brls	80003ca6 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003362:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003366:	70 0a       	ld.w	r10,r8[0x0]
80003368:	6e 3b       	ld.w	r11,r7[0xc]
8000336a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000336e:	70 09       	ld.w	r9,r8[0x0]
80003370:	2f f9       	sub	r9,-1
80003372:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003374:	e0 49 00 ff 	cp.w	r9,255
80003378:	e0 88 00 11 	brls	8000339a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000337c:	30 09       	mov	r9,0
8000337e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003380:	fe f7 09 60 	ld.w	r7,pc[2400]
80003384:	6e 0c       	ld.w	r12,r7[0x0]
80003386:	f0 1f 02 63 	mcall	80003d10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000338a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000338e:	70 0c       	ld.w	r12,r8[0x0]
80003390:	f0 1f 02 4d 	mcall	80003cc4 <phy_rx_func+0xe98>
80003394:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003396:	e0 80 04 88 	breq	80003ca6 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000339a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000339e:	72 08       	ld.w	r8,r9[0x0]
800033a0:	20 28       	sub	r8,2
800033a2:	93 08       	st.w	r9[0x0],r8
800033a4:	e0 80 04 81 	breq	80003ca6 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800033a8:	30 29       	mov	r9,2
800033aa:	fe f8 09 3e 	ld.w	r8,pc[2366]
800033ae:	91 09       	st.w	r8[0x0],r9
800033b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800033b4:	fe f8 09 84 	ld.w	r8,pc[2436]
800033b8:	70 0a       	ld.w	r10,r8[0x0]
800033ba:	fe f9 09 26 	ld.w	r9,pc[2342]
800033be:	72 09       	ld.w	r9,r9[0x0]
800033c0:	8e 4b       	ld.sh	r11,r7[0x8]
800033c2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800033c6:	70 09       	ld.w	r9,r8[0x0]
800033c8:	2f f9       	sub	r9,-1
800033ca:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033cc:	e0 49 00 ff 	cp.w	r9,255
800033d0:	e0 88 00 16 	brls	800033fc <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800033d4:	30 09       	mov	r9,0
800033d6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033d8:	fe f6 09 08 	ld.w	r6,pc[2312]
800033dc:	6c 0c       	ld.w	r12,r6[0x0]
800033de:	f0 1f 02 4d 	mcall	80003d10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033e2:	fe f8 08 fa 	ld.w	r8,pc[2298]
800033e6:	70 0c       	ld.w	r12,r8[0x0]
800033e8:	f0 1f 02 37 	mcall	80003cc4 <phy_rx_func+0xe98>
800033ec:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033ee:	c0 71       	brne	800033fc <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800033f0:	30 09       	mov	r9,0
800033f2:	fe f8 08 f6 	ld.w	r8,pc[2294]
800033f6:	91 09       	st.w	r8[0x0],r9
800033f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800033fc:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003400:	72 08       	ld.w	r8,r9[0x0]
80003402:	20 28       	sub	r8,2
80003404:	93 08       	st.w	r9[0x0],r8
80003406:	c0 71       	brne	80003414 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003408:	30 09       	mov	r9,0
8000340a:	fe f8 08 de 	ld.w	r8,pc[2270]
8000340e:	91 09       	st.w	r8[0x0],r9
80003410:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003414:	fe f8 09 24 	ld.w	r8,pc[2340]
80003418:	70 0a       	ld.w	r10,r8[0x0]
8000341a:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000341e:	72 09       	ld.w	r9,r9[0x0]
80003420:	8e 5b       	ld.sh	r11,r7[0xa]
80003422:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003426:	70 09       	ld.w	r9,r8[0x0]
80003428:	2f f9       	sub	r9,-1
8000342a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000342c:	e0 49 00 ff 	cp.w	r9,255
80003430:	e0 88 00 16 	brls	8000345c <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003434:	30 09       	mov	r9,0
80003436:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003438:	fe f6 08 a8 	ld.w	r6,pc[2216]
8000343c:	6c 0c       	ld.w	r12,r6[0x0]
8000343e:	f0 1f 02 35 	mcall	80003d10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003442:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003446:	70 0c       	ld.w	r12,r8[0x0]
80003448:	f0 1f 02 1f 	mcall	80003cc4 <phy_rx_func+0xe98>
8000344c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000344e:	c0 71       	brne	8000345c <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003450:	30 09       	mov	r9,0
80003452:	fe f8 08 96 	ld.w	r8,pc[2198]
80003456:	91 09       	st.w	r8[0x0],r9
80003458:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000345c:	fe f9 08 94 	ld.w	r9,pc[2196]
80003460:	72 08       	ld.w	r8,r9[0x0]
80003462:	20 28       	sub	r8,2
80003464:	93 08       	st.w	r9[0x0],r8
80003466:	c0 71       	brne	80003474 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003468:	30 09       	mov	r9,0
8000346a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000346e:	91 09       	st.w	r8[0x0],r9
80003470:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003474:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003478:	70 0a       	ld.w	r10,r8[0x0]
8000347a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000347e:	72 09       	ld.w	r9,r9[0x0]
80003480:	8e 6b       	ld.sh	r11,r7[0xc]
80003482:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003486:	70 09       	ld.w	r9,r8[0x0]
80003488:	2f f9       	sub	r9,-1
8000348a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000348c:	e0 49 00 ff 	cp.w	r9,255
80003490:	e0 88 00 16 	brls	800034bc <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003494:	30 09       	mov	r9,0
80003496:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003498:	fe f6 08 48 	ld.w	r6,pc[2120]
8000349c:	6c 0c       	ld.w	r12,r6[0x0]
8000349e:	f0 1f 02 1d 	mcall	80003d10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034a2:	fe f8 08 3a 	ld.w	r8,pc[2106]
800034a6:	70 0c       	ld.w	r12,r8[0x0]
800034a8:	f0 1f 02 07 	mcall	80003cc4 <phy_rx_func+0xe98>
800034ac:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800034ae:	c0 71       	brne	800034bc <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800034b0:	30 09       	mov	r9,0
800034b2:	fe f8 08 36 	ld.w	r8,pc[2102]
800034b6:	91 09       	st.w	r8[0x0],r9
800034b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034bc:	fe f9 08 34 	ld.w	r9,pc[2100]
800034c0:	72 08       	ld.w	r8,r9[0x0]
800034c2:	20 28       	sub	r8,2
800034c4:	93 08       	st.w	r9[0x0],r8
800034c6:	c0 71       	brne	800034d4 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800034c8:	30 09       	mov	r9,0
800034ca:	fe f8 08 1e 	ld.w	r8,pc[2078]
800034ce:	91 09       	st.w	r8[0x0],r9
800034d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800034d4:	fe f8 08 64 	ld.w	r8,pc[2148]
800034d8:	70 0a       	ld.w	r10,r8[0x0]
800034da:	fe f9 08 06 	ld.w	r9,pc[2054]
800034de:	72 09       	ld.w	r9,r9[0x0]
800034e0:	8e 7b       	ld.sh	r11,r7[0xe]
800034e2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034e6:	70 09       	ld.w	r9,r8[0x0]
800034e8:	2f f9       	sub	r9,-1
800034ea:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034ec:	e0 49 00 ff 	cp.w	r9,255
800034f0:	e0 88 00 16 	brls	8000351c <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800034f4:	30 09       	mov	r9,0
800034f6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034f8:	fe f7 07 e8 	ld.w	r7,pc[2024]
800034fc:	6e 0c       	ld.w	r12,r7[0x0]
800034fe:	f0 1f 02 05 	mcall	80003d10 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003502:	fe f8 07 da 	ld.w	r8,pc[2010]
80003506:	70 0c       	ld.w	r12,r8[0x0]
80003508:	f0 1f 01 ef 	mcall	80003cc4 <phy_rx_func+0xe98>
8000350c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000350e:	c0 71       	brne	8000351c <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003510:	30 09       	mov	r9,0
80003512:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003516:	91 09       	st.w	r8[0x0],r9
80003518:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000351c:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003520:	72 08       	ld.w	r8,r9[0x0]
80003522:	20 28       	sub	r8,2
80003524:	93 08       	st.w	r9[0x0],r8
80003526:	e0 81 03 c0 	brne	80003ca6 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000352a:	30 09       	mov	r9,0
8000352c:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003530:	91 09       	st.w	r8[0x0],r9
80003532:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003536:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000353a:	11 89       	ld.ub	r9,r8[0x0]
8000353c:	31 28       	mov	r8,18
8000353e:	f0 09 18 00 	cp.b	r9,r8
80003542:	e0 81 01 4c 	brne	800037da <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003546:	ef 39 00 09 	ld.ub	r9,r7[9]
8000354a:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000354e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003550:	11 89       	ld.ub	r9,r8[0x0]
80003552:	3f 28       	mov	r8,-14
80003554:	f0 09 18 00 	cp.b	r9,r8
80003558:	e0 81 01 3b 	brne	800037ce <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
8000355c:	30 19       	mov	r9,1
8000355e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003562:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003564:	6e 29       	ld.w	r9,r7[0x8]
80003566:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000356a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000356e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003570:	8e 59       	ld.sh	r9,r7[0xa]
80003572:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003576:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003578:	8e 69       	ld.sh	r9,r7[0xc]
8000357a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000357c:	8e 79       	ld.sh	r9,r7[0xe]
8000357e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003580:	fe f8 07 88 	ld.w	r8,pc[1928]
80003584:	fe f9 07 60 	ld.w	r9,pc[1888]
80003588:	72 0a       	ld.w	r10,r9[0x0]
8000358a:	70 09       	ld.w	r9,r8[0x0]
8000358c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003590:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003594:	70 09       	ld.w	r9,r8[0x0]
80003596:	2f f9       	sub	r9,-1
80003598:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000359a:	e0 49 01 ff 	cp.w	r9,511
8000359e:	e0 88 00 16 	brls	800035ca <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800035a2:	30 09       	mov	r9,0
800035a4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035a6:	fe f6 07 3e 	ld.w	r6,pc[1854]
800035aa:	6c 0c       	ld.w	r12,r6[0x0]
800035ac:	f0 1f 01 d9 	mcall	80003d10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035b0:	fe f8 07 2c 	ld.w	r8,pc[1836]
800035b4:	70 0c       	ld.w	r12,r8[0x0]
800035b6:	f0 1f 01 c4 	mcall	80003cc4 <phy_rx_func+0xe98>
800035ba:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035bc:	c0 71       	brne	800035ca <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800035be:	30 09       	mov	r9,0
800035c0:	fe f8 07 28 	ld.w	r8,pc[1832]
800035c4:	91 09       	st.w	r8[0x0],r9
800035c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035ca:	fe f9 07 26 	ld.w	r9,pc[1830]
800035ce:	72 08       	ld.w	r8,r9[0x0]
800035d0:	20 18       	sub	r8,1
800035d2:	93 08       	st.w	r9[0x0],r8
800035d4:	c0 71       	brne	800035e2 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800035d6:	30 09       	mov	r9,0
800035d8:	fe f8 07 10 	ld.w	r8,pc[1808]
800035dc:	91 09       	st.w	r8[0x0],r9
800035de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800035e2:	fe f8 07 26 	ld.w	r8,pc[1830]
800035e6:	fe f9 06 fe 	ld.w	r9,pc[1790]
800035ea:	72 0a       	ld.w	r10,r9[0x0]
800035ec:	70 09       	ld.w	r9,r8[0x0]
800035ee:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800035f2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035f6:	70 09       	ld.w	r9,r8[0x0]
800035f8:	2f f9       	sub	r9,-1
800035fa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035fc:	e0 49 01 ff 	cp.w	r9,511
80003600:	e0 88 00 16 	brls	8000362c <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003604:	30 09       	mov	r9,0
80003606:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003608:	fe f6 06 dc 	ld.w	r6,pc[1756]
8000360c:	6c 0c       	ld.w	r12,r6[0x0]
8000360e:	f0 1f 01 c1 	mcall	80003d10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003612:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003616:	70 0c       	ld.w	r12,r8[0x0]
80003618:	f0 1f 01 ab 	mcall	80003cc4 <phy_rx_func+0xe98>
8000361c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000361e:	c0 71       	brne	8000362c <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003620:	30 09       	mov	r9,0
80003622:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003626:	91 09       	st.w	r8[0x0],r9
80003628:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000362c:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003630:	72 08       	ld.w	r8,r9[0x0]
80003632:	20 18       	sub	r8,1
80003634:	93 08       	st.w	r9[0x0],r8
80003636:	c0 71       	brne	80003644 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003638:	30 09       	mov	r9,0
8000363a:	fe f8 06 ae 	ld.w	r8,pc[1710]
8000363e:	91 09       	st.w	r8[0x0],r9
80003640:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003644:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003648:	fe f9 06 9c 	ld.w	r9,pc[1692]
8000364c:	72 0a       	ld.w	r10,r9[0x0]
8000364e:	70 09       	ld.w	r9,r8[0x0]
80003650:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003654:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003658:	70 09       	ld.w	r9,r8[0x0]
8000365a:	2f f9       	sub	r9,-1
8000365c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000365e:	e0 49 01 ff 	cp.w	r9,511
80003662:	e0 88 00 16 	brls	8000368e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003666:	30 09       	mov	r9,0
80003668:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000366a:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000366e:	6c 0c       	ld.w	r12,r6[0x0]
80003670:	f0 1f 01 a8 	mcall	80003d10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003674:	fe f8 06 68 	ld.w	r8,pc[1640]
80003678:	70 0c       	ld.w	r12,r8[0x0]
8000367a:	f0 1f 01 93 	mcall	80003cc4 <phy_rx_func+0xe98>
8000367e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003680:	c0 71       	brne	8000368e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003682:	30 09       	mov	r9,0
80003684:	fe f8 06 64 	ld.w	r8,pc[1636]
80003688:	91 09       	st.w	r8[0x0],r9
8000368a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000368e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003692:	72 08       	ld.w	r8,r9[0x0]
80003694:	20 18       	sub	r8,1
80003696:	93 08       	st.w	r9[0x0],r8
80003698:	c0 71       	brne	800036a6 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000369a:	30 09       	mov	r9,0
8000369c:	fe f8 06 4c 	ld.w	r8,pc[1612]
800036a0:	91 09       	st.w	r8[0x0],r9
800036a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800036a6:	fe f8 06 62 	ld.w	r8,pc[1634]
800036aa:	fe f9 06 3a 	ld.w	r9,pc[1594]
800036ae:	72 0a       	ld.w	r10,r9[0x0]
800036b0:	70 09       	ld.w	r9,r8[0x0]
800036b2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800036b6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036ba:	70 09       	ld.w	r9,r8[0x0]
800036bc:	2f f9       	sub	r9,-1
800036be:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036c0:	e0 49 01 ff 	cp.w	r9,511
800036c4:	e0 88 00 16 	brls	800036f0 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800036c8:	30 09       	mov	r9,0
800036ca:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036cc:	fe f6 06 18 	ld.w	r6,pc[1560]
800036d0:	6c 0c       	ld.w	r12,r6[0x0]
800036d2:	f0 1f 01 90 	mcall	80003d10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036d6:	fe f8 06 06 	ld.w	r8,pc[1542]
800036da:	70 0c       	ld.w	r12,r8[0x0]
800036dc:	f0 1f 01 7a 	mcall	80003cc4 <phy_rx_func+0xe98>
800036e0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036e2:	c0 71       	brne	800036f0 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800036e4:	30 09       	mov	r9,0
800036e6:	fe f8 06 02 	ld.w	r8,pc[1538]
800036ea:	91 09       	st.w	r8[0x0],r9
800036ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036f0:	fe f9 06 00 	ld.w	r9,pc[1536]
800036f4:	72 08       	ld.w	r8,r9[0x0]
800036f6:	20 18       	sub	r8,1
800036f8:	93 08       	st.w	r9[0x0],r8
800036fa:	c0 71       	brne	80003708 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800036fc:	30 09       	mov	r9,0
800036fe:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003702:	91 09       	st.w	r8[0x0],r9
80003704:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003708:	fe f8 06 00 	ld.w	r8,pc[1536]
8000370c:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003710:	72 0a       	ld.w	r10,r9[0x0]
80003712:	70 09       	ld.w	r9,r8[0x0]
80003714:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003718:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000371c:	70 09       	ld.w	r9,r8[0x0]
8000371e:	2f f9       	sub	r9,-1
80003720:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003722:	e0 49 01 ff 	cp.w	r9,511
80003726:	e0 88 00 16 	brls	80003752 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000372a:	30 09       	mov	r9,0
8000372c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000372e:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003732:	6c 0c       	ld.w	r12,r6[0x0]
80003734:	f0 1f 01 77 	mcall	80003d10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003738:	fe f8 05 a4 	ld.w	r8,pc[1444]
8000373c:	70 0c       	ld.w	r12,r8[0x0]
8000373e:	f0 1f 01 62 	mcall	80003cc4 <phy_rx_func+0xe98>
80003742:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003744:	c0 71       	brne	80003752 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003746:	30 09       	mov	r9,0
80003748:	fe f8 05 a0 	ld.w	r8,pc[1440]
8000374c:	91 09       	st.w	r8[0x0],r9
8000374e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003752:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003756:	72 08       	ld.w	r8,r9[0x0]
80003758:	20 18       	sub	r8,1
8000375a:	93 08       	st.w	r9[0x0],r8
8000375c:	c0 71       	brne	8000376a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000375e:	30 09       	mov	r9,0
80003760:	fe f8 05 88 	ld.w	r8,pc[1416]
80003764:	91 09       	st.w	r8[0x0],r9
80003766:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000376a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000376e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003772:	72 0a       	ld.w	r10,r9[0x0]
80003774:	70 09       	ld.w	r9,r8[0x0]
80003776:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000377a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000377e:	70 09       	ld.w	r9,r8[0x0]
80003780:	2f f9       	sub	r9,-1
80003782:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003784:	e0 49 01 ff 	cp.w	r9,511
80003788:	e0 88 00 16 	brls	800037b4 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000378c:	30 09       	mov	r9,0
8000378e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003790:	fe f7 05 54 	ld.w	r7,pc[1364]
80003794:	6e 0c       	ld.w	r12,r7[0x0]
80003796:	f0 1f 01 5f 	mcall	80003d10 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000379a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000379e:	70 0c       	ld.w	r12,r8[0x0]
800037a0:	f0 1f 01 49 	mcall	80003cc4 <phy_rx_func+0xe98>
800037a4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037a6:	c0 71       	brne	800037b4 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800037a8:	30 09       	mov	r9,0
800037aa:	fe f8 05 3e 	ld.w	r8,pc[1342]
800037ae:	91 09       	st.w	r8[0x0],r9
800037b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037b4:	fe f9 05 3c 	ld.w	r9,pc[1340]
800037b8:	72 08       	ld.w	r8,r9[0x0]
800037ba:	20 18       	sub	r8,1
800037bc:	93 08       	st.w	r9[0x0],r8
800037be:	e0 81 02 74 	brne	80003ca6 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800037c2:	30 09       	mov	r9,0
800037c4:	fe f8 05 24 	ld.w	r8,pc[1316]
800037c8:	91 09       	st.w	r8[0x0],r9
800037ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800037ce:	30 09       	mov	r9,0
800037d0:	fe f8 05 18 	ld.w	r8,pc[1304]
800037d4:	91 09       	st.w	r8[0x0],r9
800037d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800037da:	fe f8 05 26 	ld.w	r8,pc[1318]
800037de:	11 89       	ld.ub	r9,r8[0x0]
800037e0:	3f 28       	mov	r8,-14
800037e2:	f0 09 18 00 	cp.b	r9,r8
800037e6:	c4 31       	brne	8000386c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800037e8:	8e 49       	ld.sh	r9,r7[0x8]
800037ea:	fe f8 05 56 	ld.w	r8,pc[1366]
800037ee:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800037f0:	fe f8 05 18 	ld.w	r8,pc[1304]
800037f4:	fe f9 04 f0 	ld.w	r9,pc[1264]
800037f8:	72 0a       	ld.w	r10,r9[0x0]
800037fa:	70 09       	ld.w	r9,r8[0x0]
800037fc:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003800:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003804:	70 09       	ld.w	r9,r8[0x0]
80003806:	2f f9       	sub	r9,-1
80003808:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000380a:	e0 49 01 ff 	cp.w	r9,511
8000380e:	e0 88 00 16 	brls	8000383a <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003812:	30 09       	mov	r9,0
80003814:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003816:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000381a:	6e 0c       	ld.w	r12,r7[0x0]
8000381c:	f0 1f 01 3d 	mcall	80003d10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003820:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003824:	70 0c       	ld.w	r12,r8[0x0]
80003826:	f0 1f 01 28 	mcall	80003cc4 <phy_rx_func+0xe98>
8000382a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000382c:	c0 71       	brne	8000383a <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
8000382e:	30 09       	mov	r9,0
80003830:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003834:	91 09       	st.w	r8[0x0],r9
80003836:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000383a:	fe f9 04 b6 	ld.w	r9,pc[1206]
8000383e:	72 08       	ld.w	r8,r9[0x0]
80003840:	20 18       	sub	r8,1
80003842:	93 08       	st.w	r9[0x0],r8
80003844:	c0 71       	brne	80003852 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003846:	30 09       	mov	r9,0
80003848:	fe f8 04 a0 	ld.w	r8,pc[1184]
8000384c:	91 09       	st.w	r8[0x0],r9
8000384e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003852:	20 18       	sub	r8,1
80003854:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003858:	93 08       	st.w	r9[0x0],r8
8000385a:	58 08       	cp.w	r8,0
8000385c:	e0 81 02 25 	brne	80003ca6 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003860:	30 09       	mov	r9,0
80003862:	fe f8 04 86 	ld.w	r8,pc[1158]
80003866:	91 09       	st.w	r8[0x0],r9
80003868:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000386c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003870:	11 89       	ld.ub	r9,r8[0x0]
80003872:	3f 38       	mov	r8,-13
80003874:	f0 09 18 00 	cp.b	r9,r8
80003878:	e0 81 01 0c 	brne	80003a90 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000387c:	8e 49       	ld.sh	r9,r7[0x8]
8000387e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003882:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003884:	8e 59       	ld.sh	r9,r7[0xa]
80003886:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003888:	8e 69       	ld.sh	r9,r7[0xc]
8000388a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000388c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003890:	fe f9 04 54 	ld.w	r9,pc[1108]
80003894:	72 0a       	ld.w	r10,r9[0x0]
80003896:	70 09       	ld.w	r9,r8[0x0]
80003898:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000389c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038a0:	70 09       	ld.w	r9,r8[0x0]
800038a2:	2f f9       	sub	r9,-1
800038a4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038a6:	e0 49 01 ff 	cp.w	r9,511
800038aa:	e0 88 00 16 	brls	800038d6 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800038ae:	30 09       	mov	r9,0
800038b0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038b2:	fe f6 04 32 	ld.w	r6,pc[1074]
800038b6:	6c 0c       	ld.w	r12,r6[0x0]
800038b8:	f0 1f 01 16 	mcall	80003d10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038bc:	fe f8 04 20 	ld.w	r8,pc[1056]
800038c0:	70 0c       	ld.w	r12,r8[0x0]
800038c2:	f0 1f 01 01 	mcall	80003cc4 <phy_rx_func+0xe98>
800038c6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038c8:	c0 71       	brne	800038d6 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800038ca:	30 09       	mov	r9,0
800038cc:	fe f8 04 1c 	ld.w	r8,pc[1052]
800038d0:	91 09       	st.w	r8[0x0],r9
800038d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038d6:	fe f9 04 1a 	ld.w	r9,pc[1050]
800038da:	72 08       	ld.w	r8,r9[0x0]
800038dc:	20 18       	sub	r8,1
800038de:	93 08       	st.w	r9[0x0],r8
800038e0:	c0 71       	brne	800038ee <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800038e2:	30 09       	mov	r9,0
800038e4:	fe f8 04 04 	ld.w	r8,pc[1028]
800038e8:	91 09       	st.w	r8[0x0],r9
800038ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800038ee:	fe f8 04 1a 	ld.w	r8,pc[1050]
800038f2:	fe f9 03 f2 	ld.w	r9,pc[1010]
800038f6:	72 0a       	ld.w	r10,r9[0x0]
800038f8:	70 09       	ld.w	r9,r8[0x0]
800038fa:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038fe:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003902:	70 09       	ld.w	r9,r8[0x0]
80003904:	2f f9       	sub	r9,-1
80003906:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003908:	e0 49 01 ff 	cp.w	r9,511
8000390c:	e0 88 00 16 	brls	80003938 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003910:	30 09       	mov	r9,0
80003912:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003914:	fe f6 03 d0 	ld.w	r6,pc[976]
80003918:	6c 0c       	ld.w	r12,r6[0x0]
8000391a:	f0 1f 00 fe 	mcall	80003d10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000391e:	fe f8 03 be 	ld.w	r8,pc[958]
80003922:	70 0c       	ld.w	r12,r8[0x0]
80003924:	f0 1f 00 e8 	mcall	80003cc4 <phy_rx_func+0xe98>
80003928:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000392a:	c0 71       	brne	80003938 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
8000392c:	30 09       	mov	r9,0
8000392e:	fe f8 03 ba 	ld.w	r8,pc[954]
80003932:	91 09       	st.w	r8[0x0],r9
80003934:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003938:	fe f9 03 b8 	ld.w	r9,pc[952]
8000393c:	72 08       	ld.w	r8,r9[0x0]
8000393e:	20 18       	sub	r8,1
80003940:	93 08       	st.w	r9[0x0],r8
80003942:	c0 71       	brne	80003950 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003944:	30 09       	mov	r9,0
80003946:	fe f8 03 a2 	ld.w	r8,pc[930]
8000394a:	91 09       	st.w	r8[0x0],r9
8000394c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003950:	fe f8 03 b8 	ld.w	r8,pc[952]
80003954:	fe f9 03 90 	ld.w	r9,pc[912]
80003958:	72 0a       	ld.w	r10,r9[0x0]
8000395a:	70 09       	ld.w	r9,r8[0x0]
8000395c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003960:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003964:	70 09       	ld.w	r9,r8[0x0]
80003966:	2f f9       	sub	r9,-1
80003968:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000396a:	e0 49 01 ff 	cp.w	r9,511
8000396e:	e0 88 00 16 	brls	8000399a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003972:	30 09       	mov	r9,0
80003974:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003976:	fe f6 03 6e 	ld.w	r6,pc[878]
8000397a:	6c 0c       	ld.w	r12,r6[0x0]
8000397c:	f0 1f 00 e5 	mcall	80003d10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003980:	fe f8 03 5c 	ld.w	r8,pc[860]
80003984:	70 0c       	ld.w	r12,r8[0x0]
80003986:	f0 1f 00 d0 	mcall	80003cc4 <phy_rx_func+0xe98>
8000398a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000398c:	c0 71       	brne	8000399a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000398e:	30 09       	mov	r9,0
80003990:	fe f8 03 58 	ld.w	r8,pc[856]
80003994:	91 09       	st.w	r8[0x0],r9
80003996:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000399a:	fe f9 03 56 	ld.w	r9,pc[854]
8000399e:	72 08       	ld.w	r8,r9[0x0]
800039a0:	20 18       	sub	r8,1
800039a2:	93 08       	st.w	r9[0x0],r8
800039a4:	c0 71       	brne	800039b2 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800039a6:	30 09       	mov	r9,0
800039a8:	fe f8 03 40 	ld.w	r8,pc[832]
800039ac:	91 09       	st.w	r8[0x0],r9
800039ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800039b2:	fe f8 03 56 	ld.w	r8,pc[854]
800039b6:	fe f9 03 2e 	ld.w	r9,pc[814]
800039ba:	72 0a       	ld.w	r10,r9[0x0]
800039bc:	70 09       	ld.w	r9,r8[0x0]
800039be:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800039c2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039c6:	70 09       	ld.w	r9,r8[0x0]
800039c8:	2f f9       	sub	r9,-1
800039ca:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039cc:	e0 49 01 ff 	cp.w	r9,511
800039d0:	e0 88 00 16 	brls	800039fc <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800039d4:	30 09       	mov	r9,0
800039d6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039d8:	fe f6 03 0c 	ld.w	r6,pc[780]
800039dc:	6c 0c       	ld.w	r12,r6[0x0]
800039de:	f0 1f 00 cd 	mcall	80003d10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039e2:	fe f8 02 fa 	ld.w	r8,pc[762]
800039e6:	70 0c       	ld.w	r12,r8[0x0]
800039e8:	f0 1f 00 b7 	mcall	80003cc4 <phy_rx_func+0xe98>
800039ec:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039ee:	c0 71       	brne	800039fc <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800039f0:	30 09       	mov	r9,0
800039f2:	fe f8 02 f6 	ld.w	r8,pc[758]
800039f6:	91 09       	st.w	r8[0x0],r9
800039f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039fc:	fe f9 02 f4 	ld.w	r9,pc[756]
80003a00:	72 08       	ld.w	r8,r9[0x0]
80003a02:	20 18       	sub	r8,1
80003a04:	93 08       	st.w	r9[0x0],r8
80003a06:	c0 71       	brne	80003a14 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003a08:	30 09       	mov	r9,0
80003a0a:	fe f8 02 de 	ld.w	r8,pc[734]
80003a0e:	91 09       	st.w	r8[0x0],r9
80003a10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003a14:	fe f8 02 f4 	ld.w	r8,pc[756]
80003a18:	fe f9 02 cc 	ld.w	r9,pc[716]
80003a1c:	72 0a       	ld.w	r10,r9[0x0]
80003a1e:	70 09       	ld.w	r9,r8[0x0]
80003a20:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a24:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a28:	70 09       	ld.w	r9,r8[0x0]
80003a2a:	2f f9       	sub	r9,-1
80003a2c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a2e:	e0 49 01 ff 	cp.w	r9,511
80003a32:	e0 88 00 16 	brls	80003a5e <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a36:	30 09       	mov	r9,0
80003a38:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a3a:	fe f7 02 aa 	ld.w	r7,pc[682]
80003a3e:	6e 0c       	ld.w	r12,r7[0x0]
80003a40:	f0 1f 00 b4 	mcall	80003d10 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a44:	fe f8 02 98 	ld.w	r8,pc[664]
80003a48:	70 0c       	ld.w	r12,r8[0x0]
80003a4a:	f0 1f 00 9f 	mcall	80003cc4 <phy_rx_func+0xe98>
80003a4e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a50:	c0 71       	brne	80003a5e <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a52:	30 09       	mov	r9,0
80003a54:	fe f8 02 94 	ld.w	r8,pc[660]
80003a58:	91 09       	st.w	r8[0x0],r9
80003a5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a5e:	fe f9 02 92 	ld.w	r9,pc[658]
80003a62:	72 08       	ld.w	r8,r9[0x0]
80003a64:	20 18       	sub	r8,1
80003a66:	93 08       	st.w	r9[0x0],r8
80003a68:	c0 71       	brne	80003a76 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a6a:	30 09       	mov	r9,0
80003a6c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a70:	91 09       	st.w	r8[0x0],r9
80003a72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a76:	20 18       	sub	r8,1
80003a78:	fe f9 02 78 	ld.w	r9,pc[632]
80003a7c:	93 08       	st.w	r9[0x0],r8
80003a7e:	58 08       	cp.w	r8,0
80003a80:	e0 81 01 13 	brne	80003ca6 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a84:	30 09       	mov	r9,0
80003a86:	fe f8 02 62 	ld.w	r8,pc[610]
80003a8a:	91 09       	st.w	r8[0x0],r9
80003a8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a90:	fe f8 02 70 	ld.w	r8,pc[624]
80003a94:	11 89       	ld.ub	r9,r8[0x0]
80003a96:	30 48       	mov	r8,4
80003a98:	f0 09 18 00 	cp.b	r9,r8
80003a9c:	c0 80       	breq	80003aac <phy_rx_func+0xc80>
80003a9e:	fe f8 02 62 	ld.w	r8,pc[610]
80003aa2:	11 89       	ld.ub	r9,r8[0x0]
80003aa4:	30 38       	mov	r8,3
80003aa6:	f0 09 18 00 	cp.b	r9,r8
80003aaa:	c1 41       	brne	80003ad2 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003aac:	6e 29       	ld.w	r9,r7[0x8]
80003aae:	fe f8 02 7a 	ld.w	r8,pc[634]
80003ab2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003ab4:	6e 39       	ld.w	r9,r7[0xc]
80003ab6:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003ab8:	fe f9 02 38 	ld.w	r9,pc[568]
80003abc:	72 08       	ld.w	r8,r9[0x0]
80003abe:	20 88       	sub	r8,8
80003ac0:	93 08       	st.w	r9[0x0],r8
80003ac2:	e0 81 00 f2 	brne	80003ca6 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003ac6:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003ac8:	fe f9 02 20 	ld.w	r9,pc[544]
80003acc:	93 08       	st.w	r9[0x0],r8
80003ace:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003ad2:	fe f8 02 2e 	ld.w	r8,pc[558]
80003ad6:	11 89       	ld.ub	r9,r8[0x0]
80003ad8:	31 38       	mov	r8,19
80003ada:	f0 09 18 00 	cp.b	r9,r8
80003ade:	e0 81 00 9c 	brne	80003c16 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003ae2:	fe f8 02 62 	ld.w	r8,pc[610]
80003ae6:	11 88       	ld.ub	r8,r8[0x0]
80003ae8:	30 c9       	mov	r9,12
80003aea:	f2 08 18 00 	cp.b	r8,r9
80003aee:	e0 81 00 7b 	brne	80003be4 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003af2:	8e 49       	ld.sh	r9,r7[0x8]
80003af4:	fe f8 02 54 	ld.w	r8,pc[596]
80003af8:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003afc:	30 09       	mov	r9,0
80003afe:	fe f8 02 46 	ld.w	r8,pc[582]
80003b02:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b04:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003b08:	3f 38       	mov	r8,-13
80003b0a:	f0 09 18 00 	cp.b	r9,r8
80003b0e:	c6 61       	brne	80003bda <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003b10:	10 99       	mov	r9,r8
80003b12:	4f c8       	lddpc	r8,80003d00 <phy_rx_func+0xed4>
80003b14:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003b16:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003b1a:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003b1e:	4f 58       	lddpc	r8,80003cf0 <phy_rx_func+0xec4>
80003b20:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003b22:	30 19       	mov	r9,1
80003b24:	fe f8 02 0c 	ld.w	r8,pc[524]
80003b28:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003b2a:	8e 79       	ld.sh	r9,r7[0xe]
80003b2c:	fe f8 02 14 	ld.w	r8,pc[532]
80003b30:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003b32:	4f 68       	lddpc	r8,80003d08 <phy_rx_func+0xedc>
80003b34:	4e c9       	lddpc	r9,80003ce4 <phy_rx_func+0xeb8>
80003b36:	72 0a       	ld.w	r10,r9[0x0]
80003b38:	70 09       	ld.w	r9,r8[0x0]
80003b3a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b3e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b42:	70 09       	ld.w	r9,r8[0x0]
80003b44:	2f f9       	sub	r9,-1
80003b46:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b48:	e0 49 01 ff 	cp.w	r9,511
80003b4c:	e0 88 00 13 	brls	80003b72 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b50:	30 09       	mov	r9,0
80003b52:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b54:	4e 46       	lddpc	r6,80003ce4 <phy_rx_func+0xeb8>
80003b56:	6c 0c       	ld.w	r12,r6[0x0]
80003b58:	f0 1f 00 6e 	mcall	80003d10 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b5c:	4e 08       	lddpc	r8,80003cdc <phy_rx_func+0xeb0>
80003b5e:	70 0c       	ld.w	r12,r8[0x0]
80003b60:	f0 1f 00 59 	mcall	80003cc4 <phy_rx_func+0xe98>
80003b64:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b66:	c0 61       	brne	80003b72 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b68:	30 09       	mov	r9,0
80003b6a:	4e 08       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003b6c:	91 09       	st.w	r8[0x0],r9
80003b6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b72:	4e 09       	lddpc	r9,80003cf0 <phy_rx_func+0xec4>
80003b74:	72 08       	ld.w	r8,r9[0x0]
80003b76:	20 18       	sub	r8,1
80003b78:	93 08       	st.w	r9[0x0],r8
80003b7a:	c0 61       	brne	80003b86 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b7c:	30 09       	mov	r9,0
80003b7e:	4d b8       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003b80:	91 09       	st.w	r8[0x0],r9
80003b82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b86:	4e 18       	lddpc	r8,80003d08 <phy_rx_func+0xedc>
80003b88:	4d 79       	lddpc	r9,80003ce4 <phy_rx_func+0xeb8>
80003b8a:	72 0a       	ld.w	r10,r9[0x0]
80003b8c:	70 09       	ld.w	r9,r8[0x0]
80003b8e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b92:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b96:	70 09       	ld.w	r9,r8[0x0]
80003b98:	2f f9       	sub	r9,-1
80003b9a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b9c:	e0 49 01 ff 	cp.w	r9,511
80003ba0:	e0 88 00 13 	brls	80003bc6 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003ba4:	30 09       	mov	r9,0
80003ba6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ba8:	4c f7       	lddpc	r7,80003ce4 <phy_rx_func+0xeb8>
80003baa:	6e 0c       	ld.w	r12,r7[0x0]
80003bac:	f0 1f 00 59 	mcall	80003d10 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003bb0:	4c b8       	lddpc	r8,80003cdc <phy_rx_func+0xeb0>
80003bb2:	70 0c       	ld.w	r12,r8[0x0]
80003bb4:	f0 1f 00 44 	mcall	80003cc4 <phy_rx_func+0xe98>
80003bb8:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003bba:	c0 61       	brne	80003bc6 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003bbc:	30 09       	mov	r9,0
80003bbe:	4c b8       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003bc0:	91 09       	st.w	r8[0x0],r9
80003bc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003bc6:	4c b9       	lddpc	r9,80003cf0 <phy_rx_func+0xec4>
80003bc8:	72 08       	ld.w	r8,r9[0x0]
80003bca:	20 18       	sub	r8,1
80003bcc:	93 08       	st.w	r9[0x0],r8
80003bce:	c6 c1       	brne	80003ca6 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003bd0:	30 09       	mov	r9,0
80003bd2:	4c 68       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003bd4:	91 09       	st.w	r8[0x0],r9
80003bd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003bda:	30 09       	mov	r9,0
80003bdc:	4c 38       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003bde:	91 09       	st.w	r8[0x0],r9
80003be0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003be4:	8e 4a       	ld.sh	r10,r7[0x8]
80003be6:	4d 99       	lddpc	r9,80003d48 <phy_rx_func+0xf1c>
80003be8:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003bec:	4d 6a       	lddpc	r10,80003d44 <phy_rx_func+0xf18>
80003bee:	15 88       	ld.ub	r8,r10[0x0]
80003bf0:	f0 cb ff ff 	sub	r11,r8,-1
80003bf4:	8e 5c       	ld.sh	r12,r7[0xa]
80003bf6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003bfa:	f0 cb ff fe 	sub	r11,r8,-2
80003bfe:	8e 6c       	ld.sh	r12,r7[0xc]
80003c00:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003c04:	f0 cb ff fd 	sub	r11,r8,-3
80003c08:	8e 7c       	ld.sh	r12,r7[0xe]
80003c0a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003c0e:	2f c8       	sub	r8,-4
80003c10:	b4 88       	st.b	r10[0x0],r8
80003c12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003c16:	30 09       	mov	r9,0
80003c18:	4b 48       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003c1a:	91 09       	st.w	r8[0x0],r9
80003c1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003c20:	4c 08       	lddpc	r8,80003d20 <phy_rx_func+0xef4>
80003c22:	70 09       	ld.w	r9,r8[0x0]
80003c24:	8e 4b       	ld.sh	r11,r7[0x8]
80003c26:	4c 0a       	lddpc	r10,80003d24 <phy_rx_func+0xef8>
80003c28:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003c2c:	2f f9       	sub	r9,-1
80003c2e:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003c30:	4b 58       	lddpc	r8,80003d04 <phy_rx_func+0xed8>
80003c32:	70 09       	ld.w	r9,r8[0x0]
80003c34:	20 29       	sub	r9,2
80003c36:	91 09       	st.w	r8[0x0],r9
80003c38:	70 08       	ld.w	r8,r8[0x0]
80003c3a:	58 08       	cp.w	r8,0
80003c3c:	c2 f1       	brne	80003c9a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003c3e:	30 09       	mov	r9,0
80003c40:	4b 88       	lddpc	r8,80003d20 <phy_rx_func+0xef4>
80003c42:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c44:	8e 59       	ld.sh	r9,r7[0xa]
80003c46:	fe 78 82 12 	mov	r8,-32238
80003c4a:	f0 09 19 00 	cp.h	r9,r8
80003c4e:	c2 11       	brne	80003c90 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c50:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003c54:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c58:	4a f8       	lddpc	r8,80003d14 <phy_rx_func+0xee8>
80003c5a:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c5c:	8e 59       	ld.sh	r9,r7[0xa]
80003c5e:	4a f8       	lddpc	r8,80003d18 <phy_rx_func+0xeec>
80003c60:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c62:	8e 69       	ld.sh	r9,r7[0xc]
80003c64:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c66:	f0 1f 00 2e 	mcall	80003d1c <phy_rx_func+0xef0>
80003c6a:	4a 18       	lddpc	r8,80003cec <phy_rx_func+0xec0>
80003c6c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c6e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c72:	31 38       	mov	r8,19
80003c74:	f0 09 18 00 	cp.b	r9,r8
80003c78:	c0 71       	brne	80003c86 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c7a:	10 99       	mov	r9,r8
80003c7c:	4a 18       	lddpc	r8,80003d00 <phy_rx_func+0xed4>
80003c7e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c80:	30 09       	mov	r9,0
80003c82:	49 c8       	lddpc	r8,80003cf0 <phy_rx_func+0xec4>
80003c84:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c86:	30 49       	mov	r9,4
80003c88:	49 88       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003c8a:	91 09       	st.w	r8[0x0],r9
80003c8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c90:	30 09       	mov	r9,0
80003c92:	49 68       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003c94:	91 09       	st.w	r8[0x0],r9
80003c96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c9a:	4a dc       	lddpc	r12,80003d4c <phy_rx_func+0xf20>
80003c9c:	f0 1f 00 18 	mcall	80003cfc <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003ca0:	30 09       	mov	r9,0
80003ca2:	49 28       	lddpc	r8,80003ce8 <phy_rx_func+0xebc>
80003ca4:	91 09       	st.w	r8[0x0],r9
80003ca6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003caa:	00 00       	add	r0,r0
80003cac:	00 00       	add	r0,r0
80003cae:	0a b4       	st.h	r5++,r4
80003cb0:	00 00       	add	r0,r0
80003cb2:	0a cc       	st.b	r5++,r12
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a ac       	st.w	r5++,r12
80003cb8:	00 00       	add	r0,r0
80003cba:	0a 8e       	andn	lr,r5
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a 7c       	tst	r12,r5
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a a4       	st.w	r5++,r4
80003cc4:	80 00       	ld.sh	r0,r0[0x0]
80003cc6:	2c ac       	sub	r12,-54
80003cc8:	00 00       	add	r0,r0
80003cca:	0a 9c       	mov	r12,r5
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	2b c4       	sub	r4,-68
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a b0       	st.h	r5++,r0
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	2b f8       	sub	r8,-65
80003cd8:	00 00       	add	r0,r0
80003cda:	0a 8d       	andn	sp,r5
80003cdc:	00 00       	add	r0,r0
80003cde:	0a a8       	st.w	r5++,r8
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a b8       	st.h	r5++,r8
80003ce4:	00 00       	add	r0,r0
80003ce6:	0a 90       	mov	r0,r5
80003ce8:	00 00       	add	r0,r0
80003cea:	0a d8       	st.w	--r5,r8
80003cec:	00 00       	add	r0,r0
80003cee:	0a c0       	st.b	r5++,r0
80003cf0:	00 00       	add	r0,r0
80003cf2:	0a 78       	tst	r8,r5
80003cf4:	00 00       	add	r0,r0
80003cf6:	0a 50       	eor	r0,r5
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	d7 e0       	acall	0x7e
80003cfc:	80 00       	ld.sh	r0,r0[0x0]
80003cfe:	71 50       	ld.w	r0,r8[0x54]
80003d00:	00 00       	add	r0,r0
80003d02:	0a 8c       	andn	r12,r5
80003d04:	00 00       	add	r0,r0
80003d06:	0a e4       	st.h	--r5,r4
80003d08:	00 00       	add	r0,r0
80003d0a:	0a c4       	st.b	r5++,r4
80003d0c:	80 00       	ld.sh	r0,r0[0x0]
80003d0e:	79 88       	ld.w	r8,r12[0x60]
80003d10:	80 00       	ld.sh	r0,r0[0x0]
80003d12:	2b e0       	sub	r0,-66
80003d14:	00 00       	add	r0,r0
80003d16:	0a 5d       	eor	sp,r5
80003d18:	00 00       	add	r0,r0
80003d1a:	1e b4       	st.h	pc++,r4
80003d1c:	80 00       	ld.sh	r0,r0[0x0]
80003d1e:	2b 94       	sub	r4,-71
80003d20:	00 00       	add	r0,r0
80003d22:	0a 80       	andn	r0,r5
80003d24:	00 00       	add	r0,r0
80003d26:	1d b8       	ld.ub	r8,lr[0x3]
80003d28:	00 00       	add	r0,r0
80003d2a:	0a 84       	andn	r4,r5
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a 4c       	or	r12,r5
80003d30:	00 00       	add	r0,r0
80003d32:	0a 43       	or	r3,r5
80003d34:	00 00       	add	r0,r0
80003d36:	0a dc       	st.w	--r5,r12
80003d38:	00 00       	add	r0,r0
80003d3a:	0a 98       	mov	r8,r5
80003d3c:	00 00       	add	r0,r0
80003d3e:	0a 64       	and	r4,r5
80003d40:	00 00       	add	r0,r0
80003d42:	1d b0       	ld.ub	r0,lr[0x3]
80003d44:	00 00       	add	r0,r0
80003d46:	0a d0       	st.w	--r5,r0
80003d48:	00 00       	add	r0,r0
80003d4a:	1e b8       	st.h	pc++,r8
80003d4c:	80 00       	ld.sh	r0,r0[0x0]
80003d4e:	d7 f8       	*unknown*

80003d50 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d50:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d52:	49 a8       	lddpc	r8,80003db8 <pdca_int_handler+0x68>
80003d54:	70 09       	ld.w	r9,r8[0x0]
80003d56:	2f f9       	sub	r9,-1
80003d58:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d5a:	49 98       	lddpc	r8,80003dbc <pdca_int_handler+0x6c>
80003d5c:	11 89       	ld.ub	r9,r8[0x0]
80003d5e:	ec 19 00 01 	eorl	r9,0x1
80003d62:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d64:	11 89       	ld.ub	r9,r8[0x0]
80003d66:	a5 69       	lsl	r9,0x4
80003d68:	2f c9       	sub	r9,-4
80003d6a:	49 6a       	lddpc	r10,80003dc0 <pdca_int_handler+0x70>
80003d6c:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d6e:	fe 7a 00 40 	mov	r10,-65472
80003d72:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d74:	30 39       	mov	r9,3
80003d76:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d78:	11 8a       	ld.ub	r10,r8[0x0]
80003d7a:	a5 6a       	lsl	r10,0x4
80003d7c:	2f ca       	sub	r10,-4
80003d7e:	49 28       	lddpc	r8,80003dc4 <pdca_int_handler+0x74>
80003d80:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d82:	fe 78 00 00 	mov	r8,-65536
80003d86:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d88:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d8a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d8c:	48 f8       	lddpc	r8,80003dc8 <pdca_int_handler+0x78>
80003d8e:	70 08       	ld.w	r8,r8[0x0]
80003d90:	58 08       	cp.w	r8,0
80003d92:	c0 70       	breq	80003da0 <pdca_int_handler+0x50>
80003d94:	48 a9       	lddpc	r9,80003dbc <pdca_int_handler+0x6c>
80003d96:	13 89       	ld.ub	r9,r9[0x0]
80003d98:	a5 69       	lsl	r9,0x4
80003d9a:	48 bc       	lddpc	r12,80003dc4 <pdca_int_handler+0x74>
80003d9c:	12 0c       	add	r12,r9
80003d9e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003da0:	48 b8       	lddpc	r8,80003dcc <pdca_int_handler+0x7c>
80003da2:	70 08       	ld.w	r8,r8[0x0]
80003da4:	58 08       	cp.w	r8,0
80003da6:	c0 70       	breq	80003db4 <pdca_int_handler+0x64>
80003da8:	48 59       	lddpc	r9,80003dbc <pdca_int_handler+0x6c>
80003daa:	13 89       	ld.ub	r9,r9[0x0]
80003dac:	a5 69       	lsl	r9,0x4
80003dae:	48 5c       	lddpc	r12,80003dc0 <pdca_int_handler+0x70>
80003db0:	12 0c       	add	r12,r9
80003db2:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003db4:	d4 02       	popm	lr
80003db6:	d6 03       	rete
80003db8:	00 00       	add	r0,r0
80003dba:	0a ec       	st.h	--r5,r12
80003dbc:	00 00       	add	r0,r0
80003dbe:	96 d8       	ld.uh	r8,r11[0xa]
80003dc0:	00 00       	add	r0,r0
80003dc2:	97 00       	st.w	r11[0x0],r0
80003dc4:	00 00       	add	r0,r0
80003dc6:	96 e0       	ld.uh	r0,r11[0xc]
80003dc8:	00 00       	add	r0,r0
80003dca:	0a e8       	st.h	--r5,r8
80003dcc:	00 00       	add	r0,r0
80003dce:	0a f0       	st.b	--r5,r0

80003dd0 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003dd0:	fe 78 10 00 	mov	r8,-61440
80003dd4:	e0 69 0d c0 	mov	r9,3520
80003dd8:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003ddc:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003de0:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003de4:	fe 78 34 00 	mov	r8,-52224
80003de8:	e0 69 80 00 	mov	r9,32768
80003dec:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003dee:	30 09       	mov	r9,0
80003df0:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003df2:	e0 69 04 21 	mov	r9,1057
80003df6:	ea 19 3f 20 	orh	r9,0x3f20
80003dfa:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003dfc:	e0 69 02 9f 	mov	r9,671
80003e00:	ea 19 01 00 	orh	r9,0x100
80003e04:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003e06:	e0 6a 04 02 	mov	r10,1026
80003e0a:	ea 1a 3f 20 	orh	r10,0x3f20
80003e0e:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003e10:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003e12:	5e fc       	retal	r12

80003e14 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003e14:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003e16:	30 19       	mov	r9,1
80003e18:	49 78       	lddpc	r8,80003e74 <local_start_PDC+0x60>
80003e1a:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003e1c:	fe 78 00 00 	mov	r8,-65536
80003e20:	30 7b       	mov	r11,7
80003e22:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003e24:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003e26:	49 59       	lddpc	r9,80003e78 <local_start_PDC+0x64>
80003e28:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003e2c:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003e2e:	30 3a       	mov	r10,3
80003e30:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003e32:	30 1c       	mov	r12,1
80003e34:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003e36:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003e38:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e3a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e3c:	30 2c       	mov	r12,2
80003e3e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003e40:	48 f9       	lddpc	r9,80003e7c <local_start_PDC+0x68>
80003e42:	e0 68 5a 5a 	mov	r8,23130
80003e46:	ea 18 ab cd 	orh	r8,0xabcd
80003e4a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003e4c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003e4e:	30 0e       	mov	lr,0
80003e50:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e52:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e54:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e56:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e58:	fe 78 00 40 	mov	r8,-65472
80003e5c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e5e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e60:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e64:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e66:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e68:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e6a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e6c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e6e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e70:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e72:	d8 02       	popm	pc
80003e74:	00 00       	add	r0,r0
80003e76:	96 d8       	ld.uh	r8,r11[0xa]
80003e78:	00 00       	add	r0,r0
80003e7a:	96 e0       	ld.uh	r0,r11[0xc]
80003e7c:	00 00       	add	r0,r0
80003e7e:	97 00       	st.w	r11[0x0],r0

80003e80 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e80:	48 38       	lddpc	r8,80003e8c <register_rx_tx_func+0xc>
80003e82:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e84:	48 38       	lddpc	r8,80003e90 <register_rx_tx_func+0x10>
80003e86:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e88:	5e fc       	retal	r12
80003e8a:	00 00       	add	r0,r0
80003e8c:	00 00       	add	r0,r0
80003e8e:	0a e8       	st.h	--r5,r8
80003e90:	00 00       	add	r0,r0
80003e92:	0a f0       	st.b	--r5,r0

80003e94 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e94:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e96:	fe 78 10 00 	mov	r8,-61440
80003e9a:	30 29       	mov	r9,2
80003e9c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003ea0:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003ea4:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003ea6:	30 3a       	mov	r10,3
80003ea8:	36 0b       	mov	r11,96
80003eaa:	49 4c       	lddpc	r12,80003ef8 <ssc_init+0x64>
80003eac:	f0 1f 00 14 	mcall	80003efc <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003eb0:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003eb2:	fe 79 10 00 	mov	r9,-61440
80003eb6:	f2 f8 01 60 	ld.w	r8,r9[352]
80003eba:	e2 18 00 02 	andl	r8,0x2,COH
80003ebe:	cf c0       	breq	80003eb6 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003ec0:	fe 79 10 00 	mov	r9,-61440
80003ec4:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ec8:	e2 18 00 02 	andl	r8,0x2,COH
80003ecc:	cf c1       	brne	80003ec4 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003ece:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003ed0:	f0 1f 00 0c 	mcall	80003f00 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003ed4:	f0 1f 00 0c 	mcall	80003f04 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ed8:	fe 79 00 00 	mov	r9,-65536
80003edc:	30 18       	mov	r8,1
80003ede:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003ee0:	fe 7a 00 40 	mov	r10,-65472
80003ee4:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003ee6:	e0 6b 01 01 	mov	r11,257
80003eea:	fe 7a 34 00 	mov	r10,-52224
80003eee:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ef0:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003ef2:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003ef4:	d8 02       	popm	pc
80003ef6:	00 00       	add	r0,r0
80003ef8:	80 00       	ld.sh	r0,r0[0x0]
80003efa:	3d 50       	mov	r0,-43
80003efc:	80 00       	ld.sh	r0,r0[0x0]
80003efe:	55 9c       	stdsp	sp[0x164],r12
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	3d d0       	mov	r0,-35
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	3e 14       	mov	r4,-31

80003f08 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003f08:	48 28       	lddpc	r8,80003f10 <xcmp_register_app_list+0x8>
80003f0a:	91 0c       	st.w	r8[0x0],r12
}
80003f0c:	5e fc       	retal	r12
80003f0e:	00 00       	add	r0,r0
80003f10:	00 00       	add	r0,r0
80003f12:	97 20       	st.w	r11[0x8],r0

80003f14 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003f14:	eb cd 40 80 	pushm	r7,lr
80003f18:	fa cd 01 00 	sub	sp,sp,256
80003f1c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003f1e:	16 98       	mov	r8,r11
80003f20:	2f 08       	sub	r8,-16
80003f22:	af a8       	sbr	r8,0xe
80003f24:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003f26:	3f f8       	mov	r8,-1
80003f28:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003f2a:	30 b9       	mov	r9,11
80003f2c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003f2e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003f30:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003f32:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003f34:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003f36:	f6 ca ff fe 	sub	r10,r11,-2
80003f3a:	18 9b       	mov	r11,r12
80003f3c:	fa cc ff f0 	sub	r12,sp,-16
80003f40:	f0 1f 00 05 	mcall	80003f54 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003f44:	2f e7       	sub	r7,-2
80003f46:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003f48:	1a 9c       	mov	r12,sp
80003f4a:	f0 1f 00 04 	mcall	80003f58 <xcmp_tx+0x44>
}
80003f4e:	2c 0d       	sub	sp,-256
80003f50:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	78 40       	ld.w	r0,r12[0x10]
80003f58:	80 00       	ld.sh	r0,r0[0x0]
80003f5a:	45 24       	lddsp	r4,sp[0x148]

80003f5c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80003f5c:	d4 21       	pushm	r4-r7,lr
80003f5e:	fa cd 00 d0 	sub	sp,sp,208
80003f62:	18 94       	mov	r4,r12
80003f64:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f66:	e0 68 01 00 	mov	r8,256
80003f6a:	f0 0b 19 00 	cp.h	r11,r8
80003f6e:	e0 8b 00 38 	brhi	80003fde <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f72:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f76:	e0 68 04 1d 	mov	r8,1053
80003f7a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f7c:	30 18       	mov	r8,1
80003f7e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f80:	32 08       	mov	r8,32
80003f82:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f84:	30 28       	mov	r8,2
80003f86:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f88:	30 48       	mov	r8,4
80003f8a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f8c:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80003f90:	ea 1a 0c 00 	orh	r10,0xc00
80003f94:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f96:	30 4a       	mov	r10,4
80003f98:	1a 9b       	mov	r11,sp
80003f9a:	fa cc ff f4 	sub	r12,sp,-12
80003f9e:	f0 1f 00 12 	mcall	80003fe4 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003fa2:	30 f8       	mov	r8,15
80003fa4:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003fa8:	3a 78       	mov	r8,-89
80003faa:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003fae:	30 08       	mov	r8,0
80003fb0:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003fb4:	0e 9a       	mov	r10,r7
80003fb6:	5c 7a       	castu.h	r10
80003fb8:	f4 08 16 08 	lsr	r8,r10,0x8
80003fbc:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003fc0:	0e 96       	mov	r6,r7
80003fc2:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003fc6:	08 9b       	mov	r11,r4
80003fc8:	fa cc ff eb 	sub	r12,sp,-21
80003fcc:	f0 1f 00 06 	mcall	80003fe4 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003fd0:	ee cb ff f3 	sub	r11,r7,-13
80003fd4:	5c 5b       	castu.b	r11
80003fd6:	fa cc ff fa 	sub	r12,sp,-6
80003fda:	f0 1f 00 04 	mcall	80003fe8 <xcmp_data_session_req+0x8c>
}
80003fde:	2c cd       	sub	sp,-208
80003fe0:	d8 22       	popm	r4-r7,pc
80003fe2:	00 00       	add	r0,r0
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	78 40       	ld.w	r0,r12[0x10]
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	3f 14       	mov	r4,-15

80003fec <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003fec:	d4 01       	pushm	lr
80003fee:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003ff2:	fe 78 b4 00 	mov	r8,-19456
80003ff6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003ff8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003ffc:	30 89       	mov	r9,8
80003ffe:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004000:	30 19       	mov	r9,1
80004002:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004004:	30 09       	mov	r9,0
80004006:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004008:	30 5a       	mov	r10,5
8000400a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000400c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000400e:	30 7a       	mov	r10,7
80004010:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004012:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004014:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004016:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000401a:	30 9b       	mov	r11,9
8000401c:	fa cc ff fe 	sub	r12,sp,-2
80004020:	f0 1f 00 02 	mcall	80004028 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004024:	2c dd       	sub	sp,-204
80004026:	d8 02       	popm	pc
80004028:	80 00       	ld.sh	r0,r0[0x0]
8000402a:	3f 14       	mov	r4,-15

8000402c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000402c:	d4 01       	pushm	lr
8000402e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004032:	fe 78 80 00 	mov	r8,-32768
80004036:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004038:	30 38       	mov	r8,3
8000403a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000403c:	30 1b       	mov	r11,1
8000403e:	fa cc ff fe 	sub	r12,sp,-2
80004042:	f0 1f 00 03 	mcall	8000404c <xcmp_opcode_not_supported+0x20>
}
80004046:	2c dd       	sub	sp,-204
80004048:	d8 02       	popm	pc
8000404a:	00 00       	add	r0,r0
8000404c:	80 00       	ld.sh	r0,r0[0x0]
8000404e:	3f 14       	mov	r4,-15

80004050 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004050:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004052:	96 88       	ld.uh	r8,r11[0x0]
80004054:	e2 18 f0 00 	andl	r8,0xf000,COH
80004058:	e0 48 80 00 	cp.w	r8,32768
8000405c:	c0 f0       	breq	8000407a <xcmp_exec_func+0x2a>
8000405e:	e0 48 b0 00 	cp.w	r8,45056
80004062:	c1 20       	breq	80004086 <xcmp_exec_func+0x36>
80004064:	58 08       	cp.w	r8,0
80004066:	c1 51       	brne	80004090 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004068:	78 08       	ld.w	r8,r12[0x0]
8000406a:	58 08       	cp.w	r8,0
8000406c:	c0 40       	breq	80004074 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000406e:	16 9c       	mov	r12,r11
80004070:	5d 18       	icall	r8
80004072:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004074:	f0 1f 00 08 	mcall	80004094 <xcmp_exec_func+0x44>
80004078:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000407a:	78 18       	ld.w	r8,r12[0x4]
8000407c:	58 08       	cp.w	r8,0
8000407e:	c0 90       	breq	80004090 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004080:	16 9c       	mov	r12,r11
80004082:	5d 18       	icall	r8
80004084:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004086:	78 28       	ld.w	r8,r12[0x8]
80004088:	58 08       	cp.w	r8,0
8000408a:	c0 30       	breq	80004090 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000408c:	16 9c       	mov	r12,r11
8000408e:	5d 18       	icall	r8
80004090:	d8 02       	popm	pc
80004092:	00 00       	add	r0,r0
80004094:	80 00       	ld.sh	r0,r0[0x0]
80004096:	40 2c       	lddsp	r12,sp[0x8]

80004098 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004098:	d4 01       	pushm	lr
8000409a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000409e:	e0 68 04 09 	mov	r8,1033
800040a2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800040a4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
800040a8:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
800040aa:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
800040ae:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
800040b0:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800040b2:	30 09       	mov	r9,0
800040b4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800040b6:	fb 69 00 08 	st.b	sp[8],r9
800040ba:	fa c8 ff f7 	sub	r8,sp,-9
800040be:	b0 89       	st.b	r8[0x0],r9
800040c0:	fa c8 ff f6 	sub	r8,sp,-10
800040c4:	b0 89       	st.b	r8[0x0],r9
800040c6:	fa c8 ff f5 	sub	r8,sp,-11
800040ca:	b0 89       	st.b	r8[0x0],r9
800040cc:	fa c8 ff f4 	sub	r8,sp,-12
800040d0:	b0 89       	st.b	r8[0x0],r9
800040d2:	fa c8 ff f3 	sub	r8,sp,-13
800040d6:	b0 89       	st.b	r8[0x0],r9
800040d8:	fa c8 ff f2 	sub	r8,sp,-14
800040dc:	b0 89       	st.b	r8[0x0],r9
800040de:	fa c8 ff f1 	sub	r8,sp,-15
800040e2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800040e4:	30 cb       	mov	r11,12
800040e6:	fa cc ff fe 	sub	r12,sp,-2
800040ea:	f0 1f 00 03 	mcall	800040f4 <xcmp_IdleTestTone+0x5c>
}
800040ee:	2c dd       	sub	sp,-204
800040f0:	d8 02       	popm	pc
800040f2:	00 00       	add	r0,r0
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	3f 14       	mov	r4,-15

800040f8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040f8:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040fa:	48 dc       	lddpc	r12,8000412c <xcmp_init+0x34>
800040fc:	f0 1f 00 0d 	mcall	80004130 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004100:	30 4b       	mov	r11,4
80004102:	31 4c       	mov	r12,20
80004104:	f0 1f 00 0c 	mcall	80004134 <xcmp_init+0x3c>
80004108:	48 c8       	lddpc	r8,80004138 <xcmp_init+0x40>
8000410a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000410c:	30 09       	mov	r9,0
8000410e:	1a d9       	st.w	--sp,r9
80004110:	1a d9       	st.w	--sp,r9
80004112:	1a d9       	st.w	--sp,r9
80004114:	30 38       	mov	r8,3
80004116:	e0 6a 04 00 	mov	r10,1024
8000411a:	48 9b       	lddpc	r11,8000413c <xcmp_init+0x44>
8000411c:	48 9c       	lddpc	r12,80004140 <xcmp_init+0x48>
8000411e:	f0 1f 00 0a 	mcall	80004144 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004122:	f0 1f 00 0a 	mcall	80004148 <xcmp_init+0x50>
80004126:	2f dd       	sub	sp,-12
	
}
80004128:	d8 02       	popm	pc
8000412a:	00 00       	add	r0,r0
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	42 48       	lddsp	r8,sp[0x90]
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	42 94       	lddsp	r4,sp[0xa4]
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	64 e4       	ld.w	r4,r2[0x38]
80004138:	00 00       	add	r0,r0
8000413a:	0b 0c       	ld.w	r12,r5++
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	d8 24       	*unknown*
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	41 4c       	lddsp	r12,sp[0x50]
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	6c 00       	ld.w	r0,r6[0x0]
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	42 cc       	lddsp	r12,sp[0xb0]

8000414c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000414c:	d4 31       	pushm	r0-r7,lr
8000414e:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004150:	4b 16       	lddpc	r6,80004214 <xcmp_rx_process+0xc8>
80004152:	30 05       	mov	r5,0
80004154:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004156:	4b 13       	lddpc	r3,80004218 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004158:	4b 12       	lddpc	r2,8000421c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000415a:	4b 21       	lddpc	r1,80004220 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000415c:	4b 20       	lddpc	r0,80004224 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000415e:	6c 0c       	ld.w	r12,r6[0x0]
80004160:	0a 99       	mov	r9,r5
80004162:	08 9a       	mov	r10,r4
80004164:	1a 9b       	mov	r11,sp
80004166:	f0 1f 00 31 	mcall	80004228 <xcmp_rx_process+0xdc>
8000416a:	58 1c       	cp.w	r12,1
8000416c:	cf 91       	brne	8000415e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000416e:	40 0b       	lddsp	r11,sp[0x0]
80004170:	58 0b       	cp.w	r11,0
80004172:	cf 60       	breq	8000415e <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004174:	96 0a       	ld.sh	r10,r11[0x0]
80004176:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000417a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000417e:	59 c8       	cp.w	r8,28
80004180:	c1 e0       	breq	800041bc <xcmp_rx_process+0x70>
80004182:	e0 89 00 07 	brgt	80004190 <xcmp_rx_process+0x44>
80004186:	58 e8       	cp.w	r8,14
80004188:	c0 e0       	breq	800041a4 <xcmp_rx_process+0x58>
8000418a:	58 f8       	cp.w	r8,15
8000418c:	c2 41       	brne	800041d4 <xcmp_rx_process+0x88>
8000418e:	c0 f8       	rjmp	800041ac <xcmp_rx_process+0x60>
80004190:	e0 48 01 09 	cp.w	r8,265
80004194:	c1 80       	breq	800041c4 <xcmp_rx_process+0x78>
80004196:	e0 48 01 0a 	cp.w	r8,266
8000419a:	c1 90       	breq	800041cc <xcmp_rx_process+0x80>
8000419c:	e0 48 00 2c 	cp.w	r8,44
800041a0:	c1 a1       	brne	800041d4 <xcmp_rx_process+0x88>
800041a2:	c0 98       	rjmp	800041b4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800041a4:	4a 2c       	lddpc	r12,8000422c <xcmp_rx_process+0xe0>
800041a6:	f0 1f 00 23 	mcall	80004230 <xcmp_rx_process+0xe4>
					break;
800041aa:	c2 f8       	rjmp	80004208 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800041ac:	4a 2c       	lddpc	r12,80004234 <xcmp_rx_process+0xe8>
800041ae:	f0 1f 00 21 	mcall	80004230 <xcmp_rx_process+0xe4>
					break;
800041b2:	c2 b8       	rjmp	80004208 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800041b4:	4a 1c       	lddpc	r12,80004238 <xcmp_rx_process+0xec>
800041b6:	f0 1f 00 1f 	mcall	80004230 <xcmp_rx_process+0xe4>
					break;
800041ba:	c2 78       	rjmp	80004208 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041bc:	04 9c       	mov	r12,r2
800041be:	f0 1f 00 1d 	mcall	80004230 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800041c2:	c2 38       	rjmp	80004208 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041c4:	02 9c       	mov	r12,r1
800041c6:	f0 1f 00 1b 	mcall	80004230 <xcmp_rx_process+0xe4>
					break;
800041ca:	c1 f8       	rjmp	80004208 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800041cc:	00 9c       	mov	r12,r0
800041ce:	f0 1f 00 19 	mcall	80004230 <xcmp_rx_process+0xe4>
					break;
800041d2:	c1 b8       	rjmp	80004208 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800041d4:	12 98       	mov	r8,r9
800041d6:	e2 18 04 00 	andl	r8,0x400,COH
800041da:	c0 70       	breq	800041e8 <xcmp_rx_process+0x9c>
800041dc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800041e0:	e0 48 00 68 	cp.w	r8,104
800041e4:	e0 8a 00 08 	brle	800041f4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800041e8:	e2 19 f0 00 	andl	r9,0xf000,COH
800041ec:	c0 e1       	brne	80004208 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800041ee:	f0 1f 00 14 	mcall	8000423c <xcmp_rx_process+0xf0>
800041f2:	c0 b8       	rjmp	80004208 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041f4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041f8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041fc:	49 19       	lddpc	r9,80004240 <xcmp_rx_process+0xf4>
800041fe:	72 08       	ld.w	r8,r9[0x0]
80004200:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004204:	f0 1f 00 0b 	mcall	80004230 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004208:	66 0c       	ld.w	r12,r3[0x0]
8000420a:	40 0b       	lddsp	r11,sp[0x0]
8000420c:	f0 1f 00 0e 	mcall	80004244 <xcmp_rx_process+0xf8>
80004210:	ca 7b       	rjmp	8000415e <xcmp_rx_process+0x12>
80004212:	00 00       	add	r0,r0
80004214:	00 00       	add	r0,r0
80004216:	0b 0c       	ld.w	r12,r5++
80004218:	00 00       	add	r0,r0
8000421a:	0a a4       	st.w	r5++,r4
8000421c:	00 00       	add	r0,r0
8000421e:	0b 1c       	ld.sh	r12,r5++
80004220:	00 00       	add	r0,r0
80004222:	0b 10       	ld.sh	r0,r5++
80004224:	00 00       	add	r0,r0
80004226:	0b 00       	ld.w	r0,r5++
80004228:	80 00       	ld.sh	r0,r0[0x0]
8000422a:	61 80       	ld.w	r0,r0[0x60]
8000422c:	00 00       	add	r0,r0
8000422e:	0b 34       	ld.ub	r4,r5++
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	40 50       	lddsp	r0,sp[0x14]
80004234:	00 00       	add	r0,r0
80004236:	0a f4       	st.b	--r5,r4
80004238:	00 00       	add	r0,r0
8000423a:	0b 28       	ld.uh	r8,r5++
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	40 2c       	lddsp	r12,sp[0x8]
80004240:	00 00       	add	r0,r0
80004242:	97 20       	st.w	r11[0x8],r0
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	2c 30       	sub	r0,-61

80004248 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004248:	eb cd 40 90 	pushm	r4,r7,lr
8000424c:	20 1d       	sub	sp,4
8000424e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004252:	48 c8       	lddpc	r8,80004280 <xcmp_rx+0x38>
80004254:	70 0c       	ld.w	r12,r8[0x0]
80004256:	f0 1f 00 0c 	mcall	80004284 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000425a:	c1 00       	breq	8000427a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000425c:	fa c7 ff fc 	sub	r7,sp,-4
80004260:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004262:	e0 6a 00 ca 	mov	r10,202
80004266:	08 9b       	mov	r11,r4
80004268:	f0 1f 00 08 	mcall	80004288 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000426c:	48 88       	lddpc	r8,8000428c <xcmp_rx+0x44>
8000426e:	70 0c       	ld.w	r12,r8[0x0]
80004270:	30 09       	mov	r9,0
80004272:	12 9a       	mov	r10,r9
80004274:	1a 9b       	mov	r11,sp
80004276:	f0 1f 00 07 	mcall	80004290 <xcmp_rx+0x48>
	}	
}
8000427a:	2f fd       	sub	sp,-4
8000427c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004280:	00 00       	add	r0,r0
80004282:	0a a4       	st.w	r5++,r4
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	2d dc       	sub	r12,-35
80004288:	80 00       	ld.sh	r0,r0[0x0]
8000428a:	78 40       	ld.w	r0,r12[0x10]
8000428c:	00 00       	add	r0,r0
8000428e:	0b 0c       	ld.w	r12,r5++
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	63 8c       	ld.w	r12,r1[0x60]

80004294 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004294:	48 28       	lddpc	r8,8000429c <xnl_register_xcmp_func+0x8>
80004296:	91 0c       	st.w	r8[0x0],r12
}
80004298:	5e fc       	retal	r12
8000429a:	00 00       	add	r0,r0
8000429c:	00 00       	add	r0,r0
8000429e:	0b 60       	ld.uh	r0,--r5

800042a0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800042a0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800042a2:	48 88       	lddpc	r8,800042c0 <xnl_get_msg_ack_func+0x20>
800042a4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800042a6:	98 49       	ld.sh	r9,r12[0x8]
800042a8:	f0 09 19 00 	cp.h	r9,r8
800042ac:	c0 81       	brne	800042bc <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800042ae:	48 68       	lddpc	r8,800042c4 <xnl_get_msg_ack_func+0x24>
800042b0:	70 0c       	ld.w	r12,r8[0x0]
800042b2:	30 09       	mov	r9,0
800042b4:	12 9a       	mov	r10,r9
800042b6:	12 9b       	mov	r11,r9
800042b8:	f0 1f 00 04 	mcall	800042c8 <xnl_get_msg_ack_func+0x28>
800042bc:	d8 02       	popm	pc
800042be:	00 00       	add	r0,r0
800042c0:	00 00       	add	r0,r0
800042c2:	0b 46       	ld.w	r6,--r5
800042c4:	00 00       	add	r0,r0
800042c6:	0b 40       	ld.w	r0,--r5
800042c8:	80 00       	ld.sh	r0,r0[0x0]
800042ca:	63 8c       	ld.w	r12,r1[0x60]

800042cc <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800042cc:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800042d0:	30 09       	mov	r9,0
800042d2:	4b 78       	lddpc	r8,800043ac <xnl_init+0xe0>
800042d4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800042d6:	30 0b       	mov	r11,0
800042d8:	30 1c       	mov	r12,1
800042da:	f0 1f 00 36 	mcall	800043b0 <xnl_init+0xe4>
800042de:	4b 68       	lddpc	r8,800043b4 <xnl_init+0xe8>
800042e0:	91 0c       	st.w	r8[0x0],r12
800042e2:	70 08       	ld.w	r8,r8[0x0]
800042e4:	58 08       	cp.w	r8,0
800042e6:	c0 80       	breq	800042f6 <xnl_init+0x2a>
800042e8:	4b 38       	lddpc	r8,800043b4 <xnl_init+0xe8>
800042ea:	70 0c       	ld.w	r12,r8[0x0]
800042ec:	30 09       	mov	r9,0
800042ee:	12 9a       	mov	r10,r9
800042f0:	12 9b       	mov	r11,r9
800042f2:	f0 1f 00 32 	mcall	800043b8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042f6:	30 4b       	mov	r11,4
800042f8:	33 2c       	mov	r12,50
800042fa:	f0 1f 00 2e 	mcall	800043b0 <xnl_init+0xe4>
800042fe:	4b 08       	lddpc	r8,800043bc <xnl_init+0xf0>
80004300:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004302:	30 4b       	mov	r11,4
80004304:	36 4c       	mov	r12,100
80004306:	f0 1f 00 2b 	mcall	800043b0 <xnl_init+0xe4>
8000430a:	4a e8       	lddpc	r8,800043c0 <xnl_init+0xf4>
8000430c:	91 0c       	st.w	r8[0x0],r12
8000430e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004310:	10 96       	mov	r6,r8
80004312:	4a d5       	lddpc	r5,800043c4 <xnl_init+0xf8>
80004314:	6c 0c       	ld.w	r12,r6[0x0]
80004316:	ea 07 00 0b 	add	r11,r5,r7
8000431a:	f0 1f 00 2c 	mcall	800043c8 <xnl_init+0xfc>
8000431e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004322:	e0 47 64 00 	cp.w	r7,25600
80004326:	cf 71       	brne	80004314 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004328:	30 4b       	mov	r11,4
8000432a:	31 4c       	mov	r12,20
8000432c:	f0 1f 00 21 	mcall	800043b0 <xnl_init+0xe4>
80004330:	4a 78       	lddpc	r8,800043cc <xnl_init+0x100>
80004332:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004334:	30 4b       	mov	r11,4
80004336:	31 4c       	mov	r12,20
80004338:	f0 1f 00 1e 	mcall	800043b0 <xnl_init+0xe4>
8000433c:	4a 58       	lddpc	r8,800043d0 <xnl_init+0x104>
8000433e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004340:	30 4b       	mov	r11,4
80004342:	30 ac       	mov	r12,10
80004344:	f0 1f 00 1b 	mcall	800043b0 <xnl_init+0xe4>
80004348:	4a 38       	lddpc	r8,800043d4 <xnl_init+0x108>
8000434a:	91 0c       	st.w	r8[0x0],r12
8000434c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000434e:	10 96       	mov	r6,r8
80004350:	4a 25       	lddpc	r5,800043d8 <xnl_init+0x10c>
80004352:	6c 0c       	ld.w	r12,r6[0x0]
80004354:	ea 07 00 0b 	add	r11,r5,r7
80004358:	f0 1f 00 1c 	mcall	800043c8 <xnl_init+0xfc>
8000435c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004360:	e0 47 14 00 	cp.w	r7,5120
80004364:	cf 71       	brne	80004352 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004366:	30 4b       	mov	r11,4
80004368:	30 5c       	mov	r12,5
8000436a:	f0 1f 00 12 	mcall	800043b0 <xnl_init+0xe4>
8000436e:	49 c8       	lddpc	r8,800043dc <xnl_init+0x110>
80004370:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004372:	30 07       	mov	r7,0
80004374:	1a d7       	st.w	--sp,r7
80004376:	1a d7       	st.w	--sp,r7
80004378:	1a d7       	st.w	--sp,r7
8000437a:	30 38       	mov	r8,3
8000437c:	0e 99       	mov	r9,r7
8000437e:	e0 6a 02 00 	mov	r10,512
80004382:	49 8b       	lddpc	r11,800043e0 <xnl_init+0x114>
80004384:	49 8c       	lddpc	r12,800043e4 <xnl_init+0x118>
80004386:	f0 1f 00 19 	mcall	800043e8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000438a:	1a d7       	st.w	--sp,r7
8000438c:	1a d7       	st.w	--sp,r7
8000438e:	1a d7       	st.w	--sp,r7
80004390:	30 38       	mov	r8,3
80004392:	0e 99       	mov	r9,r7
80004394:	e0 6a 00 82 	mov	r10,130
80004398:	49 5b       	lddpc	r11,800043ec <xnl_init+0x120>
8000439a:	49 6c       	lddpc	r12,800043f0 <xnl_init+0x124>
8000439c:	f0 1f 00 13 	mcall	800043e8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800043a0:	f0 1f 00 15 	mcall	800043f4 <xnl_init+0x128>
800043a4:	2f ad       	sub	sp,-24
}
800043a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800043aa:	00 00       	add	r0,r0
800043ac:	00 00       	add	r0,r0
800043ae:	0b 46       	ld.w	r6,--r5
800043b0:	80 00       	ld.sh	r0,r0[0x0]
800043b2:	64 e4       	ld.w	r4,r2[0x38]
800043b4:	00 00       	add	r0,r0
800043b6:	0b 40       	ld.w	r0,--r5
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	63 8c       	ld.w	r12,r1[0x60]
800043bc:	00 00       	add	r0,r0
800043be:	0b 54       	ld.sh	r4,--r5
800043c0:	00 00       	add	r0,r0
800043c2:	0a a4       	st.w	r5++,r4
800043c4:	00 00       	add	r0,r0
800043c6:	32 d2       	mov	r2,45
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	2c 30       	sub	r0,-61
800043cc:	00 00       	add	r0,r0
800043ce:	0a d4       	st.w	--r5,r4
800043d0:	00 00       	add	r0,r0
800043d2:	0a b4       	st.h	r5++,r4
800043d4:	00 00       	add	r0,r0
800043d6:	0a a8       	st.w	r5++,r8
800043d8:	00 00       	add	r0,r0
800043da:	1e d2       	st.w	--pc,r2
800043dc:	00 00       	add	r0,r0
800043de:	0a e0       	st.h	--r5,r0
800043e0:	80 00       	ld.sh	r0,r0[0x0]
800043e2:	d8 2c       	*unknown*
800043e4:	80 00       	ld.sh	r0,r0[0x0]
800043e6:	43 f8       	lddsp	r8,sp[0xfc]
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	6c 00       	ld.w	r0,r6[0x0]
800043ec:	80 00       	ld.sh	r0,r0[0x0]
800043ee:	d8 34       	*unknown*
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	44 58       	lddsp	r8,sp[0x114]
800043f4:	80 00       	ld.sh	r0,r0[0x0]
800043f6:	2e 04       	sub	r4,-32

800043f8 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800043f8:	eb cd 40 fe 	pushm	r1-r7,lr
800043fc:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043fe:	49 26       	lddpc	r6,80004444 <xnl_rx_process+0x4c>
80004400:	30 05       	mov	r5,0
80004402:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004404:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004406:	49 11       	lddpc	r1,80004448 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004408:	49 12       	lddpc	r2,8000444c <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000440a:	6c 0c       	ld.w	r12,r6[0x0]
8000440c:	0a 99       	mov	r9,r5
8000440e:	08 9a       	mov	r10,r4
80004410:	1a 9b       	mov	r11,sp
80004412:	f0 1f 00 10 	mcall	80004450 <xnl_rx_process+0x58>
80004416:	58 1c       	cp.w	r12,1
80004418:	cf 91       	brne	8000440a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000441a:	40 0c       	lddsp	r12,sp[0x0]
8000441c:	58 0c       	cp.w	r12,0
8000441e:	cf 60       	breq	8000440a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004420:	98 28       	ld.sh	r8,r12[0x4]
80004422:	e6 08 19 00 	cp.h	r8,r3
80004426:	e0 8b 00 0a 	brhi	8000443a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000442a:	5c 78       	castu.h	r8
8000442c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004430:	58 09       	cp.w	r9,0
80004432:	c0 40       	breq	8000443a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004434:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004438:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000443a:	62 0c       	ld.w	r12,r1[0x0]
8000443c:	40 0b       	lddsp	r11,sp[0x0]
8000443e:	f0 1f 00 06 	mcall	80004454 <xnl_rx_process+0x5c>
80004442:	ce 4b       	rjmp	8000440a <xnl_rx_process+0x12>
80004444:	00 00       	add	r0,r0
80004446:	0a b4       	st.h	r5++,r4
80004448:	00 00       	add	r0,r0
8000444a:	0a a4       	st.w	r5++,r4
8000444c:	00 00       	add	r0,r0
8000444e:	04 f4       	st.b	--r2,r4
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	61 80       	ld.w	r0,r0[0x60]
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	2c 30       	sub	r0,-61

80004458 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004458:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000445a:	4a a6       	lddpc	r6,80004500 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000445c:	4a a2       	lddpc	r2,80004504 <xnl_tx_process+0xac>
8000445e:	4a b4       	lddpc	r4,80004508 <xnl_tx_process+0xb0>
80004460:	30 07       	mov	r7,0
80004462:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004464:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004466:	4a a5       	lddpc	r5,8000450c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004468:	4a a3       	lddpc	r3,80004510 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000446a:	6c 08       	ld.w	r8,r6[0x0]
8000446c:	58 08       	cp.w	r8,0
8000446e:	c0 40       	breq	80004476 <xnl_tx_process+0x1e>
80004470:	58 18       	cp.w	r8,1
80004472:	cf d1       	brne	8000446c <xnl_tx_process+0x14>
80004474:	c2 48       	rjmp	800044bc <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004476:	64 0c       	ld.w	r12,r2[0x0]
80004478:	0e 99       	mov	r9,r7
8000447a:	02 9a       	mov	r10,r1
8000447c:	08 9b       	mov	r11,r4
8000447e:	f0 1f 00 26 	mcall	80004514 <xnl_tx_process+0xbc>
80004482:	58 1c       	cp.w	r12,1
80004484:	cf 31       	brne	8000446a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004486:	68 0b       	ld.w	r11,r4[0x0]
80004488:	58 0b       	cp.w	r11,0
8000448a:	cf 00       	breq	8000446a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000448c:	96 28       	ld.sh	r8,r11[0x4]
8000448e:	e0 08 19 00 	cp.h	r8,r0
80004492:	c0 71       	brne	800044a0 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004494:	4a 18       	lddpc	r8,80004518 <xnl_tx_process+0xc0>
80004496:	70 08       	ld.w	r8,r8[0x0]
80004498:	10 9c       	mov	r12,r8
8000449a:	f0 1f 00 21 	mcall	8000451c <xnl_tx_process+0xc4>
						break;
8000449e:	ce 6b       	rjmp	8000446a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800044a0:	16 9c       	mov	r12,r11
800044a2:	f0 1f 00 20 	mcall	80004520 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800044a6:	30 18       	mov	r8,1
800044a8:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044aa:	66 0c       	ld.w	r12,r3[0x0]
800044ac:	0e 99       	mov	r9,r7
800044ae:	0e 9a       	mov	r10,r7
800044b0:	0e 9b       	mov	r11,r7
800044b2:	f0 1f 00 19 	mcall	80004514 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800044b6:	30 18       	mov	r8,1
800044b8:	8d 08       	st.w	r6[0x0],r8
800044ba:	cd 8b       	rjmp	8000446a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800044bc:	66 0c       	ld.w	r12,r3[0x0]
800044be:	0e 99       	mov	r9,r7
800044c0:	36 4a       	mov	r10,100
800044c2:	0e 9b       	mov	r11,r7
800044c4:	f0 1f 00 14 	mcall	80004514 <xnl_tx_process+0xbc>
800044c8:	58 1c       	cp.w	r12,1
800044ca:	c0 81       	brne	800044da <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800044cc:	49 38       	lddpc	r8,80004518 <xnl_tx_process+0xc0>
800044ce:	70 0c       	ld.w	r12,r8[0x0]
800044d0:	68 0b       	ld.w	r11,r4[0x0]
800044d2:	f0 1f 00 13 	mcall	8000451c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800044d6:	8d 07       	st.w	r6[0x0],r7
800044d8:	cc 9b       	rjmp	8000446a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800044da:	6a 08       	ld.w	r8,r5[0x0]
800044dc:	58 38       	cp.w	r8,3
800044de:	e0 89 00 09 	brgt	800044f0 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800044e2:	68 0c       	ld.w	r12,r4[0x0]
800044e4:	f0 1f 00 0f 	mcall	80004520 <xnl_tx_process+0xc8>
						xnl_send_times++;
800044e8:	6a 08       	ld.w	r8,r5[0x0]
800044ea:	2f f8       	sub	r8,-1
800044ec:	8b 08       	st.w	r5[0x0],r8
800044ee:	cb eb       	rjmp	8000446a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800044f0:	48 a8       	lddpc	r8,80004518 <xnl_tx_process+0xc0>
800044f2:	70 0c       	ld.w	r12,r8[0x0]
800044f4:	68 0b       	ld.w	r11,r4[0x0]
800044f6:	f0 1f 00 0a 	mcall	8000451c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044fa:	8d 07       	st.w	r6[0x0],r7
800044fc:	cb 7b       	rjmp	8000446a <xnl_tx_process+0x12>
800044fe:	00 00       	add	r0,r0
80004500:	00 00       	add	r0,r0
80004502:	0b 50       	ld.sh	r0,--r5
80004504:	00 00       	add	r0,r0
80004506:	0b 54       	ld.sh	r4,--r5
80004508:	00 00       	add	r0,r0
8000450a:	0b 5c       	ld.sh	r12,--r5
8000450c:	00 00       	add	r0,r0
8000450e:	0b 58       	ld.sh	r8,--r5
80004510:	00 00       	add	r0,r0
80004512:	0b 40       	ld.w	r0,--r5
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	61 80       	ld.w	r0,r0[0x60]
80004518:	00 00       	add	r0,r0
8000451a:	0a a4       	st.w	r5++,r4
8000451c:	80 00       	ld.sh	r0,r0[0x0]
8000451e:	2c 30       	sub	r0,-61
80004520:	80 00       	ld.sh	r0,r0[0x0]
80004522:	2c 50       	sub	r0,-59

80004524 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004524:	eb cd 40 c0 	pushm	r6-r7,lr
80004528:	20 1d       	sub	sp,4
8000452a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000452c:	98 39       	ld.sh	r9,r12[0x6]
8000452e:	3f f8       	mov	r8,-1
80004530:	f0 09 19 00 	cp.h	r9,r8
80004534:	c0 a1       	brne	80004548 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004536:	4a e9       	lddpc	r9,800045ec <xnl_tx+0xc8>
80004538:	13 88       	ld.ub	r8,r9[0x0]
8000453a:	2f f8       	sub	r8,-1
8000453c:	5c 58       	castu.b	r8
8000453e:	b2 88       	st.b	r9[0x0],r8
80004540:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004544:	a9 a8       	sbr	r8,0x8
80004546:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004548:	8c 49       	ld.sh	r9,r6[0x8]
8000454a:	3f f8       	mov	r8,-1
8000454c:	f0 09 19 00 	cp.h	r9,r8
80004550:	c0 41       	brne	80004558 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004552:	4a 88       	lddpc	r8,800045f0 <xnl_tx+0xcc>
80004554:	90 18       	ld.sh	r8,r8[0x2]
80004556:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004558:	8c 59       	ld.sh	r9,r6[0xa]
8000455a:	3f f8       	mov	r8,-1
8000455c:	f0 09 19 00 	cp.h	r9,r8
80004560:	c0 41       	brne	80004568 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004562:	4a 48       	lddpc	r8,800045f0 <xnl_tx+0xcc>
80004564:	90 28       	ld.sh	r8,r8[0x4]
80004566:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004568:	8c 69       	ld.sh	r9,r6[0xc]
8000456a:	3f f8       	mov	r8,-1
8000456c:	f0 09 19 00 	cp.h	r9,r8
80004570:	c0 e1       	brne	8000458c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004572:	4a 08       	lddpc	r8,800045f0 <xnl_tx+0xcc>
80004574:	90 49       	ld.sh	r9,r8[0x8]
80004576:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004578:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000457a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000457c:	90 49       	ld.sh	r9,r8[0x8]
8000457e:	e0 19 ff 00 	andl	r9,0xff00
80004582:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004586:	f3 e8 10 08 	or	r8,r9,r8
8000458a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000458c:	0d 98       	ld.ub	r8,r6[0x1]
8000458e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004590:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004594:	10 0c       	add	r12,r8
80004596:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004598:	58 0c       	cp.w	r12,0
8000459a:	e0 89 00 04 	brgt	800045a2 <xnl_tx+0x7e>
8000459e:	30 09       	mov	r9,0
800045a0:	c0 d8       	rjmp	800045ba <xnl_tx+0x96>
800045a2:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800045a6:	2f ec       	sub	r12,-2
800045a8:	30 09       	mov	r9,0
800045aa:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800045ac:	15 1b       	ld.sh	r11,r10++
800045ae:	f6 09 00 09 	add	r9,r11,r9
800045b2:	5c 89       	casts.h	r9
		indextohWord     += 1;
800045b4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800045b6:	18 38       	cp.w	r8,r12
800045b8:	cf a1       	brne	800045ac <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800045ba:	5c 39       	neg	r9
800045bc:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045be:	48 e8       	lddpc	r8,800045f4 <xnl_tx+0xd0>
800045c0:	70 0c       	ld.w	r12,r8[0x0]
800045c2:	f0 1f 00 0e 	mcall	800045f8 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800045c6:	c1 00       	breq	800045e6 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800045c8:	fa c7 ff fc 	sub	r7,sp,-4
800045cc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800045ce:	e0 6a 01 00 	mov	r10,256
800045d2:	0c 9b       	mov	r11,r6
800045d4:	f0 1f 00 0a 	mcall	800045fc <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800045d8:	48 a8       	lddpc	r8,80004600 <xnl_tx+0xdc>
800045da:	70 0c       	ld.w	r12,r8[0x0]
800045dc:	30 09       	mov	r9,0
800045de:	12 9a       	mov	r10,r9
800045e0:	1a 9b       	mov	r11,sp
800045e2:	f0 1f 00 09 	mcall	80004604 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800045e6:	2f fd       	sub	sp,-4
800045e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045ec:	00 00       	add	r0,r0
800045ee:	0b 44       	ld.w	r4,--r5
800045f0:	00 00       	add	r0,r0
800045f2:	0b 46       	ld.w	r6,--r5
800045f4:	00 00       	add	r0,r0
800045f6:	0a a4       	st.w	r5++,r4
800045f8:	80 00       	ld.sh	r0,r0[0x0]
800045fa:	2d dc       	sub	r12,-35
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	78 40       	ld.w	r0,r12[0x10]
80004600:	00 00       	add	r0,r0
80004602:	0b 54       	ld.sh	r4,--r5
80004604:	80 00       	ld.sh	r0,r0[0x0]
80004606:	63 8c       	ld.w	r12,r1[0x60]

80004608 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004608:	eb cd 40 80 	pushm	r7,lr
8000460c:	fa cd 01 00 	sub	sp,sp,256
80004610:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004612:	e0 68 40 0e 	mov	r8,16398
80004616:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004618:	3f f8       	mov	r8,-1
8000461a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000461c:	30 c8       	mov	r8,12
8000461e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004620:	98 38       	ld.sh	r8,r12[0x6]
80004622:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004624:	98 58       	ld.sh	r8,r12[0xa]
80004626:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004628:	98 48       	ld.sh	r8,r12[0x8]
8000462a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000462c:	98 68       	ld.sh	r8,r12[0xc]
8000462e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004630:	30 08       	mov	r8,0
80004632:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004634:	1a 9c       	mov	r12,sp
80004636:	f0 1f 00 0a 	mcall	8000465c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000463a:	fa cd 00 cc 	sub	sp,sp,204
8000463e:	e0 6a 00 ca 	mov	r10,202
80004642:	ee cb ff f0 	sub	r11,r7,-16
80004646:	1a 9c       	mov	r12,sp
80004648:	f0 1f 00 06 	mcall	80004660 <xnl_data_msg_func+0x58>
8000464c:	48 68       	lddpc	r8,80004664 <xnl_data_msg_func+0x5c>
8000464e:	70 08       	ld.w	r8,r8[0x0]
80004650:	5d 18       	icall	r8
80004652:	fa cd ff 34 	sub	sp,sp,-204
}
80004656:	2c 0d       	sub	sp,-256
80004658:	e3 cd 80 80 	ldm	sp++,r7,pc
8000465c:	80 00       	ld.sh	r0,r0[0x0]
8000465e:	45 24       	lddsp	r4,sp[0x148]
80004660:	80 00       	ld.sh	r0,r0[0x0]
80004662:	78 40       	ld.w	r0,r12[0x10]
80004664:	00 00       	add	r0,r0
80004666:	0b 60       	ld.uh	r0,--r5

80004668 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004668:	d4 21       	pushm	r4-r7,lr
8000466a:	fa cd 01 00 	sub	sp,sp,256
8000466e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004670:	4c 28       	lddpc	r8,80004778 <xnl_device_auth_reply_func+0x110>
80004672:	11 88       	ld.ub	r8,r8[0x0]
80004674:	58 08       	cp.w	r8,0
80004676:	e0 81 00 7f 	brne	80004774 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000467a:	4c 18       	lddpc	r8,8000477c <xnl_device_auth_reply_func+0x114>
8000467c:	70 0c       	ld.w	r12,r8[0x0]
8000467e:	30 09       	mov	r9,0
80004680:	12 9a       	mov	r10,r9
80004682:	12 9b       	mov	r11,r9
80004684:	f0 1f 00 3f 	mcall	80004780 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004688:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000468c:	4b b8       	lddpc	r8,80004778 <xnl_device_auth_reply_func+0x110>
8000468e:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004690:	ef 39 00 12 	ld.ub	r9,r7[18]
80004694:	ef 38 00 13 	ld.ub	r8,r7[19]
80004698:	b1 68       	lsl	r8,0x10
8000469a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000469e:	ef 38 00 15 	ld.ub	r8,r7[21]
800046a2:	f3 e8 10 08 	or	r8,r9,r8
800046a6:	ef 39 00 14 	ld.ub	r9,r7[20]
800046aa:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800046ae:	ef 3a 00 16 	ld.ub	r10,r7[22]
800046b2:	ef 38 00 17 	ld.ub	r8,r7[23]
800046b6:	b1 68       	lsl	r8,0x10
800046b8:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800046bc:	ef 38 00 19 	ld.ub	r8,r7[25]
800046c0:	f5 e8 10 08 	or	r8,r10,r8
800046c4:	ef 3a 00 18 	ld.ub	r10,r7[24]
800046c8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800046cc:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046ce:	e0 64 79 b9 	mov	r4,31161
800046d2:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046d6:	e0 65 45 07 	mov	r5,17671
800046da:	ea 15 8a bd 	orh	r5,0x8abd
800046de:	e0 66 f9 3d 	mov	r6,63805
800046e2:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046e6:	e0 6e b8 cf 	mov	lr,47311
800046ea:	ea 1e 36 83 	orh	lr,0x3683
800046ee:	e0 67 aa 1c 	mov	r7,43548
800046f2:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046f6:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046f8:	f4 08 00 0c 	add	r12,r10,r8
800046fc:	f0 0b 15 04 	lsl	r11,r8,0x4
80004700:	0a 0b       	add	r11,r5
80004702:	f9 eb 20 0b 	eor	r11,r12,r11
80004706:	f0 0c 16 05 	lsr	r12,r8,0x5
8000470a:	0c 0c       	add	r12,r6
8000470c:	18 5b       	eor	r11,r12
8000470e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004710:	f2 0c 15 04 	lsl	r12,r9,0x4
80004714:	1c 0c       	add	r12,lr
80004716:	f2 0b 16 05 	lsr	r11,r9,0x5
8000471a:	0e 0b       	add	r11,r7
8000471c:	f9 eb 20 0b 	eor	r11,r12,r11
80004720:	f2 0a 00 0c 	add	r12,r9,r10
80004724:	18 5b       	eor	r11,r12
80004726:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004728:	e0 6b 37 20 	mov	r11,14112
8000472c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004730:	16 3a       	cp.w	r10,r11
80004732:	ce 21       	brne	800046f6 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004734:	e0 6a 40 1a 	mov	r10,16410
80004738:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000473a:	3f fa       	mov	r10,-1
8000473c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000473e:	30 6b       	mov	r11,6
80004740:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004742:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004744:	48 db       	lddpc	r11,80004778 <xnl_device_auth_reply_func+0x110>
80004746:	96 1c       	ld.sh	r12,r11[0x2]
80004748:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000474a:	96 2b       	ld.sh	r11,r11[0x4]
8000474c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000474e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004750:	30 ca       	mov	r10,12
80004752:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004754:	30 0a       	mov	r10,0
80004756:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000475a:	30 7a       	mov	r10,7
8000475c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004760:	30 2a       	mov	r10,2
80004762:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004766:	fa ca ff ec 	sub	r10,sp,-20
8000476a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000476c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000476e:	1a 9c       	mov	r12,sp
80004770:	f0 1f 00 05 	mcall	80004784 <xnl_device_auth_reply_func+0x11c>
}
80004774:	2c 0d       	sub	sp,-256
80004776:	d8 22       	popm	r4-r7,pc
80004778:	00 00       	add	r0,r0
8000477a:	0b 46       	ld.w	r6,--r5
8000477c:	00 00       	add	r0,r0
8000477e:	0b 40       	ld.w	r0,--r5
80004780:	80 00       	ld.sh	r0,r0[0x0]
80004782:	63 8c       	ld.w	r12,r1[0x60]
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	45 24       	lddsp	r4,sp[0x148]

80004788 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004788:	eb cd 40 80 	pushm	r7,lr
8000478c:	fa cd 01 00 	sub	sp,sp,256
80004790:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004792:	49 28       	lddpc	r8,800047d8 <xnl_master_status_brdcst_func+0x50>
80004794:	11 88       	ld.ub	r8,r8[0x0]
80004796:	58 08       	cp.w	r8,0
80004798:	c1 c1       	brne	800047d0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000479a:	49 18       	lddpc	r8,800047dc <xnl_master_status_brdcst_func+0x54>
8000479c:	70 0c       	ld.w	r12,r8[0x0]
8000479e:	30 09       	mov	r9,0
800047a0:	12 9a       	mov	r10,r9
800047a2:	12 9b       	mov	r11,r9
800047a4:	f0 1f 00 0f 	mcall	800047e0 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800047a8:	8e 58       	ld.sh	r8,r7[0xa]
800047aa:	48 c9       	lddpc	r9,800047d8 <xnl_master_status_brdcst_func+0x50>
800047ac:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047ae:	e0 68 40 0e 	mov	r8,16398
800047b2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047b4:	3f f8       	mov	r8,-1
800047b6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800047b8:	30 4a       	mov	r10,4
800047ba:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047bc:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047be:	92 19       	ld.sh	r9,r9[0x2]
800047c0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800047c2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047c4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800047c6:	30 08       	mov	r8,0
800047c8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800047ca:	1a 9c       	mov	r12,sp
800047cc:	f0 1f 00 06 	mcall	800047e4 <xnl_master_status_brdcst_func+0x5c>
}
800047d0:	2c 0d       	sub	sp,-256
800047d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800047d6:	00 00       	add	r0,r0
800047d8:	00 00       	add	r0,r0
800047da:	0b 46       	ld.w	r6,--r5
800047dc:	00 00       	add	r0,r0
800047de:	0b 40       	ld.w	r0,--r5
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	63 8c       	ld.w	r12,r1[0x60]
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	45 24       	lddsp	r4,sp[0x148]

800047e8 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800047e8:	eb cd 40 80 	pushm	r7,lr
800047ec:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800047ee:	49 28       	lddpc	r8,80004834 <xnl_device_conn_reply_func+0x4c>
800047f0:	70 0c       	ld.w	r12,r8[0x0]
800047f2:	30 09       	mov	r9,0
800047f4:	12 9a       	mov	r10,r9
800047f6:	12 9b       	mov	r11,r9
800047f8:	f0 1f 00 10 	mcall	80004838 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800047fc:	ef 18 00 10 	ld.uh	r8,r7[16]
80004800:	10 99       	mov	r9,r8
80004802:	e2 19 ff 00 	andl	r9,0xff00,COH
80004806:	e0 49 01 00 	cp.w	r9,256
8000480a:	c0 60       	breq	80004816 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000480c:	0e 9c       	mov	r12,r7
8000480e:	f0 1f 00 0c 	mcall	8000483c <xnl_device_conn_reply_func+0x54>
80004812:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004816:	a9 68       	lsl	r8,0x8
80004818:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000481c:	48 98       	lddpc	r8,80004840 <xnl_device_conn_reply_func+0x58>
8000481e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004820:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004824:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004826:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000482a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000482c:	30 19       	mov	r9,1
8000482e:	b0 89       	st.b	r8[0x0],r9
80004830:	e3 cd 80 80 	ldm	sp++,r7,pc
80004834:	00 00       	add	r0,r0
80004836:	0b 40       	ld.w	r0,--r5
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	63 8c       	ld.w	r12,r1[0x60]
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	47 88       	lddsp	r8,sp[0x1e0]
80004840:	00 00       	add	r0,r0
80004842:	0b 46       	ld.w	r6,--r5

80004844 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004844:	d4 01       	pushm	lr
80004846:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000484a:	e0 68 40 0e 	mov	r8,16398
8000484e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004850:	3f f8       	mov	r8,-1
80004852:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004854:	30 38       	mov	r8,3
80004856:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004858:	30 08       	mov	r8,0
8000485a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000485c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000485e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004860:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004862:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004864:	1a 9c       	mov	r12,sp
80004866:	f0 1f 00 03 	mcall	80004870 <xnl_send_device_master_query+0x2c>
}
8000486a:	2c 0d       	sub	sp,-256
8000486c:	d8 02       	popm	pc
8000486e:	00 00       	add	r0,r0
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	45 24       	lddsp	r4,sp[0x148]

80004874 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004874:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004876:	48 78       	lddpc	r8,80004890 <RC522_SPI_SetSpeed+0x1c>
80004878:	70 09       	ld.w	r9,r8[0x0]
8000487a:	72 ca       	ld.w	r10,r9[0x30]
8000487c:	5c 7c       	castu.h	r12
8000487e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004882:	f9 ea 10 0a 	or	r10,r12,r10
80004886:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004888:	70 0c       	ld.w	r12,r8[0x0]
8000488a:	f0 1f 00 03 	mcall	80004894 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000488e:	d8 02       	popm	pc
80004890:	00 00       	add	r0,r0
80004892:	1d ac       	ld.ub	r12,lr[0x2]
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	58 7c       	cp.w	r12,7

80004898 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004898:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000489a:	e0 6c 0a 00 	mov	r12,2560
8000489e:	f0 1f 00 02 	mcall	800048a4 <RC522_SPI_SetSpeedLow+0xc>
	
}
800048a2:	d8 02       	popm	pc
800048a4:	80 00       	ld.sh	r0,r0[0x0]
800048a6:	48 74       	lddpc	r4,800048c0 <RC522_ReadByte+0x18>

800048a8 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800048a8:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800048ac:	48 76       	lddpc	r6,800048c8 <RC522_ReadByte+0x20>
800048ae:	e0 6b 00 ff 	mov	r11,255
800048b2:	6c 0c       	ld.w	r12,r6[0x0]
800048b4:	f0 1f 00 06 	mcall	800048cc <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800048b8:	30 07       	mov	r7,0
800048ba:	0e 9b       	mov	r11,r7
800048bc:	6c 0c       	ld.w	r12,r6[0x0]
800048be:	f0 1f 00 05 	mcall	800048d0 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800048c2:	0f 9c       	ld.ub	r12,r7[0x1]
800048c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048c8:	00 00       	add	r0,r0
800048ca:	1d ac       	ld.ub	r12,lr[0x2]
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	58 82       	cp.w	r2,8
800048d0:	80 00       	ld.sh	r0,r0[0x0]
800048d2:	58 9e       	cp.w	lr,9

800048d4 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800048d4:	eb cd 40 80 	pushm	r7,lr
800048d8:	20 1d       	sub	sp,4
800048da:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800048dc:	48 77       	lddpc	r7,800048f8 <RC522_WriteByte+0x24>
800048de:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800048e2:	6e 0c       	ld.w	r12,r7[0x0]
800048e4:	f0 1f 00 06 	mcall	800048fc <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800048e8:	1a 9b       	mov	r11,sp
800048ea:	6e 0c       	ld.w	r12,r7[0x0]
800048ec:	f0 1f 00 05 	mcall	80004900 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800048f0:	5c 5c       	castu.b	r12
800048f2:	2f fd       	sub	sp,-4
800048f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800048f8:	00 00       	add	r0,r0
800048fa:	1d ac       	ld.ub	r12,lr[0x2]
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	58 82       	cp.w	r2,8
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	58 9e       	cp.w	lr,9

80004904 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004904:	eb cd 40 e0 	pushm	r5-r7,lr
80004908:	18 96       	mov	r6,r12
8000490a:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000490c:	48 a7       	lddpc	r7,80004934 <WriteRawRC+0x30>
8000490e:	30 0b       	mov	r11,0
80004910:	6e 0c       	ld.w	r12,r7[0x0]
80004912:	f0 1f 00 0a 	mcall	80004938 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004916:	ec 0c 15 01 	lsl	r12,r6,0x1
8000491a:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000491e:	f0 1f 00 08 	mcall	8000493c <WriteRawRC+0x38>
	RC522_WriteByte(value);
80004922:	0a 9c       	mov	r12,r5
80004924:	f0 1f 00 06 	mcall	8000493c <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004928:	30 0b       	mov	r11,0
8000492a:	6e 0c       	ld.w	r12,r7[0x0]
8000492c:	f0 1f 00 05 	mcall	80004940 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004930:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004934:	00 00       	add	r0,r0
80004936:	1d ac       	ld.ub	r12,lr[0x2]
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	59 e8       	cp.w	r8,30
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	48 d4       	lddpc	r4,80004970 <PcdReset+0x2c>
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	59 a8       	cp.w	r8,26

80004944 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004944:	d4 01       	pushm	lr

	SET_RC522RST;
80004946:	31 9c       	mov	r12,25
80004948:	f0 1f 00 1b 	mcall	800049b4 <PcdReset+0x70>
	delay_ns(10);
8000494c:	30 ac       	mov	r12,10
8000494e:	f0 1f 00 1b 	mcall	800049b8 <PcdReset+0x74>

	CLR_RC522RST;
80004952:	31 9c       	mov	r12,25
80004954:	f0 1f 00 1a 	mcall	800049bc <PcdReset+0x78>
	delay_ns(10);
80004958:	30 ac       	mov	r12,10
8000495a:	f0 1f 00 18 	mcall	800049b8 <PcdReset+0x74>

	SET_RC522RST;
8000495e:	31 9c       	mov	r12,25
80004960:	f0 1f 00 15 	mcall	800049b4 <PcdReset+0x70>
	delay_ns(10);
80004964:	30 ac       	mov	r12,10
80004966:	f0 1f 00 15 	mcall	800049b8 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000496a:	30 fb       	mov	r11,15
8000496c:	30 1c       	mov	r12,1
8000496e:	f0 1f 00 15 	mcall	800049c0 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004972:	30 fb       	mov	r11,15
80004974:	30 1c       	mov	r12,1
80004976:	f0 1f 00 13 	mcall	800049c0 <PcdReset+0x7c>
	delay_ns(10);
8000497a:	30 ac       	mov	r12,10
8000497c:	f0 1f 00 0f 	mcall	800049b8 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004980:	33 db       	mov	r11,61
80004982:	31 1c       	mov	r12,17
80004984:	f0 1f 00 0f 	mcall	800049c0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004988:	31 eb       	mov	r11,30
8000498a:	32 dc       	mov	r12,45
8000498c:	f0 1f 00 0d 	mcall	800049c0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004990:	30 0b       	mov	r11,0
80004992:	32 cc       	mov	r12,44
80004994:	f0 1f 00 0b 	mcall	800049c0 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004998:	e0 6b 00 8d 	mov	r11,141
8000499c:	32 ac       	mov	r12,42
8000499e:	f0 1f 00 09 	mcall	800049c0 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800049a2:	33 eb       	mov	r11,62
800049a4:	32 bc       	mov	r12,43
800049a6:	f0 1f 00 07 	mcall	800049c0 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800049aa:	34 0b       	mov	r11,64
800049ac:	31 5c       	mov	r12,21
800049ae:	f0 1f 00 05 	mcall	800049c0 <PcdReset+0x7c>
	
	return MI_OK;
}
800049b2:	d8 0a       	popm	pc,r12=0
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	55 60       	stdsp	sp[0x158],r0
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	53 00       	stdsp	sp[0xc0],r0
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	55 7c       	stdsp	sp[0x15c],r12
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	49 04       	lddpc	r4,80004a00 <ReadRawRC+0x3c>

800049c4 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800049c4:	eb cd 40 c0 	pushm	r6-r7,lr
800049c8:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800049ca:	48 c7       	lddpc	r7,800049f8 <ReadRawRC+0x34>
800049cc:	30 0b       	mov	r11,0
800049ce:	6e 0c       	ld.w	r12,r7[0x0]
800049d0:	f0 1f 00 0b 	mcall	800049fc <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800049d4:	a1 76       	lsl	r6,0x1
800049d6:	0c 9c       	mov	r12,r6
800049d8:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049dc:	a7 bc       	sbr	r12,0x7
800049de:	f0 1f 00 09 	mcall	80004a00 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800049e2:	f0 1f 00 09 	mcall	80004a04 <ReadRawRC+0x40>
800049e6:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800049e8:	30 0b       	mov	r11,0
800049ea:	6e 0c       	ld.w	r12,r7[0x0]
800049ec:	f0 1f 00 07 	mcall	80004a08 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800049f0:	0c 9c       	mov	r12,r6
800049f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049f6:	00 00       	add	r0,r0
800049f8:	00 00       	add	r0,r0
800049fa:	1d ac       	ld.ub	r12,lr[0x2]
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	59 e8       	cp.w	r8,30
80004a00:	80 00       	ld.sh	r0,r0[0x0]
80004a02:	48 d4       	lddpc	r4,80004a34 <Powerdown_RC522+0x18>
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	48 a8       	lddpc	r8,80004a2c <Powerdown_RC522+0x10>
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	59 a8       	cp.w	r8,26

80004a0c <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80004a0c:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80004a0e:	30 1c       	mov	r12,1
80004a10:	f0 1f 00 02 	mcall	80004a18 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004a14:	d8 02       	popm	pc
80004a16:	00 00       	add	r0,r0
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	49 c4       	lddpc	r4,80004a88 <SetBitMask+0x20>

80004a1c <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80004a1c:	eb cd 40 80 	pushm	r7,lr
80004a20:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004a22:	30 1c       	mov	r12,1
80004a24:	f0 1f 00 0d 	mcall	80004a58 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004a28:	30 18       	mov	r8,1
80004a2a:	f0 07 18 00 	cp.b	r7,r8
80004a2e:	c0 91       	brne	80004a40 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004a30:	18 9b       	mov	r11,r12
80004a32:	a5 ab       	sbr	r11,0x4
80004a34:	5c 5b       	castu.b	r11
80004a36:	30 1c       	mov	r12,1
80004a38:	f0 1f 00 09 	mcall	80004a5c <Powerdown_RC522+0x40>
80004a3c:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004a40:	18 9b       	mov	r11,r12
80004a42:	30 1c       	mov	r12,1
80004a44:	f0 1f 00 06 	mcall	80004a5c <Powerdown_RC522+0x40>
		delay_ns(2);
80004a48:	30 2c       	mov	r12,2
80004a4a:	f0 1f 00 06 	mcall	80004a60 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004a4e:	f0 1f 00 06 	mcall	80004a64 <Powerdown_RC522+0x48>
80004a52:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a56:	00 00       	add	r0,r0
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	49 c4       	lddpc	r4,80004ac8 <ClearBitMask+0x1c>
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	49 04       	lddpc	r4,80004a9c <PcdAntennaOn+0x10>
80004a60:	80 00       	ld.sh	r0,r0[0x0]
80004a62:	53 00       	stdsp	sp[0xc0],r0
80004a64:	80 00       	ld.sh	r0,r0[0x0]
80004a66:	4a 0c       	lddpc	r12,80004ae4 <M500PcdConfigISOType>

80004a68 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004a68:	eb cd 40 c0 	pushm	r6-r7,lr
80004a6c:	18 97       	mov	r7,r12
80004a6e:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004a70:	f0 1f 00 05 	mcall	80004a84 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004a74:	f9 e6 10 0b 	or	r11,r12,r6
80004a78:	5c 5b       	castu.b	r11
80004a7a:	0e 9c       	mov	r12,r7
80004a7c:	f0 1f 00 03 	mcall	80004a88 <SetBitMask+0x20>
}
80004a80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	49 c4       	lddpc	r4,80004af4 <M500PcdConfigISOType+0x10>
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	49 04       	lddpc	r4,80004ac8 <ClearBitMask+0x1c>

80004a8c <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a8c:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a8e:	31 4c       	mov	r12,20
80004a90:	f0 1f 00 05 	mcall	80004aa4 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a94:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a98:	c0 51       	brne	80004aa2 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a9a:	30 3b       	mov	r11,3
80004a9c:	31 4c       	mov	r12,20
80004a9e:	f0 1f 00 03 	mcall	80004aa8 <PcdAntennaOn+0x1c>
80004aa2:	d8 02       	popm	pc
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	49 c4       	lddpc	r4,80004b14 <M500PcdConfigISOType+0x30>
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	4a 68       	lddpc	r8,80004b40 <M500PcdConfigISOType+0x5c>

80004aac <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004aac:	eb cd 40 c0 	pushm	r6-r7,lr
80004ab0:	18 97       	mov	r7,r12
80004ab2:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004ab4:	f0 1f 00 06 	mcall	80004acc <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004ab8:	5c d6       	com	r6
80004aba:	f9 e6 00 06 	and	r6,r12,r6
80004abe:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004ac2:	0e 9c       	mov	r12,r7
80004ac4:	f0 1f 00 03 	mcall	80004ad0 <ClearBitMask+0x24>
	
}
80004ac8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	49 c4       	lddpc	r4,80004b3c <M500PcdConfigISOType+0x58>
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	49 04       	lddpc	r4,80004b10 <M500PcdConfigISOType+0x2c>

80004ad4 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004ad4:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004ad6:	30 3b       	mov	r11,3
80004ad8:	31 4c       	mov	r12,20
80004ada:	f0 1f 00 02 	mcall	80004ae0 <PcdAntennaOff+0xc>
}
80004ade:	d8 02       	popm	pc
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	4a ac       	lddpc	r12,80004b88 <rc522_init+0x34>

80004ae4 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004ae4:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004ae6:	34 18       	mov	r8,65
80004ae8:	f0 0c 18 00 	cp.b	r12,r8
80004aec:	c0 20       	breq	80004af0 <M500PcdConfigISOType+0xc>
80004aee:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004af0:	30 8b       	mov	r11,8
80004af2:	16 9c       	mov	r12,r11
80004af4:	f0 1f 00 14 	mcall	80004b44 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004af8:	33 db       	mov	r11,61
80004afa:	31 1c       	mov	r12,17
80004afc:	f0 1f 00 13 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004b00:	e0 6b 00 86 	mov	r11,134
80004b04:	31 7c       	mov	r12,23
80004b06:	f0 1f 00 11 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004b0a:	37 fb       	mov	r11,127
80004b0c:	32 6c       	mov	r12,38
80004b0e:	f0 1f 00 0f 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004b12:	31 eb       	mov	r11,30
80004b14:	32 dc       	mov	r12,45
80004b16:	f0 1f 00 0d 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004b1a:	30 0b       	mov	r11,0
80004b1c:	32 cc       	mov	r12,44
80004b1e:	f0 1f 00 0b 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004b22:	e0 6b 00 8d 	mov	r11,141
80004b26:	32 ac       	mov	r12,42
80004b28:	f0 1f 00 08 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004b2c:	33 eb       	mov	r11,62
80004b2e:	32 bc       	mov	r12,43
80004b30:	f0 1f 00 06 	mcall	80004b48 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004b34:	e0 6c 03 e8 	mov	r12,1000
80004b38:	f0 1f 00 05 	mcall	80004b4c <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004b3c:	f0 1f 00 05 	mcall	80004b50 <M500PcdConfigISOType+0x6c>
80004b40:	d8 0a       	popm	pc,r12=0
80004b42:	00 00       	add	r0,r0
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	4a ac       	lddpc	r12,80004bec <rc522_init+0x98>
80004b48:	80 00       	ld.sh	r0,r0[0x0]
80004b4a:	49 04       	lddpc	r4,80004b88 <rc522_init+0x34>
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	53 00       	stdsp	sp[0xc0],r0
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	4a 8c       	lddpc	r12,80004bf0 <rc522_init+0x9c>

80004b54 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004b54:	eb cd 40 c0 	pushm	r6-r7,lr
80004b58:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004b5a:	4a 38       	lddpc	r8,80004be4 <rc522_init+0x90>
80004b5c:	1a 96       	mov	r6,sp
80004b5e:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b62:	fa eb 00 00 	st.d	sp[0],r10
80004b66:	f0 e8 00 08 	ld.d	r8,r8[8]
80004b6a:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004b6e:	30 4b       	mov	r11,4
80004b70:	49 ec       	lddpc	r12,80004be8 <rc522_init+0x94>
80004b72:	f0 1f 00 1f 	mcall	80004bec <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004b76:	31 9c       	mov	r12,25
80004b78:	f0 1f 00 1e 	mcall	80004bf0 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004b7c:	31 9c       	mov	r12,25
80004b7e:	f0 1f 00 1e 	mcall	80004bf4 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004b82:	49 e7       	lddpc	r7,80004bf8 <rc522_init+0xa4>
80004b84:	fe 7c 24 00 	mov	r12,-56320
80004b88:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004b8a:	1a 9b       	mov	r11,sp
80004b8c:	f0 1f 00 1c 	mcall	80004bfc <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b90:	30 09       	mov	r9,0
80004b92:	12 9a       	mov	r10,r9
80004b94:	12 9b       	mov	r11,r9
80004b96:	6e 0c       	ld.w	r12,r7[0x0]
80004b98:	f0 1f 00 1a 	mcall	80004c00 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004b9c:	6e 0c       	ld.w	r12,r7[0x0]
80004b9e:	f0 1f 00 1a 	mcall	80004c04 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004ba2:	e0 6a 36 00 	mov	r10,13824
80004ba6:	ea 1a 01 6e 	orh	r10,0x16e
80004baa:	1a 9b       	mov	r11,sp
80004bac:	6e 0c       	ld.w	r12,r7[0x0]
80004bae:	f0 1f 00 17 	mcall	80004c08 <rc522_init+0xb4>
80004bb2:	c0 50       	breq	80004bbc <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004bb4:	30 29       	mov	r9,2
80004bb6:	49 68       	lddpc	r8,80004c0c <rc522_init+0xb8>
80004bb8:	b0 89       	st.b	r8[0x0],r9
80004bba:	c0 38       	rjmp	80004bc0 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004bbc:	f0 1f 00 15 	mcall	80004c10 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004bc0:	f0 1f 00 15 	mcall	80004c14 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004bc4:	f0 1f 00 15 	mcall	80004c18 <rc522_init+0xc4>
	
	delay_ms(2); 
80004bc8:	30 2c       	mov	r12,2
80004bca:	f0 1f 00 15 	mcall	80004c1c <rc522_init+0xc8>
	
	PcdAntennaOn();
80004bce:	f0 1f 00 15 	mcall	80004c20 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004bd2:	34 1c       	mov	r12,65
80004bd4:	f0 1f 00 14 	mcall	80004c24 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004bd8:	30 1c       	mov	r12,1
80004bda:	f0 1f 00 14 	mcall	80004c28 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004bde:	2f cd       	sub	sp,-16
80004be0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	d8 44       	*unknown*
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	d8 54       	*unknown*
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	55 18       	stdsp	sp[0x144],r8
80004bf0:	80 00       	ld.sh	r0,r0[0x0]
80004bf2:	55 48       	stdsp	sp[0x150],r8
80004bf4:	80 00       	ld.sh	r0,r0[0x0]
80004bf6:	55 60       	stdsp	sp[0x158],r0
80004bf8:	00 00       	add	r0,r0
80004bfa:	1d ac       	ld.ub	r12,lr[0x2]
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	58 18       	cp.w	r8,1
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	58 50       	cp.w	r0,5
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	58 7c       	cp.w	r12,7
80004c08:	80 00       	ld.sh	r0,r0[0x0]
80004c0a:	58 c0       	cp.w	r0,12
80004c0c:	00 00       	add	r0,r0
80004c0e:	0b 64       	ld.uh	r4,--r5
80004c10:	80 00       	ld.sh	r0,r0[0x0]
80004c12:	48 98       	lddpc	r8,80004c34 <PcdComMF522+0x8>
80004c14:	80 00       	ld.sh	r0,r0[0x0]
80004c16:	49 44       	lddpc	r4,80004c64 <PcdComMF522+0x38>
80004c18:	80 00       	ld.sh	r0,r0[0x0]
80004c1a:	4a d4       	lddpc	r4,80004ccc <PcdComMF522+0xa0>
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	53 40       	stdsp	sp[0xd0],r0
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	4a 8c       	lddpc	r12,80004cc0 <PcdComMF522+0x94>
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	4a e4       	lddpc	r4,80004cdc <PcdComMF522+0xb0>
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	4a 1c       	lddpc	r12,80004cac <PcdComMF522+0x80>

80004c2c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004c2c:	d4 31       	pushm	r0-r7,lr
80004c2e:	20 1d       	sub	sp,4
80004c30:	18 92       	mov	r2,r12
80004c32:	16 95       	mov	r5,r11
80004c34:	14 96       	mov	r6,r10
80004c36:	50 09       	stdsp	sp[0x0],r9
80004c38:	10 90       	mov	r0,r8
80004c3a:	f8 c8 00 0c 	sub	r8,r12,12
80004c3e:	5c 58       	castu.b	r8
80004c40:	30 29       	mov	r9,2
80004c42:	f2 08 18 00 	cp.b	r8,r9
80004c46:	e0 88 00 05 	brls	80004c50 <PcdComMF522+0x24>
80004c4a:	30 03       	mov	r3,0
80004c4c:	06 91       	mov	r1,r3
80004c4e:	c0 78       	rjmp	80004c5c <PcdComMF522+0x30>
80004c50:	4c f9       	lddpc	r9,80004d8c <PcdComMF522+0x160>
80004c52:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004c56:	4c f9       	lddpc	r9,80004d90 <PcdComMF522+0x164>
80004c58:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004c5c:	02 9b       	mov	r11,r1
80004c5e:	a7 bb       	sbr	r11,0x7
80004c60:	30 2c       	mov	r12,2
80004c62:	f0 1f 00 4d 	mcall	80004d94 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004c66:	e0 6b 00 80 	mov	r11,128
80004c6a:	30 4c       	mov	r12,4
80004c6c:	f0 1f 00 4b 	mcall	80004d98 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c70:	30 0b       	mov	r11,0
80004c72:	30 1c       	mov	r12,1
80004c74:	f0 1f 00 48 	mcall	80004d94 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004c78:	e0 6b 00 80 	mov	r11,128
80004c7c:	30 ac       	mov	r12,10
80004c7e:	f0 1f 00 48 	mcall	80004d9c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004c82:	58 06       	cp.w	r6,0
80004c84:	c0 c0       	breq	80004c9c <PcdComMF522+0x70>
80004c86:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004c88:	30 94       	mov	r4,9
80004c8a:	0f 3b       	ld.ub	r11,r7++
80004c8c:	08 9c       	mov	r12,r4
80004c8e:	f0 1f 00 42 	mcall	80004d94 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c92:	0e 98       	mov	r8,r7
80004c94:	0a 18       	sub	r8,r5
80004c96:	ec 08 19 00 	cp.h	r8,r6
80004c9a:	cf 83       	brcs	80004c8a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c9c:	04 9b       	mov	r11,r2
80004c9e:	30 1c       	mov	r12,1
80004ca0:	f0 1f 00 3d 	mcall	80004d94 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004ca4:	30 c8       	mov	r8,12
80004ca6:	f0 02 18 00 	cp.b	r2,r8
80004caa:	c0 61       	brne	80004cb6 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004cac:	e0 6b 00 80 	mov	r11,128
80004cb0:	30 dc       	mov	r12,13
80004cb2:	f0 1f 00 3b 	mcall	80004d9c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004cb6:	30 4c       	mov	r12,4
80004cb8:	f0 1f 00 3a 	mcall	80004da0 <PcdComMF522+0x174>
80004cbc:	18 97       	mov	r7,r12
80004cbe:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004cc2:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004cc4:	30 44       	mov	r4,4
80004cc6:	c0 88       	rjmp	80004cd6 <PcdComMF522+0xaa>
80004cc8:	08 9c       	mov	r12,r4
80004cca:	f0 1f 00 36 	mcall	80004da0 <PcdComMF522+0x174>
80004cce:	18 97       	mov	r7,r12
		i--;
80004cd0:	20 16       	sub	r6,1
80004cd2:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004cd4:	c0 a0       	breq	80004ce8 <PcdComMF522+0xbc>
80004cd6:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004cda:	c4 c1       	brne	80004d72 <PcdComMF522+0x146>
80004cdc:	ef e3 00 08 	and	r8,r7,r3
80004ce0:	ea 08 18 00 	cp.b	r8,r5
80004ce4:	cf 20       	breq	80004cc8 <PcdComMF522+0x9c>
80004ce6:	c4 68       	rjmp	80004d72 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004ce8:	e0 6b 00 80 	mov	r11,128
80004cec:	30 dc       	mov	r12,13
80004cee:	f0 1f 00 2b 	mcall	80004d98 <PcdComMF522+0x16c>
80004cf2:	30 27       	mov	r7,2
80004cf4:	c3 38       	rjmp	80004d5a <PcdComMF522+0x12e>
80004cf6:	02 67       	and	r7,r1
80004cf8:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004cfc:	30 c8       	mov	r8,12
80004cfe:	f0 02 18 00 	cp.b	r2,r8
80004d02:	c2 c1       	brne	80004d5a <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004d04:	30 ac       	mov	r12,10
80004d06:	f0 1f 00 27 	mcall	80004da0 <PcdComMF522+0x174>
80004d0a:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004d0c:	30 cc       	mov	r12,12
80004d0e:	f0 1f 00 25 	mcall	80004da0 <PcdComMF522+0x174>
80004d12:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004d16:	c0 70       	breq	80004d24 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004d18:	08 98       	mov	r8,r4
80004d1a:	20 18       	sub	r8,1
80004d1c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004d20:	a0 8c       	st.b	r0[0x0],r12
80004d22:	c0 48       	rjmp	80004d2a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004d24:	e8 08 15 03 	lsl	r8,r4,0x3
80004d28:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004d2a:	58 04       	cp.w	r4,0
80004d2c:	c0 61       	brne	80004d38 <PcdComMF522+0x10c>
80004d2e:	30 14       	mov	r4,1
80004d30:	40 05       	lddsp	r5,sp[0x0]
80004d32:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d34:	30 93       	mov	r3,9
80004d36:	c0 98       	rjmp	80004d48 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d38:	31 28       	mov	r8,18
80004d3a:	f0 04 18 00 	cp.b	r4,r8
80004d3e:	f9 b4 0b 12 	movhi	r4,18
80004d42:	58 04       	cp.w	r4,0
80004d44:	cf 61       	brne	80004d30 <PcdComMF522+0x104>
80004d46:	c0 a8       	rjmp	80004d5a <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d48:	06 9c       	mov	r12,r3
80004d4a:	f0 1f 00 16 	mcall	80004da0 <PcdComMF522+0x174>
80004d4e:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d50:	ec 05 01 08 	sub	r8,r6,r5
80004d54:	e8 08 19 00 	cp.h	r8,r4
80004d58:	cf 83       	brcs	80004d48 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004d5a:	e0 6b 00 80 	mov	r11,128
80004d5e:	30 cc       	mov	r12,12
80004d60:	f0 1f 00 0f 	mcall	80004d9c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d64:	30 0b       	mov	r11,0
80004d66:	30 1c       	mov	r12,1
80004d68:	f0 1f 00 0b 	mcall	80004d94 <PcdComMF522+0x168>
	return status;
}
80004d6c:	0e 9c       	mov	r12,r7
80004d6e:	2f fd       	sub	sp,-4
80004d70:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004d72:	e0 6b 00 80 	mov	r11,128
80004d76:	30 dc       	mov	r12,13
80004d78:	f0 1f 00 08 	mcall	80004d98 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004d7c:	30 6c       	mov	r12,6
80004d7e:	f0 1f 00 09 	mcall	80004da0 <PcdComMF522+0x174>
80004d82:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004d86:	cb 80       	breq	80004cf6 <PcdComMF522+0xca>
80004d88:	30 27       	mov	r7,2
80004d8a:	ce 8b       	rjmp	80004d5a <PcdComMF522+0x12e>
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	d8 3c       	*unknown*
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	d8 40       	acall	0x84
80004d94:	80 00       	ld.sh	r0,r0[0x0]
80004d96:	49 04       	lddpc	r4,80004dd4 <PcdAnticoll+0x30>
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	4a ac       	lddpc	r12,80004e40 <PcdRequest+0x18>
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	4a 68       	lddpc	r8,80004e34 <PcdRequest+0xc>
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	49 c4       	lddpc	r4,80004e10 <PcdAnticoll+0x6c>

80004da4 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004da4:	eb cd 40 c0 	pushm	r6-r7,lr
80004da8:	20 5d       	sub	sp,20
80004daa:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004dac:	30 8b       	mov	r11,8
80004dae:	16 9c       	mov	r12,r11
80004db0:	f0 1f 00 1a 	mcall	80004e18 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004db4:	30 0b       	mov	r11,0
80004db6:	30 dc       	mov	r12,13
80004db8:	f0 1f 00 19 	mcall	80004e1c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004dbc:	e0 6b 00 80 	mov	r11,128
80004dc0:	30 ec       	mov	r12,14
80004dc2:	f0 1f 00 16 	mcall	80004e18 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004dc6:	39 38       	mov	r8,-109
80004dc8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004dca:	32 08       	mov	r8,32
80004dcc:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004dce:	1a 9b       	mov	r11,sp
80004dd0:	fa c8 ff ed 	sub	r8,sp,-19
80004dd4:	1a 99       	mov	r9,sp
80004dd6:	30 2a       	mov	r10,2
80004dd8:	30 cc       	mov	r12,12
80004dda:	f0 1f 00 12 	mcall	80004e20 <PcdAnticoll+0x7c>
80004dde:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004de0:	c1 21       	brne	80004e04 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004de2:	1b 89       	ld.ub	r9,sp[0x0]
80004de4:	ac 89       	st.b	r6[0x0],r9
80004de6:	1b 98       	ld.ub	r8,sp[0x1]
80004de8:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004dea:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004dec:	1b a8       	ld.ub	r8,sp[0x2]
80004dee:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004df0:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004df4:	1b b9       	ld.ub	r9,sp[0x3]
80004df6:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004df8:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004dfa:	1b c9       	ld.ub	r9,sp[0x4]
80004dfc:	f0 09 18 00 	cp.b	r9,r8
80004e00:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004e04:	e0 6b 00 80 	mov	r11,128
80004e08:	30 ec       	mov	r12,14
80004e0a:	f0 1f 00 07 	mcall	80004e24 <PcdAnticoll+0x80>
	return status;
}
80004e0e:	0e 9c       	mov	r12,r7
80004e10:	2f bd       	sub	sp,-20
80004e12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e16:	00 00       	add	r0,r0
80004e18:	80 00       	ld.sh	r0,r0[0x0]
80004e1a:	4a ac       	lddpc	r12,80004ec0 <CalulateCRC+0x34>
80004e1c:	80 00       	ld.sh	r0,r0[0x0]
80004e1e:	49 04       	lddpc	r4,80004e5c <PcdRequest+0x34>
80004e20:	80 00       	ld.sh	r0,r0[0x0]
80004e22:	4c 2c       	lddpc	r12,80004f28 <PcdSelect+0x10>
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	4a 68       	lddpc	r8,80004ebc <CalulateCRC+0x30>

80004e28 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004e28:	eb cd 40 c0 	pushm	r6-r7,lr
80004e2c:	20 5d       	sub	sp,20
80004e2e:	18 97       	mov	r7,r12
80004e30:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004e32:	30 8b       	mov	r11,8
80004e34:	16 9c       	mov	r12,r11
80004e36:	f0 1f 00 12 	mcall	80004e7c <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004e3a:	30 7b       	mov	r11,7
80004e3c:	30 dc       	mov	r12,13
80004e3e:	f0 1f 00 11 	mcall	80004e80 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004e42:	30 3b       	mov	r11,3
80004e44:	31 4c       	mov	r12,20
80004e46:	f0 1f 00 10 	mcall	80004e84 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004e4a:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004e4c:	1a 9b       	mov	r11,sp
80004e4e:	fa c8 ff ed 	sub	r8,sp,-19
80004e52:	1a 99       	mov	r9,sp
80004e54:	30 1a       	mov	r10,1
80004e56:	30 cc       	mov	r12,12
80004e58:	f0 1f 00 0c 	mcall	80004e88 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004e5c:	c0 c1       	brne	80004e74 <PcdRequest+0x4c>
80004e5e:	31 08       	mov	r8,16
80004e60:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e64:	f0 09 18 00 	cp.b	r9,r8
80004e68:	c0 61       	brne	80004e74 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004e6a:	1b 88       	ld.ub	r8,sp[0x0]
80004e6c:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004e6e:	1b 98       	ld.ub	r8,sp[0x1]
80004e70:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004e72:	c0 28       	rjmp	80004e76 <PcdRequest+0x4e>
80004e74:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004e76:	2f bd       	sub	sp,-20
80004e78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	4a ac       	lddpc	r12,80004f24 <PcdSelect+0xc>
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	49 04       	lddpc	r4,80004ec0 <CalulateCRC+0x34>
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	4a 68       	lddpc	r8,80004f1c <PcdSelect+0x4>
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	4c 2c       	lddpc	r12,80004f90 <rfid_auto_reader+0x4>

80004e8c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004e8c:	eb cd 40 f8 	pushm	r3-r7,lr
80004e90:	18 95       	mov	r5,r12
80004e92:	16 96       	mov	r6,r11
80004e94:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e96:	30 4b       	mov	r11,4
80004e98:	30 5c       	mov	r12,5
80004e9a:	f0 1f 00 1c 	mcall	80004f08 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e9e:	30 0b       	mov	r11,0
80004ea0:	30 1c       	mov	r12,1
80004ea2:	f0 1f 00 1b 	mcall	80004f0c <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004ea6:	e0 6b 00 80 	mov	r11,128
80004eaa:	30 ac       	mov	r12,10
80004eac:	f0 1f 00 19 	mcall	80004f10 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004eb0:	58 06       	cp.w	r6,0
80004eb2:	c0 c0       	breq	80004eca <CalulateCRC+0x3e>
80004eb4:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004eb6:	30 94       	mov	r4,9
80004eb8:	0f 3b       	ld.ub	r11,r7++
80004eba:	08 9c       	mov	r12,r4
80004ebc:	f0 1f 00 14 	mcall	80004f0c <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004ec0:	0e 98       	mov	r8,r7
80004ec2:	0a 18       	sub	r8,r5
80004ec4:	ec 08 18 00 	cp.b	r8,r6
80004ec8:	cf 83       	brcs	80004eb8 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004eca:	30 3b       	mov	r11,3
80004ecc:	30 1c       	mov	r12,1
80004ece:	f0 1f 00 10 	mcall	80004f0c <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004ed2:	30 5c       	mov	r12,5
80004ed4:	f0 1f 00 10 	mcall	80004f14 <CalulateCRC+0x88>
80004ed8:	e0 67 00 fe 	mov	r7,254
80004edc:	30 56       	mov	r6,5
80004ede:	c0 78       	rjmp	80004eec <CalulateCRC+0x60>
80004ee0:	0c 9c       	mov	r12,r6
80004ee2:	f0 1f 00 0d 	mcall	80004f14 <CalulateCRC+0x88>
		i--;
80004ee6:	20 17       	sub	r7,1
80004ee8:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004eea:	c0 40       	breq	80004ef2 <CalulateCRC+0x66>
80004eec:	e2 1c 00 04 	andl	r12,0x4,COH
80004ef0:	cf 80       	breq	80004ee0 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004ef2:	32 2c       	mov	r12,34
80004ef4:	f0 1f 00 08 	mcall	80004f14 <CalulateCRC+0x88>
80004ef8:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004efa:	32 1c       	mov	r12,33
80004efc:	f0 1f 00 06 	mcall	80004f14 <CalulateCRC+0x88>
80004f00:	a6 9c       	st.b	r3[0x1],r12
}
80004f02:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004f06:	00 00       	add	r0,r0
80004f08:	80 00       	ld.sh	r0,r0[0x0]
80004f0a:	4a ac       	lddpc	r12,80004fb0 <rfid_auto_reader+0x24>
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	49 04       	lddpc	r4,80004f4c <PcdSelect+0x34>
80004f10:	80 00       	ld.sh	r0,r0[0x0]
80004f12:	4a 68       	lddpc	r8,80004fa8 <rfid_auto_reader+0x1c>
80004f14:	80 00       	ld.sh	r0,r0[0x0]
80004f16:	49 c4       	lddpc	r4,80004f84 <PcdSelect+0x6c>

80004f18 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004f18:	eb cd 40 80 	pushm	r7,lr
80004f1c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004f1e:	39 38       	mov	r8,-109
80004f20:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004f22:	37 08       	mov	r8,112
80004f24:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004f26:	30 08       	mov	r8,0
80004f28:	ba e8       	st.b	sp[0x6],r8
80004f2a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004f2e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004f32:	19 89       	ld.ub	r9,r12[0x0]
80004f34:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004f36:	19 3a       	ld.ub	r10,r12++
80004f38:	1b e9       	ld.ub	r9,sp[0x6]
80004f3a:	f5 e9 20 09 	eor	r9,r10,r9
80004f3e:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004f40:	16 38       	cp.w	r8,r11
80004f42:	cf 81       	brne	80004f32 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004f44:	1a 97       	mov	r7,sp
80004f46:	fa ca ff f9 	sub	r10,sp,-7
80004f4a:	30 7b       	mov	r11,7
80004f4c:	1a 9c       	mov	r12,sp
80004f4e:	f0 1f 00 0d 	mcall	80004f80 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004f52:	30 8b       	mov	r11,8
80004f54:	16 9c       	mov	r12,r11
80004f56:	f0 1f 00 0c 	mcall	80004f84 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004f5a:	fa c8 ff ed 	sub	r8,sp,-19
80004f5e:	1a 99       	mov	r9,sp
80004f60:	30 9a       	mov	r10,9
80004f62:	1a 9b       	mov	r11,sp
80004f64:	30 cc       	mov	r12,12
80004f66:	f0 1f 00 09 	mcall	80004f88 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004f6a:	c0 71       	brne	80004f78 <PcdSelect+0x60>
80004f6c:	31 88       	mov	r8,24
80004f6e:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f72:	f0 09 18 00 	cp.b	r9,r8
80004f76:	c0 20       	breq	80004f7a <PcdSelect+0x62>
80004f78:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004f7a:	2f bd       	sub	sp,-20
80004f7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	4e 8c       	lddpc	r12,80005120 <scan_rfid_save_message+0x24>
80004f84:	80 00       	ld.sh	r0,r0[0x0]
80004f86:	4a ac       	lddpc	r12,8000502c <rfid_auto_reader+0xa0>
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	4c 2c       	lddpc	r12,80005090 <rfid_auto_reader+0x104>

80004f8c <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004f8c:	eb cd 40 c0 	pushm	r6-r7,lr
80004f90:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f92:	f0 1f 00 37 	mcall	8000506c <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f96:	4b 7b       	lddpc	r11,80005070 <rfid_auto_reader+0xe4>
80004f98:	35 2c       	mov	r12,82
80004f9a:	f0 1f 00 37 	mcall	80005074 <rfid_auto_reader+0xe8>
80004f9e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004fa0:	c6 31       	brne	80005066 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004fa2:	4b 48       	lddpc	r8,80005070 <rfid_auto_reader+0xe4>
80004fa4:	11 88       	ld.ub	r8,r8[0x0]
80004fa6:	30 49       	mov	r9,4
80004fa8:	f2 08 18 00 	cp.b	r8,r9
80004fac:	c0 b1       	brne	80004fc2 <rfid_auto_reader+0x36>
80004fae:	4b 19       	lddpc	r9,80005070 <rfid_auto_reader+0xe4>
80004fb0:	13 9a       	ld.ub	r10,r9[0x1]
80004fb2:	30 09       	mov	r9,0
80004fb4:	f2 0a 18 00 	cp.b	r10,r9
80004fb8:	c0 51       	brne	80004fc2 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004fba:	4b 0c       	lddpc	r12,80005078 <rfid_auto_reader+0xec>
80004fbc:	f0 1f 00 30 	mcall	8000507c <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004fc0:	c3 c8       	rjmp	80005038 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004fc2:	30 29       	mov	r9,2
80004fc4:	f2 08 18 00 	cp.b	r8,r9
80004fc8:	c0 b1       	brne	80004fde <rfid_auto_reader+0x52>
80004fca:	4a a9       	lddpc	r9,80005070 <rfid_auto_reader+0xe4>
80004fcc:	13 9a       	ld.ub	r10,r9[0x1]
80004fce:	30 09       	mov	r9,0
80004fd0:	f2 0a 18 00 	cp.b	r10,r9
80004fd4:	c0 51       	brne	80004fde <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004fd6:	4a bc       	lddpc	r12,80005080 <rfid_auto_reader+0xf4>
80004fd8:	f0 1f 00 29 	mcall	8000507c <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004fdc:	c2 e8       	rjmp	80005038 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004fde:	34 49       	mov	r9,68
80004fe0:	f2 08 18 00 	cp.b	r8,r9
80004fe4:	c0 b1       	brne	80004ffa <rfid_auto_reader+0x6e>
80004fe6:	4a 39       	lddpc	r9,80005070 <rfid_auto_reader+0xe4>
80004fe8:	13 9a       	ld.ub	r10,r9[0x1]
80004fea:	30 09       	mov	r9,0
80004fec:	f2 0a 18 00 	cp.b	r10,r9
80004ff0:	c0 51       	brne	80004ffa <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004ff2:	4a 5c       	lddpc	r12,80005084 <rfid_auto_reader+0xf8>
80004ff4:	f0 1f 00 22 	mcall	8000507c <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ff8:	c2 08       	rjmp	80005038 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ffa:	30 89       	mov	r9,8
80004ffc:	f2 08 18 00 	cp.b	r8,r9
80005000:	c0 b1       	brne	80005016 <rfid_auto_reader+0x8a>
80005002:	49 c9       	lddpc	r9,80005070 <rfid_auto_reader+0xe4>
80005004:	13 9a       	ld.ub	r10,r9[0x1]
80005006:	30 09       	mov	r9,0
80005008:	f2 0a 18 00 	cp.b	r10,r9
8000500c:	c0 51       	brne	80005016 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
8000500e:	49 fc       	lddpc	r12,80005088 <rfid_auto_reader+0xfc>
80005010:	f0 1f 00 1b 	mcall	8000507c <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005014:	c1 28       	rjmp	80005038 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005016:	34 49       	mov	r9,68
80005018:	f2 08 18 00 	cp.b	r8,r9
8000501c:	c0 b1       	brne	80005032 <rfid_auto_reader+0xa6>
8000501e:	49 58       	lddpc	r8,80005070 <rfid_auto_reader+0xe4>
80005020:	11 99       	ld.ub	r9,r8[0x1]
80005022:	30 38       	mov	r8,3
80005024:	f0 09 18 00 	cp.b	r9,r8
80005028:	c0 51       	brne	80005032 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000502a:	49 9c       	lddpc	r12,8000508c <rfid_auto_reader+0x100>
8000502c:	f0 1f 00 14 	mcall	8000507c <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005030:	c0 48       	rjmp	80005038 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005032:	49 8c       	lddpc	r12,80005090 <rfid_auto_reader+0x104>
80005034:	f0 1f 00 12 	mcall	8000507c <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005038:	49 7c       	lddpc	r12,80005094 <rfid_auto_reader+0x108>
8000503a:	f0 1f 00 18 	mcall	80005098 <rfid_auto_reader+0x10c>
8000503e:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005040:	c0 60       	breq	8000504c <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
80005042:	34 fb       	mov	r11,79
80005044:	30 1c       	mov	r12,1
80005046:	f0 1f 00 16 	mcall	8000509c <rfid_auto_reader+0x110>
		return status;
8000504a:	c0 e8       	rjmp	80005066 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
8000504c:	49 2c       	lddpc	r12,80005094 <rfid_auto_reader+0x108>
8000504e:	f0 1f 00 15 	mcall	800050a0 <rfid_auto_reader+0x114>
80005052:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005054:	c0 91       	brne	80005066 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80005056:	30 4a       	mov	r10,4
80005058:	48 fb       	lddpc	r11,80005094 <rfid_auto_reader+0x108>
8000505a:	0c 9c       	mov	r12,r6
8000505c:	f0 1f 00 12 	mcall	800050a4 <rfid_auto_reader+0x118>
		log("select okay\n");
80005060:	49 2c       	lddpc	r12,800050a8 <rfid_auto_reader+0x11c>
80005062:	f0 1f 00 07 	mcall	8000507c <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80005066:	0e 9c       	mov	r12,r7
80005068:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	49 44       	lddpc	r4,800050bc <scan_patrol+0x10>
80005070:	00 00       	add	r0,r0
80005072:	97 34       	st.w	r11[0xc],r4
80005074:	80 00       	ld.sh	r0,r0[0x0]
80005076:	4e 28       	lddpc	r8,800051fc <scan_rfid_save_message+0x100>
80005078:	80 00       	ld.sh	r0,r0[0x0]
8000507a:	d8 74       	*unknown*
8000507c:	80 00       	ld.sh	r0,r0[0x0]
8000507e:	6f c4       	ld.w	r4,r7[0x70]
80005080:	80 00       	ld.sh	r0,r0[0x0]
80005082:	d8 80       	acall	0x88
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	d8 8c       	*unknown*
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	d8 9c       	*unknown*
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	d8 a4       	*unknown*
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	d8 b0       	acall	0x8b
80005094:	00 00       	add	r0,r0
80005096:	97 38       	st.w	r11[0xc],r8
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	4d a4       	lddpc	r4,80005200 <scan_rfid_save_message+0x104>
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	40 98       	lddsp	r8,sp[0x24]
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	4f 18       	lddpc	r8,80005264 <scan_rfid_save_message+0x168>
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	78 40       	ld.w	r0,r12[0x10]
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	d8 bc       	*unknown*

800050ac <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
800050ac:	eb cd 40 80 	pushm	r7,lr
800050b0:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
800050b2:	f0 1f 00 0d 	mcall	800050e4 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
800050b6:	30 0c       	mov	r12,0
800050b8:	f0 1f 00 0c 	mcall	800050e8 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
800050bc:	0e 9c       	mov	r12,r7
800050be:	f0 1f 00 0c 	mcall	800050ec <scan_patrol+0x40>
800050c2:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
800050c4:	30 1c       	mov	r12,1
800050c6:	f0 1f 00 09 	mcall	800050e8 <scan_patrol+0x3c>
	if(return_err == 0)
800050ca:	58 07       	cp.w	r7,0
800050cc:	c0 51       	brne	800050d6 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
800050ce:	48 9c       	lddpc	r12,800050f0 <scan_patrol+0x44>
800050d0:	f0 1f 00 09 	mcall	800050f4 <scan_patrol+0x48>
800050d4:	c0 48       	rjmp	800050dc <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
800050d6:	48 9c       	lddpc	r12,800050f8 <scan_patrol+0x4c>
800050d8:	f0 1f 00 07 	mcall	800050f4 <scan_patrol+0x48>
		
	return return_err;

}
800050dc:	0e 9c       	mov	r12,r7
800050de:	e3 cd 80 80 	ldm	sp++,r7,pc
800050e2:	00 00       	add	r0,r0
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	49 44       	lddpc	r4,80005134 <scan_rfid_save_message+0x38>
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	4a 1c       	lddpc	r12,8000516c <scan_rfid_save_message+0x70>
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	4f 8c       	lddpc	r12,800052cc <scan_rfid_save_message+0x1d0>
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	d8 cc       	*unknown*
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	6f c4       	ld.w	r4,r7[0x70]
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	d8 e0       	acall	0x8e

800050fc <scan_rfid_save_message>:
U8 scan_rfid_save_message()
{
800050fc:	eb cd 40 e0 	pushm	r5-r7,lr
80005100:	fa cd 00 8c 	sub	sp,sp,140
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80005104:	4e 9c       	lddpc	r12,800052a8 <scan_rfid_save_message+0x1ac>
80005106:	30 08       	mov	r8,0
80005108:	30 09       	mov	r9,0
8000510a:	f8 e9 00 00 	st.d	r12[0],r8
8000510e:	30 0a       	mov	r10,0
80005110:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005112:	fa e9 00 3c 	st.d	sp[60],r8
80005116:	fa e9 00 44 	st.d	sp[68],r8
8000511a:	fa e9 00 4c 	st.d	sp[76],r8
8000511e:	fa e9 00 54 	st.d	sp[84],r8
80005122:	fa e9 00 5c 	st.d	sp[92],r8
80005126:	fa e9 00 64 	st.d	sp[100],r8
8000512a:	fa e9 00 6c 	st.d	sp[108],r8
8000512e:	fa e9 00 74 	st.d	sp[116],r8
80005132:	fa e9 00 7c 	st.d	sp[124],r8
80005136:	fa e9 00 84 	st.d	sp[132],r8
	
	return_err = scan_patrol(SN);
8000513a:	f0 1f 00 5d 	mcall	800052ac <scan_rfid_save_message+0x1b0>
8000513e:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005140:	e0 81 00 a8 	brne	80005290 <scan_rfid_save_message+0x194>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005144:	4d 96       	lddpc	r6,800052a8 <scan_rfid_save_message+0x1ac>
80005146:	0d b8       	ld.ub	r8,r6[0x3]
80005148:	1a d8       	st.w	--sp,r8
8000514a:	0d a8       	ld.ub	r8,r6[0x2]
8000514c:	1a d8       	st.w	--sp,r8
8000514e:	0d 98       	ld.ub	r8,r6[0x1]
80005150:	1a d8       	st.w	--sp,r8
80005152:	0d 88       	ld.ub	r8,r6[0x0]
80005154:	1a d8       	st.w	--sp,r8
80005156:	4d 7c       	lddpc	r12,800052b0 <scan_rfid_save_message+0x1b4>
80005158:	f0 1f 00 57 	mcall	800052b4 <scan_rfid_save_message+0x1b8>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
8000515c:	34 4b       	mov	r11,68
8000515e:	30 1c       	mov	r12,1
80005160:	f0 1f 00 56 	mcall	800052b8 <scan_rfid_save_message+0x1bc>
80005164:	fa c8 ff ce 	sub	r8,sp,-50
80005168:	fa c9 ff cc 	sub	r9,sp,-52
		log("scan_patrol err!\n");
		
	return return_err;

}
U8 scan_rfid_save_message()
8000516c:	ec c5 ff fc 	sub	r5,r6,-4
80005170:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005172:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005174:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005176:	0d 8a       	ld.ub	r10,r6[0x0]
80005178:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000517c:	fc 0b 18 00 	cp.b	r11,lr
80005180:	f7 bb 08 d0 	subls	r11,-48
80005184:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005188:	f7 bb 0b a9 	subhi	r11,-87
8000518c:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005190:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005192:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005196:	fc 0a 18 00 	cp.b	r10,lr
8000519a:	f7 ba 08 d0 	subls	r10,-48
8000519e:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
800051a2:	f7 ba 0b a9 	subhi	r10,-87
800051a6:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
800051aa:	b0 bc       	st.b	r8[0x3],r12
800051ac:	2f f6       	sub	r6,-1
800051ae:	2f c8       	sub	r8,-4
800051b0:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
800051b2:	0a 36       	cp.w	r6,r5
800051b4:	ce 11       	brne	80005176 <scan_rfid_save_message+0x7a>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
800051b6:	4c 28       	lddpc	r8,800052bc <scan_rfid_save_message+0x1c0>
800051b8:	11 89       	ld.ub	r9,r8[0x0]
800051ba:	39 f8       	mov	r8,-97
800051bc:	f0 09 18 00 	cp.b	r9,r8
800051c0:	e0 88 00 05 	brls	800051ca <scan_rfid_save_message+0xce>
800051c4:	38 09       	mov	r9,-128
800051c6:	4b e8       	lddpc	r8,800052bc <scan_rfid_save_message+0x1c0>
800051c8:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
800051ca:	4b d8       	lddpc	r8,800052bc <scan_rfid_save_message+0x1c0>
800051cc:	11 86       	ld.ub	r6,r8[0x0]
800051ce:	2f f6       	sub	r6,-1
800051d0:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800051d2:	30 5a       	mov	r10,5
800051d4:	4b bb       	lddpc	r11,800052c0 <scan_rfid_save_message+0x1c4>
800051d6:	fa cc ff c9 	sub	r12,sp,-55
800051da:	f0 1f 00 3b 	mcall	800052c4 <scan_rfid_save_message+0x1c8>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800051de:	31 88       	mov	r8,24
800051e0:	fb 58 00 32 	st.h	sp[50],r8
800051e4:	fb 66 00 36 	st.b	sp[54],r6
800051e8:	fe 78 e0 00 	mov	r8,-8192
800051ec:	fb 58 00 34 	st.h	sp[52],r8
800051f0:	fa c6 ff c4 	sub	r6,sp,-60
800051f4:	30 aa       	mov	r10,10
800051f6:	fa cb ff ce 	sub	r11,sp,-50
800051fa:	0c 9c       	mov	r12,r6
800051fc:	f0 1f 00 32 	mcall	800052c4 <scan_rfid_save_message+0x1c8>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005200:	31 0a       	mov	r10,16
80005202:	fa cb ff de 	sub	r11,sp,-34
80005206:	fa cc ff ba 	sub	r12,sp,-70
8000520a:	f0 1f 00 2f 	mcall	800052c4 <scan_rfid_save_message+0x1c8>
		
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t  xgmessage;
		memcpy(&xgmessage, message, sizeof(Message_Protocol_t));
8000520e:	31 aa       	mov	r10,26
80005210:	0c 9b       	mov	r11,r6
80005212:	fa cc ff fe 	sub	r12,sp,-2
80005216:	f0 1f 00 2c 	mcall	800052c4 <scan_rfid_save_message+0x1c8>

		Message_Protocol_t * myptr = get_message_store();
8000521a:	4a c8       	lddpc	r8,800052c8 <scan_rfid_save_message+0x1cc>
8000521c:	70 0c       	ld.w	r12,r8[0x0]
8000521e:	f0 1f 00 2c 	mcall	800052cc <scan_rfid_save_message+0x1d0>
80005222:	50 7c       	stdsp	sp[0x1c],r12
		if(NULL != myptr)
80005224:	c3 20       	breq	80005288 <scan_rfid_save_message+0x18c>
		{
			memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));
80005226:	31 aa       	mov	r10,26
80005228:	fa cb ff fe 	sub	r11,sp,-2
8000522c:	f0 1f 00 26 	mcall	800052c4 <scan_rfid_save_message+0x1c8>
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005230:	4a 88       	lddpc	r8,800052d0 <scan_rfid_save_message+0x1d4>
80005232:	70 0c       	ld.w	r12,r8[0x0]
80005234:	30 09       	mov	r9,0
80005236:	12 9a       	mov	r10,r9
80005238:	fa cb ff e4 	sub	r11,sp,-28
8000523c:	f0 1f 00 26 	mcall	800052d4 <scan_rfid_save_message+0x1d8>
80005240:	58 1c       	cp.w	r12,1
80005242:	c1 10       	breq	80005264 <scan_rfid_save_message+0x168>
			{
				log("xg_resend_queue: full\n" );
80005244:	4a 5c       	lddpc	r12,800052d8 <scan_rfid_save_message+0x1dc>
80005246:	f0 1f 00 1c 	mcall	800052b4 <scan_rfid_save_message+0x1b8>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
8000524a:	32 3b       	mov	r11,35
8000524c:	30 1c       	mov	r12,1
8000524e:	f0 1f 00 1b 	mcall	800052b8 <scan_rfid_save_message+0x1bc>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
80005252:	e0 6c 17 70 	mov	r12,6000
80005256:	f0 1f 00 22 	mcall	800052dc <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
8000525a:	32 3b       	mov	r11,35
8000525c:	30 0c       	mov	r12,0
8000525e:	f0 1f 00 17 	mcall	800052b8 <scan_rfid_save_message+0x1bc>
80005262:	c1 e8       	rjmp	8000529e <scan_rfid_save_message+0x1a2>
			}
			else{
				
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005264:	49 f6       	lddpc	r6,800052e0 <scan_rfid_save_message+0x1e4>
80005266:	6c 0c       	ld.w	r12,r6[0x0]
80005268:	30 09       	mov	r9,0
8000526a:	3f fa       	mov	r10,-1
8000526c:	12 9b       	mov	r11,r9
8000526e:	f0 1f 00 1e 	mcall	800052e4 <scan_rfid_save_message+0x1e8>
				global_count++;
80005272:	49 e8       	lddpc	r8,800052e8 <scan_rfid_save_message+0x1ec>
80005274:	70 09       	ld.w	r9,r8[0x0]
80005276:	2f f9       	sub	r9,-1
80005278:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
8000527a:	6c 0c       	ld.w	r12,r6[0x0]
8000527c:	30 09       	mov	r9,0
8000527e:	12 9a       	mov	r10,r9
80005280:	12 9b       	mov	r11,r9
80005282:	f0 1f 00 15 	mcall	800052d4 <scan_rfid_save_message+0x1d8>
80005286:	c0 c8       	rjmp	8000529e <scan_rfid_save_message+0x1a2>
			}

		}
		else
		{
			log("myptr: err\n\r" );
80005288:	49 9c       	lddpc	r12,800052ec <scan_rfid_save_message+0x1f0>
8000528a:	f0 1f 00 0b 	mcall	800052b4 <scan_rfid_save_message+0x1b8>
8000528e:	c0 88       	rjmp	8000529e <scan_rfid_save_message+0x1a2>
		}
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005290:	34 fb       	mov	r11,79
80005292:	30 1c       	mov	r12,1
80005294:	f0 1f 00 09 	mcall	800052b8 <scan_rfid_save_message+0x1bc>
		log("no card find...\n");
80005298:	49 6c       	lddpc	r12,800052f0 <scan_rfid_save_message+0x1f4>
8000529a:	f0 1f 00 07 	mcall	800052b4 <scan_rfid_save_message+0x1b8>
	}
	
	return return_err;
	
}
8000529e:	0e 9c       	mov	r12,r7
800052a0:	2d dd       	sub	sp,-140
800052a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052a6:	00 00       	add	r0,r0
800052a8:	00 00       	add	r0,r0
800052aa:	0b 68       	ld.uh	r8,--r5
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	50 ac       	stdsp	sp[0x28],r12
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	d8 f4       	*unknown*
800052b4:	80 00       	ld.sh	r0,r0[0x0]
800052b6:	6f c4       	ld.w	r4,r7[0x70]
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	40 98       	lddsp	r8,sp[0x24]
800052bc:	00 00       	add	r0,r0
800052be:	05 30       	ld.ub	r0,r2++
800052c0:	00 00       	add	r0,r0
800052c2:	05 28       	ld.uh	r8,r2++
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	78 40       	ld.w	r0,r12[0x10]
800052c8:	00 00       	add	r0,r0
800052ca:	0b 78       	ld.ub	r8,--r5
800052cc:	80 00       	ld.sh	r0,r0[0x0]
800052ce:	2d dc       	sub	r12,-35
800052d0:	00 00       	add	r0,r0
800052d2:	0b 74       	ld.ub	r4,--r5
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	63 8c       	ld.w	r12,r1[0x60]
800052d8:	80 00       	ld.sh	r0,r0[0x0]
800052da:	d6 ac       	*unknown*
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	6a 58       	ld.w	r8,r5[0x14]
800052e0:	00 00       	add	r0,r0
800052e2:	0a 60       	and	r0,r5
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	61 80       	ld.w	r0,r0[0x60]
800052e8:	00 00       	add	r0,r0
800052ea:	0a 44       	or	r4,r5
800052ec:	80 00       	ld.sh	r0,r0[0x0]
800052ee:	d7 88       	*unknown*
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	d9 10       	acall	0x91

800052f4 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
800052f4:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800052f6:	f0 1f 00 02 	mcall	800052fc <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
800052fa:	d8 02       	popm	pc
800052fc:	80 00       	ld.sh	r0,r0[0x0]
800052fe:	4b 54       	lddpc	r4,800053d0 <local_start_pll0+0x3c>

80005300 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005300:	58 0c       	cp.w	r12,0
80005302:	5e 0c       	reteq	r12
80005304:	30 08       	mov	r8,0
	{
		nop();
80005306:	d7 03       	nop
		nop();
80005308:	d7 03       	nop
		nop();
8000530a:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
8000530c:	2f f8       	sub	r8,-1
8000530e:	10 3c       	cp.w	r12,r8
80005310:	fe 9b ff fb 	brhi	80005306 <delay_ns+0x6>
80005314:	5e fc       	retal	r12
80005316:	d7 03       	nop

80005318 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005318:	eb cd 40 e0 	pushm	r5-r7,lr
8000531c:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
8000531e:	58 0c       	cp.w	r12,0
80005320:	c0 b0       	breq	80005336 <delay_us+0x1e>
80005322:	30 07       	mov	r7,0
		delay_ns(1000);
80005324:	e0 65 03 e8 	mov	r5,1000
80005328:	0a 9c       	mov	r12,r5
8000532a:	f0 1f 00 05 	mcall	8000533c <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
8000532e:	2f f7       	sub	r7,-1
80005330:	0e 36       	cp.w	r6,r7
80005332:	fe 9b ff fb 	brhi	80005328 <delay_us+0x10>
80005336:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000533a:	00 00       	add	r0,r0
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	53 00       	stdsp	sp[0xc0],r0

80005340 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005340:	eb cd 40 e0 	pushm	r5-r7,lr
80005344:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005346:	58 0c       	cp.w	r12,0
80005348:	c0 b0       	breq	8000535e <delay_ms+0x1e>
8000534a:	30 07       	mov	r7,0
		delay_us(1000);
8000534c:	e0 65 03 e8 	mov	r5,1000
80005350:	0a 9c       	mov	r12,r5
80005352:	f0 1f 00 05 	mcall	80005364 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005356:	2f f7       	sub	r7,-1
80005358:	0e 36       	cp.w	r6,r7
8000535a:	fe 9b ff fb 	brhi	80005350 <delay_ms+0x10>
8000535e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005362:	00 00       	add	r0,r0
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	53 18       	stdsp	sp[0xc4],r8

80005368 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005368:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
8000536a:	30 3b       	mov	r11,3
8000536c:	48 8c       	lddpc	r12,8000538c <local_start_timer+0x24>
8000536e:	f0 1f 00 09 	mcall	80005390 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005372:	fe 78 38 00 	mov	r8,-51200
80005376:	e0 69 91 0d 	mov	r9,37133
8000537a:	ea 19 00 52 	orh	r9,0x52
8000537e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005380:	32 09       	mov	r9,32
80005382:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005384:	30 59       	mov	r9,5
80005386:	91 09       	st.w	r8[0x0],r9
}
80005388:	d8 02       	popm	pc
8000538a:	00 00       	add	r0,r0
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	d9 24       	*unknown*
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	55 18       	stdsp	sp[0x144],r8

80005394 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005394:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005396:	30 3a       	mov	r10,3
80005398:	e0 6b 1b 00 	mov	r11,6912
8000539c:	ea 1b 00 b7 	orh	r11,0xb7
800053a0:	fe 7c 0c 00 	mov	r12,-62464
800053a4:	f0 1f 00 19 	mcall	80005408 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800053a8:	31 08       	mov	r8,16
800053aa:	1a d8       	st.w	--sp,r8
800053ac:	30 08       	mov	r8,0
800053ae:	30 19       	mov	r9,1
800053b0:	30 7a       	mov	r10,7
800053b2:	10 9b       	mov	r11,r8
800053b4:	fe 7c 0c 00 	mov	r12,-62464
800053b8:	f0 1f 00 15 	mcall	8000540c <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
800053bc:	30 08       	mov	r8,0
800053be:	30 19       	mov	r9,1
800053c0:	12 9a       	mov	r10,r9
800053c2:	10 9b       	mov	r11,r8
800053c4:	fe 7c 0c 00 	mov	r12,-62464
800053c8:	f0 1f 00 12 	mcall	80005410 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
800053cc:	30 0b       	mov	r11,0
800053ce:	fe 7c 0c 00 	mov	r12,-62464
800053d2:	f0 1f 00 11 	mcall	80005414 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
800053d6:	fe 7c 0c 00 	mov	r12,-62464
800053da:	f0 1f 00 10 	mcall	80005418 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
800053de:	30 0a       	mov	r10,0
800053e0:	1a da       	st.w	--sp,r10
800053e2:	1a da       	st.w	--sp,r10
800053e4:	14 98       	mov	r8,r10
800053e6:	14 99       	mov	r9,r10
800053e8:	30 1b       	mov	r11,1
800053ea:	fe 7c 0c 00 	mov	r12,-62464
800053ee:	f0 1f 00 0c 	mcall	8000541c <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800053f2:	30 1c       	mov	r12,1
800053f4:	f0 1f 00 0b 	mcall	80005420 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800053f8:	30 2b       	mov	r11,2
800053fa:	fe 7c 0c 00 	mov	r12,-62464
800053fe:	f0 1f 00 0a 	mcall	80005424 <local_start_pll0+0x90>
80005402:	2f dd       	sub	sp,-12
/****/
}
80005404:	d8 02       	popm	pc
80005406:	00 00       	add	r0,r0
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	57 cc       	stdsp	sp[0x1f0],r12
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	57 6e       	stdsp	sp[0x1d8],lr
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	57 90       	stdsp	sp[0x1e4],r0
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	57 aa       	stdsp	sp[0x1e8],r10
80005418:	80 00       	ld.sh	r0,r0[0x0]
8000541a:	57 b8       	stdsp	sp[0x1ec],r8
8000541c:	80 00       	ld.sh	r0,r0[0x0]
8000541e:	57 28       	stdsp	sp[0x1c8],r8
80005420:	80 00       	ld.sh	r0,r0[0x0]
80005422:	54 b8       	stdsp	sp[0x12c],r8
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	57 c2       	stdsp	sp[0x1f0],r2

80005428 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005428:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
8000542c:	30 0b       	mov	r11,0
8000542e:	30 1c       	mov	r12,1
80005430:	f0 1f 00 19 	mcall	80005494 <xg_flashc_init+0x6c>
80005434:	49 98       	lddpc	r8,80005498 <xg_flashc_init+0x70>
80005436:	91 0c       	st.w	r8[0x0],r12
80005438:	70 08       	ld.w	r8,r8[0x0]
8000543a:	58 08       	cp.w	r8,0
8000543c:	c0 80       	breq	8000544c <xg_flashc_init+0x24>
8000543e:	49 78       	lddpc	r8,80005498 <xg_flashc_init+0x70>
80005440:	70 0c       	ld.w	r12,r8[0x0]
80005442:	30 09       	mov	r9,0
80005444:	12 9a       	mov	r10,r9
80005446:	12 9b       	mov	r11,r9
80005448:	f0 1f 00 15 	mcall	8000549c <xg_flashc_init+0x74>
	if (xBinarySemaphore == NULL)
8000544c:	49 38       	lddpc	r8,80005498 <xg_flashc_init+0x70>
8000544e:	70 08       	ld.w	r8,r8[0x0]
80005450:	58 08       	cp.w	r8,0
80005452:	c0 41       	brne	8000545a <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
80005454:	49 3c       	lddpc	r12,800054a0 <xg_flashc_init+0x78>
80005456:	f0 1f 00 14 	mcall	800054a4 <xg_flashc_init+0x7c>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
8000545a:	30 4b       	mov	r11,4
8000545c:	e0 6c 01 2c 	mov	r12,300
80005460:	f0 1f 00 0d 	mcall	80005494 <xg_flashc_init+0x6c>
80005464:	49 18       	lddpc	r8,800054a8 <xg_flashc_init+0x80>
80005466:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005468:	30 4b       	mov	r11,4
8000546a:	e0 6c 01 90 	mov	r12,400
8000546e:	f0 1f 00 0a 	mcall	80005494 <xg_flashc_init+0x6c>
80005472:	48 f8       	lddpc	r8,800054ac <xg_flashc_init+0x84>
80005474:	91 0c       	st.w	r8[0x0],r12
80005476:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005478:	10 96       	mov	r6,r8
8000547a:	48 e5       	lddpc	r5,800054b0 <xg_flashc_init+0x88>
8000547c:	6c 0c       	ld.w	r12,r6[0x0]
8000547e:	ea 07 00 0b 	add	r11,r5,r7
80005482:	f0 1f 00 0d 	mcall	800054b4 <xg_flashc_init+0x8c>
80005486:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005488:	e0 47 28 a0 	cp.w	r7,10400
8000548c:	cf 81       	brne	8000547c <xg_flashc_init+0x54>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
8000548e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005492:	00 00       	add	r0,r0
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	64 e4       	ld.w	r4,r2[0x38]
80005498:	00 00       	add	r0,r0
8000549a:	0b 7c       	ld.ub	r12,--r5
8000549c:	80 00       	ld.sh	r0,r0[0x0]
8000549e:	63 8c       	ld.w	r12,r1[0x60]
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	d9 3c       	*unknown*
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	6f c4       	ld.w	r4,r7[0x70]
800054a8:	00 00       	add	r0,r0
800054aa:	0b 74       	ld.ub	r4,--r5
800054ac:	00 00       	add	r0,r0
800054ae:	0b 78       	ld.ub	r8,--r5
800054b0:	00 00       	add	r0,r0
800054b2:	97 3c       	st.w	r11[0xc],r12
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	2c 30       	sub	r0,-61

800054b8 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800054b8:	fe 68 14 00 	mov	r8,-125952
800054bc:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800054be:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800054c2:	91 09       	st.w	r8[0x0],r9
}
800054c4:	5e fc       	retal	r12

800054c6 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800054c6:	f8 08 16 05 	lsr	r8,r12,0x5
800054ca:	a9 68       	lsl	r8,0x8
800054cc:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800054d0:	58 1b       	cp.w	r11,1
800054d2:	c0 d0       	breq	800054ec <gpio_enable_module_pin+0x26>
800054d4:	c0 63       	brcs	800054e0 <gpio_enable_module_pin+0x1a>
800054d6:	58 2b       	cp.w	r11,2
800054d8:	c1 00       	breq	800054f8 <gpio_enable_module_pin+0x32>
800054da:	58 3b       	cp.w	r11,3
800054dc:	c1 40       	breq	80005504 <gpio_enable_module_pin+0x3e>
800054de:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800054e0:	30 19       	mov	r9,1
800054e2:	f2 0c 09 49 	lsl	r9,r9,r12
800054e6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800054e8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054ea:	c1 28       	rjmp	8000550e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800054ec:	30 19       	mov	r9,1
800054ee:	f2 0c 09 49 	lsl	r9,r9,r12
800054f2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800054f4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054f6:	c0 c8       	rjmp	8000550e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800054f8:	30 19       	mov	r9,1
800054fa:	f2 0c 09 49 	lsl	r9,r9,r12
800054fe:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005500:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005502:	c0 68       	rjmp	8000550e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005504:	30 19       	mov	r9,1
80005506:	f2 0c 09 49 	lsl	r9,r9,r12
8000550a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000550c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000550e:	30 19       	mov	r9,1
80005510:	f2 0c 09 4c 	lsl	r12,r9,r12
80005514:	91 2c       	st.w	r8[0x8],r12
80005516:	5e fd       	retal	0

80005518 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005518:	d4 21       	pushm	r4-r7,lr
8000551a:	18 97       	mov	r7,r12
8000551c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000551e:	58 0b       	cp.w	r11,0
80005520:	c0 31       	brne	80005526 <gpio_enable_module+0xe>
80005522:	30 05       	mov	r5,0
80005524:	c0 d8       	rjmp	8000553e <gpio_enable_module+0x26>
80005526:	30 06       	mov	r6,0
80005528:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000552a:	6e 1b       	ld.w	r11,r7[0x4]
8000552c:	6e 0c       	ld.w	r12,r7[0x0]
8000552e:	f0 1f 00 06 	mcall	80005544 <gpio_enable_module+0x2c>
80005532:	18 45       	or	r5,r12
		gpiomap++;
80005534:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005536:	2f f6       	sub	r6,-1
80005538:	0c 34       	cp.w	r4,r6
8000553a:	fe 9b ff f8 	brhi	8000552a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000553e:	0a 9c       	mov	r12,r5
80005540:	d8 22       	popm	r4-r7,pc
80005542:	00 00       	add	r0,r0
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	54 c6       	stdsp	sp[0x130],r6

80005548 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005548:	f8 08 16 05 	lsr	r8,r12,0x5
8000554c:	a9 68       	lsl	r8,0x8
8000554e:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005552:	30 19       	mov	r9,1
80005554:	f2 0c 09 4c 	lsl	r12,r9,r12
80005558:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
8000555c:	91 1c       	st.w	r8[0x4],r12
}
8000555e:	5e fc       	retal	r12

80005560 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005560:	f8 08 16 05 	lsr	r8,r12,0x5
80005564:	a9 68       	lsl	r8,0x8
80005566:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000556a:	30 19       	mov	r9,1
8000556c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005570:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005574:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005578:	91 1c       	st.w	r8[0x4],r12
}
8000557a:	5e fc       	retal	r12

8000557c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000557c:	f8 08 16 05 	lsr	r8,r12,0x5
80005580:	a9 68       	lsl	r8,0x8
80005582:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005586:	30 19       	mov	r9,1
80005588:	f2 0c 09 4c 	lsl	r12,r9,r12
8000558c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005590:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005594:	91 1c       	st.w	r8[0x4],r12
}
80005596:	5e fc       	retal	r12

80005598 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005598:	c0 08       	rjmp	80005598 <_unhandled_interrupt>
8000559a:	d7 03       	nop

8000559c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000559c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800055a0:	49 99       	lddpc	r9,80005604 <INTC_register_interrupt+0x68>
800055a2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800055a6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800055aa:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800055ac:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800055b0:	58 0a       	cp.w	r10,0
800055b2:	c0 91       	brne	800055c4 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800055b4:	49 59       	lddpc	r9,80005608 <INTC_register_interrupt+0x6c>
800055b6:	49 6a       	lddpc	r10,8000560c <INTC_register_interrupt+0x70>
800055b8:	12 1a       	sub	r10,r9
800055ba:	fe 79 08 00 	mov	r9,-63488
800055be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055c2:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800055c4:	58 1a       	cp.w	r10,1
800055c6:	c0 a1       	brne	800055da <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800055c8:	49 09       	lddpc	r9,80005608 <INTC_register_interrupt+0x6c>
800055ca:	49 2a       	lddpc	r10,80005610 <INTC_register_interrupt+0x74>
800055cc:	12 1a       	sub	r10,r9
800055ce:	bf aa       	sbr	r10,0x1e
800055d0:	fe 79 08 00 	mov	r9,-63488
800055d4:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055d8:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800055da:	58 2a       	cp.w	r10,2
800055dc:	c0 a1       	brne	800055f0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800055de:	48 b9       	lddpc	r9,80005608 <INTC_register_interrupt+0x6c>
800055e0:	48 da       	lddpc	r10,80005614 <INTC_register_interrupt+0x78>
800055e2:	12 1a       	sub	r10,r9
800055e4:	bf ba       	sbr	r10,0x1f
800055e6:	fe 79 08 00 	mov	r9,-63488
800055ea:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055ee:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800055f0:	48 69       	lddpc	r9,80005608 <INTC_register_interrupt+0x6c>
800055f2:	48 aa       	lddpc	r10,80005618 <INTC_register_interrupt+0x7c>
800055f4:	12 1a       	sub	r10,r9
800055f6:	ea 1a c0 00 	orh	r10,0xc000
800055fa:	fe 79 08 00 	mov	r9,-63488
800055fe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005602:	5e fc       	retal	r12
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	d9 74       	*unknown*
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	ce 00       	breq	800055ca <INTC_register_interrupt+0x2e>
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	cf 04       	brge	800055ee <INTC_register_interrupt+0x52>
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	cf 12       	brcc	800055f4 <INTC_register_interrupt+0x58>
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	cf 20       	breq	800055fa <INTC_register_interrupt+0x5e>
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	cf 2e       	rcall	800053fe <local_start_pll0+0x6a>

8000561c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000561c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000561e:	49 18       	lddpc	r8,80005660 <INTC_init_interrupts+0x44>
80005620:	e3 b8 00 01 	mtsr	0x4,r8
80005624:	49 0e       	lddpc	lr,80005664 <INTC_init_interrupts+0x48>
80005626:	30 07       	mov	r7,0
80005628:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000562a:	49 0c       	lddpc	r12,80005668 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000562c:	49 05       	lddpc	r5,8000566c <INTC_init_interrupts+0x50>
8000562e:	10 15       	sub	r5,r8
80005630:	fe 76 08 00 	mov	r6,-63488
80005634:	c1 08       	rjmp	80005654 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005636:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005638:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000563a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000563c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005640:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005642:	10 3a       	cp.w	r10,r8
80005644:	fe 9b ff fc 	brhi	8000563c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005648:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
8000564c:	2f f7       	sub	r7,-1
8000564e:	2f 8e       	sub	lr,-8
80005650:	59 37       	cp.w	r7,19
80005652:	c0 50       	breq	8000565c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005654:	7c 08       	ld.w	r8,lr[0x0]
80005656:	58 08       	cp.w	r8,0
80005658:	ce f1       	brne	80005636 <INTC_init_interrupts+0x1a>
8000565a:	cf 7b       	rjmp	80005648 <INTC_init_interrupts+0x2c>
8000565c:	d8 22       	popm	r4-r7,pc
8000565e:	00 00       	add	r0,r0
80005660:	80 00       	ld.sh	r0,r0[0x0]
80005662:	ce 00       	breq	80005622 <INTC_init_interrupts+0x6>
80005664:	80 00       	ld.sh	r0,r0[0x0]
80005666:	d9 74       	*unknown*
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	55 98       	stdsp	sp[0x164],r8
8000566c:	80 00       	ld.sh	r0,r0[0x0]
8000566e:	cf 04       	brge	8000564e <INTC_init_interrupts+0x32>

80005670 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005670:	fe 78 08 00 	mov	r8,-63488
80005674:	e0 69 00 83 	mov	r9,131
80005678:	f2 0c 01 0c 	sub	r12,r9,r12
8000567c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005680:	f2 ca ff c0 	sub	r10,r9,-64
80005684:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005688:	58 08       	cp.w	r8,0
8000568a:	c0 21       	brne	8000568e <_get_interrupt_handler+0x1e>
8000568c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000568e:	f0 08 12 00 	clz	r8,r8
80005692:	48 5a       	lddpc	r10,800056a4 <_get_interrupt_handler+0x34>
80005694:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005698:	f0 08 11 1f 	rsub	r8,r8,31
8000569c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000569e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800056a2:	5e fc       	retal	r12
800056a4:	80 00       	ld.sh	r0,r0[0x0]
800056a6:	d9 74       	*unknown*

800056a8 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800056a8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800056aa:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800056ae:	99 a8       	st.w	r12[0x28],r8
}
800056b0:	5e fc       	retal	r12
800056b2:	d7 03       	nop

800056b4 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800056b4:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800056b6:	ec 5b bb 9f 	cp.w	r11,899999
800056ba:	e0 8b 00 04 	brhi	800056c2 <pm_enable_osc0_crystal+0xe>
800056be:	30 4b       	mov	r11,4
800056c0:	c1 38       	rjmp	800056e6 <pm_enable_osc0_crystal+0x32>
800056c2:	e0 68 c6 bf 	mov	r8,50879
800056c6:	ea 18 00 2d 	orh	r8,0x2d
800056ca:	10 3b       	cp.w	r11,r8
800056cc:	e0 8b 00 04 	brhi	800056d4 <pm_enable_osc0_crystal+0x20>
800056d0:	30 5b       	mov	r11,5
800056d2:	c0 a8       	rjmp	800056e6 <pm_enable_osc0_crystal+0x32>
800056d4:	e0 68 12 00 	mov	r8,4608
800056d8:	ea 18 00 7a 	orh	r8,0x7a
800056dc:	10 3b       	cp.w	r11,r8
800056de:	f9 bb 03 06 	movlo	r11,6
800056e2:	f9 bb 02 07 	movhs	r11,7
800056e6:	f0 1f 00 02 	mcall	800056ec <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800056ea:	d8 02       	popm	pc
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	56 a8       	stdsp	sp[0x1a8],r8

800056f0 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800056f0:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800056f2:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800056f6:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800056f8:	78 08       	ld.w	r8,r12[0x0]
800056fa:	a3 a8       	sbr	r8,0x2
800056fc:	99 08       	st.w	r12[0x0],r8
}
800056fe:	5e fc       	retal	r12

80005700 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005700:	79 58       	ld.w	r8,r12[0x54]
80005702:	e2 18 00 80 	andl	r8,0x80,COH
80005706:	cf d0       	breq	80005700 <pm_wait_for_clk0_ready>
}
80005708:	5e fc       	retal	r12
8000570a:	d7 03       	nop

8000570c <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000570c:	eb cd 40 80 	pushm	r7,lr
80005710:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80005712:	f0 1f 00 04 	mcall	80005720 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80005716:	0e 9c       	mov	r12,r7
80005718:	f0 1f 00 03 	mcall	80005724 <pm_enable_clk0+0x18>
}
8000571c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005720:	80 00       	ld.sh	r0,r0[0x0]
80005722:	56 f0       	stdsp	sp[0x1bc],r0
80005724:	80 00       	ld.sh	r0,r0[0x0]
80005726:	57 00       	stdsp	sp[0x1c0],r0

80005728 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005728:	eb cd 40 d0 	pushm	r4,r6-r7,lr
8000572c:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005730:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005732:	09 f7       	ld.ub	r7,r4[0x7]
80005734:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005738:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
8000573c:	09 b4       	ld.ub	r4,r4[0x3]
8000573e:	08 96       	mov	r6,r4
80005740:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005744:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005748:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
8000574c:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005750:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005754:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005758:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
8000575c:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005760:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005762:	79 58       	ld.w	r8,r12[0x54]
80005764:	e2 18 00 20 	andl	r8,0x20,COH
80005768:	cf d0       	breq	80005762 <pm_cksel+0x3a>
}
8000576a:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000576e <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000576e:	eb cd 40 80 	pushm	r7,lr
80005772:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005774:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005776:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000577a:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000577e:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005782:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005786:	2f 8b       	sub	r11,-8
80005788:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000578c:	e3 cd 80 80 	ldm	sp++,r7,pc

80005790 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005790:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005792:	2f 8b       	sub	r11,-8
80005794:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005798:	f5 e9 10 19 	or	r9,r10,r9<<0x1
8000579c:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800057a0:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800057a4:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800057a8:	d8 02       	popm	pc

800057aa <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800057aa:	2f 8b       	sub	r11,-8
800057ac:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800057b0:	a1 a8       	sbr	r8,0x0
800057b2:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800057b6:	5e fc       	retal	r12

800057b8 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800057b8:	79 58       	ld.w	r8,r12[0x54]
800057ba:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800057be:	cf d0       	breq	800057b8 <pm_wait_for_pll0_locked>
}
800057c0:	5e fc       	retal	r12

800057c2 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800057c2:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800057c4:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800057c8:	99 08       	st.w	r12[0x0],r8
}
800057ca:	5e fc       	retal	r12

800057cc <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800057cc:	eb cd 40 c0 	pushm	r6-r7,lr
800057d0:	18 97       	mov	r7,r12
800057d2:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800057d4:	f0 1f 00 06 	mcall	800057ec <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800057d8:	0c 9b       	mov	r11,r6
800057da:	0e 9c       	mov	r12,r7
800057dc:	f0 1f 00 05 	mcall	800057f0 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800057e0:	30 1b       	mov	r11,1
800057e2:	0e 9c       	mov	r12,r7
800057e4:	f0 1f 00 04 	mcall	800057f4 <pm_switch_to_osc0+0x28>
}
800057e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	56 b4       	stdsp	sp[0x1ac],r4
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	57 0c       	stdsp	sp[0x1c0],r12
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	57 c2       	stdsp	sp[0x1f0],r2

800057f8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800057f8:	f8 c8 00 01 	sub	r8,r12,1
800057fc:	f0 0b 00 0b 	add	r11,r8,r11
80005800:	f6 0c 0d 0a 	divu	r10,r11,r12
80005804:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005806:	f4 c8 00 01 	sub	r8,r10,1
8000580a:	e0 48 00 fe 	cp.w	r8,254
8000580e:	e0 88 00 03 	brls	80005814 <getBaudDiv+0x1c>
80005812:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005814:	5c 8c       	casts.h	r12
}
80005816:	5e fc       	retal	r12

80005818 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005818:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000581c:	30 18       	mov	r8,1
8000581e:	f0 09 18 00 	cp.b	r9,r8
80005822:	e0 88 00 04 	brls	8000582a <spi_initMaster+0x12>
80005826:	30 2c       	mov	r12,2
80005828:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000582a:	e0 68 00 80 	mov	r8,128
8000582e:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005830:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005832:	30 19       	mov	r9,1
80005834:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005838:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000583c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005840:	30 09       	mov	r9,0
80005842:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005846:	30 fa       	mov	r10,15
80005848:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000584c:	99 18       	st.w	r12[0x4],r8
8000584e:	5e f9       	retal	r9

80005850 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005850:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005852:	30 18       	mov	r8,1
80005854:	f0 0b 18 00 	cp.b	r11,r8
80005858:	5f be       	srhi	lr
8000585a:	f0 0a 18 00 	cp.b	r10,r8
8000585e:	5f b8       	srhi	r8
80005860:	fd e8 10 08 	or	r8,lr,r8
80005864:	c0 30       	breq	8000586a <spi_selectionMode+0x1a>
80005866:	30 2c       	mov	r12,2
80005868:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000586a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000586c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005870:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005874:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005878:	99 18       	st.w	r12[0x4],r8
8000587a:	d8 0a       	popm	pc,r12=0

8000587c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000587c:	30 18       	mov	r8,1
8000587e:	99 08       	st.w	r12[0x0],r8
}
80005880:	5e fc       	retal	r12

80005882 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005882:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005886:	c0 58       	rjmp	80005890 <spi_write+0xe>
		if (!timeout--) {
80005888:	58 08       	cp.w	r8,0
8000588a:	c0 21       	brne	8000588e <spi_write+0xc>
8000588c:	5e ff       	retal	1
8000588e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005890:	78 49       	ld.w	r9,r12[0x10]
80005892:	e2 19 00 02 	andl	r9,0x2,COH
80005896:	cf 90       	breq	80005888 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005898:	5c 7b       	castu.h	r11
8000589a:	99 3b       	st.w	r12[0xc],r11
8000589c:	5e fd       	retal	0

8000589e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000589e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058a2:	c0 58       	rjmp	800058ac <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800058a4:	58 08       	cp.w	r8,0
800058a6:	c0 21       	brne	800058aa <spi_read+0xc>
800058a8:	5e ff       	retal	1
800058aa:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800058ac:	78 49       	ld.w	r9,r12[0x10]
800058ae:	e2 19 02 01 	andl	r9,0x201,COH
800058b2:	e0 49 02 01 	cp.w	r9,513
800058b6:	cf 71       	brne	800058a4 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800058b8:	78 28       	ld.w	r8,r12[0x8]
800058ba:	b6 08       	st.h	r11[0x0],r8
800058bc:	5e fd       	retal	0
800058be:	d7 03       	nop

800058c0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800058c0:	eb cd 40 f8 	pushm	r3-r7,lr
800058c4:	18 95       	mov	r5,r12
800058c6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058c8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800058cc:	30 38       	mov	r8,3
800058ce:	f0 06 18 00 	cp.b	r6,r8
800058d2:	e0 8b 00 5e 	brhi	8000598e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800058d6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058da:	30 18       	mov	r8,1
800058dc:	f0 04 18 00 	cp.b	r4,r8
800058e0:	e0 8b 00 57 	brhi	8000598e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800058e4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800058e8:	30 78       	mov	r8,7
800058ea:	f0 03 18 00 	cp.b	r3,r8
800058ee:	e0 88 00 50 	brls	8000598e <spi_setupChipReg+0xce>
800058f2:	31 08       	mov	r8,16
800058f4:	f0 03 18 00 	cp.b	r3,r8
800058f8:	e0 8b 00 4b 	brhi	8000598e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800058fc:	14 9b       	mov	r11,r10
800058fe:	6e 1c       	ld.w	r12,r7[0x4]
80005900:	f0 1f 00 26 	mcall	80005998 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005904:	c4 55       	brlt	8000598e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005906:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005908:	ec 09 16 01 	lsr	r9,r6,0x1
8000590c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005910:	ec 16 00 01 	eorl	r6,0x1
80005914:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005918:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000591c:	20 83       	sub	r3,8
8000591e:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005922:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005926:	ef 39 00 09 	ld.ub	r9,r7[9]
8000592a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000592e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005932:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005936:	0f 89       	ld.ub	r9,r7[0x0]
80005938:	30 1a       	mov	r10,1
8000593a:	f4 09 18 00 	cp.b	r9,r10
8000593e:	c0 d0       	breq	80005958 <spi_setupChipReg+0x98>
80005940:	c0 a3       	brcs	80005954 <spi_setupChipReg+0x94>
80005942:	30 2a       	mov	r10,2
80005944:	f4 09 18 00 	cp.b	r9,r10
80005948:	c0 a0       	breq	8000595c <spi_setupChipReg+0x9c>
8000594a:	30 3a       	mov	r10,3
8000594c:	f4 09 18 00 	cp.b	r9,r10
80005950:	c1 f1       	brne	8000598e <spi_setupChipReg+0xce>
80005952:	c0 78       	rjmp	80005960 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005954:	8b c8       	st.w	r5[0x30],r8
		break;
80005956:	c0 68       	rjmp	80005962 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005958:	8b d8       	st.w	r5[0x34],r8
		break;
8000595a:	c0 48       	rjmp	80005962 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000595c:	8b e8       	st.w	r5[0x38],r8
		break;
8000595e:	c0 28       	rjmp	80005962 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005960:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005962:	48 f8       	lddpc	r8,8000599c <spi_setupChipReg+0xdc>
80005964:	70 08       	ld.w	r8,r8[0x0]
80005966:	58 08       	cp.w	r8,0
80005968:	c1 61       	brne	80005994 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000596a:	30 0b       	mov	r11,0
8000596c:	30 1c       	mov	r12,1
8000596e:	f0 1f 00 0d 	mcall	800059a0 <spi_setupChipReg+0xe0>
80005972:	48 b8       	lddpc	r8,8000599c <spi_setupChipReg+0xdc>
80005974:	91 0c       	st.w	r8[0x0],r12
80005976:	58 0c       	cp.w	r12,0
80005978:	c0 a0       	breq	8000598c <spi_setupChipReg+0xcc>
8000597a:	30 09       	mov	r9,0
8000597c:	12 9a       	mov	r10,r9
8000597e:	12 9b       	mov	r11,r9
80005980:	f0 1f 00 09 	mcall	800059a4 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005984:	48 68       	lddpc	r8,8000599c <spi_setupChipReg+0xdc>
80005986:	70 08       	ld.w	r8,r8[0x0]
80005988:	58 08       	cp.w	r8,0
8000598a:	c0 51       	brne	80005994 <spi_setupChipReg+0xd4>
8000598c:	c0 08       	rjmp	8000598c <spi_setupChipReg+0xcc>
8000598e:	30 2c       	mov	r12,2
80005990:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005994:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	57 f8       	stdsp	sp[0x1fc],r8
8000599c:	00 00       	add	r0,r0
8000599e:	bf e0       	*unknown*
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	64 e4       	ld.w	r4,r2[0x38]
800059a4:	80 00       	ld.sh	r0,r0[0x0]
800059a6:	63 8c       	ld.w	r12,r1[0x60]

800059a8 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059a8:	d4 01       	pushm	lr
800059aa:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059ae:	c0 58       	rjmp	800059b8 <spi_unselectChip+0x10>
		if (!timeout--) {
800059b0:	58 08       	cp.w	r8,0
800059b2:	c0 21       	brne	800059b6 <spi_unselectChip+0xe>
800059b4:	da 0a       	popm	pc,r12=1
800059b6:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800059b8:	78 49       	ld.w	r9,r12[0x10]
800059ba:	e2 19 02 00 	andl	r9,0x200,COH
800059be:	cf 90       	breq	800059b0 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800059c0:	78 18       	ld.w	r8,r12[0x4]
800059c2:	ea 18 00 0f 	orh	r8,0xf
800059c6:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800059c8:	fc 18 01 00 	movh	r8,0x100
800059cc:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800059ce:	30 09       	mov	r9,0
800059d0:	12 9a       	mov	r10,r9
800059d2:	12 9b       	mov	r11,r9
800059d4:	48 38       	lddpc	r8,800059e0 <spi_unselectChip+0x38>
800059d6:	70 0c       	ld.w	r12,r8[0x0]
800059d8:	f0 1f 00 03 	mcall	800059e4 <spi_unselectChip+0x3c>
800059dc:	d8 0a       	popm	pc,r12=0
800059de:	00 00       	add	r0,r0
800059e0:	00 00       	add	r0,r0
800059e2:	bf e0       	*unknown*
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	63 8c       	ld.w	r12,r1[0x60]

800059e8 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800059e8:	eb cd 40 f8 	pushm	r3-r7,lr
800059ec:	18 94       	mov	r4,r12
800059ee:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800059f0:	49 a6       	lddpc	r6,80005a58 <spi_selectChip+0x70>
800059f2:	30 07       	mov	r7,0
800059f4:	31 45       	mov	r5,20
800059f6:	0e 99       	mov	r9,r7
800059f8:	0a 9a       	mov	r10,r5
800059fa:	0e 9b       	mov	r11,r7
800059fc:	6c 0c       	ld.w	r12,r6[0x0]
800059fe:	f0 1f 00 18 	mcall	80005a5c <spi_selectChip+0x74>
80005a02:	cf a0       	breq	800059f6 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a04:	68 18       	ld.w	r8,r4[0x4]
80005a06:	ea 18 00 0f 	orh	r8,0xf
80005a0a:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005a0c:	68 18       	ld.w	r8,r4[0x4]
80005a0e:	e2 18 00 04 	andl	r8,0x4,COH
80005a12:	c1 10       	breq	80005a34 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005a14:	30 e8       	mov	r8,14
80005a16:	f0 03 18 00 	cp.b	r3,r8
80005a1a:	e0 8b 00 1c 	brhi	80005a52 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005a1e:	68 19       	ld.w	r9,r4[0x4]
80005a20:	e6 08 15 10 	lsl	r8,r3,0x10
80005a24:	ea 18 ff f0 	orh	r8,0xfff0
80005a28:	e8 18 ff ff 	orl	r8,0xffff
80005a2c:	12 68       	and	r8,r9
80005a2e:	89 18       	st.w	r4[0x4],r8
80005a30:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005a34:	30 38       	mov	r8,3
80005a36:	f0 03 18 00 	cp.b	r3,r8
80005a3a:	e0 8b 00 0c 	brhi	80005a52 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005a3e:	68 19       	ld.w	r9,r4[0x4]
80005a40:	2f 03       	sub	r3,-16
80005a42:	30 18       	mov	r8,1
80005a44:	f0 03 09 48 	lsl	r8,r8,r3
80005a48:	5c d8       	com	r8
80005a4a:	12 68       	and	r8,r9
80005a4c:	89 18       	st.w	r4[0x4],r8
80005a4e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a52:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005a54:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a58:	00 00       	add	r0,r0
80005a5a:	bf e0       	*unknown*
80005a5c:	80 00       	ld.sh	r0,r0[0x0]
80005a5e:	61 80       	ld.w	r0,r0[0x60]

80005a60 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005a60:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005a62:	f6 08 15 04 	lsl	r8,r11,0x4
80005a66:	14 38       	cp.w	r8,r10
80005a68:	f9 b8 08 10 	movls	r8,16
80005a6c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005a70:	f0 0b 02 4b 	mul	r11,r8,r11
80005a74:	f6 09 16 01 	lsr	r9,r11,0x1
80005a78:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005a7c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005a80:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005a84:	f2 cb 00 01 	sub	r11,r9,1
80005a88:	e0 4b ff fe 	cp.w	r11,65534
80005a8c:	e0 88 00 03 	brls	80005a92 <usart_set_async_baudrate+0x32>
80005a90:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005a92:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005a94:	e8 6e 00 00 	mov	lr,524288
80005a98:	59 08       	cp.w	r8,16
80005a9a:	fc 08 17 10 	movne	r8,lr
80005a9e:	f9 b8 00 00 	moveq	r8,0
80005aa2:	e4 1b ff f7 	andh	r11,0xfff7
80005aa6:	e0 1b fe cf 	andl	r11,0xfecf
80005aaa:	16 48       	or	r8,r11
80005aac:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005aae:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005ab2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005ab6:	99 89       	st.w	r12[0x20],r9
80005ab8:	d8 0a       	popm	pc,r12=0

80005aba <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005aba:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005abc:	e2 18 00 02 	andl	r8,0x2,COH
80005ac0:	c0 31       	brne	80005ac6 <usart_write_char+0xc>
80005ac2:	30 2c       	mov	r12,2
80005ac4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005ac6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005aca:	99 7b       	st.w	r12[0x1c],r11
80005acc:	5e fd       	retal	0
80005ace:	d7 03       	nop

80005ad0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005ad0:	eb cd 40 e0 	pushm	r5-r7,lr
80005ad4:	18 96       	mov	r6,r12
80005ad6:	16 95       	mov	r5,r11
80005ad8:	e0 67 27 0f 	mov	r7,9999
80005adc:	c0 68       	rjmp	80005ae8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005ade:	58 07       	cp.w	r7,0
80005ae0:	c0 31       	brne	80005ae6 <usart_putchar+0x16>
80005ae2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005ae6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005ae8:	0a 9b       	mov	r11,r5
80005aea:	0c 9c       	mov	r12,r6
80005aec:	f0 1f 00 03 	mcall	80005af8 <usart_putchar+0x28>
80005af0:	cf 71       	brne	80005ade <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005af2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005af6:	00 00       	add	r0,r0
80005af8:	80 00       	ld.sh	r0,r0[0x0]
80005afa:	5a ba       	cp.w	r10,-21

80005afc <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005afc:	78 58       	ld.w	r8,r12[0x14]
80005afe:	e2 18 00 e0 	andl	r8,0xe0,COH
80005b02:	c0 30       	breq	80005b08 <usart_read_char+0xc>
80005b04:	30 4c       	mov	r12,4
80005b06:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005b08:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005b0a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005b0e:	c0 31       	brne	80005b14 <usart_read_char+0x18>
80005b10:	30 3c       	mov	r12,3
80005b12:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005b14:	78 68       	ld.w	r8,r12[0x18]
80005b16:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005b1a:	97 08       	st.w	r11[0x0],r8
80005b1c:	5e fd       	retal	0
80005b1e:	d7 03       	nop

80005b20 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005b20:	eb cd 40 c0 	pushm	r6-r7,lr
80005b24:	20 1d       	sub	sp,4
80005b26:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005b28:	1a 97       	mov	r7,sp
80005b2a:	1a 9b       	mov	r11,sp
80005b2c:	0c 9c       	mov	r12,r6
80005b2e:	f0 1f 00 07 	mcall	80005b48 <usart_getchar+0x28>
80005b32:	58 3c       	cp.w	r12,3
80005b34:	cf b0       	breq	80005b2a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005b36:	58 4c       	cp.w	r12,4
80005b38:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005b3c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005b40:	2f fd       	sub	sp,-4
80005b42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b46:	00 00       	add	r0,r0
80005b48:	80 00       	ld.sh	r0,r0[0x0]
80005b4a:	5a fc       	cp.w	r12,-17

80005b4c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005b4c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b50:	18 96       	mov	r6,r12
80005b52:	16 97       	mov	r7,r11
  while (*string != '\0')
80005b54:	17 8b       	ld.ub	r11,r11[0x0]
80005b56:	58 0b       	cp.w	r11,0
80005b58:	c0 80       	breq	80005b68 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005b5a:	2f f7       	sub	r7,-1
80005b5c:	0c 9c       	mov	r12,r6
80005b5e:	f0 1f 00 04 	mcall	80005b6c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005b62:	0f 8b       	ld.ub	r11,r7[0x0]
80005b64:	58 0b       	cp.w	r11,0
80005b66:	cf a1       	brne	80005b5a <usart_write_line+0xe>
80005b68:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	5a d0       	cp.w	r0,-19

80005b70 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005b70:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005b74:	e6 18 00 01 	andh	r8,0x1,COH
80005b78:	c0 71       	brne	80005b86 <usart_reset+0x16>
80005b7a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005b7c:	3f f8       	mov	r8,-1
80005b7e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b80:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005b82:	d5 03       	csrf	0x10
80005b84:	c0 48       	rjmp	80005b8c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005b86:	3f f8       	mov	r8,-1
80005b88:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b8a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005b8c:	30 08       	mov	r8,0
80005b8e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005b90:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005b92:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005b94:	ea 68 61 0c 	mov	r8,680204
80005b98:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005b9a:	5e fc       	retal	r12

80005b9c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005b9c:	eb cd 40 e0 	pushm	r5-r7,lr
80005ba0:	18 96       	mov	r6,r12
80005ba2:	16 97       	mov	r7,r11
80005ba4:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005ba6:	f0 1f 00 2f 	mcall	80005c60 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005baa:	58 07       	cp.w	r7,0
80005bac:	c5 80       	breq	80005c5c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005bae:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005bb0:	30 49       	mov	r9,4
80005bb2:	f2 08 18 00 	cp.b	r8,r9
80005bb6:	e0 88 00 53 	brls	80005c5c <usart_init_rs232+0xc0>
80005bba:	30 99       	mov	r9,9
80005bbc:	f2 08 18 00 	cp.b	r8,r9
80005bc0:	e0 8b 00 4e 	brhi	80005c5c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005bc4:	0f d9       	ld.ub	r9,r7[0x5]
80005bc6:	30 78       	mov	r8,7
80005bc8:	f0 09 18 00 	cp.b	r9,r8
80005bcc:	e0 8b 00 48 	brhi	80005c5c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005bd0:	8e 39       	ld.sh	r9,r7[0x6]
80005bd2:	e0 68 01 01 	mov	r8,257
80005bd6:	f0 09 19 00 	cp.h	r9,r8
80005bda:	e0 8b 00 41 	brhi	80005c5c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005bde:	ef 39 00 08 	ld.ub	r9,r7[8]
80005be2:	30 38       	mov	r8,3
80005be4:	f0 09 18 00 	cp.b	r9,r8
80005be8:	e0 8b 00 3a 	brhi	80005c5c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005bec:	0a 9a       	mov	r10,r5
80005bee:	6e 0b       	ld.w	r11,r7[0x0]
80005bf0:	0c 9c       	mov	r12,r6
80005bf2:	f0 1f 00 1d 	mcall	80005c64 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005bf6:	58 1c       	cp.w	r12,1
80005bf8:	c3 20       	breq	80005c5c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005bfa:	0f c8       	ld.ub	r8,r7[0x4]
80005bfc:	30 99       	mov	r9,9
80005bfe:	f2 08 18 00 	cp.b	r8,r9
80005c02:	c0 51       	brne	80005c0c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005c04:	6c 18       	ld.w	r8,r6[0x4]
80005c06:	b1 b8       	sbr	r8,0x11
80005c08:	8d 18       	st.w	r6[0x4],r8
80005c0a:	c0 68       	rjmp	80005c16 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005c0c:	6c 19       	ld.w	r9,r6[0x4]
80005c0e:	20 58       	sub	r8,5
80005c10:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005c14:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005c16:	6c 19       	ld.w	r9,r6[0x4]
80005c18:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005c1c:	0f d8       	ld.ub	r8,r7[0x5]
80005c1e:	a9 78       	lsl	r8,0x9
80005c20:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005c24:	12 48       	or	r8,r9
80005c26:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005c28:	8e 38       	ld.sh	r8,r7[0x6]
80005c2a:	30 29       	mov	r9,2
80005c2c:	f2 08 19 00 	cp.h	r8,r9
80005c30:	e0 88 00 09 	brls	80005c42 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005c34:	6c 18       	ld.w	r8,r6[0x4]
80005c36:	ad b8       	sbr	r8,0xd
80005c38:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005c3a:	8e b8       	ld.uh	r8,r7[0x6]
80005c3c:	20 28       	sub	r8,2
80005c3e:	8d a8       	st.w	r6[0x28],r8
80005c40:	c0 68       	rjmp	80005c4c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005c42:	6c 19       	ld.w	r9,r6[0x4]
80005c44:	5c 78       	castu.h	r8
80005c46:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005c4a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005c4c:	6c 18       	ld.w	r8,r6[0x4]
80005c4e:	e0 18 ff f0 	andl	r8,0xfff0
80005c52:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005c54:	35 08       	mov	r8,80
80005c56:	8d 08       	st.w	r6[0x0],r8
80005c58:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005c5c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	5b 70       	cp.w	r0,-9
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	5a 60       	cp.w	r0,-26

80005c68 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005c68:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005c6c:	fe c0 8e 6c 	sub	r0,pc,-29076

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005c70:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005c74:	d5 53       	csrf	0x15
  cp      r0, r1
80005c76:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005c78:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005c7c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005c7e:	c0 62       	brcc	80005c8a <idata_load_loop_end>
  cp      r0, r1
80005c80:	48 92       	lddpc	r2,80005ca4 <udata_clear_loop_end+0x4>

80005c82 <idata_load_loop>:
  brlo    idata_load_loop
80005c82:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005c84:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005c86:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005c88:	cf d3       	brcs	80005c82 <idata_load_loop>

80005c8a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005c8a:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005c8e:	e0 61 bf f0 	mov	r1,49136
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005c92:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005c94:	c0 62       	brcc	80005ca0 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005c96:	30 02       	mov	r2,0
80005c98:	30 03       	mov	r3,0

80005c9a <udata_clear_loop>:
80005c9a:	a1 22       	st.d	r0++,r2
80005c9c:	02 30       	cp.w	r0,r1
80005c9e:	cf e3       	brcs	80005c9a <udata_clear_loop>

80005ca0 <udata_clear_loop_end>:
80005ca0:	fe cf e9 28 	sub	pc,pc,-5848
80005ca4:	80 00       	ld.sh	r0,r0[0x0]
80005ca6:	e2 a8       	*unknown*

80005ca8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005ca8:	f8 c8 ff f8 	sub	r8,r12,-8
80005cac:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005cae:	3f f9       	mov	r9,-1
80005cb0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005cb2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005cb4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005cb6:	30 08       	mov	r8,0
80005cb8:	99 08       	st.w	r12[0x0],r8
}
80005cba:	5e fc       	retal	r12

80005cbc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005cbc:	30 08       	mov	r8,0
80005cbe:	99 48       	st.w	r12[0x10],r8
}
80005cc0:	5e fc       	retal	r12

80005cc2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005cc2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005cc4:	70 19       	ld.w	r9,r8[0x4]
80005cc6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005cc8:	78 19       	ld.w	r9,r12[0x4]
80005cca:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005ccc:	70 19       	ld.w	r9,r8[0x4]
80005cce:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005cd0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005cd2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005cd4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005cd6:	78 08       	ld.w	r8,r12[0x0]
80005cd8:	2f f8       	sub	r8,-1
80005cda:	99 08       	st.w	r12[0x0],r8
}
80005cdc:	5e fc       	retal	r12

80005cde <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005cde:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005ce0:	5b fa       	cp.w	r10,-1
80005ce2:	c0 31       	brne	80005ce8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005ce4:	78 48       	ld.w	r8,r12[0x10]
80005ce6:	c0 c8       	rjmp	80005cfe <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005ce8:	f8 c8 ff f8 	sub	r8,r12,-8
80005cec:	70 19       	ld.w	r9,r8[0x4]
80005cee:	72 09       	ld.w	r9,r9[0x0]
80005cf0:	12 3a       	cp.w	r10,r9
80005cf2:	c0 63       	brcs	80005cfe <vListInsert+0x20>
80005cf4:	70 18       	ld.w	r8,r8[0x4]
80005cf6:	70 19       	ld.w	r9,r8[0x4]
80005cf8:	72 09       	ld.w	r9,r9[0x0]
80005cfa:	12 3a       	cp.w	r10,r9
80005cfc:	cf c2       	brcc	80005cf4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005cfe:	70 19       	ld.w	r9,r8[0x4]
80005d00:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d02:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005d04:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d06:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d08:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d0a:	78 08       	ld.w	r8,r12[0x0]
80005d0c:	2f f8       	sub	r8,-1
80005d0e:	99 08       	st.w	r12[0x0],r8
}
80005d10:	5e fc       	retal	r12

80005d12 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005d12:	78 18       	ld.w	r8,r12[0x4]
80005d14:	78 29       	ld.w	r9,r12[0x8]
80005d16:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005d18:	78 28       	ld.w	r8,r12[0x8]
80005d1a:	78 19       	ld.w	r9,r12[0x4]
80005d1c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005d1e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005d20:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005d22:	18 39       	cp.w	r9,r12
80005d24:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005d28:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005d2c:	30 09       	mov	r9,0
80005d2e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005d30:	70 09       	ld.w	r9,r8[0x0]
80005d32:	20 19       	sub	r9,1
80005d34:	91 09       	st.w	r8[0x0],r9
}
80005d36:	5e fc       	retal	r12

80005d38 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005d38:	e0 68 08 08 	mov	r8,2056
80005d3c:	ea 18 08 08 	orh	r8,0x808
80005d40:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005d42:	e0 68 09 09 	mov	r8,2313
80005d46:	ea 18 09 09 	orh	r8,0x909
80005d4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005d4c:	e0 68 0a 0a 	mov	r8,2570
80005d50:	ea 18 0a 0a 	orh	r8,0xa0a
80005d54:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005d56:	e0 68 0b 0b 	mov	r8,2827
80005d5a:	ea 18 0b 0b 	orh	r8,0xb0b
80005d5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005d60:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005d62:	e0 68 be ef 	mov	r8,48879
80005d66:	ea 18 de ad 	orh	r8,0xdead
80005d6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005d6c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005d6e:	fc 18 00 40 	movh	r8,0x40
80005d72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005d74:	e0 68 00 ff 	mov	r8,255
80005d78:	ea 18 ff 00 	orh	r8,0xff00
80005d7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005d7e:	e0 68 01 01 	mov	r8,257
80005d82:	ea 18 01 01 	orh	r8,0x101
80005d86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005d88:	e0 68 02 02 	mov	r8,514
80005d8c:	ea 18 02 02 	orh	r8,0x202
80005d90:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005d92:	e0 68 03 03 	mov	r8,771
80005d96:	ea 18 03 03 	orh	r8,0x303
80005d9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005d9c:	e0 68 04 04 	mov	r8,1028
80005da0:	ea 18 04 04 	orh	r8,0x404
80005da4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005da6:	e0 68 05 05 	mov	r8,1285
80005daa:	ea 18 05 05 	orh	r8,0x505
80005dae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005db0:	e0 68 06 06 	mov	r8,1542
80005db4:	ea 18 06 06 	orh	r8,0x606
80005db8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005dba:	e0 68 07 07 	mov	r8,1799
80005dbe:	ea 18 07 07 	orh	r8,0x707
80005dc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005dc4:	30 08       	mov	r8,0
80005dc6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005dc8:	5e fc       	retal	r12
80005dca:	d7 03       	nop

80005dcc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005dcc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005dce:	48 38       	lddpc	r8,80005dd8 <vPortEnterCritical+0xc>
80005dd0:	70 09       	ld.w	r9,r8[0x0]
80005dd2:	2f f9       	sub	r9,-1
80005dd4:	91 09       	st.w	r8[0x0],r9
}
80005dd6:	5e fc       	retal	r12
80005dd8:	00 00       	add	r0,r0
80005dda:	05 34       	ld.ub	r4,r2++

80005ddc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005ddc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005dde:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005de0:	30 0a       	mov	r10,0
80005de2:	14 9b       	mov	r11,r10
80005de4:	49 2c       	lddpc	r12,80005e2c <xPortStartScheduler+0x50>
80005de6:	f0 1f 00 13 	mcall	80005e30 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005dea:	e0 68 5d c0 	mov	r8,24000
80005dee:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005df2:	30 08       	mov	r8,0
80005df4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005df8:	e0 68 0c f8 	mov	r8,3320
80005dfc:	ea 18 00 00 	orh	r8,0x0
80005e00:	70 00       	ld.w	r0,r8[0x0]
80005e02:	60 0d       	ld.w	sp,r0[0x0]
80005e04:	1b 00       	ld.w	r0,sp++
80005e06:	e0 68 05 34 	mov	r8,1332
80005e0a:	ea 18 00 00 	orh	r8,0x0
80005e0e:	91 00       	st.w	r8[0x0],r0
80005e10:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e14:	2f ed       	sub	sp,-8
80005e16:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005e1a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005e1e:	e3 b0 00 00 	mtsr	0x0,r0
80005e22:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005e26:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005e2a:	d8 0a       	popm	pc,r12=0
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	5e f8       	retal	r8
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	55 9c       	stdsp	sp[0x164],r12

80005e34 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005e34:	20 6d       	sub	sp,24
80005e36:	eb cd 00 ff 	pushm	r0-r7
80005e3a:	fa c7 ff c0 	sub	r7,sp,-64
80005e3e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005e42:	ef 40 ff e0 	st.w	r7[-32],r0
80005e46:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005e4a:	ef 40 ff e4 	st.w	r7[-28],r0
80005e4e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005e52:	e0 68 05 34 	mov	r8,1332
80005e56:	ea 18 00 00 	orh	r8,0x0
80005e5a:	70 00       	ld.w	r0,r8[0x0]
80005e5c:	1a d0       	st.w	--sp,r0
80005e5e:	f0 1f 00 1a 	mcall	80005ec4 <LABEL_RET_SCALL_263+0x14>
80005e62:	e0 68 0c f8 	mov	r8,3320
80005e66:	ea 18 00 00 	orh	r8,0x0
80005e6a:	70 00       	ld.w	r0,r8[0x0]
80005e6c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005e6e:	f0 1f 00 17 	mcall	80005ec8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005e72:	e0 68 0c f8 	mov	r8,3320
80005e76:	ea 18 00 00 	orh	r8,0x0
80005e7a:	70 00       	ld.w	r0,r8[0x0]
80005e7c:	60 0d       	ld.w	sp,r0[0x0]
80005e7e:	1b 00       	ld.w	r0,sp++
80005e80:	e0 68 05 34 	mov	r8,1332
80005e84:	ea 18 00 00 	orh	r8,0x0
80005e88:	91 00       	st.w	r8[0x0],r0
80005e8a:	fa c7 ff d8 	sub	r7,sp,-40
80005e8e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005e92:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005e96:	e0 61 05 34 	mov	r1,1332
80005e9a:	ea 11 00 00 	orh	r1,0x0
80005e9e:	62 02       	ld.w	r2,r1[0x0]
80005ea0:	58 02       	cp.w	r2,0
80005ea2:	c0 70       	breq	80005eb0 <LABEL_RET_SCALL_263>
80005ea4:	e4 c2 00 01 	sub	r2,r2,1
80005ea8:	83 02       	st.w	r1[0x0],r2
80005eaa:	58 02       	cp.w	r2,0
80005eac:	c0 21       	brne	80005eb0 <LABEL_RET_SCALL_263>
80005eae:	b1 c0       	cbr	r0,0x10

80005eb0 <LABEL_RET_SCALL_263>:
80005eb0:	ef 40 ff f8 	st.w	r7[-8],r0
80005eb4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005eb8:	ef 40 ff fc 	st.w	r7[-4],r0
80005ebc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ec0:	2f ad       	sub	sp,-24
80005ec2:	d6 13       	rets
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	5d cc       	*unknown*
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	65 68       	ld.w	r8,r2[0x58]

80005ecc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005ecc:	e1 b8 00 43 	mfsr	r8,0x10c
80005ed0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005ed4:	5e fc       	retal	r12
80005ed6:	d7 03       	nop

80005ed8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005ed8:	48 78       	lddpc	r8,80005ef4 <vPortExitCritical+0x1c>
80005eda:	70 08       	ld.w	r8,r8[0x0]
80005edc:	58 08       	cp.w	r8,0
80005ede:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005ee0:	48 58       	lddpc	r8,80005ef4 <vPortExitCritical+0x1c>
80005ee2:	70 09       	ld.w	r9,r8[0x0]
80005ee4:	20 19       	sub	r9,1
80005ee6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005ee8:	70 08       	ld.w	r8,r8[0x0]
80005eea:	58 08       	cp.w	r8,0
80005eec:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005eee:	d5 03       	csrf	0x10
80005ef0:	5e fc       	retal	r12
80005ef2:	00 00       	add	r0,r0
80005ef4:	00 00       	add	r0,r0
80005ef6:	05 34       	ld.ub	r4,r2++

80005ef8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005ef8:	eb cd 00 ff 	pushm	r0-r7
80005efc:	e0 68 05 34 	mov	r8,1332
80005f00:	ea 18 00 00 	orh	r8,0x0
80005f04:	70 00       	ld.w	r0,r8[0x0]
80005f06:	1a d0       	st.w	--sp,r0
80005f08:	7a 90       	ld.w	r0,sp[0x24]
80005f0a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f0e:	58 10       	cp.w	r0,1
80005f10:	e0 8b 00 08 	brhi	80005f20 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005f14:	e0 68 0c f8 	mov	r8,3320
80005f18:	ea 18 00 00 	orh	r8,0x0
80005f1c:	70 00       	ld.w	r0,r8[0x0]
80005f1e:	81 0d       	st.w	r0[0x0],sp

80005f20 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005f20:	f0 1f 00 12 	mcall	80005f68 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005f24:	f0 1f 00 12 	mcall	80005f6c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005f28:	f0 1f 00 12 	mcall	80005f70 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005f2c:	f0 1f 00 12 	mcall	80005f74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005f30:	7a 90       	ld.w	r0,sp[0x24]
80005f32:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f36:	58 10       	cp.w	r0,1
80005f38:	e0 8b 00 0e 	brhi	80005f54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005f3c:	f0 1f 00 0c 	mcall	80005f6c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005f40:	f0 1f 00 0e 	mcall	80005f78 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005f44:	f0 1f 00 0c 	mcall	80005f74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005f48:	e0 68 0c f8 	mov	r8,3320
80005f4c:	ea 18 00 00 	orh	r8,0x0
80005f50:	70 00       	ld.w	r0,r8[0x0]
80005f52:	60 0d       	ld.w	sp,r0[0x0]

80005f54 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005f54:	1b 00       	ld.w	r0,sp++
80005f56:	e0 68 05 34 	mov	r8,1332
80005f5a:	ea 18 00 00 	orh	r8,0x0
80005f5e:	91 00       	st.w	r8[0x0],r0
80005f60:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f64:	d6 03       	rete
80005f66:	00 00       	add	r0,r0
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	5e cc       	retvs	r12
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	5d cc       	*unknown*
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	67 6c       	ld.w	r12,r3[0x58]
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	5e d8       	retvc	r8
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	65 68       	ld.w	r8,r2[0x58]

80005f7c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005f7c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005f7e:	f0 1f 00 02 	mcall	80005f84 <__malloc_lock+0x8>
}
80005f82:	d8 02       	popm	pc
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	65 58       	ld.w	r8,r2[0x54]

80005f88 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005f88:	d4 01       	pushm	lr
	xTaskResumeAll();
80005f8a:	f0 1f 00 02 	mcall	80005f90 <__malloc_unlock+0x8>
}
80005f8e:	d8 02       	popm	pc
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	69 14       	ld.w	r4,r4[0x44]

80005f94 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005f94:	d4 21       	pushm	r4-r7,lr
80005f96:	16 95       	mov	r5,r11
80005f98:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005f9a:	58 0c       	cp.w	r12,0
80005f9c:	c0 30       	breq	80005fa2 <_read+0xe>
80005f9e:	3f f7       	mov	r7,-1
80005fa0:	c1 48       	rjmp	80005fc8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005fa2:	58 0a       	cp.w	r10,0
80005fa4:	e0 89 00 04 	brgt	80005fac <_read+0x18>
80005fa8:	30 07       	mov	r7,0
80005faa:	c0 f8       	rjmp	80005fc8 <_read+0x34>
80005fac:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005fae:	48 84       	lddpc	r4,80005fcc <_read+0x38>
80005fb0:	68 0c       	ld.w	r12,r4[0x0]
80005fb2:	f0 1f 00 08 	mcall	80005fd0 <_read+0x3c>
    if (c < 0)
80005fb6:	c0 95       	brlt	80005fc8 <_read+0x34>
      break;

    *ptr++ = c;
80005fb8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005fbc:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005fbe:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005fc2:	58 08       	cp.w	r8,0
80005fc4:	fe 99 ff f6 	brgt	80005fb0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005fc8:	0e 9c       	mov	r12,r7
80005fca:	d8 22       	popm	r4-r7,pc
80005fcc:	00 00       	add	r0,r0
80005fce:	bf e4       	*unknown*
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	5b 20       	cp.w	r0,-14

80005fd4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005fd4:	d4 21       	pushm	r4-r7,lr
80005fd6:	16 95       	mov	r5,r11
80005fd8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005fda:	20 1c       	sub	r12,1
80005fdc:	58 2c       	cp.w	r12,2
80005fde:	e0 8b 00 12 	brhi	80006002 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005fe2:	58 0a       	cp.w	r10,0
80005fe4:	c0 31       	brne	80005fea <_write+0x16>
80005fe6:	30 07       	mov	r7,0
80005fe8:	c0 e8       	rjmp	80006004 <_write+0x30>
80005fea:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005fec:	48 74       	lddpc	r4,80006008 <_write+0x34>
80005fee:	68 0c       	ld.w	r12,r4[0x0]
80005ff0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005ff4:	f0 1f 00 06 	mcall	8000600c <_write+0x38>
80005ff8:	c0 55       	brlt	80006002 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005ffa:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005ffc:	0e 36       	cp.w	r6,r7
80005ffe:	cf 81       	brne	80005fee <_write+0x1a>
80006000:	c0 28       	rjmp	80006004 <_write+0x30>
80006002:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006004:	0e 9c       	mov	r12,r7
80006006:	d8 22       	popm	r4-r7,pc
80006008:	00 00       	add	r0,r0
8000600a:	bf e4       	*unknown*
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	5a d0       	cp.w	r0,-19

80006010 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006010:	eb cd 40 80 	pushm	r7,lr
80006014:	18 97       	mov	r7,r12
	if( pv )
80006016:	58 0c       	cp.w	r12,0
80006018:	c0 80       	breq	80006028 <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000601a:	f0 1f 00 05 	mcall	8000602c <vPortFree+0x1c>
		{
			free( pv );
8000601e:	0e 9c       	mov	r12,r7
80006020:	f0 1f 00 04 	mcall	80006030 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006024:	f0 1f 00 04 	mcall	80006034 <vPortFree+0x24>
80006028:	e3 cd 80 80 	ldm	sp++,r7,pc
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	65 58       	ld.w	r8,r2[0x54]
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	73 e8       	ld.w	r8,r9[0x78]
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	69 14       	ld.w	r4,r4[0x44]

80006038 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006038:	eb cd 40 80 	pushm	r7,lr
8000603c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000603e:	f0 1f 00 06 	mcall	80006054 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006042:	0e 9c       	mov	r12,r7
80006044:	f0 1f 00 05 	mcall	80006058 <pvPortMalloc+0x20>
80006048:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000604a:	f0 1f 00 05 	mcall	8000605c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000604e:	0e 9c       	mov	r12,r7
80006050:	e3 cd 80 80 	ldm	sp++,r7,pc
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	65 58       	ld.w	r8,r2[0x54]
80006058:	80 00       	ld.sh	r0,r0[0x0]
8000605a:	73 f8       	ld.w	r8,r9[0x7c]
8000605c:	80 00       	ld.sh	r0,r0[0x0]
8000605e:	69 14       	ld.w	r4,r4[0x44]

80006060 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006060:	d4 01       	pushm	lr
80006062:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006064:	78 09       	ld.w	r9,r12[0x0]
80006066:	58 09       	cp.w	r9,0
80006068:	c1 10       	breq	8000608a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000606a:	78 3a       	ld.w	r10,r12[0xc]
8000606c:	79 09       	ld.w	r9,r12[0x40]
8000606e:	f4 09 00 09 	add	r9,r10,r9
80006072:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006074:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006076:	14 39       	cp.w	r9,r10
80006078:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000607c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006080:	79 0a       	ld.w	r10,r12[0x40]
80006082:	78 3b       	ld.w	r11,r12[0xc]
80006084:	10 9c       	mov	r12,r8
80006086:	f0 1f 00 02 	mcall	8000608c <prvCopyDataFromQueue+0x2c>
8000608a:	d8 02       	popm	pc
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	78 40       	ld.w	r0,r12[0x10]

80006090 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006090:	eb cd 40 c0 	pushm	r6-r7,lr
80006094:	18 97       	mov	r7,r12
80006096:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006098:	78 e8       	ld.w	r8,r12[0x38]
8000609a:	58 08       	cp.w	r8,0
8000609c:	c0 31       	brne	800060a2 <xQueueReceiveFromISR+0x12>
8000609e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800060a2:	f0 1f 00 0e 	mcall	800060d8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800060a6:	6e e8       	ld.w	r8,r7[0x38]
800060a8:	20 18       	sub	r8,1
800060aa:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800060ac:	6f 18       	ld.w	r8,r7[0x44]
800060ae:	5b f8       	cp.w	r8,-1
800060b0:	c0 d1       	brne	800060ca <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060b2:	6e 48       	ld.w	r8,r7[0x10]
800060b4:	58 08       	cp.w	r8,0
800060b6:	c0 f0       	breq	800060d4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060b8:	ee cc ff f0 	sub	r12,r7,-16
800060bc:	f0 1f 00 08 	mcall	800060dc <xQueueReceiveFromISR+0x4c>
800060c0:	c0 a0       	breq	800060d4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800060c2:	30 1c       	mov	r12,1
800060c4:	8d 0c       	st.w	r6[0x0],r12
800060c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800060ca:	2f f8       	sub	r8,-1
800060cc:	ef 48 00 44 	st.w	r7[68],r8
800060d0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800060d4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800060d8:	80 00       	ld.sh	r0,r0[0x0]
800060da:	60 60       	ld.w	r0,r0[0x18]
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	66 f0       	ld.w	r0,r3[0x3c]

800060e0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800060e0:	eb cd 40 c0 	pushm	r6-r7,lr
800060e4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800060e6:	f0 1f 00 23 	mcall	80006170 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800060ea:	6f 28       	ld.w	r8,r7[0x48]
800060ec:	58 08       	cp.w	r8,0
800060ee:	e0 8a 00 18 	brle	8000611e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800060f2:	6e 98       	ld.w	r8,r7[0x24]
800060f4:	58 08       	cp.w	r8,0
800060f6:	c1 40       	breq	8000611e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800060f8:	ee c6 ff dc 	sub	r6,r7,-36
800060fc:	c0 48       	rjmp	80006104 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800060fe:	6e 98       	ld.w	r8,r7[0x24]
80006100:	58 08       	cp.w	r8,0
80006102:	c0 e0       	breq	8000611e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006104:	0c 9c       	mov	r12,r6
80006106:	f0 1f 00 1c 	mcall	80006174 <prvUnlockQueue+0x94>
8000610a:	c0 30       	breq	80006110 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000610c:	f0 1f 00 1b 	mcall	80006178 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006110:	6f 28       	ld.w	r8,r7[0x48]
80006112:	20 18       	sub	r8,1
80006114:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006118:	58 08       	cp.w	r8,0
8000611a:	fe 99 ff f2 	brgt	800060fe <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000611e:	3f f8       	mov	r8,-1
80006120:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006124:	f0 1f 00 16 	mcall	8000617c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006128:	f0 1f 00 12 	mcall	80006170 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000612c:	6f 18       	ld.w	r8,r7[0x44]
8000612e:	58 08       	cp.w	r8,0
80006130:	e0 8a 00 18 	brle	80006160 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006134:	6e 48       	ld.w	r8,r7[0x10]
80006136:	58 08       	cp.w	r8,0
80006138:	c1 40       	breq	80006160 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000613a:	ee c6 ff f0 	sub	r6,r7,-16
8000613e:	c0 48       	rjmp	80006146 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006140:	6e 48       	ld.w	r8,r7[0x10]
80006142:	58 08       	cp.w	r8,0
80006144:	c0 e0       	breq	80006160 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006146:	0c 9c       	mov	r12,r6
80006148:	f0 1f 00 0b 	mcall	80006174 <prvUnlockQueue+0x94>
8000614c:	c0 30       	breq	80006152 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000614e:	f0 1f 00 0b 	mcall	80006178 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006152:	6f 18       	ld.w	r8,r7[0x44]
80006154:	20 18       	sub	r8,1
80006156:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000615a:	58 08       	cp.w	r8,0
8000615c:	fe 99 ff f2 	brgt	80006140 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006160:	3f f8       	mov	r8,-1
80006162:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006166:	f0 1f 00 06 	mcall	8000617c <prvUnlockQueue+0x9c>
}
8000616a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000616e:	00 00       	add	r0,r0
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	5d cc       	*unknown*
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	66 f0       	ld.w	r0,r3[0x3c]
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	65 fc       	ld.w	r12,r2[0x7c]
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	5e d8       	retvc	r8

80006180 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006180:	d4 31       	pushm	r0-r7,lr
80006182:	20 5d       	sub	sp,20
80006184:	18 97       	mov	r7,r12
80006186:	50 0b       	stdsp	sp[0x0],r11
80006188:	50 2a       	stdsp	sp[0x8],r10
8000618a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000618c:	f8 c2 ff dc 	sub	r2,r12,-36
80006190:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006192:	fa c4 ff f4 	sub	r4,sp,-12
80006196:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006198:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000619a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000619e:	f0 1f 00 3e 	mcall	80006294 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800061a2:	6e e8       	ld.w	r8,r7[0x38]
800061a4:	58 08       	cp.w	r8,0
800061a6:	c2 a0       	breq	800061fa <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800061a8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800061aa:	40 0b       	lddsp	r11,sp[0x0]
800061ac:	0e 9c       	mov	r12,r7
800061ae:	f0 1f 00 3b 	mcall	80006298 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800061b2:	40 18       	lddsp	r8,sp[0x4]
800061b4:	58 08       	cp.w	r8,0
800061b6:	c1 51       	brne	800061e0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800061b8:	6e e8       	ld.w	r8,r7[0x38]
800061ba:	20 18       	sub	r8,1
800061bc:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800061be:	6e 08       	ld.w	r8,r7[0x0]
800061c0:	58 08       	cp.w	r8,0
800061c2:	c0 41       	brne	800061ca <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800061c4:	f0 1f 00 36 	mcall	8000629c <xQueueGenericReceive+0x11c>
800061c8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061ca:	6e 48       	ld.w	r8,r7[0x10]
800061cc:	58 08       	cp.w	r8,0
800061ce:	c1 20       	breq	800061f2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800061d0:	ee cc ff f0 	sub	r12,r7,-16
800061d4:	f0 1f 00 33 	mcall	800062a0 <xQueueGenericReceive+0x120>
800061d8:	58 1c       	cp.w	r12,1
800061da:	c0 c1       	brne	800061f2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800061dc:	d7 33       	scall
800061de:	c0 a8       	rjmp	800061f2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800061e0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061e2:	6e 98       	ld.w	r8,r7[0x24]
800061e4:	58 08       	cp.w	r8,0
800061e6:	c0 60       	breq	800061f2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061e8:	04 9c       	mov	r12,r2
800061ea:	f0 1f 00 2e 	mcall	800062a0 <xQueueGenericReceive+0x120>
800061ee:	c0 20       	breq	800061f2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800061f0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800061f2:	f0 1f 00 2d 	mcall	800062a4 <xQueueGenericReceive+0x124>
800061f6:	30 1c       	mov	r12,1
				return pdPASS;
800061f8:	c4 c8       	rjmp	80006290 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800061fa:	40 28       	lddsp	r8,sp[0x8]
800061fc:	58 08       	cp.w	r8,0
800061fe:	c0 51       	brne	80006208 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006200:	f0 1f 00 29 	mcall	800062a4 <xQueueGenericReceive+0x124>
80006204:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006206:	c4 58       	rjmp	80006290 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006208:	58 05       	cp.w	r5,0
8000620a:	c0 51       	brne	80006214 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000620c:	08 9c       	mov	r12,r4
8000620e:	f0 1f 00 27 	mcall	800062a8 <xQueueGenericReceive+0x128>
80006212:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006214:	f0 1f 00 24 	mcall	800062a4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006218:	f0 1f 00 25 	mcall	800062ac <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000621c:	f0 1f 00 1e 	mcall	80006294 <xQueueGenericReceive+0x114>
80006220:	6f 18       	ld.w	r8,r7[0x44]
80006222:	5b f8       	cp.w	r8,-1
80006224:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006228:	6f 28       	ld.w	r8,r7[0x48]
8000622a:	5b f8       	cp.w	r8,-1
8000622c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006230:	f0 1f 00 1d 	mcall	800062a4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006234:	06 9b       	mov	r11,r3
80006236:	08 9c       	mov	r12,r4
80006238:	f0 1f 00 1e 	mcall	800062b0 <xQueueGenericReceive+0x130>
8000623c:	c2 41       	brne	80006284 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000623e:	f0 1f 00 16 	mcall	80006294 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006242:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006244:	f0 1f 00 18 	mcall	800062a4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006248:	58 06       	cp.w	r6,0
8000624a:	c1 71       	brne	80006278 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000624c:	6e 08       	ld.w	r8,r7[0x0]
8000624e:	58 08       	cp.w	r8,0
80006250:	c0 81       	brne	80006260 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006252:	f0 1f 00 11 	mcall	80006294 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006256:	6e 1c       	ld.w	r12,r7[0x4]
80006258:	f0 1f 00 17 	mcall	800062b4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000625c:	f0 1f 00 12 	mcall	800062a4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006260:	40 2b       	lddsp	r11,sp[0x8]
80006262:	04 9c       	mov	r12,r2
80006264:	f0 1f 00 15 	mcall	800062b8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006268:	0e 9c       	mov	r12,r7
8000626a:	f0 1f 00 15 	mcall	800062bc <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000626e:	f0 1f 00 15 	mcall	800062c0 <xQueueGenericReceive+0x140>
80006272:	c9 61       	brne	8000619e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006274:	d7 33       	scall
80006276:	c9 4b       	rjmp	8000619e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006278:	0e 9c       	mov	r12,r7
8000627a:	f0 1f 00 11 	mcall	800062bc <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000627e:	f0 1f 00 11 	mcall	800062c0 <xQueueGenericReceive+0x140>
80006282:	c8 eb       	rjmp	8000619e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006284:	0e 9c       	mov	r12,r7
80006286:	f0 1f 00 0e 	mcall	800062bc <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000628a:	f0 1f 00 0e 	mcall	800062c0 <xQueueGenericReceive+0x140>
8000628e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006290:	2f bd       	sub	sp,-20
80006292:	d8 32       	popm	r0-r7,pc
80006294:	80 00       	ld.sh	r0,r0[0x0]
80006296:	5d cc       	*unknown*
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	60 60       	ld.w	r0,r0[0x18]
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	66 08       	ld.w	r8,r3[0x0]
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	66 f0       	ld.w	r0,r3[0x3c]
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	5e d8       	retvc	r8
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	65 e4       	ld.w	r4,r2[0x78]
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	65 58       	ld.w	r8,r2[0x54]
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	68 80       	ld.w	r0,r4[0x20]
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	66 6c       	ld.w	r12,r3[0x18]
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	6b 20       	ld.w	r0,r5[0x48]
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	60 e0       	ld.w	r0,r0[0x38]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	69 14       	ld.w	r4,r4[0x44]

800062c4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800062c4:	eb cd 40 80 	pushm	r7,lr
800062c8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800062ca:	79 08       	ld.w	r8,r12[0x40]
800062cc:	58 08       	cp.w	r8,0
800062ce:	c0 a1       	brne	800062e2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800062d0:	78 08       	ld.w	r8,r12[0x0]
800062d2:	58 08       	cp.w	r8,0
800062d4:	c2 b1       	brne	8000632a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800062d6:	78 1c       	ld.w	r12,r12[0x4]
800062d8:	f0 1f 00 17 	mcall	80006334 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800062dc:	30 08       	mov	r8,0
800062de:	8f 18       	st.w	r7[0x4],r8
800062e0:	c2 58       	rjmp	8000632a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800062e2:	58 0a       	cp.w	r10,0
800062e4:	c1 01       	brne	80006304 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800062e6:	10 9a       	mov	r10,r8
800062e8:	78 2c       	ld.w	r12,r12[0x8]
800062ea:	f0 1f 00 14 	mcall	80006338 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800062ee:	6e 29       	ld.w	r9,r7[0x8]
800062f0:	6f 08       	ld.w	r8,r7[0x40]
800062f2:	f2 08 00 08 	add	r8,r9,r8
800062f6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800062f8:	6e 19       	ld.w	r9,r7[0x4]
800062fa:	12 38       	cp.w	r8,r9
800062fc:	c1 73       	brcs	8000632a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800062fe:	6e 08       	ld.w	r8,r7[0x0]
80006300:	8f 28       	st.w	r7[0x8],r8
80006302:	c1 48       	rjmp	8000632a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006304:	10 9a       	mov	r10,r8
80006306:	78 3c       	ld.w	r12,r12[0xc]
80006308:	f0 1f 00 0c 	mcall	80006338 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000630c:	6f 08       	ld.w	r8,r7[0x40]
8000630e:	6e 39       	ld.w	r9,r7[0xc]
80006310:	f2 08 01 08 	sub	r8,r9,r8
80006314:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006316:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006318:	12 38       	cp.w	r8,r9
8000631a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000631e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006322:	f3 d8 e3 19 	subcs	r9,r9,r8
80006326:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000632a:	6e e8       	ld.w	r8,r7[0x38]
8000632c:	2f f8       	sub	r8,-1
8000632e:	8f e8       	st.w	r7[0x38],r8
}
80006330:	e3 cd 80 80 	ldm	sp++,r7,pc
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	66 14       	ld.w	r4,r3[0x4]
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	78 40       	ld.w	r0,r12[0x10]

8000633c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000633c:	eb cd 40 c0 	pushm	r6-r7,lr
80006340:	18 97       	mov	r7,r12
80006342:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006344:	78 ec       	ld.w	r12,r12[0x38]
80006346:	6e f8       	ld.w	r8,r7[0x3c]
80006348:	10 3c       	cp.w	r12,r8
8000634a:	c0 33       	brcs	80006350 <xQueueGenericSendFromISR+0x14>
8000634c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006350:	12 9a       	mov	r10,r9
80006352:	0e 9c       	mov	r12,r7
80006354:	f0 1f 00 0c 	mcall	80006384 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006358:	6f 28       	ld.w	r8,r7[0x48]
8000635a:	5b f8       	cp.w	r8,-1
8000635c:	c0 d1       	brne	80006376 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000635e:	6e 98       	ld.w	r8,r7[0x24]
80006360:	58 08       	cp.w	r8,0
80006362:	c0 f0       	breq	80006380 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006364:	ee cc ff dc 	sub	r12,r7,-36
80006368:	f0 1f 00 08 	mcall	80006388 <xQueueGenericSendFromISR+0x4c>
8000636c:	c0 a0       	breq	80006380 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000636e:	30 1c       	mov	r12,1
80006370:	8d 0c       	st.w	r6[0x0],r12
80006372:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006376:	2f f8       	sub	r8,-1
80006378:	ef 48 00 48 	st.w	r7[72],r8
8000637c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006380:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	62 c4       	ld.w	r4,r1[0x30]
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	66 f0       	ld.w	r0,r3[0x3c]

8000638c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000638c:	d4 31       	pushm	r0-r7,lr
8000638e:	20 5d       	sub	sp,20
80006390:	18 97       	mov	r7,r12
80006392:	50 0b       	stdsp	sp[0x0],r11
80006394:	50 2a       	stdsp	sp[0x8],r10
80006396:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006398:	f8 c0 ff f0 	sub	r0,r12,-16
8000639c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000639e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800063a2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063a4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800063a8:	f0 1f 00 2f 	mcall	80006464 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800063ac:	6e e9       	ld.w	r9,r7[0x38]
800063ae:	6e f8       	ld.w	r8,r7[0x3c]
800063b0:	10 39       	cp.w	r9,r8
800063b2:	c1 42       	brcc	800063da <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063b4:	40 1a       	lddsp	r10,sp[0x4]
800063b6:	40 0b       	lddsp	r11,sp[0x0]
800063b8:	0e 9c       	mov	r12,r7
800063ba:	f0 1f 00 2c 	mcall	80006468 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063be:	6e 98       	ld.w	r8,r7[0x24]
800063c0:	58 08       	cp.w	r8,0
800063c2:	c0 80       	breq	800063d2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800063c4:	ee cc ff dc 	sub	r12,r7,-36
800063c8:	f0 1f 00 29 	mcall	8000646c <xQueueGenericSend+0xe0>
800063cc:	58 1c       	cp.w	r12,1
800063ce:	c0 21       	brne	800063d2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800063d0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800063d2:	f0 1f 00 28 	mcall	80006470 <xQueueGenericSend+0xe4>
800063d6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800063d8:	c4 38       	rjmp	8000645e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800063da:	40 28       	lddsp	r8,sp[0x8]
800063dc:	58 08       	cp.w	r8,0
800063de:	c0 51       	brne	800063e8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800063e0:	f0 1f 00 24 	mcall	80006470 <xQueueGenericSend+0xe4>
800063e4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800063e6:	c3 c8       	rjmp	8000645e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800063e8:	58 04       	cp.w	r4,0
800063ea:	c0 51       	brne	800063f4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800063ec:	06 9c       	mov	r12,r3
800063ee:	f0 1f 00 22 	mcall	80006474 <xQueueGenericSend+0xe8>
800063f2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800063f4:	f0 1f 00 1f 	mcall	80006470 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800063f8:	f0 1f 00 20 	mcall	80006478 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800063fc:	f0 1f 00 1a 	mcall	80006464 <xQueueGenericSend+0xd8>
80006400:	6f 18       	ld.w	r8,r7[0x44]
80006402:	5b f8       	cp.w	r8,-1
80006404:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006408:	6f 28       	ld.w	r8,r7[0x48]
8000640a:	5b f8       	cp.w	r8,-1
8000640c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006410:	f0 1f 00 18 	mcall	80006470 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006414:	04 9b       	mov	r11,r2
80006416:	06 9c       	mov	r12,r3
80006418:	f0 1f 00 19 	mcall	8000647c <xQueueGenericSend+0xf0>
8000641c:	c1 b1       	brne	80006452 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000641e:	f0 1f 00 12 	mcall	80006464 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006422:	6e e5       	ld.w	r5,r7[0x38]
80006424:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006426:	f0 1f 00 13 	mcall	80006470 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000642a:	0c 35       	cp.w	r5,r6
8000642c:	c0 d1       	brne	80006446 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000642e:	40 2b       	lddsp	r11,sp[0x8]
80006430:	00 9c       	mov	r12,r0
80006432:	f0 1f 00 14 	mcall	80006480 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006436:	0e 9c       	mov	r12,r7
80006438:	f0 1f 00 13 	mcall	80006484 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000643c:	f0 1f 00 13 	mcall	80006488 <xQueueGenericSend+0xfc>
80006440:	cb 41       	brne	800063a8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006442:	d7 33       	scall
80006444:	cb 2b       	rjmp	800063a8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006446:	0e 9c       	mov	r12,r7
80006448:	f0 1f 00 0f 	mcall	80006484 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000644c:	f0 1f 00 0f 	mcall	80006488 <xQueueGenericSend+0xfc>
80006450:	ca cb       	rjmp	800063a8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006452:	0e 9c       	mov	r12,r7
80006454:	f0 1f 00 0c 	mcall	80006484 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006458:	f0 1f 00 0c 	mcall	80006488 <xQueueGenericSend+0xfc>
8000645c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000645e:	2f bd       	sub	sp,-20
80006460:	d8 32       	popm	r0-r7,pc
80006462:	00 00       	add	r0,r0
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	5d cc       	*unknown*
80006468:	80 00       	ld.sh	r0,r0[0x0]
8000646a:	62 c4       	ld.w	r4,r1[0x30]
8000646c:	80 00       	ld.sh	r0,r0[0x0]
8000646e:	66 f0       	ld.w	r0,r3[0x3c]
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	5e d8       	retvc	r8
80006474:	80 00       	ld.sh	r0,r0[0x0]
80006476:	65 e4       	ld.w	r4,r2[0x78]
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	65 58       	ld.w	r8,r2[0x54]
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	68 80       	ld.w	r0,r4[0x20]
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	6b 20       	ld.w	r0,r5[0x48]
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	60 e0       	ld.w	r0,r0[0x38]
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	69 14       	ld.w	r4,r4[0x44]

8000648c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000648c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006490:	34 cc       	mov	r12,76
80006492:	f0 1f 00 12 	mcall	800064d8 <xQueueCreateMutex+0x4c>
80006496:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006498:	c1 d0       	breq	800064d2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000649a:	30 06       	mov	r6,0
8000649c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000649e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800064a0:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800064a2:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800064a4:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800064a6:	30 18       	mov	r8,1
800064a8:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800064aa:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800064ae:	3f f8       	mov	r8,-1
800064b0:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800064b4:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800064b8:	2f 0c       	sub	r12,-16
800064ba:	f0 1f 00 09 	mcall	800064dc <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800064be:	ee cc ff dc 	sub	r12,r7,-36
800064c2:	f0 1f 00 07 	mcall	800064dc <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800064c6:	0c 99       	mov	r9,r6
800064c8:	0c 9a       	mov	r10,r6
800064ca:	0c 9b       	mov	r11,r6
800064cc:	0e 9c       	mov	r12,r7
800064ce:	f0 1f 00 05 	mcall	800064e0 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800064d2:	0e 9c       	mov	r12,r7
800064d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	60 38       	ld.w	r8,r0[0xc]
800064dc:	80 00       	ld.sh	r0,r0[0x0]
800064de:	5c a8       	swap.h	r8
800064e0:	80 00       	ld.sh	r0,r0[0x0]
800064e2:	63 8c       	ld.w	r12,r1[0x60]

800064e4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800064e4:	d4 21       	pushm	r4-r7,lr
800064e6:	18 97       	mov	r7,r12
800064e8:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800064ea:	58 0c       	cp.w	r12,0
800064ec:	c2 f0       	breq	8000654a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800064ee:	34 cc       	mov	r12,76
800064f0:	f0 1f 00 17 	mcall	8000654c <xQueueCreate+0x68>
800064f4:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800064f6:	c2 a0       	breq	8000654a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800064f8:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800064fc:	e8 cc ff ff 	sub	r12,r4,-1
80006500:	f0 1f 00 13 	mcall	8000654c <xQueueCreate+0x68>
80006504:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006506:	c1 e0       	breq	80006542 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006508:	f8 04 00 04 	add	r4,r12,r4
8000650c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000650e:	30 08       	mov	r8,0
80006510:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006512:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006514:	ee c8 00 01 	sub	r8,r7,1
80006518:	ad 38       	mul	r8,r6
8000651a:	10 0c       	add	r12,r8
8000651c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000651e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006520:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006524:	3f f8       	mov	r8,-1
80006526:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000652a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000652e:	ea cc ff f0 	sub	r12,r5,-16
80006532:	f0 1f 00 08 	mcall	80006550 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006536:	ea cc ff dc 	sub	r12,r5,-36
8000653a:	f0 1f 00 06 	mcall	80006550 <xQueueCreate+0x6c>
8000653e:	0a 9c       	mov	r12,r5
80006540:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006542:	0a 9c       	mov	r12,r5
80006544:	f0 1f 00 04 	mcall	80006554 <xQueueCreate+0x70>
80006548:	d8 2a       	popm	r4-r7,pc,r12=0
8000654a:	d8 2a       	popm	r4-r7,pc,r12=0
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	60 38       	ld.w	r8,r0[0xc]
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	5c a8       	swap.h	r8
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	60 10       	ld.w	r0,r0[0x4]

80006558 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006558:	48 38       	lddpc	r8,80006564 <vTaskSuspendAll+0xc>
8000655a:	70 09       	ld.w	r9,r8[0x0]
8000655c:	2f f9       	sub	r9,-1
8000655e:	91 09       	st.w	r8[0x0],r9
}
80006560:	5e fc       	retal	r12
80006562:	00 00       	add	r0,r0
80006564:	00 00       	add	r0,r0
80006566:	0d 28       	ld.uh	r8,r6++

80006568 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006568:	49 a8       	lddpc	r8,800065d0 <vTaskSwitchContext+0x68>
8000656a:	70 08       	ld.w	r8,r8[0x0]
8000656c:	58 08       	cp.w	r8,0
8000656e:	c0 b1       	brne	80006584 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006570:	49 98       	lddpc	r8,800065d4 <vTaskSwitchContext+0x6c>
80006572:	70 08       	ld.w	r8,r8[0x0]
80006574:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006578:	49 89       	lddpc	r9,800065d8 <vTaskSwitchContext+0x70>
8000657a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000657e:	58 08       	cp.w	r8,0
80006580:	c0 60       	breq	8000658c <vTaskSwitchContext+0x24>
80006582:	c1 18       	rjmp	800065a4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006584:	30 19       	mov	r9,1
80006586:	49 68       	lddpc	r8,800065dc <vTaskSwitchContext+0x74>
80006588:	91 09       	st.w	r8[0x0],r9
8000658a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000658c:	49 28       	lddpc	r8,800065d4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000658e:	49 3a       	lddpc	r10,800065d8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006590:	70 09       	ld.w	r9,r8[0x0]
80006592:	20 19       	sub	r9,1
80006594:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006596:	70 09       	ld.w	r9,r8[0x0]
80006598:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000659c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800065a0:	58 09       	cp.w	r9,0
800065a2:	cf 70       	breq	80006590 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800065a4:	48 c8       	lddpc	r8,800065d4 <vTaskSwitchContext+0x6c>
800065a6:	70 08       	ld.w	r8,r8[0x0]
800065a8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800065ac:	48 b9       	lddpc	r9,800065d8 <vTaskSwitchContext+0x70>
800065ae:	f2 08 00 28 	add	r8,r9,r8<<0x2
800065b2:	70 19       	ld.w	r9,r8[0x4]
800065b4:	72 19       	ld.w	r9,r9[0x4]
800065b6:	91 19       	st.w	r8[0x4],r9
800065b8:	f0 ca ff f8 	sub	r10,r8,-8
800065bc:	14 39       	cp.w	r9,r10
800065be:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800065c2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800065c6:	70 18       	ld.w	r8,r8[0x4]
800065c8:	70 39       	ld.w	r9,r8[0xc]
800065ca:	48 68       	lddpc	r8,800065e0 <vTaskSwitchContext+0x78>
800065cc:	91 09       	st.w	r8[0x0],r9
800065ce:	5e fc       	retal	r12
800065d0:	00 00       	add	r0,r0
800065d2:	0d 28       	ld.uh	r8,r6++
800065d4:	00 00       	add	r0,r0
800065d6:	0d 60       	ld.uh	r0,--r6
800065d8:	00 00       	add	r0,r0
800065da:	0c 44       	or	r4,r6
800065dc:	00 00       	add	r0,r0
800065de:	0d 48       	ld.w	r8,--r6
800065e0:	00 00       	add	r0,r0
800065e2:	0c f8       	st.b	--r6,r8

800065e4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800065e4:	48 48       	lddpc	r8,800065f4 <vTaskSetTimeOutState+0x10>
800065e6:	70 08       	ld.w	r8,r8[0x0]
800065e8:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800065ea:	48 48       	lddpc	r8,800065f8 <vTaskSetTimeOutState+0x14>
800065ec:	70 08       	ld.w	r8,r8[0x0]
800065ee:	99 18       	st.w	r12[0x4],r8
}
800065f0:	5e fc       	retal	r12
800065f2:	00 00       	add	r0,r0
800065f4:	00 00       	add	r0,r0
800065f6:	0c 3c       	cp.w	r12,r6
800065f8:	00 00       	add	r0,r0
800065fa:	0d 24       	ld.uh	r4,r6++

800065fc <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800065fc:	30 19       	mov	r9,1
800065fe:	48 28       	lddpc	r8,80006604 <vTaskMissedYield+0x8>
80006600:	91 09       	st.w	r8[0x0],r9
}
80006602:	5e fc       	retal	r12
80006604:	00 00       	add	r0,r0
80006606:	0d 48       	ld.w	r8,--r6

80006608 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006608:	48 28       	lddpc	r8,80006610 <xTaskGetCurrentTaskHandle+0x8>
8000660a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000660c:	5e fc       	retal	r12
8000660e:	00 00       	add	r0,r0
80006610:	00 00       	add	r0,r0
80006612:	0c f8       	st.b	--r6,r8

80006614 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006614:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006618:	58 0c       	cp.w	r12,0
8000661a:	c1 f0       	breq	80006658 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000661c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000661e:	78 b9       	ld.w	r9,r12[0x2c]
80006620:	79 18       	ld.w	r8,r12[0x44]
80006622:	10 39       	cp.w	r9,r8
80006624:	c1 a0       	breq	80006658 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006626:	f8 c6 ff fc 	sub	r6,r12,-4
8000662a:	0c 9c       	mov	r12,r6
8000662c:	f0 1f 00 0c 	mcall	8000665c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006630:	6f 1c       	ld.w	r12,r7[0x44]
80006632:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006634:	f8 08 11 08 	rsub	r8,r12,8
80006638:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000663a:	48 a8       	lddpc	r8,80006660 <vTaskPriorityDisinherit+0x4c>
8000663c:	70 08       	ld.w	r8,r8[0x0]
8000663e:	10 3c       	cp.w	r12,r8
80006640:	e0 88 00 04 	brls	80006648 <vTaskPriorityDisinherit+0x34>
80006644:	48 78       	lddpc	r8,80006660 <vTaskPriorityDisinherit+0x4c>
80006646:	91 0c       	st.w	r8[0x0],r12
80006648:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000664c:	0c 9b       	mov	r11,r6
8000664e:	48 68       	lddpc	r8,80006664 <vTaskPriorityDisinherit+0x50>
80006650:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006654:	f0 1f 00 05 	mcall	80006668 <vTaskPriorityDisinherit+0x54>
80006658:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000665c:	80 00       	ld.sh	r0,r0[0x0]
8000665e:	5d 12       	icall	r2
80006660:	00 00       	add	r0,r0
80006662:	0d 60       	ld.uh	r0,--r6
80006664:	00 00       	add	r0,r0
80006666:	0c 44       	or	r4,r6
80006668:	80 00       	ld.sh	r0,r0[0x0]
8000666a:	5c c2       	swap.bh	r2

8000666c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000666c:	eb cd 40 c0 	pushm	r6-r7,lr
80006670:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006672:	49 b8       	lddpc	r8,800066dc <vTaskPriorityInherit+0x70>
80006674:	70 08       	ld.w	r8,r8[0x0]
80006676:	78 b9       	ld.w	r9,r12[0x2c]
80006678:	70 b8       	ld.w	r8,r8[0x2c]
8000667a:	10 39       	cp.w	r9,r8
8000667c:	c2 d2       	brcc	800066d6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000667e:	49 88       	lddpc	r8,800066dc <vTaskPriorityInherit+0x70>
80006680:	70 08       	ld.w	r8,r8[0x0]
80006682:	70 b8       	ld.w	r8,r8[0x2c]
80006684:	f0 08 11 08 	rsub	r8,r8,8
80006688:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000668a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000668e:	49 59       	lddpc	r9,800066e0 <vTaskPriorityInherit+0x74>
80006690:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006694:	78 59       	ld.w	r9,r12[0x14]
80006696:	10 39       	cp.w	r9,r8
80006698:	c1 b1       	brne	800066ce <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000669a:	f8 c6 ff fc 	sub	r6,r12,-4
8000669e:	0c 9c       	mov	r12,r6
800066a0:	f0 1f 00 11 	mcall	800066e4 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066a4:	48 e8       	lddpc	r8,800066dc <vTaskPriorityInherit+0x70>
800066a6:	70 08       	ld.w	r8,r8[0x0]
800066a8:	70 bc       	ld.w	r12,r8[0x2c]
800066aa:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800066ac:	48 f8       	lddpc	r8,800066e8 <vTaskPriorityInherit+0x7c>
800066ae:	70 08       	ld.w	r8,r8[0x0]
800066b0:	10 3c       	cp.w	r12,r8
800066b2:	e0 88 00 04 	brls	800066ba <vTaskPriorityInherit+0x4e>
800066b6:	48 d8       	lddpc	r8,800066e8 <vTaskPriorityInherit+0x7c>
800066b8:	91 0c       	st.w	r8[0x0],r12
800066ba:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066be:	0c 9b       	mov	r11,r6
800066c0:	48 88       	lddpc	r8,800066e0 <vTaskPriorityInherit+0x74>
800066c2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066c6:	f0 1f 00 0a 	mcall	800066ec <vTaskPriorityInherit+0x80>
800066ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800066ce:	48 48       	lddpc	r8,800066dc <vTaskPriorityInherit+0x70>
800066d0:	70 08       	ld.w	r8,r8[0x0]
800066d2:	70 b8       	ld.w	r8,r8[0x2c]
800066d4:	99 b8       	st.w	r12[0x2c],r8
800066d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066da:	00 00       	add	r0,r0
800066dc:	00 00       	add	r0,r0
800066de:	0c f8       	st.b	--r6,r8
800066e0:	00 00       	add	r0,r0
800066e2:	0c 44       	or	r4,r6
800066e4:	80 00       	ld.sh	r0,r0[0x0]
800066e6:	5d 12       	icall	r2
800066e8:	00 00       	add	r0,r0
800066ea:	0d 60       	ld.uh	r0,--r6
800066ec:	80 00       	ld.sh	r0,r0[0x0]
800066ee:	5c c2       	swap.bh	r2

800066f0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800066f0:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800066f4:	78 38       	ld.w	r8,r12[0xc]
800066f6:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800066f8:	ee c6 ff e8 	sub	r6,r7,-24
800066fc:	0c 9c       	mov	r12,r6
800066fe:	f0 1f 00 15 	mcall	80006750 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006702:	49 58       	lddpc	r8,80006754 <xTaskRemoveFromEventList+0x64>
80006704:	70 08       	ld.w	r8,r8[0x0]
80006706:	58 08       	cp.w	r8,0
80006708:	c1 71       	brne	80006736 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000670a:	ee c6 ff fc 	sub	r6,r7,-4
8000670e:	0c 9c       	mov	r12,r6
80006710:	f0 1f 00 10 	mcall	80006750 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006714:	6e bc       	ld.w	r12,r7[0x2c]
80006716:	49 18       	lddpc	r8,80006758 <xTaskRemoveFromEventList+0x68>
80006718:	70 08       	ld.w	r8,r8[0x0]
8000671a:	10 3c       	cp.w	r12,r8
8000671c:	e0 88 00 04 	brls	80006724 <xTaskRemoveFromEventList+0x34>
80006720:	48 e8       	lddpc	r8,80006758 <xTaskRemoveFromEventList+0x68>
80006722:	91 0c       	st.w	r8[0x0],r12
80006724:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006728:	0c 9b       	mov	r11,r6
8000672a:	48 d8       	lddpc	r8,8000675c <xTaskRemoveFromEventList+0x6c>
8000672c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006730:	f0 1f 00 0c 	mcall	80006760 <xTaskRemoveFromEventList+0x70>
80006734:	c0 58       	rjmp	8000673e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006736:	0c 9b       	mov	r11,r6
80006738:	48 bc       	lddpc	r12,80006764 <xTaskRemoveFromEventList+0x74>
8000673a:	f0 1f 00 0a 	mcall	80006760 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000673e:	48 b8       	lddpc	r8,80006768 <xTaskRemoveFromEventList+0x78>
80006740:	70 08       	ld.w	r8,r8[0x0]
80006742:	6e b9       	ld.w	r9,r7[0x2c]
80006744:	70 b8       	ld.w	r8,r8[0x2c]
80006746:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006748:	5f 2c       	srhs	r12
8000674a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000674e:	00 00       	add	r0,r0
80006750:	80 00       	ld.sh	r0,r0[0x0]
80006752:	5d 12       	icall	r2
80006754:	00 00       	add	r0,r0
80006756:	0d 28       	ld.uh	r8,r6++
80006758:	00 00       	add	r0,r0
8000675a:	0d 60       	ld.uh	r0,--r6
8000675c:	00 00       	add	r0,r0
8000675e:	0c 44       	or	r4,r6
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	5c c2       	swap.bh	r2
80006764:	00 00       	add	r0,r0
80006766:	0c fc       	st.b	--r6,r12
80006768:	00 00       	add	r0,r0
8000676a:	0c f8       	st.b	--r6,r8

8000676c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000676c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006770:	4b 98       	lddpc	r8,80006854 <vTaskIncrementTick+0xe8>
80006772:	70 08       	ld.w	r8,r8[0x0]
80006774:	58 08       	cp.w	r8,0
80006776:	c6 91       	brne	80006848 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006778:	4b 88       	lddpc	r8,80006858 <vTaskIncrementTick+0xec>
8000677a:	70 09       	ld.w	r9,r8[0x0]
8000677c:	2f f9       	sub	r9,-1
8000677e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006780:	70 08       	ld.w	r8,r8[0x0]
80006782:	58 08       	cp.w	r8,0
80006784:	c1 a1       	brne	800067b8 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006786:	4b 68       	lddpc	r8,8000685c <vTaskIncrementTick+0xf0>
80006788:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000678a:	4b 69       	lddpc	r9,80006860 <vTaskIncrementTick+0xf4>
8000678c:	72 0b       	ld.w	r11,r9[0x0]
8000678e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006790:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006792:	4b 59       	lddpc	r9,80006864 <vTaskIncrementTick+0xf8>
80006794:	72 0a       	ld.w	r10,r9[0x0]
80006796:	2f fa       	sub	r10,-1
80006798:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000679a:	70 08       	ld.w	r8,r8[0x0]
8000679c:	70 08       	ld.w	r8,r8[0x0]
8000679e:	58 08       	cp.w	r8,0
800067a0:	c0 51       	brne	800067aa <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800067a2:	3f f9       	mov	r9,-1
800067a4:	4b 18       	lddpc	r8,80006868 <vTaskIncrementTick+0xfc>
800067a6:	91 09       	st.w	r8[0x0],r9
800067a8:	c0 88       	rjmp	800067b8 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800067aa:	4a d8       	lddpc	r8,8000685c <vTaskIncrementTick+0xf0>
800067ac:	70 08       	ld.w	r8,r8[0x0]
800067ae:	70 38       	ld.w	r8,r8[0xc]
800067b0:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800067b2:	70 19       	ld.w	r9,r8[0x4]
800067b4:	4a d8       	lddpc	r8,80006868 <vTaskIncrementTick+0xfc>
800067b6:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800067b8:	4a 88       	lddpc	r8,80006858 <vTaskIncrementTick+0xec>
800067ba:	70 09       	ld.w	r9,r8[0x0]
800067bc:	4a b8       	lddpc	r8,80006868 <vTaskIncrementTick+0xfc>
800067be:	70 08       	ld.w	r8,r8[0x0]
800067c0:	10 39       	cp.w	r9,r8
800067c2:	c4 73       	brcs	80006850 <vTaskIncrementTick+0xe4>
800067c4:	4a 68       	lddpc	r8,8000685c <vTaskIncrementTick+0xf0>
800067c6:	70 08       	ld.w	r8,r8[0x0]
800067c8:	70 08       	ld.w	r8,r8[0x0]
800067ca:	58 08       	cp.w	r8,0
800067cc:	c0 c0       	breq	800067e4 <vTaskIncrementTick+0x78>
800067ce:	4a 48       	lddpc	r8,8000685c <vTaskIncrementTick+0xf0>
800067d0:	70 08       	ld.w	r8,r8[0x0]
800067d2:	70 38       	ld.w	r8,r8[0xc]
800067d4:	70 37       	ld.w	r7,r8[0xc]
800067d6:	6e 18       	ld.w	r8,r7[0x4]
800067d8:	4a 09       	lddpc	r9,80006858 <vTaskIncrementTick+0xec>
800067da:	72 09       	ld.w	r9,r9[0x0]
800067dc:	12 38       	cp.w	r8,r9
800067de:	e0 88 00 14 	brls	80006806 <vTaskIncrementTick+0x9a>
800067e2:	c0 e8       	rjmp	800067fe <vTaskIncrementTick+0x92>
800067e4:	3f f9       	mov	r9,-1
800067e6:	4a 18       	lddpc	r8,80006868 <vTaskIncrementTick+0xfc>
800067e8:	91 09       	st.w	r8[0x0],r9
800067ea:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800067ee:	6a 08       	ld.w	r8,r5[0x0]
800067f0:	70 38       	ld.w	r8,r8[0xc]
800067f2:	70 37       	ld.w	r7,r8[0xc]
800067f4:	6e 18       	ld.w	r8,r7[0x4]
800067f6:	64 09       	ld.w	r9,r2[0x0]
800067f8:	12 38       	cp.w	r8,r9
800067fa:	e0 88 00 0a 	brls	8000680e <vTaskIncrementTick+0xa2>
800067fe:	49 b9       	lddpc	r9,80006868 <vTaskIncrementTick+0xfc>
80006800:	93 08       	st.w	r9[0x0],r8
80006802:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006806:	49 a4       	lddpc	r4,8000686c <vTaskIncrementTick+0x100>
80006808:	49 a3       	lddpc	r3,80006870 <vTaskIncrementTick+0x104>
8000680a:	49 55       	lddpc	r5,8000685c <vTaskIncrementTick+0xf0>
8000680c:	49 32       	lddpc	r2,80006858 <vTaskIncrementTick+0xec>
8000680e:	ee c6 ff fc 	sub	r6,r7,-4
80006812:	0c 9c       	mov	r12,r6
80006814:	f0 1f 00 18 	mcall	80006874 <vTaskIncrementTick+0x108>
80006818:	6e a8       	ld.w	r8,r7[0x28]
8000681a:	58 08       	cp.w	r8,0
8000681c:	c0 50       	breq	80006826 <vTaskIncrementTick+0xba>
8000681e:	ee cc ff e8 	sub	r12,r7,-24
80006822:	f0 1f 00 15 	mcall	80006874 <vTaskIncrementTick+0x108>
80006826:	6e bc       	ld.w	r12,r7[0x2c]
80006828:	68 08       	ld.w	r8,r4[0x0]
8000682a:	10 3c       	cp.w	r12,r8
8000682c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006830:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006834:	0c 9b       	mov	r11,r6
80006836:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000683a:	f0 1f 00 10 	mcall	80006878 <vTaskIncrementTick+0x10c>
8000683e:	6a 08       	ld.w	r8,r5[0x0]
80006840:	70 08       	ld.w	r8,r8[0x0]
80006842:	58 08       	cp.w	r8,0
80006844:	cd 51       	brne	800067ee <vTaskIncrementTick+0x82>
80006846:	cc fb       	rjmp	800067e4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006848:	48 d8       	lddpc	r8,8000687c <vTaskIncrementTick+0x110>
8000684a:	70 09       	ld.w	r9,r8[0x0]
8000684c:	2f f9       	sub	r9,-1
8000684e:	91 09       	st.w	r8[0x0],r9
80006850:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006854:	00 00       	add	r0,r0
80006856:	0d 28       	ld.uh	r8,r6++
80006858:	00 00       	add	r0,r0
8000685a:	0d 24       	ld.uh	r4,r6++
8000685c:	00 00       	add	r0,r0
8000685e:	0c 30       	cp.w	r0,r6
80006860:	00 00       	add	r0,r0
80006862:	0c 40       	or	r0,r6
80006864:	00 00       	add	r0,r0
80006866:	0c 3c       	cp.w	r12,r6
80006868:	00 00       	add	r0,r0
8000686a:	05 38       	ld.ub	r8,r2++
8000686c:	00 00       	add	r0,r0
8000686e:	0d 60       	ld.uh	r0,--r6
80006870:	00 00       	add	r0,r0
80006872:	0c 44       	or	r4,r6
80006874:	80 00       	ld.sh	r0,r0[0x0]
80006876:	5d 12       	icall	r2
80006878:	80 00       	ld.sh	r0,r0[0x0]
8000687a:	5c c2       	swap.bh	r2
8000687c:	00 00       	add	r0,r0
8000687e:	0c 28       	rsub	r8,r6

80006880 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006880:	eb cd 40 c0 	pushm	r6-r7,lr
80006884:	18 97       	mov	r7,r12
80006886:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006888:	f0 1f 00 15 	mcall	800068dc <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000688c:	6c 08       	ld.w	r8,r6[0x0]
8000688e:	5b f8       	cp.w	r8,-1
80006890:	c0 31       	brne	80006896 <xTaskCheckForTimeOut+0x16>
80006892:	30 07       	mov	r7,0
80006894:	c1 f8       	rjmp	800068d2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006896:	49 39       	lddpc	r9,800068e0 <xTaskCheckForTimeOut+0x60>
80006898:	72 09       	ld.w	r9,r9[0x0]
8000689a:	6e 0a       	ld.w	r10,r7[0x0]
8000689c:	12 3a       	cp.w	r10,r9
8000689e:	c0 70       	breq	800068ac <xTaskCheckForTimeOut+0x2c>
800068a0:	49 19       	lddpc	r9,800068e4 <xTaskCheckForTimeOut+0x64>
800068a2:	72 09       	ld.w	r9,r9[0x0]
800068a4:	6e 1a       	ld.w	r10,r7[0x4]
800068a6:	12 3a       	cp.w	r10,r9
800068a8:	e0 88 00 14 	brls	800068d0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800068ac:	48 e9       	lddpc	r9,800068e4 <xTaskCheckForTimeOut+0x64>
800068ae:	72 0a       	ld.w	r10,r9[0x0]
800068b0:	6e 19       	ld.w	r9,r7[0x4]
800068b2:	12 1a       	sub	r10,r9
800068b4:	14 38       	cp.w	r8,r10
800068b6:	e0 88 00 0d 	brls	800068d0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800068ba:	48 ba       	lddpc	r10,800068e4 <xTaskCheckForTimeOut+0x64>
800068bc:	74 0a       	ld.w	r10,r10[0x0]
800068be:	14 19       	sub	r9,r10
800068c0:	f2 08 00 08 	add	r8,r9,r8
800068c4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800068c6:	0e 9c       	mov	r12,r7
800068c8:	f0 1f 00 08 	mcall	800068e8 <xTaskCheckForTimeOut+0x68>
800068cc:	30 07       	mov	r7,0
800068ce:	c0 28       	rjmp	800068d2 <xTaskCheckForTimeOut+0x52>
800068d0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800068d2:	f0 1f 00 07 	mcall	800068ec <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800068d6:	0e 9c       	mov	r12,r7
800068d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	5d cc       	*unknown*
800068e0:	00 00       	add	r0,r0
800068e2:	0c 3c       	cp.w	r12,r6
800068e4:	00 00       	add	r0,r0
800068e6:	0d 24       	ld.uh	r4,r6++
800068e8:	80 00       	ld.sh	r0,r0[0x0]
800068ea:	65 e4       	ld.w	r4,r2[0x78]
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	5e d8       	retvc	r8

800068f0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800068f0:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800068f4:	f0 1f 00 05 	mcall	80006908 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800068f8:	48 58       	lddpc	r8,8000690c <xTaskGetTickCount+0x1c>
800068fa:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800068fc:	f0 1f 00 05 	mcall	80006910 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006900:	0e 9c       	mov	r12,r7
80006902:	e3 cd 80 80 	ldm	sp++,r7,pc
80006906:	00 00       	add	r0,r0
80006908:	80 00       	ld.sh	r0,r0[0x0]
8000690a:	5d cc       	*unknown*
8000690c:	00 00       	add	r0,r0
8000690e:	0d 24       	ld.uh	r4,r6++
80006910:	80 00       	ld.sh	r0,r0[0x0]
80006912:	5e d8       	retvc	r8

80006914 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006914:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006918:	f0 1f 00 2c 	mcall	800069c8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000691c:	4a c8       	lddpc	r8,800069cc <xTaskResumeAll+0xb8>
8000691e:	70 09       	ld.w	r9,r8[0x0]
80006920:	20 19       	sub	r9,1
80006922:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006924:	70 08       	ld.w	r8,r8[0x0]
80006926:	58 08       	cp.w	r8,0
80006928:	c4 91       	brne	800069ba <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000692a:	4a a8       	lddpc	r8,800069d0 <xTaskResumeAll+0xbc>
8000692c:	70 08       	ld.w	r8,r8[0x0]
8000692e:	58 08       	cp.w	r8,0
80006930:	c4 50       	breq	800069ba <xTaskResumeAll+0xa6>
80006932:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006934:	4a 85       	lddpc	r5,800069d4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006936:	4a 93       	lddpc	r3,800069d8 <xTaskResumeAll+0xc4>
80006938:	4a 92       	lddpc	r2,800069dc <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000693a:	4a a1       	lddpc	r1,800069e0 <xTaskResumeAll+0xcc>
8000693c:	c1 e8       	rjmp	80006978 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000693e:	6a 38       	ld.w	r8,r5[0xc]
80006940:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006942:	ee cc ff e8 	sub	r12,r7,-24
80006946:	f0 1f 00 28 	mcall	800069e4 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000694a:	ee c6 ff fc 	sub	r6,r7,-4
8000694e:	0c 9c       	mov	r12,r6
80006950:	f0 1f 00 25 	mcall	800069e4 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006954:	6e bc       	ld.w	r12,r7[0x2c]
80006956:	66 08       	ld.w	r8,r3[0x0]
80006958:	10 3c       	cp.w	r12,r8
8000695a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000695e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006962:	0c 9b       	mov	r11,r6
80006964:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006968:	f0 1f 00 20 	mcall	800069e8 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000696c:	62 08       	ld.w	r8,r1[0x0]
8000696e:	6e b9       	ld.w	r9,r7[0x2c]
80006970:	70 b8       	ld.w	r8,r8[0x2c]
80006972:	10 39       	cp.w	r9,r8
80006974:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006978:	6a 08       	ld.w	r8,r5[0x0]
8000697a:	58 08       	cp.w	r8,0
8000697c:	ce 11       	brne	8000693e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000697e:	49 c8       	lddpc	r8,800069ec <xTaskResumeAll+0xd8>
80006980:	70 08       	ld.w	r8,r8[0x0]
80006982:	58 08       	cp.w	r8,0
80006984:	c0 f0       	breq	800069a2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006986:	49 a8       	lddpc	r8,800069ec <xTaskResumeAll+0xd8>
80006988:	70 08       	ld.w	r8,r8[0x0]
8000698a:	58 08       	cp.w	r8,0
8000698c:	c1 10       	breq	800069ae <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000698e:	49 87       	lddpc	r7,800069ec <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006990:	f0 1f 00 18 	mcall	800069f0 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006994:	6e 08       	ld.w	r8,r7[0x0]
80006996:	20 18       	sub	r8,1
80006998:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000699a:	6e 08       	ld.w	r8,r7[0x0]
8000699c:	58 08       	cp.w	r8,0
8000699e:	cf 91       	brne	80006990 <xTaskResumeAll+0x7c>
800069a0:	c0 78       	rjmp	800069ae <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800069a2:	58 14       	cp.w	r4,1
800069a4:	c0 50       	breq	800069ae <xTaskResumeAll+0x9a>
800069a6:	49 48       	lddpc	r8,800069f4 <xTaskResumeAll+0xe0>
800069a8:	70 08       	ld.w	r8,r8[0x0]
800069aa:	58 18       	cp.w	r8,1
800069ac:	c0 71       	brne	800069ba <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800069ae:	30 09       	mov	r9,0
800069b0:	49 18       	lddpc	r8,800069f4 <xTaskResumeAll+0xe0>
800069b2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800069b4:	d7 33       	scall
800069b6:	30 17       	mov	r7,1
800069b8:	c0 28       	rjmp	800069bc <xTaskResumeAll+0xa8>
800069ba:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800069bc:	f0 1f 00 0f 	mcall	800069f8 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800069c0:	0e 9c       	mov	r12,r7
800069c2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800069c6:	00 00       	add	r0,r0
800069c8:	80 00       	ld.sh	r0,r0[0x0]
800069ca:	5d cc       	*unknown*
800069cc:	00 00       	add	r0,r0
800069ce:	0d 28       	ld.uh	r8,r6++
800069d0:	00 00       	add	r0,r0
800069d2:	0d 44       	ld.w	r4,--r6
800069d4:	00 00       	add	r0,r0
800069d6:	0c fc       	st.b	--r6,r12
800069d8:	00 00       	add	r0,r0
800069da:	0d 60       	ld.uh	r0,--r6
800069dc:	00 00       	add	r0,r0
800069de:	0c 44       	or	r4,r6
800069e0:	00 00       	add	r0,r0
800069e2:	0c f8       	st.b	--r6,r8
800069e4:	80 00       	ld.sh	r0,r0[0x0]
800069e6:	5d 12       	icall	r2
800069e8:	80 00       	ld.sh	r0,r0[0x0]
800069ea:	5c c2       	swap.bh	r2
800069ec:	00 00       	add	r0,r0
800069ee:	0c 28       	rsub	r8,r6
800069f0:	80 00       	ld.sh	r0,r0[0x0]
800069f2:	67 6c       	ld.w	r12,r3[0x58]
800069f4:	00 00       	add	r0,r0
800069f6:	0d 48       	ld.w	r8,--r6
800069f8:	80 00       	ld.sh	r0,r0[0x0]
800069fa:	5e d8       	retvc	r8

800069fc <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800069fc:	eb cd 40 80 	pushm	r7,lr
80006a00:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a02:	49 08       	lddpc	r8,80006a40 <prvAddCurrentTaskToDelayedList+0x44>
80006a04:	70 08       	ld.w	r8,r8[0x0]
80006a06:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006a08:	48 f8       	lddpc	r8,80006a44 <prvAddCurrentTaskToDelayedList+0x48>
80006a0a:	70 08       	ld.w	r8,r8[0x0]
80006a0c:	10 3c       	cp.w	r12,r8
80006a0e:	c0 a2       	brcc	80006a22 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a10:	48 c8       	lddpc	r8,80006a40 <prvAddCurrentTaskToDelayedList+0x44>
80006a12:	70 0b       	ld.w	r11,r8[0x0]
80006a14:	48 d8       	lddpc	r8,80006a48 <prvAddCurrentTaskToDelayedList+0x4c>
80006a16:	70 0c       	ld.w	r12,r8[0x0]
80006a18:	2f cb       	sub	r11,-4
80006a1a:	f0 1f 00 0d 	mcall	80006a4c <prvAddCurrentTaskToDelayedList+0x50>
80006a1e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a22:	48 88       	lddpc	r8,80006a40 <prvAddCurrentTaskToDelayedList+0x44>
80006a24:	70 0b       	ld.w	r11,r8[0x0]
80006a26:	48 b8       	lddpc	r8,80006a50 <prvAddCurrentTaskToDelayedList+0x54>
80006a28:	70 0c       	ld.w	r12,r8[0x0]
80006a2a:	2f cb       	sub	r11,-4
80006a2c:	f0 1f 00 08 	mcall	80006a4c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006a30:	48 98       	lddpc	r8,80006a54 <prvAddCurrentTaskToDelayedList+0x58>
80006a32:	70 08       	ld.w	r8,r8[0x0]
80006a34:	10 37       	cp.w	r7,r8
80006a36:	c0 32       	brcc	80006a3c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006a38:	48 78       	lddpc	r8,80006a54 <prvAddCurrentTaskToDelayedList+0x58>
80006a3a:	91 07       	st.w	r8[0x0],r7
80006a3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a40:	00 00       	add	r0,r0
80006a42:	0c f8       	st.b	--r6,r8
80006a44:	00 00       	add	r0,r0
80006a46:	0d 24       	ld.uh	r4,r6++
80006a48:	00 00       	add	r0,r0
80006a4a:	0c 40       	or	r0,r6
80006a4c:	80 00       	ld.sh	r0,r0[0x0]
80006a4e:	5c de       	com	lr
80006a50:	00 00       	add	r0,r0
80006a52:	0c 30       	cp.w	r0,r6
80006a54:	00 00       	add	r0,r0
80006a56:	05 38       	ld.ub	r8,r2++

80006a58 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a58:	eb cd 40 c0 	pushm	r6-r7,lr
80006a5c:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006a5e:	58 0c       	cp.w	r12,0
80006a60:	c1 10       	breq	80006a82 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006a62:	f0 1f 00 0a 	mcall	80006a88 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006a66:	48 a8       	lddpc	r8,80006a8c <vTaskDelay+0x34>
80006a68:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a6a:	48 a8       	lddpc	r8,80006a90 <vTaskDelay+0x38>
80006a6c:	70 0c       	ld.w	r12,r8[0x0]
80006a6e:	2f cc       	sub	r12,-4
80006a70:	f0 1f 00 09 	mcall	80006a94 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a74:	ee 06 00 0c 	add	r12,r7,r6
80006a78:	f0 1f 00 08 	mcall	80006a98 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006a7c:	f0 1f 00 08 	mcall	80006a9c <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a80:	c0 21       	brne	80006a84 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006a82:	d7 33       	scall
80006a84:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a88:	80 00       	ld.sh	r0,r0[0x0]
80006a8a:	65 58       	ld.w	r8,r2[0x54]
80006a8c:	00 00       	add	r0,r0
80006a8e:	0d 24       	ld.uh	r4,r6++
80006a90:	00 00       	add	r0,r0
80006a92:	0c f8       	st.b	--r6,r8
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	5d 12       	icall	r2
80006a98:	80 00       	ld.sh	r0,r0[0x0]
80006a9a:	69 fc       	ld.w	r12,r4[0x7c]
80006a9c:	80 00       	ld.sh	r0,r0[0x0]
80006a9e:	69 14       	ld.w	r4,r4[0x44]

80006aa0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006aa0:	eb cd 40 c0 	pushm	r6-r7,lr
80006aa4:	18 96       	mov	r6,r12
80006aa6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006aa8:	f0 1f 00 18 	mcall	80006b08 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006aac:	6c 08       	ld.w	r8,r6[0x0]
80006aae:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006ab0:	49 79       	lddpc	r9,80006b0c <vTaskDelayUntil+0x6c>
80006ab2:	72 09       	ld.w	r9,r9[0x0]
80006ab4:	12 38       	cp.w	r8,r9
80006ab6:	e0 88 00 0c 	brls	80006ace <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006aba:	0e 38       	cp.w	r8,r7
80006abc:	e0 88 00 22 	brls	80006b00 <vTaskDelayUntil+0x60>
80006ac0:	49 38       	lddpc	r8,80006b0c <vTaskDelayUntil+0x6c>
80006ac2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006ac4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006ac6:	10 37       	cp.w	r7,r8
80006ac8:	e0 88 00 14 	brls	80006af0 <vTaskDelayUntil+0x50>
80006acc:	c0 a8       	rjmp	80006ae0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006ace:	0e 38       	cp.w	r8,r7
80006ad0:	e0 8b 00 16 	brhi	80006afc <vTaskDelayUntil+0x5c>
80006ad4:	48 e8       	lddpc	r8,80006b0c <vTaskDelayUntil+0x6c>
80006ad6:	70 08       	ld.w	r8,r8[0x0]
80006ad8:	10 37       	cp.w	r7,r8
80006ada:	e0 8b 00 11 	brhi	80006afc <vTaskDelayUntil+0x5c>
80006ade:	c1 18       	rjmp	80006b00 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ae0:	48 c8       	lddpc	r8,80006b10 <vTaskDelayUntil+0x70>
80006ae2:	70 0c       	ld.w	r12,r8[0x0]
80006ae4:	2f cc       	sub	r12,-4
80006ae6:	f0 1f 00 0c 	mcall	80006b14 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006aea:	0e 9c       	mov	r12,r7
80006aec:	f0 1f 00 0b 	mcall	80006b18 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006af0:	f0 1f 00 0b 	mcall	80006b1c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006af4:	c0 81       	brne	80006b04 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006af6:	d7 33       	scall
80006af8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006afc:	8d 07       	st.w	r6[0x0],r7
80006afe:	cf 1b       	rjmp	80006ae0 <vTaskDelayUntil+0x40>
80006b00:	8d 07       	st.w	r6[0x0],r7
80006b02:	cf 7b       	rjmp	80006af0 <vTaskDelayUntil+0x50>
80006b04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b08:	80 00       	ld.sh	r0,r0[0x0]
80006b0a:	65 58       	ld.w	r8,r2[0x54]
80006b0c:	00 00       	add	r0,r0
80006b0e:	0d 24       	ld.uh	r4,r6++
80006b10:	00 00       	add	r0,r0
80006b12:	0c f8       	st.b	--r6,r8
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	5d 12       	icall	r2
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	69 fc       	ld.w	r12,r4[0x7c]
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	69 14       	ld.w	r4,r4[0x44]

80006b20 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006b20:	eb cd 40 c0 	pushm	r6-r7,lr
80006b24:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006b26:	48 e7       	lddpc	r7,80006b5c <vTaskPlaceOnEventList+0x3c>
80006b28:	6e 0b       	ld.w	r11,r7[0x0]
80006b2a:	2e 8b       	sub	r11,-24
80006b2c:	f0 1f 00 0d 	mcall	80006b60 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b30:	6e 0c       	ld.w	r12,r7[0x0]
80006b32:	2f cc       	sub	r12,-4
80006b34:	f0 1f 00 0c 	mcall	80006b64 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006b38:	5b f6       	cp.w	r6,-1
80006b3a:	c0 81       	brne	80006b4a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b3c:	6e 0b       	ld.w	r11,r7[0x0]
80006b3e:	2f cb       	sub	r11,-4
80006b40:	48 ac       	lddpc	r12,80006b68 <vTaskPlaceOnEventList+0x48>
80006b42:	f0 1f 00 0b 	mcall	80006b6c <vTaskPlaceOnEventList+0x4c>
80006b46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006b4a:	48 a8       	lddpc	r8,80006b70 <vTaskPlaceOnEventList+0x50>
80006b4c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b4e:	ec 0c 00 0c 	add	r12,r6,r12
80006b52:	f0 1f 00 09 	mcall	80006b74 <vTaskPlaceOnEventList+0x54>
80006b56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b5a:	00 00       	add	r0,r0
80006b5c:	00 00       	add	r0,r0
80006b5e:	0c f8       	st.b	--r6,r8
80006b60:	80 00       	ld.sh	r0,r0[0x0]
80006b62:	5c de       	com	lr
80006b64:	80 00       	ld.sh	r0,r0[0x0]
80006b66:	5d 12       	icall	r2
80006b68:	00 00       	add	r0,r0
80006b6a:	0d 4c       	ld.w	r12,--r6
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	5c c2       	swap.bh	r2
80006b70:	00 00       	add	r0,r0
80006b72:	0d 24       	ld.uh	r4,r6++
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	69 fc       	ld.w	r12,r4[0x7c]

80006b78 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006b78:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b7c:	49 67       	lddpc	r7,80006bd4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b7e:	49 74       	lddpc	r4,80006bd8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006b80:	49 73       	lddpc	r3,80006bdc <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b82:	49 85       	lddpc	r5,80006be0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b84:	6e 08       	ld.w	r8,r7[0x0]
80006b86:	58 08       	cp.w	r8,0
80006b88:	c1 e0       	breq	80006bc4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006b8a:	f0 1f 00 17 	mcall	80006be4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b8e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006b90:	f0 1f 00 16 	mcall	80006be8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006b94:	58 06       	cp.w	r6,0
80006b96:	c1 70       	breq	80006bc4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006b98:	f0 1f 00 15 	mcall	80006bec <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006b9c:	68 38       	ld.w	r8,r4[0xc]
80006b9e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006ba0:	ec cc ff fc 	sub	r12,r6,-4
80006ba4:	f0 1f 00 13 	mcall	80006bf0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006ba8:	66 08       	ld.w	r8,r3[0x0]
80006baa:	20 18       	sub	r8,1
80006bac:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006bae:	6e 08       	ld.w	r8,r7[0x0]
80006bb0:	20 18       	sub	r8,1
80006bb2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006bb4:	f0 1f 00 10 	mcall	80006bf4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006bb8:	6c cc       	ld.w	r12,r6[0x30]
80006bba:	f0 1f 00 10 	mcall	80006bf8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006bbe:	0c 9c       	mov	r12,r6
80006bc0:	f0 1f 00 0e 	mcall	80006bf8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006bc4:	6a 08       	ld.w	r8,r5[0x0]
80006bc6:	58 18       	cp.w	r8,1
80006bc8:	e0 88 00 03 	brls	80006bce <prvIdleTask+0x56>
			{
				taskYIELD();
80006bcc:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006bce:	f0 1f 00 0c 	mcall	80006bfc <prvIdleTask+0x84>
		}
		#endif
	}
80006bd2:	cd 9b       	rjmp	80006b84 <prvIdleTask+0xc>
80006bd4:	00 00       	add	r0,r0
80006bd6:	0c 38       	cp.w	r8,r6
80006bd8:	00 00       	add	r0,r0
80006bda:	0c e4       	st.h	--r6,r4
80006bdc:	00 00       	add	r0,r0
80006bde:	0d 44       	ld.w	r4,--r6
80006be0:	00 00       	add	r0,r0
80006be2:	0c 44       	or	r4,r6
80006be4:	80 00       	ld.sh	r0,r0[0x0]
80006be6:	65 58       	ld.w	r8,r2[0x54]
80006be8:	80 00       	ld.sh	r0,r0[0x0]
80006bea:	69 14       	ld.w	r4,r4[0x44]
80006bec:	80 00       	ld.sh	r0,r0[0x0]
80006bee:	5d cc       	*unknown*
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	5d 12       	icall	r2
80006bf4:	80 00       	ld.sh	r0,r0[0x0]
80006bf6:	5e d8       	retvc	r8
80006bf8:	80 00       	ld.sh	r0,r0[0x0]
80006bfa:	60 10       	ld.w	r0,r0[0x4]
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	20 2c       	sub	r12,2

80006c00 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006c00:	d4 31       	pushm	r0-r7,lr
80006c02:	20 1d       	sub	sp,4
80006c04:	fa c4 ff d8 	sub	r4,sp,-40
80006c08:	50 0c       	stdsp	sp[0x0],r12
80006c0a:	16 91       	mov	r1,r11
80006c0c:	14 97       	mov	r7,r10
80006c0e:	12 90       	mov	r0,r9
80006c10:	10 93       	mov	r3,r8
80006c12:	68 02       	ld.w	r2,r4[0x0]
80006c14:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006c16:	34 8c       	mov	r12,72
80006c18:	f0 1f 00 5c 	mcall	80006d88 <xTaskGenericCreate+0x188>
80006c1c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006c1e:	c0 31       	brne	80006c24 <xTaskGenericCreate+0x24>
80006c20:	3f fc       	mov	r12,-1
80006c22:	ca f8       	rjmp	80006d80 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006c24:	58 06       	cp.w	r6,0
80006c26:	e0 81 00 af 	brne	80006d84 <xTaskGenericCreate+0x184>
80006c2a:	0e 9c       	mov	r12,r7
80006c2c:	5c 7c       	castu.h	r12
80006c2e:	a3 6c       	lsl	r12,0x2
80006c30:	f0 1f 00 56 	mcall	80006d88 <xTaskGenericCreate+0x188>
80006c34:	18 96       	mov	r6,r12
80006c36:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006c38:	c0 61       	brne	80006c44 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006c3a:	0a 9c       	mov	r12,r5
80006c3c:	f0 1f 00 54 	mcall	80006d8c <xTaskGenericCreate+0x18c>
80006c40:	3f fc       	mov	r12,-1
80006c42:	c9 f8       	rjmp	80006d80 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006c44:	5c 77       	castu.h	r7
80006c46:	ee 0a 15 02 	lsl	r10,r7,0x2
80006c4a:	e0 6b 00 a5 	mov	r11,165
80006c4e:	0c 9c       	mov	r12,r6
80006c50:	f0 1f 00 50 	mcall	80006d90 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006c54:	ee c6 00 01 	sub	r6,r7,1
80006c58:	6a c8       	ld.w	r8,r5[0x30]
80006c5a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006c5e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006c62:	31 0a       	mov	r10,16
80006c64:	02 9b       	mov	r11,r1
80006c66:	ea cc ff cc 	sub	r12,r5,-52
80006c6a:	f0 1f 00 4b 	mcall	80006d94 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006c6e:	30 08       	mov	r8,0
80006c70:	eb 68 00 43 	st.b	r5[67],r8
80006c74:	58 73       	cp.w	r3,7
80006c76:	e6 07 17 80 	movls	r7,r3
80006c7a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006c7e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006c80:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006c84:	ea c4 ff fc 	sub	r4,r5,-4
80006c88:	08 9c       	mov	r12,r4
80006c8a:	f0 1f 00 44 	mcall	80006d98 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006c8e:	ea cc ff e8 	sub	r12,r5,-24
80006c92:	f0 1f 00 42 	mcall	80006d98 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006c96:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006c98:	ee 07 11 08 	rsub	r7,r7,8
80006c9c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006c9e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006ca0:	00 9a       	mov	r10,r0
80006ca2:	40 0b       	lddsp	r11,sp[0x0]
80006ca4:	0c 9c       	mov	r12,r6
80006ca6:	f0 1f 00 3e 	mcall	80006d9c <xTaskGenericCreate+0x19c>
80006caa:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006cac:	58 02       	cp.w	r2,0
80006cae:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006cb2:	f0 1f 00 3c 	mcall	80006da0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006cb6:	4b c8       	lddpc	r8,80006da4 <xTaskGenericCreate+0x1a4>
80006cb8:	70 09       	ld.w	r9,r8[0x0]
80006cba:	2f f9       	sub	r9,-1
80006cbc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006cbe:	4b b8       	lddpc	r8,80006da8 <xTaskGenericCreate+0x1a8>
80006cc0:	70 08       	ld.w	r8,r8[0x0]
80006cc2:	58 08       	cp.w	r8,0
80006cc4:	c2 61       	brne	80006d10 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006cc6:	4b 98       	lddpc	r8,80006da8 <xTaskGenericCreate+0x1a8>
80006cc8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006cca:	4b 78       	lddpc	r8,80006da4 <xTaskGenericCreate+0x1a4>
80006ccc:	70 08       	ld.w	r8,r8[0x0]
80006cce:	58 18       	cp.w	r8,1
80006cd0:	c2 b1       	brne	80006d26 <xTaskGenericCreate+0x126>
80006cd2:	4b 77       	lddpc	r7,80006dac <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006cd4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006cd8:	0e 9c       	mov	r12,r7
80006cda:	f0 1f 00 36 	mcall	80006db0 <xTaskGenericCreate+0x1b0>
80006cde:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006ce0:	0c 37       	cp.w	r7,r6
80006ce2:	cf b1       	brne	80006cd8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006ce4:	4b 47       	lddpc	r7,80006db4 <xTaskGenericCreate+0x1b4>
80006ce6:	0e 9c       	mov	r12,r7
80006ce8:	f0 1f 00 32 	mcall	80006db0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006cec:	4b 36       	lddpc	r6,80006db8 <xTaskGenericCreate+0x1b8>
80006cee:	0c 9c       	mov	r12,r6
80006cf0:	f0 1f 00 30 	mcall	80006db0 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006cf4:	4b 2c       	lddpc	r12,80006dbc <xTaskGenericCreate+0x1bc>
80006cf6:	f0 1f 00 2f 	mcall	80006db0 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006cfa:	4b 2c       	lddpc	r12,80006dc0 <xTaskGenericCreate+0x1c0>
80006cfc:	f0 1f 00 2d 	mcall	80006db0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006d00:	4b 1c       	lddpc	r12,80006dc4 <xTaskGenericCreate+0x1c4>
80006d02:	f0 1f 00 2c 	mcall	80006db0 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006d06:	4b 18       	lddpc	r8,80006dc8 <xTaskGenericCreate+0x1c8>
80006d08:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006d0a:	4b 18       	lddpc	r8,80006dcc <xTaskGenericCreate+0x1cc>
80006d0c:	91 06       	st.w	r8[0x0],r6
80006d0e:	c0 c8       	rjmp	80006d26 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006d10:	4b 08       	lddpc	r8,80006dd0 <xTaskGenericCreate+0x1d0>
80006d12:	70 08       	ld.w	r8,r8[0x0]
80006d14:	58 08       	cp.w	r8,0
80006d16:	c0 81       	brne	80006d26 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006d18:	4a 48       	lddpc	r8,80006da8 <xTaskGenericCreate+0x1a8>
80006d1a:	70 08       	ld.w	r8,r8[0x0]
80006d1c:	70 b8       	ld.w	r8,r8[0x2c]
80006d1e:	10 33       	cp.w	r3,r8
80006d20:	c0 33       	brcs	80006d26 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006d22:	4a 28       	lddpc	r8,80006da8 <xTaskGenericCreate+0x1a8>
80006d24:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006d26:	6a b8       	ld.w	r8,r5[0x2c]
80006d28:	4a b9       	lddpc	r9,80006dd4 <xTaskGenericCreate+0x1d4>
80006d2a:	72 09       	ld.w	r9,r9[0x0]
80006d2c:	12 38       	cp.w	r8,r9
80006d2e:	e0 88 00 04 	brls	80006d36 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006d32:	4a 99       	lddpc	r9,80006dd4 <xTaskGenericCreate+0x1d4>
80006d34:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006d36:	4a 98       	lddpc	r8,80006dd8 <xTaskGenericCreate+0x1d8>
80006d38:	70 09       	ld.w	r9,r8[0x0]
80006d3a:	2f f9       	sub	r9,-1
80006d3c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006d3e:	6a b8       	ld.w	r8,r5[0x2c]
80006d40:	4a 79       	lddpc	r9,80006ddc <xTaskGenericCreate+0x1dc>
80006d42:	72 09       	ld.w	r9,r9[0x0]
80006d44:	12 38       	cp.w	r8,r9
80006d46:	e0 88 00 04 	brls	80006d4e <xTaskGenericCreate+0x14e>
80006d4a:	4a 59       	lddpc	r9,80006ddc <xTaskGenericCreate+0x1dc>
80006d4c:	93 08       	st.w	r9[0x0],r8
80006d4e:	6a bc       	ld.w	r12,r5[0x2c]
80006d50:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006d54:	08 9b       	mov	r11,r4
80006d56:	49 68       	lddpc	r8,80006dac <xTaskGenericCreate+0x1ac>
80006d58:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006d5c:	f0 1f 00 21 	mcall	80006de0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006d60:	f0 1f 00 21 	mcall	80006de4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006d64:	49 b8       	lddpc	r8,80006dd0 <xTaskGenericCreate+0x1d0>
80006d66:	70 08       	ld.w	r8,r8[0x0]
80006d68:	58 08       	cp.w	r8,0
80006d6a:	c0 a0       	breq	80006d7e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006d6c:	48 f8       	lddpc	r8,80006da8 <xTaskGenericCreate+0x1a8>
80006d6e:	70 08       	ld.w	r8,r8[0x0]
80006d70:	70 b8       	ld.w	r8,r8[0x2c]
80006d72:	10 33       	cp.w	r3,r8
80006d74:	e0 88 00 05 	brls	80006d7e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006d78:	d7 33       	scall
80006d7a:	30 1c       	mov	r12,1
80006d7c:	c0 28       	rjmp	80006d80 <xTaskGenericCreate+0x180>
80006d7e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006d80:	2f fd       	sub	sp,-4
80006d82:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006d84:	99 c6       	st.w	r12[0x30],r6
80006d86:	c5 fb       	rjmp	80006c44 <xTaskGenericCreate+0x44>
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	60 38       	ld.w	r8,r0[0xc]
80006d8c:	80 00       	ld.sh	r0,r0[0x0]
80006d8e:	60 10       	ld.w	r0,r0[0x4]
80006d90:	80 00       	ld.sh	r0,r0[0x0]
80006d92:	79 88       	ld.w	r8,r12[0x60]
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	7c b4       	ld.w	r4,lr[0x2c]
80006d98:	80 00       	ld.sh	r0,r0[0x0]
80006d9a:	5c bc       	swap.b	r12
80006d9c:	80 00       	ld.sh	r0,r0[0x0]
80006d9e:	5d 38       	musfr	r8
80006da0:	80 00       	ld.sh	r0,r0[0x0]
80006da2:	5d cc       	*unknown*
80006da4:	00 00       	add	r0,r0
80006da6:	0d 44       	ld.w	r4,--r6
80006da8:	00 00       	add	r0,r0
80006daa:	0c f8       	st.b	--r6,r8
80006dac:	00 00       	add	r0,r0
80006dae:	0c 44       	or	r4,r6
80006db0:	80 00       	ld.sh	r0,r0[0x0]
80006db2:	5c a8       	swap.h	r8
80006db4:	00 00       	add	r0,r0
80006db6:	0d 10       	ld.sh	r0,r6++
80006db8:	00 00       	add	r0,r0
80006dba:	0d 2c       	ld.uh	r12,r6++
80006dbc:	00 00       	add	r0,r0
80006dbe:	0c fc       	st.b	--r6,r12
80006dc0:	00 00       	add	r0,r0
80006dc2:	0c e4       	st.h	--r6,r4
80006dc4:	00 00       	add	r0,r0
80006dc6:	0d 4c       	ld.w	r12,--r6
80006dc8:	00 00       	add	r0,r0
80006dca:	0c 30       	cp.w	r0,r6
80006dcc:	00 00       	add	r0,r0
80006dce:	0c 40       	or	r0,r6
80006dd0:	00 00       	add	r0,r0
80006dd2:	0c 34       	cp.w	r4,r6
80006dd4:	00 00       	add	r0,r0
80006dd6:	0c 2c       	rsub	r12,r6
80006dd8:	00 00       	add	r0,r0
80006dda:	0d 40       	ld.w	r0,--r6
80006ddc:	00 00       	add	r0,r0
80006dde:	0d 60       	ld.uh	r0,--r6
80006de0:	80 00       	ld.sh	r0,r0[0x0]
80006de2:	5c c2       	swap.bh	r2
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	5e d8       	retvc	r8

80006de8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006de8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006dea:	30 09       	mov	r9,0
80006dec:	1a d9       	st.w	--sp,r9
80006dee:	1a d9       	st.w	--sp,r9
80006df0:	1a d9       	st.w	--sp,r9
80006df2:	12 98       	mov	r8,r9
80006df4:	e0 6a 01 00 	mov	r10,256
80006df8:	48 9b       	lddpc	r11,80006e1c <vTaskStartScheduler+0x34>
80006dfa:	48 ac       	lddpc	r12,80006e20 <vTaskStartScheduler+0x38>
80006dfc:	f0 1f 00 0a 	mcall	80006e24 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006e00:	2f dd       	sub	sp,-12
80006e02:	58 1c       	cp.w	r12,1
80006e04:	c0 a1       	brne	80006e18 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006e06:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006e08:	30 19       	mov	r9,1
80006e0a:	48 88       	lddpc	r8,80006e28 <vTaskStartScheduler+0x40>
80006e0c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006e0e:	30 09       	mov	r9,0
80006e10:	48 78       	lddpc	r8,80006e2c <vTaskStartScheduler+0x44>
80006e12:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006e14:	f0 1f 00 07 	mcall	80006e30 <vTaskStartScheduler+0x48>
80006e18:	d8 02       	popm	pc
80006e1a:	00 00       	add	r0,r0
80006e1c:	80 00       	ld.sh	r0,r0[0x0]
80006e1e:	da 0c       	*unknown*
80006e20:	80 00       	ld.sh	r0,r0[0x0]
80006e22:	6b 78       	ld.w	r8,r5[0x5c]
80006e24:	80 00       	ld.sh	r0,r0[0x0]
80006e26:	6c 00       	ld.w	r0,r6[0x0]
80006e28:	00 00       	add	r0,r0
80006e2a:	0c 34       	cp.w	r4,r6
80006e2c:	00 00       	add	r0,r0
80006e2e:	0d 24       	ld.uh	r4,r6++
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	5d dc       	*unknown*

80006e34 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006e34:	16 cc       	st.b	r11++,r12
	return str;
}
80006e36:	5e fb       	retal	r11

80006e38 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006e38:	eb cd 40 c0 	pushm	r6-r7,lr
80006e3c:	20 3d       	sub	sp,12
80006e3e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006e40:	30 06       	mov	r6,0
80006e42:	30 07       	mov	r7,0
80006e44:	fa e7 00 00 	st.d	sp[0],r6
80006e48:	30 0c       	mov	r12,0
80006e4a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006e4c:	58 08       	cp.w	r8,0
80006e4e:	c1 30       	breq	80006e74 <PrintHex+0x3c>
80006e50:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006e52:	1a 9c       	mov	r12,sp
80006e54:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e58:	58 9e       	cp.w	lr,9
80006e5a:	e0 8a 00 04 	brle	80006e62 <PrintHex+0x2a>
80006e5e:	2c 9e       	sub	lr,-55
80006e60:	c0 48       	rjmp	80006e68 <PrintHex+0x30>
80006e62:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e66:	2d 0e       	sub	lr,-48
80006e68:	f8 09 0b 0e 	st.b	r12[r9],lr
80006e6c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006e6e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006e70:	cf 21       	brne	80006e54 <PrintHex+0x1c>
80006e72:	c0 48       	rjmp	80006e7a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006e74:	33 08       	mov	r8,48
80006e76:	ba 88       	st.b	sp[0x0],r8
80006e78:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006e7a:	f6 09 01 08 	sub	r8,r11,r9
80006e7e:	58 08       	cp.w	r8,0
80006e80:	e0 8a 00 13 	brle	80006ea6 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006e84:	12 1b       	sub	r11,r9
80006e86:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006e8a:	18 9e       	mov	lr,r12
80006e8c:	58 0c       	cp.w	r12,0
80006e8e:	e0 8a 00 0c 	brle	80006ea6 <PrintHex+0x6e>
80006e92:	1a 9b       	mov	r11,sp
80006e94:	12 0b       	add	r11,r9
80006e96:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006e98:	33 07       	mov	r7,48
80006e9a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006e9c:	2f f8       	sub	r8,-1
80006e9e:	1c 38       	cp.w	r8,lr
80006ea0:	cf d5       	brlt	80006e9a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ea2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ea6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006eaa:	f0 cb ff ff 	sub	r11,r8,-1
80006eae:	58 0b       	cp.w	r11,0
80006eb0:	e0 8a 00 19 	brle	80006ee2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006eb4:	fa cb ff f4 	sub	r11,sp,-12
80006eb8:	f6 09 00 09 	add	r9,r11,r9
80006ebc:	37 8b       	mov	r11,120
80006ebe:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006ec2:	fa c9 ff f4 	sub	r9,sp,-12
80006ec6:	10 09       	add	r9,r8
80006ec8:	33 0b       	mov	r11,48
80006eca:	f3 6b ff f4 	st.b	r9[-12],r11
80006ece:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006ed2:	fa ce 00 01 	sub	lr,sp,1
80006ed6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006ed8:	11 8b       	ld.ub	r11,r8[0x0]
80006eda:	12 cb       	st.b	r9++,r11
80006edc:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006ede:	1c 38       	cp.w	r8,lr
80006ee0:	cf c1       	brne	80006ed8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006ee2:	14 9c       	mov	r12,r10
80006ee4:	2f dd       	sub	sp,-12
80006ee6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006eea <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006eea:	d4 21       	pushm	r4-r7,lr
80006eec:	20 3d       	sub	sp,12
80006eee:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006ef0:	30 06       	mov	r6,0
80006ef2:	30 07       	mov	r7,0
80006ef4:	fa e7 00 00 	st.d	sp[0],r6
80006ef8:	30 0c       	mov	r12,0
80006efa:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006efc:	58 08       	cp.w	r8,0
80006efe:	c0 35       	brlt	80006f04 <PrintDec+0x1a>
80006f00:	14 97       	mov	r7,r10
80006f02:	c0 58       	rjmp	80006f0c <PrintDec+0x22>
	{
		*p++ = '-';
80006f04:	14 97       	mov	r7,r10
80006f06:	32 d9       	mov	r9,45
80006f08:	0e c9       	st.b	r7++,r9
		i = -i;
80006f0a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006f0c:	58 08       	cp.w	r8,0
80006f0e:	c0 51       	brne	80006f18 <PrintDec+0x2e>
80006f10:	33 08       	mov	r8,48
80006f12:	ba 88       	st.b	sp[0x0],r8
80006f14:	30 1e       	mov	lr,1
80006f16:	c2 f8       	rjmp	80006f74 <PrintDec+0x8a>
	
	int ten = i%10;
80006f18:	e0 65 66 67 	mov	r5,26215
80006f1c:	ea 15 66 66 	orh	r5,0x6666
80006f20:	f0 05 04 44 	muls.d	r4,r8,r5
80006f24:	ea 0c 14 02 	asr	r12,r5,0x2
80006f28:	f0 09 14 1f 	asr	r9,r8,0x1f
80006f2c:	f8 09 01 09 	sub	r9,r12,r9
80006f30:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f34:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006f38:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006f3a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006f3c:	e0 66 66 67 	mov	r6,26215
80006f40:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006f44:	2d 09       	sub	r9,-48
80006f46:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006f4a:	2f fe       	sub	lr,-1
		i /= 10;
80006f4c:	f0 06 04 44 	muls.d	r4,r8,r6
80006f50:	ea 09 14 02 	asr	r9,r5,0x2
80006f54:	bf 58       	asr	r8,0x1f
80006f56:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006f5a:	f0 06 04 44 	muls.d	r4,r8,r6
80006f5e:	ea 09 14 02 	asr	r9,r5,0x2
80006f62:	f0 05 14 1f 	asr	r5,r8,0x1f
80006f66:	0a 19       	sub	r9,r5
80006f68:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f6c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006f70:	58 08       	cp.w	r8,0
80006f72:	ce 91       	brne	80006f44 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006f74:	f6 0e 01 08 	sub	r8,r11,lr
80006f78:	58 08       	cp.w	r8,0
80006f7a:	e0 89 00 06 	brgt	80006f86 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f7e:	58 0e       	cp.w	lr,0
80006f80:	e0 89 00 14 	brgt	80006fa8 <PrintDec+0xbe>
80006f84:	c1 d8       	rjmp	80006fbe <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006f86:	1c 1b       	sub	r11,lr
80006f88:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006f8a:	16 9c       	mov	r12,r11
80006f8c:	58 0b       	cp.w	r11,0
80006f8e:	fe 9a ff f8 	brle	80006f7e <PrintDec+0x94>
80006f92:	1a 99       	mov	r9,sp
80006f94:	1c 09       	add	r9,lr
80006f96:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006f98:	33 06       	mov	r6,48
80006f9a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006f9c:	2f f8       	sub	r8,-1
80006f9e:	18 38       	cp.w	r8,r12
80006fa0:	cf d5       	brlt	80006f9a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006fa2:	f6 0e 00 0e 	add	lr,r11,lr
80006fa6:	ce cb       	rjmp	80006f7e <PrintDec+0x94>
80006fa8:	fa c8 ff f4 	sub	r8,sp,-12
80006fac:	1c 08       	add	r8,lr
80006fae:	20 d8       	sub	r8,13
80006fb0:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006fb4:	11 89       	ld.ub	r9,r8[0x0]
80006fb6:	0e c9       	st.b	r7++,r9
80006fb8:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006fba:	16 38       	cp.w	r8,r11
80006fbc:	cf c1       	brne	80006fb4 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006fbe:	14 9c       	mov	r12,r10
80006fc0:	2f dd       	sub	sp,-12
80006fc2:	d8 22       	popm	r4-r7,pc

80006fc4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006fc4:	d4 31       	pushm	r0-r7,lr
80006fc6:	fa cd 02 08 	sub	sp,sp,520
80006fca:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006fcc:	e0 6a 01 00 	mov	r10,256
80006fd0:	30 0b       	mov	r11,0
80006fd2:	fa cc fe f8 	sub	r12,sp,-264
80006fd6:	f0 1f 00 4e 	mcall	8000710c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006fda:	fa c4 fd d4 	sub	r4,sp,-556
80006fde:	30 0a       	mov	r10,0
80006fe0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fe2:	fa c3 ff fc 	sub	r3,sp,-4
80006fe6:	e0 61 01 00 	mov	r1,256
80006fea:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006fec:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fee:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006ff2:	02 9a       	mov	r10,r1
80006ff4:	00 9b       	mov	r11,r0
80006ff6:	06 9c       	mov	r12,r3
80006ff8:	f0 1f 00 45 	mcall	8000710c <log+0x148>
			
					if(*str == '%')
80006ffc:	0f 88       	ld.ub	r8,r7[0x0]
80006ffe:	e4 08 18 00 	cp.b	r8,r2
80007002:	c5 71       	brne	800070b0 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007004:	ee c8 ff ff 	sub	r8,r7,-1
80007008:	11 89       	ld.ub	r9,r8[0x0]
8000700a:	4c 2a       	lddpc	r10,80007110 <log+0x14c>
8000700c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000700e:	23 09       	sub	r9,48
80007010:	30 9a       	mov	r10,9
80007012:	f4 09 18 00 	cp.b	r9,r10
80007016:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000701a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000701e:	f7 b9 08 30 	subls	r9,48
80007022:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007026:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000702a:	0f 88       	ld.ub	r8,r7[0x0]
8000702c:	22 58       	sub	r8,37
8000702e:	e0 48 00 53 	cp.w	r8,83
80007032:	e0 8b 00 31 	brhi	80007094 <log+0xd0>
80007036:	4b 89       	lddpc	r9,80007114 <log+0x150>
80007038:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000703c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007040:	06 9a       	mov	r10,r3
80007042:	40 0b       	lddsp	r11,sp[0x0]
80007044:	5c 5b       	castu.b	r11
80007046:	68 0c       	ld.w	r12,r4[0x0]
80007048:	f0 1f 00 34 	mcall	80007118 <log+0x154>
							break;
8000704c:	c2 98       	rjmp	8000709e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000704e:	4b 4c       	lddpc	r12,8000711c <log+0x158>
80007050:	f0 1f 00 34 	mcall	80007120 <log+0x15c>
80007054:	08 95       	mov	r5,r4
80007056:	06 9c       	mov	r12,r3
							break;
80007058:	c2 38       	rjmp	8000709e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000705a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000705e:	06 9a       	mov	r10,r3
80007060:	40 0b       	lddsp	r11,sp[0x0]
80007062:	5c 5b       	castu.b	r11
80007064:	68 0c       	ld.w	r12,r4[0x0]
80007066:	f0 1f 00 30 	mcall	80007124 <log+0x160>
8000706a:	06 9c       	mov	r12,r3
							break;
8000706c:	c1 98       	rjmp	8000709e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000706e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80007072:	06 9b       	mov	r11,r3
80007074:	09 bc       	ld.ub	r12,r4[0x3]
80007076:	f0 1f 00 2d 	mcall	80007128 <log+0x164>
8000707a:	06 9c       	mov	r12,r3
							break;
8000707c:	c1 18       	rjmp	8000709e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000707e:	e8 c5 ff fc 	sub	r5,r4,-4
80007082:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007084:	c0 d8       	rjmp	8000709e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007086:	06 9b       	mov	r11,r3
80007088:	32 5c       	mov	r12,37
8000708a:	f0 1f 00 28 	mcall	80007128 <log+0x164>
8000708e:	08 95       	mov	r5,r4
80007090:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80007092:	c0 68       	rjmp	8000709e <log+0xda>
							
							default:
							log("I need relax.");
80007094:	4a 6c       	lddpc	r12,8000712c <log+0x168>
80007096:	f0 1f 00 23 	mcall	80007120 <log+0x15c>
8000709a:	08 95       	mov	r5,r4
8000709c:	06 9c       	mov	r12,r3
						}
						str++;
8000709e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800070a0:	1a dc       	st.w	--sp,r12
800070a2:	1a d6       	st.w	--sp,r6
800070a4:	4a 3b       	lddpc	r11,80007130 <log+0x16c>
800070a6:	0c 9c       	mov	r12,r6
800070a8:	f0 1f 00 23 	mcall	80007134 <log+0x170>
800070ac:	2f ed       	sub	sp,-8
800070ae:	c0 a8       	rjmp	800070c2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800070b0:	2f f7       	sub	r7,-1
800070b2:	1a d8       	st.w	--sp,r8
800070b4:	1a d6       	st.w	--sp,r6
800070b6:	4a 1b       	lddpc	r11,80007138 <log+0x174>
800070b8:	0c 9c       	mov	r12,r6
800070ba:	f0 1f 00 1f 	mcall	80007134 <log+0x170>
800070be:	08 95       	mov	r5,r4
800070c0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800070c2:	0f 89       	ld.ub	r9,r7[0x0]
800070c4:	30 08       	mov	r8,0
800070c6:	f0 09 18 00 	cp.b	r9,r8
800070ca:	c0 30       	breq	800070d0 <log+0x10c>
800070cc:	0a 94       	mov	r4,r5
800070ce:	c9 2b       	rjmp	80006ff2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800070d0:	fa c7 fe f8 	sub	r7,sp,-264
800070d4:	1a d7       	st.w	--sp,r7
800070d6:	49 ab       	lddpc	r11,8000713c <log+0x178>
800070d8:	0e 9c       	mov	r12,r7
800070da:	f0 1f 00 17 	mcall	80007134 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800070de:	5c 5c       	castu.b	r12
800070e0:	f8 c6 ff ff 	sub	r6,r12,-1
800070e4:	0c 9c       	mov	r12,r6
800070e6:	f0 1f 00 17 	mcall	80007140 <log+0x17c>
800070ea:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800070ec:	0c 9a       	mov	r10,r6
800070ee:	0e 9b       	mov	r11,r7
800070f0:	f0 1f 00 15 	mcall	80007144 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800070f4:	30 09       	mov	r9,0
800070f6:	30 5a       	mov	r10,5
800070f8:	fa cb fe f8 	sub	r11,sp,-264
800070fc:	49 38       	lddpc	r8,80007148 <log+0x184>
800070fe:	70 0c       	ld.w	r12,r8[0x0]
80007100:	f0 1f 00 13 	mcall	8000714c <log+0x188>
80007104:	2f fd       	sub	sp,-4
	
	
}
80007106:	fe 3d fd f8 	sub	sp,-520
8000710a:	d8 32       	popm	r0-r7,pc
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	79 88       	ld.w	r8,r12[0x60]
80007110:	00 00       	add	r0,r0
80007112:	0d 64       	ld.uh	r4,--r6
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	da 14       	*unknown*
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	6e ea       	ld.w	r10,r7[0x38]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	dc c0       	acall	0xcc
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	6f c4       	ld.w	r4,r7[0x70]
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	6e 38       	ld.w	r8,r7[0xc]
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	6e 34       	ld.w	r4,r7[0xc]
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	dc d0       	acall	0xcd
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	dc e0       	acall	0xce
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	7c 78       	ld.w	r8,lr[0x1c]
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	dc e8       	*unknown*
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	dc f0       	acall	0xcf
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	60 38       	ld.w	r8,r0[0xc]
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	78 40       	ld.w	r0,r12[0x10]
80007148:	00 00       	add	r0,r0
8000714a:	bf e8       	*unknown*
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	63 8c       	ld.w	r12,r1[0x60]

80007150 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80007150:	d4 31       	pushm	r0-r7,lr
80007152:	fa cd 02 0c 	sub	sp,sp,524
80007156:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007158:	e0 6a 01 00 	mov	r10,256
8000715c:	30 0b       	mov	r11,0
8000715e:	fa cc fe f4 	sub	r12,sp,-268
80007162:	f0 1f 00 4c 	mcall	80007290 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007166:	fa c4 fd d0 	sub	r4,sp,-560
8000716a:	30 0a       	mov	r10,0
8000716c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000716e:	fa c3 ff fc 	sub	r3,sp,-4
80007172:	e0 61 01 00 	mov	r1,256
80007176:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007178:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000717a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000717e:	02 9a       	mov	r10,r1
80007180:	00 9b       	mov	r11,r0
80007182:	06 9c       	mov	r12,r3
80007184:	f0 1f 00 43 	mcall	80007290 <logFromISR+0x140>
			
			if(*str == '%')
80007188:	0f 88       	ld.ub	r8,r7[0x0]
8000718a:	e4 08 18 00 	cp.b	r8,r2
8000718e:	c5 11       	brne	80007230 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007190:	ee c8 ff ff 	sub	r8,r7,-1
80007194:	11 89       	ld.ub	r9,r8[0x0]
80007196:	4c 0a       	lddpc	r10,80007294 <logFromISR+0x144>
80007198:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000719a:	23 09       	sub	r9,48
8000719c:	30 9a       	mov	r10,9
8000719e:	f4 09 18 00 	cp.b	r9,r10
800071a2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800071a6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800071aa:	f7 b9 08 30 	subls	r9,48
800071ae:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800071b2:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800071b6:	0f 88       	ld.ub	r8,r7[0x0]
800071b8:	22 58       	sub	r8,37
800071ba:	e0 48 00 53 	cp.w	r8,83
800071be:	e0 8b 00 2b 	brhi	80007214 <logFromISR+0xc4>
800071c2:	4b 69       	lddpc	r9,80007298 <logFromISR+0x148>
800071c4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800071c8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800071cc:	06 9a       	mov	r10,r3
800071ce:	40 0b       	lddsp	r11,sp[0x0]
800071d0:	5c 5b       	castu.b	r11
800071d2:	68 0c       	ld.w	r12,r4[0x0]
800071d4:	f0 1f 00 32 	mcall	8000729c <logFromISR+0x14c>
					break;
800071d8:	c2 38       	rjmp	8000721e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800071da:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800071de:	06 9a       	mov	r10,r3
800071e0:	40 0b       	lddsp	r11,sp[0x0]
800071e2:	5c 5b       	castu.b	r11
800071e4:	68 0c       	ld.w	r12,r4[0x0]
800071e6:	f0 1f 00 2f 	mcall	800072a0 <logFromISR+0x150>
800071ea:	06 9c       	mov	r12,r3
					break;
800071ec:	c1 98       	rjmp	8000721e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800071ee:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800071f2:	06 9b       	mov	r11,r3
800071f4:	09 bc       	ld.ub	r12,r4[0x3]
800071f6:	f0 1f 00 2c 	mcall	800072a4 <logFromISR+0x154>
800071fa:	06 9c       	mov	r12,r3
					break;
800071fc:	c1 18       	rjmp	8000721e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800071fe:	e8 c5 ff fc 	sub	r5,r4,-4
80007202:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007204:	c0 d8       	rjmp	8000721e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007206:	06 9b       	mov	r11,r3
80007208:	32 5c       	mov	r12,37
8000720a:	f0 1f 00 27 	mcall	800072a4 <logFromISR+0x154>
8000720e:	08 95       	mov	r5,r4
80007210:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007212:	c0 68       	rjmp	8000721e <logFromISR+0xce>
					default:
					log("I need relax.");
80007214:	4a 5c       	lddpc	r12,800072a8 <logFromISR+0x158>
80007216:	f0 1f 00 26 	mcall	800072ac <logFromISR+0x15c>
8000721a:	08 95       	mov	r5,r4
8000721c:	06 9c       	mov	r12,r3
				}
				str++;
8000721e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007220:	1a dc       	st.w	--sp,r12
80007222:	1a d6       	st.w	--sp,r6
80007224:	4a 3b       	lddpc	r11,800072b0 <logFromISR+0x160>
80007226:	0c 9c       	mov	r12,r6
80007228:	f0 1f 00 23 	mcall	800072b4 <logFromISR+0x164>
8000722c:	2f ed       	sub	sp,-8
8000722e:	c0 a8       	rjmp	80007242 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007230:	2f f7       	sub	r7,-1
80007232:	1a d8       	st.w	--sp,r8
80007234:	1a d6       	st.w	--sp,r6
80007236:	4a 1b       	lddpc	r11,800072b8 <logFromISR+0x168>
80007238:	0c 9c       	mov	r12,r6
8000723a:	f0 1f 00 1f 	mcall	800072b4 <logFromISR+0x164>
8000723e:	08 95       	mov	r5,r4
80007240:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80007242:	0f 89       	ld.ub	r9,r7[0x0]
80007244:	30 08       	mov	r8,0
80007246:	f0 09 18 00 	cp.b	r9,r8
8000724a:	c0 30       	breq	80007250 <logFromISR+0x100>
8000724c:	0a 94       	mov	r4,r5
8000724e:	c9 8b       	rjmp	8000717e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007250:	fa c7 fe f4 	sub	r7,sp,-268
80007254:	1a d7       	st.w	--sp,r7
80007256:	49 ab       	lddpc	r11,800072bc <logFromISR+0x16c>
80007258:	0e 9c       	mov	r12,r7
8000725a:	f0 1f 00 17 	mcall	800072b4 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000725e:	5c 5c       	castu.b	r12
80007260:	f8 c6 ff ff 	sub	r6,r12,-1
80007264:	0c 9c       	mov	r12,r6
80007266:	f0 1f 00 17 	mcall	800072c0 <logFromISR+0x170>
8000726a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000726c:	0c 9a       	mov	r10,r6
8000726e:	0e 9b       	mov	r11,r7
80007270:	f0 1f 00 15 	mcall	800072c4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007274:	30 09       	mov	r9,0
80007276:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007278:	fa ca fe f8 	sub	r10,sp,-264
8000727c:	fa cb fe f4 	sub	r11,sp,-268
80007280:	49 28       	lddpc	r8,800072c8 <logFromISR+0x178>
80007282:	70 0c       	ld.w	r12,r8[0x0]
80007284:	f0 1f 00 12 	mcall	800072cc <logFromISR+0x17c>
80007288:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000728a:	fe 3d fd f4 	sub	sp,-524
8000728e:	d8 32       	popm	r0-r7,pc
80007290:	80 00       	ld.sh	r0,r0[0x0]
80007292:	79 88       	ld.w	r8,r12[0x60]
80007294:	00 00       	add	r0,r0
80007296:	0d 65       	ld.uh	r5,--r6
80007298:	80 00       	ld.sh	r0,r0[0x0]
8000729a:	db 64       	*unknown*
8000729c:	80 00       	ld.sh	r0,r0[0x0]
8000729e:	6e ea       	ld.w	r10,r7[0x38]
800072a0:	80 00       	ld.sh	r0,r0[0x0]
800072a2:	6e 38       	ld.w	r8,r7[0xc]
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	6e 34       	ld.w	r4,r7[0xc]
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	dc d0       	acall	0xcd
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	6f c4       	ld.w	r4,r7[0x70]
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	dc e0       	acall	0xce
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	7c 78       	ld.w	r8,lr[0x1c]
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	dc e8       	*unknown*
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	dc f0       	acall	0xcf
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	60 38       	ld.w	r8,r0[0xc]
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	78 40       	ld.w	r0,r12[0x10]
800072c8:	00 00       	add	r0,r0
800072ca:	bf e8       	*unknown*
800072cc:	80 00       	ld.sh	r0,r0[0x0]
800072ce:	63 3c       	ld.w	r12,r1[0x4c]

800072d0 <log_init>:
		
	return str;
}

void log_init(void)
{
800072d0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800072d2:	30 2b       	mov	r11,2
800072d4:	48 fc       	lddpc	r12,80007310 <log_init+0x40>
800072d6:	f0 1f 00 10 	mcall	80007314 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800072da:	e0 6a 36 00 	mov	r10,13824
800072de:	ea 1a 01 6e 	orh	r10,0x16e
800072e2:	48 eb       	lddpc	r11,80007318 <log_init+0x48>
800072e4:	fe 7c 18 00 	mov	r12,-59392
800072e8:	f0 1f 00 0d 	mcall	8000731c <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800072ec:	30 4b       	mov	r11,4
800072ee:	33 2c       	mov	r12,50
800072f0:	f0 1f 00 0c 	mcall	80007320 <log_init+0x50>
800072f4:	48 c8       	lddpc	r8,80007324 <log_init+0x54>
800072f6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800072f8:	30 09       	mov	r9,0
800072fa:	1a d9       	st.w	--sp,r9
800072fc:	1a d9       	st.w	--sp,r9
800072fe:	1a d9       	st.w	--sp,r9
80007300:	30 28       	mov	r8,2
80007302:	36 4a       	mov	r10,100
80007304:	48 9b       	lddpc	r11,80007328 <log_init+0x58>
80007306:	48 ac       	lddpc	r12,8000732c <log_init+0x5c>
80007308:	f0 1f 00 0a 	mcall	80007330 <log_init+0x60>
8000730c:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000730e:	d8 02       	popm	pc
80007310:	80 00       	ld.sh	r0,r0[0x0]
80007312:	dc fc       	*unknown*
80007314:	80 00       	ld.sh	r0,r0[0x0]
80007316:	55 18       	stdsp	sp[0x144],r8
80007318:	80 00       	ld.sh	r0,r0[0x0]
8000731a:	dc b4       	*unknown*
8000731c:	80 00       	ld.sh	r0,r0[0x0]
8000731e:	5b 9c       	cp.w	r12,-7
80007320:	80 00       	ld.sh	r0,r0[0x0]
80007322:	64 e4       	ld.w	r4,r2[0x38]
80007324:	00 00       	add	r0,r0
80007326:	bf e8       	*unknown*
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	dc f8       	*unknown*
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	73 34       	ld.w	r4,r9[0x4c]
80007330:	80 00       	ld.sh	r0,r0[0x0]
80007332:	6c 00       	ld.w	r0,r6[0x0]

80007334 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007334:	eb cd 40 f8 	pushm	r3-r7,lr
80007338:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000733a:	48 c7       	lddpc	r7,80007368 <task_log+0x34>
8000733c:	30 05       	mov	r5,0
8000733e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007340:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007344:	0a 99       	mov	r9,r5
80007346:	08 9a       	mov	r10,r4
80007348:	1a 9b       	mov	r11,sp
8000734a:	6e 0c       	ld.w	r12,r7[0x0]
8000734c:	f0 1f 00 08 	mcall	8000736c <task_log+0x38>
80007350:	58 1c       	cp.w	r12,1
80007352:	cf 91       	brne	80007344 <task_log+0x10>
		{
			if( NULL != str)
80007354:	40 0b       	lddsp	r11,sp[0x0]
80007356:	58 0b       	cp.w	r11,0
80007358:	cf 60       	breq	80007344 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000735a:	06 9c       	mov	r12,r3
8000735c:	f0 1f 00 05 	mcall	80007370 <task_log+0x3c>
				vPortFree(str);
80007360:	40 0c       	lddsp	r12,sp[0x0]
80007362:	f0 1f 00 05 	mcall	80007374 <task_log+0x40>
80007366:	ce fb       	rjmp	80007344 <task_log+0x10>
80007368:	00 00       	add	r0,r0
8000736a:	bf e8       	*unknown*
8000736c:	80 00       	ld.sh	r0,r0[0x0]
8000736e:	61 80       	ld.w	r0,r0[0x60]
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	5b 4c       	cp.w	r12,-12
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	60 10       	ld.w	r0,r0[0x4]

80007378 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007378:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000737a:	fe 78 10 00 	mov	r8,-61440
8000737e:	30 19       	mov	r9,1
80007380:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007384:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007388:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
8000738c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000738e:	f0 1f 00 0c 	mcall	800073bc <main+0x44>
		
	INTC_init_interrupts();
80007392:	f0 1f 00 0c 	mcall	800073c0 <main+0x48>
		
	log_init();
80007396:	f0 1f 00 0c 	mcall	800073c4 <main+0x4c>
	log("----start debug----");
8000739a:	48 cc       	lddpc	r12,800073c8 <main+0x50>
8000739c:	f0 1f 00 0c 	mcall	800073cc <main+0x54>
	
	xg_flashc_init();
800073a0:	f0 1f 00 0c 	mcall	800073d0 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800073a4:	f0 1f 00 0c 	mcall	800073d4 <main+0x5c>
		
	app_init();
800073a8:	f0 1f 00 0c 	mcall	800073d8 <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
800073ac:	f0 1f 00 0c 	mcall	800073dc <main+0x64>

	local_start_timer();
800073b0:	f0 1f 00 0c 	mcall	800073e0 <main+0x68>
		
	vTaskStartScheduler();
800073b4:	f0 1f 00 0c 	mcall	800073e4 <main+0x6c>
	return 0;
	
}
800073b8:	d8 0a       	popm	pc,r12=0
800073ba:	00 00       	add	r0,r0
800073bc:	80 00       	ld.sh	r0,r0[0x0]
800073be:	53 94       	stdsp	sp[0xe4],r4
800073c0:	80 00       	ld.sh	r0,r0[0x0]
800073c2:	56 1c       	stdsp	sp[0x184],r12
800073c4:	80 00       	ld.sh	r0,r0[0x0]
800073c6:	72 d0       	ld.w	r0,r9[0x34]
800073c8:	80 00       	ld.sh	r0,r0[0x0]
800073ca:	dd 0c       	*unknown*
800073cc:	80 00       	ld.sh	r0,r0[0x0]
800073ce:	6f c4       	ld.w	r4,r7[0x70]
800073d0:	80 00       	ld.sh	r0,r0[0x0]
800073d2:	54 28       	stdsp	sp[0x108],r8
800073d4:	80 00       	ld.sh	r0,r0[0x0]
800073d6:	52 f4       	stdsp	sp[0xbc],r4
800073d8:	80 00       	ld.sh	r0,r0[0x0]
800073da:	27 34       	sub	r4,115
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	40 f8       	lddsp	r8,sp[0x3c]
800073e0:	80 00       	ld.sh	r0,r0[0x0]
800073e2:	53 68       	stdsp	sp[0xd8],r8
800073e4:	80 00       	ld.sh	r0,r0[0x0]
800073e6:	6d e8       	ld.w	r8,r6[0x78]

800073e8 <free>:
800073e8:	d4 01       	pushm	lr
800073ea:	e0 68 0a 3c 	mov	r8,2620
800073ee:	18 9b       	mov	r11,r12
800073f0:	70 0c       	ld.w	r12,r8[0x0]
800073f2:	e0 a0 1e 61 	rcall	8000b0b4 <_free_r>
800073f6:	d8 02       	popm	pc

800073f8 <malloc>:
800073f8:	d4 01       	pushm	lr
800073fa:	e0 68 0a 3c 	mov	r8,2620
800073fe:	18 9b       	mov	r11,r12
80007400:	70 0c       	ld.w	r12,r8[0x0]
80007402:	c0 3c       	rcall	80007408 <_malloc_r>
80007404:	d8 02       	popm	pc
80007406:	d7 03       	nop

80007408 <_malloc_r>:
80007408:	d4 31       	pushm	r0-r7,lr
8000740a:	f6 c8 ff f5 	sub	r8,r11,-11
8000740e:	18 95       	mov	r5,r12
80007410:	10 97       	mov	r7,r8
80007412:	e0 17 ff f8 	andl	r7,0xfff8
80007416:	59 68       	cp.w	r8,22
80007418:	f9 b7 08 10 	movls	r7,16
8000741c:	16 37       	cp.w	r7,r11
8000741e:	5f 38       	srlo	r8
80007420:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007424:	c0 50       	breq	8000742e <_malloc_r+0x26>
80007426:	30 c8       	mov	r8,12
80007428:	99 38       	st.w	r12[0xc],r8
8000742a:	e0 8f 01 fa 	bral	8000781e <_malloc_r+0x416>
8000742e:	fe b0 f5 a7 	rcall	80005f7c <__malloc_lock>
80007432:	e0 47 01 f7 	cp.w	r7,503
80007436:	e0 8b 00 1d 	brhi	80007470 <_malloc_r+0x68>
8000743a:	ee 03 16 03 	lsr	r3,r7,0x3
8000743e:	e0 68 05 3c 	mov	r8,1340
80007442:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007446:	70 36       	ld.w	r6,r8[0xc]
80007448:	10 36       	cp.w	r6,r8
8000744a:	c0 61       	brne	80007456 <_malloc_r+0x4e>
8000744c:	ec c8 ff f8 	sub	r8,r6,-8
80007450:	70 36       	ld.w	r6,r8[0xc]
80007452:	10 36       	cp.w	r6,r8
80007454:	c0 c0       	breq	8000746c <_malloc_r+0x64>
80007456:	6c 18       	ld.w	r8,r6[0x4]
80007458:	e0 18 ff fc 	andl	r8,0xfffc
8000745c:	6c 3a       	ld.w	r10,r6[0xc]
8000745e:	ec 08 00 09 	add	r9,r6,r8
80007462:	0a 9c       	mov	r12,r5
80007464:	6c 28       	ld.w	r8,r6[0x8]
80007466:	95 28       	st.w	r10[0x8],r8
80007468:	91 3a       	st.w	r8[0xc],r10
8000746a:	c4 78       	rjmp	800074f8 <_malloc_r+0xf0>
8000746c:	2f e3       	sub	r3,-2
8000746e:	c4 d8       	rjmp	80007508 <_malloc_r+0x100>
80007470:	ee 03 16 09 	lsr	r3,r7,0x9
80007474:	c0 41       	brne	8000747c <_malloc_r+0x74>
80007476:	ee 03 16 03 	lsr	r3,r7,0x3
8000747a:	c2 68       	rjmp	800074c6 <_malloc_r+0xbe>
8000747c:	58 43       	cp.w	r3,4
8000747e:	e0 8b 00 06 	brhi	8000748a <_malloc_r+0x82>
80007482:	ee 03 16 06 	lsr	r3,r7,0x6
80007486:	2c 83       	sub	r3,-56
80007488:	c1 f8       	rjmp	800074c6 <_malloc_r+0xbe>
8000748a:	59 43       	cp.w	r3,20
8000748c:	e0 8b 00 04 	brhi	80007494 <_malloc_r+0x8c>
80007490:	2a 53       	sub	r3,-91
80007492:	c1 a8       	rjmp	800074c6 <_malloc_r+0xbe>
80007494:	e0 43 00 54 	cp.w	r3,84
80007498:	e0 8b 00 06 	brhi	800074a4 <_malloc_r+0x9c>
8000749c:	ee 03 16 0c 	lsr	r3,r7,0xc
800074a0:	29 23       	sub	r3,-110
800074a2:	c1 28       	rjmp	800074c6 <_malloc_r+0xbe>
800074a4:	e0 43 01 54 	cp.w	r3,340
800074a8:	e0 8b 00 06 	brhi	800074b4 <_malloc_r+0xac>
800074ac:	ee 03 16 0f 	lsr	r3,r7,0xf
800074b0:	28 93       	sub	r3,-119
800074b2:	c0 a8       	rjmp	800074c6 <_malloc_r+0xbe>
800074b4:	e0 43 05 54 	cp.w	r3,1364
800074b8:	e0 88 00 04 	brls	800074c0 <_malloc_r+0xb8>
800074bc:	37 e3       	mov	r3,126
800074be:	c0 48       	rjmp	800074c6 <_malloc_r+0xbe>
800074c0:	ee 03 16 12 	lsr	r3,r7,0x12
800074c4:	28 43       	sub	r3,-124
800074c6:	e0 6a 05 3c 	mov	r10,1340
800074ca:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800074ce:	74 36       	ld.w	r6,r10[0xc]
800074d0:	c1 98       	rjmp	80007502 <_malloc_r+0xfa>
800074d2:	6c 19       	ld.w	r9,r6[0x4]
800074d4:	e0 19 ff fc 	andl	r9,0xfffc
800074d8:	f2 07 01 0b 	sub	r11,r9,r7
800074dc:	58 fb       	cp.w	r11,15
800074de:	e0 8a 00 04 	brle	800074e6 <_malloc_r+0xde>
800074e2:	20 13       	sub	r3,1
800074e4:	c1 18       	rjmp	80007506 <_malloc_r+0xfe>
800074e6:	6c 38       	ld.w	r8,r6[0xc]
800074e8:	58 0b       	cp.w	r11,0
800074ea:	c0 b5       	brlt	80007500 <_malloc_r+0xf8>
800074ec:	6c 2a       	ld.w	r10,r6[0x8]
800074ee:	ec 09 00 09 	add	r9,r6,r9
800074f2:	0a 9c       	mov	r12,r5
800074f4:	91 2a       	st.w	r8[0x8],r10
800074f6:	95 38       	st.w	r10[0xc],r8
800074f8:	72 18       	ld.w	r8,r9[0x4]
800074fa:	a1 a8       	sbr	r8,0x0
800074fc:	93 18       	st.w	r9[0x4],r8
800074fe:	cb c8       	rjmp	80007676 <_malloc_r+0x26e>
80007500:	10 96       	mov	r6,r8
80007502:	14 36       	cp.w	r6,r10
80007504:	ce 71       	brne	800074d2 <_malloc_r+0xca>
80007506:	2f f3       	sub	r3,-1
80007508:	e0 6a 05 3c 	mov	r10,1340
8000750c:	f4 cc ff f8 	sub	r12,r10,-8
80007510:	78 26       	ld.w	r6,r12[0x8]
80007512:	18 36       	cp.w	r6,r12
80007514:	c6 c0       	breq	800075ec <_malloc_r+0x1e4>
80007516:	6c 19       	ld.w	r9,r6[0x4]
80007518:	e0 19 ff fc 	andl	r9,0xfffc
8000751c:	f2 07 01 08 	sub	r8,r9,r7
80007520:	58 f8       	cp.w	r8,15
80007522:	e0 89 00 8f 	brgt	80007640 <_malloc_r+0x238>
80007526:	99 3c       	st.w	r12[0xc],r12
80007528:	99 2c       	st.w	r12[0x8],r12
8000752a:	58 08       	cp.w	r8,0
8000752c:	c0 55       	brlt	80007536 <_malloc_r+0x12e>
8000752e:	ec 09 00 09 	add	r9,r6,r9
80007532:	0a 9c       	mov	r12,r5
80007534:	ce 2b       	rjmp	800074f8 <_malloc_r+0xf0>
80007536:	e0 49 01 ff 	cp.w	r9,511
8000753a:	e0 8b 00 13 	brhi	80007560 <_malloc_r+0x158>
8000753e:	a3 99       	lsr	r9,0x3
80007540:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007544:	70 2b       	ld.w	r11,r8[0x8]
80007546:	8d 38       	st.w	r6[0xc],r8
80007548:	8d 2b       	st.w	r6[0x8],r11
8000754a:	97 36       	st.w	r11[0xc],r6
8000754c:	91 26       	st.w	r8[0x8],r6
8000754e:	a3 49       	asr	r9,0x2
80007550:	74 18       	ld.w	r8,r10[0x4]
80007552:	30 1b       	mov	r11,1
80007554:	f6 09 09 49 	lsl	r9,r11,r9
80007558:	f1 e9 10 09 	or	r9,r8,r9
8000755c:	95 19       	st.w	r10[0x4],r9
8000755e:	c4 78       	rjmp	800075ec <_malloc_r+0x1e4>
80007560:	f2 0a 16 09 	lsr	r10,r9,0x9
80007564:	58 4a       	cp.w	r10,4
80007566:	e0 8b 00 07 	brhi	80007574 <_malloc_r+0x16c>
8000756a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000756e:	2c 8a       	sub	r10,-56
80007570:	c2 08       	rjmp	800075b0 <_malloc_r+0x1a8>
80007572:	d7 03       	nop
80007574:	59 4a       	cp.w	r10,20
80007576:	e0 8b 00 04 	brhi	8000757e <_malloc_r+0x176>
8000757a:	2a 5a       	sub	r10,-91
8000757c:	c1 a8       	rjmp	800075b0 <_malloc_r+0x1a8>
8000757e:	e0 4a 00 54 	cp.w	r10,84
80007582:	e0 8b 00 06 	brhi	8000758e <_malloc_r+0x186>
80007586:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000758a:	29 2a       	sub	r10,-110
8000758c:	c1 28       	rjmp	800075b0 <_malloc_r+0x1a8>
8000758e:	e0 4a 01 54 	cp.w	r10,340
80007592:	e0 8b 00 06 	brhi	8000759e <_malloc_r+0x196>
80007596:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000759a:	28 9a       	sub	r10,-119
8000759c:	c0 a8       	rjmp	800075b0 <_malloc_r+0x1a8>
8000759e:	e0 4a 05 54 	cp.w	r10,1364
800075a2:	e0 88 00 04 	brls	800075aa <_malloc_r+0x1a2>
800075a6:	37 ea       	mov	r10,126
800075a8:	c0 48       	rjmp	800075b0 <_malloc_r+0x1a8>
800075aa:	f2 0a 16 12 	lsr	r10,r9,0x12
800075ae:	28 4a       	sub	r10,-124
800075b0:	e0 6b 05 3c 	mov	r11,1340
800075b4:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800075b8:	68 28       	ld.w	r8,r4[0x8]
800075ba:	08 38       	cp.w	r8,r4
800075bc:	c0 e1       	brne	800075d8 <_malloc_r+0x1d0>
800075be:	76 19       	ld.w	r9,r11[0x4]
800075c0:	a3 4a       	asr	r10,0x2
800075c2:	30 1e       	mov	lr,1
800075c4:	fc 0a 09 4a 	lsl	r10,lr,r10
800075c8:	f3 ea 10 0a 	or	r10,r9,r10
800075cc:	10 99       	mov	r9,r8
800075ce:	97 1a       	st.w	r11[0x4],r10
800075d0:	c0 a8       	rjmp	800075e4 <_malloc_r+0x1dc>
800075d2:	70 28       	ld.w	r8,r8[0x8]
800075d4:	08 38       	cp.w	r8,r4
800075d6:	c0 60       	breq	800075e2 <_malloc_r+0x1da>
800075d8:	70 1a       	ld.w	r10,r8[0x4]
800075da:	e0 1a ff fc 	andl	r10,0xfffc
800075de:	14 39       	cp.w	r9,r10
800075e0:	cf 93       	brcs	800075d2 <_malloc_r+0x1ca>
800075e2:	70 39       	ld.w	r9,r8[0xc]
800075e4:	8d 39       	st.w	r6[0xc],r9
800075e6:	8d 28       	st.w	r6[0x8],r8
800075e8:	91 36       	st.w	r8[0xc],r6
800075ea:	93 26       	st.w	r9[0x8],r6
800075ec:	e6 08 14 02 	asr	r8,r3,0x2
800075f0:	30 1b       	mov	r11,1
800075f2:	e0 64 05 3c 	mov	r4,1340
800075f6:	f6 08 09 4b 	lsl	r11,r11,r8
800075fa:	68 18       	ld.w	r8,r4[0x4]
800075fc:	10 3b       	cp.w	r11,r8
800075fe:	e0 8b 00 6b 	brhi	800076d4 <_malloc_r+0x2cc>
80007602:	f7 e8 00 09 	and	r9,r11,r8
80007606:	c0 b1       	brne	8000761c <_malloc_r+0x214>
80007608:	e0 13 ff fc 	andl	r3,0xfffc
8000760c:	a1 7b       	lsl	r11,0x1
8000760e:	2f c3       	sub	r3,-4
80007610:	c0 38       	rjmp	80007616 <_malloc_r+0x20e>
80007612:	2f c3       	sub	r3,-4
80007614:	a1 7b       	lsl	r11,0x1
80007616:	f7 e8 00 09 	and	r9,r11,r8
8000761a:	cf c0       	breq	80007612 <_malloc_r+0x20a>
8000761c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007620:	06 92       	mov	r2,r3
80007622:	1c 91       	mov	r1,lr
80007624:	62 36       	ld.w	r6,r1[0xc]
80007626:	c2 e8       	rjmp	80007682 <_malloc_r+0x27a>
80007628:	6c 1a       	ld.w	r10,r6[0x4]
8000762a:	e0 1a ff fc 	andl	r10,0xfffc
8000762e:	f4 07 01 08 	sub	r8,r10,r7
80007632:	58 f8       	cp.w	r8,15
80007634:	e0 8a 00 15 	brle	8000765e <_malloc_r+0x256>
80007638:	6c 3a       	ld.w	r10,r6[0xc]
8000763a:	6c 29       	ld.w	r9,r6[0x8]
8000763c:	95 29       	st.w	r10[0x8],r9
8000763e:	93 3a       	st.w	r9[0xc],r10
80007640:	0e 99       	mov	r9,r7
80007642:	ec 07 00 07 	add	r7,r6,r7
80007646:	a1 a9       	sbr	r9,0x0
80007648:	99 37       	st.w	r12[0xc],r7
8000764a:	99 27       	st.w	r12[0x8],r7
8000764c:	8d 19       	st.w	r6[0x4],r9
8000764e:	ee 08 09 08 	st.w	r7[r8],r8
80007652:	8f 2c       	st.w	r7[0x8],r12
80007654:	8f 3c       	st.w	r7[0xc],r12
80007656:	a1 a8       	sbr	r8,0x0
80007658:	0a 9c       	mov	r12,r5
8000765a:	8f 18       	st.w	r7[0x4],r8
8000765c:	c0 d8       	rjmp	80007676 <_malloc_r+0x26e>
8000765e:	6c 39       	ld.w	r9,r6[0xc]
80007660:	58 08       	cp.w	r8,0
80007662:	c0 f5       	brlt	80007680 <_malloc_r+0x278>
80007664:	ec 0a 00 0a 	add	r10,r6,r10
80007668:	74 18       	ld.w	r8,r10[0x4]
8000766a:	a1 a8       	sbr	r8,0x0
8000766c:	0a 9c       	mov	r12,r5
8000766e:	95 18       	st.w	r10[0x4],r8
80007670:	6c 28       	ld.w	r8,r6[0x8]
80007672:	93 28       	st.w	r9[0x8],r8
80007674:	91 39       	st.w	r8[0xc],r9
80007676:	fe b0 f4 89 	rcall	80005f88 <__malloc_unlock>
8000767a:	ec cc ff f8 	sub	r12,r6,-8
8000767e:	d8 32       	popm	r0-r7,pc
80007680:	12 96       	mov	r6,r9
80007682:	02 36       	cp.w	r6,r1
80007684:	cd 21       	brne	80007628 <_malloc_r+0x220>
80007686:	2f f2       	sub	r2,-1
80007688:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000768c:	c0 30       	breq	80007692 <_malloc_r+0x28a>
8000768e:	2f 81       	sub	r1,-8
80007690:	cc ab       	rjmp	80007624 <_malloc_r+0x21c>
80007692:	1c 98       	mov	r8,lr
80007694:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007698:	c0 81       	brne	800076a8 <_malloc_r+0x2a0>
8000769a:	68 19       	ld.w	r9,r4[0x4]
8000769c:	f6 08 11 ff 	rsub	r8,r11,-1
800076a0:	f3 e8 00 08 	and	r8,r9,r8
800076a4:	89 18       	st.w	r4[0x4],r8
800076a6:	c0 78       	rjmp	800076b4 <_malloc_r+0x2ac>
800076a8:	f0 c9 00 08 	sub	r9,r8,8
800076ac:	20 13       	sub	r3,1
800076ae:	70 08       	ld.w	r8,r8[0x0]
800076b0:	12 38       	cp.w	r8,r9
800076b2:	cf 10       	breq	80007694 <_malloc_r+0x28c>
800076b4:	a1 7b       	lsl	r11,0x1
800076b6:	68 18       	ld.w	r8,r4[0x4]
800076b8:	10 3b       	cp.w	r11,r8
800076ba:	e0 8b 00 0d 	brhi	800076d4 <_malloc_r+0x2cc>
800076be:	58 0b       	cp.w	r11,0
800076c0:	c0 a0       	breq	800076d4 <_malloc_r+0x2cc>
800076c2:	04 93       	mov	r3,r2
800076c4:	c0 38       	rjmp	800076ca <_malloc_r+0x2c2>
800076c6:	2f c3       	sub	r3,-4
800076c8:	a1 7b       	lsl	r11,0x1
800076ca:	f7 e8 00 09 	and	r9,r11,r8
800076ce:	ca 71       	brne	8000761c <_malloc_r+0x214>
800076d0:	cf bb       	rjmp	800076c6 <_malloc_r+0x2be>
800076d2:	d7 03       	nop
800076d4:	68 23       	ld.w	r3,r4[0x8]
800076d6:	66 12       	ld.w	r2,r3[0x4]
800076d8:	e0 12 ff fc 	andl	r2,0xfffc
800076dc:	0e 32       	cp.w	r2,r7
800076de:	5f 39       	srlo	r9
800076e0:	e4 07 01 08 	sub	r8,r2,r7
800076e4:	58 f8       	cp.w	r8,15
800076e6:	5f aa       	srle	r10
800076e8:	f5 e9 10 09 	or	r9,r10,r9
800076ec:	e0 80 00 9a 	breq	80007820 <_malloc_r+0x418>
800076f0:	e0 68 0d 70 	mov	r8,3440
800076f4:	70 01       	ld.w	r1,r8[0x0]
800076f6:	e0 68 09 48 	mov	r8,2376
800076fa:	2f 01       	sub	r1,-16
800076fc:	70 08       	ld.w	r8,r8[0x0]
800076fe:	0e 01       	add	r1,r7
80007700:	5b f8       	cp.w	r8,-1
80007702:	c0 40       	breq	8000770a <_malloc_r+0x302>
80007704:	28 11       	sub	r1,-127
80007706:	e0 11 ff 80 	andl	r1,0xff80
8000770a:	02 9b       	mov	r11,r1
8000770c:	0a 9c       	mov	r12,r5
8000770e:	e0 a0 02 a5 	rcall	80007c58 <_sbrk_r>
80007712:	18 96       	mov	r6,r12
80007714:	5b fc       	cp.w	r12,-1
80007716:	c7 50       	breq	80007800 <_malloc_r+0x3f8>
80007718:	e6 02 00 08 	add	r8,r3,r2
8000771c:	10 3c       	cp.w	r12,r8
8000771e:	c0 32       	brcc	80007724 <_malloc_r+0x31c>
80007720:	08 33       	cp.w	r3,r4
80007722:	c6 f1       	brne	80007800 <_malloc_r+0x3f8>
80007724:	e0 6a 0d 74 	mov	r10,3444
80007728:	74 09       	ld.w	r9,r10[0x0]
8000772a:	e2 09 00 09 	add	r9,r1,r9
8000772e:	95 09       	st.w	r10[0x0],r9
80007730:	10 36       	cp.w	r6,r8
80007732:	c0 a1       	brne	80007746 <_malloc_r+0x33e>
80007734:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007738:	c0 71       	brne	80007746 <_malloc_r+0x33e>
8000773a:	e2 02 00 02 	add	r2,r1,r2
8000773e:	68 28       	ld.w	r8,r4[0x8]
80007740:	a1 a2       	sbr	r2,0x0
80007742:	91 12       	st.w	r8[0x4],r2
80007744:	c4 f8       	rjmp	800077e2 <_malloc_r+0x3da>
80007746:	e0 6a 09 48 	mov	r10,2376
8000774a:	74 0b       	ld.w	r11,r10[0x0]
8000774c:	5b fb       	cp.w	r11,-1
8000774e:	c0 31       	brne	80007754 <_malloc_r+0x34c>
80007750:	95 06       	st.w	r10[0x0],r6
80007752:	c0 78       	rjmp	80007760 <_malloc_r+0x358>
80007754:	ec 09 00 09 	add	r9,r6,r9
80007758:	e0 6a 0d 74 	mov	r10,3444
8000775c:	10 19       	sub	r9,r8
8000775e:	95 09       	st.w	r10[0x0],r9
80007760:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007764:	f0 09 11 08 	rsub	r9,r8,8
80007768:	58 08       	cp.w	r8,0
8000776a:	f2 08 17 10 	movne	r8,r9
8000776e:	ed d8 e1 06 	addne	r6,r6,r8
80007772:	28 08       	sub	r8,-128
80007774:	ec 01 00 01 	add	r1,r6,r1
80007778:	0a 9c       	mov	r12,r5
8000777a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000777e:	f0 01 01 01 	sub	r1,r8,r1
80007782:	02 9b       	mov	r11,r1
80007784:	e0 a0 02 6a 	rcall	80007c58 <_sbrk_r>
80007788:	e0 68 0d 74 	mov	r8,3444
8000778c:	5b fc       	cp.w	r12,-1
8000778e:	ec 0c 17 00 	moveq	r12,r6
80007792:	f9 b1 00 00 	moveq	r1,0
80007796:	70 09       	ld.w	r9,r8[0x0]
80007798:	0c 1c       	sub	r12,r6
8000779a:	89 26       	st.w	r4[0x8],r6
8000779c:	02 0c       	add	r12,r1
8000779e:	12 01       	add	r1,r9
800077a0:	a1 ac       	sbr	r12,0x0
800077a2:	91 01       	st.w	r8[0x0],r1
800077a4:	8d 1c       	st.w	r6[0x4],r12
800077a6:	08 33       	cp.w	r3,r4
800077a8:	c1 d0       	breq	800077e2 <_malloc_r+0x3da>
800077aa:	58 f2       	cp.w	r2,15
800077ac:	e0 8b 00 05 	brhi	800077b6 <_malloc_r+0x3ae>
800077b0:	30 18       	mov	r8,1
800077b2:	8d 18       	st.w	r6[0x4],r8
800077b4:	c2 68       	rjmp	80007800 <_malloc_r+0x3f8>
800077b6:	30 59       	mov	r9,5
800077b8:	20 c2       	sub	r2,12
800077ba:	e0 12 ff f8 	andl	r2,0xfff8
800077be:	e6 02 00 08 	add	r8,r3,r2
800077c2:	91 29       	st.w	r8[0x8],r9
800077c4:	91 19       	st.w	r8[0x4],r9
800077c6:	66 18       	ld.w	r8,r3[0x4]
800077c8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077cc:	e5 e8 10 08 	or	r8,r2,r8
800077d0:	87 18       	st.w	r3[0x4],r8
800077d2:	58 f2       	cp.w	r2,15
800077d4:	e0 88 00 07 	brls	800077e2 <_malloc_r+0x3da>
800077d8:	e6 cb ff f8 	sub	r11,r3,-8
800077dc:	0a 9c       	mov	r12,r5
800077de:	e0 a0 1c 6b 	rcall	8000b0b4 <_free_r>
800077e2:	e0 69 0d 6c 	mov	r9,3436
800077e6:	72 0a       	ld.w	r10,r9[0x0]
800077e8:	e0 68 0d 74 	mov	r8,3444
800077ec:	70 08       	ld.w	r8,r8[0x0]
800077ee:	14 38       	cp.w	r8,r10
800077f0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800077f4:	e0 69 0d 68 	mov	r9,3432
800077f8:	72 0a       	ld.w	r10,r9[0x0]
800077fa:	14 38       	cp.w	r8,r10
800077fc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007800:	68 28       	ld.w	r8,r4[0x8]
80007802:	70 18       	ld.w	r8,r8[0x4]
80007804:	e0 18 ff fc 	andl	r8,0xfffc
80007808:	0e 38       	cp.w	r8,r7
8000780a:	5f 39       	srlo	r9
8000780c:	0e 18       	sub	r8,r7
8000780e:	58 f8       	cp.w	r8,15
80007810:	5f aa       	srle	r10
80007812:	f5 e9 10 09 	or	r9,r10,r9
80007816:	c0 50       	breq	80007820 <_malloc_r+0x418>
80007818:	0a 9c       	mov	r12,r5
8000781a:	fe b0 f3 b7 	rcall	80005f88 <__malloc_unlock>
8000781e:	d8 3a       	popm	r0-r7,pc,r12=0
80007820:	68 26       	ld.w	r6,r4[0x8]
80007822:	a1 a8       	sbr	r8,0x0
80007824:	0e 99       	mov	r9,r7
80007826:	a1 a9       	sbr	r9,0x0
80007828:	8d 19       	st.w	r6[0x4],r9
8000782a:	ec 07 00 07 	add	r7,r6,r7
8000782e:	0a 9c       	mov	r12,r5
80007830:	89 27       	st.w	r4[0x8],r7
80007832:	8f 18       	st.w	r7[0x4],r8
80007834:	fe b0 f3 aa 	rcall	80005f88 <__malloc_unlock>
80007838:	ec cc ff f8 	sub	r12,r6,-8
8000783c:	d8 32       	popm	r0-r7,pc
8000783e:	d7 03       	nop

80007840 <memcpy>:
80007840:	58 8a       	cp.w	r10,8
80007842:	c2 f5       	brlt	800078a0 <memcpy+0x60>
80007844:	f9 eb 10 09 	or	r9,r12,r11
80007848:	e2 19 00 03 	andl	r9,0x3,COH
8000784c:	e0 81 00 97 	brne	8000797a <memcpy+0x13a>
80007850:	e0 4a 00 20 	cp.w	r10,32
80007854:	c3 b4       	brge	800078ca <memcpy+0x8a>
80007856:	f4 08 14 02 	asr	r8,r10,0x2
8000785a:	f0 09 11 08 	rsub	r9,r8,8
8000785e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007862:	76 69       	ld.w	r9,r11[0x18]
80007864:	99 69       	st.w	r12[0x18],r9
80007866:	76 59       	ld.w	r9,r11[0x14]
80007868:	99 59       	st.w	r12[0x14],r9
8000786a:	76 49       	ld.w	r9,r11[0x10]
8000786c:	99 49       	st.w	r12[0x10],r9
8000786e:	76 39       	ld.w	r9,r11[0xc]
80007870:	99 39       	st.w	r12[0xc],r9
80007872:	76 29       	ld.w	r9,r11[0x8]
80007874:	99 29       	st.w	r12[0x8],r9
80007876:	76 19       	ld.w	r9,r11[0x4]
80007878:	99 19       	st.w	r12[0x4],r9
8000787a:	76 09       	ld.w	r9,r11[0x0]
8000787c:	99 09       	st.w	r12[0x0],r9
8000787e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007882:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007886:	e0 1a 00 03 	andl	r10,0x3
8000788a:	f4 0a 11 04 	rsub	r10,r10,4
8000788e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007892:	17 a9       	ld.ub	r9,r11[0x2]
80007894:	b0 a9       	st.b	r8[0x2],r9
80007896:	17 99       	ld.ub	r9,r11[0x1]
80007898:	b0 99       	st.b	r8[0x1],r9
8000789a:	17 89       	ld.ub	r9,r11[0x0]
8000789c:	b0 89       	st.b	r8[0x0],r9
8000789e:	5e fc       	retal	r12
800078a0:	f4 0a 11 09 	rsub	r10,r10,9
800078a4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078a8:	17 f9       	ld.ub	r9,r11[0x7]
800078aa:	b8 f9       	st.b	r12[0x7],r9
800078ac:	17 e9       	ld.ub	r9,r11[0x6]
800078ae:	b8 e9       	st.b	r12[0x6],r9
800078b0:	17 d9       	ld.ub	r9,r11[0x5]
800078b2:	b8 d9       	st.b	r12[0x5],r9
800078b4:	17 c9       	ld.ub	r9,r11[0x4]
800078b6:	b8 c9       	st.b	r12[0x4],r9
800078b8:	17 b9       	ld.ub	r9,r11[0x3]
800078ba:	b8 b9       	st.b	r12[0x3],r9
800078bc:	17 a9       	ld.ub	r9,r11[0x2]
800078be:	b8 a9       	st.b	r12[0x2],r9
800078c0:	17 99       	ld.ub	r9,r11[0x1]
800078c2:	b8 99       	st.b	r12[0x1],r9
800078c4:	17 89       	ld.ub	r9,r11[0x0]
800078c6:	b8 89       	st.b	r12[0x0],r9
800078c8:	5e fc       	retal	r12
800078ca:	eb cd 40 c0 	pushm	r6-r7,lr
800078ce:	18 99       	mov	r9,r12
800078d0:	22 0a       	sub	r10,32
800078d2:	b7 07       	ld.d	r6,r11++
800078d4:	b3 26       	st.d	r9++,r6
800078d6:	b7 07       	ld.d	r6,r11++
800078d8:	b3 26       	st.d	r9++,r6
800078da:	b7 07       	ld.d	r6,r11++
800078dc:	b3 26       	st.d	r9++,r6
800078de:	b7 07       	ld.d	r6,r11++
800078e0:	b3 26       	st.d	r9++,r6
800078e2:	22 0a       	sub	r10,32
800078e4:	cf 74       	brge	800078d2 <memcpy+0x92>
800078e6:	2f 0a       	sub	r10,-16
800078e8:	c0 65       	brlt	800078f4 <memcpy+0xb4>
800078ea:	b7 07       	ld.d	r6,r11++
800078ec:	b3 26       	st.d	r9++,r6
800078ee:	b7 07       	ld.d	r6,r11++
800078f0:	b3 26       	st.d	r9++,r6
800078f2:	21 0a       	sub	r10,16
800078f4:	5c 3a       	neg	r10
800078f6:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800078fa:	d7 03       	nop
800078fc:	d7 03       	nop
800078fe:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007902:	f3 66 00 0e 	st.b	r9[14],r6
80007906:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000790a:	f3 66 00 0d 	st.b	r9[13],r6
8000790e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007912:	f3 66 00 0c 	st.b	r9[12],r6
80007916:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000791a:	f3 66 00 0b 	st.b	r9[11],r6
8000791e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007922:	f3 66 00 0a 	st.b	r9[10],r6
80007926:	f7 36 00 09 	ld.ub	r6,r11[9]
8000792a:	f3 66 00 09 	st.b	r9[9],r6
8000792e:	f7 36 00 08 	ld.ub	r6,r11[8]
80007932:	f3 66 00 08 	st.b	r9[8],r6
80007936:	f7 36 00 07 	ld.ub	r6,r11[7]
8000793a:	f3 66 00 07 	st.b	r9[7],r6
8000793e:	f7 36 00 06 	ld.ub	r6,r11[6]
80007942:	f3 66 00 06 	st.b	r9[6],r6
80007946:	f7 36 00 05 	ld.ub	r6,r11[5]
8000794a:	f3 66 00 05 	st.b	r9[5],r6
8000794e:	f7 36 00 04 	ld.ub	r6,r11[4]
80007952:	f3 66 00 04 	st.b	r9[4],r6
80007956:	f7 36 00 03 	ld.ub	r6,r11[3]
8000795a:	f3 66 00 03 	st.b	r9[3],r6
8000795e:	f7 36 00 02 	ld.ub	r6,r11[2]
80007962:	f3 66 00 02 	st.b	r9[2],r6
80007966:	f7 36 00 01 	ld.ub	r6,r11[1]
8000796a:	f3 66 00 01 	st.b	r9[1],r6
8000796e:	f7 36 00 00 	ld.ub	r6,r11[0]
80007972:	f3 66 00 00 	st.b	r9[0],r6
80007976:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000797a:	20 1a       	sub	r10,1
8000797c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007980:	f8 0a 0b 09 	st.b	r12[r10],r9
80007984:	cf b1       	brne	8000797a <memcpy+0x13a>
80007986:	5e fc       	retal	r12

80007988 <memset>:
80007988:	18 98       	mov	r8,r12
8000798a:	c0 38       	rjmp	80007990 <memset+0x8>
8000798c:	10 cb       	st.b	r8++,r11
8000798e:	20 1a       	sub	r10,1
80007990:	58 0a       	cp.w	r10,0
80007992:	cf d1       	brne	8000798c <memset+0x4>
80007994:	5e fc       	retal	r12
80007996:	d7 03       	nop

80007998 <_realloc_r>:
80007998:	d4 31       	pushm	r0-r7,lr
8000799a:	20 1d       	sub	sp,4
8000799c:	16 94       	mov	r4,r11
8000799e:	18 92       	mov	r2,r12
800079a0:	14 9b       	mov	r11,r10
800079a2:	58 04       	cp.w	r4,0
800079a4:	c0 51       	brne	800079ae <_realloc_r+0x16>
800079a6:	fe b0 fd 31 	rcall	80007408 <_malloc_r>
800079aa:	18 95       	mov	r5,r12
800079ac:	c5 39       	rjmp	80007c52 <_realloc_r+0x2ba>
800079ae:	50 0a       	stdsp	sp[0x0],r10
800079b0:	fe b0 f2 e6 	rcall	80005f7c <__malloc_lock>
800079b4:	40 0b       	lddsp	r11,sp[0x0]
800079b6:	f6 c8 ff f5 	sub	r8,r11,-11
800079ba:	e8 c1 00 08 	sub	r1,r4,8
800079be:	10 96       	mov	r6,r8
800079c0:	62 1c       	ld.w	r12,r1[0x4]
800079c2:	e0 16 ff f8 	andl	r6,0xfff8
800079c6:	59 68       	cp.w	r8,22
800079c8:	f9 b6 08 10 	movls	r6,16
800079cc:	16 36       	cp.w	r6,r11
800079ce:	5f 38       	srlo	r8
800079d0:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800079d4:	c0 50       	breq	800079de <_realloc_r+0x46>
800079d6:	30 c8       	mov	r8,12
800079d8:	30 05       	mov	r5,0
800079da:	85 38       	st.w	r2[0xc],r8
800079dc:	c3 b9       	rjmp	80007c52 <_realloc_r+0x2ba>
800079de:	18 90       	mov	r0,r12
800079e0:	e0 10 ff fc 	andl	r0,0xfffc
800079e4:	0c 30       	cp.w	r0,r6
800079e6:	e0 84 01 0b 	brge	80007bfc <_realloc_r+0x264>
800079ea:	e0 68 05 3c 	mov	r8,1340
800079ee:	e2 00 00 09 	add	r9,r1,r0
800079f2:	70 25       	ld.w	r5,r8[0x8]
800079f4:	0a 39       	cp.w	r9,r5
800079f6:	c0 90       	breq	80007a08 <_realloc_r+0x70>
800079f8:	72 1a       	ld.w	r10,r9[0x4]
800079fa:	a1 ca       	cbr	r10,0x0
800079fc:	f2 0a 00 0a 	add	r10,r9,r10
80007a00:	74 1a       	ld.w	r10,r10[0x4]
80007a02:	ed ba 00 00 	bld	r10,0x0
80007a06:	c2 20       	breq	80007a4a <_realloc_r+0xb2>
80007a08:	72 1a       	ld.w	r10,r9[0x4]
80007a0a:	e0 1a ff fc 	andl	r10,0xfffc
80007a0e:	f4 00 00 03 	add	r3,r10,r0
80007a12:	0a 39       	cp.w	r9,r5
80007a14:	c1 31       	brne	80007a3a <_realloc_r+0xa2>
80007a16:	ec c7 ff f0 	sub	r7,r6,-16
80007a1a:	0e 33       	cp.w	r3,r7
80007a1c:	c1 95       	brlt	80007a4e <_realloc_r+0xb6>
80007a1e:	e2 06 00 09 	add	r9,r1,r6
80007a22:	0c 13       	sub	r3,r6
80007a24:	a1 a3       	sbr	r3,0x0
80007a26:	93 13       	st.w	r9[0x4],r3
80007a28:	91 29       	st.w	r8[0x8],r9
80007a2a:	04 9c       	mov	r12,r2
80007a2c:	62 18       	ld.w	r8,r1[0x4]
80007a2e:	08 95       	mov	r5,r4
80007a30:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a34:	10 46       	or	r6,r8
80007a36:	83 16       	st.w	r1[0x4],r6
80007a38:	c0 b9       	rjmp	80007c4e <_realloc_r+0x2b6>
80007a3a:	0c 33       	cp.w	r3,r6
80007a3c:	c0 95       	brlt	80007a4e <_realloc_r+0xb6>
80007a3e:	72 28       	ld.w	r8,r9[0x8]
80007a40:	02 97       	mov	r7,r1
80007a42:	72 39       	ld.w	r9,r9[0xc]
80007a44:	93 28       	st.w	r9[0x8],r8
80007a46:	91 39       	st.w	r8[0xc],r9
80007a48:	cd c8       	rjmp	80007c00 <_realloc_r+0x268>
80007a4a:	30 0a       	mov	r10,0
80007a4c:	14 99       	mov	r9,r10
80007a4e:	ed bc 00 00 	bld	r12,0x0
80007a52:	e0 80 00 95 	breq	80007b7c <_realloc_r+0x1e4>
80007a56:	62 07       	ld.w	r7,r1[0x0]
80007a58:	e2 07 01 07 	sub	r7,r1,r7
80007a5c:	6e 1c       	ld.w	r12,r7[0x4]
80007a5e:	e0 1c ff fc 	andl	r12,0xfffc
80007a62:	58 09       	cp.w	r9,0
80007a64:	c5 60       	breq	80007b10 <_realloc_r+0x178>
80007a66:	f8 00 00 03 	add	r3,r12,r0
80007a6a:	0a 39       	cp.w	r9,r5
80007a6c:	c4 81       	brne	80007afc <_realloc_r+0x164>
80007a6e:	14 03       	add	r3,r10
80007a70:	ec c9 ff f0 	sub	r9,r6,-16
80007a74:	12 33       	cp.w	r3,r9
80007a76:	c4 d5       	brlt	80007b10 <_realloc_r+0x178>
80007a78:	6e 3a       	ld.w	r10,r7[0xc]
80007a7a:	6e 29       	ld.w	r9,r7[0x8]
80007a7c:	95 29       	st.w	r10[0x8],r9
80007a7e:	93 3a       	st.w	r9[0xc],r10
80007a80:	ee c5 ff f8 	sub	r5,r7,-8
80007a84:	e0 ca 00 04 	sub	r10,r0,4
80007a88:	e0 4a 00 24 	cp.w	r10,36
80007a8c:	e0 8b 00 25 	brhi	80007ad6 <_realloc_r+0x13e>
80007a90:	0a 99       	mov	r9,r5
80007a92:	59 3a       	cp.w	r10,19
80007a94:	e0 88 00 1a 	brls	80007ac8 <_realloc_r+0x130>
80007a98:	09 09       	ld.w	r9,r4++
80007a9a:	8b 09       	st.w	r5[0x0],r9
80007a9c:	09 09       	ld.w	r9,r4++
80007a9e:	8f 39       	st.w	r7[0xc],r9
80007aa0:	ee c9 ff f0 	sub	r9,r7,-16
80007aa4:	59 ba       	cp.w	r10,27
80007aa6:	e0 88 00 11 	brls	80007ac8 <_realloc_r+0x130>
80007aaa:	09 0b       	ld.w	r11,r4++
80007aac:	93 0b       	st.w	r9[0x0],r11
80007aae:	09 09       	ld.w	r9,r4++
80007ab0:	8f 59       	st.w	r7[0x14],r9
80007ab2:	ee c9 ff e8 	sub	r9,r7,-24
80007ab6:	e0 4a 00 24 	cp.w	r10,36
80007aba:	c0 71       	brne	80007ac8 <_realloc_r+0x130>
80007abc:	09 0a       	ld.w	r10,r4++
80007abe:	93 0a       	st.w	r9[0x0],r10
80007ac0:	ee c9 ff e0 	sub	r9,r7,-32
80007ac4:	09 0a       	ld.w	r10,r4++
80007ac6:	8f 7a       	st.w	r7[0x1c],r10
80007ac8:	09 0a       	ld.w	r10,r4++
80007aca:	12 aa       	st.w	r9++,r10
80007acc:	68 0a       	ld.w	r10,r4[0x0]
80007ace:	93 0a       	st.w	r9[0x0],r10
80007ad0:	68 1a       	ld.w	r10,r4[0x4]
80007ad2:	93 1a       	st.w	r9[0x4],r10
80007ad4:	c0 78       	rjmp	80007ae2 <_realloc_r+0x14a>
80007ad6:	50 08       	stdsp	sp[0x0],r8
80007ad8:	08 9b       	mov	r11,r4
80007ada:	0a 9c       	mov	r12,r5
80007adc:	e0 a0 1d 8f 	rcall	8000b5fa <memmove>
80007ae0:	40 08       	lddsp	r8,sp[0x0]
80007ae2:	ee 06 00 09 	add	r9,r7,r6
80007ae6:	0c 13       	sub	r3,r6
80007ae8:	a1 a3       	sbr	r3,0x0
80007aea:	93 13       	st.w	r9[0x4],r3
80007aec:	91 29       	st.w	r8[0x8],r9
80007aee:	04 9c       	mov	r12,r2
80007af0:	6e 18       	ld.w	r8,r7[0x4]
80007af2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007af6:	10 46       	or	r6,r8
80007af8:	8f 16       	st.w	r7[0x4],r6
80007afa:	ca a8       	rjmp	80007c4e <_realloc_r+0x2b6>
80007afc:	14 03       	add	r3,r10
80007afe:	0c 33       	cp.w	r3,r6
80007b00:	c0 85       	brlt	80007b10 <_realloc_r+0x178>
80007b02:	72 28       	ld.w	r8,r9[0x8]
80007b04:	72 39       	ld.w	r9,r9[0xc]
80007b06:	93 28       	st.w	r9[0x8],r8
80007b08:	91 39       	st.w	r8[0xc],r9
80007b0a:	6e 28       	ld.w	r8,r7[0x8]
80007b0c:	6e 39       	ld.w	r9,r7[0xc]
80007b0e:	c0 78       	rjmp	80007b1c <_realloc_r+0x184>
80007b10:	f8 00 00 03 	add	r3,r12,r0
80007b14:	0c 33       	cp.w	r3,r6
80007b16:	c3 35       	brlt	80007b7c <_realloc_r+0x1e4>
80007b18:	6e 39       	ld.w	r9,r7[0xc]
80007b1a:	6e 28       	ld.w	r8,r7[0x8]
80007b1c:	93 28       	st.w	r9[0x8],r8
80007b1e:	91 39       	st.w	r8[0xc],r9
80007b20:	e0 ca 00 04 	sub	r10,r0,4
80007b24:	ee cc ff f8 	sub	r12,r7,-8
80007b28:	e0 4a 00 24 	cp.w	r10,36
80007b2c:	e0 8b 00 24 	brhi	80007b74 <_realloc_r+0x1dc>
80007b30:	59 3a       	cp.w	r10,19
80007b32:	e0 88 00 1a 	brls	80007b66 <_realloc_r+0x1ce>
80007b36:	09 08       	ld.w	r8,r4++
80007b38:	99 08       	st.w	r12[0x0],r8
80007b3a:	09 08       	ld.w	r8,r4++
80007b3c:	8f 38       	st.w	r7[0xc],r8
80007b3e:	ee cc ff f0 	sub	r12,r7,-16
80007b42:	59 ba       	cp.w	r10,27
80007b44:	e0 88 00 11 	brls	80007b66 <_realloc_r+0x1ce>
80007b48:	09 08       	ld.w	r8,r4++
80007b4a:	99 08       	st.w	r12[0x0],r8
80007b4c:	09 08       	ld.w	r8,r4++
80007b4e:	8f 58       	st.w	r7[0x14],r8
80007b50:	ee cc ff e8 	sub	r12,r7,-24
80007b54:	e0 4a 00 24 	cp.w	r10,36
80007b58:	c0 71       	brne	80007b66 <_realloc_r+0x1ce>
80007b5a:	09 08       	ld.w	r8,r4++
80007b5c:	99 08       	st.w	r12[0x0],r8
80007b5e:	ee cc ff e0 	sub	r12,r7,-32
80007b62:	09 08       	ld.w	r8,r4++
80007b64:	8f 78       	st.w	r7[0x1c],r8
80007b66:	09 08       	ld.w	r8,r4++
80007b68:	18 a8       	st.w	r12++,r8
80007b6a:	68 08       	ld.w	r8,r4[0x0]
80007b6c:	99 08       	st.w	r12[0x0],r8
80007b6e:	68 18       	ld.w	r8,r4[0x4]
80007b70:	99 18       	st.w	r12[0x4],r8
80007b72:	c4 78       	rjmp	80007c00 <_realloc_r+0x268>
80007b74:	08 9b       	mov	r11,r4
80007b76:	e0 a0 1d 42 	rcall	8000b5fa <memmove>
80007b7a:	c4 38       	rjmp	80007c00 <_realloc_r+0x268>
80007b7c:	04 9c       	mov	r12,r2
80007b7e:	fe b0 fc 45 	rcall	80007408 <_malloc_r>
80007b82:	18 95       	mov	r5,r12
80007b84:	c3 a0       	breq	80007bf8 <_realloc_r+0x260>
80007b86:	62 18       	ld.w	r8,r1[0x4]
80007b88:	f8 c9 00 08 	sub	r9,r12,8
80007b8c:	a1 c8       	cbr	r8,0x0
80007b8e:	e2 08 00 08 	add	r8,r1,r8
80007b92:	10 39       	cp.w	r9,r8
80007b94:	c0 71       	brne	80007ba2 <_realloc_r+0x20a>
80007b96:	72 13       	ld.w	r3,r9[0x4]
80007b98:	02 97       	mov	r7,r1
80007b9a:	e0 13 ff fc 	andl	r3,0xfffc
80007b9e:	00 03       	add	r3,r0
80007ba0:	c3 08       	rjmp	80007c00 <_realloc_r+0x268>
80007ba2:	e0 ca 00 04 	sub	r10,r0,4
80007ba6:	e0 4a 00 24 	cp.w	r10,36
80007baa:	e0 8b 00 20 	brhi	80007bea <_realloc_r+0x252>
80007bae:	08 99       	mov	r9,r4
80007bb0:	18 98       	mov	r8,r12
80007bb2:	59 3a       	cp.w	r10,19
80007bb4:	e0 88 00 14 	brls	80007bdc <_realloc_r+0x244>
80007bb8:	13 0b       	ld.w	r11,r9++
80007bba:	10 ab       	st.w	r8++,r11
80007bbc:	13 0b       	ld.w	r11,r9++
80007bbe:	10 ab       	st.w	r8++,r11
80007bc0:	59 ba       	cp.w	r10,27
80007bc2:	e0 88 00 0d 	brls	80007bdc <_realloc_r+0x244>
80007bc6:	13 0b       	ld.w	r11,r9++
80007bc8:	10 ab       	st.w	r8++,r11
80007bca:	13 0b       	ld.w	r11,r9++
80007bcc:	10 ab       	st.w	r8++,r11
80007bce:	e0 4a 00 24 	cp.w	r10,36
80007bd2:	c0 51       	brne	80007bdc <_realloc_r+0x244>
80007bd4:	13 0a       	ld.w	r10,r9++
80007bd6:	10 aa       	st.w	r8++,r10
80007bd8:	13 0a       	ld.w	r10,r9++
80007bda:	10 aa       	st.w	r8++,r10
80007bdc:	13 0a       	ld.w	r10,r9++
80007bde:	10 aa       	st.w	r8++,r10
80007be0:	72 0a       	ld.w	r10,r9[0x0]
80007be2:	91 0a       	st.w	r8[0x0],r10
80007be4:	72 19       	ld.w	r9,r9[0x4]
80007be6:	91 19       	st.w	r8[0x4],r9
80007be8:	c0 48       	rjmp	80007bf0 <_realloc_r+0x258>
80007bea:	08 9b       	mov	r11,r4
80007bec:	e0 a0 1d 07 	rcall	8000b5fa <memmove>
80007bf0:	08 9b       	mov	r11,r4
80007bf2:	04 9c       	mov	r12,r2
80007bf4:	e0 a0 1a 60 	rcall	8000b0b4 <_free_r>
80007bf8:	04 9c       	mov	r12,r2
80007bfa:	c2 a8       	rjmp	80007c4e <_realloc_r+0x2b6>
80007bfc:	00 93       	mov	r3,r0
80007bfe:	02 97       	mov	r7,r1
80007c00:	e6 06 01 09 	sub	r9,r3,r6
80007c04:	6e 18       	ld.w	r8,r7[0x4]
80007c06:	58 f9       	cp.w	r9,15
80007c08:	e0 88 00 16 	brls	80007c34 <_realloc_r+0x29c>
80007c0c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c10:	ed e8 10 08 	or	r8,r6,r8
80007c14:	8f 18       	st.w	r7[0x4],r8
80007c16:	12 98       	mov	r8,r9
80007c18:	a1 a8       	sbr	r8,0x0
80007c1a:	ee 06 00 0b 	add	r11,r7,r6
80007c1e:	f6 09 00 09 	add	r9,r11,r9
80007c22:	97 18       	st.w	r11[0x4],r8
80007c24:	72 18       	ld.w	r8,r9[0x4]
80007c26:	a1 a8       	sbr	r8,0x0
80007c28:	2f 8b       	sub	r11,-8
80007c2a:	93 18       	st.w	r9[0x4],r8
80007c2c:	04 9c       	mov	r12,r2
80007c2e:	e0 a0 1a 43 	rcall	8000b0b4 <_free_r>
80007c32:	c0 b8       	rjmp	80007c48 <_realloc_r+0x2b0>
80007c34:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c38:	e7 e8 10 08 	or	r8,r3,r8
80007c3c:	8f 18       	st.w	r7[0x4],r8
80007c3e:	ee 03 00 03 	add	r3,r7,r3
80007c42:	66 18       	ld.w	r8,r3[0x4]
80007c44:	a1 a8       	sbr	r8,0x0
80007c46:	87 18       	st.w	r3[0x4],r8
80007c48:	04 9c       	mov	r12,r2
80007c4a:	ee c5 ff f8 	sub	r5,r7,-8
80007c4e:	fe b0 f1 9d 	rcall	80005f88 <__malloc_unlock>
80007c52:	0a 9c       	mov	r12,r5
80007c54:	2f fd       	sub	sp,-4
80007c56:	d8 32       	popm	r0-r7,pc

80007c58 <_sbrk_r>:
80007c58:	d4 21       	pushm	r4-r7,lr
80007c5a:	30 08       	mov	r8,0
80007c5c:	18 97       	mov	r7,r12
80007c5e:	e0 66 bf ec 	mov	r6,49132
80007c62:	16 9c       	mov	r12,r11
80007c64:	8d 08       	st.w	r6[0x0],r8
80007c66:	c8 5c       	rcall	80007d70 <_sbrk>
80007c68:	5b fc       	cp.w	r12,-1
80007c6a:	c0 51       	brne	80007c74 <_sbrk_r+0x1c>
80007c6c:	6c 08       	ld.w	r8,r6[0x0]
80007c6e:	58 08       	cp.w	r8,0
80007c70:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007c74:	d8 22       	popm	r4-r7,pc
80007c76:	d7 03       	nop

80007c78 <sprintf>:
80007c78:	d4 01       	pushm	lr
80007c7a:	21 7d       	sub	sp,92
80007c7c:	e0 68 ff ff 	mov	r8,65535
80007c80:	ea 18 7f ff 	orh	r8,0x7fff
80007c84:	50 58       	stdsp	sp[0x14],r8
80007c86:	50 28       	stdsp	sp[0x8],r8
80007c88:	e0 68 02 08 	mov	r8,520
80007c8c:	ba 68       	st.h	sp[0xc],r8
80007c8e:	3f f8       	mov	r8,-1
80007c90:	ba 78       	st.h	sp[0xe],r8
80007c92:	e0 68 0a 3c 	mov	r8,2620
80007c96:	50 4c       	stdsp	sp[0x10],r12
80007c98:	16 9a       	mov	r10,r11
80007c9a:	50 0c       	stdsp	sp[0x0],r12
80007c9c:	fa c9 ff a0 	sub	r9,sp,-96
80007ca0:	70 0c       	ld.w	r12,r8[0x0]
80007ca2:	1a 9b       	mov	r11,sp
80007ca4:	e0 a0 02 1a 	rcall	800080d8 <_vfprintf_r>
80007ca8:	30 09       	mov	r9,0
80007caa:	40 08       	lddsp	r8,sp[0x0]
80007cac:	b0 89       	st.b	r8[0x0],r9
80007cae:	2e 9d       	sub	sp,-92
80007cb0:	d8 02       	popm	pc
80007cb2:	d7 03       	nop

80007cb4 <strncpy>:
80007cb4:	30 08       	mov	r8,0
80007cb6:	10 3a       	cp.w	r10,r8
80007cb8:	5e 0c       	reteq	r12
80007cba:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007cbe:	f8 08 0b 09 	st.b	r12[r8],r9
80007cc2:	2f f8       	sub	r8,-1
80007cc4:	58 09       	cp.w	r9,0
80007cc6:	cf 81       	brne	80007cb6 <strncpy+0x2>
80007cc8:	10 3a       	cp.w	r10,r8
80007cca:	5e 0c       	reteq	r12
80007ccc:	f8 08 0b 09 	st.b	r12[r8],r9
80007cd0:	2f f8       	sub	r8,-1
80007cd2:	cf bb       	rjmp	80007cc8 <strncpy+0x14>

80007cd4 <_close>:
80007cd4:	30 28       	mov	r8,2
80007cd6:	d6 73       	breakpoint
80007cd8:	3f fc       	mov	r12,-1
80007cda:	35 8b       	mov	r11,88
80007cdc:	58 0c       	cp.w	r12,0
80007cde:	5e 4c       	retge	r12
80007ce0:	e0 6a bf ec 	mov	r10,49132
80007ce4:	95 0b       	st.w	r10[0x0],r11
80007ce6:	5e fc       	retal	r12

80007ce8 <_lseek>:
80007ce8:	30 58       	mov	r8,5
80007cea:	d6 73       	breakpoint
80007cec:	3f fc       	mov	r12,-1
80007cee:	35 8b       	mov	r11,88
80007cf0:	58 0c       	cp.w	r12,0
80007cf2:	5e 4c       	retge	r12
80007cf4:	e0 6a bf ec 	mov	r10,49132
80007cf8:	95 0b       	st.w	r10[0x0],r11
80007cfa:	5e fc       	retal	r12

80007cfc <isatty>:
80007cfc:	30 b8       	mov	r8,11
80007cfe:	d6 73       	breakpoint
80007d00:	3f fc       	mov	r12,-1
80007d02:	35 8b       	mov	r11,88
80007d04:	58 0c       	cp.w	r12,0
80007d06:	5e 4c       	retge	r12
80007d08:	e0 6a bf ec 	mov	r10,49132
80007d0c:	95 0b       	st.w	r10[0x0],r11
80007d0e:	5e fc       	retal	r12

80007d10 <_fstat_host>:
80007d10:	30 98       	mov	r8,9
80007d12:	d6 73       	breakpoint
80007d14:	3f fc       	mov	r12,-1
80007d16:	35 8b       	mov	r11,88
80007d18:	58 0c       	cp.w	r12,0
80007d1a:	5e 4c       	retge	r12
80007d1c:	e0 6a bf ec 	mov	r10,49132
80007d20:	95 0b       	st.w	r10[0x0],r11
80007d22:	5e fc       	retal	r12

80007d24 <_fstat>:
80007d24:	d4 21       	pushm	r4-r7,lr
80007d26:	21 0d       	sub	sp,64
80007d28:	16 97       	mov	r7,r11
80007d2a:	1a 9b       	mov	r11,sp
80007d2c:	cf 2f       	rcall	80007d10 <_fstat_host>
80007d2e:	c0 34       	brge	80007d34 <_fstat+0x10>
80007d30:	3f fc       	mov	r12,-1
80007d32:	c1 c8       	rjmp	80007d6a <_fstat+0x46>
80007d34:	40 08       	lddsp	r8,sp[0x0]
80007d36:	ae 08       	st.h	r7[0x0],r8
80007d38:	40 18       	lddsp	r8,sp[0x4]
80007d3a:	ae 18       	st.h	r7[0x2],r8
80007d3c:	40 28       	lddsp	r8,sp[0x8]
80007d3e:	8f 18       	st.w	r7[0x4],r8
80007d40:	40 38       	lddsp	r8,sp[0xc]
80007d42:	ae 48       	st.h	r7[0x8],r8
80007d44:	40 48       	lddsp	r8,sp[0x10]
80007d46:	ae 58       	st.h	r7[0xa],r8
80007d48:	40 58       	lddsp	r8,sp[0x14]
80007d4a:	ae 68       	st.h	r7[0xc],r8
80007d4c:	40 68       	lddsp	r8,sp[0x18]
80007d4e:	ae 78       	st.h	r7[0xe],r8
80007d50:	40 88       	lddsp	r8,sp[0x20]
80007d52:	8f 48       	st.w	r7[0x10],r8
80007d54:	40 a8       	lddsp	r8,sp[0x28]
80007d56:	8f b8       	st.w	r7[0x2c],r8
80007d58:	40 c8       	lddsp	r8,sp[0x30]
80007d5a:	8f c8       	st.w	r7[0x30],r8
80007d5c:	40 d8       	lddsp	r8,sp[0x34]
80007d5e:	8f 58       	st.w	r7[0x14],r8
80007d60:	40 e8       	lddsp	r8,sp[0x38]
80007d62:	30 0c       	mov	r12,0
80007d64:	8f 78       	st.w	r7[0x1c],r8
80007d66:	40 f8       	lddsp	r8,sp[0x3c]
80007d68:	8f 98       	st.w	r7[0x24],r8
80007d6a:	2f 0d       	sub	sp,-64
80007d6c:	d8 22       	popm	r4-r7,pc
80007d6e:	d7 03       	nop

80007d70 <_sbrk>:
80007d70:	d4 01       	pushm	lr
80007d72:	e0 68 0d 9c 	mov	r8,3484
80007d76:	70 09       	ld.w	r9,r8[0x0]
80007d78:	58 09       	cp.w	r9,0
80007d7a:	c0 41       	brne	80007d82 <_sbrk+0x12>
80007d7c:	e0 69 bf f0 	mov	r9,49136
80007d80:	91 09       	st.w	r8[0x0],r9
80007d82:	e0 69 0d 9c 	mov	r9,3484
80007d86:	e0 7a 70 00 	mov	r10,94208
80007d8a:	72 08       	ld.w	r8,r9[0x0]
80007d8c:	f0 0c 00 0c 	add	r12,r8,r12
80007d90:	14 3c       	cp.w	r12,r10
80007d92:	e0 8b 00 04 	brhi	80007d9a <_sbrk+0x2a>
80007d96:	93 0c       	st.w	r9[0x0],r12
80007d98:	c0 68       	rjmp	80007da4 <_sbrk+0x34>
80007d9a:	e0 a0 18 15 	rcall	8000adc4 <__errno>
80007d9e:	30 c8       	mov	r8,12
80007da0:	99 08       	st.w	r12[0x0],r8
80007da2:	3f f8       	mov	r8,-1
80007da4:	10 9c       	mov	r12,r8
80007da6:	d8 02       	popm	pc

80007da8 <get_arg>:
80007da8:	d4 31       	pushm	r0-r7,lr
80007daa:	20 8d       	sub	sp,32
80007dac:	fa c4 ff bc 	sub	r4,sp,-68
80007db0:	50 4b       	stdsp	sp[0x10],r11
80007db2:	68 2e       	ld.w	lr,r4[0x8]
80007db4:	50 58       	stdsp	sp[0x14],r8
80007db6:	12 96       	mov	r6,r9
80007db8:	7c 0b       	ld.w	r11,lr[0x0]
80007dba:	70 05       	ld.w	r5,r8[0x0]
80007dbc:	50 6e       	stdsp	sp[0x18],lr
80007dbe:	58 0b       	cp.w	r11,0
80007dc0:	f4 0b 17 00 	moveq	r11,r10
80007dc4:	68 03       	ld.w	r3,r4[0x0]
80007dc6:	68 11       	ld.w	r1,r4[0x4]
80007dc8:	40 49       	lddsp	r9,sp[0x10]
80007dca:	30 08       	mov	r8,0
80007dcc:	c2 89       	rjmp	8000801c <get_arg+0x274>
80007dce:	2f fb       	sub	r11,-1
80007dd0:	32 5c       	mov	r12,37
80007dd2:	17 8a       	ld.ub	r10,r11[0x0]
80007dd4:	f8 0a 18 00 	cp.b	r10,r12
80007dd8:	5f 1e       	srne	lr
80007dda:	f0 0a 18 00 	cp.b	r10,r8
80007dde:	5f 1c       	srne	r12
80007de0:	fd ec 00 0c 	and	r12,lr,r12
80007de4:	f0 0c 18 00 	cp.b	r12,r8
80007de8:	cf 31       	brne	80007dce <get_arg+0x26>
80007dea:	58 0a       	cp.w	r10,0
80007dec:	e0 80 01 25 	breq	80008036 <get_arg+0x28e>
80007df0:	30 0c       	mov	r12,0
80007df2:	3f fa       	mov	r10,-1
80007df4:	18 90       	mov	r0,r12
80007df6:	50 3a       	stdsp	sp[0xc],r10
80007df8:	18 94       	mov	r4,r12
80007dfa:	18 92       	mov	r2,r12
80007dfc:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007e00:	16 97       	mov	r7,r11
80007e02:	50 7c       	stdsp	sp[0x1c],r12
80007e04:	fe cc 9e 10 	sub	r12,pc,-25072
80007e08:	0f 3a       	ld.ub	r10,r7++
80007e0a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007e0e:	40 7c       	lddsp	r12,sp[0x1c]
80007e10:	1c 0c       	add	r12,lr
80007e12:	fe ce 9e e6 	sub	lr,pc,-24858
80007e16:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007e1a:	20 1e       	sub	lr,1
80007e1c:	50 0e       	stdsp	sp[0x0],lr
80007e1e:	fe ce 9f 5e 	sub	lr,pc,-24738
80007e22:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007e26:	50 7c       	stdsp	sp[0x1c],r12
80007e28:	40 0c       	lddsp	r12,sp[0x0]
80007e2a:	58 7c       	cp.w	r12,7
80007e2c:	e0 8b 00 f1 	brhi	8000800e <get_arg+0x266>
80007e30:	fe ce a1 10 	sub	lr,pc,-24304
80007e34:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007e38:	36 8b       	mov	r11,104
80007e3a:	f6 0a 18 00 	cp.b	r10,r11
80007e3e:	e0 80 00 e8 	breq	8000800e <get_arg+0x266>
80007e42:	37 1b       	mov	r11,113
80007e44:	f6 0a 18 00 	cp.b	r10,r11
80007e48:	c0 70       	breq	80007e56 <get_arg+0xae>
80007e4a:	34 cb       	mov	r11,76
80007e4c:	f6 0a 18 00 	cp.b	r10,r11
80007e50:	c0 51       	brne	80007e5a <get_arg+0xb2>
80007e52:	a3 b4       	sbr	r4,0x3
80007e54:	cd d8       	rjmp	8000800e <get_arg+0x266>
80007e56:	a5 b4       	sbr	r4,0x5
80007e58:	cd b8       	rjmp	8000800e <get_arg+0x266>
80007e5a:	08 9a       	mov	r10,r4
80007e5c:	0e 9b       	mov	r11,r7
80007e5e:	a5 aa       	sbr	r10,0x4
80007e60:	17 3c       	ld.ub	r12,r11++
80007e62:	a5 b4       	sbr	r4,0x5
80007e64:	36 ce       	mov	lr,108
80007e66:	fc 0c 18 00 	cp.b	r12,lr
80007e6a:	e0 80 00 d3 	breq	80008010 <get_arg+0x268>
80007e6e:	14 94       	mov	r4,r10
80007e70:	cc f8       	rjmp	8000800e <get_arg+0x266>
80007e72:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007e76:	36 7c       	mov	r12,103
80007e78:	f8 0a 18 00 	cp.b	r10,r12
80007e7c:	e0 8b 00 27 	brhi	80007eca <get_arg+0x122>
80007e80:	36 5b       	mov	r11,101
80007e82:	f6 0a 18 00 	cp.b	r10,r11
80007e86:	c4 82       	brcc	80007f16 <get_arg+0x16e>
80007e88:	34 fb       	mov	r11,79
80007e8a:	f6 0a 18 00 	cp.b	r10,r11
80007e8e:	c4 80       	breq	80007f1e <get_arg+0x176>
80007e90:	e0 8b 00 0c 	brhi	80007ea8 <get_arg+0x100>
80007e94:	34 5b       	mov	r11,69
80007e96:	f6 0a 18 00 	cp.b	r10,r11
80007e9a:	c3 e0       	breq	80007f16 <get_arg+0x16e>
80007e9c:	34 7b       	mov	r11,71
80007e9e:	f6 0a 18 00 	cp.b	r10,r11
80007ea2:	c3 a0       	breq	80007f16 <get_arg+0x16e>
80007ea4:	34 4b       	mov	r11,68
80007ea6:	c0 88       	rjmp	80007eb6 <get_arg+0x10e>
80007ea8:	35 8b       	mov	r11,88
80007eaa:	f6 0a 18 00 	cp.b	r10,r11
80007eae:	c2 c0       	breq	80007f06 <get_arg+0x15e>
80007eb0:	e0 8b 00 07 	brhi	80007ebe <get_arg+0x116>
80007eb4:	35 5b       	mov	r11,85
80007eb6:	f6 0a 18 00 	cp.b	r10,r11
80007eba:	c3 51       	brne	80007f24 <get_arg+0x17c>
80007ebc:	c3 18       	rjmp	80007f1e <get_arg+0x176>
80007ebe:	36 3b       	mov	r11,99
80007ec0:	f6 0a 18 00 	cp.b	r10,r11
80007ec4:	c2 f0       	breq	80007f22 <get_arg+0x17a>
80007ec6:	36 4b       	mov	r11,100
80007ec8:	c0 e8       	rjmp	80007ee4 <get_arg+0x13c>
80007eca:	37 0b       	mov	r11,112
80007ecc:	f6 0a 18 00 	cp.b	r10,r11
80007ed0:	c2 50       	breq	80007f1a <get_arg+0x172>
80007ed2:	e0 8b 00 0d 	brhi	80007eec <get_arg+0x144>
80007ed6:	36 eb       	mov	r11,110
80007ed8:	f6 0a 18 00 	cp.b	r10,r11
80007edc:	c1 f0       	breq	80007f1a <get_arg+0x172>
80007ede:	e0 8b 00 14 	brhi	80007f06 <get_arg+0x15e>
80007ee2:	36 9b       	mov	r11,105
80007ee4:	f6 0a 18 00 	cp.b	r10,r11
80007ee8:	c1 e1       	brne	80007f24 <get_arg+0x17c>
80007eea:	c0 e8       	rjmp	80007f06 <get_arg+0x15e>
80007eec:	37 5b       	mov	r11,117
80007eee:	f6 0a 18 00 	cp.b	r10,r11
80007ef2:	c0 a0       	breq	80007f06 <get_arg+0x15e>
80007ef4:	37 8b       	mov	r11,120
80007ef6:	f6 0a 18 00 	cp.b	r10,r11
80007efa:	c0 60       	breq	80007f06 <get_arg+0x15e>
80007efc:	37 3b       	mov	r11,115
80007efe:	f6 0a 18 00 	cp.b	r10,r11
80007f02:	c1 11       	brne	80007f24 <get_arg+0x17c>
80007f04:	c0 b8       	rjmp	80007f1a <get_arg+0x172>
80007f06:	ed b4 00 04 	bld	r4,0x4
80007f0a:	c0 a0       	breq	80007f1e <get_arg+0x176>
80007f0c:	ed b4 00 05 	bld	r4,0x5
80007f10:	c0 91       	brne	80007f22 <get_arg+0x17a>
80007f12:	30 20       	mov	r0,2
80007f14:	c0 88       	rjmp	80007f24 <get_arg+0x17c>
80007f16:	30 40       	mov	r0,4
80007f18:	c0 68       	rjmp	80007f24 <get_arg+0x17c>
80007f1a:	30 30       	mov	r0,3
80007f1c:	c0 48       	rjmp	80007f24 <get_arg+0x17c>
80007f1e:	30 10       	mov	r0,1
80007f20:	c0 28       	rjmp	80007f24 <get_arg+0x17c>
80007f22:	30 00       	mov	r0,0
80007f24:	40 3b       	lddsp	r11,sp[0xc]
80007f26:	5b fb       	cp.w	r11,-1
80007f28:	c0 40       	breq	80007f30 <get_arg+0x188>
80007f2a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007f2e:	c7 08       	rjmp	8000800e <get_arg+0x266>
80007f30:	58 60       	cp.w	r0,6
80007f32:	e0 8b 00 6e 	brhi	8000800e <get_arg+0x266>
80007f36:	6c 0a       	ld.w	r10,r6[0x0]
80007f38:	ea cc ff ff 	sub	r12,r5,-1
80007f3c:	fe ce a1 fc 	sub	lr,pc,-24068
80007f40:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007f44:	f4 cb ff f8 	sub	r11,r10,-8
80007f48:	8d 0b       	st.w	r6[0x0],r11
80007f4a:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f4e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f52:	c0 f8       	rjmp	80007f70 <get_arg+0x1c8>
80007f54:	f4 cb ff fc 	sub	r11,r10,-4
80007f58:	8d 0b       	st.w	r6[0x0],r11
80007f5a:	74 0a       	ld.w	r10,r10[0x0]
80007f5c:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f60:	c0 88       	rjmp	80007f70 <get_arg+0x1c8>
80007f62:	f4 cb ff f8 	sub	r11,r10,-8
80007f66:	8d 0b       	st.w	r6[0x0],r11
80007f68:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f6c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f70:	0e 9b       	mov	r11,r7
80007f72:	18 95       	mov	r5,r12
80007f74:	c4 e8       	rjmp	80008010 <get_arg+0x268>
80007f76:	62 0a       	ld.w	r10,r1[0x0]
80007f78:	5b fa       	cp.w	r10,-1
80007f7a:	c0 b1       	brne	80007f90 <get_arg+0x1e8>
80007f7c:	50 19       	stdsp	sp[0x4],r9
80007f7e:	50 28       	stdsp	sp[0x8],r8
80007f80:	e0 6a 00 80 	mov	r10,128
80007f84:	30 0b       	mov	r11,0
80007f86:	02 9c       	mov	r12,r1
80007f88:	fe b0 fd 00 	rcall	80007988 <memset>
80007f8c:	40 28       	lddsp	r8,sp[0x8]
80007f8e:	40 19       	lddsp	r9,sp[0x4]
80007f90:	e4 cc 00 01 	sub	r12,r2,1
80007f94:	0e 9b       	mov	r11,r7
80007f96:	50 3c       	stdsp	sp[0xc],r12
80007f98:	f2 0c 0c 49 	max	r9,r9,r12
80007f9c:	c3 a8       	rjmp	80008010 <get_arg+0x268>
80007f9e:	62 0a       	ld.w	r10,r1[0x0]
80007fa0:	5b fa       	cp.w	r10,-1
80007fa2:	c0 b1       	brne	80007fb8 <get_arg+0x210>
80007fa4:	50 19       	stdsp	sp[0x4],r9
80007fa6:	50 28       	stdsp	sp[0x8],r8
80007fa8:	e0 6a 00 80 	mov	r10,128
80007fac:	30 0b       	mov	r11,0
80007fae:	02 9c       	mov	r12,r1
80007fb0:	fe b0 fc ec 	rcall	80007988 <memset>
80007fb4:	40 28       	lddsp	r8,sp[0x8]
80007fb6:	40 19       	lddsp	r9,sp[0x4]
80007fb8:	20 12       	sub	r2,1
80007fba:	30 0a       	mov	r10,0
80007fbc:	0e 9b       	mov	r11,r7
80007fbe:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007fc2:	f2 02 0c 49 	max	r9,r9,r2
80007fc6:	c2 58       	rjmp	80008010 <get_arg+0x268>
80007fc8:	16 97       	mov	r7,r11
80007fca:	6c 0a       	ld.w	r10,r6[0x0]
80007fcc:	f4 cb ff fc 	sub	r11,r10,-4
80007fd0:	8d 0b       	st.w	r6[0x0],r11
80007fd2:	74 0a       	ld.w	r10,r10[0x0]
80007fd4:	0e 9b       	mov	r11,r7
80007fd6:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007fda:	2f f5       	sub	r5,-1
80007fdc:	c1 a8       	rjmp	80008010 <get_arg+0x268>
80007fde:	f4 c2 00 30 	sub	r2,r10,48
80007fe2:	c0 68       	rjmp	80007fee <get_arg+0x246>
80007fe4:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007fe8:	2f f7       	sub	r7,-1
80007fea:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007fee:	0f 8a       	ld.ub	r10,r7[0x0]
80007ff0:	58 0a       	cp.w	r10,0
80007ff2:	c0 e0       	breq	8000800e <get_arg+0x266>
80007ff4:	23 0a       	sub	r10,48
80007ff6:	58 9a       	cp.w	r10,9
80007ff8:	fe 98 ff f6 	brls	80007fe4 <get_arg+0x23c>
80007ffc:	c0 98       	rjmp	8000800e <get_arg+0x266>
80007ffe:	2f f7       	sub	r7,-1
80008000:	0f 8a       	ld.ub	r10,r7[0x0]
80008002:	58 0a       	cp.w	r10,0
80008004:	c0 50       	breq	8000800e <get_arg+0x266>
80008006:	23 0a       	sub	r10,48
80008008:	58 9a       	cp.w	r10,9
8000800a:	fe 98 ff fa 	brls	80007ffe <get_arg+0x256>
8000800e:	0e 9b       	mov	r11,r7
80008010:	40 7c       	lddsp	r12,sp[0x1c]
80008012:	30 ba       	mov	r10,11
80008014:	f4 0c 18 00 	cp.b	r12,r10
80008018:	fe 91 fe f2 	brne	80007dfc <get_arg+0x54>
8000801c:	40 42       	lddsp	r2,sp[0x10]
8000801e:	17 8c       	ld.ub	r12,r11[0x0]
80008020:	0a 32       	cp.w	r2,r5
80008022:	5f 4a       	srge	r10
80008024:	f0 0c 18 00 	cp.b	r12,r8
80008028:	5f 1c       	srne	r12
8000802a:	f9 ea 00 0a 	and	r10,r12,r10
8000802e:	f0 0a 18 00 	cp.b	r10,r8
80008032:	fe 91 fe cf 	brne	80007dd0 <get_arg+0x28>
80008036:	30 08       	mov	r8,0
80008038:	40 4e       	lddsp	lr,sp[0x10]
8000803a:	17 8a       	ld.ub	r10,r11[0x0]
8000803c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008040:	f0 0a 18 00 	cp.b	r10,r8
80008044:	fc 09 17 10 	movne	r9,lr
80008048:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000804c:	06 9e       	mov	lr,r3
8000804e:	c2 a8       	rjmp	800080a2 <get_arg+0x2fa>
80008050:	62 0a       	ld.w	r10,r1[0x0]
80008052:	58 3a       	cp.w	r10,3
80008054:	c1 e0       	breq	80008090 <get_arg+0x2e8>
80008056:	e0 89 00 07 	brgt	80008064 <get_arg+0x2bc>
8000805a:	58 1a       	cp.w	r10,1
8000805c:	c1 a0       	breq	80008090 <get_arg+0x2e8>
8000805e:	58 2a       	cp.w	r10,2
80008060:	c1 81       	brne	80008090 <get_arg+0x2e8>
80008062:	c0 58       	rjmp	8000806c <get_arg+0x2c4>
80008064:	58 5a       	cp.w	r10,5
80008066:	c0 c0       	breq	8000807e <get_arg+0x2d6>
80008068:	c0 b5       	brlt	8000807e <get_arg+0x2d6>
8000806a:	c1 38       	rjmp	80008090 <get_arg+0x2e8>
8000806c:	6c 0a       	ld.w	r10,r6[0x0]
8000806e:	f4 cc ff f8 	sub	r12,r10,-8
80008072:	8d 0c       	st.w	r6[0x0],r12
80008074:	f4 e2 00 00 	ld.d	r2,r10[0]
80008078:	f0 e3 00 00 	st.d	r8[0],r2
8000807c:	c1 08       	rjmp	8000809c <get_arg+0x2f4>
8000807e:	6c 0a       	ld.w	r10,r6[0x0]
80008080:	f4 cc ff f8 	sub	r12,r10,-8
80008084:	8d 0c       	st.w	r6[0x0],r12
80008086:	f4 e2 00 00 	ld.d	r2,r10[0]
8000808a:	f0 e3 00 00 	st.d	r8[0],r2
8000808e:	c0 78       	rjmp	8000809c <get_arg+0x2f4>
80008090:	6c 0a       	ld.w	r10,r6[0x0]
80008092:	f4 cc ff fc 	sub	r12,r10,-4
80008096:	8d 0c       	st.w	r6[0x0],r12
80008098:	74 0a       	ld.w	r10,r10[0x0]
8000809a:	91 0a       	st.w	r8[0x0],r10
8000809c:	2f f5       	sub	r5,-1
8000809e:	2f 88       	sub	r8,-8
800080a0:	2f c1       	sub	r1,-4
800080a2:	12 35       	cp.w	r5,r9
800080a4:	fe 9a ff d6 	brle	80008050 <get_arg+0x2a8>
800080a8:	1c 93       	mov	r3,lr
800080aa:	40 52       	lddsp	r2,sp[0x14]
800080ac:	40 6e       	lddsp	lr,sp[0x18]
800080ae:	85 05       	st.w	r2[0x0],r5
800080b0:	9d 0b       	st.w	lr[0x0],r11
800080b2:	40 4b       	lddsp	r11,sp[0x10]
800080b4:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800080b8:	2f 8d       	sub	sp,-32
800080ba:	d8 32       	popm	r0-r7,pc

800080bc <__sprint_r>:
800080bc:	d4 21       	pushm	r4-r7,lr
800080be:	14 97       	mov	r7,r10
800080c0:	74 28       	ld.w	r8,r10[0x8]
800080c2:	58 08       	cp.w	r8,0
800080c4:	c0 41       	brne	800080cc <__sprint_r+0x10>
800080c6:	95 18       	st.w	r10[0x4],r8
800080c8:	10 9c       	mov	r12,r8
800080ca:	d8 22       	popm	r4-r7,pc
800080cc:	e0 a0 18 ba 	rcall	8000b240 <__sfvwrite_r>
800080d0:	30 08       	mov	r8,0
800080d2:	8f 18       	st.w	r7[0x4],r8
800080d4:	8f 28       	st.w	r7[0x8],r8
800080d6:	d8 22       	popm	r4-r7,pc

800080d8 <_vfprintf_r>:
800080d8:	d4 31       	pushm	r0-r7,lr
800080da:	fa cd 06 bc 	sub	sp,sp,1724
800080de:	51 09       	stdsp	sp[0x40],r9
800080e0:	16 91       	mov	r1,r11
800080e2:	14 97       	mov	r7,r10
800080e4:	18 95       	mov	r5,r12
800080e6:	e0 a0 1a 1d 	rcall	8000b520 <_localeconv_r>
800080ea:	78 0c       	ld.w	r12,r12[0x0]
800080ec:	50 cc       	stdsp	sp[0x30],r12
800080ee:	58 05       	cp.w	r5,0
800080f0:	c0 70       	breq	800080fe <_vfprintf_r+0x26>
800080f2:	6a 68       	ld.w	r8,r5[0x18]
800080f4:	58 08       	cp.w	r8,0
800080f6:	c0 41       	brne	800080fe <_vfprintf_r+0x26>
800080f8:	0a 9c       	mov	r12,r5
800080fa:	e0 a0 17 43 	rcall	8000af80 <__sinit>
800080fe:	fe c8 9f fa 	sub	r8,pc,-24582
80008102:	10 31       	cp.w	r1,r8
80008104:	c0 31       	brne	8000810a <_vfprintf_r+0x32>
80008106:	6a 01       	ld.w	r1,r5[0x0]
80008108:	c0 c8       	rjmp	80008120 <_vfprintf_r+0x48>
8000810a:	fe c8 9f e6 	sub	r8,pc,-24602
8000810e:	10 31       	cp.w	r1,r8
80008110:	c0 31       	brne	80008116 <_vfprintf_r+0x3e>
80008112:	6a 11       	ld.w	r1,r5[0x4]
80008114:	c0 68       	rjmp	80008120 <_vfprintf_r+0x48>
80008116:	fe c8 9f d2 	sub	r8,pc,-24622
8000811a:	10 31       	cp.w	r1,r8
8000811c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008120:	82 68       	ld.sh	r8,r1[0xc]
80008122:	ed b8 00 03 	bld	r8,0x3
80008126:	c0 41       	brne	8000812e <_vfprintf_r+0x56>
80008128:	62 48       	ld.w	r8,r1[0x10]
8000812a:	58 08       	cp.w	r8,0
8000812c:	c0 71       	brne	8000813a <_vfprintf_r+0x62>
8000812e:	02 9b       	mov	r11,r1
80008130:	0a 9c       	mov	r12,r5
80008132:	e0 a0 0f 5d 	rcall	80009fec <__swsetup_r>
80008136:	e0 81 0f 54 	brne	80009fde <_vfprintf_r+0x1f06>
8000813a:	82 68       	ld.sh	r8,r1[0xc]
8000813c:	10 99       	mov	r9,r8
8000813e:	e2 19 00 1a 	andl	r9,0x1a,COH
80008142:	58 a9       	cp.w	r9,10
80008144:	c3 c1       	brne	800081bc <_vfprintf_r+0xe4>
80008146:	82 79       	ld.sh	r9,r1[0xe]
80008148:	30 0a       	mov	r10,0
8000814a:	f4 09 19 00 	cp.h	r9,r10
8000814e:	c3 75       	brlt	800081bc <_vfprintf_r+0xe4>
80008150:	a1 d8       	cbr	r8,0x1
80008152:	fb 58 05 d0 	st.h	sp[1488],r8
80008156:	62 88       	ld.w	r8,r1[0x20]
80008158:	fb 48 05 e4 	st.w	sp[1508],r8
8000815c:	62 a8       	ld.w	r8,r1[0x28]
8000815e:	fb 48 05 ec 	st.w	sp[1516],r8
80008162:	fa c8 ff bc 	sub	r8,sp,-68
80008166:	fb 48 05 d4 	st.w	sp[1492],r8
8000816a:	fb 48 05 c4 	st.w	sp[1476],r8
8000816e:	e0 68 04 00 	mov	r8,1024
80008172:	fb 48 05 d8 	st.w	sp[1496],r8
80008176:	fb 48 05 cc 	st.w	sp[1484],r8
8000817a:	30 08       	mov	r8,0
8000817c:	fb 59 05 d2 	st.h	sp[1490],r9
80008180:	0e 9a       	mov	r10,r7
80008182:	41 09       	lddsp	r9,sp[0x40]
80008184:	fa c7 fa 3c 	sub	r7,sp,-1476
80008188:	fb 48 05 dc 	st.w	sp[1500],r8
8000818c:	0a 9c       	mov	r12,r5
8000818e:	0e 9b       	mov	r11,r7
80008190:	ca 4f       	rcall	800080d8 <_vfprintf_r>
80008192:	50 bc       	stdsp	sp[0x2c],r12
80008194:	c0 95       	brlt	800081a6 <_vfprintf_r+0xce>
80008196:	0e 9b       	mov	r11,r7
80008198:	0a 9c       	mov	r12,r5
8000819a:	e0 a0 16 1b 	rcall	8000add0 <_fflush_r>
8000819e:	40 be       	lddsp	lr,sp[0x2c]
800081a0:	f9 be 01 ff 	movne	lr,-1
800081a4:	50 be       	stdsp	sp[0x2c],lr
800081a6:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800081aa:	ed b8 00 06 	bld	r8,0x6
800081ae:	e0 81 0f 1a 	brne	80009fe2 <_vfprintf_r+0x1f0a>
800081b2:	82 68       	ld.sh	r8,r1[0xc]
800081b4:	a7 a8       	sbr	r8,0x6
800081b6:	a2 68       	st.h	r1[0xc],r8
800081b8:	e0 8f 0f 15 	bral	80009fe2 <_vfprintf_r+0x1f0a>
800081bc:	30 08       	mov	r8,0
800081be:	fb 48 06 b4 	st.w	sp[1716],r8
800081c2:	fb 48 06 90 	st.w	sp[1680],r8
800081c6:	fb 48 06 8c 	st.w	sp[1676],r8
800081ca:	fb 48 06 b0 	st.w	sp[1712],r8
800081ce:	30 08       	mov	r8,0
800081d0:	30 09       	mov	r9,0
800081d2:	50 a7       	stdsp	sp[0x28],r7
800081d4:	50 78       	stdsp	sp[0x1c],r8
800081d6:	fa c3 f9 e0 	sub	r3,sp,-1568
800081da:	3f f8       	mov	r8,-1
800081dc:	50 59       	stdsp	sp[0x14],r9
800081de:	fb 43 06 88 	st.w	sp[1672],r3
800081e2:	fb 48 05 44 	st.w	sp[1348],r8
800081e6:	12 9c       	mov	r12,r9
800081e8:	50 69       	stdsp	sp[0x18],r9
800081ea:	50 d9       	stdsp	sp[0x34],r9
800081ec:	50 e9       	stdsp	sp[0x38],r9
800081ee:	50 b9       	stdsp	sp[0x2c],r9
800081f0:	12 97       	mov	r7,r9
800081f2:	0a 94       	mov	r4,r5
800081f4:	40 a2       	lddsp	r2,sp[0x28]
800081f6:	32 5a       	mov	r10,37
800081f8:	30 08       	mov	r8,0
800081fa:	c0 28       	rjmp	800081fe <_vfprintf_r+0x126>
800081fc:	2f f2       	sub	r2,-1
800081fe:	05 89       	ld.ub	r9,r2[0x0]
80008200:	f0 09 18 00 	cp.b	r9,r8
80008204:	5f 1b       	srne	r11
80008206:	f4 09 18 00 	cp.b	r9,r10
8000820a:	5f 19       	srne	r9
8000820c:	f3 eb 00 0b 	and	r11,r9,r11
80008210:	f0 0b 18 00 	cp.b	r11,r8
80008214:	cf 41       	brne	800081fc <_vfprintf_r+0x124>
80008216:	40 ab       	lddsp	r11,sp[0x28]
80008218:	e4 0b 01 06 	sub	r6,r2,r11
8000821c:	c1 e0       	breq	80008258 <_vfprintf_r+0x180>
8000821e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008222:	0c 08       	add	r8,r6
80008224:	87 0b       	st.w	r3[0x0],r11
80008226:	fb 48 06 90 	st.w	sp[1680],r8
8000822a:	87 16       	st.w	r3[0x4],r6
8000822c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008230:	2f f8       	sub	r8,-1
80008232:	fb 48 06 8c 	st.w	sp[1676],r8
80008236:	58 78       	cp.w	r8,7
80008238:	e0 89 00 04 	brgt	80008240 <_vfprintf_r+0x168>
8000823c:	2f 83       	sub	r3,-8
8000823e:	c0 a8       	rjmp	80008252 <_vfprintf_r+0x17a>
80008240:	fa ca f9 78 	sub	r10,sp,-1672
80008244:	02 9b       	mov	r11,r1
80008246:	08 9c       	mov	r12,r4
80008248:	c3 af       	rcall	800080bc <__sprint_r>
8000824a:	e0 81 0e c6 	brne	80009fd6 <_vfprintf_r+0x1efe>
8000824e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008252:	40 ba       	lddsp	r10,sp[0x2c]
80008254:	0c 0a       	add	r10,r6
80008256:	50 ba       	stdsp	sp[0x2c],r10
80008258:	05 89       	ld.ub	r9,r2[0x0]
8000825a:	30 08       	mov	r8,0
8000825c:	f0 09 18 00 	cp.b	r9,r8
80008260:	e0 80 0e aa 	breq	80009fb4 <_vfprintf_r+0x1edc>
80008264:	30 09       	mov	r9,0
80008266:	fb 68 06 bb 	st.b	sp[1723],r8
8000826a:	0e 96       	mov	r6,r7
8000826c:	e4 c8 ff ff 	sub	r8,r2,-1
80008270:	3f fe       	mov	lr,-1
80008272:	50 93       	stdsp	sp[0x24],r3
80008274:	50 41       	stdsp	sp[0x10],r1
80008276:	0e 93       	mov	r3,r7
80008278:	04 91       	mov	r1,r2
8000827a:	50 89       	stdsp	sp[0x20],r9
8000827c:	50 a8       	stdsp	sp[0x28],r8
8000827e:	50 2e       	stdsp	sp[0x8],lr
80008280:	50 39       	stdsp	sp[0xc],r9
80008282:	12 95       	mov	r5,r9
80008284:	12 90       	mov	r0,r9
80008286:	10 97       	mov	r7,r8
80008288:	08 92       	mov	r2,r4
8000828a:	c0 78       	rjmp	80008298 <_vfprintf_r+0x1c0>
8000828c:	3f fc       	mov	r12,-1
8000828e:	08 97       	mov	r7,r4
80008290:	50 2c       	stdsp	sp[0x8],r12
80008292:	c0 38       	rjmp	80008298 <_vfprintf_r+0x1c0>
80008294:	30 0b       	mov	r11,0
80008296:	50 3b       	stdsp	sp[0xc],r11
80008298:	0f 38       	ld.ub	r8,r7++
8000829a:	c0 28       	rjmp	8000829e <_vfprintf_r+0x1c6>
8000829c:	12 90       	mov	r0,r9
8000829e:	f0 c9 00 20 	sub	r9,r8,32
800082a2:	e0 49 00 58 	cp.w	r9,88
800082a6:	e0 8b 0a 30 	brhi	80009706 <_vfprintf_r+0x162e>
800082aa:	fe ca a5 4e 	sub	r10,pc,-23218
800082ae:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800082b2:	50 a7       	stdsp	sp[0x28],r7
800082b4:	50 80       	stdsp	sp[0x20],r0
800082b6:	0c 97       	mov	r7,r6
800082b8:	04 94       	mov	r4,r2
800082ba:	06 96       	mov	r6,r3
800082bc:	02 92       	mov	r2,r1
800082be:	fe c9 a3 26 	sub	r9,pc,-23770
800082c2:	40 93       	lddsp	r3,sp[0x24]
800082c4:	10 90       	mov	r0,r8
800082c6:	40 41       	lddsp	r1,sp[0x10]
800082c8:	50 d9       	stdsp	sp[0x34],r9
800082ca:	e0 8f 08 8e 	bral	800093e6 <_vfprintf_r+0x130e>
800082ce:	30 08       	mov	r8,0
800082d0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800082d4:	f0 09 18 00 	cp.b	r9,r8
800082d8:	ce 01       	brne	80008298 <_vfprintf_r+0x1c0>
800082da:	32 08       	mov	r8,32
800082dc:	c6 e8       	rjmp	800083b8 <_vfprintf_r+0x2e0>
800082de:	a1 a5       	sbr	r5,0x0
800082e0:	cd cb       	rjmp	80008298 <_vfprintf_r+0x1c0>
800082e2:	0f 89       	ld.ub	r9,r7[0x0]
800082e4:	f2 c8 00 30 	sub	r8,r9,48
800082e8:	58 98       	cp.w	r8,9
800082ea:	e0 8b 00 1d 	brhi	80008324 <_vfprintf_r+0x24c>
800082ee:	ee c8 ff ff 	sub	r8,r7,-1
800082f2:	30 0b       	mov	r11,0
800082f4:	23 09       	sub	r9,48
800082f6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800082fa:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800082fe:	11 39       	ld.ub	r9,r8++
80008300:	f2 ca 00 30 	sub	r10,r9,48
80008304:	58 9a       	cp.w	r10,9
80008306:	fe 98 ff f7 	brls	800082f4 <_vfprintf_r+0x21c>
8000830a:	e0 49 00 24 	cp.w	r9,36
8000830e:	cc 31       	brne	80008294 <_vfprintf_r+0x1bc>
80008310:	e0 4b 00 20 	cp.w	r11,32
80008314:	e0 89 0e 60 	brgt	80009fd4 <_vfprintf_r+0x1efc>
80008318:	20 1b       	sub	r11,1
8000831a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000831e:	12 3b       	cp.w	r11,r9
80008320:	c0 95       	brlt	80008332 <_vfprintf_r+0x25a>
80008322:	c1 08       	rjmp	80008342 <_vfprintf_r+0x26a>
80008324:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008328:	ec ca ff ff 	sub	r10,r6,-1
8000832c:	12 36       	cp.w	r6,r9
8000832e:	c1 f5       	brlt	8000836c <_vfprintf_r+0x294>
80008330:	c2 68       	rjmp	8000837c <_vfprintf_r+0x2a4>
80008332:	fa ce f9 44 	sub	lr,sp,-1724
80008336:	10 97       	mov	r7,r8
80008338:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000833c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008340:	c3 58       	rjmp	800083aa <_vfprintf_r+0x2d2>
80008342:	10 97       	mov	r7,r8
80008344:	fa c8 f9 50 	sub	r8,sp,-1712
80008348:	1a d8       	st.w	--sp,r8
8000834a:	fa c8 fa b8 	sub	r8,sp,-1352
8000834e:	1a d8       	st.w	--sp,r8
80008350:	fa c8 fb b4 	sub	r8,sp,-1100
80008354:	02 9a       	mov	r10,r1
80008356:	1a d8       	st.w	--sp,r8
80008358:	04 9c       	mov	r12,r2
8000835a:	fa c8 f9 40 	sub	r8,sp,-1728
8000835e:	fa c9 ff b4 	sub	r9,sp,-76
80008362:	fe b0 fd 23 	rcall	80007da8 <get_arg>
80008366:	2f dd       	sub	sp,-12
80008368:	78 00       	ld.w	r0,r12[0x0]
8000836a:	c2 08       	rjmp	800083aa <_vfprintf_r+0x2d2>
8000836c:	fa cc f9 44 	sub	r12,sp,-1724
80008370:	14 96       	mov	r6,r10
80008372:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008376:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000837a:	c1 88       	rjmp	800083aa <_vfprintf_r+0x2d2>
8000837c:	41 08       	lddsp	r8,sp[0x40]
8000837e:	59 f9       	cp.w	r9,31
80008380:	e0 89 00 11 	brgt	800083a2 <_vfprintf_r+0x2ca>
80008384:	f0 cb ff fc 	sub	r11,r8,-4
80008388:	51 0b       	stdsp	sp[0x40],r11
8000838a:	70 00       	ld.w	r0,r8[0x0]
8000838c:	fa cb f9 44 	sub	r11,sp,-1724
80008390:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008394:	f1 40 fd 88 	st.w	r8[-632],r0
80008398:	2f f9       	sub	r9,-1
8000839a:	14 96       	mov	r6,r10
8000839c:	fb 49 06 b4 	st.w	sp[1716],r9
800083a0:	c0 58       	rjmp	800083aa <_vfprintf_r+0x2d2>
800083a2:	70 00       	ld.w	r0,r8[0x0]
800083a4:	14 96       	mov	r6,r10
800083a6:	2f c8       	sub	r8,-4
800083a8:	51 08       	stdsp	sp[0x40],r8
800083aa:	58 00       	cp.w	r0,0
800083ac:	fe 94 ff 76 	brge	80008298 <_vfprintf_r+0x1c0>
800083b0:	5c 30       	neg	r0
800083b2:	a3 a5       	sbr	r5,0x2
800083b4:	c7 2b       	rjmp	80008298 <_vfprintf_r+0x1c0>
800083b6:	32 b8       	mov	r8,43
800083b8:	fb 68 06 bb 	st.b	sp[1723],r8
800083bc:	c6 eb       	rjmp	80008298 <_vfprintf_r+0x1c0>
800083be:	0f 38       	ld.ub	r8,r7++
800083c0:	e0 48 00 2a 	cp.w	r8,42
800083c4:	c0 30       	breq	800083ca <_vfprintf_r+0x2f2>
800083c6:	30 09       	mov	r9,0
800083c8:	c7 98       	rjmp	800084ba <_vfprintf_r+0x3e2>
800083ca:	0f 88       	ld.ub	r8,r7[0x0]
800083cc:	f0 c9 00 30 	sub	r9,r8,48
800083d0:	58 99       	cp.w	r9,9
800083d2:	e0 8b 00 1f 	brhi	80008410 <_vfprintf_r+0x338>
800083d6:	ee c4 ff ff 	sub	r4,r7,-1
800083da:	30 0b       	mov	r11,0
800083dc:	23 08       	sub	r8,48
800083de:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800083e2:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800083e6:	09 38       	ld.ub	r8,r4++
800083e8:	f0 c9 00 30 	sub	r9,r8,48
800083ec:	58 99       	cp.w	r9,9
800083ee:	fe 98 ff f7 	brls	800083dc <_vfprintf_r+0x304>
800083f2:	e0 48 00 24 	cp.w	r8,36
800083f6:	fe 91 ff 4f 	brne	80008294 <_vfprintf_r+0x1bc>
800083fa:	e0 4b 00 20 	cp.w	r11,32
800083fe:	e0 89 0d eb 	brgt	80009fd4 <_vfprintf_r+0x1efc>
80008402:	20 1b       	sub	r11,1
80008404:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008408:	10 3b       	cp.w	r11,r8
8000840a:	c0 a5       	brlt	8000841e <_vfprintf_r+0x346>
8000840c:	c1 18       	rjmp	8000842e <_vfprintf_r+0x356>
8000840e:	d7 03       	nop
80008410:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008414:	ec c9 ff ff 	sub	r9,r6,-1
80008418:	14 36       	cp.w	r6,r10
8000841a:	c1 f5       	brlt	80008458 <_vfprintf_r+0x380>
8000841c:	c2 88       	rjmp	8000846c <_vfprintf_r+0x394>
8000841e:	fa ca f9 44 	sub	r10,sp,-1724
80008422:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008426:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000842a:	50 2b       	stdsp	sp[0x8],r11
8000842c:	c3 c8       	rjmp	800084a4 <_vfprintf_r+0x3cc>
8000842e:	fa c8 f9 50 	sub	r8,sp,-1712
80008432:	1a d8       	st.w	--sp,r8
80008434:	fa c8 fa b8 	sub	r8,sp,-1352
80008438:	1a d8       	st.w	--sp,r8
8000843a:	fa c8 fb b4 	sub	r8,sp,-1100
8000843e:	02 9a       	mov	r10,r1
80008440:	1a d8       	st.w	--sp,r8
80008442:	04 9c       	mov	r12,r2
80008444:	fa c8 f9 40 	sub	r8,sp,-1728
80008448:	fa c9 ff b4 	sub	r9,sp,-76
8000844c:	fe b0 fc ae 	rcall	80007da8 <get_arg>
80008450:	2f dd       	sub	sp,-12
80008452:	78 0c       	ld.w	r12,r12[0x0]
80008454:	50 2c       	stdsp	sp[0x8],r12
80008456:	c2 78       	rjmp	800084a4 <_vfprintf_r+0x3cc>
80008458:	12 96       	mov	r6,r9
8000845a:	0e 94       	mov	r4,r7
8000845c:	fa c9 f9 44 	sub	r9,sp,-1724
80008460:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008464:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008468:	50 28       	stdsp	sp[0x8],r8
8000846a:	c1 d8       	rjmp	800084a4 <_vfprintf_r+0x3cc>
8000846c:	41 08       	lddsp	r8,sp[0x40]
8000846e:	59 fa       	cp.w	r10,31
80008470:	e0 89 00 14 	brgt	80008498 <_vfprintf_r+0x3c0>
80008474:	f0 cb ff fc 	sub	r11,r8,-4
80008478:	70 08       	ld.w	r8,r8[0x0]
8000847a:	51 0b       	stdsp	sp[0x40],r11
8000847c:	50 28       	stdsp	sp[0x8],r8
8000847e:	fa c6 f9 44 	sub	r6,sp,-1724
80008482:	40 2e       	lddsp	lr,sp[0x8]
80008484:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008488:	f1 4e fd 88 	st.w	r8[-632],lr
8000848c:	2f fa       	sub	r10,-1
8000848e:	0e 94       	mov	r4,r7
80008490:	fb 4a 06 b4 	st.w	sp[1716],r10
80008494:	12 96       	mov	r6,r9
80008496:	c0 78       	rjmp	800084a4 <_vfprintf_r+0x3cc>
80008498:	70 0c       	ld.w	r12,r8[0x0]
8000849a:	0e 94       	mov	r4,r7
8000849c:	2f c8       	sub	r8,-4
8000849e:	50 2c       	stdsp	sp[0x8],r12
800084a0:	12 96       	mov	r6,r9
800084a2:	51 08       	stdsp	sp[0x40],r8
800084a4:	40 2b       	lddsp	r11,sp[0x8]
800084a6:	58 0b       	cp.w	r11,0
800084a8:	fe 95 fe f2 	brlt	8000828c <_vfprintf_r+0x1b4>
800084ac:	08 97       	mov	r7,r4
800084ae:	cf 5a       	rjmp	80008298 <_vfprintf_r+0x1c0>
800084b0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800084b4:	0f 38       	ld.ub	r8,r7++
800084b6:	f4 09 00 19 	add	r9,r10,r9<<0x1
800084ba:	f0 ca 00 30 	sub	r10,r8,48
800084be:	58 9a       	cp.w	r10,9
800084c0:	fe 98 ff f8 	brls	800084b0 <_vfprintf_r+0x3d8>
800084c4:	3f fa       	mov	r10,-1
800084c6:	f2 0a 0c 49 	max	r9,r9,r10
800084ca:	50 29       	stdsp	sp[0x8],r9
800084cc:	ce 9a       	rjmp	8000829e <_vfprintf_r+0x1c6>
800084ce:	a7 b5       	sbr	r5,0x7
800084d0:	ce 4a       	rjmp	80008298 <_vfprintf_r+0x1c0>
800084d2:	30 09       	mov	r9,0
800084d4:	23 08       	sub	r8,48
800084d6:	f2 09 00 29 	add	r9,r9,r9<<0x2
800084da:	f0 09 00 19 	add	r9,r8,r9<<0x1
800084de:	0f 38       	ld.ub	r8,r7++
800084e0:	f0 ca 00 30 	sub	r10,r8,48
800084e4:	58 9a       	cp.w	r10,9
800084e6:	fe 98 ff f7 	brls	800084d4 <_vfprintf_r+0x3fc>
800084ea:	e0 48 00 24 	cp.w	r8,36
800084ee:	fe 91 fe d7 	brne	8000829c <_vfprintf_r+0x1c4>
800084f2:	e0 49 00 20 	cp.w	r9,32
800084f6:	e0 89 0d 6f 	brgt	80009fd4 <_vfprintf_r+0x1efc>
800084fa:	f2 c3 00 01 	sub	r3,r9,1
800084fe:	30 19       	mov	r9,1
80008500:	50 39       	stdsp	sp[0xc],r9
80008502:	cc ba       	rjmp	80008298 <_vfprintf_r+0x1c0>
80008504:	a3 b5       	sbr	r5,0x3
80008506:	cc 9a       	rjmp	80008298 <_vfprintf_r+0x1c0>
80008508:	a7 a5       	sbr	r5,0x6
8000850a:	cc 7a       	rjmp	80008298 <_vfprintf_r+0x1c0>
8000850c:	0a 98       	mov	r8,r5
8000850e:	a5 b5       	sbr	r5,0x5
80008510:	a5 a8       	sbr	r8,0x4
80008512:	0f 89       	ld.ub	r9,r7[0x0]
80008514:	36 ce       	mov	lr,108
80008516:	fc 09 18 00 	cp.b	r9,lr
8000851a:	f7 b7 00 ff 	subeq	r7,-1
8000851e:	f0 05 17 10 	movne	r5,r8
80008522:	cb ba       	rjmp	80008298 <_vfprintf_r+0x1c0>
80008524:	a5 b5       	sbr	r5,0x5
80008526:	cb 9a       	rjmp	80008298 <_vfprintf_r+0x1c0>
80008528:	50 a7       	stdsp	sp[0x28],r7
8000852a:	50 80       	stdsp	sp[0x20],r0
8000852c:	0c 97       	mov	r7,r6
8000852e:	10 90       	mov	r0,r8
80008530:	06 96       	mov	r6,r3
80008532:	04 94       	mov	r4,r2
80008534:	40 93       	lddsp	r3,sp[0x24]
80008536:	02 92       	mov	r2,r1
80008538:	0e 99       	mov	r9,r7
8000853a:	40 41       	lddsp	r1,sp[0x10]
8000853c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008540:	40 3c       	lddsp	r12,sp[0xc]
80008542:	58 0c       	cp.w	r12,0
80008544:	c1 d0       	breq	8000857e <_vfprintf_r+0x4a6>
80008546:	10 36       	cp.w	r6,r8
80008548:	c0 64       	brge	80008554 <_vfprintf_r+0x47c>
8000854a:	fa cb f9 44 	sub	r11,sp,-1724
8000854e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008552:	c1 d8       	rjmp	8000858c <_vfprintf_r+0x4b4>
80008554:	fa c8 f9 50 	sub	r8,sp,-1712
80008558:	1a d8       	st.w	--sp,r8
8000855a:	fa c8 fa b8 	sub	r8,sp,-1352
8000855e:	1a d8       	st.w	--sp,r8
80008560:	fa c8 fb b4 	sub	r8,sp,-1100
80008564:	1a d8       	st.w	--sp,r8
80008566:	fa c8 f9 40 	sub	r8,sp,-1728
8000856a:	fa c9 ff b4 	sub	r9,sp,-76
8000856e:	04 9a       	mov	r10,r2
80008570:	0c 9b       	mov	r11,r6
80008572:	08 9c       	mov	r12,r4
80008574:	fe b0 fc 1a 	rcall	80007da8 <get_arg>
80008578:	2f dd       	sub	sp,-12
8000857a:	19 b8       	ld.ub	r8,r12[0x3]
8000857c:	c2 28       	rjmp	800085c0 <_vfprintf_r+0x4e8>
8000857e:	2f f7       	sub	r7,-1
80008580:	10 39       	cp.w	r9,r8
80008582:	c0 84       	brge	80008592 <_vfprintf_r+0x4ba>
80008584:	fa ca f9 44 	sub	r10,sp,-1724
80008588:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000858c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008590:	c1 88       	rjmp	800085c0 <_vfprintf_r+0x4e8>
80008592:	41 09       	lddsp	r9,sp[0x40]
80008594:	59 f8       	cp.w	r8,31
80008596:	e0 89 00 12 	brgt	800085ba <_vfprintf_r+0x4e2>
8000859a:	f2 ca ff fc 	sub	r10,r9,-4
8000859e:	51 0a       	stdsp	sp[0x40],r10
800085a0:	72 09       	ld.w	r9,r9[0x0]
800085a2:	fa c6 f9 44 	sub	r6,sp,-1724
800085a6:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800085aa:	2f f8       	sub	r8,-1
800085ac:	f5 49 fd 88 	st.w	r10[-632],r9
800085b0:	fb 48 06 b4 	st.w	sp[1716],r8
800085b4:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800085b8:	c0 48       	rjmp	800085c0 <_vfprintf_r+0x4e8>
800085ba:	13 b8       	ld.ub	r8,r9[0x3]
800085bc:	2f c9       	sub	r9,-4
800085be:	51 09       	stdsp	sp[0x40],r9
800085c0:	fb 68 06 60 	st.b	sp[1632],r8
800085c4:	30 0e       	mov	lr,0
800085c6:	30 08       	mov	r8,0
800085c8:	30 12       	mov	r2,1
800085ca:	fb 68 06 bb 	st.b	sp[1723],r8
800085ce:	50 2e       	stdsp	sp[0x8],lr
800085d0:	e0 8f 08 ad 	bral	8000972a <_vfprintf_r+0x1652>
800085d4:	50 a7       	stdsp	sp[0x28],r7
800085d6:	50 80       	stdsp	sp[0x20],r0
800085d8:	0c 97       	mov	r7,r6
800085da:	04 94       	mov	r4,r2
800085dc:	06 96       	mov	r6,r3
800085de:	02 92       	mov	r2,r1
800085e0:	40 93       	lddsp	r3,sp[0x24]
800085e2:	10 90       	mov	r0,r8
800085e4:	40 41       	lddsp	r1,sp[0x10]
800085e6:	a5 a5       	sbr	r5,0x4
800085e8:	c0 a8       	rjmp	800085fc <_vfprintf_r+0x524>
800085ea:	50 a7       	stdsp	sp[0x28],r7
800085ec:	50 80       	stdsp	sp[0x20],r0
800085ee:	0c 97       	mov	r7,r6
800085f0:	04 94       	mov	r4,r2
800085f2:	06 96       	mov	r6,r3
800085f4:	02 92       	mov	r2,r1
800085f6:	40 93       	lddsp	r3,sp[0x24]
800085f8:	10 90       	mov	r0,r8
800085fa:	40 41       	lddsp	r1,sp[0x10]
800085fc:	ed b5 00 05 	bld	r5,0x5
80008600:	c5 11       	brne	800086a2 <_vfprintf_r+0x5ca>
80008602:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008606:	40 3c       	lddsp	r12,sp[0xc]
80008608:	58 0c       	cp.w	r12,0
8000860a:	c1 e0       	breq	80008646 <_vfprintf_r+0x56e>
8000860c:	10 36       	cp.w	r6,r8
8000860e:	c0 64       	brge	8000861a <_vfprintf_r+0x542>
80008610:	fa cb f9 44 	sub	r11,sp,-1724
80008614:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008618:	c2 08       	rjmp	80008658 <_vfprintf_r+0x580>
8000861a:	fa c8 f9 50 	sub	r8,sp,-1712
8000861e:	1a d8       	st.w	--sp,r8
80008620:	fa c8 fa b8 	sub	r8,sp,-1352
80008624:	0c 9b       	mov	r11,r6
80008626:	1a d8       	st.w	--sp,r8
80008628:	fa c8 fb b4 	sub	r8,sp,-1100
8000862c:	1a d8       	st.w	--sp,r8
8000862e:	fa c9 ff b4 	sub	r9,sp,-76
80008632:	fa c8 f9 40 	sub	r8,sp,-1728
80008636:	04 9a       	mov	r10,r2
80008638:	08 9c       	mov	r12,r4
8000863a:	fe b0 fb b7 	rcall	80007da8 <get_arg>
8000863e:	2f dd       	sub	sp,-12
80008640:	78 1b       	ld.w	r11,r12[0x4]
80008642:	78 09       	ld.w	r9,r12[0x0]
80008644:	c2 b8       	rjmp	8000869a <_vfprintf_r+0x5c2>
80008646:	ee ca ff ff 	sub	r10,r7,-1
8000864a:	10 37       	cp.w	r7,r8
8000864c:	c0 b4       	brge	80008662 <_vfprintf_r+0x58a>
8000864e:	fa c9 f9 44 	sub	r9,sp,-1724
80008652:	14 97       	mov	r7,r10
80008654:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008658:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000865c:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008660:	c1 d8       	rjmp	8000869a <_vfprintf_r+0x5c2>
80008662:	41 09       	lddsp	r9,sp[0x40]
80008664:	59 f8       	cp.w	r8,31
80008666:	e0 89 00 14 	brgt	8000868e <_vfprintf_r+0x5b6>
8000866a:	f2 cb ff f8 	sub	r11,r9,-8
8000866e:	51 0b       	stdsp	sp[0x40],r11
80008670:	fa c6 f9 44 	sub	r6,sp,-1724
80008674:	72 1b       	ld.w	r11,r9[0x4]
80008676:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000867a:	72 09       	ld.w	r9,r9[0x0]
8000867c:	f9 4b fd 8c 	st.w	r12[-628],r11
80008680:	f9 49 fd 88 	st.w	r12[-632],r9
80008684:	2f f8       	sub	r8,-1
80008686:	14 97       	mov	r7,r10
80008688:	fb 48 06 b4 	st.w	sp[1716],r8
8000868c:	c0 78       	rjmp	8000869a <_vfprintf_r+0x5c2>
8000868e:	f2 c8 ff f8 	sub	r8,r9,-8
80008692:	72 1b       	ld.w	r11,r9[0x4]
80008694:	14 97       	mov	r7,r10
80008696:	51 08       	stdsp	sp[0x40],r8
80008698:	72 09       	ld.w	r9,r9[0x0]
8000869a:	16 98       	mov	r8,r11
8000869c:	fa e9 00 00 	st.d	sp[0],r8
800086a0:	ca e8       	rjmp	800087fc <_vfprintf_r+0x724>
800086a2:	ed b5 00 04 	bld	r5,0x4
800086a6:	c1 71       	brne	800086d4 <_vfprintf_r+0x5fc>
800086a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086ac:	40 3e       	lddsp	lr,sp[0xc]
800086ae:	58 0e       	cp.w	lr,0
800086b0:	c0 80       	breq	800086c0 <_vfprintf_r+0x5e8>
800086b2:	10 36       	cp.w	r6,r8
800086b4:	c6 94       	brge	80008786 <_vfprintf_r+0x6ae>
800086b6:	fa cc f9 44 	sub	r12,sp,-1724
800086ba:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086be:	c8 28       	rjmp	800087c2 <_vfprintf_r+0x6ea>
800086c0:	ee ca ff ff 	sub	r10,r7,-1
800086c4:	10 37       	cp.w	r7,r8
800086c6:	e0 84 00 81 	brge	800087c8 <_vfprintf_r+0x6f0>
800086ca:	fa cb f9 44 	sub	r11,sp,-1724
800086ce:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086d2:	c7 78       	rjmp	800087c0 <_vfprintf_r+0x6e8>
800086d4:	ed b5 00 06 	bld	r5,0x6
800086d8:	c4 b1       	brne	8000876e <_vfprintf_r+0x696>
800086da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086de:	40 3c       	lddsp	r12,sp[0xc]
800086e0:	58 0c       	cp.w	r12,0
800086e2:	c1 d0       	breq	8000871c <_vfprintf_r+0x644>
800086e4:	10 36       	cp.w	r6,r8
800086e6:	c0 64       	brge	800086f2 <_vfprintf_r+0x61a>
800086e8:	fa cb f9 44 	sub	r11,sp,-1724
800086ec:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086f0:	c1 f8       	rjmp	8000872e <_vfprintf_r+0x656>
800086f2:	fa c8 f9 50 	sub	r8,sp,-1712
800086f6:	1a d8       	st.w	--sp,r8
800086f8:	fa c8 fa b8 	sub	r8,sp,-1352
800086fc:	1a d8       	st.w	--sp,r8
800086fe:	fa c8 fb b4 	sub	r8,sp,-1100
80008702:	1a d8       	st.w	--sp,r8
80008704:	fa c8 f9 40 	sub	r8,sp,-1728
80008708:	fa c9 ff b4 	sub	r9,sp,-76
8000870c:	04 9a       	mov	r10,r2
8000870e:	0c 9b       	mov	r11,r6
80008710:	08 9c       	mov	r12,r4
80008712:	fe b0 fb 4b 	rcall	80007da8 <get_arg>
80008716:	2f dd       	sub	sp,-12
80008718:	98 18       	ld.sh	r8,r12[0x2]
8000871a:	c2 68       	rjmp	80008766 <_vfprintf_r+0x68e>
8000871c:	ee ca ff ff 	sub	r10,r7,-1
80008720:	10 37       	cp.w	r7,r8
80008722:	c0 94       	brge	80008734 <_vfprintf_r+0x65c>
80008724:	fa c9 f9 44 	sub	r9,sp,-1724
80008728:	14 97       	mov	r7,r10
8000872a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000872e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008732:	c1 a8       	rjmp	80008766 <_vfprintf_r+0x68e>
80008734:	41 09       	lddsp	r9,sp[0x40]
80008736:	59 f8       	cp.w	r8,31
80008738:	e0 89 00 13 	brgt	8000875e <_vfprintf_r+0x686>
8000873c:	f2 cb ff fc 	sub	r11,r9,-4
80008740:	51 0b       	stdsp	sp[0x40],r11
80008742:	72 09       	ld.w	r9,r9[0x0]
80008744:	fa c6 f9 44 	sub	r6,sp,-1724
80008748:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000874c:	2f f8       	sub	r8,-1
8000874e:	f7 49 fd 88 	st.w	r11[-632],r9
80008752:	fb 48 06 b4 	st.w	sp[1716],r8
80008756:	14 97       	mov	r7,r10
80008758:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000875c:	c0 58       	rjmp	80008766 <_vfprintf_r+0x68e>
8000875e:	92 18       	ld.sh	r8,r9[0x2]
80008760:	14 97       	mov	r7,r10
80008762:	2f c9       	sub	r9,-4
80008764:	51 09       	stdsp	sp[0x40],r9
80008766:	50 18       	stdsp	sp[0x4],r8
80008768:	bf 58       	asr	r8,0x1f
8000876a:	50 08       	stdsp	sp[0x0],r8
8000876c:	c4 88       	rjmp	800087fc <_vfprintf_r+0x724>
8000876e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008772:	40 3c       	lddsp	r12,sp[0xc]
80008774:	58 0c       	cp.w	r12,0
80008776:	c1 d0       	breq	800087b0 <_vfprintf_r+0x6d8>
80008778:	10 36       	cp.w	r6,r8
8000877a:	c0 64       	brge	80008786 <_vfprintf_r+0x6ae>
8000877c:	fa cb f9 44 	sub	r11,sp,-1724
80008780:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008784:	c1 f8       	rjmp	800087c2 <_vfprintf_r+0x6ea>
80008786:	fa c8 f9 50 	sub	r8,sp,-1712
8000878a:	1a d8       	st.w	--sp,r8
8000878c:	fa c8 fa b8 	sub	r8,sp,-1352
80008790:	0c 9b       	mov	r11,r6
80008792:	1a d8       	st.w	--sp,r8
80008794:	fa c8 fb b4 	sub	r8,sp,-1100
80008798:	04 9a       	mov	r10,r2
8000879a:	1a d8       	st.w	--sp,r8
8000879c:	08 9c       	mov	r12,r4
8000879e:	fa c8 f9 40 	sub	r8,sp,-1728
800087a2:	fa c9 ff b4 	sub	r9,sp,-76
800087a6:	fe b0 fb 01 	rcall	80007da8 <get_arg>
800087aa:	2f dd       	sub	sp,-12
800087ac:	78 0b       	ld.w	r11,r12[0x0]
800087ae:	c2 48       	rjmp	800087f6 <_vfprintf_r+0x71e>
800087b0:	ee ca ff ff 	sub	r10,r7,-1
800087b4:	10 37       	cp.w	r7,r8
800087b6:	c0 94       	brge	800087c8 <_vfprintf_r+0x6f0>
800087b8:	fa c9 f9 44 	sub	r9,sp,-1724
800087bc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087c0:	14 97       	mov	r7,r10
800087c2:	ec fb fd 88 	ld.w	r11,r6[-632]
800087c6:	c1 88       	rjmp	800087f6 <_vfprintf_r+0x71e>
800087c8:	41 09       	lddsp	r9,sp[0x40]
800087ca:	59 f8       	cp.w	r8,31
800087cc:	e0 89 00 11 	brgt	800087ee <_vfprintf_r+0x716>
800087d0:	f2 cb ff fc 	sub	r11,r9,-4
800087d4:	51 0b       	stdsp	sp[0x40],r11
800087d6:	fa c6 f9 44 	sub	r6,sp,-1724
800087da:	72 0b       	ld.w	r11,r9[0x0]
800087dc:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087e0:	f3 4b fd 88 	st.w	r9[-632],r11
800087e4:	2f f8       	sub	r8,-1
800087e6:	14 97       	mov	r7,r10
800087e8:	fb 48 06 b4 	st.w	sp[1716],r8
800087ec:	c0 58       	rjmp	800087f6 <_vfprintf_r+0x71e>
800087ee:	72 0b       	ld.w	r11,r9[0x0]
800087f0:	14 97       	mov	r7,r10
800087f2:	2f c9       	sub	r9,-4
800087f4:	51 09       	stdsp	sp[0x40],r9
800087f6:	50 1b       	stdsp	sp[0x4],r11
800087f8:	bf 5b       	asr	r11,0x1f
800087fa:	50 0b       	stdsp	sp[0x0],r11
800087fc:	fa ea 00 00 	ld.d	r10,sp[0]
80008800:	58 0a       	cp.w	r10,0
80008802:	5c 2b       	cpc	r11
80008804:	c0 e4       	brge	80008820 <_vfprintf_r+0x748>
80008806:	30 08       	mov	r8,0
80008808:	fa ea 00 00 	ld.d	r10,sp[0]
8000880c:	30 09       	mov	r9,0
8000880e:	f0 0a 01 0a 	sub	r10,r8,r10
80008812:	f2 0b 01 4b 	sbc	r11,r9,r11
80008816:	32 d8       	mov	r8,45
80008818:	fa eb 00 00 	st.d	sp[0],r10
8000881c:	fb 68 06 bb 	st.b	sp[1723],r8
80008820:	30 18       	mov	r8,1
80008822:	e0 8f 06 fa 	bral	80009616 <_vfprintf_r+0x153e>
80008826:	50 a7       	stdsp	sp[0x28],r7
80008828:	50 80       	stdsp	sp[0x20],r0
8000882a:	0c 97       	mov	r7,r6
8000882c:	04 94       	mov	r4,r2
8000882e:	06 96       	mov	r6,r3
80008830:	02 92       	mov	r2,r1
80008832:	40 93       	lddsp	r3,sp[0x24]
80008834:	10 90       	mov	r0,r8
80008836:	40 41       	lddsp	r1,sp[0x10]
80008838:	0e 99       	mov	r9,r7
8000883a:	ed b5 00 03 	bld	r5,0x3
8000883e:	c4 11       	brne	800088c0 <_vfprintf_r+0x7e8>
80008840:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008844:	40 3a       	lddsp	r10,sp[0xc]
80008846:	58 0a       	cp.w	r10,0
80008848:	c1 90       	breq	8000887a <_vfprintf_r+0x7a2>
8000884a:	10 36       	cp.w	r6,r8
8000884c:	c6 45       	brlt	80008914 <_vfprintf_r+0x83c>
8000884e:	fa c8 f9 50 	sub	r8,sp,-1712
80008852:	1a d8       	st.w	--sp,r8
80008854:	fa c8 fa b8 	sub	r8,sp,-1352
80008858:	1a d8       	st.w	--sp,r8
8000885a:	fa c8 fb b4 	sub	r8,sp,-1100
8000885e:	0c 9b       	mov	r11,r6
80008860:	1a d8       	st.w	--sp,r8
80008862:	04 9a       	mov	r10,r2
80008864:	fa c8 f9 40 	sub	r8,sp,-1728
80008868:	fa c9 ff b4 	sub	r9,sp,-76
8000886c:	08 9c       	mov	r12,r4
8000886e:	fe b0 fa 9d 	rcall	80007da8 <get_arg>
80008872:	2f dd       	sub	sp,-12
80008874:	78 16       	ld.w	r6,r12[0x4]
80008876:	50 76       	stdsp	sp[0x1c],r6
80008878:	c4 88       	rjmp	80008908 <_vfprintf_r+0x830>
8000887a:	2f f7       	sub	r7,-1
8000887c:	10 39       	cp.w	r9,r8
8000887e:	c0 c4       	brge	80008896 <_vfprintf_r+0x7be>
80008880:	fa ce f9 44 	sub	lr,sp,-1724
80008884:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008888:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000888c:	50 7c       	stdsp	sp[0x1c],r12
8000888e:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008892:	50 56       	stdsp	sp[0x14],r6
80008894:	c6 68       	rjmp	80008960 <_vfprintf_r+0x888>
80008896:	41 09       	lddsp	r9,sp[0x40]
80008898:	59 f8       	cp.w	r8,31
8000889a:	e0 89 00 10 	brgt	800088ba <_vfprintf_r+0x7e2>
8000889e:	f2 ca ff f8 	sub	r10,r9,-8
800088a2:	72 1b       	ld.w	r11,r9[0x4]
800088a4:	51 0a       	stdsp	sp[0x40],r10
800088a6:	72 09       	ld.w	r9,r9[0x0]
800088a8:	fa ca f9 44 	sub	r10,sp,-1724
800088ac:	50 7b       	stdsp	sp[0x1c],r11
800088ae:	50 59       	stdsp	sp[0x14],r9
800088b0:	f4 08 00 39 	add	r9,r10,r8<<0x3
800088b4:	40 5b       	lddsp	r11,sp[0x14]
800088b6:	40 7a       	lddsp	r10,sp[0x1c]
800088b8:	c4 78       	rjmp	80008946 <_vfprintf_r+0x86e>
800088ba:	72 18       	ld.w	r8,r9[0x4]
800088bc:	50 78       	stdsp	sp[0x1c],r8
800088be:	c4 c8       	rjmp	80008956 <_vfprintf_r+0x87e>
800088c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088c4:	40 3e       	lddsp	lr,sp[0xc]
800088c6:	58 0e       	cp.w	lr,0
800088c8:	c2 30       	breq	8000890e <_vfprintf_r+0x836>
800088ca:	10 36       	cp.w	r6,r8
800088cc:	c0 94       	brge	800088de <_vfprintf_r+0x806>
800088ce:	fa cc f9 44 	sub	r12,sp,-1724
800088d2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800088d6:	ec fb fd 8c 	ld.w	r11,r6[-628]
800088da:	50 7b       	stdsp	sp[0x1c],r11
800088dc:	cd 9b       	rjmp	8000888e <_vfprintf_r+0x7b6>
800088de:	fa c8 f9 50 	sub	r8,sp,-1712
800088e2:	1a d8       	st.w	--sp,r8
800088e4:	fa c8 fa b8 	sub	r8,sp,-1352
800088e8:	04 9a       	mov	r10,r2
800088ea:	1a d8       	st.w	--sp,r8
800088ec:	fa c8 fb b4 	sub	r8,sp,-1100
800088f0:	0c 9b       	mov	r11,r6
800088f2:	1a d8       	st.w	--sp,r8
800088f4:	08 9c       	mov	r12,r4
800088f6:	fa c8 f9 40 	sub	r8,sp,-1728
800088fa:	fa c9 ff b4 	sub	r9,sp,-76
800088fe:	fe b0 fa 55 	rcall	80007da8 <get_arg>
80008902:	2f dd       	sub	sp,-12
80008904:	78 1a       	ld.w	r10,r12[0x4]
80008906:	50 7a       	stdsp	sp[0x1c],r10
80008908:	78 0c       	ld.w	r12,r12[0x0]
8000890a:	50 5c       	stdsp	sp[0x14],r12
8000890c:	c2 a8       	rjmp	80008960 <_vfprintf_r+0x888>
8000890e:	2f f7       	sub	r7,-1
80008910:	10 39       	cp.w	r9,r8
80008912:	c0 94       	brge	80008924 <_vfprintf_r+0x84c>
80008914:	fa c9 f9 44 	sub	r9,sp,-1724
80008918:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000891c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008920:	50 78       	stdsp	sp[0x1c],r8
80008922:	cb 6b       	rjmp	8000888e <_vfprintf_r+0x7b6>
80008924:	41 09       	lddsp	r9,sp[0x40]
80008926:	59 f8       	cp.w	r8,31
80008928:	e0 89 00 15 	brgt	80008952 <_vfprintf_r+0x87a>
8000892c:	f2 ca ff f8 	sub	r10,r9,-8
80008930:	72 16       	ld.w	r6,r9[0x4]
80008932:	72 09       	ld.w	r9,r9[0x0]
80008934:	51 0a       	stdsp	sp[0x40],r10
80008936:	50 59       	stdsp	sp[0x14],r9
80008938:	fa ce f9 44 	sub	lr,sp,-1724
8000893c:	50 76       	stdsp	sp[0x1c],r6
8000893e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008942:	40 5b       	lddsp	r11,sp[0x14]
80008944:	0c 9a       	mov	r10,r6
80008946:	f2 eb fd 88 	st.d	r9[-632],r10
8000894a:	2f f8       	sub	r8,-1
8000894c:	fb 48 06 b4 	st.w	sp[1716],r8
80008950:	c0 88       	rjmp	80008960 <_vfprintf_r+0x888>
80008952:	72 1c       	ld.w	r12,r9[0x4]
80008954:	50 7c       	stdsp	sp[0x1c],r12
80008956:	f2 c8 ff f8 	sub	r8,r9,-8
8000895a:	51 08       	stdsp	sp[0x40],r8
8000895c:	72 09       	ld.w	r9,r9[0x0]
8000895e:	50 59       	stdsp	sp[0x14],r9
80008960:	40 5b       	lddsp	r11,sp[0x14]
80008962:	40 7a       	lddsp	r10,sp[0x1c]
80008964:	e0 a0 19 54 	rcall	8000bc0c <__isinfd>
80008968:	18 96       	mov	r6,r12
8000896a:	c1 70       	breq	80008998 <_vfprintf_r+0x8c0>
8000896c:	30 08       	mov	r8,0
8000896e:	30 09       	mov	r9,0
80008970:	40 5b       	lddsp	r11,sp[0x14]
80008972:	40 7a       	lddsp	r10,sp[0x1c]
80008974:	e0 a0 1d b4 	rcall	8000c4dc <__avr32_f64_cmp_lt>
80008978:	c0 40       	breq	80008980 <_vfprintf_r+0x8a8>
8000897a:	32 d8       	mov	r8,45
8000897c:	fb 68 06 bb 	st.b	sp[1723],r8
80008980:	fe c8 a9 d4 	sub	r8,pc,-22060
80008984:	fe c6 a9 d4 	sub	r6,pc,-22060
80008988:	a7 d5       	cbr	r5,0x7
8000898a:	e0 40 00 47 	cp.w	r0,71
8000898e:	f0 06 17 a0 	movle	r6,r8
80008992:	30 32       	mov	r2,3
80008994:	e0 8f 06 ce 	bral	80009730 <_vfprintf_r+0x1658>
80008998:	40 5b       	lddsp	r11,sp[0x14]
8000899a:	40 7a       	lddsp	r10,sp[0x1c]
8000899c:	e0 a0 19 4d 	rcall	8000bc36 <__isnand>
800089a0:	c0 e0       	breq	800089bc <_vfprintf_r+0x8e4>
800089a2:	50 26       	stdsp	sp[0x8],r6
800089a4:	fe c8 a9 f0 	sub	r8,pc,-22032
800089a8:	fe c6 a9 f0 	sub	r6,pc,-22032
800089ac:	a7 d5       	cbr	r5,0x7
800089ae:	e0 40 00 47 	cp.w	r0,71
800089b2:	f0 06 17 a0 	movle	r6,r8
800089b6:	30 32       	mov	r2,3
800089b8:	e0 8f 06 c2 	bral	8000973c <_vfprintf_r+0x1664>
800089bc:	40 2a       	lddsp	r10,sp[0x8]
800089be:	5b fa       	cp.w	r10,-1
800089c0:	c0 41       	brne	800089c8 <_vfprintf_r+0x8f0>
800089c2:	30 69       	mov	r9,6
800089c4:	50 29       	stdsp	sp[0x8],r9
800089c6:	c1 18       	rjmp	800089e8 <_vfprintf_r+0x910>
800089c8:	e0 40 00 47 	cp.w	r0,71
800089cc:	5f 09       	sreq	r9
800089ce:	e0 40 00 67 	cp.w	r0,103
800089d2:	5f 08       	sreq	r8
800089d4:	f3 e8 10 08 	or	r8,r9,r8
800089d8:	f8 08 18 00 	cp.b	r8,r12
800089dc:	c0 60       	breq	800089e8 <_vfprintf_r+0x910>
800089de:	40 28       	lddsp	r8,sp[0x8]
800089e0:	58 08       	cp.w	r8,0
800089e2:	f9 b8 00 01 	moveq	r8,1
800089e6:	50 28       	stdsp	sp[0x8],r8
800089e8:	40 78       	lddsp	r8,sp[0x1c]
800089ea:	40 59       	lddsp	r9,sp[0x14]
800089ec:	fa e9 06 94 	st.d	sp[1684],r8
800089f0:	a9 a5       	sbr	r5,0x8
800089f2:	fa f8 06 94 	ld.w	r8,sp[1684]
800089f6:	58 08       	cp.w	r8,0
800089f8:	c0 65       	brlt	80008a04 <_vfprintf_r+0x92c>
800089fa:	40 5e       	lddsp	lr,sp[0x14]
800089fc:	30 0c       	mov	r12,0
800089fe:	50 6e       	stdsp	sp[0x18],lr
80008a00:	50 9c       	stdsp	sp[0x24],r12
80008a02:	c0 78       	rjmp	80008a10 <_vfprintf_r+0x938>
80008a04:	40 5b       	lddsp	r11,sp[0x14]
80008a06:	32 da       	mov	r10,45
80008a08:	ee 1b 80 00 	eorh	r11,0x8000
80008a0c:	50 9a       	stdsp	sp[0x24],r10
80008a0e:	50 6b       	stdsp	sp[0x18],r11
80008a10:	e0 40 00 46 	cp.w	r0,70
80008a14:	5f 09       	sreq	r9
80008a16:	e0 40 00 66 	cp.w	r0,102
80008a1a:	5f 08       	sreq	r8
80008a1c:	f3 e8 10 08 	or	r8,r9,r8
80008a20:	50 48       	stdsp	sp[0x10],r8
80008a22:	c0 40       	breq	80008a2a <_vfprintf_r+0x952>
80008a24:	40 22       	lddsp	r2,sp[0x8]
80008a26:	30 39       	mov	r9,3
80008a28:	c1 08       	rjmp	80008a48 <_vfprintf_r+0x970>
80008a2a:	e0 40 00 45 	cp.w	r0,69
80008a2e:	5f 09       	sreq	r9
80008a30:	e0 40 00 65 	cp.w	r0,101
80008a34:	5f 08       	sreq	r8
80008a36:	40 22       	lddsp	r2,sp[0x8]
80008a38:	10 49       	or	r9,r8
80008a3a:	2f f2       	sub	r2,-1
80008a3c:	40 46       	lddsp	r6,sp[0x10]
80008a3e:	ec 09 18 00 	cp.b	r9,r6
80008a42:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008a46:	30 29       	mov	r9,2
80008a48:	fa c8 f9 5c 	sub	r8,sp,-1700
80008a4c:	1a d8       	st.w	--sp,r8
80008a4e:	fa c8 f9 54 	sub	r8,sp,-1708
80008a52:	1a d8       	st.w	--sp,r8
80008a54:	fa c8 f9 4c 	sub	r8,sp,-1716
80008a58:	08 9c       	mov	r12,r4
80008a5a:	1a d8       	st.w	--sp,r8
80008a5c:	04 98       	mov	r8,r2
80008a5e:	40 9b       	lddsp	r11,sp[0x24]
80008a60:	40 aa       	lddsp	r10,sp[0x28]
80008a62:	e0 a0 0b c3 	rcall	8000a1e8 <_dtoa_r>
80008a66:	e0 40 00 47 	cp.w	r0,71
80008a6a:	5f 19       	srne	r9
80008a6c:	e0 40 00 67 	cp.w	r0,103
80008a70:	5f 18       	srne	r8
80008a72:	18 96       	mov	r6,r12
80008a74:	2f dd       	sub	sp,-12
80008a76:	f3 e8 00 08 	and	r8,r9,r8
80008a7a:	c0 41       	brne	80008a82 <_vfprintf_r+0x9aa>
80008a7c:	ed b5 00 00 	bld	r5,0x0
80008a80:	c3 01       	brne	80008ae0 <_vfprintf_r+0xa08>
80008a82:	ec 02 00 0e 	add	lr,r6,r2
80008a86:	50 3e       	stdsp	sp[0xc],lr
80008a88:	40 4c       	lddsp	r12,sp[0x10]
80008a8a:	58 0c       	cp.w	r12,0
80008a8c:	c1 50       	breq	80008ab6 <_vfprintf_r+0x9de>
80008a8e:	0d 89       	ld.ub	r9,r6[0x0]
80008a90:	33 08       	mov	r8,48
80008a92:	f0 09 18 00 	cp.b	r9,r8
80008a96:	c0 b1       	brne	80008aac <_vfprintf_r+0x9d4>
80008a98:	30 08       	mov	r8,0
80008a9a:	30 09       	mov	r9,0
80008a9c:	40 6b       	lddsp	r11,sp[0x18]
80008a9e:	40 7a       	lddsp	r10,sp[0x1c]
80008aa0:	e0 a0 1c d7 	rcall	8000c44e <__avr32_f64_cmp_eq>
80008aa4:	fb b2 00 01 	rsubeq	r2,1
80008aa8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008aac:	40 3b       	lddsp	r11,sp[0xc]
80008aae:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ab2:	10 0b       	add	r11,r8
80008ab4:	50 3b       	stdsp	sp[0xc],r11
80008ab6:	40 6b       	lddsp	r11,sp[0x18]
80008ab8:	30 08       	mov	r8,0
80008aba:	30 09       	mov	r9,0
80008abc:	40 7a       	lddsp	r10,sp[0x1c]
80008abe:	e0 a0 1c c8 	rcall	8000c44e <__avr32_f64_cmp_eq>
80008ac2:	c0 90       	breq	80008ad4 <_vfprintf_r+0x9fc>
80008ac4:	40 3a       	lddsp	r10,sp[0xc]
80008ac6:	fb 4a 06 a4 	st.w	sp[1700],r10
80008aca:	c0 58       	rjmp	80008ad4 <_vfprintf_r+0x9fc>
80008acc:	10 c9       	st.b	r8++,r9
80008ace:	fb 48 06 a4 	st.w	sp[1700],r8
80008ad2:	c0 28       	rjmp	80008ad6 <_vfprintf_r+0x9fe>
80008ad4:	33 09       	mov	r9,48
80008ad6:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008ada:	40 3e       	lddsp	lr,sp[0xc]
80008adc:	1c 38       	cp.w	r8,lr
80008ade:	cf 73       	brcs	80008acc <_vfprintf_r+0x9f4>
80008ae0:	e0 40 00 47 	cp.w	r0,71
80008ae4:	5f 09       	sreq	r9
80008ae6:	e0 40 00 67 	cp.w	r0,103
80008aea:	5f 08       	sreq	r8
80008aec:	f3 e8 10 08 	or	r8,r9,r8
80008af0:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008af4:	0c 19       	sub	r9,r6
80008af6:	50 69       	stdsp	sp[0x18],r9
80008af8:	58 08       	cp.w	r8,0
80008afa:	c0 b0       	breq	80008b10 <_vfprintf_r+0xa38>
80008afc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b00:	5b d8       	cp.w	r8,-3
80008b02:	c0 55       	brlt	80008b0c <_vfprintf_r+0xa34>
80008b04:	40 2c       	lddsp	r12,sp[0x8]
80008b06:	18 38       	cp.w	r8,r12
80008b08:	e0 8a 00 6a 	brle	80008bdc <_vfprintf_r+0xb04>
80008b0c:	20 20       	sub	r0,2
80008b0e:	c0 58       	rjmp	80008b18 <_vfprintf_r+0xa40>
80008b10:	e0 40 00 65 	cp.w	r0,101
80008b14:	e0 89 00 46 	brgt	80008ba0 <_vfprintf_r+0xac8>
80008b18:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008b1c:	fb 60 06 9c 	st.b	sp[1692],r0
80008b20:	20 1b       	sub	r11,1
80008b22:	fb 4b 06 ac 	st.w	sp[1708],r11
80008b26:	c0 47       	brpl	80008b2e <_vfprintf_r+0xa56>
80008b28:	5c 3b       	neg	r11
80008b2a:	32 d8       	mov	r8,45
80008b2c:	c0 28       	rjmp	80008b30 <_vfprintf_r+0xa58>
80008b2e:	32 b8       	mov	r8,43
80008b30:	fb 68 06 9d 	st.b	sp[1693],r8
80008b34:	58 9b       	cp.w	r11,9
80008b36:	e0 8a 00 1d 	brle	80008b70 <_vfprintf_r+0xa98>
80008b3a:	fa c9 fa 35 	sub	r9,sp,-1483
80008b3e:	30 aa       	mov	r10,10
80008b40:	12 98       	mov	r8,r9
80008b42:	0e 9c       	mov	r12,r7
80008b44:	0c 92       	mov	r2,r6
80008b46:	f6 0a 0c 06 	divs	r6,r11,r10
80008b4a:	0e 9b       	mov	r11,r7
80008b4c:	2d 0b       	sub	r11,-48
80008b4e:	10 fb       	st.b	--r8,r11
80008b50:	0c 9b       	mov	r11,r6
80008b52:	58 96       	cp.w	r6,9
80008b54:	fe 99 ff f9 	brgt	80008b46 <_vfprintf_r+0xa6e>
80008b58:	2d 0b       	sub	r11,-48
80008b5a:	18 97       	mov	r7,r12
80008b5c:	04 96       	mov	r6,r2
80008b5e:	10 fb       	st.b	--r8,r11
80008b60:	fa ca f9 62 	sub	r10,sp,-1694
80008b64:	c0 38       	rjmp	80008b6a <_vfprintf_r+0xa92>
80008b66:	11 3b       	ld.ub	r11,r8++
80008b68:	14 cb       	st.b	r10++,r11
80008b6a:	12 38       	cp.w	r8,r9
80008b6c:	cf d3       	brcs	80008b66 <_vfprintf_r+0xa8e>
80008b6e:	c0 98       	rjmp	80008b80 <_vfprintf_r+0xaa8>
80008b70:	2d 0b       	sub	r11,-48
80008b72:	33 08       	mov	r8,48
80008b74:	fb 6b 06 9f 	st.b	sp[1695],r11
80008b78:	fb 68 06 9e 	st.b	sp[1694],r8
80008b7c:	fa ca f9 60 	sub	r10,sp,-1696
80008b80:	fa c8 f9 64 	sub	r8,sp,-1692
80008b84:	f4 08 01 08 	sub	r8,r10,r8
80008b88:	50 e8       	stdsp	sp[0x38],r8
80008b8a:	10 92       	mov	r2,r8
80008b8c:	40 6b       	lddsp	r11,sp[0x18]
80008b8e:	16 02       	add	r2,r11
80008b90:	58 1b       	cp.w	r11,1
80008b92:	e0 89 00 05 	brgt	80008b9c <_vfprintf_r+0xac4>
80008b96:	ed b5 00 00 	bld	r5,0x0
80008b9a:	c3 51       	brne	80008c04 <_vfprintf_r+0xb2c>
80008b9c:	2f f2       	sub	r2,-1
80008b9e:	c3 38       	rjmp	80008c04 <_vfprintf_r+0xb2c>
80008ba0:	e0 40 00 66 	cp.w	r0,102
80008ba4:	c1 c1       	brne	80008bdc <_vfprintf_r+0xb04>
80008ba6:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008baa:	58 02       	cp.w	r2,0
80008bac:	e0 8a 00 0c 	brle	80008bc4 <_vfprintf_r+0xaec>
80008bb0:	40 2a       	lddsp	r10,sp[0x8]
80008bb2:	58 0a       	cp.w	r10,0
80008bb4:	c0 41       	brne	80008bbc <_vfprintf_r+0xae4>
80008bb6:	ed b5 00 00 	bld	r5,0x0
80008bba:	c2 51       	brne	80008c04 <_vfprintf_r+0xb2c>
80008bbc:	2f f2       	sub	r2,-1
80008bbe:	40 29       	lddsp	r9,sp[0x8]
80008bc0:	12 02       	add	r2,r9
80008bc2:	c0 b8       	rjmp	80008bd8 <_vfprintf_r+0xb00>
80008bc4:	40 28       	lddsp	r8,sp[0x8]
80008bc6:	58 08       	cp.w	r8,0
80008bc8:	c0 61       	brne	80008bd4 <_vfprintf_r+0xafc>
80008bca:	ed b5 00 00 	bld	r5,0x0
80008bce:	c0 30       	breq	80008bd4 <_vfprintf_r+0xafc>
80008bd0:	30 12       	mov	r2,1
80008bd2:	c1 98       	rjmp	80008c04 <_vfprintf_r+0xb2c>
80008bd4:	40 22       	lddsp	r2,sp[0x8]
80008bd6:	2f e2       	sub	r2,-2
80008bd8:	36 60       	mov	r0,102
80008bda:	c1 58       	rjmp	80008c04 <_vfprintf_r+0xb2c>
80008bdc:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008be0:	40 6e       	lddsp	lr,sp[0x18]
80008be2:	1c 32       	cp.w	r2,lr
80008be4:	c0 65       	brlt	80008bf0 <_vfprintf_r+0xb18>
80008be6:	ed b5 00 00 	bld	r5,0x0
80008bea:	f7 b2 00 ff 	subeq	r2,-1
80008bee:	c0 a8       	rjmp	80008c02 <_vfprintf_r+0xb2a>
80008bf0:	e4 08 11 02 	rsub	r8,r2,2
80008bf4:	40 6c       	lddsp	r12,sp[0x18]
80008bf6:	58 02       	cp.w	r2,0
80008bf8:	f0 02 17 a0 	movle	r2,r8
80008bfc:	f9 b2 09 01 	movgt	r2,1
80008c00:	18 02       	add	r2,r12
80008c02:	36 70       	mov	r0,103
80008c04:	40 9b       	lddsp	r11,sp[0x24]
80008c06:	58 0b       	cp.w	r11,0
80008c08:	e0 80 05 94 	breq	80009730 <_vfprintf_r+0x1658>
80008c0c:	32 d8       	mov	r8,45
80008c0e:	fb 68 06 bb 	st.b	sp[1723],r8
80008c12:	e0 8f 05 93 	bral	80009738 <_vfprintf_r+0x1660>
80008c16:	50 a7       	stdsp	sp[0x28],r7
80008c18:	04 94       	mov	r4,r2
80008c1a:	0c 97       	mov	r7,r6
80008c1c:	02 92       	mov	r2,r1
80008c1e:	06 96       	mov	r6,r3
80008c20:	40 41       	lddsp	r1,sp[0x10]
80008c22:	40 93       	lddsp	r3,sp[0x24]
80008c24:	0e 99       	mov	r9,r7
80008c26:	ed b5 00 05 	bld	r5,0x5
80008c2a:	c4 81       	brne	80008cba <_vfprintf_r+0xbe2>
80008c2c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c30:	40 3e       	lddsp	lr,sp[0xc]
80008c32:	58 0e       	cp.w	lr,0
80008c34:	c1 d0       	breq	80008c6e <_vfprintf_r+0xb96>
80008c36:	10 36       	cp.w	r6,r8
80008c38:	c0 64       	brge	80008c44 <_vfprintf_r+0xb6c>
80008c3a:	fa cc f9 44 	sub	r12,sp,-1724
80008c3e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c42:	c1 d8       	rjmp	80008c7c <_vfprintf_r+0xba4>
80008c44:	fa c8 f9 50 	sub	r8,sp,-1712
80008c48:	1a d8       	st.w	--sp,r8
80008c4a:	fa c8 fa b8 	sub	r8,sp,-1352
80008c4e:	04 9a       	mov	r10,r2
80008c50:	1a d8       	st.w	--sp,r8
80008c52:	fa c8 fb b4 	sub	r8,sp,-1100
80008c56:	0c 9b       	mov	r11,r6
80008c58:	1a d8       	st.w	--sp,r8
80008c5a:	08 9c       	mov	r12,r4
80008c5c:	fa c8 f9 40 	sub	r8,sp,-1728
80008c60:	fa c9 ff b4 	sub	r9,sp,-76
80008c64:	fe b0 f8 a2 	rcall	80007da8 <get_arg>
80008c68:	2f dd       	sub	sp,-12
80008c6a:	78 0a       	ld.w	r10,r12[0x0]
80008c6c:	c2 08       	rjmp	80008cac <_vfprintf_r+0xbd4>
80008c6e:	2f f7       	sub	r7,-1
80008c70:	10 39       	cp.w	r9,r8
80008c72:	c0 84       	brge	80008c82 <_vfprintf_r+0xbaa>
80008c74:	fa cb f9 44 	sub	r11,sp,-1724
80008c78:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c7c:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c80:	c1 68       	rjmp	80008cac <_vfprintf_r+0xbd4>
80008c82:	41 09       	lddsp	r9,sp[0x40]
80008c84:	59 f8       	cp.w	r8,31
80008c86:	e0 89 00 10 	brgt	80008ca6 <_vfprintf_r+0xbce>
80008c8a:	f2 ca ff fc 	sub	r10,r9,-4
80008c8e:	51 0a       	stdsp	sp[0x40],r10
80008c90:	fa c6 f9 44 	sub	r6,sp,-1724
80008c94:	72 0a       	ld.w	r10,r9[0x0]
80008c96:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c9a:	f3 4a fd 88 	st.w	r9[-632],r10
80008c9e:	2f f8       	sub	r8,-1
80008ca0:	fb 48 06 b4 	st.w	sp[1716],r8
80008ca4:	c0 48       	rjmp	80008cac <_vfprintf_r+0xbd4>
80008ca6:	72 0a       	ld.w	r10,r9[0x0]
80008ca8:	2f c9       	sub	r9,-4
80008caa:	51 09       	stdsp	sp[0x40],r9
80008cac:	40 be       	lddsp	lr,sp[0x2c]
80008cae:	1c 98       	mov	r8,lr
80008cb0:	95 1e       	st.w	r10[0x4],lr
80008cb2:	bf 58       	asr	r8,0x1f
80008cb4:	95 08       	st.w	r10[0x0],r8
80008cb6:	fe 9f fa 9f 	bral	800081f4 <_vfprintf_r+0x11c>
80008cba:	ed b5 00 04 	bld	r5,0x4
80008cbe:	c4 80       	breq	80008d4e <_vfprintf_r+0xc76>
80008cc0:	e2 15 00 40 	andl	r5,0x40,COH
80008cc4:	c4 50       	breq	80008d4e <_vfprintf_r+0xc76>
80008cc6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cca:	40 3c       	lddsp	r12,sp[0xc]
80008ccc:	58 0c       	cp.w	r12,0
80008cce:	c1 d0       	breq	80008d08 <_vfprintf_r+0xc30>
80008cd0:	10 36       	cp.w	r6,r8
80008cd2:	c0 64       	brge	80008cde <_vfprintf_r+0xc06>
80008cd4:	fa cb f9 44 	sub	r11,sp,-1724
80008cd8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cdc:	c1 d8       	rjmp	80008d16 <_vfprintf_r+0xc3e>
80008cde:	fa c8 f9 50 	sub	r8,sp,-1712
80008ce2:	1a d8       	st.w	--sp,r8
80008ce4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ce8:	04 9a       	mov	r10,r2
80008cea:	1a d8       	st.w	--sp,r8
80008cec:	fa c8 fb b4 	sub	r8,sp,-1100
80008cf0:	0c 9b       	mov	r11,r6
80008cf2:	1a d8       	st.w	--sp,r8
80008cf4:	08 9c       	mov	r12,r4
80008cf6:	fa c8 f9 40 	sub	r8,sp,-1728
80008cfa:	fa c9 ff b4 	sub	r9,sp,-76
80008cfe:	fe b0 f8 55 	rcall	80007da8 <get_arg>
80008d02:	2f dd       	sub	sp,-12
80008d04:	78 0a       	ld.w	r10,r12[0x0]
80008d06:	c2 08       	rjmp	80008d46 <_vfprintf_r+0xc6e>
80008d08:	2f f7       	sub	r7,-1
80008d0a:	10 39       	cp.w	r9,r8
80008d0c:	c0 84       	brge	80008d1c <_vfprintf_r+0xc44>
80008d0e:	fa ca f9 44 	sub	r10,sp,-1724
80008d12:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d16:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d1a:	c1 68       	rjmp	80008d46 <_vfprintf_r+0xc6e>
80008d1c:	41 09       	lddsp	r9,sp[0x40]
80008d1e:	59 f8       	cp.w	r8,31
80008d20:	e0 89 00 10 	brgt	80008d40 <_vfprintf_r+0xc68>
80008d24:	f2 ca ff fc 	sub	r10,r9,-4
80008d28:	51 0a       	stdsp	sp[0x40],r10
80008d2a:	fa c6 f9 44 	sub	r6,sp,-1724
80008d2e:	72 0a       	ld.w	r10,r9[0x0]
80008d30:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d34:	f3 4a fd 88 	st.w	r9[-632],r10
80008d38:	2f f8       	sub	r8,-1
80008d3a:	fb 48 06 b4 	st.w	sp[1716],r8
80008d3e:	c0 48       	rjmp	80008d46 <_vfprintf_r+0xc6e>
80008d40:	72 0a       	ld.w	r10,r9[0x0]
80008d42:	2f c9       	sub	r9,-4
80008d44:	51 09       	stdsp	sp[0x40],r9
80008d46:	40 be       	lddsp	lr,sp[0x2c]
80008d48:	b4 0e       	st.h	r10[0x0],lr
80008d4a:	fe 9f fa 55 	bral	800081f4 <_vfprintf_r+0x11c>
80008d4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d52:	40 3c       	lddsp	r12,sp[0xc]
80008d54:	58 0c       	cp.w	r12,0
80008d56:	c1 d0       	breq	80008d90 <_vfprintf_r+0xcb8>
80008d58:	10 36       	cp.w	r6,r8
80008d5a:	c0 64       	brge	80008d66 <_vfprintf_r+0xc8e>
80008d5c:	fa cb f9 44 	sub	r11,sp,-1724
80008d60:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d64:	c1 d8       	rjmp	80008d9e <_vfprintf_r+0xcc6>
80008d66:	fa c8 f9 50 	sub	r8,sp,-1712
80008d6a:	1a d8       	st.w	--sp,r8
80008d6c:	fa c8 fa b8 	sub	r8,sp,-1352
80008d70:	04 9a       	mov	r10,r2
80008d72:	1a d8       	st.w	--sp,r8
80008d74:	fa c8 fb b4 	sub	r8,sp,-1100
80008d78:	0c 9b       	mov	r11,r6
80008d7a:	1a d8       	st.w	--sp,r8
80008d7c:	08 9c       	mov	r12,r4
80008d7e:	fa c8 f9 40 	sub	r8,sp,-1728
80008d82:	fa c9 ff b4 	sub	r9,sp,-76
80008d86:	fe b0 f8 11 	rcall	80007da8 <get_arg>
80008d8a:	2f dd       	sub	sp,-12
80008d8c:	78 0a       	ld.w	r10,r12[0x0]
80008d8e:	c2 08       	rjmp	80008dce <_vfprintf_r+0xcf6>
80008d90:	2f f7       	sub	r7,-1
80008d92:	10 39       	cp.w	r9,r8
80008d94:	c0 84       	brge	80008da4 <_vfprintf_r+0xccc>
80008d96:	fa ca f9 44 	sub	r10,sp,-1724
80008d9a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d9e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008da2:	c1 68       	rjmp	80008dce <_vfprintf_r+0xcf6>
80008da4:	41 09       	lddsp	r9,sp[0x40]
80008da6:	59 f8       	cp.w	r8,31
80008da8:	e0 89 00 10 	brgt	80008dc8 <_vfprintf_r+0xcf0>
80008dac:	f2 ca ff fc 	sub	r10,r9,-4
80008db0:	51 0a       	stdsp	sp[0x40],r10
80008db2:	fa c6 f9 44 	sub	r6,sp,-1724
80008db6:	72 0a       	ld.w	r10,r9[0x0]
80008db8:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dbc:	f3 4a fd 88 	st.w	r9[-632],r10
80008dc0:	2f f8       	sub	r8,-1
80008dc2:	fb 48 06 b4 	st.w	sp[1716],r8
80008dc6:	c0 48       	rjmp	80008dce <_vfprintf_r+0xcf6>
80008dc8:	72 0a       	ld.w	r10,r9[0x0]
80008dca:	2f c9       	sub	r9,-4
80008dcc:	51 09       	stdsp	sp[0x40],r9
80008dce:	40 be       	lddsp	lr,sp[0x2c]
80008dd0:	95 0e       	st.w	r10[0x0],lr
80008dd2:	fe 9f fa 11 	bral	800081f4 <_vfprintf_r+0x11c>
80008dd6:	50 a7       	stdsp	sp[0x28],r7
80008dd8:	50 80       	stdsp	sp[0x20],r0
80008dda:	0c 97       	mov	r7,r6
80008ddc:	04 94       	mov	r4,r2
80008dde:	06 96       	mov	r6,r3
80008de0:	02 92       	mov	r2,r1
80008de2:	40 93       	lddsp	r3,sp[0x24]
80008de4:	10 90       	mov	r0,r8
80008de6:	40 41       	lddsp	r1,sp[0x10]
80008de8:	a5 a5       	sbr	r5,0x4
80008dea:	c0 a8       	rjmp	80008dfe <_vfprintf_r+0xd26>
80008dec:	50 a7       	stdsp	sp[0x28],r7
80008dee:	50 80       	stdsp	sp[0x20],r0
80008df0:	0c 97       	mov	r7,r6
80008df2:	04 94       	mov	r4,r2
80008df4:	06 96       	mov	r6,r3
80008df6:	02 92       	mov	r2,r1
80008df8:	40 93       	lddsp	r3,sp[0x24]
80008dfa:	10 90       	mov	r0,r8
80008dfc:	40 41       	lddsp	r1,sp[0x10]
80008dfe:	ed b5 00 05 	bld	r5,0x5
80008e02:	c5 d1       	brne	80008ebc <_vfprintf_r+0xde4>
80008e04:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e08:	40 3c       	lddsp	r12,sp[0xc]
80008e0a:	58 0c       	cp.w	r12,0
80008e0c:	c2 60       	breq	80008e58 <_vfprintf_r+0xd80>
80008e0e:	10 36       	cp.w	r6,r8
80008e10:	c0 a4       	brge	80008e24 <_vfprintf_r+0xd4c>
80008e12:	fa cb f9 44 	sub	r11,sp,-1724
80008e16:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e1a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e1e:	fa e9 00 00 	st.d	sp[0],r8
80008e22:	c1 88       	rjmp	80008e52 <_vfprintf_r+0xd7a>
80008e24:	fa c8 f9 50 	sub	r8,sp,-1712
80008e28:	1a d8       	st.w	--sp,r8
80008e2a:	fa c8 fa b8 	sub	r8,sp,-1352
80008e2e:	04 9a       	mov	r10,r2
80008e30:	1a d8       	st.w	--sp,r8
80008e32:	0c 9b       	mov	r11,r6
80008e34:	fa c8 fb b4 	sub	r8,sp,-1100
80008e38:	08 9c       	mov	r12,r4
80008e3a:	1a d8       	st.w	--sp,r8
80008e3c:	fa c8 f9 40 	sub	r8,sp,-1728
80008e40:	fa c9 ff b4 	sub	r9,sp,-76
80008e44:	fe b0 f7 b2 	rcall	80007da8 <get_arg>
80008e48:	2f dd       	sub	sp,-12
80008e4a:	f8 ea 00 00 	ld.d	r10,r12[0]
80008e4e:	fa eb 00 00 	st.d	sp[0],r10
80008e52:	30 08       	mov	r8,0
80008e54:	e0 8f 03 de 	bral	80009610 <_vfprintf_r+0x1538>
80008e58:	ee ca ff ff 	sub	r10,r7,-1
80008e5c:	10 37       	cp.w	r7,r8
80008e5e:	c0 b4       	brge	80008e74 <_vfprintf_r+0xd9c>
80008e60:	fa c9 f9 44 	sub	r9,sp,-1724
80008e64:	14 97       	mov	r7,r10
80008e66:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e6a:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e6e:	fa eb 00 00 	st.d	sp[0],r10
80008e72:	c1 88       	rjmp	80008ea2 <_vfprintf_r+0xdca>
80008e74:	41 09       	lddsp	r9,sp[0x40]
80008e76:	59 f8       	cp.w	r8,31
80008e78:	e0 89 00 18 	brgt	80008ea8 <_vfprintf_r+0xdd0>
80008e7c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e80:	f2 cb ff f8 	sub	r11,r9,-8
80008e84:	fa e7 00 00 	st.d	sp[0],r6
80008e88:	51 0b       	stdsp	sp[0x40],r11
80008e8a:	fa c6 f9 44 	sub	r6,sp,-1724
80008e8e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e92:	fa e6 00 00 	ld.d	r6,sp[0]
80008e96:	f2 e7 fd 88 	st.d	r9[-632],r6
80008e9a:	2f f8       	sub	r8,-1
80008e9c:	14 97       	mov	r7,r10
80008e9e:	fb 48 06 b4 	st.w	sp[1716],r8
80008ea2:	40 38       	lddsp	r8,sp[0xc]
80008ea4:	e0 8f 03 b6 	bral	80009610 <_vfprintf_r+0x1538>
80008ea8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008eac:	40 38       	lddsp	r8,sp[0xc]
80008eae:	fa e7 00 00 	st.d	sp[0],r6
80008eb2:	2f 89       	sub	r9,-8
80008eb4:	14 97       	mov	r7,r10
80008eb6:	51 09       	stdsp	sp[0x40],r9
80008eb8:	e0 8f 03 ac 	bral	80009610 <_vfprintf_r+0x1538>
80008ebc:	ed b5 00 04 	bld	r5,0x4
80008ec0:	c1 61       	brne	80008eec <_vfprintf_r+0xe14>
80008ec2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ec6:	40 3e       	lddsp	lr,sp[0xc]
80008ec8:	58 0e       	cp.w	lr,0
80008eca:	c0 80       	breq	80008eda <_vfprintf_r+0xe02>
80008ecc:	10 36       	cp.w	r6,r8
80008ece:	c6 74       	brge	80008f9c <_vfprintf_r+0xec4>
80008ed0:	fa cc f9 44 	sub	r12,sp,-1724
80008ed4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ed8:	c8 08       	rjmp	80008fd8 <_vfprintf_r+0xf00>
80008eda:	ee ca ff ff 	sub	r10,r7,-1
80008ede:	10 37       	cp.w	r7,r8
80008ee0:	c7 f4       	brge	80008fde <_vfprintf_r+0xf06>
80008ee2:	fa cb f9 44 	sub	r11,sp,-1724
80008ee6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eea:	c7 68       	rjmp	80008fd6 <_vfprintf_r+0xefe>
80008eec:	ed b5 00 06 	bld	r5,0x6
80008ef0:	c4 a1       	brne	80008f84 <_vfprintf_r+0xeac>
80008ef2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ef6:	40 3c       	lddsp	r12,sp[0xc]
80008ef8:	58 0c       	cp.w	r12,0
80008efa:	c1 d0       	breq	80008f34 <_vfprintf_r+0xe5c>
80008efc:	10 36       	cp.w	r6,r8
80008efe:	c0 64       	brge	80008f0a <_vfprintf_r+0xe32>
80008f00:	fa cb f9 44 	sub	r11,sp,-1724
80008f04:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f08:	c1 f8       	rjmp	80008f46 <_vfprintf_r+0xe6e>
80008f0a:	fa c8 f9 50 	sub	r8,sp,-1712
80008f0e:	1a d8       	st.w	--sp,r8
80008f10:	fa c8 fa b8 	sub	r8,sp,-1352
80008f14:	1a d8       	st.w	--sp,r8
80008f16:	fa c8 fb b4 	sub	r8,sp,-1100
80008f1a:	1a d8       	st.w	--sp,r8
80008f1c:	fa c8 f9 40 	sub	r8,sp,-1728
80008f20:	fa c9 ff b4 	sub	r9,sp,-76
80008f24:	04 9a       	mov	r10,r2
80008f26:	0c 9b       	mov	r11,r6
80008f28:	08 9c       	mov	r12,r4
80008f2a:	fe b0 f7 3f 	rcall	80007da8 <get_arg>
80008f2e:	2f dd       	sub	sp,-12
80008f30:	98 18       	ld.sh	r8,r12[0x2]
80008f32:	c2 68       	rjmp	80008f7e <_vfprintf_r+0xea6>
80008f34:	ee ca ff ff 	sub	r10,r7,-1
80008f38:	10 37       	cp.w	r7,r8
80008f3a:	c0 94       	brge	80008f4c <_vfprintf_r+0xe74>
80008f3c:	fa c9 f9 44 	sub	r9,sp,-1724
80008f40:	14 97       	mov	r7,r10
80008f42:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f46:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f4a:	c1 a8       	rjmp	80008f7e <_vfprintf_r+0xea6>
80008f4c:	41 09       	lddsp	r9,sp[0x40]
80008f4e:	59 f8       	cp.w	r8,31
80008f50:	e0 89 00 13 	brgt	80008f76 <_vfprintf_r+0xe9e>
80008f54:	f2 cb ff fc 	sub	r11,r9,-4
80008f58:	51 0b       	stdsp	sp[0x40],r11
80008f5a:	72 09       	ld.w	r9,r9[0x0]
80008f5c:	fa c6 f9 44 	sub	r6,sp,-1724
80008f60:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f64:	2f f8       	sub	r8,-1
80008f66:	f7 49 fd 88 	st.w	r11[-632],r9
80008f6a:	fb 48 06 b4 	st.w	sp[1716],r8
80008f6e:	14 97       	mov	r7,r10
80008f70:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f74:	c0 58       	rjmp	80008f7e <_vfprintf_r+0xea6>
80008f76:	92 18       	ld.sh	r8,r9[0x2]
80008f78:	14 97       	mov	r7,r10
80008f7a:	2f c9       	sub	r9,-4
80008f7c:	51 09       	stdsp	sp[0x40],r9
80008f7e:	5c 78       	castu.h	r8
80008f80:	50 18       	stdsp	sp[0x4],r8
80008f82:	c4 68       	rjmp	8000900e <_vfprintf_r+0xf36>
80008f84:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f88:	40 3c       	lddsp	r12,sp[0xc]
80008f8a:	58 0c       	cp.w	r12,0
80008f8c:	c1 d0       	breq	80008fc6 <_vfprintf_r+0xeee>
80008f8e:	10 36       	cp.w	r6,r8
80008f90:	c0 64       	brge	80008f9c <_vfprintf_r+0xec4>
80008f92:	fa cb f9 44 	sub	r11,sp,-1724
80008f96:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f9a:	c1 f8       	rjmp	80008fd8 <_vfprintf_r+0xf00>
80008f9c:	fa c8 f9 50 	sub	r8,sp,-1712
80008fa0:	1a d8       	st.w	--sp,r8
80008fa2:	fa c8 fa b8 	sub	r8,sp,-1352
80008fa6:	0c 9b       	mov	r11,r6
80008fa8:	1a d8       	st.w	--sp,r8
80008faa:	fa c8 fb b4 	sub	r8,sp,-1100
80008fae:	04 9a       	mov	r10,r2
80008fb0:	1a d8       	st.w	--sp,r8
80008fb2:	08 9c       	mov	r12,r4
80008fb4:	fa c8 f9 40 	sub	r8,sp,-1728
80008fb8:	fa c9 ff b4 	sub	r9,sp,-76
80008fbc:	fe b0 f6 f6 	rcall	80007da8 <get_arg>
80008fc0:	2f dd       	sub	sp,-12
80008fc2:	78 0b       	ld.w	r11,r12[0x0]
80008fc4:	c2 48       	rjmp	8000900c <_vfprintf_r+0xf34>
80008fc6:	ee ca ff ff 	sub	r10,r7,-1
80008fca:	10 37       	cp.w	r7,r8
80008fcc:	c0 94       	brge	80008fde <_vfprintf_r+0xf06>
80008fce:	fa c9 f9 44 	sub	r9,sp,-1724
80008fd2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fd6:	14 97       	mov	r7,r10
80008fd8:	ec fb fd 88 	ld.w	r11,r6[-632]
80008fdc:	c1 88       	rjmp	8000900c <_vfprintf_r+0xf34>
80008fde:	41 09       	lddsp	r9,sp[0x40]
80008fe0:	59 f8       	cp.w	r8,31
80008fe2:	e0 89 00 11 	brgt	80009004 <_vfprintf_r+0xf2c>
80008fe6:	f2 cb ff fc 	sub	r11,r9,-4
80008fea:	51 0b       	stdsp	sp[0x40],r11
80008fec:	fa c6 f9 44 	sub	r6,sp,-1724
80008ff0:	72 0b       	ld.w	r11,r9[0x0]
80008ff2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ff6:	f3 4b fd 88 	st.w	r9[-632],r11
80008ffa:	2f f8       	sub	r8,-1
80008ffc:	14 97       	mov	r7,r10
80008ffe:	fb 48 06 b4 	st.w	sp[1716],r8
80009002:	c0 58       	rjmp	8000900c <_vfprintf_r+0xf34>
80009004:	72 0b       	ld.w	r11,r9[0x0]
80009006:	14 97       	mov	r7,r10
80009008:	2f c9       	sub	r9,-4
8000900a:	51 09       	stdsp	sp[0x40],r9
8000900c:	50 1b       	stdsp	sp[0x4],r11
8000900e:	30 0e       	mov	lr,0
80009010:	50 0e       	stdsp	sp[0x0],lr
80009012:	1c 98       	mov	r8,lr
80009014:	e0 8f 02 fe 	bral	80009610 <_vfprintf_r+0x1538>
80009018:	50 a7       	stdsp	sp[0x28],r7
8000901a:	50 80       	stdsp	sp[0x20],r0
8000901c:	0c 97       	mov	r7,r6
8000901e:	04 94       	mov	r4,r2
80009020:	06 96       	mov	r6,r3
80009022:	02 92       	mov	r2,r1
80009024:	40 93       	lddsp	r3,sp[0x24]
80009026:	40 41       	lddsp	r1,sp[0x10]
80009028:	0e 99       	mov	r9,r7
8000902a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000902e:	40 3c       	lddsp	r12,sp[0xc]
80009030:	58 0c       	cp.w	r12,0
80009032:	c1 d0       	breq	8000906c <_vfprintf_r+0xf94>
80009034:	10 36       	cp.w	r6,r8
80009036:	c0 64       	brge	80009042 <_vfprintf_r+0xf6a>
80009038:	fa cb f9 44 	sub	r11,sp,-1724
8000903c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009040:	c1 d8       	rjmp	8000907a <_vfprintf_r+0xfa2>
80009042:	fa c8 f9 50 	sub	r8,sp,-1712
80009046:	1a d8       	st.w	--sp,r8
80009048:	fa c8 fa b8 	sub	r8,sp,-1352
8000904c:	1a d8       	st.w	--sp,r8
8000904e:	fa c8 fb b4 	sub	r8,sp,-1100
80009052:	1a d8       	st.w	--sp,r8
80009054:	fa c9 ff b4 	sub	r9,sp,-76
80009058:	fa c8 f9 40 	sub	r8,sp,-1728
8000905c:	04 9a       	mov	r10,r2
8000905e:	0c 9b       	mov	r11,r6
80009060:	08 9c       	mov	r12,r4
80009062:	fe b0 f6 a3 	rcall	80007da8 <get_arg>
80009066:	2f dd       	sub	sp,-12
80009068:	78 09       	ld.w	r9,r12[0x0]
8000906a:	c2 18       	rjmp	800090ac <_vfprintf_r+0xfd4>
8000906c:	2f f7       	sub	r7,-1
8000906e:	10 39       	cp.w	r9,r8
80009070:	c0 84       	brge	80009080 <_vfprintf_r+0xfa8>
80009072:	fa ca f9 44 	sub	r10,sp,-1724
80009076:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000907a:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000907e:	c1 78       	rjmp	800090ac <_vfprintf_r+0xfd4>
80009080:	41 09       	lddsp	r9,sp[0x40]
80009082:	59 f8       	cp.w	r8,31
80009084:	e0 89 00 10 	brgt	800090a4 <_vfprintf_r+0xfcc>
80009088:	f2 ca ff fc 	sub	r10,r9,-4
8000908c:	51 0a       	stdsp	sp[0x40],r10
8000908e:	fa c6 f9 44 	sub	r6,sp,-1724
80009092:	72 09       	ld.w	r9,r9[0x0]
80009094:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009098:	f5 49 fd 88 	st.w	r10[-632],r9
8000909c:	2f f8       	sub	r8,-1
8000909e:	fb 48 06 b4 	st.w	sp[1716],r8
800090a2:	c0 58       	rjmp	800090ac <_vfprintf_r+0xfd4>
800090a4:	f2 c8 ff fc 	sub	r8,r9,-4
800090a8:	51 08       	stdsp	sp[0x40],r8
800090aa:	72 09       	ld.w	r9,r9[0x0]
800090ac:	33 08       	mov	r8,48
800090ae:	fb 68 06 b8 	st.b	sp[1720],r8
800090b2:	37 88       	mov	r8,120
800090b4:	30 0e       	mov	lr,0
800090b6:	fb 68 06 b9 	st.b	sp[1721],r8
800090ba:	fe cc b0 fe 	sub	r12,pc,-20226
800090be:	50 19       	stdsp	sp[0x4],r9
800090c0:	a1 b5       	sbr	r5,0x1
800090c2:	50 0e       	stdsp	sp[0x0],lr
800090c4:	50 dc       	stdsp	sp[0x34],r12
800090c6:	30 28       	mov	r8,2
800090c8:	37 80       	mov	r0,120
800090ca:	e0 8f 02 a3 	bral	80009610 <_vfprintf_r+0x1538>
800090ce:	50 a7       	stdsp	sp[0x28],r7
800090d0:	50 80       	stdsp	sp[0x20],r0
800090d2:	10 90       	mov	r0,r8
800090d4:	30 08       	mov	r8,0
800090d6:	fb 68 06 bb 	st.b	sp[1723],r8
800090da:	0c 97       	mov	r7,r6
800090dc:	04 94       	mov	r4,r2
800090de:	06 96       	mov	r6,r3
800090e0:	02 92       	mov	r2,r1
800090e2:	40 93       	lddsp	r3,sp[0x24]
800090e4:	40 41       	lddsp	r1,sp[0x10]
800090e6:	0e 99       	mov	r9,r7
800090e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090ec:	40 3b       	lddsp	r11,sp[0xc]
800090ee:	58 0b       	cp.w	r11,0
800090f0:	c1 d0       	breq	8000912a <_vfprintf_r+0x1052>
800090f2:	10 36       	cp.w	r6,r8
800090f4:	c0 64       	brge	80009100 <_vfprintf_r+0x1028>
800090f6:	fa ca f9 44 	sub	r10,sp,-1724
800090fa:	f4 06 00 36 	add	r6,r10,r6<<0x3
800090fe:	c1 d8       	rjmp	80009138 <_vfprintf_r+0x1060>
80009100:	fa c8 f9 50 	sub	r8,sp,-1712
80009104:	1a d8       	st.w	--sp,r8
80009106:	fa c8 fa b8 	sub	r8,sp,-1352
8000910a:	1a d8       	st.w	--sp,r8
8000910c:	fa c8 fb b4 	sub	r8,sp,-1100
80009110:	0c 9b       	mov	r11,r6
80009112:	1a d8       	st.w	--sp,r8
80009114:	04 9a       	mov	r10,r2
80009116:	fa c8 f9 40 	sub	r8,sp,-1728
8000911a:	fa c9 ff b4 	sub	r9,sp,-76
8000911e:	08 9c       	mov	r12,r4
80009120:	fe b0 f6 44 	rcall	80007da8 <get_arg>
80009124:	2f dd       	sub	sp,-12
80009126:	78 06       	ld.w	r6,r12[0x0]
80009128:	c2 08       	rjmp	80009168 <_vfprintf_r+0x1090>
8000912a:	2f f7       	sub	r7,-1
8000912c:	10 39       	cp.w	r9,r8
8000912e:	c0 84       	brge	8000913e <_vfprintf_r+0x1066>
80009130:	fa c9 f9 44 	sub	r9,sp,-1724
80009134:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009138:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000913c:	c1 68       	rjmp	80009168 <_vfprintf_r+0x1090>
8000913e:	41 09       	lddsp	r9,sp[0x40]
80009140:	59 f8       	cp.w	r8,31
80009142:	e0 89 00 10 	brgt	80009162 <_vfprintf_r+0x108a>
80009146:	f2 ca ff fc 	sub	r10,r9,-4
8000914a:	51 0a       	stdsp	sp[0x40],r10
8000914c:	72 06       	ld.w	r6,r9[0x0]
8000914e:	fa ce f9 44 	sub	lr,sp,-1724
80009152:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009156:	f3 46 fd 88 	st.w	r9[-632],r6
8000915a:	2f f8       	sub	r8,-1
8000915c:	fb 48 06 b4 	st.w	sp[1716],r8
80009160:	c0 48       	rjmp	80009168 <_vfprintf_r+0x1090>
80009162:	72 06       	ld.w	r6,r9[0x0]
80009164:	2f c9       	sub	r9,-4
80009166:	51 09       	stdsp	sp[0x40],r9
80009168:	40 2c       	lddsp	r12,sp[0x8]
8000916a:	58 0c       	cp.w	r12,0
8000916c:	c1 05       	brlt	8000918c <_vfprintf_r+0x10b4>
8000916e:	18 9a       	mov	r10,r12
80009170:	30 0b       	mov	r11,0
80009172:	0c 9c       	mov	r12,r6
80009174:	e0 a0 12 38 	rcall	8000b5e4 <memchr>
80009178:	e0 80 02 df 	breq	80009736 <_vfprintf_r+0x165e>
8000917c:	f8 06 01 02 	sub	r2,r12,r6
80009180:	40 2b       	lddsp	r11,sp[0x8]
80009182:	16 32       	cp.w	r2,r11
80009184:	e0 89 02 d9 	brgt	80009736 <_vfprintf_r+0x165e>
80009188:	e0 8f 02 d4 	bral	80009730 <_vfprintf_r+0x1658>
8000918c:	30 0a       	mov	r10,0
8000918e:	0c 9c       	mov	r12,r6
80009190:	50 2a       	stdsp	sp[0x8],r10
80009192:	e0 a0 15 99 	rcall	8000bcc4 <strlen>
80009196:	18 92       	mov	r2,r12
80009198:	e0 8f 02 d2 	bral	8000973c <_vfprintf_r+0x1664>
8000919c:	50 a7       	stdsp	sp[0x28],r7
8000919e:	50 80       	stdsp	sp[0x20],r0
800091a0:	0c 97       	mov	r7,r6
800091a2:	04 94       	mov	r4,r2
800091a4:	06 96       	mov	r6,r3
800091a6:	02 92       	mov	r2,r1
800091a8:	40 93       	lddsp	r3,sp[0x24]
800091aa:	10 90       	mov	r0,r8
800091ac:	40 41       	lddsp	r1,sp[0x10]
800091ae:	a5 a5       	sbr	r5,0x4
800091b0:	c0 a8       	rjmp	800091c4 <_vfprintf_r+0x10ec>
800091b2:	50 a7       	stdsp	sp[0x28],r7
800091b4:	50 80       	stdsp	sp[0x20],r0
800091b6:	0c 97       	mov	r7,r6
800091b8:	04 94       	mov	r4,r2
800091ba:	06 96       	mov	r6,r3
800091bc:	02 92       	mov	r2,r1
800091be:	40 93       	lddsp	r3,sp[0x24]
800091c0:	10 90       	mov	r0,r8
800091c2:	40 41       	lddsp	r1,sp[0x10]
800091c4:	ed b5 00 05 	bld	r5,0x5
800091c8:	c5 61       	brne	80009274 <_vfprintf_r+0x119c>
800091ca:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091ce:	40 39       	lddsp	r9,sp[0xc]
800091d0:	58 09       	cp.w	r9,0
800091d2:	c2 10       	breq	80009214 <_vfprintf_r+0x113c>
800091d4:	10 36       	cp.w	r6,r8
800091d6:	c0 74       	brge	800091e4 <_vfprintf_r+0x110c>
800091d8:	fa c8 f9 44 	sub	r8,sp,-1724
800091dc:	f0 06 00 36 	add	r6,r8,r6<<0x3
800091e0:	c2 38       	rjmp	80009226 <_vfprintf_r+0x114e>
800091e2:	d7 03       	nop
800091e4:	fa c8 f9 50 	sub	r8,sp,-1712
800091e8:	1a d8       	st.w	--sp,r8
800091ea:	fa c8 fa b8 	sub	r8,sp,-1352
800091ee:	1a d8       	st.w	--sp,r8
800091f0:	fa c8 fb b4 	sub	r8,sp,-1100
800091f4:	1a d8       	st.w	--sp,r8
800091f6:	fa c8 f9 40 	sub	r8,sp,-1728
800091fa:	fa c9 ff b4 	sub	r9,sp,-76
800091fe:	04 9a       	mov	r10,r2
80009200:	0c 9b       	mov	r11,r6
80009202:	08 9c       	mov	r12,r4
80009204:	fe b0 f5 d2 	rcall	80007da8 <get_arg>
80009208:	2f dd       	sub	sp,-12
8000920a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000920e:	fa e9 00 00 	st.d	sp[0],r8
80009212:	c2 e8       	rjmp	8000926e <_vfprintf_r+0x1196>
80009214:	ee ca ff ff 	sub	r10,r7,-1
80009218:	10 37       	cp.w	r7,r8
8000921a:	c0 b4       	brge	80009230 <_vfprintf_r+0x1158>
8000921c:	fa c8 f9 44 	sub	r8,sp,-1724
80009220:	14 97       	mov	r7,r10
80009222:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009226:	ec ea fd 88 	ld.d	r10,r6[-632]
8000922a:	fa eb 00 00 	st.d	sp[0],r10
8000922e:	c2 08       	rjmp	8000926e <_vfprintf_r+0x1196>
80009230:	41 09       	lddsp	r9,sp[0x40]
80009232:	59 f8       	cp.w	r8,31
80009234:	e0 89 00 16 	brgt	80009260 <_vfprintf_r+0x1188>
80009238:	f2 e6 00 00 	ld.d	r6,r9[0]
8000923c:	f2 cb ff f8 	sub	r11,r9,-8
80009240:	fa e7 00 00 	st.d	sp[0],r6
80009244:	51 0b       	stdsp	sp[0x40],r11
80009246:	fa c6 f9 44 	sub	r6,sp,-1724
8000924a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000924e:	fa e6 00 00 	ld.d	r6,sp[0]
80009252:	f2 e7 fd 88 	st.d	r9[-632],r6
80009256:	2f f8       	sub	r8,-1
80009258:	14 97       	mov	r7,r10
8000925a:	fb 48 06 b4 	st.w	sp[1716],r8
8000925e:	c0 88       	rjmp	8000926e <_vfprintf_r+0x1196>
80009260:	f2 e6 00 00 	ld.d	r6,r9[0]
80009264:	2f 89       	sub	r9,-8
80009266:	fa e7 00 00 	st.d	sp[0],r6
8000926a:	51 09       	stdsp	sp[0x40],r9
8000926c:	14 97       	mov	r7,r10
8000926e:	30 18       	mov	r8,1
80009270:	e0 8f 01 d0 	bral	80009610 <_vfprintf_r+0x1538>
80009274:	ed b5 00 04 	bld	r5,0x4
80009278:	c1 61       	brne	800092a4 <_vfprintf_r+0x11cc>
8000927a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000927e:	40 3e       	lddsp	lr,sp[0xc]
80009280:	58 0e       	cp.w	lr,0
80009282:	c0 80       	breq	80009292 <_vfprintf_r+0x11ba>
80009284:	10 36       	cp.w	r6,r8
80009286:	c6 74       	brge	80009354 <_vfprintf_r+0x127c>
80009288:	fa cc f9 44 	sub	r12,sp,-1724
8000928c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009290:	c8 08       	rjmp	80009390 <_vfprintf_r+0x12b8>
80009292:	ee ca ff ff 	sub	r10,r7,-1
80009296:	10 37       	cp.w	r7,r8
80009298:	c7 f4       	brge	80009396 <_vfprintf_r+0x12be>
8000929a:	fa cb f9 44 	sub	r11,sp,-1724
8000929e:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092a2:	c7 68       	rjmp	8000938e <_vfprintf_r+0x12b6>
800092a4:	ed b5 00 06 	bld	r5,0x6
800092a8:	c4 a1       	brne	8000933c <_vfprintf_r+0x1264>
800092aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092ae:	40 3c       	lddsp	r12,sp[0xc]
800092b0:	58 0c       	cp.w	r12,0
800092b2:	c1 d0       	breq	800092ec <_vfprintf_r+0x1214>
800092b4:	10 36       	cp.w	r6,r8
800092b6:	c0 64       	brge	800092c2 <_vfprintf_r+0x11ea>
800092b8:	fa cb f9 44 	sub	r11,sp,-1724
800092bc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092c0:	c1 f8       	rjmp	800092fe <_vfprintf_r+0x1226>
800092c2:	fa c8 f9 50 	sub	r8,sp,-1712
800092c6:	1a d8       	st.w	--sp,r8
800092c8:	fa c8 fa b8 	sub	r8,sp,-1352
800092cc:	1a d8       	st.w	--sp,r8
800092ce:	fa c8 fb b4 	sub	r8,sp,-1100
800092d2:	1a d8       	st.w	--sp,r8
800092d4:	fa c8 f9 40 	sub	r8,sp,-1728
800092d8:	fa c9 ff b4 	sub	r9,sp,-76
800092dc:	04 9a       	mov	r10,r2
800092de:	0c 9b       	mov	r11,r6
800092e0:	08 9c       	mov	r12,r4
800092e2:	fe b0 f5 63 	rcall	80007da8 <get_arg>
800092e6:	2f dd       	sub	sp,-12
800092e8:	98 18       	ld.sh	r8,r12[0x2]
800092ea:	c2 68       	rjmp	80009336 <_vfprintf_r+0x125e>
800092ec:	ee ca ff ff 	sub	r10,r7,-1
800092f0:	10 37       	cp.w	r7,r8
800092f2:	c0 94       	brge	80009304 <_vfprintf_r+0x122c>
800092f4:	fa c9 f9 44 	sub	r9,sp,-1724
800092f8:	14 97       	mov	r7,r10
800092fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092fe:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009302:	c1 a8       	rjmp	80009336 <_vfprintf_r+0x125e>
80009304:	41 09       	lddsp	r9,sp[0x40]
80009306:	59 f8       	cp.w	r8,31
80009308:	e0 89 00 13 	brgt	8000932e <_vfprintf_r+0x1256>
8000930c:	f2 cb ff fc 	sub	r11,r9,-4
80009310:	51 0b       	stdsp	sp[0x40],r11
80009312:	72 09       	ld.w	r9,r9[0x0]
80009314:	fa c6 f9 44 	sub	r6,sp,-1724
80009318:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000931c:	2f f8       	sub	r8,-1
8000931e:	f7 49 fd 88 	st.w	r11[-632],r9
80009322:	fb 48 06 b4 	st.w	sp[1716],r8
80009326:	14 97       	mov	r7,r10
80009328:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000932c:	c0 58       	rjmp	80009336 <_vfprintf_r+0x125e>
8000932e:	92 18       	ld.sh	r8,r9[0x2]
80009330:	14 97       	mov	r7,r10
80009332:	2f c9       	sub	r9,-4
80009334:	51 09       	stdsp	sp[0x40],r9
80009336:	5c 78       	castu.h	r8
80009338:	50 18       	stdsp	sp[0x4],r8
8000933a:	c4 68       	rjmp	800093c6 <_vfprintf_r+0x12ee>
8000933c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009340:	40 3c       	lddsp	r12,sp[0xc]
80009342:	58 0c       	cp.w	r12,0
80009344:	c1 d0       	breq	8000937e <_vfprintf_r+0x12a6>
80009346:	10 36       	cp.w	r6,r8
80009348:	c0 64       	brge	80009354 <_vfprintf_r+0x127c>
8000934a:	fa cb f9 44 	sub	r11,sp,-1724
8000934e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009352:	c1 f8       	rjmp	80009390 <_vfprintf_r+0x12b8>
80009354:	fa c8 f9 50 	sub	r8,sp,-1712
80009358:	1a d8       	st.w	--sp,r8
8000935a:	fa c8 fa b8 	sub	r8,sp,-1352
8000935e:	0c 9b       	mov	r11,r6
80009360:	1a d8       	st.w	--sp,r8
80009362:	fa c8 fb b4 	sub	r8,sp,-1100
80009366:	04 9a       	mov	r10,r2
80009368:	1a d8       	st.w	--sp,r8
8000936a:	08 9c       	mov	r12,r4
8000936c:	fa c8 f9 40 	sub	r8,sp,-1728
80009370:	fa c9 ff b4 	sub	r9,sp,-76
80009374:	fe b0 f5 1a 	rcall	80007da8 <get_arg>
80009378:	2f dd       	sub	sp,-12
8000937a:	78 0b       	ld.w	r11,r12[0x0]
8000937c:	c2 48       	rjmp	800093c4 <_vfprintf_r+0x12ec>
8000937e:	ee ca ff ff 	sub	r10,r7,-1
80009382:	10 37       	cp.w	r7,r8
80009384:	c0 94       	brge	80009396 <_vfprintf_r+0x12be>
80009386:	fa c9 f9 44 	sub	r9,sp,-1724
8000938a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000938e:	14 97       	mov	r7,r10
80009390:	ec fb fd 88 	ld.w	r11,r6[-632]
80009394:	c1 88       	rjmp	800093c4 <_vfprintf_r+0x12ec>
80009396:	41 09       	lddsp	r9,sp[0x40]
80009398:	59 f8       	cp.w	r8,31
8000939a:	e0 89 00 11 	brgt	800093bc <_vfprintf_r+0x12e4>
8000939e:	f2 cb ff fc 	sub	r11,r9,-4
800093a2:	51 0b       	stdsp	sp[0x40],r11
800093a4:	fa c6 f9 44 	sub	r6,sp,-1724
800093a8:	72 0b       	ld.w	r11,r9[0x0]
800093aa:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093ae:	f3 4b fd 88 	st.w	r9[-632],r11
800093b2:	2f f8       	sub	r8,-1
800093b4:	14 97       	mov	r7,r10
800093b6:	fb 48 06 b4 	st.w	sp[1716],r8
800093ba:	c0 58       	rjmp	800093c4 <_vfprintf_r+0x12ec>
800093bc:	72 0b       	ld.w	r11,r9[0x0]
800093be:	14 97       	mov	r7,r10
800093c0:	2f c9       	sub	r9,-4
800093c2:	51 09       	stdsp	sp[0x40],r9
800093c4:	50 1b       	stdsp	sp[0x4],r11
800093c6:	30 0e       	mov	lr,0
800093c8:	30 18       	mov	r8,1
800093ca:	50 0e       	stdsp	sp[0x0],lr
800093cc:	c2 29       	rjmp	80009610 <_vfprintf_r+0x1538>
800093ce:	50 a7       	stdsp	sp[0x28],r7
800093d0:	50 80       	stdsp	sp[0x20],r0
800093d2:	0c 97       	mov	r7,r6
800093d4:	04 94       	mov	r4,r2
800093d6:	06 96       	mov	r6,r3
800093d8:	02 92       	mov	r2,r1
800093da:	fe cc b4 1e 	sub	r12,pc,-19426
800093de:	40 93       	lddsp	r3,sp[0x24]
800093e0:	10 90       	mov	r0,r8
800093e2:	40 41       	lddsp	r1,sp[0x10]
800093e4:	50 dc       	stdsp	sp[0x34],r12
800093e6:	ed b5 00 05 	bld	r5,0x5
800093ea:	c5 51       	brne	80009494 <_vfprintf_r+0x13bc>
800093ec:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093f0:	40 3b       	lddsp	r11,sp[0xc]
800093f2:	58 0b       	cp.w	r11,0
800093f4:	c2 20       	breq	80009438 <_vfprintf_r+0x1360>
800093f6:	10 36       	cp.w	r6,r8
800093f8:	c0 a4       	brge	8000940c <_vfprintf_r+0x1334>
800093fa:	fa ca f9 44 	sub	r10,sp,-1724
800093fe:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009402:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009406:	fa e9 00 00 	st.d	sp[0],r8
8000940a:	cf 28       	rjmp	800095ee <_vfprintf_r+0x1516>
8000940c:	fa c8 f9 50 	sub	r8,sp,-1712
80009410:	1a d8       	st.w	--sp,r8
80009412:	fa c8 fa b8 	sub	r8,sp,-1352
80009416:	04 9a       	mov	r10,r2
80009418:	1a d8       	st.w	--sp,r8
8000941a:	0c 9b       	mov	r11,r6
8000941c:	fa c8 fb b4 	sub	r8,sp,-1100
80009420:	08 9c       	mov	r12,r4
80009422:	1a d8       	st.w	--sp,r8
80009424:	fa c8 f9 40 	sub	r8,sp,-1728
80009428:	fa c9 ff b4 	sub	r9,sp,-76
8000942c:	fe b0 f4 be 	rcall	80007da8 <get_arg>
80009430:	2f dd       	sub	sp,-12
80009432:	f8 ea 00 00 	ld.d	r10,r12[0]
80009436:	c0 c8       	rjmp	8000944e <_vfprintf_r+0x1376>
80009438:	ee ca ff ff 	sub	r10,r7,-1
8000943c:	10 37       	cp.w	r7,r8
8000943e:	c0 b4       	brge	80009454 <_vfprintf_r+0x137c>
80009440:	fa c9 f9 44 	sub	r9,sp,-1724
80009444:	14 97       	mov	r7,r10
80009446:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000944a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000944e:	fa eb 00 00 	st.d	sp[0],r10
80009452:	cc e8       	rjmp	800095ee <_vfprintf_r+0x1516>
80009454:	41 09       	lddsp	r9,sp[0x40]
80009456:	59 f8       	cp.w	r8,31
80009458:	e0 89 00 16 	brgt	80009484 <_vfprintf_r+0x13ac>
8000945c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009460:	f2 cb ff f8 	sub	r11,r9,-8
80009464:	fa e7 00 00 	st.d	sp[0],r6
80009468:	51 0b       	stdsp	sp[0x40],r11
8000946a:	fa c6 f9 44 	sub	r6,sp,-1724
8000946e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009472:	fa e6 00 00 	ld.d	r6,sp[0]
80009476:	f2 e7 fd 88 	st.d	r9[-632],r6
8000947a:	2f f8       	sub	r8,-1
8000947c:	14 97       	mov	r7,r10
8000947e:	fb 48 06 b4 	st.w	sp[1716],r8
80009482:	cb 68       	rjmp	800095ee <_vfprintf_r+0x1516>
80009484:	f2 e6 00 00 	ld.d	r6,r9[0]
80009488:	2f 89       	sub	r9,-8
8000948a:	fa e7 00 00 	st.d	sp[0],r6
8000948e:	51 09       	stdsp	sp[0x40],r9
80009490:	14 97       	mov	r7,r10
80009492:	ca e8       	rjmp	800095ee <_vfprintf_r+0x1516>
80009494:	ed b5 00 04 	bld	r5,0x4
80009498:	c1 71       	brne	800094c6 <_vfprintf_r+0x13ee>
8000949a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000949e:	40 3e       	lddsp	lr,sp[0xc]
800094a0:	58 0e       	cp.w	lr,0
800094a2:	c0 80       	breq	800094b2 <_vfprintf_r+0x13da>
800094a4:	10 36       	cp.w	r6,r8
800094a6:	c6 94       	brge	80009578 <_vfprintf_r+0x14a0>
800094a8:	fa cc f9 44 	sub	r12,sp,-1724
800094ac:	f8 06 00 36 	add	r6,r12,r6<<0x3
800094b0:	c8 28       	rjmp	800095b4 <_vfprintf_r+0x14dc>
800094b2:	ee ca ff ff 	sub	r10,r7,-1
800094b6:	10 37       	cp.w	r7,r8
800094b8:	e0 84 00 81 	brge	800095ba <_vfprintf_r+0x14e2>
800094bc:	fa cb f9 44 	sub	r11,sp,-1724
800094c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094c4:	c7 78       	rjmp	800095b2 <_vfprintf_r+0x14da>
800094c6:	ed b5 00 06 	bld	r5,0x6
800094ca:	c4 b1       	brne	80009560 <_vfprintf_r+0x1488>
800094cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094d0:	40 3c       	lddsp	r12,sp[0xc]
800094d2:	58 0c       	cp.w	r12,0
800094d4:	c1 d0       	breq	8000950e <_vfprintf_r+0x1436>
800094d6:	10 36       	cp.w	r6,r8
800094d8:	c0 64       	brge	800094e4 <_vfprintf_r+0x140c>
800094da:	fa cb f9 44 	sub	r11,sp,-1724
800094de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094e2:	c1 f8       	rjmp	80009520 <_vfprintf_r+0x1448>
800094e4:	fa c8 f9 50 	sub	r8,sp,-1712
800094e8:	1a d8       	st.w	--sp,r8
800094ea:	fa c8 fa b8 	sub	r8,sp,-1352
800094ee:	1a d8       	st.w	--sp,r8
800094f0:	fa c8 fb b4 	sub	r8,sp,-1100
800094f4:	1a d8       	st.w	--sp,r8
800094f6:	fa c8 f9 40 	sub	r8,sp,-1728
800094fa:	fa c9 ff b4 	sub	r9,sp,-76
800094fe:	04 9a       	mov	r10,r2
80009500:	0c 9b       	mov	r11,r6
80009502:	08 9c       	mov	r12,r4
80009504:	fe b0 f4 52 	rcall	80007da8 <get_arg>
80009508:	2f dd       	sub	sp,-12
8000950a:	98 18       	ld.sh	r8,r12[0x2]
8000950c:	c2 78       	rjmp	8000955a <_vfprintf_r+0x1482>
8000950e:	ee ca ff ff 	sub	r10,r7,-1
80009512:	10 37       	cp.w	r7,r8
80009514:	c0 a4       	brge	80009528 <_vfprintf_r+0x1450>
80009516:	fa c9 f9 44 	sub	r9,sp,-1724
8000951a:	14 97       	mov	r7,r10
8000951c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009520:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009524:	c1 b8       	rjmp	8000955a <_vfprintf_r+0x1482>
80009526:	d7 03       	nop
80009528:	41 09       	lddsp	r9,sp[0x40]
8000952a:	59 f8       	cp.w	r8,31
8000952c:	e0 89 00 13 	brgt	80009552 <_vfprintf_r+0x147a>
80009530:	f2 cb ff fc 	sub	r11,r9,-4
80009534:	51 0b       	stdsp	sp[0x40],r11
80009536:	72 09       	ld.w	r9,r9[0x0]
80009538:	fa c6 f9 44 	sub	r6,sp,-1724
8000953c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009540:	2f f8       	sub	r8,-1
80009542:	f7 49 fd 88 	st.w	r11[-632],r9
80009546:	fb 48 06 b4 	st.w	sp[1716],r8
8000954a:	14 97       	mov	r7,r10
8000954c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009550:	c0 58       	rjmp	8000955a <_vfprintf_r+0x1482>
80009552:	92 18       	ld.sh	r8,r9[0x2]
80009554:	14 97       	mov	r7,r10
80009556:	2f c9       	sub	r9,-4
80009558:	51 09       	stdsp	sp[0x40],r9
8000955a:	5c 78       	castu.h	r8
8000955c:	50 18       	stdsp	sp[0x4],r8
8000955e:	c4 68       	rjmp	800095ea <_vfprintf_r+0x1512>
80009560:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009564:	40 3c       	lddsp	r12,sp[0xc]
80009566:	58 0c       	cp.w	r12,0
80009568:	c1 d0       	breq	800095a2 <_vfprintf_r+0x14ca>
8000956a:	10 36       	cp.w	r6,r8
8000956c:	c0 64       	brge	80009578 <_vfprintf_r+0x14a0>
8000956e:	fa cb f9 44 	sub	r11,sp,-1724
80009572:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009576:	c1 f8       	rjmp	800095b4 <_vfprintf_r+0x14dc>
80009578:	fa c8 f9 50 	sub	r8,sp,-1712
8000957c:	1a d8       	st.w	--sp,r8
8000957e:	fa c8 fa b8 	sub	r8,sp,-1352
80009582:	0c 9b       	mov	r11,r6
80009584:	1a d8       	st.w	--sp,r8
80009586:	fa c8 fb b4 	sub	r8,sp,-1100
8000958a:	04 9a       	mov	r10,r2
8000958c:	1a d8       	st.w	--sp,r8
8000958e:	08 9c       	mov	r12,r4
80009590:	fa c8 f9 40 	sub	r8,sp,-1728
80009594:	fa c9 ff b4 	sub	r9,sp,-76
80009598:	fe b0 f4 08 	rcall	80007da8 <get_arg>
8000959c:	2f dd       	sub	sp,-12
8000959e:	78 0b       	ld.w	r11,r12[0x0]
800095a0:	c2 48       	rjmp	800095e8 <_vfprintf_r+0x1510>
800095a2:	ee ca ff ff 	sub	r10,r7,-1
800095a6:	10 37       	cp.w	r7,r8
800095a8:	c0 94       	brge	800095ba <_vfprintf_r+0x14e2>
800095aa:	fa c9 f9 44 	sub	r9,sp,-1724
800095ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095b2:	14 97       	mov	r7,r10
800095b4:	ec fb fd 88 	ld.w	r11,r6[-632]
800095b8:	c1 88       	rjmp	800095e8 <_vfprintf_r+0x1510>
800095ba:	41 09       	lddsp	r9,sp[0x40]
800095bc:	59 f8       	cp.w	r8,31
800095be:	e0 89 00 11 	brgt	800095e0 <_vfprintf_r+0x1508>
800095c2:	f2 cb ff fc 	sub	r11,r9,-4
800095c6:	51 0b       	stdsp	sp[0x40],r11
800095c8:	fa c6 f9 44 	sub	r6,sp,-1724
800095cc:	72 0b       	ld.w	r11,r9[0x0]
800095ce:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095d2:	f3 4b fd 88 	st.w	r9[-632],r11
800095d6:	2f f8       	sub	r8,-1
800095d8:	14 97       	mov	r7,r10
800095da:	fb 48 06 b4 	st.w	sp[1716],r8
800095de:	c0 58       	rjmp	800095e8 <_vfprintf_r+0x1510>
800095e0:	72 0b       	ld.w	r11,r9[0x0]
800095e2:	14 97       	mov	r7,r10
800095e4:	2f c9       	sub	r9,-4
800095e6:	51 09       	stdsp	sp[0x40],r9
800095e8:	50 1b       	stdsp	sp[0x4],r11
800095ea:	30 0e       	mov	lr,0
800095ec:	50 0e       	stdsp	sp[0x0],lr
800095ee:	40 08       	lddsp	r8,sp[0x0]
800095f0:	40 1c       	lddsp	r12,sp[0x4]
800095f2:	18 48       	or	r8,r12
800095f4:	5f 19       	srne	r9
800095f6:	0a 98       	mov	r8,r5
800095f8:	eb e9 00 09 	and	r9,r5,r9
800095fc:	a1 b8       	sbr	r8,0x1
800095fe:	58 09       	cp.w	r9,0
80009600:	c0 70       	breq	8000960e <_vfprintf_r+0x1536>
80009602:	10 95       	mov	r5,r8
80009604:	fb 60 06 b9 	st.b	sp[1721],r0
80009608:	33 08       	mov	r8,48
8000960a:	fb 68 06 b8 	st.b	sp[1720],r8
8000960e:	30 28       	mov	r8,2
80009610:	30 09       	mov	r9,0
80009612:	fb 69 06 bb 	st.b	sp[1723],r9
80009616:	0a 99       	mov	r9,r5
80009618:	a7 d9       	cbr	r9,0x7
8000961a:	40 2b       	lddsp	r11,sp[0x8]
8000961c:	40 16       	lddsp	r6,sp[0x4]
8000961e:	58 0b       	cp.w	r11,0
80009620:	5f 1a       	srne	r10
80009622:	f2 05 17 40 	movge	r5,r9
80009626:	fa c2 f9 78 	sub	r2,sp,-1672
8000962a:	40 09       	lddsp	r9,sp[0x0]
8000962c:	0c 49       	or	r9,r6
8000962e:	5f 19       	srne	r9
80009630:	f5 e9 10 09 	or	r9,r10,r9
80009634:	c5 c0       	breq	800096ec <_vfprintf_r+0x1614>
80009636:	30 19       	mov	r9,1
80009638:	f2 08 18 00 	cp.b	r8,r9
8000963c:	c0 60       	breq	80009648 <_vfprintf_r+0x1570>
8000963e:	30 29       	mov	r9,2
80009640:	f2 08 18 00 	cp.b	r8,r9
80009644:	c0 41       	brne	8000964c <_vfprintf_r+0x1574>
80009646:	c3 c8       	rjmp	800096be <_vfprintf_r+0x15e6>
80009648:	04 96       	mov	r6,r2
8000964a:	c3 08       	rjmp	800096aa <_vfprintf_r+0x15d2>
8000964c:	04 96       	mov	r6,r2
8000964e:	fa e8 00 00 	ld.d	r8,sp[0]
80009652:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009656:	2d 0a       	sub	r10,-48
80009658:	0c fa       	st.b	--r6,r10
8000965a:	f0 0b 16 03 	lsr	r11,r8,0x3
8000965e:	f2 0c 16 03 	lsr	r12,r9,0x3
80009662:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009666:	18 99       	mov	r9,r12
80009668:	16 98       	mov	r8,r11
8000966a:	58 08       	cp.w	r8,0
8000966c:	5c 29       	cpc	r9
8000966e:	cf 21       	brne	80009652 <_vfprintf_r+0x157a>
80009670:	fa e9 00 00 	st.d	sp[0],r8
80009674:	ed b5 00 00 	bld	r5,0x0
80009678:	c4 51       	brne	80009702 <_vfprintf_r+0x162a>
8000967a:	33 09       	mov	r9,48
8000967c:	f2 0a 18 00 	cp.b	r10,r9
80009680:	c4 10       	breq	80009702 <_vfprintf_r+0x162a>
80009682:	0c f9       	st.b	--r6,r9
80009684:	c3 f8       	rjmp	80009702 <_vfprintf_r+0x162a>
80009686:	fa ea 00 00 	ld.d	r10,sp[0]
8000968a:	30 a8       	mov	r8,10
8000968c:	30 09       	mov	r9,0
8000968e:	e0 a0 1a 19 	rcall	8000cac0 <__avr32_umod64>
80009692:	30 a8       	mov	r8,10
80009694:	2d 0a       	sub	r10,-48
80009696:	30 09       	mov	r9,0
80009698:	ac 8a       	st.b	r6[0x0],r10
8000969a:	fa ea 00 00 	ld.d	r10,sp[0]
8000969e:	e0 a0 18 df 	rcall	8000c85c <__avr32_udiv64>
800096a2:	16 99       	mov	r9,r11
800096a4:	14 98       	mov	r8,r10
800096a6:	fa e9 00 00 	st.d	sp[0],r8
800096aa:	20 16       	sub	r6,1
800096ac:	fa ea 00 00 	ld.d	r10,sp[0]
800096b0:	58 9a       	cp.w	r10,9
800096b2:	5c 2b       	cpc	r11
800096b4:	fe 9b ff e9 	brhi	80009686 <_vfprintf_r+0x15ae>
800096b8:	1b f8       	ld.ub	r8,sp[0x7]
800096ba:	2d 08       	sub	r8,-48
800096bc:	c2 08       	rjmp	800096fc <_vfprintf_r+0x1624>
800096be:	04 96       	mov	r6,r2
800096c0:	fa e8 00 00 	ld.d	r8,sp[0]
800096c4:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800096c8:	40 de       	lddsp	lr,sp[0x34]
800096ca:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800096ce:	0c fa       	st.b	--r6,r10
800096d0:	f2 0b 16 04 	lsr	r11,r9,0x4
800096d4:	f0 0a 16 04 	lsr	r10,r8,0x4
800096d8:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800096dc:	16 99       	mov	r9,r11
800096de:	14 98       	mov	r8,r10
800096e0:	58 08       	cp.w	r8,0
800096e2:	5c 29       	cpc	r9
800096e4:	cf 01       	brne	800096c4 <_vfprintf_r+0x15ec>
800096e6:	fa e9 00 00 	st.d	sp[0],r8
800096ea:	c0 c8       	rjmp	80009702 <_vfprintf_r+0x162a>
800096ec:	58 08       	cp.w	r8,0
800096ee:	c0 91       	brne	80009700 <_vfprintf_r+0x1628>
800096f0:	ed b5 00 00 	bld	r5,0x0
800096f4:	c0 61       	brne	80009700 <_vfprintf_r+0x1628>
800096f6:	fa c6 f9 79 	sub	r6,sp,-1671
800096fa:	33 08       	mov	r8,48
800096fc:	ac 88       	st.b	r6[0x0],r8
800096fe:	c0 28       	rjmp	80009702 <_vfprintf_r+0x162a>
80009700:	04 96       	mov	r6,r2
80009702:	0c 12       	sub	r2,r6
80009704:	c1 c8       	rjmp	8000973c <_vfprintf_r+0x1664>
80009706:	50 a7       	stdsp	sp[0x28],r7
80009708:	50 80       	stdsp	sp[0x20],r0
8000970a:	40 93       	lddsp	r3,sp[0x24]
8000970c:	0c 97       	mov	r7,r6
8000970e:	10 90       	mov	r0,r8
80009710:	04 94       	mov	r4,r2
80009712:	40 41       	lddsp	r1,sp[0x10]
80009714:	58 08       	cp.w	r8,0
80009716:	e0 80 04 4f 	breq	80009fb4 <_vfprintf_r+0x1edc>
8000971a:	fb 68 06 60 	st.b	sp[1632],r8
8000971e:	30 0c       	mov	r12,0
80009720:	30 08       	mov	r8,0
80009722:	30 12       	mov	r2,1
80009724:	fb 68 06 bb 	st.b	sp[1723],r8
80009728:	50 2c       	stdsp	sp[0x8],r12
8000972a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000972e:	c0 78       	rjmp	8000973c <_vfprintf_r+0x1664>
80009730:	30 0b       	mov	r11,0
80009732:	50 2b       	stdsp	sp[0x8],r11
80009734:	c0 48       	rjmp	8000973c <_vfprintf_r+0x1664>
80009736:	40 22       	lddsp	r2,sp[0x8]
80009738:	30 0a       	mov	r10,0
8000973a:	50 2a       	stdsp	sp[0x8],r10
8000973c:	40 29       	lddsp	r9,sp[0x8]
8000973e:	e4 09 0c 49 	max	r9,r2,r9
80009742:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009746:	50 39       	stdsp	sp[0xc],r9
80009748:	0a 9e       	mov	lr,r5
8000974a:	30 09       	mov	r9,0
8000974c:	e2 1e 00 02 	andl	lr,0x2,COH
80009750:	f2 08 18 00 	cp.b	r8,r9
80009754:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009758:	f7 b8 01 ff 	subne	r8,-1
8000975c:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009760:	0a 9b       	mov	r11,r5
80009762:	58 0e       	cp.w	lr,0
80009764:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009768:	f7 bc 01 fe 	subne	r12,-2
8000976c:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009770:	e2 1b 00 84 	andl	r11,0x84,COH
80009774:	50 fe       	stdsp	sp[0x3c],lr
80009776:	50 9b       	stdsp	sp[0x24],r11
80009778:	c4 71       	brne	80009806 <_vfprintf_r+0x172e>
8000977a:	40 8a       	lddsp	r10,sp[0x20]
8000977c:	40 39       	lddsp	r9,sp[0xc]
8000977e:	12 1a       	sub	r10,r9
80009780:	50 4a       	stdsp	sp[0x10],r10
80009782:	58 0a       	cp.w	r10,0
80009784:	e0 89 00 20 	brgt	800097c4 <_vfprintf_r+0x16ec>
80009788:	c3 f8       	rjmp	80009806 <_vfprintf_r+0x172e>
8000978a:	2f 09       	sub	r9,-16
8000978c:	2f f8       	sub	r8,-1
8000978e:	fe ce b7 ba 	sub	lr,pc,-18502
80009792:	31 0c       	mov	r12,16
80009794:	fb 49 06 90 	st.w	sp[1680],r9
80009798:	87 0e       	st.w	r3[0x0],lr
8000979a:	87 1c       	st.w	r3[0x4],r12
8000979c:	fb 48 06 8c 	st.w	sp[1676],r8
800097a0:	58 78       	cp.w	r8,7
800097a2:	e0 89 00 04 	brgt	800097aa <_vfprintf_r+0x16d2>
800097a6:	2f 83       	sub	r3,-8
800097a8:	c0 b8       	rjmp	800097be <_vfprintf_r+0x16e6>
800097aa:	fa ca f9 78 	sub	r10,sp,-1672
800097ae:	02 9b       	mov	r11,r1
800097b0:	08 9c       	mov	r12,r4
800097b2:	fe b0 f4 85 	rcall	800080bc <__sprint_r>
800097b6:	e0 81 04 10 	brne	80009fd6 <_vfprintf_r+0x1efe>
800097ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800097be:	40 4b       	lddsp	r11,sp[0x10]
800097c0:	21 0b       	sub	r11,16
800097c2:	50 4b       	stdsp	sp[0x10],r11
800097c4:	fa f9 06 90 	ld.w	r9,sp[1680]
800097c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097cc:	fe ca b7 f8 	sub	r10,pc,-18440
800097d0:	40 4e       	lddsp	lr,sp[0x10]
800097d2:	59 0e       	cp.w	lr,16
800097d4:	fe 99 ff db 	brgt	8000978a <_vfprintf_r+0x16b2>
800097d8:	1c 09       	add	r9,lr
800097da:	2f f8       	sub	r8,-1
800097dc:	87 0a       	st.w	r3[0x0],r10
800097de:	fb 49 06 90 	st.w	sp[1680],r9
800097e2:	87 1e       	st.w	r3[0x4],lr
800097e4:	fb 48 06 8c 	st.w	sp[1676],r8
800097e8:	58 78       	cp.w	r8,7
800097ea:	e0 89 00 04 	brgt	800097f2 <_vfprintf_r+0x171a>
800097ee:	2f 83       	sub	r3,-8
800097f0:	c0 b8       	rjmp	80009806 <_vfprintf_r+0x172e>
800097f2:	fa ca f9 78 	sub	r10,sp,-1672
800097f6:	02 9b       	mov	r11,r1
800097f8:	08 9c       	mov	r12,r4
800097fa:	fe b0 f4 61 	rcall	800080bc <__sprint_r>
800097fe:	e0 81 03 ec 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009802:	fa c3 f9 e0 	sub	r3,sp,-1568
80009806:	30 09       	mov	r9,0
80009808:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000980c:	f2 08 18 00 	cp.b	r8,r9
80009810:	c1 f0       	breq	8000984e <_vfprintf_r+0x1776>
80009812:	fa f8 06 90 	ld.w	r8,sp[1680]
80009816:	fa c9 f9 45 	sub	r9,sp,-1723
8000981a:	2f f8       	sub	r8,-1
8000981c:	87 09       	st.w	r3[0x0],r9
8000981e:	fb 48 06 90 	st.w	sp[1680],r8
80009822:	30 19       	mov	r9,1
80009824:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009828:	87 19       	st.w	r3[0x4],r9
8000982a:	2f f8       	sub	r8,-1
8000982c:	fb 48 06 8c 	st.w	sp[1676],r8
80009830:	58 78       	cp.w	r8,7
80009832:	e0 89 00 04 	brgt	8000983a <_vfprintf_r+0x1762>
80009836:	2f 83       	sub	r3,-8
80009838:	c0 b8       	rjmp	8000984e <_vfprintf_r+0x1776>
8000983a:	fa ca f9 78 	sub	r10,sp,-1672
8000983e:	02 9b       	mov	r11,r1
80009840:	08 9c       	mov	r12,r4
80009842:	fe b0 f4 3d 	rcall	800080bc <__sprint_r>
80009846:	e0 81 03 c8 	brne	80009fd6 <_vfprintf_r+0x1efe>
8000984a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000984e:	40 fc       	lddsp	r12,sp[0x3c]
80009850:	58 0c       	cp.w	r12,0
80009852:	c1 f0       	breq	80009890 <_vfprintf_r+0x17b8>
80009854:	fa f8 06 90 	ld.w	r8,sp[1680]
80009858:	fa c9 f9 48 	sub	r9,sp,-1720
8000985c:	2f e8       	sub	r8,-2
8000985e:	87 09       	st.w	r3[0x0],r9
80009860:	fb 48 06 90 	st.w	sp[1680],r8
80009864:	30 29       	mov	r9,2
80009866:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000986a:	87 19       	st.w	r3[0x4],r9
8000986c:	2f f8       	sub	r8,-1
8000986e:	fb 48 06 8c 	st.w	sp[1676],r8
80009872:	58 78       	cp.w	r8,7
80009874:	e0 89 00 04 	brgt	8000987c <_vfprintf_r+0x17a4>
80009878:	2f 83       	sub	r3,-8
8000987a:	c0 b8       	rjmp	80009890 <_vfprintf_r+0x17b8>
8000987c:	fa ca f9 78 	sub	r10,sp,-1672
80009880:	02 9b       	mov	r11,r1
80009882:	08 9c       	mov	r12,r4
80009884:	fe b0 f4 1c 	rcall	800080bc <__sprint_r>
80009888:	e0 81 03 a7 	brne	80009fd6 <_vfprintf_r+0x1efe>
8000988c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009890:	40 9b       	lddsp	r11,sp[0x24]
80009892:	e0 4b 00 80 	cp.w	r11,128
80009896:	c4 71       	brne	80009924 <_vfprintf_r+0x184c>
80009898:	40 8a       	lddsp	r10,sp[0x20]
8000989a:	40 39       	lddsp	r9,sp[0xc]
8000989c:	12 1a       	sub	r10,r9
8000989e:	50 4a       	stdsp	sp[0x10],r10
800098a0:	58 0a       	cp.w	r10,0
800098a2:	e0 89 00 20 	brgt	800098e2 <_vfprintf_r+0x180a>
800098a6:	c3 f8       	rjmp	80009924 <_vfprintf_r+0x184c>
800098a8:	2f 09       	sub	r9,-16
800098aa:	2f f8       	sub	r8,-1
800098ac:	fe ce b8 c8 	sub	lr,pc,-18232
800098b0:	31 0c       	mov	r12,16
800098b2:	fb 49 06 90 	st.w	sp[1680],r9
800098b6:	87 0e       	st.w	r3[0x0],lr
800098b8:	87 1c       	st.w	r3[0x4],r12
800098ba:	fb 48 06 8c 	st.w	sp[1676],r8
800098be:	58 78       	cp.w	r8,7
800098c0:	e0 89 00 04 	brgt	800098c8 <_vfprintf_r+0x17f0>
800098c4:	2f 83       	sub	r3,-8
800098c6:	c0 b8       	rjmp	800098dc <_vfprintf_r+0x1804>
800098c8:	fa ca f9 78 	sub	r10,sp,-1672
800098cc:	02 9b       	mov	r11,r1
800098ce:	08 9c       	mov	r12,r4
800098d0:	fe b0 f3 f6 	rcall	800080bc <__sprint_r>
800098d4:	e0 81 03 81 	brne	80009fd6 <_vfprintf_r+0x1efe>
800098d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098dc:	40 4b       	lddsp	r11,sp[0x10]
800098de:	21 0b       	sub	r11,16
800098e0:	50 4b       	stdsp	sp[0x10],r11
800098e2:	fa f9 06 90 	ld.w	r9,sp[1680]
800098e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098ea:	fe ca b9 06 	sub	r10,pc,-18170
800098ee:	40 4e       	lddsp	lr,sp[0x10]
800098f0:	59 0e       	cp.w	lr,16
800098f2:	fe 99 ff db 	brgt	800098a8 <_vfprintf_r+0x17d0>
800098f6:	1c 09       	add	r9,lr
800098f8:	2f f8       	sub	r8,-1
800098fa:	87 0a       	st.w	r3[0x0],r10
800098fc:	fb 49 06 90 	st.w	sp[1680],r9
80009900:	87 1e       	st.w	r3[0x4],lr
80009902:	fb 48 06 8c 	st.w	sp[1676],r8
80009906:	58 78       	cp.w	r8,7
80009908:	e0 89 00 04 	brgt	80009910 <_vfprintf_r+0x1838>
8000990c:	2f 83       	sub	r3,-8
8000990e:	c0 b8       	rjmp	80009924 <_vfprintf_r+0x184c>
80009910:	fa ca f9 78 	sub	r10,sp,-1672
80009914:	02 9b       	mov	r11,r1
80009916:	08 9c       	mov	r12,r4
80009918:	fe b0 f3 d2 	rcall	800080bc <__sprint_r>
8000991c:	e0 81 03 5d 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009920:	fa c3 f9 e0 	sub	r3,sp,-1568
80009924:	40 2c       	lddsp	r12,sp[0x8]
80009926:	04 1c       	sub	r12,r2
80009928:	50 2c       	stdsp	sp[0x8],r12
8000992a:	58 0c       	cp.w	r12,0
8000992c:	e0 89 00 20 	brgt	8000996c <_vfprintf_r+0x1894>
80009930:	c3 f8       	rjmp	800099ae <_vfprintf_r+0x18d6>
80009932:	2f 09       	sub	r9,-16
80009934:	2f f8       	sub	r8,-1
80009936:	fe cb b9 52 	sub	r11,pc,-18094
8000993a:	31 0a       	mov	r10,16
8000993c:	fb 49 06 90 	st.w	sp[1680],r9
80009940:	87 0b       	st.w	r3[0x0],r11
80009942:	87 1a       	st.w	r3[0x4],r10
80009944:	fb 48 06 8c 	st.w	sp[1676],r8
80009948:	58 78       	cp.w	r8,7
8000994a:	e0 89 00 04 	brgt	80009952 <_vfprintf_r+0x187a>
8000994e:	2f 83       	sub	r3,-8
80009950:	c0 b8       	rjmp	80009966 <_vfprintf_r+0x188e>
80009952:	fa ca f9 78 	sub	r10,sp,-1672
80009956:	02 9b       	mov	r11,r1
80009958:	08 9c       	mov	r12,r4
8000995a:	fe b0 f3 b1 	rcall	800080bc <__sprint_r>
8000995e:	e0 81 03 3c 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009962:	fa c3 f9 e0 	sub	r3,sp,-1568
80009966:	40 29       	lddsp	r9,sp[0x8]
80009968:	21 09       	sub	r9,16
8000996a:	50 29       	stdsp	sp[0x8],r9
8000996c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009970:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009974:	fe ca b9 90 	sub	r10,pc,-18032
80009978:	40 2e       	lddsp	lr,sp[0x8]
8000997a:	59 0e       	cp.w	lr,16
8000997c:	fe 99 ff db 	brgt	80009932 <_vfprintf_r+0x185a>
80009980:	1c 09       	add	r9,lr
80009982:	2f f8       	sub	r8,-1
80009984:	87 0a       	st.w	r3[0x0],r10
80009986:	fb 49 06 90 	st.w	sp[1680],r9
8000998a:	87 1e       	st.w	r3[0x4],lr
8000998c:	fb 48 06 8c 	st.w	sp[1676],r8
80009990:	58 78       	cp.w	r8,7
80009992:	e0 89 00 04 	brgt	8000999a <_vfprintf_r+0x18c2>
80009996:	2f 83       	sub	r3,-8
80009998:	c0 b8       	rjmp	800099ae <_vfprintf_r+0x18d6>
8000999a:	fa ca f9 78 	sub	r10,sp,-1672
8000999e:	02 9b       	mov	r11,r1
800099a0:	08 9c       	mov	r12,r4
800099a2:	fe b0 f3 8d 	rcall	800080bc <__sprint_r>
800099a6:	e0 81 03 18 	brne	80009fd6 <_vfprintf_r+0x1efe>
800099aa:	fa c3 f9 e0 	sub	r3,sp,-1568
800099ae:	ed b5 00 08 	bld	r5,0x8
800099b2:	c0 b0       	breq	800099c8 <_vfprintf_r+0x18f0>
800099b4:	fa f8 06 90 	ld.w	r8,sp[1680]
800099b8:	87 12       	st.w	r3[0x4],r2
800099ba:	87 06       	st.w	r3[0x0],r6
800099bc:	f0 02 00 02 	add	r2,r8,r2
800099c0:	fb 42 06 90 	st.w	sp[1680],r2
800099c4:	e0 8f 01 d4 	bral	80009d6c <_vfprintf_r+0x1c94>
800099c8:	e0 40 00 65 	cp.w	r0,101
800099cc:	e0 8a 01 d6 	brle	80009d78 <_vfprintf_r+0x1ca0>
800099d0:	30 08       	mov	r8,0
800099d2:	30 09       	mov	r9,0
800099d4:	40 5b       	lddsp	r11,sp[0x14]
800099d6:	40 7a       	lddsp	r10,sp[0x1c]
800099d8:	e0 a0 15 3b 	rcall	8000c44e <__avr32_f64_cmp_eq>
800099dc:	c7 90       	breq	80009ace <_vfprintf_r+0x19f6>
800099de:	fa f8 06 90 	ld.w	r8,sp[1680]
800099e2:	fe c9 ba 12 	sub	r9,pc,-17902
800099e6:	2f f8       	sub	r8,-1
800099e8:	87 09       	st.w	r3[0x0],r9
800099ea:	fb 48 06 90 	st.w	sp[1680],r8
800099ee:	30 19       	mov	r9,1
800099f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099f4:	87 19       	st.w	r3[0x4],r9
800099f6:	2f f8       	sub	r8,-1
800099f8:	fb 48 06 8c 	st.w	sp[1676],r8
800099fc:	58 78       	cp.w	r8,7
800099fe:	e0 89 00 05 	brgt	80009a08 <_vfprintf_r+0x1930>
80009a02:	2f 83       	sub	r3,-8
80009a04:	c0 c8       	rjmp	80009a1c <_vfprintf_r+0x1944>
80009a06:	d7 03       	nop
80009a08:	fa ca f9 78 	sub	r10,sp,-1672
80009a0c:	02 9b       	mov	r11,r1
80009a0e:	08 9c       	mov	r12,r4
80009a10:	fe b0 f3 56 	rcall	800080bc <__sprint_r>
80009a14:	e0 81 02 e1 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009a18:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a1c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009a20:	40 6c       	lddsp	r12,sp[0x18]
80009a22:	18 38       	cp.w	r8,r12
80009a24:	c0 55       	brlt	80009a2e <_vfprintf_r+0x1956>
80009a26:	ed b5 00 00 	bld	r5,0x0
80009a2a:	e0 81 02 6b 	brne	80009f00 <_vfprintf_r+0x1e28>
80009a2e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a32:	2f f8       	sub	r8,-1
80009a34:	40 cb       	lddsp	r11,sp[0x30]
80009a36:	fb 48 06 90 	st.w	sp[1680],r8
80009a3a:	30 19       	mov	r9,1
80009a3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a40:	87 0b       	st.w	r3[0x0],r11
80009a42:	2f f8       	sub	r8,-1
80009a44:	87 19       	st.w	r3[0x4],r9
80009a46:	fb 48 06 8c 	st.w	sp[1676],r8
80009a4a:	58 78       	cp.w	r8,7
80009a4c:	e0 89 00 04 	brgt	80009a54 <_vfprintf_r+0x197c>
80009a50:	2f 83       	sub	r3,-8
80009a52:	c0 b8       	rjmp	80009a68 <_vfprintf_r+0x1990>
80009a54:	fa ca f9 78 	sub	r10,sp,-1672
80009a58:	02 9b       	mov	r11,r1
80009a5a:	08 9c       	mov	r12,r4
80009a5c:	fe b0 f3 30 	rcall	800080bc <__sprint_r>
80009a60:	e0 81 02 bb 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009a64:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a68:	40 66       	lddsp	r6,sp[0x18]
80009a6a:	20 16       	sub	r6,1
80009a6c:	58 06       	cp.w	r6,0
80009a6e:	e0 89 00 1d 	brgt	80009aa8 <_vfprintf_r+0x19d0>
80009a72:	e0 8f 02 47 	bral	80009f00 <_vfprintf_r+0x1e28>
80009a76:	2f 09       	sub	r9,-16
80009a78:	2f f8       	sub	r8,-1
80009a7a:	fb 49 06 90 	st.w	sp[1680],r9
80009a7e:	87 02       	st.w	r3[0x0],r2
80009a80:	87 10       	st.w	r3[0x4],r0
80009a82:	fb 48 06 8c 	st.w	sp[1676],r8
80009a86:	58 78       	cp.w	r8,7
80009a88:	e0 89 00 04 	brgt	80009a90 <_vfprintf_r+0x19b8>
80009a8c:	2f 83       	sub	r3,-8
80009a8e:	c0 b8       	rjmp	80009aa4 <_vfprintf_r+0x19cc>
80009a90:	fa ca f9 78 	sub	r10,sp,-1672
80009a94:	02 9b       	mov	r11,r1
80009a96:	08 9c       	mov	r12,r4
80009a98:	fe b0 f3 12 	rcall	800080bc <__sprint_r>
80009a9c:	e0 81 02 9d 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009aa0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aa4:	21 06       	sub	r6,16
80009aa6:	c0 48       	rjmp	80009aae <_vfprintf_r+0x19d6>
80009aa8:	fe c2 ba c4 	sub	r2,pc,-17724
80009aac:	31 00       	mov	r0,16
80009aae:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ab2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ab6:	fe ca ba d2 	sub	r10,pc,-17710
80009aba:	59 06       	cp.w	r6,16
80009abc:	fe 99 ff dd 	brgt	80009a76 <_vfprintf_r+0x199e>
80009ac0:	0c 09       	add	r9,r6
80009ac2:	87 0a       	st.w	r3[0x0],r10
80009ac4:	fb 49 06 90 	st.w	sp[1680],r9
80009ac8:	2f f8       	sub	r8,-1
80009aca:	87 16       	st.w	r3[0x4],r6
80009acc:	c5 39       	rjmp	80009d72 <_vfprintf_r+0x1c9a>
80009ace:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009ad2:	58 0a       	cp.w	r10,0
80009ad4:	e0 89 00 92 	brgt	80009bf8 <_vfprintf_r+0x1b20>
80009ad8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009adc:	fe c9 bb 0c 	sub	r9,pc,-17652
80009ae0:	2f f8       	sub	r8,-1
80009ae2:	87 09       	st.w	r3[0x0],r9
80009ae4:	fb 48 06 90 	st.w	sp[1680],r8
80009ae8:	30 19       	mov	r9,1
80009aea:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aee:	87 19       	st.w	r3[0x4],r9
80009af0:	2f f8       	sub	r8,-1
80009af2:	fb 48 06 8c 	st.w	sp[1676],r8
80009af6:	58 78       	cp.w	r8,7
80009af8:	e0 89 00 04 	brgt	80009b00 <_vfprintf_r+0x1a28>
80009afc:	2f 83       	sub	r3,-8
80009afe:	c0 b8       	rjmp	80009b14 <_vfprintf_r+0x1a3c>
80009b00:	fa ca f9 78 	sub	r10,sp,-1672
80009b04:	02 9b       	mov	r11,r1
80009b06:	08 9c       	mov	r12,r4
80009b08:	fe b0 f2 da 	rcall	800080bc <__sprint_r>
80009b0c:	e0 81 02 65 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009b10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b14:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b18:	58 08       	cp.w	r8,0
80009b1a:	c0 81       	brne	80009b2a <_vfprintf_r+0x1a52>
80009b1c:	40 6a       	lddsp	r10,sp[0x18]
80009b1e:	58 0a       	cp.w	r10,0
80009b20:	c0 51       	brne	80009b2a <_vfprintf_r+0x1a52>
80009b22:	ed b5 00 00 	bld	r5,0x0
80009b26:	e0 81 01 ed 	brne	80009f00 <_vfprintf_r+0x1e28>
80009b2a:	40 c9       	lddsp	r9,sp[0x30]
80009b2c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b30:	2f f8       	sub	r8,-1
80009b32:	87 09       	st.w	r3[0x0],r9
80009b34:	fb 48 06 90 	st.w	sp[1680],r8
80009b38:	30 19       	mov	r9,1
80009b3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b3e:	87 19       	st.w	r3[0x4],r9
80009b40:	2f f8       	sub	r8,-1
80009b42:	fb 48 06 8c 	st.w	sp[1676],r8
80009b46:	58 78       	cp.w	r8,7
80009b48:	e0 89 00 04 	brgt	80009b50 <_vfprintf_r+0x1a78>
80009b4c:	2f 83       	sub	r3,-8
80009b4e:	c0 b8       	rjmp	80009b64 <_vfprintf_r+0x1a8c>
80009b50:	fa ca f9 78 	sub	r10,sp,-1672
80009b54:	02 9b       	mov	r11,r1
80009b56:	08 9c       	mov	r12,r4
80009b58:	fe b0 f2 b2 	rcall	800080bc <__sprint_r>
80009b5c:	e0 81 02 3d 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009b60:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b64:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b68:	5c 32       	neg	r2
80009b6a:	58 02       	cp.w	r2,0
80009b6c:	e0 89 00 1d 	brgt	80009ba6 <_vfprintf_r+0x1ace>
80009b70:	c3 d8       	rjmp	80009bea <_vfprintf_r+0x1b12>
80009b72:	2f 09       	sub	r9,-16
80009b74:	2f f8       	sub	r8,-1
80009b76:	31 0e       	mov	lr,16
80009b78:	fb 49 06 90 	st.w	sp[1680],r9
80009b7c:	87 00       	st.w	r3[0x0],r0
80009b7e:	87 1e       	st.w	r3[0x4],lr
80009b80:	fb 48 06 8c 	st.w	sp[1676],r8
80009b84:	58 78       	cp.w	r8,7
80009b86:	e0 89 00 04 	brgt	80009b8e <_vfprintf_r+0x1ab6>
80009b8a:	2f 83       	sub	r3,-8
80009b8c:	c0 b8       	rjmp	80009ba2 <_vfprintf_r+0x1aca>
80009b8e:	fa ca f9 78 	sub	r10,sp,-1672
80009b92:	02 9b       	mov	r11,r1
80009b94:	08 9c       	mov	r12,r4
80009b96:	fe b0 f2 93 	rcall	800080bc <__sprint_r>
80009b9a:	e0 81 02 1e 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009b9e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ba2:	21 02       	sub	r2,16
80009ba4:	c0 38       	rjmp	80009baa <_vfprintf_r+0x1ad2>
80009ba6:	fe c0 bb c2 	sub	r0,pc,-17470
80009baa:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bae:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bb2:	fe ca bb ce 	sub	r10,pc,-17458
80009bb6:	59 02       	cp.w	r2,16
80009bb8:	fe 99 ff dd 	brgt	80009b72 <_vfprintf_r+0x1a9a>
80009bbc:	04 09       	add	r9,r2
80009bbe:	2f f8       	sub	r8,-1
80009bc0:	87 0a       	st.w	r3[0x0],r10
80009bc2:	fb 49 06 90 	st.w	sp[1680],r9
80009bc6:	87 12       	st.w	r3[0x4],r2
80009bc8:	fb 48 06 8c 	st.w	sp[1676],r8
80009bcc:	58 78       	cp.w	r8,7
80009bce:	e0 89 00 04 	brgt	80009bd6 <_vfprintf_r+0x1afe>
80009bd2:	2f 83       	sub	r3,-8
80009bd4:	c0 b8       	rjmp	80009bea <_vfprintf_r+0x1b12>
80009bd6:	fa ca f9 78 	sub	r10,sp,-1672
80009bda:	02 9b       	mov	r11,r1
80009bdc:	08 9c       	mov	r12,r4
80009bde:	fe b0 f2 6f 	rcall	800080bc <__sprint_r>
80009be2:	e0 81 01 fa 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009be6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bea:	40 6c       	lddsp	r12,sp[0x18]
80009bec:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bf0:	87 06       	st.w	r3[0x0],r6
80009bf2:	87 1c       	st.w	r3[0x4],r12
80009bf4:	18 08       	add	r8,r12
80009bf6:	cb 98       	rjmp	80009d68 <_vfprintf_r+0x1c90>
80009bf8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bfc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c00:	40 6b       	lddsp	r11,sp[0x18]
80009c02:	16 3a       	cp.w	r10,r11
80009c04:	c6 f5       	brlt	80009ce2 <_vfprintf_r+0x1c0a>
80009c06:	16 09       	add	r9,r11
80009c08:	2f f8       	sub	r8,-1
80009c0a:	87 06       	st.w	r3[0x0],r6
80009c0c:	fb 49 06 90 	st.w	sp[1680],r9
80009c10:	87 1b       	st.w	r3[0x4],r11
80009c12:	fb 48 06 8c 	st.w	sp[1676],r8
80009c16:	58 78       	cp.w	r8,7
80009c18:	e0 89 00 04 	brgt	80009c20 <_vfprintf_r+0x1b48>
80009c1c:	2f 83       	sub	r3,-8
80009c1e:	c0 b8       	rjmp	80009c34 <_vfprintf_r+0x1b5c>
80009c20:	fa ca f9 78 	sub	r10,sp,-1672
80009c24:	02 9b       	mov	r11,r1
80009c26:	08 9c       	mov	r12,r4
80009c28:	fe b0 f2 4a 	rcall	800080bc <__sprint_r>
80009c2c:	e0 81 01 d5 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009c30:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c34:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009c38:	40 6a       	lddsp	r10,sp[0x18]
80009c3a:	14 16       	sub	r6,r10
80009c3c:	58 06       	cp.w	r6,0
80009c3e:	e0 89 00 1c 	brgt	80009c76 <_vfprintf_r+0x1b9e>
80009c42:	c3 d8       	rjmp	80009cbc <_vfprintf_r+0x1be4>
80009c44:	2f 09       	sub	r9,-16
80009c46:	2f f8       	sub	r8,-1
80009c48:	fb 49 06 90 	st.w	sp[1680],r9
80009c4c:	87 02       	st.w	r3[0x0],r2
80009c4e:	87 10       	st.w	r3[0x4],r0
80009c50:	fb 48 06 8c 	st.w	sp[1676],r8
80009c54:	58 78       	cp.w	r8,7
80009c56:	e0 89 00 04 	brgt	80009c5e <_vfprintf_r+0x1b86>
80009c5a:	2f 83       	sub	r3,-8
80009c5c:	c0 b8       	rjmp	80009c72 <_vfprintf_r+0x1b9a>
80009c5e:	fa ca f9 78 	sub	r10,sp,-1672
80009c62:	02 9b       	mov	r11,r1
80009c64:	08 9c       	mov	r12,r4
80009c66:	fe b0 f2 2b 	rcall	800080bc <__sprint_r>
80009c6a:	e0 81 01 b6 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009c6e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c72:	21 06       	sub	r6,16
80009c74:	c0 48       	rjmp	80009c7c <_vfprintf_r+0x1ba4>
80009c76:	fe c2 bc 92 	sub	r2,pc,-17262
80009c7a:	31 00       	mov	r0,16
80009c7c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c80:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c84:	fe ca bc a0 	sub	r10,pc,-17248
80009c88:	59 06       	cp.w	r6,16
80009c8a:	fe 99 ff dd 	brgt	80009c44 <_vfprintf_r+0x1b6c>
80009c8e:	0c 09       	add	r9,r6
80009c90:	2f f8       	sub	r8,-1
80009c92:	87 0a       	st.w	r3[0x0],r10
80009c94:	fb 49 06 90 	st.w	sp[1680],r9
80009c98:	87 16       	st.w	r3[0x4],r6
80009c9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009c9e:	58 78       	cp.w	r8,7
80009ca0:	e0 89 00 04 	brgt	80009ca8 <_vfprintf_r+0x1bd0>
80009ca4:	2f 83       	sub	r3,-8
80009ca6:	c0 b8       	rjmp	80009cbc <_vfprintf_r+0x1be4>
80009ca8:	fa ca f9 78 	sub	r10,sp,-1672
80009cac:	02 9b       	mov	r11,r1
80009cae:	08 9c       	mov	r12,r4
80009cb0:	fe b0 f2 06 	rcall	800080bc <__sprint_r>
80009cb4:	e0 81 01 91 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009cb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cbc:	ed b5 00 00 	bld	r5,0x0
80009cc0:	e0 81 01 20 	brne	80009f00 <_vfprintf_r+0x1e28>
80009cc4:	40 c9       	lddsp	r9,sp[0x30]
80009cc6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cca:	2f f8       	sub	r8,-1
80009ccc:	87 09       	st.w	r3[0x0],r9
80009cce:	fb 48 06 90 	st.w	sp[1680],r8
80009cd2:	30 19       	mov	r9,1
80009cd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cd8:	87 19       	st.w	r3[0x4],r9
80009cda:	2f f8       	sub	r8,-1
80009cdc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ce0:	c0 29       	rjmp	80009ee4 <_vfprintf_r+0x1e0c>
80009ce2:	14 09       	add	r9,r10
80009ce4:	2f f8       	sub	r8,-1
80009ce6:	fb 49 06 90 	st.w	sp[1680],r9
80009cea:	87 06       	st.w	r3[0x0],r6
80009cec:	87 1a       	st.w	r3[0x4],r10
80009cee:	fb 48 06 8c 	st.w	sp[1676],r8
80009cf2:	58 78       	cp.w	r8,7
80009cf4:	e0 89 00 04 	brgt	80009cfc <_vfprintf_r+0x1c24>
80009cf8:	2f 83       	sub	r3,-8
80009cfa:	c0 b8       	rjmp	80009d10 <_vfprintf_r+0x1c38>
80009cfc:	fa ca f9 78 	sub	r10,sp,-1672
80009d00:	02 9b       	mov	r11,r1
80009d02:	08 9c       	mov	r12,r4
80009d04:	fe b0 f1 dc 	rcall	800080bc <__sprint_r>
80009d08:	e0 81 01 67 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009d0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d10:	40 c8       	lddsp	r8,sp[0x30]
80009d12:	87 08       	st.w	r3[0x0],r8
80009d14:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d18:	2f f8       	sub	r8,-1
80009d1a:	30 19       	mov	r9,1
80009d1c:	fb 48 06 90 	st.w	sp[1680],r8
80009d20:	87 19       	st.w	r3[0x4],r9
80009d22:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d26:	2f f8       	sub	r8,-1
80009d28:	fb 48 06 8c 	st.w	sp[1676],r8
80009d2c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009d30:	58 78       	cp.w	r8,7
80009d32:	e0 89 00 04 	brgt	80009d3a <_vfprintf_r+0x1c62>
80009d36:	2f 83       	sub	r3,-8
80009d38:	c0 b8       	rjmp	80009d4e <_vfprintf_r+0x1c76>
80009d3a:	fa ca f9 78 	sub	r10,sp,-1672
80009d3e:	02 9b       	mov	r11,r1
80009d40:	08 9c       	mov	r12,r4
80009d42:	fe b0 f1 bd 	rcall	800080bc <__sprint_r>
80009d46:	e0 81 01 48 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009d4a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d4e:	04 06       	add	r6,r2
80009d50:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009d54:	87 06       	st.w	r3[0x0],r6
80009d56:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d5a:	40 66       	lddsp	r6,sp[0x18]
80009d5c:	40 6e       	lddsp	lr,sp[0x18]
80009d5e:	10 16       	sub	r6,r8
80009d60:	f2 08 01 08 	sub	r8,r9,r8
80009d64:	87 16       	st.w	r3[0x4],r6
80009d66:	1c 08       	add	r8,lr
80009d68:	fb 48 06 90 	st.w	sp[1680],r8
80009d6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d70:	2f f8       	sub	r8,-1
80009d72:	fb 48 06 8c 	st.w	sp[1676],r8
80009d76:	cb 78       	rjmp	80009ee4 <_vfprintf_r+0x1e0c>
80009d78:	40 6c       	lddsp	r12,sp[0x18]
80009d7a:	58 1c       	cp.w	r12,1
80009d7c:	e0 89 00 06 	brgt	80009d88 <_vfprintf_r+0x1cb0>
80009d80:	ed b5 00 00 	bld	r5,0x0
80009d84:	e0 81 00 85 	brne	80009e8e <_vfprintf_r+0x1db6>
80009d88:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d8c:	2f f8       	sub	r8,-1
80009d8e:	30 19       	mov	r9,1
80009d90:	fb 48 06 90 	st.w	sp[1680],r8
80009d94:	87 06       	st.w	r3[0x0],r6
80009d96:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d9a:	87 19       	st.w	r3[0x4],r9
80009d9c:	2f f8       	sub	r8,-1
80009d9e:	fb 48 06 8c 	st.w	sp[1676],r8
80009da2:	58 78       	cp.w	r8,7
80009da4:	e0 89 00 04 	brgt	80009dac <_vfprintf_r+0x1cd4>
80009da8:	2f 83       	sub	r3,-8
80009daa:	c0 b8       	rjmp	80009dc0 <_vfprintf_r+0x1ce8>
80009dac:	fa ca f9 78 	sub	r10,sp,-1672
80009db0:	02 9b       	mov	r11,r1
80009db2:	08 9c       	mov	r12,r4
80009db4:	fe b0 f1 84 	rcall	800080bc <__sprint_r>
80009db8:	e0 81 01 0f 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009dbc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dc0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dc4:	2f f8       	sub	r8,-1
80009dc6:	40 cb       	lddsp	r11,sp[0x30]
80009dc8:	fb 48 06 90 	st.w	sp[1680],r8
80009dcc:	30 19       	mov	r9,1
80009dce:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dd2:	87 0b       	st.w	r3[0x0],r11
80009dd4:	2f f8       	sub	r8,-1
80009dd6:	87 19       	st.w	r3[0x4],r9
80009dd8:	fb 48 06 8c 	st.w	sp[1676],r8
80009ddc:	58 78       	cp.w	r8,7
80009dde:	e0 89 00 05 	brgt	80009de8 <_vfprintf_r+0x1d10>
80009de2:	2f 83       	sub	r3,-8
80009de4:	c0 c8       	rjmp	80009dfc <_vfprintf_r+0x1d24>
80009de6:	d7 03       	nop
80009de8:	fa ca f9 78 	sub	r10,sp,-1672
80009dec:	02 9b       	mov	r11,r1
80009dee:	08 9c       	mov	r12,r4
80009df0:	fe b0 f1 66 	rcall	800080bc <__sprint_r>
80009df4:	e0 81 00 f1 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009df8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dfc:	30 08       	mov	r8,0
80009dfe:	30 09       	mov	r9,0
80009e00:	40 5b       	lddsp	r11,sp[0x14]
80009e02:	40 7a       	lddsp	r10,sp[0x1c]
80009e04:	e0 a0 13 25 	rcall	8000c44e <__avr32_f64_cmp_eq>
80009e08:	40 68       	lddsp	r8,sp[0x18]
80009e0a:	20 18       	sub	r8,1
80009e0c:	58 0c       	cp.w	r12,0
80009e0e:	c0 d1       	brne	80009e28 <_vfprintf_r+0x1d50>
80009e10:	2f f6       	sub	r6,-1
80009e12:	87 18       	st.w	r3[0x4],r8
80009e14:	87 06       	st.w	r3[0x0],r6
80009e16:	fa f6 06 90 	ld.w	r6,sp[1680]
80009e1a:	10 06       	add	r6,r8
80009e1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e20:	fb 46 06 90 	st.w	sp[1680],r6
80009e24:	2f f8       	sub	r8,-1
80009e26:	c3 18       	rjmp	80009e88 <_vfprintf_r+0x1db0>
80009e28:	10 96       	mov	r6,r8
80009e2a:	58 08       	cp.w	r8,0
80009e2c:	e0 89 00 1c 	brgt	80009e64 <_vfprintf_r+0x1d8c>
80009e30:	c4 b8       	rjmp	80009ec6 <_vfprintf_r+0x1dee>
80009e32:	2f 09       	sub	r9,-16
80009e34:	2f f8       	sub	r8,-1
80009e36:	fb 49 06 90 	st.w	sp[1680],r9
80009e3a:	87 02       	st.w	r3[0x0],r2
80009e3c:	87 10       	st.w	r3[0x4],r0
80009e3e:	fb 48 06 8c 	st.w	sp[1676],r8
80009e42:	58 78       	cp.w	r8,7
80009e44:	e0 89 00 04 	brgt	80009e4c <_vfprintf_r+0x1d74>
80009e48:	2f 83       	sub	r3,-8
80009e4a:	c0 b8       	rjmp	80009e60 <_vfprintf_r+0x1d88>
80009e4c:	fa ca f9 78 	sub	r10,sp,-1672
80009e50:	02 9b       	mov	r11,r1
80009e52:	08 9c       	mov	r12,r4
80009e54:	fe b0 f1 34 	rcall	800080bc <__sprint_r>
80009e58:	e0 81 00 bf 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009e5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e60:	21 06       	sub	r6,16
80009e62:	c0 48       	rjmp	80009e6a <_vfprintf_r+0x1d92>
80009e64:	fe c2 be 80 	sub	r2,pc,-16768
80009e68:	31 00       	mov	r0,16
80009e6a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e6e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e72:	fe ca be 8e 	sub	r10,pc,-16754
80009e76:	59 06       	cp.w	r6,16
80009e78:	fe 99 ff dd 	brgt	80009e32 <_vfprintf_r+0x1d5a>
80009e7c:	0c 09       	add	r9,r6
80009e7e:	87 0a       	st.w	r3[0x0],r10
80009e80:	fb 49 06 90 	st.w	sp[1680],r9
80009e84:	2f f8       	sub	r8,-1
80009e86:	87 16       	st.w	r3[0x4],r6
80009e88:	fb 48 06 8c 	st.w	sp[1676],r8
80009e8c:	c0 e8       	rjmp	80009ea8 <_vfprintf_r+0x1dd0>
80009e8e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e92:	2f f8       	sub	r8,-1
80009e94:	30 19       	mov	r9,1
80009e96:	fb 48 06 90 	st.w	sp[1680],r8
80009e9a:	87 06       	st.w	r3[0x0],r6
80009e9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ea0:	87 19       	st.w	r3[0x4],r9
80009ea2:	2f f8       	sub	r8,-1
80009ea4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ea8:	58 78       	cp.w	r8,7
80009eaa:	e0 89 00 04 	brgt	80009eb2 <_vfprintf_r+0x1dda>
80009eae:	2f 83       	sub	r3,-8
80009eb0:	c0 b8       	rjmp	80009ec6 <_vfprintf_r+0x1dee>
80009eb2:	fa ca f9 78 	sub	r10,sp,-1672
80009eb6:	02 9b       	mov	r11,r1
80009eb8:	08 9c       	mov	r12,r4
80009eba:	fe b0 f1 01 	rcall	800080bc <__sprint_r>
80009ebe:	e0 81 00 8c 	brne	80009fd6 <_vfprintf_r+0x1efe>
80009ec2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ec6:	40 ea       	lddsp	r10,sp[0x38]
80009ec8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ecc:	14 08       	add	r8,r10
80009ece:	fa c9 f9 64 	sub	r9,sp,-1692
80009ed2:	fb 48 06 90 	st.w	sp[1680],r8
80009ed6:	87 1a       	st.w	r3[0x4],r10
80009ed8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009edc:	87 09       	st.w	r3[0x0],r9
80009ede:	2f f8       	sub	r8,-1
80009ee0:	fb 48 06 8c 	st.w	sp[1676],r8
80009ee4:	58 78       	cp.w	r8,7
80009ee6:	e0 89 00 04 	brgt	80009eee <_vfprintf_r+0x1e16>
80009eea:	2f 83       	sub	r3,-8
80009eec:	c0 a8       	rjmp	80009f00 <_vfprintf_r+0x1e28>
80009eee:	fa ca f9 78 	sub	r10,sp,-1672
80009ef2:	02 9b       	mov	r11,r1
80009ef4:	08 9c       	mov	r12,r4
80009ef6:	fe b0 f0 e3 	rcall	800080bc <__sprint_r>
80009efa:	c6 e1       	brne	80009fd6 <_vfprintf_r+0x1efe>
80009efc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f00:	e2 15 00 04 	andl	r5,0x4,COH
80009f04:	c3 f0       	breq	80009f82 <_vfprintf_r+0x1eaa>
80009f06:	40 86       	lddsp	r6,sp[0x20]
80009f08:	40 39       	lddsp	r9,sp[0xc]
80009f0a:	12 16       	sub	r6,r9
80009f0c:	58 06       	cp.w	r6,0
80009f0e:	e0 89 00 1a 	brgt	80009f42 <_vfprintf_r+0x1e6a>
80009f12:	c3 88       	rjmp	80009f82 <_vfprintf_r+0x1eaa>
80009f14:	2f 09       	sub	r9,-16
80009f16:	2f f8       	sub	r8,-1
80009f18:	fb 49 06 90 	st.w	sp[1680],r9
80009f1c:	87 05       	st.w	r3[0x0],r5
80009f1e:	87 12       	st.w	r3[0x4],r2
80009f20:	fb 48 06 8c 	st.w	sp[1676],r8
80009f24:	58 78       	cp.w	r8,7
80009f26:	e0 89 00 04 	brgt	80009f2e <_vfprintf_r+0x1e56>
80009f2a:	2f 83       	sub	r3,-8
80009f2c:	c0 98       	rjmp	80009f3e <_vfprintf_r+0x1e66>
80009f2e:	00 9a       	mov	r10,r0
80009f30:	02 9b       	mov	r11,r1
80009f32:	08 9c       	mov	r12,r4
80009f34:	fe b0 f0 c4 	rcall	800080bc <__sprint_r>
80009f38:	c4 f1       	brne	80009fd6 <_vfprintf_r+0x1efe>
80009f3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f3e:	21 06       	sub	r6,16
80009f40:	c0 68       	rjmp	80009f4c <_vfprintf_r+0x1e74>
80009f42:	fe c5 bf 6e 	sub	r5,pc,-16530
80009f46:	31 02       	mov	r2,16
80009f48:	fa c0 f9 78 	sub	r0,sp,-1672
80009f4c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f54:	fe ca bf 80 	sub	r10,pc,-16512
80009f58:	59 06       	cp.w	r6,16
80009f5a:	fe 99 ff dd 	brgt	80009f14 <_vfprintf_r+0x1e3c>
80009f5e:	0c 09       	add	r9,r6
80009f60:	2f f8       	sub	r8,-1
80009f62:	87 0a       	st.w	r3[0x0],r10
80009f64:	87 16       	st.w	r3[0x4],r6
80009f66:	fb 49 06 90 	st.w	sp[1680],r9
80009f6a:	fb 48 06 8c 	st.w	sp[1676],r8
80009f6e:	58 78       	cp.w	r8,7
80009f70:	e0 8a 00 09 	brle	80009f82 <_vfprintf_r+0x1eaa>
80009f74:	fa ca f9 78 	sub	r10,sp,-1672
80009f78:	02 9b       	mov	r11,r1
80009f7a:	08 9c       	mov	r12,r4
80009f7c:	fe b0 f0 a0 	rcall	800080bc <__sprint_r>
80009f80:	c2 b1       	brne	80009fd6 <_vfprintf_r+0x1efe>
80009f82:	40 bc       	lddsp	r12,sp[0x2c]
80009f84:	40 36       	lddsp	r6,sp[0xc]
80009f86:	40 8e       	lddsp	lr,sp[0x20]
80009f88:	ec 0e 0c 48 	max	r8,r6,lr
80009f8c:	10 0c       	add	r12,r8
80009f8e:	50 bc       	stdsp	sp[0x2c],r12
80009f90:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f94:	58 08       	cp.w	r8,0
80009f96:	c0 80       	breq	80009fa6 <_vfprintf_r+0x1ece>
80009f98:	fa ca f9 78 	sub	r10,sp,-1672
80009f9c:	02 9b       	mov	r11,r1
80009f9e:	08 9c       	mov	r12,r4
80009fa0:	fe b0 f0 8e 	rcall	800080bc <__sprint_r>
80009fa4:	c1 91       	brne	80009fd6 <_vfprintf_r+0x1efe>
80009fa6:	30 0b       	mov	r11,0
80009fa8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fac:	fb 4b 06 8c 	st.w	sp[1676],r11
80009fb0:	fe 9f f1 22 	bral	800081f4 <_vfprintf_r+0x11c>
80009fb4:	08 95       	mov	r5,r4
80009fb6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fba:	58 08       	cp.w	r8,0
80009fbc:	c0 80       	breq	80009fcc <_vfprintf_r+0x1ef4>
80009fbe:	08 9c       	mov	r12,r4
80009fc0:	fa ca f9 78 	sub	r10,sp,-1672
80009fc4:	02 9b       	mov	r11,r1
80009fc6:	fe b0 f0 7b 	rcall	800080bc <__sprint_r>
80009fca:	c0 61       	brne	80009fd6 <_vfprintf_r+0x1efe>
80009fcc:	30 08       	mov	r8,0
80009fce:	fb 48 06 8c 	st.w	sp[1676],r8
80009fd2:	c0 28       	rjmp	80009fd6 <_vfprintf_r+0x1efe>
80009fd4:	40 41       	lddsp	r1,sp[0x10]
80009fd6:	82 68       	ld.sh	r8,r1[0xc]
80009fd8:	ed b8 00 06 	bld	r8,0x6
80009fdc:	c0 31       	brne	80009fe2 <_vfprintf_r+0x1f0a>
80009fde:	3f fa       	mov	r10,-1
80009fe0:	50 ba       	stdsp	sp[0x2c],r10
80009fe2:	40 bc       	lddsp	r12,sp[0x2c]
80009fe4:	fe 3d f9 44 	sub	sp,-1724
80009fe8:	d8 32       	popm	r0-r7,pc
80009fea:	d7 03       	nop

80009fec <__swsetup_r>:
80009fec:	d4 21       	pushm	r4-r7,lr
80009fee:	e0 68 0a 3c 	mov	r8,2620
80009ff2:	18 96       	mov	r6,r12
80009ff4:	16 97       	mov	r7,r11
80009ff6:	70 0c       	ld.w	r12,r8[0x0]
80009ff8:	58 0c       	cp.w	r12,0
80009ffa:	c0 60       	breq	8000a006 <__swsetup_r+0x1a>
80009ffc:	78 68       	ld.w	r8,r12[0x18]
80009ffe:	58 08       	cp.w	r8,0
8000a000:	c0 31       	brne	8000a006 <__swsetup_r+0x1a>
8000a002:	e0 a0 07 bf 	rcall	8000af80 <__sinit>
8000a006:	fe c8 bf 02 	sub	r8,pc,-16638
8000a00a:	10 37       	cp.w	r7,r8
8000a00c:	c0 61       	brne	8000a018 <__swsetup_r+0x2c>
8000a00e:	e0 68 0a 3c 	mov	r8,2620
8000a012:	70 08       	ld.w	r8,r8[0x0]
8000a014:	70 07       	ld.w	r7,r8[0x0]
8000a016:	c1 28       	rjmp	8000a03a <__swsetup_r+0x4e>
8000a018:	fe c8 be f4 	sub	r8,pc,-16652
8000a01c:	10 37       	cp.w	r7,r8
8000a01e:	c0 61       	brne	8000a02a <__swsetup_r+0x3e>
8000a020:	e0 68 0a 3c 	mov	r8,2620
8000a024:	70 08       	ld.w	r8,r8[0x0]
8000a026:	70 17       	ld.w	r7,r8[0x4]
8000a028:	c0 98       	rjmp	8000a03a <__swsetup_r+0x4e>
8000a02a:	fe c8 be e6 	sub	r8,pc,-16666
8000a02e:	10 37       	cp.w	r7,r8
8000a030:	c0 51       	brne	8000a03a <__swsetup_r+0x4e>
8000a032:	e0 68 0a 3c 	mov	r8,2620
8000a036:	70 08       	ld.w	r8,r8[0x0]
8000a038:	70 27       	ld.w	r7,r8[0x8]
8000a03a:	8e 68       	ld.sh	r8,r7[0xc]
8000a03c:	ed b8 00 03 	bld	r8,0x3
8000a040:	c1 e0       	breq	8000a07c <__swsetup_r+0x90>
8000a042:	ed b8 00 04 	bld	r8,0x4
8000a046:	c3 e1       	brne	8000a0c2 <__swsetup_r+0xd6>
8000a048:	ed b8 00 02 	bld	r8,0x2
8000a04c:	c1 51       	brne	8000a076 <__swsetup_r+0x8a>
8000a04e:	6e db       	ld.w	r11,r7[0x34]
8000a050:	58 0b       	cp.w	r11,0
8000a052:	c0 a0       	breq	8000a066 <__swsetup_r+0x7a>
8000a054:	ee c8 ff bc 	sub	r8,r7,-68
8000a058:	10 3b       	cp.w	r11,r8
8000a05a:	c0 40       	breq	8000a062 <__swsetup_r+0x76>
8000a05c:	0c 9c       	mov	r12,r6
8000a05e:	e0 a0 08 2b 	rcall	8000b0b4 <_free_r>
8000a062:	30 08       	mov	r8,0
8000a064:	8f d8       	st.w	r7[0x34],r8
8000a066:	8e 68       	ld.sh	r8,r7[0xc]
8000a068:	e0 18 ff db 	andl	r8,0xffdb
8000a06c:	ae 68       	st.h	r7[0xc],r8
8000a06e:	30 08       	mov	r8,0
8000a070:	8f 18       	st.w	r7[0x4],r8
8000a072:	6e 48       	ld.w	r8,r7[0x10]
8000a074:	8f 08       	st.w	r7[0x0],r8
8000a076:	8e 68       	ld.sh	r8,r7[0xc]
8000a078:	a3 b8       	sbr	r8,0x3
8000a07a:	ae 68       	st.h	r7[0xc],r8
8000a07c:	6e 48       	ld.w	r8,r7[0x10]
8000a07e:	58 08       	cp.w	r8,0
8000a080:	c0 b1       	brne	8000a096 <__swsetup_r+0xaa>
8000a082:	8e 68       	ld.sh	r8,r7[0xc]
8000a084:	e2 18 02 80 	andl	r8,0x280,COH
8000a088:	e0 48 02 00 	cp.w	r8,512
8000a08c:	c0 50       	breq	8000a096 <__swsetup_r+0xaa>
8000a08e:	0c 9c       	mov	r12,r6
8000a090:	0e 9b       	mov	r11,r7
8000a092:	e0 a0 0a 4b 	rcall	8000b528 <__smakebuf_r>
8000a096:	8e 69       	ld.sh	r9,r7[0xc]
8000a098:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a09c:	c0 70       	breq	8000a0aa <__swsetup_r+0xbe>
8000a09e:	30 08       	mov	r8,0
8000a0a0:	8f 28       	st.w	r7[0x8],r8
8000a0a2:	6e 58       	ld.w	r8,r7[0x14]
8000a0a4:	5c 38       	neg	r8
8000a0a6:	8f 68       	st.w	r7[0x18],r8
8000a0a8:	c0 68       	rjmp	8000a0b4 <__swsetup_r+0xc8>
8000a0aa:	ed b9 00 01 	bld	r9,0x1
8000a0ae:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a0b2:	8f 28       	st.w	r7[0x8],r8
8000a0b4:	6e 48       	ld.w	r8,r7[0x10]
8000a0b6:	58 08       	cp.w	r8,0
8000a0b8:	c0 61       	brne	8000a0c4 <__swsetup_r+0xd8>
8000a0ba:	8e 68       	ld.sh	r8,r7[0xc]
8000a0bc:	ed b8 00 07 	bld	r8,0x7
8000a0c0:	c0 21       	brne	8000a0c4 <__swsetup_r+0xd8>
8000a0c2:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a0c4:	d8 2a       	popm	r4-r7,pc,r12=0
8000a0c6:	d7 03       	nop

8000a0c8 <quorem>:
8000a0c8:	d4 31       	pushm	r0-r7,lr
8000a0ca:	20 2d       	sub	sp,8
8000a0cc:	18 97       	mov	r7,r12
8000a0ce:	78 48       	ld.w	r8,r12[0x10]
8000a0d0:	76 46       	ld.w	r6,r11[0x10]
8000a0d2:	0c 38       	cp.w	r8,r6
8000a0d4:	c0 34       	brge	8000a0da <quorem+0x12>
8000a0d6:	30 0c       	mov	r12,0
8000a0d8:	c8 58       	rjmp	8000a1e2 <quorem+0x11a>
8000a0da:	ec c2 ff fc 	sub	r2,r6,-4
8000a0de:	f6 c3 ff ec 	sub	r3,r11,-20
8000a0e2:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a0e6:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a0ea:	2f f9       	sub	r9,-1
8000a0ec:	20 16       	sub	r6,1
8000a0ee:	f8 09 0d 08 	divu	r8,r12,r9
8000a0f2:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a0f6:	ee c4 ff ec 	sub	r4,r7,-20
8000a0fa:	10 95       	mov	r5,r8
8000a0fc:	58 08       	cp.w	r8,0
8000a0fe:	c4 10       	breq	8000a180 <quorem+0xb8>
8000a100:	30 09       	mov	r9,0
8000a102:	06 9a       	mov	r10,r3
8000a104:	08 98       	mov	r8,r4
8000a106:	12 91       	mov	r1,r9
8000a108:	50 0b       	stdsp	sp[0x0],r11
8000a10a:	70 0e       	ld.w	lr,r8[0x0]
8000a10c:	b1 8e       	lsr	lr,0x10
8000a10e:	50 1e       	stdsp	sp[0x4],lr
8000a110:	15 0e       	ld.w	lr,r10++
8000a112:	fc 00 16 10 	lsr	r0,lr,0x10
8000a116:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a11a:	ea 0e 03 41 	mac	r1,r5,lr
8000a11e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a122:	b1 81       	lsr	r1,0x10
8000a124:	40 1b       	lddsp	r11,sp[0x4]
8000a126:	ea 00 02 40 	mul	r0,r5,r0
8000a12a:	e2 00 00 00 	add	r0,r1,r0
8000a12e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a132:	02 1b       	sub	r11,r1
8000a134:	50 1b       	stdsp	sp[0x4],r11
8000a136:	70 0b       	ld.w	r11,r8[0x0]
8000a138:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a13c:	02 09       	add	r9,r1
8000a13e:	f2 0e 01 0e 	sub	lr,r9,lr
8000a142:	b0 1e       	st.h	r8[0x2],lr
8000a144:	fc 09 14 10 	asr	r9,lr,0x10
8000a148:	40 1e       	lddsp	lr,sp[0x4]
8000a14a:	fc 09 00 09 	add	r9,lr,r9
8000a14e:	b0 09       	st.h	r8[0x0],r9
8000a150:	e0 01 16 10 	lsr	r1,r0,0x10
8000a154:	2f c8       	sub	r8,-4
8000a156:	b1 49       	asr	r9,0x10
8000a158:	04 3a       	cp.w	r10,r2
8000a15a:	fe 98 ff d8 	brls	8000a10a <quorem+0x42>
8000a15e:	40 0b       	lddsp	r11,sp[0x0]
8000a160:	58 0c       	cp.w	r12,0
8000a162:	c0 f1       	brne	8000a180 <quorem+0xb8>
8000a164:	ec c8 ff fb 	sub	r8,r6,-5
8000a168:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a16c:	c0 28       	rjmp	8000a170 <quorem+0xa8>
8000a16e:	20 16       	sub	r6,1
8000a170:	20 48       	sub	r8,4
8000a172:	08 38       	cp.w	r8,r4
8000a174:	e0 88 00 05 	brls	8000a17e <quorem+0xb6>
8000a178:	70 09       	ld.w	r9,r8[0x0]
8000a17a:	58 09       	cp.w	r9,0
8000a17c:	cf 90       	breq	8000a16e <quorem+0xa6>
8000a17e:	8f 46       	st.w	r7[0x10],r6
8000a180:	0e 9c       	mov	r12,r7
8000a182:	e0 a0 0a d2 	rcall	8000b726 <__mcmp>
8000a186:	c2 d5       	brlt	8000a1e0 <quorem+0x118>
8000a188:	2f f5       	sub	r5,-1
8000a18a:	08 98       	mov	r8,r4
8000a18c:	30 09       	mov	r9,0
8000a18e:	07 0b       	ld.w	r11,r3++
8000a190:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a194:	70 0c       	ld.w	r12,r8[0x0]
8000a196:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a19a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a19e:	14 1e       	sub	lr,r10
8000a1a0:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a1a4:	16 1a       	sub	r10,r11
8000a1a6:	12 0a       	add	r10,r9
8000a1a8:	b0 1a       	st.h	r8[0x2],r10
8000a1aa:	b1 4a       	asr	r10,0x10
8000a1ac:	fc 0a 00 09 	add	r9,lr,r10
8000a1b0:	b0 09       	st.h	r8[0x0],r9
8000a1b2:	2f c8       	sub	r8,-4
8000a1b4:	b1 49       	asr	r9,0x10
8000a1b6:	04 33       	cp.w	r3,r2
8000a1b8:	fe 98 ff eb 	brls	8000a18e <quorem+0xc6>
8000a1bc:	ec c8 ff fb 	sub	r8,r6,-5
8000a1c0:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a1c4:	58 09       	cp.w	r9,0
8000a1c6:	c0 d1       	brne	8000a1e0 <quorem+0x118>
8000a1c8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a1cc:	c0 28       	rjmp	8000a1d0 <quorem+0x108>
8000a1ce:	20 16       	sub	r6,1
8000a1d0:	20 48       	sub	r8,4
8000a1d2:	08 38       	cp.w	r8,r4
8000a1d4:	e0 88 00 05 	brls	8000a1de <quorem+0x116>
8000a1d8:	70 09       	ld.w	r9,r8[0x0]
8000a1da:	58 09       	cp.w	r9,0
8000a1dc:	cf 90       	breq	8000a1ce <quorem+0x106>
8000a1de:	8f 46       	st.w	r7[0x10],r6
8000a1e0:	0a 9c       	mov	r12,r5
8000a1e2:	2f ed       	sub	sp,-8
8000a1e4:	d8 32       	popm	r0-r7,pc
8000a1e6:	d7 03       	nop

8000a1e8 <_dtoa_r>:
8000a1e8:	d4 31       	pushm	r0-r7,lr
8000a1ea:	21 ad       	sub	sp,104
8000a1ec:	fa c4 ff 74 	sub	r4,sp,-140
8000a1f0:	18 97       	mov	r7,r12
8000a1f2:	16 95       	mov	r5,r11
8000a1f4:	68 2c       	ld.w	r12,r4[0x8]
8000a1f6:	50 c9       	stdsp	sp[0x30],r9
8000a1f8:	68 16       	ld.w	r6,r4[0x4]
8000a1fa:	68 09       	ld.w	r9,r4[0x0]
8000a1fc:	50 e8       	stdsp	sp[0x38],r8
8000a1fe:	14 94       	mov	r4,r10
8000a200:	51 2c       	stdsp	sp[0x48],r12
8000a202:	fa e5 00 08 	st.d	sp[8],r4
8000a206:	51 59       	stdsp	sp[0x54],r9
8000a208:	6e 95       	ld.w	r5,r7[0x24]
8000a20a:	58 05       	cp.w	r5,0
8000a20c:	c0 91       	brne	8000a21e <_dtoa_r+0x36>
8000a20e:	31 0c       	mov	r12,16
8000a210:	fe b0 e8 f4 	rcall	800073f8 <malloc>
8000a214:	99 35       	st.w	r12[0xc],r5
8000a216:	8f 9c       	st.w	r7[0x24],r12
8000a218:	99 15       	st.w	r12[0x4],r5
8000a21a:	99 25       	st.w	r12[0x8],r5
8000a21c:	99 05       	st.w	r12[0x0],r5
8000a21e:	6e 99       	ld.w	r9,r7[0x24]
8000a220:	72 08       	ld.w	r8,r9[0x0]
8000a222:	58 08       	cp.w	r8,0
8000a224:	c0 f0       	breq	8000a242 <_dtoa_r+0x5a>
8000a226:	72 1a       	ld.w	r10,r9[0x4]
8000a228:	91 1a       	st.w	r8[0x4],r10
8000a22a:	30 1a       	mov	r10,1
8000a22c:	72 19       	ld.w	r9,r9[0x4]
8000a22e:	f4 09 09 49 	lsl	r9,r10,r9
8000a232:	10 9b       	mov	r11,r8
8000a234:	91 29       	st.w	r8[0x8],r9
8000a236:	0e 9c       	mov	r12,r7
8000a238:	e0 a0 0a 90 	rcall	8000b758 <_Bfree>
8000a23c:	6e 98       	ld.w	r8,r7[0x24]
8000a23e:	30 09       	mov	r9,0
8000a240:	91 09       	st.w	r8[0x0],r9
8000a242:	40 28       	lddsp	r8,sp[0x8]
8000a244:	10 94       	mov	r4,r8
8000a246:	58 08       	cp.w	r8,0
8000a248:	c0 64       	brge	8000a254 <_dtoa_r+0x6c>
8000a24a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a24e:	50 28       	stdsp	sp[0x8],r8
8000a250:	30 18       	mov	r8,1
8000a252:	c0 28       	rjmp	8000a256 <_dtoa_r+0x6e>
8000a254:	30 08       	mov	r8,0
8000a256:	8d 08       	st.w	r6[0x0],r8
8000a258:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a25c:	40 26       	lddsp	r6,sp[0x8]
8000a25e:	0c 98       	mov	r8,r6
8000a260:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a264:	18 38       	cp.w	r8,r12
8000a266:	c2 01       	brne	8000a2a6 <_dtoa_r+0xbe>
8000a268:	e0 68 27 0f 	mov	r8,9999
8000a26c:	41 5b       	lddsp	r11,sp[0x54]
8000a26e:	97 08       	st.w	r11[0x0],r8
8000a270:	40 3a       	lddsp	r10,sp[0xc]
8000a272:	58 0a       	cp.w	r10,0
8000a274:	c0 71       	brne	8000a282 <_dtoa_r+0x9a>
8000a276:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a27a:	c0 41       	brne	8000a282 <_dtoa_r+0x9a>
8000a27c:	fe cc c1 88 	sub	r12,pc,-15992
8000a280:	c0 38       	rjmp	8000a286 <_dtoa_r+0x9e>
8000a282:	fe cc c1 82 	sub	r12,pc,-15998
8000a286:	41 29       	lddsp	r9,sp[0x48]
8000a288:	58 09       	cp.w	r9,0
8000a28a:	e0 80 05 9a 	breq	8000adbe <_dtoa_r+0xbd6>
8000a28e:	f8 c8 ff fd 	sub	r8,r12,-3
8000a292:	f8 c9 ff f8 	sub	r9,r12,-8
8000a296:	11 8b       	ld.ub	r11,r8[0x0]
8000a298:	30 0a       	mov	r10,0
8000a29a:	41 25       	lddsp	r5,sp[0x48]
8000a29c:	f4 0b 18 00 	cp.b	r11,r10
8000a2a0:	f2 08 17 10 	movne	r8,r9
8000a2a4:	c1 68       	rjmp	8000a2d0 <_dtoa_r+0xe8>
8000a2a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2aa:	30 08       	mov	r8,0
8000a2ac:	fa eb 00 3c 	st.d	sp[60],r10
8000a2b0:	30 09       	mov	r9,0
8000a2b2:	e0 a0 10 ce 	rcall	8000c44e <__avr32_f64_cmp_eq>
8000a2b6:	c1 00       	breq	8000a2d6 <_dtoa_r+0xee>
8000a2b8:	30 18       	mov	r8,1
8000a2ba:	41 5a       	lddsp	r10,sp[0x54]
8000a2bc:	95 08       	st.w	r10[0x0],r8
8000a2be:	fe cc c2 ee 	sub	r12,pc,-15634
8000a2c2:	41 29       	lddsp	r9,sp[0x48]
8000a2c4:	f8 08 00 08 	add	r8,r12,r8
8000a2c8:	58 09       	cp.w	r9,0
8000a2ca:	e0 80 05 7a 	breq	8000adbe <_dtoa_r+0xbd6>
8000a2ce:	12 95       	mov	r5,r9
8000a2d0:	8b 08       	st.w	r5[0x0],r8
8000a2d2:	e0 8f 05 76 	bral	8000adbe <_dtoa_r+0xbd6>
8000a2d6:	fa c8 ff 9c 	sub	r8,sp,-100
8000a2da:	fa c9 ff a0 	sub	r9,sp,-96
8000a2de:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2e2:	0e 9c       	mov	r12,r7
8000a2e4:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a2e8:	e0 a0 0a 8a 	rcall	8000b7fc <__d2b>
8000a2ec:	18 93       	mov	r3,r12
8000a2ee:	58 05       	cp.w	r5,0
8000a2f0:	c0 d0       	breq	8000a30a <_dtoa_r+0x122>
8000a2f2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2f6:	30 04       	mov	r4,0
8000a2f8:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a2fc:	ea c5 03 ff 	sub	r5,r5,1023
8000a300:	10 9b       	mov	r11,r8
8000a302:	51 74       	stdsp	sp[0x5c],r4
8000a304:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a308:	c2 58       	rjmp	8000a352 <_dtoa_r+0x16a>
8000a30a:	41 88       	lddsp	r8,sp[0x60]
8000a30c:	41 9c       	lddsp	r12,sp[0x64]
8000a30e:	10 0c       	add	r12,r8
8000a310:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a314:	e0 45 00 20 	cp.w	r5,32
8000a318:	e0 8a 00 0e 	brle	8000a334 <_dtoa_r+0x14c>
8000a31c:	f8 cc fb ee 	sub	r12,r12,-1042
8000a320:	40 3b       	lddsp	r11,sp[0xc]
8000a322:	ea 08 11 40 	rsub	r8,r5,64
8000a326:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a32a:	ec 08 09 46 	lsl	r6,r6,r8
8000a32e:	0c 4c       	or	r12,r6
8000a330:	c0 78       	rjmp	8000a33e <_dtoa_r+0x156>
8000a332:	d7 03       	nop
8000a334:	ea 0c 11 20 	rsub	r12,r5,32
8000a338:	40 3a       	lddsp	r10,sp[0xc]
8000a33a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a33e:	e0 a0 10 14 	rcall	8000c366 <__avr32_u32_to_f64>
8000a342:	fc 18 fe 10 	movh	r8,0xfe10
8000a346:	30 19       	mov	r9,1
8000a348:	ea c5 04 33 	sub	r5,r5,1075
8000a34c:	f0 0b 00 0b 	add	r11,r8,r11
8000a350:	51 79       	stdsp	sp[0x5c],r9
8000a352:	30 08       	mov	r8,0
8000a354:	fc 19 3f f8 	movh	r9,0x3ff8
8000a358:	e0 a0 0e 9c 	rcall	8000c090 <__avr32_f64_sub>
8000a35c:	e0 68 43 61 	mov	r8,17249
8000a360:	ea 18 63 6f 	orh	r8,0x636f
8000a364:	e0 69 87 a7 	mov	r9,34727
8000a368:	ea 19 3f d2 	orh	r9,0x3fd2
8000a36c:	e0 a0 0d a6 	rcall	8000beb8 <__avr32_f64_mul>
8000a370:	e0 68 c8 b3 	mov	r8,51379
8000a374:	ea 18 8b 60 	orh	r8,0x8b60
8000a378:	e0 69 8a 28 	mov	r9,35368
8000a37c:	ea 19 3f c6 	orh	r9,0x3fc6
8000a380:	e0 a0 0f 56 	rcall	8000c22c <__avr32_f64_add>
8000a384:	0a 9c       	mov	r12,r5
8000a386:	14 90       	mov	r0,r10
8000a388:	16 91       	mov	r1,r11
8000a38a:	e0 a0 0f f2 	rcall	8000c36e <__avr32_s32_to_f64>
8000a38e:	e0 68 79 fb 	mov	r8,31227
8000a392:	ea 18 50 9f 	orh	r8,0x509f
8000a396:	e0 69 44 13 	mov	r9,17427
8000a39a:	ea 19 3f d3 	orh	r9,0x3fd3
8000a39e:	e0 a0 0d 8d 	rcall	8000beb8 <__avr32_f64_mul>
8000a3a2:	14 98       	mov	r8,r10
8000a3a4:	16 99       	mov	r9,r11
8000a3a6:	00 9a       	mov	r10,r0
8000a3a8:	02 9b       	mov	r11,r1
8000a3aa:	e0 a0 0f 41 	rcall	8000c22c <__avr32_f64_add>
8000a3ae:	14 90       	mov	r0,r10
8000a3b0:	16 91       	mov	r1,r11
8000a3b2:	e0 a0 0f c7 	rcall	8000c340 <__avr32_f64_to_s32>
8000a3b6:	30 08       	mov	r8,0
8000a3b8:	18 96       	mov	r6,r12
8000a3ba:	30 09       	mov	r9,0
8000a3bc:	00 9a       	mov	r10,r0
8000a3be:	02 9b       	mov	r11,r1
8000a3c0:	e0 a0 10 8e 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a3c4:	c0 c0       	breq	8000a3dc <_dtoa_r+0x1f4>
8000a3c6:	0c 9c       	mov	r12,r6
8000a3c8:	e0 a0 0f d3 	rcall	8000c36e <__avr32_s32_to_f64>
8000a3cc:	14 98       	mov	r8,r10
8000a3ce:	16 99       	mov	r9,r11
8000a3d0:	00 9a       	mov	r10,r0
8000a3d2:	02 9b       	mov	r11,r1
8000a3d4:	e0 a0 10 3d 	rcall	8000c44e <__avr32_f64_cmp_eq>
8000a3d8:	f7 b6 00 01 	subeq	r6,1
8000a3dc:	59 66       	cp.w	r6,22
8000a3de:	e0 88 00 05 	brls	8000a3e8 <_dtoa_r+0x200>
8000a3e2:	30 18       	mov	r8,1
8000a3e4:	51 48       	stdsp	sp[0x50],r8
8000a3e6:	c1 38       	rjmp	8000a40c <_dtoa_r+0x224>
8000a3e8:	fe c8 c2 34 	sub	r8,pc,-15820
8000a3ec:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a3f0:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a3f4:	e0 a0 10 74 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a3f8:	f9 b4 00 00 	moveq	r4,0
8000a3fc:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a400:	f7 b6 01 01 	subne	r6,1
8000a404:	f9 bc 01 00 	movne	r12,0
8000a408:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a40c:	41 90       	lddsp	r0,sp[0x64]
8000a40e:	20 10       	sub	r0,1
8000a410:	0a 10       	sub	r0,r5
8000a412:	c0 46       	brmi	8000a41a <_dtoa_r+0x232>
8000a414:	50 40       	stdsp	sp[0x10],r0
8000a416:	30 00       	mov	r0,0
8000a418:	c0 48       	rjmp	8000a420 <_dtoa_r+0x238>
8000a41a:	30 0b       	mov	r11,0
8000a41c:	5c 30       	neg	r0
8000a41e:	50 4b       	stdsp	sp[0x10],r11
8000a420:	ec 02 11 00 	rsub	r2,r6,0
8000a424:	58 06       	cp.w	r6,0
8000a426:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a42a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a42e:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a432:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a436:	f9 b2 04 00 	movge	r2,0
8000a43a:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a43e:	f9 b9 05 00 	movlt	r9,0
8000a442:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a446:	40 c8       	lddsp	r8,sp[0x30]
8000a448:	58 98       	cp.w	r8,9
8000a44a:	e0 8b 00 20 	brhi	8000a48a <_dtoa_r+0x2a2>
8000a44e:	58 58       	cp.w	r8,5
8000a450:	f9 b4 0a 01 	movle	r4,1
8000a454:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a458:	f7 b5 09 04 	subgt	r5,4
8000a45c:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a460:	f9 b4 09 00 	movgt	r4,0
8000a464:	40 cc       	lddsp	r12,sp[0x30]
8000a466:	58 3c       	cp.w	r12,3
8000a468:	c2 d0       	breq	8000a4c2 <_dtoa_r+0x2da>
8000a46a:	e0 89 00 05 	brgt	8000a474 <_dtoa_r+0x28c>
8000a46e:	58 2c       	cp.w	r12,2
8000a470:	c1 01       	brne	8000a490 <_dtoa_r+0x2a8>
8000a472:	c1 88       	rjmp	8000a4a2 <_dtoa_r+0x2ba>
8000a474:	40 cb       	lddsp	r11,sp[0x30]
8000a476:	58 4b       	cp.w	r11,4
8000a478:	c0 60       	breq	8000a484 <_dtoa_r+0x29c>
8000a47a:	58 5b       	cp.w	r11,5
8000a47c:	c0 a1       	brne	8000a490 <_dtoa_r+0x2a8>
8000a47e:	30 1a       	mov	r10,1
8000a480:	50 da       	stdsp	sp[0x34],r10
8000a482:	c2 28       	rjmp	8000a4c6 <_dtoa_r+0x2de>
8000a484:	30 19       	mov	r9,1
8000a486:	50 d9       	stdsp	sp[0x34],r9
8000a488:	c0 f8       	rjmp	8000a4a6 <_dtoa_r+0x2be>
8000a48a:	30 08       	mov	r8,0
8000a48c:	30 14       	mov	r4,1
8000a48e:	50 c8       	stdsp	sp[0x30],r8
8000a490:	3f f5       	mov	r5,-1
8000a492:	30 1c       	mov	r12,1
8000a494:	30 0b       	mov	r11,0
8000a496:	50 95       	stdsp	sp[0x24],r5
8000a498:	50 dc       	stdsp	sp[0x34],r12
8000a49a:	0a 91       	mov	r1,r5
8000a49c:	31 28       	mov	r8,18
8000a49e:	50 eb       	stdsp	sp[0x38],r11
8000a4a0:	c2 08       	rjmp	8000a4e0 <_dtoa_r+0x2f8>
8000a4a2:	30 0a       	mov	r10,0
8000a4a4:	50 da       	stdsp	sp[0x34],r10
8000a4a6:	40 e9       	lddsp	r9,sp[0x38]
8000a4a8:	58 09       	cp.w	r9,0
8000a4aa:	e0 89 00 07 	brgt	8000a4b8 <_dtoa_r+0x2d0>
8000a4ae:	30 18       	mov	r8,1
8000a4b0:	50 98       	stdsp	sp[0x24],r8
8000a4b2:	10 91       	mov	r1,r8
8000a4b4:	50 e8       	stdsp	sp[0x38],r8
8000a4b6:	c1 58       	rjmp	8000a4e0 <_dtoa_r+0x2f8>
8000a4b8:	40 e5       	lddsp	r5,sp[0x38]
8000a4ba:	50 95       	stdsp	sp[0x24],r5
8000a4bc:	0a 91       	mov	r1,r5
8000a4be:	0a 98       	mov	r8,r5
8000a4c0:	c1 08       	rjmp	8000a4e0 <_dtoa_r+0x2f8>
8000a4c2:	30 0c       	mov	r12,0
8000a4c4:	50 dc       	stdsp	sp[0x34],r12
8000a4c6:	40 eb       	lddsp	r11,sp[0x38]
8000a4c8:	ec 0b 00 0b 	add	r11,r6,r11
8000a4cc:	50 9b       	stdsp	sp[0x24],r11
8000a4ce:	16 98       	mov	r8,r11
8000a4d0:	2f f8       	sub	r8,-1
8000a4d2:	58 08       	cp.w	r8,0
8000a4d4:	e0 89 00 05 	brgt	8000a4de <_dtoa_r+0x2f6>
8000a4d8:	10 91       	mov	r1,r8
8000a4da:	30 18       	mov	r8,1
8000a4dc:	c0 28       	rjmp	8000a4e0 <_dtoa_r+0x2f8>
8000a4de:	10 91       	mov	r1,r8
8000a4e0:	30 09       	mov	r9,0
8000a4e2:	6e 9a       	ld.w	r10,r7[0x24]
8000a4e4:	95 19       	st.w	r10[0x4],r9
8000a4e6:	30 49       	mov	r9,4
8000a4e8:	c0 68       	rjmp	8000a4f4 <_dtoa_r+0x30c>
8000a4ea:	d7 03       	nop
8000a4ec:	6a 1a       	ld.w	r10,r5[0x4]
8000a4ee:	a1 79       	lsl	r9,0x1
8000a4f0:	2f fa       	sub	r10,-1
8000a4f2:	8b 1a       	st.w	r5[0x4],r10
8000a4f4:	6e 95       	ld.w	r5,r7[0x24]
8000a4f6:	f2 ca ff ec 	sub	r10,r9,-20
8000a4fa:	10 3a       	cp.w	r10,r8
8000a4fc:	fe 98 ff f8 	brls	8000a4ec <_dtoa_r+0x304>
8000a500:	6a 1b       	ld.w	r11,r5[0x4]
8000a502:	0e 9c       	mov	r12,r7
8000a504:	e0 a0 09 44 	rcall	8000b78c <_Balloc>
8000a508:	58 e1       	cp.w	r1,14
8000a50a:	5f 88       	srls	r8
8000a50c:	8b 0c       	st.w	r5[0x0],r12
8000a50e:	f1 e4 00 04 	and	r4,r8,r4
8000a512:	6e 98       	ld.w	r8,r7[0x24]
8000a514:	70 08       	ld.w	r8,r8[0x0]
8000a516:	50 88       	stdsp	sp[0x20],r8
8000a518:	e0 80 01 82 	breq	8000a81c <_dtoa_r+0x634>
8000a51c:	58 06       	cp.w	r6,0
8000a51e:	e0 8a 00 43 	brle	8000a5a4 <_dtoa_r+0x3bc>
8000a522:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a526:	fe c8 c3 72 	sub	r8,pc,-15502
8000a52a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a52e:	fa e5 00 18 	st.d	sp[24],r4
8000a532:	ec 04 14 04 	asr	r4,r6,0x4
8000a536:	ed b4 00 04 	bld	r4,0x4
8000a53a:	c0 30       	breq	8000a540 <_dtoa_r+0x358>
8000a53c:	30 25       	mov	r5,2
8000a53e:	c1 08       	rjmp	8000a55e <_dtoa_r+0x376>
8000a540:	fe c8 c2 c4 	sub	r8,pc,-15676
8000a544:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a548:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a54c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a550:	e0 a0 0f fa 	rcall	8000c544 <__avr32_f64_div>
8000a554:	30 35       	mov	r5,3
8000a556:	14 98       	mov	r8,r10
8000a558:	16 99       	mov	r9,r11
8000a55a:	fa e9 00 08 	st.d	sp[8],r8
8000a55e:	fe cc c2 e2 	sub	r12,pc,-15646
8000a562:	50 a3       	stdsp	sp[0x28],r3
8000a564:	0c 93       	mov	r3,r6
8000a566:	18 96       	mov	r6,r12
8000a568:	c0 f8       	rjmp	8000a586 <_dtoa_r+0x39e>
8000a56a:	fa ea 00 18 	ld.d	r10,sp[24]
8000a56e:	ed b4 00 00 	bld	r4,0x0
8000a572:	c0 81       	brne	8000a582 <_dtoa_r+0x39a>
8000a574:	ec e8 00 00 	ld.d	r8,r6[0]
8000a578:	2f f5       	sub	r5,-1
8000a57a:	e0 a0 0c 9f 	rcall	8000beb8 <__avr32_f64_mul>
8000a57e:	fa eb 00 18 	st.d	sp[24],r10
8000a582:	a1 54       	asr	r4,0x1
8000a584:	2f 86       	sub	r6,-8
8000a586:	58 04       	cp.w	r4,0
8000a588:	cf 11       	brne	8000a56a <_dtoa_r+0x382>
8000a58a:	fa e8 00 18 	ld.d	r8,sp[24]
8000a58e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a592:	06 96       	mov	r6,r3
8000a594:	e0 a0 0f d8 	rcall	8000c544 <__avr32_f64_div>
8000a598:	40 a3       	lddsp	r3,sp[0x28]
8000a59a:	14 98       	mov	r8,r10
8000a59c:	16 99       	mov	r9,r11
8000a59e:	fa e9 00 08 	st.d	sp[8],r8
8000a5a2:	c2 f8       	rjmp	8000a600 <_dtoa_r+0x418>
8000a5a4:	ec 08 11 00 	rsub	r8,r6,0
8000a5a8:	c0 31       	brne	8000a5ae <_dtoa_r+0x3c6>
8000a5aa:	30 25       	mov	r5,2
8000a5ac:	c2 a8       	rjmp	8000a600 <_dtoa_r+0x418>
8000a5ae:	fe cc c3 32 	sub	r12,pc,-15566
8000a5b2:	f0 04 14 04 	asr	r4,r8,0x4
8000a5b6:	50 1c       	stdsp	sp[0x4],r12
8000a5b8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a5bc:	fe c9 c4 08 	sub	r9,pc,-15352
8000a5c0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5c4:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a5c8:	e0 a0 0c 78 	rcall	8000beb8 <__avr32_f64_mul>
8000a5cc:	40 1c       	lddsp	r12,sp[0x4]
8000a5ce:	50 63       	stdsp	sp[0x18],r3
8000a5d0:	30 25       	mov	r5,2
8000a5d2:	0c 93       	mov	r3,r6
8000a5d4:	fa eb 00 08 	st.d	sp[8],r10
8000a5d8:	18 96       	mov	r6,r12
8000a5da:	c0 f8       	rjmp	8000a5f8 <_dtoa_r+0x410>
8000a5dc:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5e0:	ed b4 00 00 	bld	r4,0x0
8000a5e4:	c0 81       	brne	8000a5f4 <_dtoa_r+0x40c>
8000a5e6:	ec e8 00 00 	ld.d	r8,r6[0]
8000a5ea:	2f f5       	sub	r5,-1
8000a5ec:	e0 a0 0c 66 	rcall	8000beb8 <__avr32_f64_mul>
8000a5f0:	fa eb 00 08 	st.d	sp[8],r10
8000a5f4:	a1 54       	asr	r4,0x1
8000a5f6:	2f 86       	sub	r6,-8
8000a5f8:	58 04       	cp.w	r4,0
8000a5fa:	cf 11       	brne	8000a5dc <_dtoa_r+0x3f4>
8000a5fc:	06 96       	mov	r6,r3
8000a5fe:	40 63       	lddsp	r3,sp[0x18]
8000a600:	41 4a       	lddsp	r10,sp[0x50]
8000a602:	58 0a       	cp.w	r10,0
8000a604:	c2 a0       	breq	8000a658 <_dtoa_r+0x470>
8000a606:	fa e8 00 08 	ld.d	r8,sp[8]
8000a60a:	58 01       	cp.w	r1,0
8000a60c:	5f 94       	srgt	r4
8000a60e:	fa e9 00 18 	st.d	sp[24],r8
8000a612:	30 08       	mov	r8,0
8000a614:	fc 19 3f f0 	movh	r9,0x3ff0
8000a618:	fa ea 00 18 	ld.d	r10,sp[24]
8000a61c:	e0 a0 0f 60 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a620:	f9 bc 00 00 	moveq	r12,0
8000a624:	f9 bc 01 01 	movne	r12,1
8000a628:	e9 ec 00 0c 	and	r12,r4,r12
8000a62c:	c1 60       	breq	8000a658 <_dtoa_r+0x470>
8000a62e:	40 98       	lddsp	r8,sp[0x24]
8000a630:	58 08       	cp.w	r8,0
8000a632:	e0 8a 00 f1 	brle	8000a814 <_dtoa_r+0x62c>
8000a636:	30 08       	mov	r8,0
8000a638:	fc 19 40 24 	movh	r9,0x4024
8000a63c:	ec c4 00 01 	sub	r4,r6,1
8000a640:	fa ea 00 18 	ld.d	r10,sp[24]
8000a644:	2f f5       	sub	r5,-1
8000a646:	50 64       	stdsp	sp[0x18],r4
8000a648:	e0 a0 0c 38 	rcall	8000beb8 <__avr32_f64_mul>
8000a64c:	40 94       	lddsp	r4,sp[0x24]
8000a64e:	14 98       	mov	r8,r10
8000a650:	16 99       	mov	r9,r11
8000a652:	fa e9 00 08 	st.d	sp[8],r8
8000a656:	c0 38       	rjmp	8000a65c <_dtoa_r+0x474>
8000a658:	50 66       	stdsp	sp[0x18],r6
8000a65a:	02 94       	mov	r4,r1
8000a65c:	0a 9c       	mov	r12,r5
8000a65e:	e0 a0 0e 88 	rcall	8000c36e <__avr32_s32_to_f64>
8000a662:	fa e8 00 08 	ld.d	r8,sp[8]
8000a666:	e0 a0 0c 29 	rcall	8000beb8 <__avr32_f64_mul>
8000a66a:	30 08       	mov	r8,0
8000a66c:	fc 19 40 1c 	movh	r9,0x401c
8000a670:	e0 a0 0d de 	rcall	8000c22c <__avr32_f64_add>
8000a674:	14 98       	mov	r8,r10
8000a676:	16 99       	mov	r9,r11
8000a678:	fa e9 00 28 	st.d	sp[40],r8
8000a67c:	fc 18 fc c0 	movh	r8,0xfcc0
8000a680:	40 a5       	lddsp	r5,sp[0x28]
8000a682:	10 05       	add	r5,r8
8000a684:	50 a5       	stdsp	sp[0x28],r5
8000a686:	58 04       	cp.w	r4,0
8000a688:	c2 11       	brne	8000a6ca <_dtoa_r+0x4e2>
8000a68a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a68e:	30 08       	mov	r8,0
8000a690:	fc 19 40 14 	movh	r9,0x4014
8000a694:	e0 a0 0c fe 	rcall	8000c090 <__avr32_f64_sub>
8000a698:	40 bc       	lddsp	r12,sp[0x2c]
8000a69a:	fa eb 00 08 	st.d	sp[8],r10
8000a69e:	14 98       	mov	r8,r10
8000a6a0:	16 99       	mov	r9,r11
8000a6a2:	18 9a       	mov	r10,r12
8000a6a4:	0a 9b       	mov	r11,r5
8000a6a6:	e0 a0 0f 1b 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a6aa:	e0 81 02 54 	brne	8000ab52 <_dtoa_r+0x96a>
8000a6ae:	0a 98       	mov	r8,r5
8000a6b0:	40 b9       	lddsp	r9,sp[0x2c]
8000a6b2:	ee 18 80 00 	eorh	r8,0x8000
8000a6b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6ba:	10 95       	mov	r5,r8
8000a6bc:	12 98       	mov	r8,r9
8000a6be:	0a 99       	mov	r9,r5
8000a6c0:	e0 a0 0f 0e 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a6c4:	e0 81 02 3e 	brne	8000ab40 <_dtoa_r+0x958>
8000a6c8:	ca 68       	rjmp	8000a814 <_dtoa_r+0x62c>
8000a6ca:	fe c9 c5 16 	sub	r9,pc,-15082
8000a6ce:	e8 c8 00 01 	sub	r8,r4,1
8000a6d2:	40 d5       	lddsp	r5,sp[0x34]
8000a6d4:	58 05       	cp.w	r5,0
8000a6d6:	c4 f0       	breq	8000a774 <_dtoa_r+0x58c>
8000a6d8:	30 0c       	mov	r12,0
8000a6da:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a6de:	51 3c       	stdsp	sp[0x4c],r12
8000a6e0:	30 0a       	mov	r10,0
8000a6e2:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a6e6:	e0 a0 0f 2f 	rcall	8000c544 <__avr32_f64_div>
8000a6ea:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6ee:	40 85       	lddsp	r5,sp[0x20]
8000a6f0:	e0 a0 0c d0 	rcall	8000c090 <__avr32_f64_sub>
8000a6f4:	fa eb 00 28 	st.d	sp[40],r10
8000a6f8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6fc:	e0 a0 0e 22 	rcall	8000c340 <__avr32_f64_to_s32>
8000a700:	51 6c       	stdsp	sp[0x58],r12
8000a702:	e0 a0 0e 36 	rcall	8000c36e <__avr32_s32_to_f64>
8000a706:	14 98       	mov	r8,r10
8000a708:	16 99       	mov	r9,r11
8000a70a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a70e:	e0 a0 0c c1 	rcall	8000c090 <__avr32_f64_sub>
8000a712:	fa eb 00 08 	st.d	sp[8],r10
8000a716:	41 68       	lddsp	r8,sp[0x58]
8000a718:	2d 08       	sub	r8,-48
8000a71a:	0a c8       	st.b	r5++,r8
8000a71c:	41 39       	lddsp	r9,sp[0x4c]
8000a71e:	2f f9       	sub	r9,-1
8000a720:	51 39       	stdsp	sp[0x4c],r9
8000a722:	fa e8 00 28 	ld.d	r8,sp[40]
8000a726:	e0 a0 0e db 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a72a:	e0 81 03 39 	brne	8000ad9c <_dtoa_r+0xbb4>
8000a72e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a732:	30 0a       	mov	r10,0
8000a734:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a738:	e0 a0 0c ac 	rcall	8000c090 <__avr32_f64_sub>
8000a73c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a740:	e0 a0 0e ce 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a744:	fa ea 00 28 	ld.d	r10,sp[40]
8000a748:	30 08       	mov	r8,0
8000a74a:	fc 19 40 24 	movh	r9,0x4024
8000a74e:	e0 81 00 da 	brne	8000a902 <_dtoa_r+0x71a>
8000a752:	41 3c       	lddsp	r12,sp[0x4c]
8000a754:	08 3c       	cp.w	r12,r4
8000a756:	c5 f4       	brge	8000a814 <_dtoa_r+0x62c>
8000a758:	e0 a0 0b b0 	rcall	8000beb8 <__avr32_f64_mul>
8000a75c:	30 08       	mov	r8,0
8000a75e:	fa eb 00 28 	st.d	sp[40],r10
8000a762:	fc 19 40 24 	movh	r9,0x4024
8000a766:	fa ea 00 08 	ld.d	r10,sp[8]
8000a76a:	e0 a0 0b a7 	rcall	8000beb8 <__avr32_f64_mul>
8000a76e:	fa eb 00 08 	st.d	sp[8],r10
8000a772:	cc 3b       	rjmp	8000a6f8 <_dtoa_r+0x510>
8000a774:	40 85       	lddsp	r5,sp[0x20]
8000a776:	08 05       	add	r5,r4
8000a778:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a77c:	51 35       	stdsp	sp[0x4c],r5
8000a77e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a782:	40 85       	lddsp	r5,sp[0x20]
8000a784:	e0 a0 0b 9a 	rcall	8000beb8 <__avr32_f64_mul>
8000a788:	fa eb 00 28 	st.d	sp[40],r10
8000a78c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a790:	e0 a0 0d d8 	rcall	8000c340 <__avr32_f64_to_s32>
8000a794:	51 6c       	stdsp	sp[0x58],r12
8000a796:	e0 a0 0d ec 	rcall	8000c36e <__avr32_s32_to_f64>
8000a79a:	14 98       	mov	r8,r10
8000a79c:	16 99       	mov	r9,r11
8000a79e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7a2:	e0 a0 0c 77 	rcall	8000c090 <__avr32_f64_sub>
8000a7a6:	fa eb 00 08 	st.d	sp[8],r10
8000a7aa:	41 68       	lddsp	r8,sp[0x58]
8000a7ac:	2d 08       	sub	r8,-48
8000a7ae:	0a c8       	st.b	r5++,r8
8000a7b0:	41 3c       	lddsp	r12,sp[0x4c]
8000a7b2:	18 35       	cp.w	r5,r12
8000a7b4:	c2 81       	brne	8000a804 <_dtoa_r+0x61c>
8000a7b6:	30 08       	mov	r8,0
8000a7b8:	fc 19 3f e0 	movh	r9,0x3fe0
8000a7bc:	fa ea 00 28 	ld.d	r10,sp[40]
8000a7c0:	e0 a0 0d 36 	rcall	8000c22c <__avr32_f64_add>
8000a7c4:	40 85       	lddsp	r5,sp[0x20]
8000a7c6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7ca:	08 05       	add	r5,r4
8000a7cc:	e0 a0 0e 88 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a7d0:	e0 81 00 99 	brne	8000a902 <_dtoa_r+0x71a>
8000a7d4:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7d8:	30 0a       	mov	r10,0
8000a7da:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a7de:	e0 a0 0c 59 	rcall	8000c090 <__avr32_f64_sub>
8000a7e2:	14 98       	mov	r8,r10
8000a7e4:	16 99       	mov	r9,r11
8000a7e6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7ea:	e0 a0 0e 79 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a7ee:	c1 30       	breq	8000a814 <_dtoa_r+0x62c>
8000a7f0:	33 09       	mov	r9,48
8000a7f2:	0a 98       	mov	r8,r5
8000a7f4:	11 7a       	ld.ub	r10,--r8
8000a7f6:	f2 0a 18 00 	cp.b	r10,r9
8000a7fa:	e0 81 02 d1 	brne	8000ad9c <_dtoa_r+0xbb4>
8000a7fe:	10 95       	mov	r5,r8
8000a800:	cf 9b       	rjmp	8000a7f2 <_dtoa_r+0x60a>
8000a802:	d7 03       	nop
8000a804:	30 08       	mov	r8,0
8000a806:	fc 19 40 24 	movh	r9,0x4024
8000a80a:	e0 a0 0b 57 	rcall	8000beb8 <__avr32_f64_mul>
8000a80e:	fa eb 00 08 	st.d	sp[8],r10
8000a812:	cb db       	rjmp	8000a78c <_dtoa_r+0x5a4>
8000a814:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a818:	fa eb 00 08 	st.d	sp[8],r10
8000a81c:	58 e6       	cp.w	r6,14
8000a81e:	5f ab       	srle	r11
8000a820:	41 8a       	lddsp	r10,sp[0x60]
8000a822:	30 08       	mov	r8,0
8000a824:	f4 09 11 ff 	rsub	r9,r10,-1
8000a828:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a82c:	f0 09 18 00 	cp.b	r9,r8
8000a830:	e0 80 00 82 	breq	8000a934 <_dtoa_r+0x74c>
8000a834:	40 ea       	lddsp	r10,sp[0x38]
8000a836:	58 01       	cp.w	r1,0
8000a838:	5f a9       	srle	r9
8000a83a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a83e:	fe ca c6 8a 	sub	r10,pc,-14710
8000a842:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a846:	fa e5 00 10 	st.d	sp[16],r4
8000a84a:	f0 09 18 00 	cp.b	r9,r8
8000a84e:	c1 40       	breq	8000a876 <_dtoa_r+0x68e>
8000a850:	58 01       	cp.w	r1,0
8000a852:	e0 81 01 77 	brne	8000ab40 <_dtoa_r+0x958>
8000a856:	30 08       	mov	r8,0
8000a858:	fc 19 40 14 	movh	r9,0x4014
8000a85c:	08 9a       	mov	r10,r4
8000a85e:	0a 9b       	mov	r11,r5
8000a860:	e0 a0 0b 2c 	rcall	8000beb8 <__avr32_f64_mul>
8000a864:	fa e8 00 08 	ld.d	r8,sp[8]
8000a868:	e0 a0 0e 06 	rcall	8000c474 <__avr32_f64_cmp_ge>
8000a86c:	e0 81 01 6a 	brne	8000ab40 <_dtoa_r+0x958>
8000a870:	02 92       	mov	r2,r1
8000a872:	e0 8f 01 72 	bral	8000ab56 <_dtoa_r+0x96e>
8000a876:	40 85       	lddsp	r5,sp[0x20]
8000a878:	30 14       	mov	r4,1
8000a87a:	fa e8 00 10 	ld.d	r8,sp[16]
8000a87e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a882:	e0 a0 0e 61 	rcall	8000c544 <__avr32_f64_div>
8000a886:	e0 a0 0d 5d 	rcall	8000c340 <__avr32_f64_to_s32>
8000a88a:	18 92       	mov	r2,r12
8000a88c:	e0 a0 0d 71 	rcall	8000c36e <__avr32_s32_to_f64>
8000a890:	fa e8 00 10 	ld.d	r8,sp[16]
8000a894:	e0 a0 0b 12 	rcall	8000beb8 <__avr32_f64_mul>
8000a898:	14 98       	mov	r8,r10
8000a89a:	16 99       	mov	r9,r11
8000a89c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8a0:	e0 a0 0b f8 	rcall	8000c090 <__avr32_f64_sub>
8000a8a4:	fa eb 00 08 	st.d	sp[8],r10
8000a8a8:	e4 c8 ff d0 	sub	r8,r2,-48
8000a8ac:	0a c8       	st.b	r5++,r8
8000a8ae:	fc 19 40 24 	movh	r9,0x4024
8000a8b2:	30 08       	mov	r8,0
8000a8b4:	02 34       	cp.w	r4,r1
8000a8b6:	c3 31       	brne	8000a91c <_dtoa_r+0x734>
8000a8b8:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8bc:	e0 a0 0c b8 	rcall	8000c22c <__avr32_f64_add>
8000a8c0:	16 91       	mov	r1,r11
8000a8c2:	14 90       	mov	r0,r10
8000a8c4:	14 98       	mov	r8,r10
8000a8c6:	02 99       	mov	r9,r1
8000a8c8:	fa ea 00 10 	ld.d	r10,sp[16]
8000a8cc:	e0 a0 0e 08 	rcall	8000c4dc <__avr32_f64_cmp_lt>
8000a8d0:	c1 a1       	brne	8000a904 <_dtoa_r+0x71c>
8000a8d2:	fa e8 00 10 	ld.d	r8,sp[16]
8000a8d6:	00 9a       	mov	r10,r0
8000a8d8:	02 9b       	mov	r11,r1
8000a8da:	e0 a0 0d ba 	rcall	8000c44e <__avr32_f64_cmp_eq>
8000a8de:	e0 80 02 5e 	breq	8000ad9a <_dtoa_r+0xbb2>
8000a8e2:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a8e6:	c0 f1       	brne	8000a904 <_dtoa_r+0x71c>
8000a8e8:	e0 8f 02 59 	bral	8000ad9a <_dtoa_r+0xbb2>
8000a8ec:	40 8a       	lddsp	r10,sp[0x20]
8000a8ee:	14 38       	cp.w	r8,r10
8000a8f0:	c0 30       	breq	8000a8f6 <_dtoa_r+0x70e>
8000a8f2:	10 95       	mov	r5,r8
8000a8f4:	c0 98       	rjmp	8000a906 <_dtoa_r+0x71e>
8000a8f6:	33 08       	mov	r8,48
8000a8f8:	40 89       	lddsp	r9,sp[0x20]
8000a8fa:	2f f6       	sub	r6,-1
8000a8fc:	b2 88       	st.b	r9[0x0],r8
8000a8fe:	40 88       	lddsp	r8,sp[0x20]
8000a900:	c0 88       	rjmp	8000a910 <_dtoa_r+0x728>
8000a902:	40 66       	lddsp	r6,sp[0x18]
8000a904:	33 99       	mov	r9,57
8000a906:	0a 98       	mov	r8,r5
8000a908:	11 7a       	ld.ub	r10,--r8
8000a90a:	f2 0a 18 00 	cp.b	r10,r9
8000a90e:	ce f0       	breq	8000a8ec <_dtoa_r+0x704>
8000a910:	50 66       	stdsp	sp[0x18],r6
8000a912:	11 89       	ld.ub	r9,r8[0x0]
8000a914:	2f f9       	sub	r9,-1
8000a916:	b0 89       	st.b	r8[0x0],r9
8000a918:	e0 8f 02 42 	bral	8000ad9c <_dtoa_r+0xbb4>
8000a91c:	e0 a0 0a ce 	rcall	8000beb8 <__avr32_f64_mul>
8000a920:	2f f4       	sub	r4,-1
8000a922:	fa eb 00 08 	st.d	sp[8],r10
8000a926:	30 08       	mov	r8,0
8000a928:	30 09       	mov	r9,0
8000a92a:	e0 a0 0d 92 	rcall	8000c44e <__avr32_f64_cmp_eq>
8000a92e:	ca 60       	breq	8000a87a <_dtoa_r+0x692>
8000a930:	e0 8f 02 35 	bral	8000ad9a <_dtoa_r+0xbb2>
8000a934:	40 d8       	lddsp	r8,sp[0x34]
8000a936:	58 08       	cp.w	r8,0
8000a938:	c0 51       	brne	8000a942 <_dtoa_r+0x75a>
8000a93a:	04 98       	mov	r8,r2
8000a93c:	00 95       	mov	r5,r0
8000a93e:	40 d4       	lddsp	r4,sp[0x34]
8000a940:	c3 78       	rjmp	8000a9ae <_dtoa_r+0x7c6>
8000a942:	40 c5       	lddsp	r5,sp[0x30]
8000a944:	58 15       	cp.w	r5,1
8000a946:	e0 89 00 0f 	brgt	8000a964 <_dtoa_r+0x77c>
8000a94a:	41 74       	lddsp	r4,sp[0x5c]
8000a94c:	58 04       	cp.w	r4,0
8000a94e:	c0 40       	breq	8000a956 <_dtoa_r+0x76e>
8000a950:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a954:	c0 48       	rjmp	8000a95c <_dtoa_r+0x774>
8000a956:	41 99       	lddsp	r9,sp[0x64]
8000a958:	f2 09 11 36 	rsub	r9,r9,54
8000a95c:	04 98       	mov	r8,r2
8000a95e:	00 95       	mov	r5,r0
8000a960:	c1 c8       	rjmp	8000a998 <_dtoa_r+0x7b0>
8000a962:	d7 03       	nop
8000a964:	e2 c8 00 01 	sub	r8,r1,1
8000a968:	58 01       	cp.w	r1,0
8000a96a:	e0 05 17 40 	movge	r5,r0
8000a96e:	e2 09 17 40 	movge	r9,r1
8000a972:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a976:	f9 b9 05 00 	movlt	r9,0
8000a97a:	10 32       	cp.w	r2,r8
8000a97c:	e5 d8 e4 18 	subge	r8,r2,r8
8000a980:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a984:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a988:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a98c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a990:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a994:	f9 b8 05 00 	movlt	r8,0
8000a998:	40 4b       	lddsp	r11,sp[0x10]
8000a99a:	12 0b       	add	r11,r9
8000a99c:	50 08       	stdsp	sp[0x0],r8
8000a99e:	50 4b       	stdsp	sp[0x10],r11
8000a9a0:	12 00       	add	r0,r9
8000a9a2:	30 1b       	mov	r11,1
8000a9a4:	0e 9c       	mov	r12,r7
8000a9a6:	e0 a0 08 a7 	rcall	8000baf4 <__i2b>
8000a9aa:	40 08       	lddsp	r8,sp[0x0]
8000a9ac:	18 94       	mov	r4,r12
8000a9ae:	40 4a       	lddsp	r10,sp[0x10]
8000a9b0:	58 05       	cp.w	r5,0
8000a9b2:	5f 99       	srgt	r9
8000a9b4:	58 0a       	cp.w	r10,0
8000a9b6:	5f 9a       	srgt	r10
8000a9b8:	f5 e9 00 09 	and	r9,r10,r9
8000a9bc:	c0 80       	breq	8000a9cc <_dtoa_r+0x7e4>
8000a9be:	40 4c       	lddsp	r12,sp[0x10]
8000a9c0:	f8 05 0d 49 	min	r9,r12,r5
8000a9c4:	12 1c       	sub	r12,r9
8000a9c6:	12 10       	sub	r0,r9
8000a9c8:	50 4c       	stdsp	sp[0x10],r12
8000a9ca:	12 15       	sub	r5,r9
8000a9cc:	58 02       	cp.w	r2,0
8000a9ce:	e0 8a 00 27 	brle	8000aa1c <_dtoa_r+0x834>
8000a9d2:	40 db       	lddsp	r11,sp[0x34]
8000a9d4:	58 0b       	cp.w	r11,0
8000a9d6:	c1 d0       	breq	8000aa10 <_dtoa_r+0x828>
8000a9d8:	58 08       	cp.w	r8,0
8000a9da:	e0 8a 00 17 	brle	8000aa08 <_dtoa_r+0x820>
8000a9de:	10 9a       	mov	r10,r8
8000a9e0:	50 08       	stdsp	sp[0x0],r8
8000a9e2:	08 9b       	mov	r11,r4
8000a9e4:	0e 9c       	mov	r12,r7
8000a9e6:	e0 a0 08 cd 	rcall	8000bb80 <__pow5mult>
8000a9ea:	06 9a       	mov	r10,r3
8000a9ec:	18 9b       	mov	r11,r12
8000a9ee:	18 94       	mov	r4,r12
8000a9f0:	0e 9c       	mov	r12,r7
8000a9f2:	e0 a0 08 01 	rcall	8000b9f4 <__multiply>
8000a9f6:	18 99       	mov	r9,r12
8000a9f8:	06 9b       	mov	r11,r3
8000a9fa:	50 19       	stdsp	sp[0x4],r9
8000a9fc:	0e 9c       	mov	r12,r7
8000a9fe:	e0 a0 06 ad 	rcall	8000b758 <_Bfree>
8000aa02:	40 19       	lddsp	r9,sp[0x4]
8000aa04:	40 08       	lddsp	r8,sp[0x0]
8000aa06:	12 93       	mov	r3,r9
8000aa08:	e4 08 01 0a 	sub	r10,r2,r8
8000aa0c:	c0 80       	breq	8000aa1c <_dtoa_r+0x834>
8000aa0e:	c0 28       	rjmp	8000aa12 <_dtoa_r+0x82a>
8000aa10:	04 9a       	mov	r10,r2
8000aa12:	06 9b       	mov	r11,r3
8000aa14:	0e 9c       	mov	r12,r7
8000aa16:	e0 a0 08 b5 	rcall	8000bb80 <__pow5mult>
8000aa1a:	18 93       	mov	r3,r12
8000aa1c:	30 1b       	mov	r11,1
8000aa1e:	0e 9c       	mov	r12,r7
8000aa20:	e0 a0 08 6a 	rcall	8000baf4 <__i2b>
8000aa24:	41 1a       	lddsp	r10,sp[0x44]
8000aa26:	18 92       	mov	r2,r12
8000aa28:	58 0a       	cp.w	r10,0
8000aa2a:	e0 8a 00 07 	brle	8000aa38 <_dtoa_r+0x850>
8000aa2e:	18 9b       	mov	r11,r12
8000aa30:	0e 9c       	mov	r12,r7
8000aa32:	e0 a0 08 a7 	rcall	8000bb80 <__pow5mult>
8000aa36:	18 92       	mov	r2,r12
8000aa38:	40 c9       	lddsp	r9,sp[0x30]
8000aa3a:	58 19       	cp.w	r9,1
8000aa3c:	e0 89 00 14 	brgt	8000aa64 <_dtoa_r+0x87c>
8000aa40:	40 38       	lddsp	r8,sp[0xc]
8000aa42:	58 08       	cp.w	r8,0
8000aa44:	c1 01       	brne	8000aa64 <_dtoa_r+0x87c>
8000aa46:	40 29       	lddsp	r9,sp[0x8]
8000aa48:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aa4c:	c0 c1       	brne	8000aa64 <_dtoa_r+0x87c>
8000aa4e:	12 98       	mov	r8,r9
8000aa50:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aa54:	c0 80       	breq	8000aa64 <_dtoa_r+0x87c>
8000aa56:	40 4c       	lddsp	r12,sp[0x10]
8000aa58:	30 1b       	mov	r11,1
8000aa5a:	2f fc       	sub	r12,-1
8000aa5c:	2f f0       	sub	r0,-1
8000aa5e:	50 4c       	stdsp	sp[0x10],r12
8000aa60:	50 6b       	stdsp	sp[0x18],r11
8000aa62:	c0 38       	rjmp	8000aa68 <_dtoa_r+0x880>
8000aa64:	30 0a       	mov	r10,0
8000aa66:	50 6a       	stdsp	sp[0x18],r10
8000aa68:	41 19       	lddsp	r9,sp[0x44]
8000aa6a:	58 09       	cp.w	r9,0
8000aa6c:	c0 31       	brne	8000aa72 <_dtoa_r+0x88a>
8000aa6e:	30 1c       	mov	r12,1
8000aa70:	c0 98       	rjmp	8000aa82 <_dtoa_r+0x89a>
8000aa72:	64 48       	ld.w	r8,r2[0x10]
8000aa74:	2f c8       	sub	r8,-4
8000aa76:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aa7a:	e0 a0 05 df 	rcall	8000b638 <__hi0bits>
8000aa7e:	f8 0c 11 20 	rsub	r12,r12,32
8000aa82:	40 4b       	lddsp	r11,sp[0x10]
8000aa84:	f8 0b 00 08 	add	r8,r12,r11
8000aa88:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa8c:	c0 c0       	breq	8000aaa4 <_dtoa_r+0x8bc>
8000aa8e:	f0 08 11 20 	rsub	r8,r8,32
8000aa92:	58 48       	cp.w	r8,4
8000aa94:	e0 8a 00 06 	brle	8000aaa0 <_dtoa_r+0x8b8>
8000aa98:	20 48       	sub	r8,4
8000aa9a:	10 0b       	add	r11,r8
8000aa9c:	50 4b       	stdsp	sp[0x10],r11
8000aa9e:	c0 78       	rjmp	8000aaac <_dtoa_r+0x8c4>
8000aaa0:	58 48       	cp.w	r8,4
8000aaa2:	c0 70       	breq	8000aab0 <_dtoa_r+0x8c8>
8000aaa4:	40 4a       	lddsp	r10,sp[0x10]
8000aaa6:	2e 48       	sub	r8,-28
8000aaa8:	10 0a       	add	r10,r8
8000aaaa:	50 4a       	stdsp	sp[0x10],r10
8000aaac:	10 00       	add	r0,r8
8000aaae:	10 05       	add	r5,r8
8000aab0:	58 00       	cp.w	r0,0
8000aab2:	e0 8a 00 08 	brle	8000aac2 <_dtoa_r+0x8da>
8000aab6:	06 9b       	mov	r11,r3
8000aab8:	00 9a       	mov	r10,r0
8000aaba:	0e 9c       	mov	r12,r7
8000aabc:	e0 a0 07 58 	rcall	8000b96c <__lshift>
8000aac0:	18 93       	mov	r3,r12
8000aac2:	40 49       	lddsp	r9,sp[0x10]
8000aac4:	58 09       	cp.w	r9,0
8000aac6:	e0 8a 00 08 	brle	8000aad6 <_dtoa_r+0x8ee>
8000aaca:	04 9b       	mov	r11,r2
8000aacc:	12 9a       	mov	r10,r9
8000aace:	0e 9c       	mov	r12,r7
8000aad0:	e0 a0 07 4e 	rcall	8000b96c <__lshift>
8000aad4:	18 92       	mov	r2,r12
8000aad6:	41 48       	lddsp	r8,sp[0x50]
8000aad8:	58 08       	cp.w	r8,0
8000aada:	c1 b0       	breq	8000ab10 <_dtoa_r+0x928>
8000aadc:	04 9b       	mov	r11,r2
8000aade:	06 9c       	mov	r12,r3
8000aae0:	e0 a0 06 23 	rcall	8000b726 <__mcmp>
8000aae4:	c1 64       	brge	8000ab10 <_dtoa_r+0x928>
8000aae6:	06 9b       	mov	r11,r3
8000aae8:	30 09       	mov	r9,0
8000aaea:	30 aa       	mov	r10,10
8000aaec:	0e 9c       	mov	r12,r7
8000aaee:	e0 a0 08 0b 	rcall	8000bb04 <__multadd>
8000aaf2:	20 16       	sub	r6,1
8000aaf4:	18 93       	mov	r3,r12
8000aaf6:	40 dc       	lddsp	r12,sp[0x34]
8000aaf8:	58 0c       	cp.w	r12,0
8000aafa:	c0 31       	brne	8000ab00 <_dtoa_r+0x918>
8000aafc:	40 91       	lddsp	r1,sp[0x24]
8000aafe:	c0 98       	rjmp	8000ab10 <_dtoa_r+0x928>
8000ab00:	08 9b       	mov	r11,r4
8000ab02:	40 91       	lddsp	r1,sp[0x24]
8000ab04:	30 09       	mov	r9,0
8000ab06:	30 aa       	mov	r10,10
8000ab08:	0e 9c       	mov	r12,r7
8000ab0a:	e0 a0 07 fd 	rcall	8000bb04 <__multadd>
8000ab0e:	18 94       	mov	r4,r12
8000ab10:	58 01       	cp.w	r1,0
8000ab12:	5f a9       	srle	r9
8000ab14:	40 cb       	lddsp	r11,sp[0x30]
8000ab16:	58 2b       	cp.w	r11,2
8000ab18:	5f 98       	srgt	r8
8000ab1a:	f3 e8 00 08 	and	r8,r9,r8
8000ab1e:	c2 50       	breq	8000ab68 <_dtoa_r+0x980>
8000ab20:	58 01       	cp.w	r1,0
8000ab22:	c1 11       	brne	8000ab44 <_dtoa_r+0x95c>
8000ab24:	04 9b       	mov	r11,r2
8000ab26:	02 99       	mov	r9,r1
8000ab28:	30 5a       	mov	r10,5
8000ab2a:	0e 9c       	mov	r12,r7
8000ab2c:	e0 a0 07 ec 	rcall	8000bb04 <__multadd>
8000ab30:	18 92       	mov	r2,r12
8000ab32:	18 9b       	mov	r11,r12
8000ab34:	06 9c       	mov	r12,r3
8000ab36:	e0 a0 05 f8 	rcall	8000b726 <__mcmp>
8000ab3a:	e0 89 00 0f 	brgt	8000ab58 <_dtoa_r+0x970>
8000ab3e:	c0 38       	rjmp	8000ab44 <_dtoa_r+0x95c>
8000ab40:	30 02       	mov	r2,0
8000ab42:	04 94       	mov	r4,r2
8000ab44:	40 ea       	lddsp	r10,sp[0x38]
8000ab46:	30 09       	mov	r9,0
8000ab48:	5c da       	com	r10
8000ab4a:	40 85       	lddsp	r5,sp[0x20]
8000ab4c:	50 6a       	stdsp	sp[0x18],r10
8000ab4e:	50 49       	stdsp	sp[0x10],r9
8000ab50:	c0 f9       	rjmp	8000ad6e <_dtoa_r+0xb86>
8000ab52:	08 92       	mov	r2,r4
8000ab54:	40 66       	lddsp	r6,sp[0x18]
8000ab56:	04 94       	mov	r4,r2
8000ab58:	2f f6       	sub	r6,-1
8000ab5a:	50 66       	stdsp	sp[0x18],r6
8000ab5c:	33 18       	mov	r8,49
8000ab5e:	40 85       	lddsp	r5,sp[0x20]
8000ab60:	0a c8       	st.b	r5++,r8
8000ab62:	30 08       	mov	r8,0
8000ab64:	50 48       	stdsp	sp[0x10],r8
8000ab66:	c0 49       	rjmp	8000ad6e <_dtoa_r+0xb86>
8000ab68:	40 dc       	lddsp	r12,sp[0x34]
8000ab6a:	58 0c       	cp.w	r12,0
8000ab6c:	e0 80 00 b5 	breq	8000acd6 <_dtoa_r+0xaee>
8000ab70:	58 05       	cp.w	r5,0
8000ab72:	e0 8a 00 08 	brle	8000ab82 <_dtoa_r+0x99a>
8000ab76:	08 9b       	mov	r11,r4
8000ab78:	0a 9a       	mov	r10,r5
8000ab7a:	0e 9c       	mov	r12,r7
8000ab7c:	e0 a0 06 f8 	rcall	8000b96c <__lshift>
8000ab80:	18 94       	mov	r4,r12
8000ab82:	40 6b       	lddsp	r11,sp[0x18]
8000ab84:	58 0b       	cp.w	r11,0
8000ab86:	c0 31       	brne	8000ab8c <_dtoa_r+0x9a4>
8000ab88:	08 9c       	mov	r12,r4
8000ab8a:	c1 38       	rjmp	8000abb0 <_dtoa_r+0x9c8>
8000ab8c:	68 1b       	ld.w	r11,r4[0x4]
8000ab8e:	0e 9c       	mov	r12,r7
8000ab90:	e0 a0 05 fe 	rcall	8000b78c <_Balloc>
8000ab94:	68 4a       	ld.w	r10,r4[0x10]
8000ab96:	18 95       	mov	r5,r12
8000ab98:	e8 cb ff f4 	sub	r11,r4,-12
8000ab9c:	2f ea       	sub	r10,-2
8000ab9e:	2f 4c       	sub	r12,-12
8000aba0:	a3 6a       	lsl	r10,0x2
8000aba2:	fe b0 e6 4f 	rcall	80007840 <memcpy>
8000aba6:	0a 9b       	mov	r11,r5
8000aba8:	30 1a       	mov	r10,1
8000abaa:	0e 9c       	mov	r12,r7
8000abac:	e0 a0 06 e0 	rcall	8000b96c <__lshift>
8000abb0:	50 44       	stdsp	sp[0x10],r4
8000abb2:	40 3a       	lddsp	r10,sp[0xc]
8000abb4:	30 19       	mov	r9,1
8000abb6:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000abba:	18 94       	mov	r4,r12
8000abbc:	50 da       	stdsp	sp[0x34],r10
8000abbe:	40 85       	lddsp	r5,sp[0x20]
8000abc0:	50 99       	stdsp	sp[0x24],r9
8000abc2:	50 26       	stdsp	sp[0x8],r6
8000abc4:	50 e1       	stdsp	sp[0x38],r1
8000abc6:	04 9b       	mov	r11,r2
8000abc8:	06 9c       	mov	r12,r3
8000abca:	fe b0 fa 7f 	rcall	8000a0c8 <quorem>
8000abce:	40 4b       	lddsp	r11,sp[0x10]
8000abd0:	f8 c0 ff d0 	sub	r0,r12,-48
8000abd4:	06 9c       	mov	r12,r3
8000abd6:	e0 a0 05 a8 	rcall	8000b726 <__mcmp>
8000abda:	08 9a       	mov	r10,r4
8000abdc:	50 6c       	stdsp	sp[0x18],r12
8000abde:	04 9b       	mov	r11,r2
8000abe0:	0e 9c       	mov	r12,r7
8000abe2:	e0 a0 06 5d 	rcall	8000b89c <__mdiff>
8000abe6:	18 91       	mov	r1,r12
8000abe8:	78 38       	ld.w	r8,r12[0xc]
8000abea:	58 08       	cp.w	r8,0
8000abec:	c0 30       	breq	8000abf2 <_dtoa_r+0xa0a>
8000abee:	30 16       	mov	r6,1
8000abf0:	c0 68       	rjmp	8000abfc <_dtoa_r+0xa14>
8000abf2:	18 9b       	mov	r11,r12
8000abf4:	06 9c       	mov	r12,r3
8000abf6:	e0 a0 05 98 	rcall	8000b726 <__mcmp>
8000abfa:	18 96       	mov	r6,r12
8000abfc:	0e 9c       	mov	r12,r7
8000abfe:	02 9b       	mov	r11,r1
8000ac00:	e0 a0 05 ac 	rcall	8000b758 <_Bfree>
8000ac04:	40 cc       	lddsp	r12,sp[0x30]
8000ac06:	ed ec 10 08 	or	r8,r6,r12
8000ac0a:	c0 d1       	brne	8000ac24 <_dtoa_r+0xa3c>
8000ac0c:	40 db       	lddsp	r11,sp[0x34]
8000ac0e:	58 0b       	cp.w	r11,0
8000ac10:	c0 a1       	brne	8000ac24 <_dtoa_r+0xa3c>
8000ac12:	40 26       	lddsp	r6,sp[0x8]
8000ac14:	e0 40 00 39 	cp.w	r0,57
8000ac18:	c3 00       	breq	8000ac78 <_dtoa_r+0xa90>
8000ac1a:	40 6a       	lddsp	r10,sp[0x18]
8000ac1c:	58 0a       	cp.w	r10,0
8000ac1e:	e0 89 00 24 	brgt	8000ac66 <_dtoa_r+0xa7e>
8000ac22:	c2 f8       	rjmp	8000ac80 <_dtoa_r+0xa98>
8000ac24:	40 69       	lddsp	r9,sp[0x18]
8000ac26:	58 09       	cp.w	r9,0
8000ac28:	c0 85       	brlt	8000ac38 <_dtoa_r+0xa50>
8000ac2a:	12 98       	mov	r8,r9
8000ac2c:	40 cc       	lddsp	r12,sp[0x30]
8000ac2e:	18 48       	or	r8,r12
8000ac30:	c1 d1       	brne	8000ac6a <_dtoa_r+0xa82>
8000ac32:	40 db       	lddsp	r11,sp[0x34]
8000ac34:	58 0b       	cp.w	r11,0
8000ac36:	c1 a1       	brne	8000ac6a <_dtoa_r+0xa82>
8000ac38:	0c 99       	mov	r9,r6
8000ac3a:	40 26       	lddsp	r6,sp[0x8]
8000ac3c:	58 09       	cp.w	r9,0
8000ac3e:	e0 8a 00 21 	brle	8000ac80 <_dtoa_r+0xa98>
8000ac42:	06 9b       	mov	r11,r3
8000ac44:	30 1a       	mov	r10,1
8000ac46:	0e 9c       	mov	r12,r7
8000ac48:	e0 a0 06 92 	rcall	8000b96c <__lshift>
8000ac4c:	04 9b       	mov	r11,r2
8000ac4e:	18 93       	mov	r3,r12
8000ac50:	e0 a0 05 6b 	rcall	8000b726 <__mcmp>
8000ac54:	e0 89 00 06 	brgt	8000ac60 <_dtoa_r+0xa78>
8000ac58:	c1 41       	brne	8000ac80 <_dtoa_r+0xa98>
8000ac5a:	ed b0 00 00 	bld	r0,0x0
8000ac5e:	c1 11       	brne	8000ac80 <_dtoa_r+0xa98>
8000ac60:	e0 40 00 39 	cp.w	r0,57
8000ac64:	c0 a0       	breq	8000ac78 <_dtoa_r+0xa90>
8000ac66:	2f f0       	sub	r0,-1
8000ac68:	c0 c8       	rjmp	8000ac80 <_dtoa_r+0xa98>
8000ac6a:	58 06       	cp.w	r6,0
8000ac6c:	e0 8a 00 0c 	brle	8000ac84 <_dtoa_r+0xa9c>
8000ac70:	40 26       	lddsp	r6,sp[0x8]
8000ac72:	e0 40 00 39 	cp.w	r0,57
8000ac76:	c0 41       	brne	8000ac7e <_dtoa_r+0xa96>
8000ac78:	33 98       	mov	r8,57
8000ac7a:	0a c8       	st.b	r5++,r8
8000ac7c:	c6 78       	rjmp	8000ad4a <_dtoa_r+0xb62>
8000ac7e:	2f f0       	sub	r0,-1
8000ac80:	0a c0       	st.b	r5++,r0
8000ac82:	c7 58       	rjmp	8000ad6c <_dtoa_r+0xb84>
8000ac84:	0a c0       	st.b	r5++,r0
8000ac86:	40 9a       	lddsp	r10,sp[0x24]
8000ac88:	40 e9       	lddsp	r9,sp[0x38]
8000ac8a:	12 3a       	cp.w	r10,r9
8000ac8c:	c4 30       	breq	8000ad12 <_dtoa_r+0xb2a>
8000ac8e:	06 9b       	mov	r11,r3
8000ac90:	30 09       	mov	r9,0
8000ac92:	30 aa       	mov	r10,10
8000ac94:	0e 9c       	mov	r12,r7
8000ac96:	e0 a0 07 37 	rcall	8000bb04 <__multadd>
8000ac9a:	40 48       	lddsp	r8,sp[0x10]
8000ac9c:	18 93       	mov	r3,r12
8000ac9e:	08 38       	cp.w	r8,r4
8000aca0:	c0 91       	brne	8000acb2 <_dtoa_r+0xaca>
8000aca2:	10 9b       	mov	r11,r8
8000aca4:	30 09       	mov	r9,0
8000aca6:	30 aa       	mov	r10,10
8000aca8:	0e 9c       	mov	r12,r7
8000acaa:	e0 a0 07 2d 	rcall	8000bb04 <__multadd>
8000acae:	50 4c       	stdsp	sp[0x10],r12
8000acb0:	c0 e8       	rjmp	8000accc <_dtoa_r+0xae4>
8000acb2:	40 4b       	lddsp	r11,sp[0x10]
8000acb4:	30 09       	mov	r9,0
8000acb6:	30 aa       	mov	r10,10
8000acb8:	0e 9c       	mov	r12,r7
8000acba:	e0 a0 07 25 	rcall	8000bb04 <__multadd>
8000acbe:	08 9b       	mov	r11,r4
8000acc0:	50 4c       	stdsp	sp[0x10],r12
8000acc2:	30 09       	mov	r9,0
8000acc4:	30 aa       	mov	r10,10
8000acc6:	0e 9c       	mov	r12,r7
8000acc8:	e0 a0 07 1e 	rcall	8000bb04 <__multadd>
8000accc:	18 94       	mov	r4,r12
8000acce:	40 9c       	lddsp	r12,sp[0x24]
8000acd0:	2f fc       	sub	r12,-1
8000acd2:	50 9c       	stdsp	sp[0x24],r12
8000acd4:	c7 9b       	rjmp	8000abc6 <_dtoa_r+0x9de>
8000acd6:	30 18       	mov	r8,1
8000acd8:	06 90       	mov	r0,r3
8000acda:	40 85       	lddsp	r5,sp[0x20]
8000acdc:	08 93       	mov	r3,r4
8000acde:	0c 94       	mov	r4,r6
8000ace0:	10 96       	mov	r6,r8
8000ace2:	04 9b       	mov	r11,r2
8000ace4:	00 9c       	mov	r12,r0
8000ace6:	fe b0 f9 f1 	rcall	8000a0c8 <quorem>
8000acea:	2d 0c       	sub	r12,-48
8000acec:	0a cc       	st.b	r5++,r12
8000acee:	02 36       	cp.w	r6,r1
8000acf0:	c0 a4       	brge	8000ad04 <_dtoa_r+0xb1c>
8000acf2:	00 9b       	mov	r11,r0
8000acf4:	30 09       	mov	r9,0
8000acf6:	30 aa       	mov	r10,10
8000acf8:	0e 9c       	mov	r12,r7
8000acfa:	2f f6       	sub	r6,-1
8000acfc:	e0 a0 07 04 	rcall	8000bb04 <__multadd>
8000ad00:	18 90       	mov	r0,r12
8000ad02:	cf 0b       	rjmp	8000ace2 <_dtoa_r+0xafa>
8000ad04:	08 96       	mov	r6,r4
8000ad06:	30 0b       	mov	r11,0
8000ad08:	06 94       	mov	r4,r3
8000ad0a:	50 4b       	stdsp	sp[0x10],r11
8000ad0c:	00 93       	mov	r3,r0
8000ad0e:	18 90       	mov	r0,r12
8000ad10:	c0 28       	rjmp	8000ad14 <_dtoa_r+0xb2c>
8000ad12:	40 26       	lddsp	r6,sp[0x8]
8000ad14:	06 9b       	mov	r11,r3
8000ad16:	30 1a       	mov	r10,1
8000ad18:	0e 9c       	mov	r12,r7
8000ad1a:	e0 a0 06 29 	rcall	8000b96c <__lshift>
8000ad1e:	04 9b       	mov	r11,r2
8000ad20:	18 93       	mov	r3,r12
8000ad22:	e0 a0 05 02 	rcall	8000b726 <__mcmp>
8000ad26:	e0 89 00 12 	brgt	8000ad4a <_dtoa_r+0xb62>
8000ad2a:	c1 b1       	brne	8000ad60 <_dtoa_r+0xb78>
8000ad2c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ad30:	c0 d1       	brne	8000ad4a <_dtoa_r+0xb62>
8000ad32:	c1 78       	rjmp	8000ad60 <_dtoa_r+0xb78>
8000ad34:	40 89       	lddsp	r9,sp[0x20]
8000ad36:	12 38       	cp.w	r8,r9
8000ad38:	c0 30       	breq	8000ad3e <_dtoa_r+0xb56>
8000ad3a:	10 95       	mov	r5,r8
8000ad3c:	c0 88       	rjmp	8000ad4c <_dtoa_r+0xb64>
8000ad3e:	2f f6       	sub	r6,-1
8000ad40:	50 66       	stdsp	sp[0x18],r6
8000ad42:	33 18       	mov	r8,49
8000ad44:	40 8c       	lddsp	r12,sp[0x20]
8000ad46:	b8 88       	st.b	r12[0x0],r8
8000ad48:	c1 38       	rjmp	8000ad6e <_dtoa_r+0xb86>
8000ad4a:	33 9a       	mov	r10,57
8000ad4c:	0a 98       	mov	r8,r5
8000ad4e:	11 79       	ld.ub	r9,--r8
8000ad50:	f4 09 18 00 	cp.b	r9,r10
8000ad54:	cf 00       	breq	8000ad34 <_dtoa_r+0xb4c>
8000ad56:	2f f9       	sub	r9,-1
8000ad58:	b0 89       	st.b	r8[0x0],r9
8000ad5a:	c0 98       	rjmp	8000ad6c <_dtoa_r+0xb84>
8000ad5c:	10 95       	mov	r5,r8
8000ad5e:	c0 28       	rjmp	8000ad62 <_dtoa_r+0xb7a>
8000ad60:	33 09       	mov	r9,48
8000ad62:	0a 98       	mov	r8,r5
8000ad64:	11 7a       	ld.ub	r10,--r8
8000ad66:	f2 0a 18 00 	cp.b	r10,r9
8000ad6a:	cf 90       	breq	8000ad5c <_dtoa_r+0xb74>
8000ad6c:	50 66       	stdsp	sp[0x18],r6
8000ad6e:	04 9b       	mov	r11,r2
8000ad70:	0e 9c       	mov	r12,r7
8000ad72:	e0 a0 04 f3 	rcall	8000b758 <_Bfree>
8000ad76:	58 04       	cp.w	r4,0
8000ad78:	c1 20       	breq	8000ad9c <_dtoa_r+0xbb4>
8000ad7a:	40 4b       	lddsp	r11,sp[0x10]
8000ad7c:	08 3b       	cp.w	r11,r4
8000ad7e:	5f 19       	srne	r9
8000ad80:	58 0b       	cp.w	r11,0
8000ad82:	5f 18       	srne	r8
8000ad84:	f3 e8 00 08 	and	r8,r9,r8
8000ad88:	c0 40       	breq	8000ad90 <_dtoa_r+0xba8>
8000ad8a:	0e 9c       	mov	r12,r7
8000ad8c:	e0 a0 04 e6 	rcall	8000b758 <_Bfree>
8000ad90:	08 9b       	mov	r11,r4
8000ad92:	0e 9c       	mov	r12,r7
8000ad94:	e0 a0 04 e2 	rcall	8000b758 <_Bfree>
8000ad98:	c0 28       	rjmp	8000ad9c <_dtoa_r+0xbb4>
8000ad9a:	50 66       	stdsp	sp[0x18],r6
8000ad9c:	0e 9c       	mov	r12,r7
8000ad9e:	06 9b       	mov	r11,r3
8000ada0:	e0 a0 04 dc 	rcall	8000b758 <_Bfree>
8000ada4:	30 08       	mov	r8,0
8000ada6:	aa 88       	st.b	r5[0x0],r8
8000ada8:	40 68       	lddsp	r8,sp[0x18]
8000adaa:	41 5a       	lddsp	r10,sp[0x54]
8000adac:	2f f8       	sub	r8,-1
8000adae:	41 29       	lddsp	r9,sp[0x48]
8000adb0:	95 08       	st.w	r10[0x0],r8
8000adb2:	40 8c       	lddsp	r12,sp[0x20]
8000adb4:	58 09       	cp.w	r9,0
8000adb6:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000adba:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000adbe:	2e 6d       	sub	sp,-104
8000adc0:	d8 32       	popm	r0-r7,pc
8000adc2:	d7 03       	nop

8000adc4 <__errno>:
8000adc4:	e0 68 0a 3c 	mov	r8,2620
8000adc8:	70 0c       	ld.w	r12,r8[0x0]
8000adca:	2f 4c       	sub	r12,-12
8000adcc:	5e fc       	retal	r12
8000adce:	d7 03       	nop

8000add0 <_fflush_r>:
8000add0:	d4 21       	pushm	r4-r7,lr
8000add2:	16 97       	mov	r7,r11
8000add4:	18 96       	mov	r6,r12
8000add6:	76 48       	ld.w	r8,r11[0x10]
8000add8:	58 08       	cp.w	r8,0
8000adda:	c7 f0       	breq	8000aed8 <_fflush_r+0x108>
8000addc:	58 0c       	cp.w	r12,0
8000adde:	c0 50       	breq	8000ade8 <_fflush_r+0x18>
8000ade0:	78 68       	ld.w	r8,r12[0x18]
8000ade2:	58 08       	cp.w	r8,0
8000ade4:	c0 21       	brne	8000ade8 <_fflush_r+0x18>
8000ade6:	cc dc       	rcall	8000af80 <__sinit>
8000ade8:	fe c8 cc e4 	sub	r8,pc,-13084
8000adec:	10 37       	cp.w	r7,r8
8000adee:	c0 31       	brne	8000adf4 <_fflush_r+0x24>
8000adf0:	6c 07       	ld.w	r7,r6[0x0]
8000adf2:	c0 c8       	rjmp	8000ae0a <_fflush_r+0x3a>
8000adf4:	fe c8 cc d0 	sub	r8,pc,-13104
8000adf8:	10 37       	cp.w	r7,r8
8000adfa:	c0 31       	brne	8000ae00 <_fflush_r+0x30>
8000adfc:	6c 17       	ld.w	r7,r6[0x4]
8000adfe:	c0 68       	rjmp	8000ae0a <_fflush_r+0x3a>
8000ae00:	fe c8 cc bc 	sub	r8,pc,-13124
8000ae04:	10 37       	cp.w	r7,r8
8000ae06:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae0a:	8e 6a       	ld.sh	r10,r7[0xc]
8000ae0c:	14 98       	mov	r8,r10
8000ae0e:	ed ba 00 03 	bld	r10,0x3
8000ae12:	c4 20       	breq	8000ae96 <_fflush_r+0xc6>
8000ae14:	ab ba       	sbr	r10,0xb
8000ae16:	ae 6a       	st.h	r7[0xc],r10
8000ae18:	6e 18       	ld.w	r8,r7[0x4]
8000ae1a:	58 08       	cp.w	r8,0
8000ae1c:	e0 89 00 06 	brgt	8000ae28 <_fflush_r+0x58>
8000ae20:	6f 08       	ld.w	r8,r7[0x40]
8000ae22:	58 08       	cp.w	r8,0
8000ae24:	e0 8a 00 5a 	brle	8000aed8 <_fflush_r+0x108>
8000ae28:	6e b8       	ld.w	r8,r7[0x2c]
8000ae2a:	58 08       	cp.w	r8,0
8000ae2c:	c5 60       	breq	8000aed8 <_fflush_r+0x108>
8000ae2e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ae32:	c0 30       	breq	8000ae38 <_fflush_r+0x68>
8000ae34:	6f 55       	ld.w	r5,r7[0x54]
8000ae36:	c0 f8       	rjmp	8000ae54 <_fflush_r+0x84>
8000ae38:	30 19       	mov	r9,1
8000ae3a:	6e 8b       	ld.w	r11,r7[0x20]
8000ae3c:	0c 9c       	mov	r12,r6
8000ae3e:	5d 18       	icall	r8
8000ae40:	18 95       	mov	r5,r12
8000ae42:	5b fc       	cp.w	r12,-1
8000ae44:	c0 81       	brne	8000ae54 <_fflush_r+0x84>
8000ae46:	6c 38       	ld.w	r8,r6[0xc]
8000ae48:	59 d8       	cp.w	r8,29
8000ae4a:	c4 70       	breq	8000aed8 <_fflush_r+0x108>
8000ae4c:	8e 68       	ld.sh	r8,r7[0xc]
8000ae4e:	a7 a8       	sbr	r8,0x6
8000ae50:	ae 68       	st.h	r7[0xc],r8
8000ae52:	d8 22       	popm	r4-r7,pc
8000ae54:	8e 68       	ld.sh	r8,r7[0xc]
8000ae56:	ed b8 00 02 	bld	r8,0x2
8000ae5a:	c0 91       	brne	8000ae6c <_fflush_r+0x9c>
8000ae5c:	6e 18       	ld.w	r8,r7[0x4]
8000ae5e:	10 15       	sub	r5,r8
8000ae60:	6e d8       	ld.w	r8,r7[0x34]
8000ae62:	58 08       	cp.w	r8,0
8000ae64:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ae68:	eb d8 e1 15 	subne	r5,r5,r8
8000ae6c:	6e b8       	ld.w	r8,r7[0x2c]
8000ae6e:	0c 9c       	mov	r12,r6
8000ae70:	30 09       	mov	r9,0
8000ae72:	0a 9a       	mov	r10,r5
8000ae74:	6e 8b       	ld.w	r11,r7[0x20]
8000ae76:	5d 18       	icall	r8
8000ae78:	8e 68       	ld.sh	r8,r7[0xc]
8000ae7a:	0a 3c       	cp.w	r12,r5
8000ae7c:	c2 61       	brne	8000aec8 <_fflush_r+0xf8>
8000ae7e:	ab d8       	cbr	r8,0xb
8000ae80:	30 0c       	mov	r12,0
8000ae82:	6e 49       	ld.w	r9,r7[0x10]
8000ae84:	ae 68       	st.h	r7[0xc],r8
8000ae86:	8f 1c       	st.w	r7[0x4],r12
8000ae88:	8f 09       	st.w	r7[0x0],r9
8000ae8a:	ed b8 00 0c 	bld	r8,0xc
8000ae8e:	c2 51       	brne	8000aed8 <_fflush_r+0x108>
8000ae90:	ef 45 00 54 	st.w	r7[84],r5
8000ae94:	d8 22       	popm	r4-r7,pc
8000ae96:	6e 45       	ld.w	r5,r7[0x10]
8000ae98:	58 05       	cp.w	r5,0
8000ae9a:	c1 f0       	breq	8000aed8 <_fflush_r+0x108>
8000ae9c:	6e 04       	ld.w	r4,r7[0x0]
8000ae9e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000aea2:	8f 05       	st.w	r7[0x0],r5
8000aea4:	f9 b8 01 00 	movne	r8,0
8000aea8:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aeac:	0a 14       	sub	r4,r5
8000aeae:	8f 28       	st.w	r7[0x8],r8
8000aeb0:	c1 18       	rjmp	8000aed2 <_fflush_r+0x102>
8000aeb2:	08 99       	mov	r9,r4
8000aeb4:	0a 9a       	mov	r10,r5
8000aeb6:	6e a8       	ld.w	r8,r7[0x28]
8000aeb8:	6e 8b       	ld.w	r11,r7[0x20]
8000aeba:	0c 9c       	mov	r12,r6
8000aebc:	5d 18       	icall	r8
8000aebe:	18 14       	sub	r4,r12
8000aec0:	58 0c       	cp.w	r12,0
8000aec2:	e0 89 00 07 	brgt	8000aed0 <_fflush_r+0x100>
8000aec6:	8e 68       	ld.sh	r8,r7[0xc]
8000aec8:	a7 a8       	sbr	r8,0x6
8000aeca:	3f fc       	mov	r12,-1
8000aecc:	ae 68       	st.h	r7[0xc],r8
8000aece:	d8 22       	popm	r4-r7,pc
8000aed0:	18 05       	add	r5,r12
8000aed2:	58 04       	cp.w	r4,0
8000aed4:	fe 99 ff ef 	brgt	8000aeb2 <_fflush_r+0xe2>
8000aed8:	d8 2a       	popm	r4-r7,pc,r12=0
8000aeda:	d7 03       	nop

8000aedc <__sfp_lock_acquire>:
8000aedc:	5e fc       	retal	r12

8000aede <__sfp_lock_release>:
8000aede:	5e fc       	retal	r12

8000aee0 <_cleanup_r>:
8000aee0:	d4 01       	pushm	lr
8000aee2:	fe cb f0 ae 	sub	r11,pc,-3922
8000aee6:	e0 a0 02 f7 	rcall	8000b4d4 <_fwalk>
8000aeea:	d8 02       	popm	pc

8000aeec <__sfmoreglue>:
8000aeec:	d4 21       	pushm	r4-r7,lr
8000aeee:	16 95       	mov	r5,r11
8000aef0:	f6 06 10 5c 	mul	r6,r11,92
8000aef4:	ec cb ff f4 	sub	r11,r6,-12
8000aef8:	fe b0 e2 88 	rcall	80007408 <_malloc_r>
8000aefc:	18 97       	mov	r7,r12
8000aefe:	c0 90       	breq	8000af10 <__sfmoreglue+0x24>
8000af00:	99 15       	st.w	r12[0x4],r5
8000af02:	30 0b       	mov	r11,0
8000af04:	2f 4c       	sub	r12,-12
8000af06:	0c 9a       	mov	r10,r6
8000af08:	8f 2c       	st.w	r7[0x8],r12
8000af0a:	8f 0b       	st.w	r7[0x0],r11
8000af0c:	fe b0 e5 3e 	rcall	80007988 <memset>
8000af10:	0e 9c       	mov	r12,r7
8000af12:	d8 22       	popm	r4-r7,pc

8000af14 <__sfp>:
8000af14:	d4 21       	pushm	r4-r7,lr
8000af16:	fe c8 cd ae 	sub	r8,pc,-12882
8000af1a:	18 96       	mov	r6,r12
8000af1c:	70 07       	ld.w	r7,r8[0x0]
8000af1e:	6e 68       	ld.w	r8,r7[0x18]
8000af20:	58 08       	cp.w	r8,0
8000af22:	c0 31       	brne	8000af28 <__sfp+0x14>
8000af24:	0e 9c       	mov	r12,r7
8000af26:	c2 dc       	rcall	8000af80 <__sinit>
8000af28:	ee c7 ff 28 	sub	r7,r7,-216
8000af2c:	30 05       	mov	r5,0
8000af2e:	6e 2c       	ld.w	r12,r7[0x8]
8000af30:	6e 18       	ld.w	r8,r7[0x4]
8000af32:	c0 68       	rjmp	8000af3e <__sfp+0x2a>
8000af34:	98 69       	ld.sh	r9,r12[0xc]
8000af36:	ea 09 19 00 	cp.h	r9,r5
8000af3a:	c1 10       	breq	8000af5c <__sfp+0x48>
8000af3c:	2a 4c       	sub	r12,-92
8000af3e:	20 18       	sub	r8,1
8000af40:	cf a7       	brpl	8000af34 <__sfp+0x20>
8000af42:	6e 08       	ld.w	r8,r7[0x0]
8000af44:	58 08       	cp.w	r8,0
8000af46:	c0 61       	brne	8000af52 <__sfp+0x3e>
8000af48:	30 4b       	mov	r11,4
8000af4a:	0c 9c       	mov	r12,r6
8000af4c:	cd 0f       	rcall	8000aeec <__sfmoreglue>
8000af4e:	8f 0c       	st.w	r7[0x0],r12
8000af50:	c0 30       	breq	8000af56 <__sfp+0x42>
8000af52:	6e 07       	ld.w	r7,r7[0x0]
8000af54:	ce db       	rjmp	8000af2e <__sfp+0x1a>
8000af56:	30 c8       	mov	r8,12
8000af58:	8d 38       	st.w	r6[0xc],r8
8000af5a:	d8 22       	popm	r4-r7,pc
8000af5c:	30 08       	mov	r8,0
8000af5e:	f9 48 00 4c 	st.w	r12[76],r8
8000af62:	99 08       	st.w	r12[0x0],r8
8000af64:	99 28       	st.w	r12[0x8],r8
8000af66:	99 18       	st.w	r12[0x4],r8
8000af68:	99 48       	st.w	r12[0x10],r8
8000af6a:	99 58       	st.w	r12[0x14],r8
8000af6c:	99 68       	st.w	r12[0x18],r8
8000af6e:	99 d8       	st.w	r12[0x34],r8
8000af70:	99 e8       	st.w	r12[0x38],r8
8000af72:	f9 48 00 48 	st.w	r12[72],r8
8000af76:	3f f8       	mov	r8,-1
8000af78:	b8 78       	st.h	r12[0xe],r8
8000af7a:	30 18       	mov	r8,1
8000af7c:	b8 68       	st.h	r12[0xc],r8
8000af7e:	d8 22       	popm	r4-r7,pc

8000af80 <__sinit>:
8000af80:	d4 21       	pushm	r4-r7,lr
8000af82:	18 96       	mov	r6,r12
8000af84:	78 67       	ld.w	r7,r12[0x18]
8000af86:	58 07       	cp.w	r7,0
8000af88:	c4 91       	brne	8000b01a <__sinit+0x9a>
8000af8a:	fe c8 00 aa 	sub	r8,pc,170
8000af8e:	30 15       	mov	r5,1
8000af90:	99 a8       	st.w	r12[0x28],r8
8000af92:	f9 47 00 d8 	st.w	r12[216],r7
8000af96:	f9 47 00 dc 	st.w	r12[220],r7
8000af9a:	f9 47 00 e0 	st.w	r12[224],r7
8000af9e:	99 65       	st.w	r12[0x18],r5
8000afa0:	cb af       	rcall	8000af14 <__sfp>
8000afa2:	8d 0c       	st.w	r6[0x0],r12
8000afa4:	0c 9c       	mov	r12,r6
8000afa6:	cb 7f       	rcall	8000af14 <__sfp>
8000afa8:	8d 1c       	st.w	r6[0x4],r12
8000afaa:	0c 9c       	mov	r12,r6
8000afac:	cb 4f       	rcall	8000af14 <__sfp>
8000afae:	6c 09       	ld.w	r9,r6[0x0]
8000afb0:	30 48       	mov	r8,4
8000afb2:	93 07       	st.w	r9[0x0],r7
8000afb4:	b2 68       	st.h	r9[0xc],r8
8000afb6:	93 17       	st.w	r9[0x4],r7
8000afb8:	93 27       	st.w	r9[0x8],r7
8000afba:	6c 18       	ld.w	r8,r6[0x4]
8000afbc:	b2 77       	st.h	r9[0xe],r7
8000afbe:	93 47       	st.w	r9[0x10],r7
8000afc0:	93 57       	st.w	r9[0x14],r7
8000afc2:	93 67       	st.w	r9[0x18],r7
8000afc4:	93 89       	st.w	r9[0x20],r9
8000afc6:	91 07       	st.w	r8[0x0],r7
8000afc8:	91 17       	st.w	r8[0x4],r7
8000afca:	91 27       	st.w	r8[0x8],r7
8000afcc:	fe ce f3 24 	sub	lr,pc,-3292
8000afd0:	fe cb f3 54 	sub	r11,pc,-3244
8000afd4:	93 9e       	st.w	r9[0x24],lr
8000afd6:	93 ab       	st.w	r9[0x28],r11
8000afd8:	fe ca f3 7c 	sub	r10,pc,-3204
8000afdc:	fe c4 f3 88 	sub	r4,pc,-3192
8000afe0:	93 ba       	st.w	r9[0x2c],r10
8000afe2:	93 c4       	st.w	r9[0x30],r4
8000afe4:	30 99       	mov	r9,9
8000afe6:	b0 69       	st.h	r8[0xc],r9
8000afe8:	b0 75       	st.h	r8[0xe],r5
8000afea:	91 c4       	st.w	r8[0x30],r4
8000afec:	91 47       	st.w	r8[0x10],r7
8000afee:	91 57       	st.w	r8[0x14],r7
8000aff0:	91 67       	st.w	r8[0x18],r7
8000aff2:	91 88       	st.w	r8[0x20],r8
8000aff4:	91 9e       	st.w	r8[0x24],lr
8000aff6:	91 ab       	st.w	r8[0x28],r11
8000aff8:	91 ba       	st.w	r8[0x2c],r10
8000affa:	8d 2c       	st.w	r6[0x8],r12
8000affc:	31 28       	mov	r8,18
8000affe:	99 07       	st.w	r12[0x0],r7
8000b000:	b8 68       	st.h	r12[0xc],r8
8000b002:	99 17       	st.w	r12[0x4],r7
8000b004:	99 27       	st.w	r12[0x8],r7
8000b006:	30 28       	mov	r8,2
8000b008:	b8 78       	st.h	r12[0xe],r8
8000b00a:	99 c4       	st.w	r12[0x30],r4
8000b00c:	99 67       	st.w	r12[0x18],r7
8000b00e:	99 9e       	st.w	r12[0x24],lr
8000b010:	99 ab       	st.w	r12[0x28],r11
8000b012:	99 ba       	st.w	r12[0x2c],r10
8000b014:	99 47       	st.w	r12[0x10],r7
8000b016:	99 57       	st.w	r12[0x14],r7
8000b018:	99 8c       	st.w	r12[0x20],r12
8000b01a:	d8 22       	popm	r4-r7,pc

8000b01c <_malloc_trim_r>:
8000b01c:	d4 21       	pushm	r4-r7,lr
8000b01e:	16 95       	mov	r5,r11
8000b020:	18 97       	mov	r7,r12
8000b022:	fe b0 d7 ad 	rcall	80005f7c <__malloc_lock>
8000b026:	e0 64 05 3c 	mov	r4,1340
8000b02a:	68 28       	ld.w	r8,r4[0x8]
8000b02c:	70 16       	ld.w	r6,r8[0x4]
8000b02e:	e0 16 ff fc 	andl	r6,0xfffc
8000b032:	ec c8 ff 91 	sub	r8,r6,-111
8000b036:	f0 05 01 05 	sub	r5,r8,r5
8000b03a:	e0 15 ff 80 	andl	r5,0xff80
8000b03e:	ea c5 00 80 	sub	r5,r5,128
8000b042:	e0 45 00 7f 	cp.w	r5,127
8000b046:	e0 8a 00 25 	brle	8000b090 <_malloc_trim_r+0x74>
8000b04a:	30 0b       	mov	r11,0
8000b04c:	0e 9c       	mov	r12,r7
8000b04e:	fe b0 e6 05 	rcall	80007c58 <_sbrk_r>
8000b052:	68 28       	ld.w	r8,r4[0x8]
8000b054:	0c 08       	add	r8,r6
8000b056:	10 3c       	cp.w	r12,r8
8000b058:	c1 c1       	brne	8000b090 <_malloc_trim_r+0x74>
8000b05a:	ea 0b 11 00 	rsub	r11,r5,0
8000b05e:	0e 9c       	mov	r12,r7
8000b060:	fe b0 e5 fc 	rcall	80007c58 <_sbrk_r>
8000b064:	5b fc       	cp.w	r12,-1
8000b066:	c1 91       	brne	8000b098 <_malloc_trim_r+0x7c>
8000b068:	30 0b       	mov	r11,0
8000b06a:	0e 9c       	mov	r12,r7
8000b06c:	fe b0 e5 f6 	rcall	80007c58 <_sbrk_r>
8000b070:	68 28       	ld.w	r8,r4[0x8]
8000b072:	f8 08 01 09 	sub	r9,r12,r8
8000b076:	58 f9       	cp.w	r9,15
8000b078:	e0 8a 00 0c 	brle	8000b090 <_malloc_trim_r+0x74>
8000b07c:	a1 a9       	sbr	r9,0x0
8000b07e:	91 19       	st.w	r8[0x4],r9
8000b080:	e0 68 09 48 	mov	r8,2376
8000b084:	70 09       	ld.w	r9,r8[0x0]
8000b086:	e0 68 0d 74 	mov	r8,3444
8000b08a:	f8 09 01 09 	sub	r9,r12,r9
8000b08e:	91 09       	st.w	r8[0x0],r9
8000b090:	0e 9c       	mov	r12,r7
8000b092:	fe b0 d7 7b 	rcall	80005f88 <__malloc_unlock>
8000b096:	d8 2a       	popm	r4-r7,pc,r12=0
8000b098:	68 28       	ld.w	r8,r4[0x8]
8000b09a:	0a 16       	sub	r6,r5
8000b09c:	a1 a6       	sbr	r6,0x0
8000b09e:	91 16       	st.w	r8[0x4],r6
8000b0a0:	e0 68 0d 74 	mov	r8,3444
8000b0a4:	70 09       	ld.w	r9,r8[0x0]
8000b0a6:	0a 19       	sub	r9,r5
8000b0a8:	0e 9c       	mov	r12,r7
8000b0aa:	91 09       	st.w	r8[0x0],r9
8000b0ac:	fe b0 d7 6e 	rcall	80005f88 <__malloc_unlock>
8000b0b0:	da 2a       	popm	r4-r7,pc,r12=1
8000b0b2:	d7 03       	nop

8000b0b4 <_free_r>:
8000b0b4:	d4 21       	pushm	r4-r7,lr
8000b0b6:	16 96       	mov	r6,r11
8000b0b8:	18 97       	mov	r7,r12
8000b0ba:	58 0b       	cp.w	r11,0
8000b0bc:	e0 80 00 c0 	breq	8000b23c <_free_r+0x188>
8000b0c0:	fe b0 d7 5e 	rcall	80005f7c <__malloc_lock>
8000b0c4:	20 86       	sub	r6,8
8000b0c6:	e0 6a 05 3c 	mov	r10,1340
8000b0ca:	6c 18       	ld.w	r8,r6[0x4]
8000b0cc:	74 2e       	ld.w	lr,r10[0x8]
8000b0ce:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b0d2:	a1 c8       	cbr	r8,0x0
8000b0d4:	ec 08 00 09 	add	r9,r6,r8
8000b0d8:	72 1b       	ld.w	r11,r9[0x4]
8000b0da:	e0 1b ff fc 	andl	r11,0xfffc
8000b0de:	1c 39       	cp.w	r9,lr
8000b0e0:	c1 e1       	brne	8000b11c <_free_r+0x68>
8000b0e2:	f6 08 00 08 	add	r8,r11,r8
8000b0e6:	58 0c       	cp.w	r12,0
8000b0e8:	c0 81       	brne	8000b0f8 <_free_r+0x44>
8000b0ea:	6c 09       	ld.w	r9,r6[0x0]
8000b0ec:	12 16       	sub	r6,r9
8000b0ee:	12 08       	add	r8,r9
8000b0f0:	6c 3b       	ld.w	r11,r6[0xc]
8000b0f2:	6c 29       	ld.w	r9,r6[0x8]
8000b0f4:	97 29       	st.w	r11[0x8],r9
8000b0f6:	93 3b       	st.w	r9[0xc],r11
8000b0f8:	10 99       	mov	r9,r8
8000b0fa:	95 26       	st.w	r10[0x8],r6
8000b0fc:	a1 a9       	sbr	r9,0x0
8000b0fe:	8d 19       	st.w	r6[0x4],r9
8000b100:	e0 69 09 44 	mov	r9,2372
8000b104:	72 09       	ld.w	r9,r9[0x0]
8000b106:	12 38       	cp.w	r8,r9
8000b108:	c0 63       	brcs	8000b114 <_free_r+0x60>
8000b10a:	e0 68 0d 70 	mov	r8,3440
8000b10e:	0e 9c       	mov	r12,r7
8000b110:	70 0b       	ld.w	r11,r8[0x0]
8000b112:	c8 5f       	rcall	8000b01c <_malloc_trim_r>
8000b114:	0e 9c       	mov	r12,r7
8000b116:	fe b0 d7 39 	rcall	80005f88 <__malloc_unlock>
8000b11a:	d8 22       	popm	r4-r7,pc
8000b11c:	93 1b       	st.w	r9[0x4],r11
8000b11e:	58 0c       	cp.w	r12,0
8000b120:	c0 30       	breq	8000b126 <_free_r+0x72>
8000b122:	30 0c       	mov	r12,0
8000b124:	c1 08       	rjmp	8000b144 <_free_r+0x90>
8000b126:	6c 0e       	ld.w	lr,r6[0x0]
8000b128:	f4 c5 ff f8 	sub	r5,r10,-8
8000b12c:	1c 16       	sub	r6,lr
8000b12e:	1c 08       	add	r8,lr
8000b130:	6c 2e       	ld.w	lr,r6[0x8]
8000b132:	0a 3e       	cp.w	lr,r5
8000b134:	f9 bc 00 01 	moveq	r12,1
8000b138:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b13c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b140:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b144:	f2 0b 00 0e 	add	lr,r9,r11
8000b148:	7c 1e       	ld.w	lr,lr[0x4]
8000b14a:	ed be 00 00 	bld	lr,0x0
8000b14e:	c1 40       	breq	8000b176 <_free_r+0xc2>
8000b150:	16 08       	add	r8,r11
8000b152:	58 0c       	cp.w	r12,0
8000b154:	c0 d1       	brne	8000b16e <_free_r+0xba>
8000b156:	e0 6e 05 3c 	mov	lr,1340
8000b15a:	72 2b       	ld.w	r11,r9[0x8]
8000b15c:	2f 8e       	sub	lr,-8
8000b15e:	1c 3b       	cp.w	r11,lr
8000b160:	c0 71       	brne	8000b16e <_free_r+0xba>
8000b162:	97 36       	st.w	r11[0xc],r6
8000b164:	97 26       	st.w	r11[0x8],r6
8000b166:	8d 2b       	st.w	r6[0x8],r11
8000b168:	8d 3b       	st.w	r6[0xc],r11
8000b16a:	30 1c       	mov	r12,1
8000b16c:	c0 58       	rjmp	8000b176 <_free_r+0xc2>
8000b16e:	72 2b       	ld.w	r11,r9[0x8]
8000b170:	72 39       	ld.w	r9,r9[0xc]
8000b172:	93 2b       	st.w	r9[0x8],r11
8000b174:	97 39       	st.w	r11[0xc],r9
8000b176:	10 99       	mov	r9,r8
8000b178:	ec 08 09 08 	st.w	r6[r8],r8
8000b17c:	a1 a9       	sbr	r9,0x0
8000b17e:	8d 19       	st.w	r6[0x4],r9
8000b180:	58 0c       	cp.w	r12,0
8000b182:	c5 a1       	brne	8000b236 <_free_r+0x182>
8000b184:	e0 48 01 ff 	cp.w	r8,511
8000b188:	e0 8b 00 13 	brhi	8000b1ae <_free_r+0xfa>
8000b18c:	a3 98       	lsr	r8,0x3
8000b18e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b192:	72 2b       	ld.w	r11,r9[0x8]
8000b194:	8d 39       	st.w	r6[0xc],r9
8000b196:	8d 2b       	st.w	r6[0x8],r11
8000b198:	97 36       	st.w	r11[0xc],r6
8000b19a:	93 26       	st.w	r9[0x8],r6
8000b19c:	a3 48       	asr	r8,0x2
8000b19e:	74 19       	ld.w	r9,r10[0x4]
8000b1a0:	30 1b       	mov	r11,1
8000b1a2:	f6 08 09 48 	lsl	r8,r11,r8
8000b1a6:	f3 e8 10 08 	or	r8,r9,r8
8000b1aa:	95 18       	st.w	r10[0x4],r8
8000b1ac:	c4 58       	rjmp	8000b236 <_free_r+0x182>
8000b1ae:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b1b2:	58 4b       	cp.w	r11,4
8000b1b4:	e0 8b 00 06 	brhi	8000b1c0 <_free_r+0x10c>
8000b1b8:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b1bc:	2c 8b       	sub	r11,-56
8000b1be:	c2 08       	rjmp	8000b1fe <_free_r+0x14a>
8000b1c0:	59 4b       	cp.w	r11,20
8000b1c2:	e0 8b 00 04 	brhi	8000b1ca <_free_r+0x116>
8000b1c6:	2a 5b       	sub	r11,-91
8000b1c8:	c1 b8       	rjmp	8000b1fe <_free_r+0x14a>
8000b1ca:	e0 4b 00 54 	cp.w	r11,84
8000b1ce:	e0 8b 00 06 	brhi	8000b1da <_free_r+0x126>
8000b1d2:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b1d6:	29 2b       	sub	r11,-110
8000b1d8:	c1 38       	rjmp	8000b1fe <_free_r+0x14a>
8000b1da:	e0 4b 01 54 	cp.w	r11,340
8000b1de:	e0 8b 00 06 	brhi	8000b1ea <_free_r+0x136>
8000b1e2:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b1e6:	28 9b       	sub	r11,-119
8000b1e8:	c0 b8       	rjmp	8000b1fe <_free_r+0x14a>
8000b1ea:	e0 4b 05 54 	cp.w	r11,1364
8000b1ee:	e0 88 00 05 	brls	8000b1f8 <_free_r+0x144>
8000b1f2:	37 eb       	mov	r11,126
8000b1f4:	c0 58       	rjmp	8000b1fe <_free_r+0x14a>
8000b1f6:	d7 03       	nop
8000b1f8:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b1fc:	28 4b       	sub	r11,-124
8000b1fe:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b202:	78 29       	ld.w	r9,r12[0x8]
8000b204:	18 39       	cp.w	r9,r12
8000b206:	c0 e1       	brne	8000b222 <_free_r+0x16e>
8000b208:	74 18       	ld.w	r8,r10[0x4]
8000b20a:	a3 4b       	asr	r11,0x2
8000b20c:	30 1c       	mov	r12,1
8000b20e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b212:	f1 eb 10 0b 	or	r11,r8,r11
8000b216:	12 98       	mov	r8,r9
8000b218:	95 1b       	st.w	r10[0x4],r11
8000b21a:	c0 a8       	rjmp	8000b22e <_free_r+0x17a>
8000b21c:	72 29       	ld.w	r9,r9[0x8]
8000b21e:	18 39       	cp.w	r9,r12
8000b220:	c0 60       	breq	8000b22c <_free_r+0x178>
8000b222:	72 1a       	ld.w	r10,r9[0x4]
8000b224:	e0 1a ff fc 	andl	r10,0xfffc
8000b228:	14 38       	cp.w	r8,r10
8000b22a:	cf 93       	brcs	8000b21c <_free_r+0x168>
8000b22c:	72 38       	ld.w	r8,r9[0xc]
8000b22e:	8d 38       	st.w	r6[0xc],r8
8000b230:	8d 29       	st.w	r6[0x8],r9
8000b232:	93 36       	st.w	r9[0xc],r6
8000b234:	91 26       	st.w	r8[0x8],r6
8000b236:	0e 9c       	mov	r12,r7
8000b238:	fe b0 d6 a8 	rcall	80005f88 <__malloc_unlock>
8000b23c:	d8 22       	popm	r4-r7,pc
8000b23e:	d7 03       	nop

8000b240 <__sfvwrite_r>:
8000b240:	d4 31       	pushm	r0-r7,lr
8000b242:	20 3d       	sub	sp,12
8000b244:	14 94       	mov	r4,r10
8000b246:	18 95       	mov	r5,r12
8000b248:	16 97       	mov	r7,r11
8000b24a:	74 28       	ld.w	r8,r10[0x8]
8000b24c:	58 08       	cp.w	r8,0
8000b24e:	e0 80 01 40 	breq	8000b4ce <__sfvwrite_r+0x28e>
8000b252:	96 68       	ld.sh	r8,r11[0xc]
8000b254:	ed b8 00 03 	bld	r8,0x3
8000b258:	c0 41       	brne	8000b260 <__sfvwrite_r+0x20>
8000b25a:	76 48       	ld.w	r8,r11[0x10]
8000b25c:	58 08       	cp.w	r8,0
8000b25e:	c0 c1       	brne	8000b276 <__sfvwrite_r+0x36>
8000b260:	0e 9b       	mov	r11,r7
8000b262:	0a 9c       	mov	r12,r5
8000b264:	fe b0 f6 c4 	rcall	80009fec <__swsetup_r>
8000b268:	c0 70       	breq	8000b276 <__sfvwrite_r+0x36>
8000b26a:	8e 68       	ld.sh	r8,r7[0xc]
8000b26c:	a7 a8       	sbr	r8,0x6
8000b26e:	ae 68       	st.h	r7[0xc],r8
8000b270:	30 98       	mov	r8,9
8000b272:	8b 38       	st.w	r5[0xc],r8
8000b274:	c2 b9       	rjmp	8000b4ca <__sfvwrite_r+0x28a>
8000b276:	8e 63       	ld.sh	r3,r7[0xc]
8000b278:	68 00       	ld.w	r0,r4[0x0]
8000b27a:	06 96       	mov	r6,r3
8000b27c:	e2 16 00 02 	andl	r6,0x2,COH
8000b280:	c2 10       	breq	8000b2c2 <__sfvwrite_r+0x82>
8000b282:	30 03       	mov	r3,0
8000b284:	e0 62 04 00 	mov	r2,1024
8000b288:	06 96       	mov	r6,r3
8000b28a:	c0 48       	rjmp	8000b292 <__sfvwrite_r+0x52>
8000b28c:	60 03       	ld.w	r3,r0[0x0]
8000b28e:	60 16       	ld.w	r6,r0[0x4]
8000b290:	2f 80       	sub	r0,-8
8000b292:	58 06       	cp.w	r6,0
8000b294:	cf c0       	breq	8000b28c <__sfvwrite_r+0x4c>
8000b296:	e0 46 04 00 	cp.w	r6,1024
8000b29a:	ec 09 17 80 	movls	r9,r6
8000b29e:	e4 09 17 b0 	movhi	r9,r2
8000b2a2:	06 9a       	mov	r10,r3
8000b2a4:	6e a8       	ld.w	r8,r7[0x28]
8000b2a6:	6e 8b       	ld.w	r11,r7[0x20]
8000b2a8:	0a 9c       	mov	r12,r5
8000b2aa:	5d 18       	icall	r8
8000b2ac:	18 16       	sub	r6,r12
8000b2ae:	58 0c       	cp.w	r12,0
8000b2b0:	e0 8a 01 0a 	brle	8000b4c4 <__sfvwrite_r+0x284>
8000b2b4:	68 28       	ld.w	r8,r4[0x8]
8000b2b6:	18 18       	sub	r8,r12
8000b2b8:	89 28       	st.w	r4[0x8],r8
8000b2ba:	e0 80 01 0a 	breq	8000b4ce <__sfvwrite_r+0x28e>
8000b2be:	18 03       	add	r3,r12
8000b2c0:	ce 9b       	rjmp	8000b292 <__sfvwrite_r+0x52>
8000b2c2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b2c6:	c0 70       	breq	8000b2d4 <__sfvwrite_r+0x94>
8000b2c8:	50 06       	stdsp	sp[0x0],r6
8000b2ca:	0c 93       	mov	r3,r6
8000b2cc:	0c 91       	mov	r1,r6
8000b2ce:	50 15       	stdsp	sp[0x4],r5
8000b2d0:	08 92       	mov	r2,r4
8000b2d2:	c9 c8       	rjmp	8000b40a <__sfvwrite_r+0x1ca>
8000b2d4:	06 96       	mov	r6,r3
8000b2d6:	08 91       	mov	r1,r4
8000b2d8:	c0 48       	rjmp	8000b2e0 <__sfvwrite_r+0xa0>
8000b2da:	60 03       	ld.w	r3,r0[0x0]
8000b2dc:	60 16       	ld.w	r6,r0[0x4]
8000b2de:	2f 80       	sub	r0,-8
8000b2e0:	58 06       	cp.w	r6,0
8000b2e2:	cf c0       	breq	8000b2da <__sfvwrite_r+0x9a>
8000b2e4:	8e 68       	ld.sh	r8,r7[0xc]
8000b2e6:	6e 24       	ld.w	r4,r7[0x8]
8000b2e8:	10 99       	mov	r9,r8
8000b2ea:	e2 19 02 00 	andl	r9,0x200,COH
8000b2ee:	c5 50       	breq	8000b398 <__sfvwrite_r+0x158>
8000b2f0:	08 36       	cp.w	r6,r4
8000b2f2:	c4 43       	brcs	8000b37a <__sfvwrite_r+0x13a>
8000b2f4:	10 99       	mov	r9,r8
8000b2f6:	e2 19 04 80 	andl	r9,0x480,COH
8000b2fa:	c4 00       	breq	8000b37a <__sfvwrite_r+0x13a>
8000b2fc:	6e 4b       	ld.w	r11,r7[0x10]
8000b2fe:	6e 09       	ld.w	r9,r7[0x0]
8000b300:	16 19       	sub	r9,r11
8000b302:	50 09       	stdsp	sp[0x0],r9
8000b304:	6e 59       	ld.w	r9,r7[0x14]
8000b306:	10 9c       	mov	r12,r8
8000b308:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b30c:	30 28       	mov	r8,2
8000b30e:	f4 08 0c 08 	divs	r8,r10,r8
8000b312:	fa e9 00 04 	st.d	sp[4],r8
8000b316:	10 94       	mov	r4,r8
8000b318:	40 09       	lddsp	r9,sp[0x0]
8000b31a:	e2 1c 04 00 	andl	r12,0x400,COH
8000b31e:	2f f9       	sub	r9,-1
8000b320:	0c 09       	add	r9,r6
8000b322:	12 38       	cp.w	r8,r9
8000b324:	f2 04 17 30 	movlo	r4,r9
8000b328:	58 0c       	cp.w	r12,0
8000b32a:	c1 10       	breq	8000b34c <__sfvwrite_r+0x10c>
8000b32c:	08 9b       	mov	r11,r4
8000b32e:	0a 9c       	mov	r12,r5
8000b330:	fe b0 e0 6c 	rcall	80007408 <_malloc_r>
8000b334:	18 92       	mov	r2,r12
8000b336:	c1 40       	breq	8000b35e <__sfvwrite_r+0x11e>
8000b338:	40 0a       	lddsp	r10,sp[0x0]
8000b33a:	6e 4b       	ld.w	r11,r7[0x10]
8000b33c:	fe b0 e2 82 	rcall	80007840 <memcpy>
8000b340:	8e 68       	ld.sh	r8,r7[0xc]
8000b342:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b346:	a7 b8       	sbr	r8,0x7
8000b348:	ae 68       	st.h	r7[0xc],r8
8000b34a:	c0 d8       	rjmp	8000b364 <__sfvwrite_r+0x124>
8000b34c:	08 9a       	mov	r10,r4
8000b34e:	0a 9c       	mov	r12,r5
8000b350:	fe b0 e3 24 	rcall	80007998 <_realloc_r>
8000b354:	18 92       	mov	r2,r12
8000b356:	c0 71       	brne	8000b364 <__sfvwrite_r+0x124>
8000b358:	6e 4b       	ld.w	r11,r7[0x10]
8000b35a:	0a 9c       	mov	r12,r5
8000b35c:	ca ce       	rcall	8000b0b4 <_free_r>
8000b35e:	30 c8       	mov	r8,12
8000b360:	8b 38       	st.w	r5[0xc],r8
8000b362:	cb 18       	rjmp	8000b4c4 <__sfvwrite_r+0x284>
8000b364:	40 0a       	lddsp	r10,sp[0x0]
8000b366:	40 09       	lddsp	r9,sp[0x0]
8000b368:	e8 0a 01 0a 	sub	r10,r4,r10
8000b36c:	e4 09 00 08 	add	r8,r2,r9
8000b370:	8f 54       	st.w	r7[0x14],r4
8000b372:	8f 2a       	st.w	r7[0x8],r10
8000b374:	8f 08       	st.w	r7[0x0],r8
8000b376:	8f 42       	st.w	r7[0x10],r2
8000b378:	0c 94       	mov	r4,r6
8000b37a:	08 36       	cp.w	r6,r4
8000b37c:	ec 04 17 30 	movlo	r4,r6
8000b380:	06 9b       	mov	r11,r3
8000b382:	08 9a       	mov	r10,r4
8000b384:	6e 0c       	ld.w	r12,r7[0x0]
8000b386:	c3 ad       	rcall	8000b5fa <memmove>
8000b388:	6e 08       	ld.w	r8,r7[0x0]
8000b38a:	08 08       	add	r8,r4
8000b38c:	8f 08       	st.w	r7[0x0],r8
8000b38e:	6e 28       	ld.w	r8,r7[0x8]
8000b390:	08 18       	sub	r8,r4
8000b392:	0c 94       	mov	r4,r6
8000b394:	8f 28       	st.w	r7[0x8],r8
8000b396:	c2 e8       	rjmp	8000b3f2 <__sfvwrite_r+0x1b2>
8000b398:	08 36       	cp.w	r6,r4
8000b39a:	5f ba       	srhi	r10
8000b39c:	6e 0c       	ld.w	r12,r7[0x0]
8000b39e:	6e 48       	ld.w	r8,r7[0x10]
8000b3a0:	10 3c       	cp.w	r12,r8
8000b3a2:	5f b8       	srhi	r8
8000b3a4:	f5 e8 00 08 	and	r8,r10,r8
8000b3a8:	f2 08 18 00 	cp.b	r8,r9
8000b3ac:	c0 d0       	breq	8000b3c6 <__sfvwrite_r+0x186>
8000b3ae:	06 9b       	mov	r11,r3
8000b3b0:	08 9a       	mov	r10,r4
8000b3b2:	c2 4d       	rcall	8000b5fa <memmove>
8000b3b4:	6e 08       	ld.w	r8,r7[0x0]
8000b3b6:	08 08       	add	r8,r4
8000b3b8:	0e 9b       	mov	r11,r7
8000b3ba:	8f 08       	st.w	r7[0x0],r8
8000b3bc:	0a 9c       	mov	r12,r5
8000b3be:	fe b0 fd 09 	rcall	8000add0 <_fflush_r>
8000b3c2:	c1 80       	breq	8000b3f2 <__sfvwrite_r+0x1b2>
8000b3c4:	c8 08       	rjmp	8000b4c4 <__sfvwrite_r+0x284>
8000b3c6:	6e 59       	ld.w	r9,r7[0x14]
8000b3c8:	12 36       	cp.w	r6,r9
8000b3ca:	c0 a3       	brcs	8000b3de <__sfvwrite_r+0x19e>
8000b3cc:	6e a8       	ld.w	r8,r7[0x28]
8000b3ce:	06 9a       	mov	r10,r3
8000b3d0:	6e 8b       	ld.w	r11,r7[0x20]
8000b3d2:	0a 9c       	mov	r12,r5
8000b3d4:	5d 18       	icall	r8
8000b3d6:	18 94       	mov	r4,r12
8000b3d8:	e0 89 00 0d 	brgt	8000b3f2 <__sfvwrite_r+0x1b2>
8000b3dc:	c7 48       	rjmp	8000b4c4 <__sfvwrite_r+0x284>
8000b3de:	0c 9a       	mov	r10,r6
8000b3e0:	06 9b       	mov	r11,r3
8000b3e2:	c0 cd       	rcall	8000b5fa <memmove>
8000b3e4:	6e 08       	ld.w	r8,r7[0x0]
8000b3e6:	0c 08       	add	r8,r6
8000b3e8:	0c 94       	mov	r4,r6
8000b3ea:	8f 08       	st.w	r7[0x0],r8
8000b3ec:	6e 28       	ld.w	r8,r7[0x8]
8000b3ee:	0c 18       	sub	r8,r6
8000b3f0:	8f 28       	st.w	r7[0x8],r8
8000b3f2:	62 28       	ld.w	r8,r1[0x8]
8000b3f4:	08 18       	sub	r8,r4
8000b3f6:	83 28       	st.w	r1[0x8],r8
8000b3f8:	c6 b0       	breq	8000b4ce <__sfvwrite_r+0x28e>
8000b3fa:	08 16       	sub	r6,r4
8000b3fc:	08 03       	add	r3,r4
8000b3fe:	c7 1b       	rjmp	8000b2e0 <__sfvwrite_r+0xa0>
8000b400:	60 03       	ld.w	r3,r0[0x0]
8000b402:	60 11       	ld.w	r1,r0[0x4]
8000b404:	30 08       	mov	r8,0
8000b406:	2f 80       	sub	r0,-8
8000b408:	50 08       	stdsp	sp[0x0],r8
8000b40a:	58 01       	cp.w	r1,0
8000b40c:	cf a0       	breq	8000b400 <__sfvwrite_r+0x1c0>
8000b40e:	40 0a       	lddsp	r10,sp[0x0]
8000b410:	58 0a       	cp.w	r10,0
8000b412:	c1 41       	brne	8000b43a <__sfvwrite_r+0x1fa>
8000b414:	e2 c6 ff ff 	sub	r6,r1,-1
8000b418:	02 9a       	mov	r10,r1
8000b41a:	30 ab       	mov	r11,10
8000b41c:	06 9c       	mov	r12,r3
8000b41e:	ce 3c       	rcall	8000b5e4 <memchr>
8000b420:	f8 c8 ff ff 	sub	r8,r12,-1
8000b424:	58 0c       	cp.w	r12,0
8000b426:	f1 d3 e1 16 	subne	r6,r8,r3
8000b42a:	f9 b9 01 01 	movne	r9,1
8000b42e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b432:	f9 b8 00 01 	moveq	r8,1
8000b436:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b43a:	02 36       	cp.w	r6,r1
8000b43c:	ec 04 17 80 	movls	r4,r6
8000b440:	e2 04 17 b0 	movhi	r4,r1
8000b444:	6e 59       	ld.w	r9,r7[0x14]
8000b446:	6e 25       	ld.w	r5,r7[0x8]
8000b448:	f2 05 00 05 	add	r5,r9,r5
8000b44c:	0a 34       	cp.w	r4,r5
8000b44e:	5f 9a       	srgt	r10
8000b450:	6e 0c       	ld.w	r12,r7[0x0]
8000b452:	6e 48       	ld.w	r8,r7[0x10]
8000b454:	10 3c       	cp.w	r12,r8
8000b456:	5f b8       	srhi	r8
8000b458:	f5 e8 00 08 	and	r8,r10,r8
8000b45c:	30 0a       	mov	r10,0
8000b45e:	f4 08 18 00 	cp.b	r8,r10
8000b462:	c0 d0       	breq	8000b47c <__sfvwrite_r+0x23c>
8000b464:	06 9b       	mov	r11,r3
8000b466:	0a 9a       	mov	r10,r5
8000b468:	cc 9c       	rcall	8000b5fa <memmove>
8000b46a:	6e 08       	ld.w	r8,r7[0x0]
8000b46c:	0a 08       	add	r8,r5
8000b46e:	0e 9b       	mov	r11,r7
8000b470:	8f 08       	st.w	r7[0x0],r8
8000b472:	40 1c       	lddsp	r12,sp[0x4]
8000b474:	fe b0 fc ae 	rcall	8000add0 <_fflush_r>
8000b478:	c1 70       	breq	8000b4a6 <__sfvwrite_r+0x266>
8000b47a:	c2 58       	rjmp	8000b4c4 <__sfvwrite_r+0x284>
8000b47c:	12 34       	cp.w	r4,r9
8000b47e:	c0 a5       	brlt	8000b492 <__sfvwrite_r+0x252>
8000b480:	6e a8       	ld.w	r8,r7[0x28]
8000b482:	06 9a       	mov	r10,r3
8000b484:	6e 8b       	ld.w	r11,r7[0x20]
8000b486:	40 1c       	lddsp	r12,sp[0x4]
8000b488:	5d 18       	icall	r8
8000b48a:	18 95       	mov	r5,r12
8000b48c:	e0 89 00 0d 	brgt	8000b4a6 <__sfvwrite_r+0x266>
8000b490:	c1 a8       	rjmp	8000b4c4 <__sfvwrite_r+0x284>
8000b492:	08 9a       	mov	r10,r4
8000b494:	06 9b       	mov	r11,r3
8000b496:	cb 2c       	rcall	8000b5fa <memmove>
8000b498:	6e 08       	ld.w	r8,r7[0x0]
8000b49a:	08 08       	add	r8,r4
8000b49c:	08 95       	mov	r5,r4
8000b49e:	8f 08       	st.w	r7[0x0],r8
8000b4a0:	6e 28       	ld.w	r8,r7[0x8]
8000b4a2:	08 18       	sub	r8,r4
8000b4a4:	8f 28       	st.w	r7[0x8],r8
8000b4a6:	0a 16       	sub	r6,r5
8000b4a8:	c0 71       	brne	8000b4b6 <__sfvwrite_r+0x276>
8000b4aa:	0e 9b       	mov	r11,r7
8000b4ac:	40 1c       	lddsp	r12,sp[0x4]
8000b4ae:	fe b0 fc 91 	rcall	8000add0 <_fflush_r>
8000b4b2:	c0 91       	brne	8000b4c4 <__sfvwrite_r+0x284>
8000b4b4:	50 06       	stdsp	sp[0x0],r6
8000b4b6:	64 28       	ld.w	r8,r2[0x8]
8000b4b8:	0a 18       	sub	r8,r5
8000b4ba:	85 28       	st.w	r2[0x8],r8
8000b4bc:	c0 90       	breq	8000b4ce <__sfvwrite_r+0x28e>
8000b4be:	0a 11       	sub	r1,r5
8000b4c0:	0a 03       	add	r3,r5
8000b4c2:	ca 4b       	rjmp	8000b40a <__sfvwrite_r+0x1ca>
8000b4c4:	8e 68       	ld.sh	r8,r7[0xc]
8000b4c6:	a7 a8       	sbr	r8,0x6
8000b4c8:	ae 68       	st.h	r7[0xc],r8
8000b4ca:	3f fc       	mov	r12,-1
8000b4cc:	c0 28       	rjmp	8000b4d0 <__sfvwrite_r+0x290>
8000b4ce:	30 0c       	mov	r12,0
8000b4d0:	2f dd       	sub	sp,-12
8000b4d2:	d8 32       	popm	r0-r7,pc

8000b4d4 <_fwalk>:
8000b4d4:	d4 31       	pushm	r0-r7,lr
8000b4d6:	30 05       	mov	r5,0
8000b4d8:	16 91       	mov	r1,r11
8000b4da:	f8 c7 ff 28 	sub	r7,r12,-216
8000b4de:	0a 92       	mov	r2,r5
8000b4e0:	fe b0 fc fe 	rcall	8000aedc <__sfp_lock_acquire>
8000b4e4:	3f f3       	mov	r3,-1
8000b4e6:	c1 68       	rjmp	8000b512 <_fwalk+0x3e>
8000b4e8:	6e 26       	ld.w	r6,r7[0x8]
8000b4ea:	6e 14       	ld.w	r4,r7[0x4]
8000b4ec:	2f 46       	sub	r6,-12
8000b4ee:	c0 c8       	rjmp	8000b506 <_fwalk+0x32>
8000b4f0:	8c 08       	ld.sh	r8,r6[0x0]
8000b4f2:	e4 08 19 00 	cp.h	r8,r2
8000b4f6:	c0 70       	breq	8000b504 <_fwalk+0x30>
8000b4f8:	8c 18       	ld.sh	r8,r6[0x2]
8000b4fa:	e6 08 19 00 	cp.h	r8,r3
8000b4fe:	c0 30       	breq	8000b504 <_fwalk+0x30>
8000b500:	5d 11       	icall	r1
8000b502:	18 45       	or	r5,r12
8000b504:	2a 46       	sub	r6,-92
8000b506:	20 14       	sub	r4,1
8000b508:	ec cc 00 0c 	sub	r12,r6,12
8000b50c:	58 04       	cp.w	r4,0
8000b50e:	cf 14       	brge	8000b4f0 <_fwalk+0x1c>
8000b510:	6e 07       	ld.w	r7,r7[0x0]
8000b512:	58 07       	cp.w	r7,0
8000b514:	ce a1       	brne	8000b4e8 <_fwalk+0x14>
8000b516:	fe b0 fc e4 	rcall	8000aede <__sfp_lock_release>
8000b51a:	0a 9c       	mov	r12,r5
8000b51c:	d8 32       	popm	r0-r7,pc
8000b51e:	d7 03       	nop

8000b520 <_localeconv_r>:
8000b520:	fe cc d3 b4 	sub	r12,pc,-11340
8000b524:	5e fc       	retal	r12
8000b526:	d7 03       	nop

8000b528 <__smakebuf_r>:
8000b528:	d4 21       	pushm	r4-r7,lr
8000b52a:	20 fd       	sub	sp,60
8000b52c:	96 68       	ld.sh	r8,r11[0xc]
8000b52e:	16 97       	mov	r7,r11
8000b530:	18 96       	mov	r6,r12
8000b532:	e2 18 00 02 	andl	r8,0x2,COH
8000b536:	c3 d1       	brne	8000b5b0 <__smakebuf_r+0x88>
8000b538:	96 7b       	ld.sh	r11,r11[0xe]
8000b53a:	f0 0b 19 00 	cp.h	r11,r8
8000b53e:	c0 55       	brlt	8000b548 <__smakebuf_r+0x20>
8000b540:	1a 9a       	mov	r10,sp
8000b542:	e0 a0 04 81 	rcall	8000be44 <_fstat_r>
8000b546:	c0 f4       	brge	8000b564 <__smakebuf_r+0x3c>
8000b548:	8e 65       	ld.sh	r5,r7[0xc]
8000b54a:	0a 98       	mov	r8,r5
8000b54c:	ab b8       	sbr	r8,0xb
8000b54e:	e2 15 00 80 	andl	r5,0x80,COH
8000b552:	ae 68       	st.h	r7[0xc],r8
8000b554:	30 04       	mov	r4,0
8000b556:	e0 68 04 00 	mov	r8,1024
8000b55a:	f9 b5 01 40 	movne	r5,64
8000b55e:	f0 05 17 00 	moveq	r5,r8
8000b562:	c1 c8       	rjmp	8000b59a <__smakebuf_r+0x72>
8000b564:	40 18       	lddsp	r8,sp[0x4]
8000b566:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b56a:	e0 48 20 00 	cp.w	r8,8192
8000b56e:	5f 04       	sreq	r4
8000b570:	e0 48 80 00 	cp.w	r8,32768
8000b574:	c0 e1       	brne	8000b590 <__smakebuf_r+0x68>
8000b576:	6e b9       	ld.w	r9,r7[0x2c]
8000b578:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b57c:	10 39       	cp.w	r9,r8
8000b57e:	c0 91       	brne	8000b590 <__smakebuf_r+0x68>
8000b580:	8e 68       	ld.sh	r8,r7[0xc]
8000b582:	e0 65 04 00 	mov	r5,1024
8000b586:	ab a8       	sbr	r8,0xa
8000b588:	ef 45 00 50 	st.w	r7[80],r5
8000b58c:	ae 68       	st.h	r7[0xc],r8
8000b58e:	c0 68       	rjmp	8000b59a <__smakebuf_r+0x72>
8000b590:	8e 68       	ld.sh	r8,r7[0xc]
8000b592:	e0 65 04 00 	mov	r5,1024
8000b596:	ab b8       	sbr	r8,0xb
8000b598:	ae 68       	st.h	r7[0xc],r8
8000b59a:	0a 9b       	mov	r11,r5
8000b59c:	0c 9c       	mov	r12,r6
8000b59e:	fe b0 df 35 	rcall	80007408 <_malloc_r>
8000b5a2:	8e 68       	ld.sh	r8,r7[0xc]
8000b5a4:	c0 d1       	brne	8000b5be <__smakebuf_r+0x96>
8000b5a6:	ed b8 00 09 	bld	r8,0x9
8000b5aa:	c1 b0       	breq	8000b5e0 <__smakebuf_r+0xb8>
8000b5ac:	a1 b8       	sbr	r8,0x1
8000b5ae:	ae 68       	st.h	r7[0xc],r8
8000b5b0:	ee c8 ff b9 	sub	r8,r7,-71
8000b5b4:	8f 48       	st.w	r7[0x10],r8
8000b5b6:	8f 08       	st.w	r7[0x0],r8
8000b5b8:	30 18       	mov	r8,1
8000b5ba:	8f 58       	st.w	r7[0x14],r8
8000b5bc:	c1 28       	rjmp	8000b5e0 <__smakebuf_r+0xb8>
8000b5be:	a7 b8       	sbr	r8,0x7
8000b5c0:	8f 4c       	st.w	r7[0x10],r12
8000b5c2:	ae 68       	st.h	r7[0xc],r8
8000b5c4:	8f 55       	st.w	r7[0x14],r5
8000b5c6:	fe c8 06 e6 	sub	r8,pc,1766
8000b5ca:	8f 0c       	st.w	r7[0x0],r12
8000b5cc:	8d a8       	st.w	r6[0x28],r8
8000b5ce:	58 04       	cp.w	r4,0
8000b5d0:	c0 80       	breq	8000b5e0 <__smakebuf_r+0xb8>
8000b5d2:	8e 7c       	ld.sh	r12,r7[0xe]
8000b5d4:	fe b0 e3 94 	rcall	80007cfc <isatty>
8000b5d8:	c0 40       	breq	8000b5e0 <__smakebuf_r+0xb8>
8000b5da:	8e 68       	ld.sh	r8,r7[0xc]
8000b5dc:	a1 a8       	sbr	r8,0x0
8000b5de:	ae 68       	st.h	r7[0xc],r8
8000b5e0:	2f 1d       	sub	sp,-60
8000b5e2:	d8 22       	popm	r4-r7,pc

8000b5e4 <memchr>:
8000b5e4:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b5e8:	c0 68       	rjmp	8000b5f4 <memchr+0x10>
8000b5ea:	20 1a       	sub	r10,1
8000b5ec:	19 88       	ld.ub	r8,r12[0x0]
8000b5ee:	16 38       	cp.w	r8,r11
8000b5f0:	5e 0c       	reteq	r12
8000b5f2:	2f fc       	sub	r12,-1
8000b5f4:	58 0a       	cp.w	r10,0
8000b5f6:	cf a1       	brne	8000b5ea <memchr+0x6>
8000b5f8:	5e fa       	retal	r10

8000b5fa <memmove>:
8000b5fa:	d4 01       	pushm	lr
8000b5fc:	18 3b       	cp.w	r11,r12
8000b5fe:	c1 92       	brcc	8000b630 <memmove+0x36>
8000b600:	f6 0a 00 09 	add	r9,r11,r10
8000b604:	12 3c       	cp.w	r12,r9
8000b606:	c1 52       	brcc	8000b630 <memmove+0x36>
8000b608:	f8 0a 00 0b 	add	r11,r12,r10
8000b60c:	30 08       	mov	r8,0
8000b60e:	c0 68       	rjmp	8000b61a <memmove+0x20>
8000b610:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b614:	20 1a       	sub	r10,1
8000b616:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b61a:	20 18       	sub	r8,1
8000b61c:	58 0a       	cp.w	r10,0
8000b61e:	cf 91       	brne	8000b610 <memmove+0x16>
8000b620:	d8 02       	popm	pc
8000b622:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b626:	20 1a       	sub	r10,1
8000b628:	f8 08 0b 09 	st.b	r12[r8],r9
8000b62c:	2f f8       	sub	r8,-1
8000b62e:	c0 28       	rjmp	8000b632 <memmove+0x38>
8000b630:	30 08       	mov	r8,0
8000b632:	58 0a       	cp.w	r10,0
8000b634:	cf 71       	brne	8000b622 <memmove+0x28>
8000b636:	d8 02       	popm	pc

8000b638 <__hi0bits>:
8000b638:	18 98       	mov	r8,r12
8000b63a:	e0 1c 00 00 	andl	r12,0x0
8000b63e:	f0 09 15 10 	lsl	r9,r8,0x10
8000b642:	58 0c       	cp.w	r12,0
8000b644:	f2 08 17 00 	moveq	r8,r9
8000b648:	f9 bc 00 10 	moveq	r12,16
8000b64c:	f9 bc 01 00 	movne	r12,0
8000b650:	10 9a       	mov	r10,r8
8000b652:	f0 09 15 08 	lsl	r9,r8,0x8
8000b656:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b65a:	f7 bc 00 f8 	subeq	r12,-8
8000b65e:	f2 08 17 00 	moveq	r8,r9
8000b662:	10 9a       	mov	r10,r8
8000b664:	f0 09 15 04 	lsl	r9,r8,0x4
8000b668:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b66c:	f7 bc 00 fc 	subeq	r12,-4
8000b670:	f2 08 17 00 	moveq	r8,r9
8000b674:	10 9a       	mov	r10,r8
8000b676:	f0 09 15 02 	lsl	r9,r8,0x2
8000b67a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b67e:	f7 bc 00 fe 	subeq	r12,-2
8000b682:	f2 08 17 00 	moveq	r8,r9
8000b686:	58 08       	cp.w	r8,0
8000b688:	5e 5c       	retlt	r12
8000b68a:	ed b8 00 1e 	bld	r8,0x1e
8000b68e:	f9 bc 01 20 	movne	r12,32
8000b692:	f7 bc 00 ff 	subeq	r12,-1
8000b696:	5e fc       	retal	r12

8000b698 <__lo0bits>:
8000b698:	18 99       	mov	r9,r12
8000b69a:	78 08       	ld.w	r8,r12[0x0]
8000b69c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b6a0:	c1 50       	breq	8000b6ca <__lo0bits+0x32>
8000b6a2:	ed b8 00 00 	bld	r8,0x0
8000b6a6:	c0 21       	brne	8000b6aa <__lo0bits+0x12>
8000b6a8:	5e fd       	retal	0
8000b6aa:	10 9b       	mov	r11,r8
8000b6ac:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b6b0:	e2 1b 00 02 	andl	r11,0x2,COH
8000b6b4:	a3 88       	lsr	r8,0x2
8000b6b6:	58 0b       	cp.w	r11,0
8000b6b8:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b6bc:	f9 bc 01 01 	movne	r12,1
8000b6c0:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b6c4:	f9 bc 00 02 	moveq	r12,2
8000b6c8:	5e fc       	retal	r12
8000b6ca:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b6ce:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b6d2:	58 0a       	cp.w	r10,0
8000b6d4:	f6 08 17 00 	moveq	r8,r11
8000b6d8:	f9 bc 00 10 	moveq	r12,16
8000b6dc:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b6e0:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b6e4:	58 0b       	cp.w	r11,0
8000b6e6:	f7 bc 00 f8 	subeq	r12,-8
8000b6ea:	f4 08 17 00 	moveq	r8,r10
8000b6ee:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b6f2:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b6f6:	58 0b       	cp.w	r11,0
8000b6f8:	f7 bc 00 fc 	subeq	r12,-4
8000b6fc:	f4 08 17 00 	moveq	r8,r10
8000b700:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b704:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b708:	58 0b       	cp.w	r11,0
8000b70a:	f7 bc 00 fe 	subeq	r12,-2
8000b70e:	f4 08 17 00 	moveq	r8,r10
8000b712:	ed b8 00 00 	bld	r8,0x0
8000b716:	c0 60       	breq	8000b722 <__lo0bits+0x8a>
8000b718:	a1 98       	lsr	r8,0x1
8000b71a:	c0 31       	brne	8000b720 <__lo0bits+0x88>
8000b71c:	32 0c       	mov	r12,32
8000b71e:	5e fc       	retal	r12
8000b720:	2f fc       	sub	r12,-1
8000b722:	93 08       	st.w	r9[0x0],r8
8000b724:	5e fc       	retal	r12

8000b726 <__mcmp>:
8000b726:	d4 01       	pushm	lr
8000b728:	18 98       	mov	r8,r12
8000b72a:	76 49       	ld.w	r9,r11[0x10]
8000b72c:	78 4c       	ld.w	r12,r12[0x10]
8000b72e:	12 1c       	sub	r12,r9
8000b730:	c1 31       	brne	8000b756 <__mcmp+0x30>
8000b732:	2f b9       	sub	r9,-5
8000b734:	a3 69       	lsl	r9,0x2
8000b736:	12 0b       	add	r11,r9
8000b738:	f0 09 00 09 	add	r9,r8,r9
8000b73c:	2e c8       	sub	r8,-20
8000b73e:	13 4e       	ld.w	lr,--r9
8000b740:	17 4a       	ld.w	r10,--r11
8000b742:	14 3e       	cp.w	lr,r10
8000b744:	c0 60       	breq	8000b750 <__mcmp+0x2a>
8000b746:	f9 bc 03 ff 	movlo	r12,-1
8000b74a:	f9 bc 02 01 	movhs	r12,1
8000b74e:	d8 02       	popm	pc
8000b750:	10 39       	cp.w	r9,r8
8000b752:	fe 9b ff f6 	brhi	8000b73e <__mcmp+0x18>
8000b756:	d8 02       	popm	pc

8000b758 <_Bfree>:
8000b758:	d4 21       	pushm	r4-r7,lr
8000b75a:	18 97       	mov	r7,r12
8000b75c:	16 95       	mov	r5,r11
8000b75e:	78 96       	ld.w	r6,r12[0x24]
8000b760:	58 06       	cp.w	r6,0
8000b762:	c0 91       	brne	8000b774 <_Bfree+0x1c>
8000b764:	31 0c       	mov	r12,16
8000b766:	fe b0 de 49 	rcall	800073f8 <malloc>
8000b76a:	99 36       	st.w	r12[0xc],r6
8000b76c:	8f 9c       	st.w	r7[0x24],r12
8000b76e:	99 16       	st.w	r12[0x4],r6
8000b770:	99 26       	st.w	r12[0x8],r6
8000b772:	99 06       	st.w	r12[0x0],r6
8000b774:	58 05       	cp.w	r5,0
8000b776:	c0 90       	breq	8000b788 <_Bfree+0x30>
8000b778:	6a 19       	ld.w	r9,r5[0x4]
8000b77a:	6e 98       	ld.w	r8,r7[0x24]
8000b77c:	70 38       	ld.w	r8,r8[0xc]
8000b77e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b782:	8b 0a       	st.w	r5[0x0],r10
8000b784:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b788:	d8 22       	popm	r4-r7,pc
8000b78a:	d7 03       	nop

8000b78c <_Balloc>:
8000b78c:	d4 21       	pushm	r4-r7,lr
8000b78e:	18 97       	mov	r7,r12
8000b790:	16 96       	mov	r6,r11
8000b792:	78 95       	ld.w	r5,r12[0x24]
8000b794:	58 05       	cp.w	r5,0
8000b796:	c0 91       	brne	8000b7a8 <_Balloc+0x1c>
8000b798:	31 0c       	mov	r12,16
8000b79a:	fe b0 de 2f 	rcall	800073f8 <malloc>
8000b79e:	99 35       	st.w	r12[0xc],r5
8000b7a0:	8f 9c       	st.w	r7[0x24],r12
8000b7a2:	99 15       	st.w	r12[0x4],r5
8000b7a4:	99 25       	st.w	r12[0x8],r5
8000b7a6:	99 05       	st.w	r12[0x0],r5
8000b7a8:	6e 95       	ld.w	r5,r7[0x24]
8000b7aa:	6a 38       	ld.w	r8,r5[0xc]
8000b7ac:	58 08       	cp.w	r8,0
8000b7ae:	c0 b1       	brne	8000b7c4 <_Balloc+0x38>
8000b7b0:	31 0a       	mov	r10,16
8000b7b2:	30 4b       	mov	r11,4
8000b7b4:	0e 9c       	mov	r12,r7
8000b7b6:	e0 a0 02 a7 	rcall	8000bd04 <_calloc_r>
8000b7ba:	8b 3c       	st.w	r5[0xc],r12
8000b7bc:	6e 98       	ld.w	r8,r7[0x24]
8000b7be:	70 3c       	ld.w	r12,r8[0xc]
8000b7c0:	58 0c       	cp.w	r12,0
8000b7c2:	c1 b0       	breq	8000b7f8 <_Balloc+0x6c>
8000b7c4:	6e 98       	ld.w	r8,r7[0x24]
8000b7c6:	70 38       	ld.w	r8,r8[0xc]
8000b7c8:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b7cc:	70 0c       	ld.w	r12,r8[0x0]
8000b7ce:	58 0c       	cp.w	r12,0
8000b7d0:	c0 40       	breq	8000b7d8 <_Balloc+0x4c>
8000b7d2:	78 09       	ld.w	r9,r12[0x0]
8000b7d4:	91 09       	st.w	r8[0x0],r9
8000b7d6:	c0 e8       	rjmp	8000b7f2 <_Balloc+0x66>
8000b7d8:	0e 9c       	mov	r12,r7
8000b7da:	30 17       	mov	r7,1
8000b7dc:	0e 9b       	mov	r11,r7
8000b7de:	ee 06 09 47 	lsl	r7,r7,r6
8000b7e2:	ee ca ff fb 	sub	r10,r7,-5
8000b7e6:	a3 6a       	lsl	r10,0x2
8000b7e8:	e0 a0 02 8e 	rcall	8000bd04 <_calloc_r>
8000b7ec:	c0 60       	breq	8000b7f8 <_Balloc+0x6c>
8000b7ee:	99 16       	st.w	r12[0x4],r6
8000b7f0:	99 27       	st.w	r12[0x8],r7
8000b7f2:	30 08       	mov	r8,0
8000b7f4:	99 38       	st.w	r12[0xc],r8
8000b7f6:	99 48       	st.w	r12[0x10],r8
8000b7f8:	d8 22       	popm	r4-r7,pc
8000b7fa:	d7 03       	nop

8000b7fc <__d2b>:
8000b7fc:	d4 31       	pushm	r0-r7,lr
8000b7fe:	20 2d       	sub	sp,8
8000b800:	16 93       	mov	r3,r11
8000b802:	12 96       	mov	r6,r9
8000b804:	10 95       	mov	r5,r8
8000b806:	14 92       	mov	r2,r10
8000b808:	30 1b       	mov	r11,1
8000b80a:	cc 1f       	rcall	8000b78c <_Balloc>
8000b80c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b810:	50 09       	stdsp	sp[0x0],r9
8000b812:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b816:	b5 a9       	sbr	r9,0x14
8000b818:	f0 01 16 14 	lsr	r1,r8,0x14
8000b81c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b820:	18 94       	mov	r4,r12
8000b822:	58 02       	cp.w	r2,0
8000b824:	c1 d0       	breq	8000b85e <__d2b+0x62>
8000b826:	fa cc ff f8 	sub	r12,sp,-8
8000b82a:	18 d2       	st.w	--r12,r2
8000b82c:	c3 6f       	rcall	8000b698 <__lo0bits>
8000b82e:	40 18       	lddsp	r8,sp[0x4]
8000b830:	c0 d0       	breq	8000b84a <__d2b+0x4e>
8000b832:	40 09       	lddsp	r9,sp[0x0]
8000b834:	f8 0a 11 20 	rsub	r10,r12,32
8000b838:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b83c:	f5 e8 10 08 	or	r8,r10,r8
8000b840:	89 58       	st.w	r4[0x14],r8
8000b842:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b846:	50 09       	stdsp	sp[0x0],r9
8000b848:	c0 28       	rjmp	8000b84c <__d2b+0x50>
8000b84a:	89 58       	st.w	r4[0x14],r8
8000b84c:	40 08       	lddsp	r8,sp[0x0]
8000b84e:	58 08       	cp.w	r8,0
8000b850:	f9 b3 01 02 	movne	r3,2
8000b854:	f9 b3 00 01 	moveq	r3,1
8000b858:	89 68       	st.w	r4[0x18],r8
8000b85a:	89 43       	st.w	r4[0x10],r3
8000b85c:	c0 88       	rjmp	8000b86c <__d2b+0x70>
8000b85e:	1a 9c       	mov	r12,sp
8000b860:	c1 cf       	rcall	8000b698 <__lo0bits>
8000b862:	30 13       	mov	r3,1
8000b864:	40 08       	lddsp	r8,sp[0x0]
8000b866:	2e 0c       	sub	r12,-32
8000b868:	89 43       	st.w	r4[0x10],r3
8000b86a:	89 58       	st.w	r4[0x14],r8
8000b86c:	58 01       	cp.w	r1,0
8000b86e:	c0 90       	breq	8000b880 <__d2b+0x84>
8000b870:	e2 c1 04 33 	sub	r1,r1,1075
8000b874:	18 01       	add	r1,r12
8000b876:	8d 01       	st.w	r6[0x0],r1
8000b878:	f8 0c 11 35 	rsub	r12,r12,53
8000b87c:	8b 0c       	st.w	r5[0x0],r12
8000b87e:	c0 c8       	rjmp	8000b896 <__d2b+0x9a>
8000b880:	e6 c8 ff fc 	sub	r8,r3,-4
8000b884:	f8 cc 04 32 	sub	r12,r12,1074
8000b888:	a5 73       	lsl	r3,0x5
8000b88a:	8d 0c       	st.w	r6[0x0],r12
8000b88c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b890:	cd 4e       	rcall	8000b638 <__hi0bits>
8000b892:	18 13       	sub	r3,r12
8000b894:	8b 03       	st.w	r5[0x0],r3
8000b896:	08 9c       	mov	r12,r4
8000b898:	2f ed       	sub	sp,-8
8000b89a:	d8 32       	popm	r0-r7,pc

8000b89c <__mdiff>:
8000b89c:	d4 31       	pushm	r0-r7,lr
8000b89e:	74 48       	ld.w	r8,r10[0x10]
8000b8a0:	76 45       	ld.w	r5,r11[0x10]
8000b8a2:	16 97       	mov	r7,r11
8000b8a4:	14 96       	mov	r6,r10
8000b8a6:	10 15       	sub	r5,r8
8000b8a8:	c1 31       	brne	8000b8ce <__mdiff+0x32>
8000b8aa:	2f b8       	sub	r8,-5
8000b8ac:	ee ce ff ec 	sub	lr,r7,-20
8000b8b0:	a3 68       	lsl	r8,0x2
8000b8b2:	f4 08 00 0b 	add	r11,r10,r8
8000b8b6:	ee 08 00 08 	add	r8,r7,r8
8000b8ba:	11 4a       	ld.w	r10,--r8
8000b8bc:	17 49       	ld.w	r9,--r11
8000b8be:	12 3a       	cp.w	r10,r9
8000b8c0:	c0 30       	breq	8000b8c6 <__mdiff+0x2a>
8000b8c2:	c0 e2       	brcc	8000b8de <__mdiff+0x42>
8000b8c4:	c0 78       	rjmp	8000b8d2 <__mdiff+0x36>
8000b8c6:	1c 38       	cp.w	r8,lr
8000b8c8:	fe 9b ff f9 	brhi	8000b8ba <__mdiff+0x1e>
8000b8cc:	c4 98       	rjmp	8000b95e <__mdiff+0xc2>
8000b8ce:	58 05       	cp.w	r5,0
8000b8d0:	c0 64       	brge	8000b8dc <__mdiff+0x40>
8000b8d2:	0e 98       	mov	r8,r7
8000b8d4:	30 15       	mov	r5,1
8000b8d6:	0c 97       	mov	r7,r6
8000b8d8:	10 96       	mov	r6,r8
8000b8da:	c0 28       	rjmp	8000b8de <__mdiff+0x42>
8000b8dc:	30 05       	mov	r5,0
8000b8de:	6e 1b       	ld.w	r11,r7[0x4]
8000b8e0:	c5 6f       	rcall	8000b78c <_Balloc>
8000b8e2:	6e 49       	ld.w	r9,r7[0x10]
8000b8e4:	6c 44       	ld.w	r4,r6[0x10]
8000b8e6:	99 35       	st.w	r12[0xc],r5
8000b8e8:	2f b4       	sub	r4,-5
8000b8ea:	f2 c5 ff fb 	sub	r5,r9,-5
8000b8ee:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b8f2:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b8f6:	2e c6       	sub	r6,-20
8000b8f8:	2e c7       	sub	r7,-20
8000b8fa:	f8 c8 ff ec 	sub	r8,r12,-20
8000b8fe:	30 0a       	mov	r10,0
8000b900:	0f 0e       	ld.w	lr,r7++
8000b902:	0d 0b       	ld.w	r11,r6++
8000b904:	fc 02 16 10 	lsr	r2,lr,0x10
8000b908:	f6 03 16 10 	lsr	r3,r11,0x10
8000b90c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b910:	e4 03 01 03 	sub	r3,r2,r3
8000b914:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b918:	fc 0b 01 0b 	sub	r11,lr,r11
8000b91c:	f6 0a 00 0a 	add	r10,r11,r10
8000b920:	b0 1a       	st.h	r8[0x2],r10
8000b922:	b1 4a       	asr	r10,0x10
8000b924:	e6 0a 00 0a 	add	r10,r3,r10
8000b928:	b0 0a       	st.h	r8[0x0],r10
8000b92a:	2f c8       	sub	r8,-4
8000b92c:	b1 4a       	asr	r10,0x10
8000b92e:	08 36       	cp.w	r6,r4
8000b930:	ce 83       	brcs	8000b900 <__mdiff+0x64>
8000b932:	c0 d8       	rjmp	8000b94c <__mdiff+0xb0>
8000b934:	0f 0b       	ld.w	r11,r7++
8000b936:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b93a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b93e:	16 0a       	add	r10,r11
8000b940:	b0 1a       	st.h	r8[0x2],r10
8000b942:	b1 4a       	asr	r10,0x10
8000b944:	1c 0a       	add	r10,lr
8000b946:	b0 0a       	st.h	r8[0x0],r10
8000b948:	2f c8       	sub	r8,-4
8000b94a:	b1 4a       	asr	r10,0x10
8000b94c:	0a 37       	cp.w	r7,r5
8000b94e:	cf 33       	brcs	8000b934 <__mdiff+0x98>
8000b950:	c0 28       	rjmp	8000b954 <__mdiff+0xb8>
8000b952:	20 19       	sub	r9,1
8000b954:	11 4a       	ld.w	r10,--r8
8000b956:	58 0a       	cp.w	r10,0
8000b958:	cf d0       	breq	8000b952 <__mdiff+0xb6>
8000b95a:	99 49       	st.w	r12[0x10],r9
8000b95c:	d8 32       	popm	r0-r7,pc
8000b95e:	30 0b       	mov	r11,0
8000b960:	c1 6f       	rcall	8000b78c <_Balloc>
8000b962:	30 18       	mov	r8,1
8000b964:	99 48       	st.w	r12[0x10],r8
8000b966:	30 08       	mov	r8,0
8000b968:	99 58       	st.w	r12[0x14],r8
8000b96a:	d8 32       	popm	r0-r7,pc

8000b96c <__lshift>:
8000b96c:	d4 31       	pushm	r0-r7,lr
8000b96e:	16 97       	mov	r7,r11
8000b970:	76 46       	ld.w	r6,r11[0x10]
8000b972:	f4 02 14 05 	asr	r2,r10,0x5
8000b976:	2f f6       	sub	r6,-1
8000b978:	14 93       	mov	r3,r10
8000b97a:	18 94       	mov	r4,r12
8000b97c:	04 06       	add	r6,r2
8000b97e:	76 1b       	ld.w	r11,r11[0x4]
8000b980:	6e 28       	ld.w	r8,r7[0x8]
8000b982:	c0 38       	rjmp	8000b988 <__lshift+0x1c>
8000b984:	2f fb       	sub	r11,-1
8000b986:	a1 78       	lsl	r8,0x1
8000b988:	10 36       	cp.w	r6,r8
8000b98a:	fe 99 ff fd 	brgt	8000b984 <__lshift+0x18>
8000b98e:	08 9c       	mov	r12,r4
8000b990:	cf ee       	rcall	8000b78c <_Balloc>
8000b992:	30 09       	mov	r9,0
8000b994:	18 95       	mov	r5,r12
8000b996:	f8 c8 ff ec 	sub	r8,r12,-20
8000b99a:	12 9a       	mov	r10,r9
8000b99c:	c0 38       	rjmp	8000b9a2 <__lshift+0x36>
8000b99e:	10 aa       	st.w	r8++,r10
8000b9a0:	2f f9       	sub	r9,-1
8000b9a2:	04 39       	cp.w	r9,r2
8000b9a4:	cf d5       	brlt	8000b99e <__lshift+0x32>
8000b9a6:	6e 4b       	ld.w	r11,r7[0x10]
8000b9a8:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b9ac:	2f bb       	sub	r11,-5
8000b9ae:	ee c9 ff ec 	sub	r9,r7,-20
8000b9b2:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b9b6:	58 03       	cp.w	r3,0
8000b9b8:	c1 30       	breq	8000b9de <__lshift+0x72>
8000b9ba:	e6 0c 11 20 	rsub	r12,r3,32
8000b9be:	30 0a       	mov	r10,0
8000b9c0:	72 02       	ld.w	r2,r9[0x0]
8000b9c2:	e4 03 09 42 	lsl	r2,r2,r3
8000b9c6:	04 4a       	or	r10,r2
8000b9c8:	10 aa       	st.w	r8++,r10
8000b9ca:	13 0a       	ld.w	r10,r9++
8000b9cc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b9d0:	16 39       	cp.w	r9,r11
8000b9d2:	cf 73       	brcs	8000b9c0 <__lshift+0x54>
8000b9d4:	91 0a       	st.w	r8[0x0],r10
8000b9d6:	58 0a       	cp.w	r10,0
8000b9d8:	c0 70       	breq	8000b9e6 <__lshift+0x7a>
8000b9da:	2f f6       	sub	r6,-1
8000b9dc:	c0 58       	rjmp	8000b9e6 <__lshift+0x7a>
8000b9de:	13 0a       	ld.w	r10,r9++
8000b9e0:	10 aa       	st.w	r8++,r10
8000b9e2:	16 39       	cp.w	r9,r11
8000b9e4:	cf d3       	brcs	8000b9de <__lshift+0x72>
8000b9e6:	08 9c       	mov	r12,r4
8000b9e8:	20 16       	sub	r6,1
8000b9ea:	0e 9b       	mov	r11,r7
8000b9ec:	8b 46       	st.w	r5[0x10],r6
8000b9ee:	cb 5e       	rcall	8000b758 <_Bfree>
8000b9f0:	0a 9c       	mov	r12,r5
8000b9f2:	d8 32       	popm	r0-r7,pc

8000b9f4 <__multiply>:
8000b9f4:	d4 31       	pushm	r0-r7,lr
8000b9f6:	20 2d       	sub	sp,8
8000b9f8:	76 49       	ld.w	r9,r11[0x10]
8000b9fa:	74 48       	ld.w	r8,r10[0x10]
8000b9fc:	16 96       	mov	r6,r11
8000b9fe:	14 95       	mov	r5,r10
8000ba00:	10 39       	cp.w	r9,r8
8000ba02:	ec 08 17 50 	movlt	r8,r6
8000ba06:	ea 06 17 50 	movlt	r6,r5
8000ba0a:	f0 05 17 50 	movlt	r5,r8
8000ba0e:	6c 28       	ld.w	r8,r6[0x8]
8000ba10:	76 43       	ld.w	r3,r11[0x10]
8000ba12:	74 42       	ld.w	r2,r10[0x10]
8000ba14:	76 1b       	ld.w	r11,r11[0x4]
8000ba16:	e4 03 00 07 	add	r7,r2,r3
8000ba1a:	10 37       	cp.w	r7,r8
8000ba1c:	f7 bb 09 ff 	subgt	r11,-1
8000ba20:	cb 6e       	rcall	8000b78c <_Balloc>
8000ba22:	ee c4 ff fb 	sub	r4,r7,-5
8000ba26:	f8 c9 ff ec 	sub	r9,r12,-20
8000ba2a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ba2e:	30 0a       	mov	r10,0
8000ba30:	12 98       	mov	r8,r9
8000ba32:	c0 28       	rjmp	8000ba36 <__multiply+0x42>
8000ba34:	10 aa       	st.w	r8++,r10
8000ba36:	08 38       	cp.w	r8,r4
8000ba38:	cf e3       	brcs	8000ba34 <__multiply+0x40>
8000ba3a:	2f b3       	sub	r3,-5
8000ba3c:	2f b2       	sub	r2,-5
8000ba3e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ba42:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ba46:	ec cb ff ec 	sub	r11,r6,-20
8000ba4a:	50 12       	stdsp	sp[0x4],r2
8000ba4c:	ea ca ff ec 	sub	r10,r5,-20
8000ba50:	c4 48       	rjmp	8000bad8 <__multiply+0xe4>
8000ba52:	94 95       	ld.uh	r5,r10[0x2]
8000ba54:	58 05       	cp.w	r5,0
8000ba56:	c2 00       	breq	8000ba96 <__multiply+0xa2>
8000ba58:	12 98       	mov	r8,r9
8000ba5a:	16 96       	mov	r6,r11
8000ba5c:	30 0e       	mov	lr,0
8000ba5e:	50 09       	stdsp	sp[0x0],r9
8000ba60:	0d 02       	ld.w	r2,r6++
8000ba62:	e4 00 16 10 	lsr	r0,r2,0x10
8000ba66:	70 01       	ld.w	r1,r8[0x0]
8000ba68:	70 09       	ld.w	r9,r8[0x0]
8000ba6a:	b1 81       	lsr	r1,0x10
8000ba6c:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ba70:	e0 05 03 41 	mac	r1,r0,r5
8000ba74:	ab 32       	mul	r2,r5
8000ba76:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ba7a:	00 02       	add	r2,r0
8000ba7c:	e4 0e 00 0e 	add	lr,r2,lr
8000ba80:	b0 1e       	st.h	r8[0x2],lr
8000ba82:	b1 8e       	lsr	lr,0x10
8000ba84:	1c 01       	add	r1,lr
8000ba86:	b0 01       	st.h	r8[0x0],r1
8000ba88:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ba8c:	2f c8       	sub	r8,-4
8000ba8e:	06 36       	cp.w	r6,r3
8000ba90:	ce 83       	brcs	8000ba60 <__multiply+0x6c>
8000ba92:	40 09       	lddsp	r9,sp[0x0]
8000ba94:	91 0e       	st.w	r8[0x0],lr
8000ba96:	94 86       	ld.uh	r6,r10[0x0]
8000ba98:	58 06       	cp.w	r6,0
8000ba9a:	c1 d0       	breq	8000bad4 <__multiply+0xe0>
8000ba9c:	72 02       	ld.w	r2,r9[0x0]
8000ba9e:	12 98       	mov	r8,r9
8000baa0:	16 9e       	mov	lr,r11
8000baa2:	30 05       	mov	r5,0
8000baa4:	b0 12       	st.h	r8[0x2],r2
8000baa6:	1d 01       	ld.w	r1,lr++
8000baa8:	90 82       	ld.uh	r2,r8[0x0]
8000baaa:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000baae:	ad 30       	mul	r0,r6
8000bab0:	e0 02 00 02 	add	r2,r0,r2
8000bab4:	e4 05 00 05 	add	r5,r2,r5
8000bab8:	b0 05       	st.h	r8[0x0],r5
8000baba:	b1 85       	lsr	r5,0x10
8000babc:	b1 81       	lsr	r1,0x10
8000babe:	2f c8       	sub	r8,-4
8000bac0:	ad 31       	mul	r1,r6
8000bac2:	90 92       	ld.uh	r2,r8[0x2]
8000bac4:	e2 02 00 02 	add	r2,r1,r2
8000bac8:	0a 02       	add	r2,r5
8000baca:	e4 05 16 10 	lsr	r5,r2,0x10
8000bace:	06 3e       	cp.w	lr,r3
8000bad0:	ce a3       	brcs	8000baa4 <__multiply+0xb0>
8000bad2:	91 02       	st.w	r8[0x0],r2
8000bad4:	2f ca       	sub	r10,-4
8000bad6:	2f c9       	sub	r9,-4
8000bad8:	40 18       	lddsp	r8,sp[0x4]
8000bada:	10 3a       	cp.w	r10,r8
8000badc:	cb b3       	brcs	8000ba52 <__multiply+0x5e>
8000bade:	c0 28       	rjmp	8000bae2 <__multiply+0xee>
8000bae0:	20 17       	sub	r7,1
8000bae2:	58 07       	cp.w	r7,0
8000bae4:	e0 8a 00 05 	brle	8000baee <__multiply+0xfa>
8000bae8:	09 48       	ld.w	r8,--r4
8000baea:	58 08       	cp.w	r8,0
8000baec:	cf a0       	breq	8000bae0 <__multiply+0xec>
8000baee:	99 47       	st.w	r12[0x10],r7
8000baf0:	2f ed       	sub	sp,-8
8000baf2:	d8 32       	popm	r0-r7,pc

8000baf4 <__i2b>:
8000baf4:	d4 21       	pushm	r4-r7,lr
8000baf6:	16 97       	mov	r7,r11
8000baf8:	30 1b       	mov	r11,1
8000bafa:	c4 9e       	rcall	8000b78c <_Balloc>
8000bafc:	30 19       	mov	r9,1
8000bafe:	99 57       	st.w	r12[0x14],r7
8000bb00:	99 49       	st.w	r12[0x10],r9
8000bb02:	d8 22       	popm	r4-r7,pc

8000bb04 <__multadd>:
8000bb04:	d4 31       	pushm	r0-r7,lr
8000bb06:	30 08       	mov	r8,0
8000bb08:	12 95       	mov	r5,r9
8000bb0a:	16 97       	mov	r7,r11
8000bb0c:	18 96       	mov	r6,r12
8000bb0e:	76 44       	ld.w	r4,r11[0x10]
8000bb10:	f6 c9 ff ec 	sub	r9,r11,-20
8000bb14:	72 0b       	ld.w	r11,r9[0x0]
8000bb16:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bb1a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bb1e:	f4 0c 02 4c 	mul	r12,r10,r12
8000bb22:	f4 0b 03 45 	mac	r5,r10,r11
8000bb26:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bb2a:	b1 85       	lsr	r5,0x10
8000bb2c:	18 05       	add	r5,r12
8000bb2e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bb32:	f8 0b 00 0b 	add	r11,r12,r11
8000bb36:	12 ab       	st.w	r9++,r11
8000bb38:	2f f8       	sub	r8,-1
8000bb3a:	b1 85       	lsr	r5,0x10
8000bb3c:	08 38       	cp.w	r8,r4
8000bb3e:	ce b5       	brlt	8000bb14 <__multadd+0x10>
8000bb40:	58 05       	cp.w	r5,0
8000bb42:	c1 c0       	breq	8000bb7a <__multadd+0x76>
8000bb44:	6e 28       	ld.w	r8,r7[0x8]
8000bb46:	10 34       	cp.w	r4,r8
8000bb48:	c1 35       	brlt	8000bb6e <__multadd+0x6a>
8000bb4a:	6e 1b       	ld.w	r11,r7[0x4]
8000bb4c:	0c 9c       	mov	r12,r6
8000bb4e:	2f fb       	sub	r11,-1
8000bb50:	c1 ee       	rcall	8000b78c <_Balloc>
8000bb52:	6e 4a       	ld.w	r10,r7[0x10]
8000bb54:	ee cb ff f4 	sub	r11,r7,-12
8000bb58:	18 93       	mov	r3,r12
8000bb5a:	2f ea       	sub	r10,-2
8000bb5c:	2f 4c       	sub	r12,-12
8000bb5e:	a3 6a       	lsl	r10,0x2
8000bb60:	fe b0 de 70 	rcall	80007840 <memcpy>
8000bb64:	0e 9b       	mov	r11,r7
8000bb66:	0c 9c       	mov	r12,r6
8000bb68:	fe b0 fd f8 	rcall	8000b758 <_Bfree>
8000bb6c:	06 97       	mov	r7,r3
8000bb6e:	e8 c8 ff ff 	sub	r8,r4,-1
8000bb72:	2f b4       	sub	r4,-5
8000bb74:	8f 48       	st.w	r7[0x10],r8
8000bb76:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bb7a:	0e 9c       	mov	r12,r7
8000bb7c:	d8 32       	popm	r0-r7,pc
8000bb7e:	d7 03       	nop

8000bb80 <__pow5mult>:
8000bb80:	d4 31       	pushm	r0-r7,lr
8000bb82:	14 96       	mov	r6,r10
8000bb84:	18 97       	mov	r7,r12
8000bb86:	16 94       	mov	r4,r11
8000bb88:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bb8c:	c0 90       	breq	8000bb9e <__pow5mult+0x1e>
8000bb8e:	20 18       	sub	r8,1
8000bb90:	fe c9 d9 e8 	sub	r9,pc,-9752
8000bb94:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bb98:	30 09       	mov	r9,0
8000bb9a:	cb 5f       	rcall	8000bb04 <__multadd>
8000bb9c:	18 94       	mov	r4,r12
8000bb9e:	a3 46       	asr	r6,0x2
8000bba0:	c3 40       	breq	8000bc08 <__pow5mult+0x88>
8000bba2:	6e 95       	ld.w	r5,r7[0x24]
8000bba4:	58 05       	cp.w	r5,0
8000bba6:	c0 91       	brne	8000bbb8 <__pow5mult+0x38>
8000bba8:	31 0c       	mov	r12,16
8000bbaa:	fe b0 dc 27 	rcall	800073f8 <malloc>
8000bbae:	99 35       	st.w	r12[0xc],r5
8000bbb0:	8f 9c       	st.w	r7[0x24],r12
8000bbb2:	99 15       	st.w	r12[0x4],r5
8000bbb4:	99 25       	st.w	r12[0x8],r5
8000bbb6:	99 05       	st.w	r12[0x0],r5
8000bbb8:	6e 93       	ld.w	r3,r7[0x24]
8000bbba:	66 25       	ld.w	r5,r3[0x8]
8000bbbc:	58 05       	cp.w	r5,0
8000bbbe:	c0 c1       	brne	8000bbd6 <__pow5mult+0x56>
8000bbc0:	e0 6b 02 71 	mov	r11,625
8000bbc4:	0e 9c       	mov	r12,r7
8000bbc6:	c9 7f       	rcall	8000baf4 <__i2b>
8000bbc8:	87 2c       	st.w	r3[0x8],r12
8000bbca:	30 08       	mov	r8,0
8000bbcc:	18 95       	mov	r5,r12
8000bbce:	99 08       	st.w	r12[0x0],r8
8000bbd0:	c0 38       	rjmp	8000bbd6 <__pow5mult+0x56>
8000bbd2:	06 9c       	mov	r12,r3
8000bbd4:	18 95       	mov	r5,r12
8000bbd6:	ed b6 00 00 	bld	r6,0x0
8000bbda:	c0 b1       	brne	8000bbf0 <__pow5mult+0x70>
8000bbdc:	08 9b       	mov	r11,r4
8000bbde:	0a 9a       	mov	r10,r5
8000bbe0:	0e 9c       	mov	r12,r7
8000bbe2:	c0 9f       	rcall	8000b9f4 <__multiply>
8000bbe4:	08 9b       	mov	r11,r4
8000bbe6:	18 93       	mov	r3,r12
8000bbe8:	0e 9c       	mov	r12,r7
8000bbea:	06 94       	mov	r4,r3
8000bbec:	fe b0 fd b6 	rcall	8000b758 <_Bfree>
8000bbf0:	a1 56       	asr	r6,0x1
8000bbf2:	c0 b0       	breq	8000bc08 <__pow5mult+0x88>
8000bbf4:	6a 03       	ld.w	r3,r5[0x0]
8000bbf6:	58 03       	cp.w	r3,0
8000bbf8:	ce d1       	brne	8000bbd2 <__pow5mult+0x52>
8000bbfa:	0a 9a       	mov	r10,r5
8000bbfc:	0a 9b       	mov	r11,r5
8000bbfe:	0e 9c       	mov	r12,r7
8000bc00:	cf ae       	rcall	8000b9f4 <__multiply>
8000bc02:	8b 0c       	st.w	r5[0x0],r12
8000bc04:	99 03       	st.w	r12[0x0],r3
8000bc06:	ce 7b       	rjmp	8000bbd4 <__pow5mult+0x54>
8000bc08:	08 9c       	mov	r12,r4
8000bc0a:	d8 32       	popm	r0-r7,pc

8000bc0c <__isinfd>:
8000bc0c:	14 98       	mov	r8,r10
8000bc0e:	fc 19 7f f0 	movh	r9,0x7ff0
8000bc12:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc16:	f0 0b 11 00 	rsub	r11,r8,0
8000bc1a:	f7 e8 10 08 	or	r8,r11,r8
8000bc1e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bc22:	f2 08 01 08 	sub	r8,r9,r8
8000bc26:	f0 0c 11 00 	rsub	r12,r8,0
8000bc2a:	f9 e8 10 08 	or	r8,r12,r8
8000bc2e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bc32:	2f fc       	sub	r12,-1
8000bc34:	5e fc       	retal	r12

8000bc36 <__isnand>:
8000bc36:	14 98       	mov	r8,r10
8000bc38:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc3c:	f0 0c 11 00 	rsub	r12,r8,0
8000bc40:	10 4c       	or	r12,r8
8000bc42:	fc 18 7f f0 	movh	r8,0x7ff0
8000bc46:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bc4a:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc4e:	bf 9c       	lsr	r12,0x1f
8000bc50:	5e fc       	retal	r12
8000bc52:	d7 03       	nop

8000bc54 <__sclose>:
8000bc54:	d4 01       	pushm	lr
8000bc56:	96 7b       	ld.sh	r11,r11[0xe]
8000bc58:	c8 2c       	rcall	8000bd5c <_close_r>
8000bc5a:	d8 02       	popm	pc

8000bc5c <__sseek>:
8000bc5c:	d4 21       	pushm	r4-r7,lr
8000bc5e:	16 97       	mov	r7,r11
8000bc60:	96 7b       	ld.sh	r11,r11[0xe]
8000bc62:	c0 3d       	rcall	8000be68 <_lseek_r>
8000bc64:	8e 68       	ld.sh	r8,r7[0xc]
8000bc66:	10 99       	mov	r9,r8
8000bc68:	ad c8       	cbr	r8,0xc
8000bc6a:	ad a9       	sbr	r9,0xc
8000bc6c:	5b fc       	cp.w	r12,-1
8000bc6e:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bc72:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bc76:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bc7a:	d8 22       	popm	r4-r7,pc

8000bc7c <__swrite>:
8000bc7c:	d4 21       	pushm	r4-r7,lr
8000bc7e:	96 68       	ld.sh	r8,r11[0xc]
8000bc80:	16 97       	mov	r7,r11
8000bc82:	14 95       	mov	r5,r10
8000bc84:	12 94       	mov	r4,r9
8000bc86:	e2 18 01 00 	andl	r8,0x100,COH
8000bc8a:	18 96       	mov	r6,r12
8000bc8c:	c0 50       	breq	8000bc96 <__swrite+0x1a>
8000bc8e:	30 29       	mov	r9,2
8000bc90:	30 0a       	mov	r10,0
8000bc92:	96 7b       	ld.sh	r11,r11[0xe]
8000bc94:	ce ac       	rcall	8000be68 <_lseek_r>
8000bc96:	8e 68       	ld.sh	r8,r7[0xc]
8000bc98:	ad c8       	cbr	r8,0xc
8000bc9a:	08 99       	mov	r9,r4
8000bc9c:	0a 9a       	mov	r10,r5
8000bc9e:	8e 7b       	ld.sh	r11,r7[0xe]
8000bca0:	0c 9c       	mov	r12,r6
8000bca2:	ae 68       	st.h	r7[0xc],r8
8000bca4:	c1 cc       	rcall	8000bcdc <_write_r>
8000bca6:	d8 22       	popm	r4-r7,pc

8000bca8 <__sread>:
8000bca8:	d4 21       	pushm	r4-r7,lr
8000bcaa:	16 97       	mov	r7,r11
8000bcac:	96 7b       	ld.sh	r11,r11[0xe]
8000bcae:	cf 1c       	rcall	8000be90 <_read_r>
8000bcb0:	c0 65       	brlt	8000bcbc <__sread+0x14>
8000bcb2:	6f 58       	ld.w	r8,r7[0x54]
8000bcb4:	18 08       	add	r8,r12
8000bcb6:	ef 48 00 54 	st.w	r7[84],r8
8000bcba:	d8 22       	popm	r4-r7,pc
8000bcbc:	8e 68       	ld.sh	r8,r7[0xc]
8000bcbe:	ad c8       	cbr	r8,0xc
8000bcc0:	ae 68       	st.h	r7[0xc],r8
8000bcc2:	d8 22       	popm	r4-r7,pc

8000bcc4 <strlen>:
8000bcc4:	30 09       	mov	r9,0
8000bcc6:	18 98       	mov	r8,r12
8000bcc8:	c0 28       	rjmp	8000bccc <strlen+0x8>
8000bcca:	2f f8       	sub	r8,-1
8000bccc:	11 8a       	ld.ub	r10,r8[0x0]
8000bcce:	f2 0a 18 00 	cp.b	r10,r9
8000bcd2:	cf c1       	brne	8000bcca <strlen+0x6>
8000bcd4:	f0 0c 01 0c 	sub	r12,r8,r12
8000bcd8:	5e fc       	retal	r12
8000bcda:	d7 03       	nop

8000bcdc <_write_r>:
8000bcdc:	d4 21       	pushm	r4-r7,lr
8000bcde:	16 98       	mov	r8,r11
8000bce0:	18 97       	mov	r7,r12
8000bce2:	10 9c       	mov	r12,r8
8000bce4:	30 08       	mov	r8,0
8000bce6:	14 9b       	mov	r11,r10
8000bce8:	e0 66 bf ec 	mov	r6,49132
8000bcec:	12 9a       	mov	r10,r9
8000bcee:	8d 08       	st.w	r6[0x0],r8
8000bcf0:	fe b0 d1 72 	rcall	80005fd4 <_write>
8000bcf4:	5b fc       	cp.w	r12,-1
8000bcf6:	c0 51       	brne	8000bd00 <_write_r+0x24>
8000bcf8:	6c 08       	ld.w	r8,r6[0x0]
8000bcfa:	58 08       	cp.w	r8,0
8000bcfc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd00:	d8 22       	popm	r4-r7,pc
8000bd02:	d7 03       	nop

8000bd04 <_calloc_r>:
8000bd04:	d4 21       	pushm	r4-r7,lr
8000bd06:	f4 0b 02 4b 	mul	r11,r10,r11
8000bd0a:	fe b0 db 7f 	rcall	80007408 <_malloc_r>
8000bd0e:	18 97       	mov	r7,r12
8000bd10:	c2 30       	breq	8000bd56 <_calloc_r+0x52>
8000bd12:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bd16:	e0 1a ff fc 	andl	r10,0xfffc
8000bd1a:	20 4a       	sub	r10,4
8000bd1c:	e0 4a 00 24 	cp.w	r10,36
8000bd20:	e0 8b 00 18 	brhi	8000bd50 <_calloc_r+0x4c>
8000bd24:	18 98       	mov	r8,r12
8000bd26:	59 3a       	cp.w	r10,19
8000bd28:	e0 88 00 0f 	brls	8000bd46 <_calloc_r+0x42>
8000bd2c:	30 09       	mov	r9,0
8000bd2e:	10 a9       	st.w	r8++,r9
8000bd30:	10 a9       	st.w	r8++,r9
8000bd32:	59 ba       	cp.w	r10,27
8000bd34:	e0 88 00 09 	brls	8000bd46 <_calloc_r+0x42>
8000bd38:	10 a9       	st.w	r8++,r9
8000bd3a:	10 a9       	st.w	r8++,r9
8000bd3c:	e0 4a 00 24 	cp.w	r10,36
8000bd40:	c0 31       	brne	8000bd46 <_calloc_r+0x42>
8000bd42:	10 a9       	st.w	r8++,r9
8000bd44:	10 a9       	st.w	r8++,r9
8000bd46:	30 09       	mov	r9,0
8000bd48:	10 a9       	st.w	r8++,r9
8000bd4a:	91 19       	st.w	r8[0x4],r9
8000bd4c:	91 09       	st.w	r8[0x0],r9
8000bd4e:	c0 48       	rjmp	8000bd56 <_calloc_r+0x52>
8000bd50:	30 0b       	mov	r11,0
8000bd52:	fe b0 de 1b 	rcall	80007988 <memset>
8000bd56:	0e 9c       	mov	r12,r7
8000bd58:	d8 22       	popm	r4-r7,pc
8000bd5a:	d7 03       	nop

8000bd5c <_close_r>:
8000bd5c:	d4 21       	pushm	r4-r7,lr
8000bd5e:	30 08       	mov	r8,0
8000bd60:	18 97       	mov	r7,r12
8000bd62:	e0 66 bf ec 	mov	r6,49132
8000bd66:	16 9c       	mov	r12,r11
8000bd68:	8d 08       	st.w	r6[0x0],r8
8000bd6a:	fe b0 df b5 	rcall	80007cd4 <_close>
8000bd6e:	5b fc       	cp.w	r12,-1
8000bd70:	c0 51       	brne	8000bd7a <_close_r+0x1e>
8000bd72:	6c 08       	ld.w	r8,r6[0x0]
8000bd74:	58 08       	cp.w	r8,0
8000bd76:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd7a:	d8 22       	popm	r4-r7,pc

8000bd7c <_fclose_r>:
8000bd7c:	d4 21       	pushm	r4-r7,lr
8000bd7e:	18 96       	mov	r6,r12
8000bd80:	16 97       	mov	r7,r11
8000bd82:	58 0b       	cp.w	r11,0
8000bd84:	c0 31       	brne	8000bd8a <_fclose_r+0xe>
8000bd86:	16 95       	mov	r5,r11
8000bd88:	c5 38       	rjmp	8000be2e <_fclose_r+0xb2>
8000bd8a:	fe b0 f8 a9 	rcall	8000aedc <__sfp_lock_acquire>
8000bd8e:	58 06       	cp.w	r6,0
8000bd90:	c0 70       	breq	8000bd9e <_fclose_r+0x22>
8000bd92:	6c 68       	ld.w	r8,r6[0x18]
8000bd94:	58 08       	cp.w	r8,0
8000bd96:	c0 41       	brne	8000bd9e <_fclose_r+0x22>
8000bd98:	0c 9c       	mov	r12,r6
8000bd9a:	fe b0 f8 f3 	rcall	8000af80 <__sinit>
8000bd9e:	fe c8 dc 9a 	sub	r8,pc,-9062
8000bda2:	10 37       	cp.w	r7,r8
8000bda4:	c0 31       	brne	8000bdaa <_fclose_r+0x2e>
8000bda6:	6c 07       	ld.w	r7,r6[0x0]
8000bda8:	c0 c8       	rjmp	8000bdc0 <_fclose_r+0x44>
8000bdaa:	fe c8 dc 86 	sub	r8,pc,-9082
8000bdae:	10 37       	cp.w	r7,r8
8000bdb0:	c0 31       	brne	8000bdb6 <_fclose_r+0x3a>
8000bdb2:	6c 17       	ld.w	r7,r6[0x4]
8000bdb4:	c0 68       	rjmp	8000bdc0 <_fclose_r+0x44>
8000bdb6:	fe c8 dc 72 	sub	r8,pc,-9102
8000bdba:	10 37       	cp.w	r7,r8
8000bdbc:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bdc0:	8e 69       	ld.sh	r9,r7[0xc]
8000bdc2:	30 08       	mov	r8,0
8000bdc4:	f0 09 19 00 	cp.h	r9,r8
8000bdc8:	c0 51       	brne	8000bdd2 <_fclose_r+0x56>
8000bdca:	fe b0 f8 8a 	rcall	8000aede <__sfp_lock_release>
8000bdce:	30 05       	mov	r5,0
8000bdd0:	c2 f8       	rjmp	8000be2e <_fclose_r+0xb2>
8000bdd2:	0e 9b       	mov	r11,r7
8000bdd4:	0c 9c       	mov	r12,r6
8000bdd6:	fe b0 f7 fd 	rcall	8000add0 <_fflush_r>
8000bdda:	6e c8       	ld.w	r8,r7[0x30]
8000bddc:	18 95       	mov	r5,r12
8000bdde:	58 08       	cp.w	r8,0
8000bde0:	c0 60       	breq	8000bdec <_fclose_r+0x70>
8000bde2:	6e 8b       	ld.w	r11,r7[0x20]
8000bde4:	0c 9c       	mov	r12,r6
8000bde6:	5d 18       	icall	r8
8000bde8:	f9 b5 05 ff 	movlt	r5,-1
8000bdec:	8e 68       	ld.sh	r8,r7[0xc]
8000bdee:	ed b8 00 07 	bld	r8,0x7
8000bdf2:	c0 51       	brne	8000bdfc <_fclose_r+0x80>
8000bdf4:	6e 4b       	ld.w	r11,r7[0x10]
8000bdf6:	0c 9c       	mov	r12,r6
8000bdf8:	fe b0 f9 5e 	rcall	8000b0b4 <_free_r>
8000bdfc:	6e db       	ld.w	r11,r7[0x34]
8000bdfe:	58 0b       	cp.w	r11,0
8000be00:	c0 a0       	breq	8000be14 <_fclose_r+0x98>
8000be02:	ee c8 ff bc 	sub	r8,r7,-68
8000be06:	10 3b       	cp.w	r11,r8
8000be08:	c0 40       	breq	8000be10 <_fclose_r+0x94>
8000be0a:	0c 9c       	mov	r12,r6
8000be0c:	fe b0 f9 54 	rcall	8000b0b4 <_free_r>
8000be10:	30 08       	mov	r8,0
8000be12:	8f d8       	st.w	r7[0x34],r8
8000be14:	6f 2b       	ld.w	r11,r7[0x48]
8000be16:	58 0b       	cp.w	r11,0
8000be18:	c0 70       	breq	8000be26 <_fclose_r+0xaa>
8000be1a:	0c 9c       	mov	r12,r6
8000be1c:	fe b0 f9 4c 	rcall	8000b0b4 <_free_r>
8000be20:	30 08       	mov	r8,0
8000be22:	ef 48 00 48 	st.w	r7[72],r8
8000be26:	30 08       	mov	r8,0
8000be28:	ae 68       	st.h	r7[0xc],r8
8000be2a:	fe b0 f8 5a 	rcall	8000aede <__sfp_lock_release>
8000be2e:	0a 9c       	mov	r12,r5
8000be30:	d8 22       	popm	r4-r7,pc
8000be32:	d7 03       	nop

8000be34 <fclose>:
8000be34:	d4 01       	pushm	lr
8000be36:	e0 68 0a 3c 	mov	r8,2620
8000be3a:	18 9b       	mov	r11,r12
8000be3c:	70 0c       	ld.w	r12,r8[0x0]
8000be3e:	c9 ff       	rcall	8000bd7c <_fclose_r>
8000be40:	d8 02       	popm	pc
8000be42:	d7 03       	nop

8000be44 <_fstat_r>:
8000be44:	d4 21       	pushm	r4-r7,lr
8000be46:	16 98       	mov	r8,r11
8000be48:	18 97       	mov	r7,r12
8000be4a:	10 9c       	mov	r12,r8
8000be4c:	30 08       	mov	r8,0
8000be4e:	e0 66 bf ec 	mov	r6,49132
8000be52:	14 9b       	mov	r11,r10
8000be54:	8d 08       	st.w	r6[0x0],r8
8000be56:	fe b0 df 67 	rcall	80007d24 <_fstat>
8000be5a:	5b fc       	cp.w	r12,-1
8000be5c:	c0 51       	brne	8000be66 <_fstat_r+0x22>
8000be5e:	6c 08       	ld.w	r8,r6[0x0]
8000be60:	58 08       	cp.w	r8,0
8000be62:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be66:	d8 22       	popm	r4-r7,pc

8000be68 <_lseek_r>:
8000be68:	d4 21       	pushm	r4-r7,lr
8000be6a:	16 98       	mov	r8,r11
8000be6c:	18 97       	mov	r7,r12
8000be6e:	10 9c       	mov	r12,r8
8000be70:	30 08       	mov	r8,0
8000be72:	14 9b       	mov	r11,r10
8000be74:	e0 66 bf ec 	mov	r6,49132
8000be78:	12 9a       	mov	r10,r9
8000be7a:	8d 08       	st.w	r6[0x0],r8
8000be7c:	fe b0 df 36 	rcall	80007ce8 <_lseek>
8000be80:	5b fc       	cp.w	r12,-1
8000be82:	c0 51       	brne	8000be8c <_lseek_r+0x24>
8000be84:	6c 08       	ld.w	r8,r6[0x0]
8000be86:	58 08       	cp.w	r8,0
8000be88:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be8c:	d8 22       	popm	r4-r7,pc
8000be8e:	d7 03       	nop

8000be90 <_read_r>:
8000be90:	d4 21       	pushm	r4-r7,lr
8000be92:	16 98       	mov	r8,r11
8000be94:	18 97       	mov	r7,r12
8000be96:	10 9c       	mov	r12,r8
8000be98:	30 08       	mov	r8,0
8000be9a:	14 9b       	mov	r11,r10
8000be9c:	e0 66 bf ec 	mov	r6,49132
8000bea0:	12 9a       	mov	r10,r9
8000bea2:	8d 08       	st.w	r6[0x0],r8
8000bea4:	fe b0 d0 78 	rcall	80005f94 <_read>
8000bea8:	5b fc       	cp.w	r12,-1
8000beaa:	c0 51       	brne	8000beb4 <_read_r+0x24>
8000beac:	6c 08       	ld.w	r8,r6[0x0]
8000beae:	58 08       	cp.w	r8,0
8000beb0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000beb4:	d8 22       	popm	r4-r7,pc
8000beb6:	d7 03       	nop

8000beb8 <__avr32_f64_mul>:
8000beb8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bebc:	e0 80 00 dc 	breq	8000c074 <__avr32_f64_mul_op1_zero>
8000bec0:	d4 21       	pushm	r4-r7,lr
8000bec2:	f7 e9 20 0e 	eor	lr,r11,r9
8000bec6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000beca:	30 15       	mov	r5,1
8000becc:	c4 30       	breq	8000bf52 <__avr32_f64_mul_op1_subnormal>
8000bece:	ab 6b       	lsl	r11,0xa
8000bed0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bed4:	ab 6a       	lsl	r10,0xa
8000bed6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000beda:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bede:	c5 c0       	breq	8000bf96 <__avr32_f64_mul_op2_subnormal>
8000bee0:	a1 78       	lsl	r8,0x1
8000bee2:	5c f9       	rol	r9
8000bee4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bee8:	e0 47 07 ff 	cp.w	r7,2047
8000beec:	c7 70       	breq	8000bfda <__avr32_f64_mul_op_nan_or_inf>
8000beee:	e0 46 07 ff 	cp.w	r6,2047
8000bef2:	c7 40       	breq	8000bfda <__avr32_f64_mul_op_nan_or_inf>
8000bef4:	ee 06 00 0c 	add	r12,r7,r6
8000bef8:	e0 2c 03 fe 	sub	r12,1022
8000befc:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bf00:	f4 09 07 44 	macu.d	r4,r10,r9
8000bf04:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bf08:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bf0c:	08 07       	add	r7,r4
8000bf0e:	f4 05 00 4a 	adc	r10,r10,r5
8000bf12:	5c 0b       	acr	r11
8000bf14:	ed bb 00 14 	bld	r11,0x14
8000bf18:	c0 50       	breq	8000bf22 <__avr32_f64_mul+0x6a>
8000bf1a:	a1 77       	lsl	r7,0x1
8000bf1c:	5c fa       	rol	r10
8000bf1e:	5c fb       	rol	r11
8000bf20:	20 1c       	sub	r12,1
8000bf22:	58 0c       	cp.w	r12,0
8000bf24:	e0 8a 00 6f 	brle	8000c002 <__avr32_f64_mul_res_subnormal>
8000bf28:	e0 4c 07 ff 	cp.w	r12,2047
8000bf2c:	e0 84 00 9c 	brge	8000c064 <__avr32_f64_mul_res_inf>
8000bf30:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bf34:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bf38:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bf3c:	ee 17 80 00 	eorh	r7,0x8000
8000bf40:	f1 b7 04 20 	satu	r7,0x1
8000bf44:	0e 0a       	add	r10,r7
8000bf46:	5c 0b       	acr	r11
8000bf48:	ed be 00 1f 	bld	lr,0x1f
8000bf4c:	ef bb 00 1f 	bst	r11,0x1f
8000bf50:	d8 22       	popm	r4-r7,pc

8000bf52 <__avr32_f64_mul_op1_subnormal>:
8000bf52:	e4 1b 00 0f 	andh	r11,0xf
8000bf56:	f4 0c 12 00 	clz	r12,r10
8000bf5a:	f6 06 12 00 	clz	r6,r11
8000bf5e:	f7 bc 03 e1 	sublo	r12,-31
8000bf62:	f8 06 17 30 	movlo	r6,r12
8000bf66:	f7 b6 02 01 	subhs	r6,1
8000bf6a:	e0 46 00 20 	cp.w	r6,32
8000bf6e:	c0 d4       	brge	8000bf88 <__avr32_f64_mul_op1_subnormal+0x36>
8000bf70:	ec 0c 11 20 	rsub	r12,r6,32
8000bf74:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf78:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bf7c:	18 4b       	or	r11,r12
8000bf7e:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf82:	20 b6       	sub	r6,11
8000bf84:	0c 17       	sub	r7,r6
8000bf86:	ca ab       	rjmp	8000beda <__avr32_f64_mul+0x22>
8000bf88:	f4 06 09 4b 	lsl	r11,r10,r6
8000bf8c:	c6 40       	breq	8000c054 <__avr32_f64_mul_res_zero>
8000bf8e:	30 0a       	mov	r10,0
8000bf90:	20 b6       	sub	r6,11
8000bf92:	0c 17       	sub	r7,r6
8000bf94:	ca 3b       	rjmp	8000beda <__avr32_f64_mul+0x22>

8000bf96 <__avr32_f64_mul_op2_subnormal>:
8000bf96:	e4 19 00 0f 	andh	r9,0xf
8000bf9a:	f0 0c 12 00 	clz	r12,r8
8000bf9e:	f2 05 12 00 	clz	r5,r9
8000bfa2:	f7 bc 03 ea 	sublo	r12,-22
8000bfa6:	f8 05 17 30 	movlo	r5,r12
8000bfaa:	f7 b5 02 0a 	subhs	r5,10
8000bfae:	e0 45 00 20 	cp.w	r5,32
8000bfb2:	c0 d4       	brge	8000bfcc <__avr32_f64_mul_op2_subnormal+0x36>
8000bfb4:	ea 0c 11 20 	rsub	r12,r5,32
8000bfb8:	f2 05 09 49 	lsl	r9,r9,r5
8000bfbc:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bfc0:	18 49       	or	r9,r12
8000bfc2:	f0 05 09 48 	lsl	r8,r8,r5
8000bfc6:	20 25       	sub	r5,2
8000bfc8:	0a 16       	sub	r6,r5
8000bfca:	c8 fb       	rjmp	8000bee8 <__avr32_f64_mul+0x30>
8000bfcc:	f0 05 09 49 	lsl	r9,r8,r5
8000bfd0:	c4 20       	breq	8000c054 <__avr32_f64_mul_res_zero>
8000bfd2:	30 08       	mov	r8,0
8000bfd4:	20 25       	sub	r5,2
8000bfd6:	0a 16       	sub	r6,r5
8000bfd8:	c8 8b       	rjmp	8000bee8 <__avr32_f64_mul+0x30>

8000bfda <__avr32_f64_mul_op_nan_or_inf>:
8000bfda:	e4 19 00 0f 	andh	r9,0xf
8000bfde:	e4 1b 00 0f 	andh	r11,0xf
8000bfe2:	14 4b       	or	r11,r10
8000bfe4:	10 49       	or	r9,r8
8000bfe6:	e0 47 07 ff 	cp.w	r7,2047
8000bfea:	c0 91       	brne	8000bffc <__avr32_f64_mul_op1_not_naninf>
8000bfec:	58 0b       	cp.w	r11,0
8000bfee:	c3 81       	brne	8000c05e <__avr32_f64_mul_res_nan>
8000bff0:	e0 46 07 ff 	cp.w	r6,2047
8000bff4:	c3 81       	brne	8000c064 <__avr32_f64_mul_res_inf>
8000bff6:	58 09       	cp.w	r9,0
8000bff8:	c3 60       	breq	8000c064 <__avr32_f64_mul_res_inf>
8000bffa:	c3 28       	rjmp	8000c05e <__avr32_f64_mul_res_nan>

8000bffc <__avr32_f64_mul_op1_not_naninf>:
8000bffc:	58 09       	cp.w	r9,0
8000bffe:	c3 30       	breq	8000c064 <__avr32_f64_mul_res_inf>
8000c000:	c2 f8       	rjmp	8000c05e <__avr32_f64_mul_res_nan>

8000c002 <__avr32_f64_mul_res_subnormal>:
8000c002:	5c 3c       	neg	r12
8000c004:	2f fc       	sub	r12,-1
8000c006:	f1 bc 04 c0 	satu	r12,0x6
8000c00a:	e0 4c 00 20 	cp.w	r12,32
8000c00e:	c1 14       	brge	8000c030 <__avr32_f64_mul_res_subnormal+0x2e>
8000c010:	f8 08 11 20 	rsub	r8,r12,32
8000c014:	0e 46       	or	r6,r7
8000c016:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c01a:	f4 08 09 49 	lsl	r9,r10,r8
8000c01e:	12 47       	or	r7,r9
8000c020:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c024:	f6 08 09 49 	lsl	r9,r11,r8
8000c028:	12 4a       	or	r10,r9
8000c02a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c02e:	c8 3b       	rjmp	8000bf34 <__avr32_f64_mul+0x7c>
8000c030:	f8 08 11 20 	rsub	r8,r12,32
8000c034:	f9 b9 00 00 	moveq	r9,0
8000c038:	c0 30       	breq	8000c03e <__avr32_f64_mul_res_subnormal+0x3c>
8000c03a:	f6 08 09 49 	lsl	r9,r11,r8
8000c03e:	0e 46       	or	r6,r7
8000c040:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c044:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c048:	f3 ea 10 07 	or	r7,r9,r10
8000c04c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c050:	30 0b       	mov	r11,0
8000c052:	c7 1b       	rjmp	8000bf34 <__avr32_f64_mul+0x7c>

8000c054 <__avr32_f64_mul_res_zero>:
8000c054:	1c 9b       	mov	r11,lr
8000c056:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c05a:	30 0a       	mov	r10,0
8000c05c:	d8 22       	popm	r4-r7,pc

8000c05e <__avr32_f64_mul_res_nan>:
8000c05e:	3f fb       	mov	r11,-1
8000c060:	3f fa       	mov	r10,-1
8000c062:	d8 22       	popm	r4-r7,pc

8000c064 <__avr32_f64_mul_res_inf>:
8000c064:	f0 6b 00 00 	mov	r11,-1048576
8000c068:	ed be 00 1f 	bld	lr,0x1f
8000c06c:	ef bb 00 1f 	bst	r11,0x1f
8000c070:	30 0a       	mov	r10,0
8000c072:	d8 22       	popm	r4-r7,pc

8000c074 <__avr32_f64_mul_op1_zero>:
8000c074:	f7 e9 20 0b 	eor	r11,r11,r9
8000c078:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c07c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c080:	e0 4c 07 ff 	cp.w	r12,2047
8000c084:	5e 1c       	retne	r12
8000c086:	3f fa       	mov	r10,-1
8000c088:	3f fb       	mov	r11,-1
8000c08a:	5e fc       	retal	r12

8000c08c <__avr32_f64_sub_from_add>:
8000c08c:	ee 19 80 00 	eorh	r9,0x8000

8000c090 <__avr32_f64_sub>:
8000c090:	f7 e9 20 0c 	eor	r12,r11,r9
8000c094:	e0 86 00 ca 	brmi	8000c228 <__avr32_f64_add_from_sub>
8000c098:	eb cd 40 e0 	pushm	r5-r7,lr
8000c09c:	16 9c       	mov	r12,r11
8000c09e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c0a2:	bf db       	cbr	r11,0x1f
8000c0a4:	bf d9       	cbr	r9,0x1f
8000c0a6:	10 3a       	cp.w	r10,r8
8000c0a8:	f2 0b 13 00 	cpc	r11,r9
8000c0ac:	c0 92       	brcc	8000c0be <__avr32_f64_sub+0x2e>
8000c0ae:	16 97       	mov	r7,r11
8000c0b0:	12 9b       	mov	r11,r9
8000c0b2:	0e 99       	mov	r9,r7
8000c0b4:	14 97       	mov	r7,r10
8000c0b6:	10 9a       	mov	r10,r8
8000c0b8:	0e 98       	mov	r8,r7
8000c0ba:	ee 1c 80 00 	eorh	r12,0x8000
8000c0be:	f6 07 16 14 	lsr	r7,r11,0x14
8000c0c2:	ab 7b       	lsl	r11,0xb
8000c0c4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c0c8:	ab 7a       	lsl	r10,0xb
8000c0ca:	bf bb       	sbr	r11,0x1f
8000c0cc:	f2 06 16 14 	lsr	r6,r9,0x14
8000c0d0:	c4 40       	breq	8000c158 <__avr32_f64_sub_opL_subnormal>
8000c0d2:	ab 79       	lsl	r9,0xb
8000c0d4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c0d8:	ab 78       	lsl	r8,0xb
8000c0da:	bf b9       	sbr	r9,0x1f

8000c0dc <__avr32_f64_sub_opL_subnormal_done>:
8000c0dc:	e0 47 07 ff 	cp.w	r7,2047
8000c0e0:	c4 f0       	breq	8000c17e <__avr32_f64_sub_opH_nan_or_inf>
8000c0e2:	0e 26       	rsub	r6,r7
8000c0e4:	c1 20       	breq	8000c108 <__avr32_f64_sub_shift_done>
8000c0e6:	ec 05 11 20 	rsub	r5,r6,32
8000c0ea:	e0 46 00 20 	cp.w	r6,32
8000c0ee:	c7 c2       	brcc	8000c1e6 <__avr32_f64_sub_longshift>
8000c0f0:	f0 05 09 4e 	lsl	lr,r8,r5
8000c0f4:	f2 05 09 45 	lsl	r5,r9,r5
8000c0f8:	f0 06 0a 48 	lsr	r8,r8,r6
8000c0fc:	f2 06 0a 49 	lsr	r9,r9,r6
8000c100:	0a 48       	or	r8,r5
8000c102:	58 0e       	cp.w	lr,0
8000c104:	5f 1e       	srne	lr
8000c106:	1c 48       	or	r8,lr

8000c108 <__avr32_f64_sub_shift_done>:
8000c108:	10 1a       	sub	r10,r8
8000c10a:	f6 09 01 4b 	sbc	r11,r11,r9
8000c10e:	f6 06 12 00 	clz	r6,r11
8000c112:	c0 e0       	breq	8000c12e <__avr32_f64_sub_longnormalize_done>
8000c114:	c7 83       	brcs	8000c204 <__avr32_f64_sub_longnormalize>
8000c116:	ec 0e 11 20 	rsub	lr,r6,32
8000c11a:	f6 06 09 4b 	lsl	r11,r11,r6
8000c11e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c122:	1c 4b       	or	r11,lr
8000c124:	f4 06 09 4a 	lsl	r10,r10,r6
8000c128:	0c 17       	sub	r7,r6
8000c12a:	e0 8a 00 39 	brle	8000c19c <__avr32_f64_sub_subnormal_result>

8000c12e <__avr32_f64_sub_longnormalize_done>:
8000c12e:	f4 09 15 15 	lsl	r9,r10,0x15
8000c132:	ab 9a       	lsr	r10,0xb
8000c134:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c138:	ab 9b       	lsr	r11,0xb
8000c13a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c13e:	18 4b       	or	r11,r12

8000c140 <__avr32_f64_sub_round>:
8000c140:	fc 17 80 00 	movh	r7,0x8000
8000c144:	ed ba 00 00 	bld	r10,0x0
8000c148:	f7 b7 01 ff 	subne	r7,-1
8000c14c:	0e 39       	cp.w	r9,r7
8000c14e:	5f 29       	srhs	r9
8000c150:	12 0a       	add	r10,r9
8000c152:	5c 0b       	acr	r11
8000c154:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c158 <__avr32_f64_sub_opL_subnormal>:
8000c158:	ab 79       	lsl	r9,0xb
8000c15a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c15e:	ab 78       	lsl	r8,0xb
8000c160:	f3 e8 10 0e 	or	lr,r9,r8
8000c164:	f9 b6 01 01 	movne	r6,1
8000c168:	ee 0e 11 00 	rsub	lr,r7,0
8000c16c:	f9 b7 00 01 	moveq	r7,1
8000c170:	ef bb 00 1f 	bst	r11,0x1f
8000c174:	f7 ea 10 0e 	or	lr,r11,r10
8000c178:	f9 b7 00 00 	moveq	r7,0
8000c17c:	cb 0b       	rjmp	8000c0dc <__avr32_f64_sub_opL_subnormal_done>

8000c17e <__avr32_f64_sub_opH_nan_or_inf>:
8000c17e:	bf db       	cbr	r11,0x1f
8000c180:	f7 ea 10 0e 	or	lr,r11,r10
8000c184:	c0 81       	brne	8000c194 <__avr32_f64_sub_return_nan>
8000c186:	e0 46 07 ff 	cp.w	r6,2047
8000c18a:	c0 50       	breq	8000c194 <__avr32_f64_sub_return_nan>
8000c18c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c190:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c194 <__avr32_f64_sub_return_nan>:
8000c194:	3f fa       	mov	r10,-1
8000c196:	3f fb       	mov	r11,-1
8000c198:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c19c <__avr32_f64_sub_subnormal_result>:
8000c19c:	5c 37       	neg	r7
8000c19e:	2f f7       	sub	r7,-1
8000c1a0:	f1 b7 04 c0 	satu	r7,0x6
8000c1a4:	e0 47 00 20 	cp.w	r7,32
8000c1a8:	c1 14       	brge	8000c1ca <__avr32_f64_sub_subnormal_result+0x2e>
8000c1aa:	ee 08 11 20 	rsub	r8,r7,32
8000c1ae:	f4 08 09 49 	lsl	r9,r10,r8
8000c1b2:	5f 16       	srne	r6
8000c1b4:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c1b8:	0c 4a       	or	r10,r6
8000c1ba:	f6 08 09 49 	lsl	r9,r11,r8
8000c1be:	f5 e9 10 0a 	or	r10,r10,r9
8000c1c2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c1c6:	30 07       	mov	r7,0
8000c1c8:	cb 3b       	rjmp	8000c12e <__avr32_f64_sub_longnormalize_done>
8000c1ca:	ee 08 11 40 	rsub	r8,r7,64
8000c1ce:	f6 08 09 49 	lsl	r9,r11,r8
8000c1d2:	14 49       	or	r9,r10
8000c1d4:	5f 16       	srne	r6
8000c1d6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c1da:	0c 4a       	or	r10,r6
8000c1dc:	30 0b       	mov	r11,0
8000c1de:	30 07       	mov	r7,0
8000c1e0:	ca 7b       	rjmp	8000c12e <__avr32_f64_sub_longnormalize_done>
8000c1e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1e6 <__avr32_f64_sub_longshift>:
8000c1e6:	f1 b6 04 c0 	satu	r6,0x6
8000c1ea:	f0 0e 17 00 	moveq	lr,r8
8000c1ee:	c0 40       	breq	8000c1f6 <__avr32_f64_sub_longshift+0x10>
8000c1f0:	f2 05 09 4e 	lsl	lr,r9,r5
8000c1f4:	10 4e       	or	lr,r8
8000c1f6:	f2 06 0a 48 	lsr	r8,r9,r6
8000c1fa:	30 09       	mov	r9,0
8000c1fc:	58 0e       	cp.w	lr,0
8000c1fe:	5f 1e       	srne	lr
8000c200:	1c 48       	or	r8,lr
8000c202:	c8 3b       	rjmp	8000c108 <__avr32_f64_sub_shift_done>

8000c204 <__avr32_f64_sub_longnormalize>:
8000c204:	f4 06 12 00 	clz	r6,r10
8000c208:	f9 b7 03 00 	movlo	r7,0
8000c20c:	f9 b6 03 00 	movlo	r6,0
8000c210:	f9 bc 03 00 	movlo	r12,0
8000c214:	f7 b6 02 e0 	subhs	r6,-32
8000c218:	f4 06 09 4b 	lsl	r11,r10,r6
8000c21c:	30 0a       	mov	r10,0
8000c21e:	0c 17       	sub	r7,r6
8000c220:	fe 9a ff be 	brle	8000c19c <__avr32_f64_sub_subnormal_result>
8000c224:	c8 5b       	rjmp	8000c12e <__avr32_f64_sub_longnormalize_done>
8000c226:	d7 03       	nop

8000c228 <__avr32_f64_add_from_sub>:
8000c228:	ee 19 80 00 	eorh	r9,0x8000

8000c22c <__avr32_f64_add>:
8000c22c:	f7 e9 20 0c 	eor	r12,r11,r9
8000c230:	fe 96 ff 2e 	brmi	8000c08c <__avr32_f64_sub_from_add>
8000c234:	eb cd 40 e0 	pushm	r5-r7,lr
8000c238:	16 9c       	mov	r12,r11
8000c23a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c23e:	bf db       	cbr	r11,0x1f
8000c240:	bf d9       	cbr	r9,0x1f
8000c242:	12 3b       	cp.w	r11,r9
8000c244:	c0 72       	brcc	8000c252 <__avr32_f64_add+0x26>
8000c246:	16 97       	mov	r7,r11
8000c248:	12 9b       	mov	r11,r9
8000c24a:	0e 99       	mov	r9,r7
8000c24c:	14 97       	mov	r7,r10
8000c24e:	10 9a       	mov	r10,r8
8000c250:	0e 98       	mov	r8,r7
8000c252:	30 0e       	mov	lr,0
8000c254:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c258:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c25c:	b5 ab       	sbr	r11,0x14
8000c25e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c262:	c6 20       	breq	8000c326 <__avr32_f64_add_op2_subnormal>
8000c264:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c268:	b5 a9       	sbr	r9,0x14
8000c26a:	e0 47 07 ff 	cp.w	r7,2047
8000c26e:	c2 80       	breq	8000c2be <__avr32_f64_add_opH_nan_or_inf>
8000c270:	0e 26       	rsub	r6,r7
8000c272:	c1 20       	breq	8000c296 <__avr32_f64_add_shift_done>
8000c274:	e0 46 00 36 	cp.w	r6,54
8000c278:	c1 52       	brcc	8000c2a2 <__avr32_f64_add_res_of_done>
8000c27a:	ec 05 11 20 	rsub	r5,r6,32
8000c27e:	e0 46 00 20 	cp.w	r6,32
8000c282:	c3 52       	brcc	8000c2ec <__avr32_f64_add_longshift>
8000c284:	f0 05 09 4e 	lsl	lr,r8,r5
8000c288:	f2 05 09 45 	lsl	r5,r9,r5
8000c28c:	f0 06 0a 48 	lsr	r8,r8,r6
8000c290:	f2 06 0a 49 	lsr	r9,r9,r6
8000c294:	0a 48       	or	r8,r5

8000c296 <__avr32_f64_add_shift_done>:
8000c296:	10 0a       	add	r10,r8
8000c298:	f6 09 00 4b 	adc	r11,r11,r9
8000c29c:	ed bb 00 15 	bld	r11,0x15
8000c2a0:	c3 40       	breq	8000c308 <__avr32_f64_add_res_of>

8000c2a2 <__avr32_f64_add_res_of_done>:
8000c2a2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c2a6:	18 4b       	or	r11,r12

8000c2a8 <__avr32_f64_add_round>:
8000c2a8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c2ac:	18 4e       	or	lr,r12
8000c2ae:	ee 1e 80 00 	eorh	lr,0x8000
8000c2b2:	f1 be 04 20 	satu	lr,0x1
8000c2b6:	1c 0a       	add	r10,lr
8000c2b8:	5c 0b       	acr	r11
8000c2ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2be <__avr32_f64_add_opH_nan_or_inf>:
8000c2be:	b5 cb       	cbr	r11,0x14
8000c2c0:	f7 ea 10 0e 	or	lr,r11,r10
8000c2c4:	c1 01       	brne	8000c2e4 <__avr32_f64_add_return_nan>
8000c2c6:	e0 46 07 ff 	cp.w	r6,2047
8000c2ca:	c0 30       	breq	8000c2d0 <__avr32_f64_add_opL_nan_or_inf>
8000c2cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2d0 <__avr32_f64_add_opL_nan_or_inf>:
8000c2d0:	b5 c9       	cbr	r9,0x14
8000c2d2:	f3 e8 10 0e 	or	lr,r9,r8
8000c2d6:	c0 71       	brne	8000c2e4 <__avr32_f64_add_return_nan>
8000c2d8:	30 0a       	mov	r10,0
8000c2da:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c2de:	18 4b       	or	r11,r12
8000c2e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2e4 <__avr32_f64_add_return_nan>:
8000c2e4:	3f fa       	mov	r10,-1
8000c2e6:	3f fb       	mov	r11,-1
8000c2e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2ec <__avr32_f64_add_longshift>:
8000c2ec:	f1 b6 04 c0 	satu	r6,0x6
8000c2f0:	f0 0e 17 00 	moveq	lr,r8
8000c2f4:	c0 60       	breq	8000c300 <__avr32_f64_add_longshift+0x14>
8000c2f6:	f2 05 09 4e 	lsl	lr,r9,r5
8000c2fa:	58 08       	cp.w	r8,0
8000c2fc:	5f 18       	srne	r8
8000c2fe:	10 4e       	or	lr,r8
8000c300:	f2 06 0a 48 	lsr	r8,r9,r6
8000c304:	30 09       	mov	r9,0
8000c306:	cc 8b       	rjmp	8000c296 <__avr32_f64_add_shift_done>

8000c308 <__avr32_f64_add_res_of>:
8000c308:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c30c:	a1 9b       	lsr	r11,0x1
8000c30e:	5d 0a       	ror	r10
8000c310:	5d 0e       	ror	lr
8000c312:	2f f7       	sub	r7,-1
8000c314:	e0 47 07 ff 	cp.w	r7,2047
8000c318:	f9 ba 00 00 	moveq	r10,0
8000c31c:	f9 bb 00 00 	moveq	r11,0
8000c320:	f9 be 00 00 	moveq	lr,0
8000c324:	cb fb       	rjmp	8000c2a2 <__avr32_f64_add_res_of_done>

8000c326 <__avr32_f64_add_op2_subnormal>:
8000c326:	30 16       	mov	r6,1
8000c328:	58 07       	cp.w	r7,0
8000c32a:	ca 01       	brne	8000c26a <__avr32_f64_add+0x3e>
8000c32c:	b5 cb       	cbr	r11,0x14
8000c32e:	10 0a       	add	r10,r8
8000c330:	f6 09 00 4b 	adc	r11,r11,r9
8000c334:	18 4b       	or	r11,r12
8000c336:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c33a:	d7 03       	nop

8000c33c <__avr32_f64_to_u32>:
8000c33c:	58 0b       	cp.w	r11,0
8000c33e:	5e 6d       	retmi	0

8000c340 <__avr32_f64_to_s32>:
8000c340:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c344:	b5 9c       	lsr	r12,0x15
8000c346:	e0 2c 03 ff 	sub	r12,1023
8000c34a:	5e 3d       	retlo	0
8000c34c:	f8 0c 11 1f 	rsub	r12,r12,31
8000c350:	16 99       	mov	r9,r11
8000c352:	ab 7b       	lsl	r11,0xb
8000c354:	bf bb       	sbr	r11,0x1f
8000c356:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c35a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c35e:	a1 79       	lsl	r9,0x1
8000c360:	5e 2b       	reths	r11
8000c362:	5c 3b       	neg	r11
8000c364:	5e fb       	retal	r11

8000c366 <__avr32_u32_to_f64>:
8000c366:	f8 cb 00 00 	sub	r11,r12,0
8000c36a:	30 0c       	mov	r12,0
8000c36c:	c0 38       	rjmp	8000c372 <__avr32_s32_to_f64+0x4>

8000c36e <__avr32_s32_to_f64>:
8000c36e:	18 9b       	mov	r11,r12
8000c370:	5c 4b       	abs	r11
8000c372:	30 0a       	mov	r10,0
8000c374:	5e 0b       	reteq	r11
8000c376:	d4 01       	pushm	lr
8000c378:	e0 69 04 1e 	mov	r9,1054
8000c37c:	f6 08 12 00 	clz	r8,r11
8000c380:	c1 70       	breq	8000c3ae <__avr32_s32_to_f64+0x40>
8000c382:	c0 c3       	brcs	8000c39a <__avr32_s32_to_f64+0x2c>
8000c384:	f0 0e 11 20 	rsub	lr,r8,32
8000c388:	f6 08 09 4b 	lsl	r11,r11,r8
8000c38c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c390:	1c 4b       	or	r11,lr
8000c392:	f4 08 09 4a 	lsl	r10,r10,r8
8000c396:	10 19       	sub	r9,r8
8000c398:	c0 b8       	rjmp	8000c3ae <__avr32_s32_to_f64+0x40>
8000c39a:	f4 08 12 00 	clz	r8,r10
8000c39e:	f9 b8 03 00 	movlo	r8,0
8000c3a2:	f7 b8 02 e0 	subhs	r8,-32
8000c3a6:	f4 08 09 4b 	lsl	r11,r10,r8
8000c3aa:	30 0a       	mov	r10,0
8000c3ac:	10 19       	sub	r9,r8
8000c3ae:	58 09       	cp.w	r9,0
8000c3b0:	e0 89 00 30 	brgt	8000c410 <__avr32_s32_to_f64+0xa2>
8000c3b4:	5c 39       	neg	r9
8000c3b6:	2f f9       	sub	r9,-1
8000c3b8:	e0 49 00 36 	cp.w	r9,54
8000c3bc:	c0 43       	brcs	8000c3c4 <__avr32_s32_to_f64+0x56>
8000c3be:	30 0b       	mov	r11,0
8000c3c0:	30 0a       	mov	r10,0
8000c3c2:	c2 68       	rjmp	8000c40e <__avr32_s32_to_f64+0xa0>
8000c3c4:	2f 69       	sub	r9,-10
8000c3c6:	f2 08 11 20 	rsub	r8,r9,32
8000c3ca:	e0 49 00 20 	cp.w	r9,32
8000c3ce:	c0 b2       	brcc	8000c3e4 <__avr32_s32_to_f64+0x76>
8000c3d0:	f4 08 09 4e 	lsl	lr,r10,r8
8000c3d4:	f6 08 09 48 	lsl	r8,r11,r8
8000c3d8:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c3dc:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c3e0:	10 4b       	or	r11,r8
8000c3e2:	c0 88       	rjmp	8000c3f2 <__avr32_s32_to_f64+0x84>
8000c3e4:	f6 08 09 4e 	lsl	lr,r11,r8
8000c3e8:	14 4e       	or	lr,r10
8000c3ea:	16 9a       	mov	r10,r11
8000c3ec:	30 0b       	mov	r11,0
8000c3ee:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c3f2:	ed ba 00 00 	bld	r10,0x0
8000c3f6:	c0 92       	brcc	8000c408 <__avr32_s32_to_f64+0x9a>
8000c3f8:	1c 7e       	tst	lr,lr
8000c3fa:	c0 41       	brne	8000c402 <__avr32_s32_to_f64+0x94>
8000c3fc:	ed ba 00 01 	bld	r10,0x1
8000c400:	c0 42       	brcc	8000c408 <__avr32_s32_to_f64+0x9a>
8000c402:	2f fa       	sub	r10,-1
8000c404:	f7 bb 02 ff 	subhs	r11,-1
8000c408:	5c fc       	rol	r12
8000c40a:	5d 0b       	ror	r11
8000c40c:	5d 0a       	ror	r10
8000c40e:	d8 02       	popm	pc
8000c410:	e0 68 03 ff 	mov	r8,1023
8000c414:	ed ba 00 0b 	bld	r10,0xb
8000c418:	f7 b8 00 ff 	subeq	r8,-1
8000c41c:	10 0a       	add	r10,r8
8000c41e:	5c 0b       	acr	r11
8000c420:	f7 b9 03 fe 	sublo	r9,-2
8000c424:	e0 49 07 ff 	cp.w	r9,2047
8000c428:	c0 55       	brlt	8000c432 <__avr32_s32_to_f64+0xc4>
8000c42a:	30 0a       	mov	r10,0
8000c42c:	fc 1b ff e0 	movh	r11,0xffe0
8000c430:	c0 c8       	rjmp	8000c448 <__floatsidf_return_op1>
8000c432:	ed bb 00 1f 	bld	r11,0x1f
8000c436:	f7 b9 01 01 	subne	r9,1
8000c43a:	ab 9a       	lsr	r10,0xb
8000c43c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c440:	a1 7b       	lsl	r11,0x1
8000c442:	ab 9b       	lsr	r11,0xb
8000c444:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c448 <__floatsidf_return_op1>:
8000c448:	a1 7c       	lsl	r12,0x1
8000c44a:	5d 0b       	ror	r11
8000c44c:	d8 02       	popm	pc

8000c44e <__avr32_f64_cmp_eq>:
8000c44e:	10 3a       	cp.w	r10,r8
8000c450:	f2 0b 13 00 	cpc	r11,r9
8000c454:	c0 80       	breq	8000c464 <__avr32_f64_cmp_eq+0x16>
8000c456:	a1 7b       	lsl	r11,0x1
8000c458:	a1 79       	lsl	r9,0x1
8000c45a:	14 4b       	or	r11,r10
8000c45c:	12 4b       	or	r11,r9
8000c45e:	10 4b       	or	r11,r8
8000c460:	5e 0f       	reteq	1
8000c462:	5e fd       	retal	0
8000c464:	a1 7b       	lsl	r11,0x1
8000c466:	fc 1c ff e0 	movh	r12,0xffe0
8000c46a:	58 0a       	cp.w	r10,0
8000c46c:	f8 0b 13 00 	cpc	r11,r12
8000c470:	5e 8f       	retls	1
8000c472:	5e fd       	retal	0

8000c474 <__avr32_f64_cmp_ge>:
8000c474:	1a de       	st.w	--sp,lr
8000c476:	1a d7       	st.w	--sp,r7
8000c478:	a1 7b       	lsl	r11,0x1
8000c47a:	5f 3c       	srlo	r12
8000c47c:	a1 79       	lsl	r9,0x1
8000c47e:	5f 37       	srlo	r7
8000c480:	5c fc       	rol	r12
8000c482:	fc 1e ff e0 	movh	lr,0xffe0
8000c486:	58 0a       	cp.w	r10,0
8000c488:	fc 0b 13 00 	cpc	r11,lr
8000c48c:	e0 8b 00 1d 	brhi	8000c4c6 <__avr32_f64_cmp_ge+0x52>
8000c490:	58 08       	cp.w	r8,0
8000c492:	fc 09 13 00 	cpc	r9,lr
8000c496:	e0 8b 00 18 	brhi	8000c4c6 <__avr32_f64_cmp_ge+0x52>
8000c49a:	58 0b       	cp.w	r11,0
8000c49c:	f5 ba 00 00 	subfeq	r10,0
8000c4a0:	c1 50       	breq	8000c4ca <__avr32_f64_cmp_ge+0x56>
8000c4a2:	1b 07       	ld.w	r7,sp++
8000c4a4:	1b 0e       	ld.w	lr,sp++
8000c4a6:	58 3c       	cp.w	r12,3
8000c4a8:	c0 a0       	breq	8000c4bc <__avr32_f64_cmp_ge+0x48>
8000c4aa:	58 1c       	cp.w	r12,1
8000c4ac:	c0 33       	brcs	8000c4b2 <__avr32_f64_cmp_ge+0x3e>
8000c4ae:	5e 0f       	reteq	1
8000c4b0:	5e 1d       	retne	0
8000c4b2:	10 3a       	cp.w	r10,r8
8000c4b4:	f2 0b 13 00 	cpc	r11,r9
8000c4b8:	5e 2f       	reths	1
8000c4ba:	5e 3d       	retlo	0
8000c4bc:	14 38       	cp.w	r8,r10
8000c4be:	f6 09 13 00 	cpc	r9,r11
8000c4c2:	5e 2f       	reths	1
8000c4c4:	5e 3d       	retlo	0
8000c4c6:	1b 07       	ld.w	r7,sp++
8000c4c8:	d8 0a       	popm	pc,r12=0
8000c4ca:	58 17       	cp.w	r7,1
8000c4cc:	5f 0c       	sreq	r12
8000c4ce:	58 09       	cp.w	r9,0
8000c4d0:	f5 b8 00 00 	subfeq	r8,0
8000c4d4:	1b 07       	ld.w	r7,sp++
8000c4d6:	1b 0e       	ld.w	lr,sp++
8000c4d8:	5e 0f       	reteq	1
8000c4da:	5e fc       	retal	r12

8000c4dc <__avr32_f64_cmp_lt>:
8000c4dc:	1a de       	st.w	--sp,lr
8000c4de:	1a d7       	st.w	--sp,r7
8000c4e0:	a1 7b       	lsl	r11,0x1
8000c4e2:	5f 3c       	srlo	r12
8000c4e4:	a1 79       	lsl	r9,0x1
8000c4e6:	5f 37       	srlo	r7
8000c4e8:	5c fc       	rol	r12
8000c4ea:	fc 1e ff e0 	movh	lr,0xffe0
8000c4ee:	58 0a       	cp.w	r10,0
8000c4f0:	fc 0b 13 00 	cpc	r11,lr
8000c4f4:	e0 8b 00 1d 	brhi	8000c52e <__avr32_f64_cmp_lt+0x52>
8000c4f8:	58 08       	cp.w	r8,0
8000c4fa:	fc 09 13 00 	cpc	r9,lr
8000c4fe:	e0 8b 00 18 	brhi	8000c52e <__avr32_f64_cmp_lt+0x52>
8000c502:	58 0b       	cp.w	r11,0
8000c504:	f5 ba 00 00 	subfeq	r10,0
8000c508:	c1 50       	breq	8000c532 <__avr32_f64_cmp_lt+0x56>
8000c50a:	1b 07       	ld.w	r7,sp++
8000c50c:	1b 0e       	ld.w	lr,sp++
8000c50e:	58 3c       	cp.w	r12,3
8000c510:	c0 a0       	breq	8000c524 <__avr32_f64_cmp_lt+0x48>
8000c512:	58 1c       	cp.w	r12,1
8000c514:	c0 33       	brcs	8000c51a <__avr32_f64_cmp_lt+0x3e>
8000c516:	5e 0d       	reteq	0
8000c518:	5e 1f       	retne	1
8000c51a:	10 3a       	cp.w	r10,r8
8000c51c:	f2 0b 13 00 	cpc	r11,r9
8000c520:	5e 2d       	reths	0
8000c522:	5e 3f       	retlo	1
8000c524:	14 38       	cp.w	r8,r10
8000c526:	f6 09 13 00 	cpc	r9,r11
8000c52a:	5e 2d       	reths	0
8000c52c:	5e 3f       	retlo	1
8000c52e:	1b 07       	ld.w	r7,sp++
8000c530:	d8 0a       	popm	pc,r12=0
8000c532:	58 17       	cp.w	r7,1
8000c534:	5f 1c       	srne	r12
8000c536:	58 09       	cp.w	r9,0
8000c538:	f5 b8 00 00 	subfeq	r8,0
8000c53c:	1b 07       	ld.w	r7,sp++
8000c53e:	1b 0e       	ld.w	lr,sp++
8000c540:	5e 0d       	reteq	0
8000c542:	5e fc       	retal	r12

8000c544 <__avr32_f64_div>:
8000c544:	eb cd 40 ff 	pushm	r0-r7,lr
8000c548:	f7 e9 20 0e 	eor	lr,r11,r9
8000c54c:	f6 07 16 14 	lsr	r7,r11,0x14
8000c550:	a9 7b       	lsl	r11,0x9
8000c552:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c556:	a9 7a       	lsl	r10,0x9
8000c558:	bd bb       	sbr	r11,0x1d
8000c55a:	e4 1b 3f ff 	andh	r11,0x3fff
8000c55e:	ab d7       	cbr	r7,0xb
8000c560:	e0 80 00 cc 	breq	8000c6f8 <__avr32_f64_div_round_subnormal+0x54>
8000c564:	e0 47 07 ff 	cp.w	r7,2047
8000c568:	e0 84 00 b5 	brge	8000c6d2 <__avr32_f64_div_round_subnormal+0x2e>
8000c56c:	f2 06 16 14 	lsr	r6,r9,0x14
8000c570:	a9 79       	lsl	r9,0x9
8000c572:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c576:	a9 78       	lsl	r8,0x9
8000c578:	bd b9       	sbr	r9,0x1d
8000c57a:	e4 19 3f ff 	andh	r9,0x3fff
8000c57e:	ab d6       	cbr	r6,0xb
8000c580:	e0 80 00 e2 	breq	8000c744 <__avr32_f64_div_round_subnormal+0xa0>
8000c584:	e0 46 07 ff 	cp.w	r6,2047
8000c588:	e0 84 00 b2 	brge	8000c6ec <__avr32_f64_div_round_subnormal+0x48>
8000c58c:	0c 17       	sub	r7,r6
8000c58e:	fe 37 fc 01 	sub	r7,-1023
8000c592:	fc 1c 80 00 	movh	r12,0x8000
8000c596:	f8 03 16 01 	lsr	r3,r12,0x1
8000c59a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c59e:	5c d4       	com	r4
8000c5a0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c5a4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5a8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5ac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5b0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5b4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5b8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5bc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5c0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5c4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5c8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c5cc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5d0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5d4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c5d8:	e4 09 07 40 	macu.d	r0,r2,r9
8000c5dc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5e0:	02 04       	add	r4,r1
8000c5e2:	5c 05       	acr	r5
8000c5e4:	a3 65       	lsl	r5,0x2
8000c5e6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c5ea:	a3 64       	lsl	r4,0x2
8000c5ec:	5c 34       	neg	r4
8000c5ee:	f8 05 01 45 	sbc	r5,r12,r5
8000c5f2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c5f6:	e4 05 07 40 	macu.d	r0,r2,r5
8000c5fa:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5fe:	02 04       	add	r4,r1
8000c600:	5c 05       	acr	r5
8000c602:	ea 03 15 02 	lsl	r3,r5,0x2
8000c606:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c60a:	e8 02 15 02 	lsl	r2,r4,0x2
8000c60e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c612:	e4 09 07 40 	macu.d	r0,r2,r9
8000c616:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c61a:	02 04       	add	r4,r1
8000c61c:	5c 05       	acr	r5
8000c61e:	a3 65       	lsl	r5,0x2
8000c620:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c624:	a3 64       	lsl	r4,0x2
8000c626:	5c 34       	neg	r4
8000c628:	f8 05 01 45 	sbc	r5,r12,r5
8000c62c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c630:	e4 05 07 40 	macu.d	r0,r2,r5
8000c634:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c638:	02 04       	add	r4,r1
8000c63a:	5c 05       	acr	r5
8000c63c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c640:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c644:	e8 02 15 02 	lsl	r2,r4,0x2
8000c648:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c64c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c650:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c654:	02 02       	add	r2,r1
8000c656:	5c 03       	acr	r3
8000c658:	ed b3 00 1c 	bld	r3,0x1c
8000c65c:	c0 90       	breq	8000c66e <__avr32_f64_div+0x12a>
8000c65e:	a1 72       	lsl	r2,0x1
8000c660:	5c f3       	rol	r3
8000c662:	20 17       	sub	r7,1
8000c664:	a3 9a       	lsr	r10,0x3
8000c666:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c66a:	a3 9b       	lsr	r11,0x3
8000c66c:	c0 58       	rjmp	8000c676 <__avr32_f64_div+0x132>
8000c66e:	a5 8a       	lsr	r10,0x4
8000c670:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c674:	a5 8b       	lsr	r11,0x4
8000c676:	58 07       	cp.w	r7,0
8000c678:	e0 8a 00 8b 	brle	8000c78e <__avr32_f64_div_res_subnormal>
8000c67c:	e0 12 ff 00 	andl	r2,0xff00
8000c680:	e8 12 00 80 	orl	r2,0x80
8000c684:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c688:	e4 09 07 40 	macu.d	r0,r2,r9
8000c68c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c690:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c694:	00 05       	add	r5,r0
8000c696:	f0 01 00 48 	adc	r8,r8,r1
8000c69a:	5c 09       	acr	r9
8000c69c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c6a0:	58 04       	cp.w	r4,0
8000c6a2:	5c 25       	cpc	r5

8000c6a4 <__avr32_f64_div_round_subnormal>:
8000c6a4:	f4 08 13 00 	cpc	r8,r10
8000c6a8:	f6 09 13 00 	cpc	r9,r11
8000c6ac:	5f 36       	srlo	r6
8000c6ae:	f8 06 17 00 	moveq	r6,r12
8000c6b2:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c6b6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c6ba:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c6be:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c6c2:	ed be 00 1f 	bld	lr,0x1f
8000c6c6:	ef bb 00 1f 	bst	r11,0x1f
8000c6ca:	0c 0a       	add	r10,r6
8000c6cc:	5c 0b       	acr	r11
8000c6ce:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c6d2:	e4 1b 00 0f 	andh	r11,0xf
8000c6d6:	14 4b       	or	r11,r10
8000c6d8:	e0 81 00 a7 	brne	8000c826 <__avr32_f64_div_res_subnormal+0x98>
8000c6dc:	f2 06 16 14 	lsr	r6,r9,0x14
8000c6e0:	ab d6       	cbr	r6,0xb
8000c6e2:	e0 46 07 ff 	cp.w	r6,2047
8000c6e6:	e0 81 00 a4 	brne	8000c82e <__avr32_f64_div_res_subnormal+0xa0>
8000c6ea:	c9 e8       	rjmp	8000c826 <__avr32_f64_div_res_subnormal+0x98>
8000c6ec:	e4 19 00 0f 	andh	r9,0xf
8000c6f0:	10 49       	or	r9,r8
8000c6f2:	e0 81 00 9a 	brne	8000c826 <__avr32_f64_div_res_subnormal+0x98>
8000c6f6:	c9 28       	rjmp	8000c81a <__avr32_f64_div_res_subnormal+0x8c>
8000c6f8:	a3 7b       	lsl	r11,0x3
8000c6fa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c6fe:	a3 7a       	lsl	r10,0x3
8000c700:	f5 eb 10 04 	or	r4,r10,r11
8000c704:	e0 80 00 a0 	breq	8000c844 <__avr32_f64_div_op1_zero>
8000c708:	f6 04 12 00 	clz	r4,r11
8000c70c:	c1 70       	breq	8000c73a <__avr32_f64_div_round_subnormal+0x96>
8000c70e:	c0 c3       	brcs	8000c726 <__avr32_f64_div_round_subnormal+0x82>
8000c710:	e8 05 11 20 	rsub	r5,r4,32
8000c714:	f6 04 09 4b 	lsl	r11,r11,r4
8000c718:	f4 05 0a 45 	lsr	r5,r10,r5
8000c71c:	0a 4b       	or	r11,r5
8000c71e:	f4 04 09 4a 	lsl	r10,r10,r4
8000c722:	08 17       	sub	r7,r4
8000c724:	c0 b8       	rjmp	8000c73a <__avr32_f64_div_round_subnormal+0x96>
8000c726:	f4 04 12 00 	clz	r4,r10
8000c72a:	f9 b4 03 00 	movlo	r4,0
8000c72e:	f7 b4 02 e0 	subhs	r4,-32
8000c732:	f4 04 09 4b 	lsl	r11,r10,r4
8000c736:	30 0a       	mov	r10,0
8000c738:	08 17       	sub	r7,r4
8000c73a:	a3 8a       	lsr	r10,0x2
8000c73c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c740:	a3 8b       	lsr	r11,0x2
8000c742:	c1 1b       	rjmp	8000c564 <__avr32_f64_div+0x20>
8000c744:	a3 79       	lsl	r9,0x3
8000c746:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c74a:	a3 78       	lsl	r8,0x3
8000c74c:	f3 e8 10 04 	or	r4,r9,r8
8000c750:	c6 f0       	breq	8000c82e <__avr32_f64_div_res_subnormal+0xa0>
8000c752:	f2 04 12 00 	clz	r4,r9
8000c756:	c1 70       	breq	8000c784 <__avr32_f64_div_round_subnormal+0xe0>
8000c758:	c0 c3       	brcs	8000c770 <__avr32_f64_div_round_subnormal+0xcc>
8000c75a:	e8 05 11 20 	rsub	r5,r4,32
8000c75e:	f2 04 09 49 	lsl	r9,r9,r4
8000c762:	f0 05 0a 45 	lsr	r5,r8,r5
8000c766:	0a 49       	or	r9,r5
8000c768:	f0 04 09 48 	lsl	r8,r8,r4
8000c76c:	08 16       	sub	r6,r4
8000c76e:	c0 b8       	rjmp	8000c784 <__avr32_f64_div_round_subnormal+0xe0>
8000c770:	f0 04 12 00 	clz	r4,r8
8000c774:	f9 b4 03 00 	movlo	r4,0
8000c778:	f7 b4 02 e0 	subhs	r4,-32
8000c77c:	f0 04 09 49 	lsl	r9,r8,r4
8000c780:	30 08       	mov	r8,0
8000c782:	08 16       	sub	r6,r4
8000c784:	a3 88       	lsr	r8,0x2
8000c786:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c78a:	a3 89       	lsr	r9,0x2
8000c78c:	cf ca       	rjmp	8000c584 <__avr32_f64_div+0x40>

8000c78e <__avr32_f64_div_res_subnormal>:
8000c78e:	5c 37       	neg	r7
8000c790:	2f f7       	sub	r7,-1
8000c792:	f1 b7 04 c0 	satu	r7,0x6
8000c796:	e0 47 00 20 	cp.w	r7,32
8000c79a:	c1 54       	brge	8000c7c4 <__avr32_f64_div_res_subnormal+0x36>
8000c79c:	ee 06 11 20 	rsub	r6,r7,32
8000c7a0:	e4 07 0a 42 	lsr	r2,r2,r7
8000c7a4:	e6 06 09 4c 	lsl	r12,r3,r6
8000c7a8:	18 42       	or	r2,r12
8000c7aa:	e6 07 0a 43 	lsr	r3,r3,r7
8000c7ae:	f4 06 09 41 	lsl	r1,r10,r6
8000c7b2:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c7b6:	f6 06 09 4c 	lsl	r12,r11,r6
8000c7ba:	18 4a       	or	r10,r12
8000c7bc:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c7c0:	30 00       	mov	r0,0
8000c7c2:	c1 58       	rjmp	8000c7ec <__avr32_f64_div_res_subnormal+0x5e>
8000c7c4:	ee 06 11 20 	rsub	r6,r7,32
8000c7c8:	f9 b0 00 00 	moveq	r0,0
8000c7cc:	f9 bc 00 00 	moveq	r12,0
8000c7d0:	c0 50       	breq	8000c7da <__avr32_f64_div_res_subnormal+0x4c>
8000c7d2:	f4 06 09 40 	lsl	r0,r10,r6
8000c7d6:	f6 06 09 4c 	lsl	r12,r11,r6
8000c7da:	e6 07 0a 42 	lsr	r2,r3,r7
8000c7de:	30 03       	mov	r3,0
8000c7e0:	f4 07 0a 41 	lsr	r1,r10,r7
8000c7e4:	18 41       	or	r1,r12
8000c7e6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c7ea:	30 0b       	mov	r11,0
8000c7ec:	e0 12 ff 00 	andl	r2,0xff00
8000c7f0:	e8 12 00 80 	orl	r2,0x80
8000c7f4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c7f8:	e4 09 07 46 	macu.d	r6,r2,r9
8000c7fc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c800:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c804:	0c 05       	add	r5,r6
8000c806:	f0 07 00 48 	adc	r8,r8,r7
8000c80a:	5c 09       	acr	r9
8000c80c:	30 07       	mov	r7,0
8000c80e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c812:	00 34       	cp.w	r4,r0
8000c814:	e2 05 13 00 	cpc	r5,r1
8000c818:	c4 6b       	rjmp	8000c6a4 <__avr32_f64_div_round_subnormal>
8000c81a:	1c 9b       	mov	r11,lr
8000c81c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c820:	30 0a       	mov	r10,0
8000c822:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c826:	3f fb       	mov	r11,-1
8000c828:	30 0a       	mov	r10,0
8000c82a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c82e:	f5 eb 10 04 	or	r4,r10,r11
8000c832:	c0 90       	breq	8000c844 <__avr32_f64_div_op1_zero>
8000c834:	1c 9b       	mov	r11,lr
8000c836:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c83a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c83e:	30 0a       	mov	r10,0
8000c840:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c844 <__avr32_f64_div_op1_zero>:
8000c844:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c848:	ce f0       	breq	8000c826 <__avr32_f64_div_res_subnormal+0x98>
8000c84a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c84e:	e0 44 07 ff 	cp.w	r4,2047
8000c852:	ce 41       	brne	8000c81a <__avr32_f64_div_res_subnormal+0x8c>
8000c854:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c858:	ce 10       	breq	8000c81a <__avr32_f64_div_res_subnormal+0x8c>
8000c85a:	ce 6b       	rjmp	8000c826 <__avr32_f64_div_res_subnormal+0x98>

8000c85c <__avr32_udiv64>:
8000c85c:	d4 31       	pushm	r0-r7,lr
8000c85e:	1a 97       	mov	r7,sp
8000c860:	20 3d       	sub	sp,12
8000c862:	10 9c       	mov	r12,r8
8000c864:	12 9e       	mov	lr,r9
8000c866:	14 93       	mov	r3,r10
8000c868:	58 09       	cp.w	r9,0
8000c86a:	e0 81 00 bd 	brne	8000c9e4 <__avr32_udiv64+0x188>
8000c86e:	16 38       	cp.w	r8,r11
8000c870:	e0 88 00 40 	brls	8000c8f0 <__avr32_udiv64+0x94>
8000c874:	f0 08 12 00 	clz	r8,r8
8000c878:	c0 d0       	breq	8000c892 <__avr32_udiv64+0x36>
8000c87a:	f6 08 09 4b 	lsl	r11,r11,r8
8000c87e:	f0 09 11 20 	rsub	r9,r8,32
8000c882:	f8 08 09 4c 	lsl	r12,r12,r8
8000c886:	f4 09 0a 49 	lsr	r9,r10,r9
8000c88a:	f4 08 09 43 	lsl	r3,r10,r8
8000c88e:	f3 eb 10 0b 	or	r11,r9,r11
8000c892:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c896:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c89a:	f6 0e 0d 00 	divu	r0,r11,lr
8000c89e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c8a2:	00 99       	mov	r9,r0
8000c8a4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8a8:	e0 0a 02 48 	mul	r8,r0,r10
8000c8ac:	10 3b       	cp.w	r11,r8
8000c8ae:	c0 a2       	brcc	8000c8c2 <__avr32_udiv64+0x66>
8000c8b0:	20 19       	sub	r9,1
8000c8b2:	18 0b       	add	r11,r12
8000c8b4:	18 3b       	cp.w	r11,r12
8000c8b6:	c0 63       	brcs	8000c8c2 <__avr32_udiv64+0x66>
8000c8b8:	10 3b       	cp.w	r11,r8
8000c8ba:	f7 b9 03 01 	sublo	r9,1
8000c8be:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8c2:	f6 08 01 01 	sub	r1,r11,r8
8000c8c6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c8ca:	e2 0e 0d 00 	divu	r0,r1,lr
8000c8ce:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c8d2:	00 98       	mov	r8,r0
8000c8d4:	e0 0a 02 4a 	mul	r10,r0,r10
8000c8d8:	14 33       	cp.w	r3,r10
8000c8da:	c0 82       	brcc	8000c8ea <__avr32_udiv64+0x8e>
8000c8dc:	20 18       	sub	r8,1
8000c8de:	18 03       	add	r3,r12
8000c8e0:	18 33       	cp.w	r3,r12
8000c8e2:	c0 43       	brcs	8000c8ea <__avr32_udiv64+0x8e>
8000c8e4:	14 33       	cp.w	r3,r10
8000c8e6:	f7 b8 03 01 	sublo	r8,1
8000c8ea:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c8ee:	cd f8       	rjmp	8000caac <__avr32_udiv64+0x250>
8000c8f0:	58 08       	cp.w	r8,0
8000c8f2:	c0 51       	brne	8000c8fc <__avr32_udiv64+0xa0>
8000c8f4:	30 19       	mov	r9,1
8000c8f6:	f2 08 0d 08 	divu	r8,r9,r8
8000c8fa:	10 9c       	mov	r12,r8
8000c8fc:	f8 06 12 00 	clz	r6,r12
8000c900:	c0 41       	brne	8000c908 <__avr32_udiv64+0xac>
8000c902:	18 1b       	sub	r11,r12
8000c904:	30 19       	mov	r9,1
8000c906:	c4 08       	rjmp	8000c986 <__avr32_udiv64+0x12a>
8000c908:	ec 01 11 20 	rsub	r1,r6,32
8000c90c:	f4 01 0a 49 	lsr	r9,r10,r1
8000c910:	f8 06 09 4c 	lsl	r12,r12,r6
8000c914:	f6 06 09 48 	lsl	r8,r11,r6
8000c918:	f6 01 0a 41 	lsr	r1,r11,r1
8000c91c:	f3 e8 10 08 	or	r8,r9,r8
8000c920:	f8 03 16 10 	lsr	r3,r12,0x10
8000c924:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c928:	e2 03 0d 00 	divu	r0,r1,r3
8000c92c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c930:	00 9e       	mov	lr,r0
8000c932:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c936:	e0 05 02 49 	mul	r9,r0,r5
8000c93a:	12 3b       	cp.w	r11,r9
8000c93c:	c0 a2       	brcc	8000c950 <__avr32_udiv64+0xf4>
8000c93e:	20 1e       	sub	lr,1
8000c940:	18 0b       	add	r11,r12
8000c942:	18 3b       	cp.w	r11,r12
8000c944:	c0 63       	brcs	8000c950 <__avr32_udiv64+0xf4>
8000c946:	12 3b       	cp.w	r11,r9
8000c948:	f7 be 03 01 	sublo	lr,1
8000c94c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c950:	12 1b       	sub	r11,r9
8000c952:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c956:	f6 03 0d 02 	divu	r2,r11,r3
8000c95a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c95e:	04 99       	mov	r9,r2
8000c960:	e4 05 02 4b 	mul	r11,r2,r5
8000c964:	16 38       	cp.w	r8,r11
8000c966:	c0 a2       	brcc	8000c97a <__avr32_udiv64+0x11e>
8000c968:	20 19       	sub	r9,1
8000c96a:	18 08       	add	r8,r12
8000c96c:	18 38       	cp.w	r8,r12
8000c96e:	c0 63       	brcs	8000c97a <__avr32_udiv64+0x11e>
8000c970:	16 38       	cp.w	r8,r11
8000c972:	f7 b9 03 01 	sublo	r9,1
8000c976:	f1 dc e3 08 	addcs	r8,r8,r12
8000c97a:	f4 06 09 43 	lsl	r3,r10,r6
8000c97e:	f0 0b 01 0b 	sub	r11,r8,r11
8000c982:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c986:	f8 06 16 10 	lsr	r6,r12,0x10
8000c98a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c98e:	f6 06 0d 00 	divu	r0,r11,r6
8000c992:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c996:	00 9a       	mov	r10,r0
8000c998:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c99c:	e0 0e 02 48 	mul	r8,r0,lr
8000c9a0:	10 3b       	cp.w	r11,r8
8000c9a2:	c0 a2       	brcc	8000c9b6 <__avr32_udiv64+0x15a>
8000c9a4:	20 1a       	sub	r10,1
8000c9a6:	18 0b       	add	r11,r12
8000c9a8:	18 3b       	cp.w	r11,r12
8000c9aa:	c0 63       	brcs	8000c9b6 <__avr32_udiv64+0x15a>
8000c9ac:	10 3b       	cp.w	r11,r8
8000c9ae:	f7 ba 03 01 	sublo	r10,1
8000c9b2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c9b6:	f6 08 01 01 	sub	r1,r11,r8
8000c9ba:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c9be:	e2 06 0d 00 	divu	r0,r1,r6
8000c9c2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c9c6:	00 98       	mov	r8,r0
8000c9c8:	e0 0e 02 4b 	mul	r11,r0,lr
8000c9cc:	16 33       	cp.w	r3,r11
8000c9ce:	c0 82       	brcc	8000c9de <__avr32_udiv64+0x182>
8000c9d0:	20 18       	sub	r8,1
8000c9d2:	18 03       	add	r3,r12
8000c9d4:	18 33       	cp.w	r3,r12
8000c9d6:	c0 43       	brcs	8000c9de <__avr32_udiv64+0x182>
8000c9d8:	16 33       	cp.w	r3,r11
8000c9da:	f7 b8 03 01 	sublo	r8,1
8000c9de:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c9e2:	c6 98       	rjmp	8000cab4 <__avr32_udiv64+0x258>
8000c9e4:	16 39       	cp.w	r9,r11
8000c9e6:	e0 8b 00 65 	brhi	8000cab0 <__avr32_udiv64+0x254>
8000c9ea:	f2 09 12 00 	clz	r9,r9
8000c9ee:	c0 b1       	brne	8000ca04 <__avr32_udiv64+0x1a8>
8000c9f0:	10 3a       	cp.w	r10,r8
8000c9f2:	5f 2a       	srhs	r10
8000c9f4:	1c 3b       	cp.w	r11,lr
8000c9f6:	5f b8       	srhi	r8
8000c9f8:	10 4a       	or	r10,r8
8000c9fa:	f2 0a 18 00 	cp.b	r10,r9
8000c9fe:	c5 90       	breq	8000cab0 <__avr32_udiv64+0x254>
8000ca00:	30 18       	mov	r8,1
8000ca02:	c5 98       	rjmp	8000cab4 <__avr32_udiv64+0x258>
8000ca04:	f0 09 09 46 	lsl	r6,r8,r9
8000ca08:	f2 03 11 20 	rsub	r3,r9,32
8000ca0c:	fc 09 09 4e 	lsl	lr,lr,r9
8000ca10:	f0 03 0a 48 	lsr	r8,r8,r3
8000ca14:	f6 09 09 4c 	lsl	r12,r11,r9
8000ca18:	f4 03 0a 42 	lsr	r2,r10,r3
8000ca1c:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca20:	f6 03 0a 43 	lsr	r3,r11,r3
8000ca24:	18 42       	or	r2,r12
8000ca26:	f1 ee 10 0c 	or	r12,r8,lr
8000ca2a:	f8 01 16 10 	lsr	r1,r12,0x10
8000ca2e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ca32:	e6 01 0d 04 	divu	r4,r3,r1
8000ca36:	e4 03 16 10 	lsr	r3,r2,0x10
8000ca3a:	08 9e       	mov	lr,r4
8000ca3c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000ca40:	e8 06 02 48 	mul	r8,r4,r6
8000ca44:	10 33       	cp.w	r3,r8
8000ca46:	c0 a2       	brcc	8000ca5a <__avr32_udiv64+0x1fe>
8000ca48:	20 1e       	sub	lr,1
8000ca4a:	18 03       	add	r3,r12
8000ca4c:	18 33       	cp.w	r3,r12
8000ca4e:	c0 63       	brcs	8000ca5a <__avr32_udiv64+0x1fe>
8000ca50:	10 33       	cp.w	r3,r8
8000ca52:	f7 be 03 01 	sublo	lr,1
8000ca56:	e7 dc e3 03 	addcs	r3,r3,r12
8000ca5a:	10 13       	sub	r3,r8
8000ca5c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000ca60:	e6 01 0d 00 	divu	r0,r3,r1
8000ca64:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca68:	00 98       	mov	r8,r0
8000ca6a:	e0 06 02 46 	mul	r6,r0,r6
8000ca6e:	0c 3b       	cp.w	r11,r6
8000ca70:	c0 a2       	brcc	8000ca84 <__avr32_udiv64+0x228>
8000ca72:	20 18       	sub	r8,1
8000ca74:	18 0b       	add	r11,r12
8000ca76:	18 3b       	cp.w	r11,r12
8000ca78:	c0 63       	brcs	8000ca84 <__avr32_udiv64+0x228>
8000ca7a:	0c 3b       	cp.w	r11,r6
8000ca7c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca80:	f7 b8 03 01 	sublo	r8,1
8000ca84:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000ca88:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000ca8c:	0c 1b       	sub	r11,r6
8000ca8e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000ca92:	06 95       	mov	r5,r3
8000ca94:	16 35       	cp.w	r5,r11
8000ca96:	e0 8b 00 0a 	brhi	8000caaa <__avr32_udiv64+0x24e>
8000ca9a:	5f 0b       	sreq	r11
8000ca9c:	f4 09 09 49 	lsl	r9,r10,r9
8000caa0:	12 32       	cp.w	r2,r9
8000caa2:	5f b9       	srhi	r9
8000caa4:	f7 e9 00 09 	and	r9,r11,r9
8000caa8:	c0 60       	breq	8000cab4 <__avr32_udiv64+0x258>
8000caaa:	20 18       	sub	r8,1
8000caac:	30 09       	mov	r9,0
8000caae:	c0 38       	rjmp	8000cab4 <__avr32_udiv64+0x258>
8000cab0:	30 09       	mov	r9,0
8000cab2:	12 98       	mov	r8,r9
8000cab4:	10 9a       	mov	r10,r8
8000cab6:	12 93       	mov	r3,r9
8000cab8:	10 92       	mov	r2,r8
8000caba:	12 9b       	mov	r11,r9
8000cabc:	2f dd       	sub	sp,-12
8000cabe:	d8 32       	popm	r0-r7,pc

8000cac0 <__avr32_umod64>:
8000cac0:	d4 31       	pushm	r0-r7,lr
8000cac2:	1a 97       	mov	r7,sp
8000cac4:	20 3d       	sub	sp,12
8000cac6:	10 9c       	mov	r12,r8
8000cac8:	12 95       	mov	r5,r9
8000caca:	14 9e       	mov	lr,r10
8000cacc:	16 91       	mov	r1,r11
8000cace:	16 96       	mov	r6,r11
8000cad0:	58 09       	cp.w	r9,0
8000cad2:	e0 81 00 81 	brne	8000cbd4 <__avr32_umod64+0x114>
8000cad6:	16 38       	cp.w	r8,r11
8000cad8:	e0 88 00 12 	brls	8000cafc <__avr32_umod64+0x3c>
8000cadc:	f0 08 12 00 	clz	r8,r8
8000cae0:	c4 e0       	breq	8000cb7c <__avr32_umod64+0xbc>
8000cae2:	f6 08 09 46 	lsl	r6,r11,r8
8000cae6:	f8 08 09 4c 	lsl	r12,r12,r8
8000caea:	f0 0b 11 20 	rsub	r11,r8,32
8000caee:	f4 08 09 4e 	lsl	lr,r10,r8
8000caf2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000caf6:	f7 e6 10 06 	or	r6,r11,r6
8000cafa:	c4 18       	rjmp	8000cb7c <__avr32_umod64+0xbc>
8000cafc:	58 08       	cp.w	r8,0
8000cafe:	c0 51       	brne	8000cb08 <__avr32_umod64+0x48>
8000cb00:	30 19       	mov	r9,1
8000cb02:	f2 08 0d 08 	divu	r8,r9,r8
8000cb06:	10 9c       	mov	r12,r8
8000cb08:	f8 08 12 00 	clz	r8,r12
8000cb0c:	c0 31       	brne	8000cb12 <__avr32_umod64+0x52>
8000cb0e:	18 16       	sub	r6,r12
8000cb10:	c3 68       	rjmp	8000cb7c <__avr32_umod64+0xbc>
8000cb12:	f0 03 11 20 	rsub	r3,r8,32
8000cb16:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cb1a:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb1e:	ec 08 09 49 	lsl	r9,r6,r8
8000cb22:	ec 03 0a 43 	lsr	r3,r6,r3
8000cb26:	f7 e9 10 09 	or	r9,r11,r9
8000cb2a:	f8 05 16 10 	lsr	r5,r12,0x10
8000cb2e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cb32:	e6 05 0d 02 	divu	r2,r3,r5
8000cb36:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cb3a:	ec 02 02 4b 	mul	r11,r6,r2
8000cb3e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cb42:	16 3e       	cp.w	lr,r11
8000cb44:	c0 72       	brcc	8000cb52 <__avr32_umod64+0x92>
8000cb46:	18 0e       	add	lr,r12
8000cb48:	18 3e       	cp.w	lr,r12
8000cb4a:	c0 43       	brcs	8000cb52 <__avr32_umod64+0x92>
8000cb4c:	16 3e       	cp.w	lr,r11
8000cb4e:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb52:	fc 0b 01 03 	sub	r3,lr,r11
8000cb56:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cb5a:	e6 05 0d 02 	divu	r2,r3,r5
8000cb5e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb62:	a5 36       	mul	r6,r2
8000cb64:	0c 39       	cp.w	r9,r6
8000cb66:	c0 72       	brcc	8000cb74 <__avr32_umod64+0xb4>
8000cb68:	18 09       	add	r9,r12
8000cb6a:	18 39       	cp.w	r9,r12
8000cb6c:	c0 43       	brcs	8000cb74 <__avr32_umod64+0xb4>
8000cb6e:	0c 39       	cp.w	r9,r6
8000cb70:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb74:	f2 06 01 06 	sub	r6,r9,r6
8000cb78:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb7c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cb80:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cb84:	ec 0a 0d 02 	divu	r2,r6,r10
8000cb88:	fc 09 16 10 	lsr	r9,lr,0x10
8000cb8c:	ea 02 02 4b 	mul	r11,r5,r2
8000cb90:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb94:	16 39       	cp.w	r9,r11
8000cb96:	c0 72       	brcc	8000cba4 <__avr32_umod64+0xe4>
8000cb98:	18 09       	add	r9,r12
8000cb9a:	18 39       	cp.w	r9,r12
8000cb9c:	c0 43       	brcs	8000cba4 <__avr32_umod64+0xe4>
8000cb9e:	16 39       	cp.w	r9,r11
8000cba0:	f3 dc e3 09 	addcs	r9,r9,r12
8000cba4:	f2 0b 01 0b 	sub	r11,r9,r11
8000cba8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cbac:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cbb0:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cbb4:	ea 0a 02 4a 	mul	r10,r5,r10
8000cbb8:	14 3e       	cp.w	lr,r10
8000cbba:	c0 72       	brcc	8000cbc8 <__avr32_umod64+0x108>
8000cbbc:	18 0e       	add	lr,r12
8000cbbe:	18 3e       	cp.w	lr,r12
8000cbc0:	c0 43       	brcs	8000cbc8 <__avr32_umod64+0x108>
8000cbc2:	14 3e       	cp.w	lr,r10
8000cbc4:	fd dc e3 0e 	addcs	lr,lr,r12
8000cbc8:	fc 0a 01 0a 	sub	r10,lr,r10
8000cbcc:	30 0b       	mov	r11,0
8000cbce:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cbd2:	c7 b8       	rjmp	8000ccc8 <__avr32_umod64+0x208>
8000cbd4:	16 39       	cp.w	r9,r11
8000cbd6:	e0 8b 00 79 	brhi	8000ccc8 <__avr32_umod64+0x208>
8000cbda:	f2 09 12 00 	clz	r9,r9
8000cbde:	c1 21       	brne	8000cc02 <__avr32_umod64+0x142>
8000cbe0:	10 3a       	cp.w	r10,r8
8000cbe2:	5f 2b       	srhs	r11
8000cbe4:	0a 31       	cp.w	r1,r5
8000cbe6:	5f ba       	srhi	r10
8000cbe8:	f7 ea 10 0a 	or	r10,r11,r10
8000cbec:	f2 0a 18 00 	cp.b	r10,r9
8000cbf0:	c0 60       	breq	8000cbfc <__avr32_umod64+0x13c>
8000cbf2:	fc 08 01 0c 	sub	r12,lr,r8
8000cbf6:	e2 05 01 46 	sbc	r6,r1,r5
8000cbfa:	18 9e       	mov	lr,r12
8000cbfc:	0c 9b       	mov	r11,r6
8000cbfe:	1c 9a       	mov	r10,lr
8000cc00:	c6 48       	rjmp	8000ccc8 <__avr32_umod64+0x208>
8000cc02:	ea 09 09 4c 	lsl	r12,r5,r9
8000cc06:	f2 06 11 20 	rsub	r6,r9,32
8000cc0a:	f6 09 09 4b 	lsl	r11,r11,r9
8000cc0e:	f0 09 09 42 	lsl	r2,r8,r9
8000cc12:	ef 46 ff f4 	st.w	r7[-12],r6
8000cc16:	f0 06 0a 48 	lsr	r8,r8,r6
8000cc1a:	18 48       	or	r8,r12
8000cc1c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cc20:	f4 09 09 43 	lsl	r3,r10,r9
8000cc24:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cc28:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cc2c:	16 4a       	or	r10,r11
8000cc2e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cc32:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc36:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cc3a:	08 91       	mov	r1,r4
8000cc3c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cc40:	e8 0e 02 46 	mul	r6,r4,lr
8000cc44:	0c 3c       	cp.w	r12,r6
8000cc46:	c0 a2       	brcc	8000cc5a <__avr32_umod64+0x19a>
8000cc48:	20 11       	sub	r1,1
8000cc4a:	10 0c       	add	r12,r8
8000cc4c:	10 3c       	cp.w	r12,r8
8000cc4e:	c0 63       	brcs	8000cc5a <__avr32_umod64+0x19a>
8000cc50:	0c 3c       	cp.w	r12,r6
8000cc52:	f7 b1 03 01 	sublo	r1,1
8000cc56:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cc5a:	0c 1c       	sub	r12,r6
8000cc5c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cc60:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc64:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cc68:	08 96       	mov	r6,r4
8000cc6a:	e8 0e 02 4e 	mul	lr,r4,lr
8000cc6e:	1c 3b       	cp.w	r11,lr
8000cc70:	c0 a2       	brcc	8000cc84 <__avr32_umod64+0x1c4>
8000cc72:	20 16       	sub	r6,1
8000cc74:	10 0b       	add	r11,r8
8000cc76:	10 3b       	cp.w	r11,r8
8000cc78:	c0 63       	brcs	8000cc84 <__avr32_umod64+0x1c4>
8000cc7a:	1c 3b       	cp.w	r11,lr
8000cc7c:	f7 b6 03 01 	sublo	r6,1
8000cc80:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cc84:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cc88:	1c 1b       	sub	r11,lr
8000cc8a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cc8e:	00 9e       	mov	lr,r0
8000cc90:	02 9c       	mov	r12,r1
8000cc92:	16 3c       	cp.w	r12,r11
8000cc94:	e0 8b 00 08 	brhi	8000cca4 <__avr32_umod64+0x1e4>
8000cc98:	5f 06       	sreq	r6
8000cc9a:	06 30       	cp.w	r0,r3
8000cc9c:	5f ba       	srhi	r10
8000cc9e:	ed ea 00 0a 	and	r10,r6,r10
8000cca2:	c0 60       	breq	8000ccae <__avr32_umod64+0x1ee>
8000cca4:	fc 02 01 04 	sub	r4,lr,r2
8000cca8:	f8 08 01 4c 	sbc	r12,r12,r8
8000ccac:	08 9e       	mov	lr,r4
8000ccae:	e6 0e 01 0a 	sub	r10,r3,lr
8000ccb2:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ccb6:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ccba:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ccbe:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ccc2:	f8 01 09 4c 	lsl	r12,r12,r1
8000ccc6:	18 4a       	or	r10,r12
8000ccc8:	2f dd       	sub	sp,-12
8000ccca:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 cc 	sub	pc,pc,28876

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 b5 	rcall	80005670 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 ae 	rcall	80005670 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 a7 	rcall	80005670 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 a0 	rcall	80005670 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
