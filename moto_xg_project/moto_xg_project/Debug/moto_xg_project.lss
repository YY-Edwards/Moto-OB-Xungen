
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000aa34  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000124c  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e04c  8000e04c  0000e44c  2**0
                  ALLOC
  6 .data         00000a3c  00000004  8000e050  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00005130  00000a40  8000ea8c  0000f240  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001680  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000035f0  00000000  00000000  000108f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c2af  00000000  00000000  00013ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00007272  00000000  00000000  0004018f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d381  00000000  00000000  00047401  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003ce0  00000000  00000000  00054784  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007f6d  00000000  00000000  00058464  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f267  00000000  00000000  000603d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001748  00000000  00000000  0006f638  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c5 d4 	sub	pc,pc,-14892

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 94       	ld.ub	r4,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 60       	and	r0,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 03 20 	mov	r10,800
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3d b4       	mov	r4,-37
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2a 5c       	sub	r12,-91
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ce 00       	breq	80002042 <app_init+0x6>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 c4       	sub	r4,124
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	69 6c       	ld.w	r12,r4[0x58]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	ce 08       	rjmp	8000225e <ButtonConfig_brdcst_func+0x7a>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6d 30       	ld.w	r0,r6[0x4c]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 57       	eor	r7,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	ce 0c       	rcall	8000228e <ButtonConfig_brdcst_func+0xaa>
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6d 30       	ld.w	r0,r6[0x4c]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 49       	or	r9,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	ce 18       	rjmp	800022a8 <ButtonConfig_brdcst_func+0xc4>
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6d 30       	ld.w	r0,r6[0x4c]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	ce 38       	rjmp	800022c0 <ButtonConfig_reply_func>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6d 30       	ld.w	r0,r6[0x4c]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	ce 54       	brge	800020d8 <FD_brdcst_func>
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6d 30       	ld.w	r0,r6[0x4c]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	ce 70       	breq	800020f0 <FD_reply_func+0x4>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6d 30       	ld.w	r0,r6[0x4c]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ce 88       	rjmp	80002352 <BatteryLevel_brdcst_func+0x4e>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6d 30       	ld.w	r0,r6[0x4c]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	ce a0       	breq	8000215e <EnOB_reply_func+0x36>
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	ce b4       	brge	80002164 <EnOB_reply_func+0x3c>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	ce cc       	rcall	8000236a <ShutDown_brdcst_func+0xe>
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	ce e8       	rjmp	80002372 <ShutDown_brdcst_func+0x16>

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	cf 00       	breq	800021b2 <SingleDetection_brdcst_func+0x1a>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	6d 30       	ld.w	r0,r6[0x4c]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	cf 14       	brge	800021c0 <SingleDetection_brdcst_func+0x28>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	cf 24       	brge	800021c6 <SingleDetection_brdcst_func+0x2e>

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	cf 38       	rjmp	80002480 <TransmitControl_brdcst_func+0x34>
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	6d 30       	ld.w	r0,r6[0x4c]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	cf 58       	rjmp	8000248c <TransmitControl_brdcst_func+0x40>
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	cf 6c       	rcall	80002492 <TransmitControl_brdcst_func+0x46>
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	cf 84       	brge	8000229a <ButtonConfig_brdcst_func+0xb6>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	cf a4       	brge	800022a2 <ButtonConfig_brdcst_func+0xbe>
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	cf cc       	rcall	800024aa <TransmitControl_reply_func+0x16>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	cf f4       	brge	800022b4 <ButtonConfig_brdcst_func+0xd0>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d0 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d0 40       	acall	0x4

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d0 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	6d 30       	ld.w	r0,r6[0x4c]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	cf 58       	rjmp	800024e8 <TransmitControl_reply_func+0x54>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d0 7c       	*unknown*

80002304 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 51       	brne	8000231e <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
80002316:	48 cc       	lddpc	r12,80002344 <BatteryLevel_brdcst_func+0x40>
80002318:	f0 1f 00 0c 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
8000231c:	c0 48       	rjmp	80002324 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
8000231e:	48 cc       	lddpc	r12,8000234c <BatteryLevel_brdcst_func+0x48>
80002320:	f0 1f 00 0a 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
		
	log("\n Battery charge: %X \n" , ptr->Charge);
80002324:	0f 98       	ld.ub	r8,r7[0x1]
80002326:	1a d8       	st.w	--sp,r8
80002328:	48 ac       	lddpc	r12,80002350 <BatteryLevel_brdcst_func+0x4c>
8000232a:	f0 1f 00 08 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	log("\n Battery voltage: %X \n" , ptr->Voltage);
8000232e:	8e 98       	ld.uh	r8,r7[0x2]
80002330:	1a d8       	st.w	--sp,r8
80002332:	48 9c       	lddpc	r12,80002354 <BatteryLevel_brdcst_func+0x50>
80002334:	f0 1f 00 05 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	
	Battery_Flag = ptr->State;
80002338:	0f 89       	ld.ub	r9,r7[0x0]
8000233a:	48 88       	lddpc	r8,80002358 <BatteryLevel_brdcst_func+0x54>
8000233c:	b0 89       	st.b	r8[0x0],r9
8000233e:	2f ed       	sub	sp,-8

}
80002340:	e3 cd 80 80 	ldm	sp++,r7,pc
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d0 98       	*unknown*
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	6d 30       	ld.w	r0,r6[0x4c]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	d0 a8       	*unknown*
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	d0 bc       	*unknown*
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	d0 d4       	*unknown*
80002358:	00 00       	add	r0,r0
8000235a:	0a 41       	or	r1,r5

8000235c <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
8000235c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
8000235e:	19 a8       	ld.ub	r8,r12[0x2]
80002360:	30 19       	mov	r9,1
80002362:	f2 08 18 00 	cp.b	r8,r9
80002366:	c0 51       	brne	80002370 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002368:	48 6c       	lddpc	r12,80002380 <ShutDown_brdcst_func+0x24>
8000236a:	f0 1f 00 07 	mcall	80002384 <ShutDown_brdcst_func+0x28>
8000236e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002370:	30 29       	mov	r9,2
80002372:	f2 08 18 00 	cp.b	r8,r9
80002376:	c0 41       	brne	8000237e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002378:	48 4c       	lddpc	r12,80002388 <ShutDown_brdcst_func+0x2c>
8000237a:	f0 1f 00 03 	mcall	80002384 <ShutDown_brdcst_func+0x28>
8000237e:	d8 02       	popm	pc
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d0 ec       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	6d 30       	ld.w	r0,r6[0x4c]
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d1 00       	acall	0x10

8000238c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000238c:	eb cd 40 80 	pushm	r7,lr
80002390:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002392:	19 a9       	ld.ub	r9,r12[0x2]
80002394:	30 08       	mov	r8,0
80002396:	f0 09 18 00 	cp.b	r9,r8
8000239a:	c1 11       	brne	800023bc <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
8000239c:	49 3c       	lddpc	r12,800023e8 <DataSession_reply_func+0x5c>
8000239e:	f0 1f 00 14 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800023a2:	0f b8       	ld.ub	r8,r7[0x3]
800023a4:	1a d8       	st.w	--sp,r8
800023a6:	49 3c       	lddpc	r12,800023f0 <DataSession_reply_func+0x64>
800023a8:	f0 1f 00 11 	mcall	800023ec <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800023ac:	0f c8       	ld.ub	r8,r7[0x4]
800023ae:	1a d8       	st.w	--sp,r8
800023b0:	49 1c       	lddpc	r12,800023f4 <DataSession_reply_func+0x68>
800023b2:	f0 1f 00 0f 	mcall	800023ec <DataSession_reply_func+0x60>
800023b6:	2f ed       	sub	sp,-8
800023b8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023bc:	48 fc       	lddpc	r12,800023f8 <DataSession_reply_func+0x6c>
800023be:	f0 1f 00 0c 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023c2:	0f a8       	ld.ub	r8,r7[0x2]
800023c4:	1a d8       	st.w	--sp,r8
800023c6:	48 ec       	lddpc	r12,800023fc <DataSession_reply_func+0x70>
800023c8:	f0 1f 00 09 	mcall	800023ec <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800023cc:	0f b8       	ld.ub	r8,r7[0x3]
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x74>
800023d2:	f0 1f 00 07 	mcall	800023ec <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023d6:	0f c8       	ld.ub	r8,r7[0x4]
800023d8:	1a d8       	st.w	--sp,r8
800023da:	48 bc       	lddpc	r12,80002404 <DataSession_reply_func+0x78>
800023dc:	f0 1f 00 04 	mcall	800023ec <DataSession_reply_func+0x60>
800023e0:	2f dd       	sub	sp,-12
800023e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800023e6:	00 00       	add	r0,r0
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	d1 10       	acall	0x11
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	6d 30       	ld.w	r0,r6[0x4c]
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	d1 20       	acall	0x12
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d1 2c       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	d1 38       	*unknown*
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d1 48       	*unknown*
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d1 58       	*unknown*
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d1 64       	*unknown*

80002408 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002408:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000240c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002410:	0f 98       	ld.ub	r8,r7[0x1]
80002412:	1a d8       	st.w	--sp,r8
80002414:	48 bc       	lddpc	r12,80002440 <CallControl_brdcst_func+0x38>
80002416:	f0 1f 00 0c 	mcall	80002444 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000241a:	2f fd       	sub	sp,-4
8000241c:	0f 99       	ld.ub	r9,r7[0x1]
8000241e:	30 38       	mov	r8,3
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c0 41       	brne	8000242c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002426:	30 09       	mov	r9,0
80002428:	48 88       	lddpc	r8,80002448 <CallControl_brdcst_func+0x40>
8000242a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000242c:	0f 99       	ld.ub	r9,r7[0x1]
8000242e:	30 48       	mov	r8,4
80002430:	f0 09 18 00 	cp.b	r9,r8
80002434:	c0 41       	brne	8000243c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002436:	30 19       	mov	r9,1
80002438:	48 48       	lddpc	r8,80002448 <CallControl_brdcst_func+0x40>
8000243a:	b0 89       	st.b	r8[0x0],r9
8000243c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002440:	80 00       	ld.sh	r0,r0[0x0]
80002442:	d1 70       	acall	0x17
80002444:	80 00       	ld.sh	r0,r0[0x0]
80002446:	6d 30       	ld.w	r0,r6[0x4c]
80002448:	00 00       	add	r0,r0
8000244a:	0a 4b       	or	r11,r5

8000244c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000244c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002450:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002454:	0f 99       	ld.ub	r9,r7[0x1]
80002456:	30 08       	mov	r8,0
80002458:	f0 09 18 00 	cp.b	r9,r8
8000245c:	c0 71       	brne	8000246a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000245e:	48 ac       	lddpc	r12,80002484 <TransmitControl_brdcst_func+0x38>
80002460:	f0 1f 00 0a 	mcall	80002488 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002464:	30 09       	mov	r9,0
80002466:	48 a8       	lddpc	r8,8000248c <TransmitControl_brdcst_func+0x40>
80002468:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000246a:	0f 99       	ld.ub	r9,r7[0x1]
8000246c:	30 18       	mov	r8,1
8000246e:	f0 09 18 00 	cp.b	r9,r8
80002472:	c0 71       	brne	80002480 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002474:	48 7c       	lddpc	r12,80002490 <TransmitControl_brdcst_func+0x44>
80002476:	f0 1f 00 05 	mcall	80002488 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000247a:	30 19       	mov	r9,1
8000247c:	48 48       	lddpc	r8,8000248c <TransmitControl_brdcst_func+0x40>
8000247e:	b0 89       	st.b	r8[0x0],r9
80002480:	e3 cd 80 80 	ldm	sp++,r7,pc
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	d1 88       	*unknown*
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	6d 30       	ld.w	r0,r6[0x4c]
8000248c:	00 00       	add	r0,r0
8000248e:	0a 4a       	or	r10,r5
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d1 a0       	acall	0x1a

80002494 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 61       	brne	800024d0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024a6:	48 ec       	lddpc	r12,800024dc <TransmitControl_reply_func+0x48>
800024a8:	f0 1f 00 0e 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024ac:	0f 98       	ld.ub	r8,r7[0x1]
800024ae:	1a d8       	st.w	--sp,r8
800024b0:	48 dc       	lddpc	r12,800024e4 <TransmitControl_reply_func+0x50>
800024b2:	f0 1f 00 0c 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024b6:	0f a8       	ld.ub	r8,r7[0x2]
800024b8:	1a d8       	st.w	--sp,r8
800024ba:	48 cc       	lddpc	r12,800024e8 <TransmitControl_reply_func+0x54>
800024bc:	f0 1f 00 09 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024c0:	0f b8       	ld.ub	r8,r7[0x3]
800024c2:	1a d8       	st.w	--sp,r8
800024c4:	48 ac       	lddpc	r12,800024ec <TransmitControl_reply_func+0x58>
800024c6:	f0 1f 00 07 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
800024ca:	2f dd       	sub	sp,-12
800024cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024d0:	48 8c       	lddpc	r12,800024f0 <TransmitControl_reply_func+0x5c>
800024d2:	f0 1f 00 04 	mcall	800024e0 <TransmitControl_reply_func+0x4c>
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024da:	00 00       	add	r0,r0
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d1 b4       	*unknown*
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	6d 30       	ld.w	r0,r6[0x4c]
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d1 d0       	acall	0x1d
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	d1 e4       	*unknown*
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d2 00       	acall	0x20
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d2 10       	acall	0x21

800024f4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024f6:	19 a9       	ld.ub	r9,r12[0x2]
800024f8:	30 08       	mov	r8,0
800024fa:	f0 09 18 00 	cp.b	r9,r8
800024fe:	c0 51       	brne	80002508 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002500:	48 4c       	lddpc	r12,80002510 <AudioRoutingControl_reply_func+0x1c>
80002502:	f0 1f 00 05 	mcall	80002514 <AudioRoutingControl_reply_func+0x20>
80002506:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002508:	48 4c       	lddpc	r12,80002518 <AudioRoutingControl_reply_func+0x24>
8000250a:	f0 1f 00 03 	mcall	80002514 <AudioRoutingControl_reply_func+0x20>
8000250e:	d8 02       	popm	pc
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	d2 28       	*unknown*
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	6d 30       	ld.w	r0,r6[0x4c]
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	d2 38       	*unknown*

8000251c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002524:	0f 89       	ld.ub	r9,r7[0x0]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c1 b1       	brne	80002562 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000252e:	0f b8       	ld.ub	r8,r7[0x3]
80002530:	31 09       	mov	r9,16
80002532:	f2 08 18 00 	cp.b	r8,r9
80002536:	c0 f1       	brne	80002554 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002538:	48 dc       	lddpc	r12,8000256c <Volume_reply_func+0x50>
8000253a:	f0 1f 00 0e 	mcall	80002570 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000253e:	0f 99       	ld.ub	r9,r7[0x1]
80002540:	0f a8       	ld.ub	r8,r7[0x2]
80002542:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002546:	1a d8       	st.w	--sp,r8
80002548:	48 bc       	lddpc	r12,80002574 <Volume_reply_func+0x58>
8000254a:	f0 1f 00 0a 	mcall	80002570 <Volume_reply_func+0x54>
8000254e:	2f fd       	sub	sp,-4
80002550:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 9c       	lddpc	r12,80002578 <Volume_reply_func+0x5c>
80002558:	f0 1f 00 06 	mcall	80002570 <Volume_reply_func+0x54>
8000255c:	2f fd       	sub	sp,-4
8000255e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002562:	48 7c       	lddpc	r12,8000257c <Volume_reply_func+0x60>
80002564:	f0 1f 00 03 	mcall	80002570 <Volume_reply_func+0x54>
80002568:	e3 cd 80 80 	ldm	sp++,r7,pc
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d2 4c       	*unknown*
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	6d 30       	ld.w	r0,r6[0x4c]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d2 60       	acall	0x26
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	d2 7c       	*unknown*
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	d2 94       	*unknown*

80002580 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002582:	19 d9       	ld.ub	r9,r12[0x5]
80002584:	30 08       	mov	r8,0
80002586:	f0 09 18 00 	cp.b	r9,r8
8000258a:	c0 81       	brne	8000259a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000258c:	10 99       	mov	r9,r8
8000258e:	48 78       	lddpc	r8,800025a8 <spk_brdcst_func+0x28>
80002590:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002592:	48 7c       	lddpc	r12,800025ac <spk_brdcst_func+0x2c>
80002594:	f0 1f 00 07 	mcall	800025b0 <spk_brdcst_func+0x30>
80002598:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000259a:	30 19       	mov	r9,1
8000259c:	48 38       	lddpc	r8,800025a8 <spk_brdcst_func+0x28>
8000259e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025a0:	48 5c       	lddpc	r12,800025b4 <spk_brdcst_func+0x34>
800025a2:	f0 1f 00 04 	mcall	800025b0 <spk_brdcst_func+0x30>
800025a6:	d8 02       	popm	pc
800025a8:	00 00       	add	r0,r0
800025aa:	0a 40       	or	r0,r5
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	d2 ac       	*unknown*
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	6d 30       	ld.w	r0,r6[0x4c]
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	d2 bc       	*unknown*

800025b8 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025ba:	19 a9       	ld.ub	r9,r12[0x2]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 f1       	brne	800025e0 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025c4:	19 e9       	ld.ub	r9,r12[0x6]
800025c6:	f0 09 18 00 	cp.b	r9,r8
800025ca:	c0 40       	breq	800025d2 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025cc:	30 19       	mov	r9,1
800025ce:	48 98       	lddpc	r8,800025f0 <spk_reply_func+0x38>
800025d0:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025d2:	19 e8       	ld.ub	r8,r12[0x6]
800025d4:	1a d8       	st.w	--sp,r8
800025d6:	48 8c       	lddpc	r12,800025f4 <spk_reply_func+0x3c>
800025d8:	f0 1f 00 08 	mcall	800025f8 <spk_reply_func+0x40>
800025dc:	2f fd       	sub	sp,-4
800025de:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025e0:	30 09       	mov	r9,0
800025e2:	48 48       	lddpc	r8,800025f0 <spk_reply_func+0x38>
800025e4:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025e6:	48 6c       	lddpc	r12,800025fc <spk_reply_func+0x44>
800025e8:	f0 1f 00 04 	mcall	800025f8 <spk_reply_func+0x40>
800025ec:	d8 02       	popm	pc
800025ee:	00 00       	add	r0,r0
800025f0:	00 00       	add	r0,r0
800025f2:	0a 40       	or	r0,r5
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	d2 c8       	*unknown*
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	6d 30       	ld.w	r0,r6[0x4c]
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	d2 d8       	*unknown*

80002600 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002600:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002604:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002608:	0f a9       	ld.ub	r9,r7[0x2]
8000260a:	30 08       	mov	r8,0
8000260c:	f0 09 18 00 	cp.b	r9,r8
80002610:	c0 71       	brne	8000261e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002612:	48 dc       	lddpc	r12,80002644 <mic_brdcst_func+0x44>
80002614:	f0 1f 00 0d 	mcall	80002648 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002618:	30 09       	mov	r9,0
8000261a:	48 d8       	lddpc	r8,8000264c <mic_brdcst_func+0x4c>
8000261c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000261e:	0f a9       	ld.ub	r9,r7[0x2]
80002620:	31 18       	mov	r8,17
80002622:	f0 09 18 00 	cp.b	r9,r8
80002626:	c0 d1       	brne	80002640 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002628:	48 ac       	lddpc	r12,80002650 <mic_brdcst_func+0x50>
8000262a:	f0 1f 00 08 	mcall	80002648 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
8000262e:	48 89       	lddpc	r9,8000264c <mic_brdcst_func+0x4c>
80002630:	30 18       	mov	r8,1
80002632:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002634:	13 89       	ld.ub	r9,r9[0x0]
80002636:	f0 09 18 00 	cp.b	r9,r8
8000263a:	c0 31       	brne	80002640 <mic_brdcst_func+0x40>
8000263c:	48 68       	lddpc	r8,80002654 <mic_brdcst_func+0x54>
8000263e:	11 88       	ld.ub	r8,r8[0x0]
80002640:	e3 cd 80 80 	ldm	sp++,r7,pc
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	d2 e4       	*unknown*
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	6d 30       	ld.w	r0,r6[0x4c]
8000264c:	00 00       	add	r0,r0
8000264e:	0a 56       	eor	r6,r5
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d2 f8       	*unknown*
80002654:	00 00       	add	r0,r0
80002656:	0a 4b       	or	r11,r5

80002658 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002658:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
8000265c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002660:	49 ac       	lddpc	r12,800026c8 <mic_reply_func+0x70>
80002662:	f0 1f 00 1b 	mcall	800026cc <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002666:	0f 89       	ld.ub	r9,r7[0x0]
80002668:	30 08       	mov	r8,0
8000266a:	f0 09 18 00 	cp.b	r9,r8
8000266e:	c2 71       	brne	800026bc <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002670:	0f 98       	ld.ub	r8,r7[0x1]
80002672:	30 29       	mov	r9,2
80002674:	f2 08 18 00 	cp.b	r8,r9
80002678:	c1 b1       	brne	800026ae <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000267a:	49 6c       	lddpc	r12,800026d0 <mic_reply_func+0x78>
8000267c:	f0 1f 00 14 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002680:	0f a8       	ld.ub	r8,r7[0x2]
80002682:	1a d8       	st.w	--sp,r8
80002684:	49 4c       	lddpc	r12,800026d4 <mic_reply_func+0x7c>
80002686:	f0 1f 00 12 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000268a:	0f b8       	ld.ub	r8,r7[0x3]
8000268c:	1a d8       	st.w	--sp,r8
8000268e:	49 3c       	lddpc	r12,800026d8 <mic_reply_func+0x80>
80002690:	f0 1f 00 0f 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002694:	0f c8       	ld.ub	r8,r7[0x4]
80002696:	1a d8       	st.w	--sp,r8
80002698:	49 1c       	lddpc	r12,800026dc <mic_reply_func+0x84>
8000269a:	f0 1f 00 0d 	mcall	800026cc <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000269e:	0f d8       	ld.ub	r8,r7[0x5]
800026a0:	1a d8       	st.w	--sp,r8
800026a2:	49 0c       	lddpc	r12,800026e0 <mic_reply_func+0x88>
800026a4:	f0 1f 00 0a 	mcall	800026cc <mic_reply_func+0x74>
800026a8:	2f cd       	sub	sp,-16
800026aa:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ae:	1a d8       	st.w	--sp,r8
800026b0:	48 dc       	lddpc	r12,800026e4 <mic_reply_func+0x8c>
800026b2:	f0 1f 00 07 	mcall	800026cc <mic_reply_func+0x74>
800026b6:	2f fd       	sub	sp,-4
800026b8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026bc:	48 bc       	lddpc	r12,800026e8 <mic_reply_func+0x90>
800026be:	f0 1f 00 04 	mcall	800026cc <mic_reply_func+0x74>
800026c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c6:	00 00       	add	r0,r0
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	d3 0c       	*unknown*
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	6d 30       	ld.w	r0,r6[0x4c]
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	d3 1c       	*unknown*
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	d3 30       	acall	0x33
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d3 44       	*unknown*
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d3 60       	acall	0x36
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	d3 78       	*unknown*
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	d3 90       	acall	0x39
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	d3 a8       	*unknown*

800026ec <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026ec:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026f4:	48 bc       	lddpc	r12,80002720 <dcm_brdcst_func+0x34>
800026f6:	f0 1f 00 0c 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026fa:	0f 88       	ld.ub	r8,r7[0x0]
800026fc:	1a d8       	st.w	--sp,r8
800026fe:	48 bc       	lddpc	r12,80002728 <dcm_brdcst_func+0x3c>
80002700:	f0 1f 00 09 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002704:	0f a8       	ld.ub	r8,r7[0x2]
80002706:	1a d8       	st.w	--sp,r8
80002708:	48 9c       	lddpc	r12,8000272c <dcm_brdcst_func+0x40>
8000270a:	f0 1f 00 07 	mcall	80002724 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000270e:	0f 98       	ld.ub	r8,r7[0x1]
80002710:	1a d8       	st.w	--sp,r8
80002712:	48 8c       	lddpc	r12,80002730 <dcm_brdcst_func+0x44>
80002714:	f0 1f 00 04 	mcall	80002724 <dcm_brdcst_func+0x38>
80002718:	2f dd       	sub	sp,-12
	
	
}
8000271a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271e:	00 00       	add	r0,r0
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	d3 b8       	*unknown*
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	6d 30       	ld.w	r0,r6[0x4c]
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	d3 cc       	*unknown*
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	d3 e0       	acall	0x3e
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d3 f8       	*unknown*

80002734 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002734:	eb cd 40 80 	pushm	r7,lr
80002738:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000273a:	19 a9       	ld.ub	r9,r12[0x2]
8000273c:	30 08       	mov	r8,0
8000273e:	f0 09 18 00 	cp.b	r9,r8
80002742:	c1 b1       	brne	80002778 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002744:	19 b8       	ld.ub	r8,r12[0x3]
80002746:	30 19       	mov	r9,1
80002748:	f2 08 18 00 	cp.b	r8,r9
8000274c:	c0 51       	brne	80002756 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000274e:	48 ec       	lddpc	r12,80002784 <dcm_reply_func+0x50>
80002750:	f0 1f 00 0e 	mcall	80002788 <dcm_reply_func+0x54>
80002754:	c0 a8       	rjmp	80002768 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002756:	58 08       	cp.w	r8,0
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000275a:	48 dc       	lddpc	r12,8000278c <dcm_reply_func+0x58>
8000275c:	f0 1f 00 0b 	mcall	80002788 <dcm_reply_func+0x54>
80002760:	c0 48       	rjmp	80002768 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002762:	48 cc       	lddpc	r12,80002790 <dcm_reply_func+0x5c>
80002764:	f0 1f 00 09 	mcall	80002788 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002768:	0f d8       	ld.ub	r8,r7[0x5]
8000276a:	1a d8       	st.w	--sp,r8
8000276c:	48 ac       	lddpc	r12,80002794 <dcm_reply_func+0x60>
8000276e:	f0 1f 00 07 	mcall	80002788 <dcm_reply_func+0x54>
80002772:	2f fd       	sub	sp,-4
80002774:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002778:	48 8c       	lddpc	r12,80002798 <dcm_reply_func+0x64>
8000277a:	f0 1f 00 04 	mcall	80002788 <dcm_reply_func+0x54>
8000277e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002782:	00 00       	add	r0,r0
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	d4 14       	*unknown*
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	6d 30       	ld.w	r0,r6[0x4c]
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	d4 28       	*unknown*
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	d4 3c       	*unknown*
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	d4 50       	acall	0x45
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	d4 5c       	*unknown*

8000279c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000279c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000279e:	19 a9       	ld.ub	r9,r12[0x2]
800027a0:	30 08       	mov	r8,0
800027a2:	f0 09 18 00 	cp.b	r9,r8
800027a6:	c0 51       	brne	800027b0 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800027a8:	48 4c       	lddpc	r12,800027b8 <ToneControl_reply_func+0x1c>
800027aa:	f0 1f 00 05 	mcall	800027bc <ToneControl_reply_func+0x20>
800027ae:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027b0:	48 4c       	lddpc	r12,800027c0 <ToneControl_reply_func+0x24>
800027b2:	f0 1f 00 03 	mcall	800027bc <ToneControl_reply_func+0x20>
800027b6:	d8 02       	popm	pc
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	d4 68       	*unknown*
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	6d 30       	ld.w	r0,r6[0x4c]
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	d4 74       	*unknown*

800027c4 <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027c4:	d4 31       	pushm	r0-r7,lr
800027c6:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c8:	31 ac       	mov	r12,26
800027ca:	f0 1f 00 29 	mcall	8000286c <app_cfg+0xa8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027ce:	f0 1f 00 29 	mcall	80002870 <app_cfg+0xac>
800027d2:	4a 98       	lddpc	r8,80002874 <app_cfg+0xb0>
800027d4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
800027d6:	4a 97       	lddpc	r7,80002878 <app_cfg+0xb4>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027d8:	4a 96       	lddpc	r6,8000287c <app_cfg+0xb8>
				else
				{
					nop();
					nop();
					nop();
					log("connecting...\n");
800027da:	4a a5       	lddpc	r5,80002880 <app_cfg+0xbc>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027dc:	4a a4       	lddpc	r4,80002884 <app_cfg+0xc0>
				{
					connect_flag=1;
800027de:	30 13       	mov	r3,1
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027e0:	30 c2       	mov	r2,12
800027e2:	30 11       	mov	r1,1
					OB_State = OB_WAITINGAPPTASK;
800027e4:	30 30       	mov	r0,3
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
800027e6:	6e 08       	ld.w	r8,r7[0x0]
800027e8:	58 08       	cp.w	r8,0
800027ea:	c0 40       	breq	800027f2 <app_cfg+0x2e>
800027ec:	58 38       	cp.w	r8,3
800027ee:	c3 91       	brne	80002860 <app_cfg+0x9c>
800027f0:	c1 a8       	rjmp	80002824 <app_cfg+0x60>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	6c 08       	ld.w	r8,r6[0x0]
800027f4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f8:	58 38       	cp.w	r8,3
800027fa:	c0 e1       	brne	80002816 <app_cfg+0x52>
800027fc:	09 88       	ld.ub	r8,r4[0x0]
800027fe:	58 08       	cp.w	r8,0
80002800:	c0 b1       	brne	80002816 <app_cfg+0x52>
				{
					connect_flag=1;
80002802:	a8 83       	st.b	r4[0x0],r3
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002804:	04 9b       	mov	r11,r2
80002806:	02 9c       	mov	r12,r1
80002808:	f0 1f 00 20 	mcall	80002888 <app_cfg+0xc4>
					OB_State = OB_WAITINGAPPTASK;
8000280c:	8f 00       	st.w	r7[0x0],r0
					log("connect OB okay!\n");
8000280e:	4a 0c       	lddpc	r12,8000288c <app_cfg+0xc8>
80002810:	f0 1f 00 20 	mcall	80002890 <app_cfg+0xcc>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002814:	c2 68       	rjmp	80002860 <app_cfg+0x9c>
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002816:	d7 03       	nop
					nop();
80002818:	d7 03       	nop
					nop();
8000281a:	d7 03       	nop
					log("connecting...\n");
8000281c:	0a 9c       	mov	r12,r5
8000281e:	f0 1f 00 1d 	mcall	80002890 <app_cfg+0xcc>
80002822:	c1 f8       	rjmp	80002860 <app_cfg+0x9c>
				}
								
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002824:	49 c8       	lddpc	r8,80002894 <app_cfg+0xd0>
80002826:	70 0c       	ld.w	r12,r8[0x0]
80002828:	30 09       	mov	r9,0
8000282a:	e0 6a 0f a0 	mov	r10,4000
8000282e:	1a 9b       	mov	r11,sp
80002830:	f0 1f 00 1a 	mcall	80002898 <app_cfg+0xd4>
80002834:	58 1c       	cp.w	r12,1
80002836:	c1 11       	brne	80002858 <app_cfg+0x94>
					{
						if(data_ptr!=NULL){//resend message
80002838:	40 08       	lddsp	r8,sp[0x0]
8000283a:	58 08       	cp.w	r8,0
8000283c:	c0 e0       	breq	80002858 <app_cfg+0x94>
							
							log("receive Okay!\n");						
8000283e:	49 8c       	lddpc	r12,8000289c <app_cfg+0xd8>
80002840:	f0 1f 00 14 	mcall	80002890 <app_cfg+0xcc>
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
80002844:	30 9a       	mov	r10,9
80002846:	31 ab       	mov	r11,26
80002848:	40 0c       	lddsp	r12,sp[0x0]
8000284a:	f0 1f 00 16 	mcall	800028a0 <app_cfg+0xdc>
							set_message_store(data_ptr);
8000284e:	49 68       	lddpc	r8,800028a4 <app_cfg+0xe0>
80002850:	70 0c       	ld.w	r12,r8[0x0]
80002852:	40 0b       	lddsp	r11,sp[0x0]
80002854:	f0 1f 00 15 	mcall	800028a8 <app_cfg+0xe4>
							
						}
						
					}
										
					nop();
80002858:	d7 03       	nop
					log("app task run!\n");
8000285a:	49 5c       	lddpc	r12,800028ac <app_cfg+0xe8>
8000285c:	f0 1f 00 0d 	mcall	80002890 <app_cfg+0xcc>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002860:	e0 6b 0f a0 	mov	r11,4000
80002864:	48 4c       	lddpc	r12,80002874 <app_cfg+0xb0>
80002866:	f0 1f 00 13 	mcall	800028b0 <app_cfg+0xec>
	}
8000286a:	cb eb       	rjmp	800027e6 <app_cfg+0x22>
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	5d fc       	*unknown*
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	66 5c       	ld.w	r12,r3[0x14]
80002874:	00 00       	add	r0,r0
80002876:	0a 44       	or	r4,r5
80002878:	00 00       	add	r0,r0
8000287a:	0a 58       	eor	r8,r5
8000287c:	00 00       	add	r0,r0
8000287e:	0d 94       	ld.ub	r4,r6[0x1]
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	d4 94       	*unknown*
80002884:	00 00       	add	r0,r0
80002886:	0a 55       	eor	r5,r5
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	3f 40       	mov	r0,-12
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	d4 80       	acall	0x48
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	6d 30       	ld.w	r0,r6[0x4c]
80002894:	00 00       	add	r0,r0
80002896:	0b 6c       	ld.uh	r12,--r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	5f 44       	srge	r4
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	d4 a4       	*unknown*
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	3e 08       	mov	r8,-32
800028a4:	00 00       	add	r0,r0
800028a6:	0b 70       	ld.ub	r0,--r5
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	2a dc       	sub	r12,-83
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	d4 b4       	*unknown*
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	68 0c       	ld.w	r12,r4[0x0]

800028b4 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800028b4:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800028b8:	19 c7       	ld.ub	r7,r12[0x4]
800028ba:	19 d8       	ld.ub	r8,r12[0x5]
800028bc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800028c0:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800028c2:	48 dc       	lddpc	r12,800028f4 <Phyuserinput_brdcst_func+0x40>
800028c4:	f0 1f 00 0d 	mcall	800028f8 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800028c8:	36 08       	mov	r8,96
800028ca:	f0 07 19 00 	cp.h	r7,r8
800028ce:	c1 11       	brne	800028f0 <Phyuserinput_brdcst_func+0x3c>
800028d0:	48 b8       	lddpc	r8,800028fc <Phyuserinput_brdcst_func+0x48>
800028d2:	11 89       	ld.ub	r9,r8[0x0]
800028d4:	30 18       	mov	r8,1
800028d6:	f0 09 18 00 	cp.b	r9,r8
800028da:	c0 b1       	brne	800028f0 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028dc:	31 4b       	mov	r11,20
800028de:	30 1c       	mov	r12,1
800028e0:	f0 1f 00 08 	mcall	80002900 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(200*2 / portTICK_RATE_MS);//延迟200ms
800028e4:	e0 6c 01 90 	mov	r12,400
800028e8:	f0 1f 00 07 	mcall	80002904 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028ec:	f0 1f 00 07 	mcall	80002908 <Phyuserinput_brdcst_func+0x54>
800028f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	d4 c4       	*unknown*
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	6d 30       	ld.w	r0,r6[0x4c]
800028fc:	00 00       	add	r0,r0
800028fe:	0a 55       	eor	r5,r5
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	3f 40       	mov	r0,-12
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	67 c4       	ld.w	r4,r3[0x70]
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	4f a4       	lddpc	r4,80002af0 <set_idle_store+0x14>

8000290c <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000290c:	d4 21       	pushm	r4-r7,lr
8000290e:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002910:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002914:	0d 88       	ld.ub	r8,r6[0x0]
80002916:	32 49       	mov	r9,36
80002918:	f2 08 18 00 	cp.b	r8,r9
8000291c:	c2 91       	brne	8000296e <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000291e:	4a ec       	lddpc	r12,800029d4 <DataSession_brdcst_func+0xc8>
80002920:	f0 1f 00 2e 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002924:	0d a5       	ld.ub	r5,r6[0x2]
80002926:	0d b8       	ld.ub	r8,r6[0x3]
80002928:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000292c:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000292e:	0d 98       	ld.ub	r8,r6[0x1]
80002930:	1a d8       	st.w	--sp,r8
80002932:	4a bc       	lddpc	r12,800029dc <DataSession_brdcst_func+0xd0>
80002934:	f0 1f 00 29 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002938:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000293c:	1a d8       	st.w	--sp,r8
8000293e:	4a 9c       	lddpc	r12,800029e0 <DataSession_brdcst_func+0xd4>
80002940:	f0 1f 00 26 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		for(i=0; i<data_length; i++)
80002944:	2f ed       	sub	sp,-8
80002946:	58 05       	cp.w	r5,0
80002948:	c4 30       	breq	800029ce <DataSession_brdcst_func+0xc2>
8000294a:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000294c:	4a 64       	lddpc	r4,800029e4 <DataSession_brdcst_func+0xd8>
8000294e:	ec 07 00 08 	add	r8,r6,r7
80002952:	11 c8       	ld.ub	r8,r8[0x4]
80002954:	1a d8       	st.w	--sp,r8
80002956:	1a d7       	st.w	--sp,r7
80002958:	08 9c       	mov	r12,r4
8000295a:	f0 1f 00 20 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000295e:	2f f7       	sub	r7,-1
80002960:	5c 57       	castu.b	r7
80002962:	2f ed       	sub	sp,-8
80002964:	ee 05 19 00 	cp.h	r5,r7
80002968:	fe 9b ff f3 	brhi	8000294e <DataSession_brdcst_func+0x42>
8000296c:	c3 18       	rjmp	800029ce <DataSession_brdcst_func+0xc2>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
8000296e:	1a d8       	st.w	--sp,r8
80002970:	49 ec       	lddpc	r12,800029e8 <DataSession_brdcst_func+0xdc>
80002972:	f0 1f 00 1a 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002976:	0d 88       	ld.ub	r8,r6[0x0]
80002978:	2f fd       	sub	sp,-4
8000297a:	30 39       	mov	r9,3
8000297c:	f2 08 18 00 	cp.b	r8,r9
80002980:	c0 51       	brne	8000298a <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002982:	49 bc       	lddpc	r12,800029ec <DataSession_brdcst_func+0xe0>
80002984:	f0 1f 00 15 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
80002988:	c2 38       	rjmp	800029ce <DataSession_brdcst_func+0xc2>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000298a:	30 49       	mov	r9,4
8000298c:	f2 08 18 00 	cp.b	r8,r9
80002990:	c1 f1       	brne	800029ce <DataSession_brdcst_func+0xc2>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002992:	31 aa       	mov	r10,26
80002994:	ec cb ff fc 	sub	r11,r6,-4
80002998:	fa cc ff fe 	sub	r12,sp,-2
8000299c:	f0 1f 00 15 	mcall	800029f0 <DataSession_brdcst_func+0xe4>

			Message_Protocol_t * myptr = get_message_store();	
800029a0:	49 58       	lddpc	r8,800029f4 <DataSession_brdcst_func+0xe8>
800029a2:	70 0c       	ld.w	r12,r8[0x0]
800029a4:	f0 1f 00 15 	mcall	800029f8 <DataSession_brdcst_func+0xec>
800029a8:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
800029aa:	c0 f0       	breq	800029c8 <DataSession_brdcst_func+0xbc>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
800029ac:	31 aa       	mov	r10,26
800029ae:	fa cb ff fe 	sub	r11,sp,-2
800029b2:	f0 1f 00 10 	mcall	800029f0 <DataSession_brdcst_func+0xe4>
				xQueueSend(xg_resend_queue, &myptr, 0);
800029b6:	49 28       	lddpc	r8,800029fc <DataSession_brdcst_func+0xf0>
800029b8:	70 0c       	ld.w	r12,r8[0x0]
800029ba:	30 09       	mov	r9,0
800029bc:	12 9a       	mov	r10,r9
800029be:	fa cb ff e4 	sub	r11,sp,-28
800029c2:	f0 1f 00 10 	mcall	80002a00 <DataSession_brdcst_func+0xf4>
800029c6:	c0 48       	rjmp	800029ce <DataSession_brdcst_func+0xc2>
			}
			else
			{
				log("myptr: err\n\r" );
800029c8:	48 fc       	lddpc	r12,80002a04 <DataSession_brdcst_func+0xf8>
800029ca:	f0 1f 00 04 	mcall	800029d8 <DataSession_brdcst_func+0xcc>
				//
		//}
		
	}
	
}
800029ce:	2f 8d       	sub	sp,-32
800029d0:	d8 22       	popm	r4-r7,pc
800029d2:	00 00       	add	r0,r0
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	d4 e4       	*unknown*
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	6d 30       	ld.w	r0,r6[0x4c]
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	d4 f8       	*unknown*
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	d5 10       	acall	0x51
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	d5 2c       	*unknown*
800029e8:	80 00       	ld.sh	r0,r0[0x0]
800029ea:	d5 44       	*unknown*
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	d5 50       	acall	0x55
800029f0:	80 00       	ld.sh	r0,r0[0x0]
800029f2:	75 ac       	ld.w	r12,r10[0x68]
800029f4:	00 00       	add	r0,r0
800029f6:	0b 70       	ld.ub	r0,--r5
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	2c 88       	sub	r8,-56
800029fc:	00 00       	add	r0,r0
800029fe:	0b 6c       	ld.uh	r12,--r5
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	61 50       	ld.w	r0,r0[0x54]
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	d5 68       	*unknown*

80002a08 <DeviceInitializationStatus_brdcst_func>:
extern volatile xSemaphoreHandle SendM_CountingSemaphore;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002a08:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002a0a:	19 e8       	ld.ub	r8,r12[0x6]
80002a0c:	30 19       	mov	r9,1
80002a0e:	f2 08 18 00 	cp.b	r8,r9
80002a12:	c0 61       	brne	80002a1e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a14:	48 98       	lddpc	r8,80002a38 <DeviceInitializationStatus_brdcst_func+0x30>
80002a16:	70 09       	ld.w	r9,r8[0x0]
80002a18:	a1 a9       	sbr	r9,0x0
80002a1a:	91 09       	st.w	r8[0x0],r9
80002a1c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002a1e:	30 29       	mov	r9,2
80002a20:	f2 08 18 00 	cp.b	r8,r9
80002a24:	c0 80       	breq	80002a34 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a26:	48 58       	lddpc	r8,80002a38 <DeviceInitializationStatus_brdcst_func+0x30>
80002a28:	70 09       	ld.w	r9,r8[0x0]
80002a2a:	e0 19 ff fc 	andl	r9,0xfffc
80002a2e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a30:	f0 1f 00 03 	mcall	80002a3c <DeviceInitializationStatus_brdcst_func+0x34>
80002a34:	d8 02       	popm	pc
80002a36:	00 00       	add	r0,r0
80002a38:	00 00       	add	r0,r0
80002a3a:	0d 94       	ld.ub	r4,r6[0x1]
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	3e 94       	mov	r4,-23

80002a40 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002a40:	20 1c       	sub	r12,1
80002a42:	5c 5c       	castu.b	r12
80002a44:	31 18       	mov	r8,17
80002a46:	f0 0c 18 00 	cp.b	r12,r8
80002a4a:	e0 88 00 03 	brls	80002a50 <CalculateBurst+0x10>
80002a4e:	5e fd       	retal	0
80002a50:	48 28       	lddpc	r8,80002a58 <CalculateBurst+0x18>
80002a52:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002a56:	5e fc       	retal	r12
80002a58:	80 00       	ld.sh	r0,r0[0x0]
80002a5a:	d5 78       	*unknown*

80002a5c <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002a5c:	48 38       	lddpc	r8,80002a68 <payload_init+0xc>
80002a5e:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002a60:	48 38       	lddpc	r8,80002a6c <payload_init+0x10>
80002a62:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002a64:	5e fc       	retal	r12
80002a66:	00 00       	add	r0,r0
80002a68:	00 00       	add	r0,r0
80002a6a:	0a 64       	and	r4,r5
80002a6c:	00 00       	add	r0,r0
80002a6e:	0a 68       	and	r8,r5

80002a70 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002a70:	d4 01       	pushm	lr
80002a72:	20 2d       	sub	sp,8
80002a74:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a76:	30 09       	mov	r9,0
80002a78:	fa ca ff f8 	sub	r10,sp,-8
80002a7c:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a7e:	1a 9b       	mov	r11,sp
80002a80:	f0 1f 00 02 	mcall	80002a88 <set_idle_store_isr+0x18>
}
80002a84:	2f ed       	sub	sp,-8
80002a86:	d8 02       	popm	pc
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	61 00       	ld.w	r0,r0[0x40]

80002a8c <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002a8c:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002a8e:	48 48       	lddpc	r8,80002a9c <payload_rx+0x10>
80002a90:	70 08       	ld.w	r8,r8[0x0]
80002a92:	18 9b       	mov	r11,r12
80002a94:	10 9c       	mov	r12,r8
80002a96:	f0 1f 00 03 	mcall	80002aa0 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002a9a:	d8 02       	popm	pc
80002a9c:	00 00       	add	r0,r0
80002a9e:	0a a0       	st.w	r5++,r0
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	2a 70       	sub	r0,-89

80002aa4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002aa4:	d4 01       	pushm	lr
80002aa6:	20 2d       	sub	sp,8
80002aa8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002aaa:	58 0c       	cp.w	r12,0
80002aac:	c1 10       	breq	80002ace <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002aae:	30 08       	mov	r8,0
80002ab0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002ab2:	98 88       	ld.uh	r8,r12[0x0]
80002ab4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ab8:	e0 48 40 00 	cp.w	r8,16384
80002abc:	c0 91       	brne	80002ace <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002abe:	48 68       	lddpc	r8,80002ad4 <phy_rx+0x30>
80002ac0:	70 0c       	ld.w	r12,r8[0x0]
80002ac2:	30 09       	mov	r9,0
80002ac4:	fa ca ff fc 	sub	r10,sp,-4
80002ac8:	1a 9b       	mov	r11,sp
80002aca:	f0 1f 00 04 	mcall	80002ad8 <phy_rx+0x34>
		}	

    }
		
 
}
80002ace:	2f ed       	sub	sp,-8
80002ad0:	d8 02       	popm	pc
80002ad2:	00 00       	add	r0,r0
80002ad4:	00 00       	add	r0,r0
80002ad6:	0a ac       	st.w	r5++,r12
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	61 00       	ld.w	r0,r0[0x40]

80002adc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002adc:	eb cd 40 80 	pushm	r7,lr
80002ae0:	20 1d       	sub	sp,4
80002ae2:	fa c7 ff fc 	sub	r7,sp,-4
80002ae6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002ae8:	30 09       	mov	r9,0
80002aea:	12 9a       	mov	r10,r9
80002aec:	1a 9b       	mov	r11,sp
80002aee:	f0 1f 00 03 	mcall	80002af8 <set_idle_store+0x1c>
}
80002af2:	2f fd       	sub	sp,-4
80002af4:	e3 cd 80 80 	ldm	sp++,r7,pc
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	61 50       	ld.w	r0,r0[0x54]

80002afc <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002afc:	d4 01       	pushm	lr
80002afe:	20 1d       	sub	sp,4
80002b00:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002b02:	98 88       	ld.uh	r8,r12[0x0]
80002b04:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b08:	e0 48 40 00 	cp.w	r8,16384
80002b0c:	c0 d1       	brne	80002b26 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b0e:	49 08       	lddpc	r8,80002b4c <phy_tx+0x50>
80002b10:	70 08       	ld.w	r8,r8[0x0]
80002b12:	58 08       	cp.w	r8,0
80002b14:	c1 a0       	breq	80002b48 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002b16:	48 e8       	lddpc	r8,80002b4c <phy_tx+0x50>
80002b18:	70 0c       	ld.w	r12,r8[0x0]
80002b1a:	30 09       	mov	r9,0
80002b1c:	12 9a       	mov	r10,r9
80002b1e:	1a 9b       	mov	r11,sp
80002b20:	f0 1f 00 0c 	mcall	80002b50 <phy_tx+0x54>
80002b24:	c1 28       	rjmp	80002b48 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002b26:	e0 48 10 00 	cp.w	r8,4096
80002b2a:	5f 0a       	sreq	r10
80002b2c:	e0 48 20 00 	cp.w	r8,8192
80002b30:	5f 09       	sreq	r9
80002b32:	f5 e9 10 09 	or	r9,r10,r9
80002b36:	c0 71       	brne	80002b44 <phy_tx+0x48>
80002b38:	e0 48 50 00 	cp.w	r8,20480
80002b3c:	c0 40       	breq	80002b44 <phy_tx+0x48>
80002b3e:	e0 48 60 00 	cp.w	r8,24576
80002b42:	c0 31       	brne	80002b48 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002b44:	48 48       	lddpc	r8,80002b54 <phy_tx+0x58>
80002b46:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002b48:	2f fd       	sub	sp,-4
80002b4a:	d8 02       	popm	pc
80002b4c:	00 00       	add	r0,r0
80002b4e:	0a cc       	st.b	r5++,r12
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	61 50       	ld.w	r0,r0[0x54]
80002b54:	00 00       	add	r0,r0
80002b56:	0a c0       	st.b	r5++,r0

80002b58 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002b58:	d4 01       	pushm	lr
80002b5a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002b5c:	30 08       	mov	r8,0
80002b5e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b60:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002b62:	1a 9a       	mov	r10,sp
80002b64:	fa cb ff fc 	sub	r11,sp,-4
80002b68:	f0 1f 00 05 	mcall	80002b7c <get_idle_store_isr+0x24>
80002b6c:	58 1c       	cp.w	r12,1
80002b6e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b72:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002b76:	2f ed       	sub	sp,-8
80002b78:	d8 02       	popm	pc
80002b7a:	00 00       	add	r0,r0
80002b7c:	80 00       	ld.sh	r0,r0[0x0]
80002b7e:	5e 54       	retlt	r4

80002b80 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b80:	eb cd 40 c0 	pushm	r6-r7,lr
80002b84:	20 1d       	sub	sp,4
80002b86:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b88:	4b a8       	lddpc	r8,80002c70 <phy_tx_func+0xf0>
80002b8a:	70 08       	ld.w	r8,r8[0x0]
80002b8c:	58 08       	cp.w	r8,0
80002b8e:	c6 60       	breq	80002c5a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b90:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b92:	30 08       	mov	r8,0
80002b94:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b96:	4b 88       	lddpc	r8,80002c74 <phy_tx_func+0xf4>
80002b98:	70 08       	ld.w	r8,r8[0x0]
80002b9a:	58 18       	cp.w	r8,1
80002b9c:	c2 60       	breq	80002be8 <phy_tx_func+0x68>
80002b9e:	c0 43       	brcs	80002ba6 <phy_tx_func+0x26>
80002ba0:	58 28       	cp.w	r8,2
80002ba2:	c5 c1       	brne	80002c5a <phy_tx_func+0xda>
80002ba4:	c5 58       	rjmp	80002c4e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ba6:	4b 38       	lddpc	r8,80002c70 <phy_tx_func+0xf0>
80002ba8:	70 0c       	ld.w	r12,r8[0x0]
80002baa:	1a 9a       	mov	r10,sp
80002bac:	4b 3b       	lddpc	r11,80002c78 <phy_tx_func+0xf8>
80002bae:	f0 1f 00 34 	mcall	80002c7c <phy_tx_func+0xfc>
80002bb2:	58 1c       	cp.w	r12,1
80002bb4:	c1 41       	brne	80002bdc <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002bb6:	4b 18       	lddpc	r8,80002c78 <phy_tx_func+0xf8>
80002bb8:	70 08       	ld.w	r8,r8[0x0]
80002bba:	90 08       	ld.sh	r8,r8[0x0]
80002bbc:	10 9a       	mov	r10,r8
80002bbe:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002bc2:	4b 09       	lddpc	r9,80002c80 <phy_tx_func+0x100>
80002bc4:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002bc6:	5c 78       	castu.h	r8
80002bc8:	ea 18 ab cd 	orh	r8,0xabcd
80002bcc:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002bce:	30 19       	mov	r9,1
80002bd0:	4a d8       	lddpc	r8,80002c84 <phy_tx_func+0x104>
80002bd2:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002bd4:	30 19       	mov	r9,1
80002bd6:	4a 88       	lddpc	r8,80002c74 <phy_tx_func+0xf4>
80002bd8:	91 09       	st.w	r8[0x0],r9
80002bda:	c4 08       	rjmp	80002c5a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002bdc:	e0 68 5a 5a 	mov	r8,23130
80002be0:	ea 18 ab cd 	orh	r8,0xabcd
80002be4:	8f 18       	st.w	r7[0x4],r8
80002be6:	c3 a8       	rjmp	80002c5a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002be8:	4a 7a       	lddpc	r10,80002c84 <phy_tx_func+0x104>
80002bea:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002bec:	4a 39       	lddpc	r9,80002c78 <phy_tx_func+0xf8>
80002bee:	72 09       	ld.w	r9,r9[0x0]
80002bf0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002bf4:	b1 69       	lsl	r9,0x10
80002bf6:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002bf8:	2f f8       	sub	r8,-1
80002bfa:	5c 58       	castu.b	r8
80002bfc:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002bfe:	4a 1b       	lddpc	r11,80002c80 <phy_tx_func+0x100>
80002c00:	96 0c       	ld.sh	r12,r11[0x0]
80002c02:	20 2c       	sub	r12,2
80002c04:	5c 8c       	casts.h	r12
80002c06:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002c0a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c0c:	30 0b       	mov	r11,0
80002c0e:	f6 0a 19 00 	cp.h	r10,r11
80002c12:	e0 89 00 09 	brgt	80002c24 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002c16:	e8 19 00 ba 	orl	r9,0xba
80002c1a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002c1c:	30 09       	mov	r9,0
80002c1e:	49 68       	lddpc	r8,80002c74 <phy_tx_func+0xf4>
80002c20:	91 09       	st.w	r8[0x0],r9
80002c22:	c1 c8       	rjmp	80002c5a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002c24:	49 5a       	lddpc	r10,80002c78 <phy_tx_func+0xf8>
80002c26:	74 0a       	ld.w	r10,r10[0x0]
80002c28:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002c2c:	14 49       	or	r9,r10
80002c2e:	8f 19       	st.w	r7[0x4],r9
80002c30:	2f f8       	sub	r8,-1
80002c32:	49 59       	lddpc	r9,80002c84 <phy_tx_func+0x104>
80002c34:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c36:	20 2c       	sub	r12,2
80002c38:	49 28       	lddpc	r8,80002c80 <phy_tx_func+0x100>
80002c3a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c3c:	30 08       	mov	r8,0
80002c3e:	f0 0c 19 00 	cp.h	r12,r8
80002c42:	e0 89 00 0c 	brgt	80002c5a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002c46:	30 29       	mov	r9,2
80002c48:	48 b8       	lddpc	r8,80002c74 <phy_tx_func+0xf4>
80002c4a:	91 09       	st.w	r8[0x0],r9
80002c4c:	c0 78       	rjmp	80002c5a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002c4e:	fc 18 00 ba 	movh	r8,0xba
80002c52:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c54:	30 09       	mov	r9,0
80002c56:	48 88       	lddpc	r8,80002c74 <phy_tx_func+0xf4>
80002c58:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002c5a:	e0 68 5a 5a 	mov	r8,23130
80002c5e:	ea 18 ab cd 	orh	r8,0xabcd
80002c62:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002c64:	30 08       	mov	r8,0
80002c66:	8f 38       	st.w	r7[0xc],r8
}
80002c68:	2f fd       	sub	sp,-4
80002c6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c6e:	00 00       	add	r0,r0
80002c70:	00 00       	add	r0,r0
80002c72:	0a cc       	st.b	r5++,r12
80002c74:	00 00       	add	r0,r0
80002c76:	0a 8c       	andn	r12,r5
80002c78:	00 00       	add	r0,r0
80002c7a:	0a 98       	mov	r8,r5
80002c7c:	80 00       	ld.sh	r0,r0[0x0]
80002c7e:	5e 54       	retlt	r4
80002c80:	00 00       	add	r0,r0
80002c82:	0a b4       	st.h	r5++,r4
80002c84:	00 00       	add	r0,r0
80002c86:	0a 6c       	and	r12,r5

80002c88 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002c88:	d4 01       	pushm	lr
80002c8a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002c8c:	30 0a       	mov	r10,0
80002c8e:	fa cb ff fc 	sub	r11,sp,-4
80002c92:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002c94:	14 99       	mov	r9,r10
80002c96:	1a 9b       	mov	r11,sp
80002c98:	f0 1f 00 05 	mcall	80002cac <get_idle_store+0x24>
80002c9c:	58 1c       	cp.w	r12,1
80002c9e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002ca2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002ca6:	2f fd       	sub	sp,-4
80002ca8:	d8 02       	popm	pc
80002caa:	00 00       	add	r0,r0
80002cac:	80 00       	ld.sh	r0,r0[0x0]
80002cae:	5f 44       	srge	r4

80002cb0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002cb0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002cb2:	48 5b       	lddpc	r11,80002cc4 <phy_init+0x14>
80002cb4:	48 5c       	lddpc	r12,80002cc8 <phy_init+0x18>
80002cb6:	f0 1f 00 06 	mcall	80002ccc <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002cba:	f0 1f 00 06 	mcall	80002cd0 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002cbe:	f0 1f 00 06 	mcall	80002cd4 <phy_init+0x24>
	
}
80002cc2:	d8 02       	popm	pc
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	2b 80       	sub	r0,-72
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	2c d8       	sub	r8,-51
80002ccc:	80 00       	ld.sh	r0,r0[0x0]
80002cce:	3d 2c       	mov	r12,-46
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	3d 40       	mov	r0,-44
80002cd4:	80 00       	ld.sh	r0,r0[0x0]
80002cd6:	46 ec       	lddsp	r12,sp[0x1b8]

80002cd8 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002cd8:	eb cd 40 e0 	pushm	r5-r7,lr
80002cdc:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002cde:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002ce2:	70 08       	ld.w	r8,r8[0x0]
80002ce4:	58 08       	cp.w	r8,0
80002ce6:	e0 80 01 08 	breq	80002ef6 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002cea:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002cec:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002cf0:	70 09       	ld.w	r9,r8[0x0]
80002cf2:	2f f9       	sub	r9,-1
80002cf4:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002cf6:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002cfa:	70 08       	ld.w	r8,r8[0x0]
80002cfc:	58 18       	cp.w	r8,1
80002cfe:	e0 80 00 85 	breq	80002e08 <phy_rx_func+0x130>
80002d02:	c0 73       	brcs	80002d10 <phy_rx_func+0x38>
80002d04:	58 28       	cp.w	r8,2
80002d06:	c5 c0       	breq	80002dbe <phy_rx_func+0xe6>
80002d08:	58 38       	cp.w	r8,3
80002d0a:	e0 81 00 f6 	brne	80002ef6 <phy_rx_func+0x21e>
80002d0e:	cd 58       	rjmp	80002eb8 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002d10:	e0 6a 5a 5a 	mov	r10,23130
80002d14:	ea 1a ab cd 	orh	r10,0xabcd
80002d18:	14 36       	cp.w	r6,r10
80002d1a:	e0 80 00 ee 	breq	80002ef6 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002d1e:	ec 08 16 10 	lsr	r8,r6,0x10
80002d22:	e0 48 ab cd 	cp.w	r8,43981
80002d26:	e0 81 00 e8 	brne	80002ef6 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002d2a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002d2e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002d32:	20 28       	sub	r8,2
80002d34:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002d38:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002d3a:	30 09       	mov	r9,0
80002d3c:	f2 08 19 00 	cp.h	r8,r9
80002d40:	e0 8a 00 db 	brle	80002ef6 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002d44:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002d48:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002d4a:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002d4e:	70 0c       	ld.w	r12,r8[0x0]
80002d50:	f0 1f 03 88 	mcall	80003b70 <phy_rx_func+0xe98>
80002d54:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002d58:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002d5a:	58 0c       	cp.w	r12,0
80002d5c:	e0 80 00 cd 	breq	80002ef6 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002d60:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002d64:	90 09       	ld.sh	r9,r8[0x0]
80002d66:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002d6a:	2f f9       	sub	r9,-1
80002d6c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d6e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002d72:	74 0a       	ld.w	r10,r10[0x0]
80002d74:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002d78:	76 0b       	ld.w	r11,r11[0x0]
80002d7a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002d7e:	2f f9       	sub	r9,-1
80002d80:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002d82:	e2 16 0f 00 	andl	r6,0xf00,COH
80002d86:	e0 46 01 00 	cp.w	r6,256
80002d8a:	c0 c0       	breq	80002da2 <phy_rx_func+0xca>
80002d8c:	e0 8b 00 05 	brhi	80002d96 <phy_rx_func+0xbe>
80002d90:	58 06       	cp.w	r6,0
80002d92:	c0 80       	breq	80002da2 <phy_rx_func+0xca>
80002d94:	c0 c8       	rjmp	80002dac <phy_rx_func+0xd4>
80002d96:	e0 46 02 00 	cp.w	r6,512
80002d9a:	c0 40       	breq	80002da2 <phy_rx_func+0xca>
80002d9c:	e0 46 03 00 	cp.w	r6,768
80002da0:	c0 61       	brne	80002dac <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002da2:	30 29       	mov	r9,2
80002da4:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002da8:	91 09       	st.w	r8[0x0],r9
80002daa:	ca 68       	rjmp	80002ef6 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002dac:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002db0:	70 0c       	ld.w	r12,r8[0x0]
80002db2:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002db6:	70 0b       	ld.w	r11,r8[0x0]
80002db8:	f0 1f 03 70 	mcall	80003b78 <phy_rx_func+0xea0>
80002dbc:	c9 d8       	rjmp	80002ef6 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002dbe:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002dc2:	b1 86       	lsr	r6,0x10
80002dc4:	14 06       	add	r6,r10
80002dc6:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002dca:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002dcc:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002dd0:	90 09       	ld.sh	r9,r8[0x0]
80002dd2:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002dd6:	76 0b       	ld.w	r11,r11[0x0]
80002dd8:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002ddc:	2f f9       	sub	r9,-1
80002dde:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002de0:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002de4:	92 08       	ld.sh	r8,r9[0x0]
80002de6:	20 28       	sub	r8,2
80002de8:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002dea:	30 09       	mov	r9,0
80002dec:	f2 08 19 00 	cp.h	r8,r9
80002df0:	e0 8a 00 07 	brle	80002dfe <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002df4:	30 19       	mov	r9,1
80002df6:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002dfa:	91 09       	st.w	r8[0x0],r9
80002dfc:	c7 d8       	rjmp	80002ef6 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002dfe:	30 39       	mov	r9,3
80002e00:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002e04:	91 09       	st.w	r8[0x0],r9
80002e06:	c7 88       	rjmp	80002ef6 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002e08:	ec 0a 14 10 	asr	r10,r6,0x10
80002e0c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002e10:	90 09       	ld.sh	r9,r8[0x0]
80002e12:	14 09       	add	r9,r10
80002e14:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e16:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002e1a:	92 08       	ld.sh	r8,r9[0x0]
80002e1c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002e20:	76 0b       	ld.w	r11,r11[0x0]
80002e22:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002e26:	2f f8       	sub	r8,-1
80002e28:	5c 88       	casts.h	r8
80002e2a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002e2c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002e30:	94 09       	ld.sh	r9,r10[0x0]
80002e32:	20 29       	sub	r9,2
80002e34:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002e36:	30 0a       	mov	r10,0
80002e38:	f4 09 19 00 	cp.h	r9,r10
80002e3c:	e0 89 00 20 	brgt	80002e7c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002e40:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002e44:	e0 46 00 ba 	cp.w	r6,186
80002e48:	c0 d1       	brne	80002e62 <phy_rx_func+0x18a>
80002e4a:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002e4e:	90 09       	ld.sh	r9,r8[0x0]
80002e50:	f4 09 19 00 	cp.h	r9,r10
80002e54:	c0 71       	brne	80002e62 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002e56:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002e5a:	70 0c       	ld.w	r12,r8[0x0]
80002e5c:	f0 1f 03 49 	mcall	80003b80 <phy_rx_func+0xea8>
80002e60:	c0 98       	rjmp	80002e72 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002e62:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002e66:	70 0c       	ld.w	r12,r8[0x0]
80002e68:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002e6c:	70 0b       	ld.w	r11,r8[0x0]
80002e6e:	f0 1f 03 43 	mcall	80003b78 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002e72:	30 09       	mov	r9,0
80002e74:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002e78:	91 09       	st.w	r8[0x0],r9
80002e7a:	c3 e8       	rjmp	80002ef6 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002e7c:	5c 86       	casts.h	r6
80002e7e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002e82:	92 0a       	ld.sh	r10,r9[0x0]
80002e84:	0c 0a       	add	r10,r6
80002e86:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e88:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002e8c:	72 09       	ld.w	r9,r9[0x0]
80002e8e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002e92:	2f f8       	sub	r8,-1
80002e94:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002e98:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002e9a:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002e9e:	92 08       	ld.sh	r8,r9[0x0]
80002ea0:	20 28       	sub	r8,2
80002ea2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002ea4:	30 09       	mov	r9,0
80002ea6:	f2 08 19 00 	cp.h	r8,r9
80002eaa:	e0 89 00 26 	brgt	80002ef6 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002eae:	30 39       	mov	r9,3
80002eb0:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002eb4:	91 09       	st.w	r8[0x0],r9
80002eb6:	c2 08       	rjmp	80002ef6 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002eb8:	e6 16 00 ff 	andh	r6,0xff,COH
80002ebc:	fc 19 00 ba 	movh	r9,0xba
80002ec0:	12 36       	cp.w	r6,r9
80002ec2:	c0 e1       	brne	80002ede <phy_rx_func+0x206>
80002ec4:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002ec8:	90 09       	ld.sh	r9,r8[0x0]
80002eca:	30 08       	mov	r8,0
80002ecc:	f0 09 19 00 	cp.h	r9,r8
80002ed0:	c0 71       	brne	80002ede <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002ed2:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002ed6:	70 0c       	ld.w	r12,r8[0x0]
80002ed8:	f0 1f 03 2a 	mcall	80003b80 <phy_rx_func+0xea8>
80002edc:	c0 98       	rjmp	80002eee <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002ede:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002ee2:	70 0c       	ld.w	r12,r8[0x0]
80002ee4:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002ee8:	70 0b       	ld.w	r11,r8[0x0]
80002eea:	f0 1f 03 24 	mcall	80003b78 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002eee:	30 09       	mov	r9,0
80002ef0:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002ef4:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002ef6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002efa:	11 89       	ld.ub	r9,r8[0x0]
80002efc:	30 08       	mov	r8,0
80002efe:	f0 09 18 00 	cp.b	r9,r8
80002f02:	c1 31       	brne	80002f28 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002f04:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002f08:	6c 0c       	ld.w	r12,r6[0x0]
80002f0a:	f0 1f 03 1a 	mcall	80003b70 <phy_rx_func+0xe98>
80002f0e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002f12:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002f14:	6c 0c       	ld.w	r12,r6[0x0]
80002f16:	f0 1f 03 17 	mcall	80003b70 <phy_rx_func+0xe98>
80002f1a:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002f1e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002f20:	30 19       	mov	r9,1
80002f22:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002f26:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002f28:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002f2c:	70 08       	ld.w	r8,r8[0x0]
80002f2e:	58 28       	cp.w	r8,2
80002f30:	e0 80 01 98 	breq	80003260 <phy_rx_func+0x588>
80002f34:	e0 8b 00 06 	brhi	80002f40 <phy_rx_func+0x268>
80002f38:	58 08       	cp.w	r8,0
80002f3a:	c0 b0       	breq	80002f50 <phy_rx_func+0x278>
80002f3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f40:	58 38       	cp.w	r8,3
80002f42:	e0 80 05 c5 	breq	80003acc <phy_rx_func+0xdf4>
80002f46:	58 48       	cp.w	r8,4
80002f48:	e0 81 06 05 	brne	80003b52 <phy_rx_func+0xe7a>
80002f4c:	e0 8f 02 4b 	bral	800033e2 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002f50:	6e 28       	ld.w	r8,r7[0x8]
80002f52:	e0 6a 5a 5a 	mov	r10,23130
80002f56:	ea 1a ab cd 	orh	r10,0xabcd
80002f5a:	14 38       	cp.w	r8,r10
80002f5c:	c0 71       	brne	80002f6a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002f5e:	30 09       	mov	r9,0
80002f60:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002f64:	91 09       	st.w	r8[0x0],r9
80002f66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002f6a:	10 99       	mov	r9,r8
80002f6c:	e0 19 00 00 	andl	r9,0x0
80002f70:	fc 1a ab cd 	movh	r10,0xabcd
80002f74:	14 39       	cp.w	r9,r10
80002f76:	e0 81 05 ee 	brne	80003b52 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002f7a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002f7e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002f82:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002f84:	6e 29       	ld.w	r9,r7[0x8]
80002f86:	e2 19 f0 00 	andl	r9,0xf000,COH
80002f8a:	e0 49 c0 00 	cp.w	r9,49152
80002f8e:	e0 81 00 ce 	brne	8000312a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002f92:	30 1a       	mov	r10,1
80002f94:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002f98:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002f9a:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002f9e:	72 09       	ld.w	r9,r9[0x0]
80002fa0:	58 09       	cp.w	r9,0
80002fa2:	c0 71       	brne	80002fb0 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002fa4:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002fa8:	f0 1f 03 00 	mcall	80003ba8 <phy_rx_func+0xed0>
80002fac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002fb0:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002fb4:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002fb8:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002fba:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002fbe:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002fc2:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002fc6:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002fc8:	13 89       	ld.ub	r9,r9[0x0]
80002fca:	37 fa       	mov	r10,127
80002fcc:	f4 09 18 00 	cp.b	r9,r10
80002fd0:	c6 d0       	breq	800030aa <phy_rx_func+0x3d2>
80002fd2:	e0 8b 00 0c 	brhi	80002fea <phy_rx_func+0x312>
80002fd6:	31 2a       	mov	r10,18
80002fd8:	f4 09 18 00 	cp.b	r9,r10
80002fdc:	c4 20       	breq	80003060 <phy_rx_func+0x388>
80002fde:	31 3a       	mov	r10,19
80002fe0:	f4 09 18 00 	cp.b	r9,r10
80002fe4:	e0 81 00 83 	brne	800030ea <phy_rx_func+0x412>
80002fe8:	c5 b8       	rjmp	8000309e <phy_rx_func+0x3c6>
80002fea:	2f 09       	sub	r9,-16
80002fec:	30 1a       	mov	r10,1
80002fee:	f4 09 18 00 	cp.b	r9,r10
80002ff2:	e0 8b 00 7c 	brhi	800030ea <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002ff6:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002ffa:	e2 18 00 f0 	andl	r8,0xf0,COH
80002ffe:	59 08       	cp.w	r8,16
80003000:	c0 71       	brne	8000300e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003002:	30 19       	mov	r9,1
80003004:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003008:	91 09       	st.w	r8[0x0],r9
8000300a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000300e:	e0 48 00 20 	cp.w	r8,32
80003012:	c2 11       	brne	80003054 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003014:	30 a9       	mov	r9,10
80003016:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000301a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000301c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003020:	6c 08       	ld.w	r8,r6[0x0]
80003022:	f0 0a 11 ff 	rsub	r10,r8,-1
80003026:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000302a:	2f f8       	sub	r8,-1
8000302c:	6e 0c       	ld.w	r12,r7[0x0]
8000302e:	f4 ca fe 00 	sub	r10,r10,-512
80003032:	30 0b       	mov	r11,0
80003034:	10 0c       	add	r12,r8
80003036:	f0 1f 02 e1 	mcall	80003bb8 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000303a:	30 08       	mov	r8,0
8000303c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000303e:	6e 0c       	ld.w	r12,r7[0x0]
80003040:	f0 1f 02 df 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003044:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003048:	70 0c       	ld.w	r12,r8[0x0]
8000304a:	f0 1f 02 ca 	mcall	80003b70 <phy_rx_func+0xe98>
8000304e:	8f 0c       	st.w	r7[0x0],r12
80003050:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003054:	30 09       	mov	r9,0
80003056:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000305a:	91 09       	st.w	r8[0x0],r9
8000305c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003060:	20 48       	sub	r8,4
80003062:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003066:	93 08       	st.w	r9[0x0],r8
80003068:	58 08       	cp.w	r8,0
8000306a:	e0 80 05 74 	breq	80003b52 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000306e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003072:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003076:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000307a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000307c:	8e 69       	ld.sh	r9,r7[0xc]
8000307e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003082:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003084:	8e 79       	ld.sh	r9,r7[0xe]
80003086:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003088:	f0 1f 02 d0 	mcall	80003bc8 <phy_rx_func+0xef0>
8000308c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003090:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003092:	30 49       	mov	r9,4
80003094:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003098:	91 09       	st.w	r8[0x0],r9
8000309a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000309e:	30 09       	mov	r9,0
800030a0:	fe f8 0a f8 	ld.w	r8,pc[2808]
800030a4:	91 09       	st.w	r8[0x0],r9
800030a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800030aa:	20 48       	sub	r8,4
800030ac:	fe f9 0a f0 	ld.w	r9,pc[2800]
800030b0:	93 08       	st.w	r9[0x0],r8
800030b2:	58 08       	cp.w	r8,0
800030b4:	e0 80 05 4f 	breq	80003b52 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800030b8:	fe f8 0b 14 	ld.w	r8,pc[2836]
800030bc:	70 09       	ld.w	r9,r8[0x0]
800030be:	8e 7b       	ld.sh	r11,r7[0xe]
800030c0:	fe fa 0b 10 	ld.w	r10,pc[2832]
800030c4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800030c8:	2f f9       	sub	r9,-1
800030ca:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800030cc:	fe f8 0a e4 	ld.w	r8,pc[2788]
800030d0:	70 09       	ld.w	r9,r8[0x0]
800030d2:	20 29       	sub	r9,2
800030d4:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800030d6:	30 29       	mov	r9,2
800030d8:	fe f8 0a c0 	ld.w	r8,pc[2752]
800030dc:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800030de:	30 39       	mov	r9,3
800030e0:	fe f8 0a b4 	ld.w	r8,pc[2740]
800030e4:	91 09       	st.w	r8[0x0],r9
800030e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800030ea:	30 3a       	mov	r10,3
800030ec:	fe f9 0a ac 	ld.w	r9,pc[2732]
800030f0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800030f2:	6e 2a       	ld.w	r10,r7[0x8]
800030f4:	fe f9 0a e0 	ld.w	r9,pc[2784]
800030f8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800030fa:	6e 3a       	ld.w	r10,r7[0xc]
800030fc:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800030fe:	59 48       	cp.w	r8,20
80003100:	c0 61       	brne	8000310c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003102:	31 89       	mov	r9,24
80003104:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003108:	91 09       	st.w	r8[0x0],r9
8000310a:	c0 a8       	rjmp	8000311e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000310c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003110:	70 08       	ld.w	r8,r8[0x0]
80003112:	59 08       	cp.w	r8,16
80003114:	c0 51       	brne	8000311e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003116:	31 09       	mov	r9,16
80003118:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000311c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000311e:	30 49       	mov	r9,4
80003120:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003124:	91 09       	st.w	r8[0x0],r9
80003126:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000312a:	e0 49 10 00 	cp.w	r9,4096
8000312e:	5f 1a       	srne	r10
80003130:	e0 49 20 00 	cp.w	r9,8192
80003134:	5f 19       	srne	r9
80003136:	f5 e9 00 09 	and	r9,r10,r9
8000313a:	e0 81 05 0c 	brne	80003b52 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000313e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003142:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003144:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003148:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000314a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000314e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003150:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003154:	72 09       	ld.w	r9,r9[0x0]
80003156:	58 09       	cp.w	r9,0
80003158:	c0 71       	brne	80003166 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000315a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000315e:	f0 1f 02 93 	mcall	80003ba8 <phy_rx_func+0xed0>
80003162:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003166:	6e 2a       	ld.w	r10,r7[0x8]
80003168:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000316c:	58 1a       	cp.w	r10,1
8000316e:	e0 8b 00 4d 	brhi	80003208 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003172:	20 48       	sub	r8,4
80003174:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003178:	93 08       	st.w	r9[0x0],r8
8000317a:	58 08       	cp.w	r8,0
8000317c:	e0 80 04 eb 	breq	80003b52 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003180:	8e 68       	ld.sh	r8,r7[0xc]
80003182:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003186:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000318a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
8000318c:	30 09       	mov	r9,0
8000318e:	f2 08 19 00 	cp.h	r8,r9
80003192:	c0 70       	breq	800031a0 <phy_rx_func+0x4c8>
80003194:	30 19       	mov	r9,1
80003196:	f2 08 19 00 	cp.h	r8,r9
8000319a:	e0 81 04 dc 	brne	80003b52 <phy_rx_func+0xe7a>
8000319e:	c2 68       	rjmp	800031ea <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800031a0:	fe f8 0a 44 	ld.w	r8,pc[2628]
800031a4:	70 0a       	ld.w	r10,r8[0x0]
800031a6:	fe f9 09 e6 	ld.w	r9,pc[2534]
800031aa:	72 09       	ld.w	r9,r9[0x0]
800031ac:	8e 7b       	ld.sh	r11,r7[0xe]
800031ae:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800031b2:	70 09       	ld.w	r9,r8[0x0]
800031b4:	2f f9       	sub	r9,-1
800031b6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031b8:	e0 49 00 ff 	cp.w	r9,255
800031bc:	e0 88 00 11 	brls	800031de <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800031c0:	30 09       	mov	r9,0
800031c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800031c4:	fe f7 09 c8 	ld.w	r7,pc[2504]
800031c8:	6e 0c       	ld.w	r12,r7[0x0]
800031ca:	f0 1f 02 7d 	mcall	80003bbc <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800031ce:	fe f8 09 ba 	ld.w	r8,pc[2490]
800031d2:	70 0c       	ld.w	r12,r8[0x0]
800031d4:	f0 1f 02 67 	mcall	80003b70 <phy_rx_func+0xe98>
800031d8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800031da:	e0 80 04 bc 	breq	80003b52 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800031de:	30 29       	mov	r9,2
800031e0:	fe f8 09 b4 	ld.w	r8,pc[2484]
800031e4:	91 09       	st.w	r8[0x0],r9
800031e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800031ea:	8e 79       	ld.sh	r9,r7[0xe]
800031ec:	30 38       	mov	r8,3
800031ee:	f0 09 19 00 	cp.h	r9,r8
800031f2:	c0 51       	brne	800031fc <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800031f4:	30 19       	mov	r9,1
800031f6:	fe f8 09 f2 	ld.w	r8,pc[2546]
800031fa:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800031fc:	30 29       	mov	r9,2
800031fe:	fe f8 09 96 	ld.w	r8,pc[2454]
80003202:	91 09       	st.w	r8[0x0],r9
80003204:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003208:	58 18       	cp.w	r8,1
8000320a:	e0 88 04 a4 	brls	80003b52 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000320e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003212:	70 0a       	ld.w	r10,r8[0x0]
80003214:	6e 3b       	ld.w	r11,r7[0xc]
80003216:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000321a:	70 09       	ld.w	r9,r8[0x0]
8000321c:	2f f9       	sub	r9,-1
8000321e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003220:	e0 49 00 ff 	cp.w	r9,255
80003224:	e0 88 00 11 	brls	80003246 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003228:	30 09       	mov	r9,0
8000322a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000322c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003230:	6e 0c       	ld.w	r12,r7[0x0]
80003232:	f0 1f 02 63 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003236:	fe f8 09 52 	ld.w	r8,pc[2386]
8000323a:	70 0c       	ld.w	r12,r8[0x0]
8000323c:	f0 1f 02 4d 	mcall	80003b70 <phy_rx_func+0xe98>
80003240:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003242:	e0 80 04 88 	breq	80003b52 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003246:	fe f9 09 56 	ld.w	r9,pc[2390]
8000324a:	72 08       	ld.w	r8,r9[0x0]
8000324c:	20 28       	sub	r8,2
8000324e:	93 08       	st.w	r9[0x0],r8
80003250:	e0 80 04 81 	breq	80003b52 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003254:	30 29       	mov	r9,2
80003256:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000325a:	91 09       	st.w	r8[0x0],r9
8000325c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003260:	fe f8 09 84 	ld.w	r8,pc[2436]
80003264:	70 0a       	ld.w	r10,r8[0x0]
80003266:	fe f9 09 26 	ld.w	r9,pc[2342]
8000326a:	72 09       	ld.w	r9,r9[0x0]
8000326c:	8e 4b       	ld.sh	r11,r7[0x8]
8000326e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003272:	70 09       	ld.w	r9,r8[0x0]
80003274:	2f f9       	sub	r9,-1
80003276:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003278:	e0 49 00 ff 	cp.w	r9,255
8000327c:	e0 88 00 16 	brls	800032a8 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003280:	30 09       	mov	r9,0
80003282:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003284:	fe f6 09 08 	ld.w	r6,pc[2312]
80003288:	6c 0c       	ld.w	r12,r6[0x0]
8000328a:	f0 1f 02 4d 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000328e:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003292:	70 0c       	ld.w	r12,r8[0x0]
80003294:	f0 1f 02 37 	mcall	80003b70 <phy_rx_func+0xe98>
80003298:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000329a:	c0 71       	brne	800032a8 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
8000329c:	30 09       	mov	r9,0
8000329e:	fe f8 08 f6 	ld.w	r8,pc[2294]
800032a2:	91 09       	st.w	r8[0x0],r9
800032a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800032a8:	fe f9 08 f4 	ld.w	r9,pc[2292]
800032ac:	72 08       	ld.w	r8,r9[0x0]
800032ae:	20 28       	sub	r8,2
800032b0:	93 08       	st.w	r9[0x0],r8
800032b2:	c0 71       	brne	800032c0 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800032b4:	30 09       	mov	r9,0
800032b6:	fe f8 08 de 	ld.w	r8,pc[2270]
800032ba:	91 09       	st.w	r8[0x0],r9
800032bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800032c0:	fe f8 09 24 	ld.w	r8,pc[2340]
800032c4:	70 0a       	ld.w	r10,r8[0x0]
800032c6:	fe f9 08 c6 	ld.w	r9,pc[2246]
800032ca:	72 09       	ld.w	r9,r9[0x0]
800032cc:	8e 5b       	ld.sh	r11,r7[0xa]
800032ce:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032d2:	70 09       	ld.w	r9,r8[0x0]
800032d4:	2f f9       	sub	r9,-1
800032d6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032d8:	e0 49 00 ff 	cp.w	r9,255
800032dc:	e0 88 00 16 	brls	80003308 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800032e0:	30 09       	mov	r9,0
800032e2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032e4:	fe f6 08 a8 	ld.w	r6,pc[2216]
800032e8:	6c 0c       	ld.w	r12,r6[0x0]
800032ea:	f0 1f 02 35 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032ee:	fe f8 08 9a 	ld.w	r8,pc[2202]
800032f2:	70 0c       	ld.w	r12,r8[0x0]
800032f4:	f0 1f 02 1f 	mcall	80003b70 <phy_rx_func+0xe98>
800032f8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032fa:	c0 71       	brne	80003308 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800032fc:	30 09       	mov	r9,0
800032fe:	fe f8 08 96 	ld.w	r8,pc[2198]
80003302:	91 09       	st.w	r8[0x0],r9
80003304:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003308:	fe f9 08 94 	ld.w	r9,pc[2196]
8000330c:	72 08       	ld.w	r8,r9[0x0]
8000330e:	20 28       	sub	r8,2
80003310:	93 08       	st.w	r9[0x0],r8
80003312:	c0 71       	brne	80003320 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003314:	30 09       	mov	r9,0
80003316:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000331a:	91 09       	st.w	r8[0x0],r9
8000331c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003320:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003324:	70 0a       	ld.w	r10,r8[0x0]
80003326:	fe f9 08 66 	ld.w	r9,pc[2150]
8000332a:	72 09       	ld.w	r9,r9[0x0]
8000332c:	8e 6b       	ld.sh	r11,r7[0xc]
8000332e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003332:	70 09       	ld.w	r9,r8[0x0]
80003334:	2f f9       	sub	r9,-1
80003336:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003338:	e0 49 00 ff 	cp.w	r9,255
8000333c:	e0 88 00 16 	brls	80003368 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003340:	30 09       	mov	r9,0
80003342:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003344:	fe f6 08 48 	ld.w	r6,pc[2120]
80003348:	6c 0c       	ld.w	r12,r6[0x0]
8000334a:	f0 1f 02 1d 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000334e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003352:	70 0c       	ld.w	r12,r8[0x0]
80003354:	f0 1f 02 07 	mcall	80003b70 <phy_rx_func+0xe98>
80003358:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000335a:	c0 71       	brne	80003368 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
8000335c:	30 09       	mov	r9,0
8000335e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003362:	91 09       	st.w	r8[0x0],r9
80003364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003368:	fe f9 08 34 	ld.w	r9,pc[2100]
8000336c:	72 08       	ld.w	r8,r9[0x0]
8000336e:	20 28       	sub	r8,2
80003370:	93 08       	st.w	r9[0x0],r8
80003372:	c0 71       	brne	80003380 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003374:	30 09       	mov	r9,0
80003376:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000337a:	91 09       	st.w	r8[0x0],r9
8000337c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003380:	fe f8 08 64 	ld.w	r8,pc[2148]
80003384:	70 0a       	ld.w	r10,r8[0x0]
80003386:	fe f9 08 06 	ld.w	r9,pc[2054]
8000338a:	72 09       	ld.w	r9,r9[0x0]
8000338c:	8e 7b       	ld.sh	r11,r7[0xe]
8000338e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003392:	70 09       	ld.w	r9,r8[0x0]
80003394:	2f f9       	sub	r9,-1
80003396:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003398:	e0 49 00 ff 	cp.w	r9,255
8000339c:	e0 88 00 16 	brls	800033c8 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800033a0:	30 09       	mov	r9,0
800033a2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033a4:	fe f7 07 e8 	ld.w	r7,pc[2024]
800033a8:	6e 0c       	ld.w	r12,r7[0x0]
800033aa:	f0 1f 02 05 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033ae:	fe f8 07 da 	ld.w	r8,pc[2010]
800033b2:	70 0c       	ld.w	r12,r8[0x0]
800033b4:	f0 1f 01 ef 	mcall	80003b70 <phy_rx_func+0xe98>
800033b8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800033ba:	c0 71       	brne	800033c8 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800033bc:	30 09       	mov	r9,0
800033be:	fe f8 07 d6 	ld.w	r8,pc[2006]
800033c2:	91 09       	st.w	r8[0x0],r9
800033c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800033c8:	fe f9 07 d4 	ld.w	r9,pc[2004]
800033cc:	72 08       	ld.w	r8,r9[0x0]
800033ce:	20 28       	sub	r8,2
800033d0:	93 08       	st.w	r9[0x0],r8
800033d2:	e0 81 03 c0 	brne	80003b52 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800033d6:	30 09       	mov	r9,0
800033d8:	fe f8 07 bc 	ld.w	r8,pc[1980]
800033dc:	91 09       	st.w	r8[0x0],r9
800033de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800033e2:	fe f8 07 ca 	ld.w	r8,pc[1994]
800033e6:	11 89       	ld.ub	r9,r8[0x0]
800033e8:	31 28       	mov	r8,18
800033ea:	f0 09 18 00 	cp.b	r9,r8
800033ee:	e0 81 01 4c 	brne	80003686 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800033f2:	ef 39 00 09 	ld.ub	r9,r7[9]
800033f6:	fe f8 07 b6 	ld.w	r8,pc[1974]
800033fa:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800033fc:	11 89       	ld.ub	r9,r8[0x0]
800033fe:	3f 28       	mov	r8,-14
80003400:	f0 09 18 00 	cp.b	r9,r8
80003404:	e0 81 01 3b 	brne	8000367a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003408:	30 19       	mov	r9,1
8000340a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000340e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003410:	6e 29       	ld.w	r9,r7[0x8]
80003412:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003416:	fe f8 07 86 	ld.w	r8,pc[1926]
8000341a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000341c:	8e 59       	ld.sh	r9,r7[0xa]
8000341e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003422:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003424:	8e 69       	ld.sh	r9,r7[0xc]
80003426:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003428:	8e 79       	ld.sh	r9,r7[0xe]
8000342a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000342c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003430:	fe f9 07 60 	ld.w	r9,pc[1888]
80003434:	72 0a       	ld.w	r10,r9[0x0]
80003436:	70 09       	ld.w	r9,r8[0x0]
80003438:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000343c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003440:	70 09       	ld.w	r9,r8[0x0]
80003442:	2f f9       	sub	r9,-1
80003444:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003446:	e0 49 01 ff 	cp.w	r9,511
8000344a:	e0 88 00 16 	brls	80003476 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000344e:	30 09       	mov	r9,0
80003450:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003452:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003456:	6c 0c       	ld.w	r12,r6[0x0]
80003458:	f0 1f 01 d9 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000345c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003460:	70 0c       	ld.w	r12,r8[0x0]
80003462:	f0 1f 01 c4 	mcall	80003b70 <phy_rx_func+0xe98>
80003466:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003468:	c0 71       	brne	80003476 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000346a:	30 09       	mov	r9,0
8000346c:	fe f8 07 28 	ld.w	r8,pc[1832]
80003470:	91 09       	st.w	r8[0x0],r9
80003472:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003476:	fe f9 07 26 	ld.w	r9,pc[1830]
8000347a:	72 08       	ld.w	r8,r9[0x0]
8000347c:	20 18       	sub	r8,1
8000347e:	93 08       	st.w	r9[0x0],r8
80003480:	c0 71       	brne	8000348e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003482:	30 09       	mov	r9,0
80003484:	fe f8 07 10 	ld.w	r8,pc[1808]
80003488:	91 09       	st.w	r8[0x0],r9
8000348a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000348e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003492:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003496:	72 0a       	ld.w	r10,r9[0x0]
80003498:	70 09       	ld.w	r9,r8[0x0]
8000349a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000349e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034a2:	70 09       	ld.w	r9,r8[0x0]
800034a4:	2f f9       	sub	r9,-1
800034a6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034a8:	e0 49 01 ff 	cp.w	r9,511
800034ac:	e0 88 00 16 	brls	800034d8 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800034b0:	30 09       	mov	r9,0
800034b2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034b4:	fe f6 06 dc 	ld.w	r6,pc[1756]
800034b8:	6c 0c       	ld.w	r12,r6[0x0]
800034ba:	f0 1f 01 c1 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034be:	fe f8 06 ca 	ld.w	r8,pc[1738]
800034c2:	70 0c       	ld.w	r12,r8[0x0]
800034c4:	f0 1f 01 ab 	mcall	80003b70 <phy_rx_func+0xe98>
800034c8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034ca:	c0 71       	brne	800034d8 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800034cc:	30 09       	mov	r9,0
800034ce:	fe f8 06 c6 	ld.w	r8,pc[1734]
800034d2:	91 09       	st.w	r8[0x0],r9
800034d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034d8:	fe f9 06 c4 	ld.w	r9,pc[1732]
800034dc:	72 08       	ld.w	r8,r9[0x0]
800034de:	20 18       	sub	r8,1
800034e0:	93 08       	st.w	r9[0x0],r8
800034e2:	c0 71       	brne	800034f0 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800034e4:	30 09       	mov	r9,0
800034e6:	fe f8 06 ae 	ld.w	r8,pc[1710]
800034ea:	91 09       	st.w	r8[0x0],r9
800034ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800034f0:	fe f8 06 c4 	ld.w	r8,pc[1732]
800034f4:	fe f9 06 9c 	ld.w	r9,pc[1692]
800034f8:	72 0a       	ld.w	r10,r9[0x0]
800034fa:	70 09       	ld.w	r9,r8[0x0]
800034fc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003500:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003504:	70 09       	ld.w	r9,r8[0x0]
80003506:	2f f9       	sub	r9,-1
80003508:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000350a:	e0 49 01 ff 	cp.w	r9,511
8000350e:	e0 88 00 16 	brls	8000353a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003512:	30 09       	mov	r9,0
80003514:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003516:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000351a:	6c 0c       	ld.w	r12,r6[0x0]
8000351c:	f0 1f 01 a8 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003520:	fe f8 06 68 	ld.w	r8,pc[1640]
80003524:	70 0c       	ld.w	r12,r8[0x0]
80003526:	f0 1f 01 93 	mcall	80003b70 <phy_rx_func+0xe98>
8000352a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000352c:	c0 71       	brne	8000353a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000352e:	30 09       	mov	r9,0
80003530:	fe f8 06 64 	ld.w	r8,pc[1636]
80003534:	91 09       	st.w	r8[0x0],r9
80003536:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000353a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000353e:	72 08       	ld.w	r8,r9[0x0]
80003540:	20 18       	sub	r8,1
80003542:	93 08       	st.w	r9[0x0],r8
80003544:	c0 71       	brne	80003552 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003546:	30 09       	mov	r9,0
80003548:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000354c:	91 09       	st.w	r8[0x0],r9
8000354e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003552:	fe f8 06 62 	ld.w	r8,pc[1634]
80003556:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000355a:	72 0a       	ld.w	r10,r9[0x0]
8000355c:	70 09       	ld.w	r9,r8[0x0]
8000355e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003562:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003566:	70 09       	ld.w	r9,r8[0x0]
80003568:	2f f9       	sub	r9,-1
8000356a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000356c:	e0 49 01 ff 	cp.w	r9,511
80003570:	e0 88 00 16 	brls	8000359c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003574:	30 09       	mov	r9,0
80003576:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003578:	fe f6 06 18 	ld.w	r6,pc[1560]
8000357c:	6c 0c       	ld.w	r12,r6[0x0]
8000357e:	f0 1f 01 90 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003582:	fe f8 06 06 	ld.w	r8,pc[1542]
80003586:	70 0c       	ld.w	r12,r8[0x0]
80003588:	f0 1f 01 7a 	mcall	80003b70 <phy_rx_func+0xe98>
8000358c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000358e:	c0 71       	brne	8000359c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003590:	30 09       	mov	r9,0
80003592:	fe f8 06 02 	ld.w	r8,pc[1538]
80003596:	91 09       	st.w	r8[0x0],r9
80003598:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000359c:	fe f9 06 00 	ld.w	r9,pc[1536]
800035a0:	72 08       	ld.w	r8,r9[0x0]
800035a2:	20 18       	sub	r8,1
800035a4:	93 08       	st.w	r9[0x0],r8
800035a6:	c0 71       	brne	800035b4 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800035a8:	30 09       	mov	r9,0
800035aa:	fe f8 05 ea 	ld.w	r8,pc[1514]
800035ae:	91 09       	st.w	r8[0x0],r9
800035b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800035b4:	fe f8 06 00 	ld.w	r8,pc[1536]
800035b8:	fe f9 05 d8 	ld.w	r9,pc[1496]
800035bc:	72 0a       	ld.w	r10,r9[0x0]
800035be:	70 09       	ld.w	r9,r8[0x0]
800035c0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800035c4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035c8:	70 09       	ld.w	r9,r8[0x0]
800035ca:	2f f9       	sub	r9,-1
800035cc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035ce:	e0 49 01 ff 	cp.w	r9,511
800035d2:	e0 88 00 16 	brls	800035fe <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800035d6:	30 09       	mov	r9,0
800035d8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035da:	fe f6 05 b6 	ld.w	r6,pc[1462]
800035de:	6c 0c       	ld.w	r12,r6[0x0]
800035e0:	f0 1f 01 77 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035e4:	fe f8 05 a4 	ld.w	r8,pc[1444]
800035e8:	70 0c       	ld.w	r12,r8[0x0]
800035ea:	f0 1f 01 62 	mcall	80003b70 <phy_rx_func+0xe98>
800035ee:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035f0:	c0 71       	brne	800035fe <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800035f2:	30 09       	mov	r9,0
800035f4:	fe f8 05 a0 	ld.w	r8,pc[1440]
800035f8:	91 09       	st.w	r8[0x0],r9
800035fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035fe:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003602:	72 08       	ld.w	r8,r9[0x0]
80003604:	20 18       	sub	r8,1
80003606:	93 08       	st.w	r9[0x0],r8
80003608:	c0 71       	brne	80003616 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000360a:	30 09       	mov	r9,0
8000360c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003610:	91 09       	st.w	r8[0x0],r9
80003612:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003616:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000361a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000361e:	72 0a       	ld.w	r10,r9[0x0]
80003620:	70 09       	ld.w	r9,r8[0x0]
80003622:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003626:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000362a:	70 09       	ld.w	r9,r8[0x0]
8000362c:	2f f9       	sub	r9,-1
8000362e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003630:	e0 49 01 ff 	cp.w	r9,511
80003634:	e0 88 00 16 	brls	80003660 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003638:	30 09       	mov	r9,0
8000363a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000363c:	fe f7 05 54 	ld.w	r7,pc[1364]
80003640:	6e 0c       	ld.w	r12,r7[0x0]
80003642:	f0 1f 01 5f 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003646:	fe f8 05 42 	ld.w	r8,pc[1346]
8000364a:	70 0c       	ld.w	r12,r8[0x0]
8000364c:	f0 1f 01 49 	mcall	80003b70 <phy_rx_func+0xe98>
80003650:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003652:	c0 71       	brne	80003660 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003654:	30 09       	mov	r9,0
80003656:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000365a:	91 09       	st.w	r8[0x0],r9
8000365c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003660:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003664:	72 08       	ld.w	r8,r9[0x0]
80003666:	20 18       	sub	r8,1
80003668:	93 08       	st.w	r9[0x0],r8
8000366a:	e0 81 02 74 	brne	80003b52 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000366e:	30 09       	mov	r9,0
80003670:	fe f8 05 24 	ld.w	r8,pc[1316]
80003674:	91 09       	st.w	r8[0x0],r9
80003676:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000367a:	30 09       	mov	r9,0
8000367c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003680:	91 09       	st.w	r8[0x0],r9
80003682:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003686:	fe f8 05 26 	ld.w	r8,pc[1318]
8000368a:	11 89       	ld.ub	r9,r8[0x0]
8000368c:	3f 28       	mov	r8,-14
8000368e:	f0 09 18 00 	cp.b	r9,r8
80003692:	c4 31       	brne	80003718 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003694:	8e 49       	ld.sh	r9,r7[0x8]
80003696:	fe f8 05 56 	ld.w	r8,pc[1366]
8000369a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000369c:	fe f8 05 18 	ld.w	r8,pc[1304]
800036a0:	fe f9 04 f0 	ld.w	r9,pc[1264]
800036a4:	72 0a       	ld.w	r10,r9[0x0]
800036a6:	70 09       	ld.w	r9,r8[0x0]
800036a8:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036ac:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036b0:	70 09       	ld.w	r9,r8[0x0]
800036b2:	2f f9       	sub	r9,-1
800036b4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036b6:	e0 49 01 ff 	cp.w	r9,511
800036ba:	e0 88 00 16 	brls	800036e6 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800036be:	30 09       	mov	r9,0
800036c0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036c2:	fe f7 04 ce 	ld.w	r7,pc[1230]
800036c6:	6e 0c       	ld.w	r12,r7[0x0]
800036c8:	f0 1f 01 3d 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036cc:	fe f8 04 bc 	ld.w	r8,pc[1212]
800036d0:	70 0c       	ld.w	r12,r8[0x0]
800036d2:	f0 1f 01 28 	mcall	80003b70 <phy_rx_func+0xe98>
800036d6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036d8:	c0 71       	brne	800036e6 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800036da:	30 09       	mov	r9,0
800036dc:	fe f8 04 b8 	ld.w	r8,pc[1208]
800036e0:	91 09       	st.w	r8[0x0],r9
800036e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036e6:	fe f9 04 b6 	ld.w	r9,pc[1206]
800036ea:	72 08       	ld.w	r8,r9[0x0]
800036ec:	20 18       	sub	r8,1
800036ee:	93 08       	st.w	r9[0x0],r8
800036f0:	c0 71       	brne	800036fe <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800036f2:	30 09       	mov	r9,0
800036f4:	fe f8 04 a0 	ld.w	r8,pc[1184]
800036f8:	91 09       	st.w	r8[0x0],r9
800036fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800036fe:	20 18       	sub	r8,1
80003700:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003704:	93 08       	st.w	r9[0x0],r8
80003706:	58 08       	cp.w	r8,0
80003708:	e0 81 02 25 	brne	80003b52 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
8000370c:	30 09       	mov	r9,0
8000370e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003712:	91 09       	st.w	r8[0x0],r9
80003714:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003718:	fe f8 04 94 	ld.w	r8,pc[1172]
8000371c:	11 89       	ld.ub	r9,r8[0x0]
8000371e:	3f 38       	mov	r8,-13
80003720:	f0 09 18 00 	cp.b	r9,r8
80003724:	e0 81 01 0c 	brne	8000393c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003728:	8e 49       	ld.sh	r9,r7[0x8]
8000372a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000372e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003730:	8e 59       	ld.sh	r9,r7[0xa]
80003732:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003734:	8e 69       	ld.sh	r9,r7[0xc]
80003736:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003738:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000373c:	fe f9 04 54 	ld.w	r9,pc[1108]
80003740:	72 0a       	ld.w	r10,r9[0x0]
80003742:	70 09       	ld.w	r9,r8[0x0]
80003744:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003748:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000374c:	70 09       	ld.w	r9,r8[0x0]
8000374e:	2f f9       	sub	r9,-1
80003750:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003752:	e0 49 01 ff 	cp.w	r9,511
80003756:	e0 88 00 16 	brls	80003782 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000375a:	30 09       	mov	r9,0
8000375c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000375e:	fe f6 04 32 	ld.w	r6,pc[1074]
80003762:	6c 0c       	ld.w	r12,r6[0x0]
80003764:	f0 1f 01 16 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003768:	fe f8 04 20 	ld.w	r8,pc[1056]
8000376c:	70 0c       	ld.w	r12,r8[0x0]
8000376e:	f0 1f 01 01 	mcall	80003b70 <phy_rx_func+0xe98>
80003772:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003774:	c0 71       	brne	80003782 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003776:	30 09       	mov	r9,0
80003778:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000377c:	91 09       	st.w	r8[0x0],r9
8000377e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003782:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003786:	72 08       	ld.w	r8,r9[0x0]
80003788:	20 18       	sub	r8,1
8000378a:	93 08       	st.w	r9[0x0],r8
8000378c:	c0 71       	brne	8000379a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000378e:	30 09       	mov	r9,0
80003790:	fe f8 04 04 	ld.w	r8,pc[1028]
80003794:	91 09       	st.w	r8[0x0],r9
80003796:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000379a:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000379e:	fe f9 03 f2 	ld.w	r9,pc[1010]
800037a2:	72 0a       	ld.w	r10,r9[0x0]
800037a4:	70 09       	ld.w	r9,r8[0x0]
800037a6:	ef 3b 00 09 	ld.ub	r11,r7[9]
800037aa:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037ae:	70 09       	ld.w	r9,r8[0x0]
800037b0:	2f f9       	sub	r9,-1
800037b2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037b4:	e0 49 01 ff 	cp.w	r9,511
800037b8:	e0 88 00 16 	brls	800037e4 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800037bc:	30 09       	mov	r9,0
800037be:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037c0:	fe f6 03 d0 	ld.w	r6,pc[976]
800037c4:	6c 0c       	ld.w	r12,r6[0x0]
800037c6:	f0 1f 00 fe 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037ca:	fe f8 03 be 	ld.w	r8,pc[958]
800037ce:	70 0c       	ld.w	r12,r8[0x0]
800037d0:	f0 1f 00 e8 	mcall	80003b70 <phy_rx_func+0xe98>
800037d4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037d6:	c0 71       	brne	800037e4 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800037d8:	30 09       	mov	r9,0
800037da:	fe f8 03 ba 	ld.w	r8,pc[954]
800037de:	91 09       	st.w	r8[0x0],r9
800037e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037e4:	fe f9 03 b8 	ld.w	r9,pc[952]
800037e8:	72 08       	ld.w	r8,r9[0x0]
800037ea:	20 18       	sub	r8,1
800037ec:	93 08       	st.w	r9[0x0],r8
800037ee:	c0 71       	brne	800037fc <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800037f0:	30 09       	mov	r9,0
800037f2:	fe f8 03 a2 	ld.w	r8,pc[930]
800037f6:	91 09       	st.w	r8[0x0],r9
800037f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800037fc:	fe f8 03 b8 	ld.w	r8,pc[952]
80003800:	fe f9 03 90 	ld.w	r9,pc[912]
80003804:	72 0a       	ld.w	r10,r9[0x0]
80003806:	70 09       	ld.w	r9,r8[0x0]
80003808:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000380c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003810:	70 09       	ld.w	r9,r8[0x0]
80003812:	2f f9       	sub	r9,-1
80003814:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003816:	e0 49 01 ff 	cp.w	r9,511
8000381a:	e0 88 00 16 	brls	80003846 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000381e:	30 09       	mov	r9,0
80003820:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003822:	fe f6 03 6e 	ld.w	r6,pc[878]
80003826:	6c 0c       	ld.w	r12,r6[0x0]
80003828:	f0 1f 00 e5 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000382c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003830:	70 0c       	ld.w	r12,r8[0x0]
80003832:	f0 1f 00 d0 	mcall	80003b70 <phy_rx_func+0xe98>
80003836:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003838:	c0 71       	brne	80003846 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000383a:	30 09       	mov	r9,0
8000383c:	fe f8 03 58 	ld.w	r8,pc[856]
80003840:	91 09       	st.w	r8[0x0],r9
80003842:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003846:	fe f9 03 56 	ld.w	r9,pc[854]
8000384a:	72 08       	ld.w	r8,r9[0x0]
8000384c:	20 18       	sub	r8,1
8000384e:	93 08       	st.w	r9[0x0],r8
80003850:	c0 71       	brne	8000385e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003852:	30 09       	mov	r9,0
80003854:	fe f8 03 40 	ld.w	r8,pc[832]
80003858:	91 09       	st.w	r8[0x0],r9
8000385a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000385e:	fe f8 03 56 	ld.w	r8,pc[854]
80003862:	fe f9 03 2e 	ld.w	r9,pc[814]
80003866:	72 0a       	ld.w	r10,r9[0x0]
80003868:	70 09       	ld.w	r9,r8[0x0]
8000386a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000386e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003872:	70 09       	ld.w	r9,r8[0x0]
80003874:	2f f9       	sub	r9,-1
80003876:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003878:	e0 49 01 ff 	cp.w	r9,511
8000387c:	e0 88 00 16 	brls	800038a8 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003880:	30 09       	mov	r9,0
80003882:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003884:	fe f6 03 0c 	ld.w	r6,pc[780]
80003888:	6c 0c       	ld.w	r12,r6[0x0]
8000388a:	f0 1f 00 cd 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000388e:	fe f8 02 fa 	ld.w	r8,pc[762]
80003892:	70 0c       	ld.w	r12,r8[0x0]
80003894:	f0 1f 00 b7 	mcall	80003b70 <phy_rx_func+0xe98>
80003898:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000389a:	c0 71       	brne	800038a8 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
8000389c:	30 09       	mov	r9,0
8000389e:	fe f8 02 f6 	ld.w	r8,pc[758]
800038a2:	91 09       	st.w	r8[0x0],r9
800038a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038a8:	fe f9 02 f4 	ld.w	r9,pc[756]
800038ac:	72 08       	ld.w	r8,r9[0x0]
800038ae:	20 18       	sub	r8,1
800038b0:	93 08       	st.w	r9[0x0],r8
800038b2:	c0 71       	brne	800038c0 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800038b4:	30 09       	mov	r9,0
800038b6:	fe f8 02 de 	ld.w	r8,pc[734]
800038ba:	91 09       	st.w	r8[0x0],r9
800038bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800038c0:	fe f8 02 f4 	ld.w	r8,pc[756]
800038c4:	fe f9 02 cc 	ld.w	r9,pc[716]
800038c8:	72 0a       	ld.w	r10,r9[0x0]
800038ca:	70 09       	ld.w	r9,r8[0x0]
800038cc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800038d0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038d4:	70 09       	ld.w	r9,r8[0x0]
800038d6:	2f f9       	sub	r9,-1
800038d8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038da:	e0 49 01 ff 	cp.w	r9,511
800038de:	e0 88 00 16 	brls	8000390a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800038e2:	30 09       	mov	r9,0
800038e4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038e6:	fe f7 02 aa 	ld.w	r7,pc[682]
800038ea:	6e 0c       	ld.w	r12,r7[0x0]
800038ec:	f0 1f 00 b4 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038f0:	fe f8 02 98 	ld.w	r8,pc[664]
800038f4:	70 0c       	ld.w	r12,r8[0x0]
800038f6:	f0 1f 00 9f 	mcall	80003b70 <phy_rx_func+0xe98>
800038fa:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038fc:	c0 71       	brne	8000390a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800038fe:	30 09       	mov	r9,0
80003900:	fe f8 02 94 	ld.w	r8,pc[660]
80003904:	91 09       	st.w	r8[0x0],r9
80003906:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000390a:	fe f9 02 92 	ld.w	r9,pc[658]
8000390e:	72 08       	ld.w	r8,r9[0x0]
80003910:	20 18       	sub	r8,1
80003912:	93 08       	st.w	r9[0x0],r8
80003914:	c0 71       	brne	80003922 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003916:	30 09       	mov	r9,0
80003918:	fe f8 02 7c 	ld.w	r8,pc[636]
8000391c:	91 09       	st.w	r8[0x0],r9
8000391e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003922:	20 18       	sub	r8,1
80003924:	fe f9 02 78 	ld.w	r9,pc[632]
80003928:	93 08       	st.w	r9[0x0],r8
8000392a:	58 08       	cp.w	r8,0
8000392c:	e0 81 01 13 	brne	80003b52 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003930:	30 09       	mov	r9,0
80003932:	fe f8 02 62 	ld.w	r8,pc[610]
80003936:	91 09       	st.w	r8[0x0],r9
80003938:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000393c:	fe f8 02 70 	ld.w	r8,pc[624]
80003940:	11 89       	ld.ub	r9,r8[0x0]
80003942:	30 48       	mov	r8,4
80003944:	f0 09 18 00 	cp.b	r9,r8
80003948:	c0 80       	breq	80003958 <phy_rx_func+0xc80>
8000394a:	fe f8 02 62 	ld.w	r8,pc[610]
8000394e:	11 89       	ld.ub	r9,r8[0x0]
80003950:	30 38       	mov	r8,3
80003952:	f0 09 18 00 	cp.b	r9,r8
80003956:	c1 41       	brne	8000397e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003958:	6e 29       	ld.w	r9,r7[0x8]
8000395a:	fe f8 02 7a 	ld.w	r8,pc[634]
8000395e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003960:	6e 39       	ld.w	r9,r7[0xc]
80003962:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003964:	fe f9 02 38 	ld.w	r9,pc[568]
80003968:	72 08       	ld.w	r8,r9[0x0]
8000396a:	20 88       	sub	r8,8
8000396c:	93 08       	st.w	r9[0x0],r8
8000396e:	e0 81 00 f2 	brne	80003b52 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003972:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003974:	fe f9 02 20 	ld.w	r9,pc[544]
80003978:	93 08       	st.w	r9[0x0],r8
8000397a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000397e:	fe f8 02 2e 	ld.w	r8,pc[558]
80003982:	11 89       	ld.ub	r9,r8[0x0]
80003984:	31 38       	mov	r8,19
80003986:	f0 09 18 00 	cp.b	r9,r8
8000398a:	e0 81 00 9c 	brne	80003ac2 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
8000398e:	fe f8 02 62 	ld.w	r8,pc[610]
80003992:	11 88       	ld.ub	r8,r8[0x0]
80003994:	30 c9       	mov	r9,12
80003996:	f2 08 18 00 	cp.b	r8,r9
8000399a:	e0 81 00 7b 	brne	80003a90 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
8000399e:	8e 49       	ld.sh	r9,r7[0x8]
800039a0:	fe f8 02 54 	ld.w	r8,pc[596]
800039a4:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800039a8:	30 09       	mov	r9,0
800039aa:	fe f8 02 46 	ld.w	r8,pc[582]
800039ae:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800039b0:	ef 39 00 0d 	ld.ub	r9,r7[13]
800039b4:	3f 38       	mov	r8,-13
800039b6:	f0 09 18 00 	cp.b	r9,r8
800039ba:	c6 61       	brne	80003a86 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800039bc:	10 99       	mov	r9,r8
800039be:	4f c8       	lddpc	r8,80003bac <phy_rx_func+0xed4>
800039c0:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800039c2:	ef 39 00 0c 	ld.ub	r9,r7[12]
800039c6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800039ca:	4f 58       	lddpc	r8,80003b9c <phy_rx_func+0xec4>
800039cc:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800039ce:	30 19       	mov	r9,1
800039d0:	fe f8 02 0c 	ld.w	r8,pc[524]
800039d4:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800039d6:	8e 79       	ld.sh	r9,r7[0xe]
800039d8:	fe f8 02 14 	ld.w	r8,pc[532]
800039dc:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800039de:	4f 68       	lddpc	r8,80003bb4 <phy_rx_func+0xedc>
800039e0:	4e c9       	lddpc	r9,80003b90 <phy_rx_func+0xeb8>
800039e2:	72 0a       	ld.w	r10,r9[0x0]
800039e4:	70 09       	ld.w	r9,r8[0x0]
800039e6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800039ea:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800039ee:	70 09       	ld.w	r9,r8[0x0]
800039f0:	2f f9       	sub	r9,-1
800039f2:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039f4:	e0 49 01 ff 	cp.w	r9,511
800039f8:	e0 88 00 13 	brls	80003a1e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800039fc:	30 09       	mov	r9,0
800039fe:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a00:	4e 46       	lddpc	r6,80003b90 <phy_rx_func+0xeb8>
80003a02:	6c 0c       	ld.w	r12,r6[0x0]
80003a04:	f0 1f 00 6e 	mcall	80003bbc <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a08:	4e 08       	lddpc	r8,80003b88 <phy_rx_func+0xeb0>
80003a0a:	70 0c       	ld.w	r12,r8[0x0]
80003a0c:	f0 1f 00 59 	mcall	80003b70 <phy_rx_func+0xe98>
80003a10:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a12:	c0 61       	brne	80003a1e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003a14:	30 09       	mov	r9,0
80003a16:	4e 08       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a18:	91 09       	st.w	r8[0x0],r9
80003a1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a1e:	4e 09       	lddpc	r9,80003b9c <phy_rx_func+0xec4>
80003a20:	72 08       	ld.w	r8,r9[0x0]
80003a22:	20 18       	sub	r8,1
80003a24:	93 08       	st.w	r9[0x0],r8
80003a26:	c0 61       	brne	80003a32 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003a28:	30 09       	mov	r9,0
80003a2a:	4d b8       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a2c:	91 09       	st.w	r8[0x0],r9
80003a2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003a32:	4e 18       	lddpc	r8,80003bb4 <phy_rx_func+0xedc>
80003a34:	4d 79       	lddpc	r9,80003b90 <phy_rx_func+0xeb8>
80003a36:	72 0a       	ld.w	r10,r9[0x0]
80003a38:	70 09       	ld.w	r9,r8[0x0]
80003a3a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a3e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a42:	70 09       	ld.w	r9,r8[0x0]
80003a44:	2f f9       	sub	r9,-1
80003a46:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a48:	e0 49 01 ff 	cp.w	r9,511
80003a4c:	e0 88 00 13 	brls	80003a72 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a50:	30 09       	mov	r9,0
80003a52:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a54:	4c f7       	lddpc	r7,80003b90 <phy_rx_func+0xeb8>
80003a56:	6e 0c       	ld.w	r12,r7[0x0]
80003a58:	f0 1f 00 59 	mcall	80003bbc <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a5c:	4c b8       	lddpc	r8,80003b88 <phy_rx_func+0xeb0>
80003a5e:	70 0c       	ld.w	r12,r8[0x0]
80003a60:	f0 1f 00 44 	mcall	80003b70 <phy_rx_func+0xe98>
80003a64:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a66:	c0 61       	brne	80003a72 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003a68:	30 09       	mov	r9,0
80003a6a:	4c b8       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a6c:	91 09       	st.w	r8[0x0],r9
80003a6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a72:	4c b9       	lddpc	r9,80003b9c <phy_rx_func+0xec4>
80003a74:	72 08       	ld.w	r8,r9[0x0]
80003a76:	20 18       	sub	r8,1
80003a78:	93 08       	st.w	r9[0x0],r8
80003a7a:	c6 c1       	brne	80003b52 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003a7c:	30 09       	mov	r9,0
80003a7e:	4c 68       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a80:	91 09       	st.w	r8[0x0],r9
80003a82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003a86:	30 09       	mov	r9,0
80003a88:	4c 38       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a8a:	91 09       	st.w	r8[0x0],r9
80003a8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003a90:	8e 4a       	ld.sh	r10,r7[0x8]
80003a92:	4d 99       	lddpc	r9,80003bf4 <phy_rx_func+0xf1c>
80003a94:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003a98:	4d 6a       	lddpc	r10,80003bf0 <phy_rx_func+0xf18>
80003a9a:	15 88       	ld.ub	r8,r10[0x0]
80003a9c:	f0 cb ff ff 	sub	r11,r8,-1
80003aa0:	8e 5c       	ld.sh	r12,r7[0xa]
80003aa2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003aa6:	f0 cb ff fe 	sub	r11,r8,-2
80003aaa:	8e 6c       	ld.sh	r12,r7[0xc]
80003aac:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003ab0:	f0 cb ff fd 	sub	r11,r8,-3
80003ab4:	8e 7c       	ld.sh	r12,r7[0xe]
80003ab6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003aba:	2f c8       	sub	r8,-4
80003abc:	b4 88       	st.b	r10[0x0],r8
80003abe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003ac2:	30 09       	mov	r9,0
80003ac4:	4b 48       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003ac6:	91 09       	st.w	r8[0x0],r9
80003ac8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003acc:	4c 08       	lddpc	r8,80003bcc <phy_rx_func+0xef4>
80003ace:	70 09       	ld.w	r9,r8[0x0]
80003ad0:	8e 4b       	ld.sh	r11,r7[0x8]
80003ad2:	4c 0a       	lddpc	r10,80003bd0 <phy_rx_func+0xef8>
80003ad4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003ad8:	2f f9       	sub	r9,-1
80003ada:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003adc:	4b 58       	lddpc	r8,80003bb0 <phy_rx_func+0xed8>
80003ade:	70 09       	ld.w	r9,r8[0x0]
80003ae0:	20 29       	sub	r9,2
80003ae2:	91 09       	st.w	r8[0x0],r9
80003ae4:	70 08       	ld.w	r8,r8[0x0]
80003ae6:	58 08       	cp.w	r8,0
80003ae8:	c2 f1       	brne	80003b46 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003aea:	30 09       	mov	r9,0
80003aec:	4b 88       	lddpc	r8,80003bcc <phy_rx_func+0xef4>
80003aee:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003af0:	8e 59       	ld.sh	r9,r7[0xa]
80003af2:	fe 78 82 12 	mov	r8,-32238
80003af6:	f0 09 19 00 	cp.h	r9,r8
80003afa:	c2 11       	brne	80003b3c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003afc:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003b00:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003b04:	4a f8       	lddpc	r8,80003bc0 <phy_rx_func+0xee8>
80003b06:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003b08:	8e 59       	ld.sh	r9,r7[0xa]
80003b0a:	4a f8       	lddpc	r8,80003bc4 <phy_rx_func+0xeec>
80003b0c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003b0e:	8e 69       	ld.sh	r9,r7[0xc]
80003b10:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003b12:	f0 1f 00 2e 	mcall	80003bc8 <phy_rx_func+0xef0>
80003b16:	4a 18       	lddpc	r8,80003b98 <phy_rx_func+0xec0>
80003b18:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b1a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003b1e:	31 38       	mov	r8,19
80003b20:	f0 09 18 00 	cp.b	r9,r8
80003b24:	c0 71       	brne	80003b32 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003b26:	10 99       	mov	r9,r8
80003b28:	4a 18       	lddpc	r8,80003bac <phy_rx_func+0xed4>
80003b2a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003b2c:	30 09       	mov	r9,0
80003b2e:	49 c8       	lddpc	r8,80003b9c <phy_rx_func+0xec4>
80003b30:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003b32:	30 49       	mov	r9,4
80003b34:	49 88       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003b36:	91 09       	st.w	r8[0x0],r9
80003b38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003b3c:	30 09       	mov	r9,0
80003b3e:	49 68       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003b40:	91 09       	st.w	r8[0x0],r9
80003b42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003b46:	4a dc       	lddpc	r12,80003bf8 <phy_rx_func+0xf20>
80003b48:	f0 1f 00 18 	mcall	80003ba8 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003b4c:	30 09       	mov	r9,0
80003b4e:	49 28       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003b50:	91 09       	st.w	r8[0x0],r9
80003b52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b56:	00 00       	add	r0,r0
80003b58:	00 00       	add	r0,r0
80003b5a:	0a ac       	st.w	r5++,r12
80003b5c:	00 00       	add	r0,r0
80003b5e:	0a c4       	st.b	r5++,r4
80003b60:	00 00       	add	r0,r0
80003b62:	0a a4       	st.w	r5++,r4
80003b64:	00 00       	add	r0,r0
80003b66:	0a 86       	andn	r6,r5
80003b68:	00 00       	add	r0,r0
80003b6a:	0a 74       	tst	r4,r5
80003b6c:	00 00       	add	r0,r0
80003b6e:	0a 9c       	mov	r12,r5
80003b70:	80 00       	ld.sh	r0,r0[0x0]
80003b72:	2b 58       	sub	r8,-75
80003b74:	00 00       	add	r0,r0
80003b76:	0a 94       	mov	r4,r5
80003b78:	80 00       	ld.sh	r0,r0[0x0]
80003b7a:	2a 70       	sub	r0,-89
80003b7c:	00 00       	add	r0,r0
80003b7e:	0a a8       	st.w	r5++,r8
80003b80:	80 00       	ld.sh	r0,r0[0x0]
80003b82:	2a a4       	sub	r4,-86
80003b84:	00 00       	add	r0,r0
80003b86:	0a 85       	andn	r5,r5
80003b88:	00 00       	add	r0,r0
80003b8a:	0a a0       	st.w	r5++,r0
80003b8c:	00 00       	add	r0,r0
80003b8e:	0a b0       	st.h	r5++,r0
80003b90:	00 00       	add	r0,r0
80003b92:	0a 88       	andn	r8,r5
80003b94:	00 00       	add	r0,r0
80003b96:	0a d0       	st.w	--r5,r0
80003b98:	00 00       	add	r0,r0
80003b9a:	0a b8       	st.h	r5++,r8
80003b9c:	00 00       	add	r0,r0
80003b9e:	0a 70       	tst	r0,r5
80003ba0:	00 00       	add	r0,r0
80003ba2:	0a 54       	eor	r4,r5
80003ba4:	80 00       	ld.sh	r0,r0[0x0]
80003ba6:	d5 c0       	acall	0x5c
80003ba8:	80 00       	ld.sh	r0,r0[0x0]
80003baa:	6e bc       	ld.w	r12,r7[0x2c]
80003bac:	00 00       	add	r0,r0
80003bae:	0a 84       	andn	r4,r5
80003bb0:	00 00       	add	r0,r0
80003bb2:	0a dc       	st.w	--r5,r12
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a bc       	st.h	r5++,r12
80003bb8:	80 00       	ld.sh	r0,r0[0x0]
80003bba:	76 f4       	ld.w	r4,r11[0x3c]
80003bbc:	80 00       	ld.sh	r0,r0[0x0]
80003bbe:	2a 8c       	sub	r12,-88
80003bc0:	00 00       	add	r0,r0
80003bc2:	0a 48       	or	r8,r5
80003bc4:	00 00       	add	r0,r0
80003bc6:	1e a8       	st.w	pc++,r8
80003bc8:	80 00       	ld.sh	r0,r0[0x0]
80003bca:	2a 40       	sub	r0,-92
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 78       	tst	r8,r5
80003bd0:	00 00       	add	r0,r0
80003bd2:	1d ac       	ld.ub	r12,lr[0x2]
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a 7c       	tst	r12,r5
80003bd8:	00 00       	add	r0,r0
80003bda:	0a 49       	or	r9,r5
80003bdc:	00 00       	add	r0,r0
80003bde:	0a 4c       	or	r12,r5
80003be0:	00 00       	add	r0,r0
80003be2:	0a d4       	st.w	--r5,r4
80003be4:	00 00       	add	r0,r0
80003be6:	0a 90       	mov	r0,r5
80003be8:	00 00       	add	r0,r0
80003bea:	0a 5c       	eor	r12,r5
80003bec:	00 00       	add	r0,r0
80003bee:	1d a4       	ld.ub	r4,lr[0x2]
80003bf0:	00 00       	add	r0,r0
80003bf2:	0a c8       	st.b	r5++,r8
80003bf4:	00 00       	add	r0,r0
80003bf6:	1e ac       	st.w	pc++,r12
80003bf8:	80 00       	ld.sh	r0,r0[0x0]
80003bfa:	d5 d8       	*unknown*

80003bfc <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003bfc:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003bfe:	49 a8       	lddpc	r8,80003c64 <pdca_int_handler+0x68>
80003c00:	70 09       	ld.w	r9,r8[0x0]
80003c02:	2f f9       	sub	r9,-1
80003c04:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003c06:	49 98       	lddpc	r8,80003c68 <pdca_int_handler+0x6c>
80003c08:	11 89       	ld.ub	r9,r8[0x0]
80003c0a:	ec 19 00 01 	eorl	r9,0x1
80003c0e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003c10:	11 89       	ld.ub	r9,r8[0x0]
80003c12:	a5 69       	lsl	r9,0x4
80003c14:	2f c9       	sub	r9,-4
80003c16:	49 6a       	lddpc	r10,80003c6c <pdca_int_handler+0x70>
80003c18:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003c1a:	fe 7a 00 40 	mov	r10,-65472
80003c1e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c20:	30 39       	mov	r9,3
80003c22:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c24:	11 8a       	ld.ub	r10,r8[0x0]
80003c26:	a5 6a       	lsl	r10,0x4
80003c28:	2f ca       	sub	r10,-4
80003c2a:	49 28       	lddpc	r8,80003c70 <pdca_int_handler+0x74>
80003c2c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c2e:	fe 78 00 00 	mov	r8,-65536
80003c32:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c34:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c36:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c38:	48 f8       	lddpc	r8,80003c74 <pdca_int_handler+0x78>
80003c3a:	70 08       	ld.w	r8,r8[0x0]
80003c3c:	58 08       	cp.w	r8,0
80003c3e:	c0 70       	breq	80003c4c <pdca_int_handler+0x50>
80003c40:	48 a9       	lddpc	r9,80003c68 <pdca_int_handler+0x6c>
80003c42:	13 89       	ld.ub	r9,r9[0x0]
80003c44:	a5 69       	lsl	r9,0x4
80003c46:	48 bc       	lddpc	r12,80003c70 <pdca_int_handler+0x74>
80003c48:	12 0c       	add	r12,r9
80003c4a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c4c:	48 b8       	lddpc	r8,80003c78 <pdca_int_handler+0x7c>
80003c4e:	70 08       	ld.w	r8,r8[0x0]
80003c50:	58 08       	cp.w	r8,0
80003c52:	c0 70       	breq	80003c60 <pdca_int_handler+0x64>
80003c54:	48 59       	lddpc	r9,80003c68 <pdca_int_handler+0x6c>
80003c56:	13 89       	ld.ub	r9,r9[0x0]
80003c58:	a5 69       	lsl	r9,0x4
80003c5a:	48 5c       	lddpc	r12,80003c6c <pdca_int_handler+0x70>
80003c5c:	12 0c       	add	r12,r9
80003c5e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003c60:	d4 02       	popm	lr
80003c62:	d6 03       	rete
80003c64:	00 00       	add	r0,r0
80003c66:	0a e4       	st.h	--r5,r4
80003c68:	00 00       	add	r0,r0
80003c6a:	50 cc       	stdsp	sp[0x30],r12
80003c6c:	00 00       	add	r0,r0
80003c6e:	50 f4       	stdsp	sp[0x3c],r4
80003c70:	00 00       	add	r0,r0
80003c72:	50 d4       	stdsp	sp[0x34],r4
80003c74:	00 00       	add	r0,r0
80003c76:	0a e0       	st.h	--r5,r0
80003c78:	00 00       	add	r0,r0
80003c7a:	0a e8       	st.h	--r5,r8

80003c7c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003c7c:	fe 78 10 00 	mov	r8,-61440
80003c80:	e0 69 0d c0 	mov	r9,3520
80003c84:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003c88:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003c8c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003c90:	fe 78 34 00 	mov	r8,-52224
80003c94:	e0 69 80 00 	mov	r9,32768
80003c98:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003c9a:	30 09       	mov	r9,0
80003c9c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003c9e:	e0 69 04 21 	mov	r9,1057
80003ca2:	ea 19 3f 20 	orh	r9,0x3f20
80003ca6:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003ca8:	e0 69 02 9f 	mov	r9,671
80003cac:	ea 19 01 00 	orh	r9,0x100
80003cb0:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003cb2:	e0 6a 04 02 	mov	r10,1026
80003cb6:	ea 1a 3f 20 	orh	r10,0x3f20
80003cba:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003cbc:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003cbe:	5e fc       	retal	r12

80003cc0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003cc0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003cc2:	30 19       	mov	r9,1
80003cc4:	49 78       	lddpc	r8,80003d20 <local_start_PDC+0x60>
80003cc6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003cc8:	fe 78 00 00 	mov	r8,-65536
80003ccc:	30 7b       	mov	r11,7
80003cce:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003cd0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003cd2:	49 59       	lddpc	r9,80003d24 <local_start_PDC+0x64>
80003cd4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003cd8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003cda:	30 3a       	mov	r10,3
80003cdc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003cde:	30 1c       	mov	r12,1
80003ce0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003ce2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003ce4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003ce6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ce8:	30 2c       	mov	r12,2
80003cea:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003cec:	48 f9       	lddpc	r9,80003d28 <local_start_PDC+0x68>
80003cee:	e0 68 5a 5a 	mov	r8,23130
80003cf2:	ea 18 ab cd 	orh	r8,0xabcd
80003cf6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003cf8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003cfa:	30 0e       	mov	lr,0
80003cfc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003cfe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003d00:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003d02:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003d04:	fe 78 00 40 	mov	r8,-65472
80003d08:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003d0a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003d0c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003d10:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003d12:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003d14:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003d16:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003d18:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d1a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d1c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003d1e:	d8 02       	popm	pc
80003d20:	00 00       	add	r0,r0
80003d22:	50 cc       	stdsp	sp[0x30],r12
80003d24:	00 00       	add	r0,r0
80003d26:	50 d4       	stdsp	sp[0x34],r4
80003d28:	00 00       	add	r0,r0
80003d2a:	50 f4       	stdsp	sp[0x3c],r4

80003d2c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d2c:	48 38       	lddpc	r8,80003d38 <register_rx_tx_func+0xc>
80003d2e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d30:	48 38       	lddpc	r8,80003d3c <register_rx_tx_func+0x10>
80003d32:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d34:	5e fc       	retal	r12
80003d36:	00 00       	add	r0,r0
80003d38:	00 00       	add	r0,r0
80003d3a:	0a e0       	st.h	--r5,r0
80003d3c:	00 00       	add	r0,r0
80003d3e:	0a e8       	st.h	--r5,r8

80003d40 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d40:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d42:	fe 78 10 00 	mov	r8,-61440
80003d46:	30 29       	mov	r9,2
80003d48:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d4c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003d50:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003d52:	30 3a       	mov	r10,3
80003d54:	36 0b       	mov	r11,96
80003d56:	49 4c       	lddpc	r12,80003da4 <ssc_init+0x64>
80003d58:	f0 1f 00 14 	mcall	80003da8 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003d5c:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003d5e:	fe 79 10 00 	mov	r9,-61440
80003d62:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d66:	e2 18 00 02 	andl	r8,0x2,COH
80003d6a:	cf c0       	breq	80003d62 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003d6c:	fe 79 10 00 	mov	r9,-61440
80003d70:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d74:	e2 18 00 02 	andl	r8,0x2,COH
80003d78:	cf c1       	brne	80003d70 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003d7a:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003d7c:	f0 1f 00 0c 	mcall	80003dac <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003d80:	f0 1f 00 0c 	mcall	80003db0 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d84:	fe 79 00 00 	mov	r9,-65536
80003d88:	30 18       	mov	r8,1
80003d8a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d8c:	fe 7a 00 40 	mov	r10,-65472
80003d90:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003d92:	e0 6b 01 01 	mov	r11,257
80003d96:	fe 7a 34 00 	mov	r10,-52224
80003d9a:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003d9c:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003d9e:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003da0:	d8 02       	popm	pc
80003da2:	00 00       	add	r0,r0
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	3b fc       	mov	r12,-65
80003da8:	80 00       	ld.sh	r0,r0[0x0]
80003daa:	53 60       	stdsp	sp[0xd8],r0
80003dac:	80 00       	ld.sh	r0,r0[0x0]
80003dae:	3c 7c       	mov	r12,-57
80003db0:	80 00       	ld.sh	r0,r0[0x0]
80003db2:	3c c0       	mov	r0,-52

80003db4 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003db4:	48 28       	lddpc	r8,80003dbc <xcmp_register_app_list+0x8>
80003db6:	91 0c       	st.w	r8[0x0],r12
}
80003db8:	5e fc       	retal	r12
80003dba:	00 00       	add	r0,r0
80003dbc:	00 00       	add	r0,r0
80003dbe:	51 14       	stdsp	sp[0x44],r4

80003dc0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003dc0:	eb cd 40 80 	pushm	r7,lr
80003dc4:	fa cd 01 00 	sub	sp,sp,256
80003dc8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003dca:	16 98       	mov	r8,r11
80003dcc:	2f 08       	sub	r8,-16
80003dce:	af a8       	sbr	r8,0xe
80003dd0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003dd2:	3f f8       	mov	r8,-1
80003dd4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003dd6:	30 b9       	mov	r9,11
80003dd8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003dda:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ddc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003dde:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003de0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003de2:	f6 ca ff fe 	sub	r10,r11,-2
80003de6:	18 9b       	mov	r11,r12
80003de8:	fa cc ff f0 	sub	r12,sp,-16
80003dec:	f0 1f 00 05 	mcall	80003e00 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003df0:	2f e7       	sub	r7,-2
80003df2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003df4:	1a 9c       	mov	r12,sp
80003df6:	f0 1f 00 04 	mcall	80003e04 <xcmp_tx+0x44>
}
80003dfa:	2c 0d       	sub	sp,-256
80003dfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e00:	80 00       	ld.sh	r0,r0[0x0]
80003e02:	75 ac       	ld.w	r12,r10[0x68]
80003e04:	80 00       	ld.sh	r0,r0[0x0]
80003e06:	43 cc       	lddsp	r12,sp[0xf0]

80003e08 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003e08:	d4 21       	pushm	r4-r7,lr
80003e0a:	fa cd 00 d0 	sub	sp,sp,208
80003e0e:	18 94       	mov	r4,r12
80003e10:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003e12:	e0 68 01 00 	mov	r8,256
80003e16:	f0 0b 19 00 	cp.h	r11,r8
80003e1a:	e0 8b 00 36 	brhi	80003e86 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003e1e:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003e22:	e0 68 04 1d 	mov	r8,1053
80003e26:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003e28:	30 18       	mov	r8,1
80003e2a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003e2c:	32 08       	mov	r8,32
80003e2e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003e30:	30 28       	mov	r8,2
80003e32:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003e34:	30 48       	mov	r8,4
80003e36:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003e38:	ea 1a 0c 00 	orh	r10,0xc00
80003e3c:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003e3e:	30 4a       	mov	r10,4
80003e40:	1a 9b       	mov	r11,sp
80003e42:	fa cc ff f4 	sub	r12,sp,-12
80003e46:	f0 1f 00 12 	mcall	80003e8c <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003e4a:	30 f8       	mov	r8,15
80003e4c:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003e50:	3a 78       	mov	r8,-89
80003e52:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003e56:	30 08       	mov	r8,0
80003e58:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003e5c:	0e 9a       	mov	r10,r7
80003e5e:	5c 7a       	castu.h	r10
80003e60:	f4 08 16 08 	lsr	r8,r10,0x8
80003e64:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003e68:	0e 96       	mov	r6,r7
80003e6a:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003e6e:	08 9b       	mov	r11,r4
80003e70:	fa cc ff eb 	sub	r12,sp,-21
80003e74:	f0 1f 00 06 	mcall	80003e8c <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003e78:	ee cb ff f3 	sub	r11,r7,-13
80003e7c:	5c 5b       	castu.b	r11
80003e7e:	fa cc ff fa 	sub	r12,sp,-6
80003e82:	f0 1f 00 04 	mcall	80003e90 <xcmp_data_session_req+0x88>
}
80003e86:	2c cd       	sub	sp,-208
80003e88:	d8 22       	popm	r4-r7,pc
80003e8a:	00 00       	add	r0,r0
80003e8c:	80 00       	ld.sh	r0,r0[0x0]
80003e8e:	75 ac       	ld.w	r12,r10[0x68]
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	3d c0       	mov	r0,-36

80003e94 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003e94:	d4 01       	pushm	lr
80003e96:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003e9a:	fe 78 b4 00 	mov	r8,-19456
80003e9e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003ea0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003ea4:	30 89       	mov	r9,8
80003ea6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003ea8:	30 19       	mov	r9,1
80003eaa:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003eac:	30 09       	mov	r9,0
80003eae:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003eb0:	30 5a       	mov	r10,5
80003eb2:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003eb4:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003eb6:	30 7a       	mov	r10,7
80003eb8:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003eba:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003ebc:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003ebe:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003ec2:	30 9b       	mov	r11,9
80003ec4:	fa cc ff fe 	sub	r12,sp,-2
80003ec8:	f0 1f 00 02 	mcall	80003ed0 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003ecc:	2c dd       	sub	sp,-204
80003ece:	d8 02       	popm	pc
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	3d c0       	mov	r0,-36

80003ed4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003ed4:	d4 01       	pushm	lr
80003ed6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003eda:	fe 78 80 00 	mov	r8,-32768
80003ede:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003ee0:	30 38       	mov	r8,3
80003ee2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003ee4:	30 1b       	mov	r11,1
80003ee6:	fa cc ff fe 	sub	r12,sp,-2
80003eea:	f0 1f 00 03 	mcall	80003ef4 <xcmp_opcode_not_supported+0x20>
}
80003eee:	2c dd       	sub	sp,-204
80003ef0:	d8 02       	popm	pc
80003ef2:	00 00       	add	r0,r0
80003ef4:	80 00       	ld.sh	r0,r0[0x0]
80003ef6:	3d c0       	mov	r0,-36

80003ef8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003ef8:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003efa:	96 88       	ld.uh	r8,r11[0x0]
80003efc:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f00:	e0 48 80 00 	cp.w	r8,32768
80003f04:	c0 f0       	breq	80003f22 <xcmp_exec_func+0x2a>
80003f06:	e0 48 b0 00 	cp.w	r8,45056
80003f0a:	c1 20       	breq	80003f2e <xcmp_exec_func+0x36>
80003f0c:	58 08       	cp.w	r8,0
80003f0e:	c1 51       	brne	80003f38 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f10:	78 08       	ld.w	r8,r12[0x0]
80003f12:	58 08       	cp.w	r8,0
80003f14:	c0 40       	breq	80003f1c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f16:	16 9c       	mov	r12,r11
80003f18:	5d 18       	icall	r8
80003f1a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003f1c:	f0 1f 00 08 	mcall	80003f3c <xcmp_exec_func+0x44>
80003f20:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003f22:	78 18       	ld.w	r8,r12[0x4]
80003f24:	58 08       	cp.w	r8,0
80003f26:	c0 90       	breq	80003f38 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003f28:	16 9c       	mov	r12,r11
80003f2a:	5d 18       	icall	r8
80003f2c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003f2e:	78 28       	ld.w	r8,r12[0x8]
80003f30:	58 08       	cp.w	r8,0
80003f32:	c0 30       	breq	80003f38 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003f34:	16 9c       	mov	r12,r11
80003f36:	5d 18       	icall	r8
80003f38:	d8 02       	popm	pc
80003f3a:	00 00       	add	r0,r0
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	3e d4       	mov	r4,-19

80003f40 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003f40:	d4 01       	pushm	lr
80003f42:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003f46:	e0 68 04 09 	mov	r8,1033
80003f4a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f4c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003f50:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003f52:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003f56:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003f58:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003f5a:	30 09       	mov	r9,0
80003f5c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003f5e:	fb 69 00 08 	st.b	sp[8],r9
80003f62:	fa c8 ff f7 	sub	r8,sp,-9
80003f66:	b0 89       	st.b	r8[0x0],r9
80003f68:	fa c8 ff f6 	sub	r8,sp,-10
80003f6c:	b0 89       	st.b	r8[0x0],r9
80003f6e:	fa c8 ff f5 	sub	r8,sp,-11
80003f72:	b0 89       	st.b	r8[0x0],r9
80003f74:	fa c8 ff f4 	sub	r8,sp,-12
80003f78:	b0 89       	st.b	r8[0x0],r9
80003f7a:	fa c8 ff f3 	sub	r8,sp,-13
80003f7e:	b0 89       	st.b	r8[0x0],r9
80003f80:	fa c8 ff f2 	sub	r8,sp,-14
80003f84:	b0 89       	st.b	r8[0x0],r9
80003f86:	fa c8 ff f1 	sub	r8,sp,-15
80003f8a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003f8c:	30 cb       	mov	r11,12
80003f8e:	fa cc ff fe 	sub	r12,sp,-2
80003f92:	f0 1f 00 03 	mcall	80003f9c <xcmp_IdleTestTone+0x5c>
}
80003f96:	2c dd       	sub	sp,-204
80003f98:	d8 02       	popm	pc
80003f9a:	00 00       	add	r0,r0
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	3d c0       	mov	r0,-36

80003fa0 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003fa0:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003fa2:	48 dc       	lddpc	r12,80003fd4 <xcmp_init+0x34>
80003fa4:	f0 1f 00 0d 	mcall	80003fd8 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003fa8:	30 4b       	mov	r11,4
80003faa:	31 4c       	mov	r12,20
80003fac:	f0 1f 00 0c 	mcall	80003fdc <xcmp_init+0x3c>
80003fb0:	48 c8       	lddpc	r8,80003fe0 <xcmp_init+0x40>
80003fb2:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003fb4:	30 09       	mov	r9,0
80003fb6:	1a d9       	st.w	--sp,r9
80003fb8:	1a d9       	st.w	--sp,r9
80003fba:	1a d9       	st.w	--sp,r9
80003fbc:	30 38       	mov	r8,3
80003fbe:	e0 6a 04 00 	mov	r10,1024
80003fc2:	48 9b       	lddpc	r11,80003fe4 <xcmp_init+0x44>
80003fc4:	48 9c       	lddpc	r12,80003fe8 <xcmp_init+0x48>
80003fc6:	f0 1f 00 0a 	mcall	80003fec <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003fca:	f0 1f 00 0a 	mcall	80003ff0 <xcmp_init+0x50>
80003fce:	2f dd       	sub	sp,-12
	
}
80003fd0:	d8 02       	popm	pc
80003fd2:	00 00       	add	r0,r0
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	40 f0       	lddsp	r0,sp[0x3c]
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	41 3c       	lddsp	r12,sp[0x4c]
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	62 50       	ld.w	r0,r1[0x14]
80003fe0:	00 00       	add	r0,r0
80003fe2:	0b 04       	ld.w	r4,r5++
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	d6 04       	*unknown*
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	3f f4       	mov	r4,-1
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	69 6c       	ld.w	r12,r4[0x58]
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	41 74       	lddsp	r4,sp[0x5c]

80003ff4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003ff4:	d4 31       	pushm	r0-r7,lr
80003ff6:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003ff8:	4b 16       	lddpc	r6,800040bc <xcmp_rx_process+0xc8>
80003ffa:	30 05       	mov	r5,0
80003ffc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003ffe:	4b 13       	lddpc	r3,800040c0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004000:	4b 12       	lddpc	r2,800040c4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004002:	4b 21       	lddpc	r1,800040c8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004004:	4b 20       	lddpc	r0,800040cc <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004006:	6c 0c       	ld.w	r12,r6[0x0]
80004008:	0a 99       	mov	r9,r5
8000400a:	08 9a       	mov	r10,r4
8000400c:	1a 9b       	mov	r11,sp
8000400e:	f0 1f 00 31 	mcall	800040d0 <xcmp_rx_process+0xdc>
80004012:	58 1c       	cp.w	r12,1
80004014:	cf 91       	brne	80004006 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004016:	40 0b       	lddsp	r11,sp[0x0]
80004018:	58 0b       	cp.w	r11,0
8000401a:	cf 60       	breq	80004006 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
8000401c:	96 0a       	ld.sh	r10,r11[0x0]
8000401e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004022:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004026:	59 c8       	cp.w	r8,28
80004028:	c1 e0       	breq	80004064 <xcmp_rx_process+0x70>
8000402a:	e0 89 00 07 	brgt	80004038 <xcmp_rx_process+0x44>
8000402e:	58 e8       	cp.w	r8,14
80004030:	c0 e0       	breq	8000404c <xcmp_rx_process+0x58>
80004032:	58 f8       	cp.w	r8,15
80004034:	c2 41       	brne	8000407c <xcmp_rx_process+0x88>
80004036:	c0 f8       	rjmp	80004054 <xcmp_rx_process+0x60>
80004038:	e0 48 01 09 	cp.w	r8,265
8000403c:	c1 80       	breq	8000406c <xcmp_rx_process+0x78>
8000403e:	e0 48 01 0a 	cp.w	r8,266
80004042:	c1 90       	breq	80004074 <xcmp_rx_process+0x80>
80004044:	e0 48 00 2c 	cp.w	r8,44
80004048:	c1 a1       	brne	8000407c <xcmp_rx_process+0x88>
8000404a:	c0 98       	rjmp	8000405c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000404c:	4a 2c       	lddpc	r12,800040d4 <xcmp_rx_process+0xe0>
8000404e:	f0 1f 00 23 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004052:	c2 f8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004054:	4a 2c       	lddpc	r12,800040dc <xcmp_rx_process+0xe8>
80004056:	f0 1f 00 21 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
8000405a:	c2 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000405c:	4a 1c       	lddpc	r12,800040e0 <xcmp_rx_process+0xec>
8000405e:	f0 1f 00 1f 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004062:	c2 78       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004064:	04 9c       	mov	r12,r2
80004066:	f0 1f 00 1d 	mcall	800040d8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000406a:	c2 38       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000406c:	02 9c       	mov	r12,r1
8000406e:	f0 1f 00 1b 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004072:	c1 f8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004074:	00 9c       	mov	r12,r0
80004076:	f0 1f 00 19 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
8000407a:	c1 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000407c:	12 98       	mov	r8,r9
8000407e:	e2 18 04 00 	andl	r8,0x400,COH
80004082:	c0 70       	breq	80004090 <xcmp_rx_process+0x9c>
80004084:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004088:	e0 48 00 68 	cp.w	r8,104
8000408c:	e0 8a 00 08 	brle	8000409c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004090:	e2 19 f0 00 	andl	r9,0xf000,COH
80004094:	c0 e1       	brne	800040b0 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004096:	f0 1f 00 14 	mcall	800040e4 <xcmp_rx_process+0xf0>
8000409a:	c0 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000409c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800040a0:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800040a4:	49 19       	lddpc	r9,800040e8 <xcmp_rx_process+0xf4>
800040a6:	72 08       	ld.w	r8,r9[0x0]
800040a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800040ac:	f0 1f 00 0b 	mcall	800040d8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040b0:	66 0c       	ld.w	r12,r3[0x0]
800040b2:	40 0b       	lddsp	r11,sp[0x0]
800040b4:	f0 1f 00 0e 	mcall	800040ec <xcmp_rx_process+0xf8>
800040b8:	ca 7b       	rjmp	80004006 <xcmp_rx_process+0x12>
800040ba:	00 00       	add	r0,r0
800040bc:	00 00       	add	r0,r0
800040be:	0b 04       	ld.w	r4,r5++
800040c0:	00 00       	add	r0,r0
800040c2:	0a 9c       	mov	r12,r5
800040c4:	00 00       	add	r0,r0
800040c6:	0b 14       	ld.sh	r4,r5++
800040c8:	00 00       	add	r0,r0
800040ca:	0b 08       	ld.w	r8,r5++
800040cc:	00 00       	add	r0,r0
800040ce:	0a f8       	st.b	--r5,r8
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	5f 44       	srge	r4
800040d4:	00 00       	add	r0,r0
800040d6:	0b 2c       	ld.uh	r12,r5++
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	3e f8       	mov	r8,-17
800040dc:	00 00       	add	r0,r0
800040de:	0a ec       	st.h	--r5,r12
800040e0:	00 00       	add	r0,r0
800040e2:	0b 20       	ld.uh	r0,r5++
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	3e d4       	mov	r4,-19
800040e8:	00 00       	add	r0,r0
800040ea:	51 14       	stdsp	sp[0x44],r4
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	2a dc       	sub	r12,-83

800040f0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800040f0:	eb cd 40 90 	pushm	r4,r7,lr
800040f4:	20 1d       	sub	sp,4
800040f6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800040fa:	48 c8       	lddpc	r8,80004128 <xcmp_rx+0x38>
800040fc:	70 0c       	ld.w	r12,r8[0x0]
800040fe:	f0 1f 00 0c 	mcall	8000412c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004102:	c1 00       	breq	80004122 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004104:	fa c7 ff fc 	sub	r7,sp,-4
80004108:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000410a:	e0 6a 00 ca 	mov	r10,202
8000410e:	08 9b       	mov	r11,r4
80004110:	f0 1f 00 08 	mcall	80004130 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004114:	48 88       	lddpc	r8,80004134 <xcmp_rx+0x44>
80004116:	70 0c       	ld.w	r12,r8[0x0]
80004118:	30 09       	mov	r9,0
8000411a:	12 9a       	mov	r10,r9
8000411c:	1a 9b       	mov	r11,sp
8000411e:	f0 1f 00 07 	mcall	80004138 <xcmp_rx+0x48>
	}	
}
80004122:	2f fd       	sub	sp,-4
80004124:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004128:	00 00       	add	r0,r0
8000412a:	0a 9c       	mov	r12,r5
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	2c 88       	sub	r8,-56
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	75 ac       	ld.w	r12,r10[0x68]
80004134:	00 00       	add	r0,r0
80004136:	0b 04       	ld.w	r4,r5++
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	61 50       	ld.w	r0,r0[0x54]

8000413c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000413c:	48 28       	lddpc	r8,80004144 <xnl_register_xcmp_func+0x8>
8000413e:	91 0c       	st.w	r8[0x0],r12
}
80004140:	5e fc       	retal	r12
80004142:	00 00       	add	r0,r0
80004144:	00 00       	add	r0,r0
80004146:	0b 58       	ld.sh	r8,--r5

80004148 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004148:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000414a:	48 88       	lddpc	r8,80004168 <xnl_get_msg_ack_func+0x20>
8000414c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000414e:	98 49       	ld.sh	r9,r12[0x8]
80004150:	f0 09 19 00 	cp.h	r9,r8
80004154:	c0 81       	brne	80004164 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004156:	48 68       	lddpc	r8,8000416c <xnl_get_msg_ack_func+0x24>
80004158:	70 0c       	ld.w	r12,r8[0x0]
8000415a:	30 09       	mov	r9,0
8000415c:	12 9a       	mov	r10,r9
8000415e:	12 9b       	mov	r11,r9
80004160:	f0 1f 00 04 	mcall	80004170 <xnl_get_msg_ack_func+0x28>
80004164:	d8 02       	popm	pc
80004166:	00 00       	add	r0,r0
80004168:	00 00       	add	r0,r0
8000416a:	0b 3e       	ld.ub	lr,r5++
8000416c:	00 00       	add	r0,r0
8000416e:	0b 38       	ld.ub	r8,r5++
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	61 50       	ld.w	r0,r0[0x54]

80004174 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004174:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004178:	30 09       	mov	r9,0
8000417a:	4b 78       	lddpc	r8,80004254 <xnl_init+0xe0>
8000417c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000417e:	30 0b       	mov	r11,0
80004180:	30 1c       	mov	r12,1
80004182:	f0 1f 00 36 	mcall	80004258 <xnl_init+0xe4>
80004186:	4b 68       	lddpc	r8,8000425c <xnl_init+0xe8>
80004188:	91 0c       	st.w	r8[0x0],r12
8000418a:	70 08       	ld.w	r8,r8[0x0]
8000418c:	58 08       	cp.w	r8,0
8000418e:	c0 80       	breq	8000419e <xnl_init+0x2a>
80004190:	4b 38       	lddpc	r8,8000425c <xnl_init+0xe8>
80004192:	70 0c       	ld.w	r12,r8[0x0]
80004194:	30 09       	mov	r9,0
80004196:	12 9a       	mov	r10,r9
80004198:	12 9b       	mov	r11,r9
8000419a:	f0 1f 00 32 	mcall	80004260 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000419e:	30 4b       	mov	r11,4
800041a0:	31 4c       	mov	r12,20
800041a2:	f0 1f 00 2e 	mcall	80004258 <xnl_init+0xe4>
800041a6:	4b 08       	lddpc	r8,80004264 <xnl_init+0xf0>
800041a8:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800041aa:	30 4b       	mov	r11,4
800041ac:	31 ec       	mov	r12,30
800041ae:	f0 1f 00 2b 	mcall	80004258 <xnl_init+0xe4>
800041b2:	4a e8       	lddpc	r8,80004268 <xnl_init+0xf4>
800041b4:	91 0c       	st.w	r8[0x0],r12
800041b6:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800041b8:	10 96       	mov	r6,r8
800041ba:	4a d5       	lddpc	r5,8000426c <xnl_init+0xf8>
800041bc:	6c 0c       	ld.w	r12,r6[0x0]
800041be:	ea 07 00 0b 	add	r11,r5,r7
800041c2:	f0 1f 00 2c 	mcall	80004270 <xnl_init+0xfc>
800041c6:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800041ca:	e0 47 1e 00 	cp.w	r7,7680
800041ce:	cf 71       	brne	800041bc <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041d0:	30 4b       	mov	r11,4
800041d2:	31 4c       	mov	r12,20
800041d4:	f0 1f 00 21 	mcall	80004258 <xnl_init+0xe4>
800041d8:	4a 78       	lddpc	r8,80004274 <xnl_init+0x100>
800041da:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041dc:	30 4b       	mov	r11,4
800041de:	30 ac       	mov	r12,10
800041e0:	f0 1f 00 1e 	mcall	80004258 <xnl_init+0xe4>
800041e4:	4a 58       	lddpc	r8,80004278 <xnl_init+0x104>
800041e6:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800041e8:	30 4b       	mov	r11,4
800041ea:	30 ac       	mov	r12,10
800041ec:	f0 1f 00 1b 	mcall	80004258 <xnl_init+0xe4>
800041f0:	4a 38       	lddpc	r8,8000427c <xnl_init+0x108>
800041f2:	91 0c       	st.w	r8[0x0],r12
800041f4:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800041f6:	10 96       	mov	r6,r8
800041f8:	4a 25       	lddpc	r5,80004280 <xnl_init+0x10c>
800041fa:	6c 0c       	ld.w	r12,r6[0x0]
800041fc:	ea 07 00 0b 	add	r11,r5,r7
80004200:	f0 1f 00 1c 	mcall	80004270 <xnl_init+0xfc>
80004204:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004208:	e0 47 14 00 	cp.w	r7,5120
8000420c:	cf 71       	brne	800041fa <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000420e:	30 4b       	mov	r11,4
80004210:	30 5c       	mov	r12,5
80004212:	f0 1f 00 12 	mcall	80004258 <xnl_init+0xe4>
80004216:	49 c8       	lddpc	r8,80004284 <xnl_init+0x110>
80004218:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000421a:	30 07       	mov	r7,0
8000421c:	1a d7       	st.w	--sp,r7
8000421e:	1a d7       	st.w	--sp,r7
80004220:	1a d7       	st.w	--sp,r7
80004222:	30 38       	mov	r8,3
80004224:	0e 99       	mov	r9,r7
80004226:	e0 6a 00 dc 	mov	r10,220
8000422a:	49 8b       	lddpc	r11,80004288 <xnl_init+0x114>
8000422c:	49 8c       	lddpc	r12,8000428c <xnl_init+0x118>
8000422e:	f0 1f 00 19 	mcall	80004290 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004232:	1a d7       	st.w	--sp,r7
80004234:	1a d7       	st.w	--sp,r7
80004236:	1a d7       	st.w	--sp,r7
80004238:	30 38       	mov	r8,3
8000423a:	0e 99       	mov	r9,r7
8000423c:	e0 6a 00 82 	mov	r10,130
80004240:	49 5b       	lddpc	r11,80004294 <xnl_init+0x120>
80004242:	49 6c       	lddpc	r12,80004298 <xnl_init+0x124>
80004244:	f0 1f 00 13 	mcall	80004290 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004248:	f0 1f 00 15 	mcall	8000429c <xnl_init+0x128>
8000424c:	2f ad       	sub	sp,-24
}
8000424e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004252:	00 00       	add	r0,r0
80004254:	00 00       	add	r0,r0
80004256:	0b 3e       	ld.ub	lr,r5++
80004258:	80 00       	ld.sh	r0,r0[0x0]
8000425a:	62 50       	ld.w	r0,r1[0x14]
8000425c:	00 00       	add	r0,r0
8000425e:	0b 38       	ld.ub	r8,r5++
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	61 50       	ld.w	r0,r0[0x54]
80004264:	00 00       	add	r0,r0
80004266:	0b 4c       	ld.w	r12,--r5
80004268:	00 00       	add	r0,r0
8000426a:	0a 9c       	mov	r12,r5
8000426c:	00 00       	add	r0,r0
8000426e:	32 c6       	mov	r6,44
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	2a dc       	sub	r12,-83
80004274:	00 00       	add	r0,r0
80004276:	0a cc       	st.b	r5++,r12
80004278:	00 00       	add	r0,r0
8000427a:	0a ac       	st.w	r5++,r12
8000427c:	00 00       	add	r0,r0
8000427e:	0a a0       	st.w	r5++,r0
80004280:	00 00       	add	r0,r0
80004282:	1e c6       	st.b	pc++,r6
80004284:	00 00       	add	r0,r0
80004286:	0a d8       	st.w	--r5,r8
80004288:	80 00       	ld.sh	r0,r0[0x0]
8000428a:	d6 0c       	*unknown*
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	42 a0       	lddsp	r0,sp[0xa8]
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	69 6c       	ld.w	r12,r4[0x58]
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	d6 14       	*unknown*
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	43 00       	lddsp	r0,sp[0xc0]
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	2c b0       	sub	r0,-53

800042a0 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800042a0:	eb cd 40 fe 	pushm	r1-r7,lr
800042a4:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042a6:	49 26       	lddpc	r6,800042ec <xnl_rx_process+0x4c>
800042a8:	30 05       	mov	r5,0
800042aa:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042ac:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ae:	49 11       	lddpc	r1,800042f0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042b0:	49 12       	lddpc	r2,800042f4 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042b2:	6c 0c       	ld.w	r12,r6[0x0]
800042b4:	0a 99       	mov	r9,r5
800042b6:	08 9a       	mov	r10,r4
800042b8:	1a 9b       	mov	r11,sp
800042ba:	f0 1f 00 10 	mcall	800042f8 <xnl_rx_process+0x58>
800042be:	58 1c       	cp.w	r12,1
800042c0:	cf 91       	brne	800042b2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800042c2:	40 0c       	lddsp	r12,sp[0x0]
800042c4:	58 0c       	cp.w	r12,0
800042c6:	cf 60       	breq	800042b2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042c8:	98 28       	ld.sh	r8,r12[0x4]
800042ca:	e6 08 19 00 	cp.h	r8,r3
800042ce:	e0 8b 00 0a 	brhi	800042e2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042d2:	5c 78       	castu.h	r8
800042d4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800042d8:	58 09       	cp.w	r9,0
800042da:	c0 40       	breq	800042e2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800042dc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800042e0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042e2:	62 0c       	ld.w	r12,r1[0x0]
800042e4:	40 0b       	lddsp	r11,sp[0x0]
800042e6:	f0 1f 00 06 	mcall	800042fc <xnl_rx_process+0x5c>
800042ea:	ce 4b       	rjmp	800042b2 <xnl_rx_process+0x12>
800042ec:	00 00       	add	r0,r0
800042ee:	0a ac       	st.w	r5++,r12
800042f0:	00 00       	add	r0,r0
800042f2:	0a 9c       	mov	r12,r5
800042f4:	00 00       	add	r0,r0
800042f6:	04 f4       	st.b	--r2,r4
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	5f 44       	srge	r4
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	2a dc       	sub	r12,-83

80004300 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004300:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004302:	4a a6       	lddpc	r6,800043a8 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004304:	4a a2       	lddpc	r2,800043ac <xnl_tx_process+0xac>
80004306:	4a b4       	lddpc	r4,800043b0 <xnl_tx_process+0xb0>
80004308:	30 07       	mov	r7,0
8000430a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000430c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000430e:	4a a5       	lddpc	r5,800043b4 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004310:	4a a3       	lddpc	r3,800043b8 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004312:	6c 08       	ld.w	r8,r6[0x0]
80004314:	58 08       	cp.w	r8,0
80004316:	c0 40       	breq	8000431e <xnl_tx_process+0x1e>
80004318:	58 18       	cp.w	r8,1
8000431a:	cf d1       	brne	80004314 <xnl_tx_process+0x14>
8000431c:	c2 48       	rjmp	80004364 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000431e:	64 0c       	ld.w	r12,r2[0x0]
80004320:	0e 99       	mov	r9,r7
80004322:	02 9a       	mov	r10,r1
80004324:	08 9b       	mov	r11,r4
80004326:	f0 1f 00 26 	mcall	800043bc <xnl_tx_process+0xbc>
8000432a:	58 1c       	cp.w	r12,1
8000432c:	cf 31       	brne	80004312 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000432e:	68 0b       	ld.w	r11,r4[0x0]
80004330:	58 0b       	cp.w	r11,0
80004332:	cf 00       	breq	80004312 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004334:	96 28       	ld.sh	r8,r11[0x4]
80004336:	e0 08 19 00 	cp.h	r8,r0
8000433a:	c0 71       	brne	80004348 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
8000433c:	4a 18       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
8000433e:	70 08       	ld.w	r8,r8[0x0]
80004340:	10 9c       	mov	r12,r8
80004342:	f0 1f 00 21 	mcall	800043c4 <xnl_tx_process+0xc4>
						break;
80004346:	ce 6b       	rjmp	80004312 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004348:	16 9c       	mov	r12,r11
8000434a:	f0 1f 00 20 	mcall	800043c8 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000434e:	30 18       	mov	r8,1
80004350:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004352:	66 0c       	ld.w	r12,r3[0x0]
80004354:	0e 99       	mov	r9,r7
80004356:	0e 9a       	mov	r10,r7
80004358:	0e 9b       	mov	r11,r7
8000435a:	f0 1f 00 19 	mcall	800043bc <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000435e:	30 18       	mov	r8,1
80004360:	8d 08       	st.w	r6[0x0],r8
80004362:	cd 8b       	rjmp	80004312 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004364:	66 0c       	ld.w	r12,r3[0x0]
80004366:	0e 99       	mov	r9,r7
80004368:	36 4a       	mov	r10,100
8000436a:	0e 9b       	mov	r11,r7
8000436c:	f0 1f 00 14 	mcall	800043bc <xnl_tx_process+0xbc>
80004370:	58 1c       	cp.w	r12,1
80004372:	c0 81       	brne	80004382 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004374:	49 38       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
80004376:	70 0c       	ld.w	r12,r8[0x0]
80004378:	68 0b       	ld.w	r11,r4[0x0]
8000437a:	f0 1f 00 13 	mcall	800043c4 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000437e:	8d 07       	st.w	r6[0x0],r7
80004380:	cc 9b       	rjmp	80004312 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004382:	6a 08       	ld.w	r8,r5[0x0]
80004384:	58 38       	cp.w	r8,3
80004386:	e0 89 00 09 	brgt	80004398 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000438a:	68 0c       	ld.w	r12,r4[0x0]
8000438c:	f0 1f 00 0f 	mcall	800043c8 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004390:	6a 08       	ld.w	r8,r5[0x0]
80004392:	2f f8       	sub	r8,-1
80004394:	8b 08       	st.w	r5[0x0],r8
80004396:	cb eb       	rjmp	80004312 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004398:	48 a8       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
8000439a:	70 0c       	ld.w	r12,r8[0x0]
8000439c:	68 0b       	ld.w	r11,r4[0x0]
8000439e:	f0 1f 00 0a 	mcall	800043c4 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800043a2:	8d 07       	st.w	r6[0x0],r7
800043a4:	cb 7b       	rjmp	80004312 <xnl_tx_process+0x12>
800043a6:	00 00       	add	r0,r0
800043a8:	00 00       	add	r0,r0
800043aa:	0b 48       	ld.w	r8,--r5
800043ac:	00 00       	add	r0,r0
800043ae:	0b 4c       	ld.w	r12,--r5
800043b0:	00 00       	add	r0,r0
800043b2:	0b 54       	ld.sh	r4,--r5
800043b4:	00 00       	add	r0,r0
800043b6:	0b 50       	ld.sh	r0,--r5
800043b8:	00 00       	add	r0,r0
800043ba:	0b 38       	ld.ub	r8,r5++
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	5f 44       	srge	r4
800043c0:	00 00       	add	r0,r0
800043c2:	0a 9c       	mov	r12,r5
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	2a dc       	sub	r12,-83
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	2a fc       	sub	r12,-81

800043cc <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800043cc:	eb cd 40 c0 	pushm	r6-r7,lr
800043d0:	20 1d       	sub	sp,4
800043d2:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800043d4:	98 39       	ld.sh	r9,r12[0x6]
800043d6:	3f f8       	mov	r8,-1
800043d8:	f0 09 19 00 	cp.h	r9,r8
800043dc:	c0 a1       	brne	800043f0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800043de:	4a e9       	lddpc	r9,80004494 <xnl_tx+0xc8>
800043e0:	13 88       	ld.ub	r8,r9[0x0]
800043e2:	2f f8       	sub	r8,-1
800043e4:	5c 58       	castu.b	r8
800043e6:	b2 88       	st.b	r9[0x0],r8
800043e8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043ec:	a9 a8       	sbr	r8,0x8
800043ee:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043f0:	8c 49       	ld.sh	r9,r6[0x8]
800043f2:	3f f8       	mov	r8,-1
800043f4:	f0 09 19 00 	cp.h	r9,r8
800043f8:	c0 41       	brne	80004400 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800043fa:	4a 88       	lddpc	r8,80004498 <xnl_tx+0xcc>
800043fc:	90 18       	ld.sh	r8,r8[0x2]
800043fe:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004400:	8c 59       	ld.sh	r9,r6[0xa]
80004402:	3f f8       	mov	r8,-1
80004404:	f0 09 19 00 	cp.h	r9,r8
80004408:	c0 41       	brne	80004410 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000440a:	4a 48       	lddpc	r8,80004498 <xnl_tx+0xcc>
8000440c:	90 28       	ld.sh	r8,r8[0x4]
8000440e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004410:	8c 69       	ld.sh	r9,r6[0xc]
80004412:	3f f8       	mov	r8,-1
80004414:	f0 09 19 00 	cp.h	r9,r8
80004418:	c0 e1       	brne	80004434 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000441a:	4a 08       	lddpc	r8,80004498 <xnl_tx+0xcc>
8000441c:	90 49       	ld.sh	r9,r8[0x8]
8000441e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004420:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004422:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004424:	90 49       	ld.sh	r9,r8[0x8]
80004426:	e0 19 ff 00 	andl	r9,0xff00
8000442a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000442e:	f3 e8 10 08 	or	r8,r9,r8
80004432:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004434:	0d 98       	ld.ub	r8,r6[0x1]
80004436:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004438:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000443c:	10 0c       	add	r12,r8
8000443e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004440:	58 0c       	cp.w	r12,0
80004442:	e0 89 00 04 	brgt	8000444a <xnl_tx+0x7e>
80004446:	30 09       	mov	r9,0
80004448:	c0 d8       	rjmp	80004462 <xnl_tx+0x96>
8000444a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000444e:	2f ec       	sub	r12,-2
80004450:	30 09       	mov	r9,0
80004452:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004454:	15 1b       	ld.sh	r11,r10++
80004456:	f6 09 00 09 	add	r9,r11,r9
8000445a:	5c 89       	casts.h	r9
		indextohWord     += 1;
8000445c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000445e:	18 38       	cp.w	r8,r12
80004460:	cf a1       	brne	80004454 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004462:	5c 39       	neg	r9
80004464:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004466:	48 e8       	lddpc	r8,8000449c <xnl_tx+0xd0>
80004468:	70 0c       	ld.w	r12,r8[0x0]
8000446a:	f0 1f 00 0e 	mcall	800044a0 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000446e:	c1 00       	breq	8000448e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004470:	fa c7 ff fc 	sub	r7,sp,-4
80004474:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004476:	e0 6a 01 00 	mov	r10,256
8000447a:	0c 9b       	mov	r11,r6
8000447c:	f0 1f 00 0a 	mcall	800044a4 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004480:	48 a8       	lddpc	r8,800044a8 <xnl_tx+0xdc>
80004482:	70 0c       	ld.w	r12,r8[0x0]
80004484:	30 09       	mov	r9,0
80004486:	12 9a       	mov	r10,r9
80004488:	1a 9b       	mov	r11,sp
8000448a:	f0 1f 00 09 	mcall	800044ac <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000448e:	2f fd       	sub	sp,-4
80004490:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004494:	00 00       	add	r0,r0
80004496:	0b 3c       	ld.ub	r12,r5++
80004498:	00 00       	add	r0,r0
8000449a:	0b 3e       	ld.ub	lr,r5++
8000449c:	00 00       	add	r0,r0
8000449e:	0a 9c       	mov	r12,r5
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	2c 88       	sub	r8,-56
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	75 ac       	ld.w	r12,r10[0x68]
800044a8:	00 00       	add	r0,r0
800044aa:	0b 4c       	ld.w	r12,--r5
800044ac:	80 00       	ld.sh	r0,r0[0x0]
800044ae:	61 50       	ld.w	r0,r0[0x54]

800044b0 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044b0:	eb cd 40 80 	pushm	r7,lr
800044b4:	fa cd 01 00 	sub	sp,sp,256
800044b8:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044ba:	e0 68 40 0e 	mov	r8,16398
800044be:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044c0:	3f f8       	mov	r8,-1
800044c2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800044c4:	30 c8       	mov	r8,12
800044c6:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800044c8:	98 38       	ld.sh	r8,r12[0x6]
800044ca:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800044cc:	98 58       	ld.sh	r8,r12[0xa]
800044ce:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800044d0:	98 48       	ld.sh	r8,r12[0x8]
800044d2:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800044d4:	98 68       	ld.sh	r8,r12[0xc]
800044d6:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800044d8:	30 08       	mov	r8,0
800044da:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044dc:	1a 9c       	mov	r12,sp
800044de:	f0 1f 00 0a 	mcall	80004504 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800044e2:	fa cd 00 cc 	sub	sp,sp,204
800044e6:	e0 6a 00 ca 	mov	r10,202
800044ea:	ee cb ff f0 	sub	r11,r7,-16
800044ee:	1a 9c       	mov	r12,sp
800044f0:	f0 1f 00 06 	mcall	80004508 <xnl_data_msg_func+0x58>
800044f4:	48 68       	lddpc	r8,8000450c <xnl_data_msg_func+0x5c>
800044f6:	70 08       	ld.w	r8,r8[0x0]
800044f8:	5d 18       	icall	r8
800044fa:	fa cd ff 34 	sub	sp,sp,-204
}
800044fe:	2c 0d       	sub	sp,-256
80004500:	e3 cd 80 80 	ldm	sp++,r7,pc
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	43 cc       	lddsp	r12,sp[0xf0]
80004508:	80 00       	ld.sh	r0,r0[0x0]
8000450a:	75 ac       	ld.w	r12,r10[0x68]
8000450c:	00 00       	add	r0,r0
8000450e:	0b 58       	ld.sh	r8,--r5

80004510 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004510:	d4 21       	pushm	r4-r7,lr
80004512:	fa cd 01 00 	sub	sp,sp,256
80004516:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004518:	4c 28       	lddpc	r8,80004620 <xnl_device_auth_reply_func+0x110>
8000451a:	11 88       	ld.ub	r8,r8[0x0]
8000451c:	58 08       	cp.w	r8,0
8000451e:	e0 81 00 7f 	brne	8000461c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004522:	4c 18       	lddpc	r8,80004624 <xnl_device_auth_reply_func+0x114>
80004524:	70 0c       	ld.w	r12,r8[0x0]
80004526:	30 09       	mov	r9,0
80004528:	12 9a       	mov	r10,r9
8000452a:	12 9b       	mov	r11,r9
8000452c:	f0 1f 00 3f 	mcall	80004628 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004530:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004534:	4b b8       	lddpc	r8,80004620 <xnl_device_auth_reply_func+0x110>
80004536:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004538:	ef 39 00 12 	ld.ub	r9,r7[18]
8000453c:	ef 38 00 13 	ld.ub	r8,r7[19]
80004540:	b1 68       	lsl	r8,0x10
80004542:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004546:	ef 38 00 15 	ld.ub	r8,r7[21]
8000454a:	f3 e8 10 08 	or	r8,r9,r8
8000454e:	ef 39 00 14 	ld.ub	r9,r7[20]
80004552:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004556:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000455a:	ef 38 00 17 	ld.ub	r8,r7[23]
8000455e:	b1 68       	lsl	r8,0x10
80004560:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004564:	ef 38 00 19 	ld.ub	r8,r7[25]
80004568:	f5 e8 10 08 	or	r8,r10,r8
8000456c:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004570:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004574:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004576:	e0 64 79 b9 	mov	r4,31161
8000457a:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000457e:	e0 65 45 07 	mov	r5,17671
80004582:	ea 15 8a bd 	orh	r5,0x8abd
80004586:	e0 66 f9 3d 	mov	r6,63805
8000458a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000458e:	e0 6e b8 cf 	mov	lr,47311
80004592:	ea 1e 36 83 	orh	lr,0x3683
80004596:	e0 67 aa 1c 	mov	r7,43548
8000459a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000459e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045a0:	f4 08 00 0c 	add	r12,r10,r8
800045a4:	f0 0b 15 04 	lsl	r11,r8,0x4
800045a8:	0a 0b       	add	r11,r5
800045aa:	f9 eb 20 0b 	eor	r11,r12,r11
800045ae:	f0 0c 16 05 	lsr	r12,r8,0x5
800045b2:	0c 0c       	add	r12,r6
800045b4:	18 5b       	eor	r11,r12
800045b6:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045b8:	f2 0c 15 04 	lsl	r12,r9,0x4
800045bc:	1c 0c       	add	r12,lr
800045be:	f2 0b 16 05 	lsr	r11,r9,0x5
800045c2:	0e 0b       	add	r11,r7
800045c4:	f9 eb 20 0b 	eor	r11,r12,r11
800045c8:	f2 0a 00 0c 	add	r12,r9,r10
800045cc:	18 5b       	eor	r11,r12
800045ce:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800045d0:	e0 6b 37 20 	mov	r11,14112
800045d4:	ea 1b c6 ef 	orh	r11,0xc6ef
800045d8:	16 3a       	cp.w	r10,r11
800045da:	ce 21       	brne	8000459e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800045dc:	e0 6a 40 1a 	mov	r10,16410
800045e0:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045e2:	3f fa       	mov	r10,-1
800045e4:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800045e6:	30 6b       	mov	r11,6
800045e8:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045ea:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045ec:	48 db       	lddpc	r11,80004620 <xnl_device_auth_reply_func+0x110>
800045ee:	96 1c       	ld.sh	r12,r11[0x2]
800045f0:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800045f2:	96 2b       	ld.sh	r11,r11[0x4]
800045f4:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045f6:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800045f8:	30 ca       	mov	r10,12
800045fa:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800045fc:	30 0a       	mov	r10,0
800045fe:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004602:	30 7a       	mov	r10,7
80004604:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004608:	30 2a       	mov	r10,2
8000460a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000460e:	fa ca ff ec 	sub	r10,sp,-20
80004612:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004614:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004616:	1a 9c       	mov	r12,sp
80004618:	f0 1f 00 05 	mcall	8000462c <xnl_device_auth_reply_func+0x11c>
}
8000461c:	2c 0d       	sub	sp,-256
8000461e:	d8 22       	popm	r4-r7,pc
80004620:	00 00       	add	r0,r0
80004622:	0b 3e       	ld.ub	lr,r5++
80004624:	00 00       	add	r0,r0
80004626:	0b 38       	ld.ub	r8,r5++
80004628:	80 00       	ld.sh	r0,r0[0x0]
8000462a:	61 50       	ld.w	r0,r0[0x54]
8000462c:	80 00       	ld.sh	r0,r0[0x0]
8000462e:	43 cc       	lddsp	r12,sp[0xf0]

80004630 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004630:	eb cd 40 80 	pushm	r7,lr
80004634:	fa cd 01 00 	sub	sp,sp,256
80004638:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000463a:	49 28       	lddpc	r8,80004680 <xnl_master_status_brdcst_func+0x50>
8000463c:	11 88       	ld.ub	r8,r8[0x0]
8000463e:	58 08       	cp.w	r8,0
80004640:	c1 c1       	brne	80004678 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004642:	49 18       	lddpc	r8,80004684 <xnl_master_status_brdcst_func+0x54>
80004644:	70 0c       	ld.w	r12,r8[0x0]
80004646:	30 09       	mov	r9,0
80004648:	12 9a       	mov	r10,r9
8000464a:	12 9b       	mov	r11,r9
8000464c:	f0 1f 00 0f 	mcall	80004688 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004650:	8e 58       	ld.sh	r8,r7[0xa]
80004652:	48 c9       	lddpc	r9,80004680 <xnl_master_status_brdcst_func+0x50>
80004654:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004656:	e0 68 40 0e 	mov	r8,16398
8000465a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000465c:	3f f8       	mov	r8,-1
8000465e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004660:	30 4a       	mov	r10,4
80004662:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004664:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004666:	92 19       	ld.sh	r9,r9[0x2]
80004668:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000466a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000466c:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000466e:	30 08       	mov	r8,0
80004670:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004672:	1a 9c       	mov	r12,sp
80004674:	f0 1f 00 06 	mcall	8000468c <xnl_master_status_brdcst_func+0x5c>
}
80004678:	2c 0d       	sub	sp,-256
8000467a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000467e:	00 00       	add	r0,r0
80004680:	00 00       	add	r0,r0
80004682:	0b 3e       	ld.ub	lr,r5++
80004684:	00 00       	add	r0,r0
80004686:	0b 38       	ld.ub	r8,r5++
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	61 50       	ld.w	r0,r0[0x54]
8000468c:	80 00       	ld.sh	r0,r0[0x0]
8000468e:	43 cc       	lddsp	r12,sp[0xf0]

80004690 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004690:	eb cd 40 80 	pushm	r7,lr
80004694:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004696:	49 28       	lddpc	r8,800046dc <xnl_device_conn_reply_func+0x4c>
80004698:	70 0c       	ld.w	r12,r8[0x0]
8000469a:	30 09       	mov	r9,0
8000469c:	12 9a       	mov	r10,r9
8000469e:	12 9b       	mov	r11,r9
800046a0:	f0 1f 00 10 	mcall	800046e0 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046a4:	ef 18 00 10 	ld.uh	r8,r7[16]
800046a8:	10 99       	mov	r9,r8
800046aa:	e2 19 ff 00 	andl	r9,0xff00,COH
800046ae:	e0 49 01 00 	cp.w	r9,256
800046b2:	c0 60       	breq	800046be <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046b4:	0e 9c       	mov	r12,r7
800046b6:	f0 1f 00 0c 	mcall	800046e4 <xnl_device_conn_reply_func+0x54>
800046ba:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800046be:	a9 68       	lsl	r8,0x8
800046c0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800046c4:	48 98       	lddpc	r8,800046e8 <xnl_device_conn_reply_func+0x58>
800046c6:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800046c8:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800046cc:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800046ce:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800046d2:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800046d4:	30 19       	mov	r9,1
800046d6:	b0 89       	st.b	r8[0x0],r9
800046d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800046dc:	00 00       	add	r0,r0
800046de:	0b 38       	ld.ub	r8,r5++
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	61 50       	ld.w	r0,r0[0x54]
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	46 30       	lddsp	r0,sp[0x18c]
800046e8:	00 00       	add	r0,r0
800046ea:	0b 3e       	ld.ub	lr,r5++

800046ec <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800046ec:	d4 01       	pushm	lr
800046ee:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046f2:	e0 68 40 0e 	mov	r8,16398
800046f6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046f8:	3f f8       	mov	r8,-1
800046fa:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800046fc:	30 38       	mov	r8,3
800046fe:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004700:	30 08       	mov	r8,0
80004702:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004704:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004706:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004708:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000470a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000470c:	1a 9c       	mov	r12,sp
8000470e:	f0 1f 00 03 	mcall	80004718 <xnl_send_device_master_query+0x2c>
}
80004712:	2c 0d       	sub	sp,-256
80004714:	d8 02       	popm	pc
80004716:	00 00       	add	r0,r0
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	43 cc       	lddsp	r12,sp[0xf0]

8000471c <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000471c:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000471e:	48 78       	lddpc	r8,80004738 <RC522_SPI_SetSpeed+0x1c>
80004720:	70 09       	ld.w	r9,r8[0x0]
80004722:	72 ca       	ld.w	r10,r9[0x30]
80004724:	5c 7c       	castu.h	r12
80004726:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000472a:	f9 ea 10 0a 	or	r10,r12,r10
8000472e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004730:	70 0c       	ld.w	r12,r8[0x0]
80004732:	f0 1f 00 03 	mcall	8000473c <RC522_SPI_SetSpeed+0x20>
		
	
}
80004736:	d8 02       	popm	pc
80004738:	00 00       	add	r0,r0
8000473a:	1d a0       	ld.ub	r0,lr[0x2]
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	56 40       	stdsp	sp[0x190],r0

80004740 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004740:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
80004742:	e0 6c 0a 00 	mov	r12,2560
80004746:	f0 1f 00 02 	mcall	8000474c <RC522_SPI_SetSpeedLow+0xc>
	
}
8000474a:	d8 02       	popm	pc
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	47 1c       	lddsp	r12,sp[0x1c4]

80004750 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004750:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004754:	48 76       	lddpc	r6,80004770 <RC522_ReadByte+0x20>
80004756:	e0 6b 00 ff 	mov	r11,255
8000475a:	6c 0c       	ld.w	r12,r6[0x0]
8000475c:	f0 1f 00 06 	mcall	80004774 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004760:	30 07       	mov	r7,0
80004762:	0e 9b       	mov	r11,r7
80004764:	6c 0c       	ld.w	r12,r6[0x0]
80004766:	f0 1f 00 05 	mcall	80004778 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
8000476a:	0f 9c       	ld.ub	r12,r7[0x1]
8000476c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004770:	00 00       	add	r0,r0
80004772:	1d a0       	ld.ub	r0,lr[0x2]
80004774:	80 00       	ld.sh	r0,r0[0x0]
80004776:	56 46       	stdsp	sp[0x190],r6
80004778:	80 00       	ld.sh	r0,r0[0x0]
8000477a:	56 62       	stdsp	sp[0x198],r2

8000477c <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
8000477c:	eb cd 40 80 	pushm	r7,lr
80004780:	20 1d       	sub	sp,4
80004782:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004784:	48 77       	lddpc	r7,800047a0 <RC522_WriteByte+0x24>
80004786:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
8000478a:	6e 0c       	ld.w	r12,r7[0x0]
8000478c:	f0 1f 00 06 	mcall	800047a4 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004790:	1a 9b       	mov	r11,sp
80004792:	6e 0c       	ld.w	r12,r7[0x0]
80004794:	f0 1f 00 05 	mcall	800047a8 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004798:	5c 5c       	castu.b	r12
8000479a:	2f fd       	sub	sp,-4
8000479c:	e3 cd 80 80 	ldm	sp++,r7,pc
800047a0:	00 00       	add	r0,r0
800047a2:	1d a0       	ld.ub	r0,lr[0x2]
800047a4:	80 00       	ld.sh	r0,r0[0x0]
800047a6:	56 46       	stdsp	sp[0x190],r6
800047a8:	80 00       	ld.sh	r0,r0[0x0]
800047aa:	56 62       	stdsp	sp[0x198],r2

800047ac <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800047ac:	eb cd 40 e0 	pushm	r5-r7,lr
800047b0:	18 96       	mov	r6,r12
800047b2:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800047b4:	48 a7       	lddpc	r7,800047dc <WriteRawRC+0x30>
800047b6:	30 0b       	mov	r11,0
800047b8:	6e 0c       	ld.w	r12,r7[0x0]
800047ba:	f0 1f 00 0a 	mcall	800047e0 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800047be:	ec 0c 15 01 	lsl	r12,r6,0x1
800047c2:	e2 1c 00 7e 	andl	r12,0x7e,COH
800047c6:	f0 1f 00 08 	mcall	800047e4 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800047ca:	0a 9c       	mov	r12,r5
800047cc:	f0 1f 00 06 	mcall	800047e4 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800047d0:	30 0b       	mov	r11,0
800047d2:	6e 0c       	ld.w	r12,r7[0x0]
800047d4:	f0 1f 00 05 	mcall	800047e8 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800047d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800047dc:	00 00       	add	r0,r0
800047de:	1d a0       	ld.ub	r0,lr[0x2]
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	57 ac       	stdsp	sp[0x1e8],r12
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	47 7c       	lddsp	r12,sp[0x1dc]
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	57 6c       	stdsp	sp[0x1d8],r12

800047ec <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800047ec:	d4 01       	pushm	lr

	SET_RC522RST;
800047ee:	31 9c       	mov	r12,25
800047f0:	f0 1f 00 1b 	mcall	8000485c <PcdReset+0x70>
	delay_ns(10);
800047f4:	30 ac       	mov	r12,10
800047f6:	f0 1f 00 1b 	mcall	80004860 <PcdReset+0x74>

	CLR_RC522RST;
800047fa:	31 9c       	mov	r12,25
800047fc:	f0 1f 00 1a 	mcall	80004864 <PcdReset+0x78>
	delay_ns(10);
80004800:	30 ac       	mov	r12,10
80004802:	f0 1f 00 18 	mcall	80004860 <PcdReset+0x74>

	SET_RC522RST;
80004806:	31 9c       	mov	r12,25
80004808:	f0 1f 00 15 	mcall	8000485c <PcdReset+0x70>
	delay_ns(10);
8000480c:	30 ac       	mov	r12,10
8000480e:	f0 1f 00 15 	mcall	80004860 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004812:	30 fb       	mov	r11,15
80004814:	30 1c       	mov	r12,1
80004816:	f0 1f 00 15 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000481a:	30 fb       	mov	r11,15
8000481c:	30 1c       	mov	r12,1
8000481e:	f0 1f 00 13 	mcall	80004868 <PcdReset+0x7c>
	delay_ns(10);
80004822:	30 ac       	mov	r12,10
80004824:	f0 1f 00 0f 	mcall	80004860 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004828:	33 db       	mov	r11,61
8000482a:	31 1c       	mov	r12,17
8000482c:	f0 1f 00 0f 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004830:	31 eb       	mov	r11,30
80004832:	32 dc       	mov	r12,45
80004834:	f0 1f 00 0d 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004838:	30 0b       	mov	r11,0
8000483a:	32 cc       	mov	r12,44
8000483c:	f0 1f 00 0b 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004840:	e0 6b 00 8d 	mov	r11,141
80004844:	32 ac       	mov	r12,42
80004846:	f0 1f 00 09 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
8000484a:	33 eb       	mov	r11,62
8000484c:	32 bc       	mov	r12,43
8000484e:	f0 1f 00 07 	mcall	80004868 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004852:	34 0b       	mov	r11,64
80004854:	31 5c       	mov	r12,21
80004856:	f0 1f 00 05 	mcall	80004868 <PcdReset+0x7c>
	
	return MI_OK;
}
8000485a:	d8 0a       	popm	pc,r12=0
8000485c:	80 00       	ld.sh	r0,r0[0x0]
8000485e:	53 24       	stdsp	sp[0xc8],r4
80004860:	80 00       	ld.sh	r0,r0[0x0]
80004862:	51 08       	stdsp	sp[0x40],r8
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	53 40       	stdsp	sp[0xd0],r0
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	47 ac       	lddsp	r12,sp[0x1e8]

8000486c <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
8000486c:	eb cd 40 c0 	pushm	r6-r7,lr
80004870:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004872:	48 c7       	lddpc	r7,800048a0 <ReadRawRC+0x34>
80004874:	30 0b       	mov	r11,0
80004876:	6e 0c       	ld.w	r12,r7[0x0]
80004878:	f0 1f 00 0b 	mcall	800048a4 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
8000487c:	a1 76       	lsl	r6,0x1
8000487e:	0c 9c       	mov	r12,r6
80004880:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004884:	a7 bc       	sbr	r12,0x7
80004886:	f0 1f 00 09 	mcall	800048a8 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
8000488a:	f0 1f 00 09 	mcall	800048ac <ReadRawRC+0x40>
8000488e:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004890:	30 0b       	mov	r11,0
80004892:	6e 0c       	ld.w	r12,r7[0x0]
80004894:	f0 1f 00 07 	mcall	800048b0 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004898:	0c 9c       	mov	r12,r6
8000489a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000489e:	00 00       	add	r0,r0
800048a0:	00 00       	add	r0,r0
800048a2:	1d a0       	ld.ub	r0,lr[0x2]
800048a4:	80 00       	ld.sh	r0,r0[0x0]
800048a6:	57 ac       	stdsp	sp[0x1e8],r12
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	47 7c       	lddsp	r12,sp[0x1dc]
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	47 50       	lddsp	r0,sp[0x1d4]
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	57 6c       	stdsp	sp[0x1d8],r12

800048b4 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800048b4:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800048b6:	30 1c       	mov	r12,1
800048b8:	f0 1f 00 02 	mcall	800048c0 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800048bc:	d8 02       	popm	pc
800048be:	00 00       	add	r0,r0
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	48 6c       	lddpc	r12,800048d8 <Powerdown_RC522+0x14>

800048c4 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
800048c4:	eb cd 40 80 	pushm	r7,lr
800048c8:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800048ca:	30 1c       	mov	r12,1
800048cc:	f0 1f 00 0d 	mcall	80004900 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800048d0:	30 18       	mov	r8,1
800048d2:	f0 07 18 00 	cp.b	r7,r8
800048d6:	c0 91       	brne	800048e8 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800048d8:	18 9b       	mov	r11,r12
800048da:	a5 ab       	sbr	r11,0x4
800048dc:	5c 5b       	castu.b	r11
800048de:	30 1c       	mov	r12,1
800048e0:	f0 1f 00 09 	mcall	80004904 <Powerdown_RC522+0x40>
800048e4:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800048e8:	18 9b       	mov	r11,r12
800048ea:	30 1c       	mov	r12,1
800048ec:	f0 1f 00 06 	mcall	80004904 <Powerdown_RC522+0x40>
		delay_ns(2);
800048f0:	30 2c       	mov	r12,2
800048f2:	f0 1f 00 06 	mcall	80004908 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800048f6:	f0 1f 00 06 	mcall	8000490c <Powerdown_RC522+0x48>
800048fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800048fe:	00 00       	add	r0,r0
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	48 6c       	lddpc	r12,80004918 <SetBitMask+0x8>
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	47 ac       	lddsp	r12,sp[0x1e8]
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	51 08       	stdsp	sp[0x40],r8
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	48 b4       	lddpc	r4,80004938 <PcdAntennaOn+0x4>

80004910 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004910:	eb cd 40 c0 	pushm	r6-r7,lr
80004914:	18 97       	mov	r7,r12
80004916:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004918:	f0 1f 00 05 	mcall	8000492c <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
8000491c:	f9 e6 10 0b 	or	r11,r12,r6
80004920:	5c 5b       	castu.b	r11
80004922:	0e 9c       	mov	r12,r7
80004924:	f0 1f 00 03 	mcall	80004930 <SetBitMask+0x20>
}
80004928:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	48 6c       	lddpc	r12,80004944 <PcdAntennaOn+0x10>
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	47 ac       	lddsp	r12,sp[0x1e8]

80004934 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004934:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004936:	31 4c       	mov	r12,20
80004938:	f0 1f 00 05 	mcall	8000494c <PcdAntennaOn+0x18>
	if (!(i & 0x03))
8000493c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004940:	c0 51       	brne	8000494a <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004942:	30 3b       	mov	r11,3
80004944:	31 4c       	mov	r12,20
80004946:	f0 1f 00 03 	mcall	80004950 <PcdAntennaOn+0x1c>
8000494a:	d8 02       	popm	pc
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	48 6c       	lddpc	r12,80004964 <ClearBitMask+0x10>
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	49 10       	lddpc	r0,80004994 <M500PcdConfigISOType+0x8>

80004954 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004954:	eb cd 40 c0 	pushm	r6-r7,lr
80004958:	18 97       	mov	r7,r12
8000495a:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
8000495c:	f0 1f 00 06 	mcall	80004974 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004960:	5c d6       	com	r6
80004962:	f9 e6 00 06 	and	r6,r12,r6
80004966:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
8000496a:	0e 9c       	mov	r12,r7
8000496c:	f0 1f 00 03 	mcall	80004978 <ClearBitMask+0x24>
	
}
80004970:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	48 6c       	lddpc	r12,8000498c <M500PcdConfigISOType>
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	47 ac       	lddsp	r12,sp[0x1e8]

8000497c <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
8000497c:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000497e:	30 3b       	mov	r11,3
80004980:	31 4c       	mov	r12,20
80004982:	f0 1f 00 02 	mcall	80004988 <PcdAntennaOff+0xc>
}
80004986:	d8 02       	popm	pc
80004988:	80 00       	ld.sh	r0,r0[0x0]
8000498a:	49 54       	lddpc	r4,800049dc <M500PcdConfigISOType+0x50>

8000498c <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
8000498c:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000498e:	34 18       	mov	r8,65
80004990:	f0 0c 18 00 	cp.b	r12,r8
80004994:	c0 20       	breq	80004998 <M500PcdConfigISOType+0xc>
80004996:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004998:	30 8b       	mov	r11,8
8000499a:	16 9c       	mov	r12,r11
8000499c:	f0 1f 00 14 	mcall	800049ec <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800049a0:	33 db       	mov	r11,61
800049a2:	31 1c       	mov	r12,17
800049a4:	f0 1f 00 13 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800049a8:	e0 6b 00 86 	mov	r11,134
800049ac:	31 7c       	mov	r12,23
800049ae:	f0 1f 00 11 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800049b2:	37 fb       	mov	r11,127
800049b4:	32 6c       	mov	r12,38
800049b6:	f0 1f 00 0f 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800049ba:	31 eb       	mov	r11,30
800049bc:	32 dc       	mov	r12,45
800049be:	f0 1f 00 0d 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800049c2:	30 0b       	mov	r11,0
800049c4:	32 cc       	mov	r12,44
800049c6:	f0 1f 00 0b 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800049ca:	e0 6b 00 8d 	mov	r11,141
800049ce:	32 ac       	mov	r12,42
800049d0:	f0 1f 00 08 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800049d4:	33 eb       	mov	r11,62
800049d6:	32 bc       	mov	r12,43
800049d8:	f0 1f 00 06 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800049dc:	e0 6c 03 e8 	mov	r12,1000
800049e0:	f0 1f 00 05 	mcall	800049f4 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800049e4:	f0 1f 00 05 	mcall	800049f8 <M500PcdConfigISOType+0x6c>
800049e8:	d8 0a       	popm	pc,r12=0
800049ea:	00 00       	add	r0,r0
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	49 54       	lddpc	r4,80004a40 <rc522_init+0x44>
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	47 ac       	lddsp	r12,sp[0x1e8]
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	51 08       	stdsp	sp[0x40],r8
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	49 34       	lddpc	r4,80004a44 <rc522_init+0x48>

800049fc <rc522_init>:


//mfrc522 init

void rc522_init()
{
800049fc:	eb cd 40 c0 	pushm	r6-r7,lr
80004a00:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004a02:	4a 38       	lddpc	r8,80004a8c <rc522_init+0x90>
80004a04:	1a 96       	mov	r6,sp
80004a06:	f0 ea 00 00 	ld.d	r10,r8[0]
80004a0a:	fa eb 00 00 	st.d	sp[0],r10
80004a0e:	f0 e8 00 08 	ld.d	r8,r8[8]
80004a12:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004a16:	30 4b       	mov	r11,4
80004a18:	49 ec       	lddpc	r12,80004a90 <rc522_init+0x94>
80004a1a:	f0 1f 00 1f 	mcall	80004a94 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004a1e:	31 9c       	mov	r12,25
80004a20:	f0 1f 00 1e 	mcall	80004a98 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004a24:	31 9c       	mov	r12,25
80004a26:	f0 1f 00 1e 	mcall	80004a9c <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004a2a:	49 e7       	lddpc	r7,80004aa0 <rc522_init+0xa4>
80004a2c:	fe 7c 24 00 	mov	r12,-56320
80004a30:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004a32:	1a 9b       	mov	r11,sp
80004a34:	f0 1f 00 1c 	mcall	80004aa4 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004a38:	30 09       	mov	r9,0
80004a3a:	12 9a       	mov	r10,r9
80004a3c:	12 9b       	mov	r11,r9
80004a3e:	6e 0c       	ld.w	r12,r7[0x0]
80004a40:	f0 1f 00 1a 	mcall	80004aa8 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004a44:	6e 0c       	ld.w	r12,r7[0x0]
80004a46:	f0 1f 00 1a 	mcall	80004aac <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004a4a:	e0 6a 36 00 	mov	r10,13824
80004a4e:	ea 1a 01 6e 	orh	r10,0x16e
80004a52:	1a 9b       	mov	r11,sp
80004a54:	6e 0c       	ld.w	r12,r7[0x0]
80004a56:	f0 1f 00 17 	mcall	80004ab0 <rc522_init+0xb4>
80004a5a:	c0 50       	breq	80004a64 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004a5c:	30 29       	mov	r9,2
80004a5e:	49 68       	lddpc	r8,80004ab4 <rc522_init+0xb8>
80004a60:	b0 89       	st.b	r8[0x0],r9
80004a62:	c0 38       	rjmp	80004a68 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004a64:	f0 1f 00 15 	mcall	80004ab8 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004a68:	f0 1f 00 15 	mcall	80004abc <rc522_init+0xc0>
	
	PcdAntennaOff();
80004a6c:	f0 1f 00 15 	mcall	80004ac0 <rc522_init+0xc4>
	
	delay_ms(2); 
80004a70:	30 2c       	mov	r12,2
80004a72:	f0 1f 00 15 	mcall	80004ac4 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004a76:	f0 1f 00 15 	mcall	80004ac8 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004a7a:	34 1c       	mov	r12,65
80004a7c:	f0 1f 00 14 	mcall	80004acc <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004a80:	30 1c       	mov	r12,1
80004a82:	f0 1f 00 14 	mcall	80004ad0 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004a86:	2f cd       	sub	sp,-16
80004a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	d6 24       	*unknown*
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	d6 34       	*unknown*
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	52 dc       	stdsp	sp[0xb4],r12
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	53 0c       	stdsp	sp[0xc0],r12
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	53 24       	stdsp	sp[0xc8],r4
80004aa0:	00 00       	add	r0,r0
80004aa2:	1d a0       	ld.ub	r0,lr[0x2]
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	55 dc       	stdsp	sp[0x174],r12
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	56 14       	stdsp	sp[0x184],r4
80004aac:	80 00       	ld.sh	r0,r0[0x0]
80004aae:	56 40       	stdsp	sp[0x190],r0
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	56 84       	stdsp	sp[0x1a0],r4
80004ab4:	00 00       	add	r0,r0
80004ab6:	0b 5c       	ld.sh	r12,--r5
80004ab8:	80 00       	ld.sh	r0,r0[0x0]
80004aba:	47 40       	lddsp	r0,sp[0x1d0]
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	47 ec       	lddsp	r12,sp[0x1f8]
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	49 7c       	lddpc	r12,80004b1c <PcdComMF522+0x48>
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	51 48       	stdsp	sp[0x50],r8
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	49 34       	lddpc	r4,80004b14 <PcdComMF522+0x40>
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	49 8c       	lddpc	r12,80004b2c <PcdComMF522+0x58>
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	48 c4       	lddpc	r4,80004b00 <PcdComMF522+0x2c>

80004ad4 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004ad4:	d4 31       	pushm	r0-r7,lr
80004ad6:	20 1d       	sub	sp,4
80004ad8:	18 92       	mov	r2,r12
80004ada:	16 95       	mov	r5,r11
80004adc:	14 96       	mov	r6,r10
80004ade:	50 09       	stdsp	sp[0x0],r9
80004ae0:	10 90       	mov	r0,r8
80004ae2:	f8 c8 00 0c 	sub	r8,r12,12
80004ae6:	5c 58       	castu.b	r8
80004ae8:	30 29       	mov	r9,2
80004aea:	f2 08 18 00 	cp.b	r8,r9
80004aee:	e0 88 00 05 	brls	80004af8 <PcdComMF522+0x24>
80004af2:	30 03       	mov	r3,0
80004af4:	06 91       	mov	r1,r3
80004af6:	c0 78       	rjmp	80004b04 <PcdComMF522+0x30>
80004af8:	4c f9       	lddpc	r9,80004c34 <PcdComMF522+0x160>
80004afa:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004afe:	4c f9       	lddpc	r9,80004c38 <PcdComMF522+0x164>
80004b00:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004b04:	02 9b       	mov	r11,r1
80004b06:	a7 bb       	sbr	r11,0x7
80004b08:	30 2c       	mov	r12,2
80004b0a:	f0 1f 00 4d 	mcall	80004c3c <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004b0e:	e0 6b 00 80 	mov	r11,128
80004b12:	30 4c       	mov	r12,4
80004b14:	f0 1f 00 4b 	mcall	80004c40 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b18:	30 0b       	mov	r11,0
80004b1a:	30 1c       	mov	r12,1
80004b1c:	f0 1f 00 48 	mcall	80004c3c <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004b20:	e0 6b 00 80 	mov	r11,128
80004b24:	30 ac       	mov	r12,10
80004b26:	f0 1f 00 48 	mcall	80004c44 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004b2a:	58 06       	cp.w	r6,0
80004b2c:	c0 c0       	breq	80004b44 <PcdComMF522+0x70>
80004b2e:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004b30:	30 94       	mov	r4,9
80004b32:	0f 3b       	ld.ub	r11,r7++
80004b34:	08 9c       	mov	r12,r4
80004b36:	f0 1f 00 42 	mcall	80004c3c <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004b3a:	0e 98       	mov	r8,r7
80004b3c:	0a 18       	sub	r8,r5
80004b3e:	ec 08 19 00 	cp.h	r8,r6
80004b42:	cf 83       	brcs	80004b32 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004b44:	04 9b       	mov	r11,r2
80004b46:	30 1c       	mov	r12,1
80004b48:	f0 1f 00 3d 	mcall	80004c3c <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004b4c:	30 c8       	mov	r8,12
80004b4e:	f0 02 18 00 	cp.b	r2,r8
80004b52:	c0 61       	brne	80004b5e <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004b54:	e0 6b 00 80 	mov	r11,128
80004b58:	30 dc       	mov	r12,13
80004b5a:	f0 1f 00 3b 	mcall	80004c44 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004b5e:	30 4c       	mov	r12,4
80004b60:	f0 1f 00 3a 	mcall	80004c48 <PcdComMF522+0x174>
80004b64:	18 97       	mov	r7,r12
80004b66:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004b6a:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004b6c:	30 44       	mov	r4,4
80004b6e:	c0 88       	rjmp	80004b7e <PcdComMF522+0xaa>
80004b70:	08 9c       	mov	r12,r4
80004b72:	f0 1f 00 36 	mcall	80004c48 <PcdComMF522+0x174>
80004b76:	18 97       	mov	r7,r12
		i--;
80004b78:	20 16       	sub	r6,1
80004b7a:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004b7c:	c0 a0       	breq	80004b90 <PcdComMF522+0xbc>
80004b7e:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004b82:	c4 c1       	brne	80004c1a <PcdComMF522+0x146>
80004b84:	ef e3 00 08 	and	r8,r7,r3
80004b88:	ea 08 18 00 	cp.b	r8,r5
80004b8c:	cf 20       	breq	80004b70 <PcdComMF522+0x9c>
80004b8e:	c4 68       	rjmp	80004c1a <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004b90:	e0 6b 00 80 	mov	r11,128
80004b94:	30 dc       	mov	r12,13
80004b96:	f0 1f 00 2b 	mcall	80004c40 <PcdComMF522+0x16c>
80004b9a:	30 27       	mov	r7,2
80004b9c:	c3 38       	rjmp	80004c02 <PcdComMF522+0x12e>
80004b9e:	02 67       	and	r7,r1
80004ba0:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ba4:	30 c8       	mov	r8,12
80004ba6:	f0 02 18 00 	cp.b	r2,r8
80004baa:	c2 c1       	brne	80004c02 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004bac:	30 ac       	mov	r12,10
80004bae:	f0 1f 00 27 	mcall	80004c48 <PcdComMF522+0x174>
80004bb2:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004bb4:	30 cc       	mov	r12,12
80004bb6:	f0 1f 00 25 	mcall	80004c48 <PcdComMF522+0x174>
80004bba:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004bbe:	c0 70       	breq	80004bcc <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004bc0:	08 98       	mov	r8,r4
80004bc2:	20 18       	sub	r8,1
80004bc4:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004bc8:	a0 8c       	st.b	r0[0x0],r12
80004bca:	c0 48       	rjmp	80004bd2 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004bcc:	e8 08 15 03 	lsl	r8,r4,0x3
80004bd0:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004bd2:	58 04       	cp.w	r4,0
80004bd4:	c0 61       	brne	80004be0 <PcdComMF522+0x10c>
80004bd6:	30 14       	mov	r4,1
80004bd8:	40 05       	lddsp	r5,sp[0x0]
80004bda:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004bdc:	30 93       	mov	r3,9
80004bde:	c0 98       	rjmp	80004bf0 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004be0:	31 28       	mov	r8,18
80004be2:	f0 04 18 00 	cp.b	r4,r8
80004be6:	f9 b4 0b 12 	movhi	r4,18
80004bea:	58 04       	cp.w	r4,0
80004bec:	cf 61       	brne	80004bd8 <PcdComMF522+0x104>
80004bee:	c0 a8       	rjmp	80004c02 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004bf0:	06 9c       	mov	r12,r3
80004bf2:	f0 1f 00 16 	mcall	80004c48 <PcdComMF522+0x174>
80004bf6:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004bf8:	ec 05 01 08 	sub	r8,r6,r5
80004bfc:	e8 08 19 00 	cp.h	r8,r4
80004c00:	cf 83       	brcs	80004bf0 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004c02:	e0 6b 00 80 	mov	r11,128
80004c06:	30 cc       	mov	r12,12
80004c08:	f0 1f 00 0f 	mcall	80004c44 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c0c:	30 0b       	mov	r11,0
80004c0e:	30 1c       	mov	r12,1
80004c10:	f0 1f 00 0b 	mcall	80004c3c <PcdComMF522+0x168>
	return status;
}
80004c14:	0e 9c       	mov	r12,r7
80004c16:	2f fd       	sub	sp,-4
80004c18:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004c1a:	e0 6b 00 80 	mov	r11,128
80004c1e:	30 dc       	mov	r12,13
80004c20:	f0 1f 00 08 	mcall	80004c40 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004c24:	30 6c       	mov	r12,6
80004c26:	f0 1f 00 09 	mcall	80004c48 <PcdComMF522+0x174>
80004c2a:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004c2e:	cb 80       	breq	80004b9e <PcdComMF522+0xca>
80004c30:	30 27       	mov	r7,2
80004c32:	ce 8b       	rjmp	80004c02 <PcdComMF522+0x12e>
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	d6 1c       	*unknown*
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	d6 20       	acall	0x62
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	47 ac       	lddsp	r12,sp[0x1e8]
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	49 54       	lddpc	r4,80004c94 <PcdAnticoll+0x48>
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	49 10       	lddpc	r0,80004c88 <PcdAnticoll+0x3c>
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	48 6c       	lddpc	r12,80004c60 <PcdAnticoll+0x14>

80004c4c <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004c4c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c50:	20 5d       	sub	sp,20
80004c52:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004c54:	30 8b       	mov	r11,8
80004c56:	16 9c       	mov	r12,r11
80004c58:	f0 1f 00 1a 	mcall	80004cc0 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004c5c:	30 0b       	mov	r11,0
80004c5e:	30 dc       	mov	r12,13
80004c60:	f0 1f 00 19 	mcall	80004cc4 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004c64:	e0 6b 00 80 	mov	r11,128
80004c68:	30 ec       	mov	r12,14
80004c6a:	f0 1f 00 16 	mcall	80004cc0 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004c6e:	39 38       	mov	r8,-109
80004c70:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004c72:	32 08       	mov	r8,32
80004c74:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004c76:	1a 9b       	mov	r11,sp
80004c78:	fa c8 ff ed 	sub	r8,sp,-19
80004c7c:	1a 99       	mov	r9,sp
80004c7e:	30 2a       	mov	r10,2
80004c80:	30 cc       	mov	r12,12
80004c82:	f0 1f 00 12 	mcall	80004cc8 <PcdAnticoll+0x7c>
80004c86:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004c88:	c1 21       	brne	80004cac <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c8a:	1b 89       	ld.ub	r9,sp[0x0]
80004c8c:	ac 89       	st.b	r6[0x0],r9
80004c8e:	1b 98       	ld.ub	r8,sp[0x1]
80004c90:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004c92:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c94:	1b a8       	ld.ub	r8,sp[0x2]
80004c96:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004c98:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c9c:	1b b9       	ld.ub	r9,sp[0x3]
80004c9e:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ca0:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004ca2:	1b c9       	ld.ub	r9,sp[0x4]
80004ca4:	f0 09 18 00 	cp.b	r9,r8
80004ca8:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004cac:	e0 6b 00 80 	mov	r11,128
80004cb0:	30 ec       	mov	r12,14
80004cb2:	f0 1f 00 07 	mcall	80004ccc <PcdAnticoll+0x80>
	return status;
}
80004cb6:	0e 9c       	mov	r12,r7
80004cb8:	2f bd       	sub	sp,-20
80004cba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004cbe:	00 00       	add	r0,r0
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	49 54       	lddpc	r4,80004d14 <PcdRequest+0x44>
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	47 ac       	lddsp	r12,sp[0x1e8]
80004cc8:	80 00       	ld.sh	r0,r0[0x0]
80004cca:	4a d4       	lddpc	r4,80004d7c <CalulateCRC+0x48>
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	49 10       	lddpc	r0,80004d10 <PcdRequest+0x40>

80004cd0 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004cd0:	eb cd 40 c0 	pushm	r6-r7,lr
80004cd4:	20 5d       	sub	sp,20
80004cd6:	18 97       	mov	r7,r12
80004cd8:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004cda:	30 8b       	mov	r11,8
80004cdc:	16 9c       	mov	r12,r11
80004cde:	f0 1f 00 12 	mcall	80004d24 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004ce2:	30 7b       	mov	r11,7
80004ce4:	30 dc       	mov	r12,13
80004ce6:	f0 1f 00 11 	mcall	80004d28 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004cea:	30 3b       	mov	r11,3
80004cec:	31 4c       	mov	r12,20
80004cee:	f0 1f 00 10 	mcall	80004d2c <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004cf2:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004cf4:	1a 9b       	mov	r11,sp
80004cf6:	fa c8 ff ed 	sub	r8,sp,-19
80004cfa:	1a 99       	mov	r9,sp
80004cfc:	30 1a       	mov	r10,1
80004cfe:	30 cc       	mov	r12,12
80004d00:	f0 1f 00 0c 	mcall	80004d30 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004d04:	c0 c1       	brne	80004d1c <PcdRequest+0x4c>
80004d06:	31 08       	mov	r8,16
80004d08:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d0c:	f0 09 18 00 	cp.b	r9,r8
80004d10:	c0 61       	brne	80004d1c <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004d12:	1b 88       	ld.ub	r8,sp[0x0]
80004d14:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004d16:	1b 98       	ld.ub	r8,sp[0x1]
80004d18:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004d1a:	c0 28       	rjmp	80004d1e <PcdRequest+0x4e>
80004d1c:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004d1e:	2f bd       	sub	sp,-20
80004d20:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d24:	80 00       	ld.sh	r0,r0[0x0]
80004d26:	49 54       	lddpc	r4,80004d78 <CalulateCRC+0x44>
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	47 ac       	lddsp	r12,sp[0x1e8]
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	49 10       	lddpc	r0,80004d70 <CalulateCRC+0x3c>
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	4a d4       	lddpc	r4,80004de4 <PcdSelect+0x24>

80004d34 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004d34:	eb cd 40 f8 	pushm	r3-r7,lr
80004d38:	18 95       	mov	r5,r12
80004d3a:	16 96       	mov	r6,r11
80004d3c:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004d3e:	30 4b       	mov	r11,4
80004d40:	30 5c       	mov	r12,5
80004d42:	f0 1f 00 1c 	mcall	80004db0 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d46:	30 0b       	mov	r11,0
80004d48:	30 1c       	mov	r12,1
80004d4a:	f0 1f 00 1b 	mcall	80004db4 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004d4e:	e0 6b 00 80 	mov	r11,128
80004d52:	30 ac       	mov	r12,10
80004d54:	f0 1f 00 19 	mcall	80004db8 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004d58:	58 06       	cp.w	r6,0
80004d5a:	c0 c0       	breq	80004d72 <CalulateCRC+0x3e>
80004d5c:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004d5e:	30 94       	mov	r4,9
80004d60:	0f 3b       	ld.ub	r11,r7++
80004d62:	08 9c       	mov	r12,r4
80004d64:	f0 1f 00 14 	mcall	80004db4 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004d68:	0e 98       	mov	r8,r7
80004d6a:	0a 18       	sub	r8,r5
80004d6c:	ec 08 18 00 	cp.b	r8,r6
80004d70:	cf 83       	brcs	80004d60 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004d72:	30 3b       	mov	r11,3
80004d74:	30 1c       	mov	r12,1
80004d76:	f0 1f 00 10 	mcall	80004db4 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004d7a:	30 5c       	mov	r12,5
80004d7c:	f0 1f 00 10 	mcall	80004dbc <CalulateCRC+0x88>
80004d80:	e0 67 00 fe 	mov	r7,254
80004d84:	30 56       	mov	r6,5
80004d86:	c0 78       	rjmp	80004d94 <CalulateCRC+0x60>
80004d88:	0c 9c       	mov	r12,r6
80004d8a:	f0 1f 00 0d 	mcall	80004dbc <CalulateCRC+0x88>
		i--;
80004d8e:	20 17       	sub	r7,1
80004d90:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004d92:	c0 40       	breq	80004d9a <CalulateCRC+0x66>
80004d94:	e2 1c 00 04 	andl	r12,0x4,COH
80004d98:	cf 80       	breq	80004d88 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004d9a:	32 2c       	mov	r12,34
80004d9c:	f0 1f 00 08 	mcall	80004dbc <CalulateCRC+0x88>
80004da0:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004da2:	32 1c       	mov	r12,33
80004da4:	f0 1f 00 06 	mcall	80004dbc <CalulateCRC+0x88>
80004da8:	a6 9c       	st.b	r3[0x1],r12
}
80004daa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004dae:	00 00       	add	r0,r0
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	49 54       	lddpc	r4,80004e04 <PcdSelect+0x44>
80004db4:	80 00       	ld.sh	r0,r0[0x0]
80004db6:	47 ac       	lddsp	r12,sp[0x1e8]
80004db8:	80 00       	ld.sh	r0,r0[0x0]
80004dba:	49 10       	lddpc	r0,80004dfc <PcdSelect+0x3c>
80004dbc:	80 00       	ld.sh	r0,r0[0x0]
80004dbe:	48 6c       	lddpc	r12,80004dd4 <PcdSelect+0x14>

80004dc0 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004dc0:	eb cd 40 80 	pushm	r7,lr
80004dc4:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004dc6:	39 38       	mov	r8,-109
80004dc8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004dca:	37 08       	mov	r8,112
80004dcc:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004dce:	30 08       	mov	r8,0
80004dd0:	ba e8       	st.b	sp[0x6],r8
80004dd2:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004dd6:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004dda:	19 89       	ld.ub	r9,r12[0x0]
80004ddc:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004dde:	19 3a       	ld.ub	r10,r12++
80004de0:	1b e9       	ld.ub	r9,sp[0x6]
80004de2:	f5 e9 20 09 	eor	r9,r10,r9
80004de6:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004de8:	16 38       	cp.w	r8,r11
80004dea:	cf 81       	brne	80004dda <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004dec:	1a 97       	mov	r7,sp
80004dee:	fa ca ff f9 	sub	r10,sp,-7
80004df2:	30 7b       	mov	r11,7
80004df4:	1a 9c       	mov	r12,sp
80004df6:	f0 1f 00 0d 	mcall	80004e28 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004dfa:	30 8b       	mov	r11,8
80004dfc:	16 9c       	mov	r12,r11
80004dfe:	f0 1f 00 0c 	mcall	80004e2c <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004e02:	fa c8 ff ed 	sub	r8,sp,-19
80004e06:	1a 99       	mov	r9,sp
80004e08:	30 9a       	mov	r10,9
80004e0a:	1a 9b       	mov	r11,sp
80004e0c:	30 cc       	mov	r12,12
80004e0e:	f0 1f 00 09 	mcall	80004e30 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004e12:	c0 71       	brne	80004e20 <PcdSelect+0x60>
80004e14:	31 88       	mov	r8,24
80004e16:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e1a:	f0 09 18 00 	cp.b	r9,r8
80004e1e:	c0 20       	breq	80004e22 <PcdSelect+0x62>
80004e20:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004e22:	2f bd       	sub	sp,-20
80004e24:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	4d 34       	lddpc	r4,80004f74 <scan_patrol+0x20>
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	49 54       	lddpc	r4,80004e80 <rfid_auto_reader+0x4c>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4a d4       	lddpc	r4,80004ee4 <rfid_auto_reader+0xb0>

80004e34 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004e34:	eb cd 40 c0 	pushm	r6-r7,lr
80004e38:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004e3a:	f0 1f 00 37 	mcall	80004f14 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004e3e:	4b 7b       	lddpc	r11,80004f18 <rfid_auto_reader+0xe4>
80004e40:	35 2c       	mov	r12,82
80004e42:	f0 1f 00 37 	mcall	80004f1c <rfid_auto_reader+0xe8>
80004e46:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004e48:	c6 31       	brne	80004f0e <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e4a:	4b 48       	lddpc	r8,80004f18 <rfid_auto_reader+0xe4>
80004e4c:	11 88       	ld.ub	r8,r8[0x0]
80004e4e:	30 49       	mov	r9,4
80004e50:	f2 08 18 00 	cp.b	r8,r9
80004e54:	c0 b1       	brne	80004e6a <rfid_auto_reader+0x36>
80004e56:	4b 19       	lddpc	r9,80004f18 <rfid_auto_reader+0xe4>
80004e58:	13 9a       	ld.ub	r10,r9[0x1]
80004e5a:	30 09       	mov	r9,0
80004e5c:	f2 0a 18 00 	cp.b	r10,r9
80004e60:	c0 51       	brne	80004e6a <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004e62:	4b 0c       	lddpc	r12,80004f20 <rfid_auto_reader+0xec>
80004e64:	f0 1f 00 30 	mcall	80004f24 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e68:	c3 c8       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004e6a:	30 29       	mov	r9,2
80004e6c:	f2 08 18 00 	cp.b	r8,r9
80004e70:	c0 b1       	brne	80004e86 <rfid_auto_reader+0x52>
80004e72:	4a a9       	lddpc	r9,80004f18 <rfid_auto_reader+0xe4>
80004e74:	13 9a       	ld.ub	r10,r9[0x1]
80004e76:	30 09       	mov	r9,0
80004e78:	f2 0a 18 00 	cp.b	r10,r9
80004e7c:	c0 51       	brne	80004e86 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004e7e:	4a bc       	lddpc	r12,80004f28 <rfid_auto_reader+0xf4>
80004e80:	f0 1f 00 29 	mcall	80004f24 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004e84:	c2 e8       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004e86:	34 49       	mov	r9,68
80004e88:	f2 08 18 00 	cp.b	r8,r9
80004e8c:	c0 b1       	brne	80004ea2 <rfid_auto_reader+0x6e>
80004e8e:	4a 39       	lddpc	r9,80004f18 <rfid_auto_reader+0xe4>
80004e90:	13 9a       	ld.ub	r10,r9[0x1]
80004e92:	30 09       	mov	r9,0
80004e94:	f2 0a 18 00 	cp.b	r10,r9
80004e98:	c0 51       	brne	80004ea2 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004e9a:	4a 5c       	lddpc	r12,80004f2c <rfid_auto_reader+0xf8>
80004e9c:	f0 1f 00 22 	mcall	80004f24 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ea0:	c2 08       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ea2:	30 89       	mov	r9,8
80004ea4:	f2 08 18 00 	cp.b	r8,r9
80004ea8:	c0 b1       	brne	80004ebe <rfid_auto_reader+0x8a>
80004eaa:	49 c9       	lddpc	r9,80004f18 <rfid_auto_reader+0xe4>
80004eac:	13 9a       	ld.ub	r10,r9[0x1]
80004eae:	30 09       	mov	r9,0
80004eb0:	f2 0a 18 00 	cp.b	r10,r9
80004eb4:	c0 51       	brne	80004ebe <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004eb6:	49 fc       	lddpc	r12,80004f30 <rfid_auto_reader+0xfc>
80004eb8:	f0 1f 00 1b 	mcall	80004f24 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ebc:	c1 28       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ebe:	34 49       	mov	r9,68
80004ec0:	f2 08 18 00 	cp.b	r8,r9
80004ec4:	c0 b1       	brne	80004eda <rfid_auto_reader+0xa6>
80004ec6:	49 58       	lddpc	r8,80004f18 <rfid_auto_reader+0xe4>
80004ec8:	11 99       	ld.ub	r9,r8[0x1]
80004eca:	30 38       	mov	r8,3
80004ecc:	f0 09 18 00 	cp.b	r9,r8
80004ed0:	c0 51       	brne	80004eda <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004ed2:	49 9c       	lddpc	r12,80004f34 <rfid_auto_reader+0x100>
80004ed4:	f0 1f 00 14 	mcall	80004f24 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ed8:	c0 48       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004eda:	49 8c       	lddpc	r12,80004f38 <rfid_auto_reader+0x104>
80004edc:	f0 1f 00 12 	mcall	80004f24 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004ee0:	49 7c       	lddpc	r12,80004f3c <rfid_auto_reader+0x108>
80004ee2:	f0 1f 00 18 	mcall	80004f40 <rfid_auto_reader+0x10c>
80004ee6:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004ee8:	c0 60       	breq	80004ef4 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004eea:	37 8b       	mov	r11,120
80004eec:	30 1c       	mov	r12,1
80004eee:	f0 1f 00 16 	mcall	80004f44 <rfid_auto_reader+0x110>
		return status;
80004ef2:	c0 e8       	rjmp	80004f0e <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004ef4:	49 2c       	lddpc	r12,80004f3c <rfid_auto_reader+0x108>
80004ef6:	f0 1f 00 15 	mcall	80004f48 <rfid_auto_reader+0x114>
80004efa:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004efc:	c0 91       	brne	80004f0e <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004efe:	30 4a       	mov	r10,4
80004f00:	48 fb       	lddpc	r11,80004f3c <rfid_auto_reader+0x108>
80004f02:	0c 9c       	mov	r12,r6
80004f04:	f0 1f 00 12 	mcall	80004f4c <rfid_auto_reader+0x118>
		log("select okay\n");
80004f08:	49 2c       	lddpc	r12,80004f50 <rfid_auto_reader+0x11c>
80004f0a:	f0 1f 00 07 	mcall	80004f24 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004f0e:	0e 9c       	mov	r12,r7
80004f10:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f14:	80 00       	ld.sh	r0,r0[0x0]
80004f16:	47 ec       	lddsp	r12,sp[0x1f8]
80004f18:	00 00       	add	r0,r0
80004f1a:	51 28       	stdsp	sp[0x48],r8
80004f1c:	80 00       	ld.sh	r0,r0[0x0]
80004f1e:	4c d0       	lddpc	r0,80005050 <rfid_sendID_message+0xac>
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	d6 54       	*unknown*
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	6d 30       	ld.w	r0,r6[0x4c]
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	d6 60       	acall	0x66
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	d6 6c       	*unknown*
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	d6 7c       	*unknown*
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	d6 84       	*unknown*
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	d6 90       	acall	0x69
80004f3c:	00 00       	add	r0,r0
80004f3e:	51 2c       	stdsp	sp[0x48],r12
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	4c 4c       	lddpc	r12,80005050 <rfid_sendID_message+0xac>
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	3f 40       	mov	r0,-12
80004f48:	80 00       	ld.sh	r0,r0[0x0]
80004f4a:	4d c0       	lddpc	r0,800050b8 <rfid_sendID_message+0x114>
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	75 ac       	ld.w	r12,r10[0x68]
80004f50:	80 00       	ld.sh	r0,r0[0x0]
80004f52:	d6 9c       	*unknown*

80004f54 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80004f54:	eb cd 40 80 	pushm	r7,lr
80004f58:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80004f5a:	f0 1f 00 0d 	mcall	80004f8c <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80004f5e:	30 0c       	mov	r12,0
80004f60:	f0 1f 00 0c 	mcall	80004f90 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80004f64:	0e 9c       	mov	r12,r7
80004f66:	f0 1f 00 0c 	mcall	80004f94 <scan_patrol+0x40>
80004f6a:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80004f6c:	30 1c       	mov	r12,1
80004f6e:	f0 1f 00 09 	mcall	80004f90 <scan_patrol+0x3c>
	if(return_err == 0)
80004f72:	58 07       	cp.w	r7,0
80004f74:	c0 51       	brne	80004f7e <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80004f76:	48 9c       	lddpc	r12,80004f98 <scan_patrol+0x44>
80004f78:	f0 1f 00 09 	mcall	80004f9c <scan_patrol+0x48>
80004f7c:	c0 48       	rjmp	80004f84 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80004f7e:	48 9c       	lddpc	r12,80004fa0 <scan_patrol+0x4c>
80004f80:	f0 1f 00 07 	mcall	80004f9c <scan_patrol+0x48>
		
	return return_err;

}
80004f84:	0e 9c       	mov	r12,r7
80004f86:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f8a:	00 00       	add	r0,r0
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	47 ec       	lddsp	r12,sp[0x1f8]
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	48 c4       	lddpc	r4,80004fc0 <rfid_sendID_message+0x1c>
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4e 34       	lddpc	r4,80005120 <delay_us>
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	d6 ac       	*unknown*
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	6d 30       	ld.w	r0,r6[0x4c]
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	d6 c0       	acall	0x6c

80004fa4 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
{
80004fa4:	eb cd 40 e0 	pushm	r5-r7,lr
80004fa8:	21 bd       	sub	sp,108
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80004faa:	4c bc       	lddpc	r12,800050d4 <rfid_sendID_message+0x130>
80004fac:	30 08       	mov	r8,0
80004fae:	30 09       	mov	r9,0
80004fb0:	f8 e9 00 00 	st.d	r12[0],r8
80004fb4:	30 0a       	mov	r10,0
80004fb6:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004fb8:	fa e9 00 1c 	st.d	sp[28],r8
80004fbc:	fa e9 00 24 	st.d	sp[36],r8
80004fc0:	fa e9 00 2c 	st.d	sp[44],r8
80004fc4:	fa e9 00 34 	st.d	sp[52],r8
80004fc8:	fa e9 00 3c 	st.d	sp[60],r8
80004fcc:	fa e9 00 44 	st.d	sp[68],r8
80004fd0:	fa e9 00 4c 	st.d	sp[76],r8
80004fd4:	fa e9 00 54 	st.d	sp[84],r8
80004fd8:	fa e9 00 5c 	st.d	sp[92],r8
80004fdc:	fa e9 00 64 	st.d	sp[100],r8
	
	return_err = scan_patrol(SN);
80004fe0:	f0 1f 00 3e 	mcall	800050d8 <rfid_sendID_message+0x134>
80004fe4:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004fe6:	c6 c1       	brne	800050be <rfid_sendID_message+0x11a>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004fe8:	4b b6       	lddpc	r6,800050d4 <rfid_sendID_message+0x130>
80004fea:	0d b8       	ld.ub	r8,r6[0x3]
80004fec:	1a d8       	st.w	--sp,r8
80004fee:	0d a8       	ld.ub	r8,r6[0x2]
80004ff0:	1a d8       	st.w	--sp,r8
80004ff2:	0d 98       	ld.ub	r8,r6[0x1]
80004ff4:	1a d8       	st.w	--sp,r8
80004ff6:	0d 88       	ld.ub	r8,r6[0x0]
80004ff8:	1a d8       	st.w	--sp,r8
80004ffa:	4b 9c       	lddpc	r12,800050dc <rfid_sendID_message+0x138>
80004ffc:	f0 1f 00 39 	mcall	800050e0 <rfid_sendID_message+0x13c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80005000:	37 7b       	mov	r11,119
80005002:	30 1c       	mov	r12,1
80005004:	f0 1f 00 38 	mcall	800050e4 <rfid_sendID_message+0x140>
80005008:	fa c8 ff ee 	sub	r8,sp,-18
8000500c:	fa c9 ff ec 	sub	r9,sp,-20
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
80005010:	ec c5 ff fc 	sub	r5,r6,-4
80005014:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005016:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005018:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
8000501a:	0d 8a       	ld.ub	r10,r6[0x0]
8000501c:	f4 0b 16 04 	lsr	r11,r10,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005020:	fc 0b 18 00 	cp.b	r11,lr
80005024:	f7 bb 08 d0 	subls	r11,-48
80005028:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
8000502c:	f7 bb 0b a9 	subhi	r11,-87
80005030:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005034:	b0 9c       	st.b	r8[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005036:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
8000503a:	fc 0a 18 00 	cp.b	r10,lr
8000503e:	f7 ba 08 d0 	subls	r10,-48
80005042:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005046:	f7 ba 0b a9 	subhi	r10,-87
8000504a:	f3 fa be 00 	st.bhi	r9[0x0],r10

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
8000504e:	b0 bc       	st.b	r8[0x3],r12
80005050:	2f f6       	sub	r6,-1
80005052:	2f c8       	sub	r8,-4
80005054:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005056:	0a 36       	cp.w	r6,r5
80005058:	ce 11       	brne	8000501a <rfid_sendID_message+0x76>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
8000505a:	4a 48       	lddpc	r8,800050e8 <rfid_sendID_message+0x144>
8000505c:	11 89       	ld.ub	r9,r8[0x0]
8000505e:	39 f8       	mov	r8,-97
80005060:	f0 09 18 00 	cp.b	r9,r8
80005064:	e0 88 00 05 	brls	8000506e <rfid_sendID_message+0xca>
80005068:	38 09       	mov	r9,-128
8000506a:	4a 08       	lddpc	r8,800050e8 <rfid_sendID_message+0x144>
8000506c:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
8000506e:	49 f8       	lddpc	r8,800050e8 <rfid_sendID_message+0x144>
80005070:	11 86       	ld.ub	r6,r8[0x0]
80005072:	2f f6       	sub	r6,-1
80005074:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005076:	30 5a       	mov	r10,5
80005078:	49 db       	lddpc	r11,800050ec <rfid_sendID_message+0x148>
8000507a:	fa cc ff e9 	sub	r12,sp,-23
8000507e:	f0 1f 00 1d 	mcall	800050f0 <rfid_sendID_message+0x14c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005082:	31 88       	mov	r8,24
80005084:	fb 58 00 12 	st.h	sp[18],r8
80005088:	fb 66 00 16 	st.b	sp[22],r6
8000508c:	fe 78 e0 00 	mov	r8,-8192
80005090:	fb 58 00 14 	st.h	sp[20],r8
80005094:	fa c6 ff e4 	sub	r6,sp,-28
80005098:	30 aa       	mov	r10,10
8000509a:	fa cb ff ee 	sub	r11,sp,-18
8000509e:	0c 9c       	mov	r12,r6
800050a0:	f0 1f 00 14 	mcall	800050f0 <rfid_sendID_message+0x14c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800050a4:	31 0a       	mov	r10,16
800050a6:	fa cb ff fe 	sub	r11,sp,-2
800050aa:	fa cc ff da 	sub	r12,sp,-38
800050ae:	f0 1f 00 11 	mcall	800050f0 <rfid_sendID_message+0x14c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
800050b2:	30 9a       	mov	r10,9
800050b4:	31 ab       	mov	r11,26
800050b6:	0c 9c       	mov	r12,r6
800050b8:	f0 1f 00 0f 	mcall	800050f4 <rfid_sendID_message+0x150>
800050bc:	c0 88       	rjmp	800050cc <rfid_sendID_message+0x128>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
800050be:	37 8b       	mov	r11,120
800050c0:	30 1c       	mov	r12,1
800050c2:	f0 1f 00 09 	mcall	800050e4 <rfid_sendID_message+0x140>
		log("no card find...\n");
800050c6:	48 dc       	lddpc	r12,800050f8 <rfid_sendID_message+0x154>
800050c8:	f0 1f 00 06 	mcall	800050e0 <rfid_sendID_message+0x13c>
	}
	
	return return_err;
	
}
800050cc:	0e 9c       	mov	r12,r7
800050ce:	2e 5d       	sub	sp,-108
800050d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800050d4:	00 00       	add	r0,r0
800050d6:	0b 60       	ld.uh	r0,--r5
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	4f 54       	lddpc	r4,800052ac <gpio_enable_module_pin+0x22>
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	d6 d4       	*unknown*
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	6d 30       	ld.w	r0,r6[0x4c]
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	3f 40       	mov	r0,-12
800050e8:	00 00       	add	r0,r0
800050ea:	05 30       	ld.ub	r0,r2++
800050ec:	00 00       	add	r0,r0
800050ee:	05 28       	ld.uh	r8,r2++
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	75 ac       	ld.w	r12,r10[0x68]
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	3e 08       	mov	r8,-32
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	d6 f0       	acall	0x6f

800050fc <rfid_init>:
/*the queue is used to receive failure-send message*/
extern volatile xQueueHandle xg_resend_queue ;


void rfid_init()
{
800050fc:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800050fe:	f0 1f 00 02 	mcall	80005104 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005102:	d8 02       	popm	pc
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	49 fc       	lddpc	r12,80005180 <local_start_timer+0x10>

80005108 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005108:	58 0c       	cp.w	r12,0
8000510a:	5e 0c       	reteq	r12
8000510c:	30 08       	mov	r8,0
	{
		nop();
8000510e:	d7 03       	nop
		nop();
80005110:	d7 03       	nop
		nop();
80005112:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005114:	2f f8       	sub	r8,-1
80005116:	10 3c       	cp.w	r12,r8
80005118:	fe 9b ff fb 	brhi	8000510e <delay_ns+0x6>
8000511c:	5e fc       	retal	r12
8000511e:	d7 03       	nop

80005120 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005120:	eb cd 40 e0 	pushm	r5-r7,lr
80005124:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005126:	58 0c       	cp.w	r12,0
80005128:	c0 b0       	breq	8000513e <delay_us+0x1e>
8000512a:	30 07       	mov	r7,0
		delay_ns(1000);
8000512c:	e0 65 03 e8 	mov	r5,1000
80005130:	0a 9c       	mov	r12,r5
80005132:	f0 1f 00 05 	mcall	80005144 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005136:	2f f7       	sub	r7,-1
80005138:	0e 36       	cp.w	r6,r7
8000513a:	fe 9b ff fb 	brhi	80005130 <delay_us+0x10>
8000513e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005142:	00 00       	add	r0,r0
80005144:	80 00       	ld.sh	r0,r0[0x0]
80005146:	51 08       	stdsp	sp[0x40],r8

80005148 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005148:	eb cd 40 e0 	pushm	r5-r7,lr
8000514c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000514e:	58 0c       	cp.w	r12,0
80005150:	c0 b0       	breq	80005166 <delay_ms+0x1e>
80005152:	30 07       	mov	r7,0
		delay_us(1000);
80005154:	e0 65 03 e8 	mov	r5,1000
80005158:	0a 9c       	mov	r12,r5
8000515a:	f0 1f 00 05 	mcall	8000516c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000515e:	2f f7       	sub	r7,-1
80005160:	0e 36       	cp.w	r6,r7
80005162:	fe 9b ff fb 	brhi	80005158 <delay_ms+0x10>
80005166:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000516a:	00 00       	add	r0,r0
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	51 20       	stdsp	sp[0x48],r0

80005170 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005170:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005172:	30 3b       	mov	r11,3
80005174:	48 8c       	lddpc	r12,80005194 <local_start_timer+0x24>
80005176:	f0 1f 00 09 	mcall	80005198 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000517a:	fe 78 38 00 	mov	r8,-51200
8000517e:	e0 69 91 0d 	mov	r9,37133
80005182:	ea 19 00 52 	orh	r9,0x52
80005186:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005188:	32 09       	mov	r9,32
8000518a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000518c:	30 59       	mov	r9,5
8000518e:	91 09       	st.w	r8[0x0],r9
}
80005190:	d8 02       	popm	pc
80005192:	00 00       	add	r0,r0
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	d7 04       	*unknown*
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	52 dc       	stdsp	sp[0xb4],r12

8000519c <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
8000519c:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
8000519e:	30 3a       	mov	r10,3
800051a0:	e0 6b 1b 00 	mov	r11,6912
800051a4:	ea 1b 00 b7 	orh	r11,0xb7
800051a8:	fe 7c 0c 00 	mov	r12,-62464
800051ac:	f0 1f 00 19 	mcall	80005210 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800051b0:	31 08       	mov	r8,16
800051b2:	1a d8       	st.w	--sp,r8
800051b4:	30 08       	mov	r8,0
800051b6:	30 19       	mov	r9,1
800051b8:	30 7a       	mov	r10,7
800051ba:	10 9b       	mov	r11,r8
800051bc:	fe 7c 0c 00 	mov	r12,-62464
800051c0:	f0 1f 00 15 	mcall	80005214 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
800051c4:	30 08       	mov	r8,0
800051c6:	30 19       	mov	r9,1
800051c8:	12 9a       	mov	r10,r9
800051ca:	10 9b       	mov	r11,r8
800051cc:	fe 7c 0c 00 	mov	r12,-62464
800051d0:	f0 1f 00 12 	mcall	80005218 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
800051d4:	30 0b       	mov	r11,0
800051d6:	fe 7c 0c 00 	mov	r12,-62464
800051da:	f0 1f 00 11 	mcall	8000521c <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
800051de:	fe 7c 0c 00 	mov	r12,-62464
800051e2:	f0 1f 00 10 	mcall	80005220 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
800051e6:	30 0a       	mov	r10,0
800051e8:	1a da       	st.w	--sp,r10
800051ea:	1a da       	st.w	--sp,r10
800051ec:	14 98       	mov	r8,r10
800051ee:	14 99       	mov	r9,r10
800051f0:	30 1b       	mov	r11,1
800051f2:	fe 7c 0c 00 	mov	r12,-62464
800051f6:	f0 1f 00 0c 	mcall	80005224 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800051fa:	30 1c       	mov	r12,1
800051fc:	f0 1f 00 0b 	mcall	80005228 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005200:	30 2b       	mov	r11,2
80005202:	fe 7c 0c 00 	mov	r12,-62464
80005206:	f0 1f 00 0a 	mcall	8000522c <local_start_pll0+0x90>
8000520a:	2f dd       	sub	sp,-12
/****/
}
8000520c:	d8 02       	popm	pc
8000520e:	00 00       	add	r0,r0
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	55 90       	stdsp	sp[0x164],r0
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	55 32       	stdsp	sp[0x14c],r2
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	55 54       	stdsp	sp[0x154],r4
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	55 6e       	stdsp	sp[0x158],lr
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	55 7c       	stdsp	sp[0x15c],r12
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	54 ec       	stdsp	sp[0x138],r12
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	52 7c       	stdsp	sp[0x9c],r12
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	55 86       	stdsp	sp[0x160],r6

80005230 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005230:	eb cd 40 e0 	pushm	r5-r7,lr
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
80005234:	30 4b       	mov	r11,4
80005236:	36 4c       	mov	r12,100
80005238:	f0 1f 00 0c 	mcall	80005268 <xg_flashc_init+0x38>
8000523c:	48 c8       	lddpc	r8,8000526c <xg_flashc_init+0x3c>
8000523e:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(100, sizeof(U32));
80005240:	30 4b       	mov	r11,4
80005242:	36 4c       	mov	r12,100
80005244:	f0 1f 00 09 	mcall	80005268 <xg_flashc_init+0x38>
80005248:	48 a8       	lddpc	r8,80005270 <xg_flashc_init+0x40>
8000524a:	91 0c       	st.w	r8[0x0],r12
8000524c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
8000524e:	10 96       	mov	r6,r8
80005250:	48 95       	lddpc	r5,80005274 <xg_flashc_init+0x44>
80005252:	6c 0c       	ld.w	r12,r6[0x0]
80005254:	ea 07 00 0b 	add	r11,r5,r7
80005258:	f0 1f 00 08 	mcall	80005278 <xg_flashc_init+0x48>
8000525c:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(100, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
8000525e:	e0 47 0a 28 	cp.w	r7,2600
80005262:	cf 81       	brne	80005252 <xg_flashc_init+0x22>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005264:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	62 50       	ld.w	r0,r1[0x14]
8000526c:	00 00       	add	r0,r0
8000526e:	0b 6c       	ld.uh	r12,--r5
80005270:	00 00       	add	r0,r0
80005272:	0b 70       	ld.ub	r0,--r5
80005274:	00 00       	add	r0,r0
80005276:	51 30       	stdsp	sp[0x4c],r0
80005278:	80 00       	ld.sh	r0,r0[0x0]
8000527a:	2a dc       	sub	r12,-83

8000527c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000527c:	fe 68 14 00 	mov	r8,-125952
80005280:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005282:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005286:	91 09       	st.w	r8[0x0],r9
}
80005288:	5e fc       	retal	r12

8000528a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000528a:	f8 08 16 05 	lsr	r8,r12,0x5
8000528e:	a9 68       	lsl	r8,0x8
80005290:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005294:	58 1b       	cp.w	r11,1
80005296:	c0 d0       	breq	800052b0 <gpio_enable_module_pin+0x26>
80005298:	c0 63       	brcs	800052a4 <gpio_enable_module_pin+0x1a>
8000529a:	58 2b       	cp.w	r11,2
8000529c:	c1 00       	breq	800052bc <gpio_enable_module_pin+0x32>
8000529e:	58 3b       	cp.w	r11,3
800052a0:	c1 40       	breq	800052c8 <gpio_enable_module_pin+0x3e>
800052a2:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800052a4:	30 19       	mov	r9,1
800052a6:	f2 0c 09 49 	lsl	r9,r9,r12
800052aa:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800052ac:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052ae:	c1 28       	rjmp	800052d2 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800052b0:	30 19       	mov	r9,1
800052b2:	f2 0c 09 49 	lsl	r9,r9,r12
800052b6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800052b8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052ba:	c0 c8       	rjmp	800052d2 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800052bc:	30 19       	mov	r9,1
800052be:	f2 0c 09 49 	lsl	r9,r9,r12
800052c2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800052c4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052c6:	c0 68       	rjmp	800052d2 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800052c8:	30 19       	mov	r9,1
800052ca:	f2 0c 09 49 	lsl	r9,r9,r12
800052ce:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800052d0:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800052d2:	30 19       	mov	r9,1
800052d4:	f2 0c 09 4c 	lsl	r12,r9,r12
800052d8:	91 2c       	st.w	r8[0x8],r12
800052da:	5e fd       	retal	0

800052dc <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800052dc:	d4 21       	pushm	r4-r7,lr
800052de:	18 97       	mov	r7,r12
800052e0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800052e2:	58 0b       	cp.w	r11,0
800052e4:	c0 31       	brne	800052ea <gpio_enable_module+0xe>
800052e6:	30 05       	mov	r5,0
800052e8:	c0 d8       	rjmp	80005302 <gpio_enable_module+0x26>
800052ea:	30 06       	mov	r6,0
800052ec:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800052ee:	6e 1b       	ld.w	r11,r7[0x4]
800052f0:	6e 0c       	ld.w	r12,r7[0x0]
800052f2:	f0 1f 00 06 	mcall	80005308 <gpio_enable_module+0x2c>
800052f6:	18 45       	or	r5,r12
		gpiomap++;
800052f8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800052fa:	2f f6       	sub	r6,-1
800052fc:	0c 34       	cp.w	r4,r6
800052fe:	fe 9b ff f8 	brhi	800052ee <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005302:	0a 9c       	mov	r12,r5
80005304:	d8 22       	popm	r4-r7,pc
80005306:	00 00       	add	r0,r0
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	52 8a       	stdsp	sp[0xa0],r10

8000530c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000530c:	f8 08 16 05 	lsr	r8,r12,0x5
80005310:	a9 68       	lsl	r8,0x8
80005312:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005316:	30 19       	mov	r9,1
80005318:	f2 0c 09 4c 	lsl	r12,r9,r12
8000531c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005320:	91 1c       	st.w	r8[0x4],r12
}
80005322:	5e fc       	retal	r12

80005324 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005324:	f8 08 16 05 	lsr	r8,r12,0x5
80005328:	a9 68       	lsl	r8,0x8
8000532a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000532e:	30 19       	mov	r9,1
80005330:	f2 0c 09 4c 	lsl	r12,r9,r12
80005334:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005338:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000533c:	91 1c       	st.w	r8[0x4],r12
}
8000533e:	5e fc       	retal	r12

80005340 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005340:	f8 08 16 05 	lsr	r8,r12,0x5
80005344:	a9 68       	lsl	r8,0x8
80005346:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000534a:	30 19       	mov	r9,1
8000534c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005350:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005354:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005358:	91 1c       	st.w	r8[0x4],r12
}
8000535a:	5e fc       	retal	r12

8000535c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000535c:	c0 08       	rjmp	8000535c <_unhandled_interrupt>
8000535e:	d7 03       	nop

80005360 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005360:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005364:	49 99       	lddpc	r9,800053c8 <INTC_register_interrupt+0x68>
80005366:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000536a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000536e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005370:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005374:	58 0a       	cp.w	r10,0
80005376:	c0 91       	brne	80005388 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005378:	49 59       	lddpc	r9,800053cc <INTC_register_interrupt+0x6c>
8000537a:	49 6a       	lddpc	r10,800053d0 <INTC_register_interrupt+0x70>
8000537c:	12 1a       	sub	r10,r9
8000537e:	fe 79 08 00 	mov	r9,-63488
80005382:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005386:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005388:	58 1a       	cp.w	r10,1
8000538a:	c0 a1       	brne	8000539e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000538c:	49 09       	lddpc	r9,800053cc <INTC_register_interrupt+0x6c>
8000538e:	49 2a       	lddpc	r10,800053d4 <INTC_register_interrupt+0x74>
80005390:	12 1a       	sub	r10,r9
80005392:	bf aa       	sbr	r10,0x1e
80005394:	fe 79 08 00 	mov	r9,-63488
80005398:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000539c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000539e:	58 2a       	cp.w	r10,2
800053a0:	c0 a1       	brne	800053b4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800053a2:	48 b9       	lddpc	r9,800053cc <INTC_register_interrupt+0x6c>
800053a4:	48 da       	lddpc	r10,800053d8 <INTC_register_interrupt+0x78>
800053a6:	12 1a       	sub	r10,r9
800053a8:	bf ba       	sbr	r10,0x1f
800053aa:	fe 79 08 00 	mov	r9,-63488
800053ae:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053b2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800053b4:	48 69       	lddpc	r9,800053cc <INTC_register_interrupt+0x6c>
800053b6:	48 aa       	lddpc	r10,800053dc <INTC_register_interrupt+0x7c>
800053b8:	12 1a       	sub	r10,r9
800053ba:	ea 1a c0 00 	orh	r10,0xc000
800053be:	fe 79 08 00 	mov	r9,-63488
800053c2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053c6:	5e fc       	retal	r12
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	d7 1c       	*unknown*
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	cc 00       	breq	8000534e <gpio_clr_gpio_pin+0xe>
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	cd 04       	brge	80005372 <INTC_register_interrupt+0x12>
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	cd 12       	brcc	80005378 <INTC_register_interrupt+0x18>
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	cd 20       	breq	8000537e <INTC_register_interrupt+0x1e>
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	cd 2e       	rcall	80005182 <local_start_timer+0x12>

800053e0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800053e0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800053e2:	49 18       	lddpc	r8,80005424 <INTC_init_interrupts+0x44>
800053e4:	e3 b8 00 01 	mtsr	0x4,r8
800053e8:	49 0e       	lddpc	lr,80005428 <INTC_init_interrupts+0x48>
800053ea:	30 07       	mov	r7,0
800053ec:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800053ee:	49 0c       	lddpc	r12,8000542c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800053f0:	49 05       	lddpc	r5,80005430 <INTC_init_interrupts+0x50>
800053f2:	10 15       	sub	r5,r8
800053f4:	fe 76 08 00 	mov	r6,-63488
800053f8:	c1 08       	rjmp	80005418 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800053fa:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800053fc:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800053fe:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005400:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005404:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005406:	10 3a       	cp.w	r10,r8
80005408:	fe 9b ff fc 	brhi	80005400 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000540c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005410:	2f f7       	sub	r7,-1
80005412:	2f 8e       	sub	lr,-8
80005414:	59 37       	cp.w	r7,19
80005416:	c0 50       	breq	80005420 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005418:	7c 08       	ld.w	r8,lr[0x0]
8000541a:	58 08       	cp.w	r8,0
8000541c:	ce f1       	brne	800053fa <INTC_init_interrupts+0x1a>
8000541e:	cf 7b       	rjmp	8000540c <INTC_init_interrupts+0x2c>
80005420:	d8 22       	popm	r4-r7,pc
80005422:	00 00       	add	r0,r0
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	cc 00       	breq	800053a6 <INTC_register_interrupt+0x46>
80005428:	80 00       	ld.sh	r0,r0[0x0]
8000542a:	d7 1c       	*unknown*
8000542c:	80 00       	ld.sh	r0,r0[0x0]
8000542e:	53 5c       	stdsp	sp[0xd4],r12
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	cd 04       	brge	800053d2 <INTC_register_interrupt+0x72>

80005434 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005434:	fe 78 08 00 	mov	r8,-63488
80005438:	e0 69 00 83 	mov	r9,131
8000543c:	f2 0c 01 0c 	sub	r12,r9,r12
80005440:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005444:	f2 ca ff c0 	sub	r10,r9,-64
80005448:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000544c:	58 08       	cp.w	r8,0
8000544e:	c0 21       	brne	80005452 <_get_interrupt_handler+0x1e>
80005450:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005452:	f0 08 12 00 	clz	r8,r8
80005456:	48 5a       	lddpc	r10,80005468 <_get_interrupt_handler+0x34>
80005458:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000545c:	f0 08 11 1f 	rsub	r8,r8,31
80005460:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005462:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005466:	5e fc       	retal	r12
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	d7 1c       	*unknown*

8000546c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000546c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000546e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005472:	99 a8       	st.w	r12[0x28],r8
}
80005474:	5e fc       	retal	r12
80005476:	d7 03       	nop

80005478 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005478:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000547a:	ec 5b bb 9f 	cp.w	r11,899999
8000547e:	e0 8b 00 04 	brhi	80005486 <pm_enable_osc0_crystal+0xe>
80005482:	30 4b       	mov	r11,4
80005484:	c1 38       	rjmp	800054aa <pm_enable_osc0_crystal+0x32>
80005486:	e0 68 c6 bf 	mov	r8,50879
8000548a:	ea 18 00 2d 	orh	r8,0x2d
8000548e:	10 3b       	cp.w	r11,r8
80005490:	e0 8b 00 04 	brhi	80005498 <pm_enable_osc0_crystal+0x20>
80005494:	30 5b       	mov	r11,5
80005496:	c0 a8       	rjmp	800054aa <pm_enable_osc0_crystal+0x32>
80005498:	e0 68 12 00 	mov	r8,4608
8000549c:	ea 18 00 7a 	orh	r8,0x7a
800054a0:	10 3b       	cp.w	r11,r8
800054a2:	f9 bb 03 06 	movlo	r11,6
800054a6:	f9 bb 02 07 	movhs	r11,7
800054aa:	f0 1f 00 02 	mcall	800054b0 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800054ae:	d8 02       	popm	pc
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	54 6c       	stdsp	sp[0x118],r12

800054b4 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800054b4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800054b6:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800054ba:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800054bc:	78 08       	ld.w	r8,r12[0x0]
800054be:	a3 a8       	sbr	r8,0x2
800054c0:	99 08       	st.w	r12[0x0],r8
}
800054c2:	5e fc       	retal	r12

800054c4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800054c4:	79 58       	ld.w	r8,r12[0x54]
800054c6:	e2 18 00 80 	andl	r8,0x80,COH
800054ca:	cf d0       	breq	800054c4 <pm_wait_for_clk0_ready>
}
800054cc:	5e fc       	retal	r12
800054ce:	d7 03       	nop

800054d0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800054d0:	eb cd 40 80 	pushm	r7,lr
800054d4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800054d6:	f0 1f 00 04 	mcall	800054e4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800054da:	0e 9c       	mov	r12,r7
800054dc:	f0 1f 00 03 	mcall	800054e8 <pm_enable_clk0+0x18>
}
800054e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800054e4:	80 00       	ld.sh	r0,r0[0x0]
800054e6:	54 b4       	stdsp	sp[0x12c],r4
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	54 c4       	stdsp	sp[0x130],r4

800054ec <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800054ec:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800054f0:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800054f4:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800054f6:	09 f7       	ld.ub	r7,r4[0x7]
800054f8:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800054fc:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005500:	09 b4       	ld.ub	r4,r4[0x3]
80005502:	08 96       	mov	r6,r4
80005504:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005508:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
8000550c:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005510:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005514:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005518:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000551c:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005520:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005524:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005526:	79 58       	ld.w	r8,r12[0x54]
80005528:	e2 18 00 20 	andl	r8,0x20,COH
8000552c:	cf d0       	breq	80005526 <pm_cksel+0x3a>
}
8000552e:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005532 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005532:	eb cd 40 80 	pushm	r7,lr
80005536:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005538:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000553a:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000553e:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005542:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005546:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000554a:	2f 8b       	sub	r11,-8
8000554c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005550:	e3 cd 80 80 	ldm	sp++,r7,pc

80005554 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005554:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005556:	2f 8b       	sub	r11,-8
80005558:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000555c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005560:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005564:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005568:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000556c:	d8 02       	popm	pc

8000556e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000556e:	2f 8b       	sub	r11,-8
80005570:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005574:	a1 a8       	sbr	r8,0x0
80005576:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000557a:	5e fc       	retal	r12

8000557c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000557c:	79 58       	ld.w	r8,r12[0x54]
8000557e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005582:	cf d0       	breq	8000557c <pm_wait_for_pll0_locked>
}
80005584:	5e fc       	retal	r12

80005586 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005586:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005588:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000558c:	99 08       	st.w	r12[0x0],r8
}
8000558e:	5e fc       	retal	r12

80005590 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005590:	eb cd 40 c0 	pushm	r6-r7,lr
80005594:	18 97       	mov	r7,r12
80005596:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005598:	f0 1f 00 06 	mcall	800055b0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000559c:	0c 9b       	mov	r11,r6
8000559e:	0e 9c       	mov	r12,r7
800055a0:	f0 1f 00 05 	mcall	800055b4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800055a4:	30 1b       	mov	r11,1
800055a6:	0e 9c       	mov	r12,r7
800055a8:	f0 1f 00 04 	mcall	800055b8 <pm_switch_to_osc0+0x28>
}
800055ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	54 78       	stdsp	sp[0x11c],r8
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	54 d0       	stdsp	sp[0x134],r0
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	55 86       	stdsp	sp[0x160],r6

800055bc <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800055bc:	f8 c8 00 01 	sub	r8,r12,1
800055c0:	f0 0b 00 0b 	add	r11,r8,r11
800055c4:	f6 0c 0d 0a 	divu	r10,r11,r12
800055c8:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800055ca:	f4 c8 00 01 	sub	r8,r10,1
800055ce:	e0 48 00 fe 	cp.w	r8,254
800055d2:	e0 88 00 03 	brls	800055d8 <getBaudDiv+0x1c>
800055d6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800055d8:	5c 8c       	casts.h	r12
}
800055da:	5e fc       	retal	r12

800055dc <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800055dc:	f7 39 00 0d 	ld.ub	r9,r11[13]
800055e0:	30 18       	mov	r8,1
800055e2:	f0 09 18 00 	cp.b	r9,r8
800055e6:	e0 88 00 04 	brls	800055ee <spi_initMaster+0x12>
800055ea:	30 2c       	mov	r12,2
800055ec:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800055ee:	e0 68 00 80 	mov	r8,128
800055f2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800055f4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800055f6:	30 19       	mov	r9,1
800055f8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800055fc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005600:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005604:	30 09       	mov	r9,0
80005606:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000560a:	30 fa       	mov	r10,15
8000560c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005610:	99 18       	st.w	r12[0x4],r8
80005612:	5e f9       	retal	r9

80005614 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005614:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005616:	30 18       	mov	r8,1
80005618:	f0 0b 18 00 	cp.b	r11,r8
8000561c:	5f be       	srhi	lr
8000561e:	f0 0a 18 00 	cp.b	r10,r8
80005622:	5f b8       	srhi	r8
80005624:	fd e8 10 08 	or	r8,lr,r8
80005628:	c0 30       	breq	8000562e <spi_selectionMode+0x1a>
8000562a:	30 2c       	mov	r12,2
8000562c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000562e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005630:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005634:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005638:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
8000563c:	99 18       	st.w	r12[0x4],r8
8000563e:	d8 0a       	popm	pc,r12=0

80005640 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005640:	30 18       	mov	r8,1
80005642:	99 08       	st.w	r12[0x0],r8
}
80005644:	5e fc       	retal	r12

80005646 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005646:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000564a:	c0 58       	rjmp	80005654 <spi_write+0xe>
		if (!timeout--) {
8000564c:	58 08       	cp.w	r8,0
8000564e:	c0 21       	brne	80005652 <spi_write+0xc>
80005650:	5e ff       	retal	1
80005652:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005654:	78 49       	ld.w	r9,r12[0x10]
80005656:	e2 19 00 02 	andl	r9,0x2,COH
8000565a:	cf 90       	breq	8000564c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000565c:	5c 7b       	castu.h	r11
8000565e:	99 3b       	st.w	r12[0xc],r11
80005660:	5e fd       	retal	0

80005662 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005662:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005666:	c0 58       	rjmp	80005670 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005668:	58 08       	cp.w	r8,0
8000566a:	c0 21       	brne	8000566e <spi_read+0xc>
8000566c:	5e ff       	retal	1
8000566e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005670:	78 49       	ld.w	r9,r12[0x10]
80005672:	e2 19 02 01 	andl	r9,0x201,COH
80005676:	e0 49 02 01 	cp.w	r9,513
8000567a:	cf 71       	brne	80005668 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000567c:	78 28       	ld.w	r8,r12[0x8]
8000567e:	b6 08       	st.h	r11[0x0],r8
80005680:	5e fd       	retal	0
80005682:	d7 03       	nop

80005684 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005684:	eb cd 40 f8 	pushm	r3-r7,lr
80005688:	18 95       	mov	r5,r12
8000568a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000568c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005690:	30 38       	mov	r8,3
80005692:	f0 06 18 00 	cp.b	r6,r8
80005696:	e0 8b 00 5e 	brhi	80005752 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000569a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000569e:	30 18       	mov	r8,1
800056a0:	f0 04 18 00 	cp.b	r4,r8
800056a4:	e0 8b 00 57 	brhi	80005752 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800056a8:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800056ac:	30 78       	mov	r8,7
800056ae:	f0 03 18 00 	cp.b	r3,r8
800056b2:	e0 88 00 50 	brls	80005752 <spi_setupChipReg+0xce>
800056b6:	31 08       	mov	r8,16
800056b8:	f0 03 18 00 	cp.b	r3,r8
800056bc:	e0 8b 00 4b 	brhi	80005752 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800056c0:	14 9b       	mov	r11,r10
800056c2:	6e 1c       	ld.w	r12,r7[0x4]
800056c4:	f0 1f 00 26 	mcall	8000575c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800056c8:	c4 55       	brlt	80005752 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800056ca:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800056cc:	ec 09 16 01 	lsr	r9,r6,0x1
800056d0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800056d4:	ec 16 00 01 	eorl	r6,0x1
800056d8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800056dc:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800056e0:	20 83       	sub	r3,8
800056e2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800056e6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800056ea:	ef 39 00 09 	ld.ub	r9,r7[9]
800056ee:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800056f2:	ef 39 00 0a 	ld.ub	r9,r7[10]
800056f6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800056fa:	0f 89       	ld.ub	r9,r7[0x0]
800056fc:	30 1a       	mov	r10,1
800056fe:	f4 09 18 00 	cp.b	r9,r10
80005702:	c0 d0       	breq	8000571c <spi_setupChipReg+0x98>
80005704:	c0 a3       	brcs	80005718 <spi_setupChipReg+0x94>
80005706:	30 2a       	mov	r10,2
80005708:	f4 09 18 00 	cp.b	r9,r10
8000570c:	c0 a0       	breq	80005720 <spi_setupChipReg+0x9c>
8000570e:	30 3a       	mov	r10,3
80005710:	f4 09 18 00 	cp.b	r9,r10
80005714:	c1 f1       	brne	80005752 <spi_setupChipReg+0xce>
80005716:	c0 78       	rjmp	80005724 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005718:	8b c8       	st.w	r5[0x30],r8
		break;
8000571a:	c0 68       	rjmp	80005726 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000571c:	8b d8       	st.w	r5[0x34],r8
		break;
8000571e:	c0 48       	rjmp	80005726 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005720:	8b e8       	st.w	r5[0x38],r8
		break;
80005722:	c0 28       	rjmp	80005726 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005724:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005726:	48 f8       	lddpc	r8,80005760 <spi_setupChipReg+0xdc>
80005728:	70 08       	ld.w	r8,r8[0x0]
8000572a:	58 08       	cp.w	r8,0
8000572c:	c1 61       	brne	80005758 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000572e:	30 0b       	mov	r11,0
80005730:	30 1c       	mov	r12,1
80005732:	f0 1f 00 0d 	mcall	80005764 <spi_setupChipReg+0xe0>
80005736:	48 b8       	lddpc	r8,80005760 <spi_setupChipReg+0xdc>
80005738:	91 0c       	st.w	r8[0x0],r12
8000573a:	58 0c       	cp.w	r12,0
8000573c:	c0 a0       	breq	80005750 <spi_setupChipReg+0xcc>
8000573e:	30 09       	mov	r9,0
80005740:	12 9a       	mov	r10,r9
80005742:	12 9b       	mov	r11,r9
80005744:	f0 1f 00 09 	mcall	80005768 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005748:	48 68       	lddpc	r8,80005760 <spi_setupChipReg+0xdc>
8000574a:	70 08       	ld.w	r8,r8[0x0]
8000574c:	58 08       	cp.w	r8,0
8000574e:	c0 51       	brne	80005758 <spi_setupChipReg+0xd4>
80005750:	c0 08       	rjmp	80005750 <spi_setupChipReg+0xcc>
80005752:	30 2c       	mov	r12,2
80005754:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005758:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	55 bc       	stdsp	sp[0x16c],r12
80005760:	00 00       	add	r0,r0
80005762:	5b 5c       	cp.w	r12,-11
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	62 50       	ld.w	r0,r1[0x14]
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	61 50       	ld.w	r0,r0[0x54]

8000576c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000576c:	d4 01       	pushm	lr
8000576e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005772:	c0 58       	rjmp	8000577c <spi_unselectChip+0x10>
		if (!timeout--) {
80005774:	58 08       	cp.w	r8,0
80005776:	c0 21       	brne	8000577a <spi_unselectChip+0xe>
80005778:	da 0a       	popm	pc,r12=1
8000577a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000577c:	78 49       	ld.w	r9,r12[0x10]
8000577e:	e2 19 02 00 	andl	r9,0x200,COH
80005782:	cf 90       	breq	80005774 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005784:	78 18       	ld.w	r8,r12[0x4]
80005786:	ea 18 00 0f 	orh	r8,0xf
8000578a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000578c:	fc 18 01 00 	movh	r8,0x100
80005790:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005792:	30 09       	mov	r9,0
80005794:	12 9a       	mov	r10,r9
80005796:	12 9b       	mov	r11,r9
80005798:	48 38       	lddpc	r8,800057a4 <spi_unselectChip+0x38>
8000579a:	70 0c       	ld.w	r12,r8[0x0]
8000579c:	f0 1f 00 03 	mcall	800057a8 <spi_unselectChip+0x3c>
800057a0:	d8 0a       	popm	pc,r12=0
800057a2:	00 00       	add	r0,r0
800057a4:	00 00       	add	r0,r0
800057a6:	5b 5c       	cp.w	r12,-11
800057a8:	80 00       	ld.sh	r0,r0[0x0]
800057aa:	61 50       	ld.w	r0,r0[0x54]

800057ac <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800057ac:	eb cd 40 f8 	pushm	r3-r7,lr
800057b0:	18 94       	mov	r4,r12
800057b2:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800057b4:	49 a6       	lddpc	r6,8000581c <spi_selectChip+0x70>
800057b6:	30 07       	mov	r7,0
800057b8:	31 45       	mov	r5,20
800057ba:	0e 99       	mov	r9,r7
800057bc:	0a 9a       	mov	r10,r5
800057be:	0e 9b       	mov	r11,r7
800057c0:	6c 0c       	ld.w	r12,r6[0x0]
800057c2:	f0 1f 00 18 	mcall	80005820 <spi_selectChip+0x74>
800057c6:	cf a0       	breq	800057ba <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800057c8:	68 18       	ld.w	r8,r4[0x4]
800057ca:	ea 18 00 0f 	orh	r8,0xf
800057ce:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800057d0:	68 18       	ld.w	r8,r4[0x4]
800057d2:	e2 18 00 04 	andl	r8,0x4,COH
800057d6:	c1 10       	breq	800057f8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800057d8:	30 e8       	mov	r8,14
800057da:	f0 03 18 00 	cp.b	r3,r8
800057de:	e0 8b 00 1c 	brhi	80005816 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800057e2:	68 19       	ld.w	r9,r4[0x4]
800057e4:	e6 08 15 10 	lsl	r8,r3,0x10
800057e8:	ea 18 ff f0 	orh	r8,0xfff0
800057ec:	e8 18 ff ff 	orl	r8,0xffff
800057f0:	12 68       	and	r8,r9
800057f2:	89 18       	st.w	r4[0x4],r8
800057f4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800057f8:	30 38       	mov	r8,3
800057fa:	f0 03 18 00 	cp.b	r3,r8
800057fe:	e0 8b 00 0c 	brhi	80005816 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005802:	68 19       	ld.w	r9,r4[0x4]
80005804:	2f 03       	sub	r3,-16
80005806:	30 18       	mov	r8,1
80005808:	f0 03 09 48 	lsl	r8,r8,r3
8000580c:	5c d8       	com	r8
8000580e:	12 68       	and	r8,r9
80005810:	89 18       	st.w	r4[0x4],r8
80005812:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005816:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005818:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000581c:	00 00       	add	r0,r0
8000581e:	5b 5c       	cp.w	r12,-11
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	5f 44       	srge	r4

80005824 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005824:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005826:	f6 08 15 04 	lsl	r8,r11,0x4
8000582a:	14 38       	cp.w	r8,r10
8000582c:	f9 b8 08 10 	movls	r8,16
80005830:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005834:	f0 0b 02 4b 	mul	r11,r8,r11
80005838:	f6 09 16 01 	lsr	r9,r11,0x1
8000583c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005840:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005844:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005848:	f2 cb 00 01 	sub	r11,r9,1
8000584c:	e0 4b ff fe 	cp.w	r11,65534
80005850:	e0 88 00 03 	brls	80005856 <usart_set_async_baudrate+0x32>
80005854:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005856:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005858:	e8 6e 00 00 	mov	lr,524288
8000585c:	59 08       	cp.w	r8,16
8000585e:	fc 08 17 10 	movne	r8,lr
80005862:	f9 b8 00 00 	moveq	r8,0
80005866:	e4 1b ff f7 	andh	r11,0xfff7
8000586a:	e0 1b fe cf 	andl	r11,0xfecf
8000586e:	16 48       	or	r8,r11
80005870:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005872:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005876:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000587a:	99 89       	st.w	r12[0x20],r9
8000587c:	d8 0a       	popm	pc,r12=0

8000587e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000587e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005880:	e2 18 00 02 	andl	r8,0x2,COH
80005884:	c0 31       	brne	8000588a <usart_write_char+0xc>
80005886:	30 2c       	mov	r12,2
80005888:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000588a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000588e:	99 7b       	st.w	r12[0x1c],r11
80005890:	5e fd       	retal	0
80005892:	d7 03       	nop

80005894 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005894:	eb cd 40 e0 	pushm	r5-r7,lr
80005898:	18 96       	mov	r6,r12
8000589a:	16 95       	mov	r5,r11
8000589c:	e0 67 27 0f 	mov	r7,9999
800058a0:	c0 68       	rjmp	800058ac <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800058a2:	58 07       	cp.w	r7,0
800058a4:	c0 31       	brne	800058aa <usart_putchar+0x16>
800058a6:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800058aa:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800058ac:	0a 9b       	mov	r11,r5
800058ae:	0c 9c       	mov	r12,r6
800058b0:	f0 1f 00 03 	mcall	800058bc <usart_putchar+0x28>
800058b4:	cf 71       	brne	800058a2 <usart_putchar+0xe>

  return USART_SUCCESS;
}
800058b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800058ba:	00 00       	add	r0,r0
800058bc:	80 00       	ld.sh	r0,r0[0x0]
800058be:	58 7e       	cp.w	lr,7

800058c0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800058c0:	78 58       	ld.w	r8,r12[0x14]
800058c2:	e2 18 00 e0 	andl	r8,0xe0,COH
800058c6:	c0 30       	breq	800058cc <usart_read_char+0xc>
800058c8:	30 4c       	mov	r12,4
800058ca:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800058cc:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800058ce:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800058d2:	c0 31       	brne	800058d8 <usart_read_char+0x18>
800058d4:	30 3c       	mov	r12,3
800058d6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800058d8:	78 68       	ld.w	r8,r12[0x18]
800058da:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800058de:	97 08       	st.w	r11[0x0],r8
800058e0:	5e fd       	retal	0
800058e2:	d7 03       	nop

800058e4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800058e4:	eb cd 40 c0 	pushm	r6-r7,lr
800058e8:	20 1d       	sub	sp,4
800058ea:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800058ec:	1a 97       	mov	r7,sp
800058ee:	1a 9b       	mov	r11,sp
800058f0:	0c 9c       	mov	r12,r6
800058f2:	f0 1f 00 07 	mcall	8000590c <usart_getchar+0x28>
800058f6:	58 3c       	cp.w	r12,3
800058f8:	cf b0       	breq	800058ee <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800058fa:	58 4c       	cp.w	r12,4
800058fc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005900:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005904:	2f fd       	sub	sp,-4
80005906:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000590a:	00 00       	add	r0,r0
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	58 c0       	cp.w	r0,12

80005910 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005910:	eb cd 40 c0 	pushm	r6-r7,lr
80005914:	18 96       	mov	r6,r12
80005916:	16 97       	mov	r7,r11
  while (*string != '\0')
80005918:	17 8b       	ld.ub	r11,r11[0x0]
8000591a:	58 0b       	cp.w	r11,0
8000591c:	c0 80       	breq	8000592c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000591e:	2f f7       	sub	r7,-1
80005920:	0c 9c       	mov	r12,r6
80005922:	f0 1f 00 04 	mcall	80005930 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005926:	0f 8b       	ld.ub	r11,r7[0x0]
80005928:	58 0b       	cp.w	r11,0
8000592a:	cf a1       	brne	8000591e <usart_write_line+0xe>
8000592c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005930:	80 00       	ld.sh	r0,r0[0x0]
80005932:	58 94       	cp.w	r4,9

80005934 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005934:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005938:	e6 18 00 01 	andh	r8,0x1,COH
8000593c:	c0 71       	brne	8000594a <usart_reset+0x16>
8000593e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005940:	3f f8       	mov	r8,-1
80005942:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005944:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005946:	d5 03       	csrf	0x10
80005948:	c0 48       	rjmp	80005950 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000594a:	3f f8       	mov	r8,-1
8000594c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000594e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005950:	30 08       	mov	r8,0
80005952:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005954:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005956:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005958:	ea 68 61 0c 	mov	r8,680204
8000595c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000595e:	5e fc       	retal	r12

80005960 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005960:	eb cd 40 e0 	pushm	r5-r7,lr
80005964:	18 96       	mov	r6,r12
80005966:	16 97       	mov	r7,r11
80005968:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000596a:	f0 1f 00 2f 	mcall	80005a24 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000596e:	58 07       	cp.w	r7,0
80005970:	c5 80       	breq	80005a20 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005972:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005974:	30 49       	mov	r9,4
80005976:	f2 08 18 00 	cp.b	r8,r9
8000597a:	e0 88 00 53 	brls	80005a20 <usart_init_rs232+0xc0>
8000597e:	30 99       	mov	r9,9
80005980:	f2 08 18 00 	cp.b	r8,r9
80005984:	e0 8b 00 4e 	brhi	80005a20 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005988:	0f d9       	ld.ub	r9,r7[0x5]
8000598a:	30 78       	mov	r8,7
8000598c:	f0 09 18 00 	cp.b	r9,r8
80005990:	e0 8b 00 48 	brhi	80005a20 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005994:	8e 39       	ld.sh	r9,r7[0x6]
80005996:	e0 68 01 01 	mov	r8,257
8000599a:	f0 09 19 00 	cp.h	r9,r8
8000599e:	e0 8b 00 41 	brhi	80005a20 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800059a2:	ef 39 00 08 	ld.ub	r9,r7[8]
800059a6:	30 38       	mov	r8,3
800059a8:	f0 09 18 00 	cp.b	r9,r8
800059ac:	e0 8b 00 3a 	brhi	80005a20 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800059b0:	0a 9a       	mov	r10,r5
800059b2:	6e 0b       	ld.w	r11,r7[0x0]
800059b4:	0c 9c       	mov	r12,r6
800059b6:	f0 1f 00 1d 	mcall	80005a28 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800059ba:	58 1c       	cp.w	r12,1
800059bc:	c3 20       	breq	80005a20 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800059be:	0f c8       	ld.ub	r8,r7[0x4]
800059c0:	30 99       	mov	r9,9
800059c2:	f2 08 18 00 	cp.b	r8,r9
800059c6:	c0 51       	brne	800059d0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800059c8:	6c 18       	ld.w	r8,r6[0x4]
800059ca:	b1 b8       	sbr	r8,0x11
800059cc:	8d 18       	st.w	r6[0x4],r8
800059ce:	c0 68       	rjmp	800059da <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800059d0:	6c 19       	ld.w	r9,r6[0x4]
800059d2:	20 58       	sub	r8,5
800059d4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800059d8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800059da:	6c 19       	ld.w	r9,r6[0x4]
800059dc:	ef 3a 00 08 	ld.ub	r10,r7[8]
800059e0:	0f d8       	ld.ub	r8,r7[0x5]
800059e2:	a9 78       	lsl	r8,0x9
800059e4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800059e8:	12 48       	or	r8,r9
800059ea:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800059ec:	8e 38       	ld.sh	r8,r7[0x6]
800059ee:	30 29       	mov	r9,2
800059f0:	f2 08 19 00 	cp.h	r8,r9
800059f4:	e0 88 00 09 	brls	80005a06 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800059f8:	6c 18       	ld.w	r8,r6[0x4]
800059fa:	ad b8       	sbr	r8,0xd
800059fc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800059fe:	8e b8       	ld.uh	r8,r7[0x6]
80005a00:	20 28       	sub	r8,2
80005a02:	8d a8       	st.w	r6[0x28],r8
80005a04:	c0 68       	rjmp	80005a10 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005a06:	6c 19       	ld.w	r9,r6[0x4]
80005a08:	5c 78       	castu.h	r8
80005a0a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005a0e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005a10:	6c 18       	ld.w	r8,r6[0x4]
80005a12:	e0 18 ff f0 	andl	r8,0xfff0
80005a16:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005a18:	35 08       	mov	r8,80
80005a1a:	8d 08       	st.w	r6[0x0],r8
80005a1c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005a20:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005a24:	80 00       	ld.sh	r0,r0[0x0]
80005a26:	59 34       	cp.w	r4,19
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	58 24       	cp.w	r4,2

80005a2c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005a2c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005a30:	fe c0 8e 30 	sub	r0,pc,-29136

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005a34:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005a38:	d5 53       	csrf	0x15
  cp      r0, r1
80005a3a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005a3c:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005a40:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005a42:	c0 62       	brcc	80005a4e <idata_load_loop_end>
  cp      r0, r1
80005a44:	48 92       	lddpc	r2,80005a68 <udata_clear_loop_end+0x4>

80005a46 <idata_load_loop>:
  brlo    idata_load_loop
80005a46:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005a48:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005a4a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005a4c:	cf d3       	brcs	80005a46 <idata_load_loop>

80005a4e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005a4e:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005a52:	e0 61 5b 70 	mov	r1,23408
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005a56:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005a58:	c0 62       	brcc	80005a64 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005a5a:	30 02       	mov	r2,0
80005a5c:	30 03       	mov	r3,0

80005a5e <udata_clear_loop>:
80005a5e:	a1 22       	st.d	r0++,r2
80005a60:	02 30       	cp.w	r0,r1
80005a62:	cf e3       	brcs	80005a5e <udata_clear_loop>

80005a64 <udata_clear_loop_end>:
80005a64:	fe cf e9 80 	sub	pc,pc,-5760
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	e0 50 f8 c8 	cp.w	r0,129224

80005a6c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005a6c:	f8 c8 ff f8 	sub	r8,r12,-8
80005a70:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005a72:	3f f9       	mov	r9,-1
80005a74:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005a76:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005a78:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005a7a:	30 08       	mov	r8,0
80005a7c:	99 08       	st.w	r12[0x0],r8
}
80005a7e:	5e fc       	retal	r12

80005a80 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005a80:	30 08       	mov	r8,0
80005a82:	99 48       	st.w	r12[0x10],r8
}
80005a84:	5e fc       	retal	r12

80005a86 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005a86:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005a88:	70 19       	ld.w	r9,r8[0x4]
80005a8a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005a8c:	78 19       	ld.w	r9,r12[0x4]
80005a8e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005a90:	70 19       	ld.w	r9,r8[0x4]
80005a92:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005a94:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005a96:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005a98:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005a9a:	78 08       	ld.w	r8,r12[0x0]
80005a9c:	2f f8       	sub	r8,-1
80005a9e:	99 08       	st.w	r12[0x0],r8
}
80005aa0:	5e fc       	retal	r12

80005aa2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005aa2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005aa4:	5b fa       	cp.w	r10,-1
80005aa6:	c0 31       	brne	80005aac <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005aa8:	78 48       	ld.w	r8,r12[0x10]
80005aaa:	c0 c8       	rjmp	80005ac2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005aac:	f8 c8 ff f8 	sub	r8,r12,-8
80005ab0:	70 19       	ld.w	r9,r8[0x4]
80005ab2:	72 09       	ld.w	r9,r9[0x0]
80005ab4:	12 3a       	cp.w	r10,r9
80005ab6:	c0 63       	brcs	80005ac2 <vListInsert+0x20>
80005ab8:	70 18       	ld.w	r8,r8[0x4]
80005aba:	70 19       	ld.w	r9,r8[0x4]
80005abc:	72 09       	ld.w	r9,r9[0x0]
80005abe:	12 3a       	cp.w	r10,r9
80005ac0:	cf c2       	brcc	80005ab8 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005ac2:	70 19       	ld.w	r9,r8[0x4]
80005ac4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005ac6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005ac8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005aca:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005acc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005ace:	78 08       	ld.w	r8,r12[0x0]
80005ad0:	2f f8       	sub	r8,-1
80005ad2:	99 08       	st.w	r12[0x0],r8
}
80005ad4:	5e fc       	retal	r12

80005ad6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005ad6:	78 18       	ld.w	r8,r12[0x4]
80005ad8:	78 29       	ld.w	r9,r12[0x8]
80005ada:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005adc:	78 28       	ld.w	r8,r12[0x8]
80005ade:	78 19       	ld.w	r9,r12[0x4]
80005ae0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005ae2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005ae4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005ae6:	18 39       	cp.w	r9,r12
80005ae8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005aec:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005af0:	30 09       	mov	r9,0
80005af2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005af4:	70 09       	ld.w	r9,r8[0x0]
80005af6:	20 19       	sub	r9,1
80005af8:	91 09       	st.w	r8[0x0],r9
}
80005afa:	5e fc       	retal	r12

80005afc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005afc:	e0 68 08 08 	mov	r8,2056
80005b00:	ea 18 08 08 	orh	r8,0x808
80005b04:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005b06:	e0 68 09 09 	mov	r8,2313
80005b0a:	ea 18 09 09 	orh	r8,0x909
80005b0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005b10:	e0 68 0a 0a 	mov	r8,2570
80005b14:	ea 18 0a 0a 	orh	r8,0xa0a
80005b18:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005b1a:	e0 68 0b 0b 	mov	r8,2827
80005b1e:	ea 18 0b 0b 	orh	r8,0xb0b
80005b22:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005b24:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005b26:	e0 68 be ef 	mov	r8,48879
80005b2a:	ea 18 de ad 	orh	r8,0xdead
80005b2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005b30:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005b32:	fc 18 00 40 	movh	r8,0x40
80005b36:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005b38:	e0 68 00 ff 	mov	r8,255
80005b3c:	ea 18 ff 00 	orh	r8,0xff00
80005b40:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005b42:	e0 68 01 01 	mov	r8,257
80005b46:	ea 18 01 01 	orh	r8,0x101
80005b4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005b4c:	e0 68 02 02 	mov	r8,514
80005b50:	ea 18 02 02 	orh	r8,0x202
80005b54:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005b56:	e0 68 03 03 	mov	r8,771
80005b5a:	ea 18 03 03 	orh	r8,0x303
80005b5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005b60:	e0 68 04 04 	mov	r8,1028
80005b64:	ea 18 04 04 	orh	r8,0x404
80005b68:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005b6a:	e0 68 05 05 	mov	r8,1285
80005b6e:	ea 18 05 05 	orh	r8,0x505
80005b72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005b74:	e0 68 06 06 	mov	r8,1542
80005b78:	ea 18 06 06 	orh	r8,0x606
80005b7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005b7e:	e0 68 07 07 	mov	r8,1799
80005b82:	ea 18 07 07 	orh	r8,0x707
80005b86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005b88:	30 08       	mov	r8,0
80005b8a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005b8c:	5e fc       	retal	r12
80005b8e:	d7 03       	nop

80005b90 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005b90:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005b92:	48 38       	lddpc	r8,80005b9c <vPortEnterCritical+0xc>
80005b94:	70 09       	ld.w	r9,r8[0x0]
80005b96:	2f f9       	sub	r9,-1
80005b98:	91 09       	st.w	r8[0x0],r9
}
80005b9a:	5e fc       	retal	r12
80005b9c:	00 00       	add	r0,r0
80005b9e:	05 34       	ld.ub	r4,r2++

80005ba0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005ba0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005ba2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005ba4:	30 0a       	mov	r10,0
80005ba6:	14 9b       	mov	r11,r10
80005ba8:	49 2c       	lddpc	r12,80005bf0 <xPortStartScheduler+0x50>
80005baa:	f0 1f 00 13 	mcall	80005bf4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005bae:	e0 68 5d c0 	mov	r8,24000
80005bb2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005bb6:	30 08       	mov	r8,0
80005bb8:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005bbc:	e0 68 0c ec 	mov	r8,3308
80005bc0:	ea 18 00 00 	orh	r8,0x0
80005bc4:	70 00       	ld.w	r0,r8[0x0]
80005bc6:	60 0d       	ld.w	sp,r0[0x0]
80005bc8:	1b 00       	ld.w	r0,sp++
80005bca:	e0 68 05 34 	mov	r8,1332
80005bce:	ea 18 00 00 	orh	r8,0x0
80005bd2:	91 00       	st.w	r8[0x0],r0
80005bd4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005bd8:	2f ed       	sub	sp,-8
80005bda:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005bde:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005be2:	e3 b0 00 00 	mtsr	0x0,r0
80005be6:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005bea:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005bee:	d8 0a       	popm	pc,r12=0
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	5c bc       	swap.b	r12
80005bf4:	80 00       	ld.sh	r0,r0[0x0]
80005bf6:	53 60       	stdsp	sp[0xd8],r0

80005bf8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005bf8:	20 6d       	sub	sp,24
80005bfa:	eb cd 00 ff 	pushm	r0-r7
80005bfe:	fa c7 ff c0 	sub	r7,sp,-64
80005c02:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005c06:	ef 40 ff e0 	st.w	r7[-32],r0
80005c0a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005c0e:	ef 40 ff e4 	st.w	r7[-28],r0
80005c12:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005c16:	e0 68 05 34 	mov	r8,1332
80005c1a:	ea 18 00 00 	orh	r8,0x0
80005c1e:	70 00       	ld.w	r0,r8[0x0]
80005c20:	1a d0       	st.w	--sp,r0
80005c22:	f0 1f 00 1a 	mcall	80005c88 <LABEL_RET_SCALL_263+0x14>
80005c26:	e0 68 0c ec 	mov	r8,3308
80005c2a:	ea 18 00 00 	orh	r8,0x0
80005c2e:	70 00       	ld.w	r0,r8[0x0]
80005c30:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005c32:	f0 1f 00 17 	mcall	80005c8c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005c36:	e0 68 0c ec 	mov	r8,3308
80005c3a:	ea 18 00 00 	orh	r8,0x0
80005c3e:	70 00       	ld.w	r0,r8[0x0]
80005c40:	60 0d       	ld.w	sp,r0[0x0]
80005c42:	1b 00       	ld.w	r0,sp++
80005c44:	e0 68 05 34 	mov	r8,1332
80005c48:	ea 18 00 00 	orh	r8,0x0
80005c4c:	91 00       	st.w	r8[0x0],r0
80005c4e:	fa c7 ff d8 	sub	r7,sp,-40
80005c52:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005c56:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005c5a:	e0 61 05 34 	mov	r1,1332
80005c5e:	ea 11 00 00 	orh	r1,0x0
80005c62:	62 02       	ld.w	r2,r1[0x0]
80005c64:	58 02       	cp.w	r2,0
80005c66:	c0 70       	breq	80005c74 <LABEL_RET_SCALL_263>
80005c68:	e4 c2 00 01 	sub	r2,r2,1
80005c6c:	83 02       	st.w	r1[0x0],r2
80005c6e:	58 02       	cp.w	r2,0
80005c70:	c0 21       	brne	80005c74 <LABEL_RET_SCALL_263>
80005c72:	b1 c0       	cbr	r0,0x10

80005c74 <LABEL_RET_SCALL_263>:
80005c74:	ef 40 ff f8 	st.w	r7[-8],r0
80005c78:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005c7c:	ef 40 ff fc 	st.w	r7[-4],r0
80005c80:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c84:	2f ad       	sub	sp,-24
80005c86:	d6 13       	rets
80005c88:	80 00       	ld.sh	r0,r0[0x0]
80005c8a:	5b 90       	cp.w	r0,-7
80005c8c:	80 00       	ld.sh	r0,r0[0x0]
80005c8e:	62 d4       	ld.w	r4,r1[0x34]

80005c90 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005c90:	e1 b8 00 43 	mfsr	r8,0x10c
80005c94:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005c98:	5e fc       	retal	r12
80005c9a:	d7 03       	nop

80005c9c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005c9c:	48 78       	lddpc	r8,80005cb8 <vPortExitCritical+0x1c>
80005c9e:	70 08       	ld.w	r8,r8[0x0]
80005ca0:	58 08       	cp.w	r8,0
80005ca2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005ca4:	48 58       	lddpc	r8,80005cb8 <vPortExitCritical+0x1c>
80005ca6:	70 09       	ld.w	r9,r8[0x0]
80005ca8:	20 19       	sub	r9,1
80005caa:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005cac:	70 08       	ld.w	r8,r8[0x0]
80005cae:	58 08       	cp.w	r8,0
80005cb0:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005cb2:	d5 03       	csrf	0x10
80005cb4:	5e fc       	retal	r12
80005cb6:	00 00       	add	r0,r0
80005cb8:	00 00       	add	r0,r0
80005cba:	05 34       	ld.ub	r4,r2++

80005cbc <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005cbc:	eb cd 00 ff 	pushm	r0-r7
80005cc0:	e0 68 05 34 	mov	r8,1332
80005cc4:	ea 18 00 00 	orh	r8,0x0
80005cc8:	70 00       	ld.w	r0,r8[0x0]
80005cca:	1a d0       	st.w	--sp,r0
80005ccc:	7a 90       	ld.w	r0,sp[0x24]
80005cce:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005cd2:	58 10       	cp.w	r0,1
80005cd4:	e0 8b 00 08 	brhi	80005ce4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005cd8:	e0 68 0c ec 	mov	r8,3308
80005cdc:	ea 18 00 00 	orh	r8,0x0
80005ce0:	70 00       	ld.w	r0,r8[0x0]
80005ce2:	81 0d       	st.w	r0[0x0],sp

80005ce4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005ce4:	f0 1f 00 12 	mcall	80005d2c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005ce8:	f0 1f 00 12 	mcall	80005d30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005cec:	f0 1f 00 12 	mcall	80005d34 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005cf0:	f0 1f 00 12 	mcall	80005d38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005cf4:	7a 90       	ld.w	r0,sp[0x24]
80005cf6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005cfa:	58 10       	cp.w	r0,1
80005cfc:	e0 8b 00 0e 	brhi	80005d18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005d00:	f0 1f 00 0c 	mcall	80005d30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005d04:	f0 1f 00 0e 	mcall	80005d3c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005d08:	f0 1f 00 0c 	mcall	80005d38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005d0c:	e0 68 0c ec 	mov	r8,3308
80005d10:	ea 18 00 00 	orh	r8,0x0
80005d14:	70 00       	ld.w	r0,r8[0x0]
80005d16:	60 0d       	ld.w	sp,r0[0x0]

80005d18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005d18:	1b 00       	ld.w	r0,sp++
80005d1a:	e0 68 05 34 	mov	r8,1332
80005d1e:	ea 18 00 00 	orh	r8,0x0
80005d22:	91 00       	st.w	r8[0x0],r0
80005d24:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d28:	d6 03       	rete
80005d2a:	00 00       	add	r0,r0
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	5c 90       	brev	r0
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	5b 90       	cp.w	r0,-7
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	64 d8       	ld.w	r8,r2[0x34]
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	5c 9c       	brev	r12
80005d3c:	80 00       	ld.sh	r0,r0[0x0]
80005d3e:	62 d4       	ld.w	r4,r1[0x34]

80005d40 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005d40:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005d42:	f0 1f 00 02 	mcall	80005d48 <__malloc_lock+0x8>
}
80005d46:	d8 02       	popm	pc
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	62 c4       	ld.w	r4,r1[0x30]

80005d4c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005d4c:	d4 01       	pushm	lr
	xTaskResumeAll();
80005d4e:	f0 1f 00 02 	mcall	80005d54 <__malloc_unlock+0x8>
}
80005d52:	d8 02       	popm	pc
80005d54:	80 00       	ld.sh	r0,r0[0x0]
80005d56:	66 80       	ld.w	r0,r3[0x20]

80005d58 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005d58:	d4 21       	pushm	r4-r7,lr
80005d5a:	16 95       	mov	r5,r11
80005d5c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005d5e:	58 0c       	cp.w	r12,0
80005d60:	c0 30       	breq	80005d66 <_read+0xe>
80005d62:	3f f7       	mov	r7,-1
80005d64:	c1 48       	rjmp	80005d8c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005d66:	58 0a       	cp.w	r10,0
80005d68:	e0 89 00 04 	brgt	80005d70 <_read+0x18>
80005d6c:	30 07       	mov	r7,0
80005d6e:	c0 f8       	rjmp	80005d8c <_read+0x34>
80005d70:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005d72:	48 84       	lddpc	r4,80005d90 <_read+0x38>
80005d74:	68 0c       	ld.w	r12,r4[0x0]
80005d76:	f0 1f 00 08 	mcall	80005d94 <_read+0x3c>
    if (c < 0)
80005d7a:	c0 95       	brlt	80005d8c <_read+0x34>
      break;

    *ptr++ = c;
80005d7c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005d80:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005d82:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005d86:	58 08       	cp.w	r8,0
80005d88:	fe 99 ff f6 	brgt	80005d74 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005d8c:	0e 9c       	mov	r12,r7
80005d8e:	d8 22       	popm	r4-r7,pc
80005d90:	00 00       	add	r0,r0
80005d92:	5b 60       	cp.w	r0,-10
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	58 e4       	cp.w	r4,14

80005d98 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005d98:	d4 21       	pushm	r4-r7,lr
80005d9a:	16 95       	mov	r5,r11
80005d9c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005d9e:	20 1c       	sub	r12,1
80005da0:	58 2c       	cp.w	r12,2
80005da2:	e0 8b 00 12 	brhi	80005dc6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005da6:	58 0a       	cp.w	r10,0
80005da8:	c0 31       	brne	80005dae <_write+0x16>
80005daa:	30 07       	mov	r7,0
80005dac:	c0 e8       	rjmp	80005dc8 <_write+0x30>
80005dae:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005db0:	48 74       	lddpc	r4,80005dcc <_write+0x34>
80005db2:	68 0c       	ld.w	r12,r4[0x0]
80005db4:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005db8:	f0 1f 00 06 	mcall	80005dd0 <_write+0x38>
80005dbc:	c0 55       	brlt	80005dc6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005dbe:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005dc0:	0e 36       	cp.w	r6,r7
80005dc2:	cf 81       	brne	80005db2 <_write+0x1a>
80005dc4:	c0 28       	rjmp	80005dc8 <_write+0x30>
80005dc6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005dc8:	0e 9c       	mov	r12,r7
80005dca:	d8 22       	popm	r4-r7,pc
80005dcc:	00 00       	add	r0,r0
80005dce:	5b 60       	cp.w	r0,-10
80005dd0:	80 00       	ld.sh	r0,r0[0x0]
80005dd2:	58 94       	cp.w	r4,9

80005dd4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005dd4:	eb cd 40 80 	pushm	r7,lr
80005dd8:	18 97       	mov	r7,r12
	if( pv )
80005dda:	58 0c       	cp.w	r12,0
80005ddc:	c0 80       	breq	80005dec <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005dde:	f0 1f 00 05 	mcall	80005df0 <vPortFree+0x1c>
		{
			free( pv );
80005de2:	0e 9c       	mov	r12,r7
80005de4:	f0 1f 00 04 	mcall	80005df4 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005de8:	f0 1f 00 04 	mcall	80005df8 <vPortFree+0x24>
80005dec:	e3 cd 80 80 	ldm	sp++,r7,pc
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	62 c4       	ld.w	r4,r1[0x30]
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	71 54       	ld.w	r4,r8[0x54]
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	66 80       	ld.w	r0,r3[0x20]

80005dfc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005dfc:	eb cd 40 80 	pushm	r7,lr
80005e00:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005e02:	f0 1f 00 06 	mcall	80005e18 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005e06:	0e 9c       	mov	r12,r7
80005e08:	f0 1f 00 05 	mcall	80005e1c <pvPortMalloc+0x20>
80005e0c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005e0e:	f0 1f 00 05 	mcall	80005e20 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005e12:	0e 9c       	mov	r12,r7
80005e14:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	62 c4       	ld.w	r4,r1[0x30]
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	71 64       	ld.w	r4,r8[0x58]
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	66 80       	ld.w	r0,r3[0x20]

80005e24 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005e24:	d4 01       	pushm	lr
80005e26:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005e28:	78 09       	ld.w	r9,r12[0x0]
80005e2a:	58 09       	cp.w	r9,0
80005e2c:	c1 10       	breq	80005e4e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005e2e:	78 3a       	ld.w	r10,r12[0xc]
80005e30:	79 09       	ld.w	r9,r12[0x40]
80005e32:	f4 09 00 09 	add	r9,r10,r9
80005e36:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005e38:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005e3a:	14 39       	cp.w	r9,r10
80005e3c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005e40:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005e44:	79 0a       	ld.w	r10,r12[0x40]
80005e46:	78 3b       	ld.w	r11,r12[0xc]
80005e48:	10 9c       	mov	r12,r8
80005e4a:	f0 1f 00 02 	mcall	80005e50 <prvCopyDataFromQueue+0x2c>
80005e4e:	d8 02       	popm	pc
80005e50:	80 00       	ld.sh	r0,r0[0x0]
80005e52:	75 ac       	ld.w	r12,r10[0x68]

80005e54 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005e54:	eb cd 40 c0 	pushm	r6-r7,lr
80005e58:	18 97       	mov	r7,r12
80005e5a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005e5c:	78 e8       	ld.w	r8,r12[0x38]
80005e5e:	58 08       	cp.w	r8,0
80005e60:	c0 31       	brne	80005e66 <xQueueReceiveFromISR+0x12>
80005e62:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005e66:	f0 1f 00 0e 	mcall	80005e9c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005e6a:	6e e8       	ld.w	r8,r7[0x38]
80005e6c:	20 18       	sub	r8,1
80005e6e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005e70:	6f 18       	ld.w	r8,r7[0x44]
80005e72:	5b f8       	cp.w	r8,-1
80005e74:	c0 d1       	brne	80005e8e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005e76:	6e 48       	ld.w	r8,r7[0x10]
80005e78:	58 08       	cp.w	r8,0
80005e7a:	c0 f0       	breq	80005e98 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005e7c:	ee cc ff f0 	sub	r12,r7,-16
80005e80:	f0 1f 00 08 	mcall	80005ea0 <xQueueReceiveFromISR+0x4c>
80005e84:	c0 a0       	breq	80005e98 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005e86:	30 1c       	mov	r12,1
80005e88:	8d 0c       	st.w	r6[0x0],r12
80005e8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005e8e:	2f f8       	sub	r8,-1
80005e90:	ef 48 00 44 	st.w	r7[68],r8
80005e94:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e98:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	5e 24       	reths	r4
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	64 5c       	ld.w	r12,r2[0x14]

80005ea4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005ea4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ea8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005eaa:	f0 1f 00 23 	mcall	80005f34 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005eae:	6f 28       	ld.w	r8,r7[0x48]
80005eb0:	58 08       	cp.w	r8,0
80005eb2:	e0 8a 00 18 	brle	80005ee2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005eb6:	6e 98       	ld.w	r8,r7[0x24]
80005eb8:	58 08       	cp.w	r8,0
80005eba:	c1 40       	breq	80005ee2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ebc:	ee c6 ff dc 	sub	r6,r7,-36
80005ec0:	c0 48       	rjmp	80005ec8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ec2:	6e 98       	ld.w	r8,r7[0x24]
80005ec4:	58 08       	cp.w	r8,0
80005ec6:	c0 e0       	breq	80005ee2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ec8:	0c 9c       	mov	r12,r6
80005eca:	f0 1f 00 1c 	mcall	80005f38 <prvUnlockQueue+0x94>
80005ece:	c0 30       	breq	80005ed4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005ed0:	f0 1f 00 1b 	mcall	80005f3c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005ed4:	6f 28       	ld.w	r8,r7[0x48]
80005ed6:	20 18       	sub	r8,1
80005ed8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005edc:	58 08       	cp.w	r8,0
80005ede:	fe 99 ff f2 	brgt	80005ec2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005ee2:	3f f8       	mov	r8,-1
80005ee4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005ee8:	f0 1f 00 16 	mcall	80005f40 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005eec:	f0 1f 00 12 	mcall	80005f34 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005ef0:	6f 18       	ld.w	r8,r7[0x44]
80005ef2:	58 08       	cp.w	r8,0
80005ef4:	e0 8a 00 18 	brle	80005f24 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005ef8:	6e 48       	ld.w	r8,r7[0x10]
80005efa:	58 08       	cp.w	r8,0
80005efc:	c1 40       	breq	80005f24 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005efe:	ee c6 ff f0 	sub	r6,r7,-16
80005f02:	c0 48       	rjmp	80005f0a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f04:	6e 48       	ld.w	r8,r7[0x10]
80005f06:	58 08       	cp.w	r8,0
80005f08:	c0 e0       	breq	80005f24 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f0a:	0c 9c       	mov	r12,r6
80005f0c:	f0 1f 00 0b 	mcall	80005f38 <prvUnlockQueue+0x94>
80005f10:	c0 30       	breq	80005f16 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005f12:	f0 1f 00 0b 	mcall	80005f3c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005f16:	6f 18       	ld.w	r8,r7[0x44]
80005f18:	20 18       	sub	r8,1
80005f1a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f1e:	58 08       	cp.w	r8,0
80005f20:	fe 99 ff f2 	brgt	80005f04 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005f24:	3f f8       	mov	r8,-1
80005f26:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005f2a:	f0 1f 00 06 	mcall	80005f40 <prvUnlockQueue+0x9c>
}
80005f2e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f32:	00 00       	add	r0,r0
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	5b 90       	cp.w	r0,-7
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	64 5c       	ld.w	r12,r2[0x14]
80005f3c:	80 00       	ld.sh	r0,r0[0x0]
80005f3e:	63 68       	ld.w	r8,r1[0x58]
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	5c 9c       	brev	r12

80005f44 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005f44:	d4 31       	pushm	r0-r7,lr
80005f46:	20 5d       	sub	sp,20
80005f48:	18 97       	mov	r7,r12
80005f4a:	50 0b       	stdsp	sp[0x0],r11
80005f4c:	50 2a       	stdsp	sp[0x8],r10
80005f4e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005f50:	f8 c2 ff dc 	sub	r2,r12,-36
80005f54:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005f56:	fa c4 ff f4 	sub	r4,sp,-12
80005f5a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005f5c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005f5e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005f62:	f0 1f 00 3e 	mcall	80006058 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005f66:	6e e8       	ld.w	r8,r7[0x38]
80005f68:	58 08       	cp.w	r8,0
80005f6a:	c2 a0       	breq	80005fbe <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005f6c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005f6e:	40 0b       	lddsp	r11,sp[0x0]
80005f70:	0e 9c       	mov	r12,r7
80005f72:	f0 1f 00 3b 	mcall	8000605c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005f76:	40 18       	lddsp	r8,sp[0x4]
80005f78:	58 08       	cp.w	r8,0
80005f7a:	c1 51       	brne	80005fa4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005f7c:	6e e8       	ld.w	r8,r7[0x38]
80005f7e:	20 18       	sub	r8,1
80005f80:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005f82:	6e 08       	ld.w	r8,r7[0x0]
80005f84:	58 08       	cp.w	r8,0
80005f86:	c0 41       	brne	80005f8e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005f88:	f0 1f 00 36 	mcall	80006060 <xQueueGenericReceive+0x11c>
80005f8c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f8e:	6e 48       	ld.w	r8,r7[0x10]
80005f90:	58 08       	cp.w	r8,0
80005f92:	c1 20       	breq	80005fb6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005f94:	ee cc ff f0 	sub	r12,r7,-16
80005f98:	f0 1f 00 33 	mcall	80006064 <xQueueGenericReceive+0x120>
80005f9c:	58 1c       	cp.w	r12,1
80005f9e:	c0 c1       	brne	80005fb6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005fa0:	d7 33       	scall
80005fa2:	c0 a8       	rjmp	80005fb6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005fa4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005fa6:	6e 98       	ld.w	r8,r7[0x24]
80005fa8:	58 08       	cp.w	r8,0
80005faa:	c0 60       	breq	80005fb6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005fac:	04 9c       	mov	r12,r2
80005fae:	f0 1f 00 2e 	mcall	80006064 <xQueueGenericReceive+0x120>
80005fb2:	c0 20       	breq	80005fb6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005fb4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005fb6:	f0 1f 00 2d 	mcall	80006068 <xQueueGenericReceive+0x124>
80005fba:	30 1c       	mov	r12,1
				return pdPASS;
80005fbc:	c4 c8       	rjmp	80006054 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005fbe:	40 28       	lddsp	r8,sp[0x8]
80005fc0:	58 08       	cp.w	r8,0
80005fc2:	c0 51       	brne	80005fcc <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005fc4:	f0 1f 00 29 	mcall	80006068 <xQueueGenericReceive+0x124>
80005fc8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005fca:	c4 58       	rjmp	80006054 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005fcc:	58 05       	cp.w	r5,0
80005fce:	c0 51       	brne	80005fd8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005fd0:	08 9c       	mov	r12,r4
80005fd2:	f0 1f 00 27 	mcall	8000606c <xQueueGenericReceive+0x128>
80005fd6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005fd8:	f0 1f 00 24 	mcall	80006068 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005fdc:	f0 1f 00 25 	mcall	80006070 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005fe0:	f0 1f 00 1e 	mcall	80006058 <xQueueGenericReceive+0x114>
80005fe4:	6f 18       	ld.w	r8,r7[0x44]
80005fe6:	5b f8       	cp.w	r8,-1
80005fe8:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005fec:	6f 28       	ld.w	r8,r7[0x48]
80005fee:	5b f8       	cp.w	r8,-1
80005ff0:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005ff4:	f0 1f 00 1d 	mcall	80006068 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ff8:	06 9b       	mov	r11,r3
80005ffa:	08 9c       	mov	r12,r4
80005ffc:	f0 1f 00 1e 	mcall	80006074 <xQueueGenericReceive+0x130>
80006000:	c2 41       	brne	80006048 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006002:	f0 1f 00 16 	mcall	80006058 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006006:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006008:	f0 1f 00 18 	mcall	80006068 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000600c:	58 06       	cp.w	r6,0
8000600e:	c1 71       	brne	8000603c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006010:	6e 08       	ld.w	r8,r7[0x0]
80006012:	58 08       	cp.w	r8,0
80006014:	c0 81       	brne	80006024 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006016:	f0 1f 00 11 	mcall	80006058 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000601a:	6e 1c       	ld.w	r12,r7[0x4]
8000601c:	f0 1f 00 17 	mcall	80006078 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006020:	f0 1f 00 12 	mcall	80006068 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006024:	40 2b       	lddsp	r11,sp[0x8]
80006026:	04 9c       	mov	r12,r2
80006028:	f0 1f 00 15 	mcall	8000607c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000602c:	0e 9c       	mov	r12,r7
8000602e:	f0 1f 00 15 	mcall	80006080 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006032:	f0 1f 00 15 	mcall	80006084 <xQueueGenericReceive+0x140>
80006036:	c9 61       	brne	80005f62 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006038:	d7 33       	scall
8000603a:	c9 4b       	rjmp	80005f62 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000603c:	0e 9c       	mov	r12,r7
8000603e:	f0 1f 00 11 	mcall	80006080 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006042:	f0 1f 00 11 	mcall	80006084 <xQueueGenericReceive+0x140>
80006046:	c8 eb       	rjmp	80005f62 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006048:	0e 9c       	mov	r12,r7
8000604a:	f0 1f 00 0e 	mcall	80006080 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000604e:	f0 1f 00 0e 	mcall	80006084 <xQueueGenericReceive+0x140>
80006052:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006054:	2f bd       	sub	sp,-20
80006056:	d8 32       	popm	r0-r7,pc
80006058:	80 00       	ld.sh	r0,r0[0x0]
8000605a:	5b 90       	cp.w	r0,-7
8000605c:	80 00       	ld.sh	r0,r0[0x0]
8000605e:	5e 24       	reths	r4
80006060:	80 00       	ld.sh	r0,r0[0x0]
80006062:	63 74       	ld.w	r4,r1[0x5c]
80006064:	80 00       	ld.sh	r0,r0[0x0]
80006066:	64 5c       	ld.w	r12,r2[0x14]
80006068:	80 00       	ld.sh	r0,r0[0x0]
8000606a:	5c 9c       	brev	r12
8000606c:	80 00       	ld.sh	r0,r0[0x0]
8000606e:	63 50       	ld.w	r0,r1[0x54]
80006070:	80 00       	ld.sh	r0,r0[0x0]
80006072:	62 c4       	ld.w	r4,r1[0x30]
80006074:	80 00       	ld.sh	r0,r0[0x0]
80006076:	65 ec       	ld.w	r12,r2[0x78]
80006078:	80 00       	ld.sh	r0,r0[0x0]
8000607a:	63 d8       	ld.w	r8,r1[0x74]
8000607c:	80 00       	ld.sh	r0,r0[0x0]
8000607e:	68 8c       	ld.w	r12,r4[0x20]
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	5e a4       	retle	r4
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	66 80       	ld.w	r0,r3[0x20]

80006088 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006088:	eb cd 40 80 	pushm	r7,lr
8000608c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000608e:	79 08       	ld.w	r8,r12[0x40]
80006090:	58 08       	cp.w	r8,0
80006092:	c0 a1       	brne	800060a6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006094:	78 08       	ld.w	r8,r12[0x0]
80006096:	58 08       	cp.w	r8,0
80006098:	c2 b1       	brne	800060ee <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000609a:	78 1c       	ld.w	r12,r12[0x4]
8000609c:	f0 1f 00 17 	mcall	800060f8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800060a0:	30 08       	mov	r8,0
800060a2:	8f 18       	st.w	r7[0x4],r8
800060a4:	c2 58       	rjmp	800060ee <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800060a6:	58 0a       	cp.w	r10,0
800060a8:	c1 01       	brne	800060c8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800060aa:	10 9a       	mov	r10,r8
800060ac:	78 2c       	ld.w	r12,r12[0x8]
800060ae:	f0 1f 00 14 	mcall	800060fc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800060b2:	6e 29       	ld.w	r9,r7[0x8]
800060b4:	6f 08       	ld.w	r8,r7[0x40]
800060b6:	f2 08 00 08 	add	r8,r9,r8
800060ba:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800060bc:	6e 19       	ld.w	r9,r7[0x4]
800060be:	12 38       	cp.w	r8,r9
800060c0:	c1 73       	brcs	800060ee <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800060c2:	6e 08       	ld.w	r8,r7[0x0]
800060c4:	8f 28       	st.w	r7[0x8],r8
800060c6:	c1 48       	rjmp	800060ee <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800060c8:	10 9a       	mov	r10,r8
800060ca:	78 3c       	ld.w	r12,r12[0xc]
800060cc:	f0 1f 00 0c 	mcall	800060fc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800060d0:	6f 08       	ld.w	r8,r7[0x40]
800060d2:	6e 39       	ld.w	r9,r7[0xc]
800060d4:	f2 08 01 08 	sub	r8,r9,r8
800060d8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800060da:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800060dc:	12 38       	cp.w	r8,r9
800060de:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800060e2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800060e6:	f3 d8 e3 19 	subcs	r9,r9,r8
800060ea:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800060ee:	6e e8       	ld.w	r8,r7[0x38]
800060f0:	2f f8       	sub	r8,-1
800060f2:	8f e8       	st.w	r7[0x38],r8
}
800060f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	63 80       	ld.w	r0,r1[0x60]
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	75 ac       	ld.w	r12,r10[0x68]

80006100 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006100:	eb cd 40 c0 	pushm	r6-r7,lr
80006104:	18 97       	mov	r7,r12
80006106:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006108:	78 ec       	ld.w	r12,r12[0x38]
8000610a:	6e f8       	ld.w	r8,r7[0x3c]
8000610c:	10 3c       	cp.w	r12,r8
8000610e:	c0 33       	brcs	80006114 <xQueueGenericSendFromISR+0x14>
80006110:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006114:	12 9a       	mov	r10,r9
80006116:	0e 9c       	mov	r12,r7
80006118:	f0 1f 00 0c 	mcall	80006148 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000611c:	6f 28       	ld.w	r8,r7[0x48]
8000611e:	5b f8       	cp.w	r8,-1
80006120:	c0 d1       	brne	8000613a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006122:	6e 98       	ld.w	r8,r7[0x24]
80006124:	58 08       	cp.w	r8,0
80006126:	c0 f0       	breq	80006144 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006128:	ee cc ff dc 	sub	r12,r7,-36
8000612c:	f0 1f 00 08 	mcall	8000614c <xQueueGenericSendFromISR+0x4c>
80006130:	c0 a0       	breq	80006144 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006132:	30 1c       	mov	r12,1
80006134:	8d 0c       	st.w	r6[0x0],r12
80006136:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000613a:	2f f8       	sub	r8,-1
8000613c:	ef 48 00 48 	st.w	r7[72],r8
80006140:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006144:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	60 88       	ld.w	r8,r0[0x20]
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	64 5c       	ld.w	r12,r2[0x14]

80006150 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006150:	d4 31       	pushm	r0-r7,lr
80006152:	20 5d       	sub	sp,20
80006154:	18 97       	mov	r7,r12
80006156:	50 0b       	stdsp	sp[0x0],r11
80006158:	50 2a       	stdsp	sp[0x8],r10
8000615a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000615c:	f8 c0 ff f0 	sub	r0,r12,-16
80006160:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006162:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006166:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006168:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000616c:	f0 1f 00 2f 	mcall	80006228 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006170:	6e e9       	ld.w	r9,r7[0x38]
80006172:	6e f8       	ld.w	r8,r7[0x3c]
80006174:	10 39       	cp.w	r9,r8
80006176:	c1 42       	brcc	8000619e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006178:	40 1a       	lddsp	r10,sp[0x4]
8000617a:	40 0b       	lddsp	r11,sp[0x0]
8000617c:	0e 9c       	mov	r12,r7
8000617e:	f0 1f 00 2c 	mcall	8000622c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006182:	6e 98       	ld.w	r8,r7[0x24]
80006184:	58 08       	cp.w	r8,0
80006186:	c0 80       	breq	80006196 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006188:	ee cc ff dc 	sub	r12,r7,-36
8000618c:	f0 1f 00 29 	mcall	80006230 <xQueueGenericSend+0xe0>
80006190:	58 1c       	cp.w	r12,1
80006192:	c0 21       	brne	80006196 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006194:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006196:	f0 1f 00 28 	mcall	80006234 <xQueueGenericSend+0xe4>
8000619a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000619c:	c4 38       	rjmp	80006222 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000619e:	40 28       	lddsp	r8,sp[0x8]
800061a0:	58 08       	cp.w	r8,0
800061a2:	c0 51       	brne	800061ac <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800061a4:	f0 1f 00 24 	mcall	80006234 <xQueueGenericSend+0xe4>
800061a8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800061aa:	c3 c8       	rjmp	80006222 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800061ac:	58 04       	cp.w	r4,0
800061ae:	c0 51       	brne	800061b8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061b0:	06 9c       	mov	r12,r3
800061b2:	f0 1f 00 22 	mcall	80006238 <xQueueGenericSend+0xe8>
800061b6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800061b8:	f0 1f 00 1f 	mcall	80006234 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800061bc:	f0 1f 00 20 	mcall	8000623c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800061c0:	f0 1f 00 1a 	mcall	80006228 <xQueueGenericSend+0xd8>
800061c4:	6f 18       	ld.w	r8,r7[0x44]
800061c6:	5b f8       	cp.w	r8,-1
800061c8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800061cc:	6f 28       	ld.w	r8,r7[0x48]
800061ce:	5b f8       	cp.w	r8,-1
800061d0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800061d4:	f0 1f 00 18 	mcall	80006234 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061d8:	04 9b       	mov	r11,r2
800061da:	06 9c       	mov	r12,r3
800061dc:	f0 1f 00 19 	mcall	80006240 <xQueueGenericSend+0xf0>
800061e0:	c1 b1       	brne	80006216 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800061e2:	f0 1f 00 12 	mcall	80006228 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800061e6:	6e e5       	ld.w	r5,r7[0x38]
800061e8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800061ea:	f0 1f 00 13 	mcall	80006234 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800061ee:	0c 35       	cp.w	r5,r6
800061f0:	c0 d1       	brne	8000620a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800061f2:	40 2b       	lddsp	r11,sp[0x8]
800061f4:	00 9c       	mov	r12,r0
800061f6:	f0 1f 00 14 	mcall	80006244 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800061fa:	0e 9c       	mov	r12,r7
800061fc:	f0 1f 00 13 	mcall	80006248 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006200:	f0 1f 00 13 	mcall	8000624c <xQueueGenericSend+0xfc>
80006204:	cb 41       	brne	8000616c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006206:	d7 33       	scall
80006208:	cb 2b       	rjmp	8000616c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000620a:	0e 9c       	mov	r12,r7
8000620c:	f0 1f 00 0f 	mcall	80006248 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006210:	f0 1f 00 0f 	mcall	8000624c <xQueueGenericSend+0xfc>
80006214:	ca cb       	rjmp	8000616c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006216:	0e 9c       	mov	r12,r7
80006218:	f0 1f 00 0c 	mcall	80006248 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000621c:	f0 1f 00 0c 	mcall	8000624c <xQueueGenericSend+0xfc>
80006220:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006222:	2f bd       	sub	sp,-20
80006224:	d8 32       	popm	r0-r7,pc
80006226:	00 00       	add	r0,r0
80006228:	80 00       	ld.sh	r0,r0[0x0]
8000622a:	5b 90       	cp.w	r0,-7
8000622c:	80 00       	ld.sh	r0,r0[0x0]
8000622e:	60 88       	ld.w	r8,r0[0x20]
80006230:	80 00       	ld.sh	r0,r0[0x0]
80006232:	64 5c       	ld.w	r12,r2[0x14]
80006234:	80 00       	ld.sh	r0,r0[0x0]
80006236:	5c 9c       	brev	r12
80006238:	80 00       	ld.sh	r0,r0[0x0]
8000623a:	63 50       	ld.w	r0,r1[0x54]
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	62 c4       	ld.w	r4,r1[0x30]
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	65 ec       	ld.w	r12,r2[0x78]
80006244:	80 00       	ld.sh	r0,r0[0x0]
80006246:	68 8c       	ld.w	r12,r4[0x20]
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	5e a4       	retle	r4
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	66 80       	ld.w	r0,r3[0x20]

80006250 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006250:	d4 21       	pushm	r4-r7,lr
80006252:	18 97       	mov	r7,r12
80006254:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006256:	58 0c       	cp.w	r12,0
80006258:	c2 f0       	breq	800062b6 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000625a:	34 cc       	mov	r12,76
8000625c:	f0 1f 00 17 	mcall	800062b8 <xQueueCreate+0x68>
80006260:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006262:	c2 a0       	breq	800062b6 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006264:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006268:	e8 cc ff ff 	sub	r12,r4,-1
8000626c:	f0 1f 00 13 	mcall	800062b8 <xQueueCreate+0x68>
80006270:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006272:	c1 e0       	breq	800062ae <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006274:	f8 04 00 04 	add	r4,r12,r4
80006278:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000627a:	30 08       	mov	r8,0
8000627c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000627e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006280:	ee c8 00 01 	sub	r8,r7,1
80006284:	ad 38       	mul	r8,r6
80006286:	10 0c       	add	r12,r8
80006288:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000628a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000628c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006290:	3f f8       	mov	r8,-1
80006292:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006296:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000629a:	ea cc ff f0 	sub	r12,r5,-16
8000629e:	f0 1f 00 08 	mcall	800062bc <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800062a2:	ea cc ff dc 	sub	r12,r5,-36
800062a6:	f0 1f 00 06 	mcall	800062bc <xQueueCreate+0x6c>
800062aa:	0a 9c       	mov	r12,r5
800062ac:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800062ae:	0a 9c       	mov	r12,r5
800062b0:	f0 1f 00 04 	mcall	800062c0 <xQueueCreate+0x70>
800062b4:	d8 2a       	popm	r4-r7,pc,r12=0
800062b6:	d8 2a       	popm	r4-r7,pc,r12=0
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	5d fc       	*unknown*
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	5a 6c       	cp.w	r12,-26
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	5d d4       	*unknown*

800062c4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800062c4:	48 38       	lddpc	r8,800062d0 <vTaskSuspendAll+0xc>
800062c6:	70 09       	ld.w	r9,r8[0x0]
800062c8:	2f f9       	sub	r9,-1
800062ca:	91 09       	st.w	r8[0x0],r9
}
800062cc:	5e fc       	retal	r12
800062ce:	00 00       	add	r0,r0
800062d0:	00 00       	add	r0,r0
800062d2:	0d 1c       	ld.sh	r12,r6++

800062d4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800062d4:	49 a8       	lddpc	r8,8000633c <vTaskSwitchContext+0x68>
800062d6:	70 08       	ld.w	r8,r8[0x0]
800062d8:	58 08       	cp.w	r8,0
800062da:	c0 b1       	brne	800062f0 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800062dc:	49 98       	lddpc	r8,80006340 <vTaskSwitchContext+0x6c>
800062de:	70 08       	ld.w	r8,r8[0x0]
800062e0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800062e4:	49 89       	lddpc	r9,80006344 <vTaskSwitchContext+0x70>
800062e6:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800062ea:	58 08       	cp.w	r8,0
800062ec:	c0 60       	breq	800062f8 <vTaskSwitchContext+0x24>
800062ee:	c1 18       	rjmp	80006310 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800062f0:	30 19       	mov	r9,1
800062f2:	49 68       	lddpc	r8,80006348 <vTaskSwitchContext+0x74>
800062f4:	91 09       	st.w	r8[0x0],r9
800062f6:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800062f8:	49 28       	lddpc	r8,80006340 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800062fa:	49 3a       	lddpc	r10,80006344 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800062fc:	70 09       	ld.w	r9,r8[0x0]
800062fe:	20 19       	sub	r9,1
80006300:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006302:	70 09       	ld.w	r9,r8[0x0]
80006304:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006308:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000630c:	58 09       	cp.w	r9,0
8000630e:	cf 70       	breq	800062fc <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006310:	48 c8       	lddpc	r8,80006340 <vTaskSwitchContext+0x6c>
80006312:	70 08       	ld.w	r8,r8[0x0]
80006314:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006318:	48 b9       	lddpc	r9,80006344 <vTaskSwitchContext+0x70>
8000631a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000631e:	70 19       	ld.w	r9,r8[0x4]
80006320:	72 19       	ld.w	r9,r9[0x4]
80006322:	91 19       	st.w	r8[0x4],r9
80006324:	f0 ca ff f8 	sub	r10,r8,-8
80006328:	14 39       	cp.w	r9,r10
8000632a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000632e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006332:	70 18       	ld.w	r8,r8[0x4]
80006334:	70 39       	ld.w	r9,r8[0xc]
80006336:	48 68       	lddpc	r8,8000634c <vTaskSwitchContext+0x78>
80006338:	91 09       	st.w	r8[0x0],r9
8000633a:	5e fc       	retal	r12
8000633c:	00 00       	add	r0,r0
8000633e:	0d 1c       	ld.sh	r12,r6++
80006340:	00 00       	add	r0,r0
80006342:	0d 54       	ld.sh	r4,--r6
80006344:	00 00       	add	r0,r0
80006346:	0c 38       	cp.w	r8,r6
80006348:	00 00       	add	r0,r0
8000634a:	0d 3c       	ld.ub	r12,r6++
8000634c:	00 00       	add	r0,r0
8000634e:	0c ec       	st.h	--r6,r12

80006350 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006350:	48 48       	lddpc	r8,80006360 <vTaskSetTimeOutState+0x10>
80006352:	70 08       	ld.w	r8,r8[0x0]
80006354:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006356:	48 48       	lddpc	r8,80006364 <vTaskSetTimeOutState+0x14>
80006358:	70 08       	ld.w	r8,r8[0x0]
8000635a:	99 18       	st.w	r12[0x4],r8
}
8000635c:	5e fc       	retal	r12
8000635e:	00 00       	add	r0,r0
80006360:	00 00       	add	r0,r0
80006362:	0c 30       	cp.w	r0,r6
80006364:	00 00       	add	r0,r0
80006366:	0d 18       	ld.sh	r8,r6++

80006368 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006368:	30 19       	mov	r9,1
8000636a:	48 28       	lddpc	r8,80006370 <vTaskMissedYield+0x8>
8000636c:	91 09       	st.w	r8[0x0],r9
}
8000636e:	5e fc       	retal	r12
80006370:	00 00       	add	r0,r0
80006372:	0d 3c       	ld.ub	r12,r6++

80006374 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006374:	48 28       	lddpc	r8,8000637c <xTaskGetCurrentTaskHandle+0x8>
80006376:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006378:	5e fc       	retal	r12
8000637a:	00 00       	add	r0,r0
8000637c:	00 00       	add	r0,r0
8000637e:	0c ec       	st.h	--r6,r12

80006380 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006380:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006384:	58 0c       	cp.w	r12,0
80006386:	c1 f0       	breq	800063c4 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006388:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000638a:	78 b9       	ld.w	r9,r12[0x2c]
8000638c:	79 18       	ld.w	r8,r12[0x44]
8000638e:	10 39       	cp.w	r9,r8
80006390:	c1 a0       	breq	800063c4 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006392:	f8 c6 ff fc 	sub	r6,r12,-4
80006396:	0c 9c       	mov	r12,r6
80006398:	f0 1f 00 0c 	mcall	800063c8 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000639c:	6f 1c       	ld.w	r12,r7[0x44]
8000639e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800063a0:	f8 08 11 08 	rsub	r8,r12,8
800063a4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800063a6:	48 a8       	lddpc	r8,800063cc <vTaskPriorityDisinherit+0x4c>
800063a8:	70 08       	ld.w	r8,r8[0x0]
800063aa:	10 3c       	cp.w	r12,r8
800063ac:	e0 88 00 04 	brls	800063b4 <vTaskPriorityDisinherit+0x34>
800063b0:	48 78       	lddpc	r8,800063cc <vTaskPriorityDisinherit+0x4c>
800063b2:	91 0c       	st.w	r8[0x0],r12
800063b4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800063b8:	0c 9b       	mov	r11,r6
800063ba:	48 68       	lddpc	r8,800063d0 <vTaskPriorityDisinherit+0x50>
800063bc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800063c0:	f0 1f 00 05 	mcall	800063d4 <vTaskPriorityDisinherit+0x54>
800063c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	5a d6       	cp.w	r6,-19
800063cc:	00 00       	add	r0,r0
800063ce:	0d 54       	ld.sh	r4,--r6
800063d0:	00 00       	add	r0,r0
800063d2:	0c 38       	cp.w	r8,r6
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	5a 86       	cp.w	r6,-24

800063d8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800063d8:	eb cd 40 c0 	pushm	r6-r7,lr
800063dc:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800063de:	49 b8       	lddpc	r8,80006448 <vTaskPriorityInherit+0x70>
800063e0:	70 08       	ld.w	r8,r8[0x0]
800063e2:	78 b9       	ld.w	r9,r12[0x2c]
800063e4:	70 b8       	ld.w	r8,r8[0x2c]
800063e6:	10 39       	cp.w	r9,r8
800063e8:	c2 d2       	brcc	80006442 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800063ea:	49 88       	lddpc	r8,80006448 <vTaskPriorityInherit+0x70>
800063ec:	70 08       	ld.w	r8,r8[0x0]
800063ee:	70 b8       	ld.w	r8,r8[0x2c]
800063f0:	f0 08 11 08 	rsub	r8,r8,8
800063f4:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800063f6:	f2 09 00 28 	add	r8,r9,r9<<0x2
800063fa:	49 59       	lddpc	r9,8000644c <vTaskPriorityInherit+0x74>
800063fc:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006400:	78 59       	ld.w	r9,r12[0x14]
80006402:	10 39       	cp.w	r9,r8
80006404:	c1 b1       	brne	8000643a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006406:	f8 c6 ff fc 	sub	r6,r12,-4
8000640a:	0c 9c       	mov	r12,r6
8000640c:	f0 1f 00 11 	mcall	80006450 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006410:	48 e8       	lddpc	r8,80006448 <vTaskPriorityInherit+0x70>
80006412:	70 08       	ld.w	r8,r8[0x0]
80006414:	70 bc       	ld.w	r12,r8[0x2c]
80006416:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006418:	48 f8       	lddpc	r8,80006454 <vTaskPriorityInherit+0x7c>
8000641a:	70 08       	ld.w	r8,r8[0x0]
8000641c:	10 3c       	cp.w	r12,r8
8000641e:	e0 88 00 04 	brls	80006426 <vTaskPriorityInherit+0x4e>
80006422:	48 d8       	lddpc	r8,80006454 <vTaskPriorityInherit+0x7c>
80006424:	91 0c       	st.w	r8[0x0],r12
80006426:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000642a:	0c 9b       	mov	r11,r6
8000642c:	48 88       	lddpc	r8,8000644c <vTaskPriorityInherit+0x74>
8000642e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006432:	f0 1f 00 0a 	mcall	80006458 <vTaskPriorityInherit+0x80>
80006436:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000643a:	48 48       	lddpc	r8,80006448 <vTaskPriorityInherit+0x70>
8000643c:	70 08       	ld.w	r8,r8[0x0]
8000643e:	70 b8       	ld.w	r8,r8[0x2c]
80006440:	99 b8       	st.w	r12[0x2c],r8
80006442:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006446:	00 00       	add	r0,r0
80006448:	00 00       	add	r0,r0
8000644a:	0c ec       	st.h	--r6,r12
8000644c:	00 00       	add	r0,r0
8000644e:	0c 38       	cp.w	r8,r6
80006450:	80 00       	ld.sh	r0,r0[0x0]
80006452:	5a d6       	cp.w	r6,-19
80006454:	00 00       	add	r0,r0
80006456:	0d 54       	ld.sh	r4,--r6
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	5a 86       	cp.w	r6,-24

8000645c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000645c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006460:	78 38       	ld.w	r8,r12[0xc]
80006462:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006464:	ee c6 ff e8 	sub	r6,r7,-24
80006468:	0c 9c       	mov	r12,r6
8000646a:	f0 1f 00 15 	mcall	800064bc <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000646e:	49 58       	lddpc	r8,800064c0 <xTaskRemoveFromEventList+0x64>
80006470:	70 08       	ld.w	r8,r8[0x0]
80006472:	58 08       	cp.w	r8,0
80006474:	c1 71       	brne	800064a2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006476:	ee c6 ff fc 	sub	r6,r7,-4
8000647a:	0c 9c       	mov	r12,r6
8000647c:	f0 1f 00 10 	mcall	800064bc <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006480:	6e bc       	ld.w	r12,r7[0x2c]
80006482:	49 18       	lddpc	r8,800064c4 <xTaskRemoveFromEventList+0x68>
80006484:	70 08       	ld.w	r8,r8[0x0]
80006486:	10 3c       	cp.w	r12,r8
80006488:	e0 88 00 04 	brls	80006490 <xTaskRemoveFromEventList+0x34>
8000648c:	48 e8       	lddpc	r8,800064c4 <xTaskRemoveFromEventList+0x68>
8000648e:	91 0c       	st.w	r8[0x0],r12
80006490:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006494:	0c 9b       	mov	r11,r6
80006496:	48 d8       	lddpc	r8,800064c8 <xTaskRemoveFromEventList+0x6c>
80006498:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000649c:	f0 1f 00 0c 	mcall	800064cc <xTaskRemoveFromEventList+0x70>
800064a0:	c0 58       	rjmp	800064aa <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800064a2:	0c 9b       	mov	r11,r6
800064a4:	48 bc       	lddpc	r12,800064d0 <xTaskRemoveFromEventList+0x74>
800064a6:	f0 1f 00 0a 	mcall	800064cc <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800064aa:	48 b8       	lddpc	r8,800064d4 <xTaskRemoveFromEventList+0x78>
800064ac:	70 08       	ld.w	r8,r8[0x0]
800064ae:	6e b9       	ld.w	r9,r7[0x2c]
800064b0:	70 b8       	ld.w	r8,r8[0x2c]
800064b2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800064b4:	5f 2c       	srhs	r12
800064b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064ba:	00 00       	add	r0,r0
800064bc:	80 00       	ld.sh	r0,r0[0x0]
800064be:	5a d6       	cp.w	r6,-19
800064c0:	00 00       	add	r0,r0
800064c2:	0d 1c       	ld.sh	r12,r6++
800064c4:	00 00       	add	r0,r0
800064c6:	0d 54       	ld.sh	r4,--r6
800064c8:	00 00       	add	r0,r0
800064ca:	0c 38       	cp.w	r8,r6
800064cc:	80 00       	ld.sh	r0,r0[0x0]
800064ce:	5a 86       	cp.w	r6,-24
800064d0:	00 00       	add	r0,r0
800064d2:	0c f0       	st.b	--r6,r0
800064d4:	00 00       	add	r0,r0
800064d6:	0c ec       	st.h	--r6,r12

800064d8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800064d8:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800064dc:	4b 98       	lddpc	r8,800065c0 <vTaskIncrementTick+0xe8>
800064de:	70 08       	ld.w	r8,r8[0x0]
800064e0:	58 08       	cp.w	r8,0
800064e2:	c6 91       	brne	800065b4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800064e4:	4b 88       	lddpc	r8,800065c4 <vTaskIncrementTick+0xec>
800064e6:	70 09       	ld.w	r9,r8[0x0]
800064e8:	2f f9       	sub	r9,-1
800064ea:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800064ec:	70 08       	ld.w	r8,r8[0x0]
800064ee:	58 08       	cp.w	r8,0
800064f0:	c1 a1       	brne	80006524 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800064f2:	4b 68       	lddpc	r8,800065c8 <vTaskIncrementTick+0xf0>
800064f4:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800064f6:	4b 69       	lddpc	r9,800065cc <vTaskIncrementTick+0xf4>
800064f8:	72 0b       	ld.w	r11,r9[0x0]
800064fa:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800064fc:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800064fe:	4b 59       	lddpc	r9,800065d0 <vTaskIncrementTick+0xf8>
80006500:	72 0a       	ld.w	r10,r9[0x0]
80006502:	2f fa       	sub	r10,-1
80006504:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006506:	70 08       	ld.w	r8,r8[0x0]
80006508:	70 08       	ld.w	r8,r8[0x0]
8000650a:	58 08       	cp.w	r8,0
8000650c:	c0 51       	brne	80006516 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000650e:	3f f9       	mov	r9,-1
80006510:	4b 18       	lddpc	r8,800065d4 <vTaskIncrementTick+0xfc>
80006512:	91 09       	st.w	r8[0x0],r9
80006514:	c0 88       	rjmp	80006524 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006516:	4a d8       	lddpc	r8,800065c8 <vTaskIncrementTick+0xf0>
80006518:	70 08       	ld.w	r8,r8[0x0]
8000651a:	70 38       	ld.w	r8,r8[0xc]
8000651c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000651e:	70 19       	ld.w	r9,r8[0x4]
80006520:	4a d8       	lddpc	r8,800065d4 <vTaskIncrementTick+0xfc>
80006522:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006524:	4a 88       	lddpc	r8,800065c4 <vTaskIncrementTick+0xec>
80006526:	70 09       	ld.w	r9,r8[0x0]
80006528:	4a b8       	lddpc	r8,800065d4 <vTaskIncrementTick+0xfc>
8000652a:	70 08       	ld.w	r8,r8[0x0]
8000652c:	10 39       	cp.w	r9,r8
8000652e:	c4 73       	brcs	800065bc <vTaskIncrementTick+0xe4>
80006530:	4a 68       	lddpc	r8,800065c8 <vTaskIncrementTick+0xf0>
80006532:	70 08       	ld.w	r8,r8[0x0]
80006534:	70 08       	ld.w	r8,r8[0x0]
80006536:	58 08       	cp.w	r8,0
80006538:	c0 c0       	breq	80006550 <vTaskIncrementTick+0x78>
8000653a:	4a 48       	lddpc	r8,800065c8 <vTaskIncrementTick+0xf0>
8000653c:	70 08       	ld.w	r8,r8[0x0]
8000653e:	70 38       	ld.w	r8,r8[0xc]
80006540:	70 37       	ld.w	r7,r8[0xc]
80006542:	6e 18       	ld.w	r8,r7[0x4]
80006544:	4a 09       	lddpc	r9,800065c4 <vTaskIncrementTick+0xec>
80006546:	72 09       	ld.w	r9,r9[0x0]
80006548:	12 38       	cp.w	r8,r9
8000654a:	e0 88 00 14 	brls	80006572 <vTaskIncrementTick+0x9a>
8000654e:	c0 e8       	rjmp	8000656a <vTaskIncrementTick+0x92>
80006550:	3f f9       	mov	r9,-1
80006552:	4a 18       	lddpc	r8,800065d4 <vTaskIncrementTick+0xfc>
80006554:	91 09       	st.w	r8[0x0],r9
80006556:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000655a:	6a 08       	ld.w	r8,r5[0x0]
8000655c:	70 38       	ld.w	r8,r8[0xc]
8000655e:	70 37       	ld.w	r7,r8[0xc]
80006560:	6e 18       	ld.w	r8,r7[0x4]
80006562:	64 09       	ld.w	r9,r2[0x0]
80006564:	12 38       	cp.w	r8,r9
80006566:	e0 88 00 0a 	brls	8000657a <vTaskIncrementTick+0xa2>
8000656a:	49 b9       	lddpc	r9,800065d4 <vTaskIncrementTick+0xfc>
8000656c:	93 08       	st.w	r9[0x0],r8
8000656e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006572:	49 a4       	lddpc	r4,800065d8 <vTaskIncrementTick+0x100>
80006574:	49 a3       	lddpc	r3,800065dc <vTaskIncrementTick+0x104>
80006576:	49 55       	lddpc	r5,800065c8 <vTaskIncrementTick+0xf0>
80006578:	49 32       	lddpc	r2,800065c4 <vTaskIncrementTick+0xec>
8000657a:	ee c6 ff fc 	sub	r6,r7,-4
8000657e:	0c 9c       	mov	r12,r6
80006580:	f0 1f 00 18 	mcall	800065e0 <vTaskIncrementTick+0x108>
80006584:	6e a8       	ld.w	r8,r7[0x28]
80006586:	58 08       	cp.w	r8,0
80006588:	c0 50       	breq	80006592 <vTaskIncrementTick+0xba>
8000658a:	ee cc ff e8 	sub	r12,r7,-24
8000658e:	f0 1f 00 15 	mcall	800065e0 <vTaskIncrementTick+0x108>
80006592:	6e bc       	ld.w	r12,r7[0x2c]
80006594:	68 08       	ld.w	r8,r4[0x0]
80006596:	10 3c       	cp.w	r12,r8
80006598:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000659c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800065a0:	0c 9b       	mov	r11,r6
800065a2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800065a6:	f0 1f 00 10 	mcall	800065e4 <vTaskIncrementTick+0x10c>
800065aa:	6a 08       	ld.w	r8,r5[0x0]
800065ac:	70 08       	ld.w	r8,r8[0x0]
800065ae:	58 08       	cp.w	r8,0
800065b0:	cd 51       	brne	8000655a <vTaskIncrementTick+0x82>
800065b2:	cc fb       	rjmp	80006550 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800065b4:	48 d8       	lddpc	r8,800065e8 <vTaskIncrementTick+0x110>
800065b6:	70 09       	ld.w	r9,r8[0x0]
800065b8:	2f f9       	sub	r9,-1
800065ba:	91 09       	st.w	r8[0x0],r9
800065bc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800065c0:	00 00       	add	r0,r0
800065c2:	0d 1c       	ld.sh	r12,r6++
800065c4:	00 00       	add	r0,r0
800065c6:	0d 18       	ld.sh	r8,r6++
800065c8:	00 00       	add	r0,r0
800065ca:	0c 24       	rsub	r4,r6
800065cc:	00 00       	add	r0,r0
800065ce:	0c 34       	cp.w	r4,r6
800065d0:	00 00       	add	r0,r0
800065d2:	0c 30       	cp.w	r0,r6
800065d4:	00 00       	add	r0,r0
800065d6:	05 38       	ld.ub	r8,r2++
800065d8:	00 00       	add	r0,r0
800065da:	0d 54       	ld.sh	r4,--r6
800065dc:	00 00       	add	r0,r0
800065de:	0c 38       	cp.w	r8,r6
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	5a d6       	cp.w	r6,-19
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	5a 86       	cp.w	r6,-24
800065e8:	00 00       	add	r0,r0
800065ea:	0c 1c       	sub	r12,r6

800065ec <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800065ec:	eb cd 40 c0 	pushm	r6-r7,lr
800065f0:	18 97       	mov	r7,r12
800065f2:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800065f4:	f0 1f 00 15 	mcall	80006648 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800065f8:	6c 08       	ld.w	r8,r6[0x0]
800065fa:	5b f8       	cp.w	r8,-1
800065fc:	c0 31       	brne	80006602 <xTaskCheckForTimeOut+0x16>
800065fe:	30 07       	mov	r7,0
80006600:	c1 f8       	rjmp	8000663e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006602:	49 39       	lddpc	r9,8000664c <xTaskCheckForTimeOut+0x60>
80006604:	72 09       	ld.w	r9,r9[0x0]
80006606:	6e 0a       	ld.w	r10,r7[0x0]
80006608:	12 3a       	cp.w	r10,r9
8000660a:	c0 70       	breq	80006618 <xTaskCheckForTimeOut+0x2c>
8000660c:	49 19       	lddpc	r9,80006650 <xTaskCheckForTimeOut+0x64>
8000660e:	72 09       	ld.w	r9,r9[0x0]
80006610:	6e 1a       	ld.w	r10,r7[0x4]
80006612:	12 3a       	cp.w	r10,r9
80006614:	e0 88 00 14 	brls	8000663c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006618:	48 e9       	lddpc	r9,80006650 <xTaskCheckForTimeOut+0x64>
8000661a:	72 0a       	ld.w	r10,r9[0x0]
8000661c:	6e 19       	ld.w	r9,r7[0x4]
8000661e:	12 1a       	sub	r10,r9
80006620:	14 38       	cp.w	r8,r10
80006622:	e0 88 00 0d 	brls	8000663c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006626:	48 ba       	lddpc	r10,80006650 <xTaskCheckForTimeOut+0x64>
80006628:	74 0a       	ld.w	r10,r10[0x0]
8000662a:	14 19       	sub	r9,r10
8000662c:	f2 08 00 08 	add	r8,r9,r8
80006630:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006632:	0e 9c       	mov	r12,r7
80006634:	f0 1f 00 08 	mcall	80006654 <xTaskCheckForTimeOut+0x68>
80006638:	30 07       	mov	r7,0
8000663a:	c0 28       	rjmp	8000663e <xTaskCheckForTimeOut+0x52>
8000663c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000663e:	f0 1f 00 07 	mcall	80006658 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006642:	0e 9c       	mov	r12,r7
80006644:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006648:	80 00       	ld.sh	r0,r0[0x0]
8000664a:	5b 90       	cp.w	r0,-7
8000664c:	00 00       	add	r0,r0
8000664e:	0c 30       	cp.w	r0,r6
80006650:	00 00       	add	r0,r0
80006652:	0d 18       	ld.sh	r8,r6++
80006654:	80 00       	ld.sh	r0,r0[0x0]
80006656:	63 50       	ld.w	r0,r1[0x54]
80006658:	80 00       	ld.sh	r0,r0[0x0]
8000665a:	5c 9c       	brev	r12

8000665c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000665c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006660:	f0 1f 00 05 	mcall	80006674 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006664:	48 58       	lddpc	r8,80006678 <xTaskGetTickCount+0x1c>
80006666:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006668:	f0 1f 00 05 	mcall	8000667c <xTaskGetTickCount+0x20>

	return xTicks;
}
8000666c:	0e 9c       	mov	r12,r7
8000666e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006672:	00 00       	add	r0,r0
80006674:	80 00       	ld.sh	r0,r0[0x0]
80006676:	5b 90       	cp.w	r0,-7
80006678:	00 00       	add	r0,r0
8000667a:	0d 18       	ld.sh	r8,r6++
8000667c:	80 00       	ld.sh	r0,r0[0x0]
8000667e:	5c 9c       	brev	r12

80006680 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006680:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006684:	f0 1f 00 2c 	mcall	80006734 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006688:	4a c8       	lddpc	r8,80006738 <xTaskResumeAll+0xb8>
8000668a:	70 09       	ld.w	r9,r8[0x0]
8000668c:	20 19       	sub	r9,1
8000668e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006690:	70 08       	ld.w	r8,r8[0x0]
80006692:	58 08       	cp.w	r8,0
80006694:	c4 91       	brne	80006726 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006696:	4a a8       	lddpc	r8,8000673c <xTaskResumeAll+0xbc>
80006698:	70 08       	ld.w	r8,r8[0x0]
8000669a:	58 08       	cp.w	r8,0
8000669c:	c4 50       	breq	80006726 <xTaskResumeAll+0xa6>
8000669e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800066a0:	4a 85       	lddpc	r5,80006740 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800066a2:	4a 93       	lddpc	r3,80006744 <xTaskResumeAll+0xc4>
800066a4:	4a 92       	lddpc	r2,80006748 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800066a6:	4a a1       	lddpc	r1,8000674c <xTaskResumeAll+0xcc>
800066a8:	c1 e8       	rjmp	800066e4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800066aa:	6a 38       	ld.w	r8,r5[0xc]
800066ac:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800066ae:	ee cc ff e8 	sub	r12,r7,-24
800066b2:	f0 1f 00 28 	mcall	80006750 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800066b6:	ee c6 ff fc 	sub	r6,r7,-4
800066ba:	0c 9c       	mov	r12,r6
800066bc:	f0 1f 00 25 	mcall	80006750 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800066c0:	6e bc       	ld.w	r12,r7[0x2c]
800066c2:	66 08       	ld.w	r8,r3[0x0]
800066c4:	10 3c       	cp.w	r12,r8
800066c6:	e7 fc ba 00 	st.whi	r3[0x0],r12
800066ca:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066ce:	0c 9b       	mov	r11,r6
800066d0:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800066d4:	f0 1f 00 20 	mcall	80006754 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800066d8:	62 08       	ld.w	r8,r1[0x0]
800066da:	6e b9       	ld.w	r9,r7[0x2c]
800066dc:	70 b8       	ld.w	r8,r8[0x2c]
800066de:	10 39       	cp.w	r9,r8
800066e0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800066e4:	6a 08       	ld.w	r8,r5[0x0]
800066e6:	58 08       	cp.w	r8,0
800066e8:	ce 11       	brne	800066aa <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800066ea:	49 c8       	lddpc	r8,80006758 <xTaskResumeAll+0xd8>
800066ec:	70 08       	ld.w	r8,r8[0x0]
800066ee:	58 08       	cp.w	r8,0
800066f0:	c0 f0       	breq	8000670e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800066f2:	49 a8       	lddpc	r8,80006758 <xTaskResumeAll+0xd8>
800066f4:	70 08       	ld.w	r8,r8[0x0]
800066f6:	58 08       	cp.w	r8,0
800066f8:	c1 10       	breq	8000671a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800066fa:	49 87       	lddpc	r7,80006758 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800066fc:	f0 1f 00 18 	mcall	8000675c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006700:	6e 08       	ld.w	r8,r7[0x0]
80006702:	20 18       	sub	r8,1
80006704:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006706:	6e 08       	ld.w	r8,r7[0x0]
80006708:	58 08       	cp.w	r8,0
8000670a:	cf 91       	brne	800066fc <xTaskResumeAll+0x7c>
8000670c:	c0 78       	rjmp	8000671a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000670e:	58 14       	cp.w	r4,1
80006710:	c0 50       	breq	8000671a <xTaskResumeAll+0x9a>
80006712:	49 48       	lddpc	r8,80006760 <xTaskResumeAll+0xe0>
80006714:	70 08       	ld.w	r8,r8[0x0]
80006716:	58 18       	cp.w	r8,1
80006718:	c0 71       	brne	80006726 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000671a:	30 09       	mov	r9,0
8000671c:	49 18       	lddpc	r8,80006760 <xTaskResumeAll+0xe0>
8000671e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006720:	d7 33       	scall
80006722:	30 17       	mov	r7,1
80006724:	c0 28       	rjmp	80006728 <xTaskResumeAll+0xa8>
80006726:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006728:	f0 1f 00 0f 	mcall	80006764 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
8000672c:	0e 9c       	mov	r12,r7
8000672e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006732:	00 00       	add	r0,r0
80006734:	80 00       	ld.sh	r0,r0[0x0]
80006736:	5b 90       	cp.w	r0,-7
80006738:	00 00       	add	r0,r0
8000673a:	0d 1c       	ld.sh	r12,r6++
8000673c:	00 00       	add	r0,r0
8000673e:	0d 38       	ld.ub	r8,r6++
80006740:	00 00       	add	r0,r0
80006742:	0c f0       	st.b	--r6,r0
80006744:	00 00       	add	r0,r0
80006746:	0d 54       	ld.sh	r4,--r6
80006748:	00 00       	add	r0,r0
8000674a:	0c 38       	cp.w	r8,r6
8000674c:	00 00       	add	r0,r0
8000674e:	0c ec       	st.h	--r6,r12
80006750:	80 00       	ld.sh	r0,r0[0x0]
80006752:	5a d6       	cp.w	r6,-19
80006754:	80 00       	ld.sh	r0,r0[0x0]
80006756:	5a 86       	cp.w	r6,-24
80006758:	00 00       	add	r0,r0
8000675a:	0c 1c       	sub	r12,r6
8000675c:	80 00       	ld.sh	r0,r0[0x0]
8000675e:	64 d8       	ld.w	r8,r2[0x34]
80006760:	00 00       	add	r0,r0
80006762:	0d 3c       	ld.ub	r12,r6++
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	5c 9c       	brev	r12

80006768 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006768:	eb cd 40 80 	pushm	r7,lr
8000676c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000676e:	49 08       	lddpc	r8,800067ac <prvAddCurrentTaskToDelayedList+0x44>
80006770:	70 08       	ld.w	r8,r8[0x0]
80006772:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006774:	48 f8       	lddpc	r8,800067b0 <prvAddCurrentTaskToDelayedList+0x48>
80006776:	70 08       	ld.w	r8,r8[0x0]
80006778:	10 3c       	cp.w	r12,r8
8000677a:	c0 a2       	brcc	8000678e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000677c:	48 c8       	lddpc	r8,800067ac <prvAddCurrentTaskToDelayedList+0x44>
8000677e:	70 0b       	ld.w	r11,r8[0x0]
80006780:	48 d8       	lddpc	r8,800067b4 <prvAddCurrentTaskToDelayedList+0x4c>
80006782:	70 0c       	ld.w	r12,r8[0x0]
80006784:	2f cb       	sub	r11,-4
80006786:	f0 1f 00 0d 	mcall	800067b8 <prvAddCurrentTaskToDelayedList+0x50>
8000678a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000678e:	48 88       	lddpc	r8,800067ac <prvAddCurrentTaskToDelayedList+0x44>
80006790:	70 0b       	ld.w	r11,r8[0x0]
80006792:	48 b8       	lddpc	r8,800067bc <prvAddCurrentTaskToDelayedList+0x54>
80006794:	70 0c       	ld.w	r12,r8[0x0]
80006796:	2f cb       	sub	r11,-4
80006798:	f0 1f 00 08 	mcall	800067b8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000679c:	48 98       	lddpc	r8,800067c0 <prvAddCurrentTaskToDelayedList+0x58>
8000679e:	70 08       	ld.w	r8,r8[0x0]
800067a0:	10 37       	cp.w	r7,r8
800067a2:	c0 32       	brcc	800067a8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800067a4:	48 78       	lddpc	r8,800067c0 <prvAddCurrentTaskToDelayedList+0x58>
800067a6:	91 07       	st.w	r8[0x0],r7
800067a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800067ac:	00 00       	add	r0,r0
800067ae:	0c ec       	st.h	--r6,r12
800067b0:	00 00       	add	r0,r0
800067b2:	0d 18       	ld.sh	r8,r6++
800067b4:	00 00       	add	r0,r0
800067b6:	0c 34       	cp.w	r4,r6
800067b8:	80 00       	ld.sh	r0,r0[0x0]
800067ba:	5a a2       	cp.w	r2,-22
800067bc:	00 00       	add	r0,r0
800067be:	0c 24       	rsub	r4,r6
800067c0:	00 00       	add	r0,r0
800067c2:	05 38       	ld.ub	r8,r2++

800067c4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800067c4:	eb cd 40 c0 	pushm	r6-r7,lr
800067c8:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800067ca:	58 0c       	cp.w	r12,0
800067cc:	c1 10       	breq	800067ee <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800067ce:	f0 1f 00 0a 	mcall	800067f4 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800067d2:	48 a8       	lddpc	r8,800067f8 <vTaskDelay+0x34>
800067d4:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800067d6:	48 a8       	lddpc	r8,800067fc <vTaskDelay+0x38>
800067d8:	70 0c       	ld.w	r12,r8[0x0]
800067da:	2f cc       	sub	r12,-4
800067dc:	f0 1f 00 09 	mcall	80006800 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800067e0:	ee 06 00 0c 	add	r12,r7,r6
800067e4:	f0 1f 00 08 	mcall	80006804 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800067e8:	f0 1f 00 08 	mcall	80006808 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800067ec:	c0 21       	brne	800067f0 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800067ee:	d7 33       	scall
800067f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	62 c4       	ld.w	r4,r1[0x30]
800067f8:	00 00       	add	r0,r0
800067fa:	0d 18       	ld.sh	r8,r6++
800067fc:	00 00       	add	r0,r0
800067fe:	0c ec       	st.h	--r6,r12
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	5a d6       	cp.w	r6,-19
80006804:	80 00       	ld.sh	r0,r0[0x0]
80006806:	67 68       	ld.w	r8,r3[0x58]
80006808:	80 00       	ld.sh	r0,r0[0x0]
8000680a:	66 80       	ld.w	r0,r3[0x20]

8000680c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000680c:	eb cd 40 c0 	pushm	r6-r7,lr
80006810:	18 96       	mov	r6,r12
80006812:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006814:	f0 1f 00 18 	mcall	80006874 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006818:	6c 08       	ld.w	r8,r6[0x0]
8000681a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
8000681c:	49 79       	lddpc	r9,80006878 <vTaskDelayUntil+0x6c>
8000681e:	72 09       	ld.w	r9,r9[0x0]
80006820:	12 38       	cp.w	r8,r9
80006822:	e0 88 00 0c 	brls	8000683a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006826:	0e 38       	cp.w	r8,r7
80006828:	e0 88 00 22 	brls	8000686c <vTaskDelayUntil+0x60>
8000682c:	49 38       	lddpc	r8,80006878 <vTaskDelayUntil+0x6c>
8000682e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006830:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006832:	10 37       	cp.w	r7,r8
80006834:	e0 88 00 14 	brls	8000685c <vTaskDelayUntil+0x50>
80006838:	c0 a8       	rjmp	8000684c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000683a:	0e 38       	cp.w	r8,r7
8000683c:	e0 8b 00 16 	brhi	80006868 <vTaskDelayUntil+0x5c>
80006840:	48 e8       	lddpc	r8,80006878 <vTaskDelayUntil+0x6c>
80006842:	70 08       	ld.w	r8,r8[0x0]
80006844:	10 37       	cp.w	r7,r8
80006846:	e0 8b 00 11 	brhi	80006868 <vTaskDelayUntil+0x5c>
8000684a:	c1 18       	rjmp	8000686c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000684c:	48 c8       	lddpc	r8,8000687c <vTaskDelayUntil+0x70>
8000684e:	70 0c       	ld.w	r12,r8[0x0]
80006850:	2f cc       	sub	r12,-4
80006852:	f0 1f 00 0c 	mcall	80006880 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006856:	0e 9c       	mov	r12,r7
80006858:	f0 1f 00 0b 	mcall	80006884 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
8000685c:	f0 1f 00 0b 	mcall	80006888 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006860:	c0 81       	brne	80006870 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006862:	d7 33       	scall
80006864:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006868:	8d 07       	st.w	r6[0x0],r7
8000686a:	cf 1b       	rjmp	8000684c <vTaskDelayUntil+0x40>
8000686c:	8d 07       	st.w	r6[0x0],r7
8000686e:	cf 7b       	rjmp	8000685c <vTaskDelayUntil+0x50>
80006870:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006874:	80 00       	ld.sh	r0,r0[0x0]
80006876:	62 c4       	ld.w	r4,r1[0x30]
80006878:	00 00       	add	r0,r0
8000687a:	0d 18       	ld.sh	r8,r6++
8000687c:	00 00       	add	r0,r0
8000687e:	0c ec       	st.h	--r6,r12
80006880:	80 00       	ld.sh	r0,r0[0x0]
80006882:	5a d6       	cp.w	r6,-19
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	67 68       	ld.w	r8,r3[0x58]
80006888:	80 00       	ld.sh	r0,r0[0x0]
8000688a:	66 80       	ld.w	r0,r3[0x20]

8000688c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000688c:	eb cd 40 c0 	pushm	r6-r7,lr
80006890:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006892:	48 e7       	lddpc	r7,800068c8 <vTaskPlaceOnEventList+0x3c>
80006894:	6e 0b       	ld.w	r11,r7[0x0]
80006896:	2e 8b       	sub	r11,-24
80006898:	f0 1f 00 0d 	mcall	800068cc <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000689c:	6e 0c       	ld.w	r12,r7[0x0]
8000689e:	2f cc       	sub	r12,-4
800068a0:	f0 1f 00 0c 	mcall	800068d0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800068a4:	5b f6       	cp.w	r6,-1
800068a6:	c0 81       	brne	800068b6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068a8:	6e 0b       	ld.w	r11,r7[0x0]
800068aa:	2f cb       	sub	r11,-4
800068ac:	48 ac       	lddpc	r12,800068d4 <vTaskPlaceOnEventList+0x48>
800068ae:	f0 1f 00 0b 	mcall	800068d8 <vTaskPlaceOnEventList+0x4c>
800068b2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800068b6:	48 a8       	lddpc	r8,800068dc <vTaskPlaceOnEventList+0x50>
800068b8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800068ba:	ec 0c 00 0c 	add	r12,r6,r12
800068be:	f0 1f 00 09 	mcall	800068e0 <vTaskPlaceOnEventList+0x54>
800068c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068c6:	00 00       	add	r0,r0
800068c8:	00 00       	add	r0,r0
800068ca:	0c ec       	st.h	--r6,r12
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	5a a2       	cp.w	r2,-22
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	5a d6       	cp.w	r6,-19
800068d4:	00 00       	add	r0,r0
800068d6:	0d 40       	ld.w	r0,--r6
800068d8:	80 00       	ld.sh	r0,r0[0x0]
800068da:	5a 86       	cp.w	r6,-24
800068dc:	00 00       	add	r0,r0
800068de:	0d 18       	ld.sh	r8,r6++
800068e0:	80 00       	ld.sh	r0,r0[0x0]
800068e2:	67 68       	ld.w	r8,r3[0x58]

800068e4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800068e4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800068e8:	49 67       	lddpc	r7,80006940 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800068ea:	49 74       	lddpc	r4,80006944 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800068ec:	49 73       	lddpc	r3,80006948 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800068ee:	49 85       	lddpc	r5,8000694c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800068f0:	6e 08       	ld.w	r8,r7[0x0]
800068f2:	58 08       	cp.w	r8,0
800068f4:	c1 e0       	breq	80006930 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800068f6:	f0 1f 00 17 	mcall	80006950 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800068fa:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800068fc:	f0 1f 00 16 	mcall	80006954 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006900:	58 06       	cp.w	r6,0
80006902:	c1 70       	breq	80006930 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006904:	f0 1f 00 15 	mcall	80006958 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006908:	68 38       	ld.w	r8,r4[0xc]
8000690a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000690c:	ec cc ff fc 	sub	r12,r6,-4
80006910:	f0 1f 00 13 	mcall	8000695c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006914:	66 08       	ld.w	r8,r3[0x0]
80006916:	20 18       	sub	r8,1
80006918:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000691a:	6e 08       	ld.w	r8,r7[0x0]
8000691c:	20 18       	sub	r8,1
8000691e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006920:	f0 1f 00 10 	mcall	80006960 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006924:	6c cc       	ld.w	r12,r6[0x30]
80006926:	f0 1f 00 10 	mcall	80006964 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000692a:	0c 9c       	mov	r12,r6
8000692c:	f0 1f 00 0e 	mcall	80006964 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006930:	6a 08       	ld.w	r8,r5[0x0]
80006932:	58 18       	cp.w	r8,1
80006934:	e0 88 00 03 	brls	8000693a <prvIdleTask+0x56>
			{
				taskYIELD();
80006938:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000693a:	f0 1f 00 0c 	mcall	80006968 <prvIdleTask+0x84>
		}
		#endif
	}
8000693e:	cd 9b       	rjmp	800068f0 <prvIdleTask+0xc>
80006940:	00 00       	add	r0,r0
80006942:	0c 2c       	rsub	r12,r6
80006944:	00 00       	add	r0,r0
80006946:	0c d8       	st.w	--r6,r8
80006948:	00 00       	add	r0,r0
8000694a:	0d 38       	ld.ub	r8,r6++
8000694c:	00 00       	add	r0,r0
8000694e:	0c 38       	cp.w	r8,r6
80006950:	80 00       	ld.sh	r0,r0[0x0]
80006952:	62 c4       	ld.w	r4,r1[0x30]
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	66 80       	ld.w	r0,r3[0x20]
80006958:	80 00       	ld.sh	r0,r0[0x0]
8000695a:	5b 90       	cp.w	r0,-7
8000695c:	80 00       	ld.sh	r0,r0[0x0]
8000695e:	5a d6       	cp.w	r6,-19
80006960:	80 00       	ld.sh	r0,r0[0x0]
80006962:	5c 9c       	brev	r12
80006964:	80 00       	ld.sh	r0,r0[0x0]
80006966:	5d d4       	*unknown*
80006968:	80 00       	ld.sh	r0,r0[0x0]
8000696a:	20 2c       	sub	r12,2

8000696c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
8000696c:	d4 31       	pushm	r0-r7,lr
8000696e:	20 1d       	sub	sp,4
80006970:	fa c4 ff d8 	sub	r4,sp,-40
80006974:	50 0c       	stdsp	sp[0x0],r12
80006976:	16 91       	mov	r1,r11
80006978:	14 97       	mov	r7,r10
8000697a:	12 90       	mov	r0,r9
8000697c:	10 93       	mov	r3,r8
8000697e:	68 02       	ld.w	r2,r4[0x0]
80006980:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006982:	34 8c       	mov	r12,72
80006984:	f0 1f 00 5c 	mcall	80006af4 <xTaskGenericCreate+0x188>
80006988:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000698a:	c0 31       	brne	80006990 <xTaskGenericCreate+0x24>
8000698c:	3f fc       	mov	r12,-1
8000698e:	ca f8       	rjmp	80006aec <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006990:	58 06       	cp.w	r6,0
80006992:	e0 81 00 af 	brne	80006af0 <xTaskGenericCreate+0x184>
80006996:	0e 9c       	mov	r12,r7
80006998:	5c 7c       	castu.h	r12
8000699a:	a3 6c       	lsl	r12,0x2
8000699c:	f0 1f 00 56 	mcall	80006af4 <xTaskGenericCreate+0x188>
800069a0:	18 96       	mov	r6,r12
800069a2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800069a4:	c0 61       	brne	800069b0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800069a6:	0a 9c       	mov	r12,r5
800069a8:	f0 1f 00 54 	mcall	80006af8 <xTaskGenericCreate+0x18c>
800069ac:	3f fc       	mov	r12,-1
800069ae:	c9 f8       	rjmp	80006aec <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800069b0:	5c 77       	castu.h	r7
800069b2:	ee 0a 15 02 	lsl	r10,r7,0x2
800069b6:	e0 6b 00 a5 	mov	r11,165
800069ba:	0c 9c       	mov	r12,r6
800069bc:	f0 1f 00 50 	mcall	80006afc <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800069c0:	ee c6 00 01 	sub	r6,r7,1
800069c4:	6a c8       	ld.w	r8,r5[0x30]
800069c6:	f0 06 00 26 	add	r6,r8,r6<<0x2
800069ca:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800069ce:	31 0a       	mov	r10,16
800069d0:	02 9b       	mov	r11,r1
800069d2:	ea cc ff cc 	sub	r12,r5,-52
800069d6:	f0 1f 00 4b 	mcall	80006b00 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800069da:	30 08       	mov	r8,0
800069dc:	eb 68 00 43 	st.b	r5[67],r8
800069e0:	58 73       	cp.w	r3,7
800069e2:	e6 07 17 80 	movls	r7,r3
800069e6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800069ea:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800069ec:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800069f0:	ea c4 ff fc 	sub	r4,r5,-4
800069f4:	08 9c       	mov	r12,r4
800069f6:	f0 1f 00 44 	mcall	80006b04 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800069fa:	ea cc ff e8 	sub	r12,r5,-24
800069fe:	f0 1f 00 42 	mcall	80006b04 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006a02:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006a04:	ee 07 11 08 	rsub	r7,r7,8
80006a08:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006a0a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006a0c:	00 9a       	mov	r10,r0
80006a0e:	40 0b       	lddsp	r11,sp[0x0]
80006a10:	0c 9c       	mov	r12,r6
80006a12:	f0 1f 00 3e 	mcall	80006b08 <xTaskGenericCreate+0x19c>
80006a16:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006a18:	58 02       	cp.w	r2,0
80006a1a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006a1e:	f0 1f 00 3c 	mcall	80006b0c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006a22:	4b c8       	lddpc	r8,80006b10 <xTaskGenericCreate+0x1a4>
80006a24:	70 09       	ld.w	r9,r8[0x0]
80006a26:	2f f9       	sub	r9,-1
80006a28:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006a2a:	4b b8       	lddpc	r8,80006b14 <xTaskGenericCreate+0x1a8>
80006a2c:	70 08       	ld.w	r8,r8[0x0]
80006a2e:	58 08       	cp.w	r8,0
80006a30:	c2 61       	brne	80006a7c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006a32:	4b 98       	lddpc	r8,80006b14 <xTaskGenericCreate+0x1a8>
80006a34:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006a36:	4b 78       	lddpc	r8,80006b10 <xTaskGenericCreate+0x1a4>
80006a38:	70 08       	ld.w	r8,r8[0x0]
80006a3a:	58 18       	cp.w	r8,1
80006a3c:	c2 b1       	brne	80006a92 <xTaskGenericCreate+0x126>
80006a3e:	4b 77       	lddpc	r7,80006b18 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006a40:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006a44:	0e 9c       	mov	r12,r7
80006a46:	f0 1f 00 36 	mcall	80006b1c <xTaskGenericCreate+0x1b0>
80006a4a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006a4c:	0c 37       	cp.w	r7,r6
80006a4e:	cf b1       	brne	80006a44 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006a50:	4b 47       	lddpc	r7,80006b20 <xTaskGenericCreate+0x1b4>
80006a52:	0e 9c       	mov	r12,r7
80006a54:	f0 1f 00 32 	mcall	80006b1c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006a58:	4b 36       	lddpc	r6,80006b24 <xTaskGenericCreate+0x1b8>
80006a5a:	0c 9c       	mov	r12,r6
80006a5c:	f0 1f 00 30 	mcall	80006b1c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006a60:	4b 2c       	lddpc	r12,80006b28 <xTaskGenericCreate+0x1bc>
80006a62:	f0 1f 00 2f 	mcall	80006b1c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006a66:	4b 2c       	lddpc	r12,80006b2c <xTaskGenericCreate+0x1c0>
80006a68:	f0 1f 00 2d 	mcall	80006b1c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006a6c:	4b 1c       	lddpc	r12,80006b30 <xTaskGenericCreate+0x1c4>
80006a6e:	f0 1f 00 2c 	mcall	80006b1c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006a72:	4b 18       	lddpc	r8,80006b34 <xTaskGenericCreate+0x1c8>
80006a74:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006a76:	4b 18       	lddpc	r8,80006b38 <xTaskGenericCreate+0x1cc>
80006a78:	91 06       	st.w	r8[0x0],r6
80006a7a:	c0 c8       	rjmp	80006a92 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006a7c:	4b 08       	lddpc	r8,80006b3c <xTaskGenericCreate+0x1d0>
80006a7e:	70 08       	ld.w	r8,r8[0x0]
80006a80:	58 08       	cp.w	r8,0
80006a82:	c0 81       	brne	80006a92 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006a84:	4a 48       	lddpc	r8,80006b14 <xTaskGenericCreate+0x1a8>
80006a86:	70 08       	ld.w	r8,r8[0x0]
80006a88:	70 b8       	ld.w	r8,r8[0x2c]
80006a8a:	10 33       	cp.w	r3,r8
80006a8c:	c0 33       	brcs	80006a92 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006a8e:	4a 28       	lddpc	r8,80006b14 <xTaskGenericCreate+0x1a8>
80006a90:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006a92:	6a b8       	ld.w	r8,r5[0x2c]
80006a94:	4a b9       	lddpc	r9,80006b40 <xTaskGenericCreate+0x1d4>
80006a96:	72 09       	ld.w	r9,r9[0x0]
80006a98:	12 38       	cp.w	r8,r9
80006a9a:	e0 88 00 04 	brls	80006aa2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006a9e:	4a 99       	lddpc	r9,80006b40 <xTaskGenericCreate+0x1d4>
80006aa0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006aa2:	4a 98       	lddpc	r8,80006b44 <xTaskGenericCreate+0x1d8>
80006aa4:	70 09       	ld.w	r9,r8[0x0]
80006aa6:	2f f9       	sub	r9,-1
80006aa8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006aaa:	6a b8       	ld.w	r8,r5[0x2c]
80006aac:	4a 79       	lddpc	r9,80006b48 <xTaskGenericCreate+0x1dc>
80006aae:	72 09       	ld.w	r9,r9[0x0]
80006ab0:	12 38       	cp.w	r8,r9
80006ab2:	e0 88 00 04 	brls	80006aba <xTaskGenericCreate+0x14e>
80006ab6:	4a 59       	lddpc	r9,80006b48 <xTaskGenericCreate+0x1dc>
80006ab8:	93 08       	st.w	r9[0x0],r8
80006aba:	6a bc       	ld.w	r12,r5[0x2c]
80006abc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006ac0:	08 9b       	mov	r11,r4
80006ac2:	49 68       	lddpc	r8,80006b18 <xTaskGenericCreate+0x1ac>
80006ac4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006ac8:	f0 1f 00 21 	mcall	80006b4c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006acc:	f0 1f 00 21 	mcall	80006b50 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006ad0:	49 b8       	lddpc	r8,80006b3c <xTaskGenericCreate+0x1d0>
80006ad2:	70 08       	ld.w	r8,r8[0x0]
80006ad4:	58 08       	cp.w	r8,0
80006ad6:	c0 a0       	breq	80006aea <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006ad8:	48 f8       	lddpc	r8,80006b14 <xTaskGenericCreate+0x1a8>
80006ada:	70 08       	ld.w	r8,r8[0x0]
80006adc:	70 b8       	ld.w	r8,r8[0x2c]
80006ade:	10 33       	cp.w	r3,r8
80006ae0:	e0 88 00 05 	brls	80006aea <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006ae4:	d7 33       	scall
80006ae6:	30 1c       	mov	r12,1
80006ae8:	c0 28       	rjmp	80006aec <xTaskGenericCreate+0x180>
80006aea:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006aec:	2f fd       	sub	sp,-4
80006aee:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006af0:	99 c6       	st.w	r12[0x30],r6
80006af2:	c5 fb       	rjmp	800069b0 <xTaskGenericCreate+0x44>
80006af4:	80 00       	ld.sh	r0,r0[0x0]
80006af6:	5d fc       	*unknown*
80006af8:	80 00       	ld.sh	r0,r0[0x0]
80006afa:	5d d4       	*unknown*
80006afc:	80 00       	ld.sh	r0,r0[0x0]
80006afe:	76 f4       	ld.w	r4,r11[0x3c]
80006b00:	80 00       	ld.sh	r0,r0[0x0]
80006b02:	7a 20       	ld.w	r0,sp[0x8]
80006b04:	80 00       	ld.sh	r0,r0[0x0]
80006b06:	5a 80       	cp.w	r0,-24
80006b08:	80 00       	ld.sh	r0,r0[0x0]
80006b0a:	5a fc       	cp.w	r12,-17
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	5b 90       	cp.w	r0,-7
80006b10:	00 00       	add	r0,r0
80006b12:	0d 38       	ld.ub	r8,r6++
80006b14:	00 00       	add	r0,r0
80006b16:	0c ec       	st.h	--r6,r12
80006b18:	00 00       	add	r0,r0
80006b1a:	0c 38       	cp.w	r8,r6
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	5a 6c       	cp.w	r12,-26
80006b20:	00 00       	add	r0,r0
80006b22:	0d 04       	ld.w	r4,r6++
80006b24:	00 00       	add	r0,r0
80006b26:	0d 20       	ld.uh	r0,r6++
80006b28:	00 00       	add	r0,r0
80006b2a:	0c f0       	st.b	--r6,r0
80006b2c:	00 00       	add	r0,r0
80006b2e:	0c d8       	st.w	--r6,r8
80006b30:	00 00       	add	r0,r0
80006b32:	0d 40       	ld.w	r0,--r6
80006b34:	00 00       	add	r0,r0
80006b36:	0c 24       	rsub	r4,r6
80006b38:	00 00       	add	r0,r0
80006b3a:	0c 34       	cp.w	r4,r6
80006b3c:	00 00       	add	r0,r0
80006b3e:	0c 28       	rsub	r8,r6
80006b40:	00 00       	add	r0,r0
80006b42:	0c 20       	rsub	r0,r6
80006b44:	00 00       	add	r0,r0
80006b46:	0d 34       	ld.ub	r4,r6++
80006b48:	00 00       	add	r0,r0
80006b4a:	0d 54       	ld.sh	r4,--r6
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	5a 86       	cp.w	r6,-24
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	5c 9c       	brev	r12

80006b54 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006b54:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006b56:	30 09       	mov	r9,0
80006b58:	1a d9       	st.w	--sp,r9
80006b5a:	1a d9       	st.w	--sp,r9
80006b5c:	1a d9       	st.w	--sp,r9
80006b5e:	12 98       	mov	r8,r9
80006b60:	e0 6a 01 00 	mov	r10,256
80006b64:	48 9b       	lddpc	r11,80006b88 <vTaskStartScheduler+0x34>
80006b66:	48 ac       	lddpc	r12,80006b8c <vTaskStartScheduler+0x38>
80006b68:	f0 1f 00 0a 	mcall	80006b90 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006b6c:	2f dd       	sub	sp,-12
80006b6e:	58 1c       	cp.w	r12,1
80006b70:	c0 a1       	brne	80006b84 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006b72:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006b74:	30 19       	mov	r9,1
80006b76:	48 88       	lddpc	r8,80006b94 <vTaskStartScheduler+0x40>
80006b78:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006b7a:	30 09       	mov	r9,0
80006b7c:	48 78       	lddpc	r8,80006b98 <vTaskStartScheduler+0x44>
80006b7e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006b80:	f0 1f 00 07 	mcall	80006b9c <vTaskStartScheduler+0x48>
80006b84:	d8 02       	popm	pc
80006b86:	00 00       	add	r0,r0
80006b88:	80 00       	ld.sh	r0,r0[0x0]
80006b8a:	d7 b4       	*unknown*
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	68 e4       	ld.w	r4,r4[0x38]
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	69 6c       	ld.w	r12,r4[0x58]
80006b94:	00 00       	add	r0,r0
80006b96:	0c 28       	rsub	r8,r6
80006b98:	00 00       	add	r0,r0
80006b9a:	0d 18       	ld.sh	r8,r6++
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	5b a0       	cp.w	r0,-6

80006ba0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006ba0:	16 cc       	st.b	r11++,r12
	return str;
}
80006ba2:	5e fb       	retal	r11

80006ba4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006ba4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ba8:	20 3d       	sub	sp,12
80006baa:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006bac:	30 06       	mov	r6,0
80006bae:	30 07       	mov	r7,0
80006bb0:	fa e7 00 00 	st.d	sp[0],r6
80006bb4:	30 0c       	mov	r12,0
80006bb6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006bb8:	58 08       	cp.w	r8,0
80006bba:	c1 30       	breq	80006be0 <PrintHex+0x3c>
80006bbc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006bbe:	1a 9c       	mov	r12,sp
80006bc0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006bc4:	58 9e       	cp.w	lr,9
80006bc6:	e0 8a 00 04 	brle	80006bce <PrintHex+0x2a>
80006bca:	2c 9e       	sub	lr,-55
80006bcc:	c0 48       	rjmp	80006bd4 <PrintHex+0x30>
80006bce:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006bd2:	2d 0e       	sub	lr,-48
80006bd4:	f8 09 0b 0e 	st.b	r12[r9],lr
80006bd8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006bda:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006bdc:	cf 21       	brne	80006bc0 <PrintHex+0x1c>
80006bde:	c0 48       	rjmp	80006be6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006be0:	33 08       	mov	r8,48
80006be2:	ba 88       	st.b	sp[0x0],r8
80006be4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006be6:	f6 09 01 08 	sub	r8,r11,r9
80006bea:	58 08       	cp.w	r8,0
80006bec:	e0 8a 00 13 	brle	80006c12 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006bf0:	12 1b       	sub	r11,r9
80006bf2:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006bf6:	18 9e       	mov	lr,r12
80006bf8:	58 0c       	cp.w	r12,0
80006bfa:	e0 8a 00 0c 	brle	80006c12 <PrintHex+0x6e>
80006bfe:	1a 9b       	mov	r11,sp
80006c00:	12 0b       	add	r11,r9
80006c02:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006c04:	33 07       	mov	r7,48
80006c06:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006c08:	2f f8       	sub	r8,-1
80006c0a:	1c 38       	cp.w	r8,lr
80006c0c:	cf d5       	brlt	80006c06 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c0e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c12:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006c16:	f0 cb ff ff 	sub	r11,r8,-1
80006c1a:	58 0b       	cp.w	r11,0
80006c1c:	e0 8a 00 19 	brle	80006c4e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006c20:	fa cb ff f4 	sub	r11,sp,-12
80006c24:	f6 09 00 09 	add	r9,r11,r9
80006c28:	37 8b       	mov	r11,120
80006c2a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006c2e:	fa c9 ff f4 	sub	r9,sp,-12
80006c32:	10 09       	add	r9,r8
80006c34:	33 0b       	mov	r11,48
80006c36:	f3 6b ff f4 	st.b	r9[-12],r11
80006c3a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c3e:	fa ce 00 01 	sub	lr,sp,1
80006c42:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006c44:	11 8b       	ld.ub	r11,r8[0x0]
80006c46:	12 cb       	st.b	r9++,r11
80006c48:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006c4a:	1c 38       	cp.w	r8,lr
80006c4c:	cf c1       	brne	80006c44 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006c4e:	14 9c       	mov	r12,r10
80006c50:	2f dd       	sub	sp,-12
80006c52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006c56 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006c56:	d4 21       	pushm	r4-r7,lr
80006c58:	20 3d       	sub	sp,12
80006c5a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006c5c:	30 06       	mov	r6,0
80006c5e:	30 07       	mov	r7,0
80006c60:	fa e7 00 00 	st.d	sp[0],r6
80006c64:	30 0c       	mov	r12,0
80006c66:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006c68:	58 08       	cp.w	r8,0
80006c6a:	c0 35       	brlt	80006c70 <PrintDec+0x1a>
80006c6c:	14 97       	mov	r7,r10
80006c6e:	c0 58       	rjmp	80006c78 <PrintDec+0x22>
	{
		*p++ = '-';
80006c70:	14 97       	mov	r7,r10
80006c72:	32 d9       	mov	r9,45
80006c74:	0e c9       	st.b	r7++,r9
		i = -i;
80006c76:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006c78:	58 08       	cp.w	r8,0
80006c7a:	c0 51       	brne	80006c84 <PrintDec+0x2e>
80006c7c:	33 08       	mov	r8,48
80006c7e:	ba 88       	st.b	sp[0x0],r8
80006c80:	30 1e       	mov	lr,1
80006c82:	c2 f8       	rjmp	80006ce0 <PrintDec+0x8a>
	
	int ten = i%10;
80006c84:	e0 65 66 67 	mov	r5,26215
80006c88:	ea 15 66 66 	orh	r5,0x6666
80006c8c:	f0 05 04 44 	muls.d	r4,r8,r5
80006c90:	ea 0c 14 02 	asr	r12,r5,0x2
80006c94:	f0 09 14 1f 	asr	r9,r8,0x1f
80006c98:	f8 09 01 09 	sub	r9,r12,r9
80006c9c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ca0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006ca4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006ca6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006ca8:	e0 66 66 67 	mov	r6,26215
80006cac:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006cb0:	2d 09       	sub	r9,-48
80006cb2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006cb6:	2f fe       	sub	lr,-1
		i /= 10;
80006cb8:	f0 06 04 44 	muls.d	r4,r8,r6
80006cbc:	ea 09 14 02 	asr	r9,r5,0x2
80006cc0:	bf 58       	asr	r8,0x1f
80006cc2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006cc6:	f0 06 04 44 	muls.d	r4,r8,r6
80006cca:	ea 09 14 02 	asr	r9,r5,0x2
80006cce:	f0 05 14 1f 	asr	r5,r8,0x1f
80006cd2:	0a 19       	sub	r9,r5
80006cd4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006cd8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006cdc:	58 08       	cp.w	r8,0
80006cde:	ce 91       	brne	80006cb0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006ce0:	f6 0e 01 08 	sub	r8,r11,lr
80006ce4:	58 08       	cp.w	r8,0
80006ce6:	e0 89 00 06 	brgt	80006cf2 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006cea:	58 0e       	cp.w	lr,0
80006cec:	e0 89 00 14 	brgt	80006d14 <PrintDec+0xbe>
80006cf0:	c1 d8       	rjmp	80006d2a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006cf2:	1c 1b       	sub	r11,lr
80006cf4:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006cf6:	16 9c       	mov	r12,r11
80006cf8:	58 0b       	cp.w	r11,0
80006cfa:	fe 9a ff f8 	brle	80006cea <PrintDec+0x94>
80006cfe:	1a 99       	mov	r9,sp
80006d00:	1c 09       	add	r9,lr
80006d02:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006d04:	33 06       	mov	r6,48
80006d06:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006d08:	2f f8       	sub	r8,-1
80006d0a:	18 38       	cp.w	r8,r12
80006d0c:	cf d5       	brlt	80006d06 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006d0e:	f6 0e 00 0e 	add	lr,r11,lr
80006d12:	ce cb       	rjmp	80006cea <PrintDec+0x94>
80006d14:	fa c8 ff f4 	sub	r8,sp,-12
80006d18:	1c 08       	add	r8,lr
80006d1a:	20 d8       	sub	r8,13
80006d1c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d20:	11 89       	ld.ub	r9,r8[0x0]
80006d22:	0e c9       	st.b	r7++,r9
80006d24:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d26:	16 38       	cp.w	r8,r11
80006d28:	cf c1       	brne	80006d20 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006d2a:	14 9c       	mov	r12,r10
80006d2c:	2f dd       	sub	sp,-12
80006d2e:	d8 22       	popm	r4-r7,pc

80006d30 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006d30:	d4 31       	pushm	r0-r7,lr
80006d32:	fa cd 02 08 	sub	sp,sp,520
80006d36:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006d38:	e0 6a 01 00 	mov	r10,256
80006d3c:	30 0b       	mov	r11,0
80006d3e:	fa cc fe f8 	sub	r12,sp,-264
80006d42:	f0 1f 00 4e 	mcall	80006e78 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006d46:	fa c4 fd d4 	sub	r4,sp,-556
80006d4a:	30 0a       	mov	r10,0
80006d4c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d4e:	fa c3 ff fc 	sub	r3,sp,-4
80006d52:	e0 61 01 00 	mov	r1,256
80006d56:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006d58:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006d5a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006d5e:	02 9a       	mov	r10,r1
80006d60:	00 9b       	mov	r11,r0
80006d62:	06 9c       	mov	r12,r3
80006d64:	f0 1f 00 45 	mcall	80006e78 <log+0x148>
			
					if(*str == '%')
80006d68:	0f 88       	ld.ub	r8,r7[0x0]
80006d6a:	e4 08 18 00 	cp.b	r8,r2
80006d6e:	c5 71       	brne	80006e1c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006d70:	ee c8 ff ff 	sub	r8,r7,-1
80006d74:	11 89       	ld.ub	r9,r8[0x0]
80006d76:	4c 2a       	lddpc	r10,80006e7c <log+0x14c>
80006d78:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006d7a:	23 09       	sub	r9,48
80006d7c:	30 9a       	mov	r10,9
80006d7e:	f4 09 18 00 	cp.b	r9,r10
80006d82:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006d86:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006d8a:	f7 b9 08 30 	subls	r9,48
80006d8e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006d92:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006d96:	0f 88       	ld.ub	r8,r7[0x0]
80006d98:	22 58       	sub	r8,37
80006d9a:	e0 48 00 53 	cp.w	r8,83
80006d9e:	e0 8b 00 31 	brhi	80006e00 <log+0xd0>
80006da2:	4b 89       	lddpc	r9,80006e80 <log+0x150>
80006da4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006da8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006dac:	06 9a       	mov	r10,r3
80006dae:	40 0b       	lddsp	r11,sp[0x0]
80006db0:	5c 5b       	castu.b	r11
80006db2:	68 0c       	ld.w	r12,r4[0x0]
80006db4:	f0 1f 00 34 	mcall	80006e84 <log+0x154>
							break;
80006db8:	c2 98       	rjmp	80006e0a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006dba:	4b 4c       	lddpc	r12,80006e88 <log+0x158>
80006dbc:	f0 1f 00 34 	mcall	80006e8c <log+0x15c>
80006dc0:	08 95       	mov	r5,r4
80006dc2:	06 9c       	mov	r12,r3
							break;
80006dc4:	c2 38       	rjmp	80006e0a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006dc6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006dca:	06 9a       	mov	r10,r3
80006dcc:	40 0b       	lddsp	r11,sp[0x0]
80006dce:	5c 5b       	castu.b	r11
80006dd0:	68 0c       	ld.w	r12,r4[0x0]
80006dd2:	f0 1f 00 30 	mcall	80006e90 <log+0x160>
80006dd6:	06 9c       	mov	r12,r3
							break;
80006dd8:	c1 98       	rjmp	80006e0a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006dda:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006dde:	06 9b       	mov	r11,r3
80006de0:	09 bc       	ld.ub	r12,r4[0x3]
80006de2:	f0 1f 00 2d 	mcall	80006e94 <log+0x164>
80006de6:	06 9c       	mov	r12,r3
							break;
80006de8:	c1 18       	rjmp	80006e0a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006dea:	e8 c5 ff fc 	sub	r5,r4,-4
80006dee:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006df0:	c0 d8       	rjmp	80006e0a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006df2:	06 9b       	mov	r11,r3
80006df4:	32 5c       	mov	r12,37
80006df6:	f0 1f 00 28 	mcall	80006e94 <log+0x164>
80006dfa:	08 95       	mov	r5,r4
80006dfc:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006dfe:	c0 68       	rjmp	80006e0a <log+0xda>
							
							default:
							log("I need relax.");
80006e00:	4a 6c       	lddpc	r12,80006e98 <log+0x168>
80006e02:	f0 1f 00 23 	mcall	80006e8c <log+0x15c>
80006e06:	08 95       	mov	r5,r4
80006e08:	06 9c       	mov	r12,r3
						}
						str++;
80006e0a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006e0c:	1a dc       	st.w	--sp,r12
80006e0e:	1a d6       	st.w	--sp,r6
80006e10:	4a 3b       	lddpc	r11,80006e9c <log+0x16c>
80006e12:	0c 9c       	mov	r12,r6
80006e14:	f0 1f 00 23 	mcall	80006ea0 <log+0x170>
80006e18:	2f ed       	sub	sp,-8
80006e1a:	c0 a8       	rjmp	80006e2e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e1c:	2f f7       	sub	r7,-1
80006e1e:	1a d8       	st.w	--sp,r8
80006e20:	1a d6       	st.w	--sp,r6
80006e22:	4a 1b       	lddpc	r11,80006ea4 <log+0x174>
80006e24:	0c 9c       	mov	r12,r6
80006e26:	f0 1f 00 1f 	mcall	80006ea0 <log+0x170>
80006e2a:	08 95       	mov	r5,r4
80006e2c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006e2e:	0f 89       	ld.ub	r9,r7[0x0]
80006e30:	30 08       	mov	r8,0
80006e32:	f0 09 18 00 	cp.b	r9,r8
80006e36:	c0 30       	breq	80006e3c <log+0x10c>
80006e38:	0a 94       	mov	r4,r5
80006e3a:	c9 2b       	rjmp	80006d5e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006e3c:	fa c7 fe f8 	sub	r7,sp,-264
80006e40:	1a d7       	st.w	--sp,r7
80006e42:	49 ab       	lddpc	r11,80006ea8 <log+0x178>
80006e44:	0e 9c       	mov	r12,r7
80006e46:	f0 1f 00 17 	mcall	80006ea0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006e4a:	5c 5c       	castu.b	r12
80006e4c:	f8 c6 ff ff 	sub	r6,r12,-1
80006e50:	0c 9c       	mov	r12,r6
80006e52:	f0 1f 00 17 	mcall	80006eac <log+0x17c>
80006e56:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006e58:	0c 9a       	mov	r10,r6
80006e5a:	0e 9b       	mov	r11,r7
80006e5c:	f0 1f 00 15 	mcall	80006eb0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006e60:	30 09       	mov	r9,0
80006e62:	30 5a       	mov	r10,5
80006e64:	fa cb fe f8 	sub	r11,sp,-264
80006e68:	49 38       	lddpc	r8,80006eb4 <log+0x184>
80006e6a:	70 0c       	ld.w	r12,r8[0x0]
80006e6c:	f0 1f 00 13 	mcall	80006eb8 <log+0x188>
80006e70:	2f fd       	sub	sp,-4
	
	
}
80006e72:	fe 3d fd f8 	sub	sp,-520
80006e76:	d8 32       	popm	r0-r7,pc
80006e78:	80 00       	ld.sh	r0,r0[0x0]
80006e7a:	76 f4       	ld.w	r4,r11[0x3c]
80006e7c:	00 00       	add	r0,r0
80006e7e:	0d 58       	ld.sh	r8,--r6
80006e80:	80 00       	ld.sh	r0,r0[0x0]
80006e82:	d7 bc       	*unknown*
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	6c 56       	ld.w	r6,r6[0x14]
80006e88:	80 00       	ld.sh	r0,r0[0x0]
80006e8a:	da 68       	*unknown*
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	6d 30       	ld.w	r0,r6[0x4c]
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	6b a4       	ld.w	r4,r5[0x68]
80006e94:	80 00       	ld.sh	r0,r0[0x0]
80006e96:	6b a0       	ld.w	r0,r5[0x68]
80006e98:	80 00       	ld.sh	r0,r0[0x0]
80006e9a:	da 78       	*unknown*
80006e9c:	80 00       	ld.sh	r0,r0[0x0]
80006e9e:	da 88       	*unknown*
80006ea0:	80 00       	ld.sh	r0,r0[0x0]
80006ea2:	79 e4       	ld.w	r4,r12[0x78]
80006ea4:	80 00       	ld.sh	r0,r0[0x0]
80006ea6:	da 90       	acall	0xa9
80006ea8:	80 00       	ld.sh	r0,r0[0x0]
80006eaa:	da 98       	*unknown*
80006eac:	80 00       	ld.sh	r0,r0[0x0]
80006eae:	5d fc       	*unknown*
80006eb0:	80 00       	ld.sh	r0,r0[0x0]
80006eb2:	75 ac       	ld.w	r12,r10[0x68]
80006eb4:	00 00       	add	r0,r0
80006eb6:	5b 64       	cp.w	r4,-10
80006eb8:	80 00       	ld.sh	r0,r0[0x0]
80006eba:	61 50       	ld.w	r0,r0[0x54]

80006ebc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006ebc:	d4 31       	pushm	r0-r7,lr
80006ebe:	fa cd 02 0c 	sub	sp,sp,524
80006ec2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006ec4:	e0 6a 01 00 	mov	r10,256
80006ec8:	30 0b       	mov	r11,0
80006eca:	fa cc fe f4 	sub	r12,sp,-268
80006ece:	f0 1f 00 4c 	mcall	80006ffc <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006ed2:	fa c4 fd d0 	sub	r4,sp,-560
80006ed6:	30 0a       	mov	r10,0
80006ed8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006eda:	fa c3 ff fc 	sub	r3,sp,-4
80006ede:	e0 61 01 00 	mov	r1,256
80006ee2:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006ee4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006ee6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006eea:	02 9a       	mov	r10,r1
80006eec:	00 9b       	mov	r11,r0
80006eee:	06 9c       	mov	r12,r3
80006ef0:	f0 1f 00 43 	mcall	80006ffc <logFromISR+0x140>
			
			if(*str == '%')
80006ef4:	0f 88       	ld.ub	r8,r7[0x0]
80006ef6:	e4 08 18 00 	cp.b	r8,r2
80006efa:	c5 11       	brne	80006f9c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006efc:	ee c8 ff ff 	sub	r8,r7,-1
80006f00:	11 89       	ld.ub	r9,r8[0x0]
80006f02:	4c 0a       	lddpc	r10,80007000 <logFromISR+0x144>
80006f04:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006f06:	23 09       	sub	r9,48
80006f08:	30 9a       	mov	r10,9
80006f0a:	f4 09 18 00 	cp.b	r9,r10
80006f0e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006f12:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006f16:	f7 b9 08 30 	subls	r9,48
80006f1a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006f1e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006f22:	0f 88       	ld.ub	r8,r7[0x0]
80006f24:	22 58       	sub	r8,37
80006f26:	e0 48 00 53 	cp.w	r8,83
80006f2a:	e0 8b 00 2b 	brhi	80006f80 <logFromISR+0xc4>
80006f2e:	4b 69       	lddpc	r9,80007004 <logFromISR+0x148>
80006f30:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006f34:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006f38:	06 9a       	mov	r10,r3
80006f3a:	40 0b       	lddsp	r11,sp[0x0]
80006f3c:	5c 5b       	castu.b	r11
80006f3e:	68 0c       	ld.w	r12,r4[0x0]
80006f40:	f0 1f 00 32 	mcall	80007008 <logFromISR+0x14c>
					break;
80006f44:	c2 38       	rjmp	80006f8a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006f46:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006f4a:	06 9a       	mov	r10,r3
80006f4c:	40 0b       	lddsp	r11,sp[0x0]
80006f4e:	5c 5b       	castu.b	r11
80006f50:	68 0c       	ld.w	r12,r4[0x0]
80006f52:	f0 1f 00 2f 	mcall	8000700c <logFromISR+0x150>
80006f56:	06 9c       	mov	r12,r3
					break;
80006f58:	c1 98       	rjmp	80006f8a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006f5a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006f5e:	06 9b       	mov	r11,r3
80006f60:	09 bc       	ld.ub	r12,r4[0x3]
80006f62:	f0 1f 00 2c 	mcall	80007010 <logFromISR+0x154>
80006f66:	06 9c       	mov	r12,r3
					break;
80006f68:	c1 18       	rjmp	80006f8a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006f6a:	e8 c5 ff fc 	sub	r5,r4,-4
80006f6e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006f70:	c0 d8       	rjmp	80006f8a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006f72:	06 9b       	mov	r11,r3
80006f74:	32 5c       	mov	r12,37
80006f76:	f0 1f 00 27 	mcall	80007010 <logFromISR+0x154>
80006f7a:	08 95       	mov	r5,r4
80006f7c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006f7e:	c0 68       	rjmp	80006f8a <logFromISR+0xce>
					default:
					log("I need relax.");
80006f80:	4a 5c       	lddpc	r12,80007014 <logFromISR+0x158>
80006f82:	f0 1f 00 26 	mcall	80007018 <logFromISR+0x15c>
80006f86:	08 95       	mov	r5,r4
80006f88:	06 9c       	mov	r12,r3
				}
				str++;
80006f8a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006f8c:	1a dc       	st.w	--sp,r12
80006f8e:	1a d6       	st.w	--sp,r6
80006f90:	4a 3b       	lddpc	r11,8000701c <logFromISR+0x160>
80006f92:	0c 9c       	mov	r12,r6
80006f94:	f0 1f 00 23 	mcall	80007020 <logFromISR+0x164>
80006f98:	2f ed       	sub	sp,-8
80006f9a:	c0 a8       	rjmp	80006fae <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f9c:	2f f7       	sub	r7,-1
80006f9e:	1a d8       	st.w	--sp,r8
80006fa0:	1a d6       	st.w	--sp,r6
80006fa2:	4a 1b       	lddpc	r11,80007024 <logFromISR+0x168>
80006fa4:	0c 9c       	mov	r12,r6
80006fa6:	f0 1f 00 1f 	mcall	80007020 <logFromISR+0x164>
80006faa:	08 95       	mov	r5,r4
80006fac:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006fae:	0f 89       	ld.ub	r9,r7[0x0]
80006fb0:	30 08       	mov	r8,0
80006fb2:	f0 09 18 00 	cp.b	r9,r8
80006fb6:	c0 30       	breq	80006fbc <logFromISR+0x100>
80006fb8:	0a 94       	mov	r4,r5
80006fba:	c9 8b       	rjmp	80006eea <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006fbc:	fa c7 fe f4 	sub	r7,sp,-268
80006fc0:	1a d7       	st.w	--sp,r7
80006fc2:	49 ab       	lddpc	r11,80007028 <logFromISR+0x16c>
80006fc4:	0e 9c       	mov	r12,r7
80006fc6:	f0 1f 00 17 	mcall	80007020 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006fca:	5c 5c       	castu.b	r12
80006fcc:	f8 c6 ff ff 	sub	r6,r12,-1
80006fd0:	0c 9c       	mov	r12,r6
80006fd2:	f0 1f 00 17 	mcall	8000702c <logFromISR+0x170>
80006fd6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006fd8:	0c 9a       	mov	r10,r6
80006fda:	0e 9b       	mov	r11,r7
80006fdc:	f0 1f 00 15 	mcall	80007030 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006fe0:	30 09       	mov	r9,0
80006fe2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006fe4:	fa ca fe f8 	sub	r10,sp,-264
80006fe8:	fa cb fe f4 	sub	r11,sp,-268
80006fec:	49 28       	lddpc	r8,80007034 <logFromISR+0x178>
80006fee:	70 0c       	ld.w	r12,r8[0x0]
80006ff0:	f0 1f 00 12 	mcall	80007038 <logFromISR+0x17c>
80006ff4:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006ff6:	fe 3d fd f4 	sub	sp,-524
80006ffa:	d8 32       	popm	r0-r7,pc
80006ffc:	80 00       	ld.sh	r0,r0[0x0]
80006ffe:	76 f4       	ld.w	r4,r11[0x3c]
80007000:	00 00       	add	r0,r0
80007002:	0d 59       	ld.sh	r9,--r6
80007004:	80 00       	ld.sh	r0,r0[0x0]
80007006:	d9 0c       	*unknown*
80007008:	80 00       	ld.sh	r0,r0[0x0]
8000700a:	6c 56       	ld.w	r6,r6[0x14]
8000700c:	80 00       	ld.sh	r0,r0[0x0]
8000700e:	6b a4       	ld.w	r4,r5[0x68]
80007010:	80 00       	ld.sh	r0,r0[0x0]
80007012:	6b a0       	ld.w	r0,r5[0x68]
80007014:	80 00       	ld.sh	r0,r0[0x0]
80007016:	da 78       	*unknown*
80007018:	80 00       	ld.sh	r0,r0[0x0]
8000701a:	6d 30       	ld.w	r0,r6[0x4c]
8000701c:	80 00       	ld.sh	r0,r0[0x0]
8000701e:	da 88       	*unknown*
80007020:	80 00       	ld.sh	r0,r0[0x0]
80007022:	79 e4       	ld.w	r4,r12[0x78]
80007024:	80 00       	ld.sh	r0,r0[0x0]
80007026:	da 90       	acall	0xa9
80007028:	80 00       	ld.sh	r0,r0[0x0]
8000702a:	da 98       	*unknown*
8000702c:	80 00       	ld.sh	r0,r0[0x0]
8000702e:	5d fc       	*unknown*
80007030:	80 00       	ld.sh	r0,r0[0x0]
80007032:	75 ac       	ld.w	r12,r10[0x68]
80007034:	00 00       	add	r0,r0
80007036:	5b 64       	cp.w	r4,-10
80007038:	80 00       	ld.sh	r0,r0[0x0]
8000703a:	61 00       	ld.w	r0,r0[0x40]

8000703c <log_init>:
		
	return str;
}

void log_init(void)
{
8000703c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000703e:	30 2b       	mov	r11,2
80007040:	48 fc       	lddpc	r12,8000707c <log_init+0x40>
80007042:	f0 1f 00 10 	mcall	80007080 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007046:	e0 6a 36 00 	mov	r10,13824
8000704a:	ea 1a 01 6e 	orh	r10,0x16e
8000704e:	48 eb       	lddpc	r11,80007084 <log_init+0x48>
80007050:	fe 7c 18 00 	mov	r12,-59392
80007054:	f0 1f 00 0d 	mcall	80007088 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007058:	30 4b       	mov	r11,4
8000705a:	33 2c       	mov	r12,50
8000705c:	f0 1f 00 0c 	mcall	8000708c <log_init+0x50>
80007060:	48 c8       	lddpc	r8,80007090 <log_init+0x54>
80007062:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007064:	30 09       	mov	r9,0
80007066:	1a d9       	st.w	--sp,r9
80007068:	1a d9       	st.w	--sp,r9
8000706a:	1a d9       	st.w	--sp,r9
8000706c:	30 28       	mov	r8,2
8000706e:	36 4a       	mov	r10,100
80007070:	48 9b       	lddpc	r11,80007094 <log_init+0x58>
80007072:	48 ac       	lddpc	r12,80007098 <log_init+0x5c>
80007074:	f0 1f 00 0a 	mcall	8000709c <log_init+0x60>
80007078:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000707a:	d8 02       	popm	pc
8000707c:	80 00       	ld.sh	r0,r0[0x0]
8000707e:	da a4       	*unknown*
80007080:	80 00       	ld.sh	r0,r0[0x0]
80007082:	52 dc       	stdsp	sp[0xb4],r12
80007084:	80 00       	ld.sh	r0,r0[0x0]
80007086:	da 5c       	*unknown*
80007088:	80 00       	ld.sh	r0,r0[0x0]
8000708a:	59 60       	cp.w	r0,22
8000708c:	80 00       	ld.sh	r0,r0[0x0]
8000708e:	62 50       	ld.w	r0,r1[0x14]
80007090:	00 00       	add	r0,r0
80007092:	5b 64       	cp.w	r4,-10
80007094:	80 00       	ld.sh	r0,r0[0x0]
80007096:	da a0       	acall	0xaa
80007098:	80 00       	ld.sh	r0,r0[0x0]
8000709a:	70 a0       	ld.w	r0,r8[0x28]
8000709c:	80 00       	ld.sh	r0,r0[0x0]
8000709e:	69 6c       	ld.w	r12,r4[0x58]

800070a0 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800070a0:	eb cd 40 f8 	pushm	r3-r7,lr
800070a4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070a6:	48 c7       	lddpc	r7,800070d4 <task_log+0x34>
800070a8:	30 05       	mov	r5,0
800070aa:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800070ac:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800070b0:	0a 99       	mov	r9,r5
800070b2:	08 9a       	mov	r10,r4
800070b4:	1a 9b       	mov	r11,sp
800070b6:	6e 0c       	ld.w	r12,r7[0x0]
800070b8:	f0 1f 00 08 	mcall	800070d8 <task_log+0x38>
800070bc:	58 1c       	cp.w	r12,1
800070be:	cf 91       	brne	800070b0 <task_log+0x10>
		{
			if( NULL != str)
800070c0:	40 0b       	lddsp	r11,sp[0x0]
800070c2:	58 0b       	cp.w	r11,0
800070c4:	cf 60       	breq	800070b0 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800070c6:	06 9c       	mov	r12,r3
800070c8:	f0 1f 00 05 	mcall	800070dc <task_log+0x3c>
				vPortFree(str);
800070cc:	40 0c       	lddsp	r12,sp[0x0]
800070ce:	f0 1f 00 05 	mcall	800070e0 <task_log+0x40>
800070d2:	ce fb       	rjmp	800070b0 <task_log+0x10>
800070d4:	00 00       	add	r0,r0
800070d6:	5b 64       	cp.w	r4,-10
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	5f 44       	srge	r4
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	59 10       	cp.w	r0,17
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	5d d4       	*unknown*

800070e4 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800070e4:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800070e6:	fe 78 10 00 	mov	r8,-61440
800070ea:	30 19       	mov	r9,1
800070ec:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800070f0:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800070f4:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800070f8:	d3 03       	ssrf	0x10
	local_start_pll0();
800070fa:	f0 1f 00 0c 	mcall	80007128 <main+0x44>
		
	INTC_init_interrupts();
800070fe:	f0 1f 00 0c 	mcall	8000712c <main+0x48>
		
	log_init();
80007102:	f0 1f 00 0c 	mcall	80007130 <main+0x4c>
	log("----start debug----");
80007106:	48 cc       	lddpc	r12,80007134 <main+0x50>
80007108:	f0 1f 00 0c 	mcall	80007138 <main+0x54>
	
	xg_flashc_init();
8000710c:	f0 1f 00 0c 	mcall	8000713c <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007110:	f0 1f 00 0c 	mcall	80007140 <main+0x5c>
		
	app_init();
80007114:	f0 1f 00 0c 	mcall	80007144 <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
80007118:	f0 1f 00 0c 	mcall	80007148 <main+0x64>

	local_start_timer();
8000711c:	f0 1f 00 0c 	mcall	8000714c <main+0x68>
		
	vTaskStartScheduler();
80007120:	f0 1f 00 0c 	mcall	80007150 <main+0x6c>
	return 0;
	
}
80007124:	d8 0a       	popm	pc,r12=0
80007126:	00 00       	add	r0,r0
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	51 9c       	stdsp	sp[0x64],r12
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	53 e0       	stdsp	sp[0xf8],r0
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	70 3c       	ld.w	r12,r8[0xc]
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	da b4       	*unknown*
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	6d 30       	ld.w	r0,r6[0x4c]
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	52 30       	stdsp	sp[0x8c],r0
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	50 fc       	stdsp	sp[0x3c],r12
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	20 3c       	sub	r12,3
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	3f a0       	mov	r0,-6
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	51 70       	stdsp	sp[0x5c],r0
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	6b 54       	ld.w	r4,r5[0x54]

80007154 <free>:
80007154:	d4 01       	pushm	lr
80007156:	e0 68 0a 3c 	mov	r8,2620
8000715a:	18 9b       	mov	r11,r12
8000715c:	70 0c       	ld.w	r12,r8[0x0]
8000715e:	e0 a0 1e 61 	rcall	8000ae20 <_free_r>
80007162:	d8 02       	popm	pc

80007164 <malloc>:
80007164:	d4 01       	pushm	lr
80007166:	e0 68 0a 3c 	mov	r8,2620
8000716a:	18 9b       	mov	r11,r12
8000716c:	70 0c       	ld.w	r12,r8[0x0]
8000716e:	c0 3c       	rcall	80007174 <_malloc_r>
80007170:	d8 02       	popm	pc
80007172:	d7 03       	nop

80007174 <_malloc_r>:
80007174:	d4 31       	pushm	r0-r7,lr
80007176:	f6 c8 ff f5 	sub	r8,r11,-11
8000717a:	18 95       	mov	r5,r12
8000717c:	10 97       	mov	r7,r8
8000717e:	e0 17 ff f8 	andl	r7,0xfff8
80007182:	59 68       	cp.w	r8,22
80007184:	f9 b7 08 10 	movls	r7,16
80007188:	16 37       	cp.w	r7,r11
8000718a:	5f 38       	srlo	r8
8000718c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007190:	c0 50       	breq	8000719a <_malloc_r+0x26>
80007192:	30 c8       	mov	r8,12
80007194:	99 38       	st.w	r12[0xc],r8
80007196:	e0 8f 01 fa 	bral	8000758a <_malloc_r+0x416>
8000719a:	fe b0 f5 d3 	rcall	80005d40 <__malloc_lock>
8000719e:	e0 47 01 f7 	cp.w	r7,503
800071a2:	e0 8b 00 1d 	brhi	800071dc <_malloc_r+0x68>
800071a6:	ee 03 16 03 	lsr	r3,r7,0x3
800071aa:	e0 68 05 3c 	mov	r8,1340
800071ae:	f0 03 00 38 	add	r8,r8,r3<<0x3
800071b2:	70 36       	ld.w	r6,r8[0xc]
800071b4:	10 36       	cp.w	r6,r8
800071b6:	c0 61       	brne	800071c2 <_malloc_r+0x4e>
800071b8:	ec c8 ff f8 	sub	r8,r6,-8
800071bc:	70 36       	ld.w	r6,r8[0xc]
800071be:	10 36       	cp.w	r6,r8
800071c0:	c0 c0       	breq	800071d8 <_malloc_r+0x64>
800071c2:	6c 18       	ld.w	r8,r6[0x4]
800071c4:	e0 18 ff fc 	andl	r8,0xfffc
800071c8:	6c 3a       	ld.w	r10,r6[0xc]
800071ca:	ec 08 00 09 	add	r9,r6,r8
800071ce:	0a 9c       	mov	r12,r5
800071d0:	6c 28       	ld.w	r8,r6[0x8]
800071d2:	95 28       	st.w	r10[0x8],r8
800071d4:	91 3a       	st.w	r8[0xc],r10
800071d6:	c4 78       	rjmp	80007264 <_malloc_r+0xf0>
800071d8:	2f e3       	sub	r3,-2
800071da:	c4 d8       	rjmp	80007274 <_malloc_r+0x100>
800071dc:	ee 03 16 09 	lsr	r3,r7,0x9
800071e0:	c0 41       	brne	800071e8 <_malloc_r+0x74>
800071e2:	ee 03 16 03 	lsr	r3,r7,0x3
800071e6:	c2 68       	rjmp	80007232 <_malloc_r+0xbe>
800071e8:	58 43       	cp.w	r3,4
800071ea:	e0 8b 00 06 	brhi	800071f6 <_malloc_r+0x82>
800071ee:	ee 03 16 06 	lsr	r3,r7,0x6
800071f2:	2c 83       	sub	r3,-56
800071f4:	c1 f8       	rjmp	80007232 <_malloc_r+0xbe>
800071f6:	59 43       	cp.w	r3,20
800071f8:	e0 8b 00 04 	brhi	80007200 <_malloc_r+0x8c>
800071fc:	2a 53       	sub	r3,-91
800071fe:	c1 a8       	rjmp	80007232 <_malloc_r+0xbe>
80007200:	e0 43 00 54 	cp.w	r3,84
80007204:	e0 8b 00 06 	brhi	80007210 <_malloc_r+0x9c>
80007208:	ee 03 16 0c 	lsr	r3,r7,0xc
8000720c:	29 23       	sub	r3,-110
8000720e:	c1 28       	rjmp	80007232 <_malloc_r+0xbe>
80007210:	e0 43 01 54 	cp.w	r3,340
80007214:	e0 8b 00 06 	brhi	80007220 <_malloc_r+0xac>
80007218:	ee 03 16 0f 	lsr	r3,r7,0xf
8000721c:	28 93       	sub	r3,-119
8000721e:	c0 a8       	rjmp	80007232 <_malloc_r+0xbe>
80007220:	e0 43 05 54 	cp.w	r3,1364
80007224:	e0 88 00 04 	brls	8000722c <_malloc_r+0xb8>
80007228:	37 e3       	mov	r3,126
8000722a:	c0 48       	rjmp	80007232 <_malloc_r+0xbe>
8000722c:	ee 03 16 12 	lsr	r3,r7,0x12
80007230:	28 43       	sub	r3,-124
80007232:	e0 6a 05 3c 	mov	r10,1340
80007236:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000723a:	74 36       	ld.w	r6,r10[0xc]
8000723c:	c1 98       	rjmp	8000726e <_malloc_r+0xfa>
8000723e:	6c 19       	ld.w	r9,r6[0x4]
80007240:	e0 19 ff fc 	andl	r9,0xfffc
80007244:	f2 07 01 0b 	sub	r11,r9,r7
80007248:	58 fb       	cp.w	r11,15
8000724a:	e0 8a 00 04 	brle	80007252 <_malloc_r+0xde>
8000724e:	20 13       	sub	r3,1
80007250:	c1 18       	rjmp	80007272 <_malloc_r+0xfe>
80007252:	6c 38       	ld.w	r8,r6[0xc]
80007254:	58 0b       	cp.w	r11,0
80007256:	c0 b5       	brlt	8000726c <_malloc_r+0xf8>
80007258:	6c 2a       	ld.w	r10,r6[0x8]
8000725a:	ec 09 00 09 	add	r9,r6,r9
8000725e:	0a 9c       	mov	r12,r5
80007260:	91 2a       	st.w	r8[0x8],r10
80007262:	95 38       	st.w	r10[0xc],r8
80007264:	72 18       	ld.w	r8,r9[0x4]
80007266:	a1 a8       	sbr	r8,0x0
80007268:	93 18       	st.w	r9[0x4],r8
8000726a:	cb c8       	rjmp	800073e2 <_malloc_r+0x26e>
8000726c:	10 96       	mov	r6,r8
8000726e:	14 36       	cp.w	r6,r10
80007270:	ce 71       	brne	8000723e <_malloc_r+0xca>
80007272:	2f f3       	sub	r3,-1
80007274:	e0 6a 05 3c 	mov	r10,1340
80007278:	f4 cc ff f8 	sub	r12,r10,-8
8000727c:	78 26       	ld.w	r6,r12[0x8]
8000727e:	18 36       	cp.w	r6,r12
80007280:	c6 c0       	breq	80007358 <_malloc_r+0x1e4>
80007282:	6c 19       	ld.w	r9,r6[0x4]
80007284:	e0 19 ff fc 	andl	r9,0xfffc
80007288:	f2 07 01 08 	sub	r8,r9,r7
8000728c:	58 f8       	cp.w	r8,15
8000728e:	e0 89 00 8f 	brgt	800073ac <_malloc_r+0x238>
80007292:	99 3c       	st.w	r12[0xc],r12
80007294:	99 2c       	st.w	r12[0x8],r12
80007296:	58 08       	cp.w	r8,0
80007298:	c0 55       	brlt	800072a2 <_malloc_r+0x12e>
8000729a:	ec 09 00 09 	add	r9,r6,r9
8000729e:	0a 9c       	mov	r12,r5
800072a0:	ce 2b       	rjmp	80007264 <_malloc_r+0xf0>
800072a2:	e0 49 01 ff 	cp.w	r9,511
800072a6:	e0 8b 00 13 	brhi	800072cc <_malloc_r+0x158>
800072aa:	a3 99       	lsr	r9,0x3
800072ac:	f4 09 00 38 	add	r8,r10,r9<<0x3
800072b0:	70 2b       	ld.w	r11,r8[0x8]
800072b2:	8d 38       	st.w	r6[0xc],r8
800072b4:	8d 2b       	st.w	r6[0x8],r11
800072b6:	97 36       	st.w	r11[0xc],r6
800072b8:	91 26       	st.w	r8[0x8],r6
800072ba:	a3 49       	asr	r9,0x2
800072bc:	74 18       	ld.w	r8,r10[0x4]
800072be:	30 1b       	mov	r11,1
800072c0:	f6 09 09 49 	lsl	r9,r11,r9
800072c4:	f1 e9 10 09 	or	r9,r8,r9
800072c8:	95 19       	st.w	r10[0x4],r9
800072ca:	c4 78       	rjmp	80007358 <_malloc_r+0x1e4>
800072cc:	f2 0a 16 09 	lsr	r10,r9,0x9
800072d0:	58 4a       	cp.w	r10,4
800072d2:	e0 8b 00 07 	brhi	800072e0 <_malloc_r+0x16c>
800072d6:	f2 0a 16 06 	lsr	r10,r9,0x6
800072da:	2c 8a       	sub	r10,-56
800072dc:	c2 08       	rjmp	8000731c <_malloc_r+0x1a8>
800072de:	d7 03       	nop
800072e0:	59 4a       	cp.w	r10,20
800072e2:	e0 8b 00 04 	brhi	800072ea <_malloc_r+0x176>
800072e6:	2a 5a       	sub	r10,-91
800072e8:	c1 a8       	rjmp	8000731c <_malloc_r+0x1a8>
800072ea:	e0 4a 00 54 	cp.w	r10,84
800072ee:	e0 8b 00 06 	brhi	800072fa <_malloc_r+0x186>
800072f2:	f2 0a 16 0c 	lsr	r10,r9,0xc
800072f6:	29 2a       	sub	r10,-110
800072f8:	c1 28       	rjmp	8000731c <_malloc_r+0x1a8>
800072fa:	e0 4a 01 54 	cp.w	r10,340
800072fe:	e0 8b 00 06 	brhi	8000730a <_malloc_r+0x196>
80007302:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007306:	28 9a       	sub	r10,-119
80007308:	c0 a8       	rjmp	8000731c <_malloc_r+0x1a8>
8000730a:	e0 4a 05 54 	cp.w	r10,1364
8000730e:	e0 88 00 04 	brls	80007316 <_malloc_r+0x1a2>
80007312:	37 ea       	mov	r10,126
80007314:	c0 48       	rjmp	8000731c <_malloc_r+0x1a8>
80007316:	f2 0a 16 12 	lsr	r10,r9,0x12
8000731a:	28 4a       	sub	r10,-124
8000731c:	e0 6b 05 3c 	mov	r11,1340
80007320:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007324:	68 28       	ld.w	r8,r4[0x8]
80007326:	08 38       	cp.w	r8,r4
80007328:	c0 e1       	brne	80007344 <_malloc_r+0x1d0>
8000732a:	76 19       	ld.w	r9,r11[0x4]
8000732c:	a3 4a       	asr	r10,0x2
8000732e:	30 1e       	mov	lr,1
80007330:	fc 0a 09 4a 	lsl	r10,lr,r10
80007334:	f3 ea 10 0a 	or	r10,r9,r10
80007338:	10 99       	mov	r9,r8
8000733a:	97 1a       	st.w	r11[0x4],r10
8000733c:	c0 a8       	rjmp	80007350 <_malloc_r+0x1dc>
8000733e:	70 28       	ld.w	r8,r8[0x8]
80007340:	08 38       	cp.w	r8,r4
80007342:	c0 60       	breq	8000734e <_malloc_r+0x1da>
80007344:	70 1a       	ld.w	r10,r8[0x4]
80007346:	e0 1a ff fc 	andl	r10,0xfffc
8000734a:	14 39       	cp.w	r9,r10
8000734c:	cf 93       	brcs	8000733e <_malloc_r+0x1ca>
8000734e:	70 39       	ld.w	r9,r8[0xc]
80007350:	8d 39       	st.w	r6[0xc],r9
80007352:	8d 28       	st.w	r6[0x8],r8
80007354:	91 36       	st.w	r8[0xc],r6
80007356:	93 26       	st.w	r9[0x8],r6
80007358:	e6 08 14 02 	asr	r8,r3,0x2
8000735c:	30 1b       	mov	r11,1
8000735e:	e0 64 05 3c 	mov	r4,1340
80007362:	f6 08 09 4b 	lsl	r11,r11,r8
80007366:	68 18       	ld.w	r8,r4[0x4]
80007368:	10 3b       	cp.w	r11,r8
8000736a:	e0 8b 00 6b 	brhi	80007440 <_malloc_r+0x2cc>
8000736e:	f7 e8 00 09 	and	r9,r11,r8
80007372:	c0 b1       	brne	80007388 <_malloc_r+0x214>
80007374:	e0 13 ff fc 	andl	r3,0xfffc
80007378:	a1 7b       	lsl	r11,0x1
8000737a:	2f c3       	sub	r3,-4
8000737c:	c0 38       	rjmp	80007382 <_malloc_r+0x20e>
8000737e:	2f c3       	sub	r3,-4
80007380:	a1 7b       	lsl	r11,0x1
80007382:	f7 e8 00 09 	and	r9,r11,r8
80007386:	cf c0       	breq	8000737e <_malloc_r+0x20a>
80007388:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000738c:	06 92       	mov	r2,r3
8000738e:	1c 91       	mov	r1,lr
80007390:	62 36       	ld.w	r6,r1[0xc]
80007392:	c2 e8       	rjmp	800073ee <_malloc_r+0x27a>
80007394:	6c 1a       	ld.w	r10,r6[0x4]
80007396:	e0 1a ff fc 	andl	r10,0xfffc
8000739a:	f4 07 01 08 	sub	r8,r10,r7
8000739e:	58 f8       	cp.w	r8,15
800073a0:	e0 8a 00 15 	brle	800073ca <_malloc_r+0x256>
800073a4:	6c 3a       	ld.w	r10,r6[0xc]
800073a6:	6c 29       	ld.w	r9,r6[0x8]
800073a8:	95 29       	st.w	r10[0x8],r9
800073aa:	93 3a       	st.w	r9[0xc],r10
800073ac:	0e 99       	mov	r9,r7
800073ae:	ec 07 00 07 	add	r7,r6,r7
800073b2:	a1 a9       	sbr	r9,0x0
800073b4:	99 37       	st.w	r12[0xc],r7
800073b6:	99 27       	st.w	r12[0x8],r7
800073b8:	8d 19       	st.w	r6[0x4],r9
800073ba:	ee 08 09 08 	st.w	r7[r8],r8
800073be:	8f 2c       	st.w	r7[0x8],r12
800073c0:	8f 3c       	st.w	r7[0xc],r12
800073c2:	a1 a8       	sbr	r8,0x0
800073c4:	0a 9c       	mov	r12,r5
800073c6:	8f 18       	st.w	r7[0x4],r8
800073c8:	c0 d8       	rjmp	800073e2 <_malloc_r+0x26e>
800073ca:	6c 39       	ld.w	r9,r6[0xc]
800073cc:	58 08       	cp.w	r8,0
800073ce:	c0 f5       	brlt	800073ec <_malloc_r+0x278>
800073d0:	ec 0a 00 0a 	add	r10,r6,r10
800073d4:	74 18       	ld.w	r8,r10[0x4]
800073d6:	a1 a8       	sbr	r8,0x0
800073d8:	0a 9c       	mov	r12,r5
800073da:	95 18       	st.w	r10[0x4],r8
800073dc:	6c 28       	ld.w	r8,r6[0x8]
800073de:	93 28       	st.w	r9[0x8],r8
800073e0:	91 39       	st.w	r8[0xc],r9
800073e2:	fe b0 f4 b5 	rcall	80005d4c <__malloc_unlock>
800073e6:	ec cc ff f8 	sub	r12,r6,-8
800073ea:	d8 32       	popm	r0-r7,pc
800073ec:	12 96       	mov	r6,r9
800073ee:	02 36       	cp.w	r6,r1
800073f0:	cd 21       	brne	80007394 <_malloc_r+0x220>
800073f2:	2f f2       	sub	r2,-1
800073f4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800073f8:	c0 30       	breq	800073fe <_malloc_r+0x28a>
800073fa:	2f 81       	sub	r1,-8
800073fc:	cc ab       	rjmp	80007390 <_malloc_r+0x21c>
800073fe:	1c 98       	mov	r8,lr
80007400:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007404:	c0 81       	brne	80007414 <_malloc_r+0x2a0>
80007406:	68 19       	ld.w	r9,r4[0x4]
80007408:	f6 08 11 ff 	rsub	r8,r11,-1
8000740c:	f3 e8 00 08 	and	r8,r9,r8
80007410:	89 18       	st.w	r4[0x4],r8
80007412:	c0 78       	rjmp	80007420 <_malloc_r+0x2ac>
80007414:	f0 c9 00 08 	sub	r9,r8,8
80007418:	20 13       	sub	r3,1
8000741a:	70 08       	ld.w	r8,r8[0x0]
8000741c:	12 38       	cp.w	r8,r9
8000741e:	cf 10       	breq	80007400 <_malloc_r+0x28c>
80007420:	a1 7b       	lsl	r11,0x1
80007422:	68 18       	ld.w	r8,r4[0x4]
80007424:	10 3b       	cp.w	r11,r8
80007426:	e0 8b 00 0d 	brhi	80007440 <_malloc_r+0x2cc>
8000742a:	58 0b       	cp.w	r11,0
8000742c:	c0 a0       	breq	80007440 <_malloc_r+0x2cc>
8000742e:	04 93       	mov	r3,r2
80007430:	c0 38       	rjmp	80007436 <_malloc_r+0x2c2>
80007432:	2f c3       	sub	r3,-4
80007434:	a1 7b       	lsl	r11,0x1
80007436:	f7 e8 00 09 	and	r9,r11,r8
8000743a:	ca 71       	brne	80007388 <_malloc_r+0x214>
8000743c:	cf bb       	rjmp	80007432 <_malloc_r+0x2be>
8000743e:	d7 03       	nop
80007440:	68 23       	ld.w	r3,r4[0x8]
80007442:	66 12       	ld.w	r2,r3[0x4]
80007444:	e0 12 ff fc 	andl	r2,0xfffc
80007448:	0e 32       	cp.w	r2,r7
8000744a:	5f 39       	srlo	r9
8000744c:	e4 07 01 08 	sub	r8,r2,r7
80007450:	58 f8       	cp.w	r8,15
80007452:	5f aa       	srle	r10
80007454:	f5 e9 10 09 	or	r9,r10,r9
80007458:	e0 80 00 9a 	breq	8000758c <_malloc_r+0x418>
8000745c:	e0 68 0d 64 	mov	r8,3428
80007460:	70 01       	ld.w	r1,r8[0x0]
80007462:	e0 68 09 48 	mov	r8,2376
80007466:	2f 01       	sub	r1,-16
80007468:	70 08       	ld.w	r8,r8[0x0]
8000746a:	0e 01       	add	r1,r7
8000746c:	5b f8       	cp.w	r8,-1
8000746e:	c0 40       	breq	80007476 <_malloc_r+0x302>
80007470:	28 11       	sub	r1,-127
80007472:	e0 11 ff 80 	andl	r1,0xff80
80007476:	02 9b       	mov	r11,r1
80007478:	0a 9c       	mov	r12,r5
8000747a:	e0 a0 02 a5 	rcall	800079c4 <_sbrk_r>
8000747e:	18 96       	mov	r6,r12
80007480:	5b fc       	cp.w	r12,-1
80007482:	c7 50       	breq	8000756c <_malloc_r+0x3f8>
80007484:	e6 02 00 08 	add	r8,r3,r2
80007488:	10 3c       	cp.w	r12,r8
8000748a:	c0 32       	brcc	80007490 <_malloc_r+0x31c>
8000748c:	08 33       	cp.w	r3,r4
8000748e:	c6 f1       	brne	8000756c <_malloc_r+0x3f8>
80007490:	e0 6a 0d 68 	mov	r10,3432
80007494:	74 09       	ld.w	r9,r10[0x0]
80007496:	e2 09 00 09 	add	r9,r1,r9
8000749a:	95 09       	st.w	r10[0x0],r9
8000749c:	10 36       	cp.w	r6,r8
8000749e:	c0 a1       	brne	800074b2 <_malloc_r+0x33e>
800074a0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800074a4:	c0 71       	brne	800074b2 <_malloc_r+0x33e>
800074a6:	e2 02 00 02 	add	r2,r1,r2
800074aa:	68 28       	ld.w	r8,r4[0x8]
800074ac:	a1 a2       	sbr	r2,0x0
800074ae:	91 12       	st.w	r8[0x4],r2
800074b0:	c4 f8       	rjmp	8000754e <_malloc_r+0x3da>
800074b2:	e0 6a 09 48 	mov	r10,2376
800074b6:	74 0b       	ld.w	r11,r10[0x0]
800074b8:	5b fb       	cp.w	r11,-1
800074ba:	c0 31       	brne	800074c0 <_malloc_r+0x34c>
800074bc:	95 06       	st.w	r10[0x0],r6
800074be:	c0 78       	rjmp	800074cc <_malloc_r+0x358>
800074c0:	ec 09 00 09 	add	r9,r6,r9
800074c4:	e0 6a 0d 68 	mov	r10,3432
800074c8:	10 19       	sub	r9,r8
800074ca:	95 09       	st.w	r10[0x0],r9
800074cc:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800074d0:	f0 09 11 08 	rsub	r9,r8,8
800074d4:	58 08       	cp.w	r8,0
800074d6:	f2 08 17 10 	movne	r8,r9
800074da:	ed d8 e1 06 	addne	r6,r6,r8
800074de:	28 08       	sub	r8,-128
800074e0:	ec 01 00 01 	add	r1,r6,r1
800074e4:	0a 9c       	mov	r12,r5
800074e6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800074ea:	f0 01 01 01 	sub	r1,r8,r1
800074ee:	02 9b       	mov	r11,r1
800074f0:	e0 a0 02 6a 	rcall	800079c4 <_sbrk_r>
800074f4:	e0 68 0d 68 	mov	r8,3432
800074f8:	5b fc       	cp.w	r12,-1
800074fa:	ec 0c 17 00 	moveq	r12,r6
800074fe:	f9 b1 00 00 	moveq	r1,0
80007502:	70 09       	ld.w	r9,r8[0x0]
80007504:	0c 1c       	sub	r12,r6
80007506:	89 26       	st.w	r4[0x8],r6
80007508:	02 0c       	add	r12,r1
8000750a:	12 01       	add	r1,r9
8000750c:	a1 ac       	sbr	r12,0x0
8000750e:	91 01       	st.w	r8[0x0],r1
80007510:	8d 1c       	st.w	r6[0x4],r12
80007512:	08 33       	cp.w	r3,r4
80007514:	c1 d0       	breq	8000754e <_malloc_r+0x3da>
80007516:	58 f2       	cp.w	r2,15
80007518:	e0 8b 00 05 	brhi	80007522 <_malloc_r+0x3ae>
8000751c:	30 18       	mov	r8,1
8000751e:	8d 18       	st.w	r6[0x4],r8
80007520:	c2 68       	rjmp	8000756c <_malloc_r+0x3f8>
80007522:	30 59       	mov	r9,5
80007524:	20 c2       	sub	r2,12
80007526:	e0 12 ff f8 	andl	r2,0xfff8
8000752a:	e6 02 00 08 	add	r8,r3,r2
8000752e:	91 29       	st.w	r8[0x8],r9
80007530:	91 19       	st.w	r8[0x4],r9
80007532:	66 18       	ld.w	r8,r3[0x4]
80007534:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007538:	e5 e8 10 08 	or	r8,r2,r8
8000753c:	87 18       	st.w	r3[0x4],r8
8000753e:	58 f2       	cp.w	r2,15
80007540:	e0 88 00 07 	brls	8000754e <_malloc_r+0x3da>
80007544:	e6 cb ff f8 	sub	r11,r3,-8
80007548:	0a 9c       	mov	r12,r5
8000754a:	e0 a0 1c 6b 	rcall	8000ae20 <_free_r>
8000754e:	e0 69 0d 60 	mov	r9,3424
80007552:	72 0a       	ld.w	r10,r9[0x0]
80007554:	e0 68 0d 68 	mov	r8,3432
80007558:	70 08       	ld.w	r8,r8[0x0]
8000755a:	14 38       	cp.w	r8,r10
8000755c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007560:	e0 69 0d 5c 	mov	r9,3420
80007564:	72 0a       	ld.w	r10,r9[0x0]
80007566:	14 38       	cp.w	r8,r10
80007568:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000756c:	68 28       	ld.w	r8,r4[0x8]
8000756e:	70 18       	ld.w	r8,r8[0x4]
80007570:	e0 18 ff fc 	andl	r8,0xfffc
80007574:	0e 38       	cp.w	r8,r7
80007576:	5f 39       	srlo	r9
80007578:	0e 18       	sub	r8,r7
8000757a:	58 f8       	cp.w	r8,15
8000757c:	5f aa       	srle	r10
8000757e:	f5 e9 10 09 	or	r9,r10,r9
80007582:	c0 50       	breq	8000758c <_malloc_r+0x418>
80007584:	0a 9c       	mov	r12,r5
80007586:	fe b0 f3 e3 	rcall	80005d4c <__malloc_unlock>
8000758a:	d8 3a       	popm	r0-r7,pc,r12=0
8000758c:	68 26       	ld.w	r6,r4[0x8]
8000758e:	a1 a8       	sbr	r8,0x0
80007590:	0e 99       	mov	r9,r7
80007592:	a1 a9       	sbr	r9,0x0
80007594:	8d 19       	st.w	r6[0x4],r9
80007596:	ec 07 00 07 	add	r7,r6,r7
8000759a:	0a 9c       	mov	r12,r5
8000759c:	89 27       	st.w	r4[0x8],r7
8000759e:	8f 18       	st.w	r7[0x4],r8
800075a0:	fe b0 f3 d6 	rcall	80005d4c <__malloc_unlock>
800075a4:	ec cc ff f8 	sub	r12,r6,-8
800075a8:	d8 32       	popm	r0-r7,pc
800075aa:	d7 03       	nop

800075ac <memcpy>:
800075ac:	58 8a       	cp.w	r10,8
800075ae:	c2 f5       	brlt	8000760c <memcpy+0x60>
800075b0:	f9 eb 10 09 	or	r9,r12,r11
800075b4:	e2 19 00 03 	andl	r9,0x3,COH
800075b8:	e0 81 00 97 	brne	800076e6 <memcpy+0x13a>
800075bc:	e0 4a 00 20 	cp.w	r10,32
800075c0:	c3 b4       	brge	80007636 <memcpy+0x8a>
800075c2:	f4 08 14 02 	asr	r8,r10,0x2
800075c6:	f0 09 11 08 	rsub	r9,r8,8
800075ca:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800075ce:	76 69       	ld.w	r9,r11[0x18]
800075d0:	99 69       	st.w	r12[0x18],r9
800075d2:	76 59       	ld.w	r9,r11[0x14]
800075d4:	99 59       	st.w	r12[0x14],r9
800075d6:	76 49       	ld.w	r9,r11[0x10]
800075d8:	99 49       	st.w	r12[0x10],r9
800075da:	76 39       	ld.w	r9,r11[0xc]
800075dc:	99 39       	st.w	r12[0xc],r9
800075de:	76 29       	ld.w	r9,r11[0x8]
800075e0:	99 29       	st.w	r12[0x8],r9
800075e2:	76 19       	ld.w	r9,r11[0x4]
800075e4:	99 19       	st.w	r12[0x4],r9
800075e6:	76 09       	ld.w	r9,r11[0x0]
800075e8:	99 09       	st.w	r12[0x0],r9
800075ea:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800075ee:	f8 08 00 28 	add	r8,r12,r8<<0x2
800075f2:	e0 1a 00 03 	andl	r10,0x3
800075f6:	f4 0a 11 04 	rsub	r10,r10,4
800075fa:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800075fe:	17 a9       	ld.ub	r9,r11[0x2]
80007600:	b0 a9       	st.b	r8[0x2],r9
80007602:	17 99       	ld.ub	r9,r11[0x1]
80007604:	b0 99       	st.b	r8[0x1],r9
80007606:	17 89       	ld.ub	r9,r11[0x0]
80007608:	b0 89       	st.b	r8[0x0],r9
8000760a:	5e fc       	retal	r12
8000760c:	f4 0a 11 09 	rsub	r10,r10,9
80007610:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007614:	17 f9       	ld.ub	r9,r11[0x7]
80007616:	b8 f9       	st.b	r12[0x7],r9
80007618:	17 e9       	ld.ub	r9,r11[0x6]
8000761a:	b8 e9       	st.b	r12[0x6],r9
8000761c:	17 d9       	ld.ub	r9,r11[0x5]
8000761e:	b8 d9       	st.b	r12[0x5],r9
80007620:	17 c9       	ld.ub	r9,r11[0x4]
80007622:	b8 c9       	st.b	r12[0x4],r9
80007624:	17 b9       	ld.ub	r9,r11[0x3]
80007626:	b8 b9       	st.b	r12[0x3],r9
80007628:	17 a9       	ld.ub	r9,r11[0x2]
8000762a:	b8 a9       	st.b	r12[0x2],r9
8000762c:	17 99       	ld.ub	r9,r11[0x1]
8000762e:	b8 99       	st.b	r12[0x1],r9
80007630:	17 89       	ld.ub	r9,r11[0x0]
80007632:	b8 89       	st.b	r12[0x0],r9
80007634:	5e fc       	retal	r12
80007636:	eb cd 40 c0 	pushm	r6-r7,lr
8000763a:	18 99       	mov	r9,r12
8000763c:	22 0a       	sub	r10,32
8000763e:	b7 07       	ld.d	r6,r11++
80007640:	b3 26       	st.d	r9++,r6
80007642:	b7 07       	ld.d	r6,r11++
80007644:	b3 26       	st.d	r9++,r6
80007646:	b7 07       	ld.d	r6,r11++
80007648:	b3 26       	st.d	r9++,r6
8000764a:	b7 07       	ld.d	r6,r11++
8000764c:	b3 26       	st.d	r9++,r6
8000764e:	22 0a       	sub	r10,32
80007650:	cf 74       	brge	8000763e <memcpy+0x92>
80007652:	2f 0a       	sub	r10,-16
80007654:	c0 65       	brlt	80007660 <memcpy+0xb4>
80007656:	b7 07       	ld.d	r6,r11++
80007658:	b3 26       	st.d	r9++,r6
8000765a:	b7 07       	ld.d	r6,r11++
8000765c:	b3 26       	st.d	r9++,r6
8000765e:	21 0a       	sub	r10,16
80007660:	5c 3a       	neg	r10
80007662:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007666:	d7 03       	nop
80007668:	d7 03       	nop
8000766a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000766e:	f3 66 00 0e 	st.b	r9[14],r6
80007672:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007676:	f3 66 00 0d 	st.b	r9[13],r6
8000767a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000767e:	f3 66 00 0c 	st.b	r9[12],r6
80007682:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007686:	f3 66 00 0b 	st.b	r9[11],r6
8000768a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000768e:	f3 66 00 0a 	st.b	r9[10],r6
80007692:	f7 36 00 09 	ld.ub	r6,r11[9]
80007696:	f3 66 00 09 	st.b	r9[9],r6
8000769a:	f7 36 00 08 	ld.ub	r6,r11[8]
8000769e:	f3 66 00 08 	st.b	r9[8],r6
800076a2:	f7 36 00 07 	ld.ub	r6,r11[7]
800076a6:	f3 66 00 07 	st.b	r9[7],r6
800076aa:	f7 36 00 06 	ld.ub	r6,r11[6]
800076ae:	f3 66 00 06 	st.b	r9[6],r6
800076b2:	f7 36 00 05 	ld.ub	r6,r11[5]
800076b6:	f3 66 00 05 	st.b	r9[5],r6
800076ba:	f7 36 00 04 	ld.ub	r6,r11[4]
800076be:	f3 66 00 04 	st.b	r9[4],r6
800076c2:	f7 36 00 03 	ld.ub	r6,r11[3]
800076c6:	f3 66 00 03 	st.b	r9[3],r6
800076ca:	f7 36 00 02 	ld.ub	r6,r11[2]
800076ce:	f3 66 00 02 	st.b	r9[2],r6
800076d2:	f7 36 00 01 	ld.ub	r6,r11[1]
800076d6:	f3 66 00 01 	st.b	r9[1],r6
800076da:	f7 36 00 00 	ld.ub	r6,r11[0]
800076de:	f3 66 00 00 	st.b	r9[0],r6
800076e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800076e6:	20 1a       	sub	r10,1
800076e8:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800076ec:	f8 0a 0b 09 	st.b	r12[r10],r9
800076f0:	cf b1       	brne	800076e6 <memcpy+0x13a>
800076f2:	5e fc       	retal	r12

800076f4 <memset>:
800076f4:	18 98       	mov	r8,r12
800076f6:	c0 38       	rjmp	800076fc <memset+0x8>
800076f8:	10 cb       	st.b	r8++,r11
800076fa:	20 1a       	sub	r10,1
800076fc:	58 0a       	cp.w	r10,0
800076fe:	cf d1       	brne	800076f8 <memset+0x4>
80007700:	5e fc       	retal	r12
80007702:	d7 03       	nop

80007704 <_realloc_r>:
80007704:	d4 31       	pushm	r0-r7,lr
80007706:	20 1d       	sub	sp,4
80007708:	16 94       	mov	r4,r11
8000770a:	18 92       	mov	r2,r12
8000770c:	14 9b       	mov	r11,r10
8000770e:	58 04       	cp.w	r4,0
80007710:	c0 51       	brne	8000771a <_realloc_r+0x16>
80007712:	fe b0 fd 31 	rcall	80007174 <_malloc_r>
80007716:	18 95       	mov	r5,r12
80007718:	c5 39       	rjmp	800079be <_realloc_r+0x2ba>
8000771a:	50 0a       	stdsp	sp[0x0],r10
8000771c:	fe b0 f3 12 	rcall	80005d40 <__malloc_lock>
80007720:	40 0b       	lddsp	r11,sp[0x0]
80007722:	f6 c8 ff f5 	sub	r8,r11,-11
80007726:	e8 c1 00 08 	sub	r1,r4,8
8000772a:	10 96       	mov	r6,r8
8000772c:	62 1c       	ld.w	r12,r1[0x4]
8000772e:	e0 16 ff f8 	andl	r6,0xfff8
80007732:	59 68       	cp.w	r8,22
80007734:	f9 b6 08 10 	movls	r6,16
80007738:	16 36       	cp.w	r6,r11
8000773a:	5f 38       	srlo	r8
8000773c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007740:	c0 50       	breq	8000774a <_realloc_r+0x46>
80007742:	30 c8       	mov	r8,12
80007744:	30 05       	mov	r5,0
80007746:	85 38       	st.w	r2[0xc],r8
80007748:	c3 b9       	rjmp	800079be <_realloc_r+0x2ba>
8000774a:	18 90       	mov	r0,r12
8000774c:	e0 10 ff fc 	andl	r0,0xfffc
80007750:	0c 30       	cp.w	r0,r6
80007752:	e0 84 01 0b 	brge	80007968 <_realloc_r+0x264>
80007756:	e0 68 05 3c 	mov	r8,1340
8000775a:	e2 00 00 09 	add	r9,r1,r0
8000775e:	70 25       	ld.w	r5,r8[0x8]
80007760:	0a 39       	cp.w	r9,r5
80007762:	c0 90       	breq	80007774 <_realloc_r+0x70>
80007764:	72 1a       	ld.w	r10,r9[0x4]
80007766:	a1 ca       	cbr	r10,0x0
80007768:	f2 0a 00 0a 	add	r10,r9,r10
8000776c:	74 1a       	ld.w	r10,r10[0x4]
8000776e:	ed ba 00 00 	bld	r10,0x0
80007772:	c2 20       	breq	800077b6 <_realloc_r+0xb2>
80007774:	72 1a       	ld.w	r10,r9[0x4]
80007776:	e0 1a ff fc 	andl	r10,0xfffc
8000777a:	f4 00 00 03 	add	r3,r10,r0
8000777e:	0a 39       	cp.w	r9,r5
80007780:	c1 31       	brne	800077a6 <_realloc_r+0xa2>
80007782:	ec c7 ff f0 	sub	r7,r6,-16
80007786:	0e 33       	cp.w	r3,r7
80007788:	c1 95       	brlt	800077ba <_realloc_r+0xb6>
8000778a:	e2 06 00 09 	add	r9,r1,r6
8000778e:	0c 13       	sub	r3,r6
80007790:	a1 a3       	sbr	r3,0x0
80007792:	93 13       	st.w	r9[0x4],r3
80007794:	91 29       	st.w	r8[0x8],r9
80007796:	04 9c       	mov	r12,r2
80007798:	62 18       	ld.w	r8,r1[0x4]
8000779a:	08 95       	mov	r5,r4
8000779c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077a0:	10 46       	or	r6,r8
800077a2:	83 16       	st.w	r1[0x4],r6
800077a4:	c0 b9       	rjmp	800079ba <_realloc_r+0x2b6>
800077a6:	0c 33       	cp.w	r3,r6
800077a8:	c0 95       	brlt	800077ba <_realloc_r+0xb6>
800077aa:	72 28       	ld.w	r8,r9[0x8]
800077ac:	02 97       	mov	r7,r1
800077ae:	72 39       	ld.w	r9,r9[0xc]
800077b0:	93 28       	st.w	r9[0x8],r8
800077b2:	91 39       	st.w	r8[0xc],r9
800077b4:	cd c8       	rjmp	8000796c <_realloc_r+0x268>
800077b6:	30 0a       	mov	r10,0
800077b8:	14 99       	mov	r9,r10
800077ba:	ed bc 00 00 	bld	r12,0x0
800077be:	e0 80 00 95 	breq	800078e8 <_realloc_r+0x1e4>
800077c2:	62 07       	ld.w	r7,r1[0x0]
800077c4:	e2 07 01 07 	sub	r7,r1,r7
800077c8:	6e 1c       	ld.w	r12,r7[0x4]
800077ca:	e0 1c ff fc 	andl	r12,0xfffc
800077ce:	58 09       	cp.w	r9,0
800077d0:	c5 60       	breq	8000787c <_realloc_r+0x178>
800077d2:	f8 00 00 03 	add	r3,r12,r0
800077d6:	0a 39       	cp.w	r9,r5
800077d8:	c4 81       	brne	80007868 <_realloc_r+0x164>
800077da:	14 03       	add	r3,r10
800077dc:	ec c9 ff f0 	sub	r9,r6,-16
800077e0:	12 33       	cp.w	r3,r9
800077e2:	c4 d5       	brlt	8000787c <_realloc_r+0x178>
800077e4:	6e 3a       	ld.w	r10,r7[0xc]
800077e6:	6e 29       	ld.w	r9,r7[0x8]
800077e8:	95 29       	st.w	r10[0x8],r9
800077ea:	93 3a       	st.w	r9[0xc],r10
800077ec:	ee c5 ff f8 	sub	r5,r7,-8
800077f0:	e0 ca 00 04 	sub	r10,r0,4
800077f4:	e0 4a 00 24 	cp.w	r10,36
800077f8:	e0 8b 00 25 	brhi	80007842 <_realloc_r+0x13e>
800077fc:	0a 99       	mov	r9,r5
800077fe:	59 3a       	cp.w	r10,19
80007800:	e0 88 00 1a 	brls	80007834 <_realloc_r+0x130>
80007804:	09 09       	ld.w	r9,r4++
80007806:	8b 09       	st.w	r5[0x0],r9
80007808:	09 09       	ld.w	r9,r4++
8000780a:	8f 39       	st.w	r7[0xc],r9
8000780c:	ee c9 ff f0 	sub	r9,r7,-16
80007810:	59 ba       	cp.w	r10,27
80007812:	e0 88 00 11 	brls	80007834 <_realloc_r+0x130>
80007816:	09 0b       	ld.w	r11,r4++
80007818:	93 0b       	st.w	r9[0x0],r11
8000781a:	09 09       	ld.w	r9,r4++
8000781c:	8f 59       	st.w	r7[0x14],r9
8000781e:	ee c9 ff e8 	sub	r9,r7,-24
80007822:	e0 4a 00 24 	cp.w	r10,36
80007826:	c0 71       	brne	80007834 <_realloc_r+0x130>
80007828:	09 0a       	ld.w	r10,r4++
8000782a:	93 0a       	st.w	r9[0x0],r10
8000782c:	ee c9 ff e0 	sub	r9,r7,-32
80007830:	09 0a       	ld.w	r10,r4++
80007832:	8f 7a       	st.w	r7[0x1c],r10
80007834:	09 0a       	ld.w	r10,r4++
80007836:	12 aa       	st.w	r9++,r10
80007838:	68 0a       	ld.w	r10,r4[0x0]
8000783a:	93 0a       	st.w	r9[0x0],r10
8000783c:	68 1a       	ld.w	r10,r4[0x4]
8000783e:	93 1a       	st.w	r9[0x4],r10
80007840:	c0 78       	rjmp	8000784e <_realloc_r+0x14a>
80007842:	50 08       	stdsp	sp[0x0],r8
80007844:	08 9b       	mov	r11,r4
80007846:	0a 9c       	mov	r12,r5
80007848:	e0 a0 1d 8f 	rcall	8000b366 <memmove>
8000784c:	40 08       	lddsp	r8,sp[0x0]
8000784e:	ee 06 00 09 	add	r9,r7,r6
80007852:	0c 13       	sub	r3,r6
80007854:	a1 a3       	sbr	r3,0x0
80007856:	93 13       	st.w	r9[0x4],r3
80007858:	91 29       	st.w	r8[0x8],r9
8000785a:	04 9c       	mov	r12,r2
8000785c:	6e 18       	ld.w	r8,r7[0x4]
8000785e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007862:	10 46       	or	r6,r8
80007864:	8f 16       	st.w	r7[0x4],r6
80007866:	ca a8       	rjmp	800079ba <_realloc_r+0x2b6>
80007868:	14 03       	add	r3,r10
8000786a:	0c 33       	cp.w	r3,r6
8000786c:	c0 85       	brlt	8000787c <_realloc_r+0x178>
8000786e:	72 28       	ld.w	r8,r9[0x8]
80007870:	72 39       	ld.w	r9,r9[0xc]
80007872:	93 28       	st.w	r9[0x8],r8
80007874:	91 39       	st.w	r8[0xc],r9
80007876:	6e 28       	ld.w	r8,r7[0x8]
80007878:	6e 39       	ld.w	r9,r7[0xc]
8000787a:	c0 78       	rjmp	80007888 <_realloc_r+0x184>
8000787c:	f8 00 00 03 	add	r3,r12,r0
80007880:	0c 33       	cp.w	r3,r6
80007882:	c3 35       	brlt	800078e8 <_realloc_r+0x1e4>
80007884:	6e 39       	ld.w	r9,r7[0xc]
80007886:	6e 28       	ld.w	r8,r7[0x8]
80007888:	93 28       	st.w	r9[0x8],r8
8000788a:	91 39       	st.w	r8[0xc],r9
8000788c:	e0 ca 00 04 	sub	r10,r0,4
80007890:	ee cc ff f8 	sub	r12,r7,-8
80007894:	e0 4a 00 24 	cp.w	r10,36
80007898:	e0 8b 00 24 	brhi	800078e0 <_realloc_r+0x1dc>
8000789c:	59 3a       	cp.w	r10,19
8000789e:	e0 88 00 1a 	brls	800078d2 <_realloc_r+0x1ce>
800078a2:	09 08       	ld.w	r8,r4++
800078a4:	99 08       	st.w	r12[0x0],r8
800078a6:	09 08       	ld.w	r8,r4++
800078a8:	8f 38       	st.w	r7[0xc],r8
800078aa:	ee cc ff f0 	sub	r12,r7,-16
800078ae:	59 ba       	cp.w	r10,27
800078b0:	e0 88 00 11 	brls	800078d2 <_realloc_r+0x1ce>
800078b4:	09 08       	ld.w	r8,r4++
800078b6:	99 08       	st.w	r12[0x0],r8
800078b8:	09 08       	ld.w	r8,r4++
800078ba:	8f 58       	st.w	r7[0x14],r8
800078bc:	ee cc ff e8 	sub	r12,r7,-24
800078c0:	e0 4a 00 24 	cp.w	r10,36
800078c4:	c0 71       	brne	800078d2 <_realloc_r+0x1ce>
800078c6:	09 08       	ld.w	r8,r4++
800078c8:	99 08       	st.w	r12[0x0],r8
800078ca:	ee cc ff e0 	sub	r12,r7,-32
800078ce:	09 08       	ld.w	r8,r4++
800078d0:	8f 78       	st.w	r7[0x1c],r8
800078d2:	09 08       	ld.w	r8,r4++
800078d4:	18 a8       	st.w	r12++,r8
800078d6:	68 08       	ld.w	r8,r4[0x0]
800078d8:	99 08       	st.w	r12[0x0],r8
800078da:	68 18       	ld.w	r8,r4[0x4]
800078dc:	99 18       	st.w	r12[0x4],r8
800078de:	c4 78       	rjmp	8000796c <_realloc_r+0x268>
800078e0:	08 9b       	mov	r11,r4
800078e2:	e0 a0 1d 42 	rcall	8000b366 <memmove>
800078e6:	c4 38       	rjmp	8000796c <_realloc_r+0x268>
800078e8:	04 9c       	mov	r12,r2
800078ea:	fe b0 fc 45 	rcall	80007174 <_malloc_r>
800078ee:	18 95       	mov	r5,r12
800078f0:	c3 a0       	breq	80007964 <_realloc_r+0x260>
800078f2:	62 18       	ld.w	r8,r1[0x4]
800078f4:	f8 c9 00 08 	sub	r9,r12,8
800078f8:	a1 c8       	cbr	r8,0x0
800078fa:	e2 08 00 08 	add	r8,r1,r8
800078fe:	10 39       	cp.w	r9,r8
80007900:	c0 71       	brne	8000790e <_realloc_r+0x20a>
80007902:	72 13       	ld.w	r3,r9[0x4]
80007904:	02 97       	mov	r7,r1
80007906:	e0 13 ff fc 	andl	r3,0xfffc
8000790a:	00 03       	add	r3,r0
8000790c:	c3 08       	rjmp	8000796c <_realloc_r+0x268>
8000790e:	e0 ca 00 04 	sub	r10,r0,4
80007912:	e0 4a 00 24 	cp.w	r10,36
80007916:	e0 8b 00 20 	brhi	80007956 <_realloc_r+0x252>
8000791a:	08 99       	mov	r9,r4
8000791c:	18 98       	mov	r8,r12
8000791e:	59 3a       	cp.w	r10,19
80007920:	e0 88 00 14 	brls	80007948 <_realloc_r+0x244>
80007924:	13 0b       	ld.w	r11,r9++
80007926:	10 ab       	st.w	r8++,r11
80007928:	13 0b       	ld.w	r11,r9++
8000792a:	10 ab       	st.w	r8++,r11
8000792c:	59 ba       	cp.w	r10,27
8000792e:	e0 88 00 0d 	brls	80007948 <_realloc_r+0x244>
80007932:	13 0b       	ld.w	r11,r9++
80007934:	10 ab       	st.w	r8++,r11
80007936:	13 0b       	ld.w	r11,r9++
80007938:	10 ab       	st.w	r8++,r11
8000793a:	e0 4a 00 24 	cp.w	r10,36
8000793e:	c0 51       	brne	80007948 <_realloc_r+0x244>
80007940:	13 0a       	ld.w	r10,r9++
80007942:	10 aa       	st.w	r8++,r10
80007944:	13 0a       	ld.w	r10,r9++
80007946:	10 aa       	st.w	r8++,r10
80007948:	13 0a       	ld.w	r10,r9++
8000794a:	10 aa       	st.w	r8++,r10
8000794c:	72 0a       	ld.w	r10,r9[0x0]
8000794e:	91 0a       	st.w	r8[0x0],r10
80007950:	72 19       	ld.w	r9,r9[0x4]
80007952:	91 19       	st.w	r8[0x4],r9
80007954:	c0 48       	rjmp	8000795c <_realloc_r+0x258>
80007956:	08 9b       	mov	r11,r4
80007958:	e0 a0 1d 07 	rcall	8000b366 <memmove>
8000795c:	08 9b       	mov	r11,r4
8000795e:	04 9c       	mov	r12,r2
80007960:	e0 a0 1a 60 	rcall	8000ae20 <_free_r>
80007964:	04 9c       	mov	r12,r2
80007966:	c2 a8       	rjmp	800079ba <_realloc_r+0x2b6>
80007968:	00 93       	mov	r3,r0
8000796a:	02 97       	mov	r7,r1
8000796c:	e6 06 01 09 	sub	r9,r3,r6
80007970:	6e 18       	ld.w	r8,r7[0x4]
80007972:	58 f9       	cp.w	r9,15
80007974:	e0 88 00 16 	brls	800079a0 <_realloc_r+0x29c>
80007978:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000797c:	ed e8 10 08 	or	r8,r6,r8
80007980:	8f 18       	st.w	r7[0x4],r8
80007982:	12 98       	mov	r8,r9
80007984:	a1 a8       	sbr	r8,0x0
80007986:	ee 06 00 0b 	add	r11,r7,r6
8000798a:	f6 09 00 09 	add	r9,r11,r9
8000798e:	97 18       	st.w	r11[0x4],r8
80007990:	72 18       	ld.w	r8,r9[0x4]
80007992:	a1 a8       	sbr	r8,0x0
80007994:	2f 8b       	sub	r11,-8
80007996:	93 18       	st.w	r9[0x4],r8
80007998:	04 9c       	mov	r12,r2
8000799a:	e0 a0 1a 43 	rcall	8000ae20 <_free_r>
8000799e:	c0 b8       	rjmp	800079b4 <_realloc_r+0x2b0>
800079a0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800079a4:	e7 e8 10 08 	or	r8,r3,r8
800079a8:	8f 18       	st.w	r7[0x4],r8
800079aa:	ee 03 00 03 	add	r3,r7,r3
800079ae:	66 18       	ld.w	r8,r3[0x4]
800079b0:	a1 a8       	sbr	r8,0x0
800079b2:	87 18       	st.w	r3[0x4],r8
800079b4:	04 9c       	mov	r12,r2
800079b6:	ee c5 ff f8 	sub	r5,r7,-8
800079ba:	fe b0 f1 c9 	rcall	80005d4c <__malloc_unlock>
800079be:	0a 9c       	mov	r12,r5
800079c0:	2f fd       	sub	sp,-4
800079c2:	d8 32       	popm	r0-r7,pc

800079c4 <_sbrk_r>:
800079c4:	d4 21       	pushm	r4-r7,lr
800079c6:	30 08       	mov	r8,0
800079c8:	18 97       	mov	r7,r12
800079ca:	e0 66 5b 68 	mov	r6,23400
800079ce:	16 9c       	mov	r12,r11
800079d0:	8d 08       	st.w	r6[0x0],r8
800079d2:	c8 5c       	rcall	80007adc <_sbrk>
800079d4:	5b fc       	cp.w	r12,-1
800079d6:	c0 51       	brne	800079e0 <_sbrk_r+0x1c>
800079d8:	6c 08       	ld.w	r8,r6[0x0]
800079da:	58 08       	cp.w	r8,0
800079dc:	ef f8 1a 03 	st.wne	r7[0xc],r8
800079e0:	d8 22       	popm	r4-r7,pc
800079e2:	d7 03       	nop

800079e4 <sprintf>:
800079e4:	d4 01       	pushm	lr
800079e6:	21 7d       	sub	sp,92
800079e8:	e0 68 ff ff 	mov	r8,65535
800079ec:	ea 18 7f ff 	orh	r8,0x7fff
800079f0:	50 58       	stdsp	sp[0x14],r8
800079f2:	50 28       	stdsp	sp[0x8],r8
800079f4:	e0 68 02 08 	mov	r8,520
800079f8:	ba 68       	st.h	sp[0xc],r8
800079fa:	3f f8       	mov	r8,-1
800079fc:	ba 78       	st.h	sp[0xe],r8
800079fe:	e0 68 0a 3c 	mov	r8,2620
80007a02:	50 4c       	stdsp	sp[0x10],r12
80007a04:	16 9a       	mov	r10,r11
80007a06:	50 0c       	stdsp	sp[0x0],r12
80007a08:	fa c9 ff a0 	sub	r9,sp,-96
80007a0c:	70 0c       	ld.w	r12,r8[0x0]
80007a0e:	1a 9b       	mov	r11,sp
80007a10:	e0 a0 02 1a 	rcall	80007e44 <_vfprintf_r>
80007a14:	30 09       	mov	r9,0
80007a16:	40 08       	lddsp	r8,sp[0x0]
80007a18:	b0 89       	st.b	r8[0x0],r9
80007a1a:	2e 9d       	sub	sp,-92
80007a1c:	d8 02       	popm	pc
80007a1e:	d7 03       	nop

80007a20 <strncpy>:
80007a20:	30 08       	mov	r8,0
80007a22:	10 3a       	cp.w	r10,r8
80007a24:	5e 0c       	reteq	r12
80007a26:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007a2a:	f8 08 0b 09 	st.b	r12[r8],r9
80007a2e:	2f f8       	sub	r8,-1
80007a30:	58 09       	cp.w	r9,0
80007a32:	cf 81       	brne	80007a22 <strncpy+0x2>
80007a34:	10 3a       	cp.w	r10,r8
80007a36:	5e 0c       	reteq	r12
80007a38:	f8 08 0b 09 	st.b	r12[r8],r9
80007a3c:	2f f8       	sub	r8,-1
80007a3e:	cf bb       	rjmp	80007a34 <strncpy+0x14>

80007a40 <_close>:
80007a40:	30 28       	mov	r8,2
80007a42:	d6 73       	breakpoint
80007a44:	3f fc       	mov	r12,-1
80007a46:	35 8b       	mov	r11,88
80007a48:	58 0c       	cp.w	r12,0
80007a4a:	5e 4c       	retge	r12
80007a4c:	e0 6a 5b 68 	mov	r10,23400
80007a50:	95 0b       	st.w	r10[0x0],r11
80007a52:	5e fc       	retal	r12

80007a54 <_lseek>:
80007a54:	30 58       	mov	r8,5
80007a56:	d6 73       	breakpoint
80007a58:	3f fc       	mov	r12,-1
80007a5a:	35 8b       	mov	r11,88
80007a5c:	58 0c       	cp.w	r12,0
80007a5e:	5e 4c       	retge	r12
80007a60:	e0 6a 5b 68 	mov	r10,23400
80007a64:	95 0b       	st.w	r10[0x0],r11
80007a66:	5e fc       	retal	r12

80007a68 <isatty>:
80007a68:	30 b8       	mov	r8,11
80007a6a:	d6 73       	breakpoint
80007a6c:	3f fc       	mov	r12,-1
80007a6e:	35 8b       	mov	r11,88
80007a70:	58 0c       	cp.w	r12,0
80007a72:	5e 4c       	retge	r12
80007a74:	e0 6a 5b 68 	mov	r10,23400
80007a78:	95 0b       	st.w	r10[0x0],r11
80007a7a:	5e fc       	retal	r12

80007a7c <_fstat_host>:
80007a7c:	30 98       	mov	r8,9
80007a7e:	d6 73       	breakpoint
80007a80:	3f fc       	mov	r12,-1
80007a82:	35 8b       	mov	r11,88
80007a84:	58 0c       	cp.w	r12,0
80007a86:	5e 4c       	retge	r12
80007a88:	e0 6a 5b 68 	mov	r10,23400
80007a8c:	95 0b       	st.w	r10[0x0],r11
80007a8e:	5e fc       	retal	r12

80007a90 <_fstat>:
80007a90:	d4 21       	pushm	r4-r7,lr
80007a92:	21 0d       	sub	sp,64
80007a94:	16 97       	mov	r7,r11
80007a96:	1a 9b       	mov	r11,sp
80007a98:	cf 2f       	rcall	80007a7c <_fstat_host>
80007a9a:	c0 34       	brge	80007aa0 <_fstat+0x10>
80007a9c:	3f fc       	mov	r12,-1
80007a9e:	c1 c8       	rjmp	80007ad6 <_fstat+0x46>
80007aa0:	40 08       	lddsp	r8,sp[0x0]
80007aa2:	ae 08       	st.h	r7[0x0],r8
80007aa4:	40 18       	lddsp	r8,sp[0x4]
80007aa6:	ae 18       	st.h	r7[0x2],r8
80007aa8:	40 28       	lddsp	r8,sp[0x8]
80007aaa:	8f 18       	st.w	r7[0x4],r8
80007aac:	40 38       	lddsp	r8,sp[0xc]
80007aae:	ae 48       	st.h	r7[0x8],r8
80007ab0:	40 48       	lddsp	r8,sp[0x10]
80007ab2:	ae 58       	st.h	r7[0xa],r8
80007ab4:	40 58       	lddsp	r8,sp[0x14]
80007ab6:	ae 68       	st.h	r7[0xc],r8
80007ab8:	40 68       	lddsp	r8,sp[0x18]
80007aba:	ae 78       	st.h	r7[0xe],r8
80007abc:	40 88       	lddsp	r8,sp[0x20]
80007abe:	8f 48       	st.w	r7[0x10],r8
80007ac0:	40 a8       	lddsp	r8,sp[0x28]
80007ac2:	8f b8       	st.w	r7[0x2c],r8
80007ac4:	40 c8       	lddsp	r8,sp[0x30]
80007ac6:	8f c8       	st.w	r7[0x30],r8
80007ac8:	40 d8       	lddsp	r8,sp[0x34]
80007aca:	8f 58       	st.w	r7[0x14],r8
80007acc:	40 e8       	lddsp	r8,sp[0x38]
80007ace:	30 0c       	mov	r12,0
80007ad0:	8f 78       	st.w	r7[0x1c],r8
80007ad2:	40 f8       	lddsp	r8,sp[0x3c]
80007ad4:	8f 98       	st.w	r7[0x24],r8
80007ad6:	2f 0d       	sub	sp,-64
80007ad8:	d8 22       	popm	r4-r7,pc
80007ada:	d7 03       	nop

80007adc <_sbrk>:
80007adc:	d4 01       	pushm	lr
80007ade:	e0 68 0d 90 	mov	r8,3472
80007ae2:	70 09       	ld.w	r9,r8[0x0]
80007ae4:	58 09       	cp.w	r9,0
80007ae6:	c0 41       	brne	80007aee <_sbrk+0x12>
80007ae8:	e0 69 5b 70 	mov	r9,23408
80007aec:	91 09       	st.w	r8[0x0],r9
80007aee:	e0 69 0d 90 	mov	r9,3472
80007af2:	e0 7a 70 00 	mov	r10,94208
80007af6:	72 08       	ld.w	r8,r9[0x0]
80007af8:	f0 0c 00 0c 	add	r12,r8,r12
80007afc:	14 3c       	cp.w	r12,r10
80007afe:	e0 8b 00 04 	brhi	80007b06 <_sbrk+0x2a>
80007b02:	93 0c       	st.w	r9[0x0],r12
80007b04:	c0 68       	rjmp	80007b10 <_sbrk+0x34>
80007b06:	e0 a0 18 15 	rcall	8000ab30 <__errno>
80007b0a:	30 c8       	mov	r8,12
80007b0c:	99 08       	st.w	r12[0x0],r8
80007b0e:	3f f8       	mov	r8,-1
80007b10:	10 9c       	mov	r12,r8
80007b12:	d8 02       	popm	pc

80007b14 <get_arg>:
80007b14:	d4 31       	pushm	r0-r7,lr
80007b16:	20 8d       	sub	sp,32
80007b18:	fa c4 ff bc 	sub	r4,sp,-68
80007b1c:	50 4b       	stdsp	sp[0x10],r11
80007b1e:	68 2e       	ld.w	lr,r4[0x8]
80007b20:	50 58       	stdsp	sp[0x14],r8
80007b22:	12 96       	mov	r6,r9
80007b24:	7c 0b       	ld.w	r11,lr[0x0]
80007b26:	70 05       	ld.w	r5,r8[0x0]
80007b28:	50 6e       	stdsp	sp[0x18],lr
80007b2a:	58 0b       	cp.w	r11,0
80007b2c:	f4 0b 17 00 	moveq	r11,r10
80007b30:	68 03       	ld.w	r3,r4[0x0]
80007b32:	68 11       	ld.w	r1,r4[0x4]
80007b34:	40 49       	lddsp	r9,sp[0x10]
80007b36:	30 08       	mov	r8,0
80007b38:	c2 89       	rjmp	80007d88 <get_arg+0x274>
80007b3a:	2f fb       	sub	r11,-1
80007b3c:	32 5c       	mov	r12,37
80007b3e:	17 8a       	ld.ub	r10,r11[0x0]
80007b40:	f8 0a 18 00 	cp.b	r10,r12
80007b44:	5f 1e       	srne	lr
80007b46:	f0 0a 18 00 	cp.b	r10,r8
80007b4a:	5f 1c       	srne	r12
80007b4c:	fd ec 00 0c 	and	r12,lr,r12
80007b50:	f0 0c 18 00 	cp.b	r12,r8
80007b54:	cf 31       	brne	80007b3a <get_arg+0x26>
80007b56:	58 0a       	cp.w	r10,0
80007b58:	e0 80 01 25 	breq	80007da2 <get_arg+0x28e>
80007b5c:	30 0c       	mov	r12,0
80007b5e:	3f fa       	mov	r10,-1
80007b60:	18 90       	mov	r0,r12
80007b62:	50 3a       	stdsp	sp[0xc],r10
80007b64:	18 94       	mov	r4,r12
80007b66:	18 92       	mov	r2,r12
80007b68:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007b6c:	16 97       	mov	r7,r11
80007b6e:	50 7c       	stdsp	sp[0x1c],r12
80007b70:	fe cc 9d d4 	sub	r12,pc,-25132
80007b74:	0f 3a       	ld.ub	r10,r7++
80007b76:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007b7a:	40 7c       	lddsp	r12,sp[0x1c]
80007b7c:	1c 0c       	add	r12,lr
80007b7e:	fe ce 9e aa 	sub	lr,pc,-24918
80007b82:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007b86:	20 1e       	sub	lr,1
80007b88:	50 0e       	stdsp	sp[0x0],lr
80007b8a:	fe ce 9f 22 	sub	lr,pc,-24798
80007b8e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007b92:	50 7c       	stdsp	sp[0x1c],r12
80007b94:	40 0c       	lddsp	r12,sp[0x0]
80007b96:	58 7c       	cp.w	r12,7
80007b98:	e0 8b 00 f1 	brhi	80007d7a <get_arg+0x266>
80007b9c:	fe ce a0 d4 	sub	lr,pc,-24364
80007ba0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007ba4:	36 8b       	mov	r11,104
80007ba6:	f6 0a 18 00 	cp.b	r10,r11
80007baa:	e0 80 00 e8 	breq	80007d7a <get_arg+0x266>
80007bae:	37 1b       	mov	r11,113
80007bb0:	f6 0a 18 00 	cp.b	r10,r11
80007bb4:	c0 70       	breq	80007bc2 <get_arg+0xae>
80007bb6:	34 cb       	mov	r11,76
80007bb8:	f6 0a 18 00 	cp.b	r10,r11
80007bbc:	c0 51       	brne	80007bc6 <get_arg+0xb2>
80007bbe:	a3 b4       	sbr	r4,0x3
80007bc0:	cd d8       	rjmp	80007d7a <get_arg+0x266>
80007bc2:	a5 b4       	sbr	r4,0x5
80007bc4:	cd b8       	rjmp	80007d7a <get_arg+0x266>
80007bc6:	08 9a       	mov	r10,r4
80007bc8:	0e 9b       	mov	r11,r7
80007bca:	a5 aa       	sbr	r10,0x4
80007bcc:	17 3c       	ld.ub	r12,r11++
80007bce:	a5 b4       	sbr	r4,0x5
80007bd0:	36 ce       	mov	lr,108
80007bd2:	fc 0c 18 00 	cp.b	r12,lr
80007bd6:	e0 80 00 d3 	breq	80007d7c <get_arg+0x268>
80007bda:	14 94       	mov	r4,r10
80007bdc:	cc f8       	rjmp	80007d7a <get_arg+0x266>
80007bde:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007be2:	36 7c       	mov	r12,103
80007be4:	f8 0a 18 00 	cp.b	r10,r12
80007be8:	e0 8b 00 27 	brhi	80007c36 <get_arg+0x122>
80007bec:	36 5b       	mov	r11,101
80007bee:	f6 0a 18 00 	cp.b	r10,r11
80007bf2:	c4 82       	brcc	80007c82 <get_arg+0x16e>
80007bf4:	34 fb       	mov	r11,79
80007bf6:	f6 0a 18 00 	cp.b	r10,r11
80007bfa:	c4 80       	breq	80007c8a <get_arg+0x176>
80007bfc:	e0 8b 00 0c 	brhi	80007c14 <get_arg+0x100>
80007c00:	34 5b       	mov	r11,69
80007c02:	f6 0a 18 00 	cp.b	r10,r11
80007c06:	c3 e0       	breq	80007c82 <get_arg+0x16e>
80007c08:	34 7b       	mov	r11,71
80007c0a:	f6 0a 18 00 	cp.b	r10,r11
80007c0e:	c3 a0       	breq	80007c82 <get_arg+0x16e>
80007c10:	34 4b       	mov	r11,68
80007c12:	c0 88       	rjmp	80007c22 <get_arg+0x10e>
80007c14:	35 8b       	mov	r11,88
80007c16:	f6 0a 18 00 	cp.b	r10,r11
80007c1a:	c2 c0       	breq	80007c72 <get_arg+0x15e>
80007c1c:	e0 8b 00 07 	brhi	80007c2a <get_arg+0x116>
80007c20:	35 5b       	mov	r11,85
80007c22:	f6 0a 18 00 	cp.b	r10,r11
80007c26:	c3 51       	brne	80007c90 <get_arg+0x17c>
80007c28:	c3 18       	rjmp	80007c8a <get_arg+0x176>
80007c2a:	36 3b       	mov	r11,99
80007c2c:	f6 0a 18 00 	cp.b	r10,r11
80007c30:	c2 f0       	breq	80007c8e <get_arg+0x17a>
80007c32:	36 4b       	mov	r11,100
80007c34:	c0 e8       	rjmp	80007c50 <get_arg+0x13c>
80007c36:	37 0b       	mov	r11,112
80007c38:	f6 0a 18 00 	cp.b	r10,r11
80007c3c:	c2 50       	breq	80007c86 <get_arg+0x172>
80007c3e:	e0 8b 00 0d 	brhi	80007c58 <get_arg+0x144>
80007c42:	36 eb       	mov	r11,110
80007c44:	f6 0a 18 00 	cp.b	r10,r11
80007c48:	c1 f0       	breq	80007c86 <get_arg+0x172>
80007c4a:	e0 8b 00 14 	brhi	80007c72 <get_arg+0x15e>
80007c4e:	36 9b       	mov	r11,105
80007c50:	f6 0a 18 00 	cp.b	r10,r11
80007c54:	c1 e1       	brne	80007c90 <get_arg+0x17c>
80007c56:	c0 e8       	rjmp	80007c72 <get_arg+0x15e>
80007c58:	37 5b       	mov	r11,117
80007c5a:	f6 0a 18 00 	cp.b	r10,r11
80007c5e:	c0 a0       	breq	80007c72 <get_arg+0x15e>
80007c60:	37 8b       	mov	r11,120
80007c62:	f6 0a 18 00 	cp.b	r10,r11
80007c66:	c0 60       	breq	80007c72 <get_arg+0x15e>
80007c68:	37 3b       	mov	r11,115
80007c6a:	f6 0a 18 00 	cp.b	r10,r11
80007c6e:	c1 11       	brne	80007c90 <get_arg+0x17c>
80007c70:	c0 b8       	rjmp	80007c86 <get_arg+0x172>
80007c72:	ed b4 00 04 	bld	r4,0x4
80007c76:	c0 a0       	breq	80007c8a <get_arg+0x176>
80007c78:	ed b4 00 05 	bld	r4,0x5
80007c7c:	c0 91       	brne	80007c8e <get_arg+0x17a>
80007c7e:	30 20       	mov	r0,2
80007c80:	c0 88       	rjmp	80007c90 <get_arg+0x17c>
80007c82:	30 40       	mov	r0,4
80007c84:	c0 68       	rjmp	80007c90 <get_arg+0x17c>
80007c86:	30 30       	mov	r0,3
80007c88:	c0 48       	rjmp	80007c90 <get_arg+0x17c>
80007c8a:	30 10       	mov	r0,1
80007c8c:	c0 28       	rjmp	80007c90 <get_arg+0x17c>
80007c8e:	30 00       	mov	r0,0
80007c90:	40 3b       	lddsp	r11,sp[0xc]
80007c92:	5b fb       	cp.w	r11,-1
80007c94:	c0 40       	breq	80007c9c <get_arg+0x188>
80007c96:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007c9a:	c7 08       	rjmp	80007d7a <get_arg+0x266>
80007c9c:	58 60       	cp.w	r0,6
80007c9e:	e0 8b 00 6e 	brhi	80007d7a <get_arg+0x266>
80007ca2:	6c 0a       	ld.w	r10,r6[0x0]
80007ca4:	ea cc ff ff 	sub	r12,r5,-1
80007ca8:	fe ce a1 c0 	sub	lr,pc,-24128
80007cac:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007cb0:	f4 cb ff f8 	sub	r11,r10,-8
80007cb4:	8d 0b       	st.w	r6[0x0],r11
80007cb6:	f4 ea 00 00 	ld.d	r10,r10[0]
80007cba:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007cbe:	c0 f8       	rjmp	80007cdc <get_arg+0x1c8>
80007cc0:	f4 cb ff fc 	sub	r11,r10,-4
80007cc4:	8d 0b       	st.w	r6[0x0],r11
80007cc6:	74 0a       	ld.w	r10,r10[0x0]
80007cc8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007ccc:	c0 88       	rjmp	80007cdc <get_arg+0x1c8>
80007cce:	f4 cb ff f8 	sub	r11,r10,-8
80007cd2:	8d 0b       	st.w	r6[0x0],r11
80007cd4:	f4 ea 00 00 	ld.d	r10,r10[0]
80007cd8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007cdc:	0e 9b       	mov	r11,r7
80007cde:	18 95       	mov	r5,r12
80007ce0:	c4 e8       	rjmp	80007d7c <get_arg+0x268>
80007ce2:	62 0a       	ld.w	r10,r1[0x0]
80007ce4:	5b fa       	cp.w	r10,-1
80007ce6:	c0 b1       	brne	80007cfc <get_arg+0x1e8>
80007ce8:	50 19       	stdsp	sp[0x4],r9
80007cea:	50 28       	stdsp	sp[0x8],r8
80007cec:	e0 6a 00 80 	mov	r10,128
80007cf0:	30 0b       	mov	r11,0
80007cf2:	02 9c       	mov	r12,r1
80007cf4:	fe b0 fd 00 	rcall	800076f4 <memset>
80007cf8:	40 28       	lddsp	r8,sp[0x8]
80007cfa:	40 19       	lddsp	r9,sp[0x4]
80007cfc:	e4 cc 00 01 	sub	r12,r2,1
80007d00:	0e 9b       	mov	r11,r7
80007d02:	50 3c       	stdsp	sp[0xc],r12
80007d04:	f2 0c 0c 49 	max	r9,r9,r12
80007d08:	c3 a8       	rjmp	80007d7c <get_arg+0x268>
80007d0a:	62 0a       	ld.w	r10,r1[0x0]
80007d0c:	5b fa       	cp.w	r10,-1
80007d0e:	c0 b1       	brne	80007d24 <get_arg+0x210>
80007d10:	50 19       	stdsp	sp[0x4],r9
80007d12:	50 28       	stdsp	sp[0x8],r8
80007d14:	e0 6a 00 80 	mov	r10,128
80007d18:	30 0b       	mov	r11,0
80007d1a:	02 9c       	mov	r12,r1
80007d1c:	fe b0 fc ec 	rcall	800076f4 <memset>
80007d20:	40 28       	lddsp	r8,sp[0x8]
80007d22:	40 19       	lddsp	r9,sp[0x4]
80007d24:	20 12       	sub	r2,1
80007d26:	30 0a       	mov	r10,0
80007d28:	0e 9b       	mov	r11,r7
80007d2a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007d2e:	f2 02 0c 49 	max	r9,r9,r2
80007d32:	c2 58       	rjmp	80007d7c <get_arg+0x268>
80007d34:	16 97       	mov	r7,r11
80007d36:	6c 0a       	ld.w	r10,r6[0x0]
80007d38:	f4 cb ff fc 	sub	r11,r10,-4
80007d3c:	8d 0b       	st.w	r6[0x0],r11
80007d3e:	74 0a       	ld.w	r10,r10[0x0]
80007d40:	0e 9b       	mov	r11,r7
80007d42:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007d46:	2f f5       	sub	r5,-1
80007d48:	c1 a8       	rjmp	80007d7c <get_arg+0x268>
80007d4a:	f4 c2 00 30 	sub	r2,r10,48
80007d4e:	c0 68       	rjmp	80007d5a <get_arg+0x246>
80007d50:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007d54:	2f f7       	sub	r7,-1
80007d56:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007d5a:	0f 8a       	ld.ub	r10,r7[0x0]
80007d5c:	58 0a       	cp.w	r10,0
80007d5e:	c0 e0       	breq	80007d7a <get_arg+0x266>
80007d60:	23 0a       	sub	r10,48
80007d62:	58 9a       	cp.w	r10,9
80007d64:	fe 98 ff f6 	brls	80007d50 <get_arg+0x23c>
80007d68:	c0 98       	rjmp	80007d7a <get_arg+0x266>
80007d6a:	2f f7       	sub	r7,-1
80007d6c:	0f 8a       	ld.ub	r10,r7[0x0]
80007d6e:	58 0a       	cp.w	r10,0
80007d70:	c0 50       	breq	80007d7a <get_arg+0x266>
80007d72:	23 0a       	sub	r10,48
80007d74:	58 9a       	cp.w	r10,9
80007d76:	fe 98 ff fa 	brls	80007d6a <get_arg+0x256>
80007d7a:	0e 9b       	mov	r11,r7
80007d7c:	40 7c       	lddsp	r12,sp[0x1c]
80007d7e:	30 ba       	mov	r10,11
80007d80:	f4 0c 18 00 	cp.b	r12,r10
80007d84:	fe 91 fe f2 	brne	80007b68 <get_arg+0x54>
80007d88:	40 42       	lddsp	r2,sp[0x10]
80007d8a:	17 8c       	ld.ub	r12,r11[0x0]
80007d8c:	0a 32       	cp.w	r2,r5
80007d8e:	5f 4a       	srge	r10
80007d90:	f0 0c 18 00 	cp.b	r12,r8
80007d94:	5f 1c       	srne	r12
80007d96:	f9 ea 00 0a 	and	r10,r12,r10
80007d9a:	f0 0a 18 00 	cp.b	r10,r8
80007d9e:	fe 91 fe cf 	brne	80007b3c <get_arg+0x28>
80007da2:	30 08       	mov	r8,0
80007da4:	40 4e       	lddsp	lr,sp[0x10]
80007da6:	17 8a       	ld.ub	r10,r11[0x0]
80007da8:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007dac:	f0 0a 18 00 	cp.b	r10,r8
80007db0:	fc 09 17 10 	movne	r9,lr
80007db4:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007db8:	06 9e       	mov	lr,r3
80007dba:	c2 a8       	rjmp	80007e0e <get_arg+0x2fa>
80007dbc:	62 0a       	ld.w	r10,r1[0x0]
80007dbe:	58 3a       	cp.w	r10,3
80007dc0:	c1 e0       	breq	80007dfc <get_arg+0x2e8>
80007dc2:	e0 89 00 07 	brgt	80007dd0 <get_arg+0x2bc>
80007dc6:	58 1a       	cp.w	r10,1
80007dc8:	c1 a0       	breq	80007dfc <get_arg+0x2e8>
80007dca:	58 2a       	cp.w	r10,2
80007dcc:	c1 81       	brne	80007dfc <get_arg+0x2e8>
80007dce:	c0 58       	rjmp	80007dd8 <get_arg+0x2c4>
80007dd0:	58 5a       	cp.w	r10,5
80007dd2:	c0 c0       	breq	80007dea <get_arg+0x2d6>
80007dd4:	c0 b5       	brlt	80007dea <get_arg+0x2d6>
80007dd6:	c1 38       	rjmp	80007dfc <get_arg+0x2e8>
80007dd8:	6c 0a       	ld.w	r10,r6[0x0]
80007dda:	f4 cc ff f8 	sub	r12,r10,-8
80007dde:	8d 0c       	st.w	r6[0x0],r12
80007de0:	f4 e2 00 00 	ld.d	r2,r10[0]
80007de4:	f0 e3 00 00 	st.d	r8[0],r2
80007de8:	c1 08       	rjmp	80007e08 <get_arg+0x2f4>
80007dea:	6c 0a       	ld.w	r10,r6[0x0]
80007dec:	f4 cc ff f8 	sub	r12,r10,-8
80007df0:	8d 0c       	st.w	r6[0x0],r12
80007df2:	f4 e2 00 00 	ld.d	r2,r10[0]
80007df6:	f0 e3 00 00 	st.d	r8[0],r2
80007dfa:	c0 78       	rjmp	80007e08 <get_arg+0x2f4>
80007dfc:	6c 0a       	ld.w	r10,r6[0x0]
80007dfe:	f4 cc ff fc 	sub	r12,r10,-4
80007e02:	8d 0c       	st.w	r6[0x0],r12
80007e04:	74 0a       	ld.w	r10,r10[0x0]
80007e06:	91 0a       	st.w	r8[0x0],r10
80007e08:	2f f5       	sub	r5,-1
80007e0a:	2f 88       	sub	r8,-8
80007e0c:	2f c1       	sub	r1,-4
80007e0e:	12 35       	cp.w	r5,r9
80007e10:	fe 9a ff d6 	brle	80007dbc <get_arg+0x2a8>
80007e14:	1c 93       	mov	r3,lr
80007e16:	40 52       	lddsp	r2,sp[0x14]
80007e18:	40 6e       	lddsp	lr,sp[0x18]
80007e1a:	85 05       	st.w	r2[0x0],r5
80007e1c:	9d 0b       	st.w	lr[0x0],r11
80007e1e:	40 4b       	lddsp	r11,sp[0x10]
80007e20:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007e24:	2f 8d       	sub	sp,-32
80007e26:	d8 32       	popm	r0-r7,pc

80007e28 <__sprint_r>:
80007e28:	d4 21       	pushm	r4-r7,lr
80007e2a:	14 97       	mov	r7,r10
80007e2c:	74 28       	ld.w	r8,r10[0x8]
80007e2e:	58 08       	cp.w	r8,0
80007e30:	c0 41       	brne	80007e38 <__sprint_r+0x10>
80007e32:	95 18       	st.w	r10[0x4],r8
80007e34:	10 9c       	mov	r12,r8
80007e36:	d8 22       	popm	r4-r7,pc
80007e38:	e0 a0 18 ba 	rcall	8000afac <__sfvwrite_r>
80007e3c:	30 08       	mov	r8,0
80007e3e:	8f 18       	st.w	r7[0x4],r8
80007e40:	8f 28       	st.w	r7[0x8],r8
80007e42:	d8 22       	popm	r4-r7,pc

80007e44 <_vfprintf_r>:
80007e44:	d4 31       	pushm	r0-r7,lr
80007e46:	fa cd 06 bc 	sub	sp,sp,1724
80007e4a:	51 09       	stdsp	sp[0x40],r9
80007e4c:	16 91       	mov	r1,r11
80007e4e:	14 97       	mov	r7,r10
80007e50:	18 95       	mov	r5,r12
80007e52:	e0 a0 1a 1d 	rcall	8000b28c <_localeconv_r>
80007e56:	78 0c       	ld.w	r12,r12[0x0]
80007e58:	50 cc       	stdsp	sp[0x30],r12
80007e5a:	58 05       	cp.w	r5,0
80007e5c:	c0 70       	breq	80007e6a <_vfprintf_r+0x26>
80007e5e:	6a 68       	ld.w	r8,r5[0x18]
80007e60:	58 08       	cp.w	r8,0
80007e62:	c0 41       	brne	80007e6a <_vfprintf_r+0x26>
80007e64:	0a 9c       	mov	r12,r5
80007e66:	e0 a0 17 43 	rcall	8000acec <__sinit>
80007e6a:	fe c8 9f be 	sub	r8,pc,-24642
80007e6e:	10 31       	cp.w	r1,r8
80007e70:	c0 31       	brne	80007e76 <_vfprintf_r+0x32>
80007e72:	6a 01       	ld.w	r1,r5[0x0]
80007e74:	c0 c8       	rjmp	80007e8c <_vfprintf_r+0x48>
80007e76:	fe c8 9f aa 	sub	r8,pc,-24662
80007e7a:	10 31       	cp.w	r1,r8
80007e7c:	c0 31       	brne	80007e82 <_vfprintf_r+0x3e>
80007e7e:	6a 11       	ld.w	r1,r5[0x4]
80007e80:	c0 68       	rjmp	80007e8c <_vfprintf_r+0x48>
80007e82:	fe c8 9f 96 	sub	r8,pc,-24682
80007e86:	10 31       	cp.w	r1,r8
80007e88:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007e8c:	82 68       	ld.sh	r8,r1[0xc]
80007e8e:	ed b8 00 03 	bld	r8,0x3
80007e92:	c0 41       	brne	80007e9a <_vfprintf_r+0x56>
80007e94:	62 48       	ld.w	r8,r1[0x10]
80007e96:	58 08       	cp.w	r8,0
80007e98:	c0 71       	brne	80007ea6 <_vfprintf_r+0x62>
80007e9a:	02 9b       	mov	r11,r1
80007e9c:	0a 9c       	mov	r12,r5
80007e9e:	e0 a0 0f 5d 	rcall	80009d58 <__swsetup_r>
80007ea2:	e0 81 0f 54 	brne	80009d4a <_vfprintf_r+0x1f06>
80007ea6:	82 68       	ld.sh	r8,r1[0xc]
80007ea8:	10 99       	mov	r9,r8
80007eaa:	e2 19 00 1a 	andl	r9,0x1a,COH
80007eae:	58 a9       	cp.w	r9,10
80007eb0:	c3 c1       	brne	80007f28 <_vfprintf_r+0xe4>
80007eb2:	82 79       	ld.sh	r9,r1[0xe]
80007eb4:	30 0a       	mov	r10,0
80007eb6:	f4 09 19 00 	cp.h	r9,r10
80007eba:	c3 75       	brlt	80007f28 <_vfprintf_r+0xe4>
80007ebc:	a1 d8       	cbr	r8,0x1
80007ebe:	fb 58 05 d0 	st.h	sp[1488],r8
80007ec2:	62 88       	ld.w	r8,r1[0x20]
80007ec4:	fb 48 05 e4 	st.w	sp[1508],r8
80007ec8:	62 a8       	ld.w	r8,r1[0x28]
80007eca:	fb 48 05 ec 	st.w	sp[1516],r8
80007ece:	fa c8 ff bc 	sub	r8,sp,-68
80007ed2:	fb 48 05 d4 	st.w	sp[1492],r8
80007ed6:	fb 48 05 c4 	st.w	sp[1476],r8
80007eda:	e0 68 04 00 	mov	r8,1024
80007ede:	fb 48 05 d8 	st.w	sp[1496],r8
80007ee2:	fb 48 05 cc 	st.w	sp[1484],r8
80007ee6:	30 08       	mov	r8,0
80007ee8:	fb 59 05 d2 	st.h	sp[1490],r9
80007eec:	0e 9a       	mov	r10,r7
80007eee:	41 09       	lddsp	r9,sp[0x40]
80007ef0:	fa c7 fa 3c 	sub	r7,sp,-1476
80007ef4:	fb 48 05 dc 	st.w	sp[1500],r8
80007ef8:	0a 9c       	mov	r12,r5
80007efa:	0e 9b       	mov	r11,r7
80007efc:	ca 4f       	rcall	80007e44 <_vfprintf_r>
80007efe:	50 bc       	stdsp	sp[0x2c],r12
80007f00:	c0 95       	brlt	80007f12 <_vfprintf_r+0xce>
80007f02:	0e 9b       	mov	r11,r7
80007f04:	0a 9c       	mov	r12,r5
80007f06:	e0 a0 16 1b 	rcall	8000ab3c <_fflush_r>
80007f0a:	40 be       	lddsp	lr,sp[0x2c]
80007f0c:	f9 be 01 ff 	movne	lr,-1
80007f10:	50 be       	stdsp	sp[0x2c],lr
80007f12:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007f16:	ed b8 00 06 	bld	r8,0x6
80007f1a:	e0 81 0f 1a 	brne	80009d4e <_vfprintf_r+0x1f0a>
80007f1e:	82 68       	ld.sh	r8,r1[0xc]
80007f20:	a7 a8       	sbr	r8,0x6
80007f22:	a2 68       	st.h	r1[0xc],r8
80007f24:	e0 8f 0f 15 	bral	80009d4e <_vfprintf_r+0x1f0a>
80007f28:	30 08       	mov	r8,0
80007f2a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f2e:	fb 48 06 90 	st.w	sp[1680],r8
80007f32:	fb 48 06 8c 	st.w	sp[1676],r8
80007f36:	fb 48 06 b0 	st.w	sp[1712],r8
80007f3a:	30 08       	mov	r8,0
80007f3c:	30 09       	mov	r9,0
80007f3e:	50 a7       	stdsp	sp[0x28],r7
80007f40:	50 78       	stdsp	sp[0x1c],r8
80007f42:	fa c3 f9 e0 	sub	r3,sp,-1568
80007f46:	3f f8       	mov	r8,-1
80007f48:	50 59       	stdsp	sp[0x14],r9
80007f4a:	fb 43 06 88 	st.w	sp[1672],r3
80007f4e:	fb 48 05 44 	st.w	sp[1348],r8
80007f52:	12 9c       	mov	r12,r9
80007f54:	50 69       	stdsp	sp[0x18],r9
80007f56:	50 d9       	stdsp	sp[0x34],r9
80007f58:	50 e9       	stdsp	sp[0x38],r9
80007f5a:	50 b9       	stdsp	sp[0x2c],r9
80007f5c:	12 97       	mov	r7,r9
80007f5e:	0a 94       	mov	r4,r5
80007f60:	40 a2       	lddsp	r2,sp[0x28]
80007f62:	32 5a       	mov	r10,37
80007f64:	30 08       	mov	r8,0
80007f66:	c0 28       	rjmp	80007f6a <_vfprintf_r+0x126>
80007f68:	2f f2       	sub	r2,-1
80007f6a:	05 89       	ld.ub	r9,r2[0x0]
80007f6c:	f0 09 18 00 	cp.b	r9,r8
80007f70:	5f 1b       	srne	r11
80007f72:	f4 09 18 00 	cp.b	r9,r10
80007f76:	5f 19       	srne	r9
80007f78:	f3 eb 00 0b 	and	r11,r9,r11
80007f7c:	f0 0b 18 00 	cp.b	r11,r8
80007f80:	cf 41       	brne	80007f68 <_vfprintf_r+0x124>
80007f82:	40 ab       	lddsp	r11,sp[0x28]
80007f84:	e4 0b 01 06 	sub	r6,r2,r11
80007f88:	c1 e0       	breq	80007fc4 <_vfprintf_r+0x180>
80007f8a:	fa f8 06 90 	ld.w	r8,sp[1680]
80007f8e:	0c 08       	add	r8,r6
80007f90:	87 0b       	st.w	r3[0x0],r11
80007f92:	fb 48 06 90 	st.w	sp[1680],r8
80007f96:	87 16       	st.w	r3[0x4],r6
80007f98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007f9c:	2f f8       	sub	r8,-1
80007f9e:	fb 48 06 8c 	st.w	sp[1676],r8
80007fa2:	58 78       	cp.w	r8,7
80007fa4:	e0 89 00 04 	brgt	80007fac <_vfprintf_r+0x168>
80007fa8:	2f 83       	sub	r3,-8
80007faa:	c0 a8       	rjmp	80007fbe <_vfprintf_r+0x17a>
80007fac:	fa ca f9 78 	sub	r10,sp,-1672
80007fb0:	02 9b       	mov	r11,r1
80007fb2:	08 9c       	mov	r12,r4
80007fb4:	c3 af       	rcall	80007e28 <__sprint_r>
80007fb6:	e0 81 0e c6 	brne	80009d42 <_vfprintf_r+0x1efe>
80007fba:	fa c3 f9 e0 	sub	r3,sp,-1568
80007fbe:	40 ba       	lddsp	r10,sp[0x2c]
80007fc0:	0c 0a       	add	r10,r6
80007fc2:	50 ba       	stdsp	sp[0x2c],r10
80007fc4:	05 89       	ld.ub	r9,r2[0x0]
80007fc6:	30 08       	mov	r8,0
80007fc8:	f0 09 18 00 	cp.b	r9,r8
80007fcc:	e0 80 0e aa 	breq	80009d20 <_vfprintf_r+0x1edc>
80007fd0:	30 09       	mov	r9,0
80007fd2:	fb 68 06 bb 	st.b	sp[1723],r8
80007fd6:	0e 96       	mov	r6,r7
80007fd8:	e4 c8 ff ff 	sub	r8,r2,-1
80007fdc:	3f fe       	mov	lr,-1
80007fde:	50 93       	stdsp	sp[0x24],r3
80007fe0:	50 41       	stdsp	sp[0x10],r1
80007fe2:	0e 93       	mov	r3,r7
80007fe4:	04 91       	mov	r1,r2
80007fe6:	50 89       	stdsp	sp[0x20],r9
80007fe8:	50 a8       	stdsp	sp[0x28],r8
80007fea:	50 2e       	stdsp	sp[0x8],lr
80007fec:	50 39       	stdsp	sp[0xc],r9
80007fee:	12 95       	mov	r5,r9
80007ff0:	12 90       	mov	r0,r9
80007ff2:	10 97       	mov	r7,r8
80007ff4:	08 92       	mov	r2,r4
80007ff6:	c0 78       	rjmp	80008004 <_vfprintf_r+0x1c0>
80007ff8:	3f fc       	mov	r12,-1
80007ffa:	08 97       	mov	r7,r4
80007ffc:	50 2c       	stdsp	sp[0x8],r12
80007ffe:	c0 38       	rjmp	80008004 <_vfprintf_r+0x1c0>
80008000:	30 0b       	mov	r11,0
80008002:	50 3b       	stdsp	sp[0xc],r11
80008004:	0f 38       	ld.ub	r8,r7++
80008006:	c0 28       	rjmp	8000800a <_vfprintf_r+0x1c6>
80008008:	12 90       	mov	r0,r9
8000800a:	f0 c9 00 20 	sub	r9,r8,32
8000800e:	e0 49 00 58 	cp.w	r9,88
80008012:	e0 8b 0a 30 	brhi	80009472 <_vfprintf_r+0x162e>
80008016:	fe ca a5 12 	sub	r10,pc,-23278
8000801a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000801e:	50 a7       	stdsp	sp[0x28],r7
80008020:	50 80       	stdsp	sp[0x20],r0
80008022:	0c 97       	mov	r7,r6
80008024:	04 94       	mov	r4,r2
80008026:	06 96       	mov	r6,r3
80008028:	02 92       	mov	r2,r1
8000802a:	fe c9 a2 ea 	sub	r9,pc,-23830
8000802e:	40 93       	lddsp	r3,sp[0x24]
80008030:	10 90       	mov	r0,r8
80008032:	40 41       	lddsp	r1,sp[0x10]
80008034:	50 d9       	stdsp	sp[0x34],r9
80008036:	e0 8f 08 8e 	bral	80009152 <_vfprintf_r+0x130e>
8000803a:	30 08       	mov	r8,0
8000803c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008040:	f0 09 18 00 	cp.b	r9,r8
80008044:	ce 01       	brne	80008004 <_vfprintf_r+0x1c0>
80008046:	32 08       	mov	r8,32
80008048:	c6 e8       	rjmp	80008124 <_vfprintf_r+0x2e0>
8000804a:	a1 a5       	sbr	r5,0x0
8000804c:	cd cb       	rjmp	80008004 <_vfprintf_r+0x1c0>
8000804e:	0f 89       	ld.ub	r9,r7[0x0]
80008050:	f2 c8 00 30 	sub	r8,r9,48
80008054:	58 98       	cp.w	r8,9
80008056:	e0 8b 00 1d 	brhi	80008090 <_vfprintf_r+0x24c>
8000805a:	ee c8 ff ff 	sub	r8,r7,-1
8000805e:	30 0b       	mov	r11,0
80008060:	23 09       	sub	r9,48
80008062:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008066:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000806a:	11 39       	ld.ub	r9,r8++
8000806c:	f2 ca 00 30 	sub	r10,r9,48
80008070:	58 9a       	cp.w	r10,9
80008072:	fe 98 ff f7 	brls	80008060 <_vfprintf_r+0x21c>
80008076:	e0 49 00 24 	cp.w	r9,36
8000807a:	cc 31       	brne	80008000 <_vfprintf_r+0x1bc>
8000807c:	e0 4b 00 20 	cp.w	r11,32
80008080:	e0 89 0e 60 	brgt	80009d40 <_vfprintf_r+0x1efc>
80008084:	20 1b       	sub	r11,1
80008086:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000808a:	12 3b       	cp.w	r11,r9
8000808c:	c0 95       	brlt	8000809e <_vfprintf_r+0x25a>
8000808e:	c1 08       	rjmp	800080ae <_vfprintf_r+0x26a>
80008090:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008094:	ec ca ff ff 	sub	r10,r6,-1
80008098:	12 36       	cp.w	r6,r9
8000809a:	c1 f5       	brlt	800080d8 <_vfprintf_r+0x294>
8000809c:	c2 68       	rjmp	800080e8 <_vfprintf_r+0x2a4>
8000809e:	fa ce f9 44 	sub	lr,sp,-1724
800080a2:	10 97       	mov	r7,r8
800080a4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800080a8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800080ac:	c3 58       	rjmp	80008116 <_vfprintf_r+0x2d2>
800080ae:	10 97       	mov	r7,r8
800080b0:	fa c8 f9 50 	sub	r8,sp,-1712
800080b4:	1a d8       	st.w	--sp,r8
800080b6:	fa c8 fa b8 	sub	r8,sp,-1352
800080ba:	1a d8       	st.w	--sp,r8
800080bc:	fa c8 fb b4 	sub	r8,sp,-1100
800080c0:	02 9a       	mov	r10,r1
800080c2:	1a d8       	st.w	--sp,r8
800080c4:	04 9c       	mov	r12,r2
800080c6:	fa c8 f9 40 	sub	r8,sp,-1728
800080ca:	fa c9 ff b4 	sub	r9,sp,-76
800080ce:	fe b0 fd 23 	rcall	80007b14 <get_arg>
800080d2:	2f dd       	sub	sp,-12
800080d4:	78 00       	ld.w	r0,r12[0x0]
800080d6:	c2 08       	rjmp	80008116 <_vfprintf_r+0x2d2>
800080d8:	fa cc f9 44 	sub	r12,sp,-1724
800080dc:	14 96       	mov	r6,r10
800080de:	f8 03 00 38 	add	r8,r12,r3<<0x3
800080e2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800080e6:	c1 88       	rjmp	80008116 <_vfprintf_r+0x2d2>
800080e8:	41 08       	lddsp	r8,sp[0x40]
800080ea:	59 f9       	cp.w	r9,31
800080ec:	e0 89 00 11 	brgt	8000810e <_vfprintf_r+0x2ca>
800080f0:	f0 cb ff fc 	sub	r11,r8,-4
800080f4:	51 0b       	stdsp	sp[0x40],r11
800080f6:	70 00       	ld.w	r0,r8[0x0]
800080f8:	fa cb f9 44 	sub	r11,sp,-1724
800080fc:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008100:	f1 40 fd 88 	st.w	r8[-632],r0
80008104:	2f f9       	sub	r9,-1
80008106:	14 96       	mov	r6,r10
80008108:	fb 49 06 b4 	st.w	sp[1716],r9
8000810c:	c0 58       	rjmp	80008116 <_vfprintf_r+0x2d2>
8000810e:	70 00       	ld.w	r0,r8[0x0]
80008110:	14 96       	mov	r6,r10
80008112:	2f c8       	sub	r8,-4
80008114:	51 08       	stdsp	sp[0x40],r8
80008116:	58 00       	cp.w	r0,0
80008118:	fe 94 ff 76 	brge	80008004 <_vfprintf_r+0x1c0>
8000811c:	5c 30       	neg	r0
8000811e:	a3 a5       	sbr	r5,0x2
80008120:	c7 2b       	rjmp	80008004 <_vfprintf_r+0x1c0>
80008122:	32 b8       	mov	r8,43
80008124:	fb 68 06 bb 	st.b	sp[1723],r8
80008128:	c6 eb       	rjmp	80008004 <_vfprintf_r+0x1c0>
8000812a:	0f 38       	ld.ub	r8,r7++
8000812c:	e0 48 00 2a 	cp.w	r8,42
80008130:	c0 30       	breq	80008136 <_vfprintf_r+0x2f2>
80008132:	30 09       	mov	r9,0
80008134:	c7 98       	rjmp	80008226 <_vfprintf_r+0x3e2>
80008136:	0f 88       	ld.ub	r8,r7[0x0]
80008138:	f0 c9 00 30 	sub	r9,r8,48
8000813c:	58 99       	cp.w	r9,9
8000813e:	e0 8b 00 1f 	brhi	8000817c <_vfprintf_r+0x338>
80008142:	ee c4 ff ff 	sub	r4,r7,-1
80008146:	30 0b       	mov	r11,0
80008148:	23 08       	sub	r8,48
8000814a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000814e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008152:	09 38       	ld.ub	r8,r4++
80008154:	f0 c9 00 30 	sub	r9,r8,48
80008158:	58 99       	cp.w	r9,9
8000815a:	fe 98 ff f7 	brls	80008148 <_vfprintf_r+0x304>
8000815e:	e0 48 00 24 	cp.w	r8,36
80008162:	fe 91 ff 4f 	brne	80008000 <_vfprintf_r+0x1bc>
80008166:	e0 4b 00 20 	cp.w	r11,32
8000816a:	e0 89 0d eb 	brgt	80009d40 <_vfprintf_r+0x1efc>
8000816e:	20 1b       	sub	r11,1
80008170:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008174:	10 3b       	cp.w	r11,r8
80008176:	c0 a5       	brlt	8000818a <_vfprintf_r+0x346>
80008178:	c1 18       	rjmp	8000819a <_vfprintf_r+0x356>
8000817a:	d7 03       	nop
8000817c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008180:	ec c9 ff ff 	sub	r9,r6,-1
80008184:	14 36       	cp.w	r6,r10
80008186:	c1 f5       	brlt	800081c4 <_vfprintf_r+0x380>
80008188:	c2 88       	rjmp	800081d8 <_vfprintf_r+0x394>
8000818a:	fa ca f9 44 	sub	r10,sp,-1724
8000818e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008192:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008196:	50 2b       	stdsp	sp[0x8],r11
80008198:	c3 c8       	rjmp	80008210 <_vfprintf_r+0x3cc>
8000819a:	fa c8 f9 50 	sub	r8,sp,-1712
8000819e:	1a d8       	st.w	--sp,r8
800081a0:	fa c8 fa b8 	sub	r8,sp,-1352
800081a4:	1a d8       	st.w	--sp,r8
800081a6:	fa c8 fb b4 	sub	r8,sp,-1100
800081aa:	02 9a       	mov	r10,r1
800081ac:	1a d8       	st.w	--sp,r8
800081ae:	04 9c       	mov	r12,r2
800081b0:	fa c8 f9 40 	sub	r8,sp,-1728
800081b4:	fa c9 ff b4 	sub	r9,sp,-76
800081b8:	fe b0 fc ae 	rcall	80007b14 <get_arg>
800081bc:	2f dd       	sub	sp,-12
800081be:	78 0c       	ld.w	r12,r12[0x0]
800081c0:	50 2c       	stdsp	sp[0x8],r12
800081c2:	c2 78       	rjmp	80008210 <_vfprintf_r+0x3cc>
800081c4:	12 96       	mov	r6,r9
800081c6:	0e 94       	mov	r4,r7
800081c8:	fa c9 f9 44 	sub	r9,sp,-1724
800081cc:	f2 03 00 38 	add	r8,r9,r3<<0x3
800081d0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800081d4:	50 28       	stdsp	sp[0x8],r8
800081d6:	c1 d8       	rjmp	80008210 <_vfprintf_r+0x3cc>
800081d8:	41 08       	lddsp	r8,sp[0x40]
800081da:	59 fa       	cp.w	r10,31
800081dc:	e0 89 00 14 	brgt	80008204 <_vfprintf_r+0x3c0>
800081e0:	f0 cb ff fc 	sub	r11,r8,-4
800081e4:	70 08       	ld.w	r8,r8[0x0]
800081e6:	51 0b       	stdsp	sp[0x40],r11
800081e8:	50 28       	stdsp	sp[0x8],r8
800081ea:	fa c6 f9 44 	sub	r6,sp,-1724
800081ee:	40 2e       	lddsp	lr,sp[0x8]
800081f0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800081f4:	f1 4e fd 88 	st.w	r8[-632],lr
800081f8:	2f fa       	sub	r10,-1
800081fa:	0e 94       	mov	r4,r7
800081fc:	fb 4a 06 b4 	st.w	sp[1716],r10
80008200:	12 96       	mov	r6,r9
80008202:	c0 78       	rjmp	80008210 <_vfprintf_r+0x3cc>
80008204:	70 0c       	ld.w	r12,r8[0x0]
80008206:	0e 94       	mov	r4,r7
80008208:	2f c8       	sub	r8,-4
8000820a:	50 2c       	stdsp	sp[0x8],r12
8000820c:	12 96       	mov	r6,r9
8000820e:	51 08       	stdsp	sp[0x40],r8
80008210:	40 2b       	lddsp	r11,sp[0x8]
80008212:	58 0b       	cp.w	r11,0
80008214:	fe 95 fe f2 	brlt	80007ff8 <_vfprintf_r+0x1b4>
80008218:	08 97       	mov	r7,r4
8000821a:	cf 5a       	rjmp	80008004 <_vfprintf_r+0x1c0>
8000821c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008220:	0f 38       	ld.ub	r8,r7++
80008222:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008226:	f0 ca 00 30 	sub	r10,r8,48
8000822a:	58 9a       	cp.w	r10,9
8000822c:	fe 98 ff f8 	brls	8000821c <_vfprintf_r+0x3d8>
80008230:	3f fa       	mov	r10,-1
80008232:	f2 0a 0c 49 	max	r9,r9,r10
80008236:	50 29       	stdsp	sp[0x8],r9
80008238:	ce 9a       	rjmp	8000800a <_vfprintf_r+0x1c6>
8000823a:	a7 b5       	sbr	r5,0x7
8000823c:	ce 4a       	rjmp	80008004 <_vfprintf_r+0x1c0>
8000823e:	30 09       	mov	r9,0
80008240:	23 08       	sub	r8,48
80008242:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008246:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000824a:	0f 38       	ld.ub	r8,r7++
8000824c:	f0 ca 00 30 	sub	r10,r8,48
80008250:	58 9a       	cp.w	r10,9
80008252:	fe 98 ff f7 	brls	80008240 <_vfprintf_r+0x3fc>
80008256:	e0 48 00 24 	cp.w	r8,36
8000825a:	fe 91 fe d7 	brne	80008008 <_vfprintf_r+0x1c4>
8000825e:	e0 49 00 20 	cp.w	r9,32
80008262:	e0 89 0d 6f 	brgt	80009d40 <_vfprintf_r+0x1efc>
80008266:	f2 c3 00 01 	sub	r3,r9,1
8000826a:	30 19       	mov	r9,1
8000826c:	50 39       	stdsp	sp[0xc],r9
8000826e:	cc ba       	rjmp	80008004 <_vfprintf_r+0x1c0>
80008270:	a3 b5       	sbr	r5,0x3
80008272:	cc 9a       	rjmp	80008004 <_vfprintf_r+0x1c0>
80008274:	a7 a5       	sbr	r5,0x6
80008276:	cc 7a       	rjmp	80008004 <_vfprintf_r+0x1c0>
80008278:	0a 98       	mov	r8,r5
8000827a:	a5 b5       	sbr	r5,0x5
8000827c:	a5 a8       	sbr	r8,0x4
8000827e:	0f 89       	ld.ub	r9,r7[0x0]
80008280:	36 ce       	mov	lr,108
80008282:	fc 09 18 00 	cp.b	r9,lr
80008286:	f7 b7 00 ff 	subeq	r7,-1
8000828a:	f0 05 17 10 	movne	r5,r8
8000828e:	cb ba       	rjmp	80008004 <_vfprintf_r+0x1c0>
80008290:	a5 b5       	sbr	r5,0x5
80008292:	cb 9a       	rjmp	80008004 <_vfprintf_r+0x1c0>
80008294:	50 a7       	stdsp	sp[0x28],r7
80008296:	50 80       	stdsp	sp[0x20],r0
80008298:	0c 97       	mov	r7,r6
8000829a:	10 90       	mov	r0,r8
8000829c:	06 96       	mov	r6,r3
8000829e:	04 94       	mov	r4,r2
800082a0:	40 93       	lddsp	r3,sp[0x24]
800082a2:	02 92       	mov	r2,r1
800082a4:	0e 99       	mov	r9,r7
800082a6:	40 41       	lddsp	r1,sp[0x10]
800082a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082ac:	40 3c       	lddsp	r12,sp[0xc]
800082ae:	58 0c       	cp.w	r12,0
800082b0:	c1 d0       	breq	800082ea <_vfprintf_r+0x4a6>
800082b2:	10 36       	cp.w	r6,r8
800082b4:	c0 64       	brge	800082c0 <_vfprintf_r+0x47c>
800082b6:	fa cb f9 44 	sub	r11,sp,-1724
800082ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082be:	c1 d8       	rjmp	800082f8 <_vfprintf_r+0x4b4>
800082c0:	fa c8 f9 50 	sub	r8,sp,-1712
800082c4:	1a d8       	st.w	--sp,r8
800082c6:	fa c8 fa b8 	sub	r8,sp,-1352
800082ca:	1a d8       	st.w	--sp,r8
800082cc:	fa c8 fb b4 	sub	r8,sp,-1100
800082d0:	1a d8       	st.w	--sp,r8
800082d2:	fa c8 f9 40 	sub	r8,sp,-1728
800082d6:	fa c9 ff b4 	sub	r9,sp,-76
800082da:	04 9a       	mov	r10,r2
800082dc:	0c 9b       	mov	r11,r6
800082de:	08 9c       	mov	r12,r4
800082e0:	fe b0 fc 1a 	rcall	80007b14 <get_arg>
800082e4:	2f dd       	sub	sp,-12
800082e6:	19 b8       	ld.ub	r8,r12[0x3]
800082e8:	c2 28       	rjmp	8000832c <_vfprintf_r+0x4e8>
800082ea:	2f f7       	sub	r7,-1
800082ec:	10 39       	cp.w	r9,r8
800082ee:	c0 84       	brge	800082fe <_vfprintf_r+0x4ba>
800082f0:	fa ca f9 44 	sub	r10,sp,-1724
800082f4:	f4 06 00 36 	add	r6,r10,r6<<0x3
800082f8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800082fc:	c1 88       	rjmp	8000832c <_vfprintf_r+0x4e8>
800082fe:	41 09       	lddsp	r9,sp[0x40]
80008300:	59 f8       	cp.w	r8,31
80008302:	e0 89 00 12 	brgt	80008326 <_vfprintf_r+0x4e2>
80008306:	f2 ca ff fc 	sub	r10,r9,-4
8000830a:	51 0a       	stdsp	sp[0x40],r10
8000830c:	72 09       	ld.w	r9,r9[0x0]
8000830e:	fa c6 f9 44 	sub	r6,sp,-1724
80008312:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008316:	2f f8       	sub	r8,-1
80008318:	f5 49 fd 88 	st.w	r10[-632],r9
8000831c:	fb 48 06 b4 	st.w	sp[1716],r8
80008320:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008324:	c0 48       	rjmp	8000832c <_vfprintf_r+0x4e8>
80008326:	13 b8       	ld.ub	r8,r9[0x3]
80008328:	2f c9       	sub	r9,-4
8000832a:	51 09       	stdsp	sp[0x40],r9
8000832c:	fb 68 06 60 	st.b	sp[1632],r8
80008330:	30 0e       	mov	lr,0
80008332:	30 08       	mov	r8,0
80008334:	30 12       	mov	r2,1
80008336:	fb 68 06 bb 	st.b	sp[1723],r8
8000833a:	50 2e       	stdsp	sp[0x8],lr
8000833c:	e0 8f 08 ad 	bral	80009496 <_vfprintf_r+0x1652>
80008340:	50 a7       	stdsp	sp[0x28],r7
80008342:	50 80       	stdsp	sp[0x20],r0
80008344:	0c 97       	mov	r7,r6
80008346:	04 94       	mov	r4,r2
80008348:	06 96       	mov	r6,r3
8000834a:	02 92       	mov	r2,r1
8000834c:	40 93       	lddsp	r3,sp[0x24]
8000834e:	10 90       	mov	r0,r8
80008350:	40 41       	lddsp	r1,sp[0x10]
80008352:	a5 a5       	sbr	r5,0x4
80008354:	c0 a8       	rjmp	80008368 <_vfprintf_r+0x524>
80008356:	50 a7       	stdsp	sp[0x28],r7
80008358:	50 80       	stdsp	sp[0x20],r0
8000835a:	0c 97       	mov	r7,r6
8000835c:	04 94       	mov	r4,r2
8000835e:	06 96       	mov	r6,r3
80008360:	02 92       	mov	r2,r1
80008362:	40 93       	lddsp	r3,sp[0x24]
80008364:	10 90       	mov	r0,r8
80008366:	40 41       	lddsp	r1,sp[0x10]
80008368:	ed b5 00 05 	bld	r5,0x5
8000836c:	c5 11       	brne	8000840e <_vfprintf_r+0x5ca>
8000836e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008372:	40 3c       	lddsp	r12,sp[0xc]
80008374:	58 0c       	cp.w	r12,0
80008376:	c1 e0       	breq	800083b2 <_vfprintf_r+0x56e>
80008378:	10 36       	cp.w	r6,r8
8000837a:	c0 64       	brge	80008386 <_vfprintf_r+0x542>
8000837c:	fa cb f9 44 	sub	r11,sp,-1724
80008380:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008384:	c2 08       	rjmp	800083c4 <_vfprintf_r+0x580>
80008386:	fa c8 f9 50 	sub	r8,sp,-1712
8000838a:	1a d8       	st.w	--sp,r8
8000838c:	fa c8 fa b8 	sub	r8,sp,-1352
80008390:	0c 9b       	mov	r11,r6
80008392:	1a d8       	st.w	--sp,r8
80008394:	fa c8 fb b4 	sub	r8,sp,-1100
80008398:	1a d8       	st.w	--sp,r8
8000839a:	fa c9 ff b4 	sub	r9,sp,-76
8000839e:	fa c8 f9 40 	sub	r8,sp,-1728
800083a2:	04 9a       	mov	r10,r2
800083a4:	08 9c       	mov	r12,r4
800083a6:	fe b0 fb b7 	rcall	80007b14 <get_arg>
800083aa:	2f dd       	sub	sp,-12
800083ac:	78 1b       	ld.w	r11,r12[0x4]
800083ae:	78 09       	ld.w	r9,r12[0x0]
800083b0:	c2 b8       	rjmp	80008406 <_vfprintf_r+0x5c2>
800083b2:	ee ca ff ff 	sub	r10,r7,-1
800083b6:	10 37       	cp.w	r7,r8
800083b8:	c0 b4       	brge	800083ce <_vfprintf_r+0x58a>
800083ba:	fa c9 f9 44 	sub	r9,sp,-1724
800083be:	14 97       	mov	r7,r10
800083c0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800083c4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800083c8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800083cc:	c1 d8       	rjmp	80008406 <_vfprintf_r+0x5c2>
800083ce:	41 09       	lddsp	r9,sp[0x40]
800083d0:	59 f8       	cp.w	r8,31
800083d2:	e0 89 00 14 	brgt	800083fa <_vfprintf_r+0x5b6>
800083d6:	f2 cb ff f8 	sub	r11,r9,-8
800083da:	51 0b       	stdsp	sp[0x40],r11
800083dc:	fa c6 f9 44 	sub	r6,sp,-1724
800083e0:	72 1b       	ld.w	r11,r9[0x4]
800083e2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800083e6:	72 09       	ld.w	r9,r9[0x0]
800083e8:	f9 4b fd 8c 	st.w	r12[-628],r11
800083ec:	f9 49 fd 88 	st.w	r12[-632],r9
800083f0:	2f f8       	sub	r8,-1
800083f2:	14 97       	mov	r7,r10
800083f4:	fb 48 06 b4 	st.w	sp[1716],r8
800083f8:	c0 78       	rjmp	80008406 <_vfprintf_r+0x5c2>
800083fa:	f2 c8 ff f8 	sub	r8,r9,-8
800083fe:	72 1b       	ld.w	r11,r9[0x4]
80008400:	14 97       	mov	r7,r10
80008402:	51 08       	stdsp	sp[0x40],r8
80008404:	72 09       	ld.w	r9,r9[0x0]
80008406:	16 98       	mov	r8,r11
80008408:	fa e9 00 00 	st.d	sp[0],r8
8000840c:	ca e8       	rjmp	80008568 <_vfprintf_r+0x724>
8000840e:	ed b5 00 04 	bld	r5,0x4
80008412:	c1 71       	brne	80008440 <_vfprintf_r+0x5fc>
80008414:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008418:	40 3e       	lddsp	lr,sp[0xc]
8000841a:	58 0e       	cp.w	lr,0
8000841c:	c0 80       	breq	8000842c <_vfprintf_r+0x5e8>
8000841e:	10 36       	cp.w	r6,r8
80008420:	c6 94       	brge	800084f2 <_vfprintf_r+0x6ae>
80008422:	fa cc f9 44 	sub	r12,sp,-1724
80008426:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000842a:	c8 28       	rjmp	8000852e <_vfprintf_r+0x6ea>
8000842c:	ee ca ff ff 	sub	r10,r7,-1
80008430:	10 37       	cp.w	r7,r8
80008432:	e0 84 00 81 	brge	80008534 <_vfprintf_r+0x6f0>
80008436:	fa cb f9 44 	sub	r11,sp,-1724
8000843a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000843e:	c7 78       	rjmp	8000852c <_vfprintf_r+0x6e8>
80008440:	ed b5 00 06 	bld	r5,0x6
80008444:	c4 b1       	brne	800084da <_vfprintf_r+0x696>
80008446:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000844a:	40 3c       	lddsp	r12,sp[0xc]
8000844c:	58 0c       	cp.w	r12,0
8000844e:	c1 d0       	breq	80008488 <_vfprintf_r+0x644>
80008450:	10 36       	cp.w	r6,r8
80008452:	c0 64       	brge	8000845e <_vfprintf_r+0x61a>
80008454:	fa cb f9 44 	sub	r11,sp,-1724
80008458:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000845c:	c1 f8       	rjmp	8000849a <_vfprintf_r+0x656>
8000845e:	fa c8 f9 50 	sub	r8,sp,-1712
80008462:	1a d8       	st.w	--sp,r8
80008464:	fa c8 fa b8 	sub	r8,sp,-1352
80008468:	1a d8       	st.w	--sp,r8
8000846a:	fa c8 fb b4 	sub	r8,sp,-1100
8000846e:	1a d8       	st.w	--sp,r8
80008470:	fa c8 f9 40 	sub	r8,sp,-1728
80008474:	fa c9 ff b4 	sub	r9,sp,-76
80008478:	04 9a       	mov	r10,r2
8000847a:	0c 9b       	mov	r11,r6
8000847c:	08 9c       	mov	r12,r4
8000847e:	fe b0 fb 4b 	rcall	80007b14 <get_arg>
80008482:	2f dd       	sub	sp,-12
80008484:	98 18       	ld.sh	r8,r12[0x2]
80008486:	c2 68       	rjmp	800084d2 <_vfprintf_r+0x68e>
80008488:	ee ca ff ff 	sub	r10,r7,-1
8000848c:	10 37       	cp.w	r7,r8
8000848e:	c0 94       	brge	800084a0 <_vfprintf_r+0x65c>
80008490:	fa c9 f9 44 	sub	r9,sp,-1724
80008494:	14 97       	mov	r7,r10
80008496:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000849a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000849e:	c1 a8       	rjmp	800084d2 <_vfprintf_r+0x68e>
800084a0:	41 09       	lddsp	r9,sp[0x40]
800084a2:	59 f8       	cp.w	r8,31
800084a4:	e0 89 00 13 	brgt	800084ca <_vfprintf_r+0x686>
800084a8:	f2 cb ff fc 	sub	r11,r9,-4
800084ac:	51 0b       	stdsp	sp[0x40],r11
800084ae:	72 09       	ld.w	r9,r9[0x0]
800084b0:	fa c6 f9 44 	sub	r6,sp,-1724
800084b4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800084b8:	2f f8       	sub	r8,-1
800084ba:	f7 49 fd 88 	st.w	r11[-632],r9
800084be:	fb 48 06 b4 	st.w	sp[1716],r8
800084c2:	14 97       	mov	r7,r10
800084c4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800084c8:	c0 58       	rjmp	800084d2 <_vfprintf_r+0x68e>
800084ca:	92 18       	ld.sh	r8,r9[0x2]
800084cc:	14 97       	mov	r7,r10
800084ce:	2f c9       	sub	r9,-4
800084d0:	51 09       	stdsp	sp[0x40],r9
800084d2:	50 18       	stdsp	sp[0x4],r8
800084d4:	bf 58       	asr	r8,0x1f
800084d6:	50 08       	stdsp	sp[0x0],r8
800084d8:	c4 88       	rjmp	80008568 <_vfprintf_r+0x724>
800084da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084de:	40 3c       	lddsp	r12,sp[0xc]
800084e0:	58 0c       	cp.w	r12,0
800084e2:	c1 d0       	breq	8000851c <_vfprintf_r+0x6d8>
800084e4:	10 36       	cp.w	r6,r8
800084e6:	c0 64       	brge	800084f2 <_vfprintf_r+0x6ae>
800084e8:	fa cb f9 44 	sub	r11,sp,-1724
800084ec:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084f0:	c1 f8       	rjmp	8000852e <_vfprintf_r+0x6ea>
800084f2:	fa c8 f9 50 	sub	r8,sp,-1712
800084f6:	1a d8       	st.w	--sp,r8
800084f8:	fa c8 fa b8 	sub	r8,sp,-1352
800084fc:	0c 9b       	mov	r11,r6
800084fe:	1a d8       	st.w	--sp,r8
80008500:	fa c8 fb b4 	sub	r8,sp,-1100
80008504:	04 9a       	mov	r10,r2
80008506:	1a d8       	st.w	--sp,r8
80008508:	08 9c       	mov	r12,r4
8000850a:	fa c8 f9 40 	sub	r8,sp,-1728
8000850e:	fa c9 ff b4 	sub	r9,sp,-76
80008512:	fe b0 fb 01 	rcall	80007b14 <get_arg>
80008516:	2f dd       	sub	sp,-12
80008518:	78 0b       	ld.w	r11,r12[0x0]
8000851a:	c2 48       	rjmp	80008562 <_vfprintf_r+0x71e>
8000851c:	ee ca ff ff 	sub	r10,r7,-1
80008520:	10 37       	cp.w	r7,r8
80008522:	c0 94       	brge	80008534 <_vfprintf_r+0x6f0>
80008524:	fa c9 f9 44 	sub	r9,sp,-1724
80008528:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000852c:	14 97       	mov	r7,r10
8000852e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008532:	c1 88       	rjmp	80008562 <_vfprintf_r+0x71e>
80008534:	41 09       	lddsp	r9,sp[0x40]
80008536:	59 f8       	cp.w	r8,31
80008538:	e0 89 00 11 	brgt	8000855a <_vfprintf_r+0x716>
8000853c:	f2 cb ff fc 	sub	r11,r9,-4
80008540:	51 0b       	stdsp	sp[0x40],r11
80008542:	fa c6 f9 44 	sub	r6,sp,-1724
80008546:	72 0b       	ld.w	r11,r9[0x0]
80008548:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000854c:	f3 4b fd 88 	st.w	r9[-632],r11
80008550:	2f f8       	sub	r8,-1
80008552:	14 97       	mov	r7,r10
80008554:	fb 48 06 b4 	st.w	sp[1716],r8
80008558:	c0 58       	rjmp	80008562 <_vfprintf_r+0x71e>
8000855a:	72 0b       	ld.w	r11,r9[0x0]
8000855c:	14 97       	mov	r7,r10
8000855e:	2f c9       	sub	r9,-4
80008560:	51 09       	stdsp	sp[0x40],r9
80008562:	50 1b       	stdsp	sp[0x4],r11
80008564:	bf 5b       	asr	r11,0x1f
80008566:	50 0b       	stdsp	sp[0x0],r11
80008568:	fa ea 00 00 	ld.d	r10,sp[0]
8000856c:	58 0a       	cp.w	r10,0
8000856e:	5c 2b       	cpc	r11
80008570:	c0 e4       	brge	8000858c <_vfprintf_r+0x748>
80008572:	30 08       	mov	r8,0
80008574:	fa ea 00 00 	ld.d	r10,sp[0]
80008578:	30 09       	mov	r9,0
8000857a:	f0 0a 01 0a 	sub	r10,r8,r10
8000857e:	f2 0b 01 4b 	sbc	r11,r9,r11
80008582:	32 d8       	mov	r8,45
80008584:	fa eb 00 00 	st.d	sp[0],r10
80008588:	fb 68 06 bb 	st.b	sp[1723],r8
8000858c:	30 18       	mov	r8,1
8000858e:	e0 8f 06 fa 	bral	80009382 <_vfprintf_r+0x153e>
80008592:	50 a7       	stdsp	sp[0x28],r7
80008594:	50 80       	stdsp	sp[0x20],r0
80008596:	0c 97       	mov	r7,r6
80008598:	04 94       	mov	r4,r2
8000859a:	06 96       	mov	r6,r3
8000859c:	02 92       	mov	r2,r1
8000859e:	40 93       	lddsp	r3,sp[0x24]
800085a0:	10 90       	mov	r0,r8
800085a2:	40 41       	lddsp	r1,sp[0x10]
800085a4:	0e 99       	mov	r9,r7
800085a6:	ed b5 00 03 	bld	r5,0x3
800085aa:	c4 11       	brne	8000862c <_vfprintf_r+0x7e8>
800085ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085b0:	40 3a       	lddsp	r10,sp[0xc]
800085b2:	58 0a       	cp.w	r10,0
800085b4:	c1 90       	breq	800085e6 <_vfprintf_r+0x7a2>
800085b6:	10 36       	cp.w	r6,r8
800085b8:	c6 45       	brlt	80008680 <_vfprintf_r+0x83c>
800085ba:	fa c8 f9 50 	sub	r8,sp,-1712
800085be:	1a d8       	st.w	--sp,r8
800085c0:	fa c8 fa b8 	sub	r8,sp,-1352
800085c4:	1a d8       	st.w	--sp,r8
800085c6:	fa c8 fb b4 	sub	r8,sp,-1100
800085ca:	0c 9b       	mov	r11,r6
800085cc:	1a d8       	st.w	--sp,r8
800085ce:	04 9a       	mov	r10,r2
800085d0:	fa c8 f9 40 	sub	r8,sp,-1728
800085d4:	fa c9 ff b4 	sub	r9,sp,-76
800085d8:	08 9c       	mov	r12,r4
800085da:	fe b0 fa 9d 	rcall	80007b14 <get_arg>
800085de:	2f dd       	sub	sp,-12
800085e0:	78 16       	ld.w	r6,r12[0x4]
800085e2:	50 76       	stdsp	sp[0x1c],r6
800085e4:	c4 88       	rjmp	80008674 <_vfprintf_r+0x830>
800085e6:	2f f7       	sub	r7,-1
800085e8:	10 39       	cp.w	r9,r8
800085ea:	c0 c4       	brge	80008602 <_vfprintf_r+0x7be>
800085ec:	fa ce f9 44 	sub	lr,sp,-1724
800085f0:	fc 06 00 36 	add	r6,lr,r6<<0x3
800085f4:	ec fc fd 8c 	ld.w	r12,r6[-628]
800085f8:	50 7c       	stdsp	sp[0x1c],r12
800085fa:	ec f6 fd 88 	ld.w	r6,r6[-632]
800085fe:	50 56       	stdsp	sp[0x14],r6
80008600:	c6 68       	rjmp	800086cc <_vfprintf_r+0x888>
80008602:	41 09       	lddsp	r9,sp[0x40]
80008604:	59 f8       	cp.w	r8,31
80008606:	e0 89 00 10 	brgt	80008626 <_vfprintf_r+0x7e2>
8000860a:	f2 ca ff f8 	sub	r10,r9,-8
8000860e:	72 1b       	ld.w	r11,r9[0x4]
80008610:	51 0a       	stdsp	sp[0x40],r10
80008612:	72 09       	ld.w	r9,r9[0x0]
80008614:	fa ca f9 44 	sub	r10,sp,-1724
80008618:	50 7b       	stdsp	sp[0x1c],r11
8000861a:	50 59       	stdsp	sp[0x14],r9
8000861c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008620:	40 5b       	lddsp	r11,sp[0x14]
80008622:	40 7a       	lddsp	r10,sp[0x1c]
80008624:	c4 78       	rjmp	800086b2 <_vfprintf_r+0x86e>
80008626:	72 18       	ld.w	r8,r9[0x4]
80008628:	50 78       	stdsp	sp[0x1c],r8
8000862a:	c4 c8       	rjmp	800086c2 <_vfprintf_r+0x87e>
8000862c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008630:	40 3e       	lddsp	lr,sp[0xc]
80008632:	58 0e       	cp.w	lr,0
80008634:	c2 30       	breq	8000867a <_vfprintf_r+0x836>
80008636:	10 36       	cp.w	r6,r8
80008638:	c0 94       	brge	8000864a <_vfprintf_r+0x806>
8000863a:	fa cc f9 44 	sub	r12,sp,-1724
8000863e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008642:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008646:	50 7b       	stdsp	sp[0x1c],r11
80008648:	cd 9b       	rjmp	800085fa <_vfprintf_r+0x7b6>
8000864a:	fa c8 f9 50 	sub	r8,sp,-1712
8000864e:	1a d8       	st.w	--sp,r8
80008650:	fa c8 fa b8 	sub	r8,sp,-1352
80008654:	04 9a       	mov	r10,r2
80008656:	1a d8       	st.w	--sp,r8
80008658:	fa c8 fb b4 	sub	r8,sp,-1100
8000865c:	0c 9b       	mov	r11,r6
8000865e:	1a d8       	st.w	--sp,r8
80008660:	08 9c       	mov	r12,r4
80008662:	fa c8 f9 40 	sub	r8,sp,-1728
80008666:	fa c9 ff b4 	sub	r9,sp,-76
8000866a:	fe b0 fa 55 	rcall	80007b14 <get_arg>
8000866e:	2f dd       	sub	sp,-12
80008670:	78 1a       	ld.w	r10,r12[0x4]
80008672:	50 7a       	stdsp	sp[0x1c],r10
80008674:	78 0c       	ld.w	r12,r12[0x0]
80008676:	50 5c       	stdsp	sp[0x14],r12
80008678:	c2 a8       	rjmp	800086cc <_vfprintf_r+0x888>
8000867a:	2f f7       	sub	r7,-1
8000867c:	10 39       	cp.w	r9,r8
8000867e:	c0 94       	brge	80008690 <_vfprintf_r+0x84c>
80008680:	fa c9 f9 44 	sub	r9,sp,-1724
80008684:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008688:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000868c:	50 78       	stdsp	sp[0x1c],r8
8000868e:	cb 6b       	rjmp	800085fa <_vfprintf_r+0x7b6>
80008690:	41 09       	lddsp	r9,sp[0x40]
80008692:	59 f8       	cp.w	r8,31
80008694:	e0 89 00 15 	brgt	800086be <_vfprintf_r+0x87a>
80008698:	f2 ca ff f8 	sub	r10,r9,-8
8000869c:	72 16       	ld.w	r6,r9[0x4]
8000869e:	72 09       	ld.w	r9,r9[0x0]
800086a0:	51 0a       	stdsp	sp[0x40],r10
800086a2:	50 59       	stdsp	sp[0x14],r9
800086a4:	fa ce f9 44 	sub	lr,sp,-1724
800086a8:	50 76       	stdsp	sp[0x1c],r6
800086aa:	fc 08 00 39 	add	r9,lr,r8<<0x3
800086ae:	40 5b       	lddsp	r11,sp[0x14]
800086b0:	0c 9a       	mov	r10,r6
800086b2:	f2 eb fd 88 	st.d	r9[-632],r10
800086b6:	2f f8       	sub	r8,-1
800086b8:	fb 48 06 b4 	st.w	sp[1716],r8
800086bc:	c0 88       	rjmp	800086cc <_vfprintf_r+0x888>
800086be:	72 1c       	ld.w	r12,r9[0x4]
800086c0:	50 7c       	stdsp	sp[0x1c],r12
800086c2:	f2 c8 ff f8 	sub	r8,r9,-8
800086c6:	51 08       	stdsp	sp[0x40],r8
800086c8:	72 09       	ld.w	r9,r9[0x0]
800086ca:	50 59       	stdsp	sp[0x14],r9
800086cc:	40 5b       	lddsp	r11,sp[0x14]
800086ce:	40 7a       	lddsp	r10,sp[0x1c]
800086d0:	e0 a0 19 54 	rcall	8000b978 <__isinfd>
800086d4:	18 96       	mov	r6,r12
800086d6:	c1 70       	breq	80008704 <_vfprintf_r+0x8c0>
800086d8:	30 08       	mov	r8,0
800086da:	30 09       	mov	r9,0
800086dc:	40 5b       	lddsp	r11,sp[0x14]
800086de:	40 7a       	lddsp	r10,sp[0x1c]
800086e0:	e0 a0 1d b4 	rcall	8000c248 <__avr32_f64_cmp_lt>
800086e4:	c0 40       	breq	800086ec <_vfprintf_r+0x8a8>
800086e6:	32 d8       	mov	r8,45
800086e8:	fb 68 06 bb 	st.b	sp[1723],r8
800086ec:	fe c8 a9 98 	sub	r8,pc,-22120
800086f0:	fe c6 a9 98 	sub	r6,pc,-22120
800086f4:	a7 d5       	cbr	r5,0x7
800086f6:	e0 40 00 47 	cp.w	r0,71
800086fa:	f0 06 17 a0 	movle	r6,r8
800086fe:	30 32       	mov	r2,3
80008700:	e0 8f 06 ce 	bral	8000949c <_vfprintf_r+0x1658>
80008704:	40 5b       	lddsp	r11,sp[0x14]
80008706:	40 7a       	lddsp	r10,sp[0x1c]
80008708:	e0 a0 19 4d 	rcall	8000b9a2 <__isnand>
8000870c:	c0 e0       	breq	80008728 <_vfprintf_r+0x8e4>
8000870e:	50 26       	stdsp	sp[0x8],r6
80008710:	fe c8 a9 b4 	sub	r8,pc,-22092
80008714:	fe c6 a9 b4 	sub	r6,pc,-22092
80008718:	a7 d5       	cbr	r5,0x7
8000871a:	e0 40 00 47 	cp.w	r0,71
8000871e:	f0 06 17 a0 	movle	r6,r8
80008722:	30 32       	mov	r2,3
80008724:	e0 8f 06 c2 	bral	800094a8 <_vfprintf_r+0x1664>
80008728:	40 2a       	lddsp	r10,sp[0x8]
8000872a:	5b fa       	cp.w	r10,-1
8000872c:	c0 41       	brne	80008734 <_vfprintf_r+0x8f0>
8000872e:	30 69       	mov	r9,6
80008730:	50 29       	stdsp	sp[0x8],r9
80008732:	c1 18       	rjmp	80008754 <_vfprintf_r+0x910>
80008734:	e0 40 00 47 	cp.w	r0,71
80008738:	5f 09       	sreq	r9
8000873a:	e0 40 00 67 	cp.w	r0,103
8000873e:	5f 08       	sreq	r8
80008740:	f3 e8 10 08 	or	r8,r9,r8
80008744:	f8 08 18 00 	cp.b	r8,r12
80008748:	c0 60       	breq	80008754 <_vfprintf_r+0x910>
8000874a:	40 28       	lddsp	r8,sp[0x8]
8000874c:	58 08       	cp.w	r8,0
8000874e:	f9 b8 00 01 	moveq	r8,1
80008752:	50 28       	stdsp	sp[0x8],r8
80008754:	40 78       	lddsp	r8,sp[0x1c]
80008756:	40 59       	lddsp	r9,sp[0x14]
80008758:	fa e9 06 94 	st.d	sp[1684],r8
8000875c:	a9 a5       	sbr	r5,0x8
8000875e:	fa f8 06 94 	ld.w	r8,sp[1684]
80008762:	58 08       	cp.w	r8,0
80008764:	c0 65       	brlt	80008770 <_vfprintf_r+0x92c>
80008766:	40 5e       	lddsp	lr,sp[0x14]
80008768:	30 0c       	mov	r12,0
8000876a:	50 6e       	stdsp	sp[0x18],lr
8000876c:	50 9c       	stdsp	sp[0x24],r12
8000876e:	c0 78       	rjmp	8000877c <_vfprintf_r+0x938>
80008770:	40 5b       	lddsp	r11,sp[0x14]
80008772:	32 da       	mov	r10,45
80008774:	ee 1b 80 00 	eorh	r11,0x8000
80008778:	50 9a       	stdsp	sp[0x24],r10
8000877a:	50 6b       	stdsp	sp[0x18],r11
8000877c:	e0 40 00 46 	cp.w	r0,70
80008780:	5f 09       	sreq	r9
80008782:	e0 40 00 66 	cp.w	r0,102
80008786:	5f 08       	sreq	r8
80008788:	f3 e8 10 08 	or	r8,r9,r8
8000878c:	50 48       	stdsp	sp[0x10],r8
8000878e:	c0 40       	breq	80008796 <_vfprintf_r+0x952>
80008790:	40 22       	lddsp	r2,sp[0x8]
80008792:	30 39       	mov	r9,3
80008794:	c1 08       	rjmp	800087b4 <_vfprintf_r+0x970>
80008796:	e0 40 00 45 	cp.w	r0,69
8000879a:	5f 09       	sreq	r9
8000879c:	e0 40 00 65 	cp.w	r0,101
800087a0:	5f 08       	sreq	r8
800087a2:	40 22       	lddsp	r2,sp[0x8]
800087a4:	10 49       	or	r9,r8
800087a6:	2f f2       	sub	r2,-1
800087a8:	40 46       	lddsp	r6,sp[0x10]
800087aa:	ec 09 18 00 	cp.b	r9,r6
800087ae:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800087b2:	30 29       	mov	r9,2
800087b4:	fa c8 f9 5c 	sub	r8,sp,-1700
800087b8:	1a d8       	st.w	--sp,r8
800087ba:	fa c8 f9 54 	sub	r8,sp,-1708
800087be:	1a d8       	st.w	--sp,r8
800087c0:	fa c8 f9 4c 	sub	r8,sp,-1716
800087c4:	08 9c       	mov	r12,r4
800087c6:	1a d8       	st.w	--sp,r8
800087c8:	04 98       	mov	r8,r2
800087ca:	40 9b       	lddsp	r11,sp[0x24]
800087cc:	40 aa       	lddsp	r10,sp[0x28]
800087ce:	e0 a0 0b c3 	rcall	80009f54 <_dtoa_r>
800087d2:	e0 40 00 47 	cp.w	r0,71
800087d6:	5f 19       	srne	r9
800087d8:	e0 40 00 67 	cp.w	r0,103
800087dc:	5f 18       	srne	r8
800087de:	18 96       	mov	r6,r12
800087e0:	2f dd       	sub	sp,-12
800087e2:	f3 e8 00 08 	and	r8,r9,r8
800087e6:	c0 41       	brne	800087ee <_vfprintf_r+0x9aa>
800087e8:	ed b5 00 00 	bld	r5,0x0
800087ec:	c3 01       	brne	8000884c <_vfprintf_r+0xa08>
800087ee:	ec 02 00 0e 	add	lr,r6,r2
800087f2:	50 3e       	stdsp	sp[0xc],lr
800087f4:	40 4c       	lddsp	r12,sp[0x10]
800087f6:	58 0c       	cp.w	r12,0
800087f8:	c1 50       	breq	80008822 <_vfprintf_r+0x9de>
800087fa:	0d 89       	ld.ub	r9,r6[0x0]
800087fc:	33 08       	mov	r8,48
800087fe:	f0 09 18 00 	cp.b	r9,r8
80008802:	c0 b1       	brne	80008818 <_vfprintf_r+0x9d4>
80008804:	30 08       	mov	r8,0
80008806:	30 09       	mov	r9,0
80008808:	40 6b       	lddsp	r11,sp[0x18]
8000880a:	40 7a       	lddsp	r10,sp[0x1c]
8000880c:	e0 a0 1c d7 	rcall	8000c1ba <__avr32_f64_cmp_eq>
80008810:	fb b2 00 01 	rsubeq	r2,1
80008814:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008818:	40 3b       	lddsp	r11,sp[0xc]
8000881a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000881e:	10 0b       	add	r11,r8
80008820:	50 3b       	stdsp	sp[0xc],r11
80008822:	40 6b       	lddsp	r11,sp[0x18]
80008824:	30 08       	mov	r8,0
80008826:	30 09       	mov	r9,0
80008828:	40 7a       	lddsp	r10,sp[0x1c]
8000882a:	e0 a0 1c c8 	rcall	8000c1ba <__avr32_f64_cmp_eq>
8000882e:	c0 90       	breq	80008840 <_vfprintf_r+0x9fc>
80008830:	40 3a       	lddsp	r10,sp[0xc]
80008832:	fb 4a 06 a4 	st.w	sp[1700],r10
80008836:	c0 58       	rjmp	80008840 <_vfprintf_r+0x9fc>
80008838:	10 c9       	st.b	r8++,r9
8000883a:	fb 48 06 a4 	st.w	sp[1700],r8
8000883e:	c0 28       	rjmp	80008842 <_vfprintf_r+0x9fe>
80008840:	33 09       	mov	r9,48
80008842:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008846:	40 3e       	lddsp	lr,sp[0xc]
80008848:	1c 38       	cp.w	r8,lr
8000884a:	cf 73       	brcs	80008838 <_vfprintf_r+0x9f4>
8000884c:	e0 40 00 47 	cp.w	r0,71
80008850:	5f 09       	sreq	r9
80008852:	e0 40 00 67 	cp.w	r0,103
80008856:	5f 08       	sreq	r8
80008858:	f3 e8 10 08 	or	r8,r9,r8
8000885c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008860:	0c 19       	sub	r9,r6
80008862:	50 69       	stdsp	sp[0x18],r9
80008864:	58 08       	cp.w	r8,0
80008866:	c0 b0       	breq	8000887c <_vfprintf_r+0xa38>
80008868:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000886c:	5b d8       	cp.w	r8,-3
8000886e:	c0 55       	brlt	80008878 <_vfprintf_r+0xa34>
80008870:	40 2c       	lddsp	r12,sp[0x8]
80008872:	18 38       	cp.w	r8,r12
80008874:	e0 8a 00 6a 	brle	80008948 <_vfprintf_r+0xb04>
80008878:	20 20       	sub	r0,2
8000887a:	c0 58       	rjmp	80008884 <_vfprintf_r+0xa40>
8000887c:	e0 40 00 65 	cp.w	r0,101
80008880:	e0 89 00 46 	brgt	8000890c <_vfprintf_r+0xac8>
80008884:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008888:	fb 60 06 9c 	st.b	sp[1692],r0
8000888c:	20 1b       	sub	r11,1
8000888e:	fb 4b 06 ac 	st.w	sp[1708],r11
80008892:	c0 47       	brpl	8000889a <_vfprintf_r+0xa56>
80008894:	5c 3b       	neg	r11
80008896:	32 d8       	mov	r8,45
80008898:	c0 28       	rjmp	8000889c <_vfprintf_r+0xa58>
8000889a:	32 b8       	mov	r8,43
8000889c:	fb 68 06 9d 	st.b	sp[1693],r8
800088a0:	58 9b       	cp.w	r11,9
800088a2:	e0 8a 00 1d 	brle	800088dc <_vfprintf_r+0xa98>
800088a6:	fa c9 fa 35 	sub	r9,sp,-1483
800088aa:	30 aa       	mov	r10,10
800088ac:	12 98       	mov	r8,r9
800088ae:	0e 9c       	mov	r12,r7
800088b0:	0c 92       	mov	r2,r6
800088b2:	f6 0a 0c 06 	divs	r6,r11,r10
800088b6:	0e 9b       	mov	r11,r7
800088b8:	2d 0b       	sub	r11,-48
800088ba:	10 fb       	st.b	--r8,r11
800088bc:	0c 9b       	mov	r11,r6
800088be:	58 96       	cp.w	r6,9
800088c0:	fe 99 ff f9 	brgt	800088b2 <_vfprintf_r+0xa6e>
800088c4:	2d 0b       	sub	r11,-48
800088c6:	18 97       	mov	r7,r12
800088c8:	04 96       	mov	r6,r2
800088ca:	10 fb       	st.b	--r8,r11
800088cc:	fa ca f9 62 	sub	r10,sp,-1694
800088d0:	c0 38       	rjmp	800088d6 <_vfprintf_r+0xa92>
800088d2:	11 3b       	ld.ub	r11,r8++
800088d4:	14 cb       	st.b	r10++,r11
800088d6:	12 38       	cp.w	r8,r9
800088d8:	cf d3       	brcs	800088d2 <_vfprintf_r+0xa8e>
800088da:	c0 98       	rjmp	800088ec <_vfprintf_r+0xaa8>
800088dc:	2d 0b       	sub	r11,-48
800088de:	33 08       	mov	r8,48
800088e0:	fb 6b 06 9f 	st.b	sp[1695],r11
800088e4:	fb 68 06 9e 	st.b	sp[1694],r8
800088e8:	fa ca f9 60 	sub	r10,sp,-1696
800088ec:	fa c8 f9 64 	sub	r8,sp,-1692
800088f0:	f4 08 01 08 	sub	r8,r10,r8
800088f4:	50 e8       	stdsp	sp[0x38],r8
800088f6:	10 92       	mov	r2,r8
800088f8:	40 6b       	lddsp	r11,sp[0x18]
800088fa:	16 02       	add	r2,r11
800088fc:	58 1b       	cp.w	r11,1
800088fe:	e0 89 00 05 	brgt	80008908 <_vfprintf_r+0xac4>
80008902:	ed b5 00 00 	bld	r5,0x0
80008906:	c3 51       	brne	80008970 <_vfprintf_r+0xb2c>
80008908:	2f f2       	sub	r2,-1
8000890a:	c3 38       	rjmp	80008970 <_vfprintf_r+0xb2c>
8000890c:	e0 40 00 66 	cp.w	r0,102
80008910:	c1 c1       	brne	80008948 <_vfprintf_r+0xb04>
80008912:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008916:	58 02       	cp.w	r2,0
80008918:	e0 8a 00 0c 	brle	80008930 <_vfprintf_r+0xaec>
8000891c:	40 2a       	lddsp	r10,sp[0x8]
8000891e:	58 0a       	cp.w	r10,0
80008920:	c0 41       	brne	80008928 <_vfprintf_r+0xae4>
80008922:	ed b5 00 00 	bld	r5,0x0
80008926:	c2 51       	brne	80008970 <_vfprintf_r+0xb2c>
80008928:	2f f2       	sub	r2,-1
8000892a:	40 29       	lddsp	r9,sp[0x8]
8000892c:	12 02       	add	r2,r9
8000892e:	c0 b8       	rjmp	80008944 <_vfprintf_r+0xb00>
80008930:	40 28       	lddsp	r8,sp[0x8]
80008932:	58 08       	cp.w	r8,0
80008934:	c0 61       	brne	80008940 <_vfprintf_r+0xafc>
80008936:	ed b5 00 00 	bld	r5,0x0
8000893a:	c0 30       	breq	80008940 <_vfprintf_r+0xafc>
8000893c:	30 12       	mov	r2,1
8000893e:	c1 98       	rjmp	80008970 <_vfprintf_r+0xb2c>
80008940:	40 22       	lddsp	r2,sp[0x8]
80008942:	2f e2       	sub	r2,-2
80008944:	36 60       	mov	r0,102
80008946:	c1 58       	rjmp	80008970 <_vfprintf_r+0xb2c>
80008948:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000894c:	40 6e       	lddsp	lr,sp[0x18]
8000894e:	1c 32       	cp.w	r2,lr
80008950:	c0 65       	brlt	8000895c <_vfprintf_r+0xb18>
80008952:	ed b5 00 00 	bld	r5,0x0
80008956:	f7 b2 00 ff 	subeq	r2,-1
8000895a:	c0 a8       	rjmp	8000896e <_vfprintf_r+0xb2a>
8000895c:	e4 08 11 02 	rsub	r8,r2,2
80008960:	40 6c       	lddsp	r12,sp[0x18]
80008962:	58 02       	cp.w	r2,0
80008964:	f0 02 17 a0 	movle	r2,r8
80008968:	f9 b2 09 01 	movgt	r2,1
8000896c:	18 02       	add	r2,r12
8000896e:	36 70       	mov	r0,103
80008970:	40 9b       	lddsp	r11,sp[0x24]
80008972:	58 0b       	cp.w	r11,0
80008974:	e0 80 05 94 	breq	8000949c <_vfprintf_r+0x1658>
80008978:	32 d8       	mov	r8,45
8000897a:	fb 68 06 bb 	st.b	sp[1723],r8
8000897e:	e0 8f 05 93 	bral	800094a4 <_vfprintf_r+0x1660>
80008982:	50 a7       	stdsp	sp[0x28],r7
80008984:	04 94       	mov	r4,r2
80008986:	0c 97       	mov	r7,r6
80008988:	02 92       	mov	r2,r1
8000898a:	06 96       	mov	r6,r3
8000898c:	40 41       	lddsp	r1,sp[0x10]
8000898e:	40 93       	lddsp	r3,sp[0x24]
80008990:	0e 99       	mov	r9,r7
80008992:	ed b5 00 05 	bld	r5,0x5
80008996:	c4 81       	brne	80008a26 <_vfprintf_r+0xbe2>
80008998:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000899c:	40 3e       	lddsp	lr,sp[0xc]
8000899e:	58 0e       	cp.w	lr,0
800089a0:	c1 d0       	breq	800089da <_vfprintf_r+0xb96>
800089a2:	10 36       	cp.w	r6,r8
800089a4:	c0 64       	brge	800089b0 <_vfprintf_r+0xb6c>
800089a6:	fa cc f9 44 	sub	r12,sp,-1724
800089aa:	f8 06 00 36 	add	r6,r12,r6<<0x3
800089ae:	c1 d8       	rjmp	800089e8 <_vfprintf_r+0xba4>
800089b0:	fa c8 f9 50 	sub	r8,sp,-1712
800089b4:	1a d8       	st.w	--sp,r8
800089b6:	fa c8 fa b8 	sub	r8,sp,-1352
800089ba:	04 9a       	mov	r10,r2
800089bc:	1a d8       	st.w	--sp,r8
800089be:	fa c8 fb b4 	sub	r8,sp,-1100
800089c2:	0c 9b       	mov	r11,r6
800089c4:	1a d8       	st.w	--sp,r8
800089c6:	08 9c       	mov	r12,r4
800089c8:	fa c8 f9 40 	sub	r8,sp,-1728
800089cc:	fa c9 ff b4 	sub	r9,sp,-76
800089d0:	fe b0 f8 a2 	rcall	80007b14 <get_arg>
800089d4:	2f dd       	sub	sp,-12
800089d6:	78 0a       	ld.w	r10,r12[0x0]
800089d8:	c2 08       	rjmp	80008a18 <_vfprintf_r+0xbd4>
800089da:	2f f7       	sub	r7,-1
800089dc:	10 39       	cp.w	r9,r8
800089de:	c0 84       	brge	800089ee <_vfprintf_r+0xbaa>
800089e0:	fa cb f9 44 	sub	r11,sp,-1724
800089e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089e8:	ec fa fd 88 	ld.w	r10,r6[-632]
800089ec:	c1 68       	rjmp	80008a18 <_vfprintf_r+0xbd4>
800089ee:	41 09       	lddsp	r9,sp[0x40]
800089f0:	59 f8       	cp.w	r8,31
800089f2:	e0 89 00 10 	brgt	80008a12 <_vfprintf_r+0xbce>
800089f6:	f2 ca ff fc 	sub	r10,r9,-4
800089fa:	51 0a       	stdsp	sp[0x40],r10
800089fc:	fa c6 f9 44 	sub	r6,sp,-1724
80008a00:	72 0a       	ld.w	r10,r9[0x0]
80008a02:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a06:	f3 4a fd 88 	st.w	r9[-632],r10
80008a0a:	2f f8       	sub	r8,-1
80008a0c:	fb 48 06 b4 	st.w	sp[1716],r8
80008a10:	c0 48       	rjmp	80008a18 <_vfprintf_r+0xbd4>
80008a12:	72 0a       	ld.w	r10,r9[0x0]
80008a14:	2f c9       	sub	r9,-4
80008a16:	51 09       	stdsp	sp[0x40],r9
80008a18:	40 be       	lddsp	lr,sp[0x2c]
80008a1a:	1c 98       	mov	r8,lr
80008a1c:	95 1e       	st.w	r10[0x4],lr
80008a1e:	bf 58       	asr	r8,0x1f
80008a20:	95 08       	st.w	r10[0x0],r8
80008a22:	fe 9f fa 9f 	bral	80007f60 <_vfprintf_r+0x11c>
80008a26:	ed b5 00 04 	bld	r5,0x4
80008a2a:	c4 80       	breq	80008aba <_vfprintf_r+0xc76>
80008a2c:	e2 15 00 40 	andl	r5,0x40,COH
80008a30:	c4 50       	breq	80008aba <_vfprintf_r+0xc76>
80008a32:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a36:	40 3c       	lddsp	r12,sp[0xc]
80008a38:	58 0c       	cp.w	r12,0
80008a3a:	c1 d0       	breq	80008a74 <_vfprintf_r+0xc30>
80008a3c:	10 36       	cp.w	r6,r8
80008a3e:	c0 64       	brge	80008a4a <_vfprintf_r+0xc06>
80008a40:	fa cb f9 44 	sub	r11,sp,-1724
80008a44:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a48:	c1 d8       	rjmp	80008a82 <_vfprintf_r+0xc3e>
80008a4a:	fa c8 f9 50 	sub	r8,sp,-1712
80008a4e:	1a d8       	st.w	--sp,r8
80008a50:	fa c8 fa b8 	sub	r8,sp,-1352
80008a54:	04 9a       	mov	r10,r2
80008a56:	1a d8       	st.w	--sp,r8
80008a58:	fa c8 fb b4 	sub	r8,sp,-1100
80008a5c:	0c 9b       	mov	r11,r6
80008a5e:	1a d8       	st.w	--sp,r8
80008a60:	08 9c       	mov	r12,r4
80008a62:	fa c8 f9 40 	sub	r8,sp,-1728
80008a66:	fa c9 ff b4 	sub	r9,sp,-76
80008a6a:	fe b0 f8 55 	rcall	80007b14 <get_arg>
80008a6e:	2f dd       	sub	sp,-12
80008a70:	78 0a       	ld.w	r10,r12[0x0]
80008a72:	c2 08       	rjmp	80008ab2 <_vfprintf_r+0xc6e>
80008a74:	2f f7       	sub	r7,-1
80008a76:	10 39       	cp.w	r9,r8
80008a78:	c0 84       	brge	80008a88 <_vfprintf_r+0xc44>
80008a7a:	fa ca f9 44 	sub	r10,sp,-1724
80008a7e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008a82:	ec fa fd 88 	ld.w	r10,r6[-632]
80008a86:	c1 68       	rjmp	80008ab2 <_vfprintf_r+0xc6e>
80008a88:	41 09       	lddsp	r9,sp[0x40]
80008a8a:	59 f8       	cp.w	r8,31
80008a8c:	e0 89 00 10 	brgt	80008aac <_vfprintf_r+0xc68>
80008a90:	f2 ca ff fc 	sub	r10,r9,-4
80008a94:	51 0a       	stdsp	sp[0x40],r10
80008a96:	fa c6 f9 44 	sub	r6,sp,-1724
80008a9a:	72 0a       	ld.w	r10,r9[0x0]
80008a9c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008aa0:	f3 4a fd 88 	st.w	r9[-632],r10
80008aa4:	2f f8       	sub	r8,-1
80008aa6:	fb 48 06 b4 	st.w	sp[1716],r8
80008aaa:	c0 48       	rjmp	80008ab2 <_vfprintf_r+0xc6e>
80008aac:	72 0a       	ld.w	r10,r9[0x0]
80008aae:	2f c9       	sub	r9,-4
80008ab0:	51 09       	stdsp	sp[0x40],r9
80008ab2:	40 be       	lddsp	lr,sp[0x2c]
80008ab4:	b4 0e       	st.h	r10[0x0],lr
80008ab6:	fe 9f fa 55 	bral	80007f60 <_vfprintf_r+0x11c>
80008aba:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008abe:	40 3c       	lddsp	r12,sp[0xc]
80008ac0:	58 0c       	cp.w	r12,0
80008ac2:	c1 d0       	breq	80008afc <_vfprintf_r+0xcb8>
80008ac4:	10 36       	cp.w	r6,r8
80008ac6:	c0 64       	brge	80008ad2 <_vfprintf_r+0xc8e>
80008ac8:	fa cb f9 44 	sub	r11,sp,-1724
80008acc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ad0:	c1 d8       	rjmp	80008b0a <_vfprintf_r+0xcc6>
80008ad2:	fa c8 f9 50 	sub	r8,sp,-1712
80008ad6:	1a d8       	st.w	--sp,r8
80008ad8:	fa c8 fa b8 	sub	r8,sp,-1352
80008adc:	04 9a       	mov	r10,r2
80008ade:	1a d8       	st.w	--sp,r8
80008ae0:	fa c8 fb b4 	sub	r8,sp,-1100
80008ae4:	0c 9b       	mov	r11,r6
80008ae6:	1a d8       	st.w	--sp,r8
80008ae8:	08 9c       	mov	r12,r4
80008aea:	fa c8 f9 40 	sub	r8,sp,-1728
80008aee:	fa c9 ff b4 	sub	r9,sp,-76
80008af2:	fe b0 f8 11 	rcall	80007b14 <get_arg>
80008af6:	2f dd       	sub	sp,-12
80008af8:	78 0a       	ld.w	r10,r12[0x0]
80008afa:	c2 08       	rjmp	80008b3a <_vfprintf_r+0xcf6>
80008afc:	2f f7       	sub	r7,-1
80008afe:	10 39       	cp.w	r9,r8
80008b00:	c0 84       	brge	80008b10 <_vfprintf_r+0xccc>
80008b02:	fa ca f9 44 	sub	r10,sp,-1724
80008b06:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b0a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b0e:	c1 68       	rjmp	80008b3a <_vfprintf_r+0xcf6>
80008b10:	41 09       	lddsp	r9,sp[0x40]
80008b12:	59 f8       	cp.w	r8,31
80008b14:	e0 89 00 10 	brgt	80008b34 <_vfprintf_r+0xcf0>
80008b18:	f2 ca ff fc 	sub	r10,r9,-4
80008b1c:	51 0a       	stdsp	sp[0x40],r10
80008b1e:	fa c6 f9 44 	sub	r6,sp,-1724
80008b22:	72 0a       	ld.w	r10,r9[0x0]
80008b24:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b28:	f3 4a fd 88 	st.w	r9[-632],r10
80008b2c:	2f f8       	sub	r8,-1
80008b2e:	fb 48 06 b4 	st.w	sp[1716],r8
80008b32:	c0 48       	rjmp	80008b3a <_vfprintf_r+0xcf6>
80008b34:	72 0a       	ld.w	r10,r9[0x0]
80008b36:	2f c9       	sub	r9,-4
80008b38:	51 09       	stdsp	sp[0x40],r9
80008b3a:	40 be       	lddsp	lr,sp[0x2c]
80008b3c:	95 0e       	st.w	r10[0x0],lr
80008b3e:	fe 9f fa 11 	bral	80007f60 <_vfprintf_r+0x11c>
80008b42:	50 a7       	stdsp	sp[0x28],r7
80008b44:	50 80       	stdsp	sp[0x20],r0
80008b46:	0c 97       	mov	r7,r6
80008b48:	04 94       	mov	r4,r2
80008b4a:	06 96       	mov	r6,r3
80008b4c:	02 92       	mov	r2,r1
80008b4e:	40 93       	lddsp	r3,sp[0x24]
80008b50:	10 90       	mov	r0,r8
80008b52:	40 41       	lddsp	r1,sp[0x10]
80008b54:	a5 a5       	sbr	r5,0x4
80008b56:	c0 a8       	rjmp	80008b6a <_vfprintf_r+0xd26>
80008b58:	50 a7       	stdsp	sp[0x28],r7
80008b5a:	50 80       	stdsp	sp[0x20],r0
80008b5c:	0c 97       	mov	r7,r6
80008b5e:	04 94       	mov	r4,r2
80008b60:	06 96       	mov	r6,r3
80008b62:	02 92       	mov	r2,r1
80008b64:	40 93       	lddsp	r3,sp[0x24]
80008b66:	10 90       	mov	r0,r8
80008b68:	40 41       	lddsp	r1,sp[0x10]
80008b6a:	ed b5 00 05 	bld	r5,0x5
80008b6e:	c5 d1       	brne	80008c28 <_vfprintf_r+0xde4>
80008b70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b74:	40 3c       	lddsp	r12,sp[0xc]
80008b76:	58 0c       	cp.w	r12,0
80008b78:	c2 60       	breq	80008bc4 <_vfprintf_r+0xd80>
80008b7a:	10 36       	cp.w	r6,r8
80008b7c:	c0 a4       	brge	80008b90 <_vfprintf_r+0xd4c>
80008b7e:	fa cb f9 44 	sub	r11,sp,-1724
80008b82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b86:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008b8a:	fa e9 00 00 	st.d	sp[0],r8
80008b8e:	c1 88       	rjmp	80008bbe <_vfprintf_r+0xd7a>
80008b90:	fa c8 f9 50 	sub	r8,sp,-1712
80008b94:	1a d8       	st.w	--sp,r8
80008b96:	fa c8 fa b8 	sub	r8,sp,-1352
80008b9a:	04 9a       	mov	r10,r2
80008b9c:	1a d8       	st.w	--sp,r8
80008b9e:	0c 9b       	mov	r11,r6
80008ba0:	fa c8 fb b4 	sub	r8,sp,-1100
80008ba4:	08 9c       	mov	r12,r4
80008ba6:	1a d8       	st.w	--sp,r8
80008ba8:	fa c8 f9 40 	sub	r8,sp,-1728
80008bac:	fa c9 ff b4 	sub	r9,sp,-76
80008bb0:	fe b0 f7 b2 	rcall	80007b14 <get_arg>
80008bb4:	2f dd       	sub	sp,-12
80008bb6:	f8 ea 00 00 	ld.d	r10,r12[0]
80008bba:	fa eb 00 00 	st.d	sp[0],r10
80008bbe:	30 08       	mov	r8,0
80008bc0:	e0 8f 03 de 	bral	8000937c <_vfprintf_r+0x1538>
80008bc4:	ee ca ff ff 	sub	r10,r7,-1
80008bc8:	10 37       	cp.w	r7,r8
80008bca:	c0 b4       	brge	80008be0 <_vfprintf_r+0xd9c>
80008bcc:	fa c9 f9 44 	sub	r9,sp,-1724
80008bd0:	14 97       	mov	r7,r10
80008bd2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008bd6:	ec ea fd 88 	ld.d	r10,r6[-632]
80008bda:	fa eb 00 00 	st.d	sp[0],r10
80008bde:	c1 88       	rjmp	80008c0e <_vfprintf_r+0xdca>
80008be0:	41 09       	lddsp	r9,sp[0x40]
80008be2:	59 f8       	cp.w	r8,31
80008be4:	e0 89 00 18 	brgt	80008c14 <_vfprintf_r+0xdd0>
80008be8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008bec:	f2 cb ff f8 	sub	r11,r9,-8
80008bf0:	fa e7 00 00 	st.d	sp[0],r6
80008bf4:	51 0b       	stdsp	sp[0x40],r11
80008bf6:	fa c6 f9 44 	sub	r6,sp,-1724
80008bfa:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008bfe:	fa e6 00 00 	ld.d	r6,sp[0]
80008c02:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c06:	2f f8       	sub	r8,-1
80008c08:	14 97       	mov	r7,r10
80008c0a:	fb 48 06 b4 	st.w	sp[1716],r8
80008c0e:	40 38       	lddsp	r8,sp[0xc]
80008c10:	e0 8f 03 b6 	bral	8000937c <_vfprintf_r+0x1538>
80008c14:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c18:	40 38       	lddsp	r8,sp[0xc]
80008c1a:	fa e7 00 00 	st.d	sp[0],r6
80008c1e:	2f 89       	sub	r9,-8
80008c20:	14 97       	mov	r7,r10
80008c22:	51 09       	stdsp	sp[0x40],r9
80008c24:	e0 8f 03 ac 	bral	8000937c <_vfprintf_r+0x1538>
80008c28:	ed b5 00 04 	bld	r5,0x4
80008c2c:	c1 61       	brne	80008c58 <_vfprintf_r+0xe14>
80008c2e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c32:	40 3e       	lddsp	lr,sp[0xc]
80008c34:	58 0e       	cp.w	lr,0
80008c36:	c0 80       	breq	80008c46 <_vfprintf_r+0xe02>
80008c38:	10 36       	cp.w	r6,r8
80008c3a:	c6 74       	brge	80008d08 <_vfprintf_r+0xec4>
80008c3c:	fa cc f9 44 	sub	r12,sp,-1724
80008c40:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c44:	c8 08       	rjmp	80008d44 <_vfprintf_r+0xf00>
80008c46:	ee ca ff ff 	sub	r10,r7,-1
80008c4a:	10 37       	cp.w	r7,r8
80008c4c:	c7 f4       	brge	80008d4a <_vfprintf_r+0xf06>
80008c4e:	fa cb f9 44 	sub	r11,sp,-1724
80008c52:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c56:	c7 68       	rjmp	80008d42 <_vfprintf_r+0xefe>
80008c58:	ed b5 00 06 	bld	r5,0x6
80008c5c:	c4 a1       	brne	80008cf0 <_vfprintf_r+0xeac>
80008c5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c62:	40 3c       	lddsp	r12,sp[0xc]
80008c64:	58 0c       	cp.w	r12,0
80008c66:	c1 d0       	breq	80008ca0 <_vfprintf_r+0xe5c>
80008c68:	10 36       	cp.w	r6,r8
80008c6a:	c0 64       	brge	80008c76 <_vfprintf_r+0xe32>
80008c6c:	fa cb f9 44 	sub	r11,sp,-1724
80008c70:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c74:	c1 f8       	rjmp	80008cb2 <_vfprintf_r+0xe6e>
80008c76:	fa c8 f9 50 	sub	r8,sp,-1712
80008c7a:	1a d8       	st.w	--sp,r8
80008c7c:	fa c8 fa b8 	sub	r8,sp,-1352
80008c80:	1a d8       	st.w	--sp,r8
80008c82:	fa c8 fb b4 	sub	r8,sp,-1100
80008c86:	1a d8       	st.w	--sp,r8
80008c88:	fa c8 f9 40 	sub	r8,sp,-1728
80008c8c:	fa c9 ff b4 	sub	r9,sp,-76
80008c90:	04 9a       	mov	r10,r2
80008c92:	0c 9b       	mov	r11,r6
80008c94:	08 9c       	mov	r12,r4
80008c96:	fe b0 f7 3f 	rcall	80007b14 <get_arg>
80008c9a:	2f dd       	sub	sp,-12
80008c9c:	98 18       	ld.sh	r8,r12[0x2]
80008c9e:	c2 68       	rjmp	80008cea <_vfprintf_r+0xea6>
80008ca0:	ee ca ff ff 	sub	r10,r7,-1
80008ca4:	10 37       	cp.w	r7,r8
80008ca6:	c0 94       	brge	80008cb8 <_vfprintf_r+0xe74>
80008ca8:	fa c9 f9 44 	sub	r9,sp,-1724
80008cac:	14 97       	mov	r7,r10
80008cae:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008cb2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008cb6:	c1 a8       	rjmp	80008cea <_vfprintf_r+0xea6>
80008cb8:	41 09       	lddsp	r9,sp[0x40]
80008cba:	59 f8       	cp.w	r8,31
80008cbc:	e0 89 00 13 	brgt	80008ce2 <_vfprintf_r+0xe9e>
80008cc0:	f2 cb ff fc 	sub	r11,r9,-4
80008cc4:	51 0b       	stdsp	sp[0x40],r11
80008cc6:	72 09       	ld.w	r9,r9[0x0]
80008cc8:	fa c6 f9 44 	sub	r6,sp,-1724
80008ccc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008cd0:	2f f8       	sub	r8,-1
80008cd2:	f7 49 fd 88 	st.w	r11[-632],r9
80008cd6:	fb 48 06 b4 	st.w	sp[1716],r8
80008cda:	14 97       	mov	r7,r10
80008cdc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008ce0:	c0 58       	rjmp	80008cea <_vfprintf_r+0xea6>
80008ce2:	92 18       	ld.sh	r8,r9[0x2]
80008ce4:	14 97       	mov	r7,r10
80008ce6:	2f c9       	sub	r9,-4
80008ce8:	51 09       	stdsp	sp[0x40],r9
80008cea:	5c 78       	castu.h	r8
80008cec:	50 18       	stdsp	sp[0x4],r8
80008cee:	c4 68       	rjmp	80008d7a <_vfprintf_r+0xf36>
80008cf0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cf4:	40 3c       	lddsp	r12,sp[0xc]
80008cf6:	58 0c       	cp.w	r12,0
80008cf8:	c1 d0       	breq	80008d32 <_vfprintf_r+0xeee>
80008cfa:	10 36       	cp.w	r6,r8
80008cfc:	c0 64       	brge	80008d08 <_vfprintf_r+0xec4>
80008cfe:	fa cb f9 44 	sub	r11,sp,-1724
80008d02:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d06:	c1 f8       	rjmp	80008d44 <_vfprintf_r+0xf00>
80008d08:	fa c8 f9 50 	sub	r8,sp,-1712
80008d0c:	1a d8       	st.w	--sp,r8
80008d0e:	fa c8 fa b8 	sub	r8,sp,-1352
80008d12:	0c 9b       	mov	r11,r6
80008d14:	1a d8       	st.w	--sp,r8
80008d16:	fa c8 fb b4 	sub	r8,sp,-1100
80008d1a:	04 9a       	mov	r10,r2
80008d1c:	1a d8       	st.w	--sp,r8
80008d1e:	08 9c       	mov	r12,r4
80008d20:	fa c8 f9 40 	sub	r8,sp,-1728
80008d24:	fa c9 ff b4 	sub	r9,sp,-76
80008d28:	fe b0 f6 f6 	rcall	80007b14 <get_arg>
80008d2c:	2f dd       	sub	sp,-12
80008d2e:	78 0b       	ld.w	r11,r12[0x0]
80008d30:	c2 48       	rjmp	80008d78 <_vfprintf_r+0xf34>
80008d32:	ee ca ff ff 	sub	r10,r7,-1
80008d36:	10 37       	cp.w	r7,r8
80008d38:	c0 94       	brge	80008d4a <_vfprintf_r+0xf06>
80008d3a:	fa c9 f9 44 	sub	r9,sp,-1724
80008d3e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d42:	14 97       	mov	r7,r10
80008d44:	ec fb fd 88 	ld.w	r11,r6[-632]
80008d48:	c1 88       	rjmp	80008d78 <_vfprintf_r+0xf34>
80008d4a:	41 09       	lddsp	r9,sp[0x40]
80008d4c:	59 f8       	cp.w	r8,31
80008d4e:	e0 89 00 11 	brgt	80008d70 <_vfprintf_r+0xf2c>
80008d52:	f2 cb ff fc 	sub	r11,r9,-4
80008d56:	51 0b       	stdsp	sp[0x40],r11
80008d58:	fa c6 f9 44 	sub	r6,sp,-1724
80008d5c:	72 0b       	ld.w	r11,r9[0x0]
80008d5e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d62:	f3 4b fd 88 	st.w	r9[-632],r11
80008d66:	2f f8       	sub	r8,-1
80008d68:	14 97       	mov	r7,r10
80008d6a:	fb 48 06 b4 	st.w	sp[1716],r8
80008d6e:	c0 58       	rjmp	80008d78 <_vfprintf_r+0xf34>
80008d70:	72 0b       	ld.w	r11,r9[0x0]
80008d72:	14 97       	mov	r7,r10
80008d74:	2f c9       	sub	r9,-4
80008d76:	51 09       	stdsp	sp[0x40],r9
80008d78:	50 1b       	stdsp	sp[0x4],r11
80008d7a:	30 0e       	mov	lr,0
80008d7c:	50 0e       	stdsp	sp[0x0],lr
80008d7e:	1c 98       	mov	r8,lr
80008d80:	e0 8f 02 fe 	bral	8000937c <_vfprintf_r+0x1538>
80008d84:	50 a7       	stdsp	sp[0x28],r7
80008d86:	50 80       	stdsp	sp[0x20],r0
80008d88:	0c 97       	mov	r7,r6
80008d8a:	04 94       	mov	r4,r2
80008d8c:	06 96       	mov	r6,r3
80008d8e:	02 92       	mov	r2,r1
80008d90:	40 93       	lddsp	r3,sp[0x24]
80008d92:	40 41       	lddsp	r1,sp[0x10]
80008d94:	0e 99       	mov	r9,r7
80008d96:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d9a:	40 3c       	lddsp	r12,sp[0xc]
80008d9c:	58 0c       	cp.w	r12,0
80008d9e:	c1 d0       	breq	80008dd8 <_vfprintf_r+0xf94>
80008da0:	10 36       	cp.w	r6,r8
80008da2:	c0 64       	brge	80008dae <_vfprintf_r+0xf6a>
80008da4:	fa cb f9 44 	sub	r11,sp,-1724
80008da8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dac:	c1 d8       	rjmp	80008de6 <_vfprintf_r+0xfa2>
80008dae:	fa c8 f9 50 	sub	r8,sp,-1712
80008db2:	1a d8       	st.w	--sp,r8
80008db4:	fa c8 fa b8 	sub	r8,sp,-1352
80008db8:	1a d8       	st.w	--sp,r8
80008dba:	fa c8 fb b4 	sub	r8,sp,-1100
80008dbe:	1a d8       	st.w	--sp,r8
80008dc0:	fa c9 ff b4 	sub	r9,sp,-76
80008dc4:	fa c8 f9 40 	sub	r8,sp,-1728
80008dc8:	04 9a       	mov	r10,r2
80008dca:	0c 9b       	mov	r11,r6
80008dcc:	08 9c       	mov	r12,r4
80008dce:	fe b0 f6 a3 	rcall	80007b14 <get_arg>
80008dd2:	2f dd       	sub	sp,-12
80008dd4:	78 09       	ld.w	r9,r12[0x0]
80008dd6:	c2 18       	rjmp	80008e18 <_vfprintf_r+0xfd4>
80008dd8:	2f f7       	sub	r7,-1
80008dda:	10 39       	cp.w	r9,r8
80008ddc:	c0 84       	brge	80008dec <_vfprintf_r+0xfa8>
80008dde:	fa ca f9 44 	sub	r10,sp,-1724
80008de2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008de6:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008dea:	c1 78       	rjmp	80008e18 <_vfprintf_r+0xfd4>
80008dec:	41 09       	lddsp	r9,sp[0x40]
80008dee:	59 f8       	cp.w	r8,31
80008df0:	e0 89 00 10 	brgt	80008e10 <_vfprintf_r+0xfcc>
80008df4:	f2 ca ff fc 	sub	r10,r9,-4
80008df8:	51 0a       	stdsp	sp[0x40],r10
80008dfa:	fa c6 f9 44 	sub	r6,sp,-1724
80008dfe:	72 09       	ld.w	r9,r9[0x0]
80008e00:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008e04:	f5 49 fd 88 	st.w	r10[-632],r9
80008e08:	2f f8       	sub	r8,-1
80008e0a:	fb 48 06 b4 	st.w	sp[1716],r8
80008e0e:	c0 58       	rjmp	80008e18 <_vfprintf_r+0xfd4>
80008e10:	f2 c8 ff fc 	sub	r8,r9,-4
80008e14:	51 08       	stdsp	sp[0x40],r8
80008e16:	72 09       	ld.w	r9,r9[0x0]
80008e18:	33 08       	mov	r8,48
80008e1a:	fb 68 06 b8 	st.b	sp[1720],r8
80008e1e:	37 88       	mov	r8,120
80008e20:	30 0e       	mov	lr,0
80008e22:	fb 68 06 b9 	st.b	sp[1721],r8
80008e26:	fe cc b0 c2 	sub	r12,pc,-20286
80008e2a:	50 19       	stdsp	sp[0x4],r9
80008e2c:	a1 b5       	sbr	r5,0x1
80008e2e:	50 0e       	stdsp	sp[0x0],lr
80008e30:	50 dc       	stdsp	sp[0x34],r12
80008e32:	30 28       	mov	r8,2
80008e34:	37 80       	mov	r0,120
80008e36:	e0 8f 02 a3 	bral	8000937c <_vfprintf_r+0x1538>
80008e3a:	50 a7       	stdsp	sp[0x28],r7
80008e3c:	50 80       	stdsp	sp[0x20],r0
80008e3e:	10 90       	mov	r0,r8
80008e40:	30 08       	mov	r8,0
80008e42:	fb 68 06 bb 	st.b	sp[1723],r8
80008e46:	0c 97       	mov	r7,r6
80008e48:	04 94       	mov	r4,r2
80008e4a:	06 96       	mov	r6,r3
80008e4c:	02 92       	mov	r2,r1
80008e4e:	40 93       	lddsp	r3,sp[0x24]
80008e50:	40 41       	lddsp	r1,sp[0x10]
80008e52:	0e 99       	mov	r9,r7
80008e54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e58:	40 3b       	lddsp	r11,sp[0xc]
80008e5a:	58 0b       	cp.w	r11,0
80008e5c:	c1 d0       	breq	80008e96 <_vfprintf_r+0x1052>
80008e5e:	10 36       	cp.w	r6,r8
80008e60:	c0 64       	brge	80008e6c <_vfprintf_r+0x1028>
80008e62:	fa ca f9 44 	sub	r10,sp,-1724
80008e66:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e6a:	c1 d8       	rjmp	80008ea4 <_vfprintf_r+0x1060>
80008e6c:	fa c8 f9 50 	sub	r8,sp,-1712
80008e70:	1a d8       	st.w	--sp,r8
80008e72:	fa c8 fa b8 	sub	r8,sp,-1352
80008e76:	1a d8       	st.w	--sp,r8
80008e78:	fa c8 fb b4 	sub	r8,sp,-1100
80008e7c:	0c 9b       	mov	r11,r6
80008e7e:	1a d8       	st.w	--sp,r8
80008e80:	04 9a       	mov	r10,r2
80008e82:	fa c8 f9 40 	sub	r8,sp,-1728
80008e86:	fa c9 ff b4 	sub	r9,sp,-76
80008e8a:	08 9c       	mov	r12,r4
80008e8c:	fe b0 f6 44 	rcall	80007b14 <get_arg>
80008e90:	2f dd       	sub	sp,-12
80008e92:	78 06       	ld.w	r6,r12[0x0]
80008e94:	c2 08       	rjmp	80008ed4 <_vfprintf_r+0x1090>
80008e96:	2f f7       	sub	r7,-1
80008e98:	10 39       	cp.w	r9,r8
80008e9a:	c0 84       	brge	80008eaa <_vfprintf_r+0x1066>
80008e9c:	fa c9 f9 44 	sub	r9,sp,-1724
80008ea0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ea4:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008ea8:	c1 68       	rjmp	80008ed4 <_vfprintf_r+0x1090>
80008eaa:	41 09       	lddsp	r9,sp[0x40]
80008eac:	59 f8       	cp.w	r8,31
80008eae:	e0 89 00 10 	brgt	80008ece <_vfprintf_r+0x108a>
80008eb2:	f2 ca ff fc 	sub	r10,r9,-4
80008eb6:	51 0a       	stdsp	sp[0x40],r10
80008eb8:	72 06       	ld.w	r6,r9[0x0]
80008eba:	fa ce f9 44 	sub	lr,sp,-1724
80008ebe:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008ec2:	f3 46 fd 88 	st.w	r9[-632],r6
80008ec6:	2f f8       	sub	r8,-1
80008ec8:	fb 48 06 b4 	st.w	sp[1716],r8
80008ecc:	c0 48       	rjmp	80008ed4 <_vfprintf_r+0x1090>
80008ece:	72 06       	ld.w	r6,r9[0x0]
80008ed0:	2f c9       	sub	r9,-4
80008ed2:	51 09       	stdsp	sp[0x40],r9
80008ed4:	40 2c       	lddsp	r12,sp[0x8]
80008ed6:	58 0c       	cp.w	r12,0
80008ed8:	c1 05       	brlt	80008ef8 <_vfprintf_r+0x10b4>
80008eda:	18 9a       	mov	r10,r12
80008edc:	30 0b       	mov	r11,0
80008ede:	0c 9c       	mov	r12,r6
80008ee0:	e0 a0 12 38 	rcall	8000b350 <memchr>
80008ee4:	e0 80 02 df 	breq	800094a2 <_vfprintf_r+0x165e>
80008ee8:	f8 06 01 02 	sub	r2,r12,r6
80008eec:	40 2b       	lddsp	r11,sp[0x8]
80008eee:	16 32       	cp.w	r2,r11
80008ef0:	e0 89 02 d9 	brgt	800094a2 <_vfprintf_r+0x165e>
80008ef4:	e0 8f 02 d4 	bral	8000949c <_vfprintf_r+0x1658>
80008ef8:	30 0a       	mov	r10,0
80008efa:	0c 9c       	mov	r12,r6
80008efc:	50 2a       	stdsp	sp[0x8],r10
80008efe:	e0 a0 15 99 	rcall	8000ba30 <strlen>
80008f02:	18 92       	mov	r2,r12
80008f04:	e0 8f 02 d2 	bral	800094a8 <_vfprintf_r+0x1664>
80008f08:	50 a7       	stdsp	sp[0x28],r7
80008f0a:	50 80       	stdsp	sp[0x20],r0
80008f0c:	0c 97       	mov	r7,r6
80008f0e:	04 94       	mov	r4,r2
80008f10:	06 96       	mov	r6,r3
80008f12:	02 92       	mov	r2,r1
80008f14:	40 93       	lddsp	r3,sp[0x24]
80008f16:	10 90       	mov	r0,r8
80008f18:	40 41       	lddsp	r1,sp[0x10]
80008f1a:	a5 a5       	sbr	r5,0x4
80008f1c:	c0 a8       	rjmp	80008f30 <_vfprintf_r+0x10ec>
80008f1e:	50 a7       	stdsp	sp[0x28],r7
80008f20:	50 80       	stdsp	sp[0x20],r0
80008f22:	0c 97       	mov	r7,r6
80008f24:	04 94       	mov	r4,r2
80008f26:	06 96       	mov	r6,r3
80008f28:	02 92       	mov	r2,r1
80008f2a:	40 93       	lddsp	r3,sp[0x24]
80008f2c:	10 90       	mov	r0,r8
80008f2e:	40 41       	lddsp	r1,sp[0x10]
80008f30:	ed b5 00 05 	bld	r5,0x5
80008f34:	c5 61       	brne	80008fe0 <_vfprintf_r+0x119c>
80008f36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f3a:	40 39       	lddsp	r9,sp[0xc]
80008f3c:	58 09       	cp.w	r9,0
80008f3e:	c2 10       	breq	80008f80 <_vfprintf_r+0x113c>
80008f40:	10 36       	cp.w	r6,r8
80008f42:	c0 74       	brge	80008f50 <_vfprintf_r+0x110c>
80008f44:	fa c8 f9 44 	sub	r8,sp,-1724
80008f48:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008f4c:	c2 38       	rjmp	80008f92 <_vfprintf_r+0x114e>
80008f4e:	d7 03       	nop
80008f50:	fa c8 f9 50 	sub	r8,sp,-1712
80008f54:	1a d8       	st.w	--sp,r8
80008f56:	fa c8 fa b8 	sub	r8,sp,-1352
80008f5a:	1a d8       	st.w	--sp,r8
80008f5c:	fa c8 fb b4 	sub	r8,sp,-1100
80008f60:	1a d8       	st.w	--sp,r8
80008f62:	fa c8 f9 40 	sub	r8,sp,-1728
80008f66:	fa c9 ff b4 	sub	r9,sp,-76
80008f6a:	04 9a       	mov	r10,r2
80008f6c:	0c 9b       	mov	r11,r6
80008f6e:	08 9c       	mov	r12,r4
80008f70:	fe b0 f5 d2 	rcall	80007b14 <get_arg>
80008f74:	2f dd       	sub	sp,-12
80008f76:	f8 e8 00 00 	ld.d	r8,r12[0]
80008f7a:	fa e9 00 00 	st.d	sp[0],r8
80008f7e:	c2 e8       	rjmp	80008fda <_vfprintf_r+0x1196>
80008f80:	ee ca ff ff 	sub	r10,r7,-1
80008f84:	10 37       	cp.w	r7,r8
80008f86:	c0 b4       	brge	80008f9c <_vfprintf_r+0x1158>
80008f88:	fa c8 f9 44 	sub	r8,sp,-1724
80008f8c:	14 97       	mov	r7,r10
80008f8e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008f92:	ec ea fd 88 	ld.d	r10,r6[-632]
80008f96:	fa eb 00 00 	st.d	sp[0],r10
80008f9a:	c2 08       	rjmp	80008fda <_vfprintf_r+0x1196>
80008f9c:	41 09       	lddsp	r9,sp[0x40]
80008f9e:	59 f8       	cp.w	r8,31
80008fa0:	e0 89 00 16 	brgt	80008fcc <_vfprintf_r+0x1188>
80008fa4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008fa8:	f2 cb ff f8 	sub	r11,r9,-8
80008fac:	fa e7 00 00 	st.d	sp[0],r6
80008fb0:	51 0b       	stdsp	sp[0x40],r11
80008fb2:	fa c6 f9 44 	sub	r6,sp,-1724
80008fb6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fba:	fa e6 00 00 	ld.d	r6,sp[0]
80008fbe:	f2 e7 fd 88 	st.d	r9[-632],r6
80008fc2:	2f f8       	sub	r8,-1
80008fc4:	14 97       	mov	r7,r10
80008fc6:	fb 48 06 b4 	st.w	sp[1716],r8
80008fca:	c0 88       	rjmp	80008fda <_vfprintf_r+0x1196>
80008fcc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008fd0:	2f 89       	sub	r9,-8
80008fd2:	fa e7 00 00 	st.d	sp[0],r6
80008fd6:	51 09       	stdsp	sp[0x40],r9
80008fd8:	14 97       	mov	r7,r10
80008fda:	30 18       	mov	r8,1
80008fdc:	e0 8f 01 d0 	bral	8000937c <_vfprintf_r+0x1538>
80008fe0:	ed b5 00 04 	bld	r5,0x4
80008fe4:	c1 61       	brne	80009010 <_vfprintf_r+0x11cc>
80008fe6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fea:	40 3e       	lddsp	lr,sp[0xc]
80008fec:	58 0e       	cp.w	lr,0
80008fee:	c0 80       	breq	80008ffe <_vfprintf_r+0x11ba>
80008ff0:	10 36       	cp.w	r6,r8
80008ff2:	c6 74       	brge	800090c0 <_vfprintf_r+0x127c>
80008ff4:	fa cc f9 44 	sub	r12,sp,-1724
80008ff8:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ffc:	c8 08       	rjmp	800090fc <_vfprintf_r+0x12b8>
80008ffe:	ee ca ff ff 	sub	r10,r7,-1
80009002:	10 37       	cp.w	r7,r8
80009004:	c7 f4       	brge	80009102 <_vfprintf_r+0x12be>
80009006:	fa cb f9 44 	sub	r11,sp,-1724
8000900a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000900e:	c7 68       	rjmp	800090fa <_vfprintf_r+0x12b6>
80009010:	ed b5 00 06 	bld	r5,0x6
80009014:	c4 a1       	brne	800090a8 <_vfprintf_r+0x1264>
80009016:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000901a:	40 3c       	lddsp	r12,sp[0xc]
8000901c:	58 0c       	cp.w	r12,0
8000901e:	c1 d0       	breq	80009058 <_vfprintf_r+0x1214>
80009020:	10 36       	cp.w	r6,r8
80009022:	c0 64       	brge	8000902e <_vfprintf_r+0x11ea>
80009024:	fa cb f9 44 	sub	r11,sp,-1724
80009028:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000902c:	c1 f8       	rjmp	8000906a <_vfprintf_r+0x1226>
8000902e:	fa c8 f9 50 	sub	r8,sp,-1712
80009032:	1a d8       	st.w	--sp,r8
80009034:	fa c8 fa b8 	sub	r8,sp,-1352
80009038:	1a d8       	st.w	--sp,r8
8000903a:	fa c8 fb b4 	sub	r8,sp,-1100
8000903e:	1a d8       	st.w	--sp,r8
80009040:	fa c8 f9 40 	sub	r8,sp,-1728
80009044:	fa c9 ff b4 	sub	r9,sp,-76
80009048:	04 9a       	mov	r10,r2
8000904a:	0c 9b       	mov	r11,r6
8000904c:	08 9c       	mov	r12,r4
8000904e:	fe b0 f5 63 	rcall	80007b14 <get_arg>
80009052:	2f dd       	sub	sp,-12
80009054:	98 18       	ld.sh	r8,r12[0x2]
80009056:	c2 68       	rjmp	800090a2 <_vfprintf_r+0x125e>
80009058:	ee ca ff ff 	sub	r10,r7,-1
8000905c:	10 37       	cp.w	r7,r8
8000905e:	c0 94       	brge	80009070 <_vfprintf_r+0x122c>
80009060:	fa c9 f9 44 	sub	r9,sp,-1724
80009064:	14 97       	mov	r7,r10
80009066:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000906a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000906e:	c1 a8       	rjmp	800090a2 <_vfprintf_r+0x125e>
80009070:	41 09       	lddsp	r9,sp[0x40]
80009072:	59 f8       	cp.w	r8,31
80009074:	e0 89 00 13 	brgt	8000909a <_vfprintf_r+0x1256>
80009078:	f2 cb ff fc 	sub	r11,r9,-4
8000907c:	51 0b       	stdsp	sp[0x40],r11
8000907e:	72 09       	ld.w	r9,r9[0x0]
80009080:	fa c6 f9 44 	sub	r6,sp,-1724
80009084:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009088:	2f f8       	sub	r8,-1
8000908a:	f7 49 fd 88 	st.w	r11[-632],r9
8000908e:	fb 48 06 b4 	st.w	sp[1716],r8
80009092:	14 97       	mov	r7,r10
80009094:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009098:	c0 58       	rjmp	800090a2 <_vfprintf_r+0x125e>
8000909a:	92 18       	ld.sh	r8,r9[0x2]
8000909c:	14 97       	mov	r7,r10
8000909e:	2f c9       	sub	r9,-4
800090a0:	51 09       	stdsp	sp[0x40],r9
800090a2:	5c 78       	castu.h	r8
800090a4:	50 18       	stdsp	sp[0x4],r8
800090a6:	c4 68       	rjmp	80009132 <_vfprintf_r+0x12ee>
800090a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090ac:	40 3c       	lddsp	r12,sp[0xc]
800090ae:	58 0c       	cp.w	r12,0
800090b0:	c1 d0       	breq	800090ea <_vfprintf_r+0x12a6>
800090b2:	10 36       	cp.w	r6,r8
800090b4:	c0 64       	brge	800090c0 <_vfprintf_r+0x127c>
800090b6:	fa cb f9 44 	sub	r11,sp,-1724
800090ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090be:	c1 f8       	rjmp	800090fc <_vfprintf_r+0x12b8>
800090c0:	fa c8 f9 50 	sub	r8,sp,-1712
800090c4:	1a d8       	st.w	--sp,r8
800090c6:	fa c8 fa b8 	sub	r8,sp,-1352
800090ca:	0c 9b       	mov	r11,r6
800090cc:	1a d8       	st.w	--sp,r8
800090ce:	fa c8 fb b4 	sub	r8,sp,-1100
800090d2:	04 9a       	mov	r10,r2
800090d4:	1a d8       	st.w	--sp,r8
800090d6:	08 9c       	mov	r12,r4
800090d8:	fa c8 f9 40 	sub	r8,sp,-1728
800090dc:	fa c9 ff b4 	sub	r9,sp,-76
800090e0:	fe b0 f5 1a 	rcall	80007b14 <get_arg>
800090e4:	2f dd       	sub	sp,-12
800090e6:	78 0b       	ld.w	r11,r12[0x0]
800090e8:	c2 48       	rjmp	80009130 <_vfprintf_r+0x12ec>
800090ea:	ee ca ff ff 	sub	r10,r7,-1
800090ee:	10 37       	cp.w	r7,r8
800090f0:	c0 94       	brge	80009102 <_vfprintf_r+0x12be>
800090f2:	fa c9 f9 44 	sub	r9,sp,-1724
800090f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090fa:	14 97       	mov	r7,r10
800090fc:	ec fb fd 88 	ld.w	r11,r6[-632]
80009100:	c1 88       	rjmp	80009130 <_vfprintf_r+0x12ec>
80009102:	41 09       	lddsp	r9,sp[0x40]
80009104:	59 f8       	cp.w	r8,31
80009106:	e0 89 00 11 	brgt	80009128 <_vfprintf_r+0x12e4>
8000910a:	f2 cb ff fc 	sub	r11,r9,-4
8000910e:	51 0b       	stdsp	sp[0x40],r11
80009110:	fa c6 f9 44 	sub	r6,sp,-1724
80009114:	72 0b       	ld.w	r11,r9[0x0]
80009116:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000911a:	f3 4b fd 88 	st.w	r9[-632],r11
8000911e:	2f f8       	sub	r8,-1
80009120:	14 97       	mov	r7,r10
80009122:	fb 48 06 b4 	st.w	sp[1716],r8
80009126:	c0 58       	rjmp	80009130 <_vfprintf_r+0x12ec>
80009128:	72 0b       	ld.w	r11,r9[0x0]
8000912a:	14 97       	mov	r7,r10
8000912c:	2f c9       	sub	r9,-4
8000912e:	51 09       	stdsp	sp[0x40],r9
80009130:	50 1b       	stdsp	sp[0x4],r11
80009132:	30 0e       	mov	lr,0
80009134:	30 18       	mov	r8,1
80009136:	50 0e       	stdsp	sp[0x0],lr
80009138:	c2 29       	rjmp	8000937c <_vfprintf_r+0x1538>
8000913a:	50 a7       	stdsp	sp[0x28],r7
8000913c:	50 80       	stdsp	sp[0x20],r0
8000913e:	0c 97       	mov	r7,r6
80009140:	04 94       	mov	r4,r2
80009142:	06 96       	mov	r6,r3
80009144:	02 92       	mov	r2,r1
80009146:	fe cc b3 e2 	sub	r12,pc,-19486
8000914a:	40 93       	lddsp	r3,sp[0x24]
8000914c:	10 90       	mov	r0,r8
8000914e:	40 41       	lddsp	r1,sp[0x10]
80009150:	50 dc       	stdsp	sp[0x34],r12
80009152:	ed b5 00 05 	bld	r5,0x5
80009156:	c5 51       	brne	80009200 <_vfprintf_r+0x13bc>
80009158:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000915c:	40 3b       	lddsp	r11,sp[0xc]
8000915e:	58 0b       	cp.w	r11,0
80009160:	c2 20       	breq	800091a4 <_vfprintf_r+0x1360>
80009162:	10 36       	cp.w	r6,r8
80009164:	c0 a4       	brge	80009178 <_vfprintf_r+0x1334>
80009166:	fa ca f9 44 	sub	r10,sp,-1724
8000916a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000916e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009172:	fa e9 00 00 	st.d	sp[0],r8
80009176:	cf 28       	rjmp	8000935a <_vfprintf_r+0x1516>
80009178:	fa c8 f9 50 	sub	r8,sp,-1712
8000917c:	1a d8       	st.w	--sp,r8
8000917e:	fa c8 fa b8 	sub	r8,sp,-1352
80009182:	04 9a       	mov	r10,r2
80009184:	1a d8       	st.w	--sp,r8
80009186:	0c 9b       	mov	r11,r6
80009188:	fa c8 fb b4 	sub	r8,sp,-1100
8000918c:	08 9c       	mov	r12,r4
8000918e:	1a d8       	st.w	--sp,r8
80009190:	fa c8 f9 40 	sub	r8,sp,-1728
80009194:	fa c9 ff b4 	sub	r9,sp,-76
80009198:	fe b0 f4 be 	rcall	80007b14 <get_arg>
8000919c:	2f dd       	sub	sp,-12
8000919e:	f8 ea 00 00 	ld.d	r10,r12[0]
800091a2:	c0 c8       	rjmp	800091ba <_vfprintf_r+0x1376>
800091a4:	ee ca ff ff 	sub	r10,r7,-1
800091a8:	10 37       	cp.w	r7,r8
800091aa:	c0 b4       	brge	800091c0 <_vfprintf_r+0x137c>
800091ac:	fa c9 f9 44 	sub	r9,sp,-1724
800091b0:	14 97       	mov	r7,r10
800091b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091b6:	ec ea fd 88 	ld.d	r10,r6[-632]
800091ba:	fa eb 00 00 	st.d	sp[0],r10
800091be:	cc e8       	rjmp	8000935a <_vfprintf_r+0x1516>
800091c0:	41 09       	lddsp	r9,sp[0x40]
800091c2:	59 f8       	cp.w	r8,31
800091c4:	e0 89 00 16 	brgt	800091f0 <_vfprintf_r+0x13ac>
800091c8:	f2 e6 00 00 	ld.d	r6,r9[0]
800091cc:	f2 cb ff f8 	sub	r11,r9,-8
800091d0:	fa e7 00 00 	st.d	sp[0],r6
800091d4:	51 0b       	stdsp	sp[0x40],r11
800091d6:	fa c6 f9 44 	sub	r6,sp,-1724
800091da:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091de:	fa e6 00 00 	ld.d	r6,sp[0]
800091e2:	f2 e7 fd 88 	st.d	r9[-632],r6
800091e6:	2f f8       	sub	r8,-1
800091e8:	14 97       	mov	r7,r10
800091ea:	fb 48 06 b4 	st.w	sp[1716],r8
800091ee:	cb 68       	rjmp	8000935a <_vfprintf_r+0x1516>
800091f0:	f2 e6 00 00 	ld.d	r6,r9[0]
800091f4:	2f 89       	sub	r9,-8
800091f6:	fa e7 00 00 	st.d	sp[0],r6
800091fa:	51 09       	stdsp	sp[0x40],r9
800091fc:	14 97       	mov	r7,r10
800091fe:	ca e8       	rjmp	8000935a <_vfprintf_r+0x1516>
80009200:	ed b5 00 04 	bld	r5,0x4
80009204:	c1 71       	brne	80009232 <_vfprintf_r+0x13ee>
80009206:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000920a:	40 3e       	lddsp	lr,sp[0xc]
8000920c:	58 0e       	cp.w	lr,0
8000920e:	c0 80       	breq	8000921e <_vfprintf_r+0x13da>
80009210:	10 36       	cp.w	r6,r8
80009212:	c6 94       	brge	800092e4 <_vfprintf_r+0x14a0>
80009214:	fa cc f9 44 	sub	r12,sp,-1724
80009218:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000921c:	c8 28       	rjmp	80009320 <_vfprintf_r+0x14dc>
8000921e:	ee ca ff ff 	sub	r10,r7,-1
80009222:	10 37       	cp.w	r7,r8
80009224:	e0 84 00 81 	brge	80009326 <_vfprintf_r+0x14e2>
80009228:	fa cb f9 44 	sub	r11,sp,-1724
8000922c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009230:	c7 78       	rjmp	8000931e <_vfprintf_r+0x14da>
80009232:	ed b5 00 06 	bld	r5,0x6
80009236:	c4 b1       	brne	800092cc <_vfprintf_r+0x1488>
80009238:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000923c:	40 3c       	lddsp	r12,sp[0xc]
8000923e:	58 0c       	cp.w	r12,0
80009240:	c1 d0       	breq	8000927a <_vfprintf_r+0x1436>
80009242:	10 36       	cp.w	r6,r8
80009244:	c0 64       	brge	80009250 <_vfprintf_r+0x140c>
80009246:	fa cb f9 44 	sub	r11,sp,-1724
8000924a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000924e:	c1 f8       	rjmp	8000928c <_vfprintf_r+0x1448>
80009250:	fa c8 f9 50 	sub	r8,sp,-1712
80009254:	1a d8       	st.w	--sp,r8
80009256:	fa c8 fa b8 	sub	r8,sp,-1352
8000925a:	1a d8       	st.w	--sp,r8
8000925c:	fa c8 fb b4 	sub	r8,sp,-1100
80009260:	1a d8       	st.w	--sp,r8
80009262:	fa c8 f9 40 	sub	r8,sp,-1728
80009266:	fa c9 ff b4 	sub	r9,sp,-76
8000926a:	04 9a       	mov	r10,r2
8000926c:	0c 9b       	mov	r11,r6
8000926e:	08 9c       	mov	r12,r4
80009270:	fe b0 f4 52 	rcall	80007b14 <get_arg>
80009274:	2f dd       	sub	sp,-12
80009276:	98 18       	ld.sh	r8,r12[0x2]
80009278:	c2 78       	rjmp	800092c6 <_vfprintf_r+0x1482>
8000927a:	ee ca ff ff 	sub	r10,r7,-1
8000927e:	10 37       	cp.w	r7,r8
80009280:	c0 a4       	brge	80009294 <_vfprintf_r+0x1450>
80009282:	fa c9 f9 44 	sub	r9,sp,-1724
80009286:	14 97       	mov	r7,r10
80009288:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000928c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009290:	c1 b8       	rjmp	800092c6 <_vfprintf_r+0x1482>
80009292:	d7 03       	nop
80009294:	41 09       	lddsp	r9,sp[0x40]
80009296:	59 f8       	cp.w	r8,31
80009298:	e0 89 00 13 	brgt	800092be <_vfprintf_r+0x147a>
8000929c:	f2 cb ff fc 	sub	r11,r9,-4
800092a0:	51 0b       	stdsp	sp[0x40],r11
800092a2:	72 09       	ld.w	r9,r9[0x0]
800092a4:	fa c6 f9 44 	sub	r6,sp,-1724
800092a8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800092ac:	2f f8       	sub	r8,-1
800092ae:	f7 49 fd 88 	st.w	r11[-632],r9
800092b2:	fb 48 06 b4 	st.w	sp[1716],r8
800092b6:	14 97       	mov	r7,r10
800092b8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800092bc:	c0 58       	rjmp	800092c6 <_vfprintf_r+0x1482>
800092be:	92 18       	ld.sh	r8,r9[0x2]
800092c0:	14 97       	mov	r7,r10
800092c2:	2f c9       	sub	r9,-4
800092c4:	51 09       	stdsp	sp[0x40],r9
800092c6:	5c 78       	castu.h	r8
800092c8:	50 18       	stdsp	sp[0x4],r8
800092ca:	c4 68       	rjmp	80009356 <_vfprintf_r+0x1512>
800092cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092d0:	40 3c       	lddsp	r12,sp[0xc]
800092d2:	58 0c       	cp.w	r12,0
800092d4:	c1 d0       	breq	8000930e <_vfprintf_r+0x14ca>
800092d6:	10 36       	cp.w	r6,r8
800092d8:	c0 64       	brge	800092e4 <_vfprintf_r+0x14a0>
800092da:	fa cb f9 44 	sub	r11,sp,-1724
800092de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092e2:	c1 f8       	rjmp	80009320 <_vfprintf_r+0x14dc>
800092e4:	fa c8 f9 50 	sub	r8,sp,-1712
800092e8:	1a d8       	st.w	--sp,r8
800092ea:	fa c8 fa b8 	sub	r8,sp,-1352
800092ee:	0c 9b       	mov	r11,r6
800092f0:	1a d8       	st.w	--sp,r8
800092f2:	fa c8 fb b4 	sub	r8,sp,-1100
800092f6:	04 9a       	mov	r10,r2
800092f8:	1a d8       	st.w	--sp,r8
800092fa:	08 9c       	mov	r12,r4
800092fc:	fa c8 f9 40 	sub	r8,sp,-1728
80009300:	fa c9 ff b4 	sub	r9,sp,-76
80009304:	fe b0 f4 08 	rcall	80007b14 <get_arg>
80009308:	2f dd       	sub	sp,-12
8000930a:	78 0b       	ld.w	r11,r12[0x0]
8000930c:	c2 48       	rjmp	80009354 <_vfprintf_r+0x1510>
8000930e:	ee ca ff ff 	sub	r10,r7,-1
80009312:	10 37       	cp.w	r7,r8
80009314:	c0 94       	brge	80009326 <_vfprintf_r+0x14e2>
80009316:	fa c9 f9 44 	sub	r9,sp,-1724
8000931a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000931e:	14 97       	mov	r7,r10
80009320:	ec fb fd 88 	ld.w	r11,r6[-632]
80009324:	c1 88       	rjmp	80009354 <_vfprintf_r+0x1510>
80009326:	41 09       	lddsp	r9,sp[0x40]
80009328:	59 f8       	cp.w	r8,31
8000932a:	e0 89 00 11 	brgt	8000934c <_vfprintf_r+0x1508>
8000932e:	f2 cb ff fc 	sub	r11,r9,-4
80009332:	51 0b       	stdsp	sp[0x40],r11
80009334:	fa c6 f9 44 	sub	r6,sp,-1724
80009338:	72 0b       	ld.w	r11,r9[0x0]
8000933a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000933e:	f3 4b fd 88 	st.w	r9[-632],r11
80009342:	2f f8       	sub	r8,-1
80009344:	14 97       	mov	r7,r10
80009346:	fb 48 06 b4 	st.w	sp[1716],r8
8000934a:	c0 58       	rjmp	80009354 <_vfprintf_r+0x1510>
8000934c:	72 0b       	ld.w	r11,r9[0x0]
8000934e:	14 97       	mov	r7,r10
80009350:	2f c9       	sub	r9,-4
80009352:	51 09       	stdsp	sp[0x40],r9
80009354:	50 1b       	stdsp	sp[0x4],r11
80009356:	30 0e       	mov	lr,0
80009358:	50 0e       	stdsp	sp[0x0],lr
8000935a:	40 08       	lddsp	r8,sp[0x0]
8000935c:	40 1c       	lddsp	r12,sp[0x4]
8000935e:	18 48       	or	r8,r12
80009360:	5f 19       	srne	r9
80009362:	0a 98       	mov	r8,r5
80009364:	eb e9 00 09 	and	r9,r5,r9
80009368:	a1 b8       	sbr	r8,0x1
8000936a:	58 09       	cp.w	r9,0
8000936c:	c0 70       	breq	8000937a <_vfprintf_r+0x1536>
8000936e:	10 95       	mov	r5,r8
80009370:	fb 60 06 b9 	st.b	sp[1721],r0
80009374:	33 08       	mov	r8,48
80009376:	fb 68 06 b8 	st.b	sp[1720],r8
8000937a:	30 28       	mov	r8,2
8000937c:	30 09       	mov	r9,0
8000937e:	fb 69 06 bb 	st.b	sp[1723],r9
80009382:	0a 99       	mov	r9,r5
80009384:	a7 d9       	cbr	r9,0x7
80009386:	40 2b       	lddsp	r11,sp[0x8]
80009388:	40 16       	lddsp	r6,sp[0x4]
8000938a:	58 0b       	cp.w	r11,0
8000938c:	5f 1a       	srne	r10
8000938e:	f2 05 17 40 	movge	r5,r9
80009392:	fa c2 f9 78 	sub	r2,sp,-1672
80009396:	40 09       	lddsp	r9,sp[0x0]
80009398:	0c 49       	or	r9,r6
8000939a:	5f 19       	srne	r9
8000939c:	f5 e9 10 09 	or	r9,r10,r9
800093a0:	c5 c0       	breq	80009458 <_vfprintf_r+0x1614>
800093a2:	30 19       	mov	r9,1
800093a4:	f2 08 18 00 	cp.b	r8,r9
800093a8:	c0 60       	breq	800093b4 <_vfprintf_r+0x1570>
800093aa:	30 29       	mov	r9,2
800093ac:	f2 08 18 00 	cp.b	r8,r9
800093b0:	c0 41       	brne	800093b8 <_vfprintf_r+0x1574>
800093b2:	c3 c8       	rjmp	8000942a <_vfprintf_r+0x15e6>
800093b4:	04 96       	mov	r6,r2
800093b6:	c3 08       	rjmp	80009416 <_vfprintf_r+0x15d2>
800093b8:	04 96       	mov	r6,r2
800093ba:	fa e8 00 00 	ld.d	r8,sp[0]
800093be:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800093c2:	2d 0a       	sub	r10,-48
800093c4:	0c fa       	st.b	--r6,r10
800093c6:	f0 0b 16 03 	lsr	r11,r8,0x3
800093ca:	f2 0c 16 03 	lsr	r12,r9,0x3
800093ce:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800093d2:	18 99       	mov	r9,r12
800093d4:	16 98       	mov	r8,r11
800093d6:	58 08       	cp.w	r8,0
800093d8:	5c 29       	cpc	r9
800093da:	cf 21       	brne	800093be <_vfprintf_r+0x157a>
800093dc:	fa e9 00 00 	st.d	sp[0],r8
800093e0:	ed b5 00 00 	bld	r5,0x0
800093e4:	c4 51       	brne	8000946e <_vfprintf_r+0x162a>
800093e6:	33 09       	mov	r9,48
800093e8:	f2 0a 18 00 	cp.b	r10,r9
800093ec:	c4 10       	breq	8000946e <_vfprintf_r+0x162a>
800093ee:	0c f9       	st.b	--r6,r9
800093f0:	c3 f8       	rjmp	8000946e <_vfprintf_r+0x162a>
800093f2:	fa ea 00 00 	ld.d	r10,sp[0]
800093f6:	30 a8       	mov	r8,10
800093f8:	30 09       	mov	r9,0
800093fa:	e0 a0 1a 19 	rcall	8000c82c <__avr32_umod64>
800093fe:	30 a8       	mov	r8,10
80009400:	2d 0a       	sub	r10,-48
80009402:	30 09       	mov	r9,0
80009404:	ac 8a       	st.b	r6[0x0],r10
80009406:	fa ea 00 00 	ld.d	r10,sp[0]
8000940a:	e0 a0 18 df 	rcall	8000c5c8 <__avr32_udiv64>
8000940e:	16 99       	mov	r9,r11
80009410:	14 98       	mov	r8,r10
80009412:	fa e9 00 00 	st.d	sp[0],r8
80009416:	20 16       	sub	r6,1
80009418:	fa ea 00 00 	ld.d	r10,sp[0]
8000941c:	58 9a       	cp.w	r10,9
8000941e:	5c 2b       	cpc	r11
80009420:	fe 9b ff e9 	brhi	800093f2 <_vfprintf_r+0x15ae>
80009424:	1b f8       	ld.ub	r8,sp[0x7]
80009426:	2d 08       	sub	r8,-48
80009428:	c2 08       	rjmp	80009468 <_vfprintf_r+0x1624>
8000942a:	04 96       	mov	r6,r2
8000942c:	fa e8 00 00 	ld.d	r8,sp[0]
80009430:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009434:	40 de       	lddsp	lr,sp[0x34]
80009436:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000943a:	0c fa       	st.b	--r6,r10
8000943c:	f2 0b 16 04 	lsr	r11,r9,0x4
80009440:	f0 0a 16 04 	lsr	r10,r8,0x4
80009444:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009448:	16 99       	mov	r9,r11
8000944a:	14 98       	mov	r8,r10
8000944c:	58 08       	cp.w	r8,0
8000944e:	5c 29       	cpc	r9
80009450:	cf 01       	brne	80009430 <_vfprintf_r+0x15ec>
80009452:	fa e9 00 00 	st.d	sp[0],r8
80009456:	c0 c8       	rjmp	8000946e <_vfprintf_r+0x162a>
80009458:	58 08       	cp.w	r8,0
8000945a:	c0 91       	brne	8000946c <_vfprintf_r+0x1628>
8000945c:	ed b5 00 00 	bld	r5,0x0
80009460:	c0 61       	brne	8000946c <_vfprintf_r+0x1628>
80009462:	fa c6 f9 79 	sub	r6,sp,-1671
80009466:	33 08       	mov	r8,48
80009468:	ac 88       	st.b	r6[0x0],r8
8000946a:	c0 28       	rjmp	8000946e <_vfprintf_r+0x162a>
8000946c:	04 96       	mov	r6,r2
8000946e:	0c 12       	sub	r2,r6
80009470:	c1 c8       	rjmp	800094a8 <_vfprintf_r+0x1664>
80009472:	50 a7       	stdsp	sp[0x28],r7
80009474:	50 80       	stdsp	sp[0x20],r0
80009476:	40 93       	lddsp	r3,sp[0x24]
80009478:	0c 97       	mov	r7,r6
8000947a:	10 90       	mov	r0,r8
8000947c:	04 94       	mov	r4,r2
8000947e:	40 41       	lddsp	r1,sp[0x10]
80009480:	58 08       	cp.w	r8,0
80009482:	e0 80 04 4f 	breq	80009d20 <_vfprintf_r+0x1edc>
80009486:	fb 68 06 60 	st.b	sp[1632],r8
8000948a:	30 0c       	mov	r12,0
8000948c:	30 08       	mov	r8,0
8000948e:	30 12       	mov	r2,1
80009490:	fb 68 06 bb 	st.b	sp[1723],r8
80009494:	50 2c       	stdsp	sp[0x8],r12
80009496:	fa c6 f9 a0 	sub	r6,sp,-1632
8000949a:	c0 78       	rjmp	800094a8 <_vfprintf_r+0x1664>
8000949c:	30 0b       	mov	r11,0
8000949e:	50 2b       	stdsp	sp[0x8],r11
800094a0:	c0 48       	rjmp	800094a8 <_vfprintf_r+0x1664>
800094a2:	40 22       	lddsp	r2,sp[0x8]
800094a4:	30 0a       	mov	r10,0
800094a6:	50 2a       	stdsp	sp[0x8],r10
800094a8:	40 29       	lddsp	r9,sp[0x8]
800094aa:	e4 09 0c 49 	max	r9,r2,r9
800094ae:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800094b2:	50 39       	stdsp	sp[0xc],r9
800094b4:	0a 9e       	mov	lr,r5
800094b6:	30 09       	mov	r9,0
800094b8:	e2 1e 00 02 	andl	lr,0x2,COH
800094bc:	f2 08 18 00 	cp.b	r8,r9
800094c0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800094c4:	f7 b8 01 ff 	subne	r8,-1
800094c8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800094cc:	0a 9b       	mov	r11,r5
800094ce:	58 0e       	cp.w	lr,0
800094d0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800094d4:	f7 bc 01 fe 	subne	r12,-2
800094d8:	fb fc 1a 03 	st.wne	sp[0xc],r12
800094dc:	e2 1b 00 84 	andl	r11,0x84,COH
800094e0:	50 fe       	stdsp	sp[0x3c],lr
800094e2:	50 9b       	stdsp	sp[0x24],r11
800094e4:	c4 71       	brne	80009572 <_vfprintf_r+0x172e>
800094e6:	40 8a       	lddsp	r10,sp[0x20]
800094e8:	40 39       	lddsp	r9,sp[0xc]
800094ea:	12 1a       	sub	r10,r9
800094ec:	50 4a       	stdsp	sp[0x10],r10
800094ee:	58 0a       	cp.w	r10,0
800094f0:	e0 89 00 20 	brgt	80009530 <_vfprintf_r+0x16ec>
800094f4:	c3 f8       	rjmp	80009572 <_vfprintf_r+0x172e>
800094f6:	2f 09       	sub	r9,-16
800094f8:	2f f8       	sub	r8,-1
800094fa:	fe ce b7 7e 	sub	lr,pc,-18562
800094fe:	31 0c       	mov	r12,16
80009500:	fb 49 06 90 	st.w	sp[1680],r9
80009504:	87 0e       	st.w	r3[0x0],lr
80009506:	87 1c       	st.w	r3[0x4],r12
80009508:	fb 48 06 8c 	st.w	sp[1676],r8
8000950c:	58 78       	cp.w	r8,7
8000950e:	e0 89 00 04 	brgt	80009516 <_vfprintf_r+0x16d2>
80009512:	2f 83       	sub	r3,-8
80009514:	c0 b8       	rjmp	8000952a <_vfprintf_r+0x16e6>
80009516:	fa ca f9 78 	sub	r10,sp,-1672
8000951a:	02 9b       	mov	r11,r1
8000951c:	08 9c       	mov	r12,r4
8000951e:	fe b0 f4 85 	rcall	80007e28 <__sprint_r>
80009522:	e0 81 04 10 	brne	80009d42 <_vfprintf_r+0x1efe>
80009526:	fa c3 f9 e0 	sub	r3,sp,-1568
8000952a:	40 4b       	lddsp	r11,sp[0x10]
8000952c:	21 0b       	sub	r11,16
8000952e:	50 4b       	stdsp	sp[0x10],r11
80009530:	fa f9 06 90 	ld.w	r9,sp[1680]
80009534:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009538:	fe ca b7 bc 	sub	r10,pc,-18500
8000953c:	40 4e       	lddsp	lr,sp[0x10]
8000953e:	59 0e       	cp.w	lr,16
80009540:	fe 99 ff db 	brgt	800094f6 <_vfprintf_r+0x16b2>
80009544:	1c 09       	add	r9,lr
80009546:	2f f8       	sub	r8,-1
80009548:	87 0a       	st.w	r3[0x0],r10
8000954a:	fb 49 06 90 	st.w	sp[1680],r9
8000954e:	87 1e       	st.w	r3[0x4],lr
80009550:	fb 48 06 8c 	st.w	sp[1676],r8
80009554:	58 78       	cp.w	r8,7
80009556:	e0 89 00 04 	brgt	8000955e <_vfprintf_r+0x171a>
8000955a:	2f 83       	sub	r3,-8
8000955c:	c0 b8       	rjmp	80009572 <_vfprintf_r+0x172e>
8000955e:	fa ca f9 78 	sub	r10,sp,-1672
80009562:	02 9b       	mov	r11,r1
80009564:	08 9c       	mov	r12,r4
80009566:	fe b0 f4 61 	rcall	80007e28 <__sprint_r>
8000956a:	e0 81 03 ec 	brne	80009d42 <_vfprintf_r+0x1efe>
8000956e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009572:	30 09       	mov	r9,0
80009574:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009578:	f2 08 18 00 	cp.b	r8,r9
8000957c:	c1 f0       	breq	800095ba <_vfprintf_r+0x1776>
8000957e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009582:	fa c9 f9 45 	sub	r9,sp,-1723
80009586:	2f f8       	sub	r8,-1
80009588:	87 09       	st.w	r3[0x0],r9
8000958a:	fb 48 06 90 	st.w	sp[1680],r8
8000958e:	30 19       	mov	r9,1
80009590:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009594:	87 19       	st.w	r3[0x4],r9
80009596:	2f f8       	sub	r8,-1
80009598:	fb 48 06 8c 	st.w	sp[1676],r8
8000959c:	58 78       	cp.w	r8,7
8000959e:	e0 89 00 04 	brgt	800095a6 <_vfprintf_r+0x1762>
800095a2:	2f 83       	sub	r3,-8
800095a4:	c0 b8       	rjmp	800095ba <_vfprintf_r+0x1776>
800095a6:	fa ca f9 78 	sub	r10,sp,-1672
800095aa:	02 9b       	mov	r11,r1
800095ac:	08 9c       	mov	r12,r4
800095ae:	fe b0 f4 3d 	rcall	80007e28 <__sprint_r>
800095b2:	e0 81 03 c8 	brne	80009d42 <_vfprintf_r+0x1efe>
800095b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800095ba:	40 fc       	lddsp	r12,sp[0x3c]
800095bc:	58 0c       	cp.w	r12,0
800095be:	c1 f0       	breq	800095fc <_vfprintf_r+0x17b8>
800095c0:	fa f8 06 90 	ld.w	r8,sp[1680]
800095c4:	fa c9 f9 48 	sub	r9,sp,-1720
800095c8:	2f e8       	sub	r8,-2
800095ca:	87 09       	st.w	r3[0x0],r9
800095cc:	fb 48 06 90 	st.w	sp[1680],r8
800095d0:	30 29       	mov	r9,2
800095d2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095d6:	87 19       	st.w	r3[0x4],r9
800095d8:	2f f8       	sub	r8,-1
800095da:	fb 48 06 8c 	st.w	sp[1676],r8
800095de:	58 78       	cp.w	r8,7
800095e0:	e0 89 00 04 	brgt	800095e8 <_vfprintf_r+0x17a4>
800095e4:	2f 83       	sub	r3,-8
800095e6:	c0 b8       	rjmp	800095fc <_vfprintf_r+0x17b8>
800095e8:	fa ca f9 78 	sub	r10,sp,-1672
800095ec:	02 9b       	mov	r11,r1
800095ee:	08 9c       	mov	r12,r4
800095f0:	fe b0 f4 1c 	rcall	80007e28 <__sprint_r>
800095f4:	e0 81 03 a7 	brne	80009d42 <_vfprintf_r+0x1efe>
800095f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800095fc:	40 9b       	lddsp	r11,sp[0x24]
800095fe:	e0 4b 00 80 	cp.w	r11,128
80009602:	c4 71       	brne	80009690 <_vfprintf_r+0x184c>
80009604:	40 8a       	lddsp	r10,sp[0x20]
80009606:	40 39       	lddsp	r9,sp[0xc]
80009608:	12 1a       	sub	r10,r9
8000960a:	50 4a       	stdsp	sp[0x10],r10
8000960c:	58 0a       	cp.w	r10,0
8000960e:	e0 89 00 20 	brgt	8000964e <_vfprintf_r+0x180a>
80009612:	c3 f8       	rjmp	80009690 <_vfprintf_r+0x184c>
80009614:	2f 09       	sub	r9,-16
80009616:	2f f8       	sub	r8,-1
80009618:	fe ce b8 8c 	sub	lr,pc,-18292
8000961c:	31 0c       	mov	r12,16
8000961e:	fb 49 06 90 	st.w	sp[1680],r9
80009622:	87 0e       	st.w	r3[0x0],lr
80009624:	87 1c       	st.w	r3[0x4],r12
80009626:	fb 48 06 8c 	st.w	sp[1676],r8
8000962a:	58 78       	cp.w	r8,7
8000962c:	e0 89 00 04 	brgt	80009634 <_vfprintf_r+0x17f0>
80009630:	2f 83       	sub	r3,-8
80009632:	c0 b8       	rjmp	80009648 <_vfprintf_r+0x1804>
80009634:	fa ca f9 78 	sub	r10,sp,-1672
80009638:	02 9b       	mov	r11,r1
8000963a:	08 9c       	mov	r12,r4
8000963c:	fe b0 f3 f6 	rcall	80007e28 <__sprint_r>
80009640:	e0 81 03 81 	brne	80009d42 <_vfprintf_r+0x1efe>
80009644:	fa c3 f9 e0 	sub	r3,sp,-1568
80009648:	40 4b       	lddsp	r11,sp[0x10]
8000964a:	21 0b       	sub	r11,16
8000964c:	50 4b       	stdsp	sp[0x10],r11
8000964e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009652:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009656:	fe ca b8 ca 	sub	r10,pc,-18230
8000965a:	40 4e       	lddsp	lr,sp[0x10]
8000965c:	59 0e       	cp.w	lr,16
8000965e:	fe 99 ff db 	brgt	80009614 <_vfprintf_r+0x17d0>
80009662:	1c 09       	add	r9,lr
80009664:	2f f8       	sub	r8,-1
80009666:	87 0a       	st.w	r3[0x0],r10
80009668:	fb 49 06 90 	st.w	sp[1680],r9
8000966c:	87 1e       	st.w	r3[0x4],lr
8000966e:	fb 48 06 8c 	st.w	sp[1676],r8
80009672:	58 78       	cp.w	r8,7
80009674:	e0 89 00 04 	brgt	8000967c <_vfprintf_r+0x1838>
80009678:	2f 83       	sub	r3,-8
8000967a:	c0 b8       	rjmp	80009690 <_vfprintf_r+0x184c>
8000967c:	fa ca f9 78 	sub	r10,sp,-1672
80009680:	02 9b       	mov	r11,r1
80009682:	08 9c       	mov	r12,r4
80009684:	fe b0 f3 d2 	rcall	80007e28 <__sprint_r>
80009688:	e0 81 03 5d 	brne	80009d42 <_vfprintf_r+0x1efe>
8000968c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009690:	40 2c       	lddsp	r12,sp[0x8]
80009692:	04 1c       	sub	r12,r2
80009694:	50 2c       	stdsp	sp[0x8],r12
80009696:	58 0c       	cp.w	r12,0
80009698:	e0 89 00 20 	brgt	800096d8 <_vfprintf_r+0x1894>
8000969c:	c3 f8       	rjmp	8000971a <_vfprintf_r+0x18d6>
8000969e:	2f 09       	sub	r9,-16
800096a0:	2f f8       	sub	r8,-1
800096a2:	fe cb b9 16 	sub	r11,pc,-18154
800096a6:	31 0a       	mov	r10,16
800096a8:	fb 49 06 90 	st.w	sp[1680],r9
800096ac:	87 0b       	st.w	r3[0x0],r11
800096ae:	87 1a       	st.w	r3[0x4],r10
800096b0:	fb 48 06 8c 	st.w	sp[1676],r8
800096b4:	58 78       	cp.w	r8,7
800096b6:	e0 89 00 04 	brgt	800096be <_vfprintf_r+0x187a>
800096ba:	2f 83       	sub	r3,-8
800096bc:	c0 b8       	rjmp	800096d2 <_vfprintf_r+0x188e>
800096be:	fa ca f9 78 	sub	r10,sp,-1672
800096c2:	02 9b       	mov	r11,r1
800096c4:	08 9c       	mov	r12,r4
800096c6:	fe b0 f3 b1 	rcall	80007e28 <__sprint_r>
800096ca:	e0 81 03 3c 	brne	80009d42 <_vfprintf_r+0x1efe>
800096ce:	fa c3 f9 e0 	sub	r3,sp,-1568
800096d2:	40 29       	lddsp	r9,sp[0x8]
800096d4:	21 09       	sub	r9,16
800096d6:	50 29       	stdsp	sp[0x8],r9
800096d8:	fa f9 06 90 	ld.w	r9,sp[1680]
800096dc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096e0:	fe ca b9 54 	sub	r10,pc,-18092
800096e4:	40 2e       	lddsp	lr,sp[0x8]
800096e6:	59 0e       	cp.w	lr,16
800096e8:	fe 99 ff db 	brgt	8000969e <_vfprintf_r+0x185a>
800096ec:	1c 09       	add	r9,lr
800096ee:	2f f8       	sub	r8,-1
800096f0:	87 0a       	st.w	r3[0x0],r10
800096f2:	fb 49 06 90 	st.w	sp[1680],r9
800096f6:	87 1e       	st.w	r3[0x4],lr
800096f8:	fb 48 06 8c 	st.w	sp[1676],r8
800096fc:	58 78       	cp.w	r8,7
800096fe:	e0 89 00 04 	brgt	80009706 <_vfprintf_r+0x18c2>
80009702:	2f 83       	sub	r3,-8
80009704:	c0 b8       	rjmp	8000971a <_vfprintf_r+0x18d6>
80009706:	fa ca f9 78 	sub	r10,sp,-1672
8000970a:	02 9b       	mov	r11,r1
8000970c:	08 9c       	mov	r12,r4
8000970e:	fe b0 f3 8d 	rcall	80007e28 <__sprint_r>
80009712:	e0 81 03 18 	brne	80009d42 <_vfprintf_r+0x1efe>
80009716:	fa c3 f9 e0 	sub	r3,sp,-1568
8000971a:	ed b5 00 08 	bld	r5,0x8
8000971e:	c0 b0       	breq	80009734 <_vfprintf_r+0x18f0>
80009720:	fa f8 06 90 	ld.w	r8,sp[1680]
80009724:	87 12       	st.w	r3[0x4],r2
80009726:	87 06       	st.w	r3[0x0],r6
80009728:	f0 02 00 02 	add	r2,r8,r2
8000972c:	fb 42 06 90 	st.w	sp[1680],r2
80009730:	e0 8f 01 d4 	bral	80009ad8 <_vfprintf_r+0x1c94>
80009734:	e0 40 00 65 	cp.w	r0,101
80009738:	e0 8a 01 d6 	brle	80009ae4 <_vfprintf_r+0x1ca0>
8000973c:	30 08       	mov	r8,0
8000973e:	30 09       	mov	r9,0
80009740:	40 5b       	lddsp	r11,sp[0x14]
80009742:	40 7a       	lddsp	r10,sp[0x1c]
80009744:	e0 a0 15 3b 	rcall	8000c1ba <__avr32_f64_cmp_eq>
80009748:	c7 90       	breq	8000983a <_vfprintf_r+0x19f6>
8000974a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000974e:	fe c9 b9 d6 	sub	r9,pc,-17962
80009752:	2f f8       	sub	r8,-1
80009754:	87 09       	st.w	r3[0x0],r9
80009756:	fb 48 06 90 	st.w	sp[1680],r8
8000975a:	30 19       	mov	r9,1
8000975c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009760:	87 19       	st.w	r3[0x4],r9
80009762:	2f f8       	sub	r8,-1
80009764:	fb 48 06 8c 	st.w	sp[1676],r8
80009768:	58 78       	cp.w	r8,7
8000976a:	e0 89 00 05 	brgt	80009774 <_vfprintf_r+0x1930>
8000976e:	2f 83       	sub	r3,-8
80009770:	c0 c8       	rjmp	80009788 <_vfprintf_r+0x1944>
80009772:	d7 03       	nop
80009774:	fa ca f9 78 	sub	r10,sp,-1672
80009778:	02 9b       	mov	r11,r1
8000977a:	08 9c       	mov	r12,r4
8000977c:	fe b0 f3 56 	rcall	80007e28 <__sprint_r>
80009780:	e0 81 02 e1 	brne	80009d42 <_vfprintf_r+0x1efe>
80009784:	fa c3 f9 e0 	sub	r3,sp,-1568
80009788:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000978c:	40 6c       	lddsp	r12,sp[0x18]
8000978e:	18 38       	cp.w	r8,r12
80009790:	c0 55       	brlt	8000979a <_vfprintf_r+0x1956>
80009792:	ed b5 00 00 	bld	r5,0x0
80009796:	e0 81 02 6b 	brne	80009c6c <_vfprintf_r+0x1e28>
8000979a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000979e:	2f f8       	sub	r8,-1
800097a0:	40 cb       	lddsp	r11,sp[0x30]
800097a2:	fb 48 06 90 	st.w	sp[1680],r8
800097a6:	30 19       	mov	r9,1
800097a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097ac:	87 0b       	st.w	r3[0x0],r11
800097ae:	2f f8       	sub	r8,-1
800097b0:	87 19       	st.w	r3[0x4],r9
800097b2:	fb 48 06 8c 	st.w	sp[1676],r8
800097b6:	58 78       	cp.w	r8,7
800097b8:	e0 89 00 04 	brgt	800097c0 <_vfprintf_r+0x197c>
800097bc:	2f 83       	sub	r3,-8
800097be:	c0 b8       	rjmp	800097d4 <_vfprintf_r+0x1990>
800097c0:	fa ca f9 78 	sub	r10,sp,-1672
800097c4:	02 9b       	mov	r11,r1
800097c6:	08 9c       	mov	r12,r4
800097c8:	fe b0 f3 30 	rcall	80007e28 <__sprint_r>
800097cc:	e0 81 02 bb 	brne	80009d42 <_vfprintf_r+0x1efe>
800097d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800097d4:	40 66       	lddsp	r6,sp[0x18]
800097d6:	20 16       	sub	r6,1
800097d8:	58 06       	cp.w	r6,0
800097da:	e0 89 00 1d 	brgt	80009814 <_vfprintf_r+0x19d0>
800097de:	e0 8f 02 47 	bral	80009c6c <_vfprintf_r+0x1e28>
800097e2:	2f 09       	sub	r9,-16
800097e4:	2f f8       	sub	r8,-1
800097e6:	fb 49 06 90 	st.w	sp[1680],r9
800097ea:	87 02       	st.w	r3[0x0],r2
800097ec:	87 10       	st.w	r3[0x4],r0
800097ee:	fb 48 06 8c 	st.w	sp[1676],r8
800097f2:	58 78       	cp.w	r8,7
800097f4:	e0 89 00 04 	brgt	800097fc <_vfprintf_r+0x19b8>
800097f8:	2f 83       	sub	r3,-8
800097fa:	c0 b8       	rjmp	80009810 <_vfprintf_r+0x19cc>
800097fc:	fa ca f9 78 	sub	r10,sp,-1672
80009800:	02 9b       	mov	r11,r1
80009802:	08 9c       	mov	r12,r4
80009804:	fe b0 f3 12 	rcall	80007e28 <__sprint_r>
80009808:	e0 81 02 9d 	brne	80009d42 <_vfprintf_r+0x1efe>
8000980c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009810:	21 06       	sub	r6,16
80009812:	c0 48       	rjmp	8000981a <_vfprintf_r+0x19d6>
80009814:	fe c2 ba 88 	sub	r2,pc,-17784
80009818:	31 00       	mov	r0,16
8000981a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000981e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009822:	fe ca ba 96 	sub	r10,pc,-17770
80009826:	59 06       	cp.w	r6,16
80009828:	fe 99 ff dd 	brgt	800097e2 <_vfprintf_r+0x199e>
8000982c:	0c 09       	add	r9,r6
8000982e:	87 0a       	st.w	r3[0x0],r10
80009830:	fb 49 06 90 	st.w	sp[1680],r9
80009834:	2f f8       	sub	r8,-1
80009836:	87 16       	st.w	r3[0x4],r6
80009838:	c5 39       	rjmp	80009ade <_vfprintf_r+0x1c9a>
8000983a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000983e:	58 0a       	cp.w	r10,0
80009840:	e0 89 00 92 	brgt	80009964 <_vfprintf_r+0x1b20>
80009844:	fa f8 06 90 	ld.w	r8,sp[1680]
80009848:	fe c9 ba d0 	sub	r9,pc,-17712
8000984c:	2f f8       	sub	r8,-1
8000984e:	87 09       	st.w	r3[0x0],r9
80009850:	fb 48 06 90 	st.w	sp[1680],r8
80009854:	30 19       	mov	r9,1
80009856:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000985a:	87 19       	st.w	r3[0x4],r9
8000985c:	2f f8       	sub	r8,-1
8000985e:	fb 48 06 8c 	st.w	sp[1676],r8
80009862:	58 78       	cp.w	r8,7
80009864:	e0 89 00 04 	brgt	8000986c <_vfprintf_r+0x1a28>
80009868:	2f 83       	sub	r3,-8
8000986a:	c0 b8       	rjmp	80009880 <_vfprintf_r+0x1a3c>
8000986c:	fa ca f9 78 	sub	r10,sp,-1672
80009870:	02 9b       	mov	r11,r1
80009872:	08 9c       	mov	r12,r4
80009874:	fe b0 f2 da 	rcall	80007e28 <__sprint_r>
80009878:	e0 81 02 65 	brne	80009d42 <_vfprintf_r+0x1efe>
8000987c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009880:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009884:	58 08       	cp.w	r8,0
80009886:	c0 81       	brne	80009896 <_vfprintf_r+0x1a52>
80009888:	40 6a       	lddsp	r10,sp[0x18]
8000988a:	58 0a       	cp.w	r10,0
8000988c:	c0 51       	brne	80009896 <_vfprintf_r+0x1a52>
8000988e:	ed b5 00 00 	bld	r5,0x0
80009892:	e0 81 01 ed 	brne	80009c6c <_vfprintf_r+0x1e28>
80009896:	40 c9       	lddsp	r9,sp[0x30]
80009898:	fa f8 06 90 	ld.w	r8,sp[1680]
8000989c:	2f f8       	sub	r8,-1
8000989e:	87 09       	st.w	r3[0x0],r9
800098a0:	fb 48 06 90 	st.w	sp[1680],r8
800098a4:	30 19       	mov	r9,1
800098a6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098aa:	87 19       	st.w	r3[0x4],r9
800098ac:	2f f8       	sub	r8,-1
800098ae:	fb 48 06 8c 	st.w	sp[1676],r8
800098b2:	58 78       	cp.w	r8,7
800098b4:	e0 89 00 04 	brgt	800098bc <_vfprintf_r+0x1a78>
800098b8:	2f 83       	sub	r3,-8
800098ba:	c0 b8       	rjmp	800098d0 <_vfprintf_r+0x1a8c>
800098bc:	fa ca f9 78 	sub	r10,sp,-1672
800098c0:	02 9b       	mov	r11,r1
800098c2:	08 9c       	mov	r12,r4
800098c4:	fe b0 f2 b2 	rcall	80007e28 <__sprint_r>
800098c8:	e0 81 02 3d 	brne	80009d42 <_vfprintf_r+0x1efe>
800098cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800098d4:	5c 32       	neg	r2
800098d6:	58 02       	cp.w	r2,0
800098d8:	e0 89 00 1d 	brgt	80009912 <_vfprintf_r+0x1ace>
800098dc:	c3 d8       	rjmp	80009956 <_vfprintf_r+0x1b12>
800098de:	2f 09       	sub	r9,-16
800098e0:	2f f8       	sub	r8,-1
800098e2:	31 0e       	mov	lr,16
800098e4:	fb 49 06 90 	st.w	sp[1680],r9
800098e8:	87 00       	st.w	r3[0x0],r0
800098ea:	87 1e       	st.w	r3[0x4],lr
800098ec:	fb 48 06 8c 	st.w	sp[1676],r8
800098f0:	58 78       	cp.w	r8,7
800098f2:	e0 89 00 04 	brgt	800098fa <_vfprintf_r+0x1ab6>
800098f6:	2f 83       	sub	r3,-8
800098f8:	c0 b8       	rjmp	8000990e <_vfprintf_r+0x1aca>
800098fa:	fa ca f9 78 	sub	r10,sp,-1672
800098fe:	02 9b       	mov	r11,r1
80009900:	08 9c       	mov	r12,r4
80009902:	fe b0 f2 93 	rcall	80007e28 <__sprint_r>
80009906:	e0 81 02 1e 	brne	80009d42 <_vfprintf_r+0x1efe>
8000990a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000990e:	21 02       	sub	r2,16
80009910:	c0 38       	rjmp	80009916 <_vfprintf_r+0x1ad2>
80009912:	fe c0 bb 86 	sub	r0,pc,-17530
80009916:	fa f9 06 90 	ld.w	r9,sp[1680]
8000991a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000991e:	fe ca bb 92 	sub	r10,pc,-17518
80009922:	59 02       	cp.w	r2,16
80009924:	fe 99 ff dd 	brgt	800098de <_vfprintf_r+0x1a9a>
80009928:	04 09       	add	r9,r2
8000992a:	2f f8       	sub	r8,-1
8000992c:	87 0a       	st.w	r3[0x0],r10
8000992e:	fb 49 06 90 	st.w	sp[1680],r9
80009932:	87 12       	st.w	r3[0x4],r2
80009934:	fb 48 06 8c 	st.w	sp[1676],r8
80009938:	58 78       	cp.w	r8,7
8000993a:	e0 89 00 04 	brgt	80009942 <_vfprintf_r+0x1afe>
8000993e:	2f 83       	sub	r3,-8
80009940:	c0 b8       	rjmp	80009956 <_vfprintf_r+0x1b12>
80009942:	fa ca f9 78 	sub	r10,sp,-1672
80009946:	02 9b       	mov	r11,r1
80009948:	08 9c       	mov	r12,r4
8000994a:	fe b0 f2 6f 	rcall	80007e28 <__sprint_r>
8000994e:	e0 81 01 fa 	brne	80009d42 <_vfprintf_r+0x1efe>
80009952:	fa c3 f9 e0 	sub	r3,sp,-1568
80009956:	40 6c       	lddsp	r12,sp[0x18]
80009958:	fa f8 06 90 	ld.w	r8,sp[1680]
8000995c:	87 06       	st.w	r3[0x0],r6
8000995e:	87 1c       	st.w	r3[0x4],r12
80009960:	18 08       	add	r8,r12
80009962:	cb 98       	rjmp	80009ad4 <_vfprintf_r+0x1c90>
80009964:	fa f9 06 90 	ld.w	r9,sp[1680]
80009968:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000996c:	40 6b       	lddsp	r11,sp[0x18]
8000996e:	16 3a       	cp.w	r10,r11
80009970:	c6 f5       	brlt	80009a4e <_vfprintf_r+0x1c0a>
80009972:	16 09       	add	r9,r11
80009974:	2f f8       	sub	r8,-1
80009976:	87 06       	st.w	r3[0x0],r6
80009978:	fb 49 06 90 	st.w	sp[1680],r9
8000997c:	87 1b       	st.w	r3[0x4],r11
8000997e:	fb 48 06 8c 	st.w	sp[1676],r8
80009982:	58 78       	cp.w	r8,7
80009984:	e0 89 00 04 	brgt	8000998c <_vfprintf_r+0x1b48>
80009988:	2f 83       	sub	r3,-8
8000998a:	c0 b8       	rjmp	800099a0 <_vfprintf_r+0x1b5c>
8000998c:	fa ca f9 78 	sub	r10,sp,-1672
80009990:	02 9b       	mov	r11,r1
80009992:	08 9c       	mov	r12,r4
80009994:	fe b0 f2 4a 	rcall	80007e28 <__sprint_r>
80009998:	e0 81 01 d5 	brne	80009d42 <_vfprintf_r+0x1efe>
8000999c:	fa c3 f9 e0 	sub	r3,sp,-1568
800099a0:	fa f6 06 ac 	ld.w	r6,sp[1708]
800099a4:	40 6a       	lddsp	r10,sp[0x18]
800099a6:	14 16       	sub	r6,r10
800099a8:	58 06       	cp.w	r6,0
800099aa:	e0 89 00 1c 	brgt	800099e2 <_vfprintf_r+0x1b9e>
800099ae:	c3 d8       	rjmp	80009a28 <_vfprintf_r+0x1be4>
800099b0:	2f 09       	sub	r9,-16
800099b2:	2f f8       	sub	r8,-1
800099b4:	fb 49 06 90 	st.w	sp[1680],r9
800099b8:	87 02       	st.w	r3[0x0],r2
800099ba:	87 10       	st.w	r3[0x4],r0
800099bc:	fb 48 06 8c 	st.w	sp[1676],r8
800099c0:	58 78       	cp.w	r8,7
800099c2:	e0 89 00 04 	brgt	800099ca <_vfprintf_r+0x1b86>
800099c6:	2f 83       	sub	r3,-8
800099c8:	c0 b8       	rjmp	800099de <_vfprintf_r+0x1b9a>
800099ca:	fa ca f9 78 	sub	r10,sp,-1672
800099ce:	02 9b       	mov	r11,r1
800099d0:	08 9c       	mov	r12,r4
800099d2:	fe b0 f2 2b 	rcall	80007e28 <__sprint_r>
800099d6:	e0 81 01 b6 	brne	80009d42 <_vfprintf_r+0x1efe>
800099da:	fa c3 f9 e0 	sub	r3,sp,-1568
800099de:	21 06       	sub	r6,16
800099e0:	c0 48       	rjmp	800099e8 <_vfprintf_r+0x1ba4>
800099e2:	fe c2 bc 56 	sub	r2,pc,-17322
800099e6:	31 00       	mov	r0,16
800099e8:	fa f9 06 90 	ld.w	r9,sp[1680]
800099ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099f0:	fe ca bc 64 	sub	r10,pc,-17308
800099f4:	59 06       	cp.w	r6,16
800099f6:	fe 99 ff dd 	brgt	800099b0 <_vfprintf_r+0x1b6c>
800099fa:	0c 09       	add	r9,r6
800099fc:	2f f8       	sub	r8,-1
800099fe:	87 0a       	st.w	r3[0x0],r10
80009a00:	fb 49 06 90 	st.w	sp[1680],r9
80009a04:	87 16       	st.w	r3[0x4],r6
80009a06:	fb 48 06 8c 	st.w	sp[1676],r8
80009a0a:	58 78       	cp.w	r8,7
80009a0c:	e0 89 00 04 	brgt	80009a14 <_vfprintf_r+0x1bd0>
80009a10:	2f 83       	sub	r3,-8
80009a12:	c0 b8       	rjmp	80009a28 <_vfprintf_r+0x1be4>
80009a14:	fa ca f9 78 	sub	r10,sp,-1672
80009a18:	02 9b       	mov	r11,r1
80009a1a:	08 9c       	mov	r12,r4
80009a1c:	fe b0 f2 06 	rcall	80007e28 <__sprint_r>
80009a20:	e0 81 01 91 	brne	80009d42 <_vfprintf_r+0x1efe>
80009a24:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a28:	ed b5 00 00 	bld	r5,0x0
80009a2c:	e0 81 01 20 	brne	80009c6c <_vfprintf_r+0x1e28>
80009a30:	40 c9       	lddsp	r9,sp[0x30]
80009a32:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a36:	2f f8       	sub	r8,-1
80009a38:	87 09       	st.w	r3[0x0],r9
80009a3a:	fb 48 06 90 	st.w	sp[1680],r8
80009a3e:	30 19       	mov	r9,1
80009a40:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a44:	87 19       	st.w	r3[0x4],r9
80009a46:	2f f8       	sub	r8,-1
80009a48:	fb 48 06 8c 	st.w	sp[1676],r8
80009a4c:	c0 29       	rjmp	80009c50 <_vfprintf_r+0x1e0c>
80009a4e:	14 09       	add	r9,r10
80009a50:	2f f8       	sub	r8,-1
80009a52:	fb 49 06 90 	st.w	sp[1680],r9
80009a56:	87 06       	st.w	r3[0x0],r6
80009a58:	87 1a       	st.w	r3[0x4],r10
80009a5a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a5e:	58 78       	cp.w	r8,7
80009a60:	e0 89 00 04 	brgt	80009a68 <_vfprintf_r+0x1c24>
80009a64:	2f 83       	sub	r3,-8
80009a66:	c0 b8       	rjmp	80009a7c <_vfprintf_r+0x1c38>
80009a68:	fa ca f9 78 	sub	r10,sp,-1672
80009a6c:	02 9b       	mov	r11,r1
80009a6e:	08 9c       	mov	r12,r4
80009a70:	fe b0 f1 dc 	rcall	80007e28 <__sprint_r>
80009a74:	e0 81 01 67 	brne	80009d42 <_vfprintf_r+0x1efe>
80009a78:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a7c:	40 c8       	lddsp	r8,sp[0x30]
80009a7e:	87 08       	st.w	r3[0x0],r8
80009a80:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a84:	2f f8       	sub	r8,-1
80009a86:	30 19       	mov	r9,1
80009a88:	fb 48 06 90 	st.w	sp[1680],r8
80009a8c:	87 19       	st.w	r3[0x4],r9
80009a8e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a92:	2f f8       	sub	r8,-1
80009a94:	fb 48 06 8c 	st.w	sp[1676],r8
80009a98:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009a9c:	58 78       	cp.w	r8,7
80009a9e:	e0 89 00 04 	brgt	80009aa6 <_vfprintf_r+0x1c62>
80009aa2:	2f 83       	sub	r3,-8
80009aa4:	c0 b8       	rjmp	80009aba <_vfprintf_r+0x1c76>
80009aa6:	fa ca f9 78 	sub	r10,sp,-1672
80009aaa:	02 9b       	mov	r11,r1
80009aac:	08 9c       	mov	r12,r4
80009aae:	fe b0 f1 bd 	rcall	80007e28 <__sprint_r>
80009ab2:	e0 81 01 48 	brne	80009d42 <_vfprintf_r+0x1efe>
80009ab6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aba:	04 06       	add	r6,r2
80009abc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ac0:	87 06       	st.w	r3[0x0],r6
80009ac2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ac6:	40 66       	lddsp	r6,sp[0x18]
80009ac8:	40 6e       	lddsp	lr,sp[0x18]
80009aca:	10 16       	sub	r6,r8
80009acc:	f2 08 01 08 	sub	r8,r9,r8
80009ad0:	87 16       	st.w	r3[0x4],r6
80009ad2:	1c 08       	add	r8,lr
80009ad4:	fb 48 06 90 	st.w	sp[1680],r8
80009ad8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009adc:	2f f8       	sub	r8,-1
80009ade:	fb 48 06 8c 	st.w	sp[1676],r8
80009ae2:	cb 78       	rjmp	80009c50 <_vfprintf_r+0x1e0c>
80009ae4:	40 6c       	lddsp	r12,sp[0x18]
80009ae6:	58 1c       	cp.w	r12,1
80009ae8:	e0 89 00 06 	brgt	80009af4 <_vfprintf_r+0x1cb0>
80009aec:	ed b5 00 00 	bld	r5,0x0
80009af0:	e0 81 00 85 	brne	80009bfa <_vfprintf_r+0x1db6>
80009af4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009af8:	2f f8       	sub	r8,-1
80009afa:	30 19       	mov	r9,1
80009afc:	fb 48 06 90 	st.w	sp[1680],r8
80009b00:	87 06       	st.w	r3[0x0],r6
80009b02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b06:	87 19       	st.w	r3[0x4],r9
80009b08:	2f f8       	sub	r8,-1
80009b0a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b0e:	58 78       	cp.w	r8,7
80009b10:	e0 89 00 04 	brgt	80009b18 <_vfprintf_r+0x1cd4>
80009b14:	2f 83       	sub	r3,-8
80009b16:	c0 b8       	rjmp	80009b2c <_vfprintf_r+0x1ce8>
80009b18:	fa ca f9 78 	sub	r10,sp,-1672
80009b1c:	02 9b       	mov	r11,r1
80009b1e:	08 9c       	mov	r12,r4
80009b20:	fe b0 f1 84 	rcall	80007e28 <__sprint_r>
80009b24:	e0 81 01 0f 	brne	80009d42 <_vfprintf_r+0x1efe>
80009b28:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b2c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b30:	2f f8       	sub	r8,-1
80009b32:	40 cb       	lddsp	r11,sp[0x30]
80009b34:	fb 48 06 90 	st.w	sp[1680],r8
80009b38:	30 19       	mov	r9,1
80009b3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b3e:	87 0b       	st.w	r3[0x0],r11
80009b40:	2f f8       	sub	r8,-1
80009b42:	87 19       	st.w	r3[0x4],r9
80009b44:	fb 48 06 8c 	st.w	sp[1676],r8
80009b48:	58 78       	cp.w	r8,7
80009b4a:	e0 89 00 05 	brgt	80009b54 <_vfprintf_r+0x1d10>
80009b4e:	2f 83       	sub	r3,-8
80009b50:	c0 c8       	rjmp	80009b68 <_vfprintf_r+0x1d24>
80009b52:	d7 03       	nop
80009b54:	fa ca f9 78 	sub	r10,sp,-1672
80009b58:	02 9b       	mov	r11,r1
80009b5a:	08 9c       	mov	r12,r4
80009b5c:	fe b0 f1 66 	rcall	80007e28 <__sprint_r>
80009b60:	e0 81 00 f1 	brne	80009d42 <_vfprintf_r+0x1efe>
80009b64:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b68:	30 08       	mov	r8,0
80009b6a:	30 09       	mov	r9,0
80009b6c:	40 5b       	lddsp	r11,sp[0x14]
80009b6e:	40 7a       	lddsp	r10,sp[0x1c]
80009b70:	e0 a0 13 25 	rcall	8000c1ba <__avr32_f64_cmp_eq>
80009b74:	40 68       	lddsp	r8,sp[0x18]
80009b76:	20 18       	sub	r8,1
80009b78:	58 0c       	cp.w	r12,0
80009b7a:	c0 d1       	brne	80009b94 <_vfprintf_r+0x1d50>
80009b7c:	2f f6       	sub	r6,-1
80009b7e:	87 18       	st.w	r3[0x4],r8
80009b80:	87 06       	st.w	r3[0x0],r6
80009b82:	fa f6 06 90 	ld.w	r6,sp[1680]
80009b86:	10 06       	add	r6,r8
80009b88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b8c:	fb 46 06 90 	st.w	sp[1680],r6
80009b90:	2f f8       	sub	r8,-1
80009b92:	c3 18       	rjmp	80009bf4 <_vfprintf_r+0x1db0>
80009b94:	10 96       	mov	r6,r8
80009b96:	58 08       	cp.w	r8,0
80009b98:	e0 89 00 1c 	brgt	80009bd0 <_vfprintf_r+0x1d8c>
80009b9c:	c4 b8       	rjmp	80009c32 <_vfprintf_r+0x1dee>
80009b9e:	2f 09       	sub	r9,-16
80009ba0:	2f f8       	sub	r8,-1
80009ba2:	fb 49 06 90 	st.w	sp[1680],r9
80009ba6:	87 02       	st.w	r3[0x0],r2
80009ba8:	87 10       	st.w	r3[0x4],r0
80009baa:	fb 48 06 8c 	st.w	sp[1676],r8
80009bae:	58 78       	cp.w	r8,7
80009bb0:	e0 89 00 04 	brgt	80009bb8 <_vfprintf_r+0x1d74>
80009bb4:	2f 83       	sub	r3,-8
80009bb6:	c0 b8       	rjmp	80009bcc <_vfprintf_r+0x1d88>
80009bb8:	fa ca f9 78 	sub	r10,sp,-1672
80009bbc:	02 9b       	mov	r11,r1
80009bbe:	08 9c       	mov	r12,r4
80009bc0:	fe b0 f1 34 	rcall	80007e28 <__sprint_r>
80009bc4:	e0 81 00 bf 	brne	80009d42 <_vfprintf_r+0x1efe>
80009bc8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bcc:	21 06       	sub	r6,16
80009bce:	c0 48       	rjmp	80009bd6 <_vfprintf_r+0x1d92>
80009bd0:	fe c2 be 44 	sub	r2,pc,-16828
80009bd4:	31 00       	mov	r0,16
80009bd6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bda:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bde:	fe ca be 52 	sub	r10,pc,-16814
80009be2:	59 06       	cp.w	r6,16
80009be4:	fe 99 ff dd 	brgt	80009b9e <_vfprintf_r+0x1d5a>
80009be8:	0c 09       	add	r9,r6
80009bea:	87 0a       	st.w	r3[0x0],r10
80009bec:	fb 49 06 90 	st.w	sp[1680],r9
80009bf0:	2f f8       	sub	r8,-1
80009bf2:	87 16       	st.w	r3[0x4],r6
80009bf4:	fb 48 06 8c 	st.w	sp[1676],r8
80009bf8:	c0 e8       	rjmp	80009c14 <_vfprintf_r+0x1dd0>
80009bfa:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bfe:	2f f8       	sub	r8,-1
80009c00:	30 19       	mov	r9,1
80009c02:	fb 48 06 90 	st.w	sp[1680],r8
80009c06:	87 06       	st.w	r3[0x0],r6
80009c08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c0c:	87 19       	st.w	r3[0x4],r9
80009c0e:	2f f8       	sub	r8,-1
80009c10:	fb 48 06 8c 	st.w	sp[1676],r8
80009c14:	58 78       	cp.w	r8,7
80009c16:	e0 89 00 04 	brgt	80009c1e <_vfprintf_r+0x1dda>
80009c1a:	2f 83       	sub	r3,-8
80009c1c:	c0 b8       	rjmp	80009c32 <_vfprintf_r+0x1dee>
80009c1e:	fa ca f9 78 	sub	r10,sp,-1672
80009c22:	02 9b       	mov	r11,r1
80009c24:	08 9c       	mov	r12,r4
80009c26:	fe b0 f1 01 	rcall	80007e28 <__sprint_r>
80009c2a:	e0 81 00 8c 	brne	80009d42 <_vfprintf_r+0x1efe>
80009c2e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c32:	40 ea       	lddsp	r10,sp[0x38]
80009c34:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c38:	14 08       	add	r8,r10
80009c3a:	fa c9 f9 64 	sub	r9,sp,-1692
80009c3e:	fb 48 06 90 	st.w	sp[1680],r8
80009c42:	87 1a       	st.w	r3[0x4],r10
80009c44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c48:	87 09       	st.w	r3[0x0],r9
80009c4a:	2f f8       	sub	r8,-1
80009c4c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c50:	58 78       	cp.w	r8,7
80009c52:	e0 89 00 04 	brgt	80009c5a <_vfprintf_r+0x1e16>
80009c56:	2f 83       	sub	r3,-8
80009c58:	c0 a8       	rjmp	80009c6c <_vfprintf_r+0x1e28>
80009c5a:	fa ca f9 78 	sub	r10,sp,-1672
80009c5e:	02 9b       	mov	r11,r1
80009c60:	08 9c       	mov	r12,r4
80009c62:	fe b0 f0 e3 	rcall	80007e28 <__sprint_r>
80009c66:	c6 e1       	brne	80009d42 <_vfprintf_r+0x1efe>
80009c68:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c6c:	e2 15 00 04 	andl	r5,0x4,COH
80009c70:	c3 f0       	breq	80009cee <_vfprintf_r+0x1eaa>
80009c72:	40 86       	lddsp	r6,sp[0x20]
80009c74:	40 39       	lddsp	r9,sp[0xc]
80009c76:	12 16       	sub	r6,r9
80009c78:	58 06       	cp.w	r6,0
80009c7a:	e0 89 00 1a 	brgt	80009cae <_vfprintf_r+0x1e6a>
80009c7e:	c3 88       	rjmp	80009cee <_vfprintf_r+0x1eaa>
80009c80:	2f 09       	sub	r9,-16
80009c82:	2f f8       	sub	r8,-1
80009c84:	fb 49 06 90 	st.w	sp[1680],r9
80009c88:	87 05       	st.w	r3[0x0],r5
80009c8a:	87 12       	st.w	r3[0x4],r2
80009c8c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c90:	58 78       	cp.w	r8,7
80009c92:	e0 89 00 04 	brgt	80009c9a <_vfprintf_r+0x1e56>
80009c96:	2f 83       	sub	r3,-8
80009c98:	c0 98       	rjmp	80009caa <_vfprintf_r+0x1e66>
80009c9a:	00 9a       	mov	r10,r0
80009c9c:	02 9b       	mov	r11,r1
80009c9e:	08 9c       	mov	r12,r4
80009ca0:	fe b0 f0 c4 	rcall	80007e28 <__sprint_r>
80009ca4:	c4 f1       	brne	80009d42 <_vfprintf_r+0x1efe>
80009ca6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009caa:	21 06       	sub	r6,16
80009cac:	c0 68       	rjmp	80009cb8 <_vfprintf_r+0x1e74>
80009cae:	fe c5 bf 32 	sub	r5,pc,-16590
80009cb2:	31 02       	mov	r2,16
80009cb4:	fa c0 f9 78 	sub	r0,sp,-1672
80009cb8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009cbc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cc0:	fe ca bf 44 	sub	r10,pc,-16572
80009cc4:	59 06       	cp.w	r6,16
80009cc6:	fe 99 ff dd 	brgt	80009c80 <_vfprintf_r+0x1e3c>
80009cca:	0c 09       	add	r9,r6
80009ccc:	2f f8       	sub	r8,-1
80009cce:	87 0a       	st.w	r3[0x0],r10
80009cd0:	87 16       	st.w	r3[0x4],r6
80009cd2:	fb 49 06 90 	st.w	sp[1680],r9
80009cd6:	fb 48 06 8c 	st.w	sp[1676],r8
80009cda:	58 78       	cp.w	r8,7
80009cdc:	e0 8a 00 09 	brle	80009cee <_vfprintf_r+0x1eaa>
80009ce0:	fa ca f9 78 	sub	r10,sp,-1672
80009ce4:	02 9b       	mov	r11,r1
80009ce6:	08 9c       	mov	r12,r4
80009ce8:	fe b0 f0 a0 	rcall	80007e28 <__sprint_r>
80009cec:	c2 b1       	brne	80009d42 <_vfprintf_r+0x1efe>
80009cee:	40 bc       	lddsp	r12,sp[0x2c]
80009cf0:	40 36       	lddsp	r6,sp[0xc]
80009cf2:	40 8e       	lddsp	lr,sp[0x20]
80009cf4:	ec 0e 0c 48 	max	r8,r6,lr
80009cf8:	10 0c       	add	r12,r8
80009cfa:	50 bc       	stdsp	sp[0x2c],r12
80009cfc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d00:	58 08       	cp.w	r8,0
80009d02:	c0 80       	breq	80009d12 <_vfprintf_r+0x1ece>
80009d04:	fa ca f9 78 	sub	r10,sp,-1672
80009d08:	02 9b       	mov	r11,r1
80009d0a:	08 9c       	mov	r12,r4
80009d0c:	fe b0 f0 8e 	rcall	80007e28 <__sprint_r>
80009d10:	c1 91       	brne	80009d42 <_vfprintf_r+0x1efe>
80009d12:	30 0b       	mov	r11,0
80009d14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d18:	fb 4b 06 8c 	st.w	sp[1676],r11
80009d1c:	fe 9f f1 22 	bral	80007f60 <_vfprintf_r+0x11c>
80009d20:	08 95       	mov	r5,r4
80009d22:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d26:	58 08       	cp.w	r8,0
80009d28:	c0 80       	breq	80009d38 <_vfprintf_r+0x1ef4>
80009d2a:	08 9c       	mov	r12,r4
80009d2c:	fa ca f9 78 	sub	r10,sp,-1672
80009d30:	02 9b       	mov	r11,r1
80009d32:	fe b0 f0 7b 	rcall	80007e28 <__sprint_r>
80009d36:	c0 61       	brne	80009d42 <_vfprintf_r+0x1efe>
80009d38:	30 08       	mov	r8,0
80009d3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009d3e:	c0 28       	rjmp	80009d42 <_vfprintf_r+0x1efe>
80009d40:	40 41       	lddsp	r1,sp[0x10]
80009d42:	82 68       	ld.sh	r8,r1[0xc]
80009d44:	ed b8 00 06 	bld	r8,0x6
80009d48:	c0 31       	brne	80009d4e <_vfprintf_r+0x1f0a>
80009d4a:	3f fa       	mov	r10,-1
80009d4c:	50 ba       	stdsp	sp[0x2c],r10
80009d4e:	40 bc       	lddsp	r12,sp[0x2c]
80009d50:	fe 3d f9 44 	sub	sp,-1724
80009d54:	d8 32       	popm	r0-r7,pc
80009d56:	d7 03       	nop

80009d58 <__swsetup_r>:
80009d58:	d4 21       	pushm	r4-r7,lr
80009d5a:	e0 68 0a 3c 	mov	r8,2620
80009d5e:	18 96       	mov	r6,r12
80009d60:	16 97       	mov	r7,r11
80009d62:	70 0c       	ld.w	r12,r8[0x0]
80009d64:	58 0c       	cp.w	r12,0
80009d66:	c0 60       	breq	80009d72 <__swsetup_r+0x1a>
80009d68:	78 68       	ld.w	r8,r12[0x18]
80009d6a:	58 08       	cp.w	r8,0
80009d6c:	c0 31       	brne	80009d72 <__swsetup_r+0x1a>
80009d6e:	e0 a0 07 bf 	rcall	8000acec <__sinit>
80009d72:	fe c8 be c6 	sub	r8,pc,-16698
80009d76:	10 37       	cp.w	r7,r8
80009d78:	c0 61       	brne	80009d84 <__swsetup_r+0x2c>
80009d7a:	e0 68 0a 3c 	mov	r8,2620
80009d7e:	70 08       	ld.w	r8,r8[0x0]
80009d80:	70 07       	ld.w	r7,r8[0x0]
80009d82:	c1 28       	rjmp	80009da6 <__swsetup_r+0x4e>
80009d84:	fe c8 be b8 	sub	r8,pc,-16712
80009d88:	10 37       	cp.w	r7,r8
80009d8a:	c0 61       	brne	80009d96 <__swsetup_r+0x3e>
80009d8c:	e0 68 0a 3c 	mov	r8,2620
80009d90:	70 08       	ld.w	r8,r8[0x0]
80009d92:	70 17       	ld.w	r7,r8[0x4]
80009d94:	c0 98       	rjmp	80009da6 <__swsetup_r+0x4e>
80009d96:	fe c8 be aa 	sub	r8,pc,-16726
80009d9a:	10 37       	cp.w	r7,r8
80009d9c:	c0 51       	brne	80009da6 <__swsetup_r+0x4e>
80009d9e:	e0 68 0a 3c 	mov	r8,2620
80009da2:	70 08       	ld.w	r8,r8[0x0]
80009da4:	70 27       	ld.w	r7,r8[0x8]
80009da6:	8e 68       	ld.sh	r8,r7[0xc]
80009da8:	ed b8 00 03 	bld	r8,0x3
80009dac:	c1 e0       	breq	80009de8 <__swsetup_r+0x90>
80009dae:	ed b8 00 04 	bld	r8,0x4
80009db2:	c3 e1       	brne	80009e2e <__swsetup_r+0xd6>
80009db4:	ed b8 00 02 	bld	r8,0x2
80009db8:	c1 51       	brne	80009de2 <__swsetup_r+0x8a>
80009dba:	6e db       	ld.w	r11,r7[0x34]
80009dbc:	58 0b       	cp.w	r11,0
80009dbe:	c0 a0       	breq	80009dd2 <__swsetup_r+0x7a>
80009dc0:	ee c8 ff bc 	sub	r8,r7,-68
80009dc4:	10 3b       	cp.w	r11,r8
80009dc6:	c0 40       	breq	80009dce <__swsetup_r+0x76>
80009dc8:	0c 9c       	mov	r12,r6
80009dca:	e0 a0 08 2b 	rcall	8000ae20 <_free_r>
80009dce:	30 08       	mov	r8,0
80009dd0:	8f d8       	st.w	r7[0x34],r8
80009dd2:	8e 68       	ld.sh	r8,r7[0xc]
80009dd4:	e0 18 ff db 	andl	r8,0xffdb
80009dd8:	ae 68       	st.h	r7[0xc],r8
80009dda:	30 08       	mov	r8,0
80009ddc:	8f 18       	st.w	r7[0x4],r8
80009dde:	6e 48       	ld.w	r8,r7[0x10]
80009de0:	8f 08       	st.w	r7[0x0],r8
80009de2:	8e 68       	ld.sh	r8,r7[0xc]
80009de4:	a3 b8       	sbr	r8,0x3
80009de6:	ae 68       	st.h	r7[0xc],r8
80009de8:	6e 48       	ld.w	r8,r7[0x10]
80009dea:	58 08       	cp.w	r8,0
80009dec:	c0 b1       	brne	80009e02 <__swsetup_r+0xaa>
80009dee:	8e 68       	ld.sh	r8,r7[0xc]
80009df0:	e2 18 02 80 	andl	r8,0x280,COH
80009df4:	e0 48 02 00 	cp.w	r8,512
80009df8:	c0 50       	breq	80009e02 <__swsetup_r+0xaa>
80009dfa:	0c 9c       	mov	r12,r6
80009dfc:	0e 9b       	mov	r11,r7
80009dfe:	e0 a0 0a 4b 	rcall	8000b294 <__smakebuf_r>
80009e02:	8e 69       	ld.sh	r9,r7[0xc]
80009e04:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009e08:	c0 70       	breq	80009e16 <__swsetup_r+0xbe>
80009e0a:	30 08       	mov	r8,0
80009e0c:	8f 28       	st.w	r7[0x8],r8
80009e0e:	6e 58       	ld.w	r8,r7[0x14]
80009e10:	5c 38       	neg	r8
80009e12:	8f 68       	st.w	r7[0x18],r8
80009e14:	c0 68       	rjmp	80009e20 <__swsetup_r+0xc8>
80009e16:	ed b9 00 01 	bld	r9,0x1
80009e1a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009e1e:	8f 28       	st.w	r7[0x8],r8
80009e20:	6e 48       	ld.w	r8,r7[0x10]
80009e22:	58 08       	cp.w	r8,0
80009e24:	c0 61       	brne	80009e30 <__swsetup_r+0xd8>
80009e26:	8e 68       	ld.sh	r8,r7[0xc]
80009e28:	ed b8 00 07 	bld	r8,0x7
80009e2c:	c0 21       	brne	80009e30 <__swsetup_r+0xd8>
80009e2e:	dc 2a       	popm	r4-r7,pc,r12=-1
80009e30:	d8 2a       	popm	r4-r7,pc,r12=0
80009e32:	d7 03       	nop

80009e34 <quorem>:
80009e34:	d4 31       	pushm	r0-r7,lr
80009e36:	20 2d       	sub	sp,8
80009e38:	18 97       	mov	r7,r12
80009e3a:	78 48       	ld.w	r8,r12[0x10]
80009e3c:	76 46       	ld.w	r6,r11[0x10]
80009e3e:	0c 38       	cp.w	r8,r6
80009e40:	c0 34       	brge	80009e46 <quorem+0x12>
80009e42:	30 0c       	mov	r12,0
80009e44:	c8 58       	rjmp	80009f4e <quorem+0x11a>
80009e46:	ec c2 ff fc 	sub	r2,r6,-4
80009e4a:	f6 c3 ff ec 	sub	r3,r11,-20
80009e4e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009e52:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009e56:	2f f9       	sub	r9,-1
80009e58:	20 16       	sub	r6,1
80009e5a:	f8 09 0d 08 	divu	r8,r12,r9
80009e5e:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009e62:	ee c4 ff ec 	sub	r4,r7,-20
80009e66:	10 95       	mov	r5,r8
80009e68:	58 08       	cp.w	r8,0
80009e6a:	c4 10       	breq	80009eec <quorem+0xb8>
80009e6c:	30 09       	mov	r9,0
80009e6e:	06 9a       	mov	r10,r3
80009e70:	08 98       	mov	r8,r4
80009e72:	12 91       	mov	r1,r9
80009e74:	50 0b       	stdsp	sp[0x0],r11
80009e76:	70 0e       	ld.w	lr,r8[0x0]
80009e78:	b1 8e       	lsr	lr,0x10
80009e7a:	50 1e       	stdsp	sp[0x4],lr
80009e7c:	15 0e       	ld.w	lr,r10++
80009e7e:	fc 00 16 10 	lsr	r0,lr,0x10
80009e82:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009e86:	ea 0e 03 41 	mac	r1,r5,lr
80009e8a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009e8e:	b1 81       	lsr	r1,0x10
80009e90:	40 1b       	lddsp	r11,sp[0x4]
80009e92:	ea 00 02 40 	mul	r0,r5,r0
80009e96:	e2 00 00 00 	add	r0,r1,r0
80009e9a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009e9e:	02 1b       	sub	r11,r1
80009ea0:	50 1b       	stdsp	sp[0x4],r11
80009ea2:	70 0b       	ld.w	r11,r8[0x0]
80009ea4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009ea8:	02 09       	add	r9,r1
80009eaa:	f2 0e 01 0e 	sub	lr,r9,lr
80009eae:	b0 1e       	st.h	r8[0x2],lr
80009eb0:	fc 09 14 10 	asr	r9,lr,0x10
80009eb4:	40 1e       	lddsp	lr,sp[0x4]
80009eb6:	fc 09 00 09 	add	r9,lr,r9
80009eba:	b0 09       	st.h	r8[0x0],r9
80009ebc:	e0 01 16 10 	lsr	r1,r0,0x10
80009ec0:	2f c8       	sub	r8,-4
80009ec2:	b1 49       	asr	r9,0x10
80009ec4:	04 3a       	cp.w	r10,r2
80009ec6:	fe 98 ff d8 	brls	80009e76 <quorem+0x42>
80009eca:	40 0b       	lddsp	r11,sp[0x0]
80009ecc:	58 0c       	cp.w	r12,0
80009ece:	c0 f1       	brne	80009eec <quorem+0xb8>
80009ed0:	ec c8 ff fb 	sub	r8,r6,-5
80009ed4:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009ed8:	c0 28       	rjmp	80009edc <quorem+0xa8>
80009eda:	20 16       	sub	r6,1
80009edc:	20 48       	sub	r8,4
80009ede:	08 38       	cp.w	r8,r4
80009ee0:	e0 88 00 05 	brls	80009eea <quorem+0xb6>
80009ee4:	70 09       	ld.w	r9,r8[0x0]
80009ee6:	58 09       	cp.w	r9,0
80009ee8:	cf 90       	breq	80009eda <quorem+0xa6>
80009eea:	8f 46       	st.w	r7[0x10],r6
80009eec:	0e 9c       	mov	r12,r7
80009eee:	e0 a0 0a d2 	rcall	8000b492 <__mcmp>
80009ef2:	c2 d5       	brlt	80009f4c <quorem+0x118>
80009ef4:	2f f5       	sub	r5,-1
80009ef6:	08 98       	mov	r8,r4
80009ef8:	30 09       	mov	r9,0
80009efa:	07 0b       	ld.w	r11,r3++
80009efc:	f6 0a 16 10 	lsr	r10,r11,0x10
80009f00:	70 0c       	ld.w	r12,r8[0x0]
80009f02:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009f06:	f8 0e 16 10 	lsr	lr,r12,0x10
80009f0a:	14 1e       	sub	lr,r10
80009f0c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009f10:	16 1a       	sub	r10,r11
80009f12:	12 0a       	add	r10,r9
80009f14:	b0 1a       	st.h	r8[0x2],r10
80009f16:	b1 4a       	asr	r10,0x10
80009f18:	fc 0a 00 09 	add	r9,lr,r10
80009f1c:	b0 09       	st.h	r8[0x0],r9
80009f1e:	2f c8       	sub	r8,-4
80009f20:	b1 49       	asr	r9,0x10
80009f22:	04 33       	cp.w	r3,r2
80009f24:	fe 98 ff eb 	brls	80009efa <quorem+0xc6>
80009f28:	ec c8 ff fb 	sub	r8,r6,-5
80009f2c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009f30:	58 09       	cp.w	r9,0
80009f32:	c0 d1       	brne	80009f4c <quorem+0x118>
80009f34:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009f38:	c0 28       	rjmp	80009f3c <quorem+0x108>
80009f3a:	20 16       	sub	r6,1
80009f3c:	20 48       	sub	r8,4
80009f3e:	08 38       	cp.w	r8,r4
80009f40:	e0 88 00 05 	brls	80009f4a <quorem+0x116>
80009f44:	70 09       	ld.w	r9,r8[0x0]
80009f46:	58 09       	cp.w	r9,0
80009f48:	cf 90       	breq	80009f3a <quorem+0x106>
80009f4a:	8f 46       	st.w	r7[0x10],r6
80009f4c:	0a 9c       	mov	r12,r5
80009f4e:	2f ed       	sub	sp,-8
80009f50:	d8 32       	popm	r0-r7,pc
80009f52:	d7 03       	nop

80009f54 <_dtoa_r>:
80009f54:	d4 31       	pushm	r0-r7,lr
80009f56:	21 ad       	sub	sp,104
80009f58:	fa c4 ff 74 	sub	r4,sp,-140
80009f5c:	18 97       	mov	r7,r12
80009f5e:	16 95       	mov	r5,r11
80009f60:	68 2c       	ld.w	r12,r4[0x8]
80009f62:	50 c9       	stdsp	sp[0x30],r9
80009f64:	68 16       	ld.w	r6,r4[0x4]
80009f66:	68 09       	ld.w	r9,r4[0x0]
80009f68:	50 e8       	stdsp	sp[0x38],r8
80009f6a:	14 94       	mov	r4,r10
80009f6c:	51 2c       	stdsp	sp[0x48],r12
80009f6e:	fa e5 00 08 	st.d	sp[8],r4
80009f72:	51 59       	stdsp	sp[0x54],r9
80009f74:	6e 95       	ld.w	r5,r7[0x24]
80009f76:	58 05       	cp.w	r5,0
80009f78:	c0 91       	brne	80009f8a <_dtoa_r+0x36>
80009f7a:	31 0c       	mov	r12,16
80009f7c:	fe b0 e8 f4 	rcall	80007164 <malloc>
80009f80:	99 35       	st.w	r12[0xc],r5
80009f82:	8f 9c       	st.w	r7[0x24],r12
80009f84:	99 15       	st.w	r12[0x4],r5
80009f86:	99 25       	st.w	r12[0x8],r5
80009f88:	99 05       	st.w	r12[0x0],r5
80009f8a:	6e 99       	ld.w	r9,r7[0x24]
80009f8c:	72 08       	ld.w	r8,r9[0x0]
80009f8e:	58 08       	cp.w	r8,0
80009f90:	c0 f0       	breq	80009fae <_dtoa_r+0x5a>
80009f92:	72 1a       	ld.w	r10,r9[0x4]
80009f94:	91 1a       	st.w	r8[0x4],r10
80009f96:	30 1a       	mov	r10,1
80009f98:	72 19       	ld.w	r9,r9[0x4]
80009f9a:	f4 09 09 49 	lsl	r9,r10,r9
80009f9e:	10 9b       	mov	r11,r8
80009fa0:	91 29       	st.w	r8[0x8],r9
80009fa2:	0e 9c       	mov	r12,r7
80009fa4:	e0 a0 0a 90 	rcall	8000b4c4 <_Bfree>
80009fa8:	6e 98       	ld.w	r8,r7[0x24]
80009faa:	30 09       	mov	r9,0
80009fac:	91 09       	st.w	r8[0x0],r9
80009fae:	40 28       	lddsp	r8,sp[0x8]
80009fb0:	10 94       	mov	r4,r8
80009fb2:	58 08       	cp.w	r8,0
80009fb4:	c0 64       	brge	80009fc0 <_dtoa_r+0x6c>
80009fb6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009fba:	50 28       	stdsp	sp[0x8],r8
80009fbc:	30 18       	mov	r8,1
80009fbe:	c0 28       	rjmp	80009fc2 <_dtoa_r+0x6e>
80009fc0:	30 08       	mov	r8,0
80009fc2:	8d 08       	st.w	r6[0x0],r8
80009fc4:	fc 1c 7f f0 	movh	r12,0x7ff0
80009fc8:	40 26       	lddsp	r6,sp[0x8]
80009fca:	0c 98       	mov	r8,r6
80009fcc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009fd0:	18 38       	cp.w	r8,r12
80009fd2:	c2 01       	brne	8000a012 <_dtoa_r+0xbe>
80009fd4:	e0 68 27 0f 	mov	r8,9999
80009fd8:	41 5b       	lddsp	r11,sp[0x54]
80009fda:	97 08       	st.w	r11[0x0],r8
80009fdc:	40 3a       	lddsp	r10,sp[0xc]
80009fde:	58 0a       	cp.w	r10,0
80009fe0:	c0 71       	brne	80009fee <_dtoa_r+0x9a>
80009fe2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009fe6:	c0 41       	brne	80009fee <_dtoa_r+0x9a>
80009fe8:	fe cc c1 4c 	sub	r12,pc,-16052
80009fec:	c0 38       	rjmp	80009ff2 <_dtoa_r+0x9e>
80009fee:	fe cc c1 46 	sub	r12,pc,-16058
80009ff2:	41 29       	lddsp	r9,sp[0x48]
80009ff4:	58 09       	cp.w	r9,0
80009ff6:	e0 80 05 9a 	breq	8000ab2a <_dtoa_r+0xbd6>
80009ffa:	f8 c8 ff fd 	sub	r8,r12,-3
80009ffe:	f8 c9 ff f8 	sub	r9,r12,-8
8000a002:	11 8b       	ld.ub	r11,r8[0x0]
8000a004:	30 0a       	mov	r10,0
8000a006:	41 25       	lddsp	r5,sp[0x48]
8000a008:	f4 0b 18 00 	cp.b	r11,r10
8000a00c:	f2 08 17 10 	movne	r8,r9
8000a010:	c1 68       	rjmp	8000a03c <_dtoa_r+0xe8>
8000a012:	fa ea 00 08 	ld.d	r10,sp[8]
8000a016:	30 08       	mov	r8,0
8000a018:	fa eb 00 3c 	st.d	sp[60],r10
8000a01c:	30 09       	mov	r9,0
8000a01e:	e0 a0 10 ce 	rcall	8000c1ba <__avr32_f64_cmp_eq>
8000a022:	c1 00       	breq	8000a042 <_dtoa_r+0xee>
8000a024:	30 18       	mov	r8,1
8000a026:	41 5a       	lddsp	r10,sp[0x54]
8000a028:	95 08       	st.w	r10[0x0],r8
8000a02a:	fe cc c2 b2 	sub	r12,pc,-15694
8000a02e:	41 29       	lddsp	r9,sp[0x48]
8000a030:	f8 08 00 08 	add	r8,r12,r8
8000a034:	58 09       	cp.w	r9,0
8000a036:	e0 80 05 7a 	breq	8000ab2a <_dtoa_r+0xbd6>
8000a03a:	12 95       	mov	r5,r9
8000a03c:	8b 08       	st.w	r5[0x0],r8
8000a03e:	e0 8f 05 76 	bral	8000ab2a <_dtoa_r+0xbd6>
8000a042:	fa c8 ff 9c 	sub	r8,sp,-100
8000a046:	fa c9 ff a0 	sub	r9,sp,-96
8000a04a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a04e:	0e 9c       	mov	r12,r7
8000a050:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a054:	e0 a0 0a 8a 	rcall	8000b568 <__d2b>
8000a058:	18 93       	mov	r3,r12
8000a05a:	58 05       	cp.w	r5,0
8000a05c:	c0 d0       	breq	8000a076 <_dtoa_r+0x122>
8000a05e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a062:	30 04       	mov	r4,0
8000a064:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a068:	ea c5 03 ff 	sub	r5,r5,1023
8000a06c:	10 9b       	mov	r11,r8
8000a06e:	51 74       	stdsp	sp[0x5c],r4
8000a070:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a074:	c2 58       	rjmp	8000a0be <_dtoa_r+0x16a>
8000a076:	41 88       	lddsp	r8,sp[0x60]
8000a078:	41 9c       	lddsp	r12,sp[0x64]
8000a07a:	10 0c       	add	r12,r8
8000a07c:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a080:	e0 45 00 20 	cp.w	r5,32
8000a084:	e0 8a 00 0e 	brle	8000a0a0 <_dtoa_r+0x14c>
8000a088:	f8 cc fb ee 	sub	r12,r12,-1042
8000a08c:	40 3b       	lddsp	r11,sp[0xc]
8000a08e:	ea 08 11 40 	rsub	r8,r5,64
8000a092:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a096:	ec 08 09 46 	lsl	r6,r6,r8
8000a09a:	0c 4c       	or	r12,r6
8000a09c:	c0 78       	rjmp	8000a0aa <_dtoa_r+0x156>
8000a09e:	d7 03       	nop
8000a0a0:	ea 0c 11 20 	rsub	r12,r5,32
8000a0a4:	40 3a       	lddsp	r10,sp[0xc]
8000a0a6:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a0aa:	e0 a0 10 14 	rcall	8000c0d2 <__avr32_u32_to_f64>
8000a0ae:	fc 18 fe 10 	movh	r8,0xfe10
8000a0b2:	30 19       	mov	r9,1
8000a0b4:	ea c5 04 33 	sub	r5,r5,1075
8000a0b8:	f0 0b 00 0b 	add	r11,r8,r11
8000a0bc:	51 79       	stdsp	sp[0x5c],r9
8000a0be:	30 08       	mov	r8,0
8000a0c0:	fc 19 3f f8 	movh	r9,0x3ff8
8000a0c4:	e0 a0 0e 9c 	rcall	8000bdfc <__avr32_f64_sub>
8000a0c8:	e0 68 43 61 	mov	r8,17249
8000a0cc:	ea 18 63 6f 	orh	r8,0x636f
8000a0d0:	e0 69 87 a7 	mov	r9,34727
8000a0d4:	ea 19 3f d2 	orh	r9,0x3fd2
8000a0d8:	e0 a0 0d a6 	rcall	8000bc24 <__avr32_f64_mul>
8000a0dc:	e0 68 c8 b3 	mov	r8,51379
8000a0e0:	ea 18 8b 60 	orh	r8,0x8b60
8000a0e4:	e0 69 8a 28 	mov	r9,35368
8000a0e8:	ea 19 3f c6 	orh	r9,0x3fc6
8000a0ec:	e0 a0 0f 56 	rcall	8000bf98 <__avr32_f64_add>
8000a0f0:	0a 9c       	mov	r12,r5
8000a0f2:	14 90       	mov	r0,r10
8000a0f4:	16 91       	mov	r1,r11
8000a0f6:	e0 a0 0f f2 	rcall	8000c0da <__avr32_s32_to_f64>
8000a0fa:	e0 68 79 fb 	mov	r8,31227
8000a0fe:	ea 18 50 9f 	orh	r8,0x509f
8000a102:	e0 69 44 13 	mov	r9,17427
8000a106:	ea 19 3f d3 	orh	r9,0x3fd3
8000a10a:	e0 a0 0d 8d 	rcall	8000bc24 <__avr32_f64_mul>
8000a10e:	14 98       	mov	r8,r10
8000a110:	16 99       	mov	r9,r11
8000a112:	00 9a       	mov	r10,r0
8000a114:	02 9b       	mov	r11,r1
8000a116:	e0 a0 0f 41 	rcall	8000bf98 <__avr32_f64_add>
8000a11a:	14 90       	mov	r0,r10
8000a11c:	16 91       	mov	r1,r11
8000a11e:	e0 a0 0f c7 	rcall	8000c0ac <__avr32_f64_to_s32>
8000a122:	30 08       	mov	r8,0
8000a124:	18 96       	mov	r6,r12
8000a126:	30 09       	mov	r9,0
8000a128:	00 9a       	mov	r10,r0
8000a12a:	02 9b       	mov	r11,r1
8000a12c:	e0 a0 10 8e 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a130:	c0 c0       	breq	8000a148 <_dtoa_r+0x1f4>
8000a132:	0c 9c       	mov	r12,r6
8000a134:	e0 a0 0f d3 	rcall	8000c0da <__avr32_s32_to_f64>
8000a138:	14 98       	mov	r8,r10
8000a13a:	16 99       	mov	r9,r11
8000a13c:	00 9a       	mov	r10,r0
8000a13e:	02 9b       	mov	r11,r1
8000a140:	e0 a0 10 3d 	rcall	8000c1ba <__avr32_f64_cmp_eq>
8000a144:	f7 b6 00 01 	subeq	r6,1
8000a148:	59 66       	cp.w	r6,22
8000a14a:	e0 88 00 05 	brls	8000a154 <_dtoa_r+0x200>
8000a14e:	30 18       	mov	r8,1
8000a150:	51 48       	stdsp	sp[0x50],r8
8000a152:	c1 38       	rjmp	8000a178 <_dtoa_r+0x224>
8000a154:	fe c8 c1 f8 	sub	r8,pc,-15880
8000a158:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a15c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a160:	e0 a0 10 74 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a164:	f9 b4 00 00 	moveq	r4,0
8000a168:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a16c:	f7 b6 01 01 	subne	r6,1
8000a170:	f9 bc 01 00 	movne	r12,0
8000a174:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a178:	41 90       	lddsp	r0,sp[0x64]
8000a17a:	20 10       	sub	r0,1
8000a17c:	0a 10       	sub	r0,r5
8000a17e:	c0 46       	brmi	8000a186 <_dtoa_r+0x232>
8000a180:	50 40       	stdsp	sp[0x10],r0
8000a182:	30 00       	mov	r0,0
8000a184:	c0 48       	rjmp	8000a18c <_dtoa_r+0x238>
8000a186:	30 0b       	mov	r11,0
8000a188:	5c 30       	neg	r0
8000a18a:	50 4b       	stdsp	sp[0x10],r11
8000a18c:	ec 02 11 00 	rsub	r2,r6,0
8000a190:	58 06       	cp.w	r6,0
8000a192:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a196:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a19a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a19e:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a1a2:	f9 b2 04 00 	movge	r2,0
8000a1a6:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a1aa:	f9 b9 05 00 	movlt	r9,0
8000a1ae:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a1b2:	40 c8       	lddsp	r8,sp[0x30]
8000a1b4:	58 98       	cp.w	r8,9
8000a1b6:	e0 8b 00 20 	brhi	8000a1f6 <_dtoa_r+0x2a2>
8000a1ba:	58 58       	cp.w	r8,5
8000a1bc:	f9 b4 0a 01 	movle	r4,1
8000a1c0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a1c4:	f7 b5 09 04 	subgt	r5,4
8000a1c8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a1cc:	f9 b4 09 00 	movgt	r4,0
8000a1d0:	40 cc       	lddsp	r12,sp[0x30]
8000a1d2:	58 3c       	cp.w	r12,3
8000a1d4:	c2 d0       	breq	8000a22e <_dtoa_r+0x2da>
8000a1d6:	e0 89 00 05 	brgt	8000a1e0 <_dtoa_r+0x28c>
8000a1da:	58 2c       	cp.w	r12,2
8000a1dc:	c1 01       	brne	8000a1fc <_dtoa_r+0x2a8>
8000a1de:	c1 88       	rjmp	8000a20e <_dtoa_r+0x2ba>
8000a1e0:	40 cb       	lddsp	r11,sp[0x30]
8000a1e2:	58 4b       	cp.w	r11,4
8000a1e4:	c0 60       	breq	8000a1f0 <_dtoa_r+0x29c>
8000a1e6:	58 5b       	cp.w	r11,5
8000a1e8:	c0 a1       	brne	8000a1fc <_dtoa_r+0x2a8>
8000a1ea:	30 1a       	mov	r10,1
8000a1ec:	50 da       	stdsp	sp[0x34],r10
8000a1ee:	c2 28       	rjmp	8000a232 <_dtoa_r+0x2de>
8000a1f0:	30 19       	mov	r9,1
8000a1f2:	50 d9       	stdsp	sp[0x34],r9
8000a1f4:	c0 f8       	rjmp	8000a212 <_dtoa_r+0x2be>
8000a1f6:	30 08       	mov	r8,0
8000a1f8:	30 14       	mov	r4,1
8000a1fa:	50 c8       	stdsp	sp[0x30],r8
8000a1fc:	3f f5       	mov	r5,-1
8000a1fe:	30 1c       	mov	r12,1
8000a200:	30 0b       	mov	r11,0
8000a202:	50 95       	stdsp	sp[0x24],r5
8000a204:	50 dc       	stdsp	sp[0x34],r12
8000a206:	0a 91       	mov	r1,r5
8000a208:	31 28       	mov	r8,18
8000a20a:	50 eb       	stdsp	sp[0x38],r11
8000a20c:	c2 08       	rjmp	8000a24c <_dtoa_r+0x2f8>
8000a20e:	30 0a       	mov	r10,0
8000a210:	50 da       	stdsp	sp[0x34],r10
8000a212:	40 e9       	lddsp	r9,sp[0x38]
8000a214:	58 09       	cp.w	r9,0
8000a216:	e0 89 00 07 	brgt	8000a224 <_dtoa_r+0x2d0>
8000a21a:	30 18       	mov	r8,1
8000a21c:	50 98       	stdsp	sp[0x24],r8
8000a21e:	10 91       	mov	r1,r8
8000a220:	50 e8       	stdsp	sp[0x38],r8
8000a222:	c1 58       	rjmp	8000a24c <_dtoa_r+0x2f8>
8000a224:	40 e5       	lddsp	r5,sp[0x38]
8000a226:	50 95       	stdsp	sp[0x24],r5
8000a228:	0a 91       	mov	r1,r5
8000a22a:	0a 98       	mov	r8,r5
8000a22c:	c1 08       	rjmp	8000a24c <_dtoa_r+0x2f8>
8000a22e:	30 0c       	mov	r12,0
8000a230:	50 dc       	stdsp	sp[0x34],r12
8000a232:	40 eb       	lddsp	r11,sp[0x38]
8000a234:	ec 0b 00 0b 	add	r11,r6,r11
8000a238:	50 9b       	stdsp	sp[0x24],r11
8000a23a:	16 98       	mov	r8,r11
8000a23c:	2f f8       	sub	r8,-1
8000a23e:	58 08       	cp.w	r8,0
8000a240:	e0 89 00 05 	brgt	8000a24a <_dtoa_r+0x2f6>
8000a244:	10 91       	mov	r1,r8
8000a246:	30 18       	mov	r8,1
8000a248:	c0 28       	rjmp	8000a24c <_dtoa_r+0x2f8>
8000a24a:	10 91       	mov	r1,r8
8000a24c:	30 09       	mov	r9,0
8000a24e:	6e 9a       	ld.w	r10,r7[0x24]
8000a250:	95 19       	st.w	r10[0x4],r9
8000a252:	30 49       	mov	r9,4
8000a254:	c0 68       	rjmp	8000a260 <_dtoa_r+0x30c>
8000a256:	d7 03       	nop
8000a258:	6a 1a       	ld.w	r10,r5[0x4]
8000a25a:	a1 79       	lsl	r9,0x1
8000a25c:	2f fa       	sub	r10,-1
8000a25e:	8b 1a       	st.w	r5[0x4],r10
8000a260:	6e 95       	ld.w	r5,r7[0x24]
8000a262:	f2 ca ff ec 	sub	r10,r9,-20
8000a266:	10 3a       	cp.w	r10,r8
8000a268:	fe 98 ff f8 	brls	8000a258 <_dtoa_r+0x304>
8000a26c:	6a 1b       	ld.w	r11,r5[0x4]
8000a26e:	0e 9c       	mov	r12,r7
8000a270:	e0 a0 09 44 	rcall	8000b4f8 <_Balloc>
8000a274:	58 e1       	cp.w	r1,14
8000a276:	5f 88       	srls	r8
8000a278:	8b 0c       	st.w	r5[0x0],r12
8000a27a:	f1 e4 00 04 	and	r4,r8,r4
8000a27e:	6e 98       	ld.w	r8,r7[0x24]
8000a280:	70 08       	ld.w	r8,r8[0x0]
8000a282:	50 88       	stdsp	sp[0x20],r8
8000a284:	e0 80 01 82 	breq	8000a588 <_dtoa_r+0x634>
8000a288:	58 06       	cp.w	r6,0
8000a28a:	e0 8a 00 43 	brle	8000a310 <_dtoa_r+0x3bc>
8000a28e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a292:	fe c8 c3 36 	sub	r8,pc,-15562
8000a296:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a29a:	fa e5 00 18 	st.d	sp[24],r4
8000a29e:	ec 04 14 04 	asr	r4,r6,0x4
8000a2a2:	ed b4 00 04 	bld	r4,0x4
8000a2a6:	c0 30       	breq	8000a2ac <_dtoa_r+0x358>
8000a2a8:	30 25       	mov	r5,2
8000a2aa:	c1 08       	rjmp	8000a2ca <_dtoa_r+0x376>
8000a2ac:	fe c8 c2 88 	sub	r8,pc,-15736
8000a2b0:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a2b4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a2b8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a2bc:	e0 a0 0f fa 	rcall	8000c2b0 <__avr32_f64_div>
8000a2c0:	30 35       	mov	r5,3
8000a2c2:	14 98       	mov	r8,r10
8000a2c4:	16 99       	mov	r9,r11
8000a2c6:	fa e9 00 08 	st.d	sp[8],r8
8000a2ca:	fe cc c2 a6 	sub	r12,pc,-15706
8000a2ce:	50 a3       	stdsp	sp[0x28],r3
8000a2d0:	0c 93       	mov	r3,r6
8000a2d2:	18 96       	mov	r6,r12
8000a2d4:	c0 f8       	rjmp	8000a2f2 <_dtoa_r+0x39e>
8000a2d6:	fa ea 00 18 	ld.d	r10,sp[24]
8000a2da:	ed b4 00 00 	bld	r4,0x0
8000a2de:	c0 81       	brne	8000a2ee <_dtoa_r+0x39a>
8000a2e0:	ec e8 00 00 	ld.d	r8,r6[0]
8000a2e4:	2f f5       	sub	r5,-1
8000a2e6:	e0 a0 0c 9f 	rcall	8000bc24 <__avr32_f64_mul>
8000a2ea:	fa eb 00 18 	st.d	sp[24],r10
8000a2ee:	a1 54       	asr	r4,0x1
8000a2f0:	2f 86       	sub	r6,-8
8000a2f2:	58 04       	cp.w	r4,0
8000a2f4:	cf 11       	brne	8000a2d6 <_dtoa_r+0x382>
8000a2f6:	fa e8 00 18 	ld.d	r8,sp[24]
8000a2fa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2fe:	06 96       	mov	r6,r3
8000a300:	e0 a0 0f d8 	rcall	8000c2b0 <__avr32_f64_div>
8000a304:	40 a3       	lddsp	r3,sp[0x28]
8000a306:	14 98       	mov	r8,r10
8000a308:	16 99       	mov	r9,r11
8000a30a:	fa e9 00 08 	st.d	sp[8],r8
8000a30e:	c2 f8       	rjmp	8000a36c <_dtoa_r+0x418>
8000a310:	ec 08 11 00 	rsub	r8,r6,0
8000a314:	c0 31       	brne	8000a31a <_dtoa_r+0x3c6>
8000a316:	30 25       	mov	r5,2
8000a318:	c2 a8       	rjmp	8000a36c <_dtoa_r+0x418>
8000a31a:	fe cc c2 f6 	sub	r12,pc,-15626
8000a31e:	f0 04 14 04 	asr	r4,r8,0x4
8000a322:	50 1c       	stdsp	sp[0x4],r12
8000a324:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a328:	fe c9 c3 cc 	sub	r9,pc,-15412
8000a32c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a330:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a334:	e0 a0 0c 78 	rcall	8000bc24 <__avr32_f64_mul>
8000a338:	40 1c       	lddsp	r12,sp[0x4]
8000a33a:	50 63       	stdsp	sp[0x18],r3
8000a33c:	30 25       	mov	r5,2
8000a33e:	0c 93       	mov	r3,r6
8000a340:	fa eb 00 08 	st.d	sp[8],r10
8000a344:	18 96       	mov	r6,r12
8000a346:	c0 f8       	rjmp	8000a364 <_dtoa_r+0x410>
8000a348:	fa ea 00 08 	ld.d	r10,sp[8]
8000a34c:	ed b4 00 00 	bld	r4,0x0
8000a350:	c0 81       	brne	8000a360 <_dtoa_r+0x40c>
8000a352:	ec e8 00 00 	ld.d	r8,r6[0]
8000a356:	2f f5       	sub	r5,-1
8000a358:	e0 a0 0c 66 	rcall	8000bc24 <__avr32_f64_mul>
8000a35c:	fa eb 00 08 	st.d	sp[8],r10
8000a360:	a1 54       	asr	r4,0x1
8000a362:	2f 86       	sub	r6,-8
8000a364:	58 04       	cp.w	r4,0
8000a366:	cf 11       	brne	8000a348 <_dtoa_r+0x3f4>
8000a368:	06 96       	mov	r6,r3
8000a36a:	40 63       	lddsp	r3,sp[0x18]
8000a36c:	41 4a       	lddsp	r10,sp[0x50]
8000a36e:	58 0a       	cp.w	r10,0
8000a370:	c2 a0       	breq	8000a3c4 <_dtoa_r+0x470>
8000a372:	fa e8 00 08 	ld.d	r8,sp[8]
8000a376:	58 01       	cp.w	r1,0
8000a378:	5f 94       	srgt	r4
8000a37a:	fa e9 00 18 	st.d	sp[24],r8
8000a37e:	30 08       	mov	r8,0
8000a380:	fc 19 3f f0 	movh	r9,0x3ff0
8000a384:	fa ea 00 18 	ld.d	r10,sp[24]
8000a388:	e0 a0 0f 60 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a38c:	f9 bc 00 00 	moveq	r12,0
8000a390:	f9 bc 01 01 	movne	r12,1
8000a394:	e9 ec 00 0c 	and	r12,r4,r12
8000a398:	c1 60       	breq	8000a3c4 <_dtoa_r+0x470>
8000a39a:	40 98       	lddsp	r8,sp[0x24]
8000a39c:	58 08       	cp.w	r8,0
8000a39e:	e0 8a 00 f1 	brle	8000a580 <_dtoa_r+0x62c>
8000a3a2:	30 08       	mov	r8,0
8000a3a4:	fc 19 40 24 	movh	r9,0x4024
8000a3a8:	ec c4 00 01 	sub	r4,r6,1
8000a3ac:	fa ea 00 18 	ld.d	r10,sp[24]
8000a3b0:	2f f5       	sub	r5,-1
8000a3b2:	50 64       	stdsp	sp[0x18],r4
8000a3b4:	e0 a0 0c 38 	rcall	8000bc24 <__avr32_f64_mul>
8000a3b8:	40 94       	lddsp	r4,sp[0x24]
8000a3ba:	14 98       	mov	r8,r10
8000a3bc:	16 99       	mov	r9,r11
8000a3be:	fa e9 00 08 	st.d	sp[8],r8
8000a3c2:	c0 38       	rjmp	8000a3c8 <_dtoa_r+0x474>
8000a3c4:	50 66       	stdsp	sp[0x18],r6
8000a3c6:	02 94       	mov	r4,r1
8000a3c8:	0a 9c       	mov	r12,r5
8000a3ca:	e0 a0 0e 88 	rcall	8000c0da <__avr32_s32_to_f64>
8000a3ce:	fa e8 00 08 	ld.d	r8,sp[8]
8000a3d2:	e0 a0 0c 29 	rcall	8000bc24 <__avr32_f64_mul>
8000a3d6:	30 08       	mov	r8,0
8000a3d8:	fc 19 40 1c 	movh	r9,0x401c
8000a3dc:	e0 a0 0d de 	rcall	8000bf98 <__avr32_f64_add>
8000a3e0:	14 98       	mov	r8,r10
8000a3e2:	16 99       	mov	r9,r11
8000a3e4:	fa e9 00 28 	st.d	sp[40],r8
8000a3e8:	fc 18 fc c0 	movh	r8,0xfcc0
8000a3ec:	40 a5       	lddsp	r5,sp[0x28]
8000a3ee:	10 05       	add	r5,r8
8000a3f0:	50 a5       	stdsp	sp[0x28],r5
8000a3f2:	58 04       	cp.w	r4,0
8000a3f4:	c2 11       	brne	8000a436 <_dtoa_r+0x4e2>
8000a3f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3fa:	30 08       	mov	r8,0
8000a3fc:	fc 19 40 14 	movh	r9,0x4014
8000a400:	e0 a0 0c fe 	rcall	8000bdfc <__avr32_f64_sub>
8000a404:	40 bc       	lddsp	r12,sp[0x2c]
8000a406:	fa eb 00 08 	st.d	sp[8],r10
8000a40a:	14 98       	mov	r8,r10
8000a40c:	16 99       	mov	r9,r11
8000a40e:	18 9a       	mov	r10,r12
8000a410:	0a 9b       	mov	r11,r5
8000a412:	e0 a0 0f 1b 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a416:	e0 81 02 54 	brne	8000a8be <_dtoa_r+0x96a>
8000a41a:	0a 98       	mov	r8,r5
8000a41c:	40 b9       	lddsp	r9,sp[0x2c]
8000a41e:	ee 18 80 00 	eorh	r8,0x8000
8000a422:	fa ea 00 08 	ld.d	r10,sp[8]
8000a426:	10 95       	mov	r5,r8
8000a428:	12 98       	mov	r8,r9
8000a42a:	0a 99       	mov	r9,r5
8000a42c:	e0 a0 0f 0e 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a430:	e0 81 02 3e 	brne	8000a8ac <_dtoa_r+0x958>
8000a434:	ca 68       	rjmp	8000a580 <_dtoa_r+0x62c>
8000a436:	fe c9 c4 da 	sub	r9,pc,-15142
8000a43a:	e8 c8 00 01 	sub	r8,r4,1
8000a43e:	40 d5       	lddsp	r5,sp[0x34]
8000a440:	58 05       	cp.w	r5,0
8000a442:	c4 f0       	breq	8000a4e0 <_dtoa_r+0x58c>
8000a444:	30 0c       	mov	r12,0
8000a446:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a44a:	51 3c       	stdsp	sp[0x4c],r12
8000a44c:	30 0a       	mov	r10,0
8000a44e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a452:	e0 a0 0f 2f 	rcall	8000c2b0 <__avr32_f64_div>
8000a456:	fa e8 00 28 	ld.d	r8,sp[40]
8000a45a:	40 85       	lddsp	r5,sp[0x20]
8000a45c:	e0 a0 0c d0 	rcall	8000bdfc <__avr32_f64_sub>
8000a460:	fa eb 00 28 	st.d	sp[40],r10
8000a464:	fa ea 00 08 	ld.d	r10,sp[8]
8000a468:	e0 a0 0e 22 	rcall	8000c0ac <__avr32_f64_to_s32>
8000a46c:	51 6c       	stdsp	sp[0x58],r12
8000a46e:	e0 a0 0e 36 	rcall	8000c0da <__avr32_s32_to_f64>
8000a472:	14 98       	mov	r8,r10
8000a474:	16 99       	mov	r9,r11
8000a476:	fa ea 00 08 	ld.d	r10,sp[8]
8000a47a:	e0 a0 0c c1 	rcall	8000bdfc <__avr32_f64_sub>
8000a47e:	fa eb 00 08 	st.d	sp[8],r10
8000a482:	41 68       	lddsp	r8,sp[0x58]
8000a484:	2d 08       	sub	r8,-48
8000a486:	0a c8       	st.b	r5++,r8
8000a488:	41 39       	lddsp	r9,sp[0x4c]
8000a48a:	2f f9       	sub	r9,-1
8000a48c:	51 39       	stdsp	sp[0x4c],r9
8000a48e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a492:	e0 a0 0e db 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a496:	e0 81 03 39 	brne	8000ab08 <_dtoa_r+0xbb4>
8000a49a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a49e:	30 0a       	mov	r10,0
8000a4a0:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a4a4:	e0 a0 0c ac 	rcall	8000bdfc <__avr32_f64_sub>
8000a4a8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a4ac:	e0 a0 0e ce 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a4b0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a4b4:	30 08       	mov	r8,0
8000a4b6:	fc 19 40 24 	movh	r9,0x4024
8000a4ba:	e0 81 00 da 	brne	8000a66e <_dtoa_r+0x71a>
8000a4be:	41 3c       	lddsp	r12,sp[0x4c]
8000a4c0:	08 3c       	cp.w	r12,r4
8000a4c2:	c5 f4       	brge	8000a580 <_dtoa_r+0x62c>
8000a4c4:	e0 a0 0b b0 	rcall	8000bc24 <__avr32_f64_mul>
8000a4c8:	30 08       	mov	r8,0
8000a4ca:	fa eb 00 28 	st.d	sp[40],r10
8000a4ce:	fc 19 40 24 	movh	r9,0x4024
8000a4d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4d6:	e0 a0 0b a7 	rcall	8000bc24 <__avr32_f64_mul>
8000a4da:	fa eb 00 08 	st.d	sp[8],r10
8000a4de:	cc 3b       	rjmp	8000a464 <_dtoa_r+0x510>
8000a4e0:	40 85       	lddsp	r5,sp[0x20]
8000a4e2:	08 05       	add	r5,r4
8000a4e4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a4e8:	51 35       	stdsp	sp[0x4c],r5
8000a4ea:	fa e8 00 28 	ld.d	r8,sp[40]
8000a4ee:	40 85       	lddsp	r5,sp[0x20]
8000a4f0:	e0 a0 0b 9a 	rcall	8000bc24 <__avr32_f64_mul>
8000a4f4:	fa eb 00 28 	st.d	sp[40],r10
8000a4f8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4fc:	e0 a0 0d d8 	rcall	8000c0ac <__avr32_f64_to_s32>
8000a500:	51 6c       	stdsp	sp[0x58],r12
8000a502:	e0 a0 0d ec 	rcall	8000c0da <__avr32_s32_to_f64>
8000a506:	14 98       	mov	r8,r10
8000a508:	16 99       	mov	r9,r11
8000a50a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a50e:	e0 a0 0c 77 	rcall	8000bdfc <__avr32_f64_sub>
8000a512:	fa eb 00 08 	st.d	sp[8],r10
8000a516:	41 68       	lddsp	r8,sp[0x58]
8000a518:	2d 08       	sub	r8,-48
8000a51a:	0a c8       	st.b	r5++,r8
8000a51c:	41 3c       	lddsp	r12,sp[0x4c]
8000a51e:	18 35       	cp.w	r5,r12
8000a520:	c2 81       	brne	8000a570 <_dtoa_r+0x61c>
8000a522:	30 08       	mov	r8,0
8000a524:	fc 19 3f e0 	movh	r9,0x3fe0
8000a528:	fa ea 00 28 	ld.d	r10,sp[40]
8000a52c:	e0 a0 0d 36 	rcall	8000bf98 <__avr32_f64_add>
8000a530:	40 85       	lddsp	r5,sp[0x20]
8000a532:	fa e8 00 08 	ld.d	r8,sp[8]
8000a536:	08 05       	add	r5,r4
8000a538:	e0 a0 0e 88 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a53c:	e0 81 00 99 	brne	8000a66e <_dtoa_r+0x71a>
8000a540:	fa e8 00 28 	ld.d	r8,sp[40]
8000a544:	30 0a       	mov	r10,0
8000a546:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a54a:	e0 a0 0c 59 	rcall	8000bdfc <__avr32_f64_sub>
8000a54e:	14 98       	mov	r8,r10
8000a550:	16 99       	mov	r9,r11
8000a552:	fa ea 00 08 	ld.d	r10,sp[8]
8000a556:	e0 a0 0e 79 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a55a:	c1 30       	breq	8000a580 <_dtoa_r+0x62c>
8000a55c:	33 09       	mov	r9,48
8000a55e:	0a 98       	mov	r8,r5
8000a560:	11 7a       	ld.ub	r10,--r8
8000a562:	f2 0a 18 00 	cp.b	r10,r9
8000a566:	e0 81 02 d1 	brne	8000ab08 <_dtoa_r+0xbb4>
8000a56a:	10 95       	mov	r5,r8
8000a56c:	cf 9b       	rjmp	8000a55e <_dtoa_r+0x60a>
8000a56e:	d7 03       	nop
8000a570:	30 08       	mov	r8,0
8000a572:	fc 19 40 24 	movh	r9,0x4024
8000a576:	e0 a0 0b 57 	rcall	8000bc24 <__avr32_f64_mul>
8000a57a:	fa eb 00 08 	st.d	sp[8],r10
8000a57e:	cb db       	rjmp	8000a4f8 <_dtoa_r+0x5a4>
8000a580:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a584:	fa eb 00 08 	st.d	sp[8],r10
8000a588:	58 e6       	cp.w	r6,14
8000a58a:	5f ab       	srle	r11
8000a58c:	41 8a       	lddsp	r10,sp[0x60]
8000a58e:	30 08       	mov	r8,0
8000a590:	f4 09 11 ff 	rsub	r9,r10,-1
8000a594:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a598:	f0 09 18 00 	cp.b	r9,r8
8000a59c:	e0 80 00 82 	breq	8000a6a0 <_dtoa_r+0x74c>
8000a5a0:	40 ea       	lddsp	r10,sp[0x38]
8000a5a2:	58 01       	cp.w	r1,0
8000a5a4:	5f a9       	srle	r9
8000a5a6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a5aa:	fe ca c6 4e 	sub	r10,pc,-14770
8000a5ae:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a5b2:	fa e5 00 10 	st.d	sp[16],r4
8000a5b6:	f0 09 18 00 	cp.b	r9,r8
8000a5ba:	c1 40       	breq	8000a5e2 <_dtoa_r+0x68e>
8000a5bc:	58 01       	cp.w	r1,0
8000a5be:	e0 81 01 77 	brne	8000a8ac <_dtoa_r+0x958>
8000a5c2:	30 08       	mov	r8,0
8000a5c4:	fc 19 40 14 	movh	r9,0x4014
8000a5c8:	08 9a       	mov	r10,r4
8000a5ca:	0a 9b       	mov	r11,r5
8000a5cc:	e0 a0 0b 2c 	rcall	8000bc24 <__avr32_f64_mul>
8000a5d0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5d4:	e0 a0 0e 06 	rcall	8000c1e0 <__avr32_f64_cmp_ge>
8000a5d8:	e0 81 01 6a 	brne	8000a8ac <_dtoa_r+0x958>
8000a5dc:	02 92       	mov	r2,r1
8000a5de:	e0 8f 01 72 	bral	8000a8c2 <_dtoa_r+0x96e>
8000a5e2:	40 85       	lddsp	r5,sp[0x20]
8000a5e4:	30 14       	mov	r4,1
8000a5e6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a5ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5ee:	e0 a0 0e 61 	rcall	8000c2b0 <__avr32_f64_div>
8000a5f2:	e0 a0 0d 5d 	rcall	8000c0ac <__avr32_f64_to_s32>
8000a5f6:	18 92       	mov	r2,r12
8000a5f8:	e0 a0 0d 71 	rcall	8000c0da <__avr32_s32_to_f64>
8000a5fc:	fa e8 00 10 	ld.d	r8,sp[16]
8000a600:	e0 a0 0b 12 	rcall	8000bc24 <__avr32_f64_mul>
8000a604:	14 98       	mov	r8,r10
8000a606:	16 99       	mov	r9,r11
8000a608:	fa ea 00 08 	ld.d	r10,sp[8]
8000a60c:	e0 a0 0b f8 	rcall	8000bdfc <__avr32_f64_sub>
8000a610:	fa eb 00 08 	st.d	sp[8],r10
8000a614:	e4 c8 ff d0 	sub	r8,r2,-48
8000a618:	0a c8       	st.b	r5++,r8
8000a61a:	fc 19 40 24 	movh	r9,0x4024
8000a61e:	30 08       	mov	r8,0
8000a620:	02 34       	cp.w	r4,r1
8000a622:	c3 31       	brne	8000a688 <_dtoa_r+0x734>
8000a624:	fa e8 00 08 	ld.d	r8,sp[8]
8000a628:	e0 a0 0c b8 	rcall	8000bf98 <__avr32_f64_add>
8000a62c:	16 91       	mov	r1,r11
8000a62e:	14 90       	mov	r0,r10
8000a630:	14 98       	mov	r8,r10
8000a632:	02 99       	mov	r9,r1
8000a634:	fa ea 00 10 	ld.d	r10,sp[16]
8000a638:	e0 a0 0e 08 	rcall	8000c248 <__avr32_f64_cmp_lt>
8000a63c:	c1 a1       	brne	8000a670 <_dtoa_r+0x71c>
8000a63e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a642:	00 9a       	mov	r10,r0
8000a644:	02 9b       	mov	r11,r1
8000a646:	e0 a0 0d ba 	rcall	8000c1ba <__avr32_f64_cmp_eq>
8000a64a:	e0 80 02 5e 	breq	8000ab06 <_dtoa_r+0xbb2>
8000a64e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a652:	c0 f1       	brne	8000a670 <_dtoa_r+0x71c>
8000a654:	e0 8f 02 59 	bral	8000ab06 <_dtoa_r+0xbb2>
8000a658:	40 8a       	lddsp	r10,sp[0x20]
8000a65a:	14 38       	cp.w	r8,r10
8000a65c:	c0 30       	breq	8000a662 <_dtoa_r+0x70e>
8000a65e:	10 95       	mov	r5,r8
8000a660:	c0 98       	rjmp	8000a672 <_dtoa_r+0x71e>
8000a662:	33 08       	mov	r8,48
8000a664:	40 89       	lddsp	r9,sp[0x20]
8000a666:	2f f6       	sub	r6,-1
8000a668:	b2 88       	st.b	r9[0x0],r8
8000a66a:	40 88       	lddsp	r8,sp[0x20]
8000a66c:	c0 88       	rjmp	8000a67c <_dtoa_r+0x728>
8000a66e:	40 66       	lddsp	r6,sp[0x18]
8000a670:	33 99       	mov	r9,57
8000a672:	0a 98       	mov	r8,r5
8000a674:	11 7a       	ld.ub	r10,--r8
8000a676:	f2 0a 18 00 	cp.b	r10,r9
8000a67a:	ce f0       	breq	8000a658 <_dtoa_r+0x704>
8000a67c:	50 66       	stdsp	sp[0x18],r6
8000a67e:	11 89       	ld.ub	r9,r8[0x0]
8000a680:	2f f9       	sub	r9,-1
8000a682:	b0 89       	st.b	r8[0x0],r9
8000a684:	e0 8f 02 42 	bral	8000ab08 <_dtoa_r+0xbb4>
8000a688:	e0 a0 0a ce 	rcall	8000bc24 <__avr32_f64_mul>
8000a68c:	2f f4       	sub	r4,-1
8000a68e:	fa eb 00 08 	st.d	sp[8],r10
8000a692:	30 08       	mov	r8,0
8000a694:	30 09       	mov	r9,0
8000a696:	e0 a0 0d 92 	rcall	8000c1ba <__avr32_f64_cmp_eq>
8000a69a:	ca 60       	breq	8000a5e6 <_dtoa_r+0x692>
8000a69c:	e0 8f 02 35 	bral	8000ab06 <_dtoa_r+0xbb2>
8000a6a0:	40 d8       	lddsp	r8,sp[0x34]
8000a6a2:	58 08       	cp.w	r8,0
8000a6a4:	c0 51       	brne	8000a6ae <_dtoa_r+0x75a>
8000a6a6:	04 98       	mov	r8,r2
8000a6a8:	00 95       	mov	r5,r0
8000a6aa:	40 d4       	lddsp	r4,sp[0x34]
8000a6ac:	c3 78       	rjmp	8000a71a <_dtoa_r+0x7c6>
8000a6ae:	40 c5       	lddsp	r5,sp[0x30]
8000a6b0:	58 15       	cp.w	r5,1
8000a6b2:	e0 89 00 0f 	brgt	8000a6d0 <_dtoa_r+0x77c>
8000a6b6:	41 74       	lddsp	r4,sp[0x5c]
8000a6b8:	58 04       	cp.w	r4,0
8000a6ba:	c0 40       	breq	8000a6c2 <_dtoa_r+0x76e>
8000a6bc:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a6c0:	c0 48       	rjmp	8000a6c8 <_dtoa_r+0x774>
8000a6c2:	41 99       	lddsp	r9,sp[0x64]
8000a6c4:	f2 09 11 36 	rsub	r9,r9,54
8000a6c8:	04 98       	mov	r8,r2
8000a6ca:	00 95       	mov	r5,r0
8000a6cc:	c1 c8       	rjmp	8000a704 <_dtoa_r+0x7b0>
8000a6ce:	d7 03       	nop
8000a6d0:	e2 c8 00 01 	sub	r8,r1,1
8000a6d4:	58 01       	cp.w	r1,0
8000a6d6:	e0 05 17 40 	movge	r5,r0
8000a6da:	e2 09 17 40 	movge	r9,r1
8000a6de:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a6e2:	f9 b9 05 00 	movlt	r9,0
8000a6e6:	10 32       	cp.w	r2,r8
8000a6e8:	e5 d8 e4 18 	subge	r8,r2,r8
8000a6ec:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a6f0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a6f4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a6f8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a6fc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a700:	f9 b8 05 00 	movlt	r8,0
8000a704:	40 4b       	lddsp	r11,sp[0x10]
8000a706:	12 0b       	add	r11,r9
8000a708:	50 08       	stdsp	sp[0x0],r8
8000a70a:	50 4b       	stdsp	sp[0x10],r11
8000a70c:	12 00       	add	r0,r9
8000a70e:	30 1b       	mov	r11,1
8000a710:	0e 9c       	mov	r12,r7
8000a712:	e0 a0 08 a7 	rcall	8000b860 <__i2b>
8000a716:	40 08       	lddsp	r8,sp[0x0]
8000a718:	18 94       	mov	r4,r12
8000a71a:	40 4a       	lddsp	r10,sp[0x10]
8000a71c:	58 05       	cp.w	r5,0
8000a71e:	5f 99       	srgt	r9
8000a720:	58 0a       	cp.w	r10,0
8000a722:	5f 9a       	srgt	r10
8000a724:	f5 e9 00 09 	and	r9,r10,r9
8000a728:	c0 80       	breq	8000a738 <_dtoa_r+0x7e4>
8000a72a:	40 4c       	lddsp	r12,sp[0x10]
8000a72c:	f8 05 0d 49 	min	r9,r12,r5
8000a730:	12 1c       	sub	r12,r9
8000a732:	12 10       	sub	r0,r9
8000a734:	50 4c       	stdsp	sp[0x10],r12
8000a736:	12 15       	sub	r5,r9
8000a738:	58 02       	cp.w	r2,0
8000a73a:	e0 8a 00 27 	brle	8000a788 <_dtoa_r+0x834>
8000a73e:	40 db       	lddsp	r11,sp[0x34]
8000a740:	58 0b       	cp.w	r11,0
8000a742:	c1 d0       	breq	8000a77c <_dtoa_r+0x828>
8000a744:	58 08       	cp.w	r8,0
8000a746:	e0 8a 00 17 	brle	8000a774 <_dtoa_r+0x820>
8000a74a:	10 9a       	mov	r10,r8
8000a74c:	50 08       	stdsp	sp[0x0],r8
8000a74e:	08 9b       	mov	r11,r4
8000a750:	0e 9c       	mov	r12,r7
8000a752:	e0 a0 08 cd 	rcall	8000b8ec <__pow5mult>
8000a756:	06 9a       	mov	r10,r3
8000a758:	18 9b       	mov	r11,r12
8000a75a:	18 94       	mov	r4,r12
8000a75c:	0e 9c       	mov	r12,r7
8000a75e:	e0 a0 08 01 	rcall	8000b760 <__multiply>
8000a762:	18 99       	mov	r9,r12
8000a764:	06 9b       	mov	r11,r3
8000a766:	50 19       	stdsp	sp[0x4],r9
8000a768:	0e 9c       	mov	r12,r7
8000a76a:	e0 a0 06 ad 	rcall	8000b4c4 <_Bfree>
8000a76e:	40 19       	lddsp	r9,sp[0x4]
8000a770:	40 08       	lddsp	r8,sp[0x0]
8000a772:	12 93       	mov	r3,r9
8000a774:	e4 08 01 0a 	sub	r10,r2,r8
8000a778:	c0 80       	breq	8000a788 <_dtoa_r+0x834>
8000a77a:	c0 28       	rjmp	8000a77e <_dtoa_r+0x82a>
8000a77c:	04 9a       	mov	r10,r2
8000a77e:	06 9b       	mov	r11,r3
8000a780:	0e 9c       	mov	r12,r7
8000a782:	e0 a0 08 b5 	rcall	8000b8ec <__pow5mult>
8000a786:	18 93       	mov	r3,r12
8000a788:	30 1b       	mov	r11,1
8000a78a:	0e 9c       	mov	r12,r7
8000a78c:	e0 a0 08 6a 	rcall	8000b860 <__i2b>
8000a790:	41 1a       	lddsp	r10,sp[0x44]
8000a792:	18 92       	mov	r2,r12
8000a794:	58 0a       	cp.w	r10,0
8000a796:	e0 8a 00 07 	brle	8000a7a4 <_dtoa_r+0x850>
8000a79a:	18 9b       	mov	r11,r12
8000a79c:	0e 9c       	mov	r12,r7
8000a79e:	e0 a0 08 a7 	rcall	8000b8ec <__pow5mult>
8000a7a2:	18 92       	mov	r2,r12
8000a7a4:	40 c9       	lddsp	r9,sp[0x30]
8000a7a6:	58 19       	cp.w	r9,1
8000a7a8:	e0 89 00 14 	brgt	8000a7d0 <_dtoa_r+0x87c>
8000a7ac:	40 38       	lddsp	r8,sp[0xc]
8000a7ae:	58 08       	cp.w	r8,0
8000a7b0:	c1 01       	brne	8000a7d0 <_dtoa_r+0x87c>
8000a7b2:	40 29       	lddsp	r9,sp[0x8]
8000a7b4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a7b8:	c0 c1       	brne	8000a7d0 <_dtoa_r+0x87c>
8000a7ba:	12 98       	mov	r8,r9
8000a7bc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a7c0:	c0 80       	breq	8000a7d0 <_dtoa_r+0x87c>
8000a7c2:	40 4c       	lddsp	r12,sp[0x10]
8000a7c4:	30 1b       	mov	r11,1
8000a7c6:	2f fc       	sub	r12,-1
8000a7c8:	2f f0       	sub	r0,-1
8000a7ca:	50 4c       	stdsp	sp[0x10],r12
8000a7cc:	50 6b       	stdsp	sp[0x18],r11
8000a7ce:	c0 38       	rjmp	8000a7d4 <_dtoa_r+0x880>
8000a7d0:	30 0a       	mov	r10,0
8000a7d2:	50 6a       	stdsp	sp[0x18],r10
8000a7d4:	41 19       	lddsp	r9,sp[0x44]
8000a7d6:	58 09       	cp.w	r9,0
8000a7d8:	c0 31       	brne	8000a7de <_dtoa_r+0x88a>
8000a7da:	30 1c       	mov	r12,1
8000a7dc:	c0 98       	rjmp	8000a7ee <_dtoa_r+0x89a>
8000a7de:	64 48       	ld.w	r8,r2[0x10]
8000a7e0:	2f c8       	sub	r8,-4
8000a7e2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a7e6:	e0 a0 05 df 	rcall	8000b3a4 <__hi0bits>
8000a7ea:	f8 0c 11 20 	rsub	r12,r12,32
8000a7ee:	40 4b       	lddsp	r11,sp[0x10]
8000a7f0:	f8 0b 00 08 	add	r8,r12,r11
8000a7f4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a7f8:	c0 c0       	breq	8000a810 <_dtoa_r+0x8bc>
8000a7fa:	f0 08 11 20 	rsub	r8,r8,32
8000a7fe:	58 48       	cp.w	r8,4
8000a800:	e0 8a 00 06 	brle	8000a80c <_dtoa_r+0x8b8>
8000a804:	20 48       	sub	r8,4
8000a806:	10 0b       	add	r11,r8
8000a808:	50 4b       	stdsp	sp[0x10],r11
8000a80a:	c0 78       	rjmp	8000a818 <_dtoa_r+0x8c4>
8000a80c:	58 48       	cp.w	r8,4
8000a80e:	c0 70       	breq	8000a81c <_dtoa_r+0x8c8>
8000a810:	40 4a       	lddsp	r10,sp[0x10]
8000a812:	2e 48       	sub	r8,-28
8000a814:	10 0a       	add	r10,r8
8000a816:	50 4a       	stdsp	sp[0x10],r10
8000a818:	10 00       	add	r0,r8
8000a81a:	10 05       	add	r5,r8
8000a81c:	58 00       	cp.w	r0,0
8000a81e:	e0 8a 00 08 	brle	8000a82e <_dtoa_r+0x8da>
8000a822:	06 9b       	mov	r11,r3
8000a824:	00 9a       	mov	r10,r0
8000a826:	0e 9c       	mov	r12,r7
8000a828:	e0 a0 07 58 	rcall	8000b6d8 <__lshift>
8000a82c:	18 93       	mov	r3,r12
8000a82e:	40 49       	lddsp	r9,sp[0x10]
8000a830:	58 09       	cp.w	r9,0
8000a832:	e0 8a 00 08 	brle	8000a842 <_dtoa_r+0x8ee>
8000a836:	04 9b       	mov	r11,r2
8000a838:	12 9a       	mov	r10,r9
8000a83a:	0e 9c       	mov	r12,r7
8000a83c:	e0 a0 07 4e 	rcall	8000b6d8 <__lshift>
8000a840:	18 92       	mov	r2,r12
8000a842:	41 48       	lddsp	r8,sp[0x50]
8000a844:	58 08       	cp.w	r8,0
8000a846:	c1 b0       	breq	8000a87c <_dtoa_r+0x928>
8000a848:	04 9b       	mov	r11,r2
8000a84a:	06 9c       	mov	r12,r3
8000a84c:	e0 a0 06 23 	rcall	8000b492 <__mcmp>
8000a850:	c1 64       	brge	8000a87c <_dtoa_r+0x928>
8000a852:	06 9b       	mov	r11,r3
8000a854:	30 09       	mov	r9,0
8000a856:	30 aa       	mov	r10,10
8000a858:	0e 9c       	mov	r12,r7
8000a85a:	e0 a0 08 0b 	rcall	8000b870 <__multadd>
8000a85e:	20 16       	sub	r6,1
8000a860:	18 93       	mov	r3,r12
8000a862:	40 dc       	lddsp	r12,sp[0x34]
8000a864:	58 0c       	cp.w	r12,0
8000a866:	c0 31       	brne	8000a86c <_dtoa_r+0x918>
8000a868:	40 91       	lddsp	r1,sp[0x24]
8000a86a:	c0 98       	rjmp	8000a87c <_dtoa_r+0x928>
8000a86c:	08 9b       	mov	r11,r4
8000a86e:	40 91       	lddsp	r1,sp[0x24]
8000a870:	30 09       	mov	r9,0
8000a872:	30 aa       	mov	r10,10
8000a874:	0e 9c       	mov	r12,r7
8000a876:	e0 a0 07 fd 	rcall	8000b870 <__multadd>
8000a87a:	18 94       	mov	r4,r12
8000a87c:	58 01       	cp.w	r1,0
8000a87e:	5f a9       	srle	r9
8000a880:	40 cb       	lddsp	r11,sp[0x30]
8000a882:	58 2b       	cp.w	r11,2
8000a884:	5f 98       	srgt	r8
8000a886:	f3 e8 00 08 	and	r8,r9,r8
8000a88a:	c2 50       	breq	8000a8d4 <_dtoa_r+0x980>
8000a88c:	58 01       	cp.w	r1,0
8000a88e:	c1 11       	brne	8000a8b0 <_dtoa_r+0x95c>
8000a890:	04 9b       	mov	r11,r2
8000a892:	02 99       	mov	r9,r1
8000a894:	30 5a       	mov	r10,5
8000a896:	0e 9c       	mov	r12,r7
8000a898:	e0 a0 07 ec 	rcall	8000b870 <__multadd>
8000a89c:	18 92       	mov	r2,r12
8000a89e:	18 9b       	mov	r11,r12
8000a8a0:	06 9c       	mov	r12,r3
8000a8a2:	e0 a0 05 f8 	rcall	8000b492 <__mcmp>
8000a8a6:	e0 89 00 0f 	brgt	8000a8c4 <_dtoa_r+0x970>
8000a8aa:	c0 38       	rjmp	8000a8b0 <_dtoa_r+0x95c>
8000a8ac:	30 02       	mov	r2,0
8000a8ae:	04 94       	mov	r4,r2
8000a8b0:	40 ea       	lddsp	r10,sp[0x38]
8000a8b2:	30 09       	mov	r9,0
8000a8b4:	5c da       	com	r10
8000a8b6:	40 85       	lddsp	r5,sp[0x20]
8000a8b8:	50 6a       	stdsp	sp[0x18],r10
8000a8ba:	50 49       	stdsp	sp[0x10],r9
8000a8bc:	c0 f9       	rjmp	8000aada <_dtoa_r+0xb86>
8000a8be:	08 92       	mov	r2,r4
8000a8c0:	40 66       	lddsp	r6,sp[0x18]
8000a8c2:	04 94       	mov	r4,r2
8000a8c4:	2f f6       	sub	r6,-1
8000a8c6:	50 66       	stdsp	sp[0x18],r6
8000a8c8:	33 18       	mov	r8,49
8000a8ca:	40 85       	lddsp	r5,sp[0x20]
8000a8cc:	0a c8       	st.b	r5++,r8
8000a8ce:	30 08       	mov	r8,0
8000a8d0:	50 48       	stdsp	sp[0x10],r8
8000a8d2:	c0 49       	rjmp	8000aada <_dtoa_r+0xb86>
8000a8d4:	40 dc       	lddsp	r12,sp[0x34]
8000a8d6:	58 0c       	cp.w	r12,0
8000a8d8:	e0 80 00 b5 	breq	8000aa42 <_dtoa_r+0xaee>
8000a8dc:	58 05       	cp.w	r5,0
8000a8de:	e0 8a 00 08 	brle	8000a8ee <_dtoa_r+0x99a>
8000a8e2:	08 9b       	mov	r11,r4
8000a8e4:	0a 9a       	mov	r10,r5
8000a8e6:	0e 9c       	mov	r12,r7
8000a8e8:	e0 a0 06 f8 	rcall	8000b6d8 <__lshift>
8000a8ec:	18 94       	mov	r4,r12
8000a8ee:	40 6b       	lddsp	r11,sp[0x18]
8000a8f0:	58 0b       	cp.w	r11,0
8000a8f2:	c0 31       	brne	8000a8f8 <_dtoa_r+0x9a4>
8000a8f4:	08 9c       	mov	r12,r4
8000a8f6:	c1 38       	rjmp	8000a91c <_dtoa_r+0x9c8>
8000a8f8:	68 1b       	ld.w	r11,r4[0x4]
8000a8fa:	0e 9c       	mov	r12,r7
8000a8fc:	e0 a0 05 fe 	rcall	8000b4f8 <_Balloc>
8000a900:	68 4a       	ld.w	r10,r4[0x10]
8000a902:	18 95       	mov	r5,r12
8000a904:	e8 cb ff f4 	sub	r11,r4,-12
8000a908:	2f ea       	sub	r10,-2
8000a90a:	2f 4c       	sub	r12,-12
8000a90c:	a3 6a       	lsl	r10,0x2
8000a90e:	fe b0 e6 4f 	rcall	800075ac <memcpy>
8000a912:	0a 9b       	mov	r11,r5
8000a914:	30 1a       	mov	r10,1
8000a916:	0e 9c       	mov	r12,r7
8000a918:	e0 a0 06 e0 	rcall	8000b6d8 <__lshift>
8000a91c:	50 44       	stdsp	sp[0x10],r4
8000a91e:	40 3a       	lddsp	r10,sp[0xc]
8000a920:	30 19       	mov	r9,1
8000a922:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a926:	18 94       	mov	r4,r12
8000a928:	50 da       	stdsp	sp[0x34],r10
8000a92a:	40 85       	lddsp	r5,sp[0x20]
8000a92c:	50 99       	stdsp	sp[0x24],r9
8000a92e:	50 26       	stdsp	sp[0x8],r6
8000a930:	50 e1       	stdsp	sp[0x38],r1
8000a932:	04 9b       	mov	r11,r2
8000a934:	06 9c       	mov	r12,r3
8000a936:	fe b0 fa 7f 	rcall	80009e34 <quorem>
8000a93a:	40 4b       	lddsp	r11,sp[0x10]
8000a93c:	f8 c0 ff d0 	sub	r0,r12,-48
8000a940:	06 9c       	mov	r12,r3
8000a942:	e0 a0 05 a8 	rcall	8000b492 <__mcmp>
8000a946:	08 9a       	mov	r10,r4
8000a948:	50 6c       	stdsp	sp[0x18],r12
8000a94a:	04 9b       	mov	r11,r2
8000a94c:	0e 9c       	mov	r12,r7
8000a94e:	e0 a0 06 5d 	rcall	8000b608 <__mdiff>
8000a952:	18 91       	mov	r1,r12
8000a954:	78 38       	ld.w	r8,r12[0xc]
8000a956:	58 08       	cp.w	r8,0
8000a958:	c0 30       	breq	8000a95e <_dtoa_r+0xa0a>
8000a95a:	30 16       	mov	r6,1
8000a95c:	c0 68       	rjmp	8000a968 <_dtoa_r+0xa14>
8000a95e:	18 9b       	mov	r11,r12
8000a960:	06 9c       	mov	r12,r3
8000a962:	e0 a0 05 98 	rcall	8000b492 <__mcmp>
8000a966:	18 96       	mov	r6,r12
8000a968:	0e 9c       	mov	r12,r7
8000a96a:	02 9b       	mov	r11,r1
8000a96c:	e0 a0 05 ac 	rcall	8000b4c4 <_Bfree>
8000a970:	40 cc       	lddsp	r12,sp[0x30]
8000a972:	ed ec 10 08 	or	r8,r6,r12
8000a976:	c0 d1       	brne	8000a990 <_dtoa_r+0xa3c>
8000a978:	40 db       	lddsp	r11,sp[0x34]
8000a97a:	58 0b       	cp.w	r11,0
8000a97c:	c0 a1       	brne	8000a990 <_dtoa_r+0xa3c>
8000a97e:	40 26       	lddsp	r6,sp[0x8]
8000a980:	e0 40 00 39 	cp.w	r0,57
8000a984:	c3 00       	breq	8000a9e4 <_dtoa_r+0xa90>
8000a986:	40 6a       	lddsp	r10,sp[0x18]
8000a988:	58 0a       	cp.w	r10,0
8000a98a:	e0 89 00 24 	brgt	8000a9d2 <_dtoa_r+0xa7e>
8000a98e:	c2 f8       	rjmp	8000a9ec <_dtoa_r+0xa98>
8000a990:	40 69       	lddsp	r9,sp[0x18]
8000a992:	58 09       	cp.w	r9,0
8000a994:	c0 85       	brlt	8000a9a4 <_dtoa_r+0xa50>
8000a996:	12 98       	mov	r8,r9
8000a998:	40 cc       	lddsp	r12,sp[0x30]
8000a99a:	18 48       	or	r8,r12
8000a99c:	c1 d1       	brne	8000a9d6 <_dtoa_r+0xa82>
8000a99e:	40 db       	lddsp	r11,sp[0x34]
8000a9a0:	58 0b       	cp.w	r11,0
8000a9a2:	c1 a1       	brne	8000a9d6 <_dtoa_r+0xa82>
8000a9a4:	0c 99       	mov	r9,r6
8000a9a6:	40 26       	lddsp	r6,sp[0x8]
8000a9a8:	58 09       	cp.w	r9,0
8000a9aa:	e0 8a 00 21 	brle	8000a9ec <_dtoa_r+0xa98>
8000a9ae:	06 9b       	mov	r11,r3
8000a9b0:	30 1a       	mov	r10,1
8000a9b2:	0e 9c       	mov	r12,r7
8000a9b4:	e0 a0 06 92 	rcall	8000b6d8 <__lshift>
8000a9b8:	04 9b       	mov	r11,r2
8000a9ba:	18 93       	mov	r3,r12
8000a9bc:	e0 a0 05 6b 	rcall	8000b492 <__mcmp>
8000a9c0:	e0 89 00 06 	brgt	8000a9cc <_dtoa_r+0xa78>
8000a9c4:	c1 41       	brne	8000a9ec <_dtoa_r+0xa98>
8000a9c6:	ed b0 00 00 	bld	r0,0x0
8000a9ca:	c1 11       	brne	8000a9ec <_dtoa_r+0xa98>
8000a9cc:	e0 40 00 39 	cp.w	r0,57
8000a9d0:	c0 a0       	breq	8000a9e4 <_dtoa_r+0xa90>
8000a9d2:	2f f0       	sub	r0,-1
8000a9d4:	c0 c8       	rjmp	8000a9ec <_dtoa_r+0xa98>
8000a9d6:	58 06       	cp.w	r6,0
8000a9d8:	e0 8a 00 0c 	brle	8000a9f0 <_dtoa_r+0xa9c>
8000a9dc:	40 26       	lddsp	r6,sp[0x8]
8000a9de:	e0 40 00 39 	cp.w	r0,57
8000a9e2:	c0 41       	brne	8000a9ea <_dtoa_r+0xa96>
8000a9e4:	33 98       	mov	r8,57
8000a9e6:	0a c8       	st.b	r5++,r8
8000a9e8:	c6 78       	rjmp	8000aab6 <_dtoa_r+0xb62>
8000a9ea:	2f f0       	sub	r0,-1
8000a9ec:	0a c0       	st.b	r5++,r0
8000a9ee:	c7 58       	rjmp	8000aad8 <_dtoa_r+0xb84>
8000a9f0:	0a c0       	st.b	r5++,r0
8000a9f2:	40 9a       	lddsp	r10,sp[0x24]
8000a9f4:	40 e9       	lddsp	r9,sp[0x38]
8000a9f6:	12 3a       	cp.w	r10,r9
8000a9f8:	c4 30       	breq	8000aa7e <_dtoa_r+0xb2a>
8000a9fa:	06 9b       	mov	r11,r3
8000a9fc:	30 09       	mov	r9,0
8000a9fe:	30 aa       	mov	r10,10
8000aa00:	0e 9c       	mov	r12,r7
8000aa02:	e0 a0 07 37 	rcall	8000b870 <__multadd>
8000aa06:	40 48       	lddsp	r8,sp[0x10]
8000aa08:	18 93       	mov	r3,r12
8000aa0a:	08 38       	cp.w	r8,r4
8000aa0c:	c0 91       	brne	8000aa1e <_dtoa_r+0xaca>
8000aa0e:	10 9b       	mov	r11,r8
8000aa10:	30 09       	mov	r9,0
8000aa12:	30 aa       	mov	r10,10
8000aa14:	0e 9c       	mov	r12,r7
8000aa16:	e0 a0 07 2d 	rcall	8000b870 <__multadd>
8000aa1a:	50 4c       	stdsp	sp[0x10],r12
8000aa1c:	c0 e8       	rjmp	8000aa38 <_dtoa_r+0xae4>
8000aa1e:	40 4b       	lddsp	r11,sp[0x10]
8000aa20:	30 09       	mov	r9,0
8000aa22:	30 aa       	mov	r10,10
8000aa24:	0e 9c       	mov	r12,r7
8000aa26:	e0 a0 07 25 	rcall	8000b870 <__multadd>
8000aa2a:	08 9b       	mov	r11,r4
8000aa2c:	50 4c       	stdsp	sp[0x10],r12
8000aa2e:	30 09       	mov	r9,0
8000aa30:	30 aa       	mov	r10,10
8000aa32:	0e 9c       	mov	r12,r7
8000aa34:	e0 a0 07 1e 	rcall	8000b870 <__multadd>
8000aa38:	18 94       	mov	r4,r12
8000aa3a:	40 9c       	lddsp	r12,sp[0x24]
8000aa3c:	2f fc       	sub	r12,-1
8000aa3e:	50 9c       	stdsp	sp[0x24],r12
8000aa40:	c7 9b       	rjmp	8000a932 <_dtoa_r+0x9de>
8000aa42:	30 18       	mov	r8,1
8000aa44:	06 90       	mov	r0,r3
8000aa46:	40 85       	lddsp	r5,sp[0x20]
8000aa48:	08 93       	mov	r3,r4
8000aa4a:	0c 94       	mov	r4,r6
8000aa4c:	10 96       	mov	r6,r8
8000aa4e:	04 9b       	mov	r11,r2
8000aa50:	00 9c       	mov	r12,r0
8000aa52:	fe b0 f9 f1 	rcall	80009e34 <quorem>
8000aa56:	2d 0c       	sub	r12,-48
8000aa58:	0a cc       	st.b	r5++,r12
8000aa5a:	02 36       	cp.w	r6,r1
8000aa5c:	c0 a4       	brge	8000aa70 <_dtoa_r+0xb1c>
8000aa5e:	00 9b       	mov	r11,r0
8000aa60:	30 09       	mov	r9,0
8000aa62:	30 aa       	mov	r10,10
8000aa64:	0e 9c       	mov	r12,r7
8000aa66:	2f f6       	sub	r6,-1
8000aa68:	e0 a0 07 04 	rcall	8000b870 <__multadd>
8000aa6c:	18 90       	mov	r0,r12
8000aa6e:	cf 0b       	rjmp	8000aa4e <_dtoa_r+0xafa>
8000aa70:	08 96       	mov	r6,r4
8000aa72:	30 0b       	mov	r11,0
8000aa74:	06 94       	mov	r4,r3
8000aa76:	50 4b       	stdsp	sp[0x10],r11
8000aa78:	00 93       	mov	r3,r0
8000aa7a:	18 90       	mov	r0,r12
8000aa7c:	c0 28       	rjmp	8000aa80 <_dtoa_r+0xb2c>
8000aa7e:	40 26       	lddsp	r6,sp[0x8]
8000aa80:	06 9b       	mov	r11,r3
8000aa82:	30 1a       	mov	r10,1
8000aa84:	0e 9c       	mov	r12,r7
8000aa86:	e0 a0 06 29 	rcall	8000b6d8 <__lshift>
8000aa8a:	04 9b       	mov	r11,r2
8000aa8c:	18 93       	mov	r3,r12
8000aa8e:	e0 a0 05 02 	rcall	8000b492 <__mcmp>
8000aa92:	e0 89 00 12 	brgt	8000aab6 <_dtoa_r+0xb62>
8000aa96:	c1 b1       	brne	8000aacc <_dtoa_r+0xb78>
8000aa98:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000aa9c:	c0 d1       	brne	8000aab6 <_dtoa_r+0xb62>
8000aa9e:	c1 78       	rjmp	8000aacc <_dtoa_r+0xb78>
8000aaa0:	40 89       	lddsp	r9,sp[0x20]
8000aaa2:	12 38       	cp.w	r8,r9
8000aaa4:	c0 30       	breq	8000aaaa <_dtoa_r+0xb56>
8000aaa6:	10 95       	mov	r5,r8
8000aaa8:	c0 88       	rjmp	8000aab8 <_dtoa_r+0xb64>
8000aaaa:	2f f6       	sub	r6,-1
8000aaac:	50 66       	stdsp	sp[0x18],r6
8000aaae:	33 18       	mov	r8,49
8000aab0:	40 8c       	lddsp	r12,sp[0x20]
8000aab2:	b8 88       	st.b	r12[0x0],r8
8000aab4:	c1 38       	rjmp	8000aada <_dtoa_r+0xb86>
8000aab6:	33 9a       	mov	r10,57
8000aab8:	0a 98       	mov	r8,r5
8000aaba:	11 79       	ld.ub	r9,--r8
8000aabc:	f4 09 18 00 	cp.b	r9,r10
8000aac0:	cf 00       	breq	8000aaa0 <_dtoa_r+0xb4c>
8000aac2:	2f f9       	sub	r9,-1
8000aac4:	b0 89       	st.b	r8[0x0],r9
8000aac6:	c0 98       	rjmp	8000aad8 <_dtoa_r+0xb84>
8000aac8:	10 95       	mov	r5,r8
8000aaca:	c0 28       	rjmp	8000aace <_dtoa_r+0xb7a>
8000aacc:	33 09       	mov	r9,48
8000aace:	0a 98       	mov	r8,r5
8000aad0:	11 7a       	ld.ub	r10,--r8
8000aad2:	f2 0a 18 00 	cp.b	r10,r9
8000aad6:	cf 90       	breq	8000aac8 <_dtoa_r+0xb74>
8000aad8:	50 66       	stdsp	sp[0x18],r6
8000aada:	04 9b       	mov	r11,r2
8000aadc:	0e 9c       	mov	r12,r7
8000aade:	e0 a0 04 f3 	rcall	8000b4c4 <_Bfree>
8000aae2:	58 04       	cp.w	r4,0
8000aae4:	c1 20       	breq	8000ab08 <_dtoa_r+0xbb4>
8000aae6:	40 4b       	lddsp	r11,sp[0x10]
8000aae8:	08 3b       	cp.w	r11,r4
8000aaea:	5f 19       	srne	r9
8000aaec:	58 0b       	cp.w	r11,0
8000aaee:	5f 18       	srne	r8
8000aaf0:	f3 e8 00 08 	and	r8,r9,r8
8000aaf4:	c0 40       	breq	8000aafc <_dtoa_r+0xba8>
8000aaf6:	0e 9c       	mov	r12,r7
8000aaf8:	e0 a0 04 e6 	rcall	8000b4c4 <_Bfree>
8000aafc:	08 9b       	mov	r11,r4
8000aafe:	0e 9c       	mov	r12,r7
8000ab00:	e0 a0 04 e2 	rcall	8000b4c4 <_Bfree>
8000ab04:	c0 28       	rjmp	8000ab08 <_dtoa_r+0xbb4>
8000ab06:	50 66       	stdsp	sp[0x18],r6
8000ab08:	0e 9c       	mov	r12,r7
8000ab0a:	06 9b       	mov	r11,r3
8000ab0c:	e0 a0 04 dc 	rcall	8000b4c4 <_Bfree>
8000ab10:	30 08       	mov	r8,0
8000ab12:	aa 88       	st.b	r5[0x0],r8
8000ab14:	40 68       	lddsp	r8,sp[0x18]
8000ab16:	41 5a       	lddsp	r10,sp[0x54]
8000ab18:	2f f8       	sub	r8,-1
8000ab1a:	41 29       	lddsp	r9,sp[0x48]
8000ab1c:	95 08       	st.w	r10[0x0],r8
8000ab1e:	40 8c       	lddsp	r12,sp[0x20]
8000ab20:	58 09       	cp.w	r9,0
8000ab22:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ab26:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ab2a:	2e 6d       	sub	sp,-104
8000ab2c:	d8 32       	popm	r0-r7,pc
8000ab2e:	d7 03       	nop

8000ab30 <__errno>:
8000ab30:	e0 68 0a 3c 	mov	r8,2620
8000ab34:	70 0c       	ld.w	r12,r8[0x0]
8000ab36:	2f 4c       	sub	r12,-12
8000ab38:	5e fc       	retal	r12
8000ab3a:	d7 03       	nop

8000ab3c <_fflush_r>:
8000ab3c:	d4 21       	pushm	r4-r7,lr
8000ab3e:	16 97       	mov	r7,r11
8000ab40:	18 96       	mov	r6,r12
8000ab42:	76 48       	ld.w	r8,r11[0x10]
8000ab44:	58 08       	cp.w	r8,0
8000ab46:	c7 f0       	breq	8000ac44 <_fflush_r+0x108>
8000ab48:	58 0c       	cp.w	r12,0
8000ab4a:	c0 50       	breq	8000ab54 <_fflush_r+0x18>
8000ab4c:	78 68       	ld.w	r8,r12[0x18]
8000ab4e:	58 08       	cp.w	r8,0
8000ab50:	c0 21       	brne	8000ab54 <_fflush_r+0x18>
8000ab52:	cc dc       	rcall	8000acec <__sinit>
8000ab54:	fe c8 cc a8 	sub	r8,pc,-13144
8000ab58:	10 37       	cp.w	r7,r8
8000ab5a:	c0 31       	brne	8000ab60 <_fflush_r+0x24>
8000ab5c:	6c 07       	ld.w	r7,r6[0x0]
8000ab5e:	c0 c8       	rjmp	8000ab76 <_fflush_r+0x3a>
8000ab60:	fe c8 cc 94 	sub	r8,pc,-13164
8000ab64:	10 37       	cp.w	r7,r8
8000ab66:	c0 31       	brne	8000ab6c <_fflush_r+0x30>
8000ab68:	6c 17       	ld.w	r7,r6[0x4]
8000ab6a:	c0 68       	rjmp	8000ab76 <_fflush_r+0x3a>
8000ab6c:	fe c8 cc 80 	sub	r8,pc,-13184
8000ab70:	10 37       	cp.w	r7,r8
8000ab72:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ab76:	8e 6a       	ld.sh	r10,r7[0xc]
8000ab78:	14 98       	mov	r8,r10
8000ab7a:	ed ba 00 03 	bld	r10,0x3
8000ab7e:	c4 20       	breq	8000ac02 <_fflush_r+0xc6>
8000ab80:	ab ba       	sbr	r10,0xb
8000ab82:	ae 6a       	st.h	r7[0xc],r10
8000ab84:	6e 18       	ld.w	r8,r7[0x4]
8000ab86:	58 08       	cp.w	r8,0
8000ab88:	e0 89 00 06 	brgt	8000ab94 <_fflush_r+0x58>
8000ab8c:	6f 08       	ld.w	r8,r7[0x40]
8000ab8e:	58 08       	cp.w	r8,0
8000ab90:	e0 8a 00 5a 	brle	8000ac44 <_fflush_r+0x108>
8000ab94:	6e b8       	ld.w	r8,r7[0x2c]
8000ab96:	58 08       	cp.w	r8,0
8000ab98:	c5 60       	breq	8000ac44 <_fflush_r+0x108>
8000ab9a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ab9e:	c0 30       	breq	8000aba4 <_fflush_r+0x68>
8000aba0:	6f 55       	ld.w	r5,r7[0x54]
8000aba2:	c0 f8       	rjmp	8000abc0 <_fflush_r+0x84>
8000aba4:	30 19       	mov	r9,1
8000aba6:	6e 8b       	ld.w	r11,r7[0x20]
8000aba8:	0c 9c       	mov	r12,r6
8000abaa:	5d 18       	icall	r8
8000abac:	18 95       	mov	r5,r12
8000abae:	5b fc       	cp.w	r12,-1
8000abb0:	c0 81       	brne	8000abc0 <_fflush_r+0x84>
8000abb2:	6c 38       	ld.w	r8,r6[0xc]
8000abb4:	59 d8       	cp.w	r8,29
8000abb6:	c4 70       	breq	8000ac44 <_fflush_r+0x108>
8000abb8:	8e 68       	ld.sh	r8,r7[0xc]
8000abba:	a7 a8       	sbr	r8,0x6
8000abbc:	ae 68       	st.h	r7[0xc],r8
8000abbe:	d8 22       	popm	r4-r7,pc
8000abc0:	8e 68       	ld.sh	r8,r7[0xc]
8000abc2:	ed b8 00 02 	bld	r8,0x2
8000abc6:	c0 91       	brne	8000abd8 <_fflush_r+0x9c>
8000abc8:	6e 18       	ld.w	r8,r7[0x4]
8000abca:	10 15       	sub	r5,r8
8000abcc:	6e d8       	ld.w	r8,r7[0x34]
8000abce:	58 08       	cp.w	r8,0
8000abd0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000abd4:	eb d8 e1 15 	subne	r5,r5,r8
8000abd8:	6e b8       	ld.w	r8,r7[0x2c]
8000abda:	0c 9c       	mov	r12,r6
8000abdc:	30 09       	mov	r9,0
8000abde:	0a 9a       	mov	r10,r5
8000abe0:	6e 8b       	ld.w	r11,r7[0x20]
8000abe2:	5d 18       	icall	r8
8000abe4:	8e 68       	ld.sh	r8,r7[0xc]
8000abe6:	0a 3c       	cp.w	r12,r5
8000abe8:	c2 61       	brne	8000ac34 <_fflush_r+0xf8>
8000abea:	ab d8       	cbr	r8,0xb
8000abec:	30 0c       	mov	r12,0
8000abee:	6e 49       	ld.w	r9,r7[0x10]
8000abf0:	ae 68       	st.h	r7[0xc],r8
8000abf2:	8f 1c       	st.w	r7[0x4],r12
8000abf4:	8f 09       	st.w	r7[0x0],r9
8000abf6:	ed b8 00 0c 	bld	r8,0xc
8000abfa:	c2 51       	brne	8000ac44 <_fflush_r+0x108>
8000abfc:	ef 45 00 54 	st.w	r7[84],r5
8000ac00:	d8 22       	popm	r4-r7,pc
8000ac02:	6e 45       	ld.w	r5,r7[0x10]
8000ac04:	58 05       	cp.w	r5,0
8000ac06:	c1 f0       	breq	8000ac44 <_fflush_r+0x108>
8000ac08:	6e 04       	ld.w	r4,r7[0x0]
8000ac0a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ac0e:	8f 05       	st.w	r7[0x0],r5
8000ac10:	f9 b8 01 00 	movne	r8,0
8000ac14:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ac18:	0a 14       	sub	r4,r5
8000ac1a:	8f 28       	st.w	r7[0x8],r8
8000ac1c:	c1 18       	rjmp	8000ac3e <_fflush_r+0x102>
8000ac1e:	08 99       	mov	r9,r4
8000ac20:	0a 9a       	mov	r10,r5
8000ac22:	6e a8       	ld.w	r8,r7[0x28]
8000ac24:	6e 8b       	ld.w	r11,r7[0x20]
8000ac26:	0c 9c       	mov	r12,r6
8000ac28:	5d 18       	icall	r8
8000ac2a:	18 14       	sub	r4,r12
8000ac2c:	58 0c       	cp.w	r12,0
8000ac2e:	e0 89 00 07 	brgt	8000ac3c <_fflush_r+0x100>
8000ac32:	8e 68       	ld.sh	r8,r7[0xc]
8000ac34:	a7 a8       	sbr	r8,0x6
8000ac36:	3f fc       	mov	r12,-1
8000ac38:	ae 68       	st.h	r7[0xc],r8
8000ac3a:	d8 22       	popm	r4-r7,pc
8000ac3c:	18 05       	add	r5,r12
8000ac3e:	58 04       	cp.w	r4,0
8000ac40:	fe 99 ff ef 	brgt	8000ac1e <_fflush_r+0xe2>
8000ac44:	d8 2a       	popm	r4-r7,pc,r12=0
8000ac46:	d7 03       	nop

8000ac48 <__sfp_lock_acquire>:
8000ac48:	5e fc       	retal	r12

8000ac4a <__sfp_lock_release>:
8000ac4a:	5e fc       	retal	r12

8000ac4c <_cleanup_r>:
8000ac4c:	d4 01       	pushm	lr
8000ac4e:	fe cb f0 ae 	sub	r11,pc,-3922
8000ac52:	e0 a0 02 f7 	rcall	8000b240 <_fwalk>
8000ac56:	d8 02       	popm	pc

8000ac58 <__sfmoreglue>:
8000ac58:	d4 21       	pushm	r4-r7,lr
8000ac5a:	16 95       	mov	r5,r11
8000ac5c:	f6 06 10 5c 	mul	r6,r11,92
8000ac60:	ec cb ff f4 	sub	r11,r6,-12
8000ac64:	fe b0 e2 88 	rcall	80007174 <_malloc_r>
8000ac68:	18 97       	mov	r7,r12
8000ac6a:	c0 90       	breq	8000ac7c <__sfmoreglue+0x24>
8000ac6c:	99 15       	st.w	r12[0x4],r5
8000ac6e:	30 0b       	mov	r11,0
8000ac70:	2f 4c       	sub	r12,-12
8000ac72:	0c 9a       	mov	r10,r6
8000ac74:	8f 2c       	st.w	r7[0x8],r12
8000ac76:	8f 0b       	st.w	r7[0x0],r11
8000ac78:	fe b0 e5 3e 	rcall	800076f4 <memset>
8000ac7c:	0e 9c       	mov	r12,r7
8000ac7e:	d8 22       	popm	r4-r7,pc

8000ac80 <__sfp>:
8000ac80:	d4 21       	pushm	r4-r7,lr
8000ac82:	fe c8 cd 72 	sub	r8,pc,-12942
8000ac86:	18 96       	mov	r6,r12
8000ac88:	70 07       	ld.w	r7,r8[0x0]
8000ac8a:	6e 68       	ld.w	r8,r7[0x18]
8000ac8c:	58 08       	cp.w	r8,0
8000ac8e:	c0 31       	brne	8000ac94 <__sfp+0x14>
8000ac90:	0e 9c       	mov	r12,r7
8000ac92:	c2 dc       	rcall	8000acec <__sinit>
8000ac94:	ee c7 ff 28 	sub	r7,r7,-216
8000ac98:	30 05       	mov	r5,0
8000ac9a:	6e 2c       	ld.w	r12,r7[0x8]
8000ac9c:	6e 18       	ld.w	r8,r7[0x4]
8000ac9e:	c0 68       	rjmp	8000acaa <__sfp+0x2a>
8000aca0:	98 69       	ld.sh	r9,r12[0xc]
8000aca2:	ea 09 19 00 	cp.h	r9,r5
8000aca6:	c1 10       	breq	8000acc8 <__sfp+0x48>
8000aca8:	2a 4c       	sub	r12,-92
8000acaa:	20 18       	sub	r8,1
8000acac:	cf a7       	brpl	8000aca0 <__sfp+0x20>
8000acae:	6e 08       	ld.w	r8,r7[0x0]
8000acb0:	58 08       	cp.w	r8,0
8000acb2:	c0 61       	brne	8000acbe <__sfp+0x3e>
8000acb4:	30 4b       	mov	r11,4
8000acb6:	0c 9c       	mov	r12,r6
8000acb8:	cd 0f       	rcall	8000ac58 <__sfmoreglue>
8000acba:	8f 0c       	st.w	r7[0x0],r12
8000acbc:	c0 30       	breq	8000acc2 <__sfp+0x42>
8000acbe:	6e 07       	ld.w	r7,r7[0x0]
8000acc0:	ce db       	rjmp	8000ac9a <__sfp+0x1a>
8000acc2:	30 c8       	mov	r8,12
8000acc4:	8d 38       	st.w	r6[0xc],r8
8000acc6:	d8 22       	popm	r4-r7,pc
8000acc8:	30 08       	mov	r8,0
8000acca:	f9 48 00 4c 	st.w	r12[76],r8
8000acce:	99 08       	st.w	r12[0x0],r8
8000acd0:	99 28       	st.w	r12[0x8],r8
8000acd2:	99 18       	st.w	r12[0x4],r8
8000acd4:	99 48       	st.w	r12[0x10],r8
8000acd6:	99 58       	st.w	r12[0x14],r8
8000acd8:	99 68       	st.w	r12[0x18],r8
8000acda:	99 d8       	st.w	r12[0x34],r8
8000acdc:	99 e8       	st.w	r12[0x38],r8
8000acde:	f9 48 00 48 	st.w	r12[72],r8
8000ace2:	3f f8       	mov	r8,-1
8000ace4:	b8 78       	st.h	r12[0xe],r8
8000ace6:	30 18       	mov	r8,1
8000ace8:	b8 68       	st.h	r12[0xc],r8
8000acea:	d8 22       	popm	r4-r7,pc

8000acec <__sinit>:
8000acec:	d4 21       	pushm	r4-r7,lr
8000acee:	18 96       	mov	r6,r12
8000acf0:	78 67       	ld.w	r7,r12[0x18]
8000acf2:	58 07       	cp.w	r7,0
8000acf4:	c4 91       	brne	8000ad86 <__sinit+0x9a>
8000acf6:	fe c8 00 aa 	sub	r8,pc,170
8000acfa:	30 15       	mov	r5,1
8000acfc:	99 a8       	st.w	r12[0x28],r8
8000acfe:	f9 47 00 d8 	st.w	r12[216],r7
8000ad02:	f9 47 00 dc 	st.w	r12[220],r7
8000ad06:	f9 47 00 e0 	st.w	r12[224],r7
8000ad0a:	99 65       	st.w	r12[0x18],r5
8000ad0c:	cb af       	rcall	8000ac80 <__sfp>
8000ad0e:	8d 0c       	st.w	r6[0x0],r12
8000ad10:	0c 9c       	mov	r12,r6
8000ad12:	cb 7f       	rcall	8000ac80 <__sfp>
8000ad14:	8d 1c       	st.w	r6[0x4],r12
8000ad16:	0c 9c       	mov	r12,r6
8000ad18:	cb 4f       	rcall	8000ac80 <__sfp>
8000ad1a:	6c 09       	ld.w	r9,r6[0x0]
8000ad1c:	30 48       	mov	r8,4
8000ad1e:	93 07       	st.w	r9[0x0],r7
8000ad20:	b2 68       	st.h	r9[0xc],r8
8000ad22:	93 17       	st.w	r9[0x4],r7
8000ad24:	93 27       	st.w	r9[0x8],r7
8000ad26:	6c 18       	ld.w	r8,r6[0x4]
8000ad28:	b2 77       	st.h	r9[0xe],r7
8000ad2a:	93 47       	st.w	r9[0x10],r7
8000ad2c:	93 57       	st.w	r9[0x14],r7
8000ad2e:	93 67       	st.w	r9[0x18],r7
8000ad30:	93 89       	st.w	r9[0x20],r9
8000ad32:	91 07       	st.w	r8[0x0],r7
8000ad34:	91 17       	st.w	r8[0x4],r7
8000ad36:	91 27       	st.w	r8[0x8],r7
8000ad38:	fe ce f3 24 	sub	lr,pc,-3292
8000ad3c:	fe cb f3 54 	sub	r11,pc,-3244
8000ad40:	93 9e       	st.w	r9[0x24],lr
8000ad42:	93 ab       	st.w	r9[0x28],r11
8000ad44:	fe ca f3 7c 	sub	r10,pc,-3204
8000ad48:	fe c4 f3 88 	sub	r4,pc,-3192
8000ad4c:	93 ba       	st.w	r9[0x2c],r10
8000ad4e:	93 c4       	st.w	r9[0x30],r4
8000ad50:	30 99       	mov	r9,9
8000ad52:	b0 69       	st.h	r8[0xc],r9
8000ad54:	b0 75       	st.h	r8[0xe],r5
8000ad56:	91 c4       	st.w	r8[0x30],r4
8000ad58:	91 47       	st.w	r8[0x10],r7
8000ad5a:	91 57       	st.w	r8[0x14],r7
8000ad5c:	91 67       	st.w	r8[0x18],r7
8000ad5e:	91 88       	st.w	r8[0x20],r8
8000ad60:	91 9e       	st.w	r8[0x24],lr
8000ad62:	91 ab       	st.w	r8[0x28],r11
8000ad64:	91 ba       	st.w	r8[0x2c],r10
8000ad66:	8d 2c       	st.w	r6[0x8],r12
8000ad68:	31 28       	mov	r8,18
8000ad6a:	99 07       	st.w	r12[0x0],r7
8000ad6c:	b8 68       	st.h	r12[0xc],r8
8000ad6e:	99 17       	st.w	r12[0x4],r7
8000ad70:	99 27       	st.w	r12[0x8],r7
8000ad72:	30 28       	mov	r8,2
8000ad74:	b8 78       	st.h	r12[0xe],r8
8000ad76:	99 c4       	st.w	r12[0x30],r4
8000ad78:	99 67       	st.w	r12[0x18],r7
8000ad7a:	99 9e       	st.w	r12[0x24],lr
8000ad7c:	99 ab       	st.w	r12[0x28],r11
8000ad7e:	99 ba       	st.w	r12[0x2c],r10
8000ad80:	99 47       	st.w	r12[0x10],r7
8000ad82:	99 57       	st.w	r12[0x14],r7
8000ad84:	99 8c       	st.w	r12[0x20],r12
8000ad86:	d8 22       	popm	r4-r7,pc

8000ad88 <_malloc_trim_r>:
8000ad88:	d4 21       	pushm	r4-r7,lr
8000ad8a:	16 95       	mov	r5,r11
8000ad8c:	18 97       	mov	r7,r12
8000ad8e:	fe b0 d7 d9 	rcall	80005d40 <__malloc_lock>
8000ad92:	e0 64 05 3c 	mov	r4,1340
8000ad96:	68 28       	ld.w	r8,r4[0x8]
8000ad98:	70 16       	ld.w	r6,r8[0x4]
8000ad9a:	e0 16 ff fc 	andl	r6,0xfffc
8000ad9e:	ec c8 ff 91 	sub	r8,r6,-111
8000ada2:	f0 05 01 05 	sub	r5,r8,r5
8000ada6:	e0 15 ff 80 	andl	r5,0xff80
8000adaa:	ea c5 00 80 	sub	r5,r5,128
8000adae:	e0 45 00 7f 	cp.w	r5,127
8000adb2:	e0 8a 00 25 	brle	8000adfc <_malloc_trim_r+0x74>
8000adb6:	30 0b       	mov	r11,0
8000adb8:	0e 9c       	mov	r12,r7
8000adba:	fe b0 e6 05 	rcall	800079c4 <_sbrk_r>
8000adbe:	68 28       	ld.w	r8,r4[0x8]
8000adc0:	0c 08       	add	r8,r6
8000adc2:	10 3c       	cp.w	r12,r8
8000adc4:	c1 c1       	brne	8000adfc <_malloc_trim_r+0x74>
8000adc6:	ea 0b 11 00 	rsub	r11,r5,0
8000adca:	0e 9c       	mov	r12,r7
8000adcc:	fe b0 e5 fc 	rcall	800079c4 <_sbrk_r>
8000add0:	5b fc       	cp.w	r12,-1
8000add2:	c1 91       	brne	8000ae04 <_malloc_trim_r+0x7c>
8000add4:	30 0b       	mov	r11,0
8000add6:	0e 9c       	mov	r12,r7
8000add8:	fe b0 e5 f6 	rcall	800079c4 <_sbrk_r>
8000addc:	68 28       	ld.w	r8,r4[0x8]
8000adde:	f8 08 01 09 	sub	r9,r12,r8
8000ade2:	58 f9       	cp.w	r9,15
8000ade4:	e0 8a 00 0c 	brle	8000adfc <_malloc_trim_r+0x74>
8000ade8:	a1 a9       	sbr	r9,0x0
8000adea:	91 19       	st.w	r8[0x4],r9
8000adec:	e0 68 09 48 	mov	r8,2376
8000adf0:	70 09       	ld.w	r9,r8[0x0]
8000adf2:	e0 68 0d 68 	mov	r8,3432
8000adf6:	f8 09 01 09 	sub	r9,r12,r9
8000adfa:	91 09       	st.w	r8[0x0],r9
8000adfc:	0e 9c       	mov	r12,r7
8000adfe:	fe b0 d7 a7 	rcall	80005d4c <__malloc_unlock>
8000ae02:	d8 2a       	popm	r4-r7,pc,r12=0
8000ae04:	68 28       	ld.w	r8,r4[0x8]
8000ae06:	0a 16       	sub	r6,r5
8000ae08:	a1 a6       	sbr	r6,0x0
8000ae0a:	91 16       	st.w	r8[0x4],r6
8000ae0c:	e0 68 0d 68 	mov	r8,3432
8000ae10:	70 09       	ld.w	r9,r8[0x0]
8000ae12:	0a 19       	sub	r9,r5
8000ae14:	0e 9c       	mov	r12,r7
8000ae16:	91 09       	st.w	r8[0x0],r9
8000ae18:	fe b0 d7 9a 	rcall	80005d4c <__malloc_unlock>
8000ae1c:	da 2a       	popm	r4-r7,pc,r12=1
8000ae1e:	d7 03       	nop

8000ae20 <_free_r>:
8000ae20:	d4 21       	pushm	r4-r7,lr
8000ae22:	16 96       	mov	r6,r11
8000ae24:	18 97       	mov	r7,r12
8000ae26:	58 0b       	cp.w	r11,0
8000ae28:	e0 80 00 c0 	breq	8000afa8 <_free_r+0x188>
8000ae2c:	fe b0 d7 8a 	rcall	80005d40 <__malloc_lock>
8000ae30:	20 86       	sub	r6,8
8000ae32:	e0 6a 05 3c 	mov	r10,1340
8000ae36:	6c 18       	ld.w	r8,r6[0x4]
8000ae38:	74 2e       	ld.w	lr,r10[0x8]
8000ae3a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ae3e:	a1 c8       	cbr	r8,0x0
8000ae40:	ec 08 00 09 	add	r9,r6,r8
8000ae44:	72 1b       	ld.w	r11,r9[0x4]
8000ae46:	e0 1b ff fc 	andl	r11,0xfffc
8000ae4a:	1c 39       	cp.w	r9,lr
8000ae4c:	c1 e1       	brne	8000ae88 <_free_r+0x68>
8000ae4e:	f6 08 00 08 	add	r8,r11,r8
8000ae52:	58 0c       	cp.w	r12,0
8000ae54:	c0 81       	brne	8000ae64 <_free_r+0x44>
8000ae56:	6c 09       	ld.w	r9,r6[0x0]
8000ae58:	12 16       	sub	r6,r9
8000ae5a:	12 08       	add	r8,r9
8000ae5c:	6c 3b       	ld.w	r11,r6[0xc]
8000ae5e:	6c 29       	ld.w	r9,r6[0x8]
8000ae60:	97 29       	st.w	r11[0x8],r9
8000ae62:	93 3b       	st.w	r9[0xc],r11
8000ae64:	10 99       	mov	r9,r8
8000ae66:	95 26       	st.w	r10[0x8],r6
8000ae68:	a1 a9       	sbr	r9,0x0
8000ae6a:	8d 19       	st.w	r6[0x4],r9
8000ae6c:	e0 69 09 44 	mov	r9,2372
8000ae70:	72 09       	ld.w	r9,r9[0x0]
8000ae72:	12 38       	cp.w	r8,r9
8000ae74:	c0 63       	brcs	8000ae80 <_free_r+0x60>
8000ae76:	e0 68 0d 64 	mov	r8,3428
8000ae7a:	0e 9c       	mov	r12,r7
8000ae7c:	70 0b       	ld.w	r11,r8[0x0]
8000ae7e:	c8 5f       	rcall	8000ad88 <_malloc_trim_r>
8000ae80:	0e 9c       	mov	r12,r7
8000ae82:	fe b0 d7 65 	rcall	80005d4c <__malloc_unlock>
8000ae86:	d8 22       	popm	r4-r7,pc
8000ae88:	93 1b       	st.w	r9[0x4],r11
8000ae8a:	58 0c       	cp.w	r12,0
8000ae8c:	c0 30       	breq	8000ae92 <_free_r+0x72>
8000ae8e:	30 0c       	mov	r12,0
8000ae90:	c1 08       	rjmp	8000aeb0 <_free_r+0x90>
8000ae92:	6c 0e       	ld.w	lr,r6[0x0]
8000ae94:	f4 c5 ff f8 	sub	r5,r10,-8
8000ae98:	1c 16       	sub	r6,lr
8000ae9a:	1c 08       	add	r8,lr
8000ae9c:	6c 2e       	ld.w	lr,r6[0x8]
8000ae9e:	0a 3e       	cp.w	lr,r5
8000aea0:	f9 bc 00 01 	moveq	r12,1
8000aea4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000aea8:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000aeac:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000aeb0:	f2 0b 00 0e 	add	lr,r9,r11
8000aeb4:	7c 1e       	ld.w	lr,lr[0x4]
8000aeb6:	ed be 00 00 	bld	lr,0x0
8000aeba:	c1 40       	breq	8000aee2 <_free_r+0xc2>
8000aebc:	16 08       	add	r8,r11
8000aebe:	58 0c       	cp.w	r12,0
8000aec0:	c0 d1       	brne	8000aeda <_free_r+0xba>
8000aec2:	e0 6e 05 3c 	mov	lr,1340
8000aec6:	72 2b       	ld.w	r11,r9[0x8]
8000aec8:	2f 8e       	sub	lr,-8
8000aeca:	1c 3b       	cp.w	r11,lr
8000aecc:	c0 71       	brne	8000aeda <_free_r+0xba>
8000aece:	97 36       	st.w	r11[0xc],r6
8000aed0:	97 26       	st.w	r11[0x8],r6
8000aed2:	8d 2b       	st.w	r6[0x8],r11
8000aed4:	8d 3b       	st.w	r6[0xc],r11
8000aed6:	30 1c       	mov	r12,1
8000aed8:	c0 58       	rjmp	8000aee2 <_free_r+0xc2>
8000aeda:	72 2b       	ld.w	r11,r9[0x8]
8000aedc:	72 39       	ld.w	r9,r9[0xc]
8000aede:	93 2b       	st.w	r9[0x8],r11
8000aee0:	97 39       	st.w	r11[0xc],r9
8000aee2:	10 99       	mov	r9,r8
8000aee4:	ec 08 09 08 	st.w	r6[r8],r8
8000aee8:	a1 a9       	sbr	r9,0x0
8000aeea:	8d 19       	st.w	r6[0x4],r9
8000aeec:	58 0c       	cp.w	r12,0
8000aeee:	c5 a1       	brne	8000afa2 <_free_r+0x182>
8000aef0:	e0 48 01 ff 	cp.w	r8,511
8000aef4:	e0 8b 00 13 	brhi	8000af1a <_free_r+0xfa>
8000aef8:	a3 98       	lsr	r8,0x3
8000aefa:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000aefe:	72 2b       	ld.w	r11,r9[0x8]
8000af00:	8d 39       	st.w	r6[0xc],r9
8000af02:	8d 2b       	st.w	r6[0x8],r11
8000af04:	97 36       	st.w	r11[0xc],r6
8000af06:	93 26       	st.w	r9[0x8],r6
8000af08:	a3 48       	asr	r8,0x2
8000af0a:	74 19       	ld.w	r9,r10[0x4]
8000af0c:	30 1b       	mov	r11,1
8000af0e:	f6 08 09 48 	lsl	r8,r11,r8
8000af12:	f3 e8 10 08 	or	r8,r9,r8
8000af16:	95 18       	st.w	r10[0x4],r8
8000af18:	c4 58       	rjmp	8000afa2 <_free_r+0x182>
8000af1a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000af1e:	58 4b       	cp.w	r11,4
8000af20:	e0 8b 00 06 	brhi	8000af2c <_free_r+0x10c>
8000af24:	f0 0b 16 06 	lsr	r11,r8,0x6
8000af28:	2c 8b       	sub	r11,-56
8000af2a:	c2 08       	rjmp	8000af6a <_free_r+0x14a>
8000af2c:	59 4b       	cp.w	r11,20
8000af2e:	e0 8b 00 04 	brhi	8000af36 <_free_r+0x116>
8000af32:	2a 5b       	sub	r11,-91
8000af34:	c1 b8       	rjmp	8000af6a <_free_r+0x14a>
8000af36:	e0 4b 00 54 	cp.w	r11,84
8000af3a:	e0 8b 00 06 	brhi	8000af46 <_free_r+0x126>
8000af3e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000af42:	29 2b       	sub	r11,-110
8000af44:	c1 38       	rjmp	8000af6a <_free_r+0x14a>
8000af46:	e0 4b 01 54 	cp.w	r11,340
8000af4a:	e0 8b 00 06 	brhi	8000af56 <_free_r+0x136>
8000af4e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000af52:	28 9b       	sub	r11,-119
8000af54:	c0 b8       	rjmp	8000af6a <_free_r+0x14a>
8000af56:	e0 4b 05 54 	cp.w	r11,1364
8000af5a:	e0 88 00 05 	brls	8000af64 <_free_r+0x144>
8000af5e:	37 eb       	mov	r11,126
8000af60:	c0 58       	rjmp	8000af6a <_free_r+0x14a>
8000af62:	d7 03       	nop
8000af64:	f0 0b 16 12 	lsr	r11,r8,0x12
8000af68:	28 4b       	sub	r11,-124
8000af6a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000af6e:	78 29       	ld.w	r9,r12[0x8]
8000af70:	18 39       	cp.w	r9,r12
8000af72:	c0 e1       	brne	8000af8e <_free_r+0x16e>
8000af74:	74 18       	ld.w	r8,r10[0x4]
8000af76:	a3 4b       	asr	r11,0x2
8000af78:	30 1c       	mov	r12,1
8000af7a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000af7e:	f1 eb 10 0b 	or	r11,r8,r11
8000af82:	12 98       	mov	r8,r9
8000af84:	95 1b       	st.w	r10[0x4],r11
8000af86:	c0 a8       	rjmp	8000af9a <_free_r+0x17a>
8000af88:	72 29       	ld.w	r9,r9[0x8]
8000af8a:	18 39       	cp.w	r9,r12
8000af8c:	c0 60       	breq	8000af98 <_free_r+0x178>
8000af8e:	72 1a       	ld.w	r10,r9[0x4]
8000af90:	e0 1a ff fc 	andl	r10,0xfffc
8000af94:	14 38       	cp.w	r8,r10
8000af96:	cf 93       	brcs	8000af88 <_free_r+0x168>
8000af98:	72 38       	ld.w	r8,r9[0xc]
8000af9a:	8d 38       	st.w	r6[0xc],r8
8000af9c:	8d 29       	st.w	r6[0x8],r9
8000af9e:	93 36       	st.w	r9[0xc],r6
8000afa0:	91 26       	st.w	r8[0x8],r6
8000afa2:	0e 9c       	mov	r12,r7
8000afa4:	fe b0 d6 d4 	rcall	80005d4c <__malloc_unlock>
8000afa8:	d8 22       	popm	r4-r7,pc
8000afaa:	d7 03       	nop

8000afac <__sfvwrite_r>:
8000afac:	d4 31       	pushm	r0-r7,lr
8000afae:	20 3d       	sub	sp,12
8000afb0:	14 94       	mov	r4,r10
8000afb2:	18 95       	mov	r5,r12
8000afb4:	16 97       	mov	r7,r11
8000afb6:	74 28       	ld.w	r8,r10[0x8]
8000afb8:	58 08       	cp.w	r8,0
8000afba:	e0 80 01 40 	breq	8000b23a <__sfvwrite_r+0x28e>
8000afbe:	96 68       	ld.sh	r8,r11[0xc]
8000afc0:	ed b8 00 03 	bld	r8,0x3
8000afc4:	c0 41       	brne	8000afcc <__sfvwrite_r+0x20>
8000afc6:	76 48       	ld.w	r8,r11[0x10]
8000afc8:	58 08       	cp.w	r8,0
8000afca:	c0 c1       	brne	8000afe2 <__sfvwrite_r+0x36>
8000afcc:	0e 9b       	mov	r11,r7
8000afce:	0a 9c       	mov	r12,r5
8000afd0:	fe b0 f6 c4 	rcall	80009d58 <__swsetup_r>
8000afd4:	c0 70       	breq	8000afe2 <__sfvwrite_r+0x36>
8000afd6:	8e 68       	ld.sh	r8,r7[0xc]
8000afd8:	a7 a8       	sbr	r8,0x6
8000afda:	ae 68       	st.h	r7[0xc],r8
8000afdc:	30 98       	mov	r8,9
8000afde:	8b 38       	st.w	r5[0xc],r8
8000afe0:	c2 b9       	rjmp	8000b236 <__sfvwrite_r+0x28a>
8000afe2:	8e 63       	ld.sh	r3,r7[0xc]
8000afe4:	68 00       	ld.w	r0,r4[0x0]
8000afe6:	06 96       	mov	r6,r3
8000afe8:	e2 16 00 02 	andl	r6,0x2,COH
8000afec:	c2 10       	breq	8000b02e <__sfvwrite_r+0x82>
8000afee:	30 03       	mov	r3,0
8000aff0:	e0 62 04 00 	mov	r2,1024
8000aff4:	06 96       	mov	r6,r3
8000aff6:	c0 48       	rjmp	8000affe <__sfvwrite_r+0x52>
8000aff8:	60 03       	ld.w	r3,r0[0x0]
8000affa:	60 16       	ld.w	r6,r0[0x4]
8000affc:	2f 80       	sub	r0,-8
8000affe:	58 06       	cp.w	r6,0
8000b000:	cf c0       	breq	8000aff8 <__sfvwrite_r+0x4c>
8000b002:	e0 46 04 00 	cp.w	r6,1024
8000b006:	ec 09 17 80 	movls	r9,r6
8000b00a:	e4 09 17 b0 	movhi	r9,r2
8000b00e:	06 9a       	mov	r10,r3
8000b010:	6e a8       	ld.w	r8,r7[0x28]
8000b012:	6e 8b       	ld.w	r11,r7[0x20]
8000b014:	0a 9c       	mov	r12,r5
8000b016:	5d 18       	icall	r8
8000b018:	18 16       	sub	r6,r12
8000b01a:	58 0c       	cp.w	r12,0
8000b01c:	e0 8a 01 0a 	brle	8000b230 <__sfvwrite_r+0x284>
8000b020:	68 28       	ld.w	r8,r4[0x8]
8000b022:	18 18       	sub	r8,r12
8000b024:	89 28       	st.w	r4[0x8],r8
8000b026:	e0 80 01 0a 	breq	8000b23a <__sfvwrite_r+0x28e>
8000b02a:	18 03       	add	r3,r12
8000b02c:	ce 9b       	rjmp	8000affe <__sfvwrite_r+0x52>
8000b02e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b032:	c0 70       	breq	8000b040 <__sfvwrite_r+0x94>
8000b034:	50 06       	stdsp	sp[0x0],r6
8000b036:	0c 93       	mov	r3,r6
8000b038:	0c 91       	mov	r1,r6
8000b03a:	50 15       	stdsp	sp[0x4],r5
8000b03c:	08 92       	mov	r2,r4
8000b03e:	c9 c8       	rjmp	8000b176 <__sfvwrite_r+0x1ca>
8000b040:	06 96       	mov	r6,r3
8000b042:	08 91       	mov	r1,r4
8000b044:	c0 48       	rjmp	8000b04c <__sfvwrite_r+0xa0>
8000b046:	60 03       	ld.w	r3,r0[0x0]
8000b048:	60 16       	ld.w	r6,r0[0x4]
8000b04a:	2f 80       	sub	r0,-8
8000b04c:	58 06       	cp.w	r6,0
8000b04e:	cf c0       	breq	8000b046 <__sfvwrite_r+0x9a>
8000b050:	8e 68       	ld.sh	r8,r7[0xc]
8000b052:	6e 24       	ld.w	r4,r7[0x8]
8000b054:	10 99       	mov	r9,r8
8000b056:	e2 19 02 00 	andl	r9,0x200,COH
8000b05a:	c5 50       	breq	8000b104 <__sfvwrite_r+0x158>
8000b05c:	08 36       	cp.w	r6,r4
8000b05e:	c4 43       	brcs	8000b0e6 <__sfvwrite_r+0x13a>
8000b060:	10 99       	mov	r9,r8
8000b062:	e2 19 04 80 	andl	r9,0x480,COH
8000b066:	c4 00       	breq	8000b0e6 <__sfvwrite_r+0x13a>
8000b068:	6e 4b       	ld.w	r11,r7[0x10]
8000b06a:	6e 09       	ld.w	r9,r7[0x0]
8000b06c:	16 19       	sub	r9,r11
8000b06e:	50 09       	stdsp	sp[0x0],r9
8000b070:	6e 59       	ld.w	r9,r7[0x14]
8000b072:	10 9c       	mov	r12,r8
8000b074:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b078:	30 28       	mov	r8,2
8000b07a:	f4 08 0c 08 	divs	r8,r10,r8
8000b07e:	fa e9 00 04 	st.d	sp[4],r8
8000b082:	10 94       	mov	r4,r8
8000b084:	40 09       	lddsp	r9,sp[0x0]
8000b086:	e2 1c 04 00 	andl	r12,0x400,COH
8000b08a:	2f f9       	sub	r9,-1
8000b08c:	0c 09       	add	r9,r6
8000b08e:	12 38       	cp.w	r8,r9
8000b090:	f2 04 17 30 	movlo	r4,r9
8000b094:	58 0c       	cp.w	r12,0
8000b096:	c1 10       	breq	8000b0b8 <__sfvwrite_r+0x10c>
8000b098:	08 9b       	mov	r11,r4
8000b09a:	0a 9c       	mov	r12,r5
8000b09c:	fe b0 e0 6c 	rcall	80007174 <_malloc_r>
8000b0a0:	18 92       	mov	r2,r12
8000b0a2:	c1 40       	breq	8000b0ca <__sfvwrite_r+0x11e>
8000b0a4:	40 0a       	lddsp	r10,sp[0x0]
8000b0a6:	6e 4b       	ld.w	r11,r7[0x10]
8000b0a8:	fe b0 e2 82 	rcall	800075ac <memcpy>
8000b0ac:	8e 68       	ld.sh	r8,r7[0xc]
8000b0ae:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b0b2:	a7 b8       	sbr	r8,0x7
8000b0b4:	ae 68       	st.h	r7[0xc],r8
8000b0b6:	c0 d8       	rjmp	8000b0d0 <__sfvwrite_r+0x124>
8000b0b8:	08 9a       	mov	r10,r4
8000b0ba:	0a 9c       	mov	r12,r5
8000b0bc:	fe b0 e3 24 	rcall	80007704 <_realloc_r>
8000b0c0:	18 92       	mov	r2,r12
8000b0c2:	c0 71       	brne	8000b0d0 <__sfvwrite_r+0x124>
8000b0c4:	6e 4b       	ld.w	r11,r7[0x10]
8000b0c6:	0a 9c       	mov	r12,r5
8000b0c8:	ca ce       	rcall	8000ae20 <_free_r>
8000b0ca:	30 c8       	mov	r8,12
8000b0cc:	8b 38       	st.w	r5[0xc],r8
8000b0ce:	cb 18       	rjmp	8000b230 <__sfvwrite_r+0x284>
8000b0d0:	40 0a       	lddsp	r10,sp[0x0]
8000b0d2:	40 09       	lddsp	r9,sp[0x0]
8000b0d4:	e8 0a 01 0a 	sub	r10,r4,r10
8000b0d8:	e4 09 00 08 	add	r8,r2,r9
8000b0dc:	8f 54       	st.w	r7[0x14],r4
8000b0de:	8f 2a       	st.w	r7[0x8],r10
8000b0e0:	8f 08       	st.w	r7[0x0],r8
8000b0e2:	8f 42       	st.w	r7[0x10],r2
8000b0e4:	0c 94       	mov	r4,r6
8000b0e6:	08 36       	cp.w	r6,r4
8000b0e8:	ec 04 17 30 	movlo	r4,r6
8000b0ec:	06 9b       	mov	r11,r3
8000b0ee:	08 9a       	mov	r10,r4
8000b0f0:	6e 0c       	ld.w	r12,r7[0x0]
8000b0f2:	c3 ad       	rcall	8000b366 <memmove>
8000b0f4:	6e 08       	ld.w	r8,r7[0x0]
8000b0f6:	08 08       	add	r8,r4
8000b0f8:	8f 08       	st.w	r7[0x0],r8
8000b0fa:	6e 28       	ld.w	r8,r7[0x8]
8000b0fc:	08 18       	sub	r8,r4
8000b0fe:	0c 94       	mov	r4,r6
8000b100:	8f 28       	st.w	r7[0x8],r8
8000b102:	c2 e8       	rjmp	8000b15e <__sfvwrite_r+0x1b2>
8000b104:	08 36       	cp.w	r6,r4
8000b106:	5f ba       	srhi	r10
8000b108:	6e 0c       	ld.w	r12,r7[0x0]
8000b10a:	6e 48       	ld.w	r8,r7[0x10]
8000b10c:	10 3c       	cp.w	r12,r8
8000b10e:	5f b8       	srhi	r8
8000b110:	f5 e8 00 08 	and	r8,r10,r8
8000b114:	f2 08 18 00 	cp.b	r8,r9
8000b118:	c0 d0       	breq	8000b132 <__sfvwrite_r+0x186>
8000b11a:	06 9b       	mov	r11,r3
8000b11c:	08 9a       	mov	r10,r4
8000b11e:	c2 4d       	rcall	8000b366 <memmove>
8000b120:	6e 08       	ld.w	r8,r7[0x0]
8000b122:	08 08       	add	r8,r4
8000b124:	0e 9b       	mov	r11,r7
8000b126:	8f 08       	st.w	r7[0x0],r8
8000b128:	0a 9c       	mov	r12,r5
8000b12a:	fe b0 fd 09 	rcall	8000ab3c <_fflush_r>
8000b12e:	c1 80       	breq	8000b15e <__sfvwrite_r+0x1b2>
8000b130:	c8 08       	rjmp	8000b230 <__sfvwrite_r+0x284>
8000b132:	6e 59       	ld.w	r9,r7[0x14]
8000b134:	12 36       	cp.w	r6,r9
8000b136:	c0 a3       	brcs	8000b14a <__sfvwrite_r+0x19e>
8000b138:	6e a8       	ld.w	r8,r7[0x28]
8000b13a:	06 9a       	mov	r10,r3
8000b13c:	6e 8b       	ld.w	r11,r7[0x20]
8000b13e:	0a 9c       	mov	r12,r5
8000b140:	5d 18       	icall	r8
8000b142:	18 94       	mov	r4,r12
8000b144:	e0 89 00 0d 	brgt	8000b15e <__sfvwrite_r+0x1b2>
8000b148:	c7 48       	rjmp	8000b230 <__sfvwrite_r+0x284>
8000b14a:	0c 9a       	mov	r10,r6
8000b14c:	06 9b       	mov	r11,r3
8000b14e:	c0 cd       	rcall	8000b366 <memmove>
8000b150:	6e 08       	ld.w	r8,r7[0x0]
8000b152:	0c 08       	add	r8,r6
8000b154:	0c 94       	mov	r4,r6
8000b156:	8f 08       	st.w	r7[0x0],r8
8000b158:	6e 28       	ld.w	r8,r7[0x8]
8000b15a:	0c 18       	sub	r8,r6
8000b15c:	8f 28       	st.w	r7[0x8],r8
8000b15e:	62 28       	ld.w	r8,r1[0x8]
8000b160:	08 18       	sub	r8,r4
8000b162:	83 28       	st.w	r1[0x8],r8
8000b164:	c6 b0       	breq	8000b23a <__sfvwrite_r+0x28e>
8000b166:	08 16       	sub	r6,r4
8000b168:	08 03       	add	r3,r4
8000b16a:	c7 1b       	rjmp	8000b04c <__sfvwrite_r+0xa0>
8000b16c:	60 03       	ld.w	r3,r0[0x0]
8000b16e:	60 11       	ld.w	r1,r0[0x4]
8000b170:	30 08       	mov	r8,0
8000b172:	2f 80       	sub	r0,-8
8000b174:	50 08       	stdsp	sp[0x0],r8
8000b176:	58 01       	cp.w	r1,0
8000b178:	cf a0       	breq	8000b16c <__sfvwrite_r+0x1c0>
8000b17a:	40 0a       	lddsp	r10,sp[0x0]
8000b17c:	58 0a       	cp.w	r10,0
8000b17e:	c1 41       	brne	8000b1a6 <__sfvwrite_r+0x1fa>
8000b180:	e2 c6 ff ff 	sub	r6,r1,-1
8000b184:	02 9a       	mov	r10,r1
8000b186:	30 ab       	mov	r11,10
8000b188:	06 9c       	mov	r12,r3
8000b18a:	ce 3c       	rcall	8000b350 <memchr>
8000b18c:	f8 c8 ff ff 	sub	r8,r12,-1
8000b190:	58 0c       	cp.w	r12,0
8000b192:	f1 d3 e1 16 	subne	r6,r8,r3
8000b196:	f9 b9 01 01 	movne	r9,1
8000b19a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b19e:	f9 b8 00 01 	moveq	r8,1
8000b1a2:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b1a6:	02 36       	cp.w	r6,r1
8000b1a8:	ec 04 17 80 	movls	r4,r6
8000b1ac:	e2 04 17 b0 	movhi	r4,r1
8000b1b0:	6e 59       	ld.w	r9,r7[0x14]
8000b1b2:	6e 25       	ld.w	r5,r7[0x8]
8000b1b4:	f2 05 00 05 	add	r5,r9,r5
8000b1b8:	0a 34       	cp.w	r4,r5
8000b1ba:	5f 9a       	srgt	r10
8000b1bc:	6e 0c       	ld.w	r12,r7[0x0]
8000b1be:	6e 48       	ld.w	r8,r7[0x10]
8000b1c0:	10 3c       	cp.w	r12,r8
8000b1c2:	5f b8       	srhi	r8
8000b1c4:	f5 e8 00 08 	and	r8,r10,r8
8000b1c8:	30 0a       	mov	r10,0
8000b1ca:	f4 08 18 00 	cp.b	r8,r10
8000b1ce:	c0 d0       	breq	8000b1e8 <__sfvwrite_r+0x23c>
8000b1d0:	06 9b       	mov	r11,r3
8000b1d2:	0a 9a       	mov	r10,r5
8000b1d4:	cc 9c       	rcall	8000b366 <memmove>
8000b1d6:	6e 08       	ld.w	r8,r7[0x0]
8000b1d8:	0a 08       	add	r8,r5
8000b1da:	0e 9b       	mov	r11,r7
8000b1dc:	8f 08       	st.w	r7[0x0],r8
8000b1de:	40 1c       	lddsp	r12,sp[0x4]
8000b1e0:	fe b0 fc ae 	rcall	8000ab3c <_fflush_r>
8000b1e4:	c1 70       	breq	8000b212 <__sfvwrite_r+0x266>
8000b1e6:	c2 58       	rjmp	8000b230 <__sfvwrite_r+0x284>
8000b1e8:	12 34       	cp.w	r4,r9
8000b1ea:	c0 a5       	brlt	8000b1fe <__sfvwrite_r+0x252>
8000b1ec:	6e a8       	ld.w	r8,r7[0x28]
8000b1ee:	06 9a       	mov	r10,r3
8000b1f0:	6e 8b       	ld.w	r11,r7[0x20]
8000b1f2:	40 1c       	lddsp	r12,sp[0x4]
8000b1f4:	5d 18       	icall	r8
8000b1f6:	18 95       	mov	r5,r12
8000b1f8:	e0 89 00 0d 	brgt	8000b212 <__sfvwrite_r+0x266>
8000b1fc:	c1 a8       	rjmp	8000b230 <__sfvwrite_r+0x284>
8000b1fe:	08 9a       	mov	r10,r4
8000b200:	06 9b       	mov	r11,r3
8000b202:	cb 2c       	rcall	8000b366 <memmove>
8000b204:	6e 08       	ld.w	r8,r7[0x0]
8000b206:	08 08       	add	r8,r4
8000b208:	08 95       	mov	r5,r4
8000b20a:	8f 08       	st.w	r7[0x0],r8
8000b20c:	6e 28       	ld.w	r8,r7[0x8]
8000b20e:	08 18       	sub	r8,r4
8000b210:	8f 28       	st.w	r7[0x8],r8
8000b212:	0a 16       	sub	r6,r5
8000b214:	c0 71       	brne	8000b222 <__sfvwrite_r+0x276>
8000b216:	0e 9b       	mov	r11,r7
8000b218:	40 1c       	lddsp	r12,sp[0x4]
8000b21a:	fe b0 fc 91 	rcall	8000ab3c <_fflush_r>
8000b21e:	c0 91       	brne	8000b230 <__sfvwrite_r+0x284>
8000b220:	50 06       	stdsp	sp[0x0],r6
8000b222:	64 28       	ld.w	r8,r2[0x8]
8000b224:	0a 18       	sub	r8,r5
8000b226:	85 28       	st.w	r2[0x8],r8
8000b228:	c0 90       	breq	8000b23a <__sfvwrite_r+0x28e>
8000b22a:	0a 11       	sub	r1,r5
8000b22c:	0a 03       	add	r3,r5
8000b22e:	ca 4b       	rjmp	8000b176 <__sfvwrite_r+0x1ca>
8000b230:	8e 68       	ld.sh	r8,r7[0xc]
8000b232:	a7 a8       	sbr	r8,0x6
8000b234:	ae 68       	st.h	r7[0xc],r8
8000b236:	3f fc       	mov	r12,-1
8000b238:	c0 28       	rjmp	8000b23c <__sfvwrite_r+0x290>
8000b23a:	30 0c       	mov	r12,0
8000b23c:	2f dd       	sub	sp,-12
8000b23e:	d8 32       	popm	r0-r7,pc

8000b240 <_fwalk>:
8000b240:	d4 31       	pushm	r0-r7,lr
8000b242:	30 05       	mov	r5,0
8000b244:	16 91       	mov	r1,r11
8000b246:	f8 c7 ff 28 	sub	r7,r12,-216
8000b24a:	0a 92       	mov	r2,r5
8000b24c:	fe b0 fc fe 	rcall	8000ac48 <__sfp_lock_acquire>
8000b250:	3f f3       	mov	r3,-1
8000b252:	c1 68       	rjmp	8000b27e <_fwalk+0x3e>
8000b254:	6e 26       	ld.w	r6,r7[0x8]
8000b256:	6e 14       	ld.w	r4,r7[0x4]
8000b258:	2f 46       	sub	r6,-12
8000b25a:	c0 c8       	rjmp	8000b272 <_fwalk+0x32>
8000b25c:	8c 08       	ld.sh	r8,r6[0x0]
8000b25e:	e4 08 19 00 	cp.h	r8,r2
8000b262:	c0 70       	breq	8000b270 <_fwalk+0x30>
8000b264:	8c 18       	ld.sh	r8,r6[0x2]
8000b266:	e6 08 19 00 	cp.h	r8,r3
8000b26a:	c0 30       	breq	8000b270 <_fwalk+0x30>
8000b26c:	5d 11       	icall	r1
8000b26e:	18 45       	or	r5,r12
8000b270:	2a 46       	sub	r6,-92
8000b272:	20 14       	sub	r4,1
8000b274:	ec cc 00 0c 	sub	r12,r6,12
8000b278:	58 04       	cp.w	r4,0
8000b27a:	cf 14       	brge	8000b25c <_fwalk+0x1c>
8000b27c:	6e 07       	ld.w	r7,r7[0x0]
8000b27e:	58 07       	cp.w	r7,0
8000b280:	ce a1       	brne	8000b254 <_fwalk+0x14>
8000b282:	fe b0 fc e4 	rcall	8000ac4a <__sfp_lock_release>
8000b286:	0a 9c       	mov	r12,r5
8000b288:	d8 32       	popm	r0-r7,pc
8000b28a:	d7 03       	nop

8000b28c <_localeconv_r>:
8000b28c:	fe cc d3 78 	sub	r12,pc,-11400
8000b290:	5e fc       	retal	r12
8000b292:	d7 03       	nop

8000b294 <__smakebuf_r>:
8000b294:	d4 21       	pushm	r4-r7,lr
8000b296:	20 fd       	sub	sp,60
8000b298:	96 68       	ld.sh	r8,r11[0xc]
8000b29a:	16 97       	mov	r7,r11
8000b29c:	18 96       	mov	r6,r12
8000b29e:	e2 18 00 02 	andl	r8,0x2,COH
8000b2a2:	c3 d1       	brne	8000b31c <__smakebuf_r+0x88>
8000b2a4:	96 7b       	ld.sh	r11,r11[0xe]
8000b2a6:	f0 0b 19 00 	cp.h	r11,r8
8000b2aa:	c0 55       	brlt	8000b2b4 <__smakebuf_r+0x20>
8000b2ac:	1a 9a       	mov	r10,sp
8000b2ae:	e0 a0 04 81 	rcall	8000bbb0 <_fstat_r>
8000b2b2:	c0 f4       	brge	8000b2d0 <__smakebuf_r+0x3c>
8000b2b4:	8e 65       	ld.sh	r5,r7[0xc]
8000b2b6:	0a 98       	mov	r8,r5
8000b2b8:	ab b8       	sbr	r8,0xb
8000b2ba:	e2 15 00 80 	andl	r5,0x80,COH
8000b2be:	ae 68       	st.h	r7[0xc],r8
8000b2c0:	30 04       	mov	r4,0
8000b2c2:	e0 68 04 00 	mov	r8,1024
8000b2c6:	f9 b5 01 40 	movne	r5,64
8000b2ca:	f0 05 17 00 	moveq	r5,r8
8000b2ce:	c1 c8       	rjmp	8000b306 <__smakebuf_r+0x72>
8000b2d0:	40 18       	lddsp	r8,sp[0x4]
8000b2d2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b2d6:	e0 48 20 00 	cp.w	r8,8192
8000b2da:	5f 04       	sreq	r4
8000b2dc:	e0 48 80 00 	cp.w	r8,32768
8000b2e0:	c0 e1       	brne	8000b2fc <__smakebuf_r+0x68>
8000b2e2:	6e b9       	ld.w	r9,r7[0x2c]
8000b2e4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b2e8:	10 39       	cp.w	r9,r8
8000b2ea:	c0 91       	brne	8000b2fc <__smakebuf_r+0x68>
8000b2ec:	8e 68       	ld.sh	r8,r7[0xc]
8000b2ee:	e0 65 04 00 	mov	r5,1024
8000b2f2:	ab a8       	sbr	r8,0xa
8000b2f4:	ef 45 00 50 	st.w	r7[80],r5
8000b2f8:	ae 68       	st.h	r7[0xc],r8
8000b2fa:	c0 68       	rjmp	8000b306 <__smakebuf_r+0x72>
8000b2fc:	8e 68       	ld.sh	r8,r7[0xc]
8000b2fe:	e0 65 04 00 	mov	r5,1024
8000b302:	ab b8       	sbr	r8,0xb
8000b304:	ae 68       	st.h	r7[0xc],r8
8000b306:	0a 9b       	mov	r11,r5
8000b308:	0c 9c       	mov	r12,r6
8000b30a:	fe b0 df 35 	rcall	80007174 <_malloc_r>
8000b30e:	8e 68       	ld.sh	r8,r7[0xc]
8000b310:	c0 d1       	brne	8000b32a <__smakebuf_r+0x96>
8000b312:	ed b8 00 09 	bld	r8,0x9
8000b316:	c1 b0       	breq	8000b34c <__smakebuf_r+0xb8>
8000b318:	a1 b8       	sbr	r8,0x1
8000b31a:	ae 68       	st.h	r7[0xc],r8
8000b31c:	ee c8 ff b9 	sub	r8,r7,-71
8000b320:	8f 48       	st.w	r7[0x10],r8
8000b322:	8f 08       	st.w	r7[0x0],r8
8000b324:	30 18       	mov	r8,1
8000b326:	8f 58       	st.w	r7[0x14],r8
8000b328:	c1 28       	rjmp	8000b34c <__smakebuf_r+0xb8>
8000b32a:	a7 b8       	sbr	r8,0x7
8000b32c:	8f 4c       	st.w	r7[0x10],r12
8000b32e:	ae 68       	st.h	r7[0xc],r8
8000b330:	8f 55       	st.w	r7[0x14],r5
8000b332:	fe c8 06 e6 	sub	r8,pc,1766
8000b336:	8f 0c       	st.w	r7[0x0],r12
8000b338:	8d a8       	st.w	r6[0x28],r8
8000b33a:	58 04       	cp.w	r4,0
8000b33c:	c0 80       	breq	8000b34c <__smakebuf_r+0xb8>
8000b33e:	8e 7c       	ld.sh	r12,r7[0xe]
8000b340:	fe b0 e3 94 	rcall	80007a68 <isatty>
8000b344:	c0 40       	breq	8000b34c <__smakebuf_r+0xb8>
8000b346:	8e 68       	ld.sh	r8,r7[0xc]
8000b348:	a1 a8       	sbr	r8,0x0
8000b34a:	ae 68       	st.h	r7[0xc],r8
8000b34c:	2f 1d       	sub	sp,-60
8000b34e:	d8 22       	popm	r4-r7,pc

8000b350 <memchr>:
8000b350:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b354:	c0 68       	rjmp	8000b360 <memchr+0x10>
8000b356:	20 1a       	sub	r10,1
8000b358:	19 88       	ld.ub	r8,r12[0x0]
8000b35a:	16 38       	cp.w	r8,r11
8000b35c:	5e 0c       	reteq	r12
8000b35e:	2f fc       	sub	r12,-1
8000b360:	58 0a       	cp.w	r10,0
8000b362:	cf a1       	brne	8000b356 <memchr+0x6>
8000b364:	5e fa       	retal	r10

8000b366 <memmove>:
8000b366:	d4 01       	pushm	lr
8000b368:	18 3b       	cp.w	r11,r12
8000b36a:	c1 92       	brcc	8000b39c <memmove+0x36>
8000b36c:	f6 0a 00 09 	add	r9,r11,r10
8000b370:	12 3c       	cp.w	r12,r9
8000b372:	c1 52       	brcc	8000b39c <memmove+0x36>
8000b374:	f8 0a 00 0b 	add	r11,r12,r10
8000b378:	30 08       	mov	r8,0
8000b37a:	c0 68       	rjmp	8000b386 <memmove+0x20>
8000b37c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b380:	20 1a       	sub	r10,1
8000b382:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b386:	20 18       	sub	r8,1
8000b388:	58 0a       	cp.w	r10,0
8000b38a:	cf 91       	brne	8000b37c <memmove+0x16>
8000b38c:	d8 02       	popm	pc
8000b38e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b392:	20 1a       	sub	r10,1
8000b394:	f8 08 0b 09 	st.b	r12[r8],r9
8000b398:	2f f8       	sub	r8,-1
8000b39a:	c0 28       	rjmp	8000b39e <memmove+0x38>
8000b39c:	30 08       	mov	r8,0
8000b39e:	58 0a       	cp.w	r10,0
8000b3a0:	cf 71       	brne	8000b38e <memmove+0x28>
8000b3a2:	d8 02       	popm	pc

8000b3a4 <__hi0bits>:
8000b3a4:	18 98       	mov	r8,r12
8000b3a6:	e0 1c 00 00 	andl	r12,0x0
8000b3aa:	f0 09 15 10 	lsl	r9,r8,0x10
8000b3ae:	58 0c       	cp.w	r12,0
8000b3b0:	f2 08 17 00 	moveq	r8,r9
8000b3b4:	f9 bc 00 10 	moveq	r12,16
8000b3b8:	f9 bc 01 00 	movne	r12,0
8000b3bc:	10 9a       	mov	r10,r8
8000b3be:	f0 09 15 08 	lsl	r9,r8,0x8
8000b3c2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b3c6:	f7 bc 00 f8 	subeq	r12,-8
8000b3ca:	f2 08 17 00 	moveq	r8,r9
8000b3ce:	10 9a       	mov	r10,r8
8000b3d0:	f0 09 15 04 	lsl	r9,r8,0x4
8000b3d4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b3d8:	f7 bc 00 fc 	subeq	r12,-4
8000b3dc:	f2 08 17 00 	moveq	r8,r9
8000b3e0:	10 9a       	mov	r10,r8
8000b3e2:	f0 09 15 02 	lsl	r9,r8,0x2
8000b3e6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b3ea:	f7 bc 00 fe 	subeq	r12,-2
8000b3ee:	f2 08 17 00 	moveq	r8,r9
8000b3f2:	58 08       	cp.w	r8,0
8000b3f4:	5e 5c       	retlt	r12
8000b3f6:	ed b8 00 1e 	bld	r8,0x1e
8000b3fa:	f9 bc 01 20 	movne	r12,32
8000b3fe:	f7 bc 00 ff 	subeq	r12,-1
8000b402:	5e fc       	retal	r12

8000b404 <__lo0bits>:
8000b404:	18 99       	mov	r9,r12
8000b406:	78 08       	ld.w	r8,r12[0x0]
8000b408:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b40c:	c1 50       	breq	8000b436 <__lo0bits+0x32>
8000b40e:	ed b8 00 00 	bld	r8,0x0
8000b412:	c0 21       	brne	8000b416 <__lo0bits+0x12>
8000b414:	5e fd       	retal	0
8000b416:	10 9b       	mov	r11,r8
8000b418:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b41c:	e2 1b 00 02 	andl	r11,0x2,COH
8000b420:	a3 88       	lsr	r8,0x2
8000b422:	58 0b       	cp.w	r11,0
8000b424:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b428:	f9 bc 01 01 	movne	r12,1
8000b42c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b430:	f9 bc 00 02 	moveq	r12,2
8000b434:	5e fc       	retal	r12
8000b436:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b43a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b43e:	58 0a       	cp.w	r10,0
8000b440:	f6 08 17 00 	moveq	r8,r11
8000b444:	f9 bc 00 10 	moveq	r12,16
8000b448:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b44c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b450:	58 0b       	cp.w	r11,0
8000b452:	f7 bc 00 f8 	subeq	r12,-8
8000b456:	f4 08 17 00 	moveq	r8,r10
8000b45a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b45e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b462:	58 0b       	cp.w	r11,0
8000b464:	f7 bc 00 fc 	subeq	r12,-4
8000b468:	f4 08 17 00 	moveq	r8,r10
8000b46c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b470:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b474:	58 0b       	cp.w	r11,0
8000b476:	f7 bc 00 fe 	subeq	r12,-2
8000b47a:	f4 08 17 00 	moveq	r8,r10
8000b47e:	ed b8 00 00 	bld	r8,0x0
8000b482:	c0 60       	breq	8000b48e <__lo0bits+0x8a>
8000b484:	a1 98       	lsr	r8,0x1
8000b486:	c0 31       	brne	8000b48c <__lo0bits+0x88>
8000b488:	32 0c       	mov	r12,32
8000b48a:	5e fc       	retal	r12
8000b48c:	2f fc       	sub	r12,-1
8000b48e:	93 08       	st.w	r9[0x0],r8
8000b490:	5e fc       	retal	r12

8000b492 <__mcmp>:
8000b492:	d4 01       	pushm	lr
8000b494:	18 98       	mov	r8,r12
8000b496:	76 49       	ld.w	r9,r11[0x10]
8000b498:	78 4c       	ld.w	r12,r12[0x10]
8000b49a:	12 1c       	sub	r12,r9
8000b49c:	c1 31       	brne	8000b4c2 <__mcmp+0x30>
8000b49e:	2f b9       	sub	r9,-5
8000b4a0:	a3 69       	lsl	r9,0x2
8000b4a2:	12 0b       	add	r11,r9
8000b4a4:	f0 09 00 09 	add	r9,r8,r9
8000b4a8:	2e c8       	sub	r8,-20
8000b4aa:	13 4e       	ld.w	lr,--r9
8000b4ac:	17 4a       	ld.w	r10,--r11
8000b4ae:	14 3e       	cp.w	lr,r10
8000b4b0:	c0 60       	breq	8000b4bc <__mcmp+0x2a>
8000b4b2:	f9 bc 03 ff 	movlo	r12,-1
8000b4b6:	f9 bc 02 01 	movhs	r12,1
8000b4ba:	d8 02       	popm	pc
8000b4bc:	10 39       	cp.w	r9,r8
8000b4be:	fe 9b ff f6 	brhi	8000b4aa <__mcmp+0x18>
8000b4c2:	d8 02       	popm	pc

8000b4c4 <_Bfree>:
8000b4c4:	d4 21       	pushm	r4-r7,lr
8000b4c6:	18 97       	mov	r7,r12
8000b4c8:	16 95       	mov	r5,r11
8000b4ca:	78 96       	ld.w	r6,r12[0x24]
8000b4cc:	58 06       	cp.w	r6,0
8000b4ce:	c0 91       	brne	8000b4e0 <_Bfree+0x1c>
8000b4d0:	31 0c       	mov	r12,16
8000b4d2:	fe b0 de 49 	rcall	80007164 <malloc>
8000b4d6:	99 36       	st.w	r12[0xc],r6
8000b4d8:	8f 9c       	st.w	r7[0x24],r12
8000b4da:	99 16       	st.w	r12[0x4],r6
8000b4dc:	99 26       	st.w	r12[0x8],r6
8000b4de:	99 06       	st.w	r12[0x0],r6
8000b4e0:	58 05       	cp.w	r5,0
8000b4e2:	c0 90       	breq	8000b4f4 <_Bfree+0x30>
8000b4e4:	6a 19       	ld.w	r9,r5[0x4]
8000b4e6:	6e 98       	ld.w	r8,r7[0x24]
8000b4e8:	70 38       	ld.w	r8,r8[0xc]
8000b4ea:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b4ee:	8b 0a       	st.w	r5[0x0],r10
8000b4f0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b4f4:	d8 22       	popm	r4-r7,pc
8000b4f6:	d7 03       	nop

8000b4f8 <_Balloc>:
8000b4f8:	d4 21       	pushm	r4-r7,lr
8000b4fa:	18 97       	mov	r7,r12
8000b4fc:	16 96       	mov	r6,r11
8000b4fe:	78 95       	ld.w	r5,r12[0x24]
8000b500:	58 05       	cp.w	r5,0
8000b502:	c0 91       	brne	8000b514 <_Balloc+0x1c>
8000b504:	31 0c       	mov	r12,16
8000b506:	fe b0 de 2f 	rcall	80007164 <malloc>
8000b50a:	99 35       	st.w	r12[0xc],r5
8000b50c:	8f 9c       	st.w	r7[0x24],r12
8000b50e:	99 15       	st.w	r12[0x4],r5
8000b510:	99 25       	st.w	r12[0x8],r5
8000b512:	99 05       	st.w	r12[0x0],r5
8000b514:	6e 95       	ld.w	r5,r7[0x24]
8000b516:	6a 38       	ld.w	r8,r5[0xc]
8000b518:	58 08       	cp.w	r8,0
8000b51a:	c0 b1       	brne	8000b530 <_Balloc+0x38>
8000b51c:	31 0a       	mov	r10,16
8000b51e:	30 4b       	mov	r11,4
8000b520:	0e 9c       	mov	r12,r7
8000b522:	e0 a0 02 a7 	rcall	8000ba70 <_calloc_r>
8000b526:	8b 3c       	st.w	r5[0xc],r12
8000b528:	6e 98       	ld.w	r8,r7[0x24]
8000b52a:	70 3c       	ld.w	r12,r8[0xc]
8000b52c:	58 0c       	cp.w	r12,0
8000b52e:	c1 b0       	breq	8000b564 <_Balloc+0x6c>
8000b530:	6e 98       	ld.w	r8,r7[0x24]
8000b532:	70 38       	ld.w	r8,r8[0xc]
8000b534:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b538:	70 0c       	ld.w	r12,r8[0x0]
8000b53a:	58 0c       	cp.w	r12,0
8000b53c:	c0 40       	breq	8000b544 <_Balloc+0x4c>
8000b53e:	78 09       	ld.w	r9,r12[0x0]
8000b540:	91 09       	st.w	r8[0x0],r9
8000b542:	c0 e8       	rjmp	8000b55e <_Balloc+0x66>
8000b544:	0e 9c       	mov	r12,r7
8000b546:	30 17       	mov	r7,1
8000b548:	0e 9b       	mov	r11,r7
8000b54a:	ee 06 09 47 	lsl	r7,r7,r6
8000b54e:	ee ca ff fb 	sub	r10,r7,-5
8000b552:	a3 6a       	lsl	r10,0x2
8000b554:	e0 a0 02 8e 	rcall	8000ba70 <_calloc_r>
8000b558:	c0 60       	breq	8000b564 <_Balloc+0x6c>
8000b55a:	99 16       	st.w	r12[0x4],r6
8000b55c:	99 27       	st.w	r12[0x8],r7
8000b55e:	30 08       	mov	r8,0
8000b560:	99 38       	st.w	r12[0xc],r8
8000b562:	99 48       	st.w	r12[0x10],r8
8000b564:	d8 22       	popm	r4-r7,pc
8000b566:	d7 03       	nop

8000b568 <__d2b>:
8000b568:	d4 31       	pushm	r0-r7,lr
8000b56a:	20 2d       	sub	sp,8
8000b56c:	16 93       	mov	r3,r11
8000b56e:	12 96       	mov	r6,r9
8000b570:	10 95       	mov	r5,r8
8000b572:	14 92       	mov	r2,r10
8000b574:	30 1b       	mov	r11,1
8000b576:	cc 1f       	rcall	8000b4f8 <_Balloc>
8000b578:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b57c:	50 09       	stdsp	sp[0x0],r9
8000b57e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b582:	b5 a9       	sbr	r9,0x14
8000b584:	f0 01 16 14 	lsr	r1,r8,0x14
8000b588:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b58c:	18 94       	mov	r4,r12
8000b58e:	58 02       	cp.w	r2,0
8000b590:	c1 d0       	breq	8000b5ca <__d2b+0x62>
8000b592:	fa cc ff f8 	sub	r12,sp,-8
8000b596:	18 d2       	st.w	--r12,r2
8000b598:	c3 6f       	rcall	8000b404 <__lo0bits>
8000b59a:	40 18       	lddsp	r8,sp[0x4]
8000b59c:	c0 d0       	breq	8000b5b6 <__d2b+0x4e>
8000b59e:	40 09       	lddsp	r9,sp[0x0]
8000b5a0:	f8 0a 11 20 	rsub	r10,r12,32
8000b5a4:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b5a8:	f5 e8 10 08 	or	r8,r10,r8
8000b5ac:	89 58       	st.w	r4[0x14],r8
8000b5ae:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b5b2:	50 09       	stdsp	sp[0x0],r9
8000b5b4:	c0 28       	rjmp	8000b5b8 <__d2b+0x50>
8000b5b6:	89 58       	st.w	r4[0x14],r8
8000b5b8:	40 08       	lddsp	r8,sp[0x0]
8000b5ba:	58 08       	cp.w	r8,0
8000b5bc:	f9 b3 01 02 	movne	r3,2
8000b5c0:	f9 b3 00 01 	moveq	r3,1
8000b5c4:	89 68       	st.w	r4[0x18],r8
8000b5c6:	89 43       	st.w	r4[0x10],r3
8000b5c8:	c0 88       	rjmp	8000b5d8 <__d2b+0x70>
8000b5ca:	1a 9c       	mov	r12,sp
8000b5cc:	c1 cf       	rcall	8000b404 <__lo0bits>
8000b5ce:	30 13       	mov	r3,1
8000b5d0:	40 08       	lddsp	r8,sp[0x0]
8000b5d2:	2e 0c       	sub	r12,-32
8000b5d4:	89 43       	st.w	r4[0x10],r3
8000b5d6:	89 58       	st.w	r4[0x14],r8
8000b5d8:	58 01       	cp.w	r1,0
8000b5da:	c0 90       	breq	8000b5ec <__d2b+0x84>
8000b5dc:	e2 c1 04 33 	sub	r1,r1,1075
8000b5e0:	18 01       	add	r1,r12
8000b5e2:	8d 01       	st.w	r6[0x0],r1
8000b5e4:	f8 0c 11 35 	rsub	r12,r12,53
8000b5e8:	8b 0c       	st.w	r5[0x0],r12
8000b5ea:	c0 c8       	rjmp	8000b602 <__d2b+0x9a>
8000b5ec:	e6 c8 ff fc 	sub	r8,r3,-4
8000b5f0:	f8 cc 04 32 	sub	r12,r12,1074
8000b5f4:	a5 73       	lsl	r3,0x5
8000b5f6:	8d 0c       	st.w	r6[0x0],r12
8000b5f8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b5fc:	cd 4e       	rcall	8000b3a4 <__hi0bits>
8000b5fe:	18 13       	sub	r3,r12
8000b600:	8b 03       	st.w	r5[0x0],r3
8000b602:	08 9c       	mov	r12,r4
8000b604:	2f ed       	sub	sp,-8
8000b606:	d8 32       	popm	r0-r7,pc

8000b608 <__mdiff>:
8000b608:	d4 31       	pushm	r0-r7,lr
8000b60a:	74 48       	ld.w	r8,r10[0x10]
8000b60c:	76 45       	ld.w	r5,r11[0x10]
8000b60e:	16 97       	mov	r7,r11
8000b610:	14 96       	mov	r6,r10
8000b612:	10 15       	sub	r5,r8
8000b614:	c1 31       	brne	8000b63a <__mdiff+0x32>
8000b616:	2f b8       	sub	r8,-5
8000b618:	ee ce ff ec 	sub	lr,r7,-20
8000b61c:	a3 68       	lsl	r8,0x2
8000b61e:	f4 08 00 0b 	add	r11,r10,r8
8000b622:	ee 08 00 08 	add	r8,r7,r8
8000b626:	11 4a       	ld.w	r10,--r8
8000b628:	17 49       	ld.w	r9,--r11
8000b62a:	12 3a       	cp.w	r10,r9
8000b62c:	c0 30       	breq	8000b632 <__mdiff+0x2a>
8000b62e:	c0 e2       	brcc	8000b64a <__mdiff+0x42>
8000b630:	c0 78       	rjmp	8000b63e <__mdiff+0x36>
8000b632:	1c 38       	cp.w	r8,lr
8000b634:	fe 9b ff f9 	brhi	8000b626 <__mdiff+0x1e>
8000b638:	c4 98       	rjmp	8000b6ca <__mdiff+0xc2>
8000b63a:	58 05       	cp.w	r5,0
8000b63c:	c0 64       	brge	8000b648 <__mdiff+0x40>
8000b63e:	0e 98       	mov	r8,r7
8000b640:	30 15       	mov	r5,1
8000b642:	0c 97       	mov	r7,r6
8000b644:	10 96       	mov	r6,r8
8000b646:	c0 28       	rjmp	8000b64a <__mdiff+0x42>
8000b648:	30 05       	mov	r5,0
8000b64a:	6e 1b       	ld.w	r11,r7[0x4]
8000b64c:	c5 6f       	rcall	8000b4f8 <_Balloc>
8000b64e:	6e 49       	ld.w	r9,r7[0x10]
8000b650:	6c 44       	ld.w	r4,r6[0x10]
8000b652:	99 35       	st.w	r12[0xc],r5
8000b654:	2f b4       	sub	r4,-5
8000b656:	f2 c5 ff fb 	sub	r5,r9,-5
8000b65a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b65e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b662:	2e c6       	sub	r6,-20
8000b664:	2e c7       	sub	r7,-20
8000b666:	f8 c8 ff ec 	sub	r8,r12,-20
8000b66a:	30 0a       	mov	r10,0
8000b66c:	0f 0e       	ld.w	lr,r7++
8000b66e:	0d 0b       	ld.w	r11,r6++
8000b670:	fc 02 16 10 	lsr	r2,lr,0x10
8000b674:	f6 03 16 10 	lsr	r3,r11,0x10
8000b678:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b67c:	e4 03 01 03 	sub	r3,r2,r3
8000b680:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b684:	fc 0b 01 0b 	sub	r11,lr,r11
8000b688:	f6 0a 00 0a 	add	r10,r11,r10
8000b68c:	b0 1a       	st.h	r8[0x2],r10
8000b68e:	b1 4a       	asr	r10,0x10
8000b690:	e6 0a 00 0a 	add	r10,r3,r10
8000b694:	b0 0a       	st.h	r8[0x0],r10
8000b696:	2f c8       	sub	r8,-4
8000b698:	b1 4a       	asr	r10,0x10
8000b69a:	08 36       	cp.w	r6,r4
8000b69c:	ce 83       	brcs	8000b66c <__mdiff+0x64>
8000b69e:	c0 d8       	rjmp	8000b6b8 <__mdiff+0xb0>
8000b6a0:	0f 0b       	ld.w	r11,r7++
8000b6a2:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b6a6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b6aa:	16 0a       	add	r10,r11
8000b6ac:	b0 1a       	st.h	r8[0x2],r10
8000b6ae:	b1 4a       	asr	r10,0x10
8000b6b0:	1c 0a       	add	r10,lr
8000b6b2:	b0 0a       	st.h	r8[0x0],r10
8000b6b4:	2f c8       	sub	r8,-4
8000b6b6:	b1 4a       	asr	r10,0x10
8000b6b8:	0a 37       	cp.w	r7,r5
8000b6ba:	cf 33       	brcs	8000b6a0 <__mdiff+0x98>
8000b6bc:	c0 28       	rjmp	8000b6c0 <__mdiff+0xb8>
8000b6be:	20 19       	sub	r9,1
8000b6c0:	11 4a       	ld.w	r10,--r8
8000b6c2:	58 0a       	cp.w	r10,0
8000b6c4:	cf d0       	breq	8000b6be <__mdiff+0xb6>
8000b6c6:	99 49       	st.w	r12[0x10],r9
8000b6c8:	d8 32       	popm	r0-r7,pc
8000b6ca:	30 0b       	mov	r11,0
8000b6cc:	c1 6f       	rcall	8000b4f8 <_Balloc>
8000b6ce:	30 18       	mov	r8,1
8000b6d0:	99 48       	st.w	r12[0x10],r8
8000b6d2:	30 08       	mov	r8,0
8000b6d4:	99 58       	st.w	r12[0x14],r8
8000b6d6:	d8 32       	popm	r0-r7,pc

8000b6d8 <__lshift>:
8000b6d8:	d4 31       	pushm	r0-r7,lr
8000b6da:	16 97       	mov	r7,r11
8000b6dc:	76 46       	ld.w	r6,r11[0x10]
8000b6de:	f4 02 14 05 	asr	r2,r10,0x5
8000b6e2:	2f f6       	sub	r6,-1
8000b6e4:	14 93       	mov	r3,r10
8000b6e6:	18 94       	mov	r4,r12
8000b6e8:	04 06       	add	r6,r2
8000b6ea:	76 1b       	ld.w	r11,r11[0x4]
8000b6ec:	6e 28       	ld.w	r8,r7[0x8]
8000b6ee:	c0 38       	rjmp	8000b6f4 <__lshift+0x1c>
8000b6f0:	2f fb       	sub	r11,-1
8000b6f2:	a1 78       	lsl	r8,0x1
8000b6f4:	10 36       	cp.w	r6,r8
8000b6f6:	fe 99 ff fd 	brgt	8000b6f0 <__lshift+0x18>
8000b6fa:	08 9c       	mov	r12,r4
8000b6fc:	cf ee       	rcall	8000b4f8 <_Balloc>
8000b6fe:	30 09       	mov	r9,0
8000b700:	18 95       	mov	r5,r12
8000b702:	f8 c8 ff ec 	sub	r8,r12,-20
8000b706:	12 9a       	mov	r10,r9
8000b708:	c0 38       	rjmp	8000b70e <__lshift+0x36>
8000b70a:	10 aa       	st.w	r8++,r10
8000b70c:	2f f9       	sub	r9,-1
8000b70e:	04 39       	cp.w	r9,r2
8000b710:	cf d5       	brlt	8000b70a <__lshift+0x32>
8000b712:	6e 4b       	ld.w	r11,r7[0x10]
8000b714:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b718:	2f bb       	sub	r11,-5
8000b71a:	ee c9 ff ec 	sub	r9,r7,-20
8000b71e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b722:	58 03       	cp.w	r3,0
8000b724:	c1 30       	breq	8000b74a <__lshift+0x72>
8000b726:	e6 0c 11 20 	rsub	r12,r3,32
8000b72a:	30 0a       	mov	r10,0
8000b72c:	72 02       	ld.w	r2,r9[0x0]
8000b72e:	e4 03 09 42 	lsl	r2,r2,r3
8000b732:	04 4a       	or	r10,r2
8000b734:	10 aa       	st.w	r8++,r10
8000b736:	13 0a       	ld.w	r10,r9++
8000b738:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b73c:	16 39       	cp.w	r9,r11
8000b73e:	cf 73       	brcs	8000b72c <__lshift+0x54>
8000b740:	91 0a       	st.w	r8[0x0],r10
8000b742:	58 0a       	cp.w	r10,0
8000b744:	c0 70       	breq	8000b752 <__lshift+0x7a>
8000b746:	2f f6       	sub	r6,-1
8000b748:	c0 58       	rjmp	8000b752 <__lshift+0x7a>
8000b74a:	13 0a       	ld.w	r10,r9++
8000b74c:	10 aa       	st.w	r8++,r10
8000b74e:	16 39       	cp.w	r9,r11
8000b750:	cf d3       	brcs	8000b74a <__lshift+0x72>
8000b752:	08 9c       	mov	r12,r4
8000b754:	20 16       	sub	r6,1
8000b756:	0e 9b       	mov	r11,r7
8000b758:	8b 46       	st.w	r5[0x10],r6
8000b75a:	cb 5e       	rcall	8000b4c4 <_Bfree>
8000b75c:	0a 9c       	mov	r12,r5
8000b75e:	d8 32       	popm	r0-r7,pc

8000b760 <__multiply>:
8000b760:	d4 31       	pushm	r0-r7,lr
8000b762:	20 2d       	sub	sp,8
8000b764:	76 49       	ld.w	r9,r11[0x10]
8000b766:	74 48       	ld.w	r8,r10[0x10]
8000b768:	16 96       	mov	r6,r11
8000b76a:	14 95       	mov	r5,r10
8000b76c:	10 39       	cp.w	r9,r8
8000b76e:	ec 08 17 50 	movlt	r8,r6
8000b772:	ea 06 17 50 	movlt	r6,r5
8000b776:	f0 05 17 50 	movlt	r5,r8
8000b77a:	6c 28       	ld.w	r8,r6[0x8]
8000b77c:	76 43       	ld.w	r3,r11[0x10]
8000b77e:	74 42       	ld.w	r2,r10[0x10]
8000b780:	76 1b       	ld.w	r11,r11[0x4]
8000b782:	e4 03 00 07 	add	r7,r2,r3
8000b786:	10 37       	cp.w	r7,r8
8000b788:	f7 bb 09 ff 	subgt	r11,-1
8000b78c:	cb 6e       	rcall	8000b4f8 <_Balloc>
8000b78e:	ee c4 ff fb 	sub	r4,r7,-5
8000b792:	f8 c9 ff ec 	sub	r9,r12,-20
8000b796:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b79a:	30 0a       	mov	r10,0
8000b79c:	12 98       	mov	r8,r9
8000b79e:	c0 28       	rjmp	8000b7a2 <__multiply+0x42>
8000b7a0:	10 aa       	st.w	r8++,r10
8000b7a2:	08 38       	cp.w	r8,r4
8000b7a4:	cf e3       	brcs	8000b7a0 <__multiply+0x40>
8000b7a6:	2f b3       	sub	r3,-5
8000b7a8:	2f b2       	sub	r2,-5
8000b7aa:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b7ae:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b7b2:	ec cb ff ec 	sub	r11,r6,-20
8000b7b6:	50 12       	stdsp	sp[0x4],r2
8000b7b8:	ea ca ff ec 	sub	r10,r5,-20
8000b7bc:	c4 48       	rjmp	8000b844 <__multiply+0xe4>
8000b7be:	94 95       	ld.uh	r5,r10[0x2]
8000b7c0:	58 05       	cp.w	r5,0
8000b7c2:	c2 00       	breq	8000b802 <__multiply+0xa2>
8000b7c4:	12 98       	mov	r8,r9
8000b7c6:	16 96       	mov	r6,r11
8000b7c8:	30 0e       	mov	lr,0
8000b7ca:	50 09       	stdsp	sp[0x0],r9
8000b7cc:	0d 02       	ld.w	r2,r6++
8000b7ce:	e4 00 16 10 	lsr	r0,r2,0x10
8000b7d2:	70 01       	ld.w	r1,r8[0x0]
8000b7d4:	70 09       	ld.w	r9,r8[0x0]
8000b7d6:	b1 81       	lsr	r1,0x10
8000b7d8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b7dc:	e0 05 03 41 	mac	r1,r0,r5
8000b7e0:	ab 32       	mul	r2,r5
8000b7e2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b7e6:	00 02       	add	r2,r0
8000b7e8:	e4 0e 00 0e 	add	lr,r2,lr
8000b7ec:	b0 1e       	st.h	r8[0x2],lr
8000b7ee:	b1 8e       	lsr	lr,0x10
8000b7f0:	1c 01       	add	r1,lr
8000b7f2:	b0 01       	st.h	r8[0x0],r1
8000b7f4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b7f8:	2f c8       	sub	r8,-4
8000b7fa:	06 36       	cp.w	r6,r3
8000b7fc:	ce 83       	brcs	8000b7cc <__multiply+0x6c>
8000b7fe:	40 09       	lddsp	r9,sp[0x0]
8000b800:	91 0e       	st.w	r8[0x0],lr
8000b802:	94 86       	ld.uh	r6,r10[0x0]
8000b804:	58 06       	cp.w	r6,0
8000b806:	c1 d0       	breq	8000b840 <__multiply+0xe0>
8000b808:	72 02       	ld.w	r2,r9[0x0]
8000b80a:	12 98       	mov	r8,r9
8000b80c:	16 9e       	mov	lr,r11
8000b80e:	30 05       	mov	r5,0
8000b810:	b0 12       	st.h	r8[0x2],r2
8000b812:	1d 01       	ld.w	r1,lr++
8000b814:	90 82       	ld.uh	r2,r8[0x0]
8000b816:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b81a:	ad 30       	mul	r0,r6
8000b81c:	e0 02 00 02 	add	r2,r0,r2
8000b820:	e4 05 00 05 	add	r5,r2,r5
8000b824:	b0 05       	st.h	r8[0x0],r5
8000b826:	b1 85       	lsr	r5,0x10
8000b828:	b1 81       	lsr	r1,0x10
8000b82a:	2f c8       	sub	r8,-4
8000b82c:	ad 31       	mul	r1,r6
8000b82e:	90 92       	ld.uh	r2,r8[0x2]
8000b830:	e2 02 00 02 	add	r2,r1,r2
8000b834:	0a 02       	add	r2,r5
8000b836:	e4 05 16 10 	lsr	r5,r2,0x10
8000b83a:	06 3e       	cp.w	lr,r3
8000b83c:	ce a3       	brcs	8000b810 <__multiply+0xb0>
8000b83e:	91 02       	st.w	r8[0x0],r2
8000b840:	2f ca       	sub	r10,-4
8000b842:	2f c9       	sub	r9,-4
8000b844:	40 18       	lddsp	r8,sp[0x4]
8000b846:	10 3a       	cp.w	r10,r8
8000b848:	cb b3       	brcs	8000b7be <__multiply+0x5e>
8000b84a:	c0 28       	rjmp	8000b84e <__multiply+0xee>
8000b84c:	20 17       	sub	r7,1
8000b84e:	58 07       	cp.w	r7,0
8000b850:	e0 8a 00 05 	brle	8000b85a <__multiply+0xfa>
8000b854:	09 48       	ld.w	r8,--r4
8000b856:	58 08       	cp.w	r8,0
8000b858:	cf a0       	breq	8000b84c <__multiply+0xec>
8000b85a:	99 47       	st.w	r12[0x10],r7
8000b85c:	2f ed       	sub	sp,-8
8000b85e:	d8 32       	popm	r0-r7,pc

8000b860 <__i2b>:
8000b860:	d4 21       	pushm	r4-r7,lr
8000b862:	16 97       	mov	r7,r11
8000b864:	30 1b       	mov	r11,1
8000b866:	c4 9e       	rcall	8000b4f8 <_Balloc>
8000b868:	30 19       	mov	r9,1
8000b86a:	99 57       	st.w	r12[0x14],r7
8000b86c:	99 49       	st.w	r12[0x10],r9
8000b86e:	d8 22       	popm	r4-r7,pc

8000b870 <__multadd>:
8000b870:	d4 31       	pushm	r0-r7,lr
8000b872:	30 08       	mov	r8,0
8000b874:	12 95       	mov	r5,r9
8000b876:	16 97       	mov	r7,r11
8000b878:	18 96       	mov	r6,r12
8000b87a:	76 44       	ld.w	r4,r11[0x10]
8000b87c:	f6 c9 ff ec 	sub	r9,r11,-20
8000b880:	72 0b       	ld.w	r11,r9[0x0]
8000b882:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b886:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b88a:	f4 0c 02 4c 	mul	r12,r10,r12
8000b88e:	f4 0b 03 45 	mac	r5,r10,r11
8000b892:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b896:	b1 85       	lsr	r5,0x10
8000b898:	18 05       	add	r5,r12
8000b89a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b89e:	f8 0b 00 0b 	add	r11,r12,r11
8000b8a2:	12 ab       	st.w	r9++,r11
8000b8a4:	2f f8       	sub	r8,-1
8000b8a6:	b1 85       	lsr	r5,0x10
8000b8a8:	08 38       	cp.w	r8,r4
8000b8aa:	ce b5       	brlt	8000b880 <__multadd+0x10>
8000b8ac:	58 05       	cp.w	r5,0
8000b8ae:	c1 c0       	breq	8000b8e6 <__multadd+0x76>
8000b8b0:	6e 28       	ld.w	r8,r7[0x8]
8000b8b2:	10 34       	cp.w	r4,r8
8000b8b4:	c1 35       	brlt	8000b8da <__multadd+0x6a>
8000b8b6:	6e 1b       	ld.w	r11,r7[0x4]
8000b8b8:	0c 9c       	mov	r12,r6
8000b8ba:	2f fb       	sub	r11,-1
8000b8bc:	c1 ee       	rcall	8000b4f8 <_Balloc>
8000b8be:	6e 4a       	ld.w	r10,r7[0x10]
8000b8c0:	ee cb ff f4 	sub	r11,r7,-12
8000b8c4:	18 93       	mov	r3,r12
8000b8c6:	2f ea       	sub	r10,-2
8000b8c8:	2f 4c       	sub	r12,-12
8000b8ca:	a3 6a       	lsl	r10,0x2
8000b8cc:	fe b0 de 70 	rcall	800075ac <memcpy>
8000b8d0:	0e 9b       	mov	r11,r7
8000b8d2:	0c 9c       	mov	r12,r6
8000b8d4:	fe b0 fd f8 	rcall	8000b4c4 <_Bfree>
8000b8d8:	06 97       	mov	r7,r3
8000b8da:	e8 c8 ff ff 	sub	r8,r4,-1
8000b8de:	2f b4       	sub	r4,-5
8000b8e0:	8f 48       	st.w	r7[0x10],r8
8000b8e2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b8e6:	0e 9c       	mov	r12,r7
8000b8e8:	d8 32       	popm	r0-r7,pc
8000b8ea:	d7 03       	nop

8000b8ec <__pow5mult>:
8000b8ec:	d4 31       	pushm	r0-r7,lr
8000b8ee:	14 96       	mov	r6,r10
8000b8f0:	18 97       	mov	r7,r12
8000b8f2:	16 94       	mov	r4,r11
8000b8f4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b8f8:	c0 90       	breq	8000b90a <__pow5mult+0x1e>
8000b8fa:	20 18       	sub	r8,1
8000b8fc:	fe c9 d9 ac 	sub	r9,pc,-9812
8000b900:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b904:	30 09       	mov	r9,0
8000b906:	cb 5f       	rcall	8000b870 <__multadd>
8000b908:	18 94       	mov	r4,r12
8000b90a:	a3 46       	asr	r6,0x2
8000b90c:	c3 40       	breq	8000b974 <__pow5mult+0x88>
8000b90e:	6e 95       	ld.w	r5,r7[0x24]
8000b910:	58 05       	cp.w	r5,0
8000b912:	c0 91       	brne	8000b924 <__pow5mult+0x38>
8000b914:	31 0c       	mov	r12,16
8000b916:	fe b0 dc 27 	rcall	80007164 <malloc>
8000b91a:	99 35       	st.w	r12[0xc],r5
8000b91c:	8f 9c       	st.w	r7[0x24],r12
8000b91e:	99 15       	st.w	r12[0x4],r5
8000b920:	99 25       	st.w	r12[0x8],r5
8000b922:	99 05       	st.w	r12[0x0],r5
8000b924:	6e 93       	ld.w	r3,r7[0x24]
8000b926:	66 25       	ld.w	r5,r3[0x8]
8000b928:	58 05       	cp.w	r5,0
8000b92a:	c0 c1       	brne	8000b942 <__pow5mult+0x56>
8000b92c:	e0 6b 02 71 	mov	r11,625
8000b930:	0e 9c       	mov	r12,r7
8000b932:	c9 7f       	rcall	8000b860 <__i2b>
8000b934:	87 2c       	st.w	r3[0x8],r12
8000b936:	30 08       	mov	r8,0
8000b938:	18 95       	mov	r5,r12
8000b93a:	99 08       	st.w	r12[0x0],r8
8000b93c:	c0 38       	rjmp	8000b942 <__pow5mult+0x56>
8000b93e:	06 9c       	mov	r12,r3
8000b940:	18 95       	mov	r5,r12
8000b942:	ed b6 00 00 	bld	r6,0x0
8000b946:	c0 b1       	brne	8000b95c <__pow5mult+0x70>
8000b948:	08 9b       	mov	r11,r4
8000b94a:	0a 9a       	mov	r10,r5
8000b94c:	0e 9c       	mov	r12,r7
8000b94e:	c0 9f       	rcall	8000b760 <__multiply>
8000b950:	08 9b       	mov	r11,r4
8000b952:	18 93       	mov	r3,r12
8000b954:	0e 9c       	mov	r12,r7
8000b956:	06 94       	mov	r4,r3
8000b958:	fe b0 fd b6 	rcall	8000b4c4 <_Bfree>
8000b95c:	a1 56       	asr	r6,0x1
8000b95e:	c0 b0       	breq	8000b974 <__pow5mult+0x88>
8000b960:	6a 03       	ld.w	r3,r5[0x0]
8000b962:	58 03       	cp.w	r3,0
8000b964:	ce d1       	brne	8000b93e <__pow5mult+0x52>
8000b966:	0a 9a       	mov	r10,r5
8000b968:	0a 9b       	mov	r11,r5
8000b96a:	0e 9c       	mov	r12,r7
8000b96c:	cf ae       	rcall	8000b760 <__multiply>
8000b96e:	8b 0c       	st.w	r5[0x0],r12
8000b970:	99 03       	st.w	r12[0x0],r3
8000b972:	ce 7b       	rjmp	8000b940 <__pow5mult+0x54>
8000b974:	08 9c       	mov	r12,r4
8000b976:	d8 32       	popm	r0-r7,pc

8000b978 <__isinfd>:
8000b978:	14 98       	mov	r8,r10
8000b97a:	fc 19 7f f0 	movh	r9,0x7ff0
8000b97e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b982:	f0 0b 11 00 	rsub	r11,r8,0
8000b986:	f7 e8 10 08 	or	r8,r11,r8
8000b98a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b98e:	f2 08 01 08 	sub	r8,r9,r8
8000b992:	f0 0c 11 00 	rsub	r12,r8,0
8000b996:	f9 e8 10 08 	or	r8,r12,r8
8000b99a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b99e:	2f fc       	sub	r12,-1
8000b9a0:	5e fc       	retal	r12

8000b9a2 <__isnand>:
8000b9a2:	14 98       	mov	r8,r10
8000b9a4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b9a8:	f0 0c 11 00 	rsub	r12,r8,0
8000b9ac:	10 4c       	or	r12,r8
8000b9ae:	fc 18 7f f0 	movh	r8,0x7ff0
8000b9b2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b9b6:	f0 0c 01 0c 	sub	r12,r8,r12
8000b9ba:	bf 9c       	lsr	r12,0x1f
8000b9bc:	5e fc       	retal	r12
8000b9be:	d7 03       	nop

8000b9c0 <__sclose>:
8000b9c0:	d4 01       	pushm	lr
8000b9c2:	96 7b       	ld.sh	r11,r11[0xe]
8000b9c4:	c8 2c       	rcall	8000bac8 <_close_r>
8000b9c6:	d8 02       	popm	pc

8000b9c8 <__sseek>:
8000b9c8:	d4 21       	pushm	r4-r7,lr
8000b9ca:	16 97       	mov	r7,r11
8000b9cc:	96 7b       	ld.sh	r11,r11[0xe]
8000b9ce:	c0 3d       	rcall	8000bbd4 <_lseek_r>
8000b9d0:	8e 68       	ld.sh	r8,r7[0xc]
8000b9d2:	10 99       	mov	r9,r8
8000b9d4:	ad c8       	cbr	r8,0xc
8000b9d6:	ad a9       	sbr	r9,0xc
8000b9d8:	5b fc       	cp.w	r12,-1
8000b9da:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b9de:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b9e2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b9e6:	d8 22       	popm	r4-r7,pc

8000b9e8 <__swrite>:
8000b9e8:	d4 21       	pushm	r4-r7,lr
8000b9ea:	96 68       	ld.sh	r8,r11[0xc]
8000b9ec:	16 97       	mov	r7,r11
8000b9ee:	14 95       	mov	r5,r10
8000b9f0:	12 94       	mov	r4,r9
8000b9f2:	e2 18 01 00 	andl	r8,0x100,COH
8000b9f6:	18 96       	mov	r6,r12
8000b9f8:	c0 50       	breq	8000ba02 <__swrite+0x1a>
8000b9fa:	30 29       	mov	r9,2
8000b9fc:	30 0a       	mov	r10,0
8000b9fe:	96 7b       	ld.sh	r11,r11[0xe]
8000ba00:	ce ac       	rcall	8000bbd4 <_lseek_r>
8000ba02:	8e 68       	ld.sh	r8,r7[0xc]
8000ba04:	ad c8       	cbr	r8,0xc
8000ba06:	08 99       	mov	r9,r4
8000ba08:	0a 9a       	mov	r10,r5
8000ba0a:	8e 7b       	ld.sh	r11,r7[0xe]
8000ba0c:	0c 9c       	mov	r12,r6
8000ba0e:	ae 68       	st.h	r7[0xc],r8
8000ba10:	c1 cc       	rcall	8000ba48 <_write_r>
8000ba12:	d8 22       	popm	r4-r7,pc

8000ba14 <__sread>:
8000ba14:	d4 21       	pushm	r4-r7,lr
8000ba16:	16 97       	mov	r7,r11
8000ba18:	96 7b       	ld.sh	r11,r11[0xe]
8000ba1a:	cf 1c       	rcall	8000bbfc <_read_r>
8000ba1c:	c0 65       	brlt	8000ba28 <__sread+0x14>
8000ba1e:	6f 58       	ld.w	r8,r7[0x54]
8000ba20:	18 08       	add	r8,r12
8000ba22:	ef 48 00 54 	st.w	r7[84],r8
8000ba26:	d8 22       	popm	r4-r7,pc
8000ba28:	8e 68       	ld.sh	r8,r7[0xc]
8000ba2a:	ad c8       	cbr	r8,0xc
8000ba2c:	ae 68       	st.h	r7[0xc],r8
8000ba2e:	d8 22       	popm	r4-r7,pc

8000ba30 <strlen>:
8000ba30:	30 09       	mov	r9,0
8000ba32:	18 98       	mov	r8,r12
8000ba34:	c0 28       	rjmp	8000ba38 <strlen+0x8>
8000ba36:	2f f8       	sub	r8,-1
8000ba38:	11 8a       	ld.ub	r10,r8[0x0]
8000ba3a:	f2 0a 18 00 	cp.b	r10,r9
8000ba3e:	cf c1       	brne	8000ba36 <strlen+0x6>
8000ba40:	f0 0c 01 0c 	sub	r12,r8,r12
8000ba44:	5e fc       	retal	r12
8000ba46:	d7 03       	nop

8000ba48 <_write_r>:
8000ba48:	d4 21       	pushm	r4-r7,lr
8000ba4a:	16 98       	mov	r8,r11
8000ba4c:	18 97       	mov	r7,r12
8000ba4e:	10 9c       	mov	r12,r8
8000ba50:	30 08       	mov	r8,0
8000ba52:	14 9b       	mov	r11,r10
8000ba54:	e0 66 5b 68 	mov	r6,23400
8000ba58:	12 9a       	mov	r10,r9
8000ba5a:	8d 08       	st.w	r6[0x0],r8
8000ba5c:	fe b0 d1 9e 	rcall	80005d98 <_write>
8000ba60:	5b fc       	cp.w	r12,-1
8000ba62:	c0 51       	brne	8000ba6c <_write_r+0x24>
8000ba64:	6c 08       	ld.w	r8,r6[0x0]
8000ba66:	58 08       	cp.w	r8,0
8000ba68:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ba6c:	d8 22       	popm	r4-r7,pc
8000ba6e:	d7 03       	nop

8000ba70 <_calloc_r>:
8000ba70:	d4 21       	pushm	r4-r7,lr
8000ba72:	f4 0b 02 4b 	mul	r11,r10,r11
8000ba76:	fe b0 db 7f 	rcall	80007174 <_malloc_r>
8000ba7a:	18 97       	mov	r7,r12
8000ba7c:	c2 30       	breq	8000bac2 <_calloc_r+0x52>
8000ba7e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ba82:	e0 1a ff fc 	andl	r10,0xfffc
8000ba86:	20 4a       	sub	r10,4
8000ba88:	e0 4a 00 24 	cp.w	r10,36
8000ba8c:	e0 8b 00 18 	brhi	8000babc <_calloc_r+0x4c>
8000ba90:	18 98       	mov	r8,r12
8000ba92:	59 3a       	cp.w	r10,19
8000ba94:	e0 88 00 0f 	brls	8000bab2 <_calloc_r+0x42>
8000ba98:	30 09       	mov	r9,0
8000ba9a:	10 a9       	st.w	r8++,r9
8000ba9c:	10 a9       	st.w	r8++,r9
8000ba9e:	59 ba       	cp.w	r10,27
8000baa0:	e0 88 00 09 	brls	8000bab2 <_calloc_r+0x42>
8000baa4:	10 a9       	st.w	r8++,r9
8000baa6:	10 a9       	st.w	r8++,r9
8000baa8:	e0 4a 00 24 	cp.w	r10,36
8000baac:	c0 31       	brne	8000bab2 <_calloc_r+0x42>
8000baae:	10 a9       	st.w	r8++,r9
8000bab0:	10 a9       	st.w	r8++,r9
8000bab2:	30 09       	mov	r9,0
8000bab4:	10 a9       	st.w	r8++,r9
8000bab6:	91 19       	st.w	r8[0x4],r9
8000bab8:	91 09       	st.w	r8[0x0],r9
8000baba:	c0 48       	rjmp	8000bac2 <_calloc_r+0x52>
8000babc:	30 0b       	mov	r11,0
8000babe:	fe b0 de 1b 	rcall	800076f4 <memset>
8000bac2:	0e 9c       	mov	r12,r7
8000bac4:	d8 22       	popm	r4-r7,pc
8000bac6:	d7 03       	nop

8000bac8 <_close_r>:
8000bac8:	d4 21       	pushm	r4-r7,lr
8000baca:	30 08       	mov	r8,0
8000bacc:	18 97       	mov	r7,r12
8000bace:	e0 66 5b 68 	mov	r6,23400
8000bad2:	16 9c       	mov	r12,r11
8000bad4:	8d 08       	st.w	r6[0x0],r8
8000bad6:	fe b0 df b5 	rcall	80007a40 <_close>
8000bada:	5b fc       	cp.w	r12,-1
8000badc:	c0 51       	brne	8000bae6 <_close_r+0x1e>
8000bade:	6c 08       	ld.w	r8,r6[0x0]
8000bae0:	58 08       	cp.w	r8,0
8000bae2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bae6:	d8 22       	popm	r4-r7,pc

8000bae8 <_fclose_r>:
8000bae8:	d4 21       	pushm	r4-r7,lr
8000baea:	18 96       	mov	r6,r12
8000baec:	16 97       	mov	r7,r11
8000baee:	58 0b       	cp.w	r11,0
8000baf0:	c0 31       	brne	8000baf6 <_fclose_r+0xe>
8000baf2:	16 95       	mov	r5,r11
8000baf4:	c5 38       	rjmp	8000bb9a <_fclose_r+0xb2>
8000baf6:	fe b0 f8 a9 	rcall	8000ac48 <__sfp_lock_acquire>
8000bafa:	58 06       	cp.w	r6,0
8000bafc:	c0 70       	breq	8000bb0a <_fclose_r+0x22>
8000bafe:	6c 68       	ld.w	r8,r6[0x18]
8000bb00:	58 08       	cp.w	r8,0
8000bb02:	c0 41       	brne	8000bb0a <_fclose_r+0x22>
8000bb04:	0c 9c       	mov	r12,r6
8000bb06:	fe b0 f8 f3 	rcall	8000acec <__sinit>
8000bb0a:	fe c8 dc 5e 	sub	r8,pc,-9122
8000bb0e:	10 37       	cp.w	r7,r8
8000bb10:	c0 31       	brne	8000bb16 <_fclose_r+0x2e>
8000bb12:	6c 07       	ld.w	r7,r6[0x0]
8000bb14:	c0 c8       	rjmp	8000bb2c <_fclose_r+0x44>
8000bb16:	fe c8 dc 4a 	sub	r8,pc,-9142
8000bb1a:	10 37       	cp.w	r7,r8
8000bb1c:	c0 31       	brne	8000bb22 <_fclose_r+0x3a>
8000bb1e:	6c 17       	ld.w	r7,r6[0x4]
8000bb20:	c0 68       	rjmp	8000bb2c <_fclose_r+0x44>
8000bb22:	fe c8 dc 36 	sub	r8,pc,-9162
8000bb26:	10 37       	cp.w	r7,r8
8000bb28:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bb2c:	8e 69       	ld.sh	r9,r7[0xc]
8000bb2e:	30 08       	mov	r8,0
8000bb30:	f0 09 19 00 	cp.h	r9,r8
8000bb34:	c0 51       	brne	8000bb3e <_fclose_r+0x56>
8000bb36:	fe b0 f8 8a 	rcall	8000ac4a <__sfp_lock_release>
8000bb3a:	30 05       	mov	r5,0
8000bb3c:	c2 f8       	rjmp	8000bb9a <_fclose_r+0xb2>
8000bb3e:	0e 9b       	mov	r11,r7
8000bb40:	0c 9c       	mov	r12,r6
8000bb42:	fe b0 f7 fd 	rcall	8000ab3c <_fflush_r>
8000bb46:	6e c8       	ld.w	r8,r7[0x30]
8000bb48:	18 95       	mov	r5,r12
8000bb4a:	58 08       	cp.w	r8,0
8000bb4c:	c0 60       	breq	8000bb58 <_fclose_r+0x70>
8000bb4e:	6e 8b       	ld.w	r11,r7[0x20]
8000bb50:	0c 9c       	mov	r12,r6
8000bb52:	5d 18       	icall	r8
8000bb54:	f9 b5 05 ff 	movlt	r5,-1
8000bb58:	8e 68       	ld.sh	r8,r7[0xc]
8000bb5a:	ed b8 00 07 	bld	r8,0x7
8000bb5e:	c0 51       	brne	8000bb68 <_fclose_r+0x80>
8000bb60:	6e 4b       	ld.w	r11,r7[0x10]
8000bb62:	0c 9c       	mov	r12,r6
8000bb64:	fe b0 f9 5e 	rcall	8000ae20 <_free_r>
8000bb68:	6e db       	ld.w	r11,r7[0x34]
8000bb6a:	58 0b       	cp.w	r11,0
8000bb6c:	c0 a0       	breq	8000bb80 <_fclose_r+0x98>
8000bb6e:	ee c8 ff bc 	sub	r8,r7,-68
8000bb72:	10 3b       	cp.w	r11,r8
8000bb74:	c0 40       	breq	8000bb7c <_fclose_r+0x94>
8000bb76:	0c 9c       	mov	r12,r6
8000bb78:	fe b0 f9 54 	rcall	8000ae20 <_free_r>
8000bb7c:	30 08       	mov	r8,0
8000bb7e:	8f d8       	st.w	r7[0x34],r8
8000bb80:	6f 2b       	ld.w	r11,r7[0x48]
8000bb82:	58 0b       	cp.w	r11,0
8000bb84:	c0 70       	breq	8000bb92 <_fclose_r+0xaa>
8000bb86:	0c 9c       	mov	r12,r6
8000bb88:	fe b0 f9 4c 	rcall	8000ae20 <_free_r>
8000bb8c:	30 08       	mov	r8,0
8000bb8e:	ef 48 00 48 	st.w	r7[72],r8
8000bb92:	30 08       	mov	r8,0
8000bb94:	ae 68       	st.h	r7[0xc],r8
8000bb96:	fe b0 f8 5a 	rcall	8000ac4a <__sfp_lock_release>
8000bb9a:	0a 9c       	mov	r12,r5
8000bb9c:	d8 22       	popm	r4-r7,pc
8000bb9e:	d7 03       	nop

8000bba0 <fclose>:
8000bba0:	d4 01       	pushm	lr
8000bba2:	e0 68 0a 3c 	mov	r8,2620
8000bba6:	18 9b       	mov	r11,r12
8000bba8:	70 0c       	ld.w	r12,r8[0x0]
8000bbaa:	c9 ff       	rcall	8000bae8 <_fclose_r>
8000bbac:	d8 02       	popm	pc
8000bbae:	d7 03       	nop

8000bbb0 <_fstat_r>:
8000bbb0:	d4 21       	pushm	r4-r7,lr
8000bbb2:	16 98       	mov	r8,r11
8000bbb4:	18 97       	mov	r7,r12
8000bbb6:	10 9c       	mov	r12,r8
8000bbb8:	30 08       	mov	r8,0
8000bbba:	e0 66 5b 68 	mov	r6,23400
8000bbbe:	14 9b       	mov	r11,r10
8000bbc0:	8d 08       	st.w	r6[0x0],r8
8000bbc2:	fe b0 df 67 	rcall	80007a90 <_fstat>
8000bbc6:	5b fc       	cp.w	r12,-1
8000bbc8:	c0 51       	brne	8000bbd2 <_fstat_r+0x22>
8000bbca:	6c 08       	ld.w	r8,r6[0x0]
8000bbcc:	58 08       	cp.w	r8,0
8000bbce:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbd2:	d8 22       	popm	r4-r7,pc

8000bbd4 <_lseek_r>:
8000bbd4:	d4 21       	pushm	r4-r7,lr
8000bbd6:	16 98       	mov	r8,r11
8000bbd8:	18 97       	mov	r7,r12
8000bbda:	10 9c       	mov	r12,r8
8000bbdc:	30 08       	mov	r8,0
8000bbde:	14 9b       	mov	r11,r10
8000bbe0:	e0 66 5b 68 	mov	r6,23400
8000bbe4:	12 9a       	mov	r10,r9
8000bbe6:	8d 08       	st.w	r6[0x0],r8
8000bbe8:	fe b0 df 36 	rcall	80007a54 <_lseek>
8000bbec:	5b fc       	cp.w	r12,-1
8000bbee:	c0 51       	brne	8000bbf8 <_lseek_r+0x24>
8000bbf0:	6c 08       	ld.w	r8,r6[0x0]
8000bbf2:	58 08       	cp.w	r8,0
8000bbf4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbf8:	d8 22       	popm	r4-r7,pc
8000bbfa:	d7 03       	nop

8000bbfc <_read_r>:
8000bbfc:	d4 21       	pushm	r4-r7,lr
8000bbfe:	16 98       	mov	r8,r11
8000bc00:	18 97       	mov	r7,r12
8000bc02:	10 9c       	mov	r12,r8
8000bc04:	30 08       	mov	r8,0
8000bc06:	14 9b       	mov	r11,r10
8000bc08:	e0 66 5b 68 	mov	r6,23400
8000bc0c:	12 9a       	mov	r10,r9
8000bc0e:	8d 08       	st.w	r6[0x0],r8
8000bc10:	fe b0 d0 a4 	rcall	80005d58 <_read>
8000bc14:	5b fc       	cp.w	r12,-1
8000bc16:	c0 51       	brne	8000bc20 <_read_r+0x24>
8000bc18:	6c 08       	ld.w	r8,r6[0x0]
8000bc1a:	58 08       	cp.w	r8,0
8000bc1c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc20:	d8 22       	popm	r4-r7,pc
8000bc22:	d7 03       	nop

8000bc24 <__avr32_f64_mul>:
8000bc24:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bc28:	e0 80 00 dc 	breq	8000bde0 <__avr32_f64_mul_op1_zero>
8000bc2c:	d4 21       	pushm	r4-r7,lr
8000bc2e:	f7 e9 20 0e 	eor	lr,r11,r9
8000bc32:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bc36:	30 15       	mov	r5,1
8000bc38:	c4 30       	breq	8000bcbe <__avr32_f64_mul_op1_subnormal>
8000bc3a:	ab 6b       	lsl	r11,0xa
8000bc3c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bc40:	ab 6a       	lsl	r10,0xa
8000bc42:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bc46:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bc4a:	c5 c0       	breq	8000bd02 <__avr32_f64_mul_op2_subnormal>
8000bc4c:	a1 78       	lsl	r8,0x1
8000bc4e:	5c f9       	rol	r9
8000bc50:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bc54:	e0 47 07 ff 	cp.w	r7,2047
8000bc58:	c7 70       	breq	8000bd46 <__avr32_f64_mul_op_nan_or_inf>
8000bc5a:	e0 46 07 ff 	cp.w	r6,2047
8000bc5e:	c7 40       	breq	8000bd46 <__avr32_f64_mul_op_nan_or_inf>
8000bc60:	ee 06 00 0c 	add	r12,r7,r6
8000bc64:	e0 2c 03 fe 	sub	r12,1022
8000bc68:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bc6c:	f4 09 07 44 	macu.d	r4,r10,r9
8000bc70:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bc74:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bc78:	08 07       	add	r7,r4
8000bc7a:	f4 05 00 4a 	adc	r10,r10,r5
8000bc7e:	5c 0b       	acr	r11
8000bc80:	ed bb 00 14 	bld	r11,0x14
8000bc84:	c0 50       	breq	8000bc8e <__avr32_f64_mul+0x6a>
8000bc86:	a1 77       	lsl	r7,0x1
8000bc88:	5c fa       	rol	r10
8000bc8a:	5c fb       	rol	r11
8000bc8c:	20 1c       	sub	r12,1
8000bc8e:	58 0c       	cp.w	r12,0
8000bc90:	e0 8a 00 6f 	brle	8000bd6e <__avr32_f64_mul_res_subnormal>
8000bc94:	e0 4c 07 ff 	cp.w	r12,2047
8000bc98:	e0 84 00 9c 	brge	8000bdd0 <__avr32_f64_mul_res_inf>
8000bc9c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bca0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bca4:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bca8:	ee 17 80 00 	eorh	r7,0x8000
8000bcac:	f1 b7 04 20 	satu	r7,0x1
8000bcb0:	0e 0a       	add	r10,r7
8000bcb2:	5c 0b       	acr	r11
8000bcb4:	ed be 00 1f 	bld	lr,0x1f
8000bcb8:	ef bb 00 1f 	bst	r11,0x1f
8000bcbc:	d8 22       	popm	r4-r7,pc

8000bcbe <__avr32_f64_mul_op1_subnormal>:
8000bcbe:	e4 1b 00 0f 	andh	r11,0xf
8000bcc2:	f4 0c 12 00 	clz	r12,r10
8000bcc6:	f6 06 12 00 	clz	r6,r11
8000bcca:	f7 bc 03 e1 	sublo	r12,-31
8000bcce:	f8 06 17 30 	movlo	r6,r12
8000bcd2:	f7 b6 02 01 	subhs	r6,1
8000bcd6:	e0 46 00 20 	cp.w	r6,32
8000bcda:	c0 d4       	brge	8000bcf4 <__avr32_f64_mul_op1_subnormal+0x36>
8000bcdc:	ec 0c 11 20 	rsub	r12,r6,32
8000bce0:	f6 06 09 4b 	lsl	r11,r11,r6
8000bce4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bce8:	18 4b       	or	r11,r12
8000bcea:	f4 06 09 4a 	lsl	r10,r10,r6
8000bcee:	20 b6       	sub	r6,11
8000bcf0:	0c 17       	sub	r7,r6
8000bcf2:	ca ab       	rjmp	8000bc46 <__avr32_f64_mul+0x22>
8000bcf4:	f4 06 09 4b 	lsl	r11,r10,r6
8000bcf8:	c6 40       	breq	8000bdc0 <__avr32_f64_mul_res_zero>
8000bcfa:	30 0a       	mov	r10,0
8000bcfc:	20 b6       	sub	r6,11
8000bcfe:	0c 17       	sub	r7,r6
8000bd00:	ca 3b       	rjmp	8000bc46 <__avr32_f64_mul+0x22>

8000bd02 <__avr32_f64_mul_op2_subnormal>:
8000bd02:	e4 19 00 0f 	andh	r9,0xf
8000bd06:	f0 0c 12 00 	clz	r12,r8
8000bd0a:	f2 05 12 00 	clz	r5,r9
8000bd0e:	f7 bc 03 ea 	sublo	r12,-22
8000bd12:	f8 05 17 30 	movlo	r5,r12
8000bd16:	f7 b5 02 0a 	subhs	r5,10
8000bd1a:	e0 45 00 20 	cp.w	r5,32
8000bd1e:	c0 d4       	brge	8000bd38 <__avr32_f64_mul_op2_subnormal+0x36>
8000bd20:	ea 0c 11 20 	rsub	r12,r5,32
8000bd24:	f2 05 09 49 	lsl	r9,r9,r5
8000bd28:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bd2c:	18 49       	or	r9,r12
8000bd2e:	f0 05 09 48 	lsl	r8,r8,r5
8000bd32:	20 25       	sub	r5,2
8000bd34:	0a 16       	sub	r6,r5
8000bd36:	c8 fb       	rjmp	8000bc54 <__avr32_f64_mul+0x30>
8000bd38:	f0 05 09 49 	lsl	r9,r8,r5
8000bd3c:	c4 20       	breq	8000bdc0 <__avr32_f64_mul_res_zero>
8000bd3e:	30 08       	mov	r8,0
8000bd40:	20 25       	sub	r5,2
8000bd42:	0a 16       	sub	r6,r5
8000bd44:	c8 8b       	rjmp	8000bc54 <__avr32_f64_mul+0x30>

8000bd46 <__avr32_f64_mul_op_nan_or_inf>:
8000bd46:	e4 19 00 0f 	andh	r9,0xf
8000bd4a:	e4 1b 00 0f 	andh	r11,0xf
8000bd4e:	14 4b       	or	r11,r10
8000bd50:	10 49       	or	r9,r8
8000bd52:	e0 47 07 ff 	cp.w	r7,2047
8000bd56:	c0 91       	brne	8000bd68 <__avr32_f64_mul_op1_not_naninf>
8000bd58:	58 0b       	cp.w	r11,0
8000bd5a:	c3 81       	brne	8000bdca <__avr32_f64_mul_res_nan>
8000bd5c:	e0 46 07 ff 	cp.w	r6,2047
8000bd60:	c3 81       	brne	8000bdd0 <__avr32_f64_mul_res_inf>
8000bd62:	58 09       	cp.w	r9,0
8000bd64:	c3 60       	breq	8000bdd0 <__avr32_f64_mul_res_inf>
8000bd66:	c3 28       	rjmp	8000bdca <__avr32_f64_mul_res_nan>

8000bd68 <__avr32_f64_mul_op1_not_naninf>:
8000bd68:	58 09       	cp.w	r9,0
8000bd6a:	c3 30       	breq	8000bdd0 <__avr32_f64_mul_res_inf>
8000bd6c:	c2 f8       	rjmp	8000bdca <__avr32_f64_mul_res_nan>

8000bd6e <__avr32_f64_mul_res_subnormal>:
8000bd6e:	5c 3c       	neg	r12
8000bd70:	2f fc       	sub	r12,-1
8000bd72:	f1 bc 04 c0 	satu	r12,0x6
8000bd76:	e0 4c 00 20 	cp.w	r12,32
8000bd7a:	c1 14       	brge	8000bd9c <__avr32_f64_mul_res_subnormal+0x2e>
8000bd7c:	f8 08 11 20 	rsub	r8,r12,32
8000bd80:	0e 46       	or	r6,r7
8000bd82:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bd86:	f4 08 09 49 	lsl	r9,r10,r8
8000bd8a:	12 47       	or	r7,r9
8000bd8c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bd90:	f6 08 09 49 	lsl	r9,r11,r8
8000bd94:	12 4a       	or	r10,r9
8000bd96:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bd9a:	c8 3b       	rjmp	8000bca0 <__avr32_f64_mul+0x7c>
8000bd9c:	f8 08 11 20 	rsub	r8,r12,32
8000bda0:	f9 b9 00 00 	moveq	r9,0
8000bda4:	c0 30       	breq	8000bdaa <__avr32_f64_mul_res_subnormal+0x3c>
8000bda6:	f6 08 09 49 	lsl	r9,r11,r8
8000bdaa:	0e 46       	or	r6,r7
8000bdac:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bdb0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bdb4:	f3 ea 10 07 	or	r7,r9,r10
8000bdb8:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bdbc:	30 0b       	mov	r11,0
8000bdbe:	c7 1b       	rjmp	8000bca0 <__avr32_f64_mul+0x7c>

8000bdc0 <__avr32_f64_mul_res_zero>:
8000bdc0:	1c 9b       	mov	r11,lr
8000bdc2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bdc6:	30 0a       	mov	r10,0
8000bdc8:	d8 22       	popm	r4-r7,pc

8000bdca <__avr32_f64_mul_res_nan>:
8000bdca:	3f fb       	mov	r11,-1
8000bdcc:	3f fa       	mov	r10,-1
8000bdce:	d8 22       	popm	r4-r7,pc

8000bdd0 <__avr32_f64_mul_res_inf>:
8000bdd0:	f0 6b 00 00 	mov	r11,-1048576
8000bdd4:	ed be 00 1f 	bld	lr,0x1f
8000bdd8:	ef bb 00 1f 	bst	r11,0x1f
8000bddc:	30 0a       	mov	r10,0
8000bdde:	d8 22       	popm	r4-r7,pc

8000bde0 <__avr32_f64_mul_op1_zero>:
8000bde0:	f7 e9 20 0b 	eor	r11,r11,r9
8000bde4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bde8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bdec:	e0 4c 07 ff 	cp.w	r12,2047
8000bdf0:	5e 1c       	retne	r12
8000bdf2:	3f fa       	mov	r10,-1
8000bdf4:	3f fb       	mov	r11,-1
8000bdf6:	5e fc       	retal	r12

8000bdf8 <__avr32_f64_sub_from_add>:
8000bdf8:	ee 19 80 00 	eorh	r9,0x8000

8000bdfc <__avr32_f64_sub>:
8000bdfc:	f7 e9 20 0c 	eor	r12,r11,r9
8000be00:	e0 86 00 ca 	brmi	8000bf94 <__avr32_f64_add_from_sub>
8000be04:	eb cd 40 e0 	pushm	r5-r7,lr
8000be08:	16 9c       	mov	r12,r11
8000be0a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000be0e:	bf db       	cbr	r11,0x1f
8000be10:	bf d9       	cbr	r9,0x1f
8000be12:	10 3a       	cp.w	r10,r8
8000be14:	f2 0b 13 00 	cpc	r11,r9
8000be18:	c0 92       	brcc	8000be2a <__avr32_f64_sub+0x2e>
8000be1a:	16 97       	mov	r7,r11
8000be1c:	12 9b       	mov	r11,r9
8000be1e:	0e 99       	mov	r9,r7
8000be20:	14 97       	mov	r7,r10
8000be22:	10 9a       	mov	r10,r8
8000be24:	0e 98       	mov	r8,r7
8000be26:	ee 1c 80 00 	eorh	r12,0x8000
8000be2a:	f6 07 16 14 	lsr	r7,r11,0x14
8000be2e:	ab 7b       	lsl	r11,0xb
8000be30:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000be34:	ab 7a       	lsl	r10,0xb
8000be36:	bf bb       	sbr	r11,0x1f
8000be38:	f2 06 16 14 	lsr	r6,r9,0x14
8000be3c:	c4 40       	breq	8000bec4 <__avr32_f64_sub_opL_subnormal>
8000be3e:	ab 79       	lsl	r9,0xb
8000be40:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000be44:	ab 78       	lsl	r8,0xb
8000be46:	bf b9       	sbr	r9,0x1f

8000be48 <__avr32_f64_sub_opL_subnormal_done>:
8000be48:	e0 47 07 ff 	cp.w	r7,2047
8000be4c:	c4 f0       	breq	8000beea <__avr32_f64_sub_opH_nan_or_inf>
8000be4e:	0e 26       	rsub	r6,r7
8000be50:	c1 20       	breq	8000be74 <__avr32_f64_sub_shift_done>
8000be52:	ec 05 11 20 	rsub	r5,r6,32
8000be56:	e0 46 00 20 	cp.w	r6,32
8000be5a:	c7 c2       	brcc	8000bf52 <__avr32_f64_sub_longshift>
8000be5c:	f0 05 09 4e 	lsl	lr,r8,r5
8000be60:	f2 05 09 45 	lsl	r5,r9,r5
8000be64:	f0 06 0a 48 	lsr	r8,r8,r6
8000be68:	f2 06 0a 49 	lsr	r9,r9,r6
8000be6c:	0a 48       	or	r8,r5
8000be6e:	58 0e       	cp.w	lr,0
8000be70:	5f 1e       	srne	lr
8000be72:	1c 48       	or	r8,lr

8000be74 <__avr32_f64_sub_shift_done>:
8000be74:	10 1a       	sub	r10,r8
8000be76:	f6 09 01 4b 	sbc	r11,r11,r9
8000be7a:	f6 06 12 00 	clz	r6,r11
8000be7e:	c0 e0       	breq	8000be9a <__avr32_f64_sub_longnormalize_done>
8000be80:	c7 83       	brcs	8000bf70 <__avr32_f64_sub_longnormalize>
8000be82:	ec 0e 11 20 	rsub	lr,r6,32
8000be86:	f6 06 09 4b 	lsl	r11,r11,r6
8000be8a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000be8e:	1c 4b       	or	r11,lr
8000be90:	f4 06 09 4a 	lsl	r10,r10,r6
8000be94:	0c 17       	sub	r7,r6
8000be96:	e0 8a 00 39 	brle	8000bf08 <__avr32_f64_sub_subnormal_result>

8000be9a <__avr32_f64_sub_longnormalize_done>:
8000be9a:	f4 09 15 15 	lsl	r9,r10,0x15
8000be9e:	ab 9a       	lsr	r10,0xb
8000bea0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bea4:	ab 9b       	lsr	r11,0xb
8000bea6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000beaa:	18 4b       	or	r11,r12

8000beac <__avr32_f64_sub_round>:
8000beac:	fc 17 80 00 	movh	r7,0x8000
8000beb0:	ed ba 00 00 	bld	r10,0x0
8000beb4:	f7 b7 01 ff 	subne	r7,-1
8000beb8:	0e 39       	cp.w	r9,r7
8000beba:	5f 29       	srhs	r9
8000bebc:	12 0a       	add	r10,r9
8000bebe:	5c 0b       	acr	r11
8000bec0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bec4 <__avr32_f64_sub_opL_subnormal>:
8000bec4:	ab 79       	lsl	r9,0xb
8000bec6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000beca:	ab 78       	lsl	r8,0xb
8000becc:	f3 e8 10 0e 	or	lr,r9,r8
8000bed0:	f9 b6 01 01 	movne	r6,1
8000bed4:	ee 0e 11 00 	rsub	lr,r7,0
8000bed8:	f9 b7 00 01 	moveq	r7,1
8000bedc:	ef bb 00 1f 	bst	r11,0x1f
8000bee0:	f7 ea 10 0e 	or	lr,r11,r10
8000bee4:	f9 b7 00 00 	moveq	r7,0
8000bee8:	cb 0b       	rjmp	8000be48 <__avr32_f64_sub_opL_subnormal_done>

8000beea <__avr32_f64_sub_opH_nan_or_inf>:
8000beea:	bf db       	cbr	r11,0x1f
8000beec:	f7 ea 10 0e 	or	lr,r11,r10
8000bef0:	c0 81       	brne	8000bf00 <__avr32_f64_sub_return_nan>
8000bef2:	e0 46 07 ff 	cp.w	r6,2047
8000bef6:	c0 50       	breq	8000bf00 <__avr32_f64_sub_return_nan>
8000bef8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000befc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf00 <__avr32_f64_sub_return_nan>:
8000bf00:	3f fa       	mov	r10,-1
8000bf02:	3f fb       	mov	r11,-1
8000bf04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf08 <__avr32_f64_sub_subnormal_result>:
8000bf08:	5c 37       	neg	r7
8000bf0a:	2f f7       	sub	r7,-1
8000bf0c:	f1 b7 04 c0 	satu	r7,0x6
8000bf10:	e0 47 00 20 	cp.w	r7,32
8000bf14:	c1 14       	brge	8000bf36 <__avr32_f64_sub_subnormal_result+0x2e>
8000bf16:	ee 08 11 20 	rsub	r8,r7,32
8000bf1a:	f4 08 09 49 	lsl	r9,r10,r8
8000bf1e:	5f 16       	srne	r6
8000bf20:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bf24:	0c 4a       	or	r10,r6
8000bf26:	f6 08 09 49 	lsl	r9,r11,r8
8000bf2a:	f5 e9 10 0a 	or	r10,r10,r9
8000bf2e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bf32:	30 07       	mov	r7,0
8000bf34:	cb 3b       	rjmp	8000be9a <__avr32_f64_sub_longnormalize_done>
8000bf36:	ee 08 11 40 	rsub	r8,r7,64
8000bf3a:	f6 08 09 49 	lsl	r9,r11,r8
8000bf3e:	14 49       	or	r9,r10
8000bf40:	5f 16       	srne	r6
8000bf42:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bf46:	0c 4a       	or	r10,r6
8000bf48:	30 0b       	mov	r11,0
8000bf4a:	30 07       	mov	r7,0
8000bf4c:	ca 7b       	rjmp	8000be9a <__avr32_f64_sub_longnormalize_done>
8000bf4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf52 <__avr32_f64_sub_longshift>:
8000bf52:	f1 b6 04 c0 	satu	r6,0x6
8000bf56:	f0 0e 17 00 	moveq	lr,r8
8000bf5a:	c0 40       	breq	8000bf62 <__avr32_f64_sub_longshift+0x10>
8000bf5c:	f2 05 09 4e 	lsl	lr,r9,r5
8000bf60:	10 4e       	or	lr,r8
8000bf62:	f2 06 0a 48 	lsr	r8,r9,r6
8000bf66:	30 09       	mov	r9,0
8000bf68:	58 0e       	cp.w	lr,0
8000bf6a:	5f 1e       	srne	lr
8000bf6c:	1c 48       	or	r8,lr
8000bf6e:	c8 3b       	rjmp	8000be74 <__avr32_f64_sub_shift_done>

8000bf70 <__avr32_f64_sub_longnormalize>:
8000bf70:	f4 06 12 00 	clz	r6,r10
8000bf74:	f9 b7 03 00 	movlo	r7,0
8000bf78:	f9 b6 03 00 	movlo	r6,0
8000bf7c:	f9 bc 03 00 	movlo	r12,0
8000bf80:	f7 b6 02 e0 	subhs	r6,-32
8000bf84:	f4 06 09 4b 	lsl	r11,r10,r6
8000bf88:	30 0a       	mov	r10,0
8000bf8a:	0c 17       	sub	r7,r6
8000bf8c:	fe 9a ff be 	brle	8000bf08 <__avr32_f64_sub_subnormal_result>
8000bf90:	c8 5b       	rjmp	8000be9a <__avr32_f64_sub_longnormalize_done>
8000bf92:	d7 03       	nop

8000bf94 <__avr32_f64_add_from_sub>:
8000bf94:	ee 19 80 00 	eorh	r9,0x8000

8000bf98 <__avr32_f64_add>:
8000bf98:	f7 e9 20 0c 	eor	r12,r11,r9
8000bf9c:	fe 96 ff 2e 	brmi	8000bdf8 <__avr32_f64_sub_from_add>
8000bfa0:	eb cd 40 e0 	pushm	r5-r7,lr
8000bfa4:	16 9c       	mov	r12,r11
8000bfa6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bfaa:	bf db       	cbr	r11,0x1f
8000bfac:	bf d9       	cbr	r9,0x1f
8000bfae:	12 3b       	cp.w	r11,r9
8000bfb0:	c0 72       	brcc	8000bfbe <__avr32_f64_add+0x26>
8000bfb2:	16 97       	mov	r7,r11
8000bfb4:	12 9b       	mov	r11,r9
8000bfb6:	0e 99       	mov	r9,r7
8000bfb8:	14 97       	mov	r7,r10
8000bfba:	10 9a       	mov	r10,r8
8000bfbc:	0e 98       	mov	r8,r7
8000bfbe:	30 0e       	mov	lr,0
8000bfc0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bfc4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bfc8:	b5 ab       	sbr	r11,0x14
8000bfca:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bfce:	c6 20       	breq	8000c092 <__avr32_f64_add_op2_subnormal>
8000bfd0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bfd4:	b5 a9       	sbr	r9,0x14
8000bfd6:	e0 47 07 ff 	cp.w	r7,2047
8000bfda:	c2 80       	breq	8000c02a <__avr32_f64_add_opH_nan_or_inf>
8000bfdc:	0e 26       	rsub	r6,r7
8000bfde:	c1 20       	breq	8000c002 <__avr32_f64_add_shift_done>
8000bfe0:	e0 46 00 36 	cp.w	r6,54
8000bfe4:	c1 52       	brcc	8000c00e <__avr32_f64_add_res_of_done>
8000bfe6:	ec 05 11 20 	rsub	r5,r6,32
8000bfea:	e0 46 00 20 	cp.w	r6,32
8000bfee:	c3 52       	brcc	8000c058 <__avr32_f64_add_longshift>
8000bff0:	f0 05 09 4e 	lsl	lr,r8,r5
8000bff4:	f2 05 09 45 	lsl	r5,r9,r5
8000bff8:	f0 06 0a 48 	lsr	r8,r8,r6
8000bffc:	f2 06 0a 49 	lsr	r9,r9,r6
8000c000:	0a 48       	or	r8,r5

8000c002 <__avr32_f64_add_shift_done>:
8000c002:	10 0a       	add	r10,r8
8000c004:	f6 09 00 4b 	adc	r11,r11,r9
8000c008:	ed bb 00 15 	bld	r11,0x15
8000c00c:	c3 40       	breq	8000c074 <__avr32_f64_add_res_of>

8000c00e <__avr32_f64_add_res_of_done>:
8000c00e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c012:	18 4b       	or	r11,r12

8000c014 <__avr32_f64_add_round>:
8000c014:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c018:	18 4e       	or	lr,r12
8000c01a:	ee 1e 80 00 	eorh	lr,0x8000
8000c01e:	f1 be 04 20 	satu	lr,0x1
8000c022:	1c 0a       	add	r10,lr
8000c024:	5c 0b       	acr	r11
8000c026:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c02a <__avr32_f64_add_opH_nan_or_inf>:
8000c02a:	b5 cb       	cbr	r11,0x14
8000c02c:	f7 ea 10 0e 	or	lr,r11,r10
8000c030:	c1 01       	brne	8000c050 <__avr32_f64_add_return_nan>
8000c032:	e0 46 07 ff 	cp.w	r6,2047
8000c036:	c0 30       	breq	8000c03c <__avr32_f64_add_opL_nan_or_inf>
8000c038:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c03c <__avr32_f64_add_opL_nan_or_inf>:
8000c03c:	b5 c9       	cbr	r9,0x14
8000c03e:	f3 e8 10 0e 	or	lr,r9,r8
8000c042:	c0 71       	brne	8000c050 <__avr32_f64_add_return_nan>
8000c044:	30 0a       	mov	r10,0
8000c046:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c04a:	18 4b       	or	r11,r12
8000c04c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c050 <__avr32_f64_add_return_nan>:
8000c050:	3f fa       	mov	r10,-1
8000c052:	3f fb       	mov	r11,-1
8000c054:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c058 <__avr32_f64_add_longshift>:
8000c058:	f1 b6 04 c0 	satu	r6,0x6
8000c05c:	f0 0e 17 00 	moveq	lr,r8
8000c060:	c0 60       	breq	8000c06c <__avr32_f64_add_longshift+0x14>
8000c062:	f2 05 09 4e 	lsl	lr,r9,r5
8000c066:	58 08       	cp.w	r8,0
8000c068:	5f 18       	srne	r8
8000c06a:	10 4e       	or	lr,r8
8000c06c:	f2 06 0a 48 	lsr	r8,r9,r6
8000c070:	30 09       	mov	r9,0
8000c072:	cc 8b       	rjmp	8000c002 <__avr32_f64_add_shift_done>

8000c074 <__avr32_f64_add_res_of>:
8000c074:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c078:	a1 9b       	lsr	r11,0x1
8000c07a:	5d 0a       	ror	r10
8000c07c:	5d 0e       	ror	lr
8000c07e:	2f f7       	sub	r7,-1
8000c080:	e0 47 07 ff 	cp.w	r7,2047
8000c084:	f9 ba 00 00 	moveq	r10,0
8000c088:	f9 bb 00 00 	moveq	r11,0
8000c08c:	f9 be 00 00 	moveq	lr,0
8000c090:	cb fb       	rjmp	8000c00e <__avr32_f64_add_res_of_done>

8000c092 <__avr32_f64_add_op2_subnormal>:
8000c092:	30 16       	mov	r6,1
8000c094:	58 07       	cp.w	r7,0
8000c096:	ca 01       	brne	8000bfd6 <__avr32_f64_add+0x3e>
8000c098:	b5 cb       	cbr	r11,0x14
8000c09a:	10 0a       	add	r10,r8
8000c09c:	f6 09 00 4b 	adc	r11,r11,r9
8000c0a0:	18 4b       	or	r11,r12
8000c0a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c0a6:	d7 03       	nop

8000c0a8 <__avr32_f64_to_u32>:
8000c0a8:	58 0b       	cp.w	r11,0
8000c0aa:	5e 6d       	retmi	0

8000c0ac <__avr32_f64_to_s32>:
8000c0ac:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c0b0:	b5 9c       	lsr	r12,0x15
8000c0b2:	e0 2c 03 ff 	sub	r12,1023
8000c0b6:	5e 3d       	retlo	0
8000c0b8:	f8 0c 11 1f 	rsub	r12,r12,31
8000c0bc:	16 99       	mov	r9,r11
8000c0be:	ab 7b       	lsl	r11,0xb
8000c0c0:	bf bb       	sbr	r11,0x1f
8000c0c2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c0c6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c0ca:	a1 79       	lsl	r9,0x1
8000c0cc:	5e 2b       	reths	r11
8000c0ce:	5c 3b       	neg	r11
8000c0d0:	5e fb       	retal	r11

8000c0d2 <__avr32_u32_to_f64>:
8000c0d2:	f8 cb 00 00 	sub	r11,r12,0
8000c0d6:	30 0c       	mov	r12,0
8000c0d8:	c0 38       	rjmp	8000c0de <__avr32_s32_to_f64+0x4>

8000c0da <__avr32_s32_to_f64>:
8000c0da:	18 9b       	mov	r11,r12
8000c0dc:	5c 4b       	abs	r11
8000c0de:	30 0a       	mov	r10,0
8000c0e0:	5e 0b       	reteq	r11
8000c0e2:	d4 01       	pushm	lr
8000c0e4:	e0 69 04 1e 	mov	r9,1054
8000c0e8:	f6 08 12 00 	clz	r8,r11
8000c0ec:	c1 70       	breq	8000c11a <__avr32_s32_to_f64+0x40>
8000c0ee:	c0 c3       	brcs	8000c106 <__avr32_s32_to_f64+0x2c>
8000c0f0:	f0 0e 11 20 	rsub	lr,r8,32
8000c0f4:	f6 08 09 4b 	lsl	r11,r11,r8
8000c0f8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c0fc:	1c 4b       	or	r11,lr
8000c0fe:	f4 08 09 4a 	lsl	r10,r10,r8
8000c102:	10 19       	sub	r9,r8
8000c104:	c0 b8       	rjmp	8000c11a <__avr32_s32_to_f64+0x40>
8000c106:	f4 08 12 00 	clz	r8,r10
8000c10a:	f9 b8 03 00 	movlo	r8,0
8000c10e:	f7 b8 02 e0 	subhs	r8,-32
8000c112:	f4 08 09 4b 	lsl	r11,r10,r8
8000c116:	30 0a       	mov	r10,0
8000c118:	10 19       	sub	r9,r8
8000c11a:	58 09       	cp.w	r9,0
8000c11c:	e0 89 00 30 	brgt	8000c17c <__avr32_s32_to_f64+0xa2>
8000c120:	5c 39       	neg	r9
8000c122:	2f f9       	sub	r9,-1
8000c124:	e0 49 00 36 	cp.w	r9,54
8000c128:	c0 43       	brcs	8000c130 <__avr32_s32_to_f64+0x56>
8000c12a:	30 0b       	mov	r11,0
8000c12c:	30 0a       	mov	r10,0
8000c12e:	c2 68       	rjmp	8000c17a <__avr32_s32_to_f64+0xa0>
8000c130:	2f 69       	sub	r9,-10
8000c132:	f2 08 11 20 	rsub	r8,r9,32
8000c136:	e0 49 00 20 	cp.w	r9,32
8000c13a:	c0 b2       	brcc	8000c150 <__avr32_s32_to_f64+0x76>
8000c13c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c140:	f6 08 09 48 	lsl	r8,r11,r8
8000c144:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c148:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c14c:	10 4b       	or	r11,r8
8000c14e:	c0 88       	rjmp	8000c15e <__avr32_s32_to_f64+0x84>
8000c150:	f6 08 09 4e 	lsl	lr,r11,r8
8000c154:	14 4e       	or	lr,r10
8000c156:	16 9a       	mov	r10,r11
8000c158:	30 0b       	mov	r11,0
8000c15a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c15e:	ed ba 00 00 	bld	r10,0x0
8000c162:	c0 92       	brcc	8000c174 <__avr32_s32_to_f64+0x9a>
8000c164:	1c 7e       	tst	lr,lr
8000c166:	c0 41       	brne	8000c16e <__avr32_s32_to_f64+0x94>
8000c168:	ed ba 00 01 	bld	r10,0x1
8000c16c:	c0 42       	brcc	8000c174 <__avr32_s32_to_f64+0x9a>
8000c16e:	2f fa       	sub	r10,-1
8000c170:	f7 bb 02 ff 	subhs	r11,-1
8000c174:	5c fc       	rol	r12
8000c176:	5d 0b       	ror	r11
8000c178:	5d 0a       	ror	r10
8000c17a:	d8 02       	popm	pc
8000c17c:	e0 68 03 ff 	mov	r8,1023
8000c180:	ed ba 00 0b 	bld	r10,0xb
8000c184:	f7 b8 00 ff 	subeq	r8,-1
8000c188:	10 0a       	add	r10,r8
8000c18a:	5c 0b       	acr	r11
8000c18c:	f7 b9 03 fe 	sublo	r9,-2
8000c190:	e0 49 07 ff 	cp.w	r9,2047
8000c194:	c0 55       	brlt	8000c19e <__avr32_s32_to_f64+0xc4>
8000c196:	30 0a       	mov	r10,0
8000c198:	fc 1b ff e0 	movh	r11,0xffe0
8000c19c:	c0 c8       	rjmp	8000c1b4 <__floatsidf_return_op1>
8000c19e:	ed bb 00 1f 	bld	r11,0x1f
8000c1a2:	f7 b9 01 01 	subne	r9,1
8000c1a6:	ab 9a       	lsr	r10,0xb
8000c1a8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c1ac:	a1 7b       	lsl	r11,0x1
8000c1ae:	ab 9b       	lsr	r11,0xb
8000c1b0:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c1b4 <__floatsidf_return_op1>:
8000c1b4:	a1 7c       	lsl	r12,0x1
8000c1b6:	5d 0b       	ror	r11
8000c1b8:	d8 02       	popm	pc

8000c1ba <__avr32_f64_cmp_eq>:
8000c1ba:	10 3a       	cp.w	r10,r8
8000c1bc:	f2 0b 13 00 	cpc	r11,r9
8000c1c0:	c0 80       	breq	8000c1d0 <__avr32_f64_cmp_eq+0x16>
8000c1c2:	a1 7b       	lsl	r11,0x1
8000c1c4:	a1 79       	lsl	r9,0x1
8000c1c6:	14 4b       	or	r11,r10
8000c1c8:	12 4b       	or	r11,r9
8000c1ca:	10 4b       	or	r11,r8
8000c1cc:	5e 0f       	reteq	1
8000c1ce:	5e fd       	retal	0
8000c1d0:	a1 7b       	lsl	r11,0x1
8000c1d2:	fc 1c ff e0 	movh	r12,0xffe0
8000c1d6:	58 0a       	cp.w	r10,0
8000c1d8:	f8 0b 13 00 	cpc	r11,r12
8000c1dc:	5e 8f       	retls	1
8000c1de:	5e fd       	retal	0

8000c1e0 <__avr32_f64_cmp_ge>:
8000c1e0:	1a de       	st.w	--sp,lr
8000c1e2:	1a d7       	st.w	--sp,r7
8000c1e4:	a1 7b       	lsl	r11,0x1
8000c1e6:	5f 3c       	srlo	r12
8000c1e8:	a1 79       	lsl	r9,0x1
8000c1ea:	5f 37       	srlo	r7
8000c1ec:	5c fc       	rol	r12
8000c1ee:	fc 1e ff e0 	movh	lr,0xffe0
8000c1f2:	58 0a       	cp.w	r10,0
8000c1f4:	fc 0b 13 00 	cpc	r11,lr
8000c1f8:	e0 8b 00 1d 	brhi	8000c232 <__avr32_f64_cmp_ge+0x52>
8000c1fc:	58 08       	cp.w	r8,0
8000c1fe:	fc 09 13 00 	cpc	r9,lr
8000c202:	e0 8b 00 18 	brhi	8000c232 <__avr32_f64_cmp_ge+0x52>
8000c206:	58 0b       	cp.w	r11,0
8000c208:	f5 ba 00 00 	subfeq	r10,0
8000c20c:	c1 50       	breq	8000c236 <__avr32_f64_cmp_ge+0x56>
8000c20e:	1b 07       	ld.w	r7,sp++
8000c210:	1b 0e       	ld.w	lr,sp++
8000c212:	58 3c       	cp.w	r12,3
8000c214:	c0 a0       	breq	8000c228 <__avr32_f64_cmp_ge+0x48>
8000c216:	58 1c       	cp.w	r12,1
8000c218:	c0 33       	brcs	8000c21e <__avr32_f64_cmp_ge+0x3e>
8000c21a:	5e 0f       	reteq	1
8000c21c:	5e 1d       	retne	0
8000c21e:	10 3a       	cp.w	r10,r8
8000c220:	f2 0b 13 00 	cpc	r11,r9
8000c224:	5e 2f       	reths	1
8000c226:	5e 3d       	retlo	0
8000c228:	14 38       	cp.w	r8,r10
8000c22a:	f6 09 13 00 	cpc	r9,r11
8000c22e:	5e 2f       	reths	1
8000c230:	5e 3d       	retlo	0
8000c232:	1b 07       	ld.w	r7,sp++
8000c234:	d8 0a       	popm	pc,r12=0
8000c236:	58 17       	cp.w	r7,1
8000c238:	5f 0c       	sreq	r12
8000c23a:	58 09       	cp.w	r9,0
8000c23c:	f5 b8 00 00 	subfeq	r8,0
8000c240:	1b 07       	ld.w	r7,sp++
8000c242:	1b 0e       	ld.w	lr,sp++
8000c244:	5e 0f       	reteq	1
8000c246:	5e fc       	retal	r12

8000c248 <__avr32_f64_cmp_lt>:
8000c248:	1a de       	st.w	--sp,lr
8000c24a:	1a d7       	st.w	--sp,r7
8000c24c:	a1 7b       	lsl	r11,0x1
8000c24e:	5f 3c       	srlo	r12
8000c250:	a1 79       	lsl	r9,0x1
8000c252:	5f 37       	srlo	r7
8000c254:	5c fc       	rol	r12
8000c256:	fc 1e ff e0 	movh	lr,0xffe0
8000c25a:	58 0a       	cp.w	r10,0
8000c25c:	fc 0b 13 00 	cpc	r11,lr
8000c260:	e0 8b 00 1d 	brhi	8000c29a <__avr32_f64_cmp_lt+0x52>
8000c264:	58 08       	cp.w	r8,0
8000c266:	fc 09 13 00 	cpc	r9,lr
8000c26a:	e0 8b 00 18 	brhi	8000c29a <__avr32_f64_cmp_lt+0x52>
8000c26e:	58 0b       	cp.w	r11,0
8000c270:	f5 ba 00 00 	subfeq	r10,0
8000c274:	c1 50       	breq	8000c29e <__avr32_f64_cmp_lt+0x56>
8000c276:	1b 07       	ld.w	r7,sp++
8000c278:	1b 0e       	ld.w	lr,sp++
8000c27a:	58 3c       	cp.w	r12,3
8000c27c:	c0 a0       	breq	8000c290 <__avr32_f64_cmp_lt+0x48>
8000c27e:	58 1c       	cp.w	r12,1
8000c280:	c0 33       	brcs	8000c286 <__avr32_f64_cmp_lt+0x3e>
8000c282:	5e 0d       	reteq	0
8000c284:	5e 1f       	retne	1
8000c286:	10 3a       	cp.w	r10,r8
8000c288:	f2 0b 13 00 	cpc	r11,r9
8000c28c:	5e 2d       	reths	0
8000c28e:	5e 3f       	retlo	1
8000c290:	14 38       	cp.w	r8,r10
8000c292:	f6 09 13 00 	cpc	r9,r11
8000c296:	5e 2d       	reths	0
8000c298:	5e 3f       	retlo	1
8000c29a:	1b 07       	ld.w	r7,sp++
8000c29c:	d8 0a       	popm	pc,r12=0
8000c29e:	58 17       	cp.w	r7,1
8000c2a0:	5f 1c       	srne	r12
8000c2a2:	58 09       	cp.w	r9,0
8000c2a4:	f5 b8 00 00 	subfeq	r8,0
8000c2a8:	1b 07       	ld.w	r7,sp++
8000c2aa:	1b 0e       	ld.w	lr,sp++
8000c2ac:	5e 0d       	reteq	0
8000c2ae:	5e fc       	retal	r12

8000c2b0 <__avr32_f64_div>:
8000c2b0:	eb cd 40 ff 	pushm	r0-r7,lr
8000c2b4:	f7 e9 20 0e 	eor	lr,r11,r9
8000c2b8:	f6 07 16 14 	lsr	r7,r11,0x14
8000c2bc:	a9 7b       	lsl	r11,0x9
8000c2be:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c2c2:	a9 7a       	lsl	r10,0x9
8000c2c4:	bd bb       	sbr	r11,0x1d
8000c2c6:	e4 1b 3f ff 	andh	r11,0x3fff
8000c2ca:	ab d7       	cbr	r7,0xb
8000c2cc:	e0 80 00 cc 	breq	8000c464 <__avr32_f64_div_round_subnormal+0x54>
8000c2d0:	e0 47 07 ff 	cp.w	r7,2047
8000c2d4:	e0 84 00 b5 	brge	8000c43e <__avr32_f64_div_round_subnormal+0x2e>
8000c2d8:	f2 06 16 14 	lsr	r6,r9,0x14
8000c2dc:	a9 79       	lsl	r9,0x9
8000c2de:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c2e2:	a9 78       	lsl	r8,0x9
8000c2e4:	bd b9       	sbr	r9,0x1d
8000c2e6:	e4 19 3f ff 	andh	r9,0x3fff
8000c2ea:	ab d6       	cbr	r6,0xb
8000c2ec:	e0 80 00 e2 	breq	8000c4b0 <__avr32_f64_div_round_subnormal+0xa0>
8000c2f0:	e0 46 07 ff 	cp.w	r6,2047
8000c2f4:	e0 84 00 b2 	brge	8000c458 <__avr32_f64_div_round_subnormal+0x48>
8000c2f8:	0c 17       	sub	r7,r6
8000c2fa:	fe 37 fc 01 	sub	r7,-1023
8000c2fe:	fc 1c 80 00 	movh	r12,0x8000
8000c302:	f8 03 16 01 	lsr	r3,r12,0x1
8000c306:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c30a:	5c d4       	com	r4
8000c30c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c310:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c314:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c318:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c31c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c320:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c324:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c328:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c32c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c330:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c334:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c338:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c33c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c340:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c344:	e4 09 07 40 	macu.d	r0,r2,r9
8000c348:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c34c:	02 04       	add	r4,r1
8000c34e:	5c 05       	acr	r5
8000c350:	a3 65       	lsl	r5,0x2
8000c352:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c356:	a3 64       	lsl	r4,0x2
8000c358:	5c 34       	neg	r4
8000c35a:	f8 05 01 45 	sbc	r5,r12,r5
8000c35e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c362:	e4 05 07 40 	macu.d	r0,r2,r5
8000c366:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c36a:	02 04       	add	r4,r1
8000c36c:	5c 05       	acr	r5
8000c36e:	ea 03 15 02 	lsl	r3,r5,0x2
8000c372:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c376:	e8 02 15 02 	lsl	r2,r4,0x2
8000c37a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c37e:	e4 09 07 40 	macu.d	r0,r2,r9
8000c382:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c386:	02 04       	add	r4,r1
8000c388:	5c 05       	acr	r5
8000c38a:	a3 65       	lsl	r5,0x2
8000c38c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c390:	a3 64       	lsl	r4,0x2
8000c392:	5c 34       	neg	r4
8000c394:	f8 05 01 45 	sbc	r5,r12,r5
8000c398:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c39c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c3a0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3a4:	02 04       	add	r4,r1
8000c3a6:	5c 05       	acr	r5
8000c3a8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3ac:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c3b0:	e8 02 15 02 	lsl	r2,r4,0x2
8000c3b4:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c3b8:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c3bc:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c3c0:	02 02       	add	r2,r1
8000c3c2:	5c 03       	acr	r3
8000c3c4:	ed b3 00 1c 	bld	r3,0x1c
8000c3c8:	c0 90       	breq	8000c3da <__avr32_f64_div+0x12a>
8000c3ca:	a1 72       	lsl	r2,0x1
8000c3cc:	5c f3       	rol	r3
8000c3ce:	20 17       	sub	r7,1
8000c3d0:	a3 9a       	lsr	r10,0x3
8000c3d2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c3d6:	a3 9b       	lsr	r11,0x3
8000c3d8:	c0 58       	rjmp	8000c3e2 <__avr32_f64_div+0x132>
8000c3da:	a5 8a       	lsr	r10,0x4
8000c3dc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c3e0:	a5 8b       	lsr	r11,0x4
8000c3e2:	58 07       	cp.w	r7,0
8000c3e4:	e0 8a 00 8b 	brle	8000c4fa <__avr32_f64_div_res_subnormal>
8000c3e8:	e0 12 ff 00 	andl	r2,0xff00
8000c3ec:	e8 12 00 80 	orl	r2,0x80
8000c3f0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c3f4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c3f8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c3fc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c400:	00 05       	add	r5,r0
8000c402:	f0 01 00 48 	adc	r8,r8,r1
8000c406:	5c 09       	acr	r9
8000c408:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c40c:	58 04       	cp.w	r4,0
8000c40e:	5c 25       	cpc	r5

8000c410 <__avr32_f64_div_round_subnormal>:
8000c410:	f4 08 13 00 	cpc	r8,r10
8000c414:	f6 09 13 00 	cpc	r9,r11
8000c418:	5f 36       	srlo	r6
8000c41a:	f8 06 17 00 	moveq	r6,r12
8000c41e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c422:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c426:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c42a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c42e:	ed be 00 1f 	bld	lr,0x1f
8000c432:	ef bb 00 1f 	bst	r11,0x1f
8000c436:	0c 0a       	add	r10,r6
8000c438:	5c 0b       	acr	r11
8000c43a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c43e:	e4 1b 00 0f 	andh	r11,0xf
8000c442:	14 4b       	or	r11,r10
8000c444:	e0 81 00 a7 	brne	8000c592 <__avr32_f64_div_res_subnormal+0x98>
8000c448:	f2 06 16 14 	lsr	r6,r9,0x14
8000c44c:	ab d6       	cbr	r6,0xb
8000c44e:	e0 46 07 ff 	cp.w	r6,2047
8000c452:	e0 81 00 a4 	brne	8000c59a <__avr32_f64_div_res_subnormal+0xa0>
8000c456:	c9 e8       	rjmp	8000c592 <__avr32_f64_div_res_subnormal+0x98>
8000c458:	e4 19 00 0f 	andh	r9,0xf
8000c45c:	10 49       	or	r9,r8
8000c45e:	e0 81 00 9a 	brne	8000c592 <__avr32_f64_div_res_subnormal+0x98>
8000c462:	c9 28       	rjmp	8000c586 <__avr32_f64_div_res_subnormal+0x8c>
8000c464:	a3 7b       	lsl	r11,0x3
8000c466:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c46a:	a3 7a       	lsl	r10,0x3
8000c46c:	f5 eb 10 04 	or	r4,r10,r11
8000c470:	e0 80 00 a0 	breq	8000c5b0 <__avr32_f64_div_op1_zero>
8000c474:	f6 04 12 00 	clz	r4,r11
8000c478:	c1 70       	breq	8000c4a6 <__avr32_f64_div_round_subnormal+0x96>
8000c47a:	c0 c3       	brcs	8000c492 <__avr32_f64_div_round_subnormal+0x82>
8000c47c:	e8 05 11 20 	rsub	r5,r4,32
8000c480:	f6 04 09 4b 	lsl	r11,r11,r4
8000c484:	f4 05 0a 45 	lsr	r5,r10,r5
8000c488:	0a 4b       	or	r11,r5
8000c48a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c48e:	08 17       	sub	r7,r4
8000c490:	c0 b8       	rjmp	8000c4a6 <__avr32_f64_div_round_subnormal+0x96>
8000c492:	f4 04 12 00 	clz	r4,r10
8000c496:	f9 b4 03 00 	movlo	r4,0
8000c49a:	f7 b4 02 e0 	subhs	r4,-32
8000c49e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c4a2:	30 0a       	mov	r10,0
8000c4a4:	08 17       	sub	r7,r4
8000c4a6:	a3 8a       	lsr	r10,0x2
8000c4a8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c4ac:	a3 8b       	lsr	r11,0x2
8000c4ae:	c1 1b       	rjmp	8000c2d0 <__avr32_f64_div+0x20>
8000c4b0:	a3 79       	lsl	r9,0x3
8000c4b2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c4b6:	a3 78       	lsl	r8,0x3
8000c4b8:	f3 e8 10 04 	or	r4,r9,r8
8000c4bc:	c6 f0       	breq	8000c59a <__avr32_f64_div_res_subnormal+0xa0>
8000c4be:	f2 04 12 00 	clz	r4,r9
8000c4c2:	c1 70       	breq	8000c4f0 <__avr32_f64_div_round_subnormal+0xe0>
8000c4c4:	c0 c3       	brcs	8000c4dc <__avr32_f64_div_round_subnormal+0xcc>
8000c4c6:	e8 05 11 20 	rsub	r5,r4,32
8000c4ca:	f2 04 09 49 	lsl	r9,r9,r4
8000c4ce:	f0 05 0a 45 	lsr	r5,r8,r5
8000c4d2:	0a 49       	or	r9,r5
8000c4d4:	f0 04 09 48 	lsl	r8,r8,r4
8000c4d8:	08 16       	sub	r6,r4
8000c4da:	c0 b8       	rjmp	8000c4f0 <__avr32_f64_div_round_subnormal+0xe0>
8000c4dc:	f0 04 12 00 	clz	r4,r8
8000c4e0:	f9 b4 03 00 	movlo	r4,0
8000c4e4:	f7 b4 02 e0 	subhs	r4,-32
8000c4e8:	f0 04 09 49 	lsl	r9,r8,r4
8000c4ec:	30 08       	mov	r8,0
8000c4ee:	08 16       	sub	r6,r4
8000c4f0:	a3 88       	lsr	r8,0x2
8000c4f2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c4f6:	a3 89       	lsr	r9,0x2
8000c4f8:	cf ca       	rjmp	8000c2f0 <__avr32_f64_div+0x40>

8000c4fa <__avr32_f64_div_res_subnormal>:
8000c4fa:	5c 37       	neg	r7
8000c4fc:	2f f7       	sub	r7,-1
8000c4fe:	f1 b7 04 c0 	satu	r7,0x6
8000c502:	e0 47 00 20 	cp.w	r7,32
8000c506:	c1 54       	brge	8000c530 <__avr32_f64_div_res_subnormal+0x36>
8000c508:	ee 06 11 20 	rsub	r6,r7,32
8000c50c:	e4 07 0a 42 	lsr	r2,r2,r7
8000c510:	e6 06 09 4c 	lsl	r12,r3,r6
8000c514:	18 42       	or	r2,r12
8000c516:	e6 07 0a 43 	lsr	r3,r3,r7
8000c51a:	f4 06 09 41 	lsl	r1,r10,r6
8000c51e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c522:	f6 06 09 4c 	lsl	r12,r11,r6
8000c526:	18 4a       	or	r10,r12
8000c528:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c52c:	30 00       	mov	r0,0
8000c52e:	c1 58       	rjmp	8000c558 <__avr32_f64_div_res_subnormal+0x5e>
8000c530:	ee 06 11 20 	rsub	r6,r7,32
8000c534:	f9 b0 00 00 	moveq	r0,0
8000c538:	f9 bc 00 00 	moveq	r12,0
8000c53c:	c0 50       	breq	8000c546 <__avr32_f64_div_res_subnormal+0x4c>
8000c53e:	f4 06 09 40 	lsl	r0,r10,r6
8000c542:	f6 06 09 4c 	lsl	r12,r11,r6
8000c546:	e6 07 0a 42 	lsr	r2,r3,r7
8000c54a:	30 03       	mov	r3,0
8000c54c:	f4 07 0a 41 	lsr	r1,r10,r7
8000c550:	18 41       	or	r1,r12
8000c552:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c556:	30 0b       	mov	r11,0
8000c558:	e0 12 ff 00 	andl	r2,0xff00
8000c55c:	e8 12 00 80 	orl	r2,0x80
8000c560:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c564:	e4 09 07 46 	macu.d	r6,r2,r9
8000c568:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c56c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c570:	0c 05       	add	r5,r6
8000c572:	f0 07 00 48 	adc	r8,r8,r7
8000c576:	5c 09       	acr	r9
8000c578:	30 07       	mov	r7,0
8000c57a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c57e:	00 34       	cp.w	r4,r0
8000c580:	e2 05 13 00 	cpc	r5,r1
8000c584:	c4 6b       	rjmp	8000c410 <__avr32_f64_div_round_subnormal>
8000c586:	1c 9b       	mov	r11,lr
8000c588:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c58c:	30 0a       	mov	r10,0
8000c58e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c592:	3f fb       	mov	r11,-1
8000c594:	30 0a       	mov	r10,0
8000c596:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c59a:	f5 eb 10 04 	or	r4,r10,r11
8000c59e:	c0 90       	breq	8000c5b0 <__avr32_f64_div_op1_zero>
8000c5a0:	1c 9b       	mov	r11,lr
8000c5a2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c5a6:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c5aa:	30 0a       	mov	r10,0
8000c5ac:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c5b0 <__avr32_f64_div_op1_zero>:
8000c5b0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c5b4:	ce f0       	breq	8000c592 <__avr32_f64_div_res_subnormal+0x98>
8000c5b6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c5ba:	e0 44 07 ff 	cp.w	r4,2047
8000c5be:	ce 41       	brne	8000c586 <__avr32_f64_div_res_subnormal+0x8c>
8000c5c0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c5c4:	ce 10       	breq	8000c586 <__avr32_f64_div_res_subnormal+0x8c>
8000c5c6:	ce 6b       	rjmp	8000c592 <__avr32_f64_div_res_subnormal+0x98>

8000c5c8 <__avr32_udiv64>:
8000c5c8:	d4 31       	pushm	r0-r7,lr
8000c5ca:	1a 97       	mov	r7,sp
8000c5cc:	20 3d       	sub	sp,12
8000c5ce:	10 9c       	mov	r12,r8
8000c5d0:	12 9e       	mov	lr,r9
8000c5d2:	14 93       	mov	r3,r10
8000c5d4:	58 09       	cp.w	r9,0
8000c5d6:	e0 81 00 bd 	brne	8000c750 <__avr32_udiv64+0x188>
8000c5da:	16 38       	cp.w	r8,r11
8000c5dc:	e0 88 00 40 	brls	8000c65c <__avr32_udiv64+0x94>
8000c5e0:	f0 08 12 00 	clz	r8,r8
8000c5e4:	c0 d0       	breq	8000c5fe <__avr32_udiv64+0x36>
8000c5e6:	f6 08 09 4b 	lsl	r11,r11,r8
8000c5ea:	f0 09 11 20 	rsub	r9,r8,32
8000c5ee:	f8 08 09 4c 	lsl	r12,r12,r8
8000c5f2:	f4 09 0a 49 	lsr	r9,r10,r9
8000c5f6:	f4 08 09 43 	lsl	r3,r10,r8
8000c5fa:	f3 eb 10 0b 	or	r11,r9,r11
8000c5fe:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c602:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c606:	f6 0e 0d 00 	divu	r0,r11,lr
8000c60a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c60e:	00 99       	mov	r9,r0
8000c610:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c614:	e0 0a 02 48 	mul	r8,r0,r10
8000c618:	10 3b       	cp.w	r11,r8
8000c61a:	c0 a2       	brcc	8000c62e <__avr32_udiv64+0x66>
8000c61c:	20 19       	sub	r9,1
8000c61e:	18 0b       	add	r11,r12
8000c620:	18 3b       	cp.w	r11,r12
8000c622:	c0 63       	brcs	8000c62e <__avr32_udiv64+0x66>
8000c624:	10 3b       	cp.w	r11,r8
8000c626:	f7 b9 03 01 	sublo	r9,1
8000c62a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c62e:	f6 08 01 01 	sub	r1,r11,r8
8000c632:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c636:	e2 0e 0d 00 	divu	r0,r1,lr
8000c63a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c63e:	00 98       	mov	r8,r0
8000c640:	e0 0a 02 4a 	mul	r10,r0,r10
8000c644:	14 33       	cp.w	r3,r10
8000c646:	c0 82       	brcc	8000c656 <__avr32_udiv64+0x8e>
8000c648:	20 18       	sub	r8,1
8000c64a:	18 03       	add	r3,r12
8000c64c:	18 33       	cp.w	r3,r12
8000c64e:	c0 43       	brcs	8000c656 <__avr32_udiv64+0x8e>
8000c650:	14 33       	cp.w	r3,r10
8000c652:	f7 b8 03 01 	sublo	r8,1
8000c656:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c65a:	cd f8       	rjmp	8000c818 <__avr32_udiv64+0x250>
8000c65c:	58 08       	cp.w	r8,0
8000c65e:	c0 51       	brne	8000c668 <__avr32_udiv64+0xa0>
8000c660:	30 19       	mov	r9,1
8000c662:	f2 08 0d 08 	divu	r8,r9,r8
8000c666:	10 9c       	mov	r12,r8
8000c668:	f8 06 12 00 	clz	r6,r12
8000c66c:	c0 41       	brne	8000c674 <__avr32_udiv64+0xac>
8000c66e:	18 1b       	sub	r11,r12
8000c670:	30 19       	mov	r9,1
8000c672:	c4 08       	rjmp	8000c6f2 <__avr32_udiv64+0x12a>
8000c674:	ec 01 11 20 	rsub	r1,r6,32
8000c678:	f4 01 0a 49 	lsr	r9,r10,r1
8000c67c:	f8 06 09 4c 	lsl	r12,r12,r6
8000c680:	f6 06 09 48 	lsl	r8,r11,r6
8000c684:	f6 01 0a 41 	lsr	r1,r11,r1
8000c688:	f3 e8 10 08 	or	r8,r9,r8
8000c68c:	f8 03 16 10 	lsr	r3,r12,0x10
8000c690:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c694:	e2 03 0d 00 	divu	r0,r1,r3
8000c698:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c69c:	00 9e       	mov	lr,r0
8000c69e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c6a2:	e0 05 02 49 	mul	r9,r0,r5
8000c6a6:	12 3b       	cp.w	r11,r9
8000c6a8:	c0 a2       	brcc	8000c6bc <__avr32_udiv64+0xf4>
8000c6aa:	20 1e       	sub	lr,1
8000c6ac:	18 0b       	add	r11,r12
8000c6ae:	18 3b       	cp.w	r11,r12
8000c6b0:	c0 63       	brcs	8000c6bc <__avr32_udiv64+0xf4>
8000c6b2:	12 3b       	cp.w	r11,r9
8000c6b4:	f7 be 03 01 	sublo	lr,1
8000c6b8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c6bc:	12 1b       	sub	r11,r9
8000c6be:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c6c2:	f6 03 0d 02 	divu	r2,r11,r3
8000c6c6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c6ca:	04 99       	mov	r9,r2
8000c6cc:	e4 05 02 4b 	mul	r11,r2,r5
8000c6d0:	16 38       	cp.w	r8,r11
8000c6d2:	c0 a2       	brcc	8000c6e6 <__avr32_udiv64+0x11e>
8000c6d4:	20 19       	sub	r9,1
8000c6d6:	18 08       	add	r8,r12
8000c6d8:	18 38       	cp.w	r8,r12
8000c6da:	c0 63       	brcs	8000c6e6 <__avr32_udiv64+0x11e>
8000c6dc:	16 38       	cp.w	r8,r11
8000c6de:	f7 b9 03 01 	sublo	r9,1
8000c6e2:	f1 dc e3 08 	addcs	r8,r8,r12
8000c6e6:	f4 06 09 43 	lsl	r3,r10,r6
8000c6ea:	f0 0b 01 0b 	sub	r11,r8,r11
8000c6ee:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c6f2:	f8 06 16 10 	lsr	r6,r12,0x10
8000c6f6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c6fa:	f6 06 0d 00 	divu	r0,r11,r6
8000c6fe:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c702:	00 9a       	mov	r10,r0
8000c704:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c708:	e0 0e 02 48 	mul	r8,r0,lr
8000c70c:	10 3b       	cp.w	r11,r8
8000c70e:	c0 a2       	brcc	8000c722 <__avr32_udiv64+0x15a>
8000c710:	20 1a       	sub	r10,1
8000c712:	18 0b       	add	r11,r12
8000c714:	18 3b       	cp.w	r11,r12
8000c716:	c0 63       	brcs	8000c722 <__avr32_udiv64+0x15a>
8000c718:	10 3b       	cp.w	r11,r8
8000c71a:	f7 ba 03 01 	sublo	r10,1
8000c71e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c722:	f6 08 01 01 	sub	r1,r11,r8
8000c726:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c72a:	e2 06 0d 00 	divu	r0,r1,r6
8000c72e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c732:	00 98       	mov	r8,r0
8000c734:	e0 0e 02 4b 	mul	r11,r0,lr
8000c738:	16 33       	cp.w	r3,r11
8000c73a:	c0 82       	brcc	8000c74a <__avr32_udiv64+0x182>
8000c73c:	20 18       	sub	r8,1
8000c73e:	18 03       	add	r3,r12
8000c740:	18 33       	cp.w	r3,r12
8000c742:	c0 43       	brcs	8000c74a <__avr32_udiv64+0x182>
8000c744:	16 33       	cp.w	r3,r11
8000c746:	f7 b8 03 01 	sublo	r8,1
8000c74a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c74e:	c6 98       	rjmp	8000c820 <__avr32_udiv64+0x258>
8000c750:	16 39       	cp.w	r9,r11
8000c752:	e0 8b 00 65 	brhi	8000c81c <__avr32_udiv64+0x254>
8000c756:	f2 09 12 00 	clz	r9,r9
8000c75a:	c0 b1       	brne	8000c770 <__avr32_udiv64+0x1a8>
8000c75c:	10 3a       	cp.w	r10,r8
8000c75e:	5f 2a       	srhs	r10
8000c760:	1c 3b       	cp.w	r11,lr
8000c762:	5f b8       	srhi	r8
8000c764:	10 4a       	or	r10,r8
8000c766:	f2 0a 18 00 	cp.b	r10,r9
8000c76a:	c5 90       	breq	8000c81c <__avr32_udiv64+0x254>
8000c76c:	30 18       	mov	r8,1
8000c76e:	c5 98       	rjmp	8000c820 <__avr32_udiv64+0x258>
8000c770:	f0 09 09 46 	lsl	r6,r8,r9
8000c774:	f2 03 11 20 	rsub	r3,r9,32
8000c778:	fc 09 09 4e 	lsl	lr,lr,r9
8000c77c:	f0 03 0a 48 	lsr	r8,r8,r3
8000c780:	f6 09 09 4c 	lsl	r12,r11,r9
8000c784:	f4 03 0a 42 	lsr	r2,r10,r3
8000c788:	ef 46 ff f4 	st.w	r7[-12],r6
8000c78c:	f6 03 0a 43 	lsr	r3,r11,r3
8000c790:	18 42       	or	r2,r12
8000c792:	f1 ee 10 0c 	or	r12,r8,lr
8000c796:	f8 01 16 10 	lsr	r1,r12,0x10
8000c79a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c79e:	e6 01 0d 04 	divu	r4,r3,r1
8000c7a2:	e4 03 16 10 	lsr	r3,r2,0x10
8000c7a6:	08 9e       	mov	lr,r4
8000c7a8:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c7ac:	e8 06 02 48 	mul	r8,r4,r6
8000c7b0:	10 33       	cp.w	r3,r8
8000c7b2:	c0 a2       	brcc	8000c7c6 <__avr32_udiv64+0x1fe>
8000c7b4:	20 1e       	sub	lr,1
8000c7b6:	18 03       	add	r3,r12
8000c7b8:	18 33       	cp.w	r3,r12
8000c7ba:	c0 63       	brcs	8000c7c6 <__avr32_udiv64+0x1fe>
8000c7bc:	10 33       	cp.w	r3,r8
8000c7be:	f7 be 03 01 	sublo	lr,1
8000c7c2:	e7 dc e3 03 	addcs	r3,r3,r12
8000c7c6:	10 13       	sub	r3,r8
8000c7c8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c7cc:	e6 01 0d 00 	divu	r0,r3,r1
8000c7d0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c7d4:	00 98       	mov	r8,r0
8000c7d6:	e0 06 02 46 	mul	r6,r0,r6
8000c7da:	0c 3b       	cp.w	r11,r6
8000c7dc:	c0 a2       	brcc	8000c7f0 <__avr32_udiv64+0x228>
8000c7de:	20 18       	sub	r8,1
8000c7e0:	18 0b       	add	r11,r12
8000c7e2:	18 3b       	cp.w	r11,r12
8000c7e4:	c0 63       	brcs	8000c7f0 <__avr32_udiv64+0x228>
8000c7e6:	0c 3b       	cp.w	r11,r6
8000c7e8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7ec:	f7 b8 03 01 	sublo	r8,1
8000c7f0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c7f4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c7f8:	0c 1b       	sub	r11,r6
8000c7fa:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c7fe:	06 95       	mov	r5,r3
8000c800:	16 35       	cp.w	r5,r11
8000c802:	e0 8b 00 0a 	brhi	8000c816 <__avr32_udiv64+0x24e>
8000c806:	5f 0b       	sreq	r11
8000c808:	f4 09 09 49 	lsl	r9,r10,r9
8000c80c:	12 32       	cp.w	r2,r9
8000c80e:	5f b9       	srhi	r9
8000c810:	f7 e9 00 09 	and	r9,r11,r9
8000c814:	c0 60       	breq	8000c820 <__avr32_udiv64+0x258>
8000c816:	20 18       	sub	r8,1
8000c818:	30 09       	mov	r9,0
8000c81a:	c0 38       	rjmp	8000c820 <__avr32_udiv64+0x258>
8000c81c:	30 09       	mov	r9,0
8000c81e:	12 98       	mov	r8,r9
8000c820:	10 9a       	mov	r10,r8
8000c822:	12 93       	mov	r3,r9
8000c824:	10 92       	mov	r2,r8
8000c826:	12 9b       	mov	r11,r9
8000c828:	2f dd       	sub	sp,-12
8000c82a:	d8 32       	popm	r0-r7,pc

8000c82c <__avr32_umod64>:
8000c82c:	d4 31       	pushm	r0-r7,lr
8000c82e:	1a 97       	mov	r7,sp
8000c830:	20 3d       	sub	sp,12
8000c832:	10 9c       	mov	r12,r8
8000c834:	12 95       	mov	r5,r9
8000c836:	14 9e       	mov	lr,r10
8000c838:	16 91       	mov	r1,r11
8000c83a:	16 96       	mov	r6,r11
8000c83c:	58 09       	cp.w	r9,0
8000c83e:	e0 81 00 81 	brne	8000c940 <__avr32_umod64+0x114>
8000c842:	16 38       	cp.w	r8,r11
8000c844:	e0 88 00 12 	brls	8000c868 <__avr32_umod64+0x3c>
8000c848:	f0 08 12 00 	clz	r8,r8
8000c84c:	c4 e0       	breq	8000c8e8 <__avr32_umod64+0xbc>
8000c84e:	f6 08 09 46 	lsl	r6,r11,r8
8000c852:	f8 08 09 4c 	lsl	r12,r12,r8
8000c856:	f0 0b 11 20 	rsub	r11,r8,32
8000c85a:	f4 08 09 4e 	lsl	lr,r10,r8
8000c85e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c862:	f7 e6 10 06 	or	r6,r11,r6
8000c866:	c4 18       	rjmp	8000c8e8 <__avr32_umod64+0xbc>
8000c868:	58 08       	cp.w	r8,0
8000c86a:	c0 51       	brne	8000c874 <__avr32_umod64+0x48>
8000c86c:	30 19       	mov	r9,1
8000c86e:	f2 08 0d 08 	divu	r8,r9,r8
8000c872:	10 9c       	mov	r12,r8
8000c874:	f8 08 12 00 	clz	r8,r12
8000c878:	c0 31       	brne	8000c87e <__avr32_umod64+0x52>
8000c87a:	18 16       	sub	r6,r12
8000c87c:	c3 68       	rjmp	8000c8e8 <__avr32_umod64+0xbc>
8000c87e:	f0 03 11 20 	rsub	r3,r8,32
8000c882:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c886:	f8 08 09 4c 	lsl	r12,r12,r8
8000c88a:	ec 08 09 49 	lsl	r9,r6,r8
8000c88e:	ec 03 0a 43 	lsr	r3,r6,r3
8000c892:	f7 e9 10 09 	or	r9,r11,r9
8000c896:	f8 05 16 10 	lsr	r5,r12,0x10
8000c89a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c89e:	e6 05 0d 02 	divu	r2,r3,r5
8000c8a2:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c8a6:	ec 02 02 4b 	mul	r11,r6,r2
8000c8aa:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c8ae:	16 3e       	cp.w	lr,r11
8000c8b0:	c0 72       	brcc	8000c8be <__avr32_umod64+0x92>
8000c8b2:	18 0e       	add	lr,r12
8000c8b4:	18 3e       	cp.w	lr,r12
8000c8b6:	c0 43       	brcs	8000c8be <__avr32_umod64+0x92>
8000c8b8:	16 3e       	cp.w	lr,r11
8000c8ba:	fd dc e3 0e 	addcs	lr,lr,r12
8000c8be:	fc 0b 01 03 	sub	r3,lr,r11
8000c8c2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c8c6:	e6 05 0d 02 	divu	r2,r3,r5
8000c8ca:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c8ce:	a5 36       	mul	r6,r2
8000c8d0:	0c 39       	cp.w	r9,r6
8000c8d2:	c0 72       	brcc	8000c8e0 <__avr32_umod64+0xb4>
8000c8d4:	18 09       	add	r9,r12
8000c8d6:	18 39       	cp.w	r9,r12
8000c8d8:	c0 43       	brcs	8000c8e0 <__avr32_umod64+0xb4>
8000c8da:	0c 39       	cp.w	r9,r6
8000c8dc:	f3 dc e3 09 	addcs	r9,r9,r12
8000c8e0:	f2 06 01 06 	sub	r6,r9,r6
8000c8e4:	f4 08 09 4e 	lsl	lr,r10,r8
8000c8e8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c8ec:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c8f0:	ec 0a 0d 02 	divu	r2,r6,r10
8000c8f4:	fc 09 16 10 	lsr	r9,lr,0x10
8000c8f8:	ea 02 02 4b 	mul	r11,r5,r2
8000c8fc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c900:	16 39       	cp.w	r9,r11
8000c902:	c0 72       	brcc	8000c910 <__avr32_umod64+0xe4>
8000c904:	18 09       	add	r9,r12
8000c906:	18 39       	cp.w	r9,r12
8000c908:	c0 43       	brcs	8000c910 <__avr32_umod64+0xe4>
8000c90a:	16 39       	cp.w	r9,r11
8000c90c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c910:	f2 0b 01 0b 	sub	r11,r9,r11
8000c914:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c918:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c91c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c920:	ea 0a 02 4a 	mul	r10,r5,r10
8000c924:	14 3e       	cp.w	lr,r10
8000c926:	c0 72       	brcc	8000c934 <__avr32_umod64+0x108>
8000c928:	18 0e       	add	lr,r12
8000c92a:	18 3e       	cp.w	lr,r12
8000c92c:	c0 43       	brcs	8000c934 <__avr32_umod64+0x108>
8000c92e:	14 3e       	cp.w	lr,r10
8000c930:	fd dc e3 0e 	addcs	lr,lr,r12
8000c934:	fc 0a 01 0a 	sub	r10,lr,r10
8000c938:	30 0b       	mov	r11,0
8000c93a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c93e:	c7 b8       	rjmp	8000ca34 <__avr32_umod64+0x208>
8000c940:	16 39       	cp.w	r9,r11
8000c942:	e0 8b 00 79 	brhi	8000ca34 <__avr32_umod64+0x208>
8000c946:	f2 09 12 00 	clz	r9,r9
8000c94a:	c1 21       	brne	8000c96e <__avr32_umod64+0x142>
8000c94c:	10 3a       	cp.w	r10,r8
8000c94e:	5f 2b       	srhs	r11
8000c950:	0a 31       	cp.w	r1,r5
8000c952:	5f ba       	srhi	r10
8000c954:	f7 ea 10 0a 	or	r10,r11,r10
8000c958:	f2 0a 18 00 	cp.b	r10,r9
8000c95c:	c0 60       	breq	8000c968 <__avr32_umod64+0x13c>
8000c95e:	fc 08 01 0c 	sub	r12,lr,r8
8000c962:	e2 05 01 46 	sbc	r6,r1,r5
8000c966:	18 9e       	mov	lr,r12
8000c968:	0c 9b       	mov	r11,r6
8000c96a:	1c 9a       	mov	r10,lr
8000c96c:	c6 48       	rjmp	8000ca34 <__avr32_umod64+0x208>
8000c96e:	ea 09 09 4c 	lsl	r12,r5,r9
8000c972:	f2 06 11 20 	rsub	r6,r9,32
8000c976:	f6 09 09 4b 	lsl	r11,r11,r9
8000c97a:	f0 09 09 42 	lsl	r2,r8,r9
8000c97e:	ef 46 ff f4 	st.w	r7[-12],r6
8000c982:	f0 06 0a 48 	lsr	r8,r8,r6
8000c986:	18 48       	or	r8,r12
8000c988:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c98c:	f4 09 09 43 	lsl	r3,r10,r9
8000c990:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c994:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c998:	16 4a       	or	r10,r11
8000c99a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c99e:	f8 0b 0d 04 	divu	r4,r12,r11
8000c9a2:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c9a6:	08 91       	mov	r1,r4
8000c9a8:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c9ac:	e8 0e 02 46 	mul	r6,r4,lr
8000c9b0:	0c 3c       	cp.w	r12,r6
8000c9b2:	c0 a2       	brcc	8000c9c6 <__avr32_umod64+0x19a>
8000c9b4:	20 11       	sub	r1,1
8000c9b6:	10 0c       	add	r12,r8
8000c9b8:	10 3c       	cp.w	r12,r8
8000c9ba:	c0 63       	brcs	8000c9c6 <__avr32_umod64+0x19a>
8000c9bc:	0c 3c       	cp.w	r12,r6
8000c9be:	f7 b1 03 01 	sublo	r1,1
8000c9c2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c9c6:	0c 1c       	sub	r12,r6
8000c9c8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c9cc:	f8 0b 0d 04 	divu	r4,r12,r11
8000c9d0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c9d4:	08 96       	mov	r6,r4
8000c9d6:	e8 0e 02 4e 	mul	lr,r4,lr
8000c9da:	1c 3b       	cp.w	r11,lr
8000c9dc:	c0 a2       	brcc	8000c9f0 <__avr32_umod64+0x1c4>
8000c9de:	20 16       	sub	r6,1
8000c9e0:	10 0b       	add	r11,r8
8000c9e2:	10 3b       	cp.w	r11,r8
8000c9e4:	c0 63       	brcs	8000c9f0 <__avr32_umod64+0x1c4>
8000c9e6:	1c 3b       	cp.w	r11,lr
8000c9e8:	f7 b6 03 01 	sublo	r6,1
8000c9ec:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c9f0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c9f4:	1c 1b       	sub	r11,lr
8000c9f6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c9fa:	00 9e       	mov	lr,r0
8000c9fc:	02 9c       	mov	r12,r1
8000c9fe:	16 3c       	cp.w	r12,r11
8000ca00:	e0 8b 00 08 	brhi	8000ca10 <__avr32_umod64+0x1e4>
8000ca04:	5f 06       	sreq	r6
8000ca06:	06 30       	cp.w	r0,r3
8000ca08:	5f ba       	srhi	r10
8000ca0a:	ed ea 00 0a 	and	r10,r6,r10
8000ca0e:	c0 60       	breq	8000ca1a <__avr32_umod64+0x1ee>
8000ca10:	fc 02 01 04 	sub	r4,lr,r2
8000ca14:	f8 08 01 4c 	sbc	r12,r12,r8
8000ca18:	08 9e       	mov	lr,r4
8000ca1a:	e6 0e 01 0a 	sub	r10,r3,lr
8000ca1e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ca22:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ca26:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ca2a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ca2e:	f8 01 09 4c 	lsl	r12,r12,r1
8000ca32:	18 4a       	or	r10,r12
8000ca34:	2f dd       	sub	sp,-12
8000ca36:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 71 08 	sub	pc,pc,28936

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c3 97 	rcall	80005434 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c3 90 	rcall	80005434 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 89 	rcall	80005434 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 82 	rcall	80005434 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
