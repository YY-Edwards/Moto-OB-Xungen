
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009e18  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c000  8000c000  0000c400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001374  8000c200  8000c200  0000c600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000d574  8000d574  0000d974  2**0
                  ALLOC
  6 .data         00000a1c  00000004  8000d578  0000dc04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00001598  00000a20  8000df94  0000e620  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000e620  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001728  00000000  00000000  0000e650  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 000035f2  00000000  00000000  0000fd78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c867  00000000  00000000  0001336a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00007503  00000000  00000000  0003fbd1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d912  00000000  00000000  000470d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003fe4  00000000  00000000  000549e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007ed5  00000000  00000000  000589cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000fe19  00000000  00000000  000608a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 000017e8  00000000  00000000  000706c0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf d0 64 	sub	pc,pc,-12188

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0c f8       	st.b	--r6,r8

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 38       	cp.w	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 03 20 	mov	r10,800
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	33 58       	mov	r8,53
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	32 fc       	mov	r12,47
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	c2 00       	breq	800020c2 <app_payload_rx_proc+0x1e>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 94       	sub	r4,121
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	5e ac       	retle	r12
8000208c:	00 00       	add	r0,r0
8000208e:	0a 2c       	rsub	r12,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	c2 08       	rjmp	800020de <FD_brdcst_func+0x6>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	62 70       	ld.w	r0,r1[0x1c]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 31       	cp.w	r1,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	c2 0c       	rcall	8000210e <FD_request_func+0xe>
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	62 70       	ld.w	r0,r1[0x1c]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 28       	rsub	r8,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	c2 18       	rjmp	80002128 <EnOB_reply_func>
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	62 70       	ld.w	r0,r1[0x1c]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	c2 38       	rjmp	80002140 <EnOB_reply_func+0x18>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	62 70       	ld.w	r0,r1[0x1c]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	c2 54       	brge	80002158 <EnOB_reply_func+0x30>
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	62 70       	ld.w	r0,r1[0x1c]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	c2 70       	breq	80002170 <EnOB_reply_func+0x48>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	62 70       	ld.w	r0,r1[0x1c]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	c2 88       	rjmp	800021d2 <SingleDetection_brdcst_func+0x3a>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	62 70       	ld.w	r0,r1[0x1c]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	c2 a0       	breq	800021de <SingleDetection_brdcst_func+0x46>
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	c2 b4       	brge	800021e4 <ButtonConfig_brdcst_func>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	c2 cc       	rcall	800021ea <ButtonConfig_brdcst_func+0x6>
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	c2 e8       	rjmp	800021f2 <ButtonConfig_brdcst_func+0xe>

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c3 00       	breq	80002232 <ButtonConfig_brdcst_func+0x4e>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	62 70       	ld.w	r0,r1[0x1c]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	c3 14       	brge	80002240 <ButtonConfig_brdcst_func+0x5c>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	c3 24       	brge	80002246 <ButtonConfig_brdcst_func+0x62>

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	c3 38       	rjmp	80002300 <ButtonConfig_reply_func+0x40>
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	62 70       	ld.w	r0,r1[0x1c]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	c3 58       	rjmp	8000230c <BatteryLevel_brdcst_func+0x8>
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	c3 6c       	rcall	80002312 <BatteryLevel_brdcst_func+0xe>
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	c3 84       	brge	8000231a <BatteryLevel_brdcst_func+0x16>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	c3 a4       	brge	80002322 <BatteryLevel_brdcst_func+0x1e>
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	c3 cc       	rcall	8000232a <BatteryLevel_brdcst_func+0x26>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	c3 f4       	brge	80002334 <BatteryLevel_brdcst_func+0x30>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	c4 18       	rjmp	8000233c <BatteryLevel_brdcst_func+0x38>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	c4 40       	breq	80002346 <BatteryLevel_brdcst_func+0x42>

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	c4 64       	brge	80002382 <DataSession_reply_func+0x26>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	62 70       	ld.w	r0,r1[0x1c]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	c3 58       	rjmp	80002368 <DataSession_reply_func+0xc>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	c4 7c       	rcall	80002390 <DataSession_reply_func+0x34>

80002304 <BatteryLevel_brdcst_func>:
	}
	
}

void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 51       	brne	8000231e <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
80002316:	48 cc       	lddpc	r12,80002344 <BatteryLevel_brdcst_func+0x40>
80002318:	f0 1f 00 0c 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
8000231c:	c0 48       	rjmp	80002324 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
8000231e:	48 cc       	lddpc	r12,8000234c <BatteryLevel_brdcst_func+0x48>
80002320:	f0 1f 00 0a 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
		
	log("\n Battery charge: %X \n" , ptr->Charge);
80002324:	0f 98       	ld.ub	r8,r7[0x1]
80002326:	1a d8       	st.w	--sp,r8
80002328:	48 ac       	lddpc	r12,80002350 <BatteryLevel_brdcst_func+0x4c>
8000232a:	f0 1f 00 08 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	log("\n Battery voltage: %X \n" , ptr->Voltage);
8000232e:	8e 98       	ld.uh	r8,r7[0x2]
80002330:	1a d8       	st.w	--sp,r8
80002332:	48 9c       	lddpc	r12,80002354 <BatteryLevel_brdcst_func+0x50>
80002334:	f0 1f 00 05 	mcall	80002348 <BatteryLevel_brdcst_func+0x44>
	
	Battery_Flag = ptr->State;
80002338:	0f 89       	ld.ub	r9,r7[0x0]
8000233a:	48 88       	lddpc	r8,80002358 <BatteryLevel_brdcst_func+0x54>
8000233c:	b0 89       	st.b	r8[0x0],r9
8000233e:	2f ed       	sub	sp,-8

}
80002340:	e3 cd 80 80 	ldm	sp++,r7,pc
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	c4 98       	rjmp	800023d8 <CallControl_brdcst_func>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	62 70       	ld.w	r0,r1[0x1c]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	c4 a8       	rjmp	800023e2 <CallControl_brdcst_func+0xa>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c4 bc       	rcall	800023e8 <CallControl_brdcst_func+0x10>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	c4 d4       	brge	800023f0 <CallControl_brdcst_func+0x18>
80002358:	00 00       	add	r0,r0
8000235a:	0a 21       	rsub	r1,r5

8000235c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000235c:	eb cd 40 80 	pushm	r7,lr
80002360:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002362:	19 a9       	ld.ub	r9,r12[0x2]
80002364:	30 08       	mov	r8,0
80002366:	f0 09 18 00 	cp.b	r9,r8
8000236a:	c1 11       	brne	8000238c <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
8000236c:	49 3c       	lddpc	r12,800023b8 <DataSession_reply_func+0x5c>
8000236e:	f0 1f 00 14 	mcall	800023bc <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
80002372:	0f b8       	ld.ub	r8,r7[0x3]
80002374:	1a d8       	st.w	--sp,r8
80002376:	49 3c       	lddpc	r12,800023c0 <DataSession_reply_func+0x64>
80002378:	f0 1f 00 11 	mcall	800023bc <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
8000237c:	0f c8       	ld.ub	r8,r7[0x4]
8000237e:	1a d8       	st.w	--sp,r8
80002380:	49 1c       	lddpc	r12,800023c4 <DataSession_reply_func+0x68>
80002382:	f0 1f 00 0f 	mcall	800023bc <DataSession_reply_func+0x60>
80002386:	2f ed       	sub	sp,-8
80002388:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
8000238c:	48 fc       	lddpc	r12,800023c8 <DataSession_reply_func+0x6c>
8000238e:	f0 1f 00 0c 	mcall	800023bc <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
80002392:	0f a8       	ld.ub	r8,r7[0x2]
80002394:	1a d8       	st.w	--sp,r8
80002396:	48 ec       	lddpc	r12,800023cc <DataSession_reply_func+0x70>
80002398:	f0 1f 00 09 	mcall	800023bc <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
8000239c:	0f b8       	ld.ub	r8,r7[0x3]
8000239e:	1a d8       	st.w	--sp,r8
800023a0:	48 cc       	lddpc	r12,800023d0 <DataSession_reply_func+0x74>
800023a2:	f0 1f 00 07 	mcall	800023bc <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023a6:	0f c8       	ld.ub	r8,r7[0x4]
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	48 bc       	lddpc	r12,800023d4 <DataSession_reply_func+0x78>
800023ac:	f0 1f 00 04 	mcall	800023bc <DataSession_reply_func+0x60>
800023b0:	2f dd       	sub	sp,-12
800023b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b6:	00 00       	add	r0,r0
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	c4 ec       	rcall	80002456 <TransmitControl_brdcst_func+0x3a>
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	62 70       	ld.w	r0,r1[0x1c]
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	c4 fc       	rcall	80002460 <TransmitControl_brdcst_func+0x44>
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	c5 08       	rjmp	80002466 <TransmitControl_reply_func+0x2>
800023c8:	80 00       	ld.sh	r0,r0[0x0]
800023ca:	c5 14       	brge	8000246c <TransmitControl_reply_func+0x8>
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	c5 24       	brge	80002472 <TransmitControl_reply_func+0xe>
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	c5 34       	brge	80002478 <TransmitControl_reply_func+0x14>
800023d4:	80 00       	ld.sh	r0,r0[0x0]
800023d6:	c5 40       	breq	8000247e <TransmitControl_reply_func+0x1a>

800023d8 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023dc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800023e0:	0f 98       	ld.ub	r8,r7[0x1]
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	48 bc       	lddpc	r12,80002410 <CallControl_brdcst_func+0x38>
800023e6:	f0 1f 00 0c 	mcall	80002414 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800023ea:	2f fd       	sub	sp,-4
800023ec:	0f 99       	ld.ub	r9,r7[0x1]
800023ee:	30 38       	mov	r8,3
800023f0:	f0 09 18 00 	cp.b	r9,r8
800023f4:	c0 41       	brne	800023fc <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023f6:	30 09       	mov	r9,0
800023f8:	48 88       	lddpc	r8,80002418 <CallControl_brdcst_func+0x40>
800023fa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023fc:	0f 99       	ld.ub	r9,r7[0x1]
800023fe:	30 48       	mov	r8,4
80002400:	f0 09 18 00 	cp.b	r9,r8
80002404:	c0 41       	brne	8000240c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002406:	30 19       	mov	r9,1
80002408:	48 48       	lddpc	r8,80002418 <CallControl_brdcst_func+0x40>
8000240a:	b0 89       	st.b	r8[0x0],r9
8000240c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	c5 4c       	rcall	800024ba <TransmitControl_reply_func+0x56>
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	62 70       	ld.w	r0,r1[0x1c]
80002418:	00 00       	add	r0,r0
8000241a:	0a 2a       	rsub	r10,r5

8000241c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000241c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002420:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002424:	0f 99       	ld.ub	r9,r7[0x1]
80002426:	30 08       	mov	r8,0
80002428:	f0 09 18 00 	cp.b	r9,r8
8000242c:	c0 71       	brne	8000243a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000242e:	48 ac       	lddpc	r12,80002454 <TransmitControl_brdcst_func+0x38>
80002430:	f0 1f 00 0a 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002434:	30 09       	mov	r9,0
80002436:	48 a8       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
80002438:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000243a:	0f 99       	ld.ub	r9,r7[0x1]
8000243c:	30 18       	mov	r8,1
8000243e:	f0 09 18 00 	cp.b	r9,r8
80002442:	c0 71       	brne	80002450 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002444:	48 7c       	lddpc	r12,80002460 <TransmitControl_brdcst_func+0x44>
80002446:	f0 1f 00 05 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000244a:	30 19       	mov	r9,1
8000244c:	48 48       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
8000244e:	b0 89       	st.b	r8[0x0],r9
80002450:	e3 cd 80 80 	ldm	sp++,r7,pc
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	c5 64       	brge	80002502 <Volume_reply_func+0x16>
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	62 70       	ld.w	r0,r1[0x1c]
8000245c:	00 00       	add	r0,r0
8000245e:	0a 29       	rsub	r9,r5
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	c5 7c       	rcall	80002510 <Volume_reply_func+0x24>

80002464 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c1 61       	brne	800024a0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002476:	48 ec       	lddpc	r12,800024ac <TransmitControl_reply_func+0x48>
80002478:	f0 1f 00 0e 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000247c:	0f 98       	ld.ub	r8,r7[0x1]
8000247e:	1a d8       	st.w	--sp,r8
80002480:	48 dc       	lddpc	r12,800024b4 <TransmitControl_reply_func+0x50>
80002482:	f0 1f 00 0c 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002486:	0f a8       	ld.ub	r8,r7[0x2]
80002488:	1a d8       	st.w	--sp,r8
8000248a:	48 cc       	lddpc	r12,800024b8 <TransmitControl_reply_func+0x54>
8000248c:	f0 1f 00 09 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002490:	0f b8       	ld.ub	r8,r7[0x3]
80002492:	1a d8       	st.w	--sp,r8
80002494:	48 ac       	lddpc	r12,800024bc <TransmitControl_reply_func+0x58>
80002496:	f0 1f 00 07 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
8000249a:	2f dd       	sub	sp,-12
8000249c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024a0:	48 8c       	lddpc	r12,800024c0 <TransmitControl_reply_func+0x5c>
800024a2:	f0 1f 00 04 	mcall	800024b0 <TransmitControl_reply_func+0x4c>
800024a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024aa:	00 00       	add	r0,r0
800024ac:	80 00       	ld.sh	r0,r0[0x0]
800024ae:	c5 90       	breq	80002560 <spk_brdcst_func+0x10>
800024b0:	80 00       	ld.sh	r0,r0[0x0]
800024b2:	62 70       	ld.w	r0,r1[0x1c]
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	c5 ac       	rcall	8000256a <spk_brdcst_func+0x1a>
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	c5 c0       	breq	80002572 <spk_brdcst_func+0x22>
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	c5 dc       	rcall	80002578 <spk_brdcst_func+0x28>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	c5 ec       	rcall	8000257e <spk_brdcst_func+0x2e>

800024c4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024c4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024c6:	19 a9       	ld.ub	r9,r12[0x2]
800024c8:	30 08       	mov	r8,0
800024ca:	f0 09 18 00 	cp.b	r9,r8
800024ce:	c0 51       	brne	800024d8 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
800024d0:	48 4c       	lddpc	r12,800024e0 <AudioRoutingControl_reply_func+0x1c>
800024d2:	f0 1f 00 05 	mcall	800024e4 <AudioRoutingControl_reply_func+0x20>
800024d6:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024d8:	48 4c       	lddpc	r12,800024e8 <AudioRoutingControl_reply_func+0x24>
800024da:	f0 1f 00 03 	mcall	800024e4 <AudioRoutingControl_reply_func+0x20>
800024de:	d8 02       	popm	pc
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	c6 04       	brge	800025a2 <spk_reply_func+0x1a>
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	62 70       	ld.w	r0,r1[0x1c]
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	c6 14       	brge	800025ac <spk_reply_func+0x24>

800024ec <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800024ec:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024f4:	0f 89       	ld.ub	r9,r7[0x0]
800024f6:	30 08       	mov	r8,0
800024f8:	f0 09 18 00 	cp.b	r9,r8
800024fc:	c1 b1       	brne	80002532 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024fe:	0f b8       	ld.ub	r8,r7[0x3]
80002500:	31 09       	mov	r9,16
80002502:	f2 08 18 00 	cp.b	r8,r9
80002506:	c0 f1       	brne	80002524 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002508:	48 dc       	lddpc	r12,8000253c <Volume_reply_func+0x50>
8000250a:	f0 1f 00 0e 	mcall	80002540 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
8000250e:	0f 99       	ld.ub	r9,r7[0x1]
80002510:	0f a8       	ld.ub	r8,r7[0x2]
80002512:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002516:	1a d8       	st.w	--sp,r8
80002518:	48 bc       	lddpc	r12,80002544 <Volume_reply_func+0x58>
8000251a:	f0 1f 00 0a 	mcall	80002540 <Volume_reply_func+0x54>
8000251e:	2f fd       	sub	sp,-4
80002520:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002524:	1a d8       	st.w	--sp,r8
80002526:	48 9c       	lddpc	r12,80002548 <Volume_reply_func+0x5c>
80002528:	f0 1f 00 06 	mcall	80002540 <Volume_reply_func+0x54>
8000252c:	2f fd       	sub	sp,-4
8000252e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002532:	48 7c       	lddpc	r12,8000254c <Volume_reply_func+0x60>
80002534:	f0 1f 00 03 	mcall	80002540 <Volume_reply_func+0x54>
80002538:	e3 cd 80 80 	ldm	sp++,r7,pc
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	c6 28       	rjmp	80002602 <mic_brdcst_func+0x32>
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	62 70       	ld.w	r0,r1[0x1c]
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	c6 3c       	rcall	8000260c <mic_brdcst_func+0x3c>
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	c6 58       	rjmp	80002614 <mic_brdcst_func+0x44>
8000254c:	80 00       	ld.sh	r0,r0[0x0]
8000254e:	c6 70       	breq	8000261c <mic_brdcst_func+0x4c>

80002550 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002550:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002552:	19 d9       	ld.ub	r9,r12[0x5]
80002554:	30 08       	mov	r8,0
80002556:	f0 09 18 00 	cp.b	r9,r8
8000255a:	c0 81       	brne	8000256a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000255c:	10 99       	mov	r9,r8
8000255e:	48 78       	lddpc	r8,80002578 <spk_brdcst_func+0x28>
80002560:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002562:	48 7c       	lddpc	r12,8000257c <spk_brdcst_func+0x2c>
80002564:	f0 1f 00 07 	mcall	80002580 <spk_brdcst_func+0x30>
80002568:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000256a:	30 19       	mov	r9,1
8000256c:	48 38       	lddpc	r8,80002578 <spk_brdcst_func+0x28>
8000256e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002570:	48 5c       	lddpc	r12,80002584 <spk_brdcst_func+0x34>
80002572:	f0 1f 00 04 	mcall	80002580 <spk_brdcst_func+0x30>
80002576:	d8 02       	popm	pc
80002578:	00 00       	add	r0,r0
8000257a:	0a 20       	rsub	r0,r5
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	c6 88       	rjmp	8000264e <mic_reply_func+0x26>
80002580:	80 00       	ld.sh	r0,r0[0x0]
80002582:	62 70       	ld.w	r0,r1[0x1c]
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	c6 98       	rjmp	80002658 <mic_reply_func+0x30>

80002588 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002588:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000258a:	19 a9       	ld.ub	r9,r12[0x2]
8000258c:	30 08       	mov	r8,0
8000258e:	f0 09 18 00 	cp.b	r9,r8
80002592:	c0 f1       	brne	800025b0 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002594:	19 e9       	ld.ub	r9,r12[0x6]
80002596:	f0 09 18 00 	cp.b	r9,r8
8000259a:	c0 40       	breq	800025a2 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000259c:	30 19       	mov	r9,1
8000259e:	48 98       	lddpc	r8,800025c0 <spk_reply_func+0x38>
800025a0:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025a2:	19 e8       	ld.ub	r8,r12[0x6]
800025a4:	1a d8       	st.w	--sp,r8
800025a6:	48 8c       	lddpc	r12,800025c4 <spk_reply_func+0x3c>
800025a8:	f0 1f 00 08 	mcall	800025c8 <spk_reply_func+0x40>
800025ac:	2f fd       	sub	sp,-4
800025ae:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025b0:	30 09       	mov	r9,0
800025b2:	48 48       	lddpc	r8,800025c0 <spk_reply_func+0x38>
800025b4:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025b6:	48 6c       	lddpc	r12,800025cc <spk_reply_func+0x44>
800025b8:	f0 1f 00 04 	mcall	800025c8 <spk_reply_func+0x40>
800025bc:	d8 02       	popm	pc
800025be:	00 00       	add	r0,r0
800025c0:	00 00       	add	r0,r0
800025c2:	0a 20       	rsub	r0,r5
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	c6 a4       	brge	8000269a <mic_reply_func+0x72>
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	62 70       	ld.w	r0,r1[0x1c]
800025cc:	80 00       	ld.sh	r0,r0[0x0]
800025ce:	c6 b4       	brge	800026a4 <mic_reply_func+0x7c>

800025d0 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800025d8:	0f a9       	ld.ub	r9,r7[0x2]
800025da:	30 08       	mov	r8,0
800025dc:	f0 09 18 00 	cp.b	r9,r8
800025e0:	c0 71       	brne	800025ee <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800025e2:	48 dc       	lddpc	r12,80002614 <mic_brdcst_func+0x44>
800025e4:	f0 1f 00 0d 	mcall	80002618 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800025e8:	30 09       	mov	r9,0
800025ea:	48 d8       	lddpc	r8,8000261c <mic_brdcst_func+0x4c>
800025ec:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800025ee:	0f a9       	ld.ub	r9,r7[0x2]
800025f0:	31 18       	mov	r8,17
800025f2:	f0 09 18 00 	cp.b	r9,r8
800025f6:	c0 d1       	brne	80002610 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025f8:	48 ac       	lddpc	r12,80002620 <mic_brdcst_func+0x50>
800025fa:	f0 1f 00 08 	mcall	80002618 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025fe:	48 89       	lddpc	r9,8000261c <mic_brdcst_func+0x4c>
80002600:	30 18       	mov	r8,1
80002602:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002604:	13 89       	ld.ub	r9,r9[0x0]
80002606:	f0 09 18 00 	cp.b	r9,r8
8000260a:	c0 31       	brne	80002610 <mic_brdcst_func+0x40>
8000260c:	48 68       	lddpc	r8,80002624 <mic_brdcst_func+0x54>
8000260e:	11 88       	ld.ub	r8,r8[0x0]
80002610:	e3 cd 80 80 	ldm	sp++,r7,pc
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	c6 c0       	breq	800026ee <dcm_brdcst_func+0x32>
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	62 70       	ld.w	r0,r1[0x1c]
8000261c:	00 00       	add	r0,r0
8000261e:	0a 32       	cp.w	r2,r5
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	c6 d4       	brge	800026fc <dcm_brdcst_func+0x40>
80002624:	00 00       	add	r0,r0
80002626:	0a 2a       	rsub	r10,r5

80002628 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002628:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
8000262c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002630:	49 ac       	lddpc	r12,80002698 <mic_reply_func+0x70>
80002632:	f0 1f 00 1b 	mcall	8000269c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002636:	0f 89       	ld.ub	r9,r7[0x0]
80002638:	30 08       	mov	r8,0
8000263a:	f0 09 18 00 	cp.b	r9,r8
8000263e:	c2 71       	brne	8000268c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002640:	0f 98       	ld.ub	r8,r7[0x1]
80002642:	30 29       	mov	r9,2
80002644:	f2 08 18 00 	cp.b	r8,r9
80002648:	c1 b1       	brne	8000267e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000264a:	49 6c       	lddpc	r12,800026a0 <mic_reply_func+0x78>
8000264c:	f0 1f 00 14 	mcall	8000269c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002650:	0f a8       	ld.ub	r8,r7[0x2]
80002652:	1a d8       	st.w	--sp,r8
80002654:	49 4c       	lddpc	r12,800026a4 <mic_reply_func+0x7c>
80002656:	f0 1f 00 12 	mcall	8000269c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000265a:	0f b8       	ld.ub	r8,r7[0x3]
8000265c:	1a d8       	st.w	--sp,r8
8000265e:	49 3c       	lddpc	r12,800026a8 <mic_reply_func+0x80>
80002660:	f0 1f 00 0f 	mcall	8000269c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002664:	0f c8       	ld.ub	r8,r7[0x4]
80002666:	1a d8       	st.w	--sp,r8
80002668:	49 1c       	lddpc	r12,800026ac <mic_reply_func+0x84>
8000266a:	f0 1f 00 0d 	mcall	8000269c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000266e:	0f d8       	ld.ub	r8,r7[0x5]
80002670:	1a d8       	st.w	--sp,r8
80002672:	49 0c       	lddpc	r12,800026b0 <mic_reply_func+0x88>
80002674:	f0 1f 00 0a 	mcall	8000269c <mic_reply_func+0x74>
80002678:	2f cd       	sub	sp,-16
8000267a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 dc       	lddpc	r12,800026b4 <mic_reply_func+0x8c>
80002682:	f0 1f 00 07 	mcall	8000269c <mic_reply_func+0x74>
80002686:	2f fd       	sub	sp,-4
80002688:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000268c:	48 bc       	lddpc	r12,800026b8 <mic_reply_func+0x90>
8000268e:	f0 1f 00 04 	mcall	8000269c <mic_reply_func+0x74>
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	c6 e8       	rjmp	80002776 <ToneControl_reply_func+0xa>
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	62 70       	ld.w	r0,r1[0x1c]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	c6 f8       	rjmp	80002780 <ToneControl_reply_func+0x14>
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	c7 0c       	rcall	80002786 <ToneControl_reply_func+0x1a>
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	c7 20       	breq	8000278e <ToneControl_reply_func+0x22>
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	c7 3c       	rcall	80002794 <app_cfg>
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	c7 54       	brge	8000279c <app_cfg+0x8>
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	c7 6c       	rcall	800027a2 <app_cfg+0xe>
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	c7 84       	brge	800027aa <app_cfg+0x16>

800026bc <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026bc:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026c0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026c4:	48 bc       	lddpc	r12,800026f0 <dcm_brdcst_func+0x34>
800026c6:	f0 1f 00 0c 	mcall	800026f4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026ca:	0f 88       	ld.ub	r8,r7[0x0]
800026cc:	1a d8       	st.w	--sp,r8
800026ce:	48 bc       	lddpc	r12,800026f8 <dcm_brdcst_func+0x3c>
800026d0:	f0 1f 00 09 	mcall	800026f4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026d4:	0f a8       	ld.ub	r8,r7[0x2]
800026d6:	1a d8       	st.w	--sp,r8
800026d8:	48 9c       	lddpc	r12,800026fc <dcm_brdcst_func+0x40>
800026da:	f0 1f 00 07 	mcall	800026f4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800026de:	0f 98       	ld.ub	r8,r7[0x1]
800026e0:	1a d8       	st.w	--sp,r8
800026e2:	48 8c       	lddpc	r12,80002700 <dcm_brdcst_func+0x44>
800026e4:	f0 1f 00 04 	mcall	800026f4 <dcm_brdcst_func+0x38>
800026e8:	2f dd       	sub	sp,-12
	
	
}
800026ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ee:	00 00       	add	r0,r0
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	c7 94       	brge	800027e4 <app_cfg+0x50>
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	62 70       	ld.w	r0,r1[0x1c]
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	c7 a8       	rjmp	800027ee <app_cfg+0x5a>
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	c7 bc       	rcall	800027f4 <app_cfg+0x60>
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	c7 d4       	brge	800027fc <app_cfg+0x68>

80002704 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002704:	eb cd 40 80 	pushm	r7,lr
80002708:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000270a:	19 a9       	ld.ub	r9,r12[0x2]
8000270c:	30 08       	mov	r8,0
8000270e:	f0 09 18 00 	cp.b	r9,r8
80002712:	c1 b1       	brne	80002748 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002714:	19 b8       	ld.ub	r8,r12[0x3]
80002716:	30 19       	mov	r9,1
80002718:	f2 08 18 00 	cp.b	r8,r9
8000271c:	c0 51       	brne	80002726 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000271e:	48 ec       	lddpc	r12,80002754 <dcm_reply_func+0x50>
80002720:	f0 1f 00 0e 	mcall	80002758 <dcm_reply_func+0x54>
80002724:	c0 a8       	rjmp	80002738 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002726:	58 08       	cp.w	r8,0
80002728:	c0 51       	brne	80002732 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000272a:	48 dc       	lddpc	r12,8000275c <dcm_reply_func+0x58>
8000272c:	f0 1f 00 0b 	mcall	80002758 <dcm_reply_func+0x54>
80002730:	c0 48       	rjmp	80002738 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002732:	48 cc       	lddpc	r12,80002760 <dcm_reply_func+0x5c>
80002734:	f0 1f 00 09 	mcall	80002758 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002738:	0f d8       	ld.ub	r8,r7[0x5]
8000273a:	1a d8       	st.w	--sp,r8
8000273c:	48 ac       	lddpc	r12,80002764 <dcm_reply_func+0x60>
8000273e:	f0 1f 00 07 	mcall	80002758 <dcm_reply_func+0x54>
80002742:	2f fd       	sub	sp,-4
80002744:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002748:	48 8c       	lddpc	r12,80002768 <dcm_reply_func+0x64>
8000274a:	f0 1f 00 04 	mcall	80002758 <dcm_reply_func+0x54>
8000274e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002752:	00 00       	add	r0,r0
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	c7 f0       	breq	80002854 <app_cfg+0xc0>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	62 70       	ld.w	r0,r1[0x1c]
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	c8 04       	brge	8000265e <mic_reply_func+0x36>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	c8 18       	rjmp	80002864 <app_cfg+0xd0>
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	c8 2c       	rcall	8000286a <app_cfg+0xd6>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	c8 38       	rjmp	80002870 <app_cfg+0xdc>

8000276c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000276c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000276e:	19 a9       	ld.ub	r9,r12[0x2]
80002770:	30 08       	mov	r8,0
80002772:	f0 09 18 00 	cp.b	r9,r8
80002776:	c0 51       	brne	80002780 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002778:	48 4c       	lddpc	r12,80002788 <ToneControl_reply_func+0x1c>
8000277a:	f0 1f 00 05 	mcall	8000278c <ToneControl_reply_func+0x20>
8000277e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002780:	48 4c       	lddpc	r12,80002790 <ToneControl_reply_func+0x24>
80002782:	f0 1f 00 03 	mcall	8000278c <ToneControl_reply_func+0x20>
80002786:	d8 02       	popm	pc
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	c8 44       	brge	80002692 <mic_reply_func+0x6a>
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	62 70       	ld.w	r0,r1[0x1c]
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	c8 50       	breq	8000269c <mic_reply_func+0x74>

80002794 <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
80002794:	d4 31       	pushm	r0-r7,lr
80002796:	20 2d       	sub	sp,8
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
80002798:	32 0c       	mov	r12,32
8000279a:	f0 1f 00 5c 	mcall	80002908 <app_cfg+0x174>
8000279e:	50 0c       	stdsp	sp[0x0],r12
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027a0:	f0 1f 00 5b 	mcall	8000290c <app_cfg+0x178>
800027a4:	4d b8       	lddpc	r8,80002910 <app_cfg+0x17c>
800027a6:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
800027a8:	4d b7       	lddpc	r7,80002914 <app_cfg+0x180>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027aa:	4d c5       	lddpc	r5,80002918 <app_cfg+0x184>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027ac:	30 91       	mov	r1,9
800027ae:	32 02       	mov	r2,32
800027b0:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
800027b2:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027b4:	4d a4       	lddpc	r4,8000291c <app_cfg+0x188>
800027b6:	fa c3 ff fc 	sub	r3,sp,-4
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
800027ba:	6e 08       	ld.w	r8,r7[0x0]
800027bc:	58 28       	cp.w	r8,2
800027be:	c3 50       	breq	80002828 <app_cfg+0x94>
800027c0:	58 38       	cp.w	r8,3
800027c2:	c4 10       	breq	80002844 <app_cfg+0xb0>
800027c4:	58 08       	cp.w	r8,0
800027c6:	e0 81 00 9b 	brne	800028fc <app_cfg+0x168>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027ca:	4d 68       	lddpc	r8,80002920 <app_cfg+0x18c>
800027cc:	70 08       	ld.w	r8,r8[0x0]
800027ce:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027d2:	58 38       	cp.w	r8,3
800027d4:	c1 21       	brne	800027f8 <app_cfg+0x64>
800027d6:	4d 48       	lddpc	r8,80002924 <app_cfg+0x190>
800027d8:	11 88       	ld.ub	r8,r8[0x0]
800027da:	58 08       	cp.w	r8,0
800027dc:	c0 e1       	brne	800027f8 <app_cfg+0x64>
				{
					connect_flag=1;
800027de:	30 19       	mov	r9,1
800027e0:	4d 18       	lddpc	r8,80002924 <app_cfg+0x190>
800027e2:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027e4:	30 cb       	mov	r11,12
800027e6:	30 1c       	mov	r12,1
800027e8:	f0 1f 00 50 	mcall	80002928 <app_cfg+0x194>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
800027ec:	30 28       	mov	r8,2
800027ee:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
800027f0:	4c fc       	lddpc	r12,8000292c <app_cfg+0x198>
800027f2:	f0 1f 00 50 	mcall	80002930 <app_cfg+0x19c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f6:	c8 38       	rjmp	800028fc <app_cfg+0x168>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
800027f8:	d7 03       	nop
					nop();
800027fa:	d7 03       	nop
					nop();
800027fc:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
800027fe:	4c ec       	lddpc	r12,80002934 <app_cfg+0x1a0>
80002800:	f0 1f 00 4c 	mcall	80002930 <app_cfg+0x19c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
80002804:	4c d8       	lddpc	r8,80002938 <app_cfg+0x1a4>
80002806:	11 de       	ld.ub	lr,r8[0x5]
80002808:	11 cc       	ld.ub	r12,r8[0x4]
8000280a:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
8000280c:	11 aa       	ld.ub	r10,r8[0x2]
8000280e:	11 99       	ld.ub	r9,r8[0x1]
80002810:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
80002812:	1a de       	st.w	--sp,lr
80002814:	1a dc       	st.w	--sp,r12
80002816:	1a db       	st.w	--sp,r11
80002818:	1a da       	st.w	--sp,r10
8000281a:	1a d9       	st.w	--sp,r9
8000281c:	1a d8       	st.w	--sp,r8
8000281e:	4c 8c       	lddpc	r12,8000293c <app_cfg+0x1a8>
80002820:	f0 1f 00 44 	mcall	80002930 <app_cfg+0x19c>
80002824:	2f ad       	sub	sp,-24
80002826:	c6 b8       	rjmp	800028fc <app_cfg+0x168>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
80002828:	0b 88       	ld.ub	r8,r5[0x0]
8000282a:	58 08       	cp.w	r8,0
8000282c:	c0 60       	breq	80002838 <app_cfg+0xa4>
							
							OB_State = OB_WAITINGAPPTASK;
8000282e:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
80002830:	4c 4c       	lddpc	r12,80002940 <app_cfg+0x1ac>
80002832:	f0 1f 00 40 	mcall	80002930 <app_cfg+0x19c>
80002836:	c6 38       	rjmp	800028fc <app_cfg+0x168>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
80002838:	02 9a       	mov	r10,r1
8000283a:	04 9b       	mov	r11,r2
8000283c:	0c 9c       	mov	r12,r6
8000283e:	f0 1f 00 42 	mcall	80002944 <app_cfg+0x1b0>
80002842:	c5 d8       	rjmp	800028fc <app_cfg+0x168>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002844:	68 0c       	ld.w	r12,r4[0x0]
80002846:	0c 99       	mov	r9,r6
80002848:	e0 6a 0f a0 	mov	r10,4000
8000284c:	06 9b       	mov	r11,r3
8000284e:	f0 1f 00 3f 	mcall	80002948 <app_cfg+0x1b4>
80002852:	58 1c       	cp.w	r12,1
80002854:	c1 01       	brne	80002874 <app_cfg+0xe0>
					{
						if(data_ptr!=NULL){//save message
80002856:	40 1c       	lddsp	r12,sp[0x4]
80002858:	58 0c       	cp.w	r12,0
8000285a:	c0 d0       	breq	80002874 <app_cfg+0xe0>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
8000285c:	30 1a       	mov	r10,1
8000285e:	04 9b       	mov	r11,r2
80002860:	f0 1f 00 3b 	mcall	8000294c <app_cfg+0x1b8>
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);		
							
							set_message_store(data_ptr);
80002864:	4b b8       	lddpc	r8,80002950 <app_cfg+0x1bc>
80002866:	70 0c       	ld.w	r12,r8[0x0]
80002868:	40 1b       	lddsp	r11,sp[0x4]
8000286a:	f0 1f 00 3b 	mcall	80002954 <app_cfg+0x1c0>
							log("receive okay!\n");
8000286e:	4b bc       	lddpc	r12,80002958 <app_cfg+0x1c4>
80002870:	f0 1f 00 30 	mcall	80002930 <app_cfg+0x19c>
							
						}
						
					}
										
					message_count = xgflash_get_message_count();
80002874:	f0 1f 00 3a 	mcall	8000295c <app_cfg+0x1c8>
80002878:	5c 8c       	casts.h	r12
8000287a:	4b a8       	lddpc	r8,80002960 <app_cfg+0x1cc>
8000287c:	b0 0c       	st.h	r8[0x0],r12
					if( (message_count!=0) && (Battery_Flag == Battery_Okay) )//有缓存且电量充足，需发送短信
8000287e:	58 0c       	cp.w	r12,0
80002880:	c3 10       	breq	800028e2 <app_cfg+0x14e>
80002882:	4b 98       	lddpc	r8,80002964 <app_cfg+0x1d0>
80002884:	11 88       	ld.ub	r8,r8[0x0]
80002886:	58 08       	cp.w	r8,0
80002888:	c2 d1       	brne	800028e2 <app_cfg+0x14e>
					{
						log("Current_total_message_count: %d\n", message_count);
8000288a:	5c 7c       	castu.h	r12
8000288c:	1a dc       	st.w	--sp,r12
8000288e:	4b 7c       	lddpc	r12,80002968 <app_cfg+0x1d4>
80002890:	f0 1f 00 28 	mcall	80002930 <app_cfg+0x19c>
						if(xSemaphoreTake(SendM_CountingSemaphore, (1000*2) / portTICK_RATE_MS) == pdTRUE)
80002894:	4b 68       	lddpc	r8,8000296c <app_cfg+0x1d8>
80002896:	70 0c       	ld.w	r12,r8[0x0]
80002898:	0c 99       	mov	r9,r6
8000289a:	e0 6a 07 d0 	mov	r10,2000
8000289e:	0c 9b       	mov	r11,r6
800028a0:	f0 1f 00 2a 	mcall	80002948 <app_cfg+0x1b4>
800028a4:	2f fd       	sub	sp,-4
800028a6:	58 1c       	cp.w	r12,1
800028a8:	c2 61       	brne	800028f4 <app_cfg+0x160>
						{
							log("xSemaphoreTake okay!\n");
800028aa:	4b 2c       	lddpc	r12,80002970 <app_cfg+0x1dc>
800028ac:	f0 1f 00 21 	mcall	80002930 <app_cfg+0x19c>
							if(m_buff==NULL)break;
800028b0:	40 08       	lddsp	r8,sp[0x0]
800028b2:	58 08       	cp.w	r8,0
800028b4:	c2 40       	breq	800028fc <app_cfg+0x168>
							status = xgflash_get_message_data(message_count, m_buff, TRUE);
800028b6:	30 1a       	mov	r10,1
800028b8:	10 9b       	mov	r11,r8
800028ba:	4a a8       	lddpc	r8,80002960 <app_cfg+0x1cc>
800028bc:	90 8c       	ld.uh	r12,r8[0x0]
800028be:	f0 1f 00 2e 	mcall	80002974 <app_cfg+0x1e0>
800028c2:	4a e8       	lddpc	r8,80002978 <app_cfg+0x1e4>
800028c4:	91 0c       	st.w	r8[0x0],r12
							if(status == XG_OK)
800028c6:	58 0c       	cp.w	r12,0
800028c8:	c0 71       	brne	800028d6 <app_cfg+0x142>
							{
								xcmp_data_session_req(m_buff, (sizeof(Message_Protocol_t)), destination);//send message
800028ca:	02 9a       	mov	r10,r1
800028cc:	04 9b       	mov	r11,r2
800028ce:	40 0c       	lddsp	r12,sp[0x0]
800028d0:	f0 1f 00 1d 	mcall	80002944 <app_cfg+0x1b0>
800028d4:	c1 08       	rjmp	800028f4 <app_cfg+0x160>
							}
							else
							{
								log("get message err : %d\n", status);
800028d6:	1a dc       	st.w	--sp,r12
800028d8:	4a 9c       	lddpc	r12,8000297c <app_cfg+0x1e8>
800028da:	f0 1f 00 16 	mcall	80002930 <app_cfg+0x19c>
800028de:	2f fd       	sub	sp,-4
800028e0:	c0 a8       	rjmp	800028f4 <app_cfg+0x160>
							}
									
						}								
					}
					else if (Battery_Flag == Battery_Low)
800028e2:	4a 18       	lddpc	r8,80002964 <app_cfg+0x1d0>
800028e4:	11 89       	ld.ub	r9,r8[0x0]
800028e6:	30 18       	mov	r8,1
800028e8:	f0 09 18 00 	cp.b	r9,r8
800028ec:	c0 41       	brne	800028f4 <app_cfg+0x160>
					{
						log("The device battery level is low !\n");
800028ee:	4a 5c       	lddpc	r12,80002980 <app_cfg+0x1ec>
800028f0:	f0 1f 00 10 	mcall	80002930 <app_cfg+0x19c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
800028f4:	d7 03       	nop
					log("app task run!\n");
800028f6:	4a 4c       	lddpc	r12,80002984 <app_cfg+0x1f0>
800028f8:	f0 1f 00 0e 	mcall	80002930 <app_cfg+0x19c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800028fc:	e0 6b 0f a0 	mov	r11,4000
80002900:	48 4c       	lddpc	r12,80002910 <app_cfg+0x17c>
80002902:	f0 1f 00 22 	mcall	80002988 <app_cfg+0x1f4>
	}
80002906:	c5 ab       	rjmp	800027ba <app_cfg+0x26>
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	53 6c       	stdsp	sp[0xd8],r12
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	5b 9c       	cp.w	r12,-7
80002910:	00 00       	add	r0,r0
80002912:	0a 24       	rsub	r4,r5
80002914:	00 00       	add	r0,r0
80002916:	0a 34       	cp.w	r4,r5
80002918:	00 00       	add	r0,r0
8000291a:	00 04       	add	r4,r0
8000291c:	00 00       	add	r0,r0
8000291e:	0a 6c       	and	r12,r5
80002920:	00 00       	add	r0,r0
80002922:	0c f8       	st.b	--r6,r8
80002924:	00 00       	add	r0,r0
80002926:	0a 30       	cp.w	r0,r5
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	34 78       	mov	r8,71
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	c8 5c       	rcall	80002a38 <DataSession_brdcst_func+0x54>
80002930:	80 00       	ld.sh	r0,r0[0x0]
80002932:	62 70       	ld.w	r0,r1[0x1c]
80002934:	80 00       	ld.sh	r0,r0[0x0]
80002936:	c8 70       	breq	80002844 <app_cfg+0xb0>
80002938:	00 00       	add	r0,r0
8000293a:	0c fc       	st.b	--r6,r12
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	c8 80       	breq	8000284e <app_cfg+0xba>
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	c8 ac       	rcall	80002a56 <DataSession_brdcst_func+0x72>
80002944:	80 00       	ld.sh	r0,r0[0x0]
80002946:	33 ac       	mov	r12,58
80002948:	80 00       	ld.sh	r0,r0[0x0]
8000294a:	54 64       	stdsp	sp[0x118],r4
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	44 c8       	lddsp	r8,sp[0x130]
80002950:	00 00       	add	r0,r0
80002952:	0a 7c       	tst	r12,r5
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	33 10       	mov	r0,49
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	c8 bc       	rcall	80002a70 <DataSession_brdcst_func+0x8c>
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	46 30       	lddsp	r0,sp[0x18c]
80002960:	00 00       	add	r0,r0
80002962:	0a 22       	rsub	r2,r5
80002964:	00 00       	add	r0,r0
80002966:	0a 21       	rsub	r1,r5
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	c8 cc       	rcall	80002a82 <DataSession_brdcst_func+0x9e>
8000296c:	00 00       	add	r0,r0
8000296e:	0a 84       	andn	r4,r5
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	c8 f0       	breq	80002890 <app_cfg+0xfc>
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	43 74       	lddsp	r4,sp[0xdc]
80002978:	00 00       	add	r0,r0
8000297a:	04 f4       	st.b	--r2,r4
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	c9 08       	rjmp	80002a9e <DataSession_brdcst_func+0xba>
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	c9 20       	breq	800028a6 <app_cfg+0x112>
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	c9 44       	brge	800028ae <app_cfg+0x11a>
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	5d 4c       	*unknown*

8000298c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000298c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002990:	19 c7       	ld.ub	r7,r12[0x4]
80002992:	19 d8       	ld.ub	r8,r12[0x5]
80002994:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002998:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000299a:	48 dc       	lddpc	r12,800029cc <Phyuserinput_brdcst_func+0x40>
8000299c:	f0 1f 00 0d 	mcall	800029d0 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800029a0:	36 08       	mov	r8,96
800029a2:	f0 07 19 00 	cp.h	r7,r8
800029a6:	c1 11       	brne	800029c8 <Phyuserinput_brdcst_func+0x3c>
800029a8:	48 b8       	lddpc	r8,800029d4 <Phyuserinput_brdcst_func+0x48>
800029aa:	11 89       	ld.ub	r9,r8[0x0]
800029ac:	30 18       	mov	r8,1
800029ae:	f0 09 18 00 	cp.b	r9,r8
800029b2:	c0 b1       	brne	800029c8 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800029b4:	31 4b       	mov	r11,20
800029b6:	30 1c       	mov	r12,1
800029b8:	f0 1f 00 08 	mcall	800029d8 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(200*2 / portTICK_RATE_MS);//延迟200ms
800029bc:	e0 6c 01 90 	mov	r12,400
800029c0:	f0 1f 00 07 	mcall	800029dc <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message		
		scan_rfid_save_message();
800029c4:	f0 1f 00 07 	mcall	800029e0 <Phyuserinput_brdcst_func+0x54>
800029c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	c9 54       	brge	800028f8 <app_cfg+0x164>
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	62 70       	ld.w	r0,r1[0x1c]
800029d4:	00 00       	add	r0,r0
800029d6:	0a 30       	cp.w	r0,r5
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	34 78       	mov	r8,71
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	5d 04       	ror	r4
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	3e 20       	mov	r0,-30

800029e4 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800029e4:	d4 21       	pushm	r4-r7,lr
800029e6:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800029e8:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800029ec:	0d 88       	ld.ub	r8,r6[0x0]
800029ee:	32 49       	mov	r9,36
800029f0:	f2 08 18 00 	cp.b	r8,r9
800029f4:	c2 91       	brne	80002a46 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800029f6:	4b 6c       	lddpc	r12,80002acc <DataSession_brdcst_func+0xe8>
800029f8:	f0 1f 00 36 	mcall	80002ad0 <DataSession_brdcst_func+0xec>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800029fc:	0d a5       	ld.ub	r5,r6[0x2]
800029fe:	0d b8       	ld.ub	r8,r6[0x3]
80002a00:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002a04:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002a06:	0d 98       	ld.ub	r8,r6[0x1]
80002a08:	1a d8       	st.w	--sp,r8
80002a0a:	4b 3c       	lddpc	r12,80002ad4 <DataSession_brdcst_func+0xf0>
80002a0c:	f0 1f 00 31 	mcall	80002ad0 <DataSession_brdcst_func+0xec>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002a10:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002a14:	1a d8       	st.w	--sp,r8
80002a16:	4b 1c       	lddpc	r12,80002ad8 <DataSession_brdcst_func+0xf4>
80002a18:	f0 1f 00 2e 	mcall	80002ad0 <DataSession_brdcst_func+0xec>
		for(i=0; i<data_length; i++)
80002a1c:	2f ed       	sub	sp,-8
80002a1e:	58 05       	cp.w	r5,0
80002a20:	c5 40       	breq	80002ac8 <DataSession_brdcst_func+0xe4>
80002a22:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002a24:	4a e4       	lddpc	r4,80002adc <DataSession_brdcst_func+0xf8>
80002a26:	ec 07 00 08 	add	r8,r6,r7
80002a2a:	11 c8       	ld.ub	r8,r8[0x4]
80002a2c:	1a d8       	st.w	--sp,r8
80002a2e:	1a d7       	st.w	--sp,r7
80002a30:	08 9c       	mov	r12,r4
80002a32:	f0 1f 00 28 	mcall	80002ad0 <DataSession_brdcst_func+0xec>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002a36:	2f f7       	sub	r7,-1
80002a38:	5c 57       	castu.b	r7
80002a3a:	2f ed       	sub	sp,-8
80002a3c:	ee 05 19 00 	cp.h	r5,r7
80002a40:	fe 9b ff f3 	brhi	80002a26 <DataSession_brdcst_func+0x42>
80002a44:	c4 28       	rjmp	80002ac8 <DataSession_brdcst_func+0xe4>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002a46:	1a d8       	st.w	--sp,r8
80002a48:	4a 6c       	lddpc	r12,80002ae0 <DataSession_brdcst_func+0xfc>
80002a4a:	f0 1f 00 22 	mcall	80002ad0 <DataSession_brdcst_func+0xec>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002a4e:	0d 88       	ld.ub	r8,r6[0x0]
80002a50:	2f fd       	sub	sp,-4
80002a52:	30 39       	mov	r9,3
80002a54:	f2 08 18 00 	cp.b	r8,r9
80002a58:	c0 51       	brne	80002a62 <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002a5a:	4a 3c       	lddpc	r12,80002ae4 <DataSession_brdcst_func+0x100>
80002a5c:	f0 1f 00 1d 	mcall	80002ad0 <DataSession_brdcst_func+0xec>
80002a60:	c2 18       	rjmp	80002aa2 <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002a62:	30 49       	mov	r9,4
80002a64:	f2 08 18 00 	cp.b	r8,r9
80002a68:	c1 d1       	brne	80002aa2 <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002a6a:	32 0a       	mov	r10,32
80002a6c:	ec cb ff fc 	sub	r11,r6,-4
80002a70:	1a 9c       	mov	r12,sp
80002a72:	f0 1f 00 1e 	mcall	80002ae8 <DataSession_brdcst_func+0x104>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002a76:	49 e8       	lddpc	r8,80002aec <DataSession_brdcst_func+0x108>
80002a78:	70 0c       	ld.w	r12,r8[0x0]
80002a7a:	f0 1f 00 1e 	mcall	80002af0 <DataSession_brdcst_func+0x10c>
80002a7e:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002a80:	c0 e0       	breq	80002a9c <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002a82:	32 0a       	mov	r10,32
80002a84:	1a 9b       	mov	r11,sp
80002a86:	f0 1f 00 19 	mcall	80002ae8 <DataSession_brdcst_func+0x104>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002a8a:	49 b8       	lddpc	r8,80002af4 <DataSession_brdcst_func+0x110>
80002a8c:	70 0c       	ld.w	r12,r8[0x0]
80002a8e:	30 09       	mov	r9,0
80002a90:	12 9a       	mov	r10,r9
80002a92:	fa cb ff e0 	sub	r11,sp,-32
80002a96:	f0 1f 00 19 	mcall	80002af8 <DataSession_brdcst_func+0x114>
80002a9a:	c0 48       	rjmp	80002aa2 <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002a9c:	49 8c       	lddpc	r12,80002afc <DataSession_brdcst_func+0x118>
80002a9e:	f0 1f 00 0d 	mcall	80002ad0 <DataSession_brdcst_func+0xec>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		
		if((ptr->State == DATA_SESSION_TX_Fail) || (ptr->State == DATA_SESSION_TX_Suc))
80002aa2:	0d 89       	ld.ub	r9,r6[0x0]
80002aa4:	20 39       	sub	r9,3
80002aa6:	30 18       	mov	r8,1
80002aa8:	f0 09 18 00 	cp.b	r9,r8
80002aac:	e0 8b 00 0e 	brhi	80002ac8 <DataSession_brdcst_func+0xe4>
		{		
			if( xSemaphoreGive( SendM_CountingSemaphore ) != pdTRUE )
80002ab0:	49 48       	lddpc	r8,80002b00 <DataSession_brdcst_func+0x11c>
80002ab2:	70 0c       	ld.w	r12,r8[0x0]
80002ab4:	30 09       	mov	r9,0
80002ab6:	12 9a       	mov	r10,r9
80002ab8:	12 9b       	mov	r11,r9
80002aba:	f0 1f 00 10 	mcall	80002af8 <DataSession_brdcst_func+0x114>
80002abe:	58 1c       	cp.w	r12,1
80002ac0:	c0 40       	breq	80002ac8 <DataSession_brdcst_func+0xe4>
			{
				log("xSemaphoreGive: err\n\r" );
80002ac2:	49 1c       	lddpc	r12,80002b04 <DataSession_brdcst_func+0x120>
80002ac4:	f0 1f 00 03 	mcall	80002ad0 <DataSession_brdcst_func+0xec>
				//
		//}
		
	}
	
}
80002ac8:	2f 7d       	sub	sp,-36
80002aca:	d8 22       	popm	r4-r7,pc
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	c9 74       	brge	800029fc <DataSession_brdcst_func+0x18>
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	62 70       	ld.w	r0,r1[0x1c]
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	c9 88       	rjmp	80002c06 <send_flash_command+0xc6>
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	c9 a0       	breq	80002a0e <DataSession_brdcst_func+0x2a>
80002adc:	80 00       	ld.sh	r0,r0[0x0]
80002ade:	c9 bc       	rcall	80002c14 <send_flash_command+0xd4>
80002ae0:	80 00       	ld.sh	r0,r0[0x0]
80002ae2:	c9 d4       	brge	80002a1c <DataSession_brdcst_func+0x38>
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	c9 e0       	breq	80002a22 <DataSession_brdcst_func+0x3e>
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	69 92       	ld.w	r2,r4[0x64]
80002aec:	00 00       	add	r0,r0
80002aee:	0a 7c       	tst	r12,r5
80002af0:	80 00       	ld.sh	r0,r0[0x0]
80002af2:	33 30       	mov	r0,51
80002af4:	00 00       	add	r0,r0
80002af6:	0a 6c       	and	r12,r5
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	56 20       	stdsp	sp[0x188],r0
80002afc:	80 00       	ld.sh	r0,r0[0x0]
80002afe:	c9 f8       	rjmp	80002c3c <send_flash_command+0xfc>
80002b00:	00 00       	add	r0,r0
80002b02:	0a 84       	andn	r4,r5
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	ca 08       	rjmp	80002c46 <send_flash_command+0x106>

80002b08 <DeviceInitializationStatus_brdcst_func>:
extern volatile xSemaphoreHandle SendM_CountingSemaphore;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002b08:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002b0a:	19 e8       	ld.ub	r8,r12[0x6]
80002b0c:	30 19       	mov	r9,1
80002b0e:	f2 08 18 00 	cp.b	r8,r9
80002b12:	c0 61       	brne	80002b1e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002b14:	48 98       	lddpc	r8,80002b38 <DeviceInitializationStatus_brdcst_func+0x30>
80002b16:	70 09       	ld.w	r9,r8[0x0]
80002b18:	a1 a9       	sbr	r9,0x0
80002b1a:	91 09       	st.w	r8[0x0],r9
80002b1c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002b1e:	30 29       	mov	r9,2
80002b20:	f2 08 18 00 	cp.b	r8,r9
80002b24:	c0 80       	breq	80002b34 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002b26:	48 58       	lddpc	r8,80002b38 <DeviceInitializationStatus_brdcst_func+0x30>
80002b28:	70 09       	ld.w	r9,r8[0x0]
80002b2a:	e0 19 ff fc 	andl	r9,0xfffc
80002b2e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002b30:	f0 1f 00 03 	mcall	80002b3c <DeviceInitializationStatus_brdcst_func+0x34>
80002b34:	d8 02       	popm	pc
80002b36:	00 00       	add	r0,r0
80002b38:	00 00       	add	r0,r0
80002b3a:	0c f8       	st.b	--r6,r8
80002b3c:	80 00       	ld.sh	r0,r0[0x0]
80002b3e:	34 38       	mov	r8,67

80002b40 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002b40:	eb cd 40 fc 	pushm	r2-r7,lr
80002b44:	20 1d       	sub	sp,4
80002b46:	18 97       	mov	r7,r12
80002b48:	14 95       	mov	r5,r10
80002b4a:	12 96       	mov	r6,r9
	U16 status = 1;
80002b4c:	30 18       	mov	r8,1
80002b4e:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002b50:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002b54:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002b58:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002b5c:	30 1b       	mov	r11,1
80002b5e:	4e 58       	lddpc	r8,80002cf0 <send_flash_command+0x1b0>
80002b60:	70 0c       	ld.w	r12,r8[0x0]
80002b62:	f0 1f 00 65 	mcall	80002cf4 <send_flash_command+0x1b4>

    switch (command)
80002b66:	30 58       	mov	r8,5
80002b68:	f0 07 19 00 	cp.h	r7,r8
80002b6c:	c3 40       	breq	80002bd4 <send_flash_command+0x94>
80002b6e:	e0 8b 00 18 	brhi	80002b9e <send_flash_command+0x5e>
80002b72:	30 28       	mov	r8,2
80002b74:	f0 07 19 00 	cp.h	r7,r8
80002b78:	c5 e0       	breq	80002c34 <send_flash_command+0xf4>
80002b7a:	e0 8b 00 08 	brhi	80002b8a <send_flash_command+0x4a>
80002b7e:	30 18       	mov	r8,1
80002b80:	f0 07 19 00 	cp.h	r7,r8
80002b84:	e0 81 00 ad 	brne	80002cde <send_flash_command+0x19e>
80002b88:	c9 e8       	rjmp	80002cc4 <send_flash_command+0x184>
80002b8a:	30 38       	mov	r8,3
80002b8c:	f0 07 19 00 	cp.h	r7,r8
80002b90:	c7 20       	breq	80002c74 <send_flash_command+0x134>
80002b92:	30 48       	mov	r8,4
80002b94:	f0 07 19 00 	cp.h	r7,r8
80002b98:	e0 81 00 a3 	brne	80002cde <send_flash_command+0x19e>
80002b9c:	c2 c8       	rjmp	80002bf4 <send_flash_command+0xb4>
80002b9e:	35 28       	mov	r8,82
80002ba0:	f0 07 19 00 	cp.h	r7,r8
80002ba4:	c2 f0       	breq	80002c02 <send_flash_command+0xc2>
80002ba6:	e0 8b 00 0c 	brhi	80002bbe <send_flash_command+0x7e>
80002baa:	30 68       	mov	r8,6
80002bac:	f0 07 19 00 	cp.h	r7,r8
80002bb0:	c2 20       	breq	80002bf4 <send_flash_command+0xb4>
80002bb2:	32 08       	mov	r8,32
80002bb4:	f0 07 19 00 	cp.h	r7,r8
80002bb8:	e0 81 00 93 	brne	80002cde <send_flash_command+0x19e>
80002bbc:	c2 38       	rjmp	80002c02 <send_flash_command+0xc2>
80002bbe:	36 08       	mov	r8,96
80002bc0:	f0 07 19 00 	cp.h	r7,r8
80002bc4:	c3 20       	breq	80002c28 <send_flash_command+0xe8>
80002bc6:	e0 68 00 d8 	mov	r8,216
80002bca:	f0 07 19 00 	cp.h	r7,r8
80002bce:	e0 81 00 88 	brne	80002cde <send_flash_command+0x19e>
80002bd2:	c1 88       	rjmp	80002c02 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002bd4:	4c 77       	lddpc	r7,80002cf0 <send_flash_command+0x1b0>
80002bd6:	30 5b       	mov	r11,5
80002bd8:	6e 0c       	ld.w	r12,r7[0x0]
80002bda:	f0 1f 00 48 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_dummy();
80002bde:	e0 6b 00 ff 	mov	r11,255
80002be2:	6e 0c       	ld.w	r12,r7[0x0]
80002be4:	f0 1f 00 45 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002be8:	fa cb ff fe 	sub	r11,sp,-2
80002bec:	6e 0c       	ld.w	r12,r7[0x0]
80002bee:	f0 1f 00 44 	mcall	80002cfc <send_flash_command+0x1bc>
			break;
80002bf2:	c7 68       	rjmp	80002cde <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002bf4:	0e 9b       	mov	r11,r7
80002bf6:	5c 7b       	castu.h	r11
80002bf8:	4b e8       	lddpc	r8,80002cf0 <send_flash_command+0x1b0>
80002bfa:	70 0c       	ld.w	r12,r8[0x0]
80002bfc:	f0 1f 00 3f 	mcall	80002cf8 <send_flash_command+0x1b8>
			break;
80002c00:	c6 f8       	rjmp	80002cde <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002c02:	4b c6       	lddpc	r6,80002cf0 <send_flash_command+0x1b0>
80002c04:	0e 9b       	mov	r11,r7
80002c06:	5c 7b       	castu.h	r11
80002c08:	6c 0c       	ld.w	r12,r6[0x0]
80002c0a:	f0 1f 00 3c 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002c0e:	08 9b       	mov	r11,r4
80002c10:	6c 0c       	ld.w	r12,r6[0x0]
80002c12:	f0 1f 00 3a 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002c16:	06 9b       	mov	r11,r3
80002c18:	6c 0c       	ld.w	r12,r6[0x0]
80002c1a:	f0 1f 00 38 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002c1e:	04 9b       	mov	r11,r2
80002c20:	6c 0c       	ld.w	r12,r6[0x0]
80002c22:	f0 1f 00 36 	mcall	80002cf8 <send_flash_command+0x1b8>
			break;
80002c26:	c5 c8       	rjmp	80002cde <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002c28:	36 0b       	mov	r11,96
80002c2a:	4b 28       	lddpc	r8,80002cf0 <send_flash_command+0x1b0>
80002c2c:	70 0c       	ld.w	r12,r8[0x0]
80002c2e:	f0 1f 00 33 	mcall	80002cf8 <send_flash_command+0x1b8>
			break;
80002c32:	c5 68       	rjmp	80002cde <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002c34:	4a f7       	lddpc	r7,80002cf0 <send_flash_command+0x1b0>
80002c36:	30 2b       	mov	r11,2
80002c38:	6e 0c       	ld.w	r12,r7[0x0]
80002c3a:	f0 1f 00 30 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002c3e:	08 9b       	mov	r11,r4
80002c40:	6e 0c       	ld.w	r12,r7[0x0]
80002c42:	f0 1f 00 2e 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002c46:	06 9b       	mov	r11,r3
80002c48:	6e 0c       	ld.w	r12,r7[0x0]
80002c4a:	f0 1f 00 2c 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002c4e:	04 9b       	mov	r11,r2
80002c50:	6e 0c       	ld.w	r12,r7[0x0]
80002c52:	f0 1f 00 2a 	mcall	80002cf8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002c56:	58 06       	cp.w	r6,0
80002c58:	c4 30       	breq	80002cde <send_flash_command+0x19e>
80002c5a:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002c5c:	4a 54       	lddpc	r4,80002cf0 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002c5e:	0f 3b       	ld.ub	r11,r7++
80002c60:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002c62:	68 0c       	ld.w	r12,r4[0x0]
80002c64:	f0 1f 00 25 	mcall	80002cf8 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002c68:	0e 98       	mov	r8,r7
80002c6a:	0a 18       	sub	r8,r5
80002c6c:	ec 08 19 00 	cp.h	r8,r6
80002c70:	cf 73       	brcs	80002c5e <send_flash_command+0x11e>
80002c72:	c3 68       	rjmp	80002cde <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002c74:	49 f7       	lddpc	r7,80002cf0 <send_flash_command+0x1b0>
80002c76:	30 3b       	mov	r11,3
80002c78:	6e 0c       	ld.w	r12,r7[0x0]
80002c7a:	f0 1f 00 20 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002c7e:	08 9b       	mov	r11,r4
80002c80:	6e 0c       	ld.w	r12,r7[0x0]
80002c82:	f0 1f 00 1e 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002c86:	06 9b       	mov	r11,r3
80002c88:	6e 0c       	ld.w	r12,r7[0x0]
80002c8a:	f0 1f 00 1c 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002c8e:	04 9b       	mov	r11,r2
80002c90:	6e 0c       	ld.w	r12,r7[0x0]
80002c92:	f0 1f 00 1a 	mcall	80002cf8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002c96:	58 06       	cp.w	r6,0
80002c98:	c2 30       	breq	80002cde <send_flash_command+0x19e>
80002c9a:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002c9c:	49 54       	lddpc	r4,80002cf0 <send_flash_command+0x1b0>
80002c9e:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002ca2:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002ca4:	06 9b       	mov	r11,r3
80002ca6:	68 0c       	ld.w	r12,r4[0x0]
80002ca8:	f0 1f 00 14 	mcall	80002cf8 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002cac:	1a 9b       	mov	r11,sp
80002cae:	68 0c       	ld.w	r12,r4[0x0]
80002cb0:	f0 1f 00 13 	mcall	80002cfc <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002cb4:	9a 08       	ld.sh	r8,sp[0x0]
80002cb6:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002cb8:	0e 98       	mov	r8,r7
80002cba:	0a 18       	sub	r8,r5
80002cbc:	ec 08 19 00 	cp.h	r8,r6
80002cc0:	cf 23       	brcs	80002ca4 <send_flash_command+0x164>
80002cc2:	c0 e8       	rjmp	80002cde <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002cc4:	48 b7       	lddpc	r7,80002cf0 <send_flash_command+0x1b0>
80002cc6:	30 1b       	mov	r11,1
80002cc8:	6e 0c       	ld.w	r12,r7[0x0]
80002cca:	f0 1f 00 0c 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002cce:	30 0b       	mov	r11,0
80002cd0:	6e 0c       	ld.w	r12,r7[0x0]
80002cd2:	f0 1f 00 0a 	mcall	80002cf8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002cd6:	30 0b       	mov	r11,0
80002cd8:	6e 0c       	ld.w	r12,r7[0x0]
80002cda:	f0 1f 00 08 	mcall	80002cf8 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002cde:	30 1b       	mov	r11,1
80002ce0:	48 48       	lddpc	r8,80002cf0 <send_flash_command+0x1b0>
80002ce2:	70 0c       	ld.w	r12,r8[0x0]
80002ce4:	f0 1f 00 07 	mcall	80002d00 <send_flash_command+0x1c0>

	return status;
}
80002ce8:	9a 1c       	ld.sh	r12,sp[0x2]
80002cea:	2f fd       	sub	sp,-4
80002cec:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002cf0:	00 00       	add	r0,r0
80002cf2:	1d 04       	ld.w	r4,lr++
80002cf4:	80 00       	ld.sh	r0,r0[0x0]
80002cf6:	4d 1c       	lddpc	r12,80002e38 <data_flash_write_block+0x5c>
80002cf8:	80 00       	ld.sh	r0,r0[0x0]
80002cfa:	4b b6       	lddpc	r6,80002de4 <data_flash_write_block+0x8>
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	4b d2       	lddpc	r2,80002df0 <data_flash_write_block+0x14>
80002d00:	80 00       	ld.sh	r0,r0[0x0]
80002d02:	4c dc       	lddpc	r12,80002e34 <data_flash_write_block+0x58>

80002d04 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002d04:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002d06:	58 0a       	cp.w	r10,0
80002d08:	5f 09       	sreq	r9
80002d0a:	e0 68 ff fe 	mov	r8,65534
80002d0e:	ea 18 00 7f 	orh	r8,0x7f
80002d12:	10 3c       	cp.w	r12,r8
80002d14:	5f b8       	srhi	r8
80002d16:	f3 e8 10 08 	or	r8,r9,r8
80002d1a:	c0 e1       	brne	80002d36 <data_flash_read_block+0x32>
80002d1c:	e0 68 10 00 	mov	r8,4096
80002d20:	f0 0b 19 00 	cp.h	r11,r8
80002d24:	e0 8b 00 09 	brhi	80002d36 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002d28:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002d2c:	18 9b       	mov	r11,r12
80002d2e:	30 3c       	mov	r12,3
80002d30:	f0 1f 00 02 	mcall	80002d38 <data_flash_read_block+0x34>
80002d34:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002d36:	da 0a       	popm	pc,r12=1
80002d38:	80 00       	ld.sh	r0,r0[0x0]
80002d3a:	2b 40       	sub	r0,-76

80002d3c <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002d3c:	eb cd 40 fc 	pushm	r2-r7,lr
80002d40:	18 94       	mov	r4,r12
80002d42:	16 93       	mov	r3,r11
80002d44:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002d46:	58 0c       	cp.w	r12,0
80002d48:	5f 09       	sreq	r9
80002d4a:	e0 68 ff fe 	mov	r8,65534
80002d4e:	ea 18 00 7f 	orh	r8,0x7f
80002d52:	10 3b       	cp.w	r11,r8
80002d54:	5f b8       	srhi	r8
80002d56:	f3 e8 10 08 	or	r8,r9,r8
80002d5a:	c3 a1       	brne	80002dce <data_flash_write_page+0x92>
80002d5c:	e0 68 01 00 	mov	r8,256
80002d60:	f0 0a 19 00 	cp.h	r10,r8
80002d64:	e0 8b 00 35 	brhi	80002dce <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002d68:	30 06       	mov	r6,0
80002d6a:	30 55       	mov	r5,5
80002d6c:	30 17       	mov	r7,1
80002d6e:	0c 99       	mov	r9,r6
80002d70:	0c 9a       	mov	r10,r6
80002d72:	0c 9b       	mov	r11,r6
80002d74:	0a 9c       	mov	r12,r5
80002d76:	f0 1f 00 19 	mcall	80002dd8 <data_flash_write_page+0x9c>
80002d7a:	ee 0c 19 00 	cp.h	r12,r7
80002d7e:	cf 80       	breq	80002d6e <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002d80:	30 09       	mov	r9,0
80002d82:	12 9a       	mov	r10,r9
80002d84:	12 9b       	mov	r11,r9
80002d86:	30 6c       	mov	r12,6
80002d88:	f0 1f 00 14 	mcall	80002dd8 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002d8c:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002d90:	08 9a       	mov	r10,r4
80002d92:	06 9b       	mov	r11,r3
80002d94:	30 2c       	mov	r12,2
80002d96:	f0 1f 00 11 	mcall	80002dd8 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002d9a:	30 06       	mov	r6,0
80002d9c:	30 57       	mov	r7,5
80002d9e:	0c 99       	mov	r9,r6
80002da0:	0c 9a       	mov	r10,r6
80002da2:	0c 9b       	mov	r11,r6
80002da4:	0e 9c       	mov	r12,r7
80002da6:	f0 1f 00 0d 	mcall	80002dd8 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002daa:	5c 7c       	castu.h	r12
80002dac:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002db0:	cf 71       	brne	80002d9e <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002db2:	18 97       	mov	r7,r12
80002db4:	e2 17 00 20 	andl	r7,0x20,COH
80002db8:	f9 b7 01 06 	movne	r7,6
80002dbc:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002dc0:	30 09       	mov	r9,0
80002dc2:	12 9a       	mov	r10,r9
80002dc4:	12 9b       	mov	r11,r9
80002dc6:	30 4c       	mov	r12,4
80002dc8:	f0 1f 00 04 	mcall	80002dd8 <data_flash_write_page+0x9c>

	return return_code;
80002dcc:	c0 28       	rjmp	80002dd0 <data_flash_write_page+0x94>
80002dce:	30 17       	mov	r7,1
}
80002dd0:	0e 9c       	mov	r12,r7
80002dd2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002dd6:	00 00       	add	r0,r0
80002dd8:	80 00       	ld.sh	r0,r0[0x0]
80002dda:	2b 40       	sub	r0,-76

80002ddc <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002ddc:	d4 31       	pushm	r0-r7,lr
80002dde:	18 94       	mov	r4,r12
80002de0:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002de4:	16 97       	mov	r7,r11
80002de6:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002de8:	30 03       	mov	r3,0
80002dea:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002dec:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002df0:	c4 98       	rjmp	80002e82 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002df2:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002df6:	c1 b1       	brne	80002e2c <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002df8:	e0 06 19 00 	cp.h	r6,r0
80002dfc:	e0 8b 00 0a 	brhi	80002e10 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002e00:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002e04:	0e 9b       	mov	r11,r7
80002e06:	08 9c       	mov	r12,r4
80002e08:	f0 1f 00 24 	mcall	80002e98 <data_flash_write_block+0xbc>
80002e0c:	30 06       	mov	r6,0
80002e0e:	c3 a8       	rjmp	80002e82 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002e10:	e0 6a 01 00 	mov	r10,256
80002e14:	0e 9b       	mov	r11,r7
80002e16:	08 9c       	mov	r12,r4
80002e18:	f0 1f 00 20 	mcall	80002e98 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002e1c:	ec c6 01 00 	sub	r6,r6,256
80002e20:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002e22:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002e26:	ee c7 ff 00 	sub	r7,r7,-256
80002e2a:	c2 c8       	rjmp	80002e82 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002e2c:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002e30:	0e 09       	add	r9,r7
80002e32:	0e 98       	mov	r8,r7
80002e34:	e4 18 00 7f 	andh	r8,0x7f
80002e38:	e0 18 ff 00 	andl	r8,0xff00
80002e3c:	f0 c8 ff 00 	sub	r8,r8,-256
80002e40:	10 39       	cp.w	r9,r8
80002e42:	e0 88 00 19 	brls	80002e74 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002e46:	0e 91       	mov	r1,r7
80002e48:	5c 51       	castu.b	r1
80002e4a:	e0 6a 01 00 	mov	r10,256
80002e4e:	02 1a       	sub	r10,r1
80002e50:	5c 7a       	castu.h	r10
80002e52:	0e 9b       	mov	r11,r7
80002e54:	08 9c       	mov	r12,r4
80002e56:	f0 1f 00 11 	mcall	80002e98 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002e5a:	ec c6 01 00 	sub	r6,r6,256
80002e5e:	02 06       	add	r6,r1
80002e60:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002e62:	e0 68 01 00 	mov	r8,256
80002e66:	f0 05 01 05 	sub	r5,r8,r5
80002e6a:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002e6c:	e0 17 ff 00 	andl	r7,0xff00
80002e70:	10 07       	add	r7,r8
80002e72:	c0 88       	rjmp	80002e82 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002e74:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002e78:	0e 9b       	mov	r11,r7
80002e7a:	08 9c       	mov	r12,r4
80002e7c:	f0 1f 00 07 	mcall	80002e98 <data_flash_write_block+0xbc>
80002e80:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002e82:	e6 06 19 00 	cp.h	r6,r3
80002e86:	5f 19       	srne	r9
80002e88:	58 7c       	cp.w	r12,7
80002e8a:	5f 08       	sreq	r8
80002e8c:	f3 e8 00 08 	and	r8,r9,r8
80002e90:	e4 08 18 00 	cp.b	r8,r2
80002e94:	ca f1       	brne	80002df2 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002e96:	d8 32       	popm	r0-r7,pc
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	2d 3c       	sub	r12,-45

80002e9c <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002e9c:	eb cd 40 f8 	pushm	r3-r7,lr
80002ea0:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002ea2:	e0 68 ff fe 	mov	r8,65534
80002ea6:	ea 18 00 7f 	orh	r8,0x7f
80002eaa:	10 3c       	cp.w	r12,r8
80002eac:	e0 88 00 04 	brls	80002eb4 <data_flash_erase_block+0x18>
80002eb0:	30 17       	mov	r7,1
80002eb2:	c3 f8       	rjmp	80002f30 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002eb4:	58 1b       	cp.w	r11,1
80002eb6:	c0 31       	brne	80002ebc <data_flash_erase_block+0x20>
80002eb8:	32 03       	mov	r3,32
80002eba:	c0 a8       	rjmp	80002ece <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002ebc:	58 2b       	cp.w	r11,2
80002ebe:	c0 31       	brne	80002ec4 <data_flash_erase_block+0x28>
80002ec0:	35 23       	mov	r3,82
80002ec2:	c0 68       	rjmp	80002ece <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002ec4:	e0 63 00 d8 	mov	r3,216
80002ec8:	58 3b       	cp.w	r11,3
80002eca:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002ece:	30 06       	mov	r6,0
80002ed0:	30 55       	mov	r5,5
80002ed2:	30 17       	mov	r7,1
80002ed4:	0c 99       	mov	r9,r6
80002ed6:	0c 9a       	mov	r10,r6
80002ed8:	0c 9b       	mov	r11,r6
80002eda:	0a 9c       	mov	r12,r5
80002edc:	f0 1f 00 17 	mcall	80002f38 <data_flash_erase_block+0x9c>
80002ee0:	ee 0c 19 00 	cp.h	r12,r7
80002ee4:	cf 80       	breq	80002ed4 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002ee6:	30 09       	mov	r9,0
80002ee8:	12 9a       	mov	r10,r9
80002eea:	12 9b       	mov	r11,r9
80002eec:	30 6c       	mov	r12,6
80002eee:	f0 1f 00 13 	mcall	80002f38 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002ef2:	30 09       	mov	r9,0
80002ef4:	12 9a       	mov	r10,r9
80002ef6:	08 9b       	mov	r11,r4
80002ef8:	06 9c       	mov	r12,r3
80002efa:	f0 1f 00 10 	mcall	80002f38 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002efe:	30 06       	mov	r6,0
80002f00:	30 57       	mov	r7,5
80002f02:	0c 99       	mov	r9,r6
80002f04:	0c 9a       	mov	r10,r6
80002f06:	0c 9b       	mov	r11,r6
80002f08:	0e 9c       	mov	r12,r7
80002f0a:	f0 1f 00 0c 	mcall	80002f38 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002f0e:	5c 7c       	castu.h	r12
80002f10:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002f14:	cf 71       	brne	80002f02 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002f16:	18 97       	mov	r7,r12
80002f18:	e2 17 00 20 	andl	r7,0x20,COH
80002f1c:	f9 b7 01 04 	movne	r7,4
80002f20:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002f24:	30 09       	mov	r9,0
80002f26:	12 9a       	mov	r10,r9
80002f28:	12 9b       	mov	r11,r9
80002f2a:	30 4c       	mov	r12,4
80002f2c:	f0 1f 00 03 	mcall	80002f38 <data_flash_erase_block+0x9c>

	return return_code;
}
80002f30:	0e 9c       	mov	r12,r7
80002f32:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002f36:	00 00       	add	r0,r0
80002f38:	80 00       	ld.sh	r0,r0[0x0]
80002f3a:	2b 40       	sub	r0,-76

80002f3c <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002f3c:	d4 31       	pushm	r0-r7,lr
80002f3e:	20 3d       	sub	sp,12
80002f40:	50 0c       	stdsp	sp[0x0],r12
80002f42:	16 91       	mov	r1,r11
80002f44:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002f46:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002f4a:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002f4c:	e0 69 10 00 	mov	r9,4096
80002f50:	f2 0a 01 07 	sub	r7,r9,r10
80002f54:	ea 07 19 00 	cp.h	r7,r5
80002f58:	ea 07 17 b0 	movhi	r7,r5
80002f5c:	5c 87       	casts.h	r7
80002f5e:	16 92       	mov	r2,r11
80002f60:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002f64:	4a e4       	lddpc	r4,8000301c <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002f66:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002f68:	e8 c8 ff ff 	sub	r8,r4,-1
80002f6c:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002f6e:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002f70:	08 9a       	mov	r10,r4
80002f72:	e0 6b 10 00 	mov	r11,4096
80002f76:	04 9c       	mov	r12,r2
80002f78:	f0 1f 00 2a 	mcall	80003020 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002f7c:	58 07       	cp.w	r7,0
80002f7e:	c3 00       	breq	80002fde <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002f80:	40 13       	lddsp	r3,sp[0x4]
80002f82:	5c 73       	castu.h	r3
80002f84:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002f88:	ec 08 18 00 	cp.b	r8,r6
80002f8c:	c1 11       	brne	80002fae <data_flash_write+0x72>
80002f8e:	e6 c9 ff ff 	sub	r9,r3,-1
80002f92:	08 09       	add	r9,r4
80002f94:	30 08       	mov	r8,0
80002f96:	c0 58       	rjmp	80002fa0 <data_flash_write+0x64>
80002f98:	13 3a       	ld.ub	r10,r9++
80002f9a:	ec 0a 18 00 	cp.b	r10,r6
80002f9e:	c0 81       	brne	80002fae <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002fa0:	2f f8       	sub	r8,-1
80002fa2:	5c 88       	casts.h	r8
80002fa4:	f0 07 19 00 	cp.h	r7,r8
80002fa8:	fe 9b ff f8 	brhi	80002f98 <data_flash_write+0x5c>
80002fac:	c1 98       	rjmp	80002fde <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002fae:	30 1b       	mov	r11,1
80002fb0:	04 9c       	mov	r12,r2
80002fb2:	f0 1f 00 1d 	mcall	80003024 <data_flash_write+0xe8>
80002fb6:	40 08       	lddsp	r8,sp[0x0]
80002fb8:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002fba:	40 2a       	lddsp	r10,sp[0x8]
80002fbc:	40 19       	lddsp	r9,sp[0x4]
80002fbe:	12 0a       	add	r10,r9
80002fc0:	0e 99       	mov	r9,r7
80002fc2:	20 19       	sub	r9,1
80002fc4:	5c 79       	castu.h	r9
80002fc6:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002fc8:	11 39       	ld.ub	r9,r8++
80002fca:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002fcc:	14 33       	cp.w	r3,r10
80002fce:	cf d1       	brne	80002fc8 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002fd0:	e0 6a 10 00 	mov	r10,4096
80002fd4:	04 9b       	mov	r11,r2
80002fd6:	08 9c       	mov	r12,r4
80002fd8:	f0 1f 00 14 	mcall	80003028 <data_flash_write+0xec>
80002fdc:	c0 78       	rjmp	80002fea <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002fde:	0e 9a       	mov	r10,r7
80002fe0:	5c 7a       	castu.h	r10
80002fe2:	02 9b       	mov	r11,r1
80002fe4:	40 0c       	lddsp	r12,sp[0x0]
80002fe6:	f0 1f 00 11 	mcall	80003028 <data_flash_write+0xec>
80002fea:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002fee:	0e 98       	mov	r8,r7
80002ff0:	ee 05 19 00 	cp.h	r5,r7
80002ff4:	c1 20       	breq	80003018 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002ff6:	5c 78       	castu.h	r8
80002ff8:	40 0a       	lddsp	r10,sp[0x0]
80002ffa:	10 0a       	add	r10,r8
80002ffc:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002ffe:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80003000:	0e 15       	sub	r5,r7
80003002:	5c 85       	casts.h	r5
80003004:	e0 05 19 00 	cp.h	r5,r0
80003008:	ea 07 17 80 	movls	r7,r5
8000300c:	e0 07 17 b0 	movhi	r7,r0
80003010:	5c 87       	casts.h	r7
80003012:	30 09       	mov	r9,0
80003014:	50 19       	stdsp	sp[0x4],r9
80003016:	ca db       	rjmp	80002f70 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80003018:	2f dd       	sub	sp,-12
8000301a:	d8 32       	popm	r0-r7,pc
8000301c:	00 00       	add	r0,r0
8000301e:	0d 04       	ld.w	r4,r6++
80003020:	80 00       	ld.sh	r0,r0[0x0]
80003022:	2d 04       	sub	r4,-48
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	2e 9c       	sub	r12,-23
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	2d dc       	sub	r12,-35

8000302c <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000302c:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000302e:	48 78       	lddpc	r8,80003048 <W25Q64_SPI_SetSpeed+0x1c>
80003030:	70 09       	ld.w	r9,r8[0x0]
80003032:	72 da       	ld.w	r10,r9[0x34]
80003034:	5c 7c       	castu.h	r12
80003036:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000303a:	f9 ea 10 0a 	or	r10,r12,r10
8000303e:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
80003040:	70 0c       	ld.w	r12,r8[0x0]
80003042:	f0 1f 00 03 	mcall	8000304c <W25Q64_SPI_SetSpeed+0x20>
	
	
}
80003046:	d8 02       	popm	pc
80003048:	00 00       	add	r0,r0
8000304a:	1d 04       	ld.w	r4,lr++
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	4b b0       	lddpc	r0,80003138 <data_flash_init+0xd8>

80003050 <W25Q64_SPI_SetSpeedHi>:
{
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
	
}
void W25Q64_SPI_SetSpeedHi(void)
{
80003050:	d4 01       	pushm	lr
	
	W25Q64_SPI_SetSpeed(0x0100);//baudDiv=1
80003052:	e0 6c 01 00 	mov	r12,256
80003056:	f0 1f 00 02 	mcall	8000305c <W25Q64_SPI_SetSpeedHi+0xc>
	
}
8000305a:	d8 02       	popm	pc
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	30 2c       	mov	r12,2

80003060 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003060:	eb cd 40 c0 	pushm	r6-r7,lr
80003064:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80003066:	4b a8       	lddpc	r8,8000314c <data_flash_init+0xec>
80003068:	fa c6 ff fc 	sub	r6,sp,-4
8000306c:	f0 ea 00 00 	ld.d	r10,r8[0]
80003070:	ec eb 00 00 	st.d	r6[0],r10
80003074:	f0 e8 00 08 	ld.d	r8,r8[8]
80003078:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
8000307c:	30 4b       	mov	r11,4
8000307e:	4b 5c       	lddpc	r12,80003150 <data_flash_init+0xf0>
80003080:	f0 1f 00 35 	mcall	80003154 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
80003084:	4b 57       	lddpc	r7,80003158 <data_flash_init+0xf8>
80003086:	fe 7c 24 00 	mov	r12,-56320
8000308a:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
8000308c:	0c 9b       	mov	r11,r6
8000308e:	f0 1f 00 34 	mcall	8000315c <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80003092:	30 09       	mov	r9,0
80003094:	12 9a       	mov	r10,r9
80003096:	12 9b       	mov	r11,r9
80003098:	6e 0c       	ld.w	r12,r7[0x0]
8000309a:	f0 1f 00 32 	mcall	80003160 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
8000309e:	6e 0c       	ld.w	r12,r7[0x0]
800030a0:	f0 1f 00 31 	mcall	80003164 <data_flash_init+0x104>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800030a4:	e0 6a 36 00 	mov	r10,13824
800030a8:	ea 1a 01 6e 	orh	r10,0x16e
800030ac:	0c 9b       	mov	r11,r6
800030ae:	6e 0c       	ld.w	r12,r7[0x0]
800030b0:	f0 1f 00 2e 	mcall	80003168 <data_flash_init+0x108>
800030b4:	c0 50       	breq	800030be <data_flash_init+0x5e>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
800030b6:	30 29       	mov	r9,2
800030b8:	4a d8       	lddpc	r8,8000316c <data_flash_init+0x10c>
800030ba:	b0 89       	st.b	r8[0x0],r9
		return;
800030bc:	c4 58       	rjmp	80003146 <data_flash_init+0xe6>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
800030be:	1a 96       	mov	r6,sp
800030c0:	30 4a       	mov	r10,4
800030c2:	4a cb       	lddpc	r11,80003170 <data_flash_init+0x110>
800030c4:	1a 9c       	mov	r12,sp
800030c6:	f0 1f 00 2c 	mcall	80003174 <data_flash_init+0x114>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
800030ca:	4a 47       	lddpc	r7,80003158 <data_flash_init+0xf8>
800030cc:	30 1b       	mov	r11,1
800030ce:	6e 0c       	ld.w	r12,r7[0x0]
800030d0:	f0 1f 00 2a 	mcall	80003178 <data_flash_init+0x118>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
800030d4:	e0 6b 00 90 	mov	r11,144
800030d8:	6e 0c       	ld.w	r12,r7[0x0]
800030da:	f0 1f 00 29 	mcall	8000317c <data_flash_init+0x11c>
	spi_write_zero();
800030de:	30 0b       	mov	r11,0
800030e0:	6e 0c       	ld.w	r12,r7[0x0]
800030e2:	f0 1f 00 27 	mcall	8000317c <data_flash_init+0x11c>
	spi_write_zero();
800030e6:	30 0b       	mov	r11,0
800030e8:	6e 0c       	ld.w	r12,r7[0x0]
800030ea:	f0 1f 00 25 	mcall	8000317c <data_flash_init+0x11c>
	spi_write_zero();
800030ee:	30 0b       	mov	r11,0
800030f0:	6e 0c       	ld.w	r12,r7[0x0]
800030f2:	f0 1f 00 23 	mcall	8000317c <data_flash_init+0x11c>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
800030f6:	e0 6b 00 ff 	mov	r11,255
800030fa:	6e 0c       	ld.w	r12,r7[0x0]
800030fc:	f0 1f 00 20 	mcall	8000317c <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[0]);
80003100:	1a 9b       	mov	r11,sp
80003102:	6e 0c       	ld.w	r12,r7[0x0]
80003104:	f0 1f 00 1f 	mcall	80003180 <data_flash_init+0x120>
	
	spi_write_dummy();
80003108:	e0 6b 00 ff 	mov	r11,255
8000310c:	6e 0c       	ld.w	r12,r7[0x0]
8000310e:	f0 1f 00 1c 	mcall	8000317c <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[1]);
80003112:	fa cb ff fe 	sub	r11,sp,-2
80003116:	6e 0c       	ld.w	r12,r7[0x0]
80003118:	f0 1f 00 1a 	mcall	80003180 <data_flash_init+0x120>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
8000311c:	30 1b       	mov	r11,1
8000311e:	6e 0c       	ld.w	r12,r7[0x0]
80003120:	f0 1f 00 19 	mcall	80003184 <data_flash_init+0x124>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80003124:	e0 68 00 ef 	mov	r8,239
80003128:	9a 09       	ld.sh	r9,sp[0x0]
8000312a:	f0 09 19 00 	cp.h	r9,r8
8000312e:	c0 61       	brne	8000313a <data_flash_init+0xda>
80003130:	31 68       	mov	r8,22
80003132:	9a 19       	ld.sh	r9,sp[0x2]
80003134:	f0 09 19 00 	cp.h	r9,r8
80003138:	c0 50       	breq	80003142 <data_flash_init+0xe2>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
8000313a:	30 39       	mov	r9,3
8000313c:	48 c8       	lddpc	r8,8000316c <data_flash_init+0x10c>
8000313e:	b0 89       	st.b	r8[0x0],r9
		return;
80003140:	c0 38       	rjmp	80003146 <data_flash_init+0xe6>
	}

	W25Q64_SPI_SetSpeedHi();
80003142:	f0 1f 00 12 	mcall	80003188 <data_flash_init+0x128>
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
80003146:	2f bd       	sub	sp,-20
80003148:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000314c:	80 00       	ld.sh	r0,r0[0x0]
8000314e:	ca 44       	brge	80003096 <data_flash_init+0x36>
80003150:	80 00       	ld.sh	r0,r0[0x0]
80003152:	ca 20       	breq	80003096 <data_flash_init+0x36>
80003154:	80 00       	ld.sh	r0,r0[0x0]
80003156:	46 dc       	lddsp	r12,sp[0x1b4]
80003158:	00 00       	add	r0,r0
8000315a:	1d 04       	ld.w	r4,lr++
8000315c:	80 00       	ld.sh	r0,r0[0x0]
8000315e:	4b 4c       	lddpc	r12,8000322c <rtc_irq+0x20>
80003160:	80 00       	ld.sh	r0,r0[0x0]
80003162:	4b 84       	lddpc	r4,80003240 <rtc_irq+0x34>
80003164:	80 00       	ld.sh	r0,r0[0x0]
80003166:	4b b0       	lddpc	r0,80003250 <rtc_irq+0x44>
80003168:	80 00       	ld.sh	r0,r0[0x0]
8000316a:	4b f4       	lddpc	r4,80003264 <rtc_irq+0x58>
8000316c:	00 00       	add	r0,r0
8000316e:	0a 3c       	cp.w	r12,r5
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	ca 40       	breq	800030ba <data_flash_init+0x5a>
80003174:	80 00       	ld.sh	r0,r0[0x0]
80003176:	69 92       	ld.w	r2,r4[0x64]
80003178:	80 00       	ld.sh	r0,r0[0x0]
8000317a:	4d 1c       	lddpc	r12,800032bc <rtc_irq+0xb0>
8000317c:	80 00       	ld.sh	r0,r0[0x0]
8000317e:	4b b6       	lddpc	r6,80003268 <rtc_irq+0x5c>
80003180:	80 00       	ld.sh	r0,r0[0x0]
80003182:	4b d2       	lddpc	r2,80003274 <rtc_irq+0x68>
80003184:	80 00       	ld.sh	r0,r0[0x0]
80003186:	4c dc       	lddpc	r12,800032b8 <rtc_irq+0xac>
80003188:	80 00       	ld.sh	r0,r0[0x0]
8000318a:	30 50       	mov	r0,5

8000318c <xg_rtc_init>:
}



void xg_rtc_init(void)
{
8000318c:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
8000318e:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80003190:	30 0a       	mov	r10,0
80003192:	32 8b       	mov	r11,40
80003194:	49 5c       	lddpc	r12,800031e8 <xg_rtc_init+0x5c>
80003196:	f0 1f 00 16 	mcall	800031ec <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
8000319a:	30 ea       	mov	r10,14
8000319c:	30 1b       	mov	r11,1
8000319e:	fe 7c 0d 00 	mov	r12,-62208
800031a2:	f0 1f 00 14 	mcall	800031f0 <xg_rtc_init+0x64>
800031a6:	c0 41       	brne	800031ae <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
800031a8:	49 3c       	lddpc	r12,800031f4 <xg_rtc_init+0x68>
800031aa:	f0 1f 00 14 	mcall	800031f8 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
800031ae:	30 0b       	mov	r11,0
800031b0:	fe 7c 0d 00 	mov	r12,-62208
800031b4:	f0 1f 00 12 	mcall	800031fc <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
800031b8:	fe 7c 0d 00 	mov	r12,-62208
800031bc:	f0 1f 00 11 	mcall	80003200 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
800031c0:	fe 7c 0d 00 	mov	r12,-62208
800031c4:	f0 1f 00 10 	mcall	80003204 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
800031c8:	49 08       	lddpc	r8,80003208 <xg_rtc_init+0x7c>
800031ca:	31 09       	mov	r9,16
800031cc:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
800031ce:	30 29       	mov	r9,2
800031d0:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
800031d2:	31 d9       	mov	r9,29
800031d4:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
800031d6:	31 79       	mov	r9,23
800031d8:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
800031da:	33 b9       	mov	r9,59
800031dc:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
800031de:	32 89       	mov	r9,40
800031e0:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
800031e2:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
800031e4:	d8 02       	popm	pc
800031e6:	00 00       	add	r0,r0
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	32 0c       	mov	r12,32
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	47 60       	lddsp	r0,sp[0x1d8]
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	4a ac       	lddpc	r12,80003298 <rtc_irq+0x8c>
800031f4:	80 00       	ld.sh	r0,r0[0x0]
800031f6:	ca 54       	brge	80003140 <data_flash_init+0xe0>
800031f8:	80 00       	ld.sh	r0,r0[0x0]
800031fa:	62 70       	ld.w	r0,r1[0x1c]
800031fc:	80 00       	ld.sh	r0,r0[0x0]
800031fe:	4a 68       	lddpc	r8,80003294 <rtc_irq+0x88>
80003200:	80 00       	ld.sh	r0,r0[0x0]
80003202:	4a 60       	lddpc	r0,80003298 <rtc_irq+0x8c>
80003204:	80 00       	ld.sh	r0,r0[0x0]
80003206:	4a 3c       	lddpc	r12,80003290 <rtc_irq+0x84>
80003208:	00 00       	add	r0,r0
8000320a:	0c fc       	st.b	--r6,r12

8000320c <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
8000320c:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
8000320e:	4b 98       	lddpc	r8,800032f0 <rtc_irq+0xe4>
80003210:	11 d9       	ld.ub	r9,r8[0x5]
80003212:	2f f9       	sub	r9,-1
80003214:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80003216:	11 d9       	ld.ub	r9,r8[0x5]
80003218:	33 b8       	mov	r8,59
8000321a:	f0 09 18 00 	cp.b	r9,r8
8000321e:	e0 88 00 5f 	brls	800032dc <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80003222:	4b 48       	lddpc	r8,800032f0 <rtc_irq+0xe4>
80003224:	30 09       	mov	r9,0
80003226:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80003228:	11 c9       	ld.ub	r9,r8[0x4]
8000322a:	2f f9       	sub	r9,-1
8000322c:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
8000322e:	11 c9       	ld.ub	r9,r8[0x4]
80003230:	33 b8       	mov	r8,59
80003232:	f0 09 18 00 	cp.b	r9,r8
80003236:	e0 88 00 53 	brls	800032dc <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
8000323a:	4a e8       	lddpc	r8,800032f0 <rtc_irq+0xe4>
8000323c:	30 09       	mov	r9,0
8000323e:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80003240:	11 b9       	ld.ub	r9,r8[0x3]
80003242:	2f f9       	sub	r9,-1
80003244:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80003246:	11 b9       	ld.ub	r9,r8[0x3]
80003248:	31 78       	mov	r8,23
8000324a:	f0 09 18 00 	cp.b	r9,r8
8000324e:	e0 88 00 47 	brls	800032dc <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80003252:	4a 88       	lddpc	r8,800032f0 <rtc_irq+0xe4>
80003254:	30 09       	mov	r9,0
80003256:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003258:	11 88       	ld.ub	r8,r8[0x0]
8000325a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000325e:	e0 69 01 6e 	mov	r9,366
80003262:	e0 6a 01 6d 	mov	r10,365
80003266:	f4 08 17 10 	movne	r8,r10
8000326a:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
8000326e:	4a 19       	lddpc	r9,800032f0 <rtc_irq+0xe4>
80003270:	13 9a       	ld.ub	r10,r9[0x1]
80003272:	30 29       	mov	r9,2
80003274:	f2 0a 18 00 	cp.b	r10,r9
80003278:	c0 b0       	breq	8000328e <rtc_irq+0x82>
8000327a:	49 e8       	lddpc	r8,800032f0 <rtc_irq+0xe4>
8000327c:	11 99       	ld.ub	r9,r8[0x1]
8000327e:	11 9a       	ld.ub	r10,r8[0x1]
80003280:	a3 9a       	lsr	r10,0x3
80003282:	12 0a       	add	r10,r9
80003284:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003288:	2e 2a       	sub	r10,-30
8000328a:	5c 5a       	castu.b	r10
8000328c:	c0 58       	rjmp	80003296 <rtc_irq+0x8a>
8000328e:	f0 c8 01 51 	sub	r8,r8,337
80003292:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80003296:	49 78       	lddpc	r8,800032f0 <rtc_irq+0xe4>
80003298:	11 a9       	ld.ub	r9,r8[0x2]
8000329a:	2f f9       	sub	r9,-1
8000329c:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
8000329e:	11 a8       	ld.ub	r8,r8[0x2]
800032a0:	f0 0a 18 00 	cp.b	r10,r8
800032a4:	c1 c2       	brcc	800032dc <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
800032a6:	49 38       	lddpc	r8,800032f0 <rtc_irq+0xe4>
800032a8:	30 19       	mov	r9,1
800032aa:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
800032ac:	11 99       	ld.ub	r9,r8[0x1]
800032ae:	2f f9       	sub	r9,-1
800032b0:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
800032b2:	11 99       	ld.ub	r9,r8[0x1]
800032b4:	30 c8       	mov	r8,12
800032b6:	f0 09 18 00 	cp.b	r9,r8
800032ba:	e0 88 00 11 	brls	800032dc <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
800032be:	48 d8       	lddpc	r8,800032f0 <rtc_irq+0xe4>
800032c0:	30 19       	mov	r9,1
800032c2:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
800032c4:	11 89       	ld.ub	r9,r8[0x0]
800032c6:	2f f9       	sub	r9,-1
800032c8:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
800032ca:	11 89       	ld.ub	r9,r8[0x0]
800032cc:	39 68       	mov	r8,-106
800032ce:	f0 09 18 00 	cp.b	r9,r8
800032d2:	e0 88 00 05 	brls	800032dc <rtc_irq+0xd0>
800032d6:	30 09       	mov	r9,0
800032d8:	48 68       	lddpc	r8,800032f0 <rtc_irq+0xe4>
800032da:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
800032dc:	fe 7c 0d 00 	mov	r12,-62208
800032e0:	f0 1f 00 05 	mcall	800032f4 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
800032e4:	30 19       	mov	r9,1
800032e6:	48 58       	lddpc	r8,800032f8 <rtc_irq+0xec>
800032e8:	91 09       	st.w	r8[0x0],r9
}
800032ea:	d4 02       	popm	lr
800032ec:	d6 03       	rete
800032ee:	00 00       	add	r0,r0
800032f0:	00 00       	add	r0,r0
800032f2:	0c fc       	st.b	--r6,r12
800032f4:	80 00       	ld.sh	r0,r0[0x0]
800032f6:	4a 8c       	lddpc	r12,80003394 <xcmp_tx+0x30>
800032f8:	00 00       	add	r0,r0
800032fa:	04 f8       	st.b	--r2,r8

800032fc <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
800032fc:	48 38       	lddpc	r8,80003308 <payload_init+0xc>
800032fe:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80003300:	48 38       	lddpc	r8,8000330c <payload_init+0x10>
80003302:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80003304:	5e fc       	retal	r12
80003306:	00 00       	add	r0,r0
80003308:	00 00       	add	r0,r0
8000330a:	0a 40       	or	r0,r5
8000330c:	00 00       	add	r0,r0
8000330e:	0a 44       	or	r4,r5

80003310 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003310:	eb cd 40 80 	pushm	r7,lr
80003314:	20 1d       	sub	sp,4
80003316:	fa c7 ff fc 	sub	r7,sp,-4
8000331a:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
8000331c:	30 09       	mov	r9,0
8000331e:	12 9a       	mov	r10,r9
80003320:	1a 9b       	mov	r11,sp
80003322:	f0 1f 00 03 	mcall	8000332c <set_idle_store+0x1c>
}
80003326:	2f fd       	sub	sp,-4
80003328:	e3 cd 80 80 	ldm	sp++,r7,pc
8000332c:	80 00       	ld.sh	r0,r0[0x0]
8000332e:	56 20       	stdsp	sp[0x188],r0

80003330 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003330:	d4 01       	pushm	lr
80003332:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003334:	30 0a       	mov	r10,0
80003336:	fa cb ff fc 	sub	r11,sp,-4
8000333a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
8000333c:	14 99       	mov	r9,r10
8000333e:	1a 9b       	mov	r11,sp
80003340:	f0 1f 00 05 	mcall	80003354 <get_idle_store+0x24>
80003344:	58 1c       	cp.w	r12,1
80003346:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000334a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000334e:	2f fd       	sub	sp,-4
80003350:	d8 02       	popm	pc
80003352:	00 00       	add	r0,r0
80003354:	80 00       	ld.sh	r0,r0[0x0]
80003356:	54 64       	stdsp	sp[0x118],r4

80003358 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003358:	48 28       	lddpc	r8,80003360 <xcmp_register_app_list+0x8>
8000335a:	91 0c       	st.w	r8[0x0],r12
}
8000335c:	5e fc       	retal	r12
8000335e:	00 00       	add	r0,r0
80003360:	00 00       	add	r0,r0
80003362:	1d 08       	ld.w	r8,lr++

80003364 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003364:	eb cd 40 80 	pushm	r7,lr
80003368:	fa cd 01 00 	sub	sp,sp,256
8000336c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000336e:	16 98       	mov	r8,r11
80003370:	2f 08       	sub	r8,-16
80003372:	af a8       	sbr	r8,0xe
80003374:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003376:	3f f8       	mov	r8,-1
80003378:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000337a:	30 b9       	mov	r9,11
8000337c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000337e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003380:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003382:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003384:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003386:	f6 ca ff fe 	sub	r10,r11,-2
8000338a:	18 9b       	mov	r11,r12
8000338c:	fa cc ff f0 	sub	r12,sp,-16
80003390:	f0 1f 00 05 	mcall	800033a4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003394:	2f e7       	sub	r7,-2
80003396:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003398:	1a 9c       	mov	r12,sp
8000339a:	f0 1f 00 04 	mcall	800033a8 <xcmp_tx+0x44>
}
8000339e:	2c 0d       	sub	sp,-256
800033a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800033a4:	80 00       	ld.sh	r0,r0[0x0]
800033a6:	69 92       	ld.w	r2,r4[0x64]
800033a8:	80 00       	ld.sh	r0,r0[0x0]
800033aa:	34 d8       	mov	r8,77

800033ac <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
800033ac:	d4 21       	pushm	r4-r7,lr
800033ae:	fa cd 00 d0 	sub	sp,sp,208
800033b2:	18 94       	mov	r4,r12
800033b4:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
800033b6:	e0 68 01 00 	mov	r8,256
800033ba:	f0 0b 19 00 	cp.h	r11,r8
800033be:	e0 8b 00 36 	brhi	8000342a <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
800033c2:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
800033c6:	e0 68 04 1d 	mov	r8,1053
800033ca:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
800033cc:	30 18       	mov	r8,1
800033ce:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
800033d0:	32 08       	mov	r8,32
800033d2:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
800033d4:	30 28       	mov	r8,2
800033d6:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
800033d8:	30 48       	mov	r8,4
800033da:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
800033dc:	ea 1a 0c 00 	orh	r10,0xc00
800033e0:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
800033e2:	30 4a       	mov	r10,4
800033e4:	1a 9b       	mov	r11,sp
800033e6:	fa cc ff f4 	sub	r12,sp,-12
800033ea:	f0 1f 00 12 	mcall	80003430 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
800033ee:	30 f8       	mov	r8,15
800033f0:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800033f4:	3a 78       	mov	r8,-89
800033f6:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800033fa:	30 08       	mov	r8,0
800033fc:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003400:	0e 9a       	mov	r10,r7
80003402:	5c 7a       	castu.h	r10
80003404:	f4 08 16 08 	lsr	r8,r10,0x8
80003408:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
8000340c:	0e 96       	mov	r6,r7
8000340e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003412:	08 9b       	mov	r11,r4
80003414:	fa cc ff eb 	sub	r12,sp,-21
80003418:	f0 1f 00 06 	mcall	80003430 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
8000341c:	ee cb ff f3 	sub	r11,r7,-13
80003420:	5c 5b       	castu.b	r11
80003422:	fa cc ff fa 	sub	r12,sp,-6
80003426:	f0 1f 00 04 	mcall	80003434 <xcmp_data_session_req+0x88>
}
8000342a:	2c cd       	sub	sp,-208
8000342c:	d8 22       	popm	r4-r7,pc
8000342e:	00 00       	add	r0,r0
80003430:	80 00       	ld.sh	r0,r0[0x0]
80003432:	69 92       	ld.w	r2,r4[0x64]
80003434:	80 00       	ld.sh	r0,r0[0x0]
80003436:	33 64       	mov	r4,54

80003438 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003438:	d4 01       	pushm	lr
8000343a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000343e:	fe 78 b4 00 	mov	r8,-19456
80003442:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003444:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003448:	30 89       	mov	r9,8
8000344a:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
8000344c:	30 19       	mov	r9,1
8000344e:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003450:	30 09       	mov	r9,0
80003452:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003454:	30 5a       	mov	r10,5
80003456:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003458:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000345a:	30 7a       	mov	r10,7
8000345c:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000345e:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003460:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003462:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003466:	30 9b       	mov	r11,9
80003468:	fa cc ff fe 	sub	r12,sp,-2
8000346c:	f0 1f 00 02 	mcall	80003474 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003470:	2c dd       	sub	sp,-204
80003472:	d8 02       	popm	pc
80003474:	80 00       	ld.sh	r0,r0[0x0]
80003476:	33 64       	mov	r4,54

80003478 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003478:	d4 01       	pushm	lr
8000347a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000347e:	e0 68 04 09 	mov	r8,1033
80003482:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003484:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003488:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000348a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000348e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003490:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003492:	30 09       	mov	r9,0
80003494:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003496:	fb 69 00 08 	st.b	sp[8],r9
8000349a:	fa c8 ff f7 	sub	r8,sp,-9
8000349e:	b0 89       	st.b	r8[0x0],r9
800034a0:	fa c8 ff f6 	sub	r8,sp,-10
800034a4:	b0 89       	st.b	r8[0x0],r9
800034a6:	fa c8 ff f5 	sub	r8,sp,-11
800034aa:	b0 89       	st.b	r8[0x0],r9
800034ac:	fa c8 ff f4 	sub	r8,sp,-12
800034b0:	b0 89       	st.b	r8[0x0],r9
800034b2:	fa c8 ff f3 	sub	r8,sp,-13
800034b6:	b0 89       	st.b	r8[0x0],r9
800034b8:	fa c8 ff f2 	sub	r8,sp,-14
800034bc:	b0 89       	st.b	r8[0x0],r9
800034be:	fa c8 ff f1 	sub	r8,sp,-15
800034c2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800034c4:	30 cb       	mov	r11,12
800034c6:	fa cc ff fe 	sub	r12,sp,-2
800034ca:	f0 1f 00 03 	mcall	800034d4 <xcmp_IdleTestTone+0x5c>
}
800034ce:	2c dd       	sub	sp,-204
800034d0:	d8 02       	popm	pc
800034d2:	00 00       	add	r0,r0
800034d4:	80 00       	ld.sh	r0,r0[0x0]
800034d6:	33 64       	mov	r4,54

800034d8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800034d8:	eb cd 40 c0 	pushm	r6-r7,lr
800034dc:	20 1d       	sub	sp,4
800034de:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800034e0:	98 39       	ld.sh	r9,r12[0x6]
800034e2:	3f f8       	mov	r8,-1
800034e4:	f0 09 19 00 	cp.h	r9,r8
800034e8:	c0 a1       	brne	800034fc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800034ea:	4a e9       	lddpc	r9,800035a0 <xnl_tx+0xc8>
800034ec:	13 88       	ld.ub	r8,r9[0x0]
800034ee:	2f f8       	sub	r8,-1
800034f0:	5c 58       	castu.b	r8
800034f2:	b2 88       	st.b	r9[0x0],r8
800034f4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800034f8:	a9 a8       	sbr	r8,0x8
800034fa:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800034fc:	8c 49       	ld.sh	r9,r6[0x8]
800034fe:	3f f8       	mov	r8,-1
80003500:	f0 09 19 00 	cp.h	r9,r8
80003504:	c0 41       	brne	8000350c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80003506:	4a 88       	lddpc	r8,800035a4 <xnl_tx+0xcc>
80003508:	90 18       	ld.sh	r8,r8[0x2]
8000350a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000350c:	8c 59       	ld.sh	r9,r6[0xa]
8000350e:	3f f8       	mov	r8,-1
80003510:	f0 09 19 00 	cp.h	r9,r8
80003514:	c0 41       	brne	8000351c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80003516:	4a 48       	lddpc	r8,800035a4 <xnl_tx+0xcc>
80003518:	90 28       	ld.sh	r8,r8[0x4]
8000351a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000351c:	8c 69       	ld.sh	r9,r6[0xc]
8000351e:	3f f8       	mov	r8,-1
80003520:	f0 09 19 00 	cp.h	r9,r8
80003524:	c0 e1       	brne	80003540 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80003526:	4a 08       	lddpc	r8,800035a4 <xnl_tx+0xcc>
80003528:	90 49       	ld.sh	r9,r8[0x8]
8000352a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000352c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000352e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80003530:	90 49       	ld.sh	r9,r8[0x8]
80003532:	e0 19 ff 00 	andl	r9,0xff00
80003536:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000353a:	f3 e8 10 08 	or	r8,r9,r8
8000353e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80003540:	0d 98       	ld.ub	r8,r6[0x1]
80003542:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80003544:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80003548:	10 0c       	add	r12,r8
8000354a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000354c:	58 0c       	cp.w	r12,0
8000354e:	e0 89 00 04 	brgt	80003556 <xnl_tx+0x7e>
80003552:	30 09       	mov	r9,0
80003554:	c0 d8       	rjmp	8000356e <xnl_tx+0x96>
80003556:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000355a:	2f ec       	sub	r12,-2
8000355c:	30 09       	mov	r9,0
8000355e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80003560:	15 1b       	ld.sh	r11,r10++
80003562:	f6 09 00 09 	add	r9,r11,r9
80003566:	5c 89       	casts.h	r9
		indextohWord     += 1;
80003568:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000356a:	18 38       	cp.w	r8,r12
8000356c:	cf a1       	brne	80003560 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000356e:	5c 39       	neg	r9
80003570:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003572:	48 e8       	lddpc	r8,800035a8 <xnl_tx+0xd0>
80003574:	70 0c       	ld.w	r12,r8[0x0]
80003576:	f0 1f 00 0e 	mcall	800035ac <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000357a:	c1 00       	breq	8000359a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000357c:	fa c7 ff fc 	sub	r7,sp,-4
80003580:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80003582:	e0 6a 01 00 	mov	r10,256
80003586:	0c 9b       	mov	r11,r6
80003588:	f0 1f 00 0a 	mcall	800035b0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000358c:	48 a8       	lddpc	r8,800035b4 <xnl_tx+0xdc>
8000358e:	70 0c       	ld.w	r12,r8[0x0]
80003590:	30 09       	mov	r9,0
80003592:	12 9a       	mov	r10,r9
80003594:	1a 9b       	mov	r11,sp
80003596:	f0 1f 00 09 	mcall	800035b8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000359a:	2f fd       	sub	sp,-4
8000359c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800035a0:	00 00       	add	r0,r0
800035a2:	0a 4c       	or	r12,r5
800035a4:	00 00       	add	r0,r0
800035a6:	0a 4e       	or	lr,r5
800035a8:	00 00       	add	r0,r0
800035aa:	0a 48       	or	r8,r5
800035ac:	80 00       	ld.sh	r0,r0[0x0]
800035ae:	33 30       	mov	r0,51
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	69 92       	ld.w	r2,r4[0x64]
800035b4:	00 00       	add	r0,r0
800035b6:	0a 58       	eor	r8,r5
800035b8:	80 00       	ld.sh	r0,r0[0x0]
800035ba:	56 20       	stdsp	sp[0x188],r0

800035bc <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800035bc:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800035be:	48 78       	lddpc	r8,800035d8 <RC522_SPI_SetSpeed+0x1c>
800035c0:	70 09       	ld.w	r9,r8[0x0]
800035c2:	72 ca       	ld.w	r10,r9[0x30]
800035c4:	5c 7c       	castu.h	r12
800035c6:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800035ca:	f9 ea 10 0a 	or	r10,r12,r10
800035ce:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800035d0:	70 0c       	ld.w	r12,r8[0x0]
800035d2:	f0 1f 00 03 	mcall	800035dc <RC522_SPI_SetSpeed+0x20>
		
	
}
800035d6:	d8 02       	popm	pc
800035d8:	00 00       	add	r0,r0
800035da:	1d 04       	ld.w	r4,lr++
800035dc:	80 00       	ld.sh	r0,r0[0x0]
800035de:	4b b0       	lddpc	r0,800036c8 <PcdReset+0x3c>

800035e0 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800035e0:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
800035e2:	e0 6c 0a 00 	mov	r12,2560
800035e6:	f0 1f 00 02 	mcall	800035ec <RC522_SPI_SetSpeedLow+0xc>
	
}
800035ea:	d8 02       	popm	pc
800035ec:	80 00       	ld.sh	r0,r0[0x0]
800035ee:	35 bc       	mov	r12,91

800035f0 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800035f0:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800035f4:	48 76       	lddpc	r6,80003610 <RC522_ReadByte+0x20>
800035f6:	e0 6b 00 ff 	mov	r11,255
800035fa:	6c 0c       	ld.w	r12,r6[0x0]
800035fc:	f0 1f 00 06 	mcall	80003614 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80003600:	30 07       	mov	r7,0
80003602:	0e 9b       	mov	r11,r7
80003604:	6c 0c       	ld.w	r12,r6[0x0]
80003606:	f0 1f 00 05 	mcall	80003618 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
8000360a:	0f 9c       	ld.ub	r12,r7[0x1]
8000360c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003610:	00 00       	add	r0,r0
80003612:	1d 04       	ld.w	r4,lr++
80003614:	80 00       	ld.sh	r0,r0[0x0]
80003616:	4b b6       	lddpc	r6,80003700 <PcdReset+0x74>
80003618:	80 00       	ld.sh	r0,r0[0x0]
8000361a:	4b d2       	lddpc	r2,8000370c <ReadRawRC>

8000361c <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
8000361c:	eb cd 40 80 	pushm	r7,lr
80003620:	20 1d       	sub	sp,4
80003622:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80003624:	48 77       	lddpc	r7,80003640 <RC522_WriteByte+0x24>
80003626:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
8000362a:	6e 0c       	ld.w	r12,r7[0x0]
8000362c:	f0 1f 00 06 	mcall	80003644 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80003630:	1a 9b       	mov	r11,sp
80003632:	6e 0c       	ld.w	r12,r7[0x0]
80003634:	f0 1f 00 05 	mcall	80003648 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80003638:	5c 5c       	castu.b	r12
8000363a:	2f fd       	sub	sp,-4
8000363c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003640:	00 00       	add	r0,r0
80003642:	1d 04       	ld.w	r4,lr++
80003644:	80 00       	ld.sh	r0,r0[0x0]
80003646:	4b b6       	lddpc	r6,80003730 <ReadRawRC+0x24>
80003648:	80 00       	ld.sh	r0,r0[0x0]
8000364a:	4b d2       	lddpc	r2,8000373c <ReadRawRC+0x30>

8000364c <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
8000364c:	eb cd 40 e0 	pushm	r5-r7,lr
80003650:	18 96       	mov	r6,r12
80003652:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80003654:	48 a7       	lddpc	r7,8000367c <WriteRawRC+0x30>
80003656:	30 0b       	mov	r11,0
80003658:	6e 0c       	ld.w	r12,r7[0x0]
8000365a:	f0 1f 00 0a 	mcall	80003680 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000365e:	ec 0c 15 01 	lsl	r12,r6,0x1
80003662:	e2 1c 00 7e 	andl	r12,0x7e,COH
80003666:	f0 1f 00 08 	mcall	80003684 <WriteRawRC+0x38>
	RC522_WriteByte(value);
8000366a:	0a 9c       	mov	r12,r5
8000366c:	f0 1f 00 06 	mcall	80003684 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80003670:	30 0b       	mov	r11,0
80003672:	6e 0c       	ld.w	r12,r7[0x0]
80003674:	f0 1f 00 05 	mcall	80003688 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80003678:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000367c:	00 00       	add	r0,r0
8000367e:	1d 04       	ld.w	r4,lr++
80003680:	80 00       	ld.sh	r0,r0[0x0]
80003682:	4d 1c       	lddpc	r12,800037c4 <SetBitMask+0x14>
80003684:	80 00       	ld.sh	r0,r0[0x0]
80003686:	36 1c       	mov	r12,97
80003688:	80 00       	ld.sh	r0,r0[0x0]
8000368a:	4c dc       	lddpc	r12,800037bc <SetBitMask+0xc>

8000368c <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
8000368c:	d4 01       	pushm	lr

	SET_RC522RST;
8000368e:	31 9c       	mov	r12,25
80003690:	f0 1f 00 1b 	mcall	800036fc <PcdReset+0x70>
	delay_ns(10);
80003694:	30 ac       	mov	r12,10
80003696:	f0 1f 00 1b 	mcall	80003700 <PcdReset+0x74>

	CLR_RC522RST;
8000369a:	31 9c       	mov	r12,25
8000369c:	f0 1f 00 1a 	mcall	80003704 <PcdReset+0x78>
	delay_ns(10);
800036a0:	30 ac       	mov	r12,10
800036a2:	f0 1f 00 18 	mcall	80003700 <PcdReset+0x74>

	SET_RC522RST;
800036a6:	31 9c       	mov	r12,25
800036a8:	f0 1f 00 15 	mcall	800036fc <PcdReset+0x70>
	delay_ns(10);
800036ac:	30 ac       	mov	r12,10
800036ae:	f0 1f 00 15 	mcall	80003700 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800036b2:	30 fb       	mov	r11,15
800036b4:	30 1c       	mov	r12,1
800036b6:	f0 1f 00 15 	mcall	80003708 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800036ba:	30 fb       	mov	r11,15
800036bc:	30 1c       	mov	r12,1
800036be:	f0 1f 00 13 	mcall	80003708 <PcdReset+0x7c>
	delay_ns(10);
800036c2:	30 ac       	mov	r12,10
800036c4:	f0 1f 00 0f 	mcall	80003700 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800036c8:	33 db       	mov	r11,61
800036ca:	31 1c       	mov	r12,17
800036cc:	f0 1f 00 0f 	mcall	80003708 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800036d0:	31 eb       	mov	r11,30
800036d2:	32 dc       	mov	r12,45
800036d4:	f0 1f 00 0d 	mcall	80003708 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800036d8:	30 0b       	mov	r11,0
800036da:	32 cc       	mov	r12,44
800036dc:	f0 1f 00 0b 	mcall	80003708 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800036e0:	e0 6b 00 8d 	mov	r11,141
800036e4:	32 ac       	mov	r12,42
800036e6:	f0 1f 00 09 	mcall	80003708 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800036ea:	33 eb       	mov	r11,62
800036ec:	32 bc       	mov	r12,43
800036ee:	f0 1f 00 07 	mcall	80003708 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800036f2:	34 0b       	mov	r11,64
800036f4:	31 5c       	mov	r12,21
800036f6:	f0 1f 00 05 	mcall	80003708 <PcdReset+0x7c>
	
	return MI_OK;
}
800036fa:	d8 0a       	popm	pc,r12=0
800036fc:	80 00       	ld.sh	r0,r0[0x0]
800036fe:	47 24       	lddsp	r4,sp[0x1c8]
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	3f c8       	mov	r8,-4
80003704:	80 00       	ld.sh	r0,r0[0x0]
80003706:	47 40       	lddsp	r0,sp[0x1d0]
80003708:	80 00       	ld.sh	r0,r0[0x0]
8000370a:	36 4c       	mov	r12,100

8000370c <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
8000370c:	eb cd 40 c0 	pushm	r6-r7,lr
80003710:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80003712:	48 c7       	lddpc	r7,80003740 <ReadRawRC+0x34>
80003714:	30 0b       	mov	r11,0
80003716:	6e 0c       	ld.w	r12,r7[0x0]
80003718:	f0 1f 00 0b 	mcall	80003744 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
8000371c:	a1 76       	lsl	r6,0x1
8000371e:	0c 9c       	mov	r12,r6
80003720:	e2 1c 00 7e 	andl	r12,0x7e,COH
80003724:	a7 bc       	sbr	r12,0x7
80003726:	f0 1f 00 09 	mcall	80003748 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
8000372a:	f0 1f 00 09 	mcall	8000374c <ReadRawRC+0x40>
8000372e:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80003730:	30 0b       	mov	r11,0
80003732:	6e 0c       	ld.w	r12,r7[0x0]
80003734:	f0 1f 00 07 	mcall	80003750 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80003738:	0c 9c       	mov	r12,r6
8000373a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000373e:	00 00       	add	r0,r0
80003740:	00 00       	add	r0,r0
80003742:	1d 04       	ld.w	r4,lr++
80003744:	80 00       	ld.sh	r0,r0[0x0]
80003746:	4d 1c       	lddpc	r12,80003888 <M500PcdConfigISOType+0x5c>
80003748:	80 00       	ld.sh	r0,r0[0x0]
8000374a:	36 1c       	mov	r12,97
8000374c:	80 00       	ld.sh	r0,r0[0x0]
8000374e:	35 f0       	mov	r0,95
80003750:	80 00       	ld.sh	r0,r0[0x0]
80003752:	4c dc       	lddpc	r12,80003884 <M500PcdConfigISOType+0x58>

80003754 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80003754:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80003756:	30 1c       	mov	r12,1
80003758:	f0 1f 00 02 	mcall	80003760 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
8000375c:	d8 02       	popm	pc
8000375e:	00 00       	add	r0,r0
80003760:	80 00       	ld.sh	r0,r0[0x0]
80003762:	37 0c       	mov	r12,112

80003764 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80003764:	eb cd 40 80 	pushm	r7,lr
80003768:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
8000376a:	30 1c       	mov	r12,1
8000376c:	f0 1f 00 0d 	mcall	800037a0 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80003770:	30 18       	mov	r8,1
80003772:	f0 07 18 00 	cp.b	r7,r8
80003776:	c0 91       	brne	80003788 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80003778:	18 9b       	mov	r11,r12
8000377a:	a5 ab       	sbr	r11,0x4
8000377c:	5c 5b       	castu.b	r11
8000377e:	30 1c       	mov	r12,1
80003780:	f0 1f 00 09 	mcall	800037a4 <Powerdown_RC522+0x40>
80003784:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80003788:	18 9b       	mov	r11,r12
8000378a:	30 1c       	mov	r12,1
8000378c:	f0 1f 00 06 	mcall	800037a4 <Powerdown_RC522+0x40>
		delay_ns(2);
80003790:	30 2c       	mov	r12,2
80003792:	f0 1f 00 06 	mcall	800037a8 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80003796:	f0 1f 00 06 	mcall	800037ac <Powerdown_RC522+0x48>
8000379a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000379e:	00 00       	add	r0,r0
800037a0:	80 00       	ld.sh	r0,r0[0x0]
800037a2:	37 0c       	mov	r12,112
800037a4:	80 00       	ld.sh	r0,r0[0x0]
800037a6:	36 4c       	mov	r12,100
800037a8:	80 00       	ld.sh	r0,r0[0x0]
800037aa:	3f c8       	mov	r8,-4
800037ac:	80 00       	ld.sh	r0,r0[0x0]
800037ae:	37 54       	mov	r4,117

800037b0 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800037b0:	eb cd 40 c0 	pushm	r6-r7,lr
800037b4:	18 97       	mov	r7,r12
800037b6:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800037b8:	f0 1f 00 05 	mcall	800037cc <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800037bc:	f9 e6 10 0b 	or	r11,r12,r6
800037c0:	5c 5b       	castu.b	r11
800037c2:	0e 9c       	mov	r12,r7
800037c4:	f0 1f 00 03 	mcall	800037d0 <SetBitMask+0x20>
}
800037c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800037cc:	80 00       	ld.sh	r0,r0[0x0]
800037ce:	37 0c       	mov	r12,112
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	36 4c       	mov	r12,100

800037d4 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
800037d4:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
800037d6:	31 4c       	mov	r12,20
800037d8:	f0 1f 00 05 	mcall	800037ec <PcdAntennaOn+0x18>
	if (!(i & 0x03))
800037dc:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800037e0:	c0 51       	brne	800037ea <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
800037e2:	30 3b       	mov	r11,3
800037e4:	31 4c       	mov	r12,20
800037e6:	f0 1f 00 03 	mcall	800037f0 <PcdAntennaOn+0x1c>
800037ea:	d8 02       	popm	pc
800037ec:	80 00       	ld.sh	r0,r0[0x0]
800037ee:	37 0c       	mov	r12,112
800037f0:	80 00       	ld.sh	r0,r0[0x0]
800037f2:	37 b0       	mov	r0,123

800037f4 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800037f4:	eb cd 40 c0 	pushm	r6-r7,lr
800037f8:	18 97       	mov	r7,r12
800037fa:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800037fc:	f0 1f 00 06 	mcall	80003814 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80003800:	5c d6       	com	r6
80003802:	f9 e6 00 06 	and	r6,r12,r6
80003806:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
8000380a:	0e 9c       	mov	r12,r7
8000380c:	f0 1f 00 03 	mcall	80003818 <ClearBitMask+0x24>
	
}
80003810:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003814:	80 00       	ld.sh	r0,r0[0x0]
80003816:	37 0c       	mov	r12,112
80003818:	80 00       	ld.sh	r0,r0[0x0]
8000381a:	36 4c       	mov	r12,100

8000381c <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
8000381c:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000381e:	30 3b       	mov	r11,3
80003820:	31 4c       	mov	r12,20
80003822:	f0 1f 00 02 	mcall	80003828 <PcdAntennaOff+0xc>
}
80003826:	d8 02       	popm	pc
80003828:	80 00       	ld.sh	r0,r0[0x0]
8000382a:	37 f4       	mov	r4,127

8000382c <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
8000382c:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000382e:	34 18       	mov	r8,65
80003830:	f0 0c 18 00 	cp.b	r12,r8
80003834:	c0 20       	breq	80003838 <M500PcdConfigISOType+0xc>
80003836:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80003838:	30 8b       	mov	r11,8
8000383a:	16 9c       	mov	r12,r11
8000383c:	f0 1f 00 14 	mcall	8000388c <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80003840:	33 db       	mov	r11,61
80003842:	31 1c       	mov	r12,17
80003844:	f0 1f 00 13 	mcall	80003890 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80003848:	e0 6b 00 86 	mov	r11,134
8000384c:	31 7c       	mov	r12,23
8000384e:	f0 1f 00 11 	mcall	80003890 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80003852:	37 fb       	mov	r11,127
80003854:	32 6c       	mov	r12,38
80003856:	f0 1f 00 0f 	mcall	80003890 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
8000385a:	31 eb       	mov	r11,30
8000385c:	32 dc       	mov	r12,45
8000385e:	f0 1f 00 0d 	mcall	80003890 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80003862:	30 0b       	mov	r11,0
80003864:	32 cc       	mov	r12,44
80003866:	f0 1f 00 0b 	mcall	80003890 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
8000386a:	e0 6b 00 8d 	mov	r11,141
8000386e:	32 ac       	mov	r12,42
80003870:	f0 1f 00 08 	mcall	80003890 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80003874:	33 eb       	mov	r11,62
80003876:	32 bc       	mov	r12,43
80003878:	f0 1f 00 06 	mcall	80003890 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
8000387c:	e0 6c 03 e8 	mov	r12,1000
80003880:	f0 1f 00 05 	mcall	80003894 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80003884:	f0 1f 00 05 	mcall	80003898 <M500PcdConfigISOType+0x6c>
80003888:	d8 0a       	popm	pc,r12=0
8000388a:	00 00       	add	r0,r0
8000388c:	80 00       	ld.sh	r0,r0[0x0]
8000388e:	37 f4       	mov	r4,127
80003890:	80 00       	ld.sh	r0,r0[0x0]
80003892:	36 4c       	mov	r12,100
80003894:	80 00       	ld.sh	r0,r0[0x0]
80003896:	3f c8       	mov	r8,-4
80003898:	80 00       	ld.sh	r0,r0[0x0]
8000389a:	37 d4       	mov	r4,125

8000389c <rc522_init>:


//mfrc522 init

void rc522_init()
{
8000389c:	eb cd 40 80 	pushm	r7,lr
800038a0:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800038a2:	49 d8       	lddpc	r8,80003914 <rc522_init+0x78>
800038a4:	1a 97       	mov	r7,sp
800038a6:	f0 ea 00 00 	ld.d	r10,r8[0]
800038aa:	fa eb 00 00 	st.d	sp[0],r10
800038ae:	f0 e8 00 08 	ld.d	r8,r8[8]
800038b2:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
800038b6:	30 1b       	mov	r11,1
800038b8:	49 8c       	lddpc	r12,80003918 <rc522_init+0x7c>
800038ba:	f0 1f 00 19 	mcall	8000391c <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
800038be:	31 9c       	mov	r12,25
800038c0:	f0 1f 00 18 	mcall	80003920 <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
800038c4:	31 9c       	mov	r12,25
800038c6:	f0 1f 00 18 	mcall	80003924 <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
800038ca:	fe 7c 24 00 	mov	r12,-56320
800038ce:	49 78       	lddpc	r8,80003928 <rc522_init+0x8c>
800038d0:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800038d2:	e0 6a 36 00 	mov	r10,13824
800038d6:	ea 1a 01 6e 	orh	r10,0x16e
800038da:	1a 9b       	mov	r11,sp
800038dc:	f0 1f 00 14 	mcall	8000392c <rc522_init+0x90>
800038e0:	c0 50       	breq	800038ea <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
800038e2:	30 29       	mov	r9,2
800038e4:	49 38       	lddpc	r8,80003930 <rc522_init+0x94>
800038e6:	b0 89       	st.b	r8[0x0],r9
800038e8:	c0 38       	rjmp	800038ee <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800038ea:	f0 1f 00 13 	mcall	80003934 <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800038ee:	f0 1f 00 13 	mcall	80003938 <rc522_init+0x9c>
	
	PcdAntennaOff();
800038f2:	f0 1f 00 13 	mcall	8000393c <rc522_init+0xa0>
	
	delay_ms(2); 
800038f6:	30 2c       	mov	r12,2
800038f8:	f0 1f 00 12 	mcall	80003940 <rc522_init+0xa4>
	
	PcdAntennaOn();
800038fc:	f0 1f 00 12 	mcall	80003944 <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
80003900:	34 1c       	mov	r12,65
80003902:	f0 1f 00 12 	mcall	80003948 <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80003906:	30 1c       	mov	r12,1
80003908:	f0 1f 00 11 	mcall	8000394c <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

8000390c:	2f cd       	sub	sp,-16
8000390e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003912:	00 00       	add	r0,r0
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	ca 7c       	rcall	80003a64 <PcdComMF522+0x114>
80003918:	80 00       	ld.sh	r0,r0[0x0]
8000391a:	ca 8c       	rcall	80003a6a <PcdComMF522+0x11a>
8000391c:	80 00       	ld.sh	r0,r0[0x0]
8000391e:	46 dc       	lddsp	r12,sp[0x1b4]
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	47 0c       	lddsp	r12,sp[0x1c0]
80003924:	80 00       	ld.sh	r0,r0[0x0]
80003926:	47 24       	lddsp	r4,sp[0x1c8]
80003928:	00 00       	add	r0,r0
8000392a:	1d 04       	ld.w	r4,lr++
8000392c:	80 00       	ld.sh	r0,r0[0x0]
8000392e:	4b f4       	lddpc	r4,80003a28 <PcdComMF522+0xd8>
80003930:	00 00       	add	r0,r0
80003932:	0a 5c       	eor	r12,r5
80003934:	80 00       	ld.sh	r0,r0[0x0]
80003936:	35 e0       	mov	r0,94
80003938:	80 00       	ld.sh	r0,r0[0x0]
8000393a:	36 8c       	mov	r12,104
8000393c:	80 00       	ld.sh	r0,r0[0x0]
8000393e:	38 1c       	mov	r12,-127
80003940:	80 00       	ld.sh	r0,r0[0x0]
80003942:	40 08       	lddsp	r8,sp[0x0]
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	37 d4       	mov	r4,125
80003948:	80 00       	ld.sh	r0,r0[0x0]
8000394a:	38 2c       	mov	r12,-126
8000394c:	80 00       	ld.sh	r0,r0[0x0]
8000394e:	37 64       	mov	r4,118

80003950 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80003950:	d4 31       	pushm	r0-r7,lr
80003952:	20 1d       	sub	sp,4
80003954:	18 92       	mov	r2,r12
80003956:	16 95       	mov	r5,r11
80003958:	14 96       	mov	r6,r10
8000395a:	50 09       	stdsp	sp[0x0],r9
8000395c:	10 90       	mov	r0,r8
8000395e:	f8 c8 00 0c 	sub	r8,r12,12
80003962:	5c 58       	castu.b	r8
80003964:	30 29       	mov	r9,2
80003966:	f2 08 18 00 	cp.b	r8,r9
8000396a:	e0 88 00 05 	brls	80003974 <PcdComMF522+0x24>
8000396e:	30 03       	mov	r3,0
80003970:	06 91       	mov	r1,r3
80003972:	c0 78       	rjmp	80003980 <PcdComMF522+0x30>
80003974:	4c f9       	lddpc	r9,80003ab0 <PcdComMF522+0x160>
80003976:	f2 08 07 01 	ld.ub	r1,r9[r8]
8000397a:	4c f9       	lddpc	r9,80003ab4 <PcdComMF522+0x164>
8000397c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80003980:	02 9b       	mov	r11,r1
80003982:	a7 bb       	sbr	r11,0x7
80003984:	30 2c       	mov	r12,2
80003986:	f0 1f 00 4d 	mcall	80003ab8 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
8000398a:	e0 6b 00 80 	mov	r11,128
8000398e:	30 4c       	mov	r12,4
80003990:	f0 1f 00 4b 	mcall	80003abc <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80003994:	30 0b       	mov	r11,0
80003996:	30 1c       	mov	r12,1
80003998:	f0 1f 00 48 	mcall	80003ab8 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
8000399c:	e0 6b 00 80 	mov	r11,128
800039a0:	30 ac       	mov	r12,10
800039a2:	f0 1f 00 48 	mcall	80003ac0 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
800039a6:	58 06       	cp.w	r6,0
800039a8:	c0 c0       	breq	800039c0 <PcdComMF522+0x70>
800039aa:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
800039ac:	30 94       	mov	r4,9
800039ae:	0f 3b       	ld.ub	r11,r7++
800039b0:	08 9c       	mov	r12,r4
800039b2:	f0 1f 00 42 	mcall	80003ab8 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
800039b6:	0e 98       	mov	r8,r7
800039b8:	0a 18       	sub	r8,r5
800039ba:	ec 08 19 00 	cp.h	r8,r6
800039be:	cf 83       	brcs	800039ae <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
800039c0:	04 9b       	mov	r11,r2
800039c2:	30 1c       	mov	r12,1
800039c4:	f0 1f 00 3d 	mcall	80003ab8 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
800039c8:	30 c8       	mov	r8,12
800039ca:	f0 02 18 00 	cp.b	r2,r8
800039ce:	c0 61       	brne	800039da <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
800039d0:	e0 6b 00 80 	mov	r11,128
800039d4:	30 dc       	mov	r12,13
800039d6:	f0 1f 00 3b 	mcall	80003ac0 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800039da:	30 4c       	mov	r12,4
800039dc:	f0 1f 00 3a 	mcall	80003ac4 <PcdComMF522+0x174>
800039e0:	18 97       	mov	r7,r12
800039e2:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800039e6:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800039e8:	30 44       	mov	r4,4
800039ea:	c0 88       	rjmp	800039fa <PcdComMF522+0xaa>
800039ec:	08 9c       	mov	r12,r4
800039ee:	f0 1f 00 36 	mcall	80003ac4 <PcdComMF522+0x174>
800039f2:	18 97       	mov	r7,r12
		i--;
800039f4:	20 16       	sub	r6,1
800039f6:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800039f8:	c0 a0       	breq	80003a0c <PcdComMF522+0xbc>
800039fa:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800039fe:	c4 c1       	brne	80003a96 <PcdComMF522+0x146>
80003a00:	ef e3 00 08 	and	r8,r7,r3
80003a04:	ea 08 18 00 	cp.b	r8,r5
80003a08:	cf 20       	breq	800039ec <PcdComMF522+0x9c>
80003a0a:	c4 68       	rjmp	80003a96 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80003a0c:	e0 6b 00 80 	mov	r11,128
80003a10:	30 dc       	mov	r12,13
80003a12:	f0 1f 00 2b 	mcall	80003abc <PcdComMF522+0x16c>
80003a16:	30 27       	mov	r7,2
80003a18:	c3 38       	rjmp	80003a7e <PcdComMF522+0x12e>
80003a1a:	02 67       	and	r7,r1
80003a1c:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80003a20:	30 c8       	mov	r8,12
80003a22:	f0 02 18 00 	cp.b	r2,r8
80003a26:	c2 c1       	brne	80003a7e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80003a28:	30 ac       	mov	r12,10
80003a2a:	f0 1f 00 27 	mcall	80003ac4 <PcdComMF522+0x174>
80003a2e:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80003a30:	30 cc       	mov	r12,12
80003a32:	f0 1f 00 25 	mcall	80003ac4 <PcdComMF522+0x174>
80003a36:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80003a3a:	c0 70       	breq	80003a48 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80003a3c:	08 98       	mov	r8,r4
80003a3e:	20 18       	sub	r8,1
80003a40:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80003a44:	a0 8c       	st.b	r0[0x0],r12
80003a46:	c0 48       	rjmp	80003a4e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80003a48:	e8 08 15 03 	lsl	r8,r4,0x3
80003a4c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80003a4e:	58 04       	cp.w	r4,0
80003a50:	c0 61       	brne	80003a5c <PcdComMF522+0x10c>
80003a52:	30 14       	mov	r4,1
80003a54:	40 05       	lddsp	r5,sp[0x0]
80003a56:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80003a58:	30 93       	mov	r3,9
80003a5a:	c0 98       	rjmp	80003a6c <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80003a5c:	31 28       	mov	r8,18
80003a5e:	f0 04 18 00 	cp.b	r4,r8
80003a62:	f9 b4 0b 12 	movhi	r4,18
80003a66:	58 04       	cp.w	r4,0
80003a68:	cf 61       	brne	80003a54 <PcdComMF522+0x104>
80003a6a:	c0 a8       	rjmp	80003a7e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80003a6c:	06 9c       	mov	r12,r3
80003a6e:	f0 1f 00 16 	mcall	80003ac4 <PcdComMF522+0x174>
80003a72:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80003a74:	ec 05 01 08 	sub	r8,r6,r5
80003a78:	e8 08 19 00 	cp.h	r8,r4
80003a7c:	cf 83       	brcs	80003a6c <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80003a7e:	e0 6b 00 80 	mov	r11,128
80003a82:	30 cc       	mov	r12,12
80003a84:	f0 1f 00 0f 	mcall	80003ac0 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80003a88:	30 0b       	mov	r11,0
80003a8a:	30 1c       	mov	r12,1
80003a8c:	f0 1f 00 0b 	mcall	80003ab8 <PcdComMF522+0x168>
	return status;
}
80003a90:	0e 9c       	mov	r12,r7
80003a92:	2f fd       	sub	sp,-4
80003a94:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80003a96:	e0 6b 00 80 	mov	r11,128
80003a9a:	30 dc       	mov	r12,13
80003a9c:	f0 1f 00 08 	mcall	80003abc <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80003aa0:	30 6c       	mov	r12,6
80003aa2:	f0 1f 00 09 	mcall	80003ac4 <PcdComMF522+0x174>
80003aa6:	e2 1c 00 1b 	andl	r12,0x1b,COH
80003aaa:	cb 80       	breq	80003a1a <PcdComMF522+0xca>
80003aac:	30 27       	mov	r7,2
80003aae:	ce 8b       	rjmp	80003a7e <PcdComMF522+0x12e>
80003ab0:	80 00       	ld.sh	r0,r0[0x0]
80003ab2:	ca 74       	brge	80003a00 <PcdComMF522+0xb0>
80003ab4:	80 00       	ld.sh	r0,r0[0x0]
80003ab6:	ca 78       	rjmp	80003c04 <CalulateCRC+0x54>
80003ab8:	80 00       	ld.sh	r0,r0[0x0]
80003aba:	36 4c       	mov	r12,100
80003abc:	80 00       	ld.sh	r0,r0[0x0]
80003abe:	37 f4       	mov	r4,127
80003ac0:	80 00       	ld.sh	r0,r0[0x0]
80003ac2:	37 b0       	mov	r0,123
80003ac4:	80 00       	ld.sh	r0,r0[0x0]
80003ac6:	37 0c       	mov	r12,112

80003ac8 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80003ac8:	eb cd 40 c0 	pushm	r6-r7,lr
80003acc:	20 5d       	sub	sp,20
80003ace:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80003ad0:	30 8b       	mov	r11,8
80003ad2:	16 9c       	mov	r12,r11
80003ad4:	f0 1f 00 1a 	mcall	80003b3c <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80003ad8:	30 0b       	mov	r11,0
80003ada:	30 dc       	mov	r12,13
80003adc:	f0 1f 00 19 	mcall	80003b40 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80003ae0:	e0 6b 00 80 	mov	r11,128
80003ae4:	30 ec       	mov	r12,14
80003ae6:	f0 1f 00 16 	mcall	80003b3c <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80003aea:	39 38       	mov	r8,-109
80003aec:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80003aee:	32 08       	mov	r8,32
80003af0:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80003af2:	1a 9b       	mov	r11,sp
80003af4:	fa c8 ff ed 	sub	r8,sp,-19
80003af8:	1a 99       	mov	r9,sp
80003afa:	30 2a       	mov	r10,2
80003afc:	30 cc       	mov	r12,12
80003afe:	f0 1f 00 12 	mcall	80003b44 <PcdAnticoll+0x7c>
80003b02:	18 97       	mov	r7,r12

	if (status == MI_OK)
80003b04:	c1 21       	brne	80003b28 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80003b06:	1b 89       	ld.ub	r9,sp[0x0]
80003b08:	ac 89       	st.b	r6[0x0],r9
80003b0a:	1b 98       	ld.ub	r8,sp[0x1]
80003b0c:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80003b0e:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80003b10:	1b a8       	ld.ub	r8,sp[0x2]
80003b12:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80003b14:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80003b18:	1b b9       	ld.ub	r9,sp[0x3]
80003b1a:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80003b1c:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80003b1e:	1b c9       	ld.ub	r9,sp[0x4]
80003b20:	f0 09 18 00 	cp.b	r9,r8
80003b24:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80003b28:	e0 6b 00 80 	mov	r11,128
80003b2c:	30 ec       	mov	r12,14
80003b2e:	f0 1f 00 07 	mcall	80003b48 <PcdAnticoll+0x80>
	return status;
}
80003b32:	0e 9c       	mov	r12,r7
80003b34:	2f bd       	sub	sp,-20
80003b36:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003b3a:	00 00       	add	r0,r0
80003b3c:	80 00       	ld.sh	r0,r0[0x0]
80003b3e:	37 f4       	mov	r4,127
80003b40:	80 00       	ld.sh	r0,r0[0x0]
80003b42:	36 4c       	mov	r12,100
80003b44:	80 00       	ld.sh	r0,r0[0x0]
80003b46:	39 50       	mov	r0,-107
80003b48:	80 00       	ld.sh	r0,r0[0x0]
80003b4a:	37 b0       	mov	r0,123

80003b4c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80003b4c:	eb cd 40 c0 	pushm	r6-r7,lr
80003b50:	20 5d       	sub	sp,20
80003b52:	18 97       	mov	r7,r12
80003b54:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80003b56:	30 8b       	mov	r11,8
80003b58:	16 9c       	mov	r12,r11
80003b5a:	f0 1f 00 12 	mcall	80003ba0 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80003b5e:	30 7b       	mov	r11,7
80003b60:	30 dc       	mov	r12,13
80003b62:	f0 1f 00 11 	mcall	80003ba4 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80003b66:	30 3b       	mov	r11,3
80003b68:	31 4c       	mov	r12,20
80003b6a:	f0 1f 00 10 	mcall	80003ba8 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80003b6e:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80003b70:	1a 9b       	mov	r11,sp
80003b72:	fa c8 ff ed 	sub	r8,sp,-19
80003b76:	1a 99       	mov	r9,sp
80003b78:	30 1a       	mov	r10,1
80003b7a:	30 cc       	mov	r12,12
80003b7c:	f0 1f 00 0c 	mcall	80003bac <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80003b80:	c0 c1       	brne	80003b98 <PcdRequest+0x4c>
80003b82:	31 08       	mov	r8,16
80003b84:	fb 39 00 13 	ld.ub	r9,sp[19]
80003b88:	f0 09 18 00 	cp.b	r9,r8
80003b8c:	c0 61       	brne	80003b98 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80003b8e:	1b 88       	ld.ub	r8,sp[0x0]
80003b90:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80003b92:	1b 98       	ld.ub	r8,sp[0x1]
80003b94:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80003b96:	c0 28       	rjmp	80003b9a <PcdRequest+0x4e>
80003b98:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80003b9a:	2f bd       	sub	sp,-20
80003b9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003ba0:	80 00       	ld.sh	r0,r0[0x0]
80003ba2:	37 f4       	mov	r4,127
80003ba4:	80 00       	ld.sh	r0,r0[0x0]
80003ba6:	36 4c       	mov	r12,100
80003ba8:	80 00       	ld.sh	r0,r0[0x0]
80003baa:	37 b0       	mov	r0,123
80003bac:	80 00       	ld.sh	r0,r0[0x0]
80003bae:	39 50       	mov	r0,-107

80003bb0 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80003bb0:	eb cd 40 f8 	pushm	r3-r7,lr
80003bb4:	18 95       	mov	r5,r12
80003bb6:	16 96       	mov	r6,r11
80003bb8:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80003bba:	30 4b       	mov	r11,4
80003bbc:	30 5c       	mov	r12,5
80003bbe:	f0 1f 00 1c 	mcall	80003c2c <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80003bc2:	30 0b       	mov	r11,0
80003bc4:	30 1c       	mov	r12,1
80003bc6:	f0 1f 00 1b 	mcall	80003c30 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80003bca:	e0 6b 00 80 	mov	r11,128
80003bce:	30 ac       	mov	r12,10
80003bd0:	f0 1f 00 19 	mcall	80003c34 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80003bd4:	58 06       	cp.w	r6,0
80003bd6:	c0 c0       	breq	80003bee <CalulateCRC+0x3e>
80003bd8:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80003bda:	30 94       	mov	r4,9
80003bdc:	0f 3b       	ld.ub	r11,r7++
80003bde:	08 9c       	mov	r12,r4
80003be0:	f0 1f 00 14 	mcall	80003c30 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80003be4:	0e 98       	mov	r8,r7
80003be6:	0a 18       	sub	r8,r5
80003be8:	ec 08 18 00 	cp.b	r8,r6
80003bec:	cf 83       	brcs	80003bdc <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80003bee:	30 3b       	mov	r11,3
80003bf0:	30 1c       	mov	r12,1
80003bf2:	f0 1f 00 10 	mcall	80003c30 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80003bf6:	30 5c       	mov	r12,5
80003bf8:	f0 1f 00 10 	mcall	80003c38 <CalulateCRC+0x88>
80003bfc:	e0 67 00 fe 	mov	r7,254
80003c00:	30 56       	mov	r6,5
80003c02:	c0 78       	rjmp	80003c10 <CalulateCRC+0x60>
80003c04:	0c 9c       	mov	r12,r6
80003c06:	f0 1f 00 0d 	mcall	80003c38 <CalulateCRC+0x88>
		i--;
80003c0a:	20 17       	sub	r7,1
80003c0c:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80003c0e:	c0 40       	breq	80003c16 <CalulateCRC+0x66>
80003c10:	e2 1c 00 04 	andl	r12,0x4,COH
80003c14:	cf 80       	breq	80003c04 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80003c16:	32 2c       	mov	r12,34
80003c18:	f0 1f 00 08 	mcall	80003c38 <CalulateCRC+0x88>
80003c1c:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80003c1e:	32 1c       	mov	r12,33
80003c20:	f0 1f 00 06 	mcall	80003c38 <CalulateCRC+0x88>
80003c24:	a6 9c       	st.b	r3[0x1],r12
}
80003c26:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003c2a:	00 00       	add	r0,r0
80003c2c:	80 00       	ld.sh	r0,r0[0x0]
80003c2e:	37 f4       	mov	r4,127
80003c30:	80 00       	ld.sh	r0,r0[0x0]
80003c32:	36 4c       	mov	r12,100
80003c34:	80 00       	ld.sh	r0,r0[0x0]
80003c36:	37 b0       	mov	r0,123
80003c38:	80 00       	ld.sh	r0,r0[0x0]
80003c3a:	37 0c       	mov	r12,112

80003c3c <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80003c3c:	eb cd 40 80 	pushm	r7,lr
80003c40:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80003c42:	39 38       	mov	r8,-109
80003c44:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80003c46:	37 08       	mov	r8,112
80003c48:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80003c4a:	30 08       	mov	r8,0
80003c4c:	ba e8       	st.b	sp[0x6],r8
80003c4e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80003c52:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80003c56:	19 89       	ld.ub	r9,r12[0x0]
80003c58:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80003c5a:	19 3a       	ld.ub	r10,r12++
80003c5c:	1b e9       	ld.ub	r9,sp[0x6]
80003c5e:	f5 e9 20 09 	eor	r9,r10,r9
80003c62:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80003c64:	16 38       	cp.w	r8,r11
80003c66:	cf 81       	brne	80003c56 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80003c68:	1a 97       	mov	r7,sp
80003c6a:	fa ca ff f9 	sub	r10,sp,-7
80003c6e:	30 7b       	mov	r11,7
80003c70:	1a 9c       	mov	r12,sp
80003c72:	f0 1f 00 0d 	mcall	80003ca4 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80003c76:	30 8b       	mov	r11,8
80003c78:	16 9c       	mov	r12,r11
80003c7a:	f0 1f 00 0c 	mcall	80003ca8 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80003c7e:	fa c8 ff ed 	sub	r8,sp,-19
80003c82:	1a 99       	mov	r9,sp
80003c84:	30 9a       	mov	r10,9
80003c86:	1a 9b       	mov	r11,sp
80003c88:	30 cc       	mov	r12,12
80003c8a:	f0 1f 00 09 	mcall	80003cac <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80003c8e:	c0 71       	brne	80003c9c <PcdSelect+0x60>
80003c90:	31 88       	mov	r8,24
80003c92:	fb 39 00 13 	ld.ub	r9,sp[19]
80003c96:	f0 09 18 00 	cp.b	r9,r8
80003c9a:	c0 20       	breq	80003c9e <PcdSelect+0x62>
80003c9c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80003c9e:	2f bd       	sub	sp,-20
80003ca0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ca4:	80 00       	ld.sh	r0,r0[0x0]
80003ca6:	3b b0       	mov	r0,-69
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	37 f4       	mov	r4,127
80003cac:	80 00       	ld.sh	r0,r0[0x0]
80003cae:	39 50       	mov	r0,-107

80003cb0 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80003cb0:	eb cd 40 c0 	pushm	r6-r7,lr
80003cb4:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80003cb6:	f0 1f 00 37 	mcall	80003d90 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80003cba:	4b 7b       	lddpc	r11,80003d94 <rfid_auto_reader+0xe4>
80003cbc:	35 2c       	mov	r12,82
80003cbe:	f0 1f 00 37 	mcall	80003d98 <rfid_auto_reader+0xe8>
80003cc2:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80003cc4:	c6 31       	brne	80003d8a <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003cc6:	4b 48       	lddpc	r8,80003d94 <rfid_auto_reader+0xe4>
80003cc8:	11 88       	ld.ub	r8,r8[0x0]
80003cca:	30 49       	mov	r9,4
80003ccc:	f2 08 18 00 	cp.b	r8,r9
80003cd0:	c0 b1       	brne	80003ce6 <rfid_auto_reader+0x36>
80003cd2:	4b 19       	lddpc	r9,80003d94 <rfid_auto_reader+0xe4>
80003cd4:	13 9a       	ld.ub	r10,r9[0x1]
80003cd6:	30 09       	mov	r9,0
80003cd8:	f2 0a 18 00 	cp.b	r10,r9
80003cdc:	c0 51       	brne	80003ce6 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80003cde:	4b 0c       	lddpc	r12,80003d9c <rfid_auto_reader+0xec>
80003ce0:	f0 1f 00 30 	mcall	80003da0 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003ce4:	c3 c8       	rjmp	80003d5c <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80003ce6:	30 29       	mov	r9,2
80003ce8:	f2 08 18 00 	cp.b	r8,r9
80003cec:	c0 b1       	brne	80003d02 <rfid_auto_reader+0x52>
80003cee:	4a a9       	lddpc	r9,80003d94 <rfid_auto_reader+0xe4>
80003cf0:	13 9a       	ld.ub	r10,r9[0x1]
80003cf2:	30 09       	mov	r9,0
80003cf4:	f2 0a 18 00 	cp.b	r10,r9
80003cf8:	c0 51       	brne	80003d02 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80003cfa:	4a bc       	lddpc	r12,80003da4 <rfid_auto_reader+0xf4>
80003cfc:	f0 1f 00 29 	mcall	80003da0 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80003d00:	c2 e8       	rjmp	80003d5c <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80003d02:	34 49       	mov	r9,68
80003d04:	f2 08 18 00 	cp.b	r8,r9
80003d08:	c0 b1       	brne	80003d1e <rfid_auto_reader+0x6e>
80003d0a:	4a 39       	lddpc	r9,80003d94 <rfid_auto_reader+0xe4>
80003d0c:	13 9a       	ld.ub	r10,r9[0x1]
80003d0e:	30 09       	mov	r9,0
80003d10:	f2 0a 18 00 	cp.b	r10,r9
80003d14:	c0 51       	brne	80003d1e <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80003d16:	4a 5c       	lddpc	r12,80003da8 <rfid_auto_reader+0xf8>
80003d18:	f0 1f 00 22 	mcall	80003da0 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80003d1c:	c2 08       	rjmp	80003d5c <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80003d1e:	30 89       	mov	r9,8
80003d20:	f2 08 18 00 	cp.b	r8,r9
80003d24:	c0 b1       	brne	80003d3a <rfid_auto_reader+0x8a>
80003d26:	49 c9       	lddpc	r9,80003d94 <rfid_auto_reader+0xe4>
80003d28:	13 9a       	ld.ub	r10,r9[0x1]
80003d2a:	30 09       	mov	r9,0
80003d2c:	f2 0a 18 00 	cp.b	r10,r9
80003d30:	c0 51       	brne	80003d3a <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80003d32:	49 fc       	lddpc	r12,80003dac <rfid_auto_reader+0xfc>
80003d34:	f0 1f 00 1b 	mcall	80003da0 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80003d38:	c1 28       	rjmp	80003d5c <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80003d3a:	34 49       	mov	r9,68
80003d3c:	f2 08 18 00 	cp.b	r8,r9
80003d40:	c0 b1       	brne	80003d56 <rfid_auto_reader+0xa6>
80003d42:	49 58       	lddpc	r8,80003d94 <rfid_auto_reader+0xe4>
80003d44:	11 99       	ld.ub	r9,r8[0x1]
80003d46:	30 38       	mov	r8,3
80003d48:	f0 09 18 00 	cp.b	r9,r8
80003d4c:	c0 51       	brne	80003d56 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80003d4e:	49 9c       	lddpc	r12,80003db0 <rfid_auto_reader+0x100>
80003d50:	f0 1f 00 14 	mcall	80003da0 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80003d54:	c0 48       	rjmp	80003d5c <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80003d56:	49 8c       	lddpc	r12,80003db4 <rfid_auto_reader+0x104>
80003d58:	f0 1f 00 12 	mcall	80003da0 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80003d5c:	49 7c       	lddpc	r12,80003db8 <rfid_auto_reader+0x108>
80003d5e:	f0 1f 00 18 	mcall	80003dbc <rfid_auto_reader+0x10c>
80003d62:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80003d64:	c0 60       	breq	80003d70 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80003d66:	37 8b       	mov	r11,120
80003d68:	30 1c       	mov	r12,1
80003d6a:	f0 1f 00 16 	mcall	80003dc0 <rfid_auto_reader+0x110>
		return status;
80003d6e:	c0 e8       	rjmp	80003d8a <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80003d70:	49 2c       	lddpc	r12,80003db8 <rfid_auto_reader+0x108>
80003d72:	f0 1f 00 15 	mcall	80003dc4 <rfid_auto_reader+0x114>
80003d76:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80003d78:	c0 91       	brne	80003d8a <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80003d7a:	30 4a       	mov	r10,4
80003d7c:	48 fb       	lddpc	r11,80003db8 <rfid_auto_reader+0x108>
80003d7e:	0c 9c       	mov	r12,r6
80003d80:	f0 1f 00 12 	mcall	80003dc8 <rfid_auto_reader+0x118>
		log("select okay\n");
80003d84:	49 2c       	lddpc	r12,80003dcc <rfid_auto_reader+0x11c>
80003d86:	f0 1f 00 07 	mcall	80003da0 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80003d8a:	0e 9c       	mov	r12,r7
80003d8c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003d90:	80 00       	ld.sh	r0,r0[0x0]
80003d92:	36 8c       	mov	r12,104
80003d94:	00 00       	add	r0,r0
80003d96:	1d 1c       	ld.sh	r12,lr++
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	3b 4c       	mov	r12,-76
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	ca 94       	brge	80003cf0 <rfid_auto_reader+0x40>
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	62 70       	ld.w	r0,r1[0x1c]
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	ca a0       	breq	80003cfa <rfid_auto_reader+0x4a>
80003da8:	80 00       	ld.sh	r0,r0[0x0]
80003daa:	ca ac       	rcall	80003efe <scan_rfid_save_message+0xde>
80003dac:	80 00       	ld.sh	r0,r0[0x0]
80003dae:	ca bc       	rcall	80003f04 <scan_rfid_save_message+0xe4>
80003db0:	80 00       	ld.sh	r0,r0[0x0]
80003db2:	ca c4       	brge	80003d0a <rfid_auto_reader+0x5a>
80003db4:	80 00       	ld.sh	r0,r0[0x0]
80003db6:	ca d0       	breq	80003d10 <rfid_auto_reader+0x60>
80003db8:	00 00       	add	r0,r0
80003dba:	1d 20       	ld.uh	r0,lr++
80003dbc:	80 00       	ld.sh	r0,r0[0x0]
80003dbe:	3a c8       	mov	r8,-84
80003dc0:	80 00       	ld.sh	r0,r0[0x0]
80003dc2:	34 78       	mov	r8,71
80003dc4:	80 00       	ld.sh	r0,r0[0x0]
80003dc6:	3c 3c       	mov	r12,-61
80003dc8:	80 00       	ld.sh	r0,r0[0x0]
80003dca:	69 92       	ld.w	r2,r4[0x64]
80003dcc:	80 00       	ld.sh	r0,r0[0x0]
80003dce:	ca dc       	rcall	80003f28 <scan_rfid_save_message+0x108>

80003dd0 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80003dd0:	eb cd 40 80 	pushm	r7,lr
80003dd4:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80003dd6:	f0 1f 00 0d 	mcall	80003e08 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80003dda:	30 0c       	mov	r12,0
80003ddc:	f0 1f 00 0c 	mcall	80003e0c <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80003de0:	0e 9c       	mov	r12,r7
80003de2:	f0 1f 00 0c 	mcall	80003e10 <scan_patrol+0x40>
80003de6:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80003de8:	30 1c       	mov	r12,1
80003dea:	f0 1f 00 09 	mcall	80003e0c <scan_patrol+0x3c>
	if(return_err == 0)
80003dee:	58 07       	cp.w	r7,0
80003df0:	c0 51       	brne	80003dfa <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80003df2:	48 9c       	lddpc	r12,80003e14 <scan_patrol+0x44>
80003df4:	f0 1f 00 09 	mcall	80003e18 <scan_patrol+0x48>
80003df8:	c0 48       	rjmp	80003e00 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80003dfa:	48 9c       	lddpc	r12,80003e1c <scan_patrol+0x4c>
80003dfc:	f0 1f 00 07 	mcall	80003e18 <scan_patrol+0x48>
		
	return return_err;

}
80003e00:	0e 9c       	mov	r12,r7
80003e02:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e06:	00 00       	add	r0,r0
80003e08:	80 00       	ld.sh	r0,r0[0x0]
80003e0a:	36 8c       	mov	r12,104
80003e0c:	80 00       	ld.sh	r0,r0[0x0]
80003e0e:	37 64       	mov	r4,118
80003e10:	80 00       	ld.sh	r0,r0[0x0]
80003e12:	3c b0       	mov	r0,-53
80003e14:	80 00       	ld.sh	r0,r0[0x0]
80003e16:	ca ec       	rcall	80003f72 <scan_rfid_save_message+0x152>
80003e18:	80 00       	ld.sh	r0,r0[0x0]
80003e1a:	62 70       	ld.w	r0,r1[0x1c]
80003e1c:	80 00       	ld.sh	r0,r0[0x0]
80003e1e:	cb 00       	breq	80003d7e <rfid_auto_reader+0xce>

80003e20 <scan_rfid_save_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
{
80003e20:	eb cd 40 e0 	pushm	r5-r7,lr
80003e24:	21 dd       	sub	sp,116
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80003e26:	4d 7c       	lddpc	r12,80003f80 <scan_rfid_save_message+0x160>
80003e28:	30 08       	mov	r8,0
80003e2a:	30 09       	mov	r9,0
80003e2c:	f8 e9 00 00 	st.d	r12[0],r8
80003e30:	30 0a       	mov	r10,0
80003e32:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80003e34:	fa e9 00 24 	st.d	sp[36],r8
80003e38:	fa e9 00 2c 	st.d	sp[44],r8
80003e3c:	fa e9 00 34 	st.d	sp[52],r8
80003e40:	fa e9 00 3c 	st.d	sp[60],r8
80003e44:	fa e9 00 44 	st.d	sp[68],r8
80003e48:	fa e9 00 4c 	st.d	sp[76],r8
80003e4c:	fa e9 00 54 	st.d	sp[84],r8
80003e50:	fa e9 00 5c 	st.d	sp[92],r8
80003e54:	fa e9 00 64 	st.d	sp[100],r8
80003e58:	fa e9 00 6c 	st.d	sp[108],r8
	
	return_err = scan_patrol(SN);
80003e5c:	f0 1f 00 4a 	mcall	80003f84 <scan_rfid_save_message+0x164>
80003e60:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80003e62:	e0 81 00 84 	brne	80003f6a <scan_rfid_save_message+0x14a>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80003e66:	4c 76       	lddpc	r6,80003f80 <scan_rfid_save_message+0x160>
80003e68:	0d b8       	ld.ub	r8,r6[0x3]
80003e6a:	1a d8       	st.w	--sp,r8
80003e6c:	0d a8       	ld.ub	r8,r6[0x2]
80003e6e:	1a d8       	st.w	--sp,r8
80003e70:	0d 98       	ld.ub	r8,r6[0x1]
80003e72:	1a d8       	st.w	--sp,r8
80003e74:	0d 88       	ld.ub	r8,r6[0x0]
80003e76:	1a d8       	st.w	--sp,r8
80003e78:	4c 4c       	lddpc	r12,80003f88 <scan_rfid_save_message+0x168>
80003e7a:	f0 1f 00 45 	mcall	80003f8c <scan_rfid_save_message+0x16c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
80003e7e:	37 7b       	mov	r11,119
80003e80:	30 1c       	mov	r12,1
80003e82:	f0 1f 00 44 	mcall	80003f90 <scan_rfid_save_message+0x170>
80003e86:	fa c8 ff ec 	sub	r8,sp,-20
80003e8a:	fa c9 ff ea 	sub	r9,sp,-22
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
80003e8e:	ec c5 ff fc 	sub	r5,r6,-4
80003e92:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80003e94:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80003e96:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80003e98:	0d 8a       	ld.ub	r10,r6[0x0]
80003e9a:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80003e9e:	fc 0b 18 00 	cp.b	r11,lr
80003ea2:	f7 bb 08 d0 	subls	r11,-48
80003ea6:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80003eaa:	f7 bb 0b a9 	subhi	r11,-87
80003eae:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80003eb2:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80003eb4:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80003eb8:	fc 0a 18 00 	cp.b	r10,lr
80003ebc:	f7 ba 08 d0 	subls	r10,-48
80003ec0:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80003ec4:	f7 ba 0b a9 	subhi	r10,-87
80003ec8:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80003ecc:	b0 bc       	st.b	r8[0x3],r12
80003ece:	2f f6       	sub	r6,-1
80003ed0:	2f c8       	sub	r8,-4
80003ed2:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80003ed4:	0a 36       	cp.w	r6,r5
80003ed6:	ce 11       	brne	80003e98 <scan_rfid_save_message+0x78>
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			data_buffer.RFID_ID[i*4+3] = 0x00;
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80003ed8:	30 6a       	mov	r10,6
80003eda:	4a fb       	lddpc	r11,80003f94 <scan_rfid_save_message+0x174>
80003edc:	fa cc ff ec 	sub	r12,sp,-20
80003ee0:	f0 1f 00 2e 	mcall	80003f98 <scan_rfid_save_message+0x178>
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80003ee4:	4a e8       	lddpc	r8,80003f9c <scan_rfid_save_message+0x17c>
80003ee6:	11 89       	ld.ub	r9,r8[0x0]
80003ee8:	39 f8       	mov	r8,-97
80003eea:	f0 09 18 00 	cp.b	r9,r8
80003eee:	e0 88 00 05 	brls	80003ef8 <scan_rfid_save_message+0xd8>
80003ef2:	38 09       	mov	r9,-128
80003ef4:	4a a8       	lddpc	r8,80003f9c <scan_rfid_save_message+0x17c>
80003ef6:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80003ef8:	4a 98       	lddpc	r8,80003f9c <scan_rfid_save_message+0x17c>
80003efa:	11 86       	ld.ub	r6,r8[0x0]
80003efc:	2f f6       	sub	r6,-1
80003efe:	5c 56       	castu.b	r6
80003f00:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80003f02:	30 5a       	mov	r10,5
80003f04:	4a 7b       	lddpc	r11,80003fa0 <scan_rfid_save_message+0x180>
80003f06:	fa cc ff e1 	sub	r12,sp,-31
80003f0a:	f0 1f 00 24 	mcall	80003f98 <scan_rfid_save_message+0x178>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80003f0e:	31 e8       	mov	r8,30
80003f10:	fb 58 00 1a 	st.h	sp[26],r8
80003f14:	fb 66 00 1e 	st.b	sp[30],r6
80003f18:	fe 78 e0 00 	mov	r8,-8192
80003f1c:	fb 58 00 1c 	st.h	sp[28],r8
80003f20:	30 aa       	mov	r10,10
80003f22:	fa cb ff e6 	sub	r11,sp,-26
80003f26:	fa cc ff dc 	sub	r12,sp,-36
80003f2a:	f0 1f 00 1c 	mcall	80003f98 <scan_rfid_save_message+0x178>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80003f2e:	31 6a       	mov	r10,22
80003f30:	fa cb ff fc 	sub	r11,sp,-4
80003f34:	fa cc ff d2 	sub	r12,sp,-46
80003f38:	f0 1f 00 18 	mcall	80003f98 <scan_rfid_save_message+0x178>
		
		//xgflash_message_save(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), TRUE);
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t * myptr = get_message_store();
80003f3c:	49 a8       	lddpc	r8,80003fa4 <scan_rfid_save_message+0x184>
80003f3e:	70 0c       	ld.w	r12,r8[0x0]
80003f40:	f0 1f 00 1a 	mcall	80003fa8 <scan_rfid_save_message+0x188>
80003f44:	50 0c       	stdsp	sp[0x0],r12
		if(NULL != myptr)
80003f46:	c0 e0       	breq	80003f62 <scan_rfid_save_message+0x142>
		{
			memcpy(myptr, message, sizeof(Message_Protocol_t));
80003f48:	32 0a       	mov	r10,32
80003f4a:	fa cb ff dc 	sub	r11,sp,-36
80003f4e:	f0 1f 00 13 	mcall	80003f98 <scan_rfid_save_message+0x178>
			xQueueSend(xg_resend_queue, &myptr, 0);
80003f52:	49 78       	lddpc	r8,80003fac <scan_rfid_save_message+0x18c>
80003f54:	70 0c       	ld.w	r12,r8[0x0]
80003f56:	30 09       	mov	r9,0
80003f58:	12 9a       	mov	r10,r9
80003f5a:	1a 9b       	mov	r11,sp
80003f5c:	f0 1f 00 15 	mcall	80003fb0 <scan_rfid_save_message+0x190>
80003f60:	c0 c8       	rjmp	80003f78 <scan_rfid_save_message+0x158>
		}
		else
		{
			log("myptr: err\n\r" );
80003f62:	49 5c       	lddpc	r12,80003fb4 <scan_rfid_save_message+0x194>
80003f64:	f0 1f 00 0a 	mcall	80003f8c <scan_rfid_save_message+0x16c>
80003f68:	c0 88       	rjmp	80003f78 <scan_rfid_save_message+0x158>
		
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80003f6a:	37 8b       	mov	r11,120
80003f6c:	30 1c       	mov	r12,1
80003f6e:	f0 1f 00 09 	mcall	80003f90 <scan_rfid_save_message+0x170>
		log("no card find...\n");
80003f72:	49 2c       	lddpc	r12,80003fb8 <scan_rfid_save_message+0x198>
80003f74:	f0 1f 00 06 	mcall	80003f8c <scan_rfid_save_message+0x16c>
	}
	
	return return_err;
	

}
80003f78:	0e 9c       	mov	r12,r7
80003f7a:	2e 3d       	sub	sp,-116
80003f7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003f80:	00 00       	add	r0,r0
80003f82:	0a 60       	and	r0,r5
80003f84:	80 00       	ld.sh	r0,r0[0x0]
80003f86:	3d d0       	mov	r0,-35
80003f88:	80 00       	ld.sh	r0,r0[0x0]
80003f8a:	cb 14       	brge	80003eec <scan_rfid_save_message+0xcc>
80003f8c:	80 00       	ld.sh	r0,r0[0x0]
80003f8e:	62 70       	ld.w	r0,r1[0x1c]
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	34 78       	mov	r8,71
80003f94:	00 00       	add	r0,r0
80003f96:	0c fc       	st.b	--r6,r12
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	69 92       	ld.w	r2,r4[0x64]
80003f9c:	00 00       	add	r0,r0
80003f9e:	05 04       	ld.w	r4,r2++
80003fa0:	00 00       	add	r0,r0
80003fa2:	04 fc       	st.b	--r2,r12
80003fa4:	00 00       	add	r0,r0
80003fa6:	0a 7c       	tst	r12,r5
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	33 30       	mov	r0,51
80003fac:	00 00       	add	r0,r0
80003fae:	0a 6c       	and	r12,r5
80003fb0:	80 00       	ld.sh	r0,r0[0x0]
80003fb2:	56 20       	stdsp	sp[0x188],r0
80003fb4:	80 00       	ld.sh	r0,r0[0x0]
80003fb6:	c9 f8       	rjmp	800040f4 <xg_flashc_init+0x4>
80003fb8:	80 00       	ld.sh	r0,r0[0x0]
80003fba:	cb 30       	breq	80003f20 <scan_rfid_save_message+0x100>

80003fbc <rfid_init>:
/*the queue is used to receive failure-send message*/
extern volatile xQueueHandle xg_resend_queue ;


void rfid_init()
{
80003fbc:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80003fbe:	f0 1f 00 02 	mcall	80003fc4 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80003fc2:	d8 02       	popm	pc
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	38 9c       	mov	r12,-119

80003fc8 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80003fc8:	58 0c       	cp.w	r12,0
80003fca:	5e 0c       	reteq	r12
80003fcc:	30 08       	mov	r8,0
	{
		nop();
80003fce:	d7 03       	nop
		nop();
80003fd0:	d7 03       	nop
		nop();
80003fd2:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80003fd4:	2f f8       	sub	r8,-1
80003fd6:	10 3c       	cp.w	r12,r8
80003fd8:	fe 9b ff fb 	brhi	80003fce <delay_ns+0x6>
80003fdc:	5e fc       	retal	r12
80003fde:	d7 03       	nop

80003fe0 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80003fe0:	eb cd 40 e0 	pushm	r5-r7,lr
80003fe4:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80003fe6:	58 0c       	cp.w	r12,0
80003fe8:	c0 b0       	breq	80003ffe <delay_us+0x1e>
80003fea:	30 07       	mov	r7,0
		delay_ns(1000);
80003fec:	e0 65 03 e8 	mov	r5,1000
80003ff0:	0a 9c       	mov	r12,r5
80003ff2:	f0 1f 00 05 	mcall	80004004 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80003ff6:	2f f7       	sub	r7,-1
80003ff8:	0e 36       	cp.w	r6,r7
80003ffa:	fe 9b ff fb 	brhi	80003ff0 <delay_us+0x10>
80003ffe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004002:	00 00       	add	r0,r0
80004004:	80 00       	ld.sh	r0,r0[0x0]
80004006:	3f c8       	mov	r8,-4

80004008 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80004008:	eb cd 40 e0 	pushm	r5-r7,lr
8000400c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000400e:	58 0c       	cp.w	r12,0
80004010:	c0 b0       	breq	80004026 <delay_ms+0x1e>
80004012:	30 07       	mov	r7,0
		delay_us(1000);
80004014:	e0 65 03 e8 	mov	r5,1000
80004018:	0a 9c       	mov	r12,r5
8000401a:	f0 1f 00 05 	mcall	8000402c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000401e:	2f f7       	sub	r7,-1
80004020:	0e 36       	cp.w	r6,r7
80004022:	fe 9b ff fb 	brhi	80004018 <delay_ms+0x10>
80004026:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000402a:	00 00       	add	r0,r0
8000402c:	80 00       	ld.sh	r0,r0[0x0]
8000402e:	3f e0       	mov	r0,-2

80004030 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80004030:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80004032:	30 3b       	mov	r11,3
80004034:	48 8c       	lddpc	r12,80004054 <local_start_timer+0x24>
80004036:	f0 1f 00 09 	mcall	80004058 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000403a:	fe 78 38 00 	mov	r8,-51200
8000403e:	e0 69 91 0d 	mov	r9,37133
80004042:	ea 19 00 52 	orh	r9,0x52
80004046:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004048:	32 09       	mov	r9,32
8000404a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000404c:	30 59       	mov	r9,5
8000404e:	91 09       	st.w	r8[0x0],r9
}
80004050:	d8 02       	popm	pc
80004052:	00 00       	add	r0,r0
80004054:	80 00       	ld.sh	r0,r0[0x0]
80004056:	cb 44       	brge	80003fbe <rfid_init+0x2>
80004058:	80 00       	ld.sh	r0,r0[0x0]
8000405a:	46 dc       	lddsp	r12,sp[0x1b4]

8000405c <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
8000405c:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
8000405e:	30 3a       	mov	r10,3
80004060:	e0 6b 1b 00 	mov	r11,6912
80004064:	ea 1b 00 b7 	orh	r11,0xb7
80004068:	fe 7c 0c 00 	mov	r12,-62464
8000406c:	f0 1f 00 19 	mcall	800040d0 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80004070:	31 08       	mov	r8,16
80004072:	1a d8       	st.w	--sp,r8
80004074:	30 08       	mov	r8,0
80004076:	30 19       	mov	r9,1
80004078:	30 7a       	mov	r10,7
8000407a:	10 9b       	mov	r11,r8
8000407c:	fe 7c 0c 00 	mov	r12,-62464
80004080:	f0 1f 00 15 	mcall	800040d4 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80004084:	30 08       	mov	r8,0
80004086:	30 19       	mov	r9,1
80004088:	12 9a       	mov	r10,r9
8000408a:	10 9b       	mov	r11,r8
8000408c:	fe 7c 0c 00 	mov	r12,-62464
80004090:	f0 1f 00 12 	mcall	800040d8 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80004094:	30 0b       	mov	r11,0
80004096:	fe 7c 0c 00 	mov	r12,-62464
8000409a:	f0 1f 00 11 	mcall	800040dc <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000409e:	fe 7c 0c 00 	mov	r12,-62464
800040a2:	f0 1f 00 10 	mcall	800040e0 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
800040a6:	30 0a       	mov	r10,0
800040a8:	1a da       	st.w	--sp,r10
800040aa:	1a da       	st.w	--sp,r10
800040ac:	14 98       	mov	r8,r10
800040ae:	14 99       	mov	r9,r10
800040b0:	30 1b       	mov	r11,1
800040b2:	fe 7c 0c 00 	mov	r12,-62464
800040b6:	f0 1f 00 0c 	mcall	800040e4 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800040ba:	30 1c       	mov	r12,1
800040bc:	f0 1f 00 0b 	mcall	800040e8 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800040c0:	30 2b       	mov	r11,2
800040c2:	fe 7c 0c 00 	mov	r12,-62464
800040c6:	f0 1f 00 0a 	mcall	800040ec <local_start_pll0+0x90>
800040ca:	2f dd       	sub	sp,-12
/****/
}
800040cc:	d8 02       	popm	pc
800040ce:	00 00       	add	r0,r0
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	49 e4       	lddpc	r4,80004148 <xg_flashc_init+0x58>
800040d4:	80 00       	ld.sh	r0,r0[0x0]
800040d6:	49 86       	lddpc	r6,80004134 <xg_flashc_init+0x44>
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	49 a8       	lddpc	r8,80004140 <xg_flashc_init+0x50>
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	49 c2       	lddpc	r2,8000414c <xg_flashc_init+0x5c>
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	49 d0       	lddpc	r0,80004154 <xg_flashc_init+0x64>
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	49 40       	lddpc	r0,80004134 <xg_flashc_init+0x44>
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	46 7c       	lddsp	r12,sp[0x19c]
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	49 da       	lddpc	r10,80004160 <xg_flashc_init+0x70>

800040f0 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800040f0:	d4 31       	pushm	r0-r7,lr
800040f2:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
800040f4:	f0 1f 00 82 	mcall	800042fc <xg_flashc_init+0x20c>
800040f8:	fe f8 02 08 	ld.w	r8,pc[520]
800040fc:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
800040fe:	70 08       	ld.w	r8,r8[0x0]
80004100:	58 08       	cp.w	r8,0
80004102:	c0 51       	brne	8000410c <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80004104:	fe fc 02 00 	ld.w	r12,pc[512]
80004108:	f0 1f 00 80 	mcall	80004308 <xg_flashc_init+0x218>
	//计数最大值为300
	//初始值为1(当flash信息数量为0时：用户扫点 -> flash-save -> flash-count+1 -> take Sem -> send -> wait for give-Sem(success/fail))
	//如果此时反馈成功，则继续查询count值是否等于0/等待用户扫点
	//如果此时反馈失败，则flash-save
	//当flash信息数量！=0时；等待查询count值
	SendM_CountingSemaphore = xSemaphoreCreateCounting(300, 1);
8000410c:	30 1b       	mov	r11,1
8000410e:	e0 6c 01 2c 	mov	r12,300
80004112:	f0 1f 00 7f 	mcall	8000430c <xg_flashc_init+0x21c>
80004116:	4f f8       	lddpc	r8,80004310 <xg_flashc_init+0x220>
80004118:	91 0c       	st.w	r8[0x0],r12
	if (SendM_CountingSemaphore == NULL)
8000411a:	70 08       	ld.w	r8,r8[0x0]
8000411c:	58 08       	cp.w	r8,0
8000411e:	c0 41       	brne	80004126 <xg_flashc_init+0x36>
	{
		log("Create the SendM_Counting semaphore failure\n");
80004120:	4f dc       	lddpc	r12,80004314 <xg_flashc_init+0x224>
80004122:	f0 1f 00 7a 	mcall	80004308 <xg_flashc_init+0x218>
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
80004126:	30 4b       	mov	r11,4
80004128:	31 4c       	mov	r12,20
8000412a:	f0 1f 00 7c 	mcall	80004318 <xg_flashc_init+0x228>
8000412e:	4f c8       	lddpc	r8,8000431c <xg_flashc_init+0x22c>
80004130:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80004132:	30 4b       	mov	r11,4
80004134:	31 4c       	mov	r12,20
80004136:	f0 1f 00 79 	mcall	80004318 <xg_flashc_init+0x228>
8000413a:	4f a8       	lddpc	r8,80004320 <xg_flashc_init+0x230>
8000413c:	91 0c       	st.w	r8[0x0],r12
8000413e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80004140:	10 96       	mov	r6,r8
80004142:	4f 95       	lddpc	r5,80004324 <xg_flashc_init+0x234>
80004144:	6c 0c       	ld.w	r12,r6[0x0]
80004146:	ea 07 00 0b 	add	r11,r5,r7
8000414a:	f0 1f 00 78 	mcall	80004328 <xg_flashc_init+0x238>
8000414e:	2e 07       	sub	r7,-32
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80004150:	e0 47 02 80 	cp.w	r7,640
80004154:	cf 81       	brne	80004144 <xg_flashc_init+0x54>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80004156:	f0 1f 00 76 	mcall	8000432c <xg_flashc_init+0x23c>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
8000415a:	30 0a       	mov	r10,0
8000415c:	30 0b       	mov	r11,0
8000415e:	4f 58       	lddpc	r8,80004330 <xg_flashc_init+0x240>
80004160:	b1 2a       	st.d	r8++,r10
80004162:	b1 2a       	st.d	r8++,r10
80004164:	b1 2a       	st.d	r8++,r10
80004166:	b1 2a       	st.d	r8++,r10
80004168:	b1 2a       	st.d	r8++,r10
8000416a:	b1 2a       	st.d	r8++,r10
8000416c:	b1 2a       	st.d	r8++,r10
8000416e:	b1 2a       	st.d	r8++,r10
80004170:	b1 2a       	st.d	r8++,r10
80004172:	f0 eb 00 00 	st.d	r8[0],r10
80004176:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80004178:	4e e7       	lddpc	r7,80004330 <xg_flashc_init+0x240>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					log("current_message_index: %d\n", current_message_index);
					memset(str, 0x00, sizeof(str));	
8000417a:	ee c4 ff f8 	sub	r4,r7,-8
8000417e:	e8 c3 ff f8 	sub	r3,r4,-8
80004182:	e6 c2 ff f8 	sub	r2,r3,-8
80004186:	e4 c1 ff f8 	sub	r1,r2,-8
8000418a:	e2 c0 ff f8 	sub	r0,r1,-8
8000418e:	e0 ca ff f8 	sub	r10,r0,-8
80004192:	50 0a       	stdsp	sp[0x0],r10
80004194:	2f 8a       	sub	r10,-8
80004196:	50 1a       	stdsp	sp[0x4],r10
80004198:	2f 8a       	sub	r10,-8
8000419a:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
8000419c:	0e 9a       	mov	r10,r7
8000419e:	30 6b       	mov	r11,6
800041a0:	30 0c       	mov	r12,0
800041a2:	f0 1f 00 65 	mcall	80004334 <xg_flashc_init+0x244>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
800041a6:	30 6a       	mov	r10,6
800041a8:	0e 9b       	mov	r11,r7
800041aa:	4e 4c       	lddpc	r12,80004338 <xg_flashc_init+0x248>
800041ac:	f0 1f 00 64 	mcall	8000433c <xg_flashc_init+0x24c>
800041b0:	c1 c0       	breq	800041e8 <xg_flashc_init+0xf8>
800041b2:	c8 b8       	rjmp	800042c8 <xg_flashc_init+0x1d8>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
800041b4:	30 6a       	mov	r10,6
800041b6:	30 0b       	mov	r11,0
800041b8:	4e 0c       	lddpc	r12,80004338 <xg_flashc_init+0x248>
800041ba:	f0 1f 00 62 	mcall	80004340 <xg_flashc_init+0x250>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
800041be:	4d d7       	lddpc	r7,80004330 <xg_flashc_init+0x240>
800041c0:	35 0a       	mov	r10,80
800041c2:	30 0b       	mov	r11,0
800041c4:	0e 9c       	mov	r12,r7
800041c6:	f0 1f 00 60 	mcall	80004344 <xg_flashc_init+0x254>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
800041ca:	30 2a       	mov	r10,2
800041cc:	30 6b       	mov	r11,6
800041ce:	0e 9c       	mov	r12,r7
800041d0:	f0 1f 00 5c 	mcall	80004340 <xg_flashc_init+0x250>
			if(return_code != DF_WRITE_COMPLETED)
800041d4:	58 7c       	cp.w	r12,7
800041d6:	e0 81 00 90 	brne	800042f6 <xg_flashc_init+0x206>
			{
				return FALSE;
			}
			current_message_index = 0;
800041da:	30 09       	mov	r9,0
800041dc:	4d b8       	lddpc	r8,80004348 <xg_flashc_init+0x258>
800041de:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
800041e0:	4d bc       	lddpc	r12,8000434c <xg_flashc_init+0x25c>
800041e2:	f0 1f 00 4a 	mcall	80004308 <xg_flashc_init+0x218>
800041e6:	c8 58       	rjmp	800042f0 <xg_flashc_init+0x200>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
800041e8:	1a d7       	st.w	--sp,r7
800041ea:	4d ac       	lddpc	r12,80004350 <xg_flashc_init+0x260>
800041ec:	f0 1f 00 47 	mcall	80004308 <xg_flashc_init+0x218>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
800041f0:	4d 6a       	lddpc	r10,80004348 <xg_flashc_init+0x258>
800041f2:	30 2b       	mov	r11,2
800041f4:	30 6c       	mov	r12,6
800041f6:	f0 1f 00 50 	mcall	80004334 <xg_flashc_init+0x244>
			if(return_code == DF_OK)
800041fa:	2f fd       	sub	sp,-4
800041fc:	58 0c       	cp.w	r12,0
800041fe:	e0 81 00 7c 	brne	800042f6 <xg_flashc_init+0x206>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80004202:	4d 28       	lddpc	r8,80004348 <xg_flashc_init+0x258>
80004204:	90 08       	ld.sh	r8,r8[0x0]
80004206:	58 08       	cp.w	r8,0
80004208:	c7 10       	breq	800042ea <xg_flashc_init+0x1fa>
					
					log("current_message_index: %d\n", current_message_index);
8000420a:	5c 78       	castu.h	r8
8000420c:	1a d8       	st.w	--sp,r8
8000420e:	4d 2c       	lddpc	r12,80004354 <xg_flashc_init+0x264>
80004210:	f0 1f 00 3e 	mcall	80004308 <xg_flashc_init+0x218>
					memset(str, 0x00, sizeof(str));	
80004214:	30 08       	mov	r8,0
80004216:	30 09       	mov	r9,0
80004218:	ee e9 00 00 	st.d	r7[0],r8
8000421c:	e8 e9 00 00 	st.d	r4[0],r8
80004220:	e6 e9 00 00 	st.d	r3[0],r8
80004224:	e4 e9 00 00 	st.d	r2[0],r8
80004228:	e2 e9 00 00 	st.d	r1[0],r8
8000422c:	e0 e9 00 00 	st.d	r0[0],r8
80004230:	40 1a       	lddsp	r10,sp[0x4]
80004232:	f4 e9 00 00 	st.d	r10[0],r8
80004236:	40 2a       	lddsp	r10,sp[0x8]
80004238:	f4 e9 00 00 	st.d	r10[0],r8
8000423c:	40 3a       	lddsp	r10,sp[0xc]
8000423e:	b5 28       	st.d	r10++,r8
80004240:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80004244:	4c 18       	lddpc	r8,80004348 <xg_flashc_init+0x258>
80004246:	90 85       	ld.uh	r5,r8[0x0]
80004248:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
8000424a:	0e 9a       	mov	r10,r7
8000424c:	30 8b       	mov	r11,8
8000424e:	0a 9c       	mov	r12,r5
80004250:	f0 1f 00 39 	mcall	80004334 <xg_flashc_init+0x244>
					if(return_code == DF_OK)
80004254:	2f fd       	sub	sp,-4
80004256:	58 0c       	cp.w	r12,0
80004258:	c4 91       	brne	800042ea <xg_flashc_init+0x1fa>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
8000425a:	0f 89       	ld.ub	r9,r7[0x0]
8000425c:	0f 98       	ld.ub	r8,r7[0x1]
8000425e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004262:	4b a9       	lddpc	r9,80004348 <xg_flashc_init+0x258>
80004264:	92 09       	ld.sh	r9,r9[0x0]
80004266:	f0 09 19 00 	cp.h	r9,r8
8000426a:	c2 c1       	brne	800042c2 <xg_flashc_init+0x1d2>
						{
							current_save_message_offset = ptr->address + ptr->offset;
8000426c:	0f e9       	ld.ub	r9,r7[0x6]
8000426e:	0f f8       	ld.ub	r8,r7[0x7]
80004270:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80004274:	0f aa       	ld.ub	r10,r7[0x2]
80004276:	0f b8       	ld.ub	r8,r7[0x3]
80004278:	b1 68       	lsl	r8,0x10
8000427a:	f1 ea 11 88 	or	r8,r8,r10<<0x18
8000427e:	0f ca       	ld.ub	r10,r7[0x4]
80004280:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004284:	0f da       	ld.ub	r10,r7[0x5]
80004286:	f5 e8 10 08 	or	r8,r10,r8
8000428a:	f2 08 00 08 	add	r8,r9,r8
8000428e:	4b 36       	lddpc	r6,80004358 <xg_flashc_init+0x268>
80004290:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80004292:	1a d8       	st.w	--sp,r8
80004294:	4b 2c       	lddpc	r12,8000435c <xg_flashc_init+0x26c>
80004296:	f0 1f 00 1d 	mcall	80004308 <xg_flashc_init+0x218>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
8000429a:	2f fd       	sub	sp,-4
8000429c:	6c 08       	ld.w	r8,r6[0x0]
8000429e:	e0 69 ff ff 	mov	r9,65535
800042a2:	ea 19 00 7f 	orh	r9,0x7f
800042a6:	12 38       	cp.w	r8,r9
800042a8:	e0 88 00 21 	brls	800042ea <xg_flashc_init+0x1fa>
										
								log("\r\n----message storage is full!!!----\r\n");
800042ac:	4a dc       	lddpc	r12,80004360 <xg_flashc_init+0x270>
800042ae:	f0 1f 00 17 	mcall	80004308 <xg_flashc_init+0x218>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
800042b2:	30 4b       	mov	r11,4
800042b4:	30 0c       	mov	r12,0
800042b6:	f0 1f 00 2c 	mcall	80004364 <xg_flashc_init+0x274>
								if(return_code == DF_ERASE_COMPLETED)goto start;
800042ba:	58 5c       	cp.w	r12,5
800042bc:	fe 90 ff 70 	breq	8000419c <xg_flashc_init+0xac>
800042c0:	c1 b8       	rjmp	800042f6 <xg_flashc_init+0x206>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
800042c2:	4a ac       	lddpc	r12,80004368 <xg_flashc_init+0x278>
800042c4:	f0 1f 00 11 	mcall	80004308 <xg_flashc_init+0x218>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800042c8:	30 3b       	mov	r11,3
800042ca:	0a 9c       	mov	r12,r5
800042cc:	f0 1f 00 26 	mcall	80004364 <xg_flashc_init+0x274>
				if(return_code != DF_ERASE_COMPLETED)
800042d0:	58 5c       	cp.w	r12,5
800042d2:	c1 21       	brne	800042f6 <xg_flashc_init+0x206>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800042d4:	30 3b       	mov	r11,3
800042d6:	e0 78 00 00 	mov	r8,65536
800042da:	ea 08 00 0c 	add	r12,r5,r8
800042de:	f0 1f 00 22 	mcall	80004364 <xg_flashc_init+0x274>
				if(return_code != DF_ERASE_COMPLETED)
800042e2:	58 5c       	cp.w	r12,5
800042e4:	fe 90 ff 68 	breq	800041b4 <xg_flashc_init+0xc4>
800042e8:	c0 78       	rjmp	800042f6 <xg_flashc_init+0x206>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
800042ea:	4a 1c       	lddpc	r12,8000436c <xg_flashc_init+0x27c>
800042ec:	f0 1f 00 07 	mcall	80004308 <xg_flashc_init+0x218>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
800042f0:	30 19       	mov	r9,1
800042f2:	4a 08       	lddpc	r8,80004370 <xg_flashc_init+0x280>
800042f4:	b0 89       	st.b	r8[0x0],r9
	//flashc_lock_all_regions(false);
	xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
800042f6:	2f dd       	sub	sp,-12
800042f8:	d8 32       	popm	r0-r7,pc
800042fa:	00 00       	add	r0,r0
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	57 20       	stdsp	sp[0x1c8],r0
80004300:	00 00       	add	r0,r0
80004302:	0a 74       	tst	r4,r5
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	cb 5c       	rcall	80004470 <xgflash_get_message_data+0xfc>
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	62 70       	ld.w	r0,r1[0x1c]
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	57 ec       	stdsp	sp[0x1f8],r12
80004310:	00 00       	add	r0,r0
80004312:	0a 84       	andn	r4,r5
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	cb 88       	rjmp	80004486 <xgflash_get_message_data+0x112>
80004318:	80 00       	ld.sh	r0,r0[0x0]
8000431a:	57 78       	stdsp	sp[0x1dc],r8
8000431c:	00 00       	add	r0,r0
8000431e:	0a 6c       	and	r12,r5
80004320:	00 00       	add	r0,r0
80004322:	0a 7c       	tst	r12,r5
80004324:	00 00       	add	r0,r0
80004326:	1d 24       	ld.uh	r4,lr++
80004328:	80 00       	ld.sh	r0,r0[0x0]
8000432a:	33 10       	mov	r0,49
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	30 60       	mov	r0,6
80004330:	00 00       	add	r0,r0
80004332:	0a 88       	andn	r8,r5
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	2d 04       	sub	r4,-48
80004338:	00 00       	add	r0,r0
8000433a:	05 08       	ld.w	r8,r2++
8000433c:	80 00       	ld.sh	r0,r0[0x0]
8000433e:	69 6c       	ld.w	r12,r4[0x58]
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	2f 3c       	sub	r12,-13
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	6a da       	ld.w	r10,r5[0x34]
80004348:	00 00       	add	r0,r0
8000434a:	0a 80       	andn	r0,r5
8000434c:	80 00       	ld.sh	r0,r0[0x0]
8000434e:	cb b8       	rjmp	800044c4 <xgflash_get_message_data+0x150>
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	cb e4       	brge	800042ce <xg_flashc_init+0x1de>
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	cb f0       	breq	800042d4 <xg_flashc_init+0x1e4>
80004358:	00 00       	add	r0,r0
8000435a:	05 10       	ld.sh	r0,r2++
8000435c:	80 00       	ld.sh	r0,r0[0x0]
8000435e:	cc 0c       	rcall	800044de <xgflash_message_save+0x16>
80004360:	80 00       	ld.sh	r0,r0[0x0]
80004362:	cc 30       	breq	800042e8 <xg_flashc_init+0x1f8>
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	2e 9c       	sub	r12,-23
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	cc 58       	rjmp	800044f4 <xgflash_message_save+0x2c>
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	cc 80       	breq	800042fe <xg_flashc_init+0x20e>
80004370:	00 00       	add	r0,r0
80004372:	0a 70       	tst	r0,r5

80004374 <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
80004374:	d4 31       	pushm	r0-r7,lr
80004376:	20 2d       	sub	sp,8
80004378:	18 95       	mov	r5,r12
8000437a:	16 96       	mov	r6,r11
8000437c:	14 91       	mov	r1,r10
	if(!list_init_success_flag)return XG_ERROR;
8000437e:	4c b8       	lddpc	r8,800044a8 <xgflash_get_message_data+0x134>
80004380:	11 89       	ld.ub	r9,r8[0x0]
80004382:	30 08       	mov	r8,0
80004384:	f0 09 18 00 	cp.b	r9,r8
80004388:	c0 31       	brne	8000438e <xgflash_get_message_data+0x1a>
8000438a:	3f fc       	mov	r12,-1
8000438c:	c8 b8       	rjmp	800044a2 <xgflash_get_message_data+0x12e>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
8000438e:	4c 88       	lddpc	r8,800044ac <xgflash_get_message_data+0x138>
80004390:	70 0c       	ld.w	r12,r8[0x0]
80004392:	30 09       	mov	r9,0
80004394:	3f fa       	mov	r10,-1
80004396:	12 9b       	mov	r11,r9
80004398:	f0 1f 00 46 	mcall	800044b0 <xgflash_get_message_data+0x13c>
	/* check input parameter */
	if (message_index > current_message_index)
8000439c:	4c 68       	lddpc	r8,800044b4 <xgflash_get_message_data+0x140>
8000439e:	90 88       	ld.uh	r8,r8[0x0]
800043a0:	0a 38       	cp.w	r8,r5
800043a2:	c0 a2       	brcc	800043b6 <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
800043a4:	4c 28       	lddpc	r8,800044ac <xgflash_get_message_data+0x138>
800043a6:	70 0c       	ld.w	r12,r8[0x0]
800043a8:	30 09       	mov	r9,0
800043aa:	12 9a       	mov	r10,r9
800043ac:	12 9b       	mov	r11,r9
800043ae:	f0 1f 00 43 	mcall	800044b8 <xgflash_get_message_data+0x144>
800043b2:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
800043b4:	c7 78       	rjmp	800044a2 <xgflash_get_message_data+0x12e>
	
	df_status_t return_code = DF_OK;
	U32 info_address =0x00000000;
	U32 data_address =0x00000000;
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
800043b6:	fa ca ff f8 	sub	r10,sp,-8
800043ba:	30 08       	mov	r8,0
800043bc:	30 09       	mov	r9,0
800043be:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
800043c0:	ea 00 15 03 	lsl	r0,r5,0x3
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
800043c4:	1a 9a       	mov	r10,sp
800043c6:	30 8b       	mov	r11,8
800043c8:	00 9c       	mov	r12,r0
800043ca:	f0 1f 00 3d 	mcall	800044bc <xgflash_get_message_data+0x148>
	if (return_code == DF_OK)
800043ce:	c6 21       	brne	80004492 <xgflash_get_message_data+0x11e>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
800043d0:	9a 88       	ld.uh	r8,sp[0x0]
800043d2:	0a 38       	cp.w	r8,r5
800043d4:	c5 61       	brne	80004480 <xgflash_get_message_data+0x10c>
		{
			bytes_remained = ptr->offset;
800043d6:	40 18       	lddsp	r8,sp[0x4]
800043d8:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			data_address = ptr->address;
800043dc:	9a 95       	ld.uh	r5,sp[0x2]
800043de:	b1 88       	lsr	r8,0x10
800043e0:	f1 e5 11 05 	or	r5,r8,r5<<0x10
			
			while (bytes_remained >= 1 && return_code == DF_OK)
800043e4:	30 04       	mov	r4,0
800043e6:	08 93       	mov	r3,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
800043e8:	e0 62 01 ff 	mov	r2,511
		if(ptr->numb == message_index)
		{
			bytes_remained = ptr->offset;
			data_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
800043ec:	c1 88       	rjmp	8000441c <xgflash_get_message_data+0xa8>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
800043ee:	e4 07 19 00 	cp.h	r7,r2
800043f2:	e0 8b 00 0a 	brhi	80004406 <xgflash_get_message_data+0x92>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
800043f6:	0c 9a       	mov	r10,r6
800043f8:	0e 9b       	mov	r11,r7
800043fa:	5c 7b       	castu.h	r11
800043fc:	0a 9c       	mov	r12,r5
800043fe:	f0 1f 00 30 	mcall	800044bc <xgflash_get_message_data+0x148>
80004402:	30 07       	mov	r7,0
80004404:	c0 c8       	rjmp	8000441c <xgflash_get_message_data+0xa8>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80004406:	0c 9a       	mov	r10,r6
80004408:	e0 6b 02 00 	mov	r11,512
8000440c:	0a 9c       	mov	r12,r5
8000440e:	f0 1f 00 2c 	mcall	800044bc <xgflash_get_message_data+0x148>
					bytes_remained-=DF_DATA_SPACE_SIZE;
80004412:	ee c7 02 00 	sub	r7,r7,512
80004416:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
80004418:	ea c5 fe 00 	sub	r5,r5,-512
		if(ptr->numb == message_index)
		{
			bytes_remained = ptr->offset;
			data_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
8000441c:	e8 07 19 00 	cp.h	r7,r4
80004420:	5f 19       	srne	r9
80004422:	58 0c       	cp.w	r12,0
80004424:	5f 08       	sreq	r8
80004426:	f3 e8 00 08 	and	r8,r9,r8
8000442a:	e6 08 18 00 	cp.b	r8,r3
8000442e:	ce 01       	brne	800043ee <xgflash_get_message_data+0x7a>
						
				}
				//memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
			}
			
			if(erase)//erase the message
80004430:	58 01       	cp.w	r1,0
80004432:	c1 e0       	breq	8000446e <xgflash_get_message_data+0xfa>
			{
				//erase data and reset:current_save_message_offset
				memset(str, 0x00, sizeof(str));
80004434:	fa c6 ff f8 	sub	r6,sp,-8
80004438:	30 08       	mov	r8,0
8000443a:	30 09       	mov	r9,0
8000443c:	ad 29       	st.d	--r6,r8
				return_code = data_flash_write((U8 *)str, data_address, bytes_remained);
8000443e:	5c 77       	castu.h	r7
80004440:	0e 9a       	mov	r10,r7
80004442:	0a 9b       	mov	r11,r5
80004444:	1a 9c       	mov	r12,sp
80004446:	f0 1f 00 1f 	mcall	800044c0 <xgflash_get_message_data+0x14c>
				current_save_message_offset-=bytes_remained;
8000444a:	49 f8       	lddpc	r8,800044c4 <xgflash_get_message_data+0x150>
8000444c:	70 09       	ld.w	r9,r8[0x0]
8000444e:	0e 19       	sub	r9,r7
80004450:	91 09       	st.w	r8[0x0],r9
				//erase info and reset:current_message_index
				current_message_index-=1;
80004452:	49 97       	lddpc	r7,800044b4 <xgflash_get_message_data+0x140>
80004454:	8e 08       	ld.sh	r8,r7[0x0]
80004456:	20 18       	sub	r8,1
80004458:	ae 08       	st.h	r7[0x0],r8
				return_code = data_flash_write((U8 *)str, info_address, XG_MESSAGE_INFO_HEADER_LENGTH);
8000445a:	30 8a       	mov	r10,8
8000445c:	00 9b       	mov	r11,r0
8000445e:	1a 9c       	mov	r12,sp
80004460:	f0 1f 00 18 	mcall	800044c0 <xgflash_get_message_data+0x14c>
				return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, XG_MESSAGE_INFO_HEADER_LENGTH);
80004464:	30 8a       	mov	r10,8
80004466:	30 6b       	mov	r11,6
80004468:	0e 9c       	mov	r12,r7
8000446a:	f0 1f 00 16 	mcall	800044c0 <xgflash_get_message_data+0x14c>
			}
		
			xSemaphoreGive(xgflash_mutex);//unlock
8000446e:	49 08       	lddpc	r8,800044ac <xgflash_get_message_data+0x138>
80004470:	70 0c       	ld.w	r12,r8[0x0]
80004472:	30 09       	mov	r9,0
80004474:	12 9a       	mov	r10,r9
80004476:	12 9b       	mov	r11,r9
80004478:	f0 1f 00 10 	mcall	800044b8 <xgflash_get_message_data+0x144>
8000447c:	30 0c       	mov	r12,0
			return XG_OK;
8000447e:	c1 28       	rjmp	800044a2 <xgflash_get_message_data+0x12e>
		}
		xSemaphoreGive(xgflash_mutex);//unlock
80004480:	48 b8       	lddpc	r8,800044ac <xgflash_get_message_data+0x138>
80004482:	70 0c       	ld.w	r12,r8[0x0]
80004484:	30 09       	mov	r9,0
80004486:	12 9a       	mov	r10,r9
80004488:	12 9b       	mov	r11,r9
8000448a:	f0 1f 00 0c 	mcall	800044b8 <xgflash_get_message_data+0x144>
8000448e:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
80004490:	c0 98       	rjmp	800044a2 <xgflash_get_message_data+0x12e>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
80004492:	48 78       	lddpc	r8,800044ac <xgflash_get_message_data+0x138>
80004494:	70 0c       	ld.w	r12,r8[0x0]
80004496:	30 09       	mov	r9,0
80004498:	12 9a       	mov	r10,r9
8000449a:	12 9b       	mov	r11,r9
8000449c:	f0 1f 00 07 	mcall	800044b8 <xgflash_get_message_data+0x144>
800044a0:	30 6c       	mov	r12,6
	return XG_FLASH_ACTION_FAIL;
		
}
800044a2:	2f ed       	sub	sp,-8
800044a4:	d8 32       	popm	r0-r7,pc
800044a6:	00 00       	add	r0,r0
800044a8:	00 00       	add	r0,r0
800044aa:	0a 70       	tst	r0,r5
800044ac:	00 00       	add	r0,r0
800044ae:	0a 74       	tst	r4,r5
800044b0:	80 00       	ld.sh	r0,r0[0x0]
800044b2:	54 64       	stdsp	sp[0x118],r4
800044b4:	00 00       	add	r0,r0
800044b6:	0a 80       	andn	r0,r5
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	56 20       	stdsp	sp[0x188],r0
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	2d 04       	sub	r4,-48
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	2f 3c       	sub	r12,-13
800044c4:	00 00       	add	r0,r0
800044c6:	05 10       	ld.sh	r0,r2++

800044c8 <xgflash_message_save>:
	
}

static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
800044c8:	d4 21       	pushm	r4-r7,lr
800044ca:	20 2d       	sub	sp,8
800044cc:	18 96       	mov	r6,r12
800044ce:	16 97       	mov	r7,r11
800044d0:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
800044d2:	4c d8       	lddpc	r8,80004604 <xgflash_message_save+0x13c>
800044d4:	11 89       	ld.ub	r9,r8[0x0]
800044d6:	30 08       	mov	r8,0
800044d8:	f0 09 18 00 	cp.b	r9,r8
800044dc:	c0 31       	brne	800044e2 <xgflash_message_save+0x1a>
800044de:	3f fc       	mov	r12,-1
800044e0:	c8 f8       	rjmp	800045fe <xgflash_message_save+0x136>
	U32 address = 0;
	static U32 bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
		
	current_bytes_remained+=data_len;//accumulate
800044e2:	16 94       	mov	r4,r11
800044e4:	5c 74       	castu.h	r4
800044e6:	4c 98       	lddpc	r8,80004608 <xgflash_message_save+0x140>
800044e8:	70 09       	ld.w	r9,r8[0x0]
800044ea:	e8 09 00 09 	add	r9,r4,r9
800044ee:	91 09       	st.w	r8[0x0],r9
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
800044f0:	58 0c       	cp.w	r12,0
800044f2:	5f 0a       	sreq	r10
800044f4:	e0 68 02 00 	mov	r8,512
800044f8:	f0 0b 19 00 	cp.h	r11,r8
800044fc:	5f b8       	srhi	r8
800044fe:	f5 e8 10 08 	or	r8,r10,r8
80004502:	e0 81 00 7d 	brne	800045fc <xgflash_message_save+0x134>
	{
		return XG_INVALID_PARAM;
	}
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
80004506:	e0 49 f0 00 	cp.w	r9,61440
8000450a:	e0 8b 00 79 	brhi	800045fc <xgflash_message_save+0x134>
	{
		//current_bytes_remained = 0;
		return XG_INVALID_PARAM;
	}
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock
8000450e:	4c 08       	lddpc	r8,8000460c <xgflash_message_save+0x144>
80004510:	70 0c       	ld.w	r12,r8[0x0]
80004512:	30 09       	mov	r9,0
80004514:	3f fa       	mov	r10,-1
80004516:	12 9b       	mov	r11,r9
80004518:	f0 1f 00 3e 	mcall	80004610 <xgflash_message_save+0x148>
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
8000451c:	4b e8       	lddpc	r8,80004614 <xgflash_message_save+0x14c>
8000451e:	70 0b       	ld.w	r11,r8[0x0]
80004520:	e0 68 ff ff 	mov	r8,65535
80004524:	ea 18 00 7f 	orh	r8,0x7f
80004528:	10 3b       	cp.w	r11,r8
8000452a:	e0 88 00 0e 	brls	80004546 <xgflash_message_save+0x7e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
8000452e:	4b bc       	lddpc	r12,80004618 <xgflash_message_save+0x150>
80004530:	f0 1f 00 3b 	mcall	8000461c <xgflash_message_save+0x154>
		xSemaphoreGive(xgflash_mutex );//unlock
80004534:	4b 68       	lddpc	r8,8000460c <xgflash_message_save+0x144>
80004536:	70 0c       	ld.w	r12,r8[0x0]
80004538:	30 09       	mov	r9,0
8000453a:	12 9a       	mov	r10,r9
8000453c:	12 9b       	mov	r11,r9
8000453e:	f0 1f 00 39 	mcall	80004620 <xgflash_message_save+0x158>
80004542:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
80004544:	c5 d8       	rjmp	800045fe <xgflash_message_save+0x136>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
80004546:	0e 9a       	mov	r10,r7
80004548:	5c 7a       	castu.h	r10
8000454a:	0c 9c       	mov	r12,r6
8000454c:	f0 1f 00 36 	mcall	80004624 <xgflash_message_save+0x15c>
	if(return_code != DF_WRITE_COMPLETED)
80004550:	58 7c       	cp.w	r12,7
80004552:	c0 a0       	breq	80004566 <xgflash_message_save+0x9e>
	{
		xSemaphoreGive(xgflash_mutex );//unlock
80004554:	4a e8       	lddpc	r8,8000460c <xgflash_message_save+0x144>
80004556:	70 0c       	ld.w	r12,r8[0x0]
80004558:	30 09       	mov	r9,0
8000455a:	12 9a       	mov	r10,r9
8000455c:	12 9b       	mov	r11,r9
8000455e:	f0 1f 00 31 	mcall	80004620 <xgflash_message_save+0x158>
80004562:	30 6c       	mov	r12,6
		return XG_FLASH_ACTION_FAIL;
80004564:	c4 d8       	rjmp	800045fe <xgflash_message_save+0x136>
	}
	
	current_save_message_offset+=data_len;
80004566:	4a c8       	lddpc	r8,80004614 <xgflash_message_save+0x14c>
80004568:	70 09       	ld.w	r9,r8[0x0]
8000456a:	12 04       	add	r4,r9
8000456c:	91 04       	st.w	r8[0x0],r4
	//log("current_save_message_offset : %X\n", current_save_message_offset);
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
8000456e:	30 18       	mov	r8,1
80004570:	f0 05 18 00 	cp.b	r5,r8
80004574:	c3 b1       	brne	800045ea <xgflash_message_save+0x122>
	{
		current_message_index++;
80004576:	4a d9       	lddpc	r9,80004628 <xgflash_message_save+0x160>
80004578:	92 08       	ld.sh	r8,r9[0x0]
8000457a:	2f f8       	sub	r8,-1
8000457c:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
8000457e:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
80004580:	4a 29       	lddpc	r9,80004608 <xgflash_message_save+0x140>
80004582:	72 09       	ld.w	r9,r9[0x0]
80004584:	12 14       	sub	r4,r9
80004586:	40 0a       	lddsp	r10,sp[0x0]
80004588:	e0 1a 00 00 	andl	r10,0x0
8000458c:	f5 e4 13 0a 	or	r10,r10,r4>>0x10
80004590:	50 0a       	stdsp	sp[0x0],r10
80004592:	ba 24       	st.h	sp[0x4],r4
		ptr.offset		= current_bytes_remained;
80004594:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80004596:	5c 78       	castu.h	r8
80004598:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
8000459c:	e2 4b 00 00 	cp.w	r11,131072
800045a0:	e0 88 00 0e 	brls	800045bc <xgflash_message_save+0xf4>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
800045a4:	4a 2c       	lddpc	r12,8000462c <xgflash_message_save+0x164>
800045a6:	f0 1f 00 1e 	mcall	8000461c <xgflash_message_save+0x154>
			xSemaphoreGive(xgflash_mutex );//unlock
800045aa:	49 98       	lddpc	r8,8000460c <xgflash_message_save+0x144>
800045ac:	70 0c       	ld.w	r12,r8[0x0]
800045ae:	30 09       	mov	r9,0
800045b0:	12 9a       	mov	r10,r9
800045b2:	12 9b       	mov	r11,r9
800045b4:	f0 1f 00 1b 	mcall	80004620 <xgflash_message_save+0x158>
800045b8:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
800045ba:	c2 28       	rjmp	800045fe <xgflash_message_save+0x136>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
800045bc:	30 8a       	mov	r10,8
800045be:	1a 9c       	mov	r12,sp
800045c0:	f0 1f 00 19 	mcall	80004624 <xgflash_message_save+0x15c>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
800045c4:	30 2a       	mov	r10,2
800045c6:	30 6b       	mov	r11,6
800045c8:	49 8c       	lddpc	r12,80004628 <xgflash_message_save+0x160>
800045ca:	f0 1f 00 17 	mcall	80004624 <xgflash_message_save+0x15c>
		if(return_code != DF_WRITE_COMPLETED)
800045ce:	58 7c       	cp.w	r12,7
800045d0:	c0 a0       	breq	800045e4 <xgflash_message_save+0x11c>
		{
			xSemaphoreGive(xgflash_mutex );//unlock
800045d2:	48 f8       	lddpc	r8,8000460c <xgflash_message_save+0x144>
800045d4:	70 0c       	ld.w	r12,r8[0x0]
800045d6:	30 09       	mov	r9,0
800045d8:	12 9a       	mov	r10,r9
800045da:	12 9b       	mov	r11,r9
800045dc:	f0 1f 00 11 	mcall	80004620 <xgflash_message_save+0x158>
800045e0:	30 6c       	mov	r12,6
			return XG_FLASH_ACTION_FAIL;
800045e2:	c0 e8       	rjmp	800045fe <xgflash_message_save+0x136>
		}
		
		current_bytes_remained = 0;//reset 0
800045e4:	30 09       	mov	r9,0
800045e6:	48 98       	lddpc	r8,80004608 <xgflash_message_save+0x140>
800045e8:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
800045ea:	48 98       	lddpc	r8,8000460c <xgflash_message_save+0x144>
800045ec:	70 0c       	ld.w	r12,r8[0x0]
800045ee:	30 09       	mov	r9,0
800045f0:	12 9a       	mov	r10,r9
800045f2:	12 9b       	mov	r11,r9
800045f4:	f0 1f 00 0b 	mcall	80004620 <xgflash_message_save+0x158>
800045f8:	30 0c       	mov	r12,0
	return XG_OK;
800045fa:	c0 28       	rjmp	800045fe <xgflash_message_save+0x136>
800045fc:	30 1c       	mov	r12,1

}
800045fe:	2f ed       	sub	sp,-8
80004600:	d8 22       	popm	r4-r7,pc
80004602:	00 00       	add	r0,r0
80004604:	00 00       	add	r0,r0
80004606:	0a 70       	tst	r0,r5
80004608:	00 00       	add	r0,r0
8000460a:	0a 78       	tst	r8,r5
8000460c:	00 00       	add	r0,r0
8000460e:	0a 74       	tst	r4,r5
80004610:	80 00       	ld.sh	r0,r0[0x0]
80004612:	54 64       	stdsp	sp[0x118],r4
80004614:	00 00       	add	r0,r0
80004616:	05 10       	ld.sh	r0,r2++
80004618:	80 00       	ld.sh	r0,r0[0x0]
8000461a:	cc bc       	rcall	800047b0 <INTC_register_interrupt+0x50>
8000461c:	80 00       	ld.sh	r0,r0[0x0]
8000461e:	62 70       	ld.w	r0,r1[0x1c]
80004620:	80 00       	ld.sh	r0,r0[0x0]
80004622:	56 20       	stdsp	sp[0x188],r0
80004624:	80 00       	ld.sh	r0,r0[0x0]
80004626:	2f 3c       	sub	r12,-13
80004628:	00 00       	add	r0,r0
8000462a:	0a 80       	andn	r0,r5
8000462c:	80 00       	ld.sh	r0,r0[0x0]
8000462e:	cc ec       	rcall	800047ca <INTC_register_interrupt+0x6a>

80004630 <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
80004630:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
80004634:	48 d8       	lddpc	r8,80004668 <xgflash_get_message_count+0x38>
80004636:	11 89       	ld.ub	r9,r8[0x0]
80004638:	30 08       	mov	r8,0
8000463a:	f0 09 18 00 	cp.b	r9,r8
8000463e:	c0 31       	brne	80004644 <xgflash_get_message_count+0x14>
80004640:	3f f7       	mov	r7,-1
80004642:	c1 08       	rjmp	80004662 <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
80004644:	48 a6       	lddpc	r6,8000466c <xgflash_get_message_count+0x3c>
80004646:	6c 0c       	ld.w	r12,r6[0x0]
80004648:	30 09       	mov	r9,0
8000464a:	3f fa       	mov	r10,-1
8000464c:	12 9b       	mov	r11,r9
8000464e:	f0 1f 00 09 	mcall	80004670 <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
80004652:	48 98       	lddpc	r8,80004674 <xgflash_get_message_count+0x44>
80004654:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
80004656:	6c 0c       	ld.w	r12,r6[0x0]
80004658:	30 09       	mov	r9,0
8000465a:	12 9a       	mov	r10,r9
8000465c:	12 9b       	mov	r11,r9
8000465e:	f0 1f 00 07 	mcall	80004678 <xgflash_get_message_count+0x48>

	return return_value;
	
}
80004662:	0e 9c       	mov	r12,r7
80004664:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004668:	00 00       	add	r0,r0
8000466a:	0a 70       	tst	r0,r5
8000466c:	00 00       	add	r0,r0
8000466e:	0a 74       	tst	r4,r5
80004670:	80 00       	ld.sh	r0,r0[0x0]
80004672:	54 64       	stdsp	sp[0x118],r4
80004674:	00 00       	add	r0,r0
80004676:	0a 80       	andn	r0,r5
80004678:	80 00       	ld.sh	r0,r0[0x0]
8000467a:	56 20       	stdsp	sp[0x188],r0

8000467c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000467c:	fe 68 14 00 	mov	r8,-125952
80004680:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80004682:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80004686:	91 09       	st.w	r8[0x0],r9
}
80004688:	5e fc       	retal	r12

8000468a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000468a:	f8 08 16 05 	lsr	r8,r12,0x5
8000468e:	a9 68       	lsl	r8,0x8
80004690:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80004694:	58 1b       	cp.w	r11,1
80004696:	c0 d0       	breq	800046b0 <gpio_enable_module_pin+0x26>
80004698:	c0 63       	brcs	800046a4 <gpio_enable_module_pin+0x1a>
8000469a:	58 2b       	cp.w	r11,2
8000469c:	c1 00       	breq	800046bc <gpio_enable_module_pin+0x32>
8000469e:	58 3b       	cp.w	r11,3
800046a0:	c1 40       	breq	800046c8 <gpio_enable_module_pin+0x3e>
800046a2:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800046a4:	30 19       	mov	r9,1
800046a6:	f2 0c 09 49 	lsl	r9,r9,r12
800046aa:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800046ac:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800046ae:	c1 28       	rjmp	800046d2 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800046b0:	30 19       	mov	r9,1
800046b2:	f2 0c 09 49 	lsl	r9,r9,r12
800046b6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800046b8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800046ba:	c0 c8       	rjmp	800046d2 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800046bc:	30 19       	mov	r9,1
800046be:	f2 0c 09 49 	lsl	r9,r9,r12
800046c2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800046c4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800046c6:	c0 68       	rjmp	800046d2 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800046c8:	30 19       	mov	r9,1
800046ca:	f2 0c 09 49 	lsl	r9,r9,r12
800046ce:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800046d0:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800046d2:	30 19       	mov	r9,1
800046d4:	f2 0c 09 4c 	lsl	r12,r9,r12
800046d8:	91 2c       	st.w	r8[0x8],r12
800046da:	5e fd       	retal	0

800046dc <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800046dc:	d4 21       	pushm	r4-r7,lr
800046de:	18 97       	mov	r7,r12
800046e0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800046e2:	58 0b       	cp.w	r11,0
800046e4:	c0 31       	brne	800046ea <gpio_enable_module+0xe>
800046e6:	30 05       	mov	r5,0
800046e8:	c0 d8       	rjmp	80004702 <gpio_enable_module+0x26>
800046ea:	30 06       	mov	r6,0
800046ec:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800046ee:	6e 1b       	ld.w	r11,r7[0x4]
800046f0:	6e 0c       	ld.w	r12,r7[0x0]
800046f2:	f0 1f 00 06 	mcall	80004708 <gpio_enable_module+0x2c>
800046f6:	18 45       	or	r5,r12
		gpiomap++;
800046f8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800046fa:	2f f6       	sub	r6,-1
800046fc:	0c 34       	cp.w	r4,r6
800046fe:	fe 9b ff f8 	brhi	800046ee <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004702:	0a 9c       	mov	r12,r5
80004704:	d8 22       	popm	r4-r7,pc
80004706:	00 00       	add	r0,r0
80004708:	80 00       	ld.sh	r0,r0[0x0]
8000470a:	46 8a       	lddsp	r10,sp[0x1a0]

8000470c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000470c:	f8 08 16 05 	lsr	r8,r12,0x5
80004710:	a9 68       	lsl	r8,0x8
80004712:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80004716:	30 19       	mov	r9,1
80004718:	f2 0c 09 4c 	lsl	r12,r9,r12
8000471c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80004720:	91 1c       	st.w	r8[0x4],r12
}
80004722:	5e fc       	retal	r12

80004724 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004724:	f8 08 16 05 	lsr	r8,r12,0x5
80004728:	a9 68       	lsl	r8,0x8
8000472a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000472e:	30 19       	mov	r9,1
80004730:	f2 0c 09 4c 	lsl	r12,r9,r12
80004734:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004738:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000473c:	91 1c       	st.w	r8[0x4],r12
}
8000473e:	5e fc       	retal	r12

80004740 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004740:	f8 08 16 05 	lsr	r8,r12,0x5
80004744:	a9 68       	lsl	r8,0x8
80004746:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000474a:	30 19       	mov	r9,1
8000474c:	f2 0c 09 4c 	lsl	r12,r9,r12
80004750:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80004754:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004758:	91 1c       	st.w	r8[0x4],r12
}
8000475a:	5e fc       	retal	r12

8000475c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000475c:	c0 08       	rjmp	8000475c <_unhandled_interrupt>
8000475e:	d7 03       	nop

80004760 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004760:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004764:	49 99       	lddpc	r9,800047c8 <INTC_register_interrupt+0x68>
80004766:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000476a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000476e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004770:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004774:	58 0a       	cp.w	r10,0
80004776:	c0 91       	brne	80004788 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004778:	49 59       	lddpc	r9,800047cc <INTC_register_interrupt+0x6c>
8000477a:	49 6a       	lddpc	r10,800047d0 <INTC_register_interrupt+0x70>
8000477c:	12 1a       	sub	r10,r9
8000477e:	fe 79 08 00 	mov	r9,-63488
80004782:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004786:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004788:	58 1a       	cp.w	r10,1
8000478a:	c0 a1       	brne	8000479e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000478c:	49 09       	lddpc	r9,800047cc <INTC_register_interrupt+0x6c>
8000478e:	49 2a       	lddpc	r10,800047d4 <INTC_register_interrupt+0x74>
80004790:	12 1a       	sub	r10,r9
80004792:	bf aa       	sbr	r10,0x1e
80004794:	fe 79 08 00 	mov	r9,-63488
80004798:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000479c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000479e:	58 2a       	cp.w	r10,2
800047a0:	c0 a1       	brne	800047b4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800047a2:	48 b9       	lddpc	r9,800047cc <INTC_register_interrupt+0x6c>
800047a4:	48 da       	lddpc	r10,800047d8 <INTC_register_interrupt+0x78>
800047a6:	12 1a       	sub	r10,r9
800047a8:	bf ba       	sbr	r10,0x1f
800047aa:	fe 79 08 00 	mov	r9,-63488
800047ae:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800047b2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800047b4:	48 69       	lddpc	r9,800047cc <INTC_register_interrupt+0x6c>
800047b6:	48 aa       	lddpc	r10,800047dc <INTC_register_interrupt+0x7c>
800047b8:	12 1a       	sub	r10,r9
800047ba:	ea 1a c0 00 	orh	r10,0xc000
800047be:	fe 79 08 00 	mov	r9,-63488
800047c2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800047c6:	5e fc       	retal	r12
800047c8:	80 00       	ld.sh	r0,r0[0x0]
800047ca:	cd 94       	brge	8000477c <INTC_register_interrupt+0x1c>
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	c0 00       	breq	800047ce <INTC_register_interrupt+0x6e>
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	c1 04       	brge	800047f2 <INTC_init_interrupts+0x12>
800047d4:	80 00       	ld.sh	r0,r0[0x0]
800047d6:	c1 12       	brcc	800047f8 <INTC_init_interrupts+0x18>
800047d8:	80 00       	ld.sh	r0,r0[0x0]
800047da:	c1 20       	breq	800047fe <INTC_init_interrupts+0x1e>
800047dc:	80 00       	ld.sh	r0,r0[0x0]
800047de:	c1 2e       	rcall	80004402 <xgflash_get_message_data+0x8e>

800047e0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800047e0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800047e2:	49 18       	lddpc	r8,80004824 <INTC_init_interrupts+0x44>
800047e4:	e3 b8 00 01 	mtsr	0x4,r8
800047e8:	49 0e       	lddpc	lr,80004828 <INTC_init_interrupts+0x48>
800047ea:	30 07       	mov	r7,0
800047ec:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800047ee:	49 0c       	lddpc	r12,8000482c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800047f0:	49 05       	lddpc	r5,80004830 <INTC_init_interrupts+0x50>
800047f2:	10 15       	sub	r5,r8
800047f4:	fe 76 08 00 	mov	r6,-63488
800047f8:	c1 08       	rjmp	80004818 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800047fa:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800047fc:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800047fe:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004800:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004804:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004806:	10 3a       	cp.w	r10,r8
80004808:	fe 9b ff fc 	brhi	80004800 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000480c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004810:	2f f7       	sub	r7,-1
80004812:	2f 8e       	sub	lr,-8
80004814:	59 37       	cp.w	r7,19
80004816:	c0 50       	breq	80004820 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004818:	7c 08       	ld.w	r8,lr[0x0]
8000481a:	58 08       	cp.w	r8,0
8000481c:	ce f1       	brne	800047fa <INTC_init_interrupts+0x1a>
8000481e:	cf 7b       	rjmp	8000480c <INTC_init_interrupts+0x2c>
80004820:	d8 22       	popm	r4-r7,pc
80004822:	00 00       	add	r0,r0
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	c0 00       	breq	80004826 <INTC_init_interrupts+0x46>
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	cd 94       	brge	800047dc <INTC_register_interrupt+0x7c>
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	47 5c       	lddsp	r12,sp[0x1d4]
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	c1 04       	brge	80004852 <_get_interrupt_handler+0x1e>

80004834 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004834:	fe 78 08 00 	mov	r8,-63488
80004838:	e0 69 00 83 	mov	r9,131
8000483c:	f2 0c 01 0c 	sub	r12,r9,r12
80004840:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004844:	f2 ca ff c0 	sub	r10,r9,-64
80004848:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000484c:	58 08       	cp.w	r8,0
8000484e:	c0 21       	brne	80004852 <_get_interrupt_handler+0x1e>
80004850:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004852:	f0 08 12 00 	clz	r8,r8
80004856:	48 5a       	lddpc	r10,80004868 <_get_interrupt_handler+0x34>
80004858:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000485c:	f0 08 11 1f 	rsub	r8,r8,31
80004860:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004862:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004866:	5e fc       	retal	r12
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	cd 94       	brge	8000481c <INTC_init_interrupts+0x3c>

8000486c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000486c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000486e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80004872:	99 a8       	st.w	r12[0x28],r8
}
80004874:	5e fc       	retal	r12
80004876:	d7 03       	nop

80004878 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80004878:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000487a:	ec 5b bb 9f 	cp.w	r11,899999
8000487e:	e0 8b 00 04 	brhi	80004886 <pm_enable_osc0_crystal+0xe>
80004882:	30 4b       	mov	r11,4
80004884:	c1 38       	rjmp	800048aa <pm_enable_osc0_crystal+0x32>
80004886:	e0 68 c6 bf 	mov	r8,50879
8000488a:	ea 18 00 2d 	orh	r8,0x2d
8000488e:	10 3b       	cp.w	r11,r8
80004890:	e0 8b 00 04 	brhi	80004898 <pm_enable_osc0_crystal+0x20>
80004894:	30 5b       	mov	r11,5
80004896:	c0 a8       	rjmp	800048aa <pm_enable_osc0_crystal+0x32>
80004898:	e0 68 12 00 	mov	r8,4608
8000489c:	ea 18 00 7a 	orh	r8,0x7a
800048a0:	10 3b       	cp.w	r11,r8
800048a2:	f9 bb 03 06 	movlo	r11,6
800048a6:	f9 bb 02 07 	movhs	r11,7
800048aa:	f0 1f 00 02 	mcall	800048b0 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800048ae:	d8 02       	popm	pc
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	48 6c       	lddpc	r12,800048c8 <pm_wait_for_clk0_ready+0x4>

800048b4 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800048b4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800048b6:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800048ba:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800048bc:	78 08       	ld.w	r8,r12[0x0]
800048be:	a3 a8       	sbr	r8,0x2
800048c0:	99 08       	st.w	r12[0x0],r8
}
800048c2:	5e fc       	retal	r12

800048c4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800048c4:	79 58       	ld.w	r8,r12[0x54]
800048c6:	e2 18 00 80 	andl	r8,0x80,COH
800048ca:	cf d0       	breq	800048c4 <pm_wait_for_clk0_ready>
}
800048cc:	5e fc       	retal	r12
800048ce:	d7 03       	nop

800048d0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800048d0:	eb cd 40 80 	pushm	r7,lr
800048d4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800048d6:	f0 1f 00 04 	mcall	800048e4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800048da:	0e 9c       	mov	r12,r7
800048dc:	f0 1f 00 03 	mcall	800048e8 <pm_enable_clk0+0x18>
}
800048e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	48 b4       	lddpc	r4,80004910 <pm_enable_clk32_no_wait+0x8>
800048e8:	80 00       	ld.sh	r0,r0[0x0]
800048ea:	48 c4       	lddpc	r4,80004918 <pm_wait_for_clk32_ready>

800048ec <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800048ec:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800048ee:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800048f2:	99 c8       	st.w	r12[0x30],r8
}
800048f4:	5e fc       	retal	r12
800048f6:	d7 03       	nop

800048f8 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
800048f8:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
800048fa:	30 1b       	mov	r11,1
800048fc:	f0 1f 00 02 	mcall	80004904 <pm_enable_osc32_crystal+0xc>
}
80004900:	d8 02       	popm	pc
80004902:	00 00       	add	r0,r0
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	48 ec       	lddpc	r12,8000493c <pm_enable_clk32+0x18>

80004908 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80004908:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
8000490a:	30 19       	mov	r9,1
8000490c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80004910:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80004914:	99 c8       	st.w	r12[0x30],r8
}
80004916:	5e fc       	retal	r12

80004918 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80004918:	79 58       	ld.w	r8,r12[0x54]
8000491a:	e2 18 02 00 	andl	r8,0x200,COH
8000491e:	cf d0       	breq	80004918 <pm_wait_for_clk32_ready>
}
80004920:	5e fc       	retal	r12
80004922:	d7 03       	nop

80004924 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80004924:	eb cd 40 80 	pushm	r7,lr
80004928:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000492a:	f0 1f 00 04 	mcall	80004938 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000492e:	0e 9c       	mov	r12,r7
80004930:	f0 1f 00 03 	mcall	8000493c <pm_enable_clk32+0x18>
}
80004934:	e3 cd 80 80 	ldm	sp++,r7,pc
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	49 08       	lddpc	r8,80004978 <pm_cksel+0x38>
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	49 18       	lddpc	r8,80004980 <pm_cksel+0x40>

80004940 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80004940:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80004944:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80004948:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000494a:	09 f7       	ld.ub	r7,r4[0x7]
8000494c:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80004950:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80004954:	09 b4       	ld.ub	r4,r4[0x3]
80004956:	08 96       	mov	r6,r4
80004958:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
8000495c:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80004960:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80004964:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80004968:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000496c:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80004970:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80004974:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80004978:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000497a:	79 58       	ld.w	r8,r12[0x54]
8000497c:	e2 18 00 20 	andl	r8,0x20,COH
80004980:	cf d0       	breq	8000497a <pm_cksel+0x3a>
}
80004982:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80004986 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80004986:	eb cd 40 80 	pushm	r7,lr
8000498a:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000498c:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000498e:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80004992:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80004996:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000499a:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000499e:	2f 8b       	sub	r11,-8
800049a0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800049a4:	e3 cd 80 80 	ldm	sp++,r7,pc

800049a8 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800049a8:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800049aa:	2f 8b       	sub	r11,-8
800049ac:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800049b0:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800049b4:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800049b8:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800049bc:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800049c0:	d8 02       	popm	pc

800049c2 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800049c2:	2f 8b       	sub	r11,-8
800049c4:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800049c8:	a1 a8       	sbr	r8,0x0
800049ca:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800049ce:	5e fc       	retal	r12

800049d0 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800049d0:	79 58       	ld.w	r8,r12[0x54]
800049d2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800049d6:	cf d0       	breq	800049d0 <pm_wait_for_pll0_locked>
}
800049d8:	5e fc       	retal	r12

800049da <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800049da:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800049dc:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800049e0:	99 08       	st.w	r12[0x0],r8
}
800049e2:	5e fc       	retal	r12

800049e4 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800049e4:	eb cd 40 c0 	pushm	r6-r7,lr
800049e8:	18 97       	mov	r7,r12
800049ea:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800049ec:	f0 1f 00 06 	mcall	80004a04 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800049f0:	0c 9b       	mov	r11,r6
800049f2:	0e 9c       	mov	r12,r7
800049f4:	f0 1f 00 05 	mcall	80004a08 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800049f8:	30 1b       	mov	r11,1
800049fa:	0e 9c       	mov	r12,r7
800049fc:	f0 1f 00 04 	mcall	80004a0c <pm_switch_to_osc0+0x28>
}
80004a00:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	48 78       	lddpc	r8,80004a20 <rtc_set_value+0x8>
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	48 d0       	lddpc	r0,80004a3c <rtc_enable>
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	49 da       	lddpc	r10,80004a80 <rtc_set_top_value+0x18>

80004a10 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80004a10:	78 0c       	ld.w	r12,r12[0x0]
}
80004a12:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80004a16:	5e fc       	retal	r12

80004a18 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80004a18:	eb cd 40 c0 	pushm	r6-r7,lr
80004a1c:	18 97       	mov	r7,r12
80004a1e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80004a20:	0e 9c       	mov	r12,r7
80004a22:	f0 1f 00 06 	mcall	80004a38 <rtc_set_value+0x20>
80004a26:	cf d1       	brne	80004a20 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80004a28:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80004a2a:	0e 9c       	mov	r12,r7
80004a2c:	f0 1f 00 03 	mcall	80004a38 <rtc_set_value+0x20>
80004a30:	cf d1       	brne	80004a2a <rtc_set_value+0x12>
}
80004a32:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a36:	00 00       	add	r0,r0
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	4a 10       	lddpc	r0,80004abc <rtc_init+0x10>

80004a3c <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80004a3c:	eb cd 40 80 	pushm	r7,lr
80004a40:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80004a42:	0e 9c       	mov	r12,r7
80004a44:	f0 1f 00 06 	mcall	80004a5c <rtc_enable+0x20>
80004a48:	cf d1       	brne	80004a42 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80004a4a:	6e 08       	ld.w	r8,r7[0x0]
80004a4c:	a1 a8       	sbr	r8,0x0
80004a4e:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80004a50:	0e 9c       	mov	r12,r7
80004a52:	f0 1f 00 03 	mcall	80004a5c <rtc_enable+0x20>
80004a56:	cf d1       	brne	80004a50 <rtc_enable+0x14>
}
80004a58:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	4a 10       	lddpc	r0,80004ae0 <rtc_init+0x34>

80004a60 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80004a60:	30 18       	mov	r8,1
80004a62:	99 48       	st.w	r12[0x10],r8
}
80004a64:	5e fc       	retal	r12
80004a66:	d7 03       	nop

80004a68 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80004a68:	eb cd 40 c0 	pushm	r6-r7,lr
80004a6c:	18 97       	mov	r7,r12
80004a6e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80004a70:	0e 9c       	mov	r12,r7
80004a72:	f0 1f 00 06 	mcall	80004a88 <rtc_set_top_value+0x20>
80004a76:	cf d1       	brne	80004a70 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80004a78:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80004a7a:	0e 9c       	mov	r12,r7
80004a7c:	f0 1f 00 03 	mcall	80004a88 <rtc_set_top_value+0x20>
80004a80:	cf d1       	brne	80004a7a <rtc_set_top_value+0x12>
}
80004a82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a86:	00 00       	add	r0,r0
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	4a 10       	lddpc	r0,80004b0c <rtc_init+0x60>

80004a8c <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004a8c:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80004a90:	e6 18 00 01 	andh	r8,0x1,COH
80004a94:	c0 71       	brne	80004aa2 <rtc_clear_interrupt+0x16>
80004a96:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80004a98:	30 18       	mov	r8,1
80004a9a:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80004a9c:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80004a9e:	d5 03       	csrf	0x10
80004aa0:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80004aa2:	30 18       	mov	r8,1
80004aa4:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80004aa6:	78 78       	ld.w	r8,r12[0x1c]
80004aa8:	5e fc       	retal	r12
80004aaa:	d7 03       	nop

80004aac <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80004aac:	eb cd 40 e0 	pushm	r5-r7,lr
80004ab0:	18 97       	mov	r7,r12
80004ab2:	16 96       	mov	r6,r11
80004ab4:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80004ab6:	30 18       	mov	r8,1
80004ab8:	f0 0b 18 00 	cp.b	r11,r8
80004abc:	5f b9       	srhi	r9
80004abe:	30 f8       	mov	r8,15
80004ac0:	f0 0a 18 00 	cp.b	r10,r8
80004ac4:	5f b8       	srhi	r8
80004ac6:	f3 e8 10 08 	or	r8,r9,r8
80004aca:	c0 30       	breq	80004ad0 <rtc_init+0x24>
80004acc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80004ad0:	30 18       	mov	r8,1
80004ad2:	f0 0b 18 00 	cp.b	r11,r8
80004ad6:	c0 a1       	brne	80004aea <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80004ad8:	fe 7c 0c 00 	mov	r12,-62464
80004adc:	f0 1f 00 0f 	mcall	80004b18 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80004ae0:	30 0b       	mov	r11,0
80004ae2:	fe 7c 0c 00 	mov	r12,-62464
80004ae6:	f0 1f 00 0e 	mcall	80004b1c <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
80004aea:	0e 9c       	mov	r12,r7
80004aec:	f0 1f 00 0d 	mcall	80004b20 <rtc_init+0x74>
80004af0:	cf d1       	brne	80004aea <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80004af2:	a3 76       	lsl	r6,0x3
80004af4:	b1 a6       	sbr	r6,0x10
80004af6:	ed e5 10 85 	or	r5,r6,r5<<0x8
80004afa:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80004afc:	0e 9c       	mov	r12,r7
80004afe:	f0 1f 00 09 	mcall	80004b20 <rtc_init+0x74>
80004b02:	cf d1       	brne	80004afc <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80004b04:	30 0b       	mov	r11,0
80004b06:	0e 9c       	mov	r12,r7
80004b08:	f0 1f 00 07 	mcall	80004b24 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80004b0c:	3f fb       	mov	r11,-1
80004b0e:	0e 9c       	mov	r12,r7
80004b10:	f0 1f 00 06 	mcall	80004b28 <rtc_init+0x7c>
80004b14:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004b18:	80 00       	ld.sh	r0,r0[0x0]
80004b1a:	48 f8       	lddpc	r8,80004b54 <spi_initMaster+0x8>
80004b1c:	80 00       	ld.sh	r0,r0[0x0]
80004b1e:	49 24       	lddpc	r4,80004b64 <spi_initMaster+0x18>
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	4a 10       	lddpc	r0,80004ba4 <spi_selectionMode+0x20>
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	4a 18       	lddpc	r8,80004ba8 <spi_selectionMode+0x24>
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	4a 68       	lddpc	r8,80004bc0 <spi_write+0xa>

80004b2c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80004b2c:	f8 c8 00 01 	sub	r8,r12,1
80004b30:	f0 0b 00 0b 	add	r11,r8,r11
80004b34:	f6 0c 0d 0a 	divu	r10,r11,r12
80004b38:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80004b3a:	f4 c8 00 01 	sub	r8,r10,1
80004b3e:	e0 48 00 fe 	cp.w	r8,254
80004b42:	e0 88 00 03 	brls	80004b48 <getBaudDiv+0x1c>
80004b46:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80004b48:	5c 8c       	casts.h	r12
}
80004b4a:	5e fc       	retal	r12

80004b4c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80004b4c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004b50:	30 18       	mov	r8,1
80004b52:	f0 09 18 00 	cp.b	r9,r8
80004b56:	e0 88 00 04 	brls	80004b5e <spi_initMaster+0x12>
80004b5a:	30 2c       	mov	r12,2
80004b5c:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80004b5e:	e0 68 00 80 	mov	r8,128
80004b62:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80004b64:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80004b66:	30 19       	mov	r9,1
80004b68:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80004b6c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004b70:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80004b74:	30 09       	mov	r9,0
80004b76:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80004b7a:	30 fa       	mov	r10,15
80004b7c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80004b80:	99 18       	st.w	r12[0x4],r8
80004b82:	5e f9       	retal	r9

80004b84 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80004b84:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80004b86:	30 18       	mov	r8,1
80004b88:	f0 0b 18 00 	cp.b	r11,r8
80004b8c:	5f be       	srhi	lr
80004b8e:	f0 0a 18 00 	cp.b	r10,r8
80004b92:	5f b8       	srhi	r8
80004b94:	fd e8 10 08 	or	r8,lr,r8
80004b98:	c0 30       	breq	80004b9e <spi_selectionMode+0x1a>
80004b9a:	30 2c       	mov	r12,2
80004b9c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80004b9e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80004ba0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80004ba4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80004ba8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80004bac:	99 18       	st.w	r12[0x4],r8
80004bae:	d8 0a       	popm	pc,r12=0

80004bb0 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80004bb0:	30 18       	mov	r8,1
80004bb2:	99 08       	st.w	r12[0x0],r8
}
80004bb4:	5e fc       	retal	r12

80004bb6 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80004bb6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004bba:	c0 58       	rjmp	80004bc4 <spi_write+0xe>
		if (!timeout--) {
80004bbc:	58 08       	cp.w	r8,0
80004bbe:	c0 21       	brne	80004bc2 <spi_write+0xc>
80004bc0:	5e ff       	retal	1
80004bc2:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004bc4:	78 49       	ld.w	r9,r12[0x10]
80004bc6:	e2 19 00 02 	andl	r9,0x2,COH
80004bca:	cf 90       	breq	80004bbc <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80004bcc:	5c 7b       	castu.h	r11
80004bce:	99 3b       	st.w	r12[0xc],r11
80004bd0:	5e fd       	retal	0

80004bd2 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80004bd2:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80004bd6:	c0 58       	rjmp	80004be0 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80004bd8:	58 08       	cp.w	r8,0
80004bda:	c0 21       	brne	80004bde <spi_read+0xc>
80004bdc:	5e ff       	retal	1
80004bde:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80004be0:	78 49       	ld.w	r9,r12[0x10]
80004be2:	e2 19 02 01 	andl	r9,0x201,COH
80004be6:	e0 49 02 01 	cp.w	r9,513
80004bea:	cf 71       	brne	80004bd8 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80004bec:	78 28       	ld.w	r8,r12[0x8]
80004bee:	b6 08       	st.h	r11[0x0],r8
80004bf0:	5e fd       	retal	0
80004bf2:	d7 03       	nop

80004bf4 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80004bf4:	eb cd 40 f8 	pushm	r3-r7,lr
80004bf8:	18 95       	mov	r5,r12
80004bfa:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004bfc:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004c00:	30 38       	mov	r8,3
80004c02:	f0 06 18 00 	cp.b	r6,r8
80004c06:	e0 8b 00 5e 	brhi	80004cc2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80004c0a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004c0e:	30 18       	mov	r8,1
80004c10:	f0 04 18 00 	cp.b	r4,r8
80004c14:	e0 8b 00 57 	brhi	80004cc2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80004c18:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004c1c:	30 78       	mov	r8,7
80004c1e:	f0 03 18 00 	cp.b	r3,r8
80004c22:	e0 88 00 50 	brls	80004cc2 <spi_setupChipReg+0xce>
80004c26:	31 08       	mov	r8,16
80004c28:	f0 03 18 00 	cp.b	r3,r8
80004c2c:	e0 8b 00 4b 	brhi	80004cc2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80004c30:	14 9b       	mov	r11,r10
80004c32:	6e 1c       	ld.w	r12,r7[0x4]
80004c34:	f0 1f 00 26 	mcall	80004ccc <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80004c38:	c4 55       	brlt	80004cc2 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80004c3a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80004c3c:	ec 09 16 01 	lsr	r9,r6,0x1
80004c40:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80004c44:	ec 16 00 01 	eorl	r6,0x1
80004c48:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80004c4c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80004c50:	20 83       	sub	r3,8
80004c52:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80004c56:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80004c5a:	ef 39 00 09 	ld.ub	r9,r7[9]
80004c5e:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80004c62:	ef 39 00 0a 	ld.ub	r9,r7[10]
80004c66:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80004c6a:	0f 89       	ld.ub	r9,r7[0x0]
80004c6c:	30 1a       	mov	r10,1
80004c6e:	f4 09 18 00 	cp.b	r9,r10
80004c72:	c0 d0       	breq	80004c8c <spi_setupChipReg+0x98>
80004c74:	c0 a3       	brcs	80004c88 <spi_setupChipReg+0x94>
80004c76:	30 2a       	mov	r10,2
80004c78:	f4 09 18 00 	cp.b	r9,r10
80004c7c:	c0 a0       	breq	80004c90 <spi_setupChipReg+0x9c>
80004c7e:	30 3a       	mov	r10,3
80004c80:	f4 09 18 00 	cp.b	r9,r10
80004c84:	c1 f1       	brne	80004cc2 <spi_setupChipReg+0xce>
80004c86:	c0 78       	rjmp	80004c94 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80004c88:	8b c8       	st.w	r5[0x30],r8
		break;
80004c8a:	c0 68       	rjmp	80004c96 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80004c8c:	8b d8       	st.w	r5[0x34],r8
		break;
80004c8e:	c0 48       	rjmp	80004c96 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80004c90:	8b e8       	st.w	r5[0x38],r8
		break;
80004c92:	c0 28       	rjmp	80004c96 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80004c94:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80004c96:	48 f8       	lddpc	r8,80004cd0 <spi_setupChipReg+0xdc>
80004c98:	70 08       	ld.w	r8,r8[0x0]
80004c9a:	58 08       	cp.w	r8,0
80004c9c:	c1 61       	brne	80004cc8 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80004c9e:	30 0b       	mov	r11,0
80004ca0:	30 1c       	mov	r12,1
80004ca2:	f0 1f 00 0d 	mcall	80004cd4 <spi_setupChipReg+0xe0>
80004ca6:	48 b8       	lddpc	r8,80004cd0 <spi_setupChipReg+0xdc>
80004ca8:	91 0c       	st.w	r8[0x0],r12
80004caa:	58 0c       	cp.w	r12,0
80004cac:	c0 a0       	breq	80004cc0 <spi_setupChipReg+0xcc>
80004cae:	30 09       	mov	r9,0
80004cb0:	12 9a       	mov	r10,r9
80004cb2:	12 9b       	mov	r11,r9
80004cb4:	f0 1f 00 09 	mcall	80004cd8 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80004cb8:	48 68       	lddpc	r8,80004cd0 <spi_setupChipReg+0xdc>
80004cba:	70 08       	ld.w	r8,r8[0x0]
80004cbc:	58 08       	cp.w	r8,0
80004cbe:	c0 51       	brne	80004cc8 <spi_setupChipReg+0xd4>
80004cc0:	c0 08       	rjmp	80004cc0 <spi_setupChipReg+0xcc>
80004cc2:	30 2c       	mov	r12,2
80004cc4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004cc8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	4b 2c       	lddpc	r12,80004d94 <usart_set_async_baudrate>
80004cd0:	00 00       	add	r0,r0
80004cd2:	1f a8       	ld.ub	r8,pc[0x2]
80004cd4:	80 00       	ld.sh	r0,r0[0x0]
80004cd6:	57 78       	stdsp	sp[0x1dc],r8
80004cd8:	80 00       	ld.sh	r0,r0[0x0]
80004cda:	56 20       	stdsp	sp[0x188],r0

80004cdc <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004cdc:	d4 01       	pushm	lr
80004cde:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004ce2:	c0 58       	rjmp	80004cec <spi_unselectChip+0x10>
		if (!timeout--) {
80004ce4:	58 08       	cp.w	r8,0
80004ce6:	c0 21       	brne	80004cea <spi_unselectChip+0xe>
80004ce8:	da 0a       	popm	pc,r12=1
80004cea:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004cec:	78 49       	ld.w	r9,r12[0x10]
80004cee:	e2 19 02 00 	andl	r9,0x200,COH
80004cf2:	cf 90       	breq	80004ce4 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004cf4:	78 18       	ld.w	r8,r12[0x4]
80004cf6:	ea 18 00 0f 	orh	r8,0xf
80004cfa:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80004cfc:	fc 18 01 00 	movh	r8,0x100
80004d00:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80004d02:	30 09       	mov	r9,0
80004d04:	12 9a       	mov	r10,r9
80004d06:	12 9b       	mov	r11,r9
80004d08:	48 38       	lddpc	r8,80004d14 <spi_unselectChip+0x38>
80004d0a:	70 0c       	ld.w	r12,r8[0x0]
80004d0c:	f0 1f 00 03 	mcall	80004d18 <spi_unselectChip+0x3c>
80004d10:	d8 0a       	popm	pc,r12=0
80004d12:	00 00       	add	r0,r0
80004d14:	00 00       	add	r0,r0
80004d16:	1f a8       	ld.ub	r8,pc[0x2]
80004d18:	80 00       	ld.sh	r0,r0[0x0]
80004d1a:	56 20       	stdsp	sp[0x188],r0

80004d1c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004d1c:	eb cd 40 f8 	pushm	r3-r7,lr
80004d20:	18 94       	mov	r4,r12
80004d22:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80004d24:	49 a6       	lddpc	r6,80004d8c <spi_selectChip+0x70>
80004d26:	30 07       	mov	r7,0
80004d28:	31 45       	mov	r5,20
80004d2a:	0e 99       	mov	r9,r7
80004d2c:	0a 9a       	mov	r10,r5
80004d2e:	0e 9b       	mov	r11,r7
80004d30:	6c 0c       	ld.w	r12,r6[0x0]
80004d32:	f0 1f 00 18 	mcall	80004d90 <spi_selectChip+0x74>
80004d36:	cf a0       	breq	80004d2a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004d38:	68 18       	ld.w	r8,r4[0x4]
80004d3a:	ea 18 00 0f 	orh	r8,0xf
80004d3e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80004d40:	68 18       	ld.w	r8,r4[0x4]
80004d42:	e2 18 00 04 	andl	r8,0x4,COH
80004d46:	c1 10       	breq	80004d68 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80004d48:	30 e8       	mov	r8,14
80004d4a:	f0 03 18 00 	cp.b	r3,r8
80004d4e:	e0 8b 00 1c 	brhi	80004d86 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80004d52:	68 19       	ld.w	r9,r4[0x4]
80004d54:	e6 08 15 10 	lsl	r8,r3,0x10
80004d58:	ea 18 ff f0 	orh	r8,0xfff0
80004d5c:	e8 18 ff ff 	orl	r8,0xffff
80004d60:	12 68       	and	r8,r9
80004d62:	89 18       	st.w	r4[0x4],r8
80004d64:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80004d68:	30 38       	mov	r8,3
80004d6a:	f0 03 18 00 	cp.b	r3,r8
80004d6e:	e0 8b 00 0c 	brhi	80004d86 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80004d72:	68 19       	ld.w	r9,r4[0x4]
80004d74:	2f 03       	sub	r3,-16
80004d76:	30 18       	mov	r8,1
80004d78:	f0 03 09 48 	lsl	r8,r8,r3
80004d7c:	5c d8       	com	r8
80004d7e:	12 68       	and	r8,r9
80004d80:	89 18       	st.w	r4[0x4],r8
80004d82:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004d86:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80004d88:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004d8c:	00 00       	add	r0,r0
80004d8e:	1f a8       	ld.ub	r8,pc[0x2]
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	54 64       	stdsp	sp[0x118],r4

80004d94 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004d94:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004d96:	f6 08 15 04 	lsl	r8,r11,0x4
80004d9a:	14 38       	cp.w	r8,r10
80004d9c:	f9 b8 08 10 	movls	r8,16
80004da0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004da4:	f0 0b 02 4b 	mul	r11,r8,r11
80004da8:	f6 09 16 01 	lsr	r9,r11,0x1
80004dac:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004db0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004db4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004db8:	f2 cb 00 01 	sub	r11,r9,1
80004dbc:	e0 4b ff fe 	cp.w	r11,65534
80004dc0:	e0 88 00 03 	brls	80004dc6 <usart_set_async_baudrate+0x32>
80004dc4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004dc6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004dc8:	e8 6e 00 00 	mov	lr,524288
80004dcc:	59 08       	cp.w	r8,16
80004dce:	fc 08 17 10 	movne	r8,lr
80004dd2:	f9 b8 00 00 	moveq	r8,0
80004dd6:	e4 1b ff f7 	andh	r11,0xfff7
80004dda:	e0 1b fe cf 	andl	r11,0xfecf
80004dde:	16 48       	or	r8,r11
80004de0:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004de2:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004de6:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004dea:	99 89       	st.w	r12[0x20],r9
80004dec:	d8 0a       	popm	pc,r12=0

80004dee <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004dee:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004df0:	e2 18 00 02 	andl	r8,0x2,COH
80004df4:	c0 31       	brne	80004dfa <usart_write_char+0xc>
80004df6:	30 2c       	mov	r12,2
80004df8:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004dfa:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004dfe:	99 7b       	st.w	r12[0x1c],r11
80004e00:	5e fd       	retal	0
80004e02:	d7 03       	nop

80004e04 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004e04:	eb cd 40 e0 	pushm	r5-r7,lr
80004e08:	18 96       	mov	r6,r12
80004e0a:	16 95       	mov	r5,r11
80004e0c:	e0 67 27 0f 	mov	r7,9999
80004e10:	c0 68       	rjmp	80004e1c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004e12:	58 07       	cp.w	r7,0
80004e14:	c0 31       	brne	80004e1a <usart_putchar+0x16>
80004e16:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004e1a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004e1c:	0a 9b       	mov	r11,r5
80004e1e:	0c 9c       	mov	r12,r6
80004e20:	f0 1f 00 03 	mcall	80004e2c <usart_putchar+0x28>
80004e24:	cf 71       	brne	80004e12 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004e26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004e2a:	00 00       	add	r0,r0
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	4d ee       	lddpc	lr,80004fa4 <_stext+0x8>

80004e30 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004e30:	78 58       	ld.w	r8,r12[0x14]
80004e32:	e2 18 00 e0 	andl	r8,0xe0,COH
80004e36:	c0 30       	breq	80004e3c <usart_read_char+0xc>
80004e38:	30 4c       	mov	r12,4
80004e3a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004e3c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004e3e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e42:	c0 31       	brne	80004e48 <usart_read_char+0x18>
80004e44:	30 3c       	mov	r12,3
80004e46:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004e48:	78 68       	ld.w	r8,r12[0x18]
80004e4a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004e4e:	97 08       	st.w	r11[0x0],r8
80004e50:	5e fd       	retal	0
80004e52:	d7 03       	nop

80004e54 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004e54:	eb cd 40 c0 	pushm	r6-r7,lr
80004e58:	20 1d       	sub	sp,4
80004e5a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004e5c:	1a 97       	mov	r7,sp
80004e5e:	1a 9b       	mov	r11,sp
80004e60:	0c 9c       	mov	r12,r6
80004e62:	f0 1f 00 07 	mcall	80004e7c <usart_getchar+0x28>
80004e66:	58 3c       	cp.w	r12,3
80004e68:	cf b0       	breq	80004e5e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004e6a:	58 4c       	cp.w	r12,4
80004e6c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004e70:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004e74:	2f fd       	sub	sp,-4
80004e76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e7a:	00 00       	add	r0,r0
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	4e 30       	lddpc	r0,80005008 <vListInsertEnd+0x12>

80004e80 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004e80:	eb cd 40 c0 	pushm	r6-r7,lr
80004e84:	18 96       	mov	r6,r12
80004e86:	16 97       	mov	r7,r11
  while (*string != '\0')
80004e88:	17 8b       	ld.ub	r11,r11[0x0]
80004e8a:	58 0b       	cp.w	r11,0
80004e8c:	c0 80       	breq	80004e9c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004e8e:	2f f7       	sub	r7,-1
80004e90:	0c 9c       	mov	r12,r6
80004e92:	f0 1f 00 04 	mcall	80004ea0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004e96:	0f 8b       	ld.ub	r11,r7[0x0]
80004e98:	58 0b       	cp.w	r11,0
80004e9a:	cf a1       	brne	80004e8e <usart_write_line+0xe>
80004e9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	4e 04       	lddpc	r4,80005020 <vListInsert+0xe>

80004ea4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004ea4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004ea8:	e6 18 00 01 	andh	r8,0x1,COH
80004eac:	c0 71       	brne	80004eba <usart_reset+0x16>
80004eae:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004eb0:	3f f8       	mov	r8,-1
80004eb2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004eb4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004eb6:	d5 03       	csrf	0x10
80004eb8:	c0 48       	rjmp	80004ec0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004eba:	3f f8       	mov	r8,-1
80004ebc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004ebe:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004ec0:	30 08       	mov	r8,0
80004ec2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004ec4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004ec6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004ec8:	ea 68 61 0c 	mov	r8,680204
80004ecc:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004ece:	5e fc       	retal	r12

80004ed0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004ed0:	eb cd 40 e0 	pushm	r5-r7,lr
80004ed4:	18 96       	mov	r6,r12
80004ed6:	16 97       	mov	r7,r11
80004ed8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004eda:	f0 1f 00 2f 	mcall	80004f94 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004ede:	58 07       	cp.w	r7,0
80004ee0:	c5 80       	breq	80004f90 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004ee2:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004ee4:	30 49       	mov	r9,4
80004ee6:	f2 08 18 00 	cp.b	r8,r9
80004eea:	e0 88 00 53 	brls	80004f90 <usart_init_rs232+0xc0>
80004eee:	30 99       	mov	r9,9
80004ef0:	f2 08 18 00 	cp.b	r8,r9
80004ef4:	e0 8b 00 4e 	brhi	80004f90 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004ef8:	0f d9       	ld.ub	r9,r7[0x5]
80004efa:	30 78       	mov	r8,7
80004efc:	f0 09 18 00 	cp.b	r9,r8
80004f00:	e0 8b 00 48 	brhi	80004f90 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004f04:	8e 39       	ld.sh	r9,r7[0x6]
80004f06:	e0 68 01 01 	mov	r8,257
80004f0a:	f0 09 19 00 	cp.h	r9,r8
80004f0e:	e0 8b 00 41 	brhi	80004f90 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004f12:	ef 39 00 08 	ld.ub	r9,r7[8]
80004f16:	30 38       	mov	r8,3
80004f18:	f0 09 18 00 	cp.b	r9,r8
80004f1c:	e0 8b 00 3a 	brhi	80004f90 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004f20:	0a 9a       	mov	r10,r5
80004f22:	6e 0b       	ld.w	r11,r7[0x0]
80004f24:	0c 9c       	mov	r12,r6
80004f26:	f0 1f 00 1d 	mcall	80004f98 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004f2a:	58 1c       	cp.w	r12,1
80004f2c:	c3 20       	breq	80004f90 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004f2e:	0f c8       	ld.ub	r8,r7[0x4]
80004f30:	30 99       	mov	r9,9
80004f32:	f2 08 18 00 	cp.b	r8,r9
80004f36:	c0 51       	brne	80004f40 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004f38:	6c 18       	ld.w	r8,r6[0x4]
80004f3a:	b1 b8       	sbr	r8,0x11
80004f3c:	8d 18       	st.w	r6[0x4],r8
80004f3e:	c0 68       	rjmp	80004f4a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004f40:	6c 19       	ld.w	r9,r6[0x4]
80004f42:	20 58       	sub	r8,5
80004f44:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004f48:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004f4a:	6c 19       	ld.w	r9,r6[0x4]
80004f4c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004f50:	0f d8       	ld.ub	r8,r7[0x5]
80004f52:	a9 78       	lsl	r8,0x9
80004f54:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004f58:	12 48       	or	r8,r9
80004f5a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004f5c:	8e 38       	ld.sh	r8,r7[0x6]
80004f5e:	30 29       	mov	r9,2
80004f60:	f2 08 19 00 	cp.h	r8,r9
80004f64:	e0 88 00 09 	brls	80004f76 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004f68:	6c 18       	ld.w	r8,r6[0x4]
80004f6a:	ad b8       	sbr	r8,0xd
80004f6c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004f6e:	8e b8       	ld.uh	r8,r7[0x6]
80004f70:	20 28       	sub	r8,2
80004f72:	8d a8       	st.w	r6[0x28],r8
80004f74:	c0 68       	rjmp	80004f80 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004f76:	6c 19       	ld.w	r9,r6[0x4]
80004f78:	5c 78       	castu.h	r8
80004f7a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004f7e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004f80:	6c 18       	ld.w	r8,r6[0x4]
80004f82:	e0 18 ff f0 	andl	r8,0xfff0
80004f86:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004f88:	35 08       	mov	r8,80
80004f8a:	8d 08       	st.w	r6[0x0],r8
80004f8c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004f90:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4e a4       	lddpc	r4,8000513c <xPortStartScheduler+0x2c>
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	4d 94       	lddpc	r4,800050fc <pxPortInitialiseStack+0x90>

80004f9c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004f9c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004fa0:	fe c0 8f a0 	sub	r0,pc,-28768

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004fa4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004fa8:	d5 53       	csrf	0x15
  cp      r0, r1
80004faa:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80004fac:	e0 61 0a 20 	mov	r1,2592
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004fb0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004fb2:	c0 62       	brcc	80004fbe <idata_load_loop_end>
  cp      r0, r1
80004fb4:	48 92       	lddpc	r2,80004fd8 <udata_clear_loop_end+0x4>

80004fb6 <idata_load_loop>:
  brlo    idata_load_loop
80004fb6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004fb8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004fba:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004fbc:	cf d3       	brcs	80004fb6 <idata_load_loop>

80004fbe <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004fbe:	e0 60 0a 20 	mov	r0,2592
  mov     r2, 0
  mov     r3, 0
80004fc2:	e0 61 1f b8 	mov	r1,8120
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004fc6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004fc8:	c0 62       	brcc	80004fd4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004fca:	30 02       	mov	r2,0
80004fcc:	30 03       	mov	r3,0

80004fce <udata_clear_loop>:
80004fce:	a1 22       	st.d	r0++,r2
80004fd0:	02 30       	cp.w	r0,r1
80004fd2:	cf e3       	brcs	80004fce <udata_clear_loop>

80004fd4 <udata_clear_loop_end>:
80004fd4:	fe cf eb 30 	sub	pc,pc,-5328
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	d5 78       	*unknown*

80004fdc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004fdc:	f8 c8 ff f8 	sub	r8,r12,-8
80004fe0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004fe2:	3f f9       	mov	r9,-1
80004fe4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004fe6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004fe8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004fea:	30 08       	mov	r8,0
80004fec:	99 08       	st.w	r12[0x0],r8
}
80004fee:	5e fc       	retal	r12

80004ff0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004ff0:	30 08       	mov	r8,0
80004ff2:	99 48       	st.w	r12[0x10],r8
}
80004ff4:	5e fc       	retal	r12

80004ff6 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004ff6:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004ff8:	70 19       	ld.w	r9,r8[0x4]
80004ffa:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004ffc:	78 19       	ld.w	r9,r12[0x4]
80004ffe:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005000:	70 19       	ld.w	r9,r8[0x4]
80005002:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005004:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005006:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005008:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000500a:	78 08       	ld.w	r8,r12[0x0]
8000500c:	2f f8       	sub	r8,-1
8000500e:	99 08       	st.w	r12[0x0],r8
}
80005010:	5e fc       	retal	r12

80005012 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005012:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005014:	5b fa       	cp.w	r10,-1
80005016:	c0 31       	brne	8000501c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005018:	78 48       	ld.w	r8,r12[0x10]
8000501a:	c0 c8       	rjmp	80005032 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
8000501c:	f8 c8 ff f8 	sub	r8,r12,-8
80005020:	70 19       	ld.w	r9,r8[0x4]
80005022:	72 09       	ld.w	r9,r9[0x0]
80005024:	12 3a       	cp.w	r10,r9
80005026:	c0 63       	brcs	80005032 <vListInsert+0x20>
80005028:	70 18       	ld.w	r8,r8[0x4]
8000502a:	70 19       	ld.w	r9,r8[0x4]
8000502c:	72 09       	ld.w	r9,r9[0x0]
8000502e:	12 3a       	cp.w	r10,r9
80005030:	cf c2       	brcc	80005028 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005032:	70 19       	ld.w	r9,r8[0x4]
80005034:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005036:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005038:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000503a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000503c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000503e:	78 08       	ld.w	r8,r12[0x0]
80005040:	2f f8       	sub	r8,-1
80005042:	99 08       	st.w	r12[0x0],r8
}
80005044:	5e fc       	retal	r12

80005046 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005046:	78 18       	ld.w	r8,r12[0x4]
80005048:	78 29       	ld.w	r9,r12[0x8]
8000504a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000504c:	78 28       	ld.w	r8,r12[0x8]
8000504e:	78 19       	ld.w	r9,r12[0x4]
80005050:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005052:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005054:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005056:	18 39       	cp.w	r9,r12
80005058:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000505c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005060:	30 09       	mov	r9,0
80005062:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005064:	70 09       	ld.w	r9,r8[0x0]
80005066:	20 19       	sub	r9,1
80005068:	91 09       	st.w	r8[0x0],r9
}
8000506a:	5e fc       	retal	r12

8000506c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000506c:	e0 68 08 08 	mov	r8,2056
80005070:	ea 18 08 08 	orh	r8,0x808
80005074:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005076:	e0 68 09 09 	mov	r8,2313
8000507a:	ea 18 09 09 	orh	r8,0x909
8000507e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005080:	e0 68 0a 0a 	mov	r8,2570
80005084:	ea 18 0a 0a 	orh	r8,0xa0a
80005088:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000508a:	e0 68 0b 0b 	mov	r8,2827
8000508e:	ea 18 0b 0b 	orh	r8,0xb0b
80005092:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005094:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005096:	e0 68 be ef 	mov	r8,48879
8000509a:	ea 18 de ad 	orh	r8,0xdead
8000509e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800050a0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800050a2:	fc 18 00 40 	movh	r8,0x40
800050a6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800050a8:	e0 68 00 ff 	mov	r8,255
800050ac:	ea 18 ff 00 	orh	r8,0xff00
800050b0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800050b2:	e0 68 01 01 	mov	r8,257
800050b6:	ea 18 01 01 	orh	r8,0x101
800050ba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800050bc:	e0 68 02 02 	mov	r8,514
800050c0:	ea 18 02 02 	orh	r8,0x202
800050c4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800050c6:	e0 68 03 03 	mov	r8,771
800050ca:	ea 18 03 03 	orh	r8,0x303
800050ce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800050d0:	e0 68 04 04 	mov	r8,1028
800050d4:	ea 18 04 04 	orh	r8,0x404
800050d8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800050da:	e0 68 05 05 	mov	r8,1285
800050de:	ea 18 05 05 	orh	r8,0x505
800050e2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800050e4:	e0 68 06 06 	mov	r8,1542
800050e8:	ea 18 06 06 	orh	r8,0x606
800050ec:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800050ee:	e0 68 07 07 	mov	r8,1799
800050f2:	ea 18 07 07 	orh	r8,0x707
800050f6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800050f8:	30 08       	mov	r8,0
800050fa:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800050fc:	5e fc       	retal	r12
800050fe:	d7 03       	nop

80005100 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005100:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005102:	48 38       	lddpc	r8,8000510c <vPortEnterCritical+0xc>
80005104:	70 09       	ld.w	r9,r8[0x0]
80005106:	2f f9       	sub	r9,-1
80005108:	91 09       	st.w	r8[0x0],r9
}
8000510a:	5e fc       	retal	r12
8000510c:	00 00       	add	r0,r0
8000510e:	05 14       	ld.sh	r4,r2++

80005110 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005110:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005112:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005114:	30 0a       	mov	r10,0
80005116:	14 9b       	mov	r11,r10
80005118:	49 2c       	lddpc	r12,80005160 <xPortStartScheduler+0x50>
8000511a:	f0 1f 00 13 	mcall	80005164 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000511e:	e0 68 5d c0 	mov	r8,24000
80005122:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005126:	30 08       	mov	r8,0
80005128:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000512c:	e0 68 0c 50 	mov	r8,3152
80005130:	ea 18 00 00 	orh	r8,0x0
80005134:	70 00       	ld.w	r0,r8[0x0]
80005136:	60 0d       	ld.w	sp,r0[0x0]
80005138:	1b 00       	ld.w	r0,sp++
8000513a:	e0 68 05 14 	mov	r8,1300
8000513e:	ea 18 00 00 	orh	r8,0x0
80005142:	91 00       	st.w	r8[0x0],r0
80005144:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005148:	2f ed       	sub	sp,-8
8000514a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000514e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005152:	e3 b0 00 00 	mtsr	0x0,r0
80005156:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000515a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000515e:	d8 0a       	popm	pc,r12=0
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	52 2c       	stdsp	sp[0x88],r12
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	47 60       	lddsp	r0,sp[0x1d8]

80005168 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005168:	20 6d       	sub	sp,24
8000516a:	eb cd 00 ff 	pushm	r0-r7
8000516e:	fa c7 ff c0 	sub	r7,sp,-64
80005172:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005176:	ef 40 ff e0 	st.w	r7[-32],r0
8000517a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000517e:	ef 40 ff e4 	st.w	r7[-28],r0
80005182:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005186:	e0 68 05 14 	mov	r8,1300
8000518a:	ea 18 00 00 	orh	r8,0x0
8000518e:	70 00       	ld.w	r0,r8[0x0]
80005190:	1a d0       	st.w	--sp,r0
80005192:	f0 1f 00 1a 	mcall	800051f8 <LABEL_RET_SCALL_263+0x14>
80005196:	e0 68 0c 50 	mov	r8,3152
8000519a:	ea 18 00 00 	orh	r8,0x0
8000519e:	70 00       	ld.w	r0,r8[0x0]
800051a0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800051a2:	f0 1f 00 17 	mcall	800051fc <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800051a6:	e0 68 0c 50 	mov	r8,3152
800051aa:	ea 18 00 00 	orh	r8,0x0
800051ae:	70 00       	ld.w	r0,r8[0x0]
800051b0:	60 0d       	ld.w	sp,r0[0x0]
800051b2:	1b 00       	ld.w	r0,sp++
800051b4:	e0 68 05 14 	mov	r8,1300
800051b8:	ea 18 00 00 	orh	r8,0x0
800051bc:	91 00       	st.w	r8[0x0],r0
800051be:	fa c7 ff d8 	sub	r7,sp,-40
800051c2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800051c6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800051ca:	e0 61 05 14 	mov	r1,1300
800051ce:	ea 11 00 00 	orh	r1,0x0
800051d2:	62 02       	ld.w	r2,r1[0x0]
800051d4:	58 02       	cp.w	r2,0
800051d6:	c0 70       	breq	800051e4 <LABEL_RET_SCALL_263>
800051d8:	e4 c2 00 01 	sub	r2,r2,1
800051dc:	83 02       	st.w	r1[0x0],r2
800051de:	58 02       	cp.w	r2,0
800051e0:	c0 21       	brne	800051e4 <LABEL_RET_SCALL_263>
800051e2:	b1 c0       	cbr	r0,0x10

800051e4 <LABEL_RET_SCALL_263>:
800051e4:	ef 40 ff f8 	st.w	r7[-8],r0
800051e8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800051ec:	ef 40 ff fc 	st.w	r7[-4],r0
800051f0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800051f4:	2f ad       	sub	sp,-24
800051f6:	d6 13       	rets
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	51 00       	stdsp	sp[0x40],r0
800051fc:	80 00       	ld.sh	r0,r0[0x0]
800051fe:	58 14       	cp.w	r4,1

80005200 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005200:	e1 b8 00 43 	mfsr	r8,0x10c
80005204:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005208:	5e fc       	retal	r12
8000520a:	d7 03       	nop

8000520c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000520c:	48 78       	lddpc	r8,80005228 <vPortExitCritical+0x1c>
8000520e:	70 08       	ld.w	r8,r8[0x0]
80005210:	58 08       	cp.w	r8,0
80005212:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005214:	48 58       	lddpc	r8,80005228 <vPortExitCritical+0x1c>
80005216:	70 09       	ld.w	r9,r8[0x0]
80005218:	20 19       	sub	r9,1
8000521a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000521c:	70 08       	ld.w	r8,r8[0x0]
8000521e:	58 08       	cp.w	r8,0
80005220:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005222:	d5 03       	csrf	0x10
80005224:	5e fc       	retal	r12
80005226:	00 00       	add	r0,r0
80005228:	00 00       	add	r0,r0
8000522a:	05 14       	ld.sh	r4,r2++

8000522c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000522c:	eb cd 00 ff 	pushm	r0-r7
80005230:	e0 68 05 14 	mov	r8,1300
80005234:	ea 18 00 00 	orh	r8,0x0
80005238:	70 00       	ld.w	r0,r8[0x0]
8000523a:	1a d0       	st.w	--sp,r0
8000523c:	7a 90       	ld.w	r0,sp[0x24]
8000523e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005242:	58 10       	cp.w	r0,1
80005244:	e0 8b 00 08 	brhi	80005254 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005248:	e0 68 0c 50 	mov	r8,3152
8000524c:	ea 18 00 00 	orh	r8,0x0
80005250:	70 00       	ld.w	r0,r8[0x0]
80005252:	81 0d       	st.w	r0[0x0],sp

80005254 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005254:	f0 1f 00 12 	mcall	8000529c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005258:	f0 1f 00 12 	mcall	800052a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000525c:	f0 1f 00 12 	mcall	800052a4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005260:	f0 1f 00 12 	mcall	800052a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005264:	7a 90       	ld.w	r0,sp[0x24]
80005266:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000526a:	58 10       	cp.w	r0,1
8000526c:	e0 8b 00 0e 	brhi	80005288 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005270:	f0 1f 00 0c 	mcall	800052a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005274:	f0 1f 00 0e 	mcall	800052ac <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005278:	f0 1f 00 0c 	mcall	800052a8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000527c:	e0 68 0c 50 	mov	r8,3152
80005280:	ea 18 00 00 	orh	r8,0x0
80005284:	70 00       	ld.w	r0,r8[0x0]
80005286:	60 0d       	ld.w	sp,r0[0x0]

80005288 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005288:	1b 00       	ld.w	r0,sp++
8000528a:	e0 68 05 14 	mov	r8,1300
8000528e:	ea 18 00 00 	orh	r8,0x0
80005292:	91 00       	st.w	r8[0x0],r0
80005294:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005298:	d6 03       	rete
8000529a:	00 00       	add	r0,r0
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	52 00       	stdsp	sp[0x80],r0
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	51 00       	stdsp	sp[0x40],r0
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	5a 18       	cp.w	r8,-31
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	52 0c       	stdsp	sp[0x80],r12
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	58 14       	cp.w	r4,1

800052b0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800052b0:	d4 01       	pushm	lr
	vTaskSuspendAll();
800052b2:	f0 1f 00 02 	mcall	800052b8 <__malloc_lock+0x8>
}
800052b6:	d8 02       	popm	pc
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	58 04       	cp.w	r4,0

800052bc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800052bc:	d4 01       	pushm	lr
	xTaskResumeAll();
800052be:	f0 1f 00 02 	mcall	800052c4 <__malloc_unlock+0x8>
}
800052c2:	d8 02       	popm	pc
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	5b c0       	cp.w	r0,-4

800052c8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800052c8:	d4 21       	pushm	r4-r7,lr
800052ca:	16 95       	mov	r5,r11
800052cc:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800052ce:	58 0c       	cp.w	r12,0
800052d0:	c0 30       	breq	800052d6 <_read+0xe>
800052d2:	3f f7       	mov	r7,-1
800052d4:	c1 48       	rjmp	800052fc <_read+0x34>
    return -1;

  for (; len > 0; --len)
800052d6:	58 0a       	cp.w	r10,0
800052d8:	e0 89 00 04 	brgt	800052e0 <_read+0x18>
800052dc:	30 07       	mov	r7,0
800052de:	c0 f8       	rjmp	800052fc <_read+0x34>
800052e0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800052e2:	48 84       	lddpc	r4,80005300 <_read+0x38>
800052e4:	68 0c       	ld.w	r12,r4[0x0]
800052e6:	f0 1f 00 08 	mcall	80005304 <_read+0x3c>
    if (c < 0)
800052ea:	c0 95       	brlt	800052fc <_read+0x34>
      break;

    *ptr++ = c;
800052ec:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800052f0:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800052f2:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800052f6:	58 08       	cp.w	r8,0
800052f8:	fe 99 ff f6 	brgt	800052e4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800052fc:	0e 9c       	mov	r12,r7
800052fe:	d8 22       	popm	r4-r7,pc
80005300:	00 00       	add	r0,r0
80005302:	1f ac       	ld.ub	r12,pc[0x2]
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	4e 54       	lddpc	r4,80005498 <xQueueGenericReceive+0x34>

80005308 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005308:	d4 21       	pushm	r4-r7,lr
8000530a:	16 95       	mov	r5,r11
8000530c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000530e:	20 1c       	sub	r12,1
80005310:	58 2c       	cp.w	r12,2
80005312:	e0 8b 00 12 	brhi	80005336 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005316:	58 0a       	cp.w	r10,0
80005318:	c0 31       	brne	8000531e <_write+0x16>
8000531a:	30 07       	mov	r7,0
8000531c:	c0 e8       	rjmp	80005338 <_write+0x30>
8000531e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005320:	48 74       	lddpc	r4,8000533c <_write+0x34>
80005322:	68 0c       	ld.w	r12,r4[0x0]
80005324:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005328:	f0 1f 00 06 	mcall	80005340 <_write+0x38>
8000532c:	c0 55       	brlt	80005336 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000532e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005330:	0e 36       	cp.w	r6,r7
80005332:	cf 81       	brne	80005322 <_write+0x1a>
80005334:	c0 28       	rjmp	80005338 <_write+0x30>
80005336:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005338:	0e 9c       	mov	r12,r7
8000533a:	d8 22       	popm	r4-r7,pc
8000533c:	00 00       	add	r0,r0
8000533e:	1f ac       	ld.ub	r12,pc[0x2]
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	4e 04       	lddpc	r4,800054c0 <xQueueGenericReceive+0x5c>

80005344 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005344:	eb cd 40 80 	pushm	r7,lr
80005348:	18 97       	mov	r7,r12
	if( pv )
8000534a:	58 0c       	cp.w	r12,0
8000534c:	c0 80       	breq	8000535c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000534e:	f0 1f 00 05 	mcall	80005360 <vPortFree+0x1c>
		{
			free( pv );
80005352:	0e 9c       	mov	r12,r7
80005354:	f0 1f 00 04 	mcall	80005364 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005358:	f0 1f 00 04 	mcall	80005368 <vPortFree+0x24>
8000535c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	58 04       	cp.w	r4,0
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	65 14       	ld.w	r4,r2[0x44]
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	5b c0       	cp.w	r0,-4

8000536c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000536c:	eb cd 40 80 	pushm	r7,lr
80005370:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005372:	f0 1f 00 06 	mcall	80005388 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005376:	0e 9c       	mov	r12,r7
80005378:	f0 1f 00 05 	mcall	8000538c <pvPortMalloc+0x20>
8000537c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000537e:	f0 1f 00 05 	mcall	80005390 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005382:	0e 9c       	mov	r12,r7
80005384:	e3 cd 80 80 	ldm	sp++,r7,pc
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	58 04       	cp.w	r4,0
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	65 24       	ld.w	r4,r2[0x48]
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	5b c0       	cp.w	r0,-4

80005394 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005394:	d4 01       	pushm	lr
80005396:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005398:	78 09       	ld.w	r9,r12[0x0]
8000539a:	58 09       	cp.w	r9,0
8000539c:	c1 10       	breq	800053be <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000539e:	78 3a       	ld.w	r10,r12[0xc]
800053a0:	79 09       	ld.w	r9,r12[0x40]
800053a2:	f4 09 00 09 	add	r9,r10,r9
800053a6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800053a8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800053aa:	14 39       	cp.w	r9,r10
800053ac:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800053b0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800053b4:	79 0a       	ld.w	r10,r12[0x40]
800053b6:	78 3b       	ld.w	r11,r12[0xc]
800053b8:	10 9c       	mov	r12,r8
800053ba:	f0 1f 00 02 	mcall	800053c0 <prvCopyDataFromQueue+0x2c>
800053be:	d8 02       	popm	pc
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	69 92       	ld.w	r2,r4[0x64]

800053c4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800053c4:	eb cd 40 c0 	pushm	r6-r7,lr
800053c8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800053ca:	f0 1f 00 23 	mcall	80005454 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800053ce:	6f 28       	ld.w	r8,r7[0x48]
800053d0:	58 08       	cp.w	r8,0
800053d2:	e0 8a 00 18 	brle	80005402 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800053d6:	6e 98       	ld.w	r8,r7[0x24]
800053d8:	58 08       	cp.w	r8,0
800053da:	c1 40       	breq	80005402 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800053dc:	ee c6 ff dc 	sub	r6,r7,-36
800053e0:	c0 48       	rjmp	800053e8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800053e2:	6e 98       	ld.w	r8,r7[0x24]
800053e4:	58 08       	cp.w	r8,0
800053e6:	c0 e0       	breq	80005402 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800053e8:	0c 9c       	mov	r12,r6
800053ea:	f0 1f 00 1c 	mcall	80005458 <prvUnlockQueue+0x94>
800053ee:	c0 30       	breq	800053f4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800053f0:	f0 1f 00 1b 	mcall	8000545c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800053f4:	6f 28       	ld.w	r8,r7[0x48]
800053f6:	20 18       	sub	r8,1
800053f8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800053fc:	58 08       	cp.w	r8,0
800053fe:	fe 99 ff f2 	brgt	800053e2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005402:	3f f8       	mov	r8,-1
80005404:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005408:	f0 1f 00 16 	mcall	80005460 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000540c:	f0 1f 00 12 	mcall	80005454 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005410:	6f 18       	ld.w	r8,r7[0x44]
80005412:	58 08       	cp.w	r8,0
80005414:	e0 8a 00 18 	brle	80005444 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005418:	6e 48       	ld.w	r8,r7[0x10]
8000541a:	58 08       	cp.w	r8,0
8000541c:	c1 40       	breq	80005444 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000541e:	ee c6 ff f0 	sub	r6,r7,-16
80005422:	c0 48       	rjmp	8000542a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005424:	6e 48       	ld.w	r8,r7[0x10]
80005426:	58 08       	cp.w	r8,0
80005428:	c0 e0       	breq	80005444 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000542a:	0c 9c       	mov	r12,r6
8000542c:	f0 1f 00 0b 	mcall	80005458 <prvUnlockQueue+0x94>
80005430:	c0 30       	breq	80005436 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005432:	f0 1f 00 0b 	mcall	8000545c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005436:	6f 18       	ld.w	r8,r7[0x44]
80005438:	20 18       	sub	r8,1
8000543a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000543e:	58 08       	cp.w	r8,0
80005440:	fe 99 ff f2 	brgt	80005424 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005444:	3f f8       	mov	r8,-1
80005446:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000544a:	f0 1f 00 06 	mcall	80005460 <prvUnlockQueue+0x9c>
}
8000544e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005452:	00 00       	add	r0,r0
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	51 00       	stdsp	sp[0x40],r0
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	59 9c       	cp.w	r12,25
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	58 a8       	cp.w	r8,10
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	52 0c       	stdsp	sp[0x80],r12

80005464 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005464:	d4 31       	pushm	r0-r7,lr
80005466:	20 5d       	sub	sp,20
80005468:	18 97       	mov	r7,r12
8000546a:	50 0b       	stdsp	sp[0x0],r11
8000546c:	50 2a       	stdsp	sp[0x8],r10
8000546e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005470:	f8 c2 ff dc 	sub	r2,r12,-36
80005474:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005476:	fa c4 ff f4 	sub	r4,sp,-12
8000547a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000547c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000547e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005482:	f0 1f 00 3e 	mcall	80005578 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005486:	6e e8       	ld.w	r8,r7[0x38]
80005488:	58 08       	cp.w	r8,0
8000548a:	c2 a0       	breq	800054de <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000548c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000548e:	40 0b       	lddsp	r11,sp[0x0]
80005490:	0e 9c       	mov	r12,r7
80005492:	f0 1f 00 3b 	mcall	8000557c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005496:	40 18       	lddsp	r8,sp[0x4]
80005498:	58 08       	cp.w	r8,0
8000549a:	c1 51       	brne	800054c4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000549c:	6e e8       	ld.w	r8,r7[0x38]
8000549e:	20 18       	sub	r8,1
800054a0:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800054a2:	6e 08       	ld.w	r8,r7[0x0]
800054a4:	58 08       	cp.w	r8,0
800054a6:	c0 41       	brne	800054ae <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800054a8:	f0 1f 00 36 	mcall	80005580 <xQueueGenericReceive+0x11c>
800054ac:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800054ae:	6e 48       	ld.w	r8,r7[0x10]
800054b0:	58 08       	cp.w	r8,0
800054b2:	c1 20       	breq	800054d6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800054b4:	ee cc ff f0 	sub	r12,r7,-16
800054b8:	f0 1f 00 33 	mcall	80005584 <xQueueGenericReceive+0x120>
800054bc:	58 1c       	cp.w	r12,1
800054be:	c0 c1       	brne	800054d6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800054c0:	d7 33       	scall
800054c2:	c0 a8       	rjmp	800054d6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800054c4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800054c6:	6e 98       	ld.w	r8,r7[0x24]
800054c8:	58 08       	cp.w	r8,0
800054ca:	c0 60       	breq	800054d6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800054cc:	04 9c       	mov	r12,r2
800054ce:	f0 1f 00 2e 	mcall	80005584 <xQueueGenericReceive+0x120>
800054d2:	c0 20       	breq	800054d6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800054d4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800054d6:	f0 1f 00 2d 	mcall	80005588 <xQueueGenericReceive+0x124>
800054da:	30 1c       	mov	r12,1
				return pdPASS;
800054dc:	c4 c8       	rjmp	80005574 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800054de:	40 28       	lddsp	r8,sp[0x8]
800054e0:	58 08       	cp.w	r8,0
800054e2:	c0 51       	brne	800054ec <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800054e4:	f0 1f 00 29 	mcall	80005588 <xQueueGenericReceive+0x124>
800054e8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800054ea:	c4 58       	rjmp	80005574 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800054ec:	58 05       	cp.w	r5,0
800054ee:	c0 51       	brne	800054f8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800054f0:	08 9c       	mov	r12,r4
800054f2:	f0 1f 00 27 	mcall	8000558c <xQueueGenericReceive+0x128>
800054f6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800054f8:	f0 1f 00 24 	mcall	80005588 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800054fc:	f0 1f 00 25 	mcall	80005590 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005500:	f0 1f 00 1e 	mcall	80005578 <xQueueGenericReceive+0x114>
80005504:	6f 18       	ld.w	r8,r7[0x44]
80005506:	5b f8       	cp.w	r8,-1
80005508:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000550c:	6f 28       	ld.w	r8,r7[0x48]
8000550e:	5b f8       	cp.w	r8,-1
80005510:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005514:	f0 1f 00 1d 	mcall	80005588 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005518:	06 9b       	mov	r11,r3
8000551a:	08 9c       	mov	r12,r4
8000551c:	f0 1f 00 1e 	mcall	80005594 <xQueueGenericReceive+0x130>
80005520:	c2 41       	brne	80005568 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005522:	f0 1f 00 16 	mcall	80005578 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005526:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005528:	f0 1f 00 18 	mcall	80005588 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000552c:	58 06       	cp.w	r6,0
8000552e:	c1 71       	brne	8000555c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005530:	6e 08       	ld.w	r8,r7[0x0]
80005532:	58 08       	cp.w	r8,0
80005534:	c0 81       	brne	80005544 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005536:	f0 1f 00 11 	mcall	80005578 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000553a:	6e 1c       	ld.w	r12,r7[0x4]
8000553c:	f0 1f 00 17 	mcall	80005598 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005540:	f0 1f 00 12 	mcall	80005588 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005544:	40 2b       	lddsp	r11,sp[0x8]
80005546:	04 9c       	mov	r12,r2
80005548:	f0 1f 00 15 	mcall	8000559c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000554c:	0e 9c       	mov	r12,r7
8000554e:	f0 1f 00 15 	mcall	800055a0 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005552:	f0 1f 00 15 	mcall	800055a4 <xQueueGenericReceive+0x140>
80005556:	c9 61       	brne	80005482 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005558:	d7 33       	scall
8000555a:	c9 4b       	rjmp	80005482 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000555c:	0e 9c       	mov	r12,r7
8000555e:	f0 1f 00 11 	mcall	800055a0 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005562:	f0 1f 00 11 	mcall	800055a4 <xQueueGenericReceive+0x140>
80005566:	c8 eb       	rjmp	80005482 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005568:	0e 9c       	mov	r12,r7
8000556a:	f0 1f 00 0e 	mcall	800055a0 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000556e:	f0 1f 00 0e 	mcall	800055a4 <xQueueGenericReceive+0x140>
80005572:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005574:	2f bd       	sub	sp,-20
80005576:	d8 32       	popm	r0-r7,pc
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	51 00       	stdsp	sp[0x40],r0
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	53 94       	stdsp	sp[0xe4],r4
80005580:	80 00       	ld.sh	r0,r0[0x0]
80005582:	58 b4       	cp.w	r4,11
80005584:	80 00       	ld.sh	r0,r0[0x0]
80005586:	59 9c       	cp.w	r12,25
80005588:	80 00       	ld.sh	r0,r0[0x0]
8000558a:	52 0c       	stdsp	sp[0x80],r12
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	58 90       	cp.w	r0,9
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	58 04       	cp.w	r4,0
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	5b 2c       	cp.w	r12,-14
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	59 18       	cp.w	r8,17
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	5d cc       	*unknown*
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	53 c4       	stdsp	sp[0xf0],r4
800055a4:	80 00       	ld.sh	r0,r0[0x0]
800055a6:	5b c0       	cp.w	r0,-4

800055a8 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800055a8:	eb cd 40 80 	pushm	r7,lr
800055ac:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800055ae:	79 08       	ld.w	r8,r12[0x40]
800055b0:	58 08       	cp.w	r8,0
800055b2:	c0 a1       	brne	800055c6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800055b4:	78 08       	ld.w	r8,r12[0x0]
800055b6:	58 08       	cp.w	r8,0
800055b8:	c2 b1       	brne	8000560e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800055ba:	78 1c       	ld.w	r12,r12[0x4]
800055bc:	f0 1f 00 17 	mcall	80005618 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800055c0:	30 08       	mov	r8,0
800055c2:	8f 18       	st.w	r7[0x4],r8
800055c4:	c2 58       	rjmp	8000560e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800055c6:	58 0a       	cp.w	r10,0
800055c8:	c1 01       	brne	800055e8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800055ca:	10 9a       	mov	r10,r8
800055cc:	78 2c       	ld.w	r12,r12[0x8]
800055ce:	f0 1f 00 14 	mcall	8000561c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800055d2:	6e 29       	ld.w	r9,r7[0x8]
800055d4:	6f 08       	ld.w	r8,r7[0x40]
800055d6:	f2 08 00 08 	add	r8,r9,r8
800055da:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800055dc:	6e 19       	ld.w	r9,r7[0x4]
800055de:	12 38       	cp.w	r8,r9
800055e0:	c1 73       	brcs	8000560e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800055e2:	6e 08       	ld.w	r8,r7[0x0]
800055e4:	8f 28       	st.w	r7[0x8],r8
800055e6:	c1 48       	rjmp	8000560e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800055e8:	10 9a       	mov	r10,r8
800055ea:	78 3c       	ld.w	r12,r12[0xc]
800055ec:	f0 1f 00 0c 	mcall	8000561c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800055f0:	6f 08       	ld.w	r8,r7[0x40]
800055f2:	6e 39       	ld.w	r9,r7[0xc]
800055f4:	f2 08 01 08 	sub	r8,r9,r8
800055f8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800055fa:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800055fc:	12 38       	cp.w	r8,r9
800055fe:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005602:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005606:	f3 d8 e3 19 	subcs	r9,r9,r8
8000560a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000560e:	6e e8       	ld.w	r8,r7[0x38]
80005610:	2f f8       	sub	r8,-1
80005612:	8f e8       	st.w	r7[0x38],r8
}
80005614:	e3 cd 80 80 	ldm	sp++,r7,pc
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	58 c0       	cp.w	r0,12
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	69 92       	ld.w	r2,r4[0x64]

80005620 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005620:	d4 31       	pushm	r0-r7,lr
80005622:	20 5d       	sub	sp,20
80005624:	18 97       	mov	r7,r12
80005626:	50 0b       	stdsp	sp[0x0],r11
80005628:	50 2a       	stdsp	sp[0x8],r10
8000562a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000562c:	f8 c0 ff f0 	sub	r0,r12,-16
80005630:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005632:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005636:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005638:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000563c:	f0 1f 00 2f 	mcall	800056f8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005640:	6e e9       	ld.w	r9,r7[0x38]
80005642:	6e f8       	ld.w	r8,r7[0x3c]
80005644:	10 39       	cp.w	r9,r8
80005646:	c1 42       	brcc	8000566e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005648:	40 1a       	lddsp	r10,sp[0x4]
8000564a:	40 0b       	lddsp	r11,sp[0x0]
8000564c:	0e 9c       	mov	r12,r7
8000564e:	f0 1f 00 2c 	mcall	800056fc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005652:	6e 98       	ld.w	r8,r7[0x24]
80005654:	58 08       	cp.w	r8,0
80005656:	c0 80       	breq	80005666 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005658:	ee cc ff dc 	sub	r12,r7,-36
8000565c:	f0 1f 00 29 	mcall	80005700 <xQueueGenericSend+0xe0>
80005660:	58 1c       	cp.w	r12,1
80005662:	c0 21       	brne	80005666 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005664:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005666:	f0 1f 00 28 	mcall	80005704 <xQueueGenericSend+0xe4>
8000566a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000566c:	c4 38       	rjmp	800056f2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000566e:	40 28       	lddsp	r8,sp[0x8]
80005670:	58 08       	cp.w	r8,0
80005672:	c0 51       	brne	8000567c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005674:	f0 1f 00 24 	mcall	80005704 <xQueueGenericSend+0xe4>
80005678:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000567a:	c3 c8       	rjmp	800056f2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000567c:	58 04       	cp.w	r4,0
8000567e:	c0 51       	brne	80005688 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005680:	06 9c       	mov	r12,r3
80005682:	f0 1f 00 22 	mcall	80005708 <xQueueGenericSend+0xe8>
80005686:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005688:	f0 1f 00 1f 	mcall	80005704 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000568c:	f0 1f 00 20 	mcall	8000570c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005690:	f0 1f 00 1a 	mcall	800056f8 <xQueueGenericSend+0xd8>
80005694:	6f 18       	ld.w	r8,r7[0x44]
80005696:	5b f8       	cp.w	r8,-1
80005698:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000569c:	6f 28       	ld.w	r8,r7[0x48]
8000569e:	5b f8       	cp.w	r8,-1
800056a0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800056a4:	f0 1f 00 18 	mcall	80005704 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800056a8:	04 9b       	mov	r11,r2
800056aa:	06 9c       	mov	r12,r3
800056ac:	f0 1f 00 19 	mcall	80005710 <xQueueGenericSend+0xf0>
800056b0:	c1 b1       	brne	800056e6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800056b2:	f0 1f 00 12 	mcall	800056f8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800056b6:	6e e5       	ld.w	r5,r7[0x38]
800056b8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800056ba:	f0 1f 00 13 	mcall	80005704 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800056be:	0c 35       	cp.w	r5,r6
800056c0:	c0 d1       	brne	800056da <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800056c2:	40 2b       	lddsp	r11,sp[0x8]
800056c4:	00 9c       	mov	r12,r0
800056c6:	f0 1f 00 14 	mcall	80005714 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800056ca:	0e 9c       	mov	r12,r7
800056cc:	f0 1f 00 13 	mcall	80005718 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800056d0:	f0 1f 00 13 	mcall	8000571c <xQueueGenericSend+0xfc>
800056d4:	cb 41       	brne	8000563c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800056d6:	d7 33       	scall
800056d8:	cb 2b       	rjmp	8000563c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800056da:	0e 9c       	mov	r12,r7
800056dc:	f0 1f 00 0f 	mcall	80005718 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800056e0:	f0 1f 00 0f 	mcall	8000571c <xQueueGenericSend+0xfc>
800056e4:	ca cb       	rjmp	8000563c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800056e6:	0e 9c       	mov	r12,r7
800056e8:	f0 1f 00 0c 	mcall	80005718 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800056ec:	f0 1f 00 0c 	mcall	8000571c <xQueueGenericSend+0xfc>
800056f0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800056f2:	2f bd       	sub	sp,-20
800056f4:	d8 32       	popm	r0-r7,pc
800056f6:	00 00       	add	r0,r0
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	51 00       	stdsp	sp[0x40],r0
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	55 a8       	stdsp	sp[0x168],r8
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	59 9c       	cp.w	r12,25
80005704:	80 00       	ld.sh	r0,r0[0x0]
80005706:	52 0c       	stdsp	sp[0x80],r12
80005708:	80 00       	ld.sh	r0,r0[0x0]
8000570a:	58 90       	cp.w	r0,9
8000570c:	80 00       	ld.sh	r0,r0[0x0]
8000570e:	58 04       	cp.w	r4,0
80005710:	80 00       	ld.sh	r0,r0[0x0]
80005712:	5b 2c       	cp.w	r12,-14
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	5d cc       	*unknown*
80005718:	80 00       	ld.sh	r0,r0[0x0]
8000571a:	53 c4       	stdsp	sp[0xf0],r4
8000571c:	80 00       	ld.sh	r0,r0[0x0]
8000571e:	5b c0       	cp.w	r0,-4

80005720 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005720:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005724:	34 cc       	mov	r12,76
80005726:	f0 1f 00 12 	mcall	8000576c <xQueueCreateMutex+0x4c>
8000572a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000572c:	c1 d0       	breq	80005766 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000572e:	30 06       	mov	r6,0
80005730:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005732:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005734:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005736:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005738:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000573a:	30 18       	mov	r8,1
8000573c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000573e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80005742:	3f f8       	mov	r8,-1
80005744:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005748:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000574c:	2f 0c       	sub	r12,-16
8000574e:	f0 1f 00 09 	mcall	80005770 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005752:	ee cc ff dc 	sub	r12,r7,-36
80005756:	f0 1f 00 07 	mcall	80005770 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000575a:	0c 99       	mov	r9,r6
8000575c:	0c 9a       	mov	r10,r6
8000575e:	0c 9b       	mov	r11,r6
80005760:	0e 9c       	mov	r12,r7
80005762:	f0 1f 00 05 	mcall	80005774 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80005766:	0e 9c       	mov	r12,r7
80005768:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	53 6c       	stdsp	sp[0xd8],r12
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	4f dc       	lddpc	r12,80005964 <vTaskPriorityInherit+0x4c>
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	56 20       	stdsp	sp[0x188],r0

80005778 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005778:	d4 21       	pushm	r4-r7,lr
8000577a:	18 97       	mov	r7,r12
8000577c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000577e:	58 0c       	cp.w	r12,0
80005780:	c2 f0       	breq	800057de <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005782:	34 cc       	mov	r12,76
80005784:	f0 1f 00 17 	mcall	800057e0 <xQueueCreate+0x68>
80005788:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000578a:	c2 a0       	breq	800057de <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000578c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005790:	e8 cc ff ff 	sub	r12,r4,-1
80005794:	f0 1f 00 13 	mcall	800057e0 <xQueueCreate+0x68>
80005798:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000579a:	c1 e0       	breq	800057d6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000579c:	f8 04 00 04 	add	r4,r12,r4
800057a0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800057a2:	30 08       	mov	r8,0
800057a4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800057a6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800057a8:	ee c8 00 01 	sub	r8,r7,1
800057ac:	ad 38       	mul	r8,r6
800057ae:	10 0c       	add	r12,r8
800057b0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800057b2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800057b4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800057b8:	3f f8       	mov	r8,-1
800057ba:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800057be:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800057c2:	ea cc ff f0 	sub	r12,r5,-16
800057c6:	f0 1f 00 08 	mcall	800057e4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800057ca:	ea cc ff dc 	sub	r12,r5,-36
800057ce:	f0 1f 00 06 	mcall	800057e4 <xQueueCreate+0x6c>
800057d2:	0a 9c       	mov	r12,r5
800057d4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800057d6:	0a 9c       	mov	r12,r5
800057d8:	f0 1f 00 04 	mcall	800057e8 <xQueueCreate+0x70>
800057dc:	d8 2a       	popm	r4-r7,pc,r12=0
800057de:	d8 2a       	popm	r4-r7,pc,r12=0
800057e0:	80 00       	ld.sh	r0,r0[0x0]
800057e2:	53 6c       	stdsp	sp[0xd8],r12
800057e4:	80 00       	ld.sh	r0,r0[0x0]
800057e6:	4f dc       	lddpc	r12,800059d8 <xTaskRemoveFromEventList+0x3c>
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	53 44       	stdsp	sp[0xd0],r4

800057ec <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
800057ec:	eb cd 40 80 	pushm	r7,lr
800057f0:	16 97       	mov	r7,r11
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
800057f2:	30 0b       	mov	r11,0
800057f4:	f0 1f 00 03 	mcall	80005800 <xQueueCreateCountingSemaphore+0x14>

		if( pxHandle != NULL )
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
800057f8:	f9 f7 1a 0e 	st.wne	r12[0x38],r7
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
	}
800057fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	57 78       	stdsp	sp[0x1dc],r8

80005804 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005804:	48 38       	lddpc	r8,80005810 <vTaskSuspendAll+0xc>
80005806:	70 09       	ld.w	r9,r8[0x0]
80005808:	2f f9       	sub	r9,-1
8000580a:	91 09       	st.w	r8[0x0],r9
}
8000580c:	5e fc       	retal	r12
8000580e:	00 00       	add	r0,r0
80005810:	00 00       	add	r0,r0
80005812:	0c 80       	andn	r0,r6

80005814 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005814:	49 a8       	lddpc	r8,8000587c <vTaskSwitchContext+0x68>
80005816:	70 08       	ld.w	r8,r8[0x0]
80005818:	58 08       	cp.w	r8,0
8000581a:	c0 b1       	brne	80005830 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000581c:	49 98       	lddpc	r8,80005880 <vTaskSwitchContext+0x6c>
8000581e:	70 08       	ld.w	r8,r8[0x0]
80005820:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005824:	49 89       	lddpc	r9,80005884 <vTaskSwitchContext+0x70>
80005826:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000582a:	58 08       	cp.w	r8,0
8000582c:	c0 60       	breq	80005838 <vTaskSwitchContext+0x24>
8000582e:	c1 18       	rjmp	80005850 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005830:	30 19       	mov	r9,1
80005832:	49 68       	lddpc	r8,80005888 <vTaskSwitchContext+0x74>
80005834:	91 09       	st.w	r8[0x0],r9
80005836:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005838:	49 28       	lddpc	r8,80005880 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000583a:	49 3a       	lddpc	r10,80005884 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000583c:	70 09       	ld.w	r9,r8[0x0]
8000583e:	20 19       	sub	r9,1
80005840:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005842:	70 09       	ld.w	r9,r8[0x0]
80005844:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005848:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000584c:	58 09       	cp.w	r9,0
8000584e:	cf 70       	breq	8000583c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005850:	48 c8       	lddpc	r8,80005880 <vTaskSwitchContext+0x6c>
80005852:	70 08       	ld.w	r8,r8[0x0]
80005854:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005858:	48 b9       	lddpc	r9,80005884 <vTaskSwitchContext+0x70>
8000585a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000585e:	70 19       	ld.w	r9,r8[0x4]
80005860:	72 19       	ld.w	r9,r9[0x4]
80005862:	91 19       	st.w	r8[0x4],r9
80005864:	f0 ca ff f8 	sub	r10,r8,-8
80005868:	14 39       	cp.w	r9,r10
8000586a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000586e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005872:	70 18       	ld.w	r8,r8[0x4]
80005874:	70 39       	ld.w	r9,r8[0xc]
80005876:	48 68       	lddpc	r8,8000588c <vTaskSwitchContext+0x78>
80005878:	91 09       	st.w	r8[0x0],r9
8000587a:	5e fc       	retal	r12
8000587c:	00 00       	add	r0,r0
8000587e:	0c 80       	andn	r0,r6
80005880:	00 00       	add	r0,r0
80005882:	0c b8       	st.h	r6++,r8
80005884:	00 00       	add	r0,r0
80005886:	0b 9c       	ld.ub	r12,r5[0x1]
80005888:	00 00       	add	r0,r0
8000588a:	0c a0       	st.w	r6++,r0
8000588c:	00 00       	add	r0,r0
8000588e:	0c 50       	eor	r0,r6

80005890 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005890:	48 48       	lddpc	r8,800058a0 <vTaskSetTimeOutState+0x10>
80005892:	70 08       	ld.w	r8,r8[0x0]
80005894:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005896:	48 48       	lddpc	r8,800058a4 <vTaskSetTimeOutState+0x14>
80005898:	70 08       	ld.w	r8,r8[0x0]
8000589a:	99 18       	st.w	r12[0x4],r8
}
8000589c:	5e fc       	retal	r12
8000589e:	00 00       	add	r0,r0
800058a0:	00 00       	add	r0,r0
800058a2:	0b 94       	ld.ub	r4,r5[0x1]
800058a4:	00 00       	add	r0,r0
800058a6:	0c 7c       	tst	r12,r6

800058a8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800058a8:	30 19       	mov	r9,1
800058aa:	48 28       	lddpc	r8,800058b0 <vTaskMissedYield+0x8>
800058ac:	91 09       	st.w	r8[0x0],r9
}
800058ae:	5e fc       	retal	r12
800058b0:	00 00       	add	r0,r0
800058b2:	0c a0       	st.w	r6++,r0

800058b4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800058b4:	48 28       	lddpc	r8,800058bc <xTaskGetCurrentTaskHandle+0x8>
800058b6:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800058b8:	5e fc       	retal	r12
800058ba:	00 00       	add	r0,r0
800058bc:	00 00       	add	r0,r0
800058be:	0c 50       	eor	r0,r6

800058c0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800058c0:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800058c4:	58 0c       	cp.w	r12,0
800058c6:	c1 f0       	breq	80005904 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800058c8:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800058ca:	78 b9       	ld.w	r9,r12[0x2c]
800058cc:	79 18       	ld.w	r8,r12[0x44]
800058ce:	10 39       	cp.w	r9,r8
800058d0:	c1 a0       	breq	80005904 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800058d2:	f8 c6 ff fc 	sub	r6,r12,-4
800058d6:	0c 9c       	mov	r12,r6
800058d8:	f0 1f 00 0c 	mcall	80005908 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800058dc:	6f 1c       	ld.w	r12,r7[0x44]
800058de:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800058e0:	f8 08 11 08 	rsub	r8,r12,8
800058e4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800058e6:	48 a8       	lddpc	r8,8000590c <vTaskPriorityDisinherit+0x4c>
800058e8:	70 08       	ld.w	r8,r8[0x0]
800058ea:	10 3c       	cp.w	r12,r8
800058ec:	e0 88 00 04 	brls	800058f4 <vTaskPriorityDisinherit+0x34>
800058f0:	48 78       	lddpc	r8,8000590c <vTaskPriorityDisinherit+0x4c>
800058f2:	91 0c       	st.w	r8[0x0],r12
800058f4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800058f8:	0c 9b       	mov	r11,r6
800058fa:	48 68       	lddpc	r8,80005910 <vTaskPriorityDisinherit+0x50>
800058fc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005900:	f0 1f 00 05 	mcall	80005914 <vTaskPriorityDisinherit+0x54>
80005904:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	50 46       	stdsp	sp[0x10],r6
8000590c:	00 00       	add	r0,r0
8000590e:	0c b8       	st.h	r6++,r8
80005910:	00 00       	add	r0,r0
80005912:	0b 9c       	ld.ub	r12,r5[0x1]
80005914:	80 00       	ld.sh	r0,r0[0x0]
80005916:	4f f6       	lddpc	r6,80005b10 <vTaskIncrementTick+0xf8>

80005918 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005918:	eb cd 40 c0 	pushm	r6-r7,lr
8000591c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000591e:	49 b8       	lddpc	r8,80005988 <vTaskPriorityInherit+0x70>
80005920:	70 08       	ld.w	r8,r8[0x0]
80005922:	78 b9       	ld.w	r9,r12[0x2c]
80005924:	70 b8       	ld.w	r8,r8[0x2c]
80005926:	10 39       	cp.w	r9,r8
80005928:	c2 d2       	brcc	80005982 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000592a:	49 88       	lddpc	r8,80005988 <vTaskPriorityInherit+0x70>
8000592c:	70 08       	ld.w	r8,r8[0x0]
8000592e:	70 b8       	ld.w	r8,r8[0x2c]
80005930:	f0 08 11 08 	rsub	r8,r8,8
80005934:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005936:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000593a:	49 59       	lddpc	r9,8000598c <vTaskPriorityInherit+0x74>
8000593c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005940:	78 59       	ld.w	r9,r12[0x14]
80005942:	10 39       	cp.w	r9,r8
80005944:	c1 b1       	brne	8000597a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005946:	f8 c6 ff fc 	sub	r6,r12,-4
8000594a:	0c 9c       	mov	r12,r6
8000594c:	f0 1f 00 11 	mcall	80005990 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005950:	48 e8       	lddpc	r8,80005988 <vTaskPriorityInherit+0x70>
80005952:	70 08       	ld.w	r8,r8[0x0]
80005954:	70 bc       	ld.w	r12,r8[0x2c]
80005956:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005958:	48 f8       	lddpc	r8,80005994 <vTaskPriorityInherit+0x7c>
8000595a:	70 08       	ld.w	r8,r8[0x0]
8000595c:	10 3c       	cp.w	r12,r8
8000595e:	e0 88 00 04 	brls	80005966 <vTaskPriorityInherit+0x4e>
80005962:	48 d8       	lddpc	r8,80005994 <vTaskPriorityInherit+0x7c>
80005964:	91 0c       	st.w	r8[0x0],r12
80005966:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000596a:	0c 9b       	mov	r11,r6
8000596c:	48 88       	lddpc	r8,8000598c <vTaskPriorityInherit+0x74>
8000596e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005972:	f0 1f 00 0a 	mcall	80005998 <vTaskPriorityInherit+0x80>
80005976:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000597a:	48 48       	lddpc	r8,80005988 <vTaskPriorityInherit+0x70>
8000597c:	70 08       	ld.w	r8,r8[0x0]
8000597e:	70 b8       	ld.w	r8,r8[0x2c]
80005980:	99 b8       	st.w	r12[0x2c],r8
80005982:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005986:	00 00       	add	r0,r0
80005988:	00 00       	add	r0,r0
8000598a:	0c 50       	eor	r0,r6
8000598c:	00 00       	add	r0,r0
8000598e:	0b 9c       	ld.ub	r12,r5[0x1]
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	50 46       	stdsp	sp[0x10],r6
80005994:	00 00       	add	r0,r0
80005996:	0c b8       	st.h	r6++,r8
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	4f f6       	lddpc	r6,80005b94 <xTaskCheckForTimeOut+0x68>

8000599c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000599c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800059a0:	78 38       	ld.w	r8,r12[0xc]
800059a2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800059a4:	ee c6 ff e8 	sub	r6,r7,-24
800059a8:	0c 9c       	mov	r12,r6
800059aa:	f0 1f 00 15 	mcall	800059fc <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800059ae:	49 58       	lddpc	r8,80005a00 <xTaskRemoveFromEventList+0x64>
800059b0:	70 08       	ld.w	r8,r8[0x0]
800059b2:	58 08       	cp.w	r8,0
800059b4:	c1 71       	brne	800059e2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800059b6:	ee c6 ff fc 	sub	r6,r7,-4
800059ba:	0c 9c       	mov	r12,r6
800059bc:	f0 1f 00 10 	mcall	800059fc <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800059c0:	6e bc       	ld.w	r12,r7[0x2c]
800059c2:	49 18       	lddpc	r8,80005a04 <xTaskRemoveFromEventList+0x68>
800059c4:	70 08       	ld.w	r8,r8[0x0]
800059c6:	10 3c       	cp.w	r12,r8
800059c8:	e0 88 00 04 	brls	800059d0 <xTaskRemoveFromEventList+0x34>
800059cc:	48 e8       	lddpc	r8,80005a04 <xTaskRemoveFromEventList+0x68>
800059ce:	91 0c       	st.w	r8[0x0],r12
800059d0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059d4:	0c 9b       	mov	r11,r6
800059d6:	48 d8       	lddpc	r8,80005a08 <xTaskRemoveFromEventList+0x6c>
800059d8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800059dc:	f0 1f 00 0c 	mcall	80005a0c <xTaskRemoveFromEventList+0x70>
800059e0:	c0 58       	rjmp	800059ea <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800059e2:	0c 9b       	mov	r11,r6
800059e4:	48 bc       	lddpc	r12,80005a10 <xTaskRemoveFromEventList+0x74>
800059e6:	f0 1f 00 0a 	mcall	80005a0c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800059ea:	48 b8       	lddpc	r8,80005a14 <xTaskRemoveFromEventList+0x78>
800059ec:	70 08       	ld.w	r8,r8[0x0]
800059ee:	6e b9       	ld.w	r9,r7[0x2c]
800059f0:	70 b8       	ld.w	r8,r8[0x2c]
800059f2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800059f4:	5f 2c       	srhs	r12
800059f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059fa:	00 00       	add	r0,r0
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	50 46       	stdsp	sp[0x10],r6
80005a00:	00 00       	add	r0,r0
80005a02:	0c 80       	andn	r0,r6
80005a04:	00 00       	add	r0,r0
80005a06:	0c b8       	st.h	r6++,r8
80005a08:	00 00       	add	r0,r0
80005a0a:	0b 9c       	ld.ub	r12,r5[0x1]
80005a0c:	80 00       	ld.sh	r0,r0[0x0]
80005a0e:	4f f6       	lddpc	r6,80005c08 <xTaskResumeAll+0x48>
80005a10:	00 00       	add	r0,r0
80005a12:	0c 54       	eor	r4,r6
80005a14:	00 00       	add	r0,r0
80005a16:	0c 50       	eor	r0,r6

80005a18 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005a18:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a1c:	4b 98       	lddpc	r8,80005b00 <vTaskIncrementTick+0xe8>
80005a1e:	70 08       	ld.w	r8,r8[0x0]
80005a20:	58 08       	cp.w	r8,0
80005a22:	c6 91       	brne	80005af4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005a24:	4b 88       	lddpc	r8,80005b04 <vTaskIncrementTick+0xec>
80005a26:	70 09       	ld.w	r9,r8[0x0]
80005a28:	2f f9       	sub	r9,-1
80005a2a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005a2c:	70 08       	ld.w	r8,r8[0x0]
80005a2e:	58 08       	cp.w	r8,0
80005a30:	c1 a1       	brne	80005a64 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005a32:	4b 68       	lddpc	r8,80005b08 <vTaskIncrementTick+0xf0>
80005a34:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005a36:	4b 69       	lddpc	r9,80005b0c <vTaskIncrementTick+0xf4>
80005a38:	72 0b       	ld.w	r11,r9[0x0]
80005a3a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005a3c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005a3e:	4b 59       	lddpc	r9,80005b10 <vTaskIncrementTick+0xf8>
80005a40:	72 0a       	ld.w	r10,r9[0x0]
80005a42:	2f fa       	sub	r10,-1
80005a44:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005a46:	70 08       	ld.w	r8,r8[0x0]
80005a48:	70 08       	ld.w	r8,r8[0x0]
80005a4a:	58 08       	cp.w	r8,0
80005a4c:	c0 51       	brne	80005a56 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005a4e:	3f f9       	mov	r9,-1
80005a50:	4b 18       	lddpc	r8,80005b14 <vTaskIncrementTick+0xfc>
80005a52:	91 09       	st.w	r8[0x0],r9
80005a54:	c0 88       	rjmp	80005a64 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005a56:	4a d8       	lddpc	r8,80005b08 <vTaskIncrementTick+0xf0>
80005a58:	70 08       	ld.w	r8,r8[0x0]
80005a5a:	70 38       	ld.w	r8,r8[0xc]
80005a5c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005a5e:	70 19       	ld.w	r9,r8[0x4]
80005a60:	4a d8       	lddpc	r8,80005b14 <vTaskIncrementTick+0xfc>
80005a62:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005a64:	4a 88       	lddpc	r8,80005b04 <vTaskIncrementTick+0xec>
80005a66:	70 09       	ld.w	r9,r8[0x0]
80005a68:	4a b8       	lddpc	r8,80005b14 <vTaskIncrementTick+0xfc>
80005a6a:	70 08       	ld.w	r8,r8[0x0]
80005a6c:	10 39       	cp.w	r9,r8
80005a6e:	c4 73       	brcs	80005afc <vTaskIncrementTick+0xe4>
80005a70:	4a 68       	lddpc	r8,80005b08 <vTaskIncrementTick+0xf0>
80005a72:	70 08       	ld.w	r8,r8[0x0]
80005a74:	70 08       	ld.w	r8,r8[0x0]
80005a76:	58 08       	cp.w	r8,0
80005a78:	c0 c0       	breq	80005a90 <vTaskIncrementTick+0x78>
80005a7a:	4a 48       	lddpc	r8,80005b08 <vTaskIncrementTick+0xf0>
80005a7c:	70 08       	ld.w	r8,r8[0x0]
80005a7e:	70 38       	ld.w	r8,r8[0xc]
80005a80:	70 37       	ld.w	r7,r8[0xc]
80005a82:	6e 18       	ld.w	r8,r7[0x4]
80005a84:	4a 09       	lddpc	r9,80005b04 <vTaskIncrementTick+0xec>
80005a86:	72 09       	ld.w	r9,r9[0x0]
80005a88:	12 38       	cp.w	r8,r9
80005a8a:	e0 88 00 14 	brls	80005ab2 <vTaskIncrementTick+0x9a>
80005a8e:	c0 e8       	rjmp	80005aaa <vTaskIncrementTick+0x92>
80005a90:	3f f9       	mov	r9,-1
80005a92:	4a 18       	lddpc	r8,80005b14 <vTaskIncrementTick+0xfc>
80005a94:	91 09       	st.w	r8[0x0],r9
80005a96:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005a9a:	6a 08       	ld.w	r8,r5[0x0]
80005a9c:	70 38       	ld.w	r8,r8[0xc]
80005a9e:	70 37       	ld.w	r7,r8[0xc]
80005aa0:	6e 18       	ld.w	r8,r7[0x4]
80005aa2:	64 09       	ld.w	r9,r2[0x0]
80005aa4:	12 38       	cp.w	r8,r9
80005aa6:	e0 88 00 0a 	brls	80005aba <vTaskIncrementTick+0xa2>
80005aaa:	49 b9       	lddpc	r9,80005b14 <vTaskIncrementTick+0xfc>
80005aac:	93 08       	st.w	r9[0x0],r8
80005aae:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005ab2:	49 a4       	lddpc	r4,80005b18 <vTaskIncrementTick+0x100>
80005ab4:	49 a3       	lddpc	r3,80005b1c <vTaskIncrementTick+0x104>
80005ab6:	49 55       	lddpc	r5,80005b08 <vTaskIncrementTick+0xf0>
80005ab8:	49 32       	lddpc	r2,80005b04 <vTaskIncrementTick+0xec>
80005aba:	ee c6 ff fc 	sub	r6,r7,-4
80005abe:	0c 9c       	mov	r12,r6
80005ac0:	f0 1f 00 18 	mcall	80005b20 <vTaskIncrementTick+0x108>
80005ac4:	6e a8       	ld.w	r8,r7[0x28]
80005ac6:	58 08       	cp.w	r8,0
80005ac8:	c0 50       	breq	80005ad2 <vTaskIncrementTick+0xba>
80005aca:	ee cc ff e8 	sub	r12,r7,-24
80005ace:	f0 1f 00 15 	mcall	80005b20 <vTaskIncrementTick+0x108>
80005ad2:	6e bc       	ld.w	r12,r7[0x2c]
80005ad4:	68 08       	ld.w	r8,r4[0x0]
80005ad6:	10 3c       	cp.w	r12,r8
80005ad8:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005adc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ae0:	0c 9b       	mov	r11,r6
80005ae2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005ae6:	f0 1f 00 10 	mcall	80005b24 <vTaskIncrementTick+0x10c>
80005aea:	6a 08       	ld.w	r8,r5[0x0]
80005aec:	70 08       	ld.w	r8,r8[0x0]
80005aee:	58 08       	cp.w	r8,0
80005af0:	cd 51       	brne	80005a9a <vTaskIncrementTick+0x82>
80005af2:	cc fb       	rjmp	80005a90 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005af4:	48 d8       	lddpc	r8,80005b28 <vTaskIncrementTick+0x110>
80005af6:	70 09       	ld.w	r9,r8[0x0]
80005af8:	2f f9       	sub	r9,-1
80005afa:	91 09       	st.w	r8[0x0],r9
80005afc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005b00:	00 00       	add	r0,r0
80005b02:	0c 80       	andn	r0,r6
80005b04:	00 00       	add	r0,r0
80005b06:	0c 7c       	tst	r12,r6
80005b08:	00 00       	add	r0,r0
80005b0a:	0b 88       	ld.ub	r8,r5[0x0]
80005b0c:	00 00       	add	r0,r0
80005b0e:	0b 98       	ld.ub	r8,r5[0x1]
80005b10:	00 00       	add	r0,r0
80005b12:	0b 94       	ld.ub	r4,r5[0x1]
80005b14:	00 00       	add	r0,r0
80005b16:	05 18       	ld.sh	r8,r2++
80005b18:	00 00       	add	r0,r0
80005b1a:	0c b8       	st.h	r6++,r8
80005b1c:	00 00       	add	r0,r0
80005b1e:	0b 9c       	ld.ub	r12,r5[0x1]
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	50 46       	stdsp	sp[0x10],r6
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	4f f6       	lddpc	r6,80005d20 <vTaskDelay+0x1c>
80005b28:	00 00       	add	r0,r0
80005b2a:	0b 80       	ld.ub	r0,r5[0x0]

80005b2c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005b2c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b30:	18 97       	mov	r7,r12
80005b32:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005b34:	f0 1f 00 15 	mcall	80005b88 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005b38:	6c 08       	ld.w	r8,r6[0x0]
80005b3a:	5b f8       	cp.w	r8,-1
80005b3c:	c0 31       	brne	80005b42 <xTaskCheckForTimeOut+0x16>
80005b3e:	30 07       	mov	r7,0
80005b40:	c1 f8       	rjmp	80005b7e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005b42:	49 39       	lddpc	r9,80005b8c <xTaskCheckForTimeOut+0x60>
80005b44:	72 09       	ld.w	r9,r9[0x0]
80005b46:	6e 0a       	ld.w	r10,r7[0x0]
80005b48:	12 3a       	cp.w	r10,r9
80005b4a:	c0 70       	breq	80005b58 <xTaskCheckForTimeOut+0x2c>
80005b4c:	49 19       	lddpc	r9,80005b90 <xTaskCheckForTimeOut+0x64>
80005b4e:	72 09       	ld.w	r9,r9[0x0]
80005b50:	6e 1a       	ld.w	r10,r7[0x4]
80005b52:	12 3a       	cp.w	r10,r9
80005b54:	e0 88 00 14 	brls	80005b7c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005b58:	48 e9       	lddpc	r9,80005b90 <xTaskCheckForTimeOut+0x64>
80005b5a:	72 0a       	ld.w	r10,r9[0x0]
80005b5c:	6e 19       	ld.w	r9,r7[0x4]
80005b5e:	12 1a       	sub	r10,r9
80005b60:	14 38       	cp.w	r8,r10
80005b62:	e0 88 00 0d 	brls	80005b7c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005b66:	48 ba       	lddpc	r10,80005b90 <xTaskCheckForTimeOut+0x64>
80005b68:	74 0a       	ld.w	r10,r10[0x0]
80005b6a:	14 19       	sub	r9,r10
80005b6c:	f2 08 00 08 	add	r8,r9,r8
80005b70:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005b72:	0e 9c       	mov	r12,r7
80005b74:	f0 1f 00 08 	mcall	80005b94 <xTaskCheckForTimeOut+0x68>
80005b78:	30 07       	mov	r7,0
80005b7a:	c0 28       	rjmp	80005b7e <xTaskCheckForTimeOut+0x52>
80005b7c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005b7e:	f0 1f 00 07 	mcall	80005b98 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005b82:	0e 9c       	mov	r12,r7
80005b84:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b88:	80 00       	ld.sh	r0,r0[0x0]
80005b8a:	51 00       	stdsp	sp[0x40],r0
80005b8c:	00 00       	add	r0,r0
80005b8e:	0b 94       	ld.ub	r4,r5[0x1]
80005b90:	00 00       	add	r0,r0
80005b92:	0c 7c       	tst	r12,r6
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	58 90       	cp.w	r0,9
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	52 0c       	stdsp	sp[0x80],r12

80005b9c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005b9c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005ba0:	f0 1f 00 05 	mcall	80005bb4 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005ba4:	48 58       	lddpc	r8,80005bb8 <xTaskGetTickCount+0x1c>
80005ba6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005ba8:	f0 1f 00 05 	mcall	80005bbc <xTaskGetTickCount+0x20>

	return xTicks;
}
80005bac:	0e 9c       	mov	r12,r7
80005bae:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bb2:	00 00       	add	r0,r0
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	51 00       	stdsp	sp[0x40],r0
80005bb8:	00 00       	add	r0,r0
80005bba:	0c 7c       	tst	r12,r6
80005bbc:	80 00       	ld.sh	r0,r0[0x0]
80005bbe:	52 0c       	stdsp	sp[0x80],r12

80005bc0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005bc0:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005bc4:	f0 1f 00 2c 	mcall	80005c74 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005bc8:	4a c8       	lddpc	r8,80005c78 <xTaskResumeAll+0xb8>
80005bca:	70 09       	ld.w	r9,r8[0x0]
80005bcc:	20 19       	sub	r9,1
80005bce:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005bd0:	70 08       	ld.w	r8,r8[0x0]
80005bd2:	58 08       	cp.w	r8,0
80005bd4:	c4 91       	brne	80005c66 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005bd6:	4a a8       	lddpc	r8,80005c7c <xTaskResumeAll+0xbc>
80005bd8:	70 08       	ld.w	r8,r8[0x0]
80005bda:	58 08       	cp.w	r8,0
80005bdc:	c4 50       	breq	80005c66 <xTaskResumeAll+0xa6>
80005bde:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005be0:	4a 85       	lddpc	r5,80005c80 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005be2:	4a 93       	lddpc	r3,80005c84 <xTaskResumeAll+0xc4>
80005be4:	4a 92       	lddpc	r2,80005c88 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005be6:	4a a1       	lddpc	r1,80005c8c <xTaskResumeAll+0xcc>
80005be8:	c1 e8       	rjmp	80005c24 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005bea:	6a 38       	ld.w	r8,r5[0xc]
80005bec:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005bee:	ee cc ff e8 	sub	r12,r7,-24
80005bf2:	f0 1f 00 28 	mcall	80005c90 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005bf6:	ee c6 ff fc 	sub	r6,r7,-4
80005bfa:	0c 9c       	mov	r12,r6
80005bfc:	f0 1f 00 25 	mcall	80005c90 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005c00:	6e bc       	ld.w	r12,r7[0x2c]
80005c02:	66 08       	ld.w	r8,r3[0x0]
80005c04:	10 3c       	cp.w	r12,r8
80005c06:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005c0a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c0e:	0c 9b       	mov	r11,r6
80005c10:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005c14:	f0 1f 00 20 	mcall	80005c94 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c18:	62 08       	ld.w	r8,r1[0x0]
80005c1a:	6e b9       	ld.w	r9,r7[0x2c]
80005c1c:	70 b8       	ld.w	r8,r8[0x2c]
80005c1e:	10 39       	cp.w	r9,r8
80005c20:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c24:	6a 08       	ld.w	r8,r5[0x0]
80005c26:	58 08       	cp.w	r8,0
80005c28:	ce 11       	brne	80005bea <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c2a:	49 c8       	lddpc	r8,80005c98 <xTaskResumeAll+0xd8>
80005c2c:	70 08       	ld.w	r8,r8[0x0]
80005c2e:	58 08       	cp.w	r8,0
80005c30:	c0 f0       	breq	80005c4e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c32:	49 a8       	lddpc	r8,80005c98 <xTaskResumeAll+0xd8>
80005c34:	70 08       	ld.w	r8,r8[0x0]
80005c36:	58 08       	cp.w	r8,0
80005c38:	c1 10       	breq	80005c5a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005c3a:	49 87       	lddpc	r7,80005c98 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005c3c:	f0 1f 00 18 	mcall	80005c9c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005c40:	6e 08       	ld.w	r8,r7[0x0]
80005c42:	20 18       	sub	r8,1
80005c44:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c46:	6e 08       	ld.w	r8,r7[0x0]
80005c48:	58 08       	cp.w	r8,0
80005c4a:	cf 91       	brne	80005c3c <xTaskResumeAll+0x7c>
80005c4c:	c0 78       	rjmp	80005c5a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005c4e:	58 14       	cp.w	r4,1
80005c50:	c0 50       	breq	80005c5a <xTaskResumeAll+0x9a>
80005c52:	49 48       	lddpc	r8,80005ca0 <xTaskResumeAll+0xe0>
80005c54:	70 08       	ld.w	r8,r8[0x0]
80005c56:	58 18       	cp.w	r8,1
80005c58:	c0 71       	brne	80005c66 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005c5a:	30 09       	mov	r9,0
80005c5c:	49 18       	lddpc	r8,80005ca0 <xTaskResumeAll+0xe0>
80005c5e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005c60:	d7 33       	scall
80005c62:	30 17       	mov	r7,1
80005c64:	c0 28       	rjmp	80005c68 <xTaskResumeAll+0xa8>
80005c66:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005c68:	f0 1f 00 0f 	mcall	80005ca4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005c6c:	0e 9c       	mov	r12,r7
80005c6e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005c72:	00 00       	add	r0,r0
80005c74:	80 00       	ld.sh	r0,r0[0x0]
80005c76:	51 00       	stdsp	sp[0x40],r0
80005c78:	00 00       	add	r0,r0
80005c7a:	0c 80       	andn	r0,r6
80005c7c:	00 00       	add	r0,r0
80005c7e:	0c 9c       	mov	r12,r6
80005c80:	00 00       	add	r0,r0
80005c82:	0c 54       	eor	r4,r6
80005c84:	00 00       	add	r0,r0
80005c86:	0c b8       	st.h	r6++,r8
80005c88:	00 00       	add	r0,r0
80005c8a:	0b 9c       	ld.ub	r12,r5[0x1]
80005c8c:	00 00       	add	r0,r0
80005c8e:	0c 50       	eor	r0,r6
80005c90:	80 00       	ld.sh	r0,r0[0x0]
80005c92:	50 46       	stdsp	sp[0x10],r6
80005c94:	80 00       	ld.sh	r0,r0[0x0]
80005c96:	4f f6       	lddpc	r6,80005e90 <prvIdleTask+0x6c>
80005c98:	00 00       	add	r0,r0
80005c9a:	0b 80       	ld.ub	r0,r5[0x0]
80005c9c:	80 00       	ld.sh	r0,r0[0x0]
80005c9e:	5a 18       	cp.w	r8,-31
80005ca0:	00 00       	add	r0,r0
80005ca2:	0c a0       	st.w	r6++,r0
80005ca4:	80 00       	ld.sh	r0,r0[0x0]
80005ca6:	52 0c       	stdsp	sp[0x80],r12

80005ca8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005ca8:	eb cd 40 80 	pushm	r7,lr
80005cac:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005cae:	49 08       	lddpc	r8,80005cec <prvAddCurrentTaskToDelayedList+0x44>
80005cb0:	70 08       	ld.w	r8,r8[0x0]
80005cb2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005cb4:	48 f8       	lddpc	r8,80005cf0 <prvAddCurrentTaskToDelayedList+0x48>
80005cb6:	70 08       	ld.w	r8,r8[0x0]
80005cb8:	10 3c       	cp.w	r12,r8
80005cba:	c0 a2       	brcc	80005cce <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005cbc:	48 c8       	lddpc	r8,80005cec <prvAddCurrentTaskToDelayedList+0x44>
80005cbe:	70 0b       	ld.w	r11,r8[0x0]
80005cc0:	48 d8       	lddpc	r8,80005cf4 <prvAddCurrentTaskToDelayedList+0x4c>
80005cc2:	70 0c       	ld.w	r12,r8[0x0]
80005cc4:	2f cb       	sub	r11,-4
80005cc6:	f0 1f 00 0d 	mcall	80005cf8 <prvAddCurrentTaskToDelayedList+0x50>
80005cca:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005cce:	48 88       	lddpc	r8,80005cec <prvAddCurrentTaskToDelayedList+0x44>
80005cd0:	70 0b       	ld.w	r11,r8[0x0]
80005cd2:	48 b8       	lddpc	r8,80005cfc <prvAddCurrentTaskToDelayedList+0x54>
80005cd4:	70 0c       	ld.w	r12,r8[0x0]
80005cd6:	2f cb       	sub	r11,-4
80005cd8:	f0 1f 00 08 	mcall	80005cf8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005cdc:	48 98       	lddpc	r8,80005d00 <prvAddCurrentTaskToDelayedList+0x58>
80005cde:	70 08       	ld.w	r8,r8[0x0]
80005ce0:	10 37       	cp.w	r7,r8
80005ce2:	c0 32       	brcc	80005ce8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005ce4:	48 78       	lddpc	r8,80005d00 <prvAddCurrentTaskToDelayedList+0x58>
80005ce6:	91 07       	st.w	r8[0x0],r7
80005ce8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cec:	00 00       	add	r0,r0
80005cee:	0c 50       	eor	r0,r6
80005cf0:	00 00       	add	r0,r0
80005cf2:	0c 7c       	tst	r12,r6
80005cf4:	00 00       	add	r0,r0
80005cf6:	0b 98       	ld.ub	r8,r5[0x1]
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	50 12       	stdsp	sp[0x4],r2
80005cfc:	00 00       	add	r0,r0
80005cfe:	0b 88       	ld.ub	r8,r5[0x0]
80005d00:	00 00       	add	r0,r0
80005d02:	05 18       	ld.sh	r8,r2++

80005d04 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80005d04:	eb cd 40 c0 	pushm	r6-r7,lr
80005d08:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80005d0a:	58 0c       	cp.w	r12,0
80005d0c:	c1 10       	breq	80005d2e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80005d0e:	f0 1f 00 0a 	mcall	80005d34 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80005d12:	48 a8       	lddpc	r8,80005d38 <vTaskDelay+0x34>
80005d14:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d16:	48 a8       	lddpc	r8,80005d3c <vTaskDelay+0x38>
80005d18:	70 0c       	ld.w	r12,r8[0x0]
80005d1a:	2f cc       	sub	r12,-4
80005d1c:	f0 1f 00 09 	mcall	80005d40 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005d20:	ee 06 00 0c 	add	r12,r7,r6
80005d24:	f0 1f 00 08 	mcall	80005d44 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80005d28:	f0 1f 00 08 	mcall	80005d48 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005d2c:	c0 21       	brne	80005d30 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80005d2e:	d7 33       	scall
80005d30:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	58 04       	cp.w	r4,0
80005d38:	00 00       	add	r0,r0
80005d3a:	0c 7c       	tst	r12,r6
80005d3c:	00 00       	add	r0,r0
80005d3e:	0c 50       	eor	r0,r6
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	50 46       	stdsp	sp[0x10],r6
80005d44:	80 00       	ld.sh	r0,r0[0x0]
80005d46:	5c a8       	swap.h	r8
80005d48:	80 00       	ld.sh	r0,r0[0x0]
80005d4a:	5b c0       	cp.w	r0,-4

80005d4c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005d4c:	eb cd 40 c0 	pushm	r6-r7,lr
80005d50:	18 96       	mov	r6,r12
80005d52:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005d54:	f0 1f 00 18 	mcall	80005db4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005d58:	6c 08       	ld.w	r8,r6[0x0]
80005d5a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005d5c:	49 79       	lddpc	r9,80005db8 <vTaskDelayUntil+0x6c>
80005d5e:	72 09       	ld.w	r9,r9[0x0]
80005d60:	12 38       	cp.w	r8,r9
80005d62:	e0 88 00 0c 	brls	80005d7a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005d66:	0e 38       	cp.w	r8,r7
80005d68:	e0 88 00 22 	brls	80005dac <vTaskDelayUntil+0x60>
80005d6c:	49 38       	lddpc	r8,80005db8 <vTaskDelayUntil+0x6c>
80005d6e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005d70:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005d72:	10 37       	cp.w	r7,r8
80005d74:	e0 88 00 14 	brls	80005d9c <vTaskDelayUntil+0x50>
80005d78:	c0 a8       	rjmp	80005d8c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005d7a:	0e 38       	cp.w	r8,r7
80005d7c:	e0 8b 00 16 	brhi	80005da8 <vTaskDelayUntil+0x5c>
80005d80:	48 e8       	lddpc	r8,80005db8 <vTaskDelayUntil+0x6c>
80005d82:	70 08       	ld.w	r8,r8[0x0]
80005d84:	10 37       	cp.w	r7,r8
80005d86:	e0 8b 00 11 	brhi	80005da8 <vTaskDelayUntil+0x5c>
80005d8a:	c1 18       	rjmp	80005dac <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d8c:	48 c8       	lddpc	r8,80005dbc <vTaskDelayUntil+0x70>
80005d8e:	70 0c       	ld.w	r12,r8[0x0]
80005d90:	2f cc       	sub	r12,-4
80005d92:	f0 1f 00 0c 	mcall	80005dc0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005d96:	0e 9c       	mov	r12,r7
80005d98:	f0 1f 00 0b 	mcall	80005dc4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005d9c:	f0 1f 00 0b 	mcall	80005dc8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005da0:	c0 81       	brne	80005db0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005da2:	d7 33       	scall
80005da4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005da8:	8d 07       	st.w	r6[0x0],r7
80005daa:	cf 1b       	rjmp	80005d8c <vTaskDelayUntil+0x40>
80005dac:	8d 07       	st.w	r6[0x0],r7
80005dae:	cf 7b       	rjmp	80005d9c <vTaskDelayUntil+0x50>
80005db0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005db4:	80 00       	ld.sh	r0,r0[0x0]
80005db6:	58 04       	cp.w	r4,0
80005db8:	00 00       	add	r0,r0
80005dba:	0c 7c       	tst	r12,r6
80005dbc:	00 00       	add	r0,r0
80005dbe:	0c 50       	eor	r0,r6
80005dc0:	80 00       	ld.sh	r0,r0[0x0]
80005dc2:	50 46       	stdsp	sp[0x10],r6
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	5c a8       	swap.h	r8
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	5b c0       	cp.w	r0,-4

80005dcc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005dcc:	eb cd 40 c0 	pushm	r6-r7,lr
80005dd0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005dd2:	48 e7       	lddpc	r7,80005e08 <vTaskPlaceOnEventList+0x3c>
80005dd4:	6e 0b       	ld.w	r11,r7[0x0]
80005dd6:	2e 8b       	sub	r11,-24
80005dd8:	f0 1f 00 0d 	mcall	80005e0c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ddc:	6e 0c       	ld.w	r12,r7[0x0]
80005dde:	2f cc       	sub	r12,-4
80005de0:	f0 1f 00 0c 	mcall	80005e10 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005de4:	5b f6       	cp.w	r6,-1
80005de6:	c0 81       	brne	80005df6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005de8:	6e 0b       	ld.w	r11,r7[0x0]
80005dea:	2f cb       	sub	r11,-4
80005dec:	48 ac       	lddpc	r12,80005e14 <vTaskPlaceOnEventList+0x48>
80005dee:	f0 1f 00 0b 	mcall	80005e18 <vTaskPlaceOnEventList+0x4c>
80005df2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005df6:	48 a8       	lddpc	r8,80005e1c <vTaskPlaceOnEventList+0x50>
80005df8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005dfa:	ec 0c 00 0c 	add	r12,r6,r12
80005dfe:	f0 1f 00 09 	mcall	80005e20 <vTaskPlaceOnEventList+0x54>
80005e02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e06:	00 00       	add	r0,r0
80005e08:	00 00       	add	r0,r0
80005e0a:	0c 50       	eor	r0,r6
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	50 12       	stdsp	sp[0x4],r2
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	50 46       	stdsp	sp[0x10],r6
80005e14:	00 00       	add	r0,r0
80005e16:	0c a4       	st.w	r6++,r4
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	4f f6       	lddpc	r6,80006014 <xTaskGenericCreate+0x168>
80005e1c:	00 00       	add	r0,r0
80005e1e:	0c 7c       	tst	r12,r6
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	5c a8       	swap.h	r8

80005e24 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005e24:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e28:	49 67       	lddpc	r7,80005e80 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e2a:	49 74       	lddpc	r4,80005e84 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005e2c:	49 73       	lddpc	r3,80005e88 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e2e:	49 85       	lddpc	r5,80005e8c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e30:	6e 08       	ld.w	r8,r7[0x0]
80005e32:	58 08       	cp.w	r8,0
80005e34:	c1 e0       	breq	80005e70 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005e36:	f0 1f 00 17 	mcall	80005e90 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e3a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005e3c:	f0 1f 00 16 	mcall	80005e94 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005e40:	58 06       	cp.w	r6,0
80005e42:	c1 70       	breq	80005e70 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005e44:	f0 1f 00 15 	mcall	80005e98 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005e48:	68 38       	ld.w	r8,r4[0xc]
80005e4a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005e4c:	ec cc ff fc 	sub	r12,r6,-4
80005e50:	f0 1f 00 13 	mcall	80005e9c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005e54:	66 08       	ld.w	r8,r3[0x0]
80005e56:	20 18       	sub	r8,1
80005e58:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005e5a:	6e 08       	ld.w	r8,r7[0x0]
80005e5c:	20 18       	sub	r8,1
80005e5e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005e60:	f0 1f 00 10 	mcall	80005ea0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005e64:	6c cc       	ld.w	r12,r6[0x30]
80005e66:	f0 1f 00 10 	mcall	80005ea4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005e6a:	0c 9c       	mov	r12,r6
80005e6c:	f0 1f 00 0e 	mcall	80005ea4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e70:	6a 08       	ld.w	r8,r5[0x0]
80005e72:	58 18       	cp.w	r8,1
80005e74:	e0 88 00 03 	brls	80005e7a <prvIdleTask+0x56>
			{
				taskYIELD();
80005e78:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005e7a:	f0 1f 00 0c 	mcall	80005ea8 <prvIdleTask+0x84>
		}
		#endif
	}
80005e7e:	cd 9b       	rjmp	80005e30 <prvIdleTask+0xc>
80005e80:	00 00       	add	r0,r0
80005e82:	0b 90       	ld.ub	r0,r5[0x1]
80005e84:	00 00       	add	r0,r0
80005e86:	0c 3c       	cp.w	r12,r6
80005e88:	00 00       	add	r0,r0
80005e8a:	0c 9c       	mov	r12,r6
80005e8c:	00 00       	add	r0,r0
80005e8e:	0b 9c       	ld.ub	r12,r5[0x1]
80005e90:	80 00       	ld.sh	r0,r0[0x0]
80005e92:	58 04       	cp.w	r4,0
80005e94:	80 00       	ld.sh	r0,r0[0x0]
80005e96:	5b c0       	cp.w	r0,-4
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	51 00       	stdsp	sp[0x40],r0
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	50 46       	stdsp	sp[0x10],r6
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	52 0c       	stdsp	sp[0x80],r12
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	53 44       	stdsp	sp[0xd0],r4
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	20 2c       	sub	r12,2

80005eac <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005eac:	d4 31       	pushm	r0-r7,lr
80005eae:	20 1d       	sub	sp,4
80005eb0:	fa c4 ff d8 	sub	r4,sp,-40
80005eb4:	50 0c       	stdsp	sp[0x0],r12
80005eb6:	16 91       	mov	r1,r11
80005eb8:	14 97       	mov	r7,r10
80005eba:	12 90       	mov	r0,r9
80005ebc:	10 93       	mov	r3,r8
80005ebe:	68 02       	ld.w	r2,r4[0x0]
80005ec0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005ec2:	34 8c       	mov	r12,72
80005ec4:	f0 1f 00 5c 	mcall	80006034 <xTaskGenericCreate+0x188>
80005ec8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005eca:	c0 31       	brne	80005ed0 <xTaskGenericCreate+0x24>
80005ecc:	3f fc       	mov	r12,-1
80005ece:	ca f8       	rjmp	8000602c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005ed0:	58 06       	cp.w	r6,0
80005ed2:	e0 81 00 af 	brne	80006030 <xTaskGenericCreate+0x184>
80005ed6:	0e 9c       	mov	r12,r7
80005ed8:	5c 7c       	castu.h	r12
80005eda:	a3 6c       	lsl	r12,0x2
80005edc:	f0 1f 00 56 	mcall	80006034 <xTaskGenericCreate+0x188>
80005ee0:	18 96       	mov	r6,r12
80005ee2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005ee4:	c0 61       	brne	80005ef0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005ee6:	0a 9c       	mov	r12,r5
80005ee8:	f0 1f 00 54 	mcall	80006038 <xTaskGenericCreate+0x18c>
80005eec:	3f fc       	mov	r12,-1
80005eee:	c9 f8       	rjmp	8000602c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005ef0:	5c 77       	castu.h	r7
80005ef2:	ee 0a 15 02 	lsl	r10,r7,0x2
80005ef6:	e0 6b 00 a5 	mov	r11,165
80005efa:	0c 9c       	mov	r12,r6
80005efc:	f0 1f 00 50 	mcall	8000603c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005f00:	ee c6 00 01 	sub	r6,r7,1
80005f04:	6a c8       	ld.w	r8,r5[0x30]
80005f06:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005f0a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005f0e:	31 0a       	mov	r10,16
80005f10:	02 9b       	mov	r11,r1
80005f12:	ea cc ff cc 	sub	r12,r5,-52
80005f16:	f0 1f 00 4b 	mcall	80006040 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005f1a:	30 08       	mov	r8,0
80005f1c:	eb 68 00 43 	st.b	r5[67],r8
80005f20:	58 73       	cp.w	r3,7
80005f22:	e6 07 17 80 	movls	r7,r3
80005f26:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005f2a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005f2c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005f30:	ea c4 ff fc 	sub	r4,r5,-4
80005f34:	08 9c       	mov	r12,r4
80005f36:	f0 1f 00 44 	mcall	80006044 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005f3a:	ea cc ff e8 	sub	r12,r5,-24
80005f3e:	f0 1f 00 42 	mcall	80006044 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005f42:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005f44:	ee 07 11 08 	rsub	r7,r7,8
80005f48:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005f4a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005f4c:	00 9a       	mov	r10,r0
80005f4e:	40 0b       	lddsp	r11,sp[0x0]
80005f50:	0c 9c       	mov	r12,r6
80005f52:	f0 1f 00 3e 	mcall	80006048 <xTaskGenericCreate+0x19c>
80005f56:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005f58:	58 02       	cp.w	r2,0
80005f5a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005f5e:	f0 1f 00 3c 	mcall	8000604c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005f62:	4b c8       	lddpc	r8,80006050 <xTaskGenericCreate+0x1a4>
80005f64:	70 09       	ld.w	r9,r8[0x0]
80005f66:	2f f9       	sub	r9,-1
80005f68:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005f6a:	4b b8       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
80005f6c:	70 08       	ld.w	r8,r8[0x0]
80005f6e:	58 08       	cp.w	r8,0
80005f70:	c2 61       	brne	80005fbc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005f72:	4b 98       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
80005f74:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005f76:	4b 78       	lddpc	r8,80006050 <xTaskGenericCreate+0x1a4>
80005f78:	70 08       	ld.w	r8,r8[0x0]
80005f7a:	58 18       	cp.w	r8,1
80005f7c:	c2 b1       	brne	80005fd2 <xTaskGenericCreate+0x126>
80005f7e:	4b 77       	lddpc	r7,80006058 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005f80:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005f84:	0e 9c       	mov	r12,r7
80005f86:	f0 1f 00 36 	mcall	8000605c <xTaskGenericCreate+0x1b0>
80005f8a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005f8c:	0c 37       	cp.w	r7,r6
80005f8e:	cf b1       	brne	80005f84 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005f90:	4b 47       	lddpc	r7,80006060 <xTaskGenericCreate+0x1b4>
80005f92:	0e 9c       	mov	r12,r7
80005f94:	f0 1f 00 32 	mcall	8000605c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005f98:	4b 36       	lddpc	r6,80006064 <xTaskGenericCreate+0x1b8>
80005f9a:	0c 9c       	mov	r12,r6
80005f9c:	f0 1f 00 30 	mcall	8000605c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005fa0:	4b 2c       	lddpc	r12,80006068 <xTaskGenericCreate+0x1bc>
80005fa2:	f0 1f 00 2f 	mcall	8000605c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005fa6:	4b 2c       	lddpc	r12,8000606c <xTaskGenericCreate+0x1c0>
80005fa8:	f0 1f 00 2d 	mcall	8000605c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005fac:	4b 1c       	lddpc	r12,80006070 <xTaskGenericCreate+0x1c4>
80005fae:	f0 1f 00 2c 	mcall	8000605c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005fb2:	4b 18       	lddpc	r8,80006074 <xTaskGenericCreate+0x1c8>
80005fb4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005fb6:	4b 18       	lddpc	r8,80006078 <xTaskGenericCreate+0x1cc>
80005fb8:	91 06       	st.w	r8[0x0],r6
80005fba:	c0 c8       	rjmp	80005fd2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005fbc:	4b 08       	lddpc	r8,8000607c <xTaskGenericCreate+0x1d0>
80005fbe:	70 08       	ld.w	r8,r8[0x0]
80005fc0:	58 08       	cp.w	r8,0
80005fc2:	c0 81       	brne	80005fd2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005fc4:	4a 48       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
80005fc6:	70 08       	ld.w	r8,r8[0x0]
80005fc8:	70 b8       	ld.w	r8,r8[0x2c]
80005fca:	10 33       	cp.w	r3,r8
80005fcc:	c0 33       	brcs	80005fd2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005fce:	4a 28       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
80005fd0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005fd2:	6a b8       	ld.w	r8,r5[0x2c]
80005fd4:	4a b9       	lddpc	r9,80006080 <xTaskGenericCreate+0x1d4>
80005fd6:	72 09       	ld.w	r9,r9[0x0]
80005fd8:	12 38       	cp.w	r8,r9
80005fda:	e0 88 00 04 	brls	80005fe2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005fde:	4a 99       	lddpc	r9,80006080 <xTaskGenericCreate+0x1d4>
80005fe0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005fe2:	4a 98       	lddpc	r8,80006084 <xTaskGenericCreate+0x1d8>
80005fe4:	70 09       	ld.w	r9,r8[0x0]
80005fe6:	2f f9       	sub	r9,-1
80005fe8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005fea:	6a b8       	ld.w	r8,r5[0x2c]
80005fec:	4a 79       	lddpc	r9,80006088 <xTaskGenericCreate+0x1dc>
80005fee:	72 09       	ld.w	r9,r9[0x0]
80005ff0:	12 38       	cp.w	r8,r9
80005ff2:	e0 88 00 04 	brls	80005ffa <xTaskGenericCreate+0x14e>
80005ff6:	4a 59       	lddpc	r9,80006088 <xTaskGenericCreate+0x1dc>
80005ff8:	93 08       	st.w	r9[0x0],r8
80005ffa:	6a bc       	ld.w	r12,r5[0x2c]
80005ffc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006000:	08 9b       	mov	r11,r4
80006002:	49 68       	lddpc	r8,80006058 <xTaskGenericCreate+0x1ac>
80006004:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006008:	f0 1f 00 21 	mcall	8000608c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000600c:	f0 1f 00 21 	mcall	80006090 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006010:	49 b8       	lddpc	r8,8000607c <xTaskGenericCreate+0x1d0>
80006012:	70 08       	ld.w	r8,r8[0x0]
80006014:	58 08       	cp.w	r8,0
80006016:	c0 a0       	breq	8000602a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006018:	48 f8       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
8000601a:	70 08       	ld.w	r8,r8[0x0]
8000601c:	70 b8       	ld.w	r8,r8[0x2c]
8000601e:	10 33       	cp.w	r3,r8
80006020:	e0 88 00 05 	brls	8000602a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006024:	d7 33       	scall
80006026:	30 1c       	mov	r12,1
80006028:	c0 28       	rjmp	8000602c <xTaskGenericCreate+0x180>
8000602a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000602c:	2f fd       	sub	sp,-4
8000602e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006030:	99 c6       	st.w	r12[0x30],r6
80006032:	c5 fb       	rjmp	80005ef0 <xTaskGenericCreate+0x44>
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	53 6c       	stdsp	sp[0xd8],r12
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	53 44       	stdsp	sp[0xd0],r4
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	6a da       	ld.w	r10,r5[0x34]
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	6e 04       	ld.w	r4,r7[0x0]
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	4f f0       	lddpc	r0,80006240 <PrintDec+0xaa>
80006048:	80 00       	ld.sh	r0,r0[0x0]
8000604a:	50 6c       	stdsp	sp[0x18],r12
8000604c:	80 00       	ld.sh	r0,r0[0x0]
8000604e:	51 00       	stdsp	sp[0x40],r0
80006050:	00 00       	add	r0,r0
80006052:	0c 9c       	mov	r12,r6
80006054:	00 00       	add	r0,r0
80006056:	0c 50       	eor	r0,r6
80006058:	00 00       	add	r0,r0
8000605a:	0b 9c       	ld.ub	r12,r5[0x1]
8000605c:	80 00       	ld.sh	r0,r0[0x0]
8000605e:	4f dc       	lddpc	r12,80006250 <PrintDec+0xba>
80006060:	00 00       	add	r0,r0
80006062:	0c 68       	and	r8,r6
80006064:	00 00       	add	r0,r0
80006066:	0c 84       	andn	r4,r6
80006068:	00 00       	add	r0,r0
8000606a:	0c 54       	eor	r4,r6
8000606c:	00 00       	add	r0,r0
8000606e:	0c 3c       	cp.w	r12,r6
80006070:	00 00       	add	r0,r0
80006072:	0c a4       	st.w	r6++,r4
80006074:	00 00       	add	r0,r0
80006076:	0b 88       	ld.ub	r8,r5[0x0]
80006078:	00 00       	add	r0,r0
8000607a:	0b 98       	ld.ub	r8,r5[0x1]
8000607c:	00 00       	add	r0,r0
8000607e:	0b 8c       	ld.ub	r12,r5[0x0]
80006080:	00 00       	add	r0,r0
80006082:	0b 84       	ld.ub	r4,r5[0x0]
80006084:	00 00       	add	r0,r0
80006086:	0c 98       	mov	r8,r6
80006088:	00 00       	add	r0,r0
8000608a:	0c b8       	st.h	r6++,r8
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	4f f6       	lddpc	r6,80006288 <log+0x18>
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	52 0c       	stdsp	sp[0x80],r12

80006094 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006094:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006096:	30 09       	mov	r9,0
80006098:	1a d9       	st.w	--sp,r9
8000609a:	1a d9       	st.w	--sp,r9
8000609c:	1a d9       	st.w	--sp,r9
8000609e:	12 98       	mov	r8,r9
800060a0:	e0 6a 01 00 	mov	r10,256
800060a4:	48 9b       	lddpc	r11,800060c8 <vTaskStartScheduler+0x34>
800060a6:	48 ac       	lddpc	r12,800060cc <vTaskStartScheduler+0x38>
800060a8:	f0 1f 00 0a 	mcall	800060d0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800060ac:	2f dd       	sub	sp,-12
800060ae:	58 1c       	cp.w	r12,1
800060b0:	c0 a1       	brne	800060c4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800060b2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800060b4:	30 19       	mov	r9,1
800060b6:	48 88       	lddpc	r8,800060d4 <vTaskStartScheduler+0x40>
800060b8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800060ba:	30 09       	mov	r9,0
800060bc:	48 78       	lddpc	r8,800060d8 <vTaskStartScheduler+0x44>
800060be:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800060c0:	f0 1f 00 07 	mcall	800060dc <vTaskStartScheduler+0x48>
800060c4:	d8 02       	popm	pc
800060c6:	00 00       	add	r0,r0
800060c8:	80 00       	ld.sh	r0,r0[0x0]
800060ca:	ce 2c       	rcall	8000628e <log+0x1e>
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	5e 24       	reths	r4
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	5e ac       	retle	r12
800060d4:	00 00       	add	r0,r0
800060d6:	0b 8c       	ld.ub	r12,r5[0x0]
800060d8:	00 00       	add	r0,r0
800060da:	0c 7c       	tst	r12,r6
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	51 10       	stdsp	sp[0x44],r0

800060e0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800060e0:	16 cc       	st.b	r11++,r12
	return str;
}
800060e2:	5e fb       	retal	r11

800060e4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800060e4:	eb cd 40 c0 	pushm	r6-r7,lr
800060e8:	20 3d       	sub	sp,12
800060ea:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800060ec:	30 06       	mov	r6,0
800060ee:	30 07       	mov	r7,0
800060f0:	fa e7 00 00 	st.d	sp[0],r6
800060f4:	30 0c       	mov	r12,0
800060f6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800060f8:	58 08       	cp.w	r8,0
800060fa:	c1 30       	breq	80006120 <PrintHex+0x3c>
800060fc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800060fe:	1a 9c       	mov	r12,sp
80006100:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006104:	58 9e       	cp.w	lr,9
80006106:	e0 8a 00 04 	brle	8000610e <PrintHex+0x2a>
8000610a:	2c 9e       	sub	lr,-55
8000610c:	c0 48       	rjmp	80006114 <PrintHex+0x30>
8000610e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006112:	2d 0e       	sub	lr,-48
80006114:	f8 09 0b 0e 	st.b	r12[r9],lr
80006118:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000611a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000611c:	cf 21       	brne	80006100 <PrintHex+0x1c>
8000611e:	c0 48       	rjmp	80006126 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006120:	33 08       	mov	r8,48
80006122:	ba 88       	st.b	sp[0x0],r8
80006124:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006126:	f6 09 01 08 	sub	r8,r11,r9
8000612a:	58 08       	cp.w	r8,0
8000612c:	e0 8a 00 13 	brle	80006152 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006130:	12 1b       	sub	r11,r9
80006132:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006136:	18 9e       	mov	lr,r12
80006138:	58 0c       	cp.w	r12,0
8000613a:	e0 8a 00 0c 	brle	80006152 <PrintHex+0x6e>
8000613e:	1a 9b       	mov	r11,sp
80006140:	12 0b       	add	r11,r9
80006142:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006144:	33 07       	mov	r7,48
80006146:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006148:	2f f8       	sub	r8,-1
8000614a:	1c 38       	cp.w	r8,lr
8000614c:	cf d5       	brlt	80006146 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000614e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006152:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006156:	f0 cb ff ff 	sub	r11,r8,-1
8000615a:	58 0b       	cp.w	r11,0
8000615c:	e0 8a 00 19 	brle	8000618e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006160:	fa cb ff f4 	sub	r11,sp,-12
80006164:	f6 09 00 09 	add	r9,r11,r9
80006168:	37 8b       	mov	r11,120
8000616a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000616e:	fa c9 ff f4 	sub	r9,sp,-12
80006172:	10 09       	add	r9,r8
80006174:	33 0b       	mov	r11,48
80006176:	f3 6b ff f4 	st.b	r9[-12],r11
8000617a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000617e:	fa ce 00 01 	sub	lr,sp,1
80006182:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006184:	11 8b       	ld.ub	r11,r8[0x0]
80006186:	12 cb       	st.b	r9++,r11
80006188:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000618a:	1c 38       	cp.w	r8,lr
8000618c:	cf c1       	brne	80006184 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000618e:	14 9c       	mov	r12,r10
80006190:	2f dd       	sub	sp,-12
80006192:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006196 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006196:	d4 21       	pushm	r4-r7,lr
80006198:	20 3d       	sub	sp,12
8000619a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
8000619c:	30 06       	mov	r6,0
8000619e:	30 07       	mov	r7,0
800061a0:	fa e7 00 00 	st.d	sp[0],r6
800061a4:	30 0c       	mov	r12,0
800061a6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800061a8:	58 08       	cp.w	r8,0
800061aa:	c0 35       	brlt	800061b0 <PrintDec+0x1a>
800061ac:	14 97       	mov	r7,r10
800061ae:	c0 58       	rjmp	800061b8 <PrintDec+0x22>
	{
		*p++ = '-';
800061b0:	14 97       	mov	r7,r10
800061b2:	32 d9       	mov	r9,45
800061b4:	0e c9       	st.b	r7++,r9
		i = -i;
800061b6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800061b8:	58 08       	cp.w	r8,0
800061ba:	c0 51       	brne	800061c4 <PrintDec+0x2e>
800061bc:	33 08       	mov	r8,48
800061be:	ba 88       	st.b	sp[0x0],r8
800061c0:	30 1e       	mov	lr,1
800061c2:	c2 f8       	rjmp	80006220 <PrintDec+0x8a>
	
	int ten = i%10;
800061c4:	e0 65 66 67 	mov	r5,26215
800061c8:	ea 15 66 66 	orh	r5,0x6666
800061cc:	f0 05 04 44 	muls.d	r4,r8,r5
800061d0:	ea 0c 14 02 	asr	r12,r5,0x2
800061d4:	f0 09 14 1f 	asr	r9,r8,0x1f
800061d8:	f8 09 01 09 	sub	r9,r12,r9
800061dc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800061e0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800061e4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800061e6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800061e8:	e0 66 66 67 	mov	r6,26215
800061ec:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800061f0:	2d 09       	sub	r9,-48
800061f2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800061f6:	2f fe       	sub	lr,-1
		i /= 10;
800061f8:	f0 06 04 44 	muls.d	r4,r8,r6
800061fc:	ea 09 14 02 	asr	r9,r5,0x2
80006200:	bf 58       	asr	r8,0x1f
80006202:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006206:	f0 06 04 44 	muls.d	r4,r8,r6
8000620a:	ea 09 14 02 	asr	r9,r5,0x2
8000620e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006212:	0a 19       	sub	r9,r5
80006214:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006218:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000621c:	58 08       	cp.w	r8,0
8000621e:	ce 91       	brne	800061f0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006220:	f6 0e 01 08 	sub	r8,r11,lr
80006224:	58 08       	cp.w	r8,0
80006226:	e0 89 00 06 	brgt	80006232 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000622a:	58 0e       	cp.w	lr,0
8000622c:	e0 89 00 14 	brgt	80006254 <PrintDec+0xbe>
80006230:	c1 d8       	rjmp	8000626a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006232:	1c 1b       	sub	r11,lr
80006234:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006236:	16 9c       	mov	r12,r11
80006238:	58 0b       	cp.w	r11,0
8000623a:	fe 9a ff f8 	brle	8000622a <PrintDec+0x94>
8000623e:	1a 99       	mov	r9,sp
80006240:	1c 09       	add	r9,lr
80006242:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006244:	33 06       	mov	r6,48
80006246:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006248:	2f f8       	sub	r8,-1
8000624a:	18 38       	cp.w	r8,r12
8000624c:	cf d5       	brlt	80006246 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000624e:	f6 0e 00 0e 	add	lr,r11,lr
80006252:	ce cb       	rjmp	8000622a <PrintDec+0x94>
80006254:	fa c8 ff f4 	sub	r8,sp,-12
80006258:	1c 08       	add	r8,lr
8000625a:	20 d8       	sub	r8,13
8000625c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006260:	11 89       	ld.ub	r9,r8[0x0]
80006262:	0e c9       	st.b	r7++,r9
80006264:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006266:	16 38       	cp.w	r8,r11
80006268:	cf c1       	brne	80006260 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000626a:	14 9c       	mov	r12,r10
8000626c:	2f dd       	sub	sp,-12
8000626e:	d8 22       	popm	r4-r7,pc

80006270 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006270:	d4 31       	pushm	r0-r7,lr
80006272:	fa cd 02 08 	sub	sp,sp,520
80006276:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006278:	e0 6a 01 00 	mov	r10,256
8000627c:	30 0b       	mov	r11,0
8000627e:	fa cc fe f8 	sub	r12,sp,-264
80006282:	f0 1f 00 4e 	mcall	800063b8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006286:	fa c4 fd d4 	sub	r4,sp,-556
8000628a:	30 0a       	mov	r10,0
8000628c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000628e:	fa c3 ff fc 	sub	r3,sp,-4
80006292:	e0 61 01 00 	mov	r1,256
80006296:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006298:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000629a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000629e:	02 9a       	mov	r10,r1
800062a0:	00 9b       	mov	r11,r0
800062a2:	06 9c       	mov	r12,r3
800062a4:	f0 1f 00 45 	mcall	800063b8 <log+0x148>
			
					if(*str == '%')
800062a8:	0f 88       	ld.ub	r8,r7[0x0]
800062aa:	e4 08 18 00 	cp.b	r8,r2
800062ae:	c5 71       	brne	8000635c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800062b0:	ee c8 ff ff 	sub	r8,r7,-1
800062b4:	11 89       	ld.ub	r9,r8[0x0]
800062b6:	4c 2a       	lddpc	r10,800063bc <log+0x14c>
800062b8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800062ba:	23 09       	sub	r9,48
800062bc:	30 9a       	mov	r10,9
800062be:	f4 09 18 00 	cp.b	r9,r10
800062c2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800062c6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800062ca:	f7 b9 08 30 	subls	r9,48
800062ce:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800062d2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800062d6:	0f 88       	ld.ub	r8,r7[0x0]
800062d8:	22 58       	sub	r8,37
800062da:	e0 48 00 53 	cp.w	r8,83
800062de:	e0 8b 00 31 	brhi	80006340 <log+0xd0>
800062e2:	4b 89       	lddpc	r9,800063c0 <log+0x150>
800062e4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800062e8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800062ec:	06 9a       	mov	r10,r3
800062ee:	40 0b       	lddsp	r11,sp[0x0]
800062f0:	5c 5b       	castu.b	r11
800062f2:	68 0c       	ld.w	r12,r4[0x0]
800062f4:	f0 1f 00 34 	mcall	800063c4 <log+0x154>
							break;
800062f8:	c2 98       	rjmp	8000634a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800062fa:	4b 4c       	lddpc	r12,800063c8 <log+0x158>
800062fc:	f0 1f 00 34 	mcall	800063cc <log+0x15c>
80006300:	08 95       	mov	r5,r4
80006302:	06 9c       	mov	r12,r3
							break;
80006304:	c2 38       	rjmp	8000634a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006306:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000630a:	06 9a       	mov	r10,r3
8000630c:	40 0b       	lddsp	r11,sp[0x0]
8000630e:	5c 5b       	castu.b	r11
80006310:	68 0c       	ld.w	r12,r4[0x0]
80006312:	f0 1f 00 30 	mcall	800063d0 <log+0x160>
80006316:	06 9c       	mov	r12,r3
							break;
80006318:	c1 98       	rjmp	8000634a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000631a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000631e:	06 9b       	mov	r11,r3
80006320:	09 bc       	ld.ub	r12,r4[0x3]
80006322:	f0 1f 00 2d 	mcall	800063d4 <log+0x164>
80006326:	06 9c       	mov	r12,r3
							break;
80006328:	c1 18       	rjmp	8000634a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000632a:	e8 c5 ff fc 	sub	r5,r4,-4
8000632e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006330:	c0 d8       	rjmp	8000634a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006332:	06 9b       	mov	r11,r3
80006334:	32 5c       	mov	r12,37
80006336:	f0 1f 00 28 	mcall	800063d4 <log+0x164>
8000633a:	08 95       	mov	r5,r4
8000633c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000633e:	c0 68       	rjmp	8000634a <log+0xda>
							
							default:
							log("I need relax.");
80006340:	4a 6c       	lddpc	r12,800063d8 <log+0x168>
80006342:	f0 1f 00 23 	mcall	800063cc <log+0x15c>
80006346:	08 95       	mov	r5,r4
80006348:	06 9c       	mov	r12,r3
						}
						str++;
8000634a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000634c:	1a dc       	st.w	--sp,r12
8000634e:	1a d6       	st.w	--sp,r6
80006350:	4a 3b       	lddpc	r11,800063dc <log+0x16c>
80006352:	0c 9c       	mov	r12,r6
80006354:	f0 1f 00 23 	mcall	800063e0 <log+0x170>
80006358:	2f ed       	sub	sp,-8
8000635a:	c0 a8       	rjmp	8000636e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000635c:	2f f7       	sub	r7,-1
8000635e:	1a d8       	st.w	--sp,r8
80006360:	1a d6       	st.w	--sp,r6
80006362:	4a 1b       	lddpc	r11,800063e4 <log+0x174>
80006364:	0c 9c       	mov	r12,r6
80006366:	f0 1f 00 1f 	mcall	800063e0 <log+0x170>
8000636a:	08 95       	mov	r5,r4
8000636c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000636e:	0f 89       	ld.ub	r9,r7[0x0]
80006370:	30 08       	mov	r8,0
80006372:	f0 09 18 00 	cp.b	r9,r8
80006376:	c0 30       	breq	8000637c <log+0x10c>
80006378:	0a 94       	mov	r4,r5
8000637a:	c9 2b       	rjmp	8000629e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000637c:	fa c7 fe f8 	sub	r7,sp,-264
80006380:	1a d7       	st.w	--sp,r7
80006382:	49 ab       	lddpc	r11,800063e8 <log+0x178>
80006384:	0e 9c       	mov	r12,r7
80006386:	f0 1f 00 17 	mcall	800063e0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000638a:	5c 5c       	castu.b	r12
8000638c:	f8 c6 ff ff 	sub	r6,r12,-1
80006390:	0c 9c       	mov	r12,r6
80006392:	f0 1f 00 17 	mcall	800063ec <log+0x17c>
80006396:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006398:	0c 9a       	mov	r10,r6
8000639a:	0e 9b       	mov	r11,r7
8000639c:	f0 1f 00 15 	mcall	800063f0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800063a0:	30 09       	mov	r9,0
800063a2:	30 5a       	mov	r10,5
800063a4:	fa cb fe f8 	sub	r11,sp,-264
800063a8:	49 38       	lddpc	r8,800063f4 <log+0x184>
800063aa:	70 0c       	ld.w	r12,r8[0x0]
800063ac:	f0 1f 00 13 	mcall	800063f8 <log+0x188>
800063b0:	2f fd       	sub	sp,-4
	
	
}
800063b2:	fe 3d fd f8 	sub	sp,-520
800063b6:	d8 32       	popm	r0-r7,pc
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	6a da       	ld.w	r10,r5[0x34]
800063bc:	00 00       	add	r0,r0
800063be:	0c bc       	st.h	r6++,r12
800063c0:	80 00       	ld.sh	r0,r0[0x0]
800063c2:	ce 34       	brge	80006388 <log+0x118>
800063c4:	80 00       	ld.sh	r0,r0[0x0]
800063c6:	61 96       	ld.w	r6,r0[0x64]
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	cf 90       	breq	800063bc <log+0x14c>
800063cc:	80 00       	ld.sh	r0,r0[0x0]
800063ce:	62 70       	ld.w	r0,r1[0x1c]
800063d0:	80 00       	ld.sh	r0,r0[0x0]
800063d2:	60 e4       	ld.w	r4,r0[0x38]
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	60 e0       	ld.w	r0,r0[0x38]
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	cf a0       	breq	800063ce <log+0x15e>
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	cf b0       	breq	800063d4 <log+0x164>
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	6d c8       	ld.w	r8,r6[0x70]
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	cf b8       	rjmp	800065dc <_malloc_r+0xa8>
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	cf c0       	breq	800063e2 <log+0x172>
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	53 6c       	stdsp	sp[0xd8],r12
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	69 92       	ld.w	r2,r4[0x64]
800063f4:	00 00       	add	r0,r0
800063f6:	1f b0       	ld.ub	r0,pc[0x3]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	56 20       	stdsp	sp[0x188],r0

800063fc <log_init>:
		
	return str;
}

void log_init(void)
{
800063fc:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800063fe:	30 2b       	mov	r11,2
80006400:	48 fc       	lddpc	r12,8000643c <log_init+0x40>
80006402:	f0 1f 00 10 	mcall	80006440 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006406:	e0 6a 36 00 	mov	r10,13824
8000640a:	ea 1a 01 6e 	orh	r10,0x16e
8000640e:	48 eb       	lddpc	r11,80006444 <log_init+0x48>
80006410:	fe 7c 18 00 	mov	r12,-59392
80006414:	f0 1f 00 0d 	mcall	80006448 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006418:	30 4b       	mov	r11,4
8000641a:	33 2c       	mov	r12,50
8000641c:	f0 1f 00 0c 	mcall	8000644c <log_init+0x50>
80006420:	48 c8       	lddpc	r8,80006450 <log_init+0x54>
80006422:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006424:	30 09       	mov	r9,0
80006426:	1a d9       	st.w	--sp,r9
80006428:	1a d9       	st.w	--sp,r9
8000642a:	1a d9       	st.w	--sp,r9
8000642c:	30 28       	mov	r8,2
8000642e:	36 4a       	mov	r10,100
80006430:	48 9b       	lddpc	r11,80006454 <log_init+0x58>
80006432:	48 ac       	lddpc	r12,80006458 <log_init+0x5c>
80006434:	f0 1f 00 0a 	mcall	8000645c <log_init+0x60>
80006438:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000643a:	d8 02       	popm	pc
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	cf cc       	rcall	80006636 <_malloc_r+0x102>
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	46 dc       	lddsp	r12,sp[0x1b4]
80006444:	80 00       	ld.sh	r0,r0[0x0]
80006446:	cf 84       	brge	80006436 <log_init+0x3a>
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	4e d0       	lddpc	r0,800065fc <_malloc_r+0xc8>
8000644c:	80 00       	ld.sh	r0,r0[0x0]
8000644e:	57 78       	stdsp	sp[0x1dc],r8
80006450:	00 00       	add	r0,r0
80006452:	1f b0       	ld.ub	r0,pc[0x3]
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	cf c8       	rjmp	8000664e <_malloc_r+0x11a>
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	64 60       	ld.w	r0,r2[0x18]
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	5e ac       	retle	r12

80006460 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80006460:	eb cd 40 f8 	pushm	r3-r7,lr
80006464:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006466:	48 c7       	lddpc	r7,80006494 <task_log+0x34>
80006468:	30 05       	mov	r5,0
8000646a:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000646c:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006470:	0a 99       	mov	r9,r5
80006472:	08 9a       	mov	r10,r4
80006474:	1a 9b       	mov	r11,sp
80006476:	6e 0c       	ld.w	r12,r7[0x0]
80006478:	f0 1f 00 08 	mcall	80006498 <task_log+0x38>
8000647c:	58 1c       	cp.w	r12,1
8000647e:	cf 91       	brne	80006470 <task_log+0x10>
		{
			if( NULL != str)
80006480:	40 0b       	lddsp	r11,sp[0x0]
80006482:	58 0b       	cp.w	r11,0
80006484:	cf 60       	breq	80006470 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006486:	06 9c       	mov	r12,r3
80006488:	f0 1f 00 05 	mcall	8000649c <task_log+0x3c>
				vPortFree(str);
8000648c:	40 0c       	lddsp	r12,sp[0x0]
8000648e:	f0 1f 00 05 	mcall	800064a0 <task_log+0x40>
80006492:	ce fb       	rjmp	80006470 <task_log+0x10>
80006494:	00 00       	add	r0,r0
80006496:	1f b0       	ld.ub	r0,pc[0x3]
80006498:	80 00       	ld.sh	r0,r0[0x0]
8000649a:	54 64       	stdsp	sp[0x118],r4
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	4e 80       	lddpc	r0,8000663c <_malloc_r+0x108>
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	53 44       	stdsp	sp[0xd0],r4

800064a4 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800064a4:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800064a6:	fe 78 10 00 	mov	r8,-61440
800064aa:	30 19       	mov	r9,1
800064ac:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800064b0:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800064b4:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800064b8:	d3 03       	ssrf	0x10
	local_start_pll0();
800064ba:	f0 1f 00 0c 	mcall	800064e8 <main+0x44>
		
	INTC_init_interrupts();
800064be:	f0 1f 00 0c 	mcall	800064ec <main+0x48>
		
	log_init();
800064c2:	f0 1f 00 0c 	mcall	800064f0 <main+0x4c>
	log("----start debug----");
800064c6:	48 cc       	lddpc	r12,800064f4 <main+0x50>
800064c8:	f0 1f 00 0c 	mcall	800064f8 <main+0x54>
	
	xg_flashc_init();
800064cc:	f0 1f 00 0c 	mcall	800064fc <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800064d0:	f0 1f 00 0c 	mcall	80006500 <main+0x5c>
		
	app_init();
800064d4:	f0 1f 00 0c 	mcall	80006504 <main+0x60>
	
	xg_rtc_init();
800064d8:	f0 1f 00 0c 	mcall	80006508 <main+0x64>
		
	//xcmp_init();

	local_start_timer();
800064dc:	f0 1f 00 0c 	mcall	8000650c <main+0x68>
		
	vTaskStartScheduler();
800064e0:	f0 1f 00 0c 	mcall	80006510 <main+0x6c>
	return 0;
	
}
800064e4:	d8 0a       	popm	pc,r12=0
800064e6:	00 00       	add	r0,r0
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	40 5c       	lddsp	r12,sp[0x14]
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	47 e0       	lddsp	r0,sp[0x1f8]
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	63 fc       	ld.w	r12,r1[0x7c]
800064f4:	80 00       	ld.sh	r0,r0[0x0]
800064f6:	cf dc       	rcall	800066f0 <_malloc_r+0x1bc>
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	62 70       	ld.w	r0,r1[0x1c]
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	40 f0       	lddsp	r0,sp[0x3c]
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	3f bc       	mov	r12,-5
80006504:	80 00       	ld.sh	r0,r0[0x0]
80006506:	20 3c       	sub	r12,3
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	31 8c       	mov	r12,24
8000650c:	80 00       	ld.sh	r0,r0[0x0]
8000650e:	40 30       	lddsp	r0,sp[0xc]
80006510:	80 00       	ld.sh	r0,r0[0x0]
80006512:	60 94       	ld.w	r4,r0[0x24]

80006514 <free>:
80006514:	d4 01       	pushm	lr
80006516:	e0 68 0a 1c 	mov	r8,2588
8000651a:	18 9b       	mov	r11,r12
8000651c:	70 0c       	ld.w	r12,r8[0x0]
8000651e:	e0 a0 1e 73 	rcall	8000a204 <_free_r>
80006522:	d8 02       	popm	pc

80006524 <malloc>:
80006524:	d4 01       	pushm	lr
80006526:	e0 68 0a 1c 	mov	r8,2588
8000652a:	18 9b       	mov	r11,r12
8000652c:	70 0c       	ld.w	r12,r8[0x0]
8000652e:	c0 3c       	rcall	80006534 <_malloc_r>
80006530:	d8 02       	popm	pc
80006532:	d7 03       	nop

80006534 <_malloc_r>:
80006534:	d4 31       	pushm	r0-r7,lr
80006536:	f6 c8 ff f5 	sub	r8,r11,-11
8000653a:	18 95       	mov	r5,r12
8000653c:	10 97       	mov	r7,r8
8000653e:	e0 17 ff f8 	andl	r7,0xfff8
80006542:	59 68       	cp.w	r8,22
80006544:	f9 b7 08 10 	movls	r7,16
80006548:	16 37       	cp.w	r7,r11
8000654a:	5f 38       	srlo	r8
8000654c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006550:	c0 50       	breq	8000655a <_malloc_r+0x26>
80006552:	30 c8       	mov	r8,12
80006554:	99 38       	st.w	r12[0xc],r8
80006556:	e0 8f 01 fa 	bral	8000694a <_malloc_r+0x416>
8000655a:	fe b0 f6 ab 	rcall	800052b0 <__malloc_lock>
8000655e:	e0 47 01 f7 	cp.w	r7,503
80006562:	e0 8b 00 1d 	brhi	8000659c <_malloc_r+0x68>
80006566:	ee 03 16 03 	lsr	r3,r7,0x3
8000656a:	e0 68 05 1c 	mov	r8,1308
8000656e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006572:	70 36       	ld.w	r6,r8[0xc]
80006574:	10 36       	cp.w	r6,r8
80006576:	c0 61       	brne	80006582 <_malloc_r+0x4e>
80006578:	ec c8 ff f8 	sub	r8,r6,-8
8000657c:	70 36       	ld.w	r6,r8[0xc]
8000657e:	10 36       	cp.w	r6,r8
80006580:	c0 c0       	breq	80006598 <_malloc_r+0x64>
80006582:	6c 18       	ld.w	r8,r6[0x4]
80006584:	e0 18 ff fc 	andl	r8,0xfffc
80006588:	6c 3a       	ld.w	r10,r6[0xc]
8000658a:	ec 08 00 09 	add	r9,r6,r8
8000658e:	0a 9c       	mov	r12,r5
80006590:	6c 28       	ld.w	r8,r6[0x8]
80006592:	95 28       	st.w	r10[0x8],r8
80006594:	91 3a       	st.w	r8[0xc],r10
80006596:	c4 78       	rjmp	80006624 <_malloc_r+0xf0>
80006598:	2f e3       	sub	r3,-2
8000659a:	c4 d8       	rjmp	80006634 <_malloc_r+0x100>
8000659c:	ee 03 16 09 	lsr	r3,r7,0x9
800065a0:	c0 41       	brne	800065a8 <_malloc_r+0x74>
800065a2:	ee 03 16 03 	lsr	r3,r7,0x3
800065a6:	c2 68       	rjmp	800065f2 <_malloc_r+0xbe>
800065a8:	58 43       	cp.w	r3,4
800065aa:	e0 8b 00 06 	brhi	800065b6 <_malloc_r+0x82>
800065ae:	ee 03 16 06 	lsr	r3,r7,0x6
800065b2:	2c 83       	sub	r3,-56
800065b4:	c1 f8       	rjmp	800065f2 <_malloc_r+0xbe>
800065b6:	59 43       	cp.w	r3,20
800065b8:	e0 8b 00 04 	brhi	800065c0 <_malloc_r+0x8c>
800065bc:	2a 53       	sub	r3,-91
800065be:	c1 a8       	rjmp	800065f2 <_malloc_r+0xbe>
800065c0:	e0 43 00 54 	cp.w	r3,84
800065c4:	e0 8b 00 06 	brhi	800065d0 <_malloc_r+0x9c>
800065c8:	ee 03 16 0c 	lsr	r3,r7,0xc
800065cc:	29 23       	sub	r3,-110
800065ce:	c1 28       	rjmp	800065f2 <_malloc_r+0xbe>
800065d0:	e0 43 01 54 	cp.w	r3,340
800065d4:	e0 8b 00 06 	brhi	800065e0 <_malloc_r+0xac>
800065d8:	ee 03 16 0f 	lsr	r3,r7,0xf
800065dc:	28 93       	sub	r3,-119
800065de:	c0 a8       	rjmp	800065f2 <_malloc_r+0xbe>
800065e0:	e0 43 05 54 	cp.w	r3,1364
800065e4:	e0 88 00 04 	brls	800065ec <_malloc_r+0xb8>
800065e8:	37 e3       	mov	r3,126
800065ea:	c0 48       	rjmp	800065f2 <_malloc_r+0xbe>
800065ec:	ee 03 16 12 	lsr	r3,r7,0x12
800065f0:	28 43       	sub	r3,-124
800065f2:	e0 6a 05 1c 	mov	r10,1308
800065f6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800065fa:	74 36       	ld.w	r6,r10[0xc]
800065fc:	c1 98       	rjmp	8000662e <_malloc_r+0xfa>
800065fe:	6c 19       	ld.w	r9,r6[0x4]
80006600:	e0 19 ff fc 	andl	r9,0xfffc
80006604:	f2 07 01 0b 	sub	r11,r9,r7
80006608:	58 fb       	cp.w	r11,15
8000660a:	e0 8a 00 04 	brle	80006612 <_malloc_r+0xde>
8000660e:	20 13       	sub	r3,1
80006610:	c1 18       	rjmp	80006632 <_malloc_r+0xfe>
80006612:	6c 38       	ld.w	r8,r6[0xc]
80006614:	58 0b       	cp.w	r11,0
80006616:	c0 b5       	brlt	8000662c <_malloc_r+0xf8>
80006618:	6c 2a       	ld.w	r10,r6[0x8]
8000661a:	ec 09 00 09 	add	r9,r6,r9
8000661e:	0a 9c       	mov	r12,r5
80006620:	91 2a       	st.w	r8[0x8],r10
80006622:	95 38       	st.w	r10[0xc],r8
80006624:	72 18       	ld.w	r8,r9[0x4]
80006626:	a1 a8       	sbr	r8,0x0
80006628:	93 18       	st.w	r9[0x4],r8
8000662a:	cb c8       	rjmp	800067a2 <_malloc_r+0x26e>
8000662c:	10 96       	mov	r6,r8
8000662e:	14 36       	cp.w	r6,r10
80006630:	ce 71       	brne	800065fe <_malloc_r+0xca>
80006632:	2f f3       	sub	r3,-1
80006634:	e0 6a 05 1c 	mov	r10,1308
80006638:	f4 cc ff f8 	sub	r12,r10,-8
8000663c:	78 26       	ld.w	r6,r12[0x8]
8000663e:	18 36       	cp.w	r6,r12
80006640:	c6 c0       	breq	80006718 <_malloc_r+0x1e4>
80006642:	6c 19       	ld.w	r9,r6[0x4]
80006644:	e0 19 ff fc 	andl	r9,0xfffc
80006648:	f2 07 01 08 	sub	r8,r9,r7
8000664c:	58 f8       	cp.w	r8,15
8000664e:	e0 89 00 8f 	brgt	8000676c <_malloc_r+0x238>
80006652:	99 3c       	st.w	r12[0xc],r12
80006654:	99 2c       	st.w	r12[0x8],r12
80006656:	58 08       	cp.w	r8,0
80006658:	c0 55       	brlt	80006662 <_malloc_r+0x12e>
8000665a:	ec 09 00 09 	add	r9,r6,r9
8000665e:	0a 9c       	mov	r12,r5
80006660:	ce 2b       	rjmp	80006624 <_malloc_r+0xf0>
80006662:	e0 49 01 ff 	cp.w	r9,511
80006666:	e0 8b 00 13 	brhi	8000668c <_malloc_r+0x158>
8000666a:	a3 99       	lsr	r9,0x3
8000666c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006670:	70 2b       	ld.w	r11,r8[0x8]
80006672:	8d 38       	st.w	r6[0xc],r8
80006674:	8d 2b       	st.w	r6[0x8],r11
80006676:	97 36       	st.w	r11[0xc],r6
80006678:	91 26       	st.w	r8[0x8],r6
8000667a:	a3 49       	asr	r9,0x2
8000667c:	74 18       	ld.w	r8,r10[0x4]
8000667e:	30 1b       	mov	r11,1
80006680:	f6 09 09 49 	lsl	r9,r11,r9
80006684:	f1 e9 10 09 	or	r9,r8,r9
80006688:	95 19       	st.w	r10[0x4],r9
8000668a:	c4 78       	rjmp	80006718 <_malloc_r+0x1e4>
8000668c:	f2 0a 16 09 	lsr	r10,r9,0x9
80006690:	58 4a       	cp.w	r10,4
80006692:	e0 8b 00 07 	brhi	800066a0 <_malloc_r+0x16c>
80006696:	f2 0a 16 06 	lsr	r10,r9,0x6
8000669a:	2c 8a       	sub	r10,-56
8000669c:	c2 08       	rjmp	800066dc <_malloc_r+0x1a8>
8000669e:	d7 03       	nop
800066a0:	59 4a       	cp.w	r10,20
800066a2:	e0 8b 00 04 	brhi	800066aa <_malloc_r+0x176>
800066a6:	2a 5a       	sub	r10,-91
800066a8:	c1 a8       	rjmp	800066dc <_malloc_r+0x1a8>
800066aa:	e0 4a 00 54 	cp.w	r10,84
800066ae:	e0 8b 00 06 	brhi	800066ba <_malloc_r+0x186>
800066b2:	f2 0a 16 0c 	lsr	r10,r9,0xc
800066b6:	29 2a       	sub	r10,-110
800066b8:	c1 28       	rjmp	800066dc <_malloc_r+0x1a8>
800066ba:	e0 4a 01 54 	cp.w	r10,340
800066be:	e0 8b 00 06 	brhi	800066ca <_malloc_r+0x196>
800066c2:	f2 0a 16 0f 	lsr	r10,r9,0xf
800066c6:	28 9a       	sub	r10,-119
800066c8:	c0 a8       	rjmp	800066dc <_malloc_r+0x1a8>
800066ca:	e0 4a 05 54 	cp.w	r10,1364
800066ce:	e0 88 00 04 	brls	800066d6 <_malloc_r+0x1a2>
800066d2:	37 ea       	mov	r10,126
800066d4:	c0 48       	rjmp	800066dc <_malloc_r+0x1a8>
800066d6:	f2 0a 16 12 	lsr	r10,r9,0x12
800066da:	28 4a       	sub	r10,-124
800066dc:	e0 6b 05 1c 	mov	r11,1308
800066e0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800066e4:	68 28       	ld.w	r8,r4[0x8]
800066e6:	08 38       	cp.w	r8,r4
800066e8:	c0 e1       	brne	80006704 <_malloc_r+0x1d0>
800066ea:	76 19       	ld.w	r9,r11[0x4]
800066ec:	a3 4a       	asr	r10,0x2
800066ee:	30 1e       	mov	lr,1
800066f0:	fc 0a 09 4a 	lsl	r10,lr,r10
800066f4:	f3 ea 10 0a 	or	r10,r9,r10
800066f8:	10 99       	mov	r9,r8
800066fa:	97 1a       	st.w	r11[0x4],r10
800066fc:	c0 a8       	rjmp	80006710 <_malloc_r+0x1dc>
800066fe:	70 28       	ld.w	r8,r8[0x8]
80006700:	08 38       	cp.w	r8,r4
80006702:	c0 60       	breq	8000670e <_malloc_r+0x1da>
80006704:	70 1a       	ld.w	r10,r8[0x4]
80006706:	e0 1a ff fc 	andl	r10,0xfffc
8000670a:	14 39       	cp.w	r9,r10
8000670c:	cf 93       	brcs	800066fe <_malloc_r+0x1ca>
8000670e:	70 39       	ld.w	r9,r8[0xc]
80006710:	8d 39       	st.w	r6[0xc],r9
80006712:	8d 28       	st.w	r6[0x8],r8
80006714:	91 36       	st.w	r8[0xc],r6
80006716:	93 26       	st.w	r9[0x8],r6
80006718:	e6 08 14 02 	asr	r8,r3,0x2
8000671c:	30 1b       	mov	r11,1
8000671e:	e0 64 05 1c 	mov	r4,1308
80006722:	f6 08 09 4b 	lsl	r11,r11,r8
80006726:	68 18       	ld.w	r8,r4[0x4]
80006728:	10 3b       	cp.w	r11,r8
8000672a:	e0 8b 00 6b 	brhi	80006800 <_malloc_r+0x2cc>
8000672e:	f7 e8 00 09 	and	r9,r11,r8
80006732:	c0 b1       	brne	80006748 <_malloc_r+0x214>
80006734:	e0 13 ff fc 	andl	r3,0xfffc
80006738:	a1 7b       	lsl	r11,0x1
8000673a:	2f c3       	sub	r3,-4
8000673c:	c0 38       	rjmp	80006742 <_malloc_r+0x20e>
8000673e:	2f c3       	sub	r3,-4
80006740:	a1 7b       	lsl	r11,0x1
80006742:	f7 e8 00 09 	and	r9,r11,r8
80006746:	cf c0       	breq	8000673e <_malloc_r+0x20a>
80006748:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000674c:	06 92       	mov	r2,r3
8000674e:	1c 91       	mov	r1,lr
80006750:	62 36       	ld.w	r6,r1[0xc]
80006752:	c2 e8       	rjmp	800067ae <_malloc_r+0x27a>
80006754:	6c 1a       	ld.w	r10,r6[0x4]
80006756:	e0 1a ff fc 	andl	r10,0xfffc
8000675a:	f4 07 01 08 	sub	r8,r10,r7
8000675e:	58 f8       	cp.w	r8,15
80006760:	e0 8a 00 15 	brle	8000678a <_malloc_r+0x256>
80006764:	6c 3a       	ld.w	r10,r6[0xc]
80006766:	6c 29       	ld.w	r9,r6[0x8]
80006768:	95 29       	st.w	r10[0x8],r9
8000676a:	93 3a       	st.w	r9[0xc],r10
8000676c:	0e 99       	mov	r9,r7
8000676e:	ec 07 00 07 	add	r7,r6,r7
80006772:	a1 a9       	sbr	r9,0x0
80006774:	99 37       	st.w	r12[0xc],r7
80006776:	99 27       	st.w	r12[0x8],r7
80006778:	8d 19       	st.w	r6[0x4],r9
8000677a:	ee 08 09 08 	st.w	r7[r8],r8
8000677e:	8f 2c       	st.w	r7[0x8],r12
80006780:	8f 3c       	st.w	r7[0xc],r12
80006782:	a1 a8       	sbr	r8,0x0
80006784:	0a 9c       	mov	r12,r5
80006786:	8f 18       	st.w	r7[0x4],r8
80006788:	c0 d8       	rjmp	800067a2 <_malloc_r+0x26e>
8000678a:	6c 39       	ld.w	r9,r6[0xc]
8000678c:	58 08       	cp.w	r8,0
8000678e:	c0 f5       	brlt	800067ac <_malloc_r+0x278>
80006790:	ec 0a 00 0a 	add	r10,r6,r10
80006794:	74 18       	ld.w	r8,r10[0x4]
80006796:	a1 a8       	sbr	r8,0x0
80006798:	0a 9c       	mov	r12,r5
8000679a:	95 18       	st.w	r10[0x4],r8
8000679c:	6c 28       	ld.w	r8,r6[0x8]
8000679e:	93 28       	st.w	r9[0x8],r8
800067a0:	91 39       	st.w	r8[0xc],r9
800067a2:	fe b0 f5 8d 	rcall	800052bc <__malloc_unlock>
800067a6:	ec cc ff f8 	sub	r12,r6,-8
800067aa:	d8 32       	popm	r0-r7,pc
800067ac:	12 96       	mov	r6,r9
800067ae:	02 36       	cp.w	r6,r1
800067b0:	cd 21       	brne	80006754 <_malloc_r+0x220>
800067b2:	2f f2       	sub	r2,-1
800067b4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800067b8:	c0 30       	breq	800067be <_malloc_r+0x28a>
800067ba:	2f 81       	sub	r1,-8
800067bc:	cc ab       	rjmp	80006750 <_malloc_r+0x21c>
800067be:	1c 98       	mov	r8,lr
800067c0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800067c4:	c0 81       	brne	800067d4 <_malloc_r+0x2a0>
800067c6:	68 19       	ld.w	r9,r4[0x4]
800067c8:	f6 08 11 ff 	rsub	r8,r11,-1
800067cc:	f3 e8 00 08 	and	r8,r9,r8
800067d0:	89 18       	st.w	r4[0x4],r8
800067d2:	c0 78       	rjmp	800067e0 <_malloc_r+0x2ac>
800067d4:	f0 c9 00 08 	sub	r9,r8,8
800067d8:	20 13       	sub	r3,1
800067da:	70 08       	ld.w	r8,r8[0x0]
800067dc:	12 38       	cp.w	r8,r9
800067de:	cf 10       	breq	800067c0 <_malloc_r+0x28c>
800067e0:	a1 7b       	lsl	r11,0x1
800067e2:	68 18       	ld.w	r8,r4[0x4]
800067e4:	10 3b       	cp.w	r11,r8
800067e6:	e0 8b 00 0d 	brhi	80006800 <_malloc_r+0x2cc>
800067ea:	58 0b       	cp.w	r11,0
800067ec:	c0 a0       	breq	80006800 <_malloc_r+0x2cc>
800067ee:	04 93       	mov	r3,r2
800067f0:	c0 38       	rjmp	800067f6 <_malloc_r+0x2c2>
800067f2:	2f c3       	sub	r3,-4
800067f4:	a1 7b       	lsl	r11,0x1
800067f6:	f7 e8 00 09 	and	r9,r11,r8
800067fa:	ca 71       	brne	80006748 <_malloc_r+0x214>
800067fc:	cf bb       	rjmp	800067f2 <_malloc_r+0x2be>
800067fe:	d7 03       	nop
80006800:	68 23       	ld.w	r3,r4[0x8]
80006802:	66 12       	ld.w	r2,r3[0x4]
80006804:	e0 12 ff fc 	andl	r2,0xfffc
80006808:	0e 32       	cp.w	r2,r7
8000680a:	5f 39       	srlo	r9
8000680c:	e4 07 01 08 	sub	r8,r2,r7
80006810:	58 f8       	cp.w	r8,15
80006812:	5f aa       	srle	r10
80006814:	f5 e9 10 09 	or	r9,r10,r9
80006818:	e0 80 00 9a 	breq	8000694c <_malloc_r+0x418>
8000681c:	e0 68 0c c8 	mov	r8,3272
80006820:	70 01       	ld.w	r1,r8[0x0]
80006822:	e0 68 09 28 	mov	r8,2344
80006826:	2f 01       	sub	r1,-16
80006828:	70 08       	ld.w	r8,r8[0x0]
8000682a:	0e 01       	add	r1,r7
8000682c:	5b f8       	cp.w	r8,-1
8000682e:	c0 40       	breq	80006836 <_malloc_r+0x302>
80006830:	28 11       	sub	r1,-127
80006832:	e0 11 ff 80 	andl	r1,0xff80
80006836:	02 9b       	mov	r11,r1
80006838:	0a 9c       	mov	r12,r5
8000683a:	e0 a0 02 b7 	rcall	80006da8 <_sbrk_r>
8000683e:	18 96       	mov	r6,r12
80006840:	5b fc       	cp.w	r12,-1
80006842:	c7 50       	breq	8000692c <_malloc_r+0x3f8>
80006844:	e6 02 00 08 	add	r8,r3,r2
80006848:	10 3c       	cp.w	r12,r8
8000684a:	c0 32       	brcc	80006850 <_malloc_r+0x31c>
8000684c:	08 33       	cp.w	r3,r4
8000684e:	c6 f1       	brne	8000692c <_malloc_r+0x3f8>
80006850:	e0 6a 0c cc 	mov	r10,3276
80006854:	74 09       	ld.w	r9,r10[0x0]
80006856:	e2 09 00 09 	add	r9,r1,r9
8000685a:	95 09       	st.w	r10[0x0],r9
8000685c:	10 36       	cp.w	r6,r8
8000685e:	c0 a1       	brne	80006872 <_malloc_r+0x33e>
80006860:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006864:	c0 71       	brne	80006872 <_malloc_r+0x33e>
80006866:	e2 02 00 02 	add	r2,r1,r2
8000686a:	68 28       	ld.w	r8,r4[0x8]
8000686c:	a1 a2       	sbr	r2,0x0
8000686e:	91 12       	st.w	r8[0x4],r2
80006870:	c4 f8       	rjmp	8000690e <_malloc_r+0x3da>
80006872:	e0 6a 09 28 	mov	r10,2344
80006876:	74 0b       	ld.w	r11,r10[0x0]
80006878:	5b fb       	cp.w	r11,-1
8000687a:	c0 31       	brne	80006880 <_malloc_r+0x34c>
8000687c:	95 06       	st.w	r10[0x0],r6
8000687e:	c0 78       	rjmp	8000688c <_malloc_r+0x358>
80006880:	ec 09 00 09 	add	r9,r6,r9
80006884:	e0 6a 0c cc 	mov	r10,3276
80006888:	10 19       	sub	r9,r8
8000688a:	95 09       	st.w	r10[0x0],r9
8000688c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006890:	f0 09 11 08 	rsub	r9,r8,8
80006894:	58 08       	cp.w	r8,0
80006896:	f2 08 17 10 	movne	r8,r9
8000689a:	ed d8 e1 06 	addne	r6,r6,r8
8000689e:	28 08       	sub	r8,-128
800068a0:	ec 01 00 01 	add	r1,r6,r1
800068a4:	0a 9c       	mov	r12,r5
800068a6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800068aa:	f0 01 01 01 	sub	r1,r8,r1
800068ae:	02 9b       	mov	r11,r1
800068b0:	e0 a0 02 7c 	rcall	80006da8 <_sbrk_r>
800068b4:	e0 68 0c cc 	mov	r8,3276
800068b8:	5b fc       	cp.w	r12,-1
800068ba:	ec 0c 17 00 	moveq	r12,r6
800068be:	f9 b1 00 00 	moveq	r1,0
800068c2:	70 09       	ld.w	r9,r8[0x0]
800068c4:	0c 1c       	sub	r12,r6
800068c6:	89 26       	st.w	r4[0x8],r6
800068c8:	02 0c       	add	r12,r1
800068ca:	12 01       	add	r1,r9
800068cc:	a1 ac       	sbr	r12,0x0
800068ce:	91 01       	st.w	r8[0x0],r1
800068d0:	8d 1c       	st.w	r6[0x4],r12
800068d2:	08 33       	cp.w	r3,r4
800068d4:	c1 d0       	breq	8000690e <_malloc_r+0x3da>
800068d6:	58 f2       	cp.w	r2,15
800068d8:	e0 8b 00 05 	brhi	800068e2 <_malloc_r+0x3ae>
800068dc:	30 18       	mov	r8,1
800068de:	8d 18       	st.w	r6[0x4],r8
800068e0:	c2 68       	rjmp	8000692c <_malloc_r+0x3f8>
800068e2:	30 59       	mov	r9,5
800068e4:	20 c2       	sub	r2,12
800068e6:	e0 12 ff f8 	andl	r2,0xfff8
800068ea:	e6 02 00 08 	add	r8,r3,r2
800068ee:	91 29       	st.w	r8[0x8],r9
800068f0:	91 19       	st.w	r8[0x4],r9
800068f2:	66 18       	ld.w	r8,r3[0x4]
800068f4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068f8:	e5 e8 10 08 	or	r8,r2,r8
800068fc:	87 18       	st.w	r3[0x4],r8
800068fe:	58 f2       	cp.w	r2,15
80006900:	e0 88 00 07 	brls	8000690e <_malloc_r+0x3da>
80006904:	e6 cb ff f8 	sub	r11,r3,-8
80006908:	0a 9c       	mov	r12,r5
8000690a:	e0 a0 1c 7d 	rcall	8000a204 <_free_r>
8000690e:	e0 69 0c c4 	mov	r9,3268
80006912:	72 0a       	ld.w	r10,r9[0x0]
80006914:	e0 68 0c cc 	mov	r8,3276
80006918:	70 08       	ld.w	r8,r8[0x0]
8000691a:	14 38       	cp.w	r8,r10
8000691c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006920:	e0 69 0c c0 	mov	r9,3264
80006924:	72 0a       	ld.w	r10,r9[0x0]
80006926:	14 38       	cp.w	r8,r10
80006928:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000692c:	68 28       	ld.w	r8,r4[0x8]
8000692e:	70 18       	ld.w	r8,r8[0x4]
80006930:	e0 18 ff fc 	andl	r8,0xfffc
80006934:	0e 38       	cp.w	r8,r7
80006936:	5f 39       	srlo	r9
80006938:	0e 18       	sub	r8,r7
8000693a:	58 f8       	cp.w	r8,15
8000693c:	5f aa       	srle	r10
8000693e:	f5 e9 10 09 	or	r9,r10,r9
80006942:	c0 50       	breq	8000694c <_malloc_r+0x418>
80006944:	0a 9c       	mov	r12,r5
80006946:	fe b0 f4 bb 	rcall	800052bc <__malloc_unlock>
8000694a:	d8 3a       	popm	r0-r7,pc,r12=0
8000694c:	68 26       	ld.w	r6,r4[0x8]
8000694e:	a1 a8       	sbr	r8,0x0
80006950:	0e 99       	mov	r9,r7
80006952:	a1 a9       	sbr	r9,0x0
80006954:	8d 19       	st.w	r6[0x4],r9
80006956:	ec 07 00 07 	add	r7,r6,r7
8000695a:	0a 9c       	mov	r12,r5
8000695c:	89 27       	st.w	r4[0x8],r7
8000695e:	8f 18       	st.w	r7[0x4],r8
80006960:	fe b0 f4 ae 	rcall	800052bc <__malloc_unlock>
80006964:	ec cc ff f8 	sub	r12,r6,-8
80006968:	d8 32       	popm	r0-r7,pc
8000696a:	d7 03       	nop

8000696c <memcmp>:
8000696c:	d4 01       	pushm	lr
8000696e:	30 08       	mov	r8,0
80006970:	c0 d8       	rjmp	8000698a <memcmp+0x1e>
80006972:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80006976:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000697a:	20 1a       	sub	r10,1
8000697c:	2f f8       	sub	r8,-1
8000697e:	f2 0e 18 00 	cp.b	lr,r9
80006982:	c0 40       	breq	8000698a <memcmp+0x1e>
80006984:	fc 09 01 0c 	sub	r12,lr,r9
80006988:	d8 02       	popm	pc
8000698a:	58 0a       	cp.w	r10,0
8000698c:	cf 31       	brne	80006972 <memcmp+0x6>
8000698e:	14 9c       	mov	r12,r10
80006990:	d8 02       	popm	pc

80006992 <memcpy>:
80006992:	58 8a       	cp.w	r10,8
80006994:	c2 f5       	brlt	800069f2 <memcpy+0x60>
80006996:	f9 eb 10 09 	or	r9,r12,r11
8000699a:	e2 19 00 03 	andl	r9,0x3,COH
8000699e:	e0 81 00 97 	brne	80006acc <memcpy+0x13a>
800069a2:	e0 4a 00 20 	cp.w	r10,32
800069a6:	c3 b4       	brge	80006a1c <memcpy+0x8a>
800069a8:	f4 08 14 02 	asr	r8,r10,0x2
800069ac:	f0 09 11 08 	rsub	r9,r8,8
800069b0:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800069b4:	76 69       	ld.w	r9,r11[0x18]
800069b6:	99 69       	st.w	r12[0x18],r9
800069b8:	76 59       	ld.w	r9,r11[0x14]
800069ba:	99 59       	st.w	r12[0x14],r9
800069bc:	76 49       	ld.w	r9,r11[0x10]
800069be:	99 49       	st.w	r12[0x10],r9
800069c0:	76 39       	ld.w	r9,r11[0xc]
800069c2:	99 39       	st.w	r12[0xc],r9
800069c4:	76 29       	ld.w	r9,r11[0x8]
800069c6:	99 29       	st.w	r12[0x8],r9
800069c8:	76 19       	ld.w	r9,r11[0x4]
800069ca:	99 19       	st.w	r12[0x4],r9
800069cc:	76 09       	ld.w	r9,r11[0x0]
800069ce:	99 09       	st.w	r12[0x0],r9
800069d0:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800069d4:	f8 08 00 28 	add	r8,r12,r8<<0x2
800069d8:	e0 1a 00 03 	andl	r10,0x3
800069dc:	f4 0a 11 04 	rsub	r10,r10,4
800069e0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800069e4:	17 a9       	ld.ub	r9,r11[0x2]
800069e6:	b0 a9       	st.b	r8[0x2],r9
800069e8:	17 99       	ld.ub	r9,r11[0x1]
800069ea:	b0 99       	st.b	r8[0x1],r9
800069ec:	17 89       	ld.ub	r9,r11[0x0]
800069ee:	b0 89       	st.b	r8[0x0],r9
800069f0:	5e fc       	retal	r12
800069f2:	f4 0a 11 09 	rsub	r10,r10,9
800069f6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800069fa:	17 f9       	ld.ub	r9,r11[0x7]
800069fc:	b8 f9       	st.b	r12[0x7],r9
800069fe:	17 e9       	ld.ub	r9,r11[0x6]
80006a00:	b8 e9       	st.b	r12[0x6],r9
80006a02:	17 d9       	ld.ub	r9,r11[0x5]
80006a04:	b8 d9       	st.b	r12[0x5],r9
80006a06:	17 c9       	ld.ub	r9,r11[0x4]
80006a08:	b8 c9       	st.b	r12[0x4],r9
80006a0a:	17 b9       	ld.ub	r9,r11[0x3]
80006a0c:	b8 b9       	st.b	r12[0x3],r9
80006a0e:	17 a9       	ld.ub	r9,r11[0x2]
80006a10:	b8 a9       	st.b	r12[0x2],r9
80006a12:	17 99       	ld.ub	r9,r11[0x1]
80006a14:	b8 99       	st.b	r12[0x1],r9
80006a16:	17 89       	ld.ub	r9,r11[0x0]
80006a18:	b8 89       	st.b	r12[0x0],r9
80006a1a:	5e fc       	retal	r12
80006a1c:	eb cd 40 c0 	pushm	r6-r7,lr
80006a20:	18 99       	mov	r9,r12
80006a22:	22 0a       	sub	r10,32
80006a24:	b7 07       	ld.d	r6,r11++
80006a26:	b3 26       	st.d	r9++,r6
80006a28:	b7 07       	ld.d	r6,r11++
80006a2a:	b3 26       	st.d	r9++,r6
80006a2c:	b7 07       	ld.d	r6,r11++
80006a2e:	b3 26       	st.d	r9++,r6
80006a30:	b7 07       	ld.d	r6,r11++
80006a32:	b3 26       	st.d	r9++,r6
80006a34:	22 0a       	sub	r10,32
80006a36:	cf 74       	brge	80006a24 <memcpy+0x92>
80006a38:	2f 0a       	sub	r10,-16
80006a3a:	c0 65       	brlt	80006a46 <memcpy+0xb4>
80006a3c:	b7 07       	ld.d	r6,r11++
80006a3e:	b3 26       	st.d	r9++,r6
80006a40:	b7 07       	ld.d	r6,r11++
80006a42:	b3 26       	st.d	r9++,r6
80006a44:	21 0a       	sub	r10,16
80006a46:	5c 3a       	neg	r10
80006a48:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006a4c:	d7 03       	nop
80006a4e:	d7 03       	nop
80006a50:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006a54:	f3 66 00 0e 	st.b	r9[14],r6
80006a58:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006a5c:	f3 66 00 0d 	st.b	r9[13],r6
80006a60:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006a64:	f3 66 00 0c 	st.b	r9[12],r6
80006a68:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006a6c:	f3 66 00 0b 	st.b	r9[11],r6
80006a70:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006a74:	f3 66 00 0a 	st.b	r9[10],r6
80006a78:	f7 36 00 09 	ld.ub	r6,r11[9]
80006a7c:	f3 66 00 09 	st.b	r9[9],r6
80006a80:	f7 36 00 08 	ld.ub	r6,r11[8]
80006a84:	f3 66 00 08 	st.b	r9[8],r6
80006a88:	f7 36 00 07 	ld.ub	r6,r11[7]
80006a8c:	f3 66 00 07 	st.b	r9[7],r6
80006a90:	f7 36 00 06 	ld.ub	r6,r11[6]
80006a94:	f3 66 00 06 	st.b	r9[6],r6
80006a98:	f7 36 00 05 	ld.ub	r6,r11[5]
80006a9c:	f3 66 00 05 	st.b	r9[5],r6
80006aa0:	f7 36 00 04 	ld.ub	r6,r11[4]
80006aa4:	f3 66 00 04 	st.b	r9[4],r6
80006aa8:	f7 36 00 03 	ld.ub	r6,r11[3]
80006aac:	f3 66 00 03 	st.b	r9[3],r6
80006ab0:	f7 36 00 02 	ld.ub	r6,r11[2]
80006ab4:	f3 66 00 02 	st.b	r9[2],r6
80006ab8:	f7 36 00 01 	ld.ub	r6,r11[1]
80006abc:	f3 66 00 01 	st.b	r9[1],r6
80006ac0:	f7 36 00 00 	ld.ub	r6,r11[0]
80006ac4:	f3 66 00 00 	st.b	r9[0],r6
80006ac8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006acc:	20 1a       	sub	r10,1
80006ace:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006ad2:	f8 0a 0b 09 	st.b	r12[r10],r9
80006ad6:	cf b1       	brne	80006acc <memcpy+0x13a>
80006ad8:	5e fc       	retal	r12

80006ada <memset>:
80006ada:	18 98       	mov	r8,r12
80006adc:	c0 38       	rjmp	80006ae2 <memset+0x8>
80006ade:	10 cb       	st.b	r8++,r11
80006ae0:	20 1a       	sub	r10,1
80006ae2:	58 0a       	cp.w	r10,0
80006ae4:	cf d1       	brne	80006ade <memset+0x4>
80006ae6:	5e fc       	retal	r12

80006ae8 <_realloc_r>:
80006ae8:	d4 31       	pushm	r0-r7,lr
80006aea:	20 1d       	sub	sp,4
80006aec:	16 94       	mov	r4,r11
80006aee:	18 92       	mov	r2,r12
80006af0:	14 9b       	mov	r11,r10
80006af2:	58 04       	cp.w	r4,0
80006af4:	c0 51       	brne	80006afe <_realloc_r+0x16>
80006af6:	fe b0 fd 1f 	rcall	80006534 <_malloc_r>
80006afa:	18 95       	mov	r5,r12
80006afc:	c5 39       	rjmp	80006da2 <_realloc_r+0x2ba>
80006afe:	50 0a       	stdsp	sp[0x0],r10
80006b00:	fe b0 f3 d8 	rcall	800052b0 <__malloc_lock>
80006b04:	40 0b       	lddsp	r11,sp[0x0]
80006b06:	f6 c8 ff f5 	sub	r8,r11,-11
80006b0a:	e8 c1 00 08 	sub	r1,r4,8
80006b0e:	10 96       	mov	r6,r8
80006b10:	62 1c       	ld.w	r12,r1[0x4]
80006b12:	e0 16 ff f8 	andl	r6,0xfff8
80006b16:	59 68       	cp.w	r8,22
80006b18:	f9 b6 08 10 	movls	r6,16
80006b1c:	16 36       	cp.w	r6,r11
80006b1e:	5f 38       	srlo	r8
80006b20:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006b24:	c0 50       	breq	80006b2e <_realloc_r+0x46>
80006b26:	30 c8       	mov	r8,12
80006b28:	30 05       	mov	r5,0
80006b2a:	85 38       	st.w	r2[0xc],r8
80006b2c:	c3 b9       	rjmp	80006da2 <_realloc_r+0x2ba>
80006b2e:	18 90       	mov	r0,r12
80006b30:	e0 10 ff fc 	andl	r0,0xfffc
80006b34:	0c 30       	cp.w	r0,r6
80006b36:	e0 84 01 0b 	brge	80006d4c <_realloc_r+0x264>
80006b3a:	e0 68 05 1c 	mov	r8,1308
80006b3e:	e2 00 00 09 	add	r9,r1,r0
80006b42:	70 25       	ld.w	r5,r8[0x8]
80006b44:	0a 39       	cp.w	r9,r5
80006b46:	c0 90       	breq	80006b58 <_realloc_r+0x70>
80006b48:	72 1a       	ld.w	r10,r9[0x4]
80006b4a:	a1 ca       	cbr	r10,0x0
80006b4c:	f2 0a 00 0a 	add	r10,r9,r10
80006b50:	74 1a       	ld.w	r10,r10[0x4]
80006b52:	ed ba 00 00 	bld	r10,0x0
80006b56:	c2 20       	breq	80006b9a <_realloc_r+0xb2>
80006b58:	72 1a       	ld.w	r10,r9[0x4]
80006b5a:	e0 1a ff fc 	andl	r10,0xfffc
80006b5e:	f4 00 00 03 	add	r3,r10,r0
80006b62:	0a 39       	cp.w	r9,r5
80006b64:	c1 31       	brne	80006b8a <_realloc_r+0xa2>
80006b66:	ec c7 ff f0 	sub	r7,r6,-16
80006b6a:	0e 33       	cp.w	r3,r7
80006b6c:	c1 95       	brlt	80006b9e <_realloc_r+0xb6>
80006b6e:	e2 06 00 09 	add	r9,r1,r6
80006b72:	0c 13       	sub	r3,r6
80006b74:	a1 a3       	sbr	r3,0x0
80006b76:	93 13       	st.w	r9[0x4],r3
80006b78:	91 29       	st.w	r8[0x8],r9
80006b7a:	04 9c       	mov	r12,r2
80006b7c:	62 18       	ld.w	r8,r1[0x4]
80006b7e:	08 95       	mov	r5,r4
80006b80:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b84:	10 46       	or	r6,r8
80006b86:	83 16       	st.w	r1[0x4],r6
80006b88:	c0 b9       	rjmp	80006d9e <_realloc_r+0x2b6>
80006b8a:	0c 33       	cp.w	r3,r6
80006b8c:	c0 95       	brlt	80006b9e <_realloc_r+0xb6>
80006b8e:	72 28       	ld.w	r8,r9[0x8]
80006b90:	02 97       	mov	r7,r1
80006b92:	72 39       	ld.w	r9,r9[0xc]
80006b94:	93 28       	st.w	r9[0x8],r8
80006b96:	91 39       	st.w	r8[0xc],r9
80006b98:	cd c8       	rjmp	80006d50 <_realloc_r+0x268>
80006b9a:	30 0a       	mov	r10,0
80006b9c:	14 99       	mov	r9,r10
80006b9e:	ed bc 00 00 	bld	r12,0x0
80006ba2:	e0 80 00 95 	breq	80006ccc <_realloc_r+0x1e4>
80006ba6:	62 07       	ld.w	r7,r1[0x0]
80006ba8:	e2 07 01 07 	sub	r7,r1,r7
80006bac:	6e 1c       	ld.w	r12,r7[0x4]
80006bae:	e0 1c ff fc 	andl	r12,0xfffc
80006bb2:	58 09       	cp.w	r9,0
80006bb4:	c5 60       	breq	80006c60 <_realloc_r+0x178>
80006bb6:	f8 00 00 03 	add	r3,r12,r0
80006bba:	0a 39       	cp.w	r9,r5
80006bbc:	c4 81       	brne	80006c4c <_realloc_r+0x164>
80006bbe:	14 03       	add	r3,r10
80006bc0:	ec c9 ff f0 	sub	r9,r6,-16
80006bc4:	12 33       	cp.w	r3,r9
80006bc6:	c4 d5       	brlt	80006c60 <_realloc_r+0x178>
80006bc8:	6e 3a       	ld.w	r10,r7[0xc]
80006bca:	6e 29       	ld.w	r9,r7[0x8]
80006bcc:	95 29       	st.w	r10[0x8],r9
80006bce:	93 3a       	st.w	r9[0xc],r10
80006bd0:	ee c5 ff f8 	sub	r5,r7,-8
80006bd4:	e0 ca 00 04 	sub	r10,r0,4
80006bd8:	e0 4a 00 24 	cp.w	r10,36
80006bdc:	e0 8b 00 25 	brhi	80006c26 <_realloc_r+0x13e>
80006be0:	0a 99       	mov	r9,r5
80006be2:	59 3a       	cp.w	r10,19
80006be4:	e0 88 00 1a 	brls	80006c18 <_realloc_r+0x130>
80006be8:	09 09       	ld.w	r9,r4++
80006bea:	8b 09       	st.w	r5[0x0],r9
80006bec:	09 09       	ld.w	r9,r4++
80006bee:	8f 39       	st.w	r7[0xc],r9
80006bf0:	ee c9 ff f0 	sub	r9,r7,-16
80006bf4:	59 ba       	cp.w	r10,27
80006bf6:	e0 88 00 11 	brls	80006c18 <_realloc_r+0x130>
80006bfa:	09 0b       	ld.w	r11,r4++
80006bfc:	93 0b       	st.w	r9[0x0],r11
80006bfe:	09 09       	ld.w	r9,r4++
80006c00:	8f 59       	st.w	r7[0x14],r9
80006c02:	ee c9 ff e8 	sub	r9,r7,-24
80006c06:	e0 4a 00 24 	cp.w	r10,36
80006c0a:	c0 71       	brne	80006c18 <_realloc_r+0x130>
80006c0c:	09 0a       	ld.w	r10,r4++
80006c0e:	93 0a       	st.w	r9[0x0],r10
80006c10:	ee c9 ff e0 	sub	r9,r7,-32
80006c14:	09 0a       	ld.w	r10,r4++
80006c16:	8f 7a       	st.w	r7[0x1c],r10
80006c18:	09 0a       	ld.w	r10,r4++
80006c1a:	12 aa       	st.w	r9++,r10
80006c1c:	68 0a       	ld.w	r10,r4[0x0]
80006c1e:	93 0a       	st.w	r9[0x0],r10
80006c20:	68 1a       	ld.w	r10,r4[0x4]
80006c22:	93 1a       	st.w	r9[0x4],r10
80006c24:	c0 78       	rjmp	80006c32 <_realloc_r+0x14a>
80006c26:	50 08       	stdsp	sp[0x0],r8
80006c28:	08 9b       	mov	r11,r4
80006c2a:	0a 9c       	mov	r12,r5
80006c2c:	e0 a0 1d 8f 	rcall	8000a74a <memmove>
80006c30:	40 08       	lddsp	r8,sp[0x0]
80006c32:	ee 06 00 09 	add	r9,r7,r6
80006c36:	0c 13       	sub	r3,r6
80006c38:	a1 a3       	sbr	r3,0x0
80006c3a:	93 13       	st.w	r9[0x4],r3
80006c3c:	91 29       	st.w	r8[0x8],r9
80006c3e:	04 9c       	mov	r12,r2
80006c40:	6e 18       	ld.w	r8,r7[0x4]
80006c42:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006c46:	10 46       	or	r6,r8
80006c48:	8f 16       	st.w	r7[0x4],r6
80006c4a:	ca a8       	rjmp	80006d9e <_realloc_r+0x2b6>
80006c4c:	14 03       	add	r3,r10
80006c4e:	0c 33       	cp.w	r3,r6
80006c50:	c0 85       	brlt	80006c60 <_realloc_r+0x178>
80006c52:	72 28       	ld.w	r8,r9[0x8]
80006c54:	72 39       	ld.w	r9,r9[0xc]
80006c56:	93 28       	st.w	r9[0x8],r8
80006c58:	91 39       	st.w	r8[0xc],r9
80006c5a:	6e 28       	ld.w	r8,r7[0x8]
80006c5c:	6e 39       	ld.w	r9,r7[0xc]
80006c5e:	c0 78       	rjmp	80006c6c <_realloc_r+0x184>
80006c60:	f8 00 00 03 	add	r3,r12,r0
80006c64:	0c 33       	cp.w	r3,r6
80006c66:	c3 35       	brlt	80006ccc <_realloc_r+0x1e4>
80006c68:	6e 39       	ld.w	r9,r7[0xc]
80006c6a:	6e 28       	ld.w	r8,r7[0x8]
80006c6c:	93 28       	st.w	r9[0x8],r8
80006c6e:	91 39       	st.w	r8[0xc],r9
80006c70:	e0 ca 00 04 	sub	r10,r0,4
80006c74:	ee cc ff f8 	sub	r12,r7,-8
80006c78:	e0 4a 00 24 	cp.w	r10,36
80006c7c:	e0 8b 00 24 	brhi	80006cc4 <_realloc_r+0x1dc>
80006c80:	59 3a       	cp.w	r10,19
80006c82:	e0 88 00 1a 	brls	80006cb6 <_realloc_r+0x1ce>
80006c86:	09 08       	ld.w	r8,r4++
80006c88:	99 08       	st.w	r12[0x0],r8
80006c8a:	09 08       	ld.w	r8,r4++
80006c8c:	8f 38       	st.w	r7[0xc],r8
80006c8e:	ee cc ff f0 	sub	r12,r7,-16
80006c92:	59 ba       	cp.w	r10,27
80006c94:	e0 88 00 11 	brls	80006cb6 <_realloc_r+0x1ce>
80006c98:	09 08       	ld.w	r8,r4++
80006c9a:	99 08       	st.w	r12[0x0],r8
80006c9c:	09 08       	ld.w	r8,r4++
80006c9e:	8f 58       	st.w	r7[0x14],r8
80006ca0:	ee cc ff e8 	sub	r12,r7,-24
80006ca4:	e0 4a 00 24 	cp.w	r10,36
80006ca8:	c0 71       	brne	80006cb6 <_realloc_r+0x1ce>
80006caa:	09 08       	ld.w	r8,r4++
80006cac:	99 08       	st.w	r12[0x0],r8
80006cae:	ee cc ff e0 	sub	r12,r7,-32
80006cb2:	09 08       	ld.w	r8,r4++
80006cb4:	8f 78       	st.w	r7[0x1c],r8
80006cb6:	09 08       	ld.w	r8,r4++
80006cb8:	18 a8       	st.w	r12++,r8
80006cba:	68 08       	ld.w	r8,r4[0x0]
80006cbc:	99 08       	st.w	r12[0x0],r8
80006cbe:	68 18       	ld.w	r8,r4[0x4]
80006cc0:	99 18       	st.w	r12[0x4],r8
80006cc2:	c4 78       	rjmp	80006d50 <_realloc_r+0x268>
80006cc4:	08 9b       	mov	r11,r4
80006cc6:	e0 a0 1d 42 	rcall	8000a74a <memmove>
80006cca:	c4 38       	rjmp	80006d50 <_realloc_r+0x268>
80006ccc:	04 9c       	mov	r12,r2
80006cce:	fe b0 fc 33 	rcall	80006534 <_malloc_r>
80006cd2:	18 95       	mov	r5,r12
80006cd4:	c3 a0       	breq	80006d48 <_realloc_r+0x260>
80006cd6:	62 18       	ld.w	r8,r1[0x4]
80006cd8:	f8 c9 00 08 	sub	r9,r12,8
80006cdc:	a1 c8       	cbr	r8,0x0
80006cde:	e2 08 00 08 	add	r8,r1,r8
80006ce2:	10 39       	cp.w	r9,r8
80006ce4:	c0 71       	brne	80006cf2 <_realloc_r+0x20a>
80006ce6:	72 13       	ld.w	r3,r9[0x4]
80006ce8:	02 97       	mov	r7,r1
80006cea:	e0 13 ff fc 	andl	r3,0xfffc
80006cee:	00 03       	add	r3,r0
80006cf0:	c3 08       	rjmp	80006d50 <_realloc_r+0x268>
80006cf2:	e0 ca 00 04 	sub	r10,r0,4
80006cf6:	e0 4a 00 24 	cp.w	r10,36
80006cfa:	e0 8b 00 20 	brhi	80006d3a <_realloc_r+0x252>
80006cfe:	08 99       	mov	r9,r4
80006d00:	18 98       	mov	r8,r12
80006d02:	59 3a       	cp.w	r10,19
80006d04:	e0 88 00 14 	brls	80006d2c <_realloc_r+0x244>
80006d08:	13 0b       	ld.w	r11,r9++
80006d0a:	10 ab       	st.w	r8++,r11
80006d0c:	13 0b       	ld.w	r11,r9++
80006d0e:	10 ab       	st.w	r8++,r11
80006d10:	59 ba       	cp.w	r10,27
80006d12:	e0 88 00 0d 	brls	80006d2c <_realloc_r+0x244>
80006d16:	13 0b       	ld.w	r11,r9++
80006d18:	10 ab       	st.w	r8++,r11
80006d1a:	13 0b       	ld.w	r11,r9++
80006d1c:	10 ab       	st.w	r8++,r11
80006d1e:	e0 4a 00 24 	cp.w	r10,36
80006d22:	c0 51       	brne	80006d2c <_realloc_r+0x244>
80006d24:	13 0a       	ld.w	r10,r9++
80006d26:	10 aa       	st.w	r8++,r10
80006d28:	13 0a       	ld.w	r10,r9++
80006d2a:	10 aa       	st.w	r8++,r10
80006d2c:	13 0a       	ld.w	r10,r9++
80006d2e:	10 aa       	st.w	r8++,r10
80006d30:	72 0a       	ld.w	r10,r9[0x0]
80006d32:	91 0a       	st.w	r8[0x0],r10
80006d34:	72 19       	ld.w	r9,r9[0x4]
80006d36:	91 19       	st.w	r8[0x4],r9
80006d38:	c0 48       	rjmp	80006d40 <_realloc_r+0x258>
80006d3a:	08 9b       	mov	r11,r4
80006d3c:	e0 a0 1d 07 	rcall	8000a74a <memmove>
80006d40:	08 9b       	mov	r11,r4
80006d42:	04 9c       	mov	r12,r2
80006d44:	e0 a0 1a 60 	rcall	8000a204 <_free_r>
80006d48:	04 9c       	mov	r12,r2
80006d4a:	c2 a8       	rjmp	80006d9e <_realloc_r+0x2b6>
80006d4c:	00 93       	mov	r3,r0
80006d4e:	02 97       	mov	r7,r1
80006d50:	e6 06 01 09 	sub	r9,r3,r6
80006d54:	6e 18       	ld.w	r8,r7[0x4]
80006d56:	58 f9       	cp.w	r9,15
80006d58:	e0 88 00 16 	brls	80006d84 <_realloc_r+0x29c>
80006d5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d60:	ed e8 10 08 	or	r8,r6,r8
80006d64:	8f 18       	st.w	r7[0x4],r8
80006d66:	12 98       	mov	r8,r9
80006d68:	a1 a8       	sbr	r8,0x0
80006d6a:	ee 06 00 0b 	add	r11,r7,r6
80006d6e:	f6 09 00 09 	add	r9,r11,r9
80006d72:	97 18       	st.w	r11[0x4],r8
80006d74:	72 18       	ld.w	r8,r9[0x4]
80006d76:	a1 a8       	sbr	r8,0x0
80006d78:	2f 8b       	sub	r11,-8
80006d7a:	93 18       	st.w	r9[0x4],r8
80006d7c:	04 9c       	mov	r12,r2
80006d7e:	e0 a0 1a 43 	rcall	8000a204 <_free_r>
80006d82:	c0 b8       	rjmp	80006d98 <_realloc_r+0x2b0>
80006d84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d88:	e7 e8 10 08 	or	r8,r3,r8
80006d8c:	8f 18       	st.w	r7[0x4],r8
80006d8e:	ee 03 00 03 	add	r3,r7,r3
80006d92:	66 18       	ld.w	r8,r3[0x4]
80006d94:	a1 a8       	sbr	r8,0x0
80006d96:	87 18       	st.w	r3[0x4],r8
80006d98:	04 9c       	mov	r12,r2
80006d9a:	ee c5 ff f8 	sub	r5,r7,-8
80006d9e:	fe b0 f2 8f 	rcall	800052bc <__malloc_unlock>
80006da2:	0a 9c       	mov	r12,r5
80006da4:	2f fd       	sub	sp,-4
80006da6:	d8 32       	popm	r0-r7,pc

80006da8 <_sbrk_r>:
80006da8:	d4 21       	pushm	r4-r7,lr
80006daa:	30 08       	mov	r8,0
80006dac:	18 97       	mov	r7,r12
80006dae:	e0 66 1f b4 	mov	r6,8116
80006db2:	16 9c       	mov	r12,r11
80006db4:	8d 08       	st.w	r6[0x0],r8
80006db6:	c8 5c       	rcall	80006ec0 <_sbrk>
80006db8:	5b fc       	cp.w	r12,-1
80006dba:	c0 51       	brne	80006dc4 <_sbrk_r+0x1c>
80006dbc:	6c 08       	ld.w	r8,r6[0x0]
80006dbe:	58 08       	cp.w	r8,0
80006dc0:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006dc4:	d8 22       	popm	r4-r7,pc
80006dc6:	d7 03       	nop

80006dc8 <sprintf>:
80006dc8:	d4 01       	pushm	lr
80006dca:	21 7d       	sub	sp,92
80006dcc:	e0 68 ff ff 	mov	r8,65535
80006dd0:	ea 18 7f ff 	orh	r8,0x7fff
80006dd4:	50 58       	stdsp	sp[0x14],r8
80006dd6:	50 28       	stdsp	sp[0x8],r8
80006dd8:	e0 68 02 08 	mov	r8,520
80006ddc:	ba 68       	st.h	sp[0xc],r8
80006dde:	3f f8       	mov	r8,-1
80006de0:	ba 78       	st.h	sp[0xe],r8
80006de2:	e0 68 0a 1c 	mov	r8,2588
80006de6:	50 4c       	stdsp	sp[0x10],r12
80006de8:	16 9a       	mov	r10,r11
80006dea:	50 0c       	stdsp	sp[0x0],r12
80006dec:	fa c9 ff a0 	sub	r9,sp,-96
80006df0:	70 0c       	ld.w	r12,r8[0x0]
80006df2:	1a 9b       	mov	r11,sp
80006df4:	e0 a0 02 1a 	rcall	80007228 <_vfprintf_r>
80006df8:	30 09       	mov	r9,0
80006dfa:	40 08       	lddsp	r8,sp[0x0]
80006dfc:	b0 89       	st.b	r8[0x0],r9
80006dfe:	2e 9d       	sub	sp,-92
80006e00:	d8 02       	popm	pc
80006e02:	d7 03       	nop

80006e04 <strncpy>:
80006e04:	30 08       	mov	r8,0
80006e06:	10 3a       	cp.w	r10,r8
80006e08:	5e 0c       	reteq	r12
80006e0a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006e0e:	f8 08 0b 09 	st.b	r12[r8],r9
80006e12:	2f f8       	sub	r8,-1
80006e14:	58 09       	cp.w	r9,0
80006e16:	cf 81       	brne	80006e06 <strncpy+0x2>
80006e18:	10 3a       	cp.w	r10,r8
80006e1a:	5e 0c       	reteq	r12
80006e1c:	f8 08 0b 09 	st.b	r12[r8],r9
80006e20:	2f f8       	sub	r8,-1
80006e22:	cf bb       	rjmp	80006e18 <strncpy+0x14>

80006e24 <_close>:
80006e24:	30 28       	mov	r8,2
80006e26:	d6 73       	breakpoint
80006e28:	3f fc       	mov	r12,-1
80006e2a:	35 8b       	mov	r11,88
80006e2c:	58 0c       	cp.w	r12,0
80006e2e:	5e 4c       	retge	r12
80006e30:	e0 6a 1f b4 	mov	r10,8116
80006e34:	95 0b       	st.w	r10[0x0],r11
80006e36:	5e fc       	retal	r12

80006e38 <_lseek>:
80006e38:	30 58       	mov	r8,5
80006e3a:	d6 73       	breakpoint
80006e3c:	3f fc       	mov	r12,-1
80006e3e:	35 8b       	mov	r11,88
80006e40:	58 0c       	cp.w	r12,0
80006e42:	5e 4c       	retge	r12
80006e44:	e0 6a 1f b4 	mov	r10,8116
80006e48:	95 0b       	st.w	r10[0x0],r11
80006e4a:	5e fc       	retal	r12

80006e4c <isatty>:
80006e4c:	30 b8       	mov	r8,11
80006e4e:	d6 73       	breakpoint
80006e50:	3f fc       	mov	r12,-1
80006e52:	35 8b       	mov	r11,88
80006e54:	58 0c       	cp.w	r12,0
80006e56:	5e 4c       	retge	r12
80006e58:	e0 6a 1f b4 	mov	r10,8116
80006e5c:	95 0b       	st.w	r10[0x0],r11
80006e5e:	5e fc       	retal	r12

80006e60 <_fstat_host>:
80006e60:	30 98       	mov	r8,9
80006e62:	d6 73       	breakpoint
80006e64:	3f fc       	mov	r12,-1
80006e66:	35 8b       	mov	r11,88
80006e68:	58 0c       	cp.w	r12,0
80006e6a:	5e 4c       	retge	r12
80006e6c:	e0 6a 1f b4 	mov	r10,8116
80006e70:	95 0b       	st.w	r10[0x0],r11
80006e72:	5e fc       	retal	r12

80006e74 <_fstat>:
80006e74:	d4 21       	pushm	r4-r7,lr
80006e76:	21 0d       	sub	sp,64
80006e78:	16 97       	mov	r7,r11
80006e7a:	1a 9b       	mov	r11,sp
80006e7c:	cf 2f       	rcall	80006e60 <_fstat_host>
80006e7e:	c0 34       	brge	80006e84 <_fstat+0x10>
80006e80:	3f fc       	mov	r12,-1
80006e82:	c1 c8       	rjmp	80006eba <_fstat+0x46>
80006e84:	40 08       	lddsp	r8,sp[0x0]
80006e86:	ae 08       	st.h	r7[0x0],r8
80006e88:	40 18       	lddsp	r8,sp[0x4]
80006e8a:	ae 18       	st.h	r7[0x2],r8
80006e8c:	40 28       	lddsp	r8,sp[0x8]
80006e8e:	8f 18       	st.w	r7[0x4],r8
80006e90:	40 38       	lddsp	r8,sp[0xc]
80006e92:	ae 48       	st.h	r7[0x8],r8
80006e94:	40 48       	lddsp	r8,sp[0x10]
80006e96:	ae 58       	st.h	r7[0xa],r8
80006e98:	40 58       	lddsp	r8,sp[0x14]
80006e9a:	ae 68       	st.h	r7[0xc],r8
80006e9c:	40 68       	lddsp	r8,sp[0x18]
80006e9e:	ae 78       	st.h	r7[0xe],r8
80006ea0:	40 88       	lddsp	r8,sp[0x20]
80006ea2:	8f 48       	st.w	r7[0x10],r8
80006ea4:	40 a8       	lddsp	r8,sp[0x28]
80006ea6:	8f b8       	st.w	r7[0x2c],r8
80006ea8:	40 c8       	lddsp	r8,sp[0x30]
80006eaa:	8f c8       	st.w	r7[0x30],r8
80006eac:	40 d8       	lddsp	r8,sp[0x34]
80006eae:	8f 58       	st.w	r7[0x14],r8
80006eb0:	40 e8       	lddsp	r8,sp[0x38]
80006eb2:	30 0c       	mov	r12,0
80006eb4:	8f 78       	st.w	r7[0x1c],r8
80006eb6:	40 f8       	lddsp	r8,sp[0x3c]
80006eb8:	8f 98       	st.w	r7[0x24],r8
80006eba:	2f 0d       	sub	sp,-64
80006ebc:	d8 22       	popm	r4-r7,pc
80006ebe:	d7 03       	nop

80006ec0 <_sbrk>:
80006ec0:	d4 01       	pushm	lr
80006ec2:	e0 68 0c f4 	mov	r8,3316
80006ec6:	70 09       	ld.w	r9,r8[0x0]
80006ec8:	58 09       	cp.w	r9,0
80006eca:	c0 41       	brne	80006ed2 <_sbrk+0x12>
80006ecc:	e0 69 1f b8 	mov	r9,8120
80006ed0:	91 09       	st.w	r8[0x0],r9
80006ed2:	e0 69 0c f4 	mov	r9,3316
80006ed6:	e0 7a 70 00 	mov	r10,94208
80006eda:	72 08       	ld.w	r8,r9[0x0]
80006edc:	f0 0c 00 0c 	add	r12,r8,r12
80006ee0:	14 3c       	cp.w	r12,r10
80006ee2:	e0 8b 00 04 	brhi	80006eea <_sbrk+0x2a>
80006ee6:	93 0c       	st.w	r9[0x0],r12
80006ee8:	c0 68       	rjmp	80006ef4 <_sbrk+0x34>
80006eea:	e0 a0 18 15 	rcall	80009f14 <__errno>
80006eee:	30 c8       	mov	r8,12
80006ef0:	99 08       	st.w	r12[0x0],r8
80006ef2:	3f f8       	mov	r8,-1
80006ef4:	10 9c       	mov	r12,r8
80006ef6:	d8 02       	popm	pc

80006ef8 <get_arg>:
80006ef8:	d4 31       	pushm	r0-r7,lr
80006efa:	20 8d       	sub	sp,32
80006efc:	fa c4 ff bc 	sub	r4,sp,-68
80006f00:	50 4b       	stdsp	sp[0x10],r11
80006f02:	68 2e       	ld.w	lr,r4[0x8]
80006f04:	50 58       	stdsp	sp[0x14],r8
80006f06:	12 96       	mov	r6,r9
80006f08:	7c 0b       	ld.w	r11,lr[0x0]
80006f0a:	70 05       	ld.w	r5,r8[0x0]
80006f0c:	50 6e       	stdsp	sp[0x18],lr
80006f0e:	58 0b       	cp.w	r11,0
80006f10:	f4 0b 17 00 	moveq	r11,r10
80006f14:	68 03       	ld.w	r3,r4[0x0]
80006f16:	68 11       	ld.w	r1,r4[0x4]
80006f18:	40 49       	lddsp	r9,sp[0x10]
80006f1a:	30 08       	mov	r8,0
80006f1c:	c2 89       	rjmp	8000716c <get_arg+0x274>
80006f1e:	2f fb       	sub	r11,-1
80006f20:	32 5c       	mov	r12,37
80006f22:	17 8a       	ld.ub	r10,r11[0x0]
80006f24:	f8 0a 18 00 	cp.b	r10,r12
80006f28:	5f 1e       	srne	lr
80006f2a:	f0 0a 18 00 	cp.b	r10,r8
80006f2e:	5f 1c       	srne	r12
80006f30:	fd ec 00 0c 	and	r12,lr,r12
80006f34:	f0 0c 18 00 	cp.b	r12,r8
80006f38:	cf 31       	brne	80006f1e <get_arg+0x26>
80006f3a:	58 0a       	cp.w	r10,0
80006f3c:	e0 80 01 25 	breq	80007186 <get_arg+0x28e>
80006f40:	30 0c       	mov	r12,0
80006f42:	3f fa       	mov	r10,-1
80006f44:	18 90       	mov	r0,r12
80006f46:	50 3a       	stdsp	sp[0xc],r10
80006f48:	18 94       	mov	r4,r12
80006f4a:	18 92       	mov	r2,r12
80006f4c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006f50:	16 97       	mov	r7,r11
80006f52:	50 7c       	stdsp	sp[0x1c],r12
80006f54:	fe cc 9c 90 	sub	r12,pc,-25456
80006f58:	0f 3a       	ld.ub	r10,r7++
80006f5a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006f5e:	40 7c       	lddsp	r12,sp[0x1c]
80006f60:	1c 0c       	add	r12,lr
80006f62:	fe ce 9d 66 	sub	lr,pc,-25242
80006f66:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006f6a:	20 1e       	sub	lr,1
80006f6c:	50 0e       	stdsp	sp[0x0],lr
80006f6e:	fe ce 9d de 	sub	lr,pc,-25122
80006f72:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006f76:	50 7c       	stdsp	sp[0x1c],r12
80006f78:	40 0c       	lddsp	r12,sp[0x0]
80006f7a:	58 7c       	cp.w	r12,7
80006f7c:	e0 8b 00 f1 	brhi	8000715e <get_arg+0x266>
80006f80:	fe ce 9f 90 	sub	lr,pc,-24688
80006f84:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006f88:	36 8b       	mov	r11,104
80006f8a:	f6 0a 18 00 	cp.b	r10,r11
80006f8e:	e0 80 00 e8 	breq	8000715e <get_arg+0x266>
80006f92:	37 1b       	mov	r11,113
80006f94:	f6 0a 18 00 	cp.b	r10,r11
80006f98:	c0 70       	breq	80006fa6 <get_arg+0xae>
80006f9a:	34 cb       	mov	r11,76
80006f9c:	f6 0a 18 00 	cp.b	r10,r11
80006fa0:	c0 51       	brne	80006faa <get_arg+0xb2>
80006fa2:	a3 b4       	sbr	r4,0x3
80006fa4:	cd d8       	rjmp	8000715e <get_arg+0x266>
80006fa6:	a5 b4       	sbr	r4,0x5
80006fa8:	cd b8       	rjmp	8000715e <get_arg+0x266>
80006faa:	08 9a       	mov	r10,r4
80006fac:	0e 9b       	mov	r11,r7
80006fae:	a5 aa       	sbr	r10,0x4
80006fb0:	17 3c       	ld.ub	r12,r11++
80006fb2:	a5 b4       	sbr	r4,0x5
80006fb4:	36 ce       	mov	lr,108
80006fb6:	fc 0c 18 00 	cp.b	r12,lr
80006fba:	e0 80 00 d3 	breq	80007160 <get_arg+0x268>
80006fbe:	14 94       	mov	r4,r10
80006fc0:	cc f8       	rjmp	8000715e <get_arg+0x266>
80006fc2:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006fc6:	36 7c       	mov	r12,103
80006fc8:	f8 0a 18 00 	cp.b	r10,r12
80006fcc:	e0 8b 00 27 	brhi	8000701a <get_arg+0x122>
80006fd0:	36 5b       	mov	r11,101
80006fd2:	f6 0a 18 00 	cp.b	r10,r11
80006fd6:	c4 82       	brcc	80007066 <get_arg+0x16e>
80006fd8:	34 fb       	mov	r11,79
80006fda:	f6 0a 18 00 	cp.b	r10,r11
80006fde:	c4 80       	breq	8000706e <get_arg+0x176>
80006fe0:	e0 8b 00 0c 	brhi	80006ff8 <get_arg+0x100>
80006fe4:	34 5b       	mov	r11,69
80006fe6:	f6 0a 18 00 	cp.b	r10,r11
80006fea:	c3 e0       	breq	80007066 <get_arg+0x16e>
80006fec:	34 7b       	mov	r11,71
80006fee:	f6 0a 18 00 	cp.b	r10,r11
80006ff2:	c3 a0       	breq	80007066 <get_arg+0x16e>
80006ff4:	34 4b       	mov	r11,68
80006ff6:	c0 88       	rjmp	80007006 <get_arg+0x10e>
80006ff8:	35 8b       	mov	r11,88
80006ffa:	f6 0a 18 00 	cp.b	r10,r11
80006ffe:	c2 c0       	breq	80007056 <get_arg+0x15e>
80007000:	e0 8b 00 07 	brhi	8000700e <get_arg+0x116>
80007004:	35 5b       	mov	r11,85
80007006:	f6 0a 18 00 	cp.b	r10,r11
8000700a:	c3 51       	brne	80007074 <get_arg+0x17c>
8000700c:	c3 18       	rjmp	8000706e <get_arg+0x176>
8000700e:	36 3b       	mov	r11,99
80007010:	f6 0a 18 00 	cp.b	r10,r11
80007014:	c2 f0       	breq	80007072 <get_arg+0x17a>
80007016:	36 4b       	mov	r11,100
80007018:	c0 e8       	rjmp	80007034 <get_arg+0x13c>
8000701a:	37 0b       	mov	r11,112
8000701c:	f6 0a 18 00 	cp.b	r10,r11
80007020:	c2 50       	breq	8000706a <get_arg+0x172>
80007022:	e0 8b 00 0d 	brhi	8000703c <get_arg+0x144>
80007026:	36 eb       	mov	r11,110
80007028:	f6 0a 18 00 	cp.b	r10,r11
8000702c:	c1 f0       	breq	8000706a <get_arg+0x172>
8000702e:	e0 8b 00 14 	brhi	80007056 <get_arg+0x15e>
80007032:	36 9b       	mov	r11,105
80007034:	f6 0a 18 00 	cp.b	r10,r11
80007038:	c1 e1       	brne	80007074 <get_arg+0x17c>
8000703a:	c0 e8       	rjmp	80007056 <get_arg+0x15e>
8000703c:	37 5b       	mov	r11,117
8000703e:	f6 0a 18 00 	cp.b	r10,r11
80007042:	c0 a0       	breq	80007056 <get_arg+0x15e>
80007044:	37 8b       	mov	r11,120
80007046:	f6 0a 18 00 	cp.b	r10,r11
8000704a:	c0 60       	breq	80007056 <get_arg+0x15e>
8000704c:	37 3b       	mov	r11,115
8000704e:	f6 0a 18 00 	cp.b	r10,r11
80007052:	c1 11       	brne	80007074 <get_arg+0x17c>
80007054:	c0 b8       	rjmp	8000706a <get_arg+0x172>
80007056:	ed b4 00 04 	bld	r4,0x4
8000705a:	c0 a0       	breq	8000706e <get_arg+0x176>
8000705c:	ed b4 00 05 	bld	r4,0x5
80007060:	c0 91       	brne	80007072 <get_arg+0x17a>
80007062:	30 20       	mov	r0,2
80007064:	c0 88       	rjmp	80007074 <get_arg+0x17c>
80007066:	30 40       	mov	r0,4
80007068:	c0 68       	rjmp	80007074 <get_arg+0x17c>
8000706a:	30 30       	mov	r0,3
8000706c:	c0 48       	rjmp	80007074 <get_arg+0x17c>
8000706e:	30 10       	mov	r0,1
80007070:	c0 28       	rjmp	80007074 <get_arg+0x17c>
80007072:	30 00       	mov	r0,0
80007074:	40 3b       	lddsp	r11,sp[0xc]
80007076:	5b fb       	cp.w	r11,-1
80007078:	c0 40       	breq	80007080 <get_arg+0x188>
8000707a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000707e:	c7 08       	rjmp	8000715e <get_arg+0x266>
80007080:	58 60       	cp.w	r0,6
80007082:	e0 8b 00 6e 	brhi	8000715e <get_arg+0x266>
80007086:	6c 0a       	ld.w	r10,r6[0x0]
80007088:	ea cc ff ff 	sub	r12,r5,-1
8000708c:	fe ce a0 7c 	sub	lr,pc,-24452
80007090:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007094:	f4 cb ff f8 	sub	r11,r10,-8
80007098:	8d 0b       	st.w	r6[0x0],r11
8000709a:	f4 ea 00 00 	ld.d	r10,r10[0]
8000709e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800070a2:	c0 f8       	rjmp	800070c0 <get_arg+0x1c8>
800070a4:	f4 cb ff fc 	sub	r11,r10,-4
800070a8:	8d 0b       	st.w	r6[0x0],r11
800070aa:	74 0a       	ld.w	r10,r10[0x0]
800070ac:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800070b0:	c0 88       	rjmp	800070c0 <get_arg+0x1c8>
800070b2:	f4 cb ff f8 	sub	r11,r10,-8
800070b6:	8d 0b       	st.w	r6[0x0],r11
800070b8:	f4 ea 00 00 	ld.d	r10,r10[0]
800070bc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800070c0:	0e 9b       	mov	r11,r7
800070c2:	18 95       	mov	r5,r12
800070c4:	c4 e8       	rjmp	80007160 <get_arg+0x268>
800070c6:	62 0a       	ld.w	r10,r1[0x0]
800070c8:	5b fa       	cp.w	r10,-1
800070ca:	c0 b1       	brne	800070e0 <get_arg+0x1e8>
800070cc:	50 19       	stdsp	sp[0x4],r9
800070ce:	50 28       	stdsp	sp[0x8],r8
800070d0:	e0 6a 00 80 	mov	r10,128
800070d4:	30 0b       	mov	r11,0
800070d6:	02 9c       	mov	r12,r1
800070d8:	fe b0 fd 01 	rcall	80006ada <memset>
800070dc:	40 28       	lddsp	r8,sp[0x8]
800070de:	40 19       	lddsp	r9,sp[0x4]
800070e0:	e4 cc 00 01 	sub	r12,r2,1
800070e4:	0e 9b       	mov	r11,r7
800070e6:	50 3c       	stdsp	sp[0xc],r12
800070e8:	f2 0c 0c 49 	max	r9,r9,r12
800070ec:	c3 a8       	rjmp	80007160 <get_arg+0x268>
800070ee:	62 0a       	ld.w	r10,r1[0x0]
800070f0:	5b fa       	cp.w	r10,-1
800070f2:	c0 b1       	brne	80007108 <get_arg+0x210>
800070f4:	50 19       	stdsp	sp[0x4],r9
800070f6:	50 28       	stdsp	sp[0x8],r8
800070f8:	e0 6a 00 80 	mov	r10,128
800070fc:	30 0b       	mov	r11,0
800070fe:	02 9c       	mov	r12,r1
80007100:	fe b0 fc ed 	rcall	80006ada <memset>
80007104:	40 28       	lddsp	r8,sp[0x8]
80007106:	40 19       	lddsp	r9,sp[0x4]
80007108:	20 12       	sub	r2,1
8000710a:	30 0a       	mov	r10,0
8000710c:	0e 9b       	mov	r11,r7
8000710e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007112:	f2 02 0c 49 	max	r9,r9,r2
80007116:	c2 58       	rjmp	80007160 <get_arg+0x268>
80007118:	16 97       	mov	r7,r11
8000711a:	6c 0a       	ld.w	r10,r6[0x0]
8000711c:	f4 cb ff fc 	sub	r11,r10,-4
80007120:	8d 0b       	st.w	r6[0x0],r11
80007122:	74 0a       	ld.w	r10,r10[0x0]
80007124:	0e 9b       	mov	r11,r7
80007126:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000712a:	2f f5       	sub	r5,-1
8000712c:	c1 a8       	rjmp	80007160 <get_arg+0x268>
8000712e:	f4 c2 00 30 	sub	r2,r10,48
80007132:	c0 68       	rjmp	8000713e <get_arg+0x246>
80007134:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007138:	2f f7       	sub	r7,-1
8000713a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000713e:	0f 8a       	ld.ub	r10,r7[0x0]
80007140:	58 0a       	cp.w	r10,0
80007142:	c0 e0       	breq	8000715e <get_arg+0x266>
80007144:	23 0a       	sub	r10,48
80007146:	58 9a       	cp.w	r10,9
80007148:	fe 98 ff f6 	brls	80007134 <get_arg+0x23c>
8000714c:	c0 98       	rjmp	8000715e <get_arg+0x266>
8000714e:	2f f7       	sub	r7,-1
80007150:	0f 8a       	ld.ub	r10,r7[0x0]
80007152:	58 0a       	cp.w	r10,0
80007154:	c0 50       	breq	8000715e <get_arg+0x266>
80007156:	23 0a       	sub	r10,48
80007158:	58 9a       	cp.w	r10,9
8000715a:	fe 98 ff fa 	brls	8000714e <get_arg+0x256>
8000715e:	0e 9b       	mov	r11,r7
80007160:	40 7c       	lddsp	r12,sp[0x1c]
80007162:	30 ba       	mov	r10,11
80007164:	f4 0c 18 00 	cp.b	r12,r10
80007168:	fe 91 fe f2 	brne	80006f4c <get_arg+0x54>
8000716c:	40 42       	lddsp	r2,sp[0x10]
8000716e:	17 8c       	ld.ub	r12,r11[0x0]
80007170:	0a 32       	cp.w	r2,r5
80007172:	5f 4a       	srge	r10
80007174:	f0 0c 18 00 	cp.b	r12,r8
80007178:	5f 1c       	srne	r12
8000717a:	f9 ea 00 0a 	and	r10,r12,r10
8000717e:	f0 0a 18 00 	cp.b	r10,r8
80007182:	fe 91 fe cf 	brne	80006f20 <get_arg+0x28>
80007186:	30 08       	mov	r8,0
80007188:	40 4e       	lddsp	lr,sp[0x10]
8000718a:	17 8a       	ld.ub	r10,r11[0x0]
8000718c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007190:	f0 0a 18 00 	cp.b	r10,r8
80007194:	fc 09 17 10 	movne	r9,lr
80007198:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000719c:	06 9e       	mov	lr,r3
8000719e:	c2 a8       	rjmp	800071f2 <get_arg+0x2fa>
800071a0:	62 0a       	ld.w	r10,r1[0x0]
800071a2:	58 3a       	cp.w	r10,3
800071a4:	c1 e0       	breq	800071e0 <get_arg+0x2e8>
800071a6:	e0 89 00 07 	brgt	800071b4 <get_arg+0x2bc>
800071aa:	58 1a       	cp.w	r10,1
800071ac:	c1 a0       	breq	800071e0 <get_arg+0x2e8>
800071ae:	58 2a       	cp.w	r10,2
800071b0:	c1 81       	brne	800071e0 <get_arg+0x2e8>
800071b2:	c0 58       	rjmp	800071bc <get_arg+0x2c4>
800071b4:	58 5a       	cp.w	r10,5
800071b6:	c0 c0       	breq	800071ce <get_arg+0x2d6>
800071b8:	c0 b5       	brlt	800071ce <get_arg+0x2d6>
800071ba:	c1 38       	rjmp	800071e0 <get_arg+0x2e8>
800071bc:	6c 0a       	ld.w	r10,r6[0x0]
800071be:	f4 cc ff f8 	sub	r12,r10,-8
800071c2:	8d 0c       	st.w	r6[0x0],r12
800071c4:	f4 e2 00 00 	ld.d	r2,r10[0]
800071c8:	f0 e3 00 00 	st.d	r8[0],r2
800071cc:	c1 08       	rjmp	800071ec <get_arg+0x2f4>
800071ce:	6c 0a       	ld.w	r10,r6[0x0]
800071d0:	f4 cc ff f8 	sub	r12,r10,-8
800071d4:	8d 0c       	st.w	r6[0x0],r12
800071d6:	f4 e2 00 00 	ld.d	r2,r10[0]
800071da:	f0 e3 00 00 	st.d	r8[0],r2
800071de:	c0 78       	rjmp	800071ec <get_arg+0x2f4>
800071e0:	6c 0a       	ld.w	r10,r6[0x0]
800071e2:	f4 cc ff fc 	sub	r12,r10,-4
800071e6:	8d 0c       	st.w	r6[0x0],r12
800071e8:	74 0a       	ld.w	r10,r10[0x0]
800071ea:	91 0a       	st.w	r8[0x0],r10
800071ec:	2f f5       	sub	r5,-1
800071ee:	2f 88       	sub	r8,-8
800071f0:	2f c1       	sub	r1,-4
800071f2:	12 35       	cp.w	r5,r9
800071f4:	fe 9a ff d6 	brle	800071a0 <get_arg+0x2a8>
800071f8:	1c 93       	mov	r3,lr
800071fa:	40 52       	lddsp	r2,sp[0x14]
800071fc:	40 6e       	lddsp	lr,sp[0x18]
800071fe:	85 05       	st.w	r2[0x0],r5
80007200:	9d 0b       	st.w	lr[0x0],r11
80007202:	40 4b       	lddsp	r11,sp[0x10]
80007204:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007208:	2f 8d       	sub	sp,-32
8000720a:	d8 32       	popm	r0-r7,pc

8000720c <__sprint_r>:
8000720c:	d4 21       	pushm	r4-r7,lr
8000720e:	14 97       	mov	r7,r10
80007210:	74 28       	ld.w	r8,r10[0x8]
80007212:	58 08       	cp.w	r8,0
80007214:	c0 41       	brne	8000721c <__sprint_r+0x10>
80007216:	95 18       	st.w	r10[0x4],r8
80007218:	10 9c       	mov	r12,r8
8000721a:	d8 22       	popm	r4-r7,pc
8000721c:	e0 a0 18 ba 	rcall	8000a390 <__sfvwrite_r>
80007220:	30 08       	mov	r8,0
80007222:	8f 18       	st.w	r7[0x4],r8
80007224:	8f 28       	st.w	r7[0x8],r8
80007226:	d8 22       	popm	r4-r7,pc

80007228 <_vfprintf_r>:
80007228:	d4 31       	pushm	r0-r7,lr
8000722a:	fa cd 06 bc 	sub	sp,sp,1724
8000722e:	51 09       	stdsp	sp[0x40],r9
80007230:	16 91       	mov	r1,r11
80007232:	14 97       	mov	r7,r10
80007234:	18 95       	mov	r5,r12
80007236:	e0 a0 1a 1d 	rcall	8000a670 <_localeconv_r>
8000723a:	78 0c       	ld.w	r12,r12[0x0]
8000723c:	50 cc       	stdsp	sp[0x30],r12
8000723e:	58 05       	cp.w	r5,0
80007240:	c0 70       	breq	8000724e <_vfprintf_r+0x26>
80007242:	6a 68       	ld.w	r8,r5[0x18]
80007244:	58 08       	cp.w	r8,0
80007246:	c0 41       	brne	8000724e <_vfprintf_r+0x26>
80007248:	0a 9c       	mov	r12,r5
8000724a:	e0 a0 17 43 	rcall	8000a0d0 <__sinit>
8000724e:	fe c8 9e 7a 	sub	r8,pc,-24966
80007252:	10 31       	cp.w	r1,r8
80007254:	c0 31       	brne	8000725a <_vfprintf_r+0x32>
80007256:	6a 01       	ld.w	r1,r5[0x0]
80007258:	c0 c8       	rjmp	80007270 <_vfprintf_r+0x48>
8000725a:	fe c8 9e 66 	sub	r8,pc,-24986
8000725e:	10 31       	cp.w	r1,r8
80007260:	c0 31       	brne	80007266 <_vfprintf_r+0x3e>
80007262:	6a 11       	ld.w	r1,r5[0x4]
80007264:	c0 68       	rjmp	80007270 <_vfprintf_r+0x48>
80007266:	fe c8 9e 52 	sub	r8,pc,-25006
8000726a:	10 31       	cp.w	r1,r8
8000726c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007270:	82 68       	ld.sh	r8,r1[0xc]
80007272:	ed b8 00 03 	bld	r8,0x3
80007276:	c0 41       	brne	8000727e <_vfprintf_r+0x56>
80007278:	62 48       	ld.w	r8,r1[0x10]
8000727a:	58 08       	cp.w	r8,0
8000727c:	c0 71       	brne	8000728a <_vfprintf_r+0x62>
8000727e:	02 9b       	mov	r11,r1
80007280:	0a 9c       	mov	r12,r5
80007282:	e0 a0 0f 5d 	rcall	8000913c <__swsetup_r>
80007286:	e0 81 0f 54 	brne	8000912e <_vfprintf_r+0x1f06>
8000728a:	82 68       	ld.sh	r8,r1[0xc]
8000728c:	10 99       	mov	r9,r8
8000728e:	e2 19 00 1a 	andl	r9,0x1a,COH
80007292:	58 a9       	cp.w	r9,10
80007294:	c3 c1       	brne	8000730c <_vfprintf_r+0xe4>
80007296:	82 79       	ld.sh	r9,r1[0xe]
80007298:	30 0a       	mov	r10,0
8000729a:	f4 09 19 00 	cp.h	r9,r10
8000729e:	c3 75       	brlt	8000730c <_vfprintf_r+0xe4>
800072a0:	a1 d8       	cbr	r8,0x1
800072a2:	fb 58 05 d0 	st.h	sp[1488],r8
800072a6:	62 88       	ld.w	r8,r1[0x20]
800072a8:	fb 48 05 e4 	st.w	sp[1508],r8
800072ac:	62 a8       	ld.w	r8,r1[0x28]
800072ae:	fb 48 05 ec 	st.w	sp[1516],r8
800072b2:	fa c8 ff bc 	sub	r8,sp,-68
800072b6:	fb 48 05 d4 	st.w	sp[1492],r8
800072ba:	fb 48 05 c4 	st.w	sp[1476],r8
800072be:	e0 68 04 00 	mov	r8,1024
800072c2:	fb 48 05 d8 	st.w	sp[1496],r8
800072c6:	fb 48 05 cc 	st.w	sp[1484],r8
800072ca:	30 08       	mov	r8,0
800072cc:	fb 59 05 d2 	st.h	sp[1490],r9
800072d0:	0e 9a       	mov	r10,r7
800072d2:	41 09       	lddsp	r9,sp[0x40]
800072d4:	fa c7 fa 3c 	sub	r7,sp,-1476
800072d8:	fb 48 05 dc 	st.w	sp[1500],r8
800072dc:	0a 9c       	mov	r12,r5
800072de:	0e 9b       	mov	r11,r7
800072e0:	ca 4f       	rcall	80007228 <_vfprintf_r>
800072e2:	50 bc       	stdsp	sp[0x2c],r12
800072e4:	c0 95       	brlt	800072f6 <_vfprintf_r+0xce>
800072e6:	0e 9b       	mov	r11,r7
800072e8:	0a 9c       	mov	r12,r5
800072ea:	e0 a0 16 1b 	rcall	80009f20 <_fflush_r>
800072ee:	40 be       	lddsp	lr,sp[0x2c]
800072f0:	f9 be 01 ff 	movne	lr,-1
800072f4:	50 be       	stdsp	sp[0x2c],lr
800072f6:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800072fa:	ed b8 00 06 	bld	r8,0x6
800072fe:	e0 81 0f 1a 	brne	80009132 <_vfprintf_r+0x1f0a>
80007302:	82 68       	ld.sh	r8,r1[0xc]
80007304:	a7 a8       	sbr	r8,0x6
80007306:	a2 68       	st.h	r1[0xc],r8
80007308:	e0 8f 0f 15 	bral	80009132 <_vfprintf_r+0x1f0a>
8000730c:	30 08       	mov	r8,0
8000730e:	fb 48 06 b4 	st.w	sp[1716],r8
80007312:	fb 48 06 90 	st.w	sp[1680],r8
80007316:	fb 48 06 8c 	st.w	sp[1676],r8
8000731a:	fb 48 06 b0 	st.w	sp[1712],r8
8000731e:	30 08       	mov	r8,0
80007320:	30 09       	mov	r9,0
80007322:	50 a7       	stdsp	sp[0x28],r7
80007324:	50 78       	stdsp	sp[0x1c],r8
80007326:	fa c3 f9 e0 	sub	r3,sp,-1568
8000732a:	3f f8       	mov	r8,-1
8000732c:	50 59       	stdsp	sp[0x14],r9
8000732e:	fb 43 06 88 	st.w	sp[1672],r3
80007332:	fb 48 05 44 	st.w	sp[1348],r8
80007336:	12 9c       	mov	r12,r9
80007338:	50 69       	stdsp	sp[0x18],r9
8000733a:	50 d9       	stdsp	sp[0x34],r9
8000733c:	50 e9       	stdsp	sp[0x38],r9
8000733e:	50 b9       	stdsp	sp[0x2c],r9
80007340:	12 97       	mov	r7,r9
80007342:	0a 94       	mov	r4,r5
80007344:	40 a2       	lddsp	r2,sp[0x28]
80007346:	32 5a       	mov	r10,37
80007348:	30 08       	mov	r8,0
8000734a:	c0 28       	rjmp	8000734e <_vfprintf_r+0x126>
8000734c:	2f f2       	sub	r2,-1
8000734e:	05 89       	ld.ub	r9,r2[0x0]
80007350:	f0 09 18 00 	cp.b	r9,r8
80007354:	5f 1b       	srne	r11
80007356:	f4 09 18 00 	cp.b	r9,r10
8000735a:	5f 19       	srne	r9
8000735c:	f3 eb 00 0b 	and	r11,r9,r11
80007360:	f0 0b 18 00 	cp.b	r11,r8
80007364:	cf 41       	brne	8000734c <_vfprintf_r+0x124>
80007366:	40 ab       	lddsp	r11,sp[0x28]
80007368:	e4 0b 01 06 	sub	r6,r2,r11
8000736c:	c1 e0       	breq	800073a8 <_vfprintf_r+0x180>
8000736e:	fa f8 06 90 	ld.w	r8,sp[1680]
80007372:	0c 08       	add	r8,r6
80007374:	87 0b       	st.w	r3[0x0],r11
80007376:	fb 48 06 90 	st.w	sp[1680],r8
8000737a:	87 16       	st.w	r3[0x4],r6
8000737c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007380:	2f f8       	sub	r8,-1
80007382:	fb 48 06 8c 	st.w	sp[1676],r8
80007386:	58 78       	cp.w	r8,7
80007388:	e0 89 00 04 	brgt	80007390 <_vfprintf_r+0x168>
8000738c:	2f 83       	sub	r3,-8
8000738e:	c0 a8       	rjmp	800073a2 <_vfprintf_r+0x17a>
80007390:	fa ca f9 78 	sub	r10,sp,-1672
80007394:	02 9b       	mov	r11,r1
80007396:	08 9c       	mov	r12,r4
80007398:	c3 af       	rcall	8000720c <__sprint_r>
8000739a:	e0 81 0e c6 	brne	80009126 <_vfprintf_r+0x1efe>
8000739e:	fa c3 f9 e0 	sub	r3,sp,-1568
800073a2:	40 ba       	lddsp	r10,sp[0x2c]
800073a4:	0c 0a       	add	r10,r6
800073a6:	50 ba       	stdsp	sp[0x2c],r10
800073a8:	05 89       	ld.ub	r9,r2[0x0]
800073aa:	30 08       	mov	r8,0
800073ac:	f0 09 18 00 	cp.b	r9,r8
800073b0:	e0 80 0e aa 	breq	80009104 <_vfprintf_r+0x1edc>
800073b4:	30 09       	mov	r9,0
800073b6:	fb 68 06 bb 	st.b	sp[1723],r8
800073ba:	0e 96       	mov	r6,r7
800073bc:	e4 c8 ff ff 	sub	r8,r2,-1
800073c0:	3f fe       	mov	lr,-1
800073c2:	50 93       	stdsp	sp[0x24],r3
800073c4:	50 41       	stdsp	sp[0x10],r1
800073c6:	0e 93       	mov	r3,r7
800073c8:	04 91       	mov	r1,r2
800073ca:	50 89       	stdsp	sp[0x20],r9
800073cc:	50 a8       	stdsp	sp[0x28],r8
800073ce:	50 2e       	stdsp	sp[0x8],lr
800073d0:	50 39       	stdsp	sp[0xc],r9
800073d2:	12 95       	mov	r5,r9
800073d4:	12 90       	mov	r0,r9
800073d6:	10 97       	mov	r7,r8
800073d8:	08 92       	mov	r2,r4
800073da:	c0 78       	rjmp	800073e8 <_vfprintf_r+0x1c0>
800073dc:	3f fc       	mov	r12,-1
800073de:	08 97       	mov	r7,r4
800073e0:	50 2c       	stdsp	sp[0x8],r12
800073e2:	c0 38       	rjmp	800073e8 <_vfprintf_r+0x1c0>
800073e4:	30 0b       	mov	r11,0
800073e6:	50 3b       	stdsp	sp[0xc],r11
800073e8:	0f 38       	ld.ub	r8,r7++
800073ea:	c0 28       	rjmp	800073ee <_vfprintf_r+0x1c6>
800073ec:	12 90       	mov	r0,r9
800073ee:	f0 c9 00 20 	sub	r9,r8,32
800073f2:	e0 49 00 58 	cp.w	r9,88
800073f6:	e0 8b 0a 30 	brhi	80008856 <_vfprintf_r+0x162e>
800073fa:	fe ca a3 ce 	sub	r10,pc,-23602
800073fe:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007402:	50 a7       	stdsp	sp[0x28],r7
80007404:	50 80       	stdsp	sp[0x20],r0
80007406:	0c 97       	mov	r7,r6
80007408:	04 94       	mov	r4,r2
8000740a:	06 96       	mov	r6,r3
8000740c:	02 92       	mov	r2,r1
8000740e:	fe c9 a1 a6 	sub	r9,pc,-24154
80007412:	40 93       	lddsp	r3,sp[0x24]
80007414:	10 90       	mov	r0,r8
80007416:	40 41       	lddsp	r1,sp[0x10]
80007418:	50 d9       	stdsp	sp[0x34],r9
8000741a:	e0 8f 08 8e 	bral	80008536 <_vfprintf_r+0x130e>
8000741e:	30 08       	mov	r8,0
80007420:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007424:	f0 09 18 00 	cp.b	r9,r8
80007428:	ce 01       	brne	800073e8 <_vfprintf_r+0x1c0>
8000742a:	32 08       	mov	r8,32
8000742c:	c6 e8       	rjmp	80007508 <_vfprintf_r+0x2e0>
8000742e:	a1 a5       	sbr	r5,0x0
80007430:	cd cb       	rjmp	800073e8 <_vfprintf_r+0x1c0>
80007432:	0f 89       	ld.ub	r9,r7[0x0]
80007434:	f2 c8 00 30 	sub	r8,r9,48
80007438:	58 98       	cp.w	r8,9
8000743a:	e0 8b 00 1d 	brhi	80007474 <_vfprintf_r+0x24c>
8000743e:	ee c8 ff ff 	sub	r8,r7,-1
80007442:	30 0b       	mov	r11,0
80007444:	23 09       	sub	r9,48
80007446:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000744a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000744e:	11 39       	ld.ub	r9,r8++
80007450:	f2 ca 00 30 	sub	r10,r9,48
80007454:	58 9a       	cp.w	r10,9
80007456:	fe 98 ff f7 	brls	80007444 <_vfprintf_r+0x21c>
8000745a:	e0 49 00 24 	cp.w	r9,36
8000745e:	cc 31       	brne	800073e4 <_vfprintf_r+0x1bc>
80007460:	e0 4b 00 20 	cp.w	r11,32
80007464:	e0 89 0e 60 	brgt	80009124 <_vfprintf_r+0x1efc>
80007468:	20 1b       	sub	r11,1
8000746a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000746e:	12 3b       	cp.w	r11,r9
80007470:	c0 95       	brlt	80007482 <_vfprintf_r+0x25a>
80007472:	c1 08       	rjmp	80007492 <_vfprintf_r+0x26a>
80007474:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007478:	ec ca ff ff 	sub	r10,r6,-1
8000747c:	12 36       	cp.w	r6,r9
8000747e:	c1 f5       	brlt	800074bc <_vfprintf_r+0x294>
80007480:	c2 68       	rjmp	800074cc <_vfprintf_r+0x2a4>
80007482:	fa ce f9 44 	sub	lr,sp,-1724
80007486:	10 97       	mov	r7,r8
80007488:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000748c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007490:	c3 58       	rjmp	800074fa <_vfprintf_r+0x2d2>
80007492:	10 97       	mov	r7,r8
80007494:	fa c8 f9 50 	sub	r8,sp,-1712
80007498:	1a d8       	st.w	--sp,r8
8000749a:	fa c8 fa b8 	sub	r8,sp,-1352
8000749e:	1a d8       	st.w	--sp,r8
800074a0:	fa c8 fb b4 	sub	r8,sp,-1100
800074a4:	02 9a       	mov	r10,r1
800074a6:	1a d8       	st.w	--sp,r8
800074a8:	04 9c       	mov	r12,r2
800074aa:	fa c8 f9 40 	sub	r8,sp,-1728
800074ae:	fa c9 ff b4 	sub	r9,sp,-76
800074b2:	fe b0 fd 23 	rcall	80006ef8 <get_arg>
800074b6:	2f dd       	sub	sp,-12
800074b8:	78 00       	ld.w	r0,r12[0x0]
800074ba:	c2 08       	rjmp	800074fa <_vfprintf_r+0x2d2>
800074bc:	fa cc f9 44 	sub	r12,sp,-1724
800074c0:	14 96       	mov	r6,r10
800074c2:	f8 03 00 38 	add	r8,r12,r3<<0x3
800074c6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800074ca:	c1 88       	rjmp	800074fa <_vfprintf_r+0x2d2>
800074cc:	41 08       	lddsp	r8,sp[0x40]
800074ce:	59 f9       	cp.w	r9,31
800074d0:	e0 89 00 11 	brgt	800074f2 <_vfprintf_r+0x2ca>
800074d4:	f0 cb ff fc 	sub	r11,r8,-4
800074d8:	51 0b       	stdsp	sp[0x40],r11
800074da:	70 00       	ld.w	r0,r8[0x0]
800074dc:	fa cb f9 44 	sub	r11,sp,-1724
800074e0:	f6 09 00 38 	add	r8,r11,r9<<0x3
800074e4:	f1 40 fd 88 	st.w	r8[-632],r0
800074e8:	2f f9       	sub	r9,-1
800074ea:	14 96       	mov	r6,r10
800074ec:	fb 49 06 b4 	st.w	sp[1716],r9
800074f0:	c0 58       	rjmp	800074fa <_vfprintf_r+0x2d2>
800074f2:	70 00       	ld.w	r0,r8[0x0]
800074f4:	14 96       	mov	r6,r10
800074f6:	2f c8       	sub	r8,-4
800074f8:	51 08       	stdsp	sp[0x40],r8
800074fa:	58 00       	cp.w	r0,0
800074fc:	fe 94 ff 76 	brge	800073e8 <_vfprintf_r+0x1c0>
80007500:	5c 30       	neg	r0
80007502:	a3 a5       	sbr	r5,0x2
80007504:	c7 2b       	rjmp	800073e8 <_vfprintf_r+0x1c0>
80007506:	32 b8       	mov	r8,43
80007508:	fb 68 06 bb 	st.b	sp[1723],r8
8000750c:	c6 eb       	rjmp	800073e8 <_vfprintf_r+0x1c0>
8000750e:	0f 38       	ld.ub	r8,r7++
80007510:	e0 48 00 2a 	cp.w	r8,42
80007514:	c0 30       	breq	8000751a <_vfprintf_r+0x2f2>
80007516:	30 09       	mov	r9,0
80007518:	c7 98       	rjmp	8000760a <_vfprintf_r+0x3e2>
8000751a:	0f 88       	ld.ub	r8,r7[0x0]
8000751c:	f0 c9 00 30 	sub	r9,r8,48
80007520:	58 99       	cp.w	r9,9
80007522:	e0 8b 00 1f 	brhi	80007560 <_vfprintf_r+0x338>
80007526:	ee c4 ff ff 	sub	r4,r7,-1
8000752a:	30 0b       	mov	r11,0
8000752c:	23 08       	sub	r8,48
8000752e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007532:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007536:	09 38       	ld.ub	r8,r4++
80007538:	f0 c9 00 30 	sub	r9,r8,48
8000753c:	58 99       	cp.w	r9,9
8000753e:	fe 98 ff f7 	brls	8000752c <_vfprintf_r+0x304>
80007542:	e0 48 00 24 	cp.w	r8,36
80007546:	fe 91 ff 4f 	brne	800073e4 <_vfprintf_r+0x1bc>
8000754a:	e0 4b 00 20 	cp.w	r11,32
8000754e:	e0 89 0d eb 	brgt	80009124 <_vfprintf_r+0x1efc>
80007552:	20 1b       	sub	r11,1
80007554:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007558:	10 3b       	cp.w	r11,r8
8000755a:	c0 a5       	brlt	8000756e <_vfprintf_r+0x346>
8000755c:	c1 18       	rjmp	8000757e <_vfprintf_r+0x356>
8000755e:	d7 03       	nop
80007560:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007564:	ec c9 ff ff 	sub	r9,r6,-1
80007568:	14 36       	cp.w	r6,r10
8000756a:	c1 f5       	brlt	800075a8 <_vfprintf_r+0x380>
8000756c:	c2 88       	rjmp	800075bc <_vfprintf_r+0x394>
8000756e:	fa ca f9 44 	sub	r10,sp,-1724
80007572:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007576:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000757a:	50 2b       	stdsp	sp[0x8],r11
8000757c:	c3 c8       	rjmp	800075f4 <_vfprintf_r+0x3cc>
8000757e:	fa c8 f9 50 	sub	r8,sp,-1712
80007582:	1a d8       	st.w	--sp,r8
80007584:	fa c8 fa b8 	sub	r8,sp,-1352
80007588:	1a d8       	st.w	--sp,r8
8000758a:	fa c8 fb b4 	sub	r8,sp,-1100
8000758e:	02 9a       	mov	r10,r1
80007590:	1a d8       	st.w	--sp,r8
80007592:	04 9c       	mov	r12,r2
80007594:	fa c8 f9 40 	sub	r8,sp,-1728
80007598:	fa c9 ff b4 	sub	r9,sp,-76
8000759c:	fe b0 fc ae 	rcall	80006ef8 <get_arg>
800075a0:	2f dd       	sub	sp,-12
800075a2:	78 0c       	ld.w	r12,r12[0x0]
800075a4:	50 2c       	stdsp	sp[0x8],r12
800075a6:	c2 78       	rjmp	800075f4 <_vfprintf_r+0x3cc>
800075a8:	12 96       	mov	r6,r9
800075aa:	0e 94       	mov	r4,r7
800075ac:	fa c9 f9 44 	sub	r9,sp,-1724
800075b0:	f2 03 00 38 	add	r8,r9,r3<<0x3
800075b4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800075b8:	50 28       	stdsp	sp[0x8],r8
800075ba:	c1 d8       	rjmp	800075f4 <_vfprintf_r+0x3cc>
800075bc:	41 08       	lddsp	r8,sp[0x40]
800075be:	59 fa       	cp.w	r10,31
800075c0:	e0 89 00 14 	brgt	800075e8 <_vfprintf_r+0x3c0>
800075c4:	f0 cb ff fc 	sub	r11,r8,-4
800075c8:	70 08       	ld.w	r8,r8[0x0]
800075ca:	51 0b       	stdsp	sp[0x40],r11
800075cc:	50 28       	stdsp	sp[0x8],r8
800075ce:	fa c6 f9 44 	sub	r6,sp,-1724
800075d2:	40 2e       	lddsp	lr,sp[0x8]
800075d4:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800075d8:	f1 4e fd 88 	st.w	r8[-632],lr
800075dc:	2f fa       	sub	r10,-1
800075de:	0e 94       	mov	r4,r7
800075e0:	fb 4a 06 b4 	st.w	sp[1716],r10
800075e4:	12 96       	mov	r6,r9
800075e6:	c0 78       	rjmp	800075f4 <_vfprintf_r+0x3cc>
800075e8:	70 0c       	ld.w	r12,r8[0x0]
800075ea:	0e 94       	mov	r4,r7
800075ec:	2f c8       	sub	r8,-4
800075ee:	50 2c       	stdsp	sp[0x8],r12
800075f0:	12 96       	mov	r6,r9
800075f2:	51 08       	stdsp	sp[0x40],r8
800075f4:	40 2b       	lddsp	r11,sp[0x8]
800075f6:	58 0b       	cp.w	r11,0
800075f8:	fe 95 fe f2 	brlt	800073dc <_vfprintf_r+0x1b4>
800075fc:	08 97       	mov	r7,r4
800075fe:	cf 5a       	rjmp	800073e8 <_vfprintf_r+0x1c0>
80007600:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007604:	0f 38       	ld.ub	r8,r7++
80007606:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000760a:	f0 ca 00 30 	sub	r10,r8,48
8000760e:	58 9a       	cp.w	r10,9
80007610:	fe 98 ff f8 	brls	80007600 <_vfprintf_r+0x3d8>
80007614:	3f fa       	mov	r10,-1
80007616:	f2 0a 0c 49 	max	r9,r9,r10
8000761a:	50 29       	stdsp	sp[0x8],r9
8000761c:	ce 9a       	rjmp	800073ee <_vfprintf_r+0x1c6>
8000761e:	a7 b5       	sbr	r5,0x7
80007620:	ce 4a       	rjmp	800073e8 <_vfprintf_r+0x1c0>
80007622:	30 09       	mov	r9,0
80007624:	23 08       	sub	r8,48
80007626:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000762a:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000762e:	0f 38       	ld.ub	r8,r7++
80007630:	f0 ca 00 30 	sub	r10,r8,48
80007634:	58 9a       	cp.w	r10,9
80007636:	fe 98 ff f7 	brls	80007624 <_vfprintf_r+0x3fc>
8000763a:	e0 48 00 24 	cp.w	r8,36
8000763e:	fe 91 fe d7 	brne	800073ec <_vfprintf_r+0x1c4>
80007642:	e0 49 00 20 	cp.w	r9,32
80007646:	e0 89 0d 6f 	brgt	80009124 <_vfprintf_r+0x1efc>
8000764a:	f2 c3 00 01 	sub	r3,r9,1
8000764e:	30 19       	mov	r9,1
80007650:	50 39       	stdsp	sp[0xc],r9
80007652:	cc ba       	rjmp	800073e8 <_vfprintf_r+0x1c0>
80007654:	a3 b5       	sbr	r5,0x3
80007656:	cc 9a       	rjmp	800073e8 <_vfprintf_r+0x1c0>
80007658:	a7 a5       	sbr	r5,0x6
8000765a:	cc 7a       	rjmp	800073e8 <_vfprintf_r+0x1c0>
8000765c:	0a 98       	mov	r8,r5
8000765e:	a5 b5       	sbr	r5,0x5
80007660:	a5 a8       	sbr	r8,0x4
80007662:	0f 89       	ld.ub	r9,r7[0x0]
80007664:	36 ce       	mov	lr,108
80007666:	fc 09 18 00 	cp.b	r9,lr
8000766a:	f7 b7 00 ff 	subeq	r7,-1
8000766e:	f0 05 17 10 	movne	r5,r8
80007672:	cb ba       	rjmp	800073e8 <_vfprintf_r+0x1c0>
80007674:	a5 b5       	sbr	r5,0x5
80007676:	cb 9a       	rjmp	800073e8 <_vfprintf_r+0x1c0>
80007678:	50 a7       	stdsp	sp[0x28],r7
8000767a:	50 80       	stdsp	sp[0x20],r0
8000767c:	0c 97       	mov	r7,r6
8000767e:	10 90       	mov	r0,r8
80007680:	06 96       	mov	r6,r3
80007682:	04 94       	mov	r4,r2
80007684:	40 93       	lddsp	r3,sp[0x24]
80007686:	02 92       	mov	r2,r1
80007688:	0e 99       	mov	r9,r7
8000768a:	40 41       	lddsp	r1,sp[0x10]
8000768c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007690:	40 3c       	lddsp	r12,sp[0xc]
80007692:	58 0c       	cp.w	r12,0
80007694:	c1 d0       	breq	800076ce <_vfprintf_r+0x4a6>
80007696:	10 36       	cp.w	r6,r8
80007698:	c0 64       	brge	800076a4 <_vfprintf_r+0x47c>
8000769a:	fa cb f9 44 	sub	r11,sp,-1724
8000769e:	f6 06 00 36 	add	r6,r11,r6<<0x3
800076a2:	c1 d8       	rjmp	800076dc <_vfprintf_r+0x4b4>
800076a4:	fa c8 f9 50 	sub	r8,sp,-1712
800076a8:	1a d8       	st.w	--sp,r8
800076aa:	fa c8 fa b8 	sub	r8,sp,-1352
800076ae:	1a d8       	st.w	--sp,r8
800076b0:	fa c8 fb b4 	sub	r8,sp,-1100
800076b4:	1a d8       	st.w	--sp,r8
800076b6:	fa c8 f9 40 	sub	r8,sp,-1728
800076ba:	fa c9 ff b4 	sub	r9,sp,-76
800076be:	04 9a       	mov	r10,r2
800076c0:	0c 9b       	mov	r11,r6
800076c2:	08 9c       	mov	r12,r4
800076c4:	fe b0 fc 1a 	rcall	80006ef8 <get_arg>
800076c8:	2f dd       	sub	sp,-12
800076ca:	19 b8       	ld.ub	r8,r12[0x3]
800076cc:	c2 28       	rjmp	80007710 <_vfprintf_r+0x4e8>
800076ce:	2f f7       	sub	r7,-1
800076d0:	10 39       	cp.w	r9,r8
800076d2:	c0 84       	brge	800076e2 <_vfprintf_r+0x4ba>
800076d4:	fa ca f9 44 	sub	r10,sp,-1724
800076d8:	f4 06 00 36 	add	r6,r10,r6<<0x3
800076dc:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800076e0:	c1 88       	rjmp	80007710 <_vfprintf_r+0x4e8>
800076e2:	41 09       	lddsp	r9,sp[0x40]
800076e4:	59 f8       	cp.w	r8,31
800076e6:	e0 89 00 12 	brgt	8000770a <_vfprintf_r+0x4e2>
800076ea:	f2 ca ff fc 	sub	r10,r9,-4
800076ee:	51 0a       	stdsp	sp[0x40],r10
800076f0:	72 09       	ld.w	r9,r9[0x0]
800076f2:	fa c6 f9 44 	sub	r6,sp,-1724
800076f6:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800076fa:	2f f8       	sub	r8,-1
800076fc:	f5 49 fd 88 	st.w	r10[-632],r9
80007700:	fb 48 06 b4 	st.w	sp[1716],r8
80007704:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007708:	c0 48       	rjmp	80007710 <_vfprintf_r+0x4e8>
8000770a:	13 b8       	ld.ub	r8,r9[0x3]
8000770c:	2f c9       	sub	r9,-4
8000770e:	51 09       	stdsp	sp[0x40],r9
80007710:	fb 68 06 60 	st.b	sp[1632],r8
80007714:	30 0e       	mov	lr,0
80007716:	30 08       	mov	r8,0
80007718:	30 12       	mov	r2,1
8000771a:	fb 68 06 bb 	st.b	sp[1723],r8
8000771e:	50 2e       	stdsp	sp[0x8],lr
80007720:	e0 8f 08 ad 	bral	8000887a <_vfprintf_r+0x1652>
80007724:	50 a7       	stdsp	sp[0x28],r7
80007726:	50 80       	stdsp	sp[0x20],r0
80007728:	0c 97       	mov	r7,r6
8000772a:	04 94       	mov	r4,r2
8000772c:	06 96       	mov	r6,r3
8000772e:	02 92       	mov	r2,r1
80007730:	40 93       	lddsp	r3,sp[0x24]
80007732:	10 90       	mov	r0,r8
80007734:	40 41       	lddsp	r1,sp[0x10]
80007736:	a5 a5       	sbr	r5,0x4
80007738:	c0 a8       	rjmp	8000774c <_vfprintf_r+0x524>
8000773a:	50 a7       	stdsp	sp[0x28],r7
8000773c:	50 80       	stdsp	sp[0x20],r0
8000773e:	0c 97       	mov	r7,r6
80007740:	04 94       	mov	r4,r2
80007742:	06 96       	mov	r6,r3
80007744:	02 92       	mov	r2,r1
80007746:	40 93       	lddsp	r3,sp[0x24]
80007748:	10 90       	mov	r0,r8
8000774a:	40 41       	lddsp	r1,sp[0x10]
8000774c:	ed b5 00 05 	bld	r5,0x5
80007750:	c5 11       	brne	800077f2 <_vfprintf_r+0x5ca>
80007752:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007756:	40 3c       	lddsp	r12,sp[0xc]
80007758:	58 0c       	cp.w	r12,0
8000775a:	c1 e0       	breq	80007796 <_vfprintf_r+0x56e>
8000775c:	10 36       	cp.w	r6,r8
8000775e:	c0 64       	brge	8000776a <_vfprintf_r+0x542>
80007760:	fa cb f9 44 	sub	r11,sp,-1724
80007764:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007768:	c2 08       	rjmp	800077a8 <_vfprintf_r+0x580>
8000776a:	fa c8 f9 50 	sub	r8,sp,-1712
8000776e:	1a d8       	st.w	--sp,r8
80007770:	fa c8 fa b8 	sub	r8,sp,-1352
80007774:	0c 9b       	mov	r11,r6
80007776:	1a d8       	st.w	--sp,r8
80007778:	fa c8 fb b4 	sub	r8,sp,-1100
8000777c:	1a d8       	st.w	--sp,r8
8000777e:	fa c9 ff b4 	sub	r9,sp,-76
80007782:	fa c8 f9 40 	sub	r8,sp,-1728
80007786:	04 9a       	mov	r10,r2
80007788:	08 9c       	mov	r12,r4
8000778a:	fe b0 fb b7 	rcall	80006ef8 <get_arg>
8000778e:	2f dd       	sub	sp,-12
80007790:	78 1b       	ld.w	r11,r12[0x4]
80007792:	78 09       	ld.w	r9,r12[0x0]
80007794:	c2 b8       	rjmp	800077ea <_vfprintf_r+0x5c2>
80007796:	ee ca ff ff 	sub	r10,r7,-1
8000779a:	10 37       	cp.w	r7,r8
8000779c:	c0 b4       	brge	800077b2 <_vfprintf_r+0x58a>
8000779e:	fa c9 f9 44 	sub	r9,sp,-1724
800077a2:	14 97       	mov	r7,r10
800077a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800077a8:	ec fb fd 8c 	ld.w	r11,r6[-628]
800077ac:	ec f9 fd 88 	ld.w	r9,r6[-632]
800077b0:	c1 d8       	rjmp	800077ea <_vfprintf_r+0x5c2>
800077b2:	41 09       	lddsp	r9,sp[0x40]
800077b4:	59 f8       	cp.w	r8,31
800077b6:	e0 89 00 14 	brgt	800077de <_vfprintf_r+0x5b6>
800077ba:	f2 cb ff f8 	sub	r11,r9,-8
800077be:	51 0b       	stdsp	sp[0x40],r11
800077c0:	fa c6 f9 44 	sub	r6,sp,-1724
800077c4:	72 1b       	ld.w	r11,r9[0x4]
800077c6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800077ca:	72 09       	ld.w	r9,r9[0x0]
800077cc:	f9 4b fd 8c 	st.w	r12[-628],r11
800077d0:	f9 49 fd 88 	st.w	r12[-632],r9
800077d4:	2f f8       	sub	r8,-1
800077d6:	14 97       	mov	r7,r10
800077d8:	fb 48 06 b4 	st.w	sp[1716],r8
800077dc:	c0 78       	rjmp	800077ea <_vfprintf_r+0x5c2>
800077de:	f2 c8 ff f8 	sub	r8,r9,-8
800077e2:	72 1b       	ld.w	r11,r9[0x4]
800077e4:	14 97       	mov	r7,r10
800077e6:	51 08       	stdsp	sp[0x40],r8
800077e8:	72 09       	ld.w	r9,r9[0x0]
800077ea:	16 98       	mov	r8,r11
800077ec:	fa e9 00 00 	st.d	sp[0],r8
800077f0:	ca e8       	rjmp	8000794c <_vfprintf_r+0x724>
800077f2:	ed b5 00 04 	bld	r5,0x4
800077f6:	c1 71       	brne	80007824 <_vfprintf_r+0x5fc>
800077f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077fc:	40 3e       	lddsp	lr,sp[0xc]
800077fe:	58 0e       	cp.w	lr,0
80007800:	c0 80       	breq	80007810 <_vfprintf_r+0x5e8>
80007802:	10 36       	cp.w	r6,r8
80007804:	c6 94       	brge	800078d6 <_vfprintf_r+0x6ae>
80007806:	fa cc f9 44 	sub	r12,sp,-1724
8000780a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000780e:	c8 28       	rjmp	80007912 <_vfprintf_r+0x6ea>
80007810:	ee ca ff ff 	sub	r10,r7,-1
80007814:	10 37       	cp.w	r7,r8
80007816:	e0 84 00 81 	brge	80007918 <_vfprintf_r+0x6f0>
8000781a:	fa cb f9 44 	sub	r11,sp,-1724
8000781e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007822:	c7 78       	rjmp	80007910 <_vfprintf_r+0x6e8>
80007824:	ed b5 00 06 	bld	r5,0x6
80007828:	c4 b1       	brne	800078be <_vfprintf_r+0x696>
8000782a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000782e:	40 3c       	lddsp	r12,sp[0xc]
80007830:	58 0c       	cp.w	r12,0
80007832:	c1 d0       	breq	8000786c <_vfprintf_r+0x644>
80007834:	10 36       	cp.w	r6,r8
80007836:	c0 64       	brge	80007842 <_vfprintf_r+0x61a>
80007838:	fa cb f9 44 	sub	r11,sp,-1724
8000783c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007840:	c1 f8       	rjmp	8000787e <_vfprintf_r+0x656>
80007842:	fa c8 f9 50 	sub	r8,sp,-1712
80007846:	1a d8       	st.w	--sp,r8
80007848:	fa c8 fa b8 	sub	r8,sp,-1352
8000784c:	1a d8       	st.w	--sp,r8
8000784e:	fa c8 fb b4 	sub	r8,sp,-1100
80007852:	1a d8       	st.w	--sp,r8
80007854:	fa c8 f9 40 	sub	r8,sp,-1728
80007858:	fa c9 ff b4 	sub	r9,sp,-76
8000785c:	04 9a       	mov	r10,r2
8000785e:	0c 9b       	mov	r11,r6
80007860:	08 9c       	mov	r12,r4
80007862:	fe b0 fb 4b 	rcall	80006ef8 <get_arg>
80007866:	2f dd       	sub	sp,-12
80007868:	98 18       	ld.sh	r8,r12[0x2]
8000786a:	c2 68       	rjmp	800078b6 <_vfprintf_r+0x68e>
8000786c:	ee ca ff ff 	sub	r10,r7,-1
80007870:	10 37       	cp.w	r7,r8
80007872:	c0 94       	brge	80007884 <_vfprintf_r+0x65c>
80007874:	fa c9 f9 44 	sub	r9,sp,-1724
80007878:	14 97       	mov	r7,r10
8000787a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000787e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007882:	c1 a8       	rjmp	800078b6 <_vfprintf_r+0x68e>
80007884:	41 09       	lddsp	r9,sp[0x40]
80007886:	59 f8       	cp.w	r8,31
80007888:	e0 89 00 13 	brgt	800078ae <_vfprintf_r+0x686>
8000788c:	f2 cb ff fc 	sub	r11,r9,-4
80007890:	51 0b       	stdsp	sp[0x40],r11
80007892:	72 09       	ld.w	r9,r9[0x0]
80007894:	fa c6 f9 44 	sub	r6,sp,-1724
80007898:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000789c:	2f f8       	sub	r8,-1
8000789e:	f7 49 fd 88 	st.w	r11[-632],r9
800078a2:	fb 48 06 b4 	st.w	sp[1716],r8
800078a6:	14 97       	mov	r7,r10
800078a8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800078ac:	c0 58       	rjmp	800078b6 <_vfprintf_r+0x68e>
800078ae:	92 18       	ld.sh	r8,r9[0x2]
800078b0:	14 97       	mov	r7,r10
800078b2:	2f c9       	sub	r9,-4
800078b4:	51 09       	stdsp	sp[0x40],r9
800078b6:	50 18       	stdsp	sp[0x4],r8
800078b8:	bf 58       	asr	r8,0x1f
800078ba:	50 08       	stdsp	sp[0x0],r8
800078bc:	c4 88       	rjmp	8000794c <_vfprintf_r+0x724>
800078be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078c2:	40 3c       	lddsp	r12,sp[0xc]
800078c4:	58 0c       	cp.w	r12,0
800078c6:	c1 d0       	breq	80007900 <_vfprintf_r+0x6d8>
800078c8:	10 36       	cp.w	r6,r8
800078ca:	c0 64       	brge	800078d6 <_vfprintf_r+0x6ae>
800078cc:	fa cb f9 44 	sub	r11,sp,-1724
800078d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078d4:	c1 f8       	rjmp	80007912 <_vfprintf_r+0x6ea>
800078d6:	fa c8 f9 50 	sub	r8,sp,-1712
800078da:	1a d8       	st.w	--sp,r8
800078dc:	fa c8 fa b8 	sub	r8,sp,-1352
800078e0:	0c 9b       	mov	r11,r6
800078e2:	1a d8       	st.w	--sp,r8
800078e4:	fa c8 fb b4 	sub	r8,sp,-1100
800078e8:	04 9a       	mov	r10,r2
800078ea:	1a d8       	st.w	--sp,r8
800078ec:	08 9c       	mov	r12,r4
800078ee:	fa c8 f9 40 	sub	r8,sp,-1728
800078f2:	fa c9 ff b4 	sub	r9,sp,-76
800078f6:	fe b0 fb 01 	rcall	80006ef8 <get_arg>
800078fa:	2f dd       	sub	sp,-12
800078fc:	78 0b       	ld.w	r11,r12[0x0]
800078fe:	c2 48       	rjmp	80007946 <_vfprintf_r+0x71e>
80007900:	ee ca ff ff 	sub	r10,r7,-1
80007904:	10 37       	cp.w	r7,r8
80007906:	c0 94       	brge	80007918 <_vfprintf_r+0x6f0>
80007908:	fa c9 f9 44 	sub	r9,sp,-1724
8000790c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007910:	14 97       	mov	r7,r10
80007912:	ec fb fd 88 	ld.w	r11,r6[-632]
80007916:	c1 88       	rjmp	80007946 <_vfprintf_r+0x71e>
80007918:	41 09       	lddsp	r9,sp[0x40]
8000791a:	59 f8       	cp.w	r8,31
8000791c:	e0 89 00 11 	brgt	8000793e <_vfprintf_r+0x716>
80007920:	f2 cb ff fc 	sub	r11,r9,-4
80007924:	51 0b       	stdsp	sp[0x40],r11
80007926:	fa c6 f9 44 	sub	r6,sp,-1724
8000792a:	72 0b       	ld.w	r11,r9[0x0]
8000792c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007930:	f3 4b fd 88 	st.w	r9[-632],r11
80007934:	2f f8       	sub	r8,-1
80007936:	14 97       	mov	r7,r10
80007938:	fb 48 06 b4 	st.w	sp[1716],r8
8000793c:	c0 58       	rjmp	80007946 <_vfprintf_r+0x71e>
8000793e:	72 0b       	ld.w	r11,r9[0x0]
80007940:	14 97       	mov	r7,r10
80007942:	2f c9       	sub	r9,-4
80007944:	51 09       	stdsp	sp[0x40],r9
80007946:	50 1b       	stdsp	sp[0x4],r11
80007948:	bf 5b       	asr	r11,0x1f
8000794a:	50 0b       	stdsp	sp[0x0],r11
8000794c:	fa ea 00 00 	ld.d	r10,sp[0]
80007950:	58 0a       	cp.w	r10,0
80007952:	5c 2b       	cpc	r11
80007954:	c0 e4       	brge	80007970 <_vfprintf_r+0x748>
80007956:	30 08       	mov	r8,0
80007958:	fa ea 00 00 	ld.d	r10,sp[0]
8000795c:	30 09       	mov	r9,0
8000795e:	f0 0a 01 0a 	sub	r10,r8,r10
80007962:	f2 0b 01 4b 	sbc	r11,r9,r11
80007966:	32 d8       	mov	r8,45
80007968:	fa eb 00 00 	st.d	sp[0],r10
8000796c:	fb 68 06 bb 	st.b	sp[1723],r8
80007970:	30 18       	mov	r8,1
80007972:	e0 8f 06 fa 	bral	80008766 <_vfprintf_r+0x153e>
80007976:	50 a7       	stdsp	sp[0x28],r7
80007978:	50 80       	stdsp	sp[0x20],r0
8000797a:	0c 97       	mov	r7,r6
8000797c:	04 94       	mov	r4,r2
8000797e:	06 96       	mov	r6,r3
80007980:	02 92       	mov	r2,r1
80007982:	40 93       	lddsp	r3,sp[0x24]
80007984:	10 90       	mov	r0,r8
80007986:	40 41       	lddsp	r1,sp[0x10]
80007988:	0e 99       	mov	r9,r7
8000798a:	ed b5 00 03 	bld	r5,0x3
8000798e:	c4 11       	brne	80007a10 <_vfprintf_r+0x7e8>
80007990:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007994:	40 3a       	lddsp	r10,sp[0xc]
80007996:	58 0a       	cp.w	r10,0
80007998:	c1 90       	breq	800079ca <_vfprintf_r+0x7a2>
8000799a:	10 36       	cp.w	r6,r8
8000799c:	c6 45       	brlt	80007a64 <_vfprintf_r+0x83c>
8000799e:	fa c8 f9 50 	sub	r8,sp,-1712
800079a2:	1a d8       	st.w	--sp,r8
800079a4:	fa c8 fa b8 	sub	r8,sp,-1352
800079a8:	1a d8       	st.w	--sp,r8
800079aa:	fa c8 fb b4 	sub	r8,sp,-1100
800079ae:	0c 9b       	mov	r11,r6
800079b0:	1a d8       	st.w	--sp,r8
800079b2:	04 9a       	mov	r10,r2
800079b4:	fa c8 f9 40 	sub	r8,sp,-1728
800079b8:	fa c9 ff b4 	sub	r9,sp,-76
800079bc:	08 9c       	mov	r12,r4
800079be:	fe b0 fa 9d 	rcall	80006ef8 <get_arg>
800079c2:	2f dd       	sub	sp,-12
800079c4:	78 16       	ld.w	r6,r12[0x4]
800079c6:	50 76       	stdsp	sp[0x1c],r6
800079c8:	c4 88       	rjmp	80007a58 <_vfprintf_r+0x830>
800079ca:	2f f7       	sub	r7,-1
800079cc:	10 39       	cp.w	r9,r8
800079ce:	c0 c4       	brge	800079e6 <_vfprintf_r+0x7be>
800079d0:	fa ce f9 44 	sub	lr,sp,-1724
800079d4:	fc 06 00 36 	add	r6,lr,r6<<0x3
800079d8:	ec fc fd 8c 	ld.w	r12,r6[-628]
800079dc:	50 7c       	stdsp	sp[0x1c],r12
800079de:	ec f6 fd 88 	ld.w	r6,r6[-632]
800079e2:	50 56       	stdsp	sp[0x14],r6
800079e4:	c6 68       	rjmp	80007ab0 <_vfprintf_r+0x888>
800079e6:	41 09       	lddsp	r9,sp[0x40]
800079e8:	59 f8       	cp.w	r8,31
800079ea:	e0 89 00 10 	brgt	80007a0a <_vfprintf_r+0x7e2>
800079ee:	f2 ca ff f8 	sub	r10,r9,-8
800079f2:	72 1b       	ld.w	r11,r9[0x4]
800079f4:	51 0a       	stdsp	sp[0x40],r10
800079f6:	72 09       	ld.w	r9,r9[0x0]
800079f8:	fa ca f9 44 	sub	r10,sp,-1724
800079fc:	50 7b       	stdsp	sp[0x1c],r11
800079fe:	50 59       	stdsp	sp[0x14],r9
80007a00:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007a04:	40 5b       	lddsp	r11,sp[0x14]
80007a06:	40 7a       	lddsp	r10,sp[0x1c]
80007a08:	c4 78       	rjmp	80007a96 <_vfprintf_r+0x86e>
80007a0a:	72 18       	ld.w	r8,r9[0x4]
80007a0c:	50 78       	stdsp	sp[0x1c],r8
80007a0e:	c4 c8       	rjmp	80007aa6 <_vfprintf_r+0x87e>
80007a10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a14:	40 3e       	lddsp	lr,sp[0xc]
80007a16:	58 0e       	cp.w	lr,0
80007a18:	c2 30       	breq	80007a5e <_vfprintf_r+0x836>
80007a1a:	10 36       	cp.w	r6,r8
80007a1c:	c0 94       	brge	80007a2e <_vfprintf_r+0x806>
80007a1e:	fa cc f9 44 	sub	r12,sp,-1724
80007a22:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007a26:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007a2a:	50 7b       	stdsp	sp[0x1c],r11
80007a2c:	cd 9b       	rjmp	800079de <_vfprintf_r+0x7b6>
80007a2e:	fa c8 f9 50 	sub	r8,sp,-1712
80007a32:	1a d8       	st.w	--sp,r8
80007a34:	fa c8 fa b8 	sub	r8,sp,-1352
80007a38:	04 9a       	mov	r10,r2
80007a3a:	1a d8       	st.w	--sp,r8
80007a3c:	fa c8 fb b4 	sub	r8,sp,-1100
80007a40:	0c 9b       	mov	r11,r6
80007a42:	1a d8       	st.w	--sp,r8
80007a44:	08 9c       	mov	r12,r4
80007a46:	fa c8 f9 40 	sub	r8,sp,-1728
80007a4a:	fa c9 ff b4 	sub	r9,sp,-76
80007a4e:	fe b0 fa 55 	rcall	80006ef8 <get_arg>
80007a52:	2f dd       	sub	sp,-12
80007a54:	78 1a       	ld.w	r10,r12[0x4]
80007a56:	50 7a       	stdsp	sp[0x1c],r10
80007a58:	78 0c       	ld.w	r12,r12[0x0]
80007a5a:	50 5c       	stdsp	sp[0x14],r12
80007a5c:	c2 a8       	rjmp	80007ab0 <_vfprintf_r+0x888>
80007a5e:	2f f7       	sub	r7,-1
80007a60:	10 39       	cp.w	r9,r8
80007a62:	c0 94       	brge	80007a74 <_vfprintf_r+0x84c>
80007a64:	fa c9 f9 44 	sub	r9,sp,-1724
80007a68:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a6c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007a70:	50 78       	stdsp	sp[0x1c],r8
80007a72:	cb 6b       	rjmp	800079de <_vfprintf_r+0x7b6>
80007a74:	41 09       	lddsp	r9,sp[0x40]
80007a76:	59 f8       	cp.w	r8,31
80007a78:	e0 89 00 15 	brgt	80007aa2 <_vfprintf_r+0x87a>
80007a7c:	f2 ca ff f8 	sub	r10,r9,-8
80007a80:	72 16       	ld.w	r6,r9[0x4]
80007a82:	72 09       	ld.w	r9,r9[0x0]
80007a84:	51 0a       	stdsp	sp[0x40],r10
80007a86:	50 59       	stdsp	sp[0x14],r9
80007a88:	fa ce f9 44 	sub	lr,sp,-1724
80007a8c:	50 76       	stdsp	sp[0x1c],r6
80007a8e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007a92:	40 5b       	lddsp	r11,sp[0x14]
80007a94:	0c 9a       	mov	r10,r6
80007a96:	f2 eb fd 88 	st.d	r9[-632],r10
80007a9a:	2f f8       	sub	r8,-1
80007a9c:	fb 48 06 b4 	st.w	sp[1716],r8
80007aa0:	c0 88       	rjmp	80007ab0 <_vfprintf_r+0x888>
80007aa2:	72 1c       	ld.w	r12,r9[0x4]
80007aa4:	50 7c       	stdsp	sp[0x1c],r12
80007aa6:	f2 c8 ff f8 	sub	r8,r9,-8
80007aaa:	51 08       	stdsp	sp[0x40],r8
80007aac:	72 09       	ld.w	r9,r9[0x0]
80007aae:	50 59       	stdsp	sp[0x14],r9
80007ab0:	40 5b       	lddsp	r11,sp[0x14]
80007ab2:	40 7a       	lddsp	r10,sp[0x1c]
80007ab4:	e0 a0 19 54 	rcall	8000ad5c <__isinfd>
80007ab8:	18 96       	mov	r6,r12
80007aba:	c1 70       	breq	80007ae8 <_vfprintf_r+0x8c0>
80007abc:	30 08       	mov	r8,0
80007abe:	30 09       	mov	r9,0
80007ac0:	40 5b       	lddsp	r11,sp[0x14]
80007ac2:	40 7a       	lddsp	r10,sp[0x1c]
80007ac4:	e0 a0 1d b4 	rcall	8000b62c <__avr32_f64_cmp_lt>
80007ac8:	c0 40       	breq	80007ad0 <_vfprintf_r+0x8a8>
80007aca:	32 d8       	mov	r8,45
80007acc:	fb 68 06 bb 	st.b	sp[1723],r8
80007ad0:	fe c8 a8 54 	sub	r8,pc,-22444
80007ad4:	fe c6 a8 54 	sub	r6,pc,-22444
80007ad8:	a7 d5       	cbr	r5,0x7
80007ada:	e0 40 00 47 	cp.w	r0,71
80007ade:	f0 06 17 a0 	movle	r6,r8
80007ae2:	30 32       	mov	r2,3
80007ae4:	e0 8f 06 ce 	bral	80008880 <_vfprintf_r+0x1658>
80007ae8:	40 5b       	lddsp	r11,sp[0x14]
80007aea:	40 7a       	lddsp	r10,sp[0x1c]
80007aec:	e0 a0 19 4d 	rcall	8000ad86 <__isnand>
80007af0:	c0 e0       	breq	80007b0c <_vfprintf_r+0x8e4>
80007af2:	50 26       	stdsp	sp[0x8],r6
80007af4:	fe c8 a8 70 	sub	r8,pc,-22416
80007af8:	fe c6 a8 70 	sub	r6,pc,-22416
80007afc:	a7 d5       	cbr	r5,0x7
80007afe:	e0 40 00 47 	cp.w	r0,71
80007b02:	f0 06 17 a0 	movle	r6,r8
80007b06:	30 32       	mov	r2,3
80007b08:	e0 8f 06 c2 	bral	8000888c <_vfprintf_r+0x1664>
80007b0c:	40 2a       	lddsp	r10,sp[0x8]
80007b0e:	5b fa       	cp.w	r10,-1
80007b10:	c0 41       	brne	80007b18 <_vfprintf_r+0x8f0>
80007b12:	30 69       	mov	r9,6
80007b14:	50 29       	stdsp	sp[0x8],r9
80007b16:	c1 18       	rjmp	80007b38 <_vfprintf_r+0x910>
80007b18:	e0 40 00 47 	cp.w	r0,71
80007b1c:	5f 09       	sreq	r9
80007b1e:	e0 40 00 67 	cp.w	r0,103
80007b22:	5f 08       	sreq	r8
80007b24:	f3 e8 10 08 	or	r8,r9,r8
80007b28:	f8 08 18 00 	cp.b	r8,r12
80007b2c:	c0 60       	breq	80007b38 <_vfprintf_r+0x910>
80007b2e:	40 28       	lddsp	r8,sp[0x8]
80007b30:	58 08       	cp.w	r8,0
80007b32:	f9 b8 00 01 	moveq	r8,1
80007b36:	50 28       	stdsp	sp[0x8],r8
80007b38:	40 78       	lddsp	r8,sp[0x1c]
80007b3a:	40 59       	lddsp	r9,sp[0x14]
80007b3c:	fa e9 06 94 	st.d	sp[1684],r8
80007b40:	a9 a5       	sbr	r5,0x8
80007b42:	fa f8 06 94 	ld.w	r8,sp[1684]
80007b46:	58 08       	cp.w	r8,0
80007b48:	c0 65       	brlt	80007b54 <_vfprintf_r+0x92c>
80007b4a:	40 5e       	lddsp	lr,sp[0x14]
80007b4c:	30 0c       	mov	r12,0
80007b4e:	50 6e       	stdsp	sp[0x18],lr
80007b50:	50 9c       	stdsp	sp[0x24],r12
80007b52:	c0 78       	rjmp	80007b60 <_vfprintf_r+0x938>
80007b54:	40 5b       	lddsp	r11,sp[0x14]
80007b56:	32 da       	mov	r10,45
80007b58:	ee 1b 80 00 	eorh	r11,0x8000
80007b5c:	50 9a       	stdsp	sp[0x24],r10
80007b5e:	50 6b       	stdsp	sp[0x18],r11
80007b60:	e0 40 00 46 	cp.w	r0,70
80007b64:	5f 09       	sreq	r9
80007b66:	e0 40 00 66 	cp.w	r0,102
80007b6a:	5f 08       	sreq	r8
80007b6c:	f3 e8 10 08 	or	r8,r9,r8
80007b70:	50 48       	stdsp	sp[0x10],r8
80007b72:	c0 40       	breq	80007b7a <_vfprintf_r+0x952>
80007b74:	40 22       	lddsp	r2,sp[0x8]
80007b76:	30 39       	mov	r9,3
80007b78:	c1 08       	rjmp	80007b98 <_vfprintf_r+0x970>
80007b7a:	e0 40 00 45 	cp.w	r0,69
80007b7e:	5f 09       	sreq	r9
80007b80:	e0 40 00 65 	cp.w	r0,101
80007b84:	5f 08       	sreq	r8
80007b86:	40 22       	lddsp	r2,sp[0x8]
80007b88:	10 49       	or	r9,r8
80007b8a:	2f f2       	sub	r2,-1
80007b8c:	40 46       	lddsp	r6,sp[0x10]
80007b8e:	ec 09 18 00 	cp.b	r9,r6
80007b92:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007b96:	30 29       	mov	r9,2
80007b98:	fa c8 f9 5c 	sub	r8,sp,-1700
80007b9c:	1a d8       	st.w	--sp,r8
80007b9e:	fa c8 f9 54 	sub	r8,sp,-1708
80007ba2:	1a d8       	st.w	--sp,r8
80007ba4:	fa c8 f9 4c 	sub	r8,sp,-1716
80007ba8:	08 9c       	mov	r12,r4
80007baa:	1a d8       	st.w	--sp,r8
80007bac:	04 98       	mov	r8,r2
80007bae:	40 9b       	lddsp	r11,sp[0x24]
80007bb0:	40 aa       	lddsp	r10,sp[0x28]
80007bb2:	e0 a0 0b c3 	rcall	80009338 <_dtoa_r>
80007bb6:	e0 40 00 47 	cp.w	r0,71
80007bba:	5f 19       	srne	r9
80007bbc:	e0 40 00 67 	cp.w	r0,103
80007bc0:	5f 18       	srne	r8
80007bc2:	18 96       	mov	r6,r12
80007bc4:	2f dd       	sub	sp,-12
80007bc6:	f3 e8 00 08 	and	r8,r9,r8
80007bca:	c0 41       	brne	80007bd2 <_vfprintf_r+0x9aa>
80007bcc:	ed b5 00 00 	bld	r5,0x0
80007bd0:	c3 01       	brne	80007c30 <_vfprintf_r+0xa08>
80007bd2:	ec 02 00 0e 	add	lr,r6,r2
80007bd6:	50 3e       	stdsp	sp[0xc],lr
80007bd8:	40 4c       	lddsp	r12,sp[0x10]
80007bda:	58 0c       	cp.w	r12,0
80007bdc:	c1 50       	breq	80007c06 <_vfprintf_r+0x9de>
80007bde:	0d 89       	ld.ub	r9,r6[0x0]
80007be0:	33 08       	mov	r8,48
80007be2:	f0 09 18 00 	cp.b	r9,r8
80007be6:	c0 b1       	brne	80007bfc <_vfprintf_r+0x9d4>
80007be8:	30 08       	mov	r8,0
80007bea:	30 09       	mov	r9,0
80007bec:	40 6b       	lddsp	r11,sp[0x18]
80007bee:	40 7a       	lddsp	r10,sp[0x1c]
80007bf0:	e0 a0 1c d7 	rcall	8000b59e <__avr32_f64_cmp_eq>
80007bf4:	fb b2 00 01 	rsubeq	r2,1
80007bf8:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007bfc:	40 3b       	lddsp	r11,sp[0xc]
80007bfe:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007c02:	10 0b       	add	r11,r8
80007c04:	50 3b       	stdsp	sp[0xc],r11
80007c06:	40 6b       	lddsp	r11,sp[0x18]
80007c08:	30 08       	mov	r8,0
80007c0a:	30 09       	mov	r9,0
80007c0c:	40 7a       	lddsp	r10,sp[0x1c]
80007c0e:	e0 a0 1c c8 	rcall	8000b59e <__avr32_f64_cmp_eq>
80007c12:	c0 90       	breq	80007c24 <_vfprintf_r+0x9fc>
80007c14:	40 3a       	lddsp	r10,sp[0xc]
80007c16:	fb 4a 06 a4 	st.w	sp[1700],r10
80007c1a:	c0 58       	rjmp	80007c24 <_vfprintf_r+0x9fc>
80007c1c:	10 c9       	st.b	r8++,r9
80007c1e:	fb 48 06 a4 	st.w	sp[1700],r8
80007c22:	c0 28       	rjmp	80007c26 <_vfprintf_r+0x9fe>
80007c24:	33 09       	mov	r9,48
80007c26:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007c2a:	40 3e       	lddsp	lr,sp[0xc]
80007c2c:	1c 38       	cp.w	r8,lr
80007c2e:	cf 73       	brcs	80007c1c <_vfprintf_r+0x9f4>
80007c30:	e0 40 00 47 	cp.w	r0,71
80007c34:	5f 09       	sreq	r9
80007c36:	e0 40 00 67 	cp.w	r0,103
80007c3a:	5f 08       	sreq	r8
80007c3c:	f3 e8 10 08 	or	r8,r9,r8
80007c40:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007c44:	0c 19       	sub	r9,r6
80007c46:	50 69       	stdsp	sp[0x18],r9
80007c48:	58 08       	cp.w	r8,0
80007c4a:	c0 b0       	breq	80007c60 <_vfprintf_r+0xa38>
80007c4c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007c50:	5b d8       	cp.w	r8,-3
80007c52:	c0 55       	brlt	80007c5c <_vfprintf_r+0xa34>
80007c54:	40 2c       	lddsp	r12,sp[0x8]
80007c56:	18 38       	cp.w	r8,r12
80007c58:	e0 8a 00 6a 	brle	80007d2c <_vfprintf_r+0xb04>
80007c5c:	20 20       	sub	r0,2
80007c5e:	c0 58       	rjmp	80007c68 <_vfprintf_r+0xa40>
80007c60:	e0 40 00 65 	cp.w	r0,101
80007c64:	e0 89 00 46 	brgt	80007cf0 <_vfprintf_r+0xac8>
80007c68:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007c6c:	fb 60 06 9c 	st.b	sp[1692],r0
80007c70:	20 1b       	sub	r11,1
80007c72:	fb 4b 06 ac 	st.w	sp[1708],r11
80007c76:	c0 47       	brpl	80007c7e <_vfprintf_r+0xa56>
80007c78:	5c 3b       	neg	r11
80007c7a:	32 d8       	mov	r8,45
80007c7c:	c0 28       	rjmp	80007c80 <_vfprintf_r+0xa58>
80007c7e:	32 b8       	mov	r8,43
80007c80:	fb 68 06 9d 	st.b	sp[1693],r8
80007c84:	58 9b       	cp.w	r11,9
80007c86:	e0 8a 00 1d 	brle	80007cc0 <_vfprintf_r+0xa98>
80007c8a:	fa c9 fa 35 	sub	r9,sp,-1483
80007c8e:	30 aa       	mov	r10,10
80007c90:	12 98       	mov	r8,r9
80007c92:	0e 9c       	mov	r12,r7
80007c94:	0c 92       	mov	r2,r6
80007c96:	f6 0a 0c 06 	divs	r6,r11,r10
80007c9a:	0e 9b       	mov	r11,r7
80007c9c:	2d 0b       	sub	r11,-48
80007c9e:	10 fb       	st.b	--r8,r11
80007ca0:	0c 9b       	mov	r11,r6
80007ca2:	58 96       	cp.w	r6,9
80007ca4:	fe 99 ff f9 	brgt	80007c96 <_vfprintf_r+0xa6e>
80007ca8:	2d 0b       	sub	r11,-48
80007caa:	18 97       	mov	r7,r12
80007cac:	04 96       	mov	r6,r2
80007cae:	10 fb       	st.b	--r8,r11
80007cb0:	fa ca f9 62 	sub	r10,sp,-1694
80007cb4:	c0 38       	rjmp	80007cba <_vfprintf_r+0xa92>
80007cb6:	11 3b       	ld.ub	r11,r8++
80007cb8:	14 cb       	st.b	r10++,r11
80007cba:	12 38       	cp.w	r8,r9
80007cbc:	cf d3       	brcs	80007cb6 <_vfprintf_r+0xa8e>
80007cbe:	c0 98       	rjmp	80007cd0 <_vfprintf_r+0xaa8>
80007cc0:	2d 0b       	sub	r11,-48
80007cc2:	33 08       	mov	r8,48
80007cc4:	fb 6b 06 9f 	st.b	sp[1695],r11
80007cc8:	fb 68 06 9e 	st.b	sp[1694],r8
80007ccc:	fa ca f9 60 	sub	r10,sp,-1696
80007cd0:	fa c8 f9 64 	sub	r8,sp,-1692
80007cd4:	f4 08 01 08 	sub	r8,r10,r8
80007cd8:	50 e8       	stdsp	sp[0x38],r8
80007cda:	10 92       	mov	r2,r8
80007cdc:	40 6b       	lddsp	r11,sp[0x18]
80007cde:	16 02       	add	r2,r11
80007ce0:	58 1b       	cp.w	r11,1
80007ce2:	e0 89 00 05 	brgt	80007cec <_vfprintf_r+0xac4>
80007ce6:	ed b5 00 00 	bld	r5,0x0
80007cea:	c3 51       	brne	80007d54 <_vfprintf_r+0xb2c>
80007cec:	2f f2       	sub	r2,-1
80007cee:	c3 38       	rjmp	80007d54 <_vfprintf_r+0xb2c>
80007cf0:	e0 40 00 66 	cp.w	r0,102
80007cf4:	c1 c1       	brne	80007d2c <_vfprintf_r+0xb04>
80007cf6:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007cfa:	58 02       	cp.w	r2,0
80007cfc:	e0 8a 00 0c 	brle	80007d14 <_vfprintf_r+0xaec>
80007d00:	40 2a       	lddsp	r10,sp[0x8]
80007d02:	58 0a       	cp.w	r10,0
80007d04:	c0 41       	brne	80007d0c <_vfprintf_r+0xae4>
80007d06:	ed b5 00 00 	bld	r5,0x0
80007d0a:	c2 51       	brne	80007d54 <_vfprintf_r+0xb2c>
80007d0c:	2f f2       	sub	r2,-1
80007d0e:	40 29       	lddsp	r9,sp[0x8]
80007d10:	12 02       	add	r2,r9
80007d12:	c0 b8       	rjmp	80007d28 <_vfprintf_r+0xb00>
80007d14:	40 28       	lddsp	r8,sp[0x8]
80007d16:	58 08       	cp.w	r8,0
80007d18:	c0 61       	brne	80007d24 <_vfprintf_r+0xafc>
80007d1a:	ed b5 00 00 	bld	r5,0x0
80007d1e:	c0 30       	breq	80007d24 <_vfprintf_r+0xafc>
80007d20:	30 12       	mov	r2,1
80007d22:	c1 98       	rjmp	80007d54 <_vfprintf_r+0xb2c>
80007d24:	40 22       	lddsp	r2,sp[0x8]
80007d26:	2f e2       	sub	r2,-2
80007d28:	36 60       	mov	r0,102
80007d2a:	c1 58       	rjmp	80007d54 <_vfprintf_r+0xb2c>
80007d2c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007d30:	40 6e       	lddsp	lr,sp[0x18]
80007d32:	1c 32       	cp.w	r2,lr
80007d34:	c0 65       	brlt	80007d40 <_vfprintf_r+0xb18>
80007d36:	ed b5 00 00 	bld	r5,0x0
80007d3a:	f7 b2 00 ff 	subeq	r2,-1
80007d3e:	c0 a8       	rjmp	80007d52 <_vfprintf_r+0xb2a>
80007d40:	e4 08 11 02 	rsub	r8,r2,2
80007d44:	40 6c       	lddsp	r12,sp[0x18]
80007d46:	58 02       	cp.w	r2,0
80007d48:	f0 02 17 a0 	movle	r2,r8
80007d4c:	f9 b2 09 01 	movgt	r2,1
80007d50:	18 02       	add	r2,r12
80007d52:	36 70       	mov	r0,103
80007d54:	40 9b       	lddsp	r11,sp[0x24]
80007d56:	58 0b       	cp.w	r11,0
80007d58:	e0 80 05 94 	breq	80008880 <_vfprintf_r+0x1658>
80007d5c:	32 d8       	mov	r8,45
80007d5e:	fb 68 06 bb 	st.b	sp[1723],r8
80007d62:	e0 8f 05 93 	bral	80008888 <_vfprintf_r+0x1660>
80007d66:	50 a7       	stdsp	sp[0x28],r7
80007d68:	04 94       	mov	r4,r2
80007d6a:	0c 97       	mov	r7,r6
80007d6c:	02 92       	mov	r2,r1
80007d6e:	06 96       	mov	r6,r3
80007d70:	40 41       	lddsp	r1,sp[0x10]
80007d72:	40 93       	lddsp	r3,sp[0x24]
80007d74:	0e 99       	mov	r9,r7
80007d76:	ed b5 00 05 	bld	r5,0x5
80007d7a:	c4 81       	brne	80007e0a <_vfprintf_r+0xbe2>
80007d7c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d80:	40 3e       	lddsp	lr,sp[0xc]
80007d82:	58 0e       	cp.w	lr,0
80007d84:	c1 d0       	breq	80007dbe <_vfprintf_r+0xb96>
80007d86:	10 36       	cp.w	r6,r8
80007d88:	c0 64       	brge	80007d94 <_vfprintf_r+0xb6c>
80007d8a:	fa cc f9 44 	sub	r12,sp,-1724
80007d8e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007d92:	c1 d8       	rjmp	80007dcc <_vfprintf_r+0xba4>
80007d94:	fa c8 f9 50 	sub	r8,sp,-1712
80007d98:	1a d8       	st.w	--sp,r8
80007d9a:	fa c8 fa b8 	sub	r8,sp,-1352
80007d9e:	04 9a       	mov	r10,r2
80007da0:	1a d8       	st.w	--sp,r8
80007da2:	fa c8 fb b4 	sub	r8,sp,-1100
80007da6:	0c 9b       	mov	r11,r6
80007da8:	1a d8       	st.w	--sp,r8
80007daa:	08 9c       	mov	r12,r4
80007dac:	fa c8 f9 40 	sub	r8,sp,-1728
80007db0:	fa c9 ff b4 	sub	r9,sp,-76
80007db4:	fe b0 f8 a2 	rcall	80006ef8 <get_arg>
80007db8:	2f dd       	sub	sp,-12
80007dba:	78 0a       	ld.w	r10,r12[0x0]
80007dbc:	c2 08       	rjmp	80007dfc <_vfprintf_r+0xbd4>
80007dbe:	2f f7       	sub	r7,-1
80007dc0:	10 39       	cp.w	r9,r8
80007dc2:	c0 84       	brge	80007dd2 <_vfprintf_r+0xbaa>
80007dc4:	fa cb f9 44 	sub	r11,sp,-1724
80007dc8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007dcc:	ec fa fd 88 	ld.w	r10,r6[-632]
80007dd0:	c1 68       	rjmp	80007dfc <_vfprintf_r+0xbd4>
80007dd2:	41 09       	lddsp	r9,sp[0x40]
80007dd4:	59 f8       	cp.w	r8,31
80007dd6:	e0 89 00 10 	brgt	80007df6 <_vfprintf_r+0xbce>
80007dda:	f2 ca ff fc 	sub	r10,r9,-4
80007dde:	51 0a       	stdsp	sp[0x40],r10
80007de0:	fa c6 f9 44 	sub	r6,sp,-1724
80007de4:	72 0a       	ld.w	r10,r9[0x0]
80007de6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007dea:	f3 4a fd 88 	st.w	r9[-632],r10
80007dee:	2f f8       	sub	r8,-1
80007df0:	fb 48 06 b4 	st.w	sp[1716],r8
80007df4:	c0 48       	rjmp	80007dfc <_vfprintf_r+0xbd4>
80007df6:	72 0a       	ld.w	r10,r9[0x0]
80007df8:	2f c9       	sub	r9,-4
80007dfa:	51 09       	stdsp	sp[0x40],r9
80007dfc:	40 be       	lddsp	lr,sp[0x2c]
80007dfe:	1c 98       	mov	r8,lr
80007e00:	95 1e       	st.w	r10[0x4],lr
80007e02:	bf 58       	asr	r8,0x1f
80007e04:	95 08       	st.w	r10[0x0],r8
80007e06:	fe 9f fa 9f 	bral	80007344 <_vfprintf_r+0x11c>
80007e0a:	ed b5 00 04 	bld	r5,0x4
80007e0e:	c4 80       	breq	80007e9e <_vfprintf_r+0xc76>
80007e10:	e2 15 00 40 	andl	r5,0x40,COH
80007e14:	c4 50       	breq	80007e9e <_vfprintf_r+0xc76>
80007e16:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e1a:	40 3c       	lddsp	r12,sp[0xc]
80007e1c:	58 0c       	cp.w	r12,0
80007e1e:	c1 d0       	breq	80007e58 <_vfprintf_r+0xc30>
80007e20:	10 36       	cp.w	r6,r8
80007e22:	c0 64       	brge	80007e2e <_vfprintf_r+0xc06>
80007e24:	fa cb f9 44 	sub	r11,sp,-1724
80007e28:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e2c:	c1 d8       	rjmp	80007e66 <_vfprintf_r+0xc3e>
80007e2e:	fa c8 f9 50 	sub	r8,sp,-1712
80007e32:	1a d8       	st.w	--sp,r8
80007e34:	fa c8 fa b8 	sub	r8,sp,-1352
80007e38:	04 9a       	mov	r10,r2
80007e3a:	1a d8       	st.w	--sp,r8
80007e3c:	fa c8 fb b4 	sub	r8,sp,-1100
80007e40:	0c 9b       	mov	r11,r6
80007e42:	1a d8       	st.w	--sp,r8
80007e44:	08 9c       	mov	r12,r4
80007e46:	fa c8 f9 40 	sub	r8,sp,-1728
80007e4a:	fa c9 ff b4 	sub	r9,sp,-76
80007e4e:	fe b0 f8 55 	rcall	80006ef8 <get_arg>
80007e52:	2f dd       	sub	sp,-12
80007e54:	78 0a       	ld.w	r10,r12[0x0]
80007e56:	c2 08       	rjmp	80007e96 <_vfprintf_r+0xc6e>
80007e58:	2f f7       	sub	r7,-1
80007e5a:	10 39       	cp.w	r9,r8
80007e5c:	c0 84       	brge	80007e6c <_vfprintf_r+0xc44>
80007e5e:	fa ca f9 44 	sub	r10,sp,-1724
80007e62:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e66:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e6a:	c1 68       	rjmp	80007e96 <_vfprintf_r+0xc6e>
80007e6c:	41 09       	lddsp	r9,sp[0x40]
80007e6e:	59 f8       	cp.w	r8,31
80007e70:	e0 89 00 10 	brgt	80007e90 <_vfprintf_r+0xc68>
80007e74:	f2 ca ff fc 	sub	r10,r9,-4
80007e78:	51 0a       	stdsp	sp[0x40],r10
80007e7a:	fa c6 f9 44 	sub	r6,sp,-1724
80007e7e:	72 0a       	ld.w	r10,r9[0x0]
80007e80:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e84:	f3 4a fd 88 	st.w	r9[-632],r10
80007e88:	2f f8       	sub	r8,-1
80007e8a:	fb 48 06 b4 	st.w	sp[1716],r8
80007e8e:	c0 48       	rjmp	80007e96 <_vfprintf_r+0xc6e>
80007e90:	72 0a       	ld.w	r10,r9[0x0]
80007e92:	2f c9       	sub	r9,-4
80007e94:	51 09       	stdsp	sp[0x40],r9
80007e96:	40 be       	lddsp	lr,sp[0x2c]
80007e98:	b4 0e       	st.h	r10[0x0],lr
80007e9a:	fe 9f fa 55 	bral	80007344 <_vfprintf_r+0x11c>
80007e9e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ea2:	40 3c       	lddsp	r12,sp[0xc]
80007ea4:	58 0c       	cp.w	r12,0
80007ea6:	c1 d0       	breq	80007ee0 <_vfprintf_r+0xcb8>
80007ea8:	10 36       	cp.w	r6,r8
80007eaa:	c0 64       	brge	80007eb6 <_vfprintf_r+0xc8e>
80007eac:	fa cb f9 44 	sub	r11,sp,-1724
80007eb0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007eb4:	c1 d8       	rjmp	80007eee <_vfprintf_r+0xcc6>
80007eb6:	fa c8 f9 50 	sub	r8,sp,-1712
80007eba:	1a d8       	st.w	--sp,r8
80007ebc:	fa c8 fa b8 	sub	r8,sp,-1352
80007ec0:	04 9a       	mov	r10,r2
80007ec2:	1a d8       	st.w	--sp,r8
80007ec4:	fa c8 fb b4 	sub	r8,sp,-1100
80007ec8:	0c 9b       	mov	r11,r6
80007eca:	1a d8       	st.w	--sp,r8
80007ecc:	08 9c       	mov	r12,r4
80007ece:	fa c8 f9 40 	sub	r8,sp,-1728
80007ed2:	fa c9 ff b4 	sub	r9,sp,-76
80007ed6:	fe b0 f8 11 	rcall	80006ef8 <get_arg>
80007eda:	2f dd       	sub	sp,-12
80007edc:	78 0a       	ld.w	r10,r12[0x0]
80007ede:	c2 08       	rjmp	80007f1e <_vfprintf_r+0xcf6>
80007ee0:	2f f7       	sub	r7,-1
80007ee2:	10 39       	cp.w	r9,r8
80007ee4:	c0 84       	brge	80007ef4 <_vfprintf_r+0xccc>
80007ee6:	fa ca f9 44 	sub	r10,sp,-1724
80007eea:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007eee:	ec fa fd 88 	ld.w	r10,r6[-632]
80007ef2:	c1 68       	rjmp	80007f1e <_vfprintf_r+0xcf6>
80007ef4:	41 09       	lddsp	r9,sp[0x40]
80007ef6:	59 f8       	cp.w	r8,31
80007ef8:	e0 89 00 10 	brgt	80007f18 <_vfprintf_r+0xcf0>
80007efc:	f2 ca ff fc 	sub	r10,r9,-4
80007f00:	51 0a       	stdsp	sp[0x40],r10
80007f02:	fa c6 f9 44 	sub	r6,sp,-1724
80007f06:	72 0a       	ld.w	r10,r9[0x0]
80007f08:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f0c:	f3 4a fd 88 	st.w	r9[-632],r10
80007f10:	2f f8       	sub	r8,-1
80007f12:	fb 48 06 b4 	st.w	sp[1716],r8
80007f16:	c0 48       	rjmp	80007f1e <_vfprintf_r+0xcf6>
80007f18:	72 0a       	ld.w	r10,r9[0x0]
80007f1a:	2f c9       	sub	r9,-4
80007f1c:	51 09       	stdsp	sp[0x40],r9
80007f1e:	40 be       	lddsp	lr,sp[0x2c]
80007f20:	95 0e       	st.w	r10[0x0],lr
80007f22:	fe 9f fa 11 	bral	80007344 <_vfprintf_r+0x11c>
80007f26:	50 a7       	stdsp	sp[0x28],r7
80007f28:	50 80       	stdsp	sp[0x20],r0
80007f2a:	0c 97       	mov	r7,r6
80007f2c:	04 94       	mov	r4,r2
80007f2e:	06 96       	mov	r6,r3
80007f30:	02 92       	mov	r2,r1
80007f32:	40 93       	lddsp	r3,sp[0x24]
80007f34:	10 90       	mov	r0,r8
80007f36:	40 41       	lddsp	r1,sp[0x10]
80007f38:	a5 a5       	sbr	r5,0x4
80007f3a:	c0 a8       	rjmp	80007f4e <_vfprintf_r+0xd26>
80007f3c:	50 a7       	stdsp	sp[0x28],r7
80007f3e:	50 80       	stdsp	sp[0x20],r0
80007f40:	0c 97       	mov	r7,r6
80007f42:	04 94       	mov	r4,r2
80007f44:	06 96       	mov	r6,r3
80007f46:	02 92       	mov	r2,r1
80007f48:	40 93       	lddsp	r3,sp[0x24]
80007f4a:	10 90       	mov	r0,r8
80007f4c:	40 41       	lddsp	r1,sp[0x10]
80007f4e:	ed b5 00 05 	bld	r5,0x5
80007f52:	c5 d1       	brne	8000800c <_vfprintf_r+0xde4>
80007f54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f58:	40 3c       	lddsp	r12,sp[0xc]
80007f5a:	58 0c       	cp.w	r12,0
80007f5c:	c2 60       	breq	80007fa8 <_vfprintf_r+0xd80>
80007f5e:	10 36       	cp.w	r6,r8
80007f60:	c0 a4       	brge	80007f74 <_vfprintf_r+0xd4c>
80007f62:	fa cb f9 44 	sub	r11,sp,-1724
80007f66:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f6a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007f6e:	fa e9 00 00 	st.d	sp[0],r8
80007f72:	c1 88       	rjmp	80007fa2 <_vfprintf_r+0xd7a>
80007f74:	fa c8 f9 50 	sub	r8,sp,-1712
80007f78:	1a d8       	st.w	--sp,r8
80007f7a:	fa c8 fa b8 	sub	r8,sp,-1352
80007f7e:	04 9a       	mov	r10,r2
80007f80:	1a d8       	st.w	--sp,r8
80007f82:	0c 9b       	mov	r11,r6
80007f84:	fa c8 fb b4 	sub	r8,sp,-1100
80007f88:	08 9c       	mov	r12,r4
80007f8a:	1a d8       	st.w	--sp,r8
80007f8c:	fa c8 f9 40 	sub	r8,sp,-1728
80007f90:	fa c9 ff b4 	sub	r9,sp,-76
80007f94:	fe b0 f7 b2 	rcall	80006ef8 <get_arg>
80007f98:	2f dd       	sub	sp,-12
80007f9a:	f8 ea 00 00 	ld.d	r10,r12[0]
80007f9e:	fa eb 00 00 	st.d	sp[0],r10
80007fa2:	30 08       	mov	r8,0
80007fa4:	e0 8f 03 de 	bral	80008760 <_vfprintf_r+0x1538>
80007fa8:	ee ca ff ff 	sub	r10,r7,-1
80007fac:	10 37       	cp.w	r7,r8
80007fae:	c0 b4       	brge	80007fc4 <_vfprintf_r+0xd9c>
80007fb0:	fa c9 f9 44 	sub	r9,sp,-1724
80007fb4:	14 97       	mov	r7,r10
80007fb6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fba:	ec ea fd 88 	ld.d	r10,r6[-632]
80007fbe:	fa eb 00 00 	st.d	sp[0],r10
80007fc2:	c1 88       	rjmp	80007ff2 <_vfprintf_r+0xdca>
80007fc4:	41 09       	lddsp	r9,sp[0x40]
80007fc6:	59 f8       	cp.w	r8,31
80007fc8:	e0 89 00 18 	brgt	80007ff8 <_vfprintf_r+0xdd0>
80007fcc:	f2 e6 00 00 	ld.d	r6,r9[0]
80007fd0:	f2 cb ff f8 	sub	r11,r9,-8
80007fd4:	fa e7 00 00 	st.d	sp[0],r6
80007fd8:	51 0b       	stdsp	sp[0x40],r11
80007fda:	fa c6 f9 44 	sub	r6,sp,-1724
80007fde:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007fe2:	fa e6 00 00 	ld.d	r6,sp[0]
80007fe6:	f2 e7 fd 88 	st.d	r9[-632],r6
80007fea:	2f f8       	sub	r8,-1
80007fec:	14 97       	mov	r7,r10
80007fee:	fb 48 06 b4 	st.w	sp[1716],r8
80007ff2:	40 38       	lddsp	r8,sp[0xc]
80007ff4:	e0 8f 03 b6 	bral	80008760 <_vfprintf_r+0x1538>
80007ff8:	f2 e6 00 00 	ld.d	r6,r9[0]
80007ffc:	40 38       	lddsp	r8,sp[0xc]
80007ffe:	fa e7 00 00 	st.d	sp[0],r6
80008002:	2f 89       	sub	r9,-8
80008004:	14 97       	mov	r7,r10
80008006:	51 09       	stdsp	sp[0x40],r9
80008008:	e0 8f 03 ac 	bral	80008760 <_vfprintf_r+0x1538>
8000800c:	ed b5 00 04 	bld	r5,0x4
80008010:	c1 61       	brne	8000803c <_vfprintf_r+0xe14>
80008012:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008016:	40 3e       	lddsp	lr,sp[0xc]
80008018:	58 0e       	cp.w	lr,0
8000801a:	c0 80       	breq	8000802a <_vfprintf_r+0xe02>
8000801c:	10 36       	cp.w	r6,r8
8000801e:	c6 74       	brge	800080ec <_vfprintf_r+0xec4>
80008020:	fa cc f9 44 	sub	r12,sp,-1724
80008024:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008028:	c8 08       	rjmp	80008128 <_vfprintf_r+0xf00>
8000802a:	ee ca ff ff 	sub	r10,r7,-1
8000802e:	10 37       	cp.w	r7,r8
80008030:	c7 f4       	brge	8000812e <_vfprintf_r+0xf06>
80008032:	fa cb f9 44 	sub	r11,sp,-1724
80008036:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000803a:	c7 68       	rjmp	80008126 <_vfprintf_r+0xefe>
8000803c:	ed b5 00 06 	bld	r5,0x6
80008040:	c4 a1       	brne	800080d4 <_vfprintf_r+0xeac>
80008042:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008046:	40 3c       	lddsp	r12,sp[0xc]
80008048:	58 0c       	cp.w	r12,0
8000804a:	c1 d0       	breq	80008084 <_vfprintf_r+0xe5c>
8000804c:	10 36       	cp.w	r6,r8
8000804e:	c0 64       	brge	8000805a <_vfprintf_r+0xe32>
80008050:	fa cb f9 44 	sub	r11,sp,-1724
80008054:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008058:	c1 f8       	rjmp	80008096 <_vfprintf_r+0xe6e>
8000805a:	fa c8 f9 50 	sub	r8,sp,-1712
8000805e:	1a d8       	st.w	--sp,r8
80008060:	fa c8 fa b8 	sub	r8,sp,-1352
80008064:	1a d8       	st.w	--sp,r8
80008066:	fa c8 fb b4 	sub	r8,sp,-1100
8000806a:	1a d8       	st.w	--sp,r8
8000806c:	fa c8 f9 40 	sub	r8,sp,-1728
80008070:	fa c9 ff b4 	sub	r9,sp,-76
80008074:	04 9a       	mov	r10,r2
80008076:	0c 9b       	mov	r11,r6
80008078:	08 9c       	mov	r12,r4
8000807a:	fe b0 f7 3f 	rcall	80006ef8 <get_arg>
8000807e:	2f dd       	sub	sp,-12
80008080:	98 18       	ld.sh	r8,r12[0x2]
80008082:	c2 68       	rjmp	800080ce <_vfprintf_r+0xea6>
80008084:	ee ca ff ff 	sub	r10,r7,-1
80008088:	10 37       	cp.w	r7,r8
8000808a:	c0 94       	brge	8000809c <_vfprintf_r+0xe74>
8000808c:	fa c9 f9 44 	sub	r9,sp,-1724
80008090:	14 97       	mov	r7,r10
80008092:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008096:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000809a:	c1 a8       	rjmp	800080ce <_vfprintf_r+0xea6>
8000809c:	41 09       	lddsp	r9,sp[0x40]
8000809e:	59 f8       	cp.w	r8,31
800080a0:	e0 89 00 13 	brgt	800080c6 <_vfprintf_r+0xe9e>
800080a4:	f2 cb ff fc 	sub	r11,r9,-4
800080a8:	51 0b       	stdsp	sp[0x40],r11
800080aa:	72 09       	ld.w	r9,r9[0x0]
800080ac:	fa c6 f9 44 	sub	r6,sp,-1724
800080b0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800080b4:	2f f8       	sub	r8,-1
800080b6:	f7 49 fd 88 	st.w	r11[-632],r9
800080ba:	fb 48 06 b4 	st.w	sp[1716],r8
800080be:	14 97       	mov	r7,r10
800080c0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800080c4:	c0 58       	rjmp	800080ce <_vfprintf_r+0xea6>
800080c6:	92 18       	ld.sh	r8,r9[0x2]
800080c8:	14 97       	mov	r7,r10
800080ca:	2f c9       	sub	r9,-4
800080cc:	51 09       	stdsp	sp[0x40],r9
800080ce:	5c 78       	castu.h	r8
800080d0:	50 18       	stdsp	sp[0x4],r8
800080d2:	c4 68       	rjmp	8000815e <_vfprintf_r+0xf36>
800080d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080d8:	40 3c       	lddsp	r12,sp[0xc]
800080da:	58 0c       	cp.w	r12,0
800080dc:	c1 d0       	breq	80008116 <_vfprintf_r+0xeee>
800080de:	10 36       	cp.w	r6,r8
800080e0:	c0 64       	brge	800080ec <_vfprintf_r+0xec4>
800080e2:	fa cb f9 44 	sub	r11,sp,-1724
800080e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080ea:	c1 f8       	rjmp	80008128 <_vfprintf_r+0xf00>
800080ec:	fa c8 f9 50 	sub	r8,sp,-1712
800080f0:	1a d8       	st.w	--sp,r8
800080f2:	fa c8 fa b8 	sub	r8,sp,-1352
800080f6:	0c 9b       	mov	r11,r6
800080f8:	1a d8       	st.w	--sp,r8
800080fa:	fa c8 fb b4 	sub	r8,sp,-1100
800080fe:	04 9a       	mov	r10,r2
80008100:	1a d8       	st.w	--sp,r8
80008102:	08 9c       	mov	r12,r4
80008104:	fa c8 f9 40 	sub	r8,sp,-1728
80008108:	fa c9 ff b4 	sub	r9,sp,-76
8000810c:	fe b0 f6 f6 	rcall	80006ef8 <get_arg>
80008110:	2f dd       	sub	sp,-12
80008112:	78 0b       	ld.w	r11,r12[0x0]
80008114:	c2 48       	rjmp	8000815c <_vfprintf_r+0xf34>
80008116:	ee ca ff ff 	sub	r10,r7,-1
8000811a:	10 37       	cp.w	r7,r8
8000811c:	c0 94       	brge	8000812e <_vfprintf_r+0xf06>
8000811e:	fa c9 f9 44 	sub	r9,sp,-1724
80008122:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008126:	14 97       	mov	r7,r10
80008128:	ec fb fd 88 	ld.w	r11,r6[-632]
8000812c:	c1 88       	rjmp	8000815c <_vfprintf_r+0xf34>
8000812e:	41 09       	lddsp	r9,sp[0x40]
80008130:	59 f8       	cp.w	r8,31
80008132:	e0 89 00 11 	brgt	80008154 <_vfprintf_r+0xf2c>
80008136:	f2 cb ff fc 	sub	r11,r9,-4
8000813a:	51 0b       	stdsp	sp[0x40],r11
8000813c:	fa c6 f9 44 	sub	r6,sp,-1724
80008140:	72 0b       	ld.w	r11,r9[0x0]
80008142:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008146:	f3 4b fd 88 	st.w	r9[-632],r11
8000814a:	2f f8       	sub	r8,-1
8000814c:	14 97       	mov	r7,r10
8000814e:	fb 48 06 b4 	st.w	sp[1716],r8
80008152:	c0 58       	rjmp	8000815c <_vfprintf_r+0xf34>
80008154:	72 0b       	ld.w	r11,r9[0x0]
80008156:	14 97       	mov	r7,r10
80008158:	2f c9       	sub	r9,-4
8000815a:	51 09       	stdsp	sp[0x40],r9
8000815c:	50 1b       	stdsp	sp[0x4],r11
8000815e:	30 0e       	mov	lr,0
80008160:	50 0e       	stdsp	sp[0x0],lr
80008162:	1c 98       	mov	r8,lr
80008164:	e0 8f 02 fe 	bral	80008760 <_vfprintf_r+0x1538>
80008168:	50 a7       	stdsp	sp[0x28],r7
8000816a:	50 80       	stdsp	sp[0x20],r0
8000816c:	0c 97       	mov	r7,r6
8000816e:	04 94       	mov	r4,r2
80008170:	06 96       	mov	r6,r3
80008172:	02 92       	mov	r2,r1
80008174:	40 93       	lddsp	r3,sp[0x24]
80008176:	40 41       	lddsp	r1,sp[0x10]
80008178:	0e 99       	mov	r9,r7
8000817a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000817e:	40 3c       	lddsp	r12,sp[0xc]
80008180:	58 0c       	cp.w	r12,0
80008182:	c1 d0       	breq	800081bc <_vfprintf_r+0xf94>
80008184:	10 36       	cp.w	r6,r8
80008186:	c0 64       	brge	80008192 <_vfprintf_r+0xf6a>
80008188:	fa cb f9 44 	sub	r11,sp,-1724
8000818c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008190:	c1 d8       	rjmp	800081ca <_vfprintf_r+0xfa2>
80008192:	fa c8 f9 50 	sub	r8,sp,-1712
80008196:	1a d8       	st.w	--sp,r8
80008198:	fa c8 fa b8 	sub	r8,sp,-1352
8000819c:	1a d8       	st.w	--sp,r8
8000819e:	fa c8 fb b4 	sub	r8,sp,-1100
800081a2:	1a d8       	st.w	--sp,r8
800081a4:	fa c9 ff b4 	sub	r9,sp,-76
800081a8:	fa c8 f9 40 	sub	r8,sp,-1728
800081ac:	04 9a       	mov	r10,r2
800081ae:	0c 9b       	mov	r11,r6
800081b0:	08 9c       	mov	r12,r4
800081b2:	fe b0 f6 a3 	rcall	80006ef8 <get_arg>
800081b6:	2f dd       	sub	sp,-12
800081b8:	78 09       	ld.w	r9,r12[0x0]
800081ba:	c2 18       	rjmp	800081fc <_vfprintf_r+0xfd4>
800081bc:	2f f7       	sub	r7,-1
800081be:	10 39       	cp.w	r9,r8
800081c0:	c0 84       	brge	800081d0 <_vfprintf_r+0xfa8>
800081c2:	fa ca f9 44 	sub	r10,sp,-1724
800081c6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800081ca:	ec f9 fd 88 	ld.w	r9,r6[-632]
800081ce:	c1 78       	rjmp	800081fc <_vfprintf_r+0xfd4>
800081d0:	41 09       	lddsp	r9,sp[0x40]
800081d2:	59 f8       	cp.w	r8,31
800081d4:	e0 89 00 10 	brgt	800081f4 <_vfprintf_r+0xfcc>
800081d8:	f2 ca ff fc 	sub	r10,r9,-4
800081dc:	51 0a       	stdsp	sp[0x40],r10
800081de:	fa c6 f9 44 	sub	r6,sp,-1724
800081e2:	72 09       	ld.w	r9,r9[0x0]
800081e4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800081e8:	f5 49 fd 88 	st.w	r10[-632],r9
800081ec:	2f f8       	sub	r8,-1
800081ee:	fb 48 06 b4 	st.w	sp[1716],r8
800081f2:	c0 58       	rjmp	800081fc <_vfprintf_r+0xfd4>
800081f4:	f2 c8 ff fc 	sub	r8,r9,-4
800081f8:	51 08       	stdsp	sp[0x40],r8
800081fa:	72 09       	ld.w	r9,r9[0x0]
800081fc:	33 08       	mov	r8,48
800081fe:	fb 68 06 b8 	st.b	sp[1720],r8
80008202:	37 88       	mov	r8,120
80008204:	30 0e       	mov	lr,0
80008206:	fb 68 06 b9 	st.b	sp[1721],r8
8000820a:	fe cc af 7e 	sub	r12,pc,-20610
8000820e:	50 19       	stdsp	sp[0x4],r9
80008210:	a1 b5       	sbr	r5,0x1
80008212:	50 0e       	stdsp	sp[0x0],lr
80008214:	50 dc       	stdsp	sp[0x34],r12
80008216:	30 28       	mov	r8,2
80008218:	37 80       	mov	r0,120
8000821a:	e0 8f 02 a3 	bral	80008760 <_vfprintf_r+0x1538>
8000821e:	50 a7       	stdsp	sp[0x28],r7
80008220:	50 80       	stdsp	sp[0x20],r0
80008222:	10 90       	mov	r0,r8
80008224:	30 08       	mov	r8,0
80008226:	fb 68 06 bb 	st.b	sp[1723],r8
8000822a:	0c 97       	mov	r7,r6
8000822c:	04 94       	mov	r4,r2
8000822e:	06 96       	mov	r6,r3
80008230:	02 92       	mov	r2,r1
80008232:	40 93       	lddsp	r3,sp[0x24]
80008234:	40 41       	lddsp	r1,sp[0x10]
80008236:	0e 99       	mov	r9,r7
80008238:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000823c:	40 3b       	lddsp	r11,sp[0xc]
8000823e:	58 0b       	cp.w	r11,0
80008240:	c1 d0       	breq	8000827a <_vfprintf_r+0x1052>
80008242:	10 36       	cp.w	r6,r8
80008244:	c0 64       	brge	80008250 <_vfprintf_r+0x1028>
80008246:	fa ca f9 44 	sub	r10,sp,-1724
8000824a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000824e:	c1 d8       	rjmp	80008288 <_vfprintf_r+0x1060>
80008250:	fa c8 f9 50 	sub	r8,sp,-1712
80008254:	1a d8       	st.w	--sp,r8
80008256:	fa c8 fa b8 	sub	r8,sp,-1352
8000825a:	1a d8       	st.w	--sp,r8
8000825c:	fa c8 fb b4 	sub	r8,sp,-1100
80008260:	0c 9b       	mov	r11,r6
80008262:	1a d8       	st.w	--sp,r8
80008264:	04 9a       	mov	r10,r2
80008266:	fa c8 f9 40 	sub	r8,sp,-1728
8000826a:	fa c9 ff b4 	sub	r9,sp,-76
8000826e:	08 9c       	mov	r12,r4
80008270:	fe b0 f6 44 	rcall	80006ef8 <get_arg>
80008274:	2f dd       	sub	sp,-12
80008276:	78 06       	ld.w	r6,r12[0x0]
80008278:	c2 08       	rjmp	800082b8 <_vfprintf_r+0x1090>
8000827a:	2f f7       	sub	r7,-1
8000827c:	10 39       	cp.w	r9,r8
8000827e:	c0 84       	brge	8000828e <_vfprintf_r+0x1066>
80008280:	fa c9 f9 44 	sub	r9,sp,-1724
80008284:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008288:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000828c:	c1 68       	rjmp	800082b8 <_vfprintf_r+0x1090>
8000828e:	41 09       	lddsp	r9,sp[0x40]
80008290:	59 f8       	cp.w	r8,31
80008292:	e0 89 00 10 	brgt	800082b2 <_vfprintf_r+0x108a>
80008296:	f2 ca ff fc 	sub	r10,r9,-4
8000829a:	51 0a       	stdsp	sp[0x40],r10
8000829c:	72 06       	ld.w	r6,r9[0x0]
8000829e:	fa ce f9 44 	sub	lr,sp,-1724
800082a2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800082a6:	f3 46 fd 88 	st.w	r9[-632],r6
800082aa:	2f f8       	sub	r8,-1
800082ac:	fb 48 06 b4 	st.w	sp[1716],r8
800082b0:	c0 48       	rjmp	800082b8 <_vfprintf_r+0x1090>
800082b2:	72 06       	ld.w	r6,r9[0x0]
800082b4:	2f c9       	sub	r9,-4
800082b6:	51 09       	stdsp	sp[0x40],r9
800082b8:	40 2c       	lddsp	r12,sp[0x8]
800082ba:	58 0c       	cp.w	r12,0
800082bc:	c1 05       	brlt	800082dc <_vfprintf_r+0x10b4>
800082be:	18 9a       	mov	r10,r12
800082c0:	30 0b       	mov	r11,0
800082c2:	0c 9c       	mov	r12,r6
800082c4:	e0 a0 12 38 	rcall	8000a734 <memchr>
800082c8:	e0 80 02 df 	breq	80008886 <_vfprintf_r+0x165e>
800082cc:	f8 06 01 02 	sub	r2,r12,r6
800082d0:	40 2b       	lddsp	r11,sp[0x8]
800082d2:	16 32       	cp.w	r2,r11
800082d4:	e0 89 02 d9 	brgt	80008886 <_vfprintf_r+0x165e>
800082d8:	e0 8f 02 d4 	bral	80008880 <_vfprintf_r+0x1658>
800082dc:	30 0a       	mov	r10,0
800082de:	0c 9c       	mov	r12,r6
800082e0:	50 2a       	stdsp	sp[0x8],r10
800082e2:	e0 a0 15 99 	rcall	8000ae14 <strlen>
800082e6:	18 92       	mov	r2,r12
800082e8:	e0 8f 02 d2 	bral	8000888c <_vfprintf_r+0x1664>
800082ec:	50 a7       	stdsp	sp[0x28],r7
800082ee:	50 80       	stdsp	sp[0x20],r0
800082f0:	0c 97       	mov	r7,r6
800082f2:	04 94       	mov	r4,r2
800082f4:	06 96       	mov	r6,r3
800082f6:	02 92       	mov	r2,r1
800082f8:	40 93       	lddsp	r3,sp[0x24]
800082fa:	10 90       	mov	r0,r8
800082fc:	40 41       	lddsp	r1,sp[0x10]
800082fe:	a5 a5       	sbr	r5,0x4
80008300:	c0 a8       	rjmp	80008314 <_vfprintf_r+0x10ec>
80008302:	50 a7       	stdsp	sp[0x28],r7
80008304:	50 80       	stdsp	sp[0x20],r0
80008306:	0c 97       	mov	r7,r6
80008308:	04 94       	mov	r4,r2
8000830a:	06 96       	mov	r6,r3
8000830c:	02 92       	mov	r2,r1
8000830e:	40 93       	lddsp	r3,sp[0x24]
80008310:	10 90       	mov	r0,r8
80008312:	40 41       	lddsp	r1,sp[0x10]
80008314:	ed b5 00 05 	bld	r5,0x5
80008318:	c5 61       	brne	800083c4 <_vfprintf_r+0x119c>
8000831a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000831e:	40 39       	lddsp	r9,sp[0xc]
80008320:	58 09       	cp.w	r9,0
80008322:	c2 10       	breq	80008364 <_vfprintf_r+0x113c>
80008324:	10 36       	cp.w	r6,r8
80008326:	c0 74       	brge	80008334 <_vfprintf_r+0x110c>
80008328:	fa c8 f9 44 	sub	r8,sp,-1724
8000832c:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008330:	c2 38       	rjmp	80008376 <_vfprintf_r+0x114e>
80008332:	d7 03       	nop
80008334:	fa c8 f9 50 	sub	r8,sp,-1712
80008338:	1a d8       	st.w	--sp,r8
8000833a:	fa c8 fa b8 	sub	r8,sp,-1352
8000833e:	1a d8       	st.w	--sp,r8
80008340:	fa c8 fb b4 	sub	r8,sp,-1100
80008344:	1a d8       	st.w	--sp,r8
80008346:	fa c8 f9 40 	sub	r8,sp,-1728
8000834a:	fa c9 ff b4 	sub	r9,sp,-76
8000834e:	04 9a       	mov	r10,r2
80008350:	0c 9b       	mov	r11,r6
80008352:	08 9c       	mov	r12,r4
80008354:	fe b0 f5 d2 	rcall	80006ef8 <get_arg>
80008358:	2f dd       	sub	sp,-12
8000835a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000835e:	fa e9 00 00 	st.d	sp[0],r8
80008362:	c2 e8       	rjmp	800083be <_vfprintf_r+0x1196>
80008364:	ee ca ff ff 	sub	r10,r7,-1
80008368:	10 37       	cp.w	r7,r8
8000836a:	c0 b4       	brge	80008380 <_vfprintf_r+0x1158>
8000836c:	fa c8 f9 44 	sub	r8,sp,-1724
80008370:	14 97       	mov	r7,r10
80008372:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008376:	ec ea fd 88 	ld.d	r10,r6[-632]
8000837a:	fa eb 00 00 	st.d	sp[0],r10
8000837e:	c2 08       	rjmp	800083be <_vfprintf_r+0x1196>
80008380:	41 09       	lddsp	r9,sp[0x40]
80008382:	59 f8       	cp.w	r8,31
80008384:	e0 89 00 16 	brgt	800083b0 <_vfprintf_r+0x1188>
80008388:	f2 e6 00 00 	ld.d	r6,r9[0]
8000838c:	f2 cb ff f8 	sub	r11,r9,-8
80008390:	fa e7 00 00 	st.d	sp[0],r6
80008394:	51 0b       	stdsp	sp[0x40],r11
80008396:	fa c6 f9 44 	sub	r6,sp,-1724
8000839a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000839e:	fa e6 00 00 	ld.d	r6,sp[0]
800083a2:	f2 e7 fd 88 	st.d	r9[-632],r6
800083a6:	2f f8       	sub	r8,-1
800083a8:	14 97       	mov	r7,r10
800083aa:	fb 48 06 b4 	st.w	sp[1716],r8
800083ae:	c0 88       	rjmp	800083be <_vfprintf_r+0x1196>
800083b0:	f2 e6 00 00 	ld.d	r6,r9[0]
800083b4:	2f 89       	sub	r9,-8
800083b6:	fa e7 00 00 	st.d	sp[0],r6
800083ba:	51 09       	stdsp	sp[0x40],r9
800083bc:	14 97       	mov	r7,r10
800083be:	30 18       	mov	r8,1
800083c0:	e0 8f 01 d0 	bral	80008760 <_vfprintf_r+0x1538>
800083c4:	ed b5 00 04 	bld	r5,0x4
800083c8:	c1 61       	brne	800083f4 <_vfprintf_r+0x11cc>
800083ca:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083ce:	40 3e       	lddsp	lr,sp[0xc]
800083d0:	58 0e       	cp.w	lr,0
800083d2:	c0 80       	breq	800083e2 <_vfprintf_r+0x11ba>
800083d4:	10 36       	cp.w	r6,r8
800083d6:	c6 74       	brge	800084a4 <_vfprintf_r+0x127c>
800083d8:	fa cc f9 44 	sub	r12,sp,-1724
800083dc:	f8 06 00 36 	add	r6,r12,r6<<0x3
800083e0:	c8 08       	rjmp	800084e0 <_vfprintf_r+0x12b8>
800083e2:	ee ca ff ff 	sub	r10,r7,-1
800083e6:	10 37       	cp.w	r7,r8
800083e8:	c7 f4       	brge	800084e6 <_vfprintf_r+0x12be>
800083ea:	fa cb f9 44 	sub	r11,sp,-1724
800083ee:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083f2:	c7 68       	rjmp	800084de <_vfprintf_r+0x12b6>
800083f4:	ed b5 00 06 	bld	r5,0x6
800083f8:	c4 a1       	brne	8000848c <_vfprintf_r+0x1264>
800083fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083fe:	40 3c       	lddsp	r12,sp[0xc]
80008400:	58 0c       	cp.w	r12,0
80008402:	c1 d0       	breq	8000843c <_vfprintf_r+0x1214>
80008404:	10 36       	cp.w	r6,r8
80008406:	c0 64       	brge	80008412 <_vfprintf_r+0x11ea>
80008408:	fa cb f9 44 	sub	r11,sp,-1724
8000840c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008410:	c1 f8       	rjmp	8000844e <_vfprintf_r+0x1226>
80008412:	fa c8 f9 50 	sub	r8,sp,-1712
80008416:	1a d8       	st.w	--sp,r8
80008418:	fa c8 fa b8 	sub	r8,sp,-1352
8000841c:	1a d8       	st.w	--sp,r8
8000841e:	fa c8 fb b4 	sub	r8,sp,-1100
80008422:	1a d8       	st.w	--sp,r8
80008424:	fa c8 f9 40 	sub	r8,sp,-1728
80008428:	fa c9 ff b4 	sub	r9,sp,-76
8000842c:	04 9a       	mov	r10,r2
8000842e:	0c 9b       	mov	r11,r6
80008430:	08 9c       	mov	r12,r4
80008432:	fe b0 f5 63 	rcall	80006ef8 <get_arg>
80008436:	2f dd       	sub	sp,-12
80008438:	98 18       	ld.sh	r8,r12[0x2]
8000843a:	c2 68       	rjmp	80008486 <_vfprintf_r+0x125e>
8000843c:	ee ca ff ff 	sub	r10,r7,-1
80008440:	10 37       	cp.w	r7,r8
80008442:	c0 94       	brge	80008454 <_vfprintf_r+0x122c>
80008444:	fa c9 f9 44 	sub	r9,sp,-1724
80008448:	14 97       	mov	r7,r10
8000844a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000844e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008452:	c1 a8       	rjmp	80008486 <_vfprintf_r+0x125e>
80008454:	41 09       	lddsp	r9,sp[0x40]
80008456:	59 f8       	cp.w	r8,31
80008458:	e0 89 00 13 	brgt	8000847e <_vfprintf_r+0x1256>
8000845c:	f2 cb ff fc 	sub	r11,r9,-4
80008460:	51 0b       	stdsp	sp[0x40],r11
80008462:	72 09       	ld.w	r9,r9[0x0]
80008464:	fa c6 f9 44 	sub	r6,sp,-1724
80008468:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000846c:	2f f8       	sub	r8,-1
8000846e:	f7 49 fd 88 	st.w	r11[-632],r9
80008472:	fb 48 06 b4 	st.w	sp[1716],r8
80008476:	14 97       	mov	r7,r10
80008478:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000847c:	c0 58       	rjmp	80008486 <_vfprintf_r+0x125e>
8000847e:	92 18       	ld.sh	r8,r9[0x2]
80008480:	14 97       	mov	r7,r10
80008482:	2f c9       	sub	r9,-4
80008484:	51 09       	stdsp	sp[0x40],r9
80008486:	5c 78       	castu.h	r8
80008488:	50 18       	stdsp	sp[0x4],r8
8000848a:	c4 68       	rjmp	80008516 <_vfprintf_r+0x12ee>
8000848c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008490:	40 3c       	lddsp	r12,sp[0xc]
80008492:	58 0c       	cp.w	r12,0
80008494:	c1 d0       	breq	800084ce <_vfprintf_r+0x12a6>
80008496:	10 36       	cp.w	r6,r8
80008498:	c0 64       	brge	800084a4 <_vfprintf_r+0x127c>
8000849a:	fa cb f9 44 	sub	r11,sp,-1724
8000849e:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084a2:	c1 f8       	rjmp	800084e0 <_vfprintf_r+0x12b8>
800084a4:	fa c8 f9 50 	sub	r8,sp,-1712
800084a8:	1a d8       	st.w	--sp,r8
800084aa:	fa c8 fa b8 	sub	r8,sp,-1352
800084ae:	0c 9b       	mov	r11,r6
800084b0:	1a d8       	st.w	--sp,r8
800084b2:	fa c8 fb b4 	sub	r8,sp,-1100
800084b6:	04 9a       	mov	r10,r2
800084b8:	1a d8       	st.w	--sp,r8
800084ba:	08 9c       	mov	r12,r4
800084bc:	fa c8 f9 40 	sub	r8,sp,-1728
800084c0:	fa c9 ff b4 	sub	r9,sp,-76
800084c4:	fe b0 f5 1a 	rcall	80006ef8 <get_arg>
800084c8:	2f dd       	sub	sp,-12
800084ca:	78 0b       	ld.w	r11,r12[0x0]
800084cc:	c2 48       	rjmp	80008514 <_vfprintf_r+0x12ec>
800084ce:	ee ca ff ff 	sub	r10,r7,-1
800084d2:	10 37       	cp.w	r7,r8
800084d4:	c0 94       	brge	800084e6 <_vfprintf_r+0x12be>
800084d6:	fa c9 f9 44 	sub	r9,sp,-1724
800084da:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084de:	14 97       	mov	r7,r10
800084e0:	ec fb fd 88 	ld.w	r11,r6[-632]
800084e4:	c1 88       	rjmp	80008514 <_vfprintf_r+0x12ec>
800084e6:	41 09       	lddsp	r9,sp[0x40]
800084e8:	59 f8       	cp.w	r8,31
800084ea:	e0 89 00 11 	brgt	8000850c <_vfprintf_r+0x12e4>
800084ee:	f2 cb ff fc 	sub	r11,r9,-4
800084f2:	51 0b       	stdsp	sp[0x40],r11
800084f4:	fa c6 f9 44 	sub	r6,sp,-1724
800084f8:	72 0b       	ld.w	r11,r9[0x0]
800084fa:	ec 08 00 39 	add	r9,r6,r8<<0x3
800084fe:	f3 4b fd 88 	st.w	r9[-632],r11
80008502:	2f f8       	sub	r8,-1
80008504:	14 97       	mov	r7,r10
80008506:	fb 48 06 b4 	st.w	sp[1716],r8
8000850a:	c0 58       	rjmp	80008514 <_vfprintf_r+0x12ec>
8000850c:	72 0b       	ld.w	r11,r9[0x0]
8000850e:	14 97       	mov	r7,r10
80008510:	2f c9       	sub	r9,-4
80008512:	51 09       	stdsp	sp[0x40],r9
80008514:	50 1b       	stdsp	sp[0x4],r11
80008516:	30 0e       	mov	lr,0
80008518:	30 18       	mov	r8,1
8000851a:	50 0e       	stdsp	sp[0x0],lr
8000851c:	c2 29       	rjmp	80008760 <_vfprintf_r+0x1538>
8000851e:	50 a7       	stdsp	sp[0x28],r7
80008520:	50 80       	stdsp	sp[0x20],r0
80008522:	0c 97       	mov	r7,r6
80008524:	04 94       	mov	r4,r2
80008526:	06 96       	mov	r6,r3
80008528:	02 92       	mov	r2,r1
8000852a:	fe cc b2 9e 	sub	r12,pc,-19810
8000852e:	40 93       	lddsp	r3,sp[0x24]
80008530:	10 90       	mov	r0,r8
80008532:	40 41       	lddsp	r1,sp[0x10]
80008534:	50 dc       	stdsp	sp[0x34],r12
80008536:	ed b5 00 05 	bld	r5,0x5
8000853a:	c5 51       	brne	800085e4 <_vfprintf_r+0x13bc>
8000853c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008540:	40 3b       	lddsp	r11,sp[0xc]
80008542:	58 0b       	cp.w	r11,0
80008544:	c2 20       	breq	80008588 <_vfprintf_r+0x1360>
80008546:	10 36       	cp.w	r6,r8
80008548:	c0 a4       	brge	8000855c <_vfprintf_r+0x1334>
8000854a:	fa ca f9 44 	sub	r10,sp,-1724
8000854e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008552:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008556:	fa e9 00 00 	st.d	sp[0],r8
8000855a:	cf 28       	rjmp	8000873e <_vfprintf_r+0x1516>
8000855c:	fa c8 f9 50 	sub	r8,sp,-1712
80008560:	1a d8       	st.w	--sp,r8
80008562:	fa c8 fa b8 	sub	r8,sp,-1352
80008566:	04 9a       	mov	r10,r2
80008568:	1a d8       	st.w	--sp,r8
8000856a:	0c 9b       	mov	r11,r6
8000856c:	fa c8 fb b4 	sub	r8,sp,-1100
80008570:	08 9c       	mov	r12,r4
80008572:	1a d8       	st.w	--sp,r8
80008574:	fa c8 f9 40 	sub	r8,sp,-1728
80008578:	fa c9 ff b4 	sub	r9,sp,-76
8000857c:	fe b0 f4 be 	rcall	80006ef8 <get_arg>
80008580:	2f dd       	sub	sp,-12
80008582:	f8 ea 00 00 	ld.d	r10,r12[0]
80008586:	c0 c8       	rjmp	8000859e <_vfprintf_r+0x1376>
80008588:	ee ca ff ff 	sub	r10,r7,-1
8000858c:	10 37       	cp.w	r7,r8
8000858e:	c0 b4       	brge	800085a4 <_vfprintf_r+0x137c>
80008590:	fa c9 f9 44 	sub	r9,sp,-1724
80008594:	14 97       	mov	r7,r10
80008596:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000859a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000859e:	fa eb 00 00 	st.d	sp[0],r10
800085a2:	cc e8       	rjmp	8000873e <_vfprintf_r+0x1516>
800085a4:	41 09       	lddsp	r9,sp[0x40]
800085a6:	59 f8       	cp.w	r8,31
800085a8:	e0 89 00 16 	brgt	800085d4 <_vfprintf_r+0x13ac>
800085ac:	f2 e6 00 00 	ld.d	r6,r9[0]
800085b0:	f2 cb ff f8 	sub	r11,r9,-8
800085b4:	fa e7 00 00 	st.d	sp[0],r6
800085b8:	51 0b       	stdsp	sp[0x40],r11
800085ba:	fa c6 f9 44 	sub	r6,sp,-1724
800085be:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085c2:	fa e6 00 00 	ld.d	r6,sp[0]
800085c6:	f2 e7 fd 88 	st.d	r9[-632],r6
800085ca:	2f f8       	sub	r8,-1
800085cc:	14 97       	mov	r7,r10
800085ce:	fb 48 06 b4 	st.w	sp[1716],r8
800085d2:	cb 68       	rjmp	8000873e <_vfprintf_r+0x1516>
800085d4:	f2 e6 00 00 	ld.d	r6,r9[0]
800085d8:	2f 89       	sub	r9,-8
800085da:	fa e7 00 00 	st.d	sp[0],r6
800085de:	51 09       	stdsp	sp[0x40],r9
800085e0:	14 97       	mov	r7,r10
800085e2:	ca e8       	rjmp	8000873e <_vfprintf_r+0x1516>
800085e4:	ed b5 00 04 	bld	r5,0x4
800085e8:	c1 71       	brne	80008616 <_vfprintf_r+0x13ee>
800085ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085ee:	40 3e       	lddsp	lr,sp[0xc]
800085f0:	58 0e       	cp.w	lr,0
800085f2:	c0 80       	breq	80008602 <_vfprintf_r+0x13da>
800085f4:	10 36       	cp.w	r6,r8
800085f6:	c6 94       	brge	800086c8 <_vfprintf_r+0x14a0>
800085f8:	fa cc f9 44 	sub	r12,sp,-1724
800085fc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008600:	c8 28       	rjmp	80008704 <_vfprintf_r+0x14dc>
80008602:	ee ca ff ff 	sub	r10,r7,-1
80008606:	10 37       	cp.w	r7,r8
80008608:	e0 84 00 81 	brge	8000870a <_vfprintf_r+0x14e2>
8000860c:	fa cb f9 44 	sub	r11,sp,-1724
80008610:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008614:	c7 78       	rjmp	80008702 <_vfprintf_r+0x14da>
80008616:	ed b5 00 06 	bld	r5,0x6
8000861a:	c4 b1       	brne	800086b0 <_vfprintf_r+0x1488>
8000861c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008620:	40 3c       	lddsp	r12,sp[0xc]
80008622:	58 0c       	cp.w	r12,0
80008624:	c1 d0       	breq	8000865e <_vfprintf_r+0x1436>
80008626:	10 36       	cp.w	r6,r8
80008628:	c0 64       	brge	80008634 <_vfprintf_r+0x140c>
8000862a:	fa cb f9 44 	sub	r11,sp,-1724
8000862e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008632:	c1 f8       	rjmp	80008670 <_vfprintf_r+0x1448>
80008634:	fa c8 f9 50 	sub	r8,sp,-1712
80008638:	1a d8       	st.w	--sp,r8
8000863a:	fa c8 fa b8 	sub	r8,sp,-1352
8000863e:	1a d8       	st.w	--sp,r8
80008640:	fa c8 fb b4 	sub	r8,sp,-1100
80008644:	1a d8       	st.w	--sp,r8
80008646:	fa c8 f9 40 	sub	r8,sp,-1728
8000864a:	fa c9 ff b4 	sub	r9,sp,-76
8000864e:	04 9a       	mov	r10,r2
80008650:	0c 9b       	mov	r11,r6
80008652:	08 9c       	mov	r12,r4
80008654:	fe b0 f4 52 	rcall	80006ef8 <get_arg>
80008658:	2f dd       	sub	sp,-12
8000865a:	98 18       	ld.sh	r8,r12[0x2]
8000865c:	c2 78       	rjmp	800086aa <_vfprintf_r+0x1482>
8000865e:	ee ca ff ff 	sub	r10,r7,-1
80008662:	10 37       	cp.w	r7,r8
80008664:	c0 a4       	brge	80008678 <_vfprintf_r+0x1450>
80008666:	fa c9 f9 44 	sub	r9,sp,-1724
8000866a:	14 97       	mov	r7,r10
8000866c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008670:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008674:	c1 b8       	rjmp	800086aa <_vfprintf_r+0x1482>
80008676:	d7 03       	nop
80008678:	41 09       	lddsp	r9,sp[0x40]
8000867a:	59 f8       	cp.w	r8,31
8000867c:	e0 89 00 13 	brgt	800086a2 <_vfprintf_r+0x147a>
80008680:	f2 cb ff fc 	sub	r11,r9,-4
80008684:	51 0b       	stdsp	sp[0x40],r11
80008686:	72 09       	ld.w	r9,r9[0x0]
80008688:	fa c6 f9 44 	sub	r6,sp,-1724
8000868c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008690:	2f f8       	sub	r8,-1
80008692:	f7 49 fd 88 	st.w	r11[-632],r9
80008696:	fb 48 06 b4 	st.w	sp[1716],r8
8000869a:	14 97       	mov	r7,r10
8000869c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800086a0:	c0 58       	rjmp	800086aa <_vfprintf_r+0x1482>
800086a2:	92 18       	ld.sh	r8,r9[0x2]
800086a4:	14 97       	mov	r7,r10
800086a6:	2f c9       	sub	r9,-4
800086a8:	51 09       	stdsp	sp[0x40],r9
800086aa:	5c 78       	castu.h	r8
800086ac:	50 18       	stdsp	sp[0x4],r8
800086ae:	c4 68       	rjmp	8000873a <_vfprintf_r+0x1512>
800086b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086b4:	40 3c       	lddsp	r12,sp[0xc]
800086b6:	58 0c       	cp.w	r12,0
800086b8:	c1 d0       	breq	800086f2 <_vfprintf_r+0x14ca>
800086ba:	10 36       	cp.w	r6,r8
800086bc:	c0 64       	brge	800086c8 <_vfprintf_r+0x14a0>
800086be:	fa cb f9 44 	sub	r11,sp,-1724
800086c2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086c6:	c1 f8       	rjmp	80008704 <_vfprintf_r+0x14dc>
800086c8:	fa c8 f9 50 	sub	r8,sp,-1712
800086cc:	1a d8       	st.w	--sp,r8
800086ce:	fa c8 fa b8 	sub	r8,sp,-1352
800086d2:	0c 9b       	mov	r11,r6
800086d4:	1a d8       	st.w	--sp,r8
800086d6:	fa c8 fb b4 	sub	r8,sp,-1100
800086da:	04 9a       	mov	r10,r2
800086dc:	1a d8       	st.w	--sp,r8
800086de:	08 9c       	mov	r12,r4
800086e0:	fa c8 f9 40 	sub	r8,sp,-1728
800086e4:	fa c9 ff b4 	sub	r9,sp,-76
800086e8:	fe b0 f4 08 	rcall	80006ef8 <get_arg>
800086ec:	2f dd       	sub	sp,-12
800086ee:	78 0b       	ld.w	r11,r12[0x0]
800086f0:	c2 48       	rjmp	80008738 <_vfprintf_r+0x1510>
800086f2:	ee ca ff ff 	sub	r10,r7,-1
800086f6:	10 37       	cp.w	r7,r8
800086f8:	c0 94       	brge	8000870a <_vfprintf_r+0x14e2>
800086fa:	fa c9 f9 44 	sub	r9,sp,-1724
800086fe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008702:	14 97       	mov	r7,r10
80008704:	ec fb fd 88 	ld.w	r11,r6[-632]
80008708:	c1 88       	rjmp	80008738 <_vfprintf_r+0x1510>
8000870a:	41 09       	lddsp	r9,sp[0x40]
8000870c:	59 f8       	cp.w	r8,31
8000870e:	e0 89 00 11 	brgt	80008730 <_vfprintf_r+0x1508>
80008712:	f2 cb ff fc 	sub	r11,r9,-4
80008716:	51 0b       	stdsp	sp[0x40],r11
80008718:	fa c6 f9 44 	sub	r6,sp,-1724
8000871c:	72 0b       	ld.w	r11,r9[0x0]
8000871e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008722:	f3 4b fd 88 	st.w	r9[-632],r11
80008726:	2f f8       	sub	r8,-1
80008728:	14 97       	mov	r7,r10
8000872a:	fb 48 06 b4 	st.w	sp[1716],r8
8000872e:	c0 58       	rjmp	80008738 <_vfprintf_r+0x1510>
80008730:	72 0b       	ld.w	r11,r9[0x0]
80008732:	14 97       	mov	r7,r10
80008734:	2f c9       	sub	r9,-4
80008736:	51 09       	stdsp	sp[0x40],r9
80008738:	50 1b       	stdsp	sp[0x4],r11
8000873a:	30 0e       	mov	lr,0
8000873c:	50 0e       	stdsp	sp[0x0],lr
8000873e:	40 08       	lddsp	r8,sp[0x0]
80008740:	40 1c       	lddsp	r12,sp[0x4]
80008742:	18 48       	or	r8,r12
80008744:	5f 19       	srne	r9
80008746:	0a 98       	mov	r8,r5
80008748:	eb e9 00 09 	and	r9,r5,r9
8000874c:	a1 b8       	sbr	r8,0x1
8000874e:	58 09       	cp.w	r9,0
80008750:	c0 70       	breq	8000875e <_vfprintf_r+0x1536>
80008752:	10 95       	mov	r5,r8
80008754:	fb 60 06 b9 	st.b	sp[1721],r0
80008758:	33 08       	mov	r8,48
8000875a:	fb 68 06 b8 	st.b	sp[1720],r8
8000875e:	30 28       	mov	r8,2
80008760:	30 09       	mov	r9,0
80008762:	fb 69 06 bb 	st.b	sp[1723],r9
80008766:	0a 99       	mov	r9,r5
80008768:	a7 d9       	cbr	r9,0x7
8000876a:	40 2b       	lddsp	r11,sp[0x8]
8000876c:	40 16       	lddsp	r6,sp[0x4]
8000876e:	58 0b       	cp.w	r11,0
80008770:	5f 1a       	srne	r10
80008772:	f2 05 17 40 	movge	r5,r9
80008776:	fa c2 f9 78 	sub	r2,sp,-1672
8000877a:	40 09       	lddsp	r9,sp[0x0]
8000877c:	0c 49       	or	r9,r6
8000877e:	5f 19       	srne	r9
80008780:	f5 e9 10 09 	or	r9,r10,r9
80008784:	c5 c0       	breq	8000883c <_vfprintf_r+0x1614>
80008786:	30 19       	mov	r9,1
80008788:	f2 08 18 00 	cp.b	r8,r9
8000878c:	c0 60       	breq	80008798 <_vfprintf_r+0x1570>
8000878e:	30 29       	mov	r9,2
80008790:	f2 08 18 00 	cp.b	r8,r9
80008794:	c0 41       	brne	8000879c <_vfprintf_r+0x1574>
80008796:	c3 c8       	rjmp	8000880e <_vfprintf_r+0x15e6>
80008798:	04 96       	mov	r6,r2
8000879a:	c3 08       	rjmp	800087fa <_vfprintf_r+0x15d2>
8000879c:	04 96       	mov	r6,r2
8000879e:	fa e8 00 00 	ld.d	r8,sp[0]
800087a2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800087a6:	2d 0a       	sub	r10,-48
800087a8:	0c fa       	st.b	--r6,r10
800087aa:	f0 0b 16 03 	lsr	r11,r8,0x3
800087ae:	f2 0c 16 03 	lsr	r12,r9,0x3
800087b2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800087b6:	18 99       	mov	r9,r12
800087b8:	16 98       	mov	r8,r11
800087ba:	58 08       	cp.w	r8,0
800087bc:	5c 29       	cpc	r9
800087be:	cf 21       	brne	800087a2 <_vfprintf_r+0x157a>
800087c0:	fa e9 00 00 	st.d	sp[0],r8
800087c4:	ed b5 00 00 	bld	r5,0x0
800087c8:	c4 51       	brne	80008852 <_vfprintf_r+0x162a>
800087ca:	33 09       	mov	r9,48
800087cc:	f2 0a 18 00 	cp.b	r10,r9
800087d0:	c4 10       	breq	80008852 <_vfprintf_r+0x162a>
800087d2:	0c f9       	st.b	--r6,r9
800087d4:	c3 f8       	rjmp	80008852 <_vfprintf_r+0x162a>
800087d6:	fa ea 00 00 	ld.d	r10,sp[0]
800087da:	30 a8       	mov	r8,10
800087dc:	30 09       	mov	r9,0
800087de:	e0 a0 1a 19 	rcall	8000bc10 <__avr32_umod64>
800087e2:	30 a8       	mov	r8,10
800087e4:	2d 0a       	sub	r10,-48
800087e6:	30 09       	mov	r9,0
800087e8:	ac 8a       	st.b	r6[0x0],r10
800087ea:	fa ea 00 00 	ld.d	r10,sp[0]
800087ee:	e0 a0 18 df 	rcall	8000b9ac <__avr32_udiv64>
800087f2:	16 99       	mov	r9,r11
800087f4:	14 98       	mov	r8,r10
800087f6:	fa e9 00 00 	st.d	sp[0],r8
800087fa:	20 16       	sub	r6,1
800087fc:	fa ea 00 00 	ld.d	r10,sp[0]
80008800:	58 9a       	cp.w	r10,9
80008802:	5c 2b       	cpc	r11
80008804:	fe 9b ff e9 	brhi	800087d6 <_vfprintf_r+0x15ae>
80008808:	1b f8       	ld.ub	r8,sp[0x7]
8000880a:	2d 08       	sub	r8,-48
8000880c:	c2 08       	rjmp	8000884c <_vfprintf_r+0x1624>
8000880e:	04 96       	mov	r6,r2
80008810:	fa e8 00 00 	ld.d	r8,sp[0]
80008814:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008818:	40 de       	lddsp	lr,sp[0x34]
8000881a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000881e:	0c fa       	st.b	--r6,r10
80008820:	f2 0b 16 04 	lsr	r11,r9,0x4
80008824:	f0 0a 16 04 	lsr	r10,r8,0x4
80008828:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000882c:	16 99       	mov	r9,r11
8000882e:	14 98       	mov	r8,r10
80008830:	58 08       	cp.w	r8,0
80008832:	5c 29       	cpc	r9
80008834:	cf 01       	brne	80008814 <_vfprintf_r+0x15ec>
80008836:	fa e9 00 00 	st.d	sp[0],r8
8000883a:	c0 c8       	rjmp	80008852 <_vfprintf_r+0x162a>
8000883c:	58 08       	cp.w	r8,0
8000883e:	c0 91       	brne	80008850 <_vfprintf_r+0x1628>
80008840:	ed b5 00 00 	bld	r5,0x0
80008844:	c0 61       	brne	80008850 <_vfprintf_r+0x1628>
80008846:	fa c6 f9 79 	sub	r6,sp,-1671
8000884a:	33 08       	mov	r8,48
8000884c:	ac 88       	st.b	r6[0x0],r8
8000884e:	c0 28       	rjmp	80008852 <_vfprintf_r+0x162a>
80008850:	04 96       	mov	r6,r2
80008852:	0c 12       	sub	r2,r6
80008854:	c1 c8       	rjmp	8000888c <_vfprintf_r+0x1664>
80008856:	50 a7       	stdsp	sp[0x28],r7
80008858:	50 80       	stdsp	sp[0x20],r0
8000885a:	40 93       	lddsp	r3,sp[0x24]
8000885c:	0c 97       	mov	r7,r6
8000885e:	10 90       	mov	r0,r8
80008860:	04 94       	mov	r4,r2
80008862:	40 41       	lddsp	r1,sp[0x10]
80008864:	58 08       	cp.w	r8,0
80008866:	e0 80 04 4f 	breq	80009104 <_vfprintf_r+0x1edc>
8000886a:	fb 68 06 60 	st.b	sp[1632],r8
8000886e:	30 0c       	mov	r12,0
80008870:	30 08       	mov	r8,0
80008872:	30 12       	mov	r2,1
80008874:	fb 68 06 bb 	st.b	sp[1723],r8
80008878:	50 2c       	stdsp	sp[0x8],r12
8000887a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000887e:	c0 78       	rjmp	8000888c <_vfprintf_r+0x1664>
80008880:	30 0b       	mov	r11,0
80008882:	50 2b       	stdsp	sp[0x8],r11
80008884:	c0 48       	rjmp	8000888c <_vfprintf_r+0x1664>
80008886:	40 22       	lddsp	r2,sp[0x8]
80008888:	30 0a       	mov	r10,0
8000888a:	50 2a       	stdsp	sp[0x8],r10
8000888c:	40 29       	lddsp	r9,sp[0x8]
8000888e:	e4 09 0c 49 	max	r9,r2,r9
80008892:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008896:	50 39       	stdsp	sp[0xc],r9
80008898:	0a 9e       	mov	lr,r5
8000889a:	30 09       	mov	r9,0
8000889c:	e2 1e 00 02 	andl	lr,0x2,COH
800088a0:	f2 08 18 00 	cp.b	r8,r9
800088a4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800088a8:	f7 b8 01 ff 	subne	r8,-1
800088ac:	fb f8 1a 03 	st.wne	sp[0xc],r8
800088b0:	0a 9b       	mov	r11,r5
800088b2:	58 0e       	cp.w	lr,0
800088b4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800088b8:	f7 bc 01 fe 	subne	r12,-2
800088bc:	fb fc 1a 03 	st.wne	sp[0xc],r12
800088c0:	e2 1b 00 84 	andl	r11,0x84,COH
800088c4:	50 fe       	stdsp	sp[0x3c],lr
800088c6:	50 9b       	stdsp	sp[0x24],r11
800088c8:	c4 71       	brne	80008956 <_vfprintf_r+0x172e>
800088ca:	40 8a       	lddsp	r10,sp[0x20]
800088cc:	40 39       	lddsp	r9,sp[0xc]
800088ce:	12 1a       	sub	r10,r9
800088d0:	50 4a       	stdsp	sp[0x10],r10
800088d2:	58 0a       	cp.w	r10,0
800088d4:	e0 89 00 20 	brgt	80008914 <_vfprintf_r+0x16ec>
800088d8:	c3 f8       	rjmp	80008956 <_vfprintf_r+0x172e>
800088da:	2f 09       	sub	r9,-16
800088dc:	2f f8       	sub	r8,-1
800088de:	fe ce b6 3a 	sub	lr,pc,-18886
800088e2:	31 0c       	mov	r12,16
800088e4:	fb 49 06 90 	st.w	sp[1680],r9
800088e8:	87 0e       	st.w	r3[0x0],lr
800088ea:	87 1c       	st.w	r3[0x4],r12
800088ec:	fb 48 06 8c 	st.w	sp[1676],r8
800088f0:	58 78       	cp.w	r8,7
800088f2:	e0 89 00 04 	brgt	800088fa <_vfprintf_r+0x16d2>
800088f6:	2f 83       	sub	r3,-8
800088f8:	c0 b8       	rjmp	8000890e <_vfprintf_r+0x16e6>
800088fa:	fa ca f9 78 	sub	r10,sp,-1672
800088fe:	02 9b       	mov	r11,r1
80008900:	08 9c       	mov	r12,r4
80008902:	fe b0 f4 85 	rcall	8000720c <__sprint_r>
80008906:	e0 81 04 10 	brne	80009126 <_vfprintf_r+0x1efe>
8000890a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000890e:	40 4b       	lddsp	r11,sp[0x10]
80008910:	21 0b       	sub	r11,16
80008912:	50 4b       	stdsp	sp[0x10],r11
80008914:	fa f9 06 90 	ld.w	r9,sp[1680]
80008918:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000891c:	fe ca b6 78 	sub	r10,pc,-18824
80008920:	40 4e       	lddsp	lr,sp[0x10]
80008922:	59 0e       	cp.w	lr,16
80008924:	fe 99 ff db 	brgt	800088da <_vfprintf_r+0x16b2>
80008928:	1c 09       	add	r9,lr
8000892a:	2f f8       	sub	r8,-1
8000892c:	87 0a       	st.w	r3[0x0],r10
8000892e:	fb 49 06 90 	st.w	sp[1680],r9
80008932:	87 1e       	st.w	r3[0x4],lr
80008934:	fb 48 06 8c 	st.w	sp[1676],r8
80008938:	58 78       	cp.w	r8,7
8000893a:	e0 89 00 04 	brgt	80008942 <_vfprintf_r+0x171a>
8000893e:	2f 83       	sub	r3,-8
80008940:	c0 b8       	rjmp	80008956 <_vfprintf_r+0x172e>
80008942:	fa ca f9 78 	sub	r10,sp,-1672
80008946:	02 9b       	mov	r11,r1
80008948:	08 9c       	mov	r12,r4
8000894a:	fe b0 f4 61 	rcall	8000720c <__sprint_r>
8000894e:	e0 81 03 ec 	brne	80009126 <_vfprintf_r+0x1efe>
80008952:	fa c3 f9 e0 	sub	r3,sp,-1568
80008956:	30 09       	mov	r9,0
80008958:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000895c:	f2 08 18 00 	cp.b	r8,r9
80008960:	c1 f0       	breq	8000899e <_vfprintf_r+0x1776>
80008962:	fa f8 06 90 	ld.w	r8,sp[1680]
80008966:	fa c9 f9 45 	sub	r9,sp,-1723
8000896a:	2f f8       	sub	r8,-1
8000896c:	87 09       	st.w	r3[0x0],r9
8000896e:	fb 48 06 90 	st.w	sp[1680],r8
80008972:	30 19       	mov	r9,1
80008974:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008978:	87 19       	st.w	r3[0x4],r9
8000897a:	2f f8       	sub	r8,-1
8000897c:	fb 48 06 8c 	st.w	sp[1676],r8
80008980:	58 78       	cp.w	r8,7
80008982:	e0 89 00 04 	brgt	8000898a <_vfprintf_r+0x1762>
80008986:	2f 83       	sub	r3,-8
80008988:	c0 b8       	rjmp	8000899e <_vfprintf_r+0x1776>
8000898a:	fa ca f9 78 	sub	r10,sp,-1672
8000898e:	02 9b       	mov	r11,r1
80008990:	08 9c       	mov	r12,r4
80008992:	fe b0 f4 3d 	rcall	8000720c <__sprint_r>
80008996:	e0 81 03 c8 	brne	80009126 <_vfprintf_r+0x1efe>
8000899a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000899e:	40 fc       	lddsp	r12,sp[0x3c]
800089a0:	58 0c       	cp.w	r12,0
800089a2:	c1 f0       	breq	800089e0 <_vfprintf_r+0x17b8>
800089a4:	fa f8 06 90 	ld.w	r8,sp[1680]
800089a8:	fa c9 f9 48 	sub	r9,sp,-1720
800089ac:	2f e8       	sub	r8,-2
800089ae:	87 09       	st.w	r3[0x0],r9
800089b0:	fb 48 06 90 	st.w	sp[1680],r8
800089b4:	30 29       	mov	r9,2
800089b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089ba:	87 19       	st.w	r3[0x4],r9
800089bc:	2f f8       	sub	r8,-1
800089be:	fb 48 06 8c 	st.w	sp[1676],r8
800089c2:	58 78       	cp.w	r8,7
800089c4:	e0 89 00 04 	brgt	800089cc <_vfprintf_r+0x17a4>
800089c8:	2f 83       	sub	r3,-8
800089ca:	c0 b8       	rjmp	800089e0 <_vfprintf_r+0x17b8>
800089cc:	fa ca f9 78 	sub	r10,sp,-1672
800089d0:	02 9b       	mov	r11,r1
800089d2:	08 9c       	mov	r12,r4
800089d4:	fe b0 f4 1c 	rcall	8000720c <__sprint_r>
800089d8:	e0 81 03 a7 	brne	80009126 <_vfprintf_r+0x1efe>
800089dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800089e0:	40 9b       	lddsp	r11,sp[0x24]
800089e2:	e0 4b 00 80 	cp.w	r11,128
800089e6:	c4 71       	brne	80008a74 <_vfprintf_r+0x184c>
800089e8:	40 8a       	lddsp	r10,sp[0x20]
800089ea:	40 39       	lddsp	r9,sp[0xc]
800089ec:	12 1a       	sub	r10,r9
800089ee:	50 4a       	stdsp	sp[0x10],r10
800089f0:	58 0a       	cp.w	r10,0
800089f2:	e0 89 00 20 	brgt	80008a32 <_vfprintf_r+0x180a>
800089f6:	c3 f8       	rjmp	80008a74 <_vfprintf_r+0x184c>
800089f8:	2f 09       	sub	r9,-16
800089fa:	2f f8       	sub	r8,-1
800089fc:	fe ce b7 48 	sub	lr,pc,-18616
80008a00:	31 0c       	mov	r12,16
80008a02:	fb 49 06 90 	st.w	sp[1680],r9
80008a06:	87 0e       	st.w	r3[0x0],lr
80008a08:	87 1c       	st.w	r3[0x4],r12
80008a0a:	fb 48 06 8c 	st.w	sp[1676],r8
80008a0e:	58 78       	cp.w	r8,7
80008a10:	e0 89 00 04 	brgt	80008a18 <_vfprintf_r+0x17f0>
80008a14:	2f 83       	sub	r3,-8
80008a16:	c0 b8       	rjmp	80008a2c <_vfprintf_r+0x1804>
80008a18:	fa ca f9 78 	sub	r10,sp,-1672
80008a1c:	02 9b       	mov	r11,r1
80008a1e:	08 9c       	mov	r12,r4
80008a20:	fe b0 f3 f6 	rcall	8000720c <__sprint_r>
80008a24:	e0 81 03 81 	brne	80009126 <_vfprintf_r+0x1efe>
80008a28:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a2c:	40 4b       	lddsp	r11,sp[0x10]
80008a2e:	21 0b       	sub	r11,16
80008a30:	50 4b       	stdsp	sp[0x10],r11
80008a32:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a36:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a3a:	fe ca b7 86 	sub	r10,pc,-18554
80008a3e:	40 4e       	lddsp	lr,sp[0x10]
80008a40:	59 0e       	cp.w	lr,16
80008a42:	fe 99 ff db 	brgt	800089f8 <_vfprintf_r+0x17d0>
80008a46:	1c 09       	add	r9,lr
80008a48:	2f f8       	sub	r8,-1
80008a4a:	87 0a       	st.w	r3[0x0],r10
80008a4c:	fb 49 06 90 	st.w	sp[1680],r9
80008a50:	87 1e       	st.w	r3[0x4],lr
80008a52:	fb 48 06 8c 	st.w	sp[1676],r8
80008a56:	58 78       	cp.w	r8,7
80008a58:	e0 89 00 04 	brgt	80008a60 <_vfprintf_r+0x1838>
80008a5c:	2f 83       	sub	r3,-8
80008a5e:	c0 b8       	rjmp	80008a74 <_vfprintf_r+0x184c>
80008a60:	fa ca f9 78 	sub	r10,sp,-1672
80008a64:	02 9b       	mov	r11,r1
80008a66:	08 9c       	mov	r12,r4
80008a68:	fe b0 f3 d2 	rcall	8000720c <__sprint_r>
80008a6c:	e0 81 03 5d 	brne	80009126 <_vfprintf_r+0x1efe>
80008a70:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a74:	40 2c       	lddsp	r12,sp[0x8]
80008a76:	04 1c       	sub	r12,r2
80008a78:	50 2c       	stdsp	sp[0x8],r12
80008a7a:	58 0c       	cp.w	r12,0
80008a7c:	e0 89 00 20 	brgt	80008abc <_vfprintf_r+0x1894>
80008a80:	c3 f8       	rjmp	80008afe <_vfprintf_r+0x18d6>
80008a82:	2f 09       	sub	r9,-16
80008a84:	2f f8       	sub	r8,-1
80008a86:	fe cb b7 d2 	sub	r11,pc,-18478
80008a8a:	31 0a       	mov	r10,16
80008a8c:	fb 49 06 90 	st.w	sp[1680],r9
80008a90:	87 0b       	st.w	r3[0x0],r11
80008a92:	87 1a       	st.w	r3[0x4],r10
80008a94:	fb 48 06 8c 	st.w	sp[1676],r8
80008a98:	58 78       	cp.w	r8,7
80008a9a:	e0 89 00 04 	brgt	80008aa2 <_vfprintf_r+0x187a>
80008a9e:	2f 83       	sub	r3,-8
80008aa0:	c0 b8       	rjmp	80008ab6 <_vfprintf_r+0x188e>
80008aa2:	fa ca f9 78 	sub	r10,sp,-1672
80008aa6:	02 9b       	mov	r11,r1
80008aa8:	08 9c       	mov	r12,r4
80008aaa:	fe b0 f3 b1 	rcall	8000720c <__sprint_r>
80008aae:	e0 81 03 3c 	brne	80009126 <_vfprintf_r+0x1efe>
80008ab2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ab6:	40 29       	lddsp	r9,sp[0x8]
80008ab8:	21 09       	sub	r9,16
80008aba:	50 29       	stdsp	sp[0x8],r9
80008abc:	fa f9 06 90 	ld.w	r9,sp[1680]
80008ac0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ac4:	fe ca b8 10 	sub	r10,pc,-18416
80008ac8:	40 2e       	lddsp	lr,sp[0x8]
80008aca:	59 0e       	cp.w	lr,16
80008acc:	fe 99 ff db 	brgt	80008a82 <_vfprintf_r+0x185a>
80008ad0:	1c 09       	add	r9,lr
80008ad2:	2f f8       	sub	r8,-1
80008ad4:	87 0a       	st.w	r3[0x0],r10
80008ad6:	fb 49 06 90 	st.w	sp[1680],r9
80008ada:	87 1e       	st.w	r3[0x4],lr
80008adc:	fb 48 06 8c 	st.w	sp[1676],r8
80008ae0:	58 78       	cp.w	r8,7
80008ae2:	e0 89 00 04 	brgt	80008aea <_vfprintf_r+0x18c2>
80008ae6:	2f 83       	sub	r3,-8
80008ae8:	c0 b8       	rjmp	80008afe <_vfprintf_r+0x18d6>
80008aea:	fa ca f9 78 	sub	r10,sp,-1672
80008aee:	02 9b       	mov	r11,r1
80008af0:	08 9c       	mov	r12,r4
80008af2:	fe b0 f3 8d 	rcall	8000720c <__sprint_r>
80008af6:	e0 81 03 18 	brne	80009126 <_vfprintf_r+0x1efe>
80008afa:	fa c3 f9 e0 	sub	r3,sp,-1568
80008afe:	ed b5 00 08 	bld	r5,0x8
80008b02:	c0 b0       	breq	80008b18 <_vfprintf_r+0x18f0>
80008b04:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b08:	87 12       	st.w	r3[0x4],r2
80008b0a:	87 06       	st.w	r3[0x0],r6
80008b0c:	f0 02 00 02 	add	r2,r8,r2
80008b10:	fb 42 06 90 	st.w	sp[1680],r2
80008b14:	e0 8f 01 d4 	bral	80008ebc <_vfprintf_r+0x1c94>
80008b18:	e0 40 00 65 	cp.w	r0,101
80008b1c:	e0 8a 01 d6 	brle	80008ec8 <_vfprintf_r+0x1ca0>
80008b20:	30 08       	mov	r8,0
80008b22:	30 09       	mov	r9,0
80008b24:	40 5b       	lddsp	r11,sp[0x14]
80008b26:	40 7a       	lddsp	r10,sp[0x1c]
80008b28:	e0 a0 15 3b 	rcall	8000b59e <__avr32_f64_cmp_eq>
80008b2c:	c7 90       	breq	80008c1e <_vfprintf_r+0x19f6>
80008b2e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b32:	fe c9 b8 92 	sub	r9,pc,-18286
80008b36:	2f f8       	sub	r8,-1
80008b38:	87 09       	st.w	r3[0x0],r9
80008b3a:	fb 48 06 90 	st.w	sp[1680],r8
80008b3e:	30 19       	mov	r9,1
80008b40:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b44:	87 19       	st.w	r3[0x4],r9
80008b46:	2f f8       	sub	r8,-1
80008b48:	fb 48 06 8c 	st.w	sp[1676],r8
80008b4c:	58 78       	cp.w	r8,7
80008b4e:	e0 89 00 05 	brgt	80008b58 <_vfprintf_r+0x1930>
80008b52:	2f 83       	sub	r3,-8
80008b54:	c0 c8       	rjmp	80008b6c <_vfprintf_r+0x1944>
80008b56:	d7 03       	nop
80008b58:	fa ca f9 78 	sub	r10,sp,-1672
80008b5c:	02 9b       	mov	r11,r1
80008b5e:	08 9c       	mov	r12,r4
80008b60:	fe b0 f3 56 	rcall	8000720c <__sprint_r>
80008b64:	e0 81 02 e1 	brne	80009126 <_vfprintf_r+0x1efe>
80008b68:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b6c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b70:	40 6c       	lddsp	r12,sp[0x18]
80008b72:	18 38       	cp.w	r8,r12
80008b74:	c0 55       	brlt	80008b7e <_vfprintf_r+0x1956>
80008b76:	ed b5 00 00 	bld	r5,0x0
80008b7a:	e0 81 02 6b 	brne	80009050 <_vfprintf_r+0x1e28>
80008b7e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b82:	2f f8       	sub	r8,-1
80008b84:	40 cb       	lddsp	r11,sp[0x30]
80008b86:	fb 48 06 90 	st.w	sp[1680],r8
80008b8a:	30 19       	mov	r9,1
80008b8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b90:	87 0b       	st.w	r3[0x0],r11
80008b92:	2f f8       	sub	r8,-1
80008b94:	87 19       	st.w	r3[0x4],r9
80008b96:	fb 48 06 8c 	st.w	sp[1676],r8
80008b9a:	58 78       	cp.w	r8,7
80008b9c:	e0 89 00 04 	brgt	80008ba4 <_vfprintf_r+0x197c>
80008ba0:	2f 83       	sub	r3,-8
80008ba2:	c0 b8       	rjmp	80008bb8 <_vfprintf_r+0x1990>
80008ba4:	fa ca f9 78 	sub	r10,sp,-1672
80008ba8:	02 9b       	mov	r11,r1
80008baa:	08 9c       	mov	r12,r4
80008bac:	fe b0 f3 30 	rcall	8000720c <__sprint_r>
80008bb0:	e0 81 02 bb 	brne	80009126 <_vfprintf_r+0x1efe>
80008bb4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bb8:	40 66       	lddsp	r6,sp[0x18]
80008bba:	20 16       	sub	r6,1
80008bbc:	58 06       	cp.w	r6,0
80008bbe:	e0 89 00 1d 	brgt	80008bf8 <_vfprintf_r+0x19d0>
80008bc2:	e0 8f 02 47 	bral	80009050 <_vfprintf_r+0x1e28>
80008bc6:	2f 09       	sub	r9,-16
80008bc8:	2f f8       	sub	r8,-1
80008bca:	fb 49 06 90 	st.w	sp[1680],r9
80008bce:	87 02       	st.w	r3[0x0],r2
80008bd0:	87 10       	st.w	r3[0x4],r0
80008bd2:	fb 48 06 8c 	st.w	sp[1676],r8
80008bd6:	58 78       	cp.w	r8,7
80008bd8:	e0 89 00 04 	brgt	80008be0 <_vfprintf_r+0x19b8>
80008bdc:	2f 83       	sub	r3,-8
80008bde:	c0 b8       	rjmp	80008bf4 <_vfprintf_r+0x19cc>
80008be0:	fa ca f9 78 	sub	r10,sp,-1672
80008be4:	02 9b       	mov	r11,r1
80008be6:	08 9c       	mov	r12,r4
80008be8:	fe b0 f3 12 	rcall	8000720c <__sprint_r>
80008bec:	e0 81 02 9d 	brne	80009126 <_vfprintf_r+0x1efe>
80008bf0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bf4:	21 06       	sub	r6,16
80008bf6:	c0 48       	rjmp	80008bfe <_vfprintf_r+0x19d6>
80008bf8:	fe c2 b9 44 	sub	r2,pc,-18108
80008bfc:	31 00       	mov	r0,16
80008bfe:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c06:	fe ca b9 52 	sub	r10,pc,-18094
80008c0a:	59 06       	cp.w	r6,16
80008c0c:	fe 99 ff dd 	brgt	80008bc6 <_vfprintf_r+0x199e>
80008c10:	0c 09       	add	r9,r6
80008c12:	87 0a       	st.w	r3[0x0],r10
80008c14:	fb 49 06 90 	st.w	sp[1680],r9
80008c18:	2f f8       	sub	r8,-1
80008c1a:	87 16       	st.w	r3[0x4],r6
80008c1c:	c5 39       	rjmp	80008ec2 <_vfprintf_r+0x1c9a>
80008c1e:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008c22:	58 0a       	cp.w	r10,0
80008c24:	e0 89 00 92 	brgt	80008d48 <_vfprintf_r+0x1b20>
80008c28:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c2c:	fe c9 b9 8c 	sub	r9,pc,-18036
80008c30:	2f f8       	sub	r8,-1
80008c32:	87 09       	st.w	r3[0x0],r9
80008c34:	fb 48 06 90 	st.w	sp[1680],r8
80008c38:	30 19       	mov	r9,1
80008c3a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c3e:	87 19       	st.w	r3[0x4],r9
80008c40:	2f f8       	sub	r8,-1
80008c42:	fb 48 06 8c 	st.w	sp[1676],r8
80008c46:	58 78       	cp.w	r8,7
80008c48:	e0 89 00 04 	brgt	80008c50 <_vfprintf_r+0x1a28>
80008c4c:	2f 83       	sub	r3,-8
80008c4e:	c0 b8       	rjmp	80008c64 <_vfprintf_r+0x1a3c>
80008c50:	fa ca f9 78 	sub	r10,sp,-1672
80008c54:	02 9b       	mov	r11,r1
80008c56:	08 9c       	mov	r12,r4
80008c58:	fe b0 f2 da 	rcall	8000720c <__sprint_r>
80008c5c:	e0 81 02 65 	brne	80009126 <_vfprintf_r+0x1efe>
80008c60:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c64:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008c68:	58 08       	cp.w	r8,0
80008c6a:	c0 81       	brne	80008c7a <_vfprintf_r+0x1a52>
80008c6c:	40 6a       	lddsp	r10,sp[0x18]
80008c6e:	58 0a       	cp.w	r10,0
80008c70:	c0 51       	brne	80008c7a <_vfprintf_r+0x1a52>
80008c72:	ed b5 00 00 	bld	r5,0x0
80008c76:	e0 81 01 ed 	brne	80009050 <_vfprintf_r+0x1e28>
80008c7a:	40 c9       	lddsp	r9,sp[0x30]
80008c7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c80:	2f f8       	sub	r8,-1
80008c82:	87 09       	st.w	r3[0x0],r9
80008c84:	fb 48 06 90 	st.w	sp[1680],r8
80008c88:	30 19       	mov	r9,1
80008c8a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c8e:	87 19       	st.w	r3[0x4],r9
80008c90:	2f f8       	sub	r8,-1
80008c92:	fb 48 06 8c 	st.w	sp[1676],r8
80008c96:	58 78       	cp.w	r8,7
80008c98:	e0 89 00 04 	brgt	80008ca0 <_vfprintf_r+0x1a78>
80008c9c:	2f 83       	sub	r3,-8
80008c9e:	c0 b8       	rjmp	80008cb4 <_vfprintf_r+0x1a8c>
80008ca0:	fa ca f9 78 	sub	r10,sp,-1672
80008ca4:	02 9b       	mov	r11,r1
80008ca6:	08 9c       	mov	r12,r4
80008ca8:	fe b0 f2 b2 	rcall	8000720c <__sprint_r>
80008cac:	e0 81 02 3d 	brne	80009126 <_vfprintf_r+0x1efe>
80008cb0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cb4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008cb8:	5c 32       	neg	r2
80008cba:	58 02       	cp.w	r2,0
80008cbc:	e0 89 00 1d 	brgt	80008cf6 <_vfprintf_r+0x1ace>
80008cc0:	c3 d8       	rjmp	80008d3a <_vfprintf_r+0x1b12>
80008cc2:	2f 09       	sub	r9,-16
80008cc4:	2f f8       	sub	r8,-1
80008cc6:	31 0e       	mov	lr,16
80008cc8:	fb 49 06 90 	st.w	sp[1680],r9
80008ccc:	87 00       	st.w	r3[0x0],r0
80008cce:	87 1e       	st.w	r3[0x4],lr
80008cd0:	fb 48 06 8c 	st.w	sp[1676],r8
80008cd4:	58 78       	cp.w	r8,7
80008cd6:	e0 89 00 04 	brgt	80008cde <_vfprintf_r+0x1ab6>
80008cda:	2f 83       	sub	r3,-8
80008cdc:	c0 b8       	rjmp	80008cf2 <_vfprintf_r+0x1aca>
80008cde:	fa ca f9 78 	sub	r10,sp,-1672
80008ce2:	02 9b       	mov	r11,r1
80008ce4:	08 9c       	mov	r12,r4
80008ce6:	fe b0 f2 93 	rcall	8000720c <__sprint_r>
80008cea:	e0 81 02 1e 	brne	80009126 <_vfprintf_r+0x1efe>
80008cee:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cf2:	21 02       	sub	r2,16
80008cf4:	c0 38       	rjmp	80008cfa <_vfprintf_r+0x1ad2>
80008cf6:	fe c0 ba 42 	sub	r0,pc,-17854
80008cfa:	fa f9 06 90 	ld.w	r9,sp[1680]
80008cfe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d02:	fe ca ba 4e 	sub	r10,pc,-17842
80008d06:	59 02       	cp.w	r2,16
80008d08:	fe 99 ff dd 	brgt	80008cc2 <_vfprintf_r+0x1a9a>
80008d0c:	04 09       	add	r9,r2
80008d0e:	2f f8       	sub	r8,-1
80008d10:	87 0a       	st.w	r3[0x0],r10
80008d12:	fb 49 06 90 	st.w	sp[1680],r9
80008d16:	87 12       	st.w	r3[0x4],r2
80008d18:	fb 48 06 8c 	st.w	sp[1676],r8
80008d1c:	58 78       	cp.w	r8,7
80008d1e:	e0 89 00 04 	brgt	80008d26 <_vfprintf_r+0x1afe>
80008d22:	2f 83       	sub	r3,-8
80008d24:	c0 b8       	rjmp	80008d3a <_vfprintf_r+0x1b12>
80008d26:	fa ca f9 78 	sub	r10,sp,-1672
80008d2a:	02 9b       	mov	r11,r1
80008d2c:	08 9c       	mov	r12,r4
80008d2e:	fe b0 f2 6f 	rcall	8000720c <__sprint_r>
80008d32:	e0 81 01 fa 	brne	80009126 <_vfprintf_r+0x1efe>
80008d36:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d3a:	40 6c       	lddsp	r12,sp[0x18]
80008d3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d40:	87 06       	st.w	r3[0x0],r6
80008d42:	87 1c       	st.w	r3[0x4],r12
80008d44:	18 08       	add	r8,r12
80008d46:	cb 98       	rjmp	80008eb8 <_vfprintf_r+0x1c90>
80008d48:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d50:	40 6b       	lddsp	r11,sp[0x18]
80008d52:	16 3a       	cp.w	r10,r11
80008d54:	c6 f5       	brlt	80008e32 <_vfprintf_r+0x1c0a>
80008d56:	16 09       	add	r9,r11
80008d58:	2f f8       	sub	r8,-1
80008d5a:	87 06       	st.w	r3[0x0],r6
80008d5c:	fb 49 06 90 	st.w	sp[1680],r9
80008d60:	87 1b       	st.w	r3[0x4],r11
80008d62:	fb 48 06 8c 	st.w	sp[1676],r8
80008d66:	58 78       	cp.w	r8,7
80008d68:	e0 89 00 04 	brgt	80008d70 <_vfprintf_r+0x1b48>
80008d6c:	2f 83       	sub	r3,-8
80008d6e:	c0 b8       	rjmp	80008d84 <_vfprintf_r+0x1b5c>
80008d70:	fa ca f9 78 	sub	r10,sp,-1672
80008d74:	02 9b       	mov	r11,r1
80008d76:	08 9c       	mov	r12,r4
80008d78:	fe b0 f2 4a 	rcall	8000720c <__sprint_r>
80008d7c:	e0 81 01 d5 	brne	80009126 <_vfprintf_r+0x1efe>
80008d80:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d84:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008d88:	40 6a       	lddsp	r10,sp[0x18]
80008d8a:	14 16       	sub	r6,r10
80008d8c:	58 06       	cp.w	r6,0
80008d8e:	e0 89 00 1c 	brgt	80008dc6 <_vfprintf_r+0x1b9e>
80008d92:	c3 d8       	rjmp	80008e0c <_vfprintf_r+0x1be4>
80008d94:	2f 09       	sub	r9,-16
80008d96:	2f f8       	sub	r8,-1
80008d98:	fb 49 06 90 	st.w	sp[1680],r9
80008d9c:	87 02       	st.w	r3[0x0],r2
80008d9e:	87 10       	st.w	r3[0x4],r0
80008da0:	fb 48 06 8c 	st.w	sp[1676],r8
80008da4:	58 78       	cp.w	r8,7
80008da6:	e0 89 00 04 	brgt	80008dae <_vfprintf_r+0x1b86>
80008daa:	2f 83       	sub	r3,-8
80008dac:	c0 b8       	rjmp	80008dc2 <_vfprintf_r+0x1b9a>
80008dae:	fa ca f9 78 	sub	r10,sp,-1672
80008db2:	02 9b       	mov	r11,r1
80008db4:	08 9c       	mov	r12,r4
80008db6:	fe b0 f2 2b 	rcall	8000720c <__sprint_r>
80008dba:	e0 81 01 b6 	brne	80009126 <_vfprintf_r+0x1efe>
80008dbe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dc2:	21 06       	sub	r6,16
80008dc4:	c0 48       	rjmp	80008dcc <_vfprintf_r+0x1ba4>
80008dc6:	fe c2 bb 12 	sub	r2,pc,-17646
80008dca:	31 00       	mov	r0,16
80008dcc:	fa f9 06 90 	ld.w	r9,sp[1680]
80008dd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008dd4:	fe ca bb 20 	sub	r10,pc,-17632
80008dd8:	59 06       	cp.w	r6,16
80008dda:	fe 99 ff dd 	brgt	80008d94 <_vfprintf_r+0x1b6c>
80008dde:	0c 09       	add	r9,r6
80008de0:	2f f8       	sub	r8,-1
80008de2:	87 0a       	st.w	r3[0x0],r10
80008de4:	fb 49 06 90 	st.w	sp[1680],r9
80008de8:	87 16       	st.w	r3[0x4],r6
80008dea:	fb 48 06 8c 	st.w	sp[1676],r8
80008dee:	58 78       	cp.w	r8,7
80008df0:	e0 89 00 04 	brgt	80008df8 <_vfprintf_r+0x1bd0>
80008df4:	2f 83       	sub	r3,-8
80008df6:	c0 b8       	rjmp	80008e0c <_vfprintf_r+0x1be4>
80008df8:	fa ca f9 78 	sub	r10,sp,-1672
80008dfc:	02 9b       	mov	r11,r1
80008dfe:	08 9c       	mov	r12,r4
80008e00:	fe b0 f2 06 	rcall	8000720c <__sprint_r>
80008e04:	e0 81 01 91 	brne	80009126 <_vfprintf_r+0x1efe>
80008e08:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e0c:	ed b5 00 00 	bld	r5,0x0
80008e10:	e0 81 01 20 	brne	80009050 <_vfprintf_r+0x1e28>
80008e14:	40 c9       	lddsp	r9,sp[0x30]
80008e16:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e1a:	2f f8       	sub	r8,-1
80008e1c:	87 09       	st.w	r3[0x0],r9
80008e1e:	fb 48 06 90 	st.w	sp[1680],r8
80008e22:	30 19       	mov	r9,1
80008e24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e28:	87 19       	st.w	r3[0x4],r9
80008e2a:	2f f8       	sub	r8,-1
80008e2c:	fb 48 06 8c 	st.w	sp[1676],r8
80008e30:	c0 29       	rjmp	80009034 <_vfprintf_r+0x1e0c>
80008e32:	14 09       	add	r9,r10
80008e34:	2f f8       	sub	r8,-1
80008e36:	fb 49 06 90 	st.w	sp[1680],r9
80008e3a:	87 06       	st.w	r3[0x0],r6
80008e3c:	87 1a       	st.w	r3[0x4],r10
80008e3e:	fb 48 06 8c 	st.w	sp[1676],r8
80008e42:	58 78       	cp.w	r8,7
80008e44:	e0 89 00 04 	brgt	80008e4c <_vfprintf_r+0x1c24>
80008e48:	2f 83       	sub	r3,-8
80008e4a:	c0 b8       	rjmp	80008e60 <_vfprintf_r+0x1c38>
80008e4c:	fa ca f9 78 	sub	r10,sp,-1672
80008e50:	02 9b       	mov	r11,r1
80008e52:	08 9c       	mov	r12,r4
80008e54:	fe b0 f1 dc 	rcall	8000720c <__sprint_r>
80008e58:	e0 81 01 67 	brne	80009126 <_vfprintf_r+0x1efe>
80008e5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e60:	40 c8       	lddsp	r8,sp[0x30]
80008e62:	87 08       	st.w	r3[0x0],r8
80008e64:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e68:	2f f8       	sub	r8,-1
80008e6a:	30 19       	mov	r9,1
80008e6c:	fb 48 06 90 	st.w	sp[1680],r8
80008e70:	87 19       	st.w	r3[0x4],r9
80008e72:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e76:	2f f8       	sub	r8,-1
80008e78:	fb 48 06 8c 	st.w	sp[1676],r8
80008e7c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008e80:	58 78       	cp.w	r8,7
80008e82:	e0 89 00 04 	brgt	80008e8a <_vfprintf_r+0x1c62>
80008e86:	2f 83       	sub	r3,-8
80008e88:	c0 b8       	rjmp	80008e9e <_vfprintf_r+0x1c76>
80008e8a:	fa ca f9 78 	sub	r10,sp,-1672
80008e8e:	02 9b       	mov	r11,r1
80008e90:	08 9c       	mov	r12,r4
80008e92:	fe b0 f1 bd 	rcall	8000720c <__sprint_r>
80008e96:	e0 81 01 48 	brne	80009126 <_vfprintf_r+0x1efe>
80008e9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e9e:	04 06       	add	r6,r2
80008ea0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ea4:	87 06       	st.w	r3[0x0],r6
80008ea6:	fa f9 06 90 	ld.w	r9,sp[1680]
80008eaa:	40 66       	lddsp	r6,sp[0x18]
80008eac:	40 6e       	lddsp	lr,sp[0x18]
80008eae:	10 16       	sub	r6,r8
80008eb0:	f2 08 01 08 	sub	r8,r9,r8
80008eb4:	87 16       	st.w	r3[0x4],r6
80008eb6:	1c 08       	add	r8,lr
80008eb8:	fb 48 06 90 	st.w	sp[1680],r8
80008ebc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ec0:	2f f8       	sub	r8,-1
80008ec2:	fb 48 06 8c 	st.w	sp[1676],r8
80008ec6:	cb 78       	rjmp	80009034 <_vfprintf_r+0x1e0c>
80008ec8:	40 6c       	lddsp	r12,sp[0x18]
80008eca:	58 1c       	cp.w	r12,1
80008ecc:	e0 89 00 06 	brgt	80008ed8 <_vfprintf_r+0x1cb0>
80008ed0:	ed b5 00 00 	bld	r5,0x0
80008ed4:	e0 81 00 85 	brne	80008fde <_vfprintf_r+0x1db6>
80008ed8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008edc:	2f f8       	sub	r8,-1
80008ede:	30 19       	mov	r9,1
80008ee0:	fb 48 06 90 	st.w	sp[1680],r8
80008ee4:	87 06       	st.w	r3[0x0],r6
80008ee6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008eea:	87 19       	st.w	r3[0x4],r9
80008eec:	2f f8       	sub	r8,-1
80008eee:	fb 48 06 8c 	st.w	sp[1676],r8
80008ef2:	58 78       	cp.w	r8,7
80008ef4:	e0 89 00 04 	brgt	80008efc <_vfprintf_r+0x1cd4>
80008ef8:	2f 83       	sub	r3,-8
80008efa:	c0 b8       	rjmp	80008f10 <_vfprintf_r+0x1ce8>
80008efc:	fa ca f9 78 	sub	r10,sp,-1672
80008f00:	02 9b       	mov	r11,r1
80008f02:	08 9c       	mov	r12,r4
80008f04:	fe b0 f1 84 	rcall	8000720c <__sprint_r>
80008f08:	e0 81 01 0f 	brne	80009126 <_vfprintf_r+0x1efe>
80008f0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f10:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f14:	2f f8       	sub	r8,-1
80008f16:	40 cb       	lddsp	r11,sp[0x30]
80008f18:	fb 48 06 90 	st.w	sp[1680],r8
80008f1c:	30 19       	mov	r9,1
80008f1e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f22:	87 0b       	st.w	r3[0x0],r11
80008f24:	2f f8       	sub	r8,-1
80008f26:	87 19       	st.w	r3[0x4],r9
80008f28:	fb 48 06 8c 	st.w	sp[1676],r8
80008f2c:	58 78       	cp.w	r8,7
80008f2e:	e0 89 00 05 	brgt	80008f38 <_vfprintf_r+0x1d10>
80008f32:	2f 83       	sub	r3,-8
80008f34:	c0 c8       	rjmp	80008f4c <_vfprintf_r+0x1d24>
80008f36:	d7 03       	nop
80008f38:	fa ca f9 78 	sub	r10,sp,-1672
80008f3c:	02 9b       	mov	r11,r1
80008f3e:	08 9c       	mov	r12,r4
80008f40:	fe b0 f1 66 	rcall	8000720c <__sprint_r>
80008f44:	e0 81 00 f1 	brne	80009126 <_vfprintf_r+0x1efe>
80008f48:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f4c:	30 08       	mov	r8,0
80008f4e:	30 09       	mov	r9,0
80008f50:	40 5b       	lddsp	r11,sp[0x14]
80008f52:	40 7a       	lddsp	r10,sp[0x1c]
80008f54:	e0 a0 13 25 	rcall	8000b59e <__avr32_f64_cmp_eq>
80008f58:	40 68       	lddsp	r8,sp[0x18]
80008f5a:	20 18       	sub	r8,1
80008f5c:	58 0c       	cp.w	r12,0
80008f5e:	c0 d1       	brne	80008f78 <_vfprintf_r+0x1d50>
80008f60:	2f f6       	sub	r6,-1
80008f62:	87 18       	st.w	r3[0x4],r8
80008f64:	87 06       	st.w	r3[0x0],r6
80008f66:	fa f6 06 90 	ld.w	r6,sp[1680]
80008f6a:	10 06       	add	r6,r8
80008f6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f70:	fb 46 06 90 	st.w	sp[1680],r6
80008f74:	2f f8       	sub	r8,-1
80008f76:	c3 18       	rjmp	80008fd8 <_vfprintf_r+0x1db0>
80008f78:	10 96       	mov	r6,r8
80008f7a:	58 08       	cp.w	r8,0
80008f7c:	e0 89 00 1c 	brgt	80008fb4 <_vfprintf_r+0x1d8c>
80008f80:	c4 b8       	rjmp	80009016 <_vfprintf_r+0x1dee>
80008f82:	2f 09       	sub	r9,-16
80008f84:	2f f8       	sub	r8,-1
80008f86:	fb 49 06 90 	st.w	sp[1680],r9
80008f8a:	87 02       	st.w	r3[0x0],r2
80008f8c:	87 10       	st.w	r3[0x4],r0
80008f8e:	fb 48 06 8c 	st.w	sp[1676],r8
80008f92:	58 78       	cp.w	r8,7
80008f94:	e0 89 00 04 	brgt	80008f9c <_vfprintf_r+0x1d74>
80008f98:	2f 83       	sub	r3,-8
80008f9a:	c0 b8       	rjmp	80008fb0 <_vfprintf_r+0x1d88>
80008f9c:	fa ca f9 78 	sub	r10,sp,-1672
80008fa0:	02 9b       	mov	r11,r1
80008fa2:	08 9c       	mov	r12,r4
80008fa4:	fe b0 f1 34 	rcall	8000720c <__sprint_r>
80008fa8:	e0 81 00 bf 	brne	80009126 <_vfprintf_r+0x1efe>
80008fac:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fb0:	21 06       	sub	r6,16
80008fb2:	c0 48       	rjmp	80008fba <_vfprintf_r+0x1d92>
80008fb4:	fe c2 bd 00 	sub	r2,pc,-17152
80008fb8:	31 00       	mov	r0,16
80008fba:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fbe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fc2:	fe ca bd 0e 	sub	r10,pc,-17138
80008fc6:	59 06       	cp.w	r6,16
80008fc8:	fe 99 ff dd 	brgt	80008f82 <_vfprintf_r+0x1d5a>
80008fcc:	0c 09       	add	r9,r6
80008fce:	87 0a       	st.w	r3[0x0],r10
80008fd0:	fb 49 06 90 	st.w	sp[1680],r9
80008fd4:	2f f8       	sub	r8,-1
80008fd6:	87 16       	st.w	r3[0x4],r6
80008fd8:	fb 48 06 8c 	st.w	sp[1676],r8
80008fdc:	c0 e8       	rjmp	80008ff8 <_vfprintf_r+0x1dd0>
80008fde:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fe2:	2f f8       	sub	r8,-1
80008fe4:	30 19       	mov	r9,1
80008fe6:	fb 48 06 90 	st.w	sp[1680],r8
80008fea:	87 06       	st.w	r3[0x0],r6
80008fec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ff0:	87 19       	st.w	r3[0x4],r9
80008ff2:	2f f8       	sub	r8,-1
80008ff4:	fb 48 06 8c 	st.w	sp[1676],r8
80008ff8:	58 78       	cp.w	r8,7
80008ffa:	e0 89 00 04 	brgt	80009002 <_vfprintf_r+0x1dda>
80008ffe:	2f 83       	sub	r3,-8
80009000:	c0 b8       	rjmp	80009016 <_vfprintf_r+0x1dee>
80009002:	fa ca f9 78 	sub	r10,sp,-1672
80009006:	02 9b       	mov	r11,r1
80009008:	08 9c       	mov	r12,r4
8000900a:	fe b0 f1 01 	rcall	8000720c <__sprint_r>
8000900e:	e0 81 00 8c 	brne	80009126 <_vfprintf_r+0x1efe>
80009012:	fa c3 f9 e0 	sub	r3,sp,-1568
80009016:	40 ea       	lddsp	r10,sp[0x38]
80009018:	fa f8 06 90 	ld.w	r8,sp[1680]
8000901c:	14 08       	add	r8,r10
8000901e:	fa c9 f9 64 	sub	r9,sp,-1692
80009022:	fb 48 06 90 	st.w	sp[1680],r8
80009026:	87 1a       	st.w	r3[0x4],r10
80009028:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000902c:	87 09       	st.w	r3[0x0],r9
8000902e:	2f f8       	sub	r8,-1
80009030:	fb 48 06 8c 	st.w	sp[1676],r8
80009034:	58 78       	cp.w	r8,7
80009036:	e0 89 00 04 	brgt	8000903e <_vfprintf_r+0x1e16>
8000903a:	2f 83       	sub	r3,-8
8000903c:	c0 a8       	rjmp	80009050 <_vfprintf_r+0x1e28>
8000903e:	fa ca f9 78 	sub	r10,sp,-1672
80009042:	02 9b       	mov	r11,r1
80009044:	08 9c       	mov	r12,r4
80009046:	fe b0 f0 e3 	rcall	8000720c <__sprint_r>
8000904a:	c6 e1       	brne	80009126 <_vfprintf_r+0x1efe>
8000904c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009050:	e2 15 00 04 	andl	r5,0x4,COH
80009054:	c3 f0       	breq	800090d2 <_vfprintf_r+0x1eaa>
80009056:	40 86       	lddsp	r6,sp[0x20]
80009058:	40 39       	lddsp	r9,sp[0xc]
8000905a:	12 16       	sub	r6,r9
8000905c:	58 06       	cp.w	r6,0
8000905e:	e0 89 00 1a 	brgt	80009092 <_vfprintf_r+0x1e6a>
80009062:	c3 88       	rjmp	800090d2 <_vfprintf_r+0x1eaa>
80009064:	2f 09       	sub	r9,-16
80009066:	2f f8       	sub	r8,-1
80009068:	fb 49 06 90 	st.w	sp[1680],r9
8000906c:	87 05       	st.w	r3[0x0],r5
8000906e:	87 12       	st.w	r3[0x4],r2
80009070:	fb 48 06 8c 	st.w	sp[1676],r8
80009074:	58 78       	cp.w	r8,7
80009076:	e0 89 00 04 	brgt	8000907e <_vfprintf_r+0x1e56>
8000907a:	2f 83       	sub	r3,-8
8000907c:	c0 98       	rjmp	8000908e <_vfprintf_r+0x1e66>
8000907e:	00 9a       	mov	r10,r0
80009080:	02 9b       	mov	r11,r1
80009082:	08 9c       	mov	r12,r4
80009084:	fe b0 f0 c4 	rcall	8000720c <__sprint_r>
80009088:	c4 f1       	brne	80009126 <_vfprintf_r+0x1efe>
8000908a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000908e:	21 06       	sub	r6,16
80009090:	c0 68       	rjmp	8000909c <_vfprintf_r+0x1e74>
80009092:	fe c5 bd ee 	sub	r5,pc,-16914
80009096:	31 02       	mov	r2,16
80009098:	fa c0 f9 78 	sub	r0,sp,-1672
8000909c:	fa f9 06 90 	ld.w	r9,sp[1680]
800090a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090a4:	fe ca be 00 	sub	r10,pc,-16896
800090a8:	59 06       	cp.w	r6,16
800090aa:	fe 99 ff dd 	brgt	80009064 <_vfprintf_r+0x1e3c>
800090ae:	0c 09       	add	r9,r6
800090b0:	2f f8       	sub	r8,-1
800090b2:	87 0a       	st.w	r3[0x0],r10
800090b4:	87 16       	st.w	r3[0x4],r6
800090b6:	fb 49 06 90 	st.w	sp[1680],r9
800090ba:	fb 48 06 8c 	st.w	sp[1676],r8
800090be:	58 78       	cp.w	r8,7
800090c0:	e0 8a 00 09 	brle	800090d2 <_vfprintf_r+0x1eaa>
800090c4:	fa ca f9 78 	sub	r10,sp,-1672
800090c8:	02 9b       	mov	r11,r1
800090ca:	08 9c       	mov	r12,r4
800090cc:	fe b0 f0 a0 	rcall	8000720c <__sprint_r>
800090d0:	c2 b1       	brne	80009126 <_vfprintf_r+0x1efe>
800090d2:	40 bc       	lddsp	r12,sp[0x2c]
800090d4:	40 36       	lddsp	r6,sp[0xc]
800090d6:	40 8e       	lddsp	lr,sp[0x20]
800090d8:	ec 0e 0c 48 	max	r8,r6,lr
800090dc:	10 0c       	add	r12,r8
800090de:	50 bc       	stdsp	sp[0x2c],r12
800090e0:	fa f8 06 90 	ld.w	r8,sp[1680]
800090e4:	58 08       	cp.w	r8,0
800090e6:	c0 80       	breq	800090f6 <_vfprintf_r+0x1ece>
800090e8:	fa ca f9 78 	sub	r10,sp,-1672
800090ec:	02 9b       	mov	r11,r1
800090ee:	08 9c       	mov	r12,r4
800090f0:	fe b0 f0 8e 	rcall	8000720c <__sprint_r>
800090f4:	c1 91       	brne	80009126 <_vfprintf_r+0x1efe>
800090f6:	30 0b       	mov	r11,0
800090f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800090fc:	fb 4b 06 8c 	st.w	sp[1676],r11
80009100:	fe 9f f1 22 	bral	80007344 <_vfprintf_r+0x11c>
80009104:	08 95       	mov	r5,r4
80009106:	fa f8 06 90 	ld.w	r8,sp[1680]
8000910a:	58 08       	cp.w	r8,0
8000910c:	c0 80       	breq	8000911c <_vfprintf_r+0x1ef4>
8000910e:	08 9c       	mov	r12,r4
80009110:	fa ca f9 78 	sub	r10,sp,-1672
80009114:	02 9b       	mov	r11,r1
80009116:	fe b0 f0 7b 	rcall	8000720c <__sprint_r>
8000911a:	c0 61       	brne	80009126 <_vfprintf_r+0x1efe>
8000911c:	30 08       	mov	r8,0
8000911e:	fb 48 06 8c 	st.w	sp[1676],r8
80009122:	c0 28       	rjmp	80009126 <_vfprintf_r+0x1efe>
80009124:	40 41       	lddsp	r1,sp[0x10]
80009126:	82 68       	ld.sh	r8,r1[0xc]
80009128:	ed b8 00 06 	bld	r8,0x6
8000912c:	c0 31       	brne	80009132 <_vfprintf_r+0x1f0a>
8000912e:	3f fa       	mov	r10,-1
80009130:	50 ba       	stdsp	sp[0x2c],r10
80009132:	40 bc       	lddsp	r12,sp[0x2c]
80009134:	fe 3d f9 44 	sub	sp,-1724
80009138:	d8 32       	popm	r0-r7,pc
8000913a:	d7 03       	nop

8000913c <__swsetup_r>:
8000913c:	d4 21       	pushm	r4-r7,lr
8000913e:	e0 68 0a 1c 	mov	r8,2588
80009142:	18 96       	mov	r6,r12
80009144:	16 97       	mov	r7,r11
80009146:	70 0c       	ld.w	r12,r8[0x0]
80009148:	58 0c       	cp.w	r12,0
8000914a:	c0 60       	breq	80009156 <__swsetup_r+0x1a>
8000914c:	78 68       	ld.w	r8,r12[0x18]
8000914e:	58 08       	cp.w	r8,0
80009150:	c0 31       	brne	80009156 <__swsetup_r+0x1a>
80009152:	e0 a0 07 bf 	rcall	8000a0d0 <__sinit>
80009156:	fe c8 bd 82 	sub	r8,pc,-17022
8000915a:	10 37       	cp.w	r7,r8
8000915c:	c0 61       	brne	80009168 <__swsetup_r+0x2c>
8000915e:	e0 68 0a 1c 	mov	r8,2588
80009162:	70 08       	ld.w	r8,r8[0x0]
80009164:	70 07       	ld.w	r7,r8[0x0]
80009166:	c1 28       	rjmp	8000918a <__swsetup_r+0x4e>
80009168:	fe c8 bd 74 	sub	r8,pc,-17036
8000916c:	10 37       	cp.w	r7,r8
8000916e:	c0 61       	brne	8000917a <__swsetup_r+0x3e>
80009170:	e0 68 0a 1c 	mov	r8,2588
80009174:	70 08       	ld.w	r8,r8[0x0]
80009176:	70 17       	ld.w	r7,r8[0x4]
80009178:	c0 98       	rjmp	8000918a <__swsetup_r+0x4e>
8000917a:	fe c8 bd 66 	sub	r8,pc,-17050
8000917e:	10 37       	cp.w	r7,r8
80009180:	c0 51       	brne	8000918a <__swsetup_r+0x4e>
80009182:	e0 68 0a 1c 	mov	r8,2588
80009186:	70 08       	ld.w	r8,r8[0x0]
80009188:	70 27       	ld.w	r7,r8[0x8]
8000918a:	8e 68       	ld.sh	r8,r7[0xc]
8000918c:	ed b8 00 03 	bld	r8,0x3
80009190:	c1 e0       	breq	800091cc <__swsetup_r+0x90>
80009192:	ed b8 00 04 	bld	r8,0x4
80009196:	c3 e1       	brne	80009212 <__swsetup_r+0xd6>
80009198:	ed b8 00 02 	bld	r8,0x2
8000919c:	c1 51       	brne	800091c6 <__swsetup_r+0x8a>
8000919e:	6e db       	ld.w	r11,r7[0x34]
800091a0:	58 0b       	cp.w	r11,0
800091a2:	c0 a0       	breq	800091b6 <__swsetup_r+0x7a>
800091a4:	ee c8 ff bc 	sub	r8,r7,-68
800091a8:	10 3b       	cp.w	r11,r8
800091aa:	c0 40       	breq	800091b2 <__swsetup_r+0x76>
800091ac:	0c 9c       	mov	r12,r6
800091ae:	e0 a0 08 2b 	rcall	8000a204 <_free_r>
800091b2:	30 08       	mov	r8,0
800091b4:	8f d8       	st.w	r7[0x34],r8
800091b6:	8e 68       	ld.sh	r8,r7[0xc]
800091b8:	e0 18 ff db 	andl	r8,0xffdb
800091bc:	ae 68       	st.h	r7[0xc],r8
800091be:	30 08       	mov	r8,0
800091c0:	8f 18       	st.w	r7[0x4],r8
800091c2:	6e 48       	ld.w	r8,r7[0x10]
800091c4:	8f 08       	st.w	r7[0x0],r8
800091c6:	8e 68       	ld.sh	r8,r7[0xc]
800091c8:	a3 b8       	sbr	r8,0x3
800091ca:	ae 68       	st.h	r7[0xc],r8
800091cc:	6e 48       	ld.w	r8,r7[0x10]
800091ce:	58 08       	cp.w	r8,0
800091d0:	c0 b1       	brne	800091e6 <__swsetup_r+0xaa>
800091d2:	8e 68       	ld.sh	r8,r7[0xc]
800091d4:	e2 18 02 80 	andl	r8,0x280,COH
800091d8:	e0 48 02 00 	cp.w	r8,512
800091dc:	c0 50       	breq	800091e6 <__swsetup_r+0xaa>
800091de:	0c 9c       	mov	r12,r6
800091e0:	0e 9b       	mov	r11,r7
800091e2:	e0 a0 0a 4b 	rcall	8000a678 <__smakebuf_r>
800091e6:	8e 69       	ld.sh	r9,r7[0xc]
800091e8:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
800091ec:	c0 70       	breq	800091fa <__swsetup_r+0xbe>
800091ee:	30 08       	mov	r8,0
800091f0:	8f 28       	st.w	r7[0x8],r8
800091f2:	6e 58       	ld.w	r8,r7[0x14]
800091f4:	5c 38       	neg	r8
800091f6:	8f 68       	st.w	r7[0x18],r8
800091f8:	c0 68       	rjmp	80009204 <__swsetup_r+0xc8>
800091fa:	ed b9 00 01 	bld	r9,0x1
800091fe:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009202:	8f 28       	st.w	r7[0x8],r8
80009204:	6e 48       	ld.w	r8,r7[0x10]
80009206:	58 08       	cp.w	r8,0
80009208:	c0 61       	brne	80009214 <__swsetup_r+0xd8>
8000920a:	8e 68       	ld.sh	r8,r7[0xc]
8000920c:	ed b8 00 07 	bld	r8,0x7
80009210:	c0 21       	brne	80009214 <__swsetup_r+0xd8>
80009212:	dc 2a       	popm	r4-r7,pc,r12=-1
80009214:	d8 2a       	popm	r4-r7,pc,r12=0
80009216:	d7 03       	nop

80009218 <quorem>:
80009218:	d4 31       	pushm	r0-r7,lr
8000921a:	20 2d       	sub	sp,8
8000921c:	18 97       	mov	r7,r12
8000921e:	78 48       	ld.w	r8,r12[0x10]
80009220:	76 46       	ld.w	r6,r11[0x10]
80009222:	0c 38       	cp.w	r8,r6
80009224:	c0 34       	brge	8000922a <quorem+0x12>
80009226:	30 0c       	mov	r12,0
80009228:	c8 58       	rjmp	80009332 <quorem+0x11a>
8000922a:	ec c2 ff fc 	sub	r2,r6,-4
8000922e:	f6 c3 ff ec 	sub	r3,r11,-20
80009232:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009236:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000923a:	2f f9       	sub	r9,-1
8000923c:	20 16       	sub	r6,1
8000923e:	f8 09 0d 08 	divu	r8,r12,r9
80009242:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009246:	ee c4 ff ec 	sub	r4,r7,-20
8000924a:	10 95       	mov	r5,r8
8000924c:	58 08       	cp.w	r8,0
8000924e:	c4 10       	breq	800092d0 <quorem+0xb8>
80009250:	30 09       	mov	r9,0
80009252:	06 9a       	mov	r10,r3
80009254:	08 98       	mov	r8,r4
80009256:	12 91       	mov	r1,r9
80009258:	50 0b       	stdsp	sp[0x0],r11
8000925a:	70 0e       	ld.w	lr,r8[0x0]
8000925c:	b1 8e       	lsr	lr,0x10
8000925e:	50 1e       	stdsp	sp[0x4],lr
80009260:	15 0e       	ld.w	lr,r10++
80009262:	fc 00 16 10 	lsr	r0,lr,0x10
80009266:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000926a:	ea 0e 03 41 	mac	r1,r5,lr
8000926e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009272:	b1 81       	lsr	r1,0x10
80009274:	40 1b       	lddsp	r11,sp[0x4]
80009276:	ea 00 02 40 	mul	r0,r5,r0
8000927a:	e2 00 00 00 	add	r0,r1,r0
8000927e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009282:	02 1b       	sub	r11,r1
80009284:	50 1b       	stdsp	sp[0x4],r11
80009286:	70 0b       	ld.w	r11,r8[0x0]
80009288:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000928c:	02 09       	add	r9,r1
8000928e:	f2 0e 01 0e 	sub	lr,r9,lr
80009292:	b0 1e       	st.h	r8[0x2],lr
80009294:	fc 09 14 10 	asr	r9,lr,0x10
80009298:	40 1e       	lddsp	lr,sp[0x4]
8000929a:	fc 09 00 09 	add	r9,lr,r9
8000929e:	b0 09       	st.h	r8[0x0],r9
800092a0:	e0 01 16 10 	lsr	r1,r0,0x10
800092a4:	2f c8       	sub	r8,-4
800092a6:	b1 49       	asr	r9,0x10
800092a8:	04 3a       	cp.w	r10,r2
800092aa:	fe 98 ff d8 	brls	8000925a <quorem+0x42>
800092ae:	40 0b       	lddsp	r11,sp[0x0]
800092b0:	58 0c       	cp.w	r12,0
800092b2:	c0 f1       	brne	800092d0 <quorem+0xb8>
800092b4:	ec c8 ff fb 	sub	r8,r6,-5
800092b8:	ee 08 00 28 	add	r8,r7,r8<<0x2
800092bc:	c0 28       	rjmp	800092c0 <quorem+0xa8>
800092be:	20 16       	sub	r6,1
800092c0:	20 48       	sub	r8,4
800092c2:	08 38       	cp.w	r8,r4
800092c4:	e0 88 00 05 	brls	800092ce <quorem+0xb6>
800092c8:	70 09       	ld.w	r9,r8[0x0]
800092ca:	58 09       	cp.w	r9,0
800092cc:	cf 90       	breq	800092be <quorem+0xa6>
800092ce:	8f 46       	st.w	r7[0x10],r6
800092d0:	0e 9c       	mov	r12,r7
800092d2:	e0 a0 0a d2 	rcall	8000a876 <__mcmp>
800092d6:	c2 d5       	brlt	80009330 <quorem+0x118>
800092d8:	2f f5       	sub	r5,-1
800092da:	08 98       	mov	r8,r4
800092dc:	30 09       	mov	r9,0
800092de:	07 0b       	ld.w	r11,r3++
800092e0:	f6 0a 16 10 	lsr	r10,r11,0x10
800092e4:	70 0c       	ld.w	r12,r8[0x0]
800092e6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800092ea:	f8 0e 16 10 	lsr	lr,r12,0x10
800092ee:	14 1e       	sub	lr,r10
800092f0:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800092f4:	16 1a       	sub	r10,r11
800092f6:	12 0a       	add	r10,r9
800092f8:	b0 1a       	st.h	r8[0x2],r10
800092fa:	b1 4a       	asr	r10,0x10
800092fc:	fc 0a 00 09 	add	r9,lr,r10
80009300:	b0 09       	st.h	r8[0x0],r9
80009302:	2f c8       	sub	r8,-4
80009304:	b1 49       	asr	r9,0x10
80009306:	04 33       	cp.w	r3,r2
80009308:	fe 98 ff eb 	brls	800092de <quorem+0xc6>
8000930c:	ec c8 ff fb 	sub	r8,r6,-5
80009310:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009314:	58 09       	cp.w	r9,0
80009316:	c0 d1       	brne	80009330 <quorem+0x118>
80009318:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000931c:	c0 28       	rjmp	80009320 <quorem+0x108>
8000931e:	20 16       	sub	r6,1
80009320:	20 48       	sub	r8,4
80009322:	08 38       	cp.w	r8,r4
80009324:	e0 88 00 05 	brls	8000932e <quorem+0x116>
80009328:	70 09       	ld.w	r9,r8[0x0]
8000932a:	58 09       	cp.w	r9,0
8000932c:	cf 90       	breq	8000931e <quorem+0x106>
8000932e:	8f 46       	st.w	r7[0x10],r6
80009330:	0a 9c       	mov	r12,r5
80009332:	2f ed       	sub	sp,-8
80009334:	d8 32       	popm	r0-r7,pc
80009336:	d7 03       	nop

80009338 <_dtoa_r>:
80009338:	d4 31       	pushm	r0-r7,lr
8000933a:	21 ad       	sub	sp,104
8000933c:	fa c4 ff 74 	sub	r4,sp,-140
80009340:	18 97       	mov	r7,r12
80009342:	16 95       	mov	r5,r11
80009344:	68 2c       	ld.w	r12,r4[0x8]
80009346:	50 c9       	stdsp	sp[0x30],r9
80009348:	68 16       	ld.w	r6,r4[0x4]
8000934a:	68 09       	ld.w	r9,r4[0x0]
8000934c:	50 e8       	stdsp	sp[0x38],r8
8000934e:	14 94       	mov	r4,r10
80009350:	51 2c       	stdsp	sp[0x48],r12
80009352:	fa e5 00 08 	st.d	sp[8],r4
80009356:	51 59       	stdsp	sp[0x54],r9
80009358:	6e 95       	ld.w	r5,r7[0x24]
8000935a:	58 05       	cp.w	r5,0
8000935c:	c0 91       	brne	8000936e <_dtoa_r+0x36>
8000935e:	31 0c       	mov	r12,16
80009360:	fe b0 e8 e2 	rcall	80006524 <malloc>
80009364:	99 35       	st.w	r12[0xc],r5
80009366:	8f 9c       	st.w	r7[0x24],r12
80009368:	99 15       	st.w	r12[0x4],r5
8000936a:	99 25       	st.w	r12[0x8],r5
8000936c:	99 05       	st.w	r12[0x0],r5
8000936e:	6e 99       	ld.w	r9,r7[0x24]
80009370:	72 08       	ld.w	r8,r9[0x0]
80009372:	58 08       	cp.w	r8,0
80009374:	c0 f0       	breq	80009392 <_dtoa_r+0x5a>
80009376:	72 1a       	ld.w	r10,r9[0x4]
80009378:	91 1a       	st.w	r8[0x4],r10
8000937a:	30 1a       	mov	r10,1
8000937c:	72 19       	ld.w	r9,r9[0x4]
8000937e:	f4 09 09 49 	lsl	r9,r10,r9
80009382:	10 9b       	mov	r11,r8
80009384:	91 29       	st.w	r8[0x8],r9
80009386:	0e 9c       	mov	r12,r7
80009388:	e0 a0 0a 90 	rcall	8000a8a8 <_Bfree>
8000938c:	6e 98       	ld.w	r8,r7[0x24]
8000938e:	30 09       	mov	r9,0
80009390:	91 09       	st.w	r8[0x0],r9
80009392:	40 28       	lddsp	r8,sp[0x8]
80009394:	10 94       	mov	r4,r8
80009396:	58 08       	cp.w	r8,0
80009398:	c0 64       	brge	800093a4 <_dtoa_r+0x6c>
8000939a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000939e:	50 28       	stdsp	sp[0x8],r8
800093a0:	30 18       	mov	r8,1
800093a2:	c0 28       	rjmp	800093a6 <_dtoa_r+0x6e>
800093a4:	30 08       	mov	r8,0
800093a6:	8d 08       	st.w	r6[0x0],r8
800093a8:	fc 1c 7f f0 	movh	r12,0x7ff0
800093ac:	40 26       	lddsp	r6,sp[0x8]
800093ae:	0c 98       	mov	r8,r6
800093b0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800093b4:	18 38       	cp.w	r8,r12
800093b6:	c2 01       	brne	800093f6 <_dtoa_r+0xbe>
800093b8:	e0 68 27 0f 	mov	r8,9999
800093bc:	41 5b       	lddsp	r11,sp[0x54]
800093be:	97 08       	st.w	r11[0x0],r8
800093c0:	40 3a       	lddsp	r10,sp[0xc]
800093c2:	58 0a       	cp.w	r10,0
800093c4:	c0 71       	brne	800093d2 <_dtoa_r+0x9a>
800093c6:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
800093ca:	c0 41       	brne	800093d2 <_dtoa_r+0x9a>
800093cc:	fe cc c0 08 	sub	r12,pc,-16376
800093d0:	c0 38       	rjmp	800093d6 <_dtoa_r+0x9e>
800093d2:	fe cc c0 02 	sub	r12,pc,-16382
800093d6:	41 29       	lddsp	r9,sp[0x48]
800093d8:	58 09       	cp.w	r9,0
800093da:	e0 80 05 9a 	breq	80009f0e <_dtoa_r+0xbd6>
800093de:	f8 c8 ff fd 	sub	r8,r12,-3
800093e2:	f8 c9 ff f8 	sub	r9,r12,-8
800093e6:	11 8b       	ld.ub	r11,r8[0x0]
800093e8:	30 0a       	mov	r10,0
800093ea:	41 25       	lddsp	r5,sp[0x48]
800093ec:	f4 0b 18 00 	cp.b	r11,r10
800093f0:	f2 08 17 10 	movne	r8,r9
800093f4:	c1 68       	rjmp	80009420 <_dtoa_r+0xe8>
800093f6:	fa ea 00 08 	ld.d	r10,sp[8]
800093fa:	30 08       	mov	r8,0
800093fc:	fa eb 00 3c 	st.d	sp[60],r10
80009400:	30 09       	mov	r9,0
80009402:	e0 a0 10 ce 	rcall	8000b59e <__avr32_f64_cmp_eq>
80009406:	c1 00       	breq	80009426 <_dtoa_r+0xee>
80009408:	30 18       	mov	r8,1
8000940a:	41 5a       	lddsp	r10,sp[0x54]
8000940c:	95 08       	st.w	r10[0x0],r8
8000940e:	fe cc c1 6e 	sub	r12,pc,-16018
80009412:	41 29       	lddsp	r9,sp[0x48]
80009414:	f8 08 00 08 	add	r8,r12,r8
80009418:	58 09       	cp.w	r9,0
8000941a:	e0 80 05 7a 	breq	80009f0e <_dtoa_r+0xbd6>
8000941e:	12 95       	mov	r5,r9
80009420:	8b 08       	st.w	r5[0x0],r8
80009422:	e0 8f 05 76 	bral	80009f0e <_dtoa_r+0xbd6>
80009426:	fa c8 ff 9c 	sub	r8,sp,-100
8000942a:	fa c9 ff a0 	sub	r9,sp,-96
8000942e:	fa ea 00 3c 	ld.d	r10,sp[60]
80009432:	0e 9c       	mov	r12,r7
80009434:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009438:	e0 a0 0a 8a 	rcall	8000a94c <__d2b>
8000943c:	18 93       	mov	r3,r12
8000943e:	58 05       	cp.w	r5,0
80009440:	c0 d0       	breq	8000945a <_dtoa_r+0x122>
80009442:	fa ea 00 3c 	ld.d	r10,sp[60]
80009446:	30 04       	mov	r4,0
80009448:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000944c:	ea c5 03 ff 	sub	r5,r5,1023
80009450:	10 9b       	mov	r11,r8
80009452:	51 74       	stdsp	sp[0x5c],r4
80009454:	ea 1b 3f f0 	orh	r11,0x3ff0
80009458:	c2 58       	rjmp	800094a2 <_dtoa_r+0x16a>
8000945a:	41 88       	lddsp	r8,sp[0x60]
8000945c:	41 9c       	lddsp	r12,sp[0x64]
8000945e:	10 0c       	add	r12,r8
80009460:	f8 c5 fb ce 	sub	r5,r12,-1074
80009464:	e0 45 00 20 	cp.w	r5,32
80009468:	e0 8a 00 0e 	brle	80009484 <_dtoa_r+0x14c>
8000946c:	f8 cc fb ee 	sub	r12,r12,-1042
80009470:	40 3b       	lddsp	r11,sp[0xc]
80009472:	ea 08 11 40 	rsub	r8,r5,64
80009476:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000947a:	ec 08 09 46 	lsl	r6,r6,r8
8000947e:	0c 4c       	or	r12,r6
80009480:	c0 78       	rjmp	8000948e <_dtoa_r+0x156>
80009482:	d7 03       	nop
80009484:	ea 0c 11 20 	rsub	r12,r5,32
80009488:	40 3a       	lddsp	r10,sp[0xc]
8000948a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000948e:	e0 a0 10 14 	rcall	8000b4b6 <__avr32_u32_to_f64>
80009492:	fc 18 fe 10 	movh	r8,0xfe10
80009496:	30 19       	mov	r9,1
80009498:	ea c5 04 33 	sub	r5,r5,1075
8000949c:	f0 0b 00 0b 	add	r11,r8,r11
800094a0:	51 79       	stdsp	sp[0x5c],r9
800094a2:	30 08       	mov	r8,0
800094a4:	fc 19 3f f8 	movh	r9,0x3ff8
800094a8:	e0 a0 0e 9c 	rcall	8000b1e0 <__avr32_f64_sub>
800094ac:	e0 68 43 61 	mov	r8,17249
800094b0:	ea 18 63 6f 	orh	r8,0x636f
800094b4:	e0 69 87 a7 	mov	r9,34727
800094b8:	ea 19 3f d2 	orh	r9,0x3fd2
800094bc:	e0 a0 0d a6 	rcall	8000b008 <__avr32_f64_mul>
800094c0:	e0 68 c8 b3 	mov	r8,51379
800094c4:	ea 18 8b 60 	orh	r8,0x8b60
800094c8:	e0 69 8a 28 	mov	r9,35368
800094cc:	ea 19 3f c6 	orh	r9,0x3fc6
800094d0:	e0 a0 0f 56 	rcall	8000b37c <__avr32_f64_add>
800094d4:	0a 9c       	mov	r12,r5
800094d6:	14 90       	mov	r0,r10
800094d8:	16 91       	mov	r1,r11
800094da:	e0 a0 0f f2 	rcall	8000b4be <__avr32_s32_to_f64>
800094de:	e0 68 79 fb 	mov	r8,31227
800094e2:	ea 18 50 9f 	orh	r8,0x509f
800094e6:	e0 69 44 13 	mov	r9,17427
800094ea:	ea 19 3f d3 	orh	r9,0x3fd3
800094ee:	e0 a0 0d 8d 	rcall	8000b008 <__avr32_f64_mul>
800094f2:	14 98       	mov	r8,r10
800094f4:	16 99       	mov	r9,r11
800094f6:	00 9a       	mov	r10,r0
800094f8:	02 9b       	mov	r11,r1
800094fa:	e0 a0 0f 41 	rcall	8000b37c <__avr32_f64_add>
800094fe:	14 90       	mov	r0,r10
80009500:	16 91       	mov	r1,r11
80009502:	e0 a0 0f c7 	rcall	8000b490 <__avr32_f64_to_s32>
80009506:	30 08       	mov	r8,0
80009508:	18 96       	mov	r6,r12
8000950a:	30 09       	mov	r9,0
8000950c:	00 9a       	mov	r10,r0
8000950e:	02 9b       	mov	r11,r1
80009510:	e0 a0 10 8e 	rcall	8000b62c <__avr32_f64_cmp_lt>
80009514:	c0 c0       	breq	8000952c <_dtoa_r+0x1f4>
80009516:	0c 9c       	mov	r12,r6
80009518:	e0 a0 0f d3 	rcall	8000b4be <__avr32_s32_to_f64>
8000951c:	14 98       	mov	r8,r10
8000951e:	16 99       	mov	r9,r11
80009520:	00 9a       	mov	r10,r0
80009522:	02 9b       	mov	r11,r1
80009524:	e0 a0 10 3d 	rcall	8000b59e <__avr32_f64_cmp_eq>
80009528:	f7 b6 00 01 	subeq	r6,1
8000952c:	59 66       	cp.w	r6,22
8000952e:	e0 88 00 05 	brls	80009538 <_dtoa_r+0x200>
80009532:	30 18       	mov	r8,1
80009534:	51 48       	stdsp	sp[0x50],r8
80009536:	c1 38       	rjmp	8000955c <_dtoa_r+0x224>
80009538:	fe c8 c0 b4 	sub	r8,pc,-16204
8000953c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009540:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009544:	e0 a0 10 74 	rcall	8000b62c <__avr32_f64_cmp_lt>
80009548:	f9 b4 00 00 	moveq	r4,0
8000954c:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009550:	f7 b6 01 01 	subne	r6,1
80009554:	f9 bc 01 00 	movne	r12,0
80009558:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000955c:	41 90       	lddsp	r0,sp[0x64]
8000955e:	20 10       	sub	r0,1
80009560:	0a 10       	sub	r0,r5
80009562:	c0 46       	brmi	8000956a <_dtoa_r+0x232>
80009564:	50 40       	stdsp	sp[0x10],r0
80009566:	30 00       	mov	r0,0
80009568:	c0 48       	rjmp	80009570 <_dtoa_r+0x238>
8000956a:	30 0b       	mov	r11,0
8000956c:	5c 30       	neg	r0
8000956e:	50 4b       	stdsp	sp[0x10],r11
80009570:	ec 02 11 00 	rsub	r2,r6,0
80009574:	58 06       	cp.w	r6,0
80009576:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000957a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000957e:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009582:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009586:	f9 b2 04 00 	movge	r2,0
8000958a:	e1 d6 e5 10 	sublt	r0,r0,r6
8000958e:	f9 b9 05 00 	movlt	r9,0
80009592:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009596:	40 c8       	lddsp	r8,sp[0x30]
80009598:	58 98       	cp.w	r8,9
8000959a:	e0 8b 00 20 	brhi	800095da <_dtoa_r+0x2a2>
8000959e:	58 58       	cp.w	r8,5
800095a0:	f9 b4 0a 01 	movle	r4,1
800095a4:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800095a8:	f7 b5 09 04 	subgt	r5,4
800095ac:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800095b0:	f9 b4 09 00 	movgt	r4,0
800095b4:	40 cc       	lddsp	r12,sp[0x30]
800095b6:	58 3c       	cp.w	r12,3
800095b8:	c2 d0       	breq	80009612 <_dtoa_r+0x2da>
800095ba:	e0 89 00 05 	brgt	800095c4 <_dtoa_r+0x28c>
800095be:	58 2c       	cp.w	r12,2
800095c0:	c1 01       	brne	800095e0 <_dtoa_r+0x2a8>
800095c2:	c1 88       	rjmp	800095f2 <_dtoa_r+0x2ba>
800095c4:	40 cb       	lddsp	r11,sp[0x30]
800095c6:	58 4b       	cp.w	r11,4
800095c8:	c0 60       	breq	800095d4 <_dtoa_r+0x29c>
800095ca:	58 5b       	cp.w	r11,5
800095cc:	c0 a1       	brne	800095e0 <_dtoa_r+0x2a8>
800095ce:	30 1a       	mov	r10,1
800095d0:	50 da       	stdsp	sp[0x34],r10
800095d2:	c2 28       	rjmp	80009616 <_dtoa_r+0x2de>
800095d4:	30 19       	mov	r9,1
800095d6:	50 d9       	stdsp	sp[0x34],r9
800095d8:	c0 f8       	rjmp	800095f6 <_dtoa_r+0x2be>
800095da:	30 08       	mov	r8,0
800095dc:	30 14       	mov	r4,1
800095de:	50 c8       	stdsp	sp[0x30],r8
800095e0:	3f f5       	mov	r5,-1
800095e2:	30 1c       	mov	r12,1
800095e4:	30 0b       	mov	r11,0
800095e6:	50 95       	stdsp	sp[0x24],r5
800095e8:	50 dc       	stdsp	sp[0x34],r12
800095ea:	0a 91       	mov	r1,r5
800095ec:	31 28       	mov	r8,18
800095ee:	50 eb       	stdsp	sp[0x38],r11
800095f0:	c2 08       	rjmp	80009630 <_dtoa_r+0x2f8>
800095f2:	30 0a       	mov	r10,0
800095f4:	50 da       	stdsp	sp[0x34],r10
800095f6:	40 e9       	lddsp	r9,sp[0x38]
800095f8:	58 09       	cp.w	r9,0
800095fa:	e0 89 00 07 	brgt	80009608 <_dtoa_r+0x2d0>
800095fe:	30 18       	mov	r8,1
80009600:	50 98       	stdsp	sp[0x24],r8
80009602:	10 91       	mov	r1,r8
80009604:	50 e8       	stdsp	sp[0x38],r8
80009606:	c1 58       	rjmp	80009630 <_dtoa_r+0x2f8>
80009608:	40 e5       	lddsp	r5,sp[0x38]
8000960a:	50 95       	stdsp	sp[0x24],r5
8000960c:	0a 91       	mov	r1,r5
8000960e:	0a 98       	mov	r8,r5
80009610:	c1 08       	rjmp	80009630 <_dtoa_r+0x2f8>
80009612:	30 0c       	mov	r12,0
80009614:	50 dc       	stdsp	sp[0x34],r12
80009616:	40 eb       	lddsp	r11,sp[0x38]
80009618:	ec 0b 00 0b 	add	r11,r6,r11
8000961c:	50 9b       	stdsp	sp[0x24],r11
8000961e:	16 98       	mov	r8,r11
80009620:	2f f8       	sub	r8,-1
80009622:	58 08       	cp.w	r8,0
80009624:	e0 89 00 05 	brgt	8000962e <_dtoa_r+0x2f6>
80009628:	10 91       	mov	r1,r8
8000962a:	30 18       	mov	r8,1
8000962c:	c0 28       	rjmp	80009630 <_dtoa_r+0x2f8>
8000962e:	10 91       	mov	r1,r8
80009630:	30 09       	mov	r9,0
80009632:	6e 9a       	ld.w	r10,r7[0x24]
80009634:	95 19       	st.w	r10[0x4],r9
80009636:	30 49       	mov	r9,4
80009638:	c0 68       	rjmp	80009644 <_dtoa_r+0x30c>
8000963a:	d7 03       	nop
8000963c:	6a 1a       	ld.w	r10,r5[0x4]
8000963e:	a1 79       	lsl	r9,0x1
80009640:	2f fa       	sub	r10,-1
80009642:	8b 1a       	st.w	r5[0x4],r10
80009644:	6e 95       	ld.w	r5,r7[0x24]
80009646:	f2 ca ff ec 	sub	r10,r9,-20
8000964a:	10 3a       	cp.w	r10,r8
8000964c:	fe 98 ff f8 	brls	8000963c <_dtoa_r+0x304>
80009650:	6a 1b       	ld.w	r11,r5[0x4]
80009652:	0e 9c       	mov	r12,r7
80009654:	e0 a0 09 44 	rcall	8000a8dc <_Balloc>
80009658:	58 e1       	cp.w	r1,14
8000965a:	5f 88       	srls	r8
8000965c:	8b 0c       	st.w	r5[0x0],r12
8000965e:	f1 e4 00 04 	and	r4,r8,r4
80009662:	6e 98       	ld.w	r8,r7[0x24]
80009664:	70 08       	ld.w	r8,r8[0x0]
80009666:	50 88       	stdsp	sp[0x20],r8
80009668:	e0 80 01 82 	breq	8000996c <_dtoa_r+0x634>
8000966c:	58 06       	cp.w	r6,0
8000966e:	e0 8a 00 43 	brle	800096f4 <_dtoa_r+0x3bc>
80009672:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009676:	fe c8 c1 f2 	sub	r8,pc,-15886
8000967a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000967e:	fa e5 00 18 	st.d	sp[24],r4
80009682:	ec 04 14 04 	asr	r4,r6,0x4
80009686:	ed b4 00 04 	bld	r4,0x4
8000968a:	c0 30       	breq	80009690 <_dtoa_r+0x358>
8000968c:	30 25       	mov	r5,2
8000968e:	c1 08       	rjmp	800096ae <_dtoa_r+0x376>
80009690:	fe c8 c1 44 	sub	r8,pc,-16060
80009694:	f0 e8 00 20 	ld.d	r8,r8[32]
80009698:	fa ea 00 3c 	ld.d	r10,sp[60]
8000969c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800096a0:	e0 a0 0f fa 	rcall	8000b694 <__avr32_f64_div>
800096a4:	30 35       	mov	r5,3
800096a6:	14 98       	mov	r8,r10
800096a8:	16 99       	mov	r9,r11
800096aa:	fa e9 00 08 	st.d	sp[8],r8
800096ae:	fe cc c1 62 	sub	r12,pc,-16030
800096b2:	50 a3       	stdsp	sp[0x28],r3
800096b4:	0c 93       	mov	r3,r6
800096b6:	18 96       	mov	r6,r12
800096b8:	c0 f8       	rjmp	800096d6 <_dtoa_r+0x39e>
800096ba:	fa ea 00 18 	ld.d	r10,sp[24]
800096be:	ed b4 00 00 	bld	r4,0x0
800096c2:	c0 81       	brne	800096d2 <_dtoa_r+0x39a>
800096c4:	ec e8 00 00 	ld.d	r8,r6[0]
800096c8:	2f f5       	sub	r5,-1
800096ca:	e0 a0 0c 9f 	rcall	8000b008 <__avr32_f64_mul>
800096ce:	fa eb 00 18 	st.d	sp[24],r10
800096d2:	a1 54       	asr	r4,0x1
800096d4:	2f 86       	sub	r6,-8
800096d6:	58 04       	cp.w	r4,0
800096d8:	cf 11       	brne	800096ba <_dtoa_r+0x382>
800096da:	fa e8 00 18 	ld.d	r8,sp[24]
800096de:	fa ea 00 08 	ld.d	r10,sp[8]
800096e2:	06 96       	mov	r6,r3
800096e4:	e0 a0 0f d8 	rcall	8000b694 <__avr32_f64_div>
800096e8:	40 a3       	lddsp	r3,sp[0x28]
800096ea:	14 98       	mov	r8,r10
800096ec:	16 99       	mov	r9,r11
800096ee:	fa e9 00 08 	st.d	sp[8],r8
800096f2:	c2 f8       	rjmp	80009750 <_dtoa_r+0x418>
800096f4:	ec 08 11 00 	rsub	r8,r6,0
800096f8:	c0 31       	brne	800096fe <_dtoa_r+0x3c6>
800096fa:	30 25       	mov	r5,2
800096fc:	c2 a8       	rjmp	80009750 <_dtoa_r+0x418>
800096fe:	fe cc c1 b2 	sub	r12,pc,-15950
80009702:	f0 04 14 04 	asr	r4,r8,0x4
80009706:	50 1c       	stdsp	sp[0x4],r12
80009708:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000970c:	fe c9 c2 88 	sub	r9,pc,-15736
80009710:	fa ea 00 3c 	ld.d	r10,sp[60]
80009714:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009718:	e0 a0 0c 78 	rcall	8000b008 <__avr32_f64_mul>
8000971c:	40 1c       	lddsp	r12,sp[0x4]
8000971e:	50 63       	stdsp	sp[0x18],r3
80009720:	30 25       	mov	r5,2
80009722:	0c 93       	mov	r3,r6
80009724:	fa eb 00 08 	st.d	sp[8],r10
80009728:	18 96       	mov	r6,r12
8000972a:	c0 f8       	rjmp	80009748 <_dtoa_r+0x410>
8000972c:	fa ea 00 08 	ld.d	r10,sp[8]
80009730:	ed b4 00 00 	bld	r4,0x0
80009734:	c0 81       	brne	80009744 <_dtoa_r+0x40c>
80009736:	ec e8 00 00 	ld.d	r8,r6[0]
8000973a:	2f f5       	sub	r5,-1
8000973c:	e0 a0 0c 66 	rcall	8000b008 <__avr32_f64_mul>
80009740:	fa eb 00 08 	st.d	sp[8],r10
80009744:	a1 54       	asr	r4,0x1
80009746:	2f 86       	sub	r6,-8
80009748:	58 04       	cp.w	r4,0
8000974a:	cf 11       	brne	8000972c <_dtoa_r+0x3f4>
8000974c:	06 96       	mov	r6,r3
8000974e:	40 63       	lddsp	r3,sp[0x18]
80009750:	41 4a       	lddsp	r10,sp[0x50]
80009752:	58 0a       	cp.w	r10,0
80009754:	c2 a0       	breq	800097a8 <_dtoa_r+0x470>
80009756:	fa e8 00 08 	ld.d	r8,sp[8]
8000975a:	58 01       	cp.w	r1,0
8000975c:	5f 94       	srgt	r4
8000975e:	fa e9 00 18 	st.d	sp[24],r8
80009762:	30 08       	mov	r8,0
80009764:	fc 19 3f f0 	movh	r9,0x3ff0
80009768:	fa ea 00 18 	ld.d	r10,sp[24]
8000976c:	e0 a0 0f 60 	rcall	8000b62c <__avr32_f64_cmp_lt>
80009770:	f9 bc 00 00 	moveq	r12,0
80009774:	f9 bc 01 01 	movne	r12,1
80009778:	e9 ec 00 0c 	and	r12,r4,r12
8000977c:	c1 60       	breq	800097a8 <_dtoa_r+0x470>
8000977e:	40 98       	lddsp	r8,sp[0x24]
80009780:	58 08       	cp.w	r8,0
80009782:	e0 8a 00 f1 	brle	80009964 <_dtoa_r+0x62c>
80009786:	30 08       	mov	r8,0
80009788:	fc 19 40 24 	movh	r9,0x4024
8000978c:	ec c4 00 01 	sub	r4,r6,1
80009790:	fa ea 00 18 	ld.d	r10,sp[24]
80009794:	2f f5       	sub	r5,-1
80009796:	50 64       	stdsp	sp[0x18],r4
80009798:	e0 a0 0c 38 	rcall	8000b008 <__avr32_f64_mul>
8000979c:	40 94       	lddsp	r4,sp[0x24]
8000979e:	14 98       	mov	r8,r10
800097a0:	16 99       	mov	r9,r11
800097a2:	fa e9 00 08 	st.d	sp[8],r8
800097a6:	c0 38       	rjmp	800097ac <_dtoa_r+0x474>
800097a8:	50 66       	stdsp	sp[0x18],r6
800097aa:	02 94       	mov	r4,r1
800097ac:	0a 9c       	mov	r12,r5
800097ae:	e0 a0 0e 88 	rcall	8000b4be <__avr32_s32_to_f64>
800097b2:	fa e8 00 08 	ld.d	r8,sp[8]
800097b6:	e0 a0 0c 29 	rcall	8000b008 <__avr32_f64_mul>
800097ba:	30 08       	mov	r8,0
800097bc:	fc 19 40 1c 	movh	r9,0x401c
800097c0:	e0 a0 0d de 	rcall	8000b37c <__avr32_f64_add>
800097c4:	14 98       	mov	r8,r10
800097c6:	16 99       	mov	r9,r11
800097c8:	fa e9 00 28 	st.d	sp[40],r8
800097cc:	fc 18 fc c0 	movh	r8,0xfcc0
800097d0:	40 a5       	lddsp	r5,sp[0x28]
800097d2:	10 05       	add	r5,r8
800097d4:	50 a5       	stdsp	sp[0x28],r5
800097d6:	58 04       	cp.w	r4,0
800097d8:	c2 11       	brne	8000981a <_dtoa_r+0x4e2>
800097da:	fa ea 00 08 	ld.d	r10,sp[8]
800097de:	30 08       	mov	r8,0
800097e0:	fc 19 40 14 	movh	r9,0x4014
800097e4:	e0 a0 0c fe 	rcall	8000b1e0 <__avr32_f64_sub>
800097e8:	40 bc       	lddsp	r12,sp[0x2c]
800097ea:	fa eb 00 08 	st.d	sp[8],r10
800097ee:	14 98       	mov	r8,r10
800097f0:	16 99       	mov	r9,r11
800097f2:	18 9a       	mov	r10,r12
800097f4:	0a 9b       	mov	r11,r5
800097f6:	e0 a0 0f 1b 	rcall	8000b62c <__avr32_f64_cmp_lt>
800097fa:	e0 81 02 54 	brne	80009ca2 <_dtoa_r+0x96a>
800097fe:	0a 98       	mov	r8,r5
80009800:	40 b9       	lddsp	r9,sp[0x2c]
80009802:	ee 18 80 00 	eorh	r8,0x8000
80009806:	fa ea 00 08 	ld.d	r10,sp[8]
8000980a:	10 95       	mov	r5,r8
8000980c:	12 98       	mov	r8,r9
8000980e:	0a 99       	mov	r9,r5
80009810:	e0 a0 0f 0e 	rcall	8000b62c <__avr32_f64_cmp_lt>
80009814:	e0 81 02 3e 	brne	80009c90 <_dtoa_r+0x958>
80009818:	ca 68       	rjmp	80009964 <_dtoa_r+0x62c>
8000981a:	fe c9 c3 96 	sub	r9,pc,-15466
8000981e:	e8 c8 00 01 	sub	r8,r4,1
80009822:	40 d5       	lddsp	r5,sp[0x34]
80009824:	58 05       	cp.w	r5,0
80009826:	c4 f0       	breq	800098c4 <_dtoa_r+0x58c>
80009828:	30 0c       	mov	r12,0
8000982a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000982e:	51 3c       	stdsp	sp[0x4c],r12
80009830:	30 0a       	mov	r10,0
80009832:	fc 1b 3f e0 	movh	r11,0x3fe0
80009836:	e0 a0 0f 2f 	rcall	8000b694 <__avr32_f64_div>
8000983a:	fa e8 00 28 	ld.d	r8,sp[40]
8000983e:	40 85       	lddsp	r5,sp[0x20]
80009840:	e0 a0 0c d0 	rcall	8000b1e0 <__avr32_f64_sub>
80009844:	fa eb 00 28 	st.d	sp[40],r10
80009848:	fa ea 00 08 	ld.d	r10,sp[8]
8000984c:	e0 a0 0e 22 	rcall	8000b490 <__avr32_f64_to_s32>
80009850:	51 6c       	stdsp	sp[0x58],r12
80009852:	e0 a0 0e 36 	rcall	8000b4be <__avr32_s32_to_f64>
80009856:	14 98       	mov	r8,r10
80009858:	16 99       	mov	r9,r11
8000985a:	fa ea 00 08 	ld.d	r10,sp[8]
8000985e:	e0 a0 0c c1 	rcall	8000b1e0 <__avr32_f64_sub>
80009862:	fa eb 00 08 	st.d	sp[8],r10
80009866:	41 68       	lddsp	r8,sp[0x58]
80009868:	2d 08       	sub	r8,-48
8000986a:	0a c8       	st.b	r5++,r8
8000986c:	41 39       	lddsp	r9,sp[0x4c]
8000986e:	2f f9       	sub	r9,-1
80009870:	51 39       	stdsp	sp[0x4c],r9
80009872:	fa e8 00 28 	ld.d	r8,sp[40]
80009876:	e0 a0 0e db 	rcall	8000b62c <__avr32_f64_cmp_lt>
8000987a:	e0 81 03 39 	brne	80009eec <_dtoa_r+0xbb4>
8000987e:	fa e8 00 08 	ld.d	r8,sp[8]
80009882:	30 0a       	mov	r10,0
80009884:	fc 1b 3f f0 	movh	r11,0x3ff0
80009888:	e0 a0 0c ac 	rcall	8000b1e0 <__avr32_f64_sub>
8000988c:	fa e8 00 28 	ld.d	r8,sp[40]
80009890:	e0 a0 0e ce 	rcall	8000b62c <__avr32_f64_cmp_lt>
80009894:	fa ea 00 28 	ld.d	r10,sp[40]
80009898:	30 08       	mov	r8,0
8000989a:	fc 19 40 24 	movh	r9,0x4024
8000989e:	e0 81 00 da 	brne	80009a52 <_dtoa_r+0x71a>
800098a2:	41 3c       	lddsp	r12,sp[0x4c]
800098a4:	08 3c       	cp.w	r12,r4
800098a6:	c5 f4       	brge	80009964 <_dtoa_r+0x62c>
800098a8:	e0 a0 0b b0 	rcall	8000b008 <__avr32_f64_mul>
800098ac:	30 08       	mov	r8,0
800098ae:	fa eb 00 28 	st.d	sp[40],r10
800098b2:	fc 19 40 24 	movh	r9,0x4024
800098b6:	fa ea 00 08 	ld.d	r10,sp[8]
800098ba:	e0 a0 0b a7 	rcall	8000b008 <__avr32_f64_mul>
800098be:	fa eb 00 08 	st.d	sp[8],r10
800098c2:	cc 3b       	rjmp	80009848 <_dtoa_r+0x510>
800098c4:	40 85       	lddsp	r5,sp[0x20]
800098c6:	08 05       	add	r5,r4
800098c8:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
800098cc:	51 35       	stdsp	sp[0x4c],r5
800098ce:	fa e8 00 28 	ld.d	r8,sp[40]
800098d2:	40 85       	lddsp	r5,sp[0x20]
800098d4:	e0 a0 0b 9a 	rcall	8000b008 <__avr32_f64_mul>
800098d8:	fa eb 00 28 	st.d	sp[40],r10
800098dc:	fa ea 00 08 	ld.d	r10,sp[8]
800098e0:	e0 a0 0d d8 	rcall	8000b490 <__avr32_f64_to_s32>
800098e4:	51 6c       	stdsp	sp[0x58],r12
800098e6:	e0 a0 0d ec 	rcall	8000b4be <__avr32_s32_to_f64>
800098ea:	14 98       	mov	r8,r10
800098ec:	16 99       	mov	r9,r11
800098ee:	fa ea 00 08 	ld.d	r10,sp[8]
800098f2:	e0 a0 0c 77 	rcall	8000b1e0 <__avr32_f64_sub>
800098f6:	fa eb 00 08 	st.d	sp[8],r10
800098fa:	41 68       	lddsp	r8,sp[0x58]
800098fc:	2d 08       	sub	r8,-48
800098fe:	0a c8       	st.b	r5++,r8
80009900:	41 3c       	lddsp	r12,sp[0x4c]
80009902:	18 35       	cp.w	r5,r12
80009904:	c2 81       	brne	80009954 <_dtoa_r+0x61c>
80009906:	30 08       	mov	r8,0
80009908:	fc 19 3f e0 	movh	r9,0x3fe0
8000990c:	fa ea 00 28 	ld.d	r10,sp[40]
80009910:	e0 a0 0d 36 	rcall	8000b37c <__avr32_f64_add>
80009914:	40 85       	lddsp	r5,sp[0x20]
80009916:	fa e8 00 08 	ld.d	r8,sp[8]
8000991a:	08 05       	add	r5,r4
8000991c:	e0 a0 0e 88 	rcall	8000b62c <__avr32_f64_cmp_lt>
80009920:	e0 81 00 99 	brne	80009a52 <_dtoa_r+0x71a>
80009924:	fa e8 00 28 	ld.d	r8,sp[40]
80009928:	30 0a       	mov	r10,0
8000992a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000992e:	e0 a0 0c 59 	rcall	8000b1e0 <__avr32_f64_sub>
80009932:	14 98       	mov	r8,r10
80009934:	16 99       	mov	r9,r11
80009936:	fa ea 00 08 	ld.d	r10,sp[8]
8000993a:	e0 a0 0e 79 	rcall	8000b62c <__avr32_f64_cmp_lt>
8000993e:	c1 30       	breq	80009964 <_dtoa_r+0x62c>
80009940:	33 09       	mov	r9,48
80009942:	0a 98       	mov	r8,r5
80009944:	11 7a       	ld.ub	r10,--r8
80009946:	f2 0a 18 00 	cp.b	r10,r9
8000994a:	e0 81 02 d1 	brne	80009eec <_dtoa_r+0xbb4>
8000994e:	10 95       	mov	r5,r8
80009950:	cf 9b       	rjmp	80009942 <_dtoa_r+0x60a>
80009952:	d7 03       	nop
80009954:	30 08       	mov	r8,0
80009956:	fc 19 40 24 	movh	r9,0x4024
8000995a:	e0 a0 0b 57 	rcall	8000b008 <__avr32_f64_mul>
8000995e:	fa eb 00 08 	st.d	sp[8],r10
80009962:	cb db       	rjmp	800098dc <_dtoa_r+0x5a4>
80009964:	fa ea 00 3c 	ld.d	r10,sp[60]
80009968:	fa eb 00 08 	st.d	sp[8],r10
8000996c:	58 e6       	cp.w	r6,14
8000996e:	5f ab       	srle	r11
80009970:	41 8a       	lddsp	r10,sp[0x60]
80009972:	30 08       	mov	r8,0
80009974:	f4 09 11 ff 	rsub	r9,r10,-1
80009978:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000997c:	f0 09 18 00 	cp.b	r9,r8
80009980:	e0 80 00 82 	breq	80009a84 <_dtoa_r+0x74c>
80009984:	40 ea       	lddsp	r10,sp[0x38]
80009986:	58 01       	cp.w	r1,0
80009988:	5f a9       	srle	r9
8000998a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000998e:	fe ca c5 0a 	sub	r10,pc,-15094
80009992:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009996:	fa e5 00 10 	st.d	sp[16],r4
8000999a:	f0 09 18 00 	cp.b	r9,r8
8000999e:	c1 40       	breq	800099c6 <_dtoa_r+0x68e>
800099a0:	58 01       	cp.w	r1,0
800099a2:	e0 81 01 77 	brne	80009c90 <_dtoa_r+0x958>
800099a6:	30 08       	mov	r8,0
800099a8:	fc 19 40 14 	movh	r9,0x4014
800099ac:	08 9a       	mov	r10,r4
800099ae:	0a 9b       	mov	r11,r5
800099b0:	e0 a0 0b 2c 	rcall	8000b008 <__avr32_f64_mul>
800099b4:	fa e8 00 08 	ld.d	r8,sp[8]
800099b8:	e0 a0 0e 06 	rcall	8000b5c4 <__avr32_f64_cmp_ge>
800099bc:	e0 81 01 6a 	brne	80009c90 <_dtoa_r+0x958>
800099c0:	02 92       	mov	r2,r1
800099c2:	e0 8f 01 72 	bral	80009ca6 <_dtoa_r+0x96e>
800099c6:	40 85       	lddsp	r5,sp[0x20]
800099c8:	30 14       	mov	r4,1
800099ca:	fa e8 00 10 	ld.d	r8,sp[16]
800099ce:	fa ea 00 08 	ld.d	r10,sp[8]
800099d2:	e0 a0 0e 61 	rcall	8000b694 <__avr32_f64_div>
800099d6:	e0 a0 0d 5d 	rcall	8000b490 <__avr32_f64_to_s32>
800099da:	18 92       	mov	r2,r12
800099dc:	e0 a0 0d 71 	rcall	8000b4be <__avr32_s32_to_f64>
800099e0:	fa e8 00 10 	ld.d	r8,sp[16]
800099e4:	e0 a0 0b 12 	rcall	8000b008 <__avr32_f64_mul>
800099e8:	14 98       	mov	r8,r10
800099ea:	16 99       	mov	r9,r11
800099ec:	fa ea 00 08 	ld.d	r10,sp[8]
800099f0:	e0 a0 0b f8 	rcall	8000b1e0 <__avr32_f64_sub>
800099f4:	fa eb 00 08 	st.d	sp[8],r10
800099f8:	e4 c8 ff d0 	sub	r8,r2,-48
800099fc:	0a c8       	st.b	r5++,r8
800099fe:	fc 19 40 24 	movh	r9,0x4024
80009a02:	30 08       	mov	r8,0
80009a04:	02 34       	cp.w	r4,r1
80009a06:	c3 31       	brne	80009a6c <_dtoa_r+0x734>
80009a08:	fa e8 00 08 	ld.d	r8,sp[8]
80009a0c:	e0 a0 0c b8 	rcall	8000b37c <__avr32_f64_add>
80009a10:	16 91       	mov	r1,r11
80009a12:	14 90       	mov	r0,r10
80009a14:	14 98       	mov	r8,r10
80009a16:	02 99       	mov	r9,r1
80009a18:	fa ea 00 10 	ld.d	r10,sp[16]
80009a1c:	e0 a0 0e 08 	rcall	8000b62c <__avr32_f64_cmp_lt>
80009a20:	c1 a1       	brne	80009a54 <_dtoa_r+0x71c>
80009a22:	fa e8 00 10 	ld.d	r8,sp[16]
80009a26:	00 9a       	mov	r10,r0
80009a28:	02 9b       	mov	r11,r1
80009a2a:	e0 a0 0d ba 	rcall	8000b59e <__avr32_f64_cmp_eq>
80009a2e:	e0 80 02 5e 	breq	80009eea <_dtoa_r+0xbb2>
80009a32:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009a36:	c0 f1       	brne	80009a54 <_dtoa_r+0x71c>
80009a38:	e0 8f 02 59 	bral	80009eea <_dtoa_r+0xbb2>
80009a3c:	40 8a       	lddsp	r10,sp[0x20]
80009a3e:	14 38       	cp.w	r8,r10
80009a40:	c0 30       	breq	80009a46 <_dtoa_r+0x70e>
80009a42:	10 95       	mov	r5,r8
80009a44:	c0 98       	rjmp	80009a56 <_dtoa_r+0x71e>
80009a46:	33 08       	mov	r8,48
80009a48:	40 89       	lddsp	r9,sp[0x20]
80009a4a:	2f f6       	sub	r6,-1
80009a4c:	b2 88       	st.b	r9[0x0],r8
80009a4e:	40 88       	lddsp	r8,sp[0x20]
80009a50:	c0 88       	rjmp	80009a60 <_dtoa_r+0x728>
80009a52:	40 66       	lddsp	r6,sp[0x18]
80009a54:	33 99       	mov	r9,57
80009a56:	0a 98       	mov	r8,r5
80009a58:	11 7a       	ld.ub	r10,--r8
80009a5a:	f2 0a 18 00 	cp.b	r10,r9
80009a5e:	ce f0       	breq	80009a3c <_dtoa_r+0x704>
80009a60:	50 66       	stdsp	sp[0x18],r6
80009a62:	11 89       	ld.ub	r9,r8[0x0]
80009a64:	2f f9       	sub	r9,-1
80009a66:	b0 89       	st.b	r8[0x0],r9
80009a68:	e0 8f 02 42 	bral	80009eec <_dtoa_r+0xbb4>
80009a6c:	e0 a0 0a ce 	rcall	8000b008 <__avr32_f64_mul>
80009a70:	2f f4       	sub	r4,-1
80009a72:	fa eb 00 08 	st.d	sp[8],r10
80009a76:	30 08       	mov	r8,0
80009a78:	30 09       	mov	r9,0
80009a7a:	e0 a0 0d 92 	rcall	8000b59e <__avr32_f64_cmp_eq>
80009a7e:	ca 60       	breq	800099ca <_dtoa_r+0x692>
80009a80:	e0 8f 02 35 	bral	80009eea <_dtoa_r+0xbb2>
80009a84:	40 d8       	lddsp	r8,sp[0x34]
80009a86:	58 08       	cp.w	r8,0
80009a88:	c0 51       	brne	80009a92 <_dtoa_r+0x75a>
80009a8a:	04 98       	mov	r8,r2
80009a8c:	00 95       	mov	r5,r0
80009a8e:	40 d4       	lddsp	r4,sp[0x34]
80009a90:	c3 78       	rjmp	80009afe <_dtoa_r+0x7c6>
80009a92:	40 c5       	lddsp	r5,sp[0x30]
80009a94:	58 15       	cp.w	r5,1
80009a96:	e0 89 00 0f 	brgt	80009ab4 <_dtoa_r+0x77c>
80009a9a:	41 74       	lddsp	r4,sp[0x5c]
80009a9c:	58 04       	cp.w	r4,0
80009a9e:	c0 40       	breq	80009aa6 <_dtoa_r+0x76e>
80009aa0:	f4 c9 fb cd 	sub	r9,r10,-1075
80009aa4:	c0 48       	rjmp	80009aac <_dtoa_r+0x774>
80009aa6:	41 99       	lddsp	r9,sp[0x64]
80009aa8:	f2 09 11 36 	rsub	r9,r9,54
80009aac:	04 98       	mov	r8,r2
80009aae:	00 95       	mov	r5,r0
80009ab0:	c1 c8       	rjmp	80009ae8 <_dtoa_r+0x7b0>
80009ab2:	d7 03       	nop
80009ab4:	e2 c8 00 01 	sub	r8,r1,1
80009ab8:	58 01       	cp.w	r1,0
80009aba:	e0 05 17 40 	movge	r5,r0
80009abe:	e2 09 17 40 	movge	r9,r1
80009ac2:	e1 d1 e5 15 	sublt	r5,r0,r1
80009ac6:	f9 b9 05 00 	movlt	r9,0
80009aca:	10 32       	cp.w	r2,r8
80009acc:	e5 d8 e4 18 	subge	r8,r2,r8
80009ad0:	f1 d2 e5 18 	sublt	r8,r8,r2
80009ad4:	e5 d8 e5 02 	addlt	r2,r2,r8
80009ad8:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009adc:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009ae0:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009ae4:	f9 b8 05 00 	movlt	r8,0
80009ae8:	40 4b       	lddsp	r11,sp[0x10]
80009aea:	12 0b       	add	r11,r9
80009aec:	50 08       	stdsp	sp[0x0],r8
80009aee:	50 4b       	stdsp	sp[0x10],r11
80009af0:	12 00       	add	r0,r9
80009af2:	30 1b       	mov	r11,1
80009af4:	0e 9c       	mov	r12,r7
80009af6:	e0 a0 08 a7 	rcall	8000ac44 <__i2b>
80009afa:	40 08       	lddsp	r8,sp[0x0]
80009afc:	18 94       	mov	r4,r12
80009afe:	40 4a       	lddsp	r10,sp[0x10]
80009b00:	58 05       	cp.w	r5,0
80009b02:	5f 99       	srgt	r9
80009b04:	58 0a       	cp.w	r10,0
80009b06:	5f 9a       	srgt	r10
80009b08:	f5 e9 00 09 	and	r9,r10,r9
80009b0c:	c0 80       	breq	80009b1c <_dtoa_r+0x7e4>
80009b0e:	40 4c       	lddsp	r12,sp[0x10]
80009b10:	f8 05 0d 49 	min	r9,r12,r5
80009b14:	12 1c       	sub	r12,r9
80009b16:	12 10       	sub	r0,r9
80009b18:	50 4c       	stdsp	sp[0x10],r12
80009b1a:	12 15       	sub	r5,r9
80009b1c:	58 02       	cp.w	r2,0
80009b1e:	e0 8a 00 27 	brle	80009b6c <_dtoa_r+0x834>
80009b22:	40 db       	lddsp	r11,sp[0x34]
80009b24:	58 0b       	cp.w	r11,0
80009b26:	c1 d0       	breq	80009b60 <_dtoa_r+0x828>
80009b28:	58 08       	cp.w	r8,0
80009b2a:	e0 8a 00 17 	brle	80009b58 <_dtoa_r+0x820>
80009b2e:	10 9a       	mov	r10,r8
80009b30:	50 08       	stdsp	sp[0x0],r8
80009b32:	08 9b       	mov	r11,r4
80009b34:	0e 9c       	mov	r12,r7
80009b36:	e0 a0 08 cd 	rcall	8000acd0 <__pow5mult>
80009b3a:	06 9a       	mov	r10,r3
80009b3c:	18 9b       	mov	r11,r12
80009b3e:	18 94       	mov	r4,r12
80009b40:	0e 9c       	mov	r12,r7
80009b42:	e0 a0 08 01 	rcall	8000ab44 <__multiply>
80009b46:	18 99       	mov	r9,r12
80009b48:	06 9b       	mov	r11,r3
80009b4a:	50 19       	stdsp	sp[0x4],r9
80009b4c:	0e 9c       	mov	r12,r7
80009b4e:	e0 a0 06 ad 	rcall	8000a8a8 <_Bfree>
80009b52:	40 19       	lddsp	r9,sp[0x4]
80009b54:	40 08       	lddsp	r8,sp[0x0]
80009b56:	12 93       	mov	r3,r9
80009b58:	e4 08 01 0a 	sub	r10,r2,r8
80009b5c:	c0 80       	breq	80009b6c <_dtoa_r+0x834>
80009b5e:	c0 28       	rjmp	80009b62 <_dtoa_r+0x82a>
80009b60:	04 9a       	mov	r10,r2
80009b62:	06 9b       	mov	r11,r3
80009b64:	0e 9c       	mov	r12,r7
80009b66:	e0 a0 08 b5 	rcall	8000acd0 <__pow5mult>
80009b6a:	18 93       	mov	r3,r12
80009b6c:	30 1b       	mov	r11,1
80009b6e:	0e 9c       	mov	r12,r7
80009b70:	e0 a0 08 6a 	rcall	8000ac44 <__i2b>
80009b74:	41 1a       	lddsp	r10,sp[0x44]
80009b76:	18 92       	mov	r2,r12
80009b78:	58 0a       	cp.w	r10,0
80009b7a:	e0 8a 00 07 	brle	80009b88 <_dtoa_r+0x850>
80009b7e:	18 9b       	mov	r11,r12
80009b80:	0e 9c       	mov	r12,r7
80009b82:	e0 a0 08 a7 	rcall	8000acd0 <__pow5mult>
80009b86:	18 92       	mov	r2,r12
80009b88:	40 c9       	lddsp	r9,sp[0x30]
80009b8a:	58 19       	cp.w	r9,1
80009b8c:	e0 89 00 14 	brgt	80009bb4 <_dtoa_r+0x87c>
80009b90:	40 38       	lddsp	r8,sp[0xc]
80009b92:	58 08       	cp.w	r8,0
80009b94:	c1 01       	brne	80009bb4 <_dtoa_r+0x87c>
80009b96:	40 29       	lddsp	r9,sp[0x8]
80009b98:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009b9c:	c0 c1       	brne	80009bb4 <_dtoa_r+0x87c>
80009b9e:	12 98       	mov	r8,r9
80009ba0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009ba4:	c0 80       	breq	80009bb4 <_dtoa_r+0x87c>
80009ba6:	40 4c       	lddsp	r12,sp[0x10]
80009ba8:	30 1b       	mov	r11,1
80009baa:	2f fc       	sub	r12,-1
80009bac:	2f f0       	sub	r0,-1
80009bae:	50 4c       	stdsp	sp[0x10],r12
80009bb0:	50 6b       	stdsp	sp[0x18],r11
80009bb2:	c0 38       	rjmp	80009bb8 <_dtoa_r+0x880>
80009bb4:	30 0a       	mov	r10,0
80009bb6:	50 6a       	stdsp	sp[0x18],r10
80009bb8:	41 19       	lddsp	r9,sp[0x44]
80009bba:	58 09       	cp.w	r9,0
80009bbc:	c0 31       	brne	80009bc2 <_dtoa_r+0x88a>
80009bbe:	30 1c       	mov	r12,1
80009bc0:	c0 98       	rjmp	80009bd2 <_dtoa_r+0x89a>
80009bc2:	64 48       	ld.w	r8,r2[0x10]
80009bc4:	2f c8       	sub	r8,-4
80009bc6:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009bca:	e0 a0 05 df 	rcall	8000a788 <__hi0bits>
80009bce:	f8 0c 11 20 	rsub	r12,r12,32
80009bd2:	40 4b       	lddsp	r11,sp[0x10]
80009bd4:	f8 0b 00 08 	add	r8,r12,r11
80009bd8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009bdc:	c0 c0       	breq	80009bf4 <_dtoa_r+0x8bc>
80009bde:	f0 08 11 20 	rsub	r8,r8,32
80009be2:	58 48       	cp.w	r8,4
80009be4:	e0 8a 00 06 	brle	80009bf0 <_dtoa_r+0x8b8>
80009be8:	20 48       	sub	r8,4
80009bea:	10 0b       	add	r11,r8
80009bec:	50 4b       	stdsp	sp[0x10],r11
80009bee:	c0 78       	rjmp	80009bfc <_dtoa_r+0x8c4>
80009bf0:	58 48       	cp.w	r8,4
80009bf2:	c0 70       	breq	80009c00 <_dtoa_r+0x8c8>
80009bf4:	40 4a       	lddsp	r10,sp[0x10]
80009bf6:	2e 48       	sub	r8,-28
80009bf8:	10 0a       	add	r10,r8
80009bfa:	50 4a       	stdsp	sp[0x10],r10
80009bfc:	10 00       	add	r0,r8
80009bfe:	10 05       	add	r5,r8
80009c00:	58 00       	cp.w	r0,0
80009c02:	e0 8a 00 08 	brle	80009c12 <_dtoa_r+0x8da>
80009c06:	06 9b       	mov	r11,r3
80009c08:	00 9a       	mov	r10,r0
80009c0a:	0e 9c       	mov	r12,r7
80009c0c:	e0 a0 07 58 	rcall	8000aabc <__lshift>
80009c10:	18 93       	mov	r3,r12
80009c12:	40 49       	lddsp	r9,sp[0x10]
80009c14:	58 09       	cp.w	r9,0
80009c16:	e0 8a 00 08 	brle	80009c26 <_dtoa_r+0x8ee>
80009c1a:	04 9b       	mov	r11,r2
80009c1c:	12 9a       	mov	r10,r9
80009c1e:	0e 9c       	mov	r12,r7
80009c20:	e0 a0 07 4e 	rcall	8000aabc <__lshift>
80009c24:	18 92       	mov	r2,r12
80009c26:	41 48       	lddsp	r8,sp[0x50]
80009c28:	58 08       	cp.w	r8,0
80009c2a:	c1 b0       	breq	80009c60 <_dtoa_r+0x928>
80009c2c:	04 9b       	mov	r11,r2
80009c2e:	06 9c       	mov	r12,r3
80009c30:	e0 a0 06 23 	rcall	8000a876 <__mcmp>
80009c34:	c1 64       	brge	80009c60 <_dtoa_r+0x928>
80009c36:	06 9b       	mov	r11,r3
80009c38:	30 09       	mov	r9,0
80009c3a:	30 aa       	mov	r10,10
80009c3c:	0e 9c       	mov	r12,r7
80009c3e:	e0 a0 08 0b 	rcall	8000ac54 <__multadd>
80009c42:	20 16       	sub	r6,1
80009c44:	18 93       	mov	r3,r12
80009c46:	40 dc       	lddsp	r12,sp[0x34]
80009c48:	58 0c       	cp.w	r12,0
80009c4a:	c0 31       	brne	80009c50 <_dtoa_r+0x918>
80009c4c:	40 91       	lddsp	r1,sp[0x24]
80009c4e:	c0 98       	rjmp	80009c60 <_dtoa_r+0x928>
80009c50:	08 9b       	mov	r11,r4
80009c52:	40 91       	lddsp	r1,sp[0x24]
80009c54:	30 09       	mov	r9,0
80009c56:	30 aa       	mov	r10,10
80009c58:	0e 9c       	mov	r12,r7
80009c5a:	e0 a0 07 fd 	rcall	8000ac54 <__multadd>
80009c5e:	18 94       	mov	r4,r12
80009c60:	58 01       	cp.w	r1,0
80009c62:	5f a9       	srle	r9
80009c64:	40 cb       	lddsp	r11,sp[0x30]
80009c66:	58 2b       	cp.w	r11,2
80009c68:	5f 98       	srgt	r8
80009c6a:	f3 e8 00 08 	and	r8,r9,r8
80009c6e:	c2 50       	breq	80009cb8 <_dtoa_r+0x980>
80009c70:	58 01       	cp.w	r1,0
80009c72:	c1 11       	brne	80009c94 <_dtoa_r+0x95c>
80009c74:	04 9b       	mov	r11,r2
80009c76:	02 99       	mov	r9,r1
80009c78:	30 5a       	mov	r10,5
80009c7a:	0e 9c       	mov	r12,r7
80009c7c:	e0 a0 07 ec 	rcall	8000ac54 <__multadd>
80009c80:	18 92       	mov	r2,r12
80009c82:	18 9b       	mov	r11,r12
80009c84:	06 9c       	mov	r12,r3
80009c86:	e0 a0 05 f8 	rcall	8000a876 <__mcmp>
80009c8a:	e0 89 00 0f 	brgt	80009ca8 <_dtoa_r+0x970>
80009c8e:	c0 38       	rjmp	80009c94 <_dtoa_r+0x95c>
80009c90:	30 02       	mov	r2,0
80009c92:	04 94       	mov	r4,r2
80009c94:	40 ea       	lddsp	r10,sp[0x38]
80009c96:	30 09       	mov	r9,0
80009c98:	5c da       	com	r10
80009c9a:	40 85       	lddsp	r5,sp[0x20]
80009c9c:	50 6a       	stdsp	sp[0x18],r10
80009c9e:	50 49       	stdsp	sp[0x10],r9
80009ca0:	c0 f9       	rjmp	80009ebe <_dtoa_r+0xb86>
80009ca2:	08 92       	mov	r2,r4
80009ca4:	40 66       	lddsp	r6,sp[0x18]
80009ca6:	04 94       	mov	r4,r2
80009ca8:	2f f6       	sub	r6,-1
80009caa:	50 66       	stdsp	sp[0x18],r6
80009cac:	33 18       	mov	r8,49
80009cae:	40 85       	lddsp	r5,sp[0x20]
80009cb0:	0a c8       	st.b	r5++,r8
80009cb2:	30 08       	mov	r8,0
80009cb4:	50 48       	stdsp	sp[0x10],r8
80009cb6:	c0 49       	rjmp	80009ebe <_dtoa_r+0xb86>
80009cb8:	40 dc       	lddsp	r12,sp[0x34]
80009cba:	58 0c       	cp.w	r12,0
80009cbc:	e0 80 00 b5 	breq	80009e26 <_dtoa_r+0xaee>
80009cc0:	58 05       	cp.w	r5,0
80009cc2:	e0 8a 00 08 	brle	80009cd2 <_dtoa_r+0x99a>
80009cc6:	08 9b       	mov	r11,r4
80009cc8:	0a 9a       	mov	r10,r5
80009cca:	0e 9c       	mov	r12,r7
80009ccc:	e0 a0 06 f8 	rcall	8000aabc <__lshift>
80009cd0:	18 94       	mov	r4,r12
80009cd2:	40 6b       	lddsp	r11,sp[0x18]
80009cd4:	58 0b       	cp.w	r11,0
80009cd6:	c0 31       	brne	80009cdc <_dtoa_r+0x9a4>
80009cd8:	08 9c       	mov	r12,r4
80009cda:	c1 38       	rjmp	80009d00 <_dtoa_r+0x9c8>
80009cdc:	68 1b       	ld.w	r11,r4[0x4]
80009cde:	0e 9c       	mov	r12,r7
80009ce0:	e0 a0 05 fe 	rcall	8000a8dc <_Balloc>
80009ce4:	68 4a       	ld.w	r10,r4[0x10]
80009ce6:	18 95       	mov	r5,r12
80009ce8:	e8 cb ff f4 	sub	r11,r4,-12
80009cec:	2f ea       	sub	r10,-2
80009cee:	2f 4c       	sub	r12,-12
80009cf0:	a3 6a       	lsl	r10,0x2
80009cf2:	fe b0 e6 50 	rcall	80006992 <memcpy>
80009cf6:	0a 9b       	mov	r11,r5
80009cf8:	30 1a       	mov	r10,1
80009cfa:	0e 9c       	mov	r12,r7
80009cfc:	e0 a0 06 e0 	rcall	8000aabc <__lshift>
80009d00:	50 44       	stdsp	sp[0x10],r4
80009d02:	40 3a       	lddsp	r10,sp[0xc]
80009d04:	30 19       	mov	r9,1
80009d06:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009d0a:	18 94       	mov	r4,r12
80009d0c:	50 da       	stdsp	sp[0x34],r10
80009d0e:	40 85       	lddsp	r5,sp[0x20]
80009d10:	50 99       	stdsp	sp[0x24],r9
80009d12:	50 26       	stdsp	sp[0x8],r6
80009d14:	50 e1       	stdsp	sp[0x38],r1
80009d16:	04 9b       	mov	r11,r2
80009d18:	06 9c       	mov	r12,r3
80009d1a:	fe b0 fa 7f 	rcall	80009218 <quorem>
80009d1e:	40 4b       	lddsp	r11,sp[0x10]
80009d20:	f8 c0 ff d0 	sub	r0,r12,-48
80009d24:	06 9c       	mov	r12,r3
80009d26:	e0 a0 05 a8 	rcall	8000a876 <__mcmp>
80009d2a:	08 9a       	mov	r10,r4
80009d2c:	50 6c       	stdsp	sp[0x18],r12
80009d2e:	04 9b       	mov	r11,r2
80009d30:	0e 9c       	mov	r12,r7
80009d32:	e0 a0 06 5d 	rcall	8000a9ec <__mdiff>
80009d36:	18 91       	mov	r1,r12
80009d38:	78 38       	ld.w	r8,r12[0xc]
80009d3a:	58 08       	cp.w	r8,0
80009d3c:	c0 30       	breq	80009d42 <_dtoa_r+0xa0a>
80009d3e:	30 16       	mov	r6,1
80009d40:	c0 68       	rjmp	80009d4c <_dtoa_r+0xa14>
80009d42:	18 9b       	mov	r11,r12
80009d44:	06 9c       	mov	r12,r3
80009d46:	e0 a0 05 98 	rcall	8000a876 <__mcmp>
80009d4a:	18 96       	mov	r6,r12
80009d4c:	0e 9c       	mov	r12,r7
80009d4e:	02 9b       	mov	r11,r1
80009d50:	e0 a0 05 ac 	rcall	8000a8a8 <_Bfree>
80009d54:	40 cc       	lddsp	r12,sp[0x30]
80009d56:	ed ec 10 08 	or	r8,r6,r12
80009d5a:	c0 d1       	brne	80009d74 <_dtoa_r+0xa3c>
80009d5c:	40 db       	lddsp	r11,sp[0x34]
80009d5e:	58 0b       	cp.w	r11,0
80009d60:	c0 a1       	brne	80009d74 <_dtoa_r+0xa3c>
80009d62:	40 26       	lddsp	r6,sp[0x8]
80009d64:	e0 40 00 39 	cp.w	r0,57
80009d68:	c3 00       	breq	80009dc8 <_dtoa_r+0xa90>
80009d6a:	40 6a       	lddsp	r10,sp[0x18]
80009d6c:	58 0a       	cp.w	r10,0
80009d6e:	e0 89 00 24 	brgt	80009db6 <_dtoa_r+0xa7e>
80009d72:	c2 f8       	rjmp	80009dd0 <_dtoa_r+0xa98>
80009d74:	40 69       	lddsp	r9,sp[0x18]
80009d76:	58 09       	cp.w	r9,0
80009d78:	c0 85       	brlt	80009d88 <_dtoa_r+0xa50>
80009d7a:	12 98       	mov	r8,r9
80009d7c:	40 cc       	lddsp	r12,sp[0x30]
80009d7e:	18 48       	or	r8,r12
80009d80:	c1 d1       	brne	80009dba <_dtoa_r+0xa82>
80009d82:	40 db       	lddsp	r11,sp[0x34]
80009d84:	58 0b       	cp.w	r11,0
80009d86:	c1 a1       	brne	80009dba <_dtoa_r+0xa82>
80009d88:	0c 99       	mov	r9,r6
80009d8a:	40 26       	lddsp	r6,sp[0x8]
80009d8c:	58 09       	cp.w	r9,0
80009d8e:	e0 8a 00 21 	brle	80009dd0 <_dtoa_r+0xa98>
80009d92:	06 9b       	mov	r11,r3
80009d94:	30 1a       	mov	r10,1
80009d96:	0e 9c       	mov	r12,r7
80009d98:	e0 a0 06 92 	rcall	8000aabc <__lshift>
80009d9c:	04 9b       	mov	r11,r2
80009d9e:	18 93       	mov	r3,r12
80009da0:	e0 a0 05 6b 	rcall	8000a876 <__mcmp>
80009da4:	e0 89 00 06 	brgt	80009db0 <_dtoa_r+0xa78>
80009da8:	c1 41       	brne	80009dd0 <_dtoa_r+0xa98>
80009daa:	ed b0 00 00 	bld	r0,0x0
80009dae:	c1 11       	brne	80009dd0 <_dtoa_r+0xa98>
80009db0:	e0 40 00 39 	cp.w	r0,57
80009db4:	c0 a0       	breq	80009dc8 <_dtoa_r+0xa90>
80009db6:	2f f0       	sub	r0,-1
80009db8:	c0 c8       	rjmp	80009dd0 <_dtoa_r+0xa98>
80009dba:	58 06       	cp.w	r6,0
80009dbc:	e0 8a 00 0c 	brle	80009dd4 <_dtoa_r+0xa9c>
80009dc0:	40 26       	lddsp	r6,sp[0x8]
80009dc2:	e0 40 00 39 	cp.w	r0,57
80009dc6:	c0 41       	brne	80009dce <_dtoa_r+0xa96>
80009dc8:	33 98       	mov	r8,57
80009dca:	0a c8       	st.b	r5++,r8
80009dcc:	c6 78       	rjmp	80009e9a <_dtoa_r+0xb62>
80009dce:	2f f0       	sub	r0,-1
80009dd0:	0a c0       	st.b	r5++,r0
80009dd2:	c7 58       	rjmp	80009ebc <_dtoa_r+0xb84>
80009dd4:	0a c0       	st.b	r5++,r0
80009dd6:	40 9a       	lddsp	r10,sp[0x24]
80009dd8:	40 e9       	lddsp	r9,sp[0x38]
80009dda:	12 3a       	cp.w	r10,r9
80009ddc:	c4 30       	breq	80009e62 <_dtoa_r+0xb2a>
80009dde:	06 9b       	mov	r11,r3
80009de0:	30 09       	mov	r9,0
80009de2:	30 aa       	mov	r10,10
80009de4:	0e 9c       	mov	r12,r7
80009de6:	e0 a0 07 37 	rcall	8000ac54 <__multadd>
80009dea:	40 48       	lddsp	r8,sp[0x10]
80009dec:	18 93       	mov	r3,r12
80009dee:	08 38       	cp.w	r8,r4
80009df0:	c0 91       	brne	80009e02 <_dtoa_r+0xaca>
80009df2:	10 9b       	mov	r11,r8
80009df4:	30 09       	mov	r9,0
80009df6:	30 aa       	mov	r10,10
80009df8:	0e 9c       	mov	r12,r7
80009dfa:	e0 a0 07 2d 	rcall	8000ac54 <__multadd>
80009dfe:	50 4c       	stdsp	sp[0x10],r12
80009e00:	c0 e8       	rjmp	80009e1c <_dtoa_r+0xae4>
80009e02:	40 4b       	lddsp	r11,sp[0x10]
80009e04:	30 09       	mov	r9,0
80009e06:	30 aa       	mov	r10,10
80009e08:	0e 9c       	mov	r12,r7
80009e0a:	e0 a0 07 25 	rcall	8000ac54 <__multadd>
80009e0e:	08 9b       	mov	r11,r4
80009e10:	50 4c       	stdsp	sp[0x10],r12
80009e12:	30 09       	mov	r9,0
80009e14:	30 aa       	mov	r10,10
80009e16:	0e 9c       	mov	r12,r7
80009e18:	e0 a0 07 1e 	rcall	8000ac54 <__multadd>
80009e1c:	18 94       	mov	r4,r12
80009e1e:	40 9c       	lddsp	r12,sp[0x24]
80009e20:	2f fc       	sub	r12,-1
80009e22:	50 9c       	stdsp	sp[0x24],r12
80009e24:	c7 9b       	rjmp	80009d16 <_dtoa_r+0x9de>
80009e26:	30 18       	mov	r8,1
80009e28:	06 90       	mov	r0,r3
80009e2a:	40 85       	lddsp	r5,sp[0x20]
80009e2c:	08 93       	mov	r3,r4
80009e2e:	0c 94       	mov	r4,r6
80009e30:	10 96       	mov	r6,r8
80009e32:	04 9b       	mov	r11,r2
80009e34:	00 9c       	mov	r12,r0
80009e36:	fe b0 f9 f1 	rcall	80009218 <quorem>
80009e3a:	2d 0c       	sub	r12,-48
80009e3c:	0a cc       	st.b	r5++,r12
80009e3e:	02 36       	cp.w	r6,r1
80009e40:	c0 a4       	brge	80009e54 <_dtoa_r+0xb1c>
80009e42:	00 9b       	mov	r11,r0
80009e44:	30 09       	mov	r9,0
80009e46:	30 aa       	mov	r10,10
80009e48:	0e 9c       	mov	r12,r7
80009e4a:	2f f6       	sub	r6,-1
80009e4c:	e0 a0 07 04 	rcall	8000ac54 <__multadd>
80009e50:	18 90       	mov	r0,r12
80009e52:	cf 0b       	rjmp	80009e32 <_dtoa_r+0xafa>
80009e54:	08 96       	mov	r6,r4
80009e56:	30 0b       	mov	r11,0
80009e58:	06 94       	mov	r4,r3
80009e5a:	50 4b       	stdsp	sp[0x10],r11
80009e5c:	00 93       	mov	r3,r0
80009e5e:	18 90       	mov	r0,r12
80009e60:	c0 28       	rjmp	80009e64 <_dtoa_r+0xb2c>
80009e62:	40 26       	lddsp	r6,sp[0x8]
80009e64:	06 9b       	mov	r11,r3
80009e66:	30 1a       	mov	r10,1
80009e68:	0e 9c       	mov	r12,r7
80009e6a:	e0 a0 06 29 	rcall	8000aabc <__lshift>
80009e6e:	04 9b       	mov	r11,r2
80009e70:	18 93       	mov	r3,r12
80009e72:	e0 a0 05 02 	rcall	8000a876 <__mcmp>
80009e76:	e0 89 00 12 	brgt	80009e9a <_dtoa_r+0xb62>
80009e7a:	c1 b1       	brne	80009eb0 <_dtoa_r+0xb78>
80009e7c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009e80:	c0 d1       	brne	80009e9a <_dtoa_r+0xb62>
80009e82:	c1 78       	rjmp	80009eb0 <_dtoa_r+0xb78>
80009e84:	40 89       	lddsp	r9,sp[0x20]
80009e86:	12 38       	cp.w	r8,r9
80009e88:	c0 30       	breq	80009e8e <_dtoa_r+0xb56>
80009e8a:	10 95       	mov	r5,r8
80009e8c:	c0 88       	rjmp	80009e9c <_dtoa_r+0xb64>
80009e8e:	2f f6       	sub	r6,-1
80009e90:	50 66       	stdsp	sp[0x18],r6
80009e92:	33 18       	mov	r8,49
80009e94:	40 8c       	lddsp	r12,sp[0x20]
80009e96:	b8 88       	st.b	r12[0x0],r8
80009e98:	c1 38       	rjmp	80009ebe <_dtoa_r+0xb86>
80009e9a:	33 9a       	mov	r10,57
80009e9c:	0a 98       	mov	r8,r5
80009e9e:	11 79       	ld.ub	r9,--r8
80009ea0:	f4 09 18 00 	cp.b	r9,r10
80009ea4:	cf 00       	breq	80009e84 <_dtoa_r+0xb4c>
80009ea6:	2f f9       	sub	r9,-1
80009ea8:	b0 89       	st.b	r8[0x0],r9
80009eaa:	c0 98       	rjmp	80009ebc <_dtoa_r+0xb84>
80009eac:	10 95       	mov	r5,r8
80009eae:	c0 28       	rjmp	80009eb2 <_dtoa_r+0xb7a>
80009eb0:	33 09       	mov	r9,48
80009eb2:	0a 98       	mov	r8,r5
80009eb4:	11 7a       	ld.ub	r10,--r8
80009eb6:	f2 0a 18 00 	cp.b	r10,r9
80009eba:	cf 90       	breq	80009eac <_dtoa_r+0xb74>
80009ebc:	50 66       	stdsp	sp[0x18],r6
80009ebe:	04 9b       	mov	r11,r2
80009ec0:	0e 9c       	mov	r12,r7
80009ec2:	e0 a0 04 f3 	rcall	8000a8a8 <_Bfree>
80009ec6:	58 04       	cp.w	r4,0
80009ec8:	c1 20       	breq	80009eec <_dtoa_r+0xbb4>
80009eca:	40 4b       	lddsp	r11,sp[0x10]
80009ecc:	08 3b       	cp.w	r11,r4
80009ece:	5f 19       	srne	r9
80009ed0:	58 0b       	cp.w	r11,0
80009ed2:	5f 18       	srne	r8
80009ed4:	f3 e8 00 08 	and	r8,r9,r8
80009ed8:	c0 40       	breq	80009ee0 <_dtoa_r+0xba8>
80009eda:	0e 9c       	mov	r12,r7
80009edc:	e0 a0 04 e6 	rcall	8000a8a8 <_Bfree>
80009ee0:	08 9b       	mov	r11,r4
80009ee2:	0e 9c       	mov	r12,r7
80009ee4:	e0 a0 04 e2 	rcall	8000a8a8 <_Bfree>
80009ee8:	c0 28       	rjmp	80009eec <_dtoa_r+0xbb4>
80009eea:	50 66       	stdsp	sp[0x18],r6
80009eec:	0e 9c       	mov	r12,r7
80009eee:	06 9b       	mov	r11,r3
80009ef0:	e0 a0 04 dc 	rcall	8000a8a8 <_Bfree>
80009ef4:	30 08       	mov	r8,0
80009ef6:	aa 88       	st.b	r5[0x0],r8
80009ef8:	40 68       	lddsp	r8,sp[0x18]
80009efa:	41 5a       	lddsp	r10,sp[0x54]
80009efc:	2f f8       	sub	r8,-1
80009efe:	41 29       	lddsp	r9,sp[0x48]
80009f00:	95 08       	st.w	r10[0x0],r8
80009f02:	40 8c       	lddsp	r12,sp[0x20]
80009f04:	58 09       	cp.w	r9,0
80009f06:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009f0a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009f0e:	2e 6d       	sub	sp,-104
80009f10:	d8 32       	popm	r0-r7,pc
80009f12:	d7 03       	nop

80009f14 <__errno>:
80009f14:	e0 68 0a 1c 	mov	r8,2588
80009f18:	70 0c       	ld.w	r12,r8[0x0]
80009f1a:	2f 4c       	sub	r12,-12
80009f1c:	5e fc       	retal	r12
80009f1e:	d7 03       	nop

80009f20 <_fflush_r>:
80009f20:	d4 21       	pushm	r4-r7,lr
80009f22:	16 97       	mov	r7,r11
80009f24:	18 96       	mov	r6,r12
80009f26:	76 48       	ld.w	r8,r11[0x10]
80009f28:	58 08       	cp.w	r8,0
80009f2a:	c7 f0       	breq	8000a028 <_fflush_r+0x108>
80009f2c:	58 0c       	cp.w	r12,0
80009f2e:	c0 50       	breq	80009f38 <_fflush_r+0x18>
80009f30:	78 68       	ld.w	r8,r12[0x18]
80009f32:	58 08       	cp.w	r8,0
80009f34:	c0 21       	brne	80009f38 <_fflush_r+0x18>
80009f36:	cc dc       	rcall	8000a0d0 <__sinit>
80009f38:	fe c8 cb 64 	sub	r8,pc,-13468
80009f3c:	10 37       	cp.w	r7,r8
80009f3e:	c0 31       	brne	80009f44 <_fflush_r+0x24>
80009f40:	6c 07       	ld.w	r7,r6[0x0]
80009f42:	c0 c8       	rjmp	80009f5a <_fflush_r+0x3a>
80009f44:	fe c8 cb 50 	sub	r8,pc,-13488
80009f48:	10 37       	cp.w	r7,r8
80009f4a:	c0 31       	brne	80009f50 <_fflush_r+0x30>
80009f4c:	6c 17       	ld.w	r7,r6[0x4]
80009f4e:	c0 68       	rjmp	80009f5a <_fflush_r+0x3a>
80009f50:	fe c8 cb 3c 	sub	r8,pc,-13508
80009f54:	10 37       	cp.w	r7,r8
80009f56:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009f5a:	8e 6a       	ld.sh	r10,r7[0xc]
80009f5c:	14 98       	mov	r8,r10
80009f5e:	ed ba 00 03 	bld	r10,0x3
80009f62:	c4 20       	breq	80009fe6 <_fflush_r+0xc6>
80009f64:	ab ba       	sbr	r10,0xb
80009f66:	ae 6a       	st.h	r7[0xc],r10
80009f68:	6e 18       	ld.w	r8,r7[0x4]
80009f6a:	58 08       	cp.w	r8,0
80009f6c:	e0 89 00 06 	brgt	80009f78 <_fflush_r+0x58>
80009f70:	6f 08       	ld.w	r8,r7[0x40]
80009f72:	58 08       	cp.w	r8,0
80009f74:	e0 8a 00 5a 	brle	8000a028 <_fflush_r+0x108>
80009f78:	6e b8       	ld.w	r8,r7[0x2c]
80009f7a:	58 08       	cp.w	r8,0
80009f7c:	c5 60       	breq	8000a028 <_fflush_r+0x108>
80009f7e:	e2 1a 10 00 	andl	r10,0x1000,COH
80009f82:	c0 30       	breq	80009f88 <_fflush_r+0x68>
80009f84:	6f 55       	ld.w	r5,r7[0x54]
80009f86:	c0 f8       	rjmp	80009fa4 <_fflush_r+0x84>
80009f88:	30 19       	mov	r9,1
80009f8a:	6e 8b       	ld.w	r11,r7[0x20]
80009f8c:	0c 9c       	mov	r12,r6
80009f8e:	5d 18       	icall	r8
80009f90:	18 95       	mov	r5,r12
80009f92:	5b fc       	cp.w	r12,-1
80009f94:	c0 81       	brne	80009fa4 <_fflush_r+0x84>
80009f96:	6c 38       	ld.w	r8,r6[0xc]
80009f98:	59 d8       	cp.w	r8,29
80009f9a:	c4 70       	breq	8000a028 <_fflush_r+0x108>
80009f9c:	8e 68       	ld.sh	r8,r7[0xc]
80009f9e:	a7 a8       	sbr	r8,0x6
80009fa0:	ae 68       	st.h	r7[0xc],r8
80009fa2:	d8 22       	popm	r4-r7,pc
80009fa4:	8e 68       	ld.sh	r8,r7[0xc]
80009fa6:	ed b8 00 02 	bld	r8,0x2
80009faa:	c0 91       	brne	80009fbc <_fflush_r+0x9c>
80009fac:	6e 18       	ld.w	r8,r7[0x4]
80009fae:	10 15       	sub	r5,r8
80009fb0:	6e d8       	ld.w	r8,r7[0x34]
80009fb2:	58 08       	cp.w	r8,0
80009fb4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009fb8:	eb d8 e1 15 	subne	r5,r5,r8
80009fbc:	6e b8       	ld.w	r8,r7[0x2c]
80009fbe:	0c 9c       	mov	r12,r6
80009fc0:	30 09       	mov	r9,0
80009fc2:	0a 9a       	mov	r10,r5
80009fc4:	6e 8b       	ld.w	r11,r7[0x20]
80009fc6:	5d 18       	icall	r8
80009fc8:	8e 68       	ld.sh	r8,r7[0xc]
80009fca:	0a 3c       	cp.w	r12,r5
80009fcc:	c2 61       	brne	8000a018 <_fflush_r+0xf8>
80009fce:	ab d8       	cbr	r8,0xb
80009fd0:	30 0c       	mov	r12,0
80009fd2:	6e 49       	ld.w	r9,r7[0x10]
80009fd4:	ae 68       	st.h	r7[0xc],r8
80009fd6:	8f 1c       	st.w	r7[0x4],r12
80009fd8:	8f 09       	st.w	r7[0x0],r9
80009fda:	ed b8 00 0c 	bld	r8,0xc
80009fde:	c2 51       	brne	8000a028 <_fflush_r+0x108>
80009fe0:	ef 45 00 54 	st.w	r7[84],r5
80009fe4:	d8 22       	popm	r4-r7,pc
80009fe6:	6e 45       	ld.w	r5,r7[0x10]
80009fe8:	58 05       	cp.w	r5,0
80009fea:	c1 f0       	breq	8000a028 <_fflush_r+0x108>
80009fec:	6e 04       	ld.w	r4,r7[0x0]
80009fee:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009ff2:	8f 05       	st.w	r7[0x0],r5
80009ff4:	f9 b8 01 00 	movne	r8,0
80009ff8:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009ffc:	0a 14       	sub	r4,r5
80009ffe:	8f 28       	st.w	r7[0x8],r8
8000a000:	c1 18       	rjmp	8000a022 <_fflush_r+0x102>
8000a002:	08 99       	mov	r9,r4
8000a004:	0a 9a       	mov	r10,r5
8000a006:	6e a8       	ld.w	r8,r7[0x28]
8000a008:	6e 8b       	ld.w	r11,r7[0x20]
8000a00a:	0c 9c       	mov	r12,r6
8000a00c:	5d 18       	icall	r8
8000a00e:	18 14       	sub	r4,r12
8000a010:	58 0c       	cp.w	r12,0
8000a012:	e0 89 00 07 	brgt	8000a020 <_fflush_r+0x100>
8000a016:	8e 68       	ld.sh	r8,r7[0xc]
8000a018:	a7 a8       	sbr	r8,0x6
8000a01a:	3f fc       	mov	r12,-1
8000a01c:	ae 68       	st.h	r7[0xc],r8
8000a01e:	d8 22       	popm	r4-r7,pc
8000a020:	18 05       	add	r5,r12
8000a022:	58 04       	cp.w	r4,0
8000a024:	fe 99 ff ef 	brgt	8000a002 <_fflush_r+0xe2>
8000a028:	d8 2a       	popm	r4-r7,pc,r12=0
8000a02a:	d7 03       	nop

8000a02c <__sfp_lock_acquire>:
8000a02c:	5e fc       	retal	r12

8000a02e <__sfp_lock_release>:
8000a02e:	5e fc       	retal	r12

8000a030 <_cleanup_r>:
8000a030:	d4 01       	pushm	lr
8000a032:	fe cb f0 ae 	sub	r11,pc,-3922
8000a036:	e0 a0 02 f7 	rcall	8000a624 <_fwalk>
8000a03a:	d8 02       	popm	pc

8000a03c <__sfmoreglue>:
8000a03c:	d4 21       	pushm	r4-r7,lr
8000a03e:	16 95       	mov	r5,r11
8000a040:	f6 06 10 5c 	mul	r6,r11,92
8000a044:	ec cb ff f4 	sub	r11,r6,-12
8000a048:	fe b0 e2 76 	rcall	80006534 <_malloc_r>
8000a04c:	18 97       	mov	r7,r12
8000a04e:	c0 90       	breq	8000a060 <__sfmoreglue+0x24>
8000a050:	99 15       	st.w	r12[0x4],r5
8000a052:	30 0b       	mov	r11,0
8000a054:	2f 4c       	sub	r12,-12
8000a056:	0c 9a       	mov	r10,r6
8000a058:	8f 2c       	st.w	r7[0x8],r12
8000a05a:	8f 0b       	st.w	r7[0x0],r11
8000a05c:	fe b0 e5 3f 	rcall	80006ada <memset>
8000a060:	0e 9c       	mov	r12,r7
8000a062:	d8 22       	popm	r4-r7,pc

8000a064 <__sfp>:
8000a064:	d4 21       	pushm	r4-r7,lr
8000a066:	fe c8 cc 2e 	sub	r8,pc,-13266
8000a06a:	18 96       	mov	r6,r12
8000a06c:	70 07       	ld.w	r7,r8[0x0]
8000a06e:	6e 68       	ld.w	r8,r7[0x18]
8000a070:	58 08       	cp.w	r8,0
8000a072:	c0 31       	brne	8000a078 <__sfp+0x14>
8000a074:	0e 9c       	mov	r12,r7
8000a076:	c2 dc       	rcall	8000a0d0 <__sinit>
8000a078:	ee c7 ff 28 	sub	r7,r7,-216
8000a07c:	30 05       	mov	r5,0
8000a07e:	6e 2c       	ld.w	r12,r7[0x8]
8000a080:	6e 18       	ld.w	r8,r7[0x4]
8000a082:	c0 68       	rjmp	8000a08e <__sfp+0x2a>
8000a084:	98 69       	ld.sh	r9,r12[0xc]
8000a086:	ea 09 19 00 	cp.h	r9,r5
8000a08a:	c1 10       	breq	8000a0ac <__sfp+0x48>
8000a08c:	2a 4c       	sub	r12,-92
8000a08e:	20 18       	sub	r8,1
8000a090:	cf a7       	brpl	8000a084 <__sfp+0x20>
8000a092:	6e 08       	ld.w	r8,r7[0x0]
8000a094:	58 08       	cp.w	r8,0
8000a096:	c0 61       	brne	8000a0a2 <__sfp+0x3e>
8000a098:	30 4b       	mov	r11,4
8000a09a:	0c 9c       	mov	r12,r6
8000a09c:	cd 0f       	rcall	8000a03c <__sfmoreglue>
8000a09e:	8f 0c       	st.w	r7[0x0],r12
8000a0a0:	c0 30       	breq	8000a0a6 <__sfp+0x42>
8000a0a2:	6e 07       	ld.w	r7,r7[0x0]
8000a0a4:	ce db       	rjmp	8000a07e <__sfp+0x1a>
8000a0a6:	30 c8       	mov	r8,12
8000a0a8:	8d 38       	st.w	r6[0xc],r8
8000a0aa:	d8 22       	popm	r4-r7,pc
8000a0ac:	30 08       	mov	r8,0
8000a0ae:	f9 48 00 4c 	st.w	r12[76],r8
8000a0b2:	99 08       	st.w	r12[0x0],r8
8000a0b4:	99 28       	st.w	r12[0x8],r8
8000a0b6:	99 18       	st.w	r12[0x4],r8
8000a0b8:	99 48       	st.w	r12[0x10],r8
8000a0ba:	99 58       	st.w	r12[0x14],r8
8000a0bc:	99 68       	st.w	r12[0x18],r8
8000a0be:	99 d8       	st.w	r12[0x34],r8
8000a0c0:	99 e8       	st.w	r12[0x38],r8
8000a0c2:	f9 48 00 48 	st.w	r12[72],r8
8000a0c6:	3f f8       	mov	r8,-1
8000a0c8:	b8 78       	st.h	r12[0xe],r8
8000a0ca:	30 18       	mov	r8,1
8000a0cc:	b8 68       	st.h	r12[0xc],r8
8000a0ce:	d8 22       	popm	r4-r7,pc

8000a0d0 <__sinit>:
8000a0d0:	d4 21       	pushm	r4-r7,lr
8000a0d2:	18 96       	mov	r6,r12
8000a0d4:	78 67       	ld.w	r7,r12[0x18]
8000a0d6:	58 07       	cp.w	r7,0
8000a0d8:	c4 91       	brne	8000a16a <__sinit+0x9a>
8000a0da:	fe c8 00 aa 	sub	r8,pc,170
8000a0de:	30 15       	mov	r5,1
8000a0e0:	99 a8       	st.w	r12[0x28],r8
8000a0e2:	f9 47 00 d8 	st.w	r12[216],r7
8000a0e6:	f9 47 00 dc 	st.w	r12[220],r7
8000a0ea:	f9 47 00 e0 	st.w	r12[224],r7
8000a0ee:	99 65       	st.w	r12[0x18],r5
8000a0f0:	cb af       	rcall	8000a064 <__sfp>
8000a0f2:	8d 0c       	st.w	r6[0x0],r12
8000a0f4:	0c 9c       	mov	r12,r6
8000a0f6:	cb 7f       	rcall	8000a064 <__sfp>
8000a0f8:	8d 1c       	st.w	r6[0x4],r12
8000a0fa:	0c 9c       	mov	r12,r6
8000a0fc:	cb 4f       	rcall	8000a064 <__sfp>
8000a0fe:	6c 09       	ld.w	r9,r6[0x0]
8000a100:	30 48       	mov	r8,4
8000a102:	93 07       	st.w	r9[0x0],r7
8000a104:	b2 68       	st.h	r9[0xc],r8
8000a106:	93 17       	st.w	r9[0x4],r7
8000a108:	93 27       	st.w	r9[0x8],r7
8000a10a:	6c 18       	ld.w	r8,r6[0x4]
8000a10c:	b2 77       	st.h	r9[0xe],r7
8000a10e:	93 47       	st.w	r9[0x10],r7
8000a110:	93 57       	st.w	r9[0x14],r7
8000a112:	93 67       	st.w	r9[0x18],r7
8000a114:	93 89       	st.w	r9[0x20],r9
8000a116:	91 07       	st.w	r8[0x0],r7
8000a118:	91 17       	st.w	r8[0x4],r7
8000a11a:	91 27       	st.w	r8[0x8],r7
8000a11c:	fe ce f3 24 	sub	lr,pc,-3292
8000a120:	fe cb f3 54 	sub	r11,pc,-3244
8000a124:	93 9e       	st.w	r9[0x24],lr
8000a126:	93 ab       	st.w	r9[0x28],r11
8000a128:	fe ca f3 7c 	sub	r10,pc,-3204
8000a12c:	fe c4 f3 88 	sub	r4,pc,-3192
8000a130:	93 ba       	st.w	r9[0x2c],r10
8000a132:	93 c4       	st.w	r9[0x30],r4
8000a134:	30 99       	mov	r9,9
8000a136:	b0 69       	st.h	r8[0xc],r9
8000a138:	b0 75       	st.h	r8[0xe],r5
8000a13a:	91 c4       	st.w	r8[0x30],r4
8000a13c:	91 47       	st.w	r8[0x10],r7
8000a13e:	91 57       	st.w	r8[0x14],r7
8000a140:	91 67       	st.w	r8[0x18],r7
8000a142:	91 88       	st.w	r8[0x20],r8
8000a144:	91 9e       	st.w	r8[0x24],lr
8000a146:	91 ab       	st.w	r8[0x28],r11
8000a148:	91 ba       	st.w	r8[0x2c],r10
8000a14a:	8d 2c       	st.w	r6[0x8],r12
8000a14c:	31 28       	mov	r8,18
8000a14e:	99 07       	st.w	r12[0x0],r7
8000a150:	b8 68       	st.h	r12[0xc],r8
8000a152:	99 17       	st.w	r12[0x4],r7
8000a154:	99 27       	st.w	r12[0x8],r7
8000a156:	30 28       	mov	r8,2
8000a158:	b8 78       	st.h	r12[0xe],r8
8000a15a:	99 c4       	st.w	r12[0x30],r4
8000a15c:	99 67       	st.w	r12[0x18],r7
8000a15e:	99 9e       	st.w	r12[0x24],lr
8000a160:	99 ab       	st.w	r12[0x28],r11
8000a162:	99 ba       	st.w	r12[0x2c],r10
8000a164:	99 47       	st.w	r12[0x10],r7
8000a166:	99 57       	st.w	r12[0x14],r7
8000a168:	99 8c       	st.w	r12[0x20],r12
8000a16a:	d8 22       	popm	r4-r7,pc

8000a16c <_malloc_trim_r>:
8000a16c:	d4 21       	pushm	r4-r7,lr
8000a16e:	16 95       	mov	r5,r11
8000a170:	18 97       	mov	r7,r12
8000a172:	fe b0 d8 9f 	rcall	800052b0 <__malloc_lock>
8000a176:	e0 64 05 1c 	mov	r4,1308
8000a17a:	68 28       	ld.w	r8,r4[0x8]
8000a17c:	70 16       	ld.w	r6,r8[0x4]
8000a17e:	e0 16 ff fc 	andl	r6,0xfffc
8000a182:	ec c8 ff 91 	sub	r8,r6,-111
8000a186:	f0 05 01 05 	sub	r5,r8,r5
8000a18a:	e0 15 ff 80 	andl	r5,0xff80
8000a18e:	ea c5 00 80 	sub	r5,r5,128
8000a192:	e0 45 00 7f 	cp.w	r5,127
8000a196:	e0 8a 00 25 	brle	8000a1e0 <_malloc_trim_r+0x74>
8000a19a:	30 0b       	mov	r11,0
8000a19c:	0e 9c       	mov	r12,r7
8000a19e:	fe b0 e6 05 	rcall	80006da8 <_sbrk_r>
8000a1a2:	68 28       	ld.w	r8,r4[0x8]
8000a1a4:	0c 08       	add	r8,r6
8000a1a6:	10 3c       	cp.w	r12,r8
8000a1a8:	c1 c1       	brne	8000a1e0 <_malloc_trim_r+0x74>
8000a1aa:	ea 0b 11 00 	rsub	r11,r5,0
8000a1ae:	0e 9c       	mov	r12,r7
8000a1b0:	fe b0 e5 fc 	rcall	80006da8 <_sbrk_r>
8000a1b4:	5b fc       	cp.w	r12,-1
8000a1b6:	c1 91       	brne	8000a1e8 <_malloc_trim_r+0x7c>
8000a1b8:	30 0b       	mov	r11,0
8000a1ba:	0e 9c       	mov	r12,r7
8000a1bc:	fe b0 e5 f6 	rcall	80006da8 <_sbrk_r>
8000a1c0:	68 28       	ld.w	r8,r4[0x8]
8000a1c2:	f8 08 01 09 	sub	r9,r12,r8
8000a1c6:	58 f9       	cp.w	r9,15
8000a1c8:	e0 8a 00 0c 	brle	8000a1e0 <_malloc_trim_r+0x74>
8000a1cc:	a1 a9       	sbr	r9,0x0
8000a1ce:	91 19       	st.w	r8[0x4],r9
8000a1d0:	e0 68 09 28 	mov	r8,2344
8000a1d4:	70 09       	ld.w	r9,r8[0x0]
8000a1d6:	e0 68 0c cc 	mov	r8,3276
8000a1da:	f8 09 01 09 	sub	r9,r12,r9
8000a1de:	91 09       	st.w	r8[0x0],r9
8000a1e0:	0e 9c       	mov	r12,r7
8000a1e2:	fe b0 d8 6d 	rcall	800052bc <__malloc_unlock>
8000a1e6:	d8 2a       	popm	r4-r7,pc,r12=0
8000a1e8:	68 28       	ld.w	r8,r4[0x8]
8000a1ea:	0a 16       	sub	r6,r5
8000a1ec:	a1 a6       	sbr	r6,0x0
8000a1ee:	91 16       	st.w	r8[0x4],r6
8000a1f0:	e0 68 0c cc 	mov	r8,3276
8000a1f4:	70 09       	ld.w	r9,r8[0x0]
8000a1f6:	0a 19       	sub	r9,r5
8000a1f8:	0e 9c       	mov	r12,r7
8000a1fa:	91 09       	st.w	r8[0x0],r9
8000a1fc:	fe b0 d8 60 	rcall	800052bc <__malloc_unlock>
8000a200:	da 2a       	popm	r4-r7,pc,r12=1
8000a202:	d7 03       	nop

8000a204 <_free_r>:
8000a204:	d4 21       	pushm	r4-r7,lr
8000a206:	16 96       	mov	r6,r11
8000a208:	18 97       	mov	r7,r12
8000a20a:	58 0b       	cp.w	r11,0
8000a20c:	e0 80 00 c0 	breq	8000a38c <_free_r+0x188>
8000a210:	fe b0 d8 50 	rcall	800052b0 <__malloc_lock>
8000a214:	20 86       	sub	r6,8
8000a216:	e0 6a 05 1c 	mov	r10,1308
8000a21a:	6c 18       	ld.w	r8,r6[0x4]
8000a21c:	74 2e       	ld.w	lr,r10[0x8]
8000a21e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a222:	a1 c8       	cbr	r8,0x0
8000a224:	ec 08 00 09 	add	r9,r6,r8
8000a228:	72 1b       	ld.w	r11,r9[0x4]
8000a22a:	e0 1b ff fc 	andl	r11,0xfffc
8000a22e:	1c 39       	cp.w	r9,lr
8000a230:	c1 e1       	brne	8000a26c <_free_r+0x68>
8000a232:	f6 08 00 08 	add	r8,r11,r8
8000a236:	58 0c       	cp.w	r12,0
8000a238:	c0 81       	brne	8000a248 <_free_r+0x44>
8000a23a:	6c 09       	ld.w	r9,r6[0x0]
8000a23c:	12 16       	sub	r6,r9
8000a23e:	12 08       	add	r8,r9
8000a240:	6c 3b       	ld.w	r11,r6[0xc]
8000a242:	6c 29       	ld.w	r9,r6[0x8]
8000a244:	97 29       	st.w	r11[0x8],r9
8000a246:	93 3b       	st.w	r9[0xc],r11
8000a248:	10 99       	mov	r9,r8
8000a24a:	95 26       	st.w	r10[0x8],r6
8000a24c:	a1 a9       	sbr	r9,0x0
8000a24e:	8d 19       	st.w	r6[0x4],r9
8000a250:	e0 69 09 24 	mov	r9,2340
8000a254:	72 09       	ld.w	r9,r9[0x0]
8000a256:	12 38       	cp.w	r8,r9
8000a258:	c0 63       	brcs	8000a264 <_free_r+0x60>
8000a25a:	e0 68 0c c8 	mov	r8,3272
8000a25e:	0e 9c       	mov	r12,r7
8000a260:	70 0b       	ld.w	r11,r8[0x0]
8000a262:	c8 5f       	rcall	8000a16c <_malloc_trim_r>
8000a264:	0e 9c       	mov	r12,r7
8000a266:	fe b0 d8 2b 	rcall	800052bc <__malloc_unlock>
8000a26a:	d8 22       	popm	r4-r7,pc
8000a26c:	93 1b       	st.w	r9[0x4],r11
8000a26e:	58 0c       	cp.w	r12,0
8000a270:	c0 30       	breq	8000a276 <_free_r+0x72>
8000a272:	30 0c       	mov	r12,0
8000a274:	c1 08       	rjmp	8000a294 <_free_r+0x90>
8000a276:	6c 0e       	ld.w	lr,r6[0x0]
8000a278:	f4 c5 ff f8 	sub	r5,r10,-8
8000a27c:	1c 16       	sub	r6,lr
8000a27e:	1c 08       	add	r8,lr
8000a280:	6c 2e       	ld.w	lr,r6[0x8]
8000a282:	0a 3e       	cp.w	lr,r5
8000a284:	f9 bc 00 01 	moveq	r12,1
8000a288:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a28c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a290:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a294:	f2 0b 00 0e 	add	lr,r9,r11
8000a298:	7c 1e       	ld.w	lr,lr[0x4]
8000a29a:	ed be 00 00 	bld	lr,0x0
8000a29e:	c1 40       	breq	8000a2c6 <_free_r+0xc2>
8000a2a0:	16 08       	add	r8,r11
8000a2a2:	58 0c       	cp.w	r12,0
8000a2a4:	c0 d1       	brne	8000a2be <_free_r+0xba>
8000a2a6:	e0 6e 05 1c 	mov	lr,1308
8000a2aa:	72 2b       	ld.w	r11,r9[0x8]
8000a2ac:	2f 8e       	sub	lr,-8
8000a2ae:	1c 3b       	cp.w	r11,lr
8000a2b0:	c0 71       	brne	8000a2be <_free_r+0xba>
8000a2b2:	97 36       	st.w	r11[0xc],r6
8000a2b4:	97 26       	st.w	r11[0x8],r6
8000a2b6:	8d 2b       	st.w	r6[0x8],r11
8000a2b8:	8d 3b       	st.w	r6[0xc],r11
8000a2ba:	30 1c       	mov	r12,1
8000a2bc:	c0 58       	rjmp	8000a2c6 <_free_r+0xc2>
8000a2be:	72 2b       	ld.w	r11,r9[0x8]
8000a2c0:	72 39       	ld.w	r9,r9[0xc]
8000a2c2:	93 2b       	st.w	r9[0x8],r11
8000a2c4:	97 39       	st.w	r11[0xc],r9
8000a2c6:	10 99       	mov	r9,r8
8000a2c8:	ec 08 09 08 	st.w	r6[r8],r8
8000a2cc:	a1 a9       	sbr	r9,0x0
8000a2ce:	8d 19       	st.w	r6[0x4],r9
8000a2d0:	58 0c       	cp.w	r12,0
8000a2d2:	c5 a1       	brne	8000a386 <_free_r+0x182>
8000a2d4:	e0 48 01 ff 	cp.w	r8,511
8000a2d8:	e0 8b 00 13 	brhi	8000a2fe <_free_r+0xfa>
8000a2dc:	a3 98       	lsr	r8,0x3
8000a2de:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a2e2:	72 2b       	ld.w	r11,r9[0x8]
8000a2e4:	8d 39       	st.w	r6[0xc],r9
8000a2e6:	8d 2b       	st.w	r6[0x8],r11
8000a2e8:	97 36       	st.w	r11[0xc],r6
8000a2ea:	93 26       	st.w	r9[0x8],r6
8000a2ec:	a3 48       	asr	r8,0x2
8000a2ee:	74 19       	ld.w	r9,r10[0x4]
8000a2f0:	30 1b       	mov	r11,1
8000a2f2:	f6 08 09 48 	lsl	r8,r11,r8
8000a2f6:	f3 e8 10 08 	or	r8,r9,r8
8000a2fa:	95 18       	st.w	r10[0x4],r8
8000a2fc:	c4 58       	rjmp	8000a386 <_free_r+0x182>
8000a2fe:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a302:	58 4b       	cp.w	r11,4
8000a304:	e0 8b 00 06 	brhi	8000a310 <_free_r+0x10c>
8000a308:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a30c:	2c 8b       	sub	r11,-56
8000a30e:	c2 08       	rjmp	8000a34e <_free_r+0x14a>
8000a310:	59 4b       	cp.w	r11,20
8000a312:	e0 8b 00 04 	brhi	8000a31a <_free_r+0x116>
8000a316:	2a 5b       	sub	r11,-91
8000a318:	c1 b8       	rjmp	8000a34e <_free_r+0x14a>
8000a31a:	e0 4b 00 54 	cp.w	r11,84
8000a31e:	e0 8b 00 06 	brhi	8000a32a <_free_r+0x126>
8000a322:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a326:	29 2b       	sub	r11,-110
8000a328:	c1 38       	rjmp	8000a34e <_free_r+0x14a>
8000a32a:	e0 4b 01 54 	cp.w	r11,340
8000a32e:	e0 8b 00 06 	brhi	8000a33a <_free_r+0x136>
8000a332:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a336:	28 9b       	sub	r11,-119
8000a338:	c0 b8       	rjmp	8000a34e <_free_r+0x14a>
8000a33a:	e0 4b 05 54 	cp.w	r11,1364
8000a33e:	e0 88 00 05 	brls	8000a348 <_free_r+0x144>
8000a342:	37 eb       	mov	r11,126
8000a344:	c0 58       	rjmp	8000a34e <_free_r+0x14a>
8000a346:	d7 03       	nop
8000a348:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a34c:	28 4b       	sub	r11,-124
8000a34e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a352:	78 29       	ld.w	r9,r12[0x8]
8000a354:	18 39       	cp.w	r9,r12
8000a356:	c0 e1       	brne	8000a372 <_free_r+0x16e>
8000a358:	74 18       	ld.w	r8,r10[0x4]
8000a35a:	a3 4b       	asr	r11,0x2
8000a35c:	30 1c       	mov	r12,1
8000a35e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a362:	f1 eb 10 0b 	or	r11,r8,r11
8000a366:	12 98       	mov	r8,r9
8000a368:	95 1b       	st.w	r10[0x4],r11
8000a36a:	c0 a8       	rjmp	8000a37e <_free_r+0x17a>
8000a36c:	72 29       	ld.w	r9,r9[0x8]
8000a36e:	18 39       	cp.w	r9,r12
8000a370:	c0 60       	breq	8000a37c <_free_r+0x178>
8000a372:	72 1a       	ld.w	r10,r9[0x4]
8000a374:	e0 1a ff fc 	andl	r10,0xfffc
8000a378:	14 38       	cp.w	r8,r10
8000a37a:	cf 93       	brcs	8000a36c <_free_r+0x168>
8000a37c:	72 38       	ld.w	r8,r9[0xc]
8000a37e:	8d 38       	st.w	r6[0xc],r8
8000a380:	8d 29       	st.w	r6[0x8],r9
8000a382:	93 36       	st.w	r9[0xc],r6
8000a384:	91 26       	st.w	r8[0x8],r6
8000a386:	0e 9c       	mov	r12,r7
8000a388:	fe b0 d7 9a 	rcall	800052bc <__malloc_unlock>
8000a38c:	d8 22       	popm	r4-r7,pc
8000a38e:	d7 03       	nop

8000a390 <__sfvwrite_r>:
8000a390:	d4 31       	pushm	r0-r7,lr
8000a392:	20 3d       	sub	sp,12
8000a394:	14 94       	mov	r4,r10
8000a396:	18 95       	mov	r5,r12
8000a398:	16 97       	mov	r7,r11
8000a39a:	74 28       	ld.w	r8,r10[0x8]
8000a39c:	58 08       	cp.w	r8,0
8000a39e:	e0 80 01 40 	breq	8000a61e <__sfvwrite_r+0x28e>
8000a3a2:	96 68       	ld.sh	r8,r11[0xc]
8000a3a4:	ed b8 00 03 	bld	r8,0x3
8000a3a8:	c0 41       	brne	8000a3b0 <__sfvwrite_r+0x20>
8000a3aa:	76 48       	ld.w	r8,r11[0x10]
8000a3ac:	58 08       	cp.w	r8,0
8000a3ae:	c0 c1       	brne	8000a3c6 <__sfvwrite_r+0x36>
8000a3b0:	0e 9b       	mov	r11,r7
8000a3b2:	0a 9c       	mov	r12,r5
8000a3b4:	fe b0 f6 c4 	rcall	8000913c <__swsetup_r>
8000a3b8:	c0 70       	breq	8000a3c6 <__sfvwrite_r+0x36>
8000a3ba:	8e 68       	ld.sh	r8,r7[0xc]
8000a3bc:	a7 a8       	sbr	r8,0x6
8000a3be:	ae 68       	st.h	r7[0xc],r8
8000a3c0:	30 98       	mov	r8,9
8000a3c2:	8b 38       	st.w	r5[0xc],r8
8000a3c4:	c2 b9       	rjmp	8000a61a <__sfvwrite_r+0x28a>
8000a3c6:	8e 63       	ld.sh	r3,r7[0xc]
8000a3c8:	68 00       	ld.w	r0,r4[0x0]
8000a3ca:	06 96       	mov	r6,r3
8000a3cc:	e2 16 00 02 	andl	r6,0x2,COH
8000a3d0:	c2 10       	breq	8000a412 <__sfvwrite_r+0x82>
8000a3d2:	30 03       	mov	r3,0
8000a3d4:	e0 62 04 00 	mov	r2,1024
8000a3d8:	06 96       	mov	r6,r3
8000a3da:	c0 48       	rjmp	8000a3e2 <__sfvwrite_r+0x52>
8000a3dc:	60 03       	ld.w	r3,r0[0x0]
8000a3de:	60 16       	ld.w	r6,r0[0x4]
8000a3e0:	2f 80       	sub	r0,-8
8000a3e2:	58 06       	cp.w	r6,0
8000a3e4:	cf c0       	breq	8000a3dc <__sfvwrite_r+0x4c>
8000a3e6:	e0 46 04 00 	cp.w	r6,1024
8000a3ea:	ec 09 17 80 	movls	r9,r6
8000a3ee:	e4 09 17 b0 	movhi	r9,r2
8000a3f2:	06 9a       	mov	r10,r3
8000a3f4:	6e a8       	ld.w	r8,r7[0x28]
8000a3f6:	6e 8b       	ld.w	r11,r7[0x20]
8000a3f8:	0a 9c       	mov	r12,r5
8000a3fa:	5d 18       	icall	r8
8000a3fc:	18 16       	sub	r6,r12
8000a3fe:	58 0c       	cp.w	r12,0
8000a400:	e0 8a 01 0a 	brle	8000a614 <__sfvwrite_r+0x284>
8000a404:	68 28       	ld.w	r8,r4[0x8]
8000a406:	18 18       	sub	r8,r12
8000a408:	89 28       	st.w	r4[0x8],r8
8000a40a:	e0 80 01 0a 	breq	8000a61e <__sfvwrite_r+0x28e>
8000a40e:	18 03       	add	r3,r12
8000a410:	ce 9b       	rjmp	8000a3e2 <__sfvwrite_r+0x52>
8000a412:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a416:	c0 70       	breq	8000a424 <__sfvwrite_r+0x94>
8000a418:	50 06       	stdsp	sp[0x0],r6
8000a41a:	0c 93       	mov	r3,r6
8000a41c:	0c 91       	mov	r1,r6
8000a41e:	50 15       	stdsp	sp[0x4],r5
8000a420:	08 92       	mov	r2,r4
8000a422:	c9 c8       	rjmp	8000a55a <__sfvwrite_r+0x1ca>
8000a424:	06 96       	mov	r6,r3
8000a426:	08 91       	mov	r1,r4
8000a428:	c0 48       	rjmp	8000a430 <__sfvwrite_r+0xa0>
8000a42a:	60 03       	ld.w	r3,r0[0x0]
8000a42c:	60 16       	ld.w	r6,r0[0x4]
8000a42e:	2f 80       	sub	r0,-8
8000a430:	58 06       	cp.w	r6,0
8000a432:	cf c0       	breq	8000a42a <__sfvwrite_r+0x9a>
8000a434:	8e 68       	ld.sh	r8,r7[0xc]
8000a436:	6e 24       	ld.w	r4,r7[0x8]
8000a438:	10 99       	mov	r9,r8
8000a43a:	e2 19 02 00 	andl	r9,0x200,COH
8000a43e:	c5 50       	breq	8000a4e8 <__sfvwrite_r+0x158>
8000a440:	08 36       	cp.w	r6,r4
8000a442:	c4 43       	brcs	8000a4ca <__sfvwrite_r+0x13a>
8000a444:	10 99       	mov	r9,r8
8000a446:	e2 19 04 80 	andl	r9,0x480,COH
8000a44a:	c4 00       	breq	8000a4ca <__sfvwrite_r+0x13a>
8000a44c:	6e 4b       	ld.w	r11,r7[0x10]
8000a44e:	6e 09       	ld.w	r9,r7[0x0]
8000a450:	16 19       	sub	r9,r11
8000a452:	50 09       	stdsp	sp[0x0],r9
8000a454:	6e 59       	ld.w	r9,r7[0x14]
8000a456:	10 9c       	mov	r12,r8
8000a458:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a45c:	30 28       	mov	r8,2
8000a45e:	f4 08 0c 08 	divs	r8,r10,r8
8000a462:	fa e9 00 04 	st.d	sp[4],r8
8000a466:	10 94       	mov	r4,r8
8000a468:	40 09       	lddsp	r9,sp[0x0]
8000a46a:	e2 1c 04 00 	andl	r12,0x400,COH
8000a46e:	2f f9       	sub	r9,-1
8000a470:	0c 09       	add	r9,r6
8000a472:	12 38       	cp.w	r8,r9
8000a474:	f2 04 17 30 	movlo	r4,r9
8000a478:	58 0c       	cp.w	r12,0
8000a47a:	c1 10       	breq	8000a49c <__sfvwrite_r+0x10c>
8000a47c:	08 9b       	mov	r11,r4
8000a47e:	0a 9c       	mov	r12,r5
8000a480:	fe b0 e0 5a 	rcall	80006534 <_malloc_r>
8000a484:	18 92       	mov	r2,r12
8000a486:	c1 40       	breq	8000a4ae <__sfvwrite_r+0x11e>
8000a488:	40 0a       	lddsp	r10,sp[0x0]
8000a48a:	6e 4b       	ld.w	r11,r7[0x10]
8000a48c:	fe b0 e2 83 	rcall	80006992 <memcpy>
8000a490:	8e 68       	ld.sh	r8,r7[0xc]
8000a492:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a496:	a7 b8       	sbr	r8,0x7
8000a498:	ae 68       	st.h	r7[0xc],r8
8000a49a:	c0 d8       	rjmp	8000a4b4 <__sfvwrite_r+0x124>
8000a49c:	08 9a       	mov	r10,r4
8000a49e:	0a 9c       	mov	r12,r5
8000a4a0:	fe b0 e3 24 	rcall	80006ae8 <_realloc_r>
8000a4a4:	18 92       	mov	r2,r12
8000a4a6:	c0 71       	brne	8000a4b4 <__sfvwrite_r+0x124>
8000a4a8:	6e 4b       	ld.w	r11,r7[0x10]
8000a4aa:	0a 9c       	mov	r12,r5
8000a4ac:	ca ce       	rcall	8000a204 <_free_r>
8000a4ae:	30 c8       	mov	r8,12
8000a4b0:	8b 38       	st.w	r5[0xc],r8
8000a4b2:	cb 18       	rjmp	8000a614 <__sfvwrite_r+0x284>
8000a4b4:	40 0a       	lddsp	r10,sp[0x0]
8000a4b6:	40 09       	lddsp	r9,sp[0x0]
8000a4b8:	e8 0a 01 0a 	sub	r10,r4,r10
8000a4bc:	e4 09 00 08 	add	r8,r2,r9
8000a4c0:	8f 54       	st.w	r7[0x14],r4
8000a4c2:	8f 2a       	st.w	r7[0x8],r10
8000a4c4:	8f 08       	st.w	r7[0x0],r8
8000a4c6:	8f 42       	st.w	r7[0x10],r2
8000a4c8:	0c 94       	mov	r4,r6
8000a4ca:	08 36       	cp.w	r6,r4
8000a4cc:	ec 04 17 30 	movlo	r4,r6
8000a4d0:	06 9b       	mov	r11,r3
8000a4d2:	08 9a       	mov	r10,r4
8000a4d4:	6e 0c       	ld.w	r12,r7[0x0]
8000a4d6:	c3 ad       	rcall	8000a74a <memmove>
8000a4d8:	6e 08       	ld.w	r8,r7[0x0]
8000a4da:	08 08       	add	r8,r4
8000a4dc:	8f 08       	st.w	r7[0x0],r8
8000a4de:	6e 28       	ld.w	r8,r7[0x8]
8000a4e0:	08 18       	sub	r8,r4
8000a4e2:	0c 94       	mov	r4,r6
8000a4e4:	8f 28       	st.w	r7[0x8],r8
8000a4e6:	c2 e8       	rjmp	8000a542 <__sfvwrite_r+0x1b2>
8000a4e8:	08 36       	cp.w	r6,r4
8000a4ea:	5f ba       	srhi	r10
8000a4ec:	6e 0c       	ld.w	r12,r7[0x0]
8000a4ee:	6e 48       	ld.w	r8,r7[0x10]
8000a4f0:	10 3c       	cp.w	r12,r8
8000a4f2:	5f b8       	srhi	r8
8000a4f4:	f5 e8 00 08 	and	r8,r10,r8
8000a4f8:	f2 08 18 00 	cp.b	r8,r9
8000a4fc:	c0 d0       	breq	8000a516 <__sfvwrite_r+0x186>
8000a4fe:	06 9b       	mov	r11,r3
8000a500:	08 9a       	mov	r10,r4
8000a502:	c2 4d       	rcall	8000a74a <memmove>
8000a504:	6e 08       	ld.w	r8,r7[0x0]
8000a506:	08 08       	add	r8,r4
8000a508:	0e 9b       	mov	r11,r7
8000a50a:	8f 08       	st.w	r7[0x0],r8
8000a50c:	0a 9c       	mov	r12,r5
8000a50e:	fe b0 fd 09 	rcall	80009f20 <_fflush_r>
8000a512:	c1 80       	breq	8000a542 <__sfvwrite_r+0x1b2>
8000a514:	c8 08       	rjmp	8000a614 <__sfvwrite_r+0x284>
8000a516:	6e 59       	ld.w	r9,r7[0x14]
8000a518:	12 36       	cp.w	r6,r9
8000a51a:	c0 a3       	brcs	8000a52e <__sfvwrite_r+0x19e>
8000a51c:	6e a8       	ld.w	r8,r7[0x28]
8000a51e:	06 9a       	mov	r10,r3
8000a520:	6e 8b       	ld.w	r11,r7[0x20]
8000a522:	0a 9c       	mov	r12,r5
8000a524:	5d 18       	icall	r8
8000a526:	18 94       	mov	r4,r12
8000a528:	e0 89 00 0d 	brgt	8000a542 <__sfvwrite_r+0x1b2>
8000a52c:	c7 48       	rjmp	8000a614 <__sfvwrite_r+0x284>
8000a52e:	0c 9a       	mov	r10,r6
8000a530:	06 9b       	mov	r11,r3
8000a532:	c0 cd       	rcall	8000a74a <memmove>
8000a534:	6e 08       	ld.w	r8,r7[0x0]
8000a536:	0c 08       	add	r8,r6
8000a538:	0c 94       	mov	r4,r6
8000a53a:	8f 08       	st.w	r7[0x0],r8
8000a53c:	6e 28       	ld.w	r8,r7[0x8]
8000a53e:	0c 18       	sub	r8,r6
8000a540:	8f 28       	st.w	r7[0x8],r8
8000a542:	62 28       	ld.w	r8,r1[0x8]
8000a544:	08 18       	sub	r8,r4
8000a546:	83 28       	st.w	r1[0x8],r8
8000a548:	c6 b0       	breq	8000a61e <__sfvwrite_r+0x28e>
8000a54a:	08 16       	sub	r6,r4
8000a54c:	08 03       	add	r3,r4
8000a54e:	c7 1b       	rjmp	8000a430 <__sfvwrite_r+0xa0>
8000a550:	60 03       	ld.w	r3,r0[0x0]
8000a552:	60 11       	ld.w	r1,r0[0x4]
8000a554:	30 08       	mov	r8,0
8000a556:	2f 80       	sub	r0,-8
8000a558:	50 08       	stdsp	sp[0x0],r8
8000a55a:	58 01       	cp.w	r1,0
8000a55c:	cf a0       	breq	8000a550 <__sfvwrite_r+0x1c0>
8000a55e:	40 0a       	lddsp	r10,sp[0x0]
8000a560:	58 0a       	cp.w	r10,0
8000a562:	c1 41       	brne	8000a58a <__sfvwrite_r+0x1fa>
8000a564:	e2 c6 ff ff 	sub	r6,r1,-1
8000a568:	02 9a       	mov	r10,r1
8000a56a:	30 ab       	mov	r11,10
8000a56c:	06 9c       	mov	r12,r3
8000a56e:	ce 3c       	rcall	8000a734 <memchr>
8000a570:	f8 c8 ff ff 	sub	r8,r12,-1
8000a574:	58 0c       	cp.w	r12,0
8000a576:	f1 d3 e1 16 	subne	r6,r8,r3
8000a57a:	f9 b9 01 01 	movne	r9,1
8000a57e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a582:	f9 b8 00 01 	moveq	r8,1
8000a586:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a58a:	02 36       	cp.w	r6,r1
8000a58c:	ec 04 17 80 	movls	r4,r6
8000a590:	e2 04 17 b0 	movhi	r4,r1
8000a594:	6e 59       	ld.w	r9,r7[0x14]
8000a596:	6e 25       	ld.w	r5,r7[0x8]
8000a598:	f2 05 00 05 	add	r5,r9,r5
8000a59c:	0a 34       	cp.w	r4,r5
8000a59e:	5f 9a       	srgt	r10
8000a5a0:	6e 0c       	ld.w	r12,r7[0x0]
8000a5a2:	6e 48       	ld.w	r8,r7[0x10]
8000a5a4:	10 3c       	cp.w	r12,r8
8000a5a6:	5f b8       	srhi	r8
8000a5a8:	f5 e8 00 08 	and	r8,r10,r8
8000a5ac:	30 0a       	mov	r10,0
8000a5ae:	f4 08 18 00 	cp.b	r8,r10
8000a5b2:	c0 d0       	breq	8000a5cc <__sfvwrite_r+0x23c>
8000a5b4:	06 9b       	mov	r11,r3
8000a5b6:	0a 9a       	mov	r10,r5
8000a5b8:	cc 9c       	rcall	8000a74a <memmove>
8000a5ba:	6e 08       	ld.w	r8,r7[0x0]
8000a5bc:	0a 08       	add	r8,r5
8000a5be:	0e 9b       	mov	r11,r7
8000a5c0:	8f 08       	st.w	r7[0x0],r8
8000a5c2:	40 1c       	lddsp	r12,sp[0x4]
8000a5c4:	fe b0 fc ae 	rcall	80009f20 <_fflush_r>
8000a5c8:	c1 70       	breq	8000a5f6 <__sfvwrite_r+0x266>
8000a5ca:	c2 58       	rjmp	8000a614 <__sfvwrite_r+0x284>
8000a5cc:	12 34       	cp.w	r4,r9
8000a5ce:	c0 a5       	brlt	8000a5e2 <__sfvwrite_r+0x252>
8000a5d0:	6e a8       	ld.w	r8,r7[0x28]
8000a5d2:	06 9a       	mov	r10,r3
8000a5d4:	6e 8b       	ld.w	r11,r7[0x20]
8000a5d6:	40 1c       	lddsp	r12,sp[0x4]
8000a5d8:	5d 18       	icall	r8
8000a5da:	18 95       	mov	r5,r12
8000a5dc:	e0 89 00 0d 	brgt	8000a5f6 <__sfvwrite_r+0x266>
8000a5e0:	c1 a8       	rjmp	8000a614 <__sfvwrite_r+0x284>
8000a5e2:	08 9a       	mov	r10,r4
8000a5e4:	06 9b       	mov	r11,r3
8000a5e6:	cb 2c       	rcall	8000a74a <memmove>
8000a5e8:	6e 08       	ld.w	r8,r7[0x0]
8000a5ea:	08 08       	add	r8,r4
8000a5ec:	08 95       	mov	r5,r4
8000a5ee:	8f 08       	st.w	r7[0x0],r8
8000a5f0:	6e 28       	ld.w	r8,r7[0x8]
8000a5f2:	08 18       	sub	r8,r4
8000a5f4:	8f 28       	st.w	r7[0x8],r8
8000a5f6:	0a 16       	sub	r6,r5
8000a5f8:	c0 71       	brne	8000a606 <__sfvwrite_r+0x276>
8000a5fa:	0e 9b       	mov	r11,r7
8000a5fc:	40 1c       	lddsp	r12,sp[0x4]
8000a5fe:	fe b0 fc 91 	rcall	80009f20 <_fflush_r>
8000a602:	c0 91       	brne	8000a614 <__sfvwrite_r+0x284>
8000a604:	50 06       	stdsp	sp[0x0],r6
8000a606:	64 28       	ld.w	r8,r2[0x8]
8000a608:	0a 18       	sub	r8,r5
8000a60a:	85 28       	st.w	r2[0x8],r8
8000a60c:	c0 90       	breq	8000a61e <__sfvwrite_r+0x28e>
8000a60e:	0a 11       	sub	r1,r5
8000a610:	0a 03       	add	r3,r5
8000a612:	ca 4b       	rjmp	8000a55a <__sfvwrite_r+0x1ca>
8000a614:	8e 68       	ld.sh	r8,r7[0xc]
8000a616:	a7 a8       	sbr	r8,0x6
8000a618:	ae 68       	st.h	r7[0xc],r8
8000a61a:	3f fc       	mov	r12,-1
8000a61c:	c0 28       	rjmp	8000a620 <__sfvwrite_r+0x290>
8000a61e:	30 0c       	mov	r12,0
8000a620:	2f dd       	sub	sp,-12
8000a622:	d8 32       	popm	r0-r7,pc

8000a624 <_fwalk>:
8000a624:	d4 31       	pushm	r0-r7,lr
8000a626:	30 05       	mov	r5,0
8000a628:	16 91       	mov	r1,r11
8000a62a:	f8 c7 ff 28 	sub	r7,r12,-216
8000a62e:	0a 92       	mov	r2,r5
8000a630:	fe b0 fc fe 	rcall	8000a02c <__sfp_lock_acquire>
8000a634:	3f f3       	mov	r3,-1
8000a636:	c1 68       	rjmp	8000a662 <_fwalk+0x3e>
8000a638:	6e 26       	ld.w	r6,r7[0x8]
8000a63a:	6e 14       	ld.w	r4,r7[0x4]
8000a63c:	2f 46       	sub	r6,-12
8000a63e:	c0 c8       	rjmp	8000a656 <_fwalk+0x32>
8000a640:	8c 08       	ld.sh	r8,r6[0x0]
8000a642:	e4 08 19 00 	cp.h	r8,r2
8000a646:	c0 70       	breq	8000a654 <_fwalk+0x30>
8000a648:	8c 18       	ld.sh	r8,r6[0x2]
8000a64a:	e6 08 19 00 	cp.h	r8,r3
8000a64e:	c0 30       	breq	8000a654 <_fwalk+0x30>
8000a650:	5d 11       	icall	r1
8000a652:	18 45       	or	r5,r12
8000a654:	2a 46       	sub	r6,-92
8000a656:	20 14       	sub	r4,1
8000a658:	ec cc 00 0c 	sub	r12,r6,12
8000a65c:	58 04       	cp.w	r4,0
8000a65e:	cf 14       	brge	8000a640 <_fwalk+0x1c>
8000a660:	6e 07       	ld.w	r7,r7[0x0]
8000a662:	58 07       	cp.w	r7,0
8000a664:	ce a1       	brne	8000a638 <_fwalk+0x14>
8000a666:	fe b0 fc e4 	rcall	8000a02e <__sfp_lock_release>
8000a66a:	0a 9c       	mov	r12,r5
8000a66c:	d8 32       	popm	r0-r7,pc
8000a66e:	d7 03       	nop

8000a670 <_localeconv_r>:
8000a670:	fe cc d2 34 	sub	r12,pc,-11724
8000a674:	5e fc       	retal	r12
8000a676:	d7 03       	nop

8000a678 <__smakebuf_r>:
8000a678:	d4 21       	pushm	r4-r7,lr
8000a67a:	20 fd       	sub	sp,60
8000a67c:	96 68       	ld.sh	r8,r11[0xc]
8000a67e:	16 97       	mov	r7,r11
8000a680:	18 96       	mov	r6,r12
8000a682:	e2 18 00 02 	andl	r8,0x2,COH
8000a686:	c3 d1       	brne	8000a700 <__smakebuf_r+0x88>
8000a688:	96 7b       	ld.sh	r11,r11[0xe]
8000a68a:	f0 0b 19 00 	cp.h	r11,r8
8000a68e:	c0 55       	brlt	8000a698 <__smakebuf_r+0x20>
8000a690:	1a 9a       	mov	r10,sp
8000a692:	e0 a0 04 81 	rcall	8000af94 <_fstat_r>
8000a696:	c0 f4       	brge	8000a6b4 <__smakebuf_r+0x3c>
8000a698:	8e 65       	ld.sh	r5,r7[0xc]
8000a69a:	0a 98       	mov	r8,r5
8000a69c:	ab b8       	sbr	r8,0xb
8000a69e:	e2 15 00 80 	andl	r5,0x80,COH
8000a6a2:	ae 68       	st.h	r7[0xc],r8
8000a6a4:	30 04       	mov	r4,0
8000a6a6:	e0 68 04 00 	mov	r8,1024
8000a6aa:	f9 b5 01 40 	movne	r5,64
8000a6ae:	f0 05 17 00 	moveq	r5,r8
8000a6b2:	c1 c8       	rjmp	8000a6ea <__smakebuf_r+0x72>
8000a6b4:	40 18       	lddsp	r8,sp[0x4]
8000a6b6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a6ba:	e0 48 20 00 	cp.w	r8,8192
8000a6be:	5f 04       	sreq	r4
8000a6c0:	e0 48 80 00 	cp.w	r8,32768
8000a6c4:	c0 e1       	brne	8000a6e0 <__smakebuf_r+0x68>
8000a6c6:	6e b9       	ld.w	r9,r7[0x2c]
8000a6c8:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a6cc:	10 39       	cp.w	r9,r8
8000a6ce:	c0 91       	brne	8000a6e0 <__smakebuf_r+0x68>
8000a6d0:	8e 68       	ld.sh	r8,r7[0xc]
8000a6d2:	e0 65 04 00 	mov	r5,1024
8000a6d6:	ab a8       	sbr	r8,0xa
8000a6d8:	ef 45 00 50 	st.w	r7[80],r5
8000a6dc:	ae 68       	st.h	r7[0xc],r8
8000a6de:	c0 68       	rjmp	8000a6ea <__smakebuf_r+0x72>
8000a6e0:	8e 68       	ld.sh	r8,r7[0xc]
8000a6e2:	e0 65 04 00 	mov	r5,1024
8000a6e6:	ab b8       	sbr	r8,0xb
8000a6e8:	ae 68       	st.h	r7[0xc],r8
8000a6ea:	0a 9b       	mov	r11,r5
8000a6ec:	0c 9c       	mov	r12,r6
8000a6ee:	fe b0 df 23 	rcall	80006534 <_malloc_r>
8000a6f2:	8e 68       	ld.sh	r8,r7[0xc]
8000a6f4:	c0 d1       	brne	8000a70e <__smakebuf_r+0x96>
8000a6f6:	ed b8 00 09 	bld	r8,0x9
8000a6fa:	c1 b0       	breq	8000a730 <__smakebuf_r+0xb8>
8000a6fc:	a1 b8       	sbr	r8,0x1
8000a6fe:	ae 68       	st.h	r7[0xc],r8
8000a700:	ee c8 ff b9 	sub	r8,r7,-71
8000a704:	8f 48       	st.w	r7[0x10],r8
8000a706:	8f 08       	st.w	r7[0x0],r8
8000a708:	30 18       	mov	r8,1
8000a70a:	8f 58       	st.w	r7[0x14],r8
8000a70c:	c1 28       	rjmp	8000a730 <__smakebuf_r+0xb8>
8000a70e:	a7 b8       	sbr	r8,0x7
8000a710:	8f 4c       	st.w	r7[0x10],r12
8000a712:	ae 68       	st.h	r7[0xc],r8
8000a714:	8f 55       	st.w	r7[0x14],r5
8000a716:	fe c8 06 e6 	sub	r8,pc,1766
8000a71a:	8f 0c       	st.w	r7[0x0],r12
8000a71c:	8d a8       	st.w	r6[0x28],r8
8000a71e:	58 04       	cp.w	r4,0
8000a720:	c0 80       	breq	8000a730 <__smakebuf_r+0xb8>
8000a722:	8e 7c       	ld.sh	r12,r7[0xe]
8000a724:	fe b0 e3 94 	rcall	80006e4c <isatty>
8000a728:	c0 40       	breq	8000a730 <__smakebuf_r+0xb8>
8000a72a:	8e 68       	ld.sh	r8,r7[0xc]
8000a72c:	a1 a8       	sbr	r8,0x0
8000a72e:	ae 68       	st.h	r7[0xc],r8
8000a730:	2f 1d       	sub	sp,-60
8000a732:	d8 22       	popm	r4-r7,pc

8000a734 <memchr>:
8000a734:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a738:	c0 68       	rjmp	8000a744 <memchr+0x10>
8000a73a:	20 1a       	sub	r10,1
8000a73c:	19 88       	ld.ub	r8,r12[0x0]
8000a73e:	16 38       	cp.w	r8,r11
8000a740:	5e 0c       	reteq	r12
8000a742:	2f fc       	sub	r12,-1
8000a744:	58 0a       	cp.w	r10,0
8000a746:	cf a1       	brne	8000a73a <memchr+0x6>
8000a748:	5e fa       	retal	r10

8000a74a <memmove>:
8000a74a:	d4 01       	pushm	lr
8000a74c:	18 3b       	cp.w	r11,r12
8000a74e:	c1 92       	brcc	8000a780 <memmove+0x36>
8000a750:	f6 0a 00 09 	add	r9,r11,r10
8000a754:	12 3c       	cp.w	r12,r9
8000a756:	c1 52       	brcc	8000a780 <memmove+0x36>
8000a758:	f8 0a 00 0b 	add	r11,r12,r10
8000a75c:	30 08       	mov	r8,0
8000a75e:	c0 68       	rjmp	8000a76a <memmove+0x20>
8000a760:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a764:	20 1a       	sub	r10,1
8000a766:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a76a:	20 18       	sub	r8,1
8000a76c:	58 0a       	cp.w	r10,0
8000a76e:	cf 91       	brne	8000a760 <memmove+0x16>
8000a770:	d8 02       	popm	pc
8000a772:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a776:	20 1a       	sub	r10,1
8000a778:	f8 08 0b 09 	st.b	r12[r8],r9
8000a77c:	2f f8       	sub	r8,-1
8000a77e:	c0 28       	rjmp	8000a782 <memmove+0x38>
8000a780:	30 08       	mov	r8,0
8000a782:	58 0a       	cp.w	r10,0
8000a784:	cf 71       	brne	8000a772 <memmove+0x28>
8000a786:	d8 02       	popm	pc

8000a788 <__hi0bits>:
8000a788:	18 98       	mov	r8,r12
8000a78a:	e0 1c 00 00 	andl	r12,0x0
8000a78e:	f0 09 15 10 	lsl	r9,r8,0x10
8000a792:	58 0c       	cp.w	r12,0
8000a794:	f2 08 17 00 	moveq	r8,r9
8000a798:	f9 bc 00 10 	moveq	r12,16
8000a79c:	f9 bc 01 00 	movne	r12,0
8000a7a0:	10 9a       	mov	r10,r8
8000a7a2:	f0 09 15 08 	lsl	r9,r8,0x8
8000a7a6:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a7aa:	f7 bc 00 f8 	subeq	r12,-8
8000a7ae:	f2 08 17 00 	moveq	r8,r9
8000a7b2:	10 9a       	mov	r10,r8
8000a7b4:	f0 09 15 04 	lsl	r9,r8,0x4
8000a7b8:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a7bc:	f7 bc 00 fc 	subeq	r12,-4
8000a7c0:	f2 08 17 00 	moveq	r8,r9
8000a7c4:	10 9a       	mov	r10,r8
8000a7c6:	f0 09 15 02 	lsl	r9,r8,0x2
8000a7ca:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a7ce:	f7 bc 00 fe 	subeq	r12,-2
8000a7d2:	f2 08 17 00 	moveq	r8,r9
8000a7d6:	58 08       	cp.w	r8,0
8000a7d8:	5e 5c       	retlt	r12
8000a7da:	ed b8 00 1e 	bld	r8,0x1e
8000a7de:	f9 bc 01 20 	movne	r12,32
8000a7e2:	f7 bc 00 ff 	subeq	r12,-1
8000a7e6:	5e fc       	retal	r12

8000a7e8 <__lo0bits>:
8000a7e8:	18 99       	mov	r9,r12
8000a7ea:	78 08       	ld.w	r8,r12[0x0]
8000a7ec:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a7f0:	c1 50       	breq	8000a81a <__lo0bits+0x32>
8000a7f2:	ed b8 00 00 	bld	r8,0x0
8000a7f6:	c0 21       	brne	8000a7fa <__lo0bits+0x12>
8000a7f8:	5e fd       	retal	0
8000a7fa:	10 9b       	mov	r11,r8
8000a7fc:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a800:	e2 1b 00 02 	andl	r11,0x2,COH
8000a804:	a3 88       	lsr	r8,0x2
8000a806:	58 0b       	cp.w	r11,0
8000a808:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a80c:	f9 bc 01 01 	movne	r12,1
8000a810:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a814:	f9 bc 00 02 	moveq	r12,2
8000a818:	5e fc       	retal	r12
8000a81a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a81e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a822:	58 0a       	cp.w	r10,0
8000a824:	f6 08 17 00 	moveq	r8,r11
8000a828:	f9 bc 00 10 	moveq	r12,16
8000a82c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a830:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a834:	58 0b       	cp.w	r11,0
8000a836:	f7 bc 00 f8 	subeq	r12,-8
8000a83a:	f4 08 17 00 	moveq	r8,r10
8000a83e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a842:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a846:	58 0b       	cp.w	r11,0
8000a848:	f7 bc 00 fc 	subeq	r12,-4
8000a84c:	f4 08 17 00 	moveq	r8,r10
8000a850:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a854:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a858:	58 0b       	cp.w	r11,0
8000a85a:	f7 bc 00 fe 	subeq	r12,-2
8000a85e:	f4 08 17 00 	moveq	r8,r10
8000a862:	ed b8 00 00 	bld	r8,0x0
8000a866:	c0 60       	breq	8000a872 <__lo0bits+0x8a>
8000a868:	a1 98       	lsr	r8,0x1
8000a86a:	c0 31       	brne	8000a870 <__lo0bits+0x88>
8000a86c:	32 0c       	mov	r12,32
8000a86e:	5e fc       	retal	r12
8000a870:	2f fc       	sub	r12,-1
8000a872:	93 08       	st.w	r9[0x0],r8
8000a874:	5e fc       	retal	r12

8000a876 <__mcmp>:
8000a876:	d4 01       	pushm	lr
8000a878:	18 98       	mov	r8,r12
8000a87a:	76 49       	ld.w	r9,r11[0x10]
8000a87c:	78 4c       	ld.w	r12,r12[0x10]
8000a87e:	12 1c       	sub	r12,r9
8000a880:	c1 31       	brne	8000a8a6 <__mcmp+0x30>
8000a882:	2f b9       	sub	r9,-5
8000a884:	a3 69       	lsl	r9,0x2
8000a886:	12 0b       	add	r11,r9
8000a888:	f0 09 00 09 	add	r9,r8,r9
8000a88c:	2e c8       	sub	r8,-20
8000a88e:	13 4e       	ld.w	lr,--r9
8000a890:	17 4a       	ld.w	r10,--r11
8000a892:	14 3e       	cp.w	lr,r10
8000a894:	c0 60       	breq	8000a8a0 <__mcmp+0x2a>
8000a896:	f9 bc 03 ff 	movlo	r12,-1
8000a89a:	f9 bc 02 01 	movhs	r12,1
8000a89e:	d8 02       	popm	pc
8000a8a0:	10 39       	cp.w	r9,r8
8000a8a2:	fe 9b ff f6 	brhi	8000a88e <__mcmp+0x18>
8000a8a6:	d8 02       	popm	pc

8000a8a8 <_Bfree>:
8000a8a8:	d4 21       	pushm	r4-r7,lr
8000a8aa:	18 97       	mov	r7,r12
8000a8ac:	16 95       	mov	r5,r11
8000a8ae:	78 96       	ld.w	r6,r12[0x24]
8000a8b0:	58 06       	cp.w	r6,0
8000a8b2:	c0 91       	brne	8000a8c4 <_Bfree+0x1c>
8000a8b4:	31 0c       	mov	r12,16
8000a8b6:	fe b0 de 37 	rcall	80006524 <malloc>
8000a8ba:	99 36       	st.w	r12[0xc],r6
8000a8bc:	8f 9c       	st.w	r7[0x24],r12
8000a8be:	99 16       	st.w	r12[0x4],r6
8000a8c0:	99 26       	st.w	r12[0x8],r6
8000a8c2:	99 06       	st.w	r12[0x0],r6
8000a8c4:	58 05       	cp.w	r5,0
8000a8c6:	c0 90       	breq	8000a8d8 <_Bfree+0x30>
8000a8c8:	6a 19       	ld.w	r9,r5[0x4]
8000a8ca:	6e 98       	ld.w	r8,r7[0x24]
8000a8cc:	70 38       	ld.w	r8,r8[0xc]
8000a8ce:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a8d2:	8b 0a       	st.w	r5[0x0],r10
8000a8d4:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a8d8:	d8 22       	popm	r4-r7,pc
8000a8da:	d7 03       	nop

8000a8dc <_Balloc>:
8000a8dc:	d4 21       	pushm	r4-r7,lr
8000a8de:	18 97       	mov	r7,r12
8000a8e0:	16 96       	mov	r6,r11
8000a8e2:	78 95       	ld.w	r5,r12[0x24]
8000a8e4:	58 05       	cp.w	r5,0
8000a8e6:	c0 91       	brne	8000a8f8 <_Balloc+0x1c>
8000a8e8:	31 0c       	mov	r12,16
8000a8ea:	fe b0 de 1d 	rcall	80006524 <malloc>
8000a8ee:	99 35       	st.w	r12[0xc],r5
8000a8f0:	8f 9c       	st.w	r7[0x24],r12
8000a8f2:	99 15       	st.w	r12[0x4],r5
8000a8f4:	99 25       	st.w	r12[0x8],r5
8000a8f6:	99 05       	st.w	r12[0x0],r5
8000a8f8:	6e 95       	ld.w	r5,r7[0x24]
8000a8fa:	6a 38       	ld.w	r8,r5[0xc]
8000a8fc:	58 08       	cp.w	r8,0
8000a8fe:	c0 b1       	brne	8000a914 <_Balloc+0x38>
8000a900:	31 0a       	mov	r10,16
8000a902:	30 4b       	mov	r11,4
8000a904:	0e 9c       	mov	r12,r7
8000a906:	e0 a0 02 a7 	rcall	8000ae54 <_calloc_r>
8000a90a:	8b 3c       	st.w	r5[0xc],r12
8000a90c:	6e 98       	ld.w	r8,r7[0x24]
8000a90e:	70 3c       	ld.w	r12,r8[0xc]
8000a910:	58 0c       	cp.w	r12,0
8000a912:	c1 b0       	breq	8000a948 <_Balloc+0x6c>
8000a914:	6e 98       	ld.w	r8,r7[0x24]
8000a916:	70 38       	ld.w	r8,r8[0xc]
8000a918:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a91c:	70 0c       	ld.w	r12,r8[0x0]
8000a91e:	58 0c       	cp.w	r12,0
8000a920:	c0 40       	breq	8000a928 <_Balloc+0x4c>
8000a922:	78 09       	ld.w	r9,r12[0x0]
8000a924:	91 09       	st.w	r8[0x0],r9
8000a926:	c0 e8       	rjmp	8000a942 <_Balloc+0x66>
8000a928:	0e 9c       	mov	r12,r7
8000a92a:	30 17       	mov	r7,1
8000a92c:	0e 9b       	mov	r11,r7
8000a92e:	ee 06 09 47 	lsl	r7,r7,r6
8000a932:	ee ca ff fb 	sub	r10,r7,-5
8000a936:	a3 6a       	lsl	r10,0x2
8000a938:	e0 a0 02 8e 	rcall	8000ae54 <_calloc_r>
8000a93c:	c0 60       	breq	8000a948 <_Balloc+0x6c>
8000a93e:	99 16       	st.w	r12[0x4],r6
8000a940:	99 27       	st.w	r12[0x8],r7
8000a942:	30 08       	mov	r8,0
8000a944:	99 38       	st.w	r12[0xc],r8
8000a946:	99 48       	st.w	r12[0x10],r8
8000a948:	d8 22       	popm	r4-r7,pc
8000a94a:	d7 03       	nop

8000a94c <__d2b>:
8000a94c:	d4 31       	pushm	r0-r7,lr
8000a94e:	20 2d       	sub	sp,8
8000a950:	16 93       	mov	r3,r11
8000a952:	12 96       	mov	r6,r9
8000a954:	10 95       	mov	r5,r8
8000a956:	14 92       	mov	r2,r10
8000a958:	30 1b       	mov	r11,1
8000a95a:	cc 1f       	rcall	8000a8dc <_Balloc>
8000a95c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a960:	50 09       	stdsp	sp[0x0],r9
8000a962:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a966:	b5 a9       	sbr	r9,0x14
8000a968:	f0 01 16 14 	lsr	r1,r8,0x14
8000a96c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a970:	18 94       	mov	r4,r12
8000a972:	58 02       	cp.w	r2,0
8000a974:	c1 d0       	breq	8000a9ae <__d2b+0x62>
8000a976:	fa cc ff f8 	sub	r12,sp,-8
8000a97a:	18 d2       	st.w	--r12,r2
8000a97c:	c3 6f       	rcall	8000a7e8 <__lo0bits>
8000a97e:	40 18       	lddsp	r8,sp[0x4]
8000a980:	c0 d0       	breq	8000a99a <__d2b+0x4e>
8000a982:	40 09       	lddsp	r9,sp[0x0]
8000a984:	f8 0a 11 20 	rsub	r10,r12,32
8000a988:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a98c:	f5 e8 10 08 	or	r8,r10,r8
8000a990:	89 58       	st.w	r4[0x14],r8
8000a992:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a996:	50 09       	stdsp	sp[0x0],r9
8000a998:	c0 28       	rjmp	8000a99c <__d2b+0x50>
8000a99a:	89 58       	st.w	r4[0x14],r8
8000a99c:	40 08       	lddsp	r8,sp[0x0]
8000a99e:	58 08       	cp.w	r8,0
8000a9a0:	f9 b3 01 02 	movne	r3,2
8000a9a4:	f9 b3 00 01 	moveq	r3,1
8000a9a8:	89 68       	st.w	r4[0x18],r8
8000a9aa:	89 43       	st.w	r4[0x10],r3
8000a9ac:	c0 88       	rjmp	8000a9bc <__d2b+0x70>
8000a9ae:	1a 9c       	mov	r12,sp
8000a9b0:	c1 cf       	rcall	8000a7e8 <__lo0bits>
8000a9b2:	30 13       	mov	r3,1
8000a9b4:	40 08       	lddsp	r8,sp[0x0]
8000a9b6:	2e 0c       	sub	r12,-32
8000a9b8:	89 43       	st.w	r4[0x10],r3
8000a9ba:	89 58       	st.w	r4[0x14],r8
8000a9bc:	58 01       	cp.w	r1,0
8000a9be:	c0 90       	breq	8000a9d0 <__d2b+0x84>
8000a9c0:	e2 c1 04 33 	sub	r1,r1,1075
8000a9c4:	18 01       	add	r1,r12
8000a9c6:	8d 01       	st.w	r6[0x0],r1
8000a9c8:	f8 0c 11 35 	rsub	r12,r12,53
8000a9cc:	8b 0c       	st.w	r5[0x0],r12
8000a9ce:	c0 c8       	rjmp	8000a9e6 <__d2b+0x9a>
8000a9d0:	e6 c8 ff fc 	sub	r8,r3,-4
8000a9d4:	f8 cc 04 32 	sub	r12,r12,1074
8000a9d8:	a5 73       	lsl	r3,0x5
8000a9da:	8d 0c       	st.w	r6[0x0],r12
8000a9dc:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a9e0:	cd 4e       	rcall	8000a788 <__hi0bits>
8000a9e2:	18 13       	sub	r3,r12
8000a9e4:	8b 03       	st.w	r5[0x0],r3
8000a9e6:	08 9c       	mov	r12,r4
8000a9e8:	2f ed       	sub	sp,-8
8000a9ea:	d8 32       	popm	r0-r7,pc

8000a9ec <__mdiff>:
8000a9ec:	d4 31       	pushm	r0-r7,lr
8000a9ee:	74 48       	ld.w	r8,r10[0x10]
8000a9f0:	76 45       	ld.w	r5,r11[0x10]
8000a9f2:	16 97       	mov	r7,r11
8000a9f4:	14 96       	mov	r6,r10
8000a9f6:	10 15       	sub	r5,r8
8000a9f8:	c1 31       	brne	8000aa1e <__mdiff+0x32>
8000a9fa:	2f b8       	sub	r8,-5
8000a9fc:	ee ce ff ec 	sub	lr,r7,-20
8000aa00:	a3 68       	lsl	r8,0x2
8000aa02:	f4 08 00 0b 	add	r11,r10,r8
8000aa06:	ee 08 00 08 	add	r8,r7,r8
8000aa0a:	11 4a       	ld.w	r10,--r8
8000aa0c:	17 49       	ld.w	r9,--r11
8000aa0e:	12 3a       	cp.w	r10,r9
8000aa10:	c0 30       	breq	8000aa16 <__mdiff+0x2a>
8000aa12:	c0 e2       	brcc	8000aa2e <__mdiff+0x42>
8000aa14:	c0 78       	rjmp	8000aa22 <__mdiff+0x36>
8000aa16:	1c 38       	cp.w	r8,lr
8000aa18:	fe 9b ff f9 	brhi	8000aa0a <__mdiff+0x1e>
8000aa1c:	c4 98       	rjmp	8000aaae <__mdiff+0xc2>
8000aa1e:	58 05       	cp.w	r5,0
8000aa20:	c0 64       	brge	8000aa2c <__mdiff+0x40>
8000aa22:	0e 98       	mov	r8,r7
8000aa24:	30 15       	mov	r5,1
8000aa26:	0c 97       	mov	r7,r6
8000aa28:	10 96       	mov	r6,r8
8000aa2a:	c0 28       	rjmp	8000aa2e <__mdiff+0x42>
8000aa2c:	30 05       	mov	r5,0
8000aa2e:	6e 1b       	ld.w	r11,r7[0x4]
8000aa30:	c5 6f       	rcall	8000a8dc <_Balloc>
8000aa32:	6e 49       	ld.w	r9,r7[0x10]
8000aa34:	6c 44       	ld.w	r4,r6[0x10]
8000aa36:	99 35       	st.w	r12[0xc],r5
8000aa38:	2f b4       	sub	r4,-5
8000aa3a:	f2 c5 ff fb 	sub	r5,r9,-5
8000aa3e:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000aa42:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000aa46:	2e c6       	sub	r6,-20
8000aa48:	2e c7       	sub	r7,-20
8000aa4a:	f8 c8 ff ec 	sub	r8,r12,-20
8000aa4e:	30 0a       	mov	r10,0
8000aa50:	0f 0e       	ld.w	lr,r7++
8000aa52:	0d 0b       	ld.w	r11,r6++
8000aa54:	fc 02 16 10 	lsr	r2,lr,0x10
8000aa58:	f6 03 16 10 	lsr	r3,r11,0x10
8000aa5c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000aa60:	e4 03 01 03 	sub	r3,r2,r3
8000aa64:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa68:	fc 0b 01 0b 	sub	r11,lr,r11
8000aa6c:	f6 0a 00 0a 	add	r10,r11,r10
8000aa70:	b0 1a       	st.h	r8[0x2],r10
8000aa72:	b1 4a       	asr	r10,0x10
8000aa74:	e6 0a 00 0a 	add	r10,r3,r10
8000aa78:	b0 0a       	st.h	r8[0x0],r10
8000aa7a:	2f c8       	sub	r8,-4
8000aa7c:	b1 4a       	asr	r10,0x10
8000aa7e:	08 36       	cp.w	r6,r4
8000aa80:	ce 83       	brcs	8000aa50 <__mdiff+0x64>
8000aa82:	c0 d8       	rjmp	8000aa9c <__mdiff+0xb0>
8000aa84:	0f 0b       	ld.w	r11,r7++
8000aa86:	f6 0e 16 10 	lsr	lr,r11,0x10
8000aa8a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa8e:	16 0a       	add	r10,r11
8000aa90:	b0 1a       	st.h	r8[0x2],r10
8000aa92:	b1 4a       	asr	r10,0x10
8000aa94:	1c 0a       	add	r10,lr
8000aa96:	b0 0a       	st.h	r8[0x0],r10
8000aa98:	2f c8       	sub	r8,-4
8000aa9a:	b1 4a       	asr	r10,0x10
8000aa9c:	0a 37       	cp.w	r7,r5
8000aa9e:	cf 33       	brcs	8000aa84 <__mdiff+0x98>
8000aaa0:	c0 28       	rjmp	8000aaa4 <__mdiff+0xb8>
8000aaa2:	20 19       	sub	r9,1
8000aaa4:	11 4a       	ld.w	r10,--r8
8000aaa6:	58 0a       	cp.w	r10,0
8000aaa8:	cf d0       	breq	8000aaa2 <__mdiff+0xb6>
8000aaaa:	99 49       	st.w	r12[0x10],r9
8000aaac:	d8 32       	popm	r0-r7,pc
8000aaae:	30 0b       	mov	r11,0
8000aab0:	c1 6f       	rcall	8000a8dc <_Balloc>
8000aab2:	30 18       	mov	r8,1
8000aab4:	99 48       	st.w	r12[0x10],r8
8000aab6:	30 08       	mov	r8,0
8000aab8:	99 58       	st.w	r12[0x14],r8
8000aaba:	d8 32       	popm	r0-r7,pc

8000aabc <__lshift>:
8000aabc:	d4 31       	pushm	r0-r7,lr
8000aabe:	16 97       	mov	r7,r11
8000aac0:	76 46       	ld.w	r6,r11[0x10]
8000aac2:	f4 02 14 05 	asr	r2,r10,0x5
8000aac6:	2f f6       	sub	r6,-1
8000aac8:	14 93       	mov	r3,r10
8000aaca:	18 94       	mov	r4,r12
8000aacc:	04 06       	add	r6,r2
8000aace:	76 1b       	ld.w	r11,r11[0x4]
8000aad0:	6e 28       	ld.w	r8,r7[0x8]
8000aad2:	c0 38       	rjmp	8000aad8 <__lshift+0x1c>
8000aad4:	2f fb       	sub	r11,-1
8000aad6:	a1 78       	lsl	r8,0x1
8000aad8:	10 36       	cp.w	r6,r8
8000aada:	fe 99 ff fd 	brgt	8000aad4 <__lshift+0x18>
8000aade:	08 9c       	mov	r12,r4
8000aae0:	cf ee       	rcall	8000a8dc <_Balloc>
8000aae2:	30 09       	mov	r9,0
8000aae4:	18 95       	mov	r5,r12
8000aae6:	f8 c8 ff ec 	sub	r8,r12,-20
8000aaea:	12 9a       	mov	r10,r9
8000aaec:	c0 38       	rjmp	8000aaf2 <__lshift+0x36>
8000aaee:	10 aa       	st.w	r8++,r10
8000aaf0:	2f f9       	sub	r9,-1
8000aaf2:	04 39       	cp.w	r9,r2
8000aaf4:	cf d5       	brlt	8000aaee <__lshift+0x32>
8000aaf6:	6e 4b       	ld.w	r11,r7[0x10]
8000aaf8:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000aafc:	2f bb       	sub	r11,-5
8000aafe:	ee c9 ff ec 	sub	r9,r7,-20
8000ab02:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ab06:	58 03       	cp.w	r3,0
8000ab08:	c1 30       	breq	8000ab2e <__lshift+0x72>
8000ab0a:	e6 0c 11 20 	rsub	r12,r3,32
8000ab0e:	30 0a       	mov	r10,0
8000ab10:	72 02       	ld.w	r2,r9[0x0]
8000ab12:	e4 03 09 42 	lsl	r2,r2,r3
8000ab16:	04 4a       	or	r10,r2
8000ab18:	10 aa       	st.w	r8++,r10
8000ab1a:	13 0a       	ld.w	r10,r9++
8000ab1c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ab20:	16 39       	cp.w	r9,r11
8000ab22:	cf 73       	brcs	8000ab10 <__lshift+0x54>
8000ab24:	91 0a       	st.w	r8[0x0],r10
8000ab26:	58 0a       	cp.w	r10,0
8000ab28:	c0 70       	breq	8000ab36 <__lshift+0x7a>
8000ab2a:	2f f6       	sub	r6,-1
8000ab2c:	c0 58       	rjmp	8000ab36 <__lshift+0x7a>
8000ab2e:	13 0a       	ld.w	r10,r9++
8000ab30:	10 aa       	st.w	r8++,r10
8000ab32:	16 39       	cp.w	r9,r11
8000ab34:	cf d3       	brcs	8000ab2e <__lshift+0x72>
8000ab36:	08 9c       	mov	r12,r4
8000ab38:	20 16       	sub	r6,1
8000ab3a:	0e 9b       	mov	r11,r7
8000ab3c:	8b 46       	st.w	r5[0x10],r6
8000ab3e:	cb 5e       	rcall	8000a8a8 <_Bfree>
8000ab40:	0a 9c       	mov	r12,r5
8000ab42:	d8 32       	popm	r0-r7,pc

8000ab44 <__multiply>:
8000ab44:	d4 31       	pushm	r0-r7,lr
8000ab46:	20 2d       	sub	sp,8
8000ab48:	76 49       	ld.w	r9,r11[0x10]
8000ab4a:	74 48       	ld.w	r8,r10[0x10]
8000ab4c:	16 96       	mov	r6,r11
8000ab4e:	14 95       	mov	r5,r10
8000ab50:	10 39       	cp.w	r9,r8
8000ab52:	ec 08 17 50 	movlt	r8,r6
8000ab56:	ea 06 17 50 	movlt	r6,r5
8000ab5a:	f0 05 17 50 	movlt	r5,r8
8000ab5e:	6c 28       	ld.w	r8,r6[0x8]
8000ab60:	76 43       	ld.w	r3,r11[0x10]
8000ab62:	74 42       	ld.w	r2,r10[0x10]
8000ab64:	76 1b       	ld.w	r11,r11[0x4]
8000ab66:	e4 03 00 07 	add	r7,r2,r3
8000ab6a:	10 37       	cp.w	r7,r8
8000ab6c:	f7 bb 09 ff 	subgt	r11,-1
8000ab70:	cb 6e       	rcall	8000a8dc <_Balloc>
8000ab72:	ee c4 ff fb 	sub	r4,r7,-5
8000ab76:	f8 c9 ff ec 	sub	r9,r12,-20
8000ab7a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ab7e:	30 0a       	mov	r10,0
8000ab80:	12 98       	mov	r8,r9
8000ab82:	c0 28       	rjmp	8000ab86 <__multiply+0x42>
8000ab84:	10 aa       	st.w	r8++,r10
8000ab86:	08 38       	cp.w	r8,r4
8000ab88:	cf e3       	brcs	8000ab84 <__multiply+0x40>
8000ab8a:	2f b3       	sub	r3,-5
8000ab8c:	2f b2       	sub	r2,-5
8000ab8e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ab92:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ab96:	ec cb ff ec 	sub	r11,r6,-20
8000ab9a:	50 12       	stdsp	sp[0x4],r2
8000ab9c:	ea ca ff ec 	sub	r10,r5,-20
8000aba0:	c4 48       	rjmp	8000ac28 <__multiply+0xe4>
8000aba2:	94 95       	ld.uh	r5,r10[0x2]
8000aba4:	58 05       	cp.w	r5,0
8000aba6:	c2 00       	breq	8000abe6 <__multiply+0xa2>
8000aba8:	12 98       	mov	r8,r9
8000abaa:	16 96       	mov	r6,r11
8000abac:	30 0e       	mov	lr,0
8000abae:	50 09       	stdsp	sp[0x0],r9
8000abb0:	0d 02       	ld.w	r2,r6++
8000abb2:	e4 00 16 10 	lsr	r0,r2,0x10
8000abb6:	70 01       	ld.w	r1,r8[0x0]
8000abb8:	70 09       	ld.w	r9,r8[0x0]
8000abba:	b1 81       	lsr	r1,0x10
8000abbc:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000abc0:	e0 05 03 41 	mac	r1,r0,r5
8000abc4:	ab 32       	mul	r2,r5
8000abc6:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000abca:	00 02       	add	r2,r0
8000abcc:	e4 0e 00 0e 	add	lr,r2,lr
8000abd0:	b0 1e       	st.h	r8[0x2],lr
8000abd2:	b1 8e       	lsr	lr,0x10
8000abd4:	1c 01       	add	r1,lr
8000abd6:	b0 01       	st.h	r8[0x0],r1
8000abd8:	e2 0e 16 10 	lsr	lr,r1,0x10
8000abdc:	2f c8       	sub	r8,-4
8000abde:	06 36       	cp.w	r6,r3
8000abe0:	ce 83       	brcs	8000abb0 <__multiply+0x6c>
8000abe2:	40 09       	lddsp	r9,sp[0x0]
8000abe4:	91 0e       	st.w	r8[0x0],lr
8000abe6:	94 86       	ld.uh	r6,r10[0x0]
8000abe8:	58 06       	cp.w	r6,0
8000abea:	c1 d0       	breq	8000ac24 <__multiply+0xe0>
8000abec:	72 02       	ld.w	r2,r9[0x0]
8000abee:	12 98       	mov	r8,r9
8000abf0:	16 9e       	mov	lr,r11
8000abf2:	30 05       	mov	r5,0
8000abf4:	b0 12       	st.h	r8[0x2],r2
8000abf6:	1d 01       	ld.w	r1,lr++
8000abf8:	90 82       	ld.uh	r2,r8[0x0]
8000abfa:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000abfe:	ad 30       	mul	r0,r6
8000ac00:	e0 02 00 02 	add	r2,r0,r2
8000ac04:	e4 05 00 05 	add	r5,r2,r5
8000ac08:	b0 05       	st.h	r8[0x0],r5
8000ac0a:	b1 85       	lsr	r5,0x10
8000ac0c:	b1 81       	lsr	r1,0x10
8000ac0e:	2f c8       	sub	r8,-4
8000ac10:	ad 31       	mul	r1,r6
8000ac12:	90 92       	ld.uh	r2,r8[0x2]
8000ac14:	e2 02 00 02 	add	r2,r1,r2
8000ac18:	0a 02       	add	r2,r5
8000ac1a:	e4 05 16 10 	lsr	r5,r2,0x10
8000ac1e:	06 3e       	cp.w	lr,r3
8000ac20:	ce a3       	brcs	8000abf4 <__multiply+0xb0>
8000ac22:	91 02       	st.w	r8[0x0],r2
8000ac24:	2f ca       	sub	r10,-4
8000ac26:	2f c9       	sub	r9,-4
8000ac28:	40 18       	lddsp	r8,sp[0x4]
8000ac2a:	10 3a       	cp.w	r10,r8
8000ac2c:	cb b3       	brcs	8000aba2 <__multiply+0x5e>
8000ac2e:	c0 28       	rjmp	8000ac32 <__multiply+0xee>
8000ac30:	20 17       	sub	r7,1
8000ac32:	58 07       	cp.w	r7,0
8000ac34:	e0 8a 00 05 	brle	8000ac3e <__multiply+0xfa>
8000ac38:	09 48       	ld.w	r8,--r4
8000ac3a:	58 08       	cp.w	r8,0
8000ac3c:	cf a0       	breq	8000ac30 <__multiply+0xec>
8000ac3e:	99 47       	st.w	r12[0x10],r7
8000ac40:	2f ed       	sub	sp,-8
8000ac42:	d8 32       	popm	r0-r7,pc

8000ac44 <__i2b>:
8000ac44:	d4 21       	pushm	r4-r7,lr
8000ac46:	16 97       	mov	r7,r11
8000ac48:	30 1b       	mov	r11,1
8000ac4a:	c4 9e       	rcall	8000a8dc <_Balloc>
8000ac4c:	30 19       	mov	r9,1
8000ac4e:	99 57       	st.w	r12[0x14],r7
8000ac50:	99 49       	st.w	r12[0x10],r9
8000ac52:	d8 22       	popm	r4-r7,pc

8000ac54 <__multadd>:
8000ac54:	d4 31       	pushm	r0-r7,lr
8000ac56:	30 08       	mov	r8,0
8000ac58:	12 95       	mov	r5,r9
8000ac5a:	16 97       	mov	r7,r11
8000ac5c:	18 96       	mov	r6,r12
8000ac5e:	76 44       	ld.w	r4,r11[0x10]
8000ac60:	f6 c9 ff ec 	sub	r9,r11,-20
8000ac64:	72 0b       	ld.w	r11,r9[0x0]
8000ac66:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ac6a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ac6e:	f4 0c 02 4c 	mul	r12,r10,r12
8000ac72:	f4 0b 03 45 	mac	r5,r10,r11
8000ac76:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ac7a:	b1 85       	lsr	r5,0x10
8000ac7c:	18 05       	add	r5,r12
8000ac7e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ac82:	f8 0b 00 0b 	add	r11,r12,r11
8000ac86:	12 ab       	st.w	r9++,r11
8000ac88:	2f f8       	sub	r8,-1
8000ac8a:	b1 85       	lsr	r5,0x10
8000ac8c:	08 38       	cp.w	r8,r4
8000ac8e:	ce b5       	brlt	8000ac64 <__multadd+0x10>
8000ac90:	58 05       	cp.w	r5,0
8000ac92:	c1 c0       	breq	8000acca <__multadd+0x76>
8000ac94:	6e 28       	ld.w	r8,r7[0x8]
8000ac96:	10 34       	cp.w	r4,r8
8000ac98:	c1 35       	brlt	8000acbe <__multadd+0x6a>
8000ac9a:	6e 1b       	ld.w	r11,r7[0x4]
8000ac9c:	0c 9c       	mov	r12,r6
8000ac9e:	2f fb       	sub	r11,-1
8000aca0:	c1 ee       	rcall	8000a8dc <_Balloc>
8000aca2:	6e 4a       	ld.w	r10,r7[0x10]
8000aca4:	ee cb ff f4 	sub	r11,r7,-12
8000aca8:	18 93       	mov	r3,r12
8000acaa:	2f ea       	sub	r10,-2
8000acac:	2f 4c       	sub	r12,-12
8000acae:	a3 6a       	lsl	r10,0x2
8000acb0:	fe b0 de 71 	rcall	80006992 <memcpy>
8000acb4:	0e 9b       	mov	r11,r7
8000acb6:	0c 9c       	mov	r12,r6
8000acb8:	fe b0 fd f8 	rcall	8000a8a8 <_Bfree>
8000acbc:	06 97       	mov	r7,r3
8000acbe:	e8 c8 ff ff 	sub	r8,r4,-1
8000acc2:	2f b4       	sub	r4,-5
8000acc4:	8f 48       	st.w	r7[0x10],r8
8000acc6:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000acca:	0e 9c       	mov	r12,r7
8000accc:	d8 32       	popm	r0-r7,pc
8000acce:	d7 03       	nop

8000acd0 <__pow5mult>:
8000acd0:	d4 31       	pushm	r0-r7,lr
8000acd2:	14 96       	mov	r6,r10
8000acd4:	18 97       	mov	r7,r12
8000acd6:	16 94       	mov	r4,r11
8000acd8:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000acdc:	c0 90       	breq	8000acee <__pow5mult+0x1e>
8000acde:	20 18       	sub	r8,1
8000ace0:	fe c9 d8 68 	sub	r9,pc,-10136
8000ace4:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ace8:	30 09       	mov	r9,0
8000acea:	cb 5f       	rcall	8000ac54 <__multadd>
8000acec:	18 94       	mov	r4,r12
8000acee:	a3 46       	asr	r6,0x2
8000acf0:	c3 40       	breq	8000ad58 <__pow5mult+0x88>
8000acf2:	6e 95       	ld.w	r5,r7[0x24]
8000acf4:	58 05       	cp.w	r5,0
8000acf6:	c0 91       	brne	8000ad08 <__pow5mult+0x38>
8000acf8:	31 0c       	mov	r12,16
8000acfa:	fe b0 dc 15 	rcall	80006524 <malloc>
8000acfe:	99 35       	st.w	r12[0xc],r5
8000ad00:	8f 9c       	st.w	r7[0x24],r12
8000ad02:	99 15       	st.w	r12[0x4],r5
8000ad04:	99 25       	st.w	r12[0x8],r5
8000ad06:	99 05       	st.w	r12[0x0],r5
8000ad08:	6e 93       	ld.w	r3,r7[0x24]
8000ad0a:	66 25       	ld.w	r5,r3[0x8]
8000ad0c:	58 05       	cp.w	r5,0
8000ad0e:	c0 c1       	brne	8000ad26 <__pow5mult+0x56>
8000ad10:	e0 6b 02 71 	mov	r11,625
8000ad14:	0e 9c       	mov	r12,r7
8000ad16:	c9 7f       	rcall	8000ac44 <__i2b>
8000ad18:	87 2c       	st.w	r3[0x8],r12
8000ad1a:	30 08       	mov	r8,0
8000ad1c:	18 95       	mov	r5,r12
8000ad1e:	99 08       	st.w	r12[0x0],r8
8000ad20:	c0 38       	rjmp	8000ad26 <__pow5mult+0x56>
8000ad22:	06 9c       	mov	r12,r3
8000ad24:	18 95       	mov	r5,r12
8000ad26:	ed b6 00 00 	bld	r6,0x0
8000ad2a:	c0 b1       	brne	8000ad40 <__pow5mult+0x70>
8000ad2c:	08 9b       	mov	r11,r4
8000ad2e:	0a 9a       	mov	r10,r5
8000ad30:	0e 9c       	mov	r12,r7
8000ad32:	c0 9f       	rcall	8000ab44 <__multiply>
8000ad34:	08 9b       	mov	r11,r4
8000ad36:	18 93       	mov	r3,r12
8000ad38:	0e 9c       	mov	r12,r7
8000ad3a:	06 94       	mov	r4,r3
8000ad3c:	fe b0 fd b6 	rcall	8000a8a8 <_Bfree>
8000ad40:	a1 56       	asr	r6,0x1
8000ad42:	c0 b0       	breq	8000ad58 <__pow5mult+0x88>
8000ad44:	6a 03       	ld.w	r3,r5[0x0]
8000ad46:	58 03       	cp.w	r3,0
8000ad48:	ce d1       	brne	8000ad22 <__pow5mult+0x52>
8000ad4a:	0a 9a       	mov	r10,r5
8000ad4c:	0a 9b       	mov	r11,r5
8000ad4e:	0e 9c       	mov	r12,r7
8000ad50:	cf ae       	rcall	8000ab44 <__multiply>
8000ad52:	8b 0c       	st.w	r5[0x0],r12
8000ad54:	99 03       	st.w	r12[0x0],r3
8000ad56:	ce 7b       	rjmp	8000ad24 <__pow5mult+0x54>
8000ad58:	08 9c       	mov	r12,r4
8000ad5a:	d8 32       	popm	r0-r7,pc

8000ad5c <__isinfd>:
8000ad5c:	14 98       	mov	r8,r10
8000ad5e:	fc 19 7f f0 	movh	r9,0x7ff0
8000ad62:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad66:	f0 0b 11 00 	rsub	r11,r8,0
8000ad6a:	f7 e8 10 08 	or	r8,r11,r8
8000ad6e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ad72:	f2 08 01 08 	sub	r8,r9,r8
8000ad76:	f0 0c 11 00 	rsub	r12,r8,0
8000ad7a:	f9 e8 10 08 	or	r8,r12,r8
8000ad7e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ad82:	2f fc       	sub	r12,-1
8000ad84:	5e fc       	retal	r12

8000ad86 <__isnand>:
8000ad86:	14 98       	mov	r8,r10
8000ad88:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad8c:	f0 0c 11 00 	rsub	r12,r8,0
8000ad90:	10 4c       	or	r12,r8
8000ad92:	fc 18 7f f0 	movh	r8,0x7ff0
8000ad96:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ad9a:	f0 0c 01 0c 	sub	r12,r8,r12
8000ad9e:	bf 9c       	lsr	r12,0x1f
8000ada0:	5e fc       	retal	r12
8000ada2:	d7 03       	nop

8000ada4 <__sclose>:
8000ada4:	d4 01       	pushm	lr
8000ada6:	96 7b       	ld.sh	r11,r11[0xe]
8000ada8:	c8 2c       	rcall	8000aeac <_close_r>
8000adaa:	d8 02       	popm	pc

8000adac <__sseek>:
8000adac:	d4 21       	pushm	r4-r7,lr
8000adae:	16 97       	mov	r7,r11
8000adb0:	96 7b       	ld.sh	r11,r11[0xe]
8000adb2:	c0 3d       	rcall	8000afb8 <_lseek_r>
8000adb4:	8e 68       	ld.sh	r8,r7[0xc]
8000adb6:	10 99       	mov	r9,r8
8000adb8:	ad c8       	cbr	r8,0xc
8000adba:	ad a9       	sbr	r9,0xc
8000adbc:	5b fc       	cp.w	r12,-1
8000adbe:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000adc2:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000adc6:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000adca:	d8 22       	popm	r4-r7,pc

8000adcc <__swrite>:
8000adcc:	d4 21       	pushm	r4-r7,lr
8000adce:	96 68       	ld.sh	r8,r11[0xc]
8000add0:	16 97       	mov	r7,r11
8000add2:	14 95       	mov	r5,r10
8000add4:	12 94       	mov	r4,r9
8000add6:	e2 18 01 00 	andl	r8,0x100,COH
8000adda:	18 96       	mov	r6,r12
8000addc:	c0 50       	breq	8000ade6 <__swrite+0x1a>
8000adde:	30 29       	mov	r9,2
8000ade0:	30 0a       	mov	r10,0
8000ade2:	96 7b       	ld.sh	r11,r11[0xe]
8000ade4:	ce ac       	rcall	8000afb8 <_lseek_r>
8000ade6:	8e 68       	ld.sh	r8,r7[0xc]
8000ade8:	ad c8       	cbr	r8,0xc
8000adea:	08 99       	mov	r9,r4
8000adec:	0a 9a       	mov	r10,r5
8000adee:	8e 7b       	ld.sh	r11,r7[0xe]
8000adf0:	0c 9c       	mov	r12,r6
8000adf2:	ae 68       	st.h	r7[0xc],r8
8000adf4:	c1 cc       	rcall	8000ae2c <_write_r>
8000adf6:	d8 22       	popm	r4-r7,pc

8000adf8 <__sread>:
8000adf8:	d4 21       	pushm	r4-r7,lr
8000adfa:	16 97       	mov	r7,r11
8000adfc:	96 7b       	ld.sh	r11,r11[0xe]
8000adfe:	cf 1c       	rcall	8000afe0 <_read_r>
8000ae00:	c0 65       	brlt	8000ae0c <__sread+0x14>
8000ae02:	6f 58       	ld.w	r8,r7[0x54]
8000ae04:	18 08       	add	r8,r12
8000ae06:	ef 48 00 54 	st.w	r7[84],r8
8000ae0a:	d8 22       	popm	r4-r7,pc
8000ae0c:	8e 68       	ld.sh	r8,r7[0xc]
8000ae0e:	ad c8       	cbr	r8,0xc
8000ae10:	ae 68       	st.h	r7[0xc],r8
8000ae12:	d8 22       	popm	r4-r7,pc

8000ae14 <strlen>:
8000ae14:	30 09       	mov	r9,0
8000ae16:	18 98       	mov	r8,r12
8000ae18:	c0 28       	rjmp	8000ae1c <strlen+0x8>
8000ae1a:	2f f8       	sub	r8,-1
8000ae1c:	11 8a       	ld.ub	r10,r8[0x0]
8000ae1e:	f2 0a 18 00 	cp.b	r10,r9
8000ae22:	cf c1       	brne	8000ae1a <strlen+0x6>
8000ae24:	f0 0c 01 0c 	sub	r12,r8,r12
8000ae28:	5e fc       	retal	r12
8000ae2a:	d7 03       	nop

8000ae2c <_write_r>:
8000ae2c:	d4 21       	pushm	r4-r7,lr
8000ae2e:	16 98       	mov	r8,r11
8000ae30:	18 97       	mov	r7,r12
8000ae32:	10 9c       	mov	r12,r8
8000ae34:	30 08       	mov	r8,0
8000ae36:	14 9b       	mov	r11,r10
8000ae38:	e0 66 1f b4 	mov	r6,8116
8000ae3c:	12 9a       	mov	r10,r9
8000ae3e:	8d 08       	st.w	r6[0x0],r8
8000ae40:	fe b0 d2 64 	rcall	80005308 <_write>
8000ae44:	5b fc       	cp.w	r12,-1
8000ae46:	c0 51       	brne	8000ae50 <_write_r+0x24>
8000ae48:	6c 08       	ld.w	r8,r6[0x0]
8000ae4a:	58 08       	cp.w	r8,0
8000ae4c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae50:	d8 22       	popm	r4-r7,pc
8000ae52:	d7 03       	nop

8000ae54 <_calloc_r>:
8000ae54:	d4 21       	pushm	r4-r7,lr
8000ae56:	f4 0b 02 4b 	mul	r11,r10,r11
8000ae5a:	fe b0 db 6d 	rcall	80006534 <_malloc_r>
8000ae5e:	18 97       	mov	r7,r12
8000ae60:	c2 30       	breq	8000aea6 <_calloc_r+0x52>
8000ae62:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ae66:	e0 1a ff fc 	andl	r10,0xfffc
8000ae6a:	20 4a       	sub	r10,4
8000ae6c:	e0 4a 00 24 	cp.w	r10,36
8000ae70:	e0 8b 00 18 	brhi	8000aea0 <_calloc_r+0x4c>
8000ae74:	18 98       	mov	r8,r12
8000ae76:	59 3a       	cp.w	r10,19
8000ae78:	e0 88 00 0f 	brls	8000ae96 <_calloc_r+0x42>
8000ae7c:	30 09       	mov	r9,0
8000ae7e:	10 a9       	st.w	r8++,r9
8000ae80:	10 a9       	st.w	r8++,r9
8000ae82:	59 ba       	cp.w	r10,27
8000ae84:	e0 88 00 09 	brls	8000ae96 <_calloc_r+0x42>
8000ae88:	10 a9       	st.w	r8++,r9
8000ae8a:	10 a9       	st.w	r8++,r9
8000ae8c:	e0 4a 00 24 	cp.w	r10,36
8000ae90:	c0 31       	brne	8000ae96 <_calloc_r+0x42>
8000ae92:	10 a9       	st.w	r8++,r9
8000ae94:	10 a9       	st.w	r8++,r9
8000ae96:	30 09       	mov	r9,0
8000ae98:	10 a9       	st.w	r8++,r9
8000ae9a:	91 19       	st.w	r8[0x4],r9
8000ae9c:	91 09       	st.w	r8[0x0],r9
8000ae9e:	c0 48       	rjmp	8000aea6 <_calloc_r+0x52>
8000aea0:	30 0b       	mov	r11,0
8000aea2:	fe b0 de 1c 	rcall	80006ada <memset>
8000aea6:	0e 9c       	mov	r12,r7
8000aea8:	d8 22       	popm	r4-r7,pc
8000aeaa:	d7 03       	nop

8000aeac <_close_r>:
8000aeac:	d4 21       	pushm	r4-r7,lr
8000aeae:	30 08       	mov	r8,0
8000aeb0:	18 97       	mov	r7,r12
8000aeb2:	e0 66 1f b4 	mov	r6,8116
8000aeb6:	16 9c       	mov	r12,r11
8000aeb8:	8d 08       	st.w	r6[0x0],r8
8000aeba:	fe b0 df b5 	rcall	80006e24 <_close>
8000aebe:	5b fc       	cp.w	r12,-1
8000aec0:	c0 51       	brne	8000aeca <_close_r+0x1e>
8000aec2:	6c 08       	ld.w	r8,r6[0x0]
8000aec4:	58 08       	cp.w	r8,0
8000aec6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aeca:	d8 22       	popm	r4-r7,pc

8000aecc <_fclose_r>:
8000aecc:	d4 21       	pushm	r4-r7,lr
8000aece:	18 96       	mov	r6,r12
8000aed0:	16 97       	mov	r7,r11
8000aed2:	58 0b       	cp.w	r11,0
8000aed4:	c0 31       	brne	8000aeda <_fclose_r+0xe>
8000aed6:	16 95       	mov	r5,r11
8000aed8:	c5 38       	rjmp	8000af7e <_fclose_r+0xb2>
8000aeda:	fe b0 f8 a9 	rcall	8000a02c <__sfp_lock_acquire>
8000aede:	58 06       	cp.w	r6,0
8000aee0:	c0 70       	breq	8000aeee <_fclose_r+0x22>
8000aee2:	6c 68       	ld.w	r8,r6[0x18]
8000aee4:	58 08       	cp.w	r8,0
8000aee6:	c0 41       	brne	8000aeee <_fclose_r+0x22>
8000aee8:	0c 9c       	mov	r12,r6
8000aeea:	fe b0 f8 f3 	rcall	8000a0d0 <__sinit>
8000aeee:	fe c8 db 1a 	sub	r8,pc,-9446
8000aef2:	10 37       	cp.w	r7,r8
8000aef4:	c0 31       	brne	8000aefa <_fclose_r+0x2e>
8000aef6:	6c 07       	ld.w	r7,r6[0x0]
8000aef8:	c0 c8       	rjmp	8000af10 <_fclose_r+0x44>
8000aefa:	fe c8 db 06 	sub	r8,pc,-9466
8000aefe:	10 37       	cp.w	r7,r8
8000af00:	c0 31       	brne	8000af06 <_fclose_r+0x3a>
8000af02:	6c 17       	ld.w	r7,r6[0x4]
8000af04:	c0 68       	rjmp	8000af10 <_fclose_r+0x44>
8000af06:	fe c8 da f2 	sub	r8,pc,-9486
8000af0a:	10 37       	cp.w	r7,r8
8000af0c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000af10:	8e 69       	ld.sh	r9,r7[0xc]
8000af12:	30 08       	mov	r8,0
8000af14:	f0 09 19 00 	cp.h	r9,r8
8000af18:	c0 51       	brne	8000af22 <_fclose_r+0x56>
8000af1a:	fe b0 f8 8a 	rcall	8000a02e <__sfp_lock_release>
8000af1e:	30 05       	mov	r5,0
8000af20:	c2 f8       	rjmp	8000af7e <_fclose_r+0xb2>
8000af22:	0e 9b       	mov	r11,r7
8000af24:	0c 9c       	mov	r12,r6
8000af26:	fe b0 f7 fd 	rcall	80009f20 <_fflush_r>
8000af2a:	6e c8       	ld.w	r8,r7[0x30]
8000af2c:	18 95       	mov	r5,r12
8000af2e:	58 08       	cp.w	r8,0
8000af30:	c0 60       	breq	8000af3c <_fclose_r+0x70>
8000af32:	6e 8b       	ld.w	r11,r7[0x20]
8000af34:	0c 9c       	mov	r12,r6
8000af36:	5d 18       	icall	r8
8000af38:	f9 b5 05 ff 	movlt	r5,-1
8000af3c:	8e 68       	ld.sh	r8,r7[0xc]
8000af3e:	ed b8 00 07 	bld	r8,0x7
8000af42:	c0 51       	brne	8000af4c <_fclose_r+0x80>
8000af44:	6e 4b       	ld.w	r11,r7[0x10]
8000af46:	0c 9c       	mov	r12,r6
8000af48:	fe b0 f9 5e 	rcall	8000a204 <_free_r>
8000af4c:	6e db       	ld.w	r11,r7[0x34]
8000af4e:	58 0b       	cp.w	r11,0
8000af50:	c0 a0       	breq	8000af64 <_fclose_r+0x98>
8000af52:	ee c8 ff bc 	sub	r8,r7,-68
8000af56:	10 3b       	cp.w	r11,r8
8000af58:	c0 40       	breq	8000af60 <_fclose_r+0x94>
8000af5a:	0c 9c       	mov	r12,r6
8000af5c:	fe b0 f9 54 	rcall	8000a204 <_free_r>
8000af60:	30 08       	mov	r8,0
8000af62:	8f d8       	st.w	r7[0x34],r8
8000af64:	6f 2b       	ld.w	r11,r7[0x48]
8000af66:	58 0b       	cp.w	r11,0
8000af68:	c0 70       	breq	8000af76 <_fclose_r+0xaa>
8000af6a:	0c 9c       	mov	r12,r6
8000af6c:	fe b0 f9 4c 	rcall	8000a204 <_free_r>
8000af70:	30 08       	mov	r8,0
8000af72:	ef 48 00 48 	st.w	r7[72],r8
8000af76:	30 08       	mov	r8,0
8000af78:	ae 68       	st.h	r7[0xc],r8
8000af7a:	fe b0 f8 5a 	rcall	8000a02e <__sfp_lock_release>
8000af7e:	0a 9c       	mov	r12,r5
8000af80:	d8 22       	popm	r4-r7,pc
8000af82:	d7 03       	nop

8000af84 <fclose>:
8000af84:	d4 01       	pushm	lr
8000af86:	e0 68 0a 1c 	mov	r8,2588
8000af8a:	18 9b       	mov	r11,r12
8000af8c:	70 0c       	ld.w	r12,r8[0x0]
8000af8e:	c9 ff       	rcall	8000aecc <_fclose_r>
8000af90:	d8 02       	popm	pc
8000af92:	d7 03       	nop

8000af94 <_fstat_r>:
8000af94:	d4 21       	pushm	r4-r7,lr
8000af96:	16 98       	mov	r8,r11
8000af98:	18 97       	mov	r7,r12
8000af9a:	10 9c       	mov	r12,r8
8000af9c:	30 08       	mov	r8,0
8000af9e:	e0 66 1f b4 	mov	r6,8116
8000afa2:	14 9b       	mov	r11,r10
8000afa4:	8d 08       	st.w	r6[0x0],r8
8000afa6:	fe b0 df 67 	rcall	80006e74 <_fstat>
8000afaa:	5b fc       	cp.w	r12,-1
8000afac:	c0 51       	brne	8000afb6 <_fstat_r+0x22>
8000afae:	6c 08       	ld.w	r8,r6[0x0]
8000afb0:	58 08       	cp.w	r8,0
8000afb2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000afb6:	d8 22       	popm	r4-r7,pc

8000afb8 <_lseek_r>:
8000afb8:	d4 21       	pushm	r4-r7,lr
8000afba:	16 98       	mov	r8,r11
8000afbc:	18 97       	mov	r7,r12
8000afbe:	10 9c       	mov	r12,r8
8000afc0:	30 08       	mov	r8,0
8000afc2:	14 9b       	mov	r11,r10
8000afc4:	e0 66 1f b4 	mov	r6,8116
8000afc8:	12 9a       	mov	r10,r9
8000afca:	8d 08       	st.w	r6[0x0],r8
8000afcc:	fe b0 df 36 	rcall	80006e38 <_lseek>
8000afd0:	5b fc       	cp.w	r12,-1
8000afd2:	c0 51       	brne	8000afdc <_lseek_r+0x24>
8000afd4:	6c 08       	ld.w	r8,r6[0x0]
8000afd6:	58 08       	cp.w	r8,0
8000afd8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000afdc:	d8 22       	popm	r4-r7,pc
8000afde:	d7 03       	nop

8000afe0 <_read_r>:
8000afe0:	d4 21       	pushm	r4-r7,lr
8000afe2:	16 98       	mov	r8,r11
8000afe4:	18 97       	mov	r7,r12
8000afe6:	10 9c       	mov	r12,r8
8000afe8:	30 08       	mov	r8,0
8000afea:	14 9b       	mov	r11,r10
8000afec:	e0 66 1f b4 	mov	r6,8116
8000aff0:	12 9a       	mov	r10,r9
8000aff2:	8d 08       	st.w	r6[0x0],r8
8000aff4:	fe b0 d1 6a 	rcall	800052c8 <_read>
8000aff8:	5b fc       	cp.w	r12,-1
8000affa:	c0 51       	brne	8000b004 <_read_r+0x24>
8000affc:	6c 08       	ld.w	r8,r6[0x0]
8000affe:	58 08       	cp.w	r8,0
8000b000:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b004:	d8 22       	popm	r4-r7,pc
8000b006:	d7 03       	nop

8000b008 <__avr32_f64_mul>:
8000b008:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b00c:	e0 80 00 dc 	breq	8000b1c4 <__avr32_f64_mul_op1_zero>
8000b010:	d4 21       	pushm	r4-r7,lr
8000b012:	f7 e9 20 0e 	eor	lr,r11,r9
8000b016:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b01a:	30 15       	mov	r5,1
8000b01c:	c4 30       	breq	8000b0a2 <__avr32_f64_mul_op1_subnormal>
8000b01e:	ab 6b       	lsl	r11,0xa
8000b020:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b024:	ab 6a       	lsl	r10,0xa
8000b026:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b02a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b02e:	c5 c0       	breq	8000b0e6 <__avr32_f64_mul_op2_subnormal>
8000b030:	a1 78       	lsl	r8,0x1
8000b032:	5c f9       	rol	r9
8000b034:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b038:	e0 47 07 ff 	cp.w	r7,2047
8000b03c:	c7 70       	breq	8000b12a <__avr32_f64_mul_op_nan_or_inf>
8000b03e:	e0 46 07 ff 	cp.w	r6,2047
8000b042:	c7 40       	breq	8000b12a <__avr32_f64_mul_op_nan_or_inf>
8000b044:	ee 06 00 0c 	add	r12,r7,r6
8000b048:	e0 2c 03 fe 	sub	r12,1022
8000b04c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b050:	f4 09 07 44 	macu.d	r4,r10,r9
8000b054:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b058:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b05c:	08 07       	add	r7,r4
8000b05e:	f4 05 00 4a 	adc	r10,r10,r5
8000b062:	5c 0b       	acr	r11
8000b064:	ed bb 00 14 	bld	r11,0x14
8000b068:	c0 50       	breq	8000b072 <__avr32_f64_mul+0x6a>
8000b06a:	a1 77       	lsl	r7,0x1
8000b06c:	5c fa       	rol	r10
8000b06e:	5c fb       	rol	r11
8000b070:	20 1c       	sub	r12,1
8000b072:	58 0c       	cp.w	r12,0
8000b074:	e0 8a 00 6f 	brle	8000b152 <__avr32_f64_mul_res_subnormal>
8000b078:	e0 4c 07 ff 	cp.w	r12,2047
8000b07c:	e0 84 00 9c 	brge	8000b1b4 <__avr32_f64_mul_res_inf>
8000b080:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b084:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b088:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b08c:	ee 17 80 00 	eorh	r7,0x8000
8000b090:	f1 b7 04 20 	satu	r7,0x1
8000b094:	0e 0a       	add	r10,r7
8000b096:	5c 0b       	acr	r11
8000b098:	ed be 00 1f 	bld	lr,0x1f
8000b09c:	ef bb 00 1f 	bst	r11,0x1f
8000b0a0:	d8 22       	popm	r4-r7,pc

8000b0a2 <__avr32_f64_mul_op1_subnormal>:
8000b0a2:	e4 1b 00 0f 	andh	r11,0xf
8000b0a6:	f4 0c 12 00 	clz	r12,r10
8000b0aa:	f6 06 12 00 	clz	r6,r11
8000b0ae:	f7 bc 03 e1 	sublo	r12,-31
8000b0b2:	f8 06 17 30 	movlo	r6,r12
8000b0b6:	f7 b6 02 01 	subhs	r6,1
8000b0ba:	e0 46 00 20 	cp.w	r6,32
8000b0be:	c0 d4       	brge	8000b0d8 <__avr32_f64_mul_op1_subnormal+0x36>
8000b0c0:	ec 0c 11 20 	rsub	r12,r6,32
8000b0c4:	f6 06 09 4b 	lsl	r11,r11,r6
8000b0c8:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b0cc:	18 4b       	or	r11,r12
8000b0ce:	f4 06 09 4a 	lsl	r10,r10,r6
8000b0d2:	20 b6       	sub	r6,11
8000b0d4:	0c 17       	sub	r7,r6
8000b0d6:	ca ab       	rjmp	8000b02a <__avr32_f64_mul+0x22>
8000b0d8:	f4 06 09 4b 	lsl	r11,r10,r6
8000b0dc:	c6 40       	breq	8000b1a4 <__avr32_f64_mul_res_zero>
8000b0de:	30 0a       	mov	r10,0
8000b0e0:	20 b6       	sub	r6,11
8000b0e2:	0c 17       	sub	r7,r6
8000b0e4:	ca 3b       	rjmp	8000b02a <__avr32_f64_mul+0x22>

8000b0e6 <__avr32_f64_mul_op2_subnormal>:
8000b0e6:	e4 19 00 0f 	andh	r9,0xf
8000b0ea:	f0 0c 12 00 	clz	r12,r8
8000b0ee:	f2 05 12 00 	clz	r5,r9
8000b0f2:	f7 bc 03 ea 	sublo	r12,-22
8000b0f6:	f8 05 17 30 	movlo	r5,r12
8000b0fa:	f7 b5 02 0a 	subhs	r5,10
8000b0fe:	e0 45 00 20 	cp.w	r5,32
8000b102:	c0 d4       	brge	8000b11c <__avr32_f64_mul_op2_subnormal+0x36>
8000b104:	ea 0c 11 20 	rsub	r12,r5,32
8000b108:	f2 05 09 49 	lsl	r9,r9,r5
8000b10c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b110:	18 49       	or	r9,r12
8000b112:	f0 05 09 48 	lsl	r8,r8,r5
8000b116:	20 25       	sub	r5,2
8000b118:	0a 16       	sub	r6,r5
8000b11a:	c8 fb       	rjmp	8000b038 <__avr32_f64_mul+0x30>
8000b11c:	f0 05 09 49 	lsl	r9,r8,r5
8000b120:	c4 20       	breq	8000b1a4 <__avr32_f64_mul_res_zero>
8000b122:	30 08       	mov	r8,0
8000b124:	20 25       	sub	r5,2
8000b126:	0a 16       	sub	r6,r5
8000b128:	c8 8b       	rjmp	8000b038 <__avr32_f64_mul+0x30>

8000b12a <__avr32_f64_mul_op_nan_or_inf>:
8000b12a:	e4 19 00 0f 	andh	r9,0xf
8000b12e:	e4 1b 00 0f 	andh	r11,0xf
8000b132:	14 4b       	or	r11,r10
8000b134:	10 49       	or	r9,r8
8000b136:	e0 47 07 ff 	cp.w	r7,2047
8000b13a:	c0 91       	brne	8000b14c <__avr32_f64_mul_op1_not_naninf>
8000b13c:	58 0b       	cp.w	r11,0
8000b13e:	c3 81       	brne	8000b1ae <__avr32_f64_mul_res_nan>
8000b140:	e0 46 07 ff 	cp.w	r6,2047
8000b144:	c3 81       	brne	8000b1b4 <__avr32_f64_mul_res_inf>
8000b146:	58 09       	cp.w	r9,0
8000b148:	c3 60       	breq	8000b1b4 <__avr32_f64_mul_res_inf>
8000b14a:	c3 28       	rjmp	8000b1ae <__avr32_f64_mul_res_nan>

8000b14c <__avr32_f64_mul_op1_not_naninf>:
8000b14c:	58 09       	cp.w	r9,0
8000b14e:	c3 30       	breq	8000b1b4 <__avr32_f64_mul_res_inf>
8000b150:	c2 f8       	rjmp	8000b1ae <__avr32_f64_mul_res_nan>

8000b152 <__avr32_f64_mul_res_subnormal>:
8000b152:	5c 3c       	neg	r12
8000b154:	2f fc       	sub	r12,-1
8000b156:	f1 bc 04 c0 	satu	r12,0x6
8000b15a:	e0 4c 00 20 	cp.w	r12,32
8000b15e:	c1 14       	brge	8000b180 <__avr32_f64_mul_res_subnormal+0x2e>
8000b160:	f8 08 11 20 	rsub	r8,r12,32
8000b164:	0e 46       	or	r6,r7
8000b166:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b16a:	f4 08 09 49 	lsl	r9,r10,r8
8000b16e:	12 47       	or	r7,r9
8000b170:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b174:	f6 08 09 49 	lsl	r9,r11,r8
8000b178:	12 4a       	or	r10,r9
8000b17a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b17e:	c8 3b       	rjmp	8000b084 <__avr32_f64_mul+0x7c>
8000b180:	f8 08 11 20 	rsub	r8,r12,32
8000b184:	f9 b9 00 00 	moveq	r9,0
8000b188:	c0 30       	breq	8000b18e <__avr32_f64_mul_res_subnormal+0x3c>
8000b18a:	f6 08 09 49 	lsl	r9,r11,r8
8000b18e:	0e 46       	or	r6,r7
8000b190:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b194:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b198:	f3 ea 10 07 	or	r7,r9,r10
8000b19c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b1a0:	30 0b       	mov	r11,0
8000b1a2:	c7 1b       	rjmp	8000b084 <__avr32_f64_mul+0x7c>

8000b1a4 <__avr32_f64_mul_res_zero>:
8000b1a4:	1c 9b       	mov	r11,lr
8000b1a6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b1aa:	30 0a       	mov	r10,0
8000b1ac:	d8 22       	popm	r4-r7,pc

8000b1ae <__avr32_f64_mul_res_nan>:
8000b1ae:	3f fb       	mov	r11,-1
8000b1b0:	3f fa       	mov	r10,-1
8000b1b2:	d8 22       	popm	r4-r7,pc

8000b1b4 <__avr32_f64_mul_res_inf>:
8000b1b4:	f0 6b 00 00 	mov	r11,-1048576
8000b1b8:	ed be 00 1f 	bld	lr,0x1f
8000b1bc:	ef bb 00 1f 	bst	r11,0x1f
8000b1c0:	30 0a       	mov	r10,0
8000b1c2:	d8 22       	popm	r4-r7,pc

8000b1c4 <__avr32_f64_mul_op1_zero>:
8000b1c4:	f7 e9 20 0b 	eor	r11,r11,r9
8000b1c8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b1cc:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b1d0:	e0 4c 07 ff 	cp.w	r12,2047
8000b1d4:	5e 1c       	retne	r12
8000b1d6:	3f fa       	mov	r10,-1
8000b1d8:	3f fb       	mov	r11,-1
8000b1da:	5e fc       	retal	r12

8000b1dc <__avr32_f64_sub_from_add>:
8000b1dc:	ee 19 80 00 	eorh	r9,0x8000

8000b1e0 <__avr32_f64_sub>:
8000b1e0:	f7 e9 20 0c 	eor	r12,r11,r9
8000b1e4:	e0 86 00 ca 	brmi	8000b378 <__avr32_f64_add_from_sub>
8000b1e8:	eb cd 40 e0 	pushm	r5-r7,lr
8000b1ec:	16 9c       	mov	r12,r11
8000b1ee:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b1f2:	bf db       	cbr	r11,0x1f
8000b1f4:	bf d9       	cbr	r9,0x1f
8000b1f6:	10 3a       	cp.w	r10,r8
8000b1f8:	f2 0b 13 00 	cpc	r11,r9
8000b1fc:	c0 92       	brcc	8000b20e <__avr32_f64_sub+0x2e>
8000b1fe:	16 97       	mov	r7,r11
8000b200:	12 9b       	mov	r11,r9
8000b202:	0e 99       	mov	r9,r7
8000b204:	14 97       	mov	r7,r10
8000b206:	10 9a       	mov	r10,r8
8000b208:	0e 98       	mov	r8,r7
8000b20a:	ee 1c 80 00 	eorh	r12,0x8000
8000b20e:	f6 07 16 14 	lsr	r7,r11,0x14
8000b212:	ab 7b       	lsl	r11,0xb
8000b214:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b218:	ab 7a       	lsl	r10,0xb
8000b21a:	bf bb       	sbr	r11,0x1f
8000b21c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b220:	c4 40       	breq	8000b2a8 <__avr32_f64_sub_opL_subnormal>
8000b222:	ab 79       	lsl	r9,0xb
8000b224:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b228:	ab 78       	lsl	r8,0xb
8000b22a:	bf b9       	sbr	r9,0x1f

8000b22c <__avr32_f64_sub_opL_subnormal_done>:
8000b22c:	e0 47 07 ff 	cp.w	r7,2047
8000b230:	c4 f0       	breq	8000b2ce <__avr32_f64_sub_opH_nan_or_inf>
8000b232:	0e 26       	rsub	r6,r7
8000b234:	c1 20       	breq	8000b258 <__avr32_f64_sub_shift_done>
8000b236:	ec 05 11 20 	rsub	r5,r6,32
8000b23a:	e0 46 00 20 	cp.w	r6,32
8000b23e:	c7 c2       	brcc	8000b336 <__avr32_f64_sub_longshift>
8000b240:	f0 05 09 4e 	lsl	lr,r8,r5
8000b244:	f2 05 09 45 	lsl	r5,r9,r5
8000b248:	f0 06 0a 48 	lsr	r8,r8,r6
8000b24c:	f2 06 0a 49 	lsr	r9,r9,r6
8000b250:	0a 48       	or	r8,r5
8000b252:	58 0e       	cp.w	lr,0
8000b254:	5f 1e       	srne	lr
8000b256:	1c 48       	or	r8,lr

8000b258 <__avr32_f64_sub_shift_done>:
8000b258:	10 1a       	sub	r10,r8
8000b25a:	f6 09 01 4b 	sbc	r11,r11,r9
8000b25e:	f6 06 12 00 	clz	r6,r11
8000b262:	c0 e0       	breq	8000b27e <__avr32_f64_sub_longnormalize_done>
8000b264:	c7 83       	brcs	8000b354 <__avr32_f64_sub_longnormalize>
8000b266:	ec 0e 11 20 	rsub	lr,r6,32
8000b26a:	f6 06 09 4b 	lsl	r11,r11,r6
8000b26e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b272:	1c 4b       	or	r11,lr
8000b274:	f4 06 09 4a 	lsl	r10,r10,r6
8000b278:	0c 17       	sub	r7,r6
8000b27a:	e0 8a 00 39 	brle	8000b2ec <__avr32_f64_sub_subnormal_result>

8000b27e <__avr32_f64_sub_longnormalize_done>:
8000b27e:	f4 09 15 15 	lsl	r9,r10,0x15
8000b282:	ab 9a       	lsr	r10,0xb
8000b284:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b288:	ab 9b       	lsr	r11,0xb
8000b28a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b28e:	18 4b       	or	r11,r12

8000b290 <__avr32_f64_sub_round>:
8000b290:	fc 17 80 00 	movh	r7,0x8000
8000b294:	ed ba 00 00 	bld	r10,0x0
8000b298:	f7 b7 01 ff 	subne	r7,-1
8000b29c:	0e 39       	cp.w	r9,r7
8000b29e:	5f 29       	srhs	r9
8000b2a0:	12 0a       	add	r10,r9
8000b2a2:	5c 0b       	acr	r11
8000b2a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2a8 <__avr32_f64_sub_opL_subnormal>:
8000b2a8:	ab 79       	lsl	r9,0xb
8000b2aa:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b2ae:	ab 78       	lsl	r8,0xb
8000b2b0:	f3 e8 10 0e 	or	lr,r9,r8
8000b2b4:	f9 b6 01 01 	movne	r6,1
8000b2b8:	ee 0e 11 00 	rsub	lr,r7,0
8000b2bc:	f9 b7 00 01 	moveq	r7,1
8000b2c0:	ef bb 00 1f 	bst	r11,0x1f
8000b2c4:	f7 ea 10 0e 	or	lr,r11,r10
8000b2c8:	f9 b7 00 00 	moveq	r7,0
8000b2cc:	cb 0b       	rjmp	8000b22c <__avr32_f64_sub_opL_subnormal_done>

8000b2ce <__avr32_f64_sub_opH_nan_or_inf>:
8000b2ce:	bf db       	cbr	r11,0x1f
8000b2d0:	f7 ea 10 0e 	or	lr,r11,r10
8000b2d4:	c0 81       	brne	8000b2e4 <__avr32_f64_sub_return_nan>
8000b2d6:	e0 46 07 ff 	cp.w	r6,2047
8000b2da:	c0 50       	breq	8000b2e4 <__avr32_f64_sub_return_nan>
8000b2dc:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b2e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2e4 <__avr32_f64_sub_return_nan>:
8000b2e4:	3f fa       	mov	r10,-1
8000b2e6:	3f fb       	mov	r11,-1
8000b2e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2ec <__avr32_f64_sub_subnormal_result>:
8000b2ec:	5c 37       	neg	r7
8000b2ee:	2f f7       	sub	r7,-1
8000b2f0:	f1 b7 04 c0 	satu	r7,0x6
8000b2f4:	e0 47 00 20 	cp.w	r7,32
8000b2f8:	c1 14       	brge	8000b31a <__avr32_f64_sub_subnormal_result+0x2e>
8000b2fa:	ee 08 11 20 	rsub	r8,r7,32
8000b2fe:	f4 08 09 49 	lsl	r9,r10,r8
8000b302:	5f 16       	srne	r6
8000b304:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b308:	0c 4a       	or	r10,r6
8000b30a:	f6 08 09 49 	lsl	r9,r11,r8
8000b30e:	f5 e9 10 0a 	or	r10,r10,r9
8000b312:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b316:	30 07       	mov	r7,0
8000b318:	cb 3b       	rjmp	8000b27e <__avr32_f64_sub_longnormalize_done>
8000b31a:	ee 08 11 40 	rsub	r8,r7,64
8000b31e:	f6 08 09 49 	lsl	r9,r11,r8
8000b322:	14 49       	or	r9,r10
8000b324:	5f 16       	srne	r6
8000b326:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b32a:	0c 4a       	or	r10,r6
8000b32c:	30 0b       	mov	r11,0
8000b32e:	30 07       	mov	r7,0
8000b330:	ca 7b       	rjmp	8000b27e <__avr32_f64_sub_longnormalize_done>
8000b332:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b336 <__avr32_f64_sub_longshift>:
8000b336:	f1 b6 04 c0 	satu	r6,0x6
8000b33a:	f0 0e 17 00 	moveq	lr,r8
8000b33e:	c0 40       	breq	8000b346 <__avr32_f64_sub_longshift+0x10>
8000b340:	f2 05 09 4e 	lsl	lr,r9,r5
8000b344:	10 4e       	or	lr,r8
8000b346:	f2 06 0a 48 	lsr	r8,r9,r6
8000b34a:	30 09       	mov	r9,0
8000b34c:	58 0e       	cp.w	lr,0
8000b34e:	5f 1e       	srne	lr
8000b350:	1c 48       	or	r8,lr
8000b352:	c8 3b       	rjmp	8000b258 <__avr32_f64_sub_shift_done>

8000b354 <__avr32_f64_sub_longnormalize>:
8000b354:	f4 06 12 00 	clz	r6,r10
8000b358:	f9 b7 03 00 	movlo	r7,0
8000b35c:	f9 b6 03 00 	movlo	r6,0
8000b360:	f9 bc 03 00 	movlo	r12,0
8000b364:	f7 b6 02 e0 	subhs	r6,-32
8000b368:	f4 06 09 4b 	lsl	r11,r10,r6
8000b36c:	30 0a       	mov	r10,0
8000b36e:	0c 17       	sub	r7,r6
8000b370:	fe 9a ff be 	brle	8000b2ec <__avr32_f64_sub_subnormal_result>
8000b374:	c8 5b       	rjmp	8000b27e <__avr32_f64_sub_longnormalize_done>
8000b376:	d7 03       	nop

8000b378 <__avr32_f64_add_from_sub>:
8000b378:	ee 19 80 00 	eorh	r9,0x8000

8000b37c <__avr32_f64_add>:
8000b37c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b380:	fe 96 ff 2e 	brmi	8000b1dc <__avr32_f64_sub_from_add>
8000b384:	eb cd 40 e0 	pushm	r5-r7,lr
8000b388:	16 9c       	mov	r12,r11
8000b38a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b38e:	bf db       	cbr	r11,0x1f
8000b390:	bf d9       	cbr	r9,0x1f
8000b392:	12 3b       	cp.w	r11,r9
8000b394:	c0 72       	brcc	8000b3a2 <__avr32_f64_add+0x26>
8000b396:	16 97       	mov	r7,r11
8000b398:	12 9b       	mov	r11,r9
8000b39a:	0e 99       	mov	r9,r7
8000b39c:	14 97       	mov	r7,r10
8000b39e:	10 9a       	mov	r10,r8
8000b3a0:	0e 98       	mov	r8,r7
8000b3a2:	30 0e       	mov	lr,0
8000b3a4:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b3a8:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b3ac:	b5 ab       	sbr	r11,0x14
8000b3ae:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b3b2:	c6 20       	breq	8000b476 <__avr32_f64_add_op2_subnormal>
8000b3b4:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b3b8:	b5 a9       	sbr	r9,0x14
8000b3ba:	e0 47 07 ff 	cp.w	r7,2047
8000b3be:	c2 80       	breq	8000b40e <__avr32_f64_add_opH_nan_or_inf>
8000b3c0:	0e 26       	rsub	r6,r7
8000b3c2:	c1 20       	breq	8000b3e6 <__avr32_f64_add_shift_done>
8000b3c4:	e0 46 00 36 	cp.w	r6,54
8000b3c8:	c1 52       	brcc	8000b3f2 <__avr32_f64_add_res_of_done>
8000b3ca:	ec 05 11 20 	rsub	r5,r6,32
8000b3ce:	e0 46 00 20 	cp.w	r6,32
8000b3d2:	c3 52       	brcc	8000b43c <__avr32_f64_add_longshift>
8000b3d4:	f0 05 09 4e 	lsl	lr,r8,r5
8000b3d8:	f2 05 09 45 	lsl	r5,r9,r5
8000b3dc:	f0 06 0a 48 	lsr	r8,r8,r6
8000b3e0:	f2 06 0a 49 	lsr	r9,r9,r6
8000b3e4:	0a 48       	or	r8,r5

8000b3e6 <__avr32_f64_add_shift_done>:
8000b3e6:	10 0a       	add	r10,r8
8000b3e8:	f6 09 00 4b 	adc	r11,r11,r9
8000b3ec:	ed bb 00 15 	bld	r11,0x15
8000b3f0:	c3 40       	breq	8000b458 <__avr32_f64_add_res_of>

8000b3f2 <__avr32_f64_add_res_of_done>:
8000b3f2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b3f6:	18 4b       	or	r11,r12

8000b3f8 <__avr32_f64_add_round>:
8000b3f8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b3fc:	18 4e       	or	lr,r12
8000b3fe:	ee 1e 80 00 	eorh	lr,0x8000
8000b402:	f1 be 04 20 	satu	lr,0x1
8000b406:	1c 0a       	add	r10,lr
8000b408:	5c 0b       	acr	r11
8000b40a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b40e <__avr32_f64_add_opH_nan_or_inf>:
8000b40e:	b5 cb       	cbr	r11,0x14
8000b410:	f7 ea 10 0e 	or	lr,r11,r10
8000b414:	c1 01       	brne	8000b434 <__avr32_f64_add_return_nan>
8000b416:	e0 46 07 ff 	cp.w	r6,2047
8000b41a:	c0 30       	breq	8000b420 <__avr32_f64_add_opL_nan_or_inf>
8000b41c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b420 <__avr32_f64_add_opL_nan_or_inf>:
8000b420:	b5 c9       	cbr	r9,0x14
8000b422:	f3 e8 10 0e 	or	lr,r9,r8
8000b426:	c0 71       	brne	8000b434 <__avr32_f64_add_return_nan>
8000b428:	30 0a       	mov	r10,0
8000b42a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b42e:	18 4b       	or	r11,r12
8000b430:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b434 <__avr32_f64_add_return_nan>:
8000b434:	3f fa       	mov	r10,-1
8000b436:	3f fb       	mov	r11,-1
8000b438:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b43c <__avr32_f64_add_longshift>:
8000b43c:	f1 b6 04 c0 	satu	r6,0x6
8000b440:	f0 0e 17 00 	moveq	lr,r8
8000b444:	c0 60       	breq	8000b450 <__avr32_f64_add_longshift+0x14>
8000b446:	f2 05 09 4e 	lsl	lr,r9,r5
8000b44a:	58 08       	cp.w	r8,0
8000b44c:	5f 18       	srne	r8
8000b44e:	10 4e       	or	lr,r8
8000b450:	f2 06 0a 48 	lsr	r8,r9,r6
8000b454:	30 09       	mov	r9,0
8000b456:	cc 8b       	rjmp	8000b3e6 <__avr32_f64_add_shift_done>

8000b458 <__avr32_f64_add_res_of>:
8000b458:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b45c:	a1 9b       	lsr	r11,0x1
8000b45e:	5d 0a       	ror	r10
8000b460:	5d 0e       	ror	lr
8000b462:	2f f7       	sub	r7,-1
8000b464:	e0 47 07 ff 	cp.w	r7,2047
8000b468:	f9 ba 00 00 	moveq	r10,0
8000b46c:	f9 bb 00 00 	moveq	r11,0
8000b470:	f9 be 00 00 	moveq	lr,0
8000b474:	cb fb       	rjmp	8000b3f2 <__avr32_f64_add_res_of_done>

8000b476 <__avr32_f64_add_op2_subnormal>:
8000b476:	30 16       	mov	r6,1
8000b478:	58 07       	cp.w	r7,0
8000b47a:	ca 01       	brne	8000b3ba <__avr32_f64_add+0x3e>
8000b47c:	b5 cb       	cbr	r11,0x14
8000b47e:	10 0a       	add	r10,r8
8000b480:	f6 09 00 4b 	adc	r11,r11,r9
8000b484:	18 4b       	or	r11,r12
8000b486:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b48a:	d7 03       	nop

8000b48c <__avr32_f64_to_u32>:
8000b48c:	58 0b       	cp.w	r11,0
8000b48e:	5e 6d       	retmi	0

8000b490 <__avr32_f64_to_s32>:
8000b490:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b494:	b5 9c       	lsr	r12,0x15
8000b496:	e0 2c 03 ff 	sub	r12,1023
8000b49a:	5e 3d       	retlo	0
8000b49c:	f8 0c 11 1f 	rsub	r12,r12,31
8000b4a0:	16 99       	mov	r9,r11
8000b4a2:	ab 7b       	lsl	r11,0xb
8000b4a4:	bf bb       	sbr	r11,0x1f
8000b4a6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b4aa:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b4ae:	a1 79       	lsl	r9,0x1
8000b4b0:	5e 2b       	reths	r11
8000b4b2:	5c 3b       	neg	r11
8000b4b4:	5e fb       	retal	r11

8000b4b6 <__avr32_u32_to_f64>:
8000b4b6:	f8 cb 00 00 	sub	r11,r12,0
8000b4ba:	30 0c       	mov	r12,0
8000b4bc:	c0 38       	rjmp	8000b4c2 <__avr32_s32_to_f64+0x4>

8000b4be <__avr32_s32_to_f64>:
8000b4be:	18 9b       	mov	r11,r12
8000b4c0:	5c 4b       	abs	r11
8000b4c2:	30 0a       	mov	r10,0
8000b4c4:	5e 0b       	reteq	r11
8000b4c6:	d4 01       	pushm	lr
8000b4c8:	e0 69 04 1e 	mov	r9,1054
8000b4cc:	f6 08 12 00 	clz	r8,r11
8000b4d0:	c1 70       	breq	8000b4fe <__avr32_s32_to_f64+0x40>
8000b4d2:	c0 c3       	brcs	8000b4ea <__avr32_s32_to_f64+0x2c>
8000b4d4:	f0 0e 11 20 	rsub	lr,r8,32
8000b4d8:	f6 08 09 4b 	lsl	r11,r11,r8
8000b4dc:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b4e0:	1c 4b       	or	r11,lr
8000b4e2:	f4 08 09 4a 	lsl	r10,r10,r8
8000b4e6:	10 19       	sub	r9,r8
8000b4e8:	c0 b8       	rjmp	8000b4fe <__avr32_s32_to_f64+0x40>
8000b4ea:	f4 08 12 00 	clz	r8,r10
8000b4ee:	f9 b8 03 00 	movlo	r8,0
8000b4f2:	f7 b8 02 e0 	subhs	r8,-32
8000b4f6:	f4 08 09 4b 	lsl	r11,r10,r8
8000b4fa:	30 0a       	mov	r10,0
8000b4fc:	10 19       	sub	r9,r8
8000b4fe:	58 09       	cp.w	r9,0
8000b500:	e0 89 00 30 	brgt	8000b560 <__avr32_s32_to_f64+0xa2>
8000b504:	5c 39       	neg	r9
8000b506:	2f f9       	sub	r9,-1
8000b508:	e0 49 00 36 	cp.w	r9,54
8000b50c:	c0 43       	brcs	8000b514 <__avr32_s32_to_f64+0x56>
8000b50e:	30 0b       	mov	r11,0
8000b510:	30 0a       	mov	r10,0
8000b512:	c2 68       	rjmp	8000b55e <__avr32_s32_to_f64+0xa0>
8000b514:	2f 69       	sub	r9,-10
8000b516:	f2 08 11 20 	rsub	r8,r9,32
8000b51a:	e0 49 00 20 	cp.w	r9,32
8000b51e:	c0 b2       	brcc	8000b534 <__avr32_s32_to_f64+0x76>
8000b520:	f4 08 09 4e 	lsl	lr,r10,r8
8000b524:	f6 08 09 48 	lsl	r8,r11,r8
8000b528:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b52c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b530:	10 4b       	or	r11,r8
8000b532:	c0 88       	rjmp	8000b542 <__avr32_s32_to_f64+0x84>
8000b534:	f6 08 09 4e 	lsl	lr,r11,r8
8000b538:	14 4e       	or	lr,r10
8000b53a:	16 9a       	mov	r10,r11
8000b53c:	30 0b       	mov	r11,0
8000b53e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b542:	ed ba 00 00 	bld	r10,0x0
8000b546:	c0 92       	brcc	8000b558 <__avr32_s32_to_f64+0x9a>
8000b548:	1c 7e       	tst	lr,lr
8000b54a:	c0 41       	brne	8000b552 <__avr32_s32_to_f64+0x94>
8000b54c:	ed ba 00 01 	bld	r10,0x1
8000b550:	c0 42       	brcc	8000b558 <__avr32_s32_to_f64+0x9a>
8000b552:	2f fa       	sub	r10,-1
8000b554:	f7 bb 02 ff 	subhs	r11,-1
8000b558:	5c fc       	rol	r12
8000b55a:	5d 0b       	ror	r11
8000b55c:	5d 0a       	ror	r10
8000b55e:	d8 02       	popm	pc
8000b560:	e0 68 03 ff 	mov	r8,1023
8000b564:	ed ba 00 0b 	bld	r10,0xb
8000b568:	f7 b8 00 ff 	subeq	r8,-1
8000b56c:	10 0a       	add	r10,r8
8000b56e:	5c 0b       	acr	r11
8000b570:	f7 b9 03 fe 	sublo	r9,-2
8000b574:	e0 49 07 ff 	cp.w	r9,2047
8000b578:	c0 55       	brlt	8000b582 <__avr32_s32_to_f64+0xc4>
8000b57a:	30 0a       	mov	r10,0
8000b57c:	fc 1b ff e0 	movh	r11,0xffe0
8000b580:	c0 c8       	rjmp	8000b598 <__floatsidf_return_op1>
8000b582:	ed bb 00 1f 	bld	r11,0x1f
8000b586:	f7 b9 01 01 	subne	r9,1
8000b58a:	ab 9a       	lsr	r10,0xb
8000b58c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b590:	a1 7b       	lsl	r11,0x1
8000b592:	ab 9b       	lsr	r11,0xb
8000b594:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b598 <__floatsidf_return_op1>:
8000b598:	a1 7c       	lsl	r12,0x1
8000b59a:	5d 0b       	ror	r11
8000b59c:	d8 02       	popm	pc

8000b59e <__avr32_f64_cmp_eq>:
8000b59e:	10 3a       	cp.w	r10,r8
8000b5a0:	f2 0b 13 00 	cpc	r11,r9
8000b5a4:	c0 80       	breq	8000b5b4 <__avr32_f64_cmp_eq+0x16>
8000b5a6:	a1 7b       	lsl	r11,0x1
8000b5a8:	a1 79       	lsl	r9,0x1
8000b5aa:	14 4b       	or	r11,r10
8000b5ac:	12 4b       	or	r11,r9
8000b5ae:	10 4b       	or	r11,r8
8000b5b0:	5e 0f       	reteq	1
8000b5b2:	5e fd       	retal	0
8000b5b4:	a1 7b       	lsl	r11,0x1
8000b5b6:	fc 1c ff e0 	movh	r12,0xffe0
8000b5ba:	58 0a       	cp.w	r10,0
8000b5bc:	f8 0b 13 00 	cpc	r11,r12
8000b5c0:	5e 8f       	retls	1
8000b5c2:	5e fd       	retal	0

8000b5c4 <__avr32_f64_cmp_ge>:
8000b5c4:	1a de       	st.w	--sp,lr
8000b5c6:	1a d7       	st.w	--sp,r7
8000b5c8:	a1 7b       	lsl	r11,0x1
8000b5ca:	5f 3c       	srlo	r12
8000b5cc:	a1 79       	lsl	r9,0x1
8000b5ce:	5f 37       	srlo	r7
8000b5d0:	5c fc       	rol	r12
8000b5d2:	fc 1e ff e0 	movh	lr,0xffe0
8000b5d6:	58 0a       	cp.w	r10,0
8000b5d8:	fc 0b 13 00 	cpc	r11,lr
8000b5dc:	e0 8b 00 1d 	brhi	8000b616 <__avr32_f64_cmp_ge+0x52>
8000b5e0:	58 08       	cp.w	r8,0
8000b5e2:	fc 09 13 00 	cpc	r9,lr
8000b5e6:	e0 8b 00 18 	brhi	8000b616 <__avr32_f64_cmp_ge+0x52>
8000b5ea:	58 0b       	cp.w	r11,0
8000b5ec:	f5 ba 00 00 	subfeq	r10,0
8000b5f0:	c1 50       	breq	8000b61a <__avr32_f64_cmp_ge+0x56>
8000b5f2:	1b 07       	ld.w	r7,sp++
8000b5f4:	1b 0e       	ld.w	lr,sp++
8000b5f6:	58 3c       	cp.w	r12,3
8000b5f8:	c0 a0       	breq	8000b60c <__avr32_f64_cmp_ge+0x48>
8000b5fa:	58 1c       	cp.w	r12,1
8000b5fc:	c0 33       	brcs	8000b602 <__avr32_f64_cmp_ge+0x3e>
8000b5fe:	5e 0f       	reteq	1
8000b600:	5e 1d       	retne	0
8000b602:	10 3a       	cp.w	r10,r8
8000b604:	f2 0b 13 00 	cpc	r11,r9
8000b608:	5e 2f       	reths	1
8000b60a:	5e 3d       	retlo	0
8000b60c:	14 38       	cp.w	r8,r10
8000b60e:	f6 09 13 00 	cpc	r9,r11
8000b612:	5e 2f       	reths	1
8000b614:	5e 3d       	retlo	0
8000b616:	1b 07       	ld.w	r7,sp++
8000b618:	d8 0a       	popm	pc,r12=0
8000b61a:	58 17       	cp.w	r7,1
8000b61c:	5f 0c       	sreq	r12
8000b61e:	58 09       	cp.w	r9,0
8000b620:	f5 b8 00 00 	subfeq	r8,0
8000b624:	1b 07       	ld.w	r7,sp++
8000b626:	1b 0e       	ld.w	lr,sp++
8000b628:	5e 0f       	reteq	1
8000b62a:	5e fc       	retal	r12

8000b62c <__avr32_f64_cmp_lt>:
8000b62c:	1a de       	st.w	--sp,lr
8000b62e:	1a d7       	st.w	--sp,r7
8000b630:	a1 7b       	lsl	r11,0x1
8000b632:	5f 3c       	srlo	r12
8000b634:	a1 79       	lsl	r9,0x1
8000b636:	5f 37       	srlo	r7
8000b638:	5c fc       	rol	r12
8000b63a:	fc 1e ff e0 	movh	lr,0xffe0
8000b63e:	58 0a       	cp.w	r10,0
8000b640:	fc 0b 13 00 	cpc	r11,lr
8000b644:	e0 8b 00 1d 	brhi	8000b67e <__avr32_f64_cmp_lt+0x52>
8000b648:	58 08       	cp.w	r8,0
8000b64a:	fc 09 13 00 	cpc	r9,lr
8000b64e:	e0 8b 00 18 	brhi	8000b67e <__avr32_f64_cmp_lt+0x52>
8000b652:	58 0b       	cp.w	r11,0
8000b654:	f5 ba 00 00 	subfeq	r10,0
8000b658:	c1 50       	breq	8000b682 <__avr32_f64_cmp_lt+0x56>
8000b65a:	1b 07       	ld.w	r7,sp++
8000b65c:	1b 0e       	ld.w	lr,sp++
8000b65e:	58 3c       	cp.w	r12,3
8000b660:	c0 a0       	breq	8000b674 <__avr32_f64_cmp_lt+0x48>
8000b662:	58 1c       	cp.w	r12,1
8000b664:	c0 33       	brcs	8000b66a <__avr32_f64_cmp_lt+0x3e>
8000b666:	5e 0d       	reteq	0
8000b668:	5e 1f       	retne	1
8000b66a:	10 3a       	cp.w	r10,r8
8000b66c:	f2 0b 13 00 	cpc	r11,r9
8000b670:	5e 2d       	reths	0
8000b672:	5e 3f       	retlo	1
8000b674:	14 38       	cp.w	r8,r10
8000b676:	f6 09 13 00 	cpc	r9,r11
8000b67a:	5e 2d       	reths	0
8000b67c:	5e 3f       	retlo	1
8000b67e:	1b 07       	ld.w	r7,sp++
8000b680:	d8 0a       	popm	pc,r12=0
8000b682:	58 17       	cp.w	r7,1
8000b684:	5f 1c       	srne	r12
8000b686:	58 09       	cp.w	r9,0
8000b688:	f5 b8 00 00 	subfeq	r8,0
8000b68c:	1b 07       	ld.w	r7,sp++
8000b68e:	1b 0e       	ld.w	lr,sp++
8000b690:	5e 0d       	reteq	0
8000b692:	5e fc       	retal	r12

8000b694 <__avr32_f64_div>:
8000b694:	eb cd 40 ff 	pushm	r0-r7,lr
8000b698:	f7 e9 20 0e 	eor	lr,r11,r9
8000b69c:	f6 07 16 14 	lsr	r7,r11,0x14
8000b6a0:	a9 7b       	lsl	r11,0x9
8000b6a2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b6a6:	a9 7a       	lsl	r10,0x9
8000b6a8:	bd bb       	sbr	r11,0x1d
8000b6aa:	e4 1b 3f ff 	andh	r11,0x3fff
8000b6ae:	ab d7       	cbr	r7,0xb
8000b6b0:	e0 80 00 cc 	breq	8000b848 <__avr32_f64_div_round_subnormal+0x54>
8000b6b4:	e0 47 07 ff 	cp.w	r7,2047
8000b6b8:	e0 84 00 b5 	brge	8000b822 <__avr32_f64_div_round_subnormal+0x2e>
8000b6bc:	f2 06 16 14 	lsr	r6,r9,0x14
8000b6c0:	a9 79       	lsl	r9,0x9
8000b6c2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b6c6:	a9 78       	lsl	r8,0x9
8000b6c8:	bd b9       	sbr	r9,0x1d
8000b6ca:	e4 19 3f ff 	andh	r9,0x3fff
8000b6ce:	ab d6       	cbr	r6,0xb
8000b6d0:	e0 80 00 e2 	breq	8000b894 <__avr32_f64_div_round_subnormal+0xa0>
8000b6d4:	e0 46 07 ff 	cp.w	r6,2047
8000b6d8:	e0 84 00 b2 	brge	8000b83c <__avr32_f64_div_round_subnormal+0x48>
8000b6dc:	0c 17       	sub	r7,r6
8000b6de:	fe 37 fc 01 	sub	r7,-1023
8000b6e2:	fc 1c 80 00 	movh	r12,0x8000
8000b6e6:	f8 03 16 01 	lsr	r3,r12,0x1
8000b6ea:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b6ee:	5c d4       	com	r4
8000b6f0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b6f4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6f8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b6fc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b700:	ea 03 15 02 	lsl	r3,r5,0x2
8000b704:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b708:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b70c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b710:	ea 03 15 02 	lsl	r3,r5,0x2
8000b714:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b718:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b71c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b720:	ea 03 15 02 	lsl	r3,r5,0x2
8000b724:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b728:	e4 09 07 40 	macu.d	r0,r2,r9
8000b72c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b730:	02 04       	add	r4,r1
8000b732:	5c 05       	acr	r5
8000b734:	a3 65       	lsl	r5,0x2
8000b736:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b73a:	a3 64       	lsl	r4,0x2
8000b73c:	5c 34       	neg	r4
8000b73e:	f8 05 01 45 	sbc	r5,r12,r5
8000b742:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b746:	e4 05 07 40 	macu.d	r0,r2,r5
8000b74a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b74e:	02 04       	add	r4,r1
8000b750:	5c 05       	acr	r5
8000b752:	ea 03 15 02 	lsl	r3,r5,0x2
8000b756:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b75a:	e8 02 15 02 	lsl	r2,r4,0x2
8000b75e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b762:	e4 09 07 40 	macu.d	r0,r2,r9
8000b766:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b76a:	02 04       	add	r4,r1
8000b76c:	5c 05       	acr	r5
8000b76e:	a3 65       	lsl	r5,0x2
8000b770:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b774:	a3 64       	lsl	r4,0x2
8000b776:	5c 34       	neg	r4
8000b778:	f8 05 01 45 	sbc	r5,r12,r5
8000b77c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b780:	e4 05 07 40 	macu.d	r0,r2,r5
8000b784:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b788:	02 04       	add	r4,r1
8000b78a:	5c 05       	acr	r5
8000b78c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b790:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b794:	e8 02 15 02 	lsl	r2,r4,0x2
8000b798:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b79c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b7a0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b7a4:	02 02       	add	r2,r1
8000b7a6:	5c 03       	acr	r3
8000b7a8:	ed b3 00 1c 	bld	r3,0x1c
8000b7ac:	c0 90       	breq	8000b7be <__avr32_f64_div+0x12a>
8000b7ae:	a1 72       	lsl	r2,0x1
8000b7b0:	5c f3       	rol	r3
8000b7b2:	20 17       	sub	r7,1
8000b7b4:	a3 9a       	lsr	r10,0x3
8000b7b6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b7ba:	a3 9b       	lsr	r11,0x3
8000b7bc:	c0 58       	rjmp	8000b7c6 <__avr32_f64_div+0x132>
8000b7be:	a5 8a       	lsr	r10,0x4
8000b7c0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b7c4:	a5 8b       	lsr	r11,0x4
8000b7c6:	58 07       	cp.w	r7,0
8000b7c8:	e0 8a 00 8b 	brle	8000b8de <__avr32_f64_div_res_subnormal>
8000b7cc:	e0 12 ff 00 	andl	r2,0xff00
8000b7d0:	e8 12 00 80 	orl	r2,0x80
8000b7d4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b7d8:	e4 09 07 40 	macu.d	r0,r2,r9
8000b7dc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b7e0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b7e4:	00 05       	add	r5,r0
8000b7e6:	f0 01 00 48 	adc	r8,r8,r1
8000b7ea:	5c 09       	acr	r9
8000b7ec:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b7f0:	58 04       	cp.w	r4,0
8000b7f2:	5c 25       	cpc	r5

8000b7f4 <__avr32_f64_div_round_subnormal>:
8000b7f4:	f4 08 13 00 	cpc	r8,r10
8000b7f8:	f6 09 13 00 	cpc	r9,r11
8000b7fc:	5f 36       	srlo	r6
8000b7fe:	f8 06 17 00 	moveq	r6,r12
8000b802:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b806:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b80a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b80e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b812:	ed be 00 1f 	bld	lr,0x1f
8000b816:	ef bb 00 1f 	bst	r11,0x1f
8000b81a:	0c 0a       	add	r10,r6
8000b81c:	5c 0b       	acr	r11
8000b81e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b822:	e4 1b 00 0f 	andh	r11,0xf
8000b826:	14 4b       	or	r11,r10
8000b828:	e0 81 00 a7 	brne	8000b976 <__avr32_f64_div_res_subnormal+0x98>
8000b82c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b830:	ab d6       	cbr	r6,0xb
8000b832:	e0 46 07 ff 	cp.w	r6,2047
8000b836:	e0 81 00 a4 	brne	8000b97e <__avr32_f64_div_res_subnormal+0xa0>
8000b83a:	c9 e8       	rjmp	8000b976 <__avr32_f64_div_res_subnormal+0x98>
8000b83c:	e4 19 00 0f 	andh	r9,0xf
8000b840:	10 49       	or	r9,r8
8000b842:	e0 81 00 9a 	brne	8000b976 <__avr32_f64_div_res_subnormal+0x98>
8000b846:	c9 28       	rjmp	8000b96a <__avr32_f64_div_res_subnormal+0x8c>
8000b848:	a3 7b       	lsl	r11,0x3
8000b84a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b84e:	a3 7a       	lsl	r10,0x3
8000b850:	f5 eb 10 04 	or	r4,r10,r11
8000b854:	e0 80 00 a0 	breq	8000b994 <__avr32_f64_div_op1_zero>
8000b858:	f6 04 12 00 	clz	r4,r11
8000b85c:	c1 70       	breq	8000b88a <__avr32_f64_div_round_subnormal+0x96>
8000b85e:	c0 c3       	brcs	8000b876 <__avr32_f64_div_round_subnormal+0x82>
8000b860:	e8 05 11 20 	rsub	r5,r4,32
8000b864:	f6 04 09 4b 	lsl	r11,r11,r4
8000b868:	f4 05 0a 45 	lsr	r5,r10,r5
8000b86c:	0a 4b       	or	r11,r5
8000b86e:	f4 04 09 4a 	lsl	r10,r10,r4
8000b872:	08 17       	sub	r7,r4
8000b874:	c0 b8       	rjmp	8000b88a <__avr32_f64_div_round_subnormal+0x96>
8000b876:	f4 04 12 00 	clz	r4,r10
8000b87a:	f9 b4 03 00 	movlo	r4,0
8000b87e:	f7 b4 02 e0 	subhs	r4,-32
8000b882:	f4 04 09 4b 	lsl	r11,r10,r4
8000b886:	30 0a       	mov	r10,0
8000b888:	08 17       	sub	r7,r4
8000b88a:	a3 8a       	lsr	r10,0x2
8000b88c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b890:	a3 8b       	lsr	r11,0x2
8000b892:	c1 1b       	rjmp	8000b6b4 <__avr32_f64_div+0x20>
8000b894:	a3 79       	lsl	r9,0x3
8000b896:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b89a:	a3 78       	lsl	r8,0x3
8000b89c:	f3 e8 10 04 	or	r4,r9,r8
8000b8a0:	c6 f0       	breq	8000b97e <__avr32_f64_div_res_subnormal+0xa0>
8000b8a2:	f2 04 12 00 	clz	r4,r9
8000b8a6:	c1 70       	breq	8000b8d4 <__avr32_f64_div_round_subnormal+0xe0>
8000b8a8:	c0 c3       	brcs	8000b8c0 <__avr32_f64_div_round_subnormal+0xcc>
8000b8aa:	e8 05 11 20 	rsub	r5,r4,32
8000b8ae:	f2 04 09 49 	lsl	r9,r9,r4
8000b8b2:	f0 05 0a 45 	lsr	r5,r8,r5
8000b8b6:	0a 49       	or	r9,r5
8000b8b8:	f0 04 09 48 	lsl	r8,r8,r4
8000b8bc:	08 16       	sub	r6,r4
8000b8be:	c0 b8       	rjmp	8000b8d4 <__avr32_f64_div_round_subnormal+0xe0>
8000b8c0:	f0 04 12 00 	clz	r4,r8
8000b8c4:	f9 b4 03 00 	movlo	r4,0
8000b8c8:	f7 b4 02 e0 	subhs	r4,-32
8000b8cc:	f0 04 09 49 	lsl	r9,r8,r4
8000b8d0:	30 08       	mov	r8,0
8000b8d2:	08 16       	sub	r6,r4
8000b8d4:	a3 88       	lsr	r8,0x2
8000b8d6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b8da:	a3 89       	lsr	r9,0x2
8000b8dc:	cf ca       	rjmp	8000b6d4 <__avr32_f64_div+0x40>

8000b8de <__avr32_f64_div_res_subnormal>:
8000b8de:	5c 37       	neg	r7
8000b8e0:	2f f7       	sub	r7,-1
8000b8e2:	f1 b7 04 c0 	satu	r7,0x6
8000b8e6:	e0 47 00 20 	cp.w	r7,32
8000b8ea:	c1 54       	brge	8000b914 <__avr32_f64_div_res_subnormal+0x36>
8000b8ec:	ee 06 11 20 	rsub	r6,r7,32
8000b8f0:	e4 07 0a 42 	lsr	r2,r2,r7
8000b8f4:	e6 06 09 4c 	lsl	r12,r3,r6
8000b8f8:	18 42       	or	r2,r12
8000b8fa:	e6 07 0a 43 	lsr	r3,r3,r7
8000b8fe:	f4 06 09 41 	lsl	r1,r10,r6
8000b902:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b906:	f6 06 09 4c 	lsl	r12,r11,r6
8000b90a:	18 4a       	or	r10,r12
8000b90c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b910:	30 00       	mov	r0,0
8000b912:	c1 58       	rjmp	8000b93c <__avr32_f64_div_res_subnormal+0x5e>
8000b914:	ee 06 11 20 	rsub	r6,r7,32
8000b918:	f9 b0 00 00 	moveq	r0,0
8000b91c:	f9 bc 00 00 	moveq	r12,0
8000b920:	c0 50       	breq	8000b92a <__avr32_f64_div_res_subnormal+0x4c>
8000b922:	f4 06 09 40 	lsl	r0,r10,r6
8000b926:	f6 06 09 4c 	lsl	r12,r11,r6
8000b92a:	e6 07 0a 42 	lsr	r2,r3,r7
8000b92e:	30 03       	mov	r3,0
8000b930:	f4 07 0a 41 	lsr	r1,r10,r7
8000b934:	18 41       	or	r1,r12
8000b936:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b93a:	30 0b       	mov	r11,0
8000b93c:	e0 12 ff 00 	andl	r2,0xff00
8000b940:	e8 12 00 80 	orl	r2,0x80
8000b944:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b948:	e4 09 07 46 	macu.d	r6,r2,r9
8000b94c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b950:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b954:	0c 05       	add	r5,r6
8000b956:	f0 07 00 48 	adc	r8,r8,r7
8000b95a:	5c 09       	acr	r9
8000b95c:	30 07       	mov	r7,0
8000b95e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b962:	00 34       	cp.w	r4,r0
8000b964:	e2 05 13 00 	cpc	r5,r1
8000b968:	c4 6b       	rjmp	8000b7f4 <__avr32_f64_div_round_subnormal>
8000b96a:	1c 9b       	mov	r11,lr
8000b96c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b970:	30 0a       	mov	r10,0
8000b972:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b976:	3f fb       	mov	r11,-1
8000b978:	30 0a       	mov	r10,0
8000b97a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b97e:	f5 eb 10 04 	or	r4,r10,r11
8000b982:	c0 90       	breq	8000b994 <__avr32_f64_div_op1_zero>
8000b984:	1c 9b       	mov	r11,lr
8000b986:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b98a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b98e:	30 0a       	mov	r10,0
8000b990:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b994 <__avr32_f64_div_op1_zero>:
8000b994:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b998:	ce f0       	breq	8000b976 <__avr32_f64_div_res_subnormal+0x98>
8000b99a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b99e:	e0 44 07 ff 	cp.w	r4,2047
8000b9a2:	ce 41       	brne	8000b96a <__avr32_f64_div_res_subnormal+0x8c>
8000b9a4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b9a8:	ce 10       	breq	8000b96a <__avr32_f64_div_res_subnormal+0x8c>
8000b9aa:	ce 6b       	rjmp	8000b976 <__avr32_f64_div_res_subnormal+0x98>

8000b9ac <__avr32_udiv64>:
8000b9ac:	d4 31       	pushm	r0-r7,lr
8000b9ae:	1a 97       	mov	r7,sp
8000b9b0:	20 3d       	sub	sp,12
8000b9b2:	10 9c       	mov	r12,r8
8000b9b4:	12 9e       	mov	lr,r9
8000b9b6:	14 93       	mov	r3,r10
8000b9b8:	58 09       	cp.w	r9,0
8000b9ba:	e0 81 00 bd 	brne	8000bb34 <__avr32_udiv64+0x188>
8000b9be:	16 38       	cp.w	r8,r11
8000b9c0:	e0 88 00 40 	brls	8000ba40 <__avr32_udiv64+0x94>
8000b9c4:	f0 08 12 00 	clz	r8,r8
8000b9c8:	c0 d0       	breq	8000b9e2 <__avr32_udiv64+0x36>
8000b9ca:	f6 08 09 4b 	lsl	r11,r11,r8
8000b9ce:	f0 09 11 20 	rsub	r9,r8,32
8000b9d2:	f8 08 09 4c 	lsl	r12,r12,r8
8000b9d6:	f4 09 0a 49 	lsr	r9,r10,r9
8000b9da:	f4 08 09 43 	lsl	r3,r10,r8
8000b9de:	f3 eb 10 0b 	or	r11,r9,r11
8000b9e2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b9e6:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b9ea:	f6 0e 0d 00 	divu	r0,r11,lr
8000b9ee:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b9f2:	00 99       	mov	r9,r0
8000b9f4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b9f8:	e0 0a 02 48 	mul	r8,r0,r10
8000b9fc:	10 3b       	cp.w	r11,r8
8000b9fe:	c0 a2       	brcc	8000ba12 <__avr32_udiv64+0x66>
8000ba00:	20 19       	sub	r9,1
8000ba02:	18 0b       	add	r11,r12
8000ba04:	18 3b       	cp.w	r11,r12
8000ba06:	c0 63       	brcs	8000ba12 <__avr32_udiv64+0x66>
8000ba08:	10 3b       	cp.w	r11,r8
8000ba0a:	f7 b9 03 01 	sublo	r9,1
8000ba0e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba12:	f6 08 01 01 	sub	r1,r11,r8
8000ba16:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ba1a:	e2 0e 0d 00 	divu	r0,r1,lr
8000ba1e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ba22:	00 98       	mov	r8,r0
8000ba24:	e0 0a 02 4a 	mul	r10,r0,r10
8000ba28:	14 33       	cp.w	r3,r10
8000ba2a:	c0 82       	brcc	8000ba3a <__avr32_udiv64+0x8e>
8000ba2c:	20 18       	sub	r8,1
8000ba2e:	18 03       	add	r3,r12
8000ba30:	18 33       	cp.w	r3,r12
8000ba32:	c0 43       	brcs	8000ba3a <__avr32_udiv64+0x8e>
8000ba34:	14 33       	cp.w	r3,r10
8000ba36:	f7 b8 03 01 	sublo	r8,1
8000ba3a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000ba3e:	cd f8       	rjmp	8000bbfc <__avr32_udiv64+0x250>
8000ba40:	58 08       	cp.w	r8,0
8000ba42:	c0 51       	brne	8000ba4c <__avr32_udiv64+0xa0>
8000ba44:	30 19       	mov	r9,1
8000ba46:	f2 08 0d 08 	divu	r8,r9,r8
8000ba4a:	10 9c       	mov	r12,r8
8000ba4c:	f8 06 12 00 	clz	r6,r12
8000ba50:	c0 41       	brne	8000ba58 <__avr32_udiv64+0xac>
8000ba52:	18 1b       	sub	r11,r12
8000ba54:	30 19       	mov	r9,1
8000ba56:	c4 08       	rjmp	8000bad6 <__avr32_udiv64+0x12a>
8000ba58:	ec 01 11 20 	rsub	r1,r6,32
8000ba5c:	f4 01 0a 49 	lsr	r9,r10,r1
8000ba60:	f8 06 09 4c 	lsl	r12,r12,r6
8000ba64:	f6 06 09 48 	lsl	r8,r11,r6
8000ba68:	f6 01 0a 41 	lsr	r1,r11,r1
8000ba6c:	f3 e8 10 08 	or	r8,r9,r8
8000ba70:	f8 03 16 10 	lsr	r3,r12,0x10
8000ba74:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ba78:	e2 03 0d 00 	divu	r0,r1,r3
8000ba7c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ba80:	00 9e       	mov	lr,r0
8000ba82:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba86:	e0 05 02 49 	mul	r9,r0,r5
8000ba8a:	12 3b       	cp.w	r11,r9
8000ba8c:	c0 a2       	brcc	8000baa0 <__avr32_udiv64+0xf4>
8000ba8e:	20 1e       	sub	lr,1
8000ba90:	18 0b       	add	r11,r12
8000ba92:	18 3b       	cp.w	r11,r12
8000ba94:	c0 63       	brcs	8000baa0 <__avr32_udiv64+0xf4>
8000ba96:	12 3b       	cp.w	r11,r9
8000ba98:	f7 be 03 01 	sublo	lr,1
8000ba9c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000baa0:	12 1b       	sub	r11,r9
8000baa2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000baa6:	f6 03 0d 02 	divu	r2,r11,r3
8000baaa:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000baae:	04 99       	mov	r9,r2
8000bab0:	e4 05 02 4b 	mul	r11,r2,r5
8000bab4:	16 38       	cp.w	r8,r11
8000bab6:	c0 a2       	brcc	8000baca <__avr32_udiv64+0x11e>
8000bab8:	20 19       	sub	r9,1
8000baba:	18 08       	add	r8,r12
8000babc:	18 38       	cp.w	r8,r12
8000babe:	c0 63       	brcs	8000baca <__avr32_udiv64+0x11e>
8000bac0:	16 38       	cp.w	r8,r11
8000bac2:	f7 b9 03 01 	sublo	r9,1
8000bac6:	f1 dc e3 08 	addcs	r8,r8,r12
8000baca:	f4 06 09 43 	lsl	r3,r10,r6
8000bace:	f0 0b 01 0b 	sub	r11,r8,r11
8000bad2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bad6:	f8 06 16 10 	lsr	r6,r12,0x10
8000bada:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bade:	f6 06 0d 00 	divu	r0,r11,r6
8000bae2:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bae6:	00 9a       	mov	r10,r0
8000bae8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000baec:	e0 0e 02 48 	mul	r8,r0,lr
8000baf0:	10 3b       	cp.w	r11,r8
8000baf2:	c0 a2       	brcc	8000bb06 <__avr32_udiv64+0x15a>
8000baf4:	20 1a       	sub	r10,1
8000baf6:	18 0b       	add	r11,r12
8000baf8:	18 3b       	cp.w	r11,r12
8000bafa:	c0 63       	brcs	8000bb06 <__avr32_udiv64+0x15a>
8000bafc:	10 3b       	cp.w	r11,r8
8000bafe:	f7 ba 03 01 	sublo	r10,1
8000bb02:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb06:	f6 08 01 01 	sub	r1,r11,r8
8000bb0a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bb0e:	e2 06 0d 00 	divu	r0,r1,r6
8000bb12:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bb16:	00 98       	mov	r8,r0
8000bb18:	e0 0e 02 4b 	mul	r11,r0,lr
8000bb1c:	16 33       	cp.w	r3,r11
8000bb1e:	c0 82       	brcc	8000bb2e <__avr32_udiv64+0x182>
8000bb20:	20 18       	sub	r8,1
8000bb22:	18 03       	add	r3,r12
8000bb24:	18 33       	cp.w	r3,r12
8000bb26:	c0 43       	brcs	8000bb2e <__avr32_udiv64+0x182>
8000bb28:	16 33       	cp.w	r3,r11
8000bb2a:	f7 b8 03 01 	sublo	r8,1
8000bb2e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bb32:	c6 98       	rjmp	8000bc04 <__avr32_udiv64+0x258>
8000bb34:	16 39       	cp.w	r9,r11
8000bb36:	e0 8b 00 65 	brhi	8000bc00 <__avr32_udiv64+0x254>
8000bb3a:	f2 09 12 00 	clz	r9,r9
8000bb3e:	c0 b1       	brne	8000bb54 <__avr32_udiv64+0x1a8>
8000bb40:	10 3a       	cp.w	r10,r8
8000bb42:	5f 2a       	srhs	r10
8000bb44:	1c 3b       	cp.w	r11,lr
8000bb46:	5f b8       	srhi	r8
8000bb48:	10 4a       	or	r10,r8
8000bb4a:	f2 0a 18 00 	cp.b	r10,r9
8000bb4e:	c5 90       	breq	8000bc00 <__avr32_udiv64+0x254>
8000bb50:	30 18       	mov	r8,1
8000bb52:	c5 98       	rjmp	8000bc04 <__avr32_udiv64+0x258>
8000bb54:	f0 09 09 46 	lsl	r6,r8,r9
8000bb58:	f2 03 11 20 	rsub	r3,r9,32
8000bb5c:	fc 09 09 4e 	lsl	lr,lr,r9
8000bb60:	f0 03 0a 48 	lsr	r8,r8,r3
8000bb64:	f6 09 09 4c 	lsl	r12,r11,r9
8000bb68:	f4 03 0a 42 	lsr	r2,r10,r3
8000bb6c:	ef 46 ff f4 	st.w	r7[-12],r6
8000bb70:	f6 03 0a 43 	lsr	r3,r11,r3
8000bb74:	18 42       	or	r2,r12
8000bb76:	f1 ee 10 0c 	or	r12,r8,lr
8000bb7a:	f8 01 16 10 	lsr	r1,r12,0x10
8000bb7e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bb82:	e6 01 0d 04 	divu	r4,r3,r1
8000bb86:	e4 03 16 10 	lsr	r3,r2,0x10
8000bb8a:	08 9e       	mov	lr,r4
8000bb8c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bb90:	e8 06 02 48 	mul	r8,r4,r6
8000bb94:	10 33       	cp.w	r3,r8
8000bb96:	c0 a2       	brcc	8000bbaa <__avr32_udiv64+0x1fe>
8000bb98:	20 1e       	sub	lr,1
8000bb9a:	18 03       	add	r3,r12
8000bb9c:	18 33       	cp.w	r3,r12
8000bb9e:	c0 63       	brcs	8000bbaa <__avr32_udiv64+0x1fe>
8000bba0:	10 33       	cp.w	r3,r8
8000bba2:	f7 be 03 01 	sublo	lr,1
8000bba6:	e7 dc e3 03 	addcs	r3,r3,r12
8000bbaa:	10 13       	sub	r3,r8
8000bbac:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bbb0:	e6 01 0d 00 	divu	r0,r3,r1
8000bbb4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bbb8:	00 98       	mov	r8,r0
8000bbba:	e0 06 02 46 	mul	r6,r0,r6
8000bbbe:	0c 3b       	cp.w	r11,r6
8000bbc0:	c0 a2       	brcc	8000bbd4 <__avr32_udiv64+0x228>
8000bbc2:	20 18       	sub	r8,1
8000bbc4:	18 0b       	add	r11,r12
8000bbc6:	18 3b       	cp.w	r11,r12
8000bbc8:	c0 63       	brcs	8000bbd4 <__avr32_udiv64+0x228>
8000bbca:	0c 3b       	cp.w	r11,r6
8000bbcc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bbd0:	f7 b8 03 01 	sublo	r8,1
8000bbd4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bbd8:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bbdc:	0c 1b       	sub	r11,r6
8000bbde:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bbe2:	06 95       	mov	r5,r3
8000bbe4:	16 35       	cp.w	r5,r11
8000bbe6:	e0 8b 00 0a 	brhi	8000bbfa <__avr32_udiv64+0x24e>
8000bbea:	5f 0b       	sreq	r11
8000bbec:	f4 09 09 49 	lsl	r9,r10,r9
8000bbf0:	12 32       	cp.w	r2,r9
8000bbf2:	5f b9       	srhi	r9
8000bbf4:	f7 e9 00 09 	and	r9,r11,r9
8000bbf8:	c0 60       	breq	8000bc04 <__avr32_udiv64+0x258>
8000bbfa:	20 18       	sub	r8,1
8000bbfc:	30 09       	mov	r9,0
8000bbfe:	c0 38       	rjmp	8000bc04 <__avr32_udiv64+0x258>
8000bc00:	30 09       	mov	r9,0
8000bc02:	12 98       	mov	r8,r9
8000bc04:	10 9a       	mov	r10,r8
8000bc06:	12 93       	mov	r3,r9
8000bc08:	10 92       	mov	r2,r8
8000bc0a:	12 9b       	mov	r11,r9
8000bc0c:	2f dd       	sub	sp,-12
8000bc0e:	d8 32       	popm	r0-r7,pc

8000bc10 <__avr32_umod64>:
8000bc10:	d4 31       	pushm	r0-r7,lr
8000bc12:	1a 97       	mov	r7,sp
8000bc14:	20 3d       	sub	sp,12
8000bc16:	10 9c       	mov	r12,r8
8000bc18:	12 95       	mov	r5,r9
8000bc1a:	14 9e       	mov	lr,r10
8000bc1c:	16 91       	mov	r1,r11
8000bc1e:	16 96       	mov	r6,r11
8000bc20:	58 09       	cp.w	r9,0
8000bc22:	e0 81 00 81 	brne	8000bd24 <__avr32_umod64+0x114>
8000bc26:	16 38       	cp.w	r8,r11
8000bc28:	e0 88 00 12 	brls	8000bc4c <__avr32_umod64+0x3c>
8000bc2c:	f0 08 12 00 	clz	r8,r8
8000bc30:	c4 e0       	breq	8000bccc <__avr32_umod64+0xbc>
8000bc32:	f6 08 09 46 	lsl	r6,r11,r8
8000bc36:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc3a:	f0 0b 11 20 	rsub	r11,r8,32
8000bc3e:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc42:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bc46:	f7 e6 10 06 	or	r6,r11,r6
8000bc4a:	c4 18       	rjmp	8000bccc <__avr32_umod64+0xbc>
8000bc4c:	58 08       	cp.w	r8,0
8000bc4e:	c0 51       	brne	8000bc58 <__avr32_umod64+0x48>
8000bc50:	30 19       	mov	r9,1
8000bc52:	f2 08 0d 08 	divu	r8,r9,r8
8000bc56:	10 9c       	mov	r12,r8
8000bc58:	f8 08 12 00 	clz	r8,r12
8000bc5c:	c0 31       	brne	8000bc62 <__avr32_umod64+0x52>
8000bc5e:	18 16       	sub	r6,r12
8000bc60:	c3 68       	rjmp	8000bccc <__avr32_umod64+0xbc>
8000bc62:	f0 03 11 20 	rsub	r3,r8,32
8000bc66:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bc6a:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc6e:	ec 08 09 49 	lsl	r9,r6,r8
8000bc72:	ec 03 0a 43 	lsr	r3,r6,r3
8000bc76:	f7 e9 10 09 	or	r9,r11,r9
8000bc7a:	f8 05 16 10 	lsr	r5,r12,0x10
8000bc7e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bc82:	e6 05 0d 02 	divu	r2,r3,r5
8000bc86:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bc8a:	ec 02 02 4b 	mul	r11,r6,r2
8000bc8e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bc92:	16 3e       	cp.w	lr,r11
8000bc94:	c0 72       	brcc	8000bca2 <__avr32_umod64+0x92>
8000bc96:	18 0e       	add	lr,r12
8000bc98:	18 3e       	cp.w	lr,r12
8000bc9a:	c0 43       	brcs	8000bca2 <__avr32_umod64+0x92>
8000bc9c:	16 3e       	cp.w	lr,r11
8000bc9e:	fd dc e3 0e 	addcs	lr,lr,r12
8000bca2:	fc 0b 01 03 	sub	r3,lr,r11
8000bca6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bcaa:	e6 05 0d 02 	divu	r2,r3,r5
8000bcae:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bcb2:	a5 36       	mul	r6,r2
8000bcb4:	0c 39       	cp.w	r9,r6
8000bcb6:	c0 72       	brcc	8000bcc4 <__avr32_umod64+0xb4>
8000bcb8:	18 09       	add	r9,r12
8000bcba:	18 39       	cp.w	r9,r12
8000bcbc:	c0 43       	brcs	8000bcc4 <__avr32_umod64+0xb4>
8000bcbe:	0c 39       	cp.w	r9,r6
8000bcc0:	f3 dc e3 09 	addcs	r9,r9,r12
8000bcc4:	f2 06 01 06 	sub	r6,r9,r6
8000bcc8:	f4 08 09 4e 	lsl	lr,r10,r8
8000bccc:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bcd0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bcd4:	ec 0a 0d 02 	divu	r2,r6,r10
8000bcd8:	fc 09 16 10 	lsr	r9,lr,0x10
8000bcdc:	ea 02 02 4b 	mul	r11,r5,r2
8000bce0:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bce4:	16 39       	cp.w	r9,r11
8000bce6:	c0 72       	brcc	8000bcf4 <__avr32_umod64+0xe4>
8000bce8:	18 09       	add	r9,r12
8000bcea:	18 39       	cp.w	r9,r12
8000bcec:	c0 43       	brcs	8000bcf4 <__avr32_umod64+0xe4>
8000bcee:	16 39       	cp.w	r9,r11
8000bcf0:	f3 dc e3 09 	addcs	r9,r9,r12
8000bcf4:	f2 0b 01 0b 	sub	r11,r9,r11
8000bcf8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bcfc:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bd00:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bd04:	ea 0a 02 4a 	mul	r10,r5,r10
8000bd08:	14 3e       	cp.w	lr,r10
8000bd0a:	c0 72       	brcc	8000bd18 <__avr32_umod64+0x108>
8000bd0c:	18 0e       	add	lr,r12
8000bd0e:	18 3e       	cp.w	lr,r12
8000bd10:	c0 43       	brcs	8000bd18 <__avr32_umod64+0x108>
8000bd12:	14 3e       	cp.w	lr,r10
8000bd14:	fd dc e3 0e 	addcs	lr,lr,r12
8000bd18:	fc 0a 01 0a 	sub	r10,lr,r10
8000bd1c:	30 0b       	mov	r11,0
8000bd1e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bd22:	c7 b8       	rjmp	8000be18 <__avr32_umod64+0x208>
8000bd24:	16 39       	cp.w	r9,r11
8000bd26:	e0 8b 00 79 	brhi	8000be18 <__avr32_umod64+0x208>
8000bd2a:	f2 09 12 00 	clz	r9,r9
8000bd2e:	c1 21       	brne	8000bd52 <__avr32_umod64+0x142>
8000bd30:	10 3a       	cp.w	r10,r8
8000bd32:	5f 2b       	srhs	r11
8000bd34:	0a 31       	cp.w	r1,r5
8000bd36:	5f ba       	srhi	r10
8000bd38:	f7 ea 10 0a 	or	r10,r11,r10
8000bd3c:	f2 0a 18 00 	cp.b	r10,r9
8000bd40:	c0 60       	breq	8000bd4c <__avr32_umod64+0x13c>
8000bd42:	fc 08 01 0c 	sub	r12,lr,r8
8000bd46:	e2 05 01 46 	sbc	r6,r1,r5
8000bd4a:	18 9e       	mov	lr,r12
8000bd4c:	0c 9b       	mov	r11,r6
8000bd4e:	1c 9a       	mov	r10,lr
8000bd50:	c6 48       	rjmp	8000be18 <__avr32_umod64+0x208>
8000bd52:	ea 09 09 4c 	lsl	r12,r5,r9
8000bd56:	f2 06 11 20 	rsub	r6,r9,32
8000bd5a:	f6 09 09 4b 	lsl	r11,r11,r9
8000bd5e:	f0 09 09 42 	lsl	r2,r8,r9
8000bd62:	ef 46 ff f4 	st.w	r7[-12],r6
8000bd66:	f0 06 0a 48 	lsr	r8,r8,r6
8000bd6a:	18 48       	or	r8,r12
8000bd6c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bd70:	f4 09 09 43 	lsl	r3,r10,r9
8000bd74:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bd78:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bd7c:	16 4a       	or	r10,r11
8000bd7e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bd82:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd86:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bd8a:	08 91       	mov	r1,r4
8000bd8c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bd90:	e8 0e 02 46 	mul	r6,r4,lr
8000bd94:	0c 3c       	cp.w	r12,r6
8000bd96:	c0 a2       	brcc	8000bdaa <__avr32_umod64+0x19a>
8000bd98:	20 11       	sub	r1,1
8000bd9a:	10 0c       	add	r12,r8
8000bd9c:	10 3c       	cp.w	r12,r8
8000bd9e:	c0 63       	brcs	8000bdaa <__avr32_umod64+0x19a>
8000bda0:	0c 3c       	cp.w	r12,r6
8000bda2:	f7 b1 03 01 	sublo	r1,1
8000bda6:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bdaa:	0c 1c       	sub	r12,r6
8000bdac:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bdb0:	f8 0b 0d 04 	divu	r4,r12,r11
8000bdb4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bdb8:	08 96       	mov	r6,r4
8000bdba:	e8 0e 02 4e 	mul	lr,r4,lr
8000bdbe:	1c 3b       	cp.w	r11,lr
8000bdc0:	c0 a2       	brcc	8000bdd4 <__avr32_umod64+0x1c4>
8000bdc2:	20 16       	sub	r6,1
8000bdc4:	10 0b       	add	r11,r8
8000bdc6:	10 3b       	cp.w	r11,r8
8000bdc8:	c0 63       	brcs	8000bdd4 <__avr32_umod64+0x1c4>
8000bdca:	1c 3b       	cp.w	r11,lr
8000bdcc:	f7 b6 03 01 	sublo	r6,1
8000bdd0:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bdd4:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bdd8:	1c 1b       	sub	r11,lr
8000bdda:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bdde:	00 9e       	mov	lr,r0
8000bde0:	02 9c       	mov	r12,r1
8000bde2:	16 3c       	cp.w	r12,r11
8000bde4:	e0 8b 00 08 	brhi	8000bdf4 <__avr32_umod64+0x1e4>
8000bde8:	5f 06       	sreq	r6
8000bdea:	06 30       	cp.w	r0,r3
8000bdec:	5f ba       	srhi	r10
8000bdee:	ed ea 00 0a 	and	r10,r6,r10
8000bdf2:	c0 60       	breq	8000bdfe <__avr32_umod64+0x1ee>
8000bdf4:	fc 02 01 04 	sub	r4,lr,r2
8000bdf8:	f8 08 01 4c 	sbc	r12,r12,r8
8000bdfc:	08 9e       	mov	lr,r4
8000bdfe:	e6 0e 01 0a 	sub	r10,r3,lr
8000be02:	f6 0c 01 4c 	sbc	r12,r11,r12
8000be06:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000be0a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000be0e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be12:	f8 01 09 4c 	lsl	r12,r12,r1
8000be16:	18 4a       	or	r10,r12
8000be18:	2f dd       	sub	sp,-12
8000be1a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c000:	c0 08       	rjmp	8000c000 <_evba>
	...

8000c004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c004:	c0 08       	rjmp	8000c004 <_handle_TLB_Multiple_Hit>
	...

8000c008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c008:	c0 08       	rjmp	8000c008 <_handle_Bus_Error_Data_Fetch>
	...

8000c00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c00c:	c0 08       	rjmp	8000c00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c010:	c0 08       	rjmp	8000c010 <_handle_NMI>
	...

8000c014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c014:	c0 08       	rjmp	8000c014 <_handle_Instruction_Address>
	...

8000c018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c018:	c0 08       	rjmp	8000c018 <_handle_ITLB_Protection>
	...

8000c01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c01c:	c0 08       	rjmp	8000c01c <_handle_Breakpoint>
	...

8000c020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c020:	c0 08       	rjmp	8000c020 <_handle_Illegal_Opcode>
	...

8000c024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c024:	c0 08       	rjmp	8000c024 <_handle_Unimplemented_Instruction>
	...

8000c028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c028:	c0 08       	rjmp	8000c028 <_handle_Privilege_Violation>
	...

8000c02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c02c:	c0 08       	rjmp	8000c02c <_handle_Floating_Point>
	...

8000c030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c030:	c0 08       	rjmp	8000c030 <_handle_Coprocessor_Absent>
	...

8000c034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c034:	c0 08       	rjmp	8000c034 <_handle_Data_Address_Read>
	...

8000c038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c038:	c0 08       	rjmp	8000c038 <_handle_Data_Address_Write>
	...

8000c03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c03c:	c0 08       	rjmp	8000c03c <_handle_DTLB_Protection_Read>
	...

8000c040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c040:	c0 08       	rjmp	8000c040 <_handle_DTLB_Protection_Write>
	...

8000c044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c044:	c0 08       	rjmp	8000c044 <_handle_DTLB_Modified>
	...

8000c050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c050:	c0 08       	rjmp	8000c050 <_handle_ITLB_Miss>
	...

8000c060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c060:	c0 08       	rjmp	8000c060 <_handle_DTLB_Miss_Read>
	...

8000c070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c070:	c0 08       	rjmp	8000c070 <_handle_DTLB_Miss_Write>
	...

8000c100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c100:	fe cf 6f 98 	sub	pc,pc,28568

8000c104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c104:	30 0c       	mov	r12,0
8000c106:	fe b0 c3 97 	rcall	80004834 <_get_interrupt_handler>
8000c10a:	58 0c       	cp.w	r12,0
8000c10c:	f8 0f 17 10 	movne	pc,r12
8000c110:	d6 03       	rete

8000c112 <_int1>:
8000c112:	30 1c       	mov	r12,1
8000c114:	fe b0 c3 90 	rcall	80004834 <_get_interrupt_handler>
8000c118:	58 0c       	cp.w	r12,0
8000c11a:	f8 0f 17 10 	movne	pc,r12
8000c11e:	d6 03       	rete

8000c120 <_int2>:
8000c120:	30 2c       	mov	r12,2
8000c122:	fe b0 c3 89 	rcall	80004834 <_get_interrupt_handler>
8000c126:	58 0c       	cp.w	r12,0
8000c128:	f8 0f 17 10 	movne	pc,r12
8000c12c:	d6 03       	rete

8000c12e <_int3>:
8000c12e:	30 3c       	mov	r12,3
8000c130:	fe b0 c3 82 	rcall	80004834 <_get_interrupt_handler>
8000c134:	58 0c       	cp.w	r12,0
8000c136:	f8 0f 17 10 	movne	pc,r12
8000c13a:	d6 03       	rete

8000c13c <ipr_val>:
8000c13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1fc:	d7 03 d7 03                                         ....
