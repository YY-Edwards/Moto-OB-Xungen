
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000b538  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000d600  8000d600  0000da00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000014b8  8000d800  8000d800  0000dc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a44  00000004  8000ecb8  0000f404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00004998  00000a48  8000f6fc  0000fe48  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000fe48  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001750  00000000  00000000  0000fe78  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000037a6  00000000  00000000  000115c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002deef  00000000  00000000  00014d6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007765  00000000  00000000  00042c5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d9e5  00000000  00000000  0004a3c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003f98  00000000  00000000  00057da8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000817e  00000000  00000000  0005bd40  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000fb8c  00000000  00000000  00063ebe  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001808  00000000  00000000  00073a50  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf ba d0 	sub	pc,pc,-17712

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d b0       	ld.ub	r0,r6[0x3]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	44 8c       	lddsp	r12,sp[0x120]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	31 28       	mov	r8,18
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d8 00       	acall	0x80
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	74 70       	ld.w	r0,r10[0x1c]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 60       	and	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d8 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	78 34       	ld.w	r4,r12[0xc]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 55       	eor	r5,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d8 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	78 34       	ld.w	r4,r12[0xc]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 4b       	or	r11,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d8 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	78 34       	ld.w	r4,r12[0xc]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d8 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	78 34       	ld.w	r4,r12[0xc]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d8 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	78 34       	ld.w	r4,r12[0xc]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d8 70       	acall	0x87
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	78 34       	ld.w	r4,r12[0xc]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d8 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	78 34       	ld.w	r4,r12[0xc]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d8 a0       	acall	0x8a
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d8 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d8 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d8 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	d9 00       	acall	0x90
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	78 34       	ld.w	r4,r12[0xc]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	d9 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	d9 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	d9 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	78 34       	ld.w	r4,r12[0xc]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d9 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	d9 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d9 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d9 a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	d9 cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	d9 f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	da 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	da 40       	acall	0xa4

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	da 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	78 34       	ld.w	r4,r12[0xc]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d9 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	da 7c       	*unknown*

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	da 98       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	78 34       	ld.w	r4,r12[0xc]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	da a8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	da b4       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	da c0       	acall	0xac
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	da d0       	acall	0xad
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	da e0       	acall	0xae
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	da ec       	*unknown*

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	da f8       	*unknown*
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	78 34       	ld.w	r4,r12[0xc]
800023c0:	00 00       	add	r0,r0
800023c2:	0a 4d       	or	sp,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	db 10       	acall	0xb1
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	78 34       	ld.w	r4,r12[0xc]
80002404:	00 00       	add	r0,r0
80002406:	0a 4c       	or	r12,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	db 28       	*unknown*

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	db 3c       	*unknown*
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	78 34       	ld.w	r4,r12[0xc]
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	db 58       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	db 6c       	*unknown*
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	db 88       	*unknown*
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	db 98       	*unknown*

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	db b0       	acall	0xbb
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	78 34       	ld.w	r4,r12[0xc]
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	db c0       	acall	0xbc

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	db d4       	*unknown*
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	78 34       	ld.w	r4,r12[0xc]
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	db e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	dc 04       	*unknown*
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	dc 1c       	*unknown*

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 48       	or	r8,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	dc 34       	*unknown*
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	78 34       	ld.w	r4,r12[0xc]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	dc 44       	*unknown*

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 48       	or	r8,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	dc 50       	acall	0xc5
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	78 34       	ld.w	r4,r12[0xc]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	dc 60       	acall	0xc6

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	dc 6c       	*unknown*
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	78 34       	ld.w	r4,r12[0xc]
800025c4:	00 00       	add	r0,r0
800025c6:	0a 57       	eor	r7,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	dc 80       	acall	0xc8
800025cc:	00 00       	add	r0,r0
800025ce:	0a 4d       	or	sp,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	dc 94       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	78 34       	ld.w	r4,r12[0xc]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	dc a4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	dc b8       	*unknown*
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	dc cc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	dc e8       	*unknown*
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	dd 00       	acall	0xd0
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	dd 18       	*unknown*
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	dd 30       	acall	0xd3

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	dd 40       	acall	0xd4
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	78 34       	ld.w	r4,r12[0xc]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	dd 54       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	dd 68       	*unknown*
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	dd 80       	acall	0xd8

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	dd 9c       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	78 34       	ld.w	r4,r12[0xc]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	dd b0       	acall	0xdb
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	dd c4       	*unknown*
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	dd d8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	dd e4       	*unknown*

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	dd f0       	acall	0xdf
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	78 34       	ld.w	r4,r12[0xc]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	dd fc       	*unknown*

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 ed       	sub	sp,56
	U16  * data_ptr;
	U8 storage_buff[50];
	
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 56 	mcall	80002898 <app_cfg+0x15c>
80002744:	4d 68       	lddpc	r8,8000289c <app_cfg+0x160>
80002746:	91 0c       	st.w	r8[0x0],r12
	memset(storage_buff, 0x00, sizeof(storage_buff));
80002748:	33 2a       	mov	r10,50
8000274a:	30 0b       	mov	r11,0
8000274c:	1a 9c       	mov	r12,sp
8000274e:	f0 1f 00 55 	mcall	800028a0 <app_cfg+0x164>
		
	for(;;)
	{
		switch(OB_State)
80002752:	4d 57       	lddpc	r7,800028a4 <app_cfg+0x168>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
80002754:	4d 54       	lddpc	r4,800028a8 <app_cfg+0x16c>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
80002756:	30 90       	mov	r0,9
80002758:	32 01       	mov	r1,32
8000275a:	30 06       	mov	r6,0
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
8000275c:	4d 43       	lddpc	r3,800028ac <app_cfg+0x170>
8000275e:	fa c2 ff cc 	sub	r2,sp,-52
	xLastWakeTime = xTaskGetTickCount();
	memset(storage_buff, 0x00, sizeof(storage_buff));
		
	for(;;)
	{
		switch(OB_State)
80002762:	6e 08       	ld.w	r8,r7[0x0]
80002764:	58 28       	cp.w	r8,2
80002766:	c3 50       	breq	800027d0 <app_cfg+0x94>
80002768:	58 38       	cp.w	r8,3
8000276a:	c4 20       	breq	800027ee <app_cfg+0xb2>
8000276c:	58 08       	cp.w	r8,0
8000276e:	e0 81 00 8e 	brne	8000288a <app_cfg+0x14e>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002772:	4d 08       	lddpc	r8,800028b0 <app_cfg+0x174>
80002774:	70 08       	ld.w	r8,r8[0x0]
80002776:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000277a:	58 38       	cp.w	r8,3
8000277c:	c1 21       	brne	800027a0 <app_cfg+0x64>
8000277e:	4c e8       	lddpc	r8,800028b4 <app_cfg+0x178>
80002780:	11 88       	ld.ub	r8,r8[0x0]
80002782:	58 08       	cp.w	r8,0
80002784:	c0 e1       	brne	800027a0 <app_cfg+0x64>
				{
					connect_flag=1;
80002786:	30 19       	mov	r9,1
80002788:	4c b8       	lddpc	r8,800028b4 <app_cfg+0x178>
8000278a:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000278c:	30 cb       	mov	r11,12
8000278e:	30 1c       	mov	r12,1
80002790:	f0 1f 00 4a 	mcall	800028b8 <app_cfg+0x17c>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002794:	30 28       	mov	r8,2
80002796:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
80002798:	4c 9c       	lddpc	r12,800028bc <app_cfg+0x180>
8000279a:	f0 1f 00 4a 	mcall	800028c0 <app_cfg+0x184>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000279e:	c7 68       	rjmp	8000288a <app_cfg+0x14e>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
800027a0:	d7 03       	nop
					nop();
800027a2:	d7 03       	nop
					nop();
800027a4:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
800027a6:	4c 8c       	lddpc	r12,800028c4 <app_cfg+0x188>
800027a8:	f0 1f 00 46 	mcall	800028c0 <app_cfg+0x184>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
800027ac:	4c 78       	lddpc	r8,800028c8 <app_cfg+0x18c>
800027ae:	11 d5       	ld.ub	r5,r8[0x5]
800027b0:	11 cc       	ld.ub	r12,r8[0x4]
800027b2:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027b4:	11 aa       	ld.ub	r10,r8[0x2]
800027b6:	11 99       	ld.ub	r9,r8[0x1]
800027b8:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ba:	1a d5       	st.w	--sp,r5
800027bc:	1a dc       	st.w	--sp,r12
800027be:	1a db       	st.w	--sp,r11
800027c0:	1a da       	st.w	--sp,r10
800027c2:	1a d9       	st.w	--sp,r9
800027c4:	1a d8       	st.w	--sp,r8
800027c6:	4c 2c       	lddpc	r12,800028cc <app_cfg+0x190>
800027c8:	f0 1f 00 3e 	mcall	800028c0 <app_cfg+0x184>
800027cc:	2f ad       	sub	sp,-24
800027ce:	c5 e8       	rjmp	8000288a <app_cfg+0x14e>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027d0:	09 88       	ld.ub	r8,r4[0x0]
800027d2:	58 08       	cp.w	r8,0
800027d4:	c0 70       	breq	800027e2 <app_cfg+0xa6>
							
							OB_State = OB_WAITINGAPPTASK;
800027d6:	30 38       	mov	r8,3
800027d8:	8f 08       	st.w	r7[0x0],r8
							log("get time okay!\n");
800027da:	4b ec       	lddpc	r12,800028d0 <app_cfg+0x194>
800027dc:	f0 1f 00 39 	mcall	800028c0 <app_cfg+0x184>
800027e0:	c5 58       	rjmp	8000288a <app_cfg+0x14e>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027e2:	00 9a       	mov	r10,r0
800027e4:	02 9b       	mov	r11,r1
800027e6:	0c 9c       	mov	r12,r6
800027e8:	f0 1f 00 3b 	mcall	800028d4 <app_cfg+0x198>
800027ec:	c4 f8       	rjmp	8000288a <app_cfg+0x14e>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027ee:	66 0c       	ld.w	r12,r3[0x0]
800027f0:	0c 99       	mov	r9,r6
800027f2:	e0 6a 0f a0 	mov	r10,4000
800027f6:	04 9b       	mov	r11,r2
800027f8:	f0 1f 00 38 	mcall	800028d8 <app_cfg+0x19c>
800027fc:	58 1c       	cp.w	r12,1
800027fe:	c1 71       	brne	8000282c <app_cfg+0xf0>
					{
						if(data_ptr!=NULL){//Resend message
80002800:	40 d8       	lddsp	r8,sp[0x34]
80002802:	58 08       	cp.w	r8,0
80002804:	c1 40       	breq	8000282c <app_cfg+0xf0>
							
							log("receive...1\n");
80002806:	4b 6c       	lddpc	r12,800028dc <app_cfg+0x1a0>
80002808:	f0 1f 00 2e 	mcall	800028c0 <app_cfg+0x184>
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
8000280c:	30 1a       	mov	r10,1
8000280e:	02 9b       	mov	r11,r1
80002810:	40 dc       	lddsp	r12,sp[0x34]
80002812:	f0 1f 00 34 	mcall	800028e0 <app_cfg+0x1a4>
							log("receive...2\n");
80002816:	4b 4c       	lddpc	r12,800028e4 <app_cfg+0x1a8>
80002818:	f0 1f 00 2a 	mcall	800028c0 <app_cfg+0x184>
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
8000281c:	4b 38       	lddpc	r8,800028e8 <app_cfg+0x1ac>
8000281e:	70 0c       	ld.w	r12,r8[0x0]
80002820:	40 db       	lddsp	r11,sp[0x34]
80002822:	f0 1f 00 33 	mcall	800028ec <app_cfg+0x1b0>
							log("receive okay and save!\n");
80002826:	4b 3c       	lddpc	r12,800028f0 <app_cfg+0x1b4>
80002828:	f0 1f 00 26 	mcall	800028c0 <app_cfg+0x184>
							
						}
						
					}
					Current_total_message_count = xgflash_get_message_count();
8000282c:	f0 1f 00 32 	mcall	800028f4 <app_cfg+0x1b8>
80002830:	5c 8c       	casts.h	r12
80002832:	4b 28       	lddpc	r8,800028f8 <app_cfg+0x1bc>
80002834:	b0 0c       	st.h	r8[0x0],r12
					if(Current_total_message_count!=0)//有缓存，需重发
80002836:	58 0c       	cp.w	r12,0
80002838:	c2 50       	breq	80002882 <app_cfg+0x146>
					{
						log("Current_total_message_count: %d\n", Current_total_message_count);
8000283a:	5c 7c       	castu.h	r12
8000283c:	1a dc       	st.w	--sp,r12
8000283e:	4b 0c       	lddpc	r12,800028fc <app_cfg+0x1c0>
80002840:	f0 1f 00 20 	mcall	800028c0 <app_cfg+0x184>
						xgflash_get_message_data(Current_total_message_count, storage_buff, TRUE);//read out from flash and erase info
80002844:	fa c5 ff fc 	sub	r5,sp,-4
80002848:	30 1a       	mov	r10,1
8000284a:	0a 9b       	mov	r11,r5
8000284c:	4a b8       	lddpc	r8,800028f8 <app_cfg+0x1bc>
8000284e:	90 8c       	ld.uh	r12,r8[0x0]
80002850:	f0 1f 00 2c 	mcall	80002900 <app_cfg+0x1c4>
						xcmp_data_session_req(storage_buff, sizeof(Message_Protocol_t), DEST);//send buff-message to DEST
80002854:	00 9a       	mov	r10,r0
80002856:	02 9b       	mov	r11,r1
80002858:	0a 9c       	mov	r12,r5
8000285a:	f0 1f 00 1f 	mcall	800028d4 <app_cfg+0x198>
						memset(storage_buff, 0x00, sizeof(storage_buff));//reset buff
8000285e:	30 08       	mov	r8,0
80002860:	30 09       	mov	r9,0
80002862:	ea e9 00 00 	st.d	r5[0],r8
80002866:	fa e9 00 0c 	st.d	sp[12],r8
8000286a:	fa e9 00 14 	st.d	sp[20],r8
8000286e:	fa e9 00 1c 	st.d	sp[28],r8
80002872:	fa e9 00 24 	st.d	sp[36],r8
80002876:	fa e9 00 2c 	st.d	sp[44],r8
8000287a:	30 08       	mov	r8,0
8000287c:	fb 58 00 34 	st.h	sp[52],r8
80002880:	2f fd       	sub	sp,-4
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
80002882:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002884:	4a 0c       	lddpc	r12,80002904 <app_cfg+0x1c8>
80002886:	f0 1f 00 0f 	mcall	800028c0 <app_cfg+0x184>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000288a:	e0 6b 0f a0 	mov	r11,4000
8000288e:	48 4c       	lddpc	r12,8000289c <app_cfg+0x160>
80002890:	f0 1f 00 1e 	mcall	80002908 <app_cfg+0x1cc>
	}
80002894:	c6 7b       	rjmp	80002762 <app_cfg+0x26>
80002896:	00 00       	add	r0,r0
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	71 60       	ld.w	r0,r8[0x58]
8000289c:	00 00       	add	r0,r0
8000289e:	0a 5c       	eor	r12,r5
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	81 f8       	st.w	r0[0x3c],r8
800028a4:	00 00       	add	r0,r0
800028a6:	0a 50       	eor	r0,r5
800028a8:	00 00       	add	r0,r0
800028aa:	00 04       	add	r4,r0
800028ac:	00 00       	add	r0,r0
800028ae:	0b 78       	ld.ub	r8,--r5
800028b0:	00 00       	add	r0,r0
800028b2:	0d b0       	ld.ub	r0,r6[0x3]
800028b4:	00 00       	add	r0,r0
800028b6:	0a 56       	eor	r6,r5
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	46 18       	lddsp	r8,sp[0x184]
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	de 08       	*unknown*
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	78 34       	ld.w	r4,r12[0xc]
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	de 1c       	*unknown*
800028c8:	00 00       	add	r0,r0
800028ca:	0d b4       	ld.ub	r4,r6[0x3]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	de 2c       	*unknown*
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	de 58       	*unknown*
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	44 e0       	lddsp	r0,sp[0x138]
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	6a 48       	ld.w	r8,r5[0x10]
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	de 68       	*unknown*
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	5a 4c       	cp.w	r12,-28
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	de 78       	*unknown*
800028e8:	00 00       	add	r0,r0
800028ea:	0b 8c       	ld.ub	r12,r5[0x0]
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	31 a8       	mov	r8,26
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	de 88       	*unknown*
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	5b c4       	cp.w	r4,-4
800028f8:	00 00       	add	r0,r0
800028fa:	0a 64       	and	r4,r5
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	de a0       	acall	0xea
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	58 f8       	cp.w	r8,15
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	de c4       	*unknown*
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	73 10       	ld.w	r0,r9[0x44]

8000290c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000290c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002910:	19 c7       	ld.ub	r7,r12[0x4]
80002912:	19 d8       	ld.ub	r8,r12[0x5]
80002914:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002918:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000291a:	48 dc       	lddpc	r12,8000294c <Phyuserinput_brdcst_func+0x40>
8000291c:	f0 1f 00 0d 	mcall	80002950 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002920:	36 08       	mov	r8,96
80002922:	f0 07 19 00 	cp.h	r7,r8
80002926:	c1 11       	brne	80002948 <Phyuserinput_brdcst_func+0x3c>
80002928:	48 b8       	lddpc	r8,80002954 <Phyuserinput_brdcst_func+0x48>
8000292a:	11 89       	ld.ub	r9,r8[0x0]
8000292c:	30 18       	mov	r8,1
8000292e:	f0 09 18 00 	cp.b	r9,r8
80002932:	c0 b1       	brne	80002948 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002934:	31 4b       	mov	r11,20
80002936:	30 1c       	mov	r12,1
80002938:	f0 1f 00 08 	mcall	80002958 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
8000293c:	e0 6c 03 20 	mov	r12,800
80002940:	f0 1f 00 07 	mcall	8000295c <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
80002944:	f0 1f 00 07 	mcall	80002960 <Phyuserinput_brdcst_func+0x54>
80002948:	e3 cd 80 80 	ldm	sp++,r7,pc
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	de d4       	*unknown*
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	78 34       	ld.w	r4,r12[0xc]
80002954:	00 00       	add	r0,r0
80002956:	0a 56       	eor	r6,r5
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	46 18       	lddsp	r8,sp[0x184]
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	72 c8       	ld.w	r8,r9[0x30]
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	56 5c       	stdsp	sp[0x194],r12

80002964 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002964:	d4 21       	pushm	r4-r7,lr
80002966:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002968:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
8000296c:	0d 88       	ld.ub	r8,r6[0x0]
8000296e:	32 49       	mov	r9,36
80002970:	f2 08 18 00 	cp.b	r8,r9
80002974:	c2 91       	brne	800029c6 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002976:	4a dc       	lddpc	r12,80002a28 <DataSession_brdcst_func+0xc4>
80002978:	f0 1f 00 2d 	mcall	80002a2c <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000297c:	0d a5       	ld.ub	r5,r6[0x2]
8000297e:	0d b8       	ld.ub	r8,r6[0x3]
80002980:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002984:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002986:	0d 98       	ld.ub	r8,r6[0x1]
80002988:	1a d8       	st.w	--sp,r8
8000298a:	4a ac       	lddpc	r12,80002a30 <DataSession_brdcst_func+0xcc>
8000298c:	f0 1f 00 28 	mcall	80002a2c <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002990:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002994:	1a d8       	st.w	--sp,r8
80002996:	4a 8c       	lddpc	r12,80002a34 <DataSession_brdcst_func+0xd0>
80002998:	f0 1f 00 25 	mcall	80002a2c <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
8000299c:	2f ed       	sub	sp,-8
8000299e:	58 05       	cp.w	r5,0
800029a0:	c4 10       	breq	80002a22 <DataSession_brdcst_func+0xbe>
800029a2:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800029a4:	4a 54       	lddpc	r4,80002a38 <DataSession_brdcst_func+0xd4>
800029a6:	ec 07 00 08 	add	r8,r6,r7
800029aa:	11 c8       	ld.ub	r8,r8[0x4]
800029ac:	1a d8       	st.w	--sp,r8
800029ae:	1a d7       	st.w	--sp,r7
800029b0:	08 9c       	mov	r12,r4
800029b2:	f0 1f 00 1f 	mcall	80002a2c <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800029b6:	2f f7       	sub	r7,-1
800029b8:	5c 57       	castu.b	r7
800029ba:	2f ed       	sub	sp,-8
800029bc:	ee 05 19 00 	cp.h	r5,r7
800029c0:	fe 9b ff f3 	brhi	800029a6 <DataSession_brdcst_func+0x42>
800029c4:	c2 f8       	rjmp	80002a22 <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
800029c6:	1a d8       	st.w	--sp,r8
800029c8:	49 dc       	lddpc	r12,80002a3c <DataSession_brdcst_func+0xd8>
800029ca:	f0 1f 00 19 	mcall	80002a2c <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
800029ce:	0d 88       	ld.ub	r8,r6[0x0]
800029d0:	2f fd       	sub	sp,-4
800029d2:	30 39       	mov	r9,3
800029d4:	f2 08 18 00 	cp.b	r8,r9
800029d8:	c0 51       	brne	800029e2 <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
800029da:	49 ac       	lddpc	r12,80002a40 <DataSession_brdcst_func+0xdc>
800029dc:	f0 1f 00 14 	mcall	80002a2c <DataSession_brdcst_func+0xc8>
800029e0:	c2 18       	rjmp	80002a22 <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800029e2:	30 49       	mov	r9,4
800029e4:	f2 08 18 00 	cp.b	r8,r9
800029e8:	c1 d1       	brne	80002a22 <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
800029ea:	32 0a       	mov	r10,32
800029ec:	ec cb ff fc 	sub	r11,r6,-4
800029f0:	1a 9c       	mov	r12,sp
800029f2:	f0 1f 00 15 	mcall	80002a44 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
800029f6:	49 58       	lddpc	r8,80002a48 <DataSession_brdcst_func+0xe4>
800029f8:	70 0c       	ld.w	r12,r8[0x0]
800029fa:	f0 1f 00 15 	mcall	80002a4c <DataSession_brdcst_func+0xe8>
800029fe:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002a00:	c0 e0       	breq	80002a1c <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002a02:	32 0a       	mov	r10,32
80002a04:	1a 9b       	mov	r11,sp
80002a06:	f0 1f 00 10 	mcall	80002a44 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002a0a:	49 28       	lddpc	r8,80002a50 <DataSession_brdcst_func+0xec>
80002a0c:	70 0c       	ld.w	r12,r8[0x0]
80002a0e:	30 09       	mov	r9,0
80002a10:	12 9a       	mov	r10,r9
80002a12:	fa cb ff e0 	sub	r11,sp,-32
80002a16:	f0 1f 00 10 	mcall	80002a54 <DataSession_brdcst_func+0xf0>
80002a1a:	c0 48       	rjmp	80002a22 <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002a1c:	48 fc       	lddpc	r12,80002a58 <DataSession_brdcst_func+0xf4>
80002a1e:	f0 1f 00 04 	mcall	80002a2c <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
80002a22:	2f 7d       	sub	sp,-36
80002a24:	d8 22       	popm	r4-r7,pc
80002a26:	00 00       	add	r0,r0
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	de f4       	*unknown*
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	78 34       	ld.w	r4,r12[0xc]
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	df 08       	*unknown*
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	df 20       	acall	0xf2
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	df 3c       	*unknown*
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	df 54       	*unknown*
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	df 60       	acall	0xf6
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	80 b0       	ld.uh	r0,r0[0x6]
80002a48:	00 00       	add	r0,r0
80002a4a:	0b 8c       	ld.ub	r12,r5[0x0]
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	33 54       	mov	r4,53
80002a50:	00 00       	add	r0,r0
80002a52:	0b 78       	ld.ub	r8,--r5
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	6c 54       	ld.w	r4,r6[0x14]
80002a58:	80 00       	ld.sh	r0,r0[0x0]
80002a5a:	df 78       	*unknown*

80002a5c <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002a5c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002a5e:	19 e8       	ld.ub	r8,r12[0x6]
80002a60:	30 19       	mov	r9,1
80002a62:	f2 08 18 00 	cp.b	r8,r9
80002a66:	c0 61       	brne	80002a72 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a68:	48 98       	lddpc	r8,80002a8c <DeviceInitializationStatus_brdcst_func+0x30>
80002a6a:	70 09       	ld.w	r9,r8[0x0]
80002a6c:	a1 a9       	sbr	r9,0x0
80002a6e:	91 09       	st.w	r8[0x0],r9
80002a70:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002a72:	30 29       	mov	r9,2
80002a74:	f2 08 18 00 	cp.b	r8,r9
80002a78:	c0 80       	breq	80002a88 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a7a:	48 58       	lddpc	r8,80002a8c <DeviceInitializationStatus_brdcst_func+0x30>
80002a7c:	70 09       	ld.w	r9,r8[0x0]
80002a7e:	e0 19 ff fc 	andl	r9,0xfffc
80002a82:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a84:	f0 1f 00 03 	mcall	80002a90 <DeviceInitializationStatus_brdcst_func+0x34>
80002a88:	d8 02       	popm	pc
80002a8a:	00 00       	add	r0,r0
80002a8c:	00 00       	add	r0,r0
80002a8e:	0d b0       	ld.ub	r0,r6[0x3]
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	45 6c       	lddsp	r12,sp[0x158]

80002a94 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002a94:	eb cd 40 fc 	pushm	r2-r7,lr
80002a98:	20 1d       	sub	sp,4
80002a9a:	18 97       	mov	r7,r12
80002a9c:	14 95       	mov	r5,r10
80002a9e:	12 96       	mov	r6,r9
	U16 status = 1;
80002aa0:	30 18       	mov	r8,1
80002aa2:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002aa4:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002aa8:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002aac:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

    //log("0-0-1\n");
	spi_selectChip(spi, DF_SPI_PCS_1);
80002ab0:	30 1b       	mov	r11,1
80002ab2:	4e 58       	lddpc	r8,80002c44 <send_flash_command+0x1b0>
80002ab4:	70 0c       	ld.w	r12,r8[0x0]
80002ab6:	f0 1f 00 65 	mcall	80002c48 <send_flash_command+0x1b4>
	//log("0-0-1-2\n");

    switch (command)
80002aba:	30 58       	mov	r8,5
80002abc:	f0 07 19 00 	cp.h	r7,r8
80002ac0:	c3 40       	breq	80002b28 <send_flash_command+0x94>
80002ac2:	e0 8b 00 18 	brhi	80002af2 <send_flash_command+0x5e>
80002ac6:	30 28       	mov	r8,2
80002ac8:	f0 07 19 00 	cp.h	r7,r8
80002acc:	c5 e0       	breq	80002b88 <send_flash_command+0xf4>
80002ace:	e0 8b 00 08 	brhi	80002ade <send_flash_command+0x4a>
80002ad2:	30 18       	mov	r8,1
80002ad4:	f0 07 19 00 	cp.h	r7,r8
80002ad8:	e0 81 00 ad 	brne	80002c32 <send_flash_command+0x19e>
80002adc:	c9 e8       	rjmp	80002c18 <send_flash_command+0x184>
80002ade:	30 38       	mov	r8,3
80002ae0:	f0 07 19 00 	cp.h	r7,r8
80002ae4:	c7 20       	breq	80002bc8 <send_flash_command+0x134>
80002ae6:	30 48       	mov	r8,4
80002ae8:	f0 07 19 00 	cp.h	r7,r8
80002aec:	e0 81 00 a3 	brne	80002c32 <send_flash_command+0x19e>
80002af0:	c2 c8       	rjmp	80002b48 <send_flash_command+0xb4>
80002af2:	35 28       	mov	r8,82
80002af4:	f0 07 19 00 	cp.h	r7,r8
80002af8:	c2 f0       	breq	80002b56 <send_flash_command+0xc2>
80002afa:	e0 8b 00 0c 	brhi	80002b12 <send_flash_command+0x7e>
80002afe:	30 68       	mov	r8,6
80002b00:	f0 07 19 00 	cp.h	r7,r8
80002b04:	c2 20       	breq	80002b48 <send_flash_command+0xb4>
80002b06:	32 08       	mov	r8,32
80002b08:	f0 07 19 00 	cp.h	r7,r8
80002b0c:	e0 81 00 93 	brne	80002c32 <send_flash_command+0x19e>
80002b10:	c2 38       	rjmp	80002b56 <send_flash_command+0xc2>
80002b12:	36 08       	mov	r8,96
80002b14:	f0 07 19 00 	cp.h	r7,r8
80002b18:	c3 20       	breq	80002b7c <send_flash_command+0xe8>
80002b1a:	e0 68 00 d8 	mov	r8,216
80002b1e:	f0 07 19 00 	cp.h	r7,r8
80002b22:	e0 81 00 88 	brne	80002c32 <send_flash_command+0x19e>
80002b26:	c1 88       	rjmp	80002b56 <send_flash_command+0xc2>
		//WEL:写使能锁定
		//busy：忙标志位（1，忙；0，闲）
		//SUS: 
		//默认:0x00
		case READ_STATUS_REG:
			spi_write_byte(command);
80002b28:	4c 77       	lddpc	r7,80002c44 <send_flash_command+0x1b0>
80002b2a:	30 5b       	mov	r11,5
80002b2c:	6e 0c       	ld.w	r12,r7[0x0]
80002b2e:	f0 1f 00 48 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_dummy();
80002b32:	e0 6b 00 ff 	mov	r11,255
80002b36:	6e 0c       	ld.w	r12,r7[0x0]
80002b38:	f0 1f 00 45 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002b3c:	fa cb ff fe 	sub	r11,sp,-2
80002b40:	6e 0c       	ld.w	r12,r7[0x0]
80002b42:	f0 1f 00 44 	mcall	80002c50 <send_flash_command+0x1bc>
			break;
80002b46:	c7 68       	rjmp	80002c32 <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002b48:	0e 9b       	mov	r11,r7
80002b4a:	5c 7b       	castu.h	r11
80002b4c:	4b e8       	lddpc	r8,80002c44 <send_flash_command+0x1b0>
80002b4e:	70 0c       	ld.w	r12,r8[0x0]
80002b50:	f0 1f 00 3f 	mcall	80002c4c <send_flash_command+0x1b8>
			break;
80002b54:	c6 f8       	rjmp	80002c32 <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002b56:	4b c6       	lddpc	r6,80002c44 <send_flash_command+0x1b0>
80002b58:	0e 9b       	mov	r11,r7
80002b5a:	5c 7b       	castu.h	r11
80002b5c:	6c 0c       	ld.w	r12,r6[0x0]
80002b5e:	f0 1f 00 3c 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002b62:	08 9b       	mov	r11,r4
80002b64:	6c 0c       	ld.w	r12,r6[0x0]
80002b66:	f0 1f 00 3a 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b6a:	06 9b       	mov	r11,r3
80002b6c:	6c 0c       	ld.w	r12,r6[0x0]
80002b6e:	f0 1f 00 38 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b72:	04 9b       	mov	r11,r2
80002b74:	6c 0c       	ld.w	r12,r6[0x0]
80002b76:	f0 1f 00 36 	mcall	80002c4c <send_flash_command+0x1b8>
			break;
80002b7a:	c5 c8       	rjmp	80002c32 <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002b7c:	36 0b       	mov	r11,96
80002b7e:	4b 28       	lddpc	r8,80002c44 <send_flash_command+0x1b0>
80002b80:	70 0c       	ld.w	r12,r8[0x0]
80002b82:	f0 1f 00 33 	mcall	80002c4c <send_flash_command+0x1b8>
			break;
80002b86:	c5 68       	rjmp	80002c32 <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002b88:	4a f7       	lddpc	r7,80002c44 <send_flash_command+0x1b0>
80002b8a:	30 2b       	mov	r11,2
80002b8c:	6e 0c       	ld.w	r12,r7[0x0]
80002b8e:	f0 1f 00 30 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002b92:	08 9b       	mov	r11,r4
80002b94:	6e 0c       	ld.w	r12,r7[0x0]
80002b96:	f0 1f 00 2e 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b9a:	06 9b       	mov	r11,r3
80002b9c:	6e 0c       	ld.w	r12,r7[0x0]
80002b9e:	f0 1f 00 2c 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002ba2:	04 9b       	mov	r11,r2
80002ba4:	6e 0c       	ld.w	r12,r7[0x0]
80002ba6:	f0 1f 00 2a 	mcall	80002c4c <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002baa:	58 06       	cp.w	r6,0
80002bac:	c4 30       	breq	80002c32 <send_flash_command+0x19e>
80002bae:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002bb0:	4a 54       	lddpc	r4,80002c44 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002bb2:	0f 3b       	ld.ub	r11,r7++
80002bb4:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002bb6:	68 0c       	ld.w	r12,r4[0x0]
80002bb8:	f0 1f 00 25 	mcall	80002c4c <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002bbc:	0e 98       	mov	r8,r7
80002bbe:	0a 18       	sub	r8,r5
80002bc0:	ec 08 19 00 	cp.h	r8,r6
80002bc4:	cf 73       	brcs	80002bb2 <send_flash_command+0x11e>
80002bc6:	c3 68       	rjmp	80002c32 <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002bc8:	49 f7       	lddpc	r7,80002c44 <send_flash_command+0x1b0>
80002bca:	30 3b       	mov	r11,3
80002bcc:	6e 0c       	ld.w	r12,r7[0x0]
80002bce:	f0 1f 00 20 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002bd2:	08 9b       	mov	r11,r4
80002bd4:	6e 0c       	ld.w	r12,r7[0x0]
80002bd6:	f0 1f 00 1e 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002bda:	06 9b       	mov	r11,r3
80002bdc:	6e 0c       	ld.w	r12,r7[0x0]
80002bde:	f0 1f 00 1c 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002be2:	04 9b       	mov	r11,r2
80002be4:	6e 0c       	ld.w	r12,r7[0x0]
80002be6:	f0 1f 00 1a 	mcall	80002c4c <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002bea:	58 06       	cp.w	r6,0
80002bec:	c2 30       	breq	80002c32 <send_flash_command+0x19e>
80002bee:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002bf0:	49 54       	lddpc	r4,80002c44 <send_flash_command+0x1b0>
80002bf2:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002bf6:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002bf8:	06 9b       	mov	r11,r3
80002bfa:	68 0c       	ld.w	r12,r4[0x0]
80002bfc:	f0 1f 00 14 	mcall	80002c4c <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002c00:	1a 9b       	mov	r11,sp
80002c02:	68 0c       	ld.w	r12,r4[0x0]
80002c04:	f0 1f 00 13 	mcall	80002c50 <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002c08:	9a 08       	ld.sh	r8,sp[0x0]
80002c0a:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002c0c:	0e 98       	mov	r8,r7
80002c0e:	0a 18       	sub	r8,r5
80002c10:	ec 08 19 00 	cp.h	r8,r6
80002c14:	cf 23       	brcs	80002bf8 <send_flash_command+0x164>
80002c16:	c0 e8       	rjmp	80002c32 <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002c18:	48 b7       	lddpc	r7,80002c44 <send_flash_command+0x1b0>
80002c1a:	30 1b       	mov	r11,1
80002c1c:	6e 0c       	ld.w	r12,r7[0x0]
80002c1e:	f0 1f 00 0c 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002c22:	30 0b       	mov	r11,0
80002c24:	6e 0c       	ld.w	r12,r7[0x0]
80002c26:	f0 1f 00 0a 	mcall	80002c4c <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002c2a:	30 0b       	mov	r11,0
80002c2c:	6e 0c       	ld.w	r12,r7[0x0]
80002c2e:	f0 1f 00 08 	mcall	80002c4c <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002c32:	30 1b       	mov	r11,1
80002c34:	48 48       	lddpc	r8,80002c44 <send_flash_command+0x1b0>
80002c36:	70 0c       	ld.w	r12,r8[0x0]
80002c38:	f0 1f 00 07 	mcall	80002c54 <send_flash_command+0x1c0>
	//log("receive...0-0-1-3\n");
	
	return status;
}
80002c3c:	9a 1c       	ld.sh	r12,sp[0x2]
80002c3e:	2f fd       	sub	sp,-4
80002c40:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002c44:	00 00       	add	r0,r0
80002c46:	20 3c       	sub	r12,3
80002c48:	80 00       	ld.sh	r0,r0[0x0]
80002c4a:	62 b0       	ld.w	r0,r1[0x2c]
80002c4c:	80 00       	ld.sh	r0,r0[0x0]
80002c4e:	61 4a       	ld.w	r10,r0[0x50]
80002c50:	80 00       	ld.sh	r0,r0[0x0]
80002c52:	61 66       	ld.w	r6,r0[0x58]
80002c54:	80 00       	ld.sh	r0,r0[0x0]
80002c56:	62 70       	ld.w	r0,r1[0x1c]

80002c58 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002c58:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002c5a:	58 0a       	cp.w	r10,0
80002c5c:	5f 09       	sreq	r9
80002c5e:	e0 68 ff fe 	mov	r8,65534
80002c62:	ea 18 00 7f 	orh	r8,0x7f
80002c66:	10 3c       	cp.w	r12,r8
80002c68:	5f b8       	srhi	r8
80002c6a:	f3 e8 10 08 	or	r8,r9,r8
80002c6e:	c1 11       	brne	80002c90 <data_flash_read_block+0x38>
80002c70:	e0 68 10 00 	mov	r8,4096
80002c74:	f0 0b 19 00 	cp.h	r11,r8
80002c78:	e0 8b 00 0c 	brhi	80002c90 <data_flash_read_block+0x38>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002c7c:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002c80:	18 9b       	mov	r11,r12
80002c82:	30 3c       	mov	r12,3
80002c84:	f0 1f 00 04 	mcall	80002c94 <data_flash_read_block+0x3c>
	log("0-0-1-3\n");
80002c88:	48 4c       	lddpc	r12,80002c98 <data_flash_read_block+0x40>
80002c8a:	f0 1f 00 05 	mcall	80002c9c <data_flash_read_block+0x44>
80002c8e:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002c90:	da 0a       	popm	pc,r12=1
80002c92:	00 00       	add	r0,r0
80002c94:	80 00       	ld.sh	r0,r0[0x0]
80002c96:	2a 94       	sub	r4,-87
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	df 8c       	*unknown*
80002c9c:	80 00       	ld.sh	r0,r0[0x0]
80002c9e:	78 34       	ld.w	r4,r12[0xc]

80002ca0 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002ca0:	eb cd 40 fc 	pushm	r2-r7,lr
80002ca4:	18 97       	mov	r7,r12
80002ca6:	16 95       	mov	r5,r11
80002ca8:	14 94       	mov	r4,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002caa:	58 0c       	cp.w	r12,0
80002cac:	5f 09       	sreq	r9
80002cae:	e0 68 ff fe 	mov	r8,65534
80002cb2:	ea 18 00 7f 	orh	r8,0x7f
80002cb6:	10 3b       	cp.w	r11,r8
80002cb8:	5f b8       	srhi	r8
80002cba:	f3 e8 10 08 	or	r8,r9,r8
80002cbe:	c3 d1       	brne	80002d38 <data_flash_write_page+0x98>
80002cc0:	e0 68 01 00 	mov	r8,256
80002cc4:	f0 0a 19 00 	cp.h	r10,r8
80002cc8:	e0 8b 00 38 	brhi	80002d38 <data_flash_write_page+0x98>
	{
		return DF_INVALID_PARAM;
	}

	log("receive...0-0-2\n");
80002ccc:	49 dc       	lddpc	r12,80002d40 <data_flash_write_page+0xa0>
80002cce:	f0 1f 00 1e 	mcall	80002d44 <data_flash_write_page+0xa4>
	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002cd2:	30 03       	mov	r3,0
80002cd4:	30 52       	mov	r2,5
80002cd6:	30 16       	mov	r6,1
80002cd8:	06 99       	mov	r9,r3
80002cda:	06 9a       	mov	r10,r3
80002cdc:	06 9b       	mov	r11,r3
80002cde:	04 9c       	mov	r12,r2
80002ce0:	f0 1f 00 1a 	mcall	80002d48 <data_flash_write_page+0xa8>
80002ce4:	ec 0c 19 00 	cp.h	r12,r6
80002ce8:	cf 80       	breq	80002cd8 <data_flash_write_page+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002cea:	30 09       	mov	r9,0
80002cec:	12 9a       	mov	r10,r9
80002cee:	12 9b       	mov	r11,r9
80002cf0:	30 6c       	mov	r12,6
80002cf2:	f0 1f 00 16 	mcall	80002d48 <data_flash_write_page+0xa8>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002cf6:	08 99       	mov	r9,r4
80002cf8:	5c 79       	castu.h	r9
80002cfa:	0e 9a       	mov	r10,r7
80002cfc:	0a 9b       	mov	r11,r5
80002cfe:	30 2c       	mov	r12,2
80002d00:	f0 1f 00 12 	mcall	80002d48 <data_flash_write_page+0xa8>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002d04:	30 05       	mov	r5,0
80002d06:	30 56       	mov	r6,5
80002d08:	0a 99       	mov	r9,r5
80002d0a:	0a 9a       	mov	r10,r5
80002d0c:	0a 9b       	mov	r11,r5
80002d0e:	0c 9c       	mov	r12,r6
80002d10:	f0 1f 00 0e 	mcall	80002d48 <data_flash_write_page+0xa8>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002d14:	5c 7c       	castu.h	r12
80002d16:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002d1a:	cf 71       	brne	80002d08 <data_flash_write_page+0x68>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002d1c:	18 97       	mov	r7,r12
80002d1e:	e2 17 00 20 	andl	r7,0x20,COH
80002d22:	f9 b7 01 06 	movne	r7,6
80002d26:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002d2a:	30 09       	mov	r9,0
80002d2c:	12 9a       	mov	r10,r9
80002d2e:	12 9b       	mov	r11,r9
80002d30:	30 4c       	mov	r12,4
80002d32:	f0 1f 00 06 	mcall	80002d48 <data_flash_write_page+0xa8>

	return return_code;
80002d36:	c0 28       	rjmp	80002d3a <data_flash_write_page+0x9a>
80002d38:	30 17       	mov	r7,1
}
80002d3a:	0e 9c       	mov	r12,r7
80002d3c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002d40:	80 00       	ld.sh	r0,r0[0x0]
80002d42:	df 98       	*unknown*
80002d44:	80 00       	ld.sh	r0,r0[0x0]
80002d46:	78 34       	ld.w	r4,r12[0xc]
80002d48:	80 00       	ld.sh	r0,r0[0x0]
80002d4a:	2a 94       	sub	r4,-87

80002d4c <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002d4c:	d4 31       	pushm	r0-r7,lr
80002d4e:	18 94       	mov	r4,r12
80002d50:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002d54:	16 97       	mov	r7,r11
80002d56:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002d58:	30 03       	mov	r3,0
80002d5a:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002d5c:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002d60:	c4 98       	rjmp	80002df2 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002d62:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002d66:	c1 b1       	brne	80002d9c <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002d68:	e0 06 19 00 	cp.h	r6,r0
80002d6c:	e0 8b 00 0a 	brhi	80002d80 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002d70:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002d74:	0e 9b       	mov	r11,r7
80002d76:	08 9c       	mov	r12,r4
80002d78:	f0 1f 00 24 	mcall	80002e08 <data_flash_write_block+0xbc>
80002d7c:	30 06       	mov	r6,0
80002d7e:	c3 a8       	rjmp	80002df2 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002d80:	e0 6a 01 00 	mov	r10,256
80002d84:	0e 9b       	mov	r11,r7
80002d86:	08 9c       	mov	r12,r4
80002d88:	f0 1f 00 20 	mcall	80002e08 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002d8c:	ec c6 01 00 	sub	r6,r6,256
80002d90:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002d92:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002d96:	ee c7 ff 00 	sub	r7,r7,-256
80002d9a:	c2 c8       	rjmp	80002df2 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002d9c:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002da0:	0e 09       	add	r9,r7
80002da2:	0e 98       	mov	r8,r7
80002da4:	e4 18 00 7f 	andh	r8,0x7f
80002da8:	e0 18 ff 00 	andl	r8,0xff00
80002dac:	f0 c8 ff 00 	sub	r8,r8,-256
80002db0:	10 39       	cp.w	r9,r8
80002db2:	e0 88 00 19 	brls	80002de4 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002db6:	0e 91       	mov	r1,r7
80002db8:	5c 51       	castu.b	r1
80002dba:	e0 6a 01 00 	mov	r10,256
80002dbe:	02 1a       	sub	r10,r1
80002dc0:	5c 7a       	castu.h	r10
80002dc2:	0e 9b       	mov	r11,r7
80002dc4:	08 9c       	mov	r12,r4
80002dc6:	f0 1f 00 11 	mcall	80002e08 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002dca:	ec c6 01 00 	sub	r6,r6,256
80002dce:	02 06       	add	r6,r1
80002dd0:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002dd2:	e0 68 01 00 	mov	r8,256
80002dd6:	f0 05 01 05 	sub	r5,r8,r5
80002dda:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002ddc:	e0 17 ff 00 	andl	r7,0xff00
80002de0:	10 07       	add	r7,r8
80002de2:	c0 88       	rjmp	80002df2 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002de4:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002de8:	0e 9b       	mov	r11,r7
80002dea:	08 9c       	mov	r12,r4
80002dec:	f0 1f 00 07 	mcall	80002e08 <data_flash_write_block+0xbc>
80002df0:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002df2:	e6 06 19 00 	cp.h	r6,r3
80002df6:	5f 19       	srne	r9
80002df8:	58 7c       	cp.w	r12,7
80002dfa:	5f 08       	sreq	r8
80002dfc:	f3 e8 00 08 	and	r8,r9,r8
80002e00:	e4 08 18 00 	cp.b	r8,r2
80002e04:	ca f1       	brne	80002d62 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002e06:	d8 32       	popm	r0-r7,pc
80002e08:	80 00       	ld.sh	r0,r0[0x0]
80002e0a:	2c a0       	sub	r0,-54

80002e0c <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002e0c:	eb cd 40 f8 	pushm	r3-r7,lr
80002e10:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002e12:	e0 68 ff fe 	mov	r8,65534
80002e16:	ea 18 00 7f 	orh	r8,0x7f
80002e1a:	10 3c       	cp.w	r12,r8
80002e1c:	e0 88 00 04 	brls	80002e24 <data_flash_erase_block+0x18>
80002e20:	30 17       	mov	r7,1
80002e22:	c3 f8       	rjmp	80002ea0 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002e24:	58 1b       	cp.w	r11,1
80002e26:	c0 31       	brne	80002e2c <data_flash_erase_block+0x20>
80002e28:	32 03       	mov	r3,32
80002e2a:	c0 a8       	rjmp	80002e3e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002e2c:	58 2b       	cp.w	r11,2
80002e2e:	c0 31       	brne	80002e34 <data_flash_erase_block+0x28>
80002e30:	35 23       	mov	r3,82
80002e32:	c0 68       	rjmp	80002e3e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002e34:	e0 63 00 d8 	mov	r3,216
80002e38:	58 3b       	cp.w	r11,3
80002e3a:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002e3e:	30 06       	mov	r6,0
80002e40:	30 55       	mov	r5,5
80002e42:	30 17       	mov	r7,1
80002e44:	0c 99       	mov	r9,r6
80002e46:	0c 9a       	mov	r10,r6
80002e48:	0c 9b       	mov	r11,r6
80002e4a:	0a 9c       	mov	r12,r5
80002e4c:	f0 1f 00 17 	mcall	80002ea8 <data_flash_erase_block+0x9c>
80002e50:	ee 0c 19 00 	cp.h	r12,r7
80002e54:	cf 80       	breq	80002e44 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e56:	30 09       	mov	r9,0
80002e58:	12 9a       	mov	r10,r9
80002e5a:	12 9b       	mov	r11,r9
80002e5c:	30 6c       	mov	r12,6
80002e5e:	f0 1f 00 13 	mcall	80002ea8 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002e62:	30 09       	mov	r9,0
80002e64:	12 9a       	mov	r10,r9
80002e66:	08 9b       	mov	r11,r4
80002e68:	06 9c       	mov	r12,r3
80002e6a:	f0 1f 00 10 	mcall	80002ea8 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002e6e:	30 06       	mov	r6,0
80002e70:	30 57       	mov	r7,5
80002e72:	0c 99       	mov	r9,r6
80002e74:	0c 9a       	mov	r10,r6
80002e76:	0c 9b       	mov	r11,r6
80002e78:	0e 9c       	mov	r12,r7
80002e7a:	f0 1f 00 0c 	mcall	80002ea8 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002e7e:	5c 7c       	castu.h	r12
80002e80:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002e84:	cf 71       	brne	80002e72 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002e86:	18 97       	mov	r7,r12
80002e88:	e2 17 00 20 	andl	r7,0x20,COH
80002e8c:	f9 b7 01 04 	movne	r7,4
80002e90:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002e94:	30 09       	mov	r9,0
80002e96:	12 9a       	mov	r10,r9
80002e98:	12 9b       	mov	r11,r9
80002e9a:	30 4c       	mov	r12,4
80002e9c:	f0 1f 00 03 	mcall	80002ea8 <data_flash_erase_block+0x9c>

	return return_code;
}
80002ea0:	0e 9c       	mov	r12,r7
80002ea2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002ea6:	00 00       	add	r0,r0
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	2a 94       	sub	r4,-87

80002eac <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002eac:	d4 31       	pushm	r0-r7,lr
80002eae:	20 3d       	sub	sp,12
80002eb0:	50 0c       	stdsp	sp[0x0],r12
80002eb2:	16 91       	mov	r1,r11
80002eb4:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002eb6:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002eba:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002ebc:	e0 69 10 00 	mov	r9,4096
80002ec0:	f2 0a 01 07 	sub	r7,r9,r10
80002ec4:	ea 07 19 00 	cp.h	r7,r5
80002ec8:	ea 07 17 b0 	movhi	r7,r5
80002ecc:	5c 87       	casts.h	r7
80002ece:	16 92       	mov	r2,r11
80002ed0:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		//log("receive...1-1-1\n");
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002ed4:	4a e4       	lddpc	r4,80002f8c <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002ed6:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002ed8:	e8 c8 ff ff 	sub	r8,r4,-1
80002edc:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002ede:	12 90       	mov	r0,r9
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		//log("receive...1-1-1\n");
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002ee0:	08 9a       	mov	r10,r4
80002ee2:	e0 6b 10 00 	mov	r11,4096
80002ee6:	04 9c       	mov	r12,r2
80002ee8:	f0 1f 00 2a 	mcall	80002f90 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002eec:	58 07       	cp.w	r7,0
80002eee:	c3 00       	breq	80002f4e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002ef0:	40 13       	lddsp	r3,sp[0x4]
80002ef2:	5c 73       	castu.h	r3
80002ef4:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002ef8:	ec 08 18 00 	cp.b	r8,r6
80002efc:	c1 11       	brne	80002f1e <data_flash_write+0x72>
80002efe:	e6 c9 ff ff 	sub	r9,r3,-1
80002f02:	08 09       	add	r9,r4
80002f04:	30 08       	mov	r8,0
80002f06:	c0 58       	rjmp	80002f10 <data_flash_write+0x64>
80002f08:	13 3a       	ld.ub	r10,r9++
80002f0a:	ec 0a 18 00 	cp.b	r10,r6
80002f0e:	c0 81       	brne	80002f1e <data_flash_write+0x72>
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		//log("receive...1-1-1\n");
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002f10:	2f f8       	sub	r8,-1
80002f12:	5c 88       	casts.h	r8
80002f14:	f0 07 19 00 	cp.h	r7,r8
80002f18:	fe 9b ff f8 	brhi	80002f08 <data_flash_write+0x5c>
80002f1c:	c1 98       	rjmp	80002f4e <data_flash_write+0xa2>
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			//log("receive...1-1-2\n");
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002f1e:	30 1b       	mov	r11,1
80002f20:	04 9c       	mov	r12,r2
80002f22:	f0 1f 00 1d 	mcall	80002f94 <data_flash_write+0xe8>
80002f26:	40 08       	lddsp	r8,sp[0x0]
80002f28:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002f2a:	40 2a       	lddsp	r10,sp[0x8]
80002f2c:	40 19       	lddsp	r9,sp[0x4]
80002f2e:	12 0a       	add	r10,r9
80002f30:	0e 99       	mov	r9,r7
80002f32:	20 19       	sub	r9,1
80002f34:	5c 79       	castu.h	r9
80002f36:	12 0a       	add	r10,r9
		{
			//log("receive...1-1-2\n");
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002f38:	11 39       	ld.ub	r9,r8++
80002f3a:	06 c9       	st.b	r3++,r9
		}
		if(i < secremain)//需要擦除
		{
			//log("receive...1-1-2\n");
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002f3c:	14 33       	cp.w	r3,r10
80002f3e:	cf d1       	brne	80002f38 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			//log("receive...1-1-3\n");
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002f40:	e0 6a 10 00 	mov	r10,4096
80002f44:	04 9b       	mov	r11,r2
80002f46:	08 9c       	mov	r12,r4
80002f48:	f0 1f 00 14 	mcall	80002f98 <data_flash_write+0xec>
80002f4c:	c0 78       	rjmp	80002f5a <data_flash_write+0xae>

		}
		else 
		{
			//log("receive...1-1-4\n");
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002f4e:	0e 9a       	mov	r10,r7
80002f50:	5c 7a       	castu.h	r10
80002f52:	02 9b       	mov	r11,r1
80002f54:	40 0c       	lddsp	r12,sp[0x0]
80002f56:	f0 1f 00 11 	mcall	80002f98 <data_flash_write+0xec>
80002f5a:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002f5e:	0e 98       	mov	r8,r7
80002f60:	ee 05 19 00 	cp.h	r5,r7
80002f64:	c1 20       	breq	80002f88 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002f66:	5c 78       	castu.h	r8
80002f68:	40 0a       	lddsp	r10,sp[0x0]
80002f6a:	10 0a       	add	r10,r8
80002f6c:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002f6e:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002f70:	0e 15       	sub	r5,r7
80002f72:	5c 85       	casts.h	r5
80002f74:	e0 05 19 00 	cp.h	r5,r0
80002f78:	ea 07 17 80 	movls	r7,r5
80002f7c:	e0 07 17 b0 	movhi	r7,r0
80002f80:	5c 87       	casts.h	r7
80002f82:	30 09       	mov	r9,0
80002f84:	50 19       	stdsp	sp[0x4],r9
80002f86:	ca db       	rjmp	80002ee0 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002f88:	2f dd       	sub	sp,-12
80002f8a:	d8 32       	popm	r0-r7,pc
80002f8c:	00 00       	add	r0,r0
80002f8e:	10 3c       	cp.w	r12,r8
80002f90:	80 00       	ld.sh	r0,r0[0x0]
80002f92:	2c 58       	sub	r8,-59
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	2e 0c       	sub	r12,-32
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	2d 4c       	sub	r12,-44

80002f9c <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80002f9c:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
80002f9e:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80002fa0:	30 0a       	mov	r10,0
80002fa2:	32 8b       	mov	r11,40
80002fa4:	49 5c       	lddpc	r12,80002ff8 <xg_rtc_init+0x5c>
80002fa6:	f0 1f 00 16 	mcall	80002ffc <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80002faa:	30 ea       	mov	r10,14
80002fac:	30 1b       	mov	r11,1
80002fae:	fe 7c 0d 00 	mov	r12,-62208
80002fb2:	f0 1f 00 14 	mcall	80003000 <xg_rtc_init+0x64>
80002fb6:	c0 41       	brne	80002fbe <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80002fb8:	49 3c       	lddpc	r12,80003004 <xg_rtc_init+0x68>
80002fba:	f0 1f 00 14 	mcall	80003008 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
80002fbe:	30 0b       	mov	r11,0
80002fc0:	fe 7c 0d 00 	mov	r12,-62208
80002fc4:	f0 1f 00 12 	mcall	8000300c <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80002fc8:	fe 7c 0d 00 	mov	r12,-62208
80002fcc:	f0 1f 00 11 	mcall	80003010 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80002fd0:	fe 7c 0d 00 	mov	r12,-62208
80002fd4:	f0 1f 00 10 	mcall	80003014 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80002fd8:	49 08       	lddpc	r8,80003018 <xg_rtc_init+0x7c>
80002fda:	31 09       	mov	r9,16
80002fdc:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80002fde:	30 29       	mov	r9,2
80002fe0:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80002fe2:	31 d9       	mov	r9,29
80002fe4:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002fe6:	31 79       	mov	r9,23
80002fe8:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002fea:	33 b9       	mov	r9,59
80002fec:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80002fee:	32 89       	mov	r9,40
80002ff0:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80002ff2:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002ff4:	d8 02       	popm	pc
80002ff6:	00 00       	add	r0,r0
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	30 1c       	mov	r12,1
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	5c f4       	rol	r4
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	60 40       	ld.w	r0,r0[0x10]
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	e0 08       	*unknown*
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	78 34       	ld.w	r4,r12[0xc]
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	5f fc       	sral	r12
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	5f f4       	sral	r4
80003014:	80 00       	ld.sh	r0,r0[0x0]
80003016:	5f d0       	srvc	r0
80003018:	00 00       	add	r0,r0
8000301a:	0d b4       	ld.ub	r4,r6[0x3]

8000301c <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
8000301c:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
8000301e:	4b 98       	lddpc	r8,80003100 <rtc_irq+0xe4>
80003020:	11 d9       	ld.ub	r9,r8[0x5]
80003022:	2f f9       	sub	r9,-1
80003024:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80003026:	11 d9       	ld.ub	r9,r8[0x5]
80003028:	33 b8       	mov	r8,59
8000302a:	f0 09 18 00 	cp.b	r9,r8
8000302e:	e0 88 00 5f 	brls	800030ec <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80003032:	4b 48       	lddpc	r8,80003100 <rtc_irq+0xe4>
80003034:	30 09       	mov	r9,0
80003036:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80003038:	11 c9       	ld.ub	r9,r8[0x4]
8000303a:	2f f9       	sub	r9,-1
8000303c:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
8000303e:	11 c9       	ld.ub	r9,r8[0x4]
80003040:	33 b8       	mov	r8,59
80003042:	f0 09 18 00 	cp.b	r9,r8
80003046:	e0 88 00 53 	brls	800030ec <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
8000304a:	4a e8       	lddpc	r8,80003100 <rtc_irq+0xe4>
8000304c:	30 09       	mov	r9,0
8000304e:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80003050:	11 b9       	ld.ub	r9,r8[0x3]
80003052:	2f f9       	sub	r9,-1
80003054:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80003056:	11 b9       	ld.ub	r9,r8[0x3]
80003058:	31 78       	mov	r8,23
8000305a:	f0 09 18 00 	cp.b	r9,r8
8000305e:	e0 88 00 47 	brls	800030ec <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80003062:	4a 88       	lddpc	r8,80003100 <rtc_irq+0xe4>
80003064:	30 09       	mov	r9,0
80003066:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003068:	11 88       	ld.ub	r8,r8[0x0]
8000306a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000306e:	e0 69 01 6e 	mov	r9,366
80003072:	e0 6a 01 6d 	mov	r10,365
80003076:	f4 08 17 10 	movne	r8,r10
8000307a:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
8000307e:	4a 19       	lddpc	r9,80003100 <rtc_irq+0xe4>
80003080:	13 9a       	ld.ub	r10,r9[0x1]
80003082:	30 29       	mov	r9,2
80003084:	f2 0a 18 00 	cp.b	r10,r9
80003088:	c0 b0       	breq	8000309e <rtc_irq+0x82>
8000308a:	49 e8       	lddpc	r8,80003100 <rtc_irq+0xe4>
8000308c:	11 99       	ld.ub	r9,r8[0x1]
8000308e:	11 9a       	ld.ub	r10,r8[0x1]
80003090:	a3 9a       	lsr	r10,0x3
80003092:	12 0a       	add	r10,r9
80003094:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003098:	2e 2a       	sub	r10,-30
8000309a:	5c 5a       	castu.b	r10
8000309c:	c0 58       	rjmp	800030a6 <rtc_irq+0x8a>
8000309e:	f0 c8 01 51 	sub	r8,r8,337
800030a2:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
800030a6:	49 78       	lddpc	r8,80003100 <rtc_irq+0xe4>
800030a8:	11 a9       	ld.ub	r9,r8[0x2]
800030aa:	2f f9       	sub	r9,-1
800030ac:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
800030ae:	11 a8       	ld.ub	r8,r8[0x2]
800030b0:	f0 0a 18 00 	cp.b	r10,r8
800030b4:	c1 c2       	brcc	800030ec <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
800030b6:	49 38       	lddpc	r8,80003100 <rtc_irq+0xe4>
800030b8:	30 19       	mov	r9,1
800030ba:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
800030bc:	11 99       	ld.ub	r9,r8[0x1]
800030be:	2f f9       	sub	r9,-1
800030c0:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
800030c2:	11 99       	ld.ub	r9,r8[0x1]
800030c4:	30 c8       	mov	r8,12
800030c6:	f0 09 18 00 	cp.b	r9,r8
800030ca:	e0 88 00 11 	brls	800030ec <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
800030ce:	48 d8       	lddpc	r8,80003100 <rtc_irq+0xe4>
800030d0:	30 19       	mov	r9,1
800030d2:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
800030d4:	11 89       	ld.ub	r9,r8[0x0]
800030d6:	2f f9       	sub	r9,-1
800030d8:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
800030da:	11 89       	ld.ub	r9,r8[0x0]
800030dc:	39 68       	mov	r8,-106
800030de:	f0 09 18 00 	cp.b	r9,r8
800030e2:	e0 88 00 05 	brls	800030ec <rtc_irq+0xd0>
800030e6:	30 09       	mov	r9,0
800030e8:	48 68       	lddpc	r8,80003100 <rtc_irq+0xe4>
800030ea:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
800030ec:	fe 7c 0d 00 	mov	r12,-62208
800030f0:	f0 1f 00 05 	mcall	80003104 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
800030f4:	30 19       	mov	r9,1
800030f6:	48 58       	lddpc	r8,80003108 <rtc_irq+0xec>
800030f8:	91 09       	st.w	r8[0x0],r9
}
800030fa:	d4 02       	popm	lr
800030fc:	d6 03       	rete
800030fe:	00 00       	add	r0,r0
80003100:	00 00       	add	r0,r0
80003102:	0d b4       	ld.ub	r4,r6[0x3]
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	60 20       	ld.w	r0,r0[0x8]
80003108:	00 00       	add	r0,r0
8000310a:	04 f4       	st.b	--r2,r4

8000310c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
8000310c:	20 1c       	sub	r12,1
8000310e:	5c 5c       	castu.b	r12
80003110:	31 18       	mov	r8,17
80003112:	f0 0c 18 00 	cp.b	r12,r8
80003116:	e0 88 00 03 	brls	8000311c <CalculateBurst+0x10>
8000311a:	5e fd       	retal	0
8000311c:	48 28       	lddpc	r8,80003124 <CalculateBurst+0x18>
8000311e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003122:	5e fc       	retal	r12
80003124:	80 00       	ld.sh	r0,r0[0x0]
80003126:	e0 28 48 38 	sub	r8,18488

80003128 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80003128:	48 38       	lddpc	r8,80003134 <payload_init+0xc>
8000312a:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000312c:	48 38       	lddpc	r8,80003138 <payload_init+0x10>
8000312e:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80003130:	5e fc       	retal	r12
80003132:	00 00       	add	r0,r0
80003134:	00 00       	add	r0,r0
80003136:	0a 6c       	and	r12,r5
80003138:	00 00       	add	r0,r0
8000313a:	0a 70       	tst	r0,r5

8000313c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000313c:	d4 01       	pushm	lr
8000313e:	20 2d       	sub	sp,8
80003140:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003142:	30 09       	mov	r9,0
80003144:	fa ca ff f8 	sub	r10,sp,-8
80003148:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000314a:	1a 9b       	mov	r11,sp
8000314c:	f0 1f 00 02 	mcall	80003154 <set_idle_store_isr+0x18>
}
80003150:	2f ed       	sub	sp,-8
80003152:	d8 02       	popm	pc
80003154:	80 00       	ld.sh	r0,r0[0x0]
80003156:	6c 04       	ld.w	r4,r6[0x0]

80003158 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80003158:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
8000315a:	48 48       	lddpc	r8,80003168 <payload_rx+0x10>
8000315c:	70 08       	ld.w	r8,r8[0x0]
8000315e:	18 9b       	mov	r11,r12
80003160:	10 9c       	mov	r12,r8
80003162:	f0 1f 00 03 	mcall	8000316c <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80003166:	d8 02       	popm	pc
80003168:	00 00       	add	r0,r0
8000316a:	0a a8       	st.w	r5++,r8
8000316c:	80 00       	ld.sh	r0,r0[0x0]
8000316e:	31 3c       	mov	r12,19

80003170 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003170:	d4 01       	pushm	lr
80003172:	20 2d       	sub	sp,8
80003174:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003176:	58 0c       	cp.w	r12,0
80003178:	c1 10       	breq	8000319a <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000317a:	30 08       	mov	r8,0
8000317c:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
8000317e:	98 88       	ld.uh	r8,r12[0x0]
80003180:	e2 18 f0 00 	andl	r8,0xf000,COH
80003184:	e0 48 40 00 	cp.w	r8,16384
80003188:	c0 91       	brne	8000319a <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
8000318a:	48 68       	lddpc	r8,800031a0 <phy_rx+0x30>
8000318c:	70 0c       	ld.w	r12,r8[0x0]
8000318e:	30 09       	mov	r9,0
80003190:	fa ca ff fc 	sub	r10,sp,-4
80003194:	1a 9b       	mov	r11,sp
80003196:	f0 1f 00 04 	mcall	800031a4 <phy_rx+0x34>
		}	

    }
		
 
}
8000319a:	2f ed       	sub	sp,-8
8000319c:	d8 02       	popm	pc
8000319e:	00 00       	add	r0,r0
800031a0:	00 00       	add	r0,r0
800031a2:	0a b4       	st.h	r5++,r4
800031a4:	80 00       	ld.sh	r0,r0[0x0]
800031a6:	6c 04       	ld.w	r4,r6[0x0]

800031a8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800031a8:	eb cd 40 80 	pushm	r7,lr
800031ac:	20 1d       	sub	sp,4
800031ae:	fa c7 ff fc 	sub	r7,sp,-4
800031b2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800031b4:	30 09       	mov	r9,0
800031b6:	12 9a       	mov	r10,r9
800031b8:	1a 9b       	mov	r11,sp
800031ba:	f0 1f 00 03 	mcall	800031c4 <set_idle_store+0x1c>
}
800031be:	2f fd       	sub	sp,-4
800031c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800031c4:	80 00       	ld.sh	r0,r0[0x0]
800031c6:	6c 54       	ld.w	r4,r6[0x14]

800031c8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800031c8:	d4 01       	pushm	lr
800031ca:	20 1d       	sub	sp,4
800031cc:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800031ce:	98 88       	ld.uh	r8,r12[0x0]
800031d0:	e2 18 f0 00 	andl	r8,0xf000,COH
800031d4:	e0 48 40 00 	cp.w	r8,16384
800031d8:	c0 d1       	brne	800031f2 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800031da:	49 08       	lddpc	r8,80003218 <phy_tx+0x50>
800031dc:	70 08       	ld.w	r8,r8[0x0]
800031de:	58 08       	cp.w	r8,0
800031e0:	c1 a0       	breq	80003214 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800031e2:	48 e8       	lddpc	r8,80003218 <phy_tx+0x50>
800031e4:	70 0c       	ld.w	r12,r8[0x0]
800031e6:	30 09       	mov	r9,0
800031e8:	12 9a       	mov	r10,r9
800031ea:	1a 9b       	mov	r11,sp
800031ec:	f0 1f 00 0c 	mcall	8000321c <phy_tx+0x54>
800031f0:	c1 28       	rjmp	80003214 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800031f2:	e0 48 10 00 	cp.w	r8,4096
800031f6:	5f 0a       	sreq	r10
800031f8:	e0 48 20 00 	cp.w	r8,8192
800031fc:	5f 09       	sreq	r9
800031fe:	f5 e9 10 09 	or	r9,r10,r9
80003202:	c0 71       	brne	80003210 <phy_tx+0x48>
80003204:	e0 48 50 00 	cp.w	r8,20480
80003208:	c0 40       	breq	80003210 <phy_tx+0x48>
8000320a:	e0 48 60 00 	cp.w	r8,24576
8000320e:	c0 31       	brne	80003214 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003210:	48 48       	lddpc	r8,80003220 <phy_tx+0x58>
80003212:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003214:	2f fd       	sub	sp,-4
80003216:	d8 02       	popm	pc
80003218:	00 00       	add	r0,r0
8000321a:	0a d4       	st.w	--r5,r4
8000321c:	80 00       	ld.sh	r0,r0[0x0]
8000321e:	6c 54       	ld.w	r4,r6[0x14]
80003220:	00 00       	add	r0,r0
80003222:	0a c8       	st.b	r5++,r8

80003224 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003224:	d4 01       	pushm	lr
80003226:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003228:	30 08       	mov	r8,0
8000322a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000322c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
8000322e:	1a 9a       	mov	r10,sp
80003230:	fa cb ff fc 	sub	r11,sp,-4
80003234:	f0 1f 00 05 	mcall	80003248 <get_idle_store_isr+0x24>
80003238:	58 1c       	cp.w	r12,1
8000323a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000323e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003242:	2f ed       	sub	sp,-8
80003244:	d8 02       	popm	pc
80003246:	00 00       	add	r0,r0
80003248:	80 00       	ld.sh	r0,r0[0x0]
8000324a:	69 58       	ld.w	r8,r4[0x54]

8000324c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
8000324c:	eb cd 40 c0 	pushm	r6-r7,lr
80003250:	20 1d       	sub	sp,4
80003252:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003254:	4b a8       	lddpc	r8,8000333c <phy_tx_func+0xf0>
80003256:	70 08       	ld.w	r8,r8[0x0]
80003258:	58 08       	cp.w	r8,0
8000325a:	c6 60       	breq	80003326 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
8000325c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000325e:	30 08       	mov	r8,0
80003260:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003262:	4b 88       	lddpc	r8,80003340 <phy_tx_func+0xf4>
80003264:	70 08       	ld.w	r8,r8[0x0]
80003266:	58 18       	cp.w	r8,1
80003268:	c2 60       	breq	800032b4 <phy_tx_func+0x68>
8000326a:	c0 43       	brcs	80003272 <phy_tx_func+0x26>
8000326c:	58 28       	cp.w	r8,2
8000326e:	c5 c1       	brne	80003326 <phy_tx_func+0xda>
80003270:	c5 58       	rjmp	8000331a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003272:	4b 38       	lddpc	r8,8000333c <phy_tx_func+0xf0>
80003274:	70 0c       	ld.w	r12,r8[0x0]
80003276:	1a 9a       	mov	r10,sp
80003278:	4b 3b       	lddpc	r11,80003344 <phy_tx_func+0xf8>
8000327a:	f0 1f 00 34 	mcall	80003348 <phy_tx_func+0xfc>
8000327e:	58 1c       	cp.w	r12,1
80003280:	c1 41       	brne	800032a8 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003282:	4b 18       	lddpc	r8,80003344 <phy_tx_func+0xf8>
80003284:	70 08       	ld.w	r8,r8[0x0]
80003286:	90 08       	ld.sh	r8,r8[0x0]
80003288:	10 9a       	mov	r10,r8
8000328a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000328e:	4b 09       	lddpc	r9,8000334c <phy_tx_func+0x100>
80003290:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003292:	5c 78       	castu.h	r8
80003294:	ea 18 ab cd 	orh	r8,0xabcd
80003298:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
8000329a:	30 19       	mov	r9,1
8000329c:	4a d8       	lddpc	r8,80003350 <phy_tx_func+0x104>
8000329e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800032a0:	30 19       	mov	r9,1
800032a2:	4a 88       	lddpc	r8,80003340 <phy_tx_func+0xf4>
800032a4:	91 09       	st.w	r8[0x0],r9
800032a6:	c4 08       	rjmp	80003326 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800032a8:	e0 68 5a 5a 	mov	r8,23130
800032ac:	ea 18 ab cd 	orh	r8,0xabcd
800032b0:	8f 18       	st.w	r7[0x4],r8
800032b2:	c3 a8       	rjmp	80003326 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800032b4:	4a 7a       	lddpc	r10,80003350 <phy_tx_func+0x104>
800032b6:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800032b8:	4a 39       	lddpc	r9,80003344 <phy_tx_func+0xf8>
800032ba:	72 09       	ld.w	r9,r9[0x0]
800032bc:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
800032c0:	b1 69       	lsl	r9,0x10
800032c2:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800032c4:	2f f8       	sub	r8,-1
800032c6:	5c 58       	castu.b	r8
800032c8:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
800032ca:	4a 1b       	lddpc	r11,8000334c <phy_tx_func+0x100>
800032cc:	96 0c       	ld.sh	r12,r11[0x0]
800032ce:	20 2c       	sub	r12,2
800032d0:	5c 8c       	casts.h	r12
800032d2:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
800032d6:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800032d8:	30 0b       	mov	r11,0
800032da:	f6 0a 19 00 	cp.h	r10,r11
800032de:	e0 89 00 09 	brgt	800032f0 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
800032e2:	e8 19 00 ba 	orl	r9,0xba
800032e6:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
800032e8:	30 09       	mov	r9,0
800032ea:	49 68       	lddpc	r8,80003340 <phy_tx_func+0xf4>
800032ec:	91 09       	st.w	r8[0x0],r9
800032ee:	c1 c8       	rjmp	80003326 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
800032f0:	49 5a       	lddpc	r10,80003344 <phy_tx_func+0xf8>
800032f2:	74 0a       	ld.w	r10,r10[0x0]
800032f4:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
800032f8:	14 49       	or	r9,r10
800032fa:	8f 19       	st.w	r7[0x4],r9
800032fc:	2f f8       	sub	r8,-1
800032fe:	49 59       	lddpc	r9,80003350 <phy_tx_func+0x104>
80003300:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003302:	20 2c       	sub	r12,2
80003304:	49 28       	lddpc	r8,8000334c <phy_tx_func+0x100>
80003306:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003308:	30 08       	mov	r8,0
8000330a:	f0 0c 19 00 	cp.h	r12,r8
8000330e:	e0 89 00 0c 	brgt	80003326 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003312:	30 29       	mov	r9,2
80003314:	48 b8       	lddpc	r8,80003340 <phy_tx_func+0xf4>
80003316:	91 09       	st.w	r8[0x0],r9
80003318:	c0 78       	rjmp	80003326 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000331a:	fc 18 00 ba 	movh	r8,0xba
8000331e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003320:	30 09       	mov	r9,0
80003322:	48 88       	lddpc	r8,80003340 <phy_tx_func+0xf4>
80003324:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80003326:	e0 68 5a 5a 	mov	r8,23130
8000332a:	ea 18 ab cd 	orh	r8,0xabcd
8000332e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80003330:	30 08       	mov	r8,0
80003332:	8f 38       	st.w	r7[0xc],r8
}
80003334:	2f fd       	sub	sp,-4
80003336:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000333a:	00 00       	add	r0,r0
8000333c:	00 00       	add	r0,r0
8000333e:	0a d4       	st.w	--r5,r4
80003340:	00 00       	add	r0,r0
80003342:	0a 94       	mov	r4,r5
80003344:	00 00       	add	r0,r0
80003346:	0a a0       	st.w	r5++,r0
80003348:	80 00       	ld.sh	r0,r0[0x0]
8000334a:	69 58       	ld.w	r8,r4[0x54]
8000334c:	00 00       	add	r0,r0
8000334e:	0a bc       	st.h	r5++,r12
80003350:	00 00       	add	r0,r0
80003352:	0a 74       	tst	r4,r5

80003354 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003354:	d4 01       	pushm	lr
80003356:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003358:	30 0a       	mov	r10,0
8000335a:	fa cb ff fc 	sub	r11,sp,-4
8000335e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003360:	14 99       	mov	r9,r10
80003362:	1a 9b       	mov	r11,sp
80003364:	f0 1f 00 05 	mcall	80003378 <get_idle_store+0x24>
80003368:	58 1c       	cp.w	r12,1
8000336a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000336e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80003372:	2f fd       	sub	sp,-4
80003374:	d8 02       	popm	pc
80003376:	00 00       	add	r0,r0
80003378:	80 00       	ld.sh	r0,r0[0x0]
8000337a:	6a 48       	ld.w	r8,r5[0x10]

8000337c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
8000337c:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000337e:	48 5b       	lddpc	r11,80003390 <phy_init+0x14>
80003380:	48 5c       	lddpc	r12,80003394 <phy_init+0x18>
80003382:	f0 1f 00 06 	mcall	80003398 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80003386:	f0 1f 00 06 	mcall	8000339c <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
8000338a:	f0 1f 00 06 	mcall	800033a0 <phy_init+0x24>
	
}
8000338e:	d8 02       	popm	pc
80003390:	80 00       	ld.sh	r0,r0[0x0]
80003392:	32 4c       	mov	r12,36
80003394:	80 00       	ld.sh	r0,r0[0x0]
80003396:	33 a4       	mov	r4,58
80003398:	80 00       	ld.sh	r0,r0[0x0]
8000339a:	44 04       	lddsp	r4,sp[0x100]
8000339c:	80 00       	ld.sh	r0,r0[0x0]
8000339e:	44 18       	lddsp	r8,sp[0x104]
800033a0:	80 00       	ld.sh	r0,r0[0x0]
800033a2:	4d c4       	lddpc	r4,80003510 <phy_rx_func+0x16c>

800033a4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800033a4:	eb cd 40 e0 	pushm	r5-r7,lr
800033a8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800033aa:	fe f8 0e 7a 	ld.w	r8,pc[3706]
800033ae:	70 08       	ld.w	r8,r8[0x0]
800033b0:	58 08       	cp.w	r8,0
800033b2:	e0 80 01 08 	breq	800035c2 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800033b6:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800033b8:	fe f8 0e 70 	ld.w	r8,pc[3696]
800033bc:	70 09       	ld.w	r9,r8[0x0]
800033be:	2f f9       	sub	r9,-1
800033c0:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800033c2:	fe f8 0e 6a 	ld.w	r8,pc[3690]
800033c6:	70 08       	ld.w	r8,r8[0x0]
800033c8:	58 18       	cp.w	r8,1
800033ca:	e0 80 00 85 	breq	800034d4 <phy_rx_func+0x130>
800033ce:	c0 73       	brcs	800033dc <phy_rx_func+0x38>
800033d0:	58 28       	cp.w	r8,2
800033d2:	c5 c0       	breq	8000348a <phy_rx_func+0xe6>
800033d4:	58 38       	cp.w	r8,3
800033d6:	e0 81 00 f6 	brne	800035c2 <phy_rx_func+0x21e>
800033da:	cd 58       	rjmp	80003584 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800033dc:	e0 6a 5a 5a 	mov	r10,23130
800033e0:	ea 1a ab cd 	orh	r10,0xabcd
800033e4:	14 36       	cp.w	r6,r10
800033e6:	e0 80 00 ee 	breq	800035c2 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800033ea:	ec 08 16 10 	lsr	r8,r6,0x10
800033ee:	e0 48 ab cd 	cp.w	r8,43981
800033f2:	e0 81 00 e8 	brne	800035c2 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800033f6:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800033fa:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800033fe:	20 28       	sub	r8,2
80003400:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003404:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003406:	30 09       	mov	r9,0
80003408:	f2 08 19 00 	cp.h	r8,r9
8000340c:	e0 8a 00 db 	brle	800035c2 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003410:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003414:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80003416:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000341a:	70 0c       	ld.w	r12,r8[0x0]
8000341c:	f0 1f 03 88 	mcall	8000423c <phy_rx_func+0xe98>
80003420:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003424:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003426:	58 0c       	cp.w	r12,0
80003428:	e0 80 00 cd 	breq	800035c2 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000342c:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003430:	90 09       	ld.sh	r9,r8[0x0]
80003432:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003436:	2f f9       	sub	r9,-1
80003438:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000343a:	fe fa 0e 06 	ld.w	r10,pc[3590]
8000343e:	74 0a       	ld.w	r10,r10[0x0]
80003440:	fe fb 0d e8 	ld.w	r11,pc[3560]
80003444:	76 0b       	ld.w	r11,r11[0x0]
80003446:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000344a:	2f f9       	sub	r9,-1
8000344c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000344e:	e2 16 0f 00 	andl	r6,0xf00,COH
80003452:	e0 46 01 00 	cp.w	r6,256
80003456:	c0 c0       	breq	8000346e <phy_rx_func+0xca>
80003458:	e0 8b 00 05 	brhi	80003462 <phy_rx_func+0xbe>
8000345c:	58 06       	cp.w	r6,0
8000345e:	c0 80       	breq	8000346e <phy_rx_func+0xca>
80003460:	c0 c8       	rjmp	80003478 <phy_rx_func+0xd4>
80003462:	e0 46 02 00 	cp.w	r6,512
80003466:	c0 40       	breq	8000346e <phy_rx_func+0xca>
80003468:	e0 46 03 00 	cp.w	r6,768
8000346c:	c0 61       	brne	80003478 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000346e:	30 29       	mov	r9,2
80003470:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003474:	91 09       	st.w	r8[0x0],r9
80003476:	ca 68       	rjmp	800035c2 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003478:	fe f8 0d c0 	ld.w	r8,pc[3520]
8000347c:	70 0c       	ld.w	r12,r8[0x0]
8000347e:	fe f8 0d c2 	ld.w	r8,pc[3522]
80003482:	70 0b       	ld.w	r11,r8[0x0]
80003484:	f0 1f 03 70 	mcall	80004244 <phy_rx_func+0xea0>
80003488:	c9 d8       	rjmp	800035c2 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
8000348a:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000348e:	b1 86       	lsr	r6,0x10
80003490:	14 06       	add	r6,r10
80003492:	fe f8 0d b6 	ld.w	r8,pc[3510]
80003496:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003498:	fe f8 0d 9c 	ld.w	r8,pc[3484]
8000349c:	90 09       	ld.sh	r9,r8[0x0]
8000349e:	fe fb 0d a2 	ld.w	r11,pc[3490]
800034a2:	76 0b       	ld.w	r11,r11[0x0]
800034a4:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800034a8:	2f f9       	sub	r9,-1
800034aa:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800034ac:	fe f9 0d 84 	ld.w	r9,pc[3460]
800034b0:	92 08       	ld.sh	r8,r9[0x0]
800034b2:	20 28       	sub	r8,2
800034b4:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800034b6:	30 09       	mov	r9,0
800034b8:	f2 08 19 00 	cp.h	r8,r9
800034bc:	e0 8a 00 07 	brle	800034ca <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
800034c0:	30 19       	mov	r9,1
800034c2:	fe f8 0d 6a 	ld.w	r8,pc[3434]
800034c6:	91 09       	st.w	r8[0x0],r9
800034c8:	c7 d8       	rjmp	800035c2 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800034ca:	30 39       	mov	r9,3
800034cc:	fe f8 0d 60 	ld.w	r8,pc[3424]
800034d0:	91 09       	st.w	r8[0x0],r9
800034d2:	c7 88       	rjmp	800035c2 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800034d4:	ec 0a 14 10 	asr	r10,r6,0x10
800034d8:	fe f8 0d 70 	ld.w	r8,pc[3440]
800034dc:	90 09       	ld.sh	r9,r8[0x0]
800034de:	14 09       	add	r9,r10
800034e0:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800034e2:	fe f9 0d 52 	ld.w	r9,pc[3410]
800034e6:	92 08       	ld.sh	r8,r9[0x0]
800034e8:	fe fb 0d 58 	ld.w	r11,pc[3416]
800034ec:	76 0b       	ld.w	r11,r11[0x0]
800034ee:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800034f2:	2f f8       	sub	r8,-1
800034f4:	5c 88       	casts.h	r8
800034f6:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800034f8:	fe fa 0d 38 	ld.w	r10,pc[3384]
800034fc:	94 09       	ld.sh	r9,r10[0x0]
800034fe:	20 29       	sub	r9,2
80003500:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003502:	30 0a       	mov	r10,0
80003504:	f4 09 19 00 	cp.h	r9,r10
80003508:	e0 89 00 20 	brgt	80003548 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000350c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003510:	e0 46 00 ba 	cp.w	r6,186
80003514:	c0 d1       	brne	8000352e <phy_rx_func+0x18a>
80003516:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000351a:	90 09       	ld.sh	r9,r8[0x0]
8000351c:	f4 09 19 00 	cp.h	r9,r10
80003520:	c0 71       	brne	8000352e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003522:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003526:	70 0c       	ld.w	r12,r8[0x0]
80003528:	f0 1f 03 49 	mcall	8000424c <phy_rx_func+0xea8>
8000352c:	c0 98       	rjmp	8000353e <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000352e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003532:	70 0c       	ld.w	r12,r8[0x0]
80003534:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003538:	70 0b       	ld.w	r11,r8[0x0]
8000353a:	f0 1f 03 43 	mcall	80004244 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000353e:	30 09       	mov	r9,0
80003540:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003544:	91 09       	st.w	r8[0x0],r9
80003546:	c3 e8       	rjmp	800035c2 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003548:	5c 86       	casts.h	r6
8000354a:	fe f9 0c fe 	ld.w	r9,pc[3326]
8000354e:	92 0a       	ld.sh	r10,r9[0x0]
80003550:	0c 0a       	add	r10,r6
80003552:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003554:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003558:	72 09       	ld.w	r9,r9[0x0]
8000355a:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000355e:	2f f8       	sub	r8,-1
80003560:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003564:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003566:	fe f9 0c ca 	ld.w	r9,pc[3274]
8000356a:	92 08       	ld.sh	r8,r9[0x0]
8000356c:	20 28       	sub	r8,2
8000356e:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003570:	30 09       	mov	r9,0
80003572:	f2 08 19 00 	cp.h	r8,r9
80003576:	e0 89 00 26 	brgt	800035c2 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000357a:	30 39       	mov	r9,3
8000357c:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003580:	91 09       	st.w	r8[0x0],r9
80003582:	c2 08       	rjmp	800035c2 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003584:	e6 16 00 ff 	andh	r6,0xff,COH
80003588:	fc 19 00 ba 	movh	r9,0xba
8000358c:	12 36       	cp.w	r6,r9
8000358e:	c0 e1       	brne	800035aa <phy_rx_func+0x206>
80003590:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003594:	90 09       	ld.sh	r9,r8[0x0]
80003596:	30 08       	mov	r8,0
80003598:	f0 09 19 00 	cp.h	r9,r8
8000359c:	c0 71       	brne	800035aa <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000359e:	fe f8 0c a2 	ld.w	r8,pc[3234]
800035a2:	70 0c       	ld.w	r12,r8[0x0]
800035a4:	f0 1f 03 2a 	mcall	8000424c <phy_rx_func+0xea8>
800035a8:	c0 98       	rjmp	800035ba <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800035aa:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800035ae:	70 0c       	ld.w	r12,r8[0x0]
800035b0:	fe f8 0c 90 	ld.w	r8,pc[3216]
800035b4:	70 0b       	ld.w	r11,r8[0x0]
800035b6:	f0 1f 03 24 	mcall	80004244 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800035ba:	30 09       	mov	r9,0
800035bc:	fe f8 0c 70 	ld.w	r8,pc[3184]
800035c0:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
800035c2:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800035c6:	11 89       	ld.ub	r9,r8[0x0]
800035c8:	30 08       	mov	r8,0
800035ca:	f0 09 18 00 	cp.b	r9,r8
800035ce:	c1 31       	brne	800035f4 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800035d0:	fe f6 0c 84 	ld.w	r6,pc[3204]
800035d4:	6c 0c       	ld.w	r12,r6[0x0]
800035d6:	f0 1f 03 1a 	mcall	8000423c <phy_rx_func+0xe98>
800035da:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800035de:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800035e0:	6c 0c       	ld.w	r12,r6[0x0]
800035e2:	f0 1f 03 17 	mcall	8000423c <phy_rx_func+0xe98>
800035e6:	fe f8 0c 76 	ld.w	r8,pc[3190]
800035ea:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800035ec:	30 19       	mov	r9,1
800035ee:	fe f8 0c 62 	ld.w	r8,pc[3170]
800035f2:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800035f4:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800035f8:	70 08       	ld.w	r8,r8[0x0]
800035fa:	58 28       	cp.w	r8,2
800035fc:	e0 80 01 98 	breq	8000392c <phy_rx_func+0x588>
80003600:	e0 8b 00 06 	brhi	8000360c <phy_rx_func+0x268>
80003604:	58 08       	cp.w	r8,0
80003606:	c0 b0       	breq	8000361c <phy_rx_func+0x278>
80003608:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000360c:	58 38       	cp.w	r8,3
8000360e:	e0 80 05 c5 	breq	80004198 <phy_rx_func+0xdf4>
80003612:	58 48       	cp.w	r8,4
80003614:	e0 81 06 05 	brne	8000421e <phy_rx_func+0xe7a>
80003618:	e0 8f 02 4b 	bral	80003aae <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000361c:	6e 28       	ld.w	r8,r7[0x8]
8000361e:	e0 6a 5a 5a 	mov	r10,23130
80003622:	ea 1a ab cd 	orh	r10,0xabcd
80003626:	14 38       	cp.w	r8,r10
80003628:	c0 71       	brne	80003636 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000362a:	30 09       	mov	r9,0
8000362c:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003630:	91 09       	st.w	r8[0x0],r9
80003632:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003636:	10 99       	mov	r9,r8
80003638:	e0 19 00 00 	andl	r9,0x0
8000363c:	fc 1a ab cd 	movh	r10,0xabcd
80003640:	14 39       	cp.w	r9,r10
80003642:	e0 81 05 ee 	brne	8000421e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003646:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000364a:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000364e:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003650:	6e 29       	ld.w	r9,r7[0x8]
80003652:	e2 19 f0 00 	andl	r9,0xf000,COH
80003656:	e0 49 c0 00 	cp.w	r9,49152
8000365a:	e0 81 00 ce 	brne	800037f6 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000365e:	30 1a       	mov	r10,1
80003660:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003664:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003666:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000366a:	72 09       	ld.w	r9,r9[0x0]
8000366c:	58 09       	cp.w	r9,0
8000366e:	c0 71       	brne	8000367c <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003670:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003674:	f0 1f 03 00 	mcall	80004274 <phy_rx_func+0xed0>
80003678:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
8000367c:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003680:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003684:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003686:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000368a:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
8000368e:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003692:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003694:	13 89       	ld.ub	r9,r9[0x0]
80003696:	37 fa       	mov	r10,127
80003698:	f4 09 18 00 	cp.b	r9,r10
8000369c:	c6 d0       	breq	80003776 <phy_rx_func+0x3d2>
8000369e:	e0 8b 00 0c 	brhi	800036b6 <phy_rx_func+0x312>
800036a2:	31 2a       	mov	r10,18
800036a4:	f4 09 18 00 	cp.b	r9,r10
800036a8:	c4 20       	breq	8000372c <phy_rx_func+0x388>
800036aa:	31 3a       	mov	r10,19
800036ac:	f4 09 18 00 	cp.b	r9,r10
800036b0:	e0 81 00 83 	brne	800037b6 <phy_rx_func+0x412>
800036b4:	c5 b8       	rjmp	8000376a <phy_rx_func+0x3c6>
800036b6:	2f 09       	sub	r9,-16
800036b8:	30 1a       	mov	r10,1
800036ba:	f4 09 18 00 	cp.b	r9,r10
800036be:	e0 8b 00 7c 	brhi	800037b6 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800036c2:	ef 38 00 0e 	ld.ub	r8,r7[14]
800036c6:	e2 18 00 f0 	andl	r8,0xf0,COH
800036ca:	59 08       	cp.w	r8,16
800036cc:	c0 71       	brne	800036da <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800036ce:	30 19       	mov	r9,1
800036d0:	fe f8 0b 94 	ld.w	r8,pc[2964]
800036d4:	91 09       	st.w	r8[0x0],r9
800036d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800036da:	e0 48 00 20 	cp.w	r8,32
800036de:	c2 11       	brne	80003720 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
800036e0:	30 a9       	mov	r9,10
800036e2:	fe f8 0b 82 	ld.w	r8,pc[2946]
800036e6:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800036e8:	fe f6 0b 98 	ld.w	r6,pc[2968]
800036ec:	6c 08       	ld.w	r8,r6[0x0]
800036ee:	f0 0a 11 ff 	rsub	r10,r8,-1
800036f2:	fe f7 0b 6a 	ld.w	r7,pc[2922]
800036f6:	2f f8       	sub	r8,-1
800036f8:	6e 0c       	ld.w	r12,r7[0x0]
800036fa:	f4 ca fe 00 	sub	r10,r10,-512
800036fe:	30 0b       	mov	r11,0
80003700:	10 0c       	add	r12,r8
80003702:	f0 1f 02 e1 	mcall	80004284 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003706:	30 08       	mov	r8,0
80003708:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000370a:	6e 0c       	ld.w	r12,r7[0x0]
8000370c:	f0 1f 02 df 	mcall	80004288 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003710:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003714:	70 0c       	ld.w	r12,r8[0x0]
80003716:	f0 1f 02 ca 	mcall	8000423c <phy_rx_func+0xe98>
8000371a:	8f 0c       	st.w	r7[0x0],r12
8000371c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003720:	30 09       	mov	r9,0
80003722:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003726:	91 09       	st.w	r8[0x0],r9
80003728:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000372c:	20 48       	sub	r8,4
8000372e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003732:	93 08       	st.w	r9[0x0],r8
80003734:	58 08       	cp.w	r8,0
80003736:	e0 80 05 74 	breq	8000421e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000373a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000373e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003742:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003746:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003748:	8e 69       	ld.sh	r9,r7[0xc]
8000374a:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000374e:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003750:	8e 79       	ld.sh	r9,r7[0xe]
80003752:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003754:	f0 1f 02 d0 	mcall	80004294 <phy_rx_func+0xef0>
80003758:	fe f8 0b 0c 	ld.w	r8,pc[2828]
8000375c:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000375e:	30 49       	mov	r9,4
80003760:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003764:	91 09       	st.w	r8[0x0],r9
80003766:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000376a:	30 09       	mov	r9,0
8000376c:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003770:	91 09       	st.w	r8[0x0],r9
80003772:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003776:	20 48       	sub	r8,4
80003778:	fe f9 0a f0 	ld.w	r9,pc[2800]
8000377c:	93 08       	st.w	r9[0x0],r8
8000377e:	58 08       	cp.w	r8,0
80003780:	e0 80 05 4f 	breq	8000421e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003784:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003788:	70 09       	ld.w	r9,r8[0x0]
8000378a:	8e 7b       	ld.sh	r11,r7[0xe]
8000378c:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003790:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003794:	2f f9       	sub	r9,-1
80003796:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003798:	fe f8 0a e4 	ld.w	r8,pc[2788]
8000379c:	70 09       	ld.w	r9,r8[0x0]
8000379e:	20 29       	sub	r9,2
800037a0:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800037a2:	30 29       	mov	r9,2
800037a4:	fe f8 0a c0 	ld.w	r8,pc[2752]
800037a8:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800037aa:	30 39       	mov	r9,3
800037ac:	fe f8 0a b4 	ld.w	r8,pc[2740]
800037b0:	91 09       	st.w	r8[0x0],r9
800037b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800037b6:	30 3a       	mov	r10,3
800037b8:	fe f9 0a ac 	ld.w	r9,pc[2732]
800037bc:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800037be:	6e 2a       	ld.w	r10,r7[0x8]
800037c0:	fe f9 0a e0 	ld.w	r9,pc[2784]
800037c4:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800037c6:	6e 3a       	ld.w	r10,r7[0xc]
800037c8:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800037ca:	59 48       	cp.w	r8,20
800037cc:	c0 61       	brne	800037d8 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800037ce:	31 89       	mov	r9,24
800037d0:	fe f8 0a 98 	ld.w	r8,pc[2712]
800037d4:	91 09       	st.w	r8[0x0],r9
800037d6:	c0 a8       	rjmp	800037ea <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800037d8:	fe f8 0a 90 	ld.w	r8,pc[2704]
800037dc:	70 08       	ld.w	r8,r8[0x0]
800037de:	59 08       	cp.w	r8,16
800037e0:	c0 51       	brne	800037ea <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800037e2:	31 09       	mov	r9,16
800037e4:	fe f8 0a 84 	ld.w	r8,pc[2692]
800037e8:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800037ea:	30 49       	mov	r9,4
800037ec:	fe f8 0a 74 	ld.w	r8,pc[2676]
800037f0:	91 09       	st.w	r8[0x0],r9
800037f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800037f6:	e0 49 10 00 	cp.w	r9,4096
800037fa:	5f 1a       	srne	r10
800037fc:	e0 49 20 00 	cp.w	r9,8192
80003800:	5f 19       	srne	r9
80003802:	f5 e9 00 09 	and	r9,r10,r9
80003806:	e0 81 05 0c 	brne	8000421e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000380a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000380e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003810:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003814:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003816:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000381a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000381c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003820:	72 09       	ld.w	r9,r9[0x0]
80003822:	58 09       	cp.w	r9,0
80003824:	c0 71       	brne	80003832 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003826:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000382a:	f0 1f 02 93 	mcall	80004274 <phy_rx_func+0xed0>
8000382e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003832:	6e 2a       	ld.w	r10,r7[0x8]
80003834:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003838:	58 1a       	cp.w	r10,1
8000383a:	e0 8b 00 4d 	brhi	800038d4 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000383e:	20 48       	sub	r8,4
80003840:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003844:	93 08       	st.w	r9[0x0],r8
80003846:	58 08       	cp.w	r8,0
80003848:	e0 80 04 eb 	breq	8000421e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
8000384c:	8e 68       	ld.sh	r8,r7[0xc]
8000384e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003852:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003856:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003858:	30 09       	mov	r9,0
8000385a:	f2 08 19 00 	cp.h	r8,r9
8000385e:	c0 70       	breq	8000386c <phy_rx_func+0x4c8>
80003860:	30 19       	mov	r9,1
80003862:	f2 08 19 00 	cp.h	r8,r9
80003866:	e0 81 04 dc 	brne	8000421e <phy_rx_func+0xe7a>
8000386a:	c2 68       	rjmp	800038b6 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000386c:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003870:	70 0a       	ld.w	r10,r8[0x0]
80003872:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003876:	72 09       	ld.w	r9,r9[0x0]
80003878:	8e 7b       	ld.sh	r11,r7[0xe]
8000387a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
8000387e:	70 09       	ld.w	r9,r8[0x0]
80003880:	2f f9       	sub	r9,-1
80003882:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003884:	e0 49 00 ff 	cp.w	r9,255
80003888:	e0 88 00 11 	brls	800038aa <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
8000388c:	30 09       	mov	r9,0
8000388e:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003890:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003894:	6e 0c       	ld.w	r12,r7[0x0]
80003896:	f0 1f 02 7d 	mcall	80004288 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000389a:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000389e:	70 0c       	ld.w	r12,r8[0x0]
800038a0:	f0 1f 02 67 	mcall	8000423c <phy_rx_func+0xe98>
800038a4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800038a6:	e0 80 04 bc 	breq	8000421e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800038aa:	30 29       	mov	r9,2
800038ac:	fe f8 09 b4 	ld.w	r8,pc[2484]
800038b0:	91 09       	st.w	r8[0x0],r9
800038b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800038b6:	8e 79       	ld.sh	r9,r7[0xe]
800038b8:	30 38       	mov	r8,3
800038ba:	f0 09 19 00 	cp.h	r9,r8
800038be:	c0 51       	brne	800038c8 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800038c0:	30 19       	mov	r9,1
800038c2:	fe f8 09 f2 	ld.w	r8,pc[2546]
800038c6:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800038c8:	30 29       	mov	r9,2
800038ca:	fe f8 09 96 	ld.w	r8,pc[2454]
800038ce:	91 09       	st.w	r8[0x0],r9
800038d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800038d4:	58 18       	cp.w	r8,1
800038d6:	e0 88 04 a4 	brls	8000421e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800038da:	fe f8 09 d6 	ld.w	r8,pc[2518]
800038de:	70 0a       	ld.w	r10,r8[0x0]
800038e0:	6e 3b       	ld.w	r11,r7[0xc]
800038e2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800038e6:	70 09       	ld.w	r9,r8[0x0]
800038e8:	2f f9       	sub	r9,-1
800038ea:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800038ec:	e0 49 00 ff 	cp.w	r9,255
800038f0:	e0 88 00 11 	brls	80003912 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
800038f4:	30 09       	mov	r9,0
800038f6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800038f8:	fe f7 09 60 	ld.w	r7,pc[2400]
800038fc:	6e 0c       	ld.w	r12,r7[0x0]
800038fe:	f0 1f 02 63 	mcall	80004288 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003902:	fe f8 09 52 	ld.w	r8,pc[2386]
80003906:	70 0c       	ld.w	r12,r8[0x0]
80003908:	f0 1f 02 4d 	mcall	8000423c <phy_rx_func+0xe98>
8000390c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000390e:	e0 80 04 88 	breq	8000421e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003912:	fe f9 09 56 	ld.w	r9,pc[2390]
80003916:	72 08       	ld.w	r8,r9[0x0]
80003918:	20 28       	sub	r8,2
8000391a:	93 08       	st.w	r9[0x0],r8
8000391c:	e0 80 04 81 	breq	8000421e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003920:	30 29       	mov	r9,2
80003922:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003926:	91 09       	st.w	r8[0x0],r9
80003928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000392c:	fe f8 09 84 	ld.w	r8,pc[2436]
80003930:	70 0a       	ld.w	r10,r8[0x0]
80003932:	fe f9 09 26 	ld.w	r9,pc[2342]
80003936:	72 09       	ld.w	r9,r9[0x0]
80003938:	8e 4b       	ld.sh	r11,r7[0x8]
8000393a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000393e:	70 09       	ld.w	r9,r8[0x0]
80003940:	2f f9       	sub	r9,-1
80003942:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003944:	e0 49 00 ff 	cp.w	r9,255
80003948:	e0 88 00 16 	brls	80003974 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
8000394c:	30 09       	mov	r9,0
8000394e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003950:	fe f6 09 08 	ld.w	r6,pc[2312]
80003954:	6c 0c       	ld.w	r12,r6[0x0]
80003956:	f0 1f 02 4d 	mcall	80004288 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000395a:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000395e:	70 0c       	ld.w	r12,r8[0x0]
80003960:	f0 1f 02 37 	mcall	8000423c <phy_rx_func+0xe98>
80003964:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003966:	c0 71       	brne	80003974 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003968:	30 09       	mov	r9,0
8000396a:	fe f8 08 f6 	ld.w	r8,pc[2294]
8000396e:	91 09       	st.w	r8[0x0],r9
80003970:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003974:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003978:	72 08       	ld.w	r8,r9[0x0]
8000397a:	20 28       	sub	r8,2
8000397c:	93 08       	st.w	r9[0x0],r8
8000397e:	c0 71       	brne	8000398c <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003980:	30 09       	mov	r9,0
80003982:	fe f8 08 de 	ld.w	r8,pc[2270]
80003986:	91 09       	st.w	r8[0x0],r9
80003988:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000398c:	fe f8 09 24 	ld.w	r8,pc[2340]
80003990:	70 0a       	ld.w	r10,r8[0x0]
80003992:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003996:	72 09       	ld.w	r9,r9[0x0]
80003998:	8e 5b       	ld.sh	r11,r7[0xa]
8000399a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000399e:	70 09       	ld.w	r9,r8[0x0]
800039a0:	2f f9       	sub	r9,-1
800039a2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800039a4:	e0 49 00 ff 	cp.w	r9,255
800039a8:	e0 88 00 16 	brls	800039d4 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800039ac:	30 09       	mov	r9,0
800039ae:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800039b0:	fe f6 08 a8 	ld.w	r6,pc[2216]
800039b4:	6c 0c       	ld.w	r12,r6[0x0]
800039b6:	f0 1f 02 35 	mcall	80004288 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800039ba:	fe f8 08 9a 	ld.w	r8,pc[2202]
800039be:	70 0c       	ld.w	r12,r8[0x0]
800039c0:	f0 1f 02 1f 	mcall	8000423c <phy_rx_func+0xe98>
800039c4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800039c6:	c0 71       	brne	800039d4 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800039c8:	30 09       	mov	r9,0
800039ca:	fe f8 08 96 	ld.w	r8,pc[2198]
800039ce:	91 09       	st.w	r8[0x0],r9
800039d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800039d4:	fe f9 08 94 	ld.w	r9,pc[2196]
800039d8:	72 08       	ld.w	r8,r9[0x0]
800039da:	20 28       	sub	r8,2
800039dc:	93 08       	st.w	r9[0x0],r8
800039de:	c0 71       	brne	800039ec <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
800039e0:	30 09       	mov	r9,0
800039e2:	fe f8 08 7e 	ld.w	r8,pc[2174]
800039e6:	91 09       	st.w	r8[0x0],r9
800039e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800039ec:	fe f8 08 c4 	ld.w	r8,pc[2244]
800039f0:	70 0a       	ld.w	r10,r8[0x0]
800039f2:	fe f9 08 66 	ld.w	r9,pc[2150]
800039f6:	72 09       	ld.w	r9,r9[0x0]
800039f8:	8e 6b       	ld.sh	r11,r7[0xc]
800039fa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800039fe:	70 09       	ld.w	r9,r8[0x0]
80003a00:	2f f9       	sub	r9,-1
80003a02:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003a04:	e0 49 00 ff 	cp.w	r9,255
80003a08:	e0 88 00 16 	brls	80003a34 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003a0c:	30 09       	mov	r9,0
80003a0e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003a10:	fe f6 08 48 	ld.w	r6,pc[2120]
80003a14:	6c 0c       	ld.w	r12,r6[0x0]
80003a16:	f0 1f 02 1d 	mcall	80004288 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003a1a:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003a1e:	70 0c       	ld.w	r12,r8[0x0]
80003a20:	f0 1f 02 07 	mcall	8000423c <phy_rx_func+0xe98>
80003a24:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003a26:	c0 71       	brne	80003a34 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003a28:	30 09       	mov	r9,0
80003a2a:	fe f8 08 36 	ld.w	r8,pc[2102]
80003a2e:	91 09       	st.w	r8[0x0],r9
80003a30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003a34:	fe f9 08 34 	ld.w	r9,pc[2100]
80003a38:	72 08       	ld.w	r8,r9[0x0]
80003a3a:	20 28       	sub	r8,2
80003a3c:	93 08       	st.w	r9[0x0],r8
80003a3e:	c0 71       	brne	80003a4c <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003a40:	30 09       	mov	r9,0
80003a42:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003a46:	91 09       	st.w	r8[0x0],r9
80003a48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003a4c:	fe f8 08 64 	ld.w	r8,pc[2148]
80003a50:	70 0a       	ld.w	r10,r8[0x0]
80003a52:	fe f9 08 06 	ld.w	r9,pc[2054]
80003a56:	72 09       	ld.w	r9,r9[0x0]
80003a58:	8e 7b       	ld.sh	r11,r7[0xe]
80003a5a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003a5e:	70 09       	ld.w	r9,r8[0x0]
80003a60:	2f f9       	sub	r9,-1
80003a62:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003a64:	e0 49 00 ff 	cp.w	r9,255
80003a68:	e0 88 00 16 	brls	80003a94 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003a6c:	30 09       	mov	r9,0
80003a6e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003a70:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003a74:	6e 0c       	ld.w	r12,r7[0x0]
80003a76:	f0 1f 02 05 	mcall	80004288 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003a7a:	fe f8 07 da 	ld.w	r8,pc[2010]
80003a7e:	70 0c       	ld.w	r12,r8[0x0]
80003a80:	f0 1f 01 ef 	mcall	8000423c <phy_rx_func+0xe98>
80003a84:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003a86:	c0 71       	brne	80003a94 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003a88:	30 09       	mov	r9,0
80003a8a:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003a8e:	91 09       	st.w	r8[0x0],r9
80003a90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003a94:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003a98:	72 08       	ld.w	r8,r9[0x0]
80003a9a:	20 28       	sub	r8,2
80003a9c:	93 08       	st.w	r9[0x0],r8
80003a9e:	e0 81 03 c0 	brne	8000421e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003aa2:	30 09       	mov	r9,0
80003aa4:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003aa8:	91 09       	st.w	r8[0x0],r9
80003aaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003aae:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003ab2:	11 89       	ld.ub	r9,r8[0x0]
80003ab4:	31 28       	mov	r8,18
80003ab6:	f0 09 18 00 	cp.b	r9,r8
80003aba:	e0 81 01 4c 	brne	80003d52 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003abe:	ef 39 00 09 	ld.ub	r9,r7[9]
80003ac2:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003ac6:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003ac8:	11 89       	ld.ub	r9,r8[0x0]
80003aca:	3f 28       	mov	r8,-14
80003acc:	f0 09 18 00 	cp.b	r9,r8
80003ad0:	e0 81 01 3b 	brne	80003d46 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003ad4:	30 19       	mov	r9,1
80003ad6:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003ada:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003adc:	6e 29       	ld.w	r9,r7[0x8]
80003ade:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003ae2:	fe f8 07 86 	ld.w	r8,pc[1926]
80003ae6:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003ae8:	8e 59       	ld.sh	r9,r7[0xa]
80003aea:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003aee:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003af0:	8e 69       	ld.sh	r9,r7[0xc]
80003af2:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003af4:	8e 79       	ld.sh	r9,r7[0xe]
80003af6:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003af8:	fe f8 07 88 	ld.w	r8,pc[1928]
80003afc:	fe f9 07 60 	ld.w	r9,pc[1888]
80003b00:	72 0a       	ld.w	r10,r9[0x0]
80003b02:	70 09       	ld.w	r9,r8[0x0]
80003b04:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b08:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b0c:	70 09       	ld.w	r9,r8[0x0]
80003b0e:	2f f9       	sub	r9,-1
80003b10:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b12:	e0 49 01 ff 	cp.w	r9,511
80003b16:	e0 88 00 16 	brls	80003b42 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b1a:	30 09       	mov	r9,0
80003b1c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b1e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003b22:	6c 0c       	ld.w	r12,r6[0x0]
80003b24:	f0 1f 01 d9 	mcall	80004288 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b28:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003b2c:	70 0c       	ld.w	r12,r8[0x0]
80003b2e:	f0 1f 01 c4 	mcall	8000423c <phy_rx_func+0xe98>
80003b32:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b34:	c0 71       	brne	80003b42 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003b36:	30 09       	mov	r9,0
80003b38:	fe f8 07 28 	ld.w	r8,pc[1832]
80003b3c:	91 09       	st.w	r8[0x0],r9
80003b3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b42:	fe f9 07 26 	ld.w	r9,pc[1830]
80003b46:	72 08       	ld.w	r8,r9[0x0]
80003b48:	20 18       	sub	r8,1
80003b4a:	93 08       	st.w	r9[0x0],r8
80003b4c:	c0 71       	brne	80003b5a <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003b4e:	30 09       	mov	r9,0
80003b50:	fe f8 07 10 	ld.w	r8,pc[1808]
80003b54:	91 09       	st.w	r8[0x0],r9
80003b56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003b5a:	fe f8 07 26 	ld.w	r8,pc[1830]
80003b5e:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003b62:	72 0a       	ld.w	r10,r9[0x0]
80003b64:	70 09       	ld.w	r9,r8[0x0]
80003b66:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003b6a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b6e:	70 09       	ld.w	r9,r8[0x0]
80003b70:	2f f9       	sub	r9,-1
80003b72:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b74:	e0 49 01 ff 	cp.w	r9,511
80003b78:	e0 88 00 16 	brls	80003ba4 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b7c:	30 09       	mov	r9,0
80003b7e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b80:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003b84:	6c 0c       	ld.w	r12,r6[0x0]
80003b86:	f0 1f 01 c1 	mcall	80004288 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b8a:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003b8e:	70 0c       	ld.w	r12,r8[0x0]
80003b90:	f0 1f 01 ab 	mcall	8000423c <phy_rx_func+0xe98>
80003b94:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b96:	c0 71       	brne	80003ba4 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003b98:	30 09       	mov	r9,0
80003b9a:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003b9e:	91 09       	st.w	r8[0x0],r9
80003ba0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003ba4:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003ba8:	72 08       	ld.w	r8,r9[0x0]
80003baa:	20 18       	sub	r8,1
80003bac:	93 08       	st.w	r9[0x0],r8
80003bae:	c0 71       	brne	80003bbc <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003bb0:	30 09       	mov	r9,0
80003bb2:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003bb6:	91 09       	st.w	r8[0x0],r9
80003bb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003bbc:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003bc0:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003bc4:	72 0a       	ld.w	r10,r9[0x0]
80003bc6:	70 09       	ld.w	r9,r8[0x0]
80003bc8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003bcc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003bd0:	70 09       	ld.w	r9,r8[0x0]
80003bd2:	2f f9       	sub	r9,-1
80003bd4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bd6:	e0 49 01 ff 	cp.w	r9,511
80003bda:	e0 88 00 16 	brls	80003c06 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bde:	30 09       	mov	r9,0
80003be0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003be2:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003be6:	6c 0c       	ld.w	r12,r6[0x0]
80003be8:	f0 1f 01 a8 	mcall	80004288 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bec:	fe f8 06 68 	ld.w	r8,pc[1640]
80003bf0:	70 0c       	ld.w	r12,r8[0x0]
80003bf2:	f0 1f 01 93 	mcall	8000423c <phy_rx_func+0xe98>
80003bf6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003bf8:	c0 71       	brne	80003c06 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003bfa:	30 09       	mov	r9,0
80003bfc:	fe f8 06 64 	ld.w	r8,pc[1636]
80003c00:	91 09       	st.w	r8[0x0],r9
80003c02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c06:	fe f9 06 62 	ld.w	r9,pc[1634]
80003c0a:	72 08       	ld.w	r8,r9[0x0]
80003c0c:	20 18       	sub	r8,1
80003c0e:	93 08       	st.w	r9[0x0],r8
80003c10:	c0 71       	brne	80003c1e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003c12:	30 09       	mov	r9,0
80003c14:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003c18:	91 09       	st.w	r8[0x0],r9
80003c1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003c1e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003c22:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003c26:	72 0a       	ld.w	r10,r9[0x0]
80003c28:	70 09       	ld.w	r9,r8[0x0]
80003c2a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003c2e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c32:	70 09       	ld.w	r9,r8[0x0]
80003c34:	2f f9       	sub	r9,-1
80003c36:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c38:	e0 49 01 ff 	cp.w	r9,511
80003c3c:	e0 88 00 16 	brls	80003c68 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c40:	30 09       	mov	r9,0
80003c42:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c44:	fe f6 06 18 	ld.w	r6,pc[1560]
80003c48:	6c 0c       	ld.w	r12,r6[0x0]
80003c4a:	f0 1f 01 90 	mcall	80004288 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c4e:	fe f8 06 06 	ld.w	r8,pc[1542]
80003c52:	70 0c       	ld.w	r12,r8[0x0]
80003c54:	f0 1f 01 7a 	mcall	8000423c <phy_rx_func+0xe98>
80003c58:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c5a:	c0 71       	brne	80003c68 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003c5c:	30 09       	mov	r9,0
80003c5e:	fe f8 06 02 	ld.w	r8,pc[1538]
80003c62:	91 09       	st.w	r8[0x0],r9
80003c64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c68:	fe f9 06 00 	ld.w	r9,pc[1536]
80003c6c:	72 08       	ld.w	r8,r9[0x0]
80003c6e:	20 18       	sub	r8,1
80003c70:	93 08       	st.w	r9[0x0],r8
80003c72:	c0 71       	brne	80003c80 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003c74:	30 09       	mov	r9,0
80003c76:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003c7a:	91 09       	st.w	r8[0x0],r9
80003c7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003c80:	fe f8 06 00 	ld.w	r8,pc[1536]
80003c84:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003c88:	72 0a       	ld.w	r10,r9[0x0]
80003c8a:	70 09       	ld.w	r9,r8[0x0]
80003c8c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003c90:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c94:	70 09       	ld.w	r9,r8[0x0]
80003c96:	2f f9       	sub	r9,-1
80003c98:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c9a:	e0 49 01 ff 	cp.w	r9,511
80003c9e:	e0 88 00 16 	brls	80003cca <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ca2:	30 09       	mov	r9,0
80003ca4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ca6:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003caa:	6c 0c       	ld.w	r12,r6[0x0]
80003cac:	f0 1f 01 77 	mcall	80004288 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003cb0:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003cb4:	70 0c       	ld.w	r12,r8[0x0]
80003cb6:	f0 1f 01 62 	mcall	8000423c <phy_rx_func+0xe98>
80003cba:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003cbc:	c0 71       	brne	80003cca <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003cbe:	30 09       	mov	r9,0
80003cc0:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003cc4:	91 09       	st.w	r8[0x0],r9
80003cc6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003cca:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003cce:	72 08       	ld.w	r8,r9[0x0]
80003cd0:	20 18       	sub	r8,1
80003cd2:	93 08       	st.w	r9[0x0],r8
80003cd4:	c0 71       	brne	80003ce2 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003cd6:	30 09       	mov	r9,0
80003cd8:	fe f8 05 88 	ld.w	r8,pc[1416]
80003cdc:	91 09       	st.w	r8[0x0],r9
80003cde:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003ce2:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003ce6:	fe f9 05 76 	ld.w	r9,pc[1398]
80003cea:	72 0a       	ld.w	r10,r9[0x0]
80003cec:	70 09       	ld.w	r9,r8[0x0]
80003cee:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003cf2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003cf6:	70 09       	ld.w	r9,r8[0x0]
80003cf8:	2f f9       	sub	r9,-1
80003cfa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cfc:	e0 49 01 ff 	cp.w	r9,511
80003d00:	e0 88 00 16 	brls	80003d2c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d04:	30 09       	mov	r9,0
80003d06:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d08:	fe f7 05 54 	ld.w	r7,pc[1364]
80003d0c:	6e 0c       	ld.w	r12,r7[0x0]
80003d0e:	f0 1f 01 5f 	mcall	80004288 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d12:	fe f8 05 42 	ld.w	r8,pc[1346]
80003d16:	70 0c       	ld.w	r12,r8[0x0]
80003d18:	f0 1f 01 49 	mcall	8000423c <phy_rx_func+0xe98>
80003d1c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d1e:	c0 71       	brne	80003d2c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003d20:	30 09       	mov	r9,0
80003d22:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003d26:	91 09       	st.w	r8[0x0],r9
80003d28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d2c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003d30:	72 08       	ld.w	r8,r9[0x0]
80003d32:	20 18       	sub	r8,1
80003d34:	93 08       	st.w	r9[0x0],r8
80003d36:	e0 81 02 74 	brne	8000421e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003d3a:	30 09       	mov	r9,0
80003d3c:	fe f8 05 24 	ld.w	r8,pc[1316]
80003d40:	91 09       	st.w	r8[0x0],r9
80003d42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003d46:	30 09       	mov	r9,0
80003d48:	fe f8 05 18 	ld.w	r8,pc[1304]
80003d4c:	91 09       	st.w	r8[0x0],r9
80003d4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003d52:	fe f8 05 26 	ld.w	r8,pc[1318]
80003d56:	11 89       	ld.ub	r9,r8[0x0]
80003d58:	3f 28       	mov	r8,-14
80003d5a:	f0 09 18 00 	cp.b	r9,r8
80003d5e:	c4 31       	brne	80003de4 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003d60:	8e 49       	ld.sh	r9,r7[0x8]
80003d62:	fe f8 05 56 	ld.w	r8,pc[1366]
80003d66:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003d68:	fe f8 05 18 	ld.w	r8,pc[1304]
80003d6c:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003d70:	72 0a       	ld.w	r10,r9[0x0]
80003d72:	70 09       	ld.w	r9,r8[0x0]
80003d74:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003d78:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d7c:	70 09       	ld.w	r9,r8[0x0]
80003d7e:	2f f9       	sub	r9,-1
80003d80:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d82:	e0 49 01 ff 	cp.w	r9,511
80003d86:	e0 88 00 16 	brls	80003db2 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d8a:	30 09       	mov	r9,0
80003d8c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d8e:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003d92:	6e 0c       	ld.w	r12,r7[0x0]
80003d94:	f0 1f 01 3d 	mcall	80004288 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d98:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003d9c:	70 0c       	ld.w	r12,r8[0x0]
80003d9e:	f0 1f 01 28 	mcall	8000423c <phy_rx_func+0xe98>
80003da2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003da4:	c0 71       	brne	80003db2 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003da6:	30 09       	mov	r9,0
80003da8:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003dac:	91 09       	st.w	r8[0x0],r9
80003dae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003db2:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003db6:	72 08       	ld.w	r8,r9[0x0]
80003db8:	20 18       	sub	r8,1
80003dba:	93 08       	st.w	r9[0x0],r8
80003dbc:	c0 71       	brne	80003dca <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003dbe:	30 09       	mov	r9,0
80003dc0:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003dc4:	91 09       	st.w	r8[0x0],r9
80003dc6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003dca:	20 18       	sub	r8,1
80003dcc:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003dd0:	93 08       	st.w	r9[0x0],r8
80003dd2:	58 08       	cp.w	r8,0
80003dd4:	e0 81 02 25 	brne	8000421e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003dd8:	30 09       	mov	r9,0
80003dda:	fe f8 04 86 	ld.w	r8,pc[1158]
80003dde:	91 09       	st.w	r8[0x0],r9
80003de0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003de4:	fe f8 04 94 	ld.w	r8,pc[1172]
80003de8:	11 89       	ld.ub	r9,r8[0x0]
80003dea:	3f 38       	mov	r8,-13
80003dec:	f0 09 18 00 	cp.b	r9,r8
80003df0:	e0 81 01 0c 	brne	80004008 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003df4:	8e 49       	ld.sh	r9,r7[0x8]
80003df6:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003dfa:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003dfc:	8e 59       	ld.sh	r9,r7[0xa]
80003dfe:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003e00:	8e 69       	ld.sh	r9,r7[0xc]
80003e02:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003e04:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003e08:	fe f9 04 54 	ld.w	r9,pc[1108]
80003e0c:	72 0a       	ld.w	r10,r9[0x0]
80003e0e:	70 09       	ld.w	r9,r8[0x0]
80003e10:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003e14:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e18:	70 09       	ld.w	r9,r8[0x0]
80003e1a:	2f f9       	sub	r9,-1
80003e1c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e1e:	e0 49 01 ff 	cp.w	r9,511
80003e22:	e0 88 00 16 	brls	80003e4e <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e26:	30 09       	mov	r9,0
80003e28:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e2a:	fe f6 04 32 	ld.w	r6,pc[1074]
80003e2e:	6c 0c       	ld.w	r12,r6[0x0]
80003e30:	f0 1f 01 16 	mcall	80004288 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e34:	fe f8 04 20 	ld.w	r8,pc[1056]
80003e38:	70 0c       	ld.w	r12,r8[0x0]
80003e3a:	f0 1f 01 01 	mcall	8000423c <phy_rx_func+0xe98>
80003e3e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e40:	c0 71       	brne	80003e4e <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003e42:	30 09       	mov	r9,0
80003e44:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003e48:	91 09       	st.w	r8[0x0],r9
80003e4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e4e:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003e52:	72 08       	ld.w	r8,r9[0x0]
80003e54:	20 18       	sub	r8,1
80003e56:	93 08       	st.w	r9[0x0],r8
80003e58:	c0 71       	brne	80003e66 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003e5a:	30 09       	mov	r9,0
80003e5c:	fe f8 04 04 	ld.w	r8,pc[1028]
80003e60:	91 09       	st.w	r8[0x0],r9
80003e62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003e66:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003e6a:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003e6e:	72 0a       	ld.w	r10,r9[0x0]
80003e70:	70 09       	ld.w	r9,r8[0x0]
80003e72:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003e76:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e7a:	70 09       	ld.w	r9,r8[0x0]
80003e7c:	2f f9       	sub	r9,-1
80003e7e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e80:	e0 49 01 ff 	cp.w	r9,511
80003e84:	e0 88 00 16 	brls	80003eb0 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e88:	30 09       	mov	r9,0
80003e8a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e8c:	fe f6 03 d0 	ld.w	r6,pc[976]
80003e90:	6c 0c       	ld.w	r12,r6[0x0]
80003e92:	f0 1f 00 fe 	mcall	80004288 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e96:	fe f8 03 be 	ld.w	r8,pc[958]
80003e9a:	70 0c       	ld.w	r12,r8[0x0]
80003e9c:	f0 1f 00 e8 	mcall	8000423c <phy_rx_func+0xe98>
80003ea0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ea2:	c0 71       	brne	80003eb0 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003ea4:	30 09       	mov	r9,0
80003ea6:	fe f8 03 ba 	ld.w	r8,pc[954]
80003eaa:	91 09       	st.w	r8[0x0],r9
80003eac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003eb0:	fe f9 03 b8 	ld.w	r9,pc[952]
80003eb4:	72 08       	ld.w	r8,r9[0x0]
80003eb6:	20 18       	sub	r8,1
80003eb8:	93 08       	st.w	r9[0x0],r8
80003eba:	c0 71       	brne	80003ec8 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003ebc:	30 09       	mov	r9,0
80003ebe:	fe f8 03 a2 	ld.w	r8,pc[930]
80003ec2:	91 09       	st.w	r8[0x0],r9
80003ec4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003ec8:	fe f8 03 b8 	ld.w	r8,pc[952]
80003ecc:	fe f9 03 90 	ld.w	r9,pc[912]
80003ed0:	72 0a       	ld.w	r10,r9[0x0]
80003ed2:	70 09       	ld.w	r9,r8[0x0]
80003ed4:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003ed8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003edc:	70 09       	ld.w	r9,r8[0x0]
80003ede:	2f f9       	sub	r9,-1
80003ee0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ee2:	e0 49 01 ff 	cp.w	r9,511
80003ee6:	e0 88 00 16 	brls	80003f12 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003eea:	30 09       	mov	r9,0
80003eec:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003eee:	fe f6 03 6e 	ld.w	r6,pc[878]
80003ef2:	6c 0c       	ld.w	r12,r6[0x0]
80003ef4:	f0 1f 00 e5 	mcall	80004288 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ef8:	fe f8 03 5c 	ld.w	r8,pc[860]
80003efc:	70 0c       	ld.w	r12,r8[0x0]
80003efe:	f0 1f 00 d0 	mcall	8000423c <phy_rx_func+0xe98>
80003f02:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f04:	c0 71       	brne	80003f12 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003f06:	30 09       	mov	r9,0
80003f08:	fe f8 03 58 	ld.w	r8,pc[856]
80003f0c:	91 09       	st.w	r8[0x0],r9
80003f0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f12:	fe f9 03 56 	ld.w	r9,pc[854]
80003f16:	72 08       	ld.w	r8,r9[0x0]
80003f18:	20 18       	sub	r8,1
80003f1a:	93 08       	st.w	r9[0x0],r8
80003f1c:	c0 71       	brne	80003f2a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003f1e:	30 09       	mov	r9,0
80003f20:	fe f8 03 40 	ld.w	r8,pc[832]
80003f24:	91 09       	st.w	r8[0x0],r9
80003f26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003f2a:	fe f8 03 56 	ld.w	r8,pc[854]
80003f2e:	fe f9 03 2e 	ld.w	r9,pc[814]
80003f32:	72 0a       	ld.w	r10,r9[0x0]
80003f34:	70 09       	ld.w	r9,r8[0x0]
80003f36:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f3a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f3e:	70 09       	ld.w	r9,r8[0x0]
80003f40:	2f f9       	sub	r9,-1
80003f42:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f44:	e0 49 01 ff 	cp.w	r9,511
80003f48:	e0 88 00 16 	brls	80003f74 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f4c:	30 09       	mov	r9,0
80003f4e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f50:	fe f6 03 0c 	ld.w	r6,pc[780]
80003f54:	6c 0c       	ld.w	r12,r6[0x0]
80003f56:	f0 1f 00 cd 	mcall	80004288 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f5a:	fe f8 02 fa 	ld.w	r8,pc[762]
80003f5e:	70 0c       	ld.w	r12,r8[0x0]
80003f60:	f0 1f 00 b7 	mcall	8000423c <phy_rx_func+0xe98>
80003f64:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f66:	c0 71       	brne	80003f74 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003f68:	30 09       	mov	r9,0
80003f6a:	fe f8 02 f6 	ld.w	r8,pc[758]
80003f6e:	91 09       	st.w	r8[0x0],r9
80003f70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f74:	fe f9 02 f4 	ld.w	r9,pc[756]
80003f78:	72 08       	ld.w	r8,r9[0x0]
80003f7a:	20 18       	sub	r8,1
80003f7c:	93 08       	st.w	r9[0x0],r8
80003f7e:	c0 71       	brne	80003f8c <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003f80:	30 09       	mov	r9,0
80003f82:	fe f8 02 de 	ld.w	r8,pc[734]
80003f86:	91 09       	st.w	r8[0x0],r9
80003f88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003f8c:	fe f8 02 f4 	ld.w	r8,pc[756]
80003f90:	fe f9 02 cc 	ld.w	r9,pc[716]
80003f94:	72 0a       	ld.w	r10,r9[0x0]
80003f96:	70 09       	ld.w	r9,r8[0x0]
80003f98:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003f9c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003fa0:	70 09       	ld.w	r9,r8[0x0]
80003fa2:	2f f9       	sub	r9,-1
80003fa4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fa6:	e0 49 01 ff 	cp.w	r9,511
80003faa:	e0 88 00 16 	brls	80003fd6 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003fae:	30 09       	mov	r9,0
80003fb0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fb2:	fe f7 02 aa 	ld.w	r7,pc[682]
80003fb6:	6e 0c       	ld.w	r12,r7[0x0]
80003fb8:	f0 1f 00 b4 	mcall	80004288 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fbc:	fe f8 02 98 	ld.w	r8,pc[664]
80003fc0:	70 0c       	ld.w	r12,r8[0x0]
80003fc2:	f0 1f 00 9f 	mcall	8000423c <phy_rx_func+0xe98>
80003fc6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fc8:	c0 71       	brne	80003fd6 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003fca:	30 09       	mov	r9,0
80003fcc:	fe f8 02 94 	ld.w	r8,pc[660]
80003fd0:	91 09       	st.w	r8[0x0],r9
80003fd2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003fd6:	fe f9 02 92 	ld.w	r9,pc[658]
80003fda:	72 08       	ld.w	r8,r9[0x0]
80003fdc:	20 18       	sub	r8,1
80003fde:	93 08       	st.w	r9[0x0],r8
80003fe0:	c0 71       	brne	80003fee <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003fe2:	30 09       	mov	r9,0
80003fe4:	fe f8 02 7c 	ld.w	r8,pc[636]
80003fe8:	91 09       	st.w	r8[0x0],r9
80003fea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003fee:	20 18       	sub	r8,1
80003ff0:	fe f9 02 78 	ld.w	r9,pc[632]
80003ff4:	93 08       	st.w	r9[0x0],r8
80003ff6:	58 08       	cp.w	r8,0
80003ff8:	e0 81 01 13 	brne	8000421e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003ffc:	30 09       	mov	r9,0
80003ffe:	fe f8 02 62 	ld.w	r8,pc[610]
80004002:	91 09       	st.w	r8[0x0],r9
80004004:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004008:	fe f8 02 70 	ld.w	r8,pc[624]
8000400c:	11 89       	ld.ub	r9,r8[0x0]
8000400e:	30 48       	mov	r8,4
80004010:	f0 09 18 00 	cp.b	r9,r8
80004014:	c0 80       	breq	80004024 <phy_rx_func+0xc80>
80004016:	fe f8 02 62 	ld.w	r8,pc[610]
8000401a:	11 89       	ld.ub	r9,r8[0x0]
8000401c:	30 38       	mov	r8,3
8000401e:	f0 09 18 00 	cp.b	r9,r8
80004022:	c1 41       	brne	8000404a <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004024:	6e 29       	ld.w	r9,r7[0x8]
80004026:	fe f8 02 7a 	ld.w	r8,pc[634]
8000402a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
8000402c:	6e 39       	ld.w	r9,r7[0xc]
8000402e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004030:	fe f9 02 38 	ld.w	r9,pc[568]
80004034:	72 08       	ld.w	r8,r9[0x0]
80004036:	20 88       	sub	r8,8
80004038:	93 08       	st.w	r9[0x0],r8
8000403a:	e0 81 00 f2 	brne	8000421e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
8000403e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004040:	fe f9 02 20 	ld.w	r9,pc[544]
80004044:	93 08       	st.w	r9[0x0],r8
80004046:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000404a:	fe f8 02 2e 	ld.w	r8,pc[558]
8000404e:	11 89       	ld.ub	r9,r8[0x0]
80004050:	31 38       	mov	r8,19
80004052:	f0 09 18 00 	cp.b	r9,r8
80004056:	e0 81 00 9c 	brne	8000418e <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
8000405a:	fe f8 02 62 	ld.w	r8,pc[610]
8000405e:	11 88       	ld.ub	r8,r8[0x0]
80004060:	30 c9       	mov	r9,12
80004062:	f2 08 18 00 	cp.b	r8,r9
80004066:	e0 81 00 7b 	brne	8000415c <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
8000406a:	8e 49       	ld.sh	r9,r7[0x8]
8000406c:	fe f8 02 54 	ld.w	r8,pc[596]
80004070:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80004074:	30 09       	mov	r9,0
80004076:	fe f8 02 46 	ld.w	r8,pc[582]
8000407a:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000407c:	ef 39 00 0d 	ld.ub	r9,r7[13]
80004080:	3f 38       	mov	r8,-13
80004082:	f0 09 18 00 	cp.b	r9,r8
80004086:	c6 61       	brne	80004152 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80004088:	10 99       	mov	r9,r8
8000408a:	4f c8       	lddpc	r8,80004278 <phy_rx_func+0xed4>
8000408c:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
8000408e:	ef 39 00 0c 	ld.ub	r9,r7[12]
80004092:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80004096:	4f 58       	lddpc	r8,80004268 <phy_rx_func+0xec4>
80004098:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
8000409a:	30 19       	mov	r9,1
8000409c:	fe f8 02 0c 	ld.w	r8,pc[524]
800040a0:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800040a2:	8e 79       	ld.sh	r9,r7[0xe]
800040a4:	fe f8 02 14 	ld.w	r8,pc[532]
800040a8:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800040aa:	4f 68       	lddpc	r8,80004280 <phy_rx_func+0xedc>
800040ac:	4e c9       	lddpc	r9,8000425c <phy_rx_func+0xeb8>
800040ae:	72 0a       	ld.w	r10,r9[0x0]
800040b0:	70 09       	ld.w	r9,r8[0x0]
800040b2:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800040b6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800040ba:	70 09       	ld.w	r9,r8[0x0]
800040bc:	2f f9       	sub	r9,-1
800040be:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800040c0:	e0 49 01 ff 	cp.w	r9,511
800040c4:	e0 88 00 13 	brls	800040ea <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800040c8:	30 09       	mov	r9,0
800040ca:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800040cc:	4e 46       	lddpc	r6,8000425c <phy_rx_func+0xeb8>
800040ce:	6c 0c       	ld.w	r12,r6[0x0]
800040d0:	f0 1f 00 6e 	mcall	80004288 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800040d4:	4e 08       	lddpc	r8,80004254 <phy_rx_func+0xeb0>
800040d6:	70 0c       	ld.w	r12,r8[0x0]
800040d8:	f0 1f 00 59 	mcall	8000423c <phy_rx_func+0xe98>
800040dc:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
800040de:	c0 61       	brne	800040ea <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
800040e0:	30 09       	mov	r9,0
800040e2:	4e 08       	lddpc	r8,80004260 <phy_rx_func+0xebc>
800040e4:	91 09       	st.w	r8[0x0],r9
800040e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800040ea:	4e 09       	lddpc	r9,80004268 <phy_rx_func+0xec4>
800040ec:	72 08       	ld.w	r8,r9[0x0]
800040ee:	20 18       	sub	r8,1
800040f0:	93 08       	st.w	r9[0x0],r8
800040f2:	c0 61       	brne	800040fe <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
800040f4:	30 09       	mov	r9,0
800040f6:	4d b8       	lddpc	r8,80004260 <phy_rx_func+0xebc>
800040f8:	91 09       	st.w	r8[0x0],r9
800040fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
800040fe:	4e 18       	lddpc	r8,80004280 <phy_rx_func+0xedc>
80004100:	4d 79       	lddpc	r9,8000425c <phy_rx_func+0xeb8>
80004102:	72 0a       	ld.w	r10,r9[0x0]
80004104:	70 09       	ld.w	r9,r8[0x0]
80004106:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000410a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000410e:	70 09       	ld.w	r9,r8[0x0]
80004110:	2f f9       	sub	r9,-1
80004112:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004114:	e0 49 01 ff 	cp.w	r9,511
80004118:	e0 88 00 13 	brls	8000413e <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
8000411c:	30 09       	mov	r9,0
8000411e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004120:	4c f7       	lddpc	r7,8000425c <phy_rx_func+0xeb8>
80004122:	6e 0c       	ld.w	r12,r7[0x0]
80004124:	f0 1f 00 59 	mcall	80004288 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80004128:	4c b8       	lddpc	r8,80004254 <phy_rx_func+0xeb0>
8000412a:	70 0c       	ld.w	r12,r8[0x0]
8000412c:	f0 1f 00 44 	mcall	8000423c <phy_rx_func+0xe98>
80004130:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004132:	c0 61       	brne	8000413e <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80004134:	30 09       	mov	r9,0
80004136:	4c b8       	lddpc	r8,80004260 <phy_rx_func+0xebc>
80004138:	91 09       	st.w	r8[0x0],r9
8000413a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000413e:	4c b9       	lddpc	r9,80004268 <phy_rx_func+0xec4>
80004140:	72 08       	ld.w	r8,r9[0x0]
80004142:	20 18       	sub	r8,1
80004144:	93 08       	st.w	r9[0x0],r8
80004146:	c6 c1       	brne	8000421e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80004148:	30 09       	mov	r9,0
8000414a:	4c 68       	lddpc	r8,80004260 <phy_rx_func+0xebc>
8000414c:	91 09       	st.w	r8[0x0],r9
8000414e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80004152:	30 09       	mov	r9,0
80004154:	4c 38       	lddpc	r8,80004260 <phy_rx_func+0xebc>
80004156:	91 09       	st.w	r8[0x0],r9
80004158:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
8000415c:	8e 4a       	ld.sh	r10,r7[0x8]
8000415e:	4d 99       	lddpc	r9,800042c0 <phy_rx_func+0xf1c>
80004160:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80004164:	4d 6a       	lddpc	r10,800042bc <phy_rx_func+0xf18>
80004166:	15 88       	ld.ub	r8,r10[0x0]
80004168:	f0 cb ff ff 	sub	r11,r8,-1
8000416c:	8e 5c       	ld.sh	r12,r7[0xa]
8000416e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80004172:	f0 cb ff fe 	sub	r11,r8,-2
80004176:	8e 6c       	ld.sh	r12,r7[0xc]
80004178:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
8000417c:	f0 cb ff fd 	sub	r11,r8,-3
80004180:	8e 7c       	ld.sh	r12,r7[0xe]
80004182:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80004186:	2f c8       	sub	r8,-4
80004188:	b4 88       	st.b	r10[0x0],r8
8000418a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
8000418e:	30 09       	mov	r9,0
80004190:	4b 48       	lddpc	r8,80004260 <phy_rx_func+0xebc>
80004192:	91 09       	st.w	r8[0x0],r9
80004194:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80004198:	4c 08       	lddpc	r8,80004298 <phy_rx_func+0xef4>
8000419a:	70 09       	ld.w	r9,r8[0x0]
8000419c:	8e 4b       	ld.sh	r11,r7[0x8]
8000419e:	4c 0a       	lddpc	r10,8000429c <phy_rx_func+0xef8>
800041a0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800041a4:	2f f9       	sub	r9,-1
800041a6:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800041a8:	4b 58       	lddpc	r8,8000427c <phy_rx_func+0xed8>
800041aa:	70 09       	ld.w	r9,r8[0x0]
800041ac:	20 29       	sub	r9,2
800041ae:	91 09       	st.w	r8[0x0],r9
800041b0:	70 08       	ld.w	r8,r8[0x0]
800041b2:	58 08       	cp.w	r8,0
800041b4:	c2 f1       	brne	80004212 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
800041b6:	30 09       	mov	r9,0
800041b8:	4b 88       	lddpc	r8,80004298 <phy_rx_func+0xef4>
800041ba:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800041bc:	8e 59       	ld.sh	r9,r7[0xa]
800041be:	fe 78 82 12 	mov	r8,-32238
800041c2:	f0 09 19 00 	cp.h	r9,r8
800041c6:	c2 11       	brne	80004208 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800041c8:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800041cc:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800041d0:	4a f8       	lddpc	r8,8000428c <phy_rx_func+0xee8>
800041d2:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800041d4:	8e 59       	ld.sh	r9,r7[0xa]
800041d6:	4a f8       	lddpc	r8,80004290 <phy_rx_func+0xeec>
800041d8:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800041da:	8e 69       	ld.sh	r9,r7[0xc]
800041dc:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800041de:	f0 1f 00 2e 	mcall	80004294 <phy_rx_func+0xef0>
800041e2:	4a 18       	lddpc	r8,80004264 <phy_rx_func+0xec0>
800041e4:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800041e6:	ef 39 00 0f 	ld.ub	r9,r7[15]
800041ea:	31 38       	mov	r8,19
800041ec:	f0 09 18 00 	cp.b	r9,r8
800041f0:	c0 71       	brne	800041fe <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
800041f2:	10 99       	mov	r9,r8
800041f4:	4a 18       	lddpc	r8,80004278 <phy_rx_func+0xed4>
800041f6:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
800041f8:	30 09       	mov	r9,0
800041fa:	49 c8       	lddpc	r8,80004268 <phy_rx_func+0xec4>
800041fc:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
800041fe:	30 49       	mov	r9,4
80004200:	49 88       	lddpc	r8,80004260 <phy_rx_func+0xebc>
80004202:	91 09       	st.w	r8[0x0],r9
80004204:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80004208:	30 09       	mov	r9,0
8000420a:	49 68       	lddpc	r8,80004260 <phy_rx_func+0xebc>
8000420c:	91 09       	st.w	r8[0x0],r9
8000420e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004212:	4a dc       	lddpc	r12,800042c4 <phy_rx_func+0xf20>
80004214:	f0 1f 00 18 	mcall	80004274 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80004218:	30 09       	mov	r9,0
8000421a:	49 28       	lddpc	r8,80004260 <phy_rx_func+0xebc>
8000421c:	91 09       	st.w	r8[0x0],r9
8000421e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004222:	00 00       	add	r0,r0
80004224:	00 00       	add	r0,r0
80004226:	0a b4       	st.h	r5++,r4
80004228:	00 00       	add	r0,r0
8000422a:	0a cc       	st.b	r5++,r12
8000422c:	00 00       	add	r0,r0
8000422e:	0a ac       	st.w	r5++,r12
80004230:	00 00       	add	r0,r0
80004232:	0a 8e       	andn	lr,r5
80004234:	00 00       	add	r0,r0
80004236:	0a 7c       	tst	r12,r5
80004238:	00 00       	add	r0,r0
8000423a:	0a a4       	st.w	r5++,r4
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	32 24       	mov	r4,34
80004240:	00 00       	add	r0,r0
80004242:	0a 9c       	mov	r12,r5
80004244:	80 00       	ld.sh	r0,r0[0x0]
80004246:	31 3c       	mov	r12,19
80004248:	00 00       	add	r0,r0
8000424a:	0a b0       	st.h	r5++,r0
8000424c:	80 00       	ld.sh	r0,r0[0x0]
8000424e:	31 70       	mov	r0,23
80004250:	00 00       	add	r0,r0
80004252:	0a 8d       	andn	sp,r5
80004254:	00 00       	add	r0,r0
80004256:	0a a8       	st.w	r5++,r8
80004258:	00 00       	add	r0,r0
8000425a:	0a b8       	st.h	r5++,r8
8000425c:	00 00       	add	r0,r0
8000425e:	0a 90       	mov	r0,r5
80004260:	00 00       	add	r0,r0
80004262:	0a d8       	st.w	--r5,r8
80004264:	00 00       	add	r0,r0
80004266:	0a c0       	st.b	r5++,r0
80004268:	00 00       	add	r0,r0
8000426a:	0a 78       	tst	r8,r5
8000426c:	00 00       	add	r0,r0
8000426e:	0a 54       	eor	r4,r5
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	e0 70 80 00 	mov	r0,98304
80004276:	79 c0       	ld.w	r0,r12[0x70]
80004278:	00 00       	add	r0,r0
8000427a:	0a 8c       	andn	r12,r5
8000427c:	00 00       	add	r0,r0
8000427e:	0a e4       	st.h	--r5,r4
80004280:	00 00       	add	r0,r0
80004282:	0a c4       	st.b	r5++,r4
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	81 f8       	st.w	r0[0x3c],r8
80004288:	80 00       	ld.sh	r0,r0[0x0]
8000428a:	31 58       	mov	r8,21
8000428c:	00 00       	add	r0,r0
8000428e:	0a 4a       	or	r10,r5
80004290:	00 00       	add	r0,r0
80004292:	21 44       	sub	r4,20
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	31 0c       	mov	r12,16
80004298:	00 00       	add	r0,r0
8000429a:	0a 80       	andn	r0,r5
8000429c:	00 00       	add	r0,r0
8000429e:	20 48       	sub	r8,4
800042a0:	00 00       	add	r0,r0
800042a2:	0a 84       	andn	r4,r5
800042a4:	00 00       	add	r0,r0
800042a6:	0a 4b       	or	r11,r5
800042a8:	00 00       	add	r0,r0
800042aa:	0a 49       	or	r9,r5
800042ac:	00 00       	add	r0,r0
800042ae:	0a dc       	st.w	--r5,r12
800042b0:	00 00       	add	r0,r0
800042b2:	0a 98       	mov	r8,r5
800042b4:	00 00       	add	r0,r0
800042b6:	0a 58       	eor	r8,r5
800042b8:	00 00       	add	r0,r0
800042ba:	20 40       	sub	r0,4
800042bc:	00 00       	add	r0,r0
800042be:	0a d0       	st.w	--r5,r0
800042c0:	00 00       	add	r0,r0
800042c2:	21 48       	sub	r8,20
800042c4:	80 00       	ld.sh	r0,r0[0x0]
800042c6:	e0 88 d4 01 	brls	8001eac8 <_data_lma+0xfe10>

800042c8 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800042c8:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
800042ca:	30 09       	mov	r9,0
800042cc:	49 b8       	lddpc	r8,80004338 <pdca_int_handler+0x70>
800042ce:	91 09       	st.w	r8[0x0],r9
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
800042d0:	49 b8       	lddpc	r8,8000433c <pdca_int_handler+0x74>
800042d2:	70 09       	ld.w	r9,r8[0x0]
800042d4:	2f f9       	sub	r9,-1
800042d6:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800042d8:	49 a8       	lddpc	r8,80004340 <pdca_int_handler+0x78>
800042da:	11 89       	ld.ub	r9,r8[0x0]
800042dc:	ec 19 00 01 	eorl	r9,0x1
800042e0:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800042e2:	11 89       	ld.ub	r9,r8[0x0]
800042e4:	a5 69       	lsl	r9,0x4
800042e6:	2f c9       	sub	r9,-4
800042e8:	49 7a       	lddpc	r10,80004344 <pdca_int_handler+0x7c>
800042ea:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800042ec:	fe 7a 00 40 	mov	r10,-65472
800042f0:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800042f2:	30 39       	mov	r9,3
800042f4:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
800042f6:	11 8a       	ld.ub	r10,r8[0x0]
800042f8:	a5 6a       	lsl	r10,0x4
800042fa:	2f ca       	sub	r10,-4
800042fc:	49 38       	lddpc	r8,80004348 <pdca_int_handler+0x80>
800042fe:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004300:	fe 78 00 00 	mov	r8,-65536
80004304:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004306:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004308:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
8000430a:	49 18       	lddpc	r8,8000434c <pdca_int_handler+0x84>
8000430c:	70 08       	ld.w	r8,r8[0x0]
8000430e:	58 08       	cp.w	r8,0
80004310:	c0 70       	breq	8000431e <pdca_int_handler+0x56>
80004312:	48 c9       	lddpc	r9,80004340 <pdca_int_handler+0x78>
80004314:	13 89       	ld.ub	r9,r9[0x0]
80004316:	a5 69       	lsl	r9,0x4
80004318:	48 cc       	lddpc	r12,80004348 <pdca_int_handler+0x80>
8000431a:	12 0c       	add	r12,r9
8000431c:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
8000431e:	48 d8       	lddpc	r8,80004350 <pdca_int_handler+0x88>
80004320:	70 08       	ld.w	r8,r8[0x0]
80004322:	58 08       	cp.w	r8,0
80004324:	c0 70       	breq	80004332 <pdca_int_handler+0x6a>
80004326:	48 79       	lddpc	r9,80004340 <pdca_int_handler+0x78>
80004328:	13 89       	ld.ub	r9,r9[0x0]
8000432a:	a5 69       	lsl	r9,0x4
8000432c:	48 6c       	lddpc	r12,80004344 <pdca_int_handler+0x7c>
8000432e:	12 0c       	add	r12,r9
80004330:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004332:	d4 02       	popm	lr
80004334:	d6 03       	rete
80004336:	00 00       	add	r0,r0
80004338:	00 00       	add	r0,r0
8000433a:	0a ec       	st.h	--r5,r12
8000433c:	00 00       	add	r0,r0
8000433e:	0a f0       	st.b	--r5,r0
80004340:	00 00       	add	r0,r0
80004342:	53 68       	stdsp	sp[0xd8],r8
80004344:	00 00       	add	r0,r0
80004346:	53 90       	stdsp	sp[0xe4],r0
80004348:	00 00       	add	r0,r0
8000434a:	53 70       	stdsp	sp[0xdc],r0
8000434c:	00 00       	add	r0,r0
8000434e:	0a e8       	st.h	--r5,r8
80004350:	00 00       	add	r0,r0
80004352:	0a f4       	st.b	--r5,r4

80004354 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004354:	fe 78 10 00 	mov	r8,-61440
80004358:	e0 69 0d c0 	mov	r9,3520
8000435c:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004360:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004364:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004368:	fe 78 34 00 	mov	r8,-52224
8000436c:	e0 69 80 00 	mov	r9,32768
80004370:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004372:	30 09       	mov	r9,0
80004374:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004376:	e0 69 04 21 	mov	r9,1057
8000437a:	ea 19 3f 20 	orh	r9,0x3f20
8000437e:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80004380:	e0 69 02 9f 	mov	r9,671
80004384:	ea 19 01 00 	orh	r9,0x100
80004388:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
8000438a:	e0 6a 04 02 	mov	r10,1026
8000438e:	ea 1a 3f 20 	orh	r10,0x3f20
80004392:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80004394:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004396:	5e fc       	retal	r12

80004398 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004398:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000439a:	30 19       	mov	r9,1
8000439c:	49 78       	lddpc	r8,800043f8 <local_start_PDC+0x60>
8000439e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800043a0:	fe 78 00 00 	mov	r8,-65536
800043a4:	30 7b       	mov	r11,7
800043a6:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800043a8:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800043aa:	49 59       	lddpc	r9,800043fc <local_start_PDC+0x64>
800043ac:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800043b0:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800043b2:	30 3a       	mov	r10,3
800043b4:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800043b6:	30 1c       	mov	r12,1
800043b8:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800043ba:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800043bc:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800043be:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800043c0:	30 2c       	mov	r12,2
800043c2:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800043c4:	48 f9       	lddpc	r9,80004400 <local_start_PDC+0x68>
800043c6:	e0 68 5a 5a 	mov	r8,23130
800043ca:	ea 18 ab cd 	orh	r8,0xabcd
800043ce:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800043d0:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800043d2:	30 0e       	mov	lr,0
800043d4:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800043d6:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800043d8:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800043da:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800043dc:	fe 78 00 40 	mov	r8,-65472
800043e0:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800043e2:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800043e4:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800043e8:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800043ea:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800043ec:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800043ee:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800043f0:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800043f2:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800043f4:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
800043f6:	d8 02       	popm	pc
800043f8:	00 00       	add	r0,r0
800043fa:	53 68       	stdsp	sp[0xd8],r8
800043fc:	00 00       	add	r0,r0
800043fe:	53 70       	stdsp	sp[0xdc],r0
80004400:	00 00       	add	r0,r0
80004402:	53 90       	stdsp	sp[0xe4],r0

80004404 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004404:	48 38       	lddpc	r8,80004410 <register_rx_tx_func+0xc>
80004406:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004408:	48 38       	lddpc	r8,80004414 <register_rx_tx_func+0x10>
8000440a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
8000440c:	5e fc       	retal	r12
8000440e:	00 00       	add	r0,r0
80004410:	00 00       	add	r0,r0
80004412:	0a e8       	st.h	--r5,r8
80004414:	00 00       	add	r0,r0
80004416:	0a f4       	st.b	--r5,r4

80004418 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004418:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000441a:	fe 78 10 00 	mov	r8,-61440
8000441e:	30 29       	mov	r9,2
80004420:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004424:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80004428:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
8000442a:	30 3a       	mov	r10,3
8000442c:	36 0b       	mov	r11,96
8000442e:	49 4c       	lddpc	r12,8000447c <ssc_init+0x64>
80004430:	f0 1f 00 14 	mcall	80004480 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80004434:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004436:	fe 79 10 00 	mov	r9,-61440
8000443a:	f2 f8 01 60 	ld.w	r8,r9[352]
8000443e:	e2 18 00 02 	andl	r8,0x2,COH
80004442:	cf c0       	breq	8000443a <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004444:	fe 79 10 00 	mov	r9,-61440
80004448:	f2 f8 01 60 	ld.w	r8,r9[352]
8000444c:	e2 18 00 02 	andl	r8,0x2,COH
80004450:	cf c1       	brne	80004448 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80004452:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80004454:	f0 1f 00 0c 	mcall	80004484 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80004458:	f0 1f 00 0c 	mcall	80004488 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000445c:	fe 79 00 00 	mov	r9,-65536
80004460:	30 18       	mov	r8,1
80004462:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004464:	fe 7a 00 40 	mov	r10,-65472
80004468:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000446a:	e0 6b 01 01 	mov	r11,257
8000446e:	fe 7a 34 00 	mov	r10,-52224
80004472:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80004474:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80004476:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80004478:	d8 02       	popm	pc
8000447a:	00 00       	add	r0,r0
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	42 c8       	lddsp	r8,sp[0xb0]
80004480:	80 00       	ld.sh	r0,r0[0x0]
80004482:	5c f4       	rol	r4
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	43 54       	lddsp	r4,sp[0xd4]
80004488:	80 00       	ld.sh	r0,r0[0x0]
8000448a:	43 98       	lddsp	r8,sp[0xe4]

8000448c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
8000448c:	48 28       	lddpc	r8,80004494 <xcmp_register_app_list+0x8>
8000448e:	91 0c       	st.w	r8[0x0],r12
}
80004490:	5e fc       	retal	r12
80004492:	00 00       	add	r0,r0
80004494:	00 00       	add	r0,r0
80004496:	53 b0       	stdsp	sp[0xec],r0

80004498 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004498:	eb cd 40 80 	pushm	r7,lr
8000449c:	fa cd 01 00 	sub	sp,sp,256
800044a0:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800044a2:	16 98       	mov	r8,r11
800044a4:	2f 08       	sub	r8,-16
800044a6:	af a8       	sbr	r8,0xe
800044a8:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800044aa:	3f f8       	mov	r8,-1
800044ac:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800044ae:	30 b9       	mov	r9,11
800044b0:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800044b2:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800044b4:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800044b6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800044b8:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800044ba:	f6 ca ff fe 	sub	r10,r11,-2
800044be:	18 9b       	mov	r11,r12
800044c0:	fa cc ff f0 	sub	r12,sp,-16
800044c4:	f0 1f 00 05 	mcall	800044d8 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800044c8:	2f e7       	sub	r7,-2
800044ca:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800044cc:	1a 9c       	mov	r12,sp
800044ce:	f0 1f 00 04 	mcall	800044dc <xcmp_tx+0x44>
}
800044d2:	2c 0d       	sub	sp,-256
800044d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800044d8:	80 00       	ld.sh	r0,r0[0x0]
800044da:	80 b0       	ld.uh	r0,r0[0x6]
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	4a a4       	lddpc	r4,80004584 <xcmp_DeviceInitializationStatus_request+0x18>

800044e0 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
800044e0:	d4 21       	pushm	r4-r7,lr
800044e2:	fa cd 00 d0 	sub	sp,sp,208
800044e6:	18 94       	mov	r4,r12
800044e8:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
800044ea:	e0 68 01 00 	mov	r8,256
800044ee:	f0 0b 19 00 	cp.h	r11,r8
800044f2:	e0 8b 00 36 	brhi	8000455e <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
800044f6:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
800044fa:	e0 68 04 1d 	mov	r8,1053
800044fe:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004500:	30 18       	mov	r8,1
80004502:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004504:	32 08       	mov	r8,32
80004506:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80004508:	30 28       	mov	r8,2
8000450a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
8000450c:	30 48       	mov	r8,4
8000450e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004510:	ea 1a 0c 00 	orh	r10,0xc00
80004514:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80004516:	30 4a       	mov	r10,4
80004518:	1a 9b       	mov	r11,sp
8000451a:	fa cc ff f4 	sub	r12,sp,-12
8000451e:	f0 1f 00 12 	mcall	80004564 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80004522:	30 f8       	mov	r8,15
80004524:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80004528:	3a 78       	mov	r8,-89
8000452a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
8000452e:	30 08       	mov	r8,0
80004530:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004534:	0e 9a       	mov	r10,r7
80004536:	5c 7a       	castu.h	r10
80004538:	f4 08 16 08 	lsr	r8,r10,0x8
8000453c:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80004540:	0e 96       	mov	r6,r7
80004542:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80004546:	08 9b       	mov	r11,r4
80004548:	fa cc ff eb 	sub	r12,sp,-21
8000454c:	f0 1f 00 06 	mcall	80004564 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80004550:	ee cb ff f3 	sub	r11,r7,-13
80004554:	5c 5b       	castu.b	r11
80004556:	fa cc ff fa 	sub	r12,sp,-6
8000455a:	f0 1f 00 04 	mcall	80004568 <xcmp_data_session_req+0x88>
}
8000455e:	2c cd       	sub	sp,-208
80004560:	d8 22       	popm	r4-r7,pc
80004562:	00 00       	add	r0,r0
80004564:	80 00       	ld.sh	r0,r0[0x0]
80004566:	80 b0       	ld.uh	r0,r0[0x6]
80004568:	80 00       	ld.sh	r0,r0[0x0]
8000456a:	44 98       	lddsp	r8,sp[0x124]

8000456c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
8000456c:	d4 01       	pushm	lr
8000456e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004572:	fe 78 b4 00 	mov	r8,-19456
80004576:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004578:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
8000457c:	30 89       	mov	r9,8
8000457e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004580:	30 19       	mov	r9,1
80004582:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004584:	30 09       	mov	r9,0
80004586:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004588:	30 5a       	mov	r10,5
8000458a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000458c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000458e:	30 7a       	mov	r10,7
80004590:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004592:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004594:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004596:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000459a:	30 9b       	mov	r11,9
8000459c:	fa cc ff fe 	sub	r12,sp,-2
800045a0:	f0 1f 00 02 	mcall	800045a8 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800045a4:	2c dd       	sub	sp,-204
800045a6:	d8 02       	popm	pc
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	44 98       	lddsp	r8,sp[0x124]

800045ac <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800045ac:	d4 01       	pushm	lr
800045ae:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800045b2:	fe 78 80 00 	mov	r8,-32768
800045b6:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800045b8:	30 38       	mov	r8,3
800045ba:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800045bc:	30 1b       	mov	r11,1
800045be:	fa cc ff fe 	sub	r12,sp,-2
800045c2:	f0 1f 00 03 	mcall	800045cc <xcmp_opcode_not_supported+0x20>
}
800045c6:	2c dd       	sub	sp,-204
800045c8:	d8 02       	popm	pc
800045ca:	00 00       	add	r0,r0
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	44 98       	lddsp	r8,sp[0x124]

800045d0 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800045d0:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800045d2:	96 88       	ld.uh	r8,r11[0x0]
800045d4:	e2 18 f0 00 	andl	r8,0xf000,COH
800045d8:	e0 48 80 00 	cp.w	r8,32768
800045dc:	c0 f0       	breq	800045fa <xcmp_exec_func+0x2a>
800045de:	e0 48 b0 00 	cp.w	r8,45056
800045e2:	c1 20       	breq	80004606 <xcmp_exec_func+0x36>
800045e4:	58 08       	cp.w	r8,0
800045e6:	c1 51       	brne	80004610 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800045e8:	78 08       	ld.w	r8,r12[0x0]
800045ea:	58 08       	cp.w	r8,0
800045ec:	c0 40       	breq	800045f4 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800045ee:	16 9c       	mov	r12,r11
800045f0:	5d 18       	icall	r8
800045f2:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800045f4:	f0 1f 00 08 	mcall	80004614 <xcmp_exec_func+0x44>
800045f8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800045fa:	78 18       	ld.w	r8,r12[0x4]
800045fc:	58 08       	cp.w	r8,0
800045fe:	c0 90       	breq	80004610 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004600:	16 9c       	mov	r12,r11
80004602:	5d 18       	icall	r8
80004604:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004606:	78 28       	ld.w	r8,r12[0x8]
80004608:	58 08       	cp.w	r8,0
8000460a:	c0 30       	breq	80004610 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000460c:	16 9c       	mov	r12,r11
8000460e:	5d 18       	icall	r8
80004610:	d8 02       	popm	pc
80004612:	00 00       	add	r0,r0
80004614:	80 00       	ld.sh	r0,r0[0x0]
80004616:	45 ac       	lddsp	r12,sp[0x168]

80004618 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004618:	d4 01       	pushm	lr
8000461a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000461e:	e0 68 04 09 	mov	r8,1033
80004622:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004624:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004628:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000462a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000462e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004630:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004632:	30 09       	mov	r9,0
80004634:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004636:	fb 69 00 08 	st.b	sp[8],r9
8000463a:	fa c8 ff f7 	sub	r8,sp,-9
8000463e:	b0 89       	st.b	r8[0x0],r9
80004640:	fa c8 ff f6 	sub	r8,sp,-10
80004644:	b0 89       	st.b	r8[0x0],r9
80004646:	fa c8 ff f5 	sub	r8,sp,-11
8000464a:	b0 89       	st.b	r8[0x0],r9
8000464c:	fa c8 ff f4 	sub	r8,sp,-12
80004650:	b0 89       	st.b	r8[0x0],r9
80004652:	fa c8 ff f3 	sub	r8,sp,-13
80004656:	b0 89       	st.b	r8[0x0],r9
80004658:	fa c8 ff f2 	sub	r8,sp,-14
8000465c:	b0 89       	st.b	r8[0x0],r9
8000465e:	fa c8 ff f1 	sub	r8,sp,-15
80004662:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004664:	30 cb       	mov	r11,12
80004666:	fa cc ff fe 	sub	r12,sp,-2
8000466a:	f0 1f 00 03 	mcall	80004674 <xcmp_IdleTestTone+0x5c>
}
8000466e:	2c dd       	sub	sp,-204
80004670:	d8 02       	popm	pc
80004672:	00 00       	add	r0,r0
80004674:	80 00       	ld.sh	r0,r0[0x0]
80004676:	44 98       	lddsp	r8,sp[0x124]

80004678 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004678:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000467a:	48 dc       	lddpc	r12,800046ac <xcmp_init+0x34>
8000467c:	f0 1f 00 0d 	mcall	800046b0 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004680:	30 4b       	mov	r11,4
80004682:	31 4c       	mov	r12,20
80004684:	f0 1f 00 0c 	mcall	800046b4 <xcmp_init+0x3c>
80004688:	48 c8       	lddpc	r8,800046b8 <xcmp_init+0x40>
8000468a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000468c:	30 09       	mov	r9,0
8000468e:	1a d9       	st.w	--sp,r9
80004690:	1a d9       	st.w	--sp,r9
80004692:	1a d9       	st.w	--sp,r9
80004694:	30 38       	mov	r8,3
80004696:	e0 6a 04 00 	mov	r10,1024
8000469a:	48 9b       	lddpc	r11,800046bc <xcmp_init+0x44>
8000469c:	48 9c       	lddpc	r12,800046c0 <xcmp_init+0x48>
8000469e:	f0 1f 00 0a 	mcall	800046c4 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800046a2:	f0 1f 00 0a 	mcall	800046c8 <xcmp_init+0x50>
800046a6:	2f dd       	sub	sp,-12
	
}
800046a8:	d8 02       	popm	pc
800046aa:	00 00       	add	r0,r0
800046ac:	80 00       	ld.sh	r0,r0[0x0]
800046ae:	47 c8       	lddsp	r8,sp[0x1f0]
800046b0:	80 00       	ld.sh	r0,r0[0x0]
800046b2:	48 14       	lddpc	r4,800046b4 <xcmp_init+0x3c>
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	6d 54       	ld.w	r4,r6[0x54]
800046b8:	00 00       	add	r0,r0
800046ba:	0b 10       	ld.sh	r0,r5++
800046bc:	80 00       	ld.sh	r0,r0[0x0]
800046be:	e0 b4       	*unknown*
800046c0:	80 00       	ld.sh	r0,r0[0x0]
800046c2:	46 cc       	lddsp	r12,sp[0x1b0]
800046c4:	80 00       	ld.sh	r0,r0[0x0]
800046c6:	74 70       	ld.w	r0,r10[0x1c]
800046c8:	80 00       	ld.sh	r0,r0[0x0]
800046ca:	48 4c       	lddpc	r12,800046d8 <xcmp_rx_process+0xc>

800046cc <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800046cc:	d4 31       	pushm	r0-r7,lr
800046ce:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800046d0:	4b 16       	lddpc	r6,80004794 <xcmp_rx_process+0xc8>
800046d2:	30 05       	mov	r5,0
800046d4:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800046d6:	4b 13       	lddpc	r3,80004798 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800046d8:	4b 12       	lddpc	r2,8000479c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800046da:	4b 21       	lddpc	r1,800047a0 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800046dc:	4b 20       	lddpc	r0,800047a4 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800046de:	6c 0c       	ld.w	r12,r6[0x0]
800046e0:	0a 99       	mov	r9,r5
800046e2:	08 9a       	mov	r10,r4
800046e4:	1a 9b       	mov	r11,sp
800046e6:	f0 1f 00 31 	mcall	800047a8 <xcmp_rx_process+0xdc>
800046ea:	58 1c       	cp.w	r12,1
800046ec:	cf 91       	brne	800046de <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800046ee:	40 0b       	lddsp	r11,sp[0x0]
800046f0:	58 0b       	cp.w	r11,0
800046f2:	cf 60       	breq	800046de <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
800046f4:	96 0a       	ld.sh	r10,r11[0x0]
800046f6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800046fa:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800046fe:	59 c8       	cp.w	r8,28
80004700:	c1 e0       	breq	8000473c <xcmp_rx_process+0x70>
80004702:	e0 89 00 07 	brgt	80004710 <xcmp_rx_process+0x44>
80004706:	58 e8       	cp.w	r8,14
80004708:	c0 e0       	breq	80004724 <xcmp_rx_process+0x58>
8000470a:	58 f8       	cp.w	r8,15
8000470c:	c2 41       	brne	80004754 <xcmp_rx_process+0x88>
8000470e:	c0 f8       	rjmp	8000472c <xcmp_rx_process+0x60>
80004710:	e0 48 01 09 	cp.w	r8,265
80004714:	c1 80       	breq	80004744 <xcmp_rx_process+0x78>
80004716:	e0 48 01 0a 	cp.w	r8,266
8000471a:	c1 90       	breq	8000474c <xcmp_rx_process+0x80>
8000471c:	e0 48 00 2c 	cp.w	r8,44
80004720:	c1 a1       	brne	80004754 <xcmp_rx_process+0x88>
80004722:	c0 98       	rjmp	80004734 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004724:	4a 2c       	lddpc	r12,800047ac <xcmp_rx_process+0xe0>
80004726:	f0 1f 00 23 	mcall	800047b0 <xcmp_rx_process+0xe4>
					break;
8000472a:	c2 f8       	rjmp	80004788 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000472c:	4a 2c       	lddpc	r12,800047b4 <xcmp_rx_process+0xe8>
8000472e:	f0 1f 00 21 	mcall	800047b0 <xcmp_rx_process+0xe4>
					break;
80004732:	c2 b8       	rjmp	80004788 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004734:	4a 1c       	lddpc	r12,800047b8 <xcmp_rx_process+0xec>
80004736:	f0 1f 00 1f 	mcall	800047b0 <xcmp_rx_process+0xe4>
					break;
8000473a:	c2 78       	rjmp	80004788 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000473c:	04 9c       	mov	r12,r2
8000473e:	f0 1f 00 1d 	mcall	800047b0 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004742:	c2 38       	rjmp	80004788 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004744:	02 9c       	mov	r12,r1
80004746:	f0 1f 00 1b 	mcall	800047b0 <xcmp_rx_process+0xe4>
					break;
8000474a:	c1 f8       	rjmp	80004788 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000474c:	00 9c       	mov	r12,r0
8000474e:	f0 1f 00 19 	mcall	800047b0 <xcmp_rx_process+0xe4>
					break;
80004752:	c1 b8       	rjmp	80004788 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004754:	12 98       	mov	r8,r9
80004756:	e2 18 04 00 	andl	r8,0x400,COH
8000475a:	c0 70       	breq	80004768 <xcmp_rx_process+0x9c>
8000475c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004760:	e0 48 00 68 	cp.w	r8,104
80004764:	e0 8a 00 08 	brle	80004774 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004768:	e2 19 f0 00 	andl	r9,0xf000,COH
8000476c:	c0 e1       	brne	80004788 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000476e:	f0 1f 00 14 	mcall	800047bc <xcmp_rx_process+0xf0>
80004772:	c0 b8       	rjmp	80004788 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004774:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004778:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000477c:	49 19       	lddpc	r9,800047c0 <xcmp_rx_process+0xf4>
8000477e:	72 08       	ld.w	r8,r9[0x0]
80004780:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004784:	f0 1f 00 0b 	mcall	800047b0 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004788:	66 0c       	ld.w	r12,r3[0x0]
8000478a:	40 0b       	lddsp	r11,sp[0x0]
8000478c:	f0 1f 00 0e 	mcall	800047c4 <xcmp_rx_process+0xf8>
80004790:	ca 7b       	rjmp	800046de <xcmp_rx_process+0x12>
80004792:	00 00       	add	r0,r0
80004794:	00 00       	add	r0,r0
80004796:	0b 10       	ld.sh	r0,r5++
80004798:	00 00       	add	r0,r0
8000479a:	0a a4       	st.w	r5++,r4
8000479c:	00 00       	add	r0,r0
8000479e:	0b 20       	ld.uh	r0,r5++
800047a0:	00 00       	add	r0,r0
800047a2:	0b 14       	ld.sh	r4,r5++
800047a4:	00 00       	add	r0,r0
800047a6:	0b 04       	ld.w	r4,r5++
800047a8:	80 00       	ld.sh	r0,r0[0x0]
800047aa:	6a 48       	ld.w	r8,r5[0x10]
800047ac:	00 00       	add	r0,r0
800047ae:	0b 38       	ld.ub	r8,r5++
800047b0:	80 00       	ld.sh	r0,r0[0x0]
800047b2:	45 d0       	lddsp	r0,sp[0x174]
800047b4:	00 00       	add	r0,r0
800047b6:	0a f8       	st.b	--r5,r8
800047b8:	00 00       	add	r0,r0
800047ba:	0b 2c       	ld.uh	r12,r5++
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	45 ac       	lddsp	r12,sp[0x168]
800047c0:	00 00       	add	r0,r0
800047c2:	53 b0       	stdsp	sp[0xec],r0
800047c4:	80 00       	ld.sh	r0,r0[0x0]
800047c6:	31 a8       	mov	r8,26

800047c8 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800047c8:	eb cd 40 90 	pushm	r4,r7,lr
800047cc:	20 1d       	sub	sp,4
800047ce:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800047d2:	48 c8       	lddpc	r8,80004800 <xcmp_rx+0x38>
800047d4:	70 0c       	ld.w	r12,r8[0x0]
800047d6:	f0 1f 00 0c 	mcall	80004804 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800047da:	c1 00       	breq	800047fa <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800047dc:	fa c7 ff fc 	sub	r7,sp,-4
800047e0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800047e2:	e0 6a 00 ca 	mov	r10,202
800047e6:	08 9b       	mov	r11,r4
800047e8:	f0 1f 00 08 	mcall	80004808 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800047ec:	48 88       	lddpc	r8,8000480c <xcmp_rx+0x44>
800047ee:	70 0c       	ld.w	r12,r8[0x0]
800047f0:	30 09       	mov	r9,0
800047f2:	12 9a       	mov	r10,r9
800047f4:	1a 9b       	mov	r11,sp
800047f6:	f0 1f 00 07 	mcall	80004810 <xcmp_rx+0x48>
	}	
}
800047fa:	2f fd       	sub	sp,-4
800047fc:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004800:	00 00       	add	r0,r0
80004802:	0a a4       	st.w	r5++,r4
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	33 54       	mov	r4,53
80004808:	80 00       	ld.sh	r0,r0[0x0]
8000480a:	80 b0       	ld.uh	r0,r0[0x6]
8000480c:	00 00       	add	r0,r0
8000480e:	0b 10       	ld.sh	r0,r5++
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	6c 54       	ld.w	r4,r6[0x14]

80004814 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004814:	48 28       	lddpc	r8,8000481c <xnl_register_xcmp_func+0x8>
80004816:	91 0c       	st.w	r8[0x0],r12
}
80004818:	5e fc       	retal	r12
8000481a:	00 00       	add	r0,r0
8000481c:	00 00       	add	r0,r0
8000481e:	0b 64       	ld.uh	r4,--r5

80004820 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004820:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004822:	48 88       	lddpc	r8,80004840 <xnl_get_msg_ack_func+0x20>
80004824:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004826:	98 49       	ld.sh	r9,r12[0x8]
80004828:	f0 09 19 00 	cp.h	r9,r8
8000482c:	c0 81       	brne	8000483c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000482e:	48 68       	lddpc	r8,80004844 <xnl_get_msg_ack_func+0x24>
80004830:	70 0c       	ld.w	r12,r8[0x0]
80004832:	30 09       	mov	r9,0
80004834:	12 9a       	mov	r10,r9
80004836:	12 9b       	mov	r11,r9
80004838:	f0 1f 00 04 	mcall	80004848 <xnl_get_msg_ack_func+0x28>
8000483c:	d8 02       	popm	pc
8000483e:	00 00       	add	r0,r0
80004840:	00 00       	add	r0,r0
80004842:	0b 4a       	ld.w	r10,--r5
80004844:	00 00       	add	r0,r0
80004846:	0b 44       	ld.w	r4,--r5
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	6c 54       	ld.w	r4,r6[0x14]

8000484c <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
8000484c:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004850:	30 09       	mov	r9,0
80004852:	4b 78       	lddpc	r8,8000492c <xnl_init+0xe0>
80004854:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004856:	30 0b       	mov	r11,0
80004858:	30 1c       	mov	r12,1
8000485a:	f0 1f 00 36 	mcall	80004930 <xnl_init+0xe4>
8000485e:	4b 68       	lddpc	r8,80004934 <xnl_init+0xe8>
80004860:	91 0c       	st.w	r8[0x0],r12
80004862:	70 08       	ld.w	r8,r8[0x0]
80004864:	58 08       	cp.w	r8,0
80004866:	c0 80       	breq	80004876 <xnl_init+0x2a>
80004868:	4b 38       	lddpc	r8,80004934 <xnl_init+0xe8>
8000486a:	70 0c       	ld.w	r12,r8[0x0]
8000486c:	30 09       	mov	r9,0
8000486e:	12 9a       	mov	r10,r9
80004870:	12 9b       	mov	r11,r9
80004872:	f0 1f 00 32 	mcall	80004938 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004876:	30 4b       	mov	r11,4
80004878:	31 4c       	mov	r12,20
8000487a:	f0 1f 00 2e 	mcall	80004930 <xnl_init+0xe4>
8000487e:	4b 08       	lddpc	r8,8000493c <xnl_init+0xf0>
80004880:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004882:	30 4b       	mov	r11,4
80004884:	31 ec       	mov	r12,30
80004886:	f0 1f 00 2b 	mcall	80004930 <xnl_init+0xe4>
8000488a:	4a e8       	lddpc	r8,80004940 <xnl_init+0xf4>
8000488c:	91 0c       	st.w	r8[0x0],r12
8000488e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004890:	10 96       	mov	r6,r8
80004892:	4a d5       	lddpc	r5,80004944 <xnl_init+0xf8>
80004894:	6c 0c       	ld.w	r12,r6[0x0]
80004896:	ea 07 00 0b 	add	r11,r5,r7
8000489a:	f0 1f 00 2c 	mcall	80004948 <xnl_init+0xfc>
8000489e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800048a2:	e0 47 1e 00 	cp.w	r7,7680
800048a6:	cf 71       	brne	80004894 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800048a8:	30 4b       	mov	r11,4
800048aa:	31 4c       	mov	r12,20
800048ac:	f0 1f 00 21 	mcall	80004930 <xnl_init+0xe4>
800048b0:	4a 78       	lddpc	r8,8000494c <xnl_init+0x100>
800048b2:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800048b4:	30 4b       	mov	r11,4
800048b6:	30 ac       	mov	r12,10
800048b8:	f0 1f 00 1e 	mcall	80004930 <xnl_init+0xe4>
800048bc:	4a 58       	lddpc	r8,80004950 <xnl_init+0x104>
800048be:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800048c0:	30 4b       	mov	r11,4
800048c2:	30 ac       	mov	r12,10
800048c4:	f0 1f 00 1b 	mcall	80004930 <xnl_init+0xe4>
800048c8:	4a 38       	lddpc	r8,80004954 <xnl_init+0x108>
800048ca:	91 0c       	st.w	r8[0x0],r12
800048cc:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800048ce:	10 96       	mov	r6,r8
800048d0:	4a 25       	lddpc	r5,80004958 <xnl_init+0x10c>
800048d2:	6c 0c       	ld.w	r12,r6[0x0]
800048d4:	ea 07 00 0b 	add	r11,r5,r7
800048d8:	f0 1f 00 1c 	mcall	80004948 <xnl_init+0xfc>
800048dc:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800048e0:	e0 47 14 00 	cp.w	r7,5120
800048e4:	cf 71       	brne	800048d2 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800048e6:	30 4b       	mov	r11,4
800048e8:	30 5c       	mov	r12,5
800048ea:	f0 1f 00 12 	mcall	80004930 <xnl_init+0xe4>
800048ee:	49 c8       	lddpc	r8,8000495c <xnl_init+0x110>
800048f0:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800048f2:	30 07       	mov	r7,0
800048f4:	1a d7       	st.w	--sp,r7
800048f6:	1a d7       	st.w	--sp,r7
800048f8:	1a d7       	st.w	--sp,r7
800048fa:	30 38       	mov	r8,3
800048fc:	0e 99       	mov	r9,r7
800048fe:	e0 6a 00 dc 	mov	r10,220
80004902:	49 8b       	lddpc	r11,80004960 <xnl_init+0x114>
80004904:	49 8c       	lddpc	r12,80004964 <xnl_init+0x118>
80004906:	f0 1f 00 19 	mcall	80004968 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000490a:	1a d7       	st.w	--sp,r7
8000490c:	1a d7       	st.w	--sp,r7
8000490e:	1a d7       	st.w	--sp,r7
80004910:	30 38       	mov	r8,3
80004912:	0e 99       	mov	r9,r7
80004914:	e0 6a 00 82 	mov	r10,130
80004918:	49 5b       	lddpc	r11,8000496c <xnl_init+0x120>
8000491a:	49 6c       	lddpc	r12,80004970 <xnl_init+0x124>
8000491c:	f0 1f 00 13 	mcall	80004968 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004920:	f0 1f 00 15 	mcall	80004974 <xnl_init+0x128>
80004924:	2f ad       	sub	sp,-24
}
80004926:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000492a:	00 00       	add	r0,r0
8000492c:	00 00       	add	r0,r0
8000492e:	0b 4a       	ld.w	r10,--r5
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	6d 54       	ld.w	r4,r6[0x54]
80004934:	00 00       	add	r0,r0
80004936:	0b 44       	ld.w	r4,--r5
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	6c 54       	ld.w	r4,r6[0x14]
8000493c:	00 00       	add	r0,r0
8000493e:	0b 58       	ld.sh	r8,--r5
80004940:	00 00       	add	r0,r0
80004942:	0a a4       	st.w	r5++,r4
80004944:	00 00       	add	r0,r0
80004946:	35 62       	mov	r2,86
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	31 a8       	mov	r8,26
8000494c:	00 00       	add	r0,r0
8000494e:	0a d4       	st.w	--r5,r4
80004950:	00 00       	add	r0,r0
80004952:	0a b4       	st.h	r5++,r4
80004954:	00 00       	add	r0,r0
80004956:	0a a8       	st.w	r5++,r8
80004958:	00 00       	add	r0,r0
8000495a:	21 62       	sub	r2,22
8000495c:	00 00       	add	r0,r0
8000495e:	0a e0       	st.h	--r5,r0
80004960:	80 00       	ld.sh	r0,r0[0x0]
80004962:	e0 bc       	*unknown*
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	49 78       	lddpc	r8,800049c0 <xnl_rx_process+0x48>
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	74 70       	ld.w	r0,r10[0x1c]
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	e0 c4 80 00 	sub	r4,r0,-32768
80004972:	49 d8       	lddpc	r8,800049e4 <xnl_tx_process+0xc>
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	33 7c       	mov	r12,55

80004978 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004978:	eb cd 40 fe 	pushm	r1-r7,lr
8000497c:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000497e:	49 26       	lddpc	r6,800049c4 <xnl_rx_process+0x4c>
80004980:	30 05       	mov	r5,0
80004982:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004984:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004986:	49 11       	lddpc	r1,800049c8 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004988:	49 12       	lddpc	r2,800049cc <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000498a:	6c 0c       	ld.w	r12,r6[0x0]
8000498c:	0a 99       	mov	r9,r5
8000498e:	08 9a       	mov	r10,r4
80004990:	1a 9b       	mov	r11,sp
80004992:	f0 1f 00 10 	mcall	800049d0 <xnl_rx_process+0x58>
80004996:	58 1c       	cp.w	r12,1
80004998:	cf 91       	brne	8000498a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000499a:	40 0c       	lddsp	r12,sp[0x0]
8000499c:	58 0c       	cp.w	r12,0
8000499e:	cf 60       	breq	8000498a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800049a0:	98 28       	ld.sh	r8,r12[0x4]
800049a2:	e6 08 19 00 	cp.h	r8,r3
800049a6:	e0 8b 00 0a 	brhi	800049ba <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800049aa:	5c 78       	castu.h	r8
800049ac:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800049b0:	58 09       	cp.w	r9,0
800049b2:	c0 40       	breq	800049ba <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800049b4:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800049b8:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800049ba:	62 0c       	ld.w	r12,r1[0x0]
800049bc:	40 0b       	lddsp	r11,sp[0x0]
800049be:	f0 1f 00 06 	mcall	800049d4 <xnl_rx_process+0x5c>
800049c2:	ce 4b       	rjmp	8000498a <xnl_rx_process+0x12>
800049c4:	00 00       	add	r0,r0
800049c6:	0a b4       	st.h	r5++,r4
800049c8:	00 00       	add	r0,r0
800049ca:	0a a4       	st.w	r5++,r4
800049cc:	00 00       	add	r0,r0
800049ce:	04 f8       	st.b	--r2,r8
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	6a 48       	ld.w	r8,r5[0x10]
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	31 a8       	mov	r8,26

800049d8 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
800049d8:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800049da:	4a a6       	lddpc	r6,80004a80 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800049dc:	4a a2       	lddpc	r2,80004a84 <xnl_tx_process+0xac>
800049de:	4a b4       	lddpc	r4,80004a88 <xnl_tx_process+0xb0>
800049e0:	30 07       	mov	r7,0
800049e2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800049e4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800049e6:	4a a5       	lddpc	r5,80004a8c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800049e8:	4a a3       	lddpc	r3,80004a90 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800049ea:	6c 08       	ld.w	r8,r6[0x0]
800049ec:	58 08       	cp.w	r8,0
800049ee:	c0 40       	breq	800049f6 <xnl_tx_process+0x1e>
800049f0:	58 18       	cp.w	r8,1
800049f2:	cf d1       	brne	800049ec <xnl_tx_process+0x14>
800049f4:	c2 48       	rjmp	80004a3c <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800049f6:	64 0c       	ld.w	r12,r2[0x0]
800049f8:	0e 99       	mov	r9,r7
800049fa:	02 9a       	mov	r10,r1
800049fc:	08 9b       	mov	r11,r4
800049fe:	f0 1f 00 26 	mcall	80004a94 <xnl_tx_process+0xbc>
80004a02:	58 1c       	cp.w	r12,1
80004a04:	cf 31       	brne	800049ea <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004a06:	68 0b       	ld.w	r11,r4[0x0]
80004a08:	58 0b       	cp.w	r11,0
80004a0a:	cf 00       	breq	800049ea <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004a0c:	96 28       	ld.sh	r8,r11[0x4]
80004a0e:	e0 08 19 00 	cp.h	r8,r0
80004a12:	c0 71       	brne	80004a20 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004a14:	4a 18       	lddpc	r8,80004a98 <xnl_tx_process+0xc0>
80004a16:	70 08       	ld.w	r8,r8[0x0]
80004a18:	10 9c       	mov	r12,r8
80004a1a:	f0 1f 00 21 	mcall	80004a9c <xnl_tx_process+0xc4>
						break;
80004a1e:	ce 6b       	rjmp	800049ea <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004a20:	16 9c       	mov	r12,r11
80004a22:	f0 1f 00 20 	mcall	80004aa0 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004a26:	30 18       	mov	r8,1
80004a28:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004a2a:	66 0c       	ld.w	r12,r3[0x0]
80004a2c:	0e 99       	mov	r9,r7
80004a2e:	0e 9a       	mov	r10,r7
80004a30:	0e 9b       	mov	r11,r7
80004a32:	f0 1f 00 19 	mcall	80004a94 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004a36:	30 18       	mov	r8,1
80004a38:	8d 08       	st.w	r6[0x0],r8
80004a3a:	cd 8b       	rjmp	800049ea <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004a3c:	66 0c       	ld.w	r12,r3[0x0]
80004a3e:	0e 99       	mov	r9,r7
80004a40:	36 4a       	mov	r10,100
80004a42:	0e 9b       	mov	r11,r7
80004a44:	f0 1f 00 14 	mcall	80004a94 <xnl_tx_process+0xbc>
80004a48:	58 1c       	cp.w	r12,1
80004a4a:	c0 81       	brne	80004a5a <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004a4c:	49 38       	lddpc	r8,80004a98 <xnl_tx_process+0xc0>
80004a4e:	70 0c       	ld.w	r12,r8[0x0]
80004a50:	68 0b       	ld.w	r11,r4[0x0]
80004a52:	f0 1f 00 13 	mcall	80004a9c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004a56:	8d 07       	st.w	r6[0x0],r7
80004a58:	cc 9b       	rjmp	800049ea <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004a5a:	6a 08       	ld.w	r8,r5[0x0]
80004a5c:	58 38       	cp.w	r8,3
80004a5e:	e0 89 00 09 	brgt	80004a70 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004a62:	68 0c       	ld.w	r12,r4[0x0]
80004a64:	f0 1f 00 0f 	mcall	80004aa0 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004a68:	6a 08       	ld.w	r8,r5[0x0]
80004a6a:	2f f8       	sub	r8,-1
80004a6c:	8b 08       	st.w	r5[0x0],r8
80004a6e:	cb eb       	rjmp	800049ea <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004a70:	48 a8       	lddpc	r8,80004a98 <xnl_tx_process+0xc0>
80004a72:	70 0c       	ld.w	r12,r8[0x0]
80004a74:	68 0b       	ld.w	r11,r4[0x0]
80004a76:	f0 1f 00 0a 	mcall	80004a9c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004a7a:	8d 07       	st.w	r6[0x0],r7
80004a7c:	cb 7b       	rjmp	800049ea <xnl_tx_process+0x12>
80004a7e:	00 00       	add	r0,r0
80004a80:	00 00       	add	r0,r0
80004a82:	0b 54       	ld.sh	r4,--r5
80004a84:	00 00       	add	r0,r0
80004a86:	0b 58       	ld.sh	r8,--r5
80004a88:	00 00       	add	r0,r0
80004a8a:	0b 60       	ld.uh	r0,--r5
80004a8c:	00 00       	add	r0,r0
80004a8e:	0b 5c       	ld.sh	r12,--r5
80004a90:	00 00       	add	r0,r0
80004a92:	0b 44       	ld.w	r4,--r5
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	6a 48       	ld.w	r8,r5[0x10]
80004a98:	00 00       	add	r0,r0
80004a9a:	0a a4       	st.w	r5++,r4
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	31 a8       	mov	r8,26
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	31 c8       	mov	r8,28

80004aa4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004aa4:	eb cd 40 c0 	pushm	r6-r7,lr
80004aa8:	20 1d       	sub	sp,4
80004aaa:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004aac:	98 39       	ld.sh	r9,r12[0x6]
80004aae:	3f f8       	mov	r8,-1
80004ab0:	f0 09 19 00 	cp.h	r9,r8
80004ab4:	c0 a1       	brne	80004ac8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004ab6:	4a e9       	lddpc	r9,80004b6c <xnl_tx+0xc8>
80004ab8:	13 88       	ld.ub	r8,r9[0x0]
80004aba:	2f f8       	sub	r8,-1
80004abc:	5c 58       	castu.b	r8
80004abe:	b2 88       	st.b	r9[0x0],r8
80004ac0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004ac4:	a9 a8       	sbr	r8,0x8
80004ac6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004ac8:	8c 49       	ld.sh	r9,r6[0x8]
80004aca:	3f f8       	mov	r8,-1
80004acc:	f0 09 19 00 	cp.h	r9,r8
80004ad0:	c0 41       	brne	80004ad8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004ad2:	4a 88       	lddpc	r8,80004b70 <xnl_tx+0xcc>
80004ad4:	90 18       	ld.sh	r8,r8[0x2]
80004ad6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004ad8:	8c 59       	ld.sh	r9,r6[0xa]
80004ada:	3f f8       	mov	r8,-1
80004adc:	f0 09 19 00 	cp.h	r9,r8
80004ae0:	c0 41       	brne	80004ae8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004ae2:	4a 48       	lddpc	r8,80004b70 <xnl_tx+0xcc>
80004ae4:	90 28       	ld.sh	r8,r8[0x4]
80004ae6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004ae8:	8c 69       	ld.sh	r9,r6[0xc]
80004aea:	3f f8       	mov	r8,-1
80004aec:	f0 09 19 00 	cp.h	r9,r8
80004af0:	c0 e1       	brne	80004b0c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004af2:	4a 08       	lddpc	r8,80004b70 <xnl_tx+0xcc>
80004af4:	90 49       	ld.sh	r9,r8[0x8]
80004af6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004af8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004afa:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004afc:	90 49       	ld.sh	r9,r8[0x8]
80004afe:	e0 19 ff 00 	andl	r9,0xff00
80004b02:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004b06:	f3 e8 10 08 	or	r8,r9,r8
80004b0a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004b0c:	0d 98       	ld.ub	r8,r6[0x1]
80004b0e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004b10:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004b14:	10 0c       	add	r12,r8
80004b16:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004b18:	58 0c       	cp.w	r12,0
80004b1a:	e0 89 00 04 	brgt	80004b22 <xnl_tx+0x7e>
80004b1e:	30 09       	mov	r9,0
80004b20:	c0 d8       	rjmp	80004b3a <xnl_tx+0x96>
80004b22:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004b26:	2f ec       	sub	r12,-2
80004b28:	30 09       	mov	r9,0
80004b2a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004b2c:	15 1b       	ld.sh	r11,r10++
80004b2e:	f6 09 00 09 	add	r9,r11,r9
80004b32:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004b34:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004b36:	18 38       	cp.w	r8,r12
80004b38:	cf a1       	brne	80004b2c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004b3a:	5c 39       	neg	r9
80004b3c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004b3e:	48 e8       	lddpc	r8,80004b74 <xnl_tx+0xd0>
80004b40:	70 0c       	ld.w	r12,r8[0x0]
80004b42:	f0 1f 00 0e 	mcall	80004b78 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004b46:	c1 00       	breq	80004b66 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004b48:	fa c7 ff fc 	sub	r7,sp,-4
80004b4c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004b4e:	e0 6a 01 00 	mov	r10,256
80004b52:	0c 9b       	mov	r11,r6
80004b54:	f0 1f 00 0a 	mcall	80004b7c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004b58:	48 a8       	lddpc	r8,80004b80 <xnl_tx+0xdc>
80004b5a:	70 0c       	ld.w	r12,r8[0x0]
80004b5c:	30 09       	mov	r9,0
80004b5e:	12 9a       	mov	r10,r9
80004b60:	1a 9b       	mov	r11,sp
80004b62:	f0 1f 00 09 	mcall	80004b84 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004b66:	2f fd       	sub	sp,-4
80004b68:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b6c:	00 00       	add	r0,r0
80004b6e:	0b 48       	ld.w	r8,--r5
80004b70:	00 00       	add	r0,r0
80004b72:	0b 4a       	ld.w	r10,--r5
80004b74:	00 00       	add	r0,r0
80004b76:	0a a4       	st.w	r5++,r4
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	33 54       	mov	r4,53
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	80 b0       	ld.uh	r0,r0[0x6]
80004b80:	00 00       	add	r0,r0
80004b82:	0b 58       	ld.sh	r8,--r5
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	6c 54       	ld.w	r4,r6[0x14]

80004b88 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004b88:	eb cd 40 80 	pushm	r7,lr
80004b8c:	fa cd 01 00 	sub	sp,sp,256
80004b90:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b92:	e0 68 40 0e 	mov	r8,16398
80004b96:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b98:	3f f8       	mov	r8,-1
80004b9a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004b9c:	30 c8       	mov	r8,12
80004b9e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004ba0:	98 38       	ld.sh	r8,r12[0x6]
80004ba2:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004ba4:	98 58       	ld.sh	r8,r12[0xa]
80004ba6:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004ba8:	98 48       	ld.sh	r8,r12[0x8]
80004baa:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004bac:	98 68       	ld.sh	r8,r12[0xc]
80004bae:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004bb0:	30 08       	mov	r8,0
80004bb2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004bb4:	1a 9c       	mov	r12,sp
80004bb6:	f0 1f 00 0a 	mcall	80004bdc <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004bba:	fa cd 00 cc 	sub	sp,sp,204
80004bbe:	e0 6a 00 ca 	mov	r10,202
80004bc2:	ee cb ff f0 	sub	r11,r7,-16
80004bc6:	1a 9c       	mov	r12,sp
80004bc8:	f0 1f 00 06 	mcall	80004be0 <xnl_data_msg_func+0x58>
80004bcc:	48 68       	lddpc	r8,80004be4 <xnl_data_msg_func+0x5c>
80004bce:	70 08       	ld.w	r8,r8[0x0]
80004bd0:	5d 18       	icall	r8
80004bd2:	fa cd ff 34 	sub	sp,sp,-204
}
80004bd6:	2c 0d       	sub	sp,-256
80004bd8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bdc:	80 00       	ld.sh	r0,r0[0x0]
80004bde:	4a a4       	lddpc	r4,80004c84 <xnl_device_auth_reply_func+0x9c>
80004be0:	80 00       	ld.sh	r0,r0[0x0]
80004be2:	80 b0       	ld.uh	r0,r0[0x6]
80004be4:	00 00       	add	r0,r0
80004be6:	0b 64       	ld.uh	r4,--r5

80004be8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004be8:	d4 21       	pushm	r4-r7,lr
80004bea:	fa cd 01 00 	sub	sp,sp,256
80004bee:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004bf0:	4c 28       	lddpc	r8,80004cf8 <xnl_device_auth_reply_func+0x110>
80004bf2:	11 88       	ld.ub	r8,r8[0x0]
80004bf4:	58 08       	cp.w	r8,0
80004bf6:	e0 81 00 7f 	brne	80004cf4 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004bfa:	4c 18       	lddpc	r8,80004cfc <xnl_device_auth_reply_func+0x114>
80004bfc:	70 0c       	ld.w	r12,r8[0x0]
80004bfe:	30 09       	mov	r9,0
80004c00:	12 9a       	mov	r10,r9
80004c02:	12 9b       	mov	r11,r9
80004c04:	f0 1f 00 3f 	mcall	80004d00 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004c08:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004c0c:	4b b8       	lddpc	r8,80004cf8 <xnl_device_auth_reply_func+0x110>
80004c0e:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004c10:	ef 39 00 12 	ld.ub	r9,r7[18]
80004c14:	ef 38 00 13 	ld.ub	r8,r7[19]
80004c18:	b1 68       	lsl	r8,0x10
80004c1a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004c1e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004c22:	f3 e8 10 08 	or	r8,r9,r8
80004c26:	ef 39 00 14 	ld.ub	r9,r7[20]
80004c2a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004c2e:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004c32:	ef 38 00 17 	ld.ub	r8,r7[23]
80004c36:	b1 68       	lsl	r8,0x10
80004c38:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004c3c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004c40:	f5 e8 10 08 	or	r8,r10,r8
80004c44:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004c48:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004c4c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c4e:	e0 64 79 b9 	mov	r4,31161
80004c52:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c56:	e0 65 45 07 	mov	r5,17671
80004c5a:	ea 15 8a bd 	orh	r5,0x8abd
80004c5e:	e0 66 f9 3d 	mov	r6,63805
80004c62:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c66:	e0 6e b8 cf 	mov	lr,47311
80004c6a:	ea 1e 36 83 	orh	lr,0x3683
80004c6e:	e0 67 aa 1c 	mov	r7,43548
80004c72:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004c76:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004c78:	f4 08 00 0c 	add	r12,r10,r8
80004c7c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004c80:	0a 0b       	add	r11,r5
80004c82:	f9 eb 20 0b 	eor	r11,r12,r11
80004c86:	f0 0c 16 05 	lsr	r12,r8,0x5
80004c8a:	0c 0c       	add	r12,r6
80004c8c:	18 5b       	eor	r11,r12
80004c8e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004c90:	f2 0c 15 04 	lsl	r12,r9,0x4
80004c94:	1c 0c       	add	r12,lr
80004c96:	f2 0b 16 05 	lsr	r11,r9,0x5
80004c9a:	0e 0b       	add	r11,r7
80004c9c:	f9 eb 20 0b 	eor	r11,r12,r11
80004ca0:	f2 0a 00 0c 	add	r12,r9,r10
80004ca4:	18 5b       	eor	r11,r12
80004ca6:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004ca8:	e0 6b 37 20 	mov	r11,14112
80004cac:	ea 1b c6 ef 	orh	r11,0xc6ef
80004cb0:	16 3a       	cp.w	r10,r11
80004cb2:	ce 21       	brne	80004c76 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004cb4:	e0 6a 40 1a 	mov	r10,16410
80004cb8:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004cba:	3f fa       	mov	r10,-1
80004cbc:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004cbe:	30 6b       	mov	r11,6
80004cc0:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004cc2:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004cc4:	48 db       	lddpc	r11,80004cf8 <xnl_device_auth_reply_func+0x110>
80004cc6:	96 1c       	ld.sh	r12,r11[0x2]
80004cc8:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004cca:	96 2b       	ld.sh	r11,r11[0x4]
80004ccc:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004cce:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004cd0:	30 ca       	mov	r10,12
80004cd2:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004cd4:	30 0a       	mov	r10,0
80004cd6:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004cda:	30 7a       	mov	r10,7
80004cdc:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004ce0:	30 2a       	mov	r10,2
80004ce2:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004ce6:	fa ca ff ec 	sub	r10,sp,-20
80004cea:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004cec:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004cee:	1a 9c       	mov	r12,sp
80004cf0:	f0 1f 00 05 	mcall	80004d04 <xnl_device_auth_reply_func+0x11c>
}
80004cf4:	2c 0d       	sub	sp,-256
80004cf6:	d8 22       	popm	r4-r7,pc
80004cf8:	00 00       	add	r0,r0
80004cfa:	0b 4a       	ld.w	r10,--r5
80004cfc:	00 00       	add	r0,r0
80004cfe:	0b 44       	ld.w	r4,--r5
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	6c 54       	ld.w	r4,r6[0x14]
80004d04:	80 00       	ld.sh	r0,r0[0x0]
80004d06:	4a a4       	lddpc	r4,80004dac <xnl_device_conn_reply_func+0x44>

80004d08 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004d08:	eb cd 40 80 	pushm	r7,lr
80004d0c:	fa cd 01 00 	sub	sp,sp,256
80004d10:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004d12:	49 28       	lddpc	r8,80004d58 <xnl_master_status_brdcst_func+0x50>
80004d14:	11 88       	ld.ub	r8,r8[0x0]
80004d16:	58 08       	cp.w	r8,0
80004d18:	c1 c1       	brne	80004d50 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004d1a:	49 18       	lddpc	r8,80004d5c <xnl_master_status_brdcst_func+0x54>
80004d1c:	70 0c       	ld.w	r12,r8[0x0]
80004d1e:	30 09       	mov	r9,0
80004d20:	12 9a       	mov	r10,r9
80004d22:	12 9b       	mov	r11,r9
80004d24:	f0 1f 00 0f 	mcall	80004d60 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004d28:	8e 58       	ld.sh	r8,r7[0xa]
80004d2a:	48 c9       	lddpc	r9,80004d58 <xnl_master_status_brdcst_func+0x50>
80004d2c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004d2e:	e0 68 40 0e 	mov	r8,16398
80004d32:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004d34:	3f f8       	mov	r8,-1
80004d36:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004d38:	30 4a       	mov	r10,4
80004d3a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004d3c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004d3e:	92 19       	ld.sh	r9,r9[0x2]
80004d40:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004d42:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004d44:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004d46:	30 08       	mov	r8,0
80004d48:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004d4a:	1a 9c       	mov	r12,sp
80004d4c:	f0 1f 00 06 	mcall	80004d64 <xnl_master_status_brdcst_func+0x5c>
}
80004d50:	2c 0d       	sub	sp,-256
80004d52:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d56:	00 00       	add	r0,r0
80004d58:	00 00       	add	r0,r0
80004d5a:	0b 4a       	ld.w	r10,--r5
80004d5c:	00 00       	add	r0,r0
80004d5e:	0b 44       	ld.w	r4,--r5
80004d60:	80 00       	ld.sh	r0,r0[0x0]
80004d62:	6c 54       	ld.w	r4,r6[0x14]
80004d64:	80 00       	ld.sh	r0,r0[0x0]
80004d66:	4a a4       	lddpc	r4,80004e0c <RC522_SPI_SetSpeed+0x18>

80004d68 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004d68:	eb cd 40 80 	pushm	r7,lr
80004d6c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004d6e:	49 28       	lddpc	r8,80004db4 <xnl_device_conn_reply_func+0x4c>
80004d70:	70 0c       	ld.w	r12,r8[0x0]
80004d72:	30 09       	mov	r9,0
80004d74:	12 9a       	mov	r10,r9
80004d76:	12 9b       	mov	r11,r9
80004d78:	f0 1f 00 10 	mcall	80004db8 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004d7c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004d80:	10 99       	mov	r9,r8
80004d82:	e2 19 ff 00 	andl	r9,0xff00,COH
80004d86:	e0 49 01 00 	cp.w	r9,256
80004d8a:	c0 60       	breq	80004d96 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004d8c:	0e 9c       	mov	r12,r7
80004d8e:	f0 1f 00 0c 	mcall	80004dbc <xnl_device_conn_reply_func+0x54>
80004d92:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004d96:	a9 68       	lsl	r8,0x8
80004d98:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004d9c:	48 98       	lddpc	r8,80004dc0 <xnl_device_conn_reply_func+0x58>
80004d9e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004da0:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004da4:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004da6:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004daa:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004dac:	30 19       	mov	r9,1
80004dae:	b0 89       	st.b	r8[0x0],r9
80004db0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004db4:	00 00       	add	r0,r0
80004db6:	0b 44       	ld.w	r4,--r5
80004db8:	80 00       	ld.sh	r0,r0[0x0]
80004dba:	6c 54       	ld.w	r4,r6[0x14]
80004dbc:	80 00       	ld.sh	r0,r0[0x0]
80004dbe:	4d 08       	lddpc	r8,80004efc <PcdReset+0x38>
80004dc0:	00 00       	add	r0,r0
80004dc2:	0b 4a       	ld.w	r10,--r5

80004dc4 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004dc4:	d4 01       	pushm	lr
80004dc6:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004dca:	e0 68 40 0e 	mov	r8,16398
80004dce:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004dd0:	3f f8       	mov	r8,-1
80004dd2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004dd4:	30 38       	mov	r8,3
80004dd6:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004dd8:	30 08       	mov	r8,0
80004dda:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004ddc:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004dde:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004de0:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004de2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004de4:	1a 9c       	mov	r12,sp
80004de6:	f0 1f 00 03 	mcall	80004df0 <xnl_send_device_master_query+0x2c>
}
80004dea:	2c 0d       	sub	sp,-256
80004dec:	d8 02       	popm	pc
80004dee:	00 00       	add	r0,r0
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	4a a4       	lddpc	r4,80004e98 <WriteRawRC+0x14>

80004df4 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004df4:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004df6:	48 78       	lddpc	r8,80004e10 <RC522_SPI_SetSpeed+0x1c>
80004df8:	70 09       	ld.w	r9,r8[0x0]
80004dfa:	72 ca       	ld.w	r10,r9[0x30]
80004dfc:	5c 7c       	castu.h	r12
80004dfe:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004e02:	f9 ea 10 0a 	or	r10,r12,r10
80004e06:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004e08:	70 0c       	ld.w	r12,r8[0x0]
80004e0a:	f0 1f 00 03 	mcall	80004e14 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004e0e:	d8 02       	popm	pc
80004e10:	00 00       	add	r0,r0
80004e12:	20 3c       	sub	r12,3
80004e14:	80 00       	ld.sh	r0,r0[0x0]
80004e16:	61 44       	ld.w	r4,r0[0x50]

80004e18 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004e18:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
80004e1a:	e0 6c 04 00 	mov	r12,1024
80004e1e:	f0 1f 00 02 	mcall	80004e24 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004e22:	d8 02       	popm	pc
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	4d f4       	lddpc	r4,80004fa0 <Powerdown_RC522+0x4>

80004e28 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004e28:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004e2c:	48 76       	lddpc	r6,80004e48 <RC522_ReadByte+0x20>
80004e2e:	e0 6b 00 ff 	mov	r11,255
80004e32:	6c 0c       	ld.w	r12,r6[0x0]
80004e34:	f0 1f 00 06 	mcall	80004e4c <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004e38:	30 07       	mov	r7,0
80004e3a:	0e 9b       	mov	r11,r7
80004e3c:	6c 0c       	ld.w	r12,r6[0x0]
80004e3e:	f0 1f 00 05 	mcall	80004e50 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80004e42:	0f 9c       	ld.ub	r12,r7[0x1]
80004e44:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e48:	00 00       	add	r0,r0
80004e4a:	20 3c       	sub	r12,3
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	61 4a       	ld.w	r10,r0[0x50]
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	61 66       	ld.w	r6,r0[0x58]

80004e54 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004e54:	eb cd 40 80 	pushm	r7,lr
80004e58:	20 1d       	sub	sp,4
80004e5a:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004e5c:	48 77       	lddpc	r7,80004e78 <RC522_WriteByte+0x24>
80004e5e:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80004e62:	6e 0c       	ld.w	r12,r7[0x0]
80004e64:	f0 1f 00 06 	mcall	80004e7c <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004e68:	1a 9b       	mov	r11,sp
80004e6a:	6e 0c       	ld.w	r12,r7[0x0]
80004e6c:	f0 1f 00 05 	mcall	80004e80 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004e70:	5c 5c       	castu.b	r12
80004e72:	2f fd       	sub	sp,-4
80004e74:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e78:	00 00       	add	r0,r0
80004e7a:	20 3c       	sub	r12,3
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	61 4a       	ld.w	r10,r0[0x50]
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	61 66       	ld.w	r6,r0[0x58]

80004e84 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004e84:	eb cd 40 e0 	pushm	r5-r7,lr
80004e88:	18 96       	mov	r6,r12
80004e8a:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004e8c:	48 a7       	lddpc	r7,80004eb4 <WriteRawRC+0x30>
80004e8e:	30 0b       	mov	r11,0
80004e90:	6e 0c       	ld.w	r12,r7[0x0]
80004e92:	f0 1f 00 0a 	mcall	80004eb8 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004e96:	ec 0c 15 01 	lsl	r12,r6,0x1
80004e9a:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004e9e:	f0 1f 00 08 	mcall	80004ebc <WriteRawRC+0x38>
	RC522_WriteByte(value);
80004ea2:	0a 9c       	mov	r12,r5
80004ea4:	f0 1f 00 06 	mcall	80004ebc <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004ea8:	30 0b       	mov	r11,0
80004eaa:	6e 0c       	ld.w	r12,r7[0x0]
80004eac:	f0 1f 00 05 	mcall	80004ec0 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004eb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004eb4:	00 00       	add	r0,r0
80004eb6:	20 3c       	sub	r12,3
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	62 b0       	ld.w	r0,r1[0x2c]
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	4e 54       	lddpc	r4,80005050 <ClearBitMask+0x24>
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	62 70       	ld.w	r0,r1[0x1c]

80004ec4 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004ec4:	d4 01       	pushm	lr

	SET_RC522RST;
80004ec6:	31 9c       	mov	r12,25
80004ec8:	f0 1f 00 1b 	mcall	80004f34 <PcdReset+0x70>
	delay_ns(10);
80004ecc:	30 ac       	mov	r12,10
80004ece:	f0 1f 00 1b 	mcall	80004f38 <PcdReset+0x74>

	CLR_RC522RST;
80004ed2:	31 9c       	mov	r12,25
80004ed4:	f0 1f 00 1a 	mcall	80004f3c <PcdReset+0x78>
	delay_ns(10);
80004ed8:	30 ac       	mov	r12,10
80004eda:	f0 1f 00 18 	mcall	80004f38 <PcdReset+0x74>

	SET_RC522RST;
80004ede:	31 9c       	mov	r12,25
80004ee0:	f0 1f 00 15 	mcall	80004f34 <PcdReset+0x70>
	delay_ns(10);
80004ee4:	30 ac       	mov	r12,10
80004ee6:	f0 1f 00 15 	mcall	80004f38 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004eea:	30 fb       	mov	r11,15
80004eec:	30 1c       	mov	r12,1
80004eee:	f0 1f 00 15 	mcall	80004f40 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004ef2:	30 fb       	mov	r11,15
80004ef4:	30 1c       	mov	r12,1
80004ef6:	f0 1f 00 13 	mcall	80004f40 <PcdReset+0x7c>
	delay_ns(10);
80004efa:	30 ac       	mov	r12,10
80004efc:	f0 1f 00 0f 	mcall	80004f38 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004f00:	33 db       	mov	r11,61
80004f02:	31 1c       	mov	r12,17
80004f04:	f0 1f 00 0f 	mcall	80004f40 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004f08:	31 eb       	mov	r11,30
80004f0a:	32 dc       	mov	r12,45
80004f0c:	f0 1f 00 0d 	mcall	80004f40 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004f10:	30 0b       	mov	r11,0
80004f12:	32 cc       	mov	r12,44
80004f14:	f0 1f 00 0b 	mcall	80004f40 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004f18:	e0 6b 00 8d 	mov	r11,141
80004f1c:	32 ac       	mov	r12,42
80004f1e:	f0 1f 00 09 	mcall	80004f40 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004f22:	33 eb       	mov	r11,62
80004f24:	32 bc       	mov	r12,43
80004f26:	f0 1f 00 07 	mcall	80004f40 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004f2a:	34 0b       	mov	r11,64
80004f2c:	31 5c       	mov	r12,21
80004f2e:	f0 1f 00 05 	mcall	80004f40 <PcdReset+0x7c>
	
	return MI_OK;
}
80004f32:	d8 0a       	popm	pc,r12=0
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	5c b8       	swap.b	r8
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	57 d0       	stdsp	sp[0x1f4],r0
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	5c d4       	com	r4
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	4e 84       	lddpc	r4,800050e0 <rc522_init+0xc>

80004f44 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004f44:	eb cd 40 c0 	pushm	r6-r7,lr
80004f48:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004f4a:	48 c7       	lddpc	r7,80004f78 <ReadRawRC+0x34>
80004f4c:	30 0b       	mov	r11,0
80004f4e:	6e 0c       	ld.w	r12,r7[0x0]
80004f50:	f0 1f 00 0b 	mcall	80004f7c <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004f54:	a1 76       	lsl	r6,0x1
80004f56:	0c 9c       	mov	r12,r6
80004f58:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004f5c:	a7 bc       	sbr	r12,0x7
80004f5e:	f0 1f 00 09 	mcall	80004f80 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80004f62:	f0 1f 00 09 	mcall	80004f84 <ReadRawRC+0x40>
80004f66:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004f68:	30 0b       	mov	r11,0
80004f6a:	6e 0c       	ld.w	r12,r7[0x0]
80004f6c:	f0 1f 00 07 	mcall	80004f88 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004f70:	0c 9c       	mov	r12,r6
80004f72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f76:	00 00       	add	r0,r0
80004f78:	00 00       	add	r0,r0
80004f7a:	20 3c       	sub	r12,3
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	62 b0       	ld.w	r0,r1[0x2c]
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	4e 54       	lddpc	r4,80005114 <rc522_init+0x40>
80004f84:	80 00       	ld.sh	r0,r0[0x0]
80004f86:	4e 28       	lddpc	r8,8000510c <rc522_init+0x38>
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	62 70       	ld.w	r0,r1[0x1c]

80004f8c <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80004f8c:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80004f8e:	30 1c       	mov	r12,1
80004f90:	f0 1f 00 02 	mcall	80004f98 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004f94:	d8 02       	popm	pc
80004f96:	00 00       	add	r0,r0
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	4f 44       	lddpc	r4,80005168 <rc522_init+0x94>

80004f9c <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80004f9c:	eb cd 40 80 	pushm	r7,lr
80004fa0:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004fa2:	30 1c       	mov	r12,1
80004fa4:	f0 1f 00 0d 	mcall	80004fd8 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004fa8:	30 18       	mov	r8,1
80004faa:	f0 07 18 00 	cp.b	r7,r8
80004fae:	c0 91       	brne	80004fc0 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004fb0:	18 9b       	mov	r11,r12
80004fb2:	a5 ab       	sbr	r11,0x4
80004fb4:	5c 5b       	castu.b	r11
80004fb6:	30 1c       	mov	r12,1
80004fb8:	f0 1f 00 09 	mcall	80004fdc <Powerdown_RC522+0x40>
80004fbc:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004fc0:	18 9b       	mov	r11,r12
80004fc2:	30 1c       	mov	r12,1
80004fc4:	f0 1f 00 06 	mcall	80004fdc <Powerdown_RC522+0x40>
		delay_ns(2);
80004fc8:	30 2c       	mov	r12,2
80004fca:	f0 1f 00 06 	mcall	80004fe0 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004fce:	f0 1f 00 06 	mcall	80004fe4 <Powerdown_RC522+0x48>
80004fd2:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fd6:	00 00       	add	r0,r0
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	4f 44       	lddpc	r4,800051a8 <rc522_init+0xd4>
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	4e 84       	lddpc	r4,8000517c <rc522_init+0xa8>
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	57 d0       	stdsp	sp[0x1f4],r0
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	4f 8c       	lddpc	r12,800051c4 <PcdComMF522+0x18>

80004fe8 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004fe8:	eb cd 40 c0 	pushm	r6-r7,lr
80004fec:	18 97       	mov	r7,r12
80004fee:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004ff0:	f0 1f 00 05 	mcall	80005004 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004ff4:	f9 e6 10 0b 	or	r11,r12,r6
80004ff8:	5c 5b       	castu.b	r11
80004ffa:	0e 9c       	mov	r12,r7
80004ffc:	f0 1f 00 03 	mcall	80005008 <SetBitMask+0x20>
}
80005000:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	4f 44       	lddpc	r4,800051d4 <PcdComMF522+0x28>
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	4e 84       	lddpc	r4,800051a8 <rc522_init+0xd4>

8000500c <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
8000500c:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
8000500e:	31 4c       	mov	r12,20
80005010:	f0 1f 00 05 	mcall	80005024 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80005014:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80005018:	c0 51       	brne	80005022 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000501a:	30 3b       	mov	r11,3
8000501c:	31 4c       	mov	r12,20
8000501e:	f0 1f 00 03 	mcall	80005028 <PcdAntennaOn+0x1c>
80005022:	d8 02       	popm	pc
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	4f 44       	lddpc	r4,800051f4 <PcdComMF522+0x48>
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	4f e8       	lddpc	r8,80005220 <PcdComMF522+0x74>

8000502c <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
8000502c:	eb cd 40 c0 	pushm	r6-r7,lr
80005030:	18 97       	mov	r7,r12
80005032:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80005034:	f0 1f 00 06 	mcall	8000504c <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80005038:	5c d6       	com	r6
8000503a:	f9 e6 00 06 	and	r6,r12,r6
8000503e:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80005042:	0e 9c       	mov	r12,r7
80005044:	f0 1f 00 03 	mcall	80005050 <ClearBitMask+0x24>
	
}
80005048:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	4f 44       	lddpc	r4,8000521c <PcdComMF522+0x70>
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	4e 84       	lddpc	r4,800051f0 <PcdComMF522+0x44>

80005054 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80005054:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80005056:	30 3b       	mov	r11,3
80005058:	31 4c       	mov	r12,20
8000505a:	f0 1f 00 02 	mcall	80005060 <PcdAntennaOff+0xc>
}
8000505e:	d8 02       	popm	pc
80005060:	80 00       	ld.sh	r0,r0[0x0]
80005062:	50 2c       	stdsp	sp[0x8],r12

80005064 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80005064:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80005066:	34 18       	mov	r8,65
80005068:	f0 0c 18 00 	cp.b	r12,r8
8000506c:	c0 20       	breq	80005070 <M500PcdConfigISOType+0xc>
8000506e:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80005070:	30 8b       	mov	r11,8
80005072:	16 9c       	mov	r12,r11
80005074:	f0 1f 00 14 	mcall	800050c4 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80005078:	33 db       	mov	r11,61
8000507a:	31 1c       	mov	r12,17
8000507c:	f0 1f 00 13 	mcall	800050c8 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80005080:	e0 6b 00 86 	mov	r11,134
80005084:	31 7c       	mov	r12,23
80005086:	f0 1f 00 11 	mcall	800050c8 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
8000508a:	37 fb       	mov	r11,127
8000508c:	32 6c       	mov	r12,38
8000508e:	f0 1f 00 0f 	mcall	800050c8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80005092:	31 eb       	mov	r11,30
80005094:	32 dc       	mov	r12,45
80005096:	f0 1f 00 0d 	mcall	800050c8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
8000509a:	30 0b       	mov	r11,0
8000509c:	32 cc       	mov	r12,44
8000509e:	f0 1f 00 0b 	mcall	800050c8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800050a2:	e0 6b 00 8d 	mov	r11,141
800050a6:	32 ac       	mov	r12,42
800050a8:	f0 1f 00 08 	mcall	800050c8 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800050ac:	33 eb       	mov	r11,62
800050ae:	32 bc       	mov	r12,43
800050b0:	f0 1f 00 06 	mcall	800050c8 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800050b4:	e0 6c 03 e8 	mov	r12,1000
800050b8:	f0 1f 00 05 	mcall	800050cc <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800050bc:	f0 1f 00 05 	mcall	800050d0 <M500PcdConfigISOType+0x6c>
800050c0:	d8 0a       	popm	pc,r12=0
800050c2:	00 00       	add	r0,r0
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	50 2c       	stdsp	sp[0x8],r12
800050c8:	80 00       	ld.sh	r0,r0[0x0]
800050ca:	4e 84       	lddpc	r4,80005268 <PcdComMF522+0xbc>
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	57 d0       	stdsp	sp[0x1f4],r0
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	50 0c       	stdsp	sp[0x0],r12

800050d4 <rc522_init>:


//mfrc522 init

void rc522_init()
{
800050d4:	eb cd 40 c0 	pushm	r6-r7,lr
800050d8:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800050da:	4a 38       	lddpc	r8,80005164 <rc522_init+0x90>
800050dc:	1a 96       	mov	r6,sp
800050de:	f0 ea 00 00 	ld.d	r10,r8[0]
800050e2:	fa eb 00 00 	st.d	sp[0],r10
800050e6:	f0 e8 00 08 	ld.d	r8,r8[8]
800050ea:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
800050ee:	30 4b       	mov	r11,4
800050f0:	49 ec       	lddpc	r12,80005168 <rc522_init+0x94>
800050f2:	f0 1f 00 1f 	mcall	8000516c <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
800050f6:	31 9c       	mov	r12,25
800050f8:	f0 1f 00 1e 	mcall	80005170 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
800050fc:	31 9c       	mov	r12,25
800050fe:	f0 1f 00 1e 	mcall	80005174 <rc522_init+0xa0>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80005102:	49 e7       	lddpc	r7,80005178 <rc522_init+0xa4>
80005104:	fe 7c 24 00 	mov	r12,-56320
80005108:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
8000510a:	1a 9b       	mov	r11,sp
8000510c:	f0 1f 00 1c 	mcall	8000517c <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80005110:	30 09       	mov	r9,0
80005112:	12 9a       	mov	r10,r9
80005114:	12 9b       	mov	r11,r9
80005116:	6e 0c       	ld.w	r12,r7[0x0]
80005118:	f0 1f 00 1a 	mcall	80005180 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
8000511c:	6e 0c       	ld.w	r12,r7[0x0]
8000511e:	f0 1f 00 1a 	mcall	80005184 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80005122:	e0 6a 36 00 	mov	r10,13824
80005126:	ea 1a 01 6e 	orh	r10,0x16e
8000512a:	1a 9b       	mov	r11,sp
8000512c:	6e 0c       	ld.w	r12,r7[0x0]
8000512e:	f0 1f 00 17 	mcall	80005188 <rc522_init+0xb4>
80005132:	c0 50       	breq	8000513c <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80005134:	30 29       	mov	r9,2
80005136:	49 68       	lddpc	r8,8000518c <rc522_init+0xb8>
80005138:	b0 89       	st.b	r8[0x0],r9
8000513a:	c0 38       	rjmp	80005140 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
8000513c:	f0 1f 00 15 	mcall	80005190 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80005140:	f0 1f 00 15 	mcall	80005194 <rc522_init+0xc0>
	
	PcdAntennaOff();
80005144:	f0 1f 00 15 	mcall	80005198 <rc522_init+0xc4>
	
	delay_ms(2); 
80005148:	30 2c       	mov	r12,2
8000514a:	f0 1f 00 15 	mcall	8000519c <rc522_init+0xc8>
	
	PcdAntennaOn();
8000514e:	f0 1f 00 15 	mcall	800051a0 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80005152:	34 1c       	mov	r12,65
80005154:	f0 1f 00 14 	mcall	800051a4 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80005158:	30 1c       	mov	r12,1
8000515a:	f0 1f 00 14 	mcall	800051a8 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

8000515e:	2f cd       	sub	sp,-16
80005160:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	e0 cc 80 00 	sub	r12,r0,-32768
8000516a:	e0 e4 80 00 	ld.d	r4,r0[-32768]
8000516e:	5c 70       	castu.h	r0
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	5c a0       	swap.h	r0
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	5c b8       	swap.b	r8
80005178:	00 00       	add	r0,r0
8000517a:	20 3c       	sub	r12,3
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	60 e0       	ld.w	r0,r0[0x38]
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	61 18       	ld.w	r8,r0[0x44]
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	61 44       	ld.w	r4,r0[0x50]
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	61 88       	ld.w	r8,r0[0x60]
8000518c:	00 00       	add	r0,r0
8000518e:	0b 68       	ld.uh	r8,--r5
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	4e 18       	lddpc	r8,80005314 <PcdComMF522+0x168>
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	4e c4       	lddpc	r4,80005344 <PcdAnticoll+0x20>
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	50 54       	stdsp	sp[0x14],r4
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	58 10       	cp.w	r0,1
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	50 0c       	stdsp	sp[0x0],r12
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	50 64       	stdsp	sp[0x18],r4
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	4f 9c       	lddpc	r12,8000538c <PcdAnticoll+0x68>

800051ac <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
800051ac:	d4 31       	pushm	r0-r7,lr
800051ae:	20 1d       	sub	sp,4
800051b0:	18 92       	mov	r2,r12
800051b2:	16 95       	mov	r5,r11
800051b4:	14 96       	mov	r6,r10
800051b6:	50 09       	stdsp	sp[0x0],r9
800051b8:	10 90       	mov	r0,r8
800051ba:	f8 c8 00 0c 	sub	r8,r12,12
800051be:	5c 58       	castu.b	r8
800051c0:	30 29       	mov	r9,2
800051c2:	f2 08 18 00 	cp.b	r8,r9
800051c6:	e0 88 00 05 	brls	800051d0 <PcdComMF522+0x24>
800051ca:	30 03       	mov	r3,0
800051cc:	06 91       	mov	r1,r3
800051ce:	c0 78       	rjmp	800051dc <PcdComMF522+0x30>
800051d0:	4c f9       	lddpc	r9,8000530c <PcdComMF522+0x160>
800051d2:	f2 08 07 01 	ld.ub	r1,r9[r8]
800051d6:	4c f9       	lddpc	r9,80005310 <PcdComMF522+0x164>
800051d8:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
800051dc:	02 9b       	mov	r11,r1
800051de:	a7 bb       	sbr	r11,0x7
800051e0:	30 2c       	mov	r12,2
800051e2:	f0 1f 00 4d 	mcall	80005314 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
800051e6:	e0 6b 00 80 	mov	r11,128
800051ea:	30 4c       	mov	r12,4
800051ec:	f0 1f 00 4b 	mcall	80005318 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
800051f0:	30 0b       	mov	r11,0
800051f2:	30 1c       	mov	r12,1
800051f4:	f0 1f 00 48 	mcall	80005314 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
800051f8:	e0 6b 00 80 	mov	r11,128
800051fc:	30 ac       	mov	r12,10
800051fe:	f0 1f 00 48 	mcall	8000531c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80005202:	58 06       	cp.w	r6,0
80005204:	c0 c0       	breq	8000521c <PcdComMF522+0x70>
80005206:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80005208:	30 94       	mov	r4,9
8000520a:	0f 3b       	ld.ub	r11,r7++
8000520c:	08 9c       	mov	r12,r4
8000520e:	f0 1f 00 42 	mcall	80005314 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80005212:	0e 98       	mov	r8,r7
80005214:	0a 18       	sub	r8,r5
80005216:	ec 08 19 00 	cp.h	r8,r6
8000521a:	cf 83       	brcs	8000520a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
8000521c:	04 9b       	mov	r11,r2
8000521e:	30 1c       	mov	r12,1
80005220:	f0 1f 00 3d 	mcall	80005314 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80005224:	30 c8       	mov	r8,12
80005226:	f0 02 18 00 	cp.b	r2,r8
8000522a:	c0 61       	brne	80005236 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
8000522c:	e0 6b 00 80 	mov	r11,128
80005230:	30 dc       	mov	r12,13
80005232:	f0 1f 00 3b 	mcall	8000531c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80005236:	30 4c       	mov	r12,4
80005238:	f0 1f 00 3a 	mcall	80005320 <PcdComMF522+0x174>
8000523c:	18 97       	mov	r7,r12
8000523e:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80005242:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80005244:	30 44       	mov	r4,4
80005246:	c0 88       	rjmp	80005256 <PcdComMF522+0xaa>
80005248:	08 9c       	mov	r12,r4
8000524a:	f0 1f 00 36 	mcall	80005320 <PcdComMF522+0x174>
8000524e:	18 97       	mov	r7,r12
		i--;
80005250:	20 16       	sub	r6,1
80005252:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80005254:	c0 a0       	breq	80005268 <PcdComMF522+0xbc>
80005256:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
8000525a:	c4 c1       	brne	800052f2 <PcdComMF522+0x146>
8000525c:	ef e3 00 08 	and	r8,r7,r3
80005260:	ea 08 18 00 	cp.b	r8,r5
80005264:	cf 20       	breq	80005248 <PcdComMF522+0x9c>
80005266:	c4 68       	rjmp	800052f2 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80005268:	e0 6b 00 80 	mov	r11,128
8000526c:	30 dc       	mov	r12,13
8000526e:	f0 1f 00 2b 	mcall	80005318 <PcdComMF522+0x16c>
80005272:	30 27       	mov	r7,2
80005274:	c3 38       	rjmp	800052da <PcdComMF522+0x12e>
80005276:	02 67       	and	r7,r1
80005278:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
8000527c:	30 c8       	mov	r8,12
8000527e:	f0 02 18 00 	cp.b	r2,r8
80005282:	c2 c1       	brne	800052da <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80005284:	30 ac       	mov	r12,10
80005286:	f0 1f 00 27 	mcall	80005320 <PcdComMF522+0x174>
8000528a:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
8000528c:	30 cc       	mov	r12,12
8000528e:	f0 1f 00 25 	mcall	80005320 <PcdComMF522+0x174>
80005292:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80005296:	c0 70       	breq	800052a4 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80005298:	08 98       	mov	r8,r4
8000529a:	20 18       	sub	r8,1
8000529c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
800052a0:	a0 8c       	st.b	r0[0x0],r12
800052a2:	c0 48       	rjmp	800052aa <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
800052a4:	e8 08 15 03 	lsl	r8,r4,0x3
800052a8:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
800052aa:	58 04       	cp.w	r4,0
800052ac:	c0 61       	brne	800052b8 <PcdComMF522+0x10c>
800052ae:	30 14       	mov	r4,1
800052b0:	40 05       	lddsp	r5,sp[0x0]
800052b2:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
800052b4:	30 93       	mov	r3,9
800052b6:	c0 98       	rjmp	800052c8 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800052b8:	31 28       	mov	r8,18
800052ba:	f0 04 18 00 	cp.b	r4,r8
800052be:	f9 b4 0b 12 	movhi	r4,18
800052c2:	58 04       	cp.w	r4,0
800052c4:	cf 61       	brne	800052b0 <PcdComMF522+0x104>
800052c6:	c0 a8       	rjmp	800052da <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
800052c8:	06 9c       	mov	r12,r3
800052ca:	f0 1f 00 16 	mcall	80005320 <PcdComMF522+0x174>
800052ce:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800052d0:	ec 05 01 08 	sub	r8,r6,r5
800052d4:	e8 08 19 00 	cp.h	r8,r4
800052d8:	cf 83       	brcs	800052c8 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
800052da:	e0 6b 00 80 	mov	r11,128
800052de:	30 cc       	mov	r12,12
800052e0:	f0 1f 00 0f 	mcall	8000531c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
800052e4:	30 0b       	mov	r11,0
800052e6:	30 1c       	mov	r12,1
800052e8:	f0 1f 00 0b 	mcall	80005314 <PcdComMF522+0x168>
	return status;
}
800052ec:	0e 9c       	mov	r12,r7
800052ee:	2f fd       	sub	sp,-4
800052f0:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
800052f2:	e0 6b 00 80 	mov	r11,128
800052f6:	30 dc       	mov	r12,13
800052f8:	f0 1f 00 08 	mcall	80005318 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
800052fc:	30 6c       	mov	r12,6
800052fe:	f0 1f 00 09 	mcall	80005320 <PcdComMF522+0x174>
80005302:	e2 1c 00 1b 	andl	r12,0x1b,COH
80005306:	cb 80       	breq	80005276 <PcdComMF522+0xca>
80005308:	30 27       	mov	r7,2
8000530a:	ce 8b       	rjmp	800052da <PcdComMF522+0x12e>
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	e0 e0 80 00 	ld.d	r0,r0[-32768]
80005312:	e0 dc 80 00 	satsub.w	r12,r0,-32768
80005316:	4e 84       	lddpc	r4,800054b4 <PcdSelect+0x1c>
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	50 2c       	stdsp	sp[0x8],r12
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	4f e8       	lddpc	r8,80005514 <rfid_auto_reader+0x8>
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	4f 44       	lddpc	r4,800054f0 <PcdSelect+0x58>

80005324 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80005324:	eb cd 40 c0 	pushm	r6-r7,lr
80005328:	20 5d       	sub	sp,20
8000532a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
8000532c:	30 8b       	mov	r11,8
8000532e:	16 9c       	mov	r12,r11
80005330:	f0 1f 00 1a 	mcall	80005398 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80005334:	30 0b       	mov	r11,0
80005336:	30 dc       	mov	r12,13
80005338:	f0 1f 00 19 	mcall	8000539c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
8000533c:	e0 6b 00 80 	mov	r11,128
80005340:	30 ec       	mov	r12,14
80005342:	f0 1f 00 16 	mcall	80005398 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80005346:	39 38       	mov	r8,-109
80005348:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
8000534a:	32 08       	mov	r8,32
8000534c:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
8000534e:	1a 9b       	mov	r11,sp
80005350:	fa c8 ff ed 	sub	r8,sp,-19
80005354:	1a 99       	mov	r9,sp
80005356:	30 2a       	mov	r10,2
80005358:	30 cc       	mov	r12,12
8000535a:	f0 1f 00 12 	mcall	800053a0 <PcdAnticoll+0x7c>
8000535e:	18 97       	mov	r7,r12

	if (status == MI_OK)
80005360:	c1 21       	brne	80005384 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80005362:	1b 89       	ld.ub	r9,sp[0x0]
80005364:	ac 89       	st.b	r6[0x0],r9
80005366:	1b 98       	ld.ub	r8,sp[0x1]
80005368:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
8000536a:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
8000536c:	1b a8       	ld.ub	r8,sp[0x2]
8000536e:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80005370:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80005374:	1b b9       	ld.ub	r9,sp[0x3]
80005376:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80005378:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
8000537a:	1b c9       	ld.ub	r9,sp[0x4]
8000537c:	f0 09 18 00 	cp.b	r9,r8
80005380:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80005384:	e0 6b 00 80 	mov	r11,128
80005388:	30 ec       	mov	r12,14
8000538a:	f0 1f 00 07 	mcall	800053a4 <PcdAnticoll+0x80>
	return status;
}
8000538e:	0e 9c       	mov	r12,r7
80005390:	2f bd       	sub	sp,-20
80005392:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005396:	00 00       	add	r0,r0
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	50 2c       	stdsp	sp[0x8],r12
8000539c:	80 00       	ld.sh	r0,r0[0x0]
8000539e:	4e 84       	lddpc	r4,8000553c <rfid_auto_reader+0x30>
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	51 ac       	stdsp	sp[0x68],r12
800053a4:	80 00       	ld.sh	r0,r0[0x0]
800053a6:	4f e8       	lddpc	r8,8000559c <rfid_auto_reader+0x90>

800053a8 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
800053a8:	eb cd 40 c0 	pushm	r6-r7,lr
800053ac:	20 5d       	sub	sp,20
800053ae:	18 97       	mov	r7,r12
800053b0:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
800053b2:	30 8b       	mov	r11,8
800053b4:	16 9c       	mov	r12,r11
800053b6:	f0 1f 00 12 	mcall	800053fc <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
800053ba:	30 7b       	mov	r11,7
800053bc:	30 dc       	mov	r12,13
800053be:	f0 1f 00 11 	mcall	80005400 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
800053c2:	30 3b       	mov	r11,3
800053c4:	31 4c       	mov	r12,20
800053c6:	f0 1f 00 10 	mcall	80005404 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
800053ca:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
800053cc:	1a 9b       	mov	r11,sp
800053ce:	fa c8 ff ed 	sub	r8,sp,-19
800053d2:	1a 99       	mov	r9,sp
800053d4:	30 1a       	mov	r10,1
800053d6:	30 cc       	mov	r12,12
800053d8:	f0 1f 00 0c 	mcall	80005408 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
800053dc:	c0 c1       	brne	800053f4 <PcdRequest+0x4c>
800053de:	31 08       	mov	r8,16
800053e0:	fb 39 00 13 	ld.ub	r9,sp[19]
800053e4:	f0 09 18 00 	cp.b	r9,r8
800053e8:	c0 61       	brne	800053f4 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
800053ea:	1b 88       	ld.ub	r8,sp[0x0]
800053ec:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
800053ee:	1b 98       	ld.ub	r8,sp[0x1]
800053f0:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
800053f2:	c0 28       	rjmp	800053f6 <PcdRequest+0x4e>
800053f4:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
800053f6:	2f bd       	sub	sp,-20
800053f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053fc:	80 00       	ld.sh	r0,r0[0x0]
800053fe:	50 2c       	stdsp	sp[0x8],r12
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	4e 84       	lddpc	r4,800055a0 <rfid_auto_reader+0x94>
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	4f e8       	lddpc	r8,800055fc <rfid_auto_reader+0xf0>
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	51 ac       	stdsp	sp[0x68],r12

8000540c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
8000540c:	eb cd 40 f8 	pushm	r3-r7,lr
80005410:	18 95       	mov	r5,r12
80005412:	16 96       	mov	r6,r11
80005414:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80005416:	30 4b       	mov	r11,4
80005418:	30 5c       	mov	r12,5
8000541a:	f0 1f 00 1c 	mcall	80005488 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000541e:	30 0b       	mov	r11,0
80005420:	30 1c       	mov	r12,1
80005422:	f0 1f 00 1b 	mcall	8000548c <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80005426:	e0 6b 00 80 	mov	r11,128
8000542a:	30 ac       	mov	r12,10
8000542c:	f0 1f 00 19 	mcall	80005490 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80005430:	58 06       	cp.w	r6,0
80005432:	c0 c0       	breq	8000544a <CalulateCRC+0x3e>
80005434:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80005436:	30 94       	mov	r4,9
80005438:	0f 3b       	ld.ub	r11,r7++
8000543a:	08 9c       	mov	r12,r4
8000543c:	f0 1f 00 14 	mcall	8000548c <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80005440:	0e 98       	mov	r8,r7
80005442:	0a 18       	sub	r8,r5
80005444:	ec 08 18 00 	cp.b	r8,r6
80005448:	cf 83       	brcs	80005438 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
8000544a:	30 3b       	mov	r11,3
8000544c:	30 1c       	mov	r12,1
8000544e:	f0 1f 00 10 	mcall	8000548c <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80005452:	30 5c       	mov	r12,5
80005454:	f0 1f 00 10 	mcall	80005494 <CalulateCRC+0x88>
80005458:	e0 67 00 fe 	mov	r7,254
8000545c:	30 56       	mov	r6,5
8000545e:	c0 78       	rjmp	8000546c <CalulateCRC+0x60>
80005460:	0c 9c       	mov	r12,r6
80005462:	f0 1f 00 0d 	mcall	80005494 <CalulateCRC+0x88>
		i--;
80005466:	20 17       	sub	r7,1
80005468:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
8000546a:	c0 40       	breq	80005472 <CalulateCRC+0x66>
8000546c:	e2 1c 00 04 	andl	r12,0x4,COH
80005470:	cf 80       	breq	80005460 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80005472:	32 2c       	mov	r12,34
80005474:	f0 1f 00 08 	mcall	80005494 <CalulateCRC+0x88>
80005478:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
8000547a:	32 1c       	mov	r12,33
8000547c:	f0 1f 00 06 	mcall	80005494 <CalulateCRC+0x88>
80005480:	a6 9c       	st.b	r3[0x1],r12
}
80005482:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005486:	00 00       	add	r0,r0
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	50 2c       	stdsp	sp[0x8],r12
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	4e 84       	lddpc	r4,8000562c <scan_patrol>
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	4f e8       	lddpc	r8,80005688 <rfid_sendID_message+0x2c>
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	4f 44       	lddpc	r4,80005664 <rfid_sendID_message+0x8>

80005498 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005498:	eb cd 40 80 	pushm	r7,lr
8000549c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000549e:	39 38       	mov	r8,-109
800054a0:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
800054a2:	37 08       	mov	r8,112
800054a4:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
800054a6:	30 08       	mov	r8,0
800054a8:	ba e8       	st.b	sp[0x6],r8
800054aa:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
800054ae:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
800054b2:	19 89       	ld.ub	r9,r12[0x0]
800054b4:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
800054b6:	19 3a       	ld.ub	r10,r12++
800054b8:	1b e9       	ld.ub	r9,sp[0x6]
800054ba:	f5 e9 20 09 	eor	r9,r10,r9
800054be:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
800054c0:	16 38       	cp.w	r8,r11
800054c2:	cf 81       	brne	800054b2 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
800054c4:	1a 97       	mov	r7,sp
800054c6:	fa ca ff f9 	sub	r10,sp,-7
800054ca:	30 7b       	mov	r11,7
800054cc:	1a 9c       	mov	r12,sp
800054ce:	f0 1f 00 0d 	mcall	80005500 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
800054d2:	30 8b       	mov	r11,8
800054d4:	16 9c       	mov	r12,r11
800054d6:	f0 1f 00 0c 	mcall	80005504 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
800054da:	fa c8 ff ed 	sub	r8,sp,-19
800054de:	1a 99       	mov	r9,sp
800054e0:	30 9a       	mov	r10,9
800054e2:	1a 9b       	mov	r11,sp
800054e4:	30 cc       	mov	r12,12
800054e6:	f0 1f 00 09 	mcall	80005508 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
800054ea:	c0 71       	brne	800054f8 <PcdSelect+0x60>
800054ec:	31 88       	mov	r8,24
800054ee:	fb 39 00 13 	ld.ub	r9,sp[19]
800054f2:	f0 09 18 00 	cp.b	r9,r8
800054f6:	c0 20       	breq	800054fa <PcdSelect+0x62>
800054f8:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
800054fa:	2f bd       	sub	sp,-20
800054fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	54 0c       	stdsp	sp[0x100],r12
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	50 2c       	stdsp	sp[0x8],r12
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	51 ac       	stdsp	sp[0x68],r12

8000550c <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
8000550c:	eb cd 40 c0 	pushm	r6-r7,lr
80005510:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80005512:	f0 1f 00 37 	mcall	800055ec <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80005516:	4b 7b       	lddpc	r11,800055f0 <rfid_auto_reader+0xe4>
80005518:	35 2c       	mov	r12,82
8000551a:	f0 1f 00 37 	mcall	800055f4 <rfid_auto_reader+0xe8>
8000551e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80005520:	c6 31       	brne	800055e6 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005522:	4b 48       	lddpc	r8,800055f0 <rfid_auto_reader+0xe4>
80005524:	11 88       	ld.ub	r8,r8[0x0]
80005526:	30 49       	mov	r9,4
80005528:	f2 08 18 00 	cp.b	r8,r9
8000552c:	c0 b1       	brne	80005542 <rfid_auto_reader+0x36>
8000552e:	4b 19       	lddpc	r9,800055f0 <rfid_auto_reader+0xe4>
80005530:	13 9a       	ld.ub	r10,r9[0x1]
80005532:	30 09       	mov	r9,0
80005534:	f2 0a 18 00 	cp.b	r10,r9
80005538:	c0 51       	brne	80005542 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
8000553a:	4b 0c       	lddpc	r12,800055f8 <rfid_auto_reader+0xec>
8000553c:	f0 1f 00 30 	mcall	800055fc <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005540:	c3 c8       	rjmp	800055b8 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005542:	30 29       	mov	r9,2
80005544:	f2 08 18 00 	cp.b	r8,r9
80005548:	c0 b1       	brne	8000555e <rfid_auto_reader+0x52>
8000554a:	4a a9       	lddpc	r9,800055f0 <rfid_auto_reader+0xe4>
8000554c:	13 9a       	ld.ub	r10,r9[0x1]
8000554e:	30 09       	mov	r9,0
80005550:	f2 0a 18 00 	cp.b	r10,r9
80005554:	c0 51       	brne	8000555e <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80005556:	4a bc       	lddpc	r12,80005600 <rfid_auto_reader+0xf4>
80005558:	f0 1f 00 29 	mcall	800055fc <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
8000555c:	c2 e8       	rjmp	800055b8 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
8000555e:	34 49       	mov	r9,68
80005560:	f2 08 18 00 	cp.b	r8,r9
80005564:	c0 b1       	brne	8000557a <rfid_auto_reader+0x6e>
80005566:	4a 39       	lddpc	r9,800055f0 <rfid_auto_reader+0xe4>
80005568:	13 9a       	ld.ub	r10,r9[0x1]
8000556a:	30 09       	mov	r9,0
8000556c:	f2 0a 18 00 	cp.b	r10,r9
80005570:	c0 51       	brne	8000557a <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80005572:	4a 5c       	lddpc	r12,80005604 <rfid_auto_reader+0xf8>
80005574:	f0 1f 00 22 	mcall	800055fc <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005578:	c2 08       	rjmp	800055b8 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000557a:	30 89       	mov	r9,8
8000557c:	f2 08 18 00 	cp.b	r8,r9
80005580:	c0 b1       	brne	80005596 <rfid_auto_reader+0x8a>
80005582:	49 c9       	lddpc	r9,800055f0 <rfid_auto_reader+0xe4>
80005584:	13 9a       	ld.ub	r10,r9[0x1]
80005586:	30 09       	mov	r9,0
80005588:	f2 0a 18 00 	cp.b	r10,r9
8000558c:	c0 51       	brne	80005596 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
8000558e:	49 fc       	lddpc	r12,80005608 <rfid_auto_reader+0xfc>
80005590:	f0 1f 00 1b 	mcall	800055fc <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005594:	c1 28       	rjmp	800055b8 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005596:	34 49       	mov	r9,68
80005598:	f2 08 18 00 	cp.b	r8,r9
8000559c:	c0 b1       	brne	800055b2 <rfid_auto_reader+0xa6>
8000559e:	49 58       	lddpc	r8,800055f0 <rfid_auto_reader+0xe4>
800055a0:	11 99       	ld.ub	r9,r8[0x1]
800055a2:	30 38       	mov	r8,3
800055a4:	f0 09 18 00 	cp.b	r9,r8
800055a8:	c0 51       	brne	800055b2 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
800055aa:	49 9c       	lddpc	r12,8000560c <rfid_auto_reader+0x100>
800055ac:	f0 1f 00 14 	mcall	800055fc <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
800055b0:	c0 48       	rjmp	800055b8 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
800055b2:	49 8c       	lddpc	r12,80005610 <rfid_auto_reader+0x104>
800055b4:	f0 1f 00 12 	mcall	800055fc <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
800055b8:	49 7c       	lddpc	r12,80005614 <rfid_auto_reader+0x108>
800055ba:	f0 1f 00 18 	mcall	80005618 <rfid_auto_reader+0x10c>
800055be:	18 97       	mov	r7,r12
	if(status!=MI_OK)
800055c0:	c0 60       	breq	800055cc <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
800055c2:	37 8b       	mov	r11,120
800055c4:	30 1c       	mov	r12,1
800055c6:	f0 1f 00 16 	mcall	8000561c <rfid_auto_reader+0x110>
		return status;
800055ca:	c0 e8       	rjmp	800055e6 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
800055cc:	49 2c       	lddpc	r12,80005614 <rfid_auto_reader+0x108>
800055ce:	f0 1f 00 15 	mcall	80005620 <rfid_auto_reader+0x114>
800055d2:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
800055d4:	c0 91       	brne	800055e6 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800055d6:	30 4a       	mov	r10,4
800055d8:	48 fb       	lddpc	r11,80005614 <rfid_auto_reader+0x108>
800055da:	0c 9c       	mov	r12,r6
800055dc:	f0 1f 00 12 	mcall	80005624 <rfid_auto_reader+0x118>
		log("select okay\n");
800055e0:	49 2c       	lddpc	r12,80005628 <rfid_auto_reader+0x11c>
800055e2:	f0 1f 00 07 	mcall	800055fc <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
800055e6:	0e 9c       	mov	r12,r7
800055e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	4e c4       	lddpc	r4,8000579c <rfid_sendID_message+0x140>
800055f0:	00 00       	add	r0,r0
800055f2:	53 c4       	stdsp	sp[0xf0],r4
800055f4:	80 00       	ld.sh	r0,r0[0x0]
800055f6:	53 a8       	stdsp	sp[0xe8],r8
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	e1 04 80 00 	ld.sh	r4,r0[-32768]
800055fe:	78 34       	ld.w	r4,r12[0xc]
80005600:	80 00       	ld.sh	r0,r0[0x0]
80005602:	e1 10 80 00 	ld.uh	r0,r0[-32768]
80005606:	e1 1c 80 00 	ld.uh	r12,r0[-32768]
8000560a:	e1 2c 80 00 	ld.sb	r12,r0[-32768]
8000560e:	e1 34 80 00 	ld.ub	r4,r0[-32768]
80005612:	e1 40 00 00 	st.w	r0[0],r0
80005616:	53 c8       	stdsp	sp[0xf0],r8
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	53 24       	stdsp	sp[0xc8],r4
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	46 18       	lddsp	r8,sp[0x184]
80005620:	80 00       	ld.sh	r0,r0[0x0]
80005622:	54 98       	stdsp	sp[0x124],r8
80005624:	80 00       	ld.sh	r0,r0[0x0]
80005626:	80 b0       	ld.uh	r0,r0[0x6]
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	e1 4c eb cd 	st.w	r0[-5171],r12

8000562c <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
8000562c:	eb cd 40 80 	pushm	r7,lr
80005630:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005632:	f0 1f 00 08 	mcall	80005650 <scan_patrol+0x24>
	Powerdown_RC522(WAKEUP_RC522);
80005636:	30 0c       	mov	r12,0
80005638:	f0 1f 00 07 	mcall	80005654 <scan_patrol+0x28>
	return_err = rfid_auto_reader(SN);
8000563c:	0e 9c       	mov	r12,r7
8000563e:	f0 1f 00 07 	mcall	80005658 <scan_patrol+0x2c>
80005642:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80005644:	30 1c       	mov	r12,1
80005646:	f0 1f 00 04 	mcall	80005654 <scan_patrol+0x28>
	//else
		//log("scan_patrol err!\n");
		
	return return_err;

}
8000564a:	0e 9c       	mov	r12,r7
8000564c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005650:	80 00       	ld.sh	r0,r0[0x0]
80005652:	4e c4       	lddpc	r4,80005800 <delay_us+0x18>
80005654:	80 00       	ld.sh	r0,r0[0x0]
80005656:	4f 9c       	lddpc	r12,80005838 <local_start_timer>
80005658:	80 00       	ld.sh	r0,r0[0x0]
8000565a:	55 0c       	stdsp	sp[0x140],r12

8000565c <rfid_sendID_message>:
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
8000565c:	eb cd 40 e0 	pushm	r5-r7,lr
80005660:	21 cd       	sub	sp,112
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80005662:	4c ec       	lddpc	r12,80005798 <rfid_sendID_message+0x13c>
80005664:	30 08       	mov	r8,0
80005666:	30 09       	mov	r9,0
80005668:	f8 e9 00 00 	st.d	r12[0],r8
8000566c:	30 0a       	mov	r10,0
8000566e:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005670:	fa e9 00 20 	st.d	sp[32],r8
80005674:	fa e9 00 28 	st.d	sp[40],r8
80005678:	fa e9 00 30 	st.d	sp[48],r8
8000567c:	fa e9 00 38 	st.d	sp[56],r8
80005680:	fa e9 00 40 	st.d	sp[64],r8
80005684:	fa e9 00 48 	st.d	sp[72],r8
80005688:	fa e9 00 50 	st.d	sp[80],r8
8000568c:	fa e9 00 58 	st.d	sp[88],r8
80005690:	fa e9 00 60 	st.d	sp[96],r8
80005694:	fa e9 00 68 	st.d	sp[104],r8
	//PcdReset();
	//Powerdown_RC522(WAKEUP_RC522);
	//return_err = rfid_auto_reader(SN);
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	return_err = scan_patrol(SN);
80005698:	f0 1f 00 41 	mcall	8000579c <rfid_sendID_message+0x140>
8000569c:	18 97       	mov	r7,r12
	
	if(return_err == 0){
8000569e:	c7 11       	brne	80005780 <rfid_sendID_message+0x124>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800056a0:	4b e6       	lddpc	r6,80005798 <rfid_sendID_message+0x13c>
800056a2:	0d b8       	ld.ub	r8,r6[0x3]
800056a4:	1a d8       	st.w	--sp,r8
800056a6:	0d a8       	ld.ub	r8,r6[0x2]
800056a8:	1a d8       	st.w	--sp,r8
800056aa:	0d 98       	ld.ub	r8,r6[0x1]
800056ac:	1a d8       	st.w	--sp,r8
800056ae:	0d 88       	ld.ub	r8,r6[0x0]
800056b0:	1a d8       	st.w	--sp,r8
800056b2:	4b cc       	lddpc	r12,800057a0 <rfid_sendID_message+0x144>
800056b4:	f0 1f 00 3c 	mcall	800057a4 <rfid_sendID_message+0x148>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
800056b8:	37 7b       	mov	r11,119
800056ba:	30 1c       	mov	r12,1
800056bc:	f0 1f 00 3b 	mcall	800057a8 <rfid_sendID_message+0x14c>
800056c0:	fa c8 ff f0 	sub	r8,sp,-16
800056c4:	fa c9 ff ee 	sub	r9,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
800056c8:	ec c5 ff fc 	sub	r5,r6,-4
800056cc:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800056ce:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
800056d0:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
800056d2:	0d 8a       	ld.ub	r10,r6[0x0]
800056d4:	f4 0b 16 04 	lsr	r11,r10,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800056d8:	fc 0b 18 00 	cp.b	r11,lr
800056dc:	f7 bb 08 d0 	subls	r11,-48
800056e0:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
800056e4:	f7 bb 0b a9 	subhi	r11,-87
800056e8:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
800056ec:	b0 9c       	st.b	r8[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
800056ee:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
800056f2:	fc 0a 18 00 	cp.b	r10,lr
800056f6:	f7 ba 08 d0 	subls	r10,-48
800056fa:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
800056fe:	f7 ba 0b a9 	subhi	r10,-87
80005702:	f3 fa be 00 	st.bhi	r9[0x0],r10

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80005706:	b0 bc       	st.b	r8[0x3],r12
80005708:	2f f6       	sub	r6,-1
8000570a:	2f c8       	sub	r8,-4
8000570c:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
8000570e:	0a 36       	cp.w	r6,r5
80005710:	ce 11       	brne	800056d2 <rfid_sendID_message+0x76>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005712:	30 6a       	mov	r10,6
80005714:	4a 6b       	lddpc	r11,800057ac <rfid_sendID_message+0x150>
80005716:	fa cc ff f0 	sub	r12,sp,-16
8000571a:	f0 1f 00 26 	mcall	800057b0 <rfid_sendID_message+0x154>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
8000571e:	4a 68       	lddpc	r8,800057b4 <rfid_sendID_message+0x158>
80005720:	11 89       	ld.ub	r9,r8[0x0]
80005722:	39 f8       	mov	r8,-97
80005724:	f0 09 18 00 	cp.b	r9,r8
80005728:	e0 88 00 05 	brls	80005732 <rfid_sendID_message+0xd6>
8000572c:	38 09       	mov	r9,-128
8000572e:	4a 28       	lddpc	r8,800057b4 <rfid_sendID_message+0x158>
80005730:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80005732:	4a 18       	lddpc	r8,800057b4 <rfid_sendID_message+0x158>
80005734:	11 86       	ld.ub	r6,r8[0x0]
80005736:	2f f6       	sub	r6,-1
80005738:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
8000573a:	30 5a       	mov	r10,5
8000573c:	49 fb       	lddpc	r11,800057b8 <rfid_sendID_message+0x15c>
8000573e:	fa cc ff e5 	sub	r12,sp,-27
80005742:	f0 1f 00 1c 	mcall	800057b0 <rfid_sendID_message+0x154>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005746:	31 e8       	mov	r8,30
80005748:	fb 58 00 16 	st.h	sp[22],r8
8000574c:	fb 66 00 1a 	st.b	sp[26],r6
80005750:	fe 78 e0 00 	mov	r8,-8192
80005754:	fb 58 00 18 	st.h	sp[24],r8
80005758:	fa c6 ff e0 	sub	r6,sp,-32
8000575c:	30 aa       	mov	r10,10
8000575e:	fa cb ff ea 	sub	r11,sp,-22
80005762:	0c 9c       	mov	r12,r6
80005764:	f0 1f 00 13 	mcall	800057b0 <rfid_sendID_message+0x154>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005768:	31 6a       	mov	r10,22
8000576a:	1a 9b       	mov	r11,sp
8000576c:	fa cc ff d6 	sub	r12,sp,-42
80005770:	f0 1f 00 10 	mcall	800057b0 <rfid_sendID_message+0x154>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80005774:	30 9a       	mov	r10,9
80005776:	32 0b       	mov	r11,32
80005778:	0c 9c       	mov	r12,r6
8000577a:	f0 1f 00 11 	mcall	800057bc <rfid_sendID_message+0x160>
8000577e:	c0 88       	rjmp	8000578e <rfid_sendID_message+0x132>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80005780:	37 8b       	mov	r11,120
80005782:	30 1c       	mov	r12,1
80005784:	f0 1f 00 09 	mcall	800057a8 <rfid_sendID_message+0x14c>
		log("no card find...\n");
80005788:	48 ec       	lddpc	r12,800057c0 <rfid_sendID_message+0x164>
8000578a:	f0 1f 00 07 	mcall	800057a4 <rfid_sendID_message+0x148>
	}
	
	return return_err;
	
}
8000578e:	0e 9c       	mov	r12,r7
80005790:	2e 4d       	sub	sp,-112
80005792:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005796:	00 00       	add	r0,r0
80005798:	00 00       	add	r0,r0
8000579a:	0b 6c       	ld.uh	r12,--r5
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	56 2c       	stdsp	sp[0x188],r12
800057a0:	80 00       	ld.sh	r0,r0[0x0]
800057a2:	e1 5c 80 00 	st.h	r0[-32768],r12
800057a6:	78 34       	ld.w	r4,r12[0xc]
800057a8:	80 00       	ld.sh	r0,r0[0x0]
800057aa:	46 18       	lddsp	r8,sp[0x184]
800057ac:	00 00       	add	r0,r0
800057ae:	0d b4       	ld.ub	r4,r6[0x3]
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	80 b0       	ld.uh	r0,r0[0x6]
800057b4:	00 00       	add	r0,r0
800057b6:	05 34       	ld.ub	r4,r2++
800057b8:	00 00       	add	r0,r0
800057ba:	05 2c       	ld.uh	r12,r2++
800057bc:	80 00       	ld.sh	r0,r0[0x0]
800057be:	44 e0       	lddsp	r0,sp[0x138]
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	e1 78 d4 01 	stcond	r0[-11263],r8

800057c4 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
800057c4:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800057c6:	f0 1f 00 02 	mcall	800057cc <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
800057ca:	d8 02       	popm	pc
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	50 d4       	stdsp	sp[0x34],r4

800057d0 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800057d0:	58 0c       	cp.w	r12,0
800057d2:	5e 0c       	reteq	r12
800057d4:	30 08       	mov	r8,0
	{
		nop();
800057d6:	d7 03       	nop
		nop();
800057d8:	d7 03       	nop
		nop();
800057da:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800057dc:	2f f8       	sub	r8,-1
800057de:	10 3c       	cp.w	r12,r8
800057e0:	fe 9b ff fb 	brhi	800057d6 <delay_ns+0x6>
800057e4:	5e fc       	retal	r12
800057e6:	d7 03       	nop

800057e8 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800057e8:	eb cd 40 e0 	pushm	r5-r7,lr
800057ec:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800057ee:	58 0c       	cp.w	r12,0
800057f0:	c0 b0       	breq	80005806 <delay_us+0x1e>
800057f2:	30 07       	mov	r7,0
		delay_ns(1000);
800057f4:	e0 65 03 e8 	mov	r5,1000
800057f8:	0a 9c       	mov	r12,r5
800057fa:	f0 1f 00 05 	mcall	8000580c <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800057fe:	2f f7       	sub	r7,-1
80005800:	0e 36       	cp.w	r6,r7
80005802:	fe 9b ff fb 	brhi	800057f8 <delay_us+0x10>
80005806:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000580a:	00 00       	add	r0,r0
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	57 d0       	stdsp	sp[0x1f4],r0

80005810 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005810:	eb cd 40 e0 	pushm	r5-r7,lr
80005814:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005816:	58 0c       	cp.w	r12,0
80005818:	c0 b0       	breq	8000582e <delay_ms+0x1e>
8000581a:	30 07       	mov	r7,0
		delay_us(1000);
8000581c:	e0 65 03 e8 	mov	r5,1000
80005820:	0a 9c       	mov	r12,r5
80005822:	f0 1f 00 05 	mcall	80005834 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005826:	2f f7       	sub	r7,-1
80005828:	0e 36       	cp.w	r6,r7
8000582a:	fe 9b ff fb 	brhi	80005820 <delay_ms+0x10>
8000582e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005832:	00 00       	add	r0,r0
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	57 e8       	stdsp	sp[0x1f8],r8

80005838 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005838:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
8000583a:	30 3b       	mov	r11,3
8000583c:	48 8c       	lddpc	r12,8000585c <local_start_timer+0x24>
8000583e:	f0 1f 00 09 	mcall	80005860 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005842:	fe 78 38 00 	mov	r8,-51200
80005846:	e0 69 91 0d 	mov	r9,37133
8000584a:	ea 19 00 52 	orh	r9,0x52
8000584e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005850:	32 09       	mov	r9,32
80005852:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005854:	30 59       	mov	r9,5
80005856:	91 09       	st.w	r8[0x0],r9
}
80005858:	d8 02       	popm	pc
8000585a:	00 00       	add	r0,r0
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	e1 8c       	*unknown*
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	5c 70       	castu.h	r0

80005864 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005864:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005866:	30 3a       	mov	r10,3
80005868:	e0 6b 1b 00 	mov	r11,6912
8000586c:	ea 1b 00 b7 	orh	r11,0xb7
80005870:	fe 7c 0c 00 	mov	r12,-62464
80005874:	f0 1f 00 19 	mcall	800058d8 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005878:	31 08       	mov	r8,16
8000587a:	1a d8       	st.w	--sp,r8
8000587c:	30 08       	mov	r8,0
8000587e:	30 19       	mov	r9,1
80005880:	30 7a       	mov	r10,7
80005882:	10 9b       	mov	r11,r8
80005884:	fe 7c 0c 00 	mov	r12,-62464
80005888:	f0 1f 00 15 	mcall	800058dc <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
8000588c:	30 08       	mov	r8,0
8000588e:	30 19       	mov	r9,1
80005890:	12 9a       	mov	r10,r9
80005892:	10 9b       	mov	r11,r8
80005894:	fe 7c 0c 00 	mov	r12,-62464
80005898:	f0 1f 00 12 	mcall	800058e0 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
8000589c:	30 0b       	mov	r11,0
8000589e:	fe 7c 0c 00 	mov	r12,-62464
800058a2:	f0 1f 00 11 	mcall	800058e4 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
800058a6:	fe 7c 0c 00 	mov	r12,-62464
800058aa:	f0 1f 00 10 	mcall	800058e8 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
800058ae:	30 0a       	mov	r10,0
800058b0:	1a da       	st.w	--sp,r10
800058b2:	1a da       	st.w	--sp,r10
800058b4:	14 98       	mov	r8,r10
800058b6:	14 99       	mov	r9,r10
800058b8:	30 1b       	mov	r11,1
800058ba:	fe 7c 0c 00 	mov	r12,-62464
800058be:	f0 1f 00 0c 	mcall	800058ec <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800058c2:	30 1c       	mov	r12,1
800058c4:	f0 1f 00 0b 	mcall	800058f0 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800058c8:	30 2b       	mov	r11,2
800058ca:	fe 7c 0c 00 	mov	r12,-62464
800058ce:	f0 1f 00 0a 	mcall	800058f4 <local_start_pll0+0x90>
800058d2:	2f dd       	sub	sp,-12
/****/
}
800058d4:	d8 02       	popm	pc
800058d6:	00 00       	add	r0,r0
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	5f 78       	srpl	r8
800058dc:	80 00       	ld.sh	r0,r0[0x0]
800058de:	5f 1a       	srne	r10
800058e0:	80 00       	ld.sh	r0,r0[0x0]
800058e2:	5f 3c       	srlo	r12
800058e4:	80 00       	ld.sh	r0,r0[0x0]
800058e6:	5f 56       	srlt	r6
800058e8:	80 00       	ld.sh	r0,r0[0x0]
800058ea:	5f 64       	srmi	r4
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	5e d4       	retvc	r4
800058f0:	80 00       	ld.sh	r0,r0[0x0]
800058f2:	5c 10       	scr	r0
800058f4:	80 00       	ld.sh	r0,r0[0x0]
800058f6:	5f 6e       	srmi	lr

800058f8 <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
800058f8:	d4 31       	pushm	r0-r7,lr
800058fa:	20 2d       	sub	sp,8
800058fc:	18 95       	mov	r5,r12
800058fe:	16 96       	mov	r6,r11
80005900:	14 91       	mov	r1,r10
	if(!list_init_success_flag)return XG_ERROR;
80005902:	4c b8       	lddpc	r8,80005a2c <xgflash_get_message_data+0x134>
80005904:	11 89       	ld.ub	r9,r8[0x0]
80005906:	30 08       	mov	r8,0
80005908:	f0 09 18 00 	cp.b	r9,r8
8000590c:	c0 31       	brne	80005912 <xgflash_get_message_data+0x1a>
8000590e:	3f fc       	mov	r12,-1
80005910:	c8 b8       	rjmp	80005a26 <xgflash_get_message_data+0x12e>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80005912:	4c 88       	lddpc	r8,80005a30 <xgflash_get_message_data+0x138>
80005914:	70 0c       	ld.w	r12,r8[0x0]
80005916:	30 09       	mov	r9,0
80005918:	3f fa       	mov	r10,-1
8000591a:	12 9b       	mov	r11,r9
8000591c:	f0 1f 00 46 	mcall	80005a34 <xgflash_get_message_data+0x13c>
	/* check input parameter */
	if (message_index > current_message_index)
80005920:	4c 68       	lddpc	r8,80005a38 <xgflash_get_message_data+0x140>
80005922:	90 88       	ld.uh	r8,r8[0x0]
80005924:	0a 38       	cp.w	r8,r5
80005926:	c0 a2       	brcc	8000593a <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
80005928:	4c 28       	lddpc	r8,80005a30 <xgflash_get_message_data+0x138>
8000592a:	70 0c       	ld.w	r12,r8[0x0]
8000592c:	30 09       	mov	r9,0
8000592e:	12 9a       	mov	r10,r9
80005930:	12 9b       	mov	r11,r9
80005932:	f0 1f 00 43 	mcall	80005a3c <xgflash_get_message_data+0x144>
80005936:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
80005938:	c7 78       	rjmp	80005a26 <xgflash_get_message_data+0x12e>
	
	df_status_t return_code = DF_OK;
	U32 info_address =0x00000000;
	U32 data_address =0x00000000;
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
8000593a:	fa ca ff f8 	sub	r10,sp,-8
8000593e:	30 08       	mov	r8,0
80005940:	30 09       	mov	r9,0
80005942:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005944:	ea 00 15 03 	lsl	r0,r5,0x3
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
80005948:	1a 9a       	mov	r10,sp
8000594a:	30 8b       	mov	r11,8
8000594c:	00 9c       	mov	r12,r0
8000594e:	f0 1f 00 3d 	mcall	80005a40 <xgflash_get_message_data+0x148>
	if (return_code == DF_OK)
80005952:	c6 21       	brne	80005a16 <xgflash_get_message_data+0x11e>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
80005954:	9a 88       	ld.uh	r8,sp[0x0]
80005956:	0a 38       	cp.w	r8,r5
80005958:	c5 61       	brne	80005a04 <xgflash_get_message_data+0x10c>
		{
			bytes_remained = ptr->offset;
8000595a:	40 18       	lddsp	r8,sp[0x4]
8000595c:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			data_address = ptr->address;
80005960:	9a 95       	ld.uh	r5,sp[0x2]
80005962:	b1 88       	lsr	r8,0x10
80005964:	f1 e5 11 05 	or	r5,r8,r5<<0x10
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005968:	30 04       	mov	r4,0
8000596a:	08 93       	mov	r3,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
8000596c:	e0 62 01 ff 	mov	r2,511
		if(ptr->numb == message_index)
		{
			bytes_remained = ptr->offset;
			data_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005970:	c1 88       	rjmp	800059a0 <xgflash_get_message_data+0xa8>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80005972:	e4 07 19 00 	cp.h	r7,r2
80005976:	e0 8b 00 0a 	brhi	8000598a <xgflash_get_message_data+0x92>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
8000597a:	0c 9a       	mov	r10,r6
8000597c:	0e 9b       	mov	r11,r7
8000597e:	5c 7b       	castu.h	r11
80005980:	0a 9c       	mov	r12,r5
80005982:	f0 1f 00 30 	mcall	80005a40 <xgflash_get_message_data+0x148>
80005986:	30 07       	mov	r7,0
80005988:	c0 c8       	rjmp	800059a0 <xgflash_get_message_data+0xa8>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
8000598a:	0c 9a       	mov	r10,r6
8000598c:	e0 6b 02 00 	mov	r11,512
80005990:	0a 9c       	mov	r12,r5
80005992:	f0 1f 00 2c 	mcall	80005a40 <xgflash_get_message_data+0x148>
					bytes_remained-=DF_DATA_SPACE_SIZE;
80005996:	ee c7 02 00 	sub	r7,r7,512
8000599a:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
8000599c:	ea c5 fe 00 	sub	r5,r5,-512
		if(ptr->numb == message_index)
		{
			bytes_remained = ptr->offset;
			data_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
800059a0:	e8 07 19 00 	cp.h	r7,r4
800059a4:	5f 19       	srne	r9
800059a6:	58 0c       	cp.w	r12,0
800059a8:	5f 08       	sreq	r8
800059aa:	f3 e8 00 08 	and	r8,r9,r8
800059ae:	e6 08 18 00 	cp.b	r8,r3
800059b2:	ce 01       	brne	80005972 <xgflash_get_message_data+0x7a>
						
				}
				//memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
			}
			
			if(erase)//erase the message
800059b4:	58 01       	cp.w	r1,0
800059b6:	c1 e0       	breq	800059f2 <xgflash_get_message_data+0xfa>
			{
				//erase data and reset:current_save_message_offset
				memset(str, 0x00, sizeof(str));
800059b8:	fa c6 ff f8 	sub	r6,sp,-8
800059bc:	30 08       	mov	r8,0
800059be:	30 09       	mov	r9,0
800059c0:	ad 29       	st.d	--r6,r8
				return_code = data_flash_write((U8 *)str, data_address, bytes_remained);
800059c2:	5c 77       	castu.h	r7
800059c4:	0e 9a       	mov	r10,r7
800059c6:	0a 9b       	mov	r11,r5
800059c8:	1a 9c       	mov	r12,sp
800059ca:	f0 1f 00 1f 	mcall	80005a44 <xgflash_get_message_data+0x14c>
				current_save_message_offset-=bytes_remained;
800059ce:	49 f8       	lddpc	r8,80005a48 <xgflash_get_message_data+0x150>
800059d0:	70 09       	ld.w	r9,r8[0x0]
800059d2:	0e 19       	sub	r9,r7
800059d4:	91 09       	st.w	r8[0x0],r9
				//erase info and reset:current_message_index
				current_message_index-=1;
800059d6:	49 97       	lddpc	r7,80005a38 <xgflash_get_message_data+0x140>
800059d8:	8e 08       	ld.sh	r8,r7[0x0]
800059da:	20 18       	sub	r8,1
800059dc:	ae 08       	st.h	r7[0x0],r8
				return_code = data_flash_write((U8 *)str, info_address, XG_MESSAGE_INFO_HEADER_LENGTH);
800059de:	30 8a       	mov	r10,8
800059e0:	00 9b       	mov	r11,r0
800059e2:	1a 9c       	mov	r12,sp
800059e4:	f0 1f 00 18 	mcall	80005a44 <xgflash_get_message_data+0x14c>
				return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, XG_MESSAGE_INFO_HEADER_LENGTH);
800059e8:	30 8a       	mov	r10,8
800059ea:	30 6b       	mov	r11,6
800059ec:	0e 9c       	mov	r12,r7
800059ee:	f0 1f 00 16 	mcall	80005a44 <xgflash_get_message_data+0x14c>
			}
		
			xSemaphoreGive(xgflash_mutex);//unlock
800059f2:	49 08       	lddpc	r8,80005a30 <xgflash_get_message_data+0x138>
800059f4:	70 0c       	ld.w	r12,r8[0x0]
800059f6:	30 09       	mov	r9,0
800059f8:	12 9a       	mov	r10,r9
800059fa:	12 9b       	mov	r11,r9
800059fc:	f0 1f 00 10 	mcall	80005a3c <xgflash_get_message_data+0x144>
80005a00:	30 0c       	mov	r12,0
			return XG_OK;
80005a02:	c1 28       	rjmp	80005a26 <xgflash_get_message_data+0x12e>
		}
		xSemaphoreGive(xgflash_mutex);//unlock
80005a04:	48 b8       	lddpc	r8,80005a30 <xgflash_get_message_data+0x138>
80005a06:	70 0c       	ld.w	r12,r8[0x0]
80005a08:	30 09       	mov	r9,0
80005a0a:	12 9a       	mov	r10,r9
80005a0c:	12 9b       	mov	r11,r9
80005a0e:	f0 1f 00 0c 	mcall	80005a3c <xgflash_get_message_data+0x144>
80005a12:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
80005a14:	c0 98       	rjmp	80005a26 <xgflash_get_message_data+0x12e>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
80005a16:	48 78       	lddpc	r8,80005a30 <xgflash_get_message_data+0x138>
80005a18:	70 0c       	ld.w	r12,r8[0x0]
80005a1a:	30 09       	mov	r9,0
80005a1c:	12 9a       	mov	r10,r9
80005a1e:	12 9b       	mov	r11,r9
80005a20:	f0 1f 00 07 	mcall	80005a3c <xgflash_get_message_data+0x144>
80005a24:	30 6c       	mov	r12,6
	return XG_FLASH_ACTION_FAIL;
		
}
80005a26:	2f ed       	sub	sp,-8
80005a28:	d8 32       	popm	r0-r7,pc
80005a2a:	00 00       	add	r0,r0
80005a2c:	00 00       	add	r0,r0
80005a2e:	0b 7c       	ld.ub	r12,--r5
80005a30:	00 00       	add	r0,r0
80005a32:	0b 80       	ld.ub	r0,r5[0x0]
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	6a 48       	ld.w	r8,r5[0x10]
80005a38:	00 00       	add	r0,r0
80005a3a:	0b 84       	ld.ub	r4,r5[0x0]
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	6c 54       	ld.w	r4,r6[0x14]
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	2c 58       	sub	r8,-59
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	2e ac       	sub	r12,-22
80005a48:	00 00       	add	r0,r0
80005a4a:	05 38       	ld.ub	r8,r2++

80005a4c <xgflash_message_save>:
	
}

static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
80005a4c:	d4 21       	pushm	r4-r7,lr
80005a4e:	20 2d       	sub	sp,8
80005a50:	18 96       	mov	r6,r12
80005a52:	16 97       	mov	r7,r11
80005a54:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
80005a56:	4d 08       	lddpc	r8,80005b94 <xgflash_message_save+0x148>
80005a58:	11 89       	ld.ub	r9,r8[0x0]
80005a5a:	30 08       	mov	r8,0
80005a5c:	f0 09 18 00 	cp.b	r9,r8
80005a60:	c0 31       	brne	80005a66 <xgflash_message_save+0x1a>
80005a62:	3f fc       	mov	r12,-1
80005a64:	c9 68       	rjmp	80005b90 <xgflash_message_save+0x144>
	U32 address = 0;
	static U32 bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
		
	current_bytes_remained+=data_len;//accumulate
80005a66:	16 94       	mov	r4,r11
80005a68:	5c 74       	castu.h	r4
80005a6a:	4c c8       	lddpc	r8,80005b98 <xgflash_message_save+0x14c>
80005a6c:	70 09       	ld.w	r9,r8[0x0]
80005a6e:	e8 09 00 09 	add	r9,r4,r9
80005a72:	91 09       	st.w	r8[0x0],r9
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
80005a74:	58 0c       	cp.w	r12,0
80005a76:	5f 0a       	sreq	r10
80005a78:	e0 68 02 00 	mov	r8,512
80005a7c:	f0 0b 19 00 	cp.h	r11,r8
80005a80:	5f b8       	srhi	r8
80005a82:	f5 e8 10 08 	or	r8,r10,r8
80005a86:	e0 81 00 84 	brne	80005b8e <xgflash_message_save+0x142>
	{
		return XG_INVALID_PARAM;
	}
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
80005a8a:	e0 49 f0 00 	cp.w	r9,61440
80005a8e:	e0 8b 00 80 	brhi	80005b8e <xgflash_message_save+0x142>
	{
		//current_bytes_remained = 0;
		return XG_INVALID_PARAM;
	}
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock	
80005a92:	4c 38       	lddpc	r8,80005b9c <xgflash_message_save+0x150>
80005a94:	70 0c       	ld.w	r12,r8[0x0]
80005a96:	30 09       	mov	r9,0
80005a98:	3f fa       	mov	r10,-1
80005a9a:	12 9b       	mov	r11,r9
80005a9c:	f0 1f 00 41 	mcall	80005ba0 <xgflash_message_save+0x154>
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
80005aa0:	4c 18       	lddpc	r8,80005ba4 <xgflash_message_save+0x158>
80005aa2:	70 0b       	ld.w	r11,r8[0x0]
80005aa4:	e0 68 ff ff 	mov	r8,65535
80005aa8:	ea 18 00 7f 	orh	r8,0x7f
80005aac:	10 3b       	cp.w	r11,r8
80005aae:	e0 88 00 0e 	brls	80005aca <xgflash_message_save+0x7e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
80005ab2:	4b ec       	lddpc	r12,80005ba8 <xgflash_message_save+0x15c>
80005ab4:	f0 1f 00 3e 	mcall	80005bac <xgflash_message_save+0x160>
		xSemaphoreGive(xgflash_mutex );//unlock
80005ab8:	4b 98       	lddpc	r8,80005b9c <xgflash_message_save+0x150>
80005aba:	70 0c       	ld.w	r12,r8[0x0]
80005abc:	30 09       	mov	r9,0
80005abe:	12 9a       	mov	r10,r9
80005ac0:	12 9b       	mov	r11,r9
80005ac2:	f0 1f 00 3c 	mcall	80005bb0 <xgflash_message_save+0x164>
80005ac6:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
80005ac8:	c6 48       	rjmp	80005b90 <xgflash_message_save+0x144>
	}
	
	//log("receive...1-1\n");
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
80005aca:	0e 9a       	mov	r10,r7
80005acc:	5c 7a       	castu.h	r10
80005ace:	0c 9c       	mov	r12,r6
80005ad0:	f0 1f 00 39 	mcall	80005bb4 <xgflash_message_save+0x168>
	if(return_code != DF_WRITE_COMPLETED)
80005ad4:	58 7c       	cp.w	r12,7
80005ad6:	c0 a0       	breq	80005aea <xgflash_message_save+0x9e>
	{
		xSemaphoreGive(xgflash_mutex );//unlock
80005ad8:	4b 18       	lddpc	r8,80005b9c <xgflash_message_save+0x150>
80005ada:	70 0c       	ld.w	r12,r8[0x0]
80005adc:	30 09       	mov	r9,0
80005ade:	12 9a       	mov	r10,r9
80005ae0:	12 9b       	mov	r11,r9
80005ae2:	f0 1f 00 34 	mcall	80005bb0 <xgflash_message_save+0x164>
80005ae6:	30 6c       	mov	r12,6
		//log("receive...1-3\n");
		return XG_FLASH_ACTION_FAIL;
80005ae8:	c5 48       	rjmp	80005b90 <xgflash_message_save+0x144>
	}
	
	//log("receive...1-2\n");
	current_save_message_offset+=data_len;
80005aea:	4a f8       	lddpc	r8,80005ba4 <xgflash_message_save+0x158>
80005aec:	70 09       	ld.w	r9,r8[0x0]
80005aee:	12 04       	add	r4,r9
80005af0:	91 04       	st.w	r8[0x0],r4
	log("current_save_message_offset : %X\n", current_save_message_offset);
80005af2:	1a d4       	st.w	--sp,r4
80005af4:	4b 1c       	lddpc	r12,80005bb8 <xgflash_message_save+0x16c>
80005af6:	f0 1f 00 2e 	mcall	80005bac <xgflash_message_save+0x160>
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
80005afa:	2f fd       	sub	sp,-4
80005afc:	30 18       	mov	r8,1
80005afe:	f0 05 18 00 	cp.b	r5,r8
80005b02:	c3 d1       	brne	80005b7c <xgflash_message_save+0x130>
	{
		current_message_index++;
80005b04:	4a e9       	lddpc	r9,80005bbc <xgflash_message_save+0x170>
80005b06:	92 08       	ld.sh	r8,r9[0x0]
80005b08:	2f f8       	sub	r8,-1
80005b0a:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
80005b0c:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
80005b0e:	4a 39       	lddpc	r9,80005b98 <xgflash_message_save+0x14c>
80005b10:	72 09       	ld.w	r9,r9[0x0]
80005b12:	4a 5a       	lddpc	r10,80005ba4 <xgflash_message_save+0x158>
80005b14:	74 0a       	ld.w	r10,r10[0x0]
80005b16:	12 1a       	sub	r10,r9
80005b18:	40 0b       	lddsp	r11,sp[0x0]
80005b1a:	e0 1b 00 00 	andl	r11,0x0
80005b1e:	f7 ea 13 0b 	or	r11,r11,r10>>0x10
80005b22:	50 0b       	stdsp	sp[0x0],r11
80005b24:	ba 2a       	st.h	sp[0x4],r10
		ptr.offset		= current_bytes_remained;
80005b26:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005b28:	5c 78       	castu.h	r8
80005b2a:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
80005b2e:	e2 4b 00 00 	cp.w	r11,131072
80005b32:	e0 88 00 0e 	brls	80005b4e <xgflash_message_save+0x102>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
80005b36:	4a 3c       	lddpc	r12,80005bc0 <xgflash_message_save+0x174>
80005b38:	f0 1f 00 1d 	mcall	80005bac <xgflash_message_save+0x160>
			xSemaphoreGive(xgflash_mutex );//unlock
80005b3c:	49 88       	lddpc	r8,80005b9c <xgflash_message_save+0x150>
80005b3e:	70 0c       	ld.w	r12,r8[0x0]
80005b40:	30 09       	mov	r9,0
80005b42:	12 9a       	mov	r10,r9
80005b44:	12 9b       	mov	r11,r9
80005b46:	f0 1f 00 1b 	mcall	80005bb0 <xgflash_message_save+0x164>
80005b4a:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
80005b4c:	c2 28       	rjmp	80005b90 <xgflash_message_save+0x144>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
80005b4e:	30 8a       	mov	r10,8
80005b50:	1a 9c       	mov	r12,sp
80005b52:	f0 1f 00 19 	mcall	80005bb4 <xgflash_message_save+0x168>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005b56:	30 2a       	mov	r10,2
80005b58:	30 6b       	mov	r11,6
80005b5a:	49 9c       	lddpc	r12,80005bbc <xgflash_message_save+0x170>
80005b5c:	f0 1f 00 16 	mcall	80005bb4 <xgflash_message_save+0x168>
		if(return_code != DF_WRITE_COMPLETED)
80005b60:	58 7c       	cp.w	r12,7
80005b62:	c0 a0       	breq	80005b76 <xgflash_message_save+0x12a>
		{
			xSemaphoreGive(xgflash_mutex );//unlock
80005b64:	48 e8       	lddpc	r8,80005b9c <xgflash_message_save+0x150>
80005b66:	70 0c       	ld.w	r12,r8[0x0]
80005b68:	30 09       	mov	r9,0
80005b6a:	12 9a       	mov	r10,r9
80005b6c:	12 9b       	mov	r11,r9
80005b6e:	f0 1f 00 11 	mcall	80005bb0 <xgflash_message_save+0x164>
80005b72:	30 6c       	mov	r12,6
			return XG_FLASH_ACTION_FAIL;
80005b74:	c0 e8       	rjmp	80005b90 <xgflash_message_save+0x144>
		}
		
		current_bytes_remained = 0;//reset 0
80005b76:	30 09       	mov	r9,0
80005b78:	48 88       	lddpc	r8,80005b98 <xgflash_message_save+0x14c>
80005b7a:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
80005b7c:	48 88       	lddpc	r8,80005b9c <xgflash_message_save+0x150>
80005b7e:	70 0c       	ld.w	r12,r8[0x0]
80005b80:	30 09       	mov	r9,0
80005b82:	12 9a       	mov	r10,r9
80005b84:	12 9b       	mov	r11,r9
80005b86:	f0 1f 00 0b 	mcall	80005bb0 <xgflash_message_save+0x164>
80005b8a:	30 0c       	mov	r12,0
	return XG_OK;
80005b8c:	c0 28       	rjmp	80005b90 <xgflash_message_save+0x144>
80005b8e:	30 1c       	mov	r12,1

}
80005b90:	2f ed       	sub	sp,-8
80005b92:	d8 22       	popm	r4-r7,pc
80005b94:	00 00       	add	r0,r0
80005b96:	0b 7c       	ld.ub	r12,--r5
80005b98:	00 00       	add	r0,r0
80005b9a:	0b 88       	ld.ub	r8,r5[0x0]
80005b9c:	00 00       	add	r0,r0
80005b9e:	0b 80       	ld.ub	r0,r5[0x0]
80005ba0:	80 00       	ld.sh	r0,r0[0x0]
80005ba2:	6a 48       	ld.w	r8,r5[0x10]
80005ba4:	00 00       	add	r0,r0
80005ba6:	05 38       	ld.ub	r8,r2++
80005ba8:	80 00       	ld.sh	r0,r0[0x0]
80005baa:	e2 c0 80 00 	sub	r0,r1,-32768
80005bae:	78 34       	ld.w	r4,r12[0xc]
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	6c 54       	ld.w	r4,r6[0x14]
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	2e ac       	sub	r12,-22
80005bb8:	80 00       	ld.sh	r0,r0[0x0]
80005bba:	e2 08 00 00 	add	r0,r1,r8
80005bbe:	0b 84       	ld.ub	r4,r5[0x0]
80005bc0:	80 00       	ld.sh	r0,r0[0x0]
80005bc2:	e2 f0 eb cd 	ld.w	r0,r1[-5171]

80005bc4 <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
80005bc4:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
80005bc8:	48 d8       	lddpc	r8,80005bfc <xgflash_get_message_count+0x38>
80005bca:	11 89       	ld.ub	r9,r8[0x0]
80005bcc:	30 08       	mov	r8,0
80005bce:	f0 09 18 00 	cp.b	r9,r8
80005bd2:	c0 31       	brne	80005bd8 <xgflash_get_message_count+0x14>
80005bd4:	3f f7       	mov	r7,-1
80005bd6:	c1 08       	rjmp	80005bf6 <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
80005bd8:	48 a6       	lddpc	r6,80005c00 <xgflash_get_message_count+0x3c>
80005bda:	6c 0c       	ld.w	r12,r6[0x0]
80005bdc:	30 09       	mov	r9,0
80005bde:	3f fa       	mov	r10,-1
80005be0:	12 9b       	mov	r11,r9
80005be2:	f0 1f 00 09 	mcall	80005c04 <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
80005be6:	48 98       	lddpc	r8,80005c08 <xgflash_get_message_count+0x44>
80005be8:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
80005bea:	6c 0c       	ld.w	r12,r6[0x0]
80005bec:	30 09       	mov	r9,0
80005bee:	12 9a       	mov	r10,r9
80005bf0:	12 9b       	mov	r11,r9
80005bf2:	f0 1f 00 07 	mcall	80005c0c <xgflash_get_message_count+0x48>

	return return_value;
	
}
80005bf6:	0e 9c       	mov	r12,r7
80005bf8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bfc:	00 00       	add	r0,r0
80005bfe:	0b 7c       	ld.ub	r12,--r5
80005c00:	00 00       	add	r0,r0
80005c02:	0b 80       	ld.ub	r0,r5[0x0]
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	6a 48       	ld.w	r8,r5[0x10]
80005c08:	00 00       	add	r0,r0
80005c0a:	0b 84       	ld.ub	r4,r5[0x0]
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	6c 54       	ld.w	r4,r6[0x14]

80005c10 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005c10:	fe 68 14 00 	mov	r8,-125952
80005c14:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005c16:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005c1a:	91 09       	st.w	r8[0x0],r9
}
80005c1c:	5e fc       	retal	r12

80005c1e <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005c1e:	f8 08 16 05 	lsr	r8,r12,0x5
80005c22:	a9 68       	lsl	r8,0x8
80005c24:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005c28:	58 1b       	cp.w	r11,1
80005c2a:	c0 d0       	breq	80005c44 <gpio_enable_module_pin+0x26>
80005c2c:	c0 63       	brcs	80005c38 <gpio_enable_module_pin+0x1a>
80005c2e:	58 2b       	cp.w	r11,2
80005c30:	c1 00       	breq	80005c50 <gpio_enable_module_pin+0x32>
80005c32:	58 3b       	cp.w	r11,3
80005c34:	c1 40       	breq	80005c5c <gpio_enable_module_pin+0x3e>
80005c36:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005c38:	30 19       	mov	r9,1
80005c3a:	f2 0c 09 49 	lsl	r9,r9,r12
80005c3e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005c40:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c42:	c1 28       	rjmp	80005c66 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005c44:	30 19       	mov	r9,1
80005c46:	f2 0c 09 49 	lsl	r9,r9,r12
80005c4a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005c4c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c4e:	c0 c8       	rjmp	80005c66 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005c50:	30 19       	mov	r9,1
80005c52:	f2 0c 09 49 	lsl	r9,r9,r12
80005c56:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005c58:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c5a:	c0 68       	rjmp	80005c66 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005c5c:	30 19       	mov	r9,1
80005c5e:	f2 0c 09 49 	lsl	r9,r9,r12
80005c62:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005c64:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005c66:	30 19       	mov	r9,1
80005c68:	f2 0c 09 4c 	lsl	r12,r9,r12
80005c6c:	91 2c       	st.w	r8[0x8],r12
80005c6e:	5e fd       	retal	0

80005c70 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005c70:	d4 21       	pushm	r4-r7,lr
80005c72:	18 97       	mov	r7,r12
80005c74:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005c76:	58 0b       	cp.w	r11,0
80005c78:	c0 31       	brne	80005c7e <gpio_enable_module+0xe>
80005c7a:	30 05       	mov	r5,0
80005c7c:	c0 d8       	rjmp	80005c96 <gpio_enable_module+0x26>
80005c7e:	30 06       	mov	r6,0
80005c80:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005c82:	6e 1b       	ld.w	r11,r7[0x4]
80005c84:	6e 0c       	ld.w	r12,r7[0x0]
80005c86:	f0 1f 00 06 	mcall	80005c9c <gpio_enable_module+0x2c>
80005c8a:	18 45       	or	r5,r12
		gpiomap++;
80005c8c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005c8e:	2f f6       	sub	r6,-1
80005c90:	0c 34       	cp.w	r4,r6
80005c92:	fe 9b ff f8 	brhi	80005c82 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005c96:	0a 9c       	mov	r12,r5
80005c98:	d8 22       	popm	r4-r7,pc
80005c9a:	00 00       	add	r0,r0
80005c9c:	80 00       	ld.sh	r0,r0[0x0]
80005c9e:	5c 1e       	scr	lr

80005ca0 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005ca0:	f8 08 16 05 	lsr	r8,r12,0x5
80005ca4:	a9 68       	lsl	r8,0x8
80005ca6:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005caa:	30 19       	mov	r9,1
80005cac:	f2 0c 09 4c 	lsl	r12,r9,r12
80005cb0:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005cb4:	91 1c       	st.w	r8[0x4],r12
}
80005cb6:	5e fc       	retal	r12

80005cb8 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005cb8:	f8 08 16 05 	lsr	r8,r12,0x5
80005cbc:	a9 68       	lsl	r8,0x8
80005cbe:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005cc2:	30 19       	mov	r9,1
80005cc4:	f2 0c 09 4c 	lsl	r12,r9,r12
80005cc8:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005ccc:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005cd0:	91 1c       	st.w	r8[0x4],r12
}
80005cd2:	5e fc       	retal	r12

80005cd4 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005cd4:	f8 08 16 05 	lsr	r8,r12,0x5
80005cd8:	a9 68       	lsl	r8,0x8
80005cda:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005cde:	30 19       	mov	r9,1
80005ce0:	f2 0c 09 4c 	lsl	r12,r9,r12
80005ce4:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005ce8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005cec:	91 1c       	st.w	r8[0x4],r12
}
80005cee:	5e fc       	retal	r12

80005cf0 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005cf0:	c0 08       	rjmp	80005cf0 <_unhandled_interrupt>
80005cf2:	d7 03       	nop

80005cf4 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005cf4:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005cf8:	49 99       	lddpc	r9,80005d5c <INTC_register_interrupt+0x68>
80005cfa:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005cfe:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005d02:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005d04:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005d08:	58 0a       	cp.w	r10,0
80005d0a:	c0 91       	brne	80005d1c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d0c:	49 59       	lddpc	r9,80005d60 <INTC_register_interrupt+0x6c>
80005d0e:	49 6a       	lddpc	r10,80005d64 <INTC_register_interrupt+0x70>
80005d10:	12 1a       	sub	r10,r9
80005d12:	fe 79 08 00 	mov	r9,-63488
80005d16:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d1a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005d1c:	58 1a       	cp.w	r10,1
80005d1e:	c0 a1       	brne	80005d32 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005d20:	49 09       	lddpc	r9,80005d60 <INTC_register_interrupt+0x6c>
80005d22:	49 2a       	lddpc	r10,80005d68 <INTC_register_interrupt+0x74>
80005d24:	12 1a       	sub	r10,r9
80005d26:	bf aa       	sbr	r10,0x1e
80005d28:	fe 79 08 00 	mov	r9,-63488
80005d2c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d30:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005d32:	58 2a       	cp.w	r10,2
80005d34:	c0 a1       	brne	80005d48 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005d36:	48 b9       	lddpc	r9,80005d60 <INTC_register_interrupt+0x6c>
80005d38:	48 da       	lddpc	r10,80005d6c <INTC_register_interrupt+0x78>
80005d3a:	12 1a       	sub	r10,r9
80005d3c:	bf ba       	sbr	r10,0x1f
80005d3e:	fe 79 08 00 	mov	r9,-63488
80005d42:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d46:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005d48:	48 69       	lddpc	r9,80005d60 <INTC_register_interrupt+0x6c>
80005d4a:	48 aa       	lddpc	r10,80005d70 <INTC_register_interrupt+0x7c>
80005d4c:	12 1a       	sub	r10,r9
80005d4e:	ea 1a c0 00 	orh	r10,0xc000
80005d52:	fe 79 08 00 	mov	r9,-63488
80005d56:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d5a:	5e fc       	retal	r12
80005d5c:	80 00       	ld.sh	r0,r0[0x0]
80005d5e:	e3 88       	*unknown*
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	d6 00       	acall	0x60
80005d64:	80 00       	ld.sh	r0,r0[0x0]
80005d66:	d7 04       	*unknown*
80005d68:	80 00       	ld.sh	r0,r0[0x0]
80005d6a:	d7 12       	popm	r0-r3,r11-r12,lr
80005d6c:	80 00       	ld.sh	r0,r0[0x0]
80005d6e:	d7 20       	acall	0x72
80005d70:	80 00       	ld.sh	r0,r0[0x0]
80005d72:	d7 2e       	*unknown*

80005d74 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005d74:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005d76:	49 18       	lddpc	r8,80005db8 <INTC_init_interrupts+0x44>
80005d78:	e3 b8 00 01 	mtsr	0x4,r8
80005d7c:	49 0e       	lddpc	lr,80005dbc <INTC_init_interrupts+0x48>
80005d7e:	30 07       	mov	r7,0
80005d80:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d82:	49 0c       	lddpc	r12,80005dc0 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d84:	49 05       	lddpc	r5,80005dc4 <INTC_init_interrupts+0x50>
80005d86:	10 15       	sub	r5,r8
80005d88:	fe 76 08 00 	mov	r6,-63488
80005d8c:	c1 08       	rjmp	80005dac <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005d8e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005d90:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d92:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d94:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005d98:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d9a:	10 3a       	cp.w	r10,r8
80005d9c:	fe 9b ff fc 	brhi	80005d94 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005da0:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005da4:	2f f7       	sub	r7,-1
80005da6:	2f 8e       	sub	lr,-8
80005da8:	59 37       	cp.w	r7,19
80005daa:	c0 50       	breq	80005db4 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005dac:	7c 08       	ld.w	r8,lr[0x0]
80005dae:	58 08       	cp.w	r8,0
80005db0:	ce f1       	brne	80005d8e <INTC_init_interrupts+0x1a>
80005db2:	cf 7b       	rjmp	80005da0 <INTC_init_interrupts+0x2c>
80005db4:	d8 22       	popm	r4-r7,pc
80005db6:	00 00       	add	r0,r0
80005db8:	80 00       	ld.sh	r0,r0[0x0]
80005dba:	d6 00       	acall	0x60
80005dbc:	80 00       	ld.sh	r0,r0[0x0]
80005dbe:	e3 88       	*unknown*
80005dc0:	80 00       	ld.sh	r0,r0[0x0]
80005dc2:	5c f0       	rol	r0
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	d7 04       	*unknown*

80005dc8 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005dc8:	fe 78 08 00 	mov	r8,-63488
80005dcc:	e0 69 00 83 	mov	r9,131
80005dd0:	f2 0c 01 0c 	sub	r12,r9,r12
80005dd4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005dd8:	f2 ca ff c0 	sub	r10,r9,-64
80005ddc:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005de0:	58 08       	cp.w	r8,0
80005de2:	c0 21       	brne	80005de6 <_get_interrupt_handler+0x1e>
80005de4:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005de6:	f0 08 12 00 	clz	r8,r8
80005dea:	48 5a       	lddpc	r10,80005dfc <_get_interrupt_handler+0x34>
80005dec:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005df0:	f0 08 11 1f 	rsub	r8,r8,31
80005df4:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005df6:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005dfa:	5e fc       	retal	r12
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	e3 88       	*unknown*

80005e00 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005e00:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005e02:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005e06:	99 a8       	st.w	r12[0x28],r8
}
80005e08:	5e fc       	retal	r12
80005e0a:	d7 03       	nop

80005e0c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005e0c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005e0e:	ec 5b bb 9f 	cp.w	r11,899999
80005e12:	e0 8b 00 04 	brhi	80005e1a <pm_enable_osc0_crystal+0xe>
80005e16:	30 4b       	mov	r11,4
80005e18:	c1 38       	rjmp	80005e3e <pm_enable_osc0_crystal+0x32>
80005e1a:	e0 68 c6 bf 	mov	r8,50879
80005e1e:	ea 18 00 2d 	orh	r8,0x2d
80005e22:	10 3b       	cp.w	r11,r8
80005e24:	e0 8b 00 04 	brhi	80005e2c <pm_enable_osc0_crystal+0x20>
80005e28:	30 5b       	mov	r11,5
80005e2a:	c0 a8       	rjmp	80005e3e <pm_enable_osc0_crystal+0x32>
80005e2c:	e0 68 12 00 	mov	r8,4608
80005e30:	ea 18 00 7a 	orh	r8,0x7a
80005e34:	10 3b       	cp.w	r11,r8
80005e36:	f9 bb 03 06 	movlo	r11,6
80005e3a:	f9 bb 02 07 	movhs	r11,7
80005e3e:	f0 1f 00 02 	mcall	80005e44 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80005e42:	d8 02       	popm	pc
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	5e 00       	reteq	r0

80005e48 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005e48:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80005e4a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005e4e:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005e50:	78 08       	ld.w	r8,r12[0x0]
80005e52:	a3 a8       	sbr	r8,0x2
80005e54:	99 08       	st.w	r12[0x0],r8
}
80005e56:	5e fc       	retal	r12

80005e58 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005e58:	79 58       	ld.w	r8,r12[0x54]
80005e5a:	e2 18 00 80 	andl	r8,0x80,COH
80005e5e:	cf d0       	breq	80005e58 <pm_wait_for_clk0_ready>
}
80005e60:	5e fc       	retal	r12
80005e62:	d7 03       	nop

80005e64 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005e64:	eb cd 40 80 	pushm	r7,lr
80005e68:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80005e6a:	f0 1f 00 04 	mcall	80005e78 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80005e6e:	0e 9c       	mov	r12,r7
80005e70:	f0 1f 00 03 	mcall	80005e7c <pm_enable_clk0+0x18>
}
80005e74:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e78:	80 00       	ld.sh	r0,r0[0x0]
80005e7a:	5e 48       	retge	r8
80005e7c:	80 00       	ld.sh	r0,r0[0x0]
80005e7e:	5e 58       	retlt	r8

80005e80 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005e80:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
80005e82:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005e86:	99 c8       	st.w	r12[0x30],r8
}
80005e88:	5e fc       	retal	r12
80005e8a:	d7 03       	nop

80005e8c <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80005e8c:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80005e8e:	30 1b       	mov	r11,1
80005e90:	f0 1f 00 02 	mcall	80005e98 <pm_enable_osc32_crystal+0xc>
}
80005e94:	d8 02       	popm	pc
80005e96:	00 00       	add	r0,r0
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	5e 80       	retls	r0

80005e9c <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005e9c:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80005e9e:	30 19       	mov	r9,1
80005ea0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80005ea4:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005ea8:	99 c8       	st.w	r12[0x30],r8
}
80005eaa:	5e fc       	retal	r12

80005eac <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80005eac:	79 58       	ld.w	r8,r12[0x54]
80005eae:	e2 18 02 00 	andl	r8,0x200,COH
80005eb2:	cf d0       	breq	80005eac <pm_wait_for_clk32_ready>
}
80005eb4:	5e fc       	retal	r12
80005eb6:	d7 03       	nop

80005eb8 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80005eb8:	eb cd 40 80 	pushm	r7,lr
80005ebc:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80005ebe:	f0 1f 00 04 	mcall	80005ecc <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
80005ec2:	0e 9c       	mov	r12,r7
80005ec4:	f0 1f 00 03 	mcall	80005ed0 <pm_enable_clk32+0x18>
}
80005ec8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ecc:	80 00       	ld.sh	r0,r0[0x0]
80005ece:	5e 9c       	retgt	r12
80005ed0:	80 00       	ld.sh	r0,r0[0x0]
80005ed2:	5e ac       	retle	r12

80005ed4 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005ed4:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005ed8:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005edc:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005ede:	09 f7       	ld.ub	r7,r4[0x7]
80005ee0:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005ee4:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005ee8:	09 b4       	ld.ub	r4,r4[0x3]
80005eea:	08 96       	mov	r6,r4
80005eec:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005ef0:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005ef4:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005ef8:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005efc:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005f00:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005f04:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005f08:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005f0c:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005f0e:	79 58       	ld.w	r8,r12[0x54]
80005f10:	e2 18 00 20 	andl	r8,0x20,COH
80005f14:	cf d0       	breq	80005f0e <pm_cksel+0x3a>
}
80005f16:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005f1a <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005f1a:	eb cd 40 80 	pushm	r7,lr
80005f1e:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005f20:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005f22:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80005f26:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005f2a:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005f2e:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005f32:	2f 8b       	sub	r11,-8
80005f34:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005f38:	e3 cd 80 80 	ldm	sp++,r7,pc

80005f3c <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005f3c:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005f3e:	2f 8b       	sub	r11,-8
80005f40:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005f44:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005f48:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005f4c:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005f50:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005f54:	d8 02       	popm	pc

80005f56 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80005f56:	2f 8b       	sub	r11,-8
80005f58:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005f5c:	a1 a8       	sbr	r8,0x0
80005f5e:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80005f62:	5e fc       	retal	r12

80005f64 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005f64:	79 58       	ld.w	r8,r12[0x54]
80005f66:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005f6a:	cf d0       	breq	80005f64 <pm_wait_for_pll0_locked>
}
80005f6c:	5e fc       	retal	r12

80005f6e <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005f6e:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005f70:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005f74:	99 08       	st.w	r12[0x0],r8
}
80005f76:	5e fc       	retal	r12

80005f78 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005f78:	eb cd 40 c0 	pushm	r6-r7,lr
80005f7c:	18 97       	mov	r7,r12
80005f7e:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005f80:	f0 1f 00 06 	mcall	80005f98 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005f84:	0c 9b       	mov	r11,r6
80005f86:	0e 9c       	mov	r12,r7
80005f88:	f0 1f 00 05 	mcall	80005f9c <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005f8c:	30 1b       	mov	r11,1
80005f8e:	0e 9c       	mov	r12,r7
80005f90:	f0 1f 00 04 	mcall	80005fa0 <pm_switch_to_osc0+0x28>
}
80005f94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	5e 0c       	reteq	r12
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	5e 64       	retmi	r4
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	5f 6e       	srmi	lr

80005fa4 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80005fa4:	78 0c       	ld.w	r12,r12[0x0]
}
80005fa6:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80005faa:	5e fc       	retal	r12

80005fac <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80005fac:	eb cd 40 c0 	pushm	r6-r7,lr
80005fb0:	18 97       	mov	r7,r12
80005fb2:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005fb4:	0e 9c       	mov	r12,r7
80005fb6:	f0 1f 00 06 	mcall	80005fcc <rtc_set_value+0x20>
80005fba:	cf d1       	brne	80005fb4 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80005fbc:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005fbe:	0e 9c       	mov	r12,r7
80005fc0:	f0 1f 00 03 	mcall	80005fcc <rtc_set_value+0x20>
80005fc4:	cf d1       	brne	80005fbe <rtc_set_value+0x12>
}
80005fc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fca:	00 00       	add	r0,r0
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	5f a4       	srle	r4

80005fd0 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80005fd0:	eb cd 40 80 	pushm	r7,lr
80005fd4:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80005fd6:	0e 9c       	mov	r12,r7
80005fd8:	f0 1f 00 06 	mcall	80005ff0 <rtc_enable+0x20>
80005fdc:	cf d1       	brne	80005fd6 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80005fde:	6e 08       	ld.w	r8,r7[0x0]
80005fe0:	a1 a8       	sbr	r8,0x0
80005fe2:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005fe4:	0e 9c       	mov	r12,r7
80005fe6:	f0 1f 00 03 	mcall	80005ff0 <rtc_enable+0x20>
80005fea:	cf d1       	brne	80005fe4 <rtc_enable+0x14>
}
80005fec:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	5f a4       	srle	r4

80005ff4 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80005ff4:	30 18       	mov	r8,1
80005ff6:	99 48       	st.w	r12[0x10],r8
}
80005ff8:	5e fc       	retal	r12
80005ffa:	d7 03       	nop

80005ffc <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80005ffc:	eb cd 40 c0 	pushm	r6-r7,lr
80006000:	18 97       	mov	r7,r12
80006002:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80006004:	0e 9c       	mov	r12,r7
80006006:	f0 1f 00 06 	mcall	8000601c <rtc_set_top_value+0x20>
8000600a:	cf d1       	brne	80006004 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
8000600c:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000600e:	0e 9c       	mov	r12,r7
80006010:	f0 1f 00 03 	mcall	8000601c <rtc_set_top_value+0x20>
80006014:	cf d1       	brne	8000600e <rtc_set_top_value+0x12>
}
80006016:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000601a:	00 00       	add	r0,r0
8000601c:	80 00       	ld.sh	r0,r0[0x0]
8000601e:	5f a4       	srle	r4

80006020 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006020:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80006024:	e6 18 00 01 	andh	r8,0x1,COH
80006028:	c0 71       	brne	80006036 <rtc_clear_interrupt+0x16>
8000602a:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000602c:	30 18       	mov	r8,1
8000602e:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006030:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80006032:	d5 03       	csrf	0x10
80006034:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006036:	30 18       	mov	r8,1
80006038:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000603a:	78 78       	ld.w	r8,r12[0x1c]
8000603c:	5e fc       	retal	r12
8000603e:	d7 03       	nop

80006040 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80006040:	eb cd 40 e0 	pushm	r5-r7,lr
80006044:	18 97       	mov	r7,r12
80006046:	16 96       	mov	r6,r11
80006048:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
8000604a:	30 18       	mov	r8,1
8000604c:	f0 0b 18 00 	cp.b	r11,r8
80006050:	5f b9       	srhi	r9
80006052:	30 f8       	mov	r8,15
80006054:	f0 0a 18 00 	cp.b	r10,r8
80006058:	5f b8       	srhi	r8
8000605a:	f3 e8 10 08 	or	r8,r9,r8
8000605e:	c0 30       	breq	80006064 <rtc_init+0x24>
80006060:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80006064:	30 18       	mov	r8,1
80006066:	f0 0b 18 00 	cp.b	r11,r8
8000606a:	c0 a1       	brne	8000607e <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
8000606c:	fe 7c 0c 00 	mov	r12,-62464
80006070:	f0 1f 00 0f 	mcall	800060ac <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80006074:	30 0b       	mov	r11,0
80006076:	fe 7c 0c 00 	mov	r12,-62464
8000607a:	f0 1f 00 0e 	mcall	800060b0 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
8000607e:	0e 9c       	mov	r12,r7
80006080:	f0 1f 00 0d 	mcall	800060b4 <rtc_init+0x74>
80006084:	cf d1       	brne	8000607e <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80006086:	a3 76       	lsl	r6,0x3
80006088:	b1 a6       	sbr	r6,0x10
8000608a:	ed e5 10 85 	or	r5,r6,r5<<0x8
8000608e:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80006090:	0e 9c       	mov	r12,r7
80006092:	f0 1f 00 09 	mcall	800060b4 <rtc_init+0x74>
80006096:	cf d1       	brne	80006090 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80006098:	30 0b       	mov	r11,0
8000609a:	0e 9c       	mov	r12,r7
8000609c:	f0 1f 00 07 	mcall	800060b8 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
800060a0:	3f fb       	mov	r11,-1
800060a2:	0e 9c       	mov	r12,r7
800060a4:	f0 1f 00 06 	mcall	800060bc <rtc_init+0x7c>
800060a8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	5e 8c       	retls	r12
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	5e b8       	rethi	r8
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	5f a4       	srle	r4
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	5f ac       	srle	r12
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	5f fc       	sral	r12

800060c0 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800060c0:	f8 c8 00 01 	sub	r8,r12,1
800060c4:	f0 0b 00 0b 	add	r11,r8,r11
800060c8:	f6 0c 0d 0a 	divu	r10,r11,r12
800060cc:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800060ce:	f4 c8 00 01 	sub	r8,r10,1
800060d2:	e0 48 00 fe 	cp.w	r8,254
800060d6:	e0 88 00 03 	brls	800060dc <getBaudDiv+0x1c>
800060da:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800060dc:	5c 8c       	casts.h	r12
}
800060de:	5e fc       	retal	r12

800060e0 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800060e0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800060e4:	30 18       	mov	r8,1
800060e6:	f0 09 18 00 	cp.b	r9,r8
800060ea:	e0 88 00 04 	brls	800060f2 <spi_initMaster+0x12>
800060ee:	30 2c       	mov	r12,2
800060f0:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800060f2:	e0 68 00 80 	mov	r8,128
800060f6:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800060f8:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800060fa:	30 19       	mov	r9,1
800060fc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80006100:	f7 39 00 0d 	ld.ub	r9,r11[13]
80006104:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80006108:	30 09       	mov	r9,0
8000610a:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000610e:	30 fa       	mov	r10,15
80006110:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80006114:	99 18       	st.w	r12[0x4],r8
80006116:	5e f9       	retal	r9

80006118 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80006118:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000611a:	30 18       	mov	r8,1
8000611c:	f0 0b 18 00 	cp.b	r11,r8
80006120:	5f be       	srhi	lr
80006122:	f0 0a 18 00 	cp.b	r10,r8
80006126:	5f b8       	srhi	r8
80006128:	fd e8 10 08 	or	r8,lr,r8
8000612c:	c0 30       	breq	80006132 <spi_selectionMode+0x1a>
8000612e:	30 2c       	mov	r12,2
80006130:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80006132:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80006134:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006138:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000613c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80006140:	99 18       	st.w	r12[0x4],r8
80006142:	d8 0a       	popm	pc,r12=0

80006144 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80006144:	30 18       	mov	r8,1
80006146:	99 08       	st.w	r12[0x0],r8
}
80006148:	5e fc       	retal	r12

8000614a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000614a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000614e:	c0 58       	rjmp	80006158 <spi_write+0xe>
		if (!timeout--) {
80006150:	58 08       	cp.w	r8,0
80006152:	c0 21       	brne	80006156 <spi_write+0xc>
80006154:	5e ff       	retal	1
80006156:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006158:	78 49       	ld.w	r9,r12[0x10]
8000615a:	e2 19 00 02 	andl	r9,0x2,COH
8000615e:	cf 90       	breq	80006150 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80006160:	5c 7b       	castu.h	r11
80006162:	99 3b       	st.w	r12[0xc],r11
80006164:	5e fd       	retal	0

80006166 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80006166:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000616a:	c0 58       	rjmp	80006174 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000616c:	58 08       	cp.w	r8,0
8000616e:	c0 21       	brne	80006172 <spi_read+0xc>
80006170:	5e ff       	retal	1
80006172:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006174:	78 49       	ld.w	r9,r12[0x10]
80006176:	e2 19 02 01 	andl	r9,0x201,COH
8000617a:	e0 49 02 01 	cp.w	r9,513
8000617e:	cf 71       	brne	8000616c <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80006180:	78 28       	ld.w	r8,r12[0x8]
80006182:	b6 08       	st.h	r11[0x0],r8
80006184:	5e fd       	retal	0
80006186:	d7 03       	nop

80006188 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80006188:	eb cd 40 f8 	pushm	r3-r7,lr
8000618c:	18 95       	mov	r5,r12
8000618e:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006190:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006194:	30 38       	mov	r8,3
80006196:	f0 06 18 00 	cp.b	r6,r8
8000619a:	e0 8b 00 5e 	brhi	80006256 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000619e:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800061a2:	30 18       	mov	r8,1
800061a4:	f0 04 18 00 	cp.b	r4,r8
800061a8:	e0 8b 00 57 	brhi	80006256 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800061ac:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800061b0:	30 78       	mov	r8,7
800061b2:	f0 03 18 00 	cp.b	r3,r8
800061b6:	e0 88 00 50 	brls	80006256 <spi_setupChipReg+0xce>
800061ba:	31 08       	mov	r8,16
800061bc:	f0 03 18 00 	cp.b	r3,r8
800061c0:	e0 8b 00 4b 	brhi	80006256 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800061c4:	14 9b       	mov	r11,r10
800061c6:	6e 1c       	ld.w	r12,r7[0x4]
800061c8:	f0 1f 00 26 	mcall	80006260 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800061cc:	c4 55       	brlt	80006256 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800061ce:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800061d0:	ec 09 16 01 	lsr	r9,r6,0x1
800061d4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800061d8:	ec 16 00 01 	eorl	r6,0x1
800061dc:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800061e0:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800061e4:	20 83       	sub	r3,8
800061e6:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800061ea:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800061ee:	ef 39 00 09 	ld.ub	r9,r7[9]
800061f2:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800061f6:	ef 39 00 0a 	ld.ub	r9,r7[10]
800061fa:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800061fe:	0f 89       	ld.ub	r9,r7[0x0]
80006200:	30 1a       	mov	r10,1
80006202:	f4 09 18 00 	cp.b	r9,r10
80006206:	c0 d0       	breq	80006220 <spi_setupChipReg+0x98>
80006208:	c0 a3       	brcs	8000621c <spi_setupChipReg+0x94>
8000620a:	30 2a       	mov	r10,2
8000620c:	f4 09 18 00 	cp.b	r9,r10
80006210:	c0 a0       	breq	80006224 <spi_setupChipReg+0x9c>
80006212:	30 3a       	mov	r10,3
80006214:	f4 09 18 00 	cp.b	r9,r10
80006218:	c1 f1       	brne	80006256 <spi_setupChipReg+0xce>
8000621a:	c0 78       	rjmp	80006228 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
8000621c:	8b c8       	st.w	r5[0x30],r8
		break;
8000621e:	c0 68       	rjmp	8000622a <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80006220:	8b d8       	st.w	r5[0x34],r8
		break;
80006222:	c0 48       	rjmp	8000622a <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80006224:	8b e8       	st.w	r5[0x38],r8
		break;
80006226:	c0 28       	rjmp	8000622a <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80006228:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000622a:	48 f8       	lddpc	r8,80006264 <spi_setupChipReg+0xdc>
8000622c:	70 08       	ld.w	r8,r8[0x0]
8000622e:	58 08       	cp.w	r8,0
80006230:	c1 61       	brne	8000625c <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80006232:	30 0b       	mov	r11,0
80006234:	30 1c       	mov	r12,1
80006236:	f0 1f 00 0d 	mcall	80006268 <spi_setupChipReg+0xe0>
8000623a:	48 b8       	lddpc	r8,80006264 <spi_setupChipReg+0xdc>
8000623c:	91 0c       	st.w	r8[0x0],r12
8000623e:	58 0c       	cp.w	r12,0
80006240:	c0 a0       	breq	80006254 <spi_setupChipReg+0xcc>
80006242:	30 09       	mov	r9,0
80006244:	12 9a       	mov	r10,r9
80006246:	12 9b       	mov	r11,r9
80006248:	f0 1f 00 09 	mcall	8000626c <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
8000624c:	48 68       	lddpc	r8,80006264 <spi_setupChipReg+0xdc>
8000624e:	70 08       	ld.w	r8,r8[0x0]
80006250:	58 08       	cp.w	r8,0
80006252:	c0 51       	brne	8000625c <spi_setupChipReg+0xd4>
80006254:	c0 08       	rjmp	80006254 <spi_setupChipReg+0xcc>
80006256:	30 2c       	mov	r12,2
80006258:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000625c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006260:	80 00       	ld.sh	r0,r0[0x0]
80006262:	60 c0       	ld.w	r0,r0[0x30]
80006264:	00 00       	add	r0,r0
80006266:	53 cc       	stdsp	sp[0xf0],r12
80006268:	80 00       	ld.sh	r0,r0[0x0]
8000626a:	6d 54       	ld.w	r4,r6[0x54]
8000626c:	80 00       	ld.sh	r0,r0[0x0]
8000626e:	6c 54       	ld.w	r4,r6[0x14]

80006270 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006270:	d4 01       	pushm	lr
80006272:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006276:	c0 58       	rjmp	80006280 <spi_unselectChip+0x10>
		if (!timeout--) {
80006278:	58 08       	cp.w	r8,0
8000627a:	c0 21       	brne	8000627e <spi_unselectChip+0xe>
8000627c:	da 0a       	popm	pc,r12=1
8000627e:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006280:	78 49       	ld.w	r9,r12[0x10]
80006282:	e2 19 02 00 	andl	r9,0x200,COH
80006286:	cf 90       	breq	80006278 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006288:	78 18       	ld.w	r8,r12[0x4]
8000628a:	ea 18 00 0f 	orh	r8,0xf
8000628e:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80006290:	fc 18 01 00 	movh	r8,0x100
80006294:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80006296:	30 09       	mov	r9,0
80006298:	12 9a       	mov	r10,r9
8000629a:	12 9b       	mov	r11,r9
8000629c:	48 38       	lddpc	r8,800062a8 <spi_unselectChip+0x38>
8000629e:	70 0c       	ld.w	r12,r8[0x0]
800062a0:	f0 1f 00 03 	mcall	800062ac <spi_unselectChip+0x3c>
800062a4:	d8 0a       	popm	pc,r12=0
800062a6:	00 00       	add	r0,r0
800062a8:	00 00       	add	r0,r0
800062aa:	53 cc       	stdsp	sp[0xf0],r12
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	6c 54       	ld.w	r4,r6[0x14]

800062b0 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800062b0:	eb cd 40 f8 	pushm	r3-r7,lr
800062b4:	18 94       	mov	r4,r12
800062b6:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800062b8:	49 a6       	lddpc	r6,80006320 <spi_selectChip+0x70>
800062ba:	30 07       	mov	r7,0
800062bc:	31 45       	mov	r5,20
800062be:	0e 99       	mov	r9,r7
800062c0:	0a 9a       	mov	r10,r5
800062c2:	0e 9b       	mov	r11,r7
800062c4:	6c 0c       	ld.w	r12,r6[0x0]
800062c6:	f0 1f 00 18 	mcall	80006324 <spi_selectChip+0x74>
800062ca:	cf a0       	breq	800062be <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800062cc:	68 18       	ld.w	r8,r4[0x4]
800062ce:	ea 18 00 0f 	orh	r8,0xf
800062d2:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800062d4:	68 18       	ld.w	r8,r4[0x4]
800062d6:	e2 18 00 04 	andl	r8,0x4,COH
800062da:	c1 10       	breq	800062fc <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800062dc:	30 e8       	mov	r8,14
800062de:	f0 03 18 00 	cp.b	r3,r8
800062e2:	e0 8b 00 1c 	brhi	8000631a <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800062e6:	68 19       	ld.w	r9,r4[0x4]
800062e8:	e6 08 15 10 	lsl	r8,r3,0x10
800062ec:	ea 18 ff f0 	orh	r8,0xfff0
800062f0:	e8 18 ff ff 	orl	r8,0xffff
800062f4:	12 68       	and	r8,r9
800062f6:	89 18       	st.w	r4[0x4],r8
800062f8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800062fc:	30 38       	mov	r8,3
800062fe:	f0 03 18 00 	cp.b	r3,r8
80006302:	e0 8b 00 0c 	brhi	8000631a <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80006306:	68 19       	ld.w	r9,r4[0x4]
80006308:	2f 03       	sub	r3,-16
8000630a:	30 18       	mov	r8,1
8000630c:	f0 03 09 48 	lsl	r8,r8,r3
80006310:	5c d8       	com	r8
80006312:	12 68       	and	r8,r9
80006314:	89 18       	st.w	r4[0x4],r8
80006316:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000631a:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
8000631c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006320:	00 00       	add	r0,r0
80006322:	53 cc       	stdsp	sp[0xf0],r12
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	6a 48       	ld.w	r8,r5[0x10]

80006328 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006328:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000632a:	f6 08 15 04 	lsl	r8,r11,0x4
8000632e:	14 38       	cp.w	r8,r10
80006330:	f9 b8 08 10 	movls	r8,16
80006334:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006338:	f0 0b 02 4b 	mul	r11,r8,r11
8000633c:	f6 09 16 01 	lsr	r9,r11,0x1
80006340:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006344:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006348:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000634c:	f2 cb 00 01 	sub	r11,r9,1
80006350:	e0 4b ff fe 	cp.w	r11,65534
80006354:	e0 88 00 03 	brls	8000635a <usart_set_async_baudrate+0x32>
80006358:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000635a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000635c:	e8 6e 00 00 	mov	lr,524288
80006360:	59 08       	cp.w	r8,16
80006362:	fc 08 17 10 	movne	r8,lr
80006366:	f9 b8 00 00 	moveq	r8,0
8000636a:	e4 1b ff f7 	andh	r11,0xfff7
8000636e:	e0 1b fe cf 	andl	r11,0xfecf
80006372:	16 48       	or	r8,r11
80006374:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006376:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000637a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000637e:	99 89       	st.w	r12[0x20],r9
80006380:	d8 0a       	popm	pc,r12=0

80006382 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006382:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006384:	e2 18 00 02 	andl	r8,0x2,COH
80006388:	c0 31       	brne	8000638e <usart_write_char+0xc>
8000638a:	30 2c       	mov	r12,2
8000638c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000638e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006392:	99 7b       	st.w	r12[0x1c],r11
80006394:	5e fd       	retal	0
80006396:	d7 03       	nop

80006398 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006398:	eb cd 40 e0 	pushm	r5-r7,lr
8000639c:	18 96       	mov	r6,r12
8000639e:	16 95       	mov	r5,r11
800063a0:	e0 67 27 0f 	mov	r7,9999
800063a4:	c0 68       	rjmp	800063b0 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800063a6:	58 07       	cp.w	r7,0
800063a8:	c0 31       	brne	800063ae <usart_putchar+0x16>
800063aa:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800063ae:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800063b0:	0a 9b       	mov	r11,r5
800063b2:	0c 9c       	mov	r12,r6
800063b4:	f0 1f 00 03 	mcall	800063c0 <usart_putchar+0x28>
800063b8:	cf 71       	brne	800063a6 <usart_putchar+0xe>

  return USART_SUCCESS;
}
800063ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800063be:	00 00       	add	r0,r0
800063c0:	80 00       	ld.sh	r0,r0[0x0]
800063c2:	63 82       	ld.w	r2,r1[0x60]

800063c4 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800063c4:	78 58       	ld.w	r8,r12[0x14]
800063c6:	e2 18 00 e0 	andl	r8,0xe0,COH
800063ca:	c0 30       	breq	800063d0 <usart_read_char+0xc>
800063cc:	30 4c       	mov	r12,4
800063ce:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800063d0:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800063d2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800063d6:	c0 31       	brne	800063dc <usart_read_char+0x18>
800063d8:	30 3c       	mov	r12,3
800063da:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800063dc:	78 68       	ld.w	r8,r12[0x18]
800063de:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800063e2:	97 08       	st.w	r11[0x0],r8
800063e4:	5e fd       	retal	0
800063e6:	d7 03       	nop

800063e8 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800063e8:	eb cd 40 c0 	pushm	r6-r7,lr
800063ec:	20 1d       	sub	sp,4
800063ee:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800063f0:	1a 97       	mov	r7,sp
800063f2:	1a 9b       	mov	r11,sp
800063f4:	0c 9c       	mov	r12,r6
800063f6:	f0 1f 00 07 	mcall	80006410 <usart_getchar+0x28>
800063fa:	58 3c       	cp.w	r12,3
800063fc:	cf b0       	breq	800063f2 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800063fe:	58 4c       	cp.w	r12,4
80006400:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006404:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006408:	2f fd       	sub	sp,-4
8000640a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000640e:	00 00       	add	r0,r0
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	63 c4       	ld.w	r4,r1[0x70]

80006414 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006414:	eb cd 40 c0 	pushm	r6-r7,lr
80006418:	18 96       	mov	r6,r12
8000641a:	16 97       	mov	r7,r11
  while (*string != '\0')
8000641c:	17 8b       	ld.ub	r11,r11[0x0]
8000641e:	58 0b       	cp.w	r11,0
80006420:	c0 80       	breq	80006430 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006422:	2f f7       	sub	r7,-1
80006424:	0c 9c       	mov	r12,r6
80006426:	f0 1f 00 04 	mcall	80006434 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000642a:	0f 8b       	ld.ub	r11,r7[0x0]
8000642c:	58 0b       	cp.w	r11,0
8000642e:	cf a1       	brne	80006422 <usart_write_line+0xe>
80006430:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	63 98       	ld.w	r8,r1[0x64]

80006438 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006438:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000643c:	e6 18 00 01 	andh	r8,0x1,COH
80006440:	c0 71       	brne	8000644e <usart_reset+0x16>
80006442:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006444:	3f f8       	mov	r8,-1
80006446:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006448:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000644a:	d5 03       	csrf	0x10
8000644c:	c0 48       	rjmp	80006454 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000644e:	3f f8       	mov	r8,-1
80006450:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006452:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006454:	30 08       	mov	r8,0
80006456:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006458:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000645a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000645c:	ea 68 61 0c 	mov	r8,680204
80006460:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006462:	5e fc       	retal	r12

80006464 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006464:	eb cd 40 e0 	pushm	r5-r7,lr
80006468:	18 96       	mov	r6,r12
8000646a:	16 97       	mov	r7,r11
8000646c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000646e:	f0 1f 00 2f 	mcall	80006528 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006472:	58 07       	cp.w	r7,0
80006474:	c5 80       	breq	80006524 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006476:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006478:	30 49       	mov	r9,4
8000647a:	f2 08 18 00 	cp.b	r8,r9
8000647e:	e0 88 00 53 	brls	80006524 <usart_init_rs232+0xc0>
80006482:	30 99       	mov	r9,9
80006484:	f2 08 18 00 	cp.b	r8,r9
80006488:	e0 8b 00 4e 	brhi	80006524 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000648c:	0f d9       	ld.ub	r9,r7[0x5]
8000648e:	30 78       	mov	r8,7
80006490:	f0 09 18 00 	cp.b	r9,r8
80006494:	e0 8b 00 48 	brhi	80006524 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006498:	8e 39       	ld.sh	r9,r7[0x6]
8000649a:	e0 68 01 01 	mov	r8,257
8000649e:	f0 09 19 00 	cp.h	r9,r8
800064a2:	e0 8b 00 41 	brhi	80006524 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800064a6:	ef 39 00 08 	ld.ub	r9,r7[8]
800064aa:	30 38       	mov	r8,3
800064ac:	f0 09 18 00 	cp.b	r9,r8
800064b0:	e0 8b 00 3a 	brhi	80006524 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800064b4:	0a 9a       	mov	r10,r5
800064b6:	6e 0b       	ld.w	r11,r7[0x0]
800064b8:	0c 9c       	mov	r12,r6
800064ba:	f0 1f 00 1d 	mcall	8000652c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800064be:	58 1c       	cp.w	r12,1
800064c0:	c3 20       	breq	80006524 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800064c2:	0f c8       	ld.ub	r8,r7[0x4]
800064c4:	30 99       	mov	r9,9
800064c6:	f2 08 18 00 	cp.b	r8,r9
800064ca:	c0 51       	brne	800064d4 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800064cc:	6c 18       	ld.w	r8,r6[0x4]
800064ce:	b1 b8       	sbr	r8,0x11
800064d0:	8d 18       	st.w	r6[0x4],r8
800064d2:	c0 68       	rjmp	800064de <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800064d4:	6c 19       	ld.w	r9,r6[0x4]
800064d6:	20 58       	sub	r8,5
800064d8:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800064dc:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800064de:	6c 19       	ld.w	r9,r6[0x4]
800064e0:	ef 3a 00 08 	ld.ub	r10,r7[8]
800064e4:	0f d8       	ld.ub	r8,r7[0x5]
800064e6:	a9 78       	lsl	r8,0x9
800064e8:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800064ec:	12 48       	or	r8,r9
800064ee:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800064f0:	8e 38       	ld.sh	r8,r7[0x6]
800064f2:	30 29       	mov	r9,2
800064f4:	f2 08 19 00 	cp.h	r8,r9
800064f8:	e0 88 00 09 	brls	8000650a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800064fc:	6c 18       	ld.w	r8,r6[0x4]
800064fe:	ad b8       	sbr	r8,0xd
80006500:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006502:	8e b8       	ld.uh	r8,r7[0x6]
80006504:	20 28       	sub	r8,2
80006506:	8d a8       	st.w	r6[0x28],r8
80006508:	c0 68       	rjmp	80006514 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000650a:	6c 19       	ld.w	r9,r6[0x4]
8000650c:	5c 78       	castu.h	r8
8000650e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006512:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006514:	6c 18       	ld.w	r8,r6[0x4]
80006516:	e0 18 ff f0 	andl	r8,0xfff0
8000651a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000651c:	35 08       	mov	r8,80
8000651e:	8d 08       	st.w	r6[0x0],r8
80006520:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006524:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006528:	80 00       	ld.sh	r0,r0[0x0]
8000652a:	64 38       	ld.w	r8,r2[0xc]
8000652c:	80 00       	ld.sh	r0,r0[0x0]
8000652e:	63 28       	ld.w	r8,r1[0x48]

80006530 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006530:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006534:	fe c0 8f 34 	sub	r0,pc,-28876

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006538:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000653c:	d5 53       	csrf	0x15
  cp      r0, r1
8000653e:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006540:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006544:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006546:	c0 62       	brcc	80006552 <idata_load_loop_end>
  cp      r0, r1
80006548:	48 92       	lddpc	r2,8000656c <udata_clear_loop_end+0x4>

8000654a <idata_load_loop>:
  brlo    idata_load_loop
8000654a:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000654c:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000654e:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006550:	cf d3       	brcs	8000654a <idata_load_loop>

80006552 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006552:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
80006556:	e0 61 53 e0 	mov	r1,21472
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000655a:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000655c:	c0 62       	brcc	80006568 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000655e:	30 02       	mov	r2,0
80006560:	30 03       	mov	r3,0

80006562 <udata_clear_loop>:
80006562:	a1 22       	st.d	r0++,r2
80006564:	02 30       	cp.w	r0,r1
80006566:	cf e3       	brcs	80006562 <udata_clear_loop>

80006568 <udata_clear_loop_end>:
80006568:	fe cf e9 80 	sub	pc,pc,-5760
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	ec b8       	*unknown*

80006570 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006570:	f8 c8 ff f8 	sub	r8,r12,-8
80006574:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006576:	3f f9       	mov	r9,-1
80006578:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000657a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
8000657c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000657e:	30 08       	mov	r8,0
80006580:	99 08       	st.w	r12[0x0],r8
}
80006582:	5e fc       	retal	r12

80006584 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006584:	30 08       	mov	r8,0
80006586:	99 48       	st.w	r12[0x10],r8
}
80006588:	5e fc       	retal	r12

8000658a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000658a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
8000658c:	70 19       	ld.w	r9,r8[0x4]
8000658e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006590:	78 19       	ld.w	r9,r12[0x4]
80006592:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006594:	70 19       	ld.w	r9,r8[0x4]
80006596:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006598:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000659a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000659c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000659e:	78 08       	ld.w	r8,r12[0x0]
800065a0:	2f f8       	sub	r8,-1
800065a2:	99 08       	st.w	r12[0x0],r8
}
800065a4:	5e fc       	retal	r12

800065a6 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800065a6:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800065a8:	5b fa       	cp.w	r10,-1
800065aa:	c0 31       	brne	800065b0 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800065ac:	78 48       	ld.w	r8,r12[0x10]
800065ae:	c0 c8       	rjmp	800065c6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800065b0:	f8 c8 ff f8 	sub	r8,r12,-8
800065b4:	70 19       	ld.w	r9,r8[0x4]
800065b6:	72 09       	ld.w	r9,r9[0x0]
800065b8:	12 3a       	cp.w	r10,r9
800065ba:	c0 63       	brcs	800065c6 <vListInsert+0x20>
800065bc:	70 18       	ld.w	r8,r8[0x4]
800065be:	70 19       	ld.w	r9,r8[0x4]
800065c0:	72 09       	ld.w	r9,r9[0x0]
800065c2:	12 3a       	cp.w	r10,r9
800065c4:	cf c2       	brcc	800065bc <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800065c6:	70 19       	ld.w	r9,r8[0x4]
800065c8:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800065ca:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800065cc:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800065ce:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800065d0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800065d2:	78 08       	ld.w	r8,r12[0x0]
800065d4:	2f f8       	sub	r8,-1
800065d6:	99 08       	st.w	r12[0x0],r8
}
800065d8:	5e fc       	retal	r12

800065da <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800065da:	78 18       	ld.w	r8,r12[0x4]
800065dc:	78 29       	ld.w	r9,r12[0x8]
800065de:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800065e0:	78 28       	ld.w	r8,r12[0x8]
800065e2:	78 19       	ld.w	r9,r12[0x4]
800065e4:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800065e6:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800065e8:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800065ea:	18 39       	cp.w	r9,r12
800065ec:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800065f0:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800065f4:	30 09       	mov	r9,0
800065f6:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800065f8:	70 09       	ld.w	r9,r8[0x0]
800065fa:	20 19       	sub	r9,1
800065fc:	91 09       	st.w	r8[0x0],r9
}
800065fe:	5e fc       	retal	r12

80006600 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006600:	e0 68 08 08 	mov	r8,2056
80006604:	ea 18 08 08 	orh	r8,0x808
80006608:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000660a:	e0 68 09 09 	mov	r8,2313
8000660e:	ea 18 09 09 	orh	r8,0x909
80006612:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006614:	e0 68 0a 0a 	mov	r8,2570
80006618:	ea 18 0a 0a 	orh	r8,0xa0a
8000661c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000661e:	e0 68 0b 0b 	mov	r8,2827
80006622:	ea 18 0b 0b 	orh	r8,0xb0b
80006626:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006628:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000662a:	e0 68 be ef 	mov	r8,48879
8000662e:	ea 18 de ad 	orh	r8,0xdead
80006632:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006634:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006636:	fc 18 00 40 	movh	r8,0x40
8000663a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000663c:	e0 68 00 ff 	mov	r8,255
80006640:	ea 18 ff 00 	orh	r8,0xff00
80006644:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006646:	e0 68 01 01 	mov	r8,257
8000664a:	ea 18 01 01 	orh	r8,0x101
8000664e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006650:	e0 68 02 02 	mov	r8,514
80006654:	ea 18 02 02 	orh	r8,0x202
80006658:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000665a:	e0 68 03 03 	mov	r8,771
8000665e:	ea 18 03 03 	orh	r8,0x303
80006662:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006664:	e0 68 04 04 	mov	r8,1028
80006668:	ea 18 04 04 	orh	r8,0x404
8000666c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000666e:	e0 68 05 05 	mov	r8,1285
80006672:	ea 18 05 05 	orh	r8,0x505
80006676:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006678:	e0 68 06 06 	mov	r8,1542
8000667c:	ea 18 06 06 	orh	r8,0x606
80006680:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006682:	e0 68 07 07 	mov	r8,1799
80006686:	ea 18 07 07 	orh	r8,0x707
8000668a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000668c:	30 08       	mov	r8,0
8000668e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006690:	5e fc       	retal	r12
80006692:	d7 03       	nop

80006694 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006694:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006696:	48 38       	lddpc	r8,800066a0 <vPortEnterCritical+0xc>
80006698:	70 09       	ld.w	r9,r8[0x0]
8000669a:	2f f9       	sub	r9,-1
8000669c:	91 09       	st.w	r8[0x0],r9
}
8000669e:	5e fc       	retal	r12
800066a0:	00 00       	add	r0,r0
800066a2:	05 3c       	ld.ub	r12,r2++

800066a4 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800066a4:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800066a6:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800066a8:	30 0a       	mov	r10,0
800066aa:	14 9b       	mov	r11,r10
800066ac:	49 2c       	lddpc	r12,800066f4 <xPortStartScheduler+0x50>
800066ae:	f0 1f 00 13 	mcall	800066f8 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800066b2:	e0 68 5d c0 	mov	r8,24000
800066b6:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800066ba:	30 08       	mov	r8,0
800066bc:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800066c0:	e0 68 0d 08 	mov	r8,3336
800066c4:	ea 18 00 00 	orh	r8,0x0
800066c8:	70 00       	ld.w	r0,r8[0x0]
800066ca:	60 0d       	ld.w	sp,r0[0x0]
800066cc:	1b 00       	ld.w	r0,sp++
800066ce:	e0 68 05 3c 	mov	r8,1340
800066d2:	ea 18 00 00 	orh	r8,0x0
800066d6:	91 00       	st.w	r8[0x0],r0
800066d8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800066dc:	2f ed       	sub	sp,-8
800066de:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800066e2:	fa f0 ff e0 	ld.w	r0,sp[-32]
800066e6:	e3 b0 00 00 	mtsr	0x0,r0
800066ea:	fa f0 ff dc 	ld.w	r0,sp[-36]
800066ee:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800066f2:	d8 0a       	popm	pc,r12=0
800066f4:	80 00       	ld.sh	r0,r0[0x0]
800066f6:	67 c0       	ld.w	r0,r3[0x70]
800066f8:	80 00       	ld.sh	r0,r0[0x0]
800066fa:	5c f4       	rol	r4

800066fc <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800066fc:	20 6d       	sub	sp,24
800066fe:	eb cd 00 ff 	pushm	r0-r7
80006702:	fa c7 ff c0 	sub	r7,sp,-64
80006706:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000670a:	ef 40 ff e0 	st.w	r7[-32],r0
8000670e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006712:	ef 40 ff e4 	st.w	r7[-28],r0
80006716:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000671a:	e0 68 05 3c 	mov	r8,1340
8000671e:	ea 18 00 00 	orh	r8,0x0
80006722:	70 00       	ld.w	r0,r8[0x0]
80006724:	1a d0       	st.w	--sp,r0
80006726:	f0 1f 00 1a 	mcall	8000678c <LABEL_RET_SCALL_263+0x14>
8000672a:	e0 68 0d 08 	mov	r8,3336
8000672e:	ea 18 00 00 	orh	r8,0x0
80006732:	70 00       	ld.w	r0,r8[0x0]
80006734:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006736:	f0 1f 00 17 	mcall	80006790 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000673a:	e0 68 0d 08 	mov	r8,3336
8000673e:	ea 18 00 00 	orh	r8,0x0
80006742:	70 00       	ld.w	r0,r8[0x0]
80006744:	60 0d       	ld.w	sp,r0[0x0]
80006746:	1b 00       	ld.w	r0,sp++
80006748:	e0 68 05 3c 	mov	r8,1340
8000674c:	ea 18 00 00 	orh	r8,0x0
80006750:	91 00       	st.w	r8[0x0],r0
80006752:	fa c7 ff d8 	sub	r7,sp,-40
80006756:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000675a:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000675e:	e0 61 05 3c 	mov	r1,1340
80006762:	ea 11 00 00 	orh	r1,0x0
80006766:	62 02       	ld.w	r2,r1[0x0]
80006768:	58 02       	cp.w	r2,0
8000676a:	c0 70       	breq	80006778 <LABEL_RET_SCALL_263>
8000676c:	e4 c2 00 01 	sub	r2,r2,1
80006770:	83 02       	st.w	r1[0x0],r2
80006772:	58 02       	cp.w	r2,0
80006774:	c0 21       	brne	80006778 <LABEL_RET_SCALL_263>
80006776:	b1 c0       	cbr	r0,0x10

80006778 <LABEL_RET_SCALL_263>:
80006778:	ef 40 ff f8 	st.w	r7[-8],r0
8000677c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006780:	ef 40 ff fc 	st.w	r7[-4],r0
80006784:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006788:	2f ad       	sub	sp,-24
8000678a:	d6 13       	rets
8000678c:	80 00       	ld.sh	r0,r0[0x0]
8000678e:	66 94       	ld.w	r4,r3[0x24]
80006790:	80 00       	ld.sh	r0,r0[0x0]
80006792:	6d d8       	ld.w	r8,r6[0x74]

80006794 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006794:	e1 b8 00 43 	mfsr	r8,0x10c
80006798:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000679c:	5e fc       	retal	r12
8000679e:	d7 03       	nop

800067a0 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800067a0:	48 78       	lddpc	r8,800067bc <vPortExitCritical+0x1c>
800067a2:	70 08       	ld.w	r8,r8[0x0]
800067a4:	58 08       	cp.w	r8,0
800067a6:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800067a8:	48 58       	lddpc	r8,800067bc <vPortExitCritical+0x1c>
800067aa:	70 09       	ld.w	r9,r8[0x0]
800067ac:	20 19       	sub	r9,1
800067ae:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800067b0:	70 08       	ld.w	r8,r8[0x0]
800067b2:	58 08       	cp.w	r8,0
800067b4:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800067b6:	d5 03       	csrf	0x10
800067b8:	5e fc       	retal	r12
800067ba:	00 00       	add	r0,r0
800067bc:	00 00       	add	r0,r0
800067be:	05 3c       	ld.ub	r12,r2++

800067c0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800067c0:	eb cd 00 ff 	pushm	r0-r7
800067c4:	e0 68 05 3c 	mov	r8,1340
800067c8:	ea 18 00 00 	orh	r8,0x0
800067cc:	70 00       	ld.w	r0,r8[0x0]
800067ce:	1a d0       	st.w	--sp,r0
800067d0:	7a 90       	ld.w	r0,sp[0x24]
800067d2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800067d6:	58 10       	cp.w	r0,1
800067d8:	e0 8b 00 08 	brhi	800067e8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800067dc:	e0 68 0d 08 	mov	r8,3336
800067e0:	ea 18 00 00 	orh	r8,0x0
800067e4:	70 00       	ld.w	r0,r8[0x0]
800067e6:	81 0d       	st.w	r0[0x0],sp

800067e8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800067e8:	f0 1f 00 12 	mcall	80006830 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800067ec:	f0 1f 00 12 	mcall	80006834 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800067f0:	f0 1f 00 12 	mcall	80006838 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800067f4:	f0 1f 00 12 	mcall	8000683c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800067f8:	7a 90       	ld.w	r0,sp[0x24]
800067fa:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800067fe:	58 10       	cp.w	r0,1
80006800:	e0 8b 00 0e 	brhi	8000681c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006804:	f0 1f 00 0c 	mcall	80006834 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006808:	f0 1f 00 0e 	mcall	80006840 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
8000680c:	f0 1f 00 0c 	mcall	8000683c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006810:	e0 68 0d 08 	mov	r8,3336
80006814:	ea 18 00 00 	orh	r8,0x0
80006818:	70 00       	ld.w	r0,r8[0x0]
8000681a:	60 0d       	ld.w	sp,r0[0x0]

8000681c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
8000681c:	1b 00       	ld.w	r0,sp++
8000681e:	e0 68 05 3c 	mov	r8,1340
80006822:	ea 18 00 00 	orh	r8,0x0
80006826:	91 00       	st.w	r8[0x0],r0
80006828:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000682c:	d6 03       	rete
8000682e:	00 00       	add	r0,r0
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	67 94       	ld.w	r4,r3[0x64]
80006834:	80 00       	ld.sh	r0,r0[0x0]
80006836:	66 94       	ld.w	r4,r3[0x24]
80006838:	80 00       	ld.sh	r0,r0[0x0]
8000683a:	6f dc       	ld.w	r12,r7[0x74]
8000683c:	80 00       	ld.sh	r0,r0[0x0]
8000683e:	67 a0       	ld.w	r0,r3[0x68]
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	6d d8       	ld.w	r8,r6[0x74]

80006844 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006844:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006846:	f0 1f 00 02 	mcall	8000684c <__malloc_lock+0x8>
}
8000684a:	d8 02       	popm	pc
8000684c:	80 00       	ld.sh	r0,r0[0x0]
8000684e:	6d c8       	ld.w	r8,r6[0x70]

80006850 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006850:	d4 01       	pushm	lr
	xTaskResumeAll();
80006852:	f0 1f 00 02 	mcall	80006858 <__malloc_unlock+0x8>
}
80006856:	d8 02       	popm	pc
80006858:	80 00       	ld.sh	r0,r0[0x0]
8000685a:	71 84       	ld.w	r4,r8[0x60]

8000685c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
8000685c:	d4 21       	pushm	r4-r7,lr
8000685e:	16 95       	mov	r5,r11
80006860:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006862:	58 0c       	cp.w	r12,0
80006864:	c0 30       	breq	8000686a <_read+0xe>
80006866:	3f f7       	mov	r7,-1
80006868:	c1 48       	rjmp	80006890 <_read+0x34>
    return -1;

  for (; len > 0; --len)
8000686a:	58 0a       	cp.w	r10,0
8000686c:	e0 89 00 04 	brgt	80006874 <_read+0x18>
80006870:	30 07       	mov	r7,0
80006872:	c0 f8       	rjmp	80006890 <_read+0x34>
80006874:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006876:	48 84       	lddpc	r4,80006894 <_read+0x38>
80006878:	68 0c       	ld.w	r12,r4[0x0]
8000687a:	f0 1f 00 08 	mcall	80006898 <_read+0x3c>
    if (c < 0)
8000687e:	c0 95       	brlt	80006890 <_read+0x34>
      break;

    *ptr++ = c;
80006880:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006884:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006886:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000688a:	58 08       	cp.w	r8,0
8000688c:	fe 99 ff f6 	brgt	80006878 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006890:	0e 9c       	mov	r12,r7
80006892:	d8 22       	popm	r4-r7,pc
80006894:	00 00       	add	r0,r0
80006896:	53 d0       	stdsp	sp[0xf4],r0
80006898:	80 00       	ld.sh	r0,r0[0x0]
8000689a:	63 e8       	ld.w	r8,r1[0x78]

8000689c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
8000689c:	d4 21       	pushm	r4-r7,lr
8000689e:	16 95       	mov	r5,r11
800068a0:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800068a2:	20 1c       	sub	r12,1
800068a4:	58 2c       	cp.w	r12,2
800068a6:	e0 8b 00 12 	brhi	800068ca <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800068aa:	58 0a       	cp.w	r10,0
800068ac:	c0 31       	brne	800068b2 <_write+0x16>
800068ae:	30 07       	mov	r7,0
800068b0:	c0 e8       	rjmp	800068cc <_write+0x30>
800068b2:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800068b4:	48 74       	lddpc	r4,800068d0 <_write+0x34>
800068b6:	68 0c       	ld.w	r12,r4[0x0]
800068b8:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800068bc:	f0 1f 00 06 	mcall	800068d4 <_write+0x38>
800068c0:	c0 55       	brlt	800068ca <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800068c2:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800068c4:	0e 36       	cp.w	r6,r7
800068c6:	cf 81       	brne	800068b6 <_write+0x1a>
800068c8:	c0 28       	rjmp	800068cc <_write+0x30>
800068ca:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800068cc:	0e 9c       	mov	r12,r7
800068ce:	d8 22       	popm	r4-r7,pc
800068d0:	00 00       	add	r0,r0
800068d2:	53 d0       	stdsp	sp[0xf4],r0
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	63 98       	ld.w	r8,r1[0x64]

800068d8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800068d8:	eb cd 40 80 	pushm	r7,lr
800068dc:	18 97       	mov	r7,r12
	if( pv )
800068de:	58 0c       	cp.w	r12,0
800068e0:	c0 80       	breq	800068f0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800068e2:	f0 1f 00 05 	mcall	800068f4 <vPortFree+0x1c>
		{
			free( pv );
800068e6:	0e 9c       	mov	r12,r7
800068e8:	f0 1f 00 04 	mcall	800068f8 <vPortFree+0x20>
		}
		xTaskResumeAll();
800068ec:	f0 1f 00 04 	mcall	800068fc <vPortFree+0x24>
800068f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800068f4:	80 00       	ld.sh	r0,r0[0x0]
800068f6:	6d c8       	ld.w	r8,r6[0x70]
800068f8:	80 00       	ld.sh	r0,r0[0x0]
800068fa:	7c 58       	ld.w	r8,lr[0x14]
800068fc:	80 00       	ld.sh	r0,r0[0x0]
800068fe:	71 84       	ld.w	r4,r8[0x60]

80006900 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006900:	eb cd 40 80 	pushm	r7,lr
80006904:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006906:	f0 1f 00 06 	mcall	8000691c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000690a:	0e 9c       	mov	r12,r7
8000690c:	f0 1f 00 05 	mcall	80006920 <pvPortMalloc+0x20>
80006910:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006912:	f0 1f 00 05 	mcall	80006924 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006916:	0e 9c       	mov	r12,r7
80006918:	e3 cd 80 80 	ldm	sp++,r7,pc
8000691c:	80 00       	ld.sh	r0,r0[0x0]
8000691e:	6d c8       	ld.w	r8,r6[0x70]
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	7c 68       	ld.w	r8,lr[0x18]
80006924:	80 00       	ld.sh	r0,r0[0x0]
80006926:	71 84       	ld.w	r4,r8[0x60]

80006928 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006928:	d4 01       	pushm	lr
8000692a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
8000692c:	78 09       	ld.w	r9,r12[0x0]
8000692e:	58 09       	cp.w	r9,0
80006930:	c1 10       	breq	80006952 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006932:	78 3a       	ld.w	r10,r12[0xc]
80006934:	79 09       	ld.w	r9,r12[0x40]
80006936:	f4 09 00 09 	add	r9,r10,r9
8000693a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000693c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000693e:	14 39       	cp.w	r9,r10
80006940:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006944:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006948:	79 0a       	ld.w	r10,r12[0x40]
8000694a:	78 3b       	ld.w	r11,r12[0xc]
8000694c:	10 9c       	mov	r12,r8
8000694e:	f0 1f 00 02 	mcall	80006954 <prvCopyDataFromQueue+0x2c>
80006952:	d8 02       	popm	pc
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	80 b0       	ld.uh	r0,r0[0x6]

80006958 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006958:	eb cd 40 c0 	pushm	r6-r7,lr
8000695c:	18 97       	mov	r7,r12
8000695e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006960:	78 e8       	ld.w	r8,r12[0x38]
80006962:	58 08       	cp.w	r8,0
80006964:	c0 31       	brne	8000696a <xQueueReceiveFromISR+0x12>
80006966:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000696a:	f0 1f 00 0e 	mcall	800069a0 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000696e:	6e e8       	ld.w	r8,r7[0x38]
80006970:	20 18       	sub	r8,1
80006972:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006974:	6f 18       	ld.w	r8,r7[0x44]
80006976:	5b f8       	cp.w	r8,-1
80006978:	c0 d1       	brne	80006992 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000697a:	6e 48       	ld.w	r8,r7[0x10]
8000697c:	58 08       	cp.w	r8,0
8000697e:	c0 f0       	breq	8000699c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006980:	ee cc ff f0 	sub	r12,r7,-16
80006984:	f0 1f 00 08 	mcall	800069a4 <xQueueReceiveFromISR+0x4c>
80006988:	c0 a0       	breq	8000699c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000698a:	30 1c       	mov	r12,1
8000698c:	8d 0c       	st.w	r6[0x0],r12
8000698e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006992:	2f f8       	sub	r8,-1
80006994:	ef 48 00 44 	st.w	r7[68],r8
80006998:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000699c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	69 28       	ld.w	r8,r4[0x48]
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	6f 60       	ld.w	r0,r7[0x58]

800069a8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800069a8:	eb cd 40 c0 	pushm	r6-r7,lr
800069ac:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800069ae:	f0 1f 00 23 	mcall	80006a38 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800069b2:	6f 28       	ld.w	r8,r7[0x48]
800069b4:	58 08       	cp.w	r8,0
800069b6:	e0 8a 00 18 	brle	800069e6 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800069ba:	6e 98       	ld.w	r8,r7[0x24]
800069bc:	58 08       	cp.w	r8,0
800069be:	c1 40       	breq	800069e6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800069c0:	ee c6 ff dc 	sub	r6,r7,-36
800069c4:	c0 48       	rjmp	800069cc <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800069c6:	6e 98       	ld.w	r8,r7[0x24]
800069c8:	58 08       	cp.w	r8,0
800069ca:	c0 e0       	breq	800069e6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800069cc:	0c 9c       	mov	r12,r6
800069ce:	f0 1f 00 1c 	mcall	80006a3c <prvUnlockQueue+0x94>
800069d2:	c0 30       	breq	800069d8 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800069d4:	f0 1f 00 1b 	mcall	80006a40 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800069d8:	6f 28       	ld.w	r8,r7[0x48]
800069da:	20 18       	sub	r8,1
800069dc:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800069e0:	58 08       	cp.w	r8,0
800069e2:	fe 99 ff f2 	brgt	800069c6 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800069e6:	3f f8       	mov	r8,-1
800069e8:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800069ec:	f0 1f 00 16 	mcall	80006a44 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800069f0:	f0 1f 00 12 	mcall	80006a38 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800069f4:	6f 18       	ld.w	r8,r7[0x44]
800069f6:	58 08       	cp.w	r8,0
800069f8:	e0 8a 00 18 	brle	80006a28 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800069fc:	6e 48       	ld.w	r8,r7[0x10]
800069fe:	58 08       	cp.w	r8,0
80006a00:	c1 40       	breq	80006a28 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006a02:	ee c6 ff f0 	sub	r6,r7,-16
80006a06:	c0 48       	rjmp	80006a0e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006a08:	6e 48       	ld.w	r8,r7[0x10]
80006a0a:	58 08       	cp.w	r8,0
80006a0c:	c0 e0       	breq	80006a28 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006a0e:	0c 9c       	mov	r12,r6
80006a10:	f0 1f 00 0b 	mcall	80006a3c <prvUnlockQueue+0x94>
80006a14:	c0 30       	breq	80006a1a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80006a16:	f0 1f 00 0b 	mcall	80006a40 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006a1a:	6f 18       	ld.w	r8,r7[0x44]
80006a1c:	20 18       	sub	r8,1
80006a1e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006a22:	58 08       	cp.w	r8,0
80006a24:	fe 99 ff f2 	brgt	80006a08 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006a28:	3f f8       	mov	r8,-1
80006a2a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006a2e:	f0 1f 00 06 	mcall	80006a44 <prvUnlockQueue+0x9c>
}
80006a32:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a36:	00 00       	add	r0,r0
80006a38:	80 00       	ld.sh	r0,r0[0x0]
80006a3a:	66 94       	ld.w	r4,r3[0x24]
80006a3c:	80 00       	ld.sh	r0,r0[0x0]
80006a3e:	6f 60       	ld.w	r0,r7[0x58]
80006a40:	80 00       	ld.sh	r0,r0[0x0]
80006a42:	6e 6c       	ld.w	r12,r7[0x18]
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	67 a0       	ld.w	r0,r3[0x68]

80006a48 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006a48:	d4 31       	pushm	r0-r7,lr
80006a4a:	20 5d       	sub	sp,20
80006a4c:	18 97       	mov	r7,r12
80006a4e:	50 0b       	stdsp	sp[0x0],r11
80006a50:	50 2a       	stdsp	sp[0x8],r10
80006a52:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006a54:	f8 c2 ff dc 	sub	r2,r12,-36
80006a58:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006a5a:	fa c4 ff f4 	sub	r4,sp,-12
80006a5e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006a60:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006a62:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006a66:	f0 1f 00 3e 	mcall	80006b5c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006a6a:	6e e8       	ld.w	r8,r7[0x38]
80006a6c:	58 08       	cp.w	r8,0
80006a6e:	c2 a0       	breq	80006ac2 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006a70:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006a72:	40 0b       	lddsp	r11,sp[0x0]
80006a74:	0e 9c       	mov	r12,r7
80006a76:	f0 1f 00 3b 	mcall	80006b60 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006a7a:	40 18       	lddsp	r8,sp[0x4]
80006a7c:	58 08       	cp.w	r8,0
80006a7e:	c1 51       	brne	80006aa8 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006a80:	6e e8       	ld.w	r8,r7[0x38]
80006a82:	20 18       	sub	r8,1
80006a84:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006a86:	6e 08       	ld.w	r8,r7[0x0]
80006a88:	58 08       	cp.w	r8,0
80006a8a:	c0 41       	brne	80006a92 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006a8c:	f0 1f 00 36 	mcall	80006b64 <xQueueGenericReceive+0x11c>
80006a90:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006a92:	6e 48       	ld.w	r8,r7[0x10]
80006a94:	58 08       	cp.w	r8,0
80006a96:	c1 20       	breq	80006aba <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006a98:	ee cc ff f0 	sub	r12,r7,-16
80006a9c:	f0 1f 00 33 	mcall	80006b68 <xQueueGenericReceive+0x120>
80006aa0:	58 1c       	cp.w	r12,1
80006aa2:	c0 c1       	brne	80006aba <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006aa4:	d7 33       	scall
80006aa6:	c0 a8       	rjmp	80006aba <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006aa8:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006aaa:	6e 98       	ld.w	r8,r7[0x24]
80006aac:	58 08       	cp.w	r8,0
80006aae:	c0 60       	breq	80006aba <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006ab0:	04 9c       	mov	r12,r2
80006ab2:	f0 1f 00 2e 	mcall	80006b68 <xQueueGenericReceive+0x120>
80006ab6:	c0 20       	breq	80006aba <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006ab8:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006aba:	f0 1f 00 2d 	mcall	80006b6c <xQueueGenericReceive+0x124>
80006abe:	30 1c       	mov	r12,1
				return pdPASS;
80006ac0:	c4 c8       	rjmp	80006b58 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006ac2:	40 28       	lddsp	r8,sp[0x8]
80006ac4:	58 08       	cp.w	r8,0
80006ac6:	c0 51       	brne	80006ad0 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006ac8:	f0 1f 00 29 	mcall	80006b6c <xQueueGenericReceive+0x124>
80006acc:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006ace:	c4 58       	rjmp	80006b58 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006ad0:	58 05       	cp.w	r5,0
80006ad2:	c0 51       	brne	80006adc <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006ad4:	08 9c       	mov	r12,r4
80006ad6:	f0 1f 00 27 	mcall	80006b70 <xQueueGenericReceive+0x128>
80006ada:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006adc:	f0 1f 00 24 	mcall	80006b6c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006ae0:	f0 1f 00 25 	mcall	80006b74 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006ae4:	f0 1f 00 1e 	mcall	80006b5c <xQueueGenericReceive+0x114>
80006ae8:	6f 18       	ld.w	r8,r7[0x44]
80006aea:	5b f8       	cp.w	r8,-1
80006aec:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006af0:	6f 28       	ld.w	r8,r7[0x48]
80006af2:	5b f8       	cp.w	r8,-1
80006af4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006af8:	f0 1f 00 1d 	mcall	80006b6c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006afc:	06 9b       	mov	r11,r3
80006afe:	08 9c       	mov	r12,r4
80006b00:	f0 1f 00 1e 	mcall	80006b78 <xQueueGenericReceive+0x130>
80006b04:	c2 41       	brne	80006b4c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006b06:	f0 1f 00 16 	mcall	80006b5c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006b0a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006b0c:	f0 1f 00 18 	mcall	80006b6c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006b10:	58 06       	cp.w	r6,0
80006b12:	c1 71       	brne	80006b40 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006b14:	6e 08       	ld.w	r8,r7[0x0]
80006b16:	58 08       	cp.w	r8,0
80006b18:	c0 81       	brne	80006b28 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006b1a:	f0 1f 00 11 	mcall	80006b5c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006b1e:	6e 1c       	ld.w	r12,r7[0x4]
80006b20:	f0 1f 00 17 	mcall	80006b7c <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006b24:	f0 1f 00 12 	mcall	80006b6c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006b28:	40 2b       	lddsp	r11,sp[0x8]
80006b2a:	04 9c       	mov	r12,r2
80006b2c:	f0 1f 00 15 	mcall	80006b80 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006b30:	0e 9c       	mov	r12,r7
80006b32:	f0 1f 00 15 	mcall	80006b84 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006b36:	f0 1f 00 15 	mcall	80006b88 <xQueueGenericReceive+0x140>
80006b3a:	c9 61       	brne	80006a66 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006b3c:	d7 33       	scall
80006b3e:	c9 4b       	rjmp	80006a66 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006b40:	0e 9c       	mov	r12,r7
80006b42:	f0 1f 00 11 	mcall	80006b84 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006b46:	f0 1f 00 11 	mcall	80006b88 <xQueueGenericReceive+0x140>
80006b4a:	c8 eb       	rjmp	80006a66 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006b4c:	0e 9c       	mov	r12,r7
80006b4e:	f0 1f 00 0e 	mcall	80006b84 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006b52:	f0 1f 00 0e 	mcall	80006b88 <xQueueGenericReceive+0x140>
80006b56:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006b58:	2f bd       	sub	sp,-20
80006b5a:	d8 32       	popm	r0-r7,pc
80006b5c:	80 00       	ld.sh	r0,r0[0x0]
80006b5e:	66 94       	ld.w	r4,r3[0x24]
80006b60:	80 00       	ld.sh	r0,r0[0x0]
80006b62:	69 28       	ld.w	r8,r4[0x48]
80006b64:	80 00       	ld.sh	r0,r0[0x0]
80006b66:	6e 78       	ld.w	r8,r7[0x1c]
80006b68:	80 00       	ld.sh	r0,r0[0x0]
80006b6a:	6f 60       	ld.w	r0,r7[0x58]
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	67 a0       	ld.w	r0,r3[0x68]
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	6e 54       	ld.w	r4,r7[0x14]
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	6d c8       	ld.w	r8,r6[0x70]
80006b78:	80 00       	ld.sh	r0,r0[0x0]
80006b7a:	70 f0       	ld.w	r0,r8[0x3c]
80006b7c:	80 00       	ld.sh	r0,r0[0x0]
80006b7e:	6e dc       	ld.w	r12,r7[0x34]
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	73 90       	ld.w	r0,r9[0x64]
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	69 a8       	ld.w	r8,r4[0x68]
80006b88:	80 00       	ld.sh	r0,r0[0x0]
80006b8a:	71 84       	ld.w	r4,r8[0x60]

80006b8c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006b8c:	eb cd 40 80 	pushm	r7,lr
80006b90:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006b92:	79 08       	ld.w	r8,r12[0x40]
80006b94:	58 08       	cp.w	r8,0
80006b96:	c0 a1       	brne	80006baa <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006b98:	78 08       	ld.w	r8,r12[0x0]
80006b9a:	58 08       	cp.w	r8,0
80006b9c:	c2 b1       	brne	80006bf2 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006b9e:	78 1c       	ld.w	r12,r12[0x4]
80006ba0:	f0 1f 00 17 	mcall	80006bfc <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006ba4:	30 08       	mov	r8,0
80006ba6:	8f 18       	st.w	r7[0x4],r8
80006ba8:	c2 58       	rjmp	80006bf2 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006baa:	58 0a       	cp.w	r10,0
80006bac:	c1 01       	brne	80006bcc <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006bae:	10 9a       	mov	r10,r8
80006bb0:	78 2c       	ld.w	r12,r12[0x8]
80006bb2:	f0 1f 00 14 	mcall	80006c00 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006bb6:	6e 29       	ld.w	r9,r7[0x8]
80006bb8:	6f 08       	ld.w	r8,r7[0x40]
80006bba:	f2 08 00 08 	add	r8,r9,r8
80006bbe:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006bc0:	6e 19       	ld.w	r9,r7[0x4]
80006bc2:	12 38       	cp.w	r8,r9
80006bc4:	c1 73       	brcs	80006bf2 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006bc6:	6e 08       	ld.w	r8,r7[0x0]
80006bc8:	8f 28       	st.w	r7[0x8],r8
80006bca:	c1 48       	rjmp	80006bf2 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006bcc:	10 9a       	mov	r10,r8
80006bce:	78 3c       	ld.w	r12,r12[0xc]
80006bd0:	f0 1f 00 0c 	mcall	80006c00 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006bd4:	6f 08       	ld.w	r8,r7[0x40]
80006bd6:	6e 39       	ld.w	r9,r7[0xc]
80006bd8:	f2 08 01 08 	sub	r8,r9,r8
80006bdc:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006bde:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006be0:	12 38       	cp.w	r8,r9
80006be2:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006be6:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006bea:	f3 d8 e3 19 	subcs	r9,r9,r8
80006bee:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006bf2:	6e e8       	ld.w	r8,r7[0x38]
80006bf4:	2f f8       	sub	r8,-1
80006bf6:	8f e8       	st.w	r7[0x38],r8
}
80006bf8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	6e 84       	ld.w	r4,r7[0x20]
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	80 b0       	ld.uh	r0,r0[0x6]

80006c04 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006c04:	eb cd 40 c0 	pushm	r6-r7,lr
80006c08:	18 97       	mov	r7,r12
80006c0a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006c0c:	78 ec       	ld.w	r12,r12[0x38]
80006c0e:	6e f8       	ld.w	r8,r7[0x3c]
80006c10:	10 3c       	cp.w	r12,r8
80006c12:	c0 33       	brcs	80006c18 <xQueueGenericSendFromISR+0x14>
80006c14:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006c18:	12 9a       	mov	r10,r9
80006c1a:	0e 9c       	mov	r12,r7
80006c1c:	f0 1f 00 0c 	mcall	80006c4c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006c20:	6f 28       	ld.w	r8,r7[0x48]
80006c22:	5b f8       	cp.w	r8,-1
80006c24:	c0 d1       	brne	80006c3e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006c26:	6e 98       	ld.w	r8,r7[0x24]
80006c28:	58 08       	cp.w	r8,0
80006c2a:	c0 f0       	breq	80006c48 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006c2c:	ee cc ff dc 	sub	r12,r7,-36
80006c30:	f0 1f 00 08 	mcall	80006c50 <xQueueGenericSendFromISR+0x4c>
80006c34:	c0 a0       	breq	80006c48 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006c36:	30 1c       	mov	r12,1
80006c38:	8d 0c       	st.w	r6[0x0],r12
80006c3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006c3e:	2f f8       	sub	r8,-1
80006c40:	ef 48 00 48 	st.w	r7[72],r8
80006c44:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006c48:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006c4c:	80 00       	ld.sh	r0,r0[0x0]
80006c4e:	6b 8c       	ld.w	r12,r5[0x60]
80006c50:	80 00       	ld.sh	r0,r0[0x0]
80006c52:	6f 60       	ld.w	r0,r7[0x58]

80006c54 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006c54:	d4 31       	pushm	r0-r7,lr
80006c56:	20 5d       	sub	sp,20
80006c58:	18 97       	mov	r7,r12
80006c5a:	50 0b       	stdsp	sp[0x0],r11
80006c5c:	50 2a       	stdsp	sp[0x8],r10
80006c5e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006c60:	f8 c0 ff f0 	sub	r0,r12,-16
80006c64:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006c66:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006c6a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006c6c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006c70:	f0 1f 00 2f 	mcall	80006d2c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006c74:	6e e9       	ld.w	r9,r7[0x38]
80006c76:	6e f8       	ld.w	r8,r7[0x3c]
80006c78:	10 39       	cp.w	r9,r8
80006c7a:	c1 42       	brcc	80006ca2 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006c7c:	40 1a       	lddsp	r10,sp[0x4]
80006c7e:	40 0b       	lddsp	r11,sp[0x0]
80006c80:	0e 9c       	mov	r12,r7
80006c82:	f0 1f 00 2c 	mcall	80006d30 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006c86:	6e 98       	ld.w	r8,r7[0x24]
80006c88:	58 08       	cp.w	r8,0
80006c8a:	c0 80       	breq	80006c9a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006c8c:	ee cc ff dc 	sub	r12,r7,-36
80006c90:	f0 1f 00 29 	mcall	80006d34 <xQueueGenericSend+0xe0>
80006c94:	58 1c       	cp.w	r12,1
80006c96:	c0 21       	brne	80006c9a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006c98:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006c9a:	f0 1f 00 28 	mcall	80006d38 <xQueueGenericSend+0xe4>
80006c9e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006ca0:	c4 38       	rjmp	80006d26 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006ca2:	40 28       	lddsp	r8,sp[0x8]
80006ca4:	58 08       	cp.w	r8,0
80006ca6:	c0 51       	brne	80006cb0 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006ca8:	f0 1f 00 24 	mcall	80006d38 <xQueueGenericSend+0xe4>
80006cac:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006cae:	c3 c8       	rjmp	80006d26 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006cb0:	58 04       	cp.w	r4,0
80006cb2:	c0 51       	brne	80006cbc <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006cb4:	06 9c       	mov	r12,r3
80006cb6:	f0 1f 00 22 	mcall	80006d3c <xQueueGenericSend+0xe8>
80006cba:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006cbc:	f0 1f 00 1f 	mcall	80006d38 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006cc0:	f0 1f 00 20 	mcall	80006d40 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006cc4:	f0 1f 00 1a 	mcall	80006d2c <xQueueGenericSend+0xd8>
80006cc8:	6f 18       	ld.w	r8,r7[0x44]
80006cca:	5b f8       	cp.w	r8,-1
80006ccc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006cd0:	6f 28       	ld.w	r8,r7[0x48]
80006cd2:	5b f8       	cp.w	r8,-1
80006cd4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006cd8:	f0 1f 00 18 	mcall	80006d38 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006cdc:	04 9b       	mov	r11,r2
80006cde:	06 9c       	mov	r12,r3
80006ce0:	f0 1f 00 19 	mcall	80006d44 <xQueueGenericSend+0xf0>
80006ce4:	c1 b1       	brne	80006d1a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006ce6:	f0 1f 00 12 	mcall	80006d2c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006cea:	6e e5       	ld.w	r5,r7[0x38]
80006cec:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006cee:	f0 1f 00 13 	mcall	80006d38 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006cf2:	0c 35       	cp.w	r5,r6
80006cf4:	c0 d1       	brne	80006d0e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006cf6:	40 2b       	lddsp	r11,sp[0x8]
80006cf8:	00 9c       	mov	r12,r0
80006cfa:	f0 1f 00 14 	mcall	80006d48 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006cfe:	0e 9c       	mov	r12,r7
80006d00:	f0 1f 00 13 	mcall	80006d4c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006d04:	f0 1f 00 13 	mcall	80006d50 <xQueueGenericSend+0xfc>
80006d08:	cb 41       	brne	80006c70 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006d0a:	d7 33       	scall
80006d0c:	cb 2b       	rjmp	80006c70 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006d0e:	0e 9c       	mov	r12,r7
80006d10:	f0 1f 00 0f 	mcall	80006d4c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006d14:	f0 1f 00 0f 	mcall	80006d50 <xQueueGenericSend+0xfc>
80006d18:	ca cb       	rjmp	80006c70 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006d1a:	0e 9c       	mov	r12,r7
80006d1c:	f0 1f 00 0c 	mcall	80006d4c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006d20:	f0 1f 00 0c 	mcall	80006d50 <xQueueGenericSend+0xfc>
80006d24:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006d26:	2f bd       	sub	sp,-20
80006d28:	d8 32       	popm	r0-r7,pc
80006d2a:	00 00       	add	r0,r0
80006d2c:	80 00       	ld.sh	r0,r0[0x0]
80006d2e:	66 94       	ld.w	r4,r3[0x24]
80006d30:	80 00       	ld.sh	r0,r0[0x0]
80006d32:	6b 8c       	ld.w	r12,r5[0x60]
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	6f 60       	ld.w	r0,r7[0x58]
80006d38:	80 00       	ld.sh	r0,r0[0x0]
80006d3a:	67 a0       	ld.w	r0,r3[0x68]
80006d3c:	80 00       	ld.sh	r0,r0[0x0]
80006d3e:	6e 54       	ld.w	r4,r7[0x14]
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	6d c8       	ld.w	r8,r6[0x70]
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	70 f0       	ld.w	r0,r8[0x3c]
80006d48:	80 00       	ld.sh	r0,r0[0x0]
80006d4a:	73 90       	ld.w	r0,r9[0x64]
80006d4c:	80 00       	ld.sh	r0,r0[0x0]
80006d4e:	69 a8       	ld.w	r8,r4[0x68]
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	71 84       	ld.w	r4,r8[0x60]

80006d54 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006d54:	d4 21       	pushm	r4-r7,lr
80006d56:	18 97       	mov	r7,r12
80006d58:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006d5a:	58 0c       	cp.w	r12,0
80006d5c:	c2 f0       	breq	80006dba <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006d5e:	34 cc       	mov	r12,76
80006d60:	f0 1f 00 17 	mcall	80006dbc <xQueueCreate+0x68>
80006d64:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006d66:	c2 a0       	breq	80006dba <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006d68:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006d6c:	e8 cc ff ff 	sub	r12,r4,-1
80006d70:	f0 1f 00 13 	mcall	80006dbc <xQueueCreate+0x68>
80006d74:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006d76:	c1 e0       	breq	80006db2 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006d78:	f8 04 00 04 	add	r4,r12,r4
80006d7c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006d7e:	30 08       	mov	r8,0
80006d80:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006d82:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006d84:	ee c8 00 01 	sub	r8,r7,1
80006d88:	ad 38       	mul	r8,r6
80006d8a:	10 0c       	add	r12,r8
80006d8c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006d8e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006d90:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006d94:	3f f8       	mov	r8,-1
80006d96:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006d9a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006d9e:	ea cc ff f0 	sub	r12,r5,-16
80006da2:	f0 1f 00 08 	mcall	80006dc0 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006da6:	ea cc ff dc 	sub	r12,r5,-36
80006daa:	f0 1f 00 06 	mcall	80006dc0 <xQueueCreate+0x6c>
80006dae:	0a 9c       	mov	r12,r5
80006db0:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006db2:	0a 9c       	mov	r12,r5
80006db4:	f0 1f 00 04 	mcall	80006dc4 <xQueueCreate+0x70>
80006db8:	d8 2a       	popm	r4-r7,pc,r12=0
80006dba:	d8 2a       	popm	r4-r7,pc,r12=0
80006dbc:	80 00       	ld.sh	r0,r0[0x0]
80006dbe:	69 00       	ld.w	r0,r4[0x40]
80006dc0:	80 00       	ld.sh	r0,r0[0x0]
80006dc2:	65 70       	ld.w	r0,r2[0x5c]
80006dc4:	80 00       	ld.sh	r0,r0[0x0]
80006dc6:	68 d8       	ld.w	r8,r4[0x34]

80006dc8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006dc8:	48 38       	lddpc	r8,80006dd4 <vTaskSuspendAll+0xc>
80006dca:	70 09       	ld.w	r9,r8[0x0]
80006dcc:	2f f9       	sub	r9,-1
80006dce:	91 09       	st.w	r8[0x0],r9
}
80006dd0:	5e fc       	retal	r12
80006dd2:	00 00       	add	r0,r0
80006dd4:	00 00       	add	r0,r0
80006dd6:	0d 38       	ld.ub	r8,r6++

80006dd8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006dd8:	49 a8       	lddpc	r8,80006e40 <vTaskSwitchContext+0x68>
80006dda:	70 08       	ld.w	r8,r8[0x0]
80006ddc:	58 08       	cp.w	r8,0
80006dde:	c0 b1       	brne	80006df4 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006de0:	49 98       	lddpc	r8,80006e44 <vTaskSwitchContext+0x6c>
80006de2:	70 08       	ld.w	r8,r8[0x0]
80006de4:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006de8:	49 89       	lddpc	r9,80006e48 <vTaskSwitchContext+0x70>
80006dea:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006dee:	58 08       	cp.w	r8,0
80006df0:	c0 60       	breq	80006dfc <vTaskSwitchContext+0x24>
80006df2:	c1 18       	rjmp	80006e14 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006df4:	30 19       	mov	r9,1
80006df6:	49 68       	lddpc	r8,80006e4c <vTaskSwitchContext+0x74>
80006df8:	91 09       	st.w	r8[0x0],r9
80006dfa:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006dfc:	49 28       	lddpc	r8,80006e44 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006dfe:	49 3a       	lddpc	r10,80006e48 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006e00:	70 09       	ld.w	r9,r8[0x0]
80006e02:	20 19       	sub	r9,1
80006e04:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006e06:	70 09       	ld.w	r9,r8[0x0]
80006e08:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006e0c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006e10:	58 09       	cp.w	r9,0
80006e12:	cf 70       	breq	80006e00 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006e14:	48 c8       	lddpc	r8,80006e44 <vTaskSwitchContext+0x6c>
80006e16:	70 08       	ld.w	r8,r8[0x0]
80006e18:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006e1c:	48 b9       	lddpc	r9,80006e48 <vTaskSwitchContext+0x70>
80006e1e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006e22:	70 19       	ld.w	r9,r8[0x4]
80006e24:	72 19       	ld.w	r9,r9[0x4]
80006e26:	91 19       	st.w	r8[0x4],r9
80006e28:	f0 ca ff f8 	sub	r10,r8,-8
80006e2c:	14 39       	cp.w	r9,r10
80006e2e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006e32:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006e36:	70 18       	ld.w	r8,r8[0x4]
80006e38:	70 39       	ld.w	r9,r8[0xc]
80006e3a:	48 68       	lddpc	r8,80006e50 <vTaskSwitchContext+0x78>
80006e3c:	91 09       	st.w	r8[0x0],r9
80006e3e:	5e fc       	retal	r12
80006e40:	00 00       	add	r0,r0
80006e42:	0d 38       	ld.ub	r8,r6++
80006e44:	00 00       	add	r0,r0
80006e46:	0d 70       	ld.ub	r0,--r6
80006e48:	00 00       	add	r0,r0
80006e4a:	0c 54       	eor	r4,r6
80006e4c:	00 00       	add	r0,r0
80006e4e:	0d 58       	ld.sh	r8,--r6
80006e50:	00 00       	add	r0,r0
80006e52:	0d 08       	ld.w	r8,r6++

80006e54 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006e54:	48 48       	lddpc	r8,80006e64 <vTaskSetTimeOutState+0x10>
80006e56:	70 08       	ld.w	r8,r8[0x0]
80006e58:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006e5a:	48 48       	lddpc	r8,80006e68 <vTaskSetTimeOutState+0x14>
80006e5c:	70 08       	ld.w	r8,r8[0x0]
80006e5e:	99 18       	st.w	r12[0x4],r8
}
80006e60:	5e fc       	retal	r12
80006e62:	00 00       	add	r0,r0
80006e64:	00 00       	add	r0,r0
80006e66:	0c 4c       	or	r12,r6
80006e68:	00 00       	add	r0,r0
80006e6a:	0d 34       	ld.ub	r4,r6++

80006e6c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006e6c:	30 19       	mov	r9,1
80006e6e:	48 28       	lddpc	r8,80006e74 <vTaskMissedYield+0x8>
80006e70:	91 09       	st.w	r8[0x0],r9
}
80006e72:	5e fc       	retal	r12
80006e74:	00 00       	add	r0,r0
80006e76:	0d 58       	ld.sh	r8,--r6

80006e78 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006e78:	48 28       	lddpc	r8,80006e80 <xTaskGetCurrentTaskHandle+0x8>
80006e7a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006e7c:	5e fc       	retal	r12
80006e7e:	00 00       	add	r0,r0
80006e80:	00 00       	add	r0,r0
80006e82:	0d 08       	ld.w	r8,r6++

80006e84 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006e84:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006e88:	58 0c       	cp.w	r12,0
80006e8a:	c1 f0       	breq	80006ec8 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006e8c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006e8e:	78 b9       	ld.w	r9,r12[0x2c]
80006e90:	79 18       	ld.w	r8,r12[0x44]
80006e92:	10 39       	cp.w	r9,r8
80006e94:	c1 a0       	breq	80006ec8 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006e96:	f8 c6 ff fc 	sub	r6,r12,-4
80006e9a:	0c 9c       	mov	r12,r6
80006e9c:	f0 1f 00 0c 	mcall	80006ecc <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006ea0:	6f 1c       	ld.w	r12,r7[0x44]
80006ea2:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006ea4:	f8 08 11 08 	rsub	r8,r12,8
80006ea8:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006eaa:	48 a8       	lddpc	r8,80006ed0 <vTaskPriorityDisinherit+0x4c>
80006eac:	70 08       	ld.w	r8,r8[0x0]
80006eae:	10 3c       	cp.w	r12,r8
80006eb0:	e0 88 00 04 	brls	80006eb8 <vTaskPriorityDisinherit+0x34>
80006eb4:	48 78       	lddpc	r8,80006ed0 <vTaskPriorityDisinherit+0x4c>
80006eb6:	91 0c       	st.w	r8[0x0],r12
80006eb8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006ebc:	0c 9b       	mov	r11,r6
80006ebe:	48 68       	lddpc	r8,80006ed4 <vTaskPriorityDisinherit+0x50>
80006ec0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006ec4:	f0 1f 00 05 	mcall	80006ed8 <vTaskPriorityDisinherit+0x54>
80006ec8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ecc:	80 00       	ld.sh	r0,r0[0x0]
80006ece:	65 da       	ld.w	r10,r2[0x74]
80006ed0:	00 00       	add	r0,r0
80006ed2:	0d 70       	ld.ub	r0,--r6
80006ed4:	00 00       	add	r0,r0
80006ed6:	0c 54       	eor	r4,r6
80006ed8:	80 00       	ld.sh	r0,r0[0x0]
80006eda:	65 8a       	ld.w	r10,r2[0x60]

80006edc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006edc:	eb cd 40 c0 	pushm	r6-r7,lr
80006ee0:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006ee2:	49 b8       	lddpc	r8,80006f4c <vTaskPriorityInherit+0x70>
80006ee4:	70 08       	ld.w	r8,r8[0x0]
80006ee6:	78 b9       	ld.w	r9,r12[0x2c]
80006ee8:	70 b8       	ld.w	r8,r8[0x2c]
80006eea:	10 39       	cp.w	r9,r8
80006eec:	c2 d2       	brcc	80006f46 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006eee:	49 88       	lddpc	r8,80006f4c <vTaskPriorityInherit+0x70>
80006ef0:	70 08       	ld.w	r8,r8[0x0]
80006ef2:	70 b8       	ld.w	r8,r8[0x2c]
80006ef4:	f0 08 11 08 	rsub	r8,r8,8
80006ef8:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006efa:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006efe:	49 59       	lddpc	r9,80006f50 <vTaskPriorityInherit+0x74>
80006f00:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006f04:	78 59       	ld.w	r9,r12[0x14]
80006f06:	10 39       	cp.w	r9,r8
80006f08:	c1 b1       	brne	80006f3e <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006f0a:	f8 c6 ff fc 	sub	r6,r12,-4
80006f0e:	0c 9c       	mov	r12,r6
80006f10:	f0 1f 00 11 	mcall	80006f54 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006f14:	48 e8       	lddpc	r8,80006f4c <vTaskPriorityInherit+0x70>
80006f16:	70 08       	ld.w	r8,r8[0x0]
80006f18:	70 bc       	ld.w	r12,r8[0x2c]
80006f1a:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006f1c:	48 f8       	lddpc	r8,80006f58 <vTaskPriorityInherit+0x7c>
80006f1e:	70 08       	ld.w	r8,r8[0x0]
80006f20:	10 3c       	cp.w	r12,r8
80006f22:	e0 88 00 04 	brls	80006f2a <vTaskPriorityInherit+0x4e>
80006f26:	48 d8       	lddpc	r8,80006f58 <vTaskPriorityInherit+0x7c>
80006f28:	91 0c       	st.w	r8[0x0],r12
80006f2a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006f2e:	0c 9b       	mov	r11,r6
80006f30:	48 88       	lddpc	r8,80006f50 <vTaskPriorityInherit+0x74>
80006f32:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006f36:	f0 1f 00 0a 	mcall	80006f5c <vTaskPriorityInherit+0x80>
80006f3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006f3e:	48 48       	lddpc	r8,80006f4c <vTaskPriorityInherit+0x70>
80006f40:	70 08       	ld.w	r8,r8[0x0]
80006f42:	70 b8       	ld.w	r8,r8[0x2c]
80006f44:	99 b8       	st.w	r12[0x2c],r8
80006f46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006f4a:	00 00       	add	r0,r0
80006f4c:	00 00       	add	r0,r0
80006f4e:	0d 08       	ld.w	r8,r6++
80006f50:	00 00       	add	r0,r0
80006f52:	0c 54       	eor	r4,r6
80006f54:	80 00       	ld.sh	r0,r0[0x0]
80006f56:	65 da       	ld.w	r10,r2[0x74]
80006f58:	00 00       	add	r0,r0
80006f5a:	0d 70       	ld.ub	r0,--r6
80006f5c:	80 00       	ld.sh	r0,r0[0x0]
80006f5e:	65 8a       	ld.w	r10,r2[0x60]

80006f60 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006f60:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006f64:	78 38       	ld.w	r8,r12[0xc]
80006f66:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006f68:	ee c6 ff e8 	sub	r6,r7,-24
80006f6c:	0c 9c       	mov	r12,r6
80006f6e:	f0 1f 00 15 	mcall	80006fc0 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006f72:	49 58       	lddpc	r8,80006fc4 <xTaskRemoveFromEventList+0x64>
80006f74:	70 08       	ld.w	r8,r8[0x0]
80006f76:	58 08       	cp.w	r8,0
80006f78:	c1 71       	brne	80006fa6 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006f7a:	ee c6 ff fc 	sub	r6,r7,-4
80006f7e:	0c 9c       	mov	r12,r6
80006f80:	f0 1f 00 10 	mcall	80006fc0 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006f84:	6e bc       	ld.w	r12,r7[0x2c]
80006f86:	49 18       	lddpc	r8,80006fc8 <xTaskRemoveFromEventList+0x68>
80006f88:	70 08       	ld.w	r8,r8[0x0]
80006f8a:	10 3c       	cp.w	r12,r8
80006f8c:	e0 88 00 04 	brls	80006f94 <xTaskRemoveFromEventList+0x34>
80006f90:	48 e8       	lddpc	r8,80006fc8 <xTaskRemoveFromEventList+0x68>
80006f92:	91 0c       	st.w	r8[0x0],r12
80006f94:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006f98:	0c 9b       	mov	r11,r6
80006f9a:	48 d8       	lddpc	r8,80006fcc <xTaskRemoveFromEventList+0x6c>
80006f9c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006fa0:	f0 1f 00 0c 	mcall	80006fd0 <xTaskRemoveFromEventList+0x70>
80006fa4:	c0 58       	rjmp	80006fae <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006fa6:	0c 9b       	mov	r11,r6
80006fa8:	48 bc       	lddpc	r12,80006fd4 <xTaskRemoveFromEventList+0x74>
80006faa:	f0 1f 00 0a 	mcall	80006fd0 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006fae:	48 b8       	lddpc	r8,80006fd8 <xTaskRemoveFromEventList+0x78>
80006fb0:	70 08       	ld.w	r8,r8[0x0]
80006fb2:	6e b9       	ld.w	r9,r7[0x2c]
80006fb4:	70 b8       	ld.w	r8,r8[0x2c]
80006fb6:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006fb8:	5f 2c       	srhs	r12
80006fba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006fbe:	00 00       	add	r0,r0
80006fc0:	80 00       	ld.sh	r0,r0[0x0]
80006fc2:	65 da       	ld.w	r10,r2[0x74]
80006fc4:	00 00       	add	r0,r0
80006fc6:	0d 38       	ld.ub	r8,r6++
80006fc8:	00 00       	add	r0,r0
80006fca:	0d 70       	ld.ub	r0,--r6
80006fcc:	00 00       	add	r0,r0
80006fce:	0c 54       	eor	r4,r6
80006fd0:	80 00       	ld.sh	r0,r0[0x0]
80006fd2:	65 8a       	ld.w	r10,r2[0x60]
80006fd4:	00 00       	add	r0,r0
80006fd6:	0d 0c       	ld.w	r12,r6++
80006fd8:	00 00       	add	r0,r0
80006fda:	0d 08       	ld.w	r8,r6++

80006fdc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006fdc:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006fe0:	4b 98       	lddpc	r8,800070c4 <vTaskIncrementTick+0xe8>
80006fe2:	70 08       	ld.w	r8,r8[0x0]
80006fe4:	58 08       	cp.w	r8,0
80006fe6:	c6 91       	brne	800070b8 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006fe8:	4b 88       	lddpc	r8,800070c8 <vTaskIncrementTick+0xec>
80006fea:	70 09       	ld.w	r9,r8[0x0]
80006fec:	2f f9       	sub	r9,-1
80006fee:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006ff0:	70 08       	ld.w	r8,r8[0x0]
80006ff2:	58 08       	cp.w	r8,0
80006ff4:	c1 a1       	brne	80007028 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006ff6:	4b 68       	lddpc	r8,800070cc <vTaskIncrementTick+0xf0>
80006ff8:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006ffa:	4b 69       	lddpc	r9,800070d0 <vTaskIncrementTick+0xf4>
80006ffc:	72 0b       	ld.w	r11,r9[0x0]
80006ffe:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80007000:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80007002:	4b 59       	lddpc	r9,800070d4 <vTaskIncrementTick+0xf8>
80007004:	72 0a       	ld.w	r10,r9[0x0]
80007006:	2f fa       	sub	r10,-1
80007008:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000700a:	70 08       	ld.w	r8,r8[0x0]
8000700c:	70 08       	ld.w	r8,r8[0x0]
8000700e:	58 08       	cp.w	r8,0
80007010:	c0 51       	brne	8000701a <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80007012:	3f f9       	mov	r9,-1
80007014:	4b 18       	lddpc	r8,800070d8 <vTaskIncrementTick+0xfc>
80007016:	91 09       	st.w	r8[0x0],r9
80007018:	c0 88       	rjmp	80007028 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000701a:	4a d8       	lddpc	r8,800070cc <vTaskIncrementTick+0xf0>
8000701c:	70 08       	ld.w	r8,r8[0x0]
8000701e:	70 38       	ld.w	r8,r8[0xc]
80007020:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80007022:	70 19       	ld.w	r9,r8[0x4]
80007024:	4a d8       	lddpc	r8,800070d8 <vTaskIncrementTick+0xfc>
80007026:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80007028:	4a 88       	lddpc	r8,800070c8 <vTaskIncrementTick+0xec>
8000702a:	70 09       	ld.w	r9,r8[0x0]
8000702c:	4a b8       	lddpc	r8,800070d8 <vTaskIncrementTick+0xfc>
8000702e:	70 08       	ld.w	r8,r8[0x0]
80007030:	10 39       	cp.w	r9,r8
80007032:	c4 73       	brcs	800070c0 <vTaskIncrementTick+0xe4>
80007034:	4a 68       	lddpc	r8,800070cc <vTaskIncrementTick+0xf0>
80007036:	70 08       	ld.w	r8,r8[0x0]
80007038:	70 08       	ld.w	r8,r8[0x0]
8000703a:	58 08       	cp.w	r8,0
8000703c:	c0 c0       	breq	80007054 <vTaskIncrementTick+0x78>
8000703e:	4a 48       	lddpc	r8,800070cc <vTaskIncrementTick+0xf0>
80007040:	70 08       	ld.w	r8,r8[0x0]
80007042:	70 38       	ld.w	r8,r8[0xc]
80007044:	70 37       	ld.w	r7,r8[0xc]
80007046:	6e 18       	ld.w	r8,r7[0x4]
80007048:	4a 09       	lddpc	r9,800070c8 <vTaskIncrementTick+0xec>
8000704a:	72 09       	ld.w	r9,r9[0x0]
8000704c:	12 38       	cp.w	r8,r9
8000704e:	e0 88 00 14 	brls	80007076 <vTaskIncrementTick+0x9a>
80007052:	c0 e8       	rjmp	8000706e <vTaskIncrementTick+0x92>
80007054:	3f f9       	mov	r9,-1
80007056:	4a 18       	lddpc	r8,800070d8 <vTaskIncrementTick+0xfc>
80007058:	91 09       	st.w	r8[0x0],r9
8000705a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000705e:	6a 08       	ld.w	r8,r5[0x0]
80007060:	70 38       	ld.w	r8,r8[0xc]
80007062:	70 37       	ld.w	r7,r8[0xc]
80007064:	6e 18       	ld.w	r8,r7[0x4]
80007066:	64 09       	ld.w	r9,r2[0x0]
80007068:	12 38       	cp.w	r8,r9
8000706a:	e0 88 00 0a 	brls	8000707e <vTaskIncrementTick+0xa2>
8000706e:	49 b9       	lddpc	r9,800070d8 <vTaskIncrementTick+0xfc>
80007070:	93 08       	st.w	r9[0x0],r8
80007072:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007076:	49 a4       	lddpc	r4,800070dc <vTaskIncrementTick+0x100>
80007078:	49 a3       	lddpc	r3,800070e0 <vTaskIncrementTick+0x104>
8000707a:	49 55       	lddpc	r5,800070cc <vTaskIncrementTick+0xf0>
8000707c:	49 32       	lddpc	r2,800070c8 <vTaskIncrementTick+0xec>
8000707e:	ee c6 ff fc 	sub	r6,r7,-4
80007082:	0c 9c       	mov	r12,r6
80007084:	f0 1f 00 18 	mcall	800070e4 <vTaskIncrementTick+0x108>
80007088:	6e a8       	ld.w	r8,r7[0x28]
8000708a:	58 08       	cp.w	r8,0
8000708c:	c0 50       	breq	80007096 <vTaskIncrementTick+0xba>
8000708e:	ee cc ff e8 	sub	r12,r7,-24
80007092:	f0 1f 00 15 	mcall	800070e4 <vTaskIncrementTick+0x108>
80007096:	6e bc       	ld.w	r12,r7[0x2c]
80007098:	68 08       	ld.w	r8,r4[0x0]
8000709a:	10 3c       	cp.w	r12,r8
8000709c:	e9 fc ba 00 	st.whi	r4[0x0],r12
800070a0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800070a4:	0c 9b       	mov	r11,r6
800070a6:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800070aa:	f0 1f 00 10 	mcall	800070e8 <vTaskIncrementTick+0x10c>
800070ae:	6a 08       	ld.w	r8,r5[0x0]
800070b0:	70 08       	ld.w	r8,r8[0x0]
800070b2:	58 08       	cp.w	r8,0
800070b4:	cd 51       	brne	8000705e <vTaskIncrementTick+0x82>
800070b6:	cc fb       	rjmp	80007054 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800070b8:	48 d8       	lddpc	r8,800070ec <vTaskIncrementTick+0x110>
800070ba:	70 09       	ld.w	r9,r8[0x0]
800070bc:	2f f9       	sub	r9,-1
800070be:	91 09       	st.w	r8[0x0],r9
800070c0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800070c4:	00 00       	add	r0,r0
800070c6:	0d 38       	ld.ub	r8,r6++
800070c8:	00 00       	add	r0,r0
800070ca:	0d 34       	ld.ub	r4,r6++
800070cc:	00 00       	add	r0,r0
800070ce:	0c 40       	or	r0,r6
800070d0:	00 00       	add	r0,r0
800070d2:	0c 50       	eor	r0,r6
800070d4:	00 00       	add	r0,r0
800070d6:	0c 4c       	or	r12,r6
800070d8:	00 00       	add	r0,r0
800070da:	05 40       	ld.w	r0,--r2
800070dc:	00 00       	add	r0,r0
800070de:	0d 70       	ld.ub	r0,--r6
800070e0:	00 00       	add	r0,r0
800070e2:	0c 54       	eor	r4,r6
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	65 da       	ld.w	r10,r2[0x74]
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	65 8a       	ld.w	r10,r2[0x60]
800070ec:	00 00       	add	r0,r0
800070ee:	0c 38       	cp.w	r8,r6

800070f0 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800070f0:	eb cd 40 c0 	pushm	r6-r7,lr
800070f4:	18 97       	mov	r7,r12
800070f6:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800070f8:	f0 1f 00 15 	mcall	8000714c <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800070fc:	6c 08       	ld.w	r8,r6[0x0]
800070fe:	5b f8       	cp.w	r8,-1
80007100:	c0 31       	brne	80007106 <xTaskCheckForTimeOut+0x16>
80007102:	30 07       	mov	r7,0
80007104:	c1 f8       	rjmp	80007142 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80007106:	49 39       	lddpc	r9,80007150 <xTaskCheckForTimeOut+0x60>
80007108:	72 09       	ld.w	r9,r9[0x0]
8000710a:	6e 0a       	ld.w	r10,r7[0x0]
8000710c:	12 3a       	cp.w	r10,r9
8000710e:	c0 70       	breq	8000711c <xTaskCheckForTimeOut+0x2c>
80007110:	49 19       	lddpc	r9,80007154 <xTaskCheckForTimeOut+0x64>
80007112:	72 09       	ld.w	r9,r9[0x0]
80007114:	6e 1a       	ld.w	r10,r7[0x4]
80007116:	12 3a       	cp.w	r10,r9
80007118:	e0 88 00 14 	brls	80007140 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000711c:	48 e9       	lddpc	r9,80007154 <xTaskCheckForTimeOut+0x64>
8000711e:	72 0a       	ld.w	r10,r9[0x0]
80007120:	6e 19       	ld.w	r9,r7[0x4]
80007122:	12 1a       	sub	r10,r9
80007124:	14 38       	cp.w	r8,r10
80007126:	e0 88 00 0d 	brls	80007140 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000712a:	48 ba       	lddpc	r10,80007154 <xTaskCheckForTimeOut+0x64>
8000712c:	74 0a       	ld.w	r10,r10[0x0]
8000712e:	14 19       	sub	r9,r10
80007130:	f2 08 00 08 	add	r8,r9,r8
80007134:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80007136:	0e 9c       	mov	r12,r7
80007138:	f0 1f 00 08 	mcall	80007158 <xTaskCheckForTimeOut+0x68>
8000713c:	30 07       	mov	r7,0
8000713e:	c0 28       	rjmp	80007142 <xTaskCheckForTimeOut+0x52>
80007140:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80007142:	f0 1f 00 07 	mcall	8000715c <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80007146:	0e 9c       	mov	r12,r7
80007148:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	66 94       	ld.w	r4,r3[0x24]
80007150:	00 00       	add	r0,r0
80007152:	0c 4c       	or	r12,r6
80007154:	00 00       	add	r0,r0
80007156:	0d 34       	ld.ub	r4,r6++
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	6e 54       	ld.w	r4,r7[0x14]
8000715c:	80 00       	ld.sh	r0,r0[0x0]
8000715e:	67 a0       	ld.w	r0,r3[0x68]

80007160 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80007160:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80007164:	f0 1f 00 05 	mcall	80007178 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80007168:	48 58       	lddpc	r8,8000717c <xTaskGetTickCount+0x1c>
8000716a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000716c:	f0 1f 00 05 	mcall	80007180 <xTaskGetTickCount+0x20>

	return xTicks;
}
80007170:	0e 9c       	mov	r12,r7
80007172:	e3 cd 80 80 	ldm	sp++,r7,pc
80007176:	00 00       	add	r0,r0
80007178:	80 00       	ld.sh	r0,r0[0x0]
8000717a:	66 94       	ld.w	r4,r3[0x24]
8000717c:	00 00       	add	r0,r0
8000717e:	0d 34       	ld.ub	r4,r6++
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	67 a0       	ld.w	r0,r3[0x68]

80007184 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80007184:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80007188:	f0 1f 00 2c 	mcall	80007238 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000718c:	4a c8       	lddpc	r8,8000723c <xTaskResumeAll+0xb8>
8000718e:	70 09       	ld.w	r9,r8[0x0]
80007190:	20 19       	sub	r9,1
80007192:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007194:	70 08       	ld.w	r8,r8[0x0]
80007196:	58 08       	cp.w	r8,0
80007198:	c4 91       	brne	8000722a <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000719a:	4a a8       	lddpc	r8,80007240 <xTaskResumeAll+0xbc>
8000719c:	70 08       	ld.w	r8,r8[0x0]
8000719e:	58 08       	cp.w	r8,0
800071a0:	c4 50       	breq	8000722a <xTaskResumeAll+0xa6>
800071a2:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800071a4:	4a 85       	lddpc	r5,80007244 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800071a6:	4a 93       	lddpc	r3,80007248 <xTaskResumeAll+0xc4>
800071a8:	4a 92       	lddpc	r2,8000724c <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800071aa:	4a a1       	lddpc	r1,80007250 <xTaskResumeAll+0xcc>
800071ac:	c1 e8       	rjmp	800071e8 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800071ae:	6a 38       	ld.w	r8,r5[0xc]
800071b0:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800071b2:	ee cc ff e8 	sub	r12,r7,-24
800071b6:	f0 1f 00 28 	mcall	80007254 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800071ba:	ee c6 ff fc 	sub	r6,r7,-4
800071be:	0c 9c       	mov	r12,r6
800071c0:	f0 1f 00 25 	mcall	80007254 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800071c4:	6e bc       	ld.w	r12,r7[0x2c]
800071c6:	66 08       	ld.w	r8,r3[0x0]
800071c8:	10 3c       	cp.w	r12,r8
800071ca:	e7 fc ba 00 	st.whi	r3[0x0],r12
800071ce:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800071d2:	0c 9b       	mov	r11,r6
800071d4:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800071d8:	f0 1f 00 20 	mcall	80007258 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800071dc:	62 08       	ld.w	r8,r1[0x0]
800071de:	6e b9       	ld.w	r9,r7[0x2c]
800071e0:	70 b8       	ld.w	r8,r8[0x2c]
800071e2:	10 39       	cp.w	r9,r8
800071e4:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800071e8:	6a 08       	ld.w	r8,r5[0x0]
800071ea:	58 08       	cp.w	r8,0
800071ec:	ce 11       	brne	800071ae <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800071ee:	49 c8       	lddpc	r8,8000725c <xTaskResumeAll+0xd8>
800071f0:	70 08       	ld.w	r8,r8[0x0]
800071f2:	58 08       	cp.w	r8,0
800071f4:	c0 f0       	breq	80007212 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800071f6:	49 a8       	lddpc	r8,8000725c <xTaskResumeAll+0xd8>
800071f8:	70 08       	ld.w	r8,r8[0x0]
800071fa:	58 08       	cp.w	r8,0
800071fc:	c1 10       	breq	8000721e <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800071fe:	49 87       	lddpc	r7,8000725c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80007200:	f0 1f 00 18 	mcall	80007260 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80007204:	6e 08       	ld.w	r8,r7[0x0]
80007206:	20 18       	sub	r8,1
80007208:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000720a:	6e 08       	ld.w	r8,r7[0x0]
8000720c:	58 08       	cp.w	r8,0
8000720e:	cf 91       	brne	80007200 <xTaskResumeAll+0x7c>
80007210:	c0 78       	rjmp	8000721e <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80007212:	58 14       	cp.w	r4,1
80007214:	c0 50       	breq	8000721e <xTaskResumeAll+0x9a>
80007216:	49 48       	lddpc	r8,80007264 <xTaskResumeAll+0xe0>
80007218:	70 08       	ld.w	r8,r8[0x0]
8000721a:	58 18       	cp.w	r8,1
8000721c:	c0 71       	brne	8000722a <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000721e:	30 09       	mov	r9,0
80007220:	49 18       	lddpc	r8,80007264 <xTaskResumeAll+0xe0>
80007222:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80007224:	d7 33       	scall
80007226:	30 17       	mov	r7,1
80007228:	c0 28       	rjmp	8000722c <xTaskResumeAll+0xa8>
8000722a:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000722c:	f0 1f 00 0f 	mcall	80007268 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80007230:	0e 9c       	mov	r12,r7
80007232:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80007236:	00 00       	add	r0,r0
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	66 94       	ld.w	r4,r3[0x24]
8000723c:	00 00       	add	r0,r0
8000723e:	0d 38       	ld.ub	r8,r6++
80007240:	00 00       	add	r0,r0
80007242:	0d 54       	ld.sh	r4,--r6
80007244:	00 00       	add	r0,r0
80007246:	0d 0c       	ld.w	r12,r6++
80007248:	00 00       	add	r0,r0
8000724a:	0d 70       	ld.ub	r0,--r6
8000724c:	00 00       	add	r0,r0
8000724e:	0c 54       	eor	r4,r6
80007250:	00 00       	add	r0,r0
80007252:	0d 08       	ld.w	r8,r6++
80007254:	80 00       	ld.sh	r0,r0[0x0]
80007256:	65 da       	ld.w	r10,r2[0x74]
80007258:	80 00       	ld.sh	r0,r0[0x0]
8000725a:	65 8a       	ld.w	r10,r2[0x60]
8000725c:	00 00       	add	r0,r0
8000725e:	0c 38       	cp.w	r8,r6
80007260:	80 00       	ld.sh	r0,r0[0x0]
80007262:	6f dc       	ld.w	r12,r7[0x74]
80007264:	00 00       	add	r0,r0
80007266:	0d 58       	ld.sh	r8,--r6
80007268:	80 00       	ld.sh	r0,r0[0x0]
8000726a:	67 a0       	ld.w	r0,r3[0x68]

8000726c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
8000726c:	eb cd 40 80 	pushm	r7,lr
80007270:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80007272:	49 08       	lddpc	r8,800072b0 <prvAddCurrentTaskToDelayedList+0x44>
80007274:	70 08       	ld.w	r8,r8[0x0]
80007276:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80007278:	48 f8       	lddpc	r8,800072b4 <prvAddCurrentTaskToDelayedList+0x48>
8000727a:	70 08       	ld.w	r8,r8[0x0]
8000727c:	10 3c       	cp.w	r12,r8
8000727e:	c0 a2       	brcc	80007292 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007280:	48 c8       	lddpc	r8,800072b0 <prvAddCurrentTaskToDelayedList+0x44>
80007282:	70 0b       	ld.w	r11,r8[0x0]
80007284:	48 d8       	lddpc	r8,800072b8 <prvAddCurrentTaskToDelayedList+0x4c>
80007286:	70 0c       	ld.w	r12,r8[0x0]
80007288:	2f cb       	sub	r11,-4
8000728a:	f0 1f 00 0d 	mcall	800072bc <prvAddCurrentTaskToDelayedList+0x50>
8000728e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007292:	48 88       	lddpc	r8,800072b0 <prvAddCurrentTaskToDelayedList+0x44>
80007294:	70 0b       	ld.w	r11,r8[0x0]
80007296:	48 b8       	lddpc	r8,800072c0 <prvAddCurrentTaskToDelayedList+0x54>
80007298:	70 0c       	ld.w	r12,r8[0x0]
8000729a:	2f cb       	sub	r11,-4
8000729c:	f0 1f 00 08 	mcall	800072bc <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800072a0:	48 98       	lddpc	r8,800072c4 <prvAddCurrentTaskToDelayedList+0x58>
800072a2:	70 08       	ld.w	r8,r8[0x0]
800072a4:	10 37       	cp.w	r7,r8
800072a6:	c0 32       	brcc	800072ac <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800072a8:	48 78       	lddpc	r8,800072c4 <prvAddCurrentTaskToDelayedList+0x58>
800072aa:	91 07       	st.w	r8[0x0],r7
800072ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800072b0:	00 00       	add	r0,r0
800072b2:	0d 08       	ld.w	r8,r6++
800072b4:	00 00       	add	r0,r0
800072b6:	0d 34       	ld.ub	r4,r6++
800072b8:	00 00       	add	r0,r0
800072ba:	0c 50       	eor	r0,r6
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	65 a6       	ld.w	r6,r2[0x68]
800072c0:	00 00       	add	r0,r0
800072c2:	0c 40       	or	r0,r6
800072c4:	00 00       	add	r0,r0
800072c6:	05 40       	ld.w	r0,--r2

800072c8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800072c8:	eb cd 40 c0 	pushm	r6-r7,lr
800072cc:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800072ce:	58 0c       	cp.w	r12,0
800072d0:	c1 10       	breq	800072f2 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800072d2:	f0 1f 00 0a 	mcall	800072f8 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800072d6:	48 a8       	lddpc	r8,800072fc <vTaskDelay+0x34>
800072d8:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800072da:	48 a8       	lddpc	r8,80007300 <vTaskDelay+0x38>
800072dc:	70 0c       	ld.w	r12,r8[0x0]
800072de:	2f cc       	sub	r12,-4
800072e0:	f0 1f 00 09 	mcall	80007304 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800072e4:	ee 06 00 0c 	add	r12,r7,r6
800072e8:	f0 1f 00 08 	mcall	80007308 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800072ec:	f0 1f 00 08 	mcall	8000730c <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800072f0:	c0 21       	brne	800072f4 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800072f2:	d7 33       	scall
800072f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800072f8:	80 00       	ld.sh	r0,r0[0x0]
800072fa:	6d c8       	ld.w	r8,r6[0x70]
800072fc:	00 00       	add	r0,r0
800072fe:	0d 34       	ld.ub	r4,r6++
80007300:	00 00       	add	r0,r0
80007302:	0d 08       	ld.w	r8,r6++
80007304:	80 00       	ld.sh	r0,r0[0x0]
80007306:	65 da       	ld.w	r10,r2[0x74]
80007308:	80 00       	ld.sh	r0,r0[0x0]
8000730a:	72 6c       	ld.w	r12,r9[0x18]
8000730c:	80 00       	ld.sh	r0,r0[0x0]
8000730e:	71 84       	ld.w	r4,r8[0x60]

80007310 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80007310:	eb cd 40 c0 	pushm	r6-r7,lr
80007314:	18 96       	mov	r6,r12
80007316:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007318:	f0 1f 00 18 	mcall	80007378 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000731c:	6c 08       	ld.w	r8,r6[0x0]
8000731e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80007320:	49 79       	lddpc	r9,8000737c <vTaskDelayUntil+0x6c>
80007322:	72 09       	ld.w	r9,r9[0x0]
80007324:	12 38       	cp.w	r8,r9
80007326:	e0 88 00 0c 	brls	8000733e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000732a:	0e 38       	cp.w	r8,r7
8000732c:	e0 88 00 22 	brls	80007370 <vTaskDelayUntil+0x60>
80007330:	49 38       	lddpc	r8,8000737c <vTaskDelayUntil+0x6c>
80007332:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007334:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80007336:	10 37       	cp.w	r7,r8
80007338:	e0 88 00 14 	brls	80007360 <vTaskDelayUntil+0x50>
8000733c:	c0 a8       	rjmp	80007350 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000733e:	0e 38       	cp.w	r8,r7
80007340:	e0 8b 00 16 	brhi	8000736c <vTaskDelayUntil+0x5c>
80007344:	48 e8       	lddpc	r8,8000737c <vTaskDelayUntil+0x6c>
80007346:	70 08       	ld.w	r8,r8[0x0]
80007348:	10 37       	cp.w	r7,r8
8000734a:	e0 8b 00 11 	brhi	8000736c <vTaskDelayUntil+0x5c>
8000734e:	c1 18       	rjmp	80007370 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007350:	48 c8       	lddpc	r8,80007380 <vTaskDelayUntil+0x70>
80007352:	70 0c       	ld.w	r12,r8[0x0]
80007354:	2f cc       	sub	r12,-4
80007356:	f0 1f 00 0c 	mcall	80007384 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000735a:	0e 9c       	mov	r12,r7
8000735c:	f0 1f 00 0b 	mcall	80007388 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007360:	f0 1f 00 0b 	mcall	8000738c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007364:	c0 81       	brne	80007374 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80007366:	d7 33       	scall
80007368:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000736c:	8d 07       	st.w	r6[0x0],r7
8000736e:	cf 1b       	rjmp	80007350 <vTaskDelayUntil+0x40>
80007370:	8d 07       	st.w	r6[0x0],r7
80007372:	cf 7b       	rjmp	80007360 <vTaskDelayUntil+0x50>
80007374:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	6d c8       	ld.w	r8,r6[0x70]
8000737c:	00 00       	add	r0,r0
8000737e:	0d 34       	ld.ub	r4,r6++
80007380:	00 00       	add	r0,r0
80007382:	0d 08       	ld.w	r8,r6++
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	65 da       	ld.w	r10,r2[0x74]
80007388:	80 00       	ld.sh	r0,r0[0x0]
8000738a:	72 6c       	ld.w	r12,r9[0x18]
8000738c:	80 00       	ld.sh	r0,r0[0x0]
8000738e:	71 84       	ld.w	r4,r8[0x60]

80007390 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80007390:	eb cd 40 c0 	pushm	r6-r7,lr
80007394:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80007396:	48 e7       	lddpc	r7,800073cc <vTaskPlaceOnEventList+0x3c>
80007398:	6e 0b       	ld.w	r11,r7[0x0]
8000739a:	2e 8b       	sub	r11,-24
8000739c:	f0 1f 00 0d 	mcall	800073d0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800073a0:	6e 0c       	ld.w	r12,r7[0x0]
800073a2:	2f cc       	sub	r12,-4
800073a4:	f0 1f 00 0c 	mcall	800073d4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800073a8:	5b f6       	cp.w	r6,-1
800073aa:	c0 81       	brne	800073ba <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800073ac:	6e 0b       	ld.w	r11,r7[0x0]
800073ae:	2f cb       	sub	r11,-4
800073b0:	48 ac       	lddpc	r12,800073d8 <vTaskPlaceOnEventList+0x48>
800073b2:	f0 1f 00 0b 	mcall	800073dc <vTaskPlaceOnEventList+0x4c>
800073b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800073ba:	48 a8       	lddpc	r8,800073e0 <vTaskPlaceOnEventList+0x50>
800073bc:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800073be:	ec 0c 00 0c 	add	r12,r6,r12
800073c2:	f0 1f 00 09 	mcall	800073e4 <vTaskPlaceOnEventList+0x54>
800073c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800073ca:	00 00       	add	r0,r0
800073cc:	00 00       	add	r0,r0
800073ce:	0d 08       	ld.w	r8,r6++
800073d0:	80 00       	ld.sh	r0,r0[0x0]
800073d2:	65 a6       	ld.w	r6,r2[0x68]
800073d4:	80 00       	ld.sh	r0,r0[0x0]
800073d6:	65 da       	ld.w	r10,r2[0x74]
800073d8:	00 00       	add	r0,r0
800073da:	0d 5c       	ld.sh	r12,--r6
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	65 8a       	ld.w	r10,r2[0x60]
800073e0:	00 00       	add	r0,r0
800073e2:	0d 34       	ld.ub	r4,r6++
800073e4:	80 00       	ld.sh	r0,r0[0x0]
800073e6:	72 6c       	ld.w	r12,r9[0x18]

800073e8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800073e8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800073ec:	49 67       	lddpc	r7,80007444 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800073ee:	49 74       	lddpc	r4,80007448 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800073f0:	49 73       	lddpc	r3,8000744c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800073f2:	49 85       	lddpc	r5,80007450 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800073f4:	6e 08       	ld.w	r8,r7[0x0]
800073f6:	58 08       	cp.w	r8,0
800073f8:	c1 e0       	breq	80007434 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800073fa:	f0 1f 00 17 	mcall	80007454 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800073fe:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80007400:	f0 1f 00 16 	mcall	80007458 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80007404:	58 06       	cp.w	r6,0
80007406:	c1 70       	breq	80007434 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007408:	f0 1f 00 15 	mcall	8000745c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000740c:	68 38       	ld.w	r8,r4[0xc]
8000740e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80007410:	ec cc ff fc 	sub	r12,r6,-4
80007414:	f0 1f 00 13 	mcall	80007460 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007418:	66 08       	ld.w	r8,r3[0x0]
8000741a:	20 18       	sub	r8,1
8000741c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000741e:	6e 08       	ld.w	r8,r7[0x0]
80007420:	20 18       	sub	r8,1
80007422:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80007424:	f0 1f 00 10 	mcall	80007464 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007428:	6c cc       	ld.w	r12,r6[0x30]
8000742a:	f0 1f 00 10 	mcall	80007468 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000742e:	0c 9c       	mov	r12,r6
80007430:	f0 1f 00 0e 	mcall	80007468 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80007434:	6a 08       	ld.w	r8,r5[0x0]
80007436:	58 18       	cp.w	r8,1
80007438:	e0 88 00 03 	brls	8000743e <prvIdleTask+0x56>
			{
				taskYIELD();
8000743c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000743e:	f0 1f 00 0c 	mcall	8000746c <prvIdleTask+0x84>
		}
		#endif
	}
80007442:	cd 9b       	rjmp	800073f4 <prvIdleTask+0xc>
80007444:	00 00       	add	r0,r0
80007446:	0c 48       	or	r8,r6
80007448:	00 00       	add	r0,r0
8000744a:	0c f4       	st.b	--r6,r4
8000744c:	00 00       	add	r0,r0
8000744e:	0d 54       	ld.sh	r4,--r6
80007450:	00 00       	add	r0,r0
80007452:	0c 54       	eor	r4,r6
80007454:	80 00       	ld.sh	r0,r0[0x0]
80007456:	6d c8       	ld.w	r8,r6[0x70]
80007458:	80 00       	ld.sh	r0,r0[0x0]
8000745a:	71 84       	ld.w	r4,r8[0x60]
8000745c:	80 00       	ld.sh	r0,r0[0x0]
8000745e:	66 94       	ld.w	r4,r3[0x24]
80007460:	80 00       	ld.sh	r0,r0[0x0]
80007462:	65 da       	ld.w	r10,r2[0x74]
80007464:	80 00       	ld.sh	r0,r0[0x0]
80007466:	67 a0       	ld.w	r0,r3[0x68]
80007468:	80 00       	ld.sh	r0,r0[0x0]
8000746a:	68 d8       	ld.w	r8,r4[0x34]
8000746c:	80 00       	ld.sh	r0,r0[0x0]
8000746e:	20 2c       	sub	r12,2

80007470 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007470:	d4 31       	pushm	r0-r7,lr
80007472:	20 1d       	sub	sp,4
80007474:	fa c4 ff d8 	sub	r4,sp,-40
80007478:	50 0c       	stdsp	sp[0x0],r12
8000747a:	16 91       	mov	r1,r11
8000747c:	14 97       	mov	r7,r10
8000747e:	12 90       	mov	r0,r9
80007480:	10 93       	mov	r3,r8
80007482:	68 02       	ld.w	r2,r4[0x0]
80007484:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80007486:	34 8c       	mov	r12,72
80007488:	f0 1f 00 5c 	mcall	800075f8 <xTaskGenericCreate+0x188>
8000748c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000748e:	c0 31       	brne	80007494 <xTaskGenericCreate+0x24>
80007490:	3f fc       	mov	r12,-1
80007492:	ca f8       	rjmp	800075f0 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007494:	58 06       	cp.w	r6,0
80007496:	e0 81 00 af 	brne	800075f4 <xTaskGenericCreate+0x184>
8000749a:	0e 9c       	mov	r12,r7
8000749c:	5c 7c       	castu.h	r12
8000749e:	a3 6c       	lsl	r12,0x2
800074a0:	f0 1f 00 56 	mcall	800075f8 <xTaskGenericCreate+0x188>
800074a4:	18 96       	mov	r6,r12
800074a6:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800074a8:	c0 61       	brne	800074b4 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800074aa:	0a 9c       	mov	r12,r5
800074ac:	f0 1f 00 54 	mcall	800075fc <xTaskGenericCreate+0x18c>
800074b0:	3f fc       	mov	r12,-1
800074b2:	c9 f8       	rjmp	800075f0 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800074b4:	5c 77       	castu.h	r7
800074b6:	ee 0a 15 02 	lsl	r10,r7,0x2
800074ba:	e0 6b 00 a5 	mov	r11,165
800074be:	0c 9c       	mov	r12,r6
800074c0:	f0 1f 00 50 	mcall	80007600 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800074c4:	ee c6 00 01 	sub	r6,r7,1
800074c8:	6a c8       	ld.w	r8,r5[0x30]
800074ca:	f0 06 00 26 	add	r6,r8,r6<<0x2
800074ce:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800074d2:	31 0a       	mov	r10,16
800074d4:	02 9b       	mov	r11,r1
800074d6:	ea cc ff cc 	sub	r12,r5,-52
800074da:	f0 1f 00 4b 	mcall	80007604 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800074de:	30 08       	mov	r8,0
800074e0:	eb 68 00 43 	st.b	r5[67],r8
800074e4:	58 73       	cp.w	r3,7
800074e6:	e6 07 17 80 	movls	r7,r3
800074ea:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800074ee:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800074f0:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800074f4:	ea c4 ff fc 	sub	r4,r5,-4
800074f8:	08 9c       	mov	r12,r4
800074fa:	f0 1f 00 44 	mcall	80007608 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800074fe:	ea cc ff e8 	sub	r12,r5,-24
80007502:	f0 1f 00 42 	mcall	80007608 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007506:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007508:	ee 07 11 08 	rsub	r7,r7,8
8000750c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000750e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007510:	00 9a       	mov	r10,r0
80007512:	40 0b       	lddsp	r11,sp[0x0]
80007514:	0c 9c       	mov	r12,r6
80007516:	f0 1f 00 3e 	mcall	8000760c <xTaskGenericCreate+0x19c>
8000751a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000751c:	58 02       	cp.w	r2,0
8000751e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007522:	f0 1f 00 3c 	mcall	80007610 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007526:	4b c8       	lddpc	r8,80007614 <xTaskGenericCreate+0x1a4>
80007528:	70 09       	ld.w	r9,r8[0x0]
8000752a:	2f f9       	sub	r9,-1
8000752c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000752e:	4b b8       	lddpc	r8,80007618 <xTaskGenericCreate+0x1a8>
80007530:	70 08       	ld.w	r8,r8[0x0]
80007532:	58 08       	cp.w	r8,0
80007534:	c2 61       	brne	80007580 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007536:	4b 98       	lddpc	r8,80007618 <xTaskGenericCreate+0x1a8>
80007538:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000753a:	4b 78       	lddpc	r8,80007614 <xTaskGenericCreate+0x1a4>
8000753c:	70 08       	ld.w	r8,r8[0x0]
8000753e:	58 18       	cp.w	r8,1
80007540:	c2 b1       	brne	80007596 <xTaskGenericCreate+0x126>
80007542:	4b 77       	lddpc	r7,8000761c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007544:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007548:	0e 9c       	mov	r12,r7
8000754a:	f0 1f 00 36 	mcall	80007620 <xTaskGenericCreate+0x1b0>
8000754e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007550:	0c 37       	cp.w	r7,r6
80007552:	cf b1       	brne	80007548 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007554:	4b 47       	lddpc	r7,80007624 <xTaskGenericCreate+0x1b4>
80007556:	0e 9c       	mov	r12,r7
80007558:	f0 1f 00 32 	mcall	80007620 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000755c:	4b 36       	lddpc	r6,80007628 <xTaskGenericCreate+0x1b8>
8000755e:	0c 9c       	mov	r12,r6
80007560:	f0 1f 00 30 	mcall	80007620 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007564:	4b 2c       	lddpc	r12,8000762c <xTaskGenericCreate+0x1bc>
80007566:	f0 1f 00 2f 	mcall	80007620 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000756a:	4b 2c       	lddpc	r12,80007630 <xTaskGenericCreate+0x1c0>
8000756c:	f0 1f 00 2d 	mcall	80007620 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007570:	4b 1c       	lddpc	r12,80007634 <xTaskGenericCreate+0x1c4>
80007572:	f0 1f 00 2c 	mcall	80007620 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80007576:	4b 18       	lddpc	r8,80007638 <xTaskGenericCreate+0x1c8>
80007578:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000757a:	4b 18       	lddpc	r8,8000763c <xTaskGenericCreate+0x1cc>
8000757c:	91 06       	st.w	r8[0x0],r6
8000757e:	c0 c8       	rjmp	80007596 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007580:	4b 08       	lddpc	r8,80007640 <xTaskGenericCreate+0x1d0>
80007582:	70 08       	ld.w	r8,r8[0x0]
80007584:	58 08       	cp.w	r8,0
80007586:	c0 81       	brne	80007596 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007588:	4a 48       	lddpc	r8,80007618 <xTaskGenericCreate+0x1a8>
8000758a:	70 08       	ld.w	r8,r8[0x0]
8000758c:	70 b8       	ld.w	r8,r8[0x2c]
8000758e:	10 33       	cp.w	r3,r8
80007590:	c0 33       	brcs	80007596 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80007592:	4a 28       	lddpc	r8,80007618 <xTaskGenericCreate+0x1a8>
80007594:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007596:	6a b8       	ld.w	r8,r5[0x2c]
80007598:	4a b9       	lddpc	r9,80007644 <xTaskGenericCreate+0x1d4>
8000759a:	72 09       	ld.w	r9,r9[0x0]
8000759c:	12 38       	cp.w	r8,r9
8000759e:	e0 88 00 04 	brls	800075a6 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800075a2:	4a 99       	lddpc	r9,80007644 <xTaskGenericCreate+0x1d4>
800075a4:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800075a6:	4a 98       	lddpc	r8,80007648 <xTaskGenericCreate+0x1d8>
800075a8:	70 09       	ld.w	r9,r8[0x0]
800075aa:	2f f9       	sub	r9,-1
800075ac:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800075ae:	6a b8       	ld.w	r8,r5[0x2c]
800075b0:	4a 79       	lddpc	r9,8000764c <xTaskGenericCreate+0x1dc>
800075b2:	72 09       	ld.w	r9,r9[0x0]
800075b4:	12 38       	cp.w	r8,r9
800075b6:	e0 88 00 04 	brls	800075be <xTaskGenericCreate+0x14e>
800075ba:	4a 59       	lddpc	r9,8000764c <xTaskGenericCreate+0x1dc>
800075bc:	93 08       	st.w	r9[0x0],r8
800075be:	6a bc       	ld.w	r12,r5[0x2c]
800075c0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800075c4:	08 9b       	mov	r11,r4
800075c6:	49 68       	lddpc	r8,8000761c <xTaskGenericCreate+0x1ac>
800075c8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800075cc:	f0 1f 00 21 	mcall	80007650 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800075d0:	f0 1f 00 21 	mcall	80007654 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800075d4:	49 b8       	lddpc	r8,80007640 <xTaskGenericCreate+0x1d0>
800075d6:	70 08       	ld.w	r8,r8[0x0]
800075d8:	58 08       	cp.w	r8,0
800075da:	c0 a0       	breq	800075ee <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800075dc:	48 f8       	lddpc	r8,80007618 <xTaskGenericCreate+0x1a8>
800075de:	70 08       	ld.w	r8,r8[0x0]
800075e0:	70 b8       	ld.w	r8,r8[0x2c]
800075e2:	10 33       	cp.w	r3,r8
800075e4:	e0 88 00 05 	brls	800075ee <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800075e8:	d7 33       	scall
800075ea:	30 1c       	mov	r12,1
800075ec:	c0 28       	rjmp	800075f0 <xTaskGenericCreate+0x180>
800075ee:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800075f0:	2f fd       	sub	sp,-4
800075f2:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800075f4:	99 c6       	st.w	r12[0x30],r6
800075f6:	c5 fb       	rjmp	800074b4 <xTaskGenericCreate+0x44>
800075f8:	80 00       	ld.sh	r0,r0[0x0]
800075fa:	69 00       	ld.w	r0,r4[0x40]
800075fc:	80 00       	ld.sh	r0,r0[0x0]
800075fe:	68 d8       	ld.w	r8,r4[0x34]
80007600:	80 00       	ld.sh	r0,r0[0x0]
80007602:	81 f8       	st.w	r0[0x3c],r8
80007604:	80 00       	ld.sh	r0,r0[0x0]
80007606:	85 24       	st.w	r2[0x8],r4
80007608:	80 00       	ld.sh	r0,r0[0x0]
8000760a:	65 84       	ld.w	r4,r2[0x60]
8000760c:	80 00       	ld.sh	r0,r0[0x0]
8000760e:	66 00       	ld.w	r0,r3[0x0]
80007610:	80 00       	ld.sh	r0,r0[0x0]
80007612:	66 94       	ld.w	r4,r3[0x24]
80007614:	00 00       	add	r0,r0
80007616:	0d 54       	ld.sh	r4,--r6
80007618:	00 00       	add	r0,r0
8000761a:	0d 08       	ld.w	r8,r6++
8000761c:	00 00       	add	r0,r0
8000761e:	0c 54       	eor	r4,r6
80007620:	80 00       	ld.sh	r0,r0[0x0]
80007622:	65 70       	ld.w	r0,r2[0x5c]
80007624:	00 00       	add	r0,r0
80007626:	0d 20       	ld.uh	r0,r6++
80007628:	00 00       	add	r0,r0
8000762a:	0d 3c       	ld.ub	r12,r6++
8000762c:	00 00       	add	r0,r0
8000762e:	0d 0c       	ld.w	r12,r6++
80007630:	00 00       	add	r0,r0
80007632:	0c f4       	st.b	--r6,r4
80007634:	00 00       	add	r0,r0
80007636:	0d 5c       	ld.sh	r12,--r6
80007638:	00 00       	add	r0,r0
8000763a:	0c 40       	or	r0,r6
8000763c:	00 00       	add	r0,r0
8000763e:	0c 50       	eor	r0,r6
80007640:	00 00       	add	r0,r0
80007642:	0c 44       	or	r4,r6
80007644:	00 00       	add	r0,r0
80007646:	0c 3c       	cp.w	r12,r6
80007648:	00 00       	add	r0,r0
8000764a:	0d 50       	ld.sh	r0,--r6
8000764c:	00 00       	add	r0,r0
8000764e:	0d 70       	ld.ub	r0,--r6
80007650:	80 00       	ld.sh	r0,r0[0x0]
80007652:	65 8a       	ld.w	r10,r2[0x60]
80007654:	80 00       	ld.sh	r0,r0[0x0]
80007656:	67 a0       	ld.w	r0,r3[0x68]

80007658 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007658:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000765a:	30 09       	mov	r9,0
8000765c:	1a d9       	st.w	--sp,r9
8000765e:	1a d9       	st.w	--sp,r9
80007660:	1a d9       	st.w	--sp,r9
80007662:	12 98       	mov	r8,r9
80007664:	e0 6a 01 00 	mov	r10,256
80007668:	48 9b       	lddpc	r11,8000768c <vTaskStartScheduler+0x34>
8000766a:	48 ac       	lddpc	r12,80007690 <vTaskStartScheduler+0x38>
8000766c:	f0 1f 00 0a 	mcall	80007694 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007670:	2f dd       	sub	sp,-12
80007672:	58 1c       	cp.w	r12,1
80007674:	c0 a1       	brne	80007688 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007676:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007678:	30 19       	mov	r9,1
8000767a:	48 88       	lddpc	r8,80007698 <vTaskStartScheduler+0x40>
8000767c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000767e:	30 09       	mov	r9,0
80007680:	48 78       	lddpc	r8,8000769c <vTaskStartScheduler+0x44>
80007682:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007684:	f0 1f 00 07 	mcall	800076a0 <vTaskStartScheduler+0x48>
80007688:	d8 02       	popm	pc
8000768a:	00 00       	add	r0,r0
8000768c:	80 00       	ld.sh	r0,r0[0x0]
8000768e:	e4 20 80 00 	sub	r0,294912
80007692:	73 e8       	ld.w	r8,r9[0x78]
80007694:	80 00       	ld.sh	r0,r0[0x0]
80007696:	74 70       	ld.w	r0,r10[0x1c]
80007698:	00 00       	add	r0,r0
8000769a:	0c 44       	or	r4,r6
8000769c:	00 00       	add	r0,r0
8000769e:	0d 34       	ld.ub	r4,r6++
800076a0:	80 00       	ld.sh	r0,r0[0x0]
800076a2:	66 a4       	ld.w	r4,r3[0x28]

800076a4 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800076a4:	16 cc       	st.b	r11++,r12
	return str;
}
800076a6:	5e fb       	retal	r11

800076a8 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800076a8:	eb cd 40 c0 	pushm	r6-r7,lr
800076ac:	20 3d       	sub	sp,12
800076ae:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800076b0:	30 06       	mov	r6,0
800076b2:	30 07       	mov	r7,0
800076b4:	fa e7 00 00 	st.d	sp[0],r6
800076b8:	30 0c       	mov	r12,0
800076ba:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800076bc:	58 08       	cp.w	r8,0
800076be:	c1 30       	breq	800076e4 <PrintHex+0x3c>
800076c0:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800076c2:	1a 9c       	mov	r12,sp
800076c4:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800076c8:	58 9e       	cp.w	lr,9
800076ca:	e0 8a 00 04 	brle	800076d2 <PrintHex+0x2a>
800076ce:	2c 9e       	sub	lr,-55
800076d0:	c0 48       	rjmp	800076d8 <PrintHex+0x30>
800076d2:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800076d6:	2d 0e       	sub	lr,-48
800076d8:	f8 09 0b 0e 	st.b	r12[r9],lr
800076dc:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800076de:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800076e0:	cf 21       	brne	800076c4 <PrintHex+0x1c>
800076e2:	c0 48       	rjmp	800076ea <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800076e4:	33 08       	mov	r8,48
800076e6:	ba 88       	st.b	sp[0x0],r8
800076e8:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800076ea:	f6 09 01 08 	sub	r8,r11,r9
800076ee:	58 08       	cp.w	r8,0
800076f0:	e0 8a 00 13 	brle	80007716 <PrintHex+0x6e>
	{
		char num = len - cnt;
800076f4:	12 1b       	sub	r11,r9
800076f6:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800076fa:	18 9e       	mov	lr,r12
800076fc:	58 0c       	cp.w	r12,0
800076fe:	e0 8a 00 0c 	brle	80007716 <PrintHex+0x6e>
80007702:	1a 9b       	mov	r11,sp
80007704:	12 0b       	add	r11,r9
80007706:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007708:	33 07       	mov	r7,48
8000770a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000770c:	2f f8       	sub	r8,-1
8000770e:	1c 38       	cp.w	r8,lr
80007710:	cf d5       	brlt	8000770a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007712:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007716:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000771a:	f0 cb ff ff 	sub	r11,r8,-1
8000771e:	58 0b       	cp.w	r11,0
80007720:	e0 8a 00 19 	brle	80007752 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007724:	fa cb ff f4 	sub	r11,sp,-12
80007728:	f6 09 00 09 	add	r9,r11,r9
8000772c:	37 8b       	mov	r11,120
8000772e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007732:	fa c9 ff f4 	sub	r9,sp,-12
80007736:	10 09       	add	r9,r8
80007738:	33 0b       	mov	r11,48
8000773a:	f3 6b ff f4 	st.b	r9[-12],r11
8000773e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007742:	fa ce 00 01 	sub	lr,sp,1
80007746:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007748:	11 8b       	ld.ub	r11,r8[0x0]
8000774a:	12 cb       	st.b	r9++,r11
8000774c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000774e:	1c 38       	cp.w	r8,lr
80007750:	cf c1       	brne	80007748 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007752:	14 9c       	mov	r12,r10
80007754:	2f dd       	sub	sp,-12
80007756:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000775a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000775a:	d4 21       	pushm	r4-r7,lr
8000775c:	20 3d       	sub	sp,12
8000775e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007760:	30 06       	mov	r6,0
80007762:	30 07       	mov	r7,0
80007764:	fa e7 00 00 	st.d	sp[0],r6
80007768:	30 0c       	mov	r12,0
8000776a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
8000776c:	58 08       	cp.w	r8,0
8000776e:	c0 35       	brlt	80007774 <PrintDec+0x1a>
80007770:	14 97       	mov	r7,r10
80007772:	c0 58       	rjmp	8000777c <PrintDec+0x22>
	{
		*p++ = '-';
80007774:	14 97       	mov	r7,r10
80007776:	32 d9       	mov	r9,45
80007778:	0e c9       	st.b	r7++,r9
		i = -i;
8000777a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000777c:	58 08       	cp.w	r8,0
8000777e:	c0 51       	brne	80007788 <PrintDec+0x2e>
80007780:	33 08       	mov	r8,48
80007782:	ba 88       	st.b	sp[0x0],r8
80007784:	30 1e       	mov	lr,1
80007786:	c2 f8       	rjmp	800077e4 <PrintDec+0x8a>
	
	int ten = i%10;
80007788:	e0 65 66 67 	mov	r5,26215
8000778c:	ea 15 66 66 	orh	r5,0x6666
80007790:	f0 05 04 44 	muls.d	r4,r8,r5
80007794:	ea 0c 14 02 	asr	r12,r5,0x2
80007798:	f0 09 14 1f 	asr	r9,r8,0x1f
8000779c:	f8 09 01 09 	sub	r9,r12,r9
800077a0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800077a4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800077a8:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800077aa:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800077ac:	e0 66 66 67 	mov	r6,26215
800077b0:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800077b4:	2d 09       	sub	r9,-48
800077b6:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800077ba:	2f fe       	sub	lr,-1
		i /= 10;
800077bc:	f0 06 04 44 	muls.d	r4,r8,r6
800077c0:	ea 09 14 02 	asr	r9,r5,0x2
800077c4:	bf 58       	asr	r8,0x1f
800077c6:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800077ca:	f0 06 04 44 	muls.d	r4,r8,r6
800077ce:	ea 09 14 02 	asr	r9,r5,0x2
800077d2:	f0 05 14 1f 	asr	r5,r8,0x1f
800077d6:	0a 19       	sub	r9,r5
800077d8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800077dc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800077e0:	58 08       	cp.w	r8,0
800077e2:	ce 91       	brne	800077b4 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800077e4:	f6 0e 01 08 	sub	r8,r11,lr
800077e8:	58 08       	cp.w	r8,0
800077ea:	e0 89 00 06 	brgt	800077f6 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800077ee:	58 0e       	cp.w	lr,0
800077f0:	e0 89 00 14 	brgt	80007818 <PrintDec+0xbe>
800077f4:	c1 d8       	rjmp	8000782e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800077f6:	1c 1b       	sub	r11,lr
800077f8:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800077fa:	16 9c       	mov	r12,r11
800077fc:	58 0b       	cp.w	r11,0
800077fe:	fe 9a ff f8 	brle	800077ee <PrintDec+0x94>
80007802:	1a 99       	mov	r9,sp
80007804:	1c 09       	add	r9,lr
80007806:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007808:	33 06       	mov	r6,48
8000780a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000780c:	2f f8       	sub	r8,-1
8000780e:	18 38       	cp.w	r8,r12
80007810:	cf d5       	brlt	8000780a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007812:	f6 0e 00 0e 	add	lr,r11,lr
80007816:	ce cb       	rjmp	800077ee <PrintDec+0x94>
80007818:	fa c8 ff f4 	sub	r8,sp,-12
8000781c:	1c 08       	add	r8,lr
8000781e:	20 d8       	sub	r8,13
80007820:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007824:	11 89       	ld.ub	r9,r8[0x0]
80007826:	0e c9       	st.b	r7++,r9
80007828:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000782a:	16 38       	cp.w	r8,r11
8000782c:	cf c1       	brne	80007824 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000782e:	14 9c       	mov	r12,r10
80007830:	2f dd       	sub	sp,-12
80007832:	d8 22       	popm	r4-r7,pc

80007834 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007834:	d4 31       	pushm	r0-r7,lr
80007836:	fa cd 02 08 	sub	sp,sp,520
8000783a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
8000783c:	e0 6a 01 00 	mov	r10,256
80007840:	30 0b       	mov	r11,0
80007842:	fa cc fe f8 	sub	r12,sp,-264
80007846:	f0 1f 00 4e 	mcall	8000797c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000784a:	fa c4 fd d4 	sub	r4,sp,-556
8000784e:	30 0a       	mov	r10,0
80007850:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007852:	fa c3 ff fc 	sub	r3,sp,-4
80007856:	e0 61 01 00 	mov	r1,256
8000785a:	14 90       	mov	r0,r10
			
					if(*str == '%')
8000785c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000785e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007862:	02 9a       	mov	r10,r1
80007864:	00 9b       	mov	r11,r0
80007866:	06 9c       	mov	r12,r3
80007868:	f0 1f 00 45 	mcall	8000797c <log+0x148>
			
					if(*str == '%')
8000786c:	0f 88       	ld.ub	r8,r7[0x0]
8000786e:	e4 08 18 00 	cp.b	r8,r2
80007872:	c5 71       	brne	80007920 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007874:	ee c8 ff ff 	sub	r8,r7,-1
80007878:	11 89       	ld.ub	r9,r8[0x0]
8000787a:	4c 2a       	lddpc	r10,80007980 <log+0x14c>
8000787c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000787e:	23 09       	sub	r9,48
80007880:	30 9a       	mov	r10,9
80007882:	f4 09 18 00 	cp.b	r9,r10
80007886:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000788a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000788e:	f7 b9 08 30 	subls	r9,48
80007892:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007896:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000789a:	0f 88       	ld.ub	r8,r7[0x0]
8000789c:	22 58       	sub	r8,37
8000789e:	e0 48 00 53 	cp.w	r8,83
800078a2:	e0 8b 00 31 	brhi	80007904 <log+0xd0>
800078a6:	4b 89       	lddpc	r9,80007984 <log+0x150>
800078a8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800078ac:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800078b0:	06 9a       	mov	r10,r3
800078b2:	40 0b       	lddsp	r11,sp[0x0]
800078b4:	5c 5b       	castu.b	r11
800078b6:	68 0c       	ld.w	r12,r4[0x0]
800078b8:	f0 1f 00 34 	mcall	80007988 <log+0x154>
							break;
800078bc:	c2 98       	rjmp	8000790e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800078be:	4b 4c       	lddpc	r12,8000798c <log+0x158>
800078c0:	f0 1f 00 34 	mcall	80007990 <log+0x15c>
800078c4:	08 95       	mov	r5,r4
800078c6:	06 9c       	mov	r12,r3
							break;
800078c8:	c2 38       	rjmp	8000790e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800078ca:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800078ce:	06 9a       	mov	r10,r3
800078d0:	40 0b       	lddsp	r11,sp[0x0]
800078d2:	5c 5b       	castu.b	r11
800078d4:	68 0c       	ld.w	r12,r4[0x0]
800078d6:	f0 1f 00 30 	mcall	80007994 <log+0x160>
800078da:	06 9c       	mov	r12,r3
							break;
800078dc:	c1 98       	rjmp	8000790e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800078de:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800078e2:	06 9b       	mov	r11,r3
800078e4:	09 bc       	ld.ub	r12,r4[0x3]
800078e6:	f0 1f 00 2d 	mcall	80007998 <log+0x164>
800078ea:	06 9c       	mov	r12,r3
							break;
800078ec:	c1 18       	rjmp	8000790e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800078ee:	e8 c5 ff fc 	sub	r5,r4,-4
800078f2:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800078f4:	c0 d8       	rjmp	8000790e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800078f6:	06 9b       	mov	r11,r3
800078f8:	32 5c       	mov	r12,37
800078fa:	f0 1f 00 28 	mcall	80007998 <log+0x164>
800078fe:	08 95       	mov	r5,r4
80007900:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80007902:	c0 68       	rjmp	8000790e <log+0xda>
							
							default:
							log("I need relax.");
80007904:	4a 6c       	lddpc	r12,8000799c <log+0x168>
80007906:	f0 1f 00 23 	mcall	80007990 <log+0x15c>
8000790a:	08 95       	mov	r5,r4
8000790c:	06 9c       	mov	r12,r3
						}
						str++;
8000790e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007910:	1a dc       	st.w	--sp,r12
80007912:	1a d6       	st.w	--sp,r6
80007914:	4a 3b       	lddpc	r11,800079a0 <log+0x16c>
80007916:	0c 9c       	mov	r12,r6
80007918:	f0 1f 00 23 	mcall	800079a4 <log+0x170>
8000791c:	2f ed       	sub	sp,-8
8000791e:	c0 a8       	rjmp	80007932 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007920:	2f f7       	sub	r7,-1
80007922:	1a d8       	st.w	--sp,r8
80007924:	1a d6       	st.w	--sp,r6
80007926:	4a 1b       	lddpc	r11,800079a8 <log+0x174>
80007928:	0c 9c       	mov	r12,r6
8000792a:	f0 1f 00 1f 	mcall	800079a4 <log+0x170>
8000792e:	08 95       	mov	r5,r4
80007930:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007932:	0f 89       	ld.ub	r9,r7[0x0]
80007934:	30 08       	mov	r8,0
80007936:	f0 09 18 00 	cp.b	r9,r8
8000793a:	c0 30       	breq	80007940 <log+0x10c>
8000793c:	0a 94       	mov	r4,r5
8000793e:	c9 2b       	rjmp	80007862 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007940:	fa c7 fe f8 	sub	r7,sp,-264
80007944:	1a d7       	st.w	--sp,r7
80007946:	49 ab       	lddpc	r11,800079ac <log+0x178>
80007948:	0e 9c       	mov	r12,r7
8000794a:	f0 1f 00 17 	mcall	800079a4 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000794e:	5c 5c       	castu.b	r12
80007950:	f8 c6 ff ff 	sub	r6,r12,-1
80007954:	0c 9c       	mov	r12,r6
80007956:	f0 1f 00 17 	mcall	800079b0 <log+0x17c>
8000795a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000795c:	0c 9a       	mov	r10,r6
8000795e:	0e 9b       	mov	r11,r7
80007960:	f0 1f 00 15 	mcall	800079b4 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007964:	30 09       	mov	r9,0
80007966:	30 5a       	mov	r10,5
80007968:	fa cb fe f8 	sub	r11,sp,-264
8000796c:	49 38       	lddpc	r8,800079b8 <log+0x184>
8000796e:	70 0c       	ld.w	r12,r8[0x0]
80007970:	f0 1f 00 13 	mcall	800079bc <log+0x188>
80007974:	2f fd       	sub	sp,-4
	
	
}
80007976:	fe 3d fd f8 	sub	sp,-520
8000797a:	d8 32       	popm	r0-r7,pc
8000797c:	80 00       	ld.sh	r0,r0[0x0]
8000797e:	81 f8       	st.w	r0[0x3c],r8
80007980:	00 00       	add	r0,r0
80007982:	0d 74       	ld.ub	r4,--r6
80007984:	80 00       	ld.sh	r0,r0[0x0]
80007986:	e4 28 80 00 	sub	r8,294912
8000798a:	77 5a       	ld.w	r10,r11[0x54]
8000798c:	80 00       	ld.sh	r0,r0[0x0]
8000798e:	e6 d4 80 00 	satsub.w	r4,r3,-32768
80007992:	78 34       	ld.w	r4,r12[0xc]
80007994:	80 00       	ld.sh	r0,r0[0x0]
80007996:	76 a8       	ld.w	r8,r11[0x28]
80007998:	80 00       	ld.sh	r0,r0[0x0]
8000799a:	76 a4       	ld.w	r4,r11[0x28]
8000799c:	80 00       	ld.sh	r0,r0[0x0]
8000799e:	e6 e4 80 00 	ld.d	r4,r3[-32768]
800079a2:	e6 f4 80 00 	ld.w	r4,r3[-32768]
800079a6:	84 e8       	ld.uh	r8,r2[0xc]
800079a8:	80 00       	ld.sh	r0,r0[0x0]
800079aa:	e6 fc 80 00 	ld.w	r12,r3[-32768]
800079ae:	e7 04 80 00 	ld.sh	r4,r3[-32768]
800079b2:	69 00       	ld.w	r0,r4[0x40]
800079b4:	80 00       	ld.sh	r0,r0[0x0]
800079b6:	80 b0       	ld.uh	r0,r0[0x6]
800079b8:	00 00       	add	r0,r0
800079ba:	53 d4       	stdsp	sp[0xf4],r4
800079bc:	80 00       	ld.sh	r0,r0[0x0]
800079be:	6c 54       	ld.w	r4,r6[0x14]

800079c0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800079c0:	d4 31       	pushm	r0-r7,lr
800079c2:	fa cd 02 0c 	sub	sp,sp,524
800079c6:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800079c8:	e0 6a 01 00 	mov	r10,256
800079cc:	30 0b       	mov	r11,0
800079ce:	fa cc fe f4 	sub	r12,sp,-268
800079d2:	f0 1f 00 4c 	mcall	80007b00 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800079d6:	fa c4 fd d0 	sub	r4,sp,-560
800079da:	30 0a       	mov	r10,0
800079dc:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800079de:	fa c3 ff fc 	sub	r3,sp,-4
800079e2:	e0 61 01 00 	mov	r1,256
800079e6:	14 90       	mov	r0,r10
			
			if(*str == '%')
800079e8:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800079ea:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800079ee:	02 9a       	mov	r10,r1
800079f0:	00 9b       	mov	r11,r0
800079f2:	06 9c       	mov	r12,r3
800079f4:	f0 1f 00 43 	mcall	80007b00 <logFromISR+0x140>
			
			if(*str == '%')
800079f8:	0f 88       	ld.ub	r8,r7[0x0]
800079fa:	e4 08 18 00 	cp.b	r8,r2
800079fe:	c5 11       	brne	80007aa0 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007a00:	ee c8 ff ff 	sub	r8,r7,-1
80007a04:	11 89       	ld.ub	r9,r8[0x0]
80007a06:	4c 0a       	lddpc	r10,80007b04 <logFromISR+0x144>
80007a08:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007a0a:	23 09       	sub	r9,48
80007a0c:	30 9a       	mov	r10,9
80007a0e:	f4 09 18 00 	cp.b	r9,r10
80007a12:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007a16:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007a1a:	f7 b9 08 30 	subls	r9,48
80007a1e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007a22:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007a26:	0f 88       	ld.ub	r8,r7[0x0]
80007a28:	22 58       	sub	r8,37
80007a2a:	e0 48 00 53 	cp.w	r8,83
80007a2e:	e0 8b 00 2b 	brhi	80007a84 <logFromISR+0xc4>
80007a32:	4b 69       	lddpc	r9,80007b08 <logFromISR+0x148>
80007a34:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007a38:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007a3c:	06 9a       	mov	r10,r3
80007a3e:	40 0b       	lddsp	r11,sp[0x0]
80007a40:	5c 5b       	castu.b	r11
80007a42:	68 0c       	ld.w	r12,r4[0x0]
80007a44:	f0 1f 00 32 	mcall	80007b0c <logFromISR+0x14c>
					break;
80007a48:	c2 38       	rjmp	80007a8e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007a4a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007a4e:	06 9a       	mov	r10,r3
80007a50:	40 0b       	lddsp	r11,sp[0x0]
80007a52:	5c 5b       	castu.b	r11
80007a54:	68 0c       	ld.w	r12,r4[0x0]
80007a56:	f0 1f 00 2f 	mcall	80007b10 <logFromISR+0x150>
80007a5a:	06 9c       	mov	r12,r3
					break;
80007a5c:	c1 98       	rjmp	80007a8e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007a5e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007a62:	06 9b       	mov	r11,r3
80007a64:	09 bc       	ld.ub	r12,r4[0x3]
80007a66:	f0 1f 00 2c 	mcall	80007b14 <logFromISR+0x154>
80007a6a:	06 9c       	mov	r12,r3
					break;
80007a6c:	c1 18       	rjmp	80007a8e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007a6e:	e8 c5 ff fc 	sub	r5,r4,-4
80007a72:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007a74:	c0 d8       	rjmp	80007a8e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007a76:	06 9b       	mov	r11,r3
80007a78:	32 5c       	mov	r12,37
80007a7a:	f0 1f 00 27 	mcall	80007b14 <logFromISR+0x154>
80007a7e:	08 95       	mov	r5,r4
80007a80:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007a82:	c0 68       	rjmp	80007a8e <logFromISR+0xce>
					default:
					log("I need relax.");
80007a84:	4a 5c       	lddpc	r12,80007b18 <logFromISR+0x158>
80007a86:	f0 1f 00 26 	mcall	80007b1c <logFromISR+0x15c>
80007a8a:	08 95       	mov	r5,r4
80007a8c:	06 9c       	mov	r12,r3
				}
				str++;
80007a8e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007a90:	1a dc       	st.w	--sp,r12
80007a92:	1a d6       	st.w	--sp,r6
80007a94:	4a 3b       	lddpc	r11,80007b20 <logFromISR+0x160>
80007a96:	0c 9c       	mov	r12,r6
80007a98:	f0 1f 00 23 	mcall	80007b24 <logFromISR+0x164>
80007a9c:	2f ed       	sub	sp,-8
80007a9e:	c0 a8       	rjmp	80007ab2 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007aa0:	2f f7       	sub	r7,-1
80007aa2:	1a d8       	st.w	--sp,r8
80007aa4:	1a d6       	st.w	--sp,r6
80007aa6:	4a 1b       	lddpc	r11,80007b28 <logFromISR+0x168>
80007aa8:	0c 9c       	mov	r12,r6
80007aaa:	f0 1f 00 1f 	mcall	80007b24 <logFromISR+0x164>
80007aae:	08 95       	mov	r5,r4
80007ab0:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80007ab2:	0f 89       	ld.ub	r9,r7[0x0]
80007ab4:	30 08       	mov	r8,0
80007ab6:	f0 09 18 00 	cp.b	r9,r8
80007aba:	c0 30       	breq	80007ac0 <logFromISR+0x100>
80007abc:	0a 94       	mov	r4,r5
80007abe:	c9 8b       	rjmp	800079ee <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007ac0:	fa c7 fe f4 	sub	r7,sp,-268
80007ac4:	1a d7       	st.w	--sp,r7
80007ac6:	49 ab       	lddpc	r11,80007b2c <logFromISR+0x16c>
80007ac8:	0e 9c       	mov	r12,r7
80007aca:	f0 1f 00 17 	mcall	80007b24 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80007ace:	5c 5c       	castu.b	r12
80007ad0:	f8 c6 ff ff 	sub	r6,r12,-1
80007ad4:	0c 9c       	mov	r12,r6
80007ad6:	f0 1f 00 17 	mcall	80007b30 <logFromISR+0x170>
80007ada:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007adc:	0c 9a       	mov	r10,r6
80007ade:	0e 9b       	mov	r11,r7
80007ae0:	f0 1f 00 15 	mcall	80007b34 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007ae4:	30 09       	mov	r9,0
80007ae6:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007ae8:	fa ca fe f8 	sub	r10,sp,-264
80007aec:	fa cb fe f4 	sub	r11,sp,-268
80007af0:	49 28       	lddpc	r8,80007b38 <logFromISR+0x178>
80007af2:	70 0c       	ld.w	r12,r8[0x0]
80007af4:	f0 1f 00 12 	mcall	80007b3c <logFromISR+0x17c>
80007af8:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007afa:	fe 3d fd f4 	sub	sp,-524
80007afe:	d8 32       	popm	r0-r7,pc
80007b00:	80 00       	ld.sh	r0,r0[0x0]
80007b02:	81 f8       	st.w	r0[0x3c],r8
80007b04:	00 00       	add	r0,r0
80007b06:	0d 75       	ld.ub	r5,--r6
80007b08:	80 00       	ld.sh	r0,r0[0x0]
80007b0a:	e5 78 80 00 	stcond	r2[-32768],r8
80007b0e:	77 5a       	ld.w	r10,r11[0x54]
80007b10:	80 00       	ld.sh	r0,r0[0x0]
80007b12:	76 a8       	ld.w	r8,r11[0x28]
80007b14:	80 00       	ld.sh	r0,r0[0x0]
80007b16:	76 a4       	ld.w	r4,r11[0x28]
80007b18:	80 00       	ld.sh	r0,r0[0x0]
80007b1a:	e6 e4 80 00 	ld.d	r4,r3[-32768]
80007b1e:	78 34       	ld.w	r4,r12[0xc]
80007b20:	80 00       	ld.sh	r0,r0[0x0]
80007b22:	e6 f4 80 00 	ld.w	r4,r3[-32768]
80007b26:	84 e8       	ld.uh	r8,r2[0xc]
80007b28:	80 00       	ld.sh	r0,r0[0x0]
80007b2a:	e6 fc 80 00 	ld.w	r12,r3[-32768]
80007b2e:	e7 04 80 00 	ld.sh	r4,r3[-32768]
80007b32:	69 00       	ld.w	r0,r4[0x40]
80007b34:	80 00       	ld.sh	r0,r0[0x0]
80007b36:	80 b0       	ld.uh	r0,r0[0x6]
80007b38:	00 00       	add	r0,r0
80007b3a:	53 d4       	stdsp	sp[0xf4],r4
80007b3c:	80 00       	ld.sh	r0,r0[0x0]
80007b3e:	6c 04       	ld.w	r4,r6[0x0]

80007b40 <log_init>:
		
	return str;
}

void log_init(void)
{
80007b40:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007b42:	30 2b       	mov	r11,2
80007b44:	48 fc       	lddpc	r12,80007b80 <log_init+0x40>
80007b46:	f0 1f 00 10 	mcall	80007b84 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007b4a:	e0 6a 36 00 	mov	r10,13824
80007b4e:	ea 1a 01 6e 	orh	r10,0x16e
80007b52:	48 eb       	lddpc	r11,80007b88 <log_init+0x48>
80007b54:	fe 7c 18 00 	mov	r12,-59392
80007b58:	f0 1f 00 0d 	mcall	80007b8c <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007b5c:	30 4b       	mov	r11,4
80007b5e:	33 2c       	mov	r12,50
80007b60:	f0 1f 00 0c 	mcall	80007b90 <log_init+0x50>
80007b64:	48 c8       	lddpc	r8,80007b94 <log_init+0x54>
80007b66:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007b68:	30 09       	mov	r9,0
80007b6a:	1a d9       	st.w	--sp,r9
80007b6c:	1a d9       	st.w	--sp,r9
80007b6e:	1a d9       	st.w	--sp,r9
80007b70:	30 28       	mov	r8,2
80007b72:	36 4a       	mov	r10,100
80007b74:	48 9b       	lddpc	r11,80007b98 <log_init+0x58>
80007b76:	48 ac       	lddpc	r12,80007b9c <log_init+0x5c>
80007b78:	f0 1f 00 0a 	mcall	80007ba0 <log_init+0x60>
80007b7c:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007b7e:	d8 02       	popm	pc
80007b80:	80 00       	ld.sh	r0,r0[0x0]
80007b82:	e7 10 80 00 	ld.uh	r0,r3[-32768]
80007b86:	5c 70       	castu.h	r0
80007b88:	80 00       	ld.sh	r0,r0[0x0]
80007b8a:	e6 c8 80 00 	sub	r8,r3,-32768
80007b8e:	64 64       	ld.w	r4,r2[0x18]
80007b90:	80 00       	ld.sh	r0,r0[0x0]
80007b92:	6d 54       	ld.w	r4,r6[0x54]
80007b94:	00 00       	add	r0,r0
80007b96:	53 d4       	stdsp	sp[0xf4],r4
80007b98:	80 00       	ld.sh	r0,r0[0x0]
80007b9a:	e7 0c 80 00 	ld.sh	r12,r3[-32768]
80007b9e:	7b a4       	ld.w	r4,sp[0x68]
80007ba0:	80 00       	ld.sh	r0,r0[0x0]
80007ba2:	74 70       	ld.w	r0,r10[0x1c]

80007ba4 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007ba4:	eb cd 40 f8 	pushm	r3-r7,lr
80007ba8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007baa:	48 c7       	lddpc	r7,80007bd8 <task_log+0x34>
80007bac:	30 05       	mov	r5,0
80007bae:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007bb0:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007bb4:	0a 99       	mov	r9,r5
80007bb6:	08 9a       	mov	r10,r4
80007bb8:	1a 9b       	mov	r11,sp
80007bba:	6e 0c       	ld.w	r12,r7[0x0]
80007bbc:	f0 1f 00 08 	mcall	80007bdc <task_log+0x38>
80007bc0:	58 1c       	cp.w	r12,1
80007bc2:	cf 91       	brne	80007bb4 <task_log+0x10>
		{
			if( NULL != str)
80007bc4:	40 0b       	lddsp	r11,sp[0x0]
80007bc6:	58 0b       	cp.w	r11,0
80007bc8:	cf 60       	breq	80007bb4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007bca:	06 9c       	mov	r12,r3
80007bcc:	f0 1f 00 05 	mcall	80007be0 <task_log+0x3c>
				vPortFree(str);
80007bd0:	40 0c       	lddsp	r12,sp[0x0]
80007bd2:	f0 1f 00 05 	mcall	80007be4 <task_log+0x40>
80007bd6:	ce fb       	rjmp	80007bb4 <task_log+0x10>
80007bd8:	00 00       	add	r0,r0
80007bda:	53 d4       	stdsp	sp[0xf4],r4
80007bdc:	80 00       	ld.sh	r0,r0[0x0]
80007bde:	6a 48       	ld.w	r8,r5[0x10]
80007be0:	80 00       	ld.sh	r0,r0[0x0]
80007be2:	64 14       	ld.w	r4,r2[0x4]
80007be4:	80 00       	ld.sh	r0,r0[0x0]
80007be6:	68 d8       	ld.w	r8,r4[0x34]

80007be8 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007be8:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007bea:	fe 78 10 00 	mov	r8,-61440
80007bee:	30 19       	mov	r9,1
80007bf0:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007bf4:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007bf8:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007bfc:	d3 03       	ssrf	0x10
	local_start_pll0();
80007bfe:	f0 1f 00 0c 	mcall	80007c2c <main+0x44>
		
	INTC_init_interrupts();
80007c02:	f0 1f 00 0c 	mcall	80007c30 <main+0x48>
		
	log_init();
80007c06:	f0 1f 00 0c 	mcall	80007c34 <main+0x4c>
	log("----start debug----");
80007c0a:	48 cc       	lddpc	r12,80007c38 <main+0x50>
80007c0c:	f0 1f 00 0c 	mcall	80007c3c <main+0x54>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007c10:	f0 1f 00 0c 	mcall	80007c40 <main+0x58>
		
	app_init();
80007c14:	f0 1f 00 0c 	mcall	80007c44 <main+0x5c>
	
	xg_rtc_init();
80007c18:	f0 1f 00 0c 	mcall	80007c48 <main+0x60>
		
	xcmp_init();
80007c1c:	f0 1f 00 0c 	mcall	80007c4c <main+0x64>

	local_start_timer();
80007c20:	f0 1f 00 0c 	mcall	80007c50 <main+0x68>
		
	vTaskStartScheduler();
80007c24:	f0 1f 00 0c 	mcall	80007c54 <main+0x6c>
	return 0;
	
}
80007c28:	d8 0a       	popm	pc,r12=0
80007c2a:	00 00       	add	r0,r0
80007c2c:	80 00       	ld.sh	r0,r0[0x0]
80007c2e:	58 64       	cp.w	r4,6
80007c30:	80 00       	ld.sh	r0,r0[0x0]
80007c32:	5d 74       	*unknown*
80007c34:	80 00       	ld.sh	r0,r0[0x0]
80007c36:	7b 40       	ld.w	r0,sp[0x50]
80007c38:	80 00       	ld.sh	r0,r0[0x0]
80007c3a:	e7 20 80 00 	ld.sb	r0,r3[-32768]
80007c3e:	78 34       	ld.w	r4,r12[0xc]
80007c40:	80 00       	ld.sh	r0,r0[0x0]
80007c42:	57 c4       	stdsp	sp[0x1f0],r4
80007c44:	80 00       	ld.sh	r0,r0[0x0]
80007c46:	20 3c       	sub	r12,3
80007c48:	80 00       	ld.sh	r0,r0[0x0]
80007c4a:	2f 9c       	sub	r12,-7
80007c4c:	80 00       	ld.sh	r0,r0[0x0]
80007c4e:	46 78       	lddsp	r8,sp[0x19c]
80007c50:	80 00       	ld.sh	r0,r0[0x0]
80007c52:	58 38       	cp.w	r8,3
80007c54:	80 00       	ld.sh	r0,r0[0x0]
80007c56:	76 58       	ld.w	r8,r11[0x14]

80007c58 <free>:
80007c58:	d4 01       	pushm	lr
80007c5a:	e0 68 0a 44 	mov	r8,2628
80007c5e:	18 9b       	mov	r11,r12
80007c60:	70 0c       	ld.w	r12,r8[0x0]
80007c62:	e0 a0 1e 61 	rcall	8000b924 <_free_r>
80007c66:	d8 02       	popm	pc

80007c68 <malloc>:
80007c68:	d4 01       	pushm	lr
80007c6a:	e0 68 0a 44 	mov	r8,2628
80007c6e:	18 9b       	mov	r11,r12
80007c70:	70 0c       	ld.w	r12,r8[0x0]
80007c72:	c0 3c       	rcall	80007c78 <_malloc_r>
80007c74:	d8 02       	popm	pc
80007c76:	d7 03       	nop

80007c78 <_malloc_r>:
80007c78:	d4 31       	pushm	r0-r7,lr
80007c7a:	f6 c8 ff f5 	sub	r8,r11,-11
80007c7e:	18 95       	mov	r5,r12
80007c80:	10 97       	mov	r7,r8
80007c82:	e0 17 ff f8 	andl	r7,0xfff8
80007c86:	59 68       	cp.w	r8,22
80007c88:	f9 b7 08 10 	movls	r7,16
80007c8c:	16 37       	cp.w	r7,r11
80007c8e:	5f 38       	srlo	r8
80007c90:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007c94:	c0 50       	breq	80007c9e <_malloc_r+0x26>
80007c96:	30 c8       	mov	r8,12
80007c98:	99 38       	st.w	r12[0xc],r8
80007c9a:	e0 8f 01 fa 	bral	8000808e <_malloc_r+0x416>
80007c9e:	fe b0 f5 d3 	rcall	80006844 <__malloc_lock>
80007ca2:	e0 47 01 f7 	cp.w	r7,503
80007ca6:	e0 8b 00 1d 	brhi	80007ce0 <_malloc_r+0x68>
80007caa:	ee 03 16 03 	lsr	r3,r7,0x3
80007cae:	e0 68 05 44 	mov	r8,1348
80007cb2:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007cb6:	70 36       	ld.w	r6,r8[0xc]
80007cb8:	10 36       	cp.w	r6,r8
80007cba:	c0 61       	brne	80007cc6 <_malloc_r+0x4e>
80007cbc:	ec c8 ff f8 	sub	r8,r6,-8
80007cc0:	70 36       	ld.w	r6,r8[0xc]
80007cc2:	10 36       	cp.w	r6,r8
80007cc4:	c0 c0       	breq	80007cdc <_malloc_r+0x64>
80007cc6:	6c 18       	ld.w	r8,r6[0x4]
80007cc8:	e0 18 ff fc 	andl	r8,0xfffc
80007ccc:	6c 3a       	ld.w	r10,r6[0xc]
80007cce:	ec 08 00 09 	add	r9,r6,r8
80007cd2:	0a 9c       	mov	r12,r5
80007cd4:	6c 28       	ld.w	r8,r6[0x8]
80007cd6:	95 28       	st.w	r10[0x8],r8
80007cd8:	91 3a       	st.w	r8[0xc],r10
80007cda:	c4 78       	rjmp	80007d68 <_malloc_r+0xf0>
80007cdc:	2f e3       	sub	r3,-2
80007cde:	c4 d8       	rjmp	80007d78 <_malloc_r+0x100>
80007ce0:	ee 03 16 09 	lsr	r3,r7,0x9
80007ce4:	c0 41       	brne	80007cec <_malloc_r+0x74>
80007ce6:	ee 03 16 03 	lsr	r3,r7,0x3
80007cea:	c2 68       	rjmp	80007d36 <_malloc_r+0xbe>
80007cec:	58 43       	cp.w	r3,4
80007cee:	e0 8b 00 06 	brhi	80007cfa <_malloc_r+0x82>
80007cf2:	ee 03 16 06 	lsr	r3,r7,0x6
80007cf6:	2c 83       	sub	r3,-56
80007cf8:	c1 f8       	rjmp	80007d36 <_malloc_r+0xbe>
80007cfa:	59 43       	cp.w	r3,20
80007cfc:	e0 8b 00 04 	brhi	80007d04 <_malloc_r+0x8c>
80007d00:	2a 53       	sub	r3,-91
80007d02:	c1 a8       	rjmp	80007d36 <_malloc_r+0xbe>
80007d04:	e0 43 00 54 	cp.w	r3,84
80007d08:	e0 8b 00 06 	brhi	80007d14 <_malloc_r+0x9c>
80007d0c:	ee 03 16 0c 	lsr	r3,r7,0xc
80007d10:	29 23       	sub	r3,-110
80007d12:	c1 28       	rjmp	80007d36 <_malloc_r+0xbe>
80007d14:	e0 43 01 54 	cp.w	r3,340
80007d18:	e0 8b 00 06 	brhi	80007d24 <_malloc_r+0xac>
80007d1c:	ee 03 16 0f 	lsr	r3,r7,0xf
80007d20:	28 93       	sub	r3,-119
80007d22:	c0 a8       	rjmp	80007d36 <_malloc_r+0xbe>
80007d24:	e0 43 05 54 	cp.w	r3,1364
80007d28:	e0 88 00 04 	brls	80007d30 <_malloc_r+0xb8>
80007d2c:	37 e3       	mov	r3,126
80007d2e:	c0 48       	rjmp	80007d36 <_malloc_r+0xbe>
80007d30:	ee 03 16 12 	lsr	r3,r7,0x12
80007d34:	28 43       	sub	r3,-124
80007d36:	e0 6a 05 44 	mov	r10,1348
80007d3a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007d3e:	74 36       	ld.w	r6,r10[0xc]
80007d40:	c1 98       	rjmp	80007d72 <_malloc_r+0xfa>
80007d42:	6c 19       	ld.w	r9,r6[0x4]
80007d44:	e0 19 ff fc 	andl	r9,0xfffc
80007d48:	f2 07 01 0b 	sub	r11,r9,r7
80007d4c:	58 fb       	cp.w	r11,15
80007d4e:	e0 8a 00 04 	brle	80007d56 <_malloc_r+0xde>
80007d52:	20 13       	sub	r3,1
80007d54:	c1 18       	rjmp	80007d76 <_malloc_r+0xfe>
80007d56:	6c 38       	ld.w	r8,r6[0xc]
80007d58:	58 0b       	cp.w	r11,0
80007d5a:	c0 b5       	brlt	80007d70 <_malloc_r+0xf8>
80007d5c:	6c 2a       	ld.w	r10,r6[0x8]
80007d5e:	ec 09 00 09 	add	r9,r6,r9
80007d62:	0a 9c       	mov	r12,r5
80007d64:	91 2a       	st.w	r8[0x8],r10
80007d66:	95 38       	st.w	r10[0xc],r8
80007d68:	72 18       	ld.w	r8,r9[0x4]
80007d6a:	a1 a8       	sbr	r8,0x0
80007d6c:	93 18       	st.w	r9[0x4],r8
80007d6e:	cb c8       	rjmp	80007ee6 <_malloc_r+0x26e>
80007d70:	10 96       	mov	r6,r8
80007d72:	14 36       	cp.w	r6,r10
80007d74:	ce 71       	brne	80007d42 <_malloc_r+0xca>
80007d76:	2f f3       	sub	r3,-1
80007d78:	e0 6a 05 44 	mov	r10,1348
80007d7c:	f4 cc ff f8 	sub	r12,r10,-8
80007d80:	78 26       	ld.w	r6,r12[0x8]
80007d82:	18 36       	cp.w	r6,r12
80007d84:	c6 c0       	breq	80007e5c <_malloc_r+0x1e4>
80007d86:	6c 19       	ld.w	r9,r6[0x4]
80007d88:	e0 19 ff fc 	andl	r9,0xfffc
80007d8c:	f2 07 01 08 	sub	r8,r9,r7
80007d90:	58 f8       	cp.w	r8,15
80007d92:	e0 89 00 8f 	brgt	80007eb0 <_malloc_r+0x238>
80007d96:	99 3c       	st.w	r12[0xc],r12
80007d98:	99 2c       	st.w	r12[0x8],r12
80007d9a:	58 08       	cp.w	r8,0
80007d9c:	c0 55       	brlt	80007da6 <_malloc_r+0x12e>
80007d9e:	ec 09 00 09 	add	r9,r6,r9
80007da2:	0a 9c       	mov	r12,r5
80007da4:	ce 2b       	rjmp	80007d68 <_malloc_r+0xf0>
80007da6:	e0 49 01 ff 	cp.w	r9,511
80007daa:	e0 8b 00 13 	brhi	80007dd0 <_malloc_r+0x158>
80007dae:	a3 99       	lsr	r9,0x3
80007db0:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007db4:	70 2b       	ld.w	r11,r8[0x8]
80007db6:	8d 38       	st.w	r6[0xc],r8
80007db8:	8d 2b       	st.w	r6[0x8],r11
80007dba:	97 36       	st.w	r11[0xc],r6
80007dbc:	91 26       	st.w	r8[0x8],r6
80007dbe:	a3 49       	asr	r9,0x2
80007dc0:	74 18       	ld.w	r8,r10[0x4]
80007dc2:	30 1b       	mov	r11,1
80007dc4:	f6 09 09 49 	lsl	r9,r11,r9
80007dc8:	f1 e9 10 09 	or	r9,r8,r9
80007dcc:	95 19       	st.w	r10[0x4],r9
80007dce:	c4 78       	rjmp	80007e5c <_malloc_r+0x1e4>
80007dd0:	f2 0a 16 09 	lsr	r10,r9,0x9
80007dd4:	58 4a       	cp.w	r10,4
80007dd6:	e0 8b 00 07 	brhi	80007de4 <_malloc_r+0x16c>
80007dda:	f2 0a 16 06 	lsr	r10,r9,0x6
80007dde:	2c 8a       	sub	r10,-56
80007de0:	c2 08       	rjmp	80007e20 <_malloc_r+0x1a8>
80007de2:	d7 03       	nop
80007de4:	59 4a       	cp.w	r10,20
80007de6:	e0 8b 00 04 	brhi	80007dee <_malloc_r+0x176>
80007dea:	2a 5a       	sub	r10,-91
80007dec:	c1 a8       	rjmp	80007e20 <_malloc_r+0x1a8>
80007dee:	e0 4a 00 54 	cp.w	r10,84
80007df2:	e0 8b 00 06 	brhi	80007dfe <_malloc_r+0x186>
80007df6:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007dfa:	29 2a       	sub	r10,-110
80007dfc:	c1 28       	rjmp	80007e20 <_malloc_r+0x1a8>
80007dfe:	e0 4a 01 54 	cp.w	r10,340
80007e02:	e0 8b 00 06 	brhi	80007e0e <_malloc_r+0x196>
80007e06:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007e0a:	28 9a       	sub	r10,-119
80007e0c:	c0 a8       	rjmp	80007e20 <_malloc_r+0x1a8>
80007e0e:	e0 4a 05 54 	cp.w	r10,1364
80007e12:	e0 88 00 04 	brls	80007e1a <_malloc_r+0x1a2>
80007e16:	37 ea       	mov	r10,126
80007e18:	c0 48       	rjmp	80007e20 <_malloc_r+0x1a8>
80007e1a:	f2 0a 16 12 	lsr	r10,r9,0x12
80007e1e:	28 4a       	sub	r10,-124
80007e20:	e0 6b 05 44 	mov	r11,1348
80007e24:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007e28:	68 28       	ld.w	r8,r4[0x8]
80007e2a:	08 38       	cp.w	r8,r4
80007e2c:	c0 e1       	brne	80007e48 <_malloc_r+0x1d0>
80007e2e:	76 19       	ld.w	r9,r11[0x4]
80007e30:	a3 4a       	asr	r10,0x2
80007e32:	30 1e       	mov	lr,1
80007e34:	fc 0a 09 4a 	lsl	r10,lr,r10
80007e38:	f3 ea 10 0a 	or	r10,r9,r10
80007e3c:	10 99       	mov	r9,r8
80007e3e:	97 1a       	st.w	r11[0x4],r10
80007e40:	c0 a8       	rjmp	80007e54 <_malloc_r+0x1dc>
80007e42:	70 28       	ld.w	r8,r8[0x8]
80007e44:	08 38       	cp.w	r8,r4
80007e46:	c0 60       	breq	80007e52 <_malloc_r+0x1da>
80007e48:	70 1a       	ld.w	r10,r8[0x4]
80007e4a:	e0 1a ff fc 	andl	r10,0xfffc
80007e4e:	14 39       	cp.w	r9,r10
80007e50:	cf 93       	brcs	80007e42 <_malloc_r+0x1ca>
80007e52:	70 39       	ld.w	r9,r8[0xc]
80007e54:	8d 39       	st.w	r6[0xc],r9
80007e56:	8d 28       	st.w	r6[0x8],r8
80007e58:	91 36       	st.w	r8[0xc],r6
80007e5a:	93 26       	st.w	r9[0x8],r6
80007e5c:	e6 08 14 02 	asr	r8,r3,0x2
80007e60:	30 1b       	mov	r11,1
80007e62:	e0 64 05 44 	mov	r4,1348
80007e66:	f6 08 09 4b 	lsl	r11,r11,r8
80007e6a:	68 18       	ld.w	r8,r4[0x4]
80007e6c:	10 3b       	cp.w	r11,r8
80007e6e:	e0 8b 00 6b 	brhi	80007f44 <_malloc_r+0x2cc>
80007e72:	f7 e8 00 09 	and	r9,r11,r8
80007e76:	c0 b1       	brne	80007e8c <_malloc_r+0x214>
80007e78:	e0 13 ff fc 	andl	r3,0xfffc
80007e7c:	a1 7b       	lsl	r11,0x1
80007e7e:	2f c3       	sub	r3,-4
80007e80:	c0 38       	rjmp	80007e86 <_malloc_r+0x20e>
80007e82:	2f c3       	sub	r3,-4
80007e84:	a1 7b       	lsl	r11,0x1
80007e86:	f7 e8 00 09 	and	r9,r11,r8
80007e8a:	cf c0       	breq	80007e82 <_malloc_r+0x20a>
80007e8c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007e90:	06 92       	mov	r2,r3
80007e92:	1c 91       	mov	r1,lr
80007e94:	62 36       	ld.w	r6,r1[0xc]
80007e96:	c2 e8       	rjmp	80007ef2 <_malloc_r+0x27a>
80007e98:	6c 1a       	ld.w	r10,r6[0x4]
80007e9a:	e0 1a ff fc 	andl	r10,0xfffc
80007e9e:	f4 07 01 08 	sub	r8,r10,r7
80007ea2:	58 f8       	cp.w	r8,15
80007ea4:	e0 8a 00 15 	brle	80007ece <_malloc_r+0x256>
80007ea8:	6c 3a       	ld.w	r10,r6[0xc]
80007eaa:	6c 29       	ld.w	r9,r6[0x8]
80007eac:	95 29       	st.w	r10[0x8],r9
80007eae:	93 3a       	st.w	r9[0xc],r10
80007eb0:	0e 99       	mov	r9,r7
80007eb2:	ec 07 00 07 	add	r7,r6,r7
80007eb6:	a1 a9       	sbr	r9,0x0
80007eb8:	99 37       	st.w	r12[0xc],r7
80007eba:	99 27       	st.w	r12[0x8],r7
80007ebc:	8d 19       	st.w	r6[0x4],r9
80007ebe:	ee 08 09 08 	st.w	r7[r8],r8
80007ec2:	8f 2c       	st.w	r7[0x8],r12
80007ec4:	8f 3c       	st.w	r7[0xc],r12
80007ec6:	a1 a8       	sbr	r8,0x0
80007ec8:	0a 9c       	mov	r12,r5
80007eca:	8f 18       	st.w	r7[0x4],r8
80007ecc:	c0 d8       	rjmp	80007ee6 <_malloc_r+0x26e>
80007ece:	6c 39       	ld.w	r9,r6[0xc]
80007ed0:	58 08       	cp.w	r8,0
80007ed2:	c0 f5       	brlt	80007ef0 <_malloc_r+0x278>
80007ed4:	ec 0a 00 0a 	add	r10,r6,r10
80007ed8:	74 18       	ld.w	r8,r10[0x4]
80007eda:	a1 a8       	sbr	r8,0x0
80007edc:	0a 9c       	mov	r12,r5
80007ede:	95 18       	st.w	r10[0x4],r8
80007ee0:	6c 28       	ld.w	r8,r6[0x8]
80007ee2:	93 28       	st.w	r9[0x8],r8
80007ee4:	91 39       	st.w	r8[0xc],r9
80007ee6:	fe b0 f4 b5 	rcall	80006850 <__malloc_unlock>
80007eea:	ec cc ff f8 	sub	r12,r6,-8
80007eee:	d8 32       	popm	r0-r7,pc
80007ef0:	12 96       	mov	r6,r9
80007ef2:	02 36       	cp.w	r6,r1
80007ef4:	cd 21       	brne	80007e98 <_malloc_r+0x220>
80007ef6:	2f f2       	sub	r2,-1
80007ef8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007efc:	c0 30       	breq	80007f02 <_malloc_r+0x28a>
80007efe:	2f 81       	sub	r1,-8
80007f00:	cc ab       	rjmp	80007e94 <_malloc_r+0x21c>
80007f02:	1c 98       	mov	r8,lr
80007f04:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007f08:	c0 81       	brne	80007f18 <_malloc_r+0x2a0>
80007f0a:	68 19       	ld.w	r9,r4[0x4]
80007f0c:	f6 08 11 ff 	rsub	r8,r11,-1
80007f10:	f3 e8 00 08 	and	r8,r9,r8
80007f14:	89 18       	st.w	r4[0x4],r8
80007f16:	c0 78       	rjmp	80007f24 <_malloc_r+0x2ac>
80007f18:	f0 c9 00 08 	sub	r9,r8,8
80007f1c:	20 13       	sub	r3,1
80007f1e:	70 08       	ld.w	r8,r8[0x0]
80007f20:	12 38       	cp.w	r8,r9
80007f22:	cf 10       	breq	80007f04 <_malloc_r+0x28c>
80007f24:	a1 7b       	lsl	r11,0x1
80007f26:	68 18       	ld.w	r8,r4[0x4]
80007f28:	10 3b       	cp.w	r11,r8
80007f2a:	e0 8b 00 0d 	brhi	80007f44 <_malloc_r+0x2cc>
80007f2e:	58 0b       	cp.w	r11,0
80007f30:	c0 a0       	breq	80007f44 <_malloc_r+0x2cc>
80007f32:	04 93       	mov	r3,r2
80007f34:	c0 38       	rjmp	80007f3a <_malloc_r+0x2c2>
80007f36:	2f c3       	sub	r3,-4
80007f38:	a1 7b       	lsl	r11,0x1
80007f3a:	f7 e8 00 09 	and	r9,r11,r8
80007f3e:	ca 71       	brne	80007e8c <_malloc_r+0x214>
80007f40:	cf bb       	rjmp	80007f36 <_malloc_r+0x2be>
80007f42:	d7 03       	nop
80007f44:	68 23       	ld.w	r3,r4[0x8]
80007f46:	66 12       	ld.w	r2,r3[0x4]
80007f48:	e0 12 ff fc 	andl	r2,0xfffc
80007f4c:	0e 32       	cp.w	r2,r7
80007f4e:	5f 39       	srlo	r9
80007f50:	e4 07 01 08 	sub	r8,r2,r7
80007f54:	58 f8       	cp.w	r8,15
80007f56:	5f aa       	srle	r10
80007f58:	f5 e9 10 09 	or	r9,r10,r9
80007f5c:	e0 80 00 9a 	breq	80008090 <_malloc_r+0x418>
80007f60:	e0 68 0d 80 	mov	r8,3456
80007f64:	70 01       	ld.w	r1,r8[0x0]
80007f66:	e0 68 09 50 	mov	r8,2384
80007f6a:	2f 01       	sub	r1,-16
80007f6c:	70 08       	ld.w	r8,r8[0x0]
80007f6e:	0e 01       	add	r1,r7
80007f70:	5b f8       	cp.w	r8,-1
80007f72:	c0 40       	breq	80007f7a <_malloc_r+0x302>
80007f74:	28 11       	sub	r1,-127
80007f76:	e0 11 ff 80 	andl	r1,0xff80
80007f7a:	02 9b       	mov	r11,r1
80007f7c:	0a 9c       	mov	r12,r5
80007f7e:	e0 a0 02 a5 	rcall	800084c8 <_sbrk_r>
80007f82:	18 96       	mov	r6,r12
80007f84:	5b fc       	cp.w	r12,-1
80007f86:	c7 50       	breq	80008070 <_malloc_r+0x3f8>
80007f88:	e6 02 00 08 	add	r8,r3,r2
80007f8c:	10 3c       	cp.w	r12,r8
80007f8e:	c0 32       	brcc	80007f94 <_malloc_r+0x31c>
80007f90:	08 33       	cp.w	r3,r4
80007f92:	c6 f1       	brne	80008070 <_malloc_r+0x3f8>
80007f94:	e0 6a 0d 84 	mov	r10,3460
80007f98:	74 09       	ld.w	r9,r10[0x0]
80007f9a:	e2 09 00 09 	add	r9,r1,r9
80007f9e:	95 09       	st.w	r10[0x0],r9
80007fa0:	10 36       	cp.w	r6,r8
80007fa2:	c0 a1       	brne	80007fb6 <_malloc_r+0x33e>
80007fa4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007fa8:	c0 71       	brne	80007fb6 <_malloc_r+0x33e>
80007faa:	e2 02 00 02 	add	r2,r1,r2
80007fae:	68 28       	ld.w	r8,r4[0x8]
80007fb0:	a1 a2       	sbr	r2,0x0
80007fb2:	91 12       	st.w	r8[0x4],r2
80007fb4:	c4 f8       	rjmp	80008052 <_malloc_r+0x3da>
80007fb6:	e0 6a 09 50 	mov	r10,2384
80007fba:	74 0b       	ld.w	r11,r10[0x0]
80007fbc:	5b fb       	cp.w	r11,-1
80007fbe:	c0 31       	brne	80007fc4 <_malloc_r+0x34c>
80007fc0:	95 06       	st.w	r10[0x0],r6
80007fc2:	c0 78       	rjmp	80007fd0 <_malloc_r+0x358>
80007fc4:	ec 09 00 09 	add	r9,r6,r9
80007fc8:	e0 6a 0d 84 	mov	r10,3460
80007fcc:	10 19       	sub	r9,r8
80007fce:	95 09       	st.w	r10[0x0],r9
80007fd0:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007fd4:	f0 09 11 08 	rsub	r9,r8,8
80007fd8:	58 08       	cp.w	r8,0
80007fda:	f2 08 17 10 	movne	r8,r9
80007fde:	ed d8 e1 06 	addne	r6,r6,r8
80007fe2:	28 08       	sub	r8,-128
80007fe4:	ec 01 00 01 	add	r1,r6,r1
80007fe8:	0a 9c       	mov	r12,r5
80007fea:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007fee:	f0 01 01 01 	sub	r1,r8,r1
80007ff2:	02 9b       	mov	r11,r1
80007ff4:	e0 a0 02 6a 	rcall	800084c8 <_sbrk_r>
80007ff8:	e0 68 0d 84 	mov	r8,3460
80007ffc:	5b fc       	cp.w	r12,-1
80007ffe:	ec 0c 17 00 	moveq	r12,r6
80008002:	f9 b1 00 00 	moveq	r1,0
80008006:	70 09       	ld.w	r9,r8[0x0]
80008008:	0c 1c       	sub	r12,r6
8000800a:	89 26       	st.w	r4[0x8],r6
8000800c:	02 0c       	add	r12,r1
8000800e:	12 01       	add	r1,r9
80008010:	a1 ac       	sbr	r12,0x0
80008012:	91 01       	st.w	r8[0x0],r1
80008014:	8d 1c       	st.w	r6[0x4],r12
80008016:	08 33       	cp.w	r3,r4
80008018:	c1 d0       	breq	80008052 <_malloc_r+0x3da>
8000801a:	58 f2       	cp.w	r2,15
8000801c:	e0 8b 00 05 	brhi	80008026 <_malloc_r+0x3ae>
80008020:	30 18       	mov	r8,1
80008022:	8d 18       	st.w	r6[0x4],r8
80008024:	c2 68       	rjmp	80008070 <_malloc_r+0x3f8>
80008026:	30 59       	mov	r9,5
80008028:	20 c2       	sub	r2,12
8000802a:	e0 12 ff f8 	andl	r2,0xfff8
8000802e:	e6 02 00 08 	add	r8,r3,r2
80008032:	91 29       	st.w	r8[0x8],r9
80008034:	91 19       	st.w	r8[0x4],r9
80008036:	66 18       	ld.w	r8,r3[0x4]
80008038:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000803c:	e5 e8 10 08 	or	r8,r2,r8
80008040:	87 18       	st.w	r3[0x4],r8
80008042:	58 f2       	cp.w	r2,15
80008044:	e0 88 00 07 	brls	80008052 <_malloc_r+0x3da>
80008048:	e6 cb ff f8 	sub	r11,r3,-8
8000804c:	0a 9c       	mov	r12,r5
8000804e:	e0 a0 1c 6b 	rcall	8000b924 <_free_r>
80008052:	e0 69 0d 7c 	mov	r9,3452
80008056:	72 0a       	ld.w	r10,r9[0x0]
80008058:	e0 68 0d 84 	mov	r8,3460
8000805c:	70 08       	ld.w	r8,r8[0x0]
8000805e:	14 38       	cp.w	r8,r10
80008060:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008064:	e0 69 0d 78 	mov	r9,3448
80008068:	72 0a       	ld.w	r10,r9[0x0]
8000806a:	14 38       	cp.w	r8,r10
8000806c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008070:	68 28       	ld.w	r8,r4[0x8]
80008072:	70 18       	ld.w	r8,r8[0x4]
80008074:	e0 18 ff fc 	andl	r8,0xfffc
80008078:	0e 38       	cp.w	r8,r7
8000807a:	5f 39       	srlo	r9
8000807c:	0e 18       	sub	r8,r7
8000807e:	58 f8       	cp.w	r8,15
80008080:	5f aa       	srle	r10
80008082:	f5 e9 10 09 	or	r9,r10,r9
80008086:	c0 50       	breq	80008090 <_malloc_r+0x418>
80008088:	0a 9c       	mov	r12,r5
8000808a:	fe b0 f3 e3 	rcall	80006850 <__malloc_unlock>
8000808e:	d8 3a       	popm	r0-r7,pc,r12=0
80008090:	68 26       	ld.w	r6,r4[0x8]
80008092:	a1 a8       	sbr	r8,0x0
80008094:	0e 99       	mov	r9,r7
80008096:	a1 a9       	sbr	r9,0x0
80008098:	8d 19       	st.w	r6[0x4],r9
8000809a:	ec 07 00 07 	add	r7,r6,r7
8000809e:	0a 9c       	mov	r12,r5
800080a0:	89 27       	st.w	r4[0x8],r7
800080a2:	8f 18       	st.w	r7[0x4],r8
800080a4:	fe b0 f3 d6 	rcall	80006850 <__malloc_unlock>
800080a8:	ec cc ff f8 	sub	r12,r6,-8
800080ac:	d8 32       	popm	r0-r7,pc
800080ae:	d7 03       	nop

800080b0 <memcpy>:
800080b0:	58 8a       	cp.w	r10,8
800080b2:	c2 f5       	brlt	80008110 <memcpy+0x60>
800080b4:	f9 eb 10 09 	or	r9,r12,r11
800080b8:	e2 19 00 03 	andl	r9,0x3,COH
800080bc:	e0 81 00 97 	brne	800081ea <memcpy+0x13a>
800080c0:	e0 4a 00 20 	cp.w	r10,32
800080c4:	c3 b4       	brge	8000813a <memcpy+0x8a>
800080c6:	f4 08 14 02 	asr	r8,r10,0x2
800080ca:	f0 09 11 08 	rsub	r9,r8,8
800080ce:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800080d2:	76 69       	ld.w	r9,r11[0x18]
800080d4:	99 69       	st.w	r12[0x18],r9
800080d6:	76 59       	ld.w	r9,r11[0x14]
800080d8:	99 59       	st.w	r12[0x14],r9
800080da:	76 49       	ld.w	r9,r11[0x10]
800080dc:	99 49       	st.w	r12[0x10],r9
800080de:	76 39       	ld.w	r9,r11[0xc]
800080e0:	99 39       	st.w	r12[0xc],r9
800080e2:	76 29       	ld.w	r9,r11[0x8]
800080e4:	99 29       	st.w	r12[0x8],r9
800080e6:	76 19       	ld.w	r9,r11[0x4]
800080e8:	99 19       	st.w	r12[0x4],r9
800080ea:	76 09       	ld.w	r9,r11[0x0]
800080ec:	99 09       	st.w	r12[0x0],r9
800080ee:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800080f2:	f8 08 00 28 	add	r8,r12,r8<<0x2
800080f6:	e0 1a 00 03 	andl	r10,0x3
800080fa:	f4 0a 11 04 	rsub	r10,r10,4
800080fe:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008102:	17 a9       	ld.ub	r9,r11[0x2]
80008104:	b0 a9       	st.b	r8[0x2],r9
80008106:	17 99       	ld.ub	r9,r11[0x1]
80008108:	b0 99       	st.b	r8[0x1],r9
8000810a:	17 89       	ld.ub	r9,r11[0x0]
8000810c:	b0 89       	st.b	r8[0x0],r9
8000810e:	5e fc       	retal	r12
80008110:	f4 0a 11 09 	rsub	r10,r10,9
80008114:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008118:	17 f9       	ld.ub	r9,r11[0x7]
8000811a:	b8 f9       	st.b	r12[0x7],r9
8000811c:	17 e9       	ld.ub	r9,r11[0x6]
8000811e:	b8 e9       	st.b	r12[0x6],r9
80008120:	17 d9       	ld.ub	r9,r11[0x5]
80008122:	b8 d9       	st.b	r12[0x5],r9
80008124:	17 c9       	ld.ub	r9,r11[0x4]
80008126:	b8 c9       	st.b	r12[0x4],r9
80008128:	17 b9       	ld.ub	r9,r11[0x3]
8000812a:	b8 b9       	st.b	r12[0x3],r9
8000812c:	17 a9       	ld.ub	r9,r11[0x2]
8000812e:	b8 a9       	st.b	r12[0x2],r9
80008130:	17 99       	ld.ub	r9,r11[0x1]
80008132:	b8 99       	st.b	r12[0x1],r9
80008134:	17 89       	ld.ub	r9,r11[0x0]
80008136:	b8 89       	st.b	r12[0x0],r9
80008138:	5e fc       	retal	r12
8000813a:	eb cd 40 c0 	pushm	r6-r7,lr
8000813e:	18 99       	mov	r9,r12
80008140:	22 0a       	sub	r10,32
80008142:	b7 07       	ld.d	r6,r11++
80008144:	b3 26       	st.d	r9++,r6
80008146:	b7 07       	ld.d	r6,r11++
80008148:	b3 26       	st.d	r9++,r6
8000814a:	b7 07       	ld.d	r6,r11++
8000814c:	b3 26       	st.d	r9++,r6
8000814e:	b7 07       	ld.d	r6,r11++
80008150:	b3 26       	st.d	r9++,r6
80008152:	22 0a       	sub	r10,32
80008154:	cf 74       	brge	80008142 <memcpy+0x92>
80008156:	2f 0a       	sub	r10,-16
80008158:	c0 65       	brlt	80008164 <memcpy+0xb4>
8000815a:	b7 07       	ld.d	r6,r11++
8000815c:	b3 26       	st.d	r9++,r6
8000815e:	b7 07       	ld.d	r6,r11++
80008160:	b3 26       	st.d	r9++,r6
80008162:	21 0a       	sub	r10,16
80008164:	5c 3a       	neg	r10
80008166:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000816a:	d7 03       	nop
8000816c:	d7 03       	nop
8000816e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80008172:	f3 66 00 0e 	st.b	r9[14],r6
80008176:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000817a:	f3 66 00 0d 	st.b	r9[13],r6
8000817e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80008182:	f3 66 00 0c 	st.b	r9[12],r6
80008186:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000818a:	f3 66 00 0b 	st.b	r9[11],r6
8000818e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80008192:	f3 66 00 0a 	st.b	r9[10],r6
80008196:	f7 36 00 09 	ld.ub	r6,r11[9]
8000819a:	f3 66 00 09 	st.b	r9[9],r6
8000819e:	f7 36 00 08 	ld.ub	r6,r11[8]
800081a2:	f3 66 00 08 	st.b	r9[8],r6
800081a6:	f7 36 00 07 	ld.ub	r6,r11[7]
800081aa:	f3 66 00 07 	st.b	r9[7],r6
800081ae:	f7 36 00 06 	ld.ub	r6,r11[6]
800081b2:	f3 66 00 06 	st.b	r9[6],r6
800081b6:	f7 36 00 05 	ld.ub	r6,r11[5]
800081ba:	f3 66 00 05 	st.b	r9[5],r6
800081be:	f7 36 00 04 	ld.ub	r6,r11[4]
800081c2:	f3 66 00 04 	st.b	r9[4],r6
800081c6:	f7 36 00 03 	ld.ub	r6,r11[3]
800081ca:	f3 66 00 03 	st.b	r9[3],r6
800081ce:	f7 36 00 02 	ld.ub	r6,r11[2]
800081d2:	f3 66 00 02 	st.b	r9[2],r6
800081d6:	f7 36 00 01 	ld.ub	r6,r11[1]
800081da:	f3 66 00 01 	st.b	r9[1],r6
800081de:	f7 36 00 00 	ld.ub	r6,r11[0]
800081e2:	f3 66 00 00 	st.b	r9[0],r6
800081e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800081ea:	20 1a       	sub	r10,1
800081ec:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800081f0:	f8 0a 0b 09 	st.b	r12[r10],r9
800081f4:	cf b1       	brne	800081ea <memcpy+0x13a>
800081f6:	5e fc       	retal	r12

800081f8 <memset>:
800081f8:	18 98       	mov	r8,r12
800081fa:	c0 38       	rjmp	80008200 <memset+0x8>
800081fc:	10 cb       	st.b	r8++,r11
800081fe:	20 1a       	sub	r10,1
80008200:	58 0a       	cp.w	r10,0
80008202:	cf d1       	brne	800081fc <memset+0x4>
80008204:	5e fc       	retal	r12
80008206:	d7 03       	nop

80008208 <_realloc_r>:
80008208:	d4 31       	pushm	r0-r7,lr
8000820a:	20 1d       	sub	sp,4
8000820c:	16 94       	mov	r4,r11
8000820e:	18 92       	mov	r2,r12
80008210:	14 9b       	mov	r11,r10
80008212:	58 04       	cp.w	r4,0
80008214:	c0 51       	brne	8000821e <_realloc_r+0x16>
80008216:	fe b0 fd 31 	rcall	80007c78 <_malloc_r>
8000821a:	18 95       	mov	r5,r12
8000821c:	c5 39       	rjmp	800084c2 <_realloc_r+0x2ba>
8000821e:	50 0a       	stdsp	sp[0x0],r10
80008220:	fe b0 f3 12 	rcall	80006844 <__malloc_lock>
80008224:	40 0b       	lddsp	r11,sp[0x0]
80008226:	f6 c8 ff f5 	sub	r8,r11,-11
8000822a:	e8 c1 00 08 	sub	r1,r4,8
8000822e:	10 96       	mov	r6,r8
80008230:	62 1c       	ld.w	r12,r1[0x4]
80008232:	e0 16 ff f8 	andl	r6,0xfff8
80008236:	59 68       	cp.w	r8,22
80008238:	f9 b6 08 10 	movls	r6,16
8000823c:	16 36       	cp.w	r6,r11
8000823e:	5f 38       	srlo	r8
80008240:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80008244:	c0 50       	breq	8000824e <_realloc_r+0x46>
80008246:	30 c8       	mov	r8,12
80008248:	30 05       	mov	r5,0
8000824a:	85 38       	st.w	r2[0xc],r8
8000824c:	c3 b9       	rjmp	800084c2 <_realloc_r+0x2ba>
8000824e:	18 90       	mov	r0,r12
80008250:	e0 10 ff fc 	andl	r0,0xfffc
80008254:	0c 30       	cp.w	r0,r6
80008256:	e0 84 01 0b 	brge	8000846c <_realloc_r+0x264>
8000825a:	e0 68 05 44 	mov	r8,1348
8000825e:	e2 00 00 09 	add	r9,r1,r0
80008262:	70 25       	ld.w	r5,r8[0x8]
80008264:	0a 39       	cp.w	r9,r5
80008266:	c0 90       	breq	80008278 <_realloc_r+0x70>
80008268:	72 1a       	ld.w	r10,r9[0x4]
8000826a:	a1 ca       	cbr	r10,0x0
8000826c:	f2 0a 00 0a 	add	r10,r9,r10
80008270:	74 1a       	ld.w	r10,r10[0x4]
80008272:	ed ba 00 00 	bld	r10,0x0
80008276:	c2 20       	breq	800082ba <_realloc_r+0xb2>
80008278:	72 1a       	ld.w	r10,r9[0x4]
8000827a:	e0 1a ff fc 	andl	r10,0xfffc
8000827e:	f4 00 00 03 	add	r3,r10,r0
80008282:	0a 39       	cp.w	r9,r5
80008284:	c1 31       	brne	800082aa <_realloc_r+0xa2>
80008286:	ec c7 ff f0 	sub	r7,r6,-16
8000828a:	0e 33       	cp.w	r3,r7
8000828c:	c1 95       	brlt	800082be <_realloc_r+0xb6>
8000828e:	e2 06 00 09 	add	r9,r1,r6
80008292:	0c 13       	sub	r3,r6
80008294:	a1 a3       	sbr	r3,0x0
80008296:	93 13       	st.w	r9[0x4],r3
80008298:	91 29       	st.w	r8[0x8],r9
8000829a:	04 9c       	mov	r12,r2
8000829c:	62 18       	ld.w	r8,r1[0x4]
8000829e:	08 95       	mov	r5,r4
800082a0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800082a4:	10 46       	or	r6,r8
800082a6:	83 16       	st.w	r1[0x4],r6
800082a8:	c0 b9       	rjmp	800084be <_realloc_r+0x2b6>
800082aa:	0c 33       	cp.w	r3,r6
800082ac:	c0 95       	brlt	800082be <_realloc_r+0xb6>
800082ae:	72 28       	ld.w	r8,r9[0x8]
800082b0:	02 97       	mov	r7,r1
800082b2:	72 39       	ld.w	r9,r9[0xc]
800082b4:	93 28       	st.w	r9[0x8],r8
800082b6:	91 39       	st.w	r8[0xc],r9
800082b8:	cd c8       	rjmp	80008470 <_realloc_r+0x268>
800082ba:	30 0a       	mov	r10,0
800082bc:	14 99       	mov	r9,r10
800082be:	ed bc 00 00 	bld	r12,0x0
800082c2:	e0 80 00 95 	breq	800083ec <_realloc_r+0x1e4>
800082c6:	62 07       	ld.w	r7,r1[0x0]
800082c8:	e2 07 01 07 	sub	r7,r1,r7
800082cc:	6e 1c       	ld.w	r12,r7[0x4]
800082ce:	e0 1c ff fc 	andl	r12,0xfffc
800082d2:	58 09       	cp.w	r9,0
800082d4:	c5 60       	breq	80008380 <_realloc_r+0x178>
800082d6:	f8 00 00 03 	add	r3,r12,r0
800082da:	0a 39       	cp.w	r9,r5
800082dc:	c4 81       	brne	8000836c <_realloc_r+0x164>
800082de:	14 03       	add	r3,r10
800082e0:	ec c9 ff f0 	sub	r9,r6,-16
800082e4:	12 33       	cp.w	r3,r9
800082e6:	c4 d5       	brlt	80008380 <_realloc_r+0x178>
800082e8:	6e 3a       	ld.w	r10,r7[0xc]
800082ea:	6e 29       	ld.w	r9,r7[0x8]
800082ec:	95 29       	st.w	r10[0x8],r9
800082ee:	93 3a       	st.w	r9[0xc],r10
800082f0:	ee c5 ff f8 	sub	r5,r7,-8
800082f4:	e0 ca 00 04 	sub	r10,r0,4
800082f8:	e0 4a 00 24 	cp.w	r10,36
800082fc:	e0 8b 00 25 	brhi	80008346 <_realloc_r+0x13e>
80008300:	0a 99       	mov	r9,r5
80008302:	59 3a       	cp.w	r10,19
80008304:	e0 88 00 1a 	brls	80008338 <_realloc_r+0x130>
80008308:	09 09       	ld.w	r9,r4++
8000830a:	8b 09       	st.w	r5[0x0],r9
8000830c:	09 09       	ld.w	r9,r4++
8000830e:	8f 39       	st.w	r7[0xc],r9
80008310:	ee c9 ff f0 	sub	r9,r7,-16
80008314:	59 ba       	cp.w	r10,27
80008316:	e0 88 00 11 	brls	80008338 <_realloc_r+0x130>
8000831a:	09 0b       	ld.w	r11,r4++
8000831c:	93 0b       	st.w	r9[0x0],r11
8000831e:	09 09       	ld.w	r9,r4++
80008320:	8f 59       	st.w	r7[0x14],r9
80008322:	ee c9 ff e8 	sub	r9,r7,-24
80008326:	e0 4a 00 24 	cp.w	r10,36
8000832a:	c0 71       	brne	80008338 <_realloc_r+0x130>
8000832c:	09 0a       	ld.w	r10,r4++
8000832e:	93 0a       	st.w	r9[0x0],r10
80008330:	ee c9 ff e0 	sub	r9,r7,-32
80008334:	09 0a       	ld.w	r10,r4++
80008336:	8f 7a       	st.w	r7[0x1c],r10
80008338:	09 0a       	ld.w	r10,r4++
8000833a:	12 aa       	st.w	r9++,r10
8000833c:	68 0a       	ld.w	r10,r4[0x0]
8000833e:	93 0a       	st.w	r9[0x0],r10
80008340:	68 1a       	ld.w	r10,r4[0x4]
80008342:	93 1a       	st.w	r9[0x4],r10
80008344:	c0 78       	rjmp	80008352 <_realloc_r+0x14a>
80008346:	50 08       	stdsp	sp[0x0],r8
80008348:	08 9b       	mov	r11,r4
8000834a:	0a 9c       	mov	r12,r5
8000834c:	e0 a0 1d 8f 	rcall	8000be6a <memmove>
80008350:	40 08       	lddsp	r8,sp[0x0]
80008352:	ee 06 00 09 	add	r9,r7,r6
80008356:	0c 13       	sub	r3,r6
80008358:	a1 a3       	sbr	r3,0x0
8000835a:	93 13       	st.w	r9[0x4],r3
8000835c:	91 29       	st.w	r8[0x8],r9
8000835e:	04 9c       	mov	r12,r2
80008360:	6e 18       	ld.w	r8,r7[0x4]
80008362:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008366:	10 46       	or	r6,r8
80008368:	8f 16       	st.w	r7[0x4],r6
8000836a:	ca a8       	rjmp	800084be <_realloc_r+0x2b6>
8000836c:	14 03       	add	r3,r10
8000836e:	0c 33       	cp.w	r3,r6
80008370:	c0 85       	brlt	80008380 <_realloc_r+0x178>
80008372:	72 28       	ld.w	r8,r9[0x8]
80008374:	72 39       	ld.w	r9,r9[0xc]
80008376:	93 28       	st.w	r9[0x8],r8
80008378:	91 39       	st.w	r8[0xc],r9
8000837a:	6e 28       	ld.w	r8,r7[0x8]
8000837c:	6e 39       	ld.w	r9,r7[0xc]
8000837e:	c0 78       	rjmp	8000838c <_realloc_r+0x184>
80008380:	f8 00 00 03 	add	r3,r12,r0
80008384:	0c 33       	cp.w	r3,r6
80008386:	c3 35       	brlt	800083ec <_realloc_r+0x1e4>
80008388:	6e 39       	ld.w	r9,r7[0xc]
8000838a:	6e 28       	ld.w	r8,r7[0x8]
8000838c:	93 28       	st.w	r9[0x8],r8
8000838e:	91 39       	st.w	r8[0xc],r9
80008390:	e0 ca 00 04 	sub	r10,r0,4
80008394:	ee cc ff f8 	sub	r12,r7,-8
80008398:	e0 4a 00 24 	cp.w	r10,36
8000839c:	e0 8b 00 24 	brhi	800083e4 <_realloc_r+0x1dc>
800083a0:	59 3a       	cp.w	r10,19
800083a2:	e0 88 00 1a 	brls	800083d6 <_realloc_r+0x1ce>
800083a6:	09 08       	ld.w	r8,r4++
800083a8:	99 08       	st.w	r12[0x0],r8
800083aa:	09 08       	ld.w	r8,r4++
800083ac:	8f 38       	st.w	r7[0xc],r8
800083ae:	ee cc ff f0 	sub	r12,r7,-16
800083b2:	59 ba       	cp.w	r10,27
800083b4:	e0 88 00 11 	brls	800083d6 <_realloc_r+0x1ce>
800083b8:	09 08       	ld.w	r8,r4++
800083ba:	99 08       	st.w	r12[0x0],r8
800083bc:	09 08       	ld.w	r8,r4++
800083be:	8f 58       	st.w	r7[0x14],r8
800083c0:	ee cc ff e8 	sub	r12,r7,-24
800083c4:	e0 4a 00 24 	cp.w	r10,36
800083c8:	c0 71       	brne	800083d6 <_realloc_r+0x1ce>
800083ca:	09 08       	ld.w	r8,r4++
800083cc:	99 08       	st.w	r12[0x0],r8
800083ce:	ee cc ff e0 	sub	r12,r7,-32
800083d2:	09 08       	ld.w	r8,r4++
800083d4:	8f 78       	st.w	r7[0x1c],r8
800083d6:	09 08       	ld.w	r8,r4++
800083d8:	18 a8       	st.w	r12++,r8
800083da:	68 08       	ld.w	r8,r4[0x0]
800083dc:	99 08       	st.w	r12[0x0],r8
800083de:	68 18       	ld.w	r8,r4[0x4]
800083e0:	99 18       	st.w	r12[0x4],r8
800083e2:	c4 78       	rjmp	80008470 <_realloc_r+0x268>
800083e4:	08 9b       	mov	r11,r4
800083e6:	e0 a0 1d 42 	rcall	8000be6a <memmove>
800083ea:	c4 38       	rjmp	80008470 <_realloc_r+0x268>
800083ec:	04 9c       	mov	r12,r2
800083ee:	fe b0 fc 45 	rcall	80007c78 <_malloc_r>
800083f2:	18 95       	mov	r5,r12
800083f4:	c3 a0       	breq	80008468 <_realloc_r+0x260>
800083f6:	62 18       	ld.w	r8,r1[0x4]
800083f8:	f8 c9 00 08 	sub	r9,r12,8
800083fc:	a1 c8       	cbr	r8,0x0
800083fe:	e2 08 00 08 	add	r8,r1,r8
80008402:	10 39       	cp.w	r9,r8
80008404:	c0 71       	brne	80008412 <_realloc_r+0x20a>
80008406:	72 13       	ld.w	r3,r9[0x4]
80008408:	02 97       	mov	r7,r1
8000840a:	e0 13 ff fc 	andl	r3,0xfffc
8000840e:	00 03       	add	r3,r0
80008410:	c3 08       	rjmp	80008470 <_realloc_r+0x268>
80008412:	e0 ca 00 04 	sub	r10,r0,4
80008416:	e0 4a 00 24 	cp.w	r10,36
8000841a:	e0 8b 00 20 	brhi	8000845a <_realloc_r+0x252>
8000841e:	08 99       	mov	r9,r4
80008420:	18 98       	mov	r8,r12
80008422:	59 3a       	cp.w	r10,19
80008424:	e0 88 00 14 	brls	8000844c <_realloc_r+0x244>
80008428:	13 0b       	ld.w	r11,r9++
8000842a:	10 ab       	st.w	r8++,r11
8000842c:	13 0b       	ld.w	r11,r9++
8000842e:	10 ab       	st.w	r8++,r11
80008430:	59 ba       	cp.w	r10,27
80008432:	e0 88 00 0d 	brls	8000844c <_realloc_r+0x244>
80008436:	13 0b       	ld.w	r11,r9++
80008438:	10 ab       	st.w	r8++,r11
8000843a:	13 0b       	ld.w	r11,r9++
8000843c:	10 ab       	st.w	r8++,r11
8000843e:	e0 4a 00 24 	cp.w	r10,36
80008442:	c0 51       	brne	8000844c <_realloc_r+0x244>
80008444:	13 0a       	ld.w	r10,r9++
80008446:	10 aa       	st.w	r8++,r10
80008448:	13 0a       	ld.w	r10,r9++
8000844a:	10 aa       	st.w	r8++,r10
8000844c:	13 0a       	ld.w	r10,r9++
8000844e:	10 aa       	st.w	r8++,r10
80008450:	72 0a       	ld.w	r10,r9[0x0]
80008452:	91 0a       	st.w	r8[0x0],r10
80008454:	72 19       	ld.w	r9,r9[0x4]
80008456:	91 19       	st.w	r8[0x4],r9
80008458:	c0 48       	rjmp	80008460 <_realloc_r+0x258>
8000845a:	08 9b       	mov	r11,r4
8000845c:	e0 a0 1d 07 	rcall	8000be6a <memmove>
80008460:	08 9b       	mov	r11,r4
80008462:	04 9c       	mov	r12,r2
80008464:	e0 a0 1a 60 	rcall	8000b924 <_free_r>
80008468:	04 9c       	mov	r12,r2
8000846a:	c2 a8       	rjmp	800084be <_realloc_r+0x2b6>
8000846c:	00 93       	mov	r3,r0
8000846e:	02 97       	mov	r7,r1
80008470:	e6 06 01 09 	sub	r9,r3,r6
80008474:	6e 18       	ld.w	r8,r7[0x4]
80008476:	58 f9       	cp.w	r9,15
80008478:	e0 88 00 16 	brls	800084a4 <_realloc_r+0x29c>
8000847c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008480:	ed e8 10 08 	or	r8,r6,r8
80008484:	8f 18       	st.w	r7[0x4],r8
80008486:	12 98       	mov	r8,r9
80008488:	a1 a8       	sbr	r8,0x0
8000848a:	ee 06 00 0b 	add	r11,r7,r6
8000848e:	f6 09 00 09 	add	r9,r11,r9
80008492:	97 18       	st.w	r11[0x4],r8
80008494:	72 18       	ld.w	r8,r9[0x4]
80008496:	a1 a8       	sbr	r8,0x0
80008498:	2f 8b       	sub	r11,-8
8000849a:	93 18       	st.w	r9[0x4],r8
8000849c:	04 9c       	mov	r12,r2
8000849e:	e0 a0 1a 43 	rcall	8000b924 <_free_r>
800084a2:	c0 b8       	rjmp	800084b8 <_realloc_r+0x2b0>
800084a4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800084a8:	e7 e8 10 08 	or	r8,r3,r8
800084ac:	8f 18       	st.w	r7[0x4],r8
800084ae:	ee 03 00 03 	add	r3,r7,r3
800084b2:	66 18       	ld.w	r8,r3[0x4]
800084b4:	a1 a8       	sbr	r8,0x0
800084b6:	87 18       	st.w	r3[0x4],r8
800084b8:	04 9c       	mov	r12,r2
800084ba:	ee c5 ff f8 	sub	r5,r7,-8
800084be:	fe b0 f1 c9 	rcall	80006850 <__malloc_unlock>
800084c2:	0a 9c       	mov	r12,r5
800084c4:	2f fd       	sub	sp,-4
800084c6:	d8 32       	popm	r0-r7,pc

800084c8 <_sbrk_r>:
800084c8:	d4 21       	pushm	r4-r7,lr
800084ca:	30 08       	mov	r8,0
800084cc:	18 97       	mov	r7,r12
800084ce:	e0 66 53 d8 	mov	r6,21464
800084d2:	16 9c       	mov	r12,r11
800084d4:	8d 08       	st.w	r6[0x0],r8
800084d6:	c8 5c       	rcall	800085e0 <_sbrk>
800084d8:	5b fc       	cp.w	r12,-1
800084da:	c0 51       	brne	800084e4 <_sbrk_r+0x1c>
800084dc:	6c 08       	ld.w	r8,r6[0x0]
800084de:	58 08       	cp.w	r8,0
800084e0:	ef f8 1a 03 	st.wne	r7[0xc],r8
800084e4:	d8 22       	popm	r4-r7,pc
800084e6:	d7 03       	nop

800084e8 <sprintf>:
800084e8:	d4 01       	pushm	lr
800084ea:	21 7d       	sub	sp,92
800084ec:	e0 68 ff ff 	mov	r8,65535
800084f0:	ea 18 7f ff 	orh	r8,0x7fff
800084f4:	50 58       	stdsp	sp[0x14],r8
800084f6:	50 28       	stdsp	sp[0x8],r8
800084f8:	e0 68 02 08 	mov	r8,520
800084fc:	ba 68       	st.h	sp[0xc],r8
800084fe:	3f f8       	mov	r8,-1
80008500:	ba 78       	st.h	sp[0xe],r8
80008502:	e0 68 0a 44 	mov	r8,2628
80008506:	50 4c       	stdsp	sp[0x10],r12
80008508:	16 9a       	mov	r10,r11
8000850a:	50 0c       	stdsp	sp[0x0],r12
8000850c:	fa c9 ff a0 	sub	r9,sp,-96
80008510:	70 0c       	ld.w	r12,r8[0x0]
80008512:	1a 9b       	mov	r11,sp
80008514:	e0 a0 02 1a 	rcall	80008948 <_vfprintf_r>
80008518:	30 09       	mov	r9,0
8000851a:	40 08       	lddsp	r8,sp[0x0]
8000851c:	b0 89       	st.b	r8[0x0],r9
8000851e:	2e 9d       	sub	sp,-92
80008520:	d8 02       	popm	pc
80008522:	d7 03       	nop

80008524 <strncpy>:
80008524:	30 08       	mov	r8,0
80008526:	10 3a       	cp.w	r10,r8
80008528:	5e 0c       	reteq	r12
8000852a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000852e:	f8 08 0b 09 	st.b	r12[r8],r9
80008532:	2f f8       	sub	r8,-1
80008534:	58 09       	cp.w	r9,0
80008536:	cf 81       	brne	80008526 <strncpy+0x2>
80008538:	10 3a       	cp.w	r10,r8
8000853a:	5e 0c       	reteq	r12
8000853c:	f8 08 0b 09 	st.b	r12[r8],r9
80008540:	2f f8       	sub	r8,-1
80008542:	cf bb       	rjmp	80008538 <strncpy+0x14>

80008544 <_close>:
80008544:	30 28       	mov	r8,2
80008546:	d6 73       	breakpoint
80008548:	3f fc       	mov	r12,-1
8000854a:	35 8b       	mov	r11,88
8000854c:	58 0c       	cp.w	r12,0
8000854e:	5e 4c       	retge	r12
80008550:	e0 6a 53 d8 	mov	r10,21464
80008554:	95 0b       	st.w	r10[0x0],r11
80008556:	5e fc       	retal	r12

80008558 <_lseek>:
80008558:	30 58       	mov	r8,5
8000855a:	d6 73       	breakpoint
8000855c:	3f fc       	mov	r12,-1
8000855e:	35 8b       	mov	r11,88
80008560:	58 0c       	cp.w	r12,0
80008562:	5e 4c       	retge	r12
80008564:	e0 6a 53 d8 	mov	r10,21464
80008568:	95 0b       	st.w	r10[0x0],r11
8000856a:	5e fc       	retal	r12

8000856c <isatty>:
8000856c:	30 b8       	mov	r8,11
8000856e:	d6 73       	breakpoint
80008570:	3f fc       	mov	r12,-1
80008572:	35 8b       	mov	r11,88
80008574:	58 0c       	cp.w	r12,0
80008576:	5e 4c       	retge	r12
80008578:	e0 6a 53 d8 	mov	r10,21464
8000857c:	95 0b       	st.w	r10[0x0],r11
8000857e:	5e fc       	retal	r12

80008580 <_fstat_host>:
80008580:	30 98       	mov	r8,9
80008582:	d6 73       	breakpoint
80008584:	3f fc       	mov	r12,-1
80008586:	35 8b       	mov	r11,88
80008588:	58 0c       	cp.w	r12,0
8000858a:	5e 4c       	retge	r12
8000858c:	e0 6a 53 d8 	mov	r10,21464
80008590:	95 0b       	st.w	r10[0x0],r11
80008592:	5e fc       	retal	r12

80008594 <_fstat>:
80008594:	d4 21       	pushm	r4-r7,lr
80008596:	21 0d       	sub	sp,64
80008598:	16 97       	mov	r7,r11
8000859a:	1a 9b       	mov	r11,sp
8000859c:	cf 2f       	rcall	80008580 <_fstat_host>
8000859e:	c0 34       	brge	800085a4 <_fstat+0x10>
800085a0:	3f fc       	mov	r12,-1
800085a2:	c1 c8       	rjmp	800085da <_fstat+0x46>
800085a4:	40 08       	lddsp	r8,sp[0x0]
800085a6:	ae 08       	st.h	r7[0x0],r8
800085a8:	40 18       	lddsp	r8,sp[0x4]
800085aa:	ae 18       	st.h	r7[0x2],r8
800085ac:	40 28       	lddsp	r8,sp[0x8]
800085ae:	8f 18       	st.w	r7[0x4],r8
800085b0:	40 38       	lddsp	r8,sp[0xc]
800085b2:	ae 48       	st.h	r7[0x8],r8
800085b4:	40 48       	lddsp	r8,sp[0x10]
800085b6:	ae 58       	st.h	r7[0xa],r8
800085b8:	40 58       	lddsp	r8,sp[0x14]
800085ba:	ae 68       	st.h	r7[0xc],r8
800085bc:	40 68       	lddsp	r8,sp[0x18]
800085be:	ae 78       	st.h	r7[0xe],r8
800085c0:	40 88       	lddsp	r8,sp[0x20]
800085c2:	8f 48       	st.w	r7[0x10],r8
800085c4:	40 a8       	lddsp	r8,sp[0x28]
800085c6:	8f b8       	st.w	r7[0x2c],r8
800085c8:	40 c8       	lddsp	r8,sp[0x30]
800085ca:	8f c8       	st.w	r7[0x30],r8
800085cc:	40 d8       	lddsp	r8,sp[0x34]
800085ce:	8f 58       	st.w	r7[0x14],r8
800085d0:	40 e8       	lddsp	r8,sp[0x38]
800085d2:	30 0c       	mov	r12,0
800085d4:	8f 78       	st.w	r7[0x1c],r8
800085d6:	40 f8       	lddsp	r8,sp[0x3c]
800085d8:	8f 98       	st.w	r7[0x24],r8
800085da:	2f 0d       	sub	sp,-64
800085dc:	d8 22       	popm	r4-r7,pc
800085de:	d7 03       	nop

800085e0 <_sbrk>:
800085e0:	d4 01       	pushm	lr
800085e2:	e0 68 0d ac 	mov	r8,3500
800085e6:	70 09       	ld.w	r9,r8[0x0]
800085e8:	58 09       	cp.w	r9,0
800085ea:	c0 41       	brne	800085f2 <_sbrk+0x12>
800085ec:	e0 69 53 e0 	mov	r9,21472
800085f0:	91 09       	st.w	r8[0x0],r9
800085f2:	e0 69 0d ac 	mov	r9,3500
800085f6:	e0 7a 70 00 	mov	r10,94208
800085fa:	72 08       	ld.w	r8,r9[0x0]
800085fc:	f0 0c 00 0c 	add	r12,r8,r12
80008600:	14 3c       	cp.w	r12,r10
80008602:	e0 8b 00 04 	brhi	8000860a <_sbrk+0x2a>
80008606:	93 0c       	st.w	r9[0x0],r12
80008608:	c0 68       	rjmp	80008614 <_sbrk+0x34>
8000860a:	e0 a0 18 15 	rcall	8000b634 <__errno>
8000860e:	30 c8       	mov	r8,12
80008610:	99 08       	st.w	r12[0x0],r8
80008612:	3f f8       	mov	r8,-1
80008614:	10 9c       	mov	r12,r8
80008616:	d8 02       	popm	pc

80008618 <get_arg>:
80008618:	d4 31       	pushm	r0-r7,lr
8000861a:	20 8d       	sub	sp,32
8000861c:	fa c4 ff bc 	sub	r4,sp,-68
80008620:	50 4b       	stdsp	sp[0x10],r11
80008622:	68 2e       	ld.w	lr,r4[0x8]
80008624:	50 58       	stdsp	sp[0x14],r8
80008626:	12 96       	mov	r6,r9
80008628:	7c 0b       	ld.w	r11,lr[0x0]
8000862a:	70 05       	ld.w	r5,r8[0x0]
8000862c:	50 6e       	stdsp	sp[0x18],lr
8000862e:	58 0b       	cp.w	r11,0
80008630:	f4 0b 17 00 	moveq	r11,r10
80008634:	68 03       	ld.w	r3,r4[0x0]
80008636:	68 11       	ld.w	r1,r4[0x4]
80008638:	40 49       	lddsp	r9,sp[0x10]
8000863a:	30 08       	mov	r8,0
8000863c:	c2 89       	rjmp	8000888c <get_arg+0x274>
8000863e:	2f fb       	sub	r11,-1
80008640:	32 5c       	mov	r12,37
80008642:	17 8a       	ld.ub	r10,r11[0x0]
80008644:	f8 0a 18 00 	cp.b	r10,r12
80008648:	5f 1e       	srne	lr
8000864a:	f0 0a 18 00 	cp.b	r10,r8
8000864e:	5f 1c       	srne	r12
80008650:	fd ec 00 0c 	and	r12,lr,r12
80008654:	f0 0c 18 00 	cp.b	r12,r8
80008658:	cf 31       	brne	8000863e <get_arg+0x26>
8000865a:	58 0a       	cp.w	r10,0
8000865c:	e0 80 01 25 	breq	800088a6 <get_arg+0x28e>
80008660:	30 0c       	mov	r12,0
80008662:	3f fa       	mov	r10,-1
80008664:	18 90       	mov	r0,r12
80008666:	50 3a       	stdsp	sp[0xc],r10
80008668:	18 94       	mov	r4,r12
8000866a:	18 92       	mov	r2,r12
8000866c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008670:	16 97       	mov	r7,r11
80008672:	50 7c       	stdsp	sp[0x1c],r12
80008674:	fe cc 9c 6c 	sub	r12,pc,-25492
80008678:	0f 3a       	ld.ub	r10,r7++
8000867a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000867e:	40 7c       	lddsp	r12,sp[0x1c]
80008680:	1c 0c       	add	r12,lr
80008682:	fe ce 9d 42 	sub	lr,pc,-25278
80008686:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000868a:	20 1e       	sub	lr,1
8000868c:	50 0e       	stdsp	sp[0x0],lr
8000868e:	fe ce 9d ba 	sub	lr,pc,-25158
80008692:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008696:	50 7c       	stdsp	sp[0x1c],r12
80008698:	40 0c       	lddsp	r12,sp[0x0]
8000869a:	58 7c       	cp.w	r12,7
8000869c:	e0 8b 00 f1 	brhi	8000887e <get_arg+0x266>
800086a0:	fe ce 9f 6c 	sub	lr,pc,-24724
800086a4:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
800086a8:	36 8b       	mov	r11,104
800086aa:	f6 0a 18 00 	cp.b	r10,r11
800086ae:	e0 80 00 e8 	breq	8000887e <get_arg+0x266>
800086b2:	37 1b       	mov	r11,113
800086b4:	f6 0a 18 00 	cp.b	r10,r11
800086b8:	c0 70       	breq	800086c6 <get_arg+0xae>
800086ba:	34 cb       	mov	r11,76
800086bc:	f6 0a 18 00 	cp.b	r10,r11
800086c0:	c0 51       	brne	800086ca <get_arg+0xb2>
800086c2:	a3 b4       	sbr	r4,0x3
800086c4:	cd d8       	rjmp	8000887e <get_arg+0x266>
800086c6:	a5 b4       	sbr	r4,0x5
800086c8:	cd b8       	rjmp	8000887e <get_arg+0x266>
800086ca:	08 9a       	mov	r10,r4
800086cc:	0e 9b       	mov	r11,r7
800086ce:	a5 aa       	sbr	r10,0x4
800086d0:	17 3c       	ld.ub	r12,r11++
800086d2:	a5 b4       	sbr	r4,0x5
800086d4:	36 ce       	mov	lr,108
800086d6:	fc 0c 18 00 	cp.b	r12,lr
800086da:	e0 80 00 d3 	breq	80008880 <get_arg+0x268>
800086de:	14 94       	mov	r4,r10
800086e0:	cc f8       	rjmp	8000887e <get_arg+0x266>
800086e2:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800086e6:	36 7c       	mov	r12,103
800086e8:	f8 0a 18 00 	cp.b	r10,r12
800086ec:	e0 8b 00 27 	brhi	8000873a <get_arg+0x122>
800086f0:	36 5b       	mov	r11,101
800086f2:	f6 0a 18 00 	cp.b	r10,r11
800086f6:	c4 82       	brcc	80008786 <get_arg+0x16e>
800086f8:	34 fb       	mov	r11,79
800086fa:	f6 0a 18 00 	cp.b	r10,r11
800086fe:	c4 80       	breq	8000878e <get_arg+0x176>
80008700:	e0 8b 00 0c 	brhi	80008718 <get_arg+0x100>
80008704:	34 5b       	mov	r11,69
80008706:	f6 0a 18 00 	cp.b	r10,r11
8000870a:	c3 e0       	breq	80008786 <get_arg+0x16e>
8000870c:	34 7b       	mov	r11,71
8000870e:	f6 0a 18 00 	cp.b	r10,r11
80008712:	c3 a0       	breq	80008786 <get_arg+0x16e>
80008714:	34 4b       	mov	r11,68
80008716:	c0 88       	rjmp	80008726 <get_arg+0x10e>
80008718:	35 8b       	mov	r11,88
8000871a:	f6 0a 18 00 	cp.b	r10,r11
8000871e:	c2 c0       	breq	80008776 <get_arg+0x15e>
80008720:	e0 8b 00 07 	brhi	8000872e <get_arg+0x116>
80008724:	35 5b       	mov	r11,85
80008726:	f6 0a 18 00 	cp.b	r10,r11
8000872a:	c3 51       	brne	80008794 <get_arg+0x17c>
8000872c:	c3 18       	rjmp	8000878e <get_arg+0x176>
8000872e:	36 3b       	mov	r11,99
80008730:	f6 0a 18 00 	cp.b	r10,r11
80008734:	c2 f0       	breq	80008792 <get_arg+0x17a>
80008736:	36 4b       	mov	r11,100
80008738:	c0 e8       	rjmp	80008754 <get_arg+0x13c>
8000873a:	37 0b       	mov	r11,112
8000873c:	f6 0a 18 00 	cp.b	r10,r11
80008740:	c2 50       	breq	8000878a <get_arg+0x172>
80008742:	e0 8b 00 0d 	brhi	8000875c <get_arg+0x144>
80008746:	36 eb       	mov	r11,110
80008748:	f6 0a 18 00 	cp.b	r10,r11
8000874c:	c1 f0       	breq	8000878a <get_arg+0x172>
8000874e:	e0 8b 00 14 	brhi	80008776 <get_arg+0x15e>
80008752:	36 9b       	mov	r11,105
80008754:	f6 0a 18 00 	cp.b	r10,r11
80008758:	c1 e1       	brne	80008794 <get_arg+0x17c>
8000875a:	c0 e8       	rjmp	80008776 <get_arg+0x15e>
8000875c:	37 5b       	mov	r11,117
8000875e:	f6 0a 18 00 	cp.b	r10,r11
80008762:	c0 a0       	breq	80008776 <get_arg+0x15e>
80008764:	37 8b       	mov	r11,120
80008766:	f6 0a 18 00 	cp.b	r10,r11
8000876a:	c0 60       	breq	80008776 <get_arg+0x15e>
8000876c:	37 3b       	mov	r11,115
8000876e:	f6 0a 18 00 	cp.b	r10,r11
80008772:	c1 11       	brne	80008794 <get_arg+0x17c>
80008774:	c0 b8       	rjmp	8000878a <get_arg+0x172>
80008776:	ed b4 00 04 	bld	r4,0x4
8000877a:	c0 a0       	breq	8000878e <get_arg+0x176>
8000877c:	ed b4 00 05 	bld	r4,0x5
80008780:	c0 91       	brne	80008792 <get_arg+0x17a>
80008782:	30 20       	mov	r0,2
80008784:	c0 88       	rjmp	80008794 <get_arg+0x17c>
80008786:	30 40       	mov	r0,4
80008788:	c0 68       	rjmp	80008794 <get_arg+0x17c>
8000878a:	30 30       	mov	r0,3
8000878c:	c0 48       	rjmp	80008794 <get_arg+0x17c>
8000878e:	30 10       	mov	r0,1
80008790:	c0 28       	rjmp	80008794 <get_arg+0x17c>
80008792:	30 00       	mov	r0,0
80008794:	40 3b       	lddsp	r11,sp[0xc]
80008796:	5b fb       	cp.w	r11,-1
80008798:	c0 40       	breq	800087a0 <get_arg+0x188>
8000879a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000879e:	c7 08       	rjmp	8000887e <get_arg+0x266>
800087a0:	58 60       	cp.w	r0,6
800087a2:	e0 8b 00 6e 	brhi	8000887e <get_arg+0x266>
800087a6:	6c 0a       	ld.w	r10,r6[0x0]
800087a8:	ea cc ff ff 	sub	r12,r5,-1
800087ac:	fe ce a0 58 	sub	lr,pc,-24488
800087b0:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800087b4:	f4 cb ff f8 	sub	r11,r10,-8
800087b8:	8d 0b       	st.w	r6[0x0],r11
800087ba:	f4 ea 00 00 	ld.d	r10,r10[0]
800087be:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800087c2:	c0 f8       	rjmp	800087e0 <get_arg+0x1c8>
800087c4:	f4 cb ff fc 	sub	r11,r10,-4
800087c8:	8d 0b       	st.w	r6[0x0],r11
800087ca:	74 0a       	ld.w	r10,r10[0x0]
800087cc:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800087d0:	c0 88       	rjmp	800087e0 <get_arg+0x1c8>
800087d2:	f4 cb ff f8 	sub	r11,r10,-8
800087d6:	8d 0b       	st.w	r6[0x0],r11
800087d8:	f4 ea 00 00 	ld.d	r10,r10[0]
800087dc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800087e0:	0e 9b       	mov	r11,r7
800087e2:	18 95       	mov	r5,r12
800087e4:	c4 e8       	rjmp	80008880 <get_arg+0x268>
800087e6:	62 0a       	ld.w	r10,r1[0x0]
800087e8:	5b fa       	cp.w	r10,-1
800087ea:	c0 b1       	brne	80008800 <get_arg+0x1e8>
800087ec:	50 19       	stdsp	sp[0x4],r9
800087ee:	50 28       	stdsp	sp[0x8],r8
800087f0:	e0 6a 00 80 	mov	r10,128
800087f4:	30 0b       	mov	r11,0
800087f6:	02 9c       	mov	r12,r1
800087f8:	fe b0 fd 00 	rcall	800081f8 <memset>
800087fc:	40 28       	lddsp	r8,sp[0x8]
800087fe:	40 19       	lddsp	r9,sp[0x4]
80008800:	e4 cc 00 01 	sub	r12,r2,1
80008804:	0e 9b       	mov	r11,r7
80008806:	50 3c       	stdsp	sp[0xc],r12
80008808:	f2 0c 0c 49 	max	r9,r9,r12
8000880c:	c3 a8       	rjmp	80008880 <get_arg+0x268>
8000880e:	62 0a       	ld.w	r10,r1[0x0]
80008810:	5b fa       	cp.w	r10,-1
80008812:	c0 b1       	brne	80008828 <get_arg+0x210>
80008814:	50 19       	stdsp	sp[0x4],r9
80008816:	50 28       	stdsp	sp[0x8],r8
80008818:	e0 6a 00 80 	mov	r10,128
8000881c:	30 0b       	mov	r11,0
8000881e:	02 9c       	mov	r12,r1
80008820:	fe b0 fc ec 	rcall	800081f8 <memset>
80008824:	40 28       	lddsp	r8,sp[0x8]
80008826:	40 19       	lddsp	r9,sp[0x4]
80008828:	20 12       	sub	r2,1
8000882a:	30 0a       	mov	r10,0
8000882c:	0e 9b       	mov	r11,r7
8000882e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008832:	f2 02 0c 49 	max	r9,r9,r2
80008836:	c2 58       	rjmp	80008880 <get_arg+0x268>
80008838:	16 97       	mov	r7,r11
8000883a:	6c 0a       	ld.w	r10,r6[0x0]
8000883c:	f4 cb ff fc 	sub	r11,r10,-4
80008840:	8d 0b       	st.w	r6[0x0],r11
80008842:	74 0a       	ld.w	r10,r10[0x0]
80008844:	0e 9b       	mov	r11,r7
80008846:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000884a:	2f f5       	sub	r5,-1
8000884c:	c1 a8       	rjmp	80008880 <get_arg+0x268>
8000884e:	f4 c2 00 30 	sub	r2,r10,48
80008852:	c0 68       	rjmp	8000885e <get_arg+0x246>
80008854:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008858:	2f f7       	sub	r7,-1
8000885a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000885e:	0f 8a       	ld.ub	r10,r7[0x0]
80008860:	58 0a       	cp.w	r10,0
80008862:	c0 e0       	breq	8000887e <get_arg+0x266>
80008864:	23 0a       	sub	r10,48
80008866:	58 9a       	cp.w	r10,9
80008868:	fe 98 ff f6 	brls	80008854 <get_arg+0x23c>
8000886c:	c0 98       	rjmp	8000887e <get_arg+0x266>
8000886e:	2f f7       	sub	r7,-1
80008870:	0f 8a       	ld.ub	r10,r7[0x0]
80008872:	58 0a       	cp.w	r10,0
80008874:	c0 50       	breq	8000887e <get_arg+0x266>
80008876:	23 0a       	sub	r10,48
80008878:	58 9a       	cp.w	r10,9
8000887a:	fe 98 ff fa 	brls	8000886e <get_arg+0x256>
8000887e:	0e 9b       	mov	r11,r7
80008880:	40 7c       	lddsp	r12,sp[0x1c]
80008882:	30 ba       	mov	r10,11
80008884:	f4 0c 18 00 	cp.b	r12,r10
80008888:	fe 91 fe f2 	brne	8000866c <get_arg+0x54>
8000888c:	40 42       	lddsp	r2,sp[0x10]
8000888e:	17 8c       	ld.ub	r12,r11[0x0]
80008890:	0a 32       	cp.w	r2,r5
80008892:	5f 4a       	srge	r10
80008894:	f0 0c 18 00 	cp.b	r12,r8
80008898:	5f 1c       	srne	r12
8000889a:	f9 ea 00 0a 	and	r10,r12,r10
8000889e:	f0 0a 18 00 	cp.b	r10,r8
800088a2:	fe 91 fe cf 	brne	80008640 <get_arg+0x28>
800088a6:	30 08       	mov	r8,0
800088a8:	40 4e       	lddsp	lr,sp[0x10]
800088aa:	17 8a       	ld.ub	r10,r11[0x0]
800088ac:	e2 05 00 21 	add	r1,r1,r5<<0x2
800088b0:	f0 0a 18 00 	cp.b	r10,r8
800088b4:	fc 09 17 10 	movne	r9,lr
800088b8:	e6 05 00 38 	add	r8,r3,r5<<0x3
800088bc:	06 9e       	mov	lr,r3
800088be:	c2 a8       	rjmp	80008912 <get_arg+0x2fa>
800088c0:	62 0a       	ld.w	r10,r1[0x0]
800088c2:	58 3a       	cp.w	r10,3
800088c4:	c1 e0       	breq	80008900 <get_arg+0x2e8>
800088c6:	e0 89 00 07 	brgt	800088d4 <get_arg+0x2bc>
800088ca:	58 1a       	cp.w	r10,1
800088cc:	c1 a0       	breq	80008900 <get_arg+0x2e8>
800088ce:	58 2a       	cp.w	r10,2
800088d0:	c1 81       	brne	80008900 <get_arg+0x2e8>
800088d2:	c0 58       	rjmp	800088dc <get_arg+0x2c4>
800088d4:	58 5a       	cp.w	r10,5
800088d6:	c0 c0       	breq	800088ee <get_arg+0x2d6>
800088d8:	c0 b5       	brlt	800088ee <get_arg+0x2d6>
800088da:	c1 38       	rjmp	80008900 <get_arg+0x2e8>
800088dc:	6c 0a       	ld.w	r10,r6[0x0]
800088de:	f4 cc ff f8 	sub	r12,r10,-8
800088e2:	8d 0c       	st.w	r6[0x0],r12
800088e4:	f4 e2 00 00 	ld.d	r2,r10[0]
800088e8:	f0 e3 00 00 	st.d	r8[0],r2
800088ec:	c1 08       	rjmp	8000890c <get_arg+0x2f4>
800088ee:	6c 0a       	ld.w	r10,r6[0x0]
800088f0:	f4 cc ff f8 	sub	r12,r10,-8
800088f4:	8d 0c       	st.w	r6[0x0],r12
800088f6:	f4 e2 00 00 	ld.d	r2,r10[0]
800088fa:	f0 e3 00 00 	st.d	r8[0],r2
800088fe:	c0 78       	rjmp	8000890c <get_arg+0x2f4>
80008900:	6c 0a       	ld.w	r10,r6[0x0]
80008902:	f4 cc ff fc 	sub	r12,r10,-4
80008906:	8d 0c       	st.w	r6[0x0],r12
80008908:	74 0a       	ld.w	r10,r10[0x0]
8000890a:	91 0a       	st.w	r8[0x0],r10
8000890c:	2f f5       	sub	r5,-1
8000890e:	2f 88       	sub	r8,-8
80008910:	2f c1       	sub	r1,-4
80008912:	12 35       	cp.w	r5,r9
80008914:	fe 9a ff d6 	brle	800088c0 <get_arg+0x2a8>
80008918:	1c 93       	mov	r3,lr
8000891a:	40 52       	lddsp	r2,sp[0x14]
8000891c:	40 6e       	lddsp	lr,sp[0x18]
8000891e:	85 05       	st.w	r2[0x0],r5
80008920:	9d 0b       	st.w	lr[0x0],r11
80008922:	40 4b       	lddsp	r11,sp[0x10]
80008924:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008928:	2f 8d       	sub	sp,-32
8000892a:	d8 32       	popm	r0-r7,pc

8000892c <__sprint_r>:
8000892c:	d4 21       	pushm	r4-r7,lr
8000892e:	14 97       	mov	r7,r10
80008930:	74 28       	ld.w	r8,r10[0x8]
80008932:	58 08       	cp.w	r8,0
80008934:	c0 41       	brne	8000893c <__sprint_r+0x10>
80008936:	95 18       	st.w	r10[0x4],r8
80008938:	10 9c       	mov	r12,r8
8000893a:	d8 22       	popm	r4-r7,pc
8000893c:	e0 a0 18 ba 	rcall	8000bab0 <__sfvwrite_r>
80008940:	30 08       	mov	r8,0
80008942:	8f 18       	st.w	r7[0x4],r8
80008944:	8f 28       	st.w	r7[0x8],r8
80008946:	d8 22       	popm	r4-r7,pc

80008948 <_vfprintf_r>:
80008948:	d4 31       	pushm	r0-r7,lr
8000894a:	fa cd 06 bc 	sub	sp,sp,1724
8000894e:	51 09       	stdsp	sp[0x40],r9
80008950:	16 91       	mov	r1,r11
80008952:	14 97       	mov	r7,r10
80008954:	18 95       	mov	r5,r12
80008956:	e0 a0 1a 1d 	rcall	8000bd90 <_localeconv_r>
8000895a:	78 0c       	ld.w	r12,r12[0x0]
8000895c:	50 cc       	stdsp	sp[0x30],r12
8000895e:	58 05       	cp.w	r5,0
80008960:	c0 70       	breq	8000896e <_vfprintf_r+0x26>
80008962:	6a 68       	ld.w	r8,r5[0x18]
80008964:	58 08       	cp.w	r8,0
80008966:	c0 41       	brne	8000896e <_vfprintf_r+0x26>
80008968:	0a 9c       	mov	r12,r5
8000896a:	e0 a0 17 43 	rcall	8000b7f0 <__sinit>
8000896e:	fe c8 9e 56 	sub	r8,pc,-25002
80008972:	10 31       	cp.w	r1,r8
80008974:	c0 31       	brne	8000897a <_vfprintf_r+0x32>
80008976:	6a 01       	ld.w	r1,r5[0x0]
80008978:	c0 c8       	rjmp	80008990 <_vfprintf_r+0x48>
8000897a:	fe c8 9e 42 	sub	r8,pc,-25022
8000897e:	10 31       	cp.w	r1,r8
80008980:	c0 31       	brne	80008986 <_vfprintf_r+0x3e>
80008982:	6a 11       	ld.w	r1,r5[0x4]
80008984:	c0 68       	rjmp	80008990 <_vfprintf_r+0x48>
80008986:	fe c8 9e 2e 	sub	r8,pc,-25042
8000898a:	10 31       	cp.w	r1,r8
8000898c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008990:	82 68       	ld.sh	r8,r1[0xc]
80008992:	ed b8 00 03 	bld	r8,0x3
80008996:	c0 41       	brne	8000899e <_vfprintf_r+0x56>
80008998:	62 48       	ld.w	r8,r1[0x10]
8000899a:	58 08       	cp.w	r8,0
8000899c:	c0 71       	brne	800089aa <_vfprintf_r+0x62>
8000899e:	02 9b       	mov	r11,r1
800089a0:	0a 9c       	mov	r12,r5
800089a2:	e0 a0 0f 5d 	rcall	8000a85c <__swsetup_r>
800089a6:	e0 81 0f 54 	brne	8000a84e <_vfprintf_r+0x1f06>
800089aa:	82 68       	ld.sh	r8,r1[0xc]
800089ac:	10 99       	mov	r9,r8
800089ae:	e2 19 00 1a 	andl	r9,0x1a,COH
800089b2:	58 a9       	cp.w	r9,10
800089b4:	c3 c1       	brne	80008a2c <_vfprintf_r+0xe4>
800089b6:	82 79       	ld.sh	r9,r1[0xe]
800089b8:	30 0a       	mov	r10,0
800089ba:	f4 09 19 00 	cp.h	r9,r10
800089be:	c3 75       	brlt	80008a2c <_vfprintf_r+0xe4>
800089c0:	a1 d8       	cbr	r8,0x1
800089c2:	fb 58 05 d0 	st.h	sp[1488],r8
800089c6:	62 88       	ld.w	r8,r1[0x20]
800089c8:	fb 48 05 e4 	st.w	sp[1508],r8
800089cc:	62 a8       	ld.w	r8,r1[0x28]
800089ce:	fb 48 05 ec 	st.w	sp[1516],r8
800089d2:	fa c8 ff bc 	sub	r8,sp,-68
800089d6:	fb 48 05 d4 	st.w	sp[1492],r8
800089da:	fb 48 05 c4 	st.w	sp[1476],r8
800089de:	e0 68 04 00 	mov	r8,1024
800089e2:	fb 48 05 d8 	st.w	sp[1496],r8
800089e6:	fb 48 05 cc 	st.w	sp[1484],r8
800089ea:	30 08       	mov	r8,0
800089ec:	fb 59 05 d2 	st.h	sp[1490],r9
800089f0:	0e 9a       	mov	r10,r7
800089f2:	41 09       	lddsp	r9,sp[0x40]
800089f4:	fa c7 fa 3c 	sub	r7,sp,-1476
800089f8:	fb 48 05 dc 	st.w	sp[1500],r8
800089fc:	0a 9c       	mov	r12,r5
800089fe:	0e 9b       	mov	r11,r7
80008a00:	ca 4f       	rcall	80008948 <_vfprintf_r>
80008a02:	50 bc       	stdsp	sp[0x2c],r12
80008a04:	c0 95       	brlt	80008a16 <_vfprintf_r+0xce>
80008a06:	0e 9b       	mov	r11,r7
80008a08:	0a 9c       	mov	r12,r5
80008a0a:	e0 a0 16 1b 	rcall	8000b640 <_fflush_r>
80008a0e:	40 be       	lddsp	lr,sp[0x2c]
80008a10:	f9 be 01 ff 	movne	lr,-1
80008a14:	50 be       	stdsp	sp[0x2c],lr
80008a16:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80008a1a:	ed b8 00 06 	bld	r8,0x6
80008a1e:	e0 81 0f 1a 	brne	8000a852 <_vfprintf_r+0x1f0a>
80008a22:	82 68       	ld.sh	r8,r1[0xc]
80008a24:	a7 a8       	sbr	r8,0x6
80008a26:	a2 68       	st.h	r1[0xc],r8
80008a28:	e0 8f 0f 15 	bral	8000a852 <_vfprintf_r+0x1f0a>
80008a2c:	30 08       	mov	r8,0
80008a2e:	fb 48 06 b4 	st.w	sp[1716],r8
80008a32:	fb 48 06 90 	st.w	sp[1680],r8
80008a36:	fb 48 06 8c 	st.w	sp[1676],r8
80008a3a:	fb 48 06 b0 	st.w	sp[1712],r8
80008a3e:	30 08       	mov	r8,0
80008a40:	30 09       	mov	r9,0
80008a42:	50 a7       	stdsp	sp[0x28],r7
80008a44:	50 78       	stdsp	sp[0x1c],r8
80008a46:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a4a:	3f f8       	mov	r8,-1
80008a4c:	50 59       	stdsp	sp[0x14],r9
80008a4e:	fb 43 06 88 	st.w	sp[1672],r3
80008a52:	fb 48 05 44 	st.w	sp[1348],r8
80008a56:	12 9c       	mov	r12,r9
80008a58:	50 69       	stdsp	sp[0x18],r9
80008a5a:	50 d9       	stdsp	sp[0x34],r9
80008a5c:	50 e9       	stdsp	sp[0x38],r9
80008a5e:	50 b9       	stdsp	sp[0x2c],r9
80008a60:	12 97       	mov	r7,r9
80008a62:	0a 94       	mov	r4,r5
80008a64:	40 a2       	lddsp	r2,sp[0x28]
80008a66:	32 5a       	mov	r10,37
80008a68:	30 08       	mov	r8,0
80008a6a:	c0 28       	rjmp	80008a6e <_vfprintf_r+0x126>
80008a6c:	2f f2       	sub	r2,-1
80008a6e:	05 89       	ld.ub	r9,r2[0x0]
80008a70:	f0 09 18 00 	cp.b	r9,r8
80008a74:	5f 1b       	srne	r11
80008a76:	f4 09 18 00 	cp.b	r9,r10
80008a7a:	5f 19       	srne	r9
80008a7c:	f3 eb 00 0b 	and	r11,r9,r11
80008a80:	f0 0b 18 00 	cp.b	r11,r8
80008a84:	cf 41       	brne	80008a6c <_vfprintf_r+0x124>
80008a86:	40 ab       	lddsp	r11,sp[0x28]
80008a88:	e4 0b 01 06 	sub	r6,r2,r11
80008a8c:	c1 e0       	breq	80008ac8 <_vfprintf_r+0x180>
80008a8e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a92:	0c 08       	add	r8,r6
80008a94:	87 0b       	st.w	r3[0x0],r11
80008a96:	fb 48 06 90 	st.w	sp[1680],r8
80008a9a:	87 16       	st.w	r3[0x4],r6
80008a9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008aa0:	2f f8       	sub	r8,-1
80008aa2:	fb 48 06 8c 	st.w	sp[1676],r8
80008aa6:	58 78       	cp.w	r8,7
80008aa8:	e0 89 00 04 	brgt	80008ab0 <_vfprintf_r+0x168>
80008aac:	2f 83       	sub	r3,-8
80008aae:	c0 a8       	rjmp	80008ac2 <_vfprintf_r+0x17a>
80008ab0:	fa ca f9 78 	sub	r10,sp,-1672
80008ab4:	02 9b       	mov	r11,r1
80008ab6:	08 9c       	mov	r12,r4
80008ab8:	c3 af       	rcall	8000892c <__sprint_r>
80008aba:	e0 81 0e c6 	brne	8000a846 <_vfprintf_r+0x1efe>
80008abe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ac2:	40 ba       	lddsp	r10,sp[0x2c]
80008ac4:	0c 0a       	add	r10,r6
80008ac6:	50 ba       	stdsp	sp[0x2c],r10
80008ac8:	05 89       	ld.ub	r9,r2[0x0]
80008aca:	30 08       	mov	r8,0
80008acc:	f0 09 18 00 	cp.b	r9,r8
80008ad0:	e0 80 0e aa 	breq	8000a824 <_vfprintf_r+0x1edc>
80008ad4:	30 09       	mov	r9,0
80008ad6:	fb 68 06 bb 	st.b	sp[1723],r8
80008ada:	0e 96       	mov	r6,r7
80008adc:	e4 c8 ff ff 	sub	r8,r2,-1
80008ae0:	3f fe       	mov	lr,-1
80008ae2:	50 93       	stdsp	sp[0x24],r3
80008ae4:	50 41       	stdsp	sp[0x10],r1
80008ae6:	0e 93       	mov	r3,r7
80008ae8:	04 91       	mov	r1,r2
80008aea:	50 89       	stdsp	sp[0x20],r9
80008aec:	50 a8       	stdsp	sp[0x28],r8
80008aee:	50 2e       	stdsp	sp[0x8],lr
80008af0:	50 39       	stdsp	sp[0xc],r9
80008af2:	12 95       	mov	r5,r9
80008af4:	12 90       	mov	r0,r9
80008af6:	10 97       	mov	r7,r8
80008af8:	08 92       	mov	r2,r4
80008afa:	c0 78       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008afc:	3f fc       	mov	r12,-1
80008afe:	08 97       	mov	r7,r4
80008b00:	50 2c       	stdsp	sp[0x8],r12
80008b02:	c0 38       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008b04:	30 0b       	mov	r11,0
80008b06:	50 3b       	stdsp	sp[0xc],r11
80008b08:	0f 38       	ld.ub	r8,r7++
80008b0a:	c0 28       	rjmp	80008b0e <_vfprintf_r+0x1c6>
80008b0c:	12 90       	mov	r0,r9
80008b0e:	f0 c9 00 20 	sub	r9,r8,32
80008b12:	e0 49 00 58 	cp.w	r9,88
80008b16:	e0 8b 0a 30 	brhi	80009f76 <_vfprintf_r+0x162e>
80008b1a:	fe ca a3 aa 	sub	r10,pc,-23638
80008b1e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008b22:	50 a7       	stdsp	sp[0x28],r7
80008b24:	50 80       	stdsp	sp[0x20],r0
80008b26:	0c 97       	mov	r7,r6
80008b28:	04 94       	mov	r4,r2
80008b2a:	06 96       	mov	r6,r3
80008b2c:	02 92       	mov	r2,r1
80008b2e:	fe c9 a1 82 	sub	r9,pc,-24190
80008b32:	40 93       	lddsp	r3,sp[0x24]
80008b34:	10 90       	mov	r0,r8
80008b36:	40 41       	lddsp	r1,sp[0x10]
80008b38:	50 d9       	stdsp	sp[0x34],r9
80008b3a:	e0 8f 08 8e 	bral	80009c56 <_vfprintf_r+0x130e>
80008b3e:	30 08       	mov	r8,0
80008b40:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008b44:	f0 09 18 00 	cp.b	r9,r8
80008b48:	ce 01       	brne	80008b08 <_vfprintf_r+0x1c0>
80008b4a:	32 08       	mov	r8,32
80008b4c:	c6 e8       	rjmp	80008c28 <_vfprintf_r+0x2e0>
80008b4e:	a1 a5       	sbr	r5,0x0
80008b50:	cd cb       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008b52:	0f 89       	ld.ub	r9,r7[0x0]
80008b54:	f2 c8 00 30 	sub	r8,r9,48
80008b58:	58 98       	cp.w	r8,9
80008b5a:	e0 8b 00 1d 	brhi	80008b94 <_vfprintf_r+0x24c>
80008b5e:	ee c8 ff ff 	sub	r8,r7,-1
80008b62:	30 0b       	mov	r11,0
80008b64:	23 09       	sub	r9,48
80008b66:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008b6a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008b6e:	11 39       	ld.ub	r9,r8++
80008b70:	f2 ca 00 30 	sub	r10,r9,48
80008b74:	58 9a       	cp.w	r10,9
80008b76:	fe 98 ff f7 	brls	80008b64 <_vfprintf_r+0x21c>
80008b7a:	e0 49 00 24 	cp.w	r9,36
80008b7e:	cc 31       	brne	80008b04 <_vfprintf_r+0x1bc>
80008b80:	e0 4b 00 20 	cp.w	r11,32
80008b84:	e0 89 0e 60 	brgt	8000a844 <_vfprintf_r+0x1efc>
80008b88:	20 1b       	sub	r11,1
80008b8a:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008b8e:	12 3b       	cp.w	r11,r9
80008b90:	c0 95       	brlt	80008ba2 <_vfprintf_r+0x25a>
80008b92:	c1 08       	rjmp	80008bb2 <_vfprintf_r+0x26a>
80008b94:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008b98:	ec ca ff ff 	sub	r10,r6,-1
80008b9c:	12 36       	cp.w	r6,r9
80008b9e:	c1 f5       	brlt	80008bdc <_vfprintf_r+0x294>
80008ba0:	c2 68       	rjmp	80008bec <_vfprintf_r+0x2a4>
80008ba2:	fa ce f9 44 	sub	lr,sp,-1724
80008ba6:	10 97       	mov	r7,r8
80008ba8:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008bac:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008bb0:	c3 58       	rjmp	80008c1a <_vfprintf_r+0x2d2>
80008bb2:	10 97       	mov	r7,r8
80008bb4:	fa c8 f9 50 	sub	r8,sp,-1712
80008bb8:	1a d8       	st.w	--sp,r8
80008bba:	fa c8 fa b8 	sub	r8,sp,-1352
80008bbe:	1a d8       	st.w	--sp,r8
80008bc0:	fa c8 fb b4 	sub	r8,sp,-1100
80008bc4:	02 9a       	mov	r10,r1
80008bc6:	1a d8       	st.w	--sp,r8
80008bc8:	04 9c       	mov	r12,r2
80008bca:	fa c8 f9 40 	sub	r8,sp,-1728
80008bce:	fa c9 ff b4 	sub	r9,sp,-76
80008bd2:	fe b0 fd 23 	rcall	80008618 <get_arg>
80008bd6:	2f dd       	sub	sp,-12
80008bd8:	78 00       	ld.w	r0,r12[0x0]
80008bda:	c2 08       	rjmp	80008c1a <_vfprintf_r+0x2d2>
80008bdc:	fa cc f9 44 	sub	r12,sp,-1724
80008be0:	14 96       	mov	r6,r10
80008be2:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008be6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008bea:	c1 88       	rjmp	80008c1a <_vfprintf_r+0x2d2>
80008bec:	41 08       	lddsp	r8,sp[0x40]
80008bee:	59 f9       	cp.w	r9,31
80008bf0:	e0 89 00 11 	brgt	80008c12 <_vfprintf_r+0x2ca>
80008bf4:	f0 cb ff fc 	sub	r11,r8,-4
80008bf8:	51 0b       	stdsp	sp[0x40],r11
80008bfa:	70 00       	ld.w	r0,r8[0x0]
80008bfc:	fa cb f9 44 	sub	r11,sp,-1724
80008c00:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008c04:	f1 40 fd 88 	st.w	r8[-632],r0
80008c08:	2f f9       	sub	r9,-1
80008c0a:	14 96       	mov	r6,r10
80008c0c:	fb 49 06 b4 	st.w	sp[1716],r9
80008c10:	c0 58       	rjmp	80008c1a <_vfprintf_r+0x2d2>
80008c12:	70 00       	ld.w	r0,r8[0x0]
80008c14:	14 96       	mov	r6,r10
80008c16:	2f c8       	sub	r8,-4
80008c18:	51 08       	stdsp	sp[0x40],r8
80008c1a:	58 00       	cp.w	r0,0
80008c1c:	fe 94 ff 76 	brge	80008b08 <_vfprintf_r+0x1c0>
80008c20:	5c 30       	neg	r0
80008c22:	a3 a5       	sbr	r5,0x2
80008c24:	c7 2b       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008c26:	32 b8       	mov	r8,43
80008c28:	fb 68 06 bb 	st.b	sp[1723],r8
80008c2c:	c6 eb       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008c2e:	0f 38       	ld.ub	r8,r7++
80008c30:	e0 48 00 2a 	cp.w	r8,42
80008c34:	c0 30       	breq	80008c3a <_vfprintf_r+0x2f2>
80008c36:	30 09       	mov	r9,0
80008c38:	c7 98       	rjmp	80008d2a <_vfprintf_r+0x3e2>
80008c3a:	0f 88       	ld.ub	r8,r7[0x0]
80008c3c:	f0 c9 00 30 	sub	r9,r8,48
80008c40:	58 99       	cp.w	r9,9
80008c42:	e0 8b 00 1f 	brhi	80008c80 <_vfprintf_r+0x338>
80008c46:	ee c4 ff ff 	sub	r4,r7,-1
80008c4a:	30 0b       	mov	r11,0
80008c4c:	23 08       	sub	r8,48
80008c4e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008c52:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008c56:	09 38       	ld.ub	r8,r4++
80008c58:	f0 c9 00 30 	sub	r9,r8,48
80008c5c:	58 99       	cp.w	r9,9
80008c5e:	fe 98 ff f7 	brls	80008c4c <_vfprintf_r+0x304>
80008c62:	e0 48 00 24 	cp.w	r8,36
80008c66:	fe 91 ff 4f 	brne	80008b04 <_vfprintf_r+0x1bc>
80008c6a:	e0 4b 00 20 	cp.w	r11,32
80008c6e:	e0 89 0d eb 	brgt	8000a844 <_vfprintf_r+0x1efc>
80008c72:	20 1b       	sub	r11,1
80008c74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c78:	10 3b       	cp.w	r11,r8
80008c7a:	c0 a5       	brlt	80008c8e <_vfprintf_r+0x346>
80008c7c:	c1 18       	rjmp	80008c9e <_vfprintf_r+0x356>
80008c7e:	d7 03       	nop
80008c80:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008c84:	ec c9 ff ff 	sub	r9,r6,-1
80008c88:	14 36       	cp.w	r6,r10
80008c8a:	c1 f5       	brlt	80008cc8 <_vfprintf_r+0x380>
80008c8c:	c2 88       	rjmp	80008cdc <_vfprintf_r+0x394>
80008c8e:	fa ca f9 44 	sub	r10,sp,-1724
80008c92:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008c96:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008c9a:	50 2b       	stdsp	sp[0x8],r11
80008c9c:	c3 c8       	rjmp	80008d14 <_vfprintf_r+0x3cc>
80008c9e:	fa c8 f9 50 	sub	r8,sp,-1712
80008ca2:	1a d8       	st.w	--sp,r8
80008ca4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ca8:	1a d8       	st.w	--sp,r8
80008caa:	fa c8 fb b4 	sub	r8,sp,-1100
80008cae:	02 9a       	mov	r10,r1
80008cb0:	1a d8       	st.w	--sp,r8
80008cb2:	04 9c       	mov	r12,r2
80008cb4:	fa c8 f9 40 	sub	r8,sp,-1728
80008cb8:	fa c9 ff b4 	sub	r9,sp,-76
80008cbc:	fe b0 fc ae 	rcall	80008618 <get_arg>
80008cc0:	2f dd       	sub	sp,-12
80008cc2:	78 0c       	ld.w	r12,r12[0x0]
80008cc4:	50 2c       	stdsp	sp[0x8],r12
80008cc6:	c2 78       	rjmp	80008d14 <_vfprintf_r+0x3cc>
80008cc8:	12 96       	mov	r6,r9
80008cca:	0e 94       	mov	r4,r7
80008ccc:	fa c9 f9 44 	sub	r9,sp,-1724
80008cd0:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008cd4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008cd8:	50 28       	stdsp	sp[0x8],r8
80008cda:	c1 d8       	rjmp	80008d14 <_vfprintf_r+0x3cc>
80008cdc:	41 08       	lddsp	r8,sp[0x40]
80008cde:	59 fa       	cp.w	r10,31
80008ce0:	e0 89 00 14 	brgt	80008d08 <_vfprintf_r+0x3c0>
80008ce4:	f0 cb ff fc 	sub	r11,r8,-4
80008ce8:	70 08       	ld.w	r8,r8[0x0]
80008cea:	51 0b       	stdsp	sp[0x40],r11
80008cec:	50 28       	stdsp	sp[0x8],r8
80008cee:	fa c6 f9 44 	sub	r6,sp,-1724
80008cf2:	40 2e       	lddsp	lr,sp[0x8]
80008cf4:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008cf8:	f1 4e fd 88 	st.w	r8[-632],lr
80008cfc:	2f fa       	sub	r10,-1
80008cfe:	0e 94       	mov	r4,r7
80008d00:	fb 4a 06 b4 	st.w	sp[1716],r10
80008d04:	12 96       	mov	r6,r9
80008d06:	c0 78       	rjmp	80008d14 <_vfprintf_r+0x3cc>
80008d08:	70 0c       	ld.w	r12,r8[0x0]
80008d0a:	0e 94       	mov	r4,r7
80008d0c:	2f c8       	sub	r8,-4
80008d0e:	50 2c       	stdsp	sp[0x8],r12
80008d10:	12 96       	mov	r6,r9
80008d12:	51 08       	stdsp	sp[0x40],r8
80008d14:	40 2b       	lddsp	r11,sp[0x8]
80008d16:	58 0b       	cp.w	r11,0
80008d18:	fe 95 fe f2 	brlt	80008afc <_vfprintf_r+0x1b4>
80008d1c:	08 97       	mov	r7,r4
80008d1e:	cf 5a       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008d20:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008d24:	0f 38       	ld.ub	r8,r7++
80008d26:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008d2a:	f0 ca 00 30 	sub	r10,r8,48
80008d2e:	58 9a       	cp.w	r10,9
80008d30:	fe 98 ff f8 	brls	80008d20 <_vfprintf_r+0x3d8>
80008d34:	3f fa       	mov	r10,-1
80008d36:	f2 0a 0c 49 	max	r9,r9,r10
80008d3a:	50 29       	stdsp	sp[0x8],r9
80008d3c:	ce 9a       	rjmp	80008b0e <_vfprintf_r+0x1c6>
80008d3e:	a7 b5       	sbr	r5,0x7
80008d40:	ce 4a       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008d42:	30 09       	mov	r9,0
80008d44:	23 08       	sub	r8,48
80008d46:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008d4a:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008d4e:	0f 38       	ld.ub	r8,r7++
80008d50:	f0 ca 00 30 	sub	r10,r8,48
80008d54:	58 9a       	cp.w	r10,9
80008d56:	fe 98 ff f7 	brls	80008d44 <_vfprintf_r+0x3fc>
80008d5a:	e0 48 00 24 	cp.w	r8,36
80008d5e:	fe 91 fe d7 	brne	80008b0c <_vfprintf_r+0x1c4>
80008d62:	e0 49 00 20 	cp.w	r9,32
80008d66:	e0 89 0d 6f 	brgt	8000a844 <_vfprintf_r+0x1efc>
80008d6a:	f2 c3 00 01 	sub	r3,r9,1
80008d6e:	30 19       	mov	r9,1
80008d70:	50 39       	stdsp	sp[0xc],r9
80008d72:	cc ba       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008d74:	a3 b5       	sbr	r5,0x3
80008d76:	cc 9a       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008d78:	a7 a5       	sbr	r5,0x6
80008d7a:	cc 7a       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008d7c:	0a 98       	mov	r8,r5
80008d7e:	a5 b5       	sbr	r5,0x5
80008d80:	a5 a8       	sbr	r8,0x4
80008d82:	0f 89       	ld.ub	r9,r7[0x0]
80008d84:	36 ce       	mov	lr,108
80008d86:	fc 09 18 00 	cp.b	r9,lr
80008d8a:	f7 b7 00 ff 	subeq	r7,-1
80008d8e:	f0 05 17 10 	movne	r5,r8
80008d92:	cb ba       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008d94:	a5 b5       	sbr	r5,0x5
80008d96:	cb 9a       	rjmp	80008b08 <_vfprintf_r+0x1c0>
80008d98:	50 a7       	stdsp	sp[0x28],r7
80008d9a:	50 80       	stdsp	sp[0x20],r0
80008d9c:	0c 97       	mov	r7,r6
80008d9e:	10 90       	mov	r0,r8
80008da0:	06 96       	mov	r6,r3
80008da2:	04 94       	mov	r4,r2
80008da4:	40 93       	lddsp	r3,sp[0x24]
80008da6:	02 92       	mov	r2,r1
80008da8:	0e 99       	mov	r9,r7
80008daa:	40 41       	lddsp	r1,sp[0x10]
80008dac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008db0:	40 3c       	lddsp	r12,sp[0xc]
80008db2:	58 0c       	cp.w	r12,0
80008db4:	c1 d0       	breq	80008dee <_vfprintf_r+0x4a6>
80008db6:	10 36       	cp.w	r6,r8
80008db8:	c0 64       	brge	80008dc4 <_vfprintf_r+0x47c>
80008dba:	fa cb f9 44 	sub	r11,sp,-1724
80008dbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dc2:	c1 d8       	rjmp	80008dfc <_vfprintf_r+0x4b4>
80008dc4:	fa c8 f9 50 	sub	r8,sp,-1712
80008dc8:	1a d8       	st.w	--sp,r8
80008dca:	fa c8 fa b8 	sub	r8,sp,-1352
80008dce:	1a d8       	st.w	--sp,r8
80008dd0:	fa c8 fb b4 	sub	r8,sp,-1100
80008dd4:	1a d8       	st.w	--sp,r8
80008dd6:	fa c8 f9 40 	sub	r8,sp,-1728
80008dda:	fa c9 ff b4 	sub	r9,sp,-76
80008dde:	04 9a       	mov	r10,r2
80008de0:	0c 9b       	mov	r11,r6
80008de2:	08 9c       	mov	r12,r4
80008de4:	fe b0 fc 1a 	rcall	80008618 <get_arg>
80008de8:	2f dd       	sub	sp,-12
80008dea:	19 b8       	ld.ub	r8,r12[0x3]
80008dec:	c2 28       	rjmp	80008e30 <_vfprintf_r+0x4e8>
80008dee:	2f f7       	sub	r7,-1
80008df0:	10 39       	cp.w	r9,r8
80008df2:	c0 84       	brge	80008e02 <_vfprintf_r+0x4ba>
80008df4:	fa ca f9 44 	sub	r10,sp,-1724
80008df8:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008dfc:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008e00:	c1 88       	rjmp	80008e30 <_vfprintf_r+0x4e8>
80008e02:	41 09       	lddsp	r9,sp[0x40]
80008e04:	59 f8       	cp.w	r8,31
80008e06:	e0 89 00 12 	brgt	80008e2a <_vfprintf_r+0x4e2>
80008e0a:	f2 ca ff fc 	sub	r10,r9,-4
80008e0e:	51 0a       	stdsp	sp[0x40],r10
80008e10:	72 09       	ld.w	r9,r9[0x0]
80008e12:	fa c6 f9 44 	sub	r6,sp,-1724
80008e16:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008e1a:	2f f8       	sub	r8,-1
80008e1c:	f5 49 fd 88 	st.w	r10[-632],r9
80008e20:	fb 48 06 b4 	st.w	sp[1716],r8
80008e24:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008e28:	c0 48       	rjmp	80008e30 <_vfprintf_r+0x4e8>
80008e2a:	13 b8       	ld.ub	r8,r9[0x3]
80008e2c:	2f c9       	sub	r9,-4
80008e2e:	51 09       	stdsp	sp[0x40],r9
80008e30:	fb 68 06 60 	st.b	sp[1632],r8
80008e34:	30 0e       	mov	lr,0
80008e36:	30 08       	mov	r8,0
80008e38:	30 12       	mov	r2,1
80008e3a:	fb 68 06 bb 	st.b	sp[1723],r8
80008e3e:	50 2e       	stdsp	sp[0x8],lr
80008e40:	e0 8f 08 ad 	bral	80009f9a <_vfprintf_r+0x1652>
80008e44:	50 a7       	stdsp	sp[0x28],r7
80008e46:	50 80       	stdsp	sp[0x20],r0
80008e48:	0c 97       	mov	r7,r6
80008e4a:	04 94       	mov	r4,r2
80008e4c:	06 96       	mov	r6,r3
80008e4e:	02 92       	mov	r2,r1
80008e50:	40 93       	lddsp	r3,sp[0x24]
80008e52:	10 90       	mov	r0,r8
80008e54:	40 41       	lddsp	r1,sp[0x10]
80008e56:	a5 a5       	sbr	r5,0x4
80008e58:	c0 a8       	rjmp	80008e6c <_vfprintf_r+0x524>
80008e5a:	50 a7       	stdsp	sp[0x28],r7
80008e5c:	50 80       	stdsp	sp[0x20],r0
80008e5e:	0c 97       	mov	r7,r6
80008e60:	04 94       	mov	r4,r2
80008e62:	06 96       	mov	r6,r3
80008e64:	02 92       	mov	r2,r1
80008e66:	40 93       	lddsp	r3,sp[0x24]
80008e68:	10 90       	mov	r0,r8
80008e6a:	40 41       	lddsp	r1,sp[0x10]
80008e6c:	ed b5 00 05 	bld	r5,0x5
80008e70:	c5 11       	brne	80008f12 <_vfprintf_r+0x5ca>
80008e72:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e76:	40 3c       	lddsp	r12,sp[0xc]
80008e78:	58 0c       	cp.w	r12,0
80008e7a:	c1 e0       	breq	80008eb6 <_vfprintf_r+0x56e>
80008e7c:	10 36       	cp.w	r6,r8
80008e7e:	c0 64       	brge	80008e8a <_vfprintf_r+0x542>
80008e80:	fa cb f9 44 	sub	r11,sp,-1724
80008e84:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e88:	c2 08       	rjmp	80008ec8 <_vfprintf_r+0x580>
80008e8a:	fa c8 f9 50 	sub	r8,sp,-1712
80008e8e:	1a d8       	st.w	--sp,r8
80008e90:	fa c8 fa b8 	sub	r8,sp,-1352
80008e94:	0c 9b       	mov	r11,r6
80008e96:	1a d8       	st.w	--sp,r8
80008e98:	fa c8 fb b4 	sub	r8,sp,-1100
80008e9c:	1a d8       	st.w	--sp,r8
80008e9e:	fa c9 ff b4 	sub	r9,sp,-76
80008ea2:	fa c8 f9 40 	sub	r8,sp,-1728
80008ea6:	04 9a       	mov	r10,r2
80008ea8:	08 9c       	mov	r12,r4
80008eaa:	fe b0 fb b7 	rcall	80008618 <get_arg>
80008eae:	2f dd       	sub	sp,-12
80008eb0:	78 1b       	ld.w	r11,r12[0x4]
80008eb2:	78 09       	ld.w	r9,r12[0x0]
80008eb4:	c2 b8       	rjmp	80008f0a <_vfprintf_r+0x5c2>
80008eb6:	ee ca ff ff 	sub	r10,r7,-1
80008eba:	10 37       	cp.w	r7,r8
80008ebc:	c0 b4       	brge	80008ed2 <_vfprintf_r+0x58a>
80008ebe:	fa c9 f9 44 	sub	r9,sp,-1724
80008ec2:	14 97       	mov	r7,r10
80008ec4:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ec8:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008ecc:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008ed0:	c1 d8       	rjmp	80008f0a <_vfprintf_r+0x5c2>
80008ed2:	41 09       	lddsp	r9,sp[0x40]
80008ed4:	59 f8       	cp.w	r8,31
80008ed6:	e0 89 00 14 	brgt	80008efe <_vfprintf_r+0x5b6>
80008eda:	f2 cb ff f8 	sub	r11,r9,-8
80008ede:	51 0b       	stdsp	sp[0x40],r11
80008ee0:	fa c6 f9 44 	sub	r6,sp,-1724
80008ee4:	72 1b       	ld.w	r11,r9[0x4]
80008ee6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008eea:	72 09       	ld.w	r9,r9[0x0]
80008eec:	f9 4b fd 8c 	st.w	r12[-628],r11
80008ef0:	f9 49 fd 88 	st.w	r12[-632],r9
80008ef4:	2f f8       	sub	r8,-1
80008ef6:	14 97       	mov	r7,r10
80008ef8:	fb 48 06 b4 	st.w	sp[1716],r8
80008efc:	c0 78       	rjmp	80008f0a <_vfprintf_r+0x5c2>
80008efe:	f2 c8 ff f8 	sub	r8,r9,-8
80008f02:	72 1b       	ld.w	r11,r9[0x4]
80008f04:	14 97       	mov	r7,r10
80008f06:	51 08       	stdsp	sp[0x40],r8
80008f08:	72 09       	ld.w	r9,r9[0x0]
80008f0a:	16 98       	mov	r8,r11
80008f0c:	fa e9 00 00 	st.d	sp[0],r8
80008f10:	ca e8       	rjmp	8000906c <_vfprintf_r+0x724>
80008f12:	ed b5 00 04 	bld	r5,0x4
80008f16:	c1 71       	brne	80008f44 <_vfprintf_r+0x5fc>
80008f18:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f1c:	40 3e       	lddsp	lr,sp[0xc]
80008f1e:	58 0e       	cp.w	lr,0
80008f20:	c0 80       	breq	80008f30 <_vfprintf_r+0x5e8>
80008f22:	10 36       	cp.w	r6,r8
80008f24:	c6 94       	brge	80008ff6 <_vfprintf_r+0x6ae>
80008f26:	fa cc f9 44 	sub	r12,sp,-1724
80008f2a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f2e:	c8 28       	rjmp	80009032 <_vfprintf_r+0x6ea>
80008f30:	ee ca ff ff 	sub	r10,r7,-1
80008f34:	10 37       	cp.w	r7,r8
80008f36:	e0 84 00 81 	brge	80009038 <_vfprintf_r+0x6f0>
80008f3a:	fa cb f9 44 	sub	r11,sp,-1724
80008f3e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f42:	c7 78       	rjmp	80009030 <_vfprintf_r+0x6e8>
80008f44:	ed b5 00 06 	bld	r5,0x6
80008f48:	c4 b1       	brne	80008fde <_vfprintf_r+0x696>
80008f4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f4e:	40 3c       	lddsp	r12,sp[0xc]
80008f50:	58 0c       	cp.w	r12,0
80008f52:	c1 d0       	breq	80008f8c <_vfprintf_r+0x644>
80008f54:	10 36       	cp.w	r6,r8
80008f56:	c0 64       	brge	80008f62 <_vfprintf_r+0x61a>
80008f58:	fa cb f9 44 	sub	r11,sp,-1724
80008f5c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f60:	c1 f8       	rjmp	80008f9e <_vfprintf_r+0x656>
80008f62:	fa c8 f9 50 	sub	r8,sp,-1712
80008f66:	1a d8       	st.w	--sp,r8
80008f68:	fa c8 fa b8 	sub	r8,sp,-1352
80008f6c:	1a d8       	st.w	--sp,r8
80008f6e:	fa c8 fb b4 	sub	r8,sp,-1100
80008f72:	1a d8       	st.w	--sp,r8
80008f74:	fa c8 f9 40 	sub	r8,sp,-1728
80008f78:	fa c9 ff b4 	sub	r9,sp,-76
80008f7c:	04 9a       	mov	r10,r2
80008f7e:	0c 9b       	mov	r11,r6
80008f80:	08 9c       	mov	r12,r4
80008f82:	fe b0 fb 4b 	rcall	80008618 <get_arg>
80008f86:	2f dd       	sub	sp,-12
80008f88:	98 18       	ld.sh	r8,r12[0x2]
80008f8a:	c2 68       	rjmp	80008fd6 <_vfprintf_r+0x68e>
80008f8c:	ee ca ff ff 	sub	r10,r7,-1
80008f90:	10 37       	cp.w	r7,r8
80008f92:	c0 94       	brge	80008fa4 <_vfprintf_r+0x65c>
80008f94:	fa c9 f9 44 	sub	r9,sp,-1724
80008f98:	14 97       	mov	r7,r10
80008f9a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f9e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008fa2:	c1 a8       	rjmp	80008fd6 <_vfprintf_r+0x68e>
80008fa4:	41 09       	lddsp	r9,sp[0x40]
80008fa6:	59 f8       	cp.w	r8,31
80008fa8:	e0 89 00 13 	brgt	80008fce <_vfprintf_r+0x686>
80008fac:	f2 cb ff fc 	sub	r11,r9,-4
80008fb0:	51 0b       	stdsp	sp[0x40],r11
80008fb2:	72 09       	ld.w	r9,r9[0x0]
80008fb4:	fa c6 f9 44 	sub	r6,sp,-1724
80008fb8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008fbc:	2f f8       	sub	r8,-1
80008fbe:	f7 49 fd 88 	st.w	r11[-632],r9
80008fc2:	fb 48 06 b4 	st.w	sp[1716],r8
80008fc6:	14 97       	mov	r7,r10
80008fc8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008fcc:	c0 58       	rjmp	80008fd6 <_vfprintf_r+0x68e>
80008fce:	92 18       	ld.sh	r8,r9[0x2]
80008fd0:	14 97       	mov	r7,r10
80008fd2:	2f c9       	sub	r9,-4
80008fd4:	51 09       	stdsp	sp[0x40],r9
80008fd6:	50 18       	stdsp	sp[0x4],r8
80008fd8:	bf 58       	asr	r8,0x1f
80008fda:	50 08       	stdsp	sp[0x0],r8
80008fdc:	c4 88       	rjmp	8000906c <_vfprintf_r+0x724>
80008fde:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fe2:	40 3c       	lddsp	r12,sp[0xc]
80008fe4:	58 0c       	cp.w	r12,0
80008fe6:	c1 d0       	breq	80009020 <_vfprintf_r+0x6d8>
80008fe8:	10 36       	cp.w	r6,r8
80008fea:	c0 64       	brge	80008ff6 <_vfprintf_r+0x6ae>
80008fec:	fa cb f9 44 	sub	r11,sp,-1724
80008ff0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ff4:	c1 f8       	rjmp	80009032 <_vfprintf_r+0x6ea>
80008ff6:	fa c8 f9 50 	sub	r8,sp,-1712
80008ffa:	1a d8       	st.w	--sp,r8
80008ffc:	fa c8 fa b8 	sub	r8,sp,-1352
80009000:	0c 9b       	mov	r11,r6
80009002:	1a d8       	st.w	--sp,r8
80009004:	fa c8 fb b4 	sub	r8,sp,-1100
80009008:	04 9a       	mov	r10,r2
8000900a:	1a d8       	st.w	--sp,r8
8000900c:	08 9c       	mov	r12,r4
8000900e:	fa c8 f9 40 	sub	r8,sp,-1728
80009012:	fa c9 ff b4 	sub	r9,sp,-76
80009016:	fe b0 fb 01 	rcall	80008618 <get_arg>
8000901a:	2f dd       	sub	sp,-12
8000901c:	78 0b       	ld.w	r11,r12[0x0]
8000901e:	c2 48       	rjmp	80009066 <_vfprintf_r+0x71e>
80009020:	ee ca ff ff 	sub	r10,r7,-1
80009024:	10 37       	cp.w	r7,r8
80009026:	c0 94       	brge	80009038 <_vfprintf_r+0x6f0>
80009028:	fa c9 f9 44 	sub	r9,sp,-1724
8000902c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009030:	14 97       	mov	r7,r10
80009032:	ec fb fd 88 	ld.w	r11,r6[-632]
80009036:	c1 88       	rjmp	80009066 <_vfprintf_r+0x71e>
80009038:	41 09       	lddsp	r9,sp[0x40]
8000903a:	59 f8       	cp.w	r8,31
8000903c:	e0 89 00 11 	brgt	8000905e <_vfprintf_r+0x716>
80009040:	f2 cb ff fc 	sub	r11,r9,-4
80009044:	51 0b       	stdsp	sp[0x40],r11
80009046:	fa c6 f9 44 	sub	r6,sp,-1724
8000904a:	72 0b       	ld.w	r11,r9[0x0]
8000904c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009050:	f3 4b fd 88 	st.w	r9[-632],r11
80009054:	2f f8       	sub	r8,-1
80009056:	14 97       	mov	r7,r10
80009058:	fb 48 06 b4 	st.w	sp[1716],r8
8000905c:	c0 58       	rjmp	80009066 <_vfprintf_r+0x71e>
8000905e:	72 0b       	ld.w	r11,r9[0x0]
80009060:	14 97       	mov	r7,r10
80009062:	2f c9       	sub	r9,-4
80009064:	51 09       	stdsp	sp[0x40],r9
80009066:	50 1b       	stdsp	sp[0x4],r11
80009068:	bf 5b       	asr	r11,0x1f
8000906a:	50 0b       	stdsp	sp[0x0],r11
8000906c:	fa ea 00 00 	ld.d	r10,sp[0]
80009070:	58 0a       	cp.w	r10,0
80009072:	5c 2b       	cpc	r11
80009074:	c0 e4       	brge	80009090 <_vfprintf_r+0x748>
80009076:	30 08       	mov	r8,0
80009078:	fa ea 00 00 	ld.d	r10,sp[0]
8000907c:	30 09       	mov	r9,0
8000907e:	f0 0a 01 0a 	sub	r10,r8,r10
80009082:	f2 0b 01 4b 	sbc	r11,r9,r11
80009086:	32 d8       	mov	r8,45
80009088:	fa eb 00 00 	st.d	sp[0],r10
8000908c:	fb 68 06 bb 	st.b	sp[1723],r8
80009090:	30 18       	mov	r8,1
80009092:	e0 8f 06 fa 	bral	80009e86 <_vfprintf_r+0x153e>
80009096:	50 a7       	stdsp	sp[0x28],r7
80009098:	50 80       	stdsp	sp[0x20],r0
8000909a:	0c 97       	mov	r7,r6
8000909c:	04 94       	mov	r4,r2
8000909e:	06 96       	mov	r6,r3
800090a0:	02 92       	mov	r2,r1
800090a2:	40 93       	lddsp	r3,sp[0x24]
800090a4:	10 90       	mov	r0,r8
800090a6:	40 41       	lddsp	r1,sp[0x10]
800090a8:	0e 99       	mov	r9,r7
800090aa:	ed b5 00 03 	bld	r5,0x3
800090ae:	c4 11       	brne	80009130 <_vfprintf_r+0x7e8>
800090b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090b4:	40 3a       	lddsp	r10,sp[0xc]
800090b6:	58 0a       	cp.w	r10,0
800090b8:	c1 90       	breq	800090ea <_vfprintf_r+0x7a2>
800090ba:	10 36       	cp.w	r6,r8
800090bc:	c6 45       	brlt	80009184 <_vfprintf_r+0x83c>
800090be:	fa c8 f9 50 	sub	r8,sp,-1712
800090c2:	1a d8       	st.w	--sp,r8
800090c4:	fa c8 fa b8 	sub	r8,sp,-1352
800090c8:	1a d8       	st.w	--sp,r8
800090ca:	fa c8 fb b4 	sub	r8,sp,-1100
800090ce:	0c 9b       	mov	r11,r6
800090d0:	1a d8       	st.w	--sp,r8
800090d2:	04 9a       	mov	r10,r2
800090d4:	fa c8 f9 40 	sub	r8,sp,-1728
800090d8:	fa c9 ff b4 	sub	r9,sp,-76
800090dc:	08 9c       	mov	r12,r4
800090de:	fe b0 fa 9d 	rcall	80008618 <get_arg>
800090e2:	2f dd       	sub	sp,-12
800090e4:	78 16       	ld.w	r6,r12[0x4]
800090e6:	50 76       	stdsp	sp[0x1c],r6
800090e8:	c4 88       	rjmp	80009178 <_vfprintf_r+0x830>
800090ea:	2f f7       	sub	r7,-1
800090ec:	10 39       	cp.w	r9,r8
800090ee:	c0 c4       	brge	80009106 <_vfprintf_r+0x7be>
800090f0:	fa ce f9 44 	sub	lr,sp,-1724
800090f4:	fc 06 00 36 	add	r6,lr,r6<<0x3
800090f8:	ec fc fd 8c 	ld.w	r12,r6[-628]
800090fc:	50 7c       	stdsp	sp[0x1c],r12
800090fe:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009102:	50 56       	stdsp	sp[0x14],r6
80009104:	c6 68       	rjmp	800091d0 <_vfprintf_r+0x888>
80009106:	41 09       	lddsp	r9,sp[0x40]
80009108:	59 f8       	cp.w	r8,31
8000910a:	e0 89 00 10 	brgt	8000912a <_vfprintf_r+0x7e2>
8000910e:	f2 ca ff f8 	sub	r10,r9,-8
80009112:	72 1b       	ld.w	r11,r9[0x4]
80009114:	51 0a       	stdsp	sp[0x40],r10
80009116:	72 09       	ld.w	r9,r9[0x0]
80009118:	fa ca f9 44 	sub	r10,sp,-1724
8000911c:	50 7b       	stdsp	sp[0x1c],r11
8000911e:	50 59       	stdsp	sp[0x14],r9
80009120:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009124:	40 5b       	lddsp	r11,sp[0x14]
80009126:	40 7a       	lddsp	r10,sp[0x1c]
80009128:	c4 78       	rjmp	800091b6 <_vfprintf_r+0x86e>
8000912a:	72 18       	ld.w	r8,r9[0x4]
8000912c:	50 78       	stdsp	sp[0x1c],r8
8000912e:	c4 c8       	rjmp	800091c6 <_vfprintf_r+0x87e>
80009130:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009134:	40 3e       	lddsp	lr,sp[0xc]
80009136:	58 0e       	cp.w	lr,0
80009138:	c2 30       	breq	8000917e <_vfprintf_r+0x836>
8000913a:	10 36       	cp.w	r6,r8
8000913c:	c0 94       	brge	8000914e <_vfprintf_r+0x806>
8000913e:	fa cc f9 44 	sub	r12,sp,-1724
80009142:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009146:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000914a:	50 7b       	stdsp	sp[0x1c],r11
8000914c:	cd 9b       	rjmp	800090fe <_vfprintf_r+0x7b6>
8000914e:	fa c8 f9 50 	sub	r8,sp,-1712
80009152:	1a d8       	st.w	--sp,r8
80009154:	fa c8 fa b8 	sub	r8,sp,-1352
80009158:	04 9a       	mov	r10,r2
8000915a:	1a d8       	st.w	--sp,r8
8000915c:	fa c8 fb b4 	sub	r8,sp,-1100
80009160:	0c 9b       	mov	r11,r6
80009162:	1a d8       	st.w	--sp,r8
80009164:	08 9c       	mov	r12,r4
80009166:	fa c8 f9 40 	sub	r8,sp,-1728
8000916a:	fa c9 ff b4 	sub	r9,sp,-76
8000916e:	fe b0 fa 55 	rcall	80008618 <get_arg>
80009172:	2f dd       	sub	sp,-12
80009174:	78 1a       	ld.w	r10,r12[0x4]
80009176:	50 7a       	stdsp	sp[0x1c],r10
80009178:	78 0c       	ld.w	r12,r12[0x0]
8000917a:	50 5c       	stdsp	sp[0x14],r12
8000917c:	c2 a8       	rjmp	800091d0 <_vfprintf_r+0x888>
8000917e:	2f f7       	sub	r7,-1
80009180:	10 39       	cp.w	r9,r8
80009182:	c0 94       	brge	80009194 <_vfprintf_r+0x84c>
80009184:	fa c9 f9 44 	sub	r9,sp,-1724
80009188:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000918c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80009190:	50 78       	stdsp	sp[0x1c],r8
80009192:	cb 6b       	rjmp	800090fe <_vfprintf_r+0x7b6>
80009194:	41 09       	lddsp	r9,sp[0x40]
80009196:	59 f8       	cp.w	r8,31
80009198:	e0 89 00 15 	brgt	800091c2 <_vfprintf_r+0x87a>
8000919c:	f2 ca ff f8 	sub	r10,r9,-8
800091a0:	72 16       	ld.w	r6,r9[0x4]
800091a2:	72 09       	ld.w	r9,r9[0x0]
800091a4:	51 0a       	stdsp	sp[0x40],r10
800091a6:	50 59       	stdsp	sp[0x14],r9
800091a8:	fa ce f9 44 	sub	lr,sp,-1724
800091ac:	50 76       	stdsp	sp[0x1c],r6
800091ae:	fc 08 00 39 	add	r9,lr,r8<<0x3
800091b2:	40 5b       	lddsp	r11,sp[0x14]
800091b4:	0c 9a       	mov	r10,r6
800091b6:	f2 eb fd 88 	st.d	r9[-632],r10
800091ba:	2f f8       	sub	r8,-1
800091bc:	fb 48 06 b4 	st.w	sp[1716],r8
800091c0:	c0 88       	rjmp	800091d0 <_vfprintf_r+0x888>
800091c2:	72 1c       	ld.w	r12,r9[0x4]
800091c4:	50 7c       	stdsp	sp[0x1c],r12
800091c6:	f2 c8 ff f8 	sub	r8,r9,-8
800091ca:	51 08       	stdsp	sp[0x40],r8
800091cc:	72 09       	ld.w	r9,r9[0x0]
800091ce:	50 59       	stdsp	sp[0x14],r9
800091d0:	40 5b       	lddsp	r11,sp[0x14]
800091d2:	40 7a       	lddsp	r10,sp[0x1c]
800091d4:	e0 a0 19 54 	rcall	8000c47c <__isinfd>
800091d8:	18 96       	mov	r6,r12
800091da:	c1 70       	breq	80009208 <_vfprintf_r+0x8c0>
800091dc:	30 08       	mov	r8,0
800091de:	30 09       	mov	r9,0
800091e0:	40 5b       	lddsp	r11,sp[0x14]
800091e2:	40 7a       	lddsp	r10,sp[0x1c]
800091e4:	e0 a0 1d b4 	rcall	8000cd4c <__avr32_f64_cmp_lt>
800091e8:	c0 40       	breq	800091f0 <_vfprintf_r+0x8a8>
800091ea:	32 d8       	mov	r8,45
800091ec:	fb 68 06 bb 	st.b	sp[1723],r8
800091f0:	fe c8 a8 30 	sub	r8,pc,-22480
800091f4:	fe c6 a8 30 	sub	r6,pc,-22480
800091f8:	a7 d5       	cbr	r5,0x7
800091fa:	e0 40 00 47 	cp.w	r0,71
800091fe:	f0 06 17 a0 	movle	r6,r8
80009202:	30 32       	mov	r2,3
80009204:	e0 8f 06 ce 	bral	80009fa0 <_vfprintf_r+0x1658>
80009208:	40 5b       	lddsp	r11,sp[0x14]
8000920a:	40 7a       	lddsp	r10,sp[0x1c]
8000920c:	e0 a0 19 4d 	rcall	8000c4a6 <__isnand>
80009210:	c0 e0       	breq	8000922c <_vfprintf_r+0x8e4>
80009212:	50 26       	stdsp	sp[0x8],r6
80009214:	fe c8 a8 4c 	sub	r8,pc,-22452
80009218:	fe c6 a8 4c 	sub	r6,pc,-22452
8000921c:	a7 d5       	cbr	r5,0x7
8000921e:	e0 40 00 47 	cp.w	r0,71
80009222:	f0 06 17 a0 	movle	r6,r8
80009226:	30 32       	mov	r2,3
80009228:	e0 8f 06 c2 	bral	80009fac <_vfprintf_r+0x1664>
8000922c:	40 2a       	lddsp	r10,sp[0x8]
8000922e:	5b fa       	cp.w	r10,-1
80009230:	c0 41       	brne	80009238 <_vfprintf_r+0x8f0>
80009232:	30 69       	mov	r9,6
80009234:	50 29       	stdsp	sp[0x8],r9
80009236:	c1 18       	rjmp	80009258 <_vfprintf_r+0x910>
80009238:	e0 40 00 47 	cp.w	r0,71
8000923c:	5f 09       	sreq	r9
8000923e:	e0 40 00 67 	cp.w	r0,103
80009242:	5f 08       	sreq	r8
80009244:	f3 e8 10 08 	or	r8,r9,r8
80009248:	f8 08 18 00 	cp.b	r8,r12
8000924c:	c0 60       	breq	80009258 <_vfprintf_r+0x910>
8000924e:	40 28       	lddsp	r8,sp[0x8]
80009250:	58 08       	cp.w	r8,0
80009252:	f9 b8 00 01 	moveq	r8,1
80009256:	50 28       	stdsp	sp[0x8],r8
80009258:	40 78       	lddsp	r8,sp[0x1c]
8000925a:	40 59       	lddsp	r9,sp[0x14]
8000925c:	fa e9 06 94 	st.d	sp[1684],r8
80009260:	a9 a5       	sbr	r5,0x8
80009262:	fa f8 06 94 	ld.w	r8,sp[1684]
80009266:	58 08       	cp.w	r8,0
80009268:	c0 65       	brlt	80009274 <_vfprintf_r+0x92c>
8000926a:	40 5e       	lddsp	lr,sp[0x14]
8000926c:	30 0c       	mov	r12,0
8000926e:	50 6e       	stdsp	sp[0x18],lr
80009270:	50 9c       	stdsp	sp[0x24],r12
80009272:	c0 78       	rjmp	80009280 <_vfprintf_r+0x938>
80009274:	40 5b       	lddsp	r11,sp[0x14]
80009276:	32 da       	mov	r10,45
80009278:	ee 1b 80 00 	eorh	r11,0x8000
8000927c:	50 9a       	stdsp	sp[0x24],r10
8000927e:	50 6b       	stdsp	sp[0x18],r11
80009280:	e0 40 00 46 	cp.w	r0,70
80009284:	5f 09       	sreq	r9
80009286:	e0 40 00 66 	cp.w	r0,102
8000928a:	5f 08       	sreq	r8
8000928c:	f3 e8 10 08 	or	r8,r9,r8
80009290:	50 48       	stdsp	sp[0x10],r8
80009292:	c0 40       	breq	8000929a <_vfprintf_r+0x952>
80009294:	40 22       	lddsp	r2,sp[0x8]
80009296:	30 39       	mov	r9,3
80009298:	c1 08       	rjmp	800092b8 <_vfprintf_r+0x970>
8000929a:	e0 40 00 45 	cp.w	r0,69
8000929e:	5f 09       	sreq	r9
800092a0:	e0 40 00 65 	cp.w	r0,101
800092a4:	5f 08       	sreq	r8
800092a6:	40 22       	lddsp	r2,sp[0x8]
800092a8:	10 49       	or	r9,r8
800092aa:	2f f2       	sub	r2,-1
800092ac:	40 46       	lddsp	r6,sp[0x10]
800092ae:	ec 09 18 00 	cp.b	r9,r6
800092b2:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800092b6:	30 29       	mov	r9,2
800092b8:	fa c8 f9 5c 	sub	r8,sp,-1700
800092bc:	1a d8       	st.w	--sp,r8
800092be:	fa c8 f9 54 	sub	r8,sp,-1708
800092c2:	1a d8       	st.w	--sp,r8
800092c4:	fa c8 f9 4c 	sub	r8,sp,-1716
800092c8:	08 9c       	mov	r12,r4
800092ca:	1a d8       	st.w	--sp,r8
800092cc:	04 98       	mov	r8,r2
800092ce:	40 9b       	lddsp	r11,sp[0x24]
800092d0:	40 aa       	lddsp	r10,sp[0x28]
800092d2:	e0 a0 0b c3 	rcall	8000aa58 <_dtoa_r>
800092d6:	e0 40 00 47 	cp.w	r0,71
800092da:	5f 19       	srne	r9
800092dc:	e0 40 00 67 	cp.w	r0,103
800092e0:	5f 18       	srne	r8
800092e2:	18 96       	mov	r6,r12
800092e4:	2f dd       	sub	sp,-12
800092e6:	f3 e8 00 08 	and	r8,r9,r8
800092ea:	c0 41       	brne	800092f2 <_vfprintf_r+0x9aa>
800092ec:	ed b5 00 00 	bld	r5,0x0
800092f0:	c3 01       	brne	80009350 <_vfprintf_r+0xa08>
800092f2:	ec 02 00 0e 	add	lr,r6,r2
800092f6:	50 3e       	stdsp	sp[0xc],lr
800092f8:	40 4c       	lddsp	r12,sp[0x10]
800092fa:	58 0c       	cp.w	r12,0
800092fc:	c1 50       	breq	80009326 <_vfprintf_r+0x9de>
800092fe:	0d 89       	ld.ub	r9,r6[0x0]
80009300:	33 08       	mov	r8,48
80009302:	f0 09 18 00 	cp.b	r9,r8
80009306:	c0 b1       	brne	8000931c <_vfprintf_r+0x9d4>
80009308:	30 08       	mov	r8,0
8000930a:	30 09       	mov	r9,0
8000930c:	40 6b       	lddsp	r11,sp[0x18]
8000930e:	40 7a       	lddsp	r10,sp[0x1c]
80009310:	e0 a0 1c d7 	rcall	8000ccbe <__avr32_f64_cmp_eq>
80009314:	fb b2 00 01 	rsubeq	r2,1
80009318:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000931c:	40 3b       	lddsp	r11,sp[0xc]
8000931e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009322:	10 0b       	add	r11,r8
80009324:	50 3b       	stdsp	sp[0xc],r11
80009326:	40 6b       	lddsp	r11,sp[0x18]
80009328:	30 08       	mov	r8,0
8000932a:	30 09       	mov	r9,0
8000932c:	40 7a       	lddsp	r10,sp[0x1c]
8000932e:	e0 a0 1c c8 	rcall	8000ccbe <__avr32_f64_cmp_eq>
80009332:	c0 90       	breq	80009344 <_vfprintf_r+0x9fc>
80009334:	40 3a       	lddsp	r10,sp[0xc]
80009336:	fb 4a 06 a4 	st.w	sp[1700],r10
8000933a:	c0 58       	rjmp	80009344 <_vfprintf_r+0x9fc>
8000933c:	10 c9       	st.b	r8++,r9
8000933e:	fb 48 06 a4 	st.w	sp[1700],r8
80009342:	c0 28       	rjmp	80009346 <_vfprintf_r+0x9fe>
80009344:	33 09       	mov	r9,48
80009346:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000934a:	40 3e       	lddsp	lr,sp[0xc]
8000934c:	1c 38       	cp.w	r8,lr
8000934e:	cf 73       	brcs	8000933c <_vfprintf_r+0x9f4>
80009350:	e0 40 00 47 	cp.w	r0,71
80009354:	5f 09       	sreq	r9
80009356:	e0 40 00 67 	cp.w	r0,103
8000935a:	5f 08       	sreq	r8
8000935c:	f3 e8 10 08 	or	r8,r9,r8
80009360:	fa f9 06 a4 	ld.w	r9,sp[1700]
80009364:	0c 19       	sub	r9,r6
80009366:	50 69       	stdsp	sp[0x18],r9
80009368:	58 08       	cp.w	r8,0
8000936a:	c0 b0       	breq	80009380 <_vfprintf_r+0xa38>
8000936c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009370:	5b d8       	cp.w	r8,-3
80009372:	c0 55       	brlt	8000937c <_vfprintf_r+0xa34>
80009374:	40 2c       	lddsp	r12,sp[0x8]
80009376:	18 38       	cp.w	r8,r12
80009378:	e0 8a 00 6a 	brle	8000944c <_vfprintf_r+0xb04>
8000937c:	20 20       	sub	r0,2
8000937e:	c0 58       	rjmp	80009388 <_vfprintf_r+0xa40>
80009380:	e0 40 00 65 	cp.w	r0,101
80009384:	e0 89 00 46 	brgt	80009410 <_vfprintf_r+0xac8>
80009388:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000938c:	fb 60 06 9c 	st.b	sp[1692],r0
80009390:	20 1b       	sub	r11,1
80009392:	fb 4b 06 ac 	st.w	sp[1708],r11
80009396:	c0 47       	brpl	8000939e <_vfprintf_r+0xa56>
80009398:	5c 3b       	neg	r11
8000939a:	32 d8       	mov	r8,45
8000939c:	c0 28       	rjmp	800093a0 <_vfprintf_r+0xa58>
8000939e:	32 b8       	mov	r8,43
800093a0:	fb 68 06 9d 	st.b	sp[1693],r8
800093a4:	58 9b       	cp.w	r11,9
800093a6:	e0 8a 00 1d 	brle	800093e0 <_vfprintf_r+0xa98>
800093aa:	fa c9 fa 35 	sub	r9,sp,-1483
800093ae:	30 aa       	mov	r10,10
800093b0:	12 98       	mov	r8,r9
800093b2:	0e 9c       	mov	r12,r7
800093b4:	0c 92       	mov	r2,r6
800093b6:	f6 0a 0c 06 	divs	r6,r11,r10
800093ba:	0e 9b       	mov	r11,r7
800093bc:	2d 0b       	sub	r11,-48
800093be:	10 fb       	st.b	--r8,r11
800093c0:	0c 9b       	mov	r11,r6
800093c2:	58 96       	cp.w	r6,9
800093c4:	fe 99 ff f9 	brgt	800093b6 <_vfprintf_r+0xa6e>
800093c8:	2d 0b       	sub	r11,-48
800093ca:	18 97       	mov	r7,r12
800093cc:	04 96       	mov	r6,r2
800093ce:	10 fb       	st.b	--r8,r11
800093d0:	fa ca f9 62 	sub	r10,sp,-1694
800093d4:	c0 38       	rjmp	800093da <_vfprintf_r+0xa92>
800093d6:	11 3b       	ld.ub	r11,r8++
800093d8:	14 cb       	st.b	r10++,r11
800093da:	12 38       	cp.w	r8,r9
800093dc:	cf d3       	brcs	800093d6 <_vfprintf_r+0xa8e>
800093de:	c0 98       	rjmp	800093f0 <_vfprintf_r+0xaa8>
800093e0:	2d 0b       	sub	r11,-48
800093e2:	33 08       	mov	r8,48
800093e4:	fb 6b 06 9f 	st.b	sp[1695],r11
800093e8:	fb 68 06 9e 	st.b	sp[1694],r8
800093ec:	fa ca f9 60 	sub	r10,sp,-1696
800093f0:	fa c8 f9 64 	sub	r8,sp,-1692
800093f4:	f4 08 01 08 	sub	r8,r10,r8
800093f8:	50 e8       	stdsp	sp[0x38],r8
800093fa:	10 92       	mov	r2,r8
800093fc:	40 6b       	lddsp	r11,sp[0x18]
800093fe:	16 02       	add	r2,r11
80009400:	58 1b       	cp.w	r11,1
80009402:	e0 89 00 05 	brgt	8000940c <_vfprintf_r+0xac4>
80009406:	ed b5 00 00 	bld	r5,0x0
8000940a:	c3 51       	brne	80009474 <_vfprintf_r+0xb2c>
8000940c:	2f f2       	sub	r2,-1
8000940e:	c3 38       	rjmp	80009474 <_vfprintf_r+0xb2c>
80009410:	e0 40 00 66 	cp.w	r0,102
80009414:	c1 c1       	brne	8000944c <_vfprintf_r+0xb04>
80009416:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000941a:	58 02       	cp.w	r2,0
8000941c:	e0 8a 00 0c 	brle	80009434 <_vfprintf_r+0xaec>
80009420:	40 2a       	lddsp	r10,sp[0x8]
80009422:	58 0a       	cp.w	r10,0
80009424:	c0 41       	brne	8000942c <_vfprintf_r+0xae4>
80009426:	ed b5 00 00 	bld	r5,0x0
8000942a:	c2 51       	brne	80009474 <_vfprintf_r+0xb2c>
8000942c:	2f f2       	sub	r2,-1
8000942e:	40 29       	lddsp	r9,sp[0x8]
80009430:	12 02       	add	r2,r9
80009432:	c0 b8       	rjmp	80009448 <_vfprintf_r+0xb00>
80009434:	40 28       	lddsp	r8,sp[0x8]
80009436:	58 08       	cp.w	r8,0
80009438:	c0 61       	brne	80009444 <_vfprintf_r+0xafc>
8000943a:	ed b5 00 00 	bld	r5,0x0
8000943e:	c0 30       	breq	80009444 <_vfprintf_r+0xafc>
80009440:	30 12       	mov	r2,1
80009442:	c1 98       	rjmp	80009474 <_vfprintf_r+0xb2c>
80009444:	40 22       	lddsp	r2,sp[0x8]
80009446:	2f e2       	sub	r2,-2
80009448:	36 60       	mov	r0,102
8000944a:	c1 58       	rjmp	80009474 <_vfprintf_r+0xb2c>
8000944c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009450:	40 6e       	lddsp	lr,sp[0x18]
80009452:	1c 32       	cp.w	r2,lr
80009454:	c0 65       	brlt	80009460 <_vfprintf_r+0xb18>
80009456:	ed b5 00 00 	bld	r5,0x0
8000945a:	f7 b2 00 ff 	subeq	r2,-1
8000945e:	c0 a8       	rjmp	80009472 <_vfprintf_r+0xb2a>
80009460:	e4 08 11 02 	rsub	r8,r2,2
80009464:	40 6c       	lddsp	r12,sp[0x18]
80009466:	58 02       	cp.w	r2,0
80009468:	f0 02 17 a0 	movle	r2,r8
8000946c:	f9 b2 09 01 	movgt	r2,1
80009470:	18 02       	add	r2,r12
80009472:	36 70       	mov	r0,103
80009474:	40 9b       	lddsp	r11,sp[0x24]
80009476:	58 0b       	cp.w	r11,0
80009478:	e0 80 05 94 	breq	80009fa0 <_vfprintf_r+0x1658>
8000947c:	32 d8       	mov	r8,45
8000947e:	fb 68 06 bb 	st.b	sp[1723],r8
80009482:	e0 8f 05 93 	bral	80009fa8 <_vfprintf_r+0x1660>
80009486:	50 a7       	stdsp	sp[0x28],r7
80009488:	04 94       	mov	r4,r2
8000948a:	0c 97       	mov	r7,r6
8000948c:	02 92       	mov	r2,r1
8000948e:	06 96       	mov	r6,r3
80009490:	40 41       	lddsp	r1,sp[0x10]
80009492:	40 93       	lddsp	r3,sp[0x24]
80009494:	0e 99       	mov	r9,r7
80009496:	ed b5 00 05 	bld	r5,0x5
8000949a:	c4 81       	brne	8000952a <_vfprintf_r+0xbe2>
8000949c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094a0:	40 3e       	lddsp	lr,sp[0xc]
800094a2:	58 0e       	cp.w	lr,0
800094a4:	c1 d0       	breq	800094de <_vfprintf_r+0xb96>
800094a6:	10 36       	cp.w	r6,r8
800094a8:	c0 64       	brge	800094b4 <_vfprintf_r+0xb6c>
800094aa:	fa cc f9 44 	sub	r12,sp,-1724
800094ae:	f8 06 00 36 	add	r6,r12,r6<<0x3
800094b2:	c1 d8       	rjmp	800094ec <_vfprintf_r+0xba4>
800094b4:	fa c8 f9 50 	sub	r8,sp,-1712
800094b8:	1a d8       	st.w	--sp,r8
800094ba:	fa c8 fa b8 	sub	r8,sp,-1352
800094be:	04 9a       	mov	r10,r2
800094c0:	1a d8       	st.w	--sp,r8
800094c2:	fa c8 fb b4 	sub	r8,sp,-1100
800094c6:	0c 9b       	mov	r11,r6
800094c8:	1a d8       	st.w	--sp,r8
800094ca:	08 9c       	mov	r12,r4
800094cc:	fa c8 f9 40 	sub	r8,sp,-1728
800094d0:	fa c9 ff b4 	sub	r9,sp,-76
800094d4:	fe b0 f8 a2 	rcall	80008618 <get_arg>
800094d8:	2f dd       	sub	sp,-12
800094da:	78 0a       	ld.w	r10,r12[0x0]
800094dc:	c2 08       	rjmp	8000951c <_vfprintf_r+0xbd4>
800094de:	2f f7       	sub	r7,-1
800094e0:	10 39       	cp.w	r9,r8
800094e2:	c0 84       	brge	800094f2 <_vfprintf_r+0xbaa>
800094e4:	fa cb f9 44 	sub	r11,sp,-1724
800094e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800094ec:	ec fa fd 88 	ld.w	r10,r6[-632]
800094f0:	c1 68       	rjmp	8000951c <_vfprintf_r+0xbd4>
800094f2:	41 09       	lddsp	r9,sp[0x40]
800094f4:	59 f8       	cp.w	r8,31
800094f6:	e0 89 00 10 	brgt	80009516 <_vfprintf_r+0xbce>
800094fa:	f2 ca ff fc 	sub	r10,r9,-4
800094fe:	51 0a       	stdsp	sp[0x40],r10
80009500:	fa c6 f9 44 	sub	r6,sp,-1724
80009504:	72 0a       	ld.w	r10,r9[0x0]
80009506:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000950a:	f3 4a fd 88 	st.w	r9[-632],r10
8000950e:	2f f8       	sub	r8,-1
80009510:	fb 48 06 b4 	st.w	sp[1716],r8
80009514:	c0 48       	rjmp	8000951c <_vfprintf_r+0xbd4>
80009516:	72 0a       	ld.w	r10,r9[0x0]
80009518:	2f c9       	sub	r9,-4
8000951a:	51 09       	stdsp	sp[0x40],r9
8000951c:	40 be       	lddsp	lr,sp[0x2c]
8000951e:	1c 98       	mov	r8,lr
80009520:	95 1e       	st.w	r10[0x4],lr
80009522:	bf 58       	asr	r8,0x1f
80009524:	95 08       	st.w	r10[0x0],r8
80009526:	fe 9f fa 9f 	bral	80008a64 <_vfprintf_r+0x11c>
8000952a:	ed b5 00 04 	bld	r5,0x4
8000952e:	c4 80       	breq	800095be <_vfprintf_r+0xc76>
80009530:	e2 15 00 40 	andl	r5,0x40,COH
80009534:	c4 50       	breq	800095be <_vfprintf_r+0xc76>
80009536:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000953a:	40 3c       	lddsp	r12,sp[0xc]
8000953c:	58 0c       	cp.w	r12,0
8000953e:	c1 d0       	breq	80009578 <_vfprintf_r+0xc30>
80009540:	10 36       	cp.w	r6,r8
80009542:	c0 64       	brge	8000954e <_vfprintf_r+0xc06>
80009544:	fa cb f9 44 	sub	r11,sp,-1724
80009548:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000954c:	c1 d8       	rjmp	80009586 <_vfprintf_r+0xc3e>
8000954e:	fa c8 f9 50 	sub	r8,sp,-1712
80009552:	1a d8       	st.w	--sp,r8
80009554:	fa c8 fa b8 	sub	r8,sp,-1352
80009558:	04 9a       	mov	r10,r2
8000955a:	1a d8       	st.w	--sp,r8
8000955c:	fa c8 fb b4 	sub	r8,sp,-1100
80009560:	0c 9b       	mov	r11,r6
80009562:	1a d8       	st.w	--sp,r8
80009564:	08 9c       	mov	r12,r4
80009566:	fa c8 f9 40 	sub	r8,sp,-1728
8000956a:	fa c9 ff b4 	sub	r9,sp,-76
8000956e:	fe b0 f8 55 	rcall	80008618 <get_arg>
80009572:	2f dd       	sub	sp,-12
80009574:	78 0a       	ld.w	r10,r12[0x0]
80009576:	c2 08       	rjmp	800095b6 <_vfprintf_r+0xc6e>
80009578:	2f f7       	sub	r7,-1
8000957a:	10 39       	cp.w	r9,r8
8000957c:	c0 84       	brge	8000958c <_vfprintf_r+0xc44>
8000957e:	fa ca f9 44 	sub	r10,sp,-1724
80009582:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009586:	ec fa fd 88 	ld.w	r10,r6[-632]
8000958a:	c1 68       	rjmp	800095b6 <_vfprintf_r+0xc6e>
8000958c:	41 09       	lddsp	r9,sp[0x40]
8000958e:	59 f8       	cp.w	r8,31
80009590:	e0 89 00 10 	brgt	800095b0 <_vfprintf_r+0xc68>
80009594:	f2 ca ff fc 	sub	r10,r9,-4
80009598:	51 0a       	stdsp	sp[0x40],r10
8000959a:	fa c6 f9 44 	sub	r6,sp,-1724
8000959e:	72 0a       	ld.w	r10,r9[0x0]
800095a0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095a4:	f3 4a fd 88 	st.w	r9[-632],r10
800095a8:	2f f8       	sub	r8,-1
800095aa:	fb 48 06 b4 	st.w	sp[1716],r8
800095ae:	c0 48       	rjmp	800095b6 <_vfprintf_r+0xc6e>
800095b0:	72 0a       	ld.w	r10,r9[0x0]
800095b2:	2f c9       	sub	r9,-4
800095b4:	51 09       	stdsp	sp[0x40],r9
800095b6:	40 be       	lddsp	lr,sp[0x2c]
800095b8:	b4 0e       	st.h	r10[0x0],lr
800095ba:	fe 9f fa 55 	bral	80008a64 <_vfprintf_r+0x11c>
800095be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095c2:	40 3c       	lddsp	r12,sp[0xc]
800095c4:	58 0c       	cp.w	r12,0
800095c6:	c1 d0       	breq	80009600 <_vfprintf_r+0xcb8>
800095c8:	10 36       	cp.w	r6,r8
800095ca:	c0 64       	brge	800095d6 <_vfprintf_r+0xc8e>
800095cc:	fa cb f9 44 	sub	r11,sp,-1724
800095d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095d4:	c1 d8       	rjmp	8000960e <_vfprintf_r+0xcc6>
800095d6:	fa c8 f9 50 	sub	r8,sp,-1712
800095da:	1a d8       	st.w	--sp,r8
800095dc:	fa c8 fa b8 	sub	r8,sp,-1352
800095e0:	04 9a       	mov	r10,r2
800095e2:	1a d8       	st.w	--sp,r8
800095e4:	fa c8 fb b4 	sub	r8,sp,-1100
800095e8:	0c 9b       	mov	r11,r6
800095ea:	1a d8       	st.w	--sp,r8
800095ec:	08 9c       	mov	r12,r4
800095ee:	fa c8 f9 40 	sub	r8,sp,-1728
800095f2:	fa c9 ff b4 	sub	r9,sp,-76
800095f6:	fe b0 f8 11 	rcall	80008618 <get_arg>
800095fa:	2f dd       	sub	sp,-12
800095fc:	78 0a       	ld.w	r10,r12[0x0]
800095fe:	c2 08       	rjmp	8000963e <_vfprintf_r+0xcf6>
80009600:	2f f7       	sub	r7,-1
80009602:	10 39       	cp.w	r9,r8
80009604:	c0 84       	brge	80009614 <_vfprintf_r+0xccc>
80009606:	fa ca f9 44 	sub	r10,sp,-1724
8000960a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000960e:	ec fa fd 88 	ld.w	r10,r6[-632]
80009612:	c1 68       	rjmp	8000963e <_vfprintf_r+0xcf6>
80009614:	41 09       	lddsp	r9,sp[0x40]
80009616:	59 f8       	cp.w	r8,31
80009618:	e0 89 00 10 	brgt	80009638 <_vfprintf_r+0xcf0>
8000961c:	f2 ca ff fc 	sub	r10,r9,-4
80009620:	51 0a       	stdsp	sp[0x40],r10
80009622:	fa c6 f9 44 	sub	r6,sp,-1724
80009626:	72 0a       	ld.w	r10,r9[0x0]
80009628:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000962c:	f3 4a fd 88 	st.w	r9[-632],r10
80009630:	2f f8       	sub	r8,-1
80009632:	fb 48 06 b4 	st.w	sp[1716],r8
80009636:	c0 48       	rjmp	8000963e <_vfprintf_r+0xcf6>
80009638:	72 0a       	ld.w	r10,r9[0x0]
8000963a:	2f c9       	sub	r9,-4
8000963c:	51 09       	stdsp	sp[0x40],r9
8000963e:	40 be       	lddsp	lr,sp[0x2c]
80009640:	95 0e       	st.w	r10[0x0],lr
80009642:	fe 9f fa 11 	bral	80008a64 <_vfprintf_r+0x11c>
80009646:	50 a7       	stdsp	sp[0x28],r7
80009648:	50 80       	stdsp	sp[0x20],r0
8000964a:	0c 97       	mov	r7,r6
8000964c:	04 94       	mov	r4,r2
8000964e:	06 96       	mov	r6,r3
80009650:	02 92       	mov	r2,r1
80009652:	40 93       	lddsp	r3,sp[0x24]
80009654:	10 90       	mov	r0,r8
80009656:	40 41       	lddsp	r1,sp[0x10]
80009658:	a5 a5       	sbr	r5,0x4
8000965a:	c0 a8       	rjmp	8000966e <_vfprintf_r+0xd26>
8000965c:	50 a7       	stdsp	sp[0x28],r7
8000965e:	50 80       	stdsp	sp[0x20],r0
80009660:	0c 97       	mov	r7,r6
80009662:	04 94       	mov	r4,r2
80009664:	06 96       	mov	r6,r3
80009666:	02 92       	mov	r2,r1
80009668:	40 93       	lddsp	r3,sp[0x24]
8000966a:	10 90       	mov	r0,r8
8000966c:	40 41       	lddsp	r1,sp[0x10]
8000966e:	ed b5 00 05 	bld	r5,0x5
80009672:	c5 d1       	brne	8000972c <_vfprintf_r+0xde4>
80009674:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009678:	40 3c       	lddsp	r12,sp[0xc]
8000967a:	58 0c       	cp.w	r12,0
8000967c:	c2 60       	breq	800096c8 <_vfprintf_r+0xd80>
8000967e:	10 36       	cp.w	r6,r8
80009680:	c0 a4       	brge	80009694 <_vfprintf_r+0xd4c>
80009682:	fa cb f9 44 	sub	r11,sp,-1724
80009686:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000968a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000968e:	fa e9 00 00 	st.d	sp[0],r8
80009692:	c1 88       	rjmp	800096c2 <_vfprintf_r+0xd7a>
80009694:	fa c8 f9 50 	sub	r8,sp,-1712
80009698:	1a d8       	st.w	--sp,r8
8000969a:	fa c8 fa b8 	sub	r8,sp,-1352
8000969e:	04 9a       	mov	r10,r2
800096a0:	1a d8       	st.w	--sp,r8
800096a2:	0c 9b       	mov	r11,r6
800096a4:	fa c8 fb b4 	sub	r8,sp,-1100
800096a8:	08 9c       	mov	r12,r4
800096aa:	1a d8       	st.w	--sp,r8
800096ac:	fa c8 f9 40 	sub	r8,sp,-1728
800096b0:	fa c9 ff b4 	sub	r9,sp,-76
800096b4:	fe b0 f7 b2 	rcall	80008618 <get_arg>
800096b8:	2f dd       	sub	sp,-12
800096ba:	f8 ea 00 00 	ld.d	r10,r12[0]
800096be:	fa eb 00 00 	st.d	sp[0],r10
800096c2:	30 08       	mov	r8,0
800096c4:	e0 8f 03 de 	bral	80009e80 <_vfprintf_r+0x1538>
800096c8:	ee ca ff ff 	sub	r10,r7,-1
800096cc:	10 37       	cp.w	r7,r8
800096ce:	c0 b4       	brge	800096e4 <_vfprintf_r+0xd9c>
800096d0:	fa c9 f9 44 	sub	r9,sp,-1724
800096d4:	14 97       	mov	r7,r10
800096d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096da:	ec ea fd 88 	ld.d	r10,r6[-632]
800096de:	fa eb 00 00 	st.d	sp[0],r10
800096e2:	c1 88       	rjmp	80009712 <_vfprintf_r+0xdca>
800096e4:	41 09       	lddsp	r9,sp[0x40]
800096e6:	59 f8       	cp.w	r8,31
800096e8:	e0 89 00 18 	brgt	80009718 <_vfprintf_r+0xdd0>
800096ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800096f0:	f2 cb ff f8 	sub	r11,r9,-8
800096f4:	fa e7 00 00 	st.d	sp[0],r6
800096f8:	51 0b       	stdsp	sp[0x40],r11
800096fa:	fa c6 f9 44 	sub	r6,sp,-1724
800096fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009702:	fa e6 00 00 	ld.d	r6,sp[0]
80009706:	f2 e7 fd 88 	st.d	r9[-632],r6
8000970a:	2f f8       	sub	r8,-1
8000970c:	14 97       	mov	r7,r10
8000970e:	fb 48 06 b4 	st.w	sp[1716],r8
80009712:	40 38       	lddsp	r8,sp[0xc]
80009714:	e0 8f 03 b6 	bral	80009e80 <_vfprintf_r+0x1538>
80009718:	f2 e6 00 00 	ld.d	r6,r9[0]
8000971c:	40 38       	lddsp	r8,sp[0xc]
8000971e:	fa e7 00 00 	st.d	sp[0],r6
80009722:	2f 89       	sub	r9,-8
80009724:	14 97       	mov	r7,r10
80009726:	51 09       	stdsp	sp[0x40],r9
80009728:	e0 8f 03 ac 	bral	80009e80 <_vfprintf_r+0x1538>
8000972c:	ed b5 00 04 	bld	r5,0x4
80009730:	c1 61       	brne	8000975c <_vfprintf_r+0xe14>
80009732:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009736:	40 3e       	lddsp	lr,sp[0xc]
80009738:	58 0e       	cp.w	lr,0
8000973a:	c0 80       	breq	8000974a <_vfprintf_r+0xe02>
8000973c:	10 36       	cp.w	r6,r8
8000973e:	c6 74       	brge	8000980c <_vfprintf_r+0xec4>
80009740:	fa cc f9 44 	sub	r12,sp,-1724
80009744:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009748:	c8 08       	rjmp	80009848 <_vfprintf_r+0xf00>
8000974a:	ee ca ff ff 	sub	r10,r7,-1
8000974e:	10 37       	cp.w	r7,r8
80009750:	c7 f4       	brge	8000984e <_vfprintf_r+0xf06>
80009752:	fa cb f9 44 	sub	r11,sp,-1724
80009756:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000975a:	c7 68       	rjmp	80009846 <_vfprintf_r+0xefe>
8000975c:	ed b5 00 06 	bld	r5,0x6
80009760:	c4 a1       	brne	800097f4 <_vfprintf_r+0xeac>
80009762:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009766:	40 3c       	lddsp	r12,sp[0xc]
80009768:	58 0c       	cp.w	r12,0
8000976a:	c1 d0       	breq	800097a4 <_vfprintf_r+0xe5c>
8000976c:	10 36       	cp.w	r6,r8
8000976e:	c0 64       	brge	8000977a <_vfprintf_r+0xe32>
80009770:	fa cb f9 44 	sub	r11,sp,-1724
80009774:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009778:	c1 f8       	rjmp	800097b6 <_vfprintf_r+0xe6e>
8000977a:	fa c8 f9 50 	sub	r8,sp,-1712
8000977e:	1a d8       	st.w	--sp,r8
80009780:	fa c8 fa b8 	sub	r8,sp,-1352
80009784:	1a d8       	st.w	--sp,r8
80009786:	fa c8 fb b4 	sub	r8,sp,-1100
8000978a:	1a d8       	st.w	--sp,r8
8000978c:	fa c8 f9 40 	sub	r8,sp,-1728
80009790:	fa c9 ff b4 	sub	r9,sp,-76
80009794:	04 9a       	mov	r10,r2
80009796:	0c 9b       	mov	r11,r6
80009798:	08 9c       	mov	r12,r4
8000979a:	fe b0 f7 3f 	rcall	80008618 <get_arg>
8000979e:	2f dd       	sub	sp,-12
800097a0:	98 18       	ld.sh	r8,r12[0x2]
800097a2:	c2 68       	rjmp	800097ee <_vfprintf_r+0xea6>
800097a4:	ee ca ff ff 	sub	r10,r7,-1
800097a8:	10 37       	cp.w	r7,r8
800097aa:	c0 94       	brge	800097bc <_vfprintf_r+0xe74>
800097ac:	fa c9 f9 44 	sub	r9,sp,-1724
800097b0:	14 97       	mov	r7,r10
800097b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800097b6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800097ba:	c1 a8       	rjmp	800097ee <_vfprintf_r+0xea6>
800097bc:	41 09       	lddsp	r9,sp[0x40]
800097be:	59 f8       	cp.w	r8,31
800097c0:	e0 89 00 13 	brgt	800097e6 <_vfprintf_r+0xe9e>
800097c4:	f2 cb ff fc 	sub	r11,r9,-4
800097c8:	51 0b       	stdsp	sp[0x40],r11
800097ca:	72 09       	ld.w	r9,r9[0x0]
800097cc:	fa c6 f9 44 	sub	r6,sp,-1724
800097d0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800097d4:	2f f8       	sub	r8,-1
800097d6:	f7 49 fd 88 	st.w	r11[-632],r9
800097da:	fb 48 06 b4 	st.w	sp[1716],r8
800097de:	14 97       	mov	r7,r10
800097e0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800097e4:	c0 58       	rjmp	800097ee <_vfprintf_r+0xea6>
800097e6:	92 18       	ld.sh	r8,r9[0x2]
800097e8:	14 97       	mov	r7,r10
800097ea:	2f c9       	sub	r9,-4
800097ec:	51 09       	stdsp	sp[0x40],r9
800097ee:	5c 78       	castu.h	r8
800097f0:	50 18       	stdsp	sp[0x4],r8
800097f2:	c4 68       	rjmp	8000987e <_vfprintf_r+0xf36>
800097f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800097f8:	40 3c       	lddsp	r12,sp[0xc]
800097fa:	58 0c       	cp.w	r12,0
800097fc:	c1 d0       	breq	80009836 <_vfprintf_r+0xeee>
800097fe:	10 36       	cp.w	r6,r8
80009800:	c0 64       	brge	8000980c <_vfprintf_r+0xec4>
80009802:	fa cb f9 44 	sub	r11,sp,-1724
80009806:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000980a:	c1 f8       	rjmp	80009848 <_vfprintf_r+0xf00>
8000980c:	fa c8 f9 50 	sub	r8,sp,-1712
80009810:	1a d8       	st.w	--sp,r8
80009812:	fa c8 fa b8 	sub	r8,sp,-1352
80009816:	0c 9b       	mov	r11,r6
80009818:	1a d8       	st.w	--sp,r8
8000981a:	fa c8 fb b4 	sub	r8,sp,-1100
8000981e:	04 9a       	mov	r10,r2
80009820:	1a d8       	st.w	--sp,r8
80009822:	08 9c       	mov	r12,r4
80009824:	fa c8 f9 40 	sub	r8,sp,-1728
80009828:	fa c9 ff b4 	sub	r9,sp,-76
8000982c:	fe b0 f6 f6 	rcall	80008618 <get_arg>
80009830:	2f dd       	sub	sp,-12
80009832:	78 0b       	ld.w	r11,r12[0x0]
80009834:	c2 48       	rjmp	8000987c <_vfprintf_r+0xf34>
80009836:	ee ca ff ff 	sub	r10,r7,-1
8000983a:	10 37       	cp.w	r7,r8
8000983c:	c0 94       	brge	8000984e <_vfprintf_r+0xf06>
8000983e:	fa c9 f9 44 	sub	r9,sp,-1724
80009842:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009846:	14 97       	mov	r7,r10
80009848:	ec fb fd 88 	ld.w	r11,r6[-632]
8000984c:	c1 88       	rjmp	8000987c <_vfprintf_r+0xf34>
8000984e:	41 09       	lddsp	r9,sp[0x40]
80009850:	59 f8       	cp.w	r8,31
80009852:	e0 89 00 11 	brgt	80009874 <_vfprintf_r+0xf2c>
80009856:	f2 cb ff fc 	sub	r11,r9,-4
8000985a:	51 0b       	stdsp	sp[0x40],r11
8000985c:	fa c6 f9 44 	sub	r6,sp,-1724
80009860:	72 0b       	ld.w	r11,r9[0x0]
80009862:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009866:	f3 4b fd 88 	st.w	r9[-632],r11
8000986a:	2f f8       	sub	r8,-1
8000986c:	14 97       	mov	r7,r10
8000986e:	fb 48 06 b4 	st.w	sp[1716],r8
80009872:	c0 58       	rjmp	8000987c <_vfprintf_r+0xf34>
80009874:	72 0b       	ld.w	r11,r9[0x0]
80009876:	14 97       	mov	r7,r10
80009878:	2f c9       	sub	r9,-4
8000987a:	51 09       	stdsp	sp[0x40],r9
8000987c:	50 1b       	stdsp	sp[0x4],r11
8000987e:	30 0e       	mov	lr,0
80009880:	50 0e       	stdsp	sp[0x0],lr
80009882:	1c 98       	mov	r8,lr
80009884:	e0 8f 02 fe 	bral	80009e80 <_vfprintf_r+0x1538>
80009888:	50 a7       	stdsp	sp[0x28],r7
8000988a:	50 80       	stdsp	sp[0x20],r0
8000988c:	0c 97       	mov	r7,r6
8000988e:	04 94       	mov	r4,r2
80009890:	06 96       	mov	r6,r3
80009892:	02 92       	mov	r2,r1
80009894:	40 93       	lddsp	r3,sp[0x24]
80009896:	40 41       	lddsp	r1,sp[0x10]
80009898:	0e 99       	mov	r9,r7
8000989a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000989e:	40 3c       	lddsp	r12,sp[0xc]
800098a0:	58 0c       	cp.w	r12,0
800098a2:	c1 d0       	breq	800098dc <_vfprintf_r+0xf94>
800098a4:	10 36       	cp.w	r6,r8
800098a6:	c0 64       	brge	800098b2 <_vfprintf_r+0xf6a>
800098a8:	fa cb f9 44 	sub	r11,sp,-1724
800098ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800098b0:	c1 d8       	rjmp	800098ea <_vfprintf_r+0xfa2>
800098b2:	fa c8 f9 50 	sub	r8,sp,-1712
800098b6:	1a d8       	st.w	--sp,r8
800098b8:	fa c8 fa b8 	sub	r8,sp,-1352
800098bc:	1a d8       	st.w	--sp,r8
800098be:	fa c8 fb b4 	sub	r8,sp,-1100
800098c2:	1a d8       	st.w	--sp,r8
800098c4:	fa c9 ff b4 	sub	r9,sp,-76
800098c8:	fa c8 f9 40 	sub	r8,sp,-1728
800098cc:	04 9a       	mov	r10,r2
800098ce:	0c 9b       	mov	r11,r6
800098d0:	08 9c       	mov	r12,r4
800098d2:	fe b0 f6 a3 	rcall	80008618 <get_arg>
800098d6:	2f dd       	sub	sp,-12
800098d8:	78 09       	ld.w	r9,r12[0x0]
800098da:	c2 18       	rjmp	8000991c <_vfprintf_r+0xfd4>
800098dc:	2f f7       	sub	r7,-1
800098de:	10 39       	cp.w	r9,r8
800098e0:	c0 84       	brge	800098f0 <_vfprintf_r+0xfa8>
800098e2:	fa ca f9 44 	sub	r10,sp,-1724
800098e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800098ea:	ec f9 fd 88 	ld.w	r9,r6[-632]
800098ee:	c1 78       	rjmp	8000991c <_vfprintf_r+0xfd4>
800098f0:	41 09       	lddsp	r9,sp[0x40]
800098f2:	59 f8       	cp.w	r8,31
800098f4:	e0 89 00 10 	brgt	80009914 <_vfprintf_r+0xfcc>
800098f8:	f2 ca ff fc 	sub	r10,r9,-4
800098fc:	51 0a       	stdsp	sp[0x40],r10
800098fe:	fa c6 f9 44 	sub	r6,sp,-1724
80009902:	72 09       	ld.w	r9,r9[0x0]
80009904:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009908:	f5 49 fd 88 	st.w	r10[-632],r9
8000990c:	2f f8       	sub	r8,-1
8000990e:	fb 48 06 b4 	st.w	sp[1716],r8
80009912:	c0 58       	rjmp	8000991c <_vfprintf_r+0xfd4>
80009914:	f2 c8 ff fc 	sub	r8,r9,-4
80009918:	51 08       	stdsp	sp[0x40],r8
8000991a:	72 09       	ld.w	r9,r9[0x0]
8000991c:	33 08       	mov	r8,48
8000991e:	fb 68 06 b8 	st.b	sp[1720],r8
80009922:	37 88       	mov	r8,120
80009924:	30 0e       	mov	lr,0
80009926:	fb 68 06 b9 	st.b	sp[1721],r8
8000992a:	fe cc af 5a 	sub	r12,pc,-20646
8000992e:	50 19       	stdsp	sp[0x4],r9
80009930:	a1 b5       	sbr	r5,0x1
80009932:	50 0e       	stdsp	sp[0x0],lr
80009934:	50 dc       	stdsp	sp[0x34],r12
80009936:	30 28       	mov	r8,2
80009938:	37 80       	mov	r0,120
8000993a:	e0 8f 02 a3 	bral	80009e80 <_vfprintf_r+0x1538>
8000993e:	50 a7       	stdsp	sp[0x28],r7
80009940:	50 80       	stdsp	sp[0x20],r0
80009942:	10 90       	mov	r0,r8
80009944:	30 08       	mov	r8,0
80009946:	fb 68 06 bb 	st.b	sp[1723],r8
8000994a:	0c 97       	mov	r7,r6
8000994c:	04 94       	mov	r4,r2
8000994e:	06 96       	mov	r6,r3
80009950:	02 92       	mov	r2,r1
80009952:	40 93       	lddsp	r3,sp[0x24]
80009954:	40 41       	lddsp	r1,sp[0x10]
80009956:	0e 99       	mov	r9,r7
80009958:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000995c:	40 3b       	lddsp	r11,sp[0xc]
8000995e:	58 0b       	cp.w	r11,0
80009960:	c1 d0       	breq	8000999a <_vfprintf_r+0x1052>
80009962:	10 36       	cp.w	r6,r8
80009964:	c0 64       	brge	80009970 <_vfprintf_r+0x1028>
80009966:	fa ca f9 44 	sub	r10,sp,-1724
8000996a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000996e:	c1 d8       	rjmp	800099a8 <_vfprintf_r+0x1060>
80009970:	fa c8 f9 50 	sub	r8,sp,-1712
80009974:	1a d8       	st.w	--sp,r8
80009976:	fa c8 fa b8 	sub	r8,sp,-1352
8000997a:	1a d8       	st.w	--sp,r8
8000997c:	fa c8 fb b4 	sub	r8,sp,-1100
80009980:	0c 9b       	mov	r11,r6
80009982:	1a d8       	st.w	--sp,r8
80009984:	04 9a       	mov	r10,r2
80009986:	fa c8 f9 40 	sub	r8,sp,-1728
8000998a:	fa c9 ff b4 	sub	r9,sp,-76
8000998e:	08 9c       	mov	r12,r4
80009990:	fe b0 f6 44 	rcall	80008618 <get_arg>
80009994:	2f dd       	sub	sp,-12
80009996:	78 06       	ld.w	r6,r12[0x0]
80009998:	c2 08       	rjmp	800099d8 <_vfprintf_r+0x1090>
8000999a:	2f f7       	sub	r7,-1
8000999c:	10 39       	cp.w	r9,r8
8000999e:	c0 84       	brge	800099ae <_vfprintf_r+0x1066>
800099a0:	fa c9 f9 44 	sub	r9,sp,-1724
800099a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800099a8:	ec f6 fd 88 	ld.w	r6,r6[-632]
800099ac:	c1 68       	rjmp	800099d8 <_vfprintf_r+0x1090>
800099ae:	41 09       	lddsp	r9,sp[0x40]
800099b0:	59 f8       	cp.w	r8,31
800099b2:	e0 89 00 10 	brgt	800099d2 <_vfprintf_r+0x108a>
800099b6:	f2 ca ff fc 	sub	r10,r9,-4
800099ba:	51 0a       	stdsp	sp[0x40],r10
800099bc:	72 06       	ld.w	r6,r9[0x0]
800099be:	fa ce f9 44 	sub	lr,sp,-1724
800099c2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800099c6:	f3 46 fd 88 	st.w	r9[-632],r6
800099ca:	2f f8       	sub	r8,-1
800099cc:	fb 48 06 b4 	st.w	sp[1716],r8
800099d0:	c0 48       	rjmp	800099d8 <_vfprintf_r+0x1090>
800099d2:	72 06       	ld.w	r6,r9[0x0]
800099d4:	2f c9       	sub	r9,-4
800099d6:	51 09       	stdsp	sp[0x40],r9
800099d8:	40 2c       	lddsp	r12,sp[0x8]
800099da:	58 0c       	cp.w	r12,0
800099dc:	c1 05       	brlt	800099fc <_vfprintf_r+0x10b4>
800099de:	18 9a       	mov	r10,r12
800099e0:	30 0b       	mov	r11,0
800099e2:	0c 9c       	mov	r12,r6
800099e4:	e0 a0 12 38 	rcall	8000be54 <memchr>
800099e8:	e0 80 02 df 	breq	80009fa6 <_vfprintf_r+0x165e>
800099ec:	f8 06 01 02 	sub	r2,r12,r6
800099f0:	40 2b       	lddsp	r11,sp[0x8]
800099f2:	16 32       	cp.w	r2,r11
800099f4:	e0 89 02 d9 	brgt	80009fa6 <_vfprintf_r+0x165e>
800099f8:	e0 8f 02 d4 	bral	80009fa0 <_vfprintf_r+0x1658>
800099fc:	30 0a       	mov	r10,0
800099fe:	0c 9c       	mov	r12,r6
80009a00:	50 2a       	stdsp	sp[0x8],r10
80009a02:	e0 a0 15 99 	rcall	8000c534 <strlen>
80009a06:	18 92       	mov	r2,r12
80009a08:	e0 8f 02 d2 	bral	80009fac <_vfprintf_r+0x1664>
80009a0c:	50 a7       	stdsp	sp[0x28],r7
80009a0e:	50 80       	stdsp	sp[0x20],r0
80009a10:	0c 97       	mov	r7,r6
80009a12:	04 94       	mov	r4,r2
80009a14:	06 96       	mov	r6,r3
80009a16:	02 92       	mov	r2,r1
80009a18:	40 93       	lddsp	r3,sp[0x24]
80009a1a:	10 90       	mov	r0,r8
80009a1c:	40 41       	lddsp	r1,sp[0x10]
80009a1e:	a5 a5       	sbr	r5,0x4
80009a20:	c0 a8       	rjmp	80009a34 <_vfprintf_r+0x10ec>
80009a22:	50 a7       	stdsp	sp[0x28],r7
80009a24:	50 80       	stdsp	sp[0x20],r0
80009a26:	0c 97       	mov	r7,r6
80009a28:	04 94       	mov	r4,r2
80009a2a:	06 96       	mov	r6,r3
80009a2c:	02 92       	mov	r2,r1
80009a2e:	40 93       	lddsp	r3,sp[0x24]
80009a30:	10 90       	mov	r0,r8
80009a32:	40 41       	lddsp	r1,sp[0x10]
80009a34:	ed b5 00 05 	bld	r5,0x5
80009a38:	c5 61       	brne	80009ae4 <_vfprintf_r+0x119c>
80009a3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a3e:	40 39       	lddsp	r9,sp[0xc]
80009a40:	58 09       	cp.w	r9,0
80009a42:	c2 10       	breq	80009a84 <_vfprintf_r+0x113c>
80009a44:	10 36       	cp.w	r6,r8
80009a46:	c0 74       	brge	80009a54 <_vfprintf_r+0x110c>
80009a48:	fa c8 f9 44 	sub	r8,sp,-1724
80009a4c:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009a50:	c2 38       	rjmp	80009a96 <_vfprintf_r+0x114e>
80009a52:	d7 03       	nop
80009a54:	fa c8 f9 50 	sub	r8,sp,-1712
80009a58:	1a d8       	st.w	--sp,r8
80009a5a:	fa c8 fa b8 	sub	r8,sp,-1352
80009a5e:	1a d8       	st.w	--sp,r8
80009a60:	fa c8 fb b4 	sub	r8,sp,-1100
80009a64:	1a d8       	st.w	--sp,r8
80009a66:	fa c8 f9 40 	sub	r8,sp,-1728
80009a6a:	fa c9 ff b4 	sub	r9,sp,-76
80009a6e:	04 9a       	mov	r10,r2
80009a70:	0c 9b       	mov	r11,r6
80009a72:	08 9c       	mov	r12,r4
80009a74:	fe b0 f5 d2 	rcall	80008618 <get_arg>
80009a78:	2f dd       	sub	sp,-12
80009a7a:	f8 e8 00 00 	ld.d	r8,r12[0]
80009a7e:	fa e9 00 00 	st.d	sp[0],r8
80009a82:	c2 e8       	rjmp	80009ade <_vfprintf_r+0x1196>
80009a84:	ee ca ff ff 	sub	r10,r7,-1
80009a88:	10 37       	cp.w	r7,r8
80009a8a:	c0 b4       	brge	80009aa0 <_vfprintf_r+0x1158>
80009a8c:	fa c8 f9 44 	sub	r8,sp,-1724
80009a90:	14 97       	mov	r7,r10
80009a92:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009a96:	ec ea fd 88 	ld.d	r10,r6[-632]
80009a9a:	fa eb 00 00 	st.d	sp[0],r10
80009a9e:	c2 08       	rjmp	80009ade <_vfprintf_r+0x1196>
80009aa0:	41 09       	lddsp	r9,sp[0x40]
80009aa2:	59 f8       	cp.w	r8,31
80009aa4:	e0 89 00 16 	brgt	80009ad0 <_vfprintf_r+0x1188>
80009aa8:	f2 e6 00 00 	ld.d	r6,r9[0]
80009aac:	f2 cb ff f8 	sub	r11,r9,-8
80009ab0:	fa e7 00 00 	st.d	sp[0],r6
80009ab4:	51 0b       	stdsp	sp[0x40],r11
80009ab6:	fa c6 f9 44 	sub	r6,sp,-1724
80009aba:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009abe:	fa e6 00 00 	ld.d	r6,sp[0]
80009ac2:	f2 e7 fd 88 	st.d	r9[-632],r6
80009ac6:	2f f8       	sub	r8,-1
80009ac8:	14 97       	mov	r7,r10
80009aca:	fb 48 06 b4 	st.w	sp[1716],r8
80009ace:	c0 88       	rjmp	80009ade <_vfprintf_r+0x1196>
80009ad0:	f2 e6 00 00 	ld.d	r6,r9[0]
80009ad4:	2f 89       	sub	r9,-8
80009ad6:	fa e7 00 00 	st.d	sp[0],r6
80009ada:	51 09       	stdsp	sp[0x40],r9
80009adc:	14 97       	mov	r7,r10
80009ade:	30 18       	mov	r8,1
80009ae0:	e0 8f 01 d0 	bral	80009e80 <_vfprintf_r+0x1538>
80009ae4:	ed b5 00 04 	bld	r5,0x4
80009ae8:	c1 61       	brne	80009b14 <_vfprintf_r+0x11cc>
80009aea:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009aee:	40 3e       	lddsp	lr,sp[0xc]
80009af0:	58 0e       	cp.w	lr,0
80009af2:	c0 80       	breq	80009b02 <_vfprintf_r+0x11ba>
80009af4:	10 36       	cp.w	r6,r8
80009af6:	c6 74       	brge	80009bc4 <_vfprintf_r+0x127c>
80009af8:	fa cc f9 44 	sub	r12,sp,-1724
80009afc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009b00:	c8 08       	rjmp	80009c00 <_vfprintf_r+0x12b8>
80009b02:	ee ca ff ff 	sub	r10,r7,-1
80009b06:	10 37       	cp.w	r7,r8
80009b08:	c7 f4       	brge	80009c06 <_vfprintf_r+0x12be>
80009b0a:	fa cb f9 44 	sub	r11,sp,-1724
80009b0e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b12:	c7 68       	rjmp	80009bfe <_vfprintf_r+0x12b6>
80009b14:	ed b5 00 06 	bld	r5,0x6
80009b18:	c4 a1       	brne	80009bac <_vfprintf_r+0x1264>
80009b1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b1e:	40 3c       	lddsp	r12,sp[0xc]
80009b20:	58 0c       	cp.w	r12,0
80009b22:	c1 d0       	breq	80009b5c <_vfprintf_r+0x1214>
80009b24:	10 36       	cp.w	r6,r8
80009b26:	c0 64       	brge	80009b32 <_vfprintf_r+0x11ea>
80009b28:	fa cb f9 44 	sub	r11,sp,-1724
80009b2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b30:	c1 f8       	rjmp	80009b6e <_vfprintf_r+0x1226>
80009b32:	fa c8 f9 50 	sub	r8,sp,-1712
80009b36:	1a d8       	st.w	--sp,r8
80009b38:	fa c8 fa b8 	sub	r8,sp,-1352
80009b3c:	1a d8       	st.w	--sp,r8
80009b3e:	fa c8 fb b4 	sub	r8,sp,-1100
80009b42:	1a d8       	st.w	--sp,r8
80009b44:	fa c8 f9 40 	sub	r8,sp,-1728
80009b48:	fa c9 ff b4 	sub	r9,sp,-76
80009b4c:	04 9a       	mov	r10,r2
80009b4e:	0c 9b       	mov	r11,r6
80009b50:	08 9c       	mov	r12,r4
80009b52:	fe b0 f5 63 	rcall	80008618 <get_arg>
80009b56:	2f dd       	sub	sp,-12
80009b58:	98 18       	ld.sh	r8,r12[0x2]
80009b5a:	c2 68       	rjmp	80009ba6 <_vfprintf_r+0x125e>
80009b5c:	ee ca ff ff 	sub	r10,r7,-1
80009b60:	10 37       	cp.w	r7,r8
80009b62:	c0 94       	brge	80009b74 <_vfprintf_r+0x122c>
80009b64:	fa c9 f9 44 	sub	r9,sp,-1724
80009b68:	14 97       	mov	r7,r10
80009b6a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009b6e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009b72:	c1 a8       	rjmp	80009ba6 <_vfprintf_r+0x125e>
80009b74:	41 09       	lddsp	r9,sp[0x40]
80009b76:	59 f8       	cp.w	r8,31
80009b78:	e0 89 00 13 	brgt	80009b9e <_vfprintf_r+0x1256>
80009b7c:	f2 cb ff fc 	sub	r11,r9,-4
80009b80:	51 0b       	stdsp	sp[0x40],r11
80009b82:	72 09       	ld.w	r9,r9[0x0]
80009b84:	fa c6 f9 44 	sub	r6,sp,-1724
80009b88:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009b8c:	2f f8       	sub	r8,-1
80009b8e:	f7 49 fd 88 	st.w	r11[-632],r9
80009b92:	fb 48 06 b4 	st.w	sp[1716],r8
80009b96:	14 97       	mov	r7,r10
80009b98:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009b9c:	c0 58       	rjmp	80009ba6 <_vfprintf_r+0x125e>
80009b9e:	92 18       	ld.sh	r8,r9[0x2]
80009ba0:	14 97       	mov	r7,r10
80009ba2:	2f c9       	sub	r9,-4
80009ba4:	51 09       	stdsp	sp[0x40],r9
80009ba6:	5c 78       	castu.h	r8
80009ba8:	50 18       	stdsp	sp[0x4],r8
80009baa:	c4 68       	rjmp	80009c36 <_vfprintf_r+0x12ee>
80009bac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009bb0:	40 3c       	lddsp	r12,sp[0xc]
80009bb2:	58 0c       	cp.w	r12,0
80009bb4:	c1 d0       	breq	80009bee <_vfprintf_r+0x12a6>
80009bb6:	10 36       	cp.w	r6,r8
80009bb8:	c0 64       	brge	80009bc4 <_vfprintf_r+0x127c>
80009bba:	fa cb f9 44 	sub	r11,sp,-1724
80009bbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009bc2:	c1 f8       	rjmp	80009c00 <_vfprintf_r+0x12b8>
80009bc4:	fa c8 f9 50 	sub	r8,sp,-1712
80009bc8:	1a d8       	st.w	--sp,r8
80009bca:	fa c8 fa b8 	sub	r8,sp,-1352
80009bce:	0c 9b       	mov	r11,r6
80009bd0:	1a d8       	st.w	--sp,r8
80009bd2:	fa c8 fb b4 	sub	r8,sp,-1100
80009bd6:	04 9a       	mov	r10,r2
80009bd8:	1a d8       	st.w	--sp,r8
80009bda:	08 9c       	mov	r12,r4
80009bdc:	fa c8 f9 40 	sub	r8,sp,-1728
80009be0:	fa c9 ff b4 	sub	r9,sp,-76
80009be4:	fe b0 f5 1a 	rcall	80008618 <get_arg>
80009be8:	2f dd       	sub	sp,-12
80009bea:	78 0b       	ld.w	r11,r12[0x0]
80009bec:	c2 48       	rjmp	80009c34 <_vfprintf_r+0x12ec>
80009bee:	ee ca ff ff 	sub	r10,r7,-1
80009bf2:	10 37       	cp.w	r7,r8
80009bf4:	c0 94       	brge	80009c06 <_vfprintf_r+0x12be>
80009bf6:	fa c9 f9 44 	sub	r9,sp,-1724
80009bfa:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009bfe:	14 97       	mov	r7,r10
80009c00:	ec fb fd 88 	ld.w	r11,r6[-632]
80009c04:	c1 88       	rjmp	80009c34 <_vfprintf_r+0x12ec>
80009c06:	41 09       	lddsp	r9,sp[0x40]
80009c08:	59 f8       	cp.w	r8,31
80009c0a:	e0 89 00 11 	brgt	80009c2c <_vfprintf_r+0x12e4>
80009c0e:	f2 cb ff fc 	sub	r11,r9,-4
80009c12:	51 0b       	stdsp	sp[0x40],r11
80009c14:	fa c6 f9 44 	sub	r6,sp,-1724
80009c18:	72 0b       	ld.w	r11,r9[0x0]
80009c1a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c1e:	f3 4b fd 88 	st.w	r9[-632],r11
80009c22:	2f f8       	sub	r8,-1
80009c24:	14 97       	mov	r7,r10
80009c26:	fb 48 06 b4 	st.w	sp[1716],r8
80009c2a:	c0 58       	rjmp	80009c34 <_vfprintf_r+0x12ec>
80009c2c:	72 0b       	ld.w	r11,r9[0x0]
80009c2e:	14 97       	mov	r7,r10
80009c30:	2f c9       	sub	r9,-4
80009c32:	51 09       	stdsp	sp[0x40],r9
80009c34:	50 1b       	stdsp	sp[0x4],r11
80009c36:	30 0e       	mov	lr,0
80009c38:	30 18       	mov	r8,1
80009c3a:	50 0e       	stdsp	sp[0x0],lr
80009c3c:	c2 29       	rjmp	80009e80 <_vfprintf_r+0x1538>
80009c3e:	50 a7       	stdsp	sp[0x28],r7
80009c40:	50 80       	stdsp	sp[0x20],r0
80009c42:	0c 97       	mov	r7,r6
80009c44:	04 94       	mov	r4,r2
80009c46:	06 96       	mov	r6,r3
80009c48:	02 92       	mov	r2,r1
80009c4a:	fe cc b2 7a 	sub	r12,pc,-19846
80009c4e:	40 93       	lddsp	r3,sp[0x24]
80009c50:	10 90       	mov	r0,r8
80009c52:	40 41       	lddsp	r1,sp[0x10]
80009c54:	50 dc       	stdsp	sp[0x34],r12
80009c56:	ed b5 00 05 	bld	r5,0x5
80009c5a:	c5 51       	brne	80009d04 <_vfprintf_r+0x13bc>
80009c5c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c60:	40 3b       	lddsp	r11,sp[0xc]
80009c62:	58 0b       	cp.w	r11,0
80009c64:	c2 20       	breq	80009ca8 <_vfprintf_r+0x1360>
80009c66:	10 36       	cp.w	r6,r8
80009c68:	c0 a4       	brge	80009c7c <_vfprintf_r+0x1334>
80009c6a:	fa ca f9 44 	sub	r10,sp,-1724
80009c6e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009c72:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009c76:	fa e9 00 00 	st.d	sp[0],r8
80009c7a:	cf 28       	rjmp	80009e5e <_vfprintf_r+0x1516>
80009c7c:	fa c8 f9 50 	sub	r8,sp,-1712
80009c80:	1a d8       	st.w	--sp,r8
80009c82:	fa c8 fa b8 	sub	r8,sp,-1352
80009c86:	04 9a       	mov	r10,r2
80009c88:	1a d8       	st.w	--sp,r8
80009c8a:	0c 9b       	mov	r11,r6
80009c8c:	fa c8 fb b4 	sub	r8,sp,-1100
80009c90:	08 9c       	mov	r12,r4
80009c92:	1a d8       	st.w	--sp,r8
80009c94:	fa c8 f9 40 	sub	r8,sp,-1728
80009c98:	fa c9 ff b4 	sub	r9,sp,-76
80009c9c:	fe b0 f4 be 	rcall	80008618 <get_arg>
80009ca0:	2f dd       	sub	sp,-12
80009ca2:	f8 ea 00 00 	ld.d	r10,r12[0]
80009ca6:	c0 c8       	rjmp	80009cbe <_vfprintf_r+0x1376>
80009ca8:	ee ca ff ff 	sub	r10,r7,-1
80009cac:	10 37       	cp.w	r7,r8
80009cae:	c0 b4       	brge	80009cc4 <_vfprintf_r+0x137c>
80009cb0:	fa c9 f9 44 	sub	r9,sp,-1724
80009cb4:	14 97       	mov	r7,r10
80009cb6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009cba:	ec ea fd 88 	ld.d	r10,r6[-632]
80009cbe:	fa eb 00 00 	st.d	sp[0],r10
80009cc2:	cc e8       	rjmp	80009e5e <_vfprintf_r+0x1516>
80009cc4:	41 09       	lddsp	r9,sp[0x40]
80009cc6:	59 f8       	cp.w	r8,31
80009cc8:	e0 89 00 16 	brgt	80009cf4 <_vfprintf_r+0x13ac>
80009ccc:	f2 e6 00 00 	ld.d	r6,r9[0]
80009cd0:	f2 cb ff f8 	sub	r11,r9,-8
80009cd4:	fa e7 00 00 	st.d	sp[0],r6
80009cd8:	51 0b       	stdsp	sp[0x40],r11
80009cda:	fa c6 f9 44 	sub	r6,sp,-1724
80009cde:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009ce2:	fa e6 00 00 	ld.d	r6,sp[0]
80009ce6:	f2 e7 fd 88 	st.d	r9[-632],r6
80009cea:	2f f8       	sub	r8,-1
80009cec:	14 97       	mov	r7,r10
80009cee:	fb 48 06 b4 	st.w	sp[1716],r8
80009cf2:	cb 68       	rjmp	80009e5e <_vfprintf_r+0x1516>
80009cf4:	f2 e6 00 00 	ld.d	r6,r9[0]
80009cf8:	2f 89       	sub	r9,-8
80009cfa:	fa e7 00 00 	st.d	sp[0],r6
80009cfe:	51 09       	stdsp	sp[0x40],r9
80009d00:	14 97       	mov	r7,r10
80009d02:	ca e8       	rjmp	80009e5e <_vfprintf_r+0x1516>
80009d04:	ed b5 00 04 	bld	r5,0x4
80009d08:	c1 71       	brne	80009d36 <_vfprintf_r+0x13ee>
80009d0a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d0e:	40 3e       	lddsp	lr,sp[0xc]
80009d10:	58 0e       	cp.w	lr,0
80009d12:	c0 80       	breq	80009d22 <_vfprintf_r+0x13da>
80009d14:	10 36       	cp.w	r6,r8
80009d16:	c6 94       	brge	80009de8 <_vfprintf_r+0x14a0>
80009d18:	fa cc f9 44 	sub	r12,sp,-1724
80009d1c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009d20:	c8 28       	rjmp	80009e24 <_vfprintf_r+0x14dc>
80009d22:	ee ca ff ff 	sub	r10,r7,-1
80009d26:	10 37       	cp.w	r7,r8
80009d28:	e0 84 00 81 	brge	80009e2a <_vfprintf_r+0x14e2>
80009d2c:	fa cb f9 44 	sub	r11,sp,-1724
80009d30:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d34:	c7 78       	rjmp	80009e22 <_vfprintf_r+0x14da>
80009d36:	ed b5 00 06 	bld	r5,0x6
80009d3a:	c4 b1       	brne	80009dd0 <_vfprintf_r+0x1488>
80009d3c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d40:	40 3c       	lddsp	r12,sp[0xc]
80009d42:	58 0c       	cp.w	r12,0
80009d44:	c1 d0       	breq	80009d7e <_vfprintf_r+0x1436>
80009d46:	10 36       	cp.w	r6,r8
80009d48:	c0 64       	brge	80009d54 <_vfprintf_r+0x140c>
80009d4a:	fa cb f9 44 	sub	r11,sp,-1724
80009d4e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d52:	c1 f8       	rjmp	80009d90 <_vfprintf_r+0x1448>
80009d54:	fa c8 f9 50 	sub	r8,sp,-1712
80009d58:	1a d8       	st.w	--sp,r8
80009d5a:	fa c8 fa b8 	sub	r8,sp,-1352
80009d5e:	1a d8       	st.w	--sp,r8
80009d60:	fa c8 fb b4 	sub	r8,sp,-1100
80009d64:	1a d8       	st.w	--sp,r8
80009d66:	fa c8 f9 40 	sub	r8,sp,-1728
80009d6a:	fa c9 ff b4 	sub	r9,sp,-76
80009d6e:	04 9a       	mov	r10,r2
80009d70:	0c 9b       	mov	r11,r6
80009d72:	08 9c       	mov	r12,r4
80009d74:	fe b0 f4 52 	rcall	80008618 <get_arg>
80009d78:	2f dd       	sub	sp,-12
80009d7a:	98 18       	ld.sh	r8,r12[0x2]
80009d7c:	c2 78       	rjmp	80009dca <_vfprintf_r+0x1482>
80009d7e:	ee ca ff ff 	sub	r10,r7,-1
80009d82:	10 37       	cp.w	r7,r8
80009d84:	c0 a4       	brge	80009d98 <_vfprintf_r+0x1450>
80009d86:	fa c9 f9 44 	sub	r9,sp,-1724
80009d8a:	14 97       	mov	r7,r10
80009d8c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009d90:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009d94:	c1 b8       	rjmp	80009dca <_vfprintf_r+0x1482>
80009d96:	d7 03       	nop
80009d98:	41 09       	lddsp	r9,sp[0x40]
80009d9a:	59 f8       	cp.w	r8,31
80009d9c:	e0 89 00 13 	brgt	80009dc2 <_vfprintf_r+0x147a>
80009da0:	f2 cb ff fc 	sub	r11,r9,-4
80009da4:	51 0b       	stdsp	sp[0x40],r11
80009da6:	72 09       	ld.w	r9,r9[0x0]
80009da8:	fa c6 f9 44 	sub	r6,sp,-1724
80009dac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009db0:	2f f8       	sub	r8,-1
80009db2:	f7 49 fd 88 	st.w	r11[-632],r9
80009db6:	fb 48 06 b4 	st.w	sp[1716],r8
80009dba:	14 97       	mov	r7,r10
80009dbc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009dc0:	c0 58       	rjmp	80009dca <_vfprintf_r+0x1482>
80009dc2:	92 18       	ld.sh	r8,r9[0x2]
80009dc4:	14 97       	mov	r7,r10
80009dc6:	2f c9       	sub	r9,-4
80009dc8:	51 09       	stdsp	sp[0x40],r9
80009dca:	5c 78       	castu.h	r8
80009dcc:	50 18       	stdsp	sp[0x4],r8
80009dce:	c4 68       	rjmp	80009e5a <_vfprintf_r+0x1512>
80009dd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009dd4:	40 3c       	lddsp	r12,sp[0xc]
80009dd6:	58 0c       	cp.w	r12,0
80009dd8:	c1 d0       	breq	80009e12 <_vfprintf_r+0x14ca>
80009dda:	10 36       	cp.w	r6,r8
80009ddc:	c0 64       	brge	80009de8 <_vfprintf_r+0x14a0>
80009dde:	fa cb f9 44 	sub	r11,sp,-1724
80009de2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009de6:	c1 f8       	rjmp	80009e24 <_vfprintf_r+0x14dc>
80009de8:	fa c8 f9 50 	sub	r8,sp,-1712
80009dec:	1a d8       	st.w	--sp,r8
80009dee:	fa c8 fa b8 	sub	r8,sp,-1352
80009df2:	0c 9b       	mov	r11,r6
80009df4:	1a d8       	st.w	--sp,r8
80009df6:	fa c8 fb b4 	sub	r8,sp,-1100
80009dfa:	04 9a       	mov	r10,r2
80009dfc:	1a d8       	st.w	--sp,r8
80009dfe:	08 9c       	mov	r12,r4
80009e00:	fa c8 f9 40 	sub	r8,sp,-1728
80009e04:	fa c9 ff b4 	sub	r9,sp,-76
80009e08:	fe b0 f4 08 	rcall	80008618 <get_arg>
80009e0c:	2f dd       	sub	sp,-12
80009e0e:	78 0b       	ld.w	r11,r12[0x0]
80009e10:	c2 48       	rjmp	80009e58 <_vfprintf_r+0x1510>
80009e12:	ee ca ff ff 	sub	r10,r7,-1
80009e16:	10 37       	cp.w	r7,r8
80009e18:	c0 94       	brge	80009e2a <_vfprintf_r+0x14e2>
80009e1a:	fa c9 f9 44 	sub	r9,sp,-1724
80009e1e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009e22:	14 97       	mov	r7,r10
80009e24:	ec fb fd 88 	ld.w	r11,r6[-632]
80009e28:	c1 88       	rjmp	80009e58 <_vfprintf_r+0x1510>
80009e2a:	41 09       	lddsp	r9,sp[0x40]
80009e2c:	59 f8       	cp.w	r8,31
80009e2e:	e0 89 00 11 	brgt	80009e50 <_vfprintf_r+0x1508>
80009e32:	f2 cb ff fc 	sub	r11,r9,-4
80009e36:	51 0b       	stdsp	sp[0x40],r11
80009e38:	fa c6 f9 44 	sub	r6,sp,-1724
80009e3c:	72 0b       	ld.w	r11,r9[0x0]
80009e3e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009e42:	f3 4b fd 88 	st.w	r9[-632],r11
80009e46:	2f f8       	sub	r8,-1
80009e48:	14 97       	mov	r7,r10
80009e4a:	fb 48 06 b4 	st.w	sp[1716],r8
80009e4e:	c0 58       	rjmp	80009e58 <_vfprintf_r+0x1510>
80009e50:	72 0b       	ld.w	r11,r9[0x0]
80009e52:	14 97       	mov	r7,r10
80009e54:	2f c9       	sub	r9,-4
80009e56:	51 09       	stdsp	sp[0x40],r9
80009e58:	50 1b       	stdsp	sp[0x4],r11
80009e5a:	30 0e       	mov	lr,0
80009e5c:	50 0e       	stdsp	sp[0x0],lr
80009e5e:	40 08       	lddsp	r8,sp[0x0]
80009e60:	40 1c       	lddsp	r12,sp[0x4]
80009e62:	18 48       	or	r8,r12
80009e64:	5f 19       	srne	r9
80009e66:	0a 98       	mov	r8,r5
80009e68:	eb e9 00 09 	and	r9,r5,r9
80009e6c:	a1 b8       	sbr	r8,0x1
80009e6e:	58 09       	cp.w	r9,0
80009e70:	c0 70       	breq	80009e7e <_vfprintf_r+0x1536>
80009e72:	10 95       	mov	r5,r8
80009e74:	fb 60 06 b9 	st.b	sp[1721],r0
80009e78:	33 08       	mov	r8,48
80009e7a:	fb 68 06 b8 	st.b	sp[1720],r8
80009e7e:	30 28       	mov	r8,2
80009e80:	30 09       	mov	r9,0
80009e82:	fb 69 06 bb 	st.b	sp[1723],r9
80009e86:	0a 99       	mov	r9,r5
80009e88:	a7 d9       	cbr	r9,0x7
80009e8a:	40 2b       	lddsp	r11,sp[0x8]
80009e8c:	40 16       	lddsp	r6,sp[0x4]
80009e8e:	58 0b       	cp.w	r11,0
80009e90:	5f 1a       	srne	r10
80009e92:	f2 05 17 40 	movge	r5,r9
80009e96:	fa c2 f9 78 	sub	r2,sp,-1672
80009e9a:	40 09       	lddsp	r9,sp[0x0]
80009e9c:	0c 49       	or	r9,r6
80009e9e:	5f 19       	srne	r9
80009ea0:	f5 e9 10 09 	or	r9,r10,r9
80009ea4:	c5 c0       	breq	80009f5c <_vfprintf_r+0x1614>
80009ea6:	30 19       	mov	r9,1
80009ea8:	f2 08 18 00 	cp.b	r8,r9
80009eac:	c0 60       	breq	80009eb8 <_vfprintf_r+0x1570>
80009eae:	30 29       	mov	r9,2
80009eb0:	f2 08 18 00 	cp.b	r8,r9
80009eb4:	c0 41       	brne	80009ebc <_vfprintf_r+0x1574>
80009eb6:	c3 c8       	rjmp	80009f2e <_vfprintf_r+0x15e6>
80009eb8:	04 96       	mov	r6,r2
80009eba:	c3 08       	rjmp	80009f1a <_vfprintf_r+0x15d2>
80009ebc:	04 96       	mov	r6,r2
80009ebe:	fa e8 00 00 	ld.d	r8,sp[0]
80009ec2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009ec6:	2d 0a       	sub	r10,-48
80009ec8:	0c fa       	st.b	--r6,r10
80009eca:	f0 0b 16 03 	lsr	r11,r8,0x3
80009ece:	f2 0c 16 03 	lsr	r12,r9,0x3
80009ed2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009ed6:	18 99       	mov	r9,r12
80009ed8:	16 98       	mov	r8,r11
80009eda:	58 08       	cp.w	r8,0
80009edc:	5c 29       	cpc	r9
80009ede:	cf 21       	brne	80009ec2 <_vfprintf_r+0x157a>
80009ee0:	fa e9 00 00 	st.d	sp[0],r8
80009ee4:	ed b5 00 00 	bld	r5,0x0
80009ee8:	c4 51       	brne	80009f72 <_vfprintf_r+0x162a>
80009eea:	33 09       	mov	r9,48
80009eec:	f2 0a 18 00 	cp.b	r10,r9
80009ef0:	c4 10       	breq	80009f72 <_vfprintf_r+0x162a>
80009ef2:	0c f9       	st.b	--r6,r9
80009ef4:	c3 f8       	rjmp	80009f72 <_vfprintf_r+0x162a>
80009ef6:	fa ea 00 00 	ld.d	r10,sp[0]
80009efa:	30 a8       	mov	r8,10
80009efc:	30 09       	mov	r9,0
80009efe:	e0 a0 1a 19 	rcall	8000d330 <__avr32_umod64>
80009f02:	30 a8       	mov	r8,10
80009f04:	2d 0a       	sub	r10,-48
80009f06:	30 09       	mov	r9,0
80009f08:	ac 8a       	st.b	r6[0x0],r10
80009f0a:	fa ea 00 00 	ld.d	r10,sp[0]
80009f0e:	e0 a0 18 df 	rcall	8000d0cc <__avr32_udiv64>
80009f12:	16 99       	mov	r9,r11
80009f14:	14 98       	mov	r8,r10
80009f16:	fa e9 00 00 	st.d	sp[0],r8
80009f1a:	20 16       	sub	r6,1
80009f1c:	fa ea 00 00 	ld.d	r10,sp[0]
80009f20:	58 9a       	cp.w	r10,9
80009f22:	5c 2b       	cpc	r11
80009f24:	fe 9b ff e9 	brhi	80009ef6 <_vfprintf_r+0x15ae>
80009f28:	1b f8       	ld.ub	r8,sp[0x7]
80009f2a:	2d 08       	sub	r8,-48
80009f2c:	c2 08       	rjmp	80009f6c <_vfprintf_r+0x1624>
80009f2e:	04 96       	mov	r6,r2
80009f30:	fa e8 00 00 	ld.d	r8,sp[0]
80009f34:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009f38:	40 de       	lddsp	lr,sp[0x34]
80009f3a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009f3e:	0c fa       	st.b	--r6,r10
80009f40:	f2 0b 16 04 	lsr	r11,r9,0x4
80009f44:	f0 0a 16 04 	lsr	r10,r8,0x4
80009f48:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009f4c:	16 99       	mov	r9,r11
80009f4e:	14 98       	mov	r8,r10
80009f50:	58 08       	cp.w	r8,0
80009f52:	5c 29       	cpc	r9
80009f54:	cf 01       	brne	80009f34 <_vfprintf_r+0x15ec>
80009f56:	fa e9 00 00 	st.d	sp[0],r8
80009f5a:	c0 c8       	rjmp	80009f72 <_vfprintf_r+0x162a>
80009f5c:	58 08       	cp.w	r8,0
80009f5e:	c0 91       	brne	80009f70 <_vfprintf_r+0x1628>
80009f60:	ed b5 00 00 	bld	r5,0x0
80009f64:	c0 61       	brne	80009f70 <_vfprintf_r+0x1628>
80009f66:	fa c6 f9 79 	sub	r6,sp,-1671
80009f6a:	33 08       	mov	r8,48
80009f6c:	ac 88       	st.b	r6[0x0],r8
80009f6e:	c0 28       	rjmp	80009f72 <_vfprintf_r+0x162a>
80009f70:	04 96       	mov	r6,r2
80009f72:	0c 12       	sub	r2,r6
80009f74:	c1 c8       	rjmp	80009fac <_vfprintf_r+0x1664>
80009f76:	50 a7       	stdsp	sp[0x28],r7
80009f78:	50 80       	stdsp	sp[0x20],r0
80009f7a:	40 93       	lddsp	r3,sp[0x24]
80009f7c:	0c 97       	mov	r7,r6
80009f7e:	10 90       	mov	r0,r8
80009f80:	04 94       	mov	r4,r2
80009f82:	40 41       	lddsp	r1,sp[0x10]
80009f84:	58 08       	cp.w	r8,0
80009f86:	e0 80 04 4f 	breq	8000a824 <_vfprintf_r+0x1edc>
80009f8a:	fb 68 06 60 	st.b	sp[1632],r8
80009f8e:	30 0c       	mov	r12,0
80009f90:	30 08       	mov	r8,0
80009f92:	30 12       	mov	r2,1
80009f94:	fb 68 06 bb 	st.b	sp[1723],r8
80009f98:	50 2c       	stdsp	sp[0x8],r12
80009f9a:	fa c6 f9 a0 	sub	r6,sp,-1632
80009f9e:	c0 78       	rjmp	80009fac <_vfprintf_r+0x1664>
80009fa0:	30 0b       	mov	r11,0
80009fa2:	50 2b       	stdsp	sp[0x8],r11
80009fa4:	c0 48       	rjmp	80009fac <_vfprintf_r+0x1664>
80009fa6:	40 22       	lddsp	r2,sp[0x8]
80009fa8:	30 0a       	mov	r10,0
80009faa:	50 2a       	stdsp	sp[0x8],r10
80009fac:	40 29       	lddsp	r9,sp[0x8]
80009fae:	e4 09 0c 49 	max	r9,r2,r9
80009fb2:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009fb6:	50 39       	stdsp	sp[0xc],r9
80009fb8:	0a 9e       	mov	lr,r5
80009fba:	30 09       	mov	r9,0
80009fbc:	e2 1e 00 02 	andl	lr,0x2,COH
80009fc0:	f2 08 18 00 	cp.b	r8,r9
80009fc4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009fc8:	f7 b8 01 ff 	subne	r8,-1
80009fcc:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009fd0:	0a 9b       	mov	r11,r5
80009fd2:	58 0e       	cp.w	lr,0
80009fd4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009fd8:	f7 bc 01 fe 	subne	r12,-2
80009fdc:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009fe0:	e2 1b 00 84 	andl	r11,0x84,COH
80009fe4:	50 fe       	stdsp	sp[0x3c],lr
80009fe6:	50 9b       	stdsp	sp[0x24],r11
80009fe8:	c4 71       	brne	8000a076 <_vfprintf_r+0x172e>
80009fea:	40 8a       	lddsp	r10,sp[0x20]
80009fec:	40 39       	lddsp	r9,sp[0xc]
80009fee:	12 1a       	sub	r10,r9
80009ff0:	50 4a       	stdsp	sp[0x10],r10
80009ff2:	58 0a       	cp.w	r10,0
80009ff4:	e0 89 00 20 	brgt	8000a034 <_vfprintf_r+0x16ec>
80009ff8:	c3 f8       	rjmp	8000a076 <_vfprintf_r+0x172e>
80009ffa:	2f 09       	sub	r9,-16
80009ffc:	2f f8       	sub	r8,-1
80009ffe:	fe ce b6 16 	sub	lr,pc,-18922
8000a002:	31 0c       	mov	r12,16
8000a004:	fb 49 06 90 	st.w	sp[1680],r9
8000a008:	87 0e       	st.w	r3[0x0],lr
8000a00a:	87 1c       	st.w	r3[0x4],r12
8000a00c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a010:	58 78       	cp.w	r8,7
8000a012:	e0 89 00 04 	brgt	8000a01a <_vfprintf_r+0x16d2>
8000a016:	2f 83       	sub	r3,-8
8000a018:	c0 b8       	rjmp	8000a02e <_vfprintf_r+0x16e6>
8000a01a:	fa ca f9 78 	sub	r10,sp,-1672
8000a01e:	02 9b       	mov	r11,r1
8000a020:	08 9c       	mov	r12,r4
8000a022:	fe b0 f4 85 	rcall	8000892c <__sprint_r>
8000a026:	e0 81 04 10 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a02a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a02e:	40 4b       	lddsp	r11,sp[0x10]
8000a030:	21 0b       	sub	r11,16
8000a032:	50 4b       	stdsp	sp[0x10],r11
8000a034:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a038:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a03c:	fe ca b6 54 	sub	r10,pc,-18860
8000a040:	40 4e       	lddsp	lr,sp[0x10]
8000a042:	59 0e       	cp.w	lr,16
8000a044:	fe 99 ff db 	brgt	80009ffa <_vfprintf_r+0x16b2>
8000a048:	1c 09       	add	r9,lr
8000a04a:	2f f8       	sub	r8,-1
8000a04c:	87 0a       	st.w	r3[0x0],r10
8000a04e:	fb 49 06 90 	st.w	sp[1680],r9
8000a052:	87 1e       	st.w	r3[0x4],lr
8000a054:	fb 48 06 8c 	st.w	sp[1676],r8
8000a058:	58 78       	cp.w	r8,7
8000a05a:	e0 89 00 04 	brgt	8000a062 <_vfprintf_r+0x171a>
8000a05e:	2f 83       	sub	r3,-8
8000a060:	c0 b8       	rjmp	8000a076 <_vfprintf_r+0x172e>
8000a062:	fa ca f9 78 	sub	r10,sp,-1672
8000a066:	02 9b       	mov	r11,r1
8000a068:	08 9c       	mov	r12,r4
8000a06a:	fe b0 f4 61 	rcall	8000892c <__sprint_r>
8000a06e:	e0 81 03 ec 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a072:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a076:	30 09       	mov	r9,0
8000a078:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a07c:	f2 08 18 00 	cp.b	r8,r9
8000a080:	c1 f0       	breq	8000a0be <_vfprintf_r+0x1776>
8000a082:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a086:	fa c9 f9 45 	sub	r9,sp,-1723
8000a08a:	2f f8       	sub	r8,-1
8000a08c:	87 09       	st.w	r3[0x0],r9
8000a08e:	fb 48 06 90 	st.w	sp[1680],r8
8000a092:	30 19       	mov	r9,1
8000a094:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a098:	87 19       	st.w	r3[0x4],r9
8000a09a:	2f f8       	sub	r8,-1
8000a09c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0a0:	58 78       	cp.w	r8,7
8000a0a2:	e0 89 00 04 	brgt	8000a0aa <_vfprintf_r+0x1762>
8000a0a6:	2f 83       	sub	r3,-8
8000a0a8:	c0 b8       	rjmp	8000a0be <_vfprintf_r+0x1776>
8000a0aa:	fa ca f9 78 	sub	r10,sp,-1672
8000a0ae:	02 9b       	mov	r11,r1
8000a0b0:	08 9c       	mov	r12,r4
8000a0b2:	fe b0 f4 3d 	rcall	8000892c <__sprint_r>
8000a0b6:	e0 81 03 c8 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a0ba:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0be:	40 fc       	lddsp	r12,sp[0x3c]
8000a0c0:	58 0c       	cp.w	r12,0
8000a0c2:	c1 f0       	breq	8000a100 <_vfprintf_r+0x17b8>
8000a0c4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a0c8:	fa c9 f9 48 	sub	r9,sp,-1720
8000a0cc:	2f e8       	sub	r8,-2
8000a0ce:	87 09       	st.w	r3[0x0],r9
8000a0d0:	fb 48 06 90 	st.w	sp[1680],r8
8000a0d4:	30 29       	mov	r9,2
8000a0d6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a0da:	87 19       	st.w	r3[0x4],r9
8000a0dc:	2f f8       	sub	r8,-1
8000a0de:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0e2:	58 78       	cp.w	r8,7
8000a0e4:	e0 89 00 04 	brgt	8000a0ec <_vfprintf_r+0x17a4>
8000a0e8:	2f 83       	sub	r3,-8
8000a0ea:	c0 b8       	rjmp	8000a100 <_vfprintf_r+0x17b8>
8000a0ec:	fa ca f9 78 	sub	r10,sp,-1672
8000a0f0:	02 9b       	mov	r11,r1
8000a0f2:	08 9c       	mov	r12,r4
8000a0f4:	fe b0 f4 1c 	rcall	8000892c <__sprint_r>
8000a0f8:	e0 81 03 a7 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a0fc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a100:	40 9b       	lddsp	r11,sp[0x24]
8000a102:	e0 4b 00 80 	cp.w	r11,128
8000a106:	c4 71       	brne	8000a194 <_vfprintf_r+0x184c>
8000a108:	40 8a       	lddsp	r10,sp[0x20]
8000a10a:	40 39       	lddsp	r9,sp[0xc]
8000a10c:	12 1a       	sub	r10,r9
8000a10e:	50 4a       	stdsp	sp[0x10],r10
8000a110:	58 0a       	cp.w	r10,0
8000a112:	e0 89 00 20 	brgt	8000a152 <_vfprintf_r+0x180a>
8000a116:	c3 f8       	rjmp	8000a194 <_vfprintf_r+0x184c>
8000a118:	2f 09       	sub	r9,-16
8000a11a:	2f f8       	sub	r8,-1
8000a11c:	fe ce b7 24 	sub	lr,pc,-18652
8000a120:	31 0c       	mov	r12,16
8000a122:	fb 49 06 90 	st.w	sp[1680],r9
8000a126:	87 0e       	st.w	r3[0x0],lr
8000a128:	87 1c       	st.w	r3[0x4],r12
8000a12a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a12e:	58 78       	cp.w	r8,7
8000a130:	e0 89 00 04 	brgt	8000a138 <_vfprintf_r+0x17f0>
8000a134:	2f 83       	sub	r3,-8
8000a136:	c0 b8       	rjmp	8000a14c <_vfprintf_r+0x1804>
8000a138:	fa ca f9 78 	sub	r10,sp,-1672
8000a13c:	02 9b       	mov	r11,r1
8000a13e:	08 9c       	mov	r12,r4
8000a140:	fe b0 f3 f6 	rcall	8000892c <__sprint_r>
8000a144:	e0 81 03 81 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a148:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a14c:	40 4b       	lddsp	r11,sp[0x10]
8000a14e:	21 0b       	sub	r11,16
8000a150:	50 4b       	stdsp	sp[0x10],r11
8000a152:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a156:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a15a:	fe ca b7 62 	sub	r10,pc,-18590
8000a15e:	40 4e       	lddsp	lr,sp[0x10]
8000a160:	59 0e       	cp.w	lr,16
8000a162:	fe 99 ff db 	brgt	8000a118 <_vfprintf_r+0x17d0>
8000a166:	1c 09       	add	r9,lr
8000a168:	2f f8       	sub	r8,-1
8000a16a:	87 0a       	st.w	r3[0x0],r10
8000a16c:	fb 49 06 90 	st.w	sp[1680],r9
8000a170:	87 1e       	st.w	r3[0x4],lr
8000a172:	fb 48 06 8c 	st.w	sp[1676],r8
8000a176:	58 78       	cp.w	r8,7
8000a178:	e0 89 00 04 	brgt	8000a180 <_vfprintf_r+0x1838>
8000a17c:	2f 83       	sub	r3,-8
8000a17e:	c0 b8       	rjmp	8000a194 <_vfprintf_r+0x184c>
8000a180:	fa ca f9 78 	sub	r10,sp,-1672
8000a184:	02 9b       	mov	r11,r1
8000a186:	08 9c       	mov	r12,r4
8000a188:	fe b0 f3 d2 	rcall	8000892c <__sprint_r>
8000a18c:	e0 81 03 5d 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a190:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a194:	40 2c       	lddsp	r12,sp[0x8]
8000a196:	04 1c       	sub	r12,r2
8000a198:	50 2c       	stdsp	sp[0x8],r12
8000a19a:	58 0c       	cp.w	r12,0
8000a19c:	e0 89 00 20 	brgt	8000a1dc <_vfprintf_r+0x1894>
8000a1a0:	c3 f8       	rjmp	8000a21e <_vfprintf_r+0x18d6>
8000a1a2:	2f 09       	sub	r9,-16
8000a1a4:	2f f8       	sub	r8,-1
8000a1a6:	fe cb b7 ae 	sub	r11,pc,-18514
8000a1aa:	31 0a       	mov	r10,16
8000a1ac:	fb 49 06 90 	st.w	sp[1680],r9
8000a1b0:	87 0b       	st.w	r3[0x0],r11
8000a1b2:	87 1a       	st.w	r3[0x4],r10
8000a1b4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a1b8:	58 78       	cp.w	r8,7
8000a1ba:	e0 89 00 04 	brgt	8000a1c2 <_vfprintf_r+0x187a>
8000a1be:	2f 83       	sub	r3,-8
8000a1c0:	c0 b8       	rjmp	8000a1d6 <_vfprintf_r+0x188e>
8000a1c2:	fa ca f9 78 	sub	r10,sp,-1672
8000a1c6:	02 9b       	mov	r11,r1
8000a1c8:	08 9c       	mov	r12,r4
8000a1ca:	fe b0 f3 b1 	rcall	8000892c <__sprint_r>
8000a1ce:	e0 81 03 3c 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a1d2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1d6:	40 29       	lddsp	r9,sp[0x8]
8000a1d8:	21 09       	sub	r9,16
8000a1da:	50 29       	stdsp	sp[0x8],r9
8000a1dc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a1e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a1e4:	fe ca b7 ec 	sub	r10,pc,-18452
8000a1e8:	40 2e       	lddsp	lr,sp[0x8]
8000a1ea:	59 0e       	cp.w	lr,16
8000a1ec:	fe 99 ff db 	brgt	8000a1a2 <_vfprintf_r+0x185a>
8000a1f0:	1c 09       	add	r9,lr
8000a1f2:	2f f8       	sub	r8,-1
8000a1f4:	87 0a       	st.w	r3[0x0],r10
8000a1f6:	fb 49 06 90 	st.w	sp[1680],r9
8000a1fa:	87 1e       	st.w	r3[0x4],lr
8000a1fc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a200:	58 78       	cp.w	r8,7
8000a202:	e0 89 00 04 	brgt	8000a20a <_vfprintf_r+0x18c2>
8000a206:	2f 83       	sub	r3,-8
8000a208:	c0 b8       	rjmp	8000a21e <_vfprintf_r+0x18d6>
8000a20a:	fa ca f9 78 	sub	r10,sp,-1672
8000a20e:	02 9b       	mov	r11,r1
8000a210:	08 9c       	mov	r12,r4
8000a212:	fe b0 f3 8d 	rcall	8000892c <__sprint_r>
8000a216:	e0 81 03 18 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a21a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a21e:	ed b5 00 08 	bld	r5,0x8
8000a222:	c0 b0       	breq	8000a238 <_vfprintf_r+0x18f0>
8000a224:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a228:	87 12       	st.w	r3[0x4],r2
8000a22a:	87 06       	st.w	r3[0x0],r6
8000a22c:	f0 02 00 02 	add	r2,r8,r2
8000a230:	fb 42 06 90 	st.w	sp[1680],r2
8000a234:	e0 8f 01 d4 	bral	8000a5dc <_vfprintf_r+0x1c94>
8000a238:	e0 40 00 65 	cp.w	r0,101
8000a23c:	e0 8a 01 d6 	brle	8000a5e8 <_vfprintf_r+0x1ca0>
8000a240:	30 08       	mov	r8,0
8000a242:	30 09       	mov	r9,0
8000a244:	40 5b       	lddsp	r11,sp[0x14]
8000a246:	40 7a       	lddsp	r10,sp[0x1c]
8000a248:	e0 a0 15 3b 	rcall	8000ccbe <__avr32_f64_cmp_eq>
8000a24c:	c7 90       	breq	8000a33e <_vfprintf_r+0x19f6>
8000a24e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a252:	fe c9 b8 6e 	sub	r9,pc,-18322
8000a256:	2f f8       	sub	r8,-1
8000a258:	87 09       	st.w	r3[0x0],r9
8000a25a:	fb 48 06 90 	st.w	sp[1680],r8
8000a25e:	30 19       	mov	r9,1
8000a260:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a264:	87 19       	st.w	r3[0x4],r9
8000a266:	2f f8       	sub	r8,-1
8000a268:	fb 48 06 8c 	st.w	sp[1676],r8
8000a26c:	58 78       	cp.w	r8,7
8000a26e:	e0 89 00 05 	brgt	8000a278 <_vfprintf_r+0x1930>
8000a272:	2f 83       	sub	r3,-8
8000a274:	c0 c8       	rjmp	8000a28c <_vfprintf_r+0x1944>
8000a276:	d7 03       	nop
8000a278:	fa ca f9 78 	sub	r10,sp,-1672
8000a27c:	02 9b       	mov	r11,r1
8000a27e:	08 9c       	mov	r12,r4
8000a280:	fe b0 f3 56 	rcall	8000892c <__sprint_r>
8000a284:	e0 81 02 e1 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a288:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a28c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a290:	40 6c       	lddsp	r12,sp[0x18]
8000a292:	18 38       	cp.w	r8,r12
8000a294:	c0 55       	brlt	8000a29e <_vfprintf_r+0x1956>
8000a296:	ed b5 00 00 	bld	r5,0x0
8000a29a:	e0 81 02 6b 	brne	8000a770 <_vfprintf_r+0x1e28>
8000a29e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a2a2:	2f f8       	sub	r8,-1
8000a2a4:	40 cb       	lddsp	r11,sp[0x30]
8000a2a6:	fb 48 06 90 	st.w	sp[1680],r8
8000a2aa:	30 19       	mov	r9,1
8000a2ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a2b0:	87 0b       	st.w	r3[0x0],r11
8000a2b2:	2f f8       	sub	r8,-1
8000a2b4:	87 19       	st.w	r3[0x4],r9
8000a2b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2ba:	58 78       	cp.w	r8,7
8000a2bc:	e0 89 00 04 	brgt	8000a2c4 <_vfprintf_r+0x197c>
8000a2c0:	2f 83       	sub	r3,-8
8000a2c2:	c0 b8       	rjmp	8000a2d8 <_vfprintf_r+0x1990>
8000a2c4:	fa ca f9 78 	sub	r10,sp,-1672
8000a2c8:	02 9b       	mov	r11,r1
8000a2ca:	08 9c       	mov	r12,r4
8000a2cc:	fe b0 f3 30 	rcall	8000892c <__sprint_r>
8000a2d0:	e0 81 02 bb 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a2d4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a2d8:	40 66       	lddsp	r6,sp[0x18]
8000a2da:	20 16       	sub	r6,1
8000a2dc:	58 06       	cp.w	r6,0
8000a2de:	e0 89 00 1d 	brgt	8000a318 <_vfprintf_r+0x19d0>
8000a2e2:	e0 8f 02 47 	bral	8000a770 <_vfprintf_r+0x1e28>
8000a2e6:	2f 09       	sub	r9,-16
8000a2e8:	2f f8       	sub	r8,-1
8000a2ea:	fb 49 06 90 	st.w	sp[1680],r9
8000a2ee:	87 02       	st.w	r3[0x0],r2
8000a2f0:	87 10       	st.w	r3[0x4],r0
8000a2f2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2f6:	58 78       	cp.w	r8,7
8000a2f8:	e0 89 00 04 	brgt	8000a300 <_vfprintf_r+0x19b8>
8000a2fc:	2f 83       	sub	r3,-8
8000a2fe:	c0 b8       	rjmp	8000a314 <_vfprintf_r+0x19cc>
8000a300:	fa ca f9 78 	sub	r10,sp,-1672
8000a304:	02 9b       	mov	r11,r1
8000a306:	08 9c       	mov	r12,r4
8000a308:	fe b0 f3 12 	rcall	8000892c <__sprint_r>
8000a30c:	e0 81 02 9d 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a310:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a314:	21 06       	sub	r6,16
8000a316:	c0 48       	rjmp	8000a31e <_vfprintf_r+0x19d6>
8000a318:	fe c2 b9 20 	sub	r2,pc,-18144
8000a31c:	31 00       	mov	r0,16
8000a31e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a322:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a326:	fe ca b9 2e 	sub	r10,pc,-18130
8000a32a:	59 06       	cp.w	r6,16
8000a32c:	fe 99 ff dd 	brgt	8000a2e6 <_vfprintf_r+0x199e>
8000a330:	0c 09       	add	r9,r6
8000a332:	87 0a       	st.w	r3[0x0],r10
8000a334:	fb 49 06 90 	st.w	sp[1680],r9
8000a338:	2f f8       	sub	r8,-1
8000a33a:	87 16       	st.w	r3[0x4],r6
8000a33c:	c5 39       	rjmp	8000a5e2 <_vfprintf_r+0x1c9a>
8000a33e:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000a342:	58 0a       	cp.w	r10,0
8000a344:	e0 89 00 92 	brgt	8000a468 <_vfprintf_r+0x1b20>
8000a348:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a34c:	fe c9 b9 68 	sub	r9,pc,-18072
8000a350:	2f f8       	sub	r8,-1
8000a352:	87 09       	st.w	r3[0x0],r9
8000a354:	fb 48 06 90 	st.w	sp[1680],r8
8000a358:	30 19       	mov	r9,1
8000a35a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a35e:	87 19       	st.w	r3[0x4],r9
8000a360:	2f f8       	sub	r8,-1
8000a362:	fb 48 06 8c 	st.w	sp[1676],r8
8000a366:	58 78       	cp.w	r8,7
8000a368:	e0 89 00 04 	brgt	8000a370 <_vfprintf_r+0x1a28>
8000a36c:	2f 83       	sub	r3,-8
8000a36e:	c0 b8       	rjmp	8000a384 <_vfprintf_r+0x1a3c>
8000a370:	fa ca f9 78 	sub	r10,sp,-1672
8000a374:	02 9b       	mov	r11,r1
8000a376:	08 9c       	mov	r12,r4
8000a378:	fe b0 f2 da 	rcall	8000892c <__sprint_r>
8000a37c:	e0 81 02 65 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a380:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a384:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a388:	58 08       	cp.w	r8,0
8000a38a:	c0 81       	brne	8000a39a <_vfprintf_r+0x1a52>
8000a38c:	40 6a       	lddsp	r10,sp[0x18]
8000a38e:	58 0a       	cp.w	r10,0
8000a390:	c0 51       	brne	8000a39a <_vfprintf_r+0x1a52>
8000a392:	ed b5 00 00 	bld	r5,0x0
8000a396:	e0 81 01 ed 	brne	8000a770 <_vfprintf_r+0x1e28>
8000a39a:	40 c9       	lddsp	r9,sp[0x30]
8000a39c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a3a0:	2f f8       	sub	r8,-1
8000a3a2:	87 09       	st.w	r3[0x0],r9
8000a3a4:	fb 48 06 90 	st.w	sp[1680],r8
8000a3a8:	30 19       	mov	r9,1
8000a3aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a3ae:	87 19       	st.w	r3[0x4],r9
8000a3b0:	2f f8       	sub	r8,-1
8000a3b2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3b6:	58 78       	cp.w	r8,7
8000a3b8:	e0 89 00 04 	brgt	8000a3c0 <_vfprintf_r+0x1a78>
8000a3bc:	2f 83       	sub	r3,-8
8000a3be:	c0 b8       	rjmp	8000a3d4 <_vfprintf_r+0x1a8c>
8000a3c0:	fa ca f9 78 	sub	r10,sp,-1672
8000a3c4:	02 9b       	mov	r11,r1
8000a3c6:	08 9c       	mov	r12,r4
8000a3c8:	fe b0 f2 b2 	rcall	8000892c <__sprint_r>
8000a3cc:	e0 81 02 3d 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a3d0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a3d4:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a3d8:	5c 32       	neg	r2
8000a3da:	58 02       	cp.w	r2,0
8000a3dc:	e0 89 00 1d 	brgt	8000a416 <_vfprintf_r+0x1ace>
8000a3e0:	c3 d8       	rjmp	8000a45a <_vfprintf_r+0x1b12>
8000a3e2:	2f 09       	sub	r9,-16
8000a3e4:	2f f8       	sub	r8,-1
8000a3e6:	31 0e       	mov	lr,16
8000a3e8:	fb 49 06 90 	st.w	sp[1680],r9
8000a3ec:	87 00       	st.w	r3[0x0],r0
8000a3ee:	87 1e       	st.w	r3[0x4],lr
8000a3f0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3f4:	58 78       	cp.w	r8,7
8000a3f6:	e0 89 00 04 	brgt	8000a3fe <_vfprintf_r+0x1ab6>
8000a3fa:	2f 83       	sub	r3,-8
8000a3fc:	c0 b8       	rjmp	8000a412 <_vfprintf_r+0x1aca>
8000a3fe:	fa ca f9 78 	sub	r10,sp,-1672
8000a402:	02 9b       	mov	r11,r1
8000a404:	08 9c       	mov	r12,r4
8000a406:	fe b0 f2 93 	rcall	8000892c <__sprint_r>
8000a40a:	e0 81 02 1e 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a40e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a412:	21 02       	sub	r2,16
8000a414:	c0 38       	rjmp	8000a41a <_vfprintf_r+0x1ad2>
8000a416:	fe c0 ba 1e 	sub	r0,pc,-17890
8000a41a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a41e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a422:	fe ca ba 2a 	sub	r10,pc,-17878
8000a426:	59 02       	cp.w	r2,16
8000a428:	fe 99 ff dd 	brgt	8000a3e2 <_vfprintf_r+0x1a9a>
8000a42c:	04 09       	add	r9,r2
8000a42e:	2f f8       	sub	r8,-1
8000a430:	87 0a       	st.w	r3[0x0],r10
8000a432:	fb 49 06 90 	st.w	sp[1680],r9
8000a436:	87 12       	st.w	r3[0x4],r2
8000a438:	fb 48 06 8c 	st.w	sp[1676],r8
8000a43c:	58 78       	cp.w	r8,7
8000a43e:	e0 89 00 04 	brgt	8000a446 <_vfprintf_r+0x1afe>
8000a442:	2f 83       	sub	r3,-8
8000a444:	c0 b8       	rjmp	8000a45a <_vfprintf_r+0x1b12>
8000a446:	fa ca f9 78 	sub	r10,sp,-1672
8000a44a:	02 9b       	mov	r11,r1
8000a44c:	08 9c       	mov	r12,r4
8000a44e:	fe b0 f2 6f 	rcall	8000892c <__sprint_r>
8000a452:	e0 81 01 fa 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a456:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a45a:	40 6c       	lddsp	r12,sp[0x18]
8000a45c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a460:	87 06       	st.w	r3[0x0],r6
8000a462:	87 1c       	st.w	r3[0x4],r12
8000a464:	18 08       	add	r8,r12
8000a466:	cb 98       	rjmp	8000a5d8 <_vfprintf_r+0x1c90>
8000a468:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a46c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a470:	40 6b       	lddsp	r11,sp[0x18]
8000a472:	16 3a       	cp.w	r10,r11
8000a474:	c6 f5       	brlt	8000a552 <_vfprintf_r+0x1c0a>
8000a476:	16 09       	add	r9,r11
8000a478:	2f f8       	sub	r8,-1
8000a47a:	87 06       	st.w	r3[0x0],r6
8000a47c:	fb 49 06 90 	st.w	sp[1680],r9
8000a480:	87 1b       	st.w	r3[0x4],r11
8000a482:	fb 48 06 8c 	st.w	sp[1676],r8
8000a486:	58 78       	cp.w	r8,7
8000a488:	e0 89 00 04 	brgt	8000a490 <_vfprintf_r+0x1b48>
8000a48c:	2f 83       	sub	r3,-8
8000a48e:	c0 b8       	rjmp	8000a4a4 <_vfprintf_r+0x1b5c>
8000a490:	fa ca f9 78 	sub	r10,sp,-1672
8000a494:	02 9b       	mov	r11,r1
8000a496:	08 9c       	mov	r12,r4
8000a498:	fe b0 f2 4a 	rcall	8000892c <__sprint_r>
8000a49c:	e0 81 01 d5 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a4a0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4a4:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000a4a8:	40 6a       	lddsp	r10,sp[0x18]
8000a4aa:	14 16       	sub	r6,r10
8000a4ac:	58 06       	cp.w	r6,0
8000a4ae:	e0 89 00 1c 	brgt	8000a4e6 <_vfprintf_r+0x1b9e>
8000a4b2:	c3 d8       	rjmp	8000a52c <_vfprintf_r+0x1be4>
8000a4b4:	2f 09       	sub	r9,-16
8000a4b6:	2f f8       	sub	r8,-1
8000a4b8:	fb 49 06 90 	st.w	sp[1680],r9
8000a4bc:	87 02       	st.w	r3[0x0],r2
8000a4be:	87 10       	st.w	r3[0x4],r0
8000a4c0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4c4:	58 78       	cp.w	r8,7
8000a4c6:	e0 89 00 04 	brgt	8000a4ce <_vfprintf_r+0x1b86>
8000a4ca:	2f 83       	sub	r3,-8
8000a4cc:	c0 b8       	rjmp	8000a4e2 <_vfprintf_r+0x1b9a>
8000a4ce:	fa ca f9 78 	sub	r10,sp,-1672
8000a4d2:	02 9b       	mov	r11,r1
8000a4d4:	08 9c       	mov	r12,r4
8000a4d6:	fe b0 f2 2b 	rcall	8000892c <__sprint_r>
8000a4da:	e0 81 01 b6 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a4de:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4e2:	21 06       	sub	r6,16
8000a4e4:	c0 48       	rjmp	8000a4ec <_vfprintf_r+0x1ba4>
8000a4e6:	fe c2 ba ee 	sub	r2,pc,-17682
8000a4ea:	31 00       	mov	r0,16
8000a4ec:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a4f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a4f4:	fe ca ba fc 	sub	r10,pc,-17668
8000a4f8:	59 06       	cp.w	r6,16
8000a4fa:	fe 99 ff dd 	brgt	8000a4b4 <_vfprintf_r+0x1b6c>
8000a4fe:	0c 09       	add	r9,r6
8000a500:	2f f8       	sub	r8,-1
8000a502:	87 0a       	st.w	r3[0x0],r10
8000a504:	fb 49 06 90 	st.w	sp[1680],r9
8000a508:	87 16       	st.w	r3[0x4],r6
8000a50a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a50e:	58 78       	cp.w	r8,7
8000a510:	e0 89 00 04 	brgt	8000a518 <_vfprintf_r+0x1bd0>
8000a514:	2f 83       	sub	r3,-8
8000a516:	c0 b8       	rjmp	8000a52c <_vfprintf_r+0x1be4>
8000a518:	fa ca f9 78 	sub	r10,sp,-1672
8000a51c:	02 9b       	mov	r11,r1
8000a51e:	08 9c       	mov	r12,r4
8000a520:	fe b0 f2 06 	rcall	8000892c <__sprint_r>
8000a524:	e0 81 01 91 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a528:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a52c:	ed b5 00 00 	bld	r5,0x0
8000a530:	e0 81 01 20 	brne	8000a770 <_vfprintf_r+0x1e28>
8000a534:	40 c9       	lddsp	r9,sp[0x30]
8000a536:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a53a:	2f f8       	sub	r8,-1
8000a53c:	87 09       	st.w	r3[0x0],r9
8000a53e:	fb 48 06 90 	st.w	sp[1680],r8
8000a542:	30 19       	mov	r9,1
8000a544:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a548:	87 19       	st.w	r3[0x4],r9
8000a54a:	2f f8       	sub	r8,-1
8000a54c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a550:	c0 29       	rjmp	8000a754 <_vfprintf_r+0x1e0c>
8000a552:	14 09       	add	r9,r10
8000a554:	2f f8       	sub	r8,-1
8000a556:	fb 49 06 90 	st.w	sp[1680],r9
8000a55a:	87 06       	st.w	r3[0x0],r6
8000a55c:	87 1a       	st.w	r3[0x4],r10
8000a55e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a562:	58 78       	cp.w	r8,7
8000a564:	e0 89 00 04 	brgt	8000a56c <_vfprintf_r+0x1c24>
8000a568:	2f 83       	sub	r3,-8
8000a56a:	c0 b8       	rjmp	8000a580 <_vfprintf_r+0x1c38>
8000a56c:	fa ca f9 78 	sub	r10,sp,-1672
8000a570:	02 9b       	mov	r11,r1
8000a572:	08 9c       	mov	r12,r4
8000a574:	fe b0 f1 dc 	rcall	8000892c <__sprint_r>
8000a578:	e0 81 01 67 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a57c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a580:	40 c8       	lddsp	r8,sp[0x30]
8000a582:	87 08       	st.w	r3[0x0],r8
8000a584:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a588:	2f f8       	sub	r8,-1
8000a58a:	30 19       	mov	r9,1
8000a58c:	fb 48 06 90 	st.w	sp[1680],r8
8000a590:	87 19       	st.w	r3[0x4],r9
8000a592:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a596:	2f f8       	sub	r8,-1
8000a598:	fb 48 06 8c 	st.w	sp[1676],r8
8000a59c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a5a0:	58 78       	cp.w	r8,7
8000a5a2:	e0 89 00 04 	brgt	8000a5aa <_vfprintf_r+0x1c62>
8000a5a6:	2f 83       	sub	r3,-8
8000a5a8:	c0 b8       	rjmp	8000a5be <_vfprintf_r+0x1c76>
8000a5aa:	fa ca f9 78 	sub	r10,sp,-1672
8000a5ae:	02 9b       	mov	r11,r1
8000a5b0:	08 9c       	mov	r12,r4
8000a5b2:	fe b0 f1 bd 	rcall	8000892c <__sprint_r>
8000a5b6:	e0 81 01 48 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a5ba:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a5be:	04 06       	add	r6,r2
8000a5c0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a5c4:	87 06       	st.w	r3[0x0],r6
8000a5c6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a5ca:	40 66       	lddsp	r6,sp[0x18]
8000a5cc:	40 6e       	lddsp	lr,sp[0x18]
8000a5ce:	10 16       	sub	r6,r8
8000a5d0:	f2 08 01 08 	sub	r8,r9,r8
8000a5d4:	87 16       	st.w	r3[0x4],r6
8000a5d6:	1c 08       	add	r8,lr
8000a5d8:	fb 48 06 90 	st.w	sp[1680],r8
8000a5dc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5e0:	2f f8       	sub	r8,-1
8000a5e2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5e6:	cb 78       	rjmp	8000a754 <_vfprintf_r+0x1e0c>
8000a5e8:	40 6c       	lddsp	r12,sp[0x18]
8000a5ea:	58 1c       	cp.w	r12,1
8000a5ec:	e0 89 00 06 	brgt	8000a5f8 <_vfprintf_r+0x1cb0>
8000a5f0:	ed b5 00 00 	bld	r5,0x0
8000a5f4:	e0 81 00 85 	brne	8000a6fe <_vfprintf_r+0x1db6>
8000a5f8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a5fc:	2f f8       	sub	r8,-1
8000a5fe:	30 19       	mov	r9,1
8000a600:	fb 48 06 90 	st.w	sp[1680],r8
8000a604:	87 06       	st.w	r3[0x0],r6
8000a606:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a60a:	87 19       	st.w	r3[0x4],r9
8000a60c:	2f f8       	sub	r8,-1
8000a60e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a612:	58 78       	cp.w	r8,7
8000a614:	e0 89 00 04 	brgt	8000a61c <_vfprintf_r+0x1cd4>
8000a618:	2f 83       	sub	r3,-8
8000a61a:	c0 b8       	rjmp	8000a630 <_vfprintf_r+0x1ce8>
8000a61c:	fa ca f9 78 	sub	r10,sp,-1672
8000a620:	02 9b       	mov	r11,r1
8000a622:	08 9c       	mov	r12,r4
8000a624:	fe b0 f1 84 	rcall	8000892c <__sprint_r>
8000a628:	e0 81 01 0f 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a62c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a630:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a634:	2f f8       	sub	r8,-1
8000a636:	40 cb       	lddsp	r11,sp[0x30]
8000a638:	fb 48 06 90 	st.w	sp[1680],r8
8000a63c:	30 19       	mov	r9,1
8000a63e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a642:	87 0b       	st.w	r3[0x0],r11
8000a644:	2f f8       	sub	r8,-1
8000a646:	87 19       	st.w	r3[0x4],r9
8000a648:	fb 48 06 8c 	st.w	sp[1676],r8
8000a64c:	58 78       	cp.w	r8,7
8000a64e:	e0 89 00 05 	brgt	8000a658 <_vfprintf_r+0x1d10>
8000a652:	2f 83       	sub	r3,-8
8000a654:	c0 c8       	rjmp	8000a66c <_vfprintf_r+0x1d24>
8000a656:	d7 03       	nop
8000a658:	fa ca f9 78 	sub	r10,sp,-1672
8000a65c:	02 9b       	mov	r11,r1
8000a65e:	08 9c       	mov	r12,r4
8000a660:	fe b0 f1 66 	rcall	8000892c <__sprint_r>
8000a664:	e0 81 00 f1 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a668:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a66c:	30 08       	mov	r8,0
8000a66e:	30 09       	mov	r9,0
8000a670:	40 5b       	lddsp	r11,sp[0x14]
8000a672:	40 7a       	lddsp	r10,sp[0x1c]
8000a674:	e0 a0 13 25 	rcall	8000ccbe <__avr32_f64_cmp_eq>
8000a678:	40 68       	lddsp	r8,sp[0x18]
8000a67a:	20 18       	sub	r8,1
8000a67c:	58 0c       	cp.w	r12,0
8000a67e:	c0 d1       	brne	8000a698 <_vfprintf_r+0x1d50>
8000a680:	2f f6       	sub	r6,-1
8000a682:	87 18       	st.w	r3[0x4],r8
8000a684:	87 06       	st.w	r3[0x0],r6
8000a686:	fa f6 06 90 	ld.w	r6,sp[1680]
8000a68a:	10 06       	add	r6,r8
8000a68c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a690:	fb 46 06 90 	st.w	sp[1680],r6
8000a694:	2f f8       	sub	r8,-1
8000a696:	c3 18       	rjmp	8000a6f8 <_vfprintf_r+0x1db0>
8000a698:	10 96       	mov	r6,r8
8000a69a:	58 08       	cp.w	r8,0
8000a69c:	e0 89 00 1c 	brgt	8000a6d4 <_vfprintf_r+0x1d8c>
8000a6a0:	c4 b8       	rjmp	8000a736 <_vfprintf_r+0x1dee>
8000a6a2:	2f 09       	sub	r9,-16
8000a6a4:	2f f8       	sub	r8,-1
8000a6a6:	fb 49 06 90 	st.w	sp[1680],r9
8000a6aa:	87 02       	st.w	r3[0x0],r2
8000a6ac:	87 10       	st.w	r3[0x4],r0
8000a6ae:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6b2:	58 78       	cp.w	r8,7
8000a6b4:	e0 89 00 04 	brgt	8000a6bc <_vfprintf_r+0x1d74>
8000a6b8:	2f 83       	sub	r3,-8
8000a6ba:	c0 b8       	rjmp	8000a6d0 <_vfprintf_r+0x1d88>
8000a6bc:	fa ca f9 78 	sub	r10,sp,-1672
8000a6c0:	02 9b       	mov	r11,r1
8000a6c2:	08 9c       	mov	r12,r4
8000a6c4:	fe b0 f1 34 	rcall	8000892c <__sprint_r>
8000a6c8:	e0 81 00 bf 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a6cc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a6d0:	21 06       	sub	r6,16
8000a6d2:	c0 48       	rjmp	8000a6da <_vfprintf_r+0x1d92>
8000a6d4:	fe c2 bc dc 	sub	r2,pc,-17188
8000a6d8:	31 00       	mov	r0,16
8000a6da:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a6de:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6e2:	fe ca bc ea 	sub	r10,pc,-17174
8000a6e6:	59 06       	cp.w	r6,16
8000a6e8:	fe 99 ff dd 	brgt	8000a6a2 <_vfprintf_r+0x1d5a>
8000a6ec:	0c 09       	add	r9,r6
8000a6ee:	87 0a       	st.w	r3[0x0],r10
8000a6f0:	fb 49 06 90 	st.w	sp[1680],r9
8000a6f4:	2f f8       	sub	r8,-1
8000a6f6:	87 16       	st.w	r3[0x4],r6
8000a6f8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6fc:	c0 e8       	rjmp	8000a718 <_vfprintf_r+0x1dd0>
8000a6fe:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a702:	2f f8       	sub	r8,-1
8000a704:	30 19       	mov	r9,1
8000a706:	fb 48 06 90 	st.w	sp[1680],r8
8000a70a:	87 06       	st.w	r3[0x0],r6
8000a70c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a710:	87 19       	st.w	r3[0x4],r9
8000a712:	2f f8       	sub	r8,-1
8000a714:	fb 48 06 8c 	st.w	sp[1676],r8
8000a718:	58 78       	cp.w	r8,7
8000a71a:	e0 89 00 04 	brgt	8000a722 <_vfprintf_r+0x1dda>
8000a71e:	2f 83       	sub	r3,-8
8000a720:	c0 b8       	rjmp	8000a736 <_vfprintf_r+0x1dee>
8000a722:	fa ca f9 78 	sub	r10,sp,-1672
8000a726:	02 9b       	mov	r11,r1
8000a728:	08 9c       	mov	r12,r4
8000a72a:	fe b0 f1 01 	rcall	8000892c <__sprint_r>
8000a72e:	e0 81 00 8c 	brne	8000a846 <_vfprintf_r+0x1efe>
8000a732:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a736:	40 ea       	lddsp	r10,sp[0x38]
8000a738:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a73c:	14 08       	add	r8,r10
8000a73e:	fa c9 f9 64 	sub	r9,sp,-1692
8000a742:	fb 48 06 90 	st.w	sp[1680],r8
8000a746:	87 1a       	st.w	r3[0x4],r10
8000a748:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a74c:	87 09       	st.w	r3[0x0],r9
8000a74e:	2f f8       	sub	r8,-1
8000a750:	fb 48 06 8c 	st.w	sp[1676],r8
8000a754:	58 78       	cp.w	r8,7
8000a756:	e0 89 00 04 	brgt	8000a75e <_vfprintf_r+0x1e16>
8000a75a:	2f 83       	sub	r3,-8
8000a75c:	c0 a8       	rjmp	8000a770 <_vfprintf_r+0x1e28>
8000a75e:	fa ca f9 78 	sub	r10,sp,-1672
8000a762:	02 9b       	mov	r11,r1
8000a764:	08 9c       	mov	r12,r4
8000a766:	fe b0 f0 e3 	rcall	8000892c <__sprint_r>
8000a76a:	c6 e1       	brne	8000a846 <_vfprintf_r+0x1efe>
8000a76c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a770:	e2 15 00 04 	andl	r5,0x4,COH
8000a774:	c3 f0       	breq	8000a7f2 <_vfprintf_r+0x1eaa>
8000a776:	40 86       	lddsp	r6,sp[0x20]
8000a778:	40 39       	lddsp	r9,sp[0xc]
8000a77a:	12 16       	sub	r6,r9
8000a77c:	58 06       	cp.w	r6,0
8000a77e:	e0 89 00 1a 	brgt	8000a7b2 <_vfprintf_r+0x1e6a>
8000a782:	c3 88       	rjmp	8000a7f2 <_vfprintf_r+0x1eaa>
8000a784:	2f 09       	sub	r9,-16
8000a786:	2f f8       	sub	r8,-1
8000a788:	fb 49 06 90 	st.w	sp[1680],r9
8000a78c:	87 05       	st.w	r3[0x0],r5
8000a78e:	87 12       	st.w	r3[0x4],r2
8000a790:	fb 48 06 8c 	st.w	sp[1676],r8
8000a794:	58 78       	cp.w	r8,7
8000a796:	e0 89 00 04 	brgt	8000a79e <_vfprintf_r+0x1e56>
8000a79a:	2f 83       	sub	r3,-8
8000a79c:	c0 98       	rjmp	8000a7ae <_vfprintf_r+0x1e66>
8000a79e:	00 9a       	mov	r10,r0
8000a7a0:	02 9b       	mov	r11,r1
8000a7a2:	08 9c       	mov	r12,r4
8000a7a4:	fe b0 f0 c4 	rcall	8000892c <__sprint_r>
8000a7a8:	c4 f1       	brne	8000a846 <_vfprintf_r+0x1efe>
8000a7aa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7ae:	21 06       	sub	r6,16
8000a7b0:	c0 68       	rjmp	8000a7bc <_vfprintf_r+0x1e74>
8000a7b2:	fe c5 bd ca 	sub	r5,pc,-16950
8000a7b6:	31 02       	mov	r2,16
8000a7b8:	fa c0 f9 78 	sub	r0,sp,-1672
8000a7bc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a7c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7c4:	fe ca bd dc 	sub	r10,pc,-16932
8000a7c8:	59 06       	cp.w	r6,16
8000a7ca:	fe 99 ff dd 	brgt	8000a784 <_vfprintf_r+0x1e3c>
8000a7ce:	0c 09       	add	r9,r6
8000a7d0:	2f f8       	sub	r8,-1
8000a7d2:	87 0a       	st.w	r3[0x0],r10
8000a7d4:	87 16       	st.w	r3[0x4],r6
8000a7d6:	fb 49 06 90 	st.w	sp[1680],r9
8000a7da:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7de:	58 78       	cp.w	r8,7
8000a7e0:	e0 8a 00 09 	brle	8000a7f2 <_vfprintf_r+0x1eaa>
8000a7e4:	fa ca f9 78 	sub	r10,sp,-1672
8000a7e8:	02 9b       	mov	r11,r1
8000a7ea:	08 9c       	mov	r12,r4
8000a7ec:	fe b0 f0 a0 	rcall	8000892c <__sprint_r>
8000a7f0:	c2 b1       	brne	8000a846 <_vfprintf_r+0x1efe>
8000a7f2:	40 bc       	lddsp	r12,sp[0x2c]
8000a7f4:	40 36       	lddsp	r6,sp[0xc]
8000a7f6:	40 8e       	lddsp	lr,sp[0x20]
8000a7f8:	ec 0e 0c 48 	max	r8,r6,lr
8000a7fc:	10 0c       	add	r12,r8
8000a7fe:	50 bc       	stdsp	sp[0x2c],r12
8000a800:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a804:	58 08       	cp.w	r8,0
8000a806:	c0 80       	breq	8000a816 <_vfprintf_r+0x1ece>
8000a808:	fa ca f9 78 	sub	r10,sp,-1672
8000a80c:	02 9b       	mov	r11,r1
8000a80e:	08 9c       	mov	r12,r4
8000a810:	fe b0 f0 8e 	rcall	8000892c <__sprint_r>
8000a814:	c1 91       	brne	8000a846 <_vfprintf_r+0x1efe>
8000a816:	30 0b       	mov	r11,0
8000a818:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a81c:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a820:	fe 9f f1 22 	bral	80008a64 <_vfprintf_r+0x11c>
8000a824:	08 95       	mov	r5,r4
8000a826:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a82a:	58 08       	cp.w	r8,0
8000a82c:	c0 80       	breq	8000a83c <_vfprintf_r+0x1ef4>
8000a82e:	08 9c       	mov	r12,r4
8000a830:	fa ca f9 78 	sub	r10,sp,-1672
8000a834:	02 9b       	mov	r11,r1
8000a836:	fe b0 f0 7b 	rcall	8000892c <__sprint_r>
8000a83a:	c0 61       	brne	8000a846 <_vfprintf_r+0x1efe>
8000a83c:	30 08       	mov	r8,0
8000a83e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a842:	c0 28       	rjmp	8000a846 <_vfprintf_r+0x1efe>
8000a844:	40 41       	lddsp	r1,sp[0x10]
8000a846:	82 68       	ld.sh	r8,r1[0xc]
8000a848:	ed b8 00 06 	bld	r8,0x6
8000a84c:	c0 31       	brne	8000a852 <_vfprintf_r+0x1f0a>
8000a84e:	3f fa       	mov	r10,-1
8000a850:	50 ba       	stdsp	sp[0x2c],r10
8000a852:	40 bc       	lddsp	r12,sp[0x2c]
8000a854:	fe 3d f9 44 	sub	sp,-1724
8000a858:	d8 32       	popm	r0-r7,pc
8000a85a:	d7 03       	nop

8000a85c <__swsetup_r>:
8000a85c:	d4 21       	pushm	r4-r7,lr
8000a85e:	e0 68 0a 44 	mov	r8,2628
8000a862:	18 96       	mov	r6,r12
8000a864:	16 97       	mov	r7,r11
8000a866:	70 0c       	ld.w	r12,r8[0x0]
8000a868:	58 0c       	cp.w	r12,0
8000a86a:	c0 60       	breq	8000a876 <__swsetup_r+0x1a>
8000a86c:	78 68       	ld.w	r8,r12[0x18]
8000a86e:	58 08       	cp.w	r8,0
8000a870:	c0 31       	brne	8000a876 <__swsetup_r+0x1a>
8000a872:	e0 a0 07 bf 	rcall	8000b7f0 <__sinit>
8000a876:	fe c8 bd 5e 	sub	r8,pc,-17058
8000a87a:	10 37       	cp.w	r7,r8
8000a87c:	c0 61       	brne	8000a888 <__swsetup_r+0x2c>
8000a87e:	e0 68 0a 44 	mov	r8,2628
8000a882:	70 08       	ld.w	r8,r8[0x0]
8000a884:	70 07       	ld.w	r7,r8[0x0]
8000a886:	c1 28       	rjmp	8000a8aa <__swsetup_r+0x4e>
8000a888:	fe c8 bd 50 	sub	r8,pc,-17072
8000a88c:	10 37       	cp.w	r7,r8
8000a88e:	c0 61       	brne	8000a89a <__swsetup_r+0x3e>
8000a890:	e0 68 0a 44 	mov	r8,2628
8000a894:	70 08       	ld.w	r8,r8[0x0]
8000a896:	70 17       	ld.w	r7,r8[0x4]
8000a898:	c0 98       	rjmp	8000a8aa <__swsetup_r+0x4e>
8000a89a:	fe c8 bd 42 	sub	r8,pc,-17086
8000a89e:	10 37       	cp.w	r7,r8
8000a8a0:	c0 51       	brne	8000a8aa <__swsetup_r+0x4e>
8000a8a2:	e0 68 0a 44 	mov	r8,2628
8000a8a6:	70 08       	ld.w	r8,r8[0x0]
8000a8a8:	70 27       	ld.w	r7,r8[0x8]
8000a8aa:	8e 68       	ld.sh	r8,r7[0xc]
8000a8ac:	ed b8 00 03 	bld	r8,0x3
8000a8b0:	c1 e0       	breq	8000a8ec <__swsetup_r+0x90>
8000a8b2:	ed b8 00 04 	bld	r8,0x4
8000a8b6:	c3 e1       	brne	8000a932 <__swsetup_r+0xd6>
8000a8b8:	ed b8 00 02 	bld	r8,0x2
8000a8bc:	c1 51       	brne	8000a8e6 <__swsetup_r+0x8a>
8000a8be:	6e db       	ld.w	r11,r7[0x34]
8000a8c0:	58 0b       	cp.w	r11,0
8000a8c2:	c0 a0       	breq	8000a8d6 <__swsetup_r+0x7a>
8000a8c4:	ee c8 ff bc 	sub	r8,r7,-68
8000a8c8:	10 3b       	cp.w	r11,r8
8000a8ca:	c0 40       	breq	8000a8d2 <__swsetup_r+0x76>
8000a8cc:	0c 9c       	mov	r12,r6
8000a8ce:	e0 a0 08 2b 	rcall	8000b924 <_free_r>
8000a8d2:	30 08       	mov	r8,0
8000a8d4:	8f d8       	st.w	r7[0x34],r8
8000a8d6:	8e 68       	ld.sh	r8,r7[0xc]
8000a8d8:	e0 18 ff db 	andl	r8,0xffdb
8000a8dc:	ae 68       	st.h	r7[0xc],r8
8000a8de:	30 08       	mov	r8,0
8000a8e0:	8f 18       	st.w	r7[0x4],r8
8000a8e2:	6e 48       	ld.w	r8,r7[0x10]
8000a8e4:	8f 08       	st.w	r7[0x0],r8
8000a8e6:	8e 68       	ld.sh	r8,r7[0xc]
8000a8e8:	a3 b8       	sbr	r8,0x3
8000a8ea:	ae 68       	st.h	r7[0xc],r8
8000a8ec:	6e 48       	ld.w	r8,r7[0x10]
8000a8ee:	58 08       	cp.w	r8,0
8000a8f0:	c0 b1       	brne	8000a906 <__swsetup_r+0xaa>
8000a8f2:	8e 68       	ld.sh	r8,r7[0xc]
8000a8f4:	e2 18 02 80 	andl	r8,0x280,COH
8000a8f8:	e0 48 02 00 	cp.w	r8,512
8000a8fc:	c0 50       	breq	8000a906 <__swsetup_r+0xaa>
8000a8fe:	0c 9c       	mov	r12,r6
8000a900:	0e 9b       	mov	r11,r7
8000a902:	e0 a0 0a 4b 	rcall	8000bd98 <__smakebuf_r>
8000a906:	8e 69       	ld.sh	r9,r7[0xc]
8000a908:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a90c:	c0 70       	breq	8000a91a <__swsetup_r+0xbe>
8000a90e:	30 08       	mov	r8,0
8000a910:	8f 28       	st.w	r7[0x8],r8
8000a912:	6e 58       	ld.w	r8,r7[0x14]
8000a914:	5c 38       	neg	r8
8000a916:	8f 68       	st.w	r7[0x18],r8
8000a918:	c0 68       	rjmp	8000a924 <__swsetup_r+0xc8>
8000a91a:	ed b9 00 01 	bld	r9,0x1
8000a91e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a922:	8f 28       	st.w	r7[0x8],r8
8000a924:	6e 48       	ld.w	r8,r7[0x10]
8000a926:	58 08       	cp.w	r8,0
8000a928:	c0 61       	brne	8000a934 <__swsetup_r+0xd8>
8000a92a:	8e 68       	ld.sh	r8,r7[0xc]
8000a92c:	ed b8 00 07 	bld	r8,0x7
8000a930:	c0 21       	brne	8000a934 <__swsetup_r+0xd8>
8000a932:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a934:	d8 2a       	popm	r4-r7,pc,r12=0
8000a936:	d7 03       	nop

8000a938 <quorem>:
8000a938:	d4 31       	pushm	r0-r7,lr
8000a93a:	20 2d       	sub	sp,8
8000a93c:	18 97       	mov	r7,r12
8000a93e:	78 48       	ld.w	r8,r12[0x10]
8000a940:	76 46       	ld.w	r6,r11[0x10]
8000a942:	0c 38       	cp.w	r8,r6
8000a944:	c0 34       	brge	8000a94a <quorem+0x12>
8000a946:	30 0c       	mov	r12,0
8000a948:	c8 58       	rjmp	8000aa52 <quorem+0x11a>
8000a94a:	ec c2 ff fc 	sub	r2,r6,-4
8000a94e:	f6 c3 ff ec 	sub	r3,r11,-20
8000a952:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a956:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a95a:	2f f9       	sub	r9,-1
8000a95c:	20 16       	sub	r6,1
8000a95e:	f8 09 0d 08 	divu	r8,r12,r9
8000a962:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a966:	ee c4 ff ec 	sub	r4,r7,-20
8000a96a:	10 95       	mov	r5,r8
8000a96c:	58 08       	cp.w	r8,0
8000a96e:	c4 10       	breq	8000a9f0 <quorem+0xb8>
8000a970:	30 09       	mov	r9,0
8000a972:	06 9a       	mov	r10,r3
8000a974:	08 98       	mov	r8,r4
8000a976:	12 91       	mov	r1,r9
8000a978:	50 0b       	stdsp	sp[0x0],r11
8000a97a:	70 0e       	ld.w	lr,r8[0x0]
8000a97c:	b1 8e       	lsr	lr,0x10
8000a97e:	50 1e       	stdsp	sp[0x4],lr
8000a980:	15 0e       	ld.w	lr,r10++
8000a982:	fc 00 16 10 	lsr	r0,lr,0x10
8000a986:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a98a:	ea 0e 03 41 	mac	r1,r5,lr
8000a98e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a992:	b1 81       	lsr	r1,0x10
8000a994:	40 1b       	lddsp	r11,sp[0x4]
8000a996:	ea 00 02 40 	mul	r0,r5,r0
8000a99a:	e2 00 00 00 	add	r0,r1,r0
8000a99e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a9a2:	02 1b       	sub	r11,r1
8000a9a4:	50 1b       	stdsp	sp[0x4],r11
8000a9a6:	70 0b       	ld.w	r11,r8[0x0]
8000a9a8:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a9ac:	02 09       	add	r9,r1
8000a9ae:	f2 0e 01 0e 	sub	lr,r9,lr
8000a9b2:	b0 1e       	st.h	r8[0x2],lr
8000a9b4:	fc 09 14 10 	asr	r9,lr,0x10
8000a9b8:	40 1e       	lddsp	lr,sp[0x4]
8000a9ba:	fc 09 00 09 	add	r9,lr,r9
8000a9be:	b0 09       	st.h	r8[0x0],r9
8000a9c0:	e0 01 16 10 	lsr	r1,r0,0x10
8000a9c4:	2f c8       	sub	r8,-4
8000a9c6:	b1 49       	asr	r9,0x10
8000a9c8:	04 3a       	cp.w	r10,r2
8000a9ca:	fe 98 ff d8 	brls	8000a97a <quorem+0x42>
8000a9ce:	40 0b       	lddsp	r11,sp[0x0]
8000a9d0:	58 0c       	cp.w	r12,0
8000a9d2:	c0 f1       	brne	8000a9f0 <quorem+0xb8>
8000a9d4:	ec c8 ff fb 	sub	r8,r6,-5
8000a9d8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a9dc:	c0 28       	rjmp	8000a9e0 <quorem+0xa8>
8000a9de:	20 16       	sub	r6,1
8000a9e0:	20 48       	sub	r8,4
8000a9e2:	08 38       	cp.w	r8,r4
8000a9e4:	e0 88 00 05 	brls	8000a9ee <quorem+0xb6>
8000a9e8:	70 09       	ld.w	r9,r8[0x0]
8000a9ea:	58 09       	cp.w	r9,0
8000a9ec:	cf 90       	breq	8000a9de <quorem+0xa6>
8000a9ee:	8f 46       	st.w	r7[0x10],r6
8000a9f0:	0e 9c       	mov	r12,r7
8000a9f2:	e0 a0 0a d2 	rcall	8000bf96 <__mcmp>
8000a9f6:	c2 d5       	brlt	8000aa50 <quorem+0x118>
8000a9f8:	2f f5       	sub	r5,-1
8000a9fa:	08 98       	mov	r8,r4
8000a9fc:	30 09       	mov	r9,0
8000a9fe:	07 0b       	ld.w	r11,r3++
8000aa00:	f6 0a 16 10 	lsr	r10,r11,0x10
8000aa04:	70 0c       	ld.w	r12,r8[0x0]
8000aa06:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa0a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000aa0e:	14 1e       	sub	lr,r10
8000aa10:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000aa14:	16 1a       	sub	r10,r11
8000aa16:	12 0a       	add	r10,r9
8000aa18:	b0 1a       	st.h	r8[0x2],r10
8000aa1a:	b1 4a       	asr	r10,0x10
8000aa1c:	fc 0a 00 09 	add	r9,lr,r10
8000aa20:	b0 09       	st.h	r8[0x0],r9
8000aa22:	2f c8       	sub	r8,-4
8000aa24:	b1 49       	asr	r9,0x10
8000aa26:	04 33       	cp.w	r3,r2
8000aa28:	fe 98 ff eb 	brls	8000a9fe <quorem+0xc6>
8000aa2c:	ec c8 ff fb 	sub	r8,r6,-5
8000aa30:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000aa34:	58 09       	cp.w	r9,0
8000aa36:	c0 d1       	brne	8000aa50 <quorem+0x118>
8000aa38:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000aa3c:	c0 28       	rjmp	8000aa40 <quorem+0x108>
8000aa3e:	20 16       	sub	r6,1
8000aa40:	20 48       	sub	r8,4
8000aa42:	08 38       	cp.w	r8,r4
8000aa44:	e0 88 00 05 	brls	8000aa4e <quorem+0x116>
8000aa48:	70 09       	ld.w	r9,r8[0x0]
8000aa4a:	58 09       	cp.w	r9,0
8000aa4c:	cf 90       	breq	8000aa3e <quorem+0x106>
8000aa4e:	8f 46       	st.w	r7[0x10],r6
8000aa50:	0a 9c       	mov	r12,r5
8000aa52:	2f ed       	sub	sp,-8
8000aa54:	d8 32       	popm	r0-r7,pc
8000aa56:	d7 03       	nop

8000aa58 <_dtoa_r>:
8000aa58:	d4 31       	pushm	r0-r7,lr
8000aa5a:	21 ad       	sub	sp,104
8000aa5c:	fa c4 ff 74 	sub	r4,sp,-140
8000aa60:	18 97       	mov	r7,r12
8000aa62:	16 95       	mov	r5,r11
8000aa64:	68 2c       	ld.w	r12,r4[0x8]
8000aa66:	50 c9       	stdsp	sp[0x30],r9
8000aa68:	68 16       	ld.w	r6,r4[0x4]
8000aa6a:	68 09       	ld.w	r9,r4[0x0]
8000aa6c:	50 e8       	stdsp	sp[0x38],r8
8000aa6e:	14 94       	mov	r4,r10
8000aa70:	51 2c       	stdsp	sp[0x48],r12
8000aa72:	fa e5 00 08 	st.d	sp[8],r4
8000aa76:	51 59       	stdsp	sp[0x54],r9
8000aa78:	6e 95       	ld.w	r5,r7[0x24]
8000aa7a:	58 05       	cp.w	r5,0
8000aa7c:	c0 91       	brne	8000aa8e <_dtoa_r+0x36>
8000aa7e:	31 0c       	mov	r12,16
8000aa80:	fe b0 e8 f4 	rcall	80007c68 <malloc>
8000aa84:	99 35       	st.w	r12[0xc],r5
8000aa86:	8f 9c       	st.w	r7[0x24],r12
8000aa88:	99 15       	st.w	r12[0x4],r5
8000aa8a:	99 25       	st.w	r12[0x8],r5
8000aa8c:	99 05       	st.w	r12[0x0],r5
8000aa8e:	6e 99       	ld.w	r9,r7[0x24]
8000aa90:	72 08       	ld.w	r8,r9[0x0]
8000aa92:	58 08       	cp.w	r8,0
8000aa94:	c0 f0       	breq	8000aab2 <_dtoa_r+0x5a>
8000aa96:	72 1a       	ld.w	r10,r9[0x4]
8000aa98:	91 1a       	st.w	r8[0x4],r10
8000aa9a:	30 1a       	mov	r10,1
8000aa9c:	72 19       	ld.w	r9,r9[0x4]
8000aa9e:	f4 09 09 49 	lsl	r9,r10,r9
8000aaa2:	10 9b       	mov	r11,r8
8000aaa4:	91 29       	st.w	r8[0x8],r9
8000aaa6:	0e 9c       	mov	r12,r7
8000aaa8:	e0 a0 0a 90 	rcall	8000bfc8 <_Bfree>
8000aaac:	6e 98       	ld.w	r8,r7[0x24]
8000aaae:	30 09       	mov	r9,0
8000aab0:	91 09       	st.w	r8[0x0],r9
8000aab2:	40 28       	lddsp	r8,sp[0x8]
8000aab4:	10 94       	mov	r4,r8
8000aab6:	58 08       	cp.w	r8,0
8000aab8:	c0 64       	brge	8000aac4 <_dtoa_r+0x6c>
8000aaba:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000aabe:	50 28       	stdsp	sp[0x8],r8
8000aac0:	30 18       	mov	r8,1
8000aac2:	c0 28       	rjmp	8000aac6 <_dtoa_r+0x6e>
8000aac4:	30 08       	mov	r8,0
8000aac6:	8d 08       	st.w	r6[0x0],r8
8000aac8:	fc 1c 7f f0 	movh	r12,0x7ff0
8000aacc:	40 26       	lddsp	r6,sp[0x8]
8000aace:	0c 98       	mov	r8,r6
8000aad0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aad4:	18 38       	cp.w	r8,r12
8000aad6:	c2 01       	brne	8000ab16 <_dtoa_r+0xbe>
8000aad8:	e0 68 27 0f 	mov	r8,9999
8000aadc:	41 5b       	lddsp	r11,sp[0x54]
8000aade:	97 08       	st.w	r11[0x0],r8
8000aae0:	40 3a       	lddsp	r10,sp[0xc]
8000aae2:	58 0a       	cp.w	r10,0
8000aae4:	c0 71       	brne	8000aaf2 <_dtoa_r+0x9a>
8000aae6:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000aaea:	c0 41       	brne	8000aaf2 <_dtoa_r+0x9a>
8000aaec:	fe cc bf e4 	sub	r12,pc,-16412
8000aaf0:	c0 38       	rjmp	8000aaf6 <_dtoa_r+0x9e>
8000aaf2:	fe cc bf de 	sub	r12,pc,-16418
8000aaf6:	41 29       	lddsp	r9,sp[0x48]
8000aaf8:	58 09       	cp.w	r9,0
8000aafa:	e0 80 05 9a 	breq	8000b62e <_dtoa_r+0xbd6>
8000aafe:	f8 c8 ff fd 	sub	r8,r12,-3
8000ab02:	f8 c9 ff f8 	sub	r9,r12,-8
8000ab06:	11 8b       	ld.ub	r11,r8[0x0]
8000ab08:	30 0a       	mov	r10,0
8000ab0a:	41 25       	lddsp	r5,sp[0x48]
8000ab0c:	f4 0b 18 00 	cp.b	r11,r10
8000ab10:	f2 08 17 10 	movne	r8,r9
8000ab14:	c1 68       	rjmp	8000ab40 <_dtoa_r+0xe8>
8000ab16:	fa ea 00 08 	ld.d	r10,sp[8]
8000ab1a:	30 08       	mov	r8,0
8000ab1c:	fa eb 00 3c 	st.d	sp[60],r10
8000ab20:	30 09       	mov	r9,0
8000ab22:	e0 a0 10 ce 	rcall	8000ccbe <__avr32_f64_cmp_eq>
8000ab26:	c1 00       	breq	8000ab46 <_dtoa_r+0xee>
8000ab28:	30 18       	mov	r8,1
8000ab2a:	41 5a       	lddsp	r10,sp[0x54]
8000ab2c:	95 08       	st.w	r10[0x0],r8
8000ab2e:	fe cc c1 4a 	sub	r12,pc,-16054
8000ab32:	41 29       	lddsp	r9,sp[0x48]
8000ab34:	f8 08 00 08 	add	r8,r12,r8
8000ab38:	58 09       	cp.w	r9,0
8000ab3a:	e0 80 05 7a 	breq	8000b62e <_dtoa_r+0xbd6>
8000ab3e:	12 95       	mov	r5,r9
8000ab40:	8b 08       	st.w	r5[0x0],r8
8000ab42:	e0 8f 05 76 	bral	8000b62e <_dtoa_r+0xbd6>
8000ab46:	fa c8 ff 9c 	sub	r8,sp,-100
8000ab4a:	fa c9 ff a0 	sub	r9,sp,-96
8000ab4e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ab52:	0e 9c       	mov	r12,r7
8000ab54:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000ab58:	e0 a0 0a 8a 	rcall	8000c06c <__d2b>
8000ab5c:	18 93       	mov	r3,r12
8000ab5e:	58 05       	cp.w	r5,0
8000ab60:	c0 d0       	breq	8000ab7a <_dtoa_r+0x122>
8000ab62:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ab66:	30 04       	mov	r4,0
8000ab68:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000ab6c:	ea c5 03 ff 	sub	r5,r5,1023
8000ab70:	10 9b       	mov	r11,r8
8000ab72:	51 74       	stdsp	sp[0x5c],r4
8000ab74:	ea 1b 3f f0 	orh	r11,0x3ff0
8000ab78:	c2 58       	rjmp	8000abc2 <_dtoa_r+0x16a>
8000ab7a:	41 88       	lddsp	r8,sp[0x60]
8000ab7c:	41 9c       	lddsp	r12,sp[0x64]
8000ab7e:	10 0c       	add	r12,r8
8000ab80:	f8 c5 fb ce 	sub	r5,r12,-1074
8000ab84:	e0 45 00 20 	cp.w	r5,32
8000ab88:	e0 8a 00 0e 	brle	8000aba4 <_dtoa_r+0x14c>
8000ab8c:	f8 cc fb ee 	sub	r12,r12,-1042
8000ab90:	40 3b       	lddsp	r11,sp[0xc]
8000ab92:	ea 08 11 40 	rsub	r8,r5,64
8000ab96:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000ab9a:	ec 08 09 46 	lsl	r6,r6,r8
8000ab9e:	0c 4c       	or	r12,r6
8000aba0:	c0 78       	rjmp	8000abae <_dtoa_r+0x156>
8000aba2:	d7 03       	nop
8000aba4:	ea 0c 11 20 	rsub	r12,r5,32
8000aba8:	40 3a       	lddsp	r10,sp[0xc]
8000abaa:	f4 0c 09 4c 	lsl	r12,r10,r12
8000abae:	e0 a0 10 14 	rcall	8000cbd6 <__avr32_u32_to_f64>
8000abb2:	fc 18 fe 10 	movh	r8,0xfe10
8000abb6:	30 19       	mov	r9,1
8000abb8:	ea c5 04 33 	sub	r5,r5,1075
8000abbc:	f0 0b 00 0b 	add	r11,r8,r11
8000abc0:	51 79       	stdsp	sp[0x5c],r9
8000abc2:	30 08       	mov	r8,0
8000abc4:	fc 19 3f f8 	movh	r9,0x3ff8
8000abc8:	e0 a0 0e 9c 	rcall	8000c900 <__avr32_f64_sub>
8000abcc:	e0 68 43 61 	mov	r8,17249
8000abd0:	ea 18 63 6f 	orh	r8,0x636f
8000abd4:	e0 69 87 a7 	mov	r9,34727
8000abd8:	ea 19 3f d2 	orh	r9,0x3fd2
8000abdc:	e0 a0 0d a6 	rcall	8000c728 <__avr32_f64_mul>
8000abe0:	e0 68 c8 b3 	mov	r8,51379
8000abe4:	ea 18 8b 60 	orh	r8,0x8b60
8000abe8:	e0 69 8a 28 	mov	r9,35368
8000abec:	ea 19 3f c6 	orh	r9,0x3fc6
8000abf0:	e0 a0 0f 56 	rcall	8000ca9c <__avr32_f64_add>
8000abf4:	0a 9c       	mov	r12,r5
8000abf6:	14 90       	mov	r0,r10
8000abf8:	16 91       	mov	r1,r11
8000abfa:	e0 a0 0f f2 	rcall	8000cbde <__avr32_s32_to_f64>
8000abfe:	e0 68 79 fb 	mov	r8,31227
8000ac02:	ea 18 50 9f 	orh	r8,0x509f
8000ac06:	e0 69 44 13 	mov	r9,17427
8000ac0a:	ea 19 3f d3 	orh	r9,0x3fd3
8000ac0e:	e0 a0 0d 8d 	rcall	8000c728 <__avr32_f64_mul>
8000ac12:	14 98       	mov	r8,r10
8000ac14:	16 99       	mov	r9,r11
8000ac16:	00 9a       	mov	r10,r0
8000ac18:	02 9b       	mov	r11,r1
8000ac1a:	e0 a0 0f 41 	rcall	8000ca9c <__avr32_f64_add>
8000ac1e:	14 90       	mov	r0,r10
8000ac20:	16 91       	mov	r1,r11
8000ac22:	e0 a0 0f c7 	rcall	8000cbb0 <__avr32_f64_to_s32>
8000ac26:	30 08       	mov	r8,0
8000ac28:	18 96       	mov	r6,r12
8000ac2a:	30 09       	mov	r9,0
8000ac2c:	00 9a       	mov	r10,r0
8000ac2e:	02 9b       	mov	r11,r1
8000ac30:	e0 a0 10 8e 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000ac34:	c0 c0       	breq	8000ac4c <_dtoa_r+0x1f4>
8000ac36:	0c 9c       	mov	r12,r6
8000ac38:	e0 a0 0f d3 	rcall	8000cbde <__avr32_s32_to_f64>
8000ac3c:	14 98       	mov	r8,r10
8000ac3e:	16 99       	mov	r9,r11
8000ac40:	00 9a       	mov	r10,r0
8000ac42:	02 9b       	mov	r11,r1
8000ac44:	e0 a0 10 3d 	rcall	8000ccbe <__avr32_f64_cmp_eq>
8000ac48:	f7 b6 00 01 	subeq	r6,1
8000ac4c:	59 66       	cp.w	r6,22
8000ac4e:	e0 88 00 05 	brls	8000ac58 <_dtoa_r+0x200>
8000ac52:	30 18       	mov	r8,1
8000ac54:	51 48       	stdsp	sp[0x50],r8
8000ac56:	c1 38       	rjmp	8000ac7c <_dtoa_r+0x224>
8000ac58:	fe c8 c0 90 	sub	r8,pc,-16240
8000ac5c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ac60:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000ac64:	e0 a0 10 74 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000ac68:	f9 b4 00 00 	moveq	r4,0
8000ac6c:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000ac70:	f7 b6 01 01 	subne	r6,1
8000ac74:	f9 bc 01 00 	movne	r12,0
8000ac78:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000ac7c:	41 90       	lddsp	r0,sp[0x64]
8000ac7e:	20 10       	sub	r0,1
8000ac80:	0a 10       	sub	r0,r5
8000ac82:	c0 46       	brmi	8000ac8a <_dtoa_r+0x232>
8000ac84:	50 40       	stdsp	sp[0x10],r0
8000ac86:	30 00       	mov	r0,0
8000ac88:	c0 48       	rjmp	8000ac90 <_dtoa_r+0x238>
8000ac8a:	30 0b       	mov	r11,0
8000ac8c:	5c 30       	neg	r0
8000ac8e:	50 4b       	stdsp	sp[0x10],r11
8000ac90:	ec 02 11 00 	rsub	r2,r6,0
8000ac94:	58 06       	cp.w	r6,0
8000ac96:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000ac9a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000ac9e:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000aca2:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000aca6:	f9 b2 04 00 	movge	r2,0
8000acaa:	e1 d6 e5 10 	sublt	r0,r0,r6
8000acae:	f9 b9 05 00 	movlt	r9,0
8000acb2:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000acb6:	40 c8       	lddsp	r8,sp[0x30]
8000acb8:	58 98       	cp.w	r8,9
8000acba:	e0 8b 00 20 	brhi	8000acfa <_dtoa_r+0x2a2>
8000acbe:	58 58       	cp.w	r8,5
8000acc0:	f9 b4 0a 01 	movle	r4,1
8000acc4:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000acc8:	f7 b5 09 04 	subgt	r5,4
8000accc:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000acd0:	f9 b4 09 00 	movgt	r4,0
8000acd4:	40 cc       	lddsp	r12,sp[0x30]
8000acd6:	58 3c       	cp.w	r12,3
8000acd8:	c2 d0       	breq	8000ad32 <_dtoa_r+0x2da>
8000acda:	e0 89 00 05 	brgt	8000ace4 <_dtoa_r+0x28c>
8000acde:	58 2c       	cp.w	r12,2
8000ace0:	c1 01       	brne	8000ad00 <_dtoa_r+0x2a8>
8000ace2:	c1 88       	rjmp	8000ad12 <_dtoa_r+0x2ba>
8000ace4:	40 cb       	lddsp	r11,sp[0x30]
8000ace6:	58 4b       	cp.w	r11,4
8000ace8:	c0 60       	breq	8000acf4 <_dtoa_r+0x29c>
8000acea:	58 5b       	cp.w	r11,5
8000acec:	c0 a1       	brne	8000ad00 <_dtoa_r+0x2a8>
8000acee:	30 1a       	mov	r10,1
8000acf0:	50 da       	stdsp	sp[0x34],r10
8000acf2:	c2 28       	rjmp	8000ad36 <_dtoa_r+0x2de>
8000acf4:	30 19       	mov	r9,1
8000acf6:	50 d9       	stdsp	sp[0x34],r9
8000acf8:	c0 f8       	rjmp	8000ad16 <_dtoa_r+0x2be>
8000acfa:	30 08       	mov	r8,0
8000acfc:	30 14       	mov	r4,1
8000acfe:	50 c8       	stdsp	sp[0x30],r8
8000ad00:	3f f5       	mov	r5,-1
8000ad02:	30 1c       	mov	r12,1
8000ad04:	30 0b       	mov	r11,0
8000ad06:	50 95       	stdsp	sp[0x24],r5
8000ad08:	50 dc       	stdsp	sp[0x34],r12
8000ad0a:	0a 91       	mov	r1,r5
8000ad0c:	31 28       	mov	r8,18
8000ad0e:	50 eb       	stdsp	sp[0x38],r11
8000ad10:	c2 08       	rjmp	8000ad50 <_dtoa_r+0x2f8>
8000ad12:	30 0a       	mov	r10,0
8000ad14:	50 da       	stdsp	sp[0x34],r10
8000ad16:	40 e9       	lddsp	r9,sp[0x38]
8000ad18:	58 09       	cp.w	r9,0
8000ad1a:	e0 89 00 07 	brgt	8000ad28 <_dtoa_r+0x2d0>
8000ad1e:	30 18       	mov	r8,1
8000ad20:	50 98       	stdsp	sp[0x24],r8
8000ad22:	10 91       	mov	r1,r8
8000ad24:	50 e8       	stdsp	sp[0x38],r8
8000ad26:	c1 58       	rjmp	8000ad50 <_dtoa_r+0x2f8>
8000ad28:	40 e5       	lddsp	r5,sp[0x38]
8000ad2a:	50 95       	stdsp	sp[0x24],r5
8000ad2c:	0a 91       	mov	r1,r5
8000ad2e:	0a 98       	mov	r8,r5
8000ad30:	c1 08       	rjmp	8000ad50 <_dtoa_r+0x2f8>
8000ad32:	30 0c       	mov	r12,0
8000ad34:	50 dc       	stdsp	sp[0x34],r12
8000ad36:	40 eb       	lddsp	r11,sp[0x38]
8000ad38:	ec 0b 00 0b 	add	r11,r6,r11
8000ad3c:	50 9b       	stdsp	sp[0x24],r11
8000ad3e:	16 98       	mov	r8,r11
8000ad40:	2f f8       	sub	r8,-1
8000ad42:	58 08       	cp.w	r8,0
8000ad44:	e0 89 00 05 	brgt	8000ad4e <_dtoa_r+0x2f6>
8000ad48:	10 91       	mov	r1,r8
8000ad4a:	30 18       	mov	r8,1
8000ad4c:	c0 28       	rjmp	8000ad50 <_dtoa_r+0x2f8>
8000ad4e:	10 91       	mov	r1,r8
8000ad50:	30 09       	mov	r9,0
8000ad52:	6e 9a       	ld.w	r10,r7[0x24]
8000ad54:	95 19       	st.w	r10[0x4],r9
8000ad56:	30 49       	mov	r9,4
8000ad58:	c0 68       	rjmp	8000ad64 <_dtoa_r+0x30c>
8000ad5a:	d7 03       	nop
8000ad5c:	6a 1a       	ld.w	r10,r5[0x4]
8000ad5e:	a1 79       	lsl	r9,0x1
8000ad60:	2f fa       	sub	r10,-1
8000ad62:	8b 1a       	st.w	r5[0x4],r10
8000ad64:	6e 95       	ld.w	r5,r7[0x24]
8000ad66:	f2 ca ff ec 	sub	r10,r9,-20
8000ad6a:	10 3a       	cp.w	r10,r8
8000ad6c:	fe 98 ff f8 	brls	8000ad5c <_dtoa_r+0x304>
8000ad70:	6a 1b       	ld.w	r11,r5[0x4]
8000ad72:	0e 9c       	mov	r12,r7
8000ad74:	e0 a0 09 44 	rcall	8000bffc <_Balloc>
8000ad78:	58 e1       	cp.w	r1,14
8000ad7a:	5f 88       	srls	r8
8000ad7c:	8b 0c       	st.w	r5[0x0],r12
8000ad7e:	f1 e4 00 04 	and	r4,r8,r4
8000ad82:	6e 98       	ld.w	r8,r7[0x24]
8000ad84:	70 08       	ld.w	r8,r8[0x0]
8000ad86:	50 88       	stdsp	sp[0x20],r8
8000ad88:	e0 80 01 82 	breq	8000b08c <_dtoa_r+0x634>
8000ad8c:	58 06       	cp.w	r6,0
8000ad8e:	e0 8a 00 43 	brle	8000ae14 <_dtoa_r+0x3bc>
8000ad92:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000ad96:	fe c8 c1 ce 	sub	r8,pc,-15922
8000ad9a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000ad9e:	fa e5 00 18 	st.d	sp[24],r4
8000ada2:	ec 04 14 04 	asr	r4,r6,0x4
8000ada6:	ed b4 00 04 	bld	r4,0x4
8000adaa:	c0 30       	breq	8000adb0 <_dtoa_r+0x358>
8000adac:	30 25       	mov	r5,2
8000adae:	c1 08       	rjmp	8000adce <_dtoa_r+0x376>
8000adb0:	fe c8 c1 20 	sub	r8,pc,-16096
8000adb4:	f0 e8 00 20 	ld.d	r8,r8[32]
8000adb8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000adbc:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000adc0:	e0 a0 0f fa 	rcall	8000cdb4 <__avr32_f64_div>
8000adc4:	30 35       	mov	r5,3
8000adc6:	14 98       	mov	r8,r10
8000adc8:	16 99       	mov	r9,r11
8000adca:	fa e9 00 08 	st.d	sp[8],r8
8000adce:	fe cc c1 3e 	sub	r12,pc,-16066
8000add2:	50 a3       	stdsp	sp[0x28],r3
8000add4:	0c 93       	mov	r3,r6
8000add6:	18 96       	mov	r6,r12
8000add8:	c0 f8       	rjmp	8000adf6 <_dtoa_r+0x39e>
8000adda:	fa ea 00 18 	ld.d	r10,sp[24]
8000adde:	ed b4 00 00 	bld	r4,0x0
8000ade2:	c0 81       	brne	8000adf2 <_dtoa_r+0x39a>
8000ade4:	ec e8 00 00 	ld.d	r8,r6[0]
8000ade8:	2f f5       	sub	r5,-1
8000adea:	e0 a0 0c 9f 	rcall	8000c728 <__avr32_f64_mul>
8000adee:	fa eb 00 18 	st.d	sp[24],r10
8000adf2:	a1 54       	asr	r4,0x1
8000adf4:	2f 86       	sub	r6,-8
8000adf6:	58 04       	cp.w	r4,0
8000adf8:	cf 11       	brne	8000adda <_dtoa_r+0x382>
8000adfa:	fa e8 00 18 	ld.d	r8,sp[24]
8000adfe:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae02:	06 96       	mov	r6,r3
8000ae04:	e0 a0 0f d8 	rcall	8000cdb4 <__avr32_f64_div>
8000ae08:	40 a3       	lddsp	r3,sp[0x28]
8000ae0a:	14 98       	mov	r8,r10
8000ae0c:	16 99       	mov	r9,r11
8000ae0e:	fa e9 00 08 	st.d	sp[8],r8
8000ae12:	c2 f8       	rjmp	8000ae70 <_dtoa_r+0x418>
8000ae14:	ec 08 11 00 	rsub	r8,r6,0
8000ae18:	c0 31       	brne	8000ae1e <_dtoa_r+0x3c6>
8000ae1a:	30 25       	mov	r5,2
8000ae1c:	c2 a8       	rjmp	8000ae70 <_dtoa_r+0x418>
8000ae1e:	fe cc c1 8e 	sub	r12,pc,-15986
8000ae22:	f0 04 14 04 	asr	r4,r8,0x4
8000ae26:	50 1c       	stdsp	sp[0x4],r12
8000ae28:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000ae2c:	fe c9 c2 64 	sub	r9,pc,-15772
8000ae30:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ae34:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000ae38:	e0 a0 0c 78 	rcall	8000c728 <__avr32_f64_mul>
8000ae3c:	40 1c       	lddsp	r12,sp[0x4]
8000ae3e:	50 63       	stdsp	sp[0x18],r3
8000ae40:	30 25       	mov	r5,2
8000ae42:	0c 93       	mov	r3,r6
8000ae44:	fa eb 00 08 	st.d	sp[8],r10
8000ae48:	18 96       	mov	r6,r12
8000ae4a:	c0 f8       	rjmp	8000ae68 <_dtoa_r+0x410>
8000ae4c:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae50:	ed b4 00 00 	bld	r4,0x0
8000ae54:	c0 81       	brne	8000ae64 <_dtoa_r+0x40c>
8000ae56:	ec e8 00 00 	ld.d	r8,r6[0]
8000ae5a:	2f f5       	sub	r5,-1
8000ae5c:	e0 a0 0c 66 	rcall	8000c728 <__avr32_f64_mul>
8000ae60:	fa eb 00 08 	st.d	sp[8],r10
8000ae64:	a1 54       	asr	r4,0x1
8000ae66:	2f 86       	sub	r6,-8
8000ae68:	58 04       	cp.w	r4,0
8000ae6a:	cf 11       	brne	8000ae4c <_dtoa_r+0x3f4>
8000ae6c:	06 96       	mov	r6,r3
8000ae6e:	40 63       	lddsp	r3,sp[0x18]
8000ae70:	41 4a       	lddsp	r10,sp[0x50]
8000ae72:	58 0a       	cp.w	r10,0
8000ae74:	c2 a0       	breq	8000aec8 <_dtoa_r+0x470>
8000ae76:	fa e8 00 08 	ld.d	r8,sp[8]
8000ae7a:	58 01       	cp.w	r1,0
8000ae7c:	5f 94       	srgt	r4
8000ae7e:	fa e9 00 18 	st.d	sp[24],r8
8000ae82:	30 08       	mov	r8,0
8000ae84:	fc 19 3f f0 	movh	r9,0x3ff0
8000ae88:	fa ea 00 18 	ld.d	r10,sp[24]
8000ae8c:	e0 a0 0f 60 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000ae90:	f9 bc 00 00 	moveq	r12,0
8000ae94:	f9 bc 01 01 	movne	r12,1
8000ae98:	e9 ec 00 0c 	and	r12,r4,r12
8000ae9c:	c1 60       	breq	8000aec8 <_dtoa_r+0x470>
8000ae9e:	40 98       	lddsp	r8,sp[0x24]
8000aea0:	58 08       	cp.w	r8,0
8000aea2:	e0 8a 00 f1 	brle	8000b084 <_dtoa_r+0x62c>
8000aea6:	30 08       	mov	r8,0
8000aea8:	fc 19 40 24 	movh	r9,0x4024
8000aeac:	ec c4 00 01 	sub	r4,r6,1
8000aeb0:	fa ea 00 18 	ld.d	r10,sp[24]
8000aeb4:	2f f5       	sub	r5,-1
8000aeb6:	50 64       	stdsp	sp[0x18],r4
8000aeb8:	e0 a0 0c 38 	rcall	8000c728 <__avr32_f64_mul>
8000aebc:	40 94       	lddsp	r4,sp[0x24]
8000aebe:	14 98       	mov	r8,r10
8000aec0:	16 99       	mov	r9,r11
8000aec2:	fa e9 00 08 	st.d	sp[8],r8
8000aec6:	c0 38       	rjmp	8000aecc <_dtoa_r+0x474>
8000aec8:	50 66       	stdsp	sp[0x18],r6
8000aeca:	02 94       	mov	r4,r1
8000aecc:	0a 9c       	mov	r12,r5
8000aece:	e0 a0 0e 88 	rcall	8000cbde <__avr32_s32_to_f64>
8000aed2:	fa e8 00 08 	ld.d	r8,sp[8]
8000aed6:	e0 a0 0c 29 	rcall	8000c728 <__avr32_f64_mul>
8000aeda:	30 08       	mov	r8,0
8000aedc:	fc 19 40 1c 	movh	r9,0x401c
8000aee0:	e0 a0 0d de 	rcall	8000ca9c <__avr32_f64_add>
8000aee4:	14 98       	mov	r8,r10
8000aee6:	16 99       	mov	r9,r11
8000aee8:	fa e9 00 28 	st.d	sp[40],r8
8000aeec:	fc 18 fc c0 	movh	r8,0xfcc0
8000aef0:	40 a5       	lddsp	r5,sp[0x28]
8000aef2:	10 05       	add	r5,r8
8000aef4:	50 a5       	stdsp	sp[0x28],r5
8000aef6:	58 04       	cp.w	r4,0
8000aef8:	c2 11       	brne	8000af3a <_dtoa_r+0x4e2>
8000aefa:	fa ea 00 08 	ld.d	r10,sp[8]
8000aefe:	30 08       	mov	r8,0
8000af00:	fc 19 40 14 	movh	r9,0x4014
8000af04:	e0 a0 0c fe 	rcall	8000c900 <__avr32_f64_sub>
8000af08:	40 bc       	lddsp	r12,sp[0x2c]
8000af0a:	fa eb 00 08 	st.d	sp[8],r10
8000af0e:	14 98       	mov	r8,r10
8000af10:	16 99       	mov	r9,r11
8000af12:	18 9a       	mov	r10,r12
8000af14:	0a 9b       	mov	r11,r5
8000af16:	e0 a0 0f 1b 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000af1a:	e0 81 02 54 	brne	8000b3c2 <_dtoa_r+0x96a>
8000af1e:	0a 98       	mov	r8,r5
8000af20:	40 b9       	lddsp	r9,sp[0x2c]
8000af22:	ee 18 80 00 	eorh	r8,0x8000
8000af26:	fa ea 00 08 	ld.d	r10,sp[8]
8000af2a:	10 95       	mov	r5,r8
8000af2c:	12 98       	mov	r8,r9
8000af2e:	0a 99       	mov	r9,r5
8000af30:	e0 a0 0f 0e 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000af34:	e0 81 02 3e 	brne	8000b3b0 <_dtoa_r+0x958>
8000af38:	ca 68       	rjmp	8000b084 <_dtoa_r+0x62c>
8000af3a:	fe c9 c3 72 	sub	r9,pc,-15502
8000af3e:	e8 c8 00 01 	sub	r8,r4,1
8000af42:	40 d5       	lddsp	r5,sp[0x34]
8000af44:	58 05       	cp.w	r5,0
8000af46:	c4 f0       	breq	8000afe4 <_dtoa_r+0x58c>
8000af48:	30 0c       	mov	r12,0
8000af4a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000af4e:	51 3c       	stdsp	sp[0x4c],r12
8000af50:	30 0a       	mov	r10,0
8000af52:	fc 1b 3f e0 	movh	r11,0x3fe0
8000af56:	e0 a0 0f 2f 	rcall	8000cdb4 <__avr32_f64_div>
8000af5a:	fa e8 00 28 	ld.d	r8,sp[40]
8000af5e:	40 85       	lddsp	r5,sp[0x20]
8000af60:	e0 a0 0c d0 	rcall	8000c900 <__avr32_f64_sub>
8000af64:	fa eb 00 28 	st.d	sp[40],r10
8000af68:	fa ea 00 08 	ld.d	r10,sp[8]
8000af6c:	e0 a0 0e 22 	rcall	8000cbb0 <__avr32_f64_to_s32>
8000af70:	51 6c       	stdsp	sp[0x58],r12
8000af72:	e0 a0 0e 36 	rcall	8000cbde <__avr32_s32_to_f64>
8000af76:	14 98       	mov	r8,r10
8000af78:	16 99       	mov	r9,r11
8000af7a:	fa ea 00 08 	ld.d	r10,sp[8]
8000af7e:	e0 a0 0c c1 	rcall	8000c900 <__avr32_f64_sub>
8000af82:	fa eb 00 08 	st.d	sp[8],r10
8000af86:	41 68       	lddsp	r8,sp[0x58]
8000af88:	2d 08       	sub	r8,-48
8000af8a:	0a c8       	st.b	r5++,r8
8000af8c:	41 39       	lddsp	r9,sp[0x4c]
8000af8e:	2f f9       	sub	r9,-1
8000af90:	51 39       	stdsp	sp[0x4c],r9
8000af92:	fa e8 00 28 	ld.d	r8,sp[40]
8000af96:	e0 a0 0e db 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000af9a:	e0 81 03 39 	brne	8000b60c <_dtoa_r+0xbb4>
8000af9e:	fa e8 00 08 	ld.d	r8,sp[8]
8000afa2:	30 0a       	mov	r10,0
8000afa4:	fc 1b 3f f0 	movh	r11,0x3ff0
8000afa8:	e0 a0 0c ac 	rcall	8000c900 <__avr32_f64_sub>
8000afac:	fa e8 00 28 	ld.d	r8,sp[40]
8000afb0:	e0 a0 0e ce 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000afb4:	fa ea 00 28 	ld.d	r10,sp[40]
8000afb8:	30 08       	mov	r8,0
8000afba:	fc 19 40 24 	movh	r9,0x4024
8000afbe:	e0 81 00 da 	brne	8000b172 <_dtoa_r+0x71a>
8000afc2:	41 3c       	lddsp	r12,sp[0x4c]
8000afc4:	08 3c       	cp.w	r12,r4
8000afc6:	c5 f4       	brge	8000b084 <_dtoa_r+0x62c>
8000afc8:	e0 a0 0b b0 	rcall	8000c728 <__avr32_f64_mul>
8000afcc:	30 08       	mov	r8,0
8000afce:	fa eb 00 28 	st.d	sp[40],r10
8000afd2:	fc 19 40 24 	movh	r9,0x4024
8000afd6:	fa ea 00 08 	ld.d	r10,sp[8]
8000afda:	e0 a0 0b a7 	rcall	8000c728 <__avr32_f64_mul>
8000afde:	fa eb 00 08 	st.d	sp[8],r10
8000afe2:	cc 3b       	rjmp	8000af68 <_dtoa_r+0x510>
8000afe4:	40 85       	lddsp	r5,sp[0x20]
8000afe6:	08 05       	add	r5,r4
8000afe8:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000afec:	51 35       	stdsp	sp[0x4c],r5
8000afee:	fa e8 00 28 	ld.d	r8,sp[40]
8000aff2:	40 85       	lddsp	r5,sp[0x20]
8000aff4:	e0 a0 0b 9a 	rcall	8000c728 <__avr32_f64_mul>
8000aff8:	fa eb 00 28 	st.d	sp[40],r10
8000affc:	fa ea 00 08 	ld.d	r10,sp[8]
8000b000:	e0 a0 0d d8 	rcall	8000cbb0 <__avr32_f64_to_s32>
8000b004:	51 6c       	stdsp	sp[0x58],r12
8000b006:	e0 a0 0d ec 	rcall	8000cbde <__avr32_s32_to_f64>
8000b00a:	14 98       	mov	r8,r10
8000b00c:	16 99       	mov	r9,r11
8000b00e:	fa ea 00 08 	ld.d	r10,sp[8]
8000b012:	e0 a0 0c 77 	rcall	8000c900 <__avr32_f64_sub>
8000b016:	fa eb 00 08 	st.d	sp[8],r10
8000b01a:	41 68       	lddsp	r8,sp[0x58]
8000b01c:	2d 08       	sub	r8,-48
8000b01e:	0a c8       	st.b	r5++,r8
8000b020:	41 3c       	lddsp	r12,sp[0x4c]
8000b022:	18 35       	cp.w	r5,r12
8000b024:	c2 81       	brne	8000b074 <_dtoa_r+0x61c>
8000b026:	30 08       	mov	r8,0
8000b028:	fc 19 3f e0 	movh	r9,0x3fe0
8000b02c:	fa ea 00 28 	ld.d	r10,sp[40]
8000b030:	e0 a0 0d 36 	rcall	8000ca9c <__avr32_f64_add>
8000b034:	40 85       	lddsp	r5,sp[0x20]
8000b036:	fa e8 00 08 	ld.d	r8,sp[8]
8000b03a:	08 05       	add	r5,r4
8000b03c:	e0 a0 0e 88 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000b040:	e0 81 00 99 	brne	8000b172 <_dtoa_r+0x71a>
8000b044:	fa e8 00 28 	ld.d	r8,sp[40]
8000b048:	30 0a       	mov	r10,0
8000b04a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b04e:	e0 a0 0c 59 	rcall	8000c900 <__avr32_f64_sub>
8000b052:	14 98       	mov	r8,r10
8000b054:	16 99       	mov	r9,r11
8000b056:	fa ea 00 08 	ld.d	r10,sp[8]
8000b05a:	e0 a0 0e 79 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000b05e:	c1 30       	breq	8000b084 <_dtoa_r+0x62c>
8000b060:	33 09       	mov	r9,48
8000b062:	0a 98       	mov	r8,r5
8000b064:	11 7a       	ld.ub	r10,--r8
8000b066:	f2 0a 18 00 	cp.b	r10,r9
8000b06a:	e0 81 02 d1 	brne	8000b60c <_dtoa_r+0xbb4>
8000b06e:	10 95       	mov	r5,r8
8000b070:	cf 9b       	rjmp	8000b062 <_dtoa_r+0x60a>
8000b072:	d7 03       	nop
8000b074:	30 08       	mov	r8,0
8000b076:	fc 19 40 24 	movh	r9,0x4024
8000b07a:	e0 a0 0b 57 	rcall	8000c728 <__avr32_f64_mul>
8000b07e:	fa eb 00 08 	st.d	sp[8],r10
8000b082:	cb db       	rjmp	8000affc <_dtoa_r+0x5a4>
8000b084:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b088:	fa eb 00 08 	st.d	sp[8],r10
8000b08c:	58 e6       	cp.w	r6,14
8000b08e:	5f ab       	srle	r11
8000b090:	41 8a       	lddsp	r10,sp[0x60]
8000b092:	30 08       	mov	r8,0
8000b094:	f4 09 11 ff 	rsub	r9,r10,-1
8000b098:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b09c:	f0 09 18 00 	cp.b	r9,r8
8000b0a0:	e0 80 00 82 	breq	8000b1a4 <_dtoa_r+0x74c>
8000b0a4:	40 ea       	lddsp	r10,sp[0x38]
8000b0a6:	58 01       	cp.w	r1,0
8000b0a8:	5f a9       	srle	r9
8000b0aa:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b0ae:	fe ca c4 e6 	sub	r10,pc,-15130
8000b0b2:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b0b6:	fa e5 00 10 	st.d	sp[16],r4
8000b0ba:	f0 09 18 00 	cp.b	r9,r8
8000b0be:	c1 40       	breq	8000b0e6 <_dtoa_r+0x68e>
8000b0c0:	58 01       	cp.w	r1,0
8000b0c2:	e0 81 01 77 	brne	8000b3b0 <_dtoa_r+0x958>
8000b0c6:	30 08       	mov	r8,0
8000b0c8:	fc 19 40 14 	movh	r9,0x4014
8000b0cc:	08 9a       	mov	r10,r4
8000b0ce:	0a 9b       	mov	r11,r5
8000b0d0:	e0 a0 0b 2c 	rcall	8000c728 <__avr32_f64_mul>
8000b0d4:	fa e8 00 08 	ld.d	r8,sp[8]
8000b0d8:	e0 a0 0e 06 	rcall	8000cce4 <__avr32_f64_cmp_ge>
8000b0dc:	e0 81 01 6a 	brne	8000b3b0 <_dtoa_r+0x958>
8000b0e0:	02 92       	mov	r2,r1
8000b0e2:	e0 8f 01 72 	bral	8000b3c6 <_dtoa_r+0x96e>
8000b0e6:	40 85       	lddsp	r5,sp[0x20]
8000b0e8:	30 14       	mov	r4,1
8000b0ea:	fa e8 00 10 	ld.d	r8,sp[16]
8000b0ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000b0f2:	e0 a0 0e 61 	rcall	8000cdb4 <__avr32_f64_div>
8000b0f6:	e0 a0 0d 5d 	rcall	8000cbb0 <__avr32_f64_to_s32>
8000b0fa:	18 92       	mov	r2,r12
8000b0fc:	e0 a0 0d 71 	rcall	8000cbde <__avr32_s32_to_f64>
8000b100:	fa e8 00 10 	ld.d	r8,sp[16]
8000b104:	e0 a0 0b 12 	rcall	8000c728 <__avr32_f64_mul>
8000b108:	14 98       	mov	r8,r10
8000b10a:	16 99       	mov	r9,r11
8000b10c:	fa ea 00 08 	ld.d	r10,sp[8]
8000b110:	e0 a0 0b f8 	rcall	8000c900 <__avr32_f64_sub>
8000b114:	fa eb 00 08 	st.d	sp[8],r10
8000b118:	e4 c8 ff d0 	sub	r8,r2,-48
8000b11c:	0a c8       	st.b	r5++,r8
8000b11e:	fc 19 40 24 	movh	r9,0x4024
8000b122:	30 08       	mov	r8,0
8000b124:	02 34       	cp.w	r4,r1
8000b126:	c3 31       	brne	8000b18c <_dtoa_r+0x734>
8000b128:	fa e8 00 08 	ld.d	r8,sp[8]
8000b12c:	e0 a0 0c b8 	rcall	8000ca9c <__avr32_f64_add>
8000b130:	16 91       	mov	r1,r11
8000b132:	14 90       	mov	r0,r10
8000b134:	14 98       	mov	r8,r10
8000b136:	02 99       	mov	r9,r1
8000b138:	fa ea 00 10 	ld.d	r10,sp[16]
8000b13c:	e0 a0 0e 08 	rcall	8000cd4c <__avr32_f64_cmp_lt>
8000b140:	c1 a1       	brne	8000b174 <_dtoa_r+0x71c>
8000b142:	fa e8 00 10 	ld.d	r8,sp[16]
8000b146:	00 9a       	mov	r10,r0
8000b148:	02 9b       	mov	r11,r1
8000b14a:	e0 a0 0d ba 	rcall	8000ccbe <__avr32_f64_cmp_eq>
8000b14e:	e0 80 02 5e 	breq	8000b60a <_dtoa_r+0xbb2>
8000b152:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b156:	c0 f1       	brne	8000b174 <_dtoa_r+0x71c>
8000b158:	e0 8f 02 59 	bral	8000b60a <_dtoa_r+0xbb2>
8000b15c:	40 8a       	lddsp	r10,sp[0x20]
8000b15e:	14 38       	cp.w	r8,r10
8000b160:	c0 30       	breq	8000b166 <_dtoa_r+0x70e>
8000b162:	10 95       	mov	r5,r8
8000b164:	c0 98       	rjmp	8000b176 <_dtoa_r+0x71e>
8000b166:	33 08       	mov	r8,48
8000b168:	40 89       	lddsp	r9,sp[0x20]
8000b16a:	2f f6       	sub	r6,-1
8000b16c:	b2 88       	st.b	r9[0x0],r8
8000b16e:	40 88       	lddsp	r8,sp[0x20]
8000b170:	c0 88       	rjmp	8000b180 <_dtoa_r+0x728>
8000b172:	40 66       	lddsp	r6,sp[0x18]
8000b174:	33 99       	mov	r9,57
8000b176:	0a 98       	mov	r8,r5
8000b178:	11 7a       	ld.ub	r10,--r8
8000b17a:	f2 0a 18 00 	cp.b	r10,r9
8000b17e:	ce f0       	breq	8000b15c <_dtoa_r+0x704>
8000b180:	50 66       	stdsp	sp[0x18],r6
8000b182:	11 89       	ld.ub	r9,r8[0x0]
8000b184:	2f f9       	sub	r9,-1
8000b186:	b0 89       	st.b	r8[0x0],r9
8000b188:	e0 8f 02 42 	bral	8000b60c <_dtoa_r+0xbb4>
8000b18c:	e0 a0 0a ce 	rcall	8000c728 <__avr32_f64_mul>
8000b190:	2f f4       	sub	r4,-1
8000b192:	fa eb 00 08 	st.d	sp[8],r10
8000b196:	30 08       	mov	r8,0
8000b198:	30 09       	mov	r9,0
8000b19a:	e0 a0 0d 92 	rcall	8000ccbe <__avr32_f64_cmp_eq>
8000b19e:	ca 60       	breq	8000b0ea <_dtoa_r+0x692>
8000b1a0:	e0 8f 02 35 	bral	8000b60a <_dtoa_r+0xbb2>
8000b1a4:	40 d8       	lddsp	r8,sp[0x34]
8000b1a6:	58 08       	cp.w	r8,0
8000b1a8:	c0 51       	brne	8000b1b2 <_dtoa_r+0x75a>
8000b1aa:	04 98       	mov	r8,r2
8000b1ac:	00 95       	mov	r5,r0
8000b1ae:	40 d4       	lddsp	r4,sp[0x34]
8000b1b0:	c3 78       	rjmp	8000b21e <_dtoa_r+0x7c6>
8000b1b2:	40 c5       	lddsp	r5,sp[0x30]
8000b1b4:	58 15       	cp.w	r5,1
8000b1b6:	e0 89 00 0f 	brgt	8000b1d4 <_dtoa_r+0x77c>
8000b1ba:	41 74       	lddsp	r4,sp[0x5c]
8000b1bc:	58 04       	cp.w	r4,0
8000b1be:	c0 40       	breq	8000b1c6 <_dtoa_r+0x76e>
8000b1c0:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b1c4:	c0 48       	rjmp	8000b1cc <_dtoa_r+0x774>
8000b1c6:	41 99       	lddsp	r9,sp[0x64]
8000b1c8:	f2 09 11 36 	rsub	r9,r9,54
8000b1cc:	04 98       	mov	r8,r2
8000b1ce:	00 95       	mov	r5,r0
8000b1d0:	c1 c8       	rjmp	8000b208 <_dtoa_r+0x7b0>
8000b1d2:	d7 03       	nop
8000b1d4:	e2 c8 00 01 	sub	r8,r1,1
8000b1d8:	58 01       	cp.w	r1,0
8000b1da:	e0 05 17 40 	movge	r5,r0
8000b1de:	e2 09 17 40 	movge	r9,r1
8000b1e2:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b1e6:	f9 b9 05 00 	movlt	r9,0
8000b1ea:	10 32       	cp.w	r2,r8
8000b1ec:	e5 d8 e4 18 	subge	r8,r2,r8
8000b1f0:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b1f4:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b1f8:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b1fc:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b200:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b204:	f9 b8 05 00 	movlt	r8,0
8000b208:	40 4b       	lddsp	r11,sp[0x10]
8000b20a:	12 0b       	add	r11,r9
8000b20c:	50 08       	stdsp	sp[0x0],r8
8000b20e:	50 4b       	stdsp	sp[0x10],r11
8000b210:	12 00       	add	r0,r9
8000b212:	30 1b       	mov	r11,1
8000b214:	0e 9c       	mov	r12,r7
8000b216:	e0 a0 08 a7 	rcall	8000c364 <__i2b>
8000b21a:	40 08       	lddsp	r8,sp[0x0]
8000b21c:	18 94       	mov	r4,r12
8000b21e:	40 4a       	lddsp	r10,sp[0x10]
8000b220:	58 05       	cp.w	r5,0
8000b222:	5f 99       	srgt	r9
8000b224:	58 0a       	cp.w	r10,0
8000b226:	5f 9a       	srgt	r10
8000b228:	f5 e9 00 09 	and	r9,r10,r9
8000b22c:	c0 80       	breq	8000b23c <_dtoa_r+0x7e4>
8000b22e:	40 4c       	lddsp	r12,sp[0x10]
8000b230:	f8 05 0d 49 	min	r9,r12,r5
8000b234:	12 1c       	sub	r12,r9
8000b236:	12 10       	sub	r0,r9
8000b238:	50 4c       	stdsp	sp[0x10],r12
8000b23a:	12 15       	sub	r5,r9
8000b23c:	58 02       	cp.w	r2,0
8000b23e:	e0 8a 00 27 	brle	8000b28c <_dtoa_r+0x834>
8000b242:	40 db       	lddsp	r11,sp[0x34]
8000b244:	58 0b       	cp.w	r11,0
8000b246:	c1 d0       	breq	8000b280 <_dtoa_r+0x828>
8000b248:	58 08       	cp.w	r8,0
8000b24a:	e0 8a 00 17 	brle	8000b278 <_dtoa_r+0x820>
8000b24e:	10 9a       	mov	r10,r8
8000b250:	50 08       	stdsp	sp[0x0],r8
8000b252:	08 9b       	mov	r11,r4
8000b254:	0e 9c       	mov	r12,r7
8000b256:	e0 a0 08 cd 	rcall	8000c3f0 <__pow5mult>
8000b25a:	06 9a       	mov	r10,r3
8000b25c:	18 9b       	mov	r11,r12
8000b25e:	18 94       	mov	r4,r12
8000b260:	0e 9c       	mov	r12,r7
8000b262:	e0 a0 08 01 	rcall	8000c264 <__multiply>
8000b266:	18 99       	mov	r9,r12
8000b268:	06 9b       	mov	r11,r3
8000b26a:	50 19       	stdsp	sp[0x4],r9
8000b26c:	0e 9c       	mov	r12,r7
8000b26e:	e0 a0 06 ad 	rcall	8000bfc8 <_Bfree>
8000b272:	40 19       	lddsp	r9,sp[0x4]
8000b274:	40 08       	lddsp	r8,sp[0x0]
8000b276:	12 93       	mov	r3,r9
8000b278:	e4 08 01 0a 	sub	r10,r2,r8
8000b27c:	c0 80       	breq	8000b28c <_dtoa_r+0x834>
8000b27e:	c0 28       	rjmp	8000b282 <_dtoa_r+0x82a>
8000b280:	04 9a       	mov	r10,r2
8000b282:	06 9b       	mov	r11,r3
8000b284:	0e 9c       	mov	r12,r7
8000b286:	e0 a0 08 b5 	rcall	8000c3f0 <__pow5mult>
8000b28a:	18 93       	mov	r3,r12
8000b28c:	30 1b       	mov	r11,1
8000b28e:	0e 9c       	mov	r12,r7
8000b290:	e0 a0 08 6a 	rcall	8000c364 <__i2b>
8000b294:	41 1a       	lddsp	r10,sp[0x44]
8000b296:	18 92       	mov	r2,r12
8000b298:	58 0a       	cp.w	r10,0
8000b29a:	e0 8a 00 07 	brle	8000b2a8 <_dtoa_r+0x850>
8000b29e:	18 9b       	mov	r11,r12
8000b2a0:	0e 9c       	mov	r12,r7
8000b2a2:	e0 a0 08 a7 	rcall	8000c3f0 <__pow5mult>
8000b2a6:	18 92       	mov	r2,r12
8000b2a8:	40 c9       	lddsp	r9,sp[0x30]
8000b2aa:	58 19       	cp.w	r9,1
8000b2ac:	e0 89 00 14 	brgt	8000b2d4 <_dtoa_r+0x87c>
8000b2b0:	40 38       	lddsp	r8,sp[0xc]
8000b2b2:	58 08       	cp.w	r8,0
8000b2b4:	c1 01       	brne	8000b2d4 <_dtoa_r+0x87c>
8000b2b6:	40 29       	lddsp	r9,sp[0x8]
8000b2b8:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b2bc:	c0 c1       	brne	8000b2d4 <_dtoa_r+0x87c>
8000b2be:	12 98       	mov	r8,r9
8000b2c0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b2c4:	c0 80       	breq	8000b2d4 <_dtoa_r+0x87c>
8000b2c6:	40 4c       	lddsp	r12,sp[0x10]
8000b2c8:	30 1b       	mov	r11,1
8000b2ca:	2f fc       	sub	r12,-1
8000b2cc:	2f f0       	sub	r0,-1
8000b2ce:	50 4c       	stdsp	sp[0x10],r12
8000b2d0:	50 6b       	stdsp	sp[0x18],r11
8000b2d2:	c0 38       	rjmp	8000b2d8 <_dtoa_r+0x880>
8000b2d4:	30 0a       	mov	r10,0
8000b2d6:	50 6a       	stdsp	sp[0x18],r10
8000b2d8:	41 19       	lddsp	r9,sp[0x44]
8000b2da:	58 09       	cp.w	r9,0
8000b2dc:	c0 31       	brne	8000b2e2 <_dtoa_r+0x88a>
8000b2de:	30 1c       	mov	r12,1
8000b2e0:	c0 98       	rjmp	8000b2f2 <_dtoa_r+0x89a>
8000b2e2:	64 48       	ld.w	r8,r2[0x10]
8000b2e4:	2f c8       	sub	r8,-4
8000b2e6:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b2ea:	e0 a0 05 df 	rcall	8000bea8 <__hi0bits>
8000b2ee:	f8 0c 11 20 	rsub	r12,r12,32
8000b2f2:	40 4b       	lddsp	r11,sp[0x10]
8000b2f4:	f8 0b 00 08 	add	r8,r12,r11
8000b2f8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b2fc:	c0 c0       	breq	8000b314 <_dtoa_r+0x8bc>
8000b2fe:	f0 08 11 20 	rsub	r8,r8,32
8000b302:	58 48       	cp.w	r8,4
8000b304:	e0 8a 00 06 	brle	8000b310 <_dtoa_r+0x8b8>
8000b308:	20 48       	sub	r8,4
8000b30a:	10 0b       	add	r11,r8
8000b30c:	50 4b       	stdsp	sp[0x10],r11
8000b30e:	c0 78       	rjmp	8000b31c <_dtoa_r+0x8c4>
8000b310:	58 48       	cp.w	r8,4
8000b312:	c0 70       	breq	8000b320 <_dtoa_r+0x8c8>
8000b314:	40 4a       	lddsp	r10,sp[0x10]
8000b316:	2e 48       	sub	r8,-28
8000b318:	10 0a       	add	r10,r8
8000b31a:	50 4a       	stdsp	sp[0x10],r10
8000b31c:	10 00       	add	r0,r8
8000b31e:	10 05       	add	r5,r8
8000b320:	58 00       	cp.w	r0,0
8000b322:	e0 8a 00 08 	brle	8000b332 <_dtoa_r+0x8da>
8000b326:	06 9b       	mov	r11,r3
8000b328:	00 9a       	mov	r10,r0
8000b32a:	0e 9c       	mov	r12,r7
8000b32c:	e0 a0 07 58 	rcall	8000c1dc <__lshift>
8000b330:	18 93       	mov	r3,r12
8000b332:	40 49       	lddsp	r9,sp[0x10]
8000b334:	58 09       	cp.w	r9,0
8000b336:	e0 8a 00 08 	brle	8000b346 <_dtoa_r+0x8ee>
8000b33a:	04 9b       	mov	r11,r2
8000b33c:	12 9a       	mov	r10,r9
8000b33e:	0e 9c       	mov	r12,r7
8000b340:	e0 a0 07 4e 	rcall	8000c1dc <__lshift>
8000b344:	18 92       	mov	r2,r12
8000b346:	41 48       	lddsp	r8,sp[0x50]
8000b348:	58 08       	cp.w	r8,0
8000b34a:	c1 b0       	breq	8000b380 <_dtoa_r+0x928>
8000b34c:	04 9b       	mov	r11,r2
8000b34e:	06 9c       	mov	r12,r3
8000b350:	e0 a0 06 23 	rcall	8000bf96 <__mcmp>
8000b354:	c1 64       	brge	8000b380 <_dtoa_r+0x928>
8000b356:	06 9b       	mov	r11,r3
8000b358:	30 09       	mov	r9,0
8000b35a:	30 aa       	mov	r10,10
8000b35c:	0e 9c       	mov	r12,r7
8000b35e:	e0 a0 08 0b 	rcall	8000c374 <__multadd>
8000b362:	20 16       	sub	r6,1
8000b364:	18 93       	mov	r3,r12
8000b366:	40 dc       	lddsp	r12,sp[0x34]
8000b368:	58 0c       	cp.w	r12,0
8000b36a:	c0 31       	brne	8000b370 <_dtoa_r+0x918>
8000b36c:	40 91       	lddsp	r1,sp[0x24]
8000b36e:	c0 98       	rjmp	8000b380 <_dtoa_r+0x928>
8000b370:	08 9b       	mov	r11,r4
8000b372:	40 91       	lddsp	r1,sp[0x24]
8000b374:	30 09       	mov	r9,0
8000b376:	30 aa       	mov	r10,10
8000b378:	0e 9c       	mov	r12,r7
8000b37a:	e0 a0 07 fd 	rcall	8000c374 <__multadd>
8000b37e:	18 94       	mov	r4,r12
8000b380:	58 01       	cp.w	r1,0
8000b382:	5f a9       	srle	r9
8000b384:	40 cb       	lddsp	r11,sp[0x30]
8000b386:	58 2b       	cp.w	r11,2
8000b388:	5f 98       	srgt	r8
8000b38a:	f3 e8 00 08 	and	r8,r9,r8
8000b38e:	c2 50       	breq	8000b3d8 <_dtoa_r+0x980>
8000b390:	58 01       	cp.w	r1,0
8000b392:	c1 11       	brne	8000b3b4 <_dtoa_r+0x95c>
8000b394:	04 9b       	mov	r11,r2
8000b396:	02 99       	mov	r9,r1
8000b398:	30 5a       	mov	r10,5
8000b39a:	0e 9c       	mov	r12,r7
8000b39c:	e0 a0 07 ec 	rcall	8000c374 <__multadd>
8000b3a0:	18 92       	mov	r2,r12
8000b3a2:	18 9b       	mov	r11,r12
8000b3a4:	06 9c       	mov	r12,r3
8000b3a6:	e0 a0 05 f8 	rcall	8000bf96 <__mcmp>
8000b3aa:	e0 89 00 0f 	brgt	8000b3c8 <_dtoa_r+0x970>
8000b3ae:	c0 38       	rjmp	8000b3b4 <_dtoa_r+0x95c>
8000b3b0:	30 02       	mov	r2,0
8000b3b2:	04 94       	mov	r4,r2
8000b3b4:	40 ea       	lddsp	r10,sp[0x38]
8000b3b6:	30 09       	mov	r9,0
8000b3b8:	5c da       	com	r10
8000b3ba:	40 85       	lddsp	r5,sp[0x20]
8000b3bc:	50 6a       	stdsp	sp[0x18],r10
8000b3be:	50 49       	stdsp	sp[0x10],r9
8000b3c0:	c0 f9       	rjmp	8000b5de <_dtoa_r+0xb86>
8000b3c2:	08 92       	mov	r2,r4
8000b3c4:	40 66       	lddsp	r6,sp[0x18]
8000b3c6:	04 94       	mov	r4,r2
8000b3c8:	2f f6       	sub	r6,-1
8000b3ca:	50 66       	stdsp	sp[0x18],r6
8000b3cc:	33 18       	mov	r8,49
8000b3ce:	40 85       	lddsp	r5,sp[0x20]
8000b3d0:	0a c8       	st.b	r5++,r8
8000b3d2:	30 08       	mov	r8,0
8000b3d4:	50 48       	stdsp	sp[0x10],r8
8000b3d6:	c0 49       	rjmp	8000b5de <_dtoa_r+0xb86>
8000b3d8:	40 dc       	lddsp	r12,sp[0x34]
8000b3da:	58 0c       	cp.w	r12,0
8000b3dc:	e0 80 00 b5 	breq	8000b546 <_dtoa_r+0xaee>
8000b3e0:	58 05       	cp.w	r5,0
8000b3e2:	e0 8a 00 08 	brle	8000b3f2 <_dtoa_r+0x99a>
8000b3e6:	08 9b       	mov	r11,r4
8000b3e8:	0a 9a       	mov	r10,r5
8000b3ea:	0e 9c       	mov	r12,r7
8000b3ec:	e0 a0 06 f8 	rcall	8000c1dc <__lshift>
8000b3f0:	18 94       	mov	r4,r12
8000b3f2:	40 6b       	lddsp	r11,sp[0x18]
8000b3f4:	58 0b       	cp.w	r11,0
8000b3f6:	c0 31       	brne	8000b3fc <_dtoa_r+0x9a4>
8000b3f8:	08 9c       	mov	r12,r4
8000b3fa:	c1 38       	rjmp	8000b420 <_dtoa_r+0x9c8>
8000b3fc:	68 1b       	ld.w	r11,r4[0x4]
8000b3fe:	0e 9c       	mov	r12,r7
8000b400:	e0 a0 05 fe 	rcall	8000bffc <_Balloc>
8000b404:	68 4a       	ld.w	r10,r4[0x10]
8000b406:	18 95       	mov	r5,r12
8000b408:	e8 cb ff f4 	sub	r11,r4,-12
8000b40c:	2f ea       	sub	r10,-2
8000b40e:	2f 4c       	sub	r12,-12
8000b410:	a3 6a       	lsl	r10,0x2
8000b412:	fe b0 e6 4f 	rcall	800080b0 <memcpy>
8000b416:	0a 9b       	mov	r11,r5
8000b418:	30 1a       	mov	r10,1
8000b41a:	0e 9c       	mov	r12,r7
8000b41c:	e0 a0 06 e0 	rcall	8000c1dc <__lshift>
8000b420:	50 44       	stdsp	sp[0x10],r4
8000b422:	40 3a       	lddsp	r10,sp[0xc]
8000b424:	30 19       	mov	r9,1
8000b426:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000b42a:	18 94       	mov	r4,r12
8000b42c:	50 da       	stdsp	sp[0x34],r10
8000b42e:	40 85       	lddsp	r5,sp[0x20]
8000b430:	50 99       	stdsp	sp[0x24],r9
8000b432:	50 26       	stdsp	sp[0x8],r6
8000b434:	50 e1       	stdsp	sp[0x38],r1
8000b436:	04 9b       	mov	r11,r2
8000b438:	06 9c       	mov	r12,r3
8000b43a:	fe b0 fa 7f 	rcall	8000a938 <quorem>
8000b43e:	40 4b       	lddsp	r11,sp[0x10]
8000b440:	f8 c0 ff d0 	sub	r0,r12,-48
8000b444:	06 9c       	mov	r12,r3
8000b446:	e0 a0 05 a8 	rcall	8000bf96 <__mcmp>
8000b44a:	08 9a       	mov	r10,r4
8000b44c:	50 6c       	stdsp	sp[0x18],r12
8000b44e:	04 9b       	mov	r11,r2
8000b450:	0e 9c       	mov	r12,r7
8000b452:	e0 a0 06 5d 	rcall	8000c10c <__mdiff>
8000b456:	18 91       	mov	r1,r12
8000b458:	78 38       	ld.w	r8,r12[0xc]
8000b45a:	58 08       	cp.w	r8,0
8000b45c:	c0 30       	breq	8000b462 <_dtoa_r+0xa0a>
8000b45e:	30 16       	mov	r6,1
8000b460:	c0 68       	rjmp	8000b46c <_dtoa_r+0xa14>
8000b462:	18 9b       	mov	r11,r12
8000b464:	06 9c       	mov	r12,r3
8000b466:	e0 a0 05 98 	rcall	8000bf96 <__mcmp>
8000b46a:	18 96       	mov	r6,r12
8000b46c:	0e 9c       	mov	r12,r7
8000b46e:	02 9b       	mov	r11,r1
8000b470:	e0 a0 05 ac 	rcall	8000bfc8 <_Bfree>
8000b474:	40 cc       	lddsp	r12,sp[0x30]
8000b476:	ed ec 10 08 	or	r8,r6,r12
8000b47a:	c0 d1       	brne	8000b494 <_dtoa_r+0xa3c>
8000b47c:	40 db       	lddsp	r11,sp[0x34]
8000b47e:	58 0b       	cp.w	r11,0
8000b480:	c0 a1       	brne	8000b494 <_dtoa_r+0xa3c>
8000b482:	40 26       	lddsp	r6,sp[0x8]
8000b484:	e0 40 00 39 	cp.w	r0,57
8000b488:	c3 00       	breq	8000b4e8 <_dtoa_r+0xa90>
8000b48a:	40 6a       	lddsp	r10,sp[0x18]
8000b48c:	58 0a       	cp.w	r10,0
8000b48e:	e0 89 00 24 	brgt	8000b4d6 <_dtoa_r+0xa7e>
8000b492:	c2 f8       	rjmp	8000b4f0 <_dtoa_r+0xa98>
8000b494:	40 69       	lddsp	r9,sp[0x18]
8000b496:	58 09       	cp.w	r9,0
8000b498:	c0 85       	brlt	8000b4a8 <_dtoa_r+0xa50>
8000b49a:	12 98       	mov	r8,r9
8000b49c:	40 cc       	lddsp	r12,sp[0x30]
8000b49e:	18 48       	or	r8,r12
8000b4a0:	c1 d1       	brne	8000b4da <_dtoa_r+0xa82>
8000b4a2:	40 db       	lddsp	r11,sp[0x34]
8000b4a4:	58 0b       	cp.w	r11,0
8000b4a6:	c1 a1       	brne	8000b4da <_dtoa_r+0xa82>
8000b4a8:	0c 99       	mov	r9,r6
8000b4aa:	40 26       	lddsp	r6,sp[0x8]
8000b4ac:	58 09       	cp.w	r9,0
8000b4ae:	e0 8a 00 21 	brle	8000b4f0 <_dtoa_r+0xa98>
8000b4b2:	06 9b       	mov	r11,r3
8000b4b4:	30 1a       	mov	r10,1
8000b4b6:	0e 9c       	mov	r12,r7
8000b4b8:	e0 a0 06 92 	rcall	8000c1dc <__lshift>
8000b4bc:	04 9b       	mov	r11,r2
8000b4be:	18 93       	mov	r3,r12
8000b4c0:	e0 a0 05 6b 	rcall	8000bf96 <__mcmp>
8000b4c4:	e0 89 00 06 	brgt	8000b4d0 <_dtoa_r+0xa78>
8000b4c8:	c1 41       	brne	8000b4f0 <_dtoa_r+0xa98>
8000b4ca:	ed b0 00 00 	bld	r0,0x0
8000b4ce:	c1 11       	brne	8000b4f0 <_dtoa_r+0xa98>
8000b4d0:	e0 40 00 39 	cp.w	r0,57
8000b4d4:	c0 a0       	breq	8000b4e8 <_dtoa_r+0xa90>
8000b4d6:	2f f0       	sub	r0,-1
8000b4d8:	c0 c8       	rjmp	8000b4f0 <_dtoa_r+0xa98>
8000b4da:	58 06       	cp.w	r6,0
8000b4dc:	e0 8a 00 0c 	brle	8000b4f4 <_dtoa_r+0xa9c>
8000b4e0:	40 26       	lddsp	r6,sp[0x8]
8000b4e2:	e0 40 00 39 	cp.w	r0,57
8000b4e6:	c0 41       	brne	8000b4ee <_dtoa_r+0xa96>
8000b4e8:	33 98       	mov	r8,57
8000b4ea:	0a c8       	st.b	r5++,r8
8000b4ec:	c6 78       	rjmp	8000b5ba <_dtoa_r+0xb62>
8000b4ee:	2f f0       	sub	r0,-1
8000b4f0:	0a c0       	st.b	r5++,r0
8000b4f2:	c7 58       	rjmp	8000b5dc <_dtoa_r+0xb84>
8000b4f4:	0a c0       	st.b	r5++,r0
8000b4f6:	40 9a       	lddsp	r10,sp[0x24]
8000b4f8:	40 e9       	lddsp	r9,sp[0x38]
8000b4fa:	12 3a       	cp.w	r10,r9
8000b4fc:	c4 30       	breq	8000b582 <_dtoa_r+0xb2a>
8000b4fe:	06 9b       	mov	r11,r3
8000b500:	30 09       	mov	r9,0
8000b502:	30 aa       	mov	r10,10
8000b504:	0e 9c       	mov	r12,r7
8000b506:	e0 a0 07 37 	rcall	8000c374 <__multadd>
8000b50a:	40 48       	lddsp	r8,sp[0x10]
8000b50c:	18 93       	mov	r3,r12
8000b50e:	08 38       	cp.w	r8,r4
8000b510:	c0 91       	brne	8000b522 <_dtoa_r+0xaca>
8000b512:	10 9b       	mov	r11,r8
8000b514:	30 09       	mov	r9,0
8000b516:	30 aa       	mov	r10,10
8000b518:	0e 9c       	mov	r12,r7
8000b51a:	e0 a0 07 2d 	rcall	8000c374 <__multadd>
8000b51e:	50 4c       	stdsp	sp[0x10],r12
8000b520:	c0 e8       	rjmp	8000b53c <_dtoa_r+0xae4>
8000b522:	40 4b       	lddsp	r11,sp[0x10]
8000b524:	30 09       	mov	r9,0
8000b526:	30 aa       	mov	r10,10
8000b528:	0e 9c       	mov	r12,r7
8000b52a:	e0 a0 07 25 	rcall	8000c374 <__multadd>
8000b52e:	08 9b       	mov	r11,r4
8000b530:	50 4c       	stdsp	sp[0x10],r12
8000b532:	30 09       	mov	r9,0
8000b534:	30 aa       	mov	r10,10
8000b536:	0e 9c       	mov	r12,r7
8000b538:	e0 a0 07 1e 	rcall	8000c374 <__multadd>
8000b53c:	18 94       	mov	r4,r12
8000b53e:	40 9c       	lddsp	r12,sp[0x24]
8000b540:	2f fc       	sub	r12,-1
8000b542:	50 9c       	stdsp	sp[0x24],r12
8000b544:	c7 9b       	rjmp	8000b436 <_dtoa_r+0x9de>
8000b546:	30 18       	mov	r8,1
8000b548:	06 90       	mov	r0,r3
8000b54a:	40 85       	lddsp	r5,sp[0x20]
8000b54c:	08 93       	mov	r3,r4
8000b54e:	0c 94       	mov	r4,r6
8000b550:	10 96       	mov	r6,r8
8000b552:	04 9b       	mov	r11,r2
8000b554:	00 9c       	mov	r12,r0
8000b556:	fe b0 f9 f1 	rcall	8000a938 <quorem>
8000b55a:	2d 0c       	sub	r12,-48
8000b55c:	0a cc       	st.b	r5++,r12
8000b55e:	02 36       	cp.w	r6,r1
8000b560:	c0 a4       	brge	8000b574 <_dtoa_r+0xb1c>
8000b562:	00 9b       	mov	r11,r0
8000b564:	30 09       	mov	r9,0
8000b566:	30 aa       	mov	r10,10
8000b568:	0e 9c       	mov	r12,r7
8000b56a:	2f f6       	sub	r6,-1
8000b56c:	e0 a0 07 04 	rcall	8000c374 <__multadd>
8000b570:	18 90       	mov	r0,r12
8000b572:	cf 0b       	rjmp	8000b552 <_dtoa_r+0xafa>
8000b574:	08 96       	mov	r6,r4
8000b576:	30 0b       	mov	r11,0
8000b578:	06 94       	mov	r4,r3
8000b57a:	50 4b       	stdsp	sp[0x10],r11
8000b57c:	00 93       	mov	r3,r0
8000b57e:	18 90       	mov	r0,r12
8000b580:	c0 28       	rjmp	8000b584 <_dtoa_r+0xb2c>
8000b582:	40 26       	lddsp	r6,sp[0x8]
8000b584:	06 9b       	mov	r11,r3
8000b586:	30 1a       	mov	r10,1
8000b588:	0e 9c       	mov	r12,r7
8000b58a:	e0 a0 06 29 	rcall	8000c1dc <__lshift>
8000b58e:	04 9b       	mov	r11,r2
8000b590:	18 93       	mov	r3,r12
8000b592:	e0 a0 05 02 	rcall	8000bf96 <__mcmp>
8000b596:	e0 89 00 12 	brgt	8000b5ba <_dtoa_r+0xb62>
8000b59a:	c1 b1       	brne	8000b5d0 <_dtoa_r+0xb78>
8000b59c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000b5a0:	c0 d1       	brne	8000b5ba <_dtoa_r+0xb62>
8000b5a2:	c1 78       	rjmp	8000b5d0 <_dtoa_r+0xb78>
8000b5a4:	40 89       	lddsp	r9,sp[0x20]
8000b5a6:	12 38       	cp.w	r8,r9
8000b5a8:	c0 30       	breq	8000b5ae <_dtoa_r+0xb56>
8000b5aa:	10 95       	mov	r5,r8
8000b5ac:	c0 88       	rjmp	8000b5bc <_dtoa_r+0xb64>
8000b5ae:	2f f6       	sub	r6,-1
8000b5b0:	50 66       	stdsp	sp[0x18],r6
8000b5b2:	33 18       	mov	r8,49
8000b5b4:	40 8c       	lddsp	r12,sp[0x20]
8000b5b6:	b8 88       	st.b	r12[0x0],r8
8000b5b8:	c1 38       	rjmp	8000b5de <_dtoa_r+0xb86>
8000b5ba:	33 9a       	mov	r10,57
8000b5bc:	0a 98       	mov	r8,r5
8000b5be:	11 79       	ld.ub	r9,--r8
8000b5c0:	f4 09 18 00 	cp.b	r9,r10
8000b5c4:	cf 00       	breq	8000b5a4 <_dtoa_r+0xb4c>
8000b5c6:	2f f9       	sub	r9,-1
8000b5c8:	b0 89       	st.b	r8[0x0],r9
8000b5ca:	c0 98       	rjmp	8000b5dc <_dtoa_r+0xb84>
8000b5cc:	10 95       	mov	r5,r8
8000b5ce:	c0 28       	rjmp	8000b5d2 <_dtoa_r+0xb7a>
8000b5d0:	33 09       	mov	r9,48
8000b5d2:	0a 98       	mov	r8,r5
8000b5d4:	11 7a       	ld.ub	r10,--r8
8000b5d6:	f2 0a 18 00 	cp.b	r10,r9
8000b5da:	cf 90       	breq	8000b5cc <_dtoa_r+0xb74>
8000b5dc:	50 66       	stdsp	sp[0x18],r6
8000b5de:	04 9b       	mov	r11,r2
8000b5e0:	0e 9c       	mov	r12,r7
8000b5e2:	e0 a0 04 f3 	rcall	8000bfc8 <_Bfree>
8000b5e6:	58 04       	cp.w	r4,0
8000b5e8:	c1 20       	breq	8000b60c <_dtoa_r+0xbb4>
8000b5ea:	40 4b       	lddsp	r11,sp[0x10]
8000b5ec:	08 3b       	cp.w	r11,r4
8000b5ee:	5f 19       	srne	r9
8000b5f0:	58 0b       	cp.w	r11,0
8000b5f2:	5f 18       	srne	r8
8000b5f4:	f3 e8 00 08 	and	r8,r9,r8
8000b5f8:	c0 40       	breq	8000b600 <_dtoa_r+0xba8>
8000b5fa:	0e 9c       	mov	r12,r7
8000b5fc:	e0 a0 04 e6 	rcall	8000bfc8 <_Bfree>
8000b600:	08 9b       	mov	r11,r4
8000b602:	0e 9c       	mov	r12,r7
8000b604:	e0 a0 04 e2 	rcall	8000bfc8 <_Bfree>
8000b608:	c0 28       	rjmp	8000b60c <_dtoa_r+0xbb4>
8000b60a:	50 66       	stdsp	sp[0x18],r6
8000b60c:	0e 9c       	mov	r12,r7
8000b60e:	06 9b       	mov	r11,r3
8000b610:	e0 a0 04 dc 	rcall	8000bfc8 <_Bfree>
8000b614:	30 08       	mov	r8,0
8000b616:	aa 88       	st.b	r5[0x0],r8
8000b618:	40 68       	lddsp	r8,sp[0x18]
8000b61a:	41 5a       	lddsp	r10,sp[0x54]
8000b61c:	2f f8       	sub	r8,-1
8000b61e:	41 29       	lddsp	r9,sp[0x48]
8000b620:	95 08       	st.w	r10[0x0],r8
8000b622:	40 8c       	lddsp	r12,sp[0x20]
8000b624:	58 09       	cp.w	r9,0
8000b626:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000b62a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000b62e:	2e 6d       	sub	sp,-104
8000b630:	d8 32       	popm	r0-r7,pc
8000b632:	d7 03       	nop

8000b634 <__errno>:
8000b634:	e0 68 0a 44 	mov	r8,2628
8000b638:	70 0c       	ld.w	r12,r8[0x0]
8000b63a:	2f 4c       	sub	r12,-12
8000b63c:	5e fc       	retal	r12
8000b63e:	d7 03       	nop

8000b640 <_fflush_r>:
8000b640:	d4 21       	pushm	r4-r7,lr
8000b642:	16 97       	mov	r7,r11
8000b644:	18 96       	mov	r6,r12
8000b646:	76 48       	ld.w	r8,r11[0x10]
8000b648:	58 08       	cp.w	r8,0
8000b64a:	c7 f0       	breq	8000b748 <_fflush_r+0x108>
8000b64c:	58 0c       	cp.w	r12,0
8000b64e:	c0 50       	breq	8000b658 <_fflush_r+0x18>
8000b650:	78 68       	ld.w	r8,r12[0x18]
8000b652:	58 08       	cp.w	r8,0
8000b654:	c0 21       	brne	8000b658 <_fflush_r+0x18>
8000b656:	cc dc       	rcall	8000b7f0 <__sinit>
8000b658:	fe c8 cb 40 	sub	r8,pc,-13504
8000b65c:	10 37       	cp.w	r7,r8
8000b65e:	c0 31       	brne	8000b664 <_fflush_r+0x24>
8000b660:	6c 07       	ld.w	r7,r6[0x0]
8000b662:	c0 c8       	rjmp	8000b67a <_fflush_r+0x3a>
8000b664:	fe c8 cb 2c 	sub	r8,pc,-13524
8000b668:	10 37       	cp.w	r7,r8
8000b66a:	c0 31       	brne	8000b670 <_fflush_r+0x30>
8000b66c:	6c 17       	ld.w	r7,r6[0x4]
8000b66e:	c0 68       	rjmp	8000b67a <_fflush_r+0x3a>
8000b670:	fe c8 cb 18 	sub	r8,pc,-13544
8000b674:	10 37       	cp.w	r7,r8
8000b676:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b67a:	8e 6a       	ld.sh	r10,r7[0xc]
8000b67c:	14 98       	mov	r8,r10
8000b67e:	ed ba 00 03 	bld	r10,0x3
8000b682:	c4 20       	breq	8000b706 <_fflush_r+0xc6>
8000b684:	ab ba       	sbr	r10,0xb
8000b686:	ae 6a       	st.h	r7[0xc],r10
8000b688:	6e 18       	ld.w	r8,r7[0x4]
8000b68a:	58 08       	cp.w	r8,0
8000b68c:	e0 89 00 06 	brgt	8000b698 <_fflush_r+0x58>
8000b690:	6f 08       	ld.w	r8,r7[0x40]
8000b692:	58 08       	cp.w	r8,0
8000b694:	e0 8a 00 5a 	brle	8000b748 <_fflush_r+0x108>
8000b698:	6e b8       	ld.w	r8,r7[0x2c]
8000b69a:	58 08       	cp.w	r8,0
8000b69c:	c5 60       	breq	8000b748 <_fflush_r+0x108>
8000b69e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000b6a2:	c0 30       	breq	8000b6a8 <_fflush_r+0x68>
8000b6a4:	6f 55       	ld.w	r5,r7[0x54]
8000b6a6:	c0 f8       	rjmp	8000b6c4 <_fflush_r+0x84>
8000b6a8:	30 19       	mov	r9,1
8000b6aa:	6e 8b       	ld.w	r11,r7[0x20]
8000b6ac:	0c 9c       	mov	r12,r6
8000b6ae:	5d 18       	icall	r8
8000b6b0:	18 95       	mov	r5,r12
8000b6b2:	5b fc       	cp.w	r12,-1
8000b6b4:	c0 81       	brne	8000b6c4 <_fflush_r+0x84>
8000b6b6:	6c 38       	ld.w	r8,r6[0xc]
8000b6b8:	59 d8       	cp.w	r8,29
8000b6ba:	c4 70       	breq	8000b748 <_fflush_r+0x108>
8000b6bc:	8e 68       	ld.sh	r8,r7[0xc]
8000b6be:	a7 a8       	sbr	r8,0x6
8000b6c0:	ae 68       	st.h	r7[0xc],r8
8000b6c2:	d8 22       	popm	r4-r7,pc
8000b6c4:	8e 68       	ld.sh	r8,r7[0xc]
8000b6c6:	ed b8 00 02 	bld	r8,0x2
8000b6ca:	c0 91       	brne	8000b6dc <_fflush_r+0x9c>
8000b6cc:	6e 18       	ld.w	r8,r7[0x4]
8000b6ce:	10 15       	sub	r5,r8
8000b6d0:	6e d8       	ld.w	r8,r7[0x34]
8000b6d2:	58 08       	cp.w	r8,0
8000b6d4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b6d8:	eb d8 e1 15 	subne	r5,r5,r8
8000b6dc:	6e b8       	ld.w	r8,r7[0x2c]
8000b6de:	0c 9c       	mov	r12,r6
8000b6e0:	30 09       	mov	r9,0
8000b6e2:	0a 9a       	mov	r10,r5
8000b6e4:	6e 8b       	ld.w	r11,r7[0x20]
8000b6e6:	5d 18       	icall	r8
8000b6e8:	8e 68       	ld.sh	r8,r7[0xc]
8000b6ea:	0a 3c       	cp.w	r12,r5
8000b6ec:	c2 61       	brne	8000b738 <_fflush_r+0xf8>
8000b6ee:	ab d8       	cbr	r8,0xb
8000b6f0:	30 0c       	mov	r12,0
8000b6f2:	6e 49       	ld.w	r9,r7[0x10]
8000b6f4:	ae 68       	st.h	r7[0xc],r8
8000b6f6:	8f 1c       	st.w	r7[0x4],r12
8000b6f8:	8f 09       	st.w	r7[0x0],r9
8000b6fa:	ed b8 00 0c 	bld	r8,0xc
8000b6fe:	c2 51       	brne	8000b748 <_fflush_r+0x108>
8000b700:	ef 45 00 54 	st.w	r7[84],r5
8000b704:	d8 22       	popm	r4-r7,pc
8000b706:	6e 45       	ld.w	r5,r7[0x10]
8000b708:	58 05       	cp.w	r5,0
8000b70a:	c1 f0       	breq	8000b748 <_fflush_r+0x108>
8000b70c:	6e 04       	ld.w	r4,r7[0x0]
8000b70e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b712:	8f 05       	st.w	r7[0x0],r5
8000b714:	f9 b8 01 00 	movne	r8,0
8000b718:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b71c:	0a 14       	sub	r4,r5
8000b71e:	8f 28       	st.w	r7[0x8],r8
8000b720:	c1 18       	rjmp	8000b742 <_fflush_r+0x102>
8000b722:	08 99       	mov	r9,r4
8000b724:	0a 9a       	mov	r10,r5
8000b726:	6e a8       	ld.w	r8,r7[0x28]
8000b728:	6e 8b       	ld.w	r11,r7[0x20]
8000b72a:	0c 9c       	mov	r12,r6
8000b72c:	5d 18       	icall	r8
8000b72e:	18 14       	sub	r4,r12
8000b730:	58 0c       	cp.w	r12,0
8000b732:	e0 89 00 07 	brgt	8000b740 <_fflush_r+0x100>
8000b736:	8e 68       	ld.sh	r8,r7[0xc]
8000b738:	a7 a8       	sbr	r8,0x6
8000b73a:	3f fc       	mov	r12,-1
8000b73c:	ae 68       	st.h	r7[0xc],r8
8000b73e:	d8 22       	popm	r4-r7,pc
8000b740:	18 05       	add	r5,r12
8000b742:	58 04       	cp.w	r4,0
8000b744:	fe 99 ff ef 	brgt	8000b722 <_fflush_r+0xe2>
8000b748:	d8 2a       	popm	r4-r7,pc,r12=0
8000b74a:	d7 03       	nop

8000b74c <__sfp_lock_acquire>:
8000b74c:	5e fc       	retal	r12

8000b74e <__sfp_lock_release>:
8000b74e:	5e fc       	retal	r12

8000b750 <_cleanup_r>:
8000b750:	d4 01       	pushm	lr
8000b752:	fe cb f0 ae 	sub	r11,pc,-3922
8000b756:	e0 a0 02 f7 	rcall	8000bd44 <_fwalk>
8000b75a:	d8 02       	popm	pc

8000b75c <__sfmoreglue>:
8000b75c:	d4 21       	pushm	r4-r7,lr
8000b75e:	16 95       	mov	r5,r11
8000b760:	f6 06 10 5c 	mul	r6,r11,92
8000b764:	ec cb ff f4 	sub	r11,r6,-12
8000b768:	fe b0 e2 88 	rcall	80007c78 <_malloc_r>
8000b76c:	18 97       	mov	r7,r12
8000b76e:	c0 90       	breq	8000b780 <__sfmoreglue+0x24>
8000b770:	99 15       	st.w	r12[0x4],r5
8000b772:	30 0b       	mov	r11,0
8000b774:	2f 4c       	sub	r12,-12
8000b776:	0c 9a       	mov	r10,r6
8000b778:	8f 2c       	st.w	r7[0x8],r12
8000b77a:	8f 0b       	st.w	r7[0x0],r11
8000b77c:	fe b0 e5 3e 	rcall	800081f8 <memset>
8000b780:	0e 9c       	mov	r12,r7
8000b782:	d8 22       	popm	r4-r7,pc

8000b784 <__sfp>:
8000b784:	d4 21       	pushm	r4-r7,lr
8000b786:	fe c8 cc 0a 	sub	r8,pc,-13302
8000b78a:	18 96       	mov	r6,r12
8000b78c:	70 07       	ld.w	r7,r8[0x0]
8000b78e:	6e 68       	ld.w	r8,r7[0x18]
8000b790:	58 08       	cp.w	r8,0
8000b792:	c0 31       	brne	8000b798 <__sfp+0x14>
8000b794:	0e 9c       	mov	r12,r7
8000b796:	c2 dc       	rcall	8000b7f0 <__sinit>
8000b798:	ee c7 ff 28 	sub	r7,r7,-216
8000b79c:	30 05       	mov	r5,0
8000b79e:	6e 2c       	ld.w	r12,r7[0x8]
8000b7a0:	6e 18       	ld.w	r8,r7[0x4]
8000b7a2:	c0 68       	rjmp	8000b7ae <__sfp+0x2a>
8000b7a4:	98 69       	ld.sh	r9,r12[0xc]
8000b7a6:	ea 09 19 00 	cp.h	r9,r5
8000b7aa:	c1 10       	breq	8000b7cc <__sfp+0x48>
8000b7ac:	2a 4c       	sub	r12,-92
8000b7ae:	20 18       	sub	r8,1
8000b7b0:	cf a7       	brpl	8000b7a4 <__sfp+0x20>
8000b7b2:	6e 08       	ld.w	r8,r7[0x0]
8000b7b4:	58 08       	cp.w	r8,0
8000b7b6:	c0 61       	brne	8000b7c2 <__sfp+0x3e>
8000b7b8:	30 4b       	mov	r11,4
8000b7ba:	0c 9c       	mov	r12,r6
8000b7bc:	cd 0f       	rcall	8000b75c <__sfmoreglue>
8000b7be:	8f 0c       	st.w	r7[0x0],r12
8000b7c0:	c0 30       	breq	8000b7c6 <__sfp+0x42>
8000b7c2:	6e 07       	ld.w	r7,r7[0x0]
8000b7c4:	ce db       	rjmp	8000b79e <__sfp+0x1a>
8000b7c6:	30 c8       	mov	r8,12
8000b7c8:	8d 38       	st.w	r6[0xc],r8
8000b7ca:	d8 22       	popm	r4-r7,pc
8000b7cc:	30 08       	mov	r8,0
8000b7ce:	f9 48 00 4c 	st.w	r12[76],r8
8000b7d2:	99 08       	st.w	r12[0x0],r8
8000b7d4:	99 28       	st.w	r12[0x8],r8
8000b7d6:	99 18       	st.w	r12[0x4],r8
8000b7d8:	99 48       	st.w	r12[0x10],r8
8000b7da:	99 58       	st.w	r12[0x14],r8
8000b7dc:	99 68       	st.w	r12[0x18],r8
8000b7de:	99 d8       	st.w	r12[0x34],r8
8000b7e0:	99 e8       	st.w	r12[0x38],r8
8000b7e2:	f9 48 00 48 	st.w	r12[72],r8
8000b7e6:	3f f8       	mov	r8,-1
8000b7e8:	b8 78       	st.h	r12[0xe],r8
8000b7ea:	30 18       	mov	r8,1
8000b7ec:	b8 68       	st.h	r12[0xc],r8
8000b7ee:	d8 22       	popm	r4-r7,pc

8000b7f0 <__sinit>:
8000b7f0:	d4 21       	pushm	r4-r7,lr
8000b7f2:	18 96       	mov	r6,r12
8000b7f4:	78 67       	ld.w	r7,r12[0x18]
8000b7f6:	58 07       	cp.w	r7,0
8000b7f8:	c4 91       	brne	8000b88a <__sinit+0x9a>
8000b7fa:	fe c8 00 aa 	sub	r8,pc,170
8000b7fe:	30 15       	mov	r5,1
8000b800:	99 a8       	st.w	r12[0x28],r8
8000b802:	f9 47 00 d8 	st.w	r12[216],r7
8000b806:	f9 47 00 dc 	st.w	r12[220],r7
8000b80a:	f9 47 00 e0 	st.w	r12[224],r7
8000b80e:	99 65       	st.w	r12[0x18],r5
8000b810:	cb af       	rcall	8000b784 <__sfp>
8000b812:	8d 0c       	st.w	r6[0x0],r12
8000b814:	0c 9c       	mov	r12,r6
8000b816:	cb 7f       	rcall	8000b784 <__sfp>
8000b818:	8d 1c       	st.w	r6[0x4],r12
8000b81a:	0c 9c       	mov	r12,r6
8000b81c:	cb 4f       	rcall	8000b784 <__sfp>
8000b81e:	6c 09       	ld.w	r9,r6[0x0]
8000b820:	30 48       	mov	r8,4
8000b822:	93 07       	st.w	r9[0x0],r7
8000b824:	b2 68       	st.h	r9[0xc],r8
8000b826:	93 17       	st.w	r9[0x4],r7
8000b828:	93 27       	st.w	r9[0x8],r7
8000b82a:	6c 18       	ld.w	r8,r6[0x4]
8000b82c:	b2 77       	st.h	r9[0xe],r7
8000b82e:	93 47       	st.w	r9[0x10],r7
8000b830:	93 57       	st.w	r9[0x14],r7
8000b832:	93 67       	st.w	r9[0x18],r7
8000b834:	93 89       	st.w	r9[0x20],r9
8000b836:	91 07       	st.w	r8[0x0],r7
8000b838:	91 17       	st.w	r8[0x4],r7
8000b83a:	91 27       	st.w	r8[0x8],r7
8000b83c:	fe ce f3 24 	sub	lr,pc,-3292
8000b840:	fe cb f3 54 	sub	r11,pc,-3244
8000b844:	93 9e       	st.w	r9[0x24],lr
8000b846:	93 ab       	st.w	r9[0x28],r11
8000b848:	fe ca f3 7c 	sub	r10,pc,-3204
8000b84c:	fe c4 f3 88 	sub	r4,pc,-3192
8000b850:	93 ba       	st.w	r9[0x2c],r10
8000b852:	93 c4       	st.w	r9[0x30],r4
8000b854:	30 99       	mov	r9,9
8000b856:	b0 69       	st.h	r8[0xc],r9
8000b858:	b0 75       	st.h	r8[0xe],r5
8000b85a:	91 c4       	st.w	r8[0x30],r4
8000b85c:	91 47       	st.w	r8[0x10],r7
8000b85e:	91 57       	st.w	r8[0x14],r7
8000b860:	91 67       	st.w	r8[0x18],r7
8000b862:	91 88       	st.w	r8[0x20],r8
8000b864:	91 9e       	st.w	r8[0x24],lr
8000b866:	91 ab       	st.w	r8[0x28],r11
8000b868:	91 ba       	st.w	r8[0x2c],r10
8000b86a:	8d 2c       	st.w	r6[0x8],r12
8000b86c:	31 28       	mov	r8,18
8000b86e:	99 07       	st.w	r12[0x0],r7
8000b870:	b8 68       	st.h	r12[0xc],r8
8000b872:	99 17       	st.w	r12[0x4],r7
8000b874:	99 27       	st.w	r12[0x8],r7
8000b876:	30 28       	mov	r8,2
8000b878:	b8 78       	st.h	r12[0xe],r8
8000b87a:	99 c4       	st.w	r12[0x30],r4
8000b87c:	99 67       	st.w	r12[0x18],r7
8000b87e:	99 9e       	st.w	r12[0x24],lr
8000b880:	99 ab       	st.w	r12[0x28],r11
8000b882:	99 ba       	st.w	r12[0x2c],r10
8000b884:	99 47       	st.w	r12[0x10],r7
8000b886:	99 57       	st.w	r12[0x14],r7
8000b888:	99 8c       	st.w	r12[0x20],r12
8000b88a:	d8 22       	popm	r4-r7,pc

8000b88c <_malloc_trim_r>:
8000b88c:	d4 21       	pushm	r4-r7,lr
8000b88e:	16 95       	mov	r5,r11
8000b890:	18 97       	mov	r7,r12
8000b892:	fe b0 d7 d9 	rcall	80006844 <__malloc_lock>
8000b896:	e0 64 05 44 	mov	r4,1348
8000b89a:	68 28       	ld.w	r8,r4[0x8]
8000b89c:	70 16       	ld.w	r6,r8[0x4]
8000b89e:	e0 16 ff fc 	andl	r6,0xfffc
8000b8a2:	ec c8 ff 91 	sub	r8,r6,-111
8000b8a6:	f0 05 01 05 	sub	r5,r8,r5
8000b8aa:	e0 15 ff 80 	andl	r5,0xff80
8000b8ae:	ea c5 00 80 	sub	r5,r5,128
8000b8b2:	e0 45 00 7f 	cp.w	r5,127
8000b8b6:	e0 8a 00 25 	brle	8000b900 <_malloc_trim_r+0x74>
8000b8ba:	30 0b       	mov	r11,0
8000b8bc:	0e 9c       	mov	r12,r7
8000b8be:	fe b0 e6 05 	rcall	800084c8 <_sbrk_r>
8000b8c2:	68 28       	ld.w	r8,r4[0x8]
8000b8c4:	0c 08       	add	r8,r6
8000b8c6:	10 3c       	cp.w	r12,r8
8000b8c8:	c1 c1       	brne	8000b900 <_malloc_trim_r+0x74>
8000b8ca:	ea 0b 11 00 	rsub	r11,r5,0
8000b8ce:	0e 9c       	mov	r12,r7
8000b8d0:	fe b0 e5 fc 	rcall	800084c8 <_sbrk_r>
8000b8d4:	5b fc       	cp.w	r12,-1
8000b8d6:	c1 91       	brne	8000b908 <_malloc_trim_r+0x7c>
8000b8d8:	30 0b       	mov	r11,0
8000b8da:	0e 9c       	mov	r12,r7
8000b8dc:	fe b0 e5 f6 	rcall	800084c8 <_sbrk_r>
8000b8e0:	68 28       	ld.w	r8,r4[0x8]
8000b8e2:	f8 08 01 09 	sub	r9,r12,r8
8000b8e6:	58 f9       	cp.w	r9,15
8000b8e8:	e0 8a 00 0c 	brle	8000b900 <_malloc_trim_r+0x74>
8000b8ec:	a1 a9       	sbr	r9,0x0
8000b8ee:	91 19       	st.w	r8[0x4],r9
8000b8f0:	e0 68 09 50 	mov	r8,2384
8000b8f4:	70 09       	ld.w	r9,r8[0x0]
8000b8f6:	e0 68 0d 84 	mov	r8,3460
8000b8fa:	f8 09 01 09 	sub	r9,r12,r9
8000b8fe:	91 09       	st.w	r8[0x0],r9
8000b900:	0e 9c       	mov	r12,r7
8000b902:	fe b0 d7 a7 	rcall	80006850 <__malloc_unlock>
8000b906:	d8 2a       	popm	r4-r7,pc,r12=0
8000b908:	68 28       	ld.w	r8,r4[0x8]
8000b90a:	0a 16       	sub	r6,r5
8000b90c:	a1 a6       	sbr	r6,0x0
8000b90e:	91 16       	st.w	r8[0x4],r6
8000b910:	e0 68 0d 84 	mov	r8,3460
8000b914:	70 09       	ld.w	r9,r8[0x0]
8000b916:	0a 19       	sub	r9,r5
8000b918:	0e 9c       	mov	r12,r7
8000b91a:	91 09       	st.w	r8[0x0],r9
8000b91c:	fe b0 d7 9a 	rcall	80006850 <__malloc_unlock>
8000b920:	da 2a       	popm	r4-r7,pc,r12=1
8000b922:	d7 03       	nop

8000b924 <_free_r>:
8000b924:	d4 21       	pushm	r4-r7,lr
8000b926:	16 96       	mov	r6,r11
8000b928:	18 97       	mov	r7,r12
8000b92a:	58 0b       	cp.w	r11,0
8000b92c:	e0 80 00 c0 	breq	8000baac <_free_r+0x188>
8000b930:	fe b0 d7 8a 	rcall	80006844 <__malloc_lock>
8000b934:	20 86       	sub	r6,8
8000b936:	e0 6a 05 44 	mov	r10,1348
8000b93a:	6c 18       	ld.w	r8,r6[0x4]
8000b93c:	74 2e       	ld.w	lr,r10[0x8]
8000b93e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b942:	a1 c8       	cbr	r8,0x0
8000b944:	ec 08 00 09 	add	r9,r6,r8
8000b948:	72 1b       	ld.w	r11,r9[0x4]
8000b94a:	e0 1b ff fc 	andl	r11,0xfffc
8000b94e:	1c 39       	cp.w	r9,lr
8000b950:	c1 e1       	brne	8000b98c <_free_r+0x68>
8000b952:	f6 08 00 08 	add	r8,r11,r8
8000b956:	58 0c       	cp.w	r12,0
8000b958:	c0 81       	brne	8000b968 <_free_r+0x44>
8000b95a:	6c 09       	ld.w	r9,r6[0x0]
8000b95c:	12 16       	sub	r6,r9
8000b95e:	12 08       	add	r8,r9
8000b960:	6c 3b       	ld.w	r11,r6[0xc]
8000b962:	6c 29       	ld.w	r9,r6[0x8]
8000b964:	97 29       	st.w	r11[0x8],r9
8000b966:	93 3b       	st.w	r9[0xc],r11
8000b968:	10 99       	mov	r9,r8
8000b96a:	95 26       	st.w	r10[0x8],r6
8000b96c:	a1 a9       	sbr	r9,0x0
8000b96e:	8d 19       	st.w	r6[0x4],r9
8000b970:	e0 69 09 4c 	mov	r9,2380
8000b974:	72 09       	ld.w	r9,r9[0x0]
8000b976:	12 38       	cp.w	r8,r9
8000b978:	c0 63       	brcs	8000b984 <_free_r+0x60>
8000b97a:	e0 68 0d 80 	mov	r8,3456
8000b97e:	0e 9c       	mov	r12,r7
8000b980:	70 0b       	ld.w	r11,r8[0x0]
8000b982:	c8 5f       	rcall	8000b88c <_malloc_trim_r>
8000b984:	0e 9c       	mov	r12,r7
8000b986:	fe b0 d7 65 	rcall	80006850 <__malloc_unlock>
8000b98a:	d8 22       	popm	r4-r7,pc
8000b98c:	93 1b       	st.w	r9[0x4],r11
8000b98e:	58 0c       	cp.w	r12,0
8000b990:	c0 30       	breq	8000b996 <_free_r+0x72>
8000b992:	30 0c       	mov	r12,0
8000b994:	c1 08       	rjmp	8000b9b4 <_free_r+0x90>
8000b996:	6c 0e       	ld.w	lr,r6[0x0]
8000b998:	f4 c5 ff f8 	sub	r5,r10,-8
8000b99c:	1c 16       	sub	r6,lr
8000b99e:	1c 08       	add	r8,lr
8000b9a0:	6c 2e       	ld.w	lr,r6[0x8]
8000b9a2:	0a 3e       	cp.w	lr,r5
8000b9a4:	f9 bc 00 01 	moveq	r12,1
8000b9a8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b9ac:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b9b0:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b9b4:	f2 0b 00 0e 	add	lr,r9,r11
8000b9b8:	7c 1e       	ld.w	lr,lr[0x4]
8000b9ba:	ed be 00 00 	bld	lr,0x0
8000b9be:	c1 40       	breq	8000b9e6 <_free_r+0xc2>
8000b9c0:	16 08       	add	r8,r11
8000b9c2:	58 0c       	cp.w	r12,0
8000b9c4:	c0 d1       	brne	8000b9de <_free_r+0xba>
8000b9c6:	e0 6e 05 44 	mov	lr,1348
8000b9ca:	72 2b       	ld.w	r11,r9[0x8]
8000b9cc:	2f 8e       	sub	lr,-8
8000b9ce:	1c 3b       	cp.w	r11,lr
8000b9d0:	c0 71       	brne	8000b9de <_free_r+0xba>
8000b9d2:	97 36       	st.w	r11[0xc],r6
8000b9d4:	97 26       	st.w	r11[0x8],r6
8000b9d6:	8d 2b       	st.w	r6[0x8],r11
8000b9d8:	8d 3b       	st.w	r6[0xc],r11
8000b9da:	30 1c       	mov	r12,1
8000b9dc:	c0 58       	rjmp	8000b9e6 <_free_r+0xc2>
8000b9de:	72 2b       	ld.w	r11,r9[0x8]
8000b9e0:	72 39       	ld.w	r9,r9[0xc]
8000b9e2:	93 2b       	st.w	r9[0x8],r11
8000b9e4:	97 39       	st.w	r11[0xc],r9
8000b9e6:	10 99       	mov	r9,r8
8000b9e8:	ec 08 09 08 	st.w	r6[r8],r8
8000b9ec:	a1 a9       	sbr	r9,0x0
8000b9ee:	8d 19       	st.w	r6[0x4],r9
8000b9f0:	58 0c       	cp.w	r12,0
8000b9f2:	c5 a1       	brne	8000baa6 <_free_r+0x182>
8000b9f4:	e0 48 01 ff 	cp.w	r8,511
8000b9f8:	e0 8b 00 13 	brhi	8000ba1e <_free_r+0xfa>
8000b9fc:	a3 98       	lsr	r8,0x3
8000b9fe:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ba02:	72 2b       	ld.w	r11,r9[0x8]
8000ba04:	8d 39       	st.w	r6[0xc],r9
8000ba06:	8d 2b       	st.w	r6[0x8],r11
8000ba08:	97 36       	st.w	r11[0xc],r6
8000ba0a:	93 26       	st.w	r9[0x8],r6
8000ba0c:	a3 48       	asr	r8,0x2
8000ba0e:	74 19       	ld.w	r9,r10[0x4]
8000ba10:	30 1b       	mov	r11,1
8000ba12:	f6 08 09 48 	lsl	r8,r11,r8
8000ba16:	f3 e8 10 08 	or	r8,r9,r8
8000ba1a:	95 18       	st.w	r10[0x4],r8
8000ba1c:	c4 58       	rjmp	8000baa6 <_free_r+0x182>
8000ba1e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ba22:	58 4b       	cp.w	r11,4
8000ba24:	e0 8b 00 06 	brhi	8000ba30 <_free_r+0x10c>
8000ba28:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ba2c:	2c 8b       	sub	r11,-56
8000ba2e:	c2 08       	rjmp	8000ba6e <_free_r+0x14a>
8000ba30:	59 4b       	cp.w	r11,20
8000ba32:	e0 8b 00 04 	brhi	8000ba3a <_free_r+0x116>
8000ba36:	2a 5b       	sub	r11,-91
8000ba38:	c1 b8       	rjmp	8000ba6e <_free_r+0x14a>
8000ba3a:	e0 4b 00 54 	cp.w	r11,84
8000ba3e:	e0 8b 00 06 	brhi	8000ba4a <_free_r+0x126>
8000ba42:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ba46:	29 2b       	sub	r11,-110
8000ba48:	c1 38       	rjmp	8000ba6e <_free_r+0x14a>
8000ba4a:	e0 4b 01 54 	cp.w	r11,340
8000ba4e:	e0 8b 00 06 	brhi	8000ba5a <_free_r+0x136>
8000ba52:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ba56:	28 9b       	sub	r11,-119
8000ba58:	c0 b8       	rjmp	8000ba6e <_free_r+0x14a>
8000ba5a:	e0 4b 05 54 	cp.w	r11,1364
8000ba5e:	e0 88 00 05 	brls	8000ba68 <_free_r+0x144>
8000ba62:	37 eb       	mov	r11,126
8000ba64:	c0 58       	rjmp	8000ba6e <_free_r+0x14a>
8000ba66:	d7 03       	nop
8000ba68:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ba6c:	28 4b       	sub	r11,-124
8000ba6e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ba72:	78 29       	ld.w	r9,r12[0x8]
8000ba74:	18 39       	cp.w	r9,r12
8000ba76:	c0 e1       	brne	8000ba92 <_free_r+0x16e>
8000ba78:	74 18       	ld.w	r8,r10[0x4]
8000ba7a:	a3 4b       	asr	r11,0x2
8000ba7c:	30 1c       	mov	r12,1
8000ba7e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ba82:	f1 eb 10 0b 	or	r11,r8,r11
8000ba86:	12 98       	mov	r8,r9
8000ba88:	95 1b       	st.w	r10[0x4],r11
8000ba8a:	c0 a8       	rjmp	8000ba9e <_free_r+0x17a>
8000ba8c:	72 29       	ld.w	r9,r9[0x8]
8000ba8e:	18 39       	cp.w	r9,r12
8000ba90:	c0 60       	breq	8000ba9c <_free_r+0x178>
8000ba92:	72 1a       	ld.w	r10,r9[0x4]
8000ba94:	e0 1a ff fc 	andl	r10,0xfffc
8000ba98:	14 38       	cp.w	r8,r10
8000ba9a:	cf 93       	brcs	8000ba8c <_free_r+0x168>
8000ba9c:	72 38       	ld.w	r8,r9[0xc]
8000ba9e:	8d 38       	st.w	r6[0xc],r8
8000baa0:	8d 29       	st.w	r6[0x8],r9
8000baa2:	93 36       	st.w	r9[0xc],r6
8000baa4:	91 26       	st.w	r8[0x8],r6
8000baa6:	0e 9c       	mov	r12,r7
8000baa8:	fe b0 d6 d4 	rcall	80006850 <__malloc_unlock>
8000baac:	d8 22       	popm	r4-r7,pc
8000baae:	d7 03       	nop

8000bab0 <__sfvwrite_r>:
8000bab0:	d4 31       	pushm	r0-r7,lr
8000bab2:	20 3d       	sub	sp,12
8000bab4:	14 94       	mov	r4,r10
8000bab6:	18 95       	mov	r5,r12
8000bab8:	16 97       	mov	r7,r11
8000baba:	74 28       	ld.w	r8,r10[0x8]
8000babc:	58 08       	cp.w	r8,0
8000babe:	e0 80 01 40 	breq	8000bd3e <__sfvwrite_r+0x28e>
8000bac2:	96 68       	ld.sh	r8,r11[0xc]
8000bac4:	ed b8 00 03 	bld	r8,0x3
8000bac8:	c0 41       	brne	8000bad0 <__sfvwrite_r+0x20>
8000baca:	76 48       	ld.w	r8,r11[0x10]
8000bacc:	58 08       	cp.w	r8,0
8000bace:	c0 c1       	brne	8000bae6 <__sfvwrite_r+0x36>
8000bad0:	0e 9b       	mov	r11,r7
8000bad2:	0a 9c       	mov	r12,r5
8000bad4:	fe b0 f6 c4 	rcall	8000a85c <__swsetup_r>
8000bad8:	c0 70       	breq	8000bae6 <__sfvwrite_r+0x36>
8000bada:	8e 68       	ld.sh	r8,r7[0xc]
8000badc:	a7 a8       	sbr	r8,0x6
8000bade:	ae 68       	st.h	r7[0xc],r8
8000bae0:	30 98       	mov	r8,9
8000bae2:	8b 38       	st.w	r5[0xc],r8
8000bae4:	c2 b9       	rjmp	8000bd3a <__sfvwrite_r+0x28a>
8000bae6:	8e 63       	ld.sh	r3,r7[0xc]
8000bae8:	68 00       	ld.w	r0,r4[0x0]
8000baea:	06 96       	mov	r6,r3
8000baec:	e2 16 00 02 	andl	r6,0x2,COH
8000baf0:	c2 10       	breq	8000bb32 <__sfvwrite_r+0x82>
8000baf2:	30 03       	mov	r3,0
8000baf4:	e0 62 04 00 	mov	r2,1024
8000baf8:	06 96       	mov	r6,r3
8000bafa:	c0 48       	rjmp	8000bb02 <__sfvwrite_r+0x52>
8000bafc:	60 03       	ld.w	r3,r0[0x0]
8000bafe:	60 16       	ld.w	r6,r0[0x4]
8000bb00:	2f 80       	sub	r0,-8
8000bb02:	58 06       	cp.w	r6,0
8000bb04:	cf c0       	breq	8000bafc <__sfvwrite_r+0x4c>
8000bb06:	e0 46 04 00 	cp.w	r6,1024
8000bb0a:	ec 09 17 80 	movls	r9,r6
8000bb0e:	e4 09 17 b0 	movhi	r9,r2
8000bb12:	06 9a       	mov	r10,r3
8000bb14:	6e a8       	ld.w	r8,r7[0x28]
8000bb16:	6e 8b       	ld.w	r11,r7[0x20]
8000bb18:	0a 9c       	mov	r12,r5
8000bb1a:	5d 18       	icall	r8
8000bb1c:	18 16       	sub	r6,r12
8000bb1e:	58 0c       	cp.w	r12,0
8000bb20:	e0 8a 01 0a 	brle	8000bd34 <__sfvwrite_r+0x284>
8000bb24:	68 28       	ld.w	r8,r4[0x8]
8000bb26:	18 18       	sub	r8,r12
8000bb28:	89 28       	st.w	r4[0x8],r8
8000bb2a:	e0 80 01 0a 	breq	8000bd3e <__sfvwrite_r+0x28e>
8000bb2e:	18 03       	add	r3,r12
8000bb30:	ce 9b       	rjmp	8000bb02 <__sfvwrite_r+0x52>
8000bb32:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000bb36:	c0 70       	breq	8000bb44 <__sfvwrite_r+0x94>
8000bb38:	50 06       	stdsp	sp[0x0],r6
8000bb3a:	0c 93       	mov	r3,r6
8000bb3c:	0c 91       	mov	r1,r6
8000bb3e:	50 15       	stdsp	sp[0x4],r5
8000bb40:	08 92       	mov	r2,r4
8000bb42:	c9 c8       	rjmp	8000bc7a <__sfvwrite_r+0x1ca>
8000bb44:	06 96       	mov	r6,r3
8000bb46:	08 91       	mov	r1,r4
8000bb48:	c0 48       	rjmp	8000bb50 <__sfvwrite_r+0xa0>
8000bb4a:	60 03       	ld.w	r3,r0[0x0]
8000bb4c:	60 16       	ld.w	r6,r0[0x4]
8000bb4e:	2f 80       	sub	r0,-8
8000bb50:	58 06       	cp.w	r6,0
8000bb52:	cf c0       	breq	8000bb4a <__sfvwrite_r+0x9a>
8000bb54:	8e 68       	ld.sh	r8,r7[0xc]
8000bb56:	6e 24       	ld.w	r4,r7[0x8]
8000bb58:	10 99       	mov	r9,r8
8000bb5a:	e2 19 02 00 	andl	r9,0x200,COH
8000bb5e:	c5 50       	breq	8000bc08 <__sfvwrite_r+0x158>
8000bb60:	08 36       	cp.w	r6,r4
8000bb62:	c4 43       	brcs	8000bbea <__sfvwrite_r+0x13a>
8000bb64:	10 99       	mov	r9,r8
8000bb66:	e2 19 04 80 	andl	r9,0x480,COH
8000bb6a:	c4 00       	breq	8000bbea <__sfvwrite_r+0x13a>
8000bb6c:	6e 4b       	ld.w	r11,r7[0x10]
8000bb6e:	6e 09       	ld.w	r9,r7[0x0]
8000bb70:	16 19       	sub	r9,r11
8000bb72:	50 09       	stdsp	sp[0x0],r9
8000bb74:	6e 59       	ld.w	r9,r7[0x14]
8000bb76:	10 9c       	mov	r12,r8
8000bb78:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000bb7c:	30 28       	mov	r8,2
8000bb7e:	f4 08 0c 08 	divs	r8,r10,r8
8000bb82:	fa e9 00 04 	st.d	sp[4],r8
8000bb86:	10 94       	mov	r4,r8
8000bb88:	40 09       	lddsp	r9,sp[0x0]
8000bb8a:	e2 1c 04 00 	andl	r12,0x400,COH
8000bb8e:	2f f9       	sub	r9,-1
8000bb90:	0c 09       	add	r9,r6
8000bb92:	12 38       	cp.w	r8,r9
8000bb94:	f2 04 17 30 	movlo	r4,r9
8000bb98:	58 0c       	cp.w	r12,0
8000bb9a:	c1 10       	breq	8000bbbc <__sfvwrite_r+0x10c>
8000bb9c:	08 9b       	mov	r11,r4
8000bb9e:	0a 9c       	mov	r12,r5
8000bba0:	fe b0 e0 6c 	rcall	80007c78 <_malloc_r>
8000bba4:	18 92       	mov	r2,r12
8000bba6:	c1 40       	breq	8000bbce <__sfvwrite_r+0x11e>
8000bba8:	40 0a       	lddsp	r10,sp[0x0]
8000bbaa:	6e 4b       	ld.w	r11,r7[0x10]
8000bbac:	fe b0 e2 82 	rcall	800080b0 <memcpy>
8000bbb0:	8e 68       	ld.sh	r8,r7[0xc]
8000bbb2:	e0 18 fb 7f 	andl	r8,0xfb7f
8000bbb6:	a7 b8       	sbr	r8,0x7
8000bbb8:	ae 68       	st.h	r7[0xc],r8
8000bbba:	c0 d8       	rjmp	8000bbd4 <__sfvwrite_r+0x124>
8000bbbc:	08 9a       	mov	r10,r4
8000bbbe:	0a 9c       	mov	r12,r5
8000bbc0:	fe b0 e3 24 	rcall	80008208 <_realloc_r>
8000bbc4:	18 92       	mov	r2,r12
8000bbc6:	c0 71       	brne	8000bbd4 <__sfvwrite_r+0x124>
8000bbc8:	6e 4b       	ld.w	r11,r7[0x10]
8000bbca:	0a 9c       	mov	r12,r5
8000bbcc:	ca ce       	rcall	8000b924 <_free_r>
8000bbce:	30 c8       	mov	r8,12
8000bbd0:	8b 38       	st.w	r5[0xc],r8
8000bbd2:	cb 18       	rjmp	8000bd34 <__sfvwrite_r+0x284>
8000bbd4:	40 0a       	lddsp	r10,sp[0x0]
8000bbd6:	40 09       	lddsp	r9,sp[0x0]
8000bbd8:	e8 0a 01 0a 	sub	r10,r4,r10
8000bbdc:	e4 09 00 08 	add	r8,r2,r9
8000bbe0:	8f 54       	st.w	r7[0x14],r4
8000bbe2:	8f 2a       	st.w	r7[0x8],r10
8000bbe4:	8f 08       	st.w	r7[0x0],r8
8000bbe6:	8f 42       	st.w	r7[0x10],r2
8000bbe8:	0c 94       	mov	r4,r6
8000bbea:	08 36       	cp.w	r6,r4
8000bbec:	ec 04 17 30 	movlo	r4,r6
8000bbf0:	06 9b       	mov	r11,r3
8000bbf2:	08 9a       	mov	r10,r4
8000bbf4:	6e 0c       	ld.w	r12,r7[0x0]
8000bbf6:	c3 ad       	rcall	8000be6a <memmove>
8000bbf8:	6e 08       	ld.w	r8,r7[0x0]
8000bbfa:	08 08       	add	r8,r4
8000bbfc:	8f 08       	st.w	r7[0x0],r8
8000bbfe:	6e 28       	ld.w	r8,r7[0x8]
8000bc00:	08 18       	sub	r8,r4
8000bc02:	0c 94       	mov	r4,r6
8000bc04:	8f 28       	st.w	r7[0x8],r8
8000bc06:	c2 e8       	rjmp	8000bc62 <__sfvwrite_r+0x1b2>
8000bc08:	08 36       	cp.w	r6,r4
8000bc0a:	5f ba       	srhi	r10
8000bc0c:	6e 0c       	ld.w	r12,r7[0x0]
8000bc0e:	6e 48       	ld.w	r8,r7[0x10]
8000bc10:	10 3c       	cp.w	r12,r8
8000bc12:	5f b8       	srhi	r8
8000bc14:	f5 e8 00 08 	and	r8,r10,r8
8000bc18:	f2 08 18 00 	cp.b	r8,r9
8000bc1c:	c0 d0       	breq	8000bc36 <__sfvwrite_r+0x186>
8000bc1e:	06 9b       	mov	r11,r3
8000bc20:	08 9a       	mov	r10,r4
8000bc22:	c2 4d       	rcall	8000be6a <memmove>
8000bc24:	6e 08       	ld.w	r8,r7[0x0]
8000bc26:	08 08       	add	r8,r4
8000bc28:	0e 9b       	mov	r11,r7
8000bc2a:	8f 08       	st.w	r7[0x0],r8
8000bc2c:	0a 9c       	mov	r12,r5
8000bc2e:	fe b0 fd 09 	rcall	8000b640 <_fflush_r>
8000bc32:	c1 80       	breq	8000bc62 <__sfvwrite_r+0x1b2>
8000bc34:	c8 08       	rjmp	8000bd34 <__sfvwrite_r+0x284>
8000bc36:	6e 59       	ld.w	r9,r7[0x14]
8000bc38:	12 36       	cp.w	r6,r9
8000bc3a:	c0 a3       	brcs	8000bc4e <__sfvwrite_r+0x19e>
8000bc3c:	6e a8       	ld.w	r8,r7[0x28]
8000bc3e:	06 9a       	mov	r10,r3
8000bc40:	6e 8b       	ld.w	r11,r7[0x20]
8000bc42:	0a 9c       	mov	r12,r5
8000bc44:	5d 18       	icall	r8
8000bc46:	18 94       	mov	r4,r12
8000bc48:	e0 89 00 0d 	brgt	8000bc62 <__sfvwrite_r+0x1b2>
8000bc4c:	c7 48       	rjmp	8000bd34 <__sfvwrite_r+0x284>
8000bc4e:	0c 9a       	mov	r10,r6
8000bc50:	06 9b       	mov	r11,r3
8000bc52:	c0 cd       	rcall	8000be6a <memmove>
8000bc54:	6e 08       	ld.w	r8,r7[0x0]
8000bc56:	0c 08       	add	r8,r6
8000bc58:	0c 94       	mov	r4,r6
8000bc5a:	8f 08       	st.w	r7[0x0],r8
8000bc5c:	6e 28       	ld.w	r8,r7[0x8]
8000bc5e:	0c 18       	sub	r8,r6
8000bc60:	8f 28       	st.w	r7[0x8],r8
8000bc62:	62 28       	ld.w	r8,r1[0x8]
8000bc64:	08 18       	sub	r8,r4
8000bc66:	83 28       	st.w	r1[0x8],r8
8000bc68:	c6 b0       	breq	8000bd3e <__sfvwrite_r+0x28e>
8000bc6a:	08 16       	sub	r6,r4
8000bc6c:	08 03       	add	r3,r4
8000bc6e:	c7 1b       	rjmp	8000bb50 <__sfvwrite_r+0xa0>
8000bc70:	60 03       	ld.w	r3,r0[0x0]
8000bc72:	60 11       	ld.w	r1,r0[0x4]
8000bc74:	30 08       	mov	r8,0
8000bc76:	2f 80       	sub	r0,-8
8000bc78:	50 08       	stdsp	sp[0x0],r8
8000bc7a:	58 01       	cp.w	r1,0
8000bc7c:	cf a0       	breq	8000bc70 <__sfvwrite_r+0x1c0>
8000bc7e:	40 0a       	lddsp	r10,sp[0x0]
8000bc80:	58 0a       	cp.w	r10,0
8000bc82:	c1 41       	brne	8000bcaa <__sfvwrite_r+0x1fa>
8000bc84:	e2 c6 ff ff 	sub	r6,r1,-1
8000bc88:	02 9a       	mov	r10,r1
8000bc8a:	30 ab       	mov	r11,10
8000bc8c:	06 9c       	mov	r12,r3
8000bc8e:	ce 3c       	rcall	8000be54 <memchr>
8000bc90:	f8 c8 ff ff 	sub	r8,r12,-1
8000bc94:	58 0c       	cp.w	r12,0
8000bc96:	f1 d3 e1 16 	subne	r6,r8,r3
8000bc9a:	f9 b9 01 01 	movne	r9,1
8000bc9e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bca2:	f9 b8 00 01 	moveq	r8,1
8000bca6:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000bcaa:	02 36       	cp.w	r6,r1
8000bcac:	ec 04 17 80 	movls	r4,r6
8000bcb0:	e2 04 17 b0 	movhi	r4,r1
8000bcb4:	6e 59       	ld.w	r9,r7[0x14]
8000bcb6:	6e 25       	ld.w	r5,r7[0x8]
8000bcb8:	f2 05 00 05 	add	r5,r9,r5
8000bcbc:	0a 34       	cp.w	r4,r5
8000bcbe:	5f 9a       	srgt	r10
8000bcc0:	6e 0c       	ld.w	r12,r7[0x0]
8000bcc2:	6e 48       	ld.w	r8,r7[0x10]
8000bcc4:	10 3c       	cp.w	r12,r8
8000bcc6:	5f b8       	srhi	r8
8000bcc8:	f5 e8 00 08 	and	r8,r10,r8
8000bccc:	30 0a       	mov	r10,0
8000bcce:	f4 08 18 00 	cp.b	r8,r10
8000bcd2:	c0 d0       	breq	8000bcec <__sfvwrite_r+0x23c>
8000bcd4:	06 9b       	mov	r11,r3
8000bcd6:	0a 9a       	mov	r10,r5
8000bcd8:	cc 9c       	rcall	8000be6a <memmove>
8000bcda:	6e 08       	ld.w	r8,r7[0x0]
8000bcdc:	0a 08       	add	r8,r5
8000bcde:	0e 9b       	mov	r11,r7
8000bce0:	8f 08       	st.w	r7[0x0],r8
8000bce2:	40 1c       	lddsp	r12,sp[0x4]
8000bce4:	fe b0 fc ae 	rcall	8000b640 <_fflush_r>
8000bce8:	c1 70       	breq	8000bd16 <__sfvwrite_r+0x266>
8000bcea:	c2 58       	rjmp	8000bd34 <__sfvwrite_r+0x284>
8000bcec:	12 34       	cp.w	r4,r9
8000bcee:	c0 a5       	brlt	8000bd02 <__sfvwrite_r+0x252>
8000bcf0:	6e a8       	ld.w	r8,r7[0x28]
8000bcf2:	06 9a       	mov	r10,r3
8000bcf4:	6e 8b       	ld.w	r11,r7[0x20]
8000bcf6:	40 1c       	lddsp	r12,sp[0x4]
8000bcf8:	5d 18       	icall	r8
8000bcfa:	18 95       	mov	r5,r12
8000bcfc:	e0 89 00 0d 	brgt	8000bd16 <__sfvwrite_r+0x266>
8000bd00:	c1 a8       	rjmp	8000bd34 <__sfvwrite_r+0x284>
8000bd02:	08 9a       	mov	r10,r4
8000bd04:	06 9b       	mov	r11,r3
8000bd06:	cb 2c       	rcall	8000be6a <memmove>
8000bd08:	6e 08       	ld.w	r8,r7[0x0]
8000bd0a:	08 08       	add	r8,r4
8000bd0c:	08 95       	mov	r5,r4
8000bd0e:	8f 08       	st.w	r7[0x0],r8
8000bd10:	6e 28       	ld.w	r8,r7[0x8]
8000bd12:	08 18       	sub	r8,r4
8000bd14:	8f 28       	st.w	r7[0x8],r8
8000bd16:	0a 16       	sub	r6,r5
8000bd18:	c0 71       	brne	8000bd26 <__sfvwrite_r+0x276>
8000bd1a:	0e 9b       	mov	r11,r7
8000bd1c:	40 1c       	lddsp	r12,sp[0x4]
8000bd1e:	fe b0 fc 91 	rcall	8000b640 <_fflush_r>
8000bd22:	c0 91       	brne	8000bd34 <__sfvwrite_r+0x284>
8000bd24:	50 06       	stdsp	sp[0x0],r6
8000bd26:	64 28       	ld.w	r8,r2[0x8]
8000bd28:	0a 18       	sub	r8,r5
8000bd2a:	85 28       	st.w	r2[0x8],r8
8000bd2c:	c0 90       	breq	8000bd3e <__sfvwrite_r+0x28e>
8000bd2e:	0a 11       	sub	r1,r5
8000bd30:	0a 03       	add	r3,r5
8000bd32:	ca 4b       	rjmp	8000bc7a <__sfvwrite_r+0x1ca>
8000bd34:	8e 68       	ld.sh	r8,r7[0xc]
8000bd36:	a7 a8       	sbr	r8,0x6
8000bd38:	ae 68       	st.h	r7[0xc],r8
8000bd3a:	3f fc       	mov	r12,-1
8000bd3c:	c0 28       	rjmp	8000bd40 <__sfvwrite_r+0x290>
8000bd3e:	30 0c       	mov	r12,0
8000bd40:	2f dd       	sub	sp,-12
8000bd42:	d8 32       	popm	r0-r7,pc

8000bd44 <_fwalk>:
8000bd44:	d4 31       	pushm	r0-r7,lr
8000bd46:	30 05       	mov	r5,0
8000bd48:	16 91       	mov	r1,r11
8000bd4a:	f8 c7 ff 28 	sub	r7,r12,-216
8000bd4e:	0a 92       	mov	r2,r5
8000bd50:	fe b0 fc fe 	rcall	8000b74c <__sfp_lock_acquire>
8000bd54:	3f f3       	mov	r3,-1
8000bd56:	c1 68       	rjmp	8000bd82 <_fwalk+0x3e>
8000bd58:	6e 26       	ld.w	r6,r7[0x8]
8000bd5a:	6e 14       	ld.w	r4,r7[0x4]
8000bd5c:	2f 46       	sub	r6,-12
8000bd5e:	c0 c8       	rjmp	8000bd76 <_fwalk+0x32>
8000bd60:	8c 08       	ld.sh	r8,r6[0x0]
8000bd62:	e4 08 19 00 	cp.h	r8,r2
8000bd66:	c0 70       	breq	8000bd74 <_fwalk+0x30>
8000bd68:	8c 18       	ld.sh	r8,r6[0x2]
8000bd6a:	e6 08 19 00 	cp.h	r8,r3
8000bd6e:	c0 30       	breq	8000bd74 <_fwalk+0x30>
8000bd70:	5d 11       	icall	r1
8000bd72:	18 45       	or	r5,r12
8000bd74:	2a 46       	sub	r6,-92
8000bd76:	20 14       	sub	r4,1
8000bd78:	ec cc 00 0c 	sub	r12,r6,12
8000bd7c:	58 04       	cp.w	r4,0
8000bd7e:	cf 14       	brge	8000bd60 <_fwalk+0x1c>
8000bd80:	6e 07       	ld.w	r7,r7[0x0]
8000bd82:	58 07       	cp.w	r7,0
8000bd84:	ce a1       	brne	8000bd58 <_fwalk+0x14>
8000bd86:	fe b0 fc e4 	rcall	8000b74e <__sfp_lock_release>
8000bd8a:	0a 9c       	mov	r12,r5
8000bd8c:	d8 32       	popm	r0-r7,pc
8000bd8e:	d7 03       	nop

8000bd90 <_localeconv_r>:
8000bd90:	fe cc d2 10 	sub	r12,pc,-11760
8000bd94:	5e fc       	retal	r12
8000bd96:	d7 03       	nop

8000bd98 <__smakebuf_r>:
8000bd98:	d4 21       	pushm	r4-r7,lr
8000bd9a:	20 fd       	sub	sp,60
8000bd9c:	96 68       	ld.sh	r8,r11[0xc]
8000bd9e:	16 97       	mov	r7,r11
8000bda0:	18 96       	mov	r6,r12
8000bda2:	e2 18 00 02 	andl	r8,0x2,COH
8000bda6:	c3 d1       	brne	8000be20 <__smakebuf_r+0x88>
8000bda8:	96 7b       	ld.sh	r11,r11[0xe]
8000bdaa:	f0 0b 19 00 	cp.h	r11,r8
8000bdae:	c0 55       	brlt	8000bdb8 <__smakebuf_r+0x20>
8000bdb0:	1a 9a       	mov	r10,sp
8000bdb2:	e0 a0 04 81 	rcall	8000c6b4 <_fstat_r>
8000bdb6:	c0 f4       	brge	8000bdd4 <__smakebuf_r+0x3c>
8000bdb8:	8e 65       	ld.sh	r5,r7[0xc]
8000bdba:	0a 98       	mov	r8,r5
8000bdbc:	ab b8       	sbr	r8,0xb
8000bdbe:	e2 15 00 80 	andl	r5,0x80,COH
8000bdc2:	ae 68       	st.h	r7[0xc],r8
8000bdc4:	30 04       	mov	r4,0
8000bdc6:	e0 68 04 00 	mov	r8,1024
8000bdca:	f9 b5 01 40 	movne	r5,64
8000bdce:	f0 05 17 00 	moveq	r5,r8
8000bdd2:	c1 c8       	rjmp	8000be0a <__smakebuf_r+0x72>
8000bdd4:	40 18       	lddsp	r8,sp[0x4]
8000bdd6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000bdda:	e0 48 20 00 	cp.w	r8,8192
8000bdde:	5f 04       	sreq	r4
8000bde0:	e0 48 80 00 	cp.w	r8,32768
8000bde4:	c0 e1       	brne	8000be00 <__smakebuf_r+0x68>
8000bde6:	6e b9       	ld.w	r9,r7[0x2c]
8000bde8:	fe c8 f9 1c 	sub	r8,pc,-1764
8000bdec:	10 39       	cp.w	r9,r8
8000bdee:	c0 91       	brne	8000be00 <__smakebuf_r+0x68>
8000bdf0:	8e 68       	ld.sh	r8,r7[0xc]
8000bdf2:	e0 65 04 00 	mov	r5,1024
8000bdf6:	ab a8       	sbr	r8,0xa
8000bdf8:	ef 45 00 50 	st.w	r7[80],r5
8000bdfc:	ae 68       	st.h	r7[0xc],r8
8000bdfe:	c0 68       	rjmp	8000be0a <__smakebuf_r+0x72>
8000be00:	8e 68       	ld.sh	r8,r7[0xc]
8000be02:	e0 65 04 00 	mov	r5,1024
8000be06:	ab b8       	sbr	r8,0xb
8000be08:	ae 68       	st.h	r7[0xc],r8
8000be0a:	0a 9b       	mov	r11,r5
8000be0c:	0c 9c       	mov	r12,r6
8000be0e:	fe b0 df 35 	rcall	80007c78 <_malloc_r>
8000be12:	8e 68       	ld.sh	r8,r7[0xc]
8000be14:	c0 d1       	brne	8000be2e <__smakebuf_r+0x96>
8000be16:	ed b8 00 09 	bld	r8,0x9
8000be1a:	c1 b0       	breq	8000be50 <__smakebuf_r+0xb8>
8000be1c:	a1 b8       	sbr	r8,0x1
8000be1e:	ae 68       	st.h	r7[0xc],r8
8000be20:	ee c8 ff b9 	sub	r8,r7,-71
8000be24:	8f 48       	st.w	r7[0x10],r8
8000be26:	8f 08       	st.w	r7[0x0],r8
8000be28:	30 18       	mov	r8,1
8000be2a:	8f 58       	st.w	r7[0x14],r8
8000be2c:	c1 28       	rjmp	8000be50 <__smakebuf_r+0xb8>
8000be2e:	a7 b8       	sbr	r8,0x7
8000be30:	8f 4c       	st.w	r7[0x10],r12
8000be32:	ae 68       	st.h	r7[0xc],r8
8000be34:	8f 55       	st.w	r7[0x14],r5
8000be36:	fe c8 06 e6 	sub	r8,pc,1766
8000be3a:	8f 0c       	st.w	r7[0x0],r12
8000be3c:	8d a8       	st.w	r6[0x28],r8
8000be3e:	58 04       	cp.w	r4,0
8000be40:	c0 80       	breq	8000be50 <__smakebuf_r+0xb8>
8000be42:	8e 7c       	ld.sh	r12,r7[0xe]
8000be44:	fe b0 e3 94 	rcall	8000856c <isatty>
8000be48:	c0 40       	breq	8000be50 <__smakebuf_r+0xb8>
8000be4a:	8e 68       	ld.sh	r8,r7[0xc]
8000be4c:	a1 a8       	sbr	r8,0x0
8000be4e:	ae 68       	st.h	r7[0xc],r8
8000be50:	2f 1d       	sub	sp,-60
8000be52:	d8 22       	popm	r4-r7,pc

8000be54 <memchr>:
8000be54:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000be58:	c0 68       	rjmp	8000be64 <memchr+0x10>
8000be5a:	20 1a       	sub	r10,1
8000be5c:	19 88       	ld.ub	r8,r12[0x0]
8000be5e:	16 38       	cp.w	r8,r11
8000be60:	5e 0c       	reteq	r12
8000be62:	2f fc       	sub	r12,-1
8000be64:	58 0a       	cp.w	r10,0
8000be66:	cf a1       	brne	8000be5a <memchr+0x6>
8000be68:	5e fa       	retal	r10

8000be6a <memmove>:
8000be6a:	d4 01       	pushm	lr
8000be6c:	18 3b       	cp.w	r11,r12
8000be6e:	c1 92       	brcc	8000bea0 <memmove+0x36>
8000be70:	f6 0a 00 09 	add	r9,r11,r10
8000be74:	12 3c       	cp.w	r12,r9
8000be76:	c1 52       	brcc	8000bea0 <memmove+0x36>
8000be78:	f8 0a 00 0b 	add	r11,r12,r10
8000be7c:	30 08       	mov	r8,0
8000be7e:	c0 68       	rjmp	8000be8a <memmove+0x20>
8000be80:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000be84:	20 1a       	sub	r10,1
8000be86:	f6 08 0b 0e 	st.b	r11[r8],lr
8000be8a:	20 18       	sub	r8,1
8000be8c:	58 0a       	cp.w	r10,0
8000be8e:	cf 91       	brne	8000be80 <memmove+0x16>
8000be90:	d8 02       	popm	pc
8000be92:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000be96:	20 1a       	sub	r10,1
8000be98:	f8 08 0b 09 	st.b	r12[r8],r9
8000be9c:	2f f8       	sub	r8,-1
8000be9e:	c0 28       	rjmp	8000bea2 <memmove+0x38>
8000bea0:	30 08       	mov	r8,0
8000bea2:	58 0a       	cp.w	r10,0
8000bea4:	cf 71       	brne	8000be92 <memmove+0x28>
8000bea6:	d8 02       	popm	pc

8000bea8 <__hi0bits>:
8000bea8:	18 98       	mov	r8,r12
8000beaa:	e0 1c 00 00 	andl	r12,0x0
8000beae:	f0 09 15 10 	lsl	r9,r8,0x10
8000beb2:	58 0c       	cp.w	r12,0
8000beb4:	f2 08 17 00 	moveq	r8,r9
8000beb8:	f9 bc 00 10 	moveq	r12,16
8000bebc:	f9 bc 01 00 	movne	r12,0
8000bec0:	10 9a       	mov	r10,r8
8000bec2:	f0 09 15 08 	lsl	r9,r8,0x8
8000bec6:	e6 1a ff 00 	andh	r10,0xff00,COH
8000beca:	f7 bc 00 f8 	subeq	r12,-8
8000bece:	f2 08 17 00 	moveq	r8,r9
8000bed2:	10 9a       	mov	r10,r8
8000bed4:	f0 09 15 04 	lsl	r9,r8,0x4
8000bed8:	e6 1a f0 00 	andh	r10,0xf000,COH
8000bedc:	f7 bc 00 fc 	subeq	r12,-4
8000bee0:	f2 08 17 00 	moveq	r8,r9
8000bee4:	10 9a       	mov	r10,r8
8000bee6:	f0 09 15 02 	lsl	r9,r8,0x2
8000beea:	e6 1a c0 00 	andh	r10,0xc000,COH
8000beee:	f7 bc 00 fe 	subeq	r12,-2
8000bef2:	f2 08 17 00 	moveq	r8,r9
8000bef6:	58 08       	cp.w	r8,0
8000bef8:	5e 5c       	retlt	r12
8000befa:	ed b8 00 1e 	bld	r8,0x1e
8000befe:	f9 bc 01 20 	movne	r12,32
8000bf02:	f7 bc 00 ff 	subeq	r12,-1
8000bf06:	5e fc       	retal	r12

8000bf08 <__lo0bits>:
8000bf08:	18 99       	mov	r9,r12
8000bf0a:	78 08       	ld.w	r8,r12[0x0]
8000bf0c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000bf10:	c1 50       	breq	8000bf3a <__lo0bits+0x32>
8000bf12:	ed b8 00 00 	bld	r8,0x0
8000bf16:	c0 21       	brne	8000bf1a <__lo0bits+0x12>
8000bf18:	5e fd       	retal	0
8000bf1a:	10 9b       	mov	r11,r8
8000bf1c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000bf20:	e2 1b 00 02 	andl	r11,0x2,COH
8000bf24:	a3 88       	lsr	r8,0x2
8000bf26:	58 0b       	cp.w	r11,0
8000bf28:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000bf2c:	f9 bc 01 01 	movne	r12,1
8000bf30:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000bf34:	f9 bc 00 02 	moveq	r12,2
8000bf38:	5e fc       	retal	r12
8000bf3a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000bf3e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bf42:	58 0a       	cp.w	r10,0
8000bf44:	f6 08 17 00 	moveq	r8,r11
8000bf48:	f9 bc 00 10 	moveq	r12,16
8000bf4c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000bf50:	f0 0a 16 08 	lsr	r10,r8,0x8
8000bf54:	58 0b       	cp.w	r11,0
8000bf56:	f7 bc 00 f8 	subeq	r12,-8
8000bf5a:	f4 08 17 00 	moveq	r8,r10
8000bf5e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000bf62:	f0 0a 16 04 	lsr	r10,r8,0x4
8000bf66:	58 0b       	cp.w	r11,0
8000bf68:	f7 bc 00 fc 	subeq	r12,-4
8000bf6c:	f4 08 17 00 	moveq	r8,r10
8000bf70:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000bf74:	f0 0a 16 02 	lsr	r10,r8,0x2
8000bf78:	58 0b       	cp.w	r11,0
8000bf7a:	f7 bc 00 fe 	subeq	r12,-2
8000bf7e:	f4 08 17 00 	moveq	r8,r10
8000bf82:	ed b8 00 00 	bld	r8,0x0
8000bf86:	c0 60       	breq	8000bf92 <__lo0bits+0x8a>
8000bf88:	a1 98       	lsr	r8,0x1
8000bf8a:	c0 31       	brne	8000bf90 <__lo0bits+0x88>
8000bf8c:	32 0c       	mov	r12,32
8000bf8e:	5e fc       	retal	r12
8000bf90:	2f fc       	sub	r12,-1
8000bf92:	93 08       	st.w	r9[0x0],r8
8000bf94:	5e fc       	retal	r12

8000bf96 <__mcmp>:
8000bf96:	d4 01       	pushm	lr
8000bf98:	18 98       	mov	r8,r12
8000bf9a:	76 49       	ld.w	r9,r11[0x10]
8000bf9c:	78 4c       	ld.w	r12,r12[0x10]
8000bf9e:	12 1c       	sub	r12,r9
8000bfa0:	c1 31       	brne	8000bfc6 <__mcmp+0x30>
8000bfa2:	2f b9       	sub	r9,-5
8000bfa4:	a3 69       	lsl	r9,0x2
8000bfa6:	12 0b       	add	r11,r9
8000bfa8:	f0 09 00 09 	add	r9,r8,r9
8000bfac:	2e c8       	sub	r8,-20
8000bfae:	13 4e       	ld.w	lr,--r9
8000bfb0:	17 4a       	ld.w	r10,--r11
8000bfb2:	14 3e       	cp.w	lr,r10
8000bfb4:	c0 60       	breq	8000bfc0 <__mcmp+0x2a>
8000bfb6:	f9 bc 03 ff 	movlo	r12,-1
8000bfba:	f9 bc 02 01 	movhs	r12,1
8000bfbe:	d8 02       	popm	pc
8000bfc0:	10 39       	cp.w	r9,r8
8000bfc2:	fe 9b ff f6 	brhi	8000bfae <__mcmp+0x18>
8000bfc6:	d8 02       	popm	pc

8000bfc8 <_Bfree>:
8000bfc8:	d4 21       	pushm	r4-r7,lr
8000bfca:	18 97       	mov	r7,r12
8000bfcc:	16 95       	mov	r5,r11
8000bfce:	78 96       	ld.w	r6,r12[0x24]
8000bfd0:	58 06       	cp.w	r6,0
8000bfd2:	c0 91       	brne	8000bfe4 <_Bfree+0x1c>
8000bfd4:	31 0c       	mov	r12,16
8000bfd6:	fe b0 de 49 	rcall	80007c68 <malloc>
8000bfda:	99 36       	st.w	r12[0xc],r6
8000bfdc:	8f 9c       	st.w	r7[0x24],r12
8000bfde:	99 16       	st.w	r12[0x4],r6
8000bfe0:	99 26       	st.w	r12[0x8],r6
8000bfe2:	99 06       	st.w	r12[0x0],r6
8000bfe4:	58 05       	cp.w	r5,0
8000bfe6:	c0 90       	breq	8000bff8 <_Bfree+0x30>
8000bfe8:	6a 19       	ld.w	r9,r5[0x4]
8000bfea:	6e 98       	ld.w	r8,r7[0x24]
8000bfec:	70 38       	ld.w	r8,r8[0xc]
8000bfee:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000bff2:	8b 0a       	st.w	r5[0x0],r10
8000bff4:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000bff8:	d8 22       	popm	r4-r7,pc
8000bffa:	d7 03       	nop

8000bffc <_Balloc>:
8000bffc:	d4 21       	pushm	r4-r7,lr
8000bffe:	18 97       	mov	r7,r12
8000c000:	16 96       	mov	r6,r11
8000c002:	78 95       	ld.w	r5,r12[0x24]
8000c004:	58 05       	cp.w	r5,0
8000c006:	c0 91       	brne	8000c018 <_Balloc+0x1c>
8000c008:	31 0c       	mov	r12,16
8000c00a:	fe b0 de 2f 	rcall	80007c68 <malloc>
8000c00e:	99 35       	st.w	r12[0xc],r5
8000c010:	8f 9c       	st.w	r7[0x24],r12
8000c012:	99 15       	st.w	r12[0x4],r5
8000c014:	99 25       	st.w	r12[0x8],r5
8000c016:	99 05       	st.w	r12[0x0],r5
8000c018:	6e 95       	ld.w	r5,r7[0x24]
8000c01a:	6a 38       	ld.w	r8,r5[0xc]
8000c01c:	58 08       	cp.w	r8,0
8000c01e:	c0 b1       	brne	8000c034 <_Balloc+0x38>
8000c020:	31 0a       	mov	r10,16
8000c022:	30 4b       	mov	r11,4
8000c024:	0e 9c       	mov	r12,r7
8000c026:	e0 a0 02 a7 	rcall	8000c574 <_calloc_r>
8000c02a:	8b 3c       	st.w	r5[0xc],r12
8000c02c:	6e 98       	ld.w	r8,r7[0x24]
8000c02e:	70 3c       	ld.w	r12,r8[0xc]
8000c030:	58 0c       	cp.w	r12,0
8000c032:	c1 b0       	breq	8000c068 <_Balloc+0x6c>
8000c034:	6e 98       	ld.w	r8,r7[0x24]
8000c036:	70 38       	ld.w	r8,r8[0xc]
8000c038:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c03c:	70 0c       	ld.w	r12,r8[0x0]
8000c03e:	58 0c       	cp.w	r12,0
8000c040:	c0 40       	breq	8000c048 <_Balloc+0x4c>
8000c042:	78 09       	ld.w	r9,r12[0x0]
8000c044:	91 09       	st.w	r8[0x0],r9
8000c046:	c0 e8       	rjmp	8000c062 <_Balloc+0x66>
8000c048:	0e 9c       	mov	r12,r7
8000c04a:	30 17       	mov	r7,1
8000c04c:	0e 9b       	mov	r11,r7
8000c04e:	ee 06 09 47 	lsl	r7,r7,r6
8000c052:	ee ca ff fb 	sub	r10,r7,-5
8000c056:	a3 6a       	lsl	r10,0x2
8000c058:	e0 a0 02 8e 	rcall	8000c574 <_calloc_r>
8000c05c:	c0 60       	breq	8000c068 <_Balloc+0x6c>
8000c05e:	99 16       	st.w	r12[0x4],r6
8000c060:	99 27       	st.w	r12[0x8],r7
8000c062:	30 08       	mov	r8,0
8000c064:	99 38       	st.w	r12[0xc],r8
8000c066:	99 48       	st.w	r12[0x10],r8
8000c068:	d8 22       	popm	r4-r7,pc
8000c06a:	d7 03       	nop

8000c06c <__d2b>:
8000c06c:	d4 31       	pushm	r0-r7,lr
8000c06e:	20 2d       	sub	sp,8
8000c070:	16 93       	mov	r3,r11
8000c072:	12 96       	mov	r6,r9
8000c074:	10 95       	mov	r5,r8
8000c076:	14 92       	mov	r2,r10
8000c078:	30 1b       	mov	r11,1
8000c07a:	cc 1f       	rcall	8000bffc <_Balloc>
8000c07c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c080:	50 09       	stdsp	sp[0x0],r9
8000c082:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c086:	b5 a9       	sbr	r9,0x14
8000c088:	f0 01 16 14 	lsr	r1,r8,0x14
8000c08c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c090:	18 94       	mov	r4,r12
8000c092:	58 02       	cp.w	r2,0
8000c094:	c1 d0       	breq	8000c0ce <__d2b+0x62>
8000c096:	fa cc ff f8 	sub	r12,sp,-8
8000c09a:	18 d2       	st.w	--r12,r2
8000c09c:	c3 6f       	rcall	8000bf08 <__lo0bits>
8000c09e:	40 18       	lddsp	r8,sp[0x4]
8000c0a0:	c0 d0       	breq	8000c0ba <__d2b+0x4e>
8000c0a2:	40 09       	lddsp	r9,sp[0x0]
8000c0a4:	f8 0a 11 20 	rsub	r10,r12,32
8000c0a8:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c0ac:	f5 e8 10 08 	or	r8,r10,r8
8000c0b0:	89 58       	st.w	r4[0x14],r8
8000c0b2:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c0b6:	50 09       	stdsp	sp[0x0],r9
8000c0b8:	c0 28       	rjmp	8000c0bc <__d2b+0x50>
8000c0ba:	89 58       	st.w	r4[0x14],r8
8000c0bc:	40 08       	lddsp	r8,sp[0x0]
8000c0be:	58 08       	cp.w	r8,0
8000c0c0:	f9 b3 01 02 	movne	r3,2
8000c0c4:	f9 b3 00 01 	moveq	r3,1
8000c0c8:	89 68       	st.w	r4[0x18],r8
8000c0ca:	89 43       	st.w	r4[0x10],r3
8000c0cc:	c0 88       	rjmp	8000c0dc <__d2b+0x70>
8000c0ce:	1a 9c       	mov	r12,sp
8000c0d0:	c1 cf       	rcall	8000bf08 <__lo0bits>
8000c0d2:	30 13       	mov	r3,1
8000c0d4:	40 08       	lddsp	r8,sp[0x0]
8000c0d6:	2e 0c       	sub	r12,-32
8000c0d8:	89 43       	st.w	r4[0x10],r3
8000c0da:	89 58       	st.w	r4[0x14],r8
8000c0dc:	58 01       	cp.w	r1,0
8000c0de:	c0 90       	breq	8000c0f0 <__d2b+0x84>
8000c0e0:	e2 c1 04 33 	sub	r1,r1,1075
8000c0e4:	18 01       	add	r1,r12
8000c0e6:	8d 01       	st.w	r6[0x0],r1
8000c0e8:	f8 0c 11 35 	rsub	r12,r12,53
8000c0ec:	8b 0c       	st.w	r5[0x0],r12
8000c0ee:	c0 c8       	rjmp	8000c106 <__d2b+0x9a>
8000c0f0:	e6 c8 ff fc 	sub	r8,r3,-4
8000c0f4:	f8 cc 04 32 	sub	r12,r12,1074
8000c0f8:	a5 73       	lsl	r3,0x5
8000c0fa:	8d 0c       	st.w	r6[0x0],r12
8000c0fc:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c100:	cd 4e       	rcall	8000bea8 <__hi0bits>
8000c102:	18 13       	sub	r3,r12
8000c104:	8b 03       	st.w	r5[0x0],r3
8000c106:	08 9c       	mov	r12,r4
8000c108:	2f ed       	sub	sp,-8
8000c10a:	d8 32       	popm	r0-r7,pc

8000c10c <__mdiff>:
8000c10c:	d4 31       	pushm	r0-r7,lr
8000c10e:	74 48       	ld.w	r8,r10[0x10]
8000c110:	76 45       	ld.w	r5,r11[0x10]
8000c112:	16 97       	mov	r7,r11
8000c114:	14 96       	mov	r6,r10
8000c116:	10 15       	sub	r5,r8
8000c118:	c1 31       	brne	8000c13e <__mdiff+0x32>
8000c11a:	2f b8       	sub	r8,-5
8000c11c:	ee ce ff ec 	sub	lr,r7,-20
8000c120:	a3 68       	lsl	r8,0x2
8000c122:	f4 08 00 0b 	add	r11,r10,r8
8000c126:	ee 08 00 08 	add	r8,r7,r8
8000c12a:	11 4a       	ld.w	r10,--r8
8000c12c:	17 49       	ld.w	r9,--r11
8000c12e:	12 3a       	cp.w	r10,r9
8000c130:	c0 30       	breq	8000c136 <__mdiff+0x2a>
8000c132:	c0 e2       	brcc	8000c14e <__mdiff+0x42>
8000c134:	c0 78       	rjmp	8000c142 <__mdiff+0x36>
8000c136:	1c 38       	cp.w	r8,lr
8000c138:	fe 9b ff f9 	brhi	8000c12a <__mdiff+0x1e>
8000c13c:	c4 98       	rjmp	8000c1ce <__mdiff+0xc2>
8000c13e:	58 05       	cp.w	r5,0
8000c140:	c0 64       	brge	8000c14c <__mdiff+0x40>
8000c142:	0e 98       	mov	r8,r7
8000c144:	30 15       	mov	r5,1
8000c146:	0c 97       	mov	r7,r6
8000c148:	10 96       	mov	r6,r8
8000c14a:	c0 28       	rjmp	8000c14e <__mdiff+0x42>
8000c14c:	30 05       	mov	r5,0
8000c14e:	6e 1b       	ld.w	r11,r7[0x4]
8000c150:	c5 6f       	rcall	8000bffc <_Balloc>
8000c152:	6e 49       	ld.w	r9,r7[0x10]
8000c154:	6c 44       	ld.w	r4,r6[0x10]
8000c156:	99 35       	st.w	r12[0xc],r5
8000c158:	2f b4       	sub	r4,-5
8000c15a:	f2 c5 ff fb 	sub	r5,r9,-5
8000c15e:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c162:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c166:	2e c6       	sub	r6,-20
8000c168:	2e c7       	sub	r7,-20
8000c16a:	f8 c8 ff ec 	sub	r8,r12,-20
8000c16e:	30 0a       	mov	r10,0
8000c170:	0f 0e       	ld.w	lr,r7++
8000c172:	0d 0b       	ld.w	r11,r6++
8000c174:	fc 02 16 10 	lsr	r2,lr,0x10
8000c178:	f6 03 16 10 	lsr	r3,r11,0x10
8000c17c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c180:	e4 03 01 03 	sub	r3,r2,r3
8000c184:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c188:	fc 0b 01 0b 	sub	r11,lr,r11
8000c18c:	f6 0a 00 0a 	add	r10,r11,r10
8000c190:	b0 1a       	st.h	r8[0x2],r10
8000c192:	b1 4a       	asr	r10,0x10
8000c194:	e6 0a 00 0a 	add	r10,r3,r10
8000c198:	b0 0a       	st.h	r8[0x0],r10
8000c19a:	2f c8       	sub	r8,-4
8000c19c:	b1 4a       	asr	r10,0x10
8000c19e:	08 36       	cp.w	r6,r4
8000c1a0:	ce 83       	brcs	8000c170 <__mdiff+0x64>
8000c1a2:	c0 d8       	rjmp	8000c1bc <__mdiff+0xb0>
8000c1a4:	0f 0b       	ld.w	r11,r7++
8000c1a6:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c1aa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c1ae:	16 0a       	add	r10,r11
8000c1b0:	b0 1a       	st.h	r8[0x2],r10
8000c1b2:	b1 4a       	asr	r10,0x10
8000c1b4:	1c 0a       	add	r10,lr
8000c1b6:	b0 0a       	st.h	r8[0x0],r10
8000c1b8:	2f c8       	sub	r8,-4
8000c1ba:	b1 4a       	asr	r10,0x10
8000c1bc:	0a 37       	cp.w	r7,r5
8000c1be:	cf 33       	brcs	8000c1a4 <__mdiff+0x98>
8000c1c0:	c0 28       	rjmp	8000c1c4 <__mdiff+0xb8>
8000c1c2:	20 19       	sub	r9,1
8000c1c4:	11 4a       	ld.w	r10,--r8
8000c1c6:	58 0a       	cp.w	r10,0
8000c1c8:	cf d0       	breq	8000c1c2 <__mdiff+0xb6>
8000c1ca:	99 49       	st.w	r12[0x10],r9
8000c1cc:	d8 32       	popm	r0-r7,pc
8000c1ce:	30 0b       	mov	r11,0
8000c1d0:	c1 6f       	rcall	8000bffc <_Balloc>
8000c1d2:	30 18       	mov	r8,1
8000c1d4:	99 48       	st.w	r12[0x10],r8
8000c1d6:	30 08       	mov	r8,0
8000c1d8:	99 58       	st.w	r12[0x14],r8
8000c1da:	d8 32       	popm	r0-r7,pc

8000c1dc <__lshift>:
8000c1dc:	d4 31       	pushm	r0-r7,lr
8000c1de:	16 97       	mov	r7,r11
8000c1e0:	76 46       	ld.w	r6,r11[0x10]
8000c1e2:	f4 02 14 05 	asr	r2,r10,0x5
8000c1e6:	2f f6       	sub	r6,-1
8000c1e8:	14 93       	mov	r3,r10
8000c1ea:	18 94       	mov	r4,r12
8000c1ec:	04 06       	add	r6,r2
8000c1ee:	76 1b       	ld.w	r11,r11[0x4]
8000c1f0:	6e 28       	ld.w	r8,r7[0x8]
8000c1f2:	c0 38       	rjmp	8000c1f8 <__lshift+0x1c>
8000c1f4:	2f fb       	sub	r11,-1
8000c1f6:	a1 78       	lsl	r8,0x1
8000c1f8:	10 36       	cp.w	r6,r8
8000c1fa:	fe 99 ff fd 	brgt	8000c1f4 <__lshift+0x18>
8000c1fe:	08 9c       	mov	r12,r4
8000c200:	cf ee       	rcall	8000bffc <_Balloc>
8000c202:	30 09       	mov	r9,0
8000c204:	18 95       	mov	r5,r12
8000c206:	f8 c8 ff ec 	sub	r8,r12,-20
8000c20a:	12 9a       	mov	r10,r9
8000c20c:	c0 38       	rjmp	8000c212 <__lshift+0x36>
8000c20e:	10 aa       	st.w	r8++,r10
8000c210:	2f f9       	sub	r9,-1
8000c212:	04 39       	cp.w	r9,r2
8000c214:	cf d5       	brlt	8000c20e <__lshift+0x32>
8000c216:	6e 4b       	ld.w	r11,r7[0x10]
8000c218:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c21c:	2f bb       	sub	r11,-5
8000c21e:	ee c9 ff ec 	sub	r9,r7,-20
8000c222:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c226:	58 03       	cp.w	r3,0
8000c228:	c1 30       	breq	8000c24e <__lshift+0x72>
8000c22a:	e6 0c 11 20 	rsub	r12,r3,32
8000c22e:	30 0a       	mov	r10,0
8000c230:	72 02       	ld.w	r2,r9[0x0]
8000c232:	e4 03 09 42 	lsl	r2,r2,r3
8000c236:	04 4a       	or	r10,r2
8000c238:	10 aa       	st.w	r8++,r10
8000c23a:	13 0a       	ld.w	r10,r9++
8000c23c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c240:	16 39       	cp.w	r9,r11
8000c242:	cf 73       	brcs	8000c230 <__lshift+0x54>
8000c244:	91 0a       	st.w	r8[0x0],r10
8000c246:	58 0a       	cp.w	r10,0
8000c248:	c0 70       	breq	8000c256 <__lshift+0x7a>
8000c24a:	2f f6       	sub	r6,-1
8000c24c:	c0 58       	rjmp	8000c256 <__lshift+0x7a>
8000c24e:	13 0a       	ld.w	r10,r9++
8000c250:	10 aa       	st.w	r8++,r10
8000c252:	16 39       	cp.w	r9,r11
8000c254:	cf d3       	brcs	8000c24e <__lshift+0x72>
8000c256:	08 9c       	mov	r12,r4
8000c258:	20 16       	sub	r6,1
8000c25a:	0e 9b       	mov	r11,r7
8000c25c:	8b 46       	st.w	r5[0x10],r6
8000c25e:	cb 5e       	rcall	8000bfc8 <_Bfree>
8000c260:	0a 9c       	mov	r12,r5
8000c262:	d8 32       	popm	r0-r7,pc

8000c264 <__multiply>:
8000c264:	d4 31       	pushm	r0-r7,lr
8000c266:	20 2d       	sub	sp,8
8000c268:	76 49       	ld.w	r9,r11[0x10]
8000c26a:	74 48       	ld.w	r8,r10[0x10]
8000c26c:	16 96       	mov	r6,r11
8000c26e:	14 95       	mov	r5,r10
8000c270:	10 39       	cp.w	r9,r8
8000c272:	ec 08 17 50 	movlt	r8,r6
8000c276:	ea 06 17 50 	movlt	r6,r5
8000c27a:	f0 05 17 50 	movlt	r5,r8
8000c27e:	6c 28       	ld.w	r8,r6[0x8]
8000c280:	76 43       	ld.w	r3,r11[0x10]
8000c282:	74 42       	ld.w	r2,r10[0x10]
8000c284:	76 1b       	ld.w	r11,r11[0x4]
8000c286:	e4 03 00 07 	add	r7,r2,r3
8000c28a:	10 37       	cp.w	r7,r8
8000c28c:	f7 bb 09 ff 	subgt	r11,-1
8000c290:	cb 6e       	rcall	8000bffc <_Balloc>
8000c292:	ee c4 ff fb 	sub	r4,r7,-5
8000c296:	f8 c9 ff ec 	sub	r9,r12,-20
8000c29a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c29e:	30 0a       	mov	r10,0
8000c2a0:	12 98       	mov	r8,r9
8000c2a2:	c0 28       	rjmp	8000c2a6 <__multiply+0x42>
8000c2a4:	10 aa       	st.w	r8++,r10
8000c2a6:	08 38       	cp.w	r8,r4
8000c2a8:	cf e3       	brcs	8000c2a4 <__multiply+0x40>
8000c2aa:	2f b3       	sub	r3,-5
8000c2ac:	2f b2       	sub	r2,-5
8000c2ae:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c2b2:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c2b6:	ec cb ff ec 	sub	r11,r6,-20
8000c2ba:	50 12       	stdsp	sp[0x4],r2
8000c2bc:	ea ca ff ec 	sub	r10,r5,-20
8000c2c0:	c4 48       	rjmp	8000c348 <__multiply+0xe4>
8000c2c2:	94 95       	ld.uh	r5,r10[0x2]
8000c2c4:	58 05       	cp.w	r5,0
8000c2c6:	c2 00       	breq	8000c306 <__multiply+0xa2>
8000c2c8:	12 98       	mov	r8,r9
8000c2ca:	16 96       	mov	r6,r11
8000c2cc:	30 0e       	mov	lr,0
8000c2ce:	50 09       	stdsp	sp[0x0],r9
8000c2d0:	0d 02       	ld.w	r2,r6++
8000c2d2:	e4 00 16 10 	lsr	r0,r2,0x10
8000c2d6:	70 01       	ld.w	r1,r8[0x0]
8000c2d8:	70 09       	ld.w	r9,r8[0x0]
8000c2da:	b1 81       	lsr	r1,0x10
8000c2dc:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c2e0:	e0 05 03 41 	mac	r1,r0,r5
8000c2e4:	ab 32       	mul	r2,r5
8000c2e6:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c2ea:	00 02       	add	r2,r0
8000c2ec:	e4 0e 00 0e 	add	lr,r2,lr
8000c2f0:	b0 1e       	st.h	r8[0x2],lr
8000c2f2:	b1 8e       	lsr	lr,0x10
8000c2f4:	1c 01       	add	r1,lr
8000c2f6:	b0 01       	st.h	r8[0x0],r1
8000c2f8:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c2fc:	2f c8       	sub	r8,-4
8000c2fe:	06 36       	cp.w	r6,r3
8000c300:	ce 83       	brcs	8000c2d0 <__multiply+0x6c>
8000c302:	40 09       	lddsp	r9,sp[0x0]
8000c304:	91 0e       	st.w	r8[0x0],lr
8000c306:	94 86       	ld.uh	r6,r10[0x0]
8000c308:	58 06       	cp.w	r6,0
8000c30a:	c1 d0       	breq	8000c344 <__multiply+0xe0>
8000c30c:	72 02       	ld.w	r2,r9[0x0]
8000c30e:	12 98       	mov	r8,r9
8000c310:	16 9e       	mov	lr,r11
8000c312:	30 05       	mov	r5,0
8000c314:	b0 12       	st.h	r8[0x2],r2
8000c316:	1d 01       	ld.w	r1,lr++
8000c318:	90 82       	ld.uh	r2,r8[0x0]
8000c31a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000c31e:	ad 30       	mul	r0,r6
8000c320:	e0 02 00 02 	add	r2,r0,r2
8000c324:	e4 05 00 05 	add	r5,r2,r5
8000c328:	b0 05       	st.h	r8[0x0],r5
8000c32a:	b1 85       	lsr	r5,0x10
8000c32c:	b1 81       	lsr	r1,0x10
8000c32e:	2f c8       	sub	r8,-4
8000c330:	ad 31       	mul	r1,r6
8000c332:	90 92       	ld.uh	r2,r8[0x2]
8000c334:	e2 02 00 02 	add	r2,r1,r2
8000c338:	0a 02       	add	r2,r5
8000c33a:	e4 05 16 10 	lsr	r5,r2,0x10
8000c33e:	06 3e       	cp.w	lr,r3
8000c340:	ce a3       	brcs	8000c314 <__multiply+0xb0>
8000c342:	91 02       	st.w	r8[0x0],r2
8000c344:	2f ca       	sub	r10,-4
8000c346:	2f c9       	sub	r9,-4
8000c348:	40 18       	lddsp	r8,sp[0x4]
8000c34a:	10 3a       	cp.w	r10,r8
8000c34c:	cb b3       	brcs	8000c2c2 <__multiply+0x5e>
8000c34e:	c0 28       	rjmp	8000c352 <__multiply+0xee>
8000c350:	20 17       	sub	r7,1
8000c352:	58 07       	cp.w	r7,0
8000c354:	e0 8a 00 05 	brle	8000c35e <__multiply+0xfa>
8000c358:	09 48       	ld.w	r8,--r4
8000c35a:	58 08       	cp.w	r8,0
8000c35c:	cf a0       	breq	8000c350 <__multiply+0xec>
8000c35e:	99 47       	st.w	r12[0x10],r7
8000c360:	2f ed       	sub	sp,-8
8000c362:	d8 32       	popm	r0-r7,pc

8000c364 <__i2b>:
8000c364:	d4 21       	pushm	r4-r7,lr
8000c366:	16 97       	mov	r7,r11
8000c368:	30 1b       	mov	r11,1
8000c36a:	c4 9e       	rcall	8000bffc <_Balloc>
8000c36c:	30 19       	mov	r9,1
8000c36e:	99 57       	st.w	r12[0x14],r7
8000c370:	99 49       	st.w	r12[0x10],r9
8000c372:	d8 22       	popm	r4-r7,pc

8000c374 <__multadd>:
8000c374:	d4 31       	pushm	r0-r7,lr
8000c376:	30 08       	mov	r8,0
8000c378:	12 95       	mov	r5,r9
8000c37a:	16 97       	mov	r7,r11
8000c37c:	18 96       	mov	r6,r12
8000c37e:	76 44       	ld.w	r4,r11[0x10]
8000c380:	f6 c9 ff ec 	sub	r9,r11,-20
8000c384:	72 0b       	ld.w	r11,r9[0x0]
8000c386:	f6 0c 16 10 	lsr	r12,r11,0x10
8000c38a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c38e:	f4 0c 02 4c 	mul	r12,r10,r12
8000c392:	f4 0b 03 45 	mac	r5,r10,r11
8000c396:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000c39a:	b1 85       	lsr	r5,0x10
8000c39c:	18 05       	add	r5,r12
8000c39e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000c3a2:	f8 0b 00 0b 	add	r11,r12,r11
8000c3a6:	12 ab       	st.w	r9++,r11
8000c3a8:	2f f8       	sub	r8,-1
8000c3aa:	b1 85       	lsr	r5,0x10
8000c3ac:	08 38       	cp.w	r8,r4
8000c3ae:	ce b5       	brlt	8000c384 <__multadd+0x10>
8000c3b0:	58 05       	cp.w	r5,0
8000c3b2:	c1 c0       	breq	8000c3ea <__multadd+0x76>
8000c3b4:	6e 28       	ld.w	r8,r7[0x8]
8000c3b6:	10 34       	cp.w	r4,r8
8000c3b8:	c1 35       	brlt	8000c3de <__multadd+0x6a>
8000c3ba:	6e 1b       	ld.w	r11,r7[0x4]
8000c3bc:	0c 9c       	mov	r12,r6
8000c3be:	2f fb       	sub	r11,-1
8000c3c0:	c1 ee       	rcall	8000bffc <_Balloc>
8000c3c2:	6e 4a       	ld.w	r10,r7[0x10]
8000c3c4:	ee cb ff f4 	sub	r11,r7,-12
8000c3c8:	18 93       	mov	r3,r12
8000c3ca:	2f ea       	sub	r10,-2
8000c3cc:	2f 4c       	sub	r12,-12
8000c3ce:	a3 6a       	lsl	r10,0x2
8000c3d0:	fe b0 de 70 	rcall	800080b0 <memcpy>
8000c3d4:	0e 9b       	mov	r11,r7
8000c3d6:	0c 9c       	mov	r12,r6
8000c3d8:	fe b0 fd f8 	rcall	8000bfc8 <_Bfree>
8000c3dc:	06 97       	mov	r7,r3
8000c3de:	e8 c8 ff ff 	sub	r8,r4,-1
8000c3e2:	2f b4       	sub	r4,-5
8000c3e4:	8f 48       	st.w	r7[0x10],r8
8000c3e6:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000c3ea:	0e 9c       	mov	r12,r7
8000c3ec:	d8 32       	popm	r0-r7,pc
8000c3ee:	d7 03       	nop

8000c3f0 <__pow5mult>:
8000c3f0:	d4 31       	pushm	r0-r7,lr
8000c3f2:	14 96       	mov	r6,r10
8000c3f4:	18 97       	mov	r7,r12
8000c3f6:	16 94       	mov	r4,r11
8000c3f8:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000c3fc:	c0 90       	breq	8000c40e <__pow5mult+0x1e>
8000c3fe:	20 18       	sub	r8,1
8000c400:	fe c9 d8 44 	sub	r9,pc,-10172
8000c404:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000c408:	30 09       	mov	r9,0
8000c40a:	cb 5f       	rcall	8000c374 <__multadd>
8000c40c:	18 94       	mov	r4,r12
8000c40e:	a3 46       	asr	r6,0x2
8000c410:	c3 40       	breq	8000c478 <__pow5mult+0x88>
8000c412:	6e 95       	ld.w	r5,r7[0x24]
8000c414:	58 05       	cp.w	r5,0
8000c416:	c0 91       	brne	8000c428 <__pow5mult+0x38>
8000c418:	31 0c       	mov	r12,16
8000c41a:	fe b0 dc 27 	rcall	80007c68 <malloc>
8000c41e:	99 35       	st.w	r12[0xc],r5
8000c420:	8f 9c       	st.w	r7[0x24],r12
8000c422:	99 15       	st.w	r12[0x4],r5
8000c424:	99 25       	st.w	r12[0x8],r5
8000c426:	99 05       	st.w	r12[0x0],r5
8000c428:	6e 93       	ld.w	r3,r7[0x24]
8000c42a:	66 25       	ld.w	r5,r3[0x8]
8000c42c:	58 05       	cp.w	r5,0
8000c42e:	c0 c1       	brne	8000c446 <__pow5mult+0x56>
8000c430:	e0 6b 02 71 	mov	r11,625
8000c434:	0e 9c       	mov	r12,r7
8000c436:	c9 7f       	rcall	8000c364 <__i2b>
8000c438:	87 2c       	st.w	r3[0x8],r12
8000c43a:	30 08       	mov	r8,0
8000c43c:	18 95       	mov	r5,r12
8000c43e:	99 08       	st.w	r12[0x0],r8
8000c440:	c0 38       	rjmp	8000c446 <__pow5mult+0x56>
8000c442:	06 9c       	mov	r12,r3
8000c444:	18 95       	mov	r5,r12
8000c446:	ed b6 00 00 	bld	r6,0x0
8000c44a:	c0 b1       	brne	8000c460 <__pow5mult+0x70>
8000c44c:	08 9b       	mov	r11,r4
8000c44e:	0a 9a       	mov	r10,r5
8000c450:	0e 9c       	mov	r12,r7
8000c452:	c0 9f       	rcall	8000c264 <__multiply>
8000c454:	08 9b       	mov	r11,r4
8000c456:	18 93       	mov	r3,r12
8000c458:	0e 9c       	mov	r12,r7
8000c45a:	06 94       	mov	r4,r3
8000c45c:	fe b0 fd b6 	rcall	8000bfc8 <_Bfree>
8000c460:	a1 56       	asr	r6,0x1
8000c462:	c0 b0       	breq	8000c478 <__pow5mult+0x88>
8000c464:	6a 03       	ld.w	r3,r5[0x0]
8000c466:	58 03       	cp.w	r3,0
8000c468:	ce d1       	brne	8000c442 <__pow5mult+0x52>
8000c46a:	0a 9a       	mov	r10,r5
8000c46c:	0a 9b       	mov	r11,r5
8000c46e:	0e 9c       	mov	r12,r7
8000c470:	cf ae       	rcall	8000c264 <__multiply>
8000c472:	8b 0c       	st.w	r5[0x0],r12
8000c474:	99 03       	st.w	r12[0x0],r3
8000c476:	ce 7b       	rjmp	8000c444 <__pow5mult+0x54>
8000c478:	08 9c       	mov	r12,r4
8000c47a:	d8 32       	popm	r0-r7,pc

8000c47c <__isinfd>:
8000c47c:	14 98       	mov	r8,r10
8000c47e:	fc 19 7f f0 	movh	r9,0x7ff0
8000c482:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c486:	f0 0b 11 00 	rsub	r11,r8,0
8000c48a:	f7 e8 10 08 	or	r8,r11,r8
8000c48e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000c492:	f2 08 01 08 	sub	r8,r9,r8
8000c496:	f0 0c 11 00 	rsub	r12,r8,0
8000c49a:	f9 e8 10 08 	or	r8,r12,r8
8000c49e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000c4a2:	2f fc       	sub	r12,-1
8000c4a4:	5e fc       	retal	r12

8000c4a6 <__isnand>:
8000c4a6:	14 98       	mov	r8,r10
8000c4a8:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c4ac:	f0 0c 11 00 	rsub	r12,r8,0
8000c4b0:	10 4c       	or	r12,r8
8000c4b2:	fc 18 7f f0 	movh	r8,0x7ff0
8000c4b6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000c4ba:	f0 0c 01 0c 	sub	r12,r8,r12
8000c4be:	bf 9c       	lsr	r12,0x1f
8000c4c0:	5e fc       	retal	r12
8000c4c2:	d7 03       	nop

8000c4c4 <__sclose>:
8000c4c4:	d4 01       	pushm	lr
8000c4c6:	96 7b       	ld.sh	r11,r11[0xe]
8000c4c8:	c8 2c       	rcall	8000c5cc <_close_r>
8000c4ca:	d8 02       	popm	pc

8000c4cc <__sseek>:
8000c4cc:	d4 21       	pushm	r4-r7,lr
8000c4ce:	16 97       	mov	r7,r11
8000c4d0:	96 7b       	ld.sh	r11,r11[0xe]
8000c4d2:	c0 3d       	rcall	8000c6d8 <_lseek_r>
8000c4d4:	8e 68       	ld.sh	r8,r7[0xc]
8000c4d6:	10 99       	mov	r9,r8
8000c4d8:	ad c8       	cbr	r8,0xc
8000c4da:	ad a9       	sbr	r9,0xc
8000c4dc:	5b fc       	cp.w	r12,-1
8000c4de:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000c4e2:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000c4e6:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000c4ea:	d8 22       	popm	r4-r7,pc

8000c4ec <__swrite>:
8000c4ec:	d4 21       	pushm	r4-r7,lr
8000c4ee:	96 68       	ld.sh	r8,r11[0xc]
8000c4f0:	16 97       	mov	r7,r11
8000c4f2:	14 95       	mov	r5,r10
8000c4f4:	12 94       	mov	r4,r9
8000c4f6:	e2 18 01 00 	andl	r8,0x100,COH
8000c4fa:	18 96       	mov	r6,r12
8000c4fc:	c0 50       	breq	8000c506 <__swrite+0x1a>
8000c4fe:	30 29       	mov	r9,2
8000c500:	30 0a       	mov	r10,0
8000c502:	96 7b       	ld.sh	r11,r11[0xe]
8000c504:	ce ac       	rcall	8000c6d8 <_lseek_r>
8000c506:	8e 68       	ld.sh	r8,r7[0xc]
8000c508:	ad c8       	cbr	r8,0xc
8000c50a:	08 99       	mov	r9,r4
8000c50c:	0a 9a       	mov	r10,r5
8000c50e:	8e 7b       	ld.sh	r11,r7[0xe]
8000c510:	0c 9c       	mov	r12,r6
8000c512:	ae 68       	st.h	r7[0xc],r8
8000c514:	c1 cc       	rcall	8000c54c <_write_r>
8000c516:	d8 22       	popm	r4-r7,pc

8000c518 <__sread>:
8000c518:	d4 21       	pushm	r4-r7,lr
8000c51a:	16 97       	mov	r7,r11
8000c51c:	96 7b       	ld.sh	r11,r11[0xe]
8000c51e:	cf 1c       	rcall	8000c700 <_read_r>
8000c520:	c0 65       	brlt	8000c52c <__sread+0x14>
8000c522:	6f 58       	ld.w	r8,r7[0x54]
8000c524:	18 08       	add	r8,r12
8000c526:	ef 48 00 54 	st.w	r7[84],r8
8000c52a:	d8 22       	popm	r4-r7,pc
8000c52c:	8e 68       	ld.sh	r8,r7[0xc]
8000c52e:	ad c8       	cbr	r8,0xc
8000c530:	ae 68       	st.h	r7[0xc],r8
8000c532:	d8 22       	popm	r4-r7,pc

8000c534 <strlen>:
8000c534:	30 09       	mov	r9,0
8000c536:	18 98       	mov	r8,r12
8000c538:	c0 28       	rjmp	8000c53c <strlen+0x8>
8000c53a:	2f f8       	sub	r8,-1
8000c53c:	11 8a       	ld.ub	r10,r8[0x0]
8000c53e:	f2 0a 18 00 	cp.b	r10,r9
8000c542:	cf c1       	brne	8000c53a <strlen+0x6>
8000c544:	f0 0c 01 0c 	sub	r12,r8,r12
8000c548:	5e fc       	retal	r12
8000c54a:	d7 03       	nop

8000c54c <_write_r>:
8000c54c:	d4 21       	pushm	r4-r7,lr
8000c54e:	16 98       	mov	r8,r11
8000c550:	18 97       	mov	r7,r12
8000c552:	10 9c       	mov	r12,r8
8000c554:	30 08       	mov	r8,0
8000c556:	14 9b       	mov	r11,r10
8000c558:	e0 66 53 d8 	mov	r6,21464
8000c55c:	12 9a       	mov	r10,r9
8000c55e:	8d 08       	st.w	r6[0x0],r8
8000c560:	fe b0 d1 9e 	rcall	8000689c <_write>
8000c564:	5b fc       	cp.w	r12,-1
8000c566:	c0 51       	brne	8000c570 <_write_r+0x24>
8000c568:	6c 08       	ld.w	r8,r6[0x0]
8000c56a:	58 08       	cp.w	r8,0
8000c56c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c570:	d8 22       	popm	r4-r7,pc
8000c572:	d7 03       	nop

8000c574 <_calloc_r>:
8000c574:	d4 21       	pushm	r4-r7,lr
8000c576:	f4 0b 02 4b 	mul	r11,r10,r11
8000c57a:	fe b0 db 7f 	rcall	80007c78 <_malloc_r>
8000c57e:	18 97       	mov	r7,r12
8000c580:	c2 30       	breq	8000c5c6 <_calloc_r+0x52>
8000c582:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000c586:	e0 1a ff fc 	andl	r10,0xfffc
8000c58a:	20 4a       	sub	r10,4
8000c58c:	e0 4a 00 24 	cp.w	r10,36
8000c590:	e0 8b 00 18 	brhi	8000c5c0 <_calloc_r+0x4c>
8000c594:	18 98       	mov	r8,r12
8000c596:	59 3a       	cp.w	r10,19
8000c598:	e0 88 00 0f 	brls	8000c5b6 <_calloc_r+0x42>
8000c59c:	30 09       	mov	r9,0
8000c59e:	10 a9       	st.w	r8++,r9
8000c5a0:	10 a9       	st.w	r8++,r9
8000c5a2:	59 ba       	cp.w	r10,27
8000c5a4:	e0 88 00 09 	brls	8000c5b6 <_calloc_r+0x42>
8000c5a8:	10 a9       	st.w	r8++,r9
8000c5aa:	10 a9       	st.w	r8++,r9
8000c5ac:	e0 4a 00 24 	cp.w	r10,36
8000c5b0:	c0 31       	brne	8000c5b6 <_calloc_r+0x42>
8000c5b2:	10 a9       	st.w	r8++,r9
8000c5b4:	10 a9       	st.w	r8++,r9
8000c5b6:	30 09       	mov	r9,0
8000c5b8:	10 a9       	st.w	r8++,r9
8000c5ba:	91 19       	st.w	r8[0x4],r9
8000c5bc:	91 09       	st.w	r8[0x0],r9
8000c5be:	c0 48       	rjmp	8000c5c6 <_calloc_r+0x52>
8000c5c0:	30 0b       	mov	r11,0
8000c5c2:	fe b0 de 1b 	rcall	800081f8 <memset>
8000c5c6:	0e 9c       	mov	r12,r7
8000c5c8:	d8 22       	popm	r4-r7,pc
8000c5ca:	d7 03       	nop

8000c5cc <_close_r>:
8000c5cc:	d4 21       	pushm	r4-r7,lr
8000c5ce:	30 08       	mov	r8,0
8000c5d0:	18 97       	mov	r7,r12
8000c5d2:	e0 66 53 d8 	mov	r6,21464
8000c5d6:	16 9c       	mov	r12,r11
8000c5d8:	8d 08       	st.w	r6[0x0],r8
8000c5da:	fe b0 df b5 	rcall	80008544 <_close>
8000c5de:	5b fc       	cp.w	r12,-1
8000c5e0:	c0 51       	brne	8000c5ea <_close_r+0x1e>
8000c5e2:	6c 08       	ld.w	r8,r6[0x0]
8000c5e4:	58 08       	cp.w	r8,0
8000c5e6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c5ea:	d8 22       	popm	r4-r7,pc

8000c5ec <_fclose_r>:
8000c5ec:	d4 21       	pushm	r4-r7,lr
8000c5ee:	18 96       	mov	r6,r12
8000c5f0:	16 97       	mov	r7,r11
8000c5f2:	58 0b       	cp.w	r11,0
8000c5f4:	c0 31       	brne	8000c5fa <_fclose_r+0xe>
8000c5f6:	16 95       	mov	r5,r11
8000c5f8:	c5 38       	rjmp	8000c69e <_fclose_r+0xb2>
8000c5fa:	fe b0 f8 a9 	rcall	8000b74c <__sfp_lock_acquire>
8000c5fe:	58 06       	cp.w	r6,0
8000c600:	c0 70       	breq	8000c60e <_fclose_r+0x22>
8000c602:	6c 68       	ld.w	r8,r6[0x18]
8000c604:	58 08       	cp.w	r8,0
8000c606:	c0 41       	brne	8000c60e <_fclose_r+0x22>
8000c608:	0c 9c       	mov	r12,r6
8000c60a:	fe b0 f8 f3 	rcall	8000b7f0 <__sinit>
8000c60e:	fe c8 da f6 	sub	r8,pc,-9482
8000c612:	10 37       	cp.w	r7,r8
8000c614:	c0 31       	brne	8000c61a <_fclose_r+0x2e>
8000c616:	6c 07       	ld.w	r7,r6[0x0]
8000c618:	c0 c8       	rjmp	8000c630 <_fclose_r+0x44>
8000c61a:	fe c8 da e2 	sub	r8,pc,-9502
8000c61e:	10 37       	cp.w	r7,r8
8000c620:	c0 31       	brne	8000c626 <_fclose_r+0x3a>
8000c622:	6c 17       	ld.w	r7,r6[0x4]
8000c624:	c0 68       	rjmp	8000c630 <_fclose_r+0x44>
8000c626:	fe c8 da ce 	sub	r8,pc,-9522
8000c62a:	10 37       	cp.w	r7,r8
8000c62c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000c630:	8e 69       	ld.sh	r9,r7[0xc]
8000c632:	30 08       	mov	r8,0
8000c634:	f0 09 19 00 	cp.h	r9,r8
8000c638:	c0 51       	brne	8000c642 <_fclose_r+0x56>
8000c63a:	fe b0 f8 8a 	rcall	8000b74e <__sfp_lock_release>
8000c63e:	30 05       	mov	r5,0
8000c640:	c2 f8       	rjmp	8000c69e <_fclose_r+0xb2>
8000c642:	0e 9b       	mov	r11,r7
8000c644:	0c 9c       	mov	r12,r6
8000c646:	fe b0 f7 fd 	rcall	8000b640 <_fflush_r>
8000c64a:	6e c8       	ld.w	r8,r7[0x30]
8000c64c:	18 95       	mov	r5,r12
8000c64e:	58 08       	cp.w	r8,0
8000c650:	c0 60       	breq	8000c65c <_fclose_r+0x70>
8000c652:	6e 8b       	ld.w	r11,r7[0x20]
8000c654:	0c 9c       	mov	r12,r6
8000c656:	5d 18       	icall	r8
8000c658:	f9 b5 05 ff 	movlt	r5,-1
8000c65c:	8e 68       	ld.sh	r8,r7[0xc]
8000c65e:	ed b8 00 07 	bld	r8,0x7
8000c662:	c0 51       	brne	8000c66c <_fclose_r+0x80>
8000c664:	6e 4b       	ld.w	r11,r7[0x10]
8000c666:	0c 9c       	mov	r12,r6
8000c668:	fe b0 f9 5e 	rcall	8000b924 <_free_r>
8000c66c:	6e db       	ld.w	r11,r7[0x34]
8000c66e:	58 0b       	cp.w	r11,0
8000c670:	c0 a0       	breq	8000c684 <_fclose_r+0x98>
8000c672:	ee c8 ff bc 	sub	r8,r7,-68
8000c676:	10 3b       	cp.w	r11,r8
8000c678:	c0 40       	breq	8000c680 <_fclose_r+0x94>
8000c67a:	0c 9c       	mov	r12,r6
8000c67c:	fe b0 f9 54 	rcall	8000b924 <_free_r>
8000c680:	30 08       	mov	r8,0
8000c682:	8f d8       	st.w	r7[0x34],r8
8000c684:	6f 2b       	ld.w	r11,r7[0x48]
8000c686:	58 0b       	cp.w	r11,0
8000c688:	c0 70       	breq	8000c696 <_fclose_r+0xaa>
8000c68a:	0c 9c       	mov	r12,r6
8000c68c:	fe b0 f9 4c 	rcall	8000b924 <_free_r>
8000c690:	30 08       	mov	r8,0
8000c692:	ef 48 00 48 	st.w	r7[72],r8
8000c696:	30 08       	mov	r8,0
8000c698:	ae 68       	st.h	r7[0xc],r8
8000c69a:	fe b0 f8 5a 	rcall	8000b74e <__sfp_lock_release>
8000c69e:	0a 9c       	mov	r12,r5
8000c6a0:	d8 22       	popm	r4-r7,pc
8000c6a2:	d7 03       	nop

8000c6a4 <fclose>:
8000c6a4:	d4 01       	pushm	lr
8000c6a6:	e0 68 0a 44 	mov	r8,2628
8000c6aa:	18 9b       	mov	r11,r12
8000c6ac:	70 0c       	ld.w	r12,r8[0x0]
8000c6ae:	c9 ff       	rcall	8000c5ec <_fclose_r>
8000c6b0:	d8 02       	popm	pc
8000c6b2:	d7 03       	nop

8000c6b4 <_fstat_r>:
8000c6b4:	d4 21       	pushm	r4-r7,lr
8000c6b6:	16 98       	mov	r8,r11
8000c6b8:	18 97       	mov	r7,r12
8000c6ba:	10 9c       	mov	r12,r8
8000c6bc:	30 08       	mov	r8,0
8000c6be:	e0 66 53 d8 	mov	r6,21464
8000c6c2:	14 9b       	mov	r11,r10
8000c6c4:	8d 08       	st.w	r6[0x0],r8
8000c6c6:	fe b0 df 67 	rcall	80008594 <_fstat>
8000c6ca:	5b fc       	cp.w	r12,-1
8000c6cc:	c0 51       	brne	8000c6d6 <_fstat_r+0x22>
8000c6ce:	6c 08       	ld.w	r8,r6[0x0]
8000c6d0:	58 08       	cp.w	r8,0
8000c6d2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c6d6:	d8 22       	popm	r4-r7,pc

8000c6d8 <_lseek_r>:
8000c6d8:	d4 21       	pushm	r4-r7,lr
8000c6da:	16 98       	mov	r8,r11
8000c6dc:	18 97       	mov	r7,r12
8000c6de:	10 9c       	mov	r12,r8
8000c6e0:	30 08       	mov	r8,0
8000c6e2:	14 9b       	mov	r11,r10
8000c6e4:	e0 66 53 d8 	mov	r6,21464
8000c6e8:	12 9a       	mov	r10,r9
8000c6ea:	8d 08       	st.w	r6[0x0],r8
8000c6ec:	fe b0 df 36 	rcall	80008558 <_lseek>
8000c6f0:	5b fc       	cp.w	r12,-1
8000c6f2:	c0 51       	brne	8000c6fc <_lseek_r+0x24>
8000c6f4:	6c 08       	ld.w	r8,r6[0x0]
8000c6f6:	58 08       	cp.w	r8,0
8000c6f8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c6fc:	d8 22       	popm	r4-r7,pc
8000c6fe:	d7 03       	nop

8000c700 <_read_r>:
8000c700:	d4 21       	pushm	r4-r7,lr
8000c702:	16 98       	mov	r8,r11
8000c704:	18 97       	mov	r7,r12
8000c706:	10 9c       	mov	r12,r8
8000c708:	30 08       	mov	r8,0
8000c70a:	14 9b       	mov	r11,r10
8000c70c:	e0 66 53 d8 	mov	r6,21464
8000c710:	12 9a       	mov	r10,r9
8000c712:	8d 08       	st.w	r6[0x0],r8
8000c714:	fe b0 d0 a4 	rcall	8000685c <_read>
8000c718:	5b fc       	cp.w	r12,-1
8000c71a:	c0 51       	brne	8000c724 <_read_r+0x24>
8000c71c:	6c 08       	ld.w	r8,r6[0x0]
8000c71e:	58 08       	cp.w	r8,0
8000c720:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c724:	d8 22       	popm	r4-r7,pc
8000c726:	d7 03       	nop

8000c728 <__avr32_f64_mul>:
8000c728:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c72c:	e0 80 00 dc 	breq	8000c8e4 <__avr32_f64_mul_op1_zero>
8000c730:	d4 21       	pushm	r4-r7,lr
8000c732:	f7 e9 20 0e 	eor	lr,r11,r9
8000c736:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c73a:	30 15       	mov	r5,1
8000c73c:	c4 30       	breq	8000c7c2 <__avr32_f64_mul_op1_subnormal>
8000c73e:	ab 6b       	lsl	r11,0xa
8000c740:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c744:	ab 6a       	lsl	r10,0xa
8000c746:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c74a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c74e:	c5 c0       	breq	8000c806 <__avr32_f64_mul_op2_subnormal>
8000c750:	a1 78       	lsl	r8,0x1
8000c752:	5c f9       	rol	r9
8000c754:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c758:	e0 47 07 ff 	cp.w	r7,2047
8000c75c:	c7 70       	breq	8000c84a <__avr32_f64_mul_op_nan_or_inf>
8000c75e:	e0 46 07 ff 	cp.w	r6,2047
8000c762:	c7 40       	breq	8000c84a <__avr32_f64_mul_op_nan_or_inf>
8000c764:	ee 06 00 0c 	add	r12,r7,r6
8000c768:	e0 2c 03 fe 	sub	r12,1022
8000c76c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c770:	f4 09 07 44 	macu.d	r4,r10,r9
8000c774:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c778:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c77c:	08 07       	add	r7,r4
8000c77e:	f4 05 00 4a 	adc	r10,r10,r5
8000c782:	5c 0b       	acr	r11
8000c784:	ed bb 00 14 	bld	r11,0x14
8000c788:	c0 50       	breq	8000c792 <__avr32_f64_mul+0x6a>
8000c78a:	a1 77       	lsl	r7,0x1
8000c78c:	5c fa       	rol	r10
8000c78e:	5c fb       	rol	r11
8000c790:	20 1c       	sub	r12,1
8000c792:	58 0c       	cp.w	r12,0
8000c794:	e0 8a 00 6f 	brle	8000c872 <__avr32_f64_mul_res_subnormal>
8000c798:	e0 4c 07 ff 	cp.w	r12,2047
8000c79c:	e0 84 00 9c 	brge	8000c8d4 <__avr32_f64_mul_res_inf>
8000c7a0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c7a4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c7a8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c7ac:	ee 17 80 00 	eorh	r7,0x8000
8000c7b0:	f1 b7 04 20 	satu	r7,0x1
8000c7b4:	0e 0a       	add	r10,r7
8000c7b6:	5c 0b       	acr	r11
8000c7b8:	ed be 00 1f 	bld	lr,0x1f
8000c7bc:	ef bb 00 1f 	bst	r11,0x1f
8000c7c0:	d8 22       	popm	r4-r7,pc

8000c7c2 <__avr32_f64_mul_op1_subnormal>:
8000c7c2:	e4 1b 00 0f 	andh	r11,0xf
8000c7c6:	f4 0c 12 00 	clz	r12,r10
8000c7ca:	f6 06 12 00 	clz	r6,r11
8000c7ce:	f7 bc 03 e1 	sublo	r12,-31
8000c7d2:	f8 06 17 30 	movlo	r6,r12
8000c7d6:	f7 b6 02 01 	subhs	r6,1
8000c7da:	e0 46 00 20 	cp.w	r6,32
8000c7de:	c0 d4       	brge	8000c7f8 <__avr32_f64_mul_op1_subnormal+0x36>
8000c7e0:	ec 0c 11 20 	rsub	r12,r6,32
8000c7e4:	f6 06 09 4b 	lsl	r11,r11,r6
8000c7e8:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c7ec:	18 4b       	or	r11,r12
8000c7ee:	f4 06 09 4a 	lsl	r10,r10,r6
8000c7f2:	20 b6       	sub	r6,11
8000c7f4:	0c 17       	sub	r7,r6
8000c7f6:	ca ab       	rjmp	8000c74a <__avr32_f64_mul+0x22>
8000c7f8:	f4 06 09 4b 	lsl	r11,r10,r6
8000c7fc:	c6 40       	breq	8000c8c4 <__avr32_f64_mul_res_zero>
8000c7fe:	30 0a       	mov	r10,0
8000c800:	20 b6       	sub	r6,11
8000c802:	0c 17       	sub	r7,r6
8000c804:	ca 3b       	rjmp	8000c74a <__avr32_f64_mul+0x22>

8000c806 <__avr32_f64_mul_op2_subnormal>:
8000c806:	e4 19 00 0f 	andh	r9,0xf
8000c80a:	f0 0c 12 00 	clz	r12,r8
8000c80e:	f2 05 12 00 	clz	r5,r9
8000c812:	f7 bc 03 ea 	sublo	r12,-22
8000c816:	f8 05 17 30 	movlo	r5,r12
8000c81a:	f7 b5 02 0a 	subhs	r5,10
8000c81e:	e0 45 00 20 	cp.w	r5,32
8000c822:	c0 d4       	brge	8000c83c <__avr32_f64_mul_op2_subnormal+0x36>
8000c824:	ea 0c 11 20 	rsub	r12,r5,32
8000c828:	f2 05 09 49 	lsl	r9,r9,r5
8000c82c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c830:	18 49       	or	r9,r12
8000c832:	f0 05 09 48 	lsl	r8,r8,r5
8000c836:	20 25       	sub	r5,2
8000c838:	0a 16       	sub	r6,r5
8000c83a:	c8 fb       	rjmp	8000c758 <__avr32_f64_mul+0x30>
8000c83c:	f0 05 09 49 	lsl	r9,r8,r5
8000c840:	c4 20       	breq	8000c8c4 <__avr32_f64_mul_res_zero>
8000c842:	30 08       	mov	r8,0
8000c844:	20 25       	sub	r5,2
8000c846:	0a 16       	sub	r6,r5
8000c848:	c8 8b       	rjmp	8000c758 <__avr32_f64_mul+0x30>

8000c84a <__avr32_f64_mul_op_nan_or_inf>:
8000c84a:	e4 19 00 0f 	andh	r9,0xf
8000c84e:	e4 1b 00 0f 	andh	r11,0xf
8000c852:	14 4b       	or	r11,r10
8000c854:	10 49       	or	r9,r8
8000c856:	e0 47 07 ff 	cp.w	r7,2047
8000c85a:	c0 91       	brne	8000c86c <__avr32_f64_mul_op1_not_naninf>
8000c85c:	58 0b       	cp.w	r11,0
8000c85e:	c3 81       	brne	8000c8ce <__avr32_f64_mul_res_nan>
8000c860:	e0 46 07 ff 	cp.w	r6,2047
8000c864:	c3 81       	brne	8000c8d4 <__avr32_f64_mul_res_inf>
8000c866:	58 09       	cp.w	r9,0
8000c868:	c3 60       	breq	8000c8d4 <__avr32_f64_mul_res_inf>
8000c86a:	c3 28       	rjmp	8000c8ce <__avr32_f64_mul_res_nan>

8000c86c <__avr32_f64_mul_op1_not_naninf>:
8000c86c:	58 09       	cp.w	r9,0
8000c86e:	c3 30       	breq	8000c8d4 <__avr32_f64_mul_res_inf>
8000c870:	c2 f8       	rjmp	8000c8ce <__avr32_f64_mul_res_nan>

8000c872 <__avr32_f64_mul_res_subnormal>:
8000c872:	5c 3c       	neg	r12
8000c874:	2f fc       	sub	r12,-1
8000c876:	f1 bc 04 c0 	satu	r12,0x6
8000c87a:	e0 4c 00 20 	cp.w	r12,32
8000c87e:	c1 14       	brge	8000c8a0 <__avr32_f64_mul_res_subnormal+0x2e>
8000c880:	f8 08 11 20 	rsub	r8,r12,32
8000c884:	0e 46       	or	r6,r7
8000c886:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c88a:	f4 08 09 49 	lsl	r9,r10,r8
8000c88e:	12 47       	or	r7,r9
8000c890:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c894:	f6 08 09 49 	lsl	r9,r11,r8
8000c898:	12 4a       	or	r10,r9
8000c89a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c89e:	c8 3b       	rjmp	8000c7a4 <__avr32_f64_mul+0x7c>
8000c8a0:	f8 08 11 20 	rsub	r8,r12,32
8000c8a4:	f9 b9 00 00 	moveq	r9,0
8000c8a8:	c0 30       	breq	8000c8ae <__avr32_f64_mul_res_subnormal+0x3c>
8000c8aa:	f6 08 09 49 	lsl	r9,r11,r8
8000c8ae:	0e 46       	or	r6,r7
8000c8b0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c8b4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c8b8:	f3 ea 10 07 	or	r7,r9,r10
8000c8bc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c8c0:	30 0b       	mov	r11,0
8000c8c2:	c7 1b       	rjmp	8000c7a4 <__avr32_f64_mul+0x7c>

8000c8c4 <__avr32_f64_mul_res_zero>:
8000c8c4:	1c 9b       	mov	r11,lr
8000c8c6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c8ca:	30 0a       	mov	r10,0
8000c8cc:	d8 22       	popm	r4-r7,pc

8000c8ce <__avr32_f64_mul_res_nan>:
8000c8ce:	3f fb       	mov	r11,-1
8000c8d0:	3f fa       	mov	r10,-1
8000c8d2:	d8 22       	popm	r4-r7,pc

8000c8d4 <__avr32_f64_mul_res_inf>:
8000c8d4:	f0 6b 00 00 	mov	r11,-1048576
8000c8d8:	ed be 00 1f 	bld	lr,0x1f
8000c8dc:	ef bb 00 1f 	bst	r11,0x1f
8000c8e0:	30 0a       	mov	r10,0
8000c8e2:	d8 22       	popm	r4-r7,pc

8000c8e4 <__avr32_f64_mul_op1_zero>:
8000c8e4:	f7 e9 20 0b 	eor	r11,r11,r9
8000c8e8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c8ec:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c8f0:	e0 4c 07 ff 	cp.w	r12,2047
8000c8f4:	5e 1c       	retne	r12
8000c8f6:	3f fa       	mov	r10,-1
8000c8f8:	3f fb       	mov	r11,-1
8000c8fa:	5e fc       	retal	r12

8000c8fc <__avr32_f64_sub_from_add>:
8000c8fc:	ee 19 80 00 	eorh	r9,0x8000

8000c900 <__avr32_f64_sub>:
8000c900:	f7 e9 20 0c 	eor	r12,r11,r9
8000c904:	e0 86 00 ca 	brmi	8000ca98 <__avr32_f64_add_from_sub>
8000c908:	eb cd 40 e0 	pushm	r5-r7,lr
8000c90c:	16 9c       	mov	r12,r11
8000c90e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c912:	bf db       	cbr	r11,0x1f
8000c914:	bf d9       	cbr	r9,0x1f
8000c916:	10 3a       	cp.w	r10,r8
8000c918:	f2 0b 13 00 	cpc	r11,r9
8000c91c:	c0 92       	brcc	8000c92e <__avr32_f64_sub+0x2e>
8000c91e:	16 97       	mov	r7,r11
8000c920:	12 9b       	mov	r11,r9
8000c922:	0e 99       	mov	r9,r7
8000c924:	14 97       	mov	r7,r10
8000c926:	10 9a       	mov	r10,r8
8000c928:	0e 98       	mov	r8,r7
8000c92a:	ee 1c 80 00 	eorh	r12,0x8000
8000c92e:	f6 07 16 14 	lsr	r7,r11,0x14
8000c932:	ab 7b       	lsl	r11,0xb
8000c934:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c938:	ab 7a       	lsl	r10,0xb
8000c93a:	bf bb       	sbr	r11,0x1f
8000c93c:	f2 06 16 14 	lsr	r6,r9,0x14
8000c940:	c4 40       	breq	8000c9c8 <__avr32_f64_sub_opL_subnormal>
8000c942:	ab 79       	lsl	r9,0xb
8000c944:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c948:	ab 78       	lsl	r8,0xb
8000c94a:	bf b9       	sbr	r9,0x1f

8000c94c <__avr32_f64_sub_opL_subnormal_done>:
8000c94c:	e0 47 07 ff 	cp.w	r7,2047
8000c950:	c4 f0       	breq	8000c9ee <__avr32_f64_sub_opH_nan_or_inf>
8000c952:	0e 26       	rsub	r6,r7
8000c954:	c1 20       	breq	8000c978 <__avr32_f64_sub_shift_done>
8000c956:	ec 05 11 20 	rsub	r5,r6,32
8000c95a:	e0 46 00 20 	cp.w	r6,32
8000c95e:	c7 c2       	brcc	8000ca56 <__avr32_f64_sub_longshift>
8000c960:	f0 05 09 4e 	lsl	lr,r8,r5
8000c964:	f2 05 09 45 	lsl	r5,r9,r5
8000c968:	f0 06 0a 48 	lsr	r8,r8,r6
8000c96c:	f2 06 0a 49 	lsr	r9,r9,r6
8000c970:	0a 48       	or	r8,r5
8000c972:	58 0e       	cp.w	lr,0
8000c974:	5f 1e       	srne	lr
8000c976:	1c 48       	or	r8,lr

8000c978 <__avr32_f64_sub_shift_done>:
8000c978:	10 1a       	sub	r10,r8
8000c97a:	f6 09 01 4b 	sbc	r11,r11,r9
8000c97e:	f6 06 12 00 	clz	r6,r11
8000c982:	c0 e0       	breq	8000c99e <__avr32_f64_sub_longnormalize_done>
8000c984:	c7 83       	brcs	8000ca74 <__avr32_f64_sub_longnormalize>
8000c986:	ec 0e 11 20 	rsub	lr,r6,32
8000c98a:	f6 06 09 4b 	lsl	r11,r11,r6
8000c98e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c992:	1c 4b       	or	r11,lr
8000c994:	f4 06 09 4a 	lsl	r10,r10,r6
8000c998:	0c 17       	sub	r7,r6
8000c99a:	e0 8a 00 39 	brle	8000ca0c <__avr32_f64_sub_subnormal_result>

8000c99e <__avr32_f64_sub_longnormalize_done>:
8000c99e:	f4 09 15 15 	lsl	r9,r10,0x15
8000c9a2:	ab 9a       	lsr	r10,0xb
8000c9a4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c9a8:	ab 9b       	lsr	r11,0xb
8000c9aa:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c9ae:	18 4b       	or	r11,r12

8000c9b0 <__avr32_f64_sub_round>:
8000c9b0:	fc 17 80 00 	movh	r7,0x8000
8000c9b4:	ed ba 00 00 	bld	r10,0x0
8000c9b8:	f7 b7 01 ff 	subne	r7,-1
8000c9bc:	0e 39       	cp.w	r9,r7
8000c9be:	5f 29       	srhs	r9
8000c9c0:	12 0a       	add	r10,r9
8000c9c2:	5c 0b       	acr	r11
8000c9c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c9c8 <__avr32_f64_sub_opL_subnormal>:
8000c9c8:	ab 79       	lsl	r9,0xb
8000c9ca:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c9ce:	ab 78       	lsl	r8,0xb
8000c9d0:	f3 e8 10 0e 	or	lr,r9,r8
8000c9d4:	f9 b6 01 01 	movne	r6,1
8000c9d8:	ee 0e 11 00 	rsub	lr,r7,0
8000c9dc:	f9 b7 00 01 	moveq	r7,1
8000c9e0:	ef bb 00 1f 	bst	r11,0x1f
8000c9e4:	f7 ea 10 0e 	or	lr,r11,r10
8000c9e8:	f9 b7 00 00 	moveq	r7,0
8000c9ec:	cb 0b       	rjmp	8000c94c <__avr32_f64_sub_opL_subnormal_done>

8000c9ee <__avr32_f64_sub_opH_nan_or_inf>:
8000c9ee:	bf db       	cbr	r11,0x1f
8000c9f0:	f7 ea 10 0e 	or	lr,r11,r10
8000c9f4:	c0 81       	brne	8000ca04 <__avr32_f64_sub_return_nan>
8000c9f6:	e0 46 07 ff 	cp.w	r6,2047
8000c9fa:	c0 50       	breq	8000ca04 <__avr32_f64_sub_return_nan>
8000c9fc:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000ca00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ca04 <__avr32_f64_sub_return_nan>:
8000ca04:	3f fa       	mov	r10,-1
8000ca06:	3f fb       	mov	r11,-1
8000ca08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ca0c <__avr32_f64_sub_subnormal_result>:
8000ca0c:	5c 37       	neg	r7
8000ca0e:	2f f7       	sub	r7,-1
8000ca10:	f1 b7 04 c0 	satu	r7,0x6
8000ca14:	e0 47 00 20 	cp.w	r7,32
8000ca18:	c1 14       	brge	8000ca3a <__avr32_f64_sub_subnormal_result+0x2e>
8000ca1a:	ee 08 11 20 	rsub	r8,r7,32
8000ca1e:	f4 08 09 49 	lsl	r9,r10,r8
8000ca22:	5f 16       	srne	r6
8000ca24:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ca28:	0c 4a       	or	r10,r6
8000ca2a:	f6 08 09 49 	lsl	r9,r11,r8
8000ca2e:	f5 e9 10 0a 	or	r10,r10,r9
8000ca32:	f4 07 0a 4b 	lsr	r11,r10,r7
8000ca36:	30 07       	mov	r7,0
8000ca38:	cb 3b       	rjmp	8000c99e <__avr32_f64_sub_longnormalize_done>
8000ca3a:	ee 08 11 40 	rsub	r8,r7,64
8000ca3e:	f6 08 09 49 	lsl	r9,r11,r8
8000ca42:	14 49       	or	r9,r10
8000ca44:	5f 16       	srne	r6
8000ca46:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ca4a:	0c 4a       	or	r10,r6
8000ca4c:	30 0b       	mov	r11,0
8000ca4e:	30 07       	mov	r7,0
8000ca50:	ca 7b       	rjmp	8000c99e <__avr32_f64_sub_longnormalize_done>
8000ca52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ca56 <__avr32_f64_sub_longshift>:
8000ca56:	f1 b6 04 c0 	satu	r6,0x6
8000ca5a:	f0 0e 17 00 	moveq	lr,r8
8000ca5e:	c0 40       	breq	8000ca66 <__avr32_f64_sub_longshift+0x10>
8000ca60:	f2 05 09 4e 	lsl	lr,r9,r5
8000ca64:	10 4e       	or	lr,r8
8000ca66:	f2 06 0a 48 	lsr	r8,r9,r6
8000ca6a:	30 09       	mov	r9,0
8000ca6c:	58 0e       	cp.w	lr,0
8000ca6e:	5f 1e       	srne	lr
8000ca70:	1c 48       	or	r8,lr
8000ca72:	c8 3b       	rjmp	8000c978 <__avr32_f64_sub_shift_done>

8000ca74 <__avr32_f64_sub_longnormalize>:
8000ca74:	f4 06 12 00 	clz	r6,r10
8000ca78:	f9 b7 03 00 	movlo	r7,0
8000ca7c:	f9 b6 03 00 	movlo	r6,0
8000ca80:	f9 bc 03 00 	movlo	r12,0
8000ca84:	f7 b6 02 e0 	subhs	r6,-32
8000ca88:	f4 06 09 4b 	lsl	r11,r10,r6
8000ca8c:	30 0a       	mov	r10,0
8000ca8e:	0c 17       	sub	r7,r6
8000ca90:	fe 9a ff be 	brle	8000ca0c <__avr32_f64_sub_subnormal_result>
8000ca94:	c8 5b       	rjmp	8000c99e <__avr32_f64_sub_longnormalize_done>
8000ca96:	d7 03       	nop

8000ca98 <__avr32_f64_add_from_sub>:
8000ca98:	ee 19 80 00 	eorh	r9,0x8000

8000ca9c <__avr32_f64_add>:
8000ca9c:	f7 e9 20 0c 	eor	r12,r11,r9
8000caa0:	fe 96 ff 2e 	brmi	8000c8fc <__avr32_f64_sub_from_add>
8000caa4:	eb cd 40 e0 	pushm	r5-r7,lr
8000caa8:	16 9c       	mov	r12,r11
8000caaa:	e6 1c 80 00 	andh	r12,0x8000,COH
8000caae:	bf db       	cbr	r11,0x1f
8000cab0:	bf d9       	cbr	r9,0x1f
8000cab2:	12 3b       	cp.w	r11,r9
8000cab4:	c0 72       	brcc	8000cac2 <__avr32_f64_add+0x26>
8000cab6:	16 97       	mov	r7,r11
8000cab8:	12 9b       	mov	r11,r9
8000caba:	0e 99       	mov	r9,r7
8000cabc:	14 97       	mov	r7,r10
8000cabe:	10 9a       	mov	r10,r8
8000cac0:	0e 98       	mov	r8,r7
8000cac2:	30 0e       	mov	lr,0
8000cac4:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000cac8:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000cacc:	b5 ab       	sbr	r11,0x14
8000cace:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000cad2:	c6 20       	breq	8000cb96 <__avr32_f64_add_op2_subnormal>
8000cad4:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000cad8:	b5 a9       	sbr	r9,0x14
8000cada:	e0 47 07 ff 	cp.w	r7,2047
8000cade:	c2 80       	breq	8000cb2e <__avr32_f64_add_opH_nan_or_inf>
8000cae0:	0e 26       	rsub	r6,r7
8000cae2:	c1 20       	breq	8000cb06 <__avr32_f64_add_shift_done>
8000cae4:	e0 46 00 36 	cp.w	r6,54
8000cae8:	c1 52       	brcc	8000cb12 <__avr32_f64_add_res_of_done>
8000caea:	ec 05 11 20 	rsub	r5,r6,32
8000caee:	e0 46 00 20 	cp.w	r6,32
8000caf2:	c3 52       	brcc	8000cb5c <__avr32_f64_add_longshift>
8000caf4:	f0 05 09 4e 	lsl	lr,r8,r5
8000caf8:	f2 05 09 45 	lsl	r5,r9,r5
8000cafc:	f0 06 0a 48 	lsr	r8,r8,r6
8000cb00:	f2 06 0a 49 	lsr	r9,r9,r6
8000cb04:	0a 48       	or	r8,r5

8000cb06 <__avr32_f64_add_shift_done>:
8000cb06:	10 0a       	add	r10,r8
8000cb08:	f6 09 00 4b 	adc	r11,r11,r9
8000cb0c:	ed bb 00 15 	bld	r11,0x15
8000cb10:	c3 40       	breq	8000cb78 <__avr32_f64_add_res_of>

8000cb12 <__avr32_f64_add_res_of_done>:
8000cb12:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000cb16:	18 4b       	or	r11,r12

8000cb18 <__avr32_f64_add_round>:
8000cb18:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000cb1c:	18 4e       	or	lr,r12
8000cb1e:	ee 1e 80 00 	eorh	lr,0x8000
8000cb22:	f1 be 04 20 	satu	lr,0x1
8000cb26:	1c 0a       	add	r10,lr
8000cb28:	5c 0b       	acr	r11
8000cb2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cb2e <__avr32_f64_add_opH_nan_or_inf>:
8000cb2e:	b5 cb       	cbr	r11,0x14
8000cb30:	f7 ea 10 0e 	or	lr,r11,r10
8000cb34:	c1 01       	brne	8000cb54 <__avr32_f64_add_return_nan>
8000cb36:	e0 46 07 ff 	cp.w	r6,2047
8000cb3a:	c0 30       	breq	8000cb40 <__avr32_f64_add_opL_nan_or_inf>
8000cb3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cb40 <__avr32_f64_add_opL_nan_or_inf>:
8000cb40:	b5 c9       	cbr	r9,0x14
8000cb42:	f3 e8 10 0e 	or	lr,r9,r8
8000cb46:	c0 71       	brne	8000cb54 <__avr32_f64_add_return_nan>
8000cb48:	30 0a       	mov	r10,0
8000cb4a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000cb4e:	18 4b       	or	r11,r12
8000cb50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cb54 <__avr32_f64_add_return_nan>:
8000cb54:	3f fa       	mov	r10,-1
8000cb56:	3f fb       	mov	r11,-1
8000cb58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cb5c <__avr32_f64_add_longshift>:
8000cb5c:	f1 b6 04 c0 	satu	r6,0x6
8000cb60:	f0 0e 17 00 	moveq	lr,r8
8000cb64:	c0 60       	breq	8000cb70 <__avr32_f64_add_longshift+0x14>
8000cb66:	f2 05 09 4e 	lsl	lr,r9,r5
8000cb6a:	58 08       	cp.w	r8,0
8000cb6c:	5f 18       	srne	r8
8000cb6e:	10 4e       	or	lr,r8
8000cb70:	f2 06 0a 48 	lsr	r8,r9,r6
8000cb74:	30 09       	mov	r9,0
8000cb76:	cc 8b       	rjmp	8000cb06 <__avr32_f64_add_shift_done>

8000cb78 <__avr32_f64_add_res_of>:
8000cb78:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000cb7c:	a1 9b       	lsr	r11,0x1
8000cb7e:	5d 0a       	ror	r10
8000cb80:	5d 0e       	ror	lr
8000cb82:	2f f7       	sub	r7,-1
8000cb84:	e0 47 07 ff 	cp.w	r7,2047
8000cb88:	f9 ba 00 00 	moveq	r10,0
8000cb8c:	f9 bb 00 00 	moveq	r11,0
8000cb90:	f9 be 00 00 	moveq	lr,0
8000cb94:	cb fb       	rjmp	8000cb12 <__avr32_f64_add_res_of_done>

8000cb96 <__avr32_f64_add_op2_subnormal>:
8000cb96:	30 16       	mov	r6,1
8000cb98:	58 07       	cp.w	r7,0
8000cb9a:	ca 01       	brne	8000cada <__avr32_f64_add+0x3e>
8000cb9c:	b5 cb       	cbr	r11,0x14
8000cb9e:	10 0a       	add	r10,r8
8000cba0:	f6 09 00 4b 	adc	r11,r11,r9
8000cba4:	18 4b       	or	r11,r12
8000cba6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000cbaa:	d7 03       	nop

8000cbac <__avr32_f64_to_u32>:
8000cbac:	58 0b       	cp.w	r11,0
8000cbae:	5e 6d       	retmi	0

8000cbb0 <__avr32_f64_to_s32>:
8000cbb0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000cbb4:	b5 9c       	lsr	r12,0x15
8000cbb6:	e0 2c 03 ff 	sub	r12,1023
8000cbba:	5e 3d       	retlo	0
8000cbbc:	f8 0c 11 1f 	rsub	r12,r12,31
8000cbc0:	16 99       	mov	r9,r11
8000cbc2:	ab 7b       	lsl	r11,0xb
8000cbc4:	bf bb       	sbr	r11,0x1f
8000cbc6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000cbca:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000cbce:	a1 79       	lsl	r9,0x1
8000cbd0:	5e 2b       	reths	r11
8000cbd2:	5c 3b       	neg	r11
8000cbd4:	5e fb       	retal	r11

8000cbd6 <__avr32_u32_to_f64>:
8000cbd6:	f8 cb 00 00 	sub	r11,r12,0
8000cbda:	30 0c       	mov	r12,0
8000cbdc:	c0 38       	rjmp	8000cbe2 <__avr32_s32_to_f64+0x4>

8000cbde <__avr32_s32_to_f64>:
8000cbde:	18 9b       	mov	r11,r12
8000cbe0:	5c 4b       	abs	r11
8000cbe2:	30 0a       	mov	r10,0
8000cbe4:	5e 0b       	reteq	r11
8000cbe6:	d4 01       	pushm	lr
8000cbe8:	e0 69 04 1e 	mov	r9,1054
8000cbec:	f6 08 12 00 	clz	r8,r11
8000cbf0:	c1 70       	breq	8000cc1e <__avr32_s32_to_f64+0x40>
8000cbf2:	c0 c3       	brcs	8000cc0a <__avr32_s32_to_f64+0x2c>
8000cbf4:	f0 0e 11 20 	rsub	lr,r8,32
8000cbf8:	f6 08 09 4b 	lsl	r11,r11,r8
8000cbfc:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000cc00:	1c 4b       	or	r11,lr
8000cc02:	f4 08 09 4a 	lsl	r10,r10,r8
8000cc06:	10 19       	sub	r9,r8
8000cc08:	c0 b8       	rjmp	8000cc1e <__avr32_s32_to_f64+0x40>
8000cc0a:	f4 08 12 00 	clz	r8,r10
8000cc0e:	f9 b8 03 00 	movlo	r8,0
8000cc12:	f7 b8 02 e0 	subhs	r8,-32
8000cc16:	f4 08 09 4b 	lsl	r11,r10,r8
8000cc1a:	30 0a       	mov	r10,0
8000cc1c:	10 19       	sub	r9,r8
8000cc1e:	58 09       	cp.w	r9,0
8000cc20:	e0 89 00 30 	brgt	8000cc80 <__avr32_s32_to_f64+0xa2>
8000cc24:	5c 39       	neg	r9
8000cc26:	2f f9       	sub	r9,-1
8000cc28:	e0 49 00 36 	cp.w	r9,54
8000cc2c:	c0 43       	brcs	8000cc34 <__avr32_s32_to_f64+0x56>
8000cc2e:	30 0b       	mov	r11,0
8000cc30:	30 0a       	mov	r10,0
8000cc32:	c2 68       	rjmp	8000cc7e <__avr32_s32_to_f64+0xa0>
8000cc34:	2f 69       	sub	r9,-10
8000cc36:	f2 08 11 20 	rsub	r8,r9,32
8000cc3a:	e0 49 00 20 	cp.w	r9,32
8000cc3e:	c0 b2       	brcc	8000cc54 <__avr32_s32_to_f64+0x76>
8000cc40:	f4 08 09 4e 	lsl	lr,r10,r8
8000cc44:	f6 08 09 48 	lsl	r8,r11,r8
8000cc48:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cc4c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000cc50:	10 4b       	or	r11,r8
8000cc52:	c0 88       	rjmp	8000cc62 <__avr32_s32_to_f64+0x84>
8000cc54:	f6 08 09 4e 	lsl	lr,r11,r8
8000cc58:	14 4e       	or	lr,r10
8000cc5a:	16 9a       	mov	r10,r11
8000cc5c:	30 0b       	mov	r11,0
8000cc5e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cc62:	ed ba 00 00 	bld	r10,0x0
8000cc66:	c0 92       	brcc	8000cc78 <__avr32_s32_to_f64+0x9a>
8000cc68:	1c 7e       	tst	lr,lr
8000cc6a:	c0 41       	brne	8000cc72 <__avr32_s32_to_f64+0x94>
8000cc6c:	ed ba 00 01 	bld	r10,0x1
8000cc70:	c0 42       	brcc	8000cc78 <__avr32_s32_to_f64+0x9a>
8000cc72:	2f fa       	sub	r10,-1
8000cc74:	f7 bb 02 ff 	subhs	r11,-1
8000cc78:	5c fc       	rol	r12
8000cc7a:	5d 0b       	ror	r11
8000cc7c:	5d 0a       	ror	r10
8000cc7e:	d8 02       	popm	pc
8000cc80:	e0 68 03 ff 	mov	r8,1023
8000cc84:	ed ba 00 0b 	bld	r10,0xb
8000cc88:	f7 b8 00 ff 	subeq	r8,-1
8000cc8c:	10 0a       	add	r10,r8
8000cc8e:	5c 0b       	acr	r11
8000cc90:	f7 b9 03 fe 	sublo	r9,-2
8000cc94:	e0 49 07 ff 	cp.w	r9,2047
8000cc98:	c0 55       	brlt	8000cca2 <__avr32_s32_to_f64+0xc4>
8000cc9a:	30 0a       	mov	r10,0
8000cc9c:	fc 1b ff e0 	movh	r11,0xffe0
8000cca0:	c0 c8       	rjmp	8000ccb8 <__floatsidf_return_op1>
8000cca2:	ed bb 00 1f 	bld	r11,0x1f
8000cca6:	f7 b9 01 01 	subne	r9,1
8000ccaa:	ab 9a       	lsr	r10,0xb
8000ccac:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ccb0:	a1 7b       	lsl	r11,0x1
8000ccb2:	ab 9b       	lsr	r11,0xb
8000ccb4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000ccb8 <__floatsidf_return_op1>:
8000ccb8:	a1 7c       	lsl	r12,0x1
8000ccba:	5d 0b       	ror	r11
8000ccbc:	d8 02       	popm	pc

8000ccbe <__avr32_f64_cmp_eq>:
8000ccbe:	10 3a       	cp.w	r10,r8
8000ccc0:	f2 0b 13 00 	cpc	r11,r9
8000ccc4:	c0 80       	breq	8000ccd4 <__avr32_f64_cmp_eq+0x16>
8000ccc6:	a1 7b       	lsl	r11,0x1
8000ccc8:	a1 79       	lsl	r9,0x1
8000ccca:	14 4b       	or	r11,r10
8000cccc:	12 4b       	or	r11,r9
8000ccce:	10 4b       	or	r11,r8
8000ccd0:	5e 0f       	reteq	1
8000ccd2:	5e fd       	retal	0
8000ccd4:	a1 7b       	lsl	r11,0x1
8000ccd6:	fc 1c ff e0 	movh	r12,0xffe0
8000ccda:	58 0a       	cp.w	r10,0
8000ccdc:	f8 0b 13 00 	cpc	r11,r12
8000cce0:	5e 8f       	retls	1
8000cce2:	5e fd       	retal	0

8000cce4 <__avr32_f64_cmp_ge>:
8000cce4:	1a de       	st.w	--sp,lr
8000cce6:	1a d7       	st.w	--sp,r7
8000cce8:	a1 7b       	lsl	r11,0x1
8000ccea:	5f 3c       	srlo	r12
8000ccec:	a1 79       	lsl	r9,0x1
8000ccee:	5f 37       	srlo	r7
8000ccf0:	5c fc       	rol	r12
8000ccf2:	fc 1e ff e0 	movh	lr,0xffe0
8000ccf6:	58 0a       	cp.w	r10,0
8000ccf8:	fc 0b 13 00 	cpc	r11,lr
8000ccfc:	e0 8b 00 1d 	brhi	8000cd36 <__avr32_f64_cmp_ge+0x52>
8000cd00:	58 08       	cp.w	r8,0
8000cd02:	fc 09 13 00 	cpc	r9,lr
8000cd06:	e0 8b 00 18 	brhi	8000cd36 <__avr32_f64_cmp_ge+0x52>
8000cd0a:	58 0b       	cp.w	r11,0
8000cd0c:	f5 ba 00 00 	subfeq	r10,0
8000cd10:	c1 50       	breq	8000cd3a <__avr32_f64_cmp_ge+0x56>
8000cd12:	1b 07       	ld.w	r7,sp++
8000cd14:	1b 0e       	ld.w	lr,sp++
8000cd16:	58 3c       	cp.w	r12,3
8000cd18:	c0 a0       	breq	8000cd2c <__avr32_f64_cmp_ge+0x48>
8000cd1a:	58 1c       	cp.w	r12,1
8000cd1c:	c0 33       	brcs	8000cd22 <__avr32_f64_cmp_ge+0x3e>
8000cd1e:	5e 0f       	reteq	1
8000cd20:	5e 1d       	retne	0
8000cd22:	10 3a       	cp.w	r10,r8
8000cd24:	f2 0b 13 00 	cpc	r11,r9
8000cd28:	5e 2f       	reths	1
8000cd2a:	5e 3d       	retlo	0
8000cd2c:	14 38       	cp.w	r8,r10
8000cd2e:	f6 09 13 00 	cpc	r9,r11
8000cd32:	5e 2f       	reths	1
8000cd34:	5e 3d       	retlo	0
8000cd36:	1b 07       	ld.w	r7,sp++
8000cd38:	d8 0a       	popm	pc,r12=0
8000cd3a:	58 17       	cp.w	r7,1
8000cd3c:	5f 0c       	sreq	r12
8000cd3e:	58 09       	cp.w	r9,0
8000cd40:	f5 b8 00 00 	subfeq	r8,0
8000cd44:	1b 07       	ld.w	r7,sp++
8000cd46:	1b 0e       	ld.w	lr,sp++
8000cd48:	5e 0f       	reteq	1
8000cd4a:	5e fc       	retal	r12

8000cd4c <__avr32_f64_cmp_lt>:
8000cd4c:	1a de       	st.w	--sp,lr
8000cd4e:	1a d7       	st.w	--sp,r7
8000cd50:	a1 7b       	lsl	r11,0x1
8000cd52:	5f 3c       	srlo	r12
8000cd54:	a1 79       	lsl	r9,0x1
8000cd56:	5f 37       	srlo	r7
8000cd58:	5c fc       	rol	r12
8000cd5a:	fc 1e ff e0 	movh	lr,0xffe0
8000cd5e:	58 0a       	cp.w	r10,0
8000cd60:	fc 0b 13 00 	cpc	r11,lr
8000cd64:	e0 8b 00 1d 	brhi	8000cd9e <__avr32_f64_cmp_lt+0x52>
8000cd68:	58 08       	cp.w	r8,0
8000cd6a:	fc 09 13 00 	cpc	r9,lr
8000cd6e:	e0 8b 00 18 	brhi	8000cd9e <__avr32_f64_cmp_lt+0x52>
8000cd72:	58 0b       	cp.w	r11,0
8000cd74:	f5 ba 00 00 	subfeq	r10,0
8000cd78:	c1 50       	breq	8000cda2 <__avr32_f64_cmp_lt+0x56>
8000cd7a:	1b 07       	ld.w	r7,sp++
8000cd7c:	1b 0e       	ld.w	lr,sp++
8000cd7e:	58 3c       	cp.w	r12,3
8000cd80:	c0 a0       	breq	8000cd94 <__avr32_f64_cmp_lt+0x48>
8000cd82:	58 1c       	cp.w	r12,1
8000cd84:	c0 33       	brcs	8000cd8a <__avr32_f64_cmp_lt+0x3e>
8000cd86:	5e 0d       	reteq	0
8000cd88:	5e 1f       	retne	1
8000cd8a:	10 3a       	cp.w	r10,r8
8000cd8c:	f2 0b 13 00 	cpc	r11,r9
8000cd90:	5e 2d       	reths	0
8000cd92:	5e 3f       	retlo	1
8000cd94:	14 38       	cp.w	r8,r10
8000cd96:	f6 09 13 00 	cpc	r9,r11
8000cd9a:	5e 2d       	reths	0
8000cd9c:	5e 3f       	retlo	1
8000cd9e:	1b 07       	ld.w	r7,sp++
8000cda0:	d8 0a       	popm	pc,r12=0
8000cda2:	58 17       	cp.w	r7,1
8000cda4:	5f 1c       	srne	r12
8000cda6:	58 09       	cp.w	r9,0
8000cda8:	f5 b8 00 00 	subfeq	r8,0
8000cdac:	1b 07       	ld.w	r7,sp++
8000cdae:	1b 0e       	ld.w	lr,sp++
8000cdb0:	5e 0d       	reteq	0
8000cdb2:	5e fc       	retal	r12

8000cdb4 <__avr32_f64_div>:
8000cdb4:	eb cd 40 ff 	pushm	r0-r7,lr
8000cdb8:	f7 e9 20 0e 	eor	lr,r11,r9
8000cdbc:	f6 07 16 14 	lsr	r7,r11,0x14
8000cdc0:	a9 7b       	lsl	r11,0x9
8000cdc2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000cdc6:	a9 7a       	lsl	r10,0x9
8000cdc8:	bd bb       	sbr	r11,0x1d
8000cdca:	e4 1b 3f ff 	andh	r11,0x3fff
8000cdce:	ab d7       	cbr	r7,0xb
8000cdd0:	e0 80 00 cc 	breq	8000cf68 <__avr32_f64_div_round_subnormal+0x54>
8000cdd4:	e0 47 07 ff 	cp.w	r7,2047
8000cdd8:	e0 84 00 b5 	brge	8000cf42 <__avr32_f64_div_round_subnormal+0x2e>
8000cddc:	f2 06 16 14 	lsr	r6,r9,0x14
8000cde0:	a9 79       	lsl	r9,0x9
8000cde2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000cde6:	a9 78       	lsl	r8,0x9
8000cde8:	bd b9       	sbr	r9,0x1d
8000cdea:	e4 19 3f ff 	andh	r9,0x3fff
8000cdee:	ab d6       	cbr	r6,0xb
8000cdf0:	e0 80 00 e2 	breq	8000cfb4 <__avr32_f64_div_round_subnormal+0xa0>
8000cdf4:	e0 46 07 ff 	cp.w	r6,2047
8000cdf8:	e0 84 00 b2 	brge	8000cf5c <__avr32_f64_div_round_subnormal+0x48>
8000cdfc:	0c 17       	sub	r7,r6
8000cdfe:	fe 37 fc 01 	sub	r7,-1023
8000ce02:	fc 1c 80 00 	movh	r12,0x8000
8000ce06:	f8 03 16 01 	lsr	r3,r12,0x1
8000ce0a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000ce0e:	5c d4       	com	r4
8000ce10:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000ce14:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ce18:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000ce1c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ce20:	ea 03 15 02 	lsl	r3,r5,0x2
8000ce24:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ce28:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000ce2c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ce30:	ea 03 15 02 	lsl	r3,r5,0x2
8000ce34:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ce38:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000ce3c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ce40:	ea 03 15 02 	lsl	r3,r5,0x2
8000ce44:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ce48:	e4 09 07 40 	macu.d	r0,r2,r9
8000ce4c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ce50:	02 04       	add	r4,r1
8000ce52:	5c 05       	acr	r5
8000ce54:	a3 65       	lsl	r5,0x2
8000ce56:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000ce5a:	a3 64       	lsl	r4,0x2
8000ce5c:	5c 34       	neg	r4
8000ce5e:	f8 05 01 45 	sbc	r5,r12,r5
8000ce62:	e6 04 06 40 	mulu.d	r0,r3,r4
8000ce66:	e4 05 07 40 	macu.d	r0,r2,r5
8000ce6a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ce6e:	02 04       	add	r4,r1
8000ce70:	5c 05       	acr	r5
8000ce72:	ea 03 15 02 	lsl	r3,r5,0x2
8000ce76:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000ce7a:	e8 02 15 02 	lsl	r2,r4,0x2
8000ce7e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ce82:	e4 09 07 40 	macu.d	r0,r2,r9
8000ce86:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ce8a:	02 04       	add	r4,r1
8000ce8c:	5c 05       	acr	r5
8000ce8e:	a3 65       	lsl	r5,0x2
8000ce90:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000ce94:	a3 64       	lsl	r4,0x2
8000ce96:	5c 34       	neg	r4
8000ce98:	f8 05 01 45 	sbc	r5,r12,r5
8000ce9c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000cea0:	e4 05 07 40 	macu.d	r0,r2,r5
8000cea4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cea8:	02 04       	add	r4,r1
8000ceaa:	5c 05       	acr	r5
8000ceac:	ea 03 15 02 	lsl	r3,r5,0x2
8000ceb0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000ceb4:	e8 02 15 02 	lsl	r2,r4,0x2
8000ceb8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000cebc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000cec0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000cec4:	02 02       	add	r2,r1
8000cec6:	5c 03       	acr	r3
8000cec8:	ed b3 00 1c 	bld	r3,0x1c
8000cecc:	c0 90       	breq	8000cede <__avr32_f64_div+0x12a>
8000cece:	a1 72       	lsl	r2,0x1
8000ced0:	5c f3       	rol	r3
8000ced2:	20 17       	sub	r7,1
8000ced4:	a3 9a       	lsr	r10,0x3
8000ced6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000ceda:	a3 9b       	lsr	r11,0x3
8000cedc:	c0 58       	rjmp	8000cee6 <__avr32_f64_div+0x132>
8000cede:	a5 8a       	lsr	r10,0x4
8000cee0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000cee4:	a5 8b       	lsr	r11,0x4
8000cee6:	58 07       	cp.w	r7,0
8000cee8:	e0 8a 00 8b 	brle	8000cffe <__avr32_f64_div_res_subnormal>
8000ceec:	e0 12 ff 00 	andl	r2,0xff00
8000cef0:	e8 12 00 80 	orl	r2,0x80
8000cef4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000cef8:	e4 09 07 40 	macu.d	r0,r2,r9
8000cefc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000cf00:	e6 09 06 48 	mulu.d	r8,r3,r9
8000cf04:	00 05       	add	r5,r0
8000cf06:	f0 01 00 48 	adc	r8,r8,r1
8000cf0a:	5c 09       	acr	r9
8000cf0c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000cf10:	58 04       	cp.w	r4,0
8000cf12:	5c 25       	cpc	r5

8000cf14 <__avr32_f64_div_round_subnormal>:
8000cf14:	f4 08 13 00 	cpc	r8,r10
8000cf18:	f6 09 13 00 	cpc	r9,r11
8000cf1c:	5f 36       	srlo	r6
8000cf1e:	f8 06 17 00 	moveq	r6,r12
8000cf22:	e4 0a 16 08 	lsr	r10,r2,0x8
8000cf26:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000cf2a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000cf2e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000cf32:	ed be 00 1f 	bld	lr,0x1f
8000cf36:	ef bb 00 1f 	bst	r11,0x1f
8000cf3a:	0c 0a       	add	r10,r6
8000cf3c:	5c 0b       	acr	r11
8000cf3e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cf42:	e4 1b 00 0f 	andh	r11,0xf
8000cf46:	14 4b       	or	r11,r10
8000cf48:	e0 81 00 a7 	brne	8000d096 <__avr32_f64_div_res_subnormal+0x98>
8000cf4c:	f2 06 16 14 	lsr	r6,r9,0x14
8000cf50:	ab d6       	cbr	r6,0xb
8000cf52:	e0 46 07 ff 	cp.w	r6,2047
8000cf56:	e0 81 00 a4 	brne	8000d09e <__avr32_f64_div_res_subnormal+0xa0>
8000cf5a:	c9 e8       	rjmp	8000d096 <__avr32_f64_div_res_subnormal+0x98>
8000cf5c:	e4 19 00 0f 	andh	r9,0xf
8000cf60:	10 49       	or	r9,r8
8000cf62:	e0 81 00 9a 	brne	8000d096 <__avr32_f64_div_res_subnormal+0x98>
8000cf66:	c9 28       	rjmp	8000d08a <__avr32_f64_div_res_subnormal+0x8c>
8000cf68:	a3 7b       	lsl	r11,0x3
8000cf6a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000cf6e:	a3 7a       	lsl	r10,0x3
8000cf70:	f5 eb 10 04 	or	r4,r10,r11
8000cf74:	e0 80 00 a0 	breq	8000d0b4 <__avr32_f64_div_op1_zero>
8000cf78:	f6 04 12 00 	clz	r4,r11
8000cf7c:	c1 70       	breq	8000cfaa <__avr32_f64_div_round_subnormal+0x96>
8000cf7e:	c0 c3       	brcs	8000cf96 <__avr32_f64_div_round_subnormal+0x82>
8000cf80:	e8 05 11 20 	rsub	r5,r4,32
8000cf84:	f6 04 09 4b 	lsl	r11,r11,r4
8000cf88:	f4 05 0a 45 	lsr	r5,r10,r5
8000cf8c:	0a 4b       	or	r11,r5
8000cf8e:	f4 04 09 4a 	lsl	r10,r10,r4
8000cf92:	08 17       	sub	r7,r4
8000cf94:	c0 b8       	rjmp	8000cfaa <__avr32_f64_div_round_subnormal+0x96>
8000cf96:	f4 04 12 00 	clz	r4,r10
8000cf9a:	f9 b4 03 00 	movlo	r4,0
8000cf9e:	f7 b4 02 e0 	subhs	r4,-32
8000cfa2:	f4 04 09 4b 	lsl	r11,r10,r4
8000cfa6:	30 0a       	mov	r10,0
8000cfa8:	08 17       	sub	r7,r4
8000cfaa:	a3 8a       	lsr	r10,0x2
8000cfac:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000cfb0:	a3 8b       	lsr	r11,0x2
8000cfb2:	c1 1b       	rjmp	8000cdd4 <__avr32_f64_div+0x20>
8000cfb4:	a3 79       	lsl	r9,0x3
8000cfb6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000cfba:	a3 78       	lsl	r8,0x3
8000cfbc:	f3 e8 10 04 	or	r4,r9,r8
8000cfc0:	c6 f0       	breq	8000d09e <__avr32_f64_div_res_subnormal+0xa0>
8000cfc2:	f2 04 12 00 	clz	r4,r9
8000cfc6:	c1 70       	breq	8000cff4 <__avr32_f64_div_round_subnormal+0xe0>
8000cfc8:	c0 c3       	brcs	8000cfe0 <__avr32_f64_div_round_subnormal+0xcc>
8000cfca:	e8 05 11 20 	rsub	r5,r4,32
8000cfce:	f2 04 09 49 	lsl	r9,r9,r4
8000cfd2:	f0 05 0a 45 	lsr	r5,r8,r5
8000cfd6:	0a 49       	or	r9,r5
8000cfd8:	f0 04 09 48 	lsl	r8,r8,r4
8000cfdc:	08 16       	sub	r6,r4
8000cfde:	c0 b8       	rjmp	8000cff4 <__avr32_f64_div_round_subnormal+0xe0>
8000cfe0:	f0 04 12 00 	clz	r4,r8
8000cfe4:	f9 b4 03 00 	movlo	r4,0
8000cfe8:	f7 b4 02 e0 	subhs	r4,-32
8000cfec:	f0 04 09 49 	lsl	r9,r8,r4
8000cff0:	30 08       	mov	r8,0
8000cff2:	08 16       	sub	r6,r4
8000cff4:	a3 88       	lsr	r8,0x2
8000cff6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000cffa:	a3 89       	lsr	r9,0x2
8000cffc:	cf ca       	rjmp	8000cdf4 <__avr32_f64_div+0x40>

8000cffe <__avr32_f64_div_res_subnormal>:
8000cffe:	5c 37       	neg	r7
8000d000:	2f f7       	sub	r7,-1
8000d002:	f1 b7 04 c0 	satu	r7,0x6
8000d006:	e0 47 00 20 	cp.w	r7,32
8000d00a:	c1 54       	brge	8000d034 <__avr32_f64_div_res_subnormal+0x36>
8000d00c:	ee 06 11 20 	rsub	r6,r7,32
8000d010:	e4 07 0a 42 	lsr	r2,r2,r7
8000d014:	e6 06 09 4c 	lsl	r12,r3,r6
8000d018:	18 42       	or	r2,r12
8000d01a:	e6 07 0a 43 	lsr	r3,r3,r7
8000d01e:	f4 06 09 41 	lsl	r1,r10,r6
8000d022:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d026:	f6 06 09 4c 	lsl	r12,r11,r6
8000d02a:	18 4a       	or	r10,r12
8000d02c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d030:	30 00       	mov	r0,0
8000d032:	c1 58       	rjmp	8000d05c <__avr32_f64_div_res_subnormal+0x5e>
8000d034:	ee 06 11 20 	rsub	r6,r7,32
8000d038:	f9 b0 00 00 	moveq	r0,0
8000d03c:	f9 bc 00 00 	moveq	r12,0
8000d040:	c0 50       	breq	8000d04a <__avr32_f64_div_res_subnormal+0x4c>
8000d042:	f4 06 09 40 	lsl	r0,r10,r6
8000d046:	f6 06 09 4c 	lsl	r12,r11,r6
8000d04a:	e6 07 0a 42 	lsr	r2,r3,r7
8000d04e:	30 03       	mov	r3,0
8000d050:	f4 07 0a 41 	lsr	r1,r10,r7
8000d054:	18 41       	or	r1,r12
8000d056:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d05a:	30 0b       	mov	r11,0
8000d05c:	e0 12 ff 00 	andl	r2,0xff00
8000d060:	e8 12 00 80 	orl	r2,0x80
8000d064:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d068:	e4 09 07 46 	macu.d	r6,r2,r9
8000d06c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d070:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d074:	0c 05       	add	r5,r6
8000d076:	f0 07 00 48 	adc	r8,r8,r7
8000d07a:	5c 09       	acr	r9
8000d07c:	30 07       	mov	r7,0
8000d07e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d082:	00 34       	cp.w	r4,r0
8000d084:	e2 05 13 00 	cpc	r5,r1
8000d088:	c4 6b       	rjmp	8000cf14 <__avr32_f64_div_round_subnormal>
8000d08a:	1c 9b       	mov	r11,lr
8000d08c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d090:	30 0a       	mov	r10,0
8000d092:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d096:	3f fb       	mov	r11,-1
8000d098:	30 0a       	mov	r10,0
8000d09a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d09e:	f5 eb 10 04 	or	r4,r10,r11
8000d0a2:	c0 90       	breq	8000d0b4 <__avr32_f64_div_op1_zero>
8000d0a4:	1c 9b       	mov	r11,lr
8000d0a6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d0aa:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d0ae:	30 0a       	mov	r10,0
8000d0b0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d0b4 <__avr32_f64_div_op1_zero>:
8000d0b4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d0b8:	ce f0       	breq	8000d096 <__avr32_f64_div_res_subnormal+0x98>
8000d0ba:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d0be:	e0 44 07 ff 	cp.w	r4,2047
8000d0c2:	ce 41       	brne	8000d08a <__avr32_f64_div_res_subnormal+0x8c>
8000d0c4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d0c8:	ce 10       	breq	8000d08a <__avr32_f64_div_res_subnormal+0x8c>
8000d0ca:	ce 6b       	rjmp	8000d096 <__avr32_f64_div_res_subnormal+0x98>

8000d0cc <__avr32_udiv64>:
8000d0cc:	d4 31       	pushm	r0-r7,lr
8000d0ce:	1a 97       	mov	r7,sp
8000d0d0:	20 3d       	sub	sp,12
8000d0d2:	10 9c       	mov	r12,r8
8000d0d4:	12 9e       	mov	lr,r9
8000d0d6:	14 93       	mov	r3,r10
8000d0d8:	58 09       	cp.w	r9,0
8000d0da:	e0 81 00 bd 	brne	8000d254 <__avr32_udiv64+0x188>
8000d0de:	16 38       	cp.w	r8,r11
8000d0e0:	e0 88 00 40 	brls	8000d160 <__avr32_udiv64+0x94>
8000d0e4:	f0 08 12 00 	clz	r8,r8
8000d0e8:	c0 d0       	breq	8000d102 <__avr32_udiv64+0x36>
8000d0ea:	f6 08 09 4b 	lsl	r11,r11,r8
8000d0ee:	f0 09 11 20 	rsub	r9,r8,32
8000d0f2:	f8 08 09 4c 	lsl	r12,r12,r8
8000d0f6:	f4 09 0a 49 	lsr	r9,r10,r9
8000d0fa:	f4 08 09 43 	lsl	r3,r10,r8
8000d0fe:	f3 eb 10 0b 	or	r11,r9,r11
8000d102:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d106:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d10a:	f6 0e 0d 00 	divu	r0,r11,lr
8000d10e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d112:	00 99       	mov	r9,r0
8000d114:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d118:	e0 0a 02 48 	mul	r8,r0,r10
8000d11c:	10 3b       	cp.w	r11,r8
8000d11e:	c0 a2       	brcc	8000d132 <__avr32_udiv64+0x66>
8000d120:	20 19       	sub	r9,1
8000d122:	18 0b       	add	r11,r12
8000d124:	18 3b       	cp.w	r11,r12
8000d126:	c0 63       	brcs	8000d132 <__avr32_udiv64+0x66>
8000d128:	10 3b       	cp.w	r11,r8
8000d12a:	f7 b9 03 01 	sublo	r9,1
8000d12e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d132:	f6 08 01 01 	sub	r1,r11,r8
8000d136:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d13a:	e2 0e 0d 00 	divu	r0,r1,lr
8000d13e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d142:	00 98       	mov	r8,r0
8000d144:	e0 0a 02 4a 	mul	r10,r0,r10
8000d148:	14 33       	cp.w	r3,r10
8000d14a:	c0 82       	brcc	8000d15a <__avr32_udiv64+0x8e>
8000d14c:	20 18       	sub	r8,1
8000d14e:	18 03       	add	r3,r12
8000d150:	18 33       	cp.w	r3,r12
8000d152:	c0 43       	brcs	8000d15a <__avr32_udiv64+0x8e>
8000d154:	14 33       	cp.w	r3,r10
8000d156:	f7 b8 03 01 	sublo	r8,1
8000d15a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d15e:	cd f8       	rjmp	8000d31c <__avr32_udiv64+0x250>
8000d160:	58 08       	cp.w	r8,0
8000d162:	c0 51       	brne	8000d16c <__avr32_udiv64+0xa0>
8000d164:	30 19       	mov	r9,1
8000d166:	f2 08 0d 08 	divu	r8,r9,r8
8000d16a:	10 9c       	mov	r12,r8
8000d16c:	f8 06 12 00 	clz	r6,r12
8000d170:	c0 41       	brne	8000d178 <__avr32_udiv64+0xac>
8000d172:	18 1b       	sub	r11,r12
8000d174:	30 19       	mov	r9,1
8000d176:	c4 08       	rjmp	8000d1f6 <__avr32_udiv64+0x12a>
8000d178:	ec 01 11 20 	rsub	r1,r6,32
8000d17c:	f4 01 0a 49 	lsr	r9,r10,r1
8000d180:	f8 06 09 4c 	lsl	r12,r12,r6
8000d184:	f6 06 09 48 	lsl	r8,r11,r6
8000d188:	f6 01 0a 41 	lsr	r1,r11,r1
8000d18c:	f3 e8 10 08 	or	r8,r9,r8
8000d190:	f8 03 16 10 	lsr	r3,r12,0x10
8000d194:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d198:	e2 03 0d 00 	divu	r0,r1,r3
8000d19c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d1a0:	00 9e       	mov	lr,r0
8000d1a2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d1a6:	e0 05 02 49 	mul	r9,r0,r5
8000d1aa:	12 3b       	cp.w	r11,r9
8000d1ac:	c0 a2       	brcc	8000d1c0 <__avr32_udiv64+0xf4>
8000d1ae:	20 1e       	sub	lr,1
8000d1b0:	18 0b       	add	r11,r12
8000d1b2:	18 3b       	cp.w	r11,r12
8000d1b4:	c0 63       	brcs	8000d1c0 <__avr32_udiv64+0xf4>
8000d1b6:	12 3b       	cp.w	r11,r9
8000d1b8:	f7 be 03 01 	sublo	lr,1
8000d1bc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d1c0:	12 1b       	sub	r11,r9
8000d1c2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d1c6:	f6 03 0d 02 	divu	r2,r11,r3
8000d1ca:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d1ce:	04 99       	mov	r9,r2
8000d1d0:	e4 05 02 4b 	mul	r11,r2,r5
8000d1d4:	16 38       	cp.w	r8,r11
8000d1d6:	c0 a2       	brcc	8000d1ea <__avr32_udiv64+0x11e>
8000d1d8:	20 19       	sub	r9,1
8000d1da:	18 08       	add	r8,r12
8000d1dc:	18 38       	cp.w	r8,r12
8000d1de:	c0 63       	brcs	8000d1ea <__avr32_udiv64+0x11e>
8000d1e0:	16 38       	cp.w	r8,r11
8000d1e2:	f7 b9 03 01 	sublo	r9,1
8000d1e6:	f1 dc e3 08 	addcs	r8,r8,r12
8000d1ea:	f4 06 09 43 	lsl	r3,r10,r6
8000d1ee:	f0 0b 01 0b 	sub	r11,r8,r11
8000d1f2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d1f6:	f8 06 16 10 	lsr	r6,r12,0x10
8000d1fa:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d1fe:	f6 06 0d 00 	divu	r0,r11,r6
8000d202:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d206:	00 9a       	mov	r10,r0
8000d208:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d20c:	e0 0e 02 48 	mul	r8,r0,lr
8000d210:	10 3b       	cp.w	r11,r8
8000d212:	c0 a2       	brcc	8000d226 <__avr32_udiv64+0x15a>
8000d214:	20 1a       	sub	r10,1
8000d216:	18 0b       	add	r11,r12
8000d218:	18 3b       	cp.w	r11,r12
8000d21a:	c0 63       	brcs	8000d226 <__avr32_udiv64+0x15a>
8000d21c:	10 3b       	cp.w	r11,r8
8000d21e:	f7 ba 03 01 	sublo	r10,1
8000d222:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d226:	f6 08 01 01 	sub	r1,r11,r8
8000d22a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d22e:	e2 06 0d 00 	divu	r0,r1,r6
8000d232:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d236:	00 98       	mov	r8,r0
8000d238:	e0 0e 02 4b 	mul	r11,r0,lr
8000d23c:	16 33       	cp.w	r3,r11
8000d23e:	c0 82       	brcc	8000d24e <__avr32_udiv64+0x182>
8000d240:	20 18       	sub	r8,1
8000d242:	18 03       	add	r3,r12
8000d244:	18 33       	cp.w	r3,r12
8000d246:	c0 43       	brcs	8000d24e <__avr32_udiv64+0x182>
8000d248:	16 33       	cp.w	r3,r11
8000d24a:	f7 b8 03 01 	sublo	r8,1
8000d24e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d252:	c6 98       	rjmp	8000d324 <__avr32_udiv64+0x258>
8000d254:	16 39       	cp.w	r9,r11
8000d256:	e0 8b 00 65 	brhi	8000d320 <__avr32_udiv64+0x254>
8000d25a:	f2 09 12 00 	clz	r9,r9
8000d25e:	c0 b1       	brne	8000d274 <__avr32_udiv64+0x1a8>
8000d260:	10 3a       	cp.w	r10,r8
8000d262:	5f 2a       	srhs	r10
8000d264:	1c 3b       	cp.w	r11,lr
8000d266:	5f b8       	srhi	r8
8000d268:	10 4a       	or	r10,r8
8000d26a:	f2 0a 18 00 	cp.b	r10,r9
8000d26e:	c5 90       	breq	8000d320 <__avr32_udiv64+0x254>
8000d270:	30 18       	mov	r8,1
8000d272:	c5 98       	rjmp	8000d324 <__avr32_udiv64+0x258>
8000d274:	f0 09 09 46 	lsl	r6,r8,r9
8000d278:	f2 03 11 20 	rsub	r3,r9,32
8000d27c:	fc 09 09 4e 	lsl	lr,lr,r9
8000d280:	f0 03 0a 48 	lsr	r8,r8,r3
8000d284:	f6 09 09 4c 	lsl	r12,r11,r9
8000d288:	f4 03 0a 42 	lsr	r2,r10,r3
8000d28c:	ef 46 ff f4 	st.w	r7[-12],r6
8000d290:	f6 03 0a 43 	lsr	r3,r11,r3
8000d294:	18 42       	or	r2,r12
8000d296:	f1 ee 10 0c 	or	r12,r8,lr
8000d29a:	f8 01 16 10 	lsr	r1,r12,0x10
8000d29e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d2a2:	e6 01 0d 04 	divu	r4,r3,r1
8000d2a6:	e4 03 16 10 	lsr	r3,r2,0x10
8000d2aa:	08 9e       	mov	lr,r4
8000d2ac:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000d2b0:	e8 06 02 48 	mul	r8,r4,r6
8000d2b4:	10 33       	cp.w	r3,r8
8000d2b6:	c0 a2       	brcc	8000d2ca <__avr32_udiv64+0x1fe>
8000d2b8:	20 1e       	sub	lr,1
8000d2ba:	18 03       	add	r3,r12
8000d2bc:	18 33       	cp.w	r3,r12
8000d2be:	c0 63       	brcs	8000d2ca <__avr32_udiv64+0x1fe>
8000d2c0:	10 33       	cp.w	r3,r8
8000d2c2:	f7 be 03 01 	sublo	lr,1
8000d2c6:	e7 dc e3 03 	addcs	r3,r3,r12
8000d2ca:	10 13       	sub	r3,r8
8000d2cc:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000d2d0:	e6 01 0d 00 	divu	r0,r3,r1
8000d2d4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d2d8:	00 98       	mov	r8,r0
8000d2da:	e0 06 02 46 	mul	r6,r0,r6
8000d2de:	0c 3b       	cp.w	r11,r6
8000d2e0:	c0 a2       	brcc	8000d2f4 <__avr32_udiv64+0x228>
8000d2e2:	20 18       	sub	r8,1
8000d2e4:	18 0b       	add	r11,r12
8000d2e6:	18 3b       	cp.w	r11,r12
8000d2e8:	c0 63       	brcs	8000d2f4 <__avr32_udiv64+0x228>
8000d2ea:	0c 3b       	cp.w	r11,r6
8000d2ec:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d2f0:	f7 b8 03 01 	sublo	r8,1
8000d2f4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000d2f8:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000d2fc:	0c 1b       	sub	r11,r6
8000d2fe:	f0 04 06 42 	mulu.d	r2,r8,r4
8000d302:	06 95       	mov	r5,r3
8000d304:	16 35       	cp.w	r5,r11
8000d306:	e0 8b 00 0a 	brhi	8000d31a <__avr32_udiv64+0x24e>
8000d30a:	5f 0b       	sreq	r11
8000d30c:	f4 09 09 49 	lsl	r9,r10,r9
8000d310:	12 32       	cp.w	r2,r9
8000d312:	5f b9       	srhi	r9
8000d314:	f7 e9 00 09 	and	r9,r11,r9
8000d318:	c0 60       	breq	8000d324 <__avr32_udiv64+0x258>
8000d31a:	20 18       	sub	r8,1
8000d31c:	30 09       	mov	r9,0
8000d31e:	c0 38       	rjmp	8000d324 <__avr32_udiv64+0x258>
8000d320:	30 09       	mov	r9,0
8000d322:	12 98       	mov	r8,r9
8000d324:	10 9a       	mov	r10,r8
8000d326:	12 93       	mov	r3,r9
8000d328:	10 92       	mov	r2,r8
8000d32a:	12 9b       	mov	r11,r9
8000d32c:	2f dd       	sub	sp,-12
8000d32e:	d8 32       	popm	r0-r7,pc

8000d330 <__avr32_umod64>:
8000d330:	d4 31       	pushm	r0-r7,lr
8000d332:	1a 97       	mov	r7,sp
8000d334:	20 3d       	sub	sp,12
8000d336:	10 9c       	mov	r12,r8
8000d338:	12 95       	mov	r5,r9
8000d33a:	14 9e       	mov	lr,r10
8000d33c:	16 91       	mov	r1,r11
8000d33e:	16 96       	mov	r6,r11
8000d340:	58 09       	cp.w	r9,0
8000d342:	e0 81 00 81 	brne	8000d444 <__avr32_umod64+0x114>
8000d346:	16 38       	cp.w	r8,r11
8000d348:	e0 88 00 12 	brls	8000d36c <__avr32_umod64+0x3c>
8000d34c:	f0 08 12 00 	clz	r8,r8
8000d350:	c4 e0       	breq	8000d3ec <__avr32_umod64+0xbc>
8000d352:	f6 08 09 46 	lsl	r6,r11,r8
8000d356:	f8 08 09 4c 	lsl	r12,r12,r8
8000d35a:	f0 0b 11 20 	rsub	r11,r8,32
8000d35e:	f4 08 09 4e 	lsl	lr,r10,r8
8000d362:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000d366:	f7 e6 10 06 	or	r6,r11,r6
8000d36a:	c4 18       	rjmp	8000d3ec <__avr32_umod64+0xbc>
8000d36c:	58 08       	cp.w	r8,0
8000d36e:	c0 51       	brne	8000d378 <__avr32_umod64+0x48>
8000d370:	30 19       	mov	r9,1
8000d372:	f2 08 0d 08 	divu	r8,r9,r8
8000d376:	10 9c       	mov	r12,r8
8000d378:	f8 08 12 00 	clz	r8,r12
8000d37c:	c0 31       	brne	8000d382 <__avr32_umod64+0x52>
8000d37e:	18 16       	sub	r6,r12
8000d380:	c3 68       	rjmp	8000d3ec <__avr32_umod64+0xbc>
8000d382:	f0 03 11 20 	rsub	r3,r8,32
8000d386:	f4 03 0a 4b 	lsr	r11,r10,r3
8000d38a:	f8 08 09 4c 	lsl	r12,r12,r8
8000d38e:	ec 08 09 49 	lsl	r9,r6,r8
8000d392:	ec 03 0a 43 	lsr	r3,r6,r3
8000d396:	f7 e9 10 09 	or	r9,r11,r9
8000d39a:	f8 05 16 10 	lsr	r5,r12,0x10
8000d39e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d3a2:	e6 05 0d 02 	divu	r2,r3,r5
8000d3a6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000d3aa:	ec 02 02 4b 	mul	r11,r6,r2
8000d3ae:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000d3b2:	16 3e       	cp.w	lr,r11
8000d3b4:	c0 72       	brcc	8000d3c2 <__avr32_umod64+0x92>
8000d3b6:	18 0e       	add	lr,r12
8000d3b8:	18 3e       	cp.w	lr,r12
8000d3ba:	c0 43       	brcs	8000d3c2 <__avr32_umod64+0x92>
8000d3bc:	16 3e       	cp.w	lr,r11
8000d3be:	fd dc e3 0e 	addcs	lr,lr,r12
8000d3c2:	fc 0b 01 03 	sub	r3,lr,r11
8000d3c6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000d3ca:	e6 05 0d 02 	divu	r2,r3,r5
8000d3ce:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d3d2:	a5 36       	mul	r6,r2
8000d3d4:	0c 39       	cp.w	r9,r6
8000d3d6:	c0 72       	brcc	8000d3e4 <__avr32_umod64+0xb4>
8000d3d8:	18 09       	add	r9,r12
8000d3da:	18 39       	cp.w	r9,r12
8000d3dc:	c0 43       	brcs	8000d3e4 <__avr32_umod64+0xb4>
8000d3de:	0c 39       	cp.w	r9,r6
8000d3e0:	f3 dc e3 09 	addcs	r9,r9,r12
8000d3e4:	f2 06 01 06 	sub	r6,r9,r6
8000d3e8:	f4 08 09 4e 	lsl	lr,r10,r8
8000d3ec:	f8 0a 16 10 	lsr	r10,r12,0x10
8000d3f0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d3f4:	ec 0a 0d 02 	divu	r2,r6,r10
8000d3f8:	fc 09 16 10 	lsr	r9,lr,0x10
8000d3fc:	ea 02 02 4b 	mul	r11,r5,r2
8000d400:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d404:	16 39       	cp.w	r9,r11
8000d406:	c0 72       	brcc	8000d414 <__avr32_umod64+0xe4>
8000d408:	18 09       	add	r9,r12
8000d40a:	18 39       	cp.w	r9,r12
8000d40c:	c0 43       	brcs	8000d414 <__avr32_umod64+0xe4>
8000d40e:	16 39       	cp.w	r9,r11
8000d410:	f3 dc e3 09 	addcs	r9,r9,r12
8000d414:	f2 0b 01 0b 	sub	r11,r9,r11
8000d418:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d41c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000d420:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000d424:	ea 0a 02 4a 	mul	r10,r5,r10
8000d428:	14 3e       	cp.w	lr,r10
8000d42a:	c0 72       	brcc	8000d438 <__avr32_umod64+0x108>
8000d42c:	18 0e       	add	lr,r12
8000d42e:	18 3e       	cp.w	lr,r12
8000d430:	c0 43       	brcs	8000d438 <__avr32_umod64+0x108>
8000d432:	14 3e       	cp.w	lr,r10
8000d434:	fd dc e3 0e 	addcs	lr,lr,r12
8000d438:	fc 0a 01 0a 	sub	r10,lr,r10
8000d43c:	30 0b       	mov	r11,0
8000d43e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000d442:	c7 b8       	rjmp	8000d538 <__avr32_umod64+0x208>
8000d444:	16 39       	cp.w	r9,r11
8000d446:	e0 8b 00 79 	brhi	8000d538 <__avr32_umod64+0x208>
8000d44a:	f2 09 12 00 	clz	r9,r9
8000d44e:	c1 21       	brne	8000d472 <__avr32_umod64+0x142>
8000d450:	10 3a       	cp.w	r10,r8
8000d452:	5f 2b       	srhs	r11
8000d454:	0a 31       	cp.w	r1,r5
8000d456:	5f ba       	srhi	r10
8000d458:	f7 ea 10 0a 	or	r10,r11,r10
8000d45c:	f2 0a 18 00 	cp.b	r10,r9
8000d460:	c0 60       	breq	8000d46c <__avr32_umod64+0x13c>
8000d462:	fc 08 01 0c 	sub	r12,lr,r8
8000d466:	e2 05 01 46 	sbc	r6,r1,r5
8000d46a:	18 9e       	mov	lr,r12
8000d46c:	0c 9b       	mov	r11,r6
8000d46e:	1c 9a       	mov	r10,lr
8000d470:	c6 48       	rjmp	8000d538 <__avr32_umod64+0x208>
8000d472:	ea 09 09 4c 	lsl	r12,r5,r9
8000d476:	f2 06 11 20 	rsub	r6,r9,32
8000d47a:	f6 09 09 4b 	lsl	r11,r11,r9
8000d47e:	f0 09 09 42 	lsl	r2,r8,r9
8000d482:	ef 46 ff f4 	st.w	r7[-12],r6
8000d486:	f0 06 0a 48 	lsr	r8,r8,r6
8000d48a:	18 48       	or	r8,r12
8000d48c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000d490:	f4 09 09 43 	lsl	r3,r10,r9
8000d494:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000d498:	f4 06 0a 4a 	lsr	r10,r10,r6
8000d49c:	16 4a       	or	r10,r11
8000d49e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d4a2:	f8 0b 0d 04 	divu	r4,r12,r11
8000d4a6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000d4aa:	08 91       	mov	r1,r4
8000d4ac:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000d4b0:	e8 0e 02 46 	mul	r6,r4,lr
8000d4b4:	0c 3c       	cp.w	r12,r6
8000d4b6:	c0 a2       	brcc	8000d4ca <__avr32_umod64+0x19a>
8000d4b8:	20 11       	sub	r1,1
8000d4ba:	10 0c       	add	r12,r8
8000d4bc:	10 3c       	cp.w	r12,r8
8000d4be:	c0 63       	brcs	8000d4ca <__avr32_umod64+0x19a>
8000d4c0:	0c 3c       	cp.w	r12,r6
8000d4c2:	f7 b1 03 01 	sublo	r1,1
8000d4c6:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000d4ca:	0c 1c       	sub	r12,r6
8000d4cc:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000d4d0:	f8 0b 0d 04 	divu	r4,r12,r11
8000d4d4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000d4d8:	08 96       	mov	r6,r4
8000d4da:	e8 0e 02 4e 	mul	lr,r4,lr
8000d4de:	1c 3b       	cp.w	r11,lr
8000d4e0:	c0 a2       	brcc	8000d4f4 <__avr32_umod64+0x1c4>
8000d4e2:	20 16       	sub	r6,1
8000d4e4:	10 0b       	add	r11,r8
8000d4e6:	10 3b       	cp.w	r11,r8
8000d4e8:	c0 63       	brcs	8000d4f4 <__avr32_umod64+0x1c4>
8000d4ea:	1c 3b       	cp.w	r11,lr
8000d4ec:	f7 b6 03 01 	sublo	r6,1
8000d4f0:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000d4f4:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000d4f8:	1c 1b       	sub	r11,lr
8000d4fa:	e2 02 06 40 	mulu.d	r0,r1,r2
8000d4fe:	00 9e       	mov	lr,r0
8000d500:	02 9c       	mov	r12,r1
8000d502:	16 3c       	cp.w	r12,r11
8000d504:	e0 8b 00 08 	brhi	8000d514 <__avr32_umod64+0x1e4>
8000d508:	5f 06       	sreq	r6
8000d50a:	06 30       	cp.w	r0,r3
8000d50c:	5f ba       	srhi	r10
8000d50e:	ed ea 00 0a 	and	r10,r6,r10
8000d512:	c0 60       	breq	8000d51e <__avr32_umod64+0x1ee>
8000d514:	fc 02 01 04 	sub	r4,lr,r2
8000d518:	f8 08 01 4c 	sbc	r12,r12,r8
8000d51c:	08 9e       	mov	lr,r4
8000d51e:	e6 0e 01 0a 	sub	r10,r3,lr
8000d522:	f6 0c 01 4c 	sbc	r12,r11,r12
8000d526:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000d52a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000d52e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d532:	f8 01 09 4c 	lsl	r12,r12,r1
8000d536:	18 4a       	or	r10,r12
8000d538:	2f dd       	sub	sp,-12
8000d53a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000d600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000d600:	c0 08       	rjmp	8000d600 <_evba>
	...

8000d604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000d604:	c0 08       	rjmp	8000d604 <_handle_TLB_Multiple_Hit>
	...

8000d608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000d608:	c0 08       	rjmp	8000d608 <_handle_Bus_Error_Data_Fetch>
	...

8000d60c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000d60c:	c0 08       	rjmp	8000d60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000d610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000d610:	c0 08       	rjmp	8000d610 <_handle_NMI>
	...

8000d614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000d614:	c0 08       	rjmp	8000d614 <_handle_Instruction_Address>
	...

8000d618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000d618:	c0 08       	rjmp	8000d618 <_handle_ITLB_Protection>
	...

8000d61c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000d61c:	c0 08       	rjmp	8000d61c <_handle_Breakpoint>
	...

8000d620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000d620:	c0 08       	rjmp	8000d620 <_handle_Illegal_Opcode>
	...

8000d624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000d624:	c0 08       	rjmp	8000d624 <_handle_Unimplemented_Instruction>
	...

8000d628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000d628:	c0 08       	rjmp	8000d628 <_handle_Privilege_Violation>
	...

8000d62c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000d62c:	c0 08       	rjmp	8000d62c <_handle_Floating_Point>
	...

8000d630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000d630:	c0 08       	rjmp	8000d630 <_handle_Coprocessor_Absent>
	...

8000d634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000d634:	c0 08       	rjmp	8000d634 <_handle_Data_Address_Read>
	...

8000d638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000d638:	c0 08       	rjmp	8000d638 <_handle_Data_Address_Write>
	...

8000d63c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000d63c:	c0 08       	rjmp	8000d63c <_handle_DTLB_Protection_Read>
	...

8000d640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000d640:	c0 08       	rjmp	8000d640 <_handle_DTLB_Protection_Write>
	...

8000d644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000d644:	c0 08       	rjmp	8000d644 <_handle_DTLB_Modified>
	...

8000d650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000d650:	c0 08       	rjmp	8000d650 <_handle_ITLB_Miss>
	...

8000d660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000d660:	c0 08       	rjmp	8000d660 <_handle_DTLB_Miss_Read>
	...

8000d670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000d670:	c0 08       	rjmp	8000d670 <_handle_DTLB_Miss_Write>
	...

8000d700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000d700:	fe cf 70 04 	sub	pc,pc,28676

8000d704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000d704:	30 0c       	mov	r12,0
8000d706:	fe b0 c3 61 	rcall	80005dc8 <_get_interrupt_handler>
8000d70a:	58 0c       	cp.w	r12,0
8000d70c:	f8 0f 17 10 	movne	pc,r12
8000d710:	d6 03       	rete

8000d712 <_int1>:
8000d712:	30 1c       	mov	r12,1
8000d714:	fe b0 c3 5a 	rcall	80005dc8 <_get_interrupt_handler>
8000d718:	58 0c       	cp.w	r12,0
8000d71a:	f8 0f 17 10 	movne	pc,r12
8000d71e:	d6 03       	rete

8000d720 <_int2>:
8000d720:	30 2c       	mov	r12,2
8000d722:	fe b0 c3 53 	rcall	80005dc8 <_get_interrupt_handler>
8000d726:	58 0c       	cp.w	r12,0
8000d728:	f8 0f 17 10 	movne	pc,r12
8000d72c:	d6 03       	rete

8000d72e <_int3>:
8000d72e:	30 3c       	mov	r12,3
8000d730:	fe b0 c3 4c 	rcall	80005dc8 <_get_interrupt_handler>
8000d734:	58 0c       	cp.w	r12,0
8000d736:	f8 0f 17 10 	movne	pc,r12
8000d73a:	d6 03       	rete

8000d73c <ipr_val>:
8000d73c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000d74c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d75c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d76c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d77c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d78c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d79c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7fc:	d7 03 d7 03                                         ....
