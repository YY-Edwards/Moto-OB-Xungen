
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a49c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c600  8000c600  0000ca00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000115c  8000c800  8000c800  0000cc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000d95c  8000d95c  0000dd5c  2**0
                  ALLOC
  6 .data         00000a38  00000004  8000d960  0000e004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e398  0000ea3c  2**0
                  ALLOC
  8 .bss          00005960  00000a40  8000e398  0000ea40  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000ea3c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000011f0  00000000  00000000  0000ea70  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00002740  00000000  00000000  0000fc60  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00028ea2  00000000  00000000  000123a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006b56  00000000  00000000  0003b242  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c4a0  00000000  00000000  00041d98  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002f88  00000000  00000000  0004e238  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000073b2  00000000  00000000  000511c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d214  00000000  00000000  00058572  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 000012c8  00000000  00000000  00065788  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf cb 8c 	sub	pc,pc,-13428

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 84       	ld.ub	r4,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	43 14       	lddsp	r4,sp[0xc4]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 04       	sub	r4,16
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	21 18       	sub	r8,17
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2f 14       	sub	r4,-15
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	c8 00       	breq	80001f82 <_trampoline+0x1f82>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	63 b4       	ld.w	r4,r1[0x6c]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 44       	or	r4,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 17 	mcall	800020ec <app_cfg+0x5c>
80002096:	49 78       	lddpc	r8,800020f0 <app_cfg+0x60>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209a:	49 76       	lddpc	r6,800020f4 <app_cfg+0x64>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000209c:	49 77       	lddpc	r7,800020f8 <app_cfg+0x68>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000209e:	30 62       	mov	r2,6
800020a0:	30 13       	mov	r3,1
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			connect_flag=1;	
800020a2:	30 11       	mov	r1,1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020a4:	30 c0       	mov	r0,12
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a6:	10 95       	mov	r5,r8
800020a8:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020ac:	6c 08       	ld.w	r8,r6[0x0]
800020ae:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b2:	58 38       	cp.w	r8,3
800020b4:	c0 a1       	brne	800020c8 <app_cfg+0x38>
800020b6:	0f 88       	ld.ub	r8,r7[0x0]
800020b8:	58 08       	cp.w	r8,0
800020ba:	c0 71       	brne	800020c8 <app_cfg+0x38>
		{	
			connect_flag=1;	
800020bc:	ae 81       	st.b	r7[0x0],r1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020be:	00 9b       	mov	r11,r0
800020c0:	06 9c       	mov	r12,r3
800020c2:	f0 1f 00 0f 	mcall	800020fc <app_cfg+0x6c>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c6:	c0 d8       	rjmp	800020e0 <app_cfg+0x50>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
800020c8:	0f 88       	ld.ub	r8,r7[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 30       	breq	800020d2 <app_cfg+0x42>
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
800020ce:	d7 03       	nop
800020d0:	c0 88       	rjmp	800020e0 <app_cfg+0x50>
				
		}
		else
		{
			nop();
800020d2:	d7 03       	nop
			nop();
800020d4:	d7 03       	nop
			nop();
800020d6:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
800020d8:	04 9b       	mov	r11,r2
800020da:	06 9c       	mov	r12,r3
800020dc:	f0 1f 00 08 	mcall	800020fc <app_cfg+0x6c>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020e0:	08 9b       	mov	r11,r4
800020e2:	0a 9c       	mov	r12,r5
800020e4:	f0 1f 00 07 	mcall	80002100 <app_cfg+0x70>
	}
800020e8:	ce 2b       	rjmp	800020ac <app_cfg+0x1c>
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	60 a4       	ld.w	r4,r0[0x28]
800020f0:	00 00       	add	r0,r0
800020f2:	0a 50       	eor	r0,r5
800020f4:	00 00       	add	r0,r0
800020f6:	0d 84       	ld.ub	r4,r6[0x0]
800020f8:	00 00       	add	r0,r0
800020fa:	0a 4e       	or	lr,r5
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	44 14       	lddsp	r4,sp[0x104]
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	62 54       	ld.w	r4,r1[0x14]

80002104 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002104:	d4 01       	pushm	lr
  log("R");
80002106:	48 3c       	lddpc	r12,80002110 <app_payload_tx_proc+0xc>
80002108:	f0 1f 00 03 	mcall	80002114 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000210c:	d8 02       	popm	pc
8000210e:	00 00       	add	r0,r0
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	c8 08       	rjmp	80002212 <SingleDetection_brdcst_func+0x6>
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	67 78       	ld.w	r8,r3[0x5c]

80002118 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002118:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000211a:	48 99       	lddpc	r9,8000213c <app_payload_rx_proc+0x24>
8000211c:	13 88       	ld.ub	r8,r9[0x0]
8000211e:	2f f8       	sub	r8,-1
80002120:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002122:	30 39       	mov	r9,3
80002124:	f2 08 18 00 	cp.b	r8,r9
80002128:	c0 71       	brne	80002136 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000212a:	30 09       	mov	r9,0
8000212c:	48 48       	lddpc	r8,8000213c <app_payload_rx_proc+0x24>
8000212e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002130:	48 4c       	lddpc	r12,80002140 <app_payload_rx_proc+0x28>
80002132:	f0 1f 00 05 	mcall	80002144 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002136:	48 58       	lddpc	r8,80002148 <app_payload_rx_proc+0x30>
80002138:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000213a:	d8 02       	popm	pc
8000213c:	00 00       	add	r0,r0
8000213e:	0a 54       	eor	r4,r5
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	c8 0c       	rcall	80002242 <ButtonConfig_brdcst_func+0x1a>
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	67 78       	ld.w	r8,r3[0x5c]
80002148:	00 00       	add	r0,r0
8000214a:	0a 4a       	or	r10,r5

8000214c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000214c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000214e:	48 3c       	lddpc	r12,80002158 <FD_brdcst_func+0xc>
80002150:	f0 1f 00 03 	mcall	8000215c <FD_brdcst_func+0x10>
	
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	c8 18       	rjmp	8000225c <ButtonConfig_brdcst_func+0x34>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	67 78       	ld.w	r8,r3[0x5c]

80002160 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002160:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002162:	48 3c       	lddpc	r12,8000216c <FD_reply_func+0xc>
80002164:	f0 1f 00 03 	mcall	80002170 <FD_reply_func+0x10>
	
	
}
80002168:	d8 02       	popm	pc
8000216a:	00 00       	add	r0,r0
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	c8 38       	rjmp	80002274 <ButtonConfig_brdcst_func+0x4c>
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	67 78       	ld.w	r8,r3[0x5c]

80002174 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002174:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002176:	48 3c       	lddpc	r12,80002180 <FD_request_func+0xc>
80002178:	f0 1f 00 03 	mcall	80002184 <FD_request_func+0x10>
	
	
}
8000217c:	d8 02       	popm	pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	c8 54       	brge	8000208c <app_init+0x50>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	67 78       	ld.w	r8,r3[0x5c]

80002188 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002188:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000218a:	48 3c       	lddpc	r12,80002194 <EnOB_brdcst_func+0xc>
8000218c:	f0 1f 00 03 	mcall	80002198 <EnOB_brdcst_func+0x10>
}
80002190:	d8 02       	popm	pc
80002192:	00 00       	add	r0,r0
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	c8 70       	breq	800020a4 <app_cfg+0x14>
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	67 78       	ld.w	r8,r3[0x5c]

8000219c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000219c:	eb cd 40 80 	pushm	r7,lr
800021a0:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800021a2:	19 a9       	ld.ub	r9,r12[0x2]
800021a4:	30 08       	mov	r8,0
800021a6:	f0 09 18 00 	cp.b	r9,r8
800021aa:	c1 91       	brne	800021dc <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800021ac:	19 b8       	ld.ub	r8,r12[0x3]
800021ae:	30 19       	mov	r9,1
800021b0:	f2 08 18 00 	cp.b	r8,r9
800021b4:	c0 61       	brne	800021c0 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021b6:	49 0c       	lddpc	r12,800021f4 <EnOB_reply_func+0x58>
800021b8:	f0 1f 00 10 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021bc:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021c0:	58 08       	cp.w	r8,0
800021c2:	c0 61       	brne	800021ce <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021c4:	48 ec       	lddpc	r12,800021fc <EnOB_reply_func+0x60>
800021c6:	f0 1f 00 0d 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	48 cc       	lddpc	r12,80002200 <EnOB_reply_func+0x64>
800021d2:	f0 1f 00 0a 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021d6:	2f fd       	sub	sp,-4
800021d8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021dc:	48 ac       	lddpc	r12,80002204 <EnOB_reply_func+0x68>
800021de:	f0 1f 00 07 	mcall	800021f8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021e2:	0f a8       	ld.ub	r8,r7[0x2]
800021e4:	1a d8       	st.w	--sp,r8
800021e6:	48 9c       	lddpc	r12,80002208 <EnOB_reply_func+0x6c>
800021e8:	f0 1f 00 04 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ec:	2f fd       	sub	sp,-4
800021ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f2:	00 00       	add	r0,r0
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	c8 88       	rjmp	80002306 <ButtonConfig_reply_func+0x2>
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	67 78       	ld.w	r8,r3[0x5c]
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	c8 a0       	breq	80002112 <app_payload_tx_proc+0xe>
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	c8 b4       	brge	80002118 <app_payload_rx_proc>
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	c8 cc       	rcall	8000231e <ButtonConfig_reply_func+0x1a>
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	c8 e8       	rjmp	80002326 <ButtonConfig_reply_func+0x22>

8000220c <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
8000220c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000220e:	19 a9       	ld.ub	r9,r12[0x2]
80002210:	31 18       	mov	r8,17
80002212:	f0 09 18 00 	cp.b	r9,r8
80002216:	c0 41       	brne	8000221e <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002218:	48 2c       	lddpc	r12,80002220 <SingleDetection_brdcst_func+0x14>
8000221a:	f0 1f 00 03 	mcall	80002224 <SingleDetection_brdcst_func+0x18>
8000221e:	d8 02       	popm	pc
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	c9 00       	breq	80002142 <app_payload_rx_proc+0x2a>
80002224:	80 00       	ld.sh	r0,r0[0x0]
80002226:	67 78       	ld.w	r8,r3[0x5c]

80002228 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002228:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000222a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000222e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002230:	4a bc       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xb4>
80002232:	f0 1f 00 2c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002236:	0f 88       	ld.ub	r8,r7[0x0]
80002238:	1a d8       	st.w	--sp,r8
8000223a:	4a bc       	lddpc	r12,800022e4 <ButtonConfig_brdcst_func+0xbc>
8000223c:	f0 1f 00 29 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002240:	1a d5       	st.w	--sp,r5
80002242:	4a ac       	lddpc	r12,800022e8 <ButtonConfig_brdcst_func+0xc0>
80002244:	f0 1f 00 27 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002248:	0f a8       	ld.ub	r8,r7[0x2]
8000224a:	1a d8       	st.w	--sp,r8
8000224c:	4a 8c       	lddpc	r12,800022ec <ButtonConfig_brdcst_func+0xc4>
8000224e:	f0 1f 00 25 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002252:	2f dd       	sub	sp,-12
80002254:	58 05       	cp.w	r5,0
80002256:	c4 10       	breq	800022d8 <ButtonConfig_brdcst_func+0xb0>
80002258:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000225a:	4a 64       	lddpc	r4,800022f0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225c:	4a 63       	lddpc	r3,800022f4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000225e:	4a 72       	lddpc	r2,800022f8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002260:	4a 71       	lddpc	r1,800022fc <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002262:	4a 80       	lddpc	r0,80002300 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002264:	0f b9       	ld.ub	r9,r7[0x3]
80002266:	0f c8       	ld.ub	r8,r7[0x4]
80002268:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226c:	1a d8       	st.w	--sp,r8
8000226e:	1a d6       	st.w	--sp,r6
80002270:	08 9c       	mov	r12,r4
80002272:	f0 1f 00 1c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002276:	0f d9       	ld.ub	r9,r7[0x5]
80002278:	0f e8       	ld.ub	r8,r7[0x6]
8000227a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227e:	1a d8       	st.w	--sp,r8
80002280:	1a d6       	st.w	--sp,r6
80002282:	06 9c       	mov	r12,r3
80002284:	f0 1f 00 17 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002288:	0f f9       	ld.ub	r9,r7[0x7]
8000228a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000228e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002292:	1a d8       	st.w	--sp,r8
80002294:	1a d6       	st.w	--sp,r6
80002296:	04 9c       	mov	r12,r2
80002298:	f0 1f 00 12 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000229c:	ef 39 00 09 	ld.ub	r9,r7[9]
800022a0:	ef 38 00 0a 	ld.ub	r8,r7[10]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	02 9c       	mov	r12,r1
800022ae:	f0 1f 00 0d 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022b2:	2f 8d       	sub	sp,-32
800022b4:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022b8:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022bc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022c0:	1a d8       	st.w	--sp,r8
800022c2:	1a d6       	st.w	--sp,r6
800022c4:	00 9c       	mov	r12,r0
800022c6:	f0 1f 00 07 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
800022ca:	2f f6       	sub	r6,-1
800022cc:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ce:	2f ed       	sub	sp,-8
800022d0:	ec 05 18 00 	cp.b	r5,r6
800022d4:	fe 9b ff c8 	brhi	80002264 <ButtonConfig_brdcst_func+0x3c>
800022d8:	d8 32       	popm	r0-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c9 14       	brge	80002200 <EnOB_reply_func+0x64>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	67 78       	ld.w	r8,r3[0x5c]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c9 34       	brge	8000220c <SingleDetection_brdcst_func>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c9 48       	rjmp	80002412 <DataSession_brdcst_func+0xca>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	c9 60       	breq	8000221a <SingleDetection_brdcst_func+0xe>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	c9 80       	breq	80002222 <SingleDetection_brdcst_func+0x16>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	c9 a8       	rjmp	8000242a <DataSession_reply_func+0x16>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	c9 d0       	breq	80002234 <ButtonConfig_brdcst_func+0xc>
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	c9 f4       	brge	8000223c <ButtonConfig_brdcst_func+0x14>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	ca 1c       	rcall	80002444 <DataSession_reply_func+0x30>

80002304 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 c1       	brne	8000232c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002316:	48 9c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x34>
80002318:	f0 1f 00 09 	mcall	8000233c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000231c:	0f 98       	ld.ub	r8,r7[0x1]
8000231e:	1a d8       	st.w	--sp,r8
80002320:	48 8c       	lddpc	r12,80002340 <ButtonConfig_reply_func+0x3c>
80002322:	f0 1f 00 07 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002326:	2f fd       	sub	sp,-4
80002328:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000232c:	48 6c       	lddpc	r12,80002344 <ButtonConfig_reply_func+0x40>
8000232e:	f0 1f 00 04 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
80002336:	00 00       	add	r0,r0
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	ca 40       	breq	80002282 <ButtonConfig_brdcst_func+0x5a>
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	67 78       	ld.w	r8,r3[0x5c]
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	c9 34       	brge	80002268 <ButtonConfig_brdcst_func+0x40>
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	ca 58       	rjmp	80002490 <CallControl_brdcst_func>

80002348 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002348:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000234a:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000234e:	0d 88       	ld.ub	r8,r6[0x0]
80002350:	32 49       	mov	r9,36
80002352:	f2 08 18 00 	cp.b	r8,r9
80002356:	c2 91       	brne	800023a8 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002358:	4a 7c       	lddpc	r12,800023f4 <DataSession_brdcst_func+0xac>
8000235a:	f0 1f 00 28 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a5       	ld.ub	r5,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002366:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002368:	0d 98       	ld.ub	r8,r6[0x1]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	4a 4c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
8000236e:	f0 1f 00 23 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002372:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002376:	1a d8       	st.w	--sp,r8
80002378:	4a 2c       	lddpc	r12,80002400 <DataSession_brdcst_func+0xb8>
8000237a:	f0 1f 00 20 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		for(i=0; i<data_length; i++)
8000237e:	2f ed       	sub	sp,-8
80002380:	58 05       	cp.w	r5,0
80002382:	c3 70       	breq	800023f0 <DataSession_brdcst_func+0xa8>
80002384:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002386:	4a 04       	lddpc	r4,80002404 <DataSession_brdcst_func+0xbc>
80002388:	ec 07 00 08 	add	r8,r6,r7
8000238c:	11 c8       	ld.ub	r8,r8[0x4]
8000238e:	1a d8       	st.w	--sp,r8
80002390:	1a d7       	st.w	--sp,r7
80002392:	08 9c       	mov	r12,r4
80002394:	f0 1f 00 19 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002398:	2f f7       	sub	r7,-1
8000239a:	5c 57       	castu.b	r7
8000239c:	2f ed       	sub	sp,-8
8000239e:	ee 05 19 00 	cp.h	r5,r7
800023a2:	fe 9b ff f3 	brhi	80002388 <DataSession_brdcst_func+0x40>
800023a6:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: %X \n", ptr->State);
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	49 8c       	lddpc	r12,80002408 <DataSession_brdcst_func+0xc0>
800023ac:	f0 1f 00 13 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		if (ptr->State == DATA_SESSION_TX_Suc)
800023b0:	0d 88       	ld.ub	r8,r6[0x0]
800023b2:	2f fd       	sub	sp,-4
800023b4:	30 39       	mov	r9,3
800023b6:	f2 08 18 00 	cp.b	r8,r9
800023ba:	c0 51       	brne	800023c4 <DataSession_brdcst_func+0x7c>
		{
			log("data transmit success\n");
800023bc:	49 4c       	lddpc	r12,8000240c <DataSession_brdcst_func+0xc4>
800023be:	f0 1f 00 0f 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
800023c2:	c0 88       	rjmp	800023d2 <DataSession_brdcst_func+0x8a>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800023c4:	30 49       	mov	r9,4
800023c6:	f2 08 18 00 	cp.b	r8,r9
800023ca:	c0 41       	brne	800023d2 <DataSession_brdcst_func+0x8a>
		{
			log("data transmit failure\n");
800023cc:	49 1c       	lddpc	r12,80002410 <DataSession_brdcst_func+0xc8>
800023ce:	f0 1f 00 0b 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023d2:	0d a7       	ld.ub	r7,r6[0x2]
800023d4:	0d b8       	ld.ub	r8,r6[0x3]
800023d6:	f1 e7 10 87 	or	r7,r8,r7<<0x8

		log("\n\r Session_ID: %x \n\r",Session_number );
800023da:	0d 98       	ld.ub	r8,r6[0x1]
800023dc:	1a d8       	st.w	--sp,r8
800023de:	48 8c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
800023e0:	f0 1f 00 06 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023e4:	5c 77       	castu.h	r7
800023e6:	1a d7       	st.w	--sp,r7
800023e8:	48 6c       	lddpc	r12,80002400 <DataSession_brdcst_func+0xb8>
800023ea:	f0 1f 00 04 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
800023ee:	2f ed       	sub	sp,-8
800023f0:	d8 22       	popm	r4-r7,pc
800023f2:	00 00       	add	r0,r0
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	ca 74       	brge	80002344 <ButtonConfig_reply_func+0x40>
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	67 78       	ld.w	r8,r3[0x5c]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	ca 88       	rjmp	8000254e <TransmitControl_reply_func+0x32>
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	ca a0       	breq	80002356 <DataSession_brdcst_func+0xe>
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	ca bc       	rcall	8000255c <TransmitControl_reply_func+0x40>
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	ca d4       	brge	80002364 <DataSession_brdcst_func+0x1c>
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	ca e0       	breq	8000236a <DataSession_brdcst_func+0x22>
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	ca f8       	rjmp	80002570 <TransmitControl_reply_func+0x54>

80002414 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
80002418:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000241a:	19 a9       	ld.ub	r9,r12[0x2]
8000241c:	30 08       	mov	r8,0
8000241e:	f0 09 18 00 	cp.b	r9,r8
80002422:	c1 11       	brne	80002444 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002424:	49 3c       	lddpc	r12,80002470 <DataSession_reply_func+0x5c>
80002426:	f0 1f 00 14 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000242a:	0f b8       	ld.ub	r8,r7[0x3]
8000242c:	1a d8       	st.w	--sp,r8
8000242e:	49 3c       	lddpc	r12,80002478 <DataSession_reply_func+0x64>
80002430:	f0 1f 00 11 	mcall	80002474 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002434:	0f c8       	ld.ub	r8,r7[0x4]
80002436:	1a d8       	st.w	--sp,r8
80002438:	49 1c       	lddpc	r12,8000247c <DataSession_reply_func+0x68>
8000243a:	f0 1f 00 0f 	mcall	80002474 <DataSession_reply_func+0x60>
8000243e:	2f ed       	sub	sp,-8
80002440:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002444:	48 fc       	lddpc	r12,80002480 <DataSession_reply_func+0x6c>
80002446:	f0 1f 00 0c 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000244a:	0f a8       	ld.ub	r8,r7[0x2]
8000244c:	1a d8       	st.w	--sp,r8
8000244e:	48 ec       	lddpc	r12,80002484 <DataSession_reply_func+0x70>
80002450:	f0 1f 00 09 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002454:	0f b8       	ld.ub	r8,r7[0x3]
80002456:	1a d8       	st.w	--sp,r8
80002458:	48 cc       	lddpc	r12,80002488 <DataSession_reply_func+0x74>
8000245a:	f0 1f 00 07 	mcall	80002474 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000245e:	0f c8       	ld.ub	r8,r7[0x4]
80002460:	1a d8       	st.w	--sp,r8
80002462:	48 bc       	lddpc	r12,8000248c <DataSession_reply_func+0x78>
80002464:	f0 1f 00 04 	mcall	80002474 <DataSession_reply_func+0x60>
80002468:	2f dd       	sub	sp,-12
8000246a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246e:	00 00       	add	r0,r0
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	cb 10       	breq	800023d4 <DataSession_brdcst_func+0x8c>
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	67 78       	ld.w	r8,r3[0x5c]
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	cb 20       	breq	800023de <DataSession_brdcst_func+0x96>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	cb 2c       	rcall	800025e2 <Volume_reply_func+0x3e>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	cb 38       	rjmp	800025e8 <Volume_reply_func+0x44>
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	cb 48       	rjmp	800025ee <Volume_reply_func+0x4a>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	cb 58       	rjmp	800025f4 <Volume_reply_func+0x50>
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	cb 64       	brge	800023fa <DataSession_brdcst_func+0xb2>

80002490 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002490:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002494:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002498:	0f 98       	ld.ub	r8,r7[0x1]
8000249a:	1a d8       	st.w	--sp,r8
8000249c:	48 bc       	lddpc	r12,800024c8 <CallControl_brdcst_func+0x38>
8000249e:	f0 1f 00 0c 	mcall	800024cc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024a2:	2f fd       	sub	sp,-4
800024a4:	0f 99       	ld.ub	r9,r7[0x1]
800024a6:	30 38       	mov	r8,3
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c0 41       	brne	800024b4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024ae:	30 09       	mov	r9,0
800024b0:	48 88       	lddpc	r8,800024d0 <CallControl_brdcst_func+0x40>
800024b2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024b4:	0f 99       	ld.ub	r9,r7[0x1]
800024b6:	30 48       	mov	r8,4
800024b8:	f0 09 18 00 	cp.b	r9,r8
800024bc:	c0 41       	brne	800024c4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024be:	30 19       	mov	r9,1
800024c0:	48 48       	lddpc	r8,800024d0 <CallControl_brdcst_func+0x40>
800024c2:	b0 89       	st.b	r8[0x0],r9
800024c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	cb 70       	breq	80002438 <DataSession_reply_func+0x24>
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	67 78       	ld.w	r8,r3[0x5c]
800024d0:	00 00       	add	r0,r0
800024d2:	0a 4c       	or	r12,r5

800024d4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024d4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024d8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024dc:	0f 99       	ld.ub	r9,r7[0x1]
800024de:	30 08       	mov	r8,0
800024e0:	f0 09 18 00 	cp.b	r9,r8
800024e4:	c0 71       	brne	800024f2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024e6:	48 ac       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x38>
800024e8:	f0 1f 00 0a 	mcall	80002510 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024ec:	30 09       	mov	r9,0
800024ee:	48 a8       	lddpc	r8,80002514 <TransmitControl_brdcst_func+0x40>
800024f0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024f2:	0f 99       	ld.ub	r9,r7[0x1]
800024f4:	30 18       	mov	r8,1
800024f6:	f0 09 18 00 	cp.b	r9,r8
800024fa:	c0 71       	brne	80002508 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024fc:	48 7c       	lddpc	r12,80002518 <TransmitControl_brdcst_func+0x44>
800024fe:	f0 1f 00 05 	mcall	80002510 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
80002502:	30 19       	mov	r9,1
80002504:	48 48       	lddpc	r8,80002514 <TransmitControl_brdcst_func+0x40>
80002506:	b0 89       	st.b	r8[0x0],r9
80002508:	e3 cd 80 80 	ldm	sp++,r7,pc
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	cb 88       	rjmp	8000267e <spk_reply_func+0x3e>
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	67 78       	ld.w	r8,r3[0x5c]
80002514:	00 00       	add	r0,r0
80002516:	0a 4b       	or	r11,r5
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	cb a0       	breq	8000248e <DataSession_reply_func+0x7a>

8000251c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002524:	0f 89       	ld.ub	r9,r7[0x0]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c1 61       	brne	80002558 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000252e:	48 ec       	lddpc	r12,80002564 <TransmitControl_reply_func+0x48>
80002530:	f0 1f 00 0e 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002534:	0f 98       	ld.ub	r8,r7[0x1]
80002536:	1a d8       	st.w	--sp,r8
80002538:	48 dc       	lddpc	r12,8000256c <TransmitControl_reply_func+0x50>
8000253a:	f0 1f 00 0c 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000253e:	0f a8       	ld.ub	r8,r7[0x2]
80002540:	1a d8       	st.w	--sp,r8
80002542:	48 cc       	lddpc	r12,80002570 <TransmitControl_reply_func+0x54>
80002544:	f0 1f 00 09 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002548:	0f b8       	ld.ub	r8,r7[0x3]
8000254a:	1a d8       	st.w	--sp,r8
8000254c:	48 ac       	lddpc	r12,80002574 <TransmitControl_reply_func+0x58>
8000254e:	f0 1f 00 07 	mcall	80002568 <TransmitControl_reply_func+0x4c>
80002552:	2f dd       	sub	sp,-12
80002554:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002558:	48 8c       	lddpc	r12,80002578 <TransmitControl_reply_func+0x5c>
8000255a:	f0 1f 00 04 	mcall	80002568 <TransmitControl_reply_func+0x4c>
8000255e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002562:	00 00       	add	r0,r0
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	cb b4       	brge	800024dc <TransmitControl_brdcst_func+0x8>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	67 78       	ld.w	r8,r3[0x5c]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	cb d0       	breq	800024e8 <TransmitControl_brdcst_func+0x14>
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	cb e4       	brge	800024ee <TransmitControl_brdcst_func+0x1a>
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	cc 00       	breq	800024f6 <TransmitControl_brdcst_func+0x22>
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	cc 10       	breq	800024fc <TransmitControl_brdcst_func+0x28>

8000257c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000257c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000257e:	19 a9       	ld.ub	r9,r12[0x2]
80002580:	30 08       	mov	r8,0
80002582:	f0 09 18 00 	cp.b	r9,r8
80002586:	c0 51       	brne	80002590 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002588:	48 4c       	lddpc	r12,80002598 <AudioRoutingControl_reply_func+0x1c>
8000258a:	f0 1f 00 05 	mcall	8000259c <AudioRoutingControl_reply_func+0x20>
8000258e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002590:	48 4c       	lddpc	r12,800025a0 <AudioRoutingControl_reply_func+0x24>
80002592:	f0 1f 00 03 	mcall	8000259c <AudioRoutingControl_reply_func+0x20>
80002596:	d8 02       	popm	pc
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	cc 28       	rjmp	8000271e <mic_reply_func+0x3e>
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	67 78       	ld.w	r8,r3[0x5c]
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	cc 38       	rjmp	80002728 <mic_reply_func+0x48>

800025a4 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025a4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025a8:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025ac:	0f 89       	ld.ub	r9,r7[0x0]
800025ae:	30 08       	mov	r8,0
800025b0:	f0 09 18 00 	cp.b	r9,r8
800025b4:	c1 b1       	brne	800025ea <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025b6:	0f b8       	ld.ub	r8,r7[0x3]
800025b8:	31 09       	mov	r9,16
800025ba:	f2 08 18 00 	cp.b	r8,r9
800025be:	c0 f1       	brne	800025dc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025c0:	48 dc       	lddpc	r12,800025f4 <Volume_reply_func+0x50>
800025c2:	f0 1f 00 0e 	mcall	800025f8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025c6:	0f 99       	ld.ub	r9,r7[0x1]
800025c8:	0f a8       	ld.ub	r8,r7[0x2]
800025ca:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ce:	1a d8       	st.w	--sp,r8
800025d0:	48 bc       	lddpc	r12,800025fc <Volume_reply_func+0x58>
800025d2:	f0 1f 00 0a 	mcall	800025f8 <Volume_reply_func+0x54>
800025d6:	2f fd       	sub	sp,-4
800025d8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025dc:	1a d8       	st.w	--sp,r8
800025de:	48 9c       	lddpc	r12,80002600 <Volume_reply_func+0x5c>
800025e0:	f0 1f 00 06 	mcall	800025f8 <Volume_reply_func+0x54>
800025e4:	2f fd       	sub	sp,-4
800025e6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025ea:	48 7c       	lddpc	r12,80002604 <Volume_reply_func+0x60>
800025ec:	f0 1f 00 03 	mcall	800025f8 <Volume_reply_func+0x54>
800025f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	cc 4c       	rcall	8000277e <dcm_brdcst_func+0xa>
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	67 78       	ld.w	r8,r3[0x5c]
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	cc 60       	breq	8000258a <AudioRoutingControl_reply_func+0xe>
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	cc 7c       	rcall	80002790 <dcm_brdcst_func+0x1c>
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	cc 94       	brge	80002598 <AudioRoutingControl_reply_func+0x1c>

80002608 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002608:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000260a:	19 d9       	ld.ub	r9,r12[0x5]
8000260c:	30 08       	mov	r8,0
8000260e:	f0 09 18 00 	cp.b	r9,r8
80002612:	c0 81       	brne	80002622 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002614:	10 99       	mov	r9,r8
80002616:	48 78       	lddpc	r8,80002630 <spk_brdcst_func+0x28>
80002618:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000261a:	48 7c       	lddpc	r12,80002634 <spk_brdcst_func+0x2c>
8000261c:	f0 1f 00 07 	mcall	80002638 <spk_brdcst_func+0x30>
80002620:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002622:	30 19       	mov	r9,1
80002624:	48 38       	lddpc	r8,80002630 <spk_brdcst_func+0x28>
80002626:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002628:	48 5c       	lddpc	r12,8000263c <spk_brdcst_func+0x34>
8000262a:	f0 1f 00 04 	mcall	80002638 <spk_brdcst_func+0x30>
8000262e:	d8 02       	popm	pc
80002630:	00 00       	add	r0,r0
80002632:	0a 40       	or	r0,r5
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	cc ac       	rcall	800027ca <dcm_reply_func+0xe>
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	67 78       	ld.w	r8,r3[0x5c]
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	cc bc       	rcall	800027d4 <dcm_reply_func+0x18>

80002640 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002640:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002642:	19 a9       	ld.ub	r9,r12[0x2]
80002644:	30 08       	mov	r8,0
80002646:	f0 09 18 00 	cp.b	r9,r8
8000264a:	c0 f1       	brne	80002668 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000264c:	19 e9       	ld.ub	r9,r12[0x6]
8000264e:	f0 09 18 00 	cp.b	r9,r8
80002652:	c0 40       	breq	8000265a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002654:	30 19       	mov	r9,1
80002656:	48 98       	lddpc	r8,80002678 <spk_reply_func+0x38>
80002658:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000265a:	19 e8       	ld.ub	r8,r12[0x6]
8000265c:	1a d8       	st.w	--sp,r8
8000265e:	48 8c       	lddpc	r12,8000267c <spk_reply_func+0x3c>
80002660:	f0 1f 00 08 	mcall	80002680 <spk_reply_func+0x40>
80002664:	2f fd       	sub	sp,-4
80002666:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002668:	30 09       	mov	r9,0
8000266a:	48 48       	lddpc	r8,80002678 <spk_reply_func+0x38>
8000266c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000266e:	48 6c       	lddpc	r12,80002684 <spk_reply_func+0x44>
80002670:	f0 1f 00 04 	mcall	80002680 <spk_reply_func+0x40>
80002674:	d8 02       	popm	pc
80002676:	00 00       	add	r0,r0
80002678:	00 00       	add	r0,r0
8000267a:	0a 40       	or	r0,r5
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	cc c8       	rjmp	80002816 <dcm_reply_func+0x5a>
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	67 78       	ld.w	r8,r3[0x5c]
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	cc d8       	rjmp	80002820 <dcm_reply_func+0x64>

80002688 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002688:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000268c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002690:	0f a9       	ld.ub	r9,r7[0x2]
80002692:	30 08       	mov	r8,0
80002694:	f0 09 18 00 	cp.b	r9,r8
80002698:	c0 71       	brne	800026a6 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000269a:	48 dc       	lddpc	r12,800026cc <mic_brdcst_func+0x44>
8000269c:	f0 1f 00 0d 	mcall	800026d0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026a0:	30 09       	mov	r9,0
800026a2:	48 d8       	lddpc	r8,800026d4 <mic_brdcst_func+0x4c>
800026a4:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026a6:	0f a9       	ld.ub	r9,r7[0x2]
800026a8:	31 18       	mov	r8,17
800026aa:	f0 09 18 00 	cp.b	r9,r8
800026ae:	c0 d1       	brne	800026c8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026b0:	48 ac       	lddpc	r12,800026d8 <mic_brdcst_func+0x50>
800026b2:	f0 1f 00 08 	mcall	800026d0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026b6:	48 89       	lddpc	r9,800026d4 <mic_brdcst_func+0x4c>
800026b8:	30 18       	mov	r8,1
800026ba:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026bc:	13 89       	ld.ub	r9,r9[0x0]
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c0 31       	brne	800026c8 <mic_brdcst_func+0x40>
800026c4:	48 68       	lddpc	r8,800026dc <mic_brdcst_func+0x54>
800026c6:	11 88       	ld.ub	r8,r8[0x0]
800026c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	cc e4       	brge	8000266a <spk_reply_func+0x2a>
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	67 78       	ld.w	r8,r3[0x5c]
800026d4:	00 00       	add	r0,r0
800026d6:	0a 4f       	or	pc,r5
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	cc f8       	rjmp	80002878 <Phyuserinput_brdcst_func+0x2c>
800026dc:	00 00       	add	r0,r0
800026de:	0a 4c       	or	r12,r5

800026e0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026e0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026e4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026e8:	49 ac       	lddpc	r12,80002750 <mic_reply_func+0x70>
800026ea:	f0 1f 00 1b 	mcall	80002754 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ee:	0f 89       	ld.ub	r9,r7[0x0]
800026f0:	30 08       	mov	r8,0
800026f2:	f0 09 18 00 	cp.b	r9,r8
800026f6:	c2 71       	brne	80002744 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026f8:	0f 98       	ld.ub	r8,r7[0x1]
800026fa:	30 29       	mov	r9,2
800026fc:	f2 08 18 00 	cp.b	r8,r9
80002700:	c1 b1       	brne	80002736 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002702:	49 6c       	lddpc	r12,80002758 <mic_reply_func+0x78>
80002704:	f0 1f 00 14 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002708:	0f a8       	ld.ub	r8,r7[0x2]
8000270a:	1a d8       	st.w	--sp,r8
8000270c:	49 4c       	lddpc	r12,8000275c <mic_reply_func+0x7c>
8000270e:	f0 1f 00 12 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002712:	0f b8       	ld.ub	r8,r7[0x3]
80002714:	1a d8       	st.w	--sp,r8
80002716:	49 3c       	lddpc	r12,80002760 <mic_reply_func+0x80>
80002718:	f0 1f 00 0f 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000271c:	0f c8       	ld.ub	r8,r7[0x4]
8000271e:	1a d8       	st.w	--sp,r8
80002720:	49 1c       	lddpc	r12,80002764 <mic_reply_func+0x84>
80002722:	f0 1f 00 0d 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002726:	0f d8       	ld.ub	r8,r7[0x5]
80002728:	1a d8       	st.w	--sp,r8
8000272a:	49 0c       	lddpc	r12,80002768 <mic_reply_func+0x88>
8000272c:	f0 1f 00 0a 	mcall	80002754 <mic_reply_func+0x74>
80002730:	2f cd       	sub	sp,-16
80002732:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002736:	1a d8       	st.w	--sp,r8
80002738:	48 dc       	lddpc	r12,8000276c <mic_reply_func+0x8c>
8000273a:	f0 1f 00 07 	mcall	80002754 <mic_reply_func+0x74>
8000273e:	2f fd       	sub	sp,-4
80002740:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002744:	48 bc       	lddpc	r12,80002770 <mic_reply_func+0x90>
80002746:	f0 1f 00 04 	mcall	80002754 <mic_reply_func+0x74>
8000274a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000274e:	00 00       	add	r0,r0
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	cd 0c       	rcall	800028f2 <send_flash_command+0x1e>
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	67 78       	ld.w	r8,r3[0x5c]
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	cd 1c       	rcall	800028fc <send_flash_command+0x28>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	cd 30       	breq	80002704 <mic_reply_func+0x24>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	cd 44       	brge	8000270a <mic_reply_func+0x2a>
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	cd 60       	breq	80002712 <mic_reply_func+0x32>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	cd 78       	rjmp	80002918 <send_flash_command+0x44>
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	cd 90       	breq	80002720 <mic_reply_func+0x40>
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	cd a8       	rjmp	80002926 <send_flash_command+0x52>

80002774 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002774:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002778:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000277c:	48 bc       	lddpc	r12,800027a8 <dcm_brdcst_func+0x34>
8000277e:	f0 1f 00 0c 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002782:	0f 88       	ld.ub	r8,r7[0x0]
80002784:	1a d8       	st.w	--sp,r8
80002786:	48 bc       	lddpc	r12,800027b0 <dcm_brdcst_func+0x3c>
80002788:	f0 1f 00 09 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000278c:	0f a8       	ld.ub	r8,r7[0x2]
8000278e:	1a d8       	st.w	--sp,r8
80002790:	48 9c       	lddpc	r12,800027b4 <dcm_brdcst_func+0x40>
80002792:	f0 1f 00 07 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002796:	0f 98       	ld.ub	r8,r7[0x1]
80002798:	1a d8       	st.w	--sp,r8
8000279a:	48 8c       	lddpc	r12,800027b8 <dcm_brdcst_func+0x44>
8000279c:	f0 1f 00 04 	mcall	800027ac <dcm_brdcst_func+0x38>
800027a0:	2f dd       	sub	sp,-12
	
	
}
800027a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027a6:	00 00       	add	r0,r0
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	cd b8       	rjmp	80002960 <send_flash_command+0x8c>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	67 78       	ld.w	r8,r3[0x5c]
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	cd cc       	rcall	8000296a <send_flash_command+0x96>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	cd e0       	breq	80002772 <mic_reply_func+0x92>
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	cd f8       	rjmp	80002978 <send_flash_command+0xa4>

800027bc <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027bc:	eb cd 40 80 	pushm	r7,lr
800027c0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027c2:	19 a9       	ld.ub	r9,r12[0x2]
800027c4:	30 08       	mov	r8,0
800027c6:	f0 09 18 00 	cp.b	r9,r8
800027ca:	c1 b1       	brne	80002800 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027cc:	19 b8       	ld.ub	r8,r12[0x3]
800027ce:	30 19       	mov	r9,1
800027d0:	f2 08 18 00 	cp.b	r8,r9
800027d4:	c0 51       	brne	800027de <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027d6:	48 ec       	lddpc	r12,8000280c <dcm_reply_func+0x50>
800027d8:	f0 1f 00 0e 	mcall	80002810 <dcm_reply_func+0x54>
800027dc:	c0 a8       	rjmp	800027f0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027de:	58 08       	cp.w	r8,0
800027e0:	c0 51       	brne	800027ea <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027e2:	48 dc       	lddpc	r12,80002814 <dcm_reply_func+0x58>
800027e4:	f0 1f 00 0b 	mcall	80002810 <dcm_reply_func+0x54>
800027e8:	c0 48       	rjmp	800027f0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027ea:	48 cc       	lddpc	r12,80002818 <dcm_reply_func+0x5c>
800027ec:	f0 1f 00 09 	mcall	80002810 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027f0:	0f d8       	ld.ub	r8,r7[0x5]
800027f2:	1a d8       	st.w	--sp,r8
800027f4:	48 ac       	lddpc	r12,8000281c <dcm_reply_func+0x60>
800027f6:	f0 1f 00 07 	mcall	80002810 <dcm_reply_func+0x54>
800027fa:	2f fd       	sub	sp,-4
800027fc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002800:	48 8c       	lddpc	r12,80002820 <dcm_reply_func+0x64>
80002802:	f0 1f 00 04 	mcall	80002810 <dcm_reply_func+0x54>
80002806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000280a:	00 00       	add	r0,r0
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	ce 14       	brge	800027d0 <dcm_reply_func+0x14>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	67 78       	ld.w	r8,r3[0x5c]
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	ce 28       	rjmp	800029da <send_flash_command+0x106>
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	ce 3c       	rcall	800029e0 <send_flash_command+0x10c>
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	ce 50       	breq	800027e8 <dcm_reply_func+0x2c>
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	ce 5c       	rcall	800029ec <send_flash_command+0x118>

80002824 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002824:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002826:	19 a9       	ld.ub	r9,r12[0x2]
80002828:	30 08       	mov	r8,0
8000282a:	f0 09 18 00 	cp.b	r9,r8
8000282e:	c0 51       	brne	80002838 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002830:	48 4c       	lddpc	r12,80002840 <ToneControl_reply_func+0x1c>
80002832:	f0 1f 00 05 	mcall	80002844 <ToneControl_reply_func+0x20>
80002836:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002838:	48 4c       	lddpc	r12,80002848 <ToneControl_reply_func+0x24>
8000283a:	f0 1f 00 03 	mcall	80002844 <ToneControl_reply_func+0x20>
8000283e:	d8 02       	popm	pc
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	ce 68       	rjmp	80002a0e <send_flash_command+0x13a>
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	67 78       	ld.w	r8,r3[0x5c]
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	ce 74       	brge	80002818 <dcm_reply_func+0x5c>

8000284c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000284c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002850:	19 c7       	ld.ub	r7,r12[0x4]
80002852:	19 d8       	ld.ub	r8,r12[0x5]
80002854:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002858:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000285a:	48 cc       	lddpc	r12,80002888 <Phyuserinput_brdcst_func+0x3c>
8000285c:	f0 1f 00 0c 	mcall	8000288c <Phyuserinput_brdcst_func+0x40>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002860:	36 08       	mov	r8,96
80002862:	f0 07 19 00 	cp.h	r7,r8
80002866:	c0 f1       	brne	80002884 <Phyuserinput_brdcst_func+0x38>
80002868:	48 a8       	lddpc	r8,80002890 <Phyuserinput_brdcst_func+0x44>
8000286a:	11 89       	ld.ub	r9,r8[0x0]
8000286c:	30 18       	mov	r8,1
8000286e:	f0 09 18 00 	cp.b	r9,r8
80002872:	c0 91       	brne	80002884 <Phyuserinput_brdcst_func+0x38>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002874:	31 4b       	mov	r11,20
80002876:	30 1c       	mov	r12,1
80002878:	f0 1f 00 07 	mcall	80002894 <Phyuserinput_brdcst_func+0x48>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
8000287c:	e0 6c 03 20 	mov	r12,800
80002880:	f0 1f 00 06 	mcall	80002898 <Phyuserinput_brdcst_func+0x4c>
80002884:	e3 cd 80 80 	ldm	sp++,r7,pc
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	ce 80       	breq	8000285a <Phyuserinput_brdcst_func+0xe>
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	67 78       	ld.w	r8,r3[0x5c]
80002890:	00 00       	add	r0,r0
80002892:	0a 4e       	or	lr,r5
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	44 14       	lddsp	r4,sp[0x104]
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	62 0c       	ld.w	r12,r1[0x0]

8000289c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000289c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000289e:	19 e8       	ld.ub	r8,r12[0x6]
800028a0:	30 19       	mov	r9,1
800028a2:	f2 08 18 00 	cp.b	r8,r9
800028a6:	c0 61       	brne	800028b2 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028a8:	48 98       	lddpc	r8,800028cc <DeviceInitializationStatus_brdcst_func+0x30>
800028aa:	70 09       	ld.w	r9,r8[0x0]
800028ac:	a1 a9       	sbr	r9,0x0
800028ae:	91 09       	st.w	r8[0x0],r9
800028b0:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028b2:	30 29       	mov	r9,2
800028b4:	f2 08 18 00 	cp.b	r8,r9
800028b8:	c0 80       	breq	800028c8 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028ba:	48 58       	lddpc	r8,800028cc <DeviceInitializationStatus_brdcst_func+0x30>
800028bc:	70 09       	ld.w	r9,r8[0x0]
800028be:	e0 19 ff fc 	andl	r9,0xfffc
800028c2:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028c4:	f0 1f 00 03 	mcall	800028d0 <DeviceInitializationStatus_brdcst_func+0x34>
800028c8:	d8 02       	popm	pc
800028ca:	00 00       	add	r0,r0
800028cc:	00 00       	add	r0,r0
800028ce:	0d 84       	ld.ub	r4,r6[0x0]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	43 68       	lddsp	r8,sp[0xd8]

800028d4 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028d4:	eb cd 40 fc 	pushm	r2-r7,lr
800028d8:	20 1d       	sub	sp,4
800028da:	18 97       	mov	r7,r12
800028dc:	14 95       	mov	r5,r10
800028de:	12 96       	mov	r6,r9
	U16 status = 1;
800028e0:	30 18       	mov	r8,1
800028e2:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028e4:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028e8:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
800028ec:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
800028f0:	30 0b       	mov	r11,0
800028f2:	4e 38       	lddpc	r8,80002a7c <send_flash_command+0x1a8>
800028f4:	70 0c       	ld.w	r12,r8[0x0]
800028f6:	f0 1f 00 63 	mcall	80002a80 <send_flash_command+0x1ac>

    switch (command)
800028fa:	30 58       	mov	r8,5
800028fc:	f0 07 19 00 	cp.h	r7,r8
80002900:	c3 40       	breq	80002968 <send_flash_command+0x94>
80002902:	e0 8b 00 18 	brhi	80002932 <send_flash_command+0x5e>
80002906:	30 28       	mov	r8,2
80002908:	f0 07 19 00 	cp.h	r7,r8
8000290c:	c5 e0       	breq	800029c8 <send_flash_command+0xf4>
8000290e:	e0 8b 00 08 	brhi	8000291e <send_flash_command+0x4a>
80002912:	30 18       	mov	r8,1
80002914:	f0 07 19 00 	cp.h	r7,r8
80002918:	e0 81 00 a9 	brne	80002a6a <send_flash_command+0x196>
8000291c:	c9 e8       	rjmp	80002a58 <send_flash_command+0x184>
8000291e:	30 38       	mov	r8,3
80002920:	f0 07 19 00 	cp.h	r7,r8
80002924:	c7 20       	breq	80002a08 <send_flash_command+0x134>
80002926:	30 48       	mov	r8,4
80002928:	f0 07 19 00 	cp.h	r7,r8
8000292c:	e0 81 00 9f 	brne	80002a6a <send_flash_command+0x196>
80002930:	c2 c8       	rjmp	80002988 <send_flash_command+0xb4>
80002932:	35 28       	mov	r8,82
80002934:	f0 07 19 00 	cp.h	r7,r8
80002938:	c2 f0       	breq	80002996 <send_flash_command+0xc2>
8000293a:	e0 8b 00 0c 	brhi	80002952 <send_flash_command+0x7e>
8000293e:	30 68       	mov	r8,6
80002940:	f0 07 19 00 	cp.h	r7,r8
80002944:	c2 20       	breq	80002988 <send_flash_command+0xb4>
80002946:	32 08       	mov	r8,32
80002948:	f0 07 19 00 	cp.h	r7,r8
8000294c:	e0 81 00 8f 	brne	80002a6a <send_flash_command+0x196>
80002950:	c2 38       	rjmp	80002996 <send_flash_command+0xc2>
80002952:	36 08       	mov	r8,96
80002954:	f0 07 19 00 	cp.h	r7,r8
80002958:	c3 20       	breq	800029bc <send_flash_command+0xe8>
8000295a:	e0 68 00 d8 	mov	r8,216
8000295e:	f0 07 19 00 	cp.h	r7,r8
80002962:	e0 81 00 84 	brne	80002a6a <send_flash_command+0x196>
80002966:	c1 88       	rjmp	80002996 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002968:	4c 57       	lddpc	r7,80002a7c <send_flash_command+0x1a8>
8000296a:	30 5b       	mov	r11,5
8000296c:	6e 0c       	ld.w	r12,r7[0x0]
8000296e:	f0 1f 00 46 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_dummy();
80002972:	e0 6b 00 ff 	mov	r11,255
80002976:	6e 0c       	ld.w	r12,r7[0x0]
80002978:	f0 1f 00 43 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_read_byte(&status);
8000297c:	fa cb ff fe 	sub	r11,sp,-2
80002980:	6e 0c       	ld.w	r12,r7[0x0]
80002982:	f0 1f 00 42 	mcall	80002a88 <send_flash_command+0x1b4>
			break;
80002986:	c7 28       	rjmp	80002a6a <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002988:	0e 9b       	mov	r11,r7
8000298a:	5c 7b       	castu.h	r11
8000298c:	4b c8       	lddpc	r8,80002a7c <send_flash_command+0x1a8>
8000298e:	70 0c       	ld.w	r12,r8[0x0]
80002990:	f0 1f 00 3d 	mcall	80002a84 <send_flash_command+0x1b0>
			break;
80002994:	c6 b8       	rjmp	80002a6a <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002996:	4b a6       	lddpc	r6,80002a7c <send_flash_command+0x1a8>
80002998:	0e 9b       	mov	r11,r7
8000299a:	5c 7b       	castu.h	r11
8000299c:	6c 0c       	ld.w	r12,r6[0x0]
8000299e:	f0 1f 00 3a 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029a2:	08 9b       	mov	r11,r4
800029a4:	6c 0c       	ld.w	r12,r6[0x0]
800029a6:	f0 1f 00 38 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029aa:	06 9b       	mov	r11,r3
800029ac:	6c 0c       	ld.w	r12,r6[0x0]
800029ae:	f0 1f 00 36 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029b2:	04 9b       	mov	r11,r2
800029b4:	6c 0c       	ld.w	r12,r6[0x0]
800029b6:	f0 1f 00 34 	mcall	80002a84 <send_flash_command+0x1b0>
			break;
800029ba:	c5 88       	rjmp	80002a6a <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
800029bc:	36 0b       	mov	r11,96
800029be:	4b 08       	lddpc	r8,80002a7c <send_flash_command+0x1a8>
800029c0:	70 0c       	ld.w	r12,r8[0x0]
800029c2:	f0 1f 00 31 	mcall	80002a84 <send_flash_command+0x1b0>
			break;
800029c6:	c5 28       	rjmp	80002a6a <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029c8:	4a d7       	lddpc	r7,80002a7c <send_flash_command+0x1a8>
800029ca:	30 2b       	mov	r11,2
800029cc:	6e 0c       	ld.w	r12,r7[0x0]
800029ce:	f0 1f 00 2e 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029d2:	08 9b       	mov	r11,r4
800029d4:	6e 0c       	ld.w	r12,r7[0x0]
800029d6:	f0 1f 00 2c 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029da:	06 9b       	mov	r11,r3
800029dc:	6e 0c       	ld.w	r12,r7[0x0]
800029de:	f0 1f 00 2a 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029e2:	04 9b       	mov	r11,r2
800029e4:	6e 0c       	ld.w	r12,r7[0x0]
800029e6:	f0 1f 00 28 	mcall	80002a84 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029ea:	58 06       	cp.w	r6,0
800029ec:	c3 f0       	breq	80002a6a <send_flash_command+0x196>
800029ee:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
800029f0:	4a 34       	lddpc	r4,80002a7c <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
800029f2:	0f 3b       	ld.ub	r11,r7++
800029f4:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
800029f6:	68 0c       	ld.w	r12,r4[0x0]
800029f8:	f0 1f 00 23 	mcall	80002a84 <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
800029fc:	0e 98       	mov	r8,r7
800029fe:	0a 18       	sub	r8,r5
80002a00:	ec 08 19 00 	cp.h	r8,r6
80002a04:	cf 73       	brcs	800029f2 <send_flash_command+0x11e>
80002a06:	c3 28       	rjmp	80002a6a <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002a08:	49 d7       	lddpc	r7,80002a7c <send_flash_command+0x1a8>
80002a0a:	30 3b       	mov	r11,3
80002a0c:	6e 0c       	ld.w	r12,r7[0x0]
80002a0e:	f0 1f 00 1e 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
80002a12:	08 9b       	mov	r11,r4
80002a14:	6e 0c       	ld.w	r12,r7[0x0]
80002a16:	f0 1f 00 1c 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
80002a1a:	06 9b       	mov	r11,r3
80002a1c:	6e 0c       	ld.w	r12,r7[0x0]
80002a1e:	f0 1f 00 1a 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002a22:	04 9b       	mov	r11,r2
80002a24:	6e 0c       	ld.w	r12,r7[0x0]
80002a26:	f0 1f 00 18 	mcall	80002a84 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a2a:	58 06       	cp.w	r6,0
80002a2c:	c1 f0       	breq	80002a6a <send_flash_command+0x196>
80002a2e:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a30:	49 34       	lddpc	r4,80002a7c <send_flash_command+0x1a8>
80002a32:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a36:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a38:	06 9b       	mov	r11,r3
80002a3a:	68 0c       	ld.w	r12,r4[0x0]
80002a3c:	f0 1f 00 12 	mcall	80002a84 <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a40:	1a 9b       	mov	r11,sp
80002a42:	68 0c       	ld.w	r12,r4[0x0]
80002a44:	f0 1f 00 11 	mcall	80002a88 <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a48:	9a 08       	ld.sh	r8,sp[0x0]
80002a4a:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a4c:	0e 98       	mov	r8,r7
80002a4e:	0a 18       	sub	r8,r5
80002a50:	ec 08 19 00 	cp.h	r8,r6
80002a54:	cf 23       	brcs	80002a38 <send_flash_command+0x164>
80002a56:	c0 a8       	rjmp	80002a6a <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a58:	48 97       	lddpc	r7,80002a7c <send_flash_command+0x1a8>
80002a5a:	30 1b       	mov	r11,1
80002a5c:	6e 0c       	ld.w	r12,r7[0x0]
80002a5e:	f0 1f 00 0a 	mcall	80002a84 <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a62:	30 0b       	mov	r11,0
80002a64:	6e 0c       	ld.w	r12,r7[0x0]
80002a66:	f0 1f 00 08 	mcall	80002a84 <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a6a:	30 0b       	mov	r11,0
80002a6c:	48 48       	lddpc	r8,80002a7c <send_flash_command+0x1a8>
80002a6e:	70 0c       	ld.w	r12,r8[0x0]
80002a70:	f0 1f 00 07 	mcall	80002a8c <send_flash_command+0x1b8>

	return status;
}
80002a74:	9a 1c       	ld.sh	r12,sp[0x2]
80002a76:	2f fd       	sub	sp,-4
80002a78:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a7c:	00 00       	add	r0,r0
80002a7e:	1d 88       	ld.ub	r8,lr[0x0]
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	51 f4       	stdsp	sp[0x7c],r4
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	50 8e       	stdsp	sp[0x20],lr
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	50 aa       	stdsp	sp[0x28],r10
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	51 b4       	stdsp	sp[0x6c],r4

80002a90 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002a90:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002a92:	58 0a       	cp.w	r10,0
80002a94:	5f 09       	sreq	r9
80002a96:	e0 68 ff fe 	mov	r8,65534
80002a9a:	ea 18 00 7f 	orh	r8,0x7f
80002a9e:	10 3c       	cp.w	r12,r8
80002aa0:	5f b8       	srhi	r8
80002aa2:	f3 e8 10 08 	or	r8,r9,r8
80002aa6:	c0 e1       	brne	80002ac2 <data_flash_read_block+0x32>
80002aa8:	e0 68 10 00 	mov	r8,4096
80002aac:	f0 0b 19 00 	cp.h	r11,r8
80002ab0:	e0 8b 00 09 	brhi	80002ac2 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002ab4:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002ab8:	18 9b       	mov	r11,r12
80002aba:	30 3c       	mov	r12,3
80002abc:	f0 1f 00 02 	mcall	80002ac4 <data_flash_read_block+0x34>
80002ac0:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002ac2:	da 0a       	popm	pc,r12=1
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	28 d4       	sub	r4,-115

80002ac8 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002ac8:	eb cd 40 e0 	pushm	r5-r7,lr
80002acc:	18 96       	mov	r6,r12
80002ace:	16 97       	mov	r7,r11
80002ad0:	14 95       	mov	r5,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002ad2:	58 0c       	cp.w	r12,0
80002ad4:	5f 09       	sreq	r9
80002ad6:	e0 68 ff fe 	mov	r8,65534
80002ada:	ea 18 00 7f 	orh	r8,0x7f
80002ade:	10 3b       	cp.w	r11,r8
80002ae0:	5f b8       	srhi	r8
80002ae2:	f3 e8 10 08 	or	r8,r9,r8
80002ae6:	c3 91       	brne	80002b58 <data_flash_write_page+0x90>
80002ae8:	e0 68 01 00 	mov	r8,256
80002aec:	f0 0a 19 00 	cp.h	r10,r8
80002af0:	e0 8b 00 34 	brhi	80002b58 <data_flash_write_page+0x90>
	{
		return DF_INVALID_PARAM;
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002af4:	30 09       	mov	r9,0
80002af6:	12 9a       	mov	r10,r9
80002af8:	12 9b       	mov	r11,r9
80002afa:	30 5c       	mov	r12,5
80002afc:	f0 1f 00 19 	mcall	80002b60 <data_flash_write_page+0x98>
	if ((status & STATUS_BUSY) != 0)
80002b00:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002b04:	c0 30       	breq	80002b0a <data_flash_write_page+0x42>
80002b06:	30 27       	mov	r7,2
80002b08:	c2 98       	rjmp	80002b5a <data_flash_write_page+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002b0a:	30 09       	mov	r9,0
80002b0c:	12 9a       	mov	r10,r9
80002b0e:	12 9b       	mov	r11,r9
80002b10:	30 6c       	mov	r12,6
80002b12:	f0 1f 00 14 	mcall	80002b60 <data_flash_write_page+0x98>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002b16:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
80002b1a:	0c 9a       	mov	r10,r6
80002b1c:	0e 9b       	mov	r11,r7
80002b1e:	30 2c       	mov	r12,2
80002b20:	f0 1f 00 10 	mcall	80002b60 <data_flash_write_page+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b24:	30 05       	mov	r5,0
80002b26:	30 56       	mov	r6,5
80002b28:	0a 99       	mov	r9,r5
80002b2a:	0a 9a       	mov	r10,r5
80002b2c:	0a 9b       	mov	r11,r5
80002b2e:	0c 9c       	mov	r12,r6
80002b30:	f0 1f 00 0c 	mcall	80002b60 <data_flash_write_page+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002b34:	5c 7c       	castu.h	r12
80002b36:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002b3a:	cf 71       	brne	80002b28 <data_flash_write_page+0x60>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002b3c:	18 97       	mov	r7,r12
80002b3e:	e2 17 00 20 	andl	r7,0x20,COH
80002b42:	f9 b7 01 06 	movne	r7,6
80002b46:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b4a:	30 09       	mov	r9,0
80002b4c:	12 9a       	mov	r10,r9
80002b4e:	12 9b       	mov	r11,r9
80002b50:	30 4c       	mov	r12,4
80002b52:	f0 1f 00 04 	mcall	80002b60 <data_flash_write_page+0x98>

	return return_code;
80002b56:	c0 28       	rjmp	80002b5a <data_flash_write_page+0x92>
80002b58:	30 17       	mov	r7,1
}
80002b5a:	0e 9c       	mov	r12,r7
80002b5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	28 d4       	sub	r4,-115

80002b64 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002b64:	d4 31       	pushm	r0-r7,lr
80002b66:	18 94       	mov	r4,r12
80002b68:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002b6c:	16 97       	mov	r7,r11
80002b6e:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b70:	30 03       	mov	r3,0
80002b72:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b74:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b78:	c4 98       	rjmp	80002c0a <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002b7a:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002b7e:	c1 b1       	brne	80002bb4 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b80:	e0 06 19 00 	cp.h	r6,r0
80002b84:	e0 8b 00 0a 	brhi	80002b98 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002b88:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002b8c:	0e 9b       	mov	r11,r7
80002b8e:	08 9c       	mov	r12,r4
80002b90:	f0 1f 00 24 	mcall	80002c20 <data_flash_write_block+0xbc>
80002b94:	30 06       	mov	r6,0
80002b96:	c3 a8       	rjmp	80002c0a <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002b98:	e0 6a 01 00 	mov	r10,256
80002b9c:	0e 9b       	mov	r11,r7
80002b9e:	08 9c       	mov	r12,r4
80002ba0:	f0 1f 00 20 	mcall	80002c20 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002ba4:	ec c6 01 00 	sub	r6,r6,256
80002ba8:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002baa:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002bae:	ee c7 ff 00 	sub	r7,r7,-256
80002bb2:	c2 c8       	rjmp	80002c0a <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002bb4:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002bb8:	0e 09       	add	r9,r7
80002bba:	0e 98       	mov	r8,r7
80002bbc:	e4 18 00 7f 	andh	r8,0x7f
80002bc0:	e0 18 ff 00 	andl	r8,0xff00
80002bc4:	f0 c8 ff 00 	sub	r8,r8,-256
80002bc8:	10 39       	cp.w	r9,r8
80002bca:	e0 88 00 19 	brls	80002bfc <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002bce:	0e 91       	mov	r1,r7
80002bd0:	5c 51       	castu.b	r1
80002bd2:	e0 6a 01 00 	mov	r10,256
80002bd6:	02 1a       	sub	r10,r1
80002bd8:	5c 7a       	castu.h	r10
80002bda:	0e 9b       	mov	r11,r7
80002bdc:	08 9c       	mov	r12,r4
80002bde:	f0 1f 00 11 	mcall	80002c20 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002be2:	ec c6 01 00 	sub	r6,r6,256
80002be6:	02 06       	add	r6,r1
80002be8:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bea:	e0 68 01 00 	mov	r8,256
80002bee:	f0 05 01 05 	sub	r5,r8,r5
80002bf2:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002bf4:	e0 17 ff 00 	andl	r7,0xff00
80002bf8:	10 07       	add	r7,r8
80002bfa:	c0 88       	rjmp	80002c0a <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002bfc:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002c00:	0e 9b       	mov	r11,r7
80002c02:	08 9c       	mov	r12,r4
80002c04:	f0 1f 00 07 	mcall	80002c20 <data_flash_write_block+0xbc>
80002c08:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002c0a:	e6 06 19 00 	cp.h	r6,r3
80002c0e:	5f 19       	srne	r9
80002c10:	58 7c       	cp.w	r12,7
80002c12:	5f 08       	sreq	r8
80002c14:	f3 e8 00 08 	and	r8,r9,r8
80002c18:	e4 08 18 00 	cp.b	r8,r2
80002c1c:	ca f1       	brne	80002b7a <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002c1e:	d8 32       	popm	r0-r7,pc
80002c20:	80 00       	ld.sh	r0,r0[0x0]
80002c22:	2a c8       	sub	r8,-84

80002c24 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002c24:	eb cd 40 c0 	pushm	r6-r7,lr
80002c28:	18 97       	mov	r7,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002c2a:	e0 68 ff fe 	mov	r8,65534
80002c2e:	ea 18 00 7f 	orh	r8,0x7f
80002c32:	10 3c       	cp.w	r12,r8
80002c34:	e0 88 00 04 	brls	80002c3c <data_flash_erase_block+0x18>
80002c38:	30 17       	mov	r7,1
80002c3a:	c3 e8       	rjmp	80002cb6 <data_flash_erase_block+0x92>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002c3c:	58 1b       	cp.w	r11,1
80002c3e:	c0 31       	brne	80002c44 <data_flash_erase_block+0x20>
80002c40:	32 06       	mov	r6,32
80002c42:	c0 a8       	rjmp	80002c56 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002c44:	58 2b       	cp.w	r11,2
80002c46:	c0 31       	brne	80002c4c <data_flash_erase_block+0x28>
80002c48:	35 26       	mov	r6,82
80002c4a:	c0 68       	rjmp	80002c56 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002c4c:	e0 66 00 d8 	mov	r6,216
80002c50:	58 3b       	cp.w	r11,3
80002c52:	f9 b6 01 60 	movne	r6,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c56:	30 09       	mov	r9,0
80002c58:	12 9a       	mov	r10,r9
80002c5a:	12 9b       	mov	r11,r9
80002c5c:	30 5c       	mov	r12,5
80002c5e:	f0 1f 00 18 	mcall	80002cbc <data_flash_erase_block+0x98>
	if ((status & STATUS_BUSY) != 0)
80002c62:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002c66:	c0 30       	breq	80002c6c <data_flash_erase_block+0x48>
80002c68:	30 27       	mov	r7,2
80002c6a:	c2 68       	rjmp	80002cb6 <data_flash_erase_block+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c6c:	30 09       	mov	r9,0
80002c6e:	12 9a       	mov	r10,r9
80002c70:	12 9b       	mov	r11,r9
80002c72:	30 6c       	mov	r12,6
80002c74:	f0 1f 00 12 	mcall	80002cbc <data_flash_erase_block+0x98>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002c78:	30 09       	mov	r9,0
80002c7a:	12 9a       	mov	r10,r9
80002c7c:	0e 9b       	mov	r11,r7
80002c7e:	0c 9c       	mov	r12,r6
80002c80:	f0 1f 00 0f 	mcall	80002cbc <data_flash_erase_block+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c84:	30 06       	mov	r6,0
80002c86:	30 57       	mov	r7,5
80002c88:	0c 99       	mov	r9,r6
80002c8a:	0c 9a       	mov	r10,r6
80002c8c:	0c 9b       	mov	r11,r6
80002c8e:	0e 9c       	mov	r12,r7
80002c90:	f0 1f 00 0b 	mcall	80002cbc <data_flash_erase_block+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002c94:	5c 7c       	castu.h	r12
80002c96:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002c9a:	cf 71       	brne	80002c88 <data_flash_erase_block+0x64>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002c9c:	18 97       	mov	r7,r12
80002c9e:	e2 17 00 20 	andl	r7,0x20,COH
80002ca2:	f9 b7 01 04 	movne	r7,4
80002ca6:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002caa:	30 09       	mov	r9,0
80002cac:	12 9a       	mov	r10,r9
80002cae:	12 9b       	mov	r11,r9
80002cb0:	30 4c       	mov	r12,4
80002cb2:	f0 1f 00 03 	mcall	80002cbc <data_flash_erase_block+0x98>

	return return_code;
}
80002cb6:	0e 9c       	mov	r12,r7
80002cb8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	28 d4       	sub	r4,-115

80002cc0 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002cc0:	d4 31       	pushm	r0-r7,lr
80002cc2:	20 3d       	sub	sp,12
80002cc4:	50 0c       	stdsp	sp[0x0],r12
80002cc6:	16 91       	mov	r1,r11
80002cc8:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002cca:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002cce:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002cd0:	e0 69 10 00 	mov	r9,4096
80002cd4:	f2 0a 01 07 	sub	r7,r9,r10
80002cd8:	ea 07 19 00 	cp.h	r7,r5
80002cdc:	ea 07 17 b0 	movhi	r7,r5
80002ce0:	5c 87       	casts.h	r7
80002ce2:	16 92       	mov	r2,r11
80002ce4:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002ce8:	4a e4       	lddpc	r4,80002da0 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002cea:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002cec:	e8 c8 ff ff 	sub	r8,r4,-1
80002cf0:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002cf2:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cf4:	08 9a       	mov	r10,r4
80002cf6:	e0 6b 10 00 	mov	r11,4096
80002cfa:	04 9c       	mov	r12,r2
80002cfc:	f0 1f 00 2a 	mcall	80002da4 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002d00:	58 07       	cp.w	r7,0
80002d02:	c3 00       	breq	80002d62 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002d04:	40 13       	lddsp	r3,sp[0x4]
80002d06:	5c 73       	castu.h	r3
80002d08:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002d0c:	ec 08 18 00 	cp.b	r8,r6
80002d10:	c1 11       	brne	80002d32 <data_flash_write+0x72>
80002d12:	e6 c9 ff ff 	sub	r9,r3,-1
80002d16:	08 09       	add	r9,r4
80002d18:	30 08       	mov	r8,0
80002d1a:	c0 58       	rjmp	80002d24 <data_flash_write+0x64>
80002d1c:	13 3a       	ld.ub	r10,r9++
80002d1e:	ec 0a 18 00 	cp.b	r10,r6
80002d22:	c0 81       	brne	80002d32 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002d24:	2f f8       	sub	r8,-1
80002d26:	5c 88       	casts.h	r8
80002d28:	f0 07 19 00 	cp.h	r7,r8
80002d2c:	fe 9b ff f8 	brhi	80002d1c <data_flash_write+0x5c>
80002d30:	c1 98       	rjmp	80002d62 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002d32:	30 1b       	mov	r11,1
80002d34:	04 9c       	mov	r12,r2
80002d36:	f0 1f 00 1d 	mcall	80002da8 <data_flash_write+0xe8>
80002d3a:	40 08       	lddsp	r8,sp[0x0]
80002d3c:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d3e:	40 2a       	lddsp	r10,sp[0x8]
80002d40:	40 19       	lddsp	r9,sp[0x4]
80002d42:	12 0a       	add	r10,r9
80002d44:	0e 99       	mov	r9,r7
80002d46:	20 19       	sub	r9,1
80002d48:	5c 79       	castu.h	r9
80002d4a:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002d4c:	11 39       	ld.ub	r9,r8++
80002d4e:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002d50:	14 33       	cp.w	r3,r10
80002d52:	cf d1       	brne	80002d4c <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002d54:	e0 6a 10 00 	mov	r10,4096
80002d58:	04 9b       	mov	r11,r2
80002d5a:	08 9c       	mov	r12,r4
80002d5c:	f0 1f 00 14 	mcall	80002dac <data_flash_write+0xec>
80002d60:	c0 78       	rjmp	80002d6e <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002d62:	0e 9a       	mov	r10,r7
80002d64:	5c 7a       	castu.h	r10
80002d66:	02 9b       	mov	r11,r1
80002d68:	40 0c       	lddsp	r12,sp[0x0]
80002d6a:	f0 1f 00 11 	mcall	80002dac <data_flash_write+0xec>
80002d6e:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002d72:	0e 98       	mov	r8,r7
80002d74:	ee 05 19 00 	cp.h	r5,r7
80002d78:	c1 20       	breq	80002d9c <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002d7a:	5c 78       	castu.h	r8
80002d7c:	40 0a       	lddsp	r10,sp[0x0]
80002d7e:	10 0a       	add	r10,r8
80002d80:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002d82:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002d84:	0e 15       	sub	r5,r7
80002d86:	5c 85       	casts.h	r5
80002d88:	e0 05 19 00 	cp.h	r5,r0
80002d8c:	ea 07 17 80 	movls	r7,r5
80002d90:	e0 07 17 b0 	movhi	r7,r0
80002d94:	5c 87       	casts.h	r7
80002d96:	30 09       	mov	r9,0
80002d98:	50 19       	stdsp	sp[0x4],r9
80002d9a:	ca db       	rjmp	80002cf4 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002d9c:	2f dd       	sub	sp,-12
80002d9e:	d8 32       	popm	r0-r7,pc
80002da0:	00 00       	add	r0,r0
80002da2:	0d 88       	ld.ub	r8,r6[0x0]
80002da4:	80 00       	ld.sh	r0,r0[0x0]
80002da6:	2a 90       	sub	r0,-87
80002da8:	80 00       	ld.sh	r0,r0[0x0]
80002daa:	2c 24       	sub	r4,-62
80002dac:	80 00       	ld.sh	r0,r0[0x0]
80002dae:	2b 64       	sub	r4,-74

80002db0 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002db0:	eb cd 40 c0 	pushm	r6-r7,lr
80002db4:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002db6:	4b f8       	lddpc	r8,80002eb0 <data_flash_init+0x100>
80002db8:	fa c6 ff fc 	sub	r6,sp,-4
80002dbc:	f0 ea 00 00 	ld.d	r10,r8[0]
80002dc0:	ec eb 00 00 	st.d	r6[0],r10
80002dc4:	f0 e8 00 08 	ld.d	r8,r8[8]
80002dc8:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002dcc:	30 4b       	mov	r11,4
80002dce:	4b ac       	lddpc	r12,80002eb4 <data_flash_init+0x104>
80002dd0:	f0 1f 00 3a 	mcall	80002eb8 <data_flash_init+0x108>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002dd4:	31 9c       	mov	r12,25
80002dd6:	f0 1f 00 3a 	mcall	80002ebc <data_flash_init+0x10c>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002dda:	31 9c       	mov	r12,25
80002ddc:	f0 1f 00 39 	mcall	80002ec0 <data_flash_init+0x110>

	spi = &AVR32_SPI;
80002de0:	4b 97       	lddpc	r7,80002ec4 <data_flash_init+0x114>
80002de2:	fe 7c 24 00 	mov	r12,-56320
80002de6:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002de8:	0c 9b       	mov	r11,r6
80002dea:	f0 1f 00 38 	mcall	80002ec8 <data_flash_init+0x118>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002dee:	30 09       	mov	r9,0
80002df0:	12 9a       	mov	r10,r9
80002df2:	12 9b       	mov	r11,r9
80002df4:	6e 0c       	ld.w	r12,r7[0x0]
80002df6:	f0 1f 00 36 	mcall	80002ecc <data_flash_init+0x11c>

	// Enable SPI.
	spi_enable(spi);
80002dfa:	6e 0c       	ld.w	r12,r7[0x0]
80002dfc:	f0 1f 00 35 	mcall	80002ed0 <data_flash_init+0x120>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002e00:	e0 6a 36 00 	mov	r10,13824
80002e04:	ea 1a 01 6e 	orh	r10,0x16e
80002e08:	0c 9b       	mov	r11,r6
80002e0a:	6e 0c       	ld.w	r12,r7[0x0]
80002e0c:	f0 1f 00 32 	mcall	80002ed4 <data_flash_init+0x124>
80002e10:	c0 50       	breq	80002e1a <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002e12:	30 29       	mov	r9,2
80002e14:	4b 18       	lddpc	r8,80002ed8 <data_flash_init+0x128>
80002e16:	b0 89       	st.b	r8[0x0],r9
		return;
80002e18:	c4 88       	rjmp	80002ea8 <data_flash_init+0xf8>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002e1a:	1a 96       	mov	r6,sp
80002e1c:	30 4a       	mov	r10,4
80002e1e:	4b 0b       	lddpc	r11,80002edc <data_flash_init+0x12c>
80002e20:	1a 9c       	mov	r12,sp
80002e22:	f0 1f 00 30 	mcall	80002ee0 <data_flash_init+0x130>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002e26:	4a 87       	lddpc	r7,80002ec4 <data_flash_init+0x114>
80002e28:	30 0b       	mov	r11,0
80002e2a:	6e 0c       	ld.w	r12,r7[0x0]
80002e2c:	f0 1f 00 2e 	mcall	80002ee4 <data_flash_init+0x134>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002e30:	e0 6b 00 9f 	mov	r11,159
80002e34:	6e 0c       	ld.w	r12,r7[0x0]
80002e36:	f0 1f 00 2d 	mcall	80002ee8 <data_flash_init+0x138>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002e3a:	e0 6b 00 ff 	mov	r11,255
80002e3e:	6e 0c       	ld.w	r12,r7[0x0]
80002e40:	f0 1f 00 2a 	mcall	80002ee8 <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[0]);
80002e44:	1a 9b       	mov	r11,sp
80002e46:	6e 0c       	ld.w	r12,r7[0x0]
80002e48:	f0 1f 00 29 	mcall	80002eec <data_flash_init+0x13c>
	spi_write_dummy();
80002e4c:	e0 6b 00 ff 	mov	r11,255
80002e50:	6e 0c       	ld.w	r12,r7[0x0]
80002e52:	f0 1f 00 26 	mcall	80002ee8 <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[1]);
80002e56:	fa cb ff fe 	sub	r11,sp,-2
80002e5a:	6e 0c       	ld.w	r12,r7[0x0]
80002e5c:	f0 1f 00 24 	mcall	80002eec <data_flash_init+0x13c>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002e60:	30 0b       	mov	r11,0
80002e62:	6e 0c       	ld.w	r12,r7[0x0]
80002e64:	f0 1f 00 23 	mcall	80002ef0 <data_flash_init+0x140>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002e68:	31 f8       	mov	r8,31
80002e6a:	9a 09       	ld.sh	r9,sp[0x0]
80002e6c:	f0 09 19 00 	cp.h	r9,r8
80002e70:	c0 61       	brne	80002e7c <data_flash_init+0xcc>
80002e72:	34 88       	mov	r8,72
80002e74:	9a 19       	ld.sh	r9,sp[0x2]
80002e76:	f0 09 19 00 	cp.h	r9,r8
80002e7a:	c0 50       	breq	80002e84 <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002e7c:	30 39       	mov	r9,3
80002e7e:	49 78       	lddpc	r8,80002ed8 <data_flash_init+0x128>
80002e80:	b0 89       	st.b	r8[0x0],r9
		return;
80002e82:	c1 38       	rjmp	80002ea8 <data_flash_init+0xf8>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e84:	30 09       	mov	r9,0
80002e86:	12 9a       	mov	r10,r9
80002e88:	12 9b       	mov	r11,r9
80002e8a:	30 6c       	mov	r12,6
80002e8c:	f0 1f 00 1a 	mcall	80002ef4 <data_flash_init+0x144>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002e90:	30 09       	mov	r9,0
80002e92:	12 9a       	mov	r10,r9
80002e94:	12 9b       	mov	r11,r9
80002e96:	30 1c       	mov	r12,1
80002e98:	f0 1f 00 17 	mcall	80002ef4 <data_flash_init+0x144>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002e9c:	30 09       	mov	r9,0
80002e9e:	12 9a       	mov	r10,r9
80002ea0:	12 9b       	mov	r11,r9
80002ea2:	30 5c       	mov	r12,5
80002ea4:	f0 1f 00 14 	mcall	80002ef4 <data_flash_init+0x144>
	
	return;
}
80002ea8:	2f bd       	sub	sp,-20
80002eaa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002eae:	00 00       	add	r0,r0
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	ce a0       	breq	80002e86 <data_flash_init+0xd6>
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	ce b4       	brge	80002e8c <data_flash_init+0xdc>
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	4e 90       	lddpc	r0,8000305c <phy_tx+0x50>
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	4e c0       	lddpc	r0,8000306c <get_idle_store_isr+0x4>
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	4e d8       	lddpc	r8,80003074 <get_idle_store_isr+0xc>
80002ec4:	00 00       	add	r0,r0
80002ec6:	1d 88       	ld.ub	r8,lr[0x0]
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	50 24       	stdsp	sp[0x8],r4
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	50 5c       	stdsp	sp[0x14],r12
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	50 88       	stdsp	sp[0x20],r8
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	50 cc       	stdsp	sp[0x30],r12
80002ed8:	00 00       	add	r0,r0
80002eda:	0a 5c       	eor	r12,r5
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	ce b0       	breq	80002eb4 <data_flash_init+0x104>
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	70 16       	ld.w	r6,r8[0x4]
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	51 f4       	stdsp	sp[0x7c],r4
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	50 8e       	stdsp	sp[0x20],lr
80002eec:	80 00       	ld.sh	r0,r0[0x0]
80002eee:	50 aa       	stdsp	sp[0x28],r10
80002ef0:	80 00       	ld.sh	r0,r0[0x0]
80002ef2:	51 b4       	stdsp	sp[0x6c],r4
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	28 d4       	sub	r4,-115

80002ef8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002ef8:	20 1c       	sub	r12,1
80002efa:	5c 5c       	castu.b	r12
80002efc:	31 18       	mov	r8,17
80002efe:	f0 0c 18 00 	cp.b	r12,r8
80002f02:	e0 88 00 03 	brls	80002f08 <CalculateBurst+0x10>
80002f06:	5e fd       	retal	0
80002f08:	48 28       	lddpc	r8,80002f10 <CalculateBurst+0x18>
80002f0a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002f0e:	5e fc       	retal	r12
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	ce d4       	brge	80002eec <data_flash_init+0x13c>

80002f14 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002f14:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002f16:	48 98       	lddpc	r8,80002f38 <payload_init+0x24>
80002f18:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002f1a:	48 98       	lddpc	r8,80002f3c <payload_init+0x28>
80002f1c:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002f1e:	30 09       	mov	r9,0
80002f20:	1a d9       	st.w	--sp,r9
80002f22:	1a d9       	st.w	--sp,r9
80002f24:	1a d9       	st.w	--sp,r9
80002f26:	30 28       	mov	r8,2
80002f28:	e0 6a 04 00 	mov	r10,1024
80002f2c:	48 5b       	lddpc	r11,80002f40 <payload_init+0x2c>
80002f2e:	48 6c       	lddpc	r12,80002f44 <payload_init+0x30>
80002f30:	f0 1f 00 06 	mcall	80002f48 <payload_init+0x34>
80002f34:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002f36:	d8 02       	popm	pc
80002f38:	00 00       	add	r0,r0
80002f3a:	0a 60       	and	r0,r5
80002f3c:	00 00       	add	r0,r0
80002f3e:	0a 64       	and	r4,r5
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	cf 1c       	rcall	80003124 <phy_tx_func+0x94>
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	2f 4c       	sub	r12,-12
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	63 b4       	ld.w	r4,r1[0x6c]

80002f4c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002f4c:	eb cd 40 f8 	pushm	r3-r7,lr
80002f50:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002f52:	48 e8       	lddpc	r8,80002f88 <payload_rx_process+0x3c>
80002f54:	70 08       	ld.w	r8,r8[0x0]
80002f56:	58 08       	cp.w	r8,0
80002f58:	c0 71       	brne	80002f66 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f5a:	30 4b       	mov	r11,4
80002f5c:	30 5c       	mov	r12,5
80002f5e:	f0 1f 00 0c 	mcall	80002f8c <payload_rx_process+0x40>
80002f62:	48 a8       	lddpc	r8,80002f88 <payload_rx_process+0x3c>
80002f64:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f66:	48 96       	lddpc	r6,80002f88 <payload_rx_process+0x3c>
80002f68:	30 05       	mov	r5,0
80002f6a:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f6c:	48 93       	lddpc	r3,80002f90 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f6e:	6c 0c       	ld.w	r12,r6[0x0]
80002f70:	0a 99       	mov	r9,r5
80002f72:	08 9a       	mov	r10,r4
80002f74:	1a 9b       	mov	r11,sp
80002f76:	f0 1f 00 08 	mcall	80002f94 <payload_rx_process+0x48>
80002f7a:	58 1c       	cp.w	r12,1
80002f7c:	cf 91       	brne	80002f6e <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f7e:	66 08       	ld.w	r8,r3[0x0]
80002f80:	40 0c       	lddsp	r12,sp[0x0]
80002f82:	5d 18       	icall	r8
80002f84:	cf 5b       	rjmp	80002f6e <payload_rx_process+0x22>
80002f86:	00 00       	add	r0,r0
80002f88:	00 00       	add	r0,r0
80002f8a:	0a 90       	mov	r0,r5
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	5c 98       	brev	r8
80002f90:	00 00       	add	r0,r0
80002f92:	0a 60       	and	r0,r5
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	59 8c       	cp.w	r12,24

80002f98 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002f98:	d4 01       	pushm	lr
80002f9a:	20 2d       	sub	sp,8
80002f9c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f9e:	30 09       	mov	r9,0
80002fa0:	fa ca ff f8 	sub	r10,sp,-8
80002fa4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002fa6:	1a 9b       	mov	r11,sp
80002fa8:	f0 1f 00 02 	mcall	80002fb0 <set_idle_store_isr+0x18>
}
80002fac:	2f ed       	sub	sp,-8
80002fae:	d8 02       	popm	pc
80002fb0:	80 00       	ld.sh	r0,r0[0x0]
80002fb2:	5b 48       	cp.w	r8,-12

80002fb4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002fb4:	d4 01       	pushm	lr
80002fb6:	20 2d       	sub	sp,8
80002fb8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002fba:	58 0c       	cp.w	r12,0
80002fbc:	c1 10       	breq	80002fde <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fbe:	30 08       	mov	r8,0
80002fc0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002fc2:	98 88       	ld.uh	r8,r12[0x0]
80002fc4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002fc8:	e0 48 40 00 	cp.w	r8,16384
80002fcc:	c0 91       	brne	80002fde <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002fce:	48 68       	lddpc	r8,80002fe4 <phy_rx+0x30>
80002fd0:	70 0c       	ld.w	r12,r8[0x0]
80002fd2:	30 09       	mov	r9,0
80002fd4:	fa ca ff fc 	sub	r10,sp,-4
80002fd8:	1a 9b       	mov	r11,sp
80002fda:	f0 1f 00 04 	mcall	80002fe8 <phy_rx+0x34>
		}	

    }
		
 
}
80002fde:	2f ed       	sub	sp,-8
80002fe0:	d8 02       	popm	pc
80002fe2:	00 00       	add	r0,r0
80002fe4:	00 00       	add	r0,r0
80002fe6:	0a bc       	st.h	r5++,r12
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	5b 48       	cp.w	r8,-12

80002fec <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002fec:	eb cd 40 80 	pushm	r7,lr
80002ff0:	20 1d       	sub	sp,4
80002ff2:	fa c7 ff fc 	sub	r7,sp,-4
80002ff6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002ff8:	30 09       	mov	r9,0
80002ffa:	12 9a       	mov	r10,r9
80002ffc:	1a 9b       	mov	r11,sp
80002ffe:	f0 1f 00 03 	mcall	80003008 <set_idle_store+0x1c>
}
80003002:	2f fd       	sub	sp,-4
80003004:	e3 cd 80 80 	ldm	sp++,r7,pc
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	5b 98       	cp.w	r8,-7

8000300c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
8000300c:	d4 01       	pushm	lr
8000300e:	20 1d       	sub	sp,4
80003010:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003012:	98 88       	ld.uh	r8,r12[0x0]
80003014:	e2 18 f0 00 	andl	r8,0xf000,COH
80003018:	e0 48 40 00 	cp.w	r8,16384
8000301c:	c0 d1       	brne	80003036 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
8000301e:	49 08       	lddpc	r8,8000305c <phy_tx+0x50>
80003020:	70 08       	ld.w	r8,r8[0x0]
80003022:	58 08       	cp.w	r8,0
80003024:	c1 a0       	breq	80003058 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003026:	48 e8       	lddpc	r8,8000305c <phy_tx+0x50>
80003028:	70 0c       	ld.w	r12,r8[0x0]
8000302a:	30 09       	mov	r9,0
8000302c:	12 9a       	mov	r10,r9
8000302e:	1a 9b       	mov	r11,sp
80003030:	f0 1f 00 0c 	mcall	80003060 <phy_tx+0x54>
80003034:	c1 28       	rjmp	80003058 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003036:	e0 48 10 00 	cp.w	r8,4096
8000303a:	5f 0a       	sreq	r10
8000303c:	e0 48 20 00 	cp.w	r8,8192
80003040:	5f 09       	sreq	r9
80003042:	f5 e9 10 09 	or	r9,r10,r9
80003046:	c0 71       	brne	80003054 <phy_tx+0x48>
80003048:	e0 48 50 00 	cp.w	r8,20480
8000304c:	c0 40       	breq	80003054 <phy_tx+0x48>
8000304e:	e0 48 60 00 	cp.w	r8,24576
80003052:	c0 31       	brne	80003058 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003054:	48 48       	lddpc	r8,80003064 <phy_tx+0x58>
80003056:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003058:	2f fd       	sub	sp,-4
8000305a:	d8 02       	popm	pc
8000305c:	00 00       	add	r0,r0
8000305e:	0a c8       	st.b	r5++,r8
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	5b 98       	cp.w	r8,-7
80003064:	00 00       	add	r0,r0
80003066:	0a b0       	st.h	r5++,r0

80003068 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003068:	d4 01       	pushm	lr
8000306a:	20 2d       	sub	sp,8
	void * ptr = NULL;
8000306c:	30 08       	mov	r8,0
8000306e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003070:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003072:	1a 9a       	mov	r10,sp
80003074:	fa cb ff fc 	sub	r11,sp,-4
80003078:	f0 1f 00 05 	mcall	8000308c <get_idle_store_isr+0x24>
8000307c:	58 1c       	cp.w	r12,1
8000307e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003082:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003086:	2f ed       	sub	sp,-8
80003088:	d8 02       	popm	pc
8000308a:	00 00       	add	r0,r0
8000308c:	80 00       	ld.sh	r0,r0[0x0]
8000308e:	58 9c       	cp.w	r12,9

80003090 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003090:	eb cd 40 c0 	pushm	r6-r7,lr
80003094:	20 1d       	sub	sp,4
80003096:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003098:	4b a8       	lddpc	r8,80003180 <phy_tx_func+0xf0>
8000309a:	70 08       	ld.w	r8,r8[0x0]
8000309c:	58 08       	cp.w	r8,0
8000309e:	c6 60       	breq	8000316a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
800030a0:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800030a2:	30 08       	mov	r8,0
800030a4:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800030a6:	4b 88       	lddpc	r8,80003184 <phy_tx_func+0xf4>
800030a8:	70 08       	ld.w	r8,r8[0x0]
800030aa:	58 18       	cp.w	r8,1
800030ac:	c2 60       	breq	800030f8 <phy_tx_func+0x68>
800030ae:	c0 43       	brcs	800030b6 <phy_tx_func+0x26>
800030b0:	58 28       	cp.w	r8,2
800030b2:	c5 c1       	brne	8000316a <phy_tx_func+0xda>
800030b4:	c5 58       	rjmp	8000315e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800030b6:	4b 38       	lddpc	r8,80003180 <phy_tx_func+0xf0>
800030b8:	70 0c       	ld.w	r12,r8[0x0]
800030ba:	1a 9a       	mov	r10,sp
800030bc:	4b 3b       	lddpc	r11,80003188 <phy_tx_func+0xf8>
800030be:	f0 1f 00 34 	mcall	8000318c <phy_tx_func+0xfc>
800030c2:	58 1c       	cp.w	r12,1
800030c4:	c1 41       	brne	800030ec <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800030c6:	4b 18       	lddpc	r8,80003188 <phy_tx_func+0xf8>
800030c8:	70 08       	ld.w	r8,r8[0x0]
800030ca:	90 08       	ld.sh	r8,r8[0x0]
800030cc:	10 9a       	mov	r10,r8
800030ce:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800030d2:	4b 09       	lddpc	r9,80003190 <phy_tx_func+0x100>
800030d4:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800030d6:	5c 78       	castu.h	r8
800030d8:	ea 18 ab cd 	orh	r8,0xabcd
800030dc:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800030de:	30 19       	mov	r9,1
800030e0:	4a d8       	lddpc	r8,80003194 <phy_tx_func+0x104>
800030e2:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800030e4:	30 19       	mov	r9,1
800030e6:	4a 88       	lddpc	r8,80003184 <phy_tx_func+0xf4>
800030e8:	91 09       	st.w	r8[0x0],r9
800030ea:	c4 08       	rjmp	8000316a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800030ec:	e0 68 5a 5a 	mov	r8,23130
800030f0:	ea 18 ab cd 	orh	r8,0xabcd
800030f4:	8f 18       	st.w	r7[0x4],r8
800030f6:	c3 a8       	rjmp	8000316a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800030f8:	4a 7a       	lddpc	r10,80003194 <phy_tx_func+0x104>
800030fa:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800030fc:	4a 39       	lddpc	r9,80003188 <phy_tx_func+0xf8>
800030fe:	72 09       	ld.w	r9,r9[0x0]
80003100:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003104:	b1 69       	lsl	r9,0x10
80003106:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003108:	2f f8       	sub	r8,-1
8000310a:	5c 58       	castu.b	r8
8000310c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
8000310e:	4a 1b       	lddpc	r11,80003190 <phy_tx_func+0x100>
80003110:	96 0c       	ld.sh	r12,r11[0x0]
80003112:	20 2c       	sub	r12,2
80003114:	5c 8c       	casts.h	r12
80003116:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
8000311a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000311c:	30 0b       	mov	r11,0
8000311e:	f6 0a 19 00 	cp.h	r10,r11
80003122:	e0 89 00 09 	brgt	80003134 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003126:	e8 19 00 ba 	orl	r9,0xba
8000312a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
8000312c:	30 09       	mov	r9,0
8000312e:	49 68       	lddpc	r8,80003184 <phy_tx_func+0xf4>
80003130:	91 09       	st.w	r8[0x0],r9
80003132:	c1 c8       	rjmp	8000316a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003134:	49 5a       	lddpc	r10,80003188 <phy_tx_func+0xf8>
80003136:	74 0a       	ld.w	r10,r10[0x0]
80003138:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
8000313c:	14 49       	or	r9,r10
8000313e:	8f 19       	st.w	r7[0x4],r9
80003140:	2f f8       	sub	r8,-1
80003142:	49 59       	lddpc	r9,80003194 <phy_tx_func+0x104>
80003144:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003146:	20 2c       	sub	r12,2
80003148:	49 28       	lddpc	r8,80003190 <phy_tx_func+0x100>
8000314a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000314c:	30 08       	mov	r8,0
8000314e:	f0 0c 19 00 	cp.h	r12,r8
80003152:	e0 89 00 0c 	brgt	8000316a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003156:	30 29       	mov	r9,2
80003158:	48 b8       	lddpc	r8,80003184 <phy_tx_func+0xf4>
8000315a:	91 09       	st.w	r8[0x0],r9
8000315c:	c0 78       	rjmp	8000316a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000315e:	fc 18 00 ba 	movh	r8,0xba
80003162:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003164:	30 09       	mov	r9,0
80003166:	48 88       	lddpc	r8,80003184 <phy_tx_func+0xf4>
80003168:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
8000316a:	e0 68 5a 5a 	mov	r8,23130
8000316e:	ea 18 ab cd 	orh	r8,0xabcd
80003172:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80003174:	30 08       	mov	r8,0
80003176:	8f 38       	st.w	r7[0xc],r8
}
80003178:	2f fd       	sub	sp,-4
8000317a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000317e:	00 00       	add	r0,r0
80003180:	00 00       	add	r0,r0
80003182:	0a c8       	st.b	r5++,r8
80003184:	00 00       	add	r0,r0
80003186:	0a 84       	andn	r4,r5
80003188:	00 00       	add	r0,r0
8000318a:	0a d0       	st.w	--r5,r0
8000318c:	80 00       	ld.sh	r0,r0[0x0]
8000318e:	58 9c       	cp.w	r12,9
80003190:	00 00       	add	r0,r0
80003192:	0a ac       	st.w	r5++,r12
80003194:	00 00       	add	r0,r0
80003196:	0a 68       	and	r8,r5

80003198 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80003198:	d4 01       	pushm	lr
8000319a:	20 1d       	sub	sp,4
	void * ptr = NULL;
8000319c:	30 0a       	mov	r10,0
8000319e:	fa cb ff fc 	sub	r11,sp,-4
800031a2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800031a4:	14 99       	mov	r9,r10
800031a6:	1a 9b       	mov	r11,sp
800031a8:	f0 1f 00 05 	mcall	800031bc <get_idle_store+0x24>
800031ac:	58 1c       	cp.w	r12,1
800031ae:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800031b2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800031b6:	2f fd       	sub	sp,-4
800031b8:	d8 02       	popm	pc
800031ba:	00 00       	add	r0,r0
800031bc:	80 00       	ld.sh	r0,r0[0x0]
800031be:	59 8c       	cp.w	r12,24

800031c0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800031c0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800031c2:	48 5b       	lddpc	r11,800031d4 <phy_init+0x14>
800031c4:	48 5c       	lddpc	r12,800031d8 <phy_init+0x18>
800031c6:	f0 1f 00 06 	mcall	800031dc <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
800031ca:	f0 1f 00 06 	mcall	800031e0 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
800031ce:	f0 1f 00 06 	mcall	800031e4 <phy_init+0x24>
	
}
800031d2:	d8 02       	popm	pc
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	30 90       	mov	r0,9
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	32 48       	mov	r8,36
800031dc:	80 00       	ld.sh	r0,r0[0x0]
800031de:	42 90       	lddsp	r0,sp[0xa4]
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	42 a4       	lddsp	r4,sp[0xa8]
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	4b c0       	lddpc	r0,800032d4 <phy_rx_func+0x8c>

800031e8 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
800031e8:	d4 01       	pushm	lr
800031ea:	20 2d       	sub	sp,8
800031ec:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800031ee:	30 08       	mov	r8,0
800031f0:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
800031f2:	48 f8       	lddpc	r8,8000322c <payload_rx+0x44>
800031f4:	70 08       	ld.w	r8,r8[0x0]
800031f6:	58 08       	cp.w	r8,0
800031f8:	c0 71       	brne	80003206 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800031fa:	30 4b       	mov	r11,4
800031fc:	30 5c       	mov	r12,5
800031fe:	f0 1f 00 0d 	mcall	80003230 <payload_rx+0x48>
80003202:	48 b8       	lddpc	r8,8000322c <payload_rx+0x44>
80003204:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80003206:	48 a8       	lddpc	r8,8000322c <payload_rx+0x44>
80003208:	70 0c       	ld.w	r12,r8[0x0]
8000320a:	30 09       	mov	r9,0
8000320c:	fa ca ff fc 	sub	r10,sp,-4
80003210:	1a 9b       	mov	r11,sp
80003212:	f0 1f 00 09 	mcall	80003234 <payload_rx+0x4c>
80003216:	c0 91       	brne	80003228 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80003218:	48 88       	lddpc	r8,80003238 <payload_rx+0x50>
8000321a:	70 0c       	ld.w	r12,r8[0x0]
8000321c:	40 0b       	lddsp	r11,sp[0x0]
8000321e:	f0 1f 00 08 	mcall	8000323c <payload_rx+0x54>
		logFromISR("mm");
80003222:	48 8c       	lddpc	r12,80003240 <payload_rx+0x58>
80003224:	f0 1f 00 08 	mcall	80003244 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80003228:	2f ed       	sub	sp,-8
8000322a:	d8 02       	popm	pc
8000322c:	00 00       	add	r0,r0
8000322e:	0a 90       	mov	r0,r5
80003230:	80 00       	ld.sh	r0,r0[0x0]
80003232:	5c 98       	brev	r8
80003234:	80 00       	ld.sh	r0,r0[0x0]
80003236:	5b 48       	cp.w	r8,-12
80003238:	00 00       	add	r0,r0
8000323a:	0a 74       	tst	r4,r5
8000323c:	80 00       	ld.sh	r0,r0[0x0]
8000323e:	2f 98       	sub	r8,-7
80003240:	80 00       	ld.sh	r0,r0[0x0]
80003242:	cf 28       	rjmp	80003426 <phy_rx_func+0x1de>
80003244:	80 00       	ld.sh	r0,r0[0x0]
80003246:	69 04       	ld.w	r4,r4[0x40]

80003248 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003248:	eb cd 40 e0 	pushm	r5-r7,lr
8000324c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000324e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80003252:	70 08       	ld.w	r8,r8[0x0]
80003254:	58 08       	cp.w	r8,0
80003256:	e0 80 01 08 	breq	80003466 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000325a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
8000325c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003260:	70 09       	ld.w	r9,r8[0x0]
80003262:	2f f9       	sub	r9,-1
80003264:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003266:	fe f8 0e 6a 	ld.w	r8,pc[3690]
8000326a:	70 08       	ld.w	r8,r8[0x0]
8000326c:	58 18       	cp.w	r8,1
8000326e:	e0 80 00 85 	breq	80003378 <phy_rx_func+0x130>
80003272:	c0 73       	brcs	80003280 <phy_rx_func+0x38>
80003274:	58 28       	cp.w	r8,2
80003276:	c5 c0       	breq	8000332e <phy_rx_func+0xe6>
80003278:	58 38       	cp.w	r8,3
8000327a:	e0 81 00 f6 	brne	80003466 <phy_rx_func+0x21e>
8000327e:	cd 58       	rjmp	80003428 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003280:	e0 6a 5a 5a 	mov	r10,23130
80003284:	ea 1a ab cd 	orh	r10,0xabcd
80003288:	14 36       	cp.w	r6,r10
8000328a:	e0 80 00 ee 	breq	80003466 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000328e:	ec 08 16 10 	lsr	r8,r6,0x10
80003292:	e0 48 ab cd 	cp.w	r8,43981
80003296:	e0 81 00 e8 	brne	80003466 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000329a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000329e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800032a2:	20 28       	sub	r8,2
800032a4:	fe f9 0e 30 	ld.w	r9,pc[3632]
800032a8:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800032aa:	30 09       	mov	r9,0
800032ac:	f2 08 19 00 	cp.h	r8,r9
800032b0:	e0 8a 00 db 	brle	80003466 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
800032b4:	fe f8 0e 24 	ld.w	r8,pc[3620]
800032b8:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
800032ba:	fe f8 0e 22 	ld.w	r8,pc[3618]
800032be:	70 0c       	ld.w	r12,r8[0x0]
800032c0:	f0 1f 03 88 	mcall	800040e0 <phy_rx_func+0xe98>
800032c4:	fe f8 0e 20 	ld.w	r8,pc[3616]
800032c8:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800032ca:	58 0c       	cp.w	r12,0
800032cc:	e0 80 00 cd 	breq	80003466 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800032d0:	fe f8 0e 08 	ld.w	r8,pc[3592]
800032d4:	90 09       	ld.sh	r9,r8[0x0]
800032d6:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800032da:	2f f9       	sub	r9,-1
800032dc:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800032de:	fe fa 0e 06 	ld.w	r10,pc[3590]
800032e2:	74 0a       	ld.w	r10,r10[0x0]
800032e4:	fe fb 0d e8 	ld.w	r11,pc[3560]
800032e8:	76 0b       	ld.w	r11,r11[0x0]
800032ea:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800032ee:	2f f9       	sub	r9,-1
800032f0:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800032f2:	e2 16 0f 00 	andl	r6,0xf00,COH
800032f6:	e0 46 01 00 	cp.w	r6,256
800032fa:	c0 c0       	breq	80003312 <phy_rx_func+0xca>
800032fc:	e0 8b 00 05 	brhi	80003306 <phy_rx_func+0xbe>
80003300:	58 06       	cp.w	r6,0
80003302:	c0 80       	breq	80003312 <phy_rx_func+0xca>
80003304:	c0 c8       	rjmp	8000331c <phy_rx_func+0xd4>
80003306:	e0 46 02 00 	cp.w	r6,512
8000330a:	c0 40       	breq	80003312 <phy_rx_func+0xca>
8000330c:	e0 46 03 00 	cp.w	r6,768
80003310:	c0 61       	brne	8000331c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003312:	30 29       	mov	r9,2
80003314:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003318:	91 09       	st.w	r8[0x0],r9
8000331a:	ca 68       	rjmp	80003466 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
8000331c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003320:	70 0c       	ld.w	r12,r8[0x0]
80003322:	fe f8 0d c2 	ld.w	r8,pc[3522]
80003326:	70 0b       	ld.w	r11,r8[0x0]
80003328:	f0 1f 03 70 	mcall	800040e8 <phy_rx_func+0xea0>
8000332c:	c9 d8       	rjmp	80003466 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
8000332e:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003332:	b1 86       	lsr	r6,0x10
80003334:	14 06       	add	r6,r10
80003336:	fe f8 0d b6 	ld.w	r8,pc[3510]
8000333a:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000333c:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003340:	90 09       	ld.sh	r9,r8[0x0]
80003342:	fe fb 0d a2 	ld.w	r11,pc[3490]
80003346:	76 0b       	ld.w	r11,r11[0x0]
80003348:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000334c:	2f f9       	sub	r9,-1
8000334e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003350:	fe f9 0d 84 	ld.w	r9,pc[3460]
80003354:	92 08       	ld.sh	r8,r9[0x0]
80003356:	20 28       	sub	r8,2
80003358:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000335a:	30 09       	mov	r9,0
8000335c:	f2 08 19 00 	cp.h	r8,r9
80003360:	e0 8a 00 07 	brle	8000336e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003364:	30 19       	mov	r9,1
80003366:	fe f8 0d 6a 	ld.w	r8,pc[3434]
8000336a:	91 09       	st.w	r8[0x0],r9
8000336c:	c7 d8       	rjmp	80003466 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
8000336e:	30 39       	mov	r9,3
80003370:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003374:	91 09       	st.w	r8[0x0],r9
80003376:	c7 88       	rjmp	80003466 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003378:	ec 0a 14 10 	asr	r10,r6,0x10
8000337c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003380:	90 09       	ld.sh	r9,r8[0x0]
80003382:	14 09       	add	r9,r10
80003384:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003386:	fe f9 0d 52 	ld.w	r9,pc[3410]
8000338a:	92 08       	ld.sh	r8,r9[0x0]
8000338c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003390:	76 0b       	ld.w	r11,r11[0x0]
80003392:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003396:	2f f8       	sub	r8,-1
80003398:	5c 88       	casts.h	r8
8000339a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000339c:	fe fa 0d 38 	ld.w	r10,pc[3384]
800033a0:	94 09       	ld.sh	r9,r10[0x0]
800033a2:	20 29       	sub	r9,2
800033a4:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800033a6:	30 0a       	mov	r10,0
800033a8:	f4 09 19 00 	cp.h	r9,r10
800033ac:	e0 89 00 20 	brgt	800033ec <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800033b0:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800033b4:	e0 46 00 ba 	cp.w	r6,186
800033b8:	c0 d1       	brne	800033d2 <phy_rx_func+0x18a>
800033ba:	fe f8 0d 32 	ld.w	r8,pc[3378]
800033be:	90 09       	ld.sh	r9,r8[0x0]
800033c0:	f4 09 19 00 	cp.h	r9,r10
800033c4:	c0 71       	brne	800033d2 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800033c6:	fe f8 0d 1e 	ld.w	r8,pc[3358]
800033ca:	70 0c       	ld.w	r12,r8[0x0]
800033cc:	f0 1f 03 49 	mcall	800040f0 <phy_rx_func+0xea8>
800033d0:	c0 98       	rjmp	800033e2 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
800033d2:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800033d6:	70 0c       	ld.w	r12,r8[0x0]
800033d8:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800033dc:	70 0b       	ld.w	r11,r8[0x0]
800033de:	f0 1f 03 43 	mcall	800040e8 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800033e2:	30 09       	mov	r9,0
800033e4:	fe f8 0c ec 	ld.w	r8,pc[3308]
800033e8:	91 09       	st.w	r8[0x0],r9
800033ea:	c3 e8       	rjmp	80003466 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800033ec:	5c 86       	casts.h	r6
800033ee:	fe f9 0c fe 	ld.w	r9,pc[3326]
800033f2:	92 0a       	ld.sh	r10,r9[0x0]
800033f4:	0c 0a       	add	r10,r6
800033f6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800033f8:	fe f9 0c ec 	ld.w	r9,pc[3308]
800033fc:	72 09       	ld.w	r9,r9[0x0]
800033fe:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003402:	2f f8       	sub	r8,-1
80003404:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003408:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000340a:	fe f9 0c ca 	ld.w	r9,pc[3274]
8000340e:	92 08       	ld.sh	r8,r9[0x0]
80003410:	20 28       	sub	r8,2
80003412:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003414:	30 09       	mov	r9,0
80003416:	f2 08 19 00 	cp.h	r8,r9
8000341a:	e0 89 00 26 	brgt	80003466 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000341e:	30 39       	mov	r9,3
80003420:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003424:	91 09       	st.w	r8[0x0],r9
80003426:	c2 08       	rjmp	80003466 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003428:	e6 16 00 ff 	andh	r6,0xff,COH
8000342c:	fc 19 00 ba 	movh	r9,0xba
80003430:	12 36       	cp.w	r6,r9
80003432:	c0 e1       	brne	8000344e <phy_rx_func+0x206>
80003434:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003438:	90 09       	ld.sh	r9,r8[0x0]
8000343a:	30 08       	mov	r8,0
8000343c:	f0 09 19 00 	cp.h	r9,r8
80003440:	c0 71       	brne	8000344e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003442:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003446:	70 0c       	ld.w	r12,r8[0x0]
80003448:	f0 1f 03 2a 	mcall	800040f0 <phy_rx_func+0xea8>
8000344c:	c0 98       	rjmp	8000345e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000344e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003452:	70 0c       	ld.w	r12,r8[0x0]
80003454:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003458:	70 0b       	ld.w	r11,r8[0x0]
8000345a:	f0 1f 03 24 	mcall	800040e8 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000345e:	30 09       	mov	r9,0
80003460:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003464:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003466:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000346a:	11 89       	ld.ub	r9,r8[0x0]
8000346c:	30 08       	mov	r8,0
8000346e:	f0 09 18 00 	cp.b	r9,r8
80003472:	c1 31       	brne	80003498 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003474:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003478:	6c 0c       	ld.w	r12,r6[0x0]
8000347a:	f0 1f 03 1a 	mcall	800040e0 <phy_rx_func+0xe98>
8000347e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003482:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003484:	6c 0c       	ld.w	r12,r6[0x0]
80003486:	f0 1f 03 17 	mcall	800040e0 <phy_rx_func+0xe98>
8000348a:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000348e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003490:	30 19       	mov	r9,1
80003492:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003496:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003498:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000349c:	70 08       	ld.w	r8,r8[0x0]
8000349e:	58 28       	cp.w	r8,2
800034a0:	e0 80 01 98 	breq	800037d0 <phy_rx_func+0x588>
800034a4:	e0 8b 00 06 	brhi	800034b0 <phy_rx_func+0x268>
800034a8:	58 08       	cp.w	r8,0
800034aa:	c0 b0       	breq	800034c0 <phy_rx_func+0x278>
800034ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800034b0:	58 38       	cp.w	r8,3
800034b2:	e0 80 05 c5 	breq	8000403c <phy_rx_func+0xdf4>
800034b6:	58 48       	cp.w	r8,4
800034b8:	e0 81 06 05 	brne	800040c2 <phy_rx_func+0xe7a>
800034bc:	e0 8f 02 4b 	bral	80003952 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800034c0:	6e 28       	ld.w	r8,r7[0x8]
800034c2:	e0 6a 5a 5a 	mov	r10,23130
800034c6:	ea 1a ab cd 	orh	r10,0xabcd
800034ca:	14 38       	cp.w	r8,r10
800034cc:	c0 71       	brne	800034da <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800034ce:	30 09       	mov	r9,0
800034d0:	fe f8 0c 38 	ld.w	r8,pc[3128]
800034d4:	91 09       	st.w	r8[0x0],r9
800034d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800034da:	10 99       	mov	r9,r8
800034dc:	e0 19 00 00 	andl	r9,0x0
800034e0:	fc 1a ab cd 	movh	r10,0xabcd
800034e4:	14 39       	cp.w	r9,r10
800034e6:	e0 81 05 ee 	brne	800040c2 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800034ea:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800034ee:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800034f2:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800034f4:	6e 29       	ld.w	r9,r7[0x8]
800034f6:	e2 19 f0 00 	andl	r9,0xf000,COH
800034fa:	e0 49 c0 00 	cp.w	r9,49152
800034fe:	e0 81 00 ce 	brne	8000369a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003502:	30 1a       	mov	r10,1
80003504:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003508:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
8000350a:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000350e:	72 09       	ld.w	r9,r9[0x0]
80003510:	58 09       	cp.w	r9,0
80003512:	c0 71       	brne	80003520 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003514:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003518:	f0 1f 03 00 	mcall	80004118 <phy_rx_func+0xed0>
8000351c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003520:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003524:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003528:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000352a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000352e:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003532:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003536:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003538:	13 89       	ld.ub	r9,r9[0x0]
8000353a:	37 fa       	mov	r10,127
8000353c:	f4 09 18 00 	cp.b	r9,r10
80003540:	c6 d0       	breq	8000361a <phy_rx_func+0x3d2>
80003542:	e0 8b 00 0c 	brhi	8000355a <phy_rx_func+0x312>
80003546:	31 2a       	mov	r10,18
80003548:	f4 09 18 00 	cp.b	r9,r10
8000354c:	c4 20       	breq	800035d0 <phy_rx_func+0x388>
8000354e:	31 3a       	mov	r10,19
80003550:	f4 09 18 00 	cp.b	r9,r10
80003554:	e0 81 00 83 	brne	8000365a <phy_rx_func+0x412>
80003558:	c5 b8       	rjmp	8000360e <phy_rx_func+0x3c6>
8000355a:	2f 09       	sub	r9,-16
8000355c:	30 1a       	mov	r10,1
8000355e:	f4 09 18 00 	cp.b	r9,r10
80003562:	e0 8b 00 7c 	brhi	8000365a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003566:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000356a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000356e:	59 08       	cp.w	r8,16
80003570:	c0 71       	brne	8000357e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003572:	30 19       	mov	r9,1
80003574:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003578:	91 09       	st.w	r8[0x0],r9
8000357a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000357e:	e0 48 00 20 	cp.w	r8,32
80003582:	c2 11       	brne	800035c4 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003584:	30 a9       	mov	r9,10
80003586:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000358a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000358c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003590:	6c 08       	ld.w	r8,r6[0x0]
80003592:	f0 0a 11 ff 	rsub	r10,r8,-1
80003596:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000359a:	2f f8       	sub	r8,-1
8000359c:	6e 0c       	ld.w	r12,r7[0x0]
8000359e:	f4 ca fe 00 	sub	r10,r10,-512
800035a2:	30 0b       	mov	r11,0
800035a4:	10 0c       	add	r12,r8
800035a6:	f0 1f 02 e1 	mcall	80004128 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
800035aa:	30 08       	mov	r8,0
800035ac:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800035ae:	6e 0c       	ld.w	r12,r7[0x0]
800035b0:	f0 1f 02 df 	mcall	8000412c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035b4:	fe f8 0b 44 	ld.w	r8,pc[2884]
800035b8:	70 0c       	ld.w	r12,r8[0x0]
800035ba:	f0 1f 02 ca 	mcall	800040e0 <phy_rx_func+0xe98>
800035be:	8f 0c       	st.w	r7[0x0],r12
800035c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800035c4:	30 09       	mov	r9,0
800035c6:	fe f8 0b 42 	ld.w	r8,pc[2882]
800035ca:	91 09       	st.w	r8[0x0],r9
800035cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800035d0:	20 48       	sub	r8,4
800035d2:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800035d6:	93 08       	st.w	r9[0x0],r8
800035d8:	58 08       	cp.w	r8,0
800035da:	e0 80 05 74 	breq	800040c2 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800035de:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800035e2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800035e6:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800035ea:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800035ec:	8e 69       	ld.sh	r9,r7[0xc]
800035ee:	fe f8 0b 46 	ld.w	r8,pc[2886]
800035f2:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800035f4:	8e 79       	ld.sh	r9,r7[0xe]
800035f6:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800035f8:	f0 1f 02 d0 	mcall	80004138 <phy_rx_func+0xef0>
800035fc:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003600:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003602:	30 49       	mov	r9,4
80003604:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003608:	91 09       	st.w	r8[0x0],r9
8000360a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000360e:	30 09       	mov	r9,0
80003610:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003614:	91 09       	st.w	r8[0x0],r9
80003616:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000361a:	20 48       	sub	r8,4
8000361c:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003620:	93 08       	st.w	r9[0x0],r8
80003622:	58 08       	cp.w	r8,0
80003624:	e0 80 05 4f 	breq	800040c2 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003628:	fe f8 0b 14 	ld.w	r8,pc[2836]
8000362c:	70 09       	ld.w	r9,r8[0x0]
8000362e:	8e 7b       	ld.sh	r11,r7[0xe]
80003630:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003634:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003638:	2f f9       	sub	r9,-1
8000363a:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000363c:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003640:	70 09       	ld.w	r9,r8[0x0]
80003642:	20 29       	sub	r9,2
80003644:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003646:	30 29       	mov	r9,2
80003648:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000364c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000364e:	30 39       	mov	r9,3
80003650:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003654:	91 09       	st.w	r8[0x0],r9
80003656:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000365a:	30 3a       	mov	r10,3
8000365c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003660:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003662:	6e 2a       	ld.w	r10,r7[0x8]
80003664:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003668:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000366a:	6e 3a       	ld.w	r10,r7[0xc]
8000366c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000366e:	59 48       	cp.w	r8,20
80003670:	c0 61       	brne	8000367c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003672:	31 89       	mov	r9,24
80003674:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003678:	91 09       	st.w	r8[0x0],r9
8000367a:	c0 a8       	rjmp	8000368e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000367c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003680:	70 08       	ld.w	r8,r8[0x0]
80003682:	59 08       	cp.w	r8,16
80003684:	c0 51       	brne	8000368e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003686:	31 09       	mov	r9,16
80003688:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000368c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000368e:	30 49       	mov	r9,4
80003690:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003694:	91 09       	st.w	r8[0x0],r9
80003696:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000369a:	e0 49 10 00 	cp.w	r9,4096
8000369e:	5f 1a       	srne	r10
800036a0:	e0 49 20 00 	cp.w	r9,8192
800036a4:	5f 19       	srne	r9
800036a6:	f5 e9 00 09 	and	r9,r10,r9
800036aa:	e0 81 05 0c 	brne	800040c2 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800036ae:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800036b2:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800036b4:	fe fa 0a 98 	ld.w	r10,pc[2712]
800036b8:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800036ba:	fe fa 0a 62 	ld.w	r10,pc[2658]
800036be:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800036c0:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800036c4:	72 09       	ld.w	r9,r9[0x0]
800036c6:	58 09       	cp.w	r9,0
800036c8:	c0 71       	brne	800036d6 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800036ca:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800036ce:	f0 1f 02 93 	mcall	80004118 <phy_rx_func+0xed0>
800036d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800036d6:	6e 2a       	ld.w	r10,r7[0x8]
800036d8:	e2 1a 0f 00 	andl	r10,0xf00,COH
800036dc:	58 1a       	cp.w	r10,1
800036de:	e0 8b 00 4d 	brhi	80003778 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800036e2:	20 48       	sub	r8,4
800036e4:	fe f9 0a 28 	ld.w	r9,pc[2600]
800036e8:	93 08       	st.w	r9[0x0],r8
800036ea:	58 08       	cp.w	r8,0
800036ec:	e0 80 04 eb 	breq	800040c2 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800036f0:	8e 68       	ld.sh	r8,r7[0xc]
800036f2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800036f6:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800036fa:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800036fc:	30 09       	mov	r9,0
800036fe:	f2 08 19 00 	cp.h	r8,r9
80003702:	c0 70       	breq	80003710 <phy_rx_func+0x4c8>
80003704:	30 19       	mov	r9,1
80003706:	f2 08 19 00 	cp.h	r8,r9
8000370a:	e0 81 04 dc 	brne	800040c2 <phy_rx_func+0xe7a>
8000370e:	c2 68       	rjmp	8000375a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003710:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003714:	70 0a       	ld.w	r10,r8[0x0]
80003716:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000371a:	72 09       	ld.w	r9,r9[0x0]
8000371c:	8e 7b       	ld.sh	r11,r7[0xe]
8000371e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003722:	70 09       	ld.w	r9,r8[0x0]
80003724:	2f f9       	sub	r9,-1
80003726:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003728:	e0 49 00 ff 	cp.w	r9,255
8000372c:	e0 88 00 11 	brls	8000374e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003730:	30 09       	mov	r9,0
80003732:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003734:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003738:	6e 0c       	ld.w	r12,r7[0x0]
8000373a:	f0 1f 02 7d 	mcall	8000412c <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000373e:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003742:	70 0c       	ld.w	r12,r8[0x0]
80003744:	f0 1f 02 67 	mcall	800040e0 <phy_rx_func+0xe98>
80003748:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000374a:	e0 80 04 bc 	breq	800040c2 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000374e:	30 29       	mov	r9,2
80003750:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003754:	91 09       	st.w	r8[0x0],r9
80003756:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000375a:	8e 79       	ld.sh	r9,r7[0xe]
8000375c:	30 38       	mov	r8,3
8000375e:	f0 09 19 00 	cp.h	r9,r8
80003762:	c0 51       	brne	8000376c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003764:	30 19       	mov	r9,1
80003766:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000376a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000376c:	30 29       	mov	r9,2
8000376e:	fe f8 09 96 	ld.w	r8,pc[2454]
80003772:	91 09       	st.w	r8[0x0],r9
80003774:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003778:	58 18       	cp.w	r8,1
8000377a:	e0 88 04 a4 	brls	800040c2 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000377e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003782:	70 0a       	ld.w	r10,r8[0x0]
80003784:	6e 3b       	ld.w	r11,r7[0xc]
80003786:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000378a:	70 09       	ld.w	r9,r8[0x0]
8000378c:	2f f9       	sub	r9,-1
8000378e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003790:	e0 49 00 ff 	cp.w	r9,255
80003794:	e0 88 00 11 	brls	800037b6 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003798:	30 09       	mov	r9,0
8000379a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000379c:	fe f7 09 60 	ld.w	r7,pc[2400]
800037a0:	6e 0c       	ld.w	r12,r7[0x0]
800037a2:	f0 1f 02 63 	mcall	8000412c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800037a6:	fe f8 09 52 	ld.w	r8,pc[2386]
800037aa:	70 0c       	ld.w	r12,r8[0x0]
800037ac:	f0 1f 02 4d 	mcall	800040e0 <phy_rx_func+0xe98>
800037b0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800037b2:	e0 80 04 88 	breq	800040c2 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800037b6:	fe f9 09 56 	ld.w	r9,pc[2390]
800037ba:	72 08       	ld.w	r8,r9[0x0]
800037bc:	20 28       	sub	r8,2
800037be:	93 08       	st.w	r9[0x0],r8
800037c0:	e0 80 04 81 	breq	800040c2 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800037c4:	30 29       	mov	r9,2
800037c6:	fe f8 09 3e 	ld.w	r8,pc[2366]
800037ca:	91 09       	st.w	r8[0x0],r9
800037cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800037d0:	fe f8 09 84 	ld.w	r8,pc[2436]
800037d4:	70 0a       	ld.w	r10,r8[0x0]
800037d6:	fe f9 09 26 	ld.w	r9,pc[2342]
800037da:	72 09       	ld.w	r9,r9[0x0]
800037dc:	8e 4b       	ld.sh	r11,r7[0x8]
800037de:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800037e2:	70 09       	ld.w	r9,r8[0x0]
800037e4:	2f f9       	sub	r9,-1
800037e6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800037e8:	e0 49 00 ff 	cp.w	r9,255
800037ec:	e0 88 00 16 	brls	80003818 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800037f0:	30 09       	mov	r9,0
800037f2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800037f4:	fe f6 09 08 	ld.w	r6,pc[2312]
800037f8:	6c 0c       	ld.w	r12,r6[0x0]
800037fa:	f0 1f 02 4d 	mcall	8000412c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800037fe:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003802:	70 0c       	ld.w	r12,r8[0x0]
80003804:	f0 1f 02 37 	mcall	800040e0 <phy_rx_func+0xe98>
80003808:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000380a:	c0 71       	brne	80003818 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
8000380c:	30 09       	mov	r9,0
8000380e:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003812:	91 09       	st.w	r8[0x0],r9
80003814:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003818:	fe f9 08 f4 	ld.w	r9,pc[2292]
8000381c:	72 08       	ld.w	r8,r9[0x0]
8000381e:	20 28       	sub	r8,2
80003820:	93 08       	st.w	r9[0x0],r8
80003822:	c0 71       	brne	80003830 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003824:	30 09       	mov	r9,0
80003826:	fe f8 08 de 	ld.w	r8,pc[2270]
8000382a:	91 09       	st.w	r8[0x0],r9
8000382c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003830:	fe f8 09 24 	ld.w	r8,pc[2340]
80003834:	70 0a       	ld.w	r10,r8[0x0]
80003836:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000383a:	72 09       	ld.w	r9,r9[0x0]
8000383c:	8e 5b       	ld.sh	r11,r7[0xa]
8000383e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003842:	70 09       	ld.w	r9,r8[0x0]
80003844:	2f f9       	sub	r9,-1
80003846:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003848:	e0 49 00 ff 	cp.w	r9,255
8000384c:	e0 88 00 16 	brls	80003878 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003850:	30 09       	mov	r9,0
80003852:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003854:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003858:	6c 0c       	ld.w	r12,r6[0x0]
8000385a:	f0 1f 02 35 	mcall	8000412c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000385e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003862:	70 0c       	ld.w	r12,r8[0x0]
80003864:	f0 1f 02 1f 	mcall	800040e0 <phy_rx_func+0xe98>
80003868:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000386a:	c0 71       	brne	80003878 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
8000386c:	30 09       	mov	r9,0
8000386e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003872:	91 09       	st.w	r8[0x0],r9
80003874:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003878:	fe f9 08 94 	ld.w	r9,pc[2196]
8000387c:	72 08       	ld.w	r8,r9[0x0]
8000387e:	20 28       	sub	r8,2
80003880:	93 08       	st.w	r9[0x0],r8
80003882:	c0 71       	brne	80003890 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003884:	30 09       	mov	r9,0
80003886:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000388a:	91 09       	st.w	r8[0x0],r9
8000388c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003890:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003894:	70 0a       	ld.w	r10,r8[0x0]
80003896:	fe f9 08 66 	ld.w	r9,pc[2150]
8000389a:	72 09       	ld.w	r9,r9[0x0]
8000389c:	8e 6b       	ld.sh	r11,r7[0xc]
8000389e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800038a2:	70 09       	ld.w	r9,r8[0x0]
800038a4:	2f f9       	sub	r9,-1
800038a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800038a8:	e0 49 00 ff 	cp.w	r9,255
800038ac:	e0 88 00 16 	brls	800038d8 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800038b0:	30 09       	mov	r9,0
800038b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800038b4:	fe f6 08 48 	ld.w	r6,pc[2120]
800038b8:	6c 0c       	ld.w	r12,r6[0x0]
800038ba:	f0 1f 02 1d 	mcall	8000412c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800038be:	fe f8 08 3a 	ld.w	r8,pc[2106]
800038c2:	70 0c       	ld.w	r12,r8[0x0]
800038c4:	f0 1f 02 07 	mcall	800040e0 <phy_rx_func+0xe98>
800038c8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800038ca:	c0 71       	brne	800038d8 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800038cc:	30 09       	mov	r9,0
800038ce:	fe f8 08 36 	ld.w	r8,pc[2102]
800038d2:	91 09       	st.w	r8[0x0],r9
800038d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800038d8:	fe f9 08 34 	ld.w	r9,pc[2100]
800038dc:	72 08       	ld.w	r8,r9[0x0]
800038de:	20 28       	sub	r8,2
800038e0:	93 08       	st.w	r9[0x0],r8
800038e2:	c0 71       	brne	800038f0 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800038e4:	30 09       	mov	r9,0
800038e6:	fe f8 08 1e 	ld.w	r8,pc[2078]
800038ea:	91 09       	st.w	r8[0x0],r9
800038ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800038f0:	fe f8 08 64 	ld.w	r8,pc[2148]
800038f4:	70 0a       	ld.w	r10,r8[0x0]
800038f6:	fe f9 08 06 	ld.w	r9,pc[2054]
800038fa:	72 09       	ld.w	r9,r9[0x0]
800038fc:	8e 7b       	ld.sh	r11,r7[0xe]
800038fe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003902:	70 09       	ld.w	r9,r8[0x0]
80003904:	2f f9       	sub	r9,-1
80003906:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003908:	e0 49 00 ff 	cp.w	r9,255
8000390c:	e0 88 00 16 	brls	80003938 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003910:	30 09       	mov	r9,0
80003912:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003914:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003918:	6e 0c       	ld.w	r12,r7[0x0]
8000391a:	f0 1f 02 05 	mcall	8000412c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000391e:	fe f8 07 da 	ld.w	r8,pc[2010]
80003922:	70 0c       	ld.w	r12,r8[0x0]
80003924:	f0 1f 01 ef 	mcall	800040e0 <phy_rx_func+0xe98>
80003928:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000392a:	c0 71       	brne	80003938 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
8000392c:	30 09       	mov	r9,0
8000392e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003932:	91 09       	st.w	r8[0x0],r9
80003934:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003938:	fe f9 07 d4 	ld.w	r9,pc[2004]
8000393c:	72 08       	ld.w	r8,r9[0x0]
8000393e:	20 28       	sub	r8,2
80003940:	93 08       	st.w	r9[0x0],r8
80003942:	e0 81 03 c0 	brne	800040c2 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003946:	30 09       	mov	r9,0
80003948:	fe f8 07 bc 	ld.w	r8,pc[1980]
8000394c:	91 09       	st.w	r8[0x0],r9
8000394e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003952:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003956:	11 89       	ld.ub	r9,r8[0x0]
80003958:	31 28       	mov	r8,18
8000395a:	f0 09 18 00 	cp.b	r9,r8
8000395e:	e0 81 01 4c 	brne	80003bf6 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003962:	ef 39 00 09 	ld.ub	r9,r7[9]
80003966:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000396a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000396c:	11 89       	ld.ub	r9,r8[0x0]
8000396e:	3f 28       	mov	r8,-14
80003970:	f0 09 18 00 	cp.b	r9,r8
80003974:	e0 81 01 3b 	brne	80003bea <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003978:	30 19       	mov	r9,1
8000397a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000397e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003980:	6e 29       	ld.w	r9,r7[0x8]
80003982:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003986:	fe f8 07 86 	ld.w	r8,pc[1926]
8000398a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000398c:	8e 59       	ld.sh	r9,r7[0xa]
8000398e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003992:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003994:	8e 69       	ld.sh	r9,r7[0xc]
80003996:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003998:	8e 79       	ld.sh	r9,r7[0xe]
8000399a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000399c:	fe f8 07 88 	ld.w	r8,pc[1928]
800039a0:	fe f9 07 60 	ld.w	r9,pc[1888]
800039a4:	72 0a       	ld.w	r10,r9[0x0]
800039a6:	70 09       	ld.w	r9,r8[0x0]
800039a8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800039ac:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039b0:	70 09       	ld.w	r9,r8[0x0]
800039b2:	2f f9       	sub	r9,-1
800039b4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039b6:	e0 49 01 ff 	cp.w	r9,511
800039ba:	e0 88 00 16 	brls	800039e6 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800039be:	30 09       	mov	r9,0
800039c0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800039c2:	fe f6 07 3e 	ld.w	r6,pc[1854]
800039c6:	6c 0c       	ld.w	r12,r6[0x0]
800039c8:	f0 1f 01 d9 	mcall	8000412c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800039cc:	fe f8 07 2c 	ld.w	r8,pc[1836]
800039d0:	70 0c       	ld.w	r12,r8[0x0]
800039d2:	f0 1f 01 c4 	mcall	800040e0 <phy_rx_func+0xe98>
800039d6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800039d8:	c0 71       	brne	800039e6 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800039da:	30 09       	mov	r9,0
800039dc:	fe f8 07 28 	ld.w	r8,pc[1832]
800039e0:	91 09       	st.w	r8[0x0],r9
800039e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800039e6:	fe f9 07 26 	ld.w	r9,pc[1830]
800039ea:	72 08       	ld.w	r8,r9[0x0]
800039ec:	20 18       	sub	r8,1
800039ee:	93 08       	st.w	r9[0x0],r8
800039f0:	c0 71       	brne	800039fe <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800039f2:	30 09       	mov	r9,0
800039f4:	fe f8 07 10 	ld.w	r8,pc[1808]
800039f8:	91 09       	st.w	r8[0x0],r9
800039fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800039fe:	fe f8 07 26 	ld.w	r8,pc[1830]
80003a02:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003a06:	72 0a       	ld.w	r10,r9[0x0]
80003a08:	70 09       	ld.w	r9,r8[0x0]
80003a0a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003a0e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a12:	70 09       	ld.w	r9,r8[0x0]
80003a14:	2f f9       	sub	r9,-1
80003a16:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a18:	e0 49 01 ff 	cp.w	r9,511
80003a1c:	e0 88 00 16 	brls	80003a48 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a20:	30 09       	mov	r9,0
80003a22:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a24:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003a28:	6c 0c       	ld.w	r12,r6[0x0]
80003a2a:	f0 1f 01 c1 	mcall	8000412c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a2e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003a32:	70 0c       	ld.w	r12,r8[0x0]
80003a34:	f0 1f 01 ab 	mcall	800040e0 <phy_rx_func+0xe98>
80003a38:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a3a:	c0 71       	brne	80003a48 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003a3c:	30 09       	mov	r9,0
80003a3e:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003a42:	91 09       	st.w	r8[0x0],r9
80003a44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a48:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003a4c:	72 08       	ld.w	r8,r9[0x0]
80003a4e:	20 18       	sub	r8,1
80003a50:	93 08       	st.w	r9[0x0],r8
80003a52:	c0 71       	brne	80003a60 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003a54:	30 09       	mov	r9,0
80003a56:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003a5a:	91 09       	st.w	r8[0x0],r9
80003a5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003a60:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003a64:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003a68:	72 0a       	ld.w	r10,r9[0x0]
80003a6a:	70 09       	ld.w	r9,r8[0x0]
80003a6c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a70:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a74:	70 09       	ld.w	r9,r8[0x0]
80003a76:	2f f9       	sub	r9,-1
80003a78:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a7a:	e0 49 01 ff 	cp.w	r9,511
80003a7e:	e0 88 00 16 	brls	80003aaa <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a82:	30 09       	mov	r9,0
80003a84:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a86:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003a8a:	6c 0c       	ld.w	r12,r6[0x0]
80003a8c:	f0 1f 01 a8 	mcall	8000412c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a90:	fe f8 06 68 	ld.w	r8,pc[1640]
80003a94:	70 0c       	ld.w	r12,r8[0x0]
80003a96:	f0 1f 01 93 	mcall	800040e0 <phy_rx_func+0xe98>
80003a9a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a9c:	c0 71       	brne	80003aaa <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003a9e:	30 09       	mov	r9,0
80003aa0:	fe f8 06 64 	ld.w	r8,pc[1636]
80003aa4:	91 09       	st.w	r8[0x0],r9
80003aa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003aaa:	fe f9 06 62 	ld.w	r9,pc[1634]
80003aae:	72 08       	ld.w	r8,r9[0x0]
80003ab0:	20 18       	sub	r8,1
80003ab2:	93 08       	st.w	r9[0x0],r8
80003ab4:	c0 71       	brne	80003ac2 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003ab6:	30 09       	mov	r9,0
80003ab8:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003abc:	91 09       	st.w	r8[0x0],r9
80003abe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003ac2:	fe f8 06 62 	ld.w	r8,pc[1634]
80003ac6:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003aca:	72 0a       	ld.w	r10,r9[0x0]
80003acc:	70 09       	ld.w	r9,r8[0x0]
80003ace:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003ad2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ad6:	70 09       	ld.w	r9,r8[0x0]
80003ad8:	2f f9       	sub	r9,-1
80003ada:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003adc:	e0 49 01 ff 	cp.w	r9,511
80003ae0:	e0 88 00 16 	brls	80003b0c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ae4:	30 09       	mov	r9,0
80003ae6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ae8:	fe f6 06 18 	ld.w	r6,pc[1560]
80003aec:	6c 0c       	ld.w	r12,r6[0x0]
80003aee:	f0 1f 01 90 	mcall	8000412c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003af2:	fe f8 06 06 	ld.w	r8,pc[1542]
80003af6:	70 0c       	ld.w	r12,r8[0x0]
80003af8:	f0 1f 01 7a 	mcall	800040e0 <phy_rx_func+0xe98>
80003afc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003afe:	c0 71       	brne	80003b0c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003b00:	30 09       	mov	r9,0
80003b02:	fe f8 06 02 	ld.w	r8,pc[1538]
80003b06:	91 09       	st.w	r8[0x0],r9
80003b08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b0c:	fe f9 06 00 	ld.w	r9,pc[1536]
80003b10:	72 08       	ld.w	r8,r9[0x0]
80003b12:	20 18       	sub	r8,1
80003b14:	93 08       	st.w	r9[0x0],r8
80003b16:	c0 71       	brne	80003b24 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003b18:	30 09       	mov	r9,0
80003b1a:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003b1e:	91 09       	st.w	r8[0x0],r9
80003b20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003b24:	fe f8 06 00 	ld.w	r8,pc[1536]
80003b28:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003b2c:	72 0a       	ld.w	r10,r9[0x0]
80003b2e:	70 09       	ld.w	r9,r8[0x0]
80003b30:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b34:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b38:	70 09       	ld.w	r9,r8[0x0]
80003b3a:	2f f9       	sub	r9,-1
80003b3c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b3e:	e0 49 01 ff 	cp.w	r9,511
80003b42:	e0 88 00 16 	brls	80003b6e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b46:	30 09       	mov	r9,0
80003b48:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b4a:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003b4e:	6c 0c       	ld.w	r12,r6[0x0]
80003b50:	f0 1f 01 77 	mcall	8000412c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b54:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003b58:	70 0c       	ld.w	r12,r8[0x0]
80003b5a:	f0 1f 01 62 	mcall	800040e0 <phy_rx_func+0xe98>
80003b5e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b60:	c0 71       	brne	80003b6e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003b62:	30 09       	mov	r9,0
80003b64:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003b68:	91 09       	st.w	r8[0x0],r9
80003b6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b6e:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003b72:	72 08       	ld.w	r8,r9[0x0]
80003b74:	20 18       	sub	r8,1
80003b76:	93 08       	st.w	r9[0x0],r8
80003b78:	c0 71       	brne	80003b86 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003b7a:	30 09       	mov	r9,0
80003b7c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003b80:	91 09       	st.w	r8[0x0],r9
80003b82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003b86:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003b8a:	fe f9 05 76 	ld.w	r9,pc[1398]
80003b8e:	72 0a       	ld.w	r10,r9[0x0]
80003b90:	70 09       	ld.w	r9,r8[0x0]
80003b92:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b96:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b9a:	70 09       	ld.w	r9,r8[0x0]
80003b9c:	2f f9       	sub	r9,-1
80003b9e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ba0:	e0 49 01 ff 	cp.w	r9,511
80003ba4:	e0 88 00 16 	brls	80003bd0 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ba8:	30 09       	mov	r9,0
80003baa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bac:	fe f7 05 54 	ld.w	r7,pc[1364]
80003bb0:	6e 0c       	ld.w	r12,r7[0x0]
80003bb2:	f0 1f 01 5f 	mcall	8000412c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bb6:	fe f8 05 42 	ld.w	r8,pc[1346]
80003bba:	70 0c       	ld.w	r12,r8[0x0]
80003bbc:	f0 1f 01 49 	mcall	800040e0 <phy_rx_func+0xe98>
80003bc0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003bc2:	c0 71       	brne	80003bd0 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003bc4:	30 09       	mov	r9,0
80003bc6:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003bca:	91 09       	st.w	r8[0x0],r9
80003bcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bd0:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003bd4:	72 08       	ld.w	r8,r9[0x0]
80003bd6:	20 18       	sub	r8,1
80003bd8:	93 08       	st.w	r9[0x0],r8
80003bda:	e0 81 02 74 	brne	800040c2 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003bde:	30 09       	mov	r9,0
80003be0:	fe f8 05 24 	ld.w	r8,pc[1316]
80003be4:	91 09       	st.w	r8[0x0],r9
80003be6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003bea:	30 09       	mov	r9,0
80003bec:	fe f8 05 18 	ld.w	r8,pc[1304]
80003bf0:	91 09       	st.w	r8[0x0],r9
80003bf2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003bf6:	fe f8 05 26 	ld.w	r8,pc[1318]
80003bfa:	11 89       	ld.ub	r9,r8[0x0]
80003bfc:	3f 28       	mov	r8,-14
80003bfe:	f0 09 18 00 	cp.b	r9,r8
80003c02:	c4 31       	brne	80003c88 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003c04:	8e 49       	ld.sh	r9,r7[0x8]
80003c06:	fe f8 05 56 	ld.w	r8,pc[1366]
80003c0a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003c0c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003c10:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003c14:	72 0a       	ld.w	r10,r9[0x0]
80003c16:	70 09       	ld.w	r9,r8[0x0]
80003c18:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003c1c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c20:	70 09       	ld.w	r9,r8[0x0]
80003c22:	2f f9       	sub	r9,-1
80003c24:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c26:	e0 49 01 ff 	cp.w	r9,511
80003c2a:	e0 88 00 16 	brls	80003c56 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c2e:	30 09       	mov	r9,0
80003c30:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c32:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003c36:	6e 0c       	ld.w	r12,r7[0x0]
80003c38:	f0 1f 01 3d 	mcall	8000412c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c3c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003c40:	70 0c       	ld.w	r12,r8[0x0]
80003c42:	f0 1f 01 28 	mcall	800040e0 <phy_rx_func+0xe98>
80003c46:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c48:	c0 71       	brne	80003c56 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003c4a:	30 09       	mov	r9,0
80003c4c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003c50:	91 09       	st.w	r8[0x0],r9
80003c52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c56:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003c5a:	72 08       	ld.w	r8,r9[0x0]
80003c5c:	20 18       	sub	r8,1
80003c5e:	93 08       	st.w	r9[0x0],r8
80003c60:	c0 71       	brne	80003c6e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003c62:	30 09       	mov	r9,0
80003c64:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003c68:	91 09       	st.w	r8[0x0],r9
80003c6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003c6e:	20 18       	sub	r8,1
80003c70:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003c74:	93 08       	st.w	r9[0x0],r8
80003c76:	58 08       	cp.w	r8,0
80003c78:	e0 81 02 25 	brne	800040c2 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003c7c:	30 09       	mov	r9,0
80003c7e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003c82:	91 09       	st.w	r8[0x0],r9
80003c84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003c88:	fe f8 04 94 	ld.w	r8,pc[1172]
80003c8c:	11 89       	ld.ub	r9,r8[0x0]
80003c8e:	3f 38       	mov	r8,-13
80003c90:	f0 09 18 00 	cp.b	r9,r8
80003c94:	e0 81 01 0c 	brne	80003eac <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003c98:	8e 49       	ld.sh	r9,r7[0x8]
80003c9a:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003c9e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003ca0:	8e 59       	ld.sh	r9,r7[0xa]
80003ca2:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003ca4:	8e 69       	ld.sh	r9,r7[0xc]
80003ca6:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003ca8:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003cac:	fe f9 04 54 	ld.w	r9,pc[1108]
80003cb0:	72 0a       	ld.w	r10,r9[0x0]
80003cb2:	70 09       	ld.w	r9,r8[0x0]
80003cb4:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003cb8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003cbc:	70 09       	ld.w	r9,r8[0x0]
80003cbe:	2f f9       	sub	r9,-1
80003cc0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cc2:	e0 49 01 ff 	cp.w	r9,511
80003cc6:	e0 88 00 16 	brls	80003cf2 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003cca:	30 09       	mov	r9,0
80003ccc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003cce:	fe f6 04 32 	ld.w	r6,pc[1074]
80003cd2:	6c 0c       	ld.w	r12,r6[0x0]
80003cd4:	f0 1f 01 16 	mcall	8000412c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003cd8:	fe f8 04 20 	ld.w	r8,pc[1056]
80003cdc:	70 0c       	ld.w	r12,r8[0x0]
80003cde:	f0 1f 01 01 	mcall	800040e0 <phy_rx_func+0xe98>
80003ce2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ce4:	c0 71       	brne	80003cf2 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003ce6:	30 09       	mov	r9,0
80003ce8:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003cec:	91 09       	st.w	r8[0x0],r9
80003cee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003cf2:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003cf6:	72 08       	ld.w	r8,r9[0x0]
80003cf8:	20 18       	sub	r8,1
80003cfa:	93 08       	st.w	r9[0x0],r8
80003cfc:	c0 71       	brne	80003d0a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003cfe:	30 09       	mov	r9,0
80003d00:	fe f8 04 04 	ld.w	r8,pc[1028]
80003d04:	91 09       	st.w	r8[0x0],r9
80003d06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003d0a:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003d0e:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003d12:	72 0a       	ld.w	r10,r9[0x0]
80003d14:	70 09       	ld.w	r9,r8[0x0]
80003d16:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003d1a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d1e:	70 09       	ld.w	r9,r8[0x0]
80003d20:	2f f9       	sub	r9,-1
80003d22:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d24:	e0 49 01 ff 	cp.w	r9,511
80003d28:	e0 88 00 16 	brls	80003d54 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d2c:	30 09       	mov	r9,0
80003d2e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d30:	fe f6 03 d0 	ld.w	r6,pc[976]
80003d34:	6c 0c       	ld.w	r12,r6[0x0]
80003d36:	f0 1f 00 fe 	mcall	8000412c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d3a:	fe f8 03 be 	ld.w	r8,pc[958]
80003d3e:	70 0c       	ld.w	r12,r8[0x0]
80003d40:	f0 1f 00 e8 	mcall	800040e0 <phy_rx_func+0xe98>
80003d44:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d46:	c0 71       	brne	80003d54 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003d48:	30 09       	mov	r9,0
80003d4a:	fe f8 03 ba 	ld.w	r8,pc[954]
80003d4e:	91 09       	st.w	r8[0x0],r9
80003d50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d54:	fe f9 03 b8 	ld.w	r9,pc[952]
80003d58:	72 08       	ld.w	r8,r9[0x0]
80003d5a:	20 18       	sub	r8,1
80003d5c:	93 08       	st.w	r9[0x0],r8
80003d5e:	c0 71       	brne	80003d6c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003d60:	30 09       	mov	r9,0
80003d62:	fe f8 03 a2 	ld.w	r8,pc[930]
80003d66:	91 09       	st.w	r8[0x0],r9
80003d68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003d6c:	fe f8 03 b8 	ld.w	r8,pc[952]
80003d70:	fe f9 03 90 	ld.w	r9,pc[912]
80003d74:	72 0a       	ld.w	r10,r9[0x0]
80003d76:	70 09       	ld.w	r9,r8[0x0]
80003d78:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003d7c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d80:	70 09       	ld.w	r9,r8[0x0]
80003d82:	2f f9       	sub	r9,-1
80003d84:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d86:	e0 49 01 ff 	cp.w	r9,511
80003d8a:	e0 88 00 16 	brls	80003db6 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d8e:	30 09       	mov	r9,0
80003d90:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d92:	fe f6 03 6e 	ld.w	r6,pc[878]
80003d96:	6c 0c       	ld.w	r12,r6[0x0]
80003d98:	f0 1f 00 e5 	mcall	8000412c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d9c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003da0:	70 0c       	ld.w	r12,r8[0x0]
80003da2:	f0 1f 00 d0 	mcall	800040e0 <phy_rx_func+0xe98>
80003da6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003da8:	c0 71       	brne	80003db6 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003daa:	30 09       	mov	r9,0
80003dac:	fe f8 03 58 	ld.w	r8,pc[856]
80003db0:	91 09       	st.w	r8[0x0],r9
80003db2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003db6:	fe f9 03 56 	ld.w	r9,pc[854]
80003dba:	72 08       	ld.w	r8,r9[0x0]
80003dbc:	20 18       	sub	r8,1
80003dbe:	93 08       	st.w	r9[0x0],r8
80003dc0:	c0 71       	brne	80003dce <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003dc2:	30 09       	mov	r9,0
80003dc4:	fe f8 03 40 	ld.w	r8,pc[832]
80003dc8:	91 09       	st.w	r8[0x0],r9
80003dca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003dce:	fe f8 03 56 	ld.w	r8,pc[854]
80003dd2:	fe f9 03 2e 	ld.w	r9,pc[814]
80003dd6:	72 0a       	ld.w	r10,r9[0x0]
80003dd8:	70 09       	ld.w	r9,r8[0x0]
80003dda:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003dde:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003de2:	70 09       	ld.w	r9,r8[0x0]
80003de4:	2f f9       	sub	r9,-1
80003de6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003de8:	e0 49 01 ff 	cp.w	r9,511
80003dec:	e0 88 00 16 	brls	80003e18 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003df0:	30 09       	mov	r9,0
80003df2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003df4:	fe f6 03 0c 	ld.w	r6,pc[780]
80003df8:	6c 0c       	ld.w	r12,r6[0x0]
80003dfa:	f0 1f 00 cd 	mcall	8000412c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003dfe:	fe f8 02 fa 	ld.w	r8,pc[762]
80003e02:	70 0c       	ld.w	r12,r8[0x0]
80003e04:	f0 1f 00 b7 	mcall	800040e0 <phy_rx_func+0xe98>
80003e08:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e0a:	c0 71       	brne	80003e18 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003e0c:	30 09       	mov	r9,0
80003e0e:	fe f8 02 f6 	ld.w	r8,pc[758]
80003e12:	91 09       	st.w	r8[0x0],r9
80003e14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e18:	fe f9 02 f4 	ld.w	r9,pc[756]
80003e1c:	72 08       	ld.w	r8,r9[0x0]
80003e1e:	20 18       	sub	r8,1
80003e20:	93 08       	st.w	r9[0x0],r8
80003e22:	c0 71       	brne	80003e30 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003e24:	30 09       	mov	r9,0
80003e26:	fe f8 02 de 	ld.w	r8,pc[734]
80003e2a:	91 09       	st.w	r8[0x0],r9
80003e2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003e30:	fe f8 02 f4 	ld.w	r8,pc[756]
80003e34:	fe f9 02 cc 	ld.w	r9,pc[716]
80003e38:	72 0a       	ld.w	r10,r9[0x0]
80003e3a:	70 09       	ld.w	r9,r8[0x0]
80003e3c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003e40:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e44:	70 09       	ld.w	r9,r8[0x0]
80003e46:	2f f9       	sub	r9,-1
80003e48:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e4a:	e0 49 01 ff 	cp.w	r9,511
80003e4e:	e0 88 00 16 	brls	80003e7a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e52:	30 09       	mov	r9,0
80003e54:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e56:	fe f7 02 aa 	ld.w	r7,pc[682]
80003e5a:	6e 0c       	ld.w	r12,r7[0x0]
80003e5c:	f0 1f 00 b4 	mcall	8000412c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e60:	fe f8 02 98 	ld.w	r8,pc[664]
80003e64:	70 0c       	ld.w	r12,r8[0x0]
80003e66:	f0 1f 00 9f 	mcall	800040e0 <phy_rx_func+0xe98>
80003e6a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e6c:	c0 71       	brne	80003e7a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003e6e:	30 09       	mov	r9,0
80003e70:	fe f8 02 94 	ld.w	r8,pc[660]
80003e74:	91 09       	st.w	r8[0x0],r9
80003e76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e7a:	fe f9 02 92 	ld.w	r9,pc[658]
80003e7e:	72 08       	ld.w	r8,r9[0x0]
80003e80:	20 18       	sub	r8,1
80003e82:	93 08       	st.w	r9[0x0],r8
80003e84:	c0 71       	brne	80003e92 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003e86:	30 09       	mov	r9,0
80003e88:	fe f8 02 7c 	ld.w	r8,pc[636]
80003e8c:	91 09       	st.w	r8[0x0],r9
80003e8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003e92:	20 18       	sub	r8,1
80003e94:	fe f9 02 78 	ld.w	r9,pc[632]
80003e98:	93 08       	st.w	r9[0x0],r8
80003e9a:	58 08       	cp.w	r8,0
80003e9c:	e0 81 01 13 	brne	800040c2 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003ea0:	30 09       	mov	r9,0
80003ea2:	fe f8 02 62 	ld.w	r8,pc[610]
80003ea6:	91 09       	st.w	r8[0x0],r9
80003ea8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003eac:	fe f8 02 70 	ld.w	r8,pc[624]
80003eb0:	11 89       	ld.ub	r9,r8[0x0]
80003eb2:	30 48       	mov	r8,4
80003eb4:	f0 09 18 00 	cp.b	r9,r8
80003eb8:	c0 80       	breq	80003ec8 <phy_rx_func+0xc80>
80003eba:	fe f8 02 62 	ld.w	r8,pc[610]
80003ebe:	11 89       	ld.ub	r9,r8[0x0]
80003ec0:	30 38       	mov	r8,3
80003ec2:	f0 09 18 00 	cp.b	r9,r8
80003ec6:	c1 41       	brne	80003eee <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003ec8:	6e 29       	ld.w	r9,r7[0x8]
80003eca:	fe f8 02 7a 	ld.w	r8,pc[634]
80003ece:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003ed0:	6e 39       	ld.w	r9,r7[0xc]
80003ed2:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003ed4:	fe f9 02 38 	ld.w	r9,pc[568]
80003ed8:	72 08       	ld.w	r8,r9[0x0]
80003eda:	20 88       	sub	r8,8
80003edc:	93 08       	st.w	r9[0x0],r8
80003ede:	e0 81 00 f2 	brne	800040c2 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003ee2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003ee4:	fe f9 02 20 	ld.w	r9,pc[544]
80003ee8:	93 08       	st.w	r9[0x0],r8
80003eea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003eee:	fe f8 02 2e 	ld.w	r8,pc[558]
80003ef2:	11 89       	ld.ub	r9,r8[0x0]
80003ef4:	31 38       	mov	r8,19
80003ef6:	f0 09 18 00 	cp.b	r9,r8
80003efa:	e0 81 00 9c 	brne	80004032 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003efe:	fe f8 02 62 	ld.w	r8,pc[610]
80003f02:	11 88       	ld.ub	r8,r8[0x0]
80003f04:	30 c9       	mov	r9,12
80003f06:	f2 08 18 00 	cp.b	r8,r9
80003f0a:	e0 81 00 7b 	brne	80004000 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003f0e:	8e 49       	ld.sh	r9,r7[0x8]
80003f10:	fe f8 02 54 	ld.w	r8,pc[596]
80003f14:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003f18:	30 09       	mov	r9,0
80003f1a:	fe f8 02 46 	ld.w	r8,pc[582]
80003f1e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003f20:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003f24:	3f 38       	mov	r8,-13
80003f26:	f0 09 18 00 	cp.b	r9,r8
80003f2a:	c6 61       	brne	80003ff6 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003f2c:	10 99       	mov	r9,r8
80003f2e:	4f c8       	lddpc	r8,8000411c <phy_rx_func+0xed4>
80003f30:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003f32:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003f36:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003f3a:	4f 58       	lddpc	r8,8000410c <phy_rx_func+0xec4>
80003f3c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003f3e:	30 19       	mov	r9,1
80003f40:	fe f8 02 0c 	ld.w	r8,pc[524]
80003f44:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003f46:	8e 79       	ld.sh	r9,r7[0xe]
80003f48:	fe f8 02 14 	ld.w	r8,pc[532]
80003f4c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003f4e:	4f 68       	lddpc	r8,80004124 <phy_rx_func+0xedc>
80003f50:	4e c9       	lddpc	r9,80004100 <phy_rx_func+0xeb8>
80003f52:	72 0a       	ld.w	r10,r9[0x0]
80003f54:	70 09       	ld.w	r9,r8[0x0]
80003f56:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003f5a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003f5e:	70 09       	ld.w	r9,r8[0x0]
80003f60:	2f f9       	sub	r9,-1
80003f62:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f64:	e0 49 01 ff 	cp.w	r9,511
80003f68:	e0 88 00 13 	brls	80003f8e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003f6c:	30 09       	mov	r9,0
80003f6e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003f70:	4e 46       	lddpc	r6,80004100 <phy_rx_func+0xeb8>
80003f72:	6c 0c       	ld.w	r12,r6[0x0]
80003f74:	f0 1f 00 6e 	mcall	8000412c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003f78:	4e 08       	lddpc	r8,800040f8 <phy_rx_func+0xeb0>
80003f7a:	70 0c       	ld.w	r12,r8[0x0]
80003f7c:	f0 1f 00 59 	mcall	800040e0 <phy_rx_func+0xe98>
80003f80:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003f82:	c0 61       	brne	80003f8e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003f84:	30 09       	mov	r9,0
80003f86:	4e 08       	lddpc	r8,80004104 <phy_rx_func+0xebc>
80003f88:	91 09       	st.w	r8[0x0],r9
80003f8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003f8e:	4e 09       	lddpc	r9,8000410c <phy_rx_func+0xec4>
80003f90:	72 08       	ld.w	r8,r9[0x0]
80003f92:	20 18       	sub	r8,1
80003f94:	93 08       	st.w	r9[0x0],r8
80003f96:	c0 61       	brne	80003fa2 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003f98:	30 09       	mov	r9,0
80003f9a:	4d b8       	lddpc	r8,80004104 <phy_rx_func+0xebc>
80003f9c:	91 09       	st.w	r8[0x0],r9
80003f9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003fa2:	4e 18       	lddpc	r8,80004124 <phy_rx_func+0xedc>
80003fa4:	4d 79       	lddpc	r9,80004100 <phy_rx_func+0xeb8>
80003fa6:	72 0a       	ld.w	r10,r9[0x0]
80003fa8:	70 09       	ld.w	r9,r8[0x0]
80003faa:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003fae:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003fb2:	70 09       	ld.w	r9,r8[0x0]
80003fb4:	2f f9       	sub	r9,-1
80003fb6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fb8:	e0 49 01 ff 	cp.w	r9,511
80003fbc:	e0 88 00 13 	brls	80003fe2 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003fc0:	30 09       	mov	r9,0
80003fc2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003fc4:	4c f7       	lddpc	r7,80004100 <phy_rx_func+0xeb8>
80003fc6:	6e 0c       	ld.w	r12,r7[0x0]
80003fc8:	f0 1f 00 59 	mcall	8000412c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003fcc:	4c b8       	lddpc	r8,800040f8 <phy_rx_func+0xeb0>
80003fce:	70 0c       	ld.w	r12,r8[0x0]
80003fd0:	f0 1f 00 44 	mcall	800040e0 <phy_rx_func+0xe98>
80003fd4:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003fd6:	c0 61       	brne	80003fe2 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003fd8:	30 09       	mov	r9,0
80003fda:	4c b8       	lddpc	r8,80004104 <phy_rx_func+0xebc>
80003fdc:	91 09       	st.w	r8[0x0],r9
80003fde:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003fe2:	4c b9       	lddpc	r9,8000410c <phy_rx_func+0xec4>
80003fe4:	72 08       	ld.w	r8,r9[0x0]
80003fe6:	20 18       	sub	r8,1
80003fe8:	93 08       	st.w	r9[0x0],r8
80003fea:	c6 c1       	brne	800040c2 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003fec:	30 09       	mov	r9,0
80003fee:	4c 68       	lddpc	r8,80004104 <phy_rx_func+0xebc>
80003ff0:	91 09       	st.w	r8[0x0],r9
80003ff2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003ff6:	30 09       	mov	r9,0
80003ff8:	4c 38       	lddpc	r8,80004104 <phy_rx_func+0xebc>
80003ffa:	91 09       	st.w	r8[0x0],r9
80003ffc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80004000:	8e 4a       	ld.sh	r10,r7[0x8]
80004002:	4d 99       	lddpc	r9,80004164 <phy_rx_func+0xf1c>
80004004:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80004008:	4d 6a       	lddpc	r10,80004160 <phy_rx_func+0xf18>
8000400a:	15 88       	ld.ub	r8,r10[0x0]
8000400c:	f0 cb ff ff 	sub	r11,r8,-1
80004010:	8e 5c       	ld.sh	r12,r7[0xa]
80004012:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80004016:	f0 cb ff fe 	sub	r11,r8,-2
8000401a:	8e 6c       	ld.sh	r12,r7[0xc]
8000401c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004020:	f0 cb ff fd 	sub	r11,r8,-3
80004024:	8e 7c       	ld.sh	r12,r7[0xe]
80004026:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
8000402a:	2f c8       	sub	r8,-4
8000402c:	b4 88       	st.b	r10[0x0],r8
8000402e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004032:	30 09       	mov	r9,0
80004034:	4b 48       	lddpc	r8,80004104 <phy_rx_func+0xebc>
80004036:	91 09       	st.w	r8[0x0],r9
80004038:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
8000403c:	4c 08       	lddpc	r8,8000413c <phy_rx_func+0xef4>
8000403e:	70 09       	ld.w	r9,r8[0x0]
80004040:	8e 4b       	ld.sh	r11,r7[0x8]
80004042:	4c 0a       	lddpc	r10,80004140 <phy_rx_func+0xef8>
80004044:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80004048:	2f f9       	sub	r9,-1
8000404a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
8000404c:	4b 58       	lddpc	r8,80004120 <phy_rx_func+0xed8>
8000404e:	70 09       	ld.w	r9,r8[0x0]
80004050:	20 29       	sub	r9,2
80004052:	91 09       	st.w	r8[0x0],r9
80004054:	70 08       	ld.w	r8,r8[0x0]
80004056:	58 08       	cp.w	r8,0
80004058:	c2 f1       	brne	800040b6 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
8000405a:	30 09       	mov	r9,0
8000405c:	4b 88       	lddpc	r8,8000413c <phy_rx_func+0xef4>
8000405e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004060:	8e 59       	ld.sh	r9,r7[0xa]
80004062:	fe 78 82 12 	mov	r8,-32238
80004066:	f0 09 19 00 	cp.h	r9,r8
8000406a:	c2 11       	brne	800040ac <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000406c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80004070:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80004074:	4a f8       	lddpc	r8,80004130 <phy_rx_func+0xee8>
80004076:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80004078:	8e 59       	ld.sh	r9,r7[0xa]
8000407a:	4a f8       	lddpc	r8,80004134 <phy_rx_func+0xeec>
8000407c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
8000407e:	8e 69       	ld.sh	r9,r7[0xc]
80004080:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80004082:	f0 1f 00 2e 	mcall	80004138 <phy_rx_func+0xef0>
80004086:	4a 18       	lddpc	r8,80004108 <phy_rx_func+0xec0>
80004088:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000408a:	ef 39 00 0f 	ld.ub	r9,r7[15]
8000408e:	31 38       	mov	r8,19
80004090:	f0 09 18 00 	cp.b	r9,r8
80004094:	c0 71       	brne	800040a2 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004096:	10 99       	mov	r9,r8
80004098:	4a 18       	lddpc	r8,8000411c <phy_rx_func+0xed4>
8000409a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
8000409c:	30 09       	mov	r9,0
8000409e:	49 c8       	lddpc	r8,8000410c <phy_rx_func+0xec4>
800040a0:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
800040a2:	30 49       	mov	r9,4
800040a4:	49 88       	lddpc	r8,80004104 <phy_rx_func+0xebc>
800040a6:	91 09       	st.w	r8[0x0],r9
800040a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
800040ac:	30 09       	mov	r9,0
800040ae:	49 68       	lddpc	r8,80004104 <phy_rx_func+0xebc>
800040b0:	91 09       	st.w	r8[0x0],r9
800040b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
800040b6:	4a dc       	lddpc	r12,80004168 <phy_rx_func+0xf20>
800040b8:	f0 1f 00 18 	mcall	80004118 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
800040bc:	30 09       	mov	r9,0
800040be:	49 28       	lddpc	r8,80004104 <phy_rx_func+0xebc>
800040c0:	91 09       	st.w	r8[0x0],r9
800040c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800040c6:	00 00       	add	r0,r0
800040c8:	00 00       	add	r0,r0
800040ca:	0a bc       	st.h	r5++,r12
800040cc:	00 00       	add	r0,r0
800040ce:	0a c0       	st.b	r5++,r0
800040d0:	00 00       	add	r0,r0
800040d2:	0a a4       	st.w	r5++,r4
800040d4:	00 00       	add	r0,r0
800040d6:	0a 80       	andn	r0,r5
800040d8:	00 00       	add	r0,r0
800040da:	0a 78       	tst	r8,r5
800040dc:	00 00       	add	r0,r0
800040de:	0a b8       	st.h	r5++,r8
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	30 68       	mov	r8,6
800040e4:	00 00       	add	r0,r0
800040e6:	0a 8c       	andn	r12,r5
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	2f 98       	sub	r8,-7
800040ec:	00 00       	add	r0,r0
800040ee:	0a 70       	tst	r0,r5
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	2f b4       	sub	r4,-5
800040f4:	00 00       	add	r0,r0
800040f6:	0a 89       	andn	r9,r5
800040f8:	00 00       	add	r0,r0
800040fa:	0a 74       	tst	r4,r5
800040fc:	00 00       	add	r0,r0
800040fe:	0a a0       	st.w	r5++,r0
80004100:	00 00       	add	r0,r0
80004102:	0a 98       	mov	r8,r5
80004104:	00 00       	add	r0,r0
80004106:	0a d4       	st.w	--r5,r4
80004108:	00 00       	add	r0,r0
8000410a:	0a 6c       	and	r12,r5
8000410c:	00 00       	add	r0,r0
8000410e:	0a 7c       	tst	r12,r5
80004110:	00 00       	add	r0,r0
80004112:	0a 4d       	or	sp,r5
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	cf 2c       	rcall	800042fa <ssc_init+0x56>
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	69 04       	ld.w	r4,r4[0x40]
8000411c:	00 00       	add	r0,r0
8000411e:	0a 88       	andn	r8,r5
80004120:	00 00       	add	r0,r0
80004122:	0a 94       	mov	r4,r5
80004124:	00 00       	add	r0,r0
80004126:	0a a8       	st.w	r5++,r8
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	71 5e       	ld.w	lr,r8[0x54]
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	31 e8       	mov	r8,30
80004130:	00 00       	add	r0,r0
80004132:	0a 49       	or	r9,r5
80004134:	00 00       	add	r0,r0
80004136:	1e 90       	mov	r0,pc
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	2e f8       	sub	r8,-17
8000413c:	00 00       	add	r0,r0
8000413e:	0a c4       	st.b	r5++,r4
80004140:	00 00       	add	r0,r0
80004142:	1d 94       	ld.ub	r4,lr[0x1]
80004144:	00 00       	add	r0,r0
80004146:	0a d8       	st.w	--r5,r8
80004148:	00 00       	add	r0,r0
8000414a:	0a 4a       	or	r10,r5
8000414c:	00 00       	add	r0,r0
8000414e:	0a 41       	or	r1,r5
80004150:	00 00       	add	r0,r0
80004152:	0a b4       	st.h	r5++,r4
80004154:	00 00       	add	r0,r0
80004156:	0a 9c       	mov	r12,r5
80004158:	00 00       	add	r0,r0
8000415a:	0a 48       	or	r8,r5
8000415c:	00 00       	add	r0,r0
8000415e:	1d 8c       	ld.ub	r12,lr[0x0]
80004160:	00 00       	add	r0,r0
80004162:	0a cc       	st.b	r5++,r12
80004164:	00 00       	add	r0,r0
80004166:	1e 94       	mov	r4,pc
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	cf 44       	brge	80004152 <phy_rx_func+0xf0a>

8000416c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
8000416c:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000416e:	49 88       	lddpc	r8,800041cc <pdca_int_handler+0x60>
80004170:	11 89       	ld.ub	r9,r8[0x0]
80004172:	ec 19 00 01 	eorl	r9,0x1
80004176:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004178:	11 89       	ld.ub	r9,r8[0x0]
8000417a:	a5 69       	lsl	r9,0x4
8000417c:	2f c9       	sub	r9,-4
8000417e:	49 5a       	lddpc	r10,800041d0 <pdca_int_handler+0x64>
80004180:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004182:	fe 7a 00 40 	mov	r10,-65472
80004186:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004188:	30 39       	mov	r9,3
8000418a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
8000418c:	11 8a       	ld.ub	r10,r8[0x0]
8000418e:	a5 6a       	lsl	r10,0x4
80004190:	2f ca       	sub	r10,-4
80004192:	49 18       	lddpc	r8,800041d4 <pdca_int_handler+0x68>
80004194:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004196:	fe 78 00 00 	mov	r8,-65536
8000419a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000419c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000419e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800041a0:	48 e8       	lddpc	r8,800041d8 <pdca_int_handler+0x6c>
800041a2:	70 08       	ld.w	r8,r8[0x0]
800041a4:	58 08       	cp.w	r8,0
800041a6:	c0 70       	breq	800041b4 <pdca_int_handler+0x48>
800041a8:	48 99       	lddpc	r9,800041cc <pdca_int_handler+0x60>
800041aa:	13 89       	ld.ub	r9,r9[0x0]
800041ac:	a5 69       	lsl	r9,0x4
800041ae:	48 ac       	lddpc	r12,800041d4 <pdca_int_handler+0x68>
800041b0:	12 0c       	add	r12,r9
800041b2:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800041b4:	48 a8       	lddpc	r8,800041dc <pdca_int_handler+0x70>
800041b6:	70 08       	ld.w	r8,r8[0x0]
800041b8:	58 08       	cp.w	r8,0
800041ba:	c0 70       	breq	800041c8 <pdca_int_handler+0x5c>
800041bc:	48 49       	lddpc	r9,800041cc <pdca_int_handler+0x60>
800041be:	13 89       	ld.ub	r9,r9[0x0]
800041c0:	a5 69       	lsl	r9,0x4
800041c2:	48 4c       	lddpc	r12,800041d0 <pdca_int_handler+0x64>
800041c4:	12 0c       	add	r12,r9
800041c6:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800041c8:	d4 02       	popm	lr
800041ca:	d6 03       	rete
800041cc:	00 00       	add	r0,r0
800041ce:	50 b4       	stdsp	sp[0x2c],r4
800041d0:	00 00       	add	r0,r0
800041d2:	50 dc       	stdsp	sp[0x34],r12
800041d4:	00 00       	add	r0,r0
800041d6:	50 bc       	stdsp	sp[0x2c],r12
800041d8:	00 00       	add	r0,r0
800041da:	0a e0       	st.h	--r5,r0
800041dc:	00 00       	add	r0,r0
800041de:	0a e4       	st.h	--r5,r4

800041e0 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800041e0:	fe 78 10 00 	mov	r8,-61440
800041e4:	e0 69 0d c0 	mov	r9,3520
800041e8:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800041ec:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800041f0:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800041f4:	fe 78 34 00 	mov	r8,-52224
800041f8:	e0 69 80 00 	mov	r9,32768
800041fc:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
800041fe:	30 09       	mov	r9,0
80004200:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004202:	e0 69 04 21 	mov	r9,1057
80004206:	ea 19 3f 20 	orh	r9,0x3f20
8000420a:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
8000420c:	e0 69 02 9f 	mov	r9,671
80004210:	ea 19 01 00 	orh	r9,0x100
80004214:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80004216:	e0 6a 04 02 	mov	r10,1026
8000421a:	ea 1a 3f 20 	orh	r10,0x3f20
8000421e:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80004220:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004222:	5e fc       	retal	r12

80004224 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004224:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004226:	30 19       	mov	r9,1
80004228:	49 78       	lddpc	r8,80004284 <local_start_PDC+0x60>
8000422a:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
8000422c:	fe 78 00 00 	mov	r8,-65536
80004230:	30 7b       	mov	r11,7
80004232:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004234:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004236:	49 59       	lddpc	r9,80004288 <local_start_PDC+0x64>
80004238:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
8000423c:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000423e:	30 3a       	mov	r10,3
80004240:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004242:	30 1c       	mov	r12,1
80004244:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004246:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004248:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000424a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000424c:	30 2c       	mov	r12,2
8000424e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004250:	48 f9       	lddpc	r9,8000428c <local_start_PDC+0x68>
80004252:	e0 68 5a 5a 	mov	r8,23130
80004256:	ea 18 ab cd 	orh	r8,0xabcd
8000425a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
8000425c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000425e:	30 0e       	mov	lr,0
80004260:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004262:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004264:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004266:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004268:	fe 78 00 40 	mov	r8,-65472
8000426c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000426e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004270:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004274:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004276:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004278:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000427a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
8000427c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000427e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004280:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004282:	d8 02       	popm	pc
80004284:	00 00       	add	r0,r0
80004286:	50 b4       	stdsp	sp[0x2c],r4
80004288:	00 00       	add	r0,r0
8000428a:	50 bc       	stdsp	sp[0x2c],r12
8000428c:	00 00       	add	r0,r0
8000428e:	50 dc       	stdsp	sp[0x34],r12

80004290 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004290:	48 38       	lddpc	r8,8000429c <register_rx_tx_func+0xc>
80004292:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004294:	48 38       	lddpc	r8,800042a0 <register_rx_tx_func+0x10>
80004296:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004298:	5e fc       	retal	r12
8000429a:	00 00       	add	r0,r0
8000429c:	00 00       	add	r0,r0
8000429e:	0a e0       	st.h	--r5,r0
800042a0:	00 00       	add	r0,r0
800042a2:	0a e4       	st.h	--r5,r4

800042a4 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800042a4:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800042a6:	fe 78 10 00 	mov	r8,-61440
800042aa:	30 29       	mov	r9,2
800042ac:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800042b0:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
800042b4:	30 3a       	mov	r10,3
800042b6:	36 0b       	mov	r11,96
800042b8:	49 3c       	lddpc	r12,80004304 <ssc_init+0x60>
800042ba:	f0 1f 00 14 	mcall	80004308 <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
800042be:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800042c0:	fe 79 10 00 	mov	r9,-61440
800042c4:	f2 f8 01 60 	ld.w	r8,r9[352]
800042c8:	e2 18 00 02 	andl	r8,0x2,COH
800042cc:	cf c0       	breq	800042c4 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800042ce:	fe 79 10 00 	mov	r9,-61440
800042d2:	f2 f8 01 60 	ld.w	r8,r9[352]
800042d6:	e2 18 00 02 	andl	r8,0x2,COH
800042da:	cf c1       	brne	800042d2 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
800042dc:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
800042de:	f0 1f 00 0c 	mcall	8000430c <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
800042e2:	f0 1f 00 0c 	mcall	80004310 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800042e6:	fe 79 00 00 	mov	r9,-65536
800042ea:	30 18       	mov	r8,1
800042ec:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800042ee:	fe 7a 00 40 	mov	r10,-65472
800042f2:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800042f4:	e0 6b 01 01 	mov	r11,257
800042f8:	fe 7a 34 00 	mov	r10,-52224
800042fc:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
800042fe:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80004300:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80004302:	d8 02       	popm	pc
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	41 6c       	lddsp	r12,sp[0x58]
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	4e f8       	lddpc	r8,800044c4 <xcmp_init+0x50>
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	41 e0       	lddsp	r0,sp[0x78]
80004310:	80 00       	ld.sh	r0,r0[0x0]
80004312:	42 24       	lddsp	r4,sp[0x88]

80004314 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004314:	48 28       	lddpc	r8,8000431c <xcmp_register_app_list+0x8>
80004316:	91 0c       	st.w	r8[0x0],r12
}
80004318:	5e fc       	retal	r12
8000431a:	00 00       	add	r0,r0
8000431c:	00 00       	add	r0,r0
8000431e:	50 fc       	stdsp	sp[0x3c],r12

80004320 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004320:	eb cd 40 80 	pushm	r7,lr
80004324:	fa cd 01 00 	sub	sp,sp,256
80004328:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000432a:	16 98       	mov	r8,r11
8000432c:	2f 08       	sub	r8,-16
8000432e:	af a8       	sbr	r8,0xe
80004330:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004332:	3f f8       	mov	r8,-1
80004334:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004336:	30 b9       	mov	r9,11
80004338:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000433a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
8000433c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000433e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004340:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004342:	f6 ca ff fe 	sub	r10,r11,-2
80004346:	18 9b       	mov	r11,r12
80004348:	fa cc ff f0 	sub	r12,sp,-16
8000434c:	f0 1f 00 05 	mcall	80004360 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004350:	2f e7       	sub	r7,-2
80004352:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004354:	1a 9c       	mov	r12,sp
80004356:	f0 1f 00 04 	mcall	80004364 <xcmp_tx+0x44>
}
8000435a:	2c 0d       	sub	sp,-256
8000435c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004360:	80 00       	ld.sh	r0,r0[0x0]
80004362:	70 16       	ld.w	r6,r8[0x4]
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	48 a0       	lddpc	r0,8000438c <xcmp_DeviceInitializationStatus_request+0x24>

80004368 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004368:	d4 01       	pushm	lr
8000436a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000436e:	fe 78 b4 00 	mov	r8,-19456
80004372:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004374:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004378:	30 89       	mov	r9,8
8000437a:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
8000437c:	30 19       	mov	r9,1
8000437e:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004380:	30 09       	mov	r9,0
80004382:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004384:	30 5a       	mov	r10,5
80004386:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004388:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000438a:	30 7a       	mov	r10,7
8000438c:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000438e:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004390:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004392:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80004396:	30 9b       	mov	r11,9
80004398:	fa cc ff fe 	sub	r12,sp,-2
8000439c:	f0 1f 00 02 	mcall	800043a4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800043a0:	2c dd       	sub	sp,-204
800043a2:	d8 02       	popm	pc
800043a4:	80 00       	ld.sh	r0,r0[0x0]
800043a6:	43 20       	lddsp	r0,sp[0xc8]

800043a8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800043a8:	d4 01       	pushm	lr
800043aa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800043ae:	fe 78 80 00 	mov	r8,-32768
800043b2:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800043b4:	30 38       	mov	r8,3
800043b6:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800043b8:	30 1b       	mov	r11,1
800043ba:	fa cc ff fe 	sub	r12,sp,-2
800043be:	f0 1f 00 03 	mcall	800043c8 <xcmp_opcode_not_supported+0x20>
}
800043c2:	2c dd       	sub	sp,-204
800043c4:	d8 02       	popm	pc
800043c6:	00 00       	add	r0,r0
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	43 20       	lddsp	r0,sp[0xc8]

800043cc <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800043cc:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800043ce:	96 88       	ld.uh	r8,r11[0x0]
800043d0:	e2 18 f0 00 	andl	r8,0xf000,COH
800043d4:	e0 48 80 00 	cp.w	r8,32768
800043d8:	c0 f0       	breq	800043f6 <xcmp_exec_func+0x2a>
800043da:	e0 48 b0 00 	cp.w	r8,45056
800043de:	c1 20       	breq	80004402 <xcmp_exec_func+0x36>
800043e0:	58 08       	cp.w	r8,0
800043e2:	c1 51       	brne	8000440c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800043e4:	78 08       	ld.w	r8,r12[0x0]
800043e6:	58 08       	cp.w	r8,0
800043e8:	c0 40       	breq	800043f0 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800043ea:	16 9c       	mov	r12,r11
800043ec:	5d 18       	icall	r8
800043ee:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800043f0:	f0 1f 00 08 	mcall	80004410 <xcmp_exec_func+0x44>
800043f4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800043f6:	78 18       	ld.w	r8,r12[0x4]
800043f8:	58 08       	cp.w	r8,0
800043fa:	c0 90       	breq	8000440c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800043fc:	16 9c       	mov	r12,r11
800043fe:	5d 18       	icall	r8
80004400:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004402:	78 28       	ld.w	r8,r12[0x8]
80004404:	58 08       	cp.w	r8,0
80004406:	c0 30       	breq	8000440c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004408:	16 9c       	mov	r12,r11
8000440a:	5d 18       	icall	r8
8000440c:	d8 02       	popm	pc
8000440e:	00 00       	add	r0,r0
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	43 a8       	lddsp	r8,sp[0xe8]

80004414 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004414:	d4 01       	pushm	lr
80004416:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000441a:	e0 68 04 09 	mov	r8,1033
8000441e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004420:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004424:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80004426:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000442a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
8000442c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000442e:	30 09       	mov	r9,0
80004430:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004432:	fb 69 00 08 	st.b	sp[8],r9
80004436:	fa c8 ff f7 	sub	r8,sp,-9
8000443a:	b0 89       	st.b	r8[0x0],r9
8000443c:	fa c8 ff f6 	sub	r8,sp,-10
80004440:	b0 89       	st.b	r8[0x0],r9
80004442:	fa c8 ff f5 	sub	r8,sp,-11
80004446:	b0 89       	st.b	r8[0x0],r9
80004448:	fa c8 ff f4 	sub	r8,sp,-12
8000444c:	b0 89       	st.b	r8[0x0],r9
8000444e:	fa c8 ff f3 	sub	r8,sp,-13
80004452:	b0 89       	st.b	r8[0x0],r9
80004454:	fa c8 ff f2 	sub	r8,sp,-14
80004458:	b0 89       	st.b	r8[0x0],r9
8000445a:	fa c8 ff f1 	sub	r8,sp,-15
8000445e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004460:	30 cb       	mov	r11,12
80004462:	fa cc ff fe 	sub	r12,sp,-2
80004466:	f0 1f 00 03 	mcall	80004470 <xcmp_IdleTestTone+0x5c>
}
8000446a:	2c dd       	sub	sp,-204
8000446c:	d8 02       	popm	pc
8000446e:	00 00       	add	r0,r0
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	43 20       	lddsp	r0,sp[0xc8]

80004474 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004474:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004476:	48 dc       	lddpc	r12,800044a8 <xcmp_init+0x34>
80004478:	f0 1f 00 0d 	mcall	800044ac <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
8000447c:	30 4b       	mov	r11,4
8000447e:	31 4c       	mov	r12,20
80004480:	f0 1f 00 0c 	mcall	800044b0 <xcmp_init+0x3c>
80004484:	48 c8       	lddpc	r8,800044b4 <xcmp_init+0x40>
80004486:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004488:	30 09       	mov	r9,0
8000448a:	1a d9       	st.w	--sp,r9
8000448c:	1a d9       	st.w	--sp,r9
8000448e:	1a d9       	st.w	--sp,r9
80004490:	30 38       	mov	r8,3
80004492:	e0 6a 01 80 	mov	r10,384
80004496:	48 9b       	lddpc	r11,800044b8 <xcmp_init+0x44>
80004498:	48 9c       	lddpc	r12,800044bc <xcmp_init+0x48>
8000449a:	f0 1f 00 0a 	mcall	800044c0 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
8000449e:	f0 1f 00 0a 	mcall	800044c4 <xcmp_init+0x50>
800044a2:	2f dd       	sub	sp,-12
	
}
800044a4:	d8 02       	popm	pc
800044a6:	00 00       	add	r0,r0
800044a8:	80 00       	ld.sh	r0,r0[0x0]
800044aa:	45 c4       	lddsp	r4,sp[0x170]
800044ac:	80 00       	ld.sh	r0,r0[0x0]
800044ae:	46 10       	lddsp	r0,sp[0x184]
800044b0:	80 00       	ld.sh	r0,r0[0x0]
800044b2:	5c 98       	brev	r8
800044b4:	00 00       	add	r0,r0
800044b6:	0b 00       	ld.w	r0,r5++
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	cf 70       	breq	800044a8 <xcmp_init+0x34>
800044bc:	80 00       	ld.sh	r0,r0[0x0]
800044be:	44 c8       	lddsp	r8,sp[0x130]
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	63 b4       	ld.w	r4,r1[0x6c]
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	46 48       	lddsp	r8,sp[0x190]

800044c8 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800044c8:	d4 31       	pushm	r0-r7,lr
800044ca:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800044cc:	4b 16       	lddpc	r6,80004590 <xcmp_rx_process+0xc8>
800044ce:	30 05       	mov	r5,0
800044d0:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800044d2:	4b 13       	lddpc	r3,80004594 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800044d4:	4b 12       	lddpc	r2,80004598 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800044d6:	4b 21       	lddpc	r1,8000459c <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800044d8:	4b 20       	lddpc	r0,800045a0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800044da:	6c 0c       	ld.w	r12,r6[0x0]
800044dc:	0a 99       	mov	r9,r5
800044de:	08 9a       	mov	r10,r4
800044e0:	1a 9b       	mov	r11,sp
800044e2:	f0 1f 00 31 	mcall	800045a4 <xcmp_rx_process+0xdc>
800044e6:	58 1c       	cp.w	r12,1
800044e8:	cf 91       	brne	800044da <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800044ea:	40 0b       	lddsp	r11,sp[0x0]
800044ec:	58 0b       	cp.w	r11,0
800044ee:	cf 60       	breq	800044da <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800044f0:	96 0a       	ld.sh	r10,r11[0x0]
800044f2:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800044f6:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800044fa:	59 c8       	cp.w	r8,28
800044fc:	c1 e0       	breq	80004538 <xcmp_rx_process+0x70>
800044fe:	e0 89 00 07 	brgt	8000450c <xcmp_rx_process+0x44>
80004502:	58 e8       	cp.w	r8,14
80004504:	c0 e0       	breq	80004520 <xcmp_rx_process+0x58>
80004506:	58 f8       	cp.w	r8,15
80004508:	c2 41       	brne	80004550 <xcmp_rx_process+0x88>
8000450a:	c0 f8       	rjmp	80004528 <xcmp_rx_process+0x60>
8000450c:	e0 48 01 09 	cp.w	r8,265
80004510:	c1 80       	breq	80004540 <xcmp_rx_process+0x78>
80004512:	e0 48 01 0a 	cp.w	r8,266
80004516:	c1 90       	breq	80004548 <xcmp_rx_process+0x80>
80004518:	e0 48 00 2c 	cp.w	r8,44
8000451c:	c1 a1       	brne	80004550 <xcmp_rx_process+0x88>
8000451e:	c0 98       	rjmp	80004530 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004520:	4a 2c       	lddpc	r12,800045a8 <xcmp_rx_process+0xe0>
80004522:	f0 1f 00 23 	mcall	800045ac <xcmp_rx_process+0xe4>
					break;
80004526:	c2 f8       	rjmp	80004584 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004528:	4a 2c       	lddpc	r12,800045b0 <xcmp_rx_process+0xe8>
8000452a:	f0 1f 00 21 	mcall	800045ac <xcmp_rx_process+0xe4>
					break;
8000452e:	c2 b8       	rjmp	80004584 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004530:	4a 1c       	lddpc	r12,800045b4 <xcmp_rx_process+0xec>
80004532:	f0 1f 00 1f 	mcall	800045ac <xcmp_rx_process+0xe4>
					break;
80004536:	c2 78       	rjmp	80004584 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004538:	04 9c       	mov	r12,r2
8000453a:	f0 1f 00 1d 	mcall	800045ac <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000453e:	c2 38       	rjmp	80004584 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004540:	02 9c       	mov	r12,r1
80004542:	f0 1f 00 1b 	mcall	800045ac <xcmp_rx_process+0xe4>
					break;
80004546:	c1 f8       	rjmp	80004584 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004548:	00 9c       	mov	r12,r0
8000454a:	f0 1f 00 19 	mcall	800045ac <xcmp_rx_process+0xe4>
					break;
8000454e:	c1 b8       	rjmp	80004584 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004550:	12 98       	mov	r8,r9
80004552:	e2 18 04 00 	andl	r8,0x400,COH
80004556:	c0 70       	breq	80004564 <xcmp_rx_process+0x9c>
80004558:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000455c:	e0 48 00 68 	cp.w	r8,104
80004560:	e0 8a 00 08 	brle	80004570 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004564:	e2 19 f0 00 	andl	r9,0xf000,COH
80004568:	c0 e1       	brne	80004584 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000456a:	f0 1f 00 14 	mcall	800045b8 <xcmp_rx_process+0xf0>
8000456e:	c0 b8       	rjmp	80004584 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004570:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004574:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004578:	49 19       	lddpc	r9,800045bc <xcmp_rx_process+0xf4>
8000457a:	72 08       	ld.w	r8,r9[0x0]
8000457c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004580:	f0 1f 00 0b 	mcall	800045ac <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004584:	66 0c       	ld.w	r12,r3[0x0]
80004586:	40 0b       	lddsp	r11,sp[0x0]
80004588:	f0 1f 00 0e 	mcall	800045c0 <xcmp_rx_process+0xf8>
8000458c:	ca 7b       	rjmp	800044da <xcmp_rx_process+0x12>
8000458e:	00 00       	add	r0,r0
80004590:	00 00       	add	r0,r0
80004592:	0b 00       	ld.w	r0,r5++
80004594:	00 00       	add	r0,r0
80004596:	0a b8       	st.h	r5++,r8
80004598:	00 00       	add	r0,r0
8000459a:	0b 10       	ld.sh	r0,r5++
8000459c:	00 00       	add	r0,r0
8000459e:	0b 04       	ld.w	r4,r5++
800045a0:	00 00       	add	r0,r0
800045a2:	0a f4       	st.b	--r5,r4
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	59 8c       	cp.w	r12,24
800045a8:	00 00       	add	r0,r0
800045aa:	0b 28       	ld.uh	r8,r5++
800045ac:	80 00       	ld.sh	r0,r0[0x0]
800045ae:	43 cc       	lddsp	r12,sp[0xf0]
800045b0:	00 00       	add	r0,r0
800045b2:	0a e8       	st.h	--r5,r8
800045b4:	00 00       	add	r0,r0
800045b6:	0b 1c       	ld.sh	r12,r5++
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	43 a8       	lddsp	r8,sp[0xe8]
800045bc:	00 00       	add	r0,r0
800045be:	50 fc       	stdsp	sp[0x3c],r12
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	2f ec       	sub	r12,-2

800045c4 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800045c4:	eb cd 40 90 	pushm	r4,r7,lr
800045c8:	20 1d       	sub	sp,4
800045ca:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800045ce:	48 c8       	lddpc	r8,800045fc <xcmp_rx+0x38>
800045d0:	70 0c       	ld.w	r12,r8[0x0]
800045d2:	f0 1f 00 0c 	mcall	80004600 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800045d6:	c1 00       	breq	800045f6 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800045d8:	fa c7 ff fc 	sub	r7,sp,-4
800045dc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800045de:	e0 6a 00 ca 	mov	r10,202
800045e2:	08 9b       	mov	r11,r4
800045e4:	f0 1f 00 08 	mcall	80004604 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800045e8:	48 88       	lddpc	r8,80004608 <xcmp_rx+0x44>
800045ea:	70 0c       	ld.w	r12,r8[0x0]
800045ec:	30 09       	mov	r9,0
800045ee:	12 9a       	mov	r10,r9
800045f0:	1a 9b       	mov	r11,sp
800045f2:	f0 1f 00 07 	mcall	8000460c <xcmp_rx+0x48>
	}	
}
800045f6:	2f fd       	sub	sp,-4
800045f8:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800045fc:	00 00       	add	r0,r0
800045fe:	0a b8       	st.h	r5++,r8
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	31 98       	mov	r8,25
80004604:	80 00       	ld.sh	r0,r0[0x0]
80004606:	70 16       	ld.w	r6,r8[0x4]
80004608:	00 00       	add	r0,r0
8000460a:	0b 00       	ld.w	r0,r5++
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	5b 98       	cp.w	r8,-7

80004610 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004610:	48 28       	lddpc	r8,80004618 <xnl_register_xcmp_func+0x8>
80004612:	91 0c       	st.w	r8[0x0],r12
}
80004614:	5e fc       	retal	r12
80004616:	00 00       	add	r0,r0
80004618:	00 00       	add	r0,r0
8000461a:	0b 58       	ld.sh	r8,--r5

8000461c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000461c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000461e:	48 88       	lddpc	r8,8000463c <xnl_get_msg_ack_func+0x20>
80004620:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004622:	98 49       	ld.sh	r9,r12[0x8]
80004624:	f0 09 19 00 	cp.h	r9,r8
80004628:	c0 81       	brne	80004638 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000462a:	48 68       	lddpc	r8,80004640 <xnl_get_msg_ack_func+0x24>
8000462c:	70 0c       	ld.w	r12,r8[0x0]
8000462e:	30 09       	mov	r9,0
80004630:	12 9a       	mov	r10,r9
80004632:	12 9b       	mov	r11,r9
80004634:	f0 1f 00 04 	mcall	80004644 <xnl_get_msg_ack_func+0x28>
80004638:	d8 02       	popm	pc
8000463a:	00 00       	add	r0,r0
8000463c:	00 00       	add	r0,r0
8000463e:	0b 38       	ld.ub	r8,r5++
80004640:	00 00       	add	r0,r0
80004642:	0b 34       	ld.ub	r4,r5++
80004644:	80 00       	ld.sh	r0,r0[0x0]
80004646:	5b 98       	cp.w	r8,-7

80004648 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004648:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
8000464c:	30 09       	mov	r9,0
8000464e:	4b 78       	lddpc	r8,80004728 <xnl_init+0xe0>
80004650:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004652:	30 0b       	mov	r11,0
80004654:	30 1c       	mov	r12,1
80004656:	f0 1f 00 36 	mcall	8000472c <xnl_init+0xe4>
8000465a:	4b 68       	lddpc	r8,80004730 <xnl_init+0xe8>
8000465c:	91 0c       	st.w	r8[0x0],r12
8000465e:	70 08       	ld.w	r8,r8[0x0]
80004660:	58 08       	cp.w	r8,0
80004662:	c0 80       	breq	80004672 <xnl_init+0x2a>
80004664:	4b 38       	lddpc	r8,80004730 <xnl_init+0xe8>
80004666:	70 0c       	ld.w	r12,r8[0x0]
80004668:	30 09       	mov	r9,0
8000466a:	12 9a       	mov	r10,r9
8000466c:	12 9b       	mov	r11,r9
8000466e:	f0 1f 00 32 	mcall	80004734 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004672:	30 4b       	mov	r11,4
80004674:	31 4c       	mov	r12,20
80004676:	f0 1f 00 2e 	mcall	8000472c <xnl_init+0xe4>
8000467a:	4b 08       	lddpc	r8,80004738 <xnl_init+0xf0>
8000467c:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
8000467e:	30 4b       	mov	r11,4
80004680:	31 ec       	mov	r12,30
80004682:	f0 1f 00 2b 	mcall	8000472c <xnl_init+0xe4>
80004686:	4a e8       	lddpc	r8,8000473c <xnl_init+0xf4>
80004688:	91 0c       	st.w	r8[0x0],r12
8000468a:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
8000468c:	10 96       	mov	r6,r8
8000468e:	4a d5       	lddpc	r5,80004740 <xnl_init+0xf8>
80004690:	6c 0c       	ld.w	r12,r6[0x0]
80004692:	ea 07 00 0b 	add	r11,r5,r7
80004696:	f0 1f 00 2c 	mcall	80004744 <xnl_init+0xfc>
8000469a:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000469e:	e0 47 1e 00 	cp.w	r7,7680
800046a2:	cf 71       	brne	80004690 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800046a4:	30 4b       	mov	r11,4
800046a6:	31 4c       	mov	r12,20
800046a8:	f0 1f 00 21 	mcall	8000472c <xnl_init+0xe4>
800046ac:	4a 78       	lddpc	r8,80004748 <xnl_init+0x100>
800046ae:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800046b0:	30 4b       	mov	r11,4
800046b2:	30 ac       	mov	r12,10
800046b4:	f0 1f 00 1e 	mcall	8000472c <xnl_init+0xe4>
800046b8:	4a 58       	lddpc	r8,8000474c <xnl_init+0x104>
800046ba:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800046bc:	30 4b       	mov	r11,4
800046be:	30 ac       	mov	r12,10
800046c0:	f0 1f 00 1b 	mcall	8000472c <xnl_init+0xe4>
800046c4:	4a 38       	lddpc	r8,80004750 <xnl_init+0x108>
800046c6:	91 0c       	st.w	r8[0x0],r12
800046c8:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800046ca:	10 96       	mov	r6,r8
800046cc:	4a 25       	lddpc	r5,80004754 <xnl_init+0x10c>
800046ce:	6c 0c       	ld.w	r12,r6[0x0]
800046d0:	ea 07 00 0b 	add	r11,r5,r7
800046d4:	f0 1f 00 1c 	mcall	80004744 <xnl_init+0xfc>
800046d8:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800046dc:	e0 47 14 00 	cp.w	r7,5120
800046e0:	cf 71       	brne	800046ce <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800046e2:	30 4b       	mov	r11,4
800046e4:	30 5c       	mov	r12,5
800046e6:	f0 1f 00 12 	mcall	8000472c <xnl_init+0xe4>
800046ea:	49 c8       	lddpc	r8,80004758 <xnl_init+0x110>
800046ec:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800046ee:	30 07       	mov	r7,0
800046f0:	1a d7       	st.w	--sp,r7
800046f2:	1a d7       	st.w	--sp,r7
800046f4:	1a d7       	st.w	--sp,r7
800046f6:	30 38       	mov	r8,3
800046f8:	0e 99       	mov	r9,r7
800046fa:	e0 6a 02 00 	mov	r10,512
800046fe:	49 8b       	lddpc	r11,8000475c <xnl_init+0x114>
80004700:	49 8c       	lddpc	r12,80004760 <xnl_init+0x118>
80004702:	f0 1f 00 19 	mcall	80004764 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004706:	1a d7       	st.w	--sp,r7
80004708:	1a d7       	st.w	--sp,r7
8000470a:	1a d7       	st.w	--sp,r7
8000470c:	30 38       	mov	r8,3
8000470e:	0e 99       	mov	r9,r7
80004710:	e0 6a 03 20 	mov	r10,800
80004714:	49 5b       	lddpc	r11,80004768 <xnl_init+0x120>
80004716:	49 6c       	lddpc	r12,8000476c <xnl_init+0x124>
80004718:	f0 1f 00 13 	mcall	80004764 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000471c:	f0 1f 00 15 	mcall	80004770 <xnl_init+0x128>
80004720:	2f ad       	sub	sp,-24
}
80004722:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004726:	00 00       	add	r0,r0
80004728:	00 00       	add	r0,r0
8000472a:	0b 38       	ld.ub	r8,r5++
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	5c 98       	brev	r8
80004730:	00 00       	add	r0,r0
80004732:	0b 34       	ld.ub	r4,r5++
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	5b 98       	cp.w	r8,-7
80004738:	00 00       	add	r0,r0
8000473a:	0b 44       	ld.w	r4,--r5
8000473c:	00 00       	add	r0,r0
8000473e:	0a b8       	st.h	r5++,r8
80004740:	00 00       	add	r0,r0
80004742:	32 ae       	mov	lr,42
80004744:	80 00       	ld.sh	r0,r0[0x0]
80004746:	2f ec       	sub	r12,-2
80004748:	00 00       	add	r0,r0
8000474a:	0a c8       	st.b	r5++,r8
8000474c:	00 00       	add	r0,r0
8000474e:	0a bc       	st.h	r5++,r12
80004750:	00 00       	add	r0,r0
80004752:	0a 74       	tst	r4,r5
80004754:	00 00       	add	r0,r0
80004756:	1e ae       	st.w	pc++,lr
80004758:	00 00       	add	r0,r0
8000475a:	0a 90       	mov	r0,r5
8000475c:	80 00       	ld.sh	r0,r0[0x0]
8000475e:	cf 78       	rjmp	8000494c <xnl_tx+0xac>
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	47 74       	lddsp	r4,sp[0x1dc]
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	63 b4       	ld.w	r4,r1[0x6c]
80004768:	80 00       	ld.sh	r0,r0[0x0]
8000476a:	c8 00       	breq	8000466a <xnl_init+0x22>
8000476c:	80 00       	ld.sh	r0,r0[0x0]
8000476e:	47 d4       	lddsp	r4,sp[0x1f4]
80004770:	80 00       	ld.sh	r0,r0[0x0]
80004772:	31 c0       	mov	r0,28

80004774 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004774:	eb cd 40 fe 	pushm	r1-r7,lr
80004778:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000477a:	49 26       	lddpc	r6,800047c0 <xnl_rx_process+0x4c>
8000477c:	30 05       	mov	r5,0
8000477e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004780:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004782:	49 11       	lddpc	r1,800047c4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004784:	49 12       	lddpc	r2,800047c8 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004786:	6c 0c       	ld.w	r12,r6[0x0]
80004788:	0a 99       	mov	r9,r5
8000478a:	08 9a       	mov	r10,r4
8000478c:	1a 9b       	mov	r11,sp
8000478e:	f0 1f 00 10 	mcall	800047cc <xnl_rx_process+0x58>
80004792:	58 1c       	cp.w	r12,1
80004794:	cf 91       	brne	80004786 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004796:	40 0c       	lddsp	r12,sp[0x0]
80004798:	58 0c       	cp.w	r12,0
8000479a:	cf 60       	breq	80004786 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000479c:	98 28       	ld.sh	r8,r12[0x4]
8000479e:	e6 08 19 00 	cp.h	r8,r3
800047a2:	e0 8b 00 0a 	brhi	800047b6 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800047a6:	5c 78       	castu.h	r8
800047a8:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800047ac:	58 09       	cp.w	r9,0
800047ae:	c0 40       	breq	800047b6 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800047b0:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800047b4:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800047b6:	62 0c       	ld.w	r12,r1[0x0]
800047b8:	40 0b       	lddsp	r11,sp[0x0]
800047ba:	f0 1f 00 06 	mcall	800047d0 <xnl_rx_process+0x5c>
800047be:	ce 4b       	rjmp	80004786 <xnl_rx_process+0x12>
800047c0:	00 00       	add	r0,r0
800047c2:	0a bc       	st.h	r5++,r12
800047c4:	00 00       	add	r0,r0
800047c6:	0a b8       	st.h	r5++,r8
800047c8:	00 00       	add	r0,r0
800047ca:	04 f0       	st.b	--r2,r0
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	59 8c       	cp.w	r12,24
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	2f ec       	sub	r12,-2

800047d4 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800047d4:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800047d6:	4a a6       	lddpc	r6,8000487c <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800047d8:	4a a2       	lddpc	r2,80004880 <xnl_tx_process+0xac>
800047da:	4a b4       	lddpc	r4,80004884 <xnl_tx_process+0xb0>
800047dc:	30 07       	mov	r7,0
800047de:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800047e0:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800047e2:	4a a5       	lddpc	r5,80004888 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800047e4:	4a a3       	lddpc	r3,8000488c <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800047e6:	6c 08       	ld.w	r8,r6[0x0]
800047e8:	58 08       	cp.w	r8,0
800047ea:	c0 40       	breq	800047f2 <xnl_tx_process+0x1e>
800047ec:	58 18       	cp.w	r8,1
800047ee:	cf d1       	brne	800047e8 <xnl_tx_process+0x14>
800047f0:	c2 48       	rjmp	80004838 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800047f2:	64 0c       	ld.w	r12,r2[0x0]
800047f4:	0e 99       	mov	r9,r7
800047f6:	02 9a       	mov	r10,r1
800047f8:	08 9b       	mov	r11,r4
800047fa:	f0 1f 00 26 	mcall	80004890 <xnl_tx_process+0xbc>
800047fe:	58 1c       	cp.w	r12,1
80004800:	cf 31       	brne	800047e6 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004802:	68 0b       	ld.w	r11,r4[0x0]
80004804:	58 0b       	cp.w	r11,0
80004806:	cf 00       	breq	800047e6 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004808:	96 28       	ld.sh	r8,r11[0x4]
8000480a:	e0 08 19 00 	cp.h	r8,r0
8000480e:	c0 71       	brne	8000481c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004810:	4a 18       	lddpc	r8,80004894 <xnl_tx_process+0xc0>
80004812:	70 08       	ld.w	r8,r8[0x0]
80004814:	10 9c       	mov	r12,r8
80004816:	f0 1f 00 21 	mcall	80004898 <xnl_tx_process+0xc4>
						break;
8000481a:	ce 6b       	rjmp	800047e6 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000481c:	16 9c       	mov	r12,r11
8000481e:	f0 1f 00 20 	mcall	8000489c <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004822:	30 18       	mov	r8,1
80004824:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004826:	66 0c       	ld.w	r12,r3[0x0]
80004828:	0e 99       	mov	r9,r7
8000482a:	0e 9a       	mov	r10,r7
8000482c:	0e 9b       	mov	r11,r7
8000482e:	f0 1f 00 19 	mcall	80004890 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004832:	30 18       	mov	r8,1
80004834:	8d 08       	st.w	r6[0x0],r8
80004836:	cd 8b       	rjmp	800047e6 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004838:	66 0c       	ld.w	r12,r3[0x0]
8000483a:	0e 99       	mov	r9,r7
8000483c:	36 4a       	mov	r10,100
8000483e:	0e 9b       	mov	r11,r7
80004840:	f0 1f 00 14 	mcall	80004890 <xnl_tx_process+0xbc>
80004844:	58 1c       	cp.w	r12,1
80004846:	c0 81       	brne	80004856 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004848:	49 38       	lddpc	r8,80004894 <xnl_tx_process+0xc0>
8000484a:	70 0c       	ld.w	r12,r8[0x0]
8000484c:	68 0b       	ld.w	r11,r4[0x0]
8000484e:	f0 1f 00 13 	mcall	80004898 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004852:	8d 07       	st.w	r6[0x0],r7
80004854:	cc 9b       	rjmp	800047e6 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004856:	6a 08       	ld.w	r8,r5[0x0]
80004858:	58 38       	cp.w	r8,3
8000485a:	e0 89 00 09 	brgt	8000486c <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000485e:	68 0c       	ld.w	r12,r4[0x0]
80004860:	f0 1f 00 0f 	mcall	8000489c <xnl_tx_process+0xc8>
						xnl_send_times++;
80004864:	6a 08       	ld.w	r8,r5[0x0]
80004866:	2f f8       	sub	r8,-1
80004868:	8b 08       	st.w	r5[0x0],r8
8000486a:	cb eb       	rjmp	800047e6 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000486c:	48 a8       	lddpc	r8,80004894 <xnl_tx_process+0xc0>
8000486e:	70 0c       	ld.w	r12,r8[0x0]
80004870:	68 0b       	ld.w	r11,r4[0x0]
80004872:	f0 1f 00 0a 	mcall	80004898 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004876:	8d 07       	st.w	r6[0x0],r7
80004878:	cb 7b       	rjmp	800047e6 <xnl_tx_process+0x12>
8000487a:	00 00       	add	r0,r0
8000487c:	00 00       	add	r0,r0
8000487e:	0b 54       	ld.sh	r4,--r5
80004880:	00 00       	add	r0,r0
80004882:	0b 44       	ld.w	r4,--r5
80004884:	00 00       	add	r0,r0
80004886:	0b 4c       	ld.w	r12,--r5
80004888:	00 00       	add	r0,r0
8000488a:	0b 48       	ld.w	r8,--r5
8000488c:	00 00       	add	r0,r0
8000488e:	0b 34       	ld.ub	r4,r5++
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	59 8c       	cp.w	r12,24
80004894:	00 00       	add	r0,r0
80004896:	0a b8       	st.h	r5++,r8
80004898:	80 00       	ld.sh	r0,r0[0x0]
8000489a:	2f ec       	sub	r12,-2
8000489c:	80 00       	ld.sh	r0,r0[0x0]
8000489e:	30 0c       	mov	r12,0

800048a0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800048a0:	eb cd 40 c0 	pushm	r6-r7,lr
800048a4:	20 1d       	sub	sp,4
800048a6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800048a8:	98 39       	ld.sh	r9,r12[0x6]
800048aa:	3f f8       	mov	r8,-1
800048ac:	f0 09 19 00 	cp.h	r9,r8
800048b0:	c0 a1       	brne	800048c4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800048b2:	4a e9       	lddpc	r9,80004968 <xnl_tx+0xc8>
800048b4:	13 88       	ld.ub	r8,r9[0x0]
800048b6:	2f f8       	sub	r8,-1
800048b8:	5c 58       	castu.b	r8
800048ba:	b2 88       	st.b	r9[0x0],r8
800048bc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800048c0:	a9 a8       	sbr	r8,0x8
800048c2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800048c4:	8c 49       	ld.sh	r9,r6[0x8]
800048c6:	3f f8       	mov	r8,-1
800048c8:	f0 09 19 00 	cp.h	r9,r8
800048cc:	c0 41       	brne	800048d4 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800048ce:	4a 88       	lddpc	r8,8000496c <xnl_tx+0xcc>
800048d0:	90 18       	ld.sh	r8,r8[0x2]
800048d2:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800048d4:	8c 59       	ld.sh	r9,r6[0xa]
800048d6:	3f f8       	mov	r8,-1
800048d8:	f0 09 19 00 	cp.h	r9,r8
800048dc:	c0 41       	brne	800048e4 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800048de:	4a 48       	lddpc	r8,8000496c <xnl_tx+0xcc>
800048e0:	90 28       	ld.sh	r8,r8[0x4]
800048e2:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800048e4:	8c 69       	ld.sh	r9,r6[0xc]
800048e6:	3f f8       	mov	r8,-1
800048e8:	f0 09 19 00 	cp.h	r9,r8
800048ec:	c0 e1       	brne	80004908 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800048ee:	4a 08       	lddpc	r8,8000496c <xnl_tx+0xcc>
800048f0:	90 49       	ld.sh	r9,r8[0x8]
800048f2:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800048f4:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800048f6:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800048f8:	90 49       	ld.sh	r9,r8[0x8]
800048fa:	e0 19 ff 00 	andl	r9,0xff00
800048fe:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004902:	f3 e8 10 08 	or	r8,r9,r8
80004906:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004908:	0d 98       	ld.ub	r8,r6[0x1]
8000490a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000490c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004910:	10 0c       	add	r12,r8
80004912:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004914:	58 0c       	cp.w	r12,0
80004916:	e0 89 00 04 	brgt	8000491e <xnl_tx+0x7e>
8000491a:	30 09       	mov	r9,0
8000491c:	c0 d8       	rjmp	80004936 <xnl_tx+0x96>
8000491e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004922:	2f ec       	sub	r12,-2
80004924:	30 09       	mov	r9,0
80004926:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004928:	15 1b       	ld.sh	r11,r10++
8000492a:	f6 09 00 09 	add	r9,r11,r9
8000492e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004930:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004932:	18 38       	cp.w	r8,r12
80004934:	cf a1       	brne	80004928 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004936:	5c 39       	neg	r9
80004938:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000493a:	48 e8       	lddpc	r8,80004970 <xnl_tx+0xd0>
8000493c:	70 0c       	ld.w	r12,r8[0x0]
8000493e:	f0 1f 00 0e 	mcall	80004974 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004942:	c1 00       	breq	80004962 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004944:	fa c7 ff fc 	sub	r7,sp,-4
80004948:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000494a:	e0 6a 01 00 	mov	r10,256
8000494e:	0c 9b       	mov	r11,r6
80004950:	f0 1f 00 0a 	mcall	80004978 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004954:	48 a8       	lddpc	r8,8000497c <xnl_tx+0xdc>
80004956:	70 0c       	ld.w	r12,r8[0x0]
80004958:	30 09       	mov	r9,0
8000495a:	12 9a       	mov	r10,r9
8000495c:	1a 9b       	mov	r11,sp
8000495e:	f0 1f 00 09 	mcall	80004980 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004962:	2f fd       	sub	sp,-4
80004964:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004968:	00 00       	add	r0,r0
8000496a:	0b 50       	ld.sh	r0,--r5
8000496c:	00 00       	add	r0,r0
8000496e:	0b 38       	ld.ub	r8,r5++
80004970:	00 00       	add	r0,r0
80004972:	0a b8       	st.h	r5++,r8
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	31 98       	mov	r8,25
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	70 16       	ld.w	r6,r8[0x4]
8000497c:	00 00       	add	r0,r0
8000497e:	0b 44       	ld.w	r4,--r5
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	5b 98       	cp.w	r8,-7

80004984 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004984:	eb cd 40 80 	pushm	r7,lr
80004988:	fa cd 01 00 	sub	sp,sp,256
8000498c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000498e:	e0 68 40 0e 	mov	r8,16398
80004992:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004994:	3f f8       	mov	r8,-1
80004996:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004998:	30 c8       	mov	r8,12
8000499a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000499c:	98 38       	ld.sh	r8,r12[0x6]
8000499e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800049a0:	98 58       	ld.sh	r8,r12[0xa]
800049a2:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800049a4:	98 48       	ld.sh	r8,r12[0x8]
800049a6:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800049a8:	98 68       	ld.sh	r8,r12[0xc]
800049aa:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800049ac:	30 08       	mov	r8,0
800049ae:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800049b0:	1a 9c       	mov	r12,sp
800049b2:	f0 1f 00 0a 	mcall	800049d8 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800049b6:	fa cd 00 cc 	sub	sp,sp,204
800049ba:	e0 6a 00 ca 	mov	r10,202
800049be:	ee cb ff f0 	sub	r11,r7,-16
800049c2:	1a 9c       	mov	r12,sp
800049c4:	f0 1f 00 06 	mcall	800049dc <xnl_data_msg_func+0x58>
800049c8:	48 68       	lddpc	r8,800049e0 <xnl_data_msg_func+0x5c>
800049ca:	70 08       	ld.w	r8,r8[0x0]
800049cc:	5d 18       	icall	r8
800049ce:	fa cd ff 34 	sub	sp,sp,-204
}
800049d2:	2c 0d       	sub	sp,-256
800049d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	48 a0       	lddpc	r0,80004a00 <xnl_device_auth_reply_func+0x1c>
800049dc:	80 00       	ld.sh	r0,r0[0x0]
800049de:	70 16       	ld.w	r6,r8[0x4]
800049e0:	00 00       	add	r0,r0
800049e2:	0b 58       	ld.sh	r8,--r5

800049e4 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800049e4:	d4 21       	pushm	r4-r7,lr
800049e6:	fa cd 01 00 	sub	sp,sp,256
800049ea:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800049ec:	4c 28       	lddpc	r8,80004af4 <xnl_device_auth_reply_func+0x110>
800049ee:	11 88       	ld.ub	r8,r8[0x0]
800049f0:	58 08       	cp.w	r8,0
800049f2:	e0 81 00 7f 	brne	80004af0 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800049f6:	4c 18       	lddpc	r8,80004af8 <xnl_device_auth_reply_func+0x114>
800049f8:	70 0c       	ld.w	r12,r8[0x0]
800049fa:	30 09       	mov	r9,0
800049fc:	12 9a       	mov	r10,r9
800049fe:	12 9b       	mov	r11,r9
80004a00:	f0 1f 00 3f 	mcall	80004afc <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004a04:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004a08:	4b b8       	lddpc	r8,80004af4 <xnl_device_auth_reply_func+0x110>
80004a0a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004a0c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004a10:	ef 38 00 13 	ld.ub	r8,r7[19]
80004a14:	b1 68       	lsl	r8,0x10
80004a16:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004a1a:	ef 38 00 15 	ld.ub	r8,r7[21]
80004a1e:	f3 e8 10 08 	or	r8,r9,r8
80004a22:	ef 39 00 14 	ld.ub	r9,r7[20]
80004a26:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004a2a:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004a2e:	ef 38 00 17 	ld.ub	r8,r7[23]
80004a32:	b1 68       	lsl	r8,0x10
80004a34:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004a38:	ef 38 00 19 	ld.ub	r8,r7[25]
80004a3c:	f5 e8 10 08 	or	r8,r10,r8
80004a40:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004a44:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004a48:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004a4a:	e0 64 79 b9 	mov	r4,31161
80004a4e:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004a52:	e0 65 45 07 	mov	r5,17671
80004a56:	ea 15 8a bd 	orh	r5,0x8abd
80004a5a:	e0 66 f9 3d 	mov	r6,63805
80004a5e:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004a62:	e0 6e b8 cf 	mov	lr,47311
80004a66:	ea 1e 36 83 	orh	lr,0x3683
80004a6a:	e0 67 aa 1c 	mov	r7,43548
80004a6e:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004a72:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004a74:	f4 08 00 0c 	add	r12,r10,r8
80004a78:	f0 0b 15 04 	lsl	r11,r8,0x4
80004a7c:	0a 0b       	add	r11,r5
80004a7e:	f9 eb 20 0b 	eor	r11,r12,r11
80004a82:	f0 0c 16 05 	lsr	r12,r8,0x5
80004a86:	0c 0c       	add	r12,r6
80004a88:	18 5b       	eor	r11,r12
80004a8a:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004a8c:	f2 0c 15 04 	lsl	r12,r9,0x4
80004a90:	1c 0c       	add	r12,lr
80004a92:	f2 0b 16 05 	lsr	r11,r9,0x5
80004a96:	0e 0b       	add	r11,r7
80004a98:	f9 eb 20 0b 	eor	r11,r12,r11
80004a9c:	f2 0a 00 0c 	add	r12,r9,r10
80004aa0:	18 5b       	eor	r11,r12
80004aa2:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004aa4:	e0 6b 37 20 	mov	r11,14112
80004aa8:	ea 1b c6 ef 	orh	r11,0xc6ef
80004aac:	16 3a       	cp.w	r10,r11
80004aae:	ce 21       	brne	80004a72 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004ab0:	e0 6a 40 1a 	mov	r10,16410
80004ab4:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004ab6:	3f fa       	mov	r10,-1
80004ab8:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004aba:	30 6b       	mov	r11,6
80004abc:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004abe:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004ac0:	48 db       	lddpc	r11,80004af4 <xnl_device_auth_reply_func+0x110>
80004ac2:	96 1c       	ld.sh	r12,r11[0x2]
80004ac4:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004ac6:	96 2b       	ld.sh	r11,r11[0x4]
80004ac8:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004aca:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004acc:	30 ca       	mov	r10,12
80004ace:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004ad0:	30 0a       	mov	r10,0
80004ad2:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004ad6:	30 7a       	mov	r10,7
80004ad8:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004adc:	30 2a       	mov	r10,2
80004ade:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004ae2:	fa ca ff ec 	sub	r10,sp,-20
80004ae6:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004ae8:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004aea:	1a 9c       	mov	r12,sp
80004aec:	f0 1f 00 05 	mcall	80004b00 <xnl_device_auth_reply_func+0x11c>
}
80004af0:	2c 0d       	sub	sp,-256
80004af2:	d8 22       	popm	r4-r7,pc
80004af4:	00 00       	add	r0,r0
80004af6:	0b 38       	ld.ub	r8,r5++
80004af8:	00 00       	add	r0,r0
80004afa:	0b 34       	ld.ub	r4,r5++
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	5b 98       	cp.w	r8,-7
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	48 a0       	lddpc	r0,80004b28 <xnl_master_status_brdcst_func+0x24>

80004b04 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004b04:	eb cd 40 80 	pushm	r7,lr
80004b08:	fa cd 01 00 	sub	sp,sp,256
80004b0c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004b0e:	49 28       	lddpc	r8,80004b54 <xnl_master_status_brdcst_func+0x50>
80004b10:	11 88       	ld.ub	r8,r8[0x0]
80004b12:	58 08       	cp.w	r8,0
80004b14:	c1 c1       	brne	80004b4c <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004b16:	49 18       	lddpc	r8,80004b58 <xnl_master_status_brdcst_func+0x54>
80004b18:	70 0c       	ld.w	r12,r8[0x0]
80004b1a:	30 09       	mov	r9,0
80004b1c:	12 9a       	mov	r10,r9
80004b1e:	12 9b       	mov	r11,r9
80004b20:	f0 1f 00 0f 	mcall	80004b5c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004b24:	8e 58       	ld.sh	r8,r7[0xa]
80004b26:	48 c9       	lddpc	r9,80004b54 <xnl_master_status_brdcst_func+0x50>
80004b28:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b2a:	e0 68 40 0e 	mov	r8,16398
80004b2e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b30:	3f f8       	mov	r8,-1
80004b32:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004b34:	30 4a       	mov	r10,4
80004b36:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004b38:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004b3a:	92 19       	ld.sh	r9,r9[0x2]
80004b3c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004b3e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004b40:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004b42:	30 08       	mov	r8,0
80004b44:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004b46:	1a 9c       	mov	r12,sp
80004b48:	f0 1f 00 06 	mcall	80004b60 <xnl_master_status_brdcst_func+0x5c>
}
80004b4c:	2c 0d       	sub	sp,-256
80004b4e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b52:	00 00       	add	r0,r0
80004b54:	00 00       	add	r0,r0
80004b56:	0b 38       	ld.ub	r8,r5++
80004b58:	00 00       	add	r0,r0
80004b5a:	0b 34       	ld.ub	r4,r5++
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	5b 98       	cp.w	r8,-7
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	48 a0       	lddpc	r0,80004b88 <xnl_device_conn_reply_func+0x24>

80004b64 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004b64:	eb cd 40 80 	pushm	r7,lr
80004b68:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004b6a:	49 28       	lddpc	r8,80004bb0 <xnl_device_conn_reply_func+0x4c>
80004b6c:	70 0c       	ld.w	r12,r8[0x0]
80004b6e:	30 09       	mov	r9,0
80004b70:	12 9a       	mov	r10,r9
80004b72:	12 9b       	mov	r11,r9
80004b74:	f0 1f 00 10 	mcall	80004bb4 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004b78:	ef 18 00 10 	ld.uh	r8,r7[16]
80004b7c:	10 99       	mov	r9,r8
80004b7e:	e2 19 ff 00 	andl	r9,0xff00,COH
80004b82:	e0 49 01 00 	cp.w	r9,256
80004b86:	c0 60       	breq	80004b92 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004b88:	0e 9c       	mov	r12,r7
80004b8a:	f0 1f 00 0c 	mcall	80004bb8 <xnl_device_conn_reply_func+0x54>
80004b8e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004b92:	a9 68       	lsl	r8,0x8
80004b94:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004b98:	48 98       	lddpc	r8,80004bbc <xnl_device_conn_reply_func+0x58>
80004b9a:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004b9c:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004ba0:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004ba2:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004ba6:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004ba8:	30 19       	mov	r9,1
80004baa:	b0 89       	st.b	r8[0x0],r9
80004bac:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bb0:	00 00       	add	r0,r0
80004bb2:	0b 34       	ld.ub	r4,r5++
80004bb4:	80 00       	ld.sh	r0,r0[0x0]
80004bb6:	5b 98       	cp.w	r8,-7
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	4b 04       	lddpc	r4,80004c78 <voc_init+0xc>
80004bbc:	00 00       	add	r0,r0
80004bbe:	0b 38       	ld.ub	r8,r5++

80004bc0 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004bc0:	d4 01       	pushm	lr
80004bc2:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004bc6:	e0 68 40 0e 	mov	r8,16398
80004bca:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004bcc:	3f f8       	mov	r8,-1
80004bce:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004bd0:	30 38       	mov	r8,3
80004bd2:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004bd4:	30 08       	mov	r8,0
80004bd6:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004bd8:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004bda:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004bdc:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004bde:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004be0:	1a 9c       	mov	r12,sp
80004be2:	f0 1f 00 03 	mcall	80004bec <xnl_send_device_master_query+0x2c>
}
80004be6:	2c 0d       	sub	sp,-256
80004be8:	d8 02       	popm	pc
80004bea:	00 00       	add	r0,r0
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	48 a0       	lddpc	r0,80004c14 <local_start_pll0+0x24>

80004bf0 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004bf0:	fe 78 0c 00 	mov	r8,-62464
80004bf4:	e0 69 03 07 	mov	r9,775
80004bf8:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004bfa:	30 49       	mov	r9,4
80004bfc:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004bfe:	71 59       	ld.w	r9,r8[0x54]
80004c00:	e2 19 00 80 	andl	r9,0x80,COH
80004c04:	cf d0       	breq	80004bfe <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004c06:	fe 78 0c 00 	mov	r8,-62464
80004c0a:	30 59       	mov	r9,5
80004c0c:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004c0e:	e0 69 01 0d 	mov	r9,269
80004c12:	ea 19 10 07 	orh	r9,0x1007
80004c16:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004c18:	71 59       	ld.w	r9,r8[0x54]
80004c1a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004c1e:	cf d0       	breq	80004c18 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004c20:	fe 78 0c 00 	mov	r8,-62464
80004c24:	fc 19 00 80 	movh	r9,0x80
80004c28:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004c2a:	34 0a       	mov	r10,64
80004c2c:	fe 69 14 00 	mov	r9,-125952
80004c30:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004c32:	30 69       	mov	r9,6
80004c34:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004c36:	30 19       	mov	r9,1
80004c38:	fe 68 10 00 	mov	r8,-126976
80004c3c:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
80004c3e:	5e fc       	retal	r12

80004c40 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80004c40:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80004c42:	30 3b       	mov	r11,3
80004c44:	48 8c       	lddpc	r12,80004c64 <local_start_timer+0x24>
80004c46:	f0 1f 00 09 	mcall	80004c68 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80004c4a:	fe 78 38 00 	mov	r8,-51200
80004c4e:	e0 69 91 0d 	mov	r9,37133
80004c52:	ea 19 00 52 	orh	r9,0x52
80004c56:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004c58:	32 09       	mov	r9,32
80004c5a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004c5c:	30 59       	mov	r9,5
80004c5e:	91 09       	st.w	r8[0x0],r9
}
80004c60:	d8 02       	popm	pc
80004c62:	00 00       	add	r0,r0
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	cf 80       	breq	80004c56 <local_start_timer+0x16>
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	4e 90       	lddpc	r0,80004e0c <voc_init+0x1a0>

80004c6c <voc_init>:
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
{
80004c6c:	d4 31       	pushm	r0-r7,lr
80004c6e:	21 4d       	sub	sp,80
	data_flash_init();
80004c70:	f0 1f 00 63 	mcall	80004dfc <voc_init+0x190>
{
	df_status_t return_code = DF_OK;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	char str[80];
	memset(str, 0x00, sizeof(str));
80004c74:	30 08       	mov	r8,0
80004c76:	30 09       	mov	r9,0
80004c78:	fa e9 00 00 	st.d	sp[0],r8
80004c7c:	fa e9 00 08 	st.d	sp[8],r8
80004c80:	fa e9 00 10 	st.d	sp[16],r8
80004c84:	fa e9 00 18 	st.d	sp[24],r8
80004c88:	fa e9 00 20 	st.d	sp[32],r8
80004c8c:	fa e9 00 28 	st.d	sp[40],r8
80004c90:	fa e9 00 30 	st.d	sp[48],r8
80004c94:	fa e9 00 38 	st.d	sp[56],r8
80004c98:	fa e9 00 40 	st.d	sp[64],r8
80004c9c:	fa e9 00 48 	st.d	sp[72],r8
80004ca0:	30 05       	mov	r5,0
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80004ca2:	1a 97       	mov	r7,sp
80004ca4:	30 73       	mov	r3,7
80004ca6:	0a 94       	mov	r4,r5
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80004ca8:	4d 62       	lddpc	r2,80004e00 <voc_init+0x194>
			log("\r\n----create voice info okay!----\r\n");
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80004caa:	4d 76       	lddpc	r6,80004e04 <voc_init+0x198>
80004cac:	30 21       	mov	r1,2
80004cae:	30 a0       	mov	r0,10
	memset(str, 0x00, sizeof(str));
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80004cb0:	1a 9a       	mov	r10,sp
80004cb2:	06 9b       	mov	r11,r3
80004cb4:	08 9c       	mov	r12,r4
80004cb6:	f0 1f 00 55 	mcall	80004e08 <voc_init+0x19c>
	if(return_code == DF_OK)
80004cba:	e0 81 00 9f 	brne	80004df8 <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80004cbe:	06 9a       	mov	r10,r3
80004cc0:	1a 9b       	mov	r11,sp
80004cc2:	04 9c       	mov	r12,r2
80004cc4:	f0 1f 00 52 	mcall	80004e0c <voc_init+0x1a0>
80004cc8:	c3 60       	breq	80004d34 <voc_init+0xc8>
80004cca:	c8 78       	rjmp	80004dd8 <voc_init+0x16c>
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
				if(return_code != DF_ERASE_COMPLETED)
				{
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
80004ccc:	fe 35 00 00 	sub	r5,-65536
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80004cd0:	0e 9b       	mov	r11,r7
80004cd2:	0a 9c       	mov	r12,r5
80004cd4:	f0 1f 00 4f 	mcall	80004e10 <voc_init+0x1a4>
				if(return_code != DF_ERASE_COMPLETED)
80004cd8:	58 5c       	cp.w	r12,5
80004cda:	e0 81 00 8f 	brne	80004df8 <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80004cde:	0c 35       	cp.w	r5,r6
80004ce0:	cf 61       	brne	80004ccc <voc_init+0x60>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80004ce2:	30 7a       	mov	r10,7
80004ce4:	30 0b       	mov	r11,0
80004ce6:	4c 7c       	lddpc	r12,80004e00 <voc_init+0x194>
80004ce8:	f0 1f 00 4b 	mcall	80004e14 <voc_init+0x1a8>
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80004cec:	1a 9c       	mov	r12,sp
80004cee:	30 08       	mov	r8,0
80004cf0:	30 09       	mov	r9,0
80004cf2:	fa e9 00 00 	st.d	sp[0],r8
80004cf6:	fa e9 00 08 	st.d	sp[8],r8
80004cfa:	fa e9 00 10 	st.d	sp[16],r8
80004cfe:	fa e9 00 18 	st.d	sp[24],r8
80004d02:	fa e9 00 20 	st.d	sp[32],r8
80004d06:	fa e9 00 28 	st.d	sp[40],r8
80004d0a:	fa e9 00 30 	st.d	sp[48],r8
80004d0e:	fa e9 00 38 	st.d	sp[56],r8
80004d12:	fa e9 00 40 	st.d	sp[64],r8
80004d16:	fa e9 00 48 	st.d	sp[72],r8
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80004d1a:	30 2a       	mov	r10,2
80004d1c:	30 ab       	mov	r11,10
80004d1e:	f0 1f 00 3e 	mcall	80004e14 <voc_init+0x1a8>
			if(return_code != DF_WRITE_COMPLETED)
80004d22:	58 7c       	cp.w	r12,7
80004d24:	c6 a1       	brne	80004df8 <voc_init+0x18c>
			{
				return FALSE;
			}
			current_voice_index = 0;
80004d26:	30 09       	mov	r9,0
80004d28:	4b 78       	lddpc	r8,80004e04 <voc_init+0x198>
80004d2a:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create voice info okay!----\r\n");
80004d2c:	4b bc       	lddpc	r12,80004e18 <voc_init+0x1ac>
80004d2e:	f0 1f 00 3c 	mcall	80004e1c <voc_init+0x1b0>
80004d32:	c5 c8       	rjmp	80004dea <voc_init+0x17e>
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80004d34:	0c 9a       	mov	r10,r6
80004d36:	02 9b       	mov	r11,r1
80004d38:	00 9c       	mov	r12,r0
80004d3a:	f0 1f 00 34 	mcall	80004e08 <voc_init+0x19c>
			if(return_code == DF_OK)
80004d3e:	c5 d1       	brne	80004df8 <voc_init+0x18c>
			{
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80004d40:	8c 08       	ld.sh	r8,r6[0x0]
80004d42:	58 08       	cp.w	r8,0
80004d44:	c5 00       	breq	80004de4 <voc_init+0x178>
					
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80004d46:	5c 78       	castu.h	r8
80004d48:	20 18       	sub	r8,1
80004d4a:	f0 08 00 38 	add	r8,r8,r8<<0x3
80004d4e:	f0 05 15 03 	lsl	r5,r8,0x3
80004d52:	2f 05       	sub	r5,-16
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80004d54:	1a 9a       	mov	r10,sp
80004d56:	34 8b       	mov	r11,72
80004d58:	0a 9c       	mov	r12,r5
80004d5a:	f0 1f 00 2c 	mcall	80004e08 <voc_init+0x19c>
					return_code = data_flash_read_block(LABEL_ADDRESS, 512, (U8 *)TEMP_BUF);
80004d5e:	4b 1a       	lddpc	r10,80004e20 <voc_init+0x1b4>
80004d60:	e0 6b 02 00 	mov	r11,512
80004d64:	08 9c       	mov	r12,r4
80004d66:	f0 1f 00 29 	mcall	80004e08 <voc_init+0x19c>
					if(return_code == DF_OK)
80004d6a:	c3 d1       	brne	80004de4 <voc_init+0x178>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
						if(ptr->numb == current_voice_index)
80004d6c:	0f 89       	ld.ub	r9,r7[0x0]
80004d6e:	0f 98       	ld.ub	r8,r7[0x1]
80004d70:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004d74:	8c 09       	ld.sh	r9,r6[0x0]
80004d76:	f0 09 19 00 	cp.h	r9,r8
80004d7a:	c2 c1       	brne	80004dd2 <voc_init+0x166>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
80004d7c:	ef 39 00 46 	ld.ub	r9,r7[70]
80004d80:	ef 38 00 47 	ld.ub	r8,r7[71]
80004d84:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80004d88:	ef 3a 00 42 	ld.ub	r10,r7[66]
80004d8c:	ef 38 00 43 	ld.ub	r8,r7[67]
80004d90:	b1 68       	lsl	r8,0x10
80004d92:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80004d96:	ef 3a 00 44 	ld.ub	r10,r7[68]
80004d9a:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004d9e:	ef 3a 00 45 	ld.ub	r10,r7[69]
80004da2:	f5 e8 10 08 	or	r8,r10,r8
80004da6:	f2 08 00 08 	add	r8,r9,r8
80004daa:	49 f9       	lddpc	r9,80004e24 <voc_init+0x1b8>
80004dac:	93 08       	st.w	r9[0x0],r8
							if(current_save_voice_offset > 0x7bc000){
80004dae:	e0 69 c0 00 	mov	r9,49152
80004db2:	ea 19 00 7b 	orh	r9,0x7b
80004db6:	12 38       	cp.w	r8,r9
80004db8:	e0 88 00 16 	brls	80004de4 <voc_init+0x178>
								
								log("\r\n----voice storage is full!!!----\r\n");
80004dbc:	49 bc       	lddpc	r12,80004e28 <voc_init+0x1bc>
80004dbe:	f0 1f 00 18 	mcall	80004e1c <voc_init+0x1b0>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80004dc2:	30 4b       	mov	r11,4
80004dc4:	08 9c       	mov	r12,r4
80004dc6:	f0 1f 00 13 	mcall	80004e10 <voc_init+0x1a4>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80004dca:	58 5c       	cp.w	r12,5
80004dcc:	fe 90 ff 72 	breq	80004cb0 <voc_init+0x44>
80004dd0:	c1 48       	rjmp	80004df8 <voc_init+0x18c>
								return FALSE;
							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
80004dd2:	49 7c       	lddpc	r12,80004e2c <voc_init+0x1c0>
80004dd4:	f0 1f 00 12 	mcall	80004e1c <voc_init+0x1b0>
	
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
80004dd8:	e6 78 00 00 	mov	r8,458752
80004ddc:	ea 08 00 06 	add	r6,r5,r8
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80004de0:	30 37       	mov	r7,3
80004de2:	c7 7b       	rjmp	80004cd0 <voc_init+0x64>
							goto ERASE;
							//return FALSE;
						}
					}
				}
				log("\r\n----read voice info okay!----\r\n");
80004de4:	49 3c       	lddpc	r12,80004e30 <voc_init+0x1c4>
80004de6:	f0 1f 00 0e 	mcall	80004e1c <voc_init+0x1b0>
			}
			else
			return FALSE;
		}
		
		memcpy(voice_count_ptr, &current_voice_index, sizeof(current_voice_index));
80004dea:	48 78       	lddpc	r8,80004e04 <voc_init+0x198>
80004dec:	90 09       	ld.sh	r9,r8[0x0]
80004dee:	49 28       	lddpc	r8,80004e34 <voc_init+0x1c8>
80004df0:	b0 09       	st.h	r8[0x0],r9
		list_init_success_flag = 1;
80004df2:	30 19       	mov	r9,1
80004df4:	49 18       	lddpc	r8,80004e38 <voc_init+0x1cc>
80004df6:	b0 89       	st.b	r8[0x0],r9
	//create_data_flash_test_task();
	voice_list_info_init(Current_total_voice);
	
	//voc_read_write_test();

80004df8:	2e cd       	sub	sp,-80
80004dfa:	d8 32       	popm	r0-r7,pc
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	2d b0       	sub	r0,-37
80004e00:	00 00       	add	r0,r0
80004e02:	05 24       	ld.uh	r4,r2++
80004e04:	00 00       	add	r0,r0
80004e06:	0b 5c       	ld.sh	r12,--r5
80004e08:	80 00       	ld.sh	r0,r0[0x0]
80004e0a:	2a 90       	sub	r0,-87
80004e0c:	80 00       	ld.sh	r0,r0[0x0]
80004e0e:	6f f0       	ld.w	r0,r7[0x7c]
80004e10:	80 00       	ld.sh	r0,r0[0x0]
80004e12:	2c 24       	sub	r4,-62
80004e14:	80 00       	ld.sh	r0,r0[0x0]
80004e16:	2c c0       	sub	r0,-52
80004e18:	80 00       	ld.sh	r0,r0[0x0]
80004e1a:	cf 98       	rjmp	8000500c <getBaudDiv+0x8>
80004e1c:	80 00       	ld.sh	r0,r0[0x0]
80004e1e:	67 78       	ld.w	r8,r3[0x5c]
80004e20:	00 00       	add	r0,r0
80004e22:	51 00       	stdsp	sp[0x40],r0
80004e24:	00 00       	add	r0,r0
80004e26:	05 2c       	ld.uh	r12,r2++
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	cf bc       	rcall	80005020 <getBaudDiv+0x1c>
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	cf e4       	brge	80004e2a <voc_init+0x1be>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	d0 08       	*unknown*
80004e34:	00 00       	add	r0,r0
80004e36:	0b 60       	ld.uh	r0,--r5
80004e38:	00 00       	add	r0,r0
80004e3a:	0b 5e       	ld.sh	lr,--r5

80004e3c <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004e3c:	f8 08 16 05 	lsr	r8,r12,0x5
80004e40:	a9 68       	lsl	r8,0x8
80004e42:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80004e46:	58 1b       	cp.w	r11,1
80004e48:	c0 d0       	breq	80004e62 <gpio_enable_module_pin+0x26>
80004e4a:	c0 63       	brcs	80004e56 <gpio_enable_module_pin+0x1a>
80004e4c:	58 2b       	cp.w	r11,2
80004e4e:	c1 00       	breq	80004e6e <gpio_enable_module_pin+0x32>
80004e50:	58 3b       	cp.w	r11,3
80004e52:	c1 40       	breq	80004e7a <gpio_enable_module_pin+0x3e>
80004e54:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004e56:	30 19       	mov	r9,1
80004e58:	f2 0c 09 49 	lsl	r9,r9,r12
80004e5c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004e5e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004e60:	c1 28       	rjmp	80004e84 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004e62:	30 19       	mov	r9,1
80004e64:	f2 0c 09 49 	lsl	r9,r9,r12
80004e68:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004e6a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004e6c:	c0 c8       	rjmp	80004e84 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004e6e:	30 19       	mov	r9,1
80004e70:	f2 0c 09 49 	lsl	r9,r9,r12
80004e74:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004e76:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004e78:	c0 68       	rjmp	80004e84 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004e7a:	30 19       	mov	r9,1
80004e7c:	f2 0c 09 49 	lsl	r9,r9,r12
80004e80:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004e82:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004e84:	30 19       	mov	r9,1
80004e86:	f2 0c 09 4c 	lsl	r12,r9,r12
80004e8a:	91 2c       	st.w	r8[0x8],r12
80004e8c:	5e fd       	retal	0
80004e8e:	d7 03       	nop

80004e90 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004e90:	d4 21       	pushm	r4-r7,lr
80004e92:	18 97       	mov	r7,r12
80004e94:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004e96:	58 0b       	cp.w	r11,0
80004e98:	c0 31       	brne	80004e9e <gpio_enable_module+0xe>
80004e9a:	30 05       	mov	r5,0
80004e9c:	c0 d8       	rjmp	80004eb6 <gpio_enable_module+0x26>
80004e9e:	30 06       	mov	r6,0
80004ea0:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80004ea2:	6e 1b       	ld.w	r11,r7[0x4]
80004ea4:	6e 0c       	ld.w	r12,r7[0x0]
80004ea6:	f0 1f 00 06 	mcall	80004ebc <gpio_enable_module+0x2c>
80004eaa:	18 45       	or	r5,r12
		gpiomap++;
80004eac:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004eae:	2f f6       	sub	r6,-1
80004eb0:	0c 34       	cp.w	r4,r6
80004eb2:	fe 9b ff f8 	brhi	80004ea2 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004eb6:	0a 9c       	mov	r12,r5
80004eb8:	d8 22       	popm	r4-r7,pc
80004eba:	00 00       	add	r0,r0
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	4e 3c       	lddpc	r12,80005048 <spi_initMaster+0x24>

80004ec0 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004ec0:	f8 08 16 05 	lsr	r8,r12,0x5
80004ec4:	a9 68       	lsl	r8,0x8
80004ec6:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80004eca:	30 19       	mov	r9,1
80004ecc:	f2 0c 09 4c 	lsl	r12,r9,r12
80004ed0:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80004ed4:	91 1c       	st.w	r8[0x4],r12
}
80004ed6:	5e fc       	retal	r12

80004ed8 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004ed8:	f8 08 16 05 	lsr	r8,r12,0x5
80004edc:	a9 68       	lsl	r8,0x8
80004ede:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80004ee2:	30 19       	mov	r9,1
80004ee4:	f2 0c 09 4c 	lsl	r12,r9,r12
80004ee8:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004eec:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004ef0:	91 1c       	st.w	r8[0x4],r12
}
80004ef2:	5e fc       	retal	r12

80004ef4 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004ef4:	c0 08       	rjmp	80004ef4 <_unhandled_interrupt>
80004ef6:	d7 03       	nop

80004ef8 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004ef8:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004efc:	49 99       	lddpc	r9,80004f60 <INTC_register_interrupt+0x68>
80004efe:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004f02:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004f06:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004f08:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004f0c:	58 0a       	cp.w	r10,0
80004f0e:	c0 91       	brne	80004f20 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004f10:	49 59       	lddpc	r9,80004f64 <INTC_register_interrupt+0x6c>
80004f12:	49 6a       	lddpc	r10,80004f68 <INTC_register_interrupt+0x70>
80004f14:	12 1a       	sub	r10,r9
80004f16:	fe 79 08 00 	mov	r9,-63488
80004f1a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004f1e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004f20:	58 1a       	cp.w	r10,1
80004f22:	c0 a1       	brne	80004f36 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004f24:	49 09       	lddpc	r9,80004f64 <INTC_register_interrupt+0x6c>
80004f26:	49 2a       	lddpc	r10,80004f6c <INTC_register_interrupt+0x74>
80004f28:	12 1a       	sub	r10,r9
80004f2a:	bf aa       	sbr	r10,0x1e
80004f2c:	fe 79 08 00 	mov	r9,-63488
80004f30:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004f34:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004f36:	58 2a       	cp.w	r10,2
80004f38:	c0 a1       	brne	80004f4c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004f3a:	48 b9       	lddpc	r9,80004f64 <INTC_register_interrupt+0x6c>
80004f3c:	48 da       	lddpc	r10,80004f70 <INTC_register_interrupt+0x78>
80004f3e:	12 1a       	sub	r10,r9
80004f40:	bf ba       	sbr	r10,0x1f
80004f42:	fe 79 08 00 	mov	r9,-63488
80004f46:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004f4a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004f4c:	48 69       	lddpc	r9,80004f64 <INTC_register_interrupt+0x6c>
80004f4e:	48 aa       	lddpc	r10,80004f74 <INTC_register_interrupt+0x7c>
80004f50:	12 1a       	sub	r10,r9
80004f52:	ea 1a c0 00 	orh	r10,0xc000
80004f56:	fe 79 08 00 	mov	r9,-63488
80004f5a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004f5e:	5e fc       	retal	r12
80004f60:	80 00       	ld.sh	r0,r0[0x0]
80004f62:	d0 2c       	*unknown*
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	c6 00       	breq	80005026 <spi_initMaster+0x2>
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	c7 04       	brge	8000504a <spi_initMaster+0x26>
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	c7 12       	brcc	80005050 <spi_initMaster+0x2c>
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	c7 20       	breq	80005056 <spi_initMaster+0x32>
80004f74:	80 00       	ld.sh	r0,r0[0x0]
80004f76:	c7 2e       	rcall	80004c5a <local_start_timer+0x1a>

80004f78 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004f78:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004f7a:	49 18       	lddpc	r8,80004fbc <INTC_init_interrupts+0x44>
80004f7c:	e3 b8 00 01 	mtsr	0x4,r8
80004f80:	49 0e       	lddpc	lr,80004fc0 <INTC_init_interrupts+0x48>
80004f82:	30 07       	mov	r7,0
80004f84:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004f86:	49 0c       	lddpc	r12,80004fc4 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004f88:	49 05       	lddpc	r5,80004fc8 <INTC_init_interrupts+0x50>
80004f8a:	10 15       	sub	r5,r8
80004f8c:	fe 76 08 00 	mov	r6,-63488
80004f90:	c1 08       	rjmp	80004fb0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004f92:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004f94:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004f96:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004f98:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004f9c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004f9e:	10 3a       	cp.w	r10,r8
80004fa0:	fe 9b ff fc 	brhi	80004f98 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004fa4:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004fa8:	2f f7       	sub	r7,-1
80004faa:	2f 8e       	sub	lr,-8
80004fac:	59 37       	cp.w	r7,19
80004fae:	c0 50       	breq	80004fb8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004fb0:	7c 08       	ld.w	r8,lr[0x0]
80004fb2:	58 08       	cp.w	r8,0
80004fb4:	ce f1       	brne	80004f92 <INTC_init_interrupts+0x1a>
80004fb6:	cf 7b       	rjmp	80004fa4 <INTC_init_interrupts+0x2c>
80004fb8:	d8 22       	popm	r4-r7,pc
80004fba:	00 00       	add	r0,r0
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	c6 00       	breq	8000507e <spi_selectionMode+0x22>
80004fc0:	80 00       	ld.sh	r0,r0[0x0]
80004fc2:	d0 2c       	*unknown*
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	4e f4       	lddpc	r4,80005180 <spi_setupChipReg+0xb4>
80004fc8:	80 00       	ld.sh	r0,r0[0x0]
80004fca:	c7 04       	brge	800050aa <spi_read>

80004fcc <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004fcc:	fe 78 08 00 	mov	r8,-63488
80004fd0:	e0 69 00 83 	mov	r9,131
80004fd4:	f2 0c 01 0c 	sub	r12,r9,r12
80004fd8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004fdc:	f2 ca ff c0 	sub	r10,r9,-64
80004fe0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004fe4:	58 08       	cp.w	r8,0
80004fe6:	c0 21       	brne	80004fea <_get_interrupt_handler+0x1e>
80004fe8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004fea:	f0 08 12 00 	clz	r8,r8
80004fee:	48 5a       	lddpc	r10,80005000 <_get_interrupt_handler+0x34>
80004ff0:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004ff4:	f0 08 11 1f 	rsub	r8,r8,31
80004ff8:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004ffa:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004ffe:	5e fc       	retal	r12
80005000:	80 00       	ld.sh	r0,r0[0x0]
80005002:	d0 2c       	*unknown*

80005004 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005004:	f8 c8 00 01 	sub	r8,r12,1
80005008:	f0 0b 00 0b 	add	r11,r8,r11
8000500c:	f6 0c 0d 0a 	divu	r10,r11,r12
80005010:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005012:	f4 c8 00 01 	sub	r8,r10,1
80005016:	e0 48 00 fe 	cp.w	r8,254
8000501a:	e0 88 00 03 	brls	80005020 <getBaudDiv+0x1c>
8000501e:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005020:	5c 8c       	casts.h	r12
}
80005022:	5e fc       	retal	r12

80005024 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005024:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005028:	30 18       	mov	r8,1
8000502a:	f0 09 18 00 	cp.b	r9,r8
8000502e:	e0 88 00 04 	brls	80005036 <spi_initMaster+0x12>
80005032:	30 2c       	mov	r12,2
80005034:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005036:	e0 68 00 80 	mov	r8,128
8000503a:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
8000503c:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
8000503e:	30 19       	mov	r9,1
80005040:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005044:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005048:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
8000504c:	30 09       	mov	r9,0
8000504e:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005052:	30 fa       	mov	r10,15
80005054:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005058:	99 18       	st.w	r12[0x4],r8
8000505a:	5e f9       	retal	r9

8000505c <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
8000505c:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000505e:	30 18       	mov	r8,1
80005060:	f0 0b 18 00 	cp.b	r11,r8
80005064:	5f be       	srhi	lr
80005066:	f0 0a 18 00 	cp.b	r10,r8
8000506a:	5f b8       	srhi	r8
8000506c:	fd e8 10 08 	or	r8,lr,r8
80005070:	c0 30       	breq	80005076 <spi_selectionMode+0x1a>
80005072:	30 2c       	mov	r12,2
80005074:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005076:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005078:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000507c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005080:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005084:	99 18       	st.w	r12[0x4],r8
80005086:	d8 0a       	popm	pc,r12=0

80005088 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005088:	30 18       	mov	r8,1
8000508a:	99 08       	st.w	r12[0x0],r8
}
8000508c:	5e fc       	retal	r12

8000508e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000508e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005092:	c0 58       	rjmp	8000509c <spi_write+0xe>
		if (!timeout--) {
80005094:	58 08       	cp.w	r8,0
80005096:	c0 21       	brne	8000509a <spi_write+0xc>
80005098:	5e ff       	retal	1
8000509a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000509c:	78 49       	ld.w	r9,r12[0x10]
8000509e:	e2 19 00 02 	andl	r9,0x2,COH
800050a2:	cf 90       	breq	80005094 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800050a4:	5c 7b       	castu.h	r11
800050a6:	99 3b       	st.w	r12[0xc],r11
800050a8:	5e fd       	retal	0

800050aa <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800050aa:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800050ae:	c0 58       	rjmp	800050b8 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800050b0:	58 08       	cp.w	r8,0
800050b2:	c0 21       	brne	800050b6 <spi_read+0xc>
800050b4:	5e ff       	retal	1
800050b6:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800050b8:	78 49       	ld.w	r9,r12[0x10]
800050ba:	e2 19 02 01 	andl	r9,0x201,COH
800050be:	e0 49 02 01 	cp.w	r9,513
800050c2:	cf 71       	brne	800050b0 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800050c4:	78 28       	ld.w	r8,r12[0x8]
800050c6:	b6 08       	st.h	r11[0x0],r8
800050c8:	5e fd       	retal	0
800050ca:	d7 03       	nop

800050cc <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800050cc:	eb cd 40 f8 	pushm	r3-r7,lr
800050d0:	18 95       	mov	r5,r12
800050d2:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800050d4:	f7 36 00 0c 	ld.ub	r6,r11[12]
800050d8:	30 38       	mov	r8,3
800050da:	f0 06 18 00 	cp.b	r6,r8
800050de:	e0 8b 00 5e 	brhi	8000519a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800050e2:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800050e6:	30 18       	mov	r8,1
800050e8:	f0 04 18 00 	cp.b	r4,r8
800050ec:	e0 8b 00 57 	brhi	8000519a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800050f0:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800050f4:	30 78       	mov	r8,7
800050f6:	f0 03 18 00 	cp.b	r3,r8
800050fa:	e0 88 00 50 	brls	8000519a <spi_setupChipReg+0xce>
800050fe:	31 08       	mov	r8,16
80005100:	f0 03 18 00 	cp.b	r3,r8
80005104:	e0 8b 00 4b 	brhi	8000519a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005108:	14 9b       	mov	r11,r10
8000510a:	6e 1c       	ld.w	r12,r7[0x4]
8000510c:	f0 1f 00 26 	mcall	800051a4 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005110:	c4 55       	brlt	8000519a <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005112:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005114:	ec 09 16 01 	lsr	r9,r6,0x1
80005118:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
8000511c:	ec 16 00 01 	eorl	r6,0x1
80005120:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005124:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005128:	20 83       	sub	r3,8
8000512a:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000512e:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005132:	ef 39 00 09 	ld.ub	r9,r7[9]
80005136:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000513a:	ef 39 00 0a 	ld.ub	r9,r7[10]
8000513e:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005142:	0f 89       	ld.ub	r9,r7[0x0]
80005144:	30 1a       	mov	r10,1
80005146:	f4 09 18 00 	cp.b	r9,r10
8000514a:	c0 d0       	breq	80005164 <spi_setupChipReg+0x98>
8000514c:	c0 a3       	brcs	80005160 <spi_setupChipReg+0x94>
8000514e:	30 2a       	mov	r10,2
80005150:	f4 09 18 00 	cp.b	r9,r10
80005154:	c0 a0       	breq	80005168 <spi_setupChipReg+0x9c>
80005156:	30 3a       	mov	r10,3
80005158:	f4 09 18 00 	cp.b	r9,r10
8000515c:	c1 f1       	brne	8000519a <spi_setupChipReg+0xce>
8000515e:	c0 78       	rjmp	8000516c <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005160:	8b c8       	st.w	r5[0x30],r8
		break;
80005162:	c0 68       	rjmp	8000516e <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005164:	8b d8       	st.w	r5[0x34],r8
		break;
80005166:	c0 48       	rjmp	8000516e <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005168:	8b e8       	st.w	r5[0x38],r8
		break;
8000516a:	c0 28       	rjmp	8000516e <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
8000516c:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000516e:	48 f8       	lddpc	r8,800051a8 <spi_setupChipReg+0xdc>
80005170:	70 08       	ld.w	r8,r8[0x0]
80005172:	58 08       	cp.w	r8,0
80005174:	c1 61       	brne	800051a0 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005176:	30 0b       	mov	r11,0
80005178:	30 1c       	mov	r12,1
8000517a:	f0 1f 00 0d 	mcall	800051ac <spi_setupChipReg+0xe0>
8000517e:	48 b8       	lddpc	r8,800051a8 <spi_setupChipReg+0xdc>
80005180:	91 0c       	st.w	r8[0x0],r12
80005182:	58 0c       	cp.w	r12,0
80005184:	c0 a0       	breq	80005198 <spi_setupChipReg+0xcc>
80005186:	30 09       	mov	r9,0
80005188:	12 9a       	mov	r10,r9
8000518a:	12 9b       	mov	r11,r9
8000518c:	f0 1f 00 09 	mcall	800051b0 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005190:	48 68       	lddpc	r8,800051a8 <spi_setupChipReg+0xdc>
80005192:	70 08       	ld.w	r8,r8[0x0]
80005194:	58 08       	cp.w	r8,0
80005196:	c0 51       	brne	800051a0 <spi_setupChipReg+0xd4>
80005198:	c0 08       	rjmp	80005198 <spi_setupChipReg+0xcc>
8000519a:	30 2c       	mov	r12,2
8000519c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800051a0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	50 04       	stdsp	sp[0x0],r4
800051a8:	00 00       	add	r0,r0
800051aa:	63 90       	ld.w	r0,r1[0x64]
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	5c 98       	brev	r8
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	5b 98       	cp.w	r8,-7

800051b4 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800051b4:	d4 01       	pushm	lr
800051b6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800051ba:	c0 58       	rjmp	800051c4 <spi_unselectChip+0x10>
		if (!timeout--) {
800051bc:	58 08       	cp.w	r8,0
800051be:	c0 21       	brne	800051c2 <spi_unselectChip+0xe>
800051c0:	da 0a       	popm	pc,r12=1
800051c2:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800051c4:	78 49       	ld.w	r9,r12[0x10]
800051c6:	e2 19 02 00 	andl	r9,0x200,COH
800051ca:	cf 90       	breq	800051bc <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800051cc:	78 18       	ld.w	r8,r12[0x4]
800051ce:	ea 18 00 0f 	orh	r8,0xf
800051d2:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800051d4:	fc 18 01 00 	movh	r8,0x100
800051d8:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800051da:	30 09       	mov	r9,0
800051dc:	12 9a       	mov	r10,r9
800051de:	12 9b       	mov	r11,r9
800051e0:	48 38       	lddpc	r8,800051ec <spi_unselectChip+0x38>
800051e2:	70 0c       	ld.w	r12,r8[0x0]
800051e4:	f0 1f 00 03 	mcall	800051f0 <spi_unselectChip+0x3c>
800051e8:	d8 0a       	popm	pc,r12=0
800051ea:	00 00       	add	r0,r0
800051ec:	00 00       	add	r0,r0
800051ee:	63 90       	ld.w	r0,r1[0x64]
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	5b 98       	cp.w	r8,-7

800051f4 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800051f4:	eb cd 40 f8 	pushm	r3-r7,lr
800051f8:	18 94       	mov	r4,r12
800051fa:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800051fc:	49 a6       	lddpc	r6,80005264 <spi_selectChip+0x70>
800051fe:	30 07       	mov	r7,0
80005200:	31 45       	mov	r5,20
80005202:	0e 99       	mov	r9,r7
80005204:	0a 9a       	mov	r10,r5
80005206:	0e 9b       	mov	r11,r7
80005208:	6c 0c       	ld.w	r12,r6[0x0]
8000520a:	f0 1f 00 18 	mcall	80005268 <spi_selectChip+0x74>
8000520e:	cf a0       	breq	80005202 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005210:	68 18       	ld.w	r8,r4[0x4]
80005212:	ea 18 00 0f 	orh	r8,0xf
80005216:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005218:	68 18       	ld.w	r8,r4[0x4]
8000521a:	e2 18 00 04 	andl	r8,0x4,COH
8000521e:	c1 10       	breq	80005240 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005220:	30 e8       	mov	r8,14
80005222:	f0 03 18 00 	cp.b	r3,r8
80005226:	e0 8b 00 1c 	brhi	8000525e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000522a:	68 19       	ld.w	r9,r4[0x4]
8000522c:	e6 08 15 10 	lsl	r8,r3,0x10
80005230:	ea 18 ff f0 	orh	r8,0xfff0
80005234:	e8 18 ff ff 	orl	r8,0xffff
80005238:	12 68       	and	r8,r9
8000523a:	89 18       	st.w	r4[0x4],r8
8000523c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005240:	30 38       	mov	r8,3
80005242:	f0 03 18 00 	cp.b	r3,r8
80005246:	e0 8b 00 0c 	brhi	8000525e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000524a:	68 19       	ld.w	r9,r4[0x4]
8000524c:	2f 03       	sub	r3,-16
8000524e:	30 18       	mov	r8,1
80005250:	f0 03 09 48 	lsl	r8,r8,r3
80005254:	5c d8       	com	r8
80005256:	12 68       	and	r8,r9
80005258:	89 18       	st.w	r4[0x4],r8
8000525a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000525e:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005260:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005264:	00 00       	add	r0,r0
80005266:	63 90       	ld.w	r0,r1[0x64]
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	59 8c       	cp.w	r12,24

8000526c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000526c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000526e:	f6 08 15 04 	lsl	r8,r11,0x4
80005272:	14 38       	cp.w	r8,r10
80005274:	f9 b8 08 10 	movls	r8,16
80005278:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000527c:	f0 0b 02 4b 	mul	r11,r8,r11
80005280:	f6 09 16 01 	lsr	r9,r11,0x1
80005284:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005288:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000528c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005290:	f2 cb 00 01 	sub	r11,r9,1
80005294:	e0 4b ff fe 	cp.w	r11,65534
80005298:	e0 88 00 03 	brls	8000529e <usart_set_async_baudrate+0x32>
8000529c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000529e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800052a0:	e8 6e 00 00 	mov	lr,524288
800052a4:	59 08       	cp.w	r8,16
800052a6:	fc 08 17 10 	movne	r8,lr
800052aa:	f9 b8 00 00 	moveq	r8,0
800052ae:	e4 1b ff f7 	andh	r11,0xfff7
800052b2:	e0 1b fe cf 	andl	r11,0xfecf
800052b6:	16 48       	or	r8,r11
800052b8:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800052ba:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800052be:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800052c2:	99 89       	st.w	r12[0x20],r9
800052c4:	d8 0a       	popm	pc,r12=0

800052c6 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800052c6:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800052c8:	e2 18 00 02 	andl	r8,0x2,COH
800052cc:	c0 31       	brne	800052d2 <usart_write_char+0xc>
800052ce:	30 2c       	mov	r12,2
800052d0:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800052d2:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800052d6:	99 7b       	st.w	r12[0x1c],r11
800052d8:	5e fd       	retal	0
800052da:	d7 03       	nop

800052dc <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800052dc:	eb cd 40 e0 	pushm	r5-r7,lr
800052e0:	18 96       	mov	r6,r12
800052e2:	16 95       	mov	r5,r11
800052e4:	e0 67 27 0f 	mov	r7,9999
800052e8:	c0 68       	rjmp	800052f4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800052ea:	58 07       	cp.w	r7,0
800052ec:	c0 31       	brne	800052f2 <usart_putchar+0x16>
800052ee:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800052f2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800052f4:	0a 9b       	mov	r11,r5
800052f6:	0c 9c       	mov	r12,r6
800052f8:	f0 1f 00 03 	mcall	80005304 <usart_putchar+0x28>
800052fc:	cf 71       	brne	800052ea <usart_putchar+0xe>

  return USART_SUCCESS;
}
800052fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005302:	00 00       	add	r0,r0
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	52 c6       	stdsp	sp[0xb0],r6

80005308 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005308:	78 58       	ld.w	r8,r12[0x14]
8000530a:	e2 18 00 e0 	andl	r8,0xe0,COH
8000530e:	c0 30       	breq	80005314 <usart_read_char+0xc>
80005310:	30 4c       	mov	r12,4
80005312:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005314:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005316:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000531a:	c0 31       	brne	80005320 <usart_read_char+0x18>
8000531c:	30 3c       	mov	r12,3
8000531e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005320:	78 68       	ld.w	r8,r12[0x18]
80005322:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005326:	97 08       	st.w	r11[0x0],r8
80005328:	5e fd       	retal	0
8000532a:	d7 03       	nop

8000532c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
8000532c:	eb cd 40 c0 	pushm	r6-r7,lr
80005330:	20 1d       	sub	sp,4
80005332:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005334:	1a 97       	mov	r7,sp
80005336:	1a 9b       	mov	r11,sp
80005338:	0c 9c       	mov	r12,r6
8000533a:	f0 1f 00 07 	mcall	80005354 <usart_getchar+0x28>
8000533e:	58 3c       	cp.w	r12,3
80005340:	cf b0       	breq	80005336 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005342:	58 4c       	cp.w	r12,4
80005344:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005348:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
8000534c:	2f fd       	sub	sp,-4
8000534e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005352:	00 00       	add	r0,r0
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	53 08       	stdsp	sp[0xc0],r8

80005358 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005358:	eb cd 40 c0 	pushm	r6-r7,lr
8000535c:	18 96       	mov	r6,r12
8000535e:	16 97       	mov	r7,r11
  while (*string != '\0')
80005360:	17 8b       	ld.ub	r11,r11[0x0]
80005362:	58 0b       	cp.w	r11,0
80005364:	c0 80       	breq	80005374 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005366:	2f f7       	sub	r7,-1
80005368:	0c 9c       	mov	r12,r6
8000536a:	f0 1f 00 04 	mcall	80005378 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000536e:	0f 8b       	ld.ub	r11,r7[0x0]
80005370:	58 0b       	cp.w	r11,0
80005372:	cf a1       	brne	80005366 <usart_write_line+0xe>
80005374:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	52 dc       	stdsp	sp[0xb4],r12

8000537c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000537c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005380:	e6 18 00 01 	andh	r8,0x1,COH
80005384:	c0 71       	brne	80005392 <usart_reset+0x16>
80005386:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005388:	3f f8       	mov	r8,-1
8000538a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000538c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000538e:	d5 03       	csrf	0x10
80005390:	c0 48       	rjmp	80005398 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005392:	3f f8       	mov	r8,-1
80005394:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005396:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005398:	30 08       	mov	r8,0
8000539a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
8000539c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000539e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800053a0:	ea 68 61 0c 	mov	r8,680204
800053a4:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800053a6:	5e fc       	retal	r12

800053a8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800053a8:	eb cd 40 e0 	pushm	r5-r7,lr
800053ac:	18 96       	mov	r6,r12
800053ae:	16 97       	mov	r7,r11
800053b0:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800053b2:	f0 1f 00 2f 	mcall	8000546c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800053b6:	58 07       	cp.w	r7,0
800053b8:	c5 80       	breq	80005468 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800053ba:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800053bc:	30 49       	mov	r9,4
800053be:	f2 08 18 00 	cp.b	r8,r9
800053c2:	e0 88 00 53 	brls	80005468 <usart_init_rs232+0xc0>
800053c6:	30 99       	mov	r9,9
800053c8:	f2 08 18 00 	cp.b	r8,r9
800053cc:	e0 8b 00 4e 	brhi	80005468 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800053d0:	0f d9       	ld.ub	r9,r7[0x5]
800053d2:	30 78       	mov	r8,7
800053d4:	f0 09 18 00 	cp.b	r9,r8
800053d8:	e0 8b 00 48 	brhi	80005468 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800053dc:	8e 39       	ld.sh	r9,r7[0x6]
800053de:	e0 68 01 01 	mov	r8,257
800053e2:	f0 09 19 00 	cp.h	r9,r8
800053e6:	e0 8b 00 41 	brhi	80005468 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800053ea:	ef 39 00 08 	ld.ub	r9,r7[8]
800053ee:	30 38       	mov	r8,3
800053f0:	f0 09 18 00 	cp.b	r9,r8
800053f4:	e0 8b 00 3a 	brhi	80005468 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800053f8:	0a 9a       	mov	r10,r5
800053fa:	6e 0b       	ld.w	r11,r7[0x0]
800053fc:	0c 9c       	mov	r12,r6
800053fe:	f0 1f 00 1d 	mcall	80005470 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005402:	58 1c       	cp.w	r12,1
80005404:	c3 20       	breq	80005468 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005406:	0f c8       	ld.ub	r8,r7[0x4]
80005408:	30 99       	mov	r9,9
8000540a:	f2 08 18 00 	cp.b	r8,r9
8000540e:	c0 51       	brne	80005418 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005410:	6c 18       	ld.w	r8,r6[0x4]
80005412:	b1 b8       	sbr	r8,0x11
80005414:	8d 18       	st.w	r6[0x4],r8
80005416:	c0 68       	rjmp	80005422 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005418:	6c 19       	ld.w	r9,r6[0x4]
8000541a:	20 58       	sub	r8,5
8000541c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005420:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005422:	6c 19       	ld.w	r9,r6[0x4]
80005424:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005428:	0f d8       	ld.ub	r8,r7[0x5]
8000542a:	a9 78       	lsl	r8,0x9
8000542c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005430:	12 48       	or	r8,r9
80005432:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005434:	8e 38       	ld.sh	r8,r7[0x6]
80005436:	30 29       	mov	r9,2
80005438:	f2 08 19 00 	cp.h	r8,r9
8000543c:	e0 88 00 09 	brls	8000544e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005440:	6c 18       	ld.w	r8,r6[0x4]
80005442:	ad b8       	sbr	r8,0xd
80005444:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005446:	8e b8       	ld.uh	r8,r7[0x6]
80005448:	20 28       	sub	r8,2
8000544a:	8d a8       	st.w	r6[0x28],r8
8000544c:	c0 68       	rjmp	80005458 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000544e:	6c 19       	ld.w	r9,r6[0x4]
80005450:	5c 78       	castu.h	r8
80005452:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005456:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005458:	6c 18       	ld.w	r8,r6[0x4]
8000545a:	e0 18 ff f0 	andl	r8,0xfff0
8000545e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005460:	35 08       	mov	r8,80
80005462:	8d 08       	st.w	r6[0x0],r8
80005464:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005468:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	53 7c       	stdsp	sp[0xdc],r12
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	52 6c       	stdsp	sp[0x98],r12

80005474 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005474:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005478:	fe c0 8e 78 	sub	r0,pc,-29064

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000547c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005480:	d5 53       	csrf	0x15
  cp      r0, r1
80005482:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005484:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005488:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000548a:	c0 62       	brcc	80005496 <idata_load_loop_end>
  cp      r0, r1
8000548c:	48 92       	lddpc	r2,800054b0 <udata_clear_loop_end+0x4>

8000548e <idata_load_loop>:
  brlo    idata_load_loop
8000548e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005490:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005492:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005494:	cf d3       	brcs	8000548e <idata_load_loop>

80005496 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005496:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000549a:	e0 61 63 a0 	mov	r1,25504
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000549e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
800054a0:	c0 62       	brcc	800054ac <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800054a2:	30 02       	mov	r2,0
800054a4:	30 03       	mov	r3,0

800054a6 <udata_clear_loop>:
800054a6:	a1 22       	st.d	r0++,r2
800054a8:	02 30       	cp.w	r0,r1
800054aa:	cf e3       	brcs	800054a6 <udata_clear_loop>

800054ac <udata_clear_loop_end>:
800054ac:	fe cf e9 7c 	sub	pc,pc,-5764
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	d9 60       	acall	0x96

800054b4 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800054b4:	f8 c8 ff f8 	sub	r8,r12,-8
800054b8:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800054ba:	3f f9       	mov	r9,-1
800054bc:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800054be:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800054c0:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800054c2:	30 08       	mov	r8,0
800054c4:	99 08       	st.w	r12[0x0],r8
}
800054c6:	5e fc       	retal	r12

800054c8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800054c8:	30 08       	mov	r8,0
800054ca:	99 48       	st.w	r12[0x10],r8
}
800054cc:	5e fc       	retal	r12

800054ce <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800054ce:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800054d0:	70 19       	ld.w	r9,r8[0x4]
800054d2:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800054d4:	78 19       	ld.w	r9,r12[0x4]
800054d6:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800054d8:	70 19       	ld.w	r9,r8[0x4]
800054da:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800054dc:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800054de:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800054e0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800054e2:	78 08       	ld.w	r8,r12[0x0]
800054e4:	2f f8       	sub	r8,-1
800054e6:	99 08       	st.w	r12[0x0],r8
}
800054e8:	5e fc       	retal	r12

800054ea <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800054ea:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800054ec:	5b fa       	cp.w	r10,-1
800054ee:	c0 31       	brne	800054f4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800054f0:	78 48       	ld.w	r8,r12[0x10]
800054f2:	c0 c8       	rjmp	8000550a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800054f4:	f8 c8 ff f8 	sub	r8,r12,-8
800054f8:	70 19       	ld.w	r9,r8[0x4]
800054fa:	72 09       	ld.w	r9,r9[0x0]
800054fc:	12 3a       	cp.w	r10,r9
800054fe:	c0 63       	brcs	8000550a <vListInsert+0x20>
80005500:	70 18       	ld.w	r8,r8[0x4]
80005502:	70 19       	ld.w	r9,r8[0x4]
80005504:	72 09       	ld.w	r9,r9[0x0]
80005506:	12 3a       	cp.w	r10,r9
80005508:	cf c2       	brcc	80005500 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000550a:	70 19       	ld.w	r9,r8[0x4]
8000550c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000550e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005510:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005512:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005514:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005516:	78 08       	ld.w	r8,r12[0x0]
80005518:	2f f8       	sub	r8,-1
8000551a:	99 08       	st.w	r12[0x0],r8
}
8000551c:	5e fc       	retal	r12

8000551e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000551e:	78 18       	ld.w	r8,r12[0x4]
80005520:	78 29       	ld.w	r9,r12[0x8]
80005522:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005524:	78 28       	ld.w	r8,r12[0x8]
80005526:	78 19       	ld.w	r9,r12[0x4]
80005528:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000552a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
8000552c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000552e:	18 39       	cp.w	r9,r12
80005530:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005534:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005538:	30 09       	mov	r9,0
8000553a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
8000553c:	70 09       	ld.w	r9,r8[0x0]
8000553e:	20 19       	sub	r9,1
80005540:	91 09       	st.w	r8[0x0],r9
}
80005542:	5e fc       	retal	r12

80005544 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005544:	e0 68 08 08 	mov	r8,2056
80005548:	ea 18 08 08 	orh	r8,0x808
8000554c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000554e:	e0 68 09 09 	mov	r8,2313
80005552:	ea 18 09 09 	orh	r8,0x909
80005556:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005558:	e0 68 0a 0a 	mov	r8,2570
8000555c:	ea 18 0a 0a 	orh	r8,0xa0a
80005560:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005562:	e0 68 0b 0b 	mov	r8,2827
80005566:	ea 18 0b 0b 	orh	r8,0xb0b
8000556a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
8000556c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000556e:	e0 68 be ef 	mov	r8,48879
80005572:	ea 18 de ad 	orh	r8,0xdead
80005576:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005578:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000557a:	fc 18 00 40 	movh	r8,0x40
8000557e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005580:	e0 68 00 ff 	mov	r8,255
80005584:	ea 18 ff 00 	orh	r8,0xff00
80005588:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000558a:	e0 68 01 01 	mov	r8,257
8000558e:	ea 18 01 01 	orh	r8,0x101
80005592:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005594:	e0 68 02 02 	mov	r8,514
80005598:	ea 18 02 02 	orh	r8,0x202
8000559c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000559e:	e0 68 03 03 	mov	r8,771
800055a2:	ea 18 03 03 	orh	r8,0x303
800055a6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800055a8:	e0 68 04 04 	mov	r8,1028
800055ac:	ea 18 04 04 	orh	r8,0x404
800055b0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800055b2:	e0 68 05 05 	mov	r8,1285
800055b6:	ea 18 05 05 	orh	r8,0x505
800055ba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800055bc:	e0 68 06 06 	mov	r8,1542
800055c0:	ea 18 06 06 	orh	r8,0x606
800055c4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800055c6:	e0 68 07 07 	mov	r8,1799
800055ca:	ea 18 07 07 	orh	r8,0x707
800055ce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800055d0:	30 08       	mov	r8,0
800055d2:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800055d4:	5e fc       	retal	r12
800055d6:	d7 03       	nop

800055d8 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800055d8:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800055da:	48 38       	lddpc	r8,800055e4 <vPortEnterCritical+0xc>
800055dc:	70 09       	ld.w	r9,r8[0x0]
800055de:	2f f9       	sub	r9,-1
800055e0:	91 09       	st.w	r8[0x0],r9
}
800055e2:	5e fc       	retal	r12
800055e4:	00 00       	add	r0,r0
800055e6:	05 30       	ld.ub	r0,r2++

800055e8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800055e8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800055ea:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800055ec:	30 0a       	mov	r10,0
800055ee:	14 9b       	mov	r11,r10
800055f0:	49 2c       	lddpc	r12,80005638 <xPortStartScheduler+0x50>
800055f2:	f0 1f 00 13 	mcall	8000563c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800055f6:	e0 68 5d c0 	mov	r8,24000
800055fa:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800055fe:	30 08       	mov	r8,0
80005600:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005604:	e0 68 0c dc 	mov	r8,3292
80005608:	ea 18 00 00 	orh	r8,0x0
8000560c:	70 00       	ld.w	r0,r8[0x0]
8000560e:	60 0d       	ld.w	sp,r0[0x0]
80005610:	1b 00       	ld.w	r0,sp++
80005612:	e0 68 05 30 	mov	r8,1328
80005616:	ea 18 00 00 	orh	r8,0x0
8000561a:	91 00       	st.w	r8[0x0],r0
8000561c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005620:	2f ed       	sub	sp,-8
80005622:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005626:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000562a:	e3 b0 00 00 	mtsr	0x0,r0
8000562e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005632:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005636:	d8 0a       	popm	pc,r12=0
80005638:	80 00       	ld.sh	r0,r0[0x0]
8000563a:	57 04       	stdsp	sp[0x1c0],r4
8000563c:	80 00       	ld.sh	r0,r0[0x0]
8000563e:	4e f8       	lddpc	r8,800057f8 <_write+0x18>

80005640 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005640:	20 6d       	sub	sp,24
80005642:	eb cd 00 ff 	pushm	r0-r7
80005646:	fa c7 ff c0 	sub	r7,sp,-64
8000564a:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000564e:	ef 40 ff e0 	st.w	r7[-32],r0
80005652:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005656:	ef 40 ff e4 	st.w	r7[-28],r0
8000565a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000565e:	e0 68 05 30 	mov	r8,1328
80005662:	ea 18 00 00 	orh	r8,0x0
80005666:	70 00       	ld.w	r0,r8[0x0]
80005668:	1a d0       	st.w	--sp,r0
8000566a:	f0 1f 00 1a 	mcall	800056d0 <LABEL_RET_SCALL_263+0x14>
8000566e:	e0 68 0c dc 	mov	r8,3292
80005672:	ea 18 00 00 	orh	r8,0x0
80005676:	70 00       	ld.w	r0,r8[0x0]
80005678:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000567a:	f0 1f 00 17 	mcall	800056d4 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000567e:	e0 68 0c dc 	mov	r8,3292
80005682:	ea 18 00 00 	orh	r8,0x0
80005686:	70 00       	ld.w	r0,r8[0x0]
80005688:	60 0d       	ld.w	sp,r0[0x0]
8000568a:	1b 00       	ld.w	r0,sp++
8000568c:	e0 68 05 30 	mov	r8,1328
80005690:	ea 18 00 00 	orh	r8,0x0
80005694:	91 00       	st.w	r8[0x0],r0
80005696:	fa c7 ff d8 	sub	r7,sp,-40
8000569a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000569e:	ee f0 ff e0 	ld.w	r0,r7[-32]
800056a2:	e0 61 05 30 	mov	r1,1328
800056a6:	ea 11 00 00 	orh	r1,0x0
800056aa:	62 02       	ld.w	r2,r1[0x0]
800056ac:	58 02       	cp.w	r2,0
800056ae:	c0 70       	breq	800056bc <LABEL_RET_SCALL_263>
800056b0:	e4 c2 00 01 	sub	r2,r2,1
800056b4:	83 02       	st.w	r1[0x0],r2
800056b6:	58 02       	cp.w	r2,0
800056b8:	c0 21       	brne	800056bc <LABEL_RET_SCALL_263>
800056ba:	b1 c0       	cbr	r0,0x10

800056bc <LABEL_RET_SCALL_263>:
800056bc:	ef 40 ff f8 	st.w	r7[-8],r0
800056c0:	ee f0 ff e4 	ld.w	r0,r7[-28]
800056c4:	ef 40 ff fc 	st.w	r7[-4],r0
800056c8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800056cc:	2f ad       	sub	sp,-24
800056ce:	d6 13       	rets
800056d0:	80 00       	ld.sh	r0,r0[0x0]
800056d2:	55 d8       	stdsp	sp[0x174],r8
800056d4:	80 00       	ld.sh	r0,r0[0x0]
800056d6:	5d 1c       	icall	r12

800056d8 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800056d8:	e1 b8 00 43 	mfsr	r8,0x10c
800056dc:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800056e0:	5e fc       	retal	r12
800056e2:	d7 03       	nop

800056e4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800056e4:	48 78       	lddpc	r8,80005700 <vPortExitCritical+0x1c>
800056e6:	70 08       	ld.w	r8,r8[0x0]
800056e8:	58 08       	cp.w	r8,0
800056ea:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800056ec:	48 58       	lddpc	r8,80005700 <vPortExitCritical+0x1c>
800056ee:	70 09       	ld.w	r9,r8[0x0]
800056f0:	20 19       	sub	r9,1
800056f2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800056f4:	70 08       	ld.w	r8,r8[0x0]
800056f6:	58 08       	cp.w	r8,0
800056f8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800056fa:	d5 03       	csrf	0x10
800056fc:	5e fc       	retal	r12
800056fe:	00 00       	add	r0,r0
80005700:	00 00       	add	r0,r0
80005702:	05 30       	ld.ub	r0,r2++

80005704 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005704:	eb cd 00 ff 	pushm	r0-r7
80005708:	e0 68 05 30 	mov	r8,1328
8000570c:	ea 18 00 00 	orh	r8,0x0
80005710:	70 00       	ld.w	r0,r8[0x0]
80005712:	1a d0       	st.w	--sp,r0
80005714:	7a 90       	ld.w	r0,sp[0x24]
80005716:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000571a:	58 10       	cp.w	r0,1
8000571c:	e0 8b 00 08 	brhi	8000572c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005720:	e0 68 0c dc 	mov	r8,3292
80005724:	ea 18 00 00 	orh	r8,0x0
80005728:	70 00       	ld.w	r0,r8[0x0]
8000572a:	81 0d       	st.w	r0[0x0],sp

8000572c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000572c:	f0 1f 00 12 	mcall	80005774 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005730:	f0 1f 00 12 	mcall	80005778 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005734:	f0 1f 00 12 	mcall	8000577c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005738:	f0 1f 00 12 	mcall	80005780 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000573c:	7a 90       	ld.w	r0,sp[0x24]
8000573e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005742:	58 10       	cp.w	r0,1
80005744:	e0 8b 00 0e 	brhi	80005760 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005748:	f0 1f 00 0c 	mcall	80005778 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
8000574c:	f0 1f 00 0e 	mcall	80005784 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005750:	f0 1f 00 0c 	mcall	80005780 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005754:	e0 68 0c dc 	mov	r8,3292
80005758:	ea 18 00 00 	orh	r8,0x0
8000575c:	70 00       	ld.w	r0,r8[0x0]
8000575e:	60 0d       	ld.w	sp,r0[0x0]

80005760 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005760:	1b 00       	ld.w	r0,sp++
80005762:	e0 68 05 30 	mov	r8,1328
80005766:	ea 18 00 00 	orh	r8,0x0
8000576a:	91 00       	st.w	r8[0x0],r0
8000576c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005770:	d6 03       	rete
80005772:	00 00       	add	r0,r0
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	56 d8       	stdsp	sp[0x1b4],r8
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	55 d8       	stdsp	sp[0x174],r8
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	5f 20       	srhs	r0
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	56 e4       	stdsp	sp[0x1b8],r4
80005784:	80 00       	ld.sh	r0,r0[0x0]
80005786:	5d 1c       	icall	r12

80005788 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005788:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000578a:	f0 1f 00 02 	mcall	80005790 <__malloc_lock+0x8>
}
8000578e:	d8 02       	popm	pc
80005790:	80 00       	ld.sh	r0,r0[0x0]
80005792:	5d 0c       	ror	r12

80005794 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005794:	d4 01       	pushm	lr
	xTaskResumeAll();
80005796:	f0 1f 00 02 	mcall	8000579c <__malloc_unlock+0x8>
}
8000579a:	d8 02       	popm	pc
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	60 c8       	ld.w	r8,r0[0x30]

800057a0 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800057a0:	d4 21       	pushm	r4-r7,lr
800057a2:	16 95       	mov	r5,r11
800057a4:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800057a6:	58 0c       	cp.w	r12,0
800057a8:	c0 30       	breq	800057ae <_read+0xe>
800057aa:	3f f7       	mov	r7,-1
800057ac:	c1 48       	rjmp	800057d4 <_read+0x34>
    return -1;

  for (; len > 0; --len)
800057ae:	58 0a       	cp.w	r10,0
800057b0:	e0 89 00 04 	brgt	800057b8 <_read+0x18>
800057b4:	30 07       	mov	r7,0
800057b6:	c0 f8       	rjmp	800057d4 <_read+0x34>
800057b8:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800057ba:	48 84       	lddpc	r4,800057d8 <_read+0x38>
800057bc:	68 0c       	ld.w	r12,r4[0x0]
800057be:	f0 1f 00 08 	mcall	800057dc <_read+0x3c>
    if (c < 0)
800057c2:	c0 95       	brlt	800057d4 <_read+0x34>
      break;

    *ptr++ = c;
800057c4:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800057c8:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800057ca:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800057ce:	58 08       	cp.w	r8,0
800057d0:	fe 99 ff f6 	brgt	800057bc <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800057d4:	0e 9c       	mov	r12,r7
800057d6:	d8 22       	popm	r4-r7,pc
800057d8:	00 00       	add	r0,r0
800057da:	63 94       	ld.w	r4,r1[0x64]
800057dc:	80 00       	ld.sh	r0,r0[0x0]
800057de:	53 2c       	stdsp	sp[0xc8],r12

800057e0 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800057e0:	d4 21       	pushm	r4-r7,lr
800057e2:	16 95       	mov	r5,r11
800057e4:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800057e6:	20 1c       	sub	r12,1
800057e8:	58 2c       	cp.w	r12,2
800057ea:	e0 8b 00 12 	brhi	8000580e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800057ee:	58 0a       	cp.w	r10,0
800057f0:	c0 31       	brne	800057f6 <_write+0x16>
800057f2:	30 07       	mov	r7,0
800057f4:	c0 e8       	rjmp	80005810 <_write+0x30>
800057f6:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800057f8:	48 74       	lddpc	r4,80005814 <_write+0x34>
800057fa:	68 0c       	ld.w	r12,r4[0x0]
800057fc:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005800:	f0 1f 00 06 	mcall	80005818 <_write+0x38>
80005804:	c0 55       	brlt	8000580e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005806:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005808:	0e 36       	cp.w	r6,r7
8000580a:	cf 81       	brne	800057fa <_write+0x1a>
8000580c:	c0 28       	rjmp	80005810 <_write+0x30>
8000580e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005810:	0e 9c       	mov	r12,r7
80005812:	d8 22       	popm	r4-r7,pc
80005814:	00 00       	add	r0,r0
80005816:	63 94       	ld.w	r4,r1[0x64]
80005818:	80 00       	ld.sh	r0,r0[0x0]
8000581a:	52 dc       	stdsp	sp[0xb4],r12

8000581c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000581c:	eb cd 40 80 	pushm	r7,lr
80005820:	18 97       	mov	r7,r12
	if( pv )
80005822:	58 0c       	cp.w	r12,0
80005824:	c0 80       	breq	80005834 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005826:	f0 1f 00 05 	mcall	80005838 <vPortFree+0x1c>
		{
			free( pv );
8000582a:	0e 9c       	mov	r12,r7
8000582c:	f0 1f 00 04 	mcall	8000583c <vPortFree+0x20>
		}
		xTaskResumeAll();
80005830:	f0 1f 00 04 	mcall	80005840 <vPortFree+0x24>
80005834:	e3 cd 80 80 	ldm	sp++,r7,pc
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	5d 0c       	ror	r12
8000583c:	80 00       	ld.sh	r0,r0[0x0]
8000583e:	6b 98       	ld.w	r8,r5[0x64]
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	60 c8       	ld.w	r8,r0[0x30]

80005844 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005844:	eb cd 40 80 	pushm	r7,lr
80005848:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000584a:	f0 1f 00 06 	mcall	80005860 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000584e:	0e 9c       	mov	r12,r7
80005850:	f0 1f 00 05 	mcall	80005864 <pvPortMalloc+0x20>
80005854:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005856:	f0 1f 00 05 	mcall	80005868 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000585a:	0e 9c       	mov	r12,r7
8000585c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	5d 0c       	ror	r12
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	6b a8       	ld.w	r8,r5[0x68]
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	60 c8       	ld.w	r8,r0[0x30]

8000586c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
8000586c:	d4 01       	pushm	lr
8000586e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005870:	78 09       	ld.w	r9,r12[0x0]
80005872:	58 09       	cp.w	r9,0
80005874:	c1 10       	breq	80005896 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005876:	78 3a       	ld.w	r10,r12[0xc]
80005878:	79 09       	ld.w	r9,r12[0x40]
8000587a:	f4 09 00 09 	add	r9,r10,r9
8000587e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005880:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005882:	14 39       	cp.w	r9,r10
80005884:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005888:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000588c:	79 0a       	ld.w	r10,r12[0x40]
8000588e:	78 3b       	ld.w	r11,r12[0xc]
80005890:	10 9c       	mov	r12,r8
80005892:	f0 1f 00 02 	mcall	80005898 <prvCopyDataFromQueue+0x2c>
80005896:	d8 02       	popm	pc
80005898:	80 00       	ld.sh	r0,r0[0x0]
8000589a:	70 16       	ld.w	r6,r8[0x4]

8000589c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
8000589c:	eb cd 40 c0 	pushm	r6-r7,lr
800058a0:	18 97       	mov	r7,r12
800058a2:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800058a4:	78 e8       	ld.w	r8,r12[0x38]
800058a6:	58 08       	cp.w	r8,0
800058a8:	c0 31       	brne	800058ae <xQueueReceiveFromISR+0x12>
800058aa:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800058ae:	f0 1f 00 0e 	mcall	800058e4 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800058b2:	6e e8       	ld.w	r8,r7[0x38]
800058b4:	20 18       	sub	r8,1
800058b6:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800058b8:	6f 18       	ld.w	r8,r7[0x44]
800058ba:	5b f8       	cp.w	r8,-1
800058bc:	c0 d1       	brne	800058d6 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800058be:	6e 48       	ld.w	r8,r7[0x10]
800058c0:	58 08       	cp.w	r8,0
800058c2:	c0 f0       	breq	800058e0 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800058c4:	ee cc ff f0 	sub	r12,r7,-16
800058c8:	f0 1f 00 08 	mcall	800058e8 <xQueueReceiveFromISR+0x4c>
800058cc:	c0 a0       	breq	800058e0 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800058ce:	30 1c       	mov	r12,1
800058d0:	8d 0c       	st.w	r6[0x0],r12
800058d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800058d6:	2f f8       	sub	r8,-1
800058d8:	ef 48 00 44 	st.w	r7[68],r8
800058dc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800058e0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800058e4:	80 00       	ld.sh	r0,r0[0x0]
800058e6:	58 6c       	cp.w	r12,6
800058e8:	80 00       	ld.sh	r0,r0[0x0]
800058ea:	5e a4       	retle	r4

800058ec <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800058ec:	eb cd 40 c0 	pushm	r6-r7,lr
800058f0:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800058f2:	f0 1f 00 23 	mcall	8000597c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800058f6:	6f 28       	ld.w	r8,r7[0x48]
800058f8:	58 08       	cp.w	r8,0
800058fa:	e0 8a 00 18 	brle	8000592a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800058fe:	6e 98       	ld.w	r8,r7[0x24]
80005900:	58 08       	cp.w	r8,0
80005902:	c1 40       	breq	8000592a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005904:	ee c6 ff dc 	sub	r6,r7,-36
80005908:	c0 48       	rjmp	80005910 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000590a:	6e 98       	ld.w	r8,r7[0x24]
8000590c:	58 08       	cp.w	r8,0
8000590e:	c0 e0       	breq	8000592a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005910:	0c 9c       	mov	r12,r6
80005912:	f0 1f 00 1c 	mcall	80005980 <prvUnlockQueue+0x94>
80005916:	c0 30       	breq	8000591c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005918:	f0 1f 00 1b 	mcall	80005984 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000591c:	6f 28       	ld.w	r8,r7[0x48]
8000591e:	20 18       	sub	r8,1
80005920:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005924:	58 08       	cp.w	r8,0
80005926:	fe 99 ff f2 	brgt	8000590a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000592a:	3f f8       	mov	r8,-1
8000592c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005930:	f0 1f 00 16 	mcall	80005988 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005934:	f0 1f 00 12 	mcall	8000597c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005938:	6f 18       	ld.w	r8,r7[0x44]
8000593a:	58 08       	cp.w	r8,0
8000593c:	e0 8a 00 18 	brle	8000596c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005940:	6e 48       	ld.w	r8,r7[0x10]
80005942:	58 08       	cp.w	r8,0
80005944:	c1 40       	breq	8000596c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005946:	ee c6 ff f0 	sub	r6,r7,-16
8000594a:	c0 48       	rjmp	80005952 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000594c:	6e 48       	ld.w	r8,r7[0x10]
8000594e:	58 08       	cp.w	r8,0
80005950:	c0 e0       	breq	8000596c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005952:	0c 9c       	mov	r12,r6
80005954:	f0 1f 00 0b 	mcall	80005980 <prvUnlockQueue+0x94>
80005958:	c0 30       	breq	8000595e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000595a:	f0 1f 00 0b 	mcall	80005984 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000595e:	6f 18       	ld.w	r8,r7[0x44]
80005960:	20 18       	sub	r8,1
80005962:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005966:	58 08       	cp.w	r8,0
80005968:	fe 99 ff f2 	brgt	8000594c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
8000596c:	3f f8       	mov	r8,-1
8000596e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005972:	f0 1f 00 06 	mcall	80005988 <prvUnlockQueue+0x9c>
}
80005976:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000597a:	00 00       	add	r0,r0
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	55 d8       	stdsp	sp[0x174],r8
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	5e a4       	retle	r4
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	5d b0       	*unknown*
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	56 e4       	stdsp	sp[0x1b8],r4

8000598c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
8000598c:	d4 31       	pushm	r0-r7,lr
8000598e:	20 5d       	sub	sp,20
80005990:	18 97       	mov	r7,r12
80005992:	50 0b       	stdsp	sp[0x0],r11
80005994:	50 2a       	stdsp	sp[0x8],r10
80005996:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005998:	f8 c2 ff dc 	sub	r2,r12,-36
8000599c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000599e:	fa c4 ff f4 	sub	r4,sp,-12
800059a2:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800059a4:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800059a6:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800059aa:	f0 1f 00 3e 	mcall	80005aa0 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800059ae:	6e e8       	ld.w	r8,r7[0x38]
800059b0:	58 08       	cp.w	r8,0
800059b2:	c2 a0       	breq	80005a06 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800059b4:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800059b6:	40 0b       	lddsp	r11,sp[0x0]
800059b8:	0e 9c       	mov	r12,r7
800059ba:	f0 1f 00 3b 	mcall	80005aa4 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800059be:	40 18       	lddsp	r8,sp[0x4]
800059c0:	58 08       	cp.w	r8,0
800059c2:	c1 51       	brne	800059ec <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800059c4:	6e e8       	ld.w	r8,r7[0x38]
800059c6:	20 18       	sub	r8,1
800059c8:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800059ca:	6e 08       	ld.w	r8,r7[0x0]
800059cc:	58 08       	cp.w	r8,0
800059ce:	c0 41       	brne	800059d6 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800059d0:	f0 1f 00 36 	mcall	80005aa8 <xQueueGenericReceive+0x11c>
800059d4:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800059d6:	6e 48       	ld.w	r8,r7[0x10]
800059d8:	58 08       	cp.w	r8,0
800059da:	c1 20       	breq	800059fe <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800059dc:	ee cc ff f0 	sub	r12,r7,-16
800059e0:	f0 1f 00 33 	mcall	80005aac <xQueueGenericReceive+0x120>
800059e4:	58 1c       	cp.w	r12,1
800059e6:	c0 c1       	brne	800059fe <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800059e8:	d7 33       	scall
800059ea:	c0 a8       	rjmp	800059fe <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800059ec:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800059ee:	6e 98       	ld.w	r8,r7[0x24]
800059f0:	58 08       	cp.w	r8,0
800059f2:	c0 60       	breq	800059fe <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800059f4:	04 9c       	mov	r12,r2
800059f6:	f0 1f 00 2e 	mcall	80005aac <xQueueGenericReceive+0x120>
800059fa:	c0 20       	breq	800059fe <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800059fc:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800059fe:	f0 1f 00 2d 	mcall	80005ab0 <xQueueGenericReceive+0x124>
80005a02:	30 1c       	mov	r12,1
				return pdPASS;
80005a04:	c4 c8       	rjmp	80005a9c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005a06:	40 28       	lddsp	r8,sp[0x8]
80005a08:	58 08       	cp.w	r8,0
80005a0a:	c0 51       	brne	80005a14 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005a0c:	f0 1f 00 29 	mcall	80005ab0 <xQueueGenericReceive+0x124>
80005a10:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005a12:	c4 58       	rjmp	80005a9c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005a14:	58 05       	cp.w	r5,0
80005a16:	c0 51       	brne	80005a20 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005a18:	08 9c       	mov	r12,r4
80005a1a:	f0 1f 00 27 	mcall	80005ab4 <xQueueGenericReceive+0x128>
80005a1e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005a20:	f0 1f 00 24 	mcall	80005ab0 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005a24:	f0 1f 00 25 	mcall	80005ab8 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005a28:	f0 1f 00 1e 	mcall	80005aa0 <xQueueGenericReceive+0x114>
80005a2c:	6f 18       	ld.w	r8,r7[0x44]
80005a2e:	5b f8       	cp.w	r8,-1
80005a30:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005a34:	6f 28       	ld.w	r8,r7[0x48]
80005a36:	5b f8       	cp.w	r8,-1
80005a38:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005a3c:	f0 1f 00 1d 	mcall	80005ab0 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005a40:	06 9b       	mov	r11,r3
80005a42:	08 9c       	mov	r12,r4
80005a44:	f0 1f 00 1e 	mcall	80005abc <xQueueGenericReceive+0x130>
80005a48:	c2 41       	brne	80005a90 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a4a:	f0 1f 00 16 	mcall	80005aa0 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005a4e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005a50:	f0 1f 00 18 	mcall	80005ab0 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005a54:	58 06       	cp.w	r6,0
80005a56:	c1 71       	brne	80005a84 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005a58:	6e 08       	ld.w	r8,r7[0x0]
80005a5a:	58 08       	cp.w	r8,0
80005a5c:	c0 81       	brne	80005a6c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005a5e:	f0 1f 00 11 	mcall	80005aa0 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005a62:	6e 1c       	ld.w	r12,r7[0x4]
80005a64:	f0 1f 00 17 	mcall	80005ac0 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005a68:	f0 1f 00 12 	mcall	80005ab0 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005a6c:	40 2b       	lddsp	r11,sp[0x8]
80005a6e:	04 9c       	mov	r12,r2
80005a70:	f0 1f 00 15 	mcall	80005ac4 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005a74:	0e 9c       	mov	r12,r7
80005a76:	f0 1f 00 15 	mcall	80005ac8 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005a7a:	f0 1f 00 15 	mcall	80005acc <xQueueGenericReceive+0x140>
80005a7e:	c9 61       	brne	800059aa <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005a80:	d7 33       	scall
80005a82:	c9 4b       	rjmp	800059aa <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005a84:	0e 9c       	mov	r12,r7
80005a86:	f0 1f 00 11 	mcall	80005ac8 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005a8a:	f0 1f 00 11 	mcall	80005acc <xQueueGenericReceive+0x140>
80005a8e:	c8 eb       	rjmp	800059aa <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005a90:	0e 9c       	mov	r12,r7
80005a92:	f0 1f 00 0e 	mcall	80005ac8 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005a96:	f0 1f 00 0e 	mcall	80005acc <xQueueGenericReceive+0x140>
80005a9a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005a9c:	2f bd       	sub	sp,-20
80005a9e:	d8 32       	popm	r0-r7,pc
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	55 d8       	stdsp	sp[0x174],r8
80005aa4:	80 00       	ld.sh	r0,r0[0x0]
80005aa6:	58 6c       	cp.w	r12,6
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	5d bc       	*unknown*
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	5e a4       	retle	r4
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	56 e4       	stdsp	sp[0x1b8],r4
80005ab4:	80 00       	ld.sh	r0,r0[0x0]
80005ab6:	5d 98       	*unknown*
80005ab8:	80 00       	ld.sh	r0,r0[0x0]
80005aba:	5d 0c       	ror	r12
80005abc:	80 00       	ld.sh	r0,r0[0x0]
80005abe:	60 34       	ld.w	r4,r0[0xc]
80005ac0:	80 00       	ld.sh	r0,r0[0x0]
80005ac2:	5e 20       	reths	r0
80005ac4:	80 00       	ld.sh	r0,r0[0x0]
80005ac6:	62 d4       	ld.w	r4,r1[0x34]
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	58 ec       	cp.w	r12,14
80005acc:	80 00       	ld.sh	r0,r0[0x0]
80005ace:	60 c8       	ld.w	r8,r0[0x30]

80005ad0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005ad0:	eb cd 40 80 	pushm	r7,lr
80005ad4:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005ad6:	79 08       	ld.w	r8,r12[0x40]
80005ad8:	58 08       	cp.w	r8,0
80005ada:	c0 a1       	brne	80005aee <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005adc:	78 08       	ld.w	r8,r12[0x0]
80005ade:	58 08       	cp.w	r8,0
80005ae0:	c2 b1       	brne	80005b36 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005ae2:	78 1c       	ld.w	r12,r12[0x4]
80005ae4:	f0 1f 00 17 	mcall	80005b40 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005ae8:	30 08       	mov	r8,0
80005aea:	8f 18       	st.w	r7[0x4],r8
80005aec:	c2 58       	rjmp	80005b36 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005aee:	58 0a       	cp.w	r10,0
80005af0:	c1 01       	brne	80005b10 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005af2:	10 9a       	mov	r10,r8
80005af4:	78 2c       	ld.w	r12,r12[0x8]
80005af6:	f0 1f 00 14 	mcall	80005b44 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005afa:	6e 29       	ld.w	r9,r7[0x8]
80005afc:	6f 08       	ld.w	r8,r7[0x40]
80005afe:	f2 08 00 08 	add	r8,r9,r8
80005b02:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005b04:	6e 19       	ld.w	r9,r7[0x4]
80005b06:	12 38       	cp.w	r8,r9
80005b08:	c1 73       	brcs	80005b36 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005b0a:	6e 08       	ld.w	r8,r7[0x0]
80005b0c:	8f 28       	st.w	r7[0x8],r8
80005b0e:	c1 48       	rjmp	80005b36 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005b10:	10 9a       	mov	r10,r8
80005b12:	78 3c       	ld.w	r12,r12[0xc]
80005b14:	f0 1f 00 0c 	mcall	80005b44 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005b18:	6f 08       	ld.w	r8,r7[0x40]
80005b1a:	6e 39       	ld.w	r9,r7[0xc]
80005b1c:	f2 08 01 08 	sub	r8,r9,r8
80005b20:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005b22:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005b24:	12 38       	cp.w	r8,r9
80005b26:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005b2a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005b2e:	f3 d8 e3 19 	subcs	r9,r9,r8
80005b32:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005b36:	6e e8       	ld.w	r8,r7[0x38]
80005b38:	2f f8       	sub	r8,-1
80005b3a:	8f e8       	st.w	r7[0x38],r8
}
80005b3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b40:	80 00       	ld.sh	r0,r0[0x0]
80005b42:	5d c8       	*unknown*
80005b44:	80 00       	ld.sh	r0,r0[0x0]
80005b46:	70 16       	ld.w	r6,r8[0x4]

80005b48 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005b48:	eb cd 40 c0 	pushm	r6-r7,lr
80005b4c:	18 97       	mov	r7,r12
80005b4e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005b50:	78 ec       	ld.w	r12,r12[0x38]
80005b52:	6e f8       	ld.w	r8,r7[0x3c]
80005b54:	10 3c       	cp.w	r12,r8
80005b56:	c0 33       	brcs	80005b5c <xQueueGenericSendFromISR+0x14>
80005b58:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005b5c:	12 9a       	mov	r10,r9
80005b5e:	0e 9c       	mov	r12,r7
80005b60:	f0 1f 00 0c 	mcall	80005b90 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005b64:	6f 28       	ld.w	r8,r7[0x48]
80005b66:	5b f8       	cp.w	r8,-1
80005b68:	c0 d1       	brne	80005b82 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b6a:	6e 98       	ld.w	r8,r7[0x24]
80005b6c:	58 08       	cp.w	r8,0
80005b6e:	c0 f0       	breq	80005b8c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b70:	ee cc ff dc 	sub	r12,r7,-36
80005b74:	f0 1f 00 08 	mcall	80005b94 <xQueueGenericSendFromISR+0x4c>
80005b78:	c0 a0       	breq	80005b8c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005b7a:	30 1c       	mov	r12,1
80005b7c:	8d 0c       	st.w	r6[0x0],r12
80005b7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005b82:	2f f8       	sub	r8,-1
80005b84:	ef 48 00 48 	st.w	r7[72],r8
80005b88:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b8c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b90:	80 00       	ld.sh	r0,r0[0x0]
80005b92:	5a d0       	cp.w	r0,-19
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	5e a4       	retle	r4

80005b98 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005b98:	d4 31       	pushm	r0-r7,lr
80005b9a:	20 5d       	sub	sp,20
80005b9c:	18 97       	mov	r7,r12
80005b9e:	50 0b       	stdsp	sp[0x0],r11
80005ba0:	50 2a       	stdsp	sp[0x8],r10
80005ba2:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005ba4:	f8 c0 ff f0 	sub	r0,r12,-16
80005ba8:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005baa:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005bae:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005bb0:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005bb4:	f0 1f 00 2f 	mcall	80005c70 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005bb8:	6e e9       	ld.w	r9,r7[0x38]
80005bba:	6e f8       	ld.w	r8,r7[0x3c]
80005bbc:	10 39       	cp.w	r9,r8
80005bbe:	c1 42       	brcc	80005be6 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005bc0:	40 1a       	lddsp	r10,sp[0x4]
80005bc2:	40 0b       	lddsp	r11,sp[0x0]
80005bc4:	0e 9c       	mov	r12,r7
80005bc6:	f0 1f 00 2c 	mcall	80005c74 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005bca:	6e 98       	ld.w	r8,r7[0x24]
80005bcc:	58 08       	cp.w	r8,0
80005bce:	c0 80       	breq	80005bde <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005bd0:	ee cc ff dc 	sub	r12,r7,-36
80005bd4:	f0 1f 00 29 	mcall	80005c78 <xQueueGenericSend+0xe0>
80005bd8:	58 1c       	cp.w	r12,1
80005bda:	c0 21       	brne	80005bde <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005bdc:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005bde:	f0 1f 00 28 	mcall	80005c7c <xQueueGenericSend+0xe4>
80005be2:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005be4:	c4 38       	rjmp	80005c6a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005be6:	40 28       	lddsp	r8,sp[0x8]
80005be8:	58 08       	cp.w	r8,0
80005bea:	c0 51       	brne	80005bf4 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005bec:	f0 1f 00 24 	mcall	80005c7c <xQueueGenericSend+0xe4>
80005bf0:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005bf2:	c3 c8       	rjmp	80005c6a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005bf4:	58 04       	cp.w	r4,0
80005bf6:	c0 51       	brne	80005c00 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005bf8:	06 9c       	mov	r12,r3
80005bfa:	f0 1f 00 22 	mcall	80005c80 <xQueueGenericSend+0xe8>
80005bfe:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005c00:	f0 1f 00 1f 	mcall	80005c7c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005c04:	f0 1f 00 20 	mcall	80005c84 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005c08:	f0 1f 00 1a 	mcall	80005c70 <xQueueGenericSend+0xd8>
80005c0c:	6f 18       	ld.w	r8,r7[0x44]
80005c0e:	5b f8       	cp.w	r8,-1
80005c10:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005c14:	6f 28       	ld.w	r8,r7[0x48]
80005c16:	5b f8       	cp.w	r8,-1
80005c18:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005c1c:	f0 1f 00 18 	mcall	80005c7c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c20:	04 9b       	mov	r11,r2
80005c22:	06 9c       	mov	r12,r3
80005c24:	f0 1f 00 19 	mcall	80005c88 <xQueueGenericSend+0xf0>
80005c28:	c1 b1       	brne	80005c5e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005c2a:	f0 1f 00 12 	mcall	80005c70 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005c2e:	6e e5       	ld.w	r5,r7[0x38]
80005c30:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005c32:	f0 1f 00 13 	mcall	80005c7c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005c36:	0c 35       	cp.w	r5,r6
80005c38:	c0 d1       	brne	80005c52 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005c3a:	40 2b       	lddsp	r11,sp[0x8]
80005c3c:	00 9c       	mov	r12,r0
80005c3e:	f0 1f 00 14 	mcall	80005c8c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005c42:	0e 9c       	mov	r12,r7
80005c44:	f0 1f 00 13 	mcall	80005c90 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005c48:	f0 1f 00 13 	mcall	80005c94 <xQueueGenericSend+0xfc>
80005c4c:	cb 41       	brne	80005bb4 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005c4e:	d7 33       	scall
80005c50:	cb 2b       	rjmp	80005bb4 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005c52:	0e 9c       	mov	r12,r7
80005c54:	f0 1f 00 0f 	mcall	80005c90 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005c58:	f0 1f 00 0f 	mcall	80005c94 <xQueueGenericSend+0xfc>
80005c5c:	ca cb       	rjmp	80005bb4 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005c5e:	0e 9c       	mov	r12,r7
80005c60:	f0 1f 00 0c 	mcall	80005c90 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005c64:	f0 1f 00 0c 	mcall	80005c94 <xQueueGenericSend+0xfc>
80005c68:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005c6a:	2f bd       	sub	sp,-20
80005c6c:	d8 32       	popm	r0-r7,pc
80005c6e:	00 00       	add	r0,r0
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	55 d8       	stdsp	sp[0x174],r8
80005c74:	80 00       	ld.sh	r0,r0[0x0]
80005c76:	5a d0       	cp.w	r0,-19
80005c78:	80 00       	ld.sh	r0,r0[0x0]
80005c7a:	5e a4       	retle	r4
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	56 e4       	stdsp	sp[0x1b8],r4
80005c80:	80 00       	ld.sh	r0,r0[0x0]
80005c82:	5d 98       	*unknown*
80005c84:	80 00       	ld.sh	r0,r0[0x0]
80005c86:	5d 0c       	ror	r12
80005c88:	80 00       	ld.sh	r0,r0[0x0]
80005c8a:	60 34       	ld.w	r4,r0[0xc]
80005c8c:	80 00       	ld.sh	r0,r0[0x0]
80005c8e:	62 d4       	ld.w	r4,r1[0x34]
80005c90:	80 00       	ld.sh	r0,r0[0x0]
80005c92:	58 ec       	cp.w	r12,14
80005c94:	80 00       	ld.sh	r0,r0[0x0]
80005c96:	60 c8       	ld.w	r8,r0[0x30]

80005c98 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005c98:	d4 21       	pushm	r4-r7,lr
80005c9a:	18 97       	mov	r7,r12
80005c9c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005c9e:	58 0c       	cp.w	r12,0
80005ca0:	c2 f0       	breq	80005cfe <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005ca2:	34 cc       	mov	r12,76
80005ca4:	f0 1f 00 17 	mcall	80005d00 <xQueueCreate+0x68>
80005ca8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005caa:	c2 a0       	breq	80005cfe <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005cac:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005cb0:	e8 cc ff ff 	sub	r12,r4,-1
80005cb4:	f0 1f 00 13 	mcall	80005d00 <xQueueCreate+0x68>
80005cb8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005cba:	c1 e0       	breq	80005cf6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005cbc:	f8 04 00 04 	add	r4,r12,r4
80005cc0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005cc2:	30 08       	mov	r8,0
80005cc4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005cc6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005cc8:	ee c8 00 01 	sub	r8,r7,1
80005ccc:	ad 38       	mul	r8,r6
80005cce:	10 0c       	add	r12,r8
80005cd0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005cd2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005cd4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005cd8:	3f f8       	mov	r8,-1
80005cda:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005cde:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005ce2:	ea cc ff f0 	sub	r12,r5,-16
80005ce6:	f0 1f 00 08 	mcall	80005d04 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005cea:	ea cc ff dc 	sub	r12,r5,-36
80005cee:	f0 1f 00 06 	mcall	80005d04 <xQueueCreate+0x6c>
80005cf2:	0a 9c       	mov	r12,r5
80005cf4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005cf6:	0a 9c       	mov	r12,r5
80005cf8:	f0 1f 00 04 	mcall	80005d08 <xQueueCreate+0x70>
80005cfc:	d8 2a       	popm	r4-r7,pc,r12=0
80005cfe:	d8 2a       	popm	r4-r7,pc,r12=0
80005d00:	80 00       	ld.sh	r0,r0[0x0]
80005d02:	58 44       	cp.w	r4,4
80005d04:	80 00       	ld.sh	r0,r0[0x0]
80005d06:	54 b4       	stdsp	sp[0x12c],r4
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	58 1c       	cp.w	r12,1

80005d0c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005d0c:	48 38       	lddpc	r8,80005d18 <vTaskSuspendAll+0xc>
80005d0e:	70 09       	ld.w	r9,r8[0x0]
80005d10:	2f f9       	sub	r9,-1
80005d12:	91 09       	st.w	r8[0x0],r9
}
80005d14:	5e fc       	retal	r12
80005d16:	00 00       	add	r0,r0
80005d18:	00 00       	add	r0,r0
80005d1a:	0d 0c       	ld.w	r12,r6++

80005d1c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005d1c:	49 a8       	lddpc	r8,80005d84 <vTaskSwitchContext+0x68>
80005d1e:	70 08       	ld.w	r8,r8[0x0]
80005d20:	58 08       	cp.w	r8,0
80005d22:	c0 b1       	brne	80005d38 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d24:	49 98       	lddpc	r8,80005d88 <vTaskSwitchContext+0x6c>
80005d26:	70 08       	ld.w	r8,r8[0x0]
80005d28:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005d2c:	49 89       	lddpc	r9,80005d8c <vTaskSwitchContext+0x70>
80005d2e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005d32:	58 08       	cp.w	r8,0
80005d34:	c0 60       	breq	80005d40 <vTaskSwitchContext+0x24>
80005d36:	c1 18       	rjmp	80005d58 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005d38:	30 19       	mov	r9,1
80005d3a:	49 68       	lddpc	r8,80005d90 <vTaskSwitchContext+0x74>
80005d3c:	91 09       	st.w	r8[0x0],r9
80005d3e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005d40:	49 28       	lddpc	r8,80005d88 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d42:	49 3a       	lddpc	r10,80005d8c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005d44:	70 09       	ld.w	r9,r8[0x0]
80005d46:	20 19       	sub	r9,1
80005d48:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d4a:	70 09       	ld.w	r9,r8[0x0]
80005d4c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005d50:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005d54:	58 09       	cp.w	r9,0
80005d56:	cf 70       	breq	80005d44 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005d58:	48 c8       	lddpc	r8,80005d88 <vTaskSwitchContext+0x6c>
80005d5a:	70 08       	ld.w	r8,r8[0x0]
80005d5c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005d60:	48 b9       	lddpc	r9,80005d8c <vTaskSwitchContext+0x70>
80005d62:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005d66:	70 19       	ld.w	r9,r8[0x4]
80005d68:	72 19       	ld.w	r9,r9[0x4]
80005d6a:	91 19       	st.w	r8[0x4],r9
80005d6c:	f0 ca ff f8 	sub	r10,r8,-8
80005d70:	14 39       	cp.w	r9,r10
80005d72:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005d76:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005d7a:	70 18       	ld.w	r8,r8[0x4]
80005d7c:	70 39       	ld.w	r9,r8[0xc]
80005d7e:	48 68       	lddpc	r8,80005d94 <vTaskSwitchContext+0x78>
80005d80:	91 09       	st.w	r8[0x0],r9
80005d82:	5e fc       	retal	r12
80005d84:	00 00       	add	r0,r0
80005d86:	0d 0c       	ld.w	r12,r6++
80005d88:	00 00       	add	r0,r0
80005d8a:	0d 44       	ld.w	r4,--r6
80005d8c:	00 00       	add	r0,r0
80005d8e:	0c 28       	rsub	r8,r6
80005d90:	00 00       	add	r0,r0
80005d92:	0d 2c       	ld.uh	r12,r6++
80005d94:	00 00       	add	r0,r0
80005d96:	0c dc       	st.w	--r6,r12

80005d98 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005d98:	48 48       	lddpc	r8,80005da8 <vTaskSetTimeOutState+0x10>
80005d9a:	70 08       	ld.w	r8,r8[0x0]
80005d9c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005d9e:	48 48       	lddpc	r8,80005dac <vTaskSetTimeOutState+0x14>
80005da0:	70 08       	ld.w	r8,r8[0x0]
80005da2:	99 18       	st.w	r12[0x4],r8
}
80005da4:	5e fc       	retal	r12
80005da6:	00 00       	add	r0,r0
80005da8:	00 00       	add	r0,r0
80005daa:	0c 20       	rsub	r0,r6
80005dac:	00 00       	add	r0,r0
80005dae:	0d 08       	ld.w	r8,r6++

80005db0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005db0:	30 19       	mov	r9,1
80005db2:	48 28       	lddpc	r8,80005db8 <vTaskMissedYield+0x8>
80005db4:	91 09       	st.w	r8[0x0],r9
}
80005db6:	5e fc       	retal	r12
80005db8:	00 00       	add	r0,r0
80005dba:	0d 2c       	ld.uh	r12,r6++

80005dbc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005dbc:	48 28       	lddpc	r8,80005dc4 <xTaskGetCurrentTaskHandle+0x8>
80005dbe:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005dc0:	5e fc       	retal	r12
80005dc2:	00 00       	add	r0,r0
80005dc4:	00 00       	add	r0,r0
80005dc6:	0c dc       	st.w	--r6,r12

80005dc8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005dc8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005dcc:	58 0c       	cp.w	r12,0
80005dce:	c1 f0       	breq	80005e0c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005dd0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005dd2:	78 b9       	ld.w	r9,r12[0x2c]
80005dd4:	79 18       	ld.w	r8,r12[0x44]
80005dd6:	10 39       	cp.w	r9,r8
80005dd8:	c1 a0       	breq	80005e0c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005dda:	f8 c6 ff fc 	sub	r6,r12,-4
80005dde:	0c 9c       	mov	r12,r6
80005de0:	f0 1f 00 0c 	mcall	80005e10 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005de4:	6f 1c       	ld.w	r12,r7[0x44]
80005de6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005de8:	f8 08 11 08 	rsub	r8,r12,8
80005dec:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005dee:	48 a8       	lddpc	r8,80005e14 <vTaskPriorityDisinherit+0x4c>
80005df0:	70 08       	ld.w	r8,r8[0x0]
80005df2:	10 3c       	cp.w	r12,r8
80005df4:	e0 88 00 04 	brls	80005dfc <vTaskPriorityDisinherit+0x34>
80005df8:	48 78       	lddpc	r8,80005e14 <vTaskPriorityDisinherit+0x4c>
80005dfa:	91 0c       	st.w	r8[0x0],r12
80005dfc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e00:	0c 9b       	mov	r11,r6
80005e02:	48 68       	lddpc	r8,80005e18 <vTaskPriorityDisinherit+0x50>
80005e04:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005e08:	f0 1f 00 05 	mcall	80005e1c <vTaskPriorityDisinherit+0x54>
80005e0c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	55 1e       	stdsp	sp[0x144],lr
80005e14:	00 00       	add	r0,r0
80005e16:	0d 44       	ld.w	r4,--r6
80005e18:	00 00       	add	r0,r0
80005e1a:	0c 28       	rsub	r8,r6
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	54 ce       	stdsp	sp[0x130],lr

80005e20 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005e20:	eb cd 40 c0 	pushm	r6-r7,lr
80005e24:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005e26:	49 b8       	lddpc	r8,80005e90 <vTaskPriorityInherit+0x70>
80005e28:	70 08       	ld.w	r8,r8[0x0]
80005e2a:	78 b9       	ld.w	r9,r12[0x2c]
80005e2c:	70 b8       	ld.w	r8,r8[0x2c]
80005e2e:	10 39       	cp.w	r9,r8
80005e30:	c2 d2       	brcc	80005e8a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005e32:	49 88       	lddpc	r8,80005e90 <vTaskPriorityInherit+0x70>
80005e34:	70 08       	ld.w	r8,r8[0x0]
80005e36:	70 b8       	ld.w	r8,r8[0x2c]
80005e38:	f0 08 11 08 	rsub	r8,r8,8
80005e3c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005e3e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005e42:	49 59       	lddpc	r9,80005e94 <vTaskPriorityInherit+0x74>
80005e44:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005e48:	78 59       	ld.w	r9,r12[0x14]
80005e4a:	10 39       	cp.w	r9,r8
80005e4c:	c1 b1       	brne	80005e82 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005e4e:	f8 c6 ff fc 	sub	r6,r12,-4
80005e52:	0c 9c       	mov	r12,r6
80005e54:	f0 1f 00 11 	mcall	80005e98 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005e58:	48 e8       	lddpc	r8,80005e90 <vTaskPriorityInherit+0x70>
80005e5a:	70 08       	ld.w	r8,r8[0x0]
80005e5c:	70 bc       	ld.w	r12,r8[0x2c]
80005e5e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005e60:	48 f8       	lddpc	r8,80005e9c <vTaskPriorityInherit+0x7c>
80005e62:	70 08       	ld.w	r8,r8[0x0]
80005e64:	10 3c       	cp.w	r12,r8
80005e66:	e0 88 00 04 	brls	80005e6e <vTaskPriorityInherit+0x4e>
80005e6a:	48 d8       	lddpc	r8,80005e9c <vTaskPriorityInherit+0x7c>
80005e6c:	91 0c       	st.w	r8[0x0],r12
80005e6e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e72:	0c 9b       	mov	r11,r6
80005e74:	48 88       	lddpc	r8,80005e94 <vTaskPriorityInherit+0x74>
80005e76:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005e7a:	f0 1f 00 0a 	mcall	80005ea0 <vTaskPriorityInherit+0x80>
80005e7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005e82:	48 48       	lddpc	r8,80005e90 <vTaskPriorityInherit+0x70>
80005e84:	70 08       	ld.w	r8,r8[0x0]
80005e86:	70 b8       	ld.w	r8,r8[0x2c]
80005e88:	99 b8       	st.w	r12[0x2c],r8
80005e8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e8e:	00 00       	add	r0,r0
80005e90:	00 00       	add	r0,r0
80005e92:	0c dc       	st.w	--r6,r12
80005e94:	00 00       	add	r0,r0
80005e96:	0c 28       	rsub	r8,r6
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	55 1e       	stdsp	sp[0x144],lr
80005e9c:	00 00       	add	r0,r0
80005e9e:	0d 44       	ld.w	r4,--r6
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	54 ce       	stdsp	sp[0x130],lr

80005ea4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005ea4:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005ea8:	78 38       	ld.w	r8,r12[0xc]
80005eaa:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005eac:	ee c6 ff e8 	sub	r6,r7,-24
80005eb0:	0c 9c       	mov	r12,r6
80005eb2:	f0 1f 00 15 	mcall	80005f04 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005eb6:	49 58       	lddpc	r8,80005f08 <xTaskRemoveFromEventList+0x64>
80005eb8:	70 08       	ld.w	r8,r8[0x0]
80005eba:	58 08       	cp.w	r8,0
80005ebc:	c1 71       	brne	80005eea <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005ebe:	ee c6 ff fc 	sub	r6,r7,-4
80005ec2:	0c 9c       	mov	r12,r6
80005ec4:	f0 1f 00 10 	mcall	80005f04 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005ec8:	6e bc       	ld.w	r12,r7[0x2c]
80005eca:	49 18       	lddpc	r8,80005f0c <xTaskRemoveFromEventList+0x68>
80005ecc:	70 08       	ld.w	r8,r8[0x0]
80005ece:	10 3c       	cp.w	r12,r8
80005ed0:	e0 88 00 04 	brls	80005ed8 <xTaskRemoveFromEventList+0x34>
80005ed4:	48 e8       	lddpc	r8,80005f0c <xTaskRemoveFromEventList+0x68>
80005ed6:	91 0c       	st.w	r8[0x0],r12
80005ed8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005edc:	0c 9b       	mov	r11,r6
80005ede:	48 d8       	lddpc	r8,80005f10 <xTaskRemoveFromEventList+0x6c>
80005ee0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005ee4:	f0 1f 00 0c 	mcall	80005f14 <xTaskRemoveFromEventList+0x70>
80005ee8:	c0 58       	rjmp	80005ef2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005eea:	0c 9b       	mov	r11,r6
80005eec:	48 bc       	lddpc	r12,80005f18 <xTaskRemoveFromEventList+0x74>
80005eee:	f0 1f 00 0a 	mcall	80005f14 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005ef2:	48 b8       	lddpc	r8,80005f1c <xTaskRemoveFromEventList+0x78>
80005ef4:	70 08       	ld.w	r8,r8[0x0]
80005ef6:	6e b9       	ld.w	r9,r7[0x2c]
80005ef8:	70 b8       	ld.w	r8,r8[0x2c]
80005efa:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005efc:	5f 2c       	srhs	r12
80005efe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f02:	00 00       	add	r0,r0
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	55 1e       	stdsp	sp[0x144],lr
80005f08:	00 00       	add	r0,r0
80005f0a:	0d 0c       	ld.w	r12,r6++
80005f0c:	00 00       	add	r0,r0
80005f0e:	0d 44       	ld.w	r4,--r6
80005f10:	00 00       	add	r0,r0
80005f12:	0c 28       	rsub	r8,r6
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	54 ce       	stdsp	sp[0x130],lr
80005f18:	00 00       	add	r0,r0
80005f1a:	0c e0       	st.h	--r6,r0
80005f1c:	00 00       	add	r0,r0
80005f1e:	0c dc       	st.w	--r6,r12

80005f20 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005f20:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005f24:	4b 98       	lddpc	r8,80006008 <vTaskIncrementTick+0xe8>
80005f26:	70 08       	ld.w	r8,r8[0x0]
80005f28:	58 08       	cp.w	r8,0
80005f2a:	c6 91       	brne	80005ffc <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005f2c:	4b 88       	lddpc	r8,8000600c <vTaskIncrementTick+0xec>
80005f2e:	70 09       	ld.w	r9,r8[0x0]
80005f30:	2f f9       	sub	r9,-1
80005f32:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005f34:	70 08       	ld.w	r8,r8[0x0]
80005f36:	58 08       	cp.w	r8,0
80005f38:	c1 a1       	brne	80005f6c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005f3a:	4b 68       	lddpc	r8,80006010 <vTaskIncrementTick+0xf0>
80005f3c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005f3e:	4b 69       	lddpc	r9,80006014 <vTaskIncrementTick+0xf4>
80005f40:	72 0b       	ld.w	r11,r9[0x0]
80005f42:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005f44:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005f46:	4b 59       	lddpc	r9,80006018 <vTaskIncrementTick+0xf8>
80005f48:	72 0a       	ld.w	r10,r9[0x0]
80005f4a:	2f fa       	sub	r10,-1
80005f4c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005f4e:	70 08       	ld.w	r8,r8[0x0]
80005f50:	70 08       	ld.w	r8,r8[0x0]
80005f52:	58 08       	cp.w	r8,0
80005f54:	c0 51       	brne	80005f5e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005f56:	3f f9       	mov	r9,-1
80005f58:	4b 18       	lddpc	r8,8000601c <vTaskIncrementTick+0xfc>
80005f5a:	91 09       	st.w	r8[0x0],r9
80005f5c:	c0 88       	rjmp	80005f6c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005f5e:	4a d8       	lddpc	r8,80006010 <vTaskIncrementTick+0xf0>
80005f60:	70 08       	ld.w	r8,r8[0x0]
80005f62:	70 38       	ld.w	r8,r8[0xc]
80005f64:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005f66:	70 19       	ld.w	r9,r8[0x4]
80005f68:	4a d8       	lddpc	r8,8000601c <vTaskIncrementTick+0xfc>
80005f6a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005f6c:	4a 88       	lddpc	r8,8000600c <vTaskIncrementTick+0xec>
80005f6e:	70 09       	ld.w	r9,r8[0x0]
80005f70:	4a b8       	lddpc	r8,8000601c <vTaskIncrementTick+0xfc>
80005f72:	70 08       	ld.w	r8,r8[0x0]
80005f74:	10 39       	cp.w	r9,r8
80005f76:	c4 73       	brcs	80006004 <vTaskIncrementTick+0xe4>
80005f78:	4a 68       	lddpc	r8,80006010 <vTaskIncrementTick+0xf0>
80005f7a:	70 08       	ld.w	r8,r8[0x0]
80005f7c:	70 08       	ld.w	r8,r8[0x0]
80005f7e:	58 08       	cp.w	r8,0
80005f80:	c0 c0       	breq	80005f98 <vTaskIncrementTick+0x78>
80005f82:	4a 48       	lddpc	r8,80006010 <vTaskIncrementTick+0xf0>
80005f84:	70 08       	ld.w	r8,r8[0x0]
80005f86:	70 38       	ld.w	r8,r8[0xc]
80005f88:	70 37       	ld.w	r7,r8[0xc]
80005f8a:	6e 18       	ld.w	r8,r7[0x4]
80005f8c:	4a 09       	lddpc	r9,8000600c <vTaskIncrementTick+0xec>
80005f8e:	72 09       	ld.w	r9,r9[0x0]
80005f90:	12 38       	cp.w	r8,r9
80005f92:	e0 88 00 14 	brls	80005fba <vTaskIncrementTick+0x9a>
80005f96:	c0 e8       	rjmp	80005fb2 <vTaskIncrementTick+0x92>
80005f98:	3f f9       	mov	r9,-1
80005f9a:	4a 18       	lddpc	r8,8000601c <vTaskIncrementTick+0xfc>
80005f9c:	91 09       	st.w	r8[0x0],r9
80005f9e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005fa2:	6a 08       	ld.w	r8,r5[0x0]
80005fa4:	70 38       	ld.w	r8,r8[0xc]
80005fa6:	70 37       	ld.w	r7,r8[0xc]
80005fa8:	6e 18       	ld.w	r8,r7[0x4]
80005faa:	64 09       	ld.w	r9,r2[0x0]
80005fac:	12 38       	cp.w	r8,r9
80005fae:	e0 88 00 0a 	brls	80005fc2 <vTaskIncrementTick+0xa2>
80005fb2:	49 b9       	lddpc	r9,8000601c <vTaskIncrementTick+0xfc>
80005fb4:	93 08       	st.w	r9[0x0],r8
80005fb6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005fba:	49 a4       	lddpc	r4,80006020 <vTaskIncrementTick+0x100>
80005fbc:	49 a3       	lddpc	r3,80006024 <vTaskIncrementTick+0x104>
80005fbe:	49 55       	lddpc	r5,80006010 <vTaskIncrementTick+0xf0>
80005fc0:	49 32       	lddpc	r2,8000600c <vTaskIncrementTick+0xec>
80005fc2:	ee c6 ff fc 	sub	r6,r7,-4
80005fc6:	0c 9c       	mov	r12,r6
80005fc8:	f0 1f 00 18 	mcall	80006028 <vTaskIncrementTick+0x108>
80005fcc:	6e a8       	ld.w	r8,r7[0x28]
80005fce:	58 08       	cp.w	r8,0
80005fd0:	c0 50       	breq	80005fda <vTaskIncrementTick+0xba>
80005fd2:	ee cc ff e8 	sub	r12,r7,-24
80005fd6:	f0 1f 00 15 	mcall	80006028 <vTaskIncrementTick+0x108>
80005fda:	6e bc       	ld.w	r12,r7[0x2c]
80005fdc:	68 08       	ld.w	r8,r4[0x0]
80005fde:	10 3c       	cp.w	r12,r8
80005fe0:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005fe4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005fe8:	0c 9b       	mov	r11,r6
80005fea:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005fee:	f0 1f 00 10 	mcall	8000602c <vTaskIncrementTick+0x10c>
80005ff2:	6a 08       	ld.w	r8,r5[0x0]
80005ff4:	70 08       	ld.w	r8,r8[0x0]
80005ff6:	58 08       	cp.w	r8,0
80005ff8:	cd 51       	brne	80005fa2 <vTaskIncrementTick+0x82>
80005ffa:	cc fb       	rjmp	80005f98 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005ffc:	48 d8       	lddpc	r8,80006030 <vTaskIncrementTick+0x110>
80005ffe:	70 09       	ld.w	r9,r8[0x0]
80006000:	2f f9       	sub	r9,-1
80006002:	91 09       	st.w	r8[0x0],r9
80006004:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006008:	00 00       	add	r0,r0
8000600a:	0d 0c       	ld.w	r12,r6++
8000600c:	00 00       	add	r0,r0
8000600e:	0d 08       	ld.w	r8,r6++
80006010:	00 00       	add	r0,r0
80006012:	0c 14       	sub	r4,r6
80006014:	00 00       	add	r0,r0
80006016:	0c 24       	rsub	r4,r6
80006018:	00 00       	add	r0,r0
8000601a:	0c 20       	rsub	r0,r6
8000601c:	00 00       	add	r0,r0
8000601e:	05 34       	ld.ub	r4,r2++
80006020:	00 00       	add	r0,r0
80006022:	0d 44       	ld.w	r4,--r6
80006024:	00 00       	add	r0,r0
80006026:	0c 28       	rsub	r8,r6
80006028:	80 00       	ld.sh	r0,r0[0x0]
8000602a:	55 1e       	stdsp	sp[0x144],lr
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	54 ce       	stdsp	sp[0x130],lr
80006030:	00 00       	add	r0,r0
80006032:	0c 0c       	add	r12,r6

80006034 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006034:	eb cd 40 c0 	pushm	r6-r7,lr
80006038:	18 97       	mov	r7,r12
8000603a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000603c:	f0 1f 00 15 	mcall	80006090 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006040:	6c 08       	ld.w	r8,r6[0x0]
80006042:	5b f8       	cp.w	r8,-1
80006044:	c0 31       	brne	8000604a <xTaskCheckForTimeOut+0x16>
80006046:	30 07       	mov	r7,0
80006048:	c1 f8       	rjmp	80006086 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000604a:	49 39       	lddpc	r9,80006094 <xTaskCheckForTimeOut+0x60>
8000604c:	72 09       	ld.w	r9,r9[0x0]
8000604e:	6e 0a       	ld.w	r10,r7[0x0]
80006050:	12 3a       	cp.w	r10,r9
80006052:	c0 70       	breq	80006060 <xTaskCheckForTimeOut+0x2c>
80006054:	49 19       	lddpc	r9,80006098 <xTaskCheckForTimeOut+0x64>
80006056:	72 09       	ld.w	r9,r9[0x0]
80006058:	6e 1a       	ld.w	r10,r7[0x4]
8000605a:	12 3a       	cp.w	r10,r9
8000605c:	e0 88 00 14 	brls	80006084 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006060:	48 e9       	lddpc	r9,80006098 <xTaskCheckForTimeOut+0x64>
80006062:	72 0a       	ld.w	r10,r9[0x0]
80006064:	6e 19       	ld.w	r9,r7[0x4]
80006066:	12 1a       	sub	r10,r9
80006068:	14 38       	cp.w	r8,r10
8000606a:	e0 88 00 0d 	brls	80006084 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000606e:	48 ba       	lddpc	r10,80006098 <xTaskCheckForTimeOut+0x64>
80006070:	74 0a       	ld.w	r10,r10[0x0]
80006072:	14 19       	sub	r9,r10
80006074:	f2 08 00 08 	add	r8,r9,r8
80006078:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000607a:	0e 9c       	mov	r12,r7
8000607c:	f0 1f 00 08 	mcall	8000609c <xTaskCheckForTimeOut+0x68>
80006080:	30 07       	mov	r7,0
80006082:	c0 28       	rjmp	80006086 <xTaskCheckForTimeOut+0x52>
80006084:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006086:	f0 1f 00 07 	mcall	800060a0 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000608a:	0e 9c       	mov	r12,r7
8000608c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	55 d8       	stdsp	sp[0x174],r8
80006094:	00 00       	add	r0,r0
80006096:	0c 20       	rsub	r0,r6
80006098:	00 00       	add	r0,r0
8000609a:	0d 08       	ld.w	r8,r6++
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	5d 98       	*unknown*
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	56 e4       	stdsp	sp[0x1b8],r4

800060a4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800060a4:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800060a8:	f0 1f 00 05 	mcall	800060bc <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800060ac:	48 58       	lddpc	r8,800060c0 <xTaskGetTickCount+0x1c>
800060ae:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800060b0:	f0 1f 00 05 	mcall	800060c4 <xTaskGetTickCount+0x20>

	return xTicks;
}
800060b4:	0e 9c       	mov	r12,r7
800060b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800060ba:	00 00       	add	r0,r0
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	55 d8       	stdsp	sp[0x174],r8
800060c0:	00 00       	add	r0,r0
800060c2:	0d 08       	ld.w	r8,r6++
800060c4:	80 00       	ld.sh	r0,r0[0x0]
800060c6:	56 e4       	stdsp	sp[0x1b8],r4

800060c8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800060c8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800060cc:	f0 1f 00 2c 	mcall	8000617c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800060d0:	4a c8       	lddpc	r8,80006180 <xTaskResumeAll+0xb8>
800060d2:	70 09       	ld.w	r9,r8[0x0]
800060d4:	20 19       	sub	r9,1
800060d6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800060d8:	70 08       	ld.w	r8,r8[0x0]
800060da:	58 08       	cp.w	r8,0
800060dc:	c4 91       	brne	8000616e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800060de:	4a a8       	lddpc	r8,80006184 <xTaskResumeAll+0xbc>
800060e0:	70 08       	ld.w	r8,r8[0x0]
800060e2:	58 08       	cp.w	r8,0
800060e4:	c4 50       	breq	8000616e <xTaskResumeAll+0xa6>
800060e6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800060e8:	4a 85       	lddpc	r5,80006188 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800060ea:	4a 93       	lddpc	r3,8000618c <xTaskResumeAll+0xc4>
800060ec:	4a 92       	lddpc	r2,80006190 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800060ee:	4a a1       	lddpc	r1,80006194 <xTaskResumeAll+0xcc>
800060f0:	c1 e8       	rjmp	8000612c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800060f2:	6a 38       	ld.w	r8,r5[0xc]
800060f4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800060f6:	ee cc ff e8 	sub	r12,r7,-24
800060fa:	f0 1f 00 28 	mcall	80006198 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800060fe:	ee c6 ff fc 	sub	r6,r7,-4
80006102:	0c 9c       	mov	r12,r6
80006104:	f0 1f 00 25 	mcall	80006198 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006108:	6e bc       	ld.w	r12,r7[0x2c]
8000610a:	66 08       	ld.w	r8,r3[0x0]
8000610c:	10 3c       	cp.w	r12,r8
8000610e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006112:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006116:	0c 9b       	mov	r11,r6
80006118:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000611c:	f0 1f 00 20 	mcall	8000619c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006120:	62 08       	ld.w	r8,r1[0x0]
80006122:	6e b9       	ld.w	r9,r7[0x2c]
80006124:	70 b8       	ld.w	r8,r8[0x2c]
80006126:	10 39       	cp.w	r9,r8
80006128:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000612c:	6a 08       	ld.w	r8,r5[0x0]
8000612e:	58 08       	cp.w	r8,0
80006130:	ce 11       	brne	800060f2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006132:	49 c8       	lddpc	r8,800061a0 <xTaskResumeAll+0xd8>
80006134:	70 08       	ld.w	r8,r8[0x0]
80006136:	58 08       	cp.w	r8,0
80006138:	c0 f0       	breq	80006156 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000613a:	49 a8       	lddpc	r8,800061a0 <xTaskResumeAll+0xd8>
8000613c:	70 08       	ld.w	r8,r8[0x0]
8000613e:	58 08       	cp.w	r8,0
80006140:	c1 10       	breq	80006162 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006142:	49 87       	lddpc	r7,800061a0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006144:	f0 1f 00 18 	mcall	800061a4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006148:	6e 08       	ld.w	r8,r7[0x0]
8000614a:	20 18       	sub	r8,1
8000614c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000614e:	6e 08       	ld.w	r8,r7[0x0]
80006150:	58 08       	cp.w	r8,0
80006152:	cf 91       	brne	80006144 <xTaskResumeAll+0x7c>
80006154:	c0 78       	rjmp	80006162 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006156:	58 14       	cp.w	r4,1
80006158:	c0 50       	breq	80006162 <xTaskResumeAll+0x9a>
8000615a:	49 48       	lddpc	r8,800061a8 <xTaskResumeAll+0xe0>
8000615c:	70 08       	ld.w	r8,r8[0x0]
8000615e:	58 18       	cp.w	r8,1
80006160:	c0 71       	brne	8000616e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006162:	30 09       	mov	r9,0
80006164:	49 18       	lddpc	r8,800061a8 <xTaskResumeAll+0xe0>
80006166:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006168:	d7 33       	scall
8000616a:	30 17       	mov	r7,1
8000616c:	c0 28       	rjmp	80006170 <xTaskResumeAll+0xa8>
8000616e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006170:	f0 1f 00 0f 	mcall	800061ac <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006174:	0e 9c       	mov	r12,r7
80006176:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000617a:	00 00       	add	r0,r0
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	55 d8       	stdsp	sp[0x174],r8
80006180:	00 00       	add	r0,r0
80006182:	0d 0c       	ld.w	r12,r6++
80006184:	00 00       	add	r0,r0
80006186:	0d 28       	ld.uh	r8,r6++
80006188:	00 00       	add	r0,r0
8000618a:	0c e0       	st.h	--r6,r0
8000618c:	00 00       	add	r0,r0
8000618e:	0d 44       	ld.w	r4,--r6
80006190:	00 00       	add	r0,r0
80006192:	0c 28       	rsub	r8,r6
80006194:	00 00       	add	r0,r0
80006196:	0c dc       	st.w	--r6,r12
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	55 1e       	stdsp	sp[0x144],lr
8000619c:	80 00       	ld.sh	r0,r0[0x0]
8000619e:	54 ce       	stdsp	sp[0x130],lr
800061a0:	00 00       	add	r0,r0
800061a2:	0c 0c       	add	r12,r6
800061a4:	80 00       	ld.sh	r0,r0[0x0]
800061a6:	5f 20       	srhs	r0
800061a8:	00 00       	add	r0,r0
800061aa:	0d 2c       	ld.uh	r12,r6++
800061ac:	80 00       	ld.sh	r0,r0[0x0]
800061ae:	56 e4       	stdsp	sp[0x1b8],r4

800061b0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800061b0:	eb cd 40 80 	pushm	r7,lr
800061b4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800061b6:	49 08       	lddpc	r8,800061f4 <prvAddCurrentTaskToDelayedList+0x44>
800061b8:	70 08       	ld.w	r8,r8[0x0]
800061ba:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800061bc:	48 f8       	lddpc	r8,800061f8 <prvAddCurrentTaskToDelayedList+0x48>
800061be:	70 08       	ld.w	r8,r8[0x0]
800061c0:	10 3c       	cp.w	r12,r8
800061c2:	c0 a2       	brcc	800061d6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800061c4:	48 c8       	lddpc	r8,800061f4 <prvAddCurrentTaskToDelayedList+0x44>
800061c6:	70 0b       	ld.w	r11,r8[0x0]
800061c8:	48 d8       	lddpc	r8,800061fc <prvAddCurrentTaskToDelayedList+0x4c>
800061ca:	70 0c       	ld.w	r12,r8[0x0]
800061cc:	2f cb       	sub	r11,-4
800061ce:	f0 1f 00 0d 	mcall	80006200 <prvAddCurrentTaskToDelayedList+0x50>
800061d2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800061d6:	48 88       	lddpc	r8,800061f4 <prvAddCurrentTaskToDelayedList+0x44>
800061d8:	70 0b       	ld.w	r11,r8[0x0]
800061da:	48 b8       	lddpc	r8,80006204 <prvAddCurrentTaskToDelayedList+0x54>
800061dc:	70 0c       	ld.w	r12,r8[0x0]
800061de:	2f cb       	sub	r11,-4
800061e0:	f0 1f 00 08 	mcall	80006200 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800061e4:	48 98       	lddpc	r8,80006208 <prvAddCurrentTaskToDelayedList+0x58>
800061e6:	70 08       	ld.w	r8,r8[0x0]
800061e8:	10 37       	cp.w	r7,r8
800061ea:	c0 32       	brcc	800061f0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800061ec:	48 78       	lddpc	r8,80006208 <prvAddCurrentTaskToDelayedList+0x58>
800061ee:	91 07       	st.w	r8[0x0],r7
800061f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800061f4:	00 00       	add	r0,r0
800061f6:	0c dc       	st.w	--r6,r12
800061f8:	00 00       	add	r0,r0
800061fa:	0d 08       	ld.w	r8,r6++
800061fc:	00 00       	add	r0,r0
800061fe:	0c 24       	rsub	r4,r6
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	54 ea       	stdsp	sp[0x138],r10
80006204:	00 00       	add	r0,r0
80006206:	0c 14       	sub	r4,r6
80006208:	00 00       	add	r0,r0
8000620a:	05 34       	ld.ub	r4,r2++

8000620c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
8000620c:	eb cd 40 c0 	pushm	r6-r7,lr
80006210:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006212:	58 0c       	cp.w	r12,0
80006214:	c1 10       	breq	80006236 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006216:	f0 1f 00 0a 	mcall	8000623c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000621a:	48 a8       	lddpc	r8,80006240 <vTaskDelay+0x34>
8000621c:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000621e:	48 a8       	lddpc	r8,80006244 <vTaskDelay+0x38>
80006220:	70 0c       	ld.w	r12,r8[0x0]
80006222:	2f cc       	sub	r12,-4
80006224:	f0 1f 00 09 	mcall	80006248 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006228:	ee 06 00 0c 	add	r12,r7,r6
8000622c:	f0 1f 00 08 	mcall	8000624c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006230:	f0 1f 00 08 	mcall	80006250 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006234:	c0 21       	brne	80006238 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006236:	d7 33       	scall
80006238:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	5d 0c       	ror	r12
80006240:	00 00       	add	r0,r0
80006242:	0d 08       	ld.w	r8,r6++
80006244:	00 00       	add	r0,r0
80006246:	0c dc       	st.w	--r6,r12
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	55 1e       	stdsp	sp[0x144],lr
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	61 b0       	ld.w	r0,r0[0x6c]
80006250:	80 00       	ld.sh	r0,r0[0x0]
80006252:	60 c8       	ld.w	r8,r0[0x30]

80006254 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006254:	eb cd 40 c0 	pushm	r6-r7,lr
80006258:	18 96       	mov	r6,r12
8000625a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000625c:	f0 1f 00 18 	mcall	800062bc <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006260:	6c 08       	ld.w	r8,r6[0x0]
80006262:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006264:	49 79       	lddpc	r9,800062c0 <vTaskDelayUntil+0x6c>
80006266:	72 09       	ld.w	r9,r9[0x0]
80006268:	12 38       	cp.w	r8,r9
8000626a:	e0 88 00 0c 	brls	80006282 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000626e:	0e 38       	cp.w	r8,r7
80006270:	e0 88 00 22 	brls	800062b4 <vTaskDelayUntil+0x60>
80006274:	49 38       	lddpc	r8,800062c0 <vTaskDelayUntil+0x6c>
80006276:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006278:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000627a:	10 37       	cp.w	r7,r8
8000627c:	e0 88 00 14 	brls	800062a4 <vTaskDelayUntil+0x50>
80006280:	c0 a8       	rjmp	80006294 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006282:	0e 38       	cp.w	r8,r7
80006284:	e0 8b 00 16 	brhi	800062b0 <vTaskDelayUntil+0x5c>
80006288:	48 e8       	lddpc	r8,800062c0 <vTaskDelayUntil+0x6c>
8000628a:	70 08       	ld.w	r8,r8[0x0]
8000628c:	10 37       	cp.w	r7,r8
8000628e:	e0 8b 00 11 	brhi	800062b0 <vTaskDelayUntil+0x5c>
80006292:	c1 18       	rjmp	800062b4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006294:	48 c8       	lddpc	r8,800062c4 <vTaskDelayUntil+0x70>
80006296:	70 0c       	ld.w	r12,r8[0x0]
80006298:	2f cc       	sub	r12,-4
8000629a:	f0 1f 00 0c 	mcall	800062c8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000629e:	0e 9c       	mov	r12,r7
800062a0:	f0 1f 00 0b 	mcall	800062cc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800062a4:	f0 1f 00 0b 	mcall	800062d0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800062a8:	c0 81       	brne	800062b8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800062aa:	d7 33       	scall
800062ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800062b0:	8d 07       	st.w	r6[0x0],r7
800062b2:	cf 1b       	rjmp	80006294 <vTaskDelayUntil+0x40>
800062b4:	8d 07       	st.w	r6[0x0],r7
800062b6:	cf 7b       	rjmp	800062a4 <vTaskDelayUntil+0x50>
800062b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	5d 0c       	ror	r12
800062c0:	00 00       	add	r0,r0
800062c2:	0d 08       	ld.w	r8,r6++
800062c4:	00 00       	add	r0,r0
800062c6:	0c dc       	st.w	--r6,r12
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	55 1e       	stdsp	sp[0x144],lr
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	61 b0       	ld.w	r0,r0[0x6c]
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	60 c8       	ld.w	r8,r0[0x30]

800062d4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800062d4:	eb cd 40 c0 	pushm	r6-r7,lr
800062d8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800062da:	48 e7       	lddpc	r7,80006310 <vTaskPlaceOnEventList+0x3c>
800062dc:	6e 0b       	ld.w	r11,r7[0x0]
800062de:	2e 8b       	sub	r11,-24
800062e0:	f0 1f 00 0d 	mcall	80006314 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800062e4:	6e 0c       	ld.w	r12,r7[0x0]
800062e6:	2f cc       	sub	r12,-4
800062e8:	f0 1f 00 0c 	mcall	80006318 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800062ec:	5b f6       	cp.w	r6,-1
800062ee:	c0 81       	brne	800062fe <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800062f0:	6e 0b       	ld.w	r11,r7[0x0]
800062f2:	2f cb       	sub	r11,-4
800062f4:	48 ac       	lddpc	r12,8000631c <vTaskPlaceOnEventList+0x48>
800062f6:	f0 1f 00 0b 	mcall	80006320 <vTaskPlaceOnEventList+0x4c>
800062fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800062fe:	48 a8       	lddpc	r8,80006324 <vTaskPlaceOnEventList+0x50>
80006300:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006302:	ec 0c 00 0c 	add	r12,r6,r12
80006306:	f0 1f 00 09 	mcall	80006328 <vTaskPlaceOnEventList+0x54>
8000630a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000630e:	00 00       	add	r0,r0
80006310:	00 00       	add	r0,r0
80006312:	0c dc       	st.w	--r6,r12
80006314:	80 00       	ld.sh	r0,r0[0x0]
80006316:	54 ea       	stdsp	sp[0x138],r10
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	55 1e       	stdsp	sp[0x144],lr
8000631c:	00 00       	add	r0,r0
8000631e:	0d 30       	ld.ub	r0,r6++
80006320:	80 00       	ld.sh	r0,r0[0x0]
80006322:	54 ce       	stdsp	sp[0x130],lr
80006324:	00 00       	add	r0,r0
80006326:	0d 08       	ld.w	r8,r6++
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	61 b0       	ld.w	r0,r0[0x6c]

8000632c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000632c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006330:	49 67       	lddpc	r7,80006388 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006332:	49 74       	lddpc	r4,8000638c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006334:	49 73       	lddpc	r3,80006390 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006336:	49 85       	lddpc	r5,80006394 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006338:	6e 08       	ld.w	r8,r7[0x0]
8000633a:	58 08       	cp.w	r8,0
8000633c:	c1 e0       	breq	80006378 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000633e:	f0 1f 00 17 	mcall	80006398 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006342:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006344:	f0 1f 00 16 	mcall	8000639c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006348:	58 06       	cp.w	r6,0
8000634a:	c1 70       	breq	80006378 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000634c:	f0 1f 00 15 	mcall	800063a0 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006350:	68 38       	ld.w	r8,r4[0xc]
80006352:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006354:	ec cc ff fc 	sub	r12,r6,-4
80006358:	f0 1f 00 13 	mcall	800063a4 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
8000635c:	66 08       	ld.w	r8,r3[0x0]
8000635e:	20 18       	sub	r8,1
80006360:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006362:	6e 08       	ld.w	r8,r7[0x0]
80006364:	20 18       	sub	r8,1
80006366:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006368:	f0 1f 00 10 	mcall	800063a8 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000636c:	6c cc       	ld.w	r12,r6[0x30]
8000636e:	f0 1f 00 10 	mcall	800063ac <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006372:	0c 9c       	mov	r12,r6
80006374:	f0 1f 00 0e 	mcall	800063ac <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006378:	6a 08       	ld.w	r8,r5[0x0]
8000637a:	58 18       	cp.w	r8,1
8000637c:	e0 88 00 03 	brls	80006382 <prvIdleTask+0x56>
			{
				taskYIELD();
80006380:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006382:	f0 1f 00 0c 	mcall	800063b0 <prvIdleTask+0x84>
		}
		#endif
	}
80006386:	cd 9b       	rjmp	80006338 <prvIdleTask+0xc>
80006388:	00 00       	add	r0,r0
8000638a:	0c 1c       	sub	r12,r6
8000638c:	00 00       	add	r0,r0
8000638e:	0c c8       	st.b	r6++,r8
80006390:	00 00       	add	r0,r0
80006392:	0d 28       	ld.uh	r8,r6++
80006394:	00 00       	add	r0,r0
80006396:	0c 28       	rsub	r8,r6
80006398:	80 00       	ld.sh	r0,r0[0x0]
8000639a:	5d 0c       	ror	r12
8000639c:	80 00       	ld.sh	r0,r0[0x0]
8000639e:	60 c8       	ld.w	r8,r0[0x30]
800063a0:	80 00       	ld.sh	r0,r0[0x0]
800063a2:	55 d8       	stdsp	sp[0x174],r8
800063a4:	80 00       	ld.sh	r0,r0[0x0]
800063a6:	55 1e       	stdsp	sp[0x144],lr
800063a8:	80 00       	ld.sh	r0,r0[0x0]
800063aa:	56 e4       	stdsp	sp[0x1b8],r4
800063ac:	80 00       	ld.sh	r0,r0[0x0]
800063ae:	58 1c       	cp.w	r12,1
800063b0:	80 00       	ld.sh	r0,r0[0x0]
800063b2:	20 2c       	sub	r12,2

800063b4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800063b4:	d4 31       	pushm	r0-r7,lr
800063b6:	20 1d       	sub	sp,4
800063b8:	fa c4 ff d8 	sub	r4,sp,-40
800063bc:	50 0c       	stdsp	sp[0x0],r12
800063be:	16 91       	mov	r1,r11
800063c0:	14 97       	mov	r7,r10
800063c2:	12 90       	mov	r0,r9
800063c4:	10 93       	mov	r3,r8
800063c6:	68 02       	ld.w	r2,r4[0x0]
800063c8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800063ca:	34 8c       	mov	r12,72
800063cc:	f0 1f 00 5c 	mcall	8000653c <xTaskGenericCreate+0x188>
800063d0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800063d2:	c0 31       	brne	800063d8 <xTaskGenericCreate+0x24>
800063d4:	3f fc       	mov	r12,-1
800063d6:	ca f8       	rjmp	80006534 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800063d8:	58 06       	cp.w	r6,0
800063da:	e0 81 00 af 	brne	80006538 <xTaskGenericCreate+0x184>
800063de:	0e 9c       	mov	r12,r7
800063e0:	5c 7c       	castu.h	r12
800063e2:	a3 6c       	lsl	r12,0x2
800063e4:	f0 1f 00 56 	mcall	8000653c <xTaskGenericCreate+0x188>
800063e8:	18 96       	mov	r6,r12
800063ea:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800063ec:	c0 61       	brne	800063f8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800063ee:	0a 9c       	mov	r12,r5
800063f0:	f0 1f 00 54 	mcall	80006540 <xTaskGenericCreate+0x18c>
800063f4:	3f fc       	mov	r12,-1
800063f6:	c9 f8       	rjmp	80006534 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800063f8:	5c 77       	castu.h	r7
800063fa:	ee 0a 15 02 	lsl	r10,r7,0x2
800063fe:	e0 6b 00 a5 	mov	r11,165
80006402:	0c 9c       	mov	r12,r6
80006404:	f0 1f 00 50 	mcall	80006544 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006408:	ee c6 00 01 	sub	r6,r7,1
8000640c:	6a c8       	ld.w	r8,r5[0x30]
8000640e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006412:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006416:	31 0a       	mov	r10,16
80006418:	02 9b       	mov	r11,r1
8000641a:	ea cc ff cc 	sub	r12,r5,-52
8000641e:	f0 1f 00 4b 	mcall	80006548 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006422:	30 08       	mov	r8,0
80006424:	eb 68 00 43 	st.b	r5[67],r8
80006428:	58 73       	cp.w	r3,7
8000642a:	e6 07 17 80 	movls	r7,r3
8000642e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006432:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006434:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006438:	ea c4 ff fc 	sub	r4,r5,-4
8000643c:	08 9c       	mov	r12,r4
8000643e:	f0 1f 00 44 	mcall	8000654c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006442:	ea cc ff e8 	sub	r12,r5,-24
80006446:	f0 1f 00 42 	mcall	8000654c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000644a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000644c:	ee 07 11 08 	rsub	r7,r7,8
80006450:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006452:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006454:	00 9a       	mov	r10,r0
80006456:	40 0b       	lddsp	r11,sp[0x0]
80006458:	0c 9c       	mov	r12,r6
8000645a:	f0 1f 00 3e 	mcall	80006550 <xTaskGenericCreate+0x19c>
8000645e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006460:	58 02       	cp.w	r2,0
80006462:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006466:	f0 1f 00 3c 	mcall	80006554 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000646a:	4b c8       	lddpc	r8,80006558 <xTaskGenericCreate+0x1a4>
8000646c:	70 09       	ld.w	r9,r8[0x0]
8000646e:	2f f9       	sub	r9,-1
80006470:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006472:	4b b8       	lddpc	r8,8000655c <xTaskGenericCreate+0x1a8>
80006474:	70 08       	ld.w	r8,r8[0x0]
80006476:	58 08       	cp.w	r8,0
80006478:	c2 61       	brne	800064c4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000647a:	4b 98       	lddpc	r8,8000655c <xTaskGenericCreate+0x1a8>
8000647c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000647e:	4b 78       	lddpc	r8,80006558 <xTaskGenericCreate+0x1a4>
80006480:	70 08       	ld.w	r8,r8[0x0]
80006482:	58 18       	cp.w	r8,1
80006484:	c2 b1       	brne	800064da <xTaskGenericCreate+0x126>
80006486:	4b 77       	lddpc	r7,80006560 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006488:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000648c:	0e 9c       	mov	r12,r7
8000648e:	f0 1f 00 36 	mcall	80006564 <xTaskGenericCreate+0x1b0>
80006492:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006494:	0c 37       	cp.w	r7,r6
80006496:	cf b1       	brne	8000648c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006498:	4b 47       	lddpc	r7,80006568 <xTaskGenericCreate+0x1b4>
8000649a:	0e 9c       	mov	r12,r7
8000649c:	f0 1f 00 32 	mcall	80006564 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800064a0:	4b 36       	lddpc	r6,8000656c <xTaskGenericCreate+0x1b8>
800064a2:	0c 9c       	mov	r12,r6
800064a4:	f0 1f 00 30 	mcall	80006564 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800064a8:	4b 2c       	lddpc	r12,80006570 <xTaskGenericCreate+0x1bc>
800064aa:	f0 1f 00 2f 	mcall	80006564 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800064ae:	4b 2c       	lddpc	r12,80006574 <xTaskGenericCreate+0x1c0>
800064b0:	f0 1f 00 2d 	mcall	80006564 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800064b4:	4b 1c       	lddpc	r12,80006578 <xTaskGenericCreate+0x1c4>
800064b6:	f0 1f 00 2c 	mcall	80006564 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800064ba:	4b 18       	lddpc	r8,8000657c <xTaskGenericCreate+0x1c8>
800064bc:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800064be:	4b 18       	lddpc	r8,80006580 <xTaskGenericCreate+0x1cc>
800064c0:	91 06       	st.w	r8[0x0],r6
800064c2:	c0 c8       	rjmp	800064da <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800064c4:	4b 08       	lddpc	r8,80006584 <xTaskGenericCreate+0x1d0>
800064c6:	70 08       	ld.w	r8,r8[0x0]
800064c8:	58 08       	cp.w	r8,0
800064ca:	c0 81       	brne	800064da <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800064cc:	4a 48       	lddpc	r8,8000655c <xTaskGenericCreate+0x1a8>
800064ce:	70 08       	ld.w	r8,r8[0x0]
800064d0:	70 b8       	ld.w	r8,r8[0x2c]
800064d2:	10 33       	cp.w	r3,r8
800064d4:	c0 33       	brcs	800064da <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800064d6:	4a 28       	lddpc	r8,8000655c <xTaskGenericCreate+0x1a8>
800064d8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800064da:	6a b8       	ld.w	r8,r5[0x2c]
800064dc:	4a b9       	lddpc	r9,80006588 <xTaskGenericCreate+0x1d4>
800064de:	72 09       	ld.w	r9,r9[0x0]
800064e0:	12 38       	cp.w	r8,r9
800064e2:	e0 88 00 04 	brls	800064ea <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800064e6:	4a 99       	lddpc	r9,80006588 <xTaskGenericCreate+0x1d4>
800064e8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800064ea:	4a 98       	lddpc	r8,8000658c <xTaskGenericCreate+0x1d8>
800064ec:	70 09       	ld.w	r9,r8[0x0]
800064ee:	2f f9       	sub	r9,-1
800064f0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800064f2:	6a b8       	ld.w	r8,r5[0x2c]
800064f4:	4a 79       	lddpc	r9,80006590 <xTaskGenericCreate+0x1dc>
800064f6:	72 09       	ld.w	r9,r9[0x0]
800064f8:	12 38       	cp.w	r8,r9
800064fa:	e0 88 00 04 	brls	80006502 <xTaskGenericCreate+0x14e>
800064fe:	4a 59       	lddpc	r9,80006590 <xTaskGenericCreate+0x1dc>
80006500:	93 08       	st.w	r9[0x0],r8
80006502:	6a bc       	ld.w	r12,r5[0x2c]
80006504:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006508:	08 9b       	mov	r11,r4
8000650a:	49 68       	lddpc	r8,80006560 <xTaskGenericCreate+0x1ac>
8000650c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006510:	f0 1f 00 21 	mcall	80006594 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006514:	f0 1f 00 21 	mcall	80006598 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006518:	49 b8       	lddpc	r8,80006584 <xTaskGenericCreate+0x1d0>
8000651a:	70 08       	ld.w	r8,r8[0x0]
8000651c:	58 08       	cp.w	r8,0
8000651e:	c0 a0       	breq	80006532 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006520:	48 f8       	lddpc	r8,8000655c <xTaskGenericCreate+0x1a8>
80006522:	70 08       	ld.w	r8,r8[0x0]
80006524:	70 b8       	ld.w	r8,r8[0x2c]
80006526:	10 33       	cp.w	r3,r8
80006528:	e0 88 00 05 	brls	80006532 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
8000652c:	d7 33       	scall
8000652e:	30 1c       	mov	r12,1
80006530:	c0 28       	rjmp	80006534 <xTaskGenericCreate+0x180>
80006532:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006534:	2f fd       	sub	sp,-4
80006536:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006538:	99 c6       	st.w	r12[0x30],r6
8000653a:	c5 fb       	rjmp	800063f8 <xTaskGenericCreate+0x44>
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	58 44       	cp.w	r4,4
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	58 1c       	cp.w	r12,1
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	71 5e       	ld.w	lr,r8[0x54]
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	74 88       	ld.w	r8,r10[0x20]
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	54 c8       	stdsp	sp[0x130],r8
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	55 44       	stdsp	sp[0x150],r4
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	55 d8       	stdsp	sp[0x174],r8
80006558:	00 00       	add	r0,r0
8000655a:	0d 28       	ld.uh	r8,r6++
8000655c:	00 00       	add	r0,r0
8000655e:	0c dc       	st.w	--r6,r12
80006560:	00 00       	add	r0,r0
80006562:	0c 28       	rsub	r8,r6
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	54 b4       	stdsp	sp[0x12c],r4
80006568:	00 00       	add	r0,r0
8000656a:	0c f4       	st.b	--r6,r4
8000656c:	00 00       	add	r0,r0
8000656e:	0d 10       	ld.sh	r0,r6++
80006570:	00 00       	add	r0,r0
80006572:	0c e0       	st.h	--r6,r0
80006574:	00 00       	add	r0,r0
80006576:	0c c8       	st.b	r6++,r8
80006578:	00 00       	add	r0,r0
8000657a:	0d 30       	ld.ub	r0,r6++
8000657c:	00 00       	add	r0,r0
8000657e:	0c 14       	sub	r4,r6
80006580:	00 00       	add	r0,r0
80006582:	0c 24       	rsub	r4,r6
80006584:	00 00       	add	r0,r0
80006586:	0c 18       	sub	r8,r6
80006588:	00 00       	add	r0,r0
8000658a:	0c 10       	sub	r0,r6
8000658c:	00 00       	add	r0,r0
8000658e:	0d 24       	ld.uh	r4,r6++
80006590:	00 00       	add	r0,r0
80006592:	0d 44       	ld.w	r4,--r6
80006594:	80 00       	ld.sh	r0,r0[0x0]
80006596:	54 ce       	stdsp	sp[0x130],lr
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	56 e4       	stdsp	sp[0x1b8],r4

8000659c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000659c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000659e:	30 09       	mov	r9,0
800065a0:	1a d9       	st.w	--sp,r9
800065a2:	1a d9       	st.w	--sp,r9
800065a4:	1a d9       	st.w	--sp,r9
800065a6:	12 98       	mov	r8,r9
800065a8:	e0 6a 01 00 	mov	r10,256
800065ac:	48 9b       	lddpc	r11,800065d0 <vTaskStartScheduler+0x34>
800065ae:	48 ac       	lddpc	r12,800065d4 <vTaskStartScheduler+0x38>
800065b0:	f0 1f 00 0a 	mcall	800065d8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800065b4:	2f dd       	sub	sp,-12
800065b6:	58 1c       	cp.w	r12,1
800065b8:	c0 a1       	brne	800065cc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800065ba:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800065bc:	30 19       	mov	r9,1
800065be:	48 88       	lddpc	r8,800065dc <vTaskStartScheduler+0x40>
800065c0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800065c2:	30 09       	mov	r9,0
800065c4:	48 78       	lddpc	r8,800065e0 <vTaskStartScheduler+0x44>
800065c6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800065c8:	f0 1f 00 07 	mcall	800065e4 <vTaskStartScheduler+0x48>
800065cc:	d8 02       	popm	pc
800065ce:	00 00       	add	r0,r0
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	d0 c4       	*unknown*
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	63 2c       	ld.w	r12,r1[0x48]
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	63 b4       	ld.w	r4,r1[0x6c]
800065dc:	00 00       	add	r0,r0
800065de:	0c 18       	sub	r8,r6
800065e0:	00 00       	add	r0,r0
800065e2:	0d 08       	ld.w	r8,r6++
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	55 e8       	stdsp	sp[0x178],r8

800065e8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800065e8:	16 cc       	st.b	r11++,r12
	return str;
}
800065ea:	5e fb       	retal	r11

800065ec <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800065ec:	eb cd 40 c0 	pushm	r6-r7,lr
800065f0:	20 3d       	sub	sp,12
800065f2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800065f4:	30 06       	mov	r6,0
800065f6:	30 07       	mov	r7,0
800065f8:	fa e7 00 00 	st.d	sp[0],r6
800065fc:	30 0c       	mov	r12,0
800065fe:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006600:	58 08       	cp.w	r8,0
80006602:	c1 30       	breq	80006628 <PrintHex+0x3c>
80006604:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006606:	1a 9c       	mov	r12,sp
80006608:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000660c:	58 9e       	cp.w	lr,9
8000660e:	e0 8a 00 04 	brle	80006616 <PrintHex+0x2a>
80006612:	2c 9e       	sub	lr,-55
80006614:	c0 48       	rjmp	8000661c <PrintHex+0x30>
80006616:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000661a:	2d 0e       	sub	lr,-48
8000661c:	f8 09 0b 0e 	st.b	r12[r9],lr
80006620:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006622:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006624:	cf 21       	brne	80006608 <PrintHex+0x1c>
80006626:	c0 48       	rjmp	8000662e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006628:	33 08       	mov	r8,48
8000662a:	ba 88       	st.b	sp[0x0],r8
8000662c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000662e:	f6 09 01 08 	sub	r8,r11,r9
80006632:	58 08       	cp.w	r8,0
80006634:	e0 8a 00 13 	brle	8000665a <PrintHex+0x6e>
	{
		char num = len - cnt;
80006638:	12 1b       	sub	r11,r9
8000663a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000663e:	18 9e       	mov	lr,r12
80006640:	58 0c       	cp.w	r12,0
80006642:	e0 8a 00 0c 	brle	8000665a <PrintHex+0x6e>
80006646:	1a 9b       	mov	r11,sp
80006648:	12 0b       	add	r11,r9
8000664a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000664c:	33 07       	mov	r7,48
8000664e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006650:	2f f8       	sub	r8,-1
80006652:	1c 38       	cp.w	r8,lr
80006654:	cf d5       	brlt	8000664e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006656:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000665a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000665e:	f0 cb ff ff 	sub	r11,r8,-1
80006662:	58 0b       	cp.w	r11,0
80006664:	e0 8a 00 19 	brle	80006696 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006668:	fa cb ff f4 	sub	r11,sp,-12
8000666c:	f6 09 00 09 	add	r9,r11,r9
80006670:	37 8b       	mov	r11,120
80006672:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006676:	fa c9 ff f4 	sub	r9,sp,-12
8000667a:	10 09       	add	r9,r8
8000667c:	33 0b       	mov	r11,48
8000667e:	f3 6b ff f4 	st.b	r9[-12],r11
80006682:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006686:	fa ce 00 01 	sub	lr,sp,1
8000668a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
8000668c:	11 8b       	ld.ub	r11,r8[0x0]
8000668e:	12 cb       	st.b	r9++,r11
80006690:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006692:	1c 38       	cp.w	r8,lr
80006694:	cf c1       	brne	8000668c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006696:	14 9c       	mov	r12,r10
80006698:	2f dd       	sub	sp,-12
8000669a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000669e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000669e:	d4 21       	pushm	r4-r7,lr
800066a0:	20 3d       	sub	sp,12
800066a2:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800066a4:	30 06       	mov	r6,0
800066a6:	30 07       	mov	r7,0
800066a8:	fa e7 00 00 	st.d	sp[0],r6
800066ac:	30 0c       	mov	r12,0
800066ae:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800066b0:	58 08       	cp.w	r8,0
800066b2:	c0 35       	brlt	800066b8 <PrintDec+0x1a>
800066b4:	14 97       	mov	r7,r10
800066b6:	c0 58       	rjmp	800066c0 <PrintDec+0x22>
	{
		*p++ = '-';
800066b8:	14 97       	mov	r7,r10
800066ba:	32 d9       	mov	r9,45
800066bc:	0e c9       	st.b	r7++,r9
		i = -i;
800066be:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800066c0:	58 08       	cp.w	r8,0
800066c2:	c0 51       	brne	800066cc <PrintDec+0x2e>
800066c4:	33 08       	mov	r8,48
800066c6:	ba 88       	st.b	sp[0x0],r8
800066c8:	30 1e       	mov	lr,1
800066ca:	c2 f8       	rjmp	80006728 <PrintDec+0x8a>
	
	int ten = i%10;
800066cc:	e0 65 66 67 	mov	r5,26215
800066d0:	ea 15 66 66 	orh	r5,0x6666
800066d4:	f0 05 04 44 	muls.d	r4,r8,r5
800066d8:	ea 0c 14 02 	asr	r12,r5,0x2
800066dc:	f0 09 14 1f 	asr	r9,r8,0x1f
800066e0:	f8 09 01 09 	sub	r9,r12,r9
800066e4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800066e8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800066ec:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800066ee:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800066f0:	e0 66 66 67 	mov	r6,26215
800066f4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800066f8:	2d 09       	sub	r9,-48
800066fa:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800066fe:	2f fe       	sub	lr,-1
		i /= 10;
80006700:	f0 06 04 44 	muls.d	r4,r8,r6
80006704:	ea 09 14 02 	asr	r9,r5,0x2
80006708:	bf 58       	asr	r8,0x1f
8000670a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000670e:	f0 06 04 44 	muls.d	r4,r8,r6
80006712:	ea 09 14 02 	asr	r9,r5,0x2
80006716:	f0 05 14 1f 	asr	r5,r8,0x1f
8000671a:	0a 19       	sub	r9,r5
8000671c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006720:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006724:	58 08       	cp.w	r8,0
80006726:	ce 91       	brne	800066f8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006728:	f6 0e 01 08 	sub	r8,r11,lr
8000672c:	58 08       	cp.w	r8,0
8000672e:	e0 89 00 06 	brgt	8000673a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006732:	58 0e       	cp.w	lr,0
80006734:	e0 89 00 14 	brgt	8000675c <PrintDec+0xbe>
80006738:	c1 d8       	rjmp	80006772 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000673a:	1c 1b       	sub	r11,lr
8000673c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000673e:	16 9c       	mov	r12,r11
80006740:	58 0b       	cp.w	r11,0
80006742:	fe 9a ff f8 	brle	80006732 <PrintDec+0x94>
80006746:	1a 99       	mov	r9,sp
80006748:	1c 09       	add	r9,lr
8000674a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000674c:	33 06       	mov	r6,48
8000674e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006750:	2f f8       	sub	r8,-1
80006752:	18 38       	cp.w	r8,r12
80006754:	cf d5       	brlt	8000674e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006756:	f6 0e 00 0e 	add	lr,r11,lr
8000675a:	ce cb       	rjmp	80006732 <PrintDec+0x94>
8000675c:	fa c8 ff f4 	sub	r8,sp,-12
80006760:	1c 08       	add	r8,lr
80006762:	20 d8       	sub	r8,13
80006764:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006768:	11 89       	ld.ub	r9,r8[0x0]
8000676a:	0e c9       	st.b	r7++,r9
8000676c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000676e:	16 38       	cp.w	r8,r11
80006770:	cf c1       	brne	80006768 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006772:	14 9c       	mov	r12,r10
80006774:	2f dd       	sub	sp,-12
80006776:	d8 22       	popm	r4-r7,pc

80006778 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006778:	d4 31       	pushm	r0-r7,lr
8000677a:	fa cd 02 08 	sub	sp,sp,520
8000677e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006780:	e0 6a 01 00 	mov	r10,256
80006784:	30 0b       	mov	r11,0
80006786:	fa cc fe f8 	sub	r12,sp,-264
8000678a:	f0 1f 00 4e 	mcall	800068c0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000678e:	fa c4 fd d4 	sub	r4,sp,-556
80006792:	30 0a       	mov	r10,0
80006794:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006796:	fa c3 ff fc 	sub	r3,sp,-4
8000679a:	e0 61 01 00 	mov	r1,256
8000679e:	14 90       	mov	r0,r10
			
					if(*str == '%')
800067a0:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800067a2:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800067a6:	02 9a       	mov	r10,r1
800067a8:	00 9b       	mov	r11,r0
800067aa:	06 9c       	mov	r12,r3
800067ac:	f0 1f 00 45 	mcall	800068c0 <log+0x148>
			
					if(*str == '%')
800067b0:	0f 88       	ld.ub	r8,r7[0x0]
800067b2:	e4 08 18 00 	cp.b	r8,r2
800067b6:	c5 71       	brne	80006864 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800067b8:	ee c8 ff ff 	sub	r8,r7,-1
800067bc:	11 89       	ld.ub	r9,r8[0x0]
800067be:	4c 2a       	lddpc	r10,800068c4 <log+0x14c>
800067c0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800067c2:	23 09       	sub	r9,48
800067c4:	30 9a       	mov	r10,9
800067c6:	f4 09 18 00 	cp.b	r9,r10
800067ca:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800067ce:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800067d2:	f7 b9 08 30 	subls	r9,48
800067d6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800067da:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800067de:	0f 88       	ld.ub	r8,r7[0x0]
800067e0:	22 58       	sub	r8,37
800067e2:	e0 48 00 53 	cp.w	r8,83
800067e6:	e0 8b 00 31 	brhi	80006848 <log+0xd0>
800067ea:	4b 89       	lddpc	r9,800068c8 <log+0x150>
800067ec:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800067f0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800067f4:	06 9a       	mov	r10,r3
800067f6:	40 0b       	lddsp	r11,sp[0x0]
800067f8:	5c 5b       	castu.b	r11
800067fa:	68 0c       	ld.w	r12,r4[0x0]
800067fc:	f0 1f 00 34 	mcall	800068cc <log+0x154>
							break;
80006800:	c2 98       	rjmp	80006852 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006802:	4b 4c       	lddpc	r12,800068d0 <log+0x158>
80006804:	f0 1f 00 34 	mcall	800068d4 <log+0x15c>
80006808:	08 95       	mov	r5,r4
8000680a:	06 9c       	mov	r12,r3
							break;
8000680c:	c2 38       	rjmp	80006852 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000680e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006812:	06 9a       	mov	r10,r3
80006814:	40 0b       	lddsp	r11,sp[0x0]
80006816:	5c 5b       	castu.b	r11
80006818:	68 0c       	ld.w	r12,r4[0x0]
8000681a:	f0 1f 00 30 	mcall	800068d8 <log+0x160>
8000681e:	06 9c       	mov	r12,r3
							break;
80006820:	c1 98       	rjmp	80006852 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006822:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006826:	06 9b       	mov	r11,r3
80006828:	09 bc       	ld.ub	r12,r4[0x3]
8000682a:	f0 1f 00 2d 	mcall	800068dc <log+0x164>
8000682e:	06 9c       	mov	r12,r3
							break;
80006830:	c1 18       	rjmp	80006852 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006832:	e8 c5 ff fc 	sub	r5,r4,-4
80006836:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006838:	c0 d8       	rjmp	80006852 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000683a:	06 9b       	mov	r11,r3
8000683c:	32 5c       	mov	r12,37
8000683e:	f0 1f 00 28 	mcall	800068dc <log+0x164>
80006842:	08 95       	mov	r5,r4
80006844:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006846:	c0 68       	rjmp	80006852 <log+0xda>
							
							default:
							log("I need relax.");
80006848:	4a 6c       	lddpc	r12,800068e0 <log+0x168>
8000684a:	f0 1f 00 23 	mcall	800068d4 <log+0x15c>
8000684e:	08 95       	mov	r5,r4
80006850:	06 9c       	mov	r12,r3
						}
						str++;
80006852:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006854:	1a dc       	st.w	--sp,r12
80006856:	1a d6       	st.w	--sp,r6
80006858:	4a 3b       	lddpc	r11,800068e4 <log+0x16c>
8000685a:	0c 9c       	mov	r12,r6
8000685c:	f0 1f 00 23 	mcall	800068e8 <log+0x170>
80006860:	2f ed       	sub	sp,-8
80006862:	c0 a8       	rjmp	80006876 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006864:	2f f7       	sub	r7,-1
80006866:	1a d8       	st.w	--sp,r8
80006868:	1a d6       	st.w	--sp,r6
8000686a:	4a 1b       	lddpc	r11,800068ec <log+0x174>
8000686c:	0c 9c       	mov	r12,r6
8000686e:	f0 1f 00 1f 	mcall	800068e8 <log+0x170>
80006872:	08 95       	mov	r5,r4
80006874:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006876:	0f 89       	ld.ub	r9,r7[0x0]
80006878:	30 08       	mov	r8,0
8000687a:	f0 09 18 00 	cp.b	r9,r8
8000687e:	c0 30       	breq	80006884 <log+0x10c>
80006880:	0a 94       	mov	r4,r5
80006882:	c9 2b       	rjmp	800067a6 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006884:	fa c7 fe f8 	sub	r7,sp,-264
80006888:	1a d7       	st.w	--sp,r7
8000688a:	49 ab       	lddpc	r11,800068f0 <log+0x178>
8000688c:	0e 9c       	mov	r12,r7
8000688e:	f0 1f 00 17 	mcall	800068e8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006892:	5c 5c       	castu.b	r12
80006894:	f8 c6 ff ff 	sub	r6,r12,-1
80006898:	0c 9c       	mov	r12,r6
8000689a:	f0 1f 00 17 	mcall	800068f4 <log+0x17c>
8000689e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800068a0:	0c 9a       	mov	r10,r6
800068a2:	0e 9b       	mov	r11,r7
800068a4:	f0 1f 00 15 	mcall	800068f8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800068a8:	30 09       	mov	r9,0
800068aa:	30 5a       	mov	r10,5
800068ac:	fa cb fe f8 	sub	r11,sp,-264
800068b0:	49 38       	lddpc	r8,800068fc <log+0x184>
800068b2:	70 0c       	ld.w	r12,r8[0x0]
800068b4:	f0 1f 00 13 	mcall	80006900 <log+0x188>
800068b8:	2f fd       	sub	sp,-4
	
	
}
800068ba:	fe 3d fd f8 	sub	sp,-520
800068be:	d8 32       	popm	r0-r7,pc
800068c0:	80 00       	ld.sh	r0,r0[0x0]
800068c2:	71 5e       	ld.w	lr,r8[0x54]
800068c4:	00 00       	add	r0,r0
800068c6:	0d 48       	ld.w	r8,--r6
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	d0 cc       	*unknown*
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	66 9e       	ld.w	lr,r3[0x24]
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	d3 78       	*unknown*
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	67 78       	ld.w	r8,r3[0x5c]
800068d8:	80 00       	ld.sh	r0,r0[0x0]
800068da:	65 ec       	ld.w	r12,r2[0x78]
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	65 e8       	ld.w	r8,r2[0x78]
800068e0:	80 00       	ld.sh	r0,r0[0x0]
800068e2:	d3 88       	*unknown*
800068e4:	80 00       	ld.sh	r0,r0[0x0]
800068e6:	d3 98       	*unknown*
800068e8:	80 00       	ld.sh	r0,r0[0x0]
800068ea:	74 4c       	ld.w	r12,r10[0x10]
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	d3 a0       	acall	0x3a
800068f0:	80 00       	ld.sh	r0,r0[0x0]
800068f2:	d3 a8       	*unknown*
800068f4:	80 00       	ld.sh	r0,r0[0x0]
800068f6:	58 44       	cp.w	r4,4
800068f8:	80 00       	ld.sh	r0,r0[0x0]
800068fa:	70 16       	ld.w	r6,r8[0x4]
800068fc:	00 00       	add	r0,r0
800068fe:	63 98       	ld.w	r8,r1[0x64]
80006900:	80 00       	ld.sh	r0,r0[0x0]
80006902:	5b 98       	cp.w	r8,-7

80006904 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006904:	d4 31       	pushm	r0-r7,lr
80006906:	fa cd 02 0c 	sub	sp,sp,524
8000690a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000690c:	e0 6a 01 00 	mov	r10,256
80006910:	30 0b       	mov	r11,0
80006912:	fa cc fe f4 	sub	r12,sp,-268
80006916:	f0 1f 00 4c 	mcall	80006a44 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000691a:	fa c4 fd d0 	sub	r4,sp,-560
8000691e:	30 0a       	mov	r10,0
80006920:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006922:	fa c3 ff fc 	sub	r3,sp,-4
80006926:	e0 61 01 00 	mov	r1,256
8000692a:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000692c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000692e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006932:	02 9a       	mov	r10,r1
80006934:	00 9b       	mov	r11,r0
80006936:	06 9c       	mov	r12,r3
80006938:	f0 1f 00 43 	mcall	80006a44 <logFromISR+0x140>
			
			if(*str == '%')
8000693c:	0f 88       	ld.ub	r8,r7[0x0]
8000693e:	e4 08 18 00 	cp.b	r8,r2
80006942:	c5 11       	brne	800069e4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006944:	ee c8 ff ff 	sub	r8,r7,-1
80006948:	11 89       	ld.ub	r9,r8[0x0]
8000694a:	4c 0a       	lddpc	r10,80006a48 <logFromISR+0x144>
8000694c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000694e:	23 09       	sub	r9,48
80006950:	30 9a       	mov	r10,9
80006952:	f4 09 18 00 	cp.b	r9,r10
80006956:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000695a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000695e:	f7 b9 08 30 	subls	r9,48
80006962:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006966:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000696a:	0f 88       	ld.ub	r8,r7[0x0]
8000696c:	22 58       	sub	r8,37
8000696e:	e0 48 00 53 	cp.w	r8,83
80006972:	e0 8b 00 2b 	brhi	800069c8 <logFromISR+0xc4>
80006976:	4b 69       	lddpc	r9,80006a4c <logFromISR+0x148>
80006978:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000697c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006980:	06 9a       	mov	r10,r3
80006982:	40 0b       	lddsp	r11,sp[0x0]
80006984:	5c 5b       	castu.b	r11
80006986:	68 0c       	ld.w	r12,r4[0x0]
80006988:	f0 1f 00 32 	mcall	80006a50 <logFromISR+0x14c>
					break;
8000698c:	c2 38       	rjmp	800069d2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000698e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006992:	06 9a       	mov	r10,r3
80006994:	40 0b       	lddsp	r11,sp[0x0]
80006996:	5c 5b       	castu.b	r11
80006998:	68 0c       	ld.w	r12,r4[0x0]
8000699a:	f0 1f 00 2f 	mcall	80006a54 <logFromISR+0x150>
8000699e:	06 9c       	mov	r12,r3
					break;
800069a0:	c1 98       	rjmp	800069d2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800069a2:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800069a6:	06 9b       	mov	r11,r3
800069a8:	09 bc       	ld.ub	r12,r4[0x3]
800069aa:	f0 1f 00 2c 	mcall	80006a58 <logFromISR+0x154>
800069ae:	06 9c       	mov	r12,r3
					break;
800069b0:	c1 18       	rjmp	800069d2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800069b2:	e8 c5 ff fc 	sub	r5,r4,-4
800069b6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800069b8:	c0 d8       	rjmp	800069d2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800069ba:	06 9b       	mov	r11,r3
800069bc:	32 5c       	mov	r12,37
800069be:	f0 1f 00 27 	mcall	80006a58 <logFromISR+0x154>
800069c2:	08 95       	mov	r5,r4
800069c4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800069c6:	c0 68       	rjmp	800069d2 <logFromISR+0xce>
					default:
					log("I need relax.");
800069c8:	4a 5c       	lddpc	r12,80006a5c <logFromISR+0x158>
800069ca:	f0 1f 00 26 	mcall	80006a60 <logFromISR+0x15c>
800069ce:	08 95       	mov	r5,r4
800069d0:	06 9c       	mov	r12,r3
				}
				str++;
800069d2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800069d4:	1a dc       	st.w	--sp,r12
800069d6:	1a d6       	st.w	--sp,r6
800069d8:	4a 3b       	lddpc	r11,80006a64 <logFromISR+0x160>
800069da:	0c 9c       	mov	r12,r6
800069dc:	f0 1f 00 23 	mcall	80006a68 <logFromISR+0x164>
800069e0:	2f ed       	sub	sp,-8
800069e2:	c0 a8       	rjmp	800069f6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800069e4:	2f f7       	sub	r7,-1
800069e6:	1a d8       	st.w	--sp,r8
800069e8:	1a d6       	st.w	--sp,r6
800069ea:	4a 1b       	lddpc	r11,80006a6c <logFromISR+0x168>
800069ec:	0c 9c       	mov	r12,r6
800069ee:	f0 1f 00 1f 	mcall	80006a68 <logFromISR+0x164>
800069f2:	08 95       	mov	r5,r4
800069f4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800069f6:	0f 89       	ld.ub	r9,r7[0x0]
800069f8:	30 08       	mov	r8,0
800069fa:	f0 09 18 00 	cp.b	r9,r8
800069fe:	c0 30       	breq	80006a04 <logFromISR+0x100>
80006a00:	0a 94       	mov	r4,r5
80006a02:	c9 8b       	rjmp	80006932 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006a04:	fa c7 fe f4 	sub	r7,sp,-268
80006a08:	1a d7       	st.w	--sp,r7
80006a0a:	49 ab       	lddpc	r11,80006a70 <logFromISR+0x16c>
80006a0c:	0e 9c       	mov	r12,r7
80006a0e:	f0 1f 00 17 	mcall	80006a68 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006a12:	5c 5c       	castu.b	r12
80006a14:	f8 c6 ff ff 	sub	r6,r12,-1
80006a18:	0c 9c       	mov	r12,r6
80006a1a:	f0 1f 00 17 	mcall	80006a74 <logFromISR+0x170>
80006a1e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006a20:	0c 9a       	mov	r10,r6
80006a22:	0e 9b       	mov	r11,r7
80006a24:	f0 1f 00 15 	mcall	80006a78 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006a28:	30 09       	mov	r9,0
80006a2a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006a2c:	fa ca fe f8 	sub	r10,sp,-264
80006a30:	fa cb fe f4 	sub	r11,sp,-268
80006a34:	49 28       	lddpc	r8,80006a7c <logFromISR+0x178>
80006a36:	70 0c       	ld.w	r12,r8[0x0]
80006a38:	f0 1f 00 12 	mcall	80006a80 <logFromISR+0x17c>
80006a3c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006a3e:	fe 3d fd f4 	sub	sp,-524
80006a42:	d8 32       	popm	r0-r7,pc
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	71 5e       	ld.w	lr,r8[0x54]
80006a48:	00 00       	add	r0,r0
80006a4a:	0d 49       	ld.w	r9,--r6
80006a4c:	80 00       	ld.sh	r0,r0[0x0]
80006a4e:	d2 1c       	*unknown*
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	66 9e       	ld.w	lr,r3[0x24]
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	65 ec       	ld.w	r12,r2[0x78]
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	65 e8       	ld.w	r8,r2[0x78]
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	d3 88       	*unknown*
80006a60:	80 00       	ld.sh	r0,r0[0x0]
80006a62:	67 78       	ld.w	r8,r3[0x5c]
80006a64:	80 00       	ld.sh	r0,r0[0x0]
80006a66:	d3 98       	*unknown*
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	74 4c       	ld.w	r12,r10[0x10]
80006a6c:	80 00       	ld.sh	r0,r0[0x0]
80006a6e:	d3 a0       	acall	0x3a
80006a70:	80 00       	ld.sh	r0,r0[0x0]
80006a72:	d3 a8       	*unknown*
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	58 44       	cp.w	r4,4
80006a78:	80 00       	ld.sh	r0,r0[0x0]
80006a7a:	70 16       	ld.w	r6,r8[0x4]
80006a7c:	00 00       	add	r0,r0
80006a7e:	63 98       	ld.w	r8,r1[0x64]
80006a80:	80 00       	ld.sh	r0,r0[0x0]
80006a82:	5b 48       	cp.w	r8,-12

80006a84 <log_init>:
		
	return str;
}

void log_init(void)
{
80006a84:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006a86:	30 2b       	mov	r11,2
80006a88:	49 0c       	lddpc	r12,80006ac8 <log_init+0x44>
80006a8a:	f0 1f 00 11 	mcall	80006acc <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006a8e:	e0 6a 36 00 	mov	r10,13824
80006a92:	ea 1a 01 6e 	orh	r10,0x16e
80006a96:	48 fb       	lddpc	r11,80006ad0 <log_init+0x4c>
80006a98:	fe 7c 18 00 	mov	r12,-59392
80006a9c:	f0 1f 00 0e 	mcall	80006ad4 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006aa0:	30 4b       	mov	r11,4
80006aa2:	33 2c       	mov	r12,50
80006aa4:	f0 1f 00 0d 	mcall	80006ad8 <log_init+0x54>
80006aa8:	48 d8       	lddpc	r8,80006adc <log_init+0x58>
80006aaa:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006aac:	30 09       	mov	r9,0
80006aae:	1a d9       	st.w	--sp,r9
80006ab0:	1a d9       	st.w	--sp,r9
80006ab2:	1a d9       	st.w	--sp,r9
80006ab4:	30 28       	mov	r8,2
80006ab6:	e0 6a 01 80 	mov	r10,384
80006aba:	48 ab       	lddpc	r11,80006ae0 <log_init+0x5c>
80006abc:	48 ac       	lddpc	r12,80006ae4 <log_init+0x60>
80006abe:	f0 1f 00 0b 	mcall	80006ae8 <log_init+0x64>
80006ac2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006ac4:	d8 02       	popm	pc
80006ac6:	00 00       	add	r0,r0
80006ac8:	80 00       	ld.sh	r0,r0[0x0]
80006aca:	d3 b4       	*unknown*
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	4e 90       	lddpc	r0,80006c70 <_malloc_r+0xb8>
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	d3 6c       	*unknown*
80006ad4:	80 00       	ld.sh	r0,r0[0x0]
80006ad6:	53 a8       	stdsp	sp[0xe8],r8
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	5c 98       	brev	r8
80006adc:	00 00       	add	r0,r0
80006ade:	63 98       	ld.w	r8,r1[0x64]
80006ae0:	80 00       	ld.sh	r0,r0[0x0]
80006ae2:	d3 b0       	acall	0x3b
80006ae4:	80 00       	ld.sh	r0,r0[0x0]
80006ae6:	6a ec       	ld.w	r12,r5[0x38]
80006ae8:	80 00       	ld.sh	r0,r0[0x0]
80006aea:	63 b4       	ld.w	r4,r1[0x6c]

80006aec <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006aec:	eb cd 40 f8 	pushm	r3-r7,lr
80006af0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006af2:	48 c7       	lddpc	r7,80006b20 <task_log+0x34>
80006af4:	30 05       	mov	r5,0
80006af6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006af8:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006afc:	0a 99       	mov	r9,r5
80006afe:	08 9a       	mov	r10,r4
80006b00:	1a 9b       	mov	r11,sp
80006b02:	6e 0c       	ld.w	r12,r7[0x0]
80006b04:	f0 1f 00 08 	mcall	80006b24 <task_log+0x38>
80006b08:	58 1c       	cp.w	r12,1
80006b0a:	cf 91       	brne	80006afc <task_log+0x10>
		{
			if( NULL != str)
80006b0c:	40 0b       	lddsp	r11,sp[0x0]
80006b0e:	58 0b       	cp.w	r11,0
80006b10:	cf 60       	breq	80006afc <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006b12:	06 9c       	mov	r12,r3
80006b14:	f0 1f 00 05 	mcall	80006b28 <task_log+0x3c>
				vPortFree(str);
80006b18:	40 0c       	lddsp	r12,sp[0x0]
80006b1a:	f0 1f 00 05 	mcall	80006b2c <task_log+0x40>
80006b1e:	ce fb       	rjmp	80006afc <task_log+0x10>
80006b20:	00 00       	add	r0,r0
80006b22:	63 98       	ld.w	r8,r1[0x64]
80006b24:	80 00       	ld.sh	r0,r0[0x0]
80006b26:	59 8c       	cp.w	r12,24
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	53 58       	stdsp	sp[0xd4],r8
80006b2c:	80 00       	ld.sh	r0,r0[0x0]
80006b2e:	58 1c       	cp.w	r12,1

80006b30 <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006b30:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006b32:	fe 78 10 00 	mov	r8,-61440
80006b36:	30 19       	mov	r9,1
80006b38:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006b3c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006b40:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006b44:	d3 03       	ssrf	0x10
	local_start_pll0();
80006b46:	f0 1f 00 0b 	mcall	80006b70 <main+0x40>
		
	INTC_init_interrupts();
80006b4a:	f0 1f 00 0b 	mcall	80006b74 <main+0x44>
		
	log_init();
80006b4e:	f0 1f 00 0b 	mcall	80006b78 <main+0x48>
	log("----start debug----");
80006b52:	48 bc       	lddpc	r12,80006b7c <main+0x4c>
80006b54:	f0 1f 00 0b 	mcall	80006b80 <main+0x50>
		
	voc_init();
80006b58:	f0 1f 00 0b 	mcall	80006b84 <main+0x54>

	//tc_init();
	
	//rfid_init();
		
	app_init();
80006b5c:	f0 1f 00 0b 	mcall	80006b88 <main+0x58>
		
	xcmp_init();
80006b60:	f0 1f 00 0b 	mcall	80006b8c <main+0x5c>

	local_start_timer();
80006b64:	f0 1f 00 0b 	mcall	80006b90 <main+0x60>
		
	vTaskStartScheduler();
80006b68:	f0 1f 00 0b 	mcall	80006b94 <main+0x64>
	return 0;
	
}
80006b6c:	d8 0a       	popm	pc,r12=0
80006b6e:	00 00       	add	r0,r0
80006b70:	80 00       	ld.sh	r0,r0[0x0]
80006b72:	4b f0       	lddpc	r0,80006c6c <_malloc_r+0xb4>
80006b74:	80 00       	ld.sh	r0,r0[0x0]
80006b76:	4f 78       	lddpc	r8,80006d50 <_malloc_r+0x198>
80006b78:	80 00       	ld.sh	r0,r0[0x0]
80006b7a:	6a 84       	ld.w	r4,r5[0x20]
80006b7c:	80 00       	ld.sh	r0,r0[0x0]
80006b7e:	d3 c4       	*unknown*
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	67 78       	ld.w	r8,r3[0x5c]
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	4c 6c       	lddpc	r12,80006c9c <_malloc_r+0xe4>
80006b88:	80 00       	ld.sh	r0,r0[0x0]
80006b8a:	20 3c       	sub	r12,3
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	44 74       	lddsp	r4,sp[0x11c]
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	4c 40       	lddpc	r0,80006ca0 <_malloc_r+0xe8>
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	65 9c       	ld.w	r12,r2[0x64]

80006b98 <free>:
80006b98:	d4 01       	pushm	lr
80006b9a:	e0 68 0a 38 	mov	r8,2616
80006b9e:	18 9b       	mov	r11,r12
80006ba0:	70 0c       	ld.w	r12,r8[0x0]
80006ba2:	e0 a0 1e 73 	rcall	8000a888 <_free_r>
80006ba6:	d8 02       	popm	pc

80006ba8 <malloc>:
80006ba8:	d4 01       	pushm	lr
80006baa:	e0 68 0a 38 	mov	r8,2616
80006bae:	18 9b       	mov	r11,r12
80006bb0:	70 0c       	ld.w	r12,r8[0x0]
80006bb2:	c0 3c       	rcall	80006bb8 <_malloc_r>
80006bb4:	d8 02       	popm	pc
80006bb6:	d7 03       	nop

80006bb8 <_malloc_r>:
80006bb8:	d4 31       	pushm	r0-r7,lr
80006bba:	f6 c8 ff f5 	sub	r8,r11,-11
80006bbe:	18 95       	mov	r5,r12
80006bc0:	10 97       	mov	r7,r8
80006bc2:	e0 17 ff f8 	andl	r7,0xfff8
80006bc6:	59 68       	cp.w	r8,22
80006bc8:	f9 b7 08 10 	movls	r7,16
80006bcc:	16 37       	cp.w	r7,r11
80006bce:	5f 38       	srlo	r8
80006bd0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006bd4:	c0 50       	breq	80006bde <_malloc_r+0x26>
80006bd6:	30 c8       	mov	r8,12
80006bd8:	99 38       	st.w	r12[0xc],r8
80006bda:	e0 8f 01 fa 	bral	80006fce <_malloc_r+0x416>
80006bde:	fe b0 f5 d5 	rcall	80005788 <__malloc_lock>
80006be2:	e0 47 01 f7 	cp.w	r7,503
80006be6:	e0 8b 00 1d 	brhi	80006c20 <_malloc_r+0x68>
80006bea:	ee 03 16 03 	lsr	r3,r7,0x3
80006bee:	e0 68 05 38 	mov	r8,1336
80006bf2:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006bf6:	70 36       	ld.w	r6,r8[0xc]
80006bf8:	10 36       	cp.w	r6,r8
80006bfa:	c0 61       	brne	80006c06 <_malloc_r+0x4e>
80006bfc:	ec c8 ff f8 	sub	r8,r6,-8
80006c00:	70 36       	ld.w	r6,r8[0xc]
80006c02:	10 36       	cp.w	r6,r8
80006c04:	c0 c0       	breq	80006c1c <_malloc_r+0x64>
80006c06:	6c 18       	ld.w	r8,r6[0x4]
80006c08:	e0 18 ff fc 	andl	r8,0xfffc
80006c0c:	6c 3a       	ld.w	r10,r6[0xc]
80006c0e:	ec 08 00 09 	add	r9,r6,r8
80006c12:	0a 9c       	mov	r12,r5
80006c14:	6c 28       	ld.w	r8,r6[0x8]
80006c16:	95 28       	st.w	r10[0x8],r8
80006c18:	91 3a       	st.w	r8[0xc],r10
80006c1a:	c4 78       	rjmp	80006ca8 <_malloc_r+0xf0>
80006c1c:	2f e3       	sub	r3,-2
80006c1e:	c4 d8       	rjmp	80006cb8 <_malloc_r+0x100>
80006c20:	ee 03 16 09 	lsr	r3,r7,0x9
80006c24:	c0 41       	brne	80006c2c <_malloc_r+0x74>
80006c26:	ee 03 16 03 	lsr	r3,r7,0x3
80006c2a:	c2 68       	rjmp	80006c76 <_malloc_r+0xbe>
80006c2c:	58 43       	cp.w	r3,4
80006c2e:	e0 8b 00 06 	brhi	80006c3a <_malloc_r+0x82>
80006c32:	ee 03 16 06 	lsr	r3,r7,0x6
80006c36:	2c 83       	sub	r3,-56
80006c38:	c1 f8       	rjmp	80006c76 <_malloc_r+0xbe>
80006c3a:	59 43       	cp.w	r3,20
80006c3c:	e0 8b 00 04 	brhi	80006c44 <_malloc_r+0x8c>
80006c40:	2a 53       	sub	r3,-91
80006c42:	c1 a8       	rjmp	80006c76 <_malloc_r+0xbe>
80006c44:	e0 43 00 54 	cp.w	r3,84
80006c48:	e0 8b 00 06 	brhi	80006c54 <_malloc_r+0x9c>
80006c4c:	ee 03 16 0c 	lsr	r3,r7,0xc
80006c50:	29 23       	sub	r3,-110
80006c52:	c1 28       	rjmp	80006c76 <_malloc_r+0xbe>
80006c54:	e0 43 01 54 	cp.w	r3,340
80006c58:	e0 8b 00 06 	brhi	80006c64 <_malloc_r+0xac>
80006c5c:	ee 03 16 0f 	lsr	r3,r7,0xf
80006c60:	28 93       	sub	r3,-119
80006c62:	c0 a8       	rjmp	80006c76 <_malloc_r+0xbe>
80006c64:	e0 43 05 54 	cp.w	r3,1364
80006c68:	e0 88 00 04 	brls	80006c70 <_malloc_r+0xb8>
80006c6c:	37 e3       	mov	r3,126
80006c6e:	c0 48       	rjmp	80006c76 <_malloc_r+0xbe>
80006c70:	ee 03 16 12 	lsr	r3,r7,0x12
80006c74:	28 43       	sub	r3,-124
80006c76:	e0 6a 05 38 	mov	r10,1336
80006c7a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006c7e:	74 36       	ld.w	r6,r10[0xc]
80006c80:	c1 98       	rjmp	80006cb2 <_malloc_r+0xfa>
80006c82:	6c 19       	ld.w	r9,r6[0x4]
80006c84:	e0 19 ff fc 	andl	r9,0xfffc
80006c88:	f2 07 01 0b 	sub	r11,r9,r7
80006c8c:	58 fb       	cp.w	r11,15
80006c8e:	e0 8a 00 04 	brle	80006c96 <_malloc_r+0xde>
80006c92:	20 13       	sub	r3,1
80006c94:	c1 18       	rjmp	80006cb6 <_malloc_r+0xfe>
80006c96:	6c 38       	ld.w	r8,r6[0xc]
80006c98:	58 0b       	cp.w	r11,0
80006c9a:	c0 b5       	brlt	80006cb0 <_malloc_r+0xf8>
80006c9c:	6c 2a       	ld.w	r10,r6[0x8]
80006c9e:	ec 09 00 09 	add	r9,r6,r9
80006ca2:	0a 9c       	mov	r12,r5
80006ca4:	91 2a       	st.w	r8[0x8],r10
80006ca6:	95 38       	st.w	r10[0xc],r8
80006ca8:	72 18       	ld.w	r8,r9[0x4]
80006caa:	a1 a8       	sbr	r8,0x0
80006cac:	93 18       	st.w	r9[0x4],r8
80006cae:	cb c8       	rjmp	80006e26 <_malloc_r+0x26e>
80006cb0:	10 96       	mov	r6,r8
80006cb2:	14 36       	cp.w	r6,r10
80006cb4:	ce 71       	brne	80006c82 <_malloc_r+0xca>
80006cb6:	2f f3       	sub	r3,-1
80006cb8:	e0 6a 05 38 	mov	r10,1336
80006cbc:	f4 cc ff f8 	sub	r12,r10,-8
80006cc0:	78 26       	ld.w	r6,r12[0x8]
80006cc2:	18 36       	cp.w	r6,r12
80006cc4:	c6 c0       	breq	80006d9c <_malloc_r+0x1e4>
80006cc6:	6c 19       	ld.w	r9,r6[0x4]
80006cc8:	e0 19 ff fc 	andl	r9,0xfffc
80006ccc:	f2 07 01 08 	sub	r8,r9,r7
80006cd0:	58 f8       	cp.w	r8,15
80006cd2:	e0 89 00 8f 	brgt	80006df0 <_malloc_r+0x238>
80006cd6:	99 3c       	st.w	r12[0xc],r12
80006cd8:	99 2c       	st.w	r12[0x8],r12
80006cda:	58 08       	cp.w	r8,0
80006cdc:	c0 55       	brlt	80006ce6 <_malloc_r+0x12e>
80006cde:	ec 09 00 09 	add	r9,r6,r9
80006ce2:	0a 9c       	mov	r12,r5
80006ce4:	ce 2b       	rjmp	80006ca8 <_malloc_r+0xf0>
80006ce6:	e0 49 01 ff 	cp.w	r9,511
80006cea:	e0 8b 00 13 	brhi	80006d10 <_malloc_r+0x158>
80006cee:	a3 99       	lsr	r9,0x3
80006cf0:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006cf4:	70 2b       	ld.w	r11,r8[0x8]
80006cf6:	8d 38       	st.w	r6[0xc],r8
80006cf8:	8d 2b       	st.w	r6[0x8],r11
80006cfa:	97 36       	st.w	r11[0xc],r6
80006cfc:	91 26       	st.w	r8[0x8],r6
80006cfe:	a3 49       	asr	r9,0x2
80006d00:	74 18       	ld.w	r8,r10[0x4]
80006d02:	30 1b       	mov	r11,1
80006d04:	f6 09 09 49 	lsl	r9,r11,r9
80006d08:	f1 e9 10 09 	or	r9,r8,r9
80006d0c:	95 19       	st.w	r10[0x4],r9
80006d0e:	c4 78       	rjmp	80006d9c <_malloc_r+0x1e4>
80006d10:	f2 0a 16 09 	lsr	r10,r9,0x9
80006d14:	58 4a       	cp.w	r10,4
80006d16:	e0 8b 00 07 	brhi	80006d24 <_malloc_r+0x16c>
80006d1a:	f2 0a 16 06 	lsr	r10,r9,0x6
80006d1e:	2c 8a       	sub	r10,-56
80006d20:	c2 08       	rjmp	80006d60 <_malloc_r+0x1a8>
80006d22:	d7 03       	nop
80006d24:	59 4a       	cp.w	r10,20
80006d26:	e0 8b 00 04 	brhi	80006d2e <_malloc_r+0x176>
80006d2a:	2a 5a       	sub	r10,-91
80006d2c:	c1 a8       	rjmp	80006d60 <_malloc_r+0x1a8>
80006d2e:	e0 4a 00 54 	cp.w	r10,84
80006d32:	e0 8b 00 06 	brhi	80006d3e <_malloc_r+0x186>
80006d36:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006d3a:	29 2a       	sub	r10,-110
80006d3c:	c1 28       	rjmp	80006d60 <_malloc_r+0x1a8>
80006d3e:	e0 4a 01 54 	cp.w	r10,340
80006d42:	e0 8b 00 06 	brhi	80006d4e <_malloc_r+0x196>
80006d46:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006d4a:	28 9a       	sub	r10,-119
80006d4c:	c0 a8       	rjmp	80006d60 <_malloc_r+0x1a8>
80006d4e:	e0 4a 05 54 	cp.w	r10,1364
80006d52:	e0 88 00 04 	brls	80006d5a <_malloc_r+0x1a2>
80006d56:	37 ea       	mov	r10,126
80006d58:	c0 48       	rjmp	80006d60 <_malloc_r+0x1a8>
80006d5a:	f2 0a 16 12 	lsr	r10,r9,0x12
80006d5e:	28 4a       	sub	r10,-124
80006d60:	e0 6b 05 38 	mov	r11,1336
80006d64:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006d68:	68 28       	ld.w	r8,r4[0x8]
80006d6a:	08 38       	cp.w	r8,r4
80006d6c:	c0 e1       	brne	80006d88 <_malloc_r+0x1d0>
80006d6e:	76 19       	ld.w	r9,r11[0x4]
80006d70:	a3 4a       	asr	r10,0x2
80006d72:	30 1e       	mov	lr,1
80006d74:	fc 0a 09 4a 	lsl	r10,lr,r10
80006d78:	f3 ea 10 0a 	or	r10,r9,r10
80006d7c:	10 99       	mov	r9,r8
80006d7e:	97 1a       	st.w	r11[0x4],r10
80006d80:	c0 a8       	rjmp	80006d94 <_malloc_r+0x1dc>
80006d82:	70 28       	ld.w	r8,r8[0x8]
80006d84:	08 38       	cp.w	r8,r4
80006d86:	c0 60       	breq	80006d92 <_malloc_r+0x1da>
80006d88:	70 1a       	ld.w	r10,r8[0x4]
80006d8a:	e0 1a ff fc 	andl	r10,0xfffc
80006d8e:	14 39       	cp.w	r9,r10
80006d90:	cf 93       	brcs	80006d82 <_malloc_r+0x1ca>
80006d92:	70 39       	ld.w	r9,r8[0xc]
80006d94:	8d 39       	st.w	r6[0xc],r9
80006d96:	8d 28       	st.w	r6[0x8],r8
80006d98:	91 36       	st.w	r8[0xc],r6
80006d9a:	93 26       	st.w	r9[0x8],r6
80006d9c:	e6 08 14 02 	asr	r8,r3,0x2
80006da0:	30 1b       	mov	r11,1
80006da2:	e0 64 05 38 	mov	r4,1336
80006da6:	f6 08 09 4b 	lsl	r11,r11,r8
80006daa:	68 18       	ld.w	r8,r4[0x4]
80006dac:	10 3b       	cp.w	r11,r8
80006dae:	e0 8b 00 6b 	brhi	80006e84 <_malloc_r+0x2cc>
80006db2:	f7 e8 00 09 	and	r9,r11,r8
80006db6:	c0 b1       	brne	80006dcc <_malloc_r+0x214>
80006db8:	e0 13 ff fc 	andl	r3,0xfffc
80006dbc:	a1 7b       	lsl	r11,0x1
80006dbe:	2f c3       	sub	r3,-4
80006dc0:	c0 38       	rjmp	80006dc6 <_malloc_r+0x20e>
80006dc2:	2f c3       	sub	r3,-4
80006dc4:	a1 7b       	lsl	r11,0x1
80006dc6:	f7 e8 00 09 	and	r9,r11,r8
80006dca:	cf c0       	breq	80006dc2 <_malloc_r+0x20a>
80006dcc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006dd0:	06 92       	mov	r2,r3
80006dd2:	1c 91       	mov	r1,lr
80006dd4:	62 36       	ld.w	r6,r1[0xc]
80006dd6:	c2 e8       	rjmp	80006e32 <_malloc_r+0x27a>
80006dd8:	6c 1a       	ld.w	r10,r6[0x4]
80006dda:	e0 1a ff fc 	andl	r10,0xfffc
80006dde:	f4 07 01 08 	sub	r8,r10,r7
80006de2:	58 f8       	cp.w	r8,15
80006de4:	e0 8a 00 15 	brle	80006e0e <_malloc_r+0x256>
80006de8:	6c 3a       	ld.w	r10,r6[0xc]
80006dea:	6c 29       	ld.w	r9,r6[0x8]
80006dec:	95 29       	st.w	r10[0x8],r9
80006dee:	93 3a       	st.w	r9[0xc],r10
80006df0:	0e 99       	mov	r9,r7
80006df2:	ec 07 00 07 	add	r7,r6,r7
80006df6:	a1 a9       	sbr	r9,0x0
80006df8:	99 37       	st.w	r12[0xc],r7
80006dfa:	99 27       	st.w	r12[0x8],r7
80006dfc:	8d 19       	st.w	r6[0x4],r9
80006dfe:	ee 08 09 08 	st.w	r7[r8],r8
80006e02:	8f 2c       	st.w	r7[0x8],r12
80006e04:	8f 3c       	st.w	r7[0xc],r12
80006e06:	a1 a8       	sbr	r8,0x0
80006e08:	0a 9c       	mov	r12,r5
80006e0a:	8f 18       	st.w	r7[0x4],r8
80006e0c:	c0 d8       	rjmp	80006e26 <_malloc_r+0x26e>
80006e0e:	6c 39       	ld.w	r9,r6[0xc]
80006e10:	58 08       	cp.w	r8,0
80006e12:	c0 f5       	brlt	80006e30 <_malloc_r+0x278>
80006e14:	ec 0a 00 0a 	add	r10,r6,r10
80006e18:	74 18       	ld.w	r8,r10[0x4]
80006e1a:	a1 a8       	sbr	r8,0x0
80006e1c:	0a 9c       	mov	r12,r5
80006e1e:	95 18       	st.w	r10[0x4],r8
80006e20:	6c 28       	ld.w	r8,r6[0x8]
80006e22:	93 28       	st.w	r9[0x8],r8
80006e24:	91 39       	st.w	r8[0xc],r9
80006e26:	fe b0 f4 b7 	rcall	80005794 <__malloc_unlock>
80006e2a:	ec cc ff f8 	sub	r12,r6,-8
80006e2e:	d8 32       	popm	r0-r7,pc
80006e30:	12 96       	mov	r6,r9
80006e32:	02 36       	cp.w	r6,r1
80006e34:	cd 21       	brne	80006dd8 <_malloc_r+0x220>
80006e36:	2f f2       	sub	r2,-1
80006e38:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006e3c:	c0 30       	breq	80006e42 <_malloc_r+0x28a>
80006e3e:	2f 81       	sub	r1,-8
80006e40:	cc ab       	rjmp	80006dd4 <_malloc_r+0x21c>
80006e42:	1c 98       	mov	r8,lr
80006e44:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006e48:	c0 81       	brne	80006e58 <_malloc_r+0x2a0>
80006e4a:	68 19       	ld.w	r9,r4[0x4]
80006e4c:	f6 08 11 ff 	rsub	r8,r11,-1
80006e50:	f3 e8 00 08 	and	r8,r9,r8
80006e54:	89 18       	st.w	r4[0x4],r8
80006e56:	c0 78       	rjmp	80006e64 <_malloc_r+0x2ac>
80006e58:	f0 c9 00 08 	sub	r9,r8,8
80006e5c:	20 13       	sub	r3,1
80006e5e:	70 08       	ld.w	r8,r8[0x0]
80006e60:	12 38       	cp.w	r8,r9
80006e62:	cf 10       	breq	80006e44 <_malloc_r+0x28c>
80006e64:	a1 7b       	lsl	r11,0x1
80006e66:	68 18       	ld.w	r8,r4[0x4]
80006e68:	10 3b       	cp.w	r11,r8
80006e6a:	e0 8b 00 0d 	brhi	80006e84 <_malloc_r+0x2cc>
80006e6e:	58 0b       	cp.w	r11,0
80006e70:	c0 a0       	breq	80006e84 <_malloc_r+0x2cc>
80006e72:	04 93       	mov	r3,r2
80006e74:	c0 38       	rjmp	80006e7a <_malloc_r+0x2c2>
80006e76:	2f c3       	sub	r3,-4
80006e78:	a1 7b       	lsl	r11,0x1
80006e7a:	f7 e8 00 09 	and	r9,r11,r8
80006e7e:	ca 71       	brne	80006dcc <_malloc_r+0x214>
80006e80:	cf bb       	rjmp	80006e76 <_malloc_r+0x2be>
80006e82:	d7 03       	nop
80006e84:	68 23       	ld.w	r3,r4[0x8]
80006e86:	66 12       	ld.w	r2,r3[0x4]
80006e88:	e0 12 ff fc 	andl	r2,0xfffc
80006e8c:	0e 32       	cp.w	r2,r7
80006e8e:	5f 39       	srlo	r9
80006e90:	e4 07 01 08 	sub	r8,r2,r7
80006e94:	58 f8       	cp.w	r8,15
80006e96:	5f aa       	srle	r10
80006e98:	f5 e9 10 09 	or	r9,r10,r9
80006e9c:	e0 80 00 9a 	breq	80006fd0 <_malloc_r+0x418>
80006ea0:	e0 68 0d 54 	mov	r8,3412
80006ea4:	70 01       	ld.w	r1,r8[0x0]
80006ea6:	e0 68 09 44 	mov	r8,2372
80006eaa:	2f 01       	sub	r1,-16
80006eac:	70 08       	ld.w	r8,r8[0x0]
80006eae:	0e 01       	add	r1,r7
80006eb0:	5b f8       	cp.w	r8,-1
80006eb2:	c0 40       	breq	80006eba <_malloc_r+0x302>
80006eb4:	28 11       	sub	r1,-127
80006eb6:	e0 11 ff 80 	andl	r1,0xff80
80006eba:	02 9b       	mov	r11,r1
80006ebc:	0a 9c       	mov	r12,r5
80006ebe:	e0 a0 02 b7 	rcall	8000742c <_sbrk_r>
80006ec2:	18 96       	mov	r6,r12
80006ec4:	5b fc       	cp.w	r12,-1
80006ec6:	c7 50       	breq	80006fb0 <_malloc_r+0x3f8>
80006ec8:	e6 02 00 08 	add	r8,r3,r2
80006ecc:	10 3c       	cp.w	r12,r8
80006ece:	c0 32       	brcc	80006ed4 <_malloc_r+0x31c>
80006ed0:	08 33       	cp.w	r3,r4
80006ed2:	c6 f1       	brne	80006fb0 <_malloc_r+0x3f8>
80006ed4:	e0 6a 0d 58 	mov	r10,3416
80006ed8:	74 09       	ld.w	r9,r10[0x0]
80006eda:	e2 09 00 09 	add	r9,r1,r9
80006ede:	95 09       	st.w	r10[0x0],r9
80006ee0:	10 36       	cp.w	r6,r8
80006ee2:	c0 a1       	brne	80006ef6 <_malloc_r+0x33e>
80006ee4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006ee8:	c0 71       	brne	80006ef6 <_malloc_r+0x33e>
80006eea:	e2 02 00 02 	add	r2,r1,r2
80006eee:	68 28       	ld.w	r8,r4[0x8]
80006ef0:	a1 a2       	sbr	r2,0x0
80006ef2:	91 12       	st.w	r8[0x4],r2
80006ef4:	c4 f8       	rjmp	80006f92 <_malloc_r+0x3da>
80006ef6:	e0 6a 09 44 	mov	r10,2372
80006efa:	74 0b       	ld.w	r11,r10[0x0]
80006efc:	5b fb       	cp.w	r11,-1
80006efe:	c0 31       	brne	80006f04 <_malloc_r+0x34c>
80006f00:	95 06       	st.w	r10[0x0],r6
80006f02:	c0 78       	rjmp	80006f10 <_malloc_r+0x358>
80006f04:	ec 09 00 09 	add	r9,r6,r9
80006f08:	e0 6a 0d 58 	mov	r10,3416
80006f0c:	10 19       	sub	r9,r8
80006f0e:	95 09       	st.w	r10[0x0],r9
80006f10:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006f14:	f0 09 11 08 	rsub	r9,r8,8
80006f18:	58 08       	cp.w	r8,0
80006f1a:	f2 08 17 10 	movne	r8,r9
80006f1e:	ed d8 e1 06 	addne	r6,r6,r8
80006f22:	28 08       	sub	r8,-128
80006f24:	ec 01 00 01 	add	r1,r6,r1
80006f28:	0a 9c       	mov	r12,r5
80006f2a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006f2e:	f0 01 01 01 	sub	r1,r8,r1
80006f32:	02 9b       	mov	r11,r1
80006f34:	e0 a0 02 7c 	rcall	8000742c <_sbrk_r>
80006f38:	e0 68 0d 58 	mov	r8,3416
80006f3c:	5b fc       	cp.w	r12,-1
80006f3e:	ec 0c 17 00 	moveq	r12,r6
80006f42:	f9 b1 00 00 	moveq	r1,0
80006f46:	70 09       	ld.w	r9,r8[0x0]
80006f48:	0c 1c       	sub	r12,r6
80006f4a:	89 26       	st.w	r4[0x8],r6
80006f4c:	02 0c       	add	r12,r1
80006f4e:	12 01       	add	r1,r9
80006f50:	a1 ac       	sbr	r12,0x0
80006f52:	91 01       	st.w	r8[0x0],r1
80006f54:	8d 1c       	st.w	r6[0x4],r12
80006f56:	08 33       	cp.w	r3,r4
80006f58:	c1 d0       	breq	80006f92 <_malloc_r+0x3da>
80006f5a:	58 f2       	cp.w	r2,15
80006f5c:	e0 8b 00 05 	brhi	80006f66 <_malloc_r+0x3ae>
80006f60:	30 18       	mov	r8,1
80006f62:	8d 18       	st.w	r6[0x4],r8
80006f64:	c2 68       	rjmp	80006fb0 <_malloc_r+0x3f8>
80006f66:	30 59       	mov	r9,5
80006f68:	20 c2       	sub	r2,12
80006f6a:	e0 12 ff f8 	andl	r2,0xfff8
80006f6e:	e6 02 00 08 	add	r8,r3,r2
80006f72:	91 29       	st.w	r8[0x8],r9
80006f74:	91 19       	st.w	r8[0x4],r9
80006f76:	66 18       	ld.w	r8,r3[0x4]
80006f78:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f7c:	e5 e8 10 08 	or	r8,r2,r8
80006f80:	87 18       	st.w	r3[0x4],r8
80006f82:	58 f2       	cp.w	r2,15
80006f84:	e0 88 00 07 	brls	80006f92 <_malloc_r+0x3da>
80006f88:	e6 cb ff f8 	sub	r11,r3,-8
80006f8c:	0a 9c       	mov	r12,r5
80006f8e:	e0 a0 1c 7d 	rcall	8000a888 <_free_r>
80006f92:	e0 69 0d 50 	mov	r9,3408
80006f96:	72 0a       	ld.w	r10,r9[0x0]
80006f98:	e0 68 0d 58 	mov	r8,3416
80006f9c:	70 08       	ld.w	r8,r8[0x0]
80006f9e:	14 38       	cp.w	r8,r10
80006fa0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006fa4:	e0 69 0d 4c 	mov	r9,3404
80006fa8:	72 0a       	ld.w	r10,r9[0x0]
80006faa:	14 38       	cp.w	r8,r10
80006fac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006fb0:	68 28       	ld.w	r8,r4[0x8]
80006fb2:	70 18       	ld.w	r8,r8[0x4]
80006fb4:	e0 18 ff fc 	andl	r8,0xfffc
80006fb8:	0e 38       	cp.w	r8,r7
80006fba:	5f 39       	srlo	r9
80006fbc:	0e 18       	sub	r8,r7
80006fbe:	58 f8       	cp.w	r8,15
80006fc0:	5f aa       	srle	r10
80006fc2:	f5 e9 10 09 	or	r9,r10,r9
80006fc6:	c0 50       	breq	80006fd0 <_malloc_r+0x418>
80006fc8:	0a 9c       	mov	r12,r5
80006fca:	fe b0 f3 e5 	rcall	80005794 <__malloc_unlock>
80006fce:	d8 3a       	popm	r0-r7,pc,r12=0
80006fd0:	68 26       	ld.w	r6,r4[0x8]
80006fd2:	a1 a8       	sbr	r8,0x0
80006fd4:	0e 99       	mov	r9,r7
80006fd6:	a1 a9       	sbr	r9,0x0
80006fd8:	8d 19       	st.w	r6[0x4],r9
80006fda:	ec 07 00 07 	add	r7,r6,r7
80006fde:	0a 9c       	mov	r12,r5
80006fe0:	89 27       	st.w	r4[0x8],r7
80006fe2:	8f 18       	st.w	r7[0x4],r8
80006fe4:	fe b0 f3 d8 	rcall	80005794 <__malloc_unlock>
80006fe8:	ec cc ff f8 	sub	r12,r6,-8
80006fec:	d8 32       	popm	r0-r7,pc
80006fee:	d7 03       	nop

80006ff0 <memcmp>:
80006ff0:	d4 01       	pushm	lr
80006ff2:	30 08       	mov	r8,0
80006ff4:	c0 d8       	rjmp	8000700e <memcmp+0x1e>
80006ff6:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80006ffa:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006ffe:	20 1a       	sub	r10,1
80007000:	2f f8       	sub	r8,-1
80007002:	f2 0e 18 00 	cp.b	lr,r9
80007006:	c0 40       	breq	8000700e <memcmp+0x1e>
80007008:	fc 09 01 0c 	sub	r12,lr,r9
8000700c:	d8 02       	popm	pc
8000700e:	58 0a       	cp.w	r10,0
80007010:	cf 31       	brne	80006ff6 <memcmp+0x6>
80007012:	14 9c       	mov	r12,r10
80007014:	d8 02       	popm	pc

80007016 <memcpy>:
80007016:	58 8a       	cp.w	r10,8
80007018:	c2 f5       	brlt	80007076 <memcpy+0x60>
8000701a:	f9 eb 10 09 	or	r9,r12,r11
8000701e:	e2 19 00 03 	andl	r9,0x3,COH
80007022:	e0 81 00 97 	brne	80007150 <memcpy+0x13a>
80007026:	e0 4a 00 20 	cp.w	r10,32
8000702a:	c3 b4       	brge	800070a0 <memcpy+0x8a>
8000702c:	f4 08 14 02 	asr	r8,r10,0x2
80007030:	f0 09 11 08 	rsub	r9,r8,8
80007034:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007038:	76 69       	ld.w	r9,r11[0x18]
8000703a:	99 69       	st.w	r12[0x18],r9
8000703c:	76 59       	ld.w	r9,r11[0x14]
8000703e:	99 59       	st.w	r12[0x14],r9
80007040:	76 49       	ld.w	r9,r11[0x10]
80007042:	99 49       	st.w	r12[0x10],r9
80007044:	76 39       	ld.w	r9,r11[0xc]
80007046:	99 39       	st.w	r12[0xc],r9
80007048:	76 29       	ld.w	r9,r11[0x8]
8000704a:	99 29       	st.w	r12[0x8],r9
8000704c:	76 19       	ld.w	r9,r11[0x4]
8000704e:	99 19       	st.w	r12[0x4],r9
80007050:	76 09       	ld.w	r9,r11[0x0]
80007052:	99 09       	st.w	r12[0x0],r9
80007054:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007058:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000705c:	e0 1a 00 03 	andl	r10,0x3
80007060:	f4 0a 11 04 	rsub	r10,r10,4
80007064:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007068:	17 a9       	ld.ub	r9,r11[0x2]
8000706a:	b0 a9       	st.b	r8[0x2],r9
8000706c:	17 99       	ld.ub	r9,r11[0x1]
8000706e:	b0 99       	st.b	r8[0x1],r9
80007070:	17 89       	ld.ub	r9,r11[0x0]
80007072:	b0 89       	st.b	r8[0x0],r9
80007074:	5e fc       	retal	r12
80007076:	f4 0a 11 09 	rsub	r10,r10,9
8000707a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000707e:	17 f9       	ld.ub	r9,r11[0x7]
80007080:	b8 f9       	st.b	r12[0x7],r9
80007082:	17 e9       	ld.ub	r9,r11[0x6]
80007084:	b8 e9       	st.b	r12[0x6],r9
80007086:	17 d9       	ld.ub	r9,r11[0x5]
80007088:	b8 d9       	st.b	r12[0x5],r9
8000708a:	17 c9       	ld.ub	r9,r11[0x4]
8000708c:	b8 c9       	st.b	r12[0x4],r9
8000708e:	17 b9       	ld.ub	r9,r11[0x3]
80007090:	b8 b9       	st.b	r12[0x3],r9
80007092:	17 a9       	ld.ub	r9,r11[0x2]
80007094:	b8 a9       	st.b	r12[0x2],r9
80007096:	17 99       	ld.ub	r9,r11[0x1]
80007098:	b8 99       	st.b	r12[0x1],r9
8000709a:	17 89       	ld.ub	r9,r11[0x0]
8000709c:	b8 89       	st.b	r12[0x0],r9
8000709e:	5e fc       	retal	r12
800070a0:	eb cd 40 c0 	pushm	r6-r7,lr
800070a4:	18 99       	mov	r9,r12
800070a6:	22 0a       	sub	r10,32
800070a8:	b7 07       	ld.d	r6,r11++
800070aa:	b3 26       	st.d	r9++,r6
800070ac:	b7 07       	ld.d	r6,r11++
800070ae:	b3 26       	st.d	r9++,r6
800070b0:	b7 07       	ld.d	r6,r11++
800070b2:	b3 26       	st.d	r9++,r6
800070b4:	b7 07       	ld.d	r6,r11++
800070b6:	b3 26       	st.d	r9++,r6
800070b8:	22 0a       	sub	r10,32
800070ba:	cf 74       	brge	800070a8 <memcpy+0x92>
800070bc:	2f 0a       	sub	r10,-16
800070be:	c0 65       	brlt	800070ca <memcpy+0xb4>
800070c0:	b7 07       	ld.d	r6,r11++
800070c2:	b3 26       	st.d	r9++,r6
800070c4:	b7 07       	ld.d	r6,r11++
800070c6:	b3 26       	st.d	r9++,r6
800070c8:	21 0a       	sub	r10,16
800070ca:	5c 3a       	neg	r10
800070cc:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800070d0:	d7 03       	nop
800070d2:	d7 03       	nop
800070d4:	f7 36 00 0e 	ld.ub	r6,r11[14]
800070d8:	f3 66 00 0e 	st.b	r9[14],r6
800070dc:	f7 36 00 0d 	ld.ub	r6,r11[13]
800070e0:	f3 66 00 0d 	st.b	r9[13],r6
800070e4:	f7 36 00 0c 	ld.ub	r6,r11[12]
800070e8:	f3 66 00 0c 	st.b	r9[12],r6
800070ec:	f7 36 00 0b 	ld.ub	r6,r11[11]
800070f0:	f3 66 00 0b 	st.b	r9[11],r6
800070f4:	f7 36 00 0a 	ld.ub	r6,r11[10]
800070f8:	f3 66 00 0a 	st.b	r9[10],r6
800070fc:	f7 36 00 09 	ld.ub	r6,r11[9]
80007100:	f3 66 00 09 	st.b	r9[9],r6
80007104:	f7 36 00 08 	ld.ub	r6,r11[8]
80007108:	f3 66 00 08 	st.b	r9[8],r6
8000710c:	f7 36 00 07 	ld.ub	r6,r11[7]
80007110:	f3 66 00 07 	st.b	r9[7],r6
80007114:	f7 36 00 06 	ld.ub	r6,r11[6]
80007118:	f3 66 00 06 	st.b	r9[6],r6
8000711c:	f7 36 00 05 	ld.ub	r6,r11[5]
80007120:	f3 66 00 05 	st.b	r9[5],r6
80007124:	f7 36 00 04 	ld.ub	r6,r11[4]
80007128:	f3 66 00 04 	st.b	r9[4],r6
8000712c:	f7 36 00 03 	ld.ub	r6,r11[3]
80007130:	f3 66 00 03 	st.b	r9[3],r6
80007134:	f7 36 00 02 	ld.ub	r6,r11[2]
80007138:	f3 66 00 02 	st.b	r9[2],r6
8000713c:	f7 36 00 01 	ld.ub	r6,r11[1]
80007140:	f3 66 00 01 	st.b	r9[1],r6
80007144:	f7 36 00 00 	ld.ub	r6,r11[0]
80007148:	f3 66 00 00 	st.b	r9[0],r6
8000714c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007150:	20 1a       	sub	r10,1
80007152:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007156:	f8 0a 0b 09 	st.b	r12[r10],r9
8000715a:	cf b1       	brne	80007150 <memcpy+0x13a>
8000715c:	5e fc       	retal	r12

8000715e <memset>:
8000715e:	18 98       	mov	r8,r12
80007160:	c0 38       	rjmp	80007166 <memset+0x8>
80007162:	10 cb       	st.b	r8++,r11
80007164:	20 1a       	sub	r10,1
80007166:	58 0a       	cp.w	r10,0
80007168:	cf d1       	brne	80007162 <memset+0x4>
8000716a:	5e fc       	retal	r12

8000716c <_realloc_r>:
8000716c:	d4 31       	pushm	r0-r7,lr
8000716e:	20 1d       	sub	sp,4
80007170:	16 94       	mov	r4,r11
80007172:	18 92       	mov	r2,r12
80007174:	14 9b       	mov	r11,r10
80007176:	58 04       	cp.w	r4,0
80007178:	c0 51       	brne	80007182 <_realloc_r+0x16>
8000717a:	fe b0 fd 1f 	rcall	80006bb8 <_malloc_r>
8000717e:	18 95       	mov	r5,r12
80007180:	c5 39       	rjmp	80007426 <_realloc_r+0x2ba>
80007182:	50 0a       	stdsp	sp[0x0],r10
80007184:	fe b0 f3 02 	rcall	80005788 <__malloc_lock>
80007188:	40 0b       	lddsp	r11,sp[0x0]
8000718a:	f6 c8 ff f5 	sub	r8,r11,-11
8000718e:	e8 c1 00 08 	sub	r1,r4,8
80007192:	10 96       	mov	r6,r8
80007194:	62 1c       	ld.w	r12,r1[0x4]
80007196:	e0 16 ff f8 	andl	r6,0xfff8
8000719a:	59 68       	cp.w	r8,22
8000719c:	f9 b6 08 10 	movls	r6,16
800071a0:	16 36       	cp.w	r6,r11
800071a2:	5f 38       	srlo	r8
800071a4:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800071a8:	c0 50       	breq	800071b2 <_realloc_r+0x46>
800071aa:	30 c8       	mov	r8,12
800071ac:	30 05       	mov	r5,0
800071ae:	85 38       	st.w	r2[0xc],r8
800071b0:	c3 b9       	rjmp	80007426 <_realloc_r+0x2ba>
800071b2:	18 90       	mov	r0,r12
800071b4:	e0 10 ff fc 	andl	r0,0xfffc
800071b8:	0c 30       	cp.w	r0,r6
800071ba:	e0 84 01 0b 	brge	800073d0 <_realloc_r+0x264>
800071be:	e0 68 05 38 	mov	r8,1336
800071c2:	e2 00 00 09 	add	r9,r1,r0
800071c6:	70 25       	ld.w	r5,r8[0x8]
800071c8:	0a 39       	cp.w	r9,r5
800071ca:	c0 90       	breq	800071dc <_realloc_r+0x70>
800071cc:	72 1a       	ld.w	r10,r9[0x4]
800071ce:	a1 ca       	cbr	r10,0x0
800071d0:	f2 0a 00 0a 	add	r10,r9,r10
800071d4:	74 1a       	ld.w	r10,r10[0x4]
800071d6:	ed ba 00 00 	bld	r10,0x0
800071da:	c2 20       	breq	8000721e <_realloc_r+0xb2>
800071dc:	72 1a       	ld.w	r10,r9[0x4]
800071de:	e0 1a ff fc 	andl	r10,0xfffc
800071e2:	f4 00 00 03 	add	r3,r10,r0
800071e6:	0a 39       	cp.w	r9,r5
800071e8:	c1 31       	brne	8000720e <_realloc_r+0xa2>
800071ea:	ec c7 ff f0 	sub	r7,r6,-16
800071ee:	0e 33       	cp.w	r3,r7
800071f0:	c1 95       	brlt	80007222 <_realloc_r+0xb6>
800071f2:	e2 06 00 09 	add	r9,r1,r6
800071f6:	0c 13       	sub	r3,r6
800071f8:	a1 a3       	sbr	r3,0x0
800071fa:	93 13       	st.w	r9[0x4],r3
800071fc:	91 29       	st.w	r8[0x8],r9
800071fe:	04 9c       	mov	r12,r2
80007200:	62 18       	ld.w	r8,r1[0x4]
80007202:	08 95       	mov	r5,r4
80007204:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007208:	10 46       	or	r6,r8
8000720a:	83 16       	st.w	r1[0x4],r6
8000720c:	c0 b9       	rjmp	80007422 <_realloc_r+0x2b6>
8000720e:	0c 33       	cp.w	r3,r6
80007210:	c0 95       	brlt	80007222 <_realloc_r+0xb6>
80007212:	72 28       	ld.w	r8,r9[0x8]
80007214:	02 97       	mov	r7,r1
80007216:	72 39       	ld.w	r9,r9[0xc]
80007218:	93 28       	st.w	r9[0x8],r8
8000721a:	91 39       	st.w	r8[0xc],r9
8000721c:	cd c8       	rjmp	800073d4 <_realloc_r+0x268>
8000721e:	30 0a       	mov	r10,0
80007220:	14 99       	mov	r9,r10
80007222:	ed bc 00 00 	bld	r12,0x0
80007226:	e0 80 00 95 	breq	80007350 <_realloc_r+0x1e4>
8000722a:	62 07       	ld.w	r7,r1[0x0]
8000722c:	e2 07 01 07 	sub	r7,r1,r7
80007230:	6e 1c       	ld.w	r12,r7[0x4]
80007232:	e0 1c ff fc 	andl	r12,0xfffc
80007236:	58 09       	cp.w	r9,0
80007238:	c5 60       	breq	800072e4 <_realloc_r+0x178>
8000723a:	f8 00 00 03 	add	r3,r12,r0
8000723e:	0a 39       	cp.w	r9,r5
80007240:	c4 81       	brne	800072d0 <_realloc_r+0x164>
80007242:	14 03       	add	r3,r10
80007244:	ec c9 ff f0 	sub	r9,r6,-16
80007248:	12 33       	cp.w	r3,r9
8000724a:	c4 d5       	brlt	800072e4 <_realloc_r+0x178>
8000724c:	6e 3a       	ld.w	r10,r7[0xc]
8000724e:	6e 29       	ld.w	r9,r7[0x8]
80007250:	95 29       	st.w	r10[0x8],r9
80007252:	93 3a       	st.w	r9[0xc],r10
80007254:	ee c5 ff f8 	sub	r5,r7,-8
80007258:	e0 ca 00 04 	sub	r10,r0,4
8000725c:	e0 4a 00 24 	cp.w	r10,36
80007260:	e0 8b 00 25 	brhi	800072aa <_realloc_r+0x13e>
80007264:	0a 99       	mov	r9,r5
80007266:	59 3a       	cp.w	r10,19
80007268:	e0 88 00 1a 	brls	8000729c <_realloc_r+0x130>
8000726c:	09 09       	ld.w	r9,r4++
8000726e:	8b 09       	st.w	r5[0x0],r9
80007270:	09 09       	ld.w	r9,r4++
80007272:	8f 39       	st.w	r7[0xc],r9
80007274:	ee c9 ff f0 	sub	r9,r7,-16
80007278:	59 ba       	cp.w	r10,27
8000727a:	e0 88 00 11 	brls	8000729c <_realloc_r+0x130>
8000727e:	09 0b       	ld.w	r11,r4++
80007280:	93 0b       	st.w	r9[0x0],r11
80007282:	09 09       	ld.w	r9,r4++
80007284:	8f 59       	st.w	r7[0x14],r9
80007286:	ee c9 ff e8 	sub	r9,r7,-24
8000728a:	e0 4a 00 24 	cp.w	r10,36
8000728e:	c0 71       	brne	8000729c <_realloc_r+0x130>
80007290:	09 0a       	ld.w	r10,r4++
80007292:	93 0a       	st.w	r9[0x0],r10
80007294:	ee c9 ff e0 	sub	r9,r7,-32
80007298:	09 0a       	ld.w	r10,r4++
8000729a:	8f 7a       	st.w	r7[0x1c],r10
8000729c:	09 0a       	ld.w	r10,r4++
8000729e:	12 aa       	st.w	r9++,r10
800072a0:	68 0a       	ld.w	r10,r4[0x0]
800072a2:	93 0a       	st.w	r9[0x0],r10
800072a4:	68 1a       	ld.w	r10,r4[0x4]
800072a6:	93 1a       	st.w	r9[0x4],r10
800072a8:	c0 78       	rjmp	800072b6 <_realloc_r+0x14a>
800072aa:	50 08       	stdsp	sp[0x0],r8
800072ac:	08 9b       	mov	r11,r4
800072ae:	0a 9c       	mov	r12,r5
800072b0:	e0 a0 1d 8f 	rcall	8000adce <memmove>
800072b4:	40 08       	lddsp	r8,sp[0x0]
800072b6:	ee 06 00 09 	add	r9,r7,r6
800072ba:	0c 13       	sub	r3,r6
800072bc:	a1 a3       	sbr	r3,0x0
800072be:	93 13       	st.w	r9[0x4],r3
800072c0:	91 29       	st.w	r8[0x8],r9
800072c2:	04 9c       	mov	r12,r2
800072c4:	6e 18       	ld.w	r8,r7[0x4]
800072c6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800072ca:	10 46       	or	r6,r8
800072cc:	8f 16       	st.w	r7[0x4],r6
800072ce:	ca a8       	rjmp	80007422 <_realloc_r+0x2b6>
800072d0:	14 03       	add	r3,r10
800072d2:	0c 33       	cp.w	r3,r6
800072d4:	c0 85       	brlt	800072e4 <_realloc_r+0x178>
800072d6:	72 28       	ld.w	r8,r9[0x8]
800072d8:	72 39       	ld.w	r9,r9[0xc]
800072da:	93 28       	st.w	r9[0x8],r8
800072dc:	91 39       	st.w	r8[0xc],r9
800072de:	6e 28       	ld.w	r8,r7[0x8]
800072e0:	6e 39       	ld.w	r9,r7[0xc]
800072e2:	c0 78       	rjmp	800072f0 <_realloc_r+0x184>
800072e4:	f8 00 00 03 	add	r3,r12,r0
800072e8:	0c 33       	cp.w	r3,r6
800072ea:	c3 35       	brlt	80007350 <_realloc_r+0x1e4>
800072ec:	6e 39       	ld.w	r9,r7[0xc]
800072ee:	6e 28       	ld.w	r8,r7[0x8]
800072f0:	93 28       	st.w	r9[0x8],r8
800072f2:	91 39       	st.w	r8[0xc],r9
800072f4:	e0 ca 00 04 	sub	r10,r0,4
800072f8:	ee cc ff f8 	sub	r12,r7,-8
800072fc:	e0 4a 00 24 	cp.w	r10,36
80007300:	e0 8b 00 24 	brhi	80007348 <_realloc_r+0x1dc>
80007304:	59 3a       	cp.w	r10,19
80007306:	e0 88 00 1a 	brls	8000733a <_realloc_r+0x1ce>
8000730a:	09 08       	ld.w	r8,r4++
8000730c:	99 08       	st.w	r12[0x0],r8
8000730e:	09 08       	ld.w	r8,r4++
80007310:	8f 38       	st.w	r7[0xc],r8
80007312:	ee cc ff f0 	sub	r12,r7,-16
80007316:	59 ba       	cp.w	r10,27
80007318:	e0 88 00 11 	brls	8000733a <_realloc_r+0x1ce>
8000731c:	09 08       	ld.w	r8,r4++
8000731e:	99 08       	st.w	r12[0x0],r8
80007320:	09 08       	ld.w	r8,r4++
80007322:	8f 58       	st.w	r7[0x14],r8
80007324:	ee cc ff e8 	sub	r12,r7,-24
80007328:	e0 4a 00 24 	cp.w	r10,36
8000732c:	c0 71       	brne	8000733a <_realloc_r+0x1ce>
8000732e:	09 08       	ld.w	r8,r4++
80007330:	99 08       	st.w	r12[0x0],r8
80007332:	ee cc ff e0 	sub	r12,r7,-32
80007336:	09 08       	ld.w	r8,r4++
80007338:	8f 78       	st.w	r7[0x1c],r8
8000733a:	09 08       	ld.w	r8,r4++
8000733c:	18 a8       	st.w	r12++,r8
8000733e:	68 08       	ld.w	r8,r4[0x0]
80007340:	99 08       	st.w	r12[0x0],r8
80007342:	68 18       	ld.w	r8,r4[0x4]
80007344:	99 18       	st.w	r12[0x4],r8
80007346:	c4 78       	rjmp	800073d4 <_realloc_r+0x268>
80007348:	08 9b       	mov	r11,r4
8000734a:	e0 a0 1d 42 	rcall	8000adce <memmove>
8000734e:	c4 38       	rjmp	800073d4 <_realloc_r+0x268>
80007350:	04 9c       	mov	r12,r2
80007352:	fe b0 fc 33 	rcall	80006bb8 <_malloc_r>
80007356:	18 95       	mov	r5,r12
80007358:	c3 a0       	breq	800073cc <_realloc_r+0x260>
8000735a:	62 18       	ld.w	r8,r1[0x4]
8000735c:	f8 c9 00 08 	sub	r9,r12,8
80007360:	a1 c8       	cbr	r8,0x0
80007362:	e2 08 00 08 	add	r8,r1,r8
80007366:	10 39       	cp.w	r9,r8
80007368:	c0 71       	brne	80007376 <_realloc_r+0x20a>
8000736a:	72 13       	ld.w	r3,r9[0x4]
8000736c:	02 97       	mov	r7,r1
8000736e:	e0 13 ff fc 	andl	r3,0xfffc
80007372:	00 03       	add	r3,r0
80007374:	c3 08       	rjmp	800073d4 <_realloc_r+0x268>
80007376:	e0 ca 00 04 	sub	r10,r0,4
8000737a:	e0 4a 00 24 	cp.w	r10,36
8000737e:	e0 8b 00 20 	brhi	800073be <_realloc_r+0x252>
80007382:	08 99       	mov	r9,r4
80007384:	18 98       	mov	r8,r12
80007386:	59 3a       	cp.w	r10,19
80007388:	e0 88 00 14 	brls	800073b0 <_realloc_r+0x244>
8000738c:	13 0b       	ld.w	r11,r9++
8000738e:	10 ab       	st.w	r8++,r11
80007390:	13 0b       	ld.w	r11,r9++
80007392:	10 ab       	st.w	r8++,r11
80007394:	59 ba       	cp.w	r10,27
80007396:	e0 88 00 0d 	brls	800073b0 <_realloc_r+0x244>
8000739a:	13 0b       	ld.w	r11,r9++
8000739c:	10 ab       	st.w	r8++,r11
8000739e:	13 0b       	ld.w	r11,r9++
800073a0:	10 ab       	st.w	r8++,r11
800073a2:	e0 4a 00 24 	cp.w	r10,36
800073a6:	c0 51       	brne	800073b0 <_realloc_r+0x244>
800073a8:	13 0a       	ld.w	r10,r9++
800073aa:	10 aa       	st.w	r8++,r10
800073ac:	13 0a       	ld.w	r10,r9++
800073ae:	10 aa       	st.w	r8++,r10
800073b0:	13 0a       	ld.w	r10,r9++
800073b2:	10 aa       	st.w	r8++,r10
800073b4:	72 0a       	ld.w	r10,r9[0x0]
800073b6:	91 0a       	st.w	r8[0x0],r10
800073b8:	72 19       	ld.w	r9,r9[0x4]
800073ba:	91 19       	st.w	r8[0x4],r9
800073bc:	c0 48       	rjmp	800073c4 <_realloc_r+0x258>
800073be:	08 9b       	mov	r11,r4
800073c0:	e0 a0 1d 07 	rcall	8000adce <memmove>
800073c4:	08 9b       	mov	r11,r4
800073c6:	04 9c       	mov	r12,r2
800073c8:	e0 a0 1a 60 	rcall	8000a888 <_free_r>
800073cc:	04 9c       	mov	r12,r2
800073ce:	c2 a8       	rjmp	80007422 <_realloc_r+0x2b6>
800073d0:	00 93       	mov	r3,r0
800073d2:	02 97       	mov	r7,r1
800073d4:	e6 06 01 09 	sub	r9,r3,r6
800073d8:	6e 18       	ld.w	r8,r7[0x4]
800073da:	58 f9       	cp.w	r9,15
800073dc:	e0 88 00 16 	brls	80007408 <_realloc_r+0x29c>
800073e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073e4:	ed e8 10 08 	or	r8,r6,r8
800073e8:	8f 18       	st.w	r7[0x4],r8
800073ea:	12 98       	mov	r8,r9
800073ec:	a1 a8       	sbr	r8,0x0
800073ee:	ee 06 00 0b 	add	r11,r7,r6
800073f2:	f6 09 00 09 	add	r9,r11,r9
800073f6:	97 18       	st.w	r11[0x4],r8
800073f8:	72 18       	ld.w	r8,r9[0x4]
800073fa:	a1 a8       	sbr	r8,0x0
800073fc:	2f 8b       	sub	r11,-8
800073fe:	93 18       	st.w	r9[0x4],r8
80007400:	04 9c       	mov	r12,r2
80007402:	e0 a0 1a 43 	rcall	8000a888 <_free_r>
80007406:	c0 b8       	rjmp	8000741c <_realloc_r+0x2b0>
80007408:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000740c:	e7 e8 10 08 	or	r8,r3,r8
80007410:	8f 18       	st.w	r7[0x4],r8
80007412:	ee 03 00 03 	add	r3,r7,r3
80007416:	66 18       	ld.w	r8,r3[0x4]
80007418:	a1 a8       	sbr	r8,0x0
8000741a:	87 18       	st.w	r3[0x4],r8
8000741c:	04 9c       	mov	r12,r2
8000741e:	ee c5 ff f8 	sub	r5,r7,-8
80007422:	fe b0 f1 b9 	rcall	80005794 <__malloc_unlock>
80007426:	0a 9c       	mov	r12,r5
80007428:	2f fd       	sub	sp,-4
8000742a:	d8 32       	popm	r0-r7,pc

8000742c <_sbrk_r>:
8000742c:	d4 21       	pushm	r4-r7,lr
8000742e:	30 08       	mov	r8,0
80007430:	18 97       	mov	r7,r12
80007432:	e0 66 63 9c 	mov	r6,25500
80007436:	16 9c       	mov	r12,r11
80007438:	8d 08       	st.w	r6[0x0],r8
8000743a:	c8 5c       	rcall	80007544 <_sbrk>
8000743c:	5b fc       	cp.w	r12,-1
8000743e:	c0 51       	brne	80007448 <_sbrk_r+0x1c>
80007440:	6c 08       	ld.w	r8,r6[0x0]
80007442:	58 08       	cp.w	r8,0
80007444:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007448:	d8 22       	popm	r4-r7,pc
8000744a:	d7 03       	nop

8000744c <sprintf>:
8000744c:	d4 01       	pushm	lr
8000744e:	21 7d       	sub	sp,92
80007450:	e0 68 ff ff 	mov	r8,65535
80007454:	ea 18 7f ff 	orh	r8,0x7fff
80007458:	50 58       	stdsp	sp[0x14],r8
8000745a:	50 28       	stdsp	sp[0x8],r8
8000745c:	e0 68 02 08 	mov	r8,520
80007460:	ba 68       	st.h	sp[0xc],r8
80007462:	3f f8       	mov	r8,-1
80007464:	ba 78       	st.h	sp[0xe],r8
80007466:	e0 68 0a 38 	mov	r8,2616
8000746a:	50 4c       	stdsp	sp[0x10],r12
8000746c:	16 9a       	mov	r10,r11
8000746e:	50 0c       	stdsp	sp[0x0],r12
80007470:	fa c9 ff a0 	sub	r9,sp,-96
80007474:	70 0c       	ld.w	r12,r8[0x0]
80007476:	1a 9b       	mov	r11,sp
80007478:	e0 a0 02 1a 	rcall	800078ac <_vfprintf_r>
8000747c:	30 09       	mov	r9,0
8000747e:	40 08       	lddsp	r8,sp[0x0]
80007480:	b0 89       	st.b	r8[0x0],r9
80007482:	2e 9d       	sub	sp,-92
80007484:	d8 02       	popm	pc
80007486:	d7 03       	nop

80007488 <strncpy>:
80007488:	30 08       	mov	r8,0
8000748a:	10 3a       	cp.w	r10,r8
8000748c:	5e 0c       	reteq	r12
8000748e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007492:	f8 08 0b 09 	st.b	r12[r8],r9
80007496:	2f f8       	sub	r8,-1
80007498:	58 09       	cp.w	r9,0
8000749a:	cf 81       	brne	8000748a <strncpy+0x2>
8000749c:	10 3a       	cp.w	r10,r8
8000749e:	5e 0c       	reteq	r12
800074a0:	f8 08 0b 09 	st.b	r12[r8],r9
800074a4:	2f f8       	sub	r8,-1
800074a6:	cf bb       	rjmp	8000749c <strncpy+0x14>

800074a8 <_close>:
800074a8:	30 28       	mov	r8,2
800074aa:	d6 73       	breakpoint
800074ac:	3f fc       	mov	r12,-1
800074ae:	35 8b       	mov	r11,88
800074b0:	58 0c       	cp.w	r12,0
800074b2:	5e 4c       	retge	r12
800074b4:	e0 6a 63 9c 	mov	r10,25500
800074b8:	95 0b       	st.w	r10[0x0],r11
800074ba:	5e fc       	retal	r12

800074bc <_lseek>:
800074bc:	30 58       	mov	r8,5
800074be:	d6 73       	breakpoint
800074c0:	3f fc       	mov	r12,-1
800074c2:	35 8b       	mov	r11,88
800074c4:	58 0c       	cp.w	r12,0
800074c6:	5e 4c       	retge	r12
800074c8:	e0 6a 63 9c 	mov	r10,25500
800074cc:	95 0b       	st.w	r10[0x0],r11
800074ce:	5e fc       	retal	r12

800074d0 <isatty>:
800074d0:	30 b8       	mov	r8,11
800074d2:	d6 73       	breakpoint
800074d4:	3f fc       	mov	r12,-1
800074d6:	35 8b       	mov	r11,88
800074d8:	58 0c       	cp.w	r12,0
800074da:	5e 4c       	retge	r12
800074dc:	e0 6a 63 9c 	mov	r10,25500
800074e0:	95 0b       	st.w	r10[0x0],r11
800074e2:	5e fc       	retal	r12

800074e4 <_fstat_host>:
800074e4:	30 98       	mov	r8,9
800074e6:	d6 73       	breakpoint
800074e8:	3f fc       	mov	r12,-1
800074ea:	35 8b       	mov	r11,88
800074ec:	58 0c       	cp.w	r12,0
800074ee:	5e 4c       	retge	r12
800074f0:	e0 6a 63 9c 	mov	r10,25500
800074f4:	95 0b       	st.w	r10[0x0],r11
800074f6:	5e fc       	retal	r12

800074f8 <_fstat>:
800074f8:	d4 21       	pushm	r4-r7,lr
800074fa:	21 0d       	sub	sp,64
800074fc:	16 97       	mov	r7,r11
800074fe:	1a 9b       	mov	r11,sp
80007500:	cf 2f       	rcall	800074e4 <_fstat_host>
80007502:	c0 34       	brge	80007508 <_fstat+0x10>
80007504:	3f fc       	mov	r12,-1
80007506:	c1 c8       	rjmp	8000753e <_fstat+0x46>
80007508:	40 08       	lddsp	r8,sp[0x0]
8000750a:	ae 08       	st.h	r7[0x0],r8
8000750c:	40 18       	lddsp	r8,sp[0x4]
8000750e:	ae 18       	st.h	r7[0x2],r8
80007510:	40 28       	lddsp	r8,sp[0x8]
80007512:	8f 18       	st.w	r7[0x4],r8
80007514:	40 38       	lddsp	r8,sp[0xc]
80007516:	ae 48       	st.h	r7[0x8],r8
80007518:	40 48       	lddsp	r8,sp[0x10]
8000751a:	ae 58       	st.h	r7[0xa],r8
8000751c:	40 58       	lddsp	r8,sp[0x14]
8000751e:	ae 68       	st.h	r7[0xc],r8
80007520:	40 68       	lddsp	r8,sp[0x18]
80007522:	ae 78       	st.h	r7[0xe],r8
80007524:	40 88       	lddsp	r8,sp[0x20]
80007526:	8f 48       	st.w	r7[0x10],r8
80007528:	40 a8       	lddsp	r8,sp[0x28]
8000752a:	8f b8       	st.w	r7[0x2c],r8
8000752c:	40 c8       	lddsp	r8,sp[0x30]
8000752e:	8f c8       	st.w	r7[0x30],r8
80007530:	40 d8       	lddsp	r8,sp[0x34]
80007532:	8f 58       	st.w	r7[0x14],r8
80007534:	40 e8       	lddsp	r8,sp[0x38]
80007536:	30 0c       	mov	r12,0
80007538:	8f 78       	st.w	r7[0x1c],r8
8000753a:	40 f8       	lddsp	r8,sp[0x3c]
8000753c:	8f 98       	st.w	r7[0x24],r8
8000753e:	2f 0d       	sub	sp,-64
80007540:	d8 22       	popm	r4-r7,pc
80007542:	d7 03       	nop

80007544 <_sbrk>:
80007544:	d4 01       	pushm	lr
80007546:	e0 68 0d 80 	mov	r8,3456
8000754a:	70 09       	ld.w	r9,r8[0x0]
8000754c:	58 09       	cp.w	r9,0
8000754e:	c0 41       	brne	80007556 <_sbrk+0x12>
80007550:	e0 69 63 a0 	mov	r9,25504
80007554:	91 09       	st.w	r8[0x0],r9
80007556:	e0 69 0d 80 	mov	r9,3456
8000755a:	e0 7a 70 00 	mov	r10,94208
8000755e:	72 08       	ld.w	r8,r9[0x0]
80007560:	f0 0c 00 0c 	add	r12,r8,r12
80007564:	14 3c       	cp.w	r12,r10
80007566:	e0 8b 00 04 	brhi	8000756e <_sbrk+0x2a>
8000756a:	93 0c       	st.w	r9[0x0],r12
8000756c:	c0 68       	rjmp	80007578 <_sbrk+0x34>
8000756e:	e0 a0 18 15 	rcall	8000a598 <__errno>
80007572:	30 c8       	mov	r8,12
80007574:	99 08       	st.w	r12[0x0],r8
80007576:	3f f8       	mov	r8,-1
80007578:	10 9c       	mov	r12,r8
8000757a:	d8 02       	popm	pc

8000757c <get_arg>:
8000757c:	d4 31       	pushm	r0-r7,lr
8000757e:	20 8d       	sub	sp,32
80007580:	fa c4 ff bc 	sub	r4,sp,-68
80007584:	50 4b       	stdsp	sp[0x10],r11
80007586:	68 2e       	ld.w	lr,r4[0x8]
80007588:	50 58       	stdsp	sp[0x14],r8
8000758a:	12 96       	mov	r6,r9
8000758c:	7c 0b       	ld.w	r11,lr[0x0]
8000758e:	70 05       	ld.w	r5,r8[0x0]
80007590:	50 6e       	stdsp	sp[0x18],lr
80007592:	58 0b       	cp.w	r11,0
80007594:	f4 0b 17 00 	moveq	r11,r10
80007598:	68 03       	ld.w	r3,r4[0x0]
8000759a:	68 11       	ld.w	r1,r4[0x4]
8000759c:	40 49       	lddsp	r9,sp[0x10]
8000759e:	30 08       	mov	r8,0
800075a0:	c2 89       	rjmp	800077f0 <get_arg+0x274>
800075a2:	2f fb       	sub	r11,-1
800075a4:	32 5c       	mov	r12,37
800075a6:	17 8a       	ld.ub	r10,r11[0x0]
800075a8:	f8 0a 18 00 	cp.b	r10,r12
800075ac:	5f 1e       	srne	lr
800075ae:	f0 0a 18 00 	cp.b	r10,r8
800075b2:	5f 1c       	srne	r12
800075b4:	fd ec 00 0c 	and	r12,lr,r12
800075b8:	f0 0c 18 00 	cp.b	r12,r8
800075bc:	cf 31       	brne	800075a2 <get_arg+0x26>
800075be:	58 0a       	cp.w	r10,0
800075c0:	e0 80 01 25 	breq	8000780a <get_arg+0x28e>
800075c4:	30 0c       	mov	r12,0
800075c6:	3f fa       	mov	r10,-1
800075c8:	18 90       	mov	r0,r12
800075ca:	50 3a       	stdsp	sp[0xc],r10
800075cc:	18 94       	mov	r4,r12
800075ce:	18 92       	mov	r2,r12
800075d0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800075d4:	16 97       	mov	r7,r11
800075d6:	50 7c       	stdsp	sp[0x1c],r12
800075d8:	fe cc 9f 2c 	sub	r12,pc,-24788
800075dc:	0f 3a       	ld.ub	r10,r7++
800075de:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800075e2:	40 7c       	lddsp	r12,sp[0x1c]
800075e4:	1c 0c       	add	r12,lr
800075e6:	fe ce a0 02 	sub	lr,pc,-24574
800075ea:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800075ee:	20 1e       	sub	lr,1
800075f0:	50 0e       	stdsp	sp[0x0],lr
800075f2:	fe ce a0 7a 	sub	lr,pc,-24454
800075f6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800075fa:	50 7c       	stdsp	sp[0x1c],r12
800075fc:	40 0c       	lddsp	r12,sp[0x0]
800075fe:	58 7c       	cp.w	r12,7
80007600:	e0 8b 00 f1 	brhi	800077e2 <get_arg+0x266>
80007604:	fe ce a2 2c 	sub	lr,pc,-24020
80007608:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000760c:	36 8b       	mov	r11,104
8000760e:	f6 0a 18 00 	cp.b	r10,r11
80007612:	e0 80 00 e8 	breq	800077e2 <get_arg+0x266>
80007616:	37 1b       	mov	r11,113
80007618:	f6 0a 18 00 	cp.b	r10,r11
8000761c:	c0 70       	breq	8000762a <get_arg+0xae>
8000761e:	34 cb       	mov	r11,76
80007620:	f6 0a 18 00 	cp.b	r10,r11
80007624:	c0 51       	brne	8000762e <get_arg+0xb2>
80007626:	a3 b4       	sbr	r4,0x3
80007628:	cd d8       	rjmp	800077e2 <get_arg+0x266>
8000762a:	a5 b4       	sbr	r4,0x5
8000762c:	cd b8       	rjmp	800077e2 <get_arg+0x266>
8000762e:	08 9a       	mov	r10,r4
80007630:	0e 9b       	mov	r11,r7
80007632:	a5 aa       	sbr	r10,0x4
80007634:	17 3c       	ld.ub	r12,r11++
80007636:	a5 b4       	sbr	r4,0x5
80007638:	36 ce       	mov	lr,108
8000763a:	fc 0c 18 00 	cp.b	r12,lr
8000763e:	e0 80 00 d3 	breq	800077e4 <get_arg+0x268>
80007642:	14 94       	mov	r4,r10
80007644:	cc f8       	rjmp	800077e2 <get_arg+0x266>
80007646:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000764a:	36 7c       	mov	r12,103
8000764c:	f8 0a 18 00 	cp.b	r10,r12
80007650:	e0 8b 00 27 	brhi	8000769e <get_arg+0x122>
80007654:	36 5b       	mov	r11,101
80007656:	f6 0a 18 00 	cp.b	r10,r11
8000765a:	c4 82       	brcc	800076ea <get_arg+0x16e>
8000765c:	34 fb       	mov	r11,79
8000765e:	f6 0a 18 00 	cp.b	r10,r11
80007662:	c4 80       	breq	800076f2 <get_arg+0x176>
80007664:	e0 8b 00 0c 	brhi	8000767c <get_arg+0x100>
80007668:	34 5b       	mov	r11,69
8000766a:	f6 0a 18 00 	cp.b	r10,r11
8000766e:	c3 e0       	breq	800076ea <get_arg+0x16e>
80007670:	34 7b       	mov	r11,71
80007672:	f6 0a 18 00 	cp.b	r10,r11
80007676:	c3 a0       	breq	800076ea <get_arg+0x16e>
80007678:	34 4b       	mov	r11,68
8000767a:	c0 88       	rjmp	8000768a <get_arg+0x10e>
8000767c:	35 8b       	mov	r11,88
8000767e:	f6 0a 18 00 	cp.b	r10,r11
80007682:	c2 c0       	breq	800076da <get_arg+0x15e>
80007684:	e0 8b 00 07 	brhi	80007692 <get_arg+0x116>
80007688:	35 5b       	mov	r11,85
8000768a:	f6 0a 18 00 	cp.b	r10,r11
8000768e:	c3 51       	brne	800076f8 <get_arg+0x17c>
80007690:	c3 18       	rjmp	800076f2 <get_arg+0x176>
80007692:	36 3b       	mov	r11,99
80007694:	f6 0a 18 00 	cp.b	r10,r11
80007698:	c2 f0       	breq	800076f6 <get_arg+0x17a>
8000769a:	36 4b       	mov	r11,100
8000769c:	c0 e8       	rjmp	800076b8 <get_arg+0x13c>
8000769e:	37 0b       	mov	r11,112
800076a0:	f6 0a 18 00 	cp.b	r10,r11
800076a4:	c2 50       	breq	800076ee <get_arg+0x172>
800076a6:	e0 8b 00 0d 	brhi	800076c0 <get_arg+0x144>
800076aa:	36 eb       	mov	r11,110
800076ac:	f6 0a 18 00 	cp.b	r10,r11
800076b0:	c1 f0       	breq	800076ee <get_arg+0x172>
800076b2:	e0 8b 00 14 	brhi	800076da <get_arg+0x15e>
800076b6:	36 9b       	mov	r11,105
800076b8:	f6 0a 18 00 	cp.b	r10,r11
800076bc:	c1 e1       	brne	800076f8 <get_arg+0x17c>
800076be:	c0 e8       	rjmp	800076da <get_arg+0x15e>
800076c0:	37 5b       	mov	r11,117
800076c2:	f6 0a 18 00 	cp.b	r10,r11
800076c6:	c0 a0       	breq	800076da <get_arg+0x15e>
800076c8:	37 8b       	mov	r11,120
800076ca:	f6 0a 18 00 	cp.b	r10,r11
800076ce:	c0 60       	breq	800076da <get_arg+0x15e>
800076d0:	37 3b       	mov	r11,115
800076d2:	f6 0a 18 00 	cp.b	r10,r11
800076d6:	c1 11       	brne	800076f8 <get_arg+0x17c>
800076d8:	c0 b8       	rjmp	800076ee <get_arg+0x172>
800076da:	ed b4 00 04 	bld	r4,0x4
800076de:	c0 a0       	breq	800076f2 <get_arg+0x176>
800076e0:	ed b4 00 05 	bld	r4,0x5
800076e4:	c0 91       	brne	800076f6 <get_arg+0x17a>
800076e6:	30 20       	mov	r0,2
800076e8:	c0 88       	rjmp	800076f8 <get_arg+0x17c>
800076ea:	30 40       	mov	r0,4
800076ec:	c0 68       	rjmp	800076f8 <get_arg+0x17c>
800076ee:	30 30       	mov	r0,3
800076f0:	c0 48       	rjmp	800076f8 <get_arg+0x17c>
800076f2:	30 10       	mov	r0,1
800076f4:	c0 28       	rjmp	800076f8 <get_arg+0x17c>
800076f6:	30 00       	mov	r0,0
800076f8:	40 3b       	lddsp	r11,sp[0xc]
800076fa:	5b fb       	cp.w	r11,-1
800076fc:	c0 40       	breq	80007704 <get_arg+0x188>
800076fe:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007702:	c7 08       	rjmp	800077e2 <get_arg+0x266>
80007704:	58 60       	cp.w	r0,6
80007706:	e0 8b 00 6e 	brhi	800077e2 <get_arg+0x266>
8000770a:	6c 0a       	ld.w	r10,r6[0x0]
8000770c:	ea cc ff ff 	sub	r12,r5,-1
80007710:	fe ce a3 18 	sub	lr,pc,-23784
80007714:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007718:	f4 cb ff f8 	sub	r11,r10,-8
8000771c:	8d 0b       	st.w	r6[0x0],r11
8000771e:	f4 ea 00 00 	ld.d	r10,r10[0]
80007722:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007726:	c0 f8       	rjmp	80007744 <get_arg+0x1c8>
80007728:	f4 cb ff fc 	sub	r11,r10,-4
8000772c:	8d 0b       	st.w	r6[0x0],r11
8000772e:	74 0a       	ld.w	r10,r10[0x0]
80007730:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007734:	c0 88       	rjmp	80007744 <get_arg+0x1c8>
80007736:	f4 cb ff f8 	sub	r11,r10,-8
8000773a:	8d 0b       	st.w	r6[0x0],r11
8000773c:	f4 ea 00 00 	ld.d	r10,r10[0]
80007740:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007744:	0e 9b       	mov	r11,r7
80007746:	18 95       	mov	r5,r12
80007748:	c4 e8       	rjmp	800077e4 <get_arg+0x268>
8000774a:	62 0a       	ld.w	r10,r1[0x0]
8000774c:	5b fa       	cp.w	r10,-1
8000774e:	c0 b1       	brne	80007764 <get_arg+0x1e8>
80007750:	50 19       	stdsp	sp[0x4],r9
80007752:	50 28       	stdsp	sp[0x8],r8
80007754:	e0 6a 00 80 	mov	r10,128
80007758:	30 0b       	mov	r11,0
8000775a:	02 9c       	mov	r12,r1
8000775c:	fe b0 fd 01 	rcall	8000715e <memset>
80007760:	40 28       	lddsp	r8,sp[0x8]
80007762:	40 19       	lddsp	r9,sp[0x4]
80007764:	e4 cc 00 01 	sub	r12,r2,1
80007768:	0e 9b       	mov	r11,r7
8000776a:	50 3c       	stdsp	sp[0xc],r12
8000776c:	f2 0c 0c 49 	max	r9,r9,r12
80007770:	c3 a8       	rjmp	800077e4 <get_arg+0x268>
80007772:	62 0a       	ld.w	r10,r1[0x0]
80007774:	5b fa       	cp.w	r10,-1
80007776:	c0 b1       	brne	8000778c <get_arg+0x210>
80007778:	50 19       	stdsp	sp[0x4],r9
8000777a:	50 28       	stdsp	sp[0x8],r8
8000777c:	e0 6a 00 80 	mov	r10,128
80007780:	30 0b       	mov	r11,0
80007782:	02 9c       	mov	r12,r1
80007784:	fe b0 fc ed 	rcall	8000715e <memset>
80007788:	40 28       	lddsp	r8,sp[0x8]
8000778a:	40 19       	lddsp	r9,sp[0x4]
8000778c:	20 12       	sub	r2,1
8000778e:	30 0a       	mov	r10,0
80007790:	0e 9b       	mov	r11,r7
80007792:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007796:	f2 02 0c 49 	max	r9,r9,r2
8000779a:	c2 58       	rjmp	800077e4 <get_arg+0x268>
8000779c:	16 97       	mov	r7,r11
8000779e:	6c 0a       	ld.w	r10,r6[0x0]
800077a0:	f4 cb ff fc 	sub	r11,r10,-4
800077a4:	8d 0b       	st.w	r6[0x0],r11
800077a6:	74 0a       	ld.w	r10,r10[0x0]
800077a8:	0e 9b       	mov	r11,r7
800077aa:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800077ae:	2f f5       	sub	r5,-1
800077b0:	c1 a8       	rjmp	800077e4 <get_arg+0x268>
800077b2:	f4 c2 00 30 	sub	r2,r10,48
800077b6:	c0 68       	rjmp	800077c2 <get_arg+0x246>
800077b8:	e4 02 00 22 	add	r2,r2,r2<<0x2
800077bc:	2f f7       	sub	r7,-1
800077be:	f4 02 00 12 	add	r2,r10,r2<<0x1
800077c2:	0f 8a       	ld.ub	r10,r7[0x0]
800077c4:	58 0a       	cp.w	r10,0
800077c6:	c0 e0       	breq	800077e2 <get_arg+0x266>
800077c8:	23 0a       	sub	r10,48
800077ca:	58 9a       	cp.w	r10,9
800077cc:	fe 98 ff f6 	brls	800077b8 <get_arg+0x23c>
800077d0:	c0 98       	rjmp	800077e2 <get_arg+0x266>
800077d2:	2f f7       	sub	r7,-1
800077d4:	0f 8a       	ld.ub	r10,r7[0x0]
800077d6:	58 0a       	cp.w	r10,0
800077d8:	c0 50       	breq	800077e2 <get_arg+0x266>
800077da:	23 0a       	sub	r10,48
800077dc:	58 9a       	cp.w	r10,9
800077de:	fe 98 ff fa 	brls	800077d2 <get_arg+0x256>
800077e2:	0e 9b       	mov	r11,r7
800077e4:	40 7c       	lddsp	r12,sp[0x1c]
800077e6:	30 ba       	mov	r10,11
800077e8:	f4 0c 18 00 	cp.b	r12,r10
800077ec:	fe 91 fe f2 	brne	800075d0 <get_arg+0x54>
800077f0:	40 42       	lddsp	r2,sp[0x10]
800077f2:	17 8c       	ld.ub	r12,r11[0x0]
800077f4:	0a 32       	cp.w	r2,r5
800077f6:	5f 4a       	srge	r10
800077f8:	f0 0c 18 00 	cp.b	r12,r8
800077fc:	5f 1c       	srne	r12
800077fe:	f9 ea 00 0a 	and	r10,r12,r10
80007802:	f0 0a 18 00 	cp.b	r10,r8
80007806:	fe 91 fe cf 	brne	800075a4 <get_arg+0x28>
8000780a:	30 08       	mov	r8,0
8000780c:	40 4e       	lddsp	lr,sp[0x10]
8000780e:	17 8a       	ld.ub	r10,r11[0x0]
80007810:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007814:	f0 0a 18 00 	cp.b	r10,r8
80007818:	fc 09 17 10 	movne	r9,lr
8000781c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007820:	06 9e       	mov	lr,r3
80007822:	c2 a8       	rjmp	80007876 <get_arg+0x2fa>
80007824:	62 0a       	ld.w	r10,r1[0x0]
80007826:	58 3a       	cp.w	r10,3
80007828:	c1 e0       	breq	80007864 <get_arg+0x2e8>
8000782a:	e0 89 00 07 	brgt	80007838 <get_arg+0x2bc>
8000782e:	58 1a       	cp.w	r10,1
80007830:	c1 a0       	breq	80007864 <get_arg+0x2e8>
80007832:	58 2a       	cp.w	r10,2
80007834:	c1 81       	brne	80007864 <get_arg+0x2e8>
80007836:	c0 58       	rjmp	80007840 <get_arg+0x2c4>
80007838:	58 5a       	cp.w	r10,5
8000783a:	c0 c0       	breq	80007852 <get_arg+0x2d6>
8000783c:	c0 b5       	brlt	80007852 <get_arg+0x2d6>
8000783e:	c1 38       	rjmp	80007864 <get_arg+0x2e8>
80007840:	6c 0a       	ld.w	r10,r6[0x0]
80007842:	f4 cc ff f8 	sub	r12,r10,-8
80007846:	8d 0c       	st.w	r6[0x0],r12
80007848:	f4 e2 00 00 	ld.d	r2,r10[0]
8000784c:	f0 e3 00 00 	st.d	r8[0],r2
80007850:	c1 08       	rjmp	80007870 <get_arg+0x2f4>
80007852:	6c 0a       	ld.w	r10,r6[0x0]
80007854:	f4 cc ff f8 	sub	r12,r10,-8
80007858:	8d 0c       	st.w	r6[0x0],r12
8000785a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000785e:	f0 e3 00 00 	st.d	r8[0],r2
80007862:	c0 78       	rjmp	80007870 <get_arg+0x2f4>
80007864:	6c 0a       	ld.w	r10,r6[0x0]
80007866:	f4 cc ff fc 	sub	r12,r10,-4
8000786a:	8d 0c       	st.w	r6[0x0],r12
8000786c:	74 0a       	ld.w	r10,r10[0x0]
8000786e:	91 0a       	st.w	r8[0x0],r10
80007870:	2f f5       	sub	r5,-1
80007872:	2f 88       	sub	r8,-8
80007874:	2f c1       	sub	r1,-4
80007876:	12 35       	cp.w	r5,r9
80007878:	fe 9a ff d6 	brle	80007824 <get_arg+0x2a8>
8000787c:	1c 93       	mov	r3,lr
8000787e:	40 52       	lddsp	r2,sp[0x14]
80007880:	40 6e       	lddsp	lr,sp[0x18]
80007882:	85 05       	st.w	r2[0x0],r5
80007884:	9d 0b       	st.w	lr[0x0],r11
80007886:	40 4b       	lddsp	r11,sp[0x10]
80007888:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000788c:	2f 8d       	sub	sp,-32
8000788e:	d8 32       	popm	r0-r7,pc

80007890 <__sprint_r>:
80007890:	d4 21       	pushm	r4-r7,lr
80007892:	14 97       	mov	r7,r10
80007894:	74 28       	ld.w	r8,r10[0x8]
80007896:	58 08       	cp.w	r8,0
80007898:	c0 41       	brne	800078a0 <__sprint_r+0x10>
8000789a:	95 18       	st.w	r10[0x4],r8
8000789c:	10 9c       	mov	r12,r8
8000789e:	d8 22       	popm	r4-r7,pc
800078a0:	e0 a0 18 ba 	rcall	8000aa14 <__sfvwrite_r>
800078a4:	30 08       	mov	r8,0
800078a6:	8f 18       	st.w	r7[0x4],r8
800078a8:	8f 28       	st.w	r7[0x8],r8
800078aa:	d8 22       	popm	r4-r7,pc

800078ac <_vfprintf_r>:
800078ac:	d4 31       	pushm	r0-r7,lr
800078ae:	fa cd 06 bc 	sub	sp,sp,1724
800078b2:	51 09       	stdsp	sp[0x40],r9
800078b4:	16 91       	mov	r1,r11
800078b6:	14 97       	mov	r7,r10
800078b8:	18 95       	mov	r5,r12
800078ba:	e0 a0 1a 1d 	rcall	8000acf4 <_localeconv_r>
800078be:	78 0c       	ld.w	r12,r12[0x0]
800078c0:	50 cc       	stdsp	sp[0x30],r12
800078c2:	58 05       	cp.w	r5,0
800078c4:	c0 70       	breq	800078d2 <_vfprintf_r+0x26>
800078c6:	6a 68       	ld.w	r8,r5[0x18]
800078c8:	58 08       	cp.w	r8,0
800078ca:	c0 41       	brne	800078d2 <_vfprintf_r+0x26>
800078cc:	0a 9c       	mov	r12,r5
800078ce:	e0 a0 17 43 	rcall	8000a754 <__sinit>
800078d2:	fe c8 a1 16 	sub	r8,pc,-24298
800078d6:	10 31       	cp.w	r1,r8
800078d8:	c0 31       	brne	800078de <_vfprintf_r+0x32>
800078da:	6a 01       	ld.w	r1,r5[0x0]
800078dc:	c0 c8       	rjmp	800078f4 <_vfprintf_r+0x48>
800078de:	fe c8 a1 02 	sub	r8,pc,-24318
800078e2:	10 31       	cp.w	r1,r8
800078e4:	c0 31       	brne	800078ea <_vfprintf_r+0x3e>
800078e6:	6a 11       	ld.w	r1,r5[0x4]
800078e8:	c0 68       	rjmp	800078f4 <_vfprintf_r+0x48>
800078ea:	fe c8 a0 ee 	sub	r8,pc,-24338
800078ee:	10 31       	cp.w	r1,r8
800078f0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800078f4:	82 68       	ld.sh	r8,r1[0xc]
800078f6:	ed b8 00 03 	bld	r8,0x3
800078fa:	c0 41       	brne	80007902 <_vfprintf_r+0x56>
800078fc:	62 48       	ld.w	r8,r1[0x10]
800078fe:	58 08       	cp.w	r8,0
80007900:	c0 71       	brne	8000790e <_vfprintf_r+0x62>
80007902:	02 9b       	mov	r11,r1
80007904:	0a 9c       	mov	r12,r5
80007906:	e0 a0 0f 5d 	rcall	800097c0 <__swsetup_r>
8000790a:	e0 81 0f 54 	brne	800097b2 <_vfprintf_r+0x1f06>
8000790e:	82 68       	ld.sh	r8,r1[0xc]
80007910:	10 99       	mov	r9,r8
80007912:	e2 19 00 1a 	andl	r9,0x1a,COH
80007916:	58 a9       	cp.w	r9,10
80007918:	c3 c1       	brne	80007990 <_vfprintf_r+0xe4>
8000791a:	82 79       	ld.sh	r9,r1[0xe]
8000791c:	30 0a       	mov	r10,0
8000791e:	f4 09 19 00 	cp.h	r9,r10
80007922:	c3 75       	brlt	80007990 <_vfprintf_r+0xe4>
80007924:	a1 d8       	cbr	r8,0x1
80007926:	fb 58 05 d0 	st.h	sp[1488],r8
8000792a:	62 88       	ld.w	r8,r1[0x20]
8000792c:	fb 48 05 e4 	st.w	sp[1508],r8
80007930:	62 a8       	ld.w	r8,r1[0x28]
80007932:	fb 48 05 ec 	st.w	sp[1516],r8
80007936:	fa c8 ff bc 	sub	r8,sp,-68
8000793a:	fb 48 05 d4 	st.w	sp[1492],r8
8000793e:	fb 48 05 c4 	st.w	sp[1476],r8
80007942:	e0 68 04 00 	mov	r8,1024
80007946:	fb 48 05 d8 	st.w	sp[1496],r8
8000794a:	fb 48 05 cc 	st.w	sp[1484],r8
8000794e:	30 08       	mov	r8,0
80007950:	fb 59 05 d2 	st.h	sp[1490],r9
80007954:	0e 9a       	mov	r10,r7
80007956:	41 09       	lddsp	r9,sp[0x40]
80007958:	fa c7 fa 3c 	sub	r7,sp,-1476
8000795c:	fb 48 05 dc 	st.w	sp[1500],r8
80007960:	0a 9c       	mov	r12,r5
80007962:	0e 9b       	mov	r11,r7
80007964:	ca 4f       	rcall	800078ac <_vfprintf_r>
80007966:	50 bc       	stdsp	sp[0x2c],r12
80007968:	c0 95       	brlt	8000797a <_vfprintf_r+0xce>
8000796a:	0e 9b       	mov	r11,r7
8000796c:	0a 9c       	mov	r12,r5
8000796e:	e0 a0 16 1b 	rcall	8000a5a4 <_fflush_r>
80007972:	40 be       	lddsp	lr,sp[0x2c]
80007974:	f9 be 01 ff 	movne	lr,-1
80007978:	50 be       	stdsp	sp[0x2c],lr
8000797a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000797e:	ed b8 00 06 	bld	r8,0x6
80007982:	e0 81 0f 1a 	brne	800097b6 <_vfprintf_r+0x1f0a>
80007986:	82 68       	ld.sh	r8,r1[0xc]
80007988:	a7 a8       	sbr	r8,0x6
8000798a:	a2 68       	st.h	r1[0xc],r8
8000798c:	e0 8f 0f 15 	bral	800097b6 <_vfprintf_r+0x1f0a>
80007990:	30 08       	mov	r8,0
80007992:	fb 48 06 b4 	st.w	sp[1716],r8
80007996:	fb 48 06 90 	st.w	sp[1680],r8
8000799a:	fb 48 06 8c 	st.w	sp[1676],r8
8000799e:	fb 48 06 b0 	st.w	sp[1712],r8
800079a2:	30 08       	mov	r8,0
800079a4:	30 09       	mov	r9,0
800079a6:	50 a7       	stdsp	sp[0x28],r7
800079a8:	50 78       	stdsp	sp[0x1c],r8
800079aa:	fa c3 f9 e0 	sub	r3,sp,-1568
800079ae:	3f f8       	mov	r8,-1
800079b0:	50 59       	stdsp	sp[0x14],r9
800079b2:	fb 43 06 88 	st.w	sp[1672],r3
800079b6:	fb 48 05 44 	st.w	sp[1348],r8
800079ba:	12 9c       	mov	r12,r9
800079bc:	50 69       	stdsp	sp[0x18],r9
800079be:	50 d9       	stdsp	sp[0x34],r9
800079c0:	50 e9       	stdsp	sp[0x38],r9
800079c2:	50 b9       	stdsp	sp[0x2c],r9
800079c4:	12 97       	mov	r7,r9
800079c6:	0a 94       	mov	r4,r5
800079c8:	40 a2       	lddsp	r2,sp[0x28]
800079ca:	32 5a       	mov	r10,37
800079cc:	30 08       	mov	r8,0
800079ce:	c0 28       	rjmp	800079d2 <_vfprintf_r+0x126>
800079d0:	2f f2       	sub	r2,-1
800079d2:	05 89       	ld.ub	r9,r2[0x0]
800079d4:	f0 09 18 00 	cp.b	r9,r8
800079d8:	5f 1b       	srne	r11
800079da:	f4 09 18 00 	cp.b	r9,r10
800079de:	5f 19       	srne	r9
800079e0:	f3 eb 00 0b 	and	r11,r9,r11
800079e4:	f0 0b 18 00 	cp.b	r11,r8
800079e8:	cf 41       	brne	800079d0 <_vfprintf_r+0x124>
800079ea:	40 ab       	lddsp	r11,sp[0x28]
800079ec:	e4 0b 01 06 	sub	r6,r2,r11
800079f0:	c1 e0       	breq	80007a2c <_vfprintf_r+0x180>
800079f2:	fa f8 06 90 	ld.w	r8,sp[1680]
800079f6:	0c 08       	add	r8,r6
800079f8:	87 0b       	st.w	r3[0x0],r11
800079fa:	fb 48 06 90 	st.w	sp[1680],r8
800079fe:	87 16       	st.w	r3[0x4],r6
80007a00:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007a04:	2f f8       	sub	r8,-1
80007a06:	fb 48 06 8c 	st.w	sp[1676],r8
80007a0a:	58 78       	cp.w	r8,7
80007a0c:	e0 89 00 04 	brgt	80007a14 <_vfprintf_r+0x168>
80007a10:	2f 83       	sub	r3,-8
80007a12:	c0 a8       	rjmp	80007a26 <_vfprintf_r+0x17a>
80007a14:	fa ca f9 78 	sub	r10,sp,-1672
80007a18:	02 9b       	mov	r11,r1
80007a1a:	08 9c       	mov	r12,r4
80007a1c:	c3 af       	rcall	80007890 <__sprint_r>
80007a1e:	e0 81 0e c6 	brne	800097aa <_vfprintf_r+0x1efe>
80007a22:	fa c3 f9 e0 	sub	r3,sp,-1568
80007a26:	40 ba       	lddsp	r10,sp[0x2c]
80007a28:	0c 0a       	add	r10,r6
80007a2a:	50 ba       	stdsp	sp[0x2c],r10
80007a2c:	05 89       	ld.ub	r9,r2[0x0]
80007a2e:	30 08       	mov	r8,0
80007a30:	f0 09 18 00 	cp.b	r9,r8
80007a34:	e0 80 0e aa 	breq	80009788 <_vfprintf_r+0x1edc>
80007a38:	30 09       	mov	r9,0
80007a3a:	fb 68 06 bb 	st.b	sp[1723],r8
80007a3e:	0e 96       	mov	r6,r7
80007a40:	e4 c8 ff ff 	sub	r8,r2,-1
80007a44:	3f fe       	mov	lr,-1
80007a46:	50 93       	stdsp	sp[0x24],r3
80007a48:	50 41       	stdsp	sp[0x10],r1
80007a4a:	0e 93       	mov	r3,r7
80007a4c:	04 91       	mov	r1,r2
80007a4e:	50 89       	stdsp	sp[0x20],r9
80007a50:	50 a8       	stdsp	sp[0x28],r8
80007a52:	50 2e       	stdsp	sp[0x8],lr
80007a54:	50 39       	stdsp	sp[0xc],r9
80007a56:	12 95       	mov	r5,r9
80007a58:	12 90       	mov	r0,r9
80007a5a:	10 97       	mov	r7,r8
80007a5c:	08 92       	mov	r2,r4
80007a5e:	c0 78       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007a60:	3f fc       	mov	r12,-1
80007a62:	08 97       	mov	r7,r4
80007a64:	50 2c       	stdsp	sp[0x8],r12
80007a66:	c0 38       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007a68:	30 0b       	mov	r11,0
80007a6a:	50 3b       	stdsp	sp[0xc],r11
80007a6c:	0f 38       	ld.ub	r8,r7++
80007a6e:	c0 28       	rjmp	80007a72 <_vfprintf_r+0x1c6>
80007a70:	12 90       	mov	r0,r9
80007a72:	f0 c9 00 20 	sub	r9,r8,32
80007a76:	e0 49 00 58 	cp.w	r9,88
80007a7a:	e0 8b 0a 30 	brhi	80008eda <_vfprintf_r+0x162e>
80007a7e:	fe ca a6 6a 	sub	r10,pc,-22934
80007a82:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007a86:	50 a7       	stdsp	sp[0x28],r7
80007a88:	50 80       	stdsp	sp[0x20],r0
80007a8a:	0c 97       	mov	r7,r6
80007a8c:	04 94       	mov	r4,r2
80007a8e:	06 96       	mov	r6,r3
80007a90:	02 92       	mov	r2,r1
80007a92:	fe c9 a4 42 	sub	r9,pc,-23486
80007a96:	40 93       	lddsp	r3,sp[0x24]
80007a98:	10 90       	mov	r0,r8
80007a9a:	40 41       	lddsp	r1,sp[0x10]
80007a9c:	50 d9       	stdsp	sp[0x34],r9
80007a9e:	e0 8f 08 8e 	bral	80008bba <_vfprintf_r+0x130e>
80007aa2:	30 08       	mov	r8,0
80007aa4:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007aa8:	f0 09 18 00 	cp.b	r9,r8
80007aac:	ce 01       	brne	80007a6c <_vfprintf_r+0x1c0>
80007aae:	32 08       	mov	r8,32
80007ab0:	c6 e8       	rjmp	80007b8c <_vfprintf_r+0x2e0>
80007ab2:	a1 a5       	sbr	r5,0x0
80007ab4:	cd cb       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007ab6:	0f 89       	ld.ub	r9,r7[0x0]
80007ab8:	f2 c8 00 30 	sub	r8,r9,48
80007abc:	58 98       	cp.w	r8,9
80007abe:	e0 8b 00 1d 	brhi	80007af8 <_vfprintf_r+0x24c>
80007ac2:	ee c8 ff ff 	sub	r8,r7,-1
80007ac6:	30 0b       	mov	r11,0
80007ac8:	23 09       	sub	r9,48
80007aca:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007ace:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007ad2:	11 39       	ld.ub	r9,r8++
80007ad4:	f2 ca 00 30 	sub	r10,r9,48
80007ad8:	58 9a       	cp.w	r10,9
80007ada:	fe 98 ff f7 	brls	80007ac8 <_vfprintf_r+0x21c>
80007ade:	e0 49 00 24 	cp.w	r9,36
80007ae2:	cc 31       	brne	80007a68 <_vfprintf_r+0x1bc>
80007ae4:	e0 4b 00 20 	cp.w	r11,32
80007ae8:	e0 89 0e 60 	brgt	800097a8 <_vfprintf_r+0x1efc>
80007aec:	20 1b       	sub	r11,1
80007aee:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007af2:	12 3b       	cp.w	r11,r9
80007af4:	c0 95       	brlt	80007b06 <_vfprintf_r+0x25a>
80007af6:	c1 08       	rjmp	80007b16 <_vfprintf_r+0x26a>
80007af8:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007afc:	ec ca ff ff 	sub	r10,r6,-1
80007b00:	12 36       	cp.w	r6,r9
80007b02:	c1 f5       	brlt	80007b40 <_vfprintf_r+0x294>
80007b04:	c2 68       	rjmp	80007b50 <_vfprintf_r+0x2a4>
80007b06:	fa ce f9 44 	sub	lr,sp,-1724
80007b0a:	10 97       	mov	r7,r8
80007b0c:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007b10:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007b14:	c3 58       	rjmp	80007b7e <_vfprintf_r+0x2d2>
80007b16:	10 97       	mov	r7,r8
80007b18:	fa c8 f9 50 	sub	r8,sp,-1712
80007b1c:	1a d8       	st.w	--sp,r8
80007b1e:	fa c8 fa b8 	sub	r8,sp,-1352
80007b22:	1a d8       	st.w	--sp,r8
80007b24:	fa c8 fb b4 	sub	r8,sp,-1100
80007b28:	02 9a       	mov	r10,r1
80007b2a:	1a d8       	st.w	--sp,r8
80007b2c:	04 9c       	mov	r12,r2
80007b2e:	fa c8 f9 40 	sub	r8,sp,-1728
80007b32:	fa c9 ff b4 	sub	r9,sp,-76
80007b36:	fe b0 fd 23 	rcall	8000757c <get_arg>
80007b3a:	2f dd       	sub	sp,-12
80007b3c:	78 00       	ld.w	r0,r12[0x0]
80007b3e:	c2 08       	rjmp	80007b7e <_vfprintf_r+0x2d2>
80007b40:	fa cc f9 44 	sub	r12,sp,-1724
80007b44:	14 96       	mov	r6,r10
80007b46:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007b4a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007b4e:	c1 88       	rjmp	80007b7e <_vfprintf_r+0x2d2>
80007b50:	41 08       	lddsp	r8,sp[0x40]
80007b52:	59 f9       	cp.w	r9,31
80007b54:	e0 89 00 11 	brgt	80007b76 <_vfprintf_r+0x2ca>
80007b58:	f0 cb ff fc 	sub	r11,r8,-4
80007b5c:	51 0b       	stdsp	sp[0x40],r11
80007b5e:	70 00       	ld.w	r0,r8[0x0]
80007b60:	fa cb f9 44 	sub	r11,sp,-1724
80007b64:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007b68:	f1 40 fd 88 	st.w	r8[-632],r0
80007b6c:	2f f9       	sub	r9,-1
80007b6e:	14 96       	mov	r6,r10
80007b70:	fb 49 06 b4 	st.w	sp[1716],r9
80007b74:	c0 58       	rjmp	80007b7e <_vfprintf_r+0x2d2>
80007b76:	70 00       	ld.w	r0,r8[0x0]
80007b78:	14 96       	mov	r6,r10
80007b7a:	2f c8       	sub	r8,-4
80007b7c:	51 08       	stdsp	sp[0x40],r8
80007b7e:	58 00       	cp.w	r0,0
80007b80:	fe 94 ff 76 	brge	80007a6c <_vfprintf_r+0x1c0>
80007b84:	5c 30       	neg	r0
80007b86:	a3 a5       	sbr	r5,0x2
80007b88:	c7 2b       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007b8a:	32 b8       	mov	r8,43
80007b8c:	fb 68 06 bb 	st.b	sp[1723],r8
80007b90:	c6 eb       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007b92:	0f 38       	ld.ub	r8,r7++
80007b94:	e0 48 00 2a 	cp.w	r8,42
80007b98:	c0 30       	breq	80007b9e <_vfprintf_r+0x2f2>
80007b9a:	30 09       	mov	r9,0
80007b9c:	c7 98       	rjmp	80007c8e <_vfprintf_r+0x3e2>
80007b9e:	0f 88       	ld.ub	r8,r7[0x0]
80007ba0:	f0 c9 00 30 	sub	r9,r8,48
80007ba4:	58 99       	cp.w	r9,9
80007ba6:	e0 8b 00 1f 	brhi	80007be4 <_vfprintf_r+0x338>
80007baa:	ee c4 ff ff 	sub	r4,r7,-1
80007bae:	30 0b       	mov	r11,0
80007bb0:	23 08       	sub	r8,48
80007bb2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007bb6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007bba:	09 38       	ld.ub	r8,r4++
80007bbc:	f0 c9 00 30 	sub	r9,r8,48
80007bc0:	58 99       	cp.w	r9,9
80007bc2:	fe 98 ff f7 	brls	80007bb0 <_vfprintf_r+0x304>
80007bc6:	e0 48 00 24 	cp.w	r8,36
80007bca:	fe 91 ff 4f 	brne	80007a68 <_vfprintf_r+0x1bc>
80007bce:	e0 4b 00 20 	cp.w	r11,32
80007bd2:	e0 89 0d eb 	brgt	800097a8 <_vfprintf_r+0x1efc>
80007bd6:	20 1b       	sub	r11,1
80007bd8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bdc:	10 3b       	cp.w	r11,r8
80007bde:	c0 a5       	brlt	80007bf2 <_vfprintf_r+0x346>
80007be0:	c1 18       	rjmp	80007c02 <_vfprintf_r+0x356>
80007be2:	d7 03       	nop
80007be4:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007be8:	ec c9 ff ff 	sub	r9,r6,-1
80007bec:	14 36       	cp.w	r6,r10
80007bee:	c1 f5       	brlt	80007c2c <_vfprintf_r+0x380>
80007bf0:	c2 88       	rjmp	80007c40 <_vfprintf_r+0x394>
80007bf2:	fa ca f9 44 	sub	r10,sp,-1724
80007bf6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007bfa:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007bfe:	50 2b       	stdsp	sp[0x8],r11
80007c00:	c3 c8       	rjmp	80007c78 <_vfprintf_r+0x3cc>
80007c02:	fa c8 f9 50 	sub	r8,sp,-1712
80007c06:	1a d8       	st.w	--sp,r8
80007c08:	fa c8 fa b8 	sub	r8,sp,-1352
80007c0c:	1a d8       	st.w	--sp,r8
80007c0e:	fa c8 fb b4 	sub	r8,sp,-1100
80007c12:	02 9a       	mov	r10,r1
80007c14:	1a d8       	st.w	--sp,r8
80007c16:	04 9c       	mov	r12,r2
80007c18:	fa c8 f9 40 	sub	r8,sp,-1728
80007c1c:	fa c9 ff b4 	sub	r9,sp,-76
80007c20:	fe b0 fc ae 	rcall	8000757c <get_arg>
80007c24:	2f dd       	sub	sp,-12
80007c26:	78 0c       	ld.w	r12,r12[0x0]
80007c28:	50 2c       	stdsp	sp[0x8],r12
80007c2a:	c2 78       	rjmp	80007c78 <_vfprintf_r+0x3cc>
80007c2c:	12 96       	mov	r6,r9
80007c2e:	0e 94       	mov	r4,r7
80007c30:	fa c9 f9 44 	sub	r9,sp,-1724
80007c34:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007c38:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007c3c:	50 28       	stdsp	sp[0x8],r8
80007c3e:	c1 d8       	rjmp	80007c78 <_vfprintf_r+0x3cc>
80007c40:	41 08       	lddsp	r8,sp[0x40]
80007c42:	59 fa       	cp.w	r10,31
80007c44:	e0 89 00 14 	brgt	80007c6c <_vfprintf_r+0x3c0>
80007c48:	f0 cb ff fc 	sub	r11,r8,-4
80007c4c:	70 08       	ld.w	r8,r8[0x0]
80007c4e:	51 0b       	stdsp	sp[0x40],r11
80007c50:	50 28       	stdsp	sp[0x8],r8
80007c52:	fa c6 f9 44 	sub	r6,sp,-1724
80007c56:	40 2e       	lddsp	lr,sp[0x8]
80007c58:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007c5c:	f1 4e fd 88 	st.w	r8[-632],lr
80007c60:	2f fa       	sub	r10,-1
80007c62:	0e 94       	mov	r4,r7
80007c64:	fb 4a 06 b4 	st.w	sp[1716],r10
80007c68:	12 96       	mov	r6,r9
80007c6a:	c0 78       	rjmp	80007c78 <_vfprintf_r+0x3cc>
80007c6c:	70 0c       	ld.w	r12,r8[0x0]
80007c6e:	0e 94       	mov	r4,r7
80007c70:	2f c8       	sub	r8,-4
80007c72:	50 2c       	stdsp	sp[0x8],r12
80007c74:	12 96       	mov	r6,r9
80007c76:	51 08       	stdsp	sp[0x40],r8
80007c78:	40 2b       	lddsp	r11,sp[0x8]
80007c7a:	58 0b       	cp.w	r11,0
80007c7c:	fe 95 fe f2 	brlt	80007a60 <_vfprintf_r+0x1b4>
80007c80:	08 97       	mov	r7,r4
80007c82:	cf 5a       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007c84:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007c88:	0f 38       	ld.ub	r8,r7++
80007c8a:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007c8e:	f0 ca 00 30 	sub	r10,r8,48
80007c92:	58 9a       	cp.w	r10,9
80007c94:	fe 98 ff f8 	brls	80007c84 <_vfprintf_r+0x3d8>
80007c98:	3f fa       	mov	r10,-1
80007c9a:	f2 0a 0c 49 	max	r9,r9,r10
80007c9e:	50 29       	stdsp	sp[0x8],r9
80007ca0:	ce 9a       	rjmp	80007a72 <_vfprintf_r+0x1c6>
80007ca2:	a7 b5       	sbr	r5,0x7
80007ca4:	ce 4a       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007ca6:	30 09       	mov	r9,0
80007ca8:	23 08       	sub	r8,48
80007caa:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007cae:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007cb2:	0f 38       	ld.ub	r8,r7++
80007cb4:	f0 ca 00 30 	sub	r10,r8,48
80007cb8:	58 9a       	cp.w	r10,9
80007cba:	fe 98 ff f7 	brls	80007ca8 <_vfprintf_r+0x3fc>
80007cbe:	e0 48 00 24 	cp.w	r8,36
80007cc2:	fe 91 fe d7 	brne	80007a70 <_vfprintf_r+0x1c4>
80007cc6:	e0 49 00 20 	cp.w	r9,32
80007cca:	e0 89 0d 6f 	brgt	800097a8 <_vfprintf_r+0x1efc>
80007cce:	f2 c3 00 01 	sub	r3,r9,1
80007cd2:	30 19       	mov	r9,1
80007cd4:	50 39       	stdsp	sp[0xc],r9
80007cd6:	cc ba       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007cd8:	a3 b5       	sbr	r5,0x3
80007cda:	cc 9a       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007cdc:	a7 a5       	sbr	r5,0x6
80007cde:	cc 7a       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007ce0:	0a 98       	mov	r8,r5
80007ce2:	a5 b5       	sbr	r5,0x5
80007ce4:	a5 a8       	sbr	r8,0x4
80007ce6:	0f 89       	ld.ub	r9,r7[0x0]
80007ce8:	36 ce       	mov	lr,108
80007cea:	fc 09 18 00 	cp.b	r9,lr
80007cee:	f7 b7 00 ff 	subeq	r7,-1
80007cf2:	f0 05 17 10 	movne	r5,r8
80007cf6:	cb ba       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007cf8:	a5 b5       	sbr	r5,0x5
80007cfa:	cb 9a       	rjmp	80007a6c <_vfprintf_r+0x1c0>
80007cfc:	50 a7       	stdsp	sp[0x28],r7
80007cfe:	50 80       	stdsp	sp[0x20],r0
80007d00:	0c 97       	mov	r7,r6
80007d02:	10 90       	mov	r0,r8
80007d04:	06 96       	mov	r6,r3
80007d06:	04 94       	mov	r4,r2
80007d08:	40 93       	lddsp	r3,sp[0x24]
80007d0a:	02 92       	mov	r2,r1
80007d0c:	0e 99       	mov	r9,r7
80007d0e:	40 41       	lddsp	r1,sp[0x10]
80007d10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d14:	40 3c       	lddsp	r12,sp[0xc]
80007d16:	58 0c       	cp.w	r12,0
80007d18:	c1 d0       	breq	80007d52 <_vfprintf_r+0x4a6>
80007d1a:	10 36       	cp.w	r6,r8
80007d1c:	c0 64       	brge	80007d28 <_vfprintf_r+0x47c>
80007d1e:	fa cb f9 44 	sub	r11,sp,-1724
80007d22:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d26:	c1 d8       	rjmp	80007d60 <_vfprintf_r+0x4b4>
80007d28:	fa c8 f9 50 	sub	r8,sp,-1712
80007d2c:	1a d8       	st.w	--sp,r8
80007d2e:	fa c8 fa b8 	sub	r8,sp,-1352
80007d32:	1a d8       	st.w	--sp,r8
80007d34:	fa c8 fb b4 	sub	r8,sp,-1100
80007d38:	1a d8       	st.w	--sp,r8
80007d3a:	fa c8 f9 40 	sub	r8,sp,-1728
80007d3e:	fa c9 ff b4 	sub	r9,sp,-76
80007d42:	04 9a       	mov	r10,r2
80007d44:	0c 9b       	mov	r11,r6
80007d46:	08 9c       	mov	r12,r4
80007d48:	fe b0 fc 1a 	rcall	8000757c <get_arg>
80007d4c:	2f dd       	sub	sp,-12
80007d4e:	19 b8       	ld.ub	r8,r12[0x3]
80007d50:	c2 28       	rjmp	80007d94 <_vfprintf_r+0x4e8>
80007d52:	2f f7       	sub	r7,-1
80007d54:	10 39       	cp.w	r9,r8
80007d56:	c0 84       	brge	80007d66 <_vfprintf_r+0x4ba>
80007d58:	fa ca f9 44 	sub	r10,sp,-1724
80007d5c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007d60:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007d64:	c1 88       	rjmp	80007d94 <_vfprintf_r+0x4e8>
80007d66:	41 09       	lddsp	r9,sp[0x40]
80007d68:	59 f8       	cp.w	r8,31
80007d6a:	e0 89 00 12 	brgt	80007d8e <_vfprintf_r+0x4e2>
80007d6e:	f2 ca ff fc 	sub	r10,r9,-4
80007d72:	51 0a       	stdsp	sp[0x40],r10
80007d74:	72 09       	ld.w	r9,r9[0x0]
80007d76:	fa c6 f9 44 	sub	r6,sp,-1724
80007d7a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007d7e:	2f f8       	sub	r8,-1
80007d80:	f5 49 fd 88 	st.w	r10[-632],r9
80007d84:	fb 48 06 b4 	st.w	sp[1716],r8
80007d88:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007d8c:	c0 48       	rjmp	80007d94 <_vfprintf_r+0x4e8>
80007d8e:	13 b8       	ld.ub	r8,r9[0x3]
80007d90:	2f c9       	sub	r9,-4
80007d92:	51 09       	stdsp	sp[0x40],r9
80007d94:	fb 68 06 60 	st.b	sp[1632],r8
80007d98:	30 0e       	mov	lr,0
80007d9a:	30 08       	mov	r8,0
80007d9c:	30 12       	mov	r2,1
80007d9e:	fb 68 06 bb 	st.b	sp[1723],r8
80007da2:	50 2e       	stdsp	sp[0x8],lr
80007da4:	e0 8f 08 ad 	bral	80008efe <_vfprintf_r+0x1652>
80007da8:	50 a7       	stdsp	sp[0x28],r7
80007daa:	50 80       	stdsp	sp[0x20],r0
80007dac:	0c 97       	mov	r7,r6
80007dae:	04 94       	mov	r4,r2
80007db0:	06 96       	mov	r6,r3
80007db2:	02 92       	mov	r2,r1
80007db4:	40 93       	lddsp	r3,sp[0x24]
80007db6:	10 90       	mov	r0,r8
80007db8:	40 41       	lddsp	r1,sp[0x10]
80007dba:	a5 a5       	sbr	r5,0x4
80007dbc:	c0 a8       	rjmp	80007dd0 <_vfprintf_r+0x524>
80007dbe:	50 a7       	stdsp	sp[0x28],r7
80007dc0:	50 80       	stdsp	sp[0x20],r0
80007dc2:	0c 97       	mov	r7,r6
80007dc4:	04 94       	mov	r4,r2
80007dc6:	06 96       	mov	r6,r3
80007dc8:	02 92       	mov	r2,r1
80007dca:	40 93       	lddsp	r3,sp[0x24]
80007dcc:	10 90       	mov	r0,r8
80007dce:	40 41       	lddsp	r1,sp[0x10]
80007dd0:	ed b5 00 05 	bld	r5,0x5
80007dd4:	c5 11       	brne	80007e76 <_vfprintf_r+0x5ca>
80007dd6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dda:	40 3c       	lddsp	r12,sp[0xc]
80007ddc:	58 0c       	cp.w	r12,0
80007dde:	c1 e0       	breq	80007e1a <_vfprintf_r+0x56e>
80007de0:	10 36       	cp.w	r6,r8
80007de2:	c0 64       	brge	80007dee <_vfprintf_r+0x542>
80007de4:	fa cb f9 44 	sub	r11,sp,-1724
80007de8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007dec:	c2 08       	rjmp	80007e2c <_vfprintf_r+0x580>
80007dee:	fa c8 f9 50 	sub	r8,sp,-1712
80007df2:	1a d8       	st.w	--sp,r8
80007df4:	fa c8 fa b8 	sub	r8,sp,-1352
80007df8:	0c 9b       	mov	r11,r6
80007dfa:	1a d8       	st.w	--sp,r8
80007dfc:	fa c8 fb b4 	sub	r8,sp,-1100
80007e00:	1a d8       	st.w	--sp,r8
80007e02:	fa c9 ff b4 	sub	r9,sp,-76
80007e06:	fa c8 f9 40 	sub	r8,sp,-1728
80007e0a:	04 9a       	mov	r10,r2
80007e0c:	08 9c       	mov	r12,r4
80007e0e:	fe b0 fb b7 	rcall	8000757c <get_arg>
80007e12:	2f dd       	sub	sp,-12
80007e14:	78 1b       	ld.w	r11,r12[0x4]
80007e16:	78 09       	ld.w	r9,r12[0x0]
80007e18:	c2 b8       	rjmp	80007e6e <_vfprintf_r+0x5c2>
80007e1a:	ee ca ff ff 	sub	r10,r7,-1
80007e1e:	10 37       	cp.w	r7,r8
80007e20:	c0 b4       	brge	80007e36 <_vfprintf_r+0x58a>
80007e22:	fa c9 f9 44 	sub	r9,sp,-1724
80007e26:	14 97       	mov	r7,r10
80007e28:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e2c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007e30:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007e34:	c1 d8       	rjmp	80007e6e <_vfprintf_r+0x5c2>
80007e36:	41 09       	lddsp	r9,sp[0x40]
80007e38:	59 f8       	cp.w	r8,31
80007e3a:	e0 89 00 14 	brgt	80007e62 <_vfprintf_r+0x5b6>
80007e3e:	f2 cb ff f8 	sub	r11,r9,-8
80007e42:	51 0b       	stdsp	sp[0x40],r11
80007e44:	fa c6 f9 44 	sub	r6,sp,-1724
80007e48:	72 1b       	ld.w	r11,r9[0x4]
80007e4a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007e4e:	72 09       	ld.w	r9,r9[0x0]
80007e50:	f9 4b fd 8c 	st.w	r12[-628],r11
80007e54:	f9 49 fd 88 	st.w	r12[-632],r9
80007e58:	2f f8       	sub	r8,-1
80007e5a:	14 97       	mov	r7,r10
80007e5c:	fb 48 06 b4 	st.w	sp[1716],r8
80007e60:	c0 78       	rjmp	80007e6e <_vfprintf_r+0x5c2>
80007e62:	f2 c8 ff f8 	sub	r8,r9,-8
80007e66:	72 1b       	ld.w	r11,r9[0x4]
80007e68:	14 97       	mov	r7,r10
80007e6a:	51 08       	stdsp	sp[0x40],r8
80007e6c:	72 09       	ld.w	r9,r9[0x0]
80007e6e:	16 98       	mov	r8,r11
80007e70:	fa e9 00 00 	st.d	sp[0],r8
80007e74:	ca e8       	rjmp	80007fd0 <_vfprintf_r+0x724>
80007e76:	ed b5 00 04 	bld	r5,0x4
80007e7a:	c1 71       	brne	80007ea8 <_vfprintf_r+0x5fc>
80007e7c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e80:	40 3e       	lddsp	lr,sp[0xc]
80007e82:	58 0e       	cp.w	lr,0
80007e84:	c0 80       	breq	80007e94 <_vfprintf_r+0x5e8>
80007e86:	10 36       	cp.w	r6,r8
80007e88:	c6 94       	brge	80007f5a <_vfprintf_r+0x6ae>
80007e8a:	fa cc f9 44 	sub	r12,sp,-1724
80007e8e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007e92:	c8 28       	rjmp	80007f96 <_vfprintf_r+0x6ea>
80007e94:	ee ca ff ff 	sub	r10,r7,-1
80007e98:	10 37       	cp.w	r7,r8
80007e9a:	e0 84 00 81 	brge	80007f9c <_vfprintf_r+0x6f0>
80007e9e:	fa cb f9 44 	sub	r11,sp,-1724
80007ea2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ea6:	c7 78       	rjmp	80007f94 <_vfprintf_r+0x6e8>
80007ea8:	ed b5 00 06 	bld	r5,0x6
80007eac:	c4 b1       	brne	80007f42 <_vfprintf_r+0x696>
80007eae:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007eb2:	40 3c       	lddsp	r12,sp[0xc]
80007eb4:	58 0c       	cp.w	r12,0
80007eb6:	c1 d0       	breq	80007ef0 <_vfprintf_r+0x644>
80007eb8:	10 36       	cp.w	r6,r8
80007eba:	c0 64       	brge	80007ec6 <_vfprintf_r+0x61a>
80007ebc:	fa cb f9 44 	sub	r11,sp,-1724
80007ec0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ec4:	c1 f8       	rjmp	80007f02 <_vfprintf_r+0x656>
80007ec6:	fa c8 f9 50 	sub	r8,sp,-1712
80007eca:	1a d8       	st.w	--sp,r8
80007ecc:	fa c8 fa b8 	sub	r8,sp,-1352
80007ed0:	1a d8       	st.w	--sp,r8
80007ed2:	fa c8 fb b4 	sub	r8,sp,-1100
80007ed6:	1a d8       	st.w	--sp,r8
80007ed8:	fa c8 f9 40 	sub	r8,sp,-1728
80007edc:	fa c9 ff b4 	sub	r9,sp,-76
80007ee0:	04 9a       	mov	r10,r2
80007ee2:	0c 9b       	mov	r11,r6
80007ee4:	08 9c       	mov	r12,r4
80007ee6:	fe b0 fb 4b 	rcall	8000757c <get_arg>
80007eea:	2f dd       	sub	sp,-12
80007eec:	98 18       	ld.sh	r8,r12[0x2]
80007eee:	c2 68       	rjmp	80007f3a <_vfprintf_r+0x68e>
80007ef0:	ee ca ff ff 	sub	r10,r7,-1
80007ef4:	10 37       	cp.w	r7,r8
80007ef6:	c0 94       	brge	80007f08 <_vfprintf_r+0x65c>
80007ef8:	fa c9 f9 44 	sub	r9,sp,-1724
80007efc:	14 97       	mov	r7,r10
80007efe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f02:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007f06:	c1 a8       	rjmp	80007f3a <_vfprintf_r+0x68e>
80007f08:	41 09       	lddsp	r9,sp[0x40]
80007f0a:	59 f8       	cp.w	r8,31
80007f0c:	e0 89 00 13 	brgt	80007f32 <_vfprintf_r+0x686>
80007f10:	f2 cb ff fc 	sub	r11,r9,-4
80007f14:	51 0b       	stdsp	sp[0x40],r11
80007f16:	72 09       	ld.w	r9,r9[0x0]
80007f18:	fa c6 f9 44 	sub	r6,sp,-1724
80007f1c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007f20:	2f f8       	sub	r8,-1
80007f22:	f7 49 fd 88 	st.w	r11[-632],r9
80007f26:	fb 48 06 b4 	st.w	sp[1716],r8
80007f2a:	14 97       	mov	r7,r10
80007f2c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007f30:	c0 58       	rjmp	80007f3a <_vfprintf_r+0x68e>
80007f32:	92 18       	ld.sh	r8,r9[0x2]
80007f34:	14 97       	mov	r7,r10
80007f36:	2f c9       	sub	r9,-4
80007f38:	51 09       	stdsp	sp[0x40],r9
80007f3a:	50 18       	stdsp	sp[0x4],r8
80007f3c:	bf 58       	asr	r8,0x1f
80007f3e:	50 08       	stdsp	sp[0x0],r8
80007f40:	c4 88       	rjmp	80007fd0 <_vfprintf_r+0x724>
80007f42:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f46:	40 3c       	lddsp	r12,sp[0xc]
80007f48:	58 0c       	cp.w	r12,0
80007f4a:	c1 d0       	breq	80007f84 <_vfprintf_r+0x6d8>
80007f4c:	10 36       	cp.w	r6,r8
80007f4e:	c0 64       	brge	80007f5a <_vfprintf_r+0x6ae>
80007f50:	fa cb f9 44 	sub	r11,sp,-1724
80007f54:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f58:	c1 f8       	rjmp	80007f96 <_vfprintf_r+0x6ea>
80007f5a:	fa c8 f9 50 	sub	r8,sp,-1712
80007f5e:	1a d8       	st.w	--sp,r8
80007f60:	fa c8 fa b8 	sub	r8,sp,-1352
80007f64:	0c 9b       	mov	r11,r6
80007f66:	1a d8       	st.w	--sp,r8
80007f68:	fa c8 fb b4 	sub	r8,sp,-1100
80007f6c:	04 9a       	mov	r10,r2
80007f6e:	1a d8       	st.w	--sp,r8
80007f70:	08 9c       	mov	r12,r4
80007f72:	fa c8 f9 40 	sub	r8,sp,-1728
80007f76:	fa c9 ff b4 	sub	r9,sp,-76
80007f7a:	fe b0 fb 01 	rcall	8000757c <get_arg>
80007f7e:	2f dd       	sub	sp,-12
80007f80:	78 0b       	ld.w	r11,r12[0x0]
80007f82:	c2 48       	rjmp	80007fca <_vfprintf_r+0x71e>
80007f84:	ee ca ff ff 	sub	r10,r7,-1
80007f88:	10 37       	cp.w	r7,r8
80007f8a:	c0 94       	brge	80007f9c <_vfprintf_r+0x6f0>
80007f8c:	fa c9 f9 44 	sub	r9,sp,-1724
80007f90:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f94:	14 97       	mov	r7,r10
80007f96:	ec fb fd 88 	ld.w	r11,r6[-632]
80007f9a:	c1 88       	rjmp	80007fca <_vfprintf_r+0x71e>
80007f9c:	41 09       	lddsp	r9,sp[0x40]
80007f9e:	59 f8       	cp.w	r8,31
80007fa0:	e0 89 00 11 	brgt	80007fc2 <_vfprintf_r+0x716>
80007fa4:	f2 cb ff fc 	sub	r11,r9,-4
80007fa8:	51 0b       	stdsp	sp[0x40],r11
80007faa:	fa c6 f9 44 	sub	r6,sp,-1724
80007fae:	72 0b       	ld.w	r11,r9[0x0]
80007fb0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007fb4:	f3 4b fd 88 	st.w	r9[-632],r11
80007fb8:	2f f8       	sub	r8,-1
80007fba:	14 97       	mov	r7,r10
80007fbc:	fb 48 06 b4 	st.w	sp[1716],r8
80007fc0:	c0 58       	rjmp	80007fca <_vfprintf_r+0x71e>
80007fc2:	72 0b       	ld.w	r11,r9[0x0]
80007fc4:	14 97       	mov	r7,r10
80007fc6:	2f c9       	sub	r9,-4
80007fc8:	51 09       	stdsp	sp[0x40],r9
80007fca:	50 1b       	stdsp	sp[0x4],r11
80007fcc:	bf 5b       	asr	r11,0x1f
80007fce:	50 0b       	stdsp	sp[0x0],r11
80007fd0:	fa ea 00 00 	ld.d	r10,sp[0]
80007fd4:	58 0a       	cp.w	r10,0
80007fd6:	5c 2b       	cpc	r11
80007fd8:	c0 e4       	brge	80007ff4 <_vfprintf_r+0x748>
80007fda:	30 08       	mov	r8,0
80007fdc:	fa ea 00 00 	ld.d	r10,sp[0]
80007fe0:	30 09       	mov	r9,0
80007fe2:	f0 0a 01 0a 	sub	r10,r8,r10
80007fe6:	f2 0b 01 4b 	sbc	r11,r9,r11
80007fea:	32 d8       	mov	r8,45
80007fec:	fa eb 00 00 	st.d	sp[0],r10
80007ff0:	fb 68 06 bb 	st.b	sp[1723],r8
80007ff4:	30 18       	mov	r8,1
80007ff6:	e0 8f 06 fa 	bral	80008dea <_vfprintf_r+0x153e>
80007ffa:	50 a7       	stdsp	sp[0x28],r7
80007ffc:	50 80       	stdsp	sp[0x20],r0
80007ffe:	0c 97       	mov	r7,r6
80008000:	04 94       	mov	r4,r2
80008002:	06 96       	mov	r6,r3
80008004:	02 92       	mov	r2,r1
80008006:	40 93       	lddsp	r3,sp[0x24]
80008008:	10 90       	mov	r0,r8
8000800a:	40 41       	lddsp	r1,sp[0x10]
8000800c:	0e 99       	mov	r9,r7
8000800e:	ed b5 00 03 	bld	r5,0x3
80008012:	c4 11       	brne	80008094 <_vfprintf_r+0x7e8>
80008014:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008018:	40 3a       	lddsp	r10,sp[0xc]
8000801a:	58 0a       	cp.w	r10,0
8000801c:	c1 90       	breq	8000804e <_vfprintf_r+0x7a2>
8000801e:	10 36       	cp.w	r6,r8
80008020:	c6 45       	brlt	800080e8 <_vfprintf_r+0x83c>
80008022:	fa c8 f9 50 	sub	r8,sp,-1712
80008026:	1a d8       	st.w	--sp,r8
80008028:	fa c8 fa b8 	sub	r8,sp,-1352
8000802c:	1a d8       	st.w	--sp,r8
8000802e:	fa c8 fb b4 	sub	r8,sp,-1100
80008032:	0c 9b       	mov	r11,r6
80008034:	1a d8       	st.w	--sp,r8
80008036:	04 9a       	mov	r10,r2
80008038:	fa c8 f9 40 	sub	r8,sp,-1728
8000803c:	fa c9 ff b4 	sub	r9,sp,-76
80008040:	08 9c       	mov	r12,r4
80008042:	fe b0 fa 9d 	rcall	8000757c <get_arg>
80008046:	2f dd       	sub	sp,-12
80008048:	78 16       	ld.w	r6,r12[0x4]
8000804a:	50 76       	stdsp	sp[0x1c],r6
8000804c:	c4 88       	rjmp	800080dc <_vfprintf_r+0x830>
8000804e:	2f f7       	sub	r7,-1
80008050:	10 39       	cp.w	r9,r8
80008052:	c0 c4       	brge	8000806a <_vfprintf_r+0x7be>
80008054:	fa ce f9 44 	sub	lr,sp,-1724
80008058:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000805c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008060:	50 7c       	stdsp	sp[0x1c],r12
80008062:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008066:	50 56       	stdsp	sp[0x14],r6
80008068:	c6 68       	rjmp	80008134 <_vfprintf_r+0x888>
8000806a:	41 09       	lddsp	r9,sp[0x40]
8000806c:	59 f8       	cp.w	r8,31
8000806e:	e0 89 00 10 	brgt	8000808e <_vfprintf_r+0x7e2>
80008072:	f2 ca ff f8 	sub	r10,r9,-8
80008076:	72 1b       	ld.w	r11,r9[0x4]
80008078:	51 0a       	stdsp	sp[0x40],r10
8000807a:	72 09       	ld.w	r9,r9[0x0]
8000807c:	fa ca f9 44 	sub	r10,sp,-1724
80008080:	50 7b       	stdsp	sp[0x1c],r11
80008082:	50 59       	stdsp	sp[0x14],r9
80008084:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008088:	40 5b       	lddsp	r11,sp[0x14]
8000808a:	40 7a       	lddsp	r10,sp[0x1c]
8000808c:	c4 78       	rjmp	8000811a <_vfprintf_r+0x86e>
8000808e:	72 18       	ld.w	r8,r9[0x4]
80008090:	50 78       	stdsp	sp[0x1c],r8
80008092:	c4 c8       	rjmp	8000812a <_vfprintf_r+0x87e>
80008094:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008098:	40 3e       	lddsp	lr,sp[0xc]
8000809a:	58 0e       	cp.w	lr,0
8000809c:	c2 30       	breq	800080e2 <_vfprintf_r+0x836>
8000809e:	10 36       	cp.w	r6,r8
800080a0:	c0 94       	brge	800080b2 <_vfprintf_r+0x806>
800080a2:	fa cc f9 44 	sub	r12,sp,-1724
800080a6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800080aa:	ec fb fd 8c 	ld.w	r11,r6[-628]
800080ae:	50 7b       	stdsp	sp[0x1c],r11
800080b0:	cd 9b       	rjmp	80008062 <_vfprintf_r+0x7b6>
800080b2:	fa c8 f9 50 	sub	r8,sp,-1712
800080b6:	1a d8       	st.w	--sp,r8
800080b8:	fa c8 fa b8 	sub	r8,sp,-1352
800080bc:	04 9a       	mov	r10,r2
800080be:	1a d8       	st.w	--sp,r8
800080c0:	fa c8 fb b4 	sub	r8,sp,-1100
800080c4:	0c 9b       	mov	r11,r6
800080c6:	1a d8       	st.w	--sp,r8
800080c8:	08 9c       	mov	r12,r4
800080ca:	fa c8 f9 40 	sub	r8,sp,-1728
800080ce:	fa c9 ff b4 	sub	r9,sp,-76
800080d2:	fe b0 fa 55 	rcall	8000757c <get_arg>
800080d6:	2f dd       	sub	sp,-12
800080d8:	78 1a       	ld.w	r10,r12[0x4]
800080da:	50 7a       	stdsp	sp[0x1c],r10
800080dc:	78 0c       	ld.w	r12,r12[0x0]
800080de:	50 5c       	stdsp	sp[0x14],r12
800080e0:	c2 a8       	rjmp	80008134 <_vfprintf_r+0x888>
800080e2:	2f f7       	sub	r7,-1
800080e4:	10 39       	cp.w	r9,r8
800080e6:	c0 94       	brge	800080f8 <_vfprintf_r+0x84c>
800080e8:	fa c9 f9 44 	sub	r9,sp,-1724
800080ec:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080f0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800080f4:	50 78       	stdsp	sp[0x1c],r8
800080f6:	cb 6b       	rjmp	80008062 <_vfprintf_r+0x7b6>
800080f8:	41 09       	lddsp	r9,sp[0x40]
800080fa:	59 f8       	cp.w	r8,31
800080fc:	e0 89 00 15 	brgt	80008126 <_vfprintf_r+0x87a>
80008100:	f2 ca ff f8 	sub	r10,r9,-8
80008104:	72 16       	ld.w	r6,r9[0x4]
80008106:	72 09       	ld.w	r9,r9[0x0]
80008108:	51 0a       	stdsp	sp[0x40],r10
8000810a:	50 59       	stdsp	sp[0x14],r9
8000810c:	fa ce f9 44 	sub	lr,sp,-1724
80008110:	50 76       	stdsp	sp[0x1c],r6
80008112:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008116:	40 5b       	lddsp	r11,sp[0x14]
80008118:	0c 9a       	mov	r10,r6
8000811a:	f2 eb fd 88 	st.d	r9[-632],r10
8000811e:	2f f8       	sub	r8,-1
80008120:	fb 48 06 b4 	st.w	sp[1716],r8
80008124:	c0 88       	rjmp	80008134 <_vfprintf_r+0x888>
80008126:	72 1c       	ld.w	r12,r9[0x4]
80008128:	50 7c       	stdsp	sp[0x1c],r12
8000812a:	f2 c8 ff f8 	sub	r8,r9,-8
8000812e:	51 08       	stdsp	sp[0x40],r8
80008130:	72 09       	ld.w	r9,r9[0x0]
80008132:	50 59       	stdsp	sp[0x14],r9
80008134:	40 5b       	lddsp	r11,sp[0x14]
80008136:	40 7a       	lddsp	r10,sp[0x1c]
80008138:	e0 a0 19 54 	rcall	8000b3e0 <__isinfd>
8000813c:	18 96       	mov	r6,r12
8000813e:	c1 70       	breq	8000816c <_vfprintf_r+0x8c0>
80008140:	30 08       	mov	r8,0
80008142:	30 09       	mov	r9,0
80008144:	40 5b       	lddsp	r11,sp[0x14]
80008146:	40 7a       	lddsp	r10,sp[0x1c]
80008148:	e0 a0 1d b4 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
8000814c:	c0 40       	breq	80008154 <_vfprintf_r+0x8a8>
8000814e:	32 d8       	mov	r8,45
80008150:	fb 68 06 bb 	st.b	sp[1723],r8
80008154:	fe c8 aa f0 	sub	r8,pc,-21776
80008158:	fe c6 aa f0 	sub	r6,pc,-21776
8000815c:	a7 d5       	cbr	r5,0x7
8000815e:	e0 40 00 47 	cp.w	r0,71
80008162:	f0 06 17 a0 	movle	r6,r8
80008166:	30 32       	mov	r2,3
80008168:	e0 8f 06 ce 	bral	80008f04 <_vfprintf_r+0x1658>
8000816c:	40 5b       	lddsp	r11,sp[0x14]
8000816e:	40 7a       	lddsp	r10,sp[0x1c]
80008170:	e0 a0 19 4d 	rcall	8000b40a <__isnand>
80008174:	c0 e0       	breq	80008190 <_vfprintf_r+0x8e4>
80008176:	50 26       	stdsp	sp[0x8],r6
80008178:	fe c8 ab 0c 	sub	r8,pc,-21748
8000817c:	fe c6 ab 0c 	sub	r6,pc,-21748
80008180:	a7 d5       	cbr	r5,0x7
80008182:	e0 40 00 47 	cp.w	r0,71
80008186:	f0 06 17 a0 	movle	r6,r8
8000818a:	30 32       	mov	r2,3
8000818c:	e0 8f 06 c2 	bral	80008f10 <_vfprintf_r+0x1664>
80008190:	40 2a       	lddsp	r10,sp[0x8]
80008192:	5b fa       	cp.w	r10,-1
80008194:	c0 41       	brne	8000819c <_vfprintf_r+0x8f0>
80008196:	30 69       	mov	r9,6
80008198:	50 29       	stdsp	sp[0x8],r9
8000819a:	c1 18       	rjmp	800081bc <_vfprintf_r+0x910>
8000819c:	e0 40 00 47 	cp.w	r0,71
800081a0:	5f 09       	sreq	r9
800081a2:	e0 40 00 67 	cp.w	r0,103
800081a6:	5f 08       	sreq	r8
800081a8:	f3 e8 10 08 	or	r8,r9,r8
800081ac:	f8 08 18 00 	cp.b	r8,r12
800081b0:	c0 60       	breq	800081bc <_vfprintf_r+0x910>
800081b2:	40 28       	lddsp	r8,sp[0x8]
800081b4:	58 08       	cp.w	r8,0
800081b6:	f9 b8 00 01 	moveq	r8,1
800081ba:	50 28       	stdsp	sp[0x8],r8
800081bc:	40 78       	lddsp	r8,sp[0x1c]
800081be:	40 59       	lddsp	r9,sp[0x14]
800081c0:	fa e9 06 94 	st.d	sp[1684],r8
800081c4:	a9 a5       	sbr	r5,0x8
800081c6:	fa f8 06 94 	ld.w	r8,sp[1684]
800081ca:	58 08       	cp.w	r8,0
800081cc:	c0 65       	brlt	800081d8 <_vfprintf_r+0x92c>
800081ce:	40 5e       	lddsp	lr,sp[0x14]
800081d0:	30 0c       	mov	r12,0
800081d2:	50 6e       	stdsp	sp[0x18],lr
800081d4:	50 9c       	stdsp	sp[0x24],r12
800081d6:	c0 78       	rjmp	800081e4 <_vfprintf_r+0x938>
800081d8:	40 5b       	lddsp	r11,sp[0x14]
800081da:	32 da       	mov	r10,45
800081dc:	ee 1b 80 00 	eorh	r11,0x8000
800081e0:	50 9a       	stdsp	sp[0x24],r10
800081e2:	50 6b       	stdsp	sp[0x18],r11
800081e4:	e0 40 00 46 	cp.w	r0,70
800081e8:	5f 09       	sreq	r9
800081ea:	e0 40 00 66 	cp.w	r0,102
800081ee:	5f 08       	sreq	r8
800081f0:	f3 e8 10 08 	or	r8,r9,r8
800081f4:	50 48       	stdsp	sp[0x10],r8
800081f6:	c0 40       	breq	800081fe <_vfprintf_r+0x952>
800081f8:	40 22       	lddsp	r2,sp[0x8]
800081fa:	30 39       	mov	r9,3
800081fc:	c1 08       	rjmp	8000821c <_vfprintf_r+0x970>
800081fe:	e0 40 00 45 	cp.w	r0,69
80008202:	5f 09       	sreq	r9
80008204:	e0 40 00 65 	cp.w	r0,101
80008208:	5f 08       	sreq	r8
8000820a:	40 22       	lddsp	r2,sp[0x8]
8000820c:	10 49       	or	r9,r8
8000820e:	2f f2       	sub	r2,-1
80008210:	40 46       	lddsp	r6,sp[0x10]
80008212:	ec 09 18 00 	cp.b	r9,r6
80008216:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000821a:	30 29       	mov	r9,2
8000821c:	fa c8 f9 5c 	sub	r8,sp,-1700
80008220:	1a d8       	st.w	--sp,r8
80008222:	fa c8 f9 54 	sub	r8,sp,-1708
80008226:	1a d8       	st.w	--sp,r8
80008228:	fa c8 f9 4c 	sub	r8,sp,-1716
8000822c:	08 9c       	mov	r12,r4
8000822e:	1a d8       	st.w	--sp,r8
80008230:	04 98       	mov	r8,r2
80008232:	40 9b       	lddsp	r11,sp[0x24]
80008234:	40 aa       	lddsp	r10,sp[0x28]
80008236:	e0 a0 0b c3 	rcall	800099bc <_dtoa_r>
8000823a:	e0 40 00 47 	cp.w	r0,71
8000823e:	5f 19       	srne	r9
80008240:	e0 40 00 67 	cp.w	r0,103
80008244:	5f 18       	srne	r8
80008246:	18 96       	mov	r6,r12
80008248:	2f dd       	sub	sp,-12
8000824a:	f3 e8 00 08 	and	r8,r9,r8
8000824e:	c0 41       	brne	80008256 <_vfprintf_r+0x9aa>
80008250:	ed b5 00 00 	bld	r5,0x0
80008254:	c3 01       	brne	800082b4 <_vfprintf_r+0xa08>
80008256:	ec 02 00 0e 	add	lr,r6,r2
8000825a:	50 3e       	stdsp	sp[0xc],lr
8000825c:	40 4c       	lddsp	r12,sp[0x10]
8000825e:	58 0c       	cp.w	r12,0
80008260:	c1 50       	breq	8000828a <_vfprintf_r+0x9de>
80008262:	0d 89       	ld.ub	r9,r6[0x0]
80008264:	33 08       	mov	r8,48
80008266:	f0 09 18 00 	cp.b	r9,r8
8000826a:	c0 b1       	brne	80008280 <_vfprintf_r+0x9d4>
8000826c:	30 08       	mov	r8,0
8000826e:	30 09       	mov	r9,0
80008270:	40 6b       	lddsp	r11,sp[0x18]
80008272:	40 7a       	lddsp	r10,sp[0x1c]
80008274:	e0 a0 1c d7 	rcall	8000bc22 <__avr32_f64_cmp_eq>
80008278:	fb b2 00 01 	rsubeq	r2,1
8000827c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008280:	40 3b       	lddsp	r11,sp[0xc]
80008282:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008286:	10 0b       	add	r11,r8
80008288:	50 3b       	stdsp	sp[0xc],r11
8000828a:	40 6b       	lddsp	r11,sp[0x18]
8000828c:	30 08       	mov	r8,0
8000828e:	30 09       	mov	r9,0
80008290:	40 7a       	lddsp	r10,sp[0x1c]
80008292:	e0 a0 1c c8 	rcall	8000bc22 <__avr32_f64_cmp_eq>
80008296:	c0 90       	breq	800082a8 <_vfprintf_r+0x9fc>
80008298:	40 3a       	lddsp	r10,sp[0xc]
8000829a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000829e:	c0 58       	rjmp	800082a8 <_vfprintf_r+0x9fc>
800082a0:	10 c9       	st.b	r8++,r9
800082a2:	fb 48 06 a4 	st.w	sp[1700],r8
800082a6:	c0 28       	rjmp	800082aa <_vfprintf_r+0x9fe>
800082a8:	33 09       	mov	r9,48
800082aa:	fa f8 06 a4 	ld.w	r8,sp[1700]
800082ae:	40 3e       	lddsp	lr,sp[0xc]
800082b0:	1c 38       	cp.w	r8,lr
800082b2:	cf 73       	brcs	800082a0 <_vfprintf_r+0x9f4>
800082b4:	e0 40 00 47 	cp.w	r0,71
800082b8:	5f 09       	sreq	r9
800082ba:	e0 40 00 67 	cp.w	r0,103
800082be:	5f 08       	sreq	r8
800082c0:	f3 e8 10 08 	or	r8,r9,r8
800082c4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800082c8:	0c 19       	sub	r9,r6
800082ca:	50 69       	stdsp	sp[0x18],r9
800082cc:	58 08       	cp.w	r8,0
800082ce:	c0 b0       	breq	800082e4 <_vfprintf_r+0xa38>
800082d0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800082d4:	5b d8       	cp.w	r8,-3
800082d6:	c0 55       	brlt	800082e0 <_vfprintf_r+0xa34>
800082d8:	40 2c       	lddsp	r12,sp[0x8]
800082da:	18 38       	cp.w	r8,r12
800082dc:	e0 8a 00 6a 	brle	800083b0 <_vfprintf_r+0xb04>
800082e0:	20 20       	sub	r0,2
800082e2:	c0 58       	rjmp	800082ec <_vfprintf_r+0xa40>
800082e4:	e0 40 00 65 	cp.w	r0,101
800082e8:	e0 89 00 46 	brgt	80008374 <_vfprintf_r+0xac8>
800082ec:	fa fb 06 ac 	ld.w	r11,sp[1708]
800082f0:	fb 60 06 9c 	st.b	sp[1692],r0
800082f4:	20 1b       	sub	r11,1
800082f6:	fb 4b 06 ac 	st.w	sp[1708],r11
800082fa:	c0 47       	brpl	80008302 <_vfprintf_r+0xa56>
800082fc:	5c 3b       	neg	r11
800082fe:	32 d8       	mov	r8,45
80008300:	c0 28       	rjmp	80008304 <_vfprintf_r+0xa58>
80008302:	32 b8       	mov	r8,43
80008304:	fb 68 06 9d 	st.b	sp[1693],r8
80008308:	58 9b       	cp.w	r11,9
8000830a:	e0 8a 00 1d 	brle	80008344 <_vfprintf_r+0xa98>
8000830e:	fa c9 fa 35 	sub	r9,sp,-1483
80008312:	30 aa       	mov	r10,10
80008314:	12 98       	mov	r8,r9
80008316:	0e 9c       	mov	r12,r7
80008318:	0c 92       	mov	r2,r6
8000831a:	f6 0a 0c 06 	divs	r6,r11,r10
8000831e:	0e 9b       	mov	r11,r7
80008320:	2d 0b       	sub	r11,-48
80008322:	10 fb       	st.b	--r8,r11
80008324:	0c 9b       	mov	r11,r6
80008326:	58 96       	cp.w	r6,9
80008328:	fe 99 ff f9 	brgt	8000831a <_vfprintf_r+0xa6e>
8000832c:	2d 0b       	sub	r11,-48
8000832e:	18 97       	mov	r7,r12
80008330:	04 96       	mov	r6,r2
80008332:	10 fb       	st.b	--r8,r11
80008334:	fa ca f9 62 	sub	r10,sp,-1694
80008338:	c0 38       	rjmp	8000833e <_vfprintf_r+0xa92>
8000833a:	11 3b       	ld.ub	r11,r8++
8000833c:	14 cb       	st.b	r10++,r11
8000833e:	12 38       	cp.w	r8,r9
80008340:	cf d3       	brcs	8000833a <_vfprintf_r+0xa8e>
80008342:	c0 98       	rjmp	80008354 <_vfprintf_r+0xaa8>
80008344:	2d 0b       	sub	r11,-48
80008346:	33 08       	mov	r8,48
80008348:	fb 6b 06 9f 	st.b	sp[1695],r11
8000834c:	fb 68 06 9e 	st.b	sp[1694],r8
80008350:	fa ca f9 60 	sub	r10,sp,-1696
80008354:	fa c8 f9 64 	sub	r8,sp,-1692
80008358:	f4 08 01 08 	sub	r8,r10,r8
8000835c:	50 e8       	stdsp	sp[0x38],r8
8000835e:	10 92       	mov	r2,r8
80008360:	40 6b       	lddsp	r11,sp[0x18]
80008362:	16 02       	add	r2,r11
80008364:	58 1b       	cp.w	r11,1
80008366:	e0 89 00 05 	brgt	80008370 <_vfprintf_r+0xac4>
8000836a:	ed b5 00 00 	bld	r5,0x0
8000836e:	c3 51       	brne	800083d8 <_vfprintf_r+0xb2c>
80008370:	2f f2       	sub	r2,-1
80008372:	c3 38       	rjmp	800083d8 <_vfprintf_r+0xb2c>
80008374:	e0 40 00 66 	cp.w	r0,102
80008378:	c1 c1       	brne	800083b0 <_vfprintf_r+0xb04>
8000837a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000837e:	58 02       	cp.w	r2,0
80008380:	e0 8a 00 0c 	brle	80008398 <_vfprintf_r+0xaec>
80008384:	40 2a       	lddsp	r10,sp[0x8]
80008386:	58 0a       	cp.w	r10,0
80008388:	c0 41       	brne	80008390 <_vfprintf_r+0xae4>
8000838a:	ed b5 00 00 	bld	r5,0x0
8000838e:	c2 51       	brne	800083d8 <_vfprintf_r+0xb2c>
80008390:	2f f2       	sub	r2,-1
80008392:	40 29       	lddsp	r9,sp[0x8]
80008394:	12 02       	add	r2,r9
80008396:	c0 b8       	rjmp	800083ac <_vfprintf_r+0xb00>
80008398:	40 28       	lddsp	r8,sp[0x8]
8000839a:	58 08       	cp.w	r8,0
8000839c:	c0 61       	brne	800083a8 <_vfprintf_r+0xafc>
8000839e:	ed b5 00 00 	bld	r5,0x0
800083a2:	c0 30       	breq	800083a8 <_vfprintf_r+0xafc>
800083a4:	30 12       	mov	r2,1
800083a6:	c1 98       	rjmp	800083d8 <_vfprintf_r+0xb2c>
800083a8:	40 22       	lddsp	r2,sp[0x8]
800083aa:	2f e2       	sub	r2,-2
800083ac:	36 60       	mov	r0,102
800083ae:	c1 58       	rjmp	800083d8 <_vfprintf_r+0xb2c>
800083b0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800083b4:	40 6e       	lddsp	lr,sp[0x18]
800083b6:	1c 32       	cp.w	r2,lr
800083b8:	c0 65       	brlt	800083c4 <_vfprintf_r+0xb18>
800083ba:	ed b5 00 00 	bld	r5,0x0
800083be:	f7 b2 00 ff 	subeq	r2,-1
800083c2:	c0 a8       	rjmp	800083d6 <_vfprintf_r+0xb2a>
800083c4:	e4 08 11 02 	rsub	r8,r2,2
800083c8:	40 6c       	lddsp	r12,sp[0x18]
800083ca:	58 02       	cp.w	r2,0
800083cc:	f0 02 17 a0 	movle	r2,r8
800083d0:	f9 b2 09 01 	movgt	r2,1
800083d4:	18 02       	add	r2,r12
800083d6:	36 70       	mov	r0,103
800083d8:	40 9b       	lddsp	r11,sp[0x24]
800083da:	58 0b       	cp.w	r11,0
800083dc:	e0 80 05 94 	breq	80008f04 <_vfprintf_r+0x1658>
800083e0:	32 d8       	mov	r8,45
800083e2:	fb 68 06 bb 	st.b	sp[1723],r8
800083e6:	e0 8f 05 93 	bral	80008f0c <_vfprintf_r+0x1660>
800083ea:	50 a7       	stdsp	sp[0x28],r7
800083ec:	04 94       	mov	r4,r2
800083ee:	0c 97       	mov	r7,r6
800083f0:	02 92       	mov	r2,r1
800083f2:	06 96       	mov	r6,r3
800083f4:	40 41       	lddsp	r1,sp[0x10]
800083f6:	40 93       	lddsp	r3,sp[0x24]
800083f8:	0e 99       	mov	r9,r7
800083fa:	ed b5 00 05 	bld	r5,0x5
800083fe:	c4 81       	brne	8000848e <_vfprintf_r+0xbe2>
80008400:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008404:	40 3e       	lddsp	lr,sp[0xc]
80008406:	58 0e       	cp.w	lr,0
80008408:	c1 d0       	breq	80008442 <_vfprintf_r+0xb96>
8000840a:	10 36       	cp.w	r6,r8
8000840c:	c0 64       	brge	80008418 <_vfprintf_r+0xb6c>
8000840e:	fa cc f9 44 	sub	r12,sp,-1724
80008412:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008416:	c1 d8       	rjmp	80008450 <_vfprintf_r+0xba4>
80008418:	fa c8 f9 50 	sub	r8,sp,-1712
8000841c:	1a d8       	st.w	--sp,r8
8000841e:	fa c8 fa b8 	sub	r8,sp,-1352
80008422:	04 9a       	mov	r10,r2
80008424:	1a d8       	st.w	--sp,r8
80008426:	fa c8 fb b4 	sub	r8,sp,-1100
8000842a:	0c 9b       	mov	r11,r6
8000842c:	1a d8       	st.w	--sp,r8
8000842e:	08 9c       	mov	r12,r4
80008430:	fa c8 f9 40 	sub	r8,sp,-1728
80008434:	fa c9 ff b4 	sub	r9,sp,-76
80008438:	fe b0 f8 a2 	rcall	8000757c <get_arg>
8000843c:	2f dd       	sub	sp,-12
8000843e:	78 0a       	ld.w	r10,r12[0x0]
80008440:	c2 08       	rjmp	80008480 <_vfprintf_r+0xbd4>
80008442:	2f f7       	sub	r7,-1
80008444:	10 39       	cp.w	r9,r8
80008446:	c0 84       	brge	80008456 <_vfprintf_r+0xbaa>
80008448:	fa cb f9 44 	sub	r11,sp,-1724
8000844c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008450:	ec fa fd 88 	ld.w	r10,r6[-632]
80008454:	c1 68       	rjmp	80008480 <_vfprintf_r+0xbd4>
80008456:	41 09       	lddsp	r9,sp[0x40]
80008458:	59 f8       	cp.w	r8,31
8000845a:	e0 89 00 10 	brgt	8000847a <_vfprintf_r+0xbce>
8000845e:	f2 ca ff fc 	sub	r10,r9,-4
80008462:	51 0a       	stdsp	sp[0x40],r10
80008464:	fa c6 f9 44 	sub	r6,sp,-1724
80008468:	72 0a       	ld.w	r10,r9[0x0]
8000846a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000846e:	f3 4a fd 88 	st.w	r9[-632],r10
80008472:	2f f8       	sub	r8,-1
80008474:	fb 48 06 b4 	st.w	sp[1716],r8
80008478:	c0 48       	rjmp	80008480 <_vfprintf_r+0xbd4>
8000847a:	72 0a       	ld.w	r10,r9[0x0]
8000847c:	2f c9       	sub	r9,-4
8000847e:	51 09       	stdsp	sp[0x40],r9
80008480:	40 be       	lddsp	lr,sp[0x2c]
80008482:	1c 98       	mov	r8,lr
80008484:	95 1e       	st.w	r10[0x4],lr
80008486:	bf 58       	asr	r8,0x1f
80008488:	95 08       	st.w	r10[0x0],r8
8000848a:	fe 9f fa 9f 	bral	800079c8 <_vfprintf_r+0x11c>
8000848e:	ed b5 00 04 	bld	r5,0x4
80008492:	c4 80       	breq	80008522 <_vfprintf_r+0xc76>
80008494:	e2 15 00 40 	andl	r5,0x40,COH
80008498:	c4 50       	breq	80008522 <_vfprintf_r+0xc76>
8000849a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000849e:	40 3c       	lddsp	r12,sp[0xc]
800084a0:	58 0c       	cp.w	r12,0
800084a2:	c1 d0       	breq	800084dc <_vfprintf_r+0xc30>
800084a4:	10 36       	cp.w	r6,r8
800084a6:	c0 64       	brge	800084b2 <_vfprintf_r+0xc06>
800084a8:	fa cb f9 44 	sub	r11,sp,-1724
800084ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084b0:	c1 d8       	rjmp	800084ea <_vfprintf_r+0xc3e>
800084b2:	fa c8 f9 50 	sub	r8,sp,-1712
800084b6:	1a d8       	st.w	--sp,r8
800084b8:	fa c8 fa b8 	sub	r8,sp,-1352
800084bc:	04 9a       	mov	r10,r2
800084be:	1a d8       	st.w	--sp,r8
800084c0:	fa c8 fb b4 	sub	r8,sp,-1100
800084c4:	0c 9b       	mov	r11,r6
800084c6:	1a d8       	st.w	--sp,r8
800084c8:	08 9c       	mov	r12,r4
800084ca:	fa c8 f9 40 	sub	r8,sp,-1728
800084ce:	fa c9 ff b4 	sub	r9,sp,-76
800084d2:	fe b0 f8 55 	rcall	8000757c <get_arg>
800084d6:	2f dd       	sub	sp,-12
800084d8:	78 0a       	ld.w	r10,r12[0x0]
800084da:	c2 08       	rjmp	8000851a <_vfprintf_r+0xc6e>
800084dc:	2f f7       	sub	r7,-1
800084de:	10 39       	cp.w	r9,r8
800084e0:	c0 84       	brge	800084f0 <_vfprintf_r+0xc44>
800084e2:	fa ca f9 44 	sub	r10,sp,-1724
800084e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800084ea:	ec fa fd 88 	ld.w	r10,r6[-632]
800084ee:	c1 68       	rjmp	8000851a <_vfprintf_r+0xc6e>
800084f0:	41 09       	lddsp	r9,sp[0x40]
800084f2:	59 f8       	cp.w	r8,31
800084f4:	e0 89 00 10 	brgt	80008514 <_vfprintf_r+0xc68>
800084f8:	f2 ca ff fc 	sub	r10,r9,-4
800084fc:	51 0a       	stdsp	sp[0x40],r10
800084fe:	fa c6 f9 44 	sub	r6,sp,-1724
80008502:	72 0a       	ld.w	r10,r9[0x0]
80008504:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008508:	f3 4a fd 88 	st.w	r9[-632],r10
8000850c:	2f f8       	sub	r8,-1
8000850e:	fb 48 06 b4 	st.w	sp[1716],r8
80008512:	c0 48       	rjmp	8000851a <_vfprintf_r+0xc6e>
80008514:	72 0a       	ld.w	r10,r9[0x0]
80008516:	2f c9       	sub	r9,-4
80008518:	51 09       	stdsp	sp[0x40],r9
8000851a:	40 be       	lddsp	lr,sp[0x2c]
8000851c:	b4 0e       	st.h	r10[0x0],lr
8000851e:	fe 9f fa 55 	bral	800079c8 <_vfprintf_r+0x11c>
80008522:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008526:	40 3c       	lddsp	r12,sp[0xc]
80008528:	58 0c       	cp.w	r12,0
8000852a:	c1 d0       	breq	80008564 <_vfprintf_r+0xcb8>
8000852c:	10 36       	cp.w	r6,r8
8000852e:	c0 64       	brge	8000853a <_vfprintf_r+0xc8e>
80008530:	fa cb f9 44 	sub	r11,sp,-1724
80008534:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008538:	c1 d8       	rjmp	80008572 <_vfprintf_r+0xcc6>
8000853a:	fa c8 f9 50 	sub	r8,sp,-1712
8000853e:	1a d8       	st.w	--sp,r8
80008540:	fa c8 fa b8 	sub	r8,sp,-1352
80008544:	04 9a       	mov	r10,r2
80008546:	1a d8       	st.w	--sp,r8
80008548:	fa c8 fb b4 	sub	r8,sp,-1100
8000854c:	0c 9b       	mov	r11,r6
8000854e:	1a d8       	st.w	--sp,r8
80008550:	08 9c       	mov	r12,r4
80008552:	fa c8 f9 40 	sub	r8,sp,-1728
80008556:	fa c9 ff b4 	sub	r9,sp,-76
8000855a:	fe b0 f8 11 	rcall	8000757c <get_arg>
8000855e:	2f dd       	sub	sp,-12
80008560:	78 0a       	ld.w	r10,r12[0x0]
80008562:	c2 08       	rjmp	800085a2 <_vfprintf_r+0xcf6>
80008564:	2f f7       	sub	r7,-1
80008566:	10 39       	cp.w	r9,r8
80008568:	c0 84       	brge	80008578 <_vfprintf_r+0xccc>
8000856a:	fa ca f9 44 	sub	r10,sp,-1724
8000856e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008572:	ec fa fd 88 	ld.w	r10,r6[-632]
80008576:	c1 68       	rjmp	800085a2 <_vfprintf_r+0xcf6>
80008578:	41 09       	lddsp	r9,sp[0x40]
8000857a:	59 f8       	cp.w	r8,31
8000857c:	e0 89 00 10 	brgt	8000859c <_vfprintf_r+0xcf0>
80008580:	f2 ca ff fc 	sub	r10,r9,-4
80008584:	51 0a       	stdsp	sp[0x40],r10
80008586:	fa c6 f9 44 	sub	r6,sp,-1724
8000858a:	72 0a       	ld.w	r10,r9[0x0]
8000858c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008590:	f3 4a fd 88 	st.w	r9[-632],r10
80008594:	2f f8       	sub	r8,-1
80008596:	fb 48 06 b4 	st.w	sp[1716],r8
8000859a:	c0 48       	rjmp	800085a2 <_vfprintf_r+0xcf6>
8000859c:	72 0a       	ld.w	r10,r9[0x0]
8000859e:	2f c9       	sub	r9,-4
800085a0:	51 09       	stdsp	sp[0x40],r9
800085a2:	40 be       	lddsp	lr,sp[0x2c]
800085a4:	95 0e       	st.w	r10[0x0],lr
800085a6:	fe 9f fa 11 	bral	800079c8 <_vfprintf_r+0x11c>
800085aa:	50 a7       	stdsp	sp[0x28],r7
800085ac:	50 80       	stdsp	sp[0x20],r0
800085ae:	0c 97       	mov	r7,r6
800085b0:	04 94       	mov	r4,r2
800085b2:	06 96       	mov	r6,r3
800085b4:	02 92       	mov	r2,r1
800085b6:	40 93       	lddsp	r3,sp[0x24]
800085b8:	10 90       	mov	r0,r8
800085ba:	40 41       	lddsp	r1,sp[0x10]
800085bc:	a5 a5       	sbr	r5,0x4
800085be:	c0 a8       	rjmp	800085d2 <_vfprintf_r+0xd26>
800085c0:	50 a7       	stdsp	sp[0x28],r7
800085c2:	50 80       	stdsp	sp[0x20],r0
800085c4:	0c 97       	mov	r7,r6
800085c6:	04 94       	mov	r4,r2
800085c8:	06 96       	mov	r6,r3
800085ca:	02 92       	mov	r2,r1
800085cc:	40 93       	lddsp	r3,sp[0x24]
800085ce:	10 90       	mov	r0,r8
800085d0:	40 41       	lddsp	r1,sp[0x10]
800085d2:	ed b5 00 05 	bld	r5,0x5
800085d6:	c5 d1       	brne	80008690 <_vfprintf_r+0xde4>
800085d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085dc:	40 3c       	lddsp	r12,sp[0xc]
800085de:	58 0c       	cp.w	r12,0
800085e0:	c2 60       	breq	8000862c <_vfprintf_r+0xd80>
800085e2:	10 36       	cp.w	r6,r8
800085e4:	c0 a4       	brge	800085f8 <_vfprintf_r+0xd4c>
800085e6:	fa cb f9 44 	sub	r11,sp,-1724
800085ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085ee:	ec e8 fd 88 	ld.d	r8,r6[-632]
800085f2:	fa e9 00 00 	st.d	sp[0],r8
800085f6:	c1 88       	rjmp	80008626 <_vfprintf_r+0xd7a>
800085f8:	fa c8 f9 50 	sub	r8,sp,-1712
800085fc:	1a d8       	st.w	--sp,r8
800085fe:	fa c8 fa b8 	sub	r8,sp,-1352
80008602:	04 9a       	mov	r10,r2
80008604:	1a d8       	st.w	--sp,r8
80008606:	0c 9b       	mov	r11,r6
80008608:	fa c8 fb b4 	sub	r8,sp,-1100
8000860c:	08 9c       	mov	r12,r4
8000860e:	1a d8       	st.w	--sp,r8
80008610:	fa c8 f9 40 	sub	r8,sp,-1728
80008614:	fa c9 ff b4 	sub	r9,sp,-76
80008618:	fe b0 f7 b2 	rcall	8000757c <get_arg>
8000861c:	2f dd       	sub	sp,-12
8000861e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008622:	fa eb 00 00 	st.d	sp[0],r10
80008626:	30 08       	mov	r8,0
80008628:	e0 8f 03 de 	bral	80008de4 <_vfprintf_r+0x1538>
8000862c:	ee ca ff ff 	sub	r10,r7,-1
80008630:	10 37       	cp.w	r7,r8
80008632:	c0 b4       	brge	80008648 <_vfprintf_r+0xd9c>
80008634:	fa c9 f9 44 	sub	r9,sp,-1724
80008638:	14 97       	mov	r7,r10
8000863a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000863e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008642:	fa eb 00 00 	st.d	sp[0],r10
80008646:	c1 88       	rjmp	80008676 <_vfprintf_r+0xdca>
80008648:	41 09       	lddsp	r9,sp[0x40]
8000864a:	59 f8       	cp.w	r8,31
8000864c:	e0 89 00 18 	brgt	8000867c <_vfprintf_r+0xdd0>
80008650:	f2 e6 00 00 	ld.d	r6,r9[0]
80008654:	f2 cb ff f8 	sub	r11,r9,-8
80008658:	fa e7 00 00 	st.d	sp[0],r6
8000865c:	51 0b       	stdsp	sp[0x40],r11
8000865e:	fa c6 f9 44 	sub	r6,sp,-1724
80008662:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008666:	fa e6 00 00 	ld.d	r6,sp[0]
8000866a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000866e:	2f f8       	sub	r8,-1
80008670:	14 97       	mov	r7,r10
80008672:	fb 48 06 b4 	st.w	sp[1716],r8
80008676:	40 38       	lddsp	r8,sp[0xc]
80008678:	e0 8f 03 b6 	bral	80008de4 <_vfprintf_r+0x1538>
8000867c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008680:	40 38       	lddsp	r8,sp[0xc]
80008682:	fa e7 00 00 	st.d	sp[0],r6
80008686:	2f 89       	sub	r9,-8
80008688:	14 97       	mov	r7,r10
8000868a:	51 09       	stdsp	sp[0x40],r9
8000868c:	e0 8f 03 ac 	bral	80008de4 <_vfprintf_r+0x1538>
80008690:	ed b5 00 04 	bld	r5,0x4
80008694:	c1 61       	brne	800086c0 <_vfprintf_r+0xe14>
80008696:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000869a:	40 3e       	lddsp	lr,sp[0xc]
8000869c:	58 0e       	cp.w	lr,0
8000869e:	c0 80       	breq	800086ae <_vfprintf_r+0xe02>
800086a0:	10 36       	cp.w	r6,r8
800086a2:	c6 74       	brge	80008770 <_vfprintf_r+0xec4>
800086a4:	fa cc f9 44 	sub	r12,sp,-1724
800086a8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086ac:	c8 08       	rjmp	800087ac <_vfprintf_r+0xf00>
800086ae:	ee ca ff ff 	sub	r10,r7,-1
800086b2:	10 37       	cp.w	r7,r8
800086b4:	c7 f4       	brge	800087b2 <_vfprintf_r+0xf06>
800086b6:	fa cb f9 44 	sub	r11,sp,-1724
800086ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086be:	c7 68       	rjmp	800087aa <_vfprintf_r+0xefe>
800086c0:	ed b5 00 06 	bld	r5,0x6
800086c4:	c4 a1       	brne	80008758 <_vfprintf_r+0xeac>
800086c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086ca:	40 3c       	lddsp	r12,sp[0xc]
800086cc:	58 0c       	cp.w	r12,0
800086ce:	c1 d0       	breq	80008708 <_vfprintf_r+0xe5c>
800086d0:	10 36       	cp.w	r6,r8
800086d2:	c0 64       	brge	800086de <_vfprintf_r+0xe32>
800086d4:	fa cb f9 44 	sub	r11,sp,-1724
800086d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086dc:	c1 f8       	rjmp	8000871a <_vfprintf_r+0xe6e>
800086de:	fa c8 f9 50 	sub	r8,sp,-1712
800086e2:	1a d8       	st.w	--sp,r8
800086e4:	fa c8 fa b8 	sub	r8,sp,-1352
800086e8:	1a d8       	st.w	--sp,r8
800086ea:	fa c8 fb b4 	sub	r8,sp,-1100
800086ee:	1a d8       	st.w	--sp,r8
800086f0:	fa c8 f9 40 	sub	r8,sp,-1728
800086f4:	fa c9 ff b4 	sub	r9,sp,-76
800086f8:	04 9a       	mov	r10,r2
800086fa:	0c 9b       	mov	r11,r6
800086fc:	08 9c       	mov	r12,r4
800086fe:	fe b0 f7 3f 	rcall	8000757c <get_arg>
80008702:	2f dd       	sub	sp,-12
80008704:	98 18       	ld.sh	r8,r12[0x2]
80008706:	c2 68       	rjmp	80008752 <_vfprintf_r+0xea6>
80008708:	ee ca ff ff 	sub	r10,r7,-1
8000870c:	10 37       	cp.w	r7,r8
8000870e:	c0 94       	brge	80008720 <_vfprintf_r+0xe74>
80008710:	fa c9 f9 44 	sub	r9,sp,-1724
80008714:	14 97       	mov	r7,r10
80008716:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000871a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000871e:	c1 a8       	rjmp	80008752 <_vfprintf_r+0xea6>
80008720:	41 09       	lddsp	r9,sp[0x40]
80008722:	59 f8       	cp.w	r8,31
80008724:	e0 89 00 13 	brgt	8000874a <_vfprintf_r+0xe9e>
80008728:	f2 cb ff fc 	sub	r11,r9,-4
8000872c:	51 0b       	stdsp	sp[0x40],r11
8000872e:	72 09       	ld.w	r9,r9[0x0]
80008730:	fa c6 f9 44 	sub	r6,sp,-1724
80008734:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008738:	2f f8       	sub	r8,-1
8000873a:	f7 49 fd 88 	st.w	r11[-632],r9
8000873e:	fb 48 06 b4 	st.w	sp[1716],r8
80008742:	14 97       	mov	r7,r10
80008744:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008748:	c0 58       	rjmp	80008752 <_vfprintf_r+0xea6>
8000874a:	92 18       	ld.sh	r8,r9[0x2]
8000874c:	14 97       	mov	r7,r10
8000874e:	2f c9       	sub	r9,-4
80008750:	51 09       	stdsp	sp[0x40],r9
80008752:	5c 78       	castu.h	r8
80008754:	50 18       	stdsp	sp[0x4],r8
80008756:	c4 68       	rjmp	800087e2 <_vfprintf_r+0xf36>
80008758:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000875c:	40 3c       	lddsp	r12,sp[0xc]
8000875e:	58 0c       	cp.w	r12,0
80008760:	c1 d0       	breq	8000879a <_vfprintf_r+0xeee>
80008762:	10 36       	cp.w	r6,r8
80008764:	c0 64       	brge	80008770 <_vfprintf_r+0xec4>
80008766:	fa cb f9 44 	sub	r11,sp,-1724
8000876a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000876e:	c1 f8       	rjmp	800087ac <_vfprintf_r+0xf00>
80008770:	fa c8 f9 50 	sub	r8,sp,-1712
80008774:	1a d8       	st.w	--sp,r8
80008776:	fa c8 fa b8 	sub	r8,sp,-1352
8000877a:	0c 9b       	mov	r11,r6
8000877c:	1a d8       	st.w	--sp,r8
8000877e:	fa c8 fb b4 	sub	r8,sp,-1100
80008782:	04 9a       	mov	r10,r2
80008784:	1a d8       	st.w	--sp,r8
80008786:	08 9c       	mov	r12,r4
80008788:	fa c8 f9 40 	sub	r8,sp,-1728
8000878c:	fa c9 ff b4 	sub	r9,sp,-76
80008790:	fe b0 f6 f6 	rcall	8000757c <get_arg>
80008794:	2f dd       	sub	sp,-12
80008796:	78 0b       	ld.w	r11,r12[0x0]
80008798:	c2 48       	rjmp	800087e0 <_vfprintf_r+0xf34>
8000879a:	ee ca ff ff 	sub	r10,r7,-1
8000879e:	10 37       	cp.w	r7,r8
800087a0:	c0 94       	brge	800087b2 <_vfprintf_r+0xf06>
800087a2:	fa c9 f9 44 	sub	r9,sp,-1724
800087a6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087aa:	14 97       	mov	r7,r10
800087ac:	ec fb fd 88 	ld.w	r11,r6[-632]
800087b0:	c1 88       	rjmp	800087e0 <_vfprintf_r+0xf34>
800087b2:	41 09       	lddsp	r9,sp[0x40]
800087b4:	59 f8       	cp.w	r8,31
800087b6:	e0 89 00 11 	brgt	800087d8 <_vfprintf_r+0xf2c>
800087ba:	f2 cb ff fc 	sub	r11,r9,-4
800087be:	51 0b       	stdsp	sp[0x40],r11
800087c0:	fa c6 f9 44 	sub	r6,sp,-1724
800087c4:	72 0b       	ld.w	r11,r9[0x0]
800087c6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087ca:	f3 4b fd 88 	st.w	r9[-632],r11
800087ce:	2f f8       	sub	r8,-1
800087d0:	14 97       	mov	r7,r10
800087d2:	fb 48 06 b4 	st.w	sp[1716],r8
800087d6:	c0 58       	rjmp	800087e0 <_vfprintf_r+0xf34>
800087d8:	72 0b       	ld.w	r11,r9[0x0]
800087da:	14 97       	mov	r7,r10
800087dc:	2f c9       	sub	r9,-4
800087de:	51 09       	stdsp	sp[0x40],r9
800087e0:	50 1b       	stdsp	sp[0x4],r11
800087e2:	30 0e       	mov	lr,0
800087e4:	50 0e       	stdsp	sp[0x0],lr
800087e6:	1c 98       	mov	r8,lr
800087e8:	e0 8f 02 fe 	bral	80008de4 <_vfprintf_r+0x1538>
800087ec:	50 a7       	stdsp	sp[0x28],r7
800087ee:	50 80       	stdsp	sp[0x20],r0
800087f0:	0c 97       	mov	r7,r6
800087f2:	04 94       	mov	r4,r2
800087f4:	06 96       	mov	r6,r3
800087f6:	02 92       	mov	r2,r1
800087f8:	40 93       	lddsp	r3,sp[0x24]
800087fa:	40 41       	lddsp	r1,sp[0x10]
800087fc:	0e 99       	mov	r9,r7
800087fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008802:	40 3c       	lddsp	r12,sp[0xc]
80008804:	58 0c       	cp.w	r12,0
80008806:	c1 d0       	breq	80008840 <_vfprintf_r+0xf94>
80008808:	10 36       	cp.w	r6,r8
8000880a:	c0 64       	brge	80008816 <_vfprintf_r+0xf6a>
8000880c:	fa cb f9 44 	sub	r11,sp,-1724
80008810:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008814:	c1 d8       	rjmp	8000884e <_vfprintf_r+0xfa2>
80008816:	fa c8 f9 50 	sub	r8,sp,-1712
8000881a:	1a d8       	st.w	--sp,r8
8000881c:	fa c8 fa b8 	sub	r8,sp,-1352
80008820:	1a d8       	st.w	--sp,r8
80008822:	fa c8 fb b4 	sub	r8,sp,-1100
80008826:	1a d8       	st.w	--sp,r8
80008828:	fa c9 ff b4 	sub	r9,sp,-76
8000882c:	fa c8 f9 40 	sub	r8,sp,-1728
80008830:	04 9a       	mov	r10,r2
80008832:	0c 9b       	mov	r11,r6
80008834:	08 9c       	mov	r12,r4
80008836:	fe b0 f6 a3 	rcall	8000757c <get_arg>
8000883a:	2f dd       	sub	sp,-12
8000883c:	78 09       	ld.w	r9,r12[0x0]
8000883e:	c2 18       	rjmp	80008880 <_vfprintf_r+0xfd4>
80008840:	2f f7       	sub	r7,-1
80008842:	10 39       	cp.w	r9,r8
80008844:	c0 84       	brge	80008854 <_vfprintf_r+0xfa8>
80008846:	fa ca f9 44 	sub	r10,sp,-1724
8000884a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000884e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008852:	c1 78       	rjmp	80008880 <_vfprintf_r+0xfd4>
80008854:	41 09       	lddsp	r9,sp[0x40]
80008856:	59 f8       	cp.w	r8,31
80008858:	e0 89 00 10 	brgt	80008878 <_vfprintf_r+0xfcc>
8000885c:	f2 ca ff fc 	sub	r10,r9,-4
80008860:	51 0a       	stdsp	sp[0x40],r10
80008862:	fa c6 f9 44 	sub	r6,sp,-1724
80008866:	72 09       	ld.w	r9,r9[0x0]
80008868:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000886c:	f5 49 fd 88 	st.w	r10[-632],r9
80008870:	2f f8       	sub	r8,-1
80008872:	fb 48 06 b4 	st.w	sp[1716],r8
80008876:	c0 58       	rjmp	80008880 <_vfprintf_r+0xfd4>
80008878:	f2 c8 ff fc 	sub	r8,r9,-4
8000887c:	51 08       	stdsp	sp[0x40],r8
8000887e:	72 09       	ld.w	r9,r9[0x0]
80008880:	33 08       	mov	r8,48
80008882:	fb 68 06 b8 	st.b	sp[1720],r8
80008886:	37 88       	mov	r8,120
80008888:	30 0e       	mov	lr,0
8000888a:	fb 68 06 b9 	st.b	sp[1721],r8
8000888e:	fe cc b2 1a 	sub	r12,pc,-19942
80008892:	50 19       	stdsp	sp[0x4],r9
80008894:	a1 b5       	sbr	r5,0x1
80008896:	50 0e       	stdsp	sp[0x0],lr
80008898:	50 dc       	stdsp	sp[0x34],r12
8000889a:	30 28       	mov	r8,2
8000889c:	37 80       	mov	r0,120
8000889e:	e0 8f 02 a3 	bral	80008de4 <_vfprintf_r+0x1538>
800088a2:	50 a7       	stdsp	sp[0x28],r7
800088a4:	50 80       	stdsp	sp[0x20],r0
800088a6:	10 90       	mov	r0,r8
800088a8:	30 08       	mov	r8,0
800088aa:	fb 68 06 bb 	st.b	sp[1723],r8
800088ae:	0c 97       	mov	r7,r6
800088b0:	04 94       	mov	r4,r2
800088b2:	06 96       	mov	r6,r3
800088b4:	02 92       	mov	r2,r1
800088b6:	40 93       	lddsp	r3,sp[0x24]
800088b8:	40 41       	lddsp	r1,sp[0x10]
800088ba:	0e 99       	mov	r9,r7
800088bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088c0:	40 3b       	lddsp	r11,sp[0xc]
800088c2:	58 0b       	cp.w	r11,0
800088c4:	c1 d0       	breq	800088fe <_vfprintf_r+0x1052>
800088c6:	10 36       	cp.w	r6,r8
800088c8:	c0 64       	brge	800088d4 <_vfprintf_r+0x1028>
800088ca:	fa ca f9 44 	sub	r10,sp,-1724
800088ce:	f4 06 00 36 	add	r6,r10,r6<<0x3
800088d2:	c1 d8       	rjmp	8000890c <_vfprintf_r+0x1060>
800088d4:	fa c8 f9 50 	sub	r8,sp,-1712
800088d8:	1a d8       	st.w	--sp,r8
800088da:	fa c8 fa b8 	sub	r8,sp,-1352
800088de:	1a d8       	st.w	--sp,r8
800088e0:	fa c8 fb b4 	sub	r8,sp,-1100
800088e4:	0c 9b       	mov	r11,r6
800088e6:	1a d8       	st.w	--sp,r8
800088e8:	04 9a       	mov	r10,r2
800088ea:	fa c8 f9 40 	sub	r8,sp,-1728
800088ee:	fa c9 ff b4 	sub	r9,sp,-76
800088f2:	08 9c       	mov	r12,r4
800088f4:	fe b0 f6 44 	rcall	8000757c <get_arg>
800088f8:	2f dd       	sub	sp,-12
800088fa:	78 06       	ld.w	r6,r12[0x0]
800088fc:	c2 08       	rjmp	8000893c <_vfprintf_r+0x1090>
800088fe:	2f f7       	sub	r7,-1
80008900:	10 39       	cp.w	r9,r8
80008902:	c0 84       	brge	80008912 <_vfprintf_r+0x1066>
80008904:	fa c9 f9 44 	sub	r9,sp,-1724
80008908:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000890c:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008910:	c1 68       	rjmp	8000893c <_vfprintf_r+0x1090>
80008912:	41 09       	lddsp	r9,sp[0x40]
80008914:	59 f8       	cp.w	r8,31
80008916:	e0 89 00 10 	brgt	80008936 <_vfprintf_r+0x108a>
8000891a:	f2 ca ff fc 	sub	r10,r9,-4
8000891e:	51 0a       	stdsp	sp[0x40],r10
80008920:	72 06       	ld.w	r6,r9[0x0]
80008922:	fa ce f9 44 	sub	lr,sp,-1724
80008926:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000892a:	f3 46 fd 88 	st.w	r9[-632],r6
8000892e:	2f f8       	sub	r8,-1
80008930:	fb 48 06 b4 	st.w	sp[1716],r8
80008934:	c0 48       	rjmp	8000893c <_vfprintf_r+0x1090>
80008936:	72 06       	ld.w	r6,r9[0x0]
80008938:	2f c9       	sub	r9,-4
8000893a:	51 09       	stdsp	sp[0x40],r9
8000893c:	40 2c       	lddsp	r12,sp[0x8]
8000893e:	58 0c       	cp.w	r12,0
80008940:	c1 05       	brlt	80008960 <_vfprintf_r+0x10b4>
80008942:	18 9a       	mov	r10,r12
80008944:	30 0b       	mov	r11,0
80008946:	0c 9c       	mov	r12,r6
80008948:	e0 a0 12 38 	rcall	8000adb8 <memchr>
8000894c:	e0 80 02 df 	breq	80008f0a <_vfprintf_r+0x165e>
80008950:	f8 06 01 02 	sub	r2,r12,r6
80008954:	40 2b       	lddsp	r11,sp[0x8]
80008956:	16 32       	cp.w	r2,r11
80008958:	e0 89 02 d9 	brgt	80008f0a <_vfprintf_r+0x165e>
8000895c:	e0 8f 02 d4 	bral	80008f04 <_vfprintf_r+0x1658>
80008960:	30 0a       	mov	r10,0
80008962:	0c 9c       	mov	r12,r6
80008964:	50 2a       	stdsp	sp[0x8],r10
80008966:	e0 a0 15 99 	rcall	8000b498 <strlen>
8000896a:	18 92       	mov	r2,r12
8000896c:	e0 8f 02 d2 	bral	80008f10 <_vfprintf_r+0x1664>
80008970:	50 a7       	stdsp	sp[0x28],r7
80008972:	50 80       	stdsp	sp[0x20],r0
80008974:	0c 97       	mov	r7,r6
80008976:	04 94       	mov	r4,r2
80008978:	06 96       	mov	r6,r3
8000897a:	02 92       	mov	r2,r1
8000897c:	40 93       	lddsp	r3,sp[0x24]
8000897e:	10 90       	mov	r0,r8
80008980:	40 41       	lddsp	r1,sp[0x10]
80008982:	a5 a5       	sbr	r5,0x4
80008984:	c0 a8       	rjmp	80008998 <_vfprintf_r+0x10ec>
80008986:	50 a7       	stdsp	sp[0x28],r7
80008988:	50 80       	stdsp	sp[0x20],r0
8000898a:	0c 97       	mov	r7,r6
8000898c:	04 94       	mov	r4,r2
8000898e:	06 96       	mov	r6,r3
80008990:	02 92       	mov	r2,r1
80008992:	40 93       	lddsp	r3,sp[0x24]
80008994:	10 90       	mov	r0,r8
80008996:	40 41       	lddsp	r1,sp[0x10]
80008998:	ed b5 00 05 	bld	r5,0x5
8000899c:	c5 61       	brne	80008a48 <_vfprintf_r+0x119c>
8000899e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089a2:	40 39       	lddsp	r9,sp[0xc]
800089a4:	58 09       	cp.w	r9,0
800089a6:	c2 10       	breq	800089e8 <_vfprintf_r+0x113c>
800089a8:	10 36       	cp.w	r6,r8
800089aa:	c0 74       	brge	800089b8 <_vfprintf_r+0x110c>
800089ac:	fa c8 f9 44 	sub	r8,sp,-1724
800089b0:	f0 06 00 36 	add	r6,r8,r6<<0x3
800089b4:	c2 38       	rjmp	800089fa <_vfprintf_r+0x114e>
800089b6:	d7 03       	nop
800089b8:	fa c8 f9 50 	sub	r8,sp,-1712
800089bc:	1a d8       	st.w	--sp,r8
800089be:	fa c8 fa b8 	sub	r8,sp,-1352
800089c2:	1a d8       	st.w	--sp,r8
800089c4:	fa c8 fb b4 	sub	r8,sp,-1100
800089c8:	1a d8       	st.w	--sp,r8
800089ca:	fa c8 f9 40 	sub	r8,sp,-1728
800089ce:	fa c9 ff b4 	sub	r9,sp,-76
800089d2:	04 9a       	mov	r10,r2
800089d4:	0c 9b       	mov	r11,r6
800089d6:	08 9c       	mov	r12,r4
800089d8:	fe b0 f5 d2 	rcall	8000757c <get_arg>
800089dc:	2f dd       	sub	sp,-12
800089de:	f8 e8 00 00 	ld.d	r8,r12[0]
800089e2:	fa e9 00 00 	st.d	sp[0],r8
800089e6:	c2 e8       	rjmp	80008a42 <_vfprintf_r+0x1196>
800089e8:	ee ca ff ff 	sub	r10,r7,-1
800089ec:	10 37       	cp.w	r7,r8
800089ee:	c0 b4       	brge	80008a04 <_vfprintf_r+0x1158>
800089f0:	fa c8 f9 44 	sub	r8,sp,-1724
800089f4:	14 97       	mov	r7,r10
800089f6:	f0 06 00 36 	add	r6,r8,r6<<0x3
800089fa:	ec ea fd 88 	ld.d	r10,r6[-632]
800089fe:	fa eb 00 00 	st.d	sp[0],r10
80008a02:	c2 08       	rjmp	80008a42 <_vfprintf_r+0x1196>
80008a04:	41 09       	lddsp	r9,sp[0x40]
80008a06:	59 f8       	cp.w	r8,31
80008a08:	e0 89 00 16 	brgt	80008a34 <_vfprintf_r+0x1188>
80008a0c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a10:	f2 cb ff f8 	sub	r11,r9,-8
80008a14:	fa e7 00 00 	st.d	sp[0],r6
80008a18:	51 0b       	stdsp	sp[0x40],r11
80008a1a:	fa c6 f9 44 	sub	r6,sp,-1724
80008a1e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a22:	fa e6 00 00 	ld.d	r6,sp[0]
80008a26:	f2 e7 fd 88 	st.d	r9[-632],r6
80008a2a:	2f f8       	sub	r8,-1
80008a2c:	14 97       	mov	r7,r10
80008a2e:	fb 48 06 b4 	st.w	sp[1716],r8
80008a32:	c0 88       	rjmp	80008a42 <_vfprintf_r+0x1196>
80008a34:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a38:	2f 89       	sub	r9,-8
80008a3a:	fa e7 00 00 	st.d	sp[0],r6
80008a3e:	51 09       	stdsp	sp[0x40],r9
80008a40:	14 97       	mov	r7,r10
80008a42:	30 18       	mov	r8,1
80008a44:	e0 8f 01 d0 	bral	80008de4 <_vfprintf_r+0x1538>
80008a48:	ed b5 00 04 	bld	r5,0x4
80008a4c:	c1 61       	brne	80008a78 <_vfprintf_r+0x11cc>
80008a4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a52:	40 3e       	lddsp	lr,sp[0xc]
80008a54:	58 0e       	cp.w	lr,0
80008a56:	c0 80       	breq	80008a66 <_vfprintf_r+0x11ba>
80008a58:	10 36       	cp.w	r6,r8
80008a5a:	c6 74       	brge	80008b28 <_vfprintf_r+0x127c>
80008a5c:	fa cc f9 44 	sub	r12,sp,-1724
80008a60:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a64:	c8 08       	rjmp	80008b64 <_vfprintf_r+0x12b8>
80008a66:	ee ca ff ff 	sub	r10,r7,-1
80008a6a:	10 37       	cp.w	r7,r8
80008a6c:	c7 f4       	brge	80008b6a <_vfprintf_r+0x12be>
80008a6e:	fa cb f9 44 	sub	r11,sp,-1724
80008a72:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a76:	c7 68       	rjmp	80008b62 <_vfprintf_r+0x12b6>
80008a78:	ed b5 00 06 	bld	r5,0x6
80008a7c:	c4 a1       	brne	80008b10 <_vfprintf_r+0x1264>
80008a7e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a82:	40 3c       	lddsp	r12,sp[0xc]
80008a84:	58 0c       	cp.w	r12,0
80008a86:	c1 d0       	breq	80008ac0 <_vfprintf_r+0x1214>
80008a88:	10 36       	cp.w	r6,r8
80008a8a:	c0 64       	brge	80008a96 <_vfprintf_r+0x11ea>
80008a8c:	fa cb f9 44 	sub	r11,sp,-1724
80008a90:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a94:	c1 f8       	rjmp	80008ad2 <_vfprintf_r+0x1226>
80008a96:	fa c8 f9 50 	sub	r8,sp,-1712
80008a9a:	1a d8       	st.w	--sp,r8
80008a9c:	fa c8 fa b8 	sub	r8,sp,-1352
80008aa0:	1a d8       	st.w	--sp,r8
80008aa2:	fa c8 fb b4 	sub	r8,sp,-1100
80008aa6:	1a d8       	st.w	--sp,r8
80008aa8:	fa c8 f9 40 	sub	r8,sp,-1728
80008aac:	fa c9 ff b4 	sub	r9,sp,-76
80008ab0:	04 9a       	mov	r10,r2
80008ab2:	0c 9b       	mov	r11,r6
80008ab4:	08 9c       	mov	r12,r4
80008ab6:	fe b0 f5 63 	rcall	8000757c <get_arg>
80008aba:	2f dd       	sub	sp,-12
80008abc:	98 18       	ld.sh	r8,r12[0x2]
80008abe:	c2 68       	rjmp	80008b0a <_vfprintf_r+0x125e>
80008ac0:	ee ca ff ff 	sub	r10,r7,-1
80008ac4:	10 37       	cp.w	r7,r8
80008ac6:	c0 94       	brge	80008ad8 <_vfprintf_r+0x122c>
80008ac8:	fa c9 f9 44 	sub	r9,sp,-1724
80008acc:	14 97       	mov	r7,r10
80008ace:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ad2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008ad6:	c1 a8       	rjmp	80008b0a <_vfprintf_r+0x125e>
80008ad8:	41 09       	lddsp	r9,sp[0x40]
80008ada:	59 f8       	cp.w	r8,31
80008adc:	e0 89 00 13 	brgt	80008b02 <_vfprintf_r+0x1256>
80008ae0:	f2 cb ff fc 	sub	r11,r9,-4
80008ae4:	51 0b       	stdsp	sp[0x40],r11
80008ae6:	72 09       	ld.w	r9,r9[0x0]
80008ae8:	fa c6 f9 44 	sub	r6,sp,-1724
80008aec:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008af0:	2f f8       	sub	r8,-1
80008af2:	f7 49 fd 88 	st.w	r11[-632],r9
80008af6:	fb 48 06 b4 	st.w	sp[1716],r8
80008afa:	14 97       	mov	r7,r10
80008afc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008b00:	c0 58       	rjmp	80008b0a <_vfprintf_r+0x125e>
80008b02:	92 18       	ld.sh	r8,r9[0x2]
80008b04:	14 97       	mov	r7,r10
80008b06:	2f c9       	sub	r9,-4
80008b08:	51 09       	stdsp	sp[0x40],r9
80008b0a:	5c 78       	castu.h	r8
80008b0c:	50 18       	stdsp	sp[0x4],r8
80008b0e:	c4 68       	rjmp	80008b9a <_vfprintf_r+0x12ee>
80008b10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b14:	40 3c       	lddsp	r12,sp[0xc]
80008b16:	58 0c       	cp.w	r12,0
80008b18:	c1 d0       	breq	80008b52 <_vfprintf_r+0x12a6>
80008b1a:	10 36       	cp.w	r6,r8
80008b1c:	c0 64       	brge	80008b28 <_vfprintf_r+0x127c>
80008b1e:	fa cb f9 44 	sub	r11,sp,-1724
80008b22:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b26:	c1 f8       	rjmp	80008b64 <_vfprintf_r+0x12b8>
80008b28:	fa c8 f9 50 	sub	r8,sp,-1712
80008b2c:	1a d8       	st.w	--sp,r8
80008b2e:	fa c8 fa b8 	sub	r8,sp,-1352
80008b32:	0c 9b       	mov	r11,r6
80008b34:	1a d8       	st.w	--sp,r8
80008b36:	fa c8 fb b4 	sub	r8,sp,-1100
80008b3a:	04 9a       	mov	r10,r2
80008b3c:	1a d8       	st.w	--sp,r8
80008b3e:	08 9c       	mov	r12,r4
80008b40:	fa c8 f9 40 	sub	r8,sp,-1728
80008b44:	fa c9 ff b4 	sub	r9,sp,-76
80008b48:	fe b0 f5 1a 	rcall	8000757c <get_arg>
80008b4c:	2f dd       	sub	sp,-12
80008b4e:	78 0b       	ld.w	r11,r12[0x0]
80008b50:	c2 48       	rjmp	80008b98 <_vfprintf_r+0x12ec>
80008b52:	ee ca ff ff 	sub	r10,r7,-1
80008b56:	10 37       	cp.w	r7,r8
80008b58:	c0 94       	brge	80008b6a <_vfprintf_r+0x12be>
80008b5a:	fa c9 f9 44 	sub	r9,sp,-1724
80008b5e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b62:	14 97       	mov	r7,r10
80008b64:	ec fb fd 88 	ld.w	r11,r6[-632]
80008b68:	c1 88       	rjmp	80008b98 <_vfprintf_r+0x12ec>
80008b6a:	41 09       	lddsp	r9,sp[0x40]
80008b6c:	59 f8       	cp.w	r8,31
80008b6e:	e0 89 00 11 	brgt	80008b90 <_vfprintf_r+0x12e4>
80008b72:	f2 cb ff fc 	sub	r11,r9,-4
80008b76:	51 0b       	stdsp	sp[0x40],r11
80008b78:	fa c6 f9 44 	sub	r6,sp,-1724
80008b7c:	72 0b       	ld.w	r11,r9[0x0]
80008b7e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b82:	f3 4b fd 88 	st.w	r9[-632],r11
80008b86:	2f f8       	sub	r8,-1
80008b88:	14 97       	mov	r7,r10
80008b8a:	fb 48 06 b4 	st.w	sp[1716],r8
80008b8e:	c0 58       	rjmp	80008b98 <_vfprintf_r+0x12ec>
80008b90:	72 0b       	ld.w	r11,r9[0x0]
80008b92:	14 97       	mov	r7,r10
80008b94:	2f c9       	sub	r9,-4
80008b96:	51 09       	stdsp	sp[0x40],r9
80008b98:	50 1b       	stdsp	sp[0x4],r11
80008b9a:	30 0e       	mov	lr,0
80008b9c:	30 18       	mov	r8,1
80008b9e:	50 0e       	stdsp	sp[0x0],lr
80008ba0:	c2 29       	rjmp	80008de4 <_vfprintf_r+0x1538>
80008ba2:	50 a7       	stdsp	sp[0x28],r7
80008ba4:	50 80       	stdsp	sp[0x20],r0
80008ba6:	0c 97       	mov	r7,r6
80008ba8:	04 94       	mov	r4,r2
80008baa:	06 96       	mov	r6,r3
80008bac:	02 92       	mov	r2,r1
80008bae:	fe cc b5 3a 	sub	r12,pc,-19142
80008bb2:	40 93       	lddsp	r3,sp[0x24]
80008bb4:	10 90       	mov	r0,r8
80008bb6:	40 41       	lddsp	r1,sp[0x10]
80008bb8:	50 dc       	stdsp	sp[0x34],r12
80008bba:	ed b5 00 05 	bld	r5,0x5
80008bbe:	c5 51       	brne	80008c68 <_vfprintf_r+0x13bc>
80008bc0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bc4:	40 3b       	lddsp	r11,sp[0xc]
80008bc6:	58 0b       	cp.w	r11,0
80008bc8:	c2 20       	breq	80008c0c <_vfprintf_r+0x1360>
80008bca:	10 36       	cp.w	r6,r8
80008bcc:	c0 a4       	brge	80008be0 <_vfprintf_r+0x1334>
80008bce:	fa ca f9 44 	sub	r10,sp,-1724
80008bd2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008bd6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008bda:	fa e9 00 00 	st.d	sp[0],r8
80008bde:	cf 28       	rjmp	80008dc2 <_vfprintf_r+0x1516>
80008be0:	fa c8 f9 50 	sub	r8,sp,-1712
80008be4:	1a d8       	st.w	--sp,r8
80008be6:	fa c8 fa b8 	sub	r8,sp,-1352
80008bea:	04 9a       	mov	r10,r2
80008bec:	1a d8       	st.w	--sp,r8
80008bee:	0c 9b       	mov	r11,r6
80008bf0:	fa c8 fb b4 	sub	r8,sp,-1100
80008bf4:	08 9c       	mov	r12,r4
80008bf6:	1a d8       	st.w	--sp,r8
80008bf8:	fa c8 f9 40 	sub	r8,sp,-1728
80008bfc:	fa c9 ff b4 	sub	r9,sp,-76
80008c00:	fe b0 f4 be 	rcall	8000757c <get_arg>
80008c04:	2f dd       	sub	sp,-12
80008c06:	f8 ea 00 00 	ld.d	r10,r12[0]
80008c0a:	c0 c8       	rjmp	80008c22 <_vfprintf_r+0x1376>
80008c0c:	ee ca ff ff 	sub	r10,r7,-1
80008c10:	10 37       	cp.w	r7,r8
80008c12:	c0 b4       	brge	80008c28 <_vfprintf_r+0x137c>
80008c14:	fa c9 f9 44 	sub	r9,sp,-1724
80008c18:	14 97       	mov	r7,r10
80008c1a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c1e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c22:	fa eb 00 00 	st.d	sp[0],r10
80008c26:	cc e8       	rjmp	80008dc2 <_vfprintf_r+0x1516>
80008c28:	41 09       	lddsp	r9,sp[0x40]
80008c2a:	59 f8       	cp.w	r8,31
80008c2c:	e0 89 00 16 	brgt	80008c58 <_vfprintf_r+0x13ac>
80008c30:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c34:	f2 cb ff f8 	sub	r11,r9,-8
80008c38:	fa e7 00 00 	st.d	sp[0],r6
80008c3c:	51 0b       	stdsp	sp[0x40],r11
80008c3e:	fa c6 f9 44 	sub	r6,sp,-1724
80008c42:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c46:	fa e6 00 00 	ld.d	r6,sp[0]
80008c4a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c4e:	2f f8       	sub	r8,-1
80008c50:	14 97       	mov	r7,r10
80008c52:	fb 48 06 b4 	st.w	sp[1716],r8
80008c56:	cb 68       	rjmp	80008dc2 <_vfprintf_r+0x1516>
80008c58:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c5c:	2f 89       	sub	r9,-8
80008c5e:	fa e7 00 00 	st.d	sp[0],r6
80008c62:	51 09       	stdsp	sp[0x40],r9
80008c64:	14 97       	mov	r7,r10
80008c66:	ca e8       	rjmp	80008dc2 <_vfprintf_r+0x1516>
80008c68:	ed b5 00 04 	bld	r5,0x4
80008c6c:	c1 71       	brne	80008c9a <_vfprintf_r+0x13ee>
80008c6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c72:	40 3e       	lddsp	lr,sp[0xc]
80008c74:	58 0e       	cp.w	lr,0
80008c76:	c0 80       	breq	80008c86 <_vfprintf_r+0x13da>
80008c78:	10 36       	cp.w	r6,r8
80008c7a:	c6 94       	brge	80008d4c <_vfprintf_r+0x14a0>
80008c7c:	fa cc f9 44 	sub	r12,sp,-1724
80008c80:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c84:	c8 28       	rjmp	80008d88 <_vfprintf_r+0x14dc>
80008c86:	ee ca ff ff 	sub	r10,r7,-1
80008c8a:	10 37       	cp.w	r7,r8
80008c8c:	e0 84 00 81 	brge	80008d8e <_vfprintf_r+0x14e2>
80008c90:	fa cb f9 44 	sub	r11,sp,-1724
80008c94:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c98:	c7 78       	rjmp	80008d86 <_vfprintf_r+0x14da>
80008c9a:	ed b5 00 06 	bld	r5,0x6
80008c9e:	c4 b1       	brne	80008d34 <_vfprintf_r+0x1488>
80008ca0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ca4:	40 3c       	lddsp	r12,sp[0xc]
80008ca6:	58 0c       	cp.w	r12,0
80008ca8:	c1 d0       	breq	80008ce2 <_vfprintf_r+0x1436>
80008caa:	10 36       	cp.w	r6,r8
80008cac:	c0 64       	brge	80008cb8 <_vfprintf_r+0x140c>
80008cae:	fa cb f9 44 	sub	r11,sp,-1724
80008cb2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cb6:	c1 f8       	rjmp	80008cf4 <_vfprintf_r+0x1448>
80008cb8:	fa c8 f9 50 	sub	r8,sp,-1712
80008cbc:	1a d8       	st.w	--sp,r8
80008cbe:	fa c8 fa b8 	sub	r8,sp,-1352
80008cc2:	1a d8       	st.w	--sp,r8
80008cc4:	fa c8 fb b4 	sub	r8,sp,-1100
80008cc8:	1a d8       	st.w	--sp,r8
80008cca:	fa c8 f9 40 	sub	r8,sp,-1728
80008cce:	fa c9 ff b4 	sub	r9,sp,-76
80008cd2:	04 9a       	mov	r10,r2
80008cd4:	0c 9b       	mov	r11,r6
80008cd6:	08 9c       	mov	r12,r4
80008cd8:	fe b0 f4 52 	rcall	8000757c <get_arg>
80008cdc:	2f dd       	sub	sp,-12
80008cde:	98 18       	ld.sh	r8,r12[0x2]
80008ce0:	c2 78       	rjmp	80008d2e <_vfprintf_r+0x1482>
80008ce2:	ee ca ff ff 	sub	r10,r7,-1
80008ce6:	10 37       	cp.w	r7,r8
80008ce8:	c0 a4       	brge	80008cfc <_vfprintf_r+0x1450>
80008cea:	fa c9 f9 44 	sub	r9,sp,-1724
80008cee:	14 97       	mov	r7,r10
80008cf0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008cf4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008cf8:	c1 b8       	rjmp	80008d2e <_vfprintf_r+0x1482>
80008cfa:	d7 03       	nop
80008cfc:	41 09       	lddsp	r9,sp[0x40]
80008cfe:	59 f8       	cp.w	r8,31
80008d00:	e0 89 00 13 	brgt	80008d26 <_vfprintf_r+0x147a>
80008d04:	f2 cb ff fc 	sub	r11,r9,-4
80008d08:	51 0b       	stdsp	sp[0x40],r11
80008d0a:	72 09       	ld.w	r9,r9[0x0]
80008d0c:	fa c6 f9 44 	sub	r6,sp,-1724
80008d10:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d14:	2f f8       	sub	r8,-1
80008d16:	f7 49 fd 88 	st.w	r11[-632],r9
80008d1a:	fb 48 06 b4 	st.w	sp[1716],r8
80008d1e:	14 97       	mov	r7,r10
80008d20:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d24:	c0 58       	rjmp	80008d2e <_vfprintf_r+0x1482>
80008d26:	92 18       	ld.sh	r8,r9[0x2]
80008d28:	14 97       	mov	r7,r10
80008d2a:	2f c9       	sub	r9,-4
80008d2c:	51 09       	stdsp	sp[0x40],r9
80008d2e:	5c 78       	castu.h	r8
80008d30:	50 18       	stdsp	sp[0x4],r8
80008d32:	c4 68       	rjmp	80008dbe <_vfprintf_r+0x1512>
80008d34:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d38:	40 3c       	lddsp	r12,sp[0xc]
80008d3a:	58 0c       	cp.w	r12,0
80008d3c:	c1 d0       	breq	80008d76 <_vfprintf_r+0x14ca>
80008d3e:	10 36       	cp.w	r6,r8
80008d40:	c0 64       	brge	80008d4c <_vfprintf_r+0x14a0>
80008d42:	fa cb f9 44 	sub	r11,sp,-1724
80008d46:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d4a:	c1 f8       	rjmp	80008d88 <_vfprintf_r+0x14dc>
80008d4c:	fa c8 f9 50 	sub	r8,sp,-1712
80008d50:	1a d8       	st.w	--sp,r8
80008d52:	fa c8 fa b8 	sub	r8,sp,-1352
80008d56:	0c 9b       	mov	r11,r6
80008d58:	1a d8       	st.w	--sp,r8
80008d5a:	fa c8 fb b4 	sub	r8,sp,-1100
80008d5e:	04 9a       	mov	r10,r2
80008d60:	1a d8       	st.w	--sp,r8
80008d62:	08 9c       	mov	r12,r4
80008d64:	fa c8 f9 40 	sub	r8,sp,-1728
80008d68:	fa c9 ff b4 	sub	r9,sp,-76
80008d6c:	fe b0 f4 08 	rcall	8000757c <get_arg>
80008d70:	2f dd       	sub	sp,-12
80008d72:	78 0b       	ld.w	r11,r12[0x0]
80008d74:	c2 48       	rjmp	80008dbc <_vfprintf_r+0x1510>
80008d76:	ee ca ff ff 	sub	r10,r7,-1
80008d7a:	10 37       	cp.w	r7,r8
80008d7c:	c0 94       	brge	80008d8e <_vfprintf_r+0x14e2>
80008d7e:	fa c9 f9 44 	sub	r9,sp,-1724
80008d82:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d86:	14 97       	mov	r7,r10
80008d88:	ec fb fd 88 	ld.w	r11,r6[-632]
80008d8c:	c1 88       	rjmp	80008dbc <_vfprintf_r+0x1510>
80008d8e:	41 09       	lddsp	r9,sp[0x40]
80008d90:	59 f8       	cp.w	r8,31
80008d92:	e0 89 00 11 	brgt	80008db4 <_vfprintf_r+0x1508>
80008d96:	f2 cb ff fc 	sub	r11,r9,-4
80008d9a:	51 0b       	stdsp	sp[0x40],r11
80008d9c:	fa c6 f9 44 	sub	r6,sp,-1724
80008da0:	72 0b       	ld.w	r11,r9[0x0]
80008da2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008da6:	f3 4b fd 88 	st.w	r9[-632],r11
80008daa:	2f f8       	sub	r8,-1
80008dac:	14 97       	mov	r7,r10
80008dae:	fb 48 06 b4 	st.w	sp[1716],r8
80008db2:	c0 58       	rjmp	80008dbc <_vfprintf_r+0x1510>
80008db4:	72 0b       	ld.w	r11,r9[0x0]
80008db6:	14 97       	mov	r7,r10
80008db8:	2f c9       	sub	r9,-4
80008dba:	51 09       	stdsp	sp[0x40],r9
80008dbc:	50 1b       	stdsp	sp[0x4],r11
80008dbe:	30 0e       	mov	lr,0
80008dc0:	50 0e       	stdsp	sp[0x0],lr
80008dc2:	40 08       	lddsp	r8,sp[0x0]
80008dc4:	40 1c       	lddsp	r12,sp[0x4]
80008dc6:	18 48       	or	r8,r12
80008dc8:	5f 19       	srne	r9
80008dca:	0a 98       	mov	r8,r5
80008dcc:	eb e9 00 09 	and	r9,r5,r9
80008dd0:	a1 b8       	sbr	r8,0x1
80008dd2:	58 09       	cp.w	r9,0
80008dd4:	c0 70       	breq	80008de2 <_vfprintf_r+0x1536>
80008dd6:	10 95       	mov	r5,r8
80008dd8:	fb 60 06 b9 	st.b	sp[1721],r0
80008ddc:	33 08       	mov	r8,48
80008dde:	fb 68 06 b8 	st.b	sp[1720],r8
80008de2:	30 28       	mov	r8,2
80008de4:	30 09       	mov	r9,0
80008de6:	fb 69 06 bb 	st.b	sp[1723],r9
80008dea:	0a 99       	mov	r9,r5
80008dec:	a7 d9       	cbr	r9,0x7
80008dee:	40 2b       	lddsp	r11,sp[0x8]
80008df0:	40 16       	lddsp	r6,sp[0x4]
80008df2:	58 0b       	cp.w	r11,0
80008df4:	5f 1a       	srne	r10
80008df6:	f2 05 17 40 	movge	r5,r9
80008dfa:	fa c2 f9 78 	sub	r2,sp,-1672
80008dfe:	40 09       	lddsp	r9,sp[0x0]
80008e00:	0c 49       	or	r9,r6
80008e02:	5f 19       	srne	r9
80008e04:	f5 e9 10 09 	or	r9,r10,r9
80008e08:	c5 c0       	breq	80008ec0 <_vfprintf_r+0x1614>
80008e0a:	30 19       	mov	r9,1
80008e0c:	f2 08 18 00 	cp.b	r8,r9
80008e10:	c0 60       	breq	80008e1c <_vfprintf_r+0x1570>
80008e12:	30 29       	mov	r9,2
80008e14:	f2 08 18 00 	cp.b	r8,r9
80008e18:	c0 41       	brne	80008e20 <_vfprintf_r+0x1574>
80008e1a:	c3 c8       	rjmp	80008e92 <_vfprintf_r+0x15e6>
80008e1c:	04 96       	mov	r6,r2
80008e1e:	c3 08       	rjmp	80008e7e <_vfprintf_r+0x15d2>
80008e20:	04 96       	mov	r6,r2
80008e22:	fa e8 00 00 	ld.d	r8,sp[0]
80008e26:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008e2a:	2d 0a       	sub	r10,-48
80008e2c:	0c fa       	st.b	--r6,r10
80008e2e:	f0 0b 16 03 	lsr	r11,r8,0x3
80008e32:	f2 0c 16 03 	lsr	r12,r9,0x3
80008e36:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008e3a:	18 99       	mov	r9,r12
80008e3c:	16 98       	mov	r8,r11
80008e3e:	58 08       	cp.w	r8,0
80008e40:	5c 29       	cpc	r9
80008e42:	cf 21       	brne	80008e26 <_vfprintf_r+0x157a>
80008e44:	fa e9 00 00 	st.d	sp[0],r8
80008e48:	ed b5 00 00 	bld	r5,0x0
80008e4c:	c4 51       	brne	80008ed6 <_vfprintf_r+0x162a>
80008e4e:	33 09       	mov	r9,48
80008e50:	f2 0a 18 00 	cp.b	r10,r9
80008e54:	c4 10       	breq	80008ed6 <_vfprintf_r+0x162a>
80008e56:	0c f9       	st.b	--r6,r9
80008e58:	c3 f8       	rjmp	80008ed6 <_vfprintf_r+0x162a>
80008e5a:	fa ea 00 00 	ld.d	r10,sp[0]
80008e5e:	30 a8       	mov	r8,10
80008e60:	30 09       	mov	r9,0
80008e62:	e0 a0 1a 19 	rcall	8000c294 <__avr32_umod64>
80008e66:	30 a8       	mov	r8,10
80008e68:	2d 0a       	sub	r10,-48
80008e6a:	30 09       	mov	r9,0
80008e6c:	ac 8a       	st.b	r6[0x0],r10
80008e6e:	fa ea 00 00 	ld.d	r10,sp[0]
80008e72:	e0 a0 18 df 	rcall	8000c030 <__avr32_udiv64>
80008e76:	16 99       	mov	r9,r11
80008e78:	14 98       	mov	r8,r10
80008e7a:	fa e9 00 00 	st.d	sp[0],r8
80008e7e:	20 16       	sub	r6,1
80008e80:	fa ea 00 00 	ld.d	r10,sp[0]
80008e84:	58 9a       	cp.w	r10,9
80008e86:	5c 2b       	cpc	r11
80008e88:	fe 9b ff e9 	brhi	80008e5a <_vfprintf_r+0x15ae>
80008e8c:	1b f8       	ld.ub	r8,sp[0x7]
80008e8e:	2d 08       	sub	r8,-48
80008e90:	c2 08       	rjmp	80008ed0 <_vfprintf_r+0x1624>
80008e92:	04 96       	mov	r6,r2
80008e94:	fa e8 00 00 	ld.d	r8,sp[0]
80008e98:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008e9c:	40 de       	lddsp	lr,sp[0x34]
80008e9e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008ea2:	0c fa       	st.b	--r6,r10
80008ea4:	f2 0b 16 04 	lsr	r11,r9,0x4
80008ea8:	f0 0a 16 04 	lsr	r10,r8,0x4
80008eac:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008eb0:	16 99       	mov	r9,r11
80008eb2:	14 98       	mov	r8,r10
80008eb4:	58 08       	cp.w	r8,0
80008eb6:	5c 29       	cpc	r9
80008eb8:	cf 01       	brne	80008e98 <_vfprintf_r+0x15ec>
80008eba:	fa e9 00 00 	st.d	sp[0],r8
80008ebe:	c0 c8       	rjmp	80008ed6 <_vfprintf_r+0x162a>
80008ec0:	58 08       	cp.w	r8,0
80008ec2:	c0 91       	brne	80008ed4 <_vfprintf_r+0x1628>
80008ec4:	ed b5 00 00 	bld	r5,0x0
80008ec8:	c0 61       	brne	80008ed4 <_vfprintf_r+0x1628>
80008eca:	fa c6 f9 79 	sub	r6,sp,-1671
80008ece:	33 08       	mov	r8,48
80008ed0:	ac 88       	st.b	r6[0x0],r8
80008ed2:	c0 28       	rjmp	80008ed6 <_vfprintf_r+0x162a>
80008ed4:	04 96       	mov	r6,r2
80008ed6:	0c 12       	sub	r2,r6
80008ed8:	c1 c8       	rjmp	80008f10 <_vfprintf_r+0x1664>
80008eda:	50 a7       	stdsp	sp[0x28],r7
80008edc:	50 80       	stdsp	sp[0x20],r0
80008ede:	40 93       	lddsp	r3,sp[0x24]
80008ee0:	0c 97       	mov	r7,r6
80008ee2:	10 90       	mov	r0,r8
80008ee4:	04 94       	mov	r4,r2
80008ee6:	40 41       	lddsp	r1,sp[0x10]
80008ee8:	58 08       	cp.w	r8,0
80008eea:	e0 80 04 4f 	breq	80009788 <_vfprintf_r+0x1edc>
80008eee:	fb 68 06 60 	st.b	sp[1632],r8
80008ef2:	30 0c       	mov	r12,0
80008ef4:	30 08       	mov	r8,0
80008ef6:	30 12       	mov	r2,1
80008ef8:	fb 68 06 bb 	st.b	sp[1723],r8
80008efc:	50 2c       	stdsp	sp[0x8],r12
80008efe:	fa c6 f9 a0 	sub	r6,sp,-1632
80008f02:	c0 78       	rjmp	80008f10 <_vfprintf_r+0x1664>
80008f04:	30 0b       	mov	r11,0
80008f06:	50 2b       	stdsp	sp[0x8],r11
80008f08:	c0 48       	rjmp	80008f10 <_vfprintf_r+0x1664>
80008f0a:	40 22       	lddsp	r2,sp[0x8]
80008f0c:	30 0a       	mov	r10,0
80008f0e:	50 2a       	stdsp	sp[0x8],r10
80008f10:	40 29       	lddsp	r9,sp[0x8]
80008f12:	e4 09 0c 49 	max	r9,r2,r9
80008f16:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008f1a:	50 39       	stdsp	sp[0xc],r9
80008f1c:	0a 9e       	mov	lr,r5
80008f1e:	30 09       	mov	r9,0
80008f20:	e2 1e 00 02 	andl	lr,0x2,COH
80008f24:	f2 08 18 00 	cp.b	r8,r9
80008f28:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008f2c:	f7 b8 01 ff 	subne	r8,-1
80008f30:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008f34:	0a 9b       	mov	r11,r5
80008f36:	58 0e       	cp.w	lr,0
80008f38:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008f3c:	f7 bc 01 fe 	subne	r12,-2
80008f40:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008f44:	e2 1b 00 84 	andl	r11,0x84,COH
80008f48:	50 fe       	stdsp	sp[0x3c],lr
80008f4a:	50 9b       	stdsp	sp[0x24],r11
80008f4c:	c4 71       	brne	80008fda <_vfprintf_r+0x172e>
80008f4e:	40 8a       	lddsp	r10,sp[0x20]
80008f50:	40 39       	lddsp	r9,sp[0xc]
80008f52:	12 1a       	sub	r10,r9
80008f54:	50 4a       	stdsp	sp[0x10],r10
80008f56:	58 0a       	cp.w	r10,0
80008f58:	e0 89 00 20 	brgt	80008f98 <_vfprintf_r+0x16ec>
80008f5c:	c3 f8       	rjmp	80008fda <_vfprintf_r+0x172e>
80008f5e:	2f 09       	sub	r9,-16
80008f60:	2f f8       	sub	r8,-1
80008f62:	fe ce b8 d6 	sub	lr,pc,-18218
80008f66:	31 0c       	mov	r12,16
80008f68:	fb 49 06 90 	st.w	sp[1680],r9
80008f6c:	87 0e       	st.w	r3[0x0],lr
80008f6e:	87 1c       	st.w	r3[0x4],r12
80008f70:	fb 48 06 8c 	st.w	sp[1676],r8
80008f74:	58 78       	cp.w	r8,7
80008f76:	e0 89 00 04 	brgt	80008f7e <_vfprintf_r+0x16d2>
80008f7a:	2f 83       	sub	r3,-8
80008f7c:	c0 b8       	rjmp	80008f92 <_vfprintf_r+0x16e6>
80008f7e:	fa ca f9 78 	sub	r10,sp,-1672
80008f82:	02 9b       	mov	r11,r1
80008f84:	08 9c       	mov	r12,r4
80008f86:	fe b0 f4 85 	rcall	80007890 <__sprint_r>
80008f8a:	e0 81 04 10 	brne	800097aa <_vfprintf_r+0x1efe>
80008f8e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f92:	40 4b       	lddsp	r11,sp[0x10]
80008f94:	21 0b       	sub	r11,16
80008f96:	50 4b       	stdsp	sp[0x10],r11
80008f98:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fa0:	fe ca b9 14 	sub	r10,pc,-18156
80008fa4:	40 4e       	lddsp	lr,sp[0x10]
80008fa6:	59 0e       	cp.w	lr,16
80008fa8:	fe 99 ff db 	brgt	80008f5e <_vfprintf_r+0x16b2>
80008fac:	1c 09       	add	r9,lr
80008fae:	2f f8       	sub	r8,-1
80008fb0:	87 0a       	st.w	r3[0x0],r10
80008fb2:	fb 49 06 90 	st.w	sp[1680],r9
80008fb6:	87 1e       	st.w	r3[0x4],lr
80008fb8:	fb 48 06 8c 	st.w	sp[1676],r8
80008fbc:	58 78       	cp.w	r8,7
80008fbe:	e0 89 00 04 	brgt	80008fc6 <_vfprintf_r+0x171a>
80008fc2:	2f 83       	sub	r3,-8
80008fc4:	c0 b8       	rjmp	80008fda <_vfprintf_r+0x172e>
80008fc6:	fa ca f9 78 	sub	r10,sp,-1672
80008fca:	02 9b       	mov	r11,r1
80008fcc:	08 9c       	mov	r12,r4
80008fce:	fe b0 f4 61 	rcall	80007890 <__sprint_r>
80008fd2:	e0 81 03 ec 	brne	800097aa <_vfprintf_r+0x1efe>
80008fd6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fda:	30 09       	mov	r9,0
80008fdc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008fe0:	f2 08 18 00 	cp.b	r8,r9
80008fe4:	c1 f0       	breq	80009022 <_vfprintf_r+0x1776>
80008fe6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fea:	fa c9 f9 45 	sub	r9,sp,-1723
80008fee:	2f f8       	sub	r8,-1
80008ff0:	87 09       	st.w	r3[0x0],r9
80008ff2:	fb 48 06 90 	st.w	sp[1680],r8
80008ff6:	30 19       	mov	r9,1
80008ff8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ffc:	87 19       	st.w	r3[0x4],r9
80008ffe:	2f f8       	sub	r8,-1
80009000:	fb 48 06 8c 	st.w	sp[1676],r8
80009004:	58 78       	cp.w	r8,7
80009006:	e0 89 00 04 	brgt	8000900e <_vfprintf_r+0x1762>
8000900a:	2f 83       	sub	r3,-8
8000900c:	c0 b8       	rjmp	80009022 <_vfprintf_r+0x1776>
8000900e:	fa ca f9 78 	sub	r10,sp,-1672
80009012:	02 9b       	mov	r11,r1
80009014:	08 9c       	mov	r12,r4
80009016:	fe b0 f4 3d 	rcall	80007890 <__sprint_r>
8000901a:	e0 81 03 c8 	brne	800097aa <_vfprintf_r+0x1efe>
8000901e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009022:	40 fc       	lddsp	r12,sp[0x3c]
80009024:	58 0c       	cp.w	r12,0
80009026:	c1 f0       	breq	80009064 <_vfprintf_r+0x17b8>
80009028:	fa f8 06 90 	ld.w	r8,sp[1680]
8000902c:	fa c9 f9 48 	sub	r9,sp,-1720
80009030:	2f e8       	sub	r8,-2
80009032:	87 09       	st.w	r3[0x0],r9
80009034:	fb 48 06 90 	st.w	sp[1680],r8
80009038:	30 29       	mov	r9,2
8000903a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000903e:	87 19       	st.w	r3[0x4],r9
80009040:	2f f8       	sub	r8,-1
80009042:	fb 48 06 8c 	st.w	sp[1676],r8
80009046:	58 78       	cp.w	r8,7
80009048:	e0 89 00 04 	brgt	80009050 <_vfprintf_r+0x17a4>
8000904c:	2f 83       	sub	r3,-8
8000904e:	c0 b8       	rjmp	80009064 <_vfprintf_r+0x17b8>
80009050:	fa ca f9 78 	sub	r10,sp,-1672
80009054:	02 9b       	mov	r11,r1
80009056:	08 9c       	mov	r12,r4
80009058:	fe b0 f4 1c 	rcall	80007890 <__sprint_r>
8000905c:	e0 81 03 a7 	brne	800097aa <_vfprintf_r+0x1efe>
80009060:	fa c3 f9 e0 	sub	r3,sp,-1568
80009064:	40 9b       	lddsp	r11,sp[0x24]
80009066:	e0 4b 00 80 	cp.w	r11,128
8000906a:	c4 71       	brne	800090f8 <_vfprintf_r+0x184c>
8000906c:	40 8a       	lddsp	r10,sp[0x20]
8000906e:	40 39       	lddsp	r9,sp[0xc]
80009070:	12 1a       	sub	r10,r9
80009072:	50 4a       	stdsp	sp[0x10],r10
80009074:	58 0a       	cp.w	r10,0
80009076:	e0 89 00 20 	brgt	800090b6 <_vfprintf_r+0x180a>
8000907a:	c3 f8       	rjmp	800090f8 <_vfprintf_r+0x184c>
8000907c:	2f 09       	sub	r9,-16
8000907e:	2f f8       	sub	r8,-1
80009080:	fe ce b9 e4 	sub	lr,pc,-17948
80009084:	31 0c       	mov	r12,16
80009086:	fb 49 06 90 	st.w	sp[1680],r9
8000908a:	87 0e       	st.w	r3[0x0],lr
8000908c:	87 1c       	st.w	r3[0x4],r12
8000908e:	fb 48 06 8c 	st.w	sp[1676],r8
80009092:	58 78       	cp.w	r8,7
80009094:	e0 89 00 04 	brgt	8000909c <_vfprintf_r+0x17f0>
80009098:	2f 83       	sub	r3,-8
8000909a:	c0 b8       	rjmp	800090b0 <_vfprintf_r+0x1804>
8000909c:	fa ca f9 78 	sub	r10,sp,-1672
800090a0:	02 9b       	mov	r11,r1
800090a2:	08 9c       	mov	r12,r4
800090a4:	fe b0 f3 f6 	rcall	80007890 <__sprint_r>
800090a8:	e0 81 03 81 	brne	800097aa <_vfprintf_r+0x1efe>
800090ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800090b0:	40 4b       	lddsp	r11,sp[0x10]
800090b2:	21 0b       	sub	r11,16
800090b4:	50 4b       	stdsp	sp[0x10],r11
800090b6:	fa f9 06 90 	ld.w	r9,sp[1680]
800090ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090be:	fe ca ba 22 	sub	r10,pc,-17886
800090c2:	40 4e       	lddsp	lr,sp[0x10]
800090c4:	59 0e       	cp.w	lr,16
800090c6:	fe 99 ff db 	brgt	8000907c <_vfprintf_r+0x17d0>
800090ca:	1c 09       	add	r9,lr
800090cc:	2f f8       	sub	r8,-1
800090ce:	87 0a       	st.w	r3[0x0],r10
800090d0:	fb 49 06 90 	st.w	sp[1680],r9
800090d4:	87 1e       	st.w	r3[0x4],lr
800090d6:	fb 48 06 8c 	st.w	sp[1676],r8
800090da:	58 78       	cp.w	r8,7
800090dc:	e0 89 00 04 	brgt	800090e4 <_vfprintf_r+0x1838>
800090e0:	2f 83       	sub	r3,-8
800090e2:	c0 b8       	rjmp	800090f8 <_vfprintf_r+0x184c>
800090e4:	fa ca f9 78 	sub	r10,sp,-1672
800090e8:	02 9b       	mov	r11,r1
800090ea:	08 9c       	mov	r12,r4
800090ec:	fe b0 f3 d2 	rcall	80007890 <__sprint_r>
800090f0:	e0 81 03 5d 	brne	800097aa <_vfprintf_r+0x1efe>
800090f4:	fa c3 f9 e0 	sub	r3,sp,-1568
800090f8:	40 2c       	lddsp	r12,sp[0x8]
800090fa:	04 1c       	sub	r12,r2
800090fc:	50 2c       	stdsp	sp[0x8],r12
800090fe:	58 0c       	cp.w	r12,0
80009100:	e0 89 00 20 	brgt	80009140 <_vfprintf_r+0x1894>
80009104:	c3 f8       	rjmp	80009182 <_vfprintf_r+0x18d6>
80009106:	2f 09       	sub	r9,-16
80009108:	2f f8       	sub	r8,-1
8000910a:	fe cb ba 6e 	sub	r11,pc,-17810
8000910e:	31 0a       	mov	r10,16
80009110:	fb 49 06 90 	st.w	sp[1680],r9
80009114:	87 0b       	st.w	r3[0x0],r11
80009116:	87 1a       	st.w	r3[0x4],r10
80009118:	fb 48 06 8c 	st.w	sp[1676],r8
8000911c:	58 78       	cp.w	r8,7
8000911e:	e0 89 00 04 	brgt	80009126 <_vfprintf_r+0x187a>
80009122:	2f 83       	sub	r3,-8
80009124:	c0 b8       	rjmp	8000913a <_vfprintf_r+0x188e>
80009126:	fa ca f9 78 	sub	r10,sp,-1672
8000912a:	02 9b       	mov	r11,r1
8000912c:	08 9c       	mov	r12,r4
8000912e:	fe b0 f3 b1 	rcall	80007890 <__sprint_r>
80009132:	e0 81 03 3c 	brne	800097aa <_vfprintf_r+0x1efe>
80009136:	fa c3 f9 e0 	sub	r3,sp,-1568
8000913a:	40 29       	lddsp	r9,sp[0x8]
8000913c:	21 09       	sub	r9,16
8000913e:	50 29       	stdsp	sp[0x8],r9
80009140:	fa f9 06 90 	ld.w	r9,sp[1680]
80009144:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009148:	fe ca ba ac 	sub	r10,pc,-17748
8000914c:	40 2e       	lddsp	lr,sp[0x8]
8000914e:	59 0e       	cp.w	lr,16
80009150:	fe 99 ff db 	brgt	80009106 <_vfprintf_r+0x185a>
80009154:	1c 09       	add	r9,lr
80009156:	2f f8       	sub	r8,-1
80009158:	87 0a       	st.w	r3[0x0],r10
8000915a:	fb 49 06 90 	st.w	sp[1680],r9
8000915e:	87 1e       	st.w	r3[0x4],lr
80009160:	fb 48 06 8c 	st.w	sp[1676],r8
80009164:	58 78       	cp.w	r8,7
80009166:	e0 89 00 04 	brgt	8000916e <_vfprintf_r+0x18c2>
8000916a:	2f 83       	sub	r3,-8
8000916c:	c0 b8       	rjmp	80009182 <_vfprintf_r+0x18d6>
8000916e:	fa ca f9 78 	sub	r10,sp,-1672
80009172:	02 9b       	mov	r11,r1
80009174:	08 9c       	mov	r12,r4
80009176:	fe b0 f3 8d 	rcall	80007890 <__sprint_r>
8000917a:	e0 81 03 18 	brne	800097aa <_vfprintf_r+0x1efe>
8000917e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009182:	ed b5 00 08 	bld	r5,0x8
80009186:	c0 b0       	breq	8000919c <_vfprintf_r+0x18f0>
80009188:	fa f8 06 90 	ld.w	r8,sp[1680]
8000918c:	87 12       	st.w	r3[0x4],r2
8000918e:	87 06       	st.w	r3[0x0],r6
80009190:	f0 02 00 02 	add	r2,r8,r2
80009194:	fb 42 06 90 	st.w	sp[1680],r2
80009198:	e0 8f 01 d4 	bral	80009540 <_vfprintf_r+0x1c94>
8000919c:	e0 40 00 65 	cp.w	r0,101
800091a0:	e0 8a 01 d6 	brle	8000954c <_vfprintf_r+0x1ca0>
800091a4:	30 08       	mov	r8,0
800091a6:	30 09       	mov	r9,0
800091a8:	40 5b       	lddsp	r11,sp[0x14]
800091aa:	40 7a       	lddsp	r10,sp[0x1c]
800091ac:	e0 a0 15 3b 	rcall	8000bc22 <__avr32_f64_cmp_eq>
800091b0:	c7 90       	breq	800092a2 <_vfprintf_r+0x19f6>
800091b2:	fa f8 06 90 	ld.w	r8,sp[1680]
800091b6:	fe c9 bb 2e 	sub	r9,pc,-17618
800091ba:	2f f8       	sub	r8,-1
800091bc:	87 09       	st.w	r3[0x0],r9
800091be:	fb 48 06 90 	st.w	sp[1680],r8
800091c2:	30 19       	mov	r9,1
800091c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091c8:	87 19       	st.w	r3[0x4],r9
800091ca:	2f f8       	sub	r8,-1
800091cc:	fb 48 06 8c 	st.w	sp[1676],r8
800091d0:	58 78       	cp.w	r8,7
800091d2:	e0 89 00 05 	brgt	800091dc <_vfprintf_r+0x1930>
800091d6:	2f 83       	sub	r3,-8
800091d8:	c0 c8       	rjmp	800091f0 <_vfprintf_r+0x1944>
800091da:	d7 03       	nop
800091dc:	fa ca f9 78 	sub	r10,sp,-1672
800091e0:	02 9b       	mov	r11,r1
800091e2:	08 9c       	mov	r12,r4
800091e4:	fe b0 f3 56 	rcall	80007890 <__sprint_r>
800091e8:	e0 81 02 e1 	brne	800097aa <_vfprintf_r+0x1efe>
800091ec:	fa c3 f9 e0 	sub	r3,sp,-1568
800091f0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800091f4:	40 6c       	lddsp	r12,sp[0x18]
800091f6:	18 38       	cp.w	r8,r12
800091f8:	c0 55       	brlt	80009202 <_vfprintf_r+0x1956>
800091fa:	ed b5 00 00 	bld	r5,0x0
800091fe:	e0 81 02 6b 	brne	800096d4 <_vfprintf_r+0x1e28>
80009202:	fa f8 06 90 	ld.w	r8,sp[1680]
80009206:	2f f8       	sub	r8,-1
80009208:	40 cb       	lddsp	r11,sp[0x30]
8000920a:	fb 48 06 90 	st.w	sp[1680],r8
8000920e:	30 19       	mov	r9,1
80009210:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009214:	87 0b       	st.w	r3[0x0],r11
80009216:	2f f8       	sub	r8,-1
80009218:	87 19       	st.w	r3[0x4],r9
8000921a:	fb 48 06 8c 	st.w	sp[1676],r8
8000921e:	58 78       	cp.w	r8,7
80009220:	e0 89 00 04 	brgt	80009228 <_vfprintf_r+0x197c>
80009224:	2f 83       	sub	r3,-8
80009226:	c0 b8       	rjmp	8000923c <_vfprintf_r+0x1990>
80009228:	fa ca f9 78 	sub	r10,sp,-1672
8000922c:	02 9b       	mov	r11,r1
8000922e:	08 9c       	mov	r12,r4
80009230:	fe b0 f3 30 	rcall	80007890 <__sprint_r>
80009234:	e0 81 02 bb 	brne	800097aa <_vfprintf_r+0x1efe>
80009238:	fa c3 f9 e0 	sub	r3,sp,-1568
8000923c:	40 66       	lddsp	r6,sp[0x18]
8000923e:	20 16       	sub	r6,1
80009240:	58 06       	cp.w	r6,0
80009242:	e0 89 00 1d 	brgt	8000927c <_vfprintf_r+0x19d0>
80009246:	e0 8f 02 47 	bral	800096d4 <_vfprintf_r+0x1e28>
8000924a:	2f 09       	sub	r9,-16
8000924c:	2f f8       	sub	r8,-1
8000924e:	fb 49 06 90 	st.w	sp[1680],r9
80009252:	87 02       	st.w	r3[0x0],r2
80009254:	87 10       	st.w	r3[0x4],r0
80009256:	fb 48 06 8c 	st.w	sp[1676],r8
8000925a:	58 78       	cp.w	r8,7
8000925c:	e0 89 00 04 	brgt	80009264 <_vfprintf_r+0x19b8>
80009260:	2f 83       	sub	r3,-8
80009262:	c0 b8       	rjmp	80009278 <_vfprintf_r+0x19cc>
80009264:	fa ca f9 78 	sub	r10,sp,-1672
80009268:	02 9b       	mov	r11,r1
8000926a:	08 9c       	mov	r12,r4
8000926c:	fe b0 f3 12 	rcall	80007890 <__sprint_r>
80009270:	e0 81 02 9d 	brne	800097aa <_vfprintf_r+0x1efe>
80009274:	fa c3 f9 e0 	sub	r3,sp,-1568
80009278:	21 06       	sub	r6,16
8000927a:	c0 48       	rjmp	80009282 <_vfprintf_r+0x19d6>
8000927c:	fe c2 bb e0 	sub	r2,pc,-17440
80009280:	31 00       	mov	r0,16
80009282:	fa f9 06 90 	ld.w	r9,sp[1680]
80009286:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000928a:	fe ca bb ee 	sub	r10,pc,-17426
8000928e:	59 06       	cp.w	r6,16
80009290:	fe 99 ff dd 	brgt	8000924a <_vfprintf_r+0x199e>
80009294:	0c 09       	add	r9,r6
80009296:	87 0a       	st.w	r3[0x0],r10
80009298:	fb 49 06 90 	st.w	sp[1680],r9
8000929c:	2f f8       	sub	r8,-1
8000929e:	87 16       	st.w	r3[0x4],r6
800092a0:	c5 39       	rjmp	80009546 <_vfprintf_r+0x1c9a>
800092a2:	fa fa 06 ac 	ld.w	r10,sp[1708]
800092a6:	58 0a       	cp.w	r10,0
800092a8:	e0 89 00 92 	brgt	800093cc <_vfprintf_r+0x1b20>
800092ac:	fa f8 06 90 	ld.w	r8,sp[1680]
800092b0:	fe c9 bc 28 	sub	r9,pc,-17368
800092b4:	2f f8       	sub	r8,-1
800092b6:	87 09       	st.w	r3[0x0],r9
800092b8:	fb 48 06 90 	st.w	sp[1680],r8
800092bc:	30 19       	mov	r9,1
800092be:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092c2:	87 19       	st.w	r3[0x4],r9
800092c4:	2f f8       	sub	r8,-1
800092c6:	fb 48 06 8c 	st.w	sp[1676],r8
800092ca:	58 78       	cp.w	r8,7
800092cc:	e0 89 00 04 	brgt	800092d4 <_vfprintf_r+0x1a28>
800092d0:	2f 83       	sub	r3,-8
800092d2:	c0 b8       	rjmp	800092e8 <_vfprintf_r+0x1a3c>
800092d4:	fa ca f9 78 	sub	r10,sp,-1672
800092d8:	02 9b       	mov	r11,r1
800092da:	08 9c       	mov	r12,r4
800092dc:	fe b0 f2 da 	rcall	80007890 <__sprint_r>
800092e0:	e0 81 02 65 	brne	800097aa <_vfprintf_r+0x1efe>
800092e4:	fa c3 f9 e0 	sub	r3,sp,-1568
800092e8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800092ec:	58 08       	cp.w	r8,0
800092ee:	c0 81       	brne	800092fe <_vfprintf_r+0x1a52>
800092f0:	40 6a       	lddsp	r10,sp[0x18]
800092f2:	58 0a       	cp.w	r10,0
800092f4:	c0 51       	brne	800092fe <_vfprintf_r+0x1a52>
800092f6:	ed b5 00 00 	bld	r5,0x0
800092fa:	e0 81 01 ed 	brne	800096d4 <_vfprintf_r+0x1e28>
800092fe:	40 c9       	lddsp	r9,sp[0x30]
80009300:	fa f8 06 90 	ld.w	r8,sp[1680]
80009304:	2f f8       	sub	r8,-1
80009306:	87 09       	st.w	r3[0x0],r9
80009308:	fb 48 06 90 	st.w	sp[1680],r8
8000930c:	30 19       	mov	r9,1
8000930e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009312:	87 19       	st.w	r3[0x4],r9
80009314:	2f f8       	sub	r8,-1
80009316:	fb 48 06 8c 	st.w	sp[1676],r8
8000931a:	58 78       	cp.w	r8,7
8000931c:	e0 89 00 04 	brgt	80009324 <_vfprintf_r+0x1a78>
80009320:	2f 83       	sub	r3,-8
80009322:	c0 b8       	rjmp	80009338 <_vfprintf_r+0x1a8c>
80009324:	fa ca f9 78 	sub	r10,sp,-1672
80009328:	02 9b       	mov	r11,r1
8000932a:	08 9c       	mov	r12,r4
8000932c:	fe b0 f2 b2 	rcall	80007890 <__sprint_r>
80009330:	e0 81 02 3d 	brne	800097aa <_vfprintf_r+0x1efe>
80009334:	fa c3 f9 e0 	sub	r3,sp,-1568
80009338:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000933c:	5c 32       	neg	r2
8000933e:	58 02       	cp.w	r2,0
80009340:	e0 89 00 1d 	brgt	8000937a <_vfprintf_r+0x1ace>
80009344:	c3 d8       	rjmp	800093be <_vfprintf_r+0x1b12>
80009346:	2f 09       	sub	r9,-16
80009348:	2f f8       	sub	r8,-1
8000934a:	31 0e       	mov	lr,16
8000934c:	fb 49 06 90 	st.w	sp[1680],r9
80009350:	87 00       	st.w	r3[0x0],r0
80009352:	87 1e       	st.w	r3[0x4],lr
80009354:	fb 48 06 8c 	st.w	sp[1676],r8
80009358:	58 78       	cp.w	r8,7
8000935a:	e0 89 00 04 	brgt	80009362 <_vfprintf_r+0x1ab6>
8000935e:	2f 83       	sub	r3,-8
80009360:	c0 b8       	rjmp	80009376 <_vfprintf_r+0x1aca>
80009362:	fa ca f9 78 	sub	r10,sp,-1672
80009366:	02 9b       	mov	r11,r1
80009368:	08 9c       	mov	r12,r4
8000936a:	fe b0 f2 93 	rcall	80007890 <__sprint_r>
8000936e:	e0 81 02 1e 	brne	800097aa <_vfprintf_r+0x1efe>
80009372:	fa c3 f9 e0 	sub	r3,sp,-1568
80009376:	21 02       	sub	r2,16
80009378:	c0 38       	rjmp	8000937e <_vfprintf_r+0x1ad2>
8000937a:	fe c0 bc de 	sub	r0,pc,-17186
8000937e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009382:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009386:	fe ca bc ea 	sub	r10,pc,-17174
8000938a:	59 02       	cp.w	r2,16
8000938c:	fe 99 ff dd 	brgt	80009346 <_vfprintf_r+0x1a9a>
80009390:	04 09       	add	r9,r2
80009392:	2f f8       	sub	r8,-1
80009394:	87 0a       	st.w	r3[0x0],r10
80009396:	fb 49 06 90 	st.w	sp[1680],r9
8000939a:	87 12       	st.w	r3[0x4],r2
8000939c:	fb 48 06 8c 	st.w	sp[1676],r8
800093a0:	58 78       	cp.w	r8,7
800093a2:	e0 89 00 04 	brgt	800093aa <_vfprintf_r+0x1afe>
800093a6:	2f 83       	sub	r3,-8
800093a8:	c0 b8       	rjmp	800093be <_vfprintf_r+0x1b12>
800093aa:	fa ca f9 78 	sub	r10,sp,-1672
800093ae:	02 9b       	mov	r11,r1
800093b0:	08 9c       	mov	r12,r4
800093b2:	fe b0 f2 6f 	rcall	80007890 <__sprint_r>
800093b6:	e0 81 01 fa 	brne	800097aa <_vfprintf_r+0x1efe>
800093ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800093be:	40 6c       	lddsp	r12,sp[0x18]
800093c0:	fa f8 06 90 	ld.w	r8,sp[1680]
800093c4:	87 06       	st.w	r3[0x0],r6
800093c6:	87 1c       	st.w	r3[0x4],r12
800093c8:	18 08       	add	r8,r12
800093ca:	cb 98       	rjmp	8000953c <_vfprintf_r+0x1c90>
800093cc:	fa f9 06 90 	ld.w	r9,sp[1680]
800093d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093d4:	40 6b       	lddsp	r11,sp[0x18]
800093d6:	16 3a       	cp.w	r10,r11
800093d8:	c6 f5       	brlt	800094b6 <_vfprintf_r+0x1c0a>
800093da:	16 09       	add	r9,r11
800093dc:	2f f8       	sub	r8,-1
800093de:	87 06       	st.w	r3[0x0],r6
800093e0:	fb 49 06 90 	st.w	sp[1680],r9
800093e4:	87 1b       	st.w	r3[0x4],r11
800093e6:	fb 48 06 8c 	st.w	sp[1676],r8
800093ea:	58 78       	cp.w	r8,7
800093ec:	e0 89 00 04 	brgt	800093f4 <_vfprintf_r+0x1b48>
800093f0:	2f 83       	sub	r3,-8
800093f2:	c0 b8       	rjmp	80009408 <_vfprintf_r+0x1b5c>
800093f4:	fa ca f9 78 	sub	r10,sp,-1672
800093f8:	02 9b       	mov	r11,r1
800093fa:	08 9c       	mov	r12,r4
800093fc:	fe b0 f2 4a 	rcall	80007890 <__sprint_r>
80009400:	e0 81 01 d5 	brne	800097aa <_vfprintf_r+0x1efe>
80009404:	fa c3 f9 e0 	sub	r3,sp,-1568
80009408:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000940c:	40 6a       	lddsp	r10,sp[0x18]
8000940e:	14 16       	sub	r6,r10
80009410:	58 06       	cp.w	r6,0
80009412:	e0 89 00 1c 	brgt	8000944a <_vfprintf_r+0x1b9e>
80009416:	c3 d8       	rjmp	80009490 <_vfprintf_r+0x1be4>
80009418:	2f 09       	sub	r9,-16
8000941a:	2f f8       	sub	r8,-1
8000941c:	fb 49 06 90 	st.w	sp[1680],r9
80009420:	87 02       	st.w	r3[0x0],r2
80009422:	87 10       	st.w	r3[0x4],r0
80009424:	fb 48 06 8c 	st.w	sp[1676],r8
80009428:	58 78       	cp.w	r8,7
8000942a:	e0 89 00 04 	brgt	80009432 <_vfprintf_r+0x1b86>
8000942e:	2f 83       	sub	r3,-8
80009430:	c0 b8       	rjmp	80009446 <_vfprintf_r+0x1b9a>
80009432:	fa ca f9 78 	sub	r10,sp,-1672
80009436:	02 9b       	mov	r11,r1
80009438:	08 9c       	mov	r12,r4
8000943a:	fe b0 f2 2b 	rcall	80007890 <__sprint_r>
8000943e:	e0 81 01 b6 	brne	800097aa <_vfprintf_r+0x1efe>
80009442:	fa c3 f9 e0 	sub	r3,sp,-1568
80009446:	21 06       	sub	r6,16
80009448:	c0 48       	rjmp	80009450 <_vfprintf_r+0x1ba4>
8000944a:	fe c2 bd ae 	sub	r2,pc,-16978
8000944e:	31 00       	mov	r0,16
80009450:	fa f9 06 90 	ld.w	r9,sp[1680]
80009454:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009458:	fe ca bd bc 	sub	r10,pc,-16964
8000945c:	59 06       	cp.w	r6,16
8000945e:	fe 99 ff dd 	brgt	80009418 <_vfprintf_r+0x1b6c>
80009462:	0c 09       	add	r9,r6
80009464:	2f f8       	sub	r8,-1
80009466:	87 0a       	st.w	r3[0x0],r10
80009468:	fb 49 06 90 	st.w	sp[1680],r9
8000946c:	87 16       	st.w	r3[0x4],r6
8000946e:	fb 48 06 8c 	st.w	sp[1676],r8
80009472:	58 78       	cp.w	r8,7
80009474:	e0 89 00 04 	brgt	8000947c <_vfprintf_r+0x1bd0>
80009478:	2f 83       	sub	r3,-8
8000947a:	c0 b8       	rjmp	80009490 <_vfprintf_r+0x1be4>
8000947c:	fa ca f9 78 	sub	r10,sp,-1672
80009480:	02 9b       	mov	r11,r1
80009482:	08 9c       	mov	r12,r4
80009484:	fe b0 f2 06 	rcall	80007890 <__sprint_r>
80009488:	e0 81 01 91 	brne	800097aa <_vfprintf_r+0x1efe>
8000948c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009490:	ed b5 00 00 	bld	r5,0x0
80009494:	e0 81 01 20 	brne	800096d4 <_vfprintf_r+0x1e28>
80009498:	40 c9       	lddsp	r9,sp[0x30]
8000949a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000949e:	2f f8       	sub	r8,-1
800094a0:	87 09       	st.w	r3[0x0],r9
800094a2:	fb 48 06 90 	st.w	sp[1680],r8
800094a6:	30 19       	mov	r9,1
800094a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094ac:	87 19       	st.w	r3[0x4],r9
800094ae:	2f f8       	sub	r8,-1
800094b0:	fb 48 06 8c 	st.w	sp[1676],r8
800094b4:	c0 29       	rjmp	800096b8 <_vfprintf_r+0x1e0c>
800094b6:	14 09       	add	r9,r10
800094b8:	2f f8       	sub	r8,-1
800094ba:	fb 49 06 90 	st.w	sp[1680],r9
800094be:	87 06       	st.w	r3[0x0],r6
800094c0:	87 1a       	st.w	r3[0x4],r10
800094c2:	fb 48 06 8c 	st.w	sp[1676],r8
800094c6:	58 78       	cp.w	r8,7
800094c8:	e0 89 00 04 	brgt	800094d0 <_vfprintf_r+0x1c24>
800094cc:	2f 83       	sub	r3,-8
800094ce:	c0 b8       	rjmp	800094e4 <_vfprintf_r+0x1c38>
800094d0:	fa ca f9 78 	sub	r10,sp,-1672
800094d4:	02 9b       	mov	r11,r1
800094d6:	08 9c       	mov	r12,r4
800094d8:	fe b0 f1 dc 	rcall	80007890 <__sprint_r>
800094dc:	e0 81 01 67 	brne	800097aa <_vfprintf_r+0x1efe>
800094e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800094e4:	40 c8       	lddsp	r8,sp[0x30]
800094e6:	87 08       	st.w	r3[0x0],r8
800094e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800094ec:	2f f8       	sub	r8,-1
800094ee:	30 19       	mov	r9,1
800094f0:	fb 48 06 90 	st.w	sp[1680],r8
800094f4:	87 19       	st.w	r3[0x4],r9
800094f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094fa:	2f f8       	sub	r8,-1
800094fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009500:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009504:	58 78       	cp.w	r8,7
80009506:	e0 89 00 04 	brgt	8000950e <_vfprintf_r+0x1c62>
8000950a:	2f 83       	sub	r3,-8
8000950c:	c0 b8       	rjmp	80009522 <_vfprintf_r+0x1c76>
8000950e:	fa ca f9 78 	sub	r10,sp,-1672
80009512:	02 9b       	mov	r11,r1
80009514:	08 9c       	mov	r12,r4
80009516:	fe b0 f1 bd 	rcall	80007890 <__sprint_r>
8000951a:	e0 81 01 48 	brne	800097aa <_vfprintf_r+0x1efe>
8000951e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009522:	04 06       	add	r6,r2
80009524:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009528:	87 06       	st.w	r3[0x0],r6
8000952a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000952e:	40 66       	lddsp	r6,sp[0x18]
80009530:	40 6e       	lddsp	lr,sp[0x18]
80009532:	10 16       	sub	r6,r8
80009534:	f2 08 01 08 	sub	r8,r9,r8
80009538:	87 16       	st.w	r3[0x4],r6
8000953a:	1c 08       	add	r8,lr
8000953c:	fb 48 06 90 	st.w	sp[1680],r8
80009540:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009544:	2f f8       	sub	r8,-1
80009546:	fb 48 06 8c 	st.w	sp[1676],r8
8000954a:	cb 78       	rjmp	800096b8 <_vfprintf_r+0x1e0c>
8000954c:	40 6c       	lddsp	r12,sp[0x18]
8000954e:	58 1c       	cp.w	r12,1
80009550:	e0 89 00 06 	brgt	8000955c <_vfprintf_r+0x1cb0>
80009554:	ed b5 00 00 	bld	r5,0x0
80009558:	e0 81 00 85 	brne	80009662 <_vfprintf_r+0x1db6>
8000955c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009560:	2f f8       	sub	r8,-1
80009562:	30 19       	mov	r9,1
80009564:	fb 48 06 90 	st.w	sp[1680],r8
80009568:	87 06       	st.w	r3[0x0],r6
8000956a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000956e:	87 19       	st.w	r3[0x4],r9
80009570:	2f f8       	sub	r8,-1
80009572:	fb 48 06 8c 	st.w	sp[1676],r8
80009576:	58 78       	cp.w	r8,7
80009578:	e0 89 00 04 	brgt	80009580 <_vfprintf_r+0x1cd4>
8000957c:	2f 83       	sub	r3,-8
8000957e:	c0 b8       	rjmp	80009594 <_vfprintf_r+0x1ce8>
80009580:	fa ca f9 78 	sub	r10,sp,-1672
80009584:	02 9b       	mov	r11,r1
80009586:	08 9c       	mov	r12,r4
80009588:	fe b0 f1 84 	rcall	80007890 <__sprint_r>
8000958c:	e0 81 01 0f 	brne	800097aa <_vfprintf_r+0x1efe>
80009590:	fa c3 f9 e0 	sub	r3,sp,-1568
80009594:	fa f8 06 90 	ld.w	r8,sp[1680]
80009598:	2f f8       	sub	r8,-1
8000959a:	40 cb       	lddsp	r11,sp[0x30]
8000959c:	fb 48 06 90 	st.w	sp[1680],r8
800095a0:	30 19       	mov	r9,1
800095a2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095a6:	87 0b       	st.w	r3[0x0],r11
800095a8:	2f f8       	sub	r8,-1
800095aa:	87 19       	st.w	r3[0x4],r9
800095ac:	fb 48 06 8c 	st.w	sp[1676],r8
800095b0:	58 78       	cp.w	r8,7
800095b2:	e0 89 00 05 	brgt	800095bc <_vfprintf_r+0x1d10>
800095b6:	2f 83       	sub	r3,-8
800095b8:	c0 c8       	rjmp	800095d0 <_vfprintf_r+0x1d24>
800095ba:	d7 03       	nop
800095bc:	fa ca f9 78 	sub	r10,sp,-1672
800095c0:	02 9b       	mov	r11,r1
800095c2:	08 9c       	mov	r12,r4
800095c4:	fe b0 f1 66 	rcall	80007890 <__sprint_r>
800095c8:	e0 81 00 f1 	brne	800097aa <_vfprintf_r+0x1efe>
800095cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800095d0:	30 08       	mov	r8,0
800095d2:	30 09       	mov	r9,0
800095d4:	40 5b       	lddsp	r11,sp[0x14]
800095d6:	40 7a       	lddsp	r10,sp[0x1c]
800095d8:	e0 a0 13 25 	rcall	8000bc22 <__avr32_f64_cmp_eq>
800095dc:	40 68       	lddsp	r8,sp[0x18]
800095de:	20 18       	sub	r8,1
800095e0:	58 0c       	cp.w	r12,0
800095e2:	c0 d1       	brne	800095fc <_vfprintf_r+0x1d50>
800095e4:	2f f6       	sub	r6,-1
800095e6:	87 18       	st.w	r3[0x4],r8
800095e8:	87 06       	st.w	r3[0x0],r6
800095ea:	fa f6 06 90 	ld.w	r6,sp[1680]
800095ee:	10 06       	add	r6,r8
800095f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095f4:	fb 46 06 90 	st.w	sp[1680],r6
800095f8:	2f f8       	sub	r8,-1
800095fa:	c3 18       	rjmp	8000965c <_vfprintf_r+0x1db0>
800095fc:	10 96       	mov	r6,r8
800095fe:	58 08       	cp.w	r8,0
80009600:	e0 89 00 1c 	brgt	80009638 <_vfprintf_r+0x1d8c>
80009604:	c4 b8       	rjmp	8000969a <_vfprintf_r+0x1dee>
80009606:	2f 09       	sub	r9,-16
80009608:	2f f8       	sub	r8,-1
8000960a:	fb 49 06 90 	st.w	sp[1680],r9
8000960e:	87 02       	st.w	r3[0x0],r2
80009610:	87 10       	st.w	r3[0x4],r0
80009612:	fb 48 06 8c 	st.w	sp[1676],r8
80009616:	58 78       	cp.w	r8,7
80009618:	e0 89 00 04 	brgt	80009620 <_vfprintf_r+0x1d74>
8000961c:	2f 83       	sub	r3,-8
8000961e:	c0 b8       	rjmp	80009634 <_vfprintf_r+0x1d88>
80009620:	fa ca f9 78 	sub	r10,sp,-1672
80009624:	02 9b       	mov	r11,r1
80009626:	08 9c       	mov	r12,r4
80009628:	fe b0 f1 34 	rcall	80007890 <__sprint_r>
8000962c:	e0 81 00 bf 	brne	800097aa <_vfprintf_r+0x1efe>
80009630:	fa c3 f9 e0 	sub	r3,sp,-1568
80009634:	21 06       	sub	r6,16
80009636:	c0 48       	rjmp	8000963e <_vfprintf_r+0x1d92>
80009638:	fe c2 bf 9c 	sub	r2,pc,-16484
8000963c:	31 00       	mov	r0,16
8000963e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009642:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009646:	fe ca bf aa 	sub	r10,pc,-16470
8000964a:	59 06       	cp.w	r6,16
8000964c:	fe 99 ff dd 	brgt	80009606 <_vfprintf_r+0x1d5a>
80009650:	0c 09       	add	r9,r6
80009652:	87 0a       	st.w	r3[0x0],r10
80009654:	fb 49 06 90 	st.w	sp[1680],r9
80009658:	2f f8       	sub	r8,-1
8000965a:	87 16       	st.w	r3[0x4],r6
8000965c:	fb 48 06 8c 	st.w	sp[1676],r8
80009660:	c0 e8       	rjmp	8000967c <_vfprintf_r+0x1dd0>
80009662:	fa f8 06 90 	ld.w	r8,sp[1680]
80009666:	2f f8       	sub	r8,-1
80009668:	30 19       	mov	r9,1
8000966a:	fb 48 06 90 	st.w	sp[1680],r8
8000966e:	87 06       	st.w	r3[0x0],r6
80009670:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009674:	87 19       	st.w	r3[0x4],r9
80009676:	2f f8       	sub	r8,-1
80009678:	fb 48 06 8c 	st.w	sp[1676],r8
8000967c:	58 78       	cp.w	r8,7
8000967e:	e0 89 00 04 	brgt	80009686 <_vfprintf_r+0x1dda>
80009682:	2f 83       	sub	r3,-8
80009684:	c0 b8       	rjmp	8000969a <_vfprintf_r+0x1dee>
80009686:	fa ca f9 78 	sub	r10,sp,-1672
8000968a:	02 9b       	mov	r11,r1
8000968c:	08 9c       	mov	r12,r4
8000968e:	fe b0 f1 01 	rcall	80007890 <__sprint_r>
80009692:	e0 81 00 8c 	brne	800097aa <_vfprintf_r+0x1efe>
80009696:	fa c3 f9 e0 	sub	r3,sp,-1568
8000969a:	40 ea       	lddsp	r10,sp[0x38]
8000969c:	fa f8 06 90 	ld.w	r8,sp[1680]
800096a0:	14 08       	add	r8,r10
800096a2:	fa c9 f9 64 	sub	r9,sp,-1692
800096a6:	fb 48 06 90 	st.w	sp[1680],r8
800096aa:	87 1a       	st.w	r3[0x4],r10
800096ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096b0:	87 09       	st.w	r3[0x0],r9
800096b2:	2f f8       	sub	r8,-1
800096b4:	fb 48 06 8c 	st.w	sp[1676],r8
800096b8:	58 78       	cp.w	r8,7
800096ba:	e0 89 00 04 	brgt	800096c2 <_vfprintf_r+0x1e16>
800096be:	2f 83       	sub	r3,-8
800096c0:	c0 a8       	rjmp	800096d4 <_vfprintf_r+0x1e28>
800096c2:	fa ca f9 78 	sub	r10,sp,-1672
800096c6:	02 9b       	mov	r11,r1
800096c8:	08 9c       	mov	r12,r4
800096ca:	fe b0 f0 e3 	rcall	80007890 <__sprint_r>
800096ce:	c6 e1       	brne	800097aa <_vfprintf_r+0x1efe>
800096d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800096d4:	e2 15 00 04 	andl	r5,0x4,COH
800096d8:	c3 f0       	breq	80009756 <_vfprintf_r+0x1eaa>
800096da:	40 86       	lddsp	r6,sp[0x20]
800096dc:	40 39       	lddsp	r9,sp[0xc]
800096de:	12 16       	sub	r6,r9
800096e0:	58 06       	cp.w	r6,0
800096e2:	e0 89 00 1a 	brgt	80009716 <_vfprintf_r+0x1e6a>
800096e6:	c3 88       	rjmp	80009756 <_vfprintf_r+0x1eaa>
800096e8:	2f 09       	sub	r9,-16
800096ea:	2f f8       	sub	r8,-1
800096ec:	fb 49 06 90 	st.w	sp[1680],r9
800096f0:	87 05       	st.w	r3[0x0],r5
800096f2:	87 12       	st.w	r3[0x4],r2
800096f4:	fb 48 06 8c 	st.w	sp[1676],r8
800096f8:	58 78       	cp.w	r8,7
800096fa:	e0 89 00 04 	brgt	80009702 <_vfprintf_r+0x1e56>
800096fe:	2f 83       	sub	r3,-8
80009700:	c0 98       	rjmp	80009712 <_vfprintf_r+0x1e66>
80009702:	00 9a       	mov	r10,r0
80009704:	02 9b       	mov	r11,r1
80009706:	08 9c       	mov	r12,r4
80009708:	fe b0 f0 c4 	rcall	80007890 <__sprint_r>
8000970c:	c4 f1       	brne	800097aa <_vfprintf_r+0x1efe>
8000970e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009712:	21 06       	sub	r6,16
80009714:	c0 68       	rjmp	80009720 <_vfprintf_r+0x1e74>
80009716:	fe c5 c0 8a 	sub	r5,pc,-16246
8000971a:	31 02       	mov	r2,16
8000971c:	fa c0 f9 78 	sub	r0,sp,-1672
80009720:	fa f9 06 90 	ld.w	r9,sp[1680]
80009724:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009728:	fe ca c0 9c 	sub	r10,pc,-16228
8000972c:	59 06       	cp.w	r6,16
8000972e:	fe 99 ff dd 	brgt	800096e8 <_vfprintf_r+0x1e3c>
80009732:	0c 09       	add	r9,r6
80009734:	2f f8       	sub	r8,-1
80009736:	87 0a       	st.w	r3[0x0],r10
80009738:	87 16       	st.w	r3[0x4],r6
8000973a:	fb 49 06 90 	st.w	sp[1680],r9
8000973e:	fb 48 06 8c 	st.w	sp[1676],r8
80009742:	58 78       	cp.w	r8,7
80009744:	e0 8a 00 09 	brle	80009756 <_vfprintf_r+0x1eaa>
80009748:	fa ca f9 78 	sub	r10,sp,-1672
8000974c:	02 9b       	mov	r11,r1
8000974e:	08 9c       	mov	r12,r4
80009750:	fe b0 f0 a0 	rcall	80007890 <__sprint_r>
80009754:	c2 b1       	brne	800097aa <_vfprintf_r+0x1efe>
80009756:	40 bc       	lddsp	r12,sp[0x2c]
80009758:	40 36       	lddsp	r6,sp[0xc]
8000975a:	40 8e       	lddsp	lr,sp[0x20]
8000975c:	ec 0e 0c 48 	max	r8,r6,lr
80009760:	10 0c       	add	r12,r8
80009762:	50 bc       	stdsp	sp[0x2c],r12
80009764:	fa f8 06 90 	ld.w	r8,sp[1680]
80009768:	58 08       	cp.w	r8,0
8000976a:	c0 80       	breq	8000977a <_vfprintf_r+0x1ece>
8000976c:	fa ca f9 78 	sub	r10,sp,-1672
80009770:	02 9b       	mov	r11,r1
80009772:	08 9c       	mov	r12,r4
80009774:	fe b0 f0 8e 	rcall	80007890 <__sprint_r>
80009778:	c1 91       	brne	800097aa <_vfprintf_r+0x1efe>
8000977a:	30 0b       	mov	r11,0
8000977c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009780:	fb 4b 06 8c 	st.w	sp[1676],r11
80009784:	fe 9f f1 22 	bral	800079c8 <_vfprintf_r+0x11c>
80009788:	08 95       	mov	r5,r4
8000978a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000978e:	58 08       	cp.w	r8,0
80009790:	c0 80       	breq	800097a0 <_vfprintf_r+0x1ef4>
80009792:	08 9c       	mov	r12,r4
80009794:	fa ca f9 78 	sub	r10,sp,-1672
80009798:	02 9b       	mov	r11,r1
8000979a:	fe b0 f0 7b 	rcall	80007890 <__sprint_r>
8000979e:	c0 61       	brne	800097aa <_vfprintf_r+0x1efe>
800097a0:	30 08       	mov	r8,0
800097a2:	fb 48 06 8c 	st.w	sp[1676],r8
800097a6:	c0 28       	rjmp	800097aa <_vfprintf_r+0x1efe>
800097a8:	40 41       	lddsp	r1,sp[0x10]
800097aa:	82 68       	ld.sh	r8,r1[0xc]
800097ac:	ed b8 00 06 	bld	r8,0x6
800097b0:	c0 31       	brne	800097b6 <_vfprintf_r+0x1f0a>
800097b2:	3f fa       	mov	r10,-1
800097b4:	50 ba       	stdsp	sp[0x2c],r10
800097b6:	40 bc       	lddsp	r12,sp[0x2c]
800097b8:	fe 3d f9 44 	sub	sp,-1724
800097bc:	d8 32       	popm	r0-r7,pc
800097be:	d7 03       	nop

800097c0 <__swsetup_r>:
800097c0:	d4 21       	pushm	r4-r7,lr
800097c2:	e0 68 0a 38 	mov	r8,2616
800097c6:	18 96       	mov	r6,r12
800097c8:	16 97       	mov	r7,r11
800097ca:	70 0c       	ld.w	r12,r8[0x0]
800097cc:	58 0c       	cp.w	r12,0
800097ce:	c0 60       	breq	800097da <__swsetup_r+0x1a>
800097d0:	78 68       	ld.w	r8,r12[0x18]
800097d2:	58 08       	cp.w	r8,0
800097d4:	c0 31       	brne	800097da <__swsetup_r+0x1a>
800097d6:	e0 a0 07 bf 	rcall	8000a754 <__sinit>
800097da:	fe c8 c0 1e 	sub	r8,pc,-16354
800097de:	10 37       	cp.w	r7,r8
800097e0:	c0 61       	brne	800097ec <__swsetup_r+0x2c>
800097e2:	e0 68 0a 38 	mov	r8,2616
800097e6:	70 08       	ld.w	r8,r8[0x0]
800097e8:	70 07       	ld.w	r7,r8[0x0]
800097ea:	c1 28       	rjmp	8000980e <__swsetup_r+0x4e>
800097ec:	fe c8 c0 10 	sub	r8,pc,-16368
800097f0:	10 37       	cp.w	r7,r8
800097f2:	c0 61       	brne	800097fe <__swsetup_r+0x3e>
800097f4:	e0 68 0a 38 	mov	r8,2616
800097f8:	70 08       	ld.w	r8,r8[0x0]
800097fa:	70 17       	ld.w	r7,r8[0x4]
800097fc:	c0 98       	rjmp	8000980e <__swsetup_r+0x4e>
800097fe:	fe c8 c0 02 	sub	r8,pc,-16382
80009802:	10 37       	cp.w	r7,r8
80009804:	c0 51       	brne	8000980e <__swsetup_r+0x4e>
80009806:	e0 68 0a 38 	mov	r8,2616
8000980a:	70 08       	ld.w	r8,r8[0x0]
8000980c:	70 27       	ld.w	r7,r8[0x8]
8000980e:	8e 68       	ld.sh	r8,r7[0xc]
80009810:	ed b8 00 03 	bld	r8,0x3
80009814:	c1 e0       	breq	80009850 <__swsetup_r+0x90>
80009816:	ed b8 00 04 	bld	r8,0x4
8000981a:	c3 e1       	brne	80009896 <__swsetup_r+0xd6>
8000981c:	ed b8 00 02 	bld	r8,0x2
80009820:	c1 51       	brne	8000984a <__swsetup_r+0x8a>
80009822:	6e db       	ld.w	r11,r7[0x34]
80009824:	58 0b       	cp.w	r11,0
80009826:	c0 a0       	breq	8000983a <__swsetup_r+0x7a>
80009828:	ee c8 ff bc 	sub	r8,r7,-68
8000982c:	10 3b       	cp.w	r11,r8
8000982e:	c0 40       	breq	80009836 <__swsetup_r+0x76>
80009830:	0c 9c       	mov	r12,r6
80009832:	e0 a0 08 2b 	rcall	8000a888 <_free_r>
80009836:	30 08       	mov	r8,0
80009838:	8f d8       	st.w	r7[0x34],r8
8000983a:	8e 68       	ld.sh	r8,r7[0xc]
8000983c:	e0 18 ff db 	andl	r8,0xffdb
80009840:	ae 68       	st.h	r7[0xc],r8
80009842:	30 08       	mov	r8,0
80009844:	8f 18       	st.w	r7[0x4],r8
80009846:	6e 48       	ld.w	r8,r7[0x10]
80009848:	8f 08       	st.w	r7[0x0],r8
8000984a:	8e 68       	ld.sh	r8,r7[0xc]
8000984c:	a3 b8       	sbr	r8,0x3
8000984e:	ae 68       	st.h	r7[0xc],r8
80009850:	6e 48       	ld.w	r8,r7[0x10]
80009852:	58 08       	cp.w	r8,0
80009854:	c0 b1       	brne	8000986a <__swsetup_r+0xaa>
80009856:	8e 68       	ld.sh	r8,r7[0xc]
80009858:	e2 18 02 80 	andl	r8,0x280,COH
8000985c:	e0 48 02 00 	cp.w	r8,512
80009860:	c0 50       	breq	8000986a <__swsetup_r+0xaa>
80009862:	0c 9c       	mov	r12,r6
80009864:	0e 9b       	mov	r11,r7
80009866:	e0 a0 0a 4b 	rcall	8000acfc <__smakebuf_r>
8000986a:	8e 69       	ld.sh	r9,r7[0xc]
8000986c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009870:	c0 70       	breq	8000987e <__swsetup_r+0xbe>
80009872:	30 08       	mov	r8,0
80009874:	8f 28       	st.w	r7[0x8],r8
80009876:	6e 58       	ld.w	r8,r7[0x14]
80009878:	5c 38       	neg	r8
8000987a:	8f 68       	st.w	r7[0x18],r8
8000987c:	c0 68       	rjmp	80009888 <__swsetup_r+0xc8>
8000987e:	ed b9 00 01 	bld	r9,0x1
80009882:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009886:	8f 28       	st.w	r7[0x8],r8
80009888:	6e 48       	ld.w	r8,r7[0x10]
8000988a:	58 08       	cp.w	r8,0
8000988c:	c0 61       	brne	80009898 <__swsetup_r+0xd8>
8000988e:	8e 68       	ld.sh	r8,r7[0xc]
80009890:	ed b8 00 07 	bld	r8,0x7
80009894:	c0 21       	brne	80009898 <__swsetup_r+0xd8>
80009896:	dc 2a       	popm	r4-r7,pc,r12=-1
80009898:	d8 2a       	popm	r4-r7,pc,r12=0
8000989a:	d7 03       	nop

8000989c <quorem>:
8000989c:	d4 31       	pushm	r0-r7,lr
8000989e:	20 2d       	sub	sp,8
800098a0:	18 97       	mov	r7,r12
800098a2:	78 48       	ld.w	r8,r12[0x10]
800098a4:	76 46       	ld.w	r6,r11[0x10]
800098a6:	0c 38       	cp.w	r8,r6
800098a8:	c0 34       	brge	800098ae <quorem+0x12>
800098aa:	30 0c       	mov	r12,0
800098ac:	c8 58       	rjmp	800099b6 <quorem+0x11a>
800098ae:	ec c2 ff fc 	sub	r2,r6,-4
800098b2:	f6 c3 ff ec 	sub	r3,r11,-20
800098b6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800098ba:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800098be:	2f f9       	sub	r9,-1
800098c0:	20 16       	sub	r6,1
800098c2:	f8 09 0d 08 	divu	r8,r12,r9
800098c6:	f6 02 00 22 	add	r2,r11,r2<<0x2
800098ca:	ee c4 ff ec 	sub	r4,r7,-20
800098ce:	10 95       	mov	r5,r8
800098d0:	58 08       	cp.w	r8,0
800098d2:	c4 10       	breq	80009954 <quorem+0xb8>
800098d4:	30 09       	mov	r9,0
800098d6:	06 9a       	mov	r10,r3
800098d8:	08 98       	mov	r8,r4
800098da:	12 91       	mov	r1,r9
800098dc:	50 0b       	stdsp	sp[0x0],r11
800098de:	70 0e       	ld.w	lr,r8[0x0]
800098e0:	b1 8e       	lsr	lr,0x10
800098e2:	50 1e       	stdsp	sp[0x4],lr
800098e4:	15 0e       	ld.w	lr,r10++
800098e6:	fc 00 16 10 	lsr	r0,lr,0x10
800098ea:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800098ee:	ea 0e 03 41 	mac	r1,r5,lr
800098f2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800098f6:	b1 81       	lsr	r1,0x10
800098f8:	40 1b       	lddsp	r11,sp[0x4]
800098fa:	ea 00 02 40 	mul	r0,r5,r0
800098fe:	e2 00 00 00 	add	r0,r1,r0
80009902:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009906:	02 1b       	sub	r11,r1
80009908:	50 1b       	stdsp	sp[0x4],r11
8000990a:	70 0b       	ld.w	r11,r8[0x0]
8000990c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009910:	02 09       	add	r9,r1
80009912:	f2 0e 01 0e 	sub	lr,r9,lr
80009916:	b0 1e       	st.h	r8[0x2],lr
80009918:	fc 09 14 10 	asr	r9,lr,0x10
8000991c:	40 1e       	lddsp	lr,sp[0x4]
8000991e:	fc 09 00 09 	add	r9,lr,r9
80009922:	b0 09       	st.h	r8[0x0],r9
80009924:	e0 01 16 10 	lsr	r1,r0,0x10
80009928:	2f c8       	sub	r8,-4
8000992a:	b1 49       	asr	r9,0x10
8000992c:	04 3a       	cp.w	r10,r2
8000992e:	fe 98 ff d8 	brls	800098de <quorem+0x42>
80009932:	40 0b       	lddsp	r11,sp[0x0]
80009934:	58 0c       	cp.w	r12,0
80009936:	c0 f1       	brne	80009954 <quorem+0xb8>
80009938:	ec c8 ff fb 	sub	r8,r6,-5
8000993c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009940:	c0 28       	rjmp	80009944 <quorem+0xa8>
80009942:	20 16       	sub	r6,1
80009944:	20 48       	sub	r8,4
80009946:	08 38       	cp.w	r8,r4
80009948:	e0 88 00 05 	brls	80009952 <quorem+0xb6>
8000994c:	70 09       	ld.w	r9,r8[0x0]
8000994e:	58 09       	cp.w	r9,0
80009950:	cf 90       	breq	80009942 <quorem+0xa6>
80009952:	8f 46       	st.w	r7[0x10],r6
80009954:	0e 9c       	mov	r12,r7
80009956:	e0 a0 0a d2 	rcall	8000aefa <__mcmp>
8000995a:	c2 d5       	brlt	800099b4 <quorem+0x118>
8000995c:	2f f5       	sub	r5,-1
8000995e:	08 98       	mov	r8,r4
80009960:	30 09       	mov	r9,0
80009962:	07 0b       	ld.w	r11,r3++
80009964:	f6 0a 16 10 	lsr	r10,r11,0x10
80009968:	70 0c       	ld.w	r12,r8[0x0]
8000996a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000996e:	f8 0e 16 10 	lsr	lr,r12,0x10
80009972:	14 1e       	sub	lr,r10
80009974:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009978:	16 1a       	sub	r10,r11
8000997a:	12 0a       	add	r10,r9
8000997c:	b0 1a       	st.h	r8[0x2],r10
8000997e:	b1 4a       	asr	r10,0x10
80009980:	fc 0a 00 09 	add	r9,lr,r10
80009984:	b0 09       	st.h	r8[0x0],r9
80009986:	2f c8       	sub	r8,-4
80009988:	b1 49       	asr	r9,0x10
8000998a:	04 33       	cp.w	r3,r2
8000998c:	fe 98 ff eb 	brls	80009962 <quorem+0xc6>
80009990:	ec c8 ff fb 	sub	r8,r6,-5
80009994:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009998:	58 09       	cp.w	r9,0
8000999a:	c0 d1       	brne	800099b4 <quorem+0x118>
8000999c:	ee 08 00 28 	add	r8,r7,r8<<0x2
800099a0:	c0 28       	rjmp	800099a4 <quorem+0x108>
800099a2:	20 16       	sub	r6,1
800099a4:	20 48       	sub	r8,4
800099a6:	08 38       	cp.w	r8,r4
800099a8:	e0 88 00 05 	brls	800099b2 <quorem+0x116>
800099ac:	70 09       	ld.w	r9,r8[0x0]
800099ae:	58 09       	cp.w	r9,0
800099b0:	cf 90       	breq	800099a2 <quorem+0x106>
800099b2:	8f 46       	st.w	r7[0x10],r6
800099b4:	0a 9c       	mov	r12,r5
800099b6:	2f ed       	sub	sp,-8
800099b8:	d8 32       	popm	r0-r7,pc
800099ba:	d7 03       	nop

800099bc <_dtoa_r>:
800099bc:	d4 31       	pushm	r0-r7,lr
800099be:	21 ad       	sub	sp,104
800099c0:	fa c4 ff 74 	sub	r4,sp,-140
800099c4:	18 97       	mov	r7,r12
800099c6:	16 95       	mov	r5,r11
800099c8:	68 2c       	ld.w	r12,r4[0x8]
800099ca:	50 c9       	stdsp	sp[0x30],r9
800099cc:	68 16       	ld.w	r6,r4[0x4]
800099ce:	68 09       	ld.w	r9,r4[0x0]
800099d0:	50 e8       	stdsp	sp[0x38],r8
800099d2:	14 94       	mov	r4,r10
800099d4:	51 2c       	stdsp	sp[0x48],r12
800099d6:	fa e5 00 08 	st.d	sp[8],r4
800099da:	51 59       	stdsp	sp[0x54],r9
800099dc:	6e 95       	ld.w	r5,r7[0x24]
800099de:	58 05       	cp.w	r5,0
800099e0:	c0 91       	brne	800099f2 <_dtoa_r+0x36>
800099e2:	31 0c       	mov	r12,16
800099e4:	fe b0 e8 e2 	rcall	80006ba8 <malloc>
800099e8:	99 35       	st.w	r12[0xc],r5
800099ea:	8f 9c       	st.w	r7[0x24],r12
800099ec:	99 15       	st.w	r12[0x4],r5
800099ee:	99 25       	st.w	r12[0x8],r5
800099f0:	99 05       	st.w	r12[0x0],r5
800099f2:	6e 99       	ld.w	r9,r7[0x24]
800099f4:	72 08       	ld.w	r8,r9[0x0]
800099f6:	58 08       	cp.w	r8,0
800099f8:	c0 f0       	breq	80009a16 <_dtoa_r+0x5a>
800099fa:	72 1a       	ld.w	r10,r9[0x4]
800099fc:	91 1a       	st.w	r8[0x4],r10
800099fe:	30 1a       	mov	r10,1
80009a00:	72 19       	ld.w	r9,r9[0x4]
80009a02:	f4 09 09 49 	lsl	r9,r10,r9
80009a06:	10 9b       	mov	r11,r8
80009a08:	91 29       	st.w	r8[0x8],r9
80009a0a:	0e 9c       	mov	r12,r7
80009a0c:	e0 a0 0a 90 	rcall	8000af2c <_Bfree>
80009a10:	6e 98       	ld.w	r8,r7[0x24]
80009a12:	30 09       	mov	r9,0
80009a14:	91 09       	st.w	r8[0x0],r9
80009a16:	40 28       	lddsp	r8,sp[0x8]
80009a18:	10 94       	mov	r4,r8
80009a1a:	58 08       	cp.w	r8,0
80009a1c:	c0 64       	brge	80009a28 <_dtoa_r+0x6c>
80009a1e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009a22:	50 28       	stdsp	sp[0x8],r8
80009a24:	30 18       	mov	r8,1
80009a26:	c0 28       	rjmp	80009a2a <_dtoa_r+0x6e>
80009a28:	30 08       	mov	r8,0
80009a2a:	8d 08       	st.w	r6[0x0],r8
80009a2c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009a30:	40 26       	lddsp	r6,sp[0x8]
80009a32:	0c 98       	mov	r8,r6
80009a34:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009a38:	18 38       	cp.w	r8,r12
80009a3a:	c2 01       	brne	80009a7a <_dtoa_r+0xbe>
80009a3c:	e0 68 27 0f 	mov	r8,9999
80009a40:	41 5b       	lddsp	r11,sp[0x54]
80009a42:	97 08       	st.w	r11[0x0],r8
80009a44:	40 3a       	lddsp	r10,sp[0xc]
80009a46:	58 0a       	cp.w	r10,0
80009a48:	c0 71       	brne	80009a56 <_dtoa_r+0x9a>
80009a4a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009a4e:	c0 41       	brne	80009a56 <_dtoa_r+0x9a>
80009a50:	fe cc c2 a4 	sub	r12,pc,-15708
80009a54:	c0 38       	rjmp	80009a5a <_dtoa_r+0x9e>
80009a56:	fe cc c2 9e 	sub	r12,pc,-15714
80009a5a:	41 29       	lddsp	r9,sp[0x48]
80009a5c:	58 09       	cp.w	r9,0
80009a5e:	e0 80 05 9a 	breq	8000a592 <_dtoa_r+0xbd6>
80009a62:	f8 c8 ff fd 	sub	r8,r12,-3
80009a66:	f8 c9 ff f8 	sub	r9,r12,-8
80009a6a:	11 8b       	ld.ub	r11,r8[0x0]
80009a6c:	30 0a       	mov	r10,0
80009a6e:	41 25       	lddsp	r5,sp[0x48]
80009a70:	f4 0b 18 00 	cp.b	r11,r10
80009a74:	f2 08 17 10 	movne	r8,r9
80009a78:	c1 68       	rjmp	80009aa4 <_dtoa_r+0xe8>
80009a7a:	fa ea 00 08 	ld.d	r10,sp[8]
80009a7e:	30 08       	mov	r8,0
80009a80:	fa eb 00 3c 	st.d	sp[60],r10
80009a84:	30 09       	mov	r9,0
80009a86:	e0 a0 10 ce 	rcall	8000bc22 <__avr32_f64_cmp_eq>
80009a8a:	c1 00       	breq	80009aaa <_dtoa_r+0xee>
80009a8c:	30 18       	mov	r8,1
80009a8e:	41 5a       	lddsp	r10,sp[0x54]
80009a90:	95 08       	st.w	r10[0x0],r8
80009a92:	fe cc c4 0a 	sub	r12,pc,-15350
80009a96:	41 29       	lddsp	r9,sp[0x48]
80009a98:	f8 08 00 08 	add	r8,r12,r8
80009a9c:	58 09       	cp.w	r9,0
80009a9e:	e0 80 05 7a 	breq	8000a592 <_dtoa_r+0xbd6>
80009aa2:	12 95       	mov	r5,r9
80009aa4:	8b 08       	st.w	r5[0x0],r8
80009aa6:	e0 8f 05 76 	bral	8000a592 <_dtoa_r+0xbd6>
80009aaa:	fa c8 ff 9c 	sub	r8,sp,-100
80009aae:	fa c9 ff a0 	sub	r9,sp,-96
80009ab2:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ab6:	0e 9c       	mov	r12,r7
80009ab8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009abc:	e0 a0 0a 8a 	rcall	8000afd0 <__d2b>
80009ac0:	18 93       	mov	r3,r12
80009ac2:	58 05       	cp.w	r5,0
80009ac4:	c0 d0       	breq	80009ade <_dtoa_r+0x122>
80009ac6:	fa ea 00 3c 	ld.d	r10,sp[60]
80009aca:	30 04       	mov	r4,0
80009acc:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009ad0:	ea c5 03 ff 	sub	r5,r5,1023
80009ad4:	10 9b       	mov	r11,r8
80009ad6:	51 74       	stdsp	sp[0x5c],r4
80009ad8:	ea 1b 3f f0 	orh	r11,0x3ff0
80009adc:	c2 58       	rjmp	80009b26 <_dtoa_r+0x16a>
80009ade:	41 88       	lddsp	r8,sp[0x60]
80009ae0:	41 9c       	lddsp	r12,sp[0x64]
80009ae2:	10 0c       	add	r12,r8
80009ae4:	f8 c5 fb ce 	sub	r5,r12,-1074
80009ae8:	e0 45 00 20 	cp.w	r5,32
80009aec:	e0 8a 00 0e 	brle	80009b08 <_dtoa_r+0x14c>
80009af0:	f8 cc fb ee 	sub	r12,r12,-1042
80009af4:	40 3b       	lddsp	r11,sp[0xc]
80009af6:	ea 08 11 40 	rsub	r8,r5,64
80009afa:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009afe:	ec 08 09 46 	lsl	r6,r6,r8
80009b02:	0c 4c       	or	r12,r6
80009b04:	c0 78       	rjmp	80009b12 <_dtoa_r+0x156>
80009b06:	d7 03       	nop
80009b08:	ea 0c 11 20 	rsub	r12,r5,32
80009b0c:	40 3a       	lddsp	r10,sp[0xc]
80009b0e:	f4 0c 09 4c 	lsl	r12,r10,r12
80009b12:	e0 a0 10 14 	rcall	8000bb3a <__avr32_u32_to_f64>
80009b16:	fc 18 fe 10 	movh	r8,0xfe10
80009b1a:	30 19       	mov	r9,1
80009b1c:	ea c5 04 33 	sub	r5,r5,1075
80009b20:	f0 0b 00 0b 	add	r11,r8,r11
80009b24:	51 79       	stdsp	sp[0x5c],r9
80009b26:	30 08       	mov	r8,0
80009b28:	fc 19 3f f8 	movh	r9,0x3ff8
80009b2c:	e0 a0 0e 9c 	rcall	8000b864 <__avr32_f64_sub>
80009b30:	e0 68 43 61 	mov	r8,17249
80009b34:	ea 18 63 6f 	orh	r8,0x636f
80009b38:	e0 69 87 a7 	mov	r9,34727
80009b3c:	ea 19 3f d2 	orh	r9,0x3fd2
80009b40:	e0 a0 0d a6 	rcall	8000b68c <__avr32_f64_mul>
80009b44:	e0 68 c8 b3 	mov	r8,51379
80009b48:	ea 18 8b 60 	orh	r8,0x8b60
80009b4c:	e0 69 8a 28 	mov	r9,35368
80009b50:	ea 19 3f c6 	orh	r9,0x3fc6
80009b54:	e0 a0 0f 56 	rcall	8000ba00 <__avr32_f64_add>
80009b58:	0a 9c       	mov	r12,r5
80009b5a:	14 90       	mov	r0,r10
80009b5c:	16 91       	mov	r1,r11
80009b5e:	e0 a0 0f f2 	rcall	8000bb42 <__avr32_s32_to_f64>
80009b62:	e0 68 79 fb 	mov	r8,31227
80009b66:	ea 18 50 9f 	orh	r8,0x509f
80009b6a:	e0 69 44 13 	mov	r9,17427
80009b6e:	ea 19 3f d3 	orh	r9,0x3fd3
80009b72:	e0 a0 0d 8d 	rcall	8000b68c <__avr32_f64_mul>
80009b76:	14 98       	mov	r8,r10
80009b78:	16 99       	mov	r9,r11
80009b7a:	00 9a       	mov	r10,r0
80009b7c:	02 9b       	mov	r11,r1
80009b7e:	e0 a0 0f 41 	rcall	8000ba00 <__avr32_f64_add>
80009b82:	14 90       	mov	r0,r10
80009b84:	16 91       	mov	r1,r11
80009b86:	e0 a0 0f c7 	rcall	8000bb14 <__avr32_f64_to_s32>
80009b8a:	30 08       	mov	r8,0
80009b8c:	18 96       	mov	r6,r12
80009b8e:	30 09       	mov	r9,0
80009b90:	00 9a       	mov	r10,r0
80009b92:	02 9b       	mov	r11,r1
80009b94:	e0 a0 10 8e 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009b98:	c0 c0       	breq	80009bb0 <_dtoa_r+0x1f4>
80009b9a:	0c 9c       	mov	r12,r6
80009b9c:	e0 a0 0f d3 	rcall	8000bb42 <__avr32_s32_to_f64>
80009ba0:	14 98       	mov	r8,r10
80009ba2:	16 99       	mov	r9,r11
80009ba4:	00 9a       	mov	r10,r0
80009ba6:	02 9b       	mov	r11,r1
80009ba8:	e0 a0 10 3d 	rcall	8000bc22 <__avr32_f64_cmp_eq>
80009bac:	f7 b6 00 01 	subeq	r6,1
80009bb0:	59 66       	cp.w	r6,22
80009bb2:	e0 88 00 05 	brls	80009bbc <_dtoa_r+0x200>
80009bb6:	30 18       	mov	r8,1
80009bb8:	51 48       	stdsp	sp[0x50],r8
80009bba:	c1 38       	rjmp	80009be0 <_dtoa_r+0x224>
80009bbc:	fe c8 c3 50 	sub	r8,pc,-15536
80009bc0:	fa ea 00 3c 	ld.d	r10,sp[60]
80009bc4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009bc8:	e0 a0 10 74 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009bcc:	f9 b4 00 00 	moveq	r4,0
80009bd0:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009bd4:	f7 b6 01 01 	subne	r6,1
80009bd8:	f9 bc 01 00 	movne	r12,0
80009bdc:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009be0:	41 90       	lddsp	r0,sp[0x64]
80009be2:	20 10       	sub	r0,1
80009be4:	0a 10       	sub	r0,r5
80009be6:	c0 46       	brmi	80009bee <_dtoa_r+0x232>
80009be8:	50 40       	stdsp	sp[0x10],r0
80009bea:	30 00       	mov	r0,0
80009bec:	c0 48       	rjmp	80009bf4 <_dtoa_r+0x238>
80009bee:	30 0b       	mov	r11,0
80009bf0:	5c 30       	neg	r0
80009bf2:	50 4b       	stdsp	sp[0x10],r11
80009bf4:	ec 02 11 00 	rsub	r2,r6,0
80009bf8:	58 06       	cp.w	r6,0
80009bfa:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009bfe:	f5 d6 e4 0a 	addge	r10,r10,r6
80009c02:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009c06:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009c0a:	f9 b2 04 00 	movge	r2,0
80009c0e:	e1 d6 e5 10 	sublt	r0,r0,r6
80009c12:	f9 b9 05 00 	movlt	r9,0
80009c16:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009c1a:	40 c8       	lddsp	r8,sp[0x30]
80009c1c:	58 98       	cp.w	r8,9
80009c1e:	e0 8b 00 20 	brhi	80009c5e <_dtoa_r+0x2a2>
80009c22:	58 58       	cp.w	r8,5
80009c24:	f9 b4 0a 01 	movle	r4,1
80009c28:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009c2c:	f7 b5 09 04 	subgt	r5,4
80009c30:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009c34:	f9 b4 09 00 	movgt	r4,0
80009c38:	40 cc       	lddsp	r12,sp[0x30]
80009c3a:	58 3c       	cp.w	r12,3
80009c3c:	c2 d0       	breq	80009c96 <_dtoa_r+0x2da>
80009c3e:	e0 89 00 05 	brgt	80009c48 <_dtoa_r+0x28c>
80009c42:	58 2c       	cp.w	r12,2
80009c44:	c1 01       	brne	80009c64 <_dtoa_r+0x2a8>
80009c46:	c1 88       	rjmp	80009c76 <_dtoa_r+0x2ba>
80009c48:	40 cb       	lddsp	r11,sp[0x30]
80009c4a:	58 4b       	cp.w	r11,4
80009c4c:	c0 60       	breq	80009c58 <_dtoa_r+0x29c>
80009c4e:	58 5b       	cp.w	r11,5
80009c50:	c0 a1       	brne	80009c64 <_dtoa_r+0x2a8>
80009c52:	30 1a       	mov	r10,1
80009c54:	50 da       	stdsp	sp[0x34],r10
80009c56:	c2 28       	rjmp	80009c9a <_dtoa_r+0x2de>
80009c58:	30 19       	mov	r9,1
80009c5a:	50 d9       	stdsp	sp[0x34],r9
80009c5c:	c0 f8       	rjmp	80009c7a <_dtoa_r+0x2be>
80009c5e:	30 08       	mov	r8,0
80009c60:	30 14       	mov	r4,1
80009c62:	50 c8       	stdsp	sp[0x30],r8
80009c64:	3f f5       	mov	r5,-1
80009c66:	30 1c       	mov	r12,1
80009c68:	30 0b       	mov	r11,0
80009c6a:	50 95       	stdsp	sp[0x24],r5
80009c6c:	50 dc       	stdsp	sp[0x34],r12
80009c6e:	0a 91       	mov	r1,r5
80009c70:	31 28       	mov	r8,18
80009c72:	50 eb       	stdsp	sp[0x38],r11
80009c74:	c2 08       	rjmp	80009cb4 <_dtoa_r+0x2f8>
80009c76:	30 0a       	mov	r10,0
80009c78:	50 da       	stdsp	sp[0x34],r10
80009c7a:	40 e9       	lddsp	r9,sp[0x38]
80009c7c:	58 09       	cp.w	r9,0
80009c7e:	e0 89 00 07 	brgt	80009c8c <_dtoa_r+0x2d0>
80009c82:	30 18       	mov	r8,1
80009c84:	50 98       	stdsp	sp[0x24],r8
80009c86:	10 91       	mov	r1,r8
80009c88:	50 e8       	stdsp	sp[0x38],r8
80009c8a:	c1 58       	rjmp	80009cb4 <_dtoa_r+0x2f8>
80009c8c:	40 e5       	lddsp	r5,sp[0x38]
80009c8e:	50 95       	stdsp	sp[0x24],r5
80009c90:	0a 91       	mov	r1,r5
80009c92:	0a 98       	mov	r8,r5
80009c94:	c1 08       	rjmp	80009cb4 <_dtoa_r+0x2f8>
80009c96:	30 0c       	mov	r12,0
80009c98:	50 dc       	stdsp	sp[0x34],r12
80009c9a:	40 eb       	lddsp	r11,sp[0x38]
80009c9c:	ec 0b 00 0b 	add	r11,r6,r11
80009ca0:	50 9b       	stdsp	sp[0x24],r11
80009ca2:	16 98       	mov	r8,r11
80009ca4:	2f f8       	sub	r8,-1
80009ca6:	58 08       	cp.w	r8,0
80009ca8:	e0 89 00 05 	brgt	80009cb2 <_dtoa_r+0x2f6>
80009cac:	10 91       	mov	r1,r8
80009cae:	30 18       	mov	r8,1
80009cb0:	c0 28       	rjmp	80009cb4 <_dtoa_r+0x2f8>
80009cb2:	10 91       	mov	r1,r8
80009cb4:	30 09       	mov	r9,0
80009cb6:	6e 9a       	ld.w	r10,r7[0x24]
80009cb8:	95 19       	st.w	r10[0x4],r9
80009cba:	30 49       	mov	r9,4
80009cbc:	c0 68       	rjmp	80009cc8 <_dtoa_r+0x30c>
80009cbe:	d7 03       	nop
80009cc0:	6a 1a       	ld.w	r10,r5[0x4]
80009cc2:	a1 79       	lsl	r9,0x1
80009cc4:	2f fa       	sub	r10,-1
80009cc6:	8b 1a       	st.w	r5[0x4],r10
80009cc8:	6e 95       	ld.w	r5,r7[0x24]
80009cca:	f2 ca ff ec 	sub	r10,r9,-20
80009cce:	10 3a       	cp.w	r10,r8
80009cd0:	fe 98 ff f8 	brls	80009cc0 <_dtoa_r+0x304>
80009cd4:	6a 1b       	ld.w	r11,r5[0x4]
80009cd6:	0e 9c       	mov	r12,r7
80009cd8:	e0 a0 09 44 	rcall	8000af60 <_Balloc>
80009cdc:	58 e1       	cp.w	r1,14
80009cde:	5f 88       	srls	r8
80009ce0:	8b 0c       	st.w	r5[0x0],r12
80009ce2:	f1 e4 00 04 	and	r4,r8,r4
80009ce6:	6e 98       	ld.w	r8,r7[0x24]
80009ce8:	70 08       	ld.w	r8,r8[0x0]
80009cea:	50 88       	stdsp	sp[0x20],r8
80009cec:	e0 80 01 82 	breq	80009ff0 <_dtoa_r+0x634>
80009cf0:	58 06       	cp.w	r6,0
80009cf2:	e0 8a 00 43 	brle	80009d78 <_dtoa_r+0x3bc>
80009cf6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009cfa:	fe c8 c4 8e 	sub	r8,pc,-15218
80009cfe:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009d02:	fa e5 00 18 	st.d	sp[24],r4
80009d06:	ec 04 14 04 	asr	r4,r6,0x4
80009d0a:	ed b4 00 04 	bld	r4,0x4
80009d0e:	c0 30       	breq	80009d14 <_dtoa_r+0x358>
80009d10:	30 25       	mov	r5,2
80009d12:	c1 08       	rjmp	80009d32 <_dtoa_r+0x376>
80009d14:	fe c8 c3 e0 	sub	r8,pc,-15392
80009d18:	f0 e8 00 20 	ld.d	r8,r8[32]
80009d1c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d20:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009d24:	e0 a0 0f fa 	rcall	8000bd18 <__avr32_f64_div>
80009d28:	30 35       	mov	r5,3
80009d2a:	14 98       	mov	r8,r10
80009d2c:	16 99       	mov	r9,r11
80009d2e:	fa e9 00 08 	st.d	sp[8],r8
80009d32:	fe cc c3 fe 	sub	r12,pc,-15362
80009d36:	50 a3       	stdsp	sp[0x28],r3
80009d38:	0c 93       	mov	r3,r6
80009d3a:	18 96       	mov	r6,r12
80009d3c:	c0 f8       	rjmp	80009d5a <_dtoa_r+0x39e>
80009d3e:	fa ea 00 18 	ld.d	r10,sp[24]
80009d42:	ed b4 00 00 	bld	r4,0x0
80009d46:	c0 81       	brne	80009d56 <_dtoa_r+0x39a>
80009d48:	ec e8 00 00 	ld.d	r8,r6[0]
80009d4c:	2f f5       	sub	r5,-1
80009d4e:	e0 a0 0c 9f 	rcall	8000b68c <__avr32_f64_mul>
80009d52:	fa eb 00 18 	st.d	sp[24],r10
80009d56:	a1 54       	asr	r4,0x1
80009d58:	2f 86       	sub	r6,-8
80009d5a:	58 04       	cp.w	r4,0
80009d5c:	cf 11       	brne	80009d3e <_dtoa_r+0x382>
80009d5e:	fa e8 00 18 	ld.d	r8,sp[24]
80009d62:	fa ea 00 08 	ld.d	r10,sp[8]
80009d66:	06 96       	mov	r6,r3
80009d68:	e0 a0 0f d8 	rcall	8000bd18 <__avr32_f64_div>
80009d6c:	40 a3       	lddsp	r3,sp[0x28]
80009d6e:	14 98       	mov	r8,r10
80009d70:	16 99       	mov	r9,r11
80009d72:	fa e9 00 08 	st.d	sp[8],r8
80009d76:	c2 f8       	rjmp	80009dd4 <_dtoa_r+0x418>
80009d78:	ec 08 11 00 	rsub	r8,r6,0
80009d7c:	c0 31       	brne	80009d82 <_dtoa_r+0x3c6>
80009d7e:	30 25       	mov	r5,2
80009d80:	c2 a8       	rjmp	80009dd4 <_dtoa_r+0x418>
80009d82:	fe cc c4 4e 	sub	r12,pc,-15282
80009d86:	f0 04 14 04 	asr	r4,r8,0x4
80009d8a:	50 1c       	stdsp	sp[0x4],r12
80009d8c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009d90:	fe c9 c5 24 	sub	r9,pc,-15068
80009d94:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d98:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009d9c:	e0 a0 0c 78 	rcall	8000b68c <__avr32_f64_mul>
80009da0:	40 1c       	lddsp	r12,sp[0x4]
80009da2:	50 63       	stdsp	sp[0x18],r3
80009da4:	30 25       	mov	r5,2
80009da6:	0c 93       	mov	r3,r6
80009da8:	fa eb 00 08 	st.d	sp[8],r10
80009dac:	18 96       	mov	r6,r12
80009dae:	c0 f8       	rjmp	80009dcc <_dtoa_r+0x410>
80009db0:	fa ea 00 08 	ld.d	r10,sp[8]
80009db4:	ed b4 00 00 	bld	r4,0x0
80009db8:	c0 81       	brne	80009dc8 <_dtoa_r+0x40c>
80009dba:	ec e8 00 00 	ld.d	r8,r6[0]
80009dbe:	2f f5       	sub	r5,-1
80009dc0:	e0 a0 0c 66 	rcall	8000b68c <__avr32_f64_mul>
80009dc4:	fa eb 00 08 	st.d	sp[8],r10
80009dc8:	a1 54       	asr	r4,0x1
80009dca:	2f 86       	sub	r6,-8
80009dcc:	58 04       	cp.w	r4,0
80009dce:	cf 11       	brne	80009db0 <_dtoa_r+0x3f4>
80009dd0:	06 96       	mov	r6,r3
80009dd2:	40 63       	lddsp	r3,sp[0x18]
80009dd4:	41 4a       	lddsp	r10,sp[0x50]
80009dd6:	58 0a       	cp.w	r10,0
80009dd8:	c2 a0       	breq	80009e2c <_dtoa_r+0x470>
80009dda:	fa e8 00 08 	ld.d	r8,sp[8]
80009dde:	58 01       	cp.w	r1,0
80009de0:	5f 94       	srgt	r4
80009de2:	fa e9 00 18 	st.d	sp[24],r8
80009de6:	30 08       	mov	r8,0
80009de8:	fc 19 3f f0 	movh	r9,0x3ff0
80009dec:	fa ea 00 18 	ld.d	r10,sp[24]
80009df0:	e0 a0 0f 60 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009df4:	f9 bc 00 00 	moveq	r12,0
80009df8:	f9 bc 01 01 	movne	r12,1
80009dfc:	e9 ec 00 0c 	and	r12,r4,r12
80009e00:	c1 60       	breq	80009e2c <_dtoa_r+0x470>
80009e02:	40 98       	lddsp	r8,sp[0x24]
80009e04:	58 08       	cp.w	r8,0
80009e06:	e0 8a 00 f1 	brle	80009fe8 <_dtoa_r+0x62c>
80009e0a:	30 08       	mov	r8,0
80009e0c:	fc 19 40 24 	movh	r9,0x4024
80009e10:	ec c4 00 01 	sub	r4,r6,1
80009e14:	fa ea 00 18 	ld.d	r10,sp[24]
80009e18:	2f f5       	sub	r5,-1
80009e1a:	50 64       	stdsp	sp[0x18],r4
80009e1c:	e0 a0 0c 38 	rcall	8000b68c <__avr32_f64_mul>
80009e20:	40 94       	lddsp	r4,sp[0x24]
80009e22:	14 98       	mov	r8,r10
80009e24:	16 99       	mov	r9,r11
80009e26:	fa e9 00 08 	st.d	sp[8],r8
80009e2a:	c0 38       	rjmp	80009e30 <_dtoa_r+0x474>
80009e2c:	50 66       	stdsp	sp[0x18],r6
80009e2e:	02 94       	mov	r4,r1
80009e30:	0a 9c       	mov	r12,r5
80009e32:	e0 a0 0e 88 	rcall	8000bb42 <__avr32_s32_to_f64>
80009e36:	fa e8 00 08 	ld.d	r8,sp[8]
80009e3a:	e0 a0 0c 29 	rcall	8000b68c <__avr32_f64_mul>
80009e3e:	30 08       	mov	r8,0
80009e40:	fc 19 40 1c 	movh	r9,0x401c
80009e44:	e0 a0 0d de 	rcall	8000ba00 <__avr32_f64_add>
80009e48:	14 98       	mov	r8,r10
80009e4a:	16 99       	mov	r9,r11
80009e4c:	fa e9 00 28 	st.d	sp[40],r8
80009e50:	fc 18 fc c0 	movh	r8,0xfcc0
80009e54:	40 a5       	lddsp	r5,sp[0x28]
80009e56:	10 05       	add	r5,r8
80009e58:	50 a5       	stdsp	sp[0x28],r5
80009e5a:	58 04       	cp.w	r4,0
80009e5c:	c2 11       	brne	80009e9e <_dtoa_r+0x4e2>
80009e5e:	fa ea 00 08 	ld.d	r10,sp[8]
80009e62:	30 08       	mov	r8,0
80009e64:	fc 19 40 14 	movh	r9,0x4014
80009e68:	e0 a0 0c fe 	rcall	8000b864 <__avr32_f64_sub>
80009e6c:	40 bc       	lddsp	r12,sp[0x2c]
80009e6e:	fa eb 00 08 	st.d	sp[8],r10
80009e72:	14 98       	mov	r8,r10
80009e74:	16 99       	mov	r9,r11
80009e76:	18 9a       	mov	r10,r12
80009e78:	0a 9b       	mov	r11,r5
80009e7a:	e0 a0 0f 1b 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009e7e:	e0 81 02 54 	brne	8000a326 <_dtoa_r+0x96a>
80009e82:	0a 98       	mov	r8,r5
80009e84:	40 b9       	lddsp	r9,sp[0x2c]
80009e86:	ee 18 80 00 	eorh	r8,0x8000
80009e8a:	fa ea 00 08 	ld.d	r10,sp[8]
80009e8e:	10 95       	mov	r5,r8
80009e90:	12 98       	mov	r8,r9
80009e92:	0a 99       	mov	r9,r5
80009e94:	e0 a0 0f 0e 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009e98:	e0 81 02 3e 	brne	8000a314 <_dtoa_r+0x958>
80009e9c:	ca 68       	rjmp	80009fe8 <_dtoa_r+0x62c>
80009e9e:	fe c9 c6 32 	sub	r9,pc,-14798
80009ea2:	e8 c8 00 01 	sub	r8,r4,1
80009ea6:	40 d5       	lddsp	r5,sp[0x34]
80009ea8:	58 05       	cp.w	r5,0
80009eaa:	c4 f0       	breq	80009f48 <_dtoa_r+0x58c>
80009eac:	30 0c       	mov	r12,0
80009eae:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009eb2:	51 3c       	stdsp	sp[0x4c],r12
80009eb4:	30 0a       	mov	r10,0
80009eb6:	fc 1b 3f e0 	movh	r11,0x3fe0
80009eba:	e0 a0 0f 2f 	rcall	8000bd18 <__avr32_f64_div>
80009ebe:	fa e8 00 28 	ld.d	r8,sp[40]
80009ec2:	40 85       	lddsp	r5,sp[0x20]
80009ec4:	e0 a0 0c d0 	rcall	8000b864 <__avr32_f64_sub>
80009ec8:	fa eb 00 28 	st.d	sp[40],r10
80009ecc:	fa ea 00 08 	ld.d	r10,sp[8]
80009ed0:	e0 a0 0e 22 	rcall	8000bb14 <__avr32_f64_to_s32>
80009ed4:	51 6c       	stdsp	sp[0x58],r12
80009ed6:	e0 a0 0e 36 	rcall	8000bb42 <__avr32_s32_to_f64>
80009eda:	14 98       	mov	r8,r10
80009edc:	16 99       	mov	r9,r11
80009ede:	fa ea 00 08 	ld.d	r10,sp[8]
80009ee2:	e0 a0 0c c1 	rcall	8000b864 <__avr32_f64_sub>
80009ee6:	fa eb 00 08 	st.d	sp[8],r10
80009eea:	41 68       	lddsp	r8,sp[0x58]
80009eec:	2d 08       	sub	r8,-48
80009eee:	0a c8       	st.b	r5++,r8
80009ef0:	41 39       	lddsp	r9,sp[0x4c]
80009ef2:	2f f9       	sub	r9,-1
80009ef4:	51 39       	stdsp	sp[0x4c],r9
80009ef6:	fa e8 00 28 	ld.d	r8,sp[40]
80009efa:	e0 a0 0e db 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009efe:	e0 81 03 39 	brne	8000a570 <_dtoa_r+0xbb4>
80009f02:	fa e8 00 08 	ld.d	r8,sp[8]
80009f06:	30 0a       	mov	r10,0
80009f08:	fc 1b 3f f0 	movh	r11,0x3ff0
80009f0c:	e0 a0 0c ac 	rcall	8000b864 <__avr32_f64_sub>
80009f10:	fa e8 00 28 	ld.d	r8,sp[40]
80009f14:	e0 a0 0e ce 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009f18:	fa ea 00 28 	ld.d	r10,sp[40]
80009f1c:	30 08       	mov	r8,0
80009f1e:	fc 19 40 24 	movh	r9,0x4024
80009f22:	e0 81 00 da 	brne	8000a0d6 <_dtoa_r+0x71a>
80009f26:	41 3c       	lddsp	r12,sp[0x4c]
80009f28:	08 3c       	cp.w	r12,r4
80009f2a:	c5 f4       	brge	80009fe8 <_dtoa_r+0x62c>
80009f2c:	e0 a0 0b b0 	rcall	8000b68c <__avr32_f64_mul>
80009f30:	30 08       	mov	r8,0
80009f32:	fa eb 00 28 	st.d	sp[40],r10
80009f36:	fc 19 40 24 	movh	r9,0x4024
80009f3a:	fa ea 00 08 	ld.d	r10,sp[8]
80009f3e:	e0 a0 0b a7 	rcall	8000b68c <__avr32_f64_mul>
80009f42:	fa eb 00 08 	st.d	sp[8],r10
80009f46:	cc 3b       	rjmp	80009ecc <_dtoa_r+0x510>
80009f48:	40 85       	lddsp	r5,sp[0x20]
80009f4a:	08 05       	add	r5,r4
80009f4c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009f50:	51 35       	stdsp	sp[0x4c],r5
80009f52:	fa e8 00 28 	ld.d	r8,sp[40]
80009f56:	40 85       	lddsp	r5,sp[0x20]
80009f58:	e0 a0 0b 9a 	rcall	8000b68c <__avr32_f64_mul>
80009f5c:	fa eb 00 28 	st.d	sp[40],r10
80009f60:	fa ea 00 08 	ld.d	r10,sp[8]
80009f64:	e0 a0 0d d8 	rcall	8000bb14 <__avr32_f64_to_s32>
80009f68:	51 6c       	stdsp	sp[0x58],r12
80009f6a:	e0 a0 0d ec 	rcall	8000bb42 <__avr32_s32_to_f64>
80009f6e:	14 98       	mov	r8,r10
80009f70:	16 99       	mov	r9,r11
80009f72:	fa ea 00 08 	ld.d	r10,sp[8]
80009f76:	e0 a0 0c 77 	rcall	8000b864 <__avr32_f64_sub>
80009f7a:	fa eb 00 08 	st.d	sp[8],r10
80009f7e:	41 68       	lddsp	r8,sp[0x58]
80009f80:	2d 08       	sub	r8,-48
80009f82:	0a c8       	st.b	r5++,r8
80009f84:	41 3c       	lddsp	r12,sp[0x4c]
80009f86:	18 35       	cp.w	r5,r12
80009f88:	c2 81       	brne	80009fd8 <_dtoa_r+0x61c>
80009f8a:	30 08       	mov	r8,0
80009f8c:	fc 19 3f e0 	movh	r9,0x3fe0
80009f90:	fa ea 00 28 	ld.d	r10,sp[40]
80009f94:	e0 a0 0d 36 	rcall	8000ba00 <__avr32_f64_add>
80009f98:	40 85       	lddsp	r5,sp[0x20]
80009f9a:	fa e8 00 08 	ld.d	r8,sp[8]
80009f9e:	08 05       	add	r5,r4
80009fa0:	e0 a0 0e 88 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009fa4:	e0 81 00 99 	brne	8000a0d6 <_dtoa_r+0x71a>
80009fa8:	fa e8 00 28 	ld.d	r8,sp[40]
80009fac:	30 0a       	mov	r10,0
80009fae:	fc 1b 3f e0 	movh	r11,0x3fe0
80009fb2:	e0 a0 0c 59 	rcall	8000b864 <__avr32_f64_sub>
80009fb6:	14 98       	mov	r8,r10
80009fb8:	16 99       	mov	r9,r11
80009fba:	fa ea 00 08 	ld.d	r10,sp[8]
80009fbe:	e0 a0 0e 79 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
80009fc2:	c1 30       	breq	80009fe8 <_dtoa_r+0x62c>
80009fc4:	33 09       	mov	r9,48
80009fc6:	0a 98       	mov	r8,r5
80009fc8:	11 7a       	ld.ub	r10,--r8
80009fca:	f2 0a 18 00 	cp.b	r10,r9
80009fce:	e0 81 02 d1 	brne	8000a570 <_dtoa_r+0xbb4>
80009fd2:	10 95       	mov	r5,r8
80009fd4:	cf 9b       	rjmp	80009fc6 <_dtoa_r+0x60a>
80009fd6:	d7 03       	nop
80009fd8:	30 08       	mov	r8,0
80009fda:	fc 19 40 24 	movh	r9,0x4024
80009fde:	e0 a0 0b 57 	rcall	8000b68c <__avr32_f64_mul>
80009fe2:	fa eb 00 08 	st.d	sp[8],r10
80009fe6:	cb db       	rjmp	80009f60 <_dtoa_r+0x5a4>
80009fe8:	fa ea 00 3c 	ld.d	r10,sp[60]
80009fec:	fa eb 00 08 	st.d	sp[8],r10
80009ff0:	58 e6       	cp.w	r6,14
80009ff2:	5f ab       	srle	r11
80009ff4:	41 8a       	lddsp	r10,sp[0x60]
80009ff6:	30 08       	mov	r8,0
80009ff8:	f4 09 11 ff 	rsub	r9,r10,-1
80009ffc:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a000:	f0 09 18 00 	cp.b	r9,r8
8000a004:	e0 80 00 82 	breq	8000a108 <_dtoa_r+0x74c>
8000a008:	40 ea       	lddsp	r10,sp[0x38]
8000a00a:	58 01       	cp.w	r1,0
8000a00c:	5f a9       	srle	r9
8000a00e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a012:	fe ca c7 a6 	sub	r10,pc,-14426
8000a016:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a01a:	fa e5 00 10 	st.d	sp[16],r4
8000a01e:	f0 09 18 00 	cp.b	r9,r8
8000a022:	c1 40       	breq	8000a04a <_dtoa_r+0x68e>
8000a024:	58 01       	cp.w	r1,0
8000a026:	e0 81 01 77 	brne	8000a314 <_dtoa_r+0x958>
8000a02a:	30 08       	mov	r8,0
8000a02c:	fc 19 40 14 	movh	r9,0x4014
8000a030:	08 9a       	mov	r10,r4
8000a032:	0a 9b       	mov	r11,r5
8000a034:	e0 a0 0b 2c 	rcall	8000b68c <__avr32_f64_mul>
8000a038:	fa e8 00 08 	ld.d	r8,sp[8]
8000a03c:	e0 a0 0e 06 	rcall	8000bc48 <__avr32_f64_cmp_ge>
8000a040:	e0 81 01 6a 	brne	8000a314 <_dtoa_r+0x958>
8000a044:	02 92       	mov	r2,r1
8000a046:	e0 8f 01 72 	bral	8000a32a <_dtoa_r+0x96e>
8000a04a:	40 85       	lddsp	r5,sp[0x20]
8000a04c:	30 14       	mov	r4,1
8000a04e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a052:	fa ea 00 08 	ld.d	r10,sp[8]
8000a056:	e0 a0 0e 61 	rcall	8000bd18 <__avr32_f64_div>
8000a05a:	e0 a0 0d 5d 	rcall	8000bb14 <__avr32_f64_to_s32>
8000a05e:	18 92       	mov	r2,r12
8000a060:	e0 a0 0d 71 	rcall	8000bb42 <__avr32_s32_to_f64>
8000a064:	fa e8 00 10 	ld.d	r8,sp[16]
8000a068:	e0 a0 0b 12 	rcall	8000b68c <__avr32_f64_mul>
8000a06c:	14 98       	mov	r8,r10
8000a06e:	16 99       	mov	r9,r11
8000a070:	fa ea 00 08 	ld.d	r10,sp[8]
8000a074:	e0 a0 0b f8 	rcall	8000b864 <__avr32_f64_sub>
8000a078:	fa eb 00 08 	st.d	sp[8],r10
8000a07c:	e4 c8 ff d0 	sub	r8,r2,-48
8000a080:	0a c8       	st.b	r5++,r8
8000a082:	fc 19 40 24 	movh	r9,0x4024
8000a086:	30 08       	mov	r8,0
8000a088:	02 34       	cp.w	r4,r1
8000a08a:	c3 31       	brne	8000a0f0 <_dtoa_r+0x734>
8000a08c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a090:	e0 a0 0c b8 	rcall	8000ba00 <__avr32_f64_add>
8000a094:	16 91       	mov	r1,r11
8000a096:	14 90       	mov	r0,r10
8000a098:	14 98       	mov	r8,r10
8000a09a:	02 99       	mov	r9,r1
8000a09c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a0a0:	e0 a0 0e 08 	rcall	8000bcb0 <__avr32_f64_cmp_lt>
8000a0a4:	c1 a1       	brne	8000a0d8 <_dtoa_r+0x71c>
8000a0a6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a0aa:	00 9a       	mov	r10,r0
8000a0ac:	02 9b       	mov	r11,r1
8000a0ae:	e0 a0 0d ba 	rcall	8000bc22 <__avr32_f64_cmp_eq>
8000a0b2:	e0 80 02 5e 	breq	8000a56e <_dtoa_r+0xbb2>
8000a0b6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a0ba:	c0 f1       	brne	8000a0d8 <_dtoa_r+0x71c>
8000a0bc:	e0 8f 02 59 	bral	8000a56e <_dtoa_r+0xbb2>
8000a0c0:	40 8a       	lddsp	r10,sp[0x20]
8000a0c2:	14 38       	cp.w	r8,r10
8000a0c4:	c0 30       	breq	8000a0ca <_dtoa_r+0x70e>
8000a0c6:	10 95       	mov	r5,r8
8000a0c8:	c0 98       	rjmp	8000a0da <_dtoa_r+0x71e>
8000a0ca:	33 08       	mov	r8,48
8000a0cc:	40 89       	lddsp	r9,sp[0x20]
8000a0ce:	2f f6       	sub	r6,-1
8000a0d0:	b2 88       	st.b	r9[0x0],r8
8000a0d2:	40 88       	lddsp	r8,sp[0x20]
8000a0d4:	c0 88       	rjmp	8000a0e4 <_dtoa_r+0x728>
8000a0d6:	40 66       	lddsp	r6,sp[0x18]
8000a0d8:	33 99       	mov	r9,57
8000a0da:	0a 98       	mov	r8,r5
8000a0dc:	11 7a       	ld.ub	r10,--r8
8000a0de:	f2 0a 18 00 	cp.b	r10,r9
8000a0e2:	ce f0       	breq	8000a0c0 <_dtoa_r+0x704>
8000a0e4:	50 66       	stdsp	sp[0x18],r6
8000a0e6:	11 89       	ld.ub	r9,r8[0x0]
8000a0e8:	2f f9       	sub	r9,-1
8000a0ea:	b0 89       	st.b	r8[0x0],r9
8000a0ec:	e0 8f 02 42 	bral	8000a570 <_dtoa_r+0xbb4>
8000a0f0:	e0 a0 0a ce 	rcall	8000b68c <__avr32_f64_mul>
8000a0f4:	2f f4       	sub	r4,-1
8000a0f6:	fa eb 00 08 	st.d	sp[8],r10
8000a0fa:	30 08       	mov	r8,0
8000a0fc:	30 09       	mov	r9,0
8000a0fe:	e0 a0 0d 92 	rcall	8000bc22 <__avr32_f64_cmp_eq>
8000a102:	ca 60       	breq	8000a04e <_dtoa_r+0x692>
8000a104:	e0 8f 02 35 	bral	8000a56e <_dtoa_r+0xbb2>
8000a108:	40 d8       	lddsp	r8,sp[0x34]
8000a10a:	58 08       	cp.w	r8,0
8000a10c:	c0 51       	brne	8000a116 <_dtoa_r+0x75a>
8000a10e:	04 98       	mov	r8,r2
8000a110:	00 95       	mov	r5,r0
8000a112:	40 d4       	lddsp	r4,sp[0x34]
8000a114:	c3 78       	rjmp	8000a182 <_dtoa_r+0x7c6>
8000a116:	40 c5       	lddsp	r5,sp[0x30]
8000a118:	58 15       	cp.w	r5,1
8000a11a:	e0 89 00 0f 	brgt	8000a138 <_dtoa_r+0x77c>
8000a11e:	41 74       	lddsp	r4,sp[0x5c]
8000a120:	58 04       	cp.w	r4,0
8000a122:	c0 40       	breq	8000a12a <_dtoa_r+0x76e>
8000a124:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a128:	c0 48       	rjmp	8000a130 <_dtoa_r+0x774>
8000a12a:	41 99       	lddsp	r9,sp[0x64]
8000a12c:	f2 09 11 36 	rsub	r9,r9,54
8000a130:	04 98       	mov	r8,r2
8000a132:	00 95       	mov	r5,r0
8000a134:	c1 c8       	rjmp	8000a16c <_dtoa_r+0x7b0>
8000a136:	d7 03       	nop
8000a138:	e2 c8 00 01 	sub	r8,r1,1
8000a13c:	58 01       	cp.w	r1,0
8000a13e:	e0 05 17 40 	movge	r5,r0
8000a142:	e2 09 17 40 	movge	r9,r1
8000a146:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a14a:	f9 b9 05 00 	movlt	r9,0
8000a14e:	10 32       	cp.w	r2,r8
8000a150:	e5 d8 e4 18 	subge	r8,r2,r8
8000a154:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a158:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a15c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a160:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a164:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a168:	f9 b8 05 00 	movlt	r8,0
8000a16c:	40 4b       	lddsp	r11,sp[0x10]
8000a16e:	12 0b       	add	r11,r9
8000a170:	50 08       	stdsp	sp[0x0],r8
8000a172:	50 4b       	stdsp	sp[0x10],r11
8000a174:	12 00       	add	r0,r9
8000a176:	30 1b       	mov	r11,1
8000a178:	0e 9c       	mov	r12,r7
8000a17a:	e0 a0 08 a7 	rcall	8000b2c8 <__i2b>
8000a17e:	40 08       	lddsp	r8,sp[0x0]
8000a180:	18 94       	mov	r4,r12
8000a182:	40 4a       	lddsp	r10,sp[0x10]
8000a184:	58 05       	cp.w	r5,0
8000a186:	5f 99       	srgt	r9
8000a188:	58 0a       	cp.w	r10,0
8000a18a:	5f 9a       	srgt	r10
8000a18c:	f5 e9 00 09 	and	r9,r10,r9
8000a190:	c0 80       	breq	8000a1a0 <_dtoa_r+0x7e4>
8000a192:	40 4c       	lddsp	r12,sp[0x10]
8000a194:	f8 05 0d 49 	min	r9,r12,r5
8000a198:	12 1c       	sub	r12,r9
8000a19a:	12 10       	sub	r0,r9
8000a19c:	50 4c       	stdsp	sp[0x10],r12
8000a19e:	12 15       	sub	r5,r9
8000a1a0:	58 02       	cp.w	r2,0
8000a1a2:	e0 8a 00 27 	brle	8000a1f0 <_dtoa_r+0x834>
8000a1a6:	40 db       	lddsp	r11,sp[0x34]
8000a1a8:	58 0b       	cp.w	r11,0
8000a1aa:	c1 d0       	breq	8000a1e4 <_dtoa_r+0x828>
8000a1ac:	58 08       	cp.w	r8,0
8000a1ae:	e0 8a 00 17 	brle	8000a1dc <_dtoa_r+0x820>
8000a1b2:	10 9a       	mov	r10,r8
8000a1b4:	50 08       	stdsp	sp[0x0],r8
8000a1b6:	08 9b       	mov	r11,r4
8000a1b8:	0e 9c       	mov	r12,r7
8000a1ba:	e0 a0 08 cd 	rcall	8000b354 <__pow5mult>
8000a1be:	06 9a       	mov	r10,r3
8000a1c0:	18 9b       	mov	r11,r12
8000a1c2:	18 94       	mov	r4,r12
8000a1c4:	0e 9c       	mov	r12,r7
8000a1c6:	e0 a0 08 01 	rcall	8000b1c8 <__multiply>
8000a1ca:	18 99       	mov	r9,r12
8000a1cc:	06 9b       	mov	r11,r3
8000a1ce:	50 19       	stdsp	sp[0x4],r9
8000a1d0:	0e 9c       	mov	r12,r7
8000a1d2:	e0 a0 06 ad 	rcall	8000af2c <_Bfree>
8000a1d6:	40 19       	lddsp	r9,sp[0x4]
8000a1d8:	40 08       	lddsp	r8,sp[0x0]
8000a1da:	12 93       	mov	r3,r9
8000a1dc:	e4 08 01 0a 	sub	r10,r2,r8
8000a1e0:	c0 80       	breq	8000a1f0 <_dtoa_r+0x834>
8000a1e2:	c0 28       	rjmp	8000a1e6 <_dtoa_r+0x82a>
8000a1e4:	04 9a       	mov	r10,r2
8000a1e6:	06 9b       	mov	r11,r3
8000a1e8:	0e 9c       	mov	r12,r7
8000a1ea:	e0 a0 08 b5 	rcall	8000b354 <__pow5mult>
8000a1ee:	18 93       	mov	r3,r12
8000a1f0:	30 1b       	mov	r11,1
8000a1f2:	0e 9c       	mov	r12,r7
8000a1f4:	e0 a0 08 6a 	rcall	8000b2c8 <__i2b>
8000a1f8:	41 1a       	lddsp	r10,sp[0x44]
8000a1fa:	18 92       	mov	r2,r12
8000a1fc:	58 0a       	cp.w	r10,0
8000a1fe:	e0 8a 00 07 	brle	8000a20c <_dtoa_r+0x850>
8000a202:	18 9b       	mov	r11,r12
8000a204:	0e 9c       	mov	r12,r7
8000a206:	e0 a0 08 a7 	rcall	8000b354 <__pow5mult>
8000a20a:	18 92       	mov	r2,r12
8000a20c:	40 c9       	lddsp	r9,sp[0x30]
8000a20e:	58 19       	cp.w	r9,1
8000a210:	e0 89 00 14 	brgt	8000a238 <_dtoa_r+0x87c>
8000a214:	40 38       	lddsp	r8,sp[0xc]
8000a216:	58 08       	cp.w	r8,0
8000a218:	c1 01       	brne	8000a238 <_dtoa_r+0x87c>
8000a21a:	40 29       	lddsp	r9,sp[0x8]
8000a21c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a220:	c0 c1       	brne	8000a238 <_dtoa_r+0x87c>
8000a222:	12 98       	mov	r8,r9
8000a224:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a228:	c0 80       	breq	8000a238 <_dtoa_r+0x87c>
8000a22a:	40 4c       	lddsp	r12,sp[0x10]
8000a22c:	30 1b       	mov	r11,1
8000a22e:	2f fc       	sub	r12,-1
8000a230:	2f f0       	sub	r0,-1
8000a232:	50 4c       	stdsp	sp[0x10],r12
8000a234:	50 6b       	stdsp	sp[0x18],r11
8000a236:	c0 38       	rjmp	8000a23c <_dtoa_r+0x880>
8000a238:	30 0a       	mov	r10,0
8000a23a:	50 6a       	stdsp	sp[0x18],r10
8000a23c:	41 19       	lddsp	r9,sp[0x44]
8000a23e:	58 09       	cp.w	r9,0
8000a240:	c0 31       	brne	8000a246 <_dtoa_r+0x88a>
8000a242:	30 1c       	mov	r12,1
8000a244:	c0 98       	rjmp	8000a256 <_dtoa_r+0x89a>
8000a246:	64 48       	ld.w	r8,r2[0x10]
8000a248:	2f c8       	sub	r8,-4
8000a24a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a24e:	e0 a0 05 df 	rcall	8000ae0c <__hi0bits>
8000a252:	f8 0c 11 20 	rsub	r12,r12,32
8000a256:	40 4b       	lddsp	r11,sp[0x10]
8000a258:	f8 0b 00 08 	add	r8,r12,r11
8000a25c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a260:	c0 c0       	breq	8000a278 <_dtoa_r+0x8bc>
8000a262:	f0 08 11 20 	rsub	r8,r8,32
8000a266:	58 48       	cp.w	r8,4
8000a268:	e0 8a 00 06 	brle	8000a274 <_dtoa_r+0x8b8>
8000a26c:	20 48       	sub	r8,4
8000a26e:	10 0b       	add	r11,r8
8000a270:	50 4b       	stdsp	sp[0x10],r11
8000a272:	c0 78       	rjmp	8000a280 <_dtoa_r+0x8c4>
8000a274:	58 48       	cp.w	r8,4
8000a276:	c0 70       	breq	8000a284 <_dtoa_r+0x8c8>
8000a278:	40 4a       	lddsp	r10,sp[0x10]
8000a27a:	2e 48       	sub	r8,-28
8000a27c:	10 0a       	add	r10,r8
8000a27e:	50 4a       	stdsp	sp[0x10],r10
8000a280:	10 00       	add	r0,r8
8000a282:	10 05       	add	r5,r8
8000a284:	58 00       	cp.w	r0,0
8000a286:	e0 8a 00 08 	brle	8000a296 <_dtoa_r+0x8da>
8000a28a:	06 9b       	mov	r11,r3
8000a28c:	00 9a       	mov	r10,r0
8000a28e:	0e 9c       	mov	r12,r7
8000a290:	e0 a0 07 58 	rcall	8000b140 <__lshift>
8000a294:	18 93       	mov	r3,r12
8000a296:	40 49       	lddsp	r9,sp[0x10]
8000a298:	58 09       	cp.w	r9,0
8000a29a:	e0 8a 00 08 	brle	8000a2aa <_dtoa_r+0x8ee>
8000a29e:	04 9b       	mov	r11,r2
8000a2a0:	12 9a       	mov	r10,r9
8000a2a2:	0e 9c       	mov	r12,r7
8000a2a4:	e0 a0 07 4e 	rcall	8000b140 <__lshift>
8000a2a8:	18 92       	mov	r2,r12
8000a2aa:	41 48       	lddsp	r8,sp[0x50]
8000a2ac:	58 08       	cp.w	r8,0
8000a2ae:	c1 b0       	breq	8000a2e4 <_dtoa_r+0x928>
8000a2b0:	04 9b       	mov	r11,r2
8000a2b2:	06 9c       	mov	r12,r3
8000a2b4:	e0 a0 06 23 	rcall	8000aefa <__mcmp>
8000a2b8:	c1 64       	brge	8000a2e4 <_dtoa_r+0x928>
8000a2ba:	06 9b       	mov	r11,r3
8000a2bc:	30 09       	mov	r9,0
8000a2be:	30 aa       	mov	r10,10
8000a2c0:	0e 9c       	mov	r12,r7
8000a2c2:	e0 a0 08 0b 	rcall	8000b2d8 <__multadd>
8000a2c6:	20 16       	sub	r6,1
8000a2c8:	18 93       	mov	r3,r12
8000a2ca:	40 dc       	lddsp	r12,sp[0x34]
8000a2cc:	58 0c       	cp.w	r12,0
8000a2ce:	c0 31       	brne	8000a2d4 <_dtoa_r+0x918>
8000a2d0:	40 91       	lddsp	r1,sp[0x24]
8000a2d2:	c0 98       	rjmp	8000a2e4 <_dtoa_r+0x928>
8000a2d4:	08 9b       	mov	r11,r4
8000a2d6:	40 91       	lddsp	r1,sp[0x24]
8000a2d8:	30 09       	mov	r9,0
8000a2da:	30 aa       	mov	r10,10
8000a2dc:	0e 9c       	mov	r12,r7
8000a2de:	e0 a0 07 fd 	rcall	8000b2d8 <__multadd>
8000a2e2:	18 94       	mov	r4,r12
8000a2e4:	58 01       	cp.w	r1,0
8000a2e6:	5f a9       	srle	r9
8000a2e8:	40 cb       	lddsp	r11,sp[0x30]
8000a2ea:	58 2b       	cp.w	r11,2
8000a2ec:	5f 98       	srgt	r8
8000a2ee:	f3 e8 00 08 	and	r8,r9,r8
8000a2f2:	c2 50       	breq	8000a33c <_dtoa_r+0x980>
8000a2f4:	58 01       	cp.w	r1,0
8000a2f6:	c1 11       	brne	8000a318 <_dtoa_r+0x95c>
8000a2f8:	04 9b       	mov	r11,r2
8000a2fa:	02 99       	mov	r9,r1
8000a2fc:	30 5a       	mov	r10,5
8000a2fe:	0e 9c       	mov	r12,r7
8000a300:	e0 a0 07 ec 	rcall	8000b2d8 <__multadd>
8000a304:	18 92       	mov	r2,r12
8000a306:	18 9b       	mov	r11,r12
8000a308:	06 9c       	mov	r12,r3
8000a30a:	e0 a0 05 f8 	rcall	8000aefa <__mcmp>
8000a30e:	e0 89 00 0f 	brgt	8000a32c <_dtoa_r+0x970>
8000a312:	c0 38       	rjmp	8000a318 <_dtoa_r+0x95c>
8000a314:	30 02       	mov	r2,0
8000a316:	04 94       	mov	r4,r2
8000a318:	40 ea       	lddsp	r10,sp[0x38]
8000a31a:	30 09       	mov	r9,0
8000a31c:	5c da       	com	r10
8000a31e:	40 85       	lddsp	r5,sp[0x20]
8000a320:	50 6a       	stdsp	sp[0x18],r10
8000a322:	50 49       	stdsp	sp[0x10],r9
8000a324:	c0 f9       	rjmp	8000a542 <_dtoa_r+0xb86>
8000a326:	08 92       	mov	r2,r4
8000a328:	40 66       	lddsp	r6,sp[0x18]
8000a32a:	04 94       	mov	r4,r2
8000a32c:	2f f6       	sub	r6,-1
8000a32e:	50 66       	stdsp	sp[0x18],r6
8000a330:	33 18       	mov	r8,49
8000a332:	40 85       	lddsp	r5,sp[0x20]
8000a334:	0a c8       	st.b	r5++,r8
8000a336:	30 08       	mov	r8,0
8000a338:	50 48       	stdsp	sp[0x10],r8
8000a33a:	c0 49       	rjmp	8000a542 <_dtoa_r+0xb86>
8000a33c:	40 dc       	lddsp	r12,sp[0x34]
8000a33e:	58 0c       	cp.w	r12,0
8000a340:	e0 80 00 b5 	breq	8000a4aa <_dtoa_r+0xaee>
8000a344:	58 05       	cp.w	r5,0
8000a346:	e0 8a 00 08 	brle	8000a356 <_dtoa_r+0x99a>
8000a34a:	08 9b       	mov	r11,r4
8000a34c:	0a 9a       	mov	r10,r5
8000a34e:	0e 9c       	mov	r12,r7
8000a350:	e0 a0 06 f8 	rcall	8000b140 <__lshift>
8000a354:	18 94       	mov	r4,r12
8000a356:	40 6b       	lddsp	r11,sp[0x18]
8000a358:	58 0b       	cp.w	r11,0
8000a35a:	c0 31       	brne	8000a360 <_dtoa_r+0x9a4>
8000a35c:	08 9c       	mov	r12,r4
8000a35e:	c1 38       	rjmp	8000a384 <_dtoa_r+0x9c8>
8000a360:	68 1b       	ld.w	r11,r4[0x4]
8000a362:	0e 9c       	mov	r12,r7
8000a364:	e0 a0 05 fe 	rcall	8000af60 <_Balloc>
8000a368:	68 4a       	ld.w	r10,r4[0x10]
8000a36a:	18 95       	mov	r5,r12
8000a36c:	e8 cb ff f4 	sub	r11,r4,-12
8000a370:	2f ea       	sub	r10,-2
8000a372:	2f 4c       	sub	r12,-12
8000a374:	a3 6a       	lsl	r10,0x2
8000a376:	fe b0 e6 50 	rcall	80007016 <memcpy>
8000a37a:	0a 9b       	mov	r11,r5
8000a37c:	30 1a       	mov	r10,1
8000a37e:	0e 9c       	mov	r12,r7
8000a380:	e0 a0 06 e0 	rcall	8000b140 <__lshift>
8000a384:	50 44       	stdsp	sp[0x10],r4
8000a386:	40 3a       	lddsp	r10,sp[0xc]
8000a388:	30 19       	mov	r9,1
8000a38a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a38e:	18 94       	mov	r4,r12
8000a390:	50 da       	stdsp	sp[0x34],r10
8000a392:	40 85       	lddsp	r5,sp[0x20]
8000a394:	50 99       	stdsp	sp[0x24],r9
8000a396:	50 26       	stdsp	sp[0x8],r6
8000a398:	50 e1       	stdsp	sp[0x38],r1
8000a39a:	04 9b       	mov	r11,r2
8000a39c:	06 9c       	mov	r12,r3
8000a39e:	fe b0 fa 7f 	rcall	8000989c <quorem>
8000a3a2:	40 4b       	lddsp	r11,sp[0x10]
8000a3a4:	f8 c0 ff d0 	sub	r0,r12,-48
8000a3a8:	06 9c       	mov	r12,r3
8000a3aa:	e0 a0 05 a8 	rcall	8000aefa <__mcmp>
8000a3ae:	08 9a       	mov	r10,r4
8000a3b0:	50 6c       	stdsp	sp[0x18],r12
8000a3b2:	04 9b       	mov	r11,r2
8000a3b4:	0e 9c       	mov	r12,r7
8000a3b6:	e0 a0 06 5d 	rcall	8000b070 <__mdiff>
8000a3ba:	18 91       	mov	r1,r12
8000a3bc:	78 38       	ld.w	r8,r12[0xc]
8000a3be:	58 08       	cp.w	r8,0
8000a3c0:	c0 30       	breq	8000a3c6 <_dtoa_r+0xa0a>
8000a3c2:	30 16       	mov	r6,1
8000a3c4:	c0 68       	rjmp	8000a3d0 <_dtoa_r+0xa14>
8000a3c6:	18 9b       	mov	r11,r12
8000a3c8:	06 9c       	mov	r12,r3
8000a3ca:	e0 a0 05 98 	rcall	8000aefa <__mcmp>
8000a3ce:	18 96       	mov	r6,r12
8000a3d0:	0e 9c       	mov	r12,r7
8000a3d2:	02 9b       	mov	r11,r1
8000a3d4:	e0 a0 05 ac 	rcall	8000af2c <_Bfree>
8000a3d8:	40 cc       	lddsp	r12,sp[0x30]
8000a3da:	ed ec 10 08 	or	r8,r6,r12
8000a3de:	c0 d1       	brne	8000a3f8 <_dtoa_r+0xa3c>
8000a3e0:	40 db       	lddsp	r11,sp[0x34]
8000a3e2:	58 0b       	cp.w	r11,0
8000a3e4:	c0 a1       	brne	8000a3f8 <_dtoa_r+0xa3c>
8000a3e6:	40 26       	lddsp	r6,sp[0x8]
8000a3e8:	e0 40 00 39 	cp.w	r0,57
8000a3ec:	c3 00       	breq	8000a44c <_dtoa_r+0xa90>
8000a3ee:	40 6a       	lddsp	r10,sp[0x18]
8000a3f0:	58 0a       	cp.w	r10,0
8000a3f2:	e0 89 00 24 	brgt	8000a43a <_dtoa_r+0xa7e>
8000a3f6:	c2 f8       	rjmp	8000a454 <_dtoa_r+0xa98>
8000a3f8:	40 69       	lddsp	r9,sp[0x18]
8000a3fa:	58 09       	cp.w	r9,0
8000a3fc:	c0 85       	brlt	8000a40c <_dtoa_r+0xa50>
8000a3fe:	12 98       	mov	r8,r9
8000a400:	40 cc       	lddsp	r12,sp[0x30]
8000a402:	18 48       	or	r8,r12
8000a404:	c1 d1       	brne	8000a43e <_dtoa_r+0xa82>
8000a406:	40 db       	lddsp	r11,sp[0x34]
8000a408:	58 0b       	cp.w	r11,0
8000a40a:	c1 a1       	brne	8000a43e <_dtoa_r+0xa82>
8000a40c:	0c 99       	mov	r9,r6
8000a40e:	40 26       	lddsp	r6,sp[0x8]
8000a410:	58 09       	cp.w	r9,0
8000a412:	e0 8a 00 21 	brle	8000a454 <_dtoa_r+0xa98>
8000a416:	06 9b       	mov	r11,r3
8000a418:	30 1a       	mov	r10,1
8000a41a:	0e 9c       	mov	r12,r7
8000a41c:	e0 a0 06 92 	rcall	8000b140 <__lshift>
8000a420:	04 9b       	mov	r11,r2
8000a422:	18 93       	mov	r3,r12
8000a424:	e0 a0 05 6b 	rcall	8000aefa <__mcmp>
8000a428:	e0 89 00 06 	brgt	8000a434 <_dtoa_r+0xa78>
8000a42c:	c1 41       	brne	8000a454 <_dtoa_r+0xa98>
8000a42e:	ed b0 00 00 	bld	r0,0x0
8000a432:	c1 11       	brne	8000a454 <_dtoa_r+0xa98>
8000a434:	e0 40 00 39 	cp.w	r0,57
8000a438:	c0 a0       	breq	8000a44c <_dtoa_r+0xa90>
8000a43a:	2f f0       	sub	r0,-1
8000a43c:	c0 c8       	rjmp	8000a454 <_dtoa_r+0xa98>
8000a43e:	58 06       	cp.w	r6,0
8000a440:	e0 8a 00 0c 	brle	8000a458 <_dtoa_r+0xa9c>
8000a444:	40 26       	lddsp	r6,sp[0x8]
8000a446:	e0 40 00 39 	cp.w	r0,57
8000a44a:	c0 41       	brne	8000a452 <_dtoa_r+0xa96>
8000a44c:	33 98       	mov	r8,57
8000a44e:	0a c8       	st.b	r5++,r8
8000a450:	c6 78       	rjmp	8000a51e <_dtoa_r+0xb62>
8000a452:	2f f0       	sub	r0,-1
8000a454:	0a c0       	st.b	r5++,r0
8000a456:	c7 58       	rjmp	8000a540 <_dtoa_r+0xb84>
8000a458:	0a c0       	st.b	r5++,r0
8000a45a:	40 9a       	lddsp	r10,sp[0x24]
8000a45c:	40 e9       	lddsp	r9,sp[0x38]
8000a45e:	12 3a       	cp.w	r10,r9
8000a460:	c4 30       	breq	8000a4e6 <_dtoa_r+0xb2a>
8000a462:	06 9b       	mov	r11,r3
8000a464:	30 09       	mov	r9,0
8000a466:	30 aa       	mov	r10,10
8000a468:	0e 9c       	mov	r12,r7
8000a46a:	e0 a0 07 37 	rcall	8000b2d8 <__multadd>
8000a46e:	40 48       	lddsp	r8,sp[0x10]
8000a470:	18 93       	mov	r3,r12
8000a472:	08 38       	cp.w	r8,r4
8000a474:	c0 91       	brne	8000a486 <_dtoa_r+0xaca>
8000a476:	10 9b       	mov	r11,r8
8000a478:	30 09       	mov	r9,0
8000a47a:	30 aa       	mov	r10,10
8000a47c:	0e 9c       	mov	r12,r7
8000a47e:	e0 a0 07 2d 	rcall	8000b2d8 <__multadd>
8000a482:	50 4c       	stdsp	sp[0x10],r12
8000a484:	c0 e8       	rjmp	8000a4a0 <_dtoa_r+0xae4>
8000a486:	40 4b       	lddsp	r11,sp[0x10]
8000a488:	30 09       	mov	r9,0
8000a48a:	30 aa       	mov	r10,10
8000a48c:	0e 9c       	mov	r12,r7
8000a48e:	e0 a0 07 25 	rcall	8000b2d8 <__multadd>
8000a492:	08 9b       	mov	r11,r4
8000a494:	50 4c       	stdsp	sp[0x10],r12
8000a496:	30 09       	mov	r9,0
8000a498:	30 aa       	mov	r10,10
8000a49a:	0e 9c       	mov	r12,r7
8000a49c:	e0 a0 07 1e 	rcall	8000b2d8 <__multadd>
8000a4a0:	18 94       	mov	r4,r12
8000a4a2:	40 9c       	lddsp	r12,sp[0x24]
8000a4a4:	2f fc       	sub	r12,-1
8000a4a6:	50 9c       	stdsp	sp[0x24],r12
8000a4a8:	c7 9b       	rjmp	8000a39a <_dtoa_r+0x9de>
8000a4aa:	30 18       	mov	r8,1
8000a4ac:	06 90       	mov	r0,r3
8000a4ae:	40 85       	lddsp	r5,sp[0x20]
8000a4b0:	08 93       	mov	r3,r4
8000a4b2:	0c 94       	mov	r4,r6
8000a4b4:	10 96       	mov	r6,r8
8000a4b6:	04 9b       	mov	r11,r2
8000a4b8:	00 9c       	mov	r12,r0
8000a4ba:	fe b0 f9 f1 	rcall	8000989c <quorem>
8000a4be:	2d 0c       	sub	r12,-48
8000a4c0:	0a cc       	st.b	r5++,r12
8000a4c2:	02 36       	cp.w	r6,r1
8000a4c4:	c0 a4       	brge	8000a4d8 <_dtoa_r+0xb1c>
8000a4c6:	00 9b       	mov	r11,r0
8000a4c8:	30 09       	mov	r9,0
8000a4ca:	30 aa       	mov	r10,10
8000a4cc:	0e 9c       	mov	r12,r7
8000a4ce:	2f f6       	sub	r6,-1
8000a4d0:	e0 a0 07 04 	rcall	8000b2d8 <__multadd>
8000a4d4:	18 90       	mov	r0,r12
8000a4d6:	cf 0b       	rjmp	8000a4b6 <_dtoa_r+0xafa>
8000a4d8:	08 96       	mov	r6,r4
8000a4da:	30 0b       	mov	r11,0
8000a4dc:	06 94       	mov	r4,r3
8000a4de:	50 4b       	stdsp	sp[0x10],r11
8000a4e0:	00 93       	mov	r3,r0
8000a4e2:	18 90       	mov	r0,r12
8000a4e4:	c0 28       	rjmp	8000a4e8 <_dtoa_r+0xb2c>
8000a4e6:	40 26       	lddsp	r6,sp[0x8]
8000a4e8:	06 9b       	mov	r11,r3
8000a4ea:	30 1a       	mov	r10,1
8000a4ec:	0e 9c       	mov	r12,r7
8000a4ee:	e0 a0 06 29 	rcall	8000b140 <__lshift>
8000a4f2:	04 9b       	mov	r11,r2
8000a4f4:	18 93       	mov	r3,r12
8000a4f6:	e0 a0 05 02 	rcall	8000aefa <__mcmp>
8000a4fa:	e0 89 00 12 	brgt	8000a51e <_dtoa_r+0xb62>
8000a4fe:	c1 b1       	brne	8000a534 <_dtoa_r+0xb78>
8000a500:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a504:	c0 d1       	brne	8000a51e <_dtoa_r+0xb62>
8000a506:	c1 78       	rjmp	8000a534 <_dtoa_r+0xb78>
8000a508:	40 89       	lddsp	r9,sp[0x20]
8000a50a:	12 38       	cp.w	r8,r9
8000a50c:	c0 30       	breq	8000a512 <_dtoa_r+0xb56>
8000a50e:	10 95       	mov	r5,r8
8000a510:	c0 88       	rjmp	8000a520 <_dtoa_r+0xb64>
8000a512:	2f f6       	sub	r6,-1
8000a514:	50 66       	stdsp	sp[0x18],r6
8000a516:	33 18       	mov	r8,49
8000a518:	40 8c       	lddsp	r12,sp[0x20]
8000a51a:	b8 88       	st.b	r12[0x0],r8
8000a51c:	c1 38       	rjmp	8000a542 <_dtoa_r+0xb86>
8000a51e:	33 9a       	mov	r10,57
8000a520:	0a 98       	mov	r8,r5
8000a522:	11 79       	ld.ub	r9,--r8
8000a524:	f4 09 18 00 	cp.b	r9,r10
8000a528:	cf 00       	breq	8000a508 <_dtoa_r+0xb4c>
8000a52a:	2f f9       	sub	r9,-1
8000a52c:	b0 89       	st.b	r8[0x0],r9
8000a52e:	c0 98       	rjmp	8000a540 <_dtoa_r+0xb84>
8000a530:	10 95       	mov	r5,r8
8000a532:	c0 28       	rjmp	8000a536 <_dtoa_r+0xb7a>
8000a534:	33 09       	mov	r9,48
8000a536:	0a 98       	mov	r8,r5
8000a538:	11 7a       	ld.ub	r10,--r8
8000a53a:	f2 0a 18 00 	cp.b	r10,r9
8000a53e:	cf 90       	breq	8000a530 <_dtoa_r+0xb74>
8000a540:	50 66       	stdsp	sp[0x18],r6
8000a542:	04 9b       	mov	r11,r2
8000a544:	0e 9c       	mov	r12,r7
8000a546:	e0 a0 04 f3 	rcall	8000af2c <_Bfree>
8000a54a:	58 04       	cp.w	r4,0
8000a54c:	c1 20       	breq	8000a570 <_dtoa_r+0xbb4>
8000a54e:	40 4b       	lddsp	r11,sp[0x10]
8000a550:	08 3b       	cp.w	r11,r4
8000a552:	5f 19       	srne	r9
8000a554:	58 0b       	cp.w	r11,0
8000a556:	5f 18       	srne	r8
8000a558:	f3 e8 00 08 	and	r8,r9,r8
8000a55c:	c0 40       	breq	8000a564 <_dtoa_r+0xba8>
8000a55e:	0e 9c       	mov	r12,r7
8000a560:	e0 a0 04 e6 	rcall	8000af2c <_Bfree>
8000a564:	08 9b       	mov	r11,r4
8000a566:	0e 9c       	mov	r12,r7
8000a568:	e0 a0 04 e2 	rcall	8000af2c <_Bfree>
8000a56c:	c0 28       	rjmp	8000a570 <_dtoa_r+0xbb4>
8000a56e:	50 66       	stdsp	sp[0x18],r6
8000a570:	0e 9c       	mov	r12,r7
8000a572:	06 9b       	mov	r11,r3
8000a574:	e0 a0 04 dc 	rcall	8000af2c <_Bfree>
8000a578:	30 08       	mov	r8,0
8000a57a:	aa 88       	st.b	r5[0x0],r8
8000a57c:	40 68       	lddsp	r8,sp[0x18]
8000a57e:	41 5a       	lddsp	r10,sp[0x54]
8000a580:	2f f8       	sub	r8,-1
8000a582:	41 29       	lddsp	r9,sp[0x48]
8000a584:	95 08       	st.w	r10[0x0],r8
8000a586:	40 8c       	lddsp	r12,sp[0x20]
8000a588:	58 09       	cp.w	r9,0
8000a58a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a58e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a592:	2e 6d       	sub	sp,-104
8000a594:	d8 32       	popm	r0-r7,pc
8000a596:	d7 03       	nop

8000a598 <__errno>:
8000a598:	e0 68 0a 38 	mov	r8,2616
8000a59c:	70 0c       	ld.w	r12,r8[0x0]
8000a59e:	2f 4c       	sub	r12,-12
8000a5a0:	5e fc       	retal	r12
8000a5a2:	d7 03       	nop

8000a5a4 <_fflush_r>:
8000a5a4:	d4 21       	pushm	r4-r7,lr
8000a5a6:	16 97       	mov	r7,r11
8000a5a8:	18 96       	mov	r6,r12
8000a5aa:	76 48       	ld.w	r8,r11[0x10]
8000a5ac:	58 08       	cp.w	r8,0
8000a5ae:	c7 f0       	breq	8000a6ac <_fflush_r+0x108>
8000a5b0:	58 0c       	cp.w	r12,0
8000a5b2:	c0 50       	breq	8000a5bc <_fflush_r+0x18>
8000a5b4:	78 68       	ld.w	r8,r12[0x18]
8000a5b6:	58 08       	cp.w	r8,0
8000a5b8:	c0 21       	brne	8000a5bc <_fflush_r+0x18>
8000a5ba:	cc dc       	rcall	8000a754 <__sinit>
8000a5bc:	fe c8 ce 00 	sub	r8,pc,-12800
8000a5c0:	10 37       	cp.w	r7,r8
8000a5c2:	c0 31       	brne	8000a5c8 <_fflush_r+0x24>
8000a5c4:	6c 07       	ld.w	r7,r6[0x0]
8000a5c6:	c0 c8       	rjmp	8000a5de <_fflush_r+0x3a>
8000a5c8:	fe c8 cd ec 	sub	r8,pc,-12820
8000a5cc:	10 37       	cp.w	r7,r8
8000a5ce:	c0 31       	brne	8000a5d4 <_fflush_r+0x30>
8000a5d0:	6c 17       	ld.w	r7,r6[0x4]
8000a5d2:	c0 68       	rjmp	8000a5de <_fflush_r+0x3a>
8000a5d4:	fe c8 cd d8 	sub	r8,pc,-12840
8000a5d8:	10 37       	cp.w	r7,r8
8000a5da:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a5de:	8e 6a       	ld.sh	r10,r7[0xc]
8000a5e0:	14 98       	mov	r8,r10
8000a5e2:	ed ba 00 03 	bld	r10,0x3
8000a5e6:	c4 20       	breq	8000a66a <_fflush_r+0xc6>
8000a5e8:	ab ba       	sbr	r10,0xb
8000a5ea:	ae 6a       	st.h	r7[0xc],r10
8000a5ec:	6e 18       	ld.w	r8,r7[0x4]
8000a5ee:	58 08       	cp.w	r8,0
8000a5f0:	e0 89 00 06 	brgt	8000a5fc <_fflush_r+0x58>
8000a5f4:	6f 08       	ld.w	r8,r7[0x40]
8000a5f6:	58 08       	cp.w	r8,0
8000a5f8:	e0 8a 00 5a 	brle	8000a6ac <_fflush_r+0x108>
8000a5fc:	6e b8       	ld.w	r8,r7[0x2c]
8000a5fe:	58 08       	cp.w	r8,0
8000a600:	c5 60       	breq	8000a6ac <_fflush_r+0x108>
8000a602:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a606:	c0 30       	breq	8000a60c <_fflush_r+0x68>
8000a608:	6f 55       	ld.w	r5,r7[0x54]
8000a60a:	c0 f8       	rjmp	8000a628 <_fflush_r+0x84>
8000a60c:	30 19       	mov	r9,1
8000a60e:	6e 8b       	ld.w	r11,r7[0x20]
8000a610:	0c 9c       	mov	r12,r6
8000a612:	5d 18       	icall	r8
8000a614:	18 95       	mov	r5,r12
8000a616:	5b fc       	cp.w	r12,-1
8000a618:	c0 81       	brne	8000a628 <_fflush_r+0x84>
8000a61a:	6c 38       	ld.w	r8,r6[0xc]
8000a61c:	59 d8       	cp.w	r8,29
8000a61e:	c4 70       	breq	8000a6ac <_fflush_r+0x108>
8000a620:	8e 68       	ld.sh	r8,r7[0xc]
8000a622:	a7 a8       	sbr	r8,0x6
8000a624:	ae 68       	st.h	r7[0xc],r8
8000a626:	d8 22       	popm	r4-r7,pc
8000a628:	8e 68       	ld.sh	r8,r7[0xc]
8000a62a:	ed b8 00 02 	bld	r8,0x2
8000a62e:	c0 91       	brne	8000a640 <_fflush_r+0x9c>
8000a630:	6e 18       	ld.w	r8,r7[0x4]
8000a632:	10 15       	sub	r5,r8
8000a634:	6e d8       	ld.w	r8,r7[0x34]
8000a636:	58 08       	cp.w	r8,0
8000a638:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a63c:	eb d8 e1 15 	subne	r5,r5,r8
8000a640:	6e b8       	ld.w	r8,r7[0x2c]
8000a642:	0c 9c       	mov	r12,r6
8000a644:	30 09       	mov	r9,0
8000a646:	0a 9a       	mov	r10,r5
8000a648:	6e 8b       	ld.w	r11,r7[0x20]
8000a64a:	5d 18       	icall	r8
8000a64c:	8e 68       	ld.sh	r8,r7[0xc]
8000a64e:	0a 3c       	cp.w	r12,r5
8000a650:	c2 61       	brne	8000a69c <_fflush_r+0xf8>
8000a652:	ab d8       	cbr	r8,0xb
8000a654:	30 0c       	mov	r12,0
8000a656:	6e 49       	ld.w	r9,r7[0x10]
8000a658:	ae 68       	st.h	r7[0xc],r8
8000a65a:	8f 1c       	st.w	r7[0x4],r12
8000a65c:	8f 09       	st.w	r7[0x0],r9
8000a65e:	ed b8 00 0c 	bld	r8,0xc
8000a662:	c2 51       	brne	8000a6ac <_fflush_r+0x108>
8000a664:	ef 45 00 54 	st.w	r7[84],r5
8000a668:	d8 22       	popm	r4-r7,pc
8000a66a:	6e 45       	ld.w	r5,r7[0x10]
8000a66c:	58 05       	cp.w	r5,0
8000a66e:	c1 f0       	breq	8000a6ac <_fflush_r+0x108>
8000a670:	6e 04       	ld.w	r4,r7[0x0]
8000a672:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a676:	8f 05       	st.w	r7[0x0],r5
8000a678:	f9 b8 01 00 	movne	r8,0
8000a67c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a680:	0a 14       	sub	r4,r5
8000a682:	8f 28       	st.w	r7[0x8],r8
8000a684:	c1 18       	rjmp	8000a6a6 <_fflush_r+0x102>
8000a686:	08 99       	mov	r9,r4
8000a688:	0a 9a       	mov	r10,r5
8000a68a:	6e a8       	ld.w	r8,r7[0x28]
8000a68c:	6e 8b       	ld.w	r11,r7[0x20]
8000a68e:	0c 9c       	mov	r12,r6
8000a690:	5d 18       	icall	r8
8000a692:	18 14       	sub	r4,r12
8000a694:	58 0c       	cp.w	r12,0
8000a696:	e0 89 00 07 	brgt	8000a6a4 <_fflush_r+0x100>
8000a69a:	8e 68       	ld.sh	r8,r7[0xc]
8000a69c:	a7 a8       	sbr	r8,0x6
8000a69e:	3f fc       	mov	r12,-1
8000a6a0:	ae 68       	st.h	r7[0xc],r8
8000a6a2:	d8 22       	popm	r4-r7,pc
8000a6a4:	18 05       	add	r5,r12
8000a6a6:	58 04       	cp.w	r4,0
8000a6a8:	fe 99 ff ef 	brgt	8000a686 <_fflush_r+0xe2>
8000a6ac:	d8 2a       	popm	r4-r7,pc,r12=0
8000a6ae:	d7 03       	nop

8000a6b0 <__sfp_lock_acquire>:
8000a6b0:	5e fc       	retal	r12

8000a6b2 <__sfp_lock_release>:
8000a6b2:	5e fc       	retal	r12

8000a6b4 <_cleanup_r>:
8000a6b4:	d4 01       	pushm	lr
8000a6b6:	fe cb f0 ae 	sub	r11,pc,-3922
8000a6ba:	e0 a0 02 f7 	rcall	8000aca8 <_fwalk>
8000a6be:	d8 02       	popm	pc

8000a6c0 <__sfmoreglue>:
8000a6c0:	d4 21       	pushm	r4-r7,lr
8000a6c2:	16 95       	mov	r5,r11
8000a6c4:	f6 06 10 5c 	mul	r6,r11,92
8000a6c8:	ec cb ff f4 	sub	r11,r6,-12
8000a6cc:	fe b0 e2 76 	rcall	80006bb8 <_malloc_r>
8000a6d0:	18 97       	mov	r7,r12
8000a6d2:	c0 90       	breq	8000a6e4 <__sfmoreglue+0x24>
8000a6d4:	99 15       	st.w	r12[0x4],r5
8000a6d6:	30 0b       	mov	r11,0
8000a6d8:	2f 4c       	sub	r12,-12
8000a6da:	0c 9a       	mov	r10,r6
8000a6dc:	8f 2c       	st.w	r7[0x8],r12
8000a6de:	8f 0b       	st.w	r7[0x0],r11
8000a6e0:	fe b0 e5 3f 	rcall	8000715e <memset>
8000a6e4:	0e 9c       	mov	r12,r7
8000a6e6:	d8 22       	popm	r4-r7,pc

8000a6e8 <__sfp>:
8000a6e8:	d4 21       	pushm	r4-r7,lr
8000a6ea:	fe c8 ce ca 	sub	r8,pc,-12598
8000a6ee:	18 96       	mov	r6,r12
8000a6f0:	70 07       	ld.w	r7,r8[0x0]
8000a6f2:	6e 68       	ld.w	r8,r7[0x18]
8000a6f4:	58 08       	cp.w	r8,0
8000a6f6:	c0 31       	brne	8000a6fc <__sfp+0x14>
8000a6f8:	0e 9c       	mov	r12,r7
8000a6fa:	c2 dc       	rcall	8000a754 <__sinit>
8000a6fc:	ee c7 ff 28 	sub	r7,r7,-216
8000a700:	30 05       	mov	r5,0
8000a702:	6e 2c       	ld.w	r12,r7[0x8]
8000a704:	6e 18       	ld.w	r8,r7[0x4]
8000a706:	c0 68       	rjmp	8000a712 <__sfp+0x2a>
8000a708:	98 69       	ld.sh	r9,r12[0xc]
8000a70a:	ea 09 19 00 	cp.h	r9,r5
8000a70e:	c1 10       	breq	8000a730 <__sfp+0x48>
8000a710:	2a 4c       	sub	r12,-92
8000a712:	20 18       	sub	r8,1
8000a714:	cf a7       	brpl	8000a708 <__sfp+0x20>
8000a716:	6e 08       	ld.w	r8,r7[0x0]
8000a718:	58 08       	cp.w	r8,0
8000a71a:	c0 61       	brne	8000a726 <__sfp+0x3e>
8000a71c:	30 4b       	mov	r11,4
8000a71e:	0c 9c       	mov	r12,r6
8000a720:	cd 0f       	rcall	8000a6c0 <__sfmoreglue>
8000a722:	8f 0c       	st.w	r7[0x0],r12
8000a724:	c0 30       	breq	8000a72a <__sfp+0x42>
8000a726:	6e 07       	ld.w	r7,r7[0x0]
8000a728:	ce db       	rjmp	8000a702 <__sfp+0x1a>
8000a72a:	30 c8       	mov	r8,12
8000a72c:	8d 38       	st.w	r6[0xc],r8
8000a72e:	d8 22       	popm	r4-r7,pc
8000a730:	30 08       	mov	r8,0
8000a732:	f9 48 00 4c 	st.w	r12[76],r8
8000a736:	99 08       	st.w	r12[0x0],r8
8000a738:	99 28       	st.w	r12[0x8],r8
8000a73a:	99 18       	st.w	r12[0x4],r8
8000a73c:	99 48       	st.w	r12[0x10],r8
8000a73e:	99 58       	st.w	r12[0x14],r8
8000a740:	99 68       	st.w	r12[0x18],r8
8000a742:	99 d8       	st.w	r12[0x34],r8
8000a744:	99 e8       	st.w	r12[0x38],r8
8000a746:	f9 48 00 48 	st.w	r12[72],r8
8000a74a:	3f f8       	mov	r8,-1
8000a74c:	b8 78       	st.h	r12[0xe],r8
8000a74e:	30 18       	mov	r8,1
8000a750:	b8 68       	st.h	r12[0xc],r8
8000a752:	d8 22       	popm	r4-r7,pc

8000a754 <__sinit>:
8000a754:	d4 21       	pushm	r4-r7,lr
8000a756:	18 96       	mov	r6,r12
8000a758:	78 67       	ld.w	r7,r12[0x18]
8000a75a:	58 07       	cp.w	r7,0
8000a75c:	c4 91       	brne	8000a7ee <__sinit+0x9a>
8000a75e:	fe c8 00 aa 	sub	r8,pc,170
8000a762:	30 15       	mov	r5,1
8000a764:	99 a8       	st.w	r12[0x28],r8
8000a766:	f9 47 00 d8 	st.w	r12[216],r7
8000a76a:	f9 47 00 dc 	st.w	r12[220],r7
8000a76e:	f9 47 00 e0 	st.w	r12[224],r7
8000a772:	99 65       	st.w	r12[0x18],r5
8000a774:	cb af       	rcall	8000a6e8 <__sfp>
8000a776:	8d 0c       	st.w	r6[0x0],r12
8000a778:	0c 9c       	mov	r12,r6
8000a77a:	cb 7f       	rcall	8000a6e8 <__sfp>
8000a77c:	8d 1c       	st.w	r6[0x4],r12
8000a77e:	0c 9c       	mov	r12,r6
8000a780:	cb 4f       	rcall	8000a6e8 <__sfp>
8000a782:	6c 09       	ld.w	r9,r6[0x0]
8000a784:	30 48       	mov	r8,4
8000a786:	93 07       	st.w	r9[0x0],r7
8000a788:	b2 68       	st.h	r9[0xc],r8
8000a78a:	93 17       	st.w	r9[0x4],r7
8000a78c:	93 27       	st.w	r9[0x8],r7
8000a78e:	6c 18       	ld.w	r8,r6[0x4]
8000a790:	b2 77       	st.h	r9[0xe],r7
8000a792:	93 47       	st.w	r9[0x10],r7
8000a794:	93 57       	st.w	r9[0x14],r7
8000a796:	93 67       	st.w	r9[0x18],r7
8000a798:	93 89       	st.w	r9[0x20],r9
8000a79a:	91 07       	st.w	r8[0x0],r7
8000a79c:	91 17       	st.w	r8[0x4],r7
8000a79e:	91 27       	st.w	r8[0x8],r7
8000a7a0:	fe ce f3 24 	sub	lr,pc,-3292
8000a7a4:	fe cb f3 54 	sub	r11,pc,-3244
8000a7a8:	93 9e       	st.w	r9[0x24],lr
8000a7aa:	93 ab       	st.w	r9[0x28],r11
8000a7ac:	fe ca f3 7c 	sub	r10,pc,-3204
8000a7b0:	fe c4 f3 88 	sub	r4,pc,-3192
8000a7b4:	93 ba       	st.w	r9[0x2c],r10
8000a7b6:	93 c4       	st.w	r9[0x30],r4
8000a7b8:	30 99       	mov	r9,9
8000a7ba:	b0 69       	st.h	r8[0xc],r9
8000a7bc:	b0 75       	st.h	r8[0xe],r5
8000a7be:	91 c4       	st.w	r8[0x30],r4
8000a7c0:	91 47       	st.w	r8[0x10],r7
8000a7c2:	91 57       	st.w	r8[0x14],r7
8000a7c4:	91 67       	st.w	r8[0x18],r7
8000a7c6:	91 88       	st.w	r8[0x20],r8
8000a7c8:	91 9e       	st.w	r8[0x24],lr
8000a7ca:	91 ab       	st.w	r8[0x28],r11
8000a7cc:	91 ba       	st.w	r8[0x2c],r10
8000a7ce:	8d 2c       	st.w	r6[0x8],r12
8000a7d0:	31 28       	mov	r8,18
8000a7d2:	99 07       	st.w	r12[0x0],r7
8000a7d4:	b8 68       	st.h	r12[0xc],r8
8000a7d6:	99 17       	st.w	r12[0x4],r7
8000a7d8:	99 27       	st.w	r12[0x8],r7
8000a7da:	30 28       	mov	r8,2
8000a7dc:	b8 78       	st.h	r12[0xe],r8
8000a7de:	99 c4       	st.w	r12[0x30],r4
8000a7e0:	99 67       	st.w	r12[0x18],r7
8000a7e2:	99 9e       	st.w	r12[0x24],lr
8000a7e4:	99 ab       	st.w	r12[0x28],r11
8000a7e6:	99 ba       	st.w	r12[0x2c],r10
8000a7e8:	99 47       	st.w	r12[0x10],r7
8000a7ea:	99 57       	st.w	r12[0x14],r7
8000a7ec:	99 8c       	st.w	r12[0x20],r12
8000a7ee:	d8 22       	popm	r4-r7,pc

8000a7f0 <_malloc_trim_r>:
8000a7f0:	d4 21       	pushm	r4-r7,lr
8000a7f2:	16 95       	mov	r5,r11
8000a7f4:	18 97       	mov	r7,r12
8000a7f6:	fe b0 d7 c9 	rcall	80005788 <__malloc_lock>
8000a7fa:	e0 64 05 38 	mov	r4,1336
8000a7fe:	68 28       	ld.w	r8,r4[0x8]
8000a800:	70 16       	ld.w	r6,r8[0x4]
8000a802:	e0 16 ff fc 	andl	r6,0xfffc
8000a806:	ec c8 ff 91 	sub	r8,r6,-111
8000a80a:	f0 05 01 05 	sub	r5,r8,r5
8000a80e:	e0 15 ff 80 	andl	r5,0xff80
8000a812:	ea c5 00 80 	sub	r5,r5,128
8000a816:	e0 45 00 7f 	cp.w	r5,127
8000a81a:	e0 8a 00 25 	brle	8000a864 <_malloc_trim_r+0x74>
8000a81e:	30 0b       	mov	r11,0
8000a820:	0e 9c       	mov	r12,r7
8000a822:	fe b0 e6 05 	rcall	8000742c <_sbrk_r>
8000a826:	68 28       	ld.w	r8,r4[0x8]
8000a828:	0c 08       	add	r8,r6
8000a82a:	10 3c       	cp.w	r12,r8
8000a82c:	c1 c1       	brne	8000a864 <_malloc_trim_r+0x74>
8000a82e:	ea 0b 11 00 	rsub	r11,r5,0
8000a832:	0e 9c       	mov	r12,r7
8000a834:	fe b0 e5 fc 	rcall	8000742c <_sbrk_r>
8000a838:	5b fc       	cp.w	r12,-1
8000a83a:	c1 91       	brne	8000a86c <_malloc_trim_r+0x7c>
8000a83c:	30 0b       	mov	r11,0
8000a83e:	0e 9c       	mov	r12,r7
8000a840:	fe b0 e5 f6 	rcall	8000742c <_sbrk_r>
8000a844:	68 28       	ld.w	r8,r4[0x8]
8000a846:	f8 08 01 09 	sub	r9,r12,r8
8000a84a:	58 f9       	cp.w	r9,15
8000a84c:	e0 8a 00 0c 	brle	8000a864 <_malloc_trim_r+0x74>
8000a850:	a1 a9       	sbr	r9,0x0
8000a852:	91 19       	st.w	r8[0x4],r9
8000a854:	e0 68 09 44 	mov	r8,2372
8000a858:	70 09       	ld.w	r9,r8[0x0]
8000a85a:	e0 68 0d 58 	mov	r8,3416
8000a85e:	f8 09 01 09 	sub	r9,r12,r9
8000a862:	91 09       	st.w	r8[0x0],r9
8000a864:	0e 9c       	mov	r12,r7
8000a866:	fe b0 d7 97 	rcall	80005794 <__malloc_unlock>
8000a86a:	d8 2a       	popm	r4-r7,pc,r12=0
8000a86c:	68 28       	ld.w	r8,r4[0x8]
8000a86e:	0a 16       	sub	r6,r5
8000a870:	a1 a6       	sbr	r6,0x0
8000a872:	91 16       	st.w	r8[0x4],r6
8000a874:	e0 68 0d 58 	mov	r8,3416
8000a878:	70 09       	ld.w	r9,r8[0x0]
8000a87a:	0a 19       	sub	r9,r5
8000a87c:	0e 9c       	mov	r12,r7
8000a87e:	91 09       	st.w	r8[0x0],r9
8000a880:	fe b0 d7 8a 	rcall	80005794 <__malloc_unlock>
8000a884:	da 2a       	popm	r4-r7,pc,r12=1
8000a886:	d7 03       	nop

8000a888 <_free_r>:
8000a888:	d4 21       	pushm	r4-r7,lr
8000a88a:	16 96       	mov	r6,r11
8000a88c:	18 97       	mov	r7,r12
8000a88e:	58 0b       	cp.w	r11,0
8000a890:	e0 80 00 c0 	breq	8000aa10 <_free_r+0x188>
8000a894:	fe b0 d7 7a 	rcall	80005788 <__malloc_lock>
8000a898:	20 86       	sub	r6,8
8000a89a:	e0 6a 05 38 	mov	r10,1336
8000a89e:	6c 18       	ld.w	r8,r6[0x4]
8000a8a0:	74 2e       	ld.w	lr,r10[0x8]
8000a8a2:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a8a6:	a1 c8       	cbr	r8,0x0
8000a8a8:	ec 08 00 09 	add	r9,r6,r8
8000a8ac:	72 1b       	ld.w	r11,r9[0x4]
8000a8ae:	e0 1b ff fc 	andl	r11,0xfffc
8000a8b2:	1c 39       	cp.w	r9,lr
8000a8b4:	c1 e1       	brne	8000a8f0 <_free_r+0x68>
8000a8b6:	f6 08 00 08 	add	r8,r11,r8
8000a8ba:	58 0c       	cp.w	r12,0
8000a8bc:	c0 81       	brne	8000a8cc <_free_r+0x44>
8000a8be:	6c 09       	ld.w	r9,r6[0x0]
8000a8c0:	12 16       	sub	r6,r9
8000a8c2:	12 08       	add	r8,r9
8000a8c4:	6c 3b       	ld.w	r11,r6[0xc]
8000a8c6:	6c 29       	ld.w	r9,r6[0x8]
8000a8c8:	97 29       	st.w	r11[0x8],r9
8000a8ca:	93 3b       	st.w	r9[0xc],r11
8000a8cc:	10 99       	mov	r9,r8
8000a8ce:	95 26       	st.w	r10[0x8],r6
8000a8d0:	a1 a9       	sbr	r9,0x0
8000a8d2:	8d 19       	st.w	r6[0x4],r9
8000a8d4:	e0 69 09 40 	mov	r9,2368
8000a8d8:	72 09       	ld.w	r9,r9[0x0]
8000a8da:	12 38       	cp.w	r8,r9
8000a8dc:	c0 63       	brcs	8000a8e8 <_free_r+0x60>
8000a8de:	e0 68 0d 54 	mov	r8,3412
8000a8e2:	0e 9c       	mov	r12,r7
8000a8e4:	70 0b       	ld.w	r11,r8[0x0]
8000a8e6:	c8 5f       	rcall	8000a7f0 <_malloc_trim_r>
8000a8e8:	0e 9c       	mov	r12,r7
8000a8ea:	fe b0 d7 55 	rcall	80005794 <__malloc_unlock>
8000a8ee:	d8 22       	popm	r4-r7,pc
8000a8f0:	93 1b       	st.w	r9[0x4],r11
8000a8f2:	58 0c       	cp.w	r12,0
8000a8f4:	c0 30       	breq	8000a8fa <_free_r+0x72>
8000a8f6:	30 0c       	mov	r12,0
8000a8f8:	c1 08       	rjmp	8000a918 <_free_r+0x90>
8000a8fa:	6c 0e       	ld.w	lr,r6[0x0]
8000a8fc:	f4 c5 ff f8 	sub	r5,r10,-8
8000a900:	1c 16       	sub	r6,lr
8000a902:	1c 08       	add	r8,lr
8000a904:	6c 2e       	ld.w	lr,r6[0x8]
8000a906:	0a 3e       	cp.w	lr,r5
8000a908:	f9 bc 00 01 	moveq	r12,1
8000a90c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a910:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a914:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a918:	f2 0b 00 0e 	add	lr,r9,r11
8000a91c:	7c 1e       	ld.w	lr,lr[0x4]
8000a91e:	ed be 00 00 	bld	lr,0x0
8000a922:	c1 40       	breq	8000a94a <_free_r+0xc2>
8000a924:	16 08       	add	r8,r11
8000a926:	58 0c       	cp.w	r12,0
8000a928:	c0 d1       	brne	8000a942 <_free_r+0xba>
8000a92a:	e0 6e 05 38 	mov	lr,1336
8000a92e:	72 2b       	ld.w	r11,r9[0x8]
8000a930:	2f 8e       	sub	lr,-8
8000a932:	1c 3b       	cp.w	r11,lr
8000a934:	c0 71       	brne	8000a942 <_free_r+0xba>
8000a936:	97 36       	st.w	r11[0xc],r6
8000a938:	97 26       	st.w	r11[0x8],r6
8000a93a:	8d 2b       	st.w	r6[0x8],r11
8000a93c:	8d 3b       	st.w	r6[0xc],r11
8000a93e:	30 1c       	mov	r12,1
8000a940:	c0 58       	rjmp	8000a94a <_free_r+0xc2>
8000a942:	72 2b       	ld.w	r11,r9[0x8]
8000a944:	72 39       	ld.w	r9,r9[0xc]
8000a946:	93 2b       	st.w	r9[0x8],r11
8000a948:	97 39       	st.w	r11[0xc],r9
8000a94a:	10 99       	mov	r9,r8
8000a94c:	ec 08 09 08 	st.w	r6[r8],r8
8000a950:	a1 a9       	sbr	r9,0x0
8000a952:	8d 19       	st.w	r6[0x4],r9
8000a954:	58 0c       	cp.w	r12,0
8000a956:	c5 a1       	brne	8000aa0a <_free_r+0x182>
8000a958:	e0 48 01 ff 	cp.w	r8,511
8000a95c:	e0 8b 00 13 	brhi	8000a982 <_free_r+0xfa>
8000a960:	a3 98       	lsr	r8,0x3
8000a962:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a966:	72 2b       	ld.w	r11,r9[0x8]
8000a968:	8d 39       	st.w	r6[0xc],r9
8000a96a:	8d 2b       	st.w	r6[0x8],r11
8000a96c:	97 36       	st.w	r11[0xc],r6
8000a96e:	93 26       	st.w	r9[0x8],r6
8000a970:	a3 48       	asr	r8,0x2
8000a972:	74 19       	ld.w	r9,r10[0x4]
8000a974:	30 1b       	mov	r11,1
8000a976:	f6 08 09 48 	lsl	r8,r11,r8
8000a97a:	f3 e8 10 08 	or	r8,r9,r8
8000a97e:	95 18       	st.w	r10[0x4],r8
8000a980:	c4 58       	rjmp	8000aa0a <_free_r+0x182>
8000a982:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a986:	58 4b       	cp.w	r11,4
8000a988:	e0 8b 00 06 	brhi	8000a994 <_free_r+0x10c>
8000a98c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a990:	2c 8b       	sub	r11,-56
8000a992:	c2 08       	rjmp	8000a9d2 <_free_r+0x14a>
8000a994:	59 4b       	cp.w	r11,20
8000a996:	e0 8b 00 04 	brhi	8000a99e <_free_r+0x116>
8000a99a:	2a 5b       	sub	r11,-91
8000a99c:	c1 b8       	rjmp	8000a9d2 <_free_r+0x14a>
8000a99e:	e0 4b 00 54 	cp.w	r11,84
8000a9a2:	e0 8b 00 06 	brhi	8000a9ae <_free_r+0x126>
8000a9a6:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a9aa:	29 2b       	sub	r11,-110
8000a9ac:	c1 38       	rjmp	8000a9d2 <_free_r+0x14a>
8000a9ae:	e0 4b 01 54 	cp.w	r11,340
8000a9b2:	e0 8b 00 06 	brhi	8000a9be <_free_r+0x136>
8000a9b6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a9ba:	28 9b       	sub	r11,-119
8000a9bc:	c0 b8       	rjmp	8000a9d2 <_free_r+0x14a>
8000a9be:	e0 4b 05 54 	cp.w	r11,1364
8000a9c2:	e0 88 00 05 	brls	8000a9cc <_free_r+0x144>
8000a9c6:	37 eb       	mov	r11,126
8000a9c8:	c0 58       	rjmp	8000a9d2 <_free_r+0x14a>
8000a9ca:	d7 03       	nop
8000a9cc:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a9d0:	28 4b       	sub	r11,-124
8000a9d2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a9d6:	78 29       	ld.w	r9,r12[0x8]
8000a9d8:	18 39       	cp.w	r9,r12
8000a9da:	c0 e1       	brne	8000a9f6 <_free_r+0x16e>
8000a9dc:	74 18       	ld.w	r8,r10[0x4]
8000a9de:	a3 4b       	asr	r11,0x2
8000a9e0:	30 1c       	mov	r12,1
8000a9e2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a9e6:	f1 eb 10 0b 	or	r11,r8,r11
8000a9ea:	12 98       	mov	r8,r9
8000a9ec:	95 1b       	st.w	r10[0x4],r11
8000a9ee:	c0 a8       	rjmp	8000aa02 <_free_r+0x17a>
8000a9f0:	72 29       	ld.w	r9,r9[0x8]
8000a9f2:	18 39       	cp.w	r9,r12
8000a9f4:	c0 60       	breq	8000aa00 <_free_r+0x178>
8000a9f6:	72 1a       	ld.w	r10,r9[0x4]
8000a9f8:	e0 1a ff fc 	andl	r10,0xfffc
8000a9fc:	14 38       	cp.w	r8,r10
8000a9fe:	cf 93       	brcs	8000a9f0 <_free_r+0x168>
8000aa00:	72 38       	ld.w	r8,r9[0xc]
8000aa02:	8d 38       	st.w	r6[0xc],r8
8000aa04:	8d 29       	st.w	r6[0x8],r9
8000aa06:	93 36       	st.w	r9[0xc],r6
8000aa08:	91 26       	st.w	r8[0x8],r6
8000aa0a:	0e 9c       	mov	r12,r7
8000aa0c:	fe b0 d6 c4 	rcall	80005794 <__malloc_unlock>
8000aa10:	d8 22       	popm	r4-r7,pc
8000aa12:	d7 03       	nop

8000aa14 <__sfvwrite_r>:
8000aa14:	d4 31       	pushm	r0-r7,lr
8000aa16:	20 3d       	sub	sp,12
8000aa18:	14 94       	mov	r4,r10
8000aa1a:	18 95       	mov	r5,r12
8000aa1c:	16 97       	mov	r7,r11
8000aa1e:	74 28       	ld.w	r8,r10[0x8]
8000aa20:	58 08       	cp.w	r8,0
8000aa22:	e0 80 01 40 	breq	8000aca2 <__sfvwrite_r+0x28e>
8000aa26:	96 68       	ld.sh	r8,r11[0xc]
8000aa28:	ed b8 00 03 	bld	r8,0x3
8000aa2c:	c0 41       	brne	8000aa34 <__sfvwrite_r+0x20>
8000aa2e:	76 48       	ld.w	r8,r11[0x10]
8000aa30:	58 08       	cp.w	r8,0
8000aa32:	c0 c1       	brne	8000aa4a <__sfvwrite_r+0x36>
8000aa34:	0e 9b       	mov	r11,r7
8000aa36:	0a 9c       	mov	r12,r5
8000aa38:	fe b0 f6 c4 	rcall	800097c0 <__swsetup_r>
8000aa3c:	c0 70       	breq	8000aa4a <__sfvwrite_r+0x36>
8000aa3e:	8e 68       	ld.sh	r8,r7[0xc]
8000aa40:	a7 a8       	sbr	r8,0x6
8000aa42:	ae 68       	st.h	r7[0xc],r8
8000aa44:	30 98       	mov	r8,9
8000aa46:	8b 38       	st.w	r5[0xc],r8
8000aa48:	c2 b9       	rjmp	8000ac9e <__sfvwrite_r+0x28a>
8000aa4a:	8e 63       	ld.sh	r3,r7[0xc]
8000aa4c:	68 00       	ld.w	r0,r4[0x0]
8000aa4e:	06 96       	mov	r6,r3
8000aa50:	e2 16 00 02 	andl	r6,0x2,COH
8000aa54:	c2 10       	breq	8000aa96 <__sfvwrite_r+0x82>
8000aa56:	30 03       	mov	r3,0
8000aa58:	e0 62 04 00 	mov	r2,1024
8000aa5c:	06 96       	mov	r6,r3
8000aa5e:	c0 48       	rjmp	8000aa66 <__sfvwrite_r+0x52>
8000aa60:	60 03       	ld.w	r3,r0[0x0]
8000aa62:	60 16       	ld.w	r6,r0[0x4]
8000aa64:	2f 80       	sub	r0,-8
8000aa66:	58 06       	cp.w	r6,0
8000aa68:	cf c0       	breq	8000aa60 <__sfvwrite_r+0x4c>
8000aa6a:	e0 46 04 00 	cp.w	r6,1024
8000aa6e:	ec 09 17 80 	movls	r9,r6
8000aa72:	e4 09 17 b0 	movhi	r9,r2
8000aa76:	06 9a       	mov	r10,r3
8000aa78:	6e a8       	ld.w	r8,r7[0x28]
8000aa7a:	6e 8b       	ld.w	r11,r7[0x20]
8000aa7c:	0a 9c       	mov	r12,r5
8000aa7e:	5d 18       	icall	r8
8000aa80:	18 16       	sub	r6,r12
8000aa82:	58 0c       	cp.w	r12,0
8000aa84:	e0 8a 01 0a 	brle	8000ac98 <__sfvwrite_r+0x284>
8000aa88:	68 28       	ld.w	r8,r4[0x8]
8000aa8a:	18 18       	sub	r8,r12
8000aa8c:	89 28       	st.w	r4[0x8],r8
8000aa8e:	e0 80 01 0a 	breq	8000aca2 <__sfvwrite_r+0x28e>
8000aa92:	18 03       	add	r3,r12
8000aa94:	ce 9b       	rjmp	8000aa66 <__sfvwrite_r+0x52>
8000aa96:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000aa9a:	c0 70       	breq	8000aaa8 <__sfvwrite_r+0x94>
8000aa9c:	50 06       	stdsp	sp[0x0],r6
8000aa9e:	0c 93       	mov	r3,r6
8000aaa0:	0c 91       	mov	r1,r6
8000aaa2:	50 15       	stdsp	sp[0x4],r5
8000aaa4:	08 92       	mov	r2,r4
8000aaa6:	c9 c8       	rjmp	8000abde <__sfvwrite_r+0x1ca>
8000aaa8:	06 96       	mov	r6,r3
8000aaaa:	08 91       	mov	r1,r4
8000aaac:	c0 48       	rjmp	8000aab4 <__sfvwrite_r+0xa0>
8000aaae:	60 03       	ld.w	r3,r0[0x0]
8000aab0:	60 16       	ld.w	r6,r0[0x4]
8000aab2:	2f 80       	sub	r0,-8
8000aab4:	58 06       	cp.w	r6,0
8000aab6:	cf c0       	breq	8000aaae <__sfvwrite_r+0x9a>
8000aab8:	8e 68       	ld.sh	r8,r7[0xc]
8000aaba:	6e 24       	ld.w	r4,r7[0x8]
8000aabc:	10 99       	mov	r9,r8
8000aabe:	e2 19 02 00 	andl	r9,0x200,COH
8000aac2:	c5 50       	breq	8000ab6c <__sfvwrite_r+0x158>
8000aac4:	08 36       	cp.w	r6,r4
8000aac6:	c4 43       	brcs	8000ab4e <__sfvwrite_r+0x13a>
8000aac8:	10 99       	mov	r9,r8
8000aaca:	e2 19 04 80 	andl	r9,0x480,COH
8000aace:	c4 00       	breq	8000ab4e <__sfvwrite_r+0x13a>
8000aad0:	6e 4b       	ld.w	r11,r7[0x10]
8000aad2:	6e 09       	ld.w	r9,r7[0x0]
8000aad4:	16 19       	sub	r9,r11
8000aad6:	50 09       	stdsp	sp[0x0],r9
8000aad8:	6e 59       	ld.w	r9,r7[0x14]
8000aada:	10 9c       	mov	r12,r8
8000aadc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000aae0:	30 28       	mov	r8,2
8000aae2:	f4 08 0c 08 	divs	r8,r10,r8
8000aae6:	fa e9 00 04 	st.d	sp[4],r8
8000aaea:	10 94       	mov	r4,r8
8000aaec:	40 09       	lddsp	r9,sp[0x0]
8000aaee:	e2 1c 04 00 	andl	r12,0x400,COH
8000aaf2:	2f f9       	sub	r9,-1
8000aaf4:	0c 09       	add	r9,r6
8000aaf6:	12 38       	cp.w	r8,r9
8000aaf8:	f2 04 17 30 	movlo	r4,r9
8000aafc:	58 0c       	cp.w	r12,0
8000aafe:	c1 10       	breq	8000ab20 <__sfvwrite_r+0x10c>
8000ab00:	08 9b       	mov	r11,r4
8000ab02:	0a 9c       	mov	r12,r5
8000ab04:	fe b0 e0 5a 	rcall	80006bb8 <_malloc_r>
8000ab08:	18 92       	mov	r2,r12
8000ab0a:	c1 40       	breq	8000ab32 <__sfvwrite_r+0x11e>
8000ab0c:	40 0a       	lddsp	r10,sp[0x0]
8000ab0e:	6e 4b       	ld.w	r11,r7[0x10]
8000ab10:	fe b0 e2 83 	rcall	80007016 <memcpy>
8000ab14:	8e 68       	ld.sh	r8,r7[0xc]
8000ab16:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ab1a:	a7 b8       	sbr	r8,0x7
8000ab1c:	ae 68       	st.h	r7[0xc],r8
8000ab1e:	c0 d8       	rjmp	8000ab38 <__sfvwrite_r+0x124>
8000ab20:	08 9a       	mov	r10,r4
8000ab22:	0a 9c       	mov	r12,r5
8000ab24:	fe b0 e3 24 	rcall	8000716c <_realloc_r>
8000ab28:	18 92       	mov	r2,r12
8000ab2a:	c0 71       	brne	8000ab38 <__sfvwrite_r+0x124>
8000ab2c:	6e 4b       	ld.w	r11,r7[0x10]
8000ab2e:	0a 9c       	mov	r12,r5
8000ab30:	ca ce       	rcall	8000a888 <_free_r>
8000ab32:	30 c8       	mov	r8,12
8000ab34:	8b 38       	st.w	r5[0xc],r8
8000ab36:	cb 18       	rjmp	8000ac98 <__sfvwrite_r+0x284>
8000ab38:	40 0a       	lddsp	r10,sp[0x0]
8000ab3a:	40 09       	lddsp	r9,sp[0x0]
8000ab3c:	e8 0a 01 0a 	sub	r10,r4,r10
8000ab40:	e4 09 00 08 	add	r8,r2,r9
8000ab44:	8f 54       	st.w	r7[0x14],r4
8000ab46:	8f 2a       	st.w	r7[0x8],r10
8000ab48:	8f 08       	st.w	r7[0x0],r8
8000ab4a:	8f 42       	st.w	r7[0x10],r2
8000ab4c:	0c 94       	mov	r4,r6
8000ab4e:	08 36       	cp.w	r6,r4
8000ab50:	ec 04 17 30 	movlo	r4,r6
8000ab54:	06 9b       	mov	r11,r3
8000ab56:	08 9a       	mov	r10,r4
8000ab58:	6e 0c       	ld.w	r12,r7[0x0]
8000ab5a:	c3 ad       	rcall	8000adce <memmove>
8000ab5c:	6e 08       	ld.w	r8,r7[0x0]
8000ab5e:	08 08       	add	r8,r4
8000ab60:	8f 08       	st.w	r7[0x0],r8
8000ab62:	6e 28       	ld.w	r8,r7[0x8]
8000ab64:	08 18       	sub	r8,r4
8000ab66:	0c 94       	mov	r4,r6
8000ab68:	8f 28       	st.w	r7[0x8],r8
8000ab6a:	c2 e8       	rjmp	8000abc6 <__sfvwrite_r+0x1b2>
8000ab6c:	08 36       	cp.w	r6,r4
8000ab6e:	5f ba       	srhi	r10
8000ab70:	6e 0c       	ld.w	r12,r7[0x0]
8000ab72:	6e 48       	ld.w	r8,r7[0x10]
8000ab74:	10 3c       	cp.w	r12,r8
8000ab76:	5f b8       	srhi	r8
8000ab78:	f5 e8 00 08 	and	r8,r10,r8
8000ab7c:	f2 08 18 00 	cp.b	r8,r9
8000ab80:	c0 d0       	breq	8000ab9a <__sfvwrite_r+0x186>
8000ab82:	06 9b       	mov	r11,r3
8000ab84:	08 9a       	mov	r10,r4
8000ab86:	c2 4d       	rcall	8000adce <memmove>
8000ab88:	6e 08       	ld.w	r8,r7[0x0]
8000ab8a:	08 08       	add	r8,r4
8000ab8c:	0e 9b       	mov	r11,r7
8000ab8e:	8f 08       	st.w	r7[0x0],r8
8000ab90:	0a 9c       	mov	r12,r5
8000ab92:	fe b0 fd 09 	rcall	8000a5a4 <_fflush_r>
8000ab96:	c1 80       	breq	8000abc6 <__sfvwrite_r+0x1b2>
8000ab98:	c8 08       	rjmp	8000ac98 <__sfvwrite_r+0x284>
8000ab9a:	6e 59       	ld.w	r9,r7[0x14]
8000ab9c:	12 36       	cp.w	r6,r9
8000ab9e:	c0 a3       	brcs	8000abb2 <__sfvwrite_r+0x19e>
8000aba0:	6e a8       	ld.w	r8,r7[0x28]
8000aba2:	06 9a       	mov	r10,r3
8000aba4:	6e 8b       	ld.w	r11,r7[0x20]
8000aba6:	0a 9c       	mov	r12,r5
8000aba8:	5d 18       	icall	r8
8000abaa:	18 94       	mov	r4,r12
8000abac:	e0 89 00 0d 	brgt	8000abc6 <__sfvwrite_r+0x1b2>
8000abb0:	c7 48       	rjmp	8000ac98 <__sfvwrite_r+0x284>
8000abb2:	0c 9a       	mov	r10,r6
8000abb4:	06 9b       	mov	r11,r3
8000abb6:	c0 cd       	rcall	8000adce <memmove>
8000abb8:	6e 08       	ld.w	r8,r7[0x0]
8000abba:	0c 08       	add	r8,r6
8000abbc:	0c 94       	mov	r4,r6
8000abbe:	8f 08       	st.w	r7[0x0],r8
8000abc0:	6e 28       	ld.w	r8,r7[0x8]
8000abc2:	0c 18       	sub	r8,r6
8000abc4:	8f 28       	st.w	r7[0x8],r8
8000abc6:	62 28       	ld.w	r8,r1[0x8]
8000abc8:	08 18       	sub	r8,r4
8000abca:	83 28       	st.w	r1[0x8],r8
8000abcc:	c6 b0       	breq	8000aca2 <__sfvwrite_r+0x28e>
8000abce:	08 16       	sub	r6,r4
8000abd0:	08 03       	add	r3,r4
8000abd2:	c7 1b       	rjmp	8000aab4 <__sfvwrite_r+0xa0>
8000abd4:	60 03       	ld.w	r3,r0[0x0]
8000abd6:	60 11       	ld.w	r1,r0[0x4]
8000abd8:	30 08       	mov	r8,0
8000abda:	2f 80       	sub	r0,-8
8000abdc:	50 08       	stdsp	sp[0x0],r8
8000abde:	58 01       	cp.w	r1,0
8000abe0:	cf a0       	breq	8000abd4 <__sfvwrite_r+0x1c0>
8000abe2:	40 0a       	lddsp	r10,sp[0x0]
8000abe4:	58 0a       	cp.w	r10,0
8000abe6:	c1 41       	brne	8000ac0e <__sfvwrite_r+0x1fa>
8000abe8:	e2 c6 ff ff 	sub	r6,r1,-1
8000abec:	02 9a       	mov	r10,r1
8000abee:	30 ab       	mov	r11,10
8000abf0:	06 9c       	mov	r12,r3
8000abf2:	ce 3c       	rcall	8000adb8 <memchr>
8000abf4:	f8 c8 ff ff 	sub	r8,r12,-1
8000abf8:	58 0c       	cp.w	r12,0
8000abfa:	f1 d3 e1 16 	subne	r6,r8,r3
8000abfe:	f9 b9 01 01 	movne	r9,1
8000ac02:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ac06:	f9 b8 00 01 	moveq	r8,1
8000ac0a:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ac0e:	02 36       	cp.w	r6,r1
8000ac10:	ec 04 17 80 	movls	r4,r6
8000ac14:	e2 04 17 b0 	movhi	r4,r1
8000ac18:	6e 59       	ld.w	r9,r7[0x14]
8000ac1a:	6e 25       	ld.w	r5,r7[0x8]
8000ac1c:	f2 05 00 05 	add	r5,r9,r5
8000ac20:	0a 34       	cp.w	r4,r5
8000ac22:	5f 9a       	srgt	r10
8000ac24:	6e 0c       	ld.w	r12,r7[0x0]
8000ac26:	6e 48       	ld.w	r8,r7[0x10]
8000ac28:	10 3c       	cp.w	r12,r8
8000ac2a:	5f b8       	srhi	r8
8000ac2c:	f5 e8 00 08 	and	r8,r10,r8
8000ac30:	30 0a       	mov	r10,0
8000ac32:	f4 08 18 00 	cp.b	r8,r10
8000ac36:	c0 d0       	breq	8000ac50 <__sfvwrite_r+0x23c>
8000ac38:	06 9b       	mov	r11,r3
8000ac3a:	0a 9a       	mov	r10,r5
8000ac3c:	cc 9c       	rcall	8000adce <memmove>
8000ac3e:	6e 08       	ld.w	r8,r7[0x0]
8000ac40:	0a 08       	add	r8,r5
8000ac42:	0e 9b       	mov	r11,r7
8000ac44:	8f 08       	st.w	r7[0x0],r8
8000ac46:	40 1c       	lddsp	r12,sp[0x4]
8000ac48:	fe b0 fc ae 	rcall	8000a5a4 <_fflush_r>
8000ac4c:	c1 70       	breq	8000ac7a <__sfvwrite_r+0x266>
8000ac4e:	c2 58       	rjmp	8000ac98 <__sfvwrite_r+0x284>
8000ac50:	12 34       	cp.w	r4,r9
8000ac52:	c0 a5       	brlt	8000ac66 <__sfvwrite_r+0x252>
8000ac54:	6e a8       	ld.w	r8,r7[0x28]
8000ac56:	06 9a       	mov	r10,r3
8000ac58:	6e 8b       	ld.w	r11,r7[0x20]
8000ac5a:	40 1c       	lddsp	r12,sp[0x4]
8000ac5c:	5d 18       	icall	r8
8000ac5e:	18 95       	mov	r5,r12
8000ac60:	e0 89 00 0d 	brgt	8000ac7a <__sfvwrite_r+0x266>
8000ac64:	c1 a8       	rjmp	8000ac98 <__sfvwrite_r+0x284>
8000ac66:	08 9a       	mov	r10,r4
8000ac68:	06 9b       	mov	r11,r3
8000ac6a:	cb 2c       	rcall	8000adce <memmove>
8000ac6c:	6e 08       	ld.w	r8,r7[0x0]
8000ac6e:	08 08       	add	r8,r4
8000ac70:	08 95       	mov	r5,r4
8000ac72:	8f 08       	st.w	r7[0x0],r8
8000ac74:	6e 28       	ld.w	r8,r7[0x8]
8000ac76:	08 18       	sub	r8,r4
8000ac78:	8f 28       	st.w	r7[0x8],r8
8000ac7a:	0a 16       	sub	r6,r5
8000ac7c:	c0 71       	brne	8000ac8a <__sfvwrite_r+0x276>
8000ac7e:	0e 9b       	mov	r11,r7
8000ac80:	40 1c       	lddsp	r12,sp[0x4]
8000ac82:	fe b0 fc 91 	rcall	8000a5a4 <_fflush_r>
8000ac86:	c0 91       	brne	8000ac98 <__sfvwrite_r+0x284>
8000ac88:	50 06       	stdsp	sp[0x0],r6
8000ac8a:	64 28       	ld.w	r8,r2[0x8]
8000ac8c:	0a 18       	sub	r8,r5
8000ac8e:	85 28       	st.w	r2[0x8],r8
8000ac90:	c0 90       	breq	8000aca2 <__sfvwrite_r+0x28e>
8000ac92:	0a 11       	sub	r1,r5
8000ac94:	0a 03       	add	r3,r5
8000ac96:	ca 4b       	rjmp	8000abde <__sfvwrite_r+0x1ca>
8000ac98:	8e 68       	ld.sh	r8,r7[0xc]
8000ac9a:	a7 a8       	sbr	r8,0x6
8000ac9c:	ae 68       	st.h	r7[0xc],r8
8000ac9e:	3f fc       	mov	r12,-1
8000aca0:	c0 28       	rjmp	8000aca4 <__sfvwrite_r+0x290>
8000aca2:	30 0c       	mov	r12,0
8000aca4:	2f dd       	sub	sp,-12
8000aca6:	d8 32       	popm	r0-r7,pc

8000aca8 <_fwalk>:
8000aca8:	d4 31       	pushm	r0-r7,lr
8000acaa:	30 05       	mov	r5,0
8000acac:	16 91       	mov	r1,r11
8000acae:	f8 c7 ff 28 	sub	r7,r12,-216
8000acb2:	0a 92       	mov	r2,r5
8000acb4:	fe b0 fc fe 	rcall	8000a6b0 <__sfp_lock_acquire>
8000acb8:	3f f3       	mov	r3,-1
8000acba:	c1 68       	rjmp	8000ace6 <_fwalk+0x3e>
8000acbc:	6e 26       	ld.w	r6,r7[0x8]
8000acbe:	6e 14       	ld.w	r4,r7[0x4]
8000acc0:	2f 46       	sub	r6,-12
8000acc2:	c0 c8       	rjmp	8000acda <_fwalk+0x32>
8000acc4:	8c 08       	ld.sh	r8,r6[0x0]
8000acc6:	e4 08 19 00 	cp.h	r8,r2
8000acca:	c0 70       	breq	8000acd8 <_fwalk+0x30>
8000accc:	8c 18       	ld.sh	r8,r6[0x2]
8000acce:	e6 08 19 00 	cp.h	r8,r3
8000acd2:	c0 30       	breq	8000acd8 <_fwalk+0x30>
8000acd4:	5d 11       	icall	r1
8000acd6:	18 45       	or	r5,r12
8000acd8:	2a 46       	sub	r6,-92
8000acda:	20 14       	sub	r4,1
8000acdc:	ec cc 00 0c 	sub	r12,r6,12
8000ace0:	58 04       	cp.w	r4,0
8000ace2:	cf 14       	brge	8000acc4 <_fwalk+0x1c>
8000ace4:	6e 07       	ld.w	r7,r7[0x0]
8000ace6:	58 07       	cp.w	r7,0
8000ace8:	ce a1       	brne	8000acbc <_fwalk+0x14>
8000acea:	fe b0 fc e4 	rcall	8000a6b2 <__sfp_lock_release>
8000acee:	0a 9c       	mov	r12,r5
8000acf0:	d8 32       	popm	r0-r7,pc
8000acf2:	d7 03       	nop

8000acf4 <_localeconv_r>:
8000acf4:	fe cc d4 d0 	sub	r12,pc,-11056
8000acf8:	5e fc       	retal	r12
8000acfa:	d7 03       	nop

8000acfc <__smakebuf_r>:
8000acfc:	d4 21       	pushm	r4-r7,lr
8000acfe:	20 fd       	sub	sp,60
8000ad00:	96 68       	ld.sh	r8,r11[0xc]
8000ad02:	16 97       	mov	r7,r11
8000ad04:	18 96       	mov	r6,r12
8000ad06:	e2 18 00 02 	andl	r8,0x2,COH
8000ad0a:	c3 d1       	brne	8000ad84 <__smakebuf_r+0x88>
8000ad0c:	96 7b       	ld.sh	r11,r11[0xe]
8000ad0e:	f0 0b 19 00 	cp.h	r11,r8
8000ad12:	c0 55       	brlt	8000ad1c <__smakebuf_r+0x20>
8000ad14:	1a 9a       	mov	r10,sp
8000ad16:	e0 a0 04 81 	rcall	8000b618 <_fstat_r>
8000ad1a:	c0 f4       	brge	8000ad38 <__smakebuf_r+0x3c>
8000ad1c:	8e 65       	ld.sh	r5,r7[0xc]
8000ad1e:	0a 98       	mov	r8,r5
8000ad20:	ab b8       	sbr	r8,0xb
8000ad22:	e2 15 00 80 	andl	r5,0x80,COH
8000ad26:	ae 68       	st.h	r7[0xc],r8
8000ad28:	30 04       	mov	r4,0
8000ad2a:	e0 68 04 00 	mov	r8,1024
8000ad2e:	f9 b5 01 40 	movne	r5,64
8000ad32:	f0 05 17 00 	moveq	r5,r8
8000ad36:	c1 c8       	rjmp	8000ad6e <__smakebuf_r+0x72>
8000ad38:	40 18       	lddsp	r8,sp[0x4]
8000ad3a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000ad3e:	e0 48 20 00 	cp.w	r8,8192
8000ad42:	5f 04       	sreq	r4
8000ad44:	e0 48 80 00 	cp.w	r8,32768
8000ad48:	c0 e1       	brne	8000ad64 <__smakebuf_r+0x68>
8000ad4a:	6e b9       	ld.w	r9,r7[0x2c]
8000ad4c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000ad50:	10 39       	cp.w	r9,r8
8000ad52:	c0 91       	brne	8000ad64 <__smakebuf_r+0x68>
8000ad54:	8e 68       	ld.sh	r8,r7[0xc]
8000ad56:	e0 65 04 00 	mov	r5,1024
8000ad5a:	ab a8       	sbr	r8,0xa
8000ad5c:	ef 45 00 50 	st.w	r7[80],r5
8000ad60:	ae 68       	st.h	r7[0xc],r8
8000ad62:	c0 68       	rjmp	8000ad6e <__smakebuf_r+0x72>
8000ad64:	8e 68       	ld.sh	r8,r7[0xc]
8000ad66:	e0 65 04 00 	mov	r5,1024
8000ad6a:	ab b8       	sbr	r8,0xb
8000ad6c:	ae 68       	st.h	r7[0xc],r8
8000ad6e:	0a 9b       	mov	r11,r5
8000ad70:	0c 9c       	mov	r12,r6
8000ad72:	fe b0 df 23 	rcall	80006bb8 <_malloc_r>
8000ad76:	8e 68       	ld.sh	r8,r7[0xc]
8000ad78:	c0 d1       	brne	8000ad92 <__smakebuf_r+0x96>
8000ad7a:	ed b8 00 09 	bld	r8,0x9
8000ad7e:	c1 b0       	breq	8000adb4 <__smakebuf_r+0xb8>
8000ad80:	a1 b8       	sbr	r8,0x1
8000ad82:	ae 68       	st.h	r7[0xc],r8
8000ad84:	ee c8 ff b9 	sub	r8,r7,-71
8000ad88:	8f 48       	st.w	r7[0x10],r8
8000ad8a:	8f 08       	st.w	r7[0x0],r8
8000ad8c:	30 18       	mov	r8,1
8000ad8e:	8f 58       	st.w	r7[0x14],r8
8000ad90:	c1 28       	rjmp	8000adb4 <__smakebuf_r+0xb8>
8000ad92:	a7 b8       	sbr	r8,0x7
8000ad94:	8f 4c       	st.w	r7[0x10],r12
8000ad96:	ae 68       	st.h	r7[0xc],r8
8000ad98:	8f 55       	st.w	r7[0x14],r5
8000ad9a:	fe c8 06 e6 	sub	r8,pc,1766
8000ad9e:	8f 0c       	st.w	r7[0x0],r12
8000ada0:	8d a8       	st.w	r6[0x28],r8
8000ada2:	58 04       	cp.w	r4,0
8000ada4:	c0 80       	breq	8000adb4 <__smakebuf_r+0xb8>
8000ada6:	8e 7c       	ld.sh	r12,r7[0xe]
8000ada8:	fe b0 e3 94 	rcall	800074d0 <isatty>
8000adac:	c0 40       	breq	8000adb4 <__smakebuf_r+0xb8>
8000adae:	8e 68       	ld.sh	r8,r7[0xc]
8000adb0:	a1 a8       	sbr	r8,0x0
8000adb2:	ae 68       	st.h	r7[0xc],r8
8000adb4:	2f 1d       	sub	sp,-60
8000adb6:	d8 22       	popm	r4-r7,pc

8000adb8 <memchr>:
8000adb8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000adbc:	c0 68       	rjmp	8000adc8 <memchr+0x10>
8000adbe:	20 1a       	sub	r10,1
8000adc0:	19 88       	ld.ub	r8,r12[0x0]
8000adc2:	16 38       	cp.w	r8,r11
8000adc4:	5e 0c       	reteq	r12
8000adc6:	2f fc       	sub	r12,-1
8000adc8:	58 0a       	cp.w	r10,0
8000adca:	cf a1       	brne	8000adbe <memchr+0x6>
8000adcc:	5e fa       	retal	r10

8000adce <memmove>:
8000adce:	d4 01       	pushm	lr
8000add0:	18 3b       	cp.w	r11,r12
8000add2:	c1 92       	brcc	8000ae04 <memmove+0x36>
8000add4:	f6 0a 00 09 	add	r9,r11,r10
8000add8:	12 3c       	cp.w	r12,r9
8000adda:	c1 52       	brcc	8000ae04 <memmove+0x36>
8000addc:	f8 0a 00 0b 	add	r11,r12,r10
8000ade0:	30 08       	mov	r8,0
8000ade2:	c0 68       	rjmp	8000adee <memmove+0x20>
8000ade4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ade8:	20 1a       	sub	r10,1
8000adea:	f6 08 0b 0e 	st.b	r11[r8],lr
8000adee:	20 18       	sub	r8,1
8000adf0:	58 0a       	cp.w	r10,0
8000adf2:	cf 91       	brne	8000ade4 <memmove+0x16>
8000adf4:	d8 02       	popm	pc
8000adf6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000adfa:	20 1a       	sub	r10,1
8000adfc:	f8 08 0b 09 	st.b	r12[r8],r9
8000ae00:	2f f8       	sub	r8,-1
8000ae02:	c0 28       	rjmp	8000ae06 <memmove+0x38>
8000ae04:	30 08       	mov	r8,0
8000ae06:	58 0a       	cp.w	r10,0
8000ae08:	cf 71       	brne	8000adf6 <memmove+0x28>
8000ae0a:	d8 02       	popm	pc

8000ae0c <__hi0bits>:
8000ae0c:	18 98       	mov	r8,r12
8000ae0e:	e0 1c 00 00 	andl	r12,0x0
8000ae12:	f0 09 15 10 	lsl	r9,r8,0x10
8000ae16:	58 0c       	cp.w	r12,0
8000ae18:	f2 08 17 00 	moveq	r8,r9
8000ae1c:	f9 bc 00 10 	moveq	r12,16
8000ae20:	f9 bc 01 00 	movne	r12,0
8000ae24:	10 9a       	mov	r10,r8
8000ae26:	f0 09 15 08 	lsl	r9,r8,0x8
8000ae2a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ae2e:	f7 bc 00 f8 	subeq	r12,-8
8000ae32:	f2 08 17 00 	moveq	r8,r9
8000ae36:	10 9a       	mov	r10,r8
8000ae38:	f0 09 15 04 	lsl	r9,r8,0x4
8000ae3c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000ae40:	f7 bc 00 fc 	subeq	r12,-4
8000ae44:	f2 08 17 00 	moveq	r8,r9
8000ae48:	10 9a       	mov	r10,r8
8000ae4a:	f0 09 15 02 	lsl	r9,r8,0x2
8000ae4e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000ae52:	f7 bc 00 fe 	subeq	r12,-2
8000ae56:	f2 08 17 00 	moveq	r8,r9
8000ae5a:	58 08       	cp.w	r8,0
8000ae5c:	5e 5c       	retlt	r12
8000ae5e:	ed b8 00 1e 	bld	r8,0x1e
8000ae62:	f9 bc 01 20 	movne	r12,32
8000ae66:	f7 bc 00 ff 	subeq	r12,-1
8000ae6a:	5e fc       	retal	r12

8000ae6c <__lo0bits>:
8000ae6c:	18 99       	mov	r9,r12
8000ae6e:	78 08       	ld.w	r8,r12[0x0]
8000ae70:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000ae74:	c1 50       	breq	8000ae9e <__lo0bits+0x32>
8000ae76:	ed b8 00 00 	bld	r8,0x0
8000ae7a:	c0 21       	brne	8000ae7e <__lo0bits+0x12>
8000ae7c:	5e fd       	retal	0
8000ae7e:	10 9b       	mov	r11,r8
8000ae80:	f0 0a 16 01 	lsr	r10,r8,0x1
8000ae84:	e2 1b 00 02 	andl	r11,0x2,COH
8000ae88:	a3 88       	lsr	r8,0x2
8000ae8a:	58 0b       	cp.w	r11,0
8000ae8c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000ae90:	f9 bc 01 01 	movne	r12,1
8000ae94:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000ae98:	f9 bc 00 02 	moveq	r12,2
8000ae9c:	5e fc       	retal	r12
8000ae9e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000aea2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000aea6:	58 0a       	cp.w	r10,0
8000aea8:	f6 08 17 00 	moveq	r8,r11
8000aeac:	f9 bc 00 10 	moveq	r12,16
8000aeb0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000aeb4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000aeb8:	58 0b       	cp.w	r11,0
8000aeba:	f7 bc 00 f8 	subeq	r12,-8
8000aebe:	f4 08 17 00 	moveq	r8,r10
8000aec2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000aec6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000aeca:	58 0b       	cp.w	r11,0
8000aecc:	f7 bc 00 fc 	subeq	r12,-4
8000aed0:	f4 08 17 00 	moveq	r8,r10
8000aed4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000aed8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000aedc:	58 0b       	cp.w	r11,0
8000aede:	f7 bc 00 fe 	subeq	r12,-2
8000aee2:	f4 08 17 00 	moveq	r8,r10
8000aee6:	ed b8 00 00 	bld	r8,0x0
8000aeea:	c0 60       	breq	8000aef6 <__lo0bits+0x8a>
8000aeec:	a1 98       	lsr	r8,0x1
8000aeee:	c0 31       	brne	8000aef4 <__lo0bits+0x88>
8000aef0:	32 0c       	mov	r12,32
8000aef2:	5e fc       	retal	r12
8000aef4:	2f fc       	sub	r12,-1
8000aef6:	93 08       	st.w	r9[0x0],r8
8000aef8:	5e fc       	retal	r12

8000aefa <__mcmp>:
8000aefa:	d4 01       	pushm	lr
8000aefc:	18 98       	mov	r8,r12
8000aefe:	76 49       	ld.w	r9,r11[0x10]
8000af00:	78 4c       	ld.w	r12,r12[0x10]
8000af02:	12 1c       	sub	r12,r9
8000af04:	c1 31       	brne	8000af2a <__mcmp+0x30>
8000af06:	2f b9       	sub	r9,-5
8000af08:	a3 69       	lsl	r9,0x2
8000af0a:	12 0b       	add	r11,r9
8000af0c:	f0 09 00 09 	add	r9,r8,r9
8000af10:	2e c8       	sub	r8,-20
8000af12:	13 4e       	ld.w	lr,--r9
8000af14:	17 4a       	ld.w	r10,--r11
8000af16:	14 3e       	cp.w	lr,r10
8000af18:	c0 60       	breq	8000af24 <__mcmp+0x2a>
8000af1a:	f9 bc 03 ff 	movlo	r12,-1
8000af1e:	f9 bc 02 01 	movhs	r12,1
8000af22:	d8 02       	popm	pc
8000af24:	10 39       	cp.w	r9,r8
8000af26:	fe 9b ff f6 	brhi	8000af12 <__mcmp+0x18>
8000af2a:	d8 02       	popm	pc

8000af2c <_Bfree>:
8000af2c:	d4 21       	pushm	r4-r7,lr
8000af2e:	18 97       	mov	r7,r12
8000af30:	16 95       	mov	r5,r11
8000af32:	78 96       	ld.w	r6,r12[0x24]
8000af34:	58 06       	cp.w	r6,0
8000af36:	c0 91       	brne	8000af48 <_Bfree+0x1c>
8000af38:	31 0c       	mov	r12,16
8000af3a:	fe b0 de 37 	rcall	80006ba8 <malloc>
8000af3e:	99 36       	st.w	r12[0xc],r6
8000af40:	8f 9c       	st.w	r7[0x24],r12
8000af42:	99 16       	st.w	r12[0x4],r6
8000af44:	99 26       	st.w	r12[0x8],r6
8000af46:	99 06       	st.w	r12[0x0],r6
8000af48:	58 05       	cp.w	r5,0
8000af4a:	c0 90       	breq	8000af5c <_Bfree+0x30>
8000af4c:	6a 19       	ld.w	r9,r5[0x4]
8000af4e:	6e 98       	ld.w	r8,r7[0x24]
8000af50:	70 38       	ld.w	r8,r8[0xc]
8000af52:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000af56:	8b 0a       	st.w	r5[0x0],r10
8000af58:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000af5c:	d8 22       	popm	r4-r7,pc
8000af5e:	d7 03       	nop

8000af60 <_Balloc>:
8000af60:	d4 21       	pushm	r4-r7,lr
8000af62:	18 97       	mov	r7,r12
8000af64:	16 96       	mov	r6,r11
8000af66:	78 95       	ld.w	r5,r12[0x24]
8000af68:	58 05       	cp.w	r5,0
8000af6a:	c0 91       	brne	8000af7c <_Balloc+0x1c>
8000af6c:	31 0c       	mov	r12,16
8000af6e:	fe b0 de 1d 	rcall	80006ba8 <malloc>
8000af72:	99 35       	st.w	r12[0xc],r5
8000af74:	8f 9c       	st.w	r7[0x24],r12
8000af76:	99 15       	st.w	r12[0x4],r5
8000af78:	99 25       	st.w	r12[0x8],r5
8000af7a:	99 05       	st.w	r12[0x0],r5
8000af7c:	6e 95       	ld.w	r5,r7[0x24]
8000af7e:	6a 38       	ld.w	r8,r5[0xc]
8000af80:	58 08       	cp.w	r8,0
8000af82:	c0 b1       	brne	8000af98 <_Balloc+0x38>
8000af84:	31 0a       	mov	r10,16
8000af86:	30 4b       	mov	r11,4
8000af88:	0e 9c       	mov	r12,r7
8000af8a:	e0 a0 02 a7 	rcall	8000b4d8 <_calloc_r>
8000af8e:	8b 3c       	st.w	r5[0xc],r12
8000af90:	6e 98       	ld.w	r8,r7[0x24]
8000af92:	70 3c       	ld.w	r12,r8[0xc]
8000af94:	58 0c       	cp.w	r12,0
8000af96:	c1 b0       	breq	8000afcc <_Balloc+0x6c>
8000af98:	6e 98       	ld.w	r8,r7[0x24]
8000af9a:	70 38       	ld.w	r8,r8[0xc]
8000af9c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000afa0:	70 0c       	ld.w	r12,r8[0x0]
8000afa2:	58 0c       	cp.w	r12,0
8000afa4:	c0 40       	breq	8000afac <_Balloc+0x4c>
8000afa6:	78 09       	ld.w	r9,r12[0x0]
8000afa8:	91 09       	st.w	r8[0x0],r9
8000afaa:	c0 e8       	rjmp	8000afc6 <_Balloc+0x66>
8000afac:	0e 9c       	mov	r12,r7
8000afae:	30 17       	mov	r7,1
8000afb0:	0e 9b       	mov	r11,r7
8000afb2:	ee 06 09 47 	lsl	r7,r7,r6
8000afb6:	ee ca ff fb 	sub	r10,r7,-5
8000afba:	a3 6a       	lsl	r10,0x2
8000afbc:	e0 a0 02 8e 	rcall	8000b4d8 <_calloc_r>
8000afc0:	c0 60       	breq	8000afcc <_Balloc+0x6c>
8000afc2:	99 16       	st.w	r12[0x4],r6
8000afc4:	99 27       	st.w	r12[0x8],r7
8000afc6:	30 08       	mov	r8,0
8000afc8:	99 38       	st.w	r12[0xc],r8
8000afca:	99 48       	st.w	r12[0x10],r8
8000afcc:	d8 22       	popm	r4-r7,pc
8000afce:	d7 03       	nop

8000afd0 <__d2b>:
8000afd0:	d4 31       	pushm	r0-r7,lr
8000afd2:	20 2d       	sub	sp,8
8000afd4:	16 93       	mov	r3,r11
8000afd6:	12 96       	mov	r6,r9
8000afd8:	10 95       	mov	r5,r8
8000afda:	14 92       	mov	r2,r10
8000afdc:	30 1b       	mov	r11,1
8000afde:	cc 1f       	rcall	8000af60 <_Balloc>
8000afe0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000afe4:	50 09       	stdsp	sp[0x0],r9
8000afe6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000afea:	b5 a9       	sbr	r9,0x14
8000afec:	f0 01 16 14 	lsr	r1,r8,0x14
8000aff0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000aff4:	18 94       	mov	r4,r12
8000aff6:	58 02       	cp.w	r2,0
8000aff8:	c1 d0       	breq	8000b032 <__d2b+0x62>
8000affa:	fa cc ff f8 	sub	r12,sp,-8
8000affe:	18 d2       	st.w	--r12,r2
8000b000:	c3 6f       	rcall	8000ae6c <__lo0bits>
8000b002:	40 18       	lddsp	r8,sp[0x4]
8000b004:	c0 d0       	breq	8000b01e <__d2b+0x4e>
8000b006:	40 09       	lddsp	r9,sp[0x0]
8000b008:	f8 0a 11 20 	rsub	r10,r12,32
8000b00c:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b010:	f5 e8 10 08 	or	r8,r10,r8
8000b014:	89 58       	st.w	r4[0x14],r8
8000b016:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b01a:	50 09       	stdsp	sp[0x0],r9
8000b01c:	c0 28       	rjmp	8000b020 <__d2b+0x50>
8000b01e:	89 58       	st.w	r4[0x14],r8
8000b020:	40 08       	lddsp	r8,sp[0x0]
8000b022:	58 08       	cp.w	r8,0
8000b024:	f9 b3 01 02 	movne	r3,2
8000b028:	f9 b3 00 01 	moveq	r3,1
8000b02c:	89 68       	st.w	r4[0x18],r8
8000b02e:	89 43       	st.w	r4[0x10],r3
8000b030:	c0 88       	rjmp	8000b040 <__d2b+0x70>
8000b032:	1a 9c       	mov	r12,sp
8000b034:	c1 cf       	rcall	8000ae6c <__lo0bits>
8000b036:	30 13       	mov	r3,1
8000b038:	40 08       	lddsp	r8,sp[0x0]
8000b03a:	2e 0c       	sub	r12,-32
8000b03c:	89 43       	st.w	r4[0x10],r3
8000b03e:	89 58       	st.w	r4[0x14],r8
8000b040:	58 01       	cp.w	r1,0
8000b042:	c0 90       	breq	8000b054 <__d2b+0x84>
8000b044:	e2 c1 04 33 	sub	r1,r1,1075
8000b048:	18 01       	add	r1,r12
8000b04a:	8d 01       	st.w	r6[0x0],r1
8000b04c:	f8 0c 11 35 	rsub	r12,r12,53
8000b050:	8b 0c       	st.w	r5[0x0],r12
8000b052:	c0 c8       	rjmp	8000b06a <__d2b+0x9a>
8000b054:	e6 c8 ff fc 	sub	r8,r3,-4
8000b058:	f8 cc 04 32 	sub	r12,r12,1074
8000b05c:	a5 73       	lsl	r3,0x5
8000b05e:	8d 0c       	st.w	r6[0x0],r12
8000b060:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b064:	cd 4e       	rcall	8000ae0c <__hi0bits>
8000b066:	18 13       	sub	r3,r12
8000b068:	8b 03       	st.w	r5[0x0],r3
8000b06a:	08 9c       	mov	r12,r4
8000b06c:	2f ed       	sub	sp,-8
8000b06e:	d8 32       	popm	r0-r7,pc

8000b070 <__mdiff>:
8000b070:	d4 31       	pushm	r0-r7,lr
8000b072:	74 48       	ld.w	r8,r10[0x10]
8000b074:	76 45       	ld.w	r5,r11[0x10]
8000b076:	16 97       	mov	r7,r11
8000b078:	14 96       	mov	r6,r10
8000b07a:	10 15       	sub	r5,r8
8000b07c:	c1 31       	brne	8000b0a2 <__mdiff+0x32>
8000b07e:	2f b8       	sub	r8,-5
8000b080:	ee ce ff ec 	sub	lr,r7,-20
8000b084:	a3 68       	lsl	r8,0x2
8000b086:	f4 08 00 0b 	add	r11,r10,r8
8000b08a:	ee 08 00 08 	add	r8,r7,r8
8000b08e:	11 4a       	ld.w	r10,--r8
8000b090:	17 49       	ld.w	r9,--r11
8000b092:	12 3a       	cp.w	r10,r9
8000b094:	c0 30       	breq	8000b09a <__mdiff+0x2a>
8000b096:	c0 e2       	brcc	8000b0b2 <__mdiff+0x42>
8000b098:	c0 78       	rjmp	8000b0a6 <__mdiff+0x36>
8000b09a:	1c 38       	cp.w	r8,lr
8000b09c:	fe 9b ff f9 	brhi	8000b08e <__mdiff+0x1e>
8000b0a0:	c4 98       	rjmp	8000b132 <__mdiff+0xc2>
8000b0a2:	58 05       	cp.w	r5,0
8000b0a4:	c0 64       	brge	8000b0b0 <__mdiff+0x40>
8000b0a6:	0e 98       	mov	r8,r7
8000b0a8:	30 15       	mov	r5,1
8000b0aa:	0c 97       	mov	r7,r6
8000b0ac:	10 96       	mov	r6,r8
8000b0ae:	c0 28       	rjmp	8000b0b2 <__mdiff+0x42>
8000b0b0:	30 05       	mov	r5,0
8000b0b2:	6e 1b       	ld.w	r11,r7[0x4]
8000b0b4:	c5 6f       	rcall	8000af60 <_Balloc>
8000b0b6:	6e 49       	ld.w	r9,r7[0x10]
8000b0b8:	6c 44       	ld.w	r4,r6[0x10]
8000b0ba:	99 35       	st.w	r12[0xc],r5
8000b0bc:	2f b4       	sub	r4,-5
8000b0be:	f2 c5 ff fb 	sub	r5,r9,-5
8000b0c2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b0c6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b0ca:	2e c6       	sub	r6,-20
8000b0cc:	2e c7       	sub	r7,-20
8000b0ce:	f8 c8 ff ec 	sub	r8,r12,-20
8000b0d2:	30 0a       	mov	r10,0
8000b0d4:	0f 0e       	ld.w	lr,r7++
8000b0d6:	0d 0b       	ld.w	r11,r6++
8000b0d8:	fc 02 16 10 	lsr	r2,lr,0x10
8000b0dc:	f6 03 16 10 	lsr	r3,r11,0x10
8000b0e0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b0e4:	e4 03 01 03 	sub	r3,r2,r3
8000b0e8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b0ec:	fc 0b 01 0b 	sub	r11,lr,r11
8000b0f0:	f6 0a 00 0a 	add	r10,r11,r10
8000b0f4:	b0 1a       	st.h	r8[0x2],r10
8000b0f6:	b1 4a       	asr	r10,0x10
8000b0f8:	e6 0a 00 0a 	add	r10,r3,r10
8000b0fc:	b0 0a       	st.h	r8[0x0],r10
8000b0fe:	2f c8       	sub	r8,-4
8000b100:	b1 4a       	asr	r10,0x10
8000b102:	08 36       	cp.w	r6,r4
8000b104:	ce 83       	brcs	8000b0d4 <__mdiff+0x64>
8000b106:	c0 d8       	rjmp	8000b120 <__mdiff+0xb0>
8000b108:	0f 0b       	ld.w	r11,r7++
8000b10a:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b10e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b112:	16 0a       	add	r10,r11
8000b114:	b0 1a       	st.h	r8[0x2],r10
8000b116:	b1 4a       	asr	r10,0x10
8000b118:	1c 0a       	add	r10,lr
8000b11a:	b0 0a       	st.h	r8[0x0],r10
8000b11c:	2f c8       	sub	r8,-4
8000b11e:	b1 4a       	asr	r10,0x10
8000b120:	0a 37       	cp.w	r7,r5
8000b122:	cf 33       	brcs	8000b108 <__mdiff+0x98>
8000b124:	c0 28       	rjmp	8000b128 <__mdiff+0xb8>
8000b126:	20 19       	sub	r9,1
8000b128:	11 4a       	ld.w	r10,--r8
8000b12a:	58 0a       	cp.w	r10,0
8000b12c:	cf d0       	breq	8000b126 <__mdiff+0xb6>
8000b12e:	99 49       	st.w	r12[0x10],r9
8000b130:	d8 32       	popm	r0-r7,pc
8000b132:	30 0b       	mov	r11,0
8000b134:	c1 6f       	rcall	8000af60 <_Balloc>
8000b136:	30 18       	mov	r8,1
8000b138:	99 48       	st.w	r12[0x10],r8
8000b13a:	30 08       	mov	r8,0
8000b13c:	99 58       	st.w	r12[0x14],r8
8000b13e:	d8 32       	popm	r0-r7,pc

8000b140 <__lshift>:
8000b140:	d4 31       	pushm	r0-r7,lr
8000b142:	16 97       	mov	r7,r11
8000b144:	76 46       	ld.w	r6,r11[0x10]
8000b146:	f4 02 14 05 	asr	r2,r10,0x5
8000b14a:	2f f6       	sub	r6,-1
8000b14c:	14 93       	mov	r3,r10
8000b14e:	18 94       	mov	r4,r12
8000b150:	04 06       	add	r6,r2
8000b152:	76 1b       	ld.w	r11,r11[0x4]
8000b154:	6e 28       	ld.w	r8,r7[0x8]
8000b156:	c0 38       	rjmp	8000b15c <__lshift+0x1c>
8000b158:	2f fb       	sub	r11,-1
8000b15a:	a1 78       	lsl	r8,0x1
8000b15c:	10 36       	cp.w	r6,r8
8000b15e:	fe 99 ff fd 	brgt	8000b158 <__lshift+0x18>
8000b162:	08 9c       	mov	r12,r4
8000b164:	cf ee       	rcall	8000af60 <_Balloc>
8000b166:	30 09       	mov	r9,0
8000b168:	18 95       	mov	r5,r12
8000b16a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b16e:	12 9a       	mov	r10,r9
8000b170:	c0 38       	rjmp	8000b176 <__lshift+0x36>
8000b172:	10 aa       	st.w	r8++,r10
8000b174:	2f f9       	sub	r9,-1
8000b176:	04 39       	cp.w	r9,r2
8000b178:	cf d5       	brlt	8000b172 <__lshift+0x32>
8000b17a:	6e 4b       	ld.w	r11,r7[0x10]
8000b17c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b180:	2f bb       	sub	r11,-5
8000b182:	ee c9 ff ec 	sub	r9,r7,-20
8000b186:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b18a:	58 03       	cp.w	r3,0
8000b18c:	c1 30       	breq	8000b1b2 <__lshift+0x72>
8000b18e:	e6 0c 11 20 	rsub	r12,r3,32
8000b192:	30 0a       	mov	r10,0
8000b194:	72 02       	ld.w	r2,r9[0x0]
8000b196:	e4 03 09 42 	lsl	r2,r2,r3
8000b19a:	04 4a       	or	r10,r2
8000b19c:	10 aa       	st.w	r8++,r10
8000b19e:	13 0a       	ld.w	r10,r9++
8000b1a0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b1a4:	16 39       	cp.w	r9,r11
8000b1a6:	cf 73       	brcs	8000b194 <__lshift+0x54>
8000b1a8:	91 0a       	st.w	r8[0x0],r10
8000b1aa:	58 0a       	cp.w	r10,0
8000b1ac:	c0 70       	breq	8000b1ba <__lshift+0x7a>
8000b1ae:	2f f6       	sub	r6,-1
8000b1b0:	c0 58       	rjmp	8000b1ba <__lshift+0x7a>
8000b1b2:	13 0a       	ld.w	r10,r9++
8000b1b4:	10 aa       	st.w	r8++,r10
8000b1b6:	16 39       	cp.w	r9,r11
8000b1b8:	cf d3       	brcs	8000b1b2 <__lshift+0x72>
8000b1ba:	08 9c       	mov	r12,r4
8000b1bc:	20 16       	sub	r6,1
8000b1be:	0e 9b       	mov	r11,r7
8000b1c0:	8b 46       	st.w	r5[0x10],r6
8000b1c2:	cb 5e       	rcall	8000af2c <_Bfree>
8000b1c4:	0a 9c       	mov	r12,r5
8000b1c6:	d8 32       	popm	r0-r7,pc

8000b1c8 <__multiply>:
8000b1c8:	d4 31       	pushm	r0-r7,lr
8000b1ca:	20 2d       	sub	sp,8
8000b1cc:	76 49       	ld.w	r9,r11[0x10]
8000b1ce:	74 48       	ld.w	r8,r10[0x10]
8000b1d0:	16 96       	mov	r6,r11
8000b1d2:	14 95       	mov	r5,r10
8000b1d4:	10 39       	cp.w	r9,r8
8000b1d6:	ec 08 17 50 	movlt	r8,r6
8000b1da:	ea 06 17 50 	movlt	r6,r5
8000b1de:	f0 05 17 50 	movlt	r5,r8
8000b1e2:	6c 28       	ld.w	r8,r6[0x8]
8000b1e4:	76 43       	ld.w	r3,r11[0x10]
8000b1e6:	74 42       	ld.w	r2,r10[0x10]
8000b1e8:	76 1b       	ld.w	r11,r11[0x4]
8000b1ea:	e4 03 00 07 	add	r7,r2,r3
8000b1ee:	10 37       	cp.w	r7,r8
8000b1f0:	f7 bb 09 ff 	subgt	r11,-1
8000b1f4:	cb 6e       	rcall	8000af60 <_Balloc>
8000b1f6:	ee c4 ff fb 	sub	r4,r7,-5
8000b1fa:	f8 c9 ff ec 	sub	r9,r12,-20
8000b1fe:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b202:	30 0a       	mov	r10,0
8000b204:	12 98       	mov	r8,r9
8000b206:	c0 28       	rjmp	8000b20a <__multiply+0x42>
8000b208:	10 aa       	st.w	r8++,r10
8000b20a:	08 38       	cp.w	r8,r4
8000b20c:	cf e3       	brcs	8000b208 <__multiply+0x40>
8000b20e:	2f b3       	sub	r3,-5
8000b210:	2f b2       	sub	r2,-5
8000b212:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b216:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b21a:	ec cb ff ec 	sub	r11,r6,-20
8000b21e:	50 12       	stdsp	sp[0x4],r2
8000b220:	ea ca ff ec 	sub	r10,r5,-20
8000b224:	c4 48       	rjmp	8000b2ac <__multiply+0xe4>
8000b226:	94 95       	ld.uh	r5,r10[0x2]
8000b228:	58 05       	cp.w	r5,0
8000b22a:	c2 00       	breq	8000b26a <__multiply+0xa2>
8000b22c:	12 98       	mov	r8,r9
8000b22e:	16 96       	mov	r6,r11
8000b230:	30 0e       	mov	lr,0
8000b232:	50 09       	stdsp	sp[0x0],r9
8000b234:	0d 02       	ld.w	r2,r6++
8000b236:	e4 00 16 10 	lsr	r0,r2,0x10
8000b23a:	70 01       	ld.w	r1,r8[0x0]
8000b23c:	70 09       	ld.w	r9,r8[0x0]
8000b23e:	b1 81       	lsr	r1,0x10
8000b240:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b244:	e0 05 03 41 	mac	r1,r0,r5
8000b248:	ab 32       	mul	r2,r5
8000b24a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b24e:	00 02       	add	r2,r0
8000b250:	e4 0e 00 0e 	add	lr,r2,lr
8000b254:	b0 1e       	st.h	r8[0x2],lr
8000b256:	b1 8e       	lsr	lr,0x10
8000b258:	1c 01       	add	r1,lr
8000b25a:	b0 01       	st.h	r8[0x0],r1
8000b25c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b260:	2f c8       	sub	r8,-4
8000b262:	06 36       	cp.w	r6,r3
8000b264:	ce 83       	brcs	8000b234 <__multiply+0x6c>
8000b266:	40 09       	lddsp	r9,sp[0x0]
8000b268:	91 0e       	st.w	r8[0x0],lr
8000b26a:	94 86       	ld.uh	r6,r10[0x0]
8000b26c:	58 06       	cp.w	r6,0
8000b26e:	c1 d0       	breq	8000b2a8 <__multiply+0xe0>
8000b270:	72 02       	ld.w	r2,r9[0x0]
8000b272:	12 98       	mov	r8,r9
8000b274:	16 9e       	mov	lr,r11
8000b276:	30 05       	mov	r5,0
8000b278:	b0 12       	st.h	r8[0x2],r2
8000b27a:	1d 01       	ld.w	r1,lr++
8000b27c:	90 82       	ld.uh	r2,r8[0x0]
8000b27e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b282:	ad 30       	mul	r0,r6
8000b284:	e0 02 00 02 	add	r2,r0,r2
8000b288:	e4 05 00 05 	add	r5,r2,r5
8000b28c:	b0 05       	st.h	r8[0x0],r5
8000b28e:	b1 85       	lsr	r5,0x10
8000b290:	b1 81       	lsr	r1,0x10
8000b292:	2f c8       	sub	r8,-4
8000b294:	ad 31       	mul	r1,r6
8000b296:	90 92       	ld.uh	r2,r8[0x2]
8000b298:	e2 02 00 02 	add	r2,r1,r2
8000b29c:	0a 02       	add	r2,r5
8000b29e:	e4 05 16 10 	lsr	r5,r2,0x10
8000b2a2:	06 3e       	cp.w	lr,r3
8000b2a4:	ce a3       	brcs	8000b278 <__multiply+0xb0>
8000b2a6:	91 02       	st.w	r8[0x0],r2
8000b2a8:	2f ca       	sub	r10,-4
8000b2aa:	2f c9       	sub	r9,-4
8000b2ac:	40 18       	lddsp	r8,sp[0x4]
8000b2ae:	10 3a       	cp.w	r10,r8
8000b2b0:	cb b3       	brcs	8000b226 <__multiply+0x5e>
8000b2b2:	c0 28       	rjmp	8000b2b6 <__multiply+0xee>
8000b2b4:	20 17       	sub	r7,1
8000b2b6:	58 07       	cp.w	r7,0
8000b2b8:	e0 8a 00 05 	brle	8000b2c2 <__multiply+0xfa>
8000b2bc:	09 48       	ld.w	r8,--r4
8000b2be:	58 08       	cp.w	r8,0
8000b2c0:	cf a0       	breq	8000b2b4 <__multiply+0xec>
8000b2c2:	99 47       	st.w	r12[0x10],r7
8000b2c4:	2f ed       	sub	sp,-8
8000b2c6:	d8 32       	popm	r0-r7,pc

8000b2c8 <__i2b>:
8000b2c8:	d4 21       	pushm	r4-r7,lr
8000b2ca:	16 97       	mov	r7,r11
8000b2cc:	30 1b       	mov	r11,1
8000b2ce:	c4 9e       	rcall	8000af60 <_Balloc>
8000b2d0:	30 19       	mov	r9,1
8000b2d2:	99 57       	st.w	r12[0x14],r7
8000b2d4:	99 49       	st.w	r12[0x10],r9
8000b2d6:	d8 22       	popm	r4-r7,pc

8000b2d8 <__multadd>:
8000b2d8:	d4 31       	pushm	r0-r7,lr
8000b2da:	30 08       	mov	r8,0
8000b2dc:	12 95       	mov	r5,r9
8000b2de:	16 97       	mov	r7,r11
8000b2e0:	18 96       	mov	r6,r12
8000b2e2:	76 44       	ld.w	r4,r11[0x10]
8000b2e4:	f6 c9 ff ec 	sub	r9,r11,-20
8000b2e8:	72 0b       	ld.w	r11,r9[0x0]
8000b2ea:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b2ee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b2f2:	f4 0c 02 4c 	mul	r12,r10,r12
8000b2f6:	f4 0b 03 45 	mac	r5,r10,r11
8000b2fa:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b2fe:	b1 85       	lsr	r5,0x10
8000b300:	18 05       	add	r5,r12
8000b302:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b306:	f8 0b 00 0b 	add	r11,r12,r11
8000b30a:	12 ab       	st.w	r9++,r11
8000b30c:	2f f8       	sub	r8,-1
8000b30e:	b1 85       	lsr	r5,0x10
8000b310:	08 38       	cp.w	r8,r4
8000b312:	ce b5       	brlt	8000b2e8 <__multadd+0x10>
8000b314:	58 05       	cp.w	r5,0
8000b316:	c1 c0       	breq	8000b34e <__multadd+0x76>
8000b318:	6e 28       	ld.w	r8,r7[0x8]
8000b31a:	10 34       	cp.w	r4,r8
8000b31c:	c1 35       	brlt	8000b342 <__multadd+0x6a>
8000b31e:	6e 1b       	ld.w	r11,r7[0x4]
8000b320:	0c 9c       	mov	r12,r6
8000b322:	2f fb       	sub	r11,-1
8000b324:	c1 ee       	rcall	8000af60 <_Balloc>
8000b326:	6e 4a       	ld.w	r10,r7[0x10]
8000b328:	ee cb ff f4 	sub	r11,r7,-12
8000b32c:	18 93       	mov	r3,r12
8000b32e:	2f ea       	sub	r10,-2
8000b330:	2f 4c       	sub	r12,-12
8000b332:	a3 6a       	lsl	r10,0x2
8000b334:	fe b0 de 71 	rcall	80007016 <memcpy>
8000b338:	0e 9b       	mov	r11,r7
8000b33a:	0c 9c       	mov	r12,r6
8000b33c:	fe b0 fd f8 	rcall	8000af2c <_Bfree>
8000b340:	06 97       	mov	r7,r3
8000b342:	e8 c8 ff ff 	sub	r8,r4,-1
8000b346:	2f b4       	sub	r4,-5
8000b348:	8f 48       	st.w	r7[0x10],r8
8000b34a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b34e:	0e 9c       	mov	r12,r7
8000b350:	d8 32       	popm	r0-r7,pc
8000b352:	d7 03       	nop

8000b354 <__pow5mult>:
8000b354:	d4 31       	pushm	r0-r7,lr
8000b356:	14 96       	mov	r6,r10
8000b358:	18 97       	mov	r7,r12
8000b35a:	16 94       	mov	r4,r11
8000b35c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b360:	c0 90       	breq	8000b372 <__pow5mult+0x1e>
8000b362:	20 18       	sub	r8,1
8000b364:	fe c9 db 04 	sub	r9,pc,-9468
8000b368:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b36c:	30 09       	mov	r9,0
8000b36e:	cb 5f       	rcall	8000b2d8 <__multadd>
8000b370:	18 94       	mov	r4,r12
8000b372:	a3 46       	asr	r6,0x2
8000b374:	c3 40       	breq	8000b3dc <__pow5mult+0x88>
8000b376:	6e 95       	ld.w	r5,r7[0x24]
8000b378:	58 05       	cp.w	r5,0
8000b37a:	c0 91       	brne	8000b38c <__pow5mult+0x38>
8000b37c:	31 0c       	mov	r12,16
8000b37e:	fe b0 dc 15 	rcall	80006ba8 <malloc>
8000b382:	99 35       	st.w	r12[0xc],r5
8000b384:	8f 9c       	st.w	r7[0x24],r12
8000b386:	99 15       	st.w	r12[0x4],r5
8000b388:	99 25       	st.w	r12[0x8],r5
8000b38a:	99 05       	st.w	r12[0x0],r5
8000b38c:	6e 93       	ld.w	r3,r7[0x24]
8000b38e:	66 25       	ld.w	r5,r3[0x8]
8000b390:	58 05       	cp.w	r5,0
8000b392:	c0 c1       	brne	8000b3aa <__pow5mult+0x56>
8000b394:	e0 6b 02 71 	mov	r11,625
8000b398:	0e 9c       	mov	r12,r7
8000b39a:	c9 7f       	rcall	8000b2c8 <__i2b>
8000b39c:	87 2c       	st.w	r3[0x8],r12
8000b39e:	30 08       	mov	r8,0
8000b3a0:	18 95       	mov	r5,r12
8000b3a2:	99 08       	st.w	r12[0x0],r8
8000b3a4:	c0 38       	rjmp	8000b3aa <__pow5mult+0x56>
8000b3a6:	06 9c       	mov	r12,r3
8000b3a8:	18 95       	mov	r5,r12
8000b3aa:	ed b6 00 00 	bld	r6,0x0
8000b3ae:	c0 b1       	brne	8000b3c4 <__pow5mult+0x70>
8000b3b0:	08 9b       	mov	r11,r4
8000b3b2:	0a 9a       	mov	r10,r5
8000b3b4:	0e 9c       	mov	r12,r7
8000b3b6:	c0 9f       	rcall	8000b1c8 <__multiply>
8000b3b8:	08 9b       	mov	r11,r4
8000b3ba:	18 93       	mov	r3,r12
8000b3bc:	0e 9c       	mov	r12,r7
8000b3be:	06 94       	mov	r4,r3
8000b3c0:	fe b0 fd b6 	rcall	8000af2c <_Bfree>
8000b3c4:	a1 56       	asr	r6,0x1
8000b3c6:	c0 b0       	breq	8000b3dc <__pow5mult+0x88>
8000b3c8:	6a 03       	ld.w	r3,r5[0x0]
8000b3ca:	58 03       	cp.w	r3,0
8000b3cc:	ce d1       	brne	8000b3a6 <__pow5mult+0x52>
8000b3ce:	0a 9a       	mov	r10,r5
8000b3d0:	0a 9b       	mov	r11,r5
8000b3d2:	0e 9c       	mov	r12,r7
8000b3d4:	cf ae       	rcall	8000b1c8 <__multiply>
8000b3d6:	8b 0c       	st.w	r5[0x0],r12
8000b3d8:	99 03       	st.w	r12[0x0],r3
8000b3da:	ce 7b       	rjmp	8000b3a8 <__pow5mult+0x54>
8000b3dc:	08 9c       	mov	r12,r4
8000b3de:	d8 32       	popm	r0-r7,pc

8000b3e0 <__isinfd>:
8000b3e0:	14 98       	mov	r8,r10
8000b3e2:	fc 19 7f f0 	movh	r9,0x7ff0
8000b3e6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b3ea:	f0 0b 11 00 	rsub	r11,r8,0
8000b3ee:	f7 e8 10 08 	or	r8,r11,r8
8000b3f2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b3f6:	f2 08 01 08 	sub	r8,r9,r8
8000b3fa:	f0 0c 11 00 	rsub	r12,r8,0
8000b3fe:	f9 e8 10 08 	or	r8,r12,r8
8000b402:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b406:	2f fc       	sub	r12,-1
8000b408:	5e fc       	retal	r12

8000b40a <__isnand>:
8000b40a:	14 98       	mov	r8,r10
8000b40c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b410:	f0 0c 11 00 	rsub	r12,r8,0
8000b414:	10 4c       	or	r12,r8
8000b416:	fc 18 7f f0 	movh	r8,0x7ff0
8000b41a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b41e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b422:	bf 9c       	lsr	r12,0x1f
8000b424:	5e fc       	retal	r12
8000b426:	d7 03       	nop

8000b428 <__sclose>:
8000b428:	d4 01       	pushm	lr
8000b42a:	96 7b       	ld.sh	r11,r11[0xe]
8000b42c:	c8 2c       	rcall	8000b530 <_close_r>
8000b42e:	d8 02       	popm	pc

8000b430 <__sseek>:
8000b430:	d4 21       	pushm	r4-r7,lr
8000b432:	16 97       	mov	r7,r11
8000b434:	96 7b       	ld.sh	r11,r11[0xe]
8000b436:	c0 3d       	rcall	8000b63c <_lseek_r>
8000b438:	8e 68       	ld.sh	r8,r7[0xc]
8000b43a:	10 99       	mov	r9,r8
8000b43c:	ad c8       	cbr	r8,0xc
8000b43e:	ad a9       	sbr	r9,0xc
8000b440:	5b fc       	cp.w	r12,-1
8000b442:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b446:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b44a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b44e:	d8 22       	popm	r4-r7,pc

8000b450 <__swrite>:
8000b450:	d4 21       	pushm	r4-r7,lr
8000b452:	96 68       	ld.sh	r8,r11[0xc]
8000b454:	16 97       	mov	r7,r11
8000b456:	14 95       	mov	r5,r10
8000b458:	12 94       	mov	r4,r9
8000b45a:	e2 18 01 00 	andl	r8,0x100,COH
8000b45e:	18 96       	mov	r6,r12
8000b460:	c0 50       	breq	8000b46a <__swrite+0x1a>
8000b462:	30 29       	mov	r9,2
8000b464:	30 0a       	mov	r10,0
8000b466:	96 7b       	ld.sh	r11,r11[0xe]
8000b468:	ce ac       	rcall	8000b63c <_lseek_r>
8000b46a:	8e 68       	ld.sh	r8,r7[0xc]
8000b46c:	ad c8       	cbr	r8,0xc
8000b46e:	08 99       	mov	r9,r4
8000b470:	0a 9a       	mov	r10,r5
8000b472:	8e 7b       	ld.sh	r11,r7[0xe]
8000b474:	0c 9c       	mov	r12,r6
8000b476:	ae 68       	st.h	r7[0xc],r8
8000b478:	c1 cc       	rcall	8000b4b0 <_write_r>
8000b47a:	d8 22       	popm	r4-r7,pc

8000b47c <__sread>:
8000b47c:	d4 21       	pushm	r4-r7,lr
8000b47e:	16 97       	mov	r7,r11
8000b480:	96 7b       	ld.sh	r11,r11[0xe]
8000b482:	cf 1c       	rcall	8000b664 <_read_r>
8000b484:	c0 65       	brlt	8000b490 <__sread+0x14>
8000b486:	6f 58       	ld.w	r8,r7[0x54]
8000b488:	18 08       	add	r8,r12
8000b48a:	ef 48 00 54 	st.w	r7[84],r8
8000b48e:	d8 22       	popm	r4-r7,pc
8000b490:	8e 68       	ld.sh	r8,r7[0xc]
8000b492:	ad c8       	cbr	r8,0xc
8000b494:	ae 68       	st.h	r7[0xc],r8
8000b496:	d8 22       	popm	r4-r7,pc

8000b498 <strlen>:
8000b498:	30 09       	mov	r9,0
8000b49a:	18 98       	mov	r8,r12
8000b49c:	c0 28       	rjmp	8000b4a0 <strlen+0x8>
8000b49e:	2f f8       	sub	r8,-1
8000b4a0:	11 8a       	ld.ub	r10,r8[0x0]
8000b4a2:	f2 0a 18 00 	cp.b	r10,r9
8000b4a6:	cf c1       	brne	8000b49e <strlen+0x6>
8000b4a8:	f0 0c 01 0c 	sub	r12,r8,r12
8000b4ac:	5e fc       	retal	r12
8000b4ae:	d7 03       	nop

8000b4b0 <_write_r>:
8000b4b0:	d4 21       	pushm	r4-r7,lr
8000b4b2:	16 98       	mov	r8,r11
8000b4b4:	18 97       	mov	r7,r12
8000b4b6:	10 9c       	mov	r12,r8
8000b4b8:	30 08       	mov	r8,0
8000b4ba:	14 9b       	mov	r11,r10
8000b4bc:	e0 66 63 9c 	mov	r6,25500
8000b4c0:	12 9a       	mov	r10,r9
8000b4c2:	8d 08       	st.w	r6[0x0],r8
8000b4c4:	fe b0 d1 8e 	rcall	800057e0 <_write>
8000b4c8:	5b fc       	cp.w	r12,-1
8000b4ca:	c0 51       	brne	8000b4d4 <_write_r+0x24>
8000b4cc:	6c 08       	ld.w	r8,r6[0x0]
8000b4ce:	58 08       	cp.w	r8,0
8000b4d0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b4d4:	d8 22       	popm	r4-r7,pc
8000b4d6:	d7 03       	nop

8000b4d8 <_calloc_r>:
8000b4d8:	d4 21       	pushm	r4-r7,lr
8000b4da:	f4 0b 02 4b 	mul	r11,r10,r11
8000b4de:	fe b0 db 6d 	rcall	80006bb8 <_malloc_r>
8000b4e2:	18 97       	mov	r7,r12
8000b4e4:	c2 30       	breq	8000b52a <_calloc_r+0x52>
8000b4e6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b4ea:	e0 1a ff fc 	andl	r10,0xfffc
8000b4ee:	20 4a       	sub	r10,4
8000b4f0:	e0 4a 00 24 	cp.w	r10,36
8000b4f4:	e0 8b 00 18 	brhi	8000b524 <_calloc_r+0x4c>
8000b4f8:	18 98       	mov	r8,r12
8000b4fa:	59 3a       	cp.w	r10,19
8000b4fc:	e0 88 00 0f 	brls	8000b51a <_calloc_r+0x42>
8000b500:	30 09       	mov	r9,0
8000b502:	10 a9       	st.w	r8++,r9
8000b504:	10 a9       	st.w	r8++,r9
8000b506:	59 ba       	cp.w	r10,27
8000b508:	e0 88 00 09 	brls	8000b51a <_calloc_r+0x42>
8000b50c:	10 a9       	st.w	r8++,r9
8000b50e:	10 a9       	st.w	r8++,r9
8000b510:	e0 4a 00 24 	cp.w	r10,36
8000b514:	c0 31       	brne	8000b51a <_calloc_r+0x42>
8000b516:	10 a9       	st.w	r8++,r9
8000b518:	10 a9       	st.w	r8++,r9
8000b51a:	30 09       	mov	r9,0
8000b51c:	10 a9       	st.w	r8++,r9
8000b51e:	91 19       	st.w	r8[0x4],r9
8000b520:	91 09       	st.w	r8[0x0],r9
8000b522:	c0 48       	rjmp	8000b52a <_calloc_r+0x52>
8000b524:	30 0b       	mov	r11,0
8000b526:	fe b0 de 1c 	rcall	8000715e <memset>
8000b52a:	0e 9c       	mov	r12,r7
8000b52c:	d8 22       	popm	r4-r7,pc
8000b52e:	d7 03       	nop

8000b530 <_close_r>:
8000b530:	d4 21       	pushm	r4-r7,lr
8000b532:	30 08       	mov	r8,0
8000b534:	18 97       	mov	r7,r12
8000b536:	e0 66 63 9c 	mov	r6,25500
8000b53a:	16 9c       	mov	r12,r11
8000b53c:	8d 08       	st.w	r6[0x0],r8
8000b53e:	fe b0 df b5 	rcall	800074a8 <_close>
8000b542:	5b fc       	cp.w	r12,-1
8000b544:	c0 51       	brne	8000b54e <_close_r+0x1e>
8000b546:	6c 08       	ld.w	r8,r6[0x0]
8000b548:	58 08       	cp.w	r8,0
8000b54a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b54e:	d8 22       	popm	r4-r7,pc

8000b550 <_fclose_r>:
8000b550:	d4 21       	pushm	r4-r7,lr
8000b552:	18 96       	mov	r6,r12
8000b554:	16 97       	mov	r7,r11
8000b556:	58 0b       	cp.w	r11,0
8000b558:	c0 31       	brne	8000b55e <_fclose_r+0xe>
8000b55a:	16 95       	mov	r5,r11
8000b55c:	c5 38       	rjmp	8000b602 <_fclose_r+0xb2>
8000b55e:	fe b0 f8 a9 	rcall	8000a6b0 <__sfp_lock_acquire>
8000b562:	58 06       	cp.w	r6,0
8000b564:	c0 70       	breq	8000b572 <_fclose_r+0x22>
8000b566:	6c 68       	ld.w	r8,r6[0x18]
8000b568:	58 08       	cp.w	r8,0
8000b56a:	c0 41       	brne	8000b572 <_fclose_r+0x22>
8000b56c:	0c 9c       	mov	r12,r6
8000b56e:	fe b0 f8 f3 	rcall	8000a754 <__sinit>
8000b572:	fe c8 dd b6 	sub	r8,pc,-8778
8000b576:	10 37       	cp.w	r7,r8
8000b578:	c0 31       	brne	8000b57e <_fclose_r+0x2e>
8000b57a:	6c 07       	ld.w	r7,r6[0x0]
8000b57c:	c0 c8       	rjmp	8000b594 <_fclose_r+0x44>
8000b57e:	fe c8 dd a2 	sub	r8,pc,-8798
8000b582:	10 37       	cp.w	r7,r8
8000b584:	c0 31       	brne	8000b58a <_fclose_r+0x3a>
8000b586:	6c 17       	ld.w	r7,r6[0x4]
8000b588:	c0 68       	rjmp	8000b594 <_fclose_r+0x44>
8000b58a:	fe c8 dd 8e 	sub	r8,pc,-8818
8000b58e:	10 37       	cp.w	r7,r8
8000b590:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b594:	8e 69       	ld.sh	r9,r7[0xc]
8000b596:	30 08       	mov	r8,0
8000b598:	f0 09 19 00 	cp.h	r9,r8
8000b59c:	c0 51       	brne	8000b5a6 <_fclose_r+0x56>
8000b59e:	fe b0 f8 8a 	rcall	8000a6b2 <__sfp_lock_release>
8000b5a2:	30 05       	mov	r5,0
8000b5a4:	c2 f8       	rjmp	8000b602 <_fclose_r+0xb2>
8000b5a6:	0e 9b       	mov	r11,r7
8000b5a8:	0c 9c       	mov	r12,r6
8000b5aa:	fe b0 f7 fd 	rcall	8000a5a4 <_fflush_r>
8000b5ae:	6e c8       	ld.w	r8,r7[0x30]
8000b5b0:	18 95       	mov	r5,r12
8000b5b2:	58 08       	cp.w	r8,0
8000b5b4:	c0 60       	breq	8000b5c0 <_fclose_r+0x70>
8000b5b6:	6e 8b       	ld.w	r11,r7[0x20]
8000b5b8:	0c 9c       	mov	r12,r6
8000b5ba:	5d 18       	icall	r8
8000b5bc:	f9 b5 05 ff 	movlt	r5,-1
8000b5c0:	8e 68       	ld.sh	r8,r7[0xc]
8000b5c2:	ed b8 00 07 	bld	r8,0x7
8000b5c6:	c0 51       	brne	8000b5d0 <_fclose_r+0x80>
8000b5c8:	6e 4b       	ld.w	r11,r7[0x10]
8000b5ca:	0c 9c       	mov	r12,r6
8000b5cc:	fe b0 f9 5e 	rcall	8000a888 <_free_r>
8000b5d0:	6e db       	ld.w	r11,r7[0x34]
8000b5d2:	58 0b       	cp.w	r11,0
8000b5d4:	c0 a0       	breq	8000b5e8 <_fclose_r+0x98>
8000b5d6:	ee c8 ff bc 	sub	r8,r7,-68
8000b5da:	10 3b       	cp.w	r11,r8
8000b5dc:	c0 40       	breq	8000b5e4 <_fclose_r+0x94>
8000b5de:	0c 9c       	mov	r12,r6
8000b5e0:	fe b0 f9 54 	rcall	8000a888 <_free_r>
8000b5e4:	30 08       	mov	r8,0
8000b5e6:	8f d8       	st.w	r7[0x34],r8
8000b5e8:	6f 2b       	ld.w	r11,r7[0x48]
8000b5ea:	58 0b       	cp.w	r11,0
8000b5ec:	c0 70       	breq	8000b5fa <_fclose_r+0xaa>
8000b5ee:	0c 9c       	mov	r12,r6
8000b5f0:	fe b0 f9 4c 	rcall	8000a888 <_free_r>
8000b5f4:	30 08       	mov	r8,0
8000b5f6:	ef 48 00 48 	st.w	r7[72],r8
8000b5fa:	30 08       	mov	r8,0
8000b5fc:	ae 68       	st.h	r7[0xc],r8
8000b5fe:	fe b0 f8 5a 	rcall	8000a6b2 <__sfp_lock_release>
8000b602:	0a 9c       	mov	r12,r5
8000b604:	d8 22       	popm	r4-r7,pc
8000b606:	d7 03       	nop

8000b608 <fclose>:
8000b608:	d4 01       	pushm	lr
8000b60a:	e0 68 0a 38 	mov	r8,2616
8000b60e:	18 9b       	mov	r11,r12
8000b610:	70 0c       	ld.w	r12,r8[0x0]
8000b612:	c9 ff       	rcall	8000b550 <_fclose_r>
8000b614:	d8 02       	popm	pc
8000b616:	d7 03       	nop

8000b618 <_fstat_r>:
8000b618:	d4 21       	pushm	r4-r7,lr
8000b61a:	16 98       	mov	r8,r11
8000b61c:	18 97       	mov	r7,r12
8000b61e:	10 9c       	mov	r12,r8
8000b620:	30 08       	mov	r8,0
8000b622:	e0 66 63 9c 	mov	r6,25500
8000b626:	14 9b       	mov	r11,r10
8000b628:	8d 08       	st.w	r6[0x0],r8
8000b62a:	fe b0 df 67 	rcall	800074f8 <_fstat>
8000b62e:	5b fc       	cp.w	r12,-1
8000b630:	c0 51       	brne	8000b63a <_fstat_r+0x22>
8000b632:	6c 08       	ld.w	r8,r6[0x0]
8000b634:	58 08       	cp.w	r8,0
8000b636:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b63a:	d8 22       	popm	r4-r7,pc

8000b63c <_lseek_r>:
8000b63c:	d4 21       	pushm	r4-r7,lr
8000b63e:	16 98       	mov	r8,r11
8000b640:	18 97       	mov	r7,r12
8000b642:	10 9c       	mov	r12,r8
8000b644:	30 08       	mov	r8,0
8000b646:	14 9b       	mov	r11,r10
8000b648:	e0 66 63 9c 	mov	r6,25500
8000b64c:	12 9a       	mov	r10,r9
8000b64e:	8d 08       	st.w	r6[0x0],r8
8000b650:	fe b0 df 36 	rcall	800074bc <_lseek>
8000b654:	5b fc       	cp.w	r12,-1
8000b656:	c0 51       	brne	8000b660 <_lseek_r+0x24>
8000b658:	6c 08       	ld.w	r8,r6[0x0]
8000b65a:	58 08       	cp.w	r8,0
8000b65c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b660:	d8 22       	popm	r4-r7,pc
8000b662:	d7 03       	nop

8000b664 <_read_r>:
8000b664:	d4 21       	pushm	r4-r7,lr
8000b666:	16 98       	mov	r8,r11
8000b668:	18 97       	mov	r7,r12
8000b66a:	10 9c       	mov	r12,r8
8000b66c:	30 08       	mov	r8,0
8000b66e:	14 9b       	mov	r11,r10
8000b670:	e0 66 63 9c 	mov	r6,25500
8000b674:	12 9a       	mov	r10,r9
8000b676:	8d 08       	st.w	r6[0x0],r8
8000b678:	fe b0 d0 94 	rcall	800057a0 <_read>
8000b67c:	5b fc       	cp.w	r12,-1
8000b67e:	c0 51       	brne	8000b688 <_read_r+0x24>
8000b680:	6c 08       	ld.w	r8,r6[0x0]
8000b682:	58 08       	cp.w	r8,0
8000b684:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b688:	d8 22       	popm	r4-r7,pc
8000b68a:	d7 03       	nop

8000b68c <__avr32_f64_mul>:
8000b68c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b690:	e0 80 00 dc 	breq	8000b848 <__avr32_f64_mul_op1_zero>
8000b694:	d4 21       	pushm	r4-r7,lr
8000b696:	f7 e9 20 0e 	eor	lr,r11,r9
8000b69a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b69e:	30 15       	mov	r5,1
8000b6a0:	c4 30       	breq	8000b726 <__avr32_f64_mul_op1_subnormal>
8000b6a2:	ab 6b       	lsl	r11,0xa
8000b6a4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b6a8:	ab 6a       	lsl	r10,0xa
8000b6aa:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b6ae:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b6b2:	c5 c0       	breq	8000b76a <__avr32_f64_mul_op2_subnormal>
8000b6b4:	a1 78       	lsl	r8,0x1
8000b6b6:	5c f9       	rol	r9
8000b6b8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b6bc:	e0 47 07 ff 	cp.w	r7,2047
8000b6c0:	c7 70       	breq	8000b7ae <__avr32_f64_mul_op_nan_or_inf>
8000b6c2:	e0 46 07 ff 	cp.w	r6,2047
8000b6c6:	c7 40       	breq	8000b7ae <__avr32_f64_mul_op_nan_or_inf>
8000b6c8:	ee 06 00 0c 	add	r12,r7,r6
8000b6cc:	e0 2c 03 fe 	sub	r12,1022
8000b6d0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b6d4:	f4 09 07 44 	macu.d	r4,r10,r9
8000b6d8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b6dc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b6e0:	08 07       	add	r7,r4
8000b6e2:	f4 05 00 4a 	adc	r10,r10,r5
8000b6e6:	5c 0b       	acr	r11
8000b6e8:	ed bb 00 14 	bld	r11,0x14
8000b6ec:	c0 50       	breq	8000b6f6 <__avr32_f64_mul+0x6a>
8000b6ee:	a1 77       	lsl	r7,0x1
8000b6f0:	5c fa       	rol	r10
8000b6f2:	5c fb       	rol	r11
8000b6f4:	20 1c       	sub	r12,1
8000b6f6:	58 0c       	cp.w	r12,0
8000b6f8:	e0 8a 00 6f 	brle	8000b7d6 <__avr32_f64_mul_res_subnormal>
8000b6fc:	e0 4c 07 ff 	cp.w	r12,2047
8000b700:	e0 84 00 9c 	brge	8000b838 <__avr32_f64_mul_res_inf>
8000b704:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b708:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b70c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b710:	ee 17 80 00 	eorh	r7,0x8000
8000b714:	f1 b7 04 20 	satu	r7,0x1
8000b718:	0e 0a       	add	r10,r7
8000b71a:	5c 0b       	acr	r11
8000b71c:	ed be 00 1f 	bld	lr,0x1f
8000b720:	ef bb 00 1f 	bst	r11,0x1f
8000b724:	d8 22       	popm	r4-r7,pc

8000b726 <__avr32_f64_mul_op1_subnormal>:
8000b726:	e4 1b 00 0f 	andh	r11,0xf
8000b72a:	f4 0c 12 00 	clz	r12,r10
8000b72e:	f6 06 12 00 	clz	r6,r11
8000b732:	f7 bc 03 e1 	sublo	r12,-31
8000b736:	f8 06 17 30 	movlo	r6,r12
8000b73a:	f7 b6 02 01 	subhs	r6,1
8000b73e:	e0 46 00 20 	cp.w	r6,32
8000b742:	c0 d4       	brge	8000b75c <__avr32_f64_mul_op1_subnormal+0x36>
8000b744:	ec 0c 11 20 	rsub	r12,r6,32
8000b748:	f6 06 09 4b 	lsl	r11,r11,r6
8000b74c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b750:	18 4b       	or	r11,r12
8000b752:	f4 06 09 4a 	lsl	r10,r10,r6
8000b756:	20 b6       	sub	r6,11
8000b758:	0c 17       	sub	r7,r6
8000b75a:	ca ab       	rjmp	8000b6ae <__avr32_f64_mul+0x22>
8000b75c:	f4 06 09 4b 	lsl	r11,r10,r6
8000b760:	c6 40       	breq	8000b828 <__avr32_f64_mul_res_zero>
8000b762:	30 0a       	mov	r10,0
8000b764:	20 b6       	sub	r6,11
8000b766:	0c 17       	sub	r7,r6
8000b768:	ca 3b       	rjmp	8000b6ae <__avr32_f64_mul+0x22>

8000b76a <__avr32_f64_mul_op2_subnormal>:
8000b76a:	e4 19 00 0f 	andh	r9,0xf
8000b76e:	f0 0c 12 00 	clz	r12,r8
8000b772:	f2 05 12 00 	clz	r5,r9
8000b776:	f7 bc 03 ea 	sublo	r12,-22
8000b77a:	f8 05 17 30 	movlo	r5,r12
8000b77e:	f7 b5 02 0a 	subhs	r5,10
8000b782:	e0 45 00 20 	cp.w	r5,32
8000b786:	c0 d4       	brge	8000b7a0 <__avr32_f64_mul_op2_subnormal+0x36>
8000b788:	ea 0c 11 20 	rsub	r12,r5,32
8000b78c:	f2 05 09 49 	lsl	r9,r9,r5
8000b790:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b794:	18 49       	or	r9,r12
8000b796:	f0 05 09 48 	lsl	r8,r8,r5
8000b79a:	20 25       	sub	r5,2
8000b79c:	0a 16       	sub	r6,r5
8000b79e:	c8 fb       	rjmp	8000b6bc <__avr32_f64_mul+0x30>
8000b7a0:	f0 05 09 49 	lsl	r9,r8,r5
8000b7a4:	c4 20       	breq	8000b828 <__avr32_f64_mul_res_zero>
8000b7a6:	30 08       	mov	r8,0
8000b7a8:	20 25       	sub	r5,2
8000b7aa:	0a 16       	sub	r6,r5
8000b7ac:	c8 8b       	rjmp	8000b6bc <__avr32_f64_mul+0x30>

8000b7ae <__avr32_f64_mul_op_nan_or_inf>:
8000b7ae:	e4 19 00 0f 	andh	r9,0xf
8000b7b2:	e4 1b 00 0f 	andh	r11,0xf
8000b7b6:	14 4b       	or	r11,r10
8000b7b8:	10 49       	or	r9,r8
8000b7ba:	e0 47 07 ff 	cp.w	r7,2047
8000b7be:	c0 91       	brne	8000b7d0 <__avr32_f64_mul_op1_not_naninf>
8000b7c0:	58 0b       	cp.w	r11,0
8000b7c2:	c3 81       	brne	8000b832 <__avr32_f64_mul_res_nan>
8000b7c4:	e0 46 07 ff 	cp.w	r6,2047
8000b7c8:	c3 81       	brne	8000b838 <__avr32_f64_mul_res_inf>
8000b7ca:	58 09       	cp.w	r9,0
8000b7cc:	c3 60       	breq	8000b838 <__avr32_f64_mul_res_inf>
8000b7ce:	c3 28       	rjmp	8000b832 <__avr32_f64_mul_res_nan>

8000b7d0 <__avr32_f64_mul_op1_not_naninf>:
8000b7d0:	58 09       	cp.w	r9,0
8000b7d2:	c3 30       	breq	8000b838 <__avr32_f64_mul_res_inf>
8000b7d4:	c2 f8       	rjmp	8000b832 <__avr32_f64_mul_res_nan>

8000b7d6 <__avr32_f64_mul_res_subnormal>:
8000b7d6:	5c 3c       	neg	r12
8000b7d8:	2f fc       	sub	r12,-1
8000b7da:	f1 bc 04 c0 	satu	r12,0x6
8000b7de:	e0 4c 00 20 	cp.w	r12,32
8000b7e2:	c1 14       	brge	8000b804 <__avr32_f64_mul_res_subnormal+0x2e>
8000b7e4:	f8 08 11 20 	rsub	r8,r12,32
8000b7e8:	0e 46       	or	r6,r7
8000b7ea:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b7ee:	f4 08 09 49 	lsl	r9,r10,r8
8000b7f2:	12 47       	or	r7,r9
8000b7f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b7f8:	f6 08 09 49 	lsl	r9,r11,r8
8000b7fc:	12 4a       	or	r10,r9
8000b7fe:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b802:	c8 3b       	rjmp	8000b708 <__avr32_f64_mul+0x7c>
8000b804:	f8 08 11 20 	rsub	r8,r12,32
8000b808:	f9 b9 00 00 	moveq	r9,0
8000b80c:	c0 30       	breq	8000b812 <__avr32_f64_mul_res_subnormal+0x3c>
8000b80e:	f6 08 09 49 	lsl	r9,r11,r8
8000b812:	0e 46       	or	r6,r7
8000b814:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b818:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b81c:	f3 ea 10 07 	or	r7,r9,r10
8000b820:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b824:	30 0b       	mov	r11,0
8000b826:	c7 1b       	rjmp	8000b708 <__avr32_f64_mul+0x7c>

8000b828 <__avr32_f64_mul_res_zero>:
8000b828:	1c 9b       	mov	r11,lr
8000b82a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b82e:	30 0a       	mov	r10,0
8000b830:	d8 22       	popm	r4-r7,pc

8000b832 <__avr32_f64_mul_res_nan>:
8000b832:	3f fb       	mov	r11,-1
8000b834:	3f fa       	mov	r10,-1
8000b836:	d8 22       	popm	r4-r7,pc

8000b838 <__avr32_f64_mul_res_inf>:
8000b838:	f0 6b 00 00 	mov	r11,-1048576
8000b83c:	ed be 00 1f 	bld	lr,0x1f
8000b840:	ef bb 00 1f 	bst	r11,0x1f
8000b844:	30 0a       	mov	r10,0
8000b846:	d8 22       	popm	r4-r7,pc

8000b848 <__avr32_f64_mul_op1_zero>:
8000b848:	f7 e9 20 0b 	eor	r11,r11,r9
8000b84c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b850:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b854:	e0 4c 07 ff 	cp.w	r12,2047
8000b858:	5e 1c       	retne	r12
8000b85a:	3f fa       	mov	r10,-1
8000b85c:	3f fb       	mov	r11,-1
8000b85e:	5e fc       	retal	r12

8000b860 <__avr32_f64_sub_from_add>:
8000b860:	ee 19 80 00 	eorh	r9,0x8000

8000b864 <__avr32_f64_sub>:
8000b864:	f7 e9 20 0c 	eor	r12,r11,r9
8000b868:	e0 86 00 ca 	brmi	8000b9fc <__avr32_f64_add_from_sub>
8000b86c:	eb cd 40 e0 	pushm	r5-r7,lr
8000b870:	16 9c       	mov	r12,r11
8000b872:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b876:	bf db       	cbr	r11,0x1f
8000b878:	bf d9       	cbr	r9,0x1f
8000b87a:	10 3a       	cp.w	r10,r8
8000b87c:	f2 0b 13 00 	cpc	r11,r9
8000b880:	c0 92       	brcc	8000b892 <__avr32_f64_sub+0x2e>
8000b882:	16 97       	mov	r7,r11
8000b884:	12 9b       	mov	r11,r9
8000b886:	0e 99       	mov	r9,r7
8000b888:	14 97       	mov	r7,r10
8000b88a:	10 9a       	mov	r10,r8
8000b88c:	0e 98       	mov	r8,r7
8000b88e:	ee 1c 80 00 	eorh	r12,0x8000
8000b892:	f6 07 16 14 	lsr	r7,r11,0x14
8000b896:	ab 7b       	lsl	r11,0xb
8000b898:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b89c:	ab 7a       	lsl	r10,0xb
8000b89e:	bf bb       	sbr	r11,0x1f
8000b8a0:	f2 06 16 14 	lsr	r6,r9,0x14
8000b8a4:	c4 40       	breq	8000b92c <__avr32_f64_sub_opL_subnormal>
8000b8a6:	ab 79       	lsl	r9,0xb
8000b8a8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b8ac:	ab 78       	lsl	r8,0xb
8000b8ae:	bf b9       	sbr	r9,0x1f

8000b8b0 <__avr32_f64_sub_opL_subnormal_done>:
8000b8b0:	e0 47 07 ff 	cp.w	r7,2047
8000b8b4:	c4 f0       	breq	8000b952 <__avr32_f64_sub_opH_nan_or_inf>
8000b8b6:	0e 26       	rsub	r6,r7
8000b8b8:	c1 20       	breq	8000b8dc <__avr32_f64_sub_shift_done>
8000b8ba:	ec 05 11 20 	rsub	r5,r6,32
8000b8be:	e0 46 00 20 	cp.w	r6,32
8000b8c2:	c7 c2       	brcc	8000b9ba <__avr32_f64_sub_longshift>
8000b8c4:	f0 05 09 4e 	lsl	lr,r8,r5
8000b8c8:	f2 05 09 45 	lsl	r5,r9,r5
8000b8cc:	f0 06 0a 48 	lsr	r8,r8,r6
8000b8d0:	f2 06 0a 49 	lsr	r9,r9,r6
8000b8d4:	0a 48       	or	r8,r5
8000b8d6:	58 0e       	cp.w	lr,0
8000b8d8:	5f 1e       	srne	lr
8000b8da:	1c 48       	or	r8,lr

8000b8dc <__avr32_f64_sub_shift_done>:
8000b8dc:	10 1a       	sub	r10,r8
8000b8de:	f6 09 01 4b 	sbc	r11,r11,r9
8000b8e2:	f6 06 12 00 	clz	r6,r11
8000b8e6:	c0 e0       	breq	8000b902 <__avr32_f64_sub_longnormalize_done>
8000b8e8:	c7 83       	brcs	8000b9d8 <__avr32_f64_sub_longnormalize>
8000b8ea:	ec 0e 11 20 	rsub	lr,r6,32
8000b8ee:	f6 06 09 4b 	lsl	r11,r11,r6
8000b8f2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b8f6:	1c 4b       	or	r11,lr
8000b8f8:	f4 06 09 4a 	lsl	r10,r10,r6
8000b8fc:	0c 17       	sub	r7,r6
8000b8fe:	e0 8a 00 39 	brle	8000b970 <__avr32_f64_sub_subnormal_result>

8000b902 <__avr32_f64_sub_longnormalize_done>:
8000b902:	f4 09 15 15 	lsl	r9,r10,0x15
8000b906:	ab 9a       	lsr	r10,0xb
8000b908:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b90c:	ab 9b       	lsr	r11,0xb
8000b90e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b912:	18 4b       	or	r11,r12

8000b914 <__avr32_f64_sub_round>:
8000b914:	fc 17 80 00 	movh	r7,0x8000
8000b918:	ed ba 00 00 	bld	r10,0x0
8000b91c:	f7 b7 01 ff 	subne	r7,-1
8000b920:	0e 39       	cp.w	r9,r7
8000b922:	5f 29       	srhs	r9
8000b924:	12 0a       	add	r10,r9
8000b926:	5c 0b       	acr	r11
8000b928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b92c <__avr32_f64_sub_opL_subnormal>:
8000b92c:	ab 79       	lsl	r9,0xb
8000b92e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b932:	ab 78       	lsl	r8,0xb
8000b934:	f3 e8 10 0e 	or	lr,r9,r8
8000b938:	f9 b6 01 01 	movne	r6,1
8000b93c:	ee 0e 11 00 	rsub	lr,r7,0
8000b940:	f9 b7 00 01 	moveq	r7,1
8000b944:	ef bb 00 1f 	bst	r11,0x1f
8000b948:	f7 ea 10 0e 	or	lr,r11,r10
8000b94c:	f9 b7 00 00 	moveq	r7,0
8000b950:	cb 0b       	rjmp	8000b8b0 <__avr32_f64_sub_opL_subnormal_done>

8000b952 <__avr32_f64_sub_opH_nan_or_inf>:
8000b952:	bf db       	cbr	r11,0x1f
8000b954:	f7 ea 10 0e 	or	lr,r11,r10
8000b958:	c0 81       	brne	8000b968 <__avr32_f64_sub_return_nan>
8000b95a:	e0 46 07 ff 	cp.w	r6,2047
8000b95e:	c0 50       	breq	8000b968 <__avr32_f64_sub_return_nan>
8000b960:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b964:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b968 <__avr32_f64_sub_return_nan>:
8000b968:	3f fa       	mov	r10,-1
8000b96a:	3f fb       	mov	r11,-1
8000b96c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b970 <__avr32_f64_sub_subnormal_result>:
8000b970:	5c 37       	neg	r7
8000b972:	2f f7       	sub	r7,-1
8000b974:	f1 b7 04 c0 	satu	r7,0x6
8000b978:	e0 47 00 20 	cp.w	r7,32
8000b97c:	c1 14       	brge	8000b99e <__avr32_f64_sub_subnormal_result+0x2e>
8000b97e:	ee 08 11 20 	rsub	r8,r7,32
8000b982:	f4 08 09 49 	lsl	r9,r10,r8
8000b986:	5f 16       	srne	r6
8000b988:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b98c:	0c 4a       	or	r10,r6
8000b98e:	f6 08 09 49 	lsl	r9,r11,r8
8000b992:	f5 e9 10 0a 	or	r10,r10,r9
8000b996:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b99a:	30 07       	mov	r7,0
8000b99c:	cb 3b       	rjmp	8000b902 <__avr32_f64_sub_longnormalize_done>
8000b99e:	ee 08 11 40 	rsub	r8,r7,64
8000b9a2:	f6 08 09 49 	lsl	r9,r11,r8
8000b9a6:	14 49       	or	r9,r10
8000b9a8:	5f 16       	srne	r6
8000b9aa:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b9ae:	0c 4a       	or	r10,r6
8000b9b0:	30 0b       	mov	r11,0
8000b9b2:	30 07       	mov	r7,0
8000b9b4:	ca 7b       	rjmp	8000b902 <__avr32_f64_sub_longnormalize_done>
8000b9b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9ba <__avr32_f64_sub_longshift>:
8000b9ba:	f1 b6 04 c0 	satu	r6,0x6
8000b9be:	f0 0e 17 00 	moveq	lr,r8
8000b9c2:	c0 40       	breq	8000b9ca <__avr32_f64_sub_longshift+0x10>
8000b9c4:	f2 05 09 4e 	lsl	lr,r9,r5
8000b9c8:	10 4e       	or	lr,r8
8000b9ca:	f2 06 0a 48 	lsr	r8,r9,r6
8000b9ce:	30 09       	mov	r9,0
8000b9d0:	58 0e       	cp.w	lr,0
8000b9d2:	5f 1e       	srne	lr
8000b9d4:	1c 48       	or	r8,lr
8000b9d6:	c8 3b       	rjmp	8000b8dc <__avr32_f64_sub_shift_done>

8000b9d8 <__avr32_f64_sub_longnormalize>:
8000b9d8:	f4 06 12 00 	clz	r6,r10
8000b9dc:	f9 b7 03 00 	movlo	r7,0
8000b9e0:	f9 b6 03 00 	movlo	r6,0
8000b9e4:	f9 bc 03 00 	movlo	r12,0
8000b9e8:	f7 b6 02 e0 	subhs	r6,-32
8000b9ec:	f4 06 09 4b 	lsl	r11,r10,r6
8000b9f0:	30 0a       	mov	r10,0
8000b9f2:	0c 17       	sub	r7,r6
8000b9f4:	fe 9a ff be 	brle	8000b970 <__avr32_f64_sub_subnormal_result>
8000b9f8:	c8 5b       	rjmp	8000b902 <__avr32_f64_sub_longnormalize_done>
8000b9fa:	d7 03       	nop

8000b9fc <__avr32_f64_add_from_sub>:
8000b9fc:	ee 19 80 00 	eorh	r9,0x8000

8000ba00 <__avr32_f64_add>:
8000ba00:	f7 e9 20 0c 	eor	r12,r11,r9
8000ba04:	fe 96 ff 2e 	brmi	8000b860 <__avr32_f64_sub_from_add>
8000ba08:	eb cd 40 e0 	pushm	r5-r7,lr
8000ba0c:	16 9c       	mov	r12,r11
8000ba0e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ba12:	bf db       	cbr	r11,0x1f
8000ba14:	bf d9       	cbr	r9,0x1f
8000ba16:	12 3b       	cp.w	r11,r9
8000ba18:	c0 72       	brcc	8000ba26 <__avr32_f64_add+0x26>
8000ba1a:	16 97       	mov	r7,r11
8000ba1c:	12 9b       	mov	r11,r9
8000ba1e:	0e 99       	mov	r9,r7
8000ba20:	14 97       	mov	r7,r10
8000ba22:	10 9a       	mov	r10,r8
8000ba24:	0e 98       	mov	r8,r7
8000ba26:	30 0e       	mov	lr,0
8000ba28:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ba2c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ba30:	b5 ab       	sbr	r11,0x14
8000ba32:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ba36:	c6 20       	breq	8000bafa <__avr32_f64_add_op2_subnormal>
8000ba38:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ba3c:	b5 a9       	sbr	r9,0x14
8000ba3e:	e0 47 07 ff 	cp.w	r7,2047
8000ba42:	c2 80       	breq	8000ba92 <__avr32_f64_add_opH_nan_or_inf>
8000ba44:	0e 26       	rsub	r6,r7
8000ba46:	c1 20       	breq	8000ba6a <__avr32_f64_add_shift_done>
8000ba48:	e0 46 00 36 	cp.w	r6,54
8000ba4c:	c1 52       	brcc	8000ba76 <__avr32_f64_add_res_of_done>
8000ba4e:	ec 05 11 20 	rsub	r5,r6,32
8000ba52:	e0 46 00 20 	cp.w	r6,32
8000ba56:	c3 52       	brcc	8000bac0 <__avr32_f64_add_longshift>
8000ba58:	f0 05 09 4e 	lsl	lr,r8,r5
8000ba5c:	f2 05 09 45 	lsl	r5,r9,r5
8000ba60:	f0 06 0a 48 	lsr	r8,r8,r6
8000ba64:	f2 06 0a 49 	lsr	r9,r9,r6
8000ba68:	0a 48       	or	r8,r5

8000ba6a <__avr32_f64_add_shift_done>:
8000ba6a:	10 0a       	add	r10,r8
8000ba6c:	f6 09 00 4b 	adc	r11,r11,r9
8000ba70:	ed bb 00 15 	bld	r11,0x15
8000ba74:	c3 40       	breq	8000badc <__avr32_f64_add_res_of>

8000ba76 <__avr32_f64_add_res_of_done>:
8000ba76:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ba7a:	18 4b       	or	r11,r12

8000ba7c <__avr32_f64_add_round>:
8000ba7c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000ba80:	18 4e       	or	lr,r12
8000ba82:	ee 1e 80 00 	eorh	lr,0x8000
8000ba86:	f1 be 04 20 	satu	lr,0x1
8000ba8a:	1c 0a       	add	r10,lr
8000ba8c:	5c 0b       	acr	r11
8000ba8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba92 <__avr32_f64_add_opH_nan_or_inf>:
8000ba92:	b5 cb       	cbr	r11,0x14
8000ba94:	f7 ea 10 0e 	or	lr,r11,r10
8000ba98:	c1 01       	brne	8000bab8 <__avr32_f64_add_return_nan>
8000ba9a:	e0 46 07 ff 	cp.w	r6,2047
8000ba9e:	c0 30       	breq	8000baa4 <__avr32_f64_add_opL_nan_or_inf>
8000baa0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000baa4 <__avr32_f64_add_opL_nan_or_inf>:
8000baa4:	b5 c9       	cbr	r9,0x14
8000baa6:	f3 e8 10 0e 	or	lr,r9,r8
8000baaa:	c0 71       	brne	8000bab8 <__avr32_f64_add_return_nan>
8000baac:	30 0a       	mov	r10,0
8000baae:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bab2:	18 4b       	or	r11,r12
8000bab4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bab8 <__avr32_f64_add_return_nan>:
8000bab8:	3f fa       	mov	r10,-1
8000baba:	3f fb       	mov	r11,-1
8000babc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bac0 <__avr32_f64_add_longshift>:
8000bac0:	f1 b6 04 c0 	satu	r6,0x6
8000bac4:	f0 0e 17 00 	moveq	lr,r8
8000bac8:	c0 60       	breq	8000bad4 <__avr32_f64_add_longshift+0x14>
8000baca:	f2 05 09 4e 	lsl	lr,r9,r5
8000bace:	58 08       	cp.w	r8,0
8000bad0:	5f 18       	srne	r8
8000bad2:	10 4e       	or	lr,r8
8000bad4:	f2 06 0a 48 	lsr	r8,r9,r6
8000bad8:	30 09       	mov	r9,0
8000bada:	cc 8b       	rjmp	8000ba6a <__avr32_f64_add_shift_done>

8000badc <__avr32_f64_add_res_of>:
8000badc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bae0:	a1 9b       	lsr	r11,0x1
8000bae2:	5d 0a       	ror	r10
8000bae4:	5d 0e       	ror	lr
8000bae6:	2f f7       	sub	r7,-1
8000bae8:	e0 47 07 ff 	cp.w	r7,2047
8000baec:	f9 ba 00 00 	moveq	r10,0
8000baf0:	f9 bb 00 00 	moveq	r11,0
8000baf4:	f9 be 00 00 	moveq	lr,0
8000baf8:	cb fb       	rjmp	8000ba76 <__avr32_f64_add_res_of_done>

8000bafa <__avr32_f64_add_op2_subnormal>:
8000bafa:	30 16       	mov	r6,1
8000bafc:	58 07       	cp.w	r7,0
8000bafe:	ca 01       	brne	8000ba3e <__avr32_f64_add+0x3e>
8000bb00:	b5 cb       	cbr	r11,0x14
8000bb02:	10 0a       	add	r10,r8
8000bb04:	f6 09 00 4b 	adc	r11,r11,r9
8000bb08:	18 4b       	or	r11,r12
8000bb0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bb0e:	d7 03       	nop

8000bb10 <__avr32_f64_to_u32>:
8000bb10:	58 0b       	cp.w	r11,0
8000bb12:	5e 6d       	retmi	0

8000bb14 <__avr32_f64_to_s32>:
8000bb14:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bb18:	b5 9c       	lsr	r12,0x15
8000bb1a:	e0 2c 03 ff 	sub	r12,1023
8000bb1e:	5e 3d       	retlo	0
8000bb20:	f8 0c 11 1f 	rsub	r12,r12,31
8000bb24:	16 99       	mov	r9,r11
8000bb26:	ab 7b       	lsl	r11,0xb
8000bb28:	bf bb       	sbr	r11,0x1f
8000bb2a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bb2e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bb32:	a1 79       	lsl	r9,0x1
8000bb34:	5e 2b       	reths	r11
8000bb36:	5c 3b       	neg	r11
8000bb38:	5e fb       	retal	r11

8000bb3a <__avr32_u32_to_f64>:
8000bb3a:	f8 cb 00 00 	sub	r11,r12,0
8000bb3e:	30 0c       	mov	r12,0
8000bb40:	c0 38       	rjmp	8000bb46 <__avr32_s32_to_f64+0x4>

8000bb42 <__avr32_s32_to_f64>:
8000bb42:	18 9b       	mov	r11,r12
8000bb44:	5c 4b       	abs	r11
8000bb46:	30 0a       	mov	r10,0
8000bb48:	5e 0b       	reteq	r11
8000bb4a:	d4 01       	pushm	lr
8000bb4c:	e0 69 04 1e 	mov	r9,1054
8000bb50:	f6 08 12 00 	clz	r8,r11
8000bb54:	c1 70       	breq	8000bb82 <__avr32_s32_to_f64+0x40>
8000bb56:	c0 c3       	brcs	8000bb6e <__avr32_s32_to_f64+0x2c>
8000bb58:	f0 0e 11 20 	rsub	lr,r8,32
8000bb5c:	f6 08 09 4b 	lsl	r11,r11,r8
8000bb60:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb64:	1c 4b       	or	r11,lr
8000bb66:	f4 08 09 4a 	lsl	r10,r10,r8
8000bb6a:	10 19       	sub	r9,r8
8000bb6c:	c0 b8       	rjmp	8000bb82 <__avr32_s32_to_f64+0x40>
8000bb6e:	f4 08 12 00 	clz	r8,r10
8000bb72:	f9 b8 03 00 	movlo	r8,0
8000bb76:	f7 b8 02 e0 	subhs	r8,-32
8000bb7a:	f4 08 09 4b 	lsl	r11,r10,r8
8000bb7e:	30 0a       	mov	r10,0
8000bb80:	10 19       	sub	r9,r8
8000bb82:	58 09       	cp.w	r9,0
8000bb84:	e0 89 00 30 	brgt	8000bbe4 <__avr32_s32_to_f64+0xa2>
8000bb88:	5c 39       	neg	r9
8000bb8a:	2f f9       	sub	r9,-1
8000bb8c:	e0 49 00 36 	cp.w	r9,54
8000bb90:	c0 43       	brcs	8000bb98 <__avr32_s32_to_f64+0x56>
8000bb92:	30 0b       	mov	r11,0
8000bb94:	30 0a       	mov	r10,0
8000bb96:	c2 68       	rjmp	8000bbe2 <__avr32_s32_to_f64+0xa0>
8000bb98:	2f 69       	sub	r9,-10
8000bb9a:	f2 08 11 20 	rsub	r8,r9,32
8000bb9e:	e0 49 00 20 	cp.w	r9,32
8000bba2:	c0 b2       	brcc	8000bbb8 <__avr32_s32_to_f64+0x76>
8000bba4:	f4 08 09 4e 	lsl	lr,r10,r8
8000bba8:	f6 08 09 48 	lsl	r8,r11,r8
8000bbac:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bbb0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bbb4:	10 4b       	or	r11,r8
8000bbb6:	c0 88       	rjmp	8000bbc6 <__avr32_s32_to_f64+0x84>
8000bbb8:	f6 08 09 4e 	lsl	lr,r11,r8
8000bbbc:	14 4e       	or	lr,r10
8000bbbe:	16 9a       	mov	r10,r11
8000bbc0:	30 0b       	mov	r11,0
8000bbc2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bbc6:	ed ba 00 00 	bld	r10,0x0
8000bbca:	c0 92       	brcc	8000bbdc <__avr32_s32_to_f64+0x9a>
8000bbcc:	1c 7e       	tst	lr,lr
8000bbce:	c0 41       	brne	8000bbd6 <__avr32_s32_to_f64+0x94>
8000bbd0:	ed ba 00 01 	bld	r10,0x1
8000bbd4:	c0 42       	brcc	8000bbdc <__avr32_s32_to_f64+0x9a>
8000bbd6:	2f fa       	sub	r10,-1
8000bbd8:	f7 bb 02 ff 	subhs	r11,-1
8000bbdc:	5c fc       	rol	r12
8000bbde:	5d 0b       	ror	r11
8000bbe0:	5d 0a       	ror	r10
8000bbe2:	d8 02       	popm	pc
8000bbe4:	e0 68 03 ff 	mov	r8,1023
8000bbe8:	ed ba 00 0b 	bld	r10,0xb
8000bbec:	f7 b8 00 ff 	subeq	r8,-1
8000bbf0:	10 0a       	add	r10,r8
8000bbf2:	5c 0b       	acr	r11
8000bbf4:	f7 b9 03 fe 	sublo	r9,-2
8000bbf8:	e0 49 07 ff 	cp.w	r9,2047
8000bbfc:	c0 55       	brlt	8000bc06 <__avr32_s32_to_f64+0xc4>
8000bbfe:	30 0a       	mov	r10,0
8000bc00:	fc 1b ff e0 	movh	r11,0xffe0
8000bc04:	c0 c8       	rjmp	8000bc1c <__floatsidf_return_op1>
8000bc06:	ed bb 00 1f 	bld	r11,0x1f
8000bc0a:	f7 b9 01 01 	subne	r9,1
8000bc0e:	ab 9a       	lsr	r10,0xb
8000bc10:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bc14:	a1 7b       	lsl	r11,0x1
8000bc16:	ab 9b       	lsr	r11,0xb
8000bc18:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bc1c <__floatsidf_return_op1>:
8000bc1c:	a1 7c       	lsl	r12,0x1
8000bc1e:	5d 0b       	ror	r11
8000bc20:	d8 02       	popm	pc

8000bc22 <__avr32_f64_cmp_eq>:
8000bc22:	10 3a       	cp.w	r10,r8
8000bc24:	f2 0b 13 00 	cpc	r11,r9
8000bc28:	c0 80       	breq	8000bc38 <__avr32_f64_cmp_eq+0x16>
8000bc2a:	a1 7b       	lsl	r11,0x1
8000bc2c:	a1 79       	lsl	r9,0x1
8000bc2e:	14 4b       	or	r11,r10
8000bc30:	12 4b       	or	r11,r9
8000bc32:	10 4b       	or	r11,r8
8000bc34:	5e 0f       	reteq	1
8000bc36:	5e fd       	retal	0
8000bc38:	a1 7b       	lsl	r11,0x1
8000bc3a:	fc 1c ff e0 	movh	r12,0xffe0
8000bc3e:	58 0a       	cp.w	r10,0
8000bc40:	f8 0b 13 00 	cpc	r11,r12
8000bc44:	5e 8f       	retls	1
8000bc46:	5e fd       	retal	0

8000bc48 <__avr32_f64_cmp_ge>:
8000bc48:	1a de       	st.w	--sp,lr
8000bc4a:	1a d7       	st.w	--sp,r7
8000bc4c:	a1 7b       	lsl	r11,0x1
8000bc4e:	5f 3c       	srlo	r12
8000bc50:	a1 79       	lsl	r9,0x1
8000bc52:	5f 37       	srlo	r7
8000bc54:	5c fc       	rol	r12
8000bc56:	fc 1e ff e0 	movh	lr,0xffe0
8000bc5a:	58 0a       	cp.w	r10,0
8000bc5c:	fc 0b 13 00 	cpc	r11,lr
8000bc60:	e0 8b 00 1d 	brhi	8000bc9a <__avr32_f64_cmp_ge+0x52>
8000bc64:	58 08       	cp.w	r8,0
8000bc66:	fc 09 13 00 	cpc	r9,lr
8000bc6a:	e0 8b 00 18 	brhi	8000bc9a <__avr32_f64_cmp_ge+0x52>
8000bc6e:	58 0b       	cp.w	r11,0
8000bc70:	f5 ba 00 00 	subfeq	r10,0
8000bc74:	c1 50       	breq	8000bc9e <__avr32_f64_cmp_ge+0x56>
8000bc76:	1b 07       	ld.w	r7,sp++
8000bc78:	1b 0e       	ld.w	lr,sp++
8000bc7a:	58 3c       	cp.w	r12,3
8000bc7c:	c0 a0       	breq	8000bc90 <__avr32_f64_cmp_ge+0x48>
8000bc7e:	58 1c       	cp.w	r12,1
8000bc80:	c0 33       	brcs	8000bc86 <__avr32_f64_cmp_ge+0x3e>
8000bc82:	5e 0f       	reteq	1
8000bc84:	5e 1d       	retne	0
8000bc86:	10 3a       	cp.w	r10,r8
8000bc88:	f2 0b 13 00 	cpc	r11,r9
8000bc8c:	5e 2f       	reths	1
8000bc8e:	5e 3d       	retlo	0
8000bc90:	14 38       	cp.w	r8,r10
8000bc92:	f6 09 13 00 	cpc	r9,r11
8000bc96:	5e 2f       	reths	1
8000bc98:	5e 3d       	retlo	0
8000bc9a:	1b 07       	ld.w	r7,sp++
8000bc9c:	d8 0a       	popm	pc,r12=0
8000bc9e:	58 17       	cp.w	r7,1
8000bca0:	5f 0c       	sreq	r12
8000bca2:	58 09       	cp.w	r9,0
8000bca4:	f5 b8 00 00 	subfeq	r8,0
8000bca8:	1b 07       	ld.w	r7,sp++
8000bcaa:	1b 0e       	ld.w	lr,sp++
8000bcac:	5e 0f       	reteq	1
8000bcae:	5e fc       	retal	r12

8000bcb0 <__avr32_f64_cmp_lt>:
8000bcb0:	1a de       	st.w	--sp,lr
8000bcb2:	1a d7       	st.w	--sp,r7
8000bcb4:	a1 7b       	lsl	r11,0x1
8000bcb6:	5f 3c       	srlo	r12
8000bcb8:	a1 79       	lsl	r9,0x1
8000bcba:	5f 37       	srlo	r7
8000bcbc:	5c fc       	rol	r12
8000bcbe:	fc 1e ff e0 	movh	lr,0xffe0
8000bcc2:	58 0a       	cp.w	r10,0
8000bcc4:	fc 0b 13 00 	cpc	r11,lr
8000bcc8:	e0 8b 00 1d 	brhi	8000bd02 <__avr32_f64_cmp_lt+0x52>
8000bccc:	58 08       	cp.w	r8,0
8000bcce:	fc 09 13 00 	cpc	r9,lr
8000bcd2:	e0 8b 00 18 	brhi	8000bd02 <__avr32_f64_cmp_lt+0x52>
8000bcd6:	58 0b       	cp.w	r11,0
8000bcd8:	f5 ba 00 00 	subfeq	r10,0
8000bcdc:	c1 50       	breq	8000bd06 <__avr32_f64_cmp_lt+0x56>
8000bcde:	1b 07       	ld.w	r7,sp++
8000bce0:	1b 0e       	ld.w	lr,sp++
8000bce2:	58 3c       	cp.w	r12,3
8000bce4:	c0 a0       	breq	8000bcf8 <__avr32_f64_cmp_lt+0x48>
8000bce6:	58 1c       	cp.w	r12,1
8000bce8:	c0 33       	brcs	8000bcee <__avr32_f64_cmp_lt+0x3e>
8000bcea:	5e 0d       	reteq	0
8000bcec:	5e 1f       	retne	1
8000bcee:	10 3a       	cp.w	r10,r8
8000bcf0:	f2 0b 13 00 	cpc	r11,r9
8000bcf4:	5e 2d       	reths	0
8000bcf6:	5e 3f       	retlo	1
8000bcf8:	14 38       	cp.w	r8,r10
8000bcfa:	f6 09 13 00 	cpc	r9,r11
8000bcfe:	5e 2d       	reths	0
8000bd00:	5e 3f       	retlo	1
8000bd02:	1b 07       	ld.w	r7,sp++
8000bd04:	d8 0a       	popm	pc,r12=0
8000bd06:	58 17       	cp.w	r7,1
8000bd08:	5f 1c       	srne	r12
8000bd0a:	58 09       	cp.w	r9,0
8000bd0c:	f5 b8 00 00 	subfeq	r8,0
8000bd10:	1b 07       	ld.w	r7,sp++
8000bd12:	1b 0e       	ld.w	lr,sp++
8000bd14:	5e 0d       	reteq	0
8000bd16:	5e fc       	retal	r12

8000bd18 <__avr32_f64_div>:
8000bd18:	eb cd 40 ff 	pushm	r0-r7,lr
8000bd1c:	f7 e9 20 0e 	eor	lr,r11,r9
8000bd20:	f6 07 16 14 	lsr	r7,r11,0x14
8000bd24:	a9 7b       	lsl	r11,0x9
8000bd26:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bd2a:	a9 7a       	lsl	r10,0x9
8000bd2c:	bd bb       	sbr	r11,0x1d
8000bd2e:	e4 1b 3f ff 	andh	r11,0x3fff
8000bd32:	ab d7       	cbr	r7,0xb
8000bd34:	e0 80 00 cc 	breq	8000becc <__avr32_f64_div_round_subnormal+0x54>
8000bd38:	e0 47 07 ff 	cp.w	r7,2047
8000bd3c:	e0 84 00 b5 	brge	8000bea6 <__avr32_f64_div_round_subnormal+0x2e>
8000bd40:	f2 06 16 14 	lsr	r6,r9,0x14
8000bd44:	a9 79       	lsl	r9,0x9
8000bd46:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bd4a:	a9 78       	lsl	r8,0x9
8000bd4c:	bd b9       	sbr	r9,0x1d
8000bd4e:	e4 19 3f ff 	andh	r9,0x3fff
8000bd52:	ab d6       	cbr	r6,0xb
8000bd54:	e0 80 00 e2 	breq	8000bf18 <__avr32_f64_div_round_subnormal+0xa0>
8000bd58:	e0 46 07 ff 	cp.w	r6,2047
8000bd5c:	e0 84 00 b2 	brge	8000bec0 <__avr32_f64_div_round_subnormal+0x48>
8000bd60:	0c 17       	sub	r7,r6
8000bd62:	fe 37 fc 01 	sub	r7,-1023
8000bd66:	fc 1c 80 00 	movh	r12,0x8000
8000bd6a:	f8 03 16 01 	lsr	r3,r12,0x1
8000bd6e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bd72:	5c d4       	com	r4
8000bd74:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bd78:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd7c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd80:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd84:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd88:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd8c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd90:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd94:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd98:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd9c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bda0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bda4:	ea 03 15 02 	lsl	r3,r5,0x2
8000bda8:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bdac:	e4 09 07 40 	macu.d	r0,r2,r9
8000bdb0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bdb4:	02 04       	add	r4,r1
8000bdb6:	5c 05       	acr	r5
8000bdb8:	a3 65       	lsl	r5,0x2
8000bdba:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bdbe:	a3 64       	lsl	r4,0x2
8000bdc0:	5c 34       	neg	r4
8000bdc2:	f8 05 01 45 	sbc	r5,r12,r5
8000bdc6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bdca:	e4 05 07 40 	macu.d	r0,r2,r5
8000bdce:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bdd2:	02 04       	add	r4,r1
8000bdd4:	5c 05       	acr	r5
8000bdd6:	ea 03 15 02 	lsl	r3,r5,0x2
8000bdda:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bdde:	e8 02 15 02 	lsl	r2,r4,0x2
8000bde2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bde6:	e4 09 07 40 	macu.d	r0,r2,r9
8000bdea:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bdee:	02 04       	add	r4,r1
8000bdf0:	5c 05       	acr	r5
8000bdf2:	a3 65       	lsl	r5,0x2
8000bdf4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bdf8:	a3 64       	lsl	r4,0x2
8000bdfa:	5c 34       	neg	r4
8000bdfc:	f8 05 01 45 	sbc	r5,r12,r5
8000be00:	e6 04 06 40 	mulu.d	r0,r3,r4
8000be04:	e4 05 07 40 	macu.d	r0,r2,r5
8000be08:	e6 05 06 44 	mulu.d	r4,r3,r5
8000be0c:	02 04       	add	r4,r1
8000be0e:	5c 05       	acr	r5
8000be10:	ea 03 15 02 	lsl	r3,r5,0x2
8000be14:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000be18:	e8 02 15 02 	lsl	r2,r4,0x2
8000be1c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000be20:	e4 0b 07 40 	macu.d	r0,r2,r11
8000be24:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000be28:	02 02       	add	r2,r1
8000be2a:	5c 03       	acr	r3
8000be2c:	ed b3 00 1c 	bld	r3,0x1c
8000be30:	c0 90       	breq	8000be42 <__avr32_f64_div+0x12a>
8000be32:	a1 72       	lsl	r2,0x1
8000be34:	5c f3       	rol	r3
8000be36:	20 17       	sub	r7,1
8000be38:	a3 9a       	lsr	r10,0x3
8000be3a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000be3e:	a3 9b       	lsr	r11,0x3
8000be40:	c0 58       	rjmp	8000be4a <__avr32_f64_div+0x132>
8000be42:	a5 8a       	lsr	r10,0x4
8000be44:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000be48:	a5 8b       	lsr	r11,0x4
8000be4a:	58 07       	cp.w	r7,0
8000be4c:	e0 8a 00 8b 	brle	8000bf62 <__avr32_f64_div_res_subnormal>
8000be50:	e0 12 ff 00 	andl	r2,0xff00
8000be54:	e8 12 00 80 	orl	r2,0x80
8000be58:	e6 08 06 40 	mulu.d	r0,r3,r8
8000be5c:	e4 09 07 40 	macu.d	r0,r2,r9
8000be60:	e4 08 06 44 	mulu.d	r4,r2,r8
8000be64:	e6 09 06 48 	mulu.d	r8,r3,r9
8000be68:	00 05       	add	r5,r0
8000be6a:	f0 01 00 48 	adc	r8,r8,r1
8000be6e:	5c 09       	acr	r9
8000be70:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000be74:	58 04       	cp.w	r4,0
8000be76:	5c 25       	cpc	r5

8000be78 <__avr32_f64_div_round_subnormal>:
8000be78:	f4 08 13 00 	cpc	r8,r10
8000be7c:	f6 09 13 00 	cpc	r9,r11
8000be80:	5f 36       	srlo	r6
8000be82:	f8 06 17 00 	moveq	r6,r12
8000be86:	e4 0a 16 08 	lsr	r10,r2,0x8
8000be8a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000be8e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000be92:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000be96:	ed be 00 1f 	bld	lr,0x1f
8000be9a:	ef bb 00 1f 	bst	r11,0x1f
8000be9e:	0c 0a       	add	r10,r6
8000bea0:	5c 0b       	acr	r11
8000bea2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bea6:	e4 1b 00 0f 	andh	r11,0xf
8000beaa:	14 4b       	or	r11,r10
8000beac:	e0 81 00 a7 	brne	8000bffa <__avr32_f64_div_res_subnormal+0x98>
8000beb0:	f2 06 16 14 	lsr	r6,r9,0x14
8000beb4:	ab d6       	cbr	r6,0xb
8000beb6:	e0 46 07 ff 	cp.w	r6,2047
8000beba:	e0 81 00 a4 	brne	8000c002 <__avr32_f64_div_res_subnormal+0xa0>
8000bebe:	c9 e8       	rjmp	8000bffa <__avr32_f64_div_res_subnormal+0x98>
8000bec0:	e4 19 00 0f 	andh	r9,0xf
8000bec4:	10 49       	or	r9,r8
8000bec6:	e0 81 00 9a 	brne	8000bffa <__avr32_f64_div_res_subnormal+0x98>
8000beca:	c9 28       	rjmp	8000bfee <__avr32_f64_div_res_subnormal+0x8c>
8000becc:	a3 7b       	lsl	r11,0x3
8000bece:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000bed2:	a3 7a       	lsl	r10,0x3
8000bed4:	f5 eb 10 04 	or	r4,r10,r11
8000bed8:	e0 80 00 a0 	breq	8000c018 <__avr32_f64_div_op1_zero>
8000bedc:	f6 04 12 00 	clz	r4,r11
8000bee0:	c1 70       	breq	8000bf0e <__avr32_f64_div_round_subnormal+0x96>
8000bee2:	c0 c3       	brcs	8000befa <__avr32_f64_div_round_subnormal+0x82>
8000bee4:	e8 05 11 20 	rsub	r5,r4,32
8000bee8:	f6 04 09 4b 	lsl	r11,r11,r4
8000beec:	f4 05 0a 45 	lsr	r5,r10,r5
8000bef0:	0a 4b       	or	r11,r5
8000bef2:	f4 04 09 4a 	lsl	r10,r10,r4
8000bef6:	08 17       	sub	r7,r4
8000bef8:	c0 b8       	rjmp	8000bf0e <__avr32_f64_div_round_subnormal+0x96>
8000befa:	f4 04 12 00 	clz	r4,r10
8000befe:	f9 b4 03 00 	movlo	r4,0
8000bf02:	f7 b4 02 e0 	subhs	r4,-32
8000bf06:	f4 04 09 4b 	lsl	r11,r10,r4
8000bf0a:	30 0a       	mov	r10,0
8000bf0c:	08 17       	sub	r7,r4
8000bf0e:	a3 8a       	lsr	r10,0x2
8000bf10:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bf14:	a3 8b       	lsr	r11,0x2
8000bf16:	c1 1b       	rjmp	8000bd38 <__avr32_f64_div+0x20>
8000bf18:	a3 79       	lsl	r9,0x3
8000bf1a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bf1e:	a3 78       	lsl	r8,0x3
8000bf20:	f3 e8 10 04 	or	r4,r9,r8
8000bf24:	c6 f0       	breq	8000c002 <__avr32_f64_div_res_subnormal+0xa0>
8000bf26:	f2 04 12 00 	clz	r4,r9
8000bf2a:	c1 70       	breq	8000bf58 <__avr32_f64_div_round_subnormal+0xe0>
8000bf2c:	c0 c3       	brcs	8000bf44 <__avr32_f64_div_round_subnormal+0xcc>
8000bf2e:	e8 05 11 20 	rsub	r5,r4,32
8000bf32:	f2 04 09 49 	lsl	r9,r9,r4
8000bf36:	f0 05 0a 45 	lsr	r5,r8,r5
8000bf3a:	0a 49       	or	r9,r5
8000bf3c:	f0 04 09 48 	lsl	r8,r8,r4
8000bf40:	08 16       	sub	r6,r4
8000bf42:	c0 b8       	rjmp	8000bf58 <__avr32_f64_div_round_subnormal+0xe0>
8000bf44:	f0 04 12 00 	clz	r4,r8
8000bf48:	f9 b4 03 00 	movlo	r4,0
8000bf4c:	f7 b4 02 e0 	subhs	r4,-32
8000bf50:	f0 04 09 49 	lsl	r9,r8,r4
8000bf54:	30 08       	mov	r8,0
8000bf56:	08 16       	sub	r6,r4
8000bf58:	a3 88       	lsr	r8,0x2
8000bf5a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bf5e:	a3 89       	lsr	r9,0x2
8000bf60:	cf ca       	rjmp	8000bd58 <__avr32_f64_div+0x40>

8000bf62 <__avr32_f64_div_res_subnormal>:
8000bf62:	5c 37       	neg	r7
8000bf64:	2f f7       	sub	r7,-1
8000bf66:	f1 b7 04 c0 	satu	r7,0x6
8000bf6a:	e0 47 00 20 	cp.w	r7,32
8000bf6e:	c1 54       	brge	8000bf98 <__avr32_f64_div_res_subnormal+0x36>
8000bf70:	ee 06 11 20 	rsub	r6,r7,32
8000bf74:	e4 07 0a 42 	lsr	r2,r2,r7
8000bf78:	e6 06 09 4c 	lsl	r12,r3,r6
8000bf7c:	18 42       	or	r2,r12
8000bf7e:	e6 07 0a 43 	lsr	r3,r3,r7
8000bf82:	f4 06 09 41 	lsl	r1,r10,r6
8000bf86:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bf8a:	f6 06 09 4c 	lsl	r12,r11,r6
8000bf8e:	18 4a       	or	r10,r12
8000bf90:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bf94:	30 00       	mov	r0,0
8000bf96:	c1 58       	rjmp	8000bfc0 <__avr32_f64_div_res_subnormal+0x5e>
8000bf98:	ee 06 11 20 	rsub	r6,r7,32
8000bf9c:	f9 b0 00 00 	moveq	r0,0
8000bfa0:	f9 bc 00 00 	moveq	r12,0
8000bfa4:	c0 50       	breq	8000bfae <__avr32_f64_div_res_subnormal+0x4c>
8000bfa6:	f4 06 09 40 	lsl	r0,r10,r6
8000bfaa:	f6 06 09 4c 	lsl	r12,r11,r6
8000bfae:	e6 07 0a 42 	lsr	r2,r3,r7
8000bfb2:	30 03       	mov	r3,0
8000bfb4:	f4 07 0a 41 	lsr	r1,r10,r7
8000bfb8:	18 41       	or	r1,r12
8000bfba:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bfbe:	30 0b       	mov	r11,0
8000bfc0:	e0 12 ff 00 	andl	r2,0xff00
8000bfc4:	e8 12 00 80 	orl	r2,0x80
8000bfc8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bfcc:	e4 09 07 46 	macu.d	r6,r2,r9
8000bfd0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bfd4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bfd8:	0c 05       	add	r5,r6
8000bfda:	f0 07 00 48 	adc	r8,r8,r7
8000bfde:	5c 09       	acr	r9
8000bfe0:	30 07       	mov	r7,0
8000bfe2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bfe6:	00 34       	cp.w	r4,r0
8000bfe8:	e2 05 13 00 	cpc	r5,r1
8000bfec:	c4 6b       	rjmp	8000be78 <__avr32_f64_div_round_subnormal>
8000bfee:	1c 9b       	mov	r11,lr
8000bff0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bff4:	30 0a       	mov	r10,0
8000bff6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bffa:	3f fb       	mov	r11,-1
8000bffc:	30 0a       	mov	r10,0
8000bffe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c002:	f5 eb 10 04 	or	r4,r10,r11
8000c006:	c0 90       	breq	8000c018 <__avr32_f64_div_op1_zero>
8000c008:	1c 9b       	mov	r11,lr
8000c00a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c00e:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c012:	30 0a       	mov	r10,0
8000c014:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c018 <__avr32_f64_div_op1_zero>:
8000c018:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c01c:	ce f0       	breq	8000bffa <__avr32_f64_div_res_subnormal+0x98>
8000c01e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c022:	e0 44 07 ff 	cp.w	r4,2047
8000c026:	ce 41       	brne	8000bfee <__avr32_f64_div_res_subnormal+0x8c>
8000c028:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c02c:	ce 10       	breq	8000bfee <__avr32_f64_div_res_subnormal+0x8c>
8000c02e:	ce 6b       	rjmp	8000bffa <__avr32_f64_div_res_subnormal+0x98>

8000c030 <__avr32_udiv64>:
8000c030:	d4 31       	pushm	r0-r7,lr
8000c032:	1a 97       	mov	r7,sp
8000c034:	20 3d       	sub	sp,12
8000c036:	10 9c       	mov	r12,r8
8000c038:	12 9e       	mov	lr,r9
8000c03a:	14 93       	mov	r3,r10
8000c03c:	58 09       	cp.w	r9,0
8000c03e:	e0 81 00 bd 	brne	8000c1b8 <__avr32_udiv64+0x188>
8000c042:	16 38       	cp.w	r8,r11
8000c044:	e0 88 00 40 	brls	8000c0c4 <__avr32_udiv64+0x94>
8000c048:	f0 08 12 00 	clz	r8,r8
8000c04c:	c0 d0       	breq	8000c066 <__avr32_udiv64+0x36>
8000c04e:	f6 08 09 4b 	lsl	r11,r11,r8
8000c052:	f0 09 11 20 	rsub	r9,r8,32
8000c056:	f8 08 09 4c 	lsl	r12,r12,r8
8000c05a:	f4 09 0a 49 	lsr	r9,r10,r9
8000c05e:	f4 08 09 43 	lsl	r3,r10,r8
8000c062:	f3 eb 10 0b 	or	r11,r9,r11
8000c066:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c06a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c06e:	f6 0e 0d 00 	divu	r0,r11,lr
8000c072:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c076:	00 99       	mov	r9,r0
8000c078:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c07c:	e0 0a 02 48 	mul	r8,r0,r10
8000c080:	10 3b       	cp.w	r11,r8
8000c082:	c0 a2       	brcc	8000c096 <__avr32_udiv64+0x66>
8000c084:	20 19       	sub	r9,1
8000c086:	18 0b       	add	r11,r12
8000c088:	18 3b       	cp.w	r11,r12
8000c08a:	c0 63       	brcs	8000c096 <__avr32_udiv64+0x66>
8000c08c:	10 3b       	cp.w	r11,r8
8000c08e:	f7 b9 03 01 	sublo	r9,1
8000c092:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c096:	f6 08 01 01 	sub	r1,r11,r8
8000c09a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c09e:	e2 0e 0d 00 	divu	r0,r1,lr
8000c0a2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c0a6:	00 98       	mov	r8,r0
8000c0a8:	e0 0a 02 4a 	mul	r10,r0,r10
8000c0ac:	14 33       	cp.w	r3,r10
8000c0ae:	c0 82       	brcc	8000c0be <__avr32_udiv64+0x8e>
8000c0b0:	20 18       	sub	r8,1
8000c0b2:	18 03       	add	r3,r12
8000c0b4:	18 33       	cp.w	r3,r12
8000c0b6:	c0 43       	brcs	8000c0be <__avr32_udiv64+0x8e>
8000c0b8:	14 33       	cp.w	r3,r10
8000c0ba:	f7 b8 03 01 	sublo	r8,1
8000c0be:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c0c2:	cd f8       	rjmp	8000c280 <__avr32_udiv64+0x250>
8000c0c4:	58 08       	cp.w	r8,0
8000c0c6:	c0 51       	brne	8000c0d0 <__avr32_udiv64+0xa0>
8000c0c8:	30 19       	mov	r9,1
8000c0ca:	f2 08 0d 08 	divu	r8,r9,r8
8000c0ce:	10 9c       	mov	r12,r8
8000c0d0:	f8 06 12 00 	clz	r6,r12
8000c0d4:	c0 41       	brne	8000c0dc <__avr32_udiv64+0xac>
8000c0d6:	18 1b       	sub	r11,r12
8000c0d8:	30 19       	mov	r9,1
8000c0da:	c4 08       	rjmp	8000c15a <__avr32_udiv64+0x12a>
8000c0dc:	ec 01 11 20 	rsub	r1,r6,32
8000c0e0:	f4 01 0a 49 	lsr	r9,r10,r1
8000c0e4:	f8 06 09 4c 	lsl	r12,r12,r6
8000c0e8:	f6 06 09 48 	lsl	r8,r11,r6
8000c0ec:	f6 01 0a 41 	lsr	r1,r11,r1
8000c0f0:	f3 e8 10 08 	or	r8,r9,r8
8000c0f4:	f8 03 16 10 	lsr	r3,r12,0x10
8000c0f8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c0fc:	e2 03 0d 00 	divu	r0,r1,r3
8000c100:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c104:	00 9e       	mov	lr,r0
8000c106:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c10a:	e0 05 02 49 	mul	r9,r0,r5
8000c10e:	12 3b       	cp.w	r11,r9
8000c110:	c0 a2       	brcc	8000c124 <__avr32_udiv64+0xf4>
8000c112:	20 1e       	sub	lr,1
8000c114:	18 0b       	add	r11,r12
8000c116:	18 3b       	cp.w	r11,r12
8000c118:	c0 63       	brcs	8000c124 <__avr32_udiv64+0xf4>
8000c11a:	12 3b       	cp.w	r11,r9
8000c11c:	f7 be 03 01 	sublo	lr,1
8000c120:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c124:	12 1b       	sub	r11,r9
8000c126:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c12a:	f6 03 0d 02 	divu	r2,r11,r3
8000c12e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c132:	04 99       	mov	r9,r2
8000c134:	e4 05 02 4b 	mul	r11,r2,r5
8000c138:	16 38       	cp.w	r8,r11
8000c13a:	c0 a2       	brcc	8000c14e <__avr32_udiv64+0x11e>
8000c13c:	20 19       	sub	r9,1
8000c13e:	18 08       	add	r8,r12
8000c140:	18 38       	cp.w	r8,r12
8000c142:	c0 63       	brcs	8000c14e <__avr32_udiv64+0x11e>
8000c144:	16 38       	cp.w	r8,r11
8000c146:	f7 b9 03 01 	sublo	r9,1
8000c14a:	f1 dc e3 08 	addcs	r8,r8,r12
8000c14e:	f4 06 09 43 	lsl	r3,r10,r6
8000c152:	f0 0b 01 0b 	sub	r11,r8,r11
8000c156:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c15a:	f8 06 16 10 	lsr	r6,r12,0x10
8000c15e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c162:	f6 06 0d 00 	divu	r0,r11,r6
8000c166:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c16a:	00 9a       	mov	r10,r0
8000c16c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c170:	e0 0e 02 48 	mul	r8,r0,lr
8000c174:	10 3b       	cp.w	r11,r8
8000c176:	c0 a2       	brcc	8000c18a <__avr32_udiv64+0x15a>
8000c178:	20 1a       	sub	r10,1
8000c17a:	18 0b       	add	r11,r12
8000c17c:	18 3b       	cp.w	r11,r12
8000c17e:	c0 63       	brcs	8000c18a <__avr32_udiv64+0x15a>
8000c180:	10 3b       	cp.w	r11,r8
8000c182:	f7 ba 03 01 	sublo	r10,1
8000c186:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c18a:	f6 08 01 01 	sub	r1,r11,r8
8000c18e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c192:	e2 06 0d 00 	divu	r0,r1,r6
8000c196:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c19a:	00 98       	mov	r8,r0
8000c19c:	e0 0e 02 4b 	mul	r11,r0,lr
8000c1a0:	16 33       	cp.w	r3,r11
8000c1a2:	c0 82       	brcc	8000c1b2 <__avr32_udiv64+0x182>
8000c1a4:	20 18       	sub	r8,1
8000c1a6:	18 03       	add	r3,r12
8000c1a8:	18 33       	cp.w	r3,r12
8000c1aa:	c0 43       	brcs	8000c1b2 <__avr32_udiv64+0x182>
8000c1ac:	16 33       	cp.w	r3,r11
8000c1ae:	f7 b8 03 01 	sublo	r8,1
8000c1b2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c1b6:	c6 98       	rjmp	8000c288 <__avr32_udiv64+0x258>
8000c1b8:	16 39       	cp.w	r9,r11
8000c1ba:	e0 8b 00 65 	brhi	8000c284 <__avr32_udiv64+0x254>
8000c1be:	f2 09 12 00 	clz	r9,r9
8000c1c2:	c0 b1       	brne	8000c1d8 <__avr32_udiv64+0x1a8>
8000c1c4:	10 3a       	cp.w	r10,r8
8000c1c6:	5f 2a       	srhs	r10
8000c1c8:	1c 3b       	cp.w	r11,lr
8000c1ca:	5f b8       	srhi	r8
8000c1cc:	10 4a       	or	r10,r8
8000c1ce:	f2 0a 18 00 	cp.b	r10,r9
8000c1d2:	c5 90       	breq	8000c284 <__avr32_udiv64+0x254>
8000c1d4:	30 18       	mov	r8,1
8000c1d6:	c5 98       	rjmp	8000c288 <__avr32_udiv64+0x258>
8000c1d8:	f0 09 09 46 	lsl	r6,r8,r9
8000c1dc:	f2 03 11 20 	rsub	r3,r9,32
8000c1e0:	fc 09 09 4e 	lsl	lr,lr,r9
8000c1e4:	f0 03 0a 48 	lsr	r8,r8,r3
8000c1e8:	f6 09 09 4c 	lsl	r12,r11,r9
8000c1ec:	f4 03 0a 42 	lsr	r2,r10,r3
8000c1f0:	ef 46 ff f4 	st.w	r7[-12],r6
8000c1f4:	f6 03 0a 43 	lsr	r3,r11,r3
8000c1f8:	18 42       	or	r2,r12
8000c1fa:	f1 ee 10 0c 	or	r12,r8,lr
8000c1fe:	f8 01 16 10 	lsr	r1,r12,0x10
8000c202:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c206:	e6 01 0d 04 	divu	r4,r3,r1
8000c20a:	e4 03 16 10 	lsr	r3,r2,0x10
8000c20e:	08 9e       	mov	lr,r4
8000c210:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c214:	e8 06 02 48 	mul	r8,r4,r6
8000c218:	10 33       	cp.w	r3,r8
8000c21a:	c0 a2       	brcc	8000c22e <__avr32_udiv64+0x1fe>
8000c21c:	20 1e       	sub	lr,1
8000c21e:	18 03       	add	r3,r12
8000c220:	18 33       	cp.w	r3,r12
8000c222:	c0 63       	brcs	8000c22e <__avr32_udiv64+0x1fe>
8000c224:	10 33       	cp.w	r3,r8
8000c226:	f7 be 03 01 	sublo	lr,1
8000c22a:	e7 dc e3 03 	addcs	r3,r3,r12
8000c22e:	10 13       	sub	r3,r8
8000c230:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c234:	e6 01 0d 00 	divu	r0,r3,r1
8000c238:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c23c:	00 98       	mov	r8,r0
8000c23e:	e0 06 02 46 	mul	r6,r0,r6
8000c242:	0c 3b       	cp.w	r11,r6
8000c244:	c0 a2       	brcc	8000c258 <__avr32_udiv64+0x228>
8000c246:	20 18       	sub	r8,1
8000c248:	18 0b       	add	r11,r12
8000c24a:	18 3b       	cp.w	r11,r12
8000c24c:	c0 63       	brcs	8000c258 <__avr32_udiv64+0x228>
8000c24e:	0c 3b       	cp.w	r11,r6
8000c250:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c254:	f7 b8 03 01 	sublo	r8,1
8000c258:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c25c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c260:	0c 1b       	sub	r11,r6
8000c262:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c266:	06 95       	mov	r5,r3
8000c268:	16 35       	cp.w	r5,r11
8000c26a:	e0 8b 00 0a 	brhi	8000c27e <__avr32_udiv64+0x24e>
8000c26e:	5f 0b       	sreq	r11
8000c270:	f4 09 09 49 	lsl	r9,r10,r9
8000c274:	12 32       	cp.w	r2,r9
8000c276:	5f b9       	srhi	r9
8000c278:	f7 e9 00 09 	and	r9,r11,r9
8000c27c:	c0 60       	breq	8000c288 <__avr32_udiv64+0x258>
8000c27e:	20 18       	sub	r8,1
8000c280:	30 09       	mov	r9,0
8000c282:	c0 38       	rjmp	8000c288 <__avr32_udiv64+0x258>
8000c284:	30 09       	mov	r9,0
8000c286:	12 98       	mov	r8,r9
8000c288:	10 9a       	mov	r10,r8
8000c28a:	12 93       	mov	r3,r9
8000c28c:	10 92       	mov	r2,r8
8000c28e:	12 9b       	mov	r11,r9
8000c290:	2f dd       	sub	sp,-12
8000c292:	d8 32       	popm	r0-r7,pc

8000c294 <__avr32_umod64>:
8000c294:	d4 31       	pushm	r0-r7,lr
8000c296:	1a 97       	mov	r7,sp
8000c298:	20 3d       	sub	sp,12
8000c29a:	10 9c       	mov	r12,r8
8000c29c:	12 95       	mov	r5,r9
8000c29e:	14 9e       	mov	lr,r10
8000c2a0:	16 91       	mov	r1,r11
8000c2a2:	16 96       	mov	r6,r11
8000c2a4:	58 09       	cp.w	r9,0
8000c2a6:	e0 81 00 81 	brne	8000c3a8 <__avr32_umod64+0x114>
8000c2aa:	16 38       	cp.w	r8,r11
8000c2ac:	e0 88 00 12 	brls	8000c2d0 <__avr32_umod64+0x3c>
8000c2b0:	f0 08 12 00 	clz	r8,r8
8000c2b4:	c4 e0       	breq	8000c350 <__avr32_umod64+0xbc>
8000c2b6:	f6 08 09 46 	lsl	r6,r11,r8
8000c2ba:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2be:	f0 0b 11 20 	rsub	r11,r8,32
8000c2c2:	f4 08 09 4e 	lsl	lr,r10,r8
8000c2c6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c2ca:	f7 e6 10 06 	or	r6,r11,r6
8000c2ce:	c4 18       	rjmp	8000c350 <__avr32_umod64+0xbc>
8000c2d0:	58 08       	cp.w	r8,0
8000c2d2:	c0 51       	brne	8000c2dc <__avr32_umod64+0x48>
8000c2d4:	30 19       	mov	r9,1
8000c2d6:	f2 08 0d 08 	divu	r8,r9,r8
8000c2da:	10 9c       	mov	r12,r8
8000c2dc:	f8 08 12 00 	clz	r8,r12
8000c2e0:	c0 31       	brne	8000c2e6 <__avr32_umod64+0x52>
8000c2e2:	18 16       	sub	r6,r12
8000c2e4:	c3 68       	rjmp	8000c350 <__avr32_umod64+0xbc>
8000c2e6:	f0 03 11 20 	rsub	r3,r8,32
8000c2ea:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c2ee:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2f2:	ec 08 09 49 	lsl	r9,r6,r8
8000c2f6:	ec 03 0a 43 	lsr	r3,r6,r3
8000c2fa:	f7 e9 10 09 	or	r9,r11,r9
8000c2fe:	f8 05 16 10 	lsr	r5,r12,0x10
8000c302:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c306:	e6 05 0d 02 	divu	r2,r3,r5
8000c30a:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c30e:	ec 02 02 4b 	mul	r11,r6,r2
8000c312:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c316:	16 3e       	cp.w	lr,r11
8000c318:	c0 72       	brcc	8000c326 <__avr32_umod64+0x92>
8000c31a:	18 0e       	add	lr,r12
8000c31c:	18 3e       	cp.w	lr,r12
8000c31e:	c0 43       	brcs	8000c326 <__avr32_umod64+0x92>
8000c320:	16 3e       	cp.w	lr,r11
8000c322:	fd dc e3 0e 	addcs	lr,lr,r12
8000c326:	fc 0b 01 03 	sub	r3,lr,r11
8000c32a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c32e:	e6 05 0d 02 	divu	r2,r3,r5
8000c332:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c336:	a5 36       	mul	r6,r2
8000c338:	0c 39       	cp.w	r9,r6
8000c33a:	c0 72       	brcc	8000c348 <__avr32_umod64+0xb4>
8000c33c:	18 09       	add	r9,r12
8000c33e:	18 39       	cp.w	r9,r12
8000c340:	c0 43       	brcs	8000c348 <__avr32_umod64+0xb4>
8000c342:	0c 39       	cp.w	r9,r6
8000c344:	f3 dc e3 09 	addcs	r9,r9,r12
8000c348:	f2 06 01 06 	sub	r6,r9,r6
8000c34c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c350:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c354:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c358:	ec 0a 0d 02 	divu	r2,r6,r10
8000c35c:	fc 09 16 10 	lsr	r9,lr,0x10
8000c360:	ea 02 02 4b 	mul	r11,r5,r2
8000c364:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c368:	16 39       	cp.w	r9,r11
8000c36a:	c0 72       	brcc	8000c378 <__avr32_umod64+0xe4>
8000c36c:	18 09       	add	r9,r12
8000c36e:	18 39       	cp.w	r9,r12
8000c370:	c0 43       	brcs	8000c378 <__avr32_umod64+0xe4>
8000c372:	16 39       	cp.w	r9,r11
8000c374:	f3 dc e3 09 	addcs	r9,r9,r12
8000c378:	f2 0b 01 0b 	sub	r11,r9,r11
8000c37c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c380:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c384:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c388:	ea 0a 02 4a 	mul	r10,r5,r10
8000c38c:	14 3e       	cp.w	lr,r10
8000c38e:	c0 72       	brcc	8000c39c <__avr32_umod64+0x108>
8000c390:	18 0e       	add	lr,r12
8000c392:	18 3e       	cp.w	lr,r12
8000c394:	c0 43       	brcs	8000c39c <__avr32_umod64+0x108>
8000c396:	14 3e       	cp.w	lr,r10
8000c398:	fd dc e3 0e 	addcs	lr,lr,r12
8000c39c:	fc 0a 01 0a 	sub	r10,lr,r10
8000c3a0:	30 0b       	mov	r11,0
8000c3a2:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c3a6:	c7 b8       	rjmp	8000c49c <__avr32_umod64+0x208>
8000c3a8:	16 39       	cp.w	r9,r11
8000c3aa:	e0 8b 00 79 	brhi	8000c49c <__avr32_umod64+0x208>
8000c3ae:	f2 09 12 00 	clz	r9,r9
8000c3b2:	c1 21       	brne	8000c3d6 <__avr32_umod64+0x142>
8000c3b4:	10 3a       	cp.w	r10,r8
8000c3b6:	5f 2b       	srhs	r11
8000c3b8:	0a 31       	cp.w	r1,r5
8000c3ba:	5f ba       	srhi	r10
8000c3bc:	f7 ea 10 0a 	or	r10,r11,r10
8000c3c0:	f2 0a 18 00 	cp.b	r10,r9
8000c3c4:	c0 60       	breq	8000c3d0 <__avr32_umod64+0x13c>
8000c3c6:	fc 08 01 0c 	sub	r12,lr,r8
8000c3ca:	e2 05 01 46 	sbc	r6,r1,r5
8000c3ce:	18 9e       	mov	lr,r12
8000c3d0:	0c 9b       	mov	r11,r6
8000c3d2:	1c 9a       	mov	r10,lr
8000c3d4:	c6 48       	rjmp	8000c49c <__avr32_umod64+0x208>
8000c3d6:	ea 09 09 4c 	lsl	r12,r5,r9
8000c3da:	f2 06 11 20 	rsub	r6,r9,32
8000c3de:	f6 09 09 4b 	lsl	r11,r11,r9
8000c3e2:	f0 09 09 42 	lsl	r2,r8,r9
8000c3e6:	ef 46 ff f4 	st.w	r7[-12],r6
8000c3ea:	f0 06 0a 48 	lsr	r8,r8,r6
8000c3ee:	18 48       	or	r8,r12
8000c3f0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c3f4:	f4 09 09 43 	lsl	r3,r10,r9
8000c3f8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c3fc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c400:	16 4a       	or	r10,r11
8000c402:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c406:	f8 0b 0d 04 	divu	r4,r12,r11
8000c40a:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c40e:	08 91       	mov	r1,r4
8000c410:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c414:	e8 0e 02 46 	mul	r6,r4,lr
8000c418:	0c 3c       	cp.w	r12,r6
8000c41a:	c0 a2       	brcc	8000c42e <__avr32_umod64+0x19a>
8000c41c:	20 11       	sub	r1,1
8000c41e:	10 0c       	add	r12,r8
8000c420:	10 3c       	cp.w	r12,r8
8000c422:	c0 63       	brcs	8000c42e <__avr32_umod64+0x19a>
8000c424:	0c 3c       	cp.w	r12,r6
8000c426:	f7 b1 03 01 	sublo	r1,1
8000c42a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c42e:	0c 1c       	sub	r12,r6
8000c430:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c434:	f8 0b 0d 04 	divu	r4,r12,r11
8000c438:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c43c:	08 96       	mov	r6,r4
8000c43e:	e8 0e 02 4e 	mul	lr,r4,lr
8000c442:	1c 3b       	cp.w	r11,lr
8000c444:	c0 a2       	brcc	8000c458 <__avr32_umod64+0x1c4>
8000c446:	20 16       	sub	r6,1
8000c448:	10 0b       	add	r11,r8
8000c44a:	10 3b       	cp.w	r11,r8
8000c44c:	c0 63       	brcs	8000c458 <__avr32_umod64+0x1c4>
8000c44e:	1c 3b       	cp.w	r11,lr
8000c450:	f7 b6 03 01 	sublo	r6,1
8000c454:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c458:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c45c:	1c 1b       	sub	r11,lr
8000c45e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c462:	00 9e       	mov	lr,r0
8000c464:	02 9c       	mov	r12,r1
8000c466:	16 3c       	cp.w	r12,r11
8000c468:	e0 8b 00 08 	brhi	8000c478 <__avr32_umod64+0x1e4>
8000c46c:	5f 06       	sreq	r6
8000c46e:	06 30       	cp.w	r0,r3
8000c470:	5f ba       	srhi	r10
8000c472:	ed ea 00 0a 	and	r10,r6,r10
8000c476:	c0 60       	breq	8000c482 <__avr32_umod64+0x1ee>
8000c478:	fc 02 01 04 	sub	r4,lr,r2
8000c47c:	f8 08 01 4c 	sbc	r12,r12,r8
8000c480:	08 9e       	mov	lr,r4
8000c482:	e6 0e 01 0a 	sub	r10,r3,lr
8000c486:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c48a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c48e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c492:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c496:	f8 01 09 4c 	lsl	r12,r12,r1
8000c49a:	18 4a       	or	r10,r12
8000c49c:	2f dd       	sub	sp,-12
8000c49e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c600:	c0 08       	rjmp	8000c600 <_evba>
	...

8000c604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c604:	c0 08       	rjmp	8000c604 <_handle_TLB_Multiple_Hit>
	...

8000c608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c608:	c0 08       	rjmp	8000c608 <_handle_Bus_Error_Data_Fetch>
	...

8000c60c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c60c:	c0 08       	rjmp	8000c60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c610:	c0 08       	rjmp	8000c610 <_handle_NMI>
	...

8000c614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c614:	c0 08       	rjmp	8000c614 <_handle_Instruction_Address>
	...

8000c618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c618:	c0 08       	rjmp	8000c618 <_handle_ITLB_Protection>
	...

8000c61c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c61c:	c0 08       	rjmp	8000c61c <_handle_Breakpoint>
	...

8000c620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c620:	c0 08       	rjmp	8000c620 <_handle_Illegal_Opcode>
	...

8000c624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c624:	c0 08       	rjmp	8000c624 <_handle_Unimplemented_Instruction>
	...

8000c628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c628:	c0 08       	rjmp	8000c628 <_handle_Privilege_Violation>
	...

8000c62c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c62c:	c0 08       	rjmp	8000c62c <_handle_Floating_Point>
	...

8000c630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c630:	c0 08       	rjmp	8000c630 <_handle_Coprocessor_Absent>
	...

8000c634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c634:	c0 08       	rjmp	8000c634 <_handle_Data_Address_Read>
	...

8000c638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c638:	c0 08       	rjmp	8000c638 <_handle_Data_Address_Write>
	...

8000c63c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c63c:	c0 08       	rjmp	8000c63c <_handle_DTLB_Protection_Read>
	...

8000c640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c640:	c0 08       	rjmp	8000c640 <_handle_DTLB_Protection_Write>
	...

8000c644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c644:	c0 08       	rjmp	8000c644 <_handle_DTLB_Modified>
	...

8000c650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c650:	c0 08       	rjmp	8000c650 <_handle_ITLB_Miss>
	...

8000c660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c660:	c0 08       	rjmp	8000c660 <_handle_DTLB_Miss_Read>
	...

8000c670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c670:	c0 08       	rjmp	8000c670 <_handle_DTLB_Miss_Write>
	...

8000c700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c700:	fe cf 70 c0 	sub	pc,pc,28864

8000c704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c704:	30 0c       	mov	r12,0
8000c706:	fe b0 c4 63 	rcall	80004fcc <_get_interrupt_handler>
8000c70a:	58 0c       	cp.w	r12,0
8000c70c:	f8 0f 17 10 	movne	pc,r12
8000c710:	d6 03       	rete

8000c712 <_int1>:
8000c712:	30 1c       	mov	r12,1
8000c714:	fe b0 c4 5c 	rcall	80004fcc <_get_interrupt_handler>
8000c718:	58 0c       	cp.w	r12,0
8000c71a:	f8 0f 17 10 	movne	pc,r12
8000c71e:	d6 03       	rete

8000c720 <_int2>:
8000c720:	30 2c       	mov	r12,2
8000c722:	fe b0 c4 55 	rcall	80004fcc <_get_interrupt_handler>
8000c726:	58 0c       	cp.w	r12,0
8000c728:	f8 0f 17 10 	movne	pc,r12
8000c72c:	d6 03       	rete

8000c72e <_int3>:
8000c72e:	30 3c       	mov	r12,3
8000c730:	fe b0 c4 4e 	rcall	80004fcc <_get_interrupt_handler>
8000c734:	58 0c       	cp.w	r12,0
8000c736:	f8 0f 17 10 	movne	pc,r12
8000c73a:	d6 03       	rete

8000c73c <ipr_val>:
8000c73c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c74c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c75c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c76c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c77c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c78c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c79c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7fc:	d7 03 d7 03                                         ....
