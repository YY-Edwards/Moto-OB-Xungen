
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a734  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c800  8000c800  0000cc00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001260  8000ca00  8000ca00  0000ce00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a30  00000004  8000dc60  0000e404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a34  8000e690  0000ee34  2**0
                  ALLOC
  7 .bss          0000ac40  00000a38  8000e690  0000ee38  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000ee34  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001680  00000000  00000000  0000ee68  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000364b  00000000  00000000  000104e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c4c6  00000000  00000000  00013b33  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000072c8  00000000  00000000  0003fff9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d3c1  00000000  00000000  000472c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003cf0  00000000  00000000  00054684  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00008001  00000000  00000000  00058374  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f16e  00000000  00000000  00060375  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001748  00000000  00000000  0006f4e8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c9 24 	sub	pc,pc,-14044

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	f8 c8 ff fe 	sub	r8,r12,-2
void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
80002008:	f1 2a 00 01 	ld.sb	r10,r8[1]
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
8000200c:	48 c9       	lddpc	r9,8000203c <DeviceManagement_brdcst_func+0x38>
8000200e:	92 39       	ld.sh	r9,r9[0x6]
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
		temp |= ptr->XCMP_Device_ID;
80002010:	11 a8       	ld.ub	r8,r8[0x2]
80002012:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002016:	f0 09 19 00 	cp.h	r9,r8
8000201a:	5e 1c       	retne	r12
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
		{
			if (xcmp->u8[0] == 0x01)
8000201c:	19 a9       	ld.ub	r9,r12[0x2]
8000201e:	30 18       	mov	r8,1
80002020:	f0 09 18 00 	cp.b	r9,r8
80002024:	c0 61       	brne	80002030 <DeviceManagement_brdcst_func+0x2c>
			//if(ptr->Function == Start)
			{
				//Enable Option Board
				bunchofrandomstatusflags |= 0x00000002;
80002026:	48 78       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002028:	70 09       	ld.w	r9,r8[0x0]
8000202a:	a1 b9       	sbr	r9,0x1
8000202c:	91 09       	st.w	r8[0x0],r9
8000202e:	5e fc       	retal	r12
			}
			else
			{
				//Disable Option Board.
				//log("Device State : %d\n", );
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002030:	48 48       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	a1 d9       	cbr	r9,0x1
80002036:	91 09       	st.w	r8[0x0],r9
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	97 00       	st.w	r11[0x0],r0
80002040:	00 00       	add	r0,r0
80002042:	0d 7c       	ld.ub	r12,--r6

80002044 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002044:	5e fc       	retal	r12

80002046 <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002046:	5e fc       	retal	r12

80002048 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002048:	48 38       	lddpc	r8,80002054 <vApplicationIdleHook+0xc>
8000204a:	70 09       	ld.w	r9,r8[0x0]
8000204c:	2f f9       	sub	r9,-1
8000204e:	91 09       	st.w	r8[0x0],r9
	
}
80002050:	5e fc       	retal	r12
80002052:	00 00       	add	r0,r0
80002054:	00 00       	add	r0,r0
80002056:	0a 58       	eor	r8,r5

80002058 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002058:	d4 01       	pushm	lr
  log("R");
8000205a:	48 3c       	lddpc	r12,80002064 <app_payload_tx_proc+0xc>
8000205c:	f0 1f 00 03 	mcall	80002068 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002060:	d8 02       	popm	pc
80002062:	00 00       	add	r0,r0
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	ca 00       	breq	80001fa6 <_trampoline+0x1fa6>
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	6a 38       	ld.w	r8,r5[0xc]

8000206c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000206c:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000206e:	48 99       	lddpc	r9,80002090 <app_payload_rx_proc+0x24>
80002070:	13 88       	ld.ub	r8,r9[0x0]
80002072:	2f f8       	sub	r8,-1
80002074:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002076:	30 39       	mov	r9,3
80002078:	f2 08 18 00 	cp.b	r8,r9
8000207c:	c0 71       	brne	8000208a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000207e:	30 09       	mov	r9,0
80002080:	48 48       	lddpc	r8,80002090 <app_payload_rx_proc+0x24>
80002082:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002084:	48 4c       	lddpc	r12,80002094 <app_payload_rx_proc+0x28>
80002086:	f0 1f 00 05 	mcall	80002098 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000208a:	48 58       	lddpc	r8,8000209c <app_payload_rx_proc+0x30>
8000208c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000208e:	d8 02       	popm	pc
80002090:	00 00       	add	r0,r0
80002092:	0a 54       	eor	r4,r5
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	ca 04       	brge	80001fd6 <_trampoline+0x1fd6>
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	6a 38       	ld.w	r8,r5[0xc]
8000209c:	00 00       	add	r0,r0
8000209e:	0a 40       	or	r0,r5

800020a0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a2:	48 3c       	lddpc	r12,800020ac <FD_brdcst_func+0xc>
800020a4:	f0 1f 00 03 	mcall	800020b0 <FD_brdcst_func+0x10>
	
}
800020a8:	d8 02       	popm	pc
800020aa:	00 00       	add	r0,r0
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	ca 10       	breq	80001ff0 <_trampoline+0x1ff0>
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	6a 38       	ld.w	r8,r5[0xc]

800020b4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b6:	48 3c       	lddpc	r12,800020c0 <FD_reply_func+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <FD_reply_func+0x10>
	
	
}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	ca 30       	breq	80002008 <DeviceManagement_brdcst_func+0x4>
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	6a 38       	ld.w	r8,r5[0xc]

800020c8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ca:	48 3c       	lddpc	r12,800020d4 <FD_request_func+0xc>
800020cc:	f0 1f 00 03 	mcall	800020d8 <FD_request_func+0x10>
	
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	ca 4c       	rcall	8000221e <ButtonConfig_brdcst_func+0x72>
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	6a 38       	ld.w	r8,r5[0xc]

800020dc <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020dc:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020de:	48 3c       	lddpc	r12,800020e8 <EnOB_brdcst_func+0xc>
800020e0:	f0 1f 00 03 	mcall	800020ec <EnOB_brdcst_func+0x10>
}
800020e4:	d8 02       	popm	pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	ca 68       	rjmp	80002236 <ButtonConfig_brdcst_func+0x8a>
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	6a 38       	ld.w	r8,r5[0xc]

800020f0 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f6:	19 a9       	ld.ub	r9,r12[0x2]
800020f8:	30 08       	mov	r8,0
800020fa:	f0 09 18 00 	cp.b	r9,r8
800020fe:	c1 91       	brne	80002130 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002100:	19 b8       	ld.ub	r8,r12[0x3]
80002102:	30 19       	mov	r9,1
80002104:	f2 08 18 00 	cp.b	r8,r9
80002108:	c0 61       	brne	80002114 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210a:	49 0c       	lddpc	r12,80002148 <EnOB_reply_func+0x58>
8000210c:	f0 1f 00 10 	mcall	8000214c <EnOB_reply_func+0x5c>
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002114:	58 08       	cp.w	r8,0
80002116:	c0 61       	brne	80002122 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002118:	48 ec       	lddpc	r12,80002150 <EnOB_reply_func+0x60>
8000211a:	f0 1f 00 0d 	mcall	8000214c <EnOB_reply_func+0x5c>
8000211e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002122:	1a d8       	st.w	--sp,r8
80002124:	48 cc       	lddpc	r12,80002154 <EnOB_reply_func+0x64>
80002126:	f0 1f 00 0a 	mcall	8000214c <EnOB_reply_func+0x5c>
8000212a:	2f fd       	sub	sp,-4
8000212c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002130:	48 ac       	lddpc	r12,80002158 <EnOB_reply_func+0x68>
80002132:	f0 1f 00 07 	mcall	8000214c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002136:	0f a8       	ld.ub	r8,r7[0x2]
80002138:	1a d8       	st.w	--sp,r8
8000213a:	48 9c       	lddpc	r12,8000215c <EnOB_reply_func+0x6c>
8000213c:	f0 1f 00 04 	mcall	8000214c <EnOB_reply_func+0x5c>
80002140:	2f fd       	sub	sp,-4
80002142:	e3 cd 80 80 	ldm	sp++,r7,pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	ca 80       	breq	8000209a <app_payload_rx_proc+0x2e>
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	6a 38       	ld.w	r8,r5[0xc]
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ca 98       	rjmp	800022a4 <ButtonConfig_reply_func+0x1c>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	ca ac       	rcall	800022aa <ButtonConfig_reply_func+0x22>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ca c4       	brge	800020b2 <FD_brdcst_func+0x12>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	ca e0       	breq	800020ba <FD_reply_func+0x6>

80002160 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 91       	brne	80002180 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 ac       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x38>
80002172:	f0 1f 00 0b 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
80002176:	30 19       	mov	r9,1
80002178:	48 a8       	lddpc	r8,800021a0 <SingleDetection_brdcst_func+0x40>
8000217a:	b0 89       	st.b	r8[0x0],r9
8000217c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002180:	48 9c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x44>
80002182:	f0 1f 00 07 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
80002186:	0f a8       	ld.ub	r8,r7[0x2]
80002188:	1a d8       	st.w	--sp,r8
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x48>
8000218c:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
80002190:	2f fd       	sub	sp,-4
80002192:	e3 cd 80 80 	ldm	sp++,r7,pc
80002196:	00 00       	add	r0,r0
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	ca f8       	rjmp	800022f8 <BatteryLevel_brdcst_func+0x2c>
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	6a 38       	ld.w	r8,r5[0xc]
800021a0:	00 00       	add	r0,r0
800021a2:	00 04       	add	r4,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	cb 0c       	rcall	80002306 <ShutDown_brdcst_func+0xa>
800021a8:	80 00       	ld.sh	r0,r0[0x0]
800021aa:	cb 1c       	rcall	8000230c <ShutDown_brdcst_func+0x10>

800021ac <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ac:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ae:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b4:	4a bc       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xb4>
800021b6:	f0 1f 00 2c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021ba:	0f 88       	ld.ub	r8,r7[0x0]
800021bc:	1a d8       	st.w	--sp,r8
800021be:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xbc>
800021c0:	f0 1f 00 29 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c4:	1a d5       	st.w	--sp,r5
800021c6:	4a ac       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc0>
800021c8:	f0 1f 00 27 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021cc:	0f a8       	ld.ub	r8,r7[0x2]
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	4a 8c       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc4>
800021d2:	f0 1f 00 25 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d6:	2f dd       	sub	sp,-12
800021d8:	58 05       	cp.w	r5,0
800021da:	c4 10       	breq	8000225c <ButtonConfig_brdcst_func+0xb0>
800021dc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021de:	4a 64       	lddpc	r4,80002274 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e0:	4a 63       	lddpc	r3,80002278 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e2:	4a 72       	lddpc	r2,8000227c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e4:	4a 71       	lddpc	r1,80002280 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e6:	4a 80       	lddpc	r0,80002284 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e8:	0f b9       	ld.ub	r9,r7[0x3]
800021ea:	0f c8       	ld.ub	r8,r7[0x4]
800021ec:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f0:	1a d8       	st.w	--sp,r8
800021f2:	1a d6       	st.w	--sp,r6
800021f4:	08 9c       	mov	r12,r4
800021f6:	f0 1f 00 1c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fa:	0f d9       	ld.ub	r9,r7[0x5]
800021fc:	0f e8       	ld.ub	r8,r7[0x6]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	06 9c       	mov	r12,r3
80002208:	f0 1f 00 17 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000220c:	0f f9       	ld.ub	r9,r7[0x7]
8000220e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002212:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002216:	1a d8       	st.w	--sp,r8
80002218:	1a d6       	st.w	--sp,r6
8000221a:	04 9c       	mov	r12,r2
8000221c:	f0 1f 00 12 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002220:	ef 39 00 09 	ld.ub	r9,r7[9]
80002224:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002228:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	1a d6       	st.w	--sp,r6
80002230:	02 9c       	mov	r12,r1
80002232:	f0 1f 00 0d 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002236:	2f 8d       	sub	sp,-32
80002238:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000223c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002240:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002244:	1a d8       	st.w	--sp,r8
80002246:	1a d6       	st.w	--sp,r6
80002248:	00 9c       	mov	r12,r0
8000224a:	f0 1f 00 07 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
8000224e:	2f f6       	sub	r6,-1
80002250:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002252:	2f ed       	sub	sp,-8
80002254:	ec 05 18 00 	cp.b	r5,r6
80002258:	fe 9b ff c8 	brhi	800021e8 <ButtonConfig_brdcst_func+0x3c>
8000225c:	d8 32       	popm	r0-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	cb 30       	breq	800021c8 <ButtonConfig_brdcst_func+0x1c>
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	6a 38       	ld.w	r8,r5[0xc]
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	cb 50       	breq	800021d4 <ButtonConfig_brdcst_func+0x28>
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	cb 64       	brge	800021da <ButtonConfig_brdcst_func+0x2e>
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	cb 7c       	rcall	800023e0 <TransmitControl_brdcst_func+0x14>
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	cb 9c       	rcall	800023e8 <TransmitControl_brdcst_func+0x1c>
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	cb c4       	brge	800021f2 <ButtonConfig_brdcst_func+0x46>
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	cb ec       	rcall	800023fa <TransmitControl_brdcst_func+0x2e>
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	cc 10       	breq	80002204 <ButtonConfig_brdcst_func+0x58>
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	cc 38       	rjmp	8000240c <TransmitControl_brdcst_func+0x40>

80002288 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002288:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000228c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002290:	0f 89       	ld.ub	r9,r7[0x0]
80002292:	30 08       	mov	r8,0
80002294:	f0 09 18 00 	cp.b	r9,r8
80002298:	c0 c1       	brne	800022b0 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000229a:	48 9c       	lddpc	r12,800022bc <ButtonConfig_reply_func+0x34>
8000229c:	f0 1f 00 09 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a0:	0f 98       	ld.ub	r8,r7[0x1]
800022a2:	1a d8       	st.w	--sp,r8
800022a4:	48 8c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x3c>
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022aa:	2f fd       	sub	sp,-4
800022ac:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b0:	48 6c       	lddpc	r12,800022c8 <ButtonConfig_reply_func+0x40>
800022b2:	f0 1f 00 04 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	cc 5c       	rcall	80002448 <TransmitControl_reply_func+0x34>
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	6a 38       	ld.w	r8,r5[0xc]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	cb 50       	breq	80002230 <ButtonConfig_brdcst_func+0x84>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	cc 74       	brge	80002258 <ButtonConfig_brdcst_func+0xac>

800022cc <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022d0:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022d4:	0f 89       	ld.ub	r9,r7[0x0]
800022d6:	30 08       	mov	r8,0
800022d8:	f0 09 18 00 	cp.b	r9,r8
800022dc:	c0 40       	breq	800022e4 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022de:	48 5c       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x24>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 58       	lddpc	r8,800022f8 <BatteryLevel_brdcst_func+0x2c>
800022e8:	b0 89       	st.b	r8[0x0],r9

}
800022ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	cc 90       	breq	80002284 <ButtonConfig_brdcst_func+0xd8>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	6a 38       	ld.w	r8,r5[0xc]
800022f8:	00 00       	add	r0,r0
800022fa:	0a 39       	cp.w	r9,r5

800022fc <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022fe:	19 a8       	ld.ub	r8,r12[0x2]
80002300:	30 19       	mov	r9,1
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 51       	brne	80002310 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002308:	48 6c       	lddpc	r12,80002320 <ShutDown_brdcst_func+0x24>
8000230a:	f0 1f 00 07 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002310:	30 29       	mov	r9,2
80002312:	f2 08 18 00 	cp.b	r8,r9
80002316:	c0 41       	brne	8000231e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002318:	48 4c       	lddpc	r12,80002328 <ShutDown_brdcst_func+0x2c>
8000231a:	f0 1f 00 03 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000231e:	d8 02       	popm	pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	cc a4       	brge	800022b6 <ButtonConfig_reply_func+0x2e>
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	6a 38       	ld.w	r8,r5[0xc]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	cc b8       	rjmp	800024c0 <Volume_reply_func+0x24>

8000232c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
80002330:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002332:	19 a9       	ld.ub	r9,r12[0x2]
80002334:	30 08       	mov	r8,0
80002336:	f0 09 18 00 	cp.b	r9,r8
8000233a:	c0 61       	brne	80002346 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000233c:	48 dc       	lddpc	r12,80002370 <DataSession_reply_func+0x44>
8000233e:	f0 1f 00 0e 	mcall	80002374 <DataSession_reply_func+0x48>
80002342:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002346:	48 dc       	lddpc	r12,80002378 <DataSession_reply_func+0x4c>
80002348:	f0 1f 00 0b 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000234c:	0f a8       	ld.ub	r8,r7[0x2]
8000234e:	1a d8       	st.w	--sp,r8
80002350:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x50>
80002352:	f0 1f 00 09 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002356:	0f b8       	ld.ub	r8,r7[0x3]
80002358:	1a d8       	st.w	--sp,r8
8000235a:	48 ac       	lddpc	r12,80002380 <DataSession_reply_func+0x54>
8000235c:	f0 1f 00 06 	mcall	80002374 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002360:	0f c8       	ld.ub	r8,r7[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <DataSession_reply_func+0x58>
80002366:	f0 1f 00 04 	mcall	80002374 <DataSession_reply_func+0x48>
8000236a:	2f dd       	sub	sp,-12
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	cc c8       	rjmp	8000250a <spk_brdcst_func+0xa>
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	6a 38       	ld.w	r8,r5[0xc]
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	cc d8       	rjmp	80002514 <spk_brdcst_func+0x14>
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	cc e8       	rjmp	8000251a <spk_brdcst_func+0x1a>
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	cc f8       	rjmp	80002520 <spk_brdcst_func+0x20>
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	cd 04       	brge	80002326 <ShutDown_brdcst_func+0x2a>

80002388 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002388:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000238c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002390:	0f 98       	ld.ub	r8,r7[0x1]
80002392:	1a d8       	st.w	--sp,r8
80002394:	48 bc       	lddpc	r12,800023c0 <CallControl_brdcst_func+0x38>
80002396:	f0 1f 00 0c 	mcall	800023c4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000239a:	2f fd       	sub	sp,-4
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 38       	mov	r8,3
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023a6:	30 09       	mov	r9,0
800023a8:	48 88       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023ac:	0f 99       	ld.ub	r9,r7[0x1]
800023ae:	30 48       	mov	r8,4
800023b0:	f0 09 18 00 	cp.b	r9,r8
800023b4:	c0 41       	brne	800023bc <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023b6:	30 19       	mov	r9,1
800023b8:	48 48       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023ba:	b0 89       	st.b	r8[0x0],r9
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	cd 10       	breq	80002364 <DataSession_reply_func+0x38>
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	6a 38       	ld.w	r8,r5[0xc]
800023c8:	00 00       	add	r0,r0
800023ca:	0a 42       	or	r2,r5

800023cc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023d0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023d4:	0f 99       	ld.ub	r9,r7[0x1]
800023d6:	30 08       	mov	r8,0
800023d8:	f0 09 18 00 	cp.b	r9,r8
800023dc:	c0 71       	brne	800023ea <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023de:	48 ac       	lddpc	r12,80002404 <TransmitControl_brdcst_func+0x38>
800023e0:	f0 1f 00 0a 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023e4:	30 09       	mov	r9,0
800023e6:	48 a8       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023e8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ea:	0f 99       	ld.ub	r9,r7[0x1]
800023ec:	30 18       	mov	r8,1
800023ee:	f0 09 18 00 	cp.b	r9,r8
800023f2:	c0 71       	brne	80002400 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023f4:	48 7c       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x44>
800023f6:	f0 1f 00 05 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023fa:	30 19       	mov	r9,1
800023fc:	48 48       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023fe:	b0 89       	st.b	r8[0x0],r9
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	cd 28       	rjmp	800025aa <mic_brdcst_func+0x2a>
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	6a 38       	ld.w	r8,r5[0xc]
8000240c:	00 00       	add	r0,r0
8000240e:	0a 41       	or	r1,r5
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	cd 40       	breq	800023ba <CallControl_brdcst_func+0x32>

80002414 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002418:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000241c:	0f 89       	ld.ub	r9,r7[0x0]
8000241e:	30 08       	mov	r8,0
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c1 61       	brne	80002450 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002426:	48 ec       	lddpc	r12,8000245c <TransmitControl_reply_func+0x48>
80002428:	f0 1f 00 0e 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000242c:	0f 98       	ld.ub	r8,r7[0x1]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	48 dc       	lddpc	r12,80002464 <TransmitControl_reply_func+0x50>
80002432:	f0 1f 00 0c 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002436:	0f a8       	ld.ub	r8,r7[0x2]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	48 cc       	lddpc	r12,80002468 <TransmitControl_reply_func+0x54>
8000243c:	f0 1f 00 09 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002440:	0f b8       	ld.ub	r8,r7[0x3]
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 ac       	lddpc	r12,8000246c <TransmitControl_reply_func+0x58>
80002446:	f0 1f 00 07 	mcall	80002460 <TransmitControl_reply_func+0x4c>
8000244a:	2f dd       	sub	sp,-12
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002450:	48 8c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x5c>
80002452:	f0 1f 00 04 	mcall	80002460 <TransmitControl_reply_func+0x4c>
80002456:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	cd 54       	brge	80002408 <TransmitControl_brdcst_func+0x3c>
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	6a 38       	ld.w	r8,r5[0xc]
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	cd 70       	breq	80002414 <TransmitControl_reply_func>
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	cd 84       	brge	8000241a <TransmitControl_reply_func+0x6>
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	cd a0       	breq	80002422 <TransmitControl_reply_func+0xe>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	cd b0       	breq	80002428 <TransmitControl_reply_func+0x14>

80002474 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002474:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002476:	19 a9       	ld.ub	r9,r12[0x2]
80002478:	30 08       	mov	r8,0
8000247a:	f0 09 18 00 	cp.b	r9,r8
8000247e:	c0 51       	brne	80002488 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x1c>
80002482:	f0 1f 00 05 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002488:	48 4c       	lddpc	r12,80002498 <AudioRoutingControl_reply_func+0x24>
8000248a:	f0 1f 00 03 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
8000248e:	d8 02       	popm	pc
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	cd c8       	rjmp	8000264a <mic_reply_func+0x72>
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	6a 38       	ld.w	r8,r5[0xc]
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	cd d8       	rjmp	80002654 <mic_reply_func+0x7c>

8000249c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024a4:	0f 89       	ld.ub	r9,r7[0x0]
800024a6:	30 08       	mov	r8,0
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c1 b1       	brne	800024e2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ae:	0f b8       	ld.ub	r8,r7[0x3]
800024b0:	31 09       	mov	r9,16
800024b2:	f2 08 18 00 	cp.b	r8,r9
800024b6:	c0 f1       	brne	800024d4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b8:	48 dc       	lddpc	r12,800024ec <Volume_reply_func+0x50>
800024ba:	f0 1f 00 0e 	mcall	800024f0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024be:	0f 99       	ld.ub	r9,r7[0x1]
800024c0:	0f a8       	ld.ub	r8,r7[0x2]
800024c2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 bc       	lddpc	r12,800024f4 <Volume_reply_func+0x58>
800024ca:	f0 1f 00 0a 	mcall	800024f0 <Volume_reply_func+0x54>
800024ce:	2f fd       	sub	sp,-4
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024d4:	1a d8       	st.w	--sp,r8
800024d6:	48 9c       	lddpc	r12,800024f8 <Volume_reply_func+0x5c>
800024d8:	f0 1f 00 06 	mcall	800024f0 <Volume_reply_func+0x54>
800024dc:	2f fd       	sub	sp,-4
800024de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024e2:	48 7c       	lddpc	r12,800024fc <Volume_reply_func+0x60>
800024e4:	f0 1f 00 03 	mcall	800024f0 <Volume_reply_func+0x54>
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	cd ec       	rcall	800026aa <dcm_brdcst_func+0x3e>
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	6a 38       	ld.w	r8,r5[0xc]
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	ce 00       	breq	800024b6 <Volume_reply_func+0x1a>
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	ce 1c       	rcall	800026bc <dcm_reply_func+0x8>
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	ce 34       	brge	800024c4 <Volume_reply_func+0x28>

80002500 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002502:	19 d9       	ld.ub	r9,r12[0x5]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 81       	brne	8000251a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000250c:	10 99       	mov	r9,r8
8000250e:	48 78       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
80002510:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002512:	48 7c       	lddpc	r12,8000252c <spk_brdcst_func+0x2c>
80002514:	f0 1f 00 07 	mcall	80002530 <spk_brdcst_func+0x30>
80002518:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000251a:	30 19       	mov	r9,1
8000251c:	48 38       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
8000251e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002520:	48 5c       	lddpc	r12,80002534 <spk_brdcst_func+0x34>
80002522:	f0 1f 00 04 	mcall	80002530 <spk_brdcst_func+0x30>
80002526:	d8 02       	popm	pc
80002528:	00 00       	add	r0,r0
8000252a:	0a 38       	cp.w	r8,r5
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	ce 4c       	rcall	800026f6 <dcm_reply_func+0x42>
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	6a 38       	ld.w	r8,r5[0xc]
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	ce 5c       	rcall	80002700 <dcm_reply_func+0x4c>

80002538 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000253a:	19 a9       	ld.ub	r9,r12[0x2]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 f1       	brne	80002560 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002544:	19 e9       	ld.ub	r9,r12[0x6]
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 40       	breq	80002552 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000254c:	30 19       	mov	r9,1
8000254e:	48 98       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002550:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002552:	19 e8       	ld.ub	r8,r12[0x6]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <spk_reply_func+0x3c>
80002558:	f0 1f 00 08 	mcall	80002578 <spk_reply_func+0x40>
8000255c:	2f fd       	sub	sp,-4
8000255e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 48       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002564:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002566:	48 6c       	lddpc	r12,8000257c <spk_reply_func+0x44>
80002568:	f0 1f 00 04 	mcall	80002578 <spk_reply_func+0x40>
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	00 00       	add	r0,r0
80002572:	0a 38       	cp.w	r8,r5
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	ce 68       	rjmp	80002742 <ToneControl_reply_func+0x26>
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	6a 38       	ld.w	r8,r5[0xc]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	ce 78       	rjmp	8000274c <app_init+0x8>

80002580 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002588:	0f a9       	ld.ub	r9,r7[0x2]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 71       	brne	8000259e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002592:	48 dc       	lddpc	r12,800025c4 <mic_brdcst_func+0x44>
80002594:	f0 1f 00 0d 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002598:	30 09       	mov	r9,0
8000259a:	48 d8       	lddpc	r8,800025cc <mic_brdcst_func+0x4c>
8000259c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000259e:	0f a9       	ld.ub	r9,r7[0x2]
800025a0:	31 18       	mov	r8,17
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 d1       	brne	800025c0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a8:	48 ac       	lddpc	r12,800025d0 <mic_brdcst_func+0x50>
800025aa:	f0 1f 00 08 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ae:	48 89       	lddpc	r9,800025cc <mic_brdcst_func+0x4c>
800025b0:	30 18       	mov	r8,1
800025b2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025b4:	13 89       	ld.ub	r9,r9[0x0]
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 31       	brne	800025c0 <mic_brdcst_func+0x40>
800025bc:	48 68       	lddpc	r8,800025d4 <mic_brdcst_func+0x54>
800025be:	11 88       	ld.ub	r8,r8[0x0]
800025c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	ce 84       	brge	80002596 <mic_brdcst_func+0x16>
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	6a 38       	ld.w	r8,r5[0xc]
800025cc:	00 00       	add	r0,r0
800025ce:	0a 46       	or	r6,r5
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	ce 98       	rjmp	800027a4 <app_init+0x60>
800025d4:	00 00       	add	r0,r0
800025d6:	0a 42       	or	r2,r5

800025d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025e0:	49 ac       	lddpc	r12,80002648 <mic_reply_func+0x70>
800025e2:	f0 1f 00 1b 	mcall	8000264c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025e6:	0f 89       	ld.ub	r9,r7[0x0]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c2 71       	brne	8000263c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025f0:	0f 98       	ld.ub	r8,r7[0x1]
800025f2:	30 29       	mov	r9,2
800025f4:	f2 08 18 00 	cp.b	r8,r9
800025f8:	c1 b1       	brne	8000262e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025fa:	49 6c       	lddpc	r12,80002650 <mic_reply_func+0x78>
800025fc:	f0 1f 00 14 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002600:	0f a8       	ld.ub	r8,r7[0x2]
80002602:	1a d8       	st.w	--sp,r8
80002604:	49 4c       	lddpc	r12,80002654 <mic_reply_func+0x7c>
80002606:	f0 1f 00 12 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000260a:	0f b8       	ld.ub	r8,r7[0x3]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	49 3c       	lddpc	r12,80002658 <mic_reply_func+0x80>
80002610:	f0 1f 00 0f 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002614:	0f c8       	ld.ub	r8,r7[0x4]
80002616:	1a d8       	st.w	--sp,r8
80002618:	49 1c       	lddpc	r12,8000265c <mic_reply_func+0x84>
8000261a:	f0 1f 00 0d 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000261e:	0f d8       	ld.ub	r8,r7[0x5]
80002620:	1a d8       	st.w	--sp,r8
80002622:	49 0c       	lddpc	r12,80002660 <mic_reply_func+0x88>
80002624:	f0 1f 00 0a 	mcall	8000264c <mic_reply_func+0x74>
80002628:	2f cd       	sub	sp,-16
8000262a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000262e:	1a d8       	st.w	--sp,r8
80002630:	48 dc       	lddpc	r12,80002664 <mic_reply_func+0x8c>
80002632:	f0 1f 00 07 	mcall	8000264c <mic_reply_func+0x74>
80002636:	2f fd       	sub	sp,-4
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000263c:	48 bc       	lddpc	r12,80002668 <mic_reply_func+0x90>
8000263e:	f0 1f 00 04 	mcall	8000264c <mic_reply_func+0x74>
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	ce ac       	rcall	8000281e <app_cfg+0x62>
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	6a 38       	ld.w	r8,r5[0xc]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	ce bc       	rcall	80002828 <app_cfg+0x6c>
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	ce d0       	breq	80002630 <mic_reply_func+0x58>
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	ce e4       	brge	80002636 <mic_reply_func+0x5e>
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	cf 00       	breq	8000263e <mic_reply_func+0x66>
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	cf 18       	rjmp	80002844 <app_cfg+0x88>
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	cf 30       	breq	8000264c <mic_reply_func+0x74>
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	cf 48       	rjmp	80002852 <app_cfg+0x96>

8000266c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002674:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x34>
80002676:	f0 1f 00 0c 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000267a:	0f 88       	ld.ub	r8,r7[0x0]
8000267c:	1a d8       	st.w	--sp,r8
8000267e:	48 bc       	lddpc	r12,800026a8 <dcm_brdcst_func+0x3c>
80002680:	f0 1f 00 09 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 9c       	lddpc	r12,800026ac <dcm_brdcst_func+0x40>
8000268a:	f0 1f 00 07 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000268e:	0f 98       	ld.ub	r8,r7[0x1]
80002690:	1a d8       	st.w	--sp,r8
80002692:	48 8c       	lddpc	r12,800026b0 <dcm_brdcst_func+0x44>
80002694:	f0 1f 00 04 	mcall	800026a4 <dcm_brdcst_func+0x38>
80002698:	2f dd       	sub	sp,-12
	
	
}
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	cf 58       	rjmp	8000288c <app_cfg+0xd0>
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	6a 38       	ld.w	r8,r5[0xc]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	cf 6c       	rcall	80002896 <app_cfg+0xda>
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	cf 80       	breq	8000269e <dcm_brdcst_func+0x32>
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	cf 98       	rjmp	800028a4 <app_cfg+0xe8>

800026b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026b4:	eb cd 40 80 	pushm	r7,lr
800026b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026ba:	19 a9       	ld.ub	r9,r12[0x2]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c1 b1       	brne	800026f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026c4:	19 b8       	ld.ub	r8,r12[0x3]
800026c6:	30 19       	mov	r9,1
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c0 51       	brne	800026d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ce:	48 ec       	lddpc	r12,80002704 <dcm_reply_func+0x50>
800026d0:	f0 1f 00 0e 	mcall	80002708 <dcm_reply_func+0x54>
800026d4:	c0 a8       	rjmp	800026e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026d6:	58 08       	cp.w	r8,0
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026da:	48 dc       	lddpc	r12,8000270c <dcm_reply_func+0x58>
800026dc:	f0 1f 00 0b 	mcall	80002708 <dcm_reply_func+0x54>
800026e0:	c0 48       	rjmp	800026e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026e2:	48 cc       	lddpc	r12,80002710 <dcm_reply_func+0x5c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e8:	0f d8       	ld.ub	r8,r7[0x5]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 ac       	lddpc	r12,80002714 <dcm_reply_func+0x60>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_reply_func+0x54>
800026f2:	2f fd       	sub	sp,-4
800026f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f8:	48 8c       	lddpc	r12,80002718 <dcm_reply_func+0x64>
800026fa:	f0 1f 00 04 	mcall	80002708 <dcm_reply_func+0x54>
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	cf b4       	brge	800026fc <dcm_reply_func+0x48>
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	6a 38       	ld.w	r8,r5[0xc]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	cf c8       	rjmp	80002906 <DataSession_brdcst_func+0xa>
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	cf dc       	rcall	8000290c <DataSession_brdcst_func+0x10>
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	cf f0       	breq	80002714 <dcm_reply_func+0x60>
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	cf fc       	rcall	80002918 <DataSession_brdcst_func+0x1c>

8000271c <ToneControl_reply_func>:
			//log("Device State : %d\n", ptr->Device_State);
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000271c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c0 51       	brne	80002730 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x1c>
8000272a:	f0 1f 00 05 	mcall	8000273c <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002730:	48 4c       	lddpc	r12,80002740 <ToneControl_reply_func+0x24>
80002732:	f0 1f 00 03 	mcall	8000273c <ToneControl_reply_func+0x20>
80002736:	d8 02       	popm	pc
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d0 08       	*unknown*
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	6a 38       	ld.w	r8,r5[0xc]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	d0 14       	*unknown*

80002744 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002744:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002746:	49 1c       	lddpc	r12,80002788 <app_init+0x44>
80002748:	f0 1f 00 11 	mcall	8000278c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000274c:	49 1b       	lddpc	r11,80002790 <app_init+0x4c>
8000274e:	49 2c       	lddpc	r12,80002794 <app_init+0x50>
80002750:	f0 1f 00 12 	mcall	80002798 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002754:	f0 1f 00 12 	mcall	8000279c <app_init+0x58>
80002758:	49 28       	lddpc	r8,800027a0 <app_init+0x5c>
8000275a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000275c:	70 08       	ld.w	r8,r8[0x0]
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 41       	brne	80002768 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002762:	49 1c       	lddpc	r12,800027a4 <app_init+0x60>
80002764:	f0 1f 00 11 	mcall	800027a8 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002768:	30 09       	mov	r9,0
8000276a:	1a d9       	st.w	--sp,r9
8000276c:	1a d9       	st.w	--sp,r9
8000276e:	1a d9       	st.w	--sp,r9
80002770:	30 18       	mov	r8,1
80002772:	e0 6a 03 20 	mov	r10,800
80002776:	48 eb       	lddpc	r11,800027ac <app_init+0x68>
80002778:	48 ec       	lddpc	r12,800027b0 <app_init+0x6c>
8000277a:	f0 1f 00 0f 	mcall	800027b4 <app_init+0x70>
8000277e:	48 f8       	lddpc	r8,800027b8 <app_init+0x74>
80002780:	91 0c       	st.w	r8[0x0],r12
80002782:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002784:	d8 02       	popm	pc
80002786:	00 00       	add	r0,r0
80002788:	00 00       	add	r0,r0
8000278a:	00 08       	add	r8,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	3d b4       	mov	r4,-37
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	20 58       	sub	r8,5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 6c       	sub	r12,6
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	2a 64       	sub	r4,-90
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	5f 00       	sreq	r0
800027a0:	00 00       	add	r0,r0
800027a2:	0a 4c       	or	r12,r5
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d0 20       	acall	0x2
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	6a 38       	ld.w	r8,r5[0xc]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d0 4c       	*unknown*
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	27 bc       	sub	r12,123
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	66 74       	ld.w	r4,r3[0x1c]
800027b8:	00 00       	add	r0,r0
800027ba:	0a 3c       	cp.w	r12,r5

800027bc <app_cfg>:
extern void xnl_send_device_master_query(void);
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
800027be:	21 4d       	sub	sp,80
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c0:	31 4c       	mov	r12,20
800027c2:	f0 1f 00 3b 	mcall	800028ac <app_cfg+0xf0>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027c6:	f0 1f 00 3b 	mcall	800028b0 <app_cfg+0xf4>
800027ca:	4b b8       	lddpc	r8,800028b4 <app_cfg+0xf8>
800027cc:	91 0c       	st.w	r8[0x0],r12
	
	static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	char str[80];
	memset(str, 0x00, 80);
800027ce:	35 0a       	mov	r10,80
800027d0:	30 0b       	mov	r11,0
800027d2:	1a 9c       	mov	r12,sp
800027d4:	f0 1f 00 39 	mcall	800028b8 <app_cfg+0xfc>
	
	/* 'Give' the semaphore to unblock the task. */
	 //if( xBinarySemaphore != NULL ){
		//xSemaphoreGive(xBinarySemaphore);
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
800027d8:	4b 98       	lddpc	r8,800028bc <app_cfg+0x100>
800027da:	70 0c       	ld.w	r12,r8[0x0]
800027dc:	30 09       	mov	r9,0
800027de:	3f fa       	mov	r10,-1
800027e0:	12 9b       	mov	r11,r9
800027e2:	f0 1f 00 38 	mcall	800028c0 <app_cfg+0x104>
		
	for(;;)
	{
		switch(OB_State)
800027e6:	4b 86       	lddpc	r6,800028c4 <app_cfg+0x108>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027e8:	4b 85       	lddpc	r5,800028c8 <app_cfg+0x10c>
					nop();
					nop();
					nop();
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
					log("connecting...\n");
800027ea:	4b 91       	lddpc	r1,800028cc <app_cfg+0x110>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027ec:	4b 27       	lddpc	r7,800028b4 <app_cfg+0xf8>
800027ee:	e0 60 07 d0 	mov	r0,2000
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	4b 82       	lddpc	r2,800028d0 <app_cfg+0x114>
				{
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027f4:	30 c3       	mov	r3,12
800027f6:	30 14       	mov	r4,1
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
		
	for(;;)
	{
		switch(OB_State)
800027f8:	6c 08       	ld.w	r8,r6[0x0]
800027fa:	58 08       	cp.w	r8,0
800027fc:	c0 40       	breq	80002804 <app_cfg+0x48>
800027fe:	58 38       	cp.w	r8,3
80002800:	c5 01       	brne	800028a0 <app_cfg+0xe4>
80002802:	c3 a8       	rjmp	80002876 <app_cfg+0xba>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002804:	6a 08       	ld.w	r8,r5[0x0]
80002806:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000280a:	58 38       	cp.w	r8,3
8000280c:	c2 81       	brne	8000285c <app_cfg+0xa0>
8000280e:	05 88       	ld.ub	r8,r2[0x0]
80002810:	58 08       	cp.w	r8,0
80002812:	c2 51       	brne	8000285c <app_cfg+0xa0>
				{
					connect_flag=1;
80002814:	30 18       	mov	r8,1
80002816:	a4 88       	st.b	r2[0x0],r8
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002818:	06 9b       	mov	r11,r3
8000281a:	08 9c       	mov	r12,r4
8000281c:	f0 1f 00 2e 	mcall	800028d4 <app_cfg+0x118>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002820:	06 9b       	mov	r11,r3
80002822:	08 9c       	mov	r12,r4
80002824:	f0 1f 00 2c 	mcall	800028d4 <app_cfg+0x118>
					OB_State = OB_WAITINGAPPTASK;
80002828:	30 38       	mov	r8,3
8000282a:	8d 08       	st.w	r6[0x0],r8
					log("connect OB okay!\n");
8000282c:	4a bc       	lddpc	r12,800028d8 <app_cfg+0x11c>
8000282e:	f0 1f 00 2c 	mcall	800028dc <app_cfg+0x120>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
													 XCMP_Version[2],  XCMP_Version[3]);
80002832:	4a c8       	lddpc	r8,800028e0 <app_cfg+0x124>
80002834:	11 bb       	ld.ub	r11,r8[0x3]
80002836:	11 aa       	ld.ub	r10,r8[0x2]
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
80002838:	11 99       	ld.ub	r9,r8[0x1]
8000283a:	11 88       	ld.ub	r8,r8[0x0]
8000283c:	1a db       	st.w	--sp,r11
8000283e:	1a da       	st.w	--sp,r10
80002840:	1a d9       	st.w	--sp,r9
80002842:	1a d8       	st.w	--sp,r8
80002844:	4a 8c       	lddpc	r12,800028e4 <app_cfg+0x128>
80002846:	f0 1f 00 26 	mcall	800028dc <app_cfg+0x120>
													 XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);							 
8000284a:	1a d4       	st.w	--sp,r4
8000284c:	1a d4       	st.w	--sp,r4
8000284e:	30 28       	mov	r8,2
80002850:	1a d8       	st.w	--sp,r8
80002852:	4a 6c       	lddpc	r12,800028e8 <app_cfg+0x12c>
80002854:	f0 1f 00 22 	mcall	800028dc <app_cfg+0x120>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002858:	2f 9d       	sub	sp,-28
8000285a:	c2 38       	rjmp	800028a0 <app_cfg+0xe4>
													 XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);							 
				}
				else
				{
					nop();
8000285c:	d7 03       	nop
					nop();
8000285e:	d7 03       	nop
					nop();
80002860:	d7 03       	nop
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
80002862:	f0 1f 00 23 	mcall	800028ec <app_cfg+0x130>
					log("connecting...\n");
80002866:	02 9c       	mov	r12,r1
80002868:	f0 1f 00 1d 	mcall	800028dc <app_cfg+0x120>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000286c:	00 9b       	mov	r11,r0
8000286e:	0e 9c       	mov	r12,r7
80002870:	f0 1f 00 20 	mcall	800028f0 <app_cfg+0x134>
80002874:	c1 68       	rjmp	800028a0 <app_cfg+0xe4>
							//}
						//
						//}
					}
					
					if (0x00000003 != (bunchofrandomstatusflags & 0x00000003))//掉线
80002876:	6a 08       	ld.w	r8,r5[0x0]
80002878:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000287c:	58 38       	cp.w	r8,3
8000287e:	c0 70       	breq	8000288c <app_cfg+0xd0>
					{					
						OB_State = OB_UNCONNECTEDWAITINGSTATUS;
80002880:	30 08       	mov	r8,0
80002882:	8d 08       	st.w	r6[0x0],r8
						connect_flag=0;
80002884:	a4 88       	st.b	r2[0x0],r8
						log("OB disconnecting!!!\n");
80002886:	49 cc       	lddpc	r12,800028f4 <app_cfg+0x138>
80002888:	f0 1f 00 15 	mcall	800028dc <app_cfg+0x120>
					}
					
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000288c:	06 9b       	mov	r11,r3
8000288e:	08 9c       	mov	r12,r4
80002890:	f0 1f 00 11 	mcall	800028d4 <app_cfg+0x118>
								//log("str[%d]: %x\n", i, str[i]);
							//}
							//memset(str, 0x00, 80);
						//}
					//}
					nop();
80002894:	d7 03       	nop
					nop();						
80002896:	d7 03       	nop
					nop();
80002898:	d7 03       	nop
					log("app task run!\n");
8000289a:	49 8c       	lddpc	r12,800028f8 <app_cfg+0x13c>
8000289c:	f0 1f 00 10 	mcall	800028dc <app_cfg+0x120>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800028a0:	e0 6b 0f a0 	mov	r11,4000
800028a4:	0e 9c       	mov	r12,r7
800028a6:	f0 1f 00 13 	mcall	800028f0 <app_cfg+0x134>
	}
800028aa:	ca 7b       	rjmp	800027f8 <app_cfg+0x3c>
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	5a ac       	cp.w	r12,-22
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	63 64       	ld.w	r4,r1[0x58]
800028b4:	00 00       	add	r0,r0
800028b6:	0a 50       	eor	r0,r5
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	73 f4       	ld.w	r4,r9[0x7c]
800028bc:	00 00       	add	r0,r0
800028be:	0b 54       	ld.sh	r4,--r5
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	5b f4       	cp.w	r4,-1
800028c4:	00 00       	add	r0,r0
800028c6:	0a 48       	or	r8,r5
800028c8:	00 00       	add	r0,r0
800028ca:	0d 7c       	ld.ub	r12,--r6
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	d0 a4       	*unknown*
800028d0:	00 00       	add	r0,r0
800028d2:	0a 45       	or	r5,r5
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	3f 4c       	mov	r12,-12
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	d0 54       	*unknown*
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	6a 38       	ld.w	r8,r5[0xc]
800028e0:	00 00       	add	r0,r0
800028e2:	0d 78       	ld.ub	r8,--r6
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	d0 68       	*unknown*
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	d0 84       	*unknown*
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	46 f8       	lddsp	r8,sp[0x1bc]
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	65 14       	ld.w	r4,r2[0x44]
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	d0 b4       	*unknown*
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	d0 cc       	*unknown*

800028fc <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028fc:	d4 21       	pushm	r4-r7,lr
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028fe:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002902:	0d 88       	ld.ub	r8,r6[0x0]
80002904:	32 49       	mov	r9,36
80002906:	f2 08 18 00 	cp.b	r8,r9
8000290a:	c2 91       	brne	8000295c <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000290c:	49 dc       	lddpc	r12,80002980 <DataSession_brdcst_func+0x84>
8000290e:	f0 1f 00 1e 	mcall	80002984 <DataSession_brdcst_func+0x88>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002912:	0d a5       	ld.ub	r5,r6[0x2]
80002914:	0d b8       	ld.ub	r8,r6[0x3]
80002916:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000291a:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000291c:	0d 98       	ld.ub	r8,r6[0x1]
8000291e:	1a d8       	st.w	--sp,r8
80002920:	49 ac       	lddpc	r12,80002988 <DataSession_brdcst_func+0x8c>
80002922:	f0 1f 00 19 	mcall	80002984 <DataSession_brdcst_func+0x88>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002926:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000292a:	1a d8       	st.w	--sp,r8
8000292c:	49 8c       	lddpc	r12,8000298c <DataSession_brdcst_func+0x90>
8000292e:	f0 1f 00 16 	mcall	80002984 <DataSession_brdcst_func+0x88>
		for(i=0; i<data_length; i++)
80002932:	2f ed       	sub	sp,-8
80002934:	58 05       	cp.w	r5,0
80002936:	c2 40       	breq	8000297e <DataSession_brdcst_func+0x82>
80002938:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000293a:	49 64       	lddpc	r4,80002990 <DataSession_brdcst_func+0x94>
8000293c:	ec 07 00 08 	add	r8,r6,r7
80002940:	11 c8       	ld.ub	r8,r8[0x4]
80002942:	1a d8       	st.w	--sp,r8
80002944:	1a d7       	st.w	--sp,r7
80002946:	08 9c       	mov	r12,r4
80002948:	f0 1f 00 0f 	mcall	80002984 <DataSession_brdcst_func+0x88>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000294c:	2f f7       	sub	r7,-1
8000294e:	5c 57       	castu.b	r7
80002950:	2f ed       	sub	sp,-8
80002952:	ee 05 19 00 	cp.h	r5,r7
80002956:	fe 9b ff f3 	brhi	8000293c <DataSession_brdcst_func+0x40>
8000295a:	d8 22       	popm	r4-r7,pc
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
8000295c:	1a d8       	st.w	--sp,r8
8000295e:	48 ec       	lddpc	r12,80002994 <DataSession_brdcst_func+0x98>
80002960:	f0 1f 00 09 	mcall	80002984 <DataSession_brdcst_func+0x88>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002964:	2f fd       	sub	sp,-4
80002966:	0d 89       	ld.ub	r9,r6[0x0]
80002968:	30 38       	mov	r8,3
8000296a:	f0 09 18 00 	cp.b	r9,r8
8000296e:	c0 81       	brne	8000297e <DataSession_brdcst_func+0x82>
		{
			log("data transmit success\n");
80002970:	48 ac       	lddpc	r12,80002998 <DataSession_brdcst_func+0x9c>
80002972:	f0 1f 00 05 	mcall	80002984 <DataSession_brdcst_func+0x88>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002976:	e0 6c 07 d0 	mov	r12,2000
8000297a:	f0 1f 00 09 	mcall	8000299c <DataSession_brdcst_func+0xa0>
8000297e:	d8 22       	popm	r4-r7,pc
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	d0 dc       	*unknown*
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	6a 38       	ld.w	r8,r5[0xc]
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	d0 f0       	acall	0xf
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	d1 08       	*unknown*
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	d1 24       	*unknown*
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	d1 3c       	*unknown*
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	d1 48       	*unknown*
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	64 cc       	ld.w	r12,r2[0x30]

800029a0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800029a0:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800029a4:	19 c7       	ld.ub	r7,r12[0x4]
800029a6:	19 d8       	ld.ub	r8,r12[0x5]
800029a8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800029ac:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800029ae:	48 dc       	lddpc	r12,800029e0 <Phyuserinput_brdcst_func+0x40>
800029b0:	f0 1f 00 0d 	mcall	800029e4 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800029b4:	36 08       	mov	r8,96
800029b6:	f0 07 19 00 	cp.h	r7,r8
800029ba:	c1 11       	brne	800029dc <Phyuserinput_brdcst_func+0x3c>
800029bc:	48 b8       	lddpc	r8,800029e8 <Phyuserinput_brdcst_func+0x48>
800029be:	11 89       	ld.ub	r9,r8[0x0]
800029c0:	30 18       	mov	r8,1
800029c2:	f0 09 18 00 	cp.b	r9,r8
800029c6:	c0 b1       	brne	800029dc <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
800029c8:	34 5b       	mov	r11,69
800029ca:	30 1c       	mov	r12,1
800029cc:	f0 1f 00 08 	mcall	800029ec <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(100*2 / portTICK_RATE_MS);//延迟100ms
800029d0:	e0 6c 00 c8 	mov	r12,200
800029d4:	f0 1f 00 07 	mcall	800029f0 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message	
800029d8:	f0 1f 00 07 	mcall	800029f4 <Phyuserinput_brdcst_func+0x54>
800029dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	d1 60       	acall	0x16
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	6a 38       	ld.w	r8,r5[0xc]
800029e8:	00 00       	add	r0,r0
800029ea:	0a 45       	or	r5,r5
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	3f 4c       	mov	r12,-12
800029f0:	80 00       	ld.sh	r0,r0[0x0]
800029f2:	64 cc       	ld.w	r12,r2[0x30]
800029f4:	80 00       	ld.sh	r0,r0[0x0]
800029f6:	4d f8       	lddpc	r8,80002b70 <get_idle_store_isr+0x10>

800029f8 <DeviceInitializationStatus_brdcst_func>:
//xnl_content_master_status_brdcst_t XCMP_Version;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t *ptr = (DeviceInitializationStatus_brdcst_t* )xcmp->u8;
800029fc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	//log("DeviceInitializationStatus_brdcst...\n");
	
	memcpy(XCMP_Version, &(ptr->XCMPVersion[0]), sizeof(XCMP_Version));
80002a00:	30 4a       	mov	r10,4
80002a02:	0e 9b       	mov	r11,r7
80002a04:	48 dc       	lddpc	r12,80002a38 <DeviceInitializationStatus_brdcst_func+0x40>
80002a06:	f0 1f 00 0e 	mcall	80002a3c <DeviceInitializationStatus_brdcst_func+0x44>
	
	if (ptr->DeviceInitType == Device_Init_Complete)
80002a0a:	0f c8       	ld.ub	r8,r7[0x4]
80002a0c:	30 19       	mov	r9,1
80002a0e:	f2 08 18 00 	cp.b	r8,r9
80002a12:	c0 71       	brne	80002a20 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a14:	48 b8       	lddpc	r8,80002a40 <DeviceInitializationStatus_brdcst_func+0x48>
80002a16:	70 09       	ld.w	r9,r8[0x0]
80002a18:	a1 a9       	sbr	r9,0x0
80002a1a:	91 09       	st.w	r8[0x0],r9
80002a1c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else if(ptr->DeviceInitType  == Device_Init_Status)
80002a20:	58 08       	cp.w	r8,0
80002a22:	c0 81       	brne	80002a32 <DeviceInitializationStatus_brdcst_func+0x3a>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a24:	48 78       	lddpc	r8,80002a40 <DeviceInitializationStatus_brdcst_func+0x48>
80002a26:	70 09       	ld.w	r9,r8[0x0]
80002a28:	e0 19 ff fc 	andl	r9,0xfffc
80002a2c:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a2e:	f0 1f 00 06 	mcall	80002a44 <DeviceInitializationStatus_brdcst_func+0x4c>
80002a32:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a36:	00 00       	add	r0,r0
80002a38:	00 00       	add	r0,r0
80002a3a:	0d 78       	ld.ub	r8,--r6
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	72 ac       	ld.w	r12,r9[0x28]
80002a40:	00 00       	add	r0,r0
80002a42:	0d 7c       	ld.ub	r12,--r6
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	3e 98       	mov	r8,-23

80002a48 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002a48:	20 1c       	sub	r12,1
80002a4a:	5c 5c       	castu.b	r12
80002a4c:	31 18       	mov	r8,17
80002a4e:	f0 0c 18 00 	cp.b	r12,r8
80002a52:	e0 88 00 03 	brls	80002a58 <CalculateBurst+0x10>
80002a56:	5e fd       	retal	0
80002a58:	48 28       	lddpc	r8,80002a60 <CalculateBurst+0x18>
80002a5a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002a5e:	5e fc       	retal	r12
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	d1 80       	acall	0x18

80002a64 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002a64:	48 38       	lddpc	r8,80002a70 <payload_init+0xc>
80002a66:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002a68:	48 38       	lddpc	r8,80002a74 <payload_init+0x10>
80002a6a:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002a6c:	5e fc       	retal	r12
80002a6e:	00 00       	add	r0,r0
80002a70:	00 00       	add	r0,r0
80002a72:	0a 5c       	eor	r12,r5
80002a74:	00 00       	add	r0,r0
80002a76:	0a 60       	and	r0,r5

80002a78 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002a78:	d4 01       	pushm	lr
80002a7a:	20 2d       	sub	sp,8
80002a7c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a7e:	30 09       	mov	r9,0
80002a80:	fa ca ff f8 	sub	r10,sp,-8
80002a84:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a86:	1a 9b       	mov	r11,sp
80002a88:	f0 1f 00 02 	mcall	80002a90 <set_idle_store_isr+0x18>
}
80002a8c:	2f ed       	sub	sp,-8
80002a8e:	d8 02       	popm	pc
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	5d b0       	*unknown*

80002a94 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002a94:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002a96:	48 48       	lddpc	r8,80002aa4 <payload_rx+0x10>
80002a98:	70 08       	ld.w	r8,r8[0x0]
80002a9a:	18 9b       	mov	r11,r12
80002a9c:	10 9c       	mov	r12,r8
80002a9e:	f0 1f 00 03 	mcall	80002aa8 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002aa2:	d8 02       	popm	pc
80002aa4:	00 00       	add	r0,r0
80002aa6:	0a 98       	mov	r8,r5
80002aa8:	80 00       	ld.sh	r0,r0[0x0]
80002aaa:	2a 78       	sub	r8,-89

80002aac <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002aac:	d4 01       	pushm	lr
80002aae:	20 2d       	sub	sp,8
80002ab0:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002ab2:	58 0c       	cp.w	r12,0
80002ab4:	c1 10       	breq	80002ad6 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ab6:	30 08       	mov	r8,0
80002ab8:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002aba:	98 88       	ld.uh	r8,r12[0x0]
80002abc:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ac0:	e0 48 40 00 	cp.w	r8,16384
80002ac4:	c0 91       	brne	80002ad6 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002ac6:	48 68       	lddpc	r8,80002adc <phy_rx+0x30>
80002ac8:	70 0c       	ld.w	r12,r8[0x0]
80002aca:	30 09       	mov	r9,0
80002acc:	fa ca ff fc 	sub	r10,sp,-4
80002ad0:	1a 9b       	mov	r11,sp
80002ad2:	f0 1f 00 04 	mcall	80002ae0 <phy_rx+0x34>
		}	

    }
		
 
}
80002ad6:	2f ed       	sub	sp,-8
80002ad8:	d8 02       	popm	pc
80002ada:	00 00       	add	r0,r0
80002adc:	00 00       	add	r0,r0
80002ade:	0a a4       	st.w	r5++,r4
80002ae0:	80 00       	ld.sh	r0,r0[0x0]
80002ae2:	5d b0       	*unknown*

80002ae4 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002ae4:	eb cd 40 80 	pushm	r7,lr
80002ae8:	20 1d       	sub	sp,4
80002aea:	fa c7 ff fc 	sub	r7,sp,-4
80002aee:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002af0:	30 09       	mov	r9,0
80002af2:	12 9a       	mov	r10,r9
80002af4:	1a 9b       	mov	r11,sp
80002af6:	f0 1f 00 03 	mcall	80002b00 <set_idle_store+0x1c>
}
80002afa:	2f fd       	sub	sp,-4
80002afc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	5e 00       	reteq	r0

80002b04 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002b04:	d4 01       	pushm	lr
80002b06:	20 1d       	sub	sp,4
80002b08:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002b0a:	98 88       	ld.uh	r8,r12[0x0]
80002b0c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b10:	e0 48 40 00 	cp.w	r8,16384
80002b14:	c0 d1       	brne	80002b2e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b16:	49 08       	lddpc	r8,80002b54 <phy_tx+0x50>
80002b18:	70 08       	ld.w	r8,r8[0x0]
80002b1a:	58 08       	cp.w	r8,0
80002b1c:	c1 a0       	breq	80002b50 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002b1e:	48 e8       	lddpc	r8,80002b54 <phy_tx+0x50>
80002b20:	70 0c       	ld.w	r12,r8[0x0]
80002b22:	30 09       	mov	r9,0
80002b24:	12 9a       	mov	r10,r9
80002b26:	1a 9b       	mov	r11,sp
80002b28:	f0 1f 00 0c 	mcall	80002b58 <phy_tx+0x54>
80002b2c:	c1 28       	rjmp	80002b50 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002b2e:	e0 48 10 00 	cp.w	r8,4096
80002b32:	5f 0a       	sreq	r10
80002b34:	e0 48 20 00 	cp.w	r8,8192
80002b38:	5f 09       	sreq	r9
80002b3a:	f5 e9 10 09 	or	r9,r10,r9
80002b3e:	c0 71       	brne	80002b4c <phy_tx+0x48>
80002b40:	e0 48 50 00 	cp.w	r8,20480
80002b44:	c0 40       	breq	80002b4c <phy_tx+0x48>
80002b46:	e0 48 60 00 	cp.w	r8,24576
80002b4a:	c0 31       	brne	80002b50 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002b4c:	48 48       	lddpc	r8,80002b5c <phy_tx+0x58>
80002b4e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002b50:	2f fd       	sub	sp,-4
80002b52:	d8 02       	popm	pc
80002b54:	00 00       	add	r0,r0
80002b56:	0a c4       	st.b	r5++,r4
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	5e 00       	reteq	r0
80002b5c:	00 00       	add	r0,r0
80002b5e:	0a b8       	st.h	r5++,r8

80002b60 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002b60:	d4 01       	pushm	lr
80002b62:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002b64:	30 08       	mov	r8,0
80002b66:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b68:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002b6a:	1a 9a       	mov	r10,sp
80002b6c:	fa cb ff fc 	sub	r11,sp,-4
80002b70:	f0 1f 00 05 	mcall	80002b84 <get_idle_store_isr+0x24>
80002b74:	58 1c       	cp.w	r12,1
80002b76:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b7a:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002b7e:	2f ed       	sub	sp,-8
80002b80:	d8 02       	popm	pc
80002b82:	00 00       	add	r0,r0
80002b84:	80 00       	ld.sh	r0,r0[0x0]
80002b86:	5b 04       	cp.w	r4,-16

80002b88 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b88:	eb cd 40 c0 	pushm	r6-r7,lr
80002b8c:	20 1d       	sub	sp,4
80002b8e:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b90:	4b a8       	lddpc	r8,80002c78 <phy_tx_func+0xf0>
80002b92:	70 08       	ld.w	r8,r8[0x0]
80002b94:	58 08       	cp.w	r8,0
80002b96:	c6 60       	breq	80002c62 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b98:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b9a:	30 08       	mov	r8,0
80002b9c:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b9e:	4b 88       	lddpc	r8,80002c7c <phy_tx_func+0xf4>
80002ba0:	70 08       	ld.w	r8,r8[0x0]
80002ba2:	58 18       	cp.w	r8,1
80002ba4:	c2 60       	breq	80002bf0 <phy_tx_func+0x68>
80002ba6:	c0 43       	brcs	80002bae <phy_tx_func+0x26>
80002ba8:	58 28       	cp.w	r8,2
80002baa:	c5 c1       	brne	80002c62 <phy_tx_func+0xda>
80002bac:	c5 58       	rjmp	80002c56 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002bae:	4b 38       	lddpc	r8,80002c78 <phy_tx_func+0xf0>
80002bb0:	70 0c       	ld.w	r12,r8[0x0]
80002bb2:	1a 9a       	mov	r10,sp
80002bb4:	4b 3b       	lddpc	r11,80002c80 <phy_tx_func+0xf8>
80002bb6:	f0 1f 00 34 	mcall	80002c84 <phy_tx_func+0xfc>
80002bba:	58 1c       	cp.w	r12,1
80002bbc:	c1 41       	brne	80002be4 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002bbe:	4b 18       	lddpc	r8,80002c80 <phy_tx_func+0xf8>
80002bc0:	70 08       	ld.w	r8,r8[0x0]
80002bc2:	90 08       	ld.sh	r8,r8[0x0]
80002bc4:	10 9a       	mov	r10,r8
80002bc6:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002bca:	4b 09       	lddpc	r9,80002c88 <phy_tx_func+0x100>
80002bcc:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002bce:	5c 78       	castu.h	r8
80002bd0:	ea 18 ab cd 	orh	r8,0xabcd
80002bd4:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002bd6:	30 19       	mov	r9,1
80002bd8:	4a d8       	lddpc	r8,80002c8c <phy_tx_func+0x104>
80002bda:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002bdc:	30 19       	mov	r9,1
80002bde:	4a 88       	lddpc	r8,80002c7c <phy_tx_func+0xf4>
80002be0:	91 09       	st.w	r8[0x0],r9
80002be2:	c4 08       	rjmp	80002c62 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002be4:	e0 68 5a 5a 	mov	r8,23130
80002be8:	ea 18 ab cd 	orh	r8,0xabcd
80002bec:	8f 18       	st.w	r7[0x4],r8
80002bee:	c3 a8       	rjmp	80002c62 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002bf0:	4a 7a       	lddpc	r10,80002c8c <phy_tx_func+0x104>
80002bf2:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002bf4:	4a 39       	lddpc	r9,80002c80 <phy_tx_func+0xf8>
80002bf6:	72 09       	ld.w	r9,r9[0x0]
80002bf8:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002bfc:	b1 69       	lsl	r9,0x10
80002bfe:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c00:	2f f8       	sub	r8,-1
80002c02:	5c 58       	castu.b	r8
80002c04:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002c06:	4a 1b       	lddpc	r11,80002c88 <phy_tx_func+0x100>
80002c08:	96 0c       	ld.sh	r12,r11[0x0]
80002c0a:	20 2c       	sub	r12,2
80002c0c:	5c 8c       	casts.h	r12
80002c0e:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002c12:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c14:	30 0b       	mov	r11,0
80002c16:	f6 0a 19 00 	cp.h	r10,r11
80002c1a:	e0 89 00 09 	brgt	80002c2c <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002c1e:	e8 19 00 ba 	orl	r9,0xba
80002c22:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002c24:	30 09       	mov	r9,0
80002c26:	49 68       	lddpc	r8,80002c7c <phy_tx_func+0xf4>
80002c28:	91 09       	st.w	r8[0x0],r9
80002c2a:	c1 c8       	rjmp	80002c62 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002c2c:	49 5a       	lddpc	r10,80002c80 <phy_tx_func+0xf8>
80002c2e:	74 0a       	ld.w	r10,r10[0x0]
80002c30:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002c34:	14 49       	or	r9,r10
80002c36:	8f 19       	st.w	r7[0x4],r9
80002c38:	2f f8       	sub	r8,-1
80002c3a:	49 59       	lddpc	r9,80002c8c <phy_tx_func+0x104>
80002c3c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c3e:	20 2c       	sub	r12,2
80002c40:	49 28       	lddpc	r8,80002c88 <phy_tx_func+0x100>
80002c42:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c44:	30 08       	mov	r8,0
80002c46:	f0 0c 19 00 	cp.h	r12,r8
80002c4a:	e0 89 00 0c 	brgt	80002c62 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002c4e:	30 29       	mov	r9,2
80002c50:	48 b8       	lddpc	r8,80002c7c <phy_tx_func+0xf4>
80002c52:	91 09       	st.w	r8[0x0],r9
80002c54:	c0 78       	rjmp	80002c62 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002c56:	fc 18 00 ba 	movh	r8,0xba
80002c5a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c5c:	30 09       	mov	r9,0
80002c5e:	48 88       	lddpc	r8,80002c7c <phy_tx_func+0xf4>
80002c60:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002c62:	e0 68 5a 5a 	mov	r8,23130
80002c66:	ea 18 ab cd 	orh	r8,0xabcd
80002c6a:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002c6c:	30 08       	mov	r8,0
80002c6e:	8f 38       	st.w	r7[0xc],r8
}
80002c70:	2f fd       	sub	sp,-4
80002c72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c76:	00 00       	add	r0,r0
80002c78:	00 00       	add	r0,r0
80002c7a:	0a c4       	st.b	r5++,r4
80002c7c:	00 00       	add	r0,r0
80002c7e:	0a 84       	andn	r4,r5
80002c80:	00 00       	add	r0,r0
80002c82:	0a 90       	mov	r0,r5
80002c84:	80 00       	ld.sh	r0,r0[0x0]
80002c86:	5b 04       	cp.w	r4,-16
80002c88:	00 00       	add	r0,r0
80002c8a:	0a ac       	st.w	r5++,r12
80002c8c:	00 00       	add	r0,r0
80002c8e:	0a 64       	and	r4,r5

80002c90 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002c90:	d4 01       	pushm	lr
80002c92:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002c94:	30 0a       	mov	r10,0
80002c96:	fa cb ff fc 	sub	r11,sp,-4
80002c9a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002c9c:	14 99       	mov	r9,r10
80002c9e:	1a 9b       	mov	r11,sp
80002ca0:	f0 1f 00 05 	mcall	80002cb4 <get_idle_store+0x24>
80002ca4:	58 1c       	cp.w	r12,1
80002ca6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002caa:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002cae:	2f fd       	sub	sp,-4
80002cb0:	d8 02       	popm	pc
80002cb2:	00 00       	add	r0,r0
80002cb4:	80 00       	ld.sh	r0,r0[0x0]
80002cb6:	5b f4       	cp.w	r4,-1

80002cb8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002cb8:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002cba:	48 4b       	lddpc	r11,80002cc8 <phy_init+0x10>
80002cbc:	48 4c       	lddpc	r12,80002ccc <phy_init+0x14>
80002cbe:	f0 1f 00 05 	mcall	80002cd0 <phy_init+0x18>
	
	/*initialize the SSC*/
	ssc_init();
80002cc2:	f0 1f 00 05 	mcall	80002cd4 <phy_init+0x1c>
	
	/*send device_master_query to connect radio*/
	//xnl_send_device_master_query();
	
}
80002cc6:	d8 02       	popm	pc
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	2b 88       	sub	r8,-72
80002ccc:	80 00       	ld.sh	r0,r0[0x0]
80002cce:	2c d8       	sub	r8,-51
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	3d 2c       	mov	r12,-46
80002cd4:	80 00       	ld.sh	r0,r0[0x0]
80002cd6:	3d 40       	mov	r0,-44

80002cd8 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002cd8:	eb cd 40 e0 	pushm	r5-r7,lr
80002cdc:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002cde:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002ce2:	70 08       	ld.w	r8,r8[0x0]
80002ce4:	58 08       	cp.w	r8,0
80002ce6:	e0 80 01 08 	breq	80002ef6 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002cea:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002cec:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002cf0:	70 09       	ld.w	r9,r8[0x0]
80002cf2:	2f f9       	sub	r9,-1
80002cf4:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002cf6:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002cfa:	70 08       	ld.w	r8,r8[0x0]
80002cfc:	58 18       	cp.w	r8,1
80002cfe:	e0 80 00 85 	breq	80002e08 <phy_rx_func+0x130>
80002d02:	c0 73       	brcs	80002d10 <phy_rx_func+0x38>
80002d04:	58 28       	cp.w	r8,2
80002d06:	c5 c0       	breq	80002dbe <phy_rx_func+0xe6>
80002d08:	58 38       	cp.w	r8,3
80002d0a:	e0 81 00 f6 	brne	80002ef6 <phy_rx_func+0x21e>
80002d0e:	cd 58       	rjmp	80002eb8 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002d10:	e0 6a 5a 5a 	mov	r10,23130
80002d14:	ea 1a ab cd 	orh	r10,0xabcd
80002d18:	14 36       	cp.w	r6,r10
80002d1a:	e0 80 00 ee 	breq	80002ef6 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002d1e:	ec 08 16 10 	lsr	r8,r6,0x10
80002d22:	e0 48 ab cd 	cp.w	r8,43981
80002d26:	e0 81 00 e8 	brne	80002ef6 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002d2a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002d2e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002d32:	20 28       	sub	r8,2
80002d34:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002d38:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002d3a:	30 09       	mov	r9,0
80002d3c:	f2 08 19 00 	cp.h	r8,r9
80002d40:	e0 8a 00 db 	brle	80002ef6 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002d44:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002d48:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002d4a:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002d4e:	70 0c       	ld.w	r12,r8[0x0]
80002d50:	f0 1f 03 88 	mcall	80003b70 <phy_rx_func+0xe98>
80002d54:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002d58:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002d5a:	58 0c       	cp.w	r12,0
80002d5c:	e0 80 00 cd 	breq	80002ef6 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002d60:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002d64:	90 09       	ld.sh	r9,r8[0x0]
80002d66:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002d6a:	2f f9       	sub	r9,-1
80002d6c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d6e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002d72:	74 0a       	ld.w	r10,r10[0x0]
80002d74:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002d78:	76 0b       	ld.w	r11,r11[0x0]
80002d7a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002d7e:	2f f9       	sub	r9,-1
80002d80:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002d82:	e2 16 0f 00 	andl	r6,0xf00,COH
80002d86:	e0 46 01 00 	cp.w	r6,256
80002d8a:	c0 c0       	breq	80002da2 <phy_rx_func+0xca>
80002d8c:	e0 8b 00 05 	brhi	80002d96 <phy_rx_func+0xbe>
80002d90:	58 06       	cp.w	r6,0
80002d92:	c0 80       	breq	80002da2 <phy_rx_func+0xca>
80002d94:	c0 c8       	rjmp	80002dac <phy_rx_func+0xd4>
80002d96:	e0 46 02 00 	cp.w	r6,512
80002d9a:	c0 40       	breq	80002da2 <phy_rx_func+0xca>
80002d9c:	e0 46 03 00 	cp.w	r6,768
80002da0:	c0 61       	brne	80002dac <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002da2:	30 29       	mov	r9,2
80002da4:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002da8:	91 09       	st.w	r8[0x0],r9
80002daa:	ca 68       	rjmp	80002ef6 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002dac:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002db0:	70 0c       	ld.w	r12,r8[0x0]
80002db2:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002db6:	70 0b       	ld.w	r11,r8[0x0]
80002db8:	f0 1f 03 70 	mcall	80003b78 <phy_rx_func+0xea0>
80002dbc:	c9 d8       	rjmp	80002ef6 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002dbe:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002dc2:	b1 86       	lsr	r6,0x10
80002dc4:	14 06       	add	r6,r10
80002dc6:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002dca:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002dcc:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002dd0:	90 09       	ld.sh	r9,r8[0x0]
80002dd2:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002dd6:	76 0b       	ld.w	r11,r11[0x0]
80002dd8:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002ddc:	2f f9       	sub	r9,-1
80002dde:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002de0:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002de4:	92 08       	ld.sh	r8,r9[0x0]
80002de6:	20 28       	sub	r8,2
80002de8:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002dea:	30 09       	mov	r9,0
80002dec:	f2 08 19 00 	cp.h	r8,r9
80002df0:	e0 8a 00 07 	brle	80002dfe <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002df4:	30 19       	mov	r9,1
80002df6:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002dfa:	91 09       	st.w	r8[0x0],r9
80002dfc:	c7 d8       	rjmp	80002ef6 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002dfe:	30 39       	mov	r9,3
80002e00:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002e04:	91 09       	st.w	r8[0x0],r9
80002e06:	c7 88       	rjmp	80002ef6 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002e08:	ec 0a 14 10 	asr	r10,r6,0x10
80002e0c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002e10:	90 09       	ld.sh	r9,r8[0x0]
80002e12:	14 09       	add	r9,r10
80002e14:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e16:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002e1a:	92 08       	ld.sh	r8,r9[0x0]
80002e1c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002e20:	76 0b       	ld.w	r11,r11[0x0]
80002e22:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002e26:	2f f8       	sub	r8,-1
80002e28:	5c 88       	casts.h	r8
80002e2a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002e2c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002e30:	94 09       	ld.sh	r9,r10[0x0]
80002e32:	20 29       	sub	r9,2
80002e34:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002e36:	30 0a       	mov	r10,0
80002e38:	f4 09 19 00 	cp.h	r9,r10
80002e3c:	e0 89 00 20 	brgt	80002e7c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002e40:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002e44:	e0 46 00 ba 	cp.w	r6,186
80002e48:	c0 d1       	brne	80002e62 <phy_rx_func+0x18a>
80002e4a:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002e4e:	90 09       	ld.sh	r9,r8[0x0]
80002e50:	f4 09 19 00 	cp.h	r9,r10
80002e54:	c0 71       	brne	80002e62 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002e56:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002e5a:	70 0c       	ld.w	r12,r8[0x0]
80002e5c:	f0 1f 03 49 	mcall	80003b80 <phy_rx_func+0xea8>
80002e60:	c0 98       	rjmp	80002e72 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002e62:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002e66:	70 0c       	ld.w	r12,r8[0x0]
80002e68:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002e6c:	70 0b       	ld.w	r11,r8[0x0]
80002e6e:	f0 1f 03 43 	mcall	80003b78 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002e72:	30 09       	mov	r9,0
80002e74:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002e78:	91 09       	st.w	r8[0x0],r9
80002e7a:	c3 e8       	rjmp	80002ef6 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002e7c:	5c 86       	casts.h	r6
80002e7e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002e82:	92 0a       	ld.sh	r10,r9[0x0]
80002e84:	0c 0a       	add	r10,r6
80002e86:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e88:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002e8c:	72 09       	ld.w	r9,r9[0x0]
80002e8e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002e92:	2f f8       	sub	r8,-1
80002e94:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002e98:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002e9a:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002e9e:	92 08       	ld.sh	r8,r9[0x0]
80002ea0:	20 28       	sub	r8,2
80002ea2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002ea4:	30 09       	mov	r9,0
80002ea6:	f2 08 19 00 	cp.h	r8,r9
80002eaa:	e0 89 00 26 	brgt	80002ef6 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002eae:	30 39       	mov	r9,3
80002eb0:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002eb4:	91 09       	st.w	r8[0x0],r9
80002eb6:	c2 08       	rjmp	80002ef6 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002eb8:	e6 16 00 ff 	andh	r6,0xff,COH
80002ebc:	fc 19 00 ba 	movh	r9,0xba
80002ec0:	12 36       	cp.w	r6,r9
80002ec2:	c0 e1       	brne	80002ede <phy_rx_func+0x206>
80002ec4:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002ec8:	90 09       	ld.sh	r9,r8[0x0]
80002eca:	30 08       	mov	r8,0
80002ecc:	f0 09 19 00 	cp.h	r9,r8
80002ed0:	c0 71       	brne	80002ede <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002ed2:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002ed6:	70 0c       	ld.w	r12,r8[0x0]
80002ed8:	f0 1f 03 2a 	mcall	80003b80 <phy_rx_func+0xea8>
80002edc:	c0 98       	rjmp	80002eee <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002ede:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002ee2:	70 0c       	ld.w	r12,r8[0x0]
80002ee4:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002ee8:	70 0b       	ld.w	r11,r8[0x0]
80002eea:	f0 1f 03 24 	mcall	80003b78 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002eee:	30 09       	mov	r9,0
80002ef0:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002ef4:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002ef6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002efa:	11 89       	ld.ub	r9,r8[0x0]
80002efc:	30 08       	mov	r8,0
80002efe:	f0 09 18 00 	cp.b	r9,r8
80002f02:	c1 31       	brne	80002f28 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002f04:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002f08:	6c 0c       	ld.w	r12,r6[0x0]
80002f0a:	f0 1f 03 1a 	mcall	80003b70 <phy_rx_func+0xe98>
80002f0e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002f12:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002f14:	6c 0c       	ld.w	r12,r6[0x0]
80002f16:	f0 1f 03 17 	mcall	80003b70 <phy_rx_func+0xe98>
80002f1a:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002f1e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002f20:	30 19       	mov	r9,1
80002f22:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002f26:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002f28:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002f2c:	70 08       	ld.w	r8,r8[0x0]
80002f2e:	58 28       	cp.w	r8,2
80002f30:	e0 80 01 98 	breq	80003260 <phy_rx_func+0x588>
80002f34:	e0 8b 00 06 	brhi	80002f40 <phy_rx_func+0x268>
80002f38:	58 08       	cp.w	r8,0
80002f3a:	c0 b0       	breq	80002f50 <phy_rx_func+0x278>
80002f3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f40:	58 38       	cp.w	r8,3
80002f42:	e0 80 05 c5 	breq	80003acc <phy_rx_func+0xdf4>
80002f46:	58 48       	cp.w	r8,4
80002f48:	e0 81 06 05 	brne	80003b52 <phy_rx_func+0xe7a>
80002f4c:	e0 8f 02 4b 	bral	800033e2 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002f50:	6e 28       	ld.w	r8,r7[0x8]
80002f52:	e0 6a 5a 5a 	mov	r10,23130
80002f56:	ea 1a ab cd 	orh	r10,0xabcd
80002f5a:	14 38       	cp.w	r8,r10
80002f5c:	c0 71       	brne	80002f6a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002f5e:	30 09       	mov	r9,0
80002f60:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002f64:	91 09       	st.w	r8[0x0],r9
80002f66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002f6a:	10 99       	mov	r9,r8
80002f6c:	e0 19 00 00 	andl	r9,0x0
80002f70:	fc 1a ab cd 	movh	r10,0xabcd
80002f74:	14 39       	cp.w	r9,r10
80002f76:	e0 81 05 ee 	brne	80003b52 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002f7a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002f7e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002f82:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002f84:	6e 29       	ld.w	r9,r7[0x8]
80002f86:	e2 19 f0 00 	andl	r9,0xf000,COH
80002f8a:	e0 49 c0 00 	cp.w	r9,49152
80002f8e:	e0 81 00 ce 	brne	8000312a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002f92:	30 1a       	mov	r10,1
80002f94:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002f98:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002f9a:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002f9e:	72 09       	ld.w	r9,r9[0x0]
80002fa0:	58 09       	cp.w	r9,0
80002fa2:	c0 71       	brne	80002fb0 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002fa4:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002fa8:	f0 1f 03 00 	mcall	80003ba8 <phy_rx_func+0xed0>
80002fac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002fb0:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002fb4:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002fb8:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002fba:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002fbe:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002fc2:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002fc6:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002fc8:	13 89       	ld.ub	r9,r9[0x0]
80002fca:	37 fa       	mov	r10,127
80002fcc:	f4 09 18 00 	cp.b	r9,r10
80002fd0:	c6 d0       	breq	800030aa <phy_rx_func+0x3d2>
80002fd2:	e0 8b 00 0c 	brhi	80002fea <phy_rx_func+0x312>
80002fd6:	31 2a       	mov	r10,18
80002fd8:	f4 09 18 00 	cp.b	r9,r10
80002fdc:	c4 20       	breq	80003060 <phy_rx_func+0x388>
80002fde:	31 3a       	mov	r10,19
80002fe0:	f4 09 18 00 	cp.b	r9,r10
80002fe4:	e0 81 00 83 	brne	800030ea <phy_rx_func+0x412>
80002fe8:	c5 b8       	rjmp	8000309e <phy_rx_func+0x3c6>
80002fea:	2f 09       	sub	r9,-16
80002fec:	30 1a       	mov	r10,1
80002fee:	f4 09 18 00 	cp.b	r9,r10
80002ff2:	e0 8b 00 7c 	brhi	800030ea <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002ff6:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002ffa:	e2 18 00 f0 	andl	r8,0xf0,COH
80002ffe:	59 08       	cp.w	r8,16
80003000:	c0 71       	brne	8000300e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003002:	30 19       	mov	r9,1
80003004:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003008:	91 09       	st.w	r8[0x0],r9
8000300a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000300e:	e0 48 00 20 	cp.w	r8,32
80003012:	c2 11       	brne	80003054 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003014:	30 a9       	mov	r9,10
80003016:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000301a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000301c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003020:	6c 08       	ld.w	r8,r6[0x0]
80003022:	f0 0a 11 ff 	rsub	r10,r8,-1
80003026:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000302a:	2f f8       	sub	r8,-1
8000302c:	6e 0c       	ld.w	r12,r7[0x0]
8000302e:	f4 ca fe 00 	sub	r10,r10,-512
80003032:	30 0b       	mov	r11,0
80003034:	10 0c       	add	r12,r8
80003036:	f0 1f 02 e1 	mcall	80003bb8 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000303a:	30 08       	mov	r8,0
8000303c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000303e:	6e 0c       	ld.w	r12,r7[0x0]
80003040:	f0 1f 02 df 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003044:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003048:	70 0c       	ld.w	r12,r8[0x0]
8000304a:	f0 1f 02 ca 	mcall	80003b70 <phy_rx_func+0xe98>
8000304e:	8f 0c       	st.w	r7[0x0],r12
80003050:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003054:	30 09       	mov	r9,0
80003056:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000305a:	91 09       	st.w	r8[0x0],r9
8000305c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003060:	20 48       	sub	r8,4
80003062:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003066:	93 08       	st.w	r9[0x0],r8
80003068:	58 08       	cp.w	r8,0
8000306a:	e0 80 05 74 	breq	80003b52 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000306e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003072:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003076:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000307a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000307c:	8e 69       	ld.sh	r9,r7[0xc]
8000307e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003082:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003084:	8e 79       	ld.sh	r9,r7[0xe]
80003086:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003088:	f0 1f 02 d0 	mcall	80003bc8 <phy_rx_func+0xef0>
8000308c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003090:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003092:	30 49       	mov	r9,4
80003094:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003098:	91 09       	st.w	r8[0x0],r9
8000309a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000309e:	30 09       	mov	r9,0
800030a0:	fe f8 0a f8 	ld.w	r8,pc[2808]
800030a4:	91 09       	st.w	r8[0x0],r9
800030a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800030aa:	20 48       	sub	r8,4
800030ac:	fe f9 0a f0 	ld.w	r9,pc[2800]
800030b0:	93 08       	st.w	r9[0x0],r8
800030b2:	58 08       	cp.w	r8,0
800030b4:	e0 80 05 4f 	breq	80003b52 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800030b8:	fe f8 0b 14 	ld.w	r8,pc[2836]
800030bc:	70 09       	ld.w	r9,r8[0x0]
800030be:	8e 7b       	ld.sh	r11,r7[0xe]
800030c0:	fe fa 0b 10 	ld.w	r10,pc[2832]
800030c4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800030c8:	2f f9       	sub	r9,-1
800030ca:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800030cc:	fe f8 0a e4 	ld.w	r8,pc[2788]
800030d0:	70 09       	ld.w	r9,r8[0x0]
800030d2:	20 29       	sub	r9,2
800030d4:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800030d6:	30 29       	mov	r9,2
800030d8:	fe f8 0a c0 	ld.w	r8,pc[2752]
800030dc:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800030de:	30 39       	mov	r9,3
800030e0:	fe f8 0a b4 	ld.w	r8,pc[2740]
800030e4:	91 09       	st.w	r8[0x0],r9
800030e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800030ea:	30 3a       	mov	r10,3
800030ec:	fe f9 0a ac 	ld.w	r9,pc[2732]
800030f0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800030f2:	6e 2a       	ld.w	r10,r7[0x8]
800030f4:	fe f9 0a e0 	ld.w	r9,pc[2784]
800030f8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800030fa:	6e 3a       	ld.w	r10,r7[0xc]
800030fc:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800030fe:	59 48       	cp.w	r8,20
80003100:	c0 61       	brne	8000310c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003102:	31 89       	mov	r9,24
80003104:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003108:	91 09       	st.w	r8[0x0],r9
8000310a:	c0 a8       	rjmp	8000311e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000310c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003110:	70 08       	ld.w	r8,r8[0x0]
80003112:	59 08       	cp.w	r8,16
80003114:	c0 51       	brne	8000311e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003116:	31 09       	mov	r9,16
80003118:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000311c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000311e:	30 49       	mov	r9,4
80003120:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003124:	91 09       	st.w	r8[0x0],r9
80003126:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000312a:	e0 49 10 00 	cp.w	r9,4096
8000312e:	5f 1a       	srne	r10
80003130:	e0 49 20 00 	cp.w	r9,8192
80003134:	5f 19       	srne	r9
80003136:	f5 e9 00 09 	and	r9,r10,r9
8000313a:	e0 81 05 0c 	brne	80003b52 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000313e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003142:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003144:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003148:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000314a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000314e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003150:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003154:	72 09       	ld.w	r9,r9[0x0]
80003156:	58 09       	cp.w	r9,0
80003158:	c0 71       	brne	80003166 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000315a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000315e:	f0 1f 02 93 	mcall	80003ba8 <phy_rx_func+0xed0>
80003162:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003166:	6e 2a       	ld.w	r10,r7[0x8]
80003168:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000316c:	58 1a       	cp.w	r10,1
8000316e:	e0 8b 00 4d 	brhi	80003208 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003172:	20 48       	sub	r8,4
80003174:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003178:	93 08       	st.w	r9[0x0],r8
8000317a:	58 08       	cp.w	r8,0
8000317c:	e0 80 04 eb 	breq	80003b52 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003180:	8e 68       	ld.sh	r8,r7[0xc]
80003182:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003186:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000318a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
8000318c:	30 09       	mov	r9,0
8000318e:	f2 08 19 00 	cp.h	r8,r9
80003192:	c0 70       	breq	800031a0 <phy_rx_func+0x4c8>
80003194:	30 19       	mov	r9,1
80003196:	f2 08 19 00 	cp.h	r8,r9
8000319a:	e0 81 04 dc 	brne	80003b52 <phy_rx_func+0xe7a>
8000319e:	c2 68       	rjmp	800031ea <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800031a0:	fe f8 0a 44 	ld.w	r8,pc[2628]
800031a4:	70 0a       	ld.w	r10,r8[0x0]
800031a6:	fe f9 09 e6 	ld.w	r9,pc[2534]
800031aa:	72 09       	ld.w	r9,r9[0x0]
800031ac:	8e 7b       	ld.sh	r11,r7[0xe]
800031ae:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800031b2:	70 09       	ld.w	r9,r8[0x0]
800031b4:	2f f9       	sub	r9,-1
800031b6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031b8:	e0 49 00 ff 	cp.w	r9,255
800031bc:	e0 88 00 11 	brls	800031de <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800031c0:	30 09       	mov	r9,0
800031c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800031c4:	fe f7 09 c8 	ld.w	r7,pc[2504]
800031c8:	6e 0c       	ld.w	r12,r7[0x0]
800031ca:	f0 1f 02 7d 	mcall	80003bbc <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800031ce:	fe f8 09 ba 	ld.w	r8,pc[2490]
800031d2:	70 0c       	ld.w	r12,r8[0x0]
800031d4:	f0 1f 02 67 	mcall	80003b70 <phy_rx_func+0xe98>
800031d8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800031da:	e0 80 04 bc 	breq	80003b52 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800031de:	30 29       	mov	r9,2
800031e0:	fe f8 09 b4 	ld.w	r8,pc[2484]
800031e4:	91 09       	st.w	r8[0x0],r9
800031e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800031ea:	8e 79       	ld.sh	r9,r7[0xe]
800031ec:	30 38       	mov	r8,3
800031ee:	f0 09 19 00 	cp.h	r9,r8
800031f2:	c0 51       	brne	800031fc <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800031f4:	30 19       	mov	r9,1
800031f6:	fe f8 09 f2 	ld.w	r8,pc[2546]
800031fa:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800031fc:	30 29       	mov	r9,2
800031fe:	fe f8 09 96 	ld.w	r8,pc[2454]
80003202:	91 09       	st.w	r8[0x0],r9
80003204:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003208:	58 18       	cp.w	r8,1
8000320a:	e0 88 04 a4 	brls	80003b52 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000320e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003212:	70 0a       	ld.w	r10,r8[0x0]
80003214:	6e 3b       	ld.w	r11,r7[0xc]
80003216:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000321a:	70 09       	ld.w	r9,r8[0x0]
8000321c:	2f f9       	sub	r9,-1
8000321e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003220:	e0 49 00 ff 	cp.w	r9,255
80003224:	e0 88 00 11 	brls	80003246 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003228:	30 09       	mov	r9,0
8000322a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000322c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003230:	6e 0c       	ld.w	r12,r7[0x0]
80003232:	f0 1f 02 63 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003236:	fe f8 09 52 	ld.w	r8,pc[2386]
8000323a:	70 0c       	ld.w	r12,r8[0x0]
8000323c:	f0 1f 02 4d 	mcall	80003b70 <phy_rx_func+0xe98>
80003240:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003242:	e0 80 04 88 	breq	80003b52 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003246:	fe f9 09 56 	ld.w	r9,pc[2390]
8000324a:	72 08       	ld.w	r8,r9[0x0]
8000324c:	20 28       	sub	r8,2
8000324e:	93 08       	st.w	r9[0x0],r8
80003250:	e0 80 04 81 	breq	80003b52 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003254:	30 29       	mov	r9,2
80003256:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000325a:	91 09       	st.w	r8[0x0],r9
8000325c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003260:	fe f8 09 84 	ld.w	r8,pc[2436]
80003264:	70 0a       	ld.w	r10,r8[0x0]
80003266:	fe f9 09 26 	ld.w	r9,pc[2342]
8000326a:	72 09       	ld.w	r9,r9[0x0]
8000326c:	8e 4b       	ld.sh	r11,r7[0x8]
8000326e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003272:	70 09       	ld.w	r9,r8[0x0]
80003274:	2f f9       	sub	r9,-1
80003276:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003278:	e0 49 00 ff 	cp.w	r9,255
8000327c:	e0 88 00 16 	brls	800032a8 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003280:	30 09       	mov	r9,0
80003282:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003284:	fe f6 09 08 	ld.w	r6,pc[2312]
80003288:	6c 0c       	ld.w	r12,r6[0x0]
8000328a:	f0 1f 02 4d 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000328e:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003292:	70 0c       	ld.w	r12,r8[0x0]
80003294:	f0 1f 02 37 	mcall	80003b70 <phy_rx_func+0xe98>
80003298:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000329a:	c0 71       	brne	800032a8 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
8000329c:	30 09       	mov	r9,0
8000329e:	fe f8 08 f6 	ld.w	r8,pc[2294]
800032a2:	91 09       	st.w	r8[0x0],r9
800032a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800032a8:	fe f9 08 f4 	ld.w	r9,pc[2292]
800032ac:	72 08       	ld.w	r8,r9[0x0]
800032ae:	20 28       	sub	r8,2
800032b0:	93 08       	st.w	r9[0x0],r8
800032b2:	c0 71       	brne	800032c0 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800032b4:	30 09       	mov	r9,0
800032b6:	fe f8 08 de 	ld.w	r8,pc[2270]
800032ba:	91 09       	st.w	r8[0x0],r9
800032bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800032c0:	fe f8 09 24 	ld.w	r8,pc[2340]
800032c4:	70 0a       	ld.w	r10,r8[0x0]
800032c6:	fe f9 08 c6 	ld.w	r9,pc[2246]
800032ca:	72 09       	ld.w	r9,r9[0x0]
800032cc:	8e 5b       	ld.sh	r11,r7[0xa]
800032ce:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032d2:	70 09       	ld.w	r9,r8[0x0]
800032d4:	2f f9       	sub	r9,-1
800032d6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032d8:	e0 49 00 ff 	cp.w	r9,255
800032dc:	e0 88 00 16 	brls	80003308 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800032e0:	30 09       	mov	r9,0
800032e2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032e4:	fe f6 08 a8 	ld.w	r6,pc[2216]
800032e8:	6c 0c       	ld.w	r12,r6[0x0]
800032ea:	f0 1f 02 35 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032ee:	fe f8 08 9a 	ld.w	r8,pc[2202]
800032f2:	70 0c       	ld.w	r12,r8[0x0]
800032f4:	f0 1f 02 1f 	mcall	80003b70 <phy_rx_func+0xe98>
800032f8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032fa:	c0 71       	brne	80003308 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800032fc:	30 09       	mov	r9,0
800032fe:	fe f8 08 96 	ld.w	r8,pc[2198]
80003302:	91 09       	st.w	r8[0x0],r9
80003304:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003308:	fe f9 08 94 	ld.w	r9,pc[2196]
8000330c:	72 08       	ld.w	r8,r9[0x0]
8000330e:	20 28       	sub	r8,2
80003310:	93 08       	st.w	r9[0x0],r8
80003312:	c0 71       	brne	80003320 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003314:	30 09       	mov	r9,0
80003316:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000331a:	91 09       	st.w	r8[0x0],r9
8000331c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003320:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003324:	70 0a       	ld.w	r10,r8[0x0]
80003326:	fe f9 08 66 	ld.w	r9,pc[2150]
8000332a:	72 09       	ld.w	r9,r9[0x0]
8000332c:	8e 6b       	ld.sh	r11,r7[0xc]
8000332e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003332:	70 09       	ld.w	r9,r8[0x0]
80003334:	2f f9       	sub	r9,-1
80003336:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003338:	e0 49 00 ff 	cp.w	r9,255
8000333c:	e0 88 00 16 	brls	80003368 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003340:	30 09       	mov	r9,0
80003342:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003344:	fe f6 08 48 	ld.w	r6,pc[2120]
80003348:	6c 0c       	ld.w	r12,r6[0x0]
8000334a:	f0 1f 02 1d 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000334e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003352:	70 0c       	ld.w	r12,r8[0x0]
80003354:	f0 1f 02 07 	mcall	80003b70 <phy_rx_func+0xe98>
80003358:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000335a:	c0 71       	brne	80003368 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
8000335c:	30 09       	mov	r9,0
8000335e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003362:	91 09       	st.w	r8[0x0],r9
80003364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003368:	fe f9 08 34 	ld.w	r9,pc[2100]
8000336c:	72 08       	ld.w	r8,r9[0x0]
8000336e:	20 28       	sub	r8,2
80003370:	93 08       	st.w	r9[0x0],r8
80003372:	c0 71       	brne	80003380 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003374:	30 09       	mov	r9,0
80003376:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000337a:	91 09       	st.w	r8[0x0],r9
8000337c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003380:	fe f8 08 64 	ld.w	r8,pc[2148]
80003384:	70 0a       	ld.w	r10,r8[0x0]
80003386:	fe f9 08 06 	ld.w	r9,pc[2054]
8000338a:	72 09       	ld.w	r9,r9[0x0]
8000338c:	8e 7b       	ld.sh	r11,r7[0xe]
8000338e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003392:	70 09       	ld.w	r9,r8[0x0]
80003394:	2f f9       	sub	r9,-1
80003396:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003398:	e0 49 00 ff 	cp.w	r9,255
8000339c:	e0 88 00 16 	brls	800033c8 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800033a0:	30 09       	mov	r9,0
800033a2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033a4:	fe f7 07 e8 	ld.w	r7,pc[2024]
800033a8:	6e 0c       	ld.w	r12,r7[0x0]
800033aa:	f0 1f 02 05 	mcall	80003bbc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033ae:	fe f8 07 da 	ld.w	r8,pc[2010]
800033b2:	70 0c       	ld.w	r12,r8[0x0]
800033b4:	f0 1f 01 ef 	mcall	80003b70 <phy_rx_func+0xe98>
800033b8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800033ba:	c0 71       	brne	800033c8 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800033bc:	30 09       	mov	r9,0
800033be:	fe f8 07 d6 	ld.w	r8,pc[2006]
800033c2:	91 09       	st.w	r8[0x0],r9
800033c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800033c8:	fe f9 07 d4 	ld.w	r9,pc[2004]
800033cc:	72 08       	ld.w	r8,r9[0x0]
800033ce:	20 28       	sub	r8,2
800033d0:	93 08       	st.w	r9[0x0],r8
800033d2:	e0 81 03 c0 	brne	80003b52 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800033d6:	30 09       	mov	r9,0
800033d8:	fe f8 07 bc 	ld.w	r8,pc[1980]
800033dc:	91 09       	st.w	r8[0x0],r9
800033de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800033e2:	fe f8 07 ca 	ld.w	r8,pc[1994]
800033e6:	11 89       	ld.ub	r9,r8[0x0]
800033e8:	31 28       	mov	r8,18
800033ea:	f0 09 18 00 	cp.b	r9,r8
800033ee:	e0 81 01 4c 	brne	80003686 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800033f2:	ef 39 00 09 	ld.ub	r9,r7[9]
800033f6:	fe f8 07 b6 	ld.w	r8,pc[1974]
800033fa:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800033fc:	11 89       	ld.ub	r9,r8[0x0]
800033fe:	3f 28       	mov	r8,-14
80003400:	f0 09 18 00 	cp.b	r9,r8
80003404:	e0 81 01 3b 	brne	8000367a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003408:	30 19       	mov	r9,1
8000340a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000340e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003410:	6e 29       	ld.w	r9,r7[0x8]
80003412:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003416:	fe f8 07 86 	ld.w	r8,pc[1926]
8000341a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000341c:	8e 59       	ld.sh	r9,r7[0xa]
8000341e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003422:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003424:	8e 69       	ld.sh	r9,r7[0xc]
80003426:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003428:	8e 79       	ld.sh	r9,r7[0xe]
8000342a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000342c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003430:	fe f9 07 60 	ld.w	r9,pc[1888]
80003434:	72 0a       	ld.w	r10,r9[0x0]
80003436:	70 09       	ld.w	r9,r8[0x0]
80003438:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000343c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003440:	70 09       	ld.w	r9,r8[0x0]
80003442:	2f f9       	sub	r9,-1
80003444:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003446:	e0 49 01 ff 	cp.w	r9,511
8000344a:	e0 88 00 16 	brls	80003476 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000344e:	30 09       	mov	r9,0
80003450:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003452:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003456:	6c 0c       	ld.w	r12,r6[0x0]
80003458:	f0 1f 01 d9 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000345c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003460:	70 0c       	ld.w	r12,r8[0x0]
80003462:	f0 1f 01 c4 	mcall	80003b70 <phy_rx_func+0xe98>
80003466:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003468:	c0 71       	brne	80003476 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000346a:	30 09       	mov	r9,0
8000346c:	fe f8 07 28 	ld.w	r8,pc[1832]
80003470:	91 09       	st.w	r8[0x0],r9
80003472:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003476:	fe f9 07 26 	ld.w	r9,pc[1830]
8000347a:	72 08       	ld.w	r8,r9[0x0]
8000347c:	20 18       	sub	r8,1
8000347e:	93 08       	st.w	r9[0x0],r8
80003480:	c0 71       	brne	8000348e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003482:	30 09       	mov	r9,0
80003484:	fe f8 07 10 	ld.w	r8,pc[1808]
80003488:	91 09       	st.w	r8[0x0],r9
8000348a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000348e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003492:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003496:	72 0a       	ld.w	r10,r9[0x0]
80003498:	70 09       	ld.w	r9,r8[0x0]
8000349a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000349e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034a2:	70 09       	ld.w	r9,r8[0x0]
800034a4:	2f f9       	sub	r9,-1
800034a6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034a8:	e0 49 01 ff 	cp.w	r9,511
800034ac:	e0 88 00 16 	brls	800034d8 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800034b0:	30 09       	mov	r9,0
800034b2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034b4:	fe f6 06 dc 	ld.w	r6,pc[1756]
800034b8:	6c 0c       	ld.w	r12,r6[0x0]
800034ba:	f0 1f 01 c1 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034be:	fe f8 06 ca 	ld.w	r8,pc[1738]
800034c2:	70 0c       	ld.w	r12,r8[0x0]
800034c4:	f0 1f 01 ab 	mcall	80003b70 <phy_rx_func+0xe98>
800034c8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034ca:	c0 71       	brne	800034d8 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800034cc:	30 09       	mov	r9,0
800034ce:	fe f8 06 c6 	ld.w	r8,pc[1734]
800034d2:	91 09       	st.w	r8[0x0],r9
800034d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034d8:	fe f9 06 c4 	ld.w	r9,pc[1732]
800034dc:	72 08       	ld.w	r8,r9[0x0]
800034de:	20 18       	sub	r8,1
800034e0:	93 08       	st.w	r9[0x0],r8
800034e2:	c0 71       	brne	800034f0 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800034e4:	30 09       	mov	r9,0
800034e6:	fe f8 06 ae 	ld.w	r8,pc[1710]
800034ea:	91 09       	st.w	r8[0x0],r9
800034ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800034f0:	fe f8 06 c4 	ld.w	r8,pc[1732]
800034f4:	fe f9 06 9c 	ld.w	r9,pc[1692]
800034f8:	72 0a       	ld.w	r10,r9[0x0]
800034fa:	70 09       	ld.w	r9,r8[0x0]
800034fc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003500:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003504:	70 09       	ld.w	r9,r8[0x0]
80003506:	2f f9       	sub	r9,-1
80003508:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000350a:	e0 49 01 ff 	cp.w	r9,511
8000350e:	e0 88 00 16 	brls	8000353a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003512:	30 09       	mov	r9,0
80003514:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003516:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000351a:	6c 0c       	ld.w	r12,r6[0x0]
8000351c:	f0 1f 01 a8 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003520:	fe f8 06 68 	ld.w	r8,pc[1640]
80003524:	70 0c       	ld.w	r12,r8[0x0]
80003526:	f0 1f 01 93 	mcall	80003b70 <phy_rx_func+0xe98>
8000352a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000352c:	c0 71       	brne	8000353a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000352e:	30 09       	mov	r9,0
80003530:	fe f8 06 64 	ld.w	r8,pc[1636]
80003534:	91 09       	st.w	r8[0x0],r9
80003536:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000353a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000353e:	72 08       	ld.w	r8,r9[0x0]
80003540:	20 18       	sub	r8,1
80003542:	93 08       	st.w	r9[0x0],r8
80003544:	c0 71       	brne	80003552 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003546:	30 09       	mov	r9,0
80003548:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000354c:	91 09       	st.w	r8[0x0],r9
8000354e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003552:	fe f8 06 62 	ld.w	r8,pc[1634]
80003556:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000355a:	72 0a       	ld.w	r10,r9[0x0]
8000355c:	70 09       	ld.w	r9,r8[0x0]
8000355e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003562:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003566:	70 09       	ld.w	r9,r8[0x0]
80003568:	2f f9       	sub	r9,-1
8000356a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000356c:	e0 49 01 ff 	cp.w	r9,511
80003570:	e0 88 00 16 	brls	8000359c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003574:	30 09       	mov	r9,0
80003576:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003578:	fe f6 06 18 	ld.w	r6,pc[1560]
8000357c:	6c 0c       	ld.w	r12,r6[0x0]
8000357e:	f0 1f 01 90 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003582:	fe f8 06 06 	ld.w	r8,pc[1542]
80003586:	70 0c       	ld.w	r12,r8[0x0]
80003588:	f0 1f 01 7a 	mcall	80003b70 <phy_rx_func+0xe98>
8000358c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000358e:	c0 71       	brne	8000359c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003590:	30 09       	mov	r9,0
80003592:	fe f8 06 02 	ld.w	r8,pc[1538]
80003596:	91 09       	st.w	r8[0x0],r9
80003598:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000359c:	fe f9 06 00 	ld.w	r9,pc[1536]
800035a0:	72 08       	ld.w	r8,r9[0x0]
800035a2:	20 18       	sub	r8,1
800035a4:	93 08       	st.w	r9[0x0],r8
800035a6:	c0 71       	brne	800035b4 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800035a8:	30 09       	mov	r9,0
800035aa:	fe f8 05 ea 	ld.w	r8,pc[1514]
800035ae:	91 09       	st.w	r8[0x0],r9
800035b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800035b4:	fe f8 06 00 	ld.w	r8,pc[1536]
800035b8:	fe f9 05 d8 	ld.w	r9,pc[1496]
800035bc:	72 0a       	ld.w	r10,r9[0x0]
800035be:	70 09       	ld.w	r9,r8[0x0]
800035c0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800035c4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035c8:	70 09       	ld.w	r9,r8[0x0]
800035ca:	2f f9       	sub	r9,-1
800035cc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035ce:	e0 49 01 ff 	cp.w	r9,511
800035d2:	e0 88 00 16 	brls	800035fe <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800035d6:	30 09       	mov	r9,0
800035d8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035da:	fe f6 05 b6 	ld.w	r6,pc[1462]
800035de:	6c 0c       	ld.w	r12,r6[0x0]
800035e0:	f0 1f 01 77 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035e4:	fe f8 05 a4 	ld.w	r8,pc[1444]
800035e8:	70 0c       	ld.w	r12,r8[0x0]
800035ea:	f0 1f 01 62 	mcall	80003b70 <phy_rx_func+0xe98>
800035ee:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035f0:	c0 71       	brne	800035fe <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800035f2:	30 09       	mov	r9,0
800035f4:	fe f8 05 a0 	ld.w	r8,pc[1440]
800035f8:	91 09       	st.w	r8[0x0],r9
800035fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035fe:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003602:	72 08       	ld.w	r8,r9[0x0]
80003604:	20 18       	sub	r8,1
80003606:	93 08       	st.w	r9[0x0],r8
80003608:	c0 71       	brne	80003616 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000360a:	30 09       	mov	r9,0
8000360c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003610:	91 09       	st.w	r8[0x0],r9
80003612:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003616:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000361a:	fe f9 05 76 	ld.w	r9,pc[1398]
8000361e:	72 0a       	ld.w	r10,r9[0x0]
80003620:	70 09       	ld.w	r9,r8[0x0]
80003622:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003626:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000362a:	70 09       	ld.w	r9,r8[0x0]
8000362c:	2f f9       	sub	r9,-1
8000362e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003630:	e0 49 01 ff 	cp.w	r9,511
80003634:	e0 88 00 16 	brls	80003660 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003638:	30 09       	mov	r9,0
8000363a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000363c:	fe f7 05 54 	ld.w	r7,pc[1364]
80003640:	6e 0c       	ld.w	r12,r7[0x0]
80003642:	f0 1f 01 5f 	mcall	80003bbc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003646:	fe f8 05 42 	ld.w	r8,pc[1346]
8000364a:	70 0c       	ld.w	r12,r8[0x0]
8000364c:	f0 1f 01 49 	mcall	80003b70 <phy_rx_func+0xe98>
80003650:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003652:	c0 71       	brne	80003660 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003654:	30 09       	mov	r9,0
80003656:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000365a:	91 09       	st.w	r8[0x0],r9
8000365c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003660:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003664:	72 08       	ld.w	r8,r9[0x0]
80003666:	20 18       	sub	r8,1
80003668:	93 08       	st.w	r9[0x0],r8
8000366a:	e0 81 02 74 	brne	80003b52 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000366e:	30 09       	mov	r9,0
80003670:	fe f8 05 24 	ld.w	r8,pc[1316]
80003674:	91 09       	st.w	r8[0x0],r9
80003676:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000367a:	30 09       	mov	r9,0
8000367c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003680:	91 09       	st.w	r8[0x0],r9
80003682:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003686:	fe f8 05 26 	ld.w	r8,pc[1318]
8000368a:	11 89       	ld.ub	r9,r8[0x0]
8000368c:	3f 28       	mov	r8,-14
8000368e:	f0 09 18 00 	cp.b	r9,r8
80003692:	c4 31       	brne	80003718 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003694:	8e 49       	ld.sh	r9,r7[0x8]
80003696:	fe f8 05 56 	ld.w	r8,pc[1366]
8000369a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000369c:	fe f8 05 18 	ld.w	r8,pc[1304]
800036a0:	fe f9 04 f0 	ld.w	r9,pc[1264]
800036a4:	72 0a       	ld.w	r10,r9[0x0]
800036a6:	70 09       	ld.w	r9,r8[0x0]
800036a8:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036ac:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036b0:	70 09       	ld.w	r9,r8[0x0]
800036b2:	2f f9       	sub	r9,-1
800036b4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036b6:	e0 49 01 ff 	cp.w	r9,511
800036ba:	e0 88 00 16 	brls	800036e6 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800036be:	30 09       	mov	r9,0
800036c0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036c2:	fe f7 04 ce 	ld.w	r7,pc[1230]
800036c6:	6e 0c       	ld.w	r12,r7[0x0]
800036c8:	f0 1f 01 3d 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036cc:	fe f8 04 bc 	ld.w	r8,pc[1212]
800036d0:	70 0c       	ld.w	r12,r8[0x0]
800036d2:	f0 1f 01 28 	mcall	80003b70 <phy_rx_func+0xe98>
800036d6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036d8:	c0 71       	brne	800036e6 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800036da:	30 09       	mov	r9,0
800036dc:	fe f8 04 b8 	ld.w	r8,pc[1208]
800036e0:	91 09       	st.w	r8[0x0],r9
800036e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036e6:	fe f9 04 b6 	ld.w	r9,pc[1206]
800036ea:	72 08       	ld.w	r8,r9[0x0]
800036ec:	20 18       	sub	r8,1
800036ee:	93 08       	st.w	r9[0x0],r8
800036f0:	c0 71       	brne	800036fe <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800036f2:	30 09       	mov	r9,0
800036f4:	fe f8 04 a0 	ld.w	r8,pc[1184]
800036f8:	91 09       	st.w	r8[0x0],r9
800036fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800036fe:	20 18       	sub	r8,1
80003700:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003704:	93 08       	st.w	r9[0x0],r8
80003706:	58 08       	cp.w	r8,0
80003708:	e0 81 02 25 	brne	80003b52 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
8000370c:	30 09       	mov	r9,0
8000370e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003712:	91 09       	st.w	r8[0x0],r9
80003714:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003718:	fe f8 04 94 	ld.w	r8,pc[1172]
8000371c:	11 89       	ld.ub	r9,r8[0x0]
8000371e:	3f 38       	mov	r8,-13
80003720:	f0 09 18 00 	cp.b	r9,r8
80003724:	e0 81 01 0c 	brne	8000393c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003728:	8e 49       	ld.sh	r9,r7[0x8]
8000372a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000372e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003730:	8e 59       	ld.sh	r9,r7[0xa]
80003732:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003734:	8e 69       	ld.sh	r9,r7[0xc]
80003736:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003738:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000373c:	fe f9 04 54 	ld.w	r9,pc[1108]
80003740:	72 0a       	ld.w	r10,r9[0x0]
80003742:	70 09       	ld.w	r9,r8[0x0]
80003744:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003748:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000374c:	70 09       	ld.w	r9,r8[0x0]
8000374e:	2f f9       	sub	r9,-1
80003750:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003752:	e0 49 01 ff 	cp.w	r9,511
80003756:	e0 88 00 16 	brls	80003782 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000375a:	30 09       	mov	r9,0
8000375c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000375e:	fe f6 04 32 	ld.w	r6,pc[1074]
80003762:	6c 0c       	ld.w	r12,r6[0x0]
80003764:	f0 1f 01 16 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003768:	fe f8 04 20 	ld.w	r8,pc[1056]
8000376c:	70 0c       	ld.w	r12,r8[0x0]
8000376e:	f0 1f 01 01 	mcall	80003b70 <phy_rx_func+0xe98>
80003772:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003774:	c0 71       	brne	80003782 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003776:	30 09       	mov	r9,0
80003778:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000377c:	91 09       	st.w	r8[0x0],r9
8000377e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003782:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003786:	72 08       	ld.w	r8,r9[0x0]
80003788:	20 18       	sub	r8,1
8000378a:	93 08       	st.w	r9[0x0],r8
8000378c:	c0 71       	brne	8000379a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000378e:	30 09       	mov	r9,0
80003790:	fe f8 04 04 	ld.w	r8,pc[1028]
80003794:	91 09       	st.w	r8[0x0],r9
80003796:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000379a:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000379e:	fe f9 03 f2 	ld.w	r9,pc[1010]
800037a2:	72 0a       	ld.w	r10,r9[0x0]
800037a4:	70 09       	ld.w	r9,r8[0x0]
800037a6:	ef 3b 00 09 	ld.ub	r11,r7[9]
800037aa:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037ae:	70 09       	ld.w	r9,r8[0x0]
800037b0:	2f f9       	sub	r9,-1
800037b2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037b4:	e0 49 01 ff 	cp.w	r9,511
800037b8:	e0 88 00 16 	brls	800037e4 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800037bc:	30 09       	mov	r9,0
800037be:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037c0:	fe f6 03 d0 	ld.w	r6,pc[976]
800037c4:	6c 0c       	ld.w	r12,r6[0x0]
800037c6:	f0 1f 00 fe 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037ca:	fe f8 03 be 	ld.w	r8,pc[958]
800037ce:	70 0c       	ld.w	r12,r8[0x0]
800037d0:	f0 1f 00 e8 	mcall	80003b70 <phy_rx_func+0xe98>
800037d4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037d6:	c0 71       	brne	800037e4 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800037d8:	30 09       	mov	r9,0
800037da:	fe f8 03 ba 	ld.w	r8,pc[954]
800037de:	91 09       	st.w	r8[0x0],r9
800037e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037e4:	fe f9 03 b8 	ld.w	r9,pc[952]
800037e8:	72 08       	ld.w	r8,r9[0x0]
800037ea:	20 18       	sub	r8,1
800037ec:	93 08       	st.w	r9[0x0],r8
800037ee:	c0 71       	brne	800037fc <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800037f0:	30 09       	mov	r9,0
800037f2:	fe f8 03 a2 	ld.w	r8,pc[930]
800037f6:	91 09       	st.w	r8[0x0],r9
800037f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800037fc:	fe f8 03 b8 	ld.w	r8,pc[952]
80003800:	fe f9 03 90 	ld.w	r9,pc[912]
80003804:	72 0a       	ld.w	r10,r9[0x0]
80003806:	70 09       	ld.w	r9,r8[0x0]
80003808:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000380c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003810:	70 09       	ld.w	r9,r8[0x0]
80003812:	2f f9       	sub	r9,-1
80003814:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003816:	e0 49 01 ff 	cp.w	r9,511
8000381a:	e0 88 00 16 	brls	80003846 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000381e:	30 09       	mov	r9,0
80003820:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003822:	fe f6 03 6e 	ld.w	r6,pc[878]
80003826:	6c 0c       	ld.w	r12,r6[0x0]
80003828:	f0 1f 00 e5 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000382c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003830:	70 0c       	ld.w	r12,r8[0x0]
80003832:	f0 1f 00 d0 	mcall	80003b70 <phy_rx_func+0xe98>
80003836:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003838:	c0 71       	brne	80003846 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000383a:	30 09       	mov	r9,0
8000383c:	fe f8 03 58 	ld.w	r8,pc[856]
80003840:	91 09       	st.w	r8[0x0],r9
80003842:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003846:	fe f9 03 56 	ld.w	r9,pc[854]
8000384a:	72 08       	ld.w	r8,r9[0x0]
8000384c:	20 18       	sub	r8,1
8000384e:	93 08       	st.w	r9[0x0],r8
80003850:	c0 71       	brne	8000385e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003852:	30 09       	mov	r9,0
80003854:	fe f8 03 40 	ld.w	r8,pc[832]
80003858:	91 09       	st.w	r8[0x0],r9
8000385a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000385e:	fe f8 03 56 	ld.w	r8,pc[854]
80003862:	fe f9 03 2e 	ld.w	r9,pc[814]
80003866:	72 0a       	ld.w	r10,r9[0x0]
80003868:	70 09       	ld.w	r9,r8[0x0]
8000386a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000386e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003872:	70 09       	ld.w	r9,r8[0x0]
80003874:	2f f9       	sub	r9,-1
80003876:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003878:	e0 49 01 ff 	cp.w	r9,511
8000387c:	e0 88 00 16 	brls	800038a8 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003880:	30 09       	mov	r9,0
80003882:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003884:	fe f6 03 0c 	ld.w	r6,pc[780]
80003888:	6c 0c       	ld.w	r12,r6[0x0]
8000388a:	f0 1f 00 cd 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000388e:	fe f8 02 fa 	ld.w	r8,pc[762]
80003892:	70 0c       	ld.w	r12,r8[0x0]
80003894:	f0 1f 00 b7 	mcall	80003b70 <phy_rx_func+0xe98>
80003898:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000389a:	c0 71       	brne	800038a8 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
8000389c:	30 09       	mov	r9,0
8000389e:	fe f8 02 f6 	ld.w	r8,pc[758]
800038a2:	91 09       	st.w	r8[0x0],r9
800038a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038a8:	fe f9 02 f4 	ld.w	r9,pc[756]
800038ac:	72 08       	ld.w	r8,r9[0x0]
800038ae:	20 18       	sub	r8,1
800038b0:	93 08       	st.w	r9[0x0],r8
800038b2:	c0 71       	brne	800038c0 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800038b4:	30 09       	mov	r9,0
800038b6:	fe f8 02 de 	ld.w	r8,pc[734]
800038ba:	91 09       	st.w	r8[0x0],r9
800038bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800038c0:	fe f8 02 f4 	ld.w	r8,pc[756]
800038c4:	fe f9 02 cc 	ld.w	r9,pc[716]
800038c8:	72 0a       	ld.w	r10,r9[0x0]
800038ca:	70 09       	ld.w	r9,r8[0x0]
800038cc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800038d0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038d4:	70 09       	ld.w	r9,r8[0x0]
800038d6:	2f f9       	sub	r9,-1
800038d8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038da:	e0 49 01 ff 	cp.w	r9,511
800038de:	e0 88 00 16 	brls	8000390a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800038e2:	30 09       	mov	r9,0
800038e4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038e6:	fe f7 02 aa 	ld.w	r7,pc[682]
800038ea:	6e 0c       	ld.w	r12,r7[0x0]
800038ec:	f0 1f 00 b4 	mcall	80003bbc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038f0:	fe f8 02 98 	ld.w	r8,pc[664]
800038f4:	70 0c       	ld.w	r12,r8[0x0]
800038f6:	f0 1f 00 9f 	mcall	80003b70 <phy_rx_func+0xe98>
800038fa:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038fc:	c0 71       	brne	8000390a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800038fe:	30 09       	mov	r9,0
80003900:	fe f8 02 94 	ld.w	r8,pc[660]
80003904:	91 09       	st.w	r8[0x0],r9
80003906:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000390a:	fe f9 02 92 	ld.w	r9,pc[658]
8000390e:	72 08       	ld.w	r8,r9[0x0]
80003910:	20 18       	sub	r8,1
80003912:	93 08       	st.w	r9[0x0],r8
80003914:	c0 71       	brne	80003922 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003916:	30 09       	mov	r9,0
80003918:	fe f8 02 7c 	ld.w	r8,pc[636]
8000391c:	91 09       	st.w	r8[0x0],r9
8000391e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003922:	20 18       	sub	r8,1
80003924:	fe f9 02 78 	ld.w	r9,pc[632]
80003928:	93 08       	st.w	r9[0x0],r8
8000392a:	58 08       	cp.w	r8,0
8000392c:	e0 81 01 13 	brne	80003b52 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003930:	30 09       	mov	r9,0
80003932:	fe f8 02 62 	ld.w	r8,pc[610]
80003936:	91 09       	st.w	r8[0x0],r9
80003938:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000393c:	fe f8 02 70 	ld.w	r8,pc[624]
80003940:	11 89       	ld.ub	r9,r8[0x0]
80003942:	30 48       	mov	r8,4
80003944:	f0 09 18 00 	cp.b	r9,r8
80003948:	c0 80       	breq	80003958 <phy_rx_func+0xc80>
8000394a:	fe f8 02 62 	ld.w	r8,pc[610]
8000394e:	11 89       	ld.ub	r9,r8[0x0]
80003950:	30 38       	mov	r8,3
80003952:	f0 09 18 00 	cp.b	r9,r8
80003956:	c1 41       	brne	8000397e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003958:	6e 29       	ld.w	r9,r7[0x8]
8000395a:	fe f8 02 7a 	ld.w	r8,pc[634]
8000395e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003960:	6e 39       	ld.w	r9,r7[0xc]
80003962:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003964:	fe f9 02 38 	ld.w	r9,pc[568]
80003968:	72 08       	ld.w	r8,r9[0x0]
8000396a:	20 88       	sub	r8,8
8000396c:	93 08       	st.w	r9[0x0],r8
8000396e:	e0 81 00 f2 	brne	80003b52 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003972:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003974:	fe f9 02 20 	ld.w	r9,pc[544]
80003978:	93 08       	st.w	r9[0x0],r8
8000397a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
8000397e:	fe f8 02 2e 	ld.w	r8,pc[558]
80003982:	11 89       	ld.ub	r9,r8[0x0]
80003984:	31 38       	mov	r8,19
80003986:	f0 09 18 00 	cp.b	r9,r8
8000398a:	e0 81 00 9c 	brne	80003ac2 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
8000398e:	fe f8 02 62 	ld.w	r8,pc[610]
80003992:	11 88       	ld.ub	r8,r8[0x0]
80003994:	30 c9       	mov	r9,12
80003996:	f2 08 18 00 	cp.b	r8,r9
8000399a:	e0 81 00 7b 	brne	80003a90 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
8000399e:	8e 49       	ld.sh	r9,r7[0x8]
800039a0:	fe f8 02 54 	ld.w	r8,pc[596]
800039a4:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800039a8:	30 09       	mov	r9,0
800039aa:	fe f8 02 46 	ld.w	r8,pc[582]
800039ae:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800039b0:	ef 39 00 0d 	ld.ub	r9,r7[13]
800039b4:	3f 38       	mov	r8,-13
800039b6:	f0 09 18 00 	cp.b	r9,r8
800039ba:	c6 61       	brne	80003a86 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800039bc:	10 99       	mov	r9,r8
800039be:	4f c8       	lddpc	r8,80003bac <phy_rx_func+0xed4>
800039c0:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800039c2:	ef 39 00 0c 	ld.ub	r9,r7[12]
800039c6:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800039ca:	4f 58       	lddpc	r8,80003b9c <phy_rx_func+0xec4>
800039cc:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800039ce:	30 19       	mov	r9,1
800039d0:	fe f8 02 0c 	ld.w	r8,pc[524]
800039d4:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800039d6:	8e 79       	ld.sh	r9,r7[0xe]
800039d8:	fe f8 02 14 	ld.w	r8,pc[532]
800039dc:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800039de:	4f 68       	lddpc	r8,80003bb4 <phy_rx_func+0xedc>
800039e0:	4e c9       	lddpc	r9,80003b90 <phy_rx_func+0xeb8>
800039e2:	72 0a       	ld.w	r10,r9[0x0]
800039e4:	70 09       	ld.w	r9,r8[0x0]
800039e6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800039ea:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800039ee:	70 09       	ld.w	r9,r8[0x0]
800039f0:	2f f9       	sub	r9,-1
800039f2:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039f4:	e0 49 01 ff 	cp.w	r9,511
800039f8:	e0 88 00 13 	brls	80003a1e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800039fc:	30 09       	mov	r9,0
800039fe:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a00:	4e 46       	lddpc	r6,80003b90 <phy_rx_func+0xeb8>
80003a02:	6c 0c       	ld.w	r12,r6[0x0]
80003a04:	f0 1f 00 6e 	mcall	80003bbc <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a08:	4e 08       	lddpc	r8,80003b88 <phy_rx_func+0xeb0>
80003a0a:	70 0c       	ld.w	r12,r8[0x0]
80003a0c:	f0 1f 00 59 	mcall	80003b70 <phy_rx_func+0xe98>
80003a10:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a12:	c0 61       	brne	80003a1e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003a14:	30 09       	mov	r9,0
80003a16:	4e 08       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a18:	91 09       	st.w	r8[0x0],r9
80003a1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a1e:	4e 09       	lddpc	r9,80003b9c <phy_rx_func+0xec4>
80003a20:	72 08       	ld.w	r8,r9[0x0]
80003a22:	20 18       	sub	r8,1
80003a24:	93 08       	st.w	r9[0x0],r8
80003a26:	c0 61       	brne	80003a32 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003a28:	30 09       	mov	r9,0
80003a2a:	4d b8       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a2c:	91 09       	st.w	r8[0x0],r9
80003a2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003a32:	4e 18       	lddpc	r8,80003bb4 <phy_rx_func+0xedc>
80003a34:	4d 79       	lddpc	r9,80003b90 <phy_rx_func+0xeb8>
80003a36:	72 0a       	ld.w	r10,r9[0x0]
80003a38:	70 09       	ld.w	r9,r8[0x0]
80003a3a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a3e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a42:	70 09       	ld.w	r9,r8[0x0]
80003a44:	2f f9       	sub	r9,-1
80003a46:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a48:	e0 49 01 ff 	cp.w	r9,511
80003a4c:	e0 88 00 13 	brls	80003a72 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a50:	30 09       	mov	r9,0
80003a52:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a54:	4c f7       	lddpc	r7,80003b90 <phy_rx_func+0xeb8>
80003a56:	6e 0c       	ld.w	r12,r7[0x0]
80003a58:	f0 1f 00 59 	mcall	80003bbc <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a5c:	4c b8       	lddpc	r8,80003b88 <phy_rx_func+0xeb0>
80003a5e:	70 0c       	ld.w	r12,r8[0x0]
80003a60:	f0 1f 00 44 	mcall	80003b70 <phy_rx_func+0xe98>
80003a64:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a66:	c0 61       	brne	80003a72 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003a68:	30 09       	mov	r9,0
80003a6a:	4c b8       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a6c:	91 09       	st.w	r8[0x0],r9
80003a6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a72:	4c b9       	lddpc	r9,80003b9c <phy_rx_func+0xec4>
80003a74:	72 08       	ld.w	r8,r9[0x0]
80003a76:	20 18       	sub	r8,1
80003a78:	93 08       	st.w	r9[0x0],r8
80003a7a:	c6 c1       	brne	80003b52 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003a7c:	30 09       	mov	r9,0
80003a7e:	4c 68       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a80:	91 09       	st.w	r8[0x0],r9
80003a82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003a86:	30 09       	mov	r9,0
80003a88:	4c 38       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003a8a:	91 09       	st.w	r8[0x0],r9
80003a8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003a90:	8e 4a       	ld.sh	r10,r7[0x8]
80003a92:	4d 99       	lddpc	r9,80003bf4 <phy_rx_func+0xf1c>
80003a94:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003a98:	4d 6a       	lddpc	r10,80003bf0 <phy_rx_func+0xf18>
80003a9a:	15 88       	ld.ub	r8,r10[0x0]
80003a9c:	f0 cb ff ff 	sub	r11,r8,-1
80003aa0:	8e 5c       	ld.sh	r12,r7[0xa]
80003aa2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003aa6:	f0 cb ff fe 	sub	r11,r8,-2
80003aaa:	8e 6c       	ld.sh	r12,r7[0xc]
80003aac:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003ab0:	f0 cb ff fd 	sub	r11,r8,-3
80003ab4:	8e 7c       	ld.sh	r12,r7[0xe]
80003ab6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003aba:	2f c8       	sub	r8,-4
80003abc:	b4 88       	st.b	r10[0x0],r8
80003abe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003ac2:	30 09       	mov	r9,0
80003ac4:	4b 48       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003ac6:	91 09       	st.w	r8[0x0],r9
80003ac8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003acc:	4c 08       	lddpc	r8,80003bcc <phy_rx_func+0xef4>
80003ace:	70 09       	ld.w	r9,r8[0x0]
80003ad0:	8e 4b       	ld.sh	r11,r7[0x8]
80003ad2:	4c 0a       	lddpc	r10,80003bd0 <phy_rx_func+0xef8>
80003ad4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003ad8:	2f f9       	sub	r9,-1
80003ada:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003adc:	4b 58       	lddpc	r8,80003bb0 <phy_rx_func+0xed8>
80003ade:	70 09       	ld.w	r9,r8[0x0]
80003ae0:	20 29       	sub	r9,2
80003ae2:	91 09       	st.w	r8[0x0],r9
80003ae4:	70 08       	ld.w	r8,r8[0x0]
80003ae6:	58 08       	cp.w	r8,0
80003ae8:	c2 f1       	brne	80003b46 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003aea:	30 09       	mov	r9,0
80003aec:	4b 88       	lddpc	r8,80003bcc <phy_rx_func+0xef4>
80003aee:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003af0:	8e 59       	ld.sh	r9,r7[0xa]
80003af2:	fe 78 82 12 	mov	r8,-32238
80003af6:	f0 09 19 00 	cp.h	r9,r8
80003afa:	c2 11       	brne	80003b3c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003afc:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003b00:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003b04:	4a f8       	lddpc	r8,80003bc0 <phy_rx_func+0xee8>
80003b06:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003b08:	8e 59       	ld.sh	r9,r7[0xa]
80003b0a:	4a f8       	lddpc	r8,80003bc4 <phy_rx_func+0xeec>
80003b0c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003b0e:	8e 69       	ld.sh	r9,r7[0xc]
80003b10:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003b12:	f0 1f 00 2e 	mcall	80003bc8 <phy_rx_func+0xef0>
80003b16:	4a 18       	lddpc	r8,80003b98 <phy_rx_func+0xec0>
80003b18:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b1a:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003b1e:	31 38       	mov	r8,19
80003b20:	f0 09 18 00 	cp.b	r9,r8
80003b24:	c0 71       	brne	80003b32 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003b26:	10 99       	mov	r9,r8
80003b28:	4a 18       	lddpc	r8,80003bac <phy_rx_func+0xed4>
80003b2a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003b2c:	30 09       	mov	r9,0
80003b2e:	49 c8       	lddpc	r8,80003b9c <phy_rx_func+0xec4>
80003b30:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003b32:	30 49       	mov	r9,4
80003b34:	49 88       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003b36:	91 09       	st.w	r8[0x0],r9
80003b38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003b3c:	30 09       	mov	r9,0
80003b3e:	49 68       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003b40:	91 09       	st.w	r8[0x0],r9
80003b42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003b46:	4a dc       	lddpc	r12,80003bf8 <phy_rx_func+0xf20>
80003b48:	f0 1f 00 18 	mcall	80003ba8 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003b4c:	30 09       	mov	r9,0
80003b4e:	49 28       	lddpc	r8,80003b94 <phy_rx_func+0xebc>
80003b50:	91 09       	st.w	r8[0x0],r9
80003b52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b56:	00 00       	add	r0,r0
80003b58:	00 00       	add	r0,r0
80003b5a:	0a a4       	st.w	r5++,r4
80003b5c:	00 00       	add	r0,r0
80003b5e:	0a bc       	st.h	r5++,r12
80003b60:	00 00       	add	r0,r0
80003b62:	0a 9c       	mov	r12,r5
80003b64:	00 00       	add	r0,r0
80003b66:	0a 7e       	tst	lr,r5
80003b68:	00 00       	add	r0,r0
80003b6a:	0a 6c       	and	r12,r5
80003b6c:	00 00       	add	r0,r0
80003b6e:	0a 94       	mov	r4,r5
80003b70:	80 00       	ld.sh	r0,r0[0x0]
80003b72:	2b 60       	sub	r0,-74
80003b74:	00 00       	add	r0,r0
80003b76:	0a 8c       	andn	r12,r5
80003b78:	80 00       	ld.sh	r0,r0[0x0]
80003b7a:	2a 78       	sub	r8,-89
80003b7c:	00 00       	add	r0,r0
80003b7e:	0a a0       	st.w	r5++,r0
80003b80:	80 00       	ld.sh	r0,r0[0x0]
80003b82:	2a ac       	sub	r12,-86
80003b84:	00 00       	add	r0,r0
80003b86:	0a 7d       	tst	sp,r5
80003b88:	00 00       	add	r0,r0
80003b8a:	0a 98       	mov	r8,r5
80003b8c:	00 00       	add	r0,r0
80003b8e:	0a a8       	st.w	r5++,r8
80003b90:	00 00       	add	r0,r0
80003b92:	0a 80       	andn	r0,r5
80003b94:	00 00       	add	r0,r0
80003b96:	0a c8       	st.b	r5++,r8
80003b98:	00 00       	add	r0,r0
80003b9a:	0a b0       	st.h	r5++,r0
80003b9c:	00 00       	add	r0,r0
80003b9e:	0a 68       	and	r8,r5
80003ba0:	00 00       	add	r0,r0
80003ba2:	0a 44       	or	r4,r5
80003ba4:	80 00       	ld.sh	r0,r0[0x0]
80003ba6:	d1 c8       	*unknown*
80003ba8:	80 00       	ld.sh	r0,r0[0x0]
80003baa:	6b c4       	ld.w	r4,r5[0x70]
80003bac:	00 00       	add	r0,r0
80003bae:	0a 7c       	tst	r12,r5
80003bb0:	00 00       	add	r0,r0
80003bb2:	0a d4       	st.w	--r5,r4
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a b4       	st.h	r5++,r4
80003bb8:	80 00       	ld.sh	r0,r0[0x0]
80003bba:	73 f4       	ld.w	r4,r9[0x7c]
80003bbc:	80 00       	ld.sh	r0,r0[0x0]
80003bbe:	2a 94       	sub	r4,-87
80003bc0:	00 00       	add	r0,r0
80003bc2:	0a 3a       	cp.w	r10,r5
80003bc4:	00 00       	add	r0,r0
80003bc6:	1e 90       	mov	r0,pc
80003bc8:	80 00       	ld.sh	r0,r0[0x0]
80003bca:	2a 48       	sub	r8,-92
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 70       	tst	r0,r5
80003bd0:	00 00       	add	r0,r0
80003bd2:	1d 94       	ld.ub	r4,lr[0x1]
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a 74       	tst	r4,r5
80003bd8:	00 00       	add	r0,r0
80003bda:	0a 40       	or	r0,r5
80003bdc:	00 00       	add	r0,r0
80003bde:	0a 43       	or	r3,r5
80003be0:	00 00       	add	r0,r0
80003be2:	0a cc       	st.b	r5++,r12
80003be4:	00 00       	add	r0,r0
80003be6:	0a 88       	andn	r8,r5
80003be8:	00 00       	add	r0,r0
80003bea:	0a 55       	eor	r5,r5
80003bec:	00 00       	add	r0,r0
80003bee:	1d 8c       	ld.ub	r12,lr[0x0]
80003bf0:	00 00       	add	r0,r0
80003bf2:	0a c0       	st.b	r5++,r0
80003bf4:	00 00       	add	r0,r0
80003bf6:	1e 94       	mov	r4,pc
80003bf8:	80 00       	ld.sh	r0,r0[0x0]
80003bfa:	d1 e0       	acall	0x1e

80003bfc <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003bfc:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003bfe:	49 a8       	lddpc	r8,80003c64 <pdca_int_handler+0x68>
80003c00:	70 09       	ld.w	r9,r8[0x0]
80003c02:	2f f9       	sub	r9,-1
80003c04:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003c06:	49 98       	lddpc	r8,80003c68 <pdca_int_handler+0x6c>
80003c08:	11 89       	ld.ub	r9,r8[0x0]
80003c0a:	ec 19 00 01 	eorl	r9,0x1
80003c0e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003c10:	11 89       	ld.ub	r9,r8[0x0]
80003c12:	a5 69       	lsl	r9,0x4
80003c14:	2f c9       	sub	r9,-4
80003c16:	49 6a       	lddpc	r10,80003c6c <pdca_int_handler+0x70>
80003c18:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003c1a:	fe 7a 00 40 	mov	r10,-65472
80003c1e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c20:	30 39       	mov	r9,3
80003c22:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c24:	11 8a       	ld.ub	r10,r8[0x0]
80003c26:	a5 6a       	lsl	r10,0x4
80003c28:	2f ca       	sub	r10,-4
80003c2a:	49 28       	lddpc	r8,80003c70 <pdca_int_handler+0x74>
80003c2c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c2e:	fe 78 00 00 	mov	r8,-65536
80003c32:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c34:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c36:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c38:	48 f8       	lddpc	r8,80003c74 <pdca_int_handler+0x78>
80003c3a:	70 08       	ld.w	r8,r8[0x0]
80003c3c:	58 08       	cp.w	r8,0
80003c3e:	c0 70       	breq	80003c4c <pdca_int_handler+0x50>
80003c40:	48 a9       	lddpc	r9,80003c68 <pdca_int_handler+0x6c>
80003c42:	13 89       	ld.ub	r9,r9[0x0]
80003c44:	a5 69       	lsl	r9,0x4
80003c46:	48 bc       	lddpc	r12,80003c70 <pdca_int_handler+0x74>
80003c48:	12 0c       	add	r12,r9
80003c4a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c4c:	48 b8       	lddpc	r8,80003c78 <pdca_int_handler+0x7c>
80003c4e:	70 08       	ld.w	r8,r8[0x0]
80003c50:	58 08       	cp.w	r8,0
80003c52:	c0 70       	breq	80003c60 <pdca_int_handler+0x64>
80003c54:	48 59       	lddpc	r9,80003c68 <pdca_int_handler+0x6c>
80003c56:	13 89       	ld.ub	r9,r9[0x0]
80003c58:	a5 69       	lsl	r9,0x4
80003c5a:	48 5c       	lddpc	r12,80003c6c <pdca_int_handler+0x70>
80003c5c:	12 0c       	add	r12,r9
80003c5e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003c60:	d4 02       	popm	lr
80003c62:	d6 03       	rete
80003c64:	00 00       	add	r0,r0
80003c66:	0a dc       	st.w	--r5,r12
80003c68:	00 00       	add	r0,r0
80003c6a:	96 b4       	ld.uh	r4,r11[0x6]
80003c6c:	00 00       	add	r0,r0
80003c6e:	96 dc       	ld.uh	r12,r11[0xa]
80003c70:	00 00       	add	r0,r0
80003c72:	96 bc       	ld.uh	r12,r11[0x6]
80003c74:	00 00       	add	r0,r0
80003c76:	0a d8       	st.w	--r5,r8
80003c78:	00 00       	add	r0,r0
80003c7a:	0a e0       	st.h	--r5,r0

80003c7c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003c7c:	fe 78 10 00 	mov	r8,-61440
80003c80:	e0 69 0d c0 	mov	r9,3520
80003c84:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003c88:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003c8c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003c90:	fe 78 34 00 	mov	r8,-52224
80003c94:	e0 69 80 00 	mov	r9,32768
80003c98:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003c9a:	30 09       	mov	r9,0
80003c9c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003c9e:	e0 69 04 21 	mov	r9,1057
80003ca2:	ea 19 3f 20 	orh	r9,0x3f20
80003ca6:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003ca8:	e0 69 02 9f 	mov	r9,671
80003cac:	ea 19 01 00 	orh	r9,0x100
80003cb0:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003cb2:	e0 6a 04 02 	mov	r10,1026
80003cb6:	ea 1a 3f 20 	orh	r10,0x3f20
80003cba:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003cbc:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003cbe:	5e fc       	retal	r12

80003cc0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003cc0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003cc2:	30 19       	mov	r9,1
80003cc4:	49 78       	lddpc	r8,80003d20 <local_start_PDC+0x60>
80003cc6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003cc8:	fe 78 00 00 	mov	r8,-65536
80003ccc:	30 7b       	mov	r11,7
80003cce:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003cd0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003cd2:	49 59       	lddpc	r9,80003d24 <local_start_PDC+0x64>
80003cd4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003cd8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003cda:	30 3a       	mov	r10,3
80003cdc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003cde:	30 1c       	mov	r12,1
80003ce0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003ce2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003ce4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003ce6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ce8:	30 2c       	mov	r12,2
80003cea:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003cec:	48 f9       	lddpc	r9,80003d28 <local_start_PDC+0x68>
80003cee:	e0 68 5a 5a 	mov	r8,23130
80003cf2:	ea 18 ab cd 	orh	r8,0xabcd
80003cf6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003cf8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003cfa:	30 0e       	mov	lr,0
80003cfc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003cfe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003d00:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003d02:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003d04:	fe 78 00 40 	mov	r8,-65472
80003d08:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003d0a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003d0c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003d10:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003d12:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003d14:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003d16:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003d18:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d1a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d1c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003d1e:	d8 02       	popm	pc
80003d20:	00 00       	add	r0,r0
80003d22:	96 b4       	ld.uh	r4,r11[0x6]
80003d24:	00 00       	add	r0,r0
80003d26:	96 bc       	ld.uh	r12,r11[0x6]
80003d28:	00 00       	add	r0,r0
80003d2a:	96 dc       	ld.uh	r12,r11[0xa]

80003d2c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d2c:	48 38       	lddpc	r8,80003d38 <register_rx_tx_func+0xc>
80003d2e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d30:	48 38       	lddpc	r8,80003d3c <register_rx_tx_func+0x10>
80003d32:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d34:	5e fc       	retal	r12
80003d36:	00 00       	add	r0,r0
80003d38:	00 00       	add	r0,r0
80003d3a:	0a d8       	st.w	--r5,r8
80003d3c:	00 00       	add	r0,r0
80003d3e:	0a e0       	st.h	--r5,r0

80003d40 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d40:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d42:	fe 78 10 00 	mov	r8,-61440
80003d46:	30 29       	mov	r9,2
80003d48:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d4c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003d50:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003d52:	30 3a       	mov	r10,3
80003d54:	36 0b       	mov	r11,96
80003d56:	49 4c       	lddpc	r12,80003da4 <ssc_init+0x64>
80003d58:	f0 1f 00 14 	mcall	80003da8 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003d5c:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003d5e:	fe 79 10 00 	mov	r9,-61440
80003d62:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d66:	e2 18 00 02 	andl	r8,0x2,COH
80003d6a:	cf c0       	breq	80003d62 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003d6c:	fe 79 10 00 	mov	r9,-61440
80003d70:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d74:	e2 18 00 02 	andl	r8,0x2,COH
80003d78:	cf c1       	brne	80003d70 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003d7a:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003d7c:	f0 1f 00 0c 	mcall	80003dac <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003d80:	f0 1f 00 0c 	mcall	80003db0 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d84:	fe 79 00 00 	mov	r9,-65536
80003d88:	30 18       	mov	r8,1
80003d8a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d8c:	fe 7a 00 40 	mov	r10,-65472
80003d90:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003d92:	e0 6b 01 01 	mov	r11,257
80003d96:	fe 7a 34 00 	mov	r10,-52224
80003d9a:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003d9c:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003d9e:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003da0:	d8 02       	popm	pc
80003da2:	00 00       	add	r0,r0
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	3b fc       	mov	r12,-65
80003da8:	80 00       	ld.sh	r0,r0[0x0]
80003daa:	51 84       	stdsp	sp[0x60],r4
80003dac:	80 00       	ld.sh	r0,r0[0x0]
80003dae:	3c 7c       	mov	r12,-57
80003db0:	80 00       	ld.sh	r0,r0[0x0]
80003db2:	3c c0       	mov	r0,-52

80003db4 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003db4:	48 28       	lddpc	r8,80003dbc <xcmp_register_app_list+0x8>
80003db6:	91 0c       	st.w	r8[0x0],r12
}
80003db8:	5e fc       	retal	r12
80003dba:	00 00       	add	r0,r0
80003dbc:	00 00       	add	r0,r0
80003dbe:	96 fc       	ld.uh	r12,r11[0xe]

80003dc0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003dc0:	eb cd 40 80 	pushm	r7,lr
80003dc4:	fa cd 01 00 	sub	sp,sp,256
80003dc8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003dca:	16 98       	mov	r8,r11
80003dcc:	2f 08       	sub	r8,-16
80003dce:	af a8       	sbr	r8,0xe
80003dd0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003dd2:	3f f8       	mov	r8,-1
80003dd4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003dd6:	30 b9       	mov	r9,11
80003dd8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003dda:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ddc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003dde:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003de0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003de2:	f6 ca ff fe 	sub	r10,r11,-2
80003de6:	18 9b       	mov	r11,r12
80003de8:	fa cc ff f0 	sub	r12,sp,-16
80003dec:	f0 1f 00 05 	mcall	80003e00 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003df0:	2f e7       	sub	r7,-2
80003df2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003df4:	1a 9c       	mov	r12,sp
80003df6:	f0 1f 00 04 	mcall	80003e04 <xcmp_tx+0x44>
}
80003dfa:	2c 0d       	sub	sp,-256
80003dfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e00:	80 00       	ld.sh	r0,r0[0x0]
80003e02:	72 ac       	ld.w	r12,r9[0x28]
80003e04:	80 00       	ld.sh	r0,r0[0x0]
80003e06:	43 d8       	lddsp	r8,sp[0xf4]

80003e08 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80003e08:	d4 21       	pushm	r4-r7,lr
80003e0a:	fa cd 00 d0 	sub	sp,sp,208
80003e0e:	18 94       	mov	r4,r12
80003e10:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003e12:	e0 68 01 00 	mov	r8,256
80003e16:	f0 0b 19 00 	cp.h	r11,r8
80003e1a:	e0 8b 00 38 	brhi	80003e8a <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003e1e:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003e22:	e0 68 04 1d 	mov	r8,1053
80003e26:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003e28:	30 18       	mov	r8,1
80003e2a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003e2c:	32 08       	mov	r8,32
80003e2e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003e30:	30 28       	mov	r8,2
80003e32:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003e34:	30 48       	mov	r8,4
80003e36:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003e38:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80003e3c:	ea 1a 0c 00 	orh	r10,0xc00
80003e40:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003e42:	30 4a       	mov	r10,4
80003e44:	1a 9b       	mov	r11,sp
80003e46:	fa cc ff f4 	sub	r12,sp,-12
80003e4a:	f0 1f 00 12 	mcall	80003e90 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003e4e:	30 f8       	mov	r8,15
80003e50:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003e54:	3a 78       	mov	r8,-89
80003e56:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003e5a:	30 08       	mov	r8,0
80003e5c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003e60:	0e 9a       	mov	r10,r7
80003e62:	5c 7a       	castu.h	r10
80003e64:	f4 08 16 08 	lsr	r8,r10,0x8
80003e68:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003e6c:	0e 96       	mov	r6,r7
80003e6e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003e72:	08 9b       	mov	r11,r4
80003e74:	fa cc ff eb 	sub	r12,sp,-21
80003e78:	f0 1f 00 06 	mcall	80003e90 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003e7c:	ee cb ff f3 	sub	r11,r7,-13
80003e80:	5c 5b       	castu.b	r11
80003e82:	fa cc ff fa 	sub	r12,sp,-6
80003e86:	f0 1f 00 04 	mcall	80003e94 <xcmp_data_session_req+0x8c>
}
80003e8a:	2c cd       	sub	sp,-208
80003e8c:	d8 22       	popm	r4-r7,pc
80003e8e:	00 00       	add	r0,r0
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	72 ac       	ld.w	r12,r9[0x28]
80003e94:	80 00       	ld.sh	r0,r0[0x0]
80003e96:	3d c0       	mov	r0,-36

80003e98 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003e98:	d4 01       	pushm	lr
80003e9a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003e9e:	fe 78 b4 00 	mov	r8,-19456
80003ea2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003ea4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = XCMP_Version[0];
80003ea8:	48 c9       	lddpc	r9,80003ed8 <xcmp_DeviceInitializationStatus_request+0x40>
80003eaa:	13 8a       	ld.ub	r10,r9[0x0]
80003eac:	b0 8a       	st.b	r8[0x0],r10
	ptr->XCMPVersion[1] = XCMP_Version[1];
80003eae:	13 9a       	ld.ub	r10,r9[0x1]
80003eb0:	b0 9a       	st.b	r8[0x1],r10
	ptr->XCMPVersion[2] = XCMP_Version[2];
80003eb2:	13 aa       	ld.ub	r10,r9[0x2]
80003eb4:	b0 aa       	st.b	r8[0x2],r10
	ptr->XCMPVersion[3] = XCMP_Version[3];
80003eb6:	13 b9       	ld.ub	r9,r9[0x3]
80003eb8:	b0 b9       	st.b	r8[0x3],r9
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003eba:	30 09       	mov	r9,0
80003ebc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003ebe:	30 7a       	mov	r10,7
80003ec0:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003ec2:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003ec4:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003ec6:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003eca:	30 9b       	mov	r11,9
80003ecc:	fa cc ff fe 	sub	r12,sp,-2
80003ed0:	f0 1f 00 03 	mcall	80003edc <xcmp_DeviceInitializationStatus_request+0x44>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003ed4:	2c dd       	sub	sp,-204
80003ed6:	d8 02       	popm	pc
80003ed8:	00 00       	add	r0,r0
80003eda:	0d 78       	ld.ub	r8,--r6
80003edc:	80 00       	ld.sh	r0,r0[0x0]
80003ede:	3d c0       	mov	r0,-36

80003ee0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003ee0:	d4 01       	pushm	lr
80003ee2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003ee6:	fe 78 80 00 	mov	r8,-32768
80003eea:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003eec:	30 38       	mov	r8,3
80003eee:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003ef0:	30 1b       	mov	r11,1
80003ef2:	fa cc ff fe 	sub	r12,sp,-2
80003ef6:	f0 1f 00 03 	mcall	80003f00 <xcmp_opcode_not_supported+0x20>
}
80003efa:	2c dd       	sub	sp,-204
80003efc:	d8 02       	popm	pc
80003efe:	00 00       	add	r0,r0
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	3d c0       	mov	r0,-36

80003f04 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003f04:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003f06:	96 88       	ld.uh	r8,r11[0x0]
80003f08:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f0c:	e0 48 80 00 	cp.w	r8,32768
80003f10:	c0 f0       	breq	80003f2e <xcmp_exec_func+0x2a>
80003f12:	e0 48 b0 00 	cp.w	r8,45056
80003f16:	c1 20       	breq	80003f3a <xcmp_exec_func+0x36>
80003f18:	58 08       	cp.w	r8,0
80003f1a:	c1 51       	brne	80003f44 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f1c:	78 08       	ld.w	r8,r12[0x0]
80003f1e:	58 08       	cp.w	r8,0
80003f20:	c0 40       	breq	80003f28 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f22:	16 9c       	mov	r12,r11
80003f24:	5d 18       	icall	r8
80003f26:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003f28:	f0 1f 00 08 	mcall	80003f48 <xcmp_exec_func+0x44>
80003f2c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003f2e:	78 18       	ld.w	r8,r12[0x4]
80003f30:	58 08       	cp.w	r8,0
80003f32:	c0 90       	breq	80003f44 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003f34:	16 9c       	mov	r12,r11
80003f36:	5d 18       	icall	r8
80003f38:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003f3a:	78 28       	ld.w	r8,r12[0x8]
80003f3c:	58 08       	cp.w	r8,0
80003f3e:	c0 30       	breq	80003f44 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003f40:	16 9c       	mov	r12,r11
80003f42:	5d 18       	icall	r8
80003f44:	d8 02       	popm	pc
80003f46:	00 00       	add	r0,r0
80003f48:	80 00       	ld.sh	r0,r0[0x0]
80003f4a:	3e e0       	mov	r0,-18

80003f4c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003f4c:	d4 01       	pushm	lr
80003f4e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003f52:	e0 68 04 09 	mov	r8,1033
80003f56:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f58:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003f5c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003f5e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003f62:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003f64:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003f66:	30 09       	mov	r9,0
80003f68:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003f6a:	fb 69 00 08 	st.b	sp[8],r9
80003f6e:	fa c8 ff f7 	sub	r8,sp,-9
80003f72:	b0 89       	st.b	r8[0x0],r9
80003f74:	fa c8 ff f6 	sub	r8,sp,-10
80003f78:	b0 89       	st.b	r8[0x0],r9
80003f7a:	fa c8 ff f5 	sub	r8,sp,-11
80003f7e:	b0 89       	st.b	r8[0x0],r9
80003f80:	fa c8 ff f4 	sub	r8,sp,-12
80003f84:	b0 89       	st.b	r8[0x0],r9
80003f86:	fa c8 ff f3 	sub	r8,sp,-13
80003f8a:	b0 89       	st.b	r8[0x0],r9
80003f8c:	fa c8 ff f2 	sub	r8,sp,-14
80003f90:	b0 89       	st.b	r8[0x0],r9
80003f92:	fa c8 ff f1 	sub	r8,sp,-15
80003f96:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003f98:	30 cb       	mov	r11,12
80003f9a:	fa cc ff fe 	sub	r12,sp,-2
80003f9e:	f0 1f 00 03 	mcall	80003fa8 <xcmp_IdleTestTone+0x5c>
}
80003fa2:	2c dd       	sub	sp,-204
80003fa4:	d8 02       	popm	pc
80003fa6:	00 00       	add	r0,r0
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	3d c0       	mov	r0,-36

80003fac <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003fac:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003fae:	48 dc       	lddpc	r12,80003fe0 <xcmp_init+0x34>
80003fb0:	f0 1f 00 0d 	mcall	80003fe4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003fb4:	30 4b       	mov	r11,4
80003fb6:	31 4c       	mov	r12,20
80003fb8:	f0 1f 00 0c 	mcall	80003fe8 <xcmp_init+0x3c>
80003fbc:	48 c8       	lddpc	r8,80003fec <xcmp_init+0x40>
80003fbe:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003fc0:	30 09       	mov	r9,0
80003fc2:	1a d9       	st.w	--sp,r9
80003fc4:	1a d9       	st.w	--sp,r9
80003fc6:	1a d9       	st.w	--sp,r9
80003fc8:	30 38       	mov	r8,3
80003fca:	e0 6a 04 00 	mov	r10,1024
80003fce:	48 9b       	lddpc	r11,80003ff0 <xcmp_init+0x44>
80003fd0:	48 9c       	lddpc	r12,80003ff4 <xcmp_init+0x48>
80003fd2:	f0 1f 00 0a 	mcall	80003ff8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003fd6:	f0 1f 00 0a 	mcall	80003ffc <xcmp_init+0x50>
80003fda:	2f dd       	sub	sp,-12
	
}
80003fdc:	d8 02       	popm	pc
80003fde:	00 00       	add	r0,r0
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	40 fc       	lddsp	r12,sp[0x3c]
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	41 48       	lddsp	r8,sp[0x50]
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	5f 58       	srlt	r8
80003fec:	00 00       	add	r0,r0
80003fee:	0a fc       	st.b	--r5,r12
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	d2 0c       	*unknown*
80003ff4:	80 00       	ld.sh	r0,r0[0x0]
80003ff6:	40 00       	lddsp	r0,sp[0x0]
80003ff8:	80 00       	ld.sh	r0,r0[0x0]
80003ffa:	66 74       	ld.w	r4,r3[0x1c]
80003ffc:	80 00       	ld.sh	r0,r0[0x0]
80003ffe:	41 80       	lddsp	r0,sp[0x60]

80004000 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004000:	d4 31       	pushm	r0-r7,lr
80004002:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004004:	4b 16       	lddpc	r6,800040c8 <xcmp_rx_process+0xc8>
80004006:	30 05       	mov	r5,0
80004008:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000400a:	4b 13       	lddpc	r3,800040cc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000400c:	4b 12       	lddpc	r2,800040d0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000400e:	4b 21       	lddpc	r1,800040d4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004010:	4b 20       	lddpc	r0,800040d8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004012:	6c 0c       	ld.w	r12,r6[0x0]
80004014:	0a 99       	mov	r9,r5
80004016:	08 9a       	mov	r10,r4
80004018:	1a 9b       	mov	r11,sp
8000401a:	f0 1f 00 31 	mcall	800040dc <xcmp_rx_process+0xdc>
8000401e:	58 1c       	cp.w	r12,1
80004020:	cf 91       	brne	80004012 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004022:	40 0b       	lddsp	r11,sp[0x0]
80004024:	58 0b       	cp.w	r11,0
80004026:	cf 60       	breq	80004012 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004028:	96 0a       	ld.sh	r10,r11[0x0]
8000402a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000402e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004032:	59 c8       	cp.w	r8,28
80004034:	c1 e0       	breq	80004070 <xcmp_rx_process+0x70>
80004036:	e0 89 00 07 	brgt	80004044 <xcmp_rx_process+0x44>
8000403a:	58 e8       	cp.w	r8,14
8000403c:	c0 e0       	breq	80004058 <xcmp_rx_process+0x58>
8000403e:	58 f8       	cp.w	r8,15
80004040:	c2 41       	brne	80004088 <xcmp_rx_process+0x88>
80004042:	c0 f8       	rjmp	80004060 <xcmp_rx_process+0x60>
80004044:	e0 48 01 09 	cp.w	r8,265
80004048:	c1 80       	breq	80004078 <xcmp_rx_process+0x78>
8000404a:	e0 48 01 0a 	cp.w	r8,266
8000404e:	c1 90       	breq	80004080 <xcmp_rx_process+0x80>
80004050:	e0 48 00 2c 	cp.w	r8,44
80004054:	c1 a1       	brne	80004088 <xcmp_rx_process+0x88>
80004056:	c0 98       	rjmp	80004068 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004058:	4a 2c       	lddpc	r12,800040e0 <xcmp_rx_process+0xe0>
8000405a:	f0 1f 00 23 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
8000405e:	c2 f8       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004060:	4a 2c       	lddpc	r12,800040e8 <xcmp_rx_process+0xe8>
80004062:	f0 1f 00 21 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
80004066:	c2 b8       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004068:	4a 1c       	lddpc	r12,800040ec <xcmp_rx_process+0xec>
8000406a:	f0 1f 00 1f 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
8000406e:	c2 78       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004070:	04 9c       	mov	r12,r2
80004072:	f0 1f 00 1d 	mcall	800040e4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004076:	c2 38       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004078:	02 9c       	mov	r12,r1
8000407a:	f0 1f 00 1b 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
8000407e:	c1 f8       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004080:	00 9c       	mov	r12,r0
80004082:	f0 1f 00 19 	mcall	800040e4 <xcmp_rx_process+0xe4>
					break;
80004086:	c1 b8       	rjmp	800040bc <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004088:	12 98       	mov	r8,r9
8000408a:	e2 18 04 00 	andl	r8,0x400,COH
8000408e:	c0 70       	breq	8000409c <xcmp_rx_process+0x9c>
80004090:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004094:	e0 48 00 68 	cp.w	r8,104
80004098:	e0 8a 00 08 	brle	800040a8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000409c:	e2 19 f0 00 	andl	r9,0xf000,COH
800040a0:	c0 e1       	brne	800040bc <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800040a2:	f0 1f 00 14 	mcall	800040f0 <xcmp_rx_process+0xf0>
800040a6:	c0 b8       	rjmp	800040bc <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800040a8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800040ac:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800040b0:	49 19       	lddpc	r9,800040f4 <xcmp_rx_process+0xf4>
800040b2:	72 08       	ld.w	r8,r9[0x0]
800040b4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800040b8:	f0 1f 00 0b 	mcall	800040e4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040bc:	66 0c       	ld.w	r12,r3[0x0]
800040be:	40 0b       	lddsp	r11,sp[0x0]
800040c0:	f0 1f 00 0e 	mcall	800040f8 <xcmp_rx_process+0xf8>
800040c4:	ca 7b       	rjmp	80004012 <xcmp_rx_process+0x12>
800040c6:	00 00       	add	r0,r0
800040c8:	00 00       	add	r0,r0
800040ca:	0a fc       	st.b	--r5,r12
800040cc:	00 00       	add	r0,r0
800040ce:	0a 94       	mov	r4,r5
800040d0:	00 00       	add	r0,r0
800040d2:	0b 0c       	ld.w	r12,r5++
800040d4:	00 00       	add	r0,r0
800040d6:	0b 00       	ld.w	r0,r5++
800040d8:	00 00       	add	r0,r0
800040da:	0a f0       	st.b	--r5,r0
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	5b f4       	cp.w	r4,-1
800040e0:	00 00       	add	r0,r0
800040e2:	0b 24       	ld.uh	r4,r5++
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	3f 04       	mov	r4,-16
800040e8:	00 00       	add	r0,r0
800040ea:	0a e4       	st.h	--r5,r4
800040ec:	00 00       	add	r0,r0
800040ee:	0b 18       	ld.sh	r8,r5++
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	3e e0       	mov	r0,-18
800040f4:	00 00       	add	r0,r0
800040f6:	96 fc       	ld.uh	r12,r11[0xe]
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	2a e4       	sub	r4,-82

800040fc <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800040fc:	eb cd 40 90 	pushm	r4,r7,lr
80004100:	20 1d       	sub	sp,4
80004102:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004106:	48 c8       	lddpc	r8,80004134 <xcmp_rx+0x38>
80004108:	70 0c       	ld.w	r12,r8[0x0]
8000410a:	f0 1f 00 0c 	mcall	80004138 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000410e:	c1 00       	breq	8000412e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004110:	fa c7 ff fc 	sub	r7,sp,-4
80004114:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004116:	e0 6a 00 ca 	mov	r10,202
8000411a:	08 9b       	mov	r11,r4
8000411c:	f0 1f 00 08 	mcall	8000413c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004120:	48 88       	lddpc	r8,80004140 <xcmp_rx+0x44>
80004122:	70 0c       	ld.w	r12,r8[0x0]
80004124:	30 09       	mov	r9,0
80004126:	12 9a       	mov	r10,r9
80004128:	1a 9b       	mov	r11,sp
8000412a:	f0 1f 00 07 	mcall	80004144 <xcmp_rx+0x48>
	}	
}
8000412e:	2f fd       	sub	sp,-4
80004130:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004134:	00 00       	add	r0,r0
80004136:	0a 94       	mov	r4,r5
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	2c 90       	sub	r0,-55
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	72 ac       	ld.w	r12,r9[0x28]
80004140:	00 00       	add	r0,r0
80004142:	0a fc       	st.b	--r5,r12
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	5e 00       	reteq	r0

80004148 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004148:	48 28       	lddpc	r8,80004150 <xnl_register_xcmp_func+0x8>
8000414a:	91 0c       	st.w	r8[0x0],r12
}
8000414c:	5e fc       	retal	r12
8000414e:	00 00       	add	r0,r0
80004150:	00 00       	add	r0,r0
80004152:	0b 48       	ld.w	r8,--r5

80004154 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004154:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004156:	48 88       	lddpc	r8,80004174 <xnl_get_msg_ack_func+0x20>
80004158:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000415a:	98 49       	ld.sh	r9,r12[0x8]
8000415c:	f0 09 19 00 	cp.h	r9,r8
80004160:	c0 81       	brne	80004170 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004162:	48 68       	lddpc	r8,80004178 <xnl_get_msg_ack_func+0x24>
80004164:	70 0c       	ld.w	r12,r8[0x0]
80004166:	30 09       	mov	r9,0
80004168:	12 9a       	mov	r10,r9
8000416a:	12 9b       	mov	r11,r9
8000416c:	f0 1f 00 04 	mcall	8000417c <xnl_get_msg_ack_func+0x28>
80004170:	d8 02       	popm	pc
80004172:	00 00       	add	r0,r0
80004174:	00 00       	add	r0,r0
80004176:	97 00       	st.w	r11[0x0],r0
80004178:	00 00       	add	r0,r0
8000417a:	0b 30       	ld.ub	r0,r5++
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	5e 00       	reteq	r0

80004180 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004180:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004184:	30 09       	mov	r9,0
80004186:	4b 78       	lddpc	r8,80004260 <xnl_init+0xe0>
80004188:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000418a:	30 0b       	mov	r11,0
8000418c:	30 1c       	mov	r12,1
8000418e:	f0 1f 00 36 	mcall	80004264 <xnl_init+0xe4>
80004192:	4b 68       	lddpc	r8,80004268 <xnl_init+0xe8>
80004194:	91 0c       	st.w	r8[0x0],r12
80004196:	70 08       	ld.w	r8,r8[0x0]
80004198:	58 08       	cp.w	r8,0
8000419a:	c0 80       	breq	800041aa <xnl_init+0x2a>
8000419c:	4b 38       	lddpc	r8,80004268 <xnl_init+0xe8>
8000419e:	70 0c       	ld.w	r12,r8[0x0]
800041a0:	30 09       	mov	r9,0
800041a2:	12 9a       	mov	r10,r9
800041a4:	12 9b       	mov	r11,r9
800041a6:	f0 1f 00 32 	mcall	8000426c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800041aa:	30 4b       	mov	r11,4
800041ac:	33 2c       	mov	r12,50
800041ae:	f0 1f 00 2e 	mcall	80004264 <xnl_init+0xe4>
800041b2:	4b 08       	lddpc	r8,80004270 <xnl_init+0xf0>
800041b4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800041b6:	30 4b       	mov	r11,4
800041b8:	36 4c       	mov	r12,100
800041ba:	f0 1f 00 2b 	mcall	80004264 <xnl_init+0xe4>
800041be:	4a e8       	lddpc	r8,80004274 <xnl_init+0xf4>
800041c0:	91 0c       	st.w	r8[0x0],r12
800041c2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800041c4:	10 96       	mov	r6,r8
800041c6:	4a d5       	lddpc	r5,80004278 <xnl_init+0xf8>
800041c8:	6c 0c       	ld.w	r12,r6[0x0]
800041ca:	ea 07 00 0b 	add	r11,r5,r7
800041ce:	f0 1f 00 2c 	mcall	8000427c <xnl_init+0xfc>
800041d2:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800041d6:	e0 47 64 00 	cp.w	r7,25600
800041da:	cf 71       	brne	800041c8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041dc:	30 4b       	mov	r11,4
800041de:	31 4c       	mov	r12,20
800041e0:	f0 1f 00 21 	mcall	80004264 <xnl_init+0xe4>
800041e4:	4a 78       	lddpc	r8,80004280 <xnl_init+0x100>
800041e6:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041e8:	30 4b       	mov	r11,4
800041ea:	31 4c       	mov	r12,20
800041ec:	f0 1f 00 1e 	mcall	80004264 <xnl_init+0xe4>
800041f0:	4a 58       	lddpc	r8,80004284 <xnl_init+0x104>
800041f2:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800041f4:	30 4b       	mov	r11,4
800041f6:	30 ac       	mov	r12,10
800041f8:	f0 1f 00 1b 	mcall	80004264 <xnl_init+0xe4>
800041fc:	4a 38       	lddpc	r8,80004288 <xnl_init+0x108>
800041fe:	91 0c       	st.w	r8[0x0],r12
80004200:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004202:	10 96       	mov	r6,r8
80004204:	4a 25       	lddpc	r5,8000428c <xnl_init+0x10c>
80004206:	6c 0c       	ld.w	r12,r6[0x0]
80004208:	ea 07 00 0b 	add	r11,r5,r7
8000420c:	f0 1f 00 1c 	mcall	8000427c <xnl_init+0xfc>
80004210:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004214:	e0 47 14 00 	cp.w	r7,5120
80004218:	cf 71       	brne	80004206 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000421a:	30 4b       	mov	r11,4
8000421c:	30 5c       	mov	r12,5
8000421e:	f0 1f 00 12 	mcall	80004264 <xnl_init+0xe4>
80004222:	49 c8       	lddpc	r8,80004290 <xnl_init+0x110>
80004224:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004226:	30 07       	mov	r7,0
80004228:	1a d7       	st.w	--sp,r7
8000422a:	1a d7       	st.w	--sp,r7
8000422c:	1a d7       	st.w	--sp,r7
8000422e:	30 38       	mov	r8,3
80004230:	0e 99       	mov	r9,r7
80004232:	e0 6a 02 00 	mov	r10,512
80004236:	49 8b       	lddpc	r11,80004294 <xnl_init+0x114>
80004238:	49 8c       	lddpc	r12,80004298 <xnl_init+0x118>
8000423a:	f0 1f 00 19 	mcall	8000429c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000423e:	1a d7       	st.w	--sp,r7
80004240:	1a d7       	st.w	--sp,r7
80004242:	1a d7       	st.w	--sp,r7
80004244:	30 38       	mov	r8,3
80004246:	0e 99       	mov	r9,r7
80004248:	e0 6a 00 82 	mov	r10,130
8000424c:	49 5b       	lddpc	r11,800042a0 <xnl_init+0x120>
8000424e:	49 6c       	lddpc	r12,800042a4 <xnl_init+0x124>
80004250:	f0 1f 00 13 	mcall	8000429c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004254:	f0 1f 00 15 	mcall	800042a8 <xnl_init+0x128>
80004258:	2f ad       	sub	sp,-24
}
8000425a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000425e:	00 00       	add	r0,r0
80004260:	00 00       	add	r0,r0
80004262:	97 00       	st.w	r11[0x0],r0
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	5f 58       	srlt	r8
80004268:	00 00       	add	r0,r0
8000426a:	0b 30       	ld.ub	r0,r5++
8000426c:	80 00       	ld.sh	r0,r0[0x0]
8000426e:	5e 00       	reteq	r0
80004270:	00 00       	add	r0,r0
80004272:	0b 3c       	ld.ub	r12,r5++
80004274:	00 00       	add	r0,r0
80004276:	0a 94       	mov	r4,r5
80004278:	00 00       	add	r0,r0
8000427a:	32 ae       	mov	lr,42
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	2a e4       	sub	r4,-82
80004280:	00 00       	add	r0,r0
80004282:	0a c4       	st.b	r5++,r4
80004284:	00 00       	add	r0,r0
80004286:	0a a4       	st.w	r5++,r4
80004288:	00 00       	add	r0,r0
8000428a:	0a 98       	mov	r8,r5
8000428c:	00 00       	add	r0,r0
8000428e:	1e ae       	st.w	pc++,lr
80004290:	00 00       	add	r0,r0
80004292:	0a d0       	st.w	--r5,r0
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	d2 14       	*unknown*
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	42 ac       	lddsp	r12,sp[0xa8]
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	66 74       	ld.w	r4,r3[0x1c]
800042a0:	80 00       	ld.sh	r0,r0[0x0]
800042a2:	d2 1c       	*unknown*
800042a4:	80 00       	ld.sh	r0,r0[0x0]
800042a6:	43 0c       	lddsp	r12,sp[0xc0]
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	2c b8       	sub	r8,-53

800042ac <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800042ac:	eb cd 40 fe 	pushm	r1-r7,lr
800042b0:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042b2:	49 26       	lddpc	r6,800042f8 <xnl_rx_process+0x4c>
800042b4:	30 05       	mov	r5,0
800042b6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042b8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ba:	49 11       	lddpc	r1,800042fc <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042bc:	49 12       	lddpc	r2,80004300 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042be:	6c 0c       	ld.w	r12,r6[0x0]
800042c0:	0a 99       	mov	r9,r5
800042c2:	08 9a       	mov	r10,r4
800042c4:	1a 9b       	mov	r11,sp
800042c6:	f0 1f 00 10 	mcall	80004304 <xnl_rx_process+0x58>
800042ca:	58 1c       	cp.w	r12,1
800042cc:	cf 91       	brne	800042be <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800042ce:	40 0c       	lddsp	r12,sp[0x0]
800042d0:	58 0c       	cp.w	r12,0
800042d2:	cf 60       	breq	800042be <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042d4:	98 28       	ld.sh	r8,r12[0x4]
800042d6:	e6 08 19 00 	cp.h	r8,r3
800042da:	e0 8b 00 0a 	brhi	800042ee <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042de:	5c 78       	castu.h	r8
800042e0:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800042e4:	58 09       	cp.w	r9,0
800042e6:	c0 40       	breq	800042ee <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800042e8:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800042ec:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ee:	62 0c       	ld.w	r12,r1[0x0]
800042f0:	40 0b       	lddsp	r11,sp[0x0]
800042f2:	f0 1f 00 06 	mcall	80004308 <xnl_rx_process+0x5c>
800042f6:	ce 4b       	rjmp	800042be <xnl_rx_process+0x12>
800042f8:	00 00       	add	r0,r0
800042fa:	0a a4       	st.w	r5++,r4
800042fc:	00 00       	add	r0,r0
800042fe:	0a 94       	mov	r4,r5
80004300:	00 00       	add	r0,r0
80004302:	04 f4       	st.b	--r2,r4
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	5b f4       	cp.w	r4,-1
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	2a e4       	sub	r4,-82

8000430c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
8000430c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000430e:	4a a6       	lddpc	r6,800043b4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004310:	4a a2       	lddpc	r2,800043b8 <xnl_tx_process+0xac>
80004312:	4a b4       	lddpc	r4,800043bc <xnl_tx_process+0xb0>
80004314:	30 07       	mov	r7,0
80004316:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004318:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000431a:	4a a5       	lddpc	r5,800043c0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000431c:	4a a3       	lddpc	r3,800043c4 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000431e:	6c 08       	ld.w	r8,r6[0x0]
80004320:	58 08       	cp.w	r8,0
80004322:	c0 40       	breq	8000432a <xnl_tx_process+0x1e>
80004324:	58 18       	cp.w	r8,1
80004326:	cf d1       	brne	80004320 <xnl_tx_process+0x14>
80004328:	c2 48       	rjmp	80004370 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000432a:	64 0c       	ld.w	r12,r2[0x0]
8000432c:	0e 99       	mov	r9,r7
8000432e:	02 9a       	mov	r10,r1
80004330:	08 9b       	mov	r11,r4
80004332:	f0 1f 00 26 	mcall	800043c8 <xnl_tx_process+0xbc>
80004336:	58 1c       	cp.w	r12,1
80004338:	cf 31       	brne	8000431e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000433a:	68 0b       	ld.w	r11,r4[0x0]
8000433c:	58 0b       	cp.w	r11,0
8000433e:	cf 00       	breq	8000431e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004340:	96 28       	ld.sh	r8,r11[0x4]
80004342:	e0 08 19 00 	cp.h	r8,r0
80004346:	c0 71       	brne	80004354 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004348:	4a 18       	lddpc	r8,800043cc <xnl_tx_process+0xc0>
8000434a:	70 08       	ld.w	r8,r8[0x0]
8000434c:	10 9c       	mov	r12,r8
8000434e:	f0 1f 00 21 	mcall	800043d0 <xnl_tx_process+0xc4>
						break;
80004352:	ce 6b       	rjmp	8000431e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004354:	16 9c       	mov	r12,r11
80004356:	f0 1f 00 20 	mcall	800043d4 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000435a:	30 18       	mov	r8,1
8000435c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000435e:	66 0c       	ld.w	r12,r3[0x0]
80004360:	0e 99       	mov	r9,r7
80004362:	0e 9a       	mov	r10,r7
80004364:	0e 9b       	mov	r11,r7
80004366:	f0 1f 00 19 	mcall	800043c8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000436a:	30 18       	mov	r8,1
8000436c:	8d 08       	st.w	r6[0x0],r8
8000436e:	cd 8b       	rjmp	8000431e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004370:	66 0c       	ld.w	r12,r3[0x0]
80004372:	0e 99       	mov	r9,r7
80004374:	36 4a       	mov	r10,100
80004376:	0e 9b       	mov	r11,r7
80004378:	f0 1f 00 14 	mcall	800043c8 <xnl_tx_process+0xbc>
8000437c:	58 1c       	cp.w	r12,1
8000437e:	c0 81       	brne	8000438e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004380:	49 38       	lddpc	r8,800043cc <xnl_tx_process+0xc0>
80004382:	70 0c       	ld.w	r12,r8[0x0]
80004384:	68 0b       	ld.w	r11,r4[0x0]
80004386:	f0 1f 00 13 	mcall	800043d0 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000438a:	8d 07       	st.w	r6[0x0],r7
8000438c:	cc 9b       	rjmp	8000431e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000438e:	6a 08       	ld.w	r8,r5[0x0]
80004390:	58 38       	cp.w	r8,3
80004392:	e0 89 00 09 	brgt	800043a4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004396:	68 0c       	ld.w	r12,r4[0x0]
80004398:	f0 1f 00 0f 	mcall	800043d4 <xnl_tx_process+0xc8>
						xnl_send_times++;
8000439c:	6a 08       	ld.w	r8,r5[0x0]
8000439e:	2f f8       	sub	r8,-1
800043a0:	8b 08       	st.w	r5[0x0],r8
800043a2:	cb eb       	rjmp	8000431e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800043a4:	48 a8       	lddpc	r8,800043cc <xnl_tx_process+0xc0>
800043a6:	70 0c       	ld.w	r12,r8[0x0]
800043a8:	68 0b       	ld.w	r11,r4[0x0]
800043aa:	f0 1f 00 0a 	mcall	800043d0 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800043ae:	8d 07       	st.w	r6[0x0],r7
800043b0:	cb 7b       	rjmp	8000431e <xnl_tx_process+0x12>
800043b2:	00 00       	add	r0,r0
800043b4:	00 00       	add	r0,r0
800043b6:	0b 38       	ld.ub	r8,r5++
800043b8:	00 00       	add	r0,r0
800043ba:	0b 3c       	ld.ub	r12,r5++
800043bc:	00 00       	add	r0,r0
800043be:	0b 44       	ld.w	r4,--r5
800043c0:	00 00       	add	r0,r0
800043c2:	0b 40       	ld.w	r0,--r5
800043c4:	00 00       	add	r0,r0
800043c6:	0b 30       	ld.ub	r0,r5++
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	5b f4       	cp.w	r4,-1
800043cc:	00 00       	add	r0,r0
800043ce:	0a 94       	mov	r4,r5
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	2a e4       	sub	r4,-82
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	2b 04       	sub	r4,-80

800043d8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800043d8:	eb cd 40 c0 	pushm	r6-r7,lr
800043dc:	20 1d       	sub	sp,4
800043de:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800043e0:	98 39       	ld.sh	r9,r12[0x6]
800043e2:	3f f8       	mov	r8,-1
800043e4:	f0 09 19 00 	cp.h	r9,r8
800043e8:	c0 a1       	brne	800043fc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800043ea:	4a e9       	lddpc	r9,800044a0 <xnl_tx+0xc8>
800043ec:	13 88       	ld.ub	r8,r9[0x0]
800043ee:	2f f8       	sub	r8,-1
800043f0:	5c 58       	castu.b	r8
800043f2:	b2 88       	st.b	r9[0x0],r8
800043f4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043f8:	a9 a8       	sbr	r8,0x8
800043fa:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043fc:	8c 49       	ld.sh	r9,r6[0x8]
800043fe:	3f f8       	mov	r8,-1
80004400:	f0 09 19 00 	cp.h	r9,r8
80004404:	c0 41       	brne	8000440c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004406:	4a 88       	lddpc	r8,800044a4 <xnl_tx+0xcc>
80004408:	90 18       	ld.sh	r8,r8[0x2]
8000440a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000440c:	8c 59       	ld.sh	r9,r6[0xa]
8000440e:	3f f8       	mov	r8,-1
80004410:	f0 09 19 00 	cp.h	r9,r8
80004414:	c0 41       	brne	8000441c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004416:	4a 48       	lddpc	r8,800044a4 <xnl_tx+0xcc>
80004418:	90 28       	ld.sh	r8,r8[0x4]
8000441a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000441c:	8c 69       	ld.sh	r9,r6[0xc]
8000441e:	3f f8       	mov	r8,-1
80004420:	f0 09 19 00 	cp.h	r9,r8
80004424:	c0 e1       	brne	80004440 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004426:	4a 08       	lddpc	r8,800044a4 <xnl_tx+0xcc>
80004428:	90 49       	ld.sh	r9,r8[0x8]
8000442a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000442c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000442e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004430:	90 49       	ld.sh	r9,r8[0x8]
80004432:	e0 19 ff 00 	andl	r9,0xff00
80004436:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000443a:	f3 e8 10 08 	or	r8,r9,r8
8000443e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004440:	0d 98       	ld.ub	r8,r6[0x1]
80004442:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004444:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004448:	10 0c       	add	r12,r8
8000444a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000444c:	58 0c       	cp.w	r12,0
8000444e:	e0 89 00 04 	brgt	80004456 <xnl_tx+0x7e>
80004452:	30 09       	mov	r9,0
80004454:	c0 d8       	rjmp	8000446e <xnl_tx+0x96>
80004456:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000445a:	2f ec       	sub	r12,-2
8000445c:	30 09       	mov	r9,0
8000445e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004460:	15 1b       	ld.sh	r11,r10++
80004462:	f6 09 00 09 	add	r9,r11,r9
80004466:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004468:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000446a:	18 38       	cp.w	r8,r12
8000446c:	cf a1       	brne	80004460 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000446e:	5c 39       	neg	r9
80004470:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004472:	48 e8       	lddpc	r8,800044a8 <xnl_tx+0xd0>
80004474:	70 0c       	ld.w	r12,r8[0x0]
80004476:	f0 1f 00 0e 	mcall	800044ac <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000447a:	c1 00       	breq	8000449a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000447c:	fa c7 ff fc 	sub	r7,sp,-4
80004480:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004482:	e0 6a 01 00 	mov	r10,256
80004486:	0c 9b       	mov	r11,r6
80004488:	f0 1f 00 0a 	mcall	800044b0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000448c:	48 a8       	lddpc	r8,800044b4 <xnl_tx+0xdc>
8000448e:	70 0c       	ld.w	r12,r8[0x0]
80004490:	30 09       	mov	r9,0
80004492:	12 9a       	mov	r10,r9
80004494:	1a 9b       	mov	r11,sp
80004496:	f0 1f 00 09 	mcall	800044b8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000449a:	2f fd       	sub	sp,-4
8000449c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800044a0:	00 00       	add	r0,r0
800044a2:	0b 34       	ld.ub	r4,r5++
800044a4:	00 00       	add	r0,r0
800044a6:	97 00       	st.w	r11[0x0],r0
800044a8:	00 00       	add	r0,r0
800044aa:	0a 94       	mov	r4,r5
800044ac:	80 00       	ld.sh	r0,r0[0x0]
800044ae:	2c 90       	sub	r0,-55
800044b0:	80 00       	ld.sh	r0,r0[0x0]
800044b2:	72 ac       	ld.w	r12,r9[0x28]
800044b4:	00 00       	add	r0,r0
800044b6:	0b 3c       	ld.ub	r12,r5++
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	5e 00       	reteq	r0

800044bc <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044bc:	eb cd 40 80 	pushm	r7,lr
800044c0:	fa cd 01 00 	sub	sp,sp,256
800044c4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044c6:	e0 68 40 0e 	mov	r8,16398
800044ca:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044cc:	3f f8       	mov	r8,-1
800044ce:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800044d0:	30 c8       	mov	r8,12
800044d2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800044d4:	98 38       	ld.sh	r8,r12[0x6]
800044d6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800044d8:	98 58       	ld.sh	r8,r12[0xa]
800044da:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800044dc:	98 48       	ld.sh	r8,r12[0x8]
800044de:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800044e0:	98 68       	ld.sh	r8,r12[0xc]
800044e2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800044e4:	30 08       	mov	r8,0
800044e6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044e8:	1a 9c       	mov	r12,sp
800044ea:	f0 1f 00 0a 	mcall	80004510 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800044ee:	fa cd 00 cc 	sub	sp,sp,204
800044f2:	e0 6a 00 ca 	mov	r10,202
800044f6:	ee cb ff f0 	sub	r11,r7,-16
800044fa:	1a 9c       	mov	r12,sp
800044fc:	f0 1f 00 06 	mcall	80004514 <xnl_data_msg_func+0x58>
80004500:	48 68       	lddpc	r8,80004518 <xnl_data_msg_func+0x5c>
80004502:	70 08       	ld.w	r8,r8[0x0]
80004504:	5d 18       	icall	r8
80004506:	fa cd ff 34 	sub	sp,sp,-204
}
8000450a:	2c 0d       	sub	sp,-256
8000450c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	43 d8       	lddsp	r8,sp[0xf4]
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	72 ac       	ld.w	r12,r9[0x28]
80004518:	00 00       	add	r0,r0
8000451a:	0b 48       	ld.w	r8,--r5

8000451c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000451c:	d4 21       	pushm	r4-r7,lr
8000451e:	fa cd 01 00 	sub	sp,sp,256
80004522:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004524:	4c 28       	lddpc	r8,8000462c <xnl_device_auth_reply_func+0x110>
80004526:	11 88       	ld.ub	r8,r8[0x0]
80004528:	58 08       	cp.w	r8,0
8000452a:	e0 81 00 7f 	brne	80004628 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000452e:	4c 18       	lddpc	r8,80004630 <xnl_device_auth_reply_func+0x114>
80004530:	70 0c       	ld.w	r12,r8[0x0]
80004532:	30 09       	mov	r9,0
80004534:	12 9a       	mov	r10,r9
80004536:	12 9b       	mov	r11,r9
80004538:	f0 1f 00 3f 	mcall	80004634 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000453c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004540:	4b b8       	lddpc	r8,8000462c <xnl_device_auth_reply_func+0x110>
80004542:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004544:	ef 39 00 12 	ld.ub	r9,r7[18]
80004548:	ef 38 00 13 	ld.ub	r8,r7[19]
8000454c:	b1 68       	lsl	r8,0x10
8000454e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004552:	ef 38 00 15 	ld.ub	r8,r7[21]
80004556:	f3 e8 10 08 	or	r8,r9,r8
8000455a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000455e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004562:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004566:	ef 38 00 17 	ld.ub	r8,r7[23]
8000456a:	b1 68       	lsl	r8,0x10
8000456c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004570:	ef 38 00 19 	ld.ub	r8,r7[25]
80004574:	f5 e8 10 08 	or	r8,r10,r8
80004578:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000457c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004580:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004582:	e0 64 79 b9 	mov	r4,31161
80004586:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000458a:	e0 65 45 07 	mov	r5,17671
8000458e:	ea 15 8a bd 	orh	r5,0x8abd
80004592:	e0 66 f9 3d 	mov	r6,63805
80004596:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000459a:	e0 6e b8 cf 	mov	lr,47311
8000459e:	ea 1e 36 83 	orh	lr,0x3683
800045a2:	e0 67 aa 1c 	mov	r7,43548
800045a6:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045aa:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045ac:	f4 08 00 0c 	add	r12,r10,r8
800045b0:	f0 0b 15 04 	lsl	r11,r8,0x4
800045b4:	0a 0b       	add	r11,r5
800045b6:	f9 eb 20 0b 	eor	r11,r12,r11
800045ba:	f0 0c 16 05 	lsr	r12,r8,0x5
800045be:	0c 0c       	add	r12,r6
800045c0:	18 5b       	eor	r11,r12
800045c2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045c4:	f2 0c 15 04 	lsl	r12,r9,0x4
800045c8:	1c 0c       	add	r12,lr
800045ca:	f2 0b 16 05 	lsr	r11,r9,0x5
800045ce:	0e 0b       	add	r11,r7
800045d0:	f9 eb 20 0b 	eor	r11,r12,r11
800045d4:	f2 0a 00 0c 	add	r12,r9,r10
800045d8:	18 5b       	eor	r11,r12
800045da:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800045dc:	e0 6b 37 20 	mov	r11,14112
800045e0:	ea 1b c6 ef 	orh	r11,0xc6ef
800045e4:	16 3a       	cp.w	r10,r11
800045e6:	ce 21       	brne	800045aa <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800045e8:	e0 6a 40 1a 	mov	r10,16410
800045ec:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045ee:	3f fa       	mov	r10,-1
800045f0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800045f2:	30 6b       	mov	r11,6
800045f4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045f6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045f8:	48 db       	lddpc	r11,8000462c <xnl_device_auth_reply_func+0x110>
800045fa:	96 1c       	ld.sh	r12,r11[0x2]
800045fc:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800045fe:	96 2b       	ld.sh	r11,r11[0x4]
80004600:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004602:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004604:	30 ca       	mov	r10,12
80004606:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004608:	30 0a       	mov	r10,0
8000460a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000460e:	30 7a       	mov	r10,7
80004610:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004614:	30 2a       	mov	r10,2
80004616:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000461a:	fa ca ff ec 	sub	r10,sp,-20
8000461e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004620:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004622:	1a 9c       	mov	r12,sp
80004624:	f0 1f 00 05 	mcall	80004638 <xnl_device_auth_reply_func+0x11c>
}
80004628:	2c 0d       	sub	sp,-256
8000462a:	d8 22       	popm	r4-r7,pc
8000462c:	00 00       	add	r0,r0
8000462e:	97 00       	st.w	r11[0x0],r0
80004630:	00 00       	add	r0,r0
80004632:	0b 30       	ld.ub	r0,r5++
80004634:	80 00       	ld.sh	r0,r0[0x0]
80004636:	5e 00       	reteq	r0
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	43 d8       	lddsp	r8,sp[0xf4]

8000463c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000463c:	eb cd 40 80 	pushm	r7,lr
80004640:	fa cd 01 00 	sub	sp,sp,256
80004644:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004646:	49 28       	lddpc	r8,8000468c <xnl_master_status_brdcst_func+0x50>
80004648:	11 88       	ld.ub	r8,r8[0x0]
8000464a:	58 08       	cp.w	r8,0
8000464c:	c1 c1       	brne	80004684 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000464e:	49 18       	lddpc	r8,80004690 <xnl_master_status_brdcst_func+0x54>
80004650:	70 0c       	ld.w	r12,r8[0x0]
80004652:	30 09       	mov	r9,0
80004654:	12 9a       	mov	r10,r9
80004656:	12 9b       	mov	r11,r9
80004658:	f0 1f 00 0f 	mcall	80004694 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000465c:	8e 58       	ld.sh	r8,r7[0xa]
8000465e:	48 c9       	lddpc	r9,8000468c <xnl_master_status_brdcst_func+0x50>
80004660:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004662:	e0 68 40 0e 	mov	r8,16398
80004666:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004668:	3f f8       	mov	r8,-1
8000466a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000466c:	30 4a       	mov	r10,4
8000466e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004670:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004672:	92 19       	ld.sh	r9,r9[0x2]
80004674:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004676:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004678:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000467a:	30 08       	mov	r8,0
8000467c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000467e:	1a 9c       	mov	r12,sp
80004680:	f0 1f 00 06 	mcall	80004698 <xnl_master_status_brdcst_func+0x5c>
}
80004684:	2c 0d       	sub	sp,-256
80004686:	e3 cd 80 80 	ldm	sp++,r7,pc
8000468a:	00 00       	add	r0,r0
8000468c:	00 00       	add	r0,r0
8000468e:	97 00       	st.w	r11[0x0],r0
80004690:	00 00       	add	r0,r0
80004692:	0b 30       	ld.ub	r0,r5++
80004694:	80 00       	ld.sh	r0,r0[0x0]
80004696:	5e 00       	reteq	r0
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	43 d8       	lddsp	r8,sp[0xf4]

8000469c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000469c:	eb cd 40 80 	pushm	r7,lr
800046a0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800046a2:	49 28       	lddpc	r8,800046e8 <xnl_device_conn_reply_func+0x4c>
800046a4:	70 0c       	ld.w	r12,r8[0x0]
800046a6:	30 09       	mov	r9,0
800046a8:	12 9a       	mov	r10,r9
800046aa:	12 9b       	mov	r11,r9
800046ac:	f0 1f 00 10 	mcall	800046ec <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046b0:	ef 18 00 10 	ld.uh	r8,r7[16]
800046b4:	10 99       	mov	r9,r8
800046b6:	e2 19 ff 00 	andl	r9,0xff00,COH
800046ba:	e0 49 01 00 	cp.w	r9,256
800046be:	c0 60       	breq	800046ca <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046c0:	0e 9c       	mov	r12,r7
800046c2:	f0 1f 00 0c 	mcall	800046f0 <xnl_device_conn_reply_func+0x54>
800046c6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800046ca:	a9 68       	lsl	r8,0x8
800046cc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800046d0:	48 98       	lddpc	r8,800046f4 <xnl_device_conn_reply_func+0x58>
800046d2:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800046d4:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800046d8:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800046da:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800046de:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800046e0:	30 19       	mov	r9,1
800046e2:	b0 89       	st.b	r8[0x0],r9
800046e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800046e8:	00 00       	add	r0,r0
800046ea:	0b 30       	ld.ub	r0,r5++
800046ec:	80 00       	ld.sh	r0,r0[0x0]
800046ee:	5e 00       	reteq	r0
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	46 3c       	lddsp	r12,sp[0x18c]
800046f4:	00 00       	add	r0,r0
800046f6:	97 00       	st.w	r11[0x0],r0

800046f8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800046f8:	d4 01       	pushm	lr
800046fa:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046fe:	e0 68 40 0e 	mov	r8,16398
80004702:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004704:	3f f8       	mov	r8,-1
80004706:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004708:	30 38       	mov	r8,3
8000470a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
8000470c:	30 08       	mov	r8,0
8000470e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004710:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004712:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004714:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004716:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004718:	1a 9c       	mov	r12,sp
8000471a:	f0 1f 00 03 	mcall	80004724 <xnl_send_device_master_query+0x2c>
}
8000471e:	2c 0d       	sub	sp,-256
80004720:	d8 02       	popm	pc
80004722:	00 00       	add	r0,r0
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	43 d8       	lddsp	r8,sp[0xf4]

80004728 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004728:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
8000472c:	48 76       	lddpc	r6,80004748 <RC522_ReadByte+0x20>
8000472e:	e0 6b 00 ff 	mov	r11,255
80004732:	6c 0c       	ld.w	r12,r6[0x0]
80004734:	f0 1f 00 06 	mcall	8000474c <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004738:	30 07       	mov	r7,0
8000473a:	0e 9b       	mov	r11,r7
8000473c:	6c 0c       	ld.w	r12,r6[0x0]
8000473e:	f0 1f 00 05 	mcall	80004750 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80004742:	0f 9c       	ld.ub	r12,r7[0x1]
80004744:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004748:	00 00       	add	r0,r0
8000474a:	1d 88       	ld.ub	r8,lr[0x0]
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	53 e0       	stdsp	sp[0xf8],r0
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	53 fc       	stdsp	sp[0xfc],r12

80004754 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004754:	eb cd 40 80 	pushm	r7,lr
80004758:	20 1d       	sub	sp,4
8000475a:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
8000475c:	48 77       	lddpc	r7,80004778 <RC522_WriteByte+0x24>
8000475e:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80004762:	6e 0c       	ld.w	r12,r7[0x0]
80004764:	f0 1f 00 06 	mcall	8000477c <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004768:	1a 9b       	mov	r11,sp
8000476a:	6e 0c       	ld.w	r12,r7[0x0]
8000476c:	f0 1f 00 05 	mcall	80004780 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004770:	5c 5c       	castu.b	r12
80004772:	2f fd       	sub	sp,-4
80004774:	e3 cd 80 80 	ldm	sp++,r7,pc
80004778:	00 00       	add	r0,r0
8000477a:	1d 88       	ld.ub	r8,lr[0x0]
8000477c:	80 00       	ld.sh	r0,r0[0x0]
8000477e:	53 e0       	stdsp	sp[0xf8],r0
80004780:	80 00       	ld.sh	r0,r0[0x0]
80004782:	53 fc       	stdsp	sp[0xfc],r12

80004784 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004784:	eb cd 40 e0 	pushm	r5-r7,lr
80004788:	18 96       	mov	r6,r12
8000478a:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000478c:	48 a7       	lddpc	r7,800047b4 <WriteRawRC+0x30>
8000478e:	30 0b       	mov	r11,0
80004790:	6e 0c       	ld.w	r12,r7[0x0]
80004792:	f0 1f 00 0a 	mcall	800047b8 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004796:	ec 0c 15 01 	lsl	r12,r6,0x1
8000479a:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000479e:	f0 1f 00 08 	mcall	800047bc <WriteRawRC+0x38>
	RC522_WriteByte(value);
800047a2:	0a 9c       	mov	r12,r5
800047a4:	f0 1f 00 06 	mcall	800047bc <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800047a8:	30 0b       	mov	r11,0
800047aa:	6e 0c       	ld.w	r12,r7[0x0]
800047ac:	f0 1f 00 05 	mcall	800047c0 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800047b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800047b4:	00 00       	add	r0,r0
800047b6:	1d 88       	ld.ub	r8,lr[0x0]
800047b8:	80 00       	ld.sh	r0,r0[0x0]
800047ba:	54 5c       	stdsp	sp[0x114],r12
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	47 54       	lddsp	r4,sp[0x1d4]
800047c0:	80 00       	ld.sh	r0,r0[0x0]
800047c2:	54 1c       	stdsp	sp[0x104],r12

800047c4 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800047c4:	d4 01       	pushm	lr

	SET_RC522RST;
800047c6:	31 9c       	mov	r12,25
800047c8:	f0 1f 00 1b 	mcall	80004834 <PcdReset+0x70>
	delay_ns(10);
800047cc:	30 ac       	mov	r12,10
800047ce:	f0 1f 00 1b 	mcall	80004838 <PcdReset+0x74>

	CLR_RC522RST;
800047d2:	31 9c       	mov	r12,25
800047d4:	f0 1f 00 1a 	mcall	8000483c <PcdReset+0x78>
	delay_ns(10);
800047d8:	30 ac       	mov	r12,10
800047da:	f0 1f 00 18 	mcall	80004838 <PcdReset+0x74>

	SET_RC522RST;
800047de:	31 9c       	mov	r12,25
800047e0:	f0 1f 00 15 	mcall	80004834 <PcdReset+0x70>
	delay_ns(10);
800047e4:	30 ac       	mov	r12,10
800047e6:	f0 1f 00 15 	mcall	80004838 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047ea:	30 fb       	mov	r11,15
800047ec:	30 1c       	mov	r12,1
800047ee:	f0 1f 00 15 	mcall	80004840 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047f2:	30 fb       	mov	r11,15
800047f4:	30 1c       	mov	r12,1
800047f6:	f0 1f 00 13 	mcall	80004840 <PcdReset+0x7c>
	delay_ns(10);
800047fa:	30 ac       	mov	r12,10
800047fc:	f0 1f 00 0f 	mcall	80004838 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004800:	33 db       	mov	r11,61
80004802:	31 1c       	mov	r12,17
80004804:	f0 1f 00 0f 	mcall	80004840 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004808:	31 eb       	mov	r11,30
8000480a:	32 dc       	mov	r12,45
8000480c:	f0 1f 00 0d 	mcall	80004840 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004810:	30 0b       	mov	r11,0
80004812:	32 cc       	mov	r12,44
80004814:	f0 1f 00 0b 	mcall	80004840 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004818:	e0 6b 00 8d 	mov	r11,141
8000481c:	32 ac       	mov	r12,42
8000481e:	f0 1f 00 09 	mcall	80004840 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004822:	33 eb       	mov	r11,62
80004824:	32 bc       	mov	r12,43
80004826:	f0 1f 00 07 	mcall	80004840 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000482a:	34 0b       	mov	r11,64
8000482c:	31 5c       	mov	r12,21
8000482e:	f0 1f 00 05 	mcall	80004840 <PcdReset+0x7c>
	
	return MI_OK;
}
80004832:	d8 0a       	popm	pc,r12=0
80004834:	80 00       	ld.sh	r0,r0[0x0]
80004836:	51 48       	stdsp	sp[0x50],r8
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	4f 50       	lddpc	r0,80004a0c <PcdComMF522+0xd8>
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	51 64       	stdsp	sp[0x58],r4
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	47 84       	lddsp	r4,sp[0x1e0]

80004844 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004844:	eb cd 40 c0 	pushm	r6-r7,lr
80004848:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000484a:	48 c7       	lddpc	r7,80004878 <ReadRawRC+0x34>
8000484c:	30 0b       	mov	r11,0
8000484e:	6e 0c       	ld.w	r12,r7[0x0]
80004850:	f0 1f 00 0b 	mcall	8000487c <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004854:	a1 76       	lsl	r6,0x1
80004856:	0c 9c       	mov	r12,r6
80004858:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000485c:	a7 bc       	sbr	r12,0x7
8000485e:	f0 1f 00 09 	mcall	80004880 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80004862:	f0 1f 00 09 	mcall	80004884 <ReadRawRC+0x40>
80004866:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004868:	30 0b       	mov	r11,0
8000486a:	6e 0c       	ld.w	r12,r7[0x0]
8000486c:	f0 1f 00 07 	mcall	80004888 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004870:	0c 9c       	mov	r12,r6
80004872:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004876:	00 00       	add	r0,r0
80004878:	00 00       	add	r0,r0
8000487a:	1d 88       	ld.ub	r8,lr[0x0]
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	54 5c       	stdsp	sp[0x114],r12
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	47 54       	lddsp	r4,sp[0x1d4]
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	47 28       	lddsp	r8,sp[0x1c8]
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	54 1c       	stdsp	sp[0x104],r12

8000488c <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
8000488c:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
8000488e:	30 1c       	mov	r12,1
80004890:	f0 1f 00 02 	mcall	80004898 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004894:	d8 02       	popm	pc
80004896:	00 00       	add	r0,r0
80004898:	80 00       	ld.sh	r0,r0[0x0]
8000489a:	48 44       	lddpc	r4,800048a8 <Powerdown_RC522+0xc>

8000489c <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
8000489c:	eb cd 40 80 	pushm	r7,lr
800048a0:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800048a2:	30 1c       	mov	r12,1
800048a4:	f0 1f 00 0d 	mcall	800048d8 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800048a8:	30 18       	mov	r8,1
800048aa:	f0 07 18 00 	cp.b	r7,r8
800048ae:	c0 91       	brne	800048c0 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800048b0:	18 9b       	mov	r11,r12
800048b2:	a5 ab       	sbr	r11,0x4
800048b4:	5c 5b       	castu.b	r11
800048b6:	30 1c       	mov	r12,1
800048b8:	f0 1f 00 09 	mcall	800048dc <Powerdown_RC522+0x40>
800048bc:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800048c0:	18 9b       	mov	r11,r12
800048c2:	30 1c       	mov	r12,1
800048c4:	f0 1f 00 06 	mcall	800048dc <Powerdown_RC522+0x40>
		delay_ns(2);
800048c8:	30 2c       	mov	r12,2
800048ca:	f0 1f 00 06 	mcall	800048e0 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800048ce:	f0 1f 00 06 	mcall	800048e4 <Powerdown_RC522+0x48>
800048d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800048d6:	00 00       	add	r0,r0
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	48 44       	lddpc	r4,800048e8 <SetBitMask>
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	47 84       	lddsp	r4,sp[0x1e0]
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	4f 50       	lddpc	r0,80004ab4 <PcdAnticoll+0x8>
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	48 8c       	lddpc	r12,80004904 <SetBitMask+0x1c>

800048e8 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800048e8:	eb cd 40 c0 	pushm	r6-r7,lr
800048ec:	18 97       	mov	r7,r12
800048ee:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800048f0:	f0 1f 00 05 	mcall	80004904 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800048f4:	f9 e6 10 0b 	or	r11,r12,r6
800048f8:	5c 5b       	castu.b	r11
800048fa:	0e 9c       	mov	r12,r7
800048fc:	f0 1f 00 03 	mcall	80004908 <SetBitMask+0x20>
}
80004900:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	48 44       	lddpc	r4,80004914 <ClearBitMask+0x8>
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	47 84       	lddsp	r4,sp[0x1e0]

8000490c <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
8000490c:	eb cd 40 c0 	pushm	r6-r7,lr
80004910:	18 97       	mov	r7,r12
80004912:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004914:	f0 1f 00 06 	mcall	8000492c <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004918:	5c d6       	com	r6
8000491a:	f9 e6 00 06 	and	r6,r12,r6
8000491e:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004922:	0e 9c       	mov	r12,r7
80004924:	f0 1f 00 03 	mcall	80004930 <ClearBitMask+0x24>
	
}
80004928:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	48 44       	lddpc	r4,8000493c <PcdComMF522+0x8>
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	47 84       	lddsp	r4,sp[0x1e0]

80004934 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004934:	d4 31       	pushm	r0-r7,lr
80004936:	20 1d       	sub	sp,4
80004938:	18 92       	mov	r2,r12
8000493a:	16 95       	mov	r5,r11
8000493c:	14 96       	mov	r6,r10
8000493e:	50 09       	stdsp	sp[0x0],r9
80004940:	10 90       	mov	r0,r8
80004942:	f8 c8 00 0c 	sub	r8,r12,12
80004946:	5c 58       	castu.b	r8
80004948:	30 29       	mov	r9,2
8000494a:	f2 08 18 00 	cp.b	r8,r9
8000494e:	e0 88 00 05 	brls	80004958 <PcdComMF522+0x24>
80004952:	30 03       	mov	r3,0
80004954:	06 91       	mov	r1,r3
80004956:	c0 78       	rjmp	80004964 <PcdComMF522+0x30>
80004958:	4c f9       	lddpc	r9,80004a94 <PcdComMF522+0x160>
8000495a:	f2 08 07 01 	ld.ub	r1,r9[r8]
8000495e:	4c f9       	lddpc	r9,80004a98 <PcdComMF522+0x164>
80004960:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004964:	02 9b       	mov	r11,r1
80004966:	a7 bb       	sbr	r11,0x7
80004968:	30 2c       	mov	r12,2
8000496a:	f0 1f 00 4d 	mcall	80004a9c <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
8000496e:	e0 6b 00 80 	mov	r11,128
80004972:	30 4c       	mov	r12,4
80004974:	f0 1f 00 4b 	mcall	80004aa0 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004978:	30 0b       	mov	r11,0
8000497a:	30 1c       	mov	r12,1
8000497c:	f0 1f 00 48 	mcall	80004a9c <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004980:	e0 6b 00 80 	mov	r11,128
80004984:	30 ac       	mov	r12,10
80004986:	f0 1f 00 48 	mcall	80004aa4 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
8000498a:	58 06       	cp.w	r6,0
8000498c:	c0 c0       	breq	800049a4 <PcdComMF522+0x70>
8000498e:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004990:	30 94       	mov	r4,9
80004992:	0f 3b       	ld.ub	r11,r7++
80004994:	08 9c       	mov	r12,r4
80004996:	f0 1f 00 42 	mcall	80004a9c <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
8000499a:	0e 98       	mov	r8,r7
8000499c:	0a 18       	sub	r8,r5
8000499e:	ec 08 19 00 	cp.h	r8,r6
800049a2:	cf 83       	brcs	80004992 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
800049a4:	04 9b       	mov	r11,r2
800049a6:	30 1c       	mov	r12,1
800049a8:	f0 1f 00 3d 	mcall	80004a9c <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
800049ac:	30 c8       	mov	r8,12
800049ae:	f0 02 18 00 	cp.b	r2,r8
800049b2:	c0 61       	brne	800049be <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
800049b4:	e0 6b 00 80 	mov	r11,128
800049b8:	30 dc       	mov	r12,13
800049ba:	f0 1f 00 3b 	mcall	80004aa4 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800049be:	30 4c       	mov	r12,4
800049c0:	f0 1f 00 3a 	mcall	80004aa8 <PcdComMF522+0x174>
800049c4:	18 97       	mov	r7,r12
800049c6:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800049ca:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800049cc:	30 44       	mov	r4,4
800049ce:	c0 88       	rjmp	800049de <PcdComMF522+0xaa>
800049d0:	08 9c       	mov	r12,r4
800049d2:	f0 1f 00 36 	mcall	80004aa8 <PcdComMF522+0x174>
800049d6:	18 97       	mov	r7,r12
		i--;
800049d8:	20 16       	sub	r6,1
800049da:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800049dc:	c0 a0       	breq	800049f0 <PcdComMF522+0xbc>
800049de:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800049e2:	c4 c1       	brne	80004a7a <PcdComMF522+0x146>
800049e4:	ef e3 00 08 	and	r8,r7,r3
800049e8:	ea 08 18 00 	cp.b	r8,r5
800049ec:	cf 20       	breq	800049d0 <PcdComMF522+0x9c>
800049ee:	c4 68       	rjmp	80004a7a <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
800049f0:	e0 6b 00 80 	mov	r11,128
800049f4:	30 dc       	mov	r12,13
800049f6:	f0 1f 00 2b 	mcall	80004aa0 <PcdComMF522+0x16c>
800049fa:	30 27       	mov	r7,2
800049fc:	c3 38       	rjmp	80004a62 <PcdComMF522+0x12e>
800049fe:	02 67       	and	r7,r1
80004a00:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004a04:	30 c8       	mov	r8,12
80004a06:	f0 02 18 00 	cp.b	r2,r8
80004a0a:	c2 c1       	brne	80004a62 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004a0c:	30 ac       	mov	r12,10
80004a0e:	f0 1f 00 27 	mcall	80004aa8 <PcdComMF522+0x174>
80004a12:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004a14:	30 cc       	mov	r12,12
80004a16:	f0 1f 00 25 	mcall	80004aa8 <PcdComMF522+0x174>
80004a1a:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004a1e:	c0 70       	breq	80004a2c <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004a20:	08 98       	mov	r8,r4
80004a22:	20 18       	sub	r8,1
80004a24:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004a28:	a0 8c       	st.b	r0[0x0],r12
80004a2a:	c0 48       	rjmp	80004a32 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004a2c:	e8 08 15 03 	lsl	r8,r4,0x3
80004a30:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004a32:	58 04       	cp.w	r4,0
80004a34:	c0 61       	brne	80004a40 <PcdComMF522+0x10c>
80004a36:	30 14       	mov	r4,1
80004a38:	40 05       	lddsp	r5,sp[0x0]
80004a3a:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004a3c:	30 93       	mov	r3,9
80004a3e:	c0 98       	rjmp	80004a50 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004a40:	31 28       	mov	r8,18
80004a42:	f0 04 18 00 	cp.b	r4,r8
80004a46:	f9 b4 0b 12 	movhi	r4,18
80004a4a:	58 04       	cp.w	r4,0
80004a4c:	cf 61       	brne	80004a38 <PcdComMF522+0x104>
80004a4e:	c0 a8       	rjmp	80004a62 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004a50:	06 9c       	mov	r12,r3
80004a52:	f0 1f 00 16 	mcall	80004aa8 <PcdComMF522+0x174>
80004a56:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004a58:	ec 05 01 08 	sub	r8,r6,r5
80004a5c:	e8 08 19 00 	cp.h	r8,r4
80004a60:	cf 83       	brcs	80004a50 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004a62:	e0 6b 00 80 	mov	r11,128
80004a66:	30 cc       	mov	r12,12
80004a68:	f0 1f 00 0f 	mcall	80004aa4 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004a6c:	30 0b       	mov	r11,0
80004a6e:	30 1c       	mov	r12,1
80004a70:	f0 1f 00 0b 	mcall	80004a9c <PcdComMF522+0x168>
	return status;
}
80004a74:	0e 9c       	mov	r12,r7
80004a76:	2f fd       	sub	sp,-4
80004a78:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004a7a:	e0 6b 00 80 	mov	r11,128
80004a7e:	30 dc       	mov	r12,13
80004a80:	f0 1f 00 08 	mcall	80004aa0 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004a84:	30 6c       	mov	r12,6
80004a86:	f0 1f 00 09 	mcall	80004aa8 <PcdComMF522+0x174>
80004a8a:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004a8e:	cb 80       	breq	800049fe <PcdComMF522+0xca>
80004a90:	30 27       	mov	r7,2
80004a92:	ce 8b       	rjmp	80004a62 <PcdComMF522+0x12e>
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	d2 24       	*unknown*
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	d2 28       	*unknown*
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	47 84       	lddsp	r4,sp[0x1e0]
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	49 0c       	lddpc	r12,80004ae0 <PcdAnticoll+0x34>
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	48 e8       	lddpc	r8,80004adc <PcdAnticoll+0x30>
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	48 44       	lddpc	r4,80004ab8 <PcdAnticoll+0xc>

80004aac <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004aac:	eb cd 40 c0 	pushm	r6-r7,lr
80004ab0:	20 5d       	sub	sp,20
80004ab2:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004ab4:	30 8b       	mov	r11,8
80004ab6:	16 9c       	mov	r12,r11
80004ab8:	f0 1f 00 1a 	mcall	80004b20 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004abc:	30 0b       	mov	r11,0
80004abe:	30 dc       	mov	r12,13
80004ac0:	f0 1f 00 19 	mcall	80004b24 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004ac4:	e0 6b 00 80 	mov	r11,128
80004ac8:	30 ec       	mov	r12,14
80004aca:	f0 1f 00 16 	mcall	80004b20 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004ace:	39 38       	mov	r8,-109
80004ad0:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004ad2:	32 08       	mov	r8,32
80004ad4:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004ad6:	1a 9b       	mov	r11,sp
80004ad8:	fa c8 ff ed 	sub	r8,sp,-19
80004adc:	1a 99       	mov	r9,sp
80004ade:	30 2a       	mov	r10,2
80004ae0:	30 cc       	mov	r12,12
80004ae2:	f0 1f 00 12 	mcall	80004b28 <PcdAnticoll+0x7c>
80004ae6:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004ae8:	c1 21       	brne	80004b0c <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004aea:	1b 89       	ld.ub	r9,sp[0x0]
80004aec:	ac 89       	st.b	r6[0x0],r9
80004aee:	1b 98       	ld.ub	r8,sp[0x1]
80004af0:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004af2:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004af4:	1b a8       	ld.ub	r8,sp[0x2]
80004af6:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004af8:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004afc:	1b b9       	ld.ub	r9,sp[0x3]
80004afe:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004b00:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004b02:	1b c9       	ld.ub	r9,sp[0x4]
80004b04:	f0 09 18 00 	cp.b	r9,r8
80004b08:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004b0c:	e0 6b 00 80 	mov	r11,128
80004b10:	30 ec       	mov	r12,14
80004b12:	f0 1f 00 07 	mcall	80004b2c <PcdAnticoll+0x80>
	return status;
}
80004b16:	0e 9c       	mov	r12,r7
80004b18:	2f bd       	sub	sp,-20
80004b1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b1e:	00 00       	add	r0,r0
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	49 0c       	lddpc	r12,80004b60 <PcdRequest+0x30>
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	47 84       	lddsp	r4,sp[0x1e0]
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	49 34       	lddpc	r4,80004b74 <PcdRequest+0x44>
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	48 e8       	lddpc	r8,80004b64 <PcdRequest+0x34>

80004b30 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004b30:	eb cd 40 c0 	pushm	r6-r7,lr
80004b34:	20 5d       	sub	sp,20
80004b36:	18 97       	mov	r7,r12
80004b38:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004b3a:	30 8b       	mov	r11,8
80004b3c:	16 9c       	mov	r12,r11
80004b3e:	f0 1f 00 12 	mcall	80004b84 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004b42:	30 7b       	mov	r11,7
80004b44:	30 dc       	mov	r12,13
80004b46:	f0 1f 00 11 	mcall	80004b88 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004b4a:	30 3b       	mov	r11,3
80004b4c:	31 4c       	mov	r12,20
80004b4e:	f0 1f 00 10 	mcall	80004b8c <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004b52:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004b54:	1a 9b       	mov	r11,sp
80004b56:	fa c8 ff ed 	sub	r8,sp,-19
80004b5a:	1a 99       	mov	r9,sp
80004b5c:	30 1a       	mov	r10,1
80004b5e:	30 cc       	mov	r12,12
80004b60:	f0 1f 00 0c 	mcall	80004b90 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004b64:	c0 c1       	brne	80004b7c <PcdRequest+0x4c>
80004b66:	31 08       	mov	r8,16
80004b68:	fb 39 00 13 	ld.ub	r9,sp[19]
80004b6c:	f0 09 18 00 	cp.b	r9,r8
80004b70:	c0 61       	brne	80004b7c <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004b72:	1b 88       	ld.ub	r8,sp[0x0]
80004b74:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004b76:	1b 98       	ld.ub	r8,sp[0x1]
80004b78:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004b7a:	c0 28       	rjmp	80004b7e <PcdRequest+0x4e>
80004b7c:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004b7e:	2f bd       	sub	sp,-20
80004b80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	49 0c       	lddpc	r12,80004bc4 <CalulateCRC+0x30>
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	47 84       	lddsp	r4,sp[0x1e0]
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	48 e8       	lddpc	r8,80004bc4 <CalulateCRC+0x30>
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	49 34       	lddpc	r4,80004bdc <CalulateCRC+0x48>

80004b94 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004b94:	eb cd 40 f8 	pushm	r3-r7,lr
80004b98:	18 95       	mov	r5,r12
80004b9a:	16 96       	mov	r6,r11
80004b9c:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004b9e:	30 4b       	mov	r11,4
80004ba0:	30 5c       	mov	r12,5
80004ba2:	f0 1f 00 1c 	mcall	80004c10 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004ba6:	30 0b       	mov	r11,0
80004ba8:	30 1c       	mov	r12,1
80004baa:	f0 1f 00 1b 	mcall	80004c14 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004bae:	e0 6b 00 80 	mov	r11,128
80004bb2:	30 ac       	mov	r12,10
80004bb4:	f0 1f 00 19 	mcall	80004c18 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004bb8:	58 06       	cp.w	r6,0
80004bba:	c0 c0       	breq	80004bd2 <CalulateCRC+0x3e>
80004bbc:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004bbe:	30 94       	mov	r4,9
80004bc0:	0f 3b       	ld.ub	r11,r7++
80004bc2:	08 9c       	mov	r12,r4
80004bc4:	f0 1f 00 14 	mcall	80004c14 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004bc8:	0e 98       	mov	r8,r7
80004bca:	0a 18       	sub	r8,r5
80004bcc:	ec 08 18 00 	cp.b	r8,r6
80004bd0:	cf 83       	brcs	80004bc0 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004bd2:	30 3b       	mov	r11,3
80004bd4:	30 1c       	mov	r12,1
80004bd6:	f0 1f 00 10 	mcall	80004c14 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004bda:	30 5c       	mov	r12,5
80004bdc:	f0 1f 00 10 	mcall	80004c1c <CalulateCRC+0x88>
80004be0:	e0 67 00 fe 	mov	r7,254
80004be4:	30 56       	mov	r6,5
80004be6:	c0 78       	rjmp	80004bf4 <CalulateCRC+0x60>
80004be8:	0c 9c       	mov	r12,r6
80004bea:	f0 1f 00 0d 	mcall	80004c1c <CalulateCRC+0x88>
		i--;
80004bee:	20 17       	sub	r7,1
80004bf0:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004bf2:	c0 40       	breq	80004bfa <CalulateCRC+0x66>
80004bf4:	e2 1c 00 04 	andl	r12,0x4,COH
80004bf8:	cf 80       	breq	80004be8 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004bfa:	32 2c       	mov	r12,34
80004bfc:	f0 1f 00 08 	mcall	80004c1c <CalulateCRC+0x88>
80004c00:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004c02:	32 1c       	mov	r12,33
80004c04:	f0 1f 00 06 	mcall	80004c1c <CalulateCRC+0x88>
80004c08:	a6 9c       	st.b	r3[0x1],r12
}
80004c0a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004c0e:	00 00       	add	r0,r0
80004c10:	80 00       	ld.sh	r0,r0[0x0]
80004c12:	49 0c       	lddpc	r12,80004c50 <PcdSelect+0x30>
80004c14:	80 00       	ld.sh	r0,r0[0x0]
80004c16:	47 84       	lddsp	r4,sp[0x1e0]
80004c18:	80 00       	ld.sh	r0,r0[0x0]
80004c1a:	48 e8       	lddpc	r8,80004c50 <PcdSelect+0x30>
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	48 44       	lddpc	r4,80004c2c <PcdSelect+0xc>

80004c20 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004c20:	eb cd 40 80 	pushm	r7,lr
80004c24:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004c26:	39 38       	mov	r8,-109
80004c28:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004c2a:	37 08       	mov	r8,112
80004c2c:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004c2e:	30 08       	mov	r8,0
80004c30:	ba e8       	st.b	sp[0x6],r8
80004c32:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004c36:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004c3a:	19 89       	ld.ub	r9,r12[0x0]
80004c3c:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004c3e:	19 3a       	ld.ub	r10,r12++
80004c40:	1b e9       	ld.ub	r9,sp[0x6]
80004c42:	f5 e9 20 09 	eor	r9,r10,r9
80004c46:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004c48:	16 38       	cp.w	r8,r11
80004c4a:	cf 81       	brne	80004c3a <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004c4c:	1a 97       	mov	r7,sp
80004c4e:	fa ca ff f9 	sub	r10,sp,-7
80004c52:	30 7b       	mov	r11,7
80004c54:	1a 9c       	mov	r12,sp
80004c56:	f0 1f 00 0d 	mcall	80004c88 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004c5a:	30 8b       	mov	r11,8
80004c5c:	16 9c       	mov	r12,r11
80004c5e:	f0 1f 00 0c 	mcall	80004c8c <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004c62:	fa c8 ff ed 	sub	r8,sp,-19
80004c66:	1a 99       	mov	r9,sp
80004c68:	30 9a       	mov	r10,9
80004c6a:	1a 9b       	mov	r11,sp
80004c6c:	30 cc       	mov	r12,12
80004c6e:	f0 1f 00 09 	mcall	80004c90 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004c72:	c0 71       	brne	80004c80 <PcdSelect+0x60>
80004c74:	31 88       	mov	r8,24
80004c76:	fb 39 00 13 	ld.ub	r9,sp[19]
80004c7a:	f0 09 18 00 	cp.b	r9,r8
80004c7e:	c0 20       	breq	80004c82 <PcdSelect+0x62>
80004c80:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004c82:	2f bd       	sub	sp,-20
80004c84:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	4b 94       	lddpc	r4,80004d6c <rfid_auto_reader+0xd8>
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	49 0c       	lddpc	r12,80004ccc <rfid_auto_reader+0x38>
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	49 34       	lddpc	r4,80004cdc <rfid_auto_reader+0x48>

80004c94 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004c94:	eb cd 40 c0 	pushm	r6-r7,lr
80004c98:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004c9a:	f0 1f 00 35 	mcall	80004d6c <rfid_auto_reader+0xd8>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004c9e:	4b 5b       	lddpc	r11,80004d70 <rfid_auto_reader+0xdc>
80004ca0:	35 2c       	mov	r12,82
80004ca2:	f0 1f 00 35 	mcall	80004d74 <rfid_auto_reader+0xe0>
80004ca6:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004ca8:	c5 e1       	brne	80004d64 <rfid_auto_reader+0xd0>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004caa:	4b 28       	lddpc	r8,80004d70 <rfid_auto_reader+0xdc>
80004cac:	11 88       	ld.ub	r8,r8[0x0]
80004cae:	30 49       	mov	r9,4
80004cb0:	f2 08 18 00 	cp.b	r8,r9
80004cb4:	c0 b1       	brne	80004cca <rfid_auto_reader+0x36>
80004cb6:	4a f9       	lddpc	r9,80004d70 <rfid_auto_reader+0xdc>
80004cb8:	13 9a       	ld.ub	r10,r9[0x1]
80004cba:	30 09       	mov	r9,0
80004cbc:	f2 0a 18 00 	cp.b	r10,r9
80004cc0:	c0 51       	brne	80004cca <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004cc2:	4a ec       	lddpc	r12,80004d78 <rfid_auto_reader+0xe4>
80004cc4:	f0 1f 00 2e 	mcall	80004d7c <rfid_auto_reader+0xe8>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004cc8:	c3 c8       	rjmp	80004d40 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004cca:	30 29       	mov	r9,2
80004ccc:	f2 08 18 00 	cp.b	r8,r9
80004cd0:	c0 b1       	brne	80004ce6 <rfid_auto_reader+0x52>
80004cd2:	4a 89       	lddpc	r9,80004d70 <rfid_auto_reader+0xdc>
80004cd4:	13 9a       	ld.ub	r10,r9[0x1]
80004cd6:	30 09       	mov	r9,0
80004cd8:	f2 0a 18 00 	cp.b	r10,r9
80004cdc:	c0 51       	brne	80004ce6 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004cde:	4a 9c       	lddpc	r12,80004d80 <rfid_auto_reader+0xec>
80004ce0:	f0 1f 00 27 	mcall	80004d7c <rfid_auto_reader+0xe8>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004ce4:	c2 e8       	rjmp	80004d40 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ce6:	34 49       	mov	r9,68
80004ce8:	f2 08 18 00 	cp.b	r8,r9
80004cec:	c0 b1       	brne	80004d02 <rfid_auto_reader+0x6e>
80004cee:	4a 19       	lddpc	r9,80004d70 <rfid_auto_reader+0xdc>
80004cf0:	13 9a       	ld.ub	r10,r9[0x1]
80004cf2:	30 09       	mov	r9,0
80004cf4:	f2 0a 18 00 	cp.b	r10,r9
80004cf8:	c0 51       	brne	80004d02 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004cfa:	4a 3c       	lddpc	r12,80004d84 <rfid_auto_reader+0xf0>
80004cfc:	f0 1f 00 20 	mcall	80004d7c <rfid_auto_reader+0xe8>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004d00:	c2 08       	rjmp	80004d40 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004d02:	30 89       	mov	r9,8
80004d04:	f2 08 18 00 	cp.b	r8,r9
80004d08:	c0 b1       	brne	80004d1e <rfid_auto_reader+0x8a>
80004d0a:	49 a9       	lddpc	r9,80004d70 <rfid_auto_reader+0xdc>
80004d0c:	13 9a       	ld.ub	r10,r9[0x1]
80004d0e:	30 09       	mov	r9,0
80004d10:	f2 0a 18 00 	cp.b	r10,r9
80004d14:	c0 51       	brne	80004d1e <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004d16:	49 dc       	lddpc	r12,80004d88 <rfid_auto_reader+0xf4>
80004d18:	f0 1f 00 19 	mcall	80004d7c <rfid_auto_reader+0xe8>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004d1c:	c1 28       	rjmp	80004d40 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004d1e:	34 49       	mov	r9,68
80004d20:	f2 08 18 00 	cp.b	r8,r9
80004d24:	c0 b1       	brne	80004d3a <rfid_auto_reader+0xa6>
80004d26:	49 38       	lddpc	r8,80004d70 <rfid_auto_reader+0xdc>
80004d28:	11 99       	ld.ub	r9,r8[0x1]
80004d2a:	30 38       	mov	r8,3
80004d2c:	f0 09 18 00 	cp.b	r9,r8
80004d30:	c0 51       	brne	80004d3a <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004d32:	49 7c       	lddpc	r12,80004d8c <rfid_auto_reader+0xf8>
80004d34:	f0 1f 00 12 	mcall	80004d7c <rfid_auto_reader+0xe8>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004d38:	c0 48       	rjmp	80004d40 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004d3a:	49 6c       	lddpc	r12,80004d90 <rfid_auto_reader+0xfc>
80004d3c:	f0 1f 00 10 	mcall	80004d7c <rfid_auto_reader+0xe8>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004d40:	49 5c       	lddpc	r12,80004d94 <rfid_auto_reader+0x100>
80004d42:	f0 1f 00 16 	mcall	80004d98 <rfid_auto_reader+0x104>
80004d46:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004d48:	c0 e1       	brne	80004d64 <rfid_auto_reader+0xd0>
		return status;
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004d4a:	49 3c       	lddpc	r12,80004d94 <rfid_auto_reader+0x100>
80004d4c:	f0 1f 00 14 	mcall	80004d9c <rfid_auto_reader+0x108>
80004d50:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004d52:	c0 91       	brne	80004d64 <rfid_auto_reader+0xd0>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004d54:	30 4a       	mov	r10,4
80004d56:	49 0b       	lddpc	r11,80004d94 <rfid_auto_reader+0x100>
80004d58:	0c 9c       	mov	r12,r6
80004d5a:	f0 1f 00 12 	mcall	80004da0 <rfid_auto_reader+0x10c>
		log("select okay\n");
80004d5e:	49 2c       	lddpc	r12,80004da4 <rfid_auto_reader+0x110>
80004d60:	f0 1f 00 07 	mcall	80004d7c <rfid_auto_reader+0xe8>
		return status;	
	}
	
//}
	
}
80004d64:	0e 9c       	mov	r12,r7
80004d66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d6a:	00 00       	add	r0,r0
80004d6c:	80 00       	ld.sh	r0,r0[0x0]
80004d6e:	47 c4       	lddsp	r4,sp[0x1f0]
80004d70:	00 00       	add	r0,r0
80004d72:	97 1c       	st.w	r11[0x4],r12
80004d74:	80 00       	ld.sh	r0,r0[0x0]
80004d76:	4b 30       	lddpc	r0,80004e40 <rfid_sendID_message+0x48>
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	d2 2c       	*unknown*
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	6a 38       	ld.w	r8,r5[0xc]
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	d2 38       	*unknown*
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	d2 44       	*unknown*
80004d88:	80 00       	ld.sh	r0,r0[0x0]
80004d8a:	d2 54       	*unknown*
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	d2 5c       	*unknown*
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	d2 68       	*unknown*
80004d94:	00 00       	add	r0,r0
80004d96:	97 20       	st.w	r11[0x8],r0
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	4a ac       	lddpc	r12,80004e40 <rfid_sendID_message+0x48>
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	4c 20       	lddpc	r0,80004ea4 <rfid_sendID_message+0xac>
80004da0:	80 00       	ld.sh	r0,r0[0x0]
80004da2:	72 ac       	ld.w	r12,r9[0x28]
80004da4:	80 00       	ld.sh	r0,r0[0x0]
80004da6:	d2 74       	*unknown*

80004da8 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80004da8:	eb cd 40 80 	pushm	r7,lr
80004dac:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80004dae:	f0 1f 00 0d 	mcall	80004de0 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80004db2:	30 0c       	mov	r12,0
80004db4:	f0 1f 00 0c 	mcall	80004de4 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80004db8:	0e 9c       	mov	r12,r7
80004dba:	f0 1f 00 0c 	mcall	80004de8 <scan_patrol+0x40>
80004dbe:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80004dc0:	30 1c       	mov	r12,1
80004dc2:	f0 1f 00 09 	mcall	80004de4 <scan_patrol+0x3c>
	if(return_err == 0)
80004dc6:	58 07       	cp.w	r7,0
80004dc8:	c0 51       	brne	80004dd2 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80004dca:	48 9c       	lddpc	r12,80004dec <scan_patrol+0x44>
80004dcc:	f0 1f 00 09 	mcall	80004df0 <scan_patrol+0x48>
80004dd0:	c0 48       	rjmp	80004dd8 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80004dd2:	48 9c       	lddpc	r12,80004df4 <scan_patrol+0x4c>
80004dd4:	f0 1f 00 07 	mcall	80004df0 <scan_patrol+0x48>
		
	return return_err;

}
80004dd8:	0e 9c       	mov	r12,r7
80004dda:	e3 cd 80 80 	ldm	sp++,r7,pc
80004dde:	00 00       	add	r0,r0
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	47 c4       	lddsp	r4,sp[0x1f0]
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	48 9c       	lddpc	r12,80004e08 <rfid_sendID_message+0x10>
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	4c 94       	lddpc	r4,80004f0c <rfid_sendID_message+0x114>
80004dec:	80 00       	ld.sh	r0,r0[0x0]
80004dee:	d2 84       	*unknown*
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	6a 38       	ld.w	r8,r5[0xc]
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	d2 98       	*unknown*

80004df8 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
{
80004df8:	eb cd 40 f8 	pushm	r3-r7,lr
80004dfc:	21 bd       	sub	sp,108
	U32 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80004dfe:	fa ca ff a0 	sub	r10,sp,-96
80004e02:	30 08       	mov	r8,0
80004e04:	30 09       	mov	r9,0
80004e06:	f4 e9 00 00 	st.d	r10[0],r8
80004e0a:	30 0b       	mov	r11,0
80004e0c:	b4 4b       	st.h	r10[0x8],r11
	memset(message, 0x00, 80);
80004e0e:	fa e9 00 10 	st.d	sp[16],r8
80004e12:	fa e9 00 18 	st.d	sp[24],r8
80004e16:	fa e9 00 20 	st.d	sp[32],r8
80004e1a:	fa e9 00 28 	st.d	sp[40],r8
80004e1e:	fa e9 00 30 	st.d	sp[48],r8
80004e22:	fa e9 00 38 	st.d	sp[56],r8
80004e26:	fa e9 00 40 	st.d	sp[64],r8
80004e2a:	fa e9 00 48 	st.d	sp[72],r8
80004e2e:	fa e9 00 50 	st.d	sp[80],r8
80004e32:	fa e9 00 58 	st.d	sp[88],r8
80004e36:	30 07       	mov	r7,0
	
	//return_err = scan_patrol(SN);
	
	do 
	{	
		return_err = scan_patrol(SN);
80004e38:	14 94       	mov	r4,r10
		if(return_err == 0)break;
		else
		{
			vTaskDelay(400*2 / portTICK_RATE_MS);//寤惰400ms
80004e3a:	e0 63 03 20 	mov	r3,800
		}
		connect_counts++;
		
	} while ((connect_counts < 7) && (return_err !=0));
80004e3e:	30 75       	mov	r5,7
	
	//return_err = scan_patrol(SN);
	
	do 
	{	
		return_err = scan_patrol(SN);
80004e40:	08 9c       	mov	r12,r4
80004e42:	f0 1f 00 3b 	mcall	80004f2c <rfid_sendID_message+0x134>
80004e46:	18 96       	mov	r6,r12
		if(return_err == 0)break;
80004e48:	c0 a0       	breq	80004e5c <rfid_sendID_message+0x64>
		else
		{
			vTaskDelay(400*2 / portTICK_RATE_MS);//寤惰400ms
80004e4a:	06 9c       	mov	r12,r3
80004e4c:	f0 1f 00 39 	mcall	80004f30 <rfid_sendID_message+0x138>
		}
		connect_counts++;
80004e50:	2f f7       	sub	r7,-1
80004e52:	5c 57       	castu.b	r7
		
	} while ((connect_counts < 7) && (return_err !=0));
80004e54:	ea 07 18 00 	cp.b	r7,r5
80004e58:	cf 41       	brne	80004e40 <rfid_sendID_message+0x48>
80004e5a:	c5 c8       	rjmp	80004f12 <rfid_sendID_message+0x11a>
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004e5c:	fb 3b 00 63 	ld.ub	r11,sp[99]
80004e60:	fb 3a 00 62 	ld.ub	r10,sp[98]
80004e64:	fb 39 00 61 	ld.ub	r9,sp[97]
80004e68:	fb 38 00 60 	ld.ub	r8,sp[96]
80004e6c:	1a db       	st.w	--sp,r11
80004e6e:	1a da       	st.w	--sp,r10
80004e70:	1a d9       	st.w	--sp,r9
80004e72:	1a d8       	st.w	--sp,r8
80004e74:	4b 0c       	lddpc	r12,80004f34 <rfid_sendID_message+0x13c>
80004e76:	f0 1f 00 31 	mcall	80004f38 <rfid_sendID_message+0x140>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
80004e7a:	34 4b       	mov	r11,68
80004e7c:	30 1c       	mov	r12,1
80004e7e:	f0 1f 00 30 	mcall	80004f3c <rfid_sendID_message+0x144>
80004e82:	fa c9 ff f0 	sub	r9,sp,-16
80004e86:	fa ca ff ee 	sub	r10,sp,-18
80004e8a:	30 08       	mov	r8,0
80004e8c:	12 9d       	mov	sp,r9
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80004e8e:	30 97       	mov	r7,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80004e90:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80004e92:	fa cb ff 94 	sub	r11,sp,-108
80004e96:	10 0b       	add	r11,r8
80004e98:	f7 3b ff f4 	ld.ub	r11,r11[-12]
80004e9c:	a5 8b       	lsr	r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80004e9e:	ee 0b 18 00 	cp.b	r11,r7
80004ea2:	f7 bb 08 d0 	subls	r11,-48
80004ea6:	f3 fb 8e 00 	st.bls	r9[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80004eaa:	f7 bb 0b a9 	subhi	r11,-87
80004eae:	f3 fb be 00 	st.bhi	r9[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80004eb2:	b2 9c       	st.b	r9[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80004eb4:	fa cb ff 94 	sub	r11,sp,-108
80004eb8:	10 0b       	add	r11,r8
80004eba:	f7 3b ff f4 	ld.ub	r11,r11[-12]
80004ebe:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80004ec2:	ee 0b 18 00 	cp.b	r11,r7
80004ec6:	f7 bb 08 d0 	subls	r11,-48
80004eca:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80004ece:	f7 bb 0b a9 	subhi	r11,-87
80004ed2:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80004ed6:	b2 bc       	st.b	r9[0x3],r12
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80004ed8:	2f f8       	sub	r8,-1
80004eda:	2f c9       	sub	r9,-4
80004edc:	2f ca       	sub	r10,-4
80004ede:	58 48       	cp.w	r8,4
80004ee0:	cd 91       	brne	80004e92 <rfid_sendID_message+0x9a>
		//header.session_id = (++start_session);
	
		//memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
		//header.type = 0xe000;
	
		memcpy(message, unsure_data, sizeof(Message_Header_t));//疯header版
80004ee2:	fa c7 ff f0 	sub	r7,sp,-16
80004ee6:	49 78       	lddpc	r8,80004f40 <rfid_sendID_message+0x148>
80004ee8:	70 08       	ld.w	r8,r8[0x0]
80004eea:	8f 08       	st.w	r7[0x0],r8
		//memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
		
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80004eec:	31 0a       	mov	r10,16
80004eee:	1a 9b       	mov	r11,sp
80004ef0:	fa cc ff ec 	sub	r12,sp,-20
80004ef4:	f0 1f 00 14 	mcall	80004f44 <rfid_sendID_message+0x14c>
		
		message[sizeof(Message_Header_t)+sizeof(Message_Data_t)] = 0x00;//terminate flag;
80004ef8:	30 08       	mov	r8,0
80004efa:	fb 68 00 24 	st.b	sp[36],r8
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)+1), destination);
80004efe:	e0 7a 01 01 	mov	r10,65793
80004f02:	31 5b       	mov	r11,21
80004f04:	0e 9c       	mov	r12,r7
80004f06:	f0 1f 00 11 	mcall	80004f48 <rfid_sendID_message+0x150>
		log("no card find...\n");
	}
	
	return return_err;
	
}
80004f0a:	0c 9c       	mov	r12,r6
80004f0c:	2e 5d       	sub	sp,-108
80004f0e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)+1), destination);
		
	}
	else
	{
		vTaskDelay(500*2 / portTICK_RATE_MS);//寤惰500ms
80004f12:	e0 6c 03 e8 	mov	r12,1000
80004f16:	f0 1f 00 07 	mcall	80004f30 <rfid_sendID_message+0x138>
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80004f1a:	34 fb       	mov	r11,79
80004f1c:	30 1c       	mov	r12,1
80004f1e:	f0 1f 00 08 	mcall	80004f3c <rfid_sendID_message+0x144>
		log("no card find...\n");
80004f22:	48 bc       	lddpc	r12,80004f4c <rfid_sendID_message+0x154>
80004f24:	f0 1f 00 05 	mcall	80004f38 <rfid_sendID_message+0x140>
80004f28:	cf 1b       	rjmp	80004f0a <rfid_sendID_message+0x112>
80004f2a:	00 00       	add	r0,r0
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	4d a8       	lddpc	r8,80005094 <xg_flashc_init+0x6c>
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	64 cc       	ld.w	r12,r2[0x30]
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	d2 ac       	*unknown*
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	6a 38       	ld.w	r8,r5[0xc]
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	3f 4c       	mov	r12,-12
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	d2 dc       	*unknown*
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	72 ac       	ld.w	r12,r9[0x28]
80004f48:	80 00       	ld.sh	r0,r0[0x0]
80004f4a:	3e 08       	mov	r8,-32
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	d2 c8       	*unknown*

80004f50 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80004f50:	58 0c       	cp.w	r12,0
80004f52:	5e 0c       	reteq	r12
80004f54:	30 08       	mov	r8,0
	{
		nop();
80004f56:	d7 03       	nop
		nop();
80004f58:	d7 03       	nop
		nop();
80004f5a:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80004f5c:	2f f8       	sub	r8,-1
80004f5e:	10 3c       	cp.w	r12,r8
80004f60:	fe 9b ff fb 	brhi	80004f56 <delay_ns+0x6>
80004f64:	5e fc       	retal	r12
80004f66:	d7 03       	nop

80004f68 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80004f68:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80004f6a:	30 3b       	mov	r11,3
80004f6c:	48 8c       	lddpc	r12,80004f8c <local_start_timer+0x24>
80004f6e:	f0 1f 00 09 	mcall	80004f90 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80004f72:	fe 78 38 00 	mov	r8,-51200
80004f76:	e0 69 91 0d 	mov	r9,37133
80004f7a:	ea 19 00 52 	orh	r9,0x52
80004f7e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004f80:	32 09       	mov	r9,32
80004f82:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004f84:	30 59       	mov	r9,5
80004f86:	91 09       	st.w	r8[0x0],r9
}
80004f88:	d8 02       	popm	pc
80004f8a:	00 00       	add	r0,r0
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	d2 e0       	acall	0x2e
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	51 18       	stdsp	sp[0x44],r8

80004f94 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80004f94:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80004f96:	30 3a       	mov	r10,3
80004f98:	e0 6b 1b 00 	mov	r11,6912
80004f9c:	ea 1b 00 b7 	orh	r11,0xb7
80004fa0:	fe 7c 0c 00 	mov	r12,-62464
80004fa4:	f0 1f 00 19 	mcall	80005008 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80004fa8:	31 08       	mov	r8,16
80004faa:	1a d8       	st.w	--sp,r8
80004fac:	30 08       	mov	r8,0
80004fae:	30 19       	mov	r9,1
80004fb0:	30 7a       	mov	r10,7
80004fb2:	10 9b       	mov	r11,r8
80004fb4:	fe 7c 0c 00 	mov	r12,-62464
80004fb8:	f0 1f 00 15 	mcall	8000500c <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80004fbc:	30 08       	mov	r8,0
80004fbe:	30 19       	mov	r9,1
80004fc0:	12 9a       	mov	r10,r9
80004fc2:	10 9b       	mov	r11,r8
80004fc4:	fe 7c 0c 00 	mov	r12,-62464
80004fc8:	f0 1f 00 12 	mcall	80005010 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80004fcc:	30 0b       	mov	r11,0
80004fce:	fe 7c 0c 00 	mov	r12,-62464
80004fd2:	f0 1f 00 11 	mcall	80005014 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80004fd6:	fe 7c 0c 00 	mov	r12,-62464
80004fda:	f0 1f 00 10 	mcall	80005018 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80004fde:	30 0a       	mov	r10,0
80004fe0:	1a da       	st.w	--sp,r10
80004fe2:	1a da       	st.w	--sp,r10
80004fe4:	14 98       	mov	r8,r10
80004fe6:	14 99       	mov	r9,r10
80004fe8:	30 1b       	mov	r11,1
80004fea:	fe 7c 0c 00 	mov	r12,-62464
80004fee:	f0 1f 00 0c 	mcall	8000501c <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80004ff2:	30 1c       	mov	r12,1
80004ff4:	f0 1f 00 0b 	mcall	80005020 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80004ff8:	30 2b       	mov	r11,2
80004ffa:	fe 7c 0c 00 	mov	r12,-62464
80004ffe:	f0 1f 00 0a 	mcall	80005024 <local_start_pll0+0x90>
80005002:	2f dd       	sub	sp,-12
/****/
}
80005004:	d8 02       	popm	pc
80005006:	00 00       	add	r0,r0
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	53 b4       	stdsp	sp[0xec],r4
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	53 56       	stdsp	sp[0xd4],r6
80005010:	80 00       	ld.sh	r0,r0[0x0]
80005012:	53 78       	stdsp	sp[0xdc],r8
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	53 92       	stdsp	sp[0xe4],r2
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	53 a0       	stdsp	sp[0xe8],r0
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	53 10       	stdsp	sp[0xc4],r0
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	50 b8       	stdsp	sp[0x2c],r8
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	53 aa       	stdsp	sp[0xe8],r10

80005028 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005028:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
8000502c:	30 0b       	mov	r11,0
8000502e:	30 1c       	mov	r12,1
80005030:	f0 1f 00 19 	mcall	80005094 <xg_flashc_init+0x6c>
80005034:	49 98       	lddpc	r8,80005098 <xg_flashc_init+0x70>
80005036:	91 0c       	st.w	r8[0x0],r12
80005038:	70 08       	ld.w	r8,r8[0x0]
8000503a:	58 08       	cp.w	r8,0
8000503c:	c0 80       	breq	8000504c <xg_flashc_init+0x24>
8000503e:	49 78       	lddpc	r8,80005098 <xg_flashc_init+0x70>
80005040:	70 0c       	ld.w	r12,r8[0x0]
80005042:	30 09       	mov	r9,0
80005044:	12 9a       	mov	r10,r9
80005046:	12 9b       	mov	r11,r9
80005048:	f0 1f 00 15 	mcall	8000509c <xg_flashc_init+0x74>
	if (xBinarySemaphore == NULL)
8000504c:	49 38       	lddpc	r8,80005098 <xg_flashc_init+0x70>
8000504e:	70 08       	ld.w	r8,r8[0x0]
80005050:	58 08       	cp.w	r8,0
80005052:	c0 41       	brne	8000505a <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
80005054:	49 3c       	lddpc	r12,800050a0 <xg_flashc_init+0x78>
80005056:	f0 1f 00 14 	mcall	800050a4 <xg_flashc_init+0x7c>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
8000505a:	30 4b       	mov	r11,4
8000505c:	e0 6c 01 2c 	mov	r12,300
80005060:	f0 1f 00 0d 	mcall	80005094 <xg_flashc_init+0x6c>
80005064:	49 18       	lddpc	r8,800050a8 <xg_flashc_init+0x80>
80005066:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005068:	30 4b       	mov	r11,4
8000506a:	e0 6c 01 90 	mov	r12,400
8000506e:	f0 1f 00 0a 	mcall	80005094 <xg_flashc_init+0x6c>
80005072:	48 f8       	lddpc	r8,800050ac <xg_flashc_init+0x84>
80005074:	91 0c       	st.w	r8[0x0],r12
80005076:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005078:	10 96       	mov	r6,r8
8000507a:	48 e5       	lddpc	r5,800050b0 <xg_flashc_init+0x88>
8000507c:	6c 0c       	ld.w	r12,r6[0x0]
8000507e:	ea 07 00 0b 	add	r11,r5,r7
80005082:	f0 1f 00 0d 	mcall	800050b4 <xg_flashc_init+0x8c>
80005086:	2e c7       	sub	r7,-20
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005088:	e0 47 1f 40 	cp.w	r7,8000
8000508c:	cf 81       	brne	8000507c <xg_flashc_init+0x54>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
8000508e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005092:	00 00       	add	r0,r0
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	5f 58       	srlt	r8
80005098:	00 00       	add	r0,r0
8000509a:	0b 54       	ld.sh	r4,--r5
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	5e 00       	reteq	r0
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	d2 f8       	*unknown*
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	6a 38       	ld.w	r8,r5[0xc]
800050a8:	00 00       	add	r0,r0
800050aa:	0b 4c       	ld.w	r12,--r5
800050ac:	00 00       	add	r0,r0
800050ae:	0b 50       	ld.sh	r0,--r5
800050b0:	00 00       	add	r0,r0
800050b2:	97 24       	st.w	r11[0x8],r4
800050b4:	80 00       	ld.sh	r0,r0[0x0]
800050b6:	2a e4       	sub	r4,-82

800050b8 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800050b8:	fe 68 14 00 	mov	r8,-125952
800050bc:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800050be:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800050c2:	91 09       	st.w	r8[0x0],r9
}
800050c4:	5e fc       	retal	r12

800050c6 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800050c6:	f8 08 16 05 	lsr	r8,r12,0x5
800050ca:	a9 68       	lsl	r8,0x8
800050cc:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800050d0:	58 1b       	cp.w	r11,1
800050d2:	c0 d0       	breq	800050ec <gpio_enable_module_pin+0x26>
800050d4:	c0 63       	brcs	800050e0 <gpio_enable_module_pin+0x1a>
800050d6:	58 2b       	cp.w	r11,2
800050d8:	c1 00       	breq	800050f8 <gpio_enable_module_pin+0x32>
800050da:	58 3b       	cp.w	r11,3
800050dc:	c1 40       	breq	80005104 <gpio_enable_module_pin+0x3e>
800050de:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800050e0:	30 19       	mov	r9,1
800050e2:	f2 0c 09 49 	lsl	r9,r9,r12
800050e6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800050e8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050ea:	c1 28       	rjmp	8000510e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800050ec:	30 19       	mov	r9,1
800050ee:	f2 0c 09 49 	lsl	r9,r9,r12
800050f2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800050f4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800050f6:	c0 c8       	rjmp	8000510e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800050f8:	30 19       	mov	r9,1
800050fa:	f2 0c 09 49 	lsl	r9,r9,r12
800050fe:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005100:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005102:	c0 68       	rjmp	8000510e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005104:	30 19       	mov	r9,1
80005106:	f2 0c 09 49 	lsl	r9,r9,r12
8000510a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000510c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000510e:	30 19       	mov	r9,1
80005110:	f2 0c 09 4c 	lsl	r12,r9,r12
80005114:	91 2c       	st.w	r8[0x8],r12
80005116:	5e fd       	retal	0

80005118 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005118:	d4 21       	pushm	r4-r7,lr
8000511a:	18 97       	mov	r7,r12
8000511c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000511e:	58 0b       	cp.w	r11,0
80005120:	c0 31       	brne	80005126 <gpio_enable_module+0xe>
80005122:	30 05       	mov	r5,0
80005124:	c0 d8       	rjmp	8000513e <gpio_enable_module+0x26>
80005126:	30 06       	mov	r6,0
80005128:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000512a:	6e 1b       	ld.w	r11,r7[0x4]
8000512c:	6e 0c       	ld.w	r12,r7[0x0]
8000512e:	f0 1f 00 06 	mcall	80005144 <gpio_enable_module+0x2c>
80005132:	18 45       	or	r5,r12
		gpiomap++;
80005134:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005136:	2f f6       	sub	r6,-1
80005138:	0c 34       	cp.w	r4,r6
8000513a:	fe 9b ff f8 	brhi	8000512a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000513e:	0a 9c       	mov	r12,r5
80005140:	d8 22       	popm	r4-r7,pc
80005142:	00 00       	add	r0,r0
80005144:	80 00       	ld.sh	r0,r0[0x0]
80005146:	50 c6       	stdsp	sp[0x30],r6

80005148 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005148:	f8 08 16 05 	lsr	r8,r12,0x5
8000514c:	a9 68       	lsl	r8,0x8
8000514e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005152:	30 19       	mov	r9,1
80005154:	f2 0c 09 4c 	lsl	r12,r9,r12
80005158:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000515c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005160:	91 1c       	st.w	r8[0x4],r12
}
80005162:	5e fc       	retal	r12

80005164 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005164:	f8 08 16 05 	lsr	r8,r12,0x5
80005168:	a9 68       	lsl	r8,0x8
8000516a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000516e:	30 19       	mov	r9,1
80005170:	f2 0c 09 4c 	lsl	r12,r9,r12
80005174:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005178:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000517c:	91 1c       	st.w	r8[0x4],r12
}
8000517e:	5e fc       	retal	r12

80005180 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005180:	c0 08       	rjmp	80005180 <_unhandled_interrupt>
80005182:	d7 03       	nop

80005184 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005184:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005188:	49 99       	lddpc	r9,800051ec <INTC_register_interrupt+0x68>
8000518a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000518e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005192:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005194:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005198:	58 0a       	cp.w	r10,0
8000519a:	c0 91       	brne	800051ac <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000519c:	49 59       	lddpc	r9,800051f0 <INTC_register_interrupt+0x6c>
8000519e:	49 6a       	lddpc	r10,800051f4 <INTC_register_interrupt+0x70>
800051a0:	12 1a       	sub	r10,r9
800051a2:	fe 79 08 00 	mov	r9,-63488
800051a6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051aa:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800051ac:	58 1a       	cp.w	r10,1
800051ae:	c0 a1       	brne	800051c2 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800051b0:	49 09       	lddpc	r9,800051f0 <INTC_register_interrupt+0x6c>
800051b2:	49 2a       	lddpc	r10,800051f8 <INTC_register_interrupt+0x74>
800051b4:	12 1a       	sub	r10,r9
800051b6:	bf aa       	sbr	r10,0x1e
800051b8:	fe 79 08 00 	mov	r9,-63488
800051bc:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051c0:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800051c2:	58 2a       	cp.w	r10,2
800051c4:	c0 a1       	brne	800051d8 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800051c6:	48 b9       	lddpc	r9,800051f0 <INTC_register_interrupt+0x6c>
800051c8:	48 da       	lddpc	r10,800051fc <INTC_register_interrupt+0x78>
800051ca:	12 1a       	sub	r10,r9
800051cc:	bf ba       	sbr	r10,0x1f
800051ce:	fe 79 08 00 	mov	r9,-63488
800051d2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051d6:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800051d8:	48 69       	lddpc	r9,800051f0 <INTC_register_interrupt+0x6c>
800051da:	48 aa       	lddpc	r10,80005200 <INTC_register_interrupt+0x7c>
800051dc:	12 1a       	sub	r10,r9
800051de:	ea 1a c0 00 	orh	r10,0xc000
800051e2:	fe 79 08 00 	mov	r9,-63488
800051e6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800051ea:	5e fc       	retal	r12
800051ec:	80 00       	ld.sh	r0,r0[0x0]
800051ee:	d3 30       	acall	0x33
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	c8 00       	breq	800050f2 <gpio_enable_module_pin+0x2c>
800051f4:	80 00       	ld.sh	r0,r0[0x0]
800051f6:	c9 04       	brge	80005116 <gpio_enable_module_pin+0x50>
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	c9 12       	brcc	8000511c <gpio_enable_module+0x4>
800051fc:	80 00       	ld.sh	r0,r0[0x0]
800051fe:	c9 20       	breq	80005122 <gpio_enable_module+0xa>
80005200:	80 00       	ld.sh	r0,r0[0x0]
80005202:	c9 2e       	rcall	80004f26 <rfid_sendID_message+0x12e>

80005204 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005204:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005206:	49 18       	lddpc	r8,80005248 <INTC_init_interrupts+0x44>
80005208:	e3 b8 00 01 	mtsr	0x4,r8
8000520c:	49 0e       	lddpc	lr,8000524c <INTC_init_interrupts+0x48>
8000520e:	30 07       	mov	r7,0
80005210:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005212:	49 0c       	lddpc	r12,80005250 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005214:	49 05       	lddpc	r5,80005254 <INTC_init_interrupts+0x50>
80005216:	10 15       	sub	r5,r8
80005218:	fe 76 08 00 	mov	r6,-63488
8000521c:	c1 08       	rjmp	8000523c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000521e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005220:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005222:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005224:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005228:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000522a:	10 3a       	cp.w	r10,r8
8000522c:	fe 9b ff fc 	brhi	80005224 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005230:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005234:	2f f7       	sub	r7,-1
80005236:	2f 8e       	sub	lr,-8
80005238:	59 37       	cp.w	r7,19
8000523a:	c0 50       	breq	80005244 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000523c:	7c 08       	ld.w	r8,lr[0x0]
8000523e:	58 08       	cp.w	r8,0
80005240:	ce f1       	brne	8000521e <INTC_init_interrupts+0x1a>
80005242:	cf 7b       	rjmp	80005230 <INTC_init_interrupts+0x2c>
80005244:	d8 22       	popm	r4-r7,pc
80005246:	00 00       	add	r0,r0
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	c8 00       	breq	8000514a <gpio_set_gpio_pin+0x2>
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	d3 30       	acall	0x33
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	51 80       	stdsp	sp[0x60],r0
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	c9 04       	brge	80005176 <gpio_clr_gpio_pin+0x12>

80005258 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005258:	fe 78 08 00 	mov	r8,-63488
8000525c:	e0 69 00 83 	mov	r9,131
80005260:	f2 0c 01 0c 	sub	r12,r9,r12
80005264:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005268:	f2 ca ff c0 	sub	r10,r9,-64
8000526c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005270:	58 08       	cp.w	r8,0
80005272:	c0 21       	brne	80005276 <_get_interrupt_handler+0x1e>
80005274:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005276:	f0 08 12 00 	clz	r8,r8
8000527a:	48 5a       	lddpc	r10,8000528c <_get_interrupt_handler+0x34>
8000527c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005280:	f0 08 11 1f 	rsub	r8,r8,31
80005284:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005286:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000528a:	5e fc       	retal	r12
8000528c:	80 00       	ld.sh	r0,r0[0x0]
8000528e:	d3 30       	acall	0x33

80005290 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005290:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005292:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005296:	99 a8       	st.w	r12[0x28],r8
}
80005298:	5e fc       	retal	r12
8000529a:	d7 03       	nop

8000529c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000529c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000529e:	ec 5b bb 9f 	cp.w	r11,899999
800052a2:	e0 8b 00 04 	brhi	800052aa <pm_enable_osc0_crystal+0xe>
800052a6:	30 4b       	mov	r11,4
800052a8:	c1 38       	rjmp	800052ce <pm_enable_osc0_crystal+0x32>
800052aa:	e0 68 c6 bf 	mov	r8,50879
800052ae:	ea 18 00 2d 	orh	r8,0x2d
800052b2:	10 3b       	cp.w	r11,r8
800052b4:	e0 8b 00 04 	brhi	800052bc <pm_enable_osc0_crystal+0x20>
800052b8:	30 5b       	mov	r11,5
800052ba:	c0 a8       	rjmp	800052ce <pm_enable_osc0_crystal+0x32>
800052bc:	e0 68 12 00 	mov	r8,4608
800052c0:	ea 18 00 7a 	orh	r8,0x7a
800052c4:	10 3b       	cp.w	r11,r8
800052c6:	f9 bb 03 06 	movlo	r11,6
800052ca:	f9 bb 02 07 	movhs	r11,7
800052ce:	f0 1f 00 02 	mcall	800052d4 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800052d2:	d8 02       	popm	pc
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	52 90       	stdsp	sp[0xa4],r0

800052d8 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800052d8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800052da:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800052de:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800052e0:	78 08       	ld.w	r8,r12[0x0]
800052e2:	a3 a8       	sbr	r8,0x2
800052e4:	99 08       	st.w	r12[0x0],r8
}
800052e6:	5e fc       	retal	r12

800052e8 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800052e8:	79 58       	ld.w	r8,r12[0x54]
800052ea:	e2 18 00 80 	andl	r8,0x80,COH
800052ee:	cf d0       	breq	800052e8 <pm_wait_for_clk0_ready>
}
800052f0:	5e fc       	retal	r12
800052f2:	d7 03       	nop

800052f4 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800052f4:	eb cd 40 80 	pushm	r7,lr
800052f8:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800052fa:	f0 1f 00 04 	mcall	80005308 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800052fe:	0e 9c       	mov	r12,r7
80005300:	f0 1f 00 03 	mcall	8000530c <pm_enable_clk0+0x18>
}
80005304:	e3 cd 80 80 	ldm	sp++,r7,pc
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	52 d8       	stdsp	sp[0xb4],r8
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	52 e8       	stdsp	sp[0xb8],r8

80005310 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005310:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005314:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005318:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000531a:	09 f7       	ld.ub	r7,r4[0x7]
8000531c:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005320:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005324:	09 b4       	ld.ub	r4,r4[0x3]
80005326:	08 96       	mov	r6,r4
80005328:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
8000532c:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005330:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005334:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005338:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000533c:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005340:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005344:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005348:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000534a:	79 58       	ld.w	r8,r12[0x54]
8000534c:	e2 18 00 20 	andl	r8,0x20,COH
80005350:	cf d0       	breq	8000534a <pm_cksel+0x3a>
}
80005352:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005356 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005356:	eb cd 40 80 	pushm	r7,lr
8000535a:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000535c:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000535e:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80005362:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005366:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000536a:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000536e:	2f 8b       	sub	r11,-8
80005370:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005374:	e3 cd 80 80 	ldm	sp++,r7,pc

80005378 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005378:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000537a:	2f 8b       	sub	r11,-8
8000537c:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005380:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005384:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005388:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
8000538c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005390:	d8 02       	popm	pc

80005392 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80005392:	2f 8b       	sub	r11,-8
80005394:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005398:	a1 a8       	sbr	r8,0x0
8000539a:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000539e:	5e fc       	retal	r12

800053a0 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800053a0:	79 58       	ld.w	r8,r12[0x54]
800053a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800053a6:	cf d0       	breq	800053a0 <pm_wait_for_pll0_locked>
}
800053a8:	5e fc       	retal	r12

800053aa <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800053aa:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800053ac:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800053b0:	99 08       	st.w	r12[0x0],r8
}
800053b2:	5e fc       	retal	r12

800053b4 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800053b4:	eb cd 40 c0 	pushm	r6-r7,lr
800053b8:	18 97       	mov	r7,r12
800053ba:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800053bc:	f0 1f 00 06 	mcall	800053d4 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800053c0:	0c 9b       	mov	r11,r6
800053c2:	0e 9c       	mov	r12,r7
800053c4:	f0 1f 00 05 	mcall	800053d8 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800053c8:	30 1b       	mov	r11,1
800053ca:	0e 9c       	mov	r12,r7
800053cc:	f0 1f 00 04 	mcall	800053dc <pm_switch_to_osc0+0x28>
}
800053d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	52 9c       	stdsp	sp[0xa4],r12
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	52 f4       	stdsp	sp[0xbc],r4
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	53 aa       	stdsp	sp[0xe8],r10

800053e0 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800053e0:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800053e4:	c0 58       	rjmp	800053ee <spi_write+0xe>
		if (!timeout--) {
800053e6:	58 08       	cp.w	r8,0
800053e8:	c0 21       	brne	800053ec <spi_write+0xc>
800053ea:	5e ff       	retal	1
800053ec:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800053ee:	78 49       	ld.w	r9,r12[0x10]
800053f0:	e2 19 00 02 	andl	r9,0x2,COH
800053f4:	cf 90       	breq	800053e6 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800053f6:	5c 7b       	castu.h	r11
800053f8:	99 3b       	st.w	r12[0xc],r11
800053fa:	5e fd       	retal	0

800053fc <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800053fc:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005400:	c0 58       	rjmp	8000540a <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005402:	58 08       	cp.w	r8,0
80005404:	c0 21       	brne	80005408 <spi_read+0xc>
80005406:	5e ff       	retal	1
80005408:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000540a:	78 49       	ld.w	r9,r12[0x10]
8000540c:	e2 19 02 01 	andl	r9,0x201,COH
80005410:	e0 49 02 01 	cp.w	r9,513
80005414:	cf 71       	brne	80005402 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005416:	78 28       	ld.w	r8,r12[0x8]
80005418:	b6 08       	st.h	r11[0x0],r8
8000541a:	5e fd       	retal	0

8000541c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000541c:	d4 01       	pushm	lr
8000541e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005422:	c0 58       	rjmp	8000542c <spi_unselectChip+0x10>
		if (!timeout--) {
80005424:	58 08       	cp.w	r8,0
80005426:	c0 21       	brne	8000542a <spi_unselectChip+0xe>
80005428:	da 0a       	popm	pc,r12=1
8000542a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000542c:	78 49       	ld.w	r9,r12[0x10]
8000542e:	e2 19 02 00 	andl	r9,0x200,COH
80005432:	cf 90       	breq	80005424 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005434:	78 18       	ld.w	r8,r12[0x4]
80005436:	ea 18 00 0f 	orh	r8,0xf
8000543a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000543c:	fc 18 01 00 	movh	r8,0x100
80005440:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005442:	30 09       	mov	r9,0
80005444:	12 9a       	mov	r10,r9
80005446:	12 9b       	mov	r11,r9
80005448:	48 38       	lddpc	r8,80005454 <spi_unselectChip+0x38>
8000544a:	70 0c       	ld.w	r12,r8[0x0]
8000544c:	f0 1f 00 03 	mcall	80005458 <spi_unselectChip+0x3c>
80005450:	d8 0a       	popm	pc,r12=0
80005452:	00 00       	add	r0,r0
80005454:	00 00       	add	r0,r0
80005456:	b6 68       	st.h	r11[0xc],r8
80005458:	80 00       	ld.sh	r0,r0[0x0]
8000545a:	5e 00       	reteq	r0

8000545c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000545c:	eb cd 40 f8 	pushm	r3-r7,lr
80005460:	18 94       	mov	r4,r12
80005462:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005464:	49 a6       	lddpc	r6,800054cc <spi_selectChip+0x70>
80005466:	30 07       	mov	r7,0
80005468:	31 45       	mov	r5,20
8000546a:	0e 99       	mov	r9,r7
8000546c:	0a 9a       	mov	r10,r5
8000546e:	0e 9b       	mov	r11,r7
80005470:	6c 0c       	ld.w	r12,r6[0x0]
80005472:	f0 1f 00 18 	mcall	800054d0 <spi_selectChip+0x74>
80005476:	cf a0       	breq	8000546a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005478:	68 18       	ld.w	r8,r4[0x4]
8000547a:	ea 18 00 0f 	orh	r8,0xf
8000547e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005480:	68 18       	ld.w	r8,r4[0x4]
80005482:	e2 18 00 04 	andl	r8,0x4,COH
80005486:	c1 10       	breq	800054a8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005488:	30 e8       	mov	r8,14
8000548a:	f0 03 18 00 	cp.b	r3,r8
8000548e:	e0 8b 00 1c 	brhi	800054c6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005492:	68 19       	ld.w	r9,r4[0x4]
80005494:	e6 08 15 10 	lsl	r8,r3,0x10
80005498:	ea 18 ff f0 	orh	r8,0xfff0
8000549c:	e8 18 ff ff 	orl	r8,0xffff
800054a0:	12 68       	and	r8,r9
800054a2:	89 18       	st.w	r4[0x4],r8
800054a4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800054a8:	30 38       	mov	r8,3
800054aa:	f0 03 18 00 	cp.b	r3,r8
800054ae:	e0 8b 00 0c 	brhi	800054c6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800054b2:	68 19       	ld.w	r9,r4[0x4]
800054b4:	2f 03       	sub	r3,-16
800054b6:	30 18       	mov	r8,1
800054b8:	f0 03 09 48 	lsl	r8,r8,r3
800054bc:	5c d8       	com	r8
800054be:	12 68       	and	r8,r9
800054c0:	89 18       	st.w	r4[0x4],r8
800054c2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800054c6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800054c8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800054cc:	00 00       	add	r0,r0
800054ce:	b6 68       	st.h	r11[0xc],r8
800054d0:	80 00       	ld.sh	r0,r0[0x0]
800054d2:	5b f4       	cp.w	r4,-1

800054d4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800054d4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800054d6:	f6 08 15 04 	lsl	r8,r11,0x4
800054da:	14 38       	cp.w	r8,r10
800054dc:	f9 b8 08 10 	movls	r8,16
800054e0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800054e4:	f0 0b 02 4b 	mul	r11,r8,r11
800054e8:	f6 09 16 01 	lsr	r9,r11,0x1
800054ec:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800054f0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800054f4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800054f8:	f2 cb 00 01 	sub	r11,r9,1
800054fc:	e0 4b ff fe 	cp.w	r11,65534
80005500:	e0 88 00 03 	brls	80005506 <usart_set_async_baudrate+0x32>
80005504:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005506:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005508:	e8 6e 00 00 	mov	lr,524288
8000550c:	59 08       	cp.w	r8,16
8000550e:	fc 08 17 10 	movne	r8,lr
80005512:	f9 b8 00 00 	moveq	r8,0
80005516:	e4 1b ff f7 	andh	r11,0xfff7
8000551a:	e0 1b fe cf 	andl	r11,0xfecf
8000551e:	16 48       	or	r8,r11
80005520:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005522:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005526:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000552a:	99 89       	st.w	r12[0x20],r9
8000552c:	d8 0a       	popm	pc,r12=0

8000552e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000552e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005530:	e2 18 00 02 	andl	r8,0x2,COH
80005534:	c0 31       	brne	8000553a <usart_write_char+0xc>
80005536:	30 2c       	mov	r12,2
80005538:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000553a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000553e:	99 7b       	st.w	r12[0x1c],r11
80005540:	5e fd       	retal	0
80005542:	d7 03       	nop

80005544 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005544:	eb cd 40 e0 	pushm	r5-r7,lr
80005548:	18 96       	mov	r6,r12
8000554a:	16 95       	mov	r5,r11
8000554c:	e0 67 27 0f 	mov	r7,9999
80005550:	c0 68       	rjmp	8000555c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005552:	58 07       	cp.w	r7,0
80005554:	c0 31       	brne	8000555a <usart_putchar+0x16>
80005556:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000555a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000555c:	0a 9b       	mov	r11,r5
8000555e:	0c 9c       	mov	r12,r6
80005560:	f0 1f 00 03 	mcall	8000556c <usart_putchar+0x28>
80005564:	cf 71       	brne	80005552 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005566:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000556a:	00 00       	add	r0,r0
8000556c:	80 00       	ld.sh	r0,r0[0x0]
8000556e:	55 2e       	stdsp	sp[0x148],lr

80005570 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005570:	78 58       	ld.w	r8,r12[0x14]
80005572:	e2 18 00 e0 	andl	r8,0xe0,COH
80005576:	c0 30       	breq	8000557c <usart_read_char+0xc>
80005578:	30 4c       	mov	r12,4
8000557a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
8000557c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000557e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005582:	c0 31       	brne	80005588 <usart_read_char+0x18>
80005584:	30 3c       	mov	r12,3
80005586:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005588:	78 68       	ld.w	r8,r12[0x18]
8000558a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000558e:	97 08       	st.w	r11[0x0],r8
80005590:	5e fd       	retal	0
80005592:	d7 03       	nop

80005594 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005594:	eb cd 40 c0 	pushm	r6-r7,lr
80005598:	20 1d       	sub	sp,4
8000559a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
8000559c:	1a 97       	mov	r7,sp
8000559e:	1a 9b       	mov	r11,sp
800055a0:	0c 9c       	mov	r12,r6
800055a2:	f0 1f 00 07 	mcall	800055bc <usart_getchar+0x28>
800055a6:	58 3c       	cp.w	r12,3
800055a8:	cf b0       	breq	8000559e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800055aa:	58 4c       	cp.w	r12,4
800055ac:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800055b0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800055b4:	2f fd       	sub	sp,-4
800055b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055ba:	00 00       	add	r0,r0
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	55 70       	stdsp	sp[0x15c],r0

800055c0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800055c0:	eb cd 40 c0 	pushm	r6-r7,lr
800055c4:	18 96       	mov	r6,r12
800055c6:	16 97       	mov	r7,r11
  while (*string != '\0')
800055c8:	17 8b       	ld.ub	r11,r11[0x0]
800055ca:	58 0b       	cp.w	r11,0
800055cc:	c0 80       	breq	800055dc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800055ce:	2f f7       	sub	r7,-1
800055d0:	0c 9c       	mov	r12,r6
800055d2:	f0 1f 00 04 	mcall	800055e0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800055d6:	0f 8b       	ld.ub	r11,r7[0x0]
800055d8:	58 0b       	cp.w	r11,0
800055da:	cf a1       	brne	800055ce <usart_write_line+0xe>
800055dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	55 44       	stdsp	sp[0x150],r4

800055e4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800055e4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800055e8:	e6 18 00 01 	andh	r8,0x1,COH
800055ec:	c0 71       	brne	800055fa <usart_reset+0x16>
800055ee:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800055f0:	3f f8       	mov	r8,-1
800055f2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800055f4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800055f6:	d5 03       	csrf	0x10
800055f8:	c0 48       	rjmp	80005600 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800055fa:	3f f8       	mov	r8,-1
800055fc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800055fe:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005600:	30 08       	mov	r8,0
80005602:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005604:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005606:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005608:	ea 68 61 0c 	mov	r8,680204
8000560c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000560e:	5e fc       	retal	r12

80005610 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005610:	eb cd 40 e0 	pushm	r5-r7,lr
80005614:	18 96       	mov	r6,r12
80005616:	16 97       	mov	r7,r11
80005618:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000561a:	f0 1f 00 2f 	mcall	800056d4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000561e:	58 07       	cp.w	r7,0
80005620:	c5 80       	breq	800056d0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005622:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005624:	30 49       	mov	r9,4
80005626:	f2 08 18 00 	cp.b	r8,r9
8000562a:	e0 88 00 53 	brls	800056d0 <usart_init_rs232+0xc0>
8000562e:	30 99       	mov	r9,9
80005630:	f2 08 18 00 	cp.b	r8,r9
80005634:	e0 8b 00 4e 	brhi	800056d0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005638:	0f d9       	ld.ub	r9,r7[0x5]
8000563a:	30 78       	mov	r8,7
8000563c:	f0 09 18 00 	cp.b	r9,r8
80005640:	e0 8b 00 48 	brhi	800056d0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005644:	8e 39       	ld.sh	r9,r7[0x6]
80005646:	e0 68 01 01 	mov	r8,257
8000564a:	f0 09 19 00 	cp.h	r9,r8
8000564e:	e0 8b 00 41 	brhi	800056d0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005652:	ef 39 00 08 	ld.ub	r9,r7[8]
80005656:	30 38       	mov	r8,3
80005658:	f0 09 18 00 	cp.b	r9,r8
8000565c:	e0 8b 00 3a 	brhi	800056d0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005660:	0a 9a       	mov	r10,r5
80005662:	6e 0b       	ld.w	r11,r7[0x0]
80005664:	0c 9c       	mov	r12,r6
80005666:	f0 1f 00 1d 	mcall	800056d8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000566a:	58 1c       	cp.w	r12,1
8000566c:	c3 20       	breq	800056d0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000566e:	0f c8       	ld.ub	r8,r7[0x4]
80005670:	30 99       	mov	r9,9
80005672:	f2 08 18 00 	cp.b	r8,r9
80005676:	c0 51       	brne	80005680 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005678:	6c 18       	ld.w	r8,r6[0x4]
8000567a:	b1 b8       	sbr	r8,0x11
8000567c:	8d 18       	st.w	r6[0x4],r8
8000567e:	c0 68       	rjmp	8000568a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005680:	6c 19       	ld.w	r9,r6[0x4]
80005682:	20 58       	sub	r8,5
80005684:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005688:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000568a:	6c 19       	ld.w	r9,r6[0x4]
8000568c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005690:	0f d8       	ld.ub	r8,r7[0x5]
80005692:	a9 78       	lsl	r8,0x9
80005694:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005698:	12 48       	or	r8,r9
8000569a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
8000569c:	8e 38       	ld.sh	r8,r7[0x6]
8000569e:	30 29       	mov	r9,2
800056a0:	f2 08 19 00 	cp.h	r8,r9
800056a4:	e0 88 00 09 	brls	800056b6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800056a8:	6c 18       	ld.w	r8,r6[0x4]
800056aa:	ad b8       	sbr	r8,0xd
800056ac:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800056ae:	8e b8       	ld.uh	r8,r7[0x6]
800056b0:	20 28       	sub	r8,2
800056b2:	8d a8       	st.w	r6[0x28],r8
800056b4:	c0 68       	rjmp	800056c0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800056b6:	6c 19       	ld.w	r9,r6[0x4]
800056b8:	5c 78       	castu.h	r8
800056ba:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800056be:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800056c0:	6c 18       	ld.w	r8,r6[0x4]
800056c2:	e0 18 ff f0 	andl	r8,0xfff0
800056c6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800056c8:	35 08       	mov	r8,80
800056ca:	8d 08       	st.w	r6[0x0],r8
800056cc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800056d0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800056d4:	80 00       	ld.sh	r0,r0[0x0]
800056d6:	55 e4       	stdsp	sp[0x178],r4
800056d8:	80 00       	ld.sh	r0,r0[0x0]
800056da:	54 d4       	stdsp	sp[0x134],r4

800056dc <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800056dc:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800056e0:	fe c0 8e e0 	sub	r0,pc,-28960

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800056e4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800056e8:	d5 53       	csrf	0x15
  cp      r0, r1
800056ea:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
800056ec:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800056f0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800056f2:	c0 62       	brcc	800056fe <idata_load_loop_end>
  cp      r0, r1
800056f4:	48 92       	lddpc	r2,80005718 <udata_clear_loop_end+0x4>

800056f6 <idata_load_loop>:
  brlo    idata_load_loop
800056f6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800056f8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
800056fa:	02 30       	cp.w	r0,r1
  cp      r0, r1
800056fc:	cf d3       	brcs	800056f6 <idata_load_loop>

800056fe <idata_load_loop_end>:
  brhs    udata_clear_loop_end
800056fe:	e0 60 0a 38 	mov	r0,2616
  mov     r2, 0
  mov     r3, 0
80005702:	e0 61 b6 78 	mov	r1,46712
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005706:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005708:	c0 62       	brcc	80005714 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000570a:	30 02       	mov	r2,0
8000570c:	30 03       	mov	r3,0

8000570e <udata_clear_loop>:
8000570e:	a1 22       	st.d	r0++,r2
80005710:	02 30       	cp.w	r0,r1
80005712:	cf e3       	brcs	8000570e <udata_clear_loop>

80005714 <udata_clear_loop_end>:
80005714:	fe cf e9 28 	sub	pc,pc,-5848
80005718:	80 00       	ld.sh	r0,r0[0x0]
8000571a:	dc 60       	acall	0xc6

8000571c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
8000571c:	f8 c8 ff f8 	sub	r8,r12,-8
80005720:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005722:	3f f9       	mov	r9,-1
80005724:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005726:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005728:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000572a:	30 08       	mov	r8,0
8000572c:	99 08       	st.w	r12[0x0],r8
}
8000572e:	5e fc       	retal	r12

80005730 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005730:	30 08       	mov	r8,0
80005732:	99 48       	st.w	r12[0x10],r8
}
80005734:	5e fc       	retal	r12

80005736 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005736:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005738:	70 19       	ld.w	r9,r8[0x4]
8000573a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000573c:	78 19       	ld.w	r9,r12[0x4]
8000573e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005740:	70 19       	ld.w	r9,r8[0x4]
80005742:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005744:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005746:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005748:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000574a:	78 08       	ld.w	r8,r12[0x0]
8000574c:	2f f8       	sub	r8,-1
8000574e:	99 08       	st.w	r12[0x0],r8
}
80005750:	5e fc       	retal	r12

80005752 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005752:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005754:	5b fa       	cp.w	r10,-1
80005756:	c0 31       	brne	8000575c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005758:	78 48       	ld.w	r8,r12[0x10]
8000575a:	c0 c8       	rjmp	80005772 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
8000575c:	f8 c8 ff f8 	sub	r8,r12,-8
80005760:	70 19       	ld.w	r9,r8[0x4]
80005762:	72 09       	ld.w	r9,r9[0x0]
80005764:	12 3a       	cp.w	r10,r9
80005766:	c0 63       	brcs	80005772 <vListInsert+0x20>
80005768:	70 18       	ld.w	r8,r8[0x4]
8000576a:	70 19       	ld.w	r9,r8[0x4]
8000576c:	72 09       	ld.w	r9,r9[0x0]
8000576e:	12 3a       	cp.w	r10,r9
80005770:	cf c2       	brcc	80005768 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005772:	70 19       	ld.w	r9,r8[0x4]
80005774:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005776:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005778:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000577a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000577c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000577e:	78 08       	ld.w	r8,r12[0x0]
80005780:	2f f8       	sub	r8,-1
80005782:	99 08       	st.w	r12[0x0],r8
}
80005784:	5e fc       	retal	r12

80005786 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005786:	78 18       	ld.w	r8,r12[0x4]
80005788:	78 29       	ld.w	r9,r12[0x8]
8000578a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000578c:	78 28       	ld.w	r8,r12[0x8]
8000578e:	78 19       	ld.w	r9,r12[0x4]
80005790:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005792:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005794:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005796:	18 39       	cp.w	r9,r12
80005798:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000579c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800057a0:	30 09       	mov	r9,0
800057a2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800057a4:	70 09       	ld.w	r9,r8[0x0]
800057a6:	20 19       	sub	r9,1
800057a8:	91 09       	st.w	r8[0x0],r9
}
800057aa:	5e fc       	retal	r12

800057ac <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800057ac:	e0 68 08 08 	mov	r8,2056
800057b0:	ea 18 08 08 	orh	r8,0x808
800057b4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800057b6:	e0 68 09 09 	mov	r8,2313
800057ba:	ea 18 09 09 	orh	r8,0x909
800057be:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800057c0:	e0 68 0a 0a 	mov	r8,2570
800057c4:	ea 18 0a 0a 	orh	r8,0xa0a
800057c8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800057ca:	e0 68 0b 0b 	mov	r8,2827
800057ce:	ea 18 0b 0b 	orh	r8,0xb0b
800057d2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800057d4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800057d6:	e0 68 be ef 	mov	r8,48879
800057da:	ea 18 de ad 	orh	r8,0xdead
800057de:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800057e0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800057e2:	fc 18 00 40 	movh	r8,0x40
800057e6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800057e8:	e0 68 00 ff 	mov	r8,255
800057ec:	ea 18 ff 00 	orh	r8,0xff00
800057f0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800057f2:	e0 68 01 01 	mov	r8,257
800057f6:	ea 18 01 01 	orh	r8,0x101
800057fa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800057fc:	e0 68 02 02 	mov	r8,514
80005800:	ea 18 02 02 	orh	r8,0x202
80005804:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005806:	e0 68 03 03 	mov	r8,771
8000580a:	ea 18 03 03 	orh	r8,0x303
8000580e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005810:	e0 68 04 04 	mov	r8,1028
80005814:	ea 18 04 04 	orh	r8,0x404
80005818:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000581a:	e0 68 05 05 	mov	r8,1285
8000581e:	ea 18 05 05 	orh	r8,0x505
80005822:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005824:	e0 68 06 06 	mov	r8,1542
80005828:	ea 18 06 06 	orh	r8,0x606
8000582c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000582e:	e0 68 07 07 	mov	r8,1799
80005832:	ea 18 07 07 	orh	r8,0x707
80005836:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005838:	30 08       	mov	r8,0
8000583a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000583c:	5e fc       	retal	r12
8000583e:	d7 03       	nop

80005840 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005840:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005842:	48 38       	lddpc	r8,8000584c <vPortEnterCritical+0xc>
80005844:	70 09       	ld.w	r9,r8[0x0]
80005846:	2f f9       	sub	r9,-1
80005848:	91 09       	st.w	r8[0x0],r9
}
8000584a:	5e fc       	retal	r12
8000584c:	00 00       	add	r0,r0
8000584e:	05 28       	ld.uh	r8,r2++

80005850 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005850:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005852:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005854:	30 0a       	mov	r10,0
80005856:	14 9b       	mov	r11,r10
80005858:	49 2c       	lddpc	r12,800058a0 <xPortStartScheduler+0x50>
8000585a:	f0 1f 00 13 	mcall	800058a4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000585e:	e0 68 5d c0 	mov	r8,24000
80005862:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005866:	30 08       	mov	r8,0
80005868:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000586c:	e0 68 0c d0 	mov	r8,3280
80005870:	ea 18 00 00 	orh	r8,0x0
80005874:	70 00       	ld.w	r0,r8[0x0]
80005876:	60 0d       	ld.w	sp,r0[0x0]
80005878:	1b 00       	ld.w	r0,sp++
8000587a:	e0 68 05 28 	mov	r8,1320
8000587e:	ea 18 00 00 	orh	r8,0x0
80005882:	91 00       	st.w	r8[0x0],r0
80005884:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005888:	2f ed       	sub	sp,-8
8000588a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000588e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005892:	e3 b0 00 00 	mtsr	0x0,r0
80005896:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000589a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000589e:	d8 0a       	popm	pc,r12=0
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	59 6c       	cp.w	r12,22
800058a4:	80 00       	ld.sh	r0,r0[0x0]
800058a6:	51 84       	stdsp	sp[0x60],r4

800058a8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800058a8:	20 6d       	sub	sp,24
800058aa:	eb cd 00 ff 	pushm	r0-r7
800058ae:	fa c7 ff c0 	sub	r7,sp,-64
800058b2:	ee f0 ff f8 	ld.w	r0,r7[-8]
800058b6:	ef 40 ff e0 	st.w	r7[-32],r0
800058ba:	ee f0 ff fc 	ld.w	r0,r7[-4]
800058be:	ef 40 ff e4 	st.w	r7[-28],r0
800058c2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800058c6:	e0 68 05 28 	mov	r8,1320
800058ca:	ea 18 00 00 	orh	r8,0x0
800058ce:	70 00       	ld.w	r0,r8[0x0]
800058d0:	1a d0       	st.w	--sp,r0
800058d2:	f0 1f 00 1a 	mcall	80005938 <LABEL_RET_SCALL_263+0x14>
800058d6:	e0 68 0c d0 	mov	r8,3280
800058da:	ea 18 00 00 	orh	r8,0x0
800058de:	70 00       	ld.w	r0,r8[0x0]
800058e0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800058e2:	f0 1f 00 17 	mcall	8000593c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800058e6:	e0 68 0c d0 	mov	r8,3280
800058ea:	ea 18 00 00 	orh	r8,0x0
800058ee:	70 00       	ld.w	r0,r8[0x0]
800058f0:	60 0d       	ld.w	sp,r0[0x0]
800058f2:	1b 00       	ld.w	r0,sp++
800058f4:	e0 68 05 28 	mov	r8,1320
800058f8:	ea 18 00 00 	orh	r8,0x0
800058fc:	91 00       	st.w	r8[0x0],r0
800058fe:	fa c7 ff d8 	sub	r7,sp,-40
80005902:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005906:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000590a:	e0 61 05 28 	mov	r1,1320
8000590e:	ea 11 00 00 	orh	r1,0x0
80005912:	62 02       	ld.w	r2,r1[0x0]
80005914:	58 02       	cp.w	r2,0
80005916:	c0 70       	breq	80005924 <LABEL_RET_SCALL_263>
80005918:	e4 c2 00 01 	sub	r2,r2,1
8000591c:	83 02       	st.w	r1[0x0],r2
8000591e:	58 02       	cp.w	r2,0
80005920:	c0 21       	brne	80005924 <LABEL_RET_SCALL_263>
80005922:	b1 c0       	cbr	r0,0x10

80005924 <LABEL_RET_SCALL_263>:
80005924:	ef 40 ff f8 	st.w	r7[-8],r0
80005928:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000592c:	ef 40 ff fc 	st.w	r7[-4],r0
80005930:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005934:	2f ad       	sub	sp,-24
80005936:	d6 13       	rets
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	58 40       	cp.w	r0,4
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	5f dc       	srvc	r12

80005940 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005940:	e1 b8 00 43 	mfsr	r8,0x10c
80005944:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005948:	5e fc       	retal	r12
8000594a:	d7 03       	nop

8000594c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000594c:	48 78       	lddpc	r8,80005968 <vPortExitCritical+0x1c>
8000594e:	70 08       	ld.w	r8,r8[0x0]
80005950:	58 08       	cp.w	r8,0
80005952:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005954:	48 58       	lddpc	r8,80005968 <vPortExitCritical+0x1c>
80005956:	70 09       	ld.w	r9,r8[0x0]
80005958:	20 19       	sub	r9,1
8000595a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000595c:	70 08       	ld.w	r8,r8[0x0]
8000595e:	58 08       	cp.w	r8,0
80005960:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005962:	d5 03       	csrf	0x10
80005964:	5e fc       	retal	r12
80005966:	00 00       	add	r0,r0
80005968:	00 00       	add	r0,r0
8000596a:	05 28       	ld.uh	r8,r2++

8000596c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000596c:	eb cd 00 ff 	pushm	r0-r7
80005970:	e0 68 05 28 	mov	r8,1320
80005974:	ea 18 00 00 	orh	r8,0x0
80005978:	70 00       	ld.w	r0,r8[0x0]
8000597a:	1a d0       	st.w	--sp,r0
8000597c:	7a 90       	ld.w	r0,sp[0x24]
8000597e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005982:	58 10       	cp.w	r0,1
80005984:	e0 8b 00 08 	brhi	80005994 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005988:	e0 68 0c d0 	mov	r8,3280
8000598c:	ea 18 00 00 	orh	r8,0x0
80005990:	70 00       	ld.w	r0,r8[0x0]
80005992:	81 0d       	st.w	r0[0x0],sp

80005994 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005994:	f0 1f 00 12 	mcall	800059dc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005998:	f0 1f 00 12 	mcall	800059e0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000599c:	f0 1f 00 12 	mcall	800059e4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800059a0:	f0 1f 00 12 	mcall	800059e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800059a4:	7a 90       	ld.w	r0,sp[0x24]
800059a6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059aa:	58 10       	cp.w	r0,1
800059ac:	e0 8b 00 0e 	brhi	800059c8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800059b0:	f0 1f 00 0c 	mcall	800059e0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800059b4:	f0 1f 00 0e 	mcall	800059ec <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800059b8:	f0 1f 00 0c 	mcall	800059e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800059bc:	e0 68 0c d0 	mov	r8,3280
800059c0:	ea 18 00 00 	orh	r8,0x0
800059c4:	70 00       	ld.w	r0,r8[0x0]
800059c6:	60 0d       	ld.w	sp,r0[0x0]

800059c8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800059c8:	1b 00       	ld.w	r0,sp++
800059ca:	e0 68 05 28 	mov	r8,1320
800059ce:	ea 18 00 00 	orh	r8,0x0
800059d2:	91 00       	st.w	r8[0x0],r0
800059d4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800059d8:	d6 03       	rete
800059da:	00 00       	add	r0,r0
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	59 40       	cp.w	r0,20
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	58 40       	cp.w	r0,4
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	61 e0       	ld.w	r0,r0[0x78]
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	59 4c       	cp.w	r12,20
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	5f dc       	srvc	r12

800059f0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800059f0:	d4 01       	pushm	lr
	vTaskSuspendAll();
800059f2:	f0 1f 00 02 	mcall	800059f8 <__malloc_lock+0x8>
}
800059f6:	d8 02       	popm	pc
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	5f cc       	srvs	r12

800059fc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800059fc:	d4 01       	pushm	lr
	xTaskResumeAll();
800059fe:	f0 1f 00 02 	mcall	80005a04 <__malloc_unlock+0x8>
}
80005a02:	d8 02       	popm	pc
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	63 88       	ld.w	r8,r1[0x60]

80005a08 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005a08:	d4 21       	pushm	r4-r7,lr
80005a0a:	16 95       	mov	r5,r11
80005a0c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005a0e:	58 0c       	cp.w	r12,0
80005a10:	c0 30       	breq	80005a16 <_read+0xe>
80005a12:	3f f7       	mov	r7,-1
80005a14:	c1 48       	rjmp	80005a3c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005a16:	58 0a       	cp.w	r10,0
80005a18:	e0 89 00 04 	brgt	80005a20 <_read+0x18>
80005a1c:	30 07       	mov	r7,0
80005a1e:	c0 f8       	rjmp	80005a3c <_read+0x34>
80005a20:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005a22:	48 84       	lddpc	r4,80005a40 <_read+0x38>
80005a24:	68 0c       	ld.w	r12,r4[0x0]
80005a26:	f0 1f 00 08 	mcall	80005a44 <_read+0x3c>
    if (c < 0)
80005a2a:	c0 95       	brlt	80005a3c <_read+0x34>
      break;

    *ptr++ = c;
80005a2c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005a30:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005a32:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005a36:	58 08       	cp.w	r8,0
80005a38:	fe 99 ff f6 	brgt	80005a24 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005a3c:	0e 9c       	mov	r12,r7
80005a3e:	d8 22       	popm	r4-r7,pc
80005a40:	00 00       	add	r0,r0
80005a42:	b6 6c       	st.h	r11[0xc],r12
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	55 94       	stdsp	sp[0x164],r4

80005a48 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005a48:	d4 21       	pushm	r4-r7,lr
80005a4a:	16 95       	mov	r5,r11
80005a4c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005a4e:	20 1c       	sub	r12,1
80005a50:	58 2c       	cp.w	r12,2
80005a52:	e0 8b 00 12 	brhi	80005a76 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a56:	58 0a       	cp.w	r10,0
80005a58:	c0 31       	brne	80005a5e <_write+0x16>
80005a5a:	30 07       	mov	r7,0
80005a5c:	c0 e8       	rjmp	80005a78 <_write+0x30>
80005a5e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005a60:	48 74       	lddpc	r4,80005a7c <_write+0x34>
80005a62:	68 0c       	ld.w	r12,r4[0x0]
80005a64:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005a68:	f0 1f 00 06 	mcall	80005a80 <_write+0x38>
80005a6c:	c0 55       	brlt	80005a76 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005a6e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005a70:	0e 36       	cp.w	r6,r7
80005a72:	cf 81       	brne	80005a62 <_write+0x1a>
80005a74:	c0 28       	rjmp	80005a78 <_write+0x30>
80005a76:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005a78:	0e 9c       	mov	r12,r7
80005a7a:	d8 22       	popm	r4-r7,pc
80005a7c:	00 00       	add	r0,r0
80005a7e:	b6 6c       	st.h	r11[0xc],r12
80005a80:	80 00       	ld.sh	r0,r0[0x0]
80005a82:	55 44       	stdsp	sp[0x150],r4

80005a84 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005a84:	eb cd 40 80 	pushm	r7,lr
80005a88:	18 97       	mov	r7,r12
	if( pv )
80005a8a:	58 0c       	cp.w	r12,0
80005a8c:	c0 80       	breq	80005a9c <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005a8e:	f0 1f 00 05 	mcall	80005aa0 <vPortFree+0x1c>
		{
			free( pv );
80005a92:	0e 9c       	mov	r12,r7
80005a94:	f0 1f 00 04 	mcall	80005aa4 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005a98:	f0 1f 00 04 	mcall	80005aa8 <vPortFree+0x24>
80005a9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	5f cc       	srvs	r12
80005aa4:	80 00       	ld.sh	r0,r0[0x0]
80005aa6:	6e 54       	ld.w	r4,r7[0x14]
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	63 88       	ld.w	r8,r1[0x60]

80005aac <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005aac:	eb cd 40 80 	pushm	r7,lr
80005ab0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005ab2:	f0 1f 00 06 	mcall	80005ac8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005ab6:	0e 9c       	mov	r12,r7
80005ab8:	f0 1f 00 05 	mcall	80005acc <pvPortMalloc+0x20>
80005abc:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005abe:	f0 1f 00 05 	mcall	80005ad0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005ac2:	0e 9c       	mov	r12,r7
80005ac4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	5f cc       	srvs	r12
80005acc:	80 00       	ld.sh	r0,r0[0x0]
80005ace:	6e 64       	ld.w	r4,r7[0x18]
80005ad0:	80 00       	ld.sh	r0,r0[0x0]
80005ad2:	63 88       	ld.w	r8,r1[0x60]

80005ad4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005ad4:	d4 01       	pushm	lr
80005ad6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005ad8:	78 09       	ld.w	r9,r12[0x0]
80005ada:	58 09       	cp.w	r9,0
80005adc:	c1 10       	breq	80005afe <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005ade:	78 3a       	ld.w	r10,r12[0xc]
80005ae0:	79 09       	ld.w	r9,r12[0x40]
80005ae2:	f4 09 00 09 	add	r9,r10,r9
80005ae6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005ae8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005aea:	14 39       	cp.w	r9,r10
80005aec:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005af0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005af4:	79 0a       	ld.w	r10,r12[0x40]
80005af6:	78 3b       	ld.w	r11,r12[0xc]
80005af8:	10 9c       	mov	r12,r8
80005afa:	f0 1f 00 02 	mcall	80005b00 <prvCopyDataFromQueue+0x2c>
80005afe:	d8 02       	popm	pc
80005b00:	80 00       	ld.sh	r0,r0[0x0]
80005b02:	72 ac       	ld.w	r12,r9[0x28]

80005b04 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005b04:	eb cd 40 c0 	pushm	r6-r7,lr
80005b08:	18 97       	mov	r7,r12
80005b0a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005b0c:	78 e8       	ld.w	r8,r12[0x38]
80005b0e:	58 08       	cp.w	r8,0
80005b10:	c0 31       	brne	80005b16 <xQueueReceiveFromISR+0x12>
80005b12:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005b16:	f0 1f 00 0e 	mcall	80005b4c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005b1a:	6e e8       	ld.w	r8,r7[0x38]
80005b1c:	20 18       	sub	r8,1
80005b1e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005b20:	6f 18       	ld.w	r8,r7[0x44]
80005b22:	5b f8       	cp.w	r8,-1
80005b24:	c0 d1       	brne	80005b3e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005b26:	6e 48       	ld.w	r8,r7[0x10]
80005b28:	58 08       	cp.w	r8,0
80005b2a:	c0 f0       	breq	80005b48 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005b2c:	ee cc ff f0 	sub	r12,r7,-16
80005b30:	f0 1f 00 08 	mcall	80005b50 <xQueueReceiveFromISR+0x4c>
80005b34:	c0 a0       	breq	80005b48 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005b36:	30 1c       	mov	r12,1
80005b38:	8d 0c       	st.w	r6[0x0],r12
80005b3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005b3e:	2f f8       	sub	r8,-1
80005b40:	ef 48 00 44 	st.w	r7[68],r8
80005b44:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b48:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	5a d4       	cp.w	r4,-19
80005b50:	80 00       	ld.sh	r0,r0[0x0]
80005b52:	61 64       	ld.w	r4,r0[0x58]

80005b54 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005b54:	eb cd 40 c0 	pushm	r6-r7,lr
80005b58:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005b5a:	f0 1f 00 23 	mcall	80005be4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005b5e:	6f 28       	ld.w	r8,r7[0x48]
80005b60:	58 08       	cp.w	r8,0
80005b62:	e0 8a 00 18 	brle	80005b92 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b66:	6e 98       	ld.w	r8,r7[0x24]
80005b68:	58 08       	cp.w	r8,0
80005b6a:	c1 40       	breq	80005b92 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b6c:	ee c6 ff dc 	sub	r6,r7,-36
80005b70:	c0 48       	rjmp	80005b78 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b72:	6e 98       	ld.w	r8,r7[0x24]
80005b74:	58 08       	cp.w	r8,0
80005b76:	c0 e0       	breq	80005b92 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b78:	0c 9c       	mov	r12,r6
80005b7a:	f0 1f 00 1c 	mcall	80005be8 <prvUnlockQueue+0x94>
80005b7e:	c0 30       	breq	80005b84 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005b80:	f0 1f 00 1b 	mcall	80005bec <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005b84:	6f 28       	ld.w	r8,r7[0x48]
80005b86:	20 18       	sub	r8,1
80005b88:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005b8c:	58 08       	cp.w	r8,0
80005b8e:	fe 99 ff f2 	brgt	80005b72 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005b92:	3f f8       	mov	r8,-1
80005b94:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005b98:	f0 1f 00 16 	mcall	80005bf0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005b9c:	f0 1f 00 12 	mcall	80005be4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005ba0:	6f 18       	ld.w	r8,r7[0x44]
80005ba2:	58 08       	cp.w	r8,0
80005ba4:	e0 8a 00 18 	brle	80005bd4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005ba8:	6e 48       	ld.w	r8,r7[0x10]
80005baa:	58 08       	cp.w	r8,0
80005bac:	c1 40       	breq	80005bd4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bae:	ee c6 ff f0 	sub	r6,r7,-16
80005bb2:	c0 48       	rjmp	80005bba <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005bb4:	6e 48       	ld.w	r8,r7[0x10]
80005bb6:	58 08       	cp.w	r8,0
80005bb8:	c0 e0       	breq	80005bd4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005bba:	0c 9c       	mov	r12,r6
80005bbc:	f0 1f 00 0b 	mcall	80005be8 <prvUnlockQueue+0x94>
80005bc0:	c0 30       	breq	80005bc6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005bc2:	f0 1f 00 0b 	mcall	80005bec <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005bc6:	6f 18       	ld.w	r8,r7[0x44]
80005bc8:	20 18       	sub	r8,1
80005bca:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005bce:	58 08       	cp.w	r8,0
80005bd0:	fe 99 ff f2 	brgt	80005bb4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005bd4:	3f f8       	mov	r8,-1
80005bd6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005bda:	f0 1f 00 06 	mcall	80005bf0 <prvUnlockQueue+0x9c>
}
80005bde:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005be2:	00 00       	add	r0,r0
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	58 40       	cp.w	r0,4
80005be8:	80 00       	ld.sh	r0,r0[0x0]
80005bea:	61 64       	ld.w	r4,r0[0x58]
80005bec:	80 00       	ld.sh	r0,r0[0x0]
80005bee:	60 70       	ld.w	r0,r0[0x1c]
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	59 4c       	cp.w	r12,20

80005bf4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005bf4:	d4 31       	pushm	r0-r7,lr
80005bf6:	20 5d       	sub	sp,20
80005bf8:	18 97       	mov	r7,r12
80005bfa:	50 0b       	stdsp	sp[0x0],r11
80005bfc:	50 2a       	stdsp	sp[0x8],r10
80005bfe:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005c00:	f8 c2 ff dc 	sub	r2,r12,-36
80005c04:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c06:	fa c4 ff f4 	sub	r4,sp,-12
80005c0a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005c0c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c0e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005c12:	f0 1f 00 3e 	mcall	80005d08 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005c16:	6e e8       	ld.w	r8,r7[0x38]
80005c18:	58 08       	cp.w	r8,0
80005c1a:	c2 a0       	breq	80005c6e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005c1c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005c1e:	40 0b       	lddsp	r11,sp[0x0]
80005c20:	0e 9c       	mov	r12,r7
80005c22:	f0 1f 00 3b 	mcall	80005d0c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005c26:	40 18       	lddsp	r8,sp[0x4]
80005c28:	58 08       	cp.w	r8,0
80005c2a:	c1 51       	brne	80005c54 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005c2c:	6e e8       	ld.w	r8,r7[0x38]
80005c2e:	20 18       	sub	r8,1
80005c30:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005c32:	6e 08       	ld.w	r8,r7[0x0]
80005c34:	58 08       	cp.w	r8,0
80005c36:	c0 41       	brne	80005c3e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005c38:	f0 1f 00 36 	mcall	80005d10 <xQueueGenericReceive+0x11c>
80005c3c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005c3e:	6e 48       	ld.w	r8,r7[0x10]
80005c40:	58 08       	cp.w	r8,0
80005c42:	c1 20       	breq	80005c66 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005c44:	ee cc ff f0 	sub	r12,r7,-16
80005c48:	f0 1f 00 33 	mcall	80005d14 <xQueueGenericReceive+0x120>
80005c4c:	58 1c       	cp.w	r12,1
80005c4e:	c0 c1       	brne	80005c66 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005c50:	d7 33       	scall
80005c52:	c0 a8       	rjmp	80005c66 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005c54:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005c56:	6e 98       	ld.w	r8,r7[0x24]
80005c58:	58 08       	cp.w	r8,0
80005c5a:	c0 60       	breq	80005c66 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005c5c:	04 9c       	mov	r12,r2
80005c5e:	f0 1f 00 2e 	mcall	80005d14 <xQueueGenericReceive+0x120>
80005c62:	c0 20       	breq	80005c66 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005c64:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005c66:	f0 1f 00 2d 	mcall	80005d18 <xQueueGenericReceive+0x124>
80005c6a:	30 1c       	mov	r12,1
				return pdPASS;
80005c6c:	c4 c8       	rjmp	80005d04 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005c6e:	40 28       	lddsp	r8,sp[0x8]
80005c70:	58 08       	cp.w	r8,0
80005c72:	c0 51       	brne	80005c7c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005c74:	f0 1f 00 29 	mcall	80005d18 <xQueueGenericReceive+0x124>
80005c78:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80005c7a:	c4 58       	rjmp	80005d04 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005c7c:	58 05       	cp.w	r5,0
80005c7e:	c0 51       	brne	80005c88 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005c80:	08 9c       	mov	r12,r4
80005c82:	f0 1f 00 27 	mcall	80005d1c <xQueueGenericReceive+0x128>
80005c86:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005c88:	f0 1f 00 24 	mcall	80005d18 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005c8c:	f0 1f 00 25 	mcall	80005d20 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005c90:	f0 1f 00 1e 	mcall	80005d08 <xQueueGenericReceive+0x114>
80005c94:	6f 18       	ld.w	r8,r7[0x44]
80005c96:	5b f8       	cp.w	r8,-1
80005c98:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005c9c:	6f 28       	ld.w	r8,r7[0x48]
80005c9e:	5b f8       	cp.w	r8,-1
80005ca0:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005ca4:	f0 1f 00 1d 	mcall	80005d18 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005ca8:	06 9b       	mov	r11,r3
80005caa:	08 9c       	mov	r12,r4
80005cac:	f0 1f 00 1e 	mcall	80005d24 <xQueueGenericReceive+0x130>
80005cb0:	c2 41       	brne	80005cf8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005cb2:	f0 1f 00 16 	mcall	80005d08 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005cb6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005cb8:	f0 1f 00 18 	mcall	80005d18 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005cbc:	58 06       	cp.w	r6,0
80005cbe:	c1 71       	brne	80005cec <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005cc0:	6e 08       	ld.w	r8,r7[0x0]
80005cc2:	58 08       	cp.w	r8,0
80005cc4:	c0 81       	brne	80005cd4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005cc6:	f0 1f 00 11 	mcall	80005d08 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005cca:	6e 1c       	ld.w	r12,r7[0x4]
80005ccc:	f0 1f 00 17 	mcall	80005d28 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005cd0:	f0 1f 00 12 	mcall	80005d18 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005cd4:	40 2b       	lddsp	r11,sp[0x8]
80005cd6:	04 9c       	mov	r12,r2
80005cd8:	f0 1f 00 15 	mcall	80005d2c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005cdc:	0e 9c       	mov	r12,r7
80005cde:	f0 1f 00 15 	mcall	80005d30 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005ce2:	f0 1f 00 15 	mcall	80005d34 <xQueueGenericReceive+0x140>
80005ce6:	c9 61       	brne	80005c12 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005ce8:	d7 33       	scall
80005cea:	c9 4b       	rjmp	80005c12 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005cec:	0e 9c       	mov	r12,r7
80005cee:	f0 1f 00 11 	mcall	80005d30 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005cf2:	f0 1f 00 11 	mcall	80005d34 <xQueueGenericReceive+0x140>
80005cf6:	c8 eb       	rjmp	80005c12 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005cf8:	0e 9c       	mov	r12,r7
80005cfa:	f0 1f 00 0e 	mcall	80005d30 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005cfe:	f0 1f 00 0e 	mcall	80005d34 <xQueueGenericReceive+0x140>
80005d02:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005d04:	2f bd       	sub	sp,-20
80005d06:	d8 32       	popm	r0-r7,pc
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	58 40       	cp.w	r0,4
80005d0c:	80 00       	ld.sh	r0,r0[0x0]
80005d0e:	5a d4       	cp.w	r4,-19
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	60 7c       	ld.w	r12,r0[0x1c]
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	61 64       	ld.w	r4,r0[0x58]
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	59 4c       	cp.w	r12,20
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	60 58       	ld.w	r8,r0[0x14]
80005d20:	80 00       	ld.sh	r0,r0[0x0]
80005d22:	5f cc       	srvs	r12
80005d24:	80 00       	ld.sh	r0,r0[0x0]
80005d26:	62 f4       	ld.w	r4,r1[0x3c]
80005d28:	80 00       	ld.sh	r0,r0[0x0]
80005d2a:	60 e0       	ld.w	r0,r0[0x38]
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	65 94       	ld.w	r4,r2[0x64]
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	5b 54       	cp.w	r4,-11
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	63 88       	ld.w	r8,r1[0x60]

80005d38 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005d38:	eb cd 40 80 	pushm	r7,lr
80005d3c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005d3e:	79 08       	ld.w	r8,r12[0x40]
80005d40:	58 08       	cp.w	r8,0
80005d42:	c0 a1       	brne	80005d56 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005d44:	78 08       	ld.w	r8,r12[0x0]
80005d46:	58 08       	cp.w	r8,0
80005d48:	c2 b1       	brne	80005d9e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005d4a:	78 1c       	ld.w	r12,r12[0x4]
80005d4c:	f0 1f 00 17 	mcall	80005da8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005d50:	30 08       	mov	r8,0
80005d52:	8f 18       	st.w	r7[0x4],r8
80005d54:	c2 58       	rjmp	80005d9e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005d56:	58 0a       	cp.w	r10,0
80005d58:	c1 01       	brne	80005d78 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005d5a:	10 9a       	mov	r10,r8
80005d5c:	78 2c       	ld.w	r12,r12[0x8]
80005d5e:	f0 1f 00 14 	mcall	80005dac <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005d62:	6e 29       	ld.w	r9,r7[0x8]
80005d64:	6f 08       	ld.w	r8,r7[0x40]
80005d66:	f2 08 00 08 	add	r8,r9,r8
80005d6a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005d6c:	6e 19       	ld.w	r9,r7[0x4]
80005d6e:	12 38       	cp.w	r8,r9
80005d70:	c1 73       	brcs	80005d9e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005d72:	6e 08       	ld.w	r8,r7[0x0]
80005d74:	8f 28       	st.w	r7[0x8],r8
80005d76:	c1 48       	rjmp	80005d9e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005d78:	10 9a       	mov	r10,r8
80005d7a:	78 3c       	ld.w	r12,r12[0xc]
80005d7c:	f0 1f 00 0c 	mcall	80005dac <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005d80:	6f 08       	ld.w	r8,r7[0x40]
80005d82:	6e 39       	ld.w	r9,r7[0xc]
80005d84:	f2 08 01 08 	sub	r8,r9,r8
80005d88:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005d8a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005d8c:	12 38       	cp.w	r8,r9
80005d8e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005d92:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005d96:	f3 d8 e3 19 	subcs	r9,r9,r8
80005d9a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005d9e:	6e e8       	ld.w	r8,r7[0x38]
80005da0:	2f f8       	sub	r8,-1
80005da2:	8f e8       	st.w	r7[0x38],r8
}
80005da4:	e3 cd 80 80 	ldm	sp++,r7,pc
80005da8:	80 00       	ld.sh	r0,r0[0x0]
80005daa:	60 88       	ld.w	r8,r0[0x20]
80005dac:	80 00       	ld.sh	r0,r0[0x0]
80005dae:	72 ac       	ld.w	r12,r9[0x28]

80005db0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005db0:	eb cd 40 c0 	pushm	r6-r7,lr
80005db4:	18 97       	mov	r7,r12
80005db6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005db8:	78 ec       	ld.w	r12,r12[0x38]
80005dba:	6e f8       	ld.w	r8,r7[0x3c]
80005dbc:	10 3c       	cp.w	r12,r8
80005dbe:	c0 33       	brcs	80005dc4 <xQueueGenericSendFromISR+0x14>
80005dc0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005dc4:	12 9a       	mov	r10,r9
80005dc6:	0e 9c       	mov	r12,r7
80005dc8:	f0 1f 00 0c 	mcall	80005df8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005dcc:	6f 28       	ld.w	r8,r7[0x48]
80005dce:	5b f8       	cp.w	r8,-1
80005dd0:	c0 d1       	brne	80005dea <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005dd2:	6e 98       	ld.w	r8,r7[0x24]
80005dd4:	58 08       	cp.w	r8,0
80005dd6:	c0 f0       	breq	80005df4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005dd8:	ee cc ff dc 	sub	r12,r7,-36
80005ddc:	f0 1f 00 08 	mcall	80005dfc <xQueueGenericSendFromISR+0x4c>
80005de0:	c0 a0       	breq	80005df4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005de2:	30 1c       	mov	r12,1
80005de4:	8d 0c       	st.w	r6[0x0],r12
80005de6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005dea:	2f f8       	sub	r8,-1
80005dec:	ef 48 00 48 	st.w	r7[72],r8
80005df0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005df4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	5d 38       	musfr	r8
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	61 64       	ld.w	r4,r0[0x58]

80005e00 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005e00:	d4 31       	pushm	r0-r7,lr
80005e02:	20 5d       	sub	sp,20
80005e04:	18 97       	mov	r7,r12
80005e06:	50 0b       	stdsp	sp[0x0],r11
80005e08:	50 2a       	stdsp	sp[0x8],r10
80005e0a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005e0c:	f8 c0 ff f0 	sub	r0,r12,-16
80005e10:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e12:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005e16:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e18:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005e1c:	f0 1f 00 2f 	mcall	80005ed8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005e20:	6e e9       	ld.w	r9,r7[0x38]
80005e22:	6e f8       	ld.w	r8,r7[0x3c]
80005e24:	10 39       	cp.w	r9,r8
80005e26:	c1 42       	brcc	80005e4e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005e28:	40 1a       	lddsp	r10,sp[0x4]
80005e2a:	40 0b       	lddsp	r11,sp[0x0]
80005e2c:	0e 9c       	mov	r12,r7
80005e2e:	f0 1f 00 2c 	mcall	80005edc <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005e32:	6e 98       	ld.w	r8,r7[0x24]
80005e34:	58 08       	cp.w	r8,0
80005e36:	c0 80       	breq	80005e46 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005e38:	ee cc ff dc 	sub	r12,r7,-36
80005e3c:	f0 1f 00 29 	mcall	80005ee0 <xQueueGenericSend+0xe0>
80005e40:	58 1c       	cp.w	r12,1
80005e42:	c0 21       	brne	80005e46 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005e44:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005e46:	f0 1f 00 28 	mcall	80005ee4 <xQueueGenericSend+0xe4>
80005e4a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005e4c:	c4 38       	rjmp	80005ed2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005e4e:	40 28       	lddsp	r8,sp[0x8]
80005e50:	58 08       	cp.w	r8,0
80005e52:	c0 51       	brne	80005e5c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005e54:	f0 1f 00 24 	mcall	80005ee4 <xQueueGenericSend+0xe4>
80005e58:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005e5a:	c3 c8       	rjmp	80005ed2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005e5c:	58 04       	cp.w	r4,0
80005e5e:	c0 51       	brne	80005e68 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005e60:	06 9c       	mov	r12,r3
80005e62:	f0 1f 00 22 	mcall	80005ee8 <xQueueGenericSend+0xe8>
80005e66:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005e68:	f0 1f 00 1f 	mcall	80005ee4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005e6c:	f0 1f 00 20 	mcall	80005eec <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005e70:	f0 1f 00 1a 	mcall	80005ed8 <xQueueGenericSend+0xd8>
80005e74:	6f 18       	ld.w	r8,r7[0x44]
80005e76:	5b f8       	cp.w	r8,-1
80005e78:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005e7c:	6f 28       	ld.w	r8,r7[0x48]
80005e7e:	5b f8       	cp.w	r8,-1
80005e80:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005e84:	f0 1f 00 18 	mcall	80005ee4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005e88:	04 9b       	mov	r11,r2
80005e8a:	06 9c       	mov	r12,r3
80005e8c:	f0 1f 00 19 	mcall	80005ef0 <xQueueGenericSend+0xf0>
80005e90:	c1 b1       	brne	80005ec6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005e92:	f0 1f 00 12 	mcall	80005ed8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005e96:	6e e5       	ld.w	r5,r7[0x38]
80005e98:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005e9a:	f0 1f 00 13 	mcall	80005ee4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005e9e:	0c 35       	cp.w	r5,r6
80005ea0:	c0 d1       	brne	80005eba <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005ea2:	40 2b       	lddsp	r11,sp[0x8]
80005ea4:	00 9c       	mov	r12,r0
80005ea6:	f0 1f 00 14 	mcall	80005ef4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005eaa:	0e 9c       	mov	r12,r7
80005eac:	f0 1f 00 13 	mcall	80005ef8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005eb0:	f0 1f 00 13 	mcall	80005efc <xQueueGenericSend+0xfc>
80005eb4:	cb 41       	brne	80005e1c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005eb6:	d7 33       	scall
80005eb8:	cb 2b       	rjmp	80005e1c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005eba:	0e 9c       	mov	r12,r7
80005ebc:	f0 1f 00 0f 	mcall	80005ef8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005ec0:	f0 1f 00 0f 	mcall	80005efc <xQueueGenericSend+0xfc>
80005ec4:	ca cb       	rjmp	80005e1c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005ec6:	0e 9c       	mov	r12,r7
80005ec8:	f0 1f 00 0c 	mcall	80005ef8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005ecc:	f0 1f 00 0c 	mcall	80005efc <xQueueGenericSend+0xfc>
80005ed0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005ed2:	2f bd       	sub	sp,-20
80005ed4:	d8 32       	popm	r0-r7,pc
80005ed6:	00 00       	add	r0,r0
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	58 40       	cp.w	r0,4
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	5d 38       	musfr	r8
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	61 64       	ld.w	r4,r0[0x58]
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	59 4c       	cp.w	r12,20
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	60 58       	ld.w	r8,r0[0x14]
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	5f cc       	srvs	r12
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	62 f4       	ld.w	r4,r1[0x3c]
80005ef4:	80 00       	ld.sh	r0,r0[0x0]
80005ef6:	65 94       	ld.w	r4,r2[0x64]
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	5b 54       	cp.w	r4,-11
80005efc:	80 00       	ld.sh	r0,r0[0x0]
80005efe:	63 88       	ld.w	r8,r1[0x60]

80005f00 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005f00:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005f04:	34 cc       	mov	r12,76
80005f06:	f0 1f 00 12 	mcall	80005f4c <xQueueCreateMutex+0x4c>
80005f0a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80005f0c:	c1 d0       	breq	80005f46 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80005f0e:	30 06       	mov	r6,0
80005f10:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005f12:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005f14:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005f16:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005f18:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80005f1a:	30 18       	mov	r8,1
80005f1c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80005f1e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80005f22:	3f f8       	mov	r8,-1
80005f24:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005f28:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005f2c:	2f 0c       	sub	r12,-16
80005f2e:	f0 1f 00 09 	mcall	80005f50 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005f32:	ee cc ff dc 	sub	r12,r7,-36
80005f36:	f0 1f 00 07 	mcall	80005f50 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80005f3a:	0c 99       	mov	r9,r6
80005f3c:	0c 9a       	mov	r10,r6
80005f3e:	0c 9b       	mov	r11,r6
80005f40:	0e 9c       	mov	r12,r7
80005f42:	f0 1f 00 05 	mcall	80005f54 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80005f46:	0e 9c       	mov	r12,r7
80005f48:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	5a ac       	cp.w	r12,-22
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	57 1c       	stdsp	sp[0x1c4],r12
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	5e 00       	reteq	r0

80005f58 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005f58:	d4 21       	pushm	r4-r7,lr
80005f5a:	18 97       	mov	r7,r12
80005f5c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005f5e:	58 0c       	cp.w	r12,0
80005f60:	c2 f0       	breq	80005fbe <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005f62:	34 cc       	mov	r12,76
80005f64:	f0 1f 00 17 	mcall	80005fc0 <xQueueCreate+0x68>
80005f68:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005f6a:	c2 a0       	breq	80005fbe <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005f6c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005f70:	e8 cc ff ff 	sub	r12,r4,-1
80005f74:	f0 1f 00 13 	mcall	80005fc0 <xQueueCreate+0x68>
80005f78:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005f7a:	c1 e0       	breq	80005fb6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005f7c:	f8 04 00 04 	add	r4,r12,r4
80005f80:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005f82:	30 08       	mov	r8,0
80005f84:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005f86:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005f88:	ee c8 00 01 	sub	r8,r7,1
80005f8c:	ad 38       	mul	r8,r6
80005f8e:	10 0c       	add	r12,r8
80005f90:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005f92:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005f94:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005f98:	3f f8       	mov	r8,-1
80005f9a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005f9e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005fa2:	ea cc ff f0 	sub	r12,r5,-16
80005fa6:	f0 1f 00 08 	mcall	80005fc4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005faa:	ea cc ff dc 	sub	r12,r5,-36
80005fae:	f0 1f 00 06 	mcall	80005fc4 <xQueueCreate+0x6c>
80005fb2:	0a 9c       	mov	r12,r5
80005fb4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005fb6:	0a 9c       	mov	r12,r5
80005fb8:	f0 1f 00 04 	mcall	80005fc8 <xQueueCreate+0x70>
80005fbc:	d8 2a       	popm	r4-r7,pc,r12=0
80005fbe:	d8 2a       	popm	r4-r7,pc,r12=0
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	5a ac       	cp.w	r12,-22
80005fc4:	80 00       	ld.sh	r0,r0[0x0]
80005fc6:	57 1c       	stdsp	sp[0x1c4],r12
80005fc8:	80 00       	ld.sh	r0,r0[0x0]
80005fca:	5a 84       	cp.w	r4,-24

80005fcc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005fcc:	48 38       	lddpc	r8,80005fd8 <vTaskSuspendAll+0xc>
80005fce:	70 09       	ld.w	r9,r8[0x0]
80005fd0:	2f f9       	sub	r9,-1
80005fd2:	91 09       	st.w	r8[0x0],r9
}
80005fd4:	5e fc       	retal	r12
80005fd6:	00 00       	add	r0,r0
80005fd8:	00 00       	add	r0,r0
80005fda:	0d 00       	ld.w	r0,r6++

80005fdc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005fdc:	49 a8       	lddpc	r8,80006044 <vTaskSwitchContext+0x68>
80005fde:	70 08       	ld.w	r8,r8[0x0]
80005fe0:	58 08       	cp.w	r8,0
80005fe2:	c0 b1       	brne	80005ff8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005fe4:	49 98       	lddpc	r8,80006048 <vTaskSwitchContext+0x6c>
80005fe6:	70 08       	ld.w	r8,r8[0x0]
80005fe8:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005fec:	49 89       	lddpc	r9,8000604c <vTaskSwitchContext+0x70>
80005fee:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005ff2:	58 08       	cp.w	r8,0
80005ff4:	c0 60       	breq	80006000 <vTaskSwitchContext+0x24>
80005ff6:	c1 18       	rjmp	80006018 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005ff8:	30 19       	mov	r9,1
80005ffa:	49 68       	lddpc	r8,80006050 <vTaskSwitchContext+0x74>
80005ffc:	91 09       	st.w	r8[0x0],r9
80005ffe:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006000:	49 28       	lddpc	r8,80006048 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006002:	49 3a       	lddpc	r10,8000604c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006004:	70 09       	ld.w	r9,r8[0x0]
80006006:	20 19       	sub	r9,1
80006008:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000600a:	70 09       	ld.w	r9,r8[0x0]
8000600c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006010:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006014:	58 09       	cp.w	r9,0
80006016:	cf 70       	breq	80006004 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006018:	48 c8       	lddpc	r8,80006048 <vTaskSwitchContext+0x6c>
8000601a:	70 08       	ld.w	r8,r8[0x0]
8000601c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006020:	48 b9       	lddpc	r9,8000604c <vTaskSwitchContext+0x70>
80006022:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006026:	70 19       	ld.w	r9,r8[0x4]
80006028:	72 19       	ld.w	r9,r9[0x4]
8000602a:	91 19       	st.w	r8[0x4],r9
8000602c:	f0 ca ff f8 	sub	r10,r8,-8
80006030:	14 39       	cp.w	r9,r10
80006032:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006036:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000603a:	70 18       	ld.w	r8,r8[0x4]
8000603c:	70 39       	ld.w	r9,r8[0xc]
8000603e:	48 68       	lddpc	r8,80006054 <vTaskSwitchContext+0x78>
80006040:	91 09       	st.w	r8[0x0],r9
80006042:	5e fc       	retal	r12
80006044:	00 00       	add	r0,r0
80006046:	0d 00       	ld.w	r0,r6++
80006048:	00 00       	add	r0,r0
8000604a:	0d 38       	ld.ub	r8,r6++
8000604c:	00 00       	add	r0,r0
8000604e:	0c 1c       	sub	r12,r6
80006050:	00 00       	add	r0,r0
80006052:	0d 20       	ld.uh	r0,r6++
80006054:	00 00       	add	r0,r0
80006056:	0c d0       	st.w	--r6,r0

80006058 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006058:	48 48       	lddpc	r8,80006068 <vTaskSetTimeOutState+0x10>
8000605a:	70 08       	ld.w	r8,r8[0x0]
8000605c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000605e:	48 48       	lddpc	r8,8000606c <vTaskSetTimeOutState+0x14>
80006060:	70 08       	ld.w	r8,r8[0x0]
80006062:	99 18       	st.w	r12[0x4],r8
}
80006064:	5e fc       	retal	r12
80006066:	00 00       	add	r0,r0
80006068:	00 00       	add	r0,r0
8000606a:	0c 14       	sub	r4,r6
8000606c:	00 00       	add	r0,r0
8000606e:	0c fc       	st.b	--r6,r12

80006070 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006070:	30 19       	mov	r9,1
80006072:	48 28       	lddpc	r8,80006078 <vTaskMissedYield+0x8>
80006074:	91 09       	st.w	r8[0x0],r9
}
80006076:	5e fc       	retal	r12
80006078:	00 00       	add	r0,r0
8000607a:	0d 20       	ld.uh	r0,r6++

8000607c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000607c:	48 28       	lddpc	r8,80006084 <xTaskGetCurrentTaskHandle+0x8>
8000607e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006080:	5e fc       	retal	r12
80006082:	00 00       	add	r0,r0
80006084:	00 00       	add	r0,r0
80006086:	0c d0       	st.w	--r6,r0

80006088 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006088:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000608c:	58 0c       	cp.w	r12,0
8000608e:	c1 f0       	breq	800060cc <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006090:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006092:	78 b9       	ld.w	r9,r12[0x2c]
80006094:	79 18       	ld.w	r8,r12[0x44]
80006096:	10 39       	cp.w	r9,r8
80006098:	c1 a0       	breq	800060cc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000609a:	f8 c6 ff fc 	sub	r6,r12,-4
8000609e:	0c 9c       	mov	r12,r6
800060a0:	f0 1f 00 0c 	mcall	800060d0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800060a4:	6f 1c       	ld.w	r12,r7[0x44]
800060a6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800060a8:	f8 08 11 08 	rsub	r8,r12,8
800060ac:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800060ae:	48 a8       	lddpc	r8,800060d4 <vTaskPriorityDisinherit+0x4c>
800060b0:	70 08       	ld.w	r8,r8[0x0]
800060b2:	10 3c       	cp.w	r12,r8
800060b4:	e0 88 00 04 	brls	800060bc <vTaskPriorityDisinherit+0x34>
800060b8:	48 78       	lddpc	r8,800060d4 <vTaskPriorityDisinherit+0x4c>
800060ba:	91 0c       	st.w	r8[0x0],r12
800060bc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800060c0:	0c 9b       	mov	r11,r6
800060c2:	48 68       	lddpc	r8,800060d8 <vTaskPriorityDisinherit+0x50>
800060c4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800060c8:	f0 1f 00 05 	mcall	800060dc <vTaskPriorityDisinherit+0x54>
800060cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	57 86       	stdsp	sp[0x1e0],r6
800060d4:	00 00       	add	r0,r0
800060d6:	0d 38       	ld.ub	r8,r6++
800060d8:	00 00       	add	r0,r0
800060da:	0c 1c       	sub	r12,r6
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	57 36       	stdsp	sp[0x1cc],r6

800060e0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800060e0:	eb cd 40 c0 	pushm	r6-r7,lr
800060e4:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800060e6:	49 b8       	lddpc	r8,80006150 <vTaskPriorityInherit+0x70>
800060e8:	70 08       	ld.w	r8,r8[0x0]
800060ea:	78 b9       	ld.w	r9,r12[0x2c]
800060ec:	70 b8       	ld.w	r8,r8[0x2c]
800060ee:	10 39       	cp.w	r9,r8
800060f0:	c2 d2       	brcc	8000614a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800060f2:	49 88       	lddpc	r8,80006150 <vTaskPriorityInherit+0x70>
800060f4:	70 08       	ld.w	r8,r8[0x0]
800060f6:	70 b8       	ld.w	r8,r8[0x2c]
800060f8:	f0 08 11 08 	rsub	r8,r8,8
800060fc:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800060fe:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006102:	49 59       	lddpc	r9,80006154 <vTaskPriorityInherit+0x74>
80006104:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006108:	78 59       	ld.w	r9,r12[0x14]
8000610a:	10 39       	cp.w	r9,r8
8000610c:	c1 b1       	brne	80006142 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000610e:	f8 c6 ff fc 	sub	r6,r12,-4
80006112:	0c 9c       	mov	r12,r6
80006114:	f0 1f 00 11 	mcall	80006158 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006118:	48 e8       	lddpc	r8,80006150 <vTaskPriorityInherit+0x70>
8000611a:	70 08       	ld.w	r8,r8[0x0]
8000611c:	70 bc       	ld.w	r12,r8[0x2c]
8000611e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006120:	48 f8       	lddpc	r8,8000615c <vTaskPriorityInherit+0x7c>
80006122:	70 08       	ld.w	r8,r8[0x0]
80006124:	10 3c       	cp.w	r12,r8
80006126:	e0 88 00 04 	brls	8000612e <vTaskPriorityInherit+0x4e>
8000612a:	48 d8       	lddpc	r8,8000615c <vTaskPriorityInherit+0x7c>
8000612c:	91 0c       	st.w	r8[0x0],r12
8000612e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006132:	0c 9b       	mov	r11,r6
80006134:	48 88       	lddpc	r8,80006154 <vTaskPriorityInherit+0x74>
80006136:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000613a:	f0 1f 00 0a 	mcall	80006160 <vTaskPriorityInherit+0x80>
8000613e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006142:	48 48       	lddpc	r8,80006150 <vTaskPriorityInherit+0x70>
80006144:	70 08       	ld.w	r8,r8[0x0]
80006146:	70 b8       	ld.w	r8,r8[0x2c]
80006148:	99 b8       	st.w	r12[0x2c],r8
8000614a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000614e:	00 00       	add	r0,r0
80006150:	00 00       	add	r0,r0
80006152:	0c d0       	st.w	--r6,r0
80006154:	00 00       	add	r0,r0
80006156:	0c 1c       	sub	r12,r6
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	57 86       	stdsp	sp[0x1e0],r6
8000615c:	00 00       	add	r0,r0
8000615e:	0d 38       	ld.ub	r8,r6++
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	57 36       	stdsp	sp[0x1cc],r6

80006164 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006164:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006168:	78 38       	ld.w	r8,r12[0xc]
8000616a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000616c:	ee c6 ff e8 	sub	r6,r7,-24
80006170:	0c 9c       	mov	r12,r6
80006172:	f0 1f 00 15 	mcall	800061c4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006176:	49 58       	lddpc	r8,800061c8 <xTaskRemoveFromEventList+0x64>
80006178:	70 08       	ld.w	r8,r8[0x0]
8000617a:	58 08       	cp.w	r8,0
8000617c:	c1 71       	brne	800061aa <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000617e:	ee c6 ff fc 	sub	r6,r7,-4
80006182:	0c 9c       	mov	r12,r6
80006184:	f0 1f 00 10 	mcall	800061c4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006188:	6e bc       	ld.w	r12,r7[0x2c]
8000618a:	49 18       	lddpc	r8,800061cc <xTaskRemoveFromEventList+0x68>
8000618c:	70 08       	ld.w	r8,r8[0x0]
8000618e:	10 3c       	cp.w	r12,r8
80006190:	e0 88 00 04 	brls	80006198 <xTaskRemoveFromEventList+0x34>
80006194:	48 e8       	lddpc	r8,800061cc <xTaskRemoveFromEventList+0x68>
80006196:	91 0c       	st.w	r8[0x0],r12
80006198:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000619c:	0c 9b       	mov	r11,r6
8000619e:	48 d8       	lddpc	r8,800061d0 <xTaskRemoveFromEventList+0x6c>
800061a0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800061a4:	f0 1f 00 0c 	mcall	800061d4 <xTaskRemoveFromEventList+0x70>
800061a8:	c0 58       	rjmp	800061b2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800061aa:	0c 9b       	mov	r11,r6
800061ac:	48 bc       	lddpc	r12,800061d8 <xTaskRemoveFromEventList+0x74>
800061ae:	f0 1f 00 0a 	mcall	800061d4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800061b2:	48 b8       	lddpc	r8,800061dc <xTaskRemoveFromEventList+0x78>
800061b4:	70 08       	ld.w	r8,r8[0x0]
800061b6:	6e b9       	ld.w	r9,r7[0x2c]
800061b8:	70 b8       	ld.w	r8,r8[0x2c]
800061ba:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800061bc:	5f 2c       	srhs	r12
800061be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061c2:	00 00       	add	r0,r0
800061c4:	80 00       	ld.sh	r0,r0[0x0]
800061c6:	57 86       	stdsp	sp[0x1e0],r6
800061c8:	00 00       	add	r0,r0
800061ca:	0d 00       	ld.w	r0,r6++
800061cc:	00 00       	add	r0,r0
800061ce:	0d 38       	ld.ub	r8,r6++
800061d0:	00 00       	add	r0,r0
800061d2:	0c 1c       	sub	r12,r6
800061d4:	80 00       	ld.sh	r0,r0[0x0]
800061d6:	57 36       	stdsp	sp[0x1cc],r6
800061d8:	00 00       	add	r0,r0
800061da:	0c d4       	st.w	--r6,r4
800061dc:	00 00       	add	r0,r0
800061de:	0c d0       	st.w	--r6,r0

800061e0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800061e0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800061e4:	4b 98       	lddpc	r8,800062c8 <vTaskIncrementTick+0xe8>
800061e6:	70 08       	ld.w	r8,r8[0x0]
800061e8:	58 08       	cp.w	r8,0
800061ea:	c6 91       	brne	800062bc <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800061ec:	4b 88       	lddpc	r8,800062cc <vTaskIncrementTick+0xec>
800061ee:	70 09       	ld.w	r9,r8[0x0]
800061f0:	2f f9       	sub	r9,-1
800061f2:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800061f4:	70 08       	ld.w	r8,r8[0x0]
800061f6:	58 08       	cp.w	r8,0
800061f8:	c1 a1       	brne	8000622c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800061fa:	4b 68       	lddpc	r8,800062d0 <vTaskIncrementTick+0xf0>
800061fc:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800061fe:	4b 69       	lddpc	r9,800062d4 <vTaskIncrementTick+0xf4>
80006200:	72 0b       	ld.w	r11,r9[0x0]
80006202:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006204:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006206:	4b 59       	lddpc	r9,800062d8 <vTaskIncrementTick+0xf8>
80006208:	72 0a       	ld.w	r10,r9[0x0]
8000620a:	2f fa       	sub	r10,-1
8000620c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000620e:	70 08       	ld.w	r8,r8[0x0]
80006210:	70 08       	ld.w	r8,r8[0x0]
80006212:	58 08       	cp.w	r8,0
80006214:	c0 51       	brne	8000621e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006216:	3f f9       	mov	r9,-1
80006218:	4b 18       	lddpc	r8,800062dc <vTaskIncrementTick+0xfc>
8000621a:	91 09       	st.w	r8[0x0],r9
8000621c:	c0 88       	rjmp	8000622c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000621e:	4a d8       	lddpc	r8,800062d0 <vTaskIncrementTick+0xf0>
80006220:	70 08       	ld.w	r8,r8[0x0]
80006222:	70 38       	ld.w	r8,r8[0xc]
80006224:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006226:	70 19       	ld.w	r9,r8[0x4]
80006228:	4a d8       	lddpc	r8,800062dc <vTaskIncrementTick+0xfc>
8000622a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000622c:	4a 88       	lddpc	r8,800062cc <vTaskIncrementTick+0xec>
8000622e:	70 09       	ld.w	r9,r8[0x0]
80006230:	4a b8       	lddpc	r8,800062dc <vTaskIncrementTick+0xfc>
80006232:	70 08       	ld.w	r8,r8[0x0]
80006234:	10 39       	cp.w	r9,r8
80006236:	c4 73       	brcs	800062c4 <vTaskIncrementTick+0xe4>
80006238:	4a 68       	lddpc	r8,800062d0 <vTaskIncrementTick+0xf0>
8000623a:	70 08       	ld.w	r8,r8[0x0]
8000623c:	70 08       	ld.w	r8,r8[0x0]
8000623e:	58 08       	cp.w	r8,0
80006240:	c0 c0       	breq	80006258 <vTaskIncrementTick+0x78>
80006242:	4a 48       	lddpc	r8,800062d0 <vTaskIncrementTick+0xf0>
80006244:	70 08       	ld.w	r8,r8[0x0]
80006246:	70 38       	ld.w	r8,r8[0xc]
80006248:	70 37       	ld.w	r7,r8[0xc]
8000624a:	6e 18       	ld.w	r8,r7[0x4]
8000624c:	4a 09       	lddpc	r9,800062cc <vTaskIncrementTick+0xec>
8000624e:	72 09       	ld.w	r9,r9[0x0]
80006250:	12 38       	cp.w	r8,r9
80006252:	e0 88 00 14 	brls	8000627a <vTaskIncrementTick+0x9a>
80006256:	c0 e8       	rjmp	80006272 <vTaskIncrementTick+0x92>
80006258:	3f f9       	mov	r9,-1
8000625a:	4a 18       	lddpc	r8,800062dc <vTaskIncrementTick+0xfc>
8000625c:	91 09       	st.w	r8[0x0],r9
8000625e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006262:	6a 08       	ld.w	r8,r5[0x0]
80006264:	70 38       	ld.w	r8,r8[0xc]
80006266:	70 37       	ld.w	r7,r8[0xc]
80006268:	6e 18       	ld.w	r8,r7[0x4]
8000626a:	64 09       	ld.w	r9,r2[0x0]
8000626c:	12 38       	cp.w	r8,r9
8000626e:	e0 88 00 0a 	brls	80006282 <vTaskIncrementTick+0xa2>
80006272:	49 b9       	lddpc	r9,800062dc <vTaskIncrementTick+0xfc>
80006274:	93 08       	st.w	r9[0x0],r8
80006276:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000627a:	49 a4       	lddpc	r4,800062e0 <vTaskIncrementTick+0x100>
8000627c:	49 a3       	lddpc	r3,800062e4 <vTaskIncrementTick+0x104>
8000627e:	49 55       	lddpc	r5,800062d0 <vTaskIncrementTick+0xf0>
80006280:	49 32       	lddpc	r2,800062cc <vTaskIncrementTick+0xec>
80006282:	ee c6 ff fc 	sub	r6,r7,-4
80006286:	0c 9c       	mov	r12,r6
80006288:	f0 1f 00 18 	mcall	800062e8 <vTaskIncrementTick+0x108>
8000628c:	6e a8       	ld.w	r8,r7[0x28]
8000628e:	58 08       	cp.w	r8,0
80006290:	c0 50       	breq	8000629a <vTaskIncrementTick+0xba>
80006292:	ee cc ff e8 	sub	r12,r7,-24
80006296:	f0 1f 00 15 	mcall	800062e8 <vTaskIncrementTick+0x108>
8000629a:	6e bc       	ld.w	r12,r7[0x2c]
8000629c:	68 08       	ld.w	r8,r4[0x0]
8000629e:	10 3c       	cp.w	r12,r8
800062a0:	e9 fc ba 00 	st.whi	r4[0x0],r12
800062a4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800062a8:	0c 9b       	mov	r11,r6
800062aa:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800062ae:	f0 1f 00 10 	mcall	800062ec <vTaskIncrementTick+0x10c>
800062b2:	6a 08       	ld.w	r8,r5[0x0]
800062b4:	70 08       	ld.w	r8,r8[0x0]
800062b6:	58 08       	cp.w	r8,0
800062b8:	cd 51       	brne	80006262 <vTaskIncrementTick+0x82>
800062ba:	cc fb       	rjmp	80006258 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800062bc:	48 d8       	lddpc	r8,800062f0 <vTaskIncrementTick+0x110>
800062be:	70 09       	ld.w	r9,r8[0x0]
800062c0:	2f f9       	sub	r9,-1
800062c2:	91 09       	st.w	r8[0x0],r9
800062c4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800062c8:	00 00       	add	r0,r0
800062ca:	0d 00       	ld.w	r0,r6++
800062cc:	00 00       	add	r0,r0
800062ce:	0c fc       	st.b	--r6,r12
800062d0:	00 00       	add	r0,r0
800062d2:	0c 08       	add	r8,r6
800062d4:	00 00       	add	r0,r0
800062d6:	0c 18       	sub	r8,r6
800062d8:	00 00       	add	r0,r0
800062da:	0c 14       	sub	r4,r6
800062dc:	00 00       	add	r0,r0
800062de:	05 2c       	ld.uh	r12,r2++
800062e0:	00 00       	add	r0,r0
800062e2:	0d 38       	ld.ub	r8,r6++
800062e4:	00 00       	add	r0,r0
800062e6:	0c 1c       	sub	r12,r6
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	57 86       	stdsp	sp[0x1e0],r6
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	57 36       	stdsp	sp[0x1cc],r6
800062f0:	00 00       	add	r0,r0
800062f2:	0c 00       	add	r0,r6

800062f4 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800062f4:	eb cd 40 c0 	pushm	r6-r7,lr
800062f8:	18 97       	mov	r7,r12
800062fa:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800062fc:	f0 1f 00 15 	mcall	80006350 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006300:	6c 08       	ld.w	r8,r6[0x0]
80006302:	5b f8       	cp.w	r8,-1
80006304:	c0 31       	brne	8000630a <xTaskCheckForTimeOut+0x16>
80006306:	30 07       	mov	r7,0
80006308:	c1 f8       	rjmp	80006346 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000630a:	49 39       	lddpc	r9,80006354 <xTaskCheckForTimeOut+0x60>
8000630c:	72 09       	ld.w	r9,r9[0x0]
8000630e:	6e 0a       	ld.w	r10,r7[0x0]
80006310:	12 3a       	cp.w	r10,r9
80006312:	c0 70       	breq	80006320 <xTaskCheckForTimeOut+0x2c>
80006314:	49 19       	lddpc	r9,80006358 <xTaskCheckForTimeOut+0x64>
80006316:	72 09       	ld.w	r9,r9[0x0]
80006318:	6e 1a       	ld.w	r10,r7[0x4]
8000631a:	12 3a       	cp.w	r10,r9
8000631c:	e0 88 00 14 	brls	80006344 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006320:	48 e9       	lddpc	r9,80006358 <xTaskCheckForTimeOut+0x64>
80006322:	72 0a       	ld.w	r10,r9[0x0]
80006324:	6e 19       	ld.w	r9,r7[0x4]
80006326:	12 1a       	sub	r10,r9
80006328:	14 38       	cp.w	r8,r10
8000632a:	e0 88 00 0d 	brls	80006344 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000632e:	48 ba       	lddpc	r10,80006358 <xTaskCheckForTimeOut+0x64>
80006330:	74 0a       	ld.w	r10,r10[0x0]
80006332:	14 19       	sub	r9,r10
80006334:	f2 08 00 08 	add	r8,r9,r8
80006338:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000633a:	0e 9c       	mov	r12,r7
8000633c:	f0 1f 00 08 	mcall	8000635c <xTaskCheckForTimeOut+0x68>
80006340:	30 07       	mov	r7,0
80006342:	c0 28       	rjmp	80006346 <xTaskCheckForTimeOut+0x52>
80006344:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006346:	f0 1f 00 07 	mcall	80006360 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000634a:	0e 9c       	mov	r12,r7
8000634c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	58 40       	cp.w	r0,4
80006354:	00 00       	add	r0,r0
80006356:	0c 14       	sub	r4,r6
80006358:	00 00       	add	r0,r0
8000635a:	0c fc       	st.b	--r6,r12
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	60 58       	ld.w	r8,r0[0x14]
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	59 4c       	cp.w	r12,20

80006364 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006364:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006368:	f0 1f 00 05 	mcall	8000637c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000636c:	48 58       	lddpc	r8,80006380 <xTaskGetTickCount+0x1c>
8000636e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006370:	f0 1f 00 05 	mcall	80006384 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006374:	0e 9c       	mov	r12,r7
80006376:	e3 cd 80 80 	ldm	sp++,r7,pc
8000637a:	00 00       	add	r0,r0
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	58 40       	cp.w	r0,4
80006380:	00 00       	add	r0,r0
80006382:	0c fc       	st.b	--r6,r12
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	59 4c       	cp.w	r12,20

80006388 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006388:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000638c:	f0 1f 00 2c 	mcall	8000643c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006390:	4a c8       	lddpc	r8,80006440 <xTaskResumeAll+0xb8>
80006392:	70 09       	ld.w	r9,r8[0x0]
80006394:	20 19       	sub	r9,1
80006396:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006398:	70 08       	ld.w	r8,r8[0x0]
8000639a:	58 08       	cp.w	r8,0
8000639c:	c4 91       	brne	8000642e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000639e:	4a a8       	lddpc	r8,80006444 <xTaskResumeAll+0xbc>
800063a0:	70 08       	ld.w	r8,r8[0x0]
800063a2:	58 08       	cp.w	r8,0
800063a4:	c4 50       	breq	8000642e <xTaskResumeAll+0xa6>
800063a6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800063a8:	4a 85       	lddpc	r5,80006448 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800063aa:	4a 93       	lddpc	r3,8000644c <xTaskResumeAll+0xc4>
800063ac:	4a 92       	lddpc	r2,80006450 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800063ae:	4a a1       	lddpc	r1,80006454 <xTaskResumeAll+0xcc>
800063b0:	c1 e8       	rjmp	800063ec <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800063b2:	6a 38       	ld.w	r8,r5[0xc]
800063b4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800063b6:	ee cc ff e8 	sub	r12,r7,-24
800063ba:	f0 1f 00 28 	mcall	80006458 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800063be:	ee c6 ff fc 	sub	r6,r7,-4
800063c2:	0c 9c       	mov	r12,r6
800063c4:	f0 1f 00 25 	mcall	80006458 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800063c8:	6e bc       	ld.w	r12,r7[0x2c]
800063ca:	66 08       	ld.w	r8,r3[0x0]
800063cc:	10 3c       	cp.w	r12,r8
800063ce:	e7 fc ba 00 	st.whi	r3[0x0],r12
800063d2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800063d6:	0c 9b       	mov	r11,r6
800063d8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800063dc:	f0 1f 00 20 	mcall	8000645c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800063e0:	62 08       	ld.w	r8,r1[0x0]
800063e2:	6e b9       	ld.w	r9,r7[0x2c]
800063e4:	70 b8       	ld.w	r8,r8[0x2c]
800063e6:	10 39       	cp.w	r9,r8
800063e8:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800063ec:	6a 08       	ld.w	r8,r5[0x0]
800063ee:	58 08       	cp.w	r8,0
800063f0:	ce 11       	brne	800063b2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063f2:	49 c8       	lddpc	r8,80006460 <xTaskResumeAll+0xd8>
800063f4:	70 08       	ld.w	r8,r8[0x0]
800063f6:	58 08       	cp.w	r8,0
800063f8:	c0 f0       	breq	80006416 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800063fa:	49 a8       	lddpc	r8,80006460 <xTaskResumeAll+0xd8>
800063fc:	70 08       	ld.w	r8,r8[0x0]
800063fe:	58 08       	cp.w	r8,0
80006400:	c1 10       	breq	80006422 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006402:	49 87       	lddpc	r7,80006460 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006404:	f0 1f 00 18 	mcall	80006464 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006408:	6e 08       	ld.w	r8,r7[0x0]
8000640a:	20 18       	sub	r8,1
8000640c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000640e:	6e 08       	ld.w	r8,r7[0x0]
80006410:	58 08       	cp.w	r8,0
80006412:	cf 91       	brne	80006404 <xTaskResumeAll+0x7c>
80006414:	c0 78       	rjmp	80006422 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006416:	58 14       	cp.w	r4,1
80006418:	c0 50       	breq	80006422 <xTaskResumeAll+0x9a>
8000641a:	49 48       	lddpc	r8,80006468 <xTaskResumeAll+0xe0>
8000641c:	70 08       	ld.w	r8,r8[0x0]
8000641e:	58 18       	cp.w	r8,1
80006420:	c0 71       	brne	8000642e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006422:	30 09       	mov	r9,0
80006424:	49 18       	lddpc	r8,80006468 <xTaskResumeAll+0xe0>
80006426:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006428:	d7 33       	scall
8000642a:	30 17       	mov	r7,1
8000642c:	c0 28       	rjmp	80006430 <xTaskResumeAll+0xa8>
8000642e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006430:	f0 1f 00 0f 	mcall	8000646c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006434:	0e 9c       	mov	r12,r7
80006436:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000643a:	00 00       	add	r0,r0
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	58 40       	cp.w	r0,4
80006440:	00 00       	add	r0,r0
80006442:	0d 00       	ld.w	r0,r6++
80006444:	00 00       	add	r0,r0
80006446:	0d 1c       	ld.sh	r12,r6++
80006448:	00 00       	add	r0,r0
8000644a:	0c d4       	st.w	--r6,r4
8000644c:	00 00       	add	r0,r0
8000644e:	0d 38       	ld.ub	r8,r6++
80006450:	00 00       	add	r0,r0
80006452:	0c 1c       	sub	r12,r6
80006454:	00 00       	add	r0,r0
80006456:	0c d0       	st.w	--r6,r0
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	57 86       	stdsp	sp[0x1e0],r6
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	57 36       	stdsp	sp[0x1cc],r6
80006460:	00 00       	add	r0,r0
80006462:	0c 00       	add	r0,r6
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	61 e0       	ld.w	r0,r0[0x78]
80006468:	00 00       	add	r0,r0
8000646a:	0d 20       	ld.uh	r0,r6++
8000646c:	80 00       	ld.sh	r0,r0[0x0]
8000646e:	59 4c       	cp.w	r12,20

80006470 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006470:	eb cd 40 80 	pushm	r7,lr
80006474:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006476:	49 08       	lddpc	r8,800064b4 <prvAddCurrentTaskToDelayedList+0x44>
80006478:	70 08       	ld.w	r8,r8[0x0]
8000647a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
8000647c:	48 f8       	lddpc	r8,800064b8 <prvAddCurrentTaskToDelayedList+0x48>
8000647e:	70 08       	ld.w	r8,r8[0x0]
80006480:	10 3c       	cp.w	r12,r8
80006482:	c0 a2       	brcc	80006496 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006484:	48 c8       	lddpc	r8,800064b4 <prvAddCurrentTaskToDelayedList+0x44>
80006486:	70 0b       	ld.w	r11,r8[0x0]
80006488:	48 d8       	lddpc	r8,800064bc <prvAddCurrentTaskToDelayedList+0x4c>
8000648a:	70 0c       	ld.w	r12,r8[0x0]
8000648c:	2f cb       	sub	r11,-4
8000648e:	f0 1f 00 0d 	mcall	800064c0 <prvAddCurrentTaskToDelayedList+0x50>
80006492:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006496:	48 88       	lddpc	r8,800064b4 <prvAddCurrentTaskToDelayedList+0x44>
80006498:	70 0b       	ld.w	r11,r8[0x0]
8000649a:	48 b8       	lddpc	r8,800064c4 <prvAddCurrentTaskToDelayedList+0x54>
8000649c:	70 0c       	ld.w	r12,r8[0x0]
8000649e:	2f cb       	sub	r11,-4
800064a0:	f0 1f 00 08 	mcall	800064c0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800064a4:	48 98       	lddpc	r8,800064c8 <prvAddCurrentTaskToDelayedList+0x58>
800064a6:	70 08       	ld.w	r8,r8[0x0]
800064a8:	10 37       	cp.w	r7,r8
800064aa:	c0 32       	brcc	800064b0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800064ac:	48 78       	lddpc	r8,800064c8 <prvAddCurrentTaskToDelayedList+0x58>
800064ae:	91 07       	st.w	r8[0x0],r7
800064b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800064b4:	00 00       	add	r0,r0
800064b6:	0c d0       	st.w	--r6,r0
800064b8:	00 00       	add	r0,r0
800064ba:	0c fc       	st.b	--r6,r12
800064bc:	00 00       	add	r0,r0
800064be:	0c 18       	sub	r8,r6
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	57 52       	stdsp	sp[0x1d4],r2
800064c4:	00 00       	add	r0,r0
800064c6:	0c 08       	add	r8,r6
800064c8:	00 00       	add	r0,r0
800064ca:	05 2c       	ld.uh	r12,r2++

800064cc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800064cc:	eb cd 40 c0 	pushm	r6-r7,lr
800064d0:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800064d2:	58 0c       	cp.w	r12,0
800064d4:	c1 10       	breq	800064f6 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800064d6:	f0 1f 00 0a 	mcall	800064fc <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800064da:	48 a8       	lddpc	r8,80006500 <vTaskDelay+0x34>
800064dc:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800064de:	48 a8       	lddpc	r8,80006504 <vTaskDelay+0x38>
800064e0:	70 0c       	ld.w	r12,r8[0x0]
800064e2:	2f cc       	sub	r12,-4
800064e4:	f0 1f 00 09 	mcall	80006508 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800064e8:	ee 06 00 0c 	add	r12,r7,r6
800064ec:	f0 1f 00 08 	mcall	8000650c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800064f0:	f0 1f 00 08 	mcall	80006510 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800064f4:	c0 21       	brne	800064f8 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800064f6:	d7 33       	scall
800064f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	5f cc       	srvs	r12
80006500:	00 00       	add	r0,r0
80006502:	0c fc       	st.b	--r6,r12
80006504:	00 00       	add	r0,r0
80006506:	0c d0       	st.w	--r6,r0
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	57 86       	stdsp	sp[0x1e0],r6
8000650c:	80 00       	ld.sh	r0,r0[0x0]
8000650e:	64 70       	ld.w	r0,r2[0x1c]
80006510:	80 00       	ld.sh	r0,r0[0x0]
80006512:	63 88       	ld.w	r8,r1[0x60]

80006514 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006514:	eb cd 40 c0 	pushm	r6-r7,lr
80006518:	18 96       	mov	r6,r12
8000651a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000651c:	f0 1f 00 18 	mcall	8000657c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006520:	6c 08       	ld.w	r8,r6[0x0]
80006522:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006524:	49 79       	lddpc	r9,80006580 <vTaskDelayUntil+0x6c>
80006526:	72 09       	ld.w	r9,r9[0x0]
80006528:	12 38       	cp.w	r8,r9
8000652a:	e0 88 00 0c 	brls	80006542 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000652e:	0e 38       	cp.w	r8,r7
80006530:	e0 88 00 22 	brls	80006574 <vTaskDelayUntil+0x60>
80006534:	49 38       	lddpc	r8,80006580 <vTaskDelayUntil+0x6c>
80006536:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006538:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000653a:	10 37       	cp.w	r7,r8
8000653c:	e0 88 00 14 	brls	80006564 <vTaskDelayUntil+0x50>
80006540:	c0 a8       	rjmp	80006554 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006542:	0e 38       	cp.w	r8,r7
80006544:	e0 8b 00 16 	brhi	80006570 <vTaskDelayUntil+0x5c>
80006548:	48 e8       	lddpc	r8,80006580 <vTaskDelayUntil+0x6c>
8000654a:	70 08       	ld.w	r8,r8[0x0]
8000654c:	10 37       	cp.w	r7,r8
8000654e:	e0 8b 00 11 	brhi	80006570 <vTaskDelayUntil+0x5c>
80006552:	c1 18       	rjmp	80006574 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006554:	48 c8       	lddpc	r8,80006584 <vTaskDelayUntil+0x70>
80006556:	70 0c       	ld.w	r12,r8[0x0]
80006558:	2f cc       	sub	r12,-4
8000655a:	f0 1f 00 0c 	mcall	80006588 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000655e:	0e 9c       	mov	r12,r7
80006560:	f0 1f 00 0b 	mcall	8000658c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006564:	f0 1f 00 0b 	mcall	80006590 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006568:	c0 81       	brne	80006578 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000656a:	d7 33       	scall
8000656c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006570:	8d 07       	st.w	r6[0x0],r7
80006572:	cf 1b       	rjmp	80006554 <vTaskDelayUntil+0x40>
80006574:	8d 07       	st.w	r6[0x0],r7
80006576:	cf 7b       	rjmp	80006564 <vTaskDelayUntil+0x50>
80006578:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	5f cc       	srvs	r12
80006580:	00 00       	add	r0,r0
80006582:	0c fc       	st.b	--r6,r12
80006584:	00 00       	add	r0,r0
80006586:	0c d0       	st.w	--r6,r0
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	57 86       	stdsp	sp[0x1e0],r6
8000658c:	80 00       	ld.sh	r0,r0[0x0]
8000658e:	64 70       	ld.w	r0,r2[0x1c]
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	63 88       	ld.w	r8,r1[0x60]

80006594 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006594:	eb cd 40 c0 	pushm	r6-r7,lr
80006598:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000659a:	48 e7       	lddpc	r7,800065d0 <vTaskPlaceOnEventList+0x3c>
8000659c:	6e 0b       	ld.w	r11,r7[0x0]
8000659e:	2e 8b       	sub	r11,-24
800065a0:	f0 1f 00 0d 	mcall	800065d4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800065a4:	6e 0c       	ld.w	r12,r7[0x0]
800065a6:	2f cc       	sub	r12,-4
800065a8:	f0 1f 00 0c 	mcall	800065d8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800065ac:	5b f6       	cp.w	r6,-1
800065ae:	c0 81       	brne	800065be <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800065b0:	6e 0b       	ld.w	r11,r7[0x0]
800065b2:	2f cb       	sub	r11,-4
800065b4:	48 ac       	lddpc	r12,800065dc <vTaskPlaceOnEventList+0x48>
800065b6:	f0 1f 00 0b 	mcall	800065e0 <vTaskPlaceOnEventList+0x4c>
800065ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800065be:	48 a8       	lddpc	r8,800065e4 <vTaskPlaceOnEventList+0x50>
800065c0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800065c2:	ec 0c 00 0c 	add	r12,r6,r12
800065c6:	f0 1f 00 09 	mcall	800065e8 <vTaskPlaceOnEventList+0x54>
800065ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065ce:	00 00       	add	r0,r0
800065d0:	00 00       	add	r0,r0
800065d2:	0c d0       	st.w	--r6,r0
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	57 52       	stdsp	sp[0x1d4],r2
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	57 86       	stdsp	sp[0x1e0],r6
800065dc:	00 00       	add	r0,r0
800065de:	0d 24       	ld.uh	r4,r6++
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	57 36       	stdsp	sp[0x1cc],r6
800065e4:	00 00       	add	r0,r0
800065e6:	0c fc       	st.b	--r6,r12
800065e8:	80 00       	ld.sh	r0,r0[0x0]
800065ea:	64 70       	ld.w	r0,r2[0x1c]

800065ec <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800065ec:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800065f0:	49 67       	lddpc	r7,80006648 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800065f2:	49 74       	lddpc	r4,8000664c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800065f4:	49 73       	lddpc	r3,80006650 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800065f6:	49 85       	lddpc	r5,80006654 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800065f8:	6e 08       	ld.w	r8,r7[0x0]
800065fa:	58 08       	cp.w	r8,0
800065fc:	c1 e0       	breq	80006638 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800065fe:	f0 1f 00 17 	mcall	80006658 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006602:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006604:	f0 1f 00 16 	mcall	8000665c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006608:	58 06       	cp.w	r6,0
8000660a:	c1 70       	breq	80006638 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000660c:	f0 1f 00 15 	mcall	80006660 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006610:	68 38       	ld.w	r8,r4[0xc]
80006612:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006614:	ec cc ff fc 	sub	r12,r6,-4
80006618:	f0 1f 00 13 	mcall	80006664 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
8000661c:	66 08       	ld.w	r8,r3[0x0]
8000661e:	20 18       	sub	r8,1
80006620:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006622:	6e 08       	ld.w	r8,r7[0x0]
80006624:	20 18       	sub	r8,1
80006626:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006628:	f0 1f 00 10 	mcall	80006668 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000662c:	6c cc       	ld.w	r12,r6[0x30]
8000662e:	f0 1f 00 10 	mcall	8000666c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006632:	0c 9c       	mov	r12,r6
80006634:	f0 1f 00 0e 	mcall	8000666c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006638:	6a 08       	ld.w	r8,r5[0x0]
8000663a:	58 18       	cp.w	r8,1
8000663c:	e0 88 00 03 	brls	80006642 <prvIdleTask+0x56>
			{
				taskYIELD();
80006640:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006642:	f0 1f 00 0c 	mcall	80006670 <prvIdleTask+0x84>
		}
		#endif
	}
80006646:	cd 9b       	rjmp	800065f8 <prvIdleTask+0xc>
80006648:	00 00       	add	r0,r0
8000664a:	0c 10       	sub	r0,r6
8000664c:	00 00       	add	r0,r0
8000664e:	0c bc       	st.h	r6++,r12
80006650:	00 00       	add	r0,r0
80006652:	0d 1c       	ld.sh	r12,r6++
80006654:	00 00       	add	r0,r0
80006656:	0c 1c       	sub	r12,r6
80006658:	80 00       	ld.sh	r0,r0[0x0]
8000665a:	5f cc       	srvs	r12
8000665c:	80 00       	ld.sh	r0,r0[0x0]
8000665e:	63 88       	ld.w	r8,r1[0x60]
80006660:	80 00       	ld.sh	r0,r0[0x0]
80006662:	58 40       	cp.w	r0,4
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	57 86       	stdsp	sp[0x1e0],r6
80006668:	80 00       	ld.sh	r0,r0[0x0]
8000666a:	59 4c       	cp.w	r12,20
8000666c:	80 00       	ld.sh	r0,r0[0x0]
8000666e:	5a 84       	cp.w	r4,-24
80006670:	80 00       	ld.sh	r0,r0[0x0]
80006672:	20 48       	sub	r8,4

80006674 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006674:	d4 31       	pushm	r0-r7,lr
80006676:	20 1d       	sub	sp,4
80006678:	fa c4 ff d8 	sub	r4,sp,-40
8000667c:	50 0c       	stdsp	sp[0x0],r12
8000667e:	16 91       	mov	r1,r11
80006680:	14 97       	mov	r7,r10
80006682:	12 90       	mov	r0,r9
80006684:	10 93       	mov	r3,r8
80006686:	68 02       	ld.w	r2,r4[0x0]
80006688:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000668a:	34 8c       	mov	r12,72
8000668c:	f0 1f 00 5c 	mcall	800067fc <xTaskGenericCreate+0x188>
80006690:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006692:	c0 31       	brne	80006698 <xTaskGenericCreate+0x24>
80006694:	3f fc       	mov	r12,-1
80006696:	ca f8       	rjmp	800067f4 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006698:	58 06       	cp.w	r6,0
8000669a:	e0 81 00 af 	brne	800067f8 <xTaskGenericCreate+0x184>
8000669e:	0e 9c       	mov	r12,r7
800066a0:	5c 7c       	castu.h	r12
800066a2:	a3 6c       	lsl	r12,0x2
800066a4:	f0 1f 00 56 	mcall	800067fc <xTaskGenericCreate+0x188>
800066a8:	18 96       	mov	r6,r12
800066aa:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800066ac:	c0 61       	brne	800066b8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800066ae:	0a 9c       	mov	r12,r5
800066b0:	f0 1f 00 54 	mcall	80006800 <xTaskGenericCreate+0x18c>
800066b4:	3f fc       	mov	r12,-1
800066b6:	c9 f8       	rjmp	800067f4 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800066b8:	5c 77       	castu.h	r7
800066ba:	ee 0a 15 02 	lsl	r10,r7,0x2
800066be:	e0 6b 00 a5 	mov	r11,165
800066c2:	0c 9c       	mov	r12,r6
800066c4:	f0 1f 00 50 	mcall	80006804 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800066c8:	ee c6 00 01 	sub	r6,r7,1
800066cc:	6a c8       	ld.w	r8,r5[0x30]
800066ce:	f0 06 00 26 	add	r6,r8,r6<<0x2
800066d2:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800066d6:	31 0a       	mov	r10,16
800066d8:	02 9b       	mov	r11,r1
800066da:	ea cc ff cc 	sub	r12,r5,-52
800066de:	f0 1f 00 4b 	mcall	80006808 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800066e2:	30 08       	mov	r8,0
800066e4:	eb 68 00 43 	st.b	r5[67],r8
800066e8:	58 73       	cp.w	r3,7
800066ea:	e6 07 17 80 	movls	r7,r3
800066ee:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800066f2:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800066f4:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800066f8:	ea c4 ff fc 	sub	r4,r5,-4
800066fc:	08 9c       	mov	r12,r4
800066fe:	f0 1f 00 44 	mcall	8000680c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006702:	ea cc ff e8 	sub	r12,r5,-24
80006706:	f0 1f 00 42 	mcall	8000680c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000670a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000670c:	ee 07 11 08 	rsub	r7,r7,8
80006710:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006712:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006714:	00 9a       	mov	r10,r0
80006716:	40 0b       	lddsp	r11,sp[0x0]
80006718:	0c 9c       	mov	r12,r6
8000671a:	f0 1f 00 3e 	mcall	80006810 <xTaskGenericCreate+0x19c>
8000671e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006720:	58 02       	cp.w	r2,0
80006722:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006726:	f0 1f 00 3c 	mcall	80006814 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000672a:	4b c8       	lddpc	r8,80006818 <xTaskGenericCreate+0x1a4>
8000672c:	70 09       	ld.w	r9,r8[0x0]
8000672e:	2f f9       	sub	r9,-1
80006730:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006732:	4b b8       	lddpc	r8,8000681c <xTaskGenericCreate+0x1a8>
80006734:	70 08       	ld.w	r8,r8[0x0]
80006736:	58 08       	cp.w	r8,0
80006738:	c2 61       	brne	80006784 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000673a:	4b 98       	lddpc	r8,8000681c <xTaskGenericCreate+0x1a8>
8000673c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000673e:	4b 78       	lddpc	r8,80006818 <xTaskGenericCreate+0x1a4>
80006740:	70 08       	ld.w	r8,r8[0x0]
80006742:	58 18       	cp.w	r8,1
80006744:	c2 b1       	brne	8000679a <xTaskGenericCreate+0x126>
80006746:	4b 77       	lddpc	r7,80006820 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006748:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000674c:	0e 9c       	mov	r12,r7
8000674e:	f0 1f 00 36 	mcall	80006824 <xTaskGenericCreate+0x1b0>
80006752:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006754:	0c 37       	cp.w	r7,r6
80006756:	cf b1       	brne	8000674c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006758:	4b 47       	lddpc	r7,80006828 <xTaskGenericCreate+0x1b4>
8000675a:	0e 9c       	mov	r12,r7
8000675c:	f0 1f 00 32 	mcall	80006824 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006760:	4b 36       	lddpc	r6,8000682c <xTaskGenericCreate+0x1b8>
80006762:	0c 9c       	mov	r12,r6
80006764:	f0 1f 00 30 	mcall	80006824 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006768:	4b 2c       	lddpc	r12,80006830 <xTaskGenericCreate+0x1bc>
8000676a:	f0 1f 00 2f 	mcall	80006824 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000676e:	4b 2c       	lddpc	r12,80006834 <xTaskGenericCreate+0x1c0>
80006770:	f0 1f 00 2d 	mcall	80006824 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006774:	4b 1c       	lddpc	r12,80006838 <xTaskGenericCreate+0x1c4>
80006776:	f0 1f 00 2c 	mcall	80006824 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000677a:	4b 18       	lddpc	r8,8000683c <xTaskGenericCreate+0x1c8>
8000677c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000677e:	4b 18       	lddpc	r8,80006840 <xTaskGenericCreate+0x1cc>
80006780:	91 06       	st.w	r8[0x0],r6
80006782:	c0 c8       	rjmp	8000679a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006784:	4b 08       	lddpc	r8,80006844 <xTaskGenericCreate+0x1d0>
80006786:	70 08       	ld.w	r8,r8[0x0]
80006788:	58 08       	cp.w	r8,0
8000678a:	c0 81       	brne	8000679a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000678c:	4a 48       	lddpc	r8,8000681c <xTaskGenericCreate+0x1a8>
8000678e:	70 08       	ld.w	r8,r8[0x0]
80006790:	70 b8       	ld.w	r8,r8[0x2c]
80006792:	10 33       	cp.w	r3,r8
80006794:	c0 33       	brcs	8000679a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006796:	4a 28       	lddpc	r8,8000681c <xTaskGenericCreate+0x1a8>
80006798:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000679a:	6a b8       	ld.w	r8,r5[0x2c]
8000679c:	4a b9       	lddpc	r9,80006848 <xTaskGenericCreate+0x1d4>
8000679e:	72 09       	ld.w	r9,r9[0x0]
800067a0:	12 38       	cp.w	r8,r9
800067a2:	e0 88 00 04 	brls	800067aa <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800067a6:	4a 99       	lddpc	r9,80006848 <xTaskGenericCreate+0x1d4>
800067a8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800067aa:	4a 98       	lddpc	r8,8000684c <xTaskGenericCreate+0x1d8>
800067ac:	70 09       	ld.w	r9,r8[0x0]
800067ae:	2f f9       	sub	r9,-1
800067b0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800067b2:	6a b8       	ld.w	r8,r5[0x2c]
800067b4:	4a 79       	lddpc	r9,80006850 <xTaskGenericCreate+0x1dc>
800067b6:	72 09       	ld.w	r9,r9[0x0]
800067b8:	12 38       	cp.w	r8,r9
800067ba:	e0 88 00 04 	brls	800067c2 <xTaskGenericCreate+0x14e>
800067be:	4a 59       	lddpc	r9,80006850 <xTaskGenericCreate+0x1dc>
800067c0:	93 08       	st.w	r9[0x0],r8
800067c2:	6a bc       	ld.w	r12,r5[0x2c]
800067c4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067c8:	08 9b       	mov	r11,r4
800067ca:	49 68       	lddpc	r8,80006820 <xTaskGenericCreate+0x1ac>
800067cc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067d0:	f0 1f 00 21 	mcall	80006854 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800067d4:	f0 1f 00 21 	mcall	80006858 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800067d8:	49 b8       	lddpc	r8,80006844 <xTaskGenericCreate+0x1d0>
800067da:	70 08       	ld.w	r8,r8[0x0]
800067dc:	58 08       	cp.w	r8,0
800067de:	c0 a0       	breq	800067f2 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800067e0:	48 f8       	lddpc	r8,8000681c <xTaskGenericCreate+0x1a8>
800067e2:	70 08       	ld.w	r8,r8[0x0]
800067e4:	70 b8       	ld.w	r8,r8[0x2c]
800067e6:	10 33       	cp.w	r3,r8
800067e8:	e0 88 00 05 	brls	800067f2 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800067ec:	d7 33       	scall
800067ee:	30 1c       	mov	r12,1
800067f0:	c0 28       	rjmp	800067f4 <xTaskGenericCreate+0x180>
800067f2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800067f4:	2f fd       	sub	sp,-4
800067f6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800067f8:	99 c6       	st.w	r12[0x30],r6
800067fa:	c5 fb       	rjmp	800066b8 <xTaskGenericCreate+0x44>
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	5a ac       	cp.w	r12,-22
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	5a 84       	cp.w	r4,-24
80006804:	80 00       	ld.sh	r0,r0[0x0]
80006806:	73 f4       	ld.w	r4,r9[0x7c]
80006808:	80 00       	ld.sh	r0,r0[0x0]
8000680a:	77 20       	ld.w	r0,r11[0x48]
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	57 30       	stdsp	sp[0x1cc],r0
80006810:	80 00       	ld.sh	r0,r0[0x0]
80006812:	57 ac       	stdsp	sp[0x1e8],r12
80006814:	80 00       	ld.sh	r0,r0[0x0]
80006816:	58 40       	cp.w	r0,4
80006818:	00 00       	add	r0,r0
8000681a:	0d 1c       	ld.sh	r12,r6++
8000681c:	00 00       	add	r0,r0
8000681e:	0c d0       	st.w	--r6,r0
80006820:	00 00       	add	r0,r0
80006822:	0c 1c       	sub	r12,r6
80006824:	80 00       	ld.sh	r0,r0[0x0]
80006826:	57 1c       	stdsp	sp[0x1c4],r12
80006828:	00 00       	add	r0,r0
8000682a:	0c e8       	st.h	--r6,r8
8000682c:	00 00       	add	r0,r0
8000682e:	0d 04       	ld.w	r4,r6++
80006830:	00 00       	add	r0,r0
80006832:	0c d4       	st.w	--r6,r4
80006834:	00 00       	add	r0,r0
80006836:	0c bc       	st.h	r6++,r12
80006838:	00 00       	add	r0,r0
8000683a:	0d 24       	ld.uh	r4,r6++
8000683c:	00 00       	add	r0,r0
8000683e:	0c 08       	add	r8,r6
80006840:	00 00       	add	r0,r0
80006842:	0c 18       	sub	r8,r6
80006844:	00 00       	add	r0,r0
80006846:	0c 0c       	add	r12,r6
80006848:	00 00       	add	r0,r0
8000684a:	0c 04       	add	r4,r6
8000684c:	00 00       	add	r0,r0
8000684e:	0d 18       	ld.sh	r8,r6++
80006850:	00 00       	add	r0,r0
80006852:	0d 38       	ld.ub	r8,r6++
80006854:	80 00       	ld.sh	r0,r0[0x0]
80006856:	57 36       	stdsp	sp[0x1cc],r6
80006858:	80 00       	ld.sh	r0,r0[0x0]
8000685a:	59 4c       	cp.w	r12,20

8000685c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000685c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000685e:	30 09       	mov	r9,0
80006860:	1a d9       	st.w	--sp,r9
80006862:	1a d9       	st.w	--sp,r9
80006864:	1a d9       	st.w	--sp,r9
80006866:	12 98       	mov	r8,r9
80006868:	e0 6a 01 00 	mov	r10,256
8000686c:	48 9b       	lddpc	r11,80006890 <vTaskStartScheduler+0x34>
8000686e:	48 ac       	lddpc	r12,80006894 <vTaskStartScheduler+0x38>
80006870:	f0 1f 00 0a 	mcall	80006898 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006874:	2f dd       	sub	sp,-12
80006876:	58 1c       	cp.w	r12,1
80006878:	c0 a1       	brne	8000688c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000687a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000687c:	30 19       	mov	r9,1
8000687e:	48 88       	lddpc	r8,8000689c <vTaskStartScheduler+0x40>
80006880:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006882:	30 09       	mov	r9,0
80006884:	48 78       	lddpc	r8,800068a0 <vTaskStartScheduler+0x44>
80006886:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006888:	f0 1f 00 07 	mcall	800068a4 <vTaskStartScheduler+0x48>
8000688c:	d8 02       	popm	pc
8000688e:	00 00       	add	r0,r0
80006890:	80 00       	ld.sh	r0,r0[0x0]
80006892:	d3 c8       	*unknown*
80006894:	80 00       	ld.sh	r0,r0[0x0]
80006896:	65 ec       	ld.w	r12,r2[0x78]
80006898:	80 00       	ld.sh	r0,r0[0x0]
8000689a:	66 74       	ld.w	r4,r3[0x1c]
8000689c:	00 00       	add	r0,r0
8000689e:	0c 0c       	add	r12,r6
800068a0:	00 00       	add	r0,r0
800068a2:	0c fc       	st.b	--r6,r12
800068a4:	80 00       	ld.sh	r0,r0[0x0]
800068a6:	58 50       	cp.w	r0,5

800068a8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800068a8:	16 cc       	st.b	r11++,r12
	return str;
}
800068aa:	5e fb       	retal	r11

800068ac <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800068ac:	eb cd 40 c0 	pushm	r6-r7,lr
800068b0:	20 3d       	sub	sp,12
800068b2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800068b4:	30 06       	mov	r6,0
800068b6:	30 07       	mov	r7,0
800068b8:	fa e7 00 00 	st.d	sp[0],r6
800068bc:	30 0c       	mov	r12,0
800068be:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800068c0:	58 08       	cp.w	r8,0
800068c2:	c1 30       	breq	800068e8 <PrintHex+0x3c>
800068c4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800068c6:	1a 9c       	mov	r12,sp
800068c8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800068cc:	58 9e       	cp.w	lr,9
800068ce:	e0 8a 00 04 	brle	800068d6 <PrintHex+0x2a>
800068d2:	2c 9e       	sub	lr,-55
800068d4:	c0 48       	rjmp	800068dc <PrintHex+0x30>
800068d6:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800068da:	2d 0e       	sub	lr,-48
800068dc:	f8 09 0b 0e 	st.b	r12[r9],lr
800068e0:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800068e2:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800068e4:	cf 21       	brne	800068c8 <PrintHex+0x1c>
800068e6:	c0 48       	rjmp	800068ee <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800068e8:	33 08       	mov	r8,48
800068ea:	ba 88       	st.b	sp[0x0],r8
800068ec:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800068ee:	f6 09 01 08 	sub	r8,r11,r9
800068f2:	58 08       	cp.w	r8,0
800068f4:	e0 8a 00 13 	brle	8000691a <PrintHex+0x6e>
	{
		char num = len - cnt;
800068f8:	12 1b       	sub	r11,r9
800068fa:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800068fe:	18 9e       	mov	lr,r12
80006900:	58 0c       	cp.w	r12,0
80006902:	e0 8a 00 0c 	brle	8000691a <PrintHex+0x6e>
80006906:	1a 9b       	mov	r11,sp
80006908:	12 0b       	add	r11,r9
8000690a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000690c:	33 07       	mov	r7,48
8000690e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006910:	2f f8       	sub	r8,-1
80006912:	1c 38       	cp.w	r8,lr
80006914:	cf d5       	brlt	8000690e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006916:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000691a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000691e:	f0 cb ff ff 	sub	r11,r8,-1
80006922:	58 0b       	cp.w	r11,0
80006924:	e0 8a 00 19 	brle	80006956 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006928:	fa cb ff f4 	sub	r11,sp,-12
8000692c:	f6 09 00 09 	add	r9,r11,r9
80006930:	37 8b       	mov	r11,120
80006932:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006936:	fa c9 ff f4 	sub	r9,sp,-12
8000693a:	10 09       	add	r9,r8
8000693c:	33 0b       	mov	r11,48
8000693e:	f3 6b ff f4 	st.b	r9[-12],r11
80006942:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006946:	fa ce 00 01 	sub	lr,sp,1
8000694a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
8000694c:	11 8b       	ld.ub	r11,r8[0x0]
8000694e:	12 cb       	st.b	r9++,r11
80006950:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006952:	1c 38       	cp.w	r8,lr
80006954:	cf c1       	brne	8000694c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006956:	14 9c       	mov	r12,r10
80006958:	2f dd       	sub	sp,-12
8000695a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000695e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000695e:	d4 21       	pushm	r4-r7,lr
80006960:	20 3d       	sub	sp,12
80006962:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006964:	30 06       	mov	r6,0
80006966:	30 07       	mov	r7,0
80006968:	fa e7 00 00 	st.d	sp[0],r6
8000696c:	30 0c       	mov	r12,0
8000696e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006970:	58 08       	cp.w	r8,0
80006972:	c0 35       	brlt	80006978 <PrintDec+0x1a>
80006974:	14 97       	mov	r7,r10
80006976:	c0 58       	rjmp	80006980 <PrintDec+0x22>
	{
		*p++ = '-';
80006978:	14 97       	mov	r7,r10
8000697a:	32 d9       	mov	r9,45
8000697c:	0e c9       	st.b	r7++,r9
		i = -i;
8000697e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006980:	58 08       	cp.w	r8,0
80006982:	c0 51       	brne	8000698c <PrintDec+0x2e>
80006984:	33 08       	mov	r8,48
80006986:	ba 88       	st.b	sp[0x0],r8
80006988:	30 1e       	mov	lr,1
8000698a:	c2 f8       	rjmp	800069e8 <PrintDec+0x8a>
	
	int ten = i%10;
8000698c:	e0 65 66 67 	mov	r5,26215
80006990:	ea 15 66 66 	orh	r5,0x6666
80006994:	f0 05 04 44 	muls.d	r4,r8,r5
80006998:	ea 0c 14 02 	asr	r12,r5,0x2
8000699c:	f0 09 14 1f 	asr	r9,r8,0x1f
800069a0:	f8 09 01 09 	sub	r9,r12,r9
800069a4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800069a8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800069ac:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800069ae:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800069b0:	e0 66 66 67 	mov	r6,26215
800069b4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800069b8:	2d 09       	sub	r9,-48
800069ba:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800069be:	2f fe       	sub	lr,-1
		i /= 10;
800069c0:	f0 06 04 44 	muls.d	r4,r8,r6
800069c4:	ea 09 14 02 	asr	r9,r5,0x2
800069c8:	bf 58       	asr	r8,0x1f
800069ca:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800069ce:	f0 06 04 44 	muls.d	r4,r8,r6
800069d2:	ea 09 14 02 	asr	r9,r5,0x2
800069d6:	f0 05 14 1f 	asr	r5,r8,0x1f
800069da:	0a 19       	sub	r9,r5
800069dc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800069e0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800069e4:	58 08       	cp.w	r8,0
800069e6:	ce 91       	brne	800069b8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800069e8:	f6 0e 01 08 	sub	r8,r11,lr
800069ec:	58 08       	cp.w	r8,0
800069ee:	e0 89 00 06 	brgt	800069fa <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800069f2:	58 0e       	cp.w	lr,0
800069f4:	e0 89 00 14 	brgt	80006a1c <PrintDec+0xbe>
800069f8:	c1 d8       	rjmp	80006a32 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800069fa:	1c 1b       	sub	r11,lr
800069fc:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800069fe:	16 9c       	mov	r12,r11
80006a00:	58 0b       	cp.w	r11,0
80006a02:	fe 9a ff f8 	brle	800069f2 <PrintDec+0x94>
80006a06:	1a 99       	mov	r9,sp
80006a08:	1c 09       	add	r9,lr
80006a0a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006a0c:	33 06       	mov	r6,48
80006a0e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006a10:	2f f8       	sub	r8,-1
80006a12:	18 38       	cp.w	r8,r12
80006a14:	cf d5       	brlt	80006a0e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006a16:	f6 0e 00 0e 	add	lr,r11,lr
80006a1a:	ce cb       	rjmp	800069f2 <PrintDec+0x94>
80006a1c:	fa c8 ff f4 	sub	r8,sp,-12
80006a20:	1c 08       	add	r8,lr
80006a22:	20 d8       	sub	r8,13
80006a24:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006a28:	11 89       	ld.ub	r9,r8[0x0]
80006a2a:	0e c9       	st.b	r7++,r9
80006a2c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006a2e:	16 38       	cp.w	r8,r11
80006a30:	cf c1       	brne	80006a28 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006a32:	14 9c       	mov	r12,r10
80006a34:	2f dd       	sub	sp,-12
80006a36:	d8 22       	popm	r4-r7,pc

80006a38 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006a38:	d4 31       	pushm	r0-r7,lr
80006a3a:	fa cd 02 08 	sub	sp,sp,520
80006a3e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006a40:	e0 6a 01 00 	mov	r10,256
80006a44:	30 0b       	mov	r11,0
80006a46:	fa cc fe f8 	sub	r12,sp,-264
80006a4a:	f0 1f 00 4e 	mcall	80006b80 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006a4e:	fa c4 fd d4 	sub	r4,sp,-556
80006a52:	30 0a       	mov	r10,0
80006a54:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006a56:	fa c3 ff fc 	sub	r3,sp,-4
80006a5a:	e0 61 01 00 	mov	r1,256
80006a5e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006a60:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006a62:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006a66:	02 9a       	mov	r10,r1
80006a68:	00 9b       	mov	r11,r0
80006a6a:	06 9c       	mov	r12,r3
80006a6c:	f0 1f 00 45 	mcall	80006b80 <log+0x148>
			
					if(*str == '%')
80006a70:	0f 88       	ld.ub	r8,r7[0x0]
80006a72:	e4 08 18 00 	cp.b	r8,r2
80006a76:	c5 71       	brne	80006b24 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006a78:	ee c8 ff ff 	sub	r8,r7,-1
80006a7c:	11 89       	ld.ub	r9,r8[0x0]
80006a7e:	4c 2a       	lddpc	r10,80006b84 <log+0x14c>
80006a80:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006a82:	23 09       	sub	r9,48
80006a84:	30 9a       	mov	r10,9
80006a86:	f4 09 18 00 	cp.b	r9,r10
80006a8a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006a8e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006a92:	f7 b9 08 30 	subls	r9,48
80006a96:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006a9a:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006a9e:	0f 88       	ld.ub	r8,r7[0x0]
80006aa0:	22 58       	sub	r8,37
80006aa2:	e0 48 00 53 	cp.w	r8,83
80006aa6:	e0 8b 00 31 	brhi	80006b08 <log+0xd0>
80006aaa:	4b 89       	lddpc	r9,80006b88 <log+0x150>
80006aac:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006ab0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006ab4:	06 9a       	mov	r10,r3
80006ab6:	40 0b       	lddsp	r11,sp[0x0]
80006ab8:	5c 5b       	castu.b	r11
80006aba:	68 0c       	ld.w	r12,r4[0x0]
80006abc:	f0 1f 00 34 	mcall	80006b8c <log+0x154>
							break;
80006ac0:	c2 98       	rjmp	80006b12 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006ac2:	4b 4c       	lddpc	r12,80006b90 <log+0x158>
80006ac4:	f0 1f 00 34 	mcall	80006b94 <log+0x15c>
80006ac8:	08 95       	mov	r5,r4
80006aca:	06 9c       	mov	r12,r3
							break;
80006acc:	c2 38       	rjmp	80006b12 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006ace:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006ad2:	06 9a       	mov	r10,r3
80006ad4:	40 0b       	lddsp	r11,sp[0x0]
80006ad6:	5c 5b       	castu.b	r11
80006ad8:	68 0c       	ld.w	r12,r4[0x0]
80006ada:	f0 1f 00 30 	mcall	80006b98 <log+0x160>
80006ade:	06 9c       	mov	r12,r3
							break;
80006ae0:	c1 98       	rjmp	80006b12 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006ae2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006ae6:	06 9b       	mov	r11,r3
80006ae8:	09 bc       	ld.ub	r12,r4[0x3]
80006aea:	f0 1f 00 2d 	mcall	80006b9c <log+0x164>
80006aee:	06 9c       	mov	r12,r3
							break;
80006af0:	c1 18       	rjmp	80006b12 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006af2:	e8 c5 ff fc 	sub	r5,r4,-4
80006af6:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006af8:	c0 d8       	rjmp	80006b12 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006afa:	06 9b       	mov	r11,r3
80006afc:	32 5c       	mov	r12,37
80006afe:	f0 1f 00 28 	mcall	80006b9c <log+0x164>
80006b02:	08 95       	mov	r5,r4
80006b04:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006b06:	c0 68       	rjmp	80006b12 <log+0xda>
							
							default:
							log("I need relax.");
80006b08:	4a 6c       	lddpc	r12,80006ba0 <log+0x168>
80006b0a:	f0 1f 00 23 	mcall	80006b94 <log+0x15c>
80006b0e:	08 95       	mov	r5,r4
80006b10:	06 9c       	mov	r12,r3
						}
						str++;
80006b12:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006b14:	1a dc       	st.w	--sp,r12
80006b16:	1a d6       	st.w	--sp,r6
80006b18:	4a 3b       	lddpc	r11,80006ba4 <log+0x16c>
80006b1a:	0c 9c       	mov	r12,r6
80006b1c:	f0 1f 00 23 	mcall	80006ba8 <log+0x170>
80006b20:	2f ed       	sub	sp,-8
80006b22:	c0 a8       	rjmp	80006b36 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006b24:	2f f7       	sub	r7,-1
80006b26:	1a d8       	st.w	--sp,r8
80006b28:	1a d6       	st.w	--sp,r6
80006b2a:	4a 1b       	lddpc	r11,80006bac <log+0x174>
80006b2c:	0c 9c       	mov	r12,r6
80006b2e:	f0 1f 00 1f 	mcall	80006ba8 <log+0x170>
80006b32:	08 95       	mov	r5,r4
80006b34:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006b36:	0f 89       	ld.ub	r9,r7[0x0]
80006b38:	30 08       	mov	r8,0
80006b3a:	f0 09 18 00 	cp.b	r9,r8
80006b3e:	c0 30       	breq	80006b44 <log+0x10c>
80006b40:	0a 94       	mov	r4,r5
80006b42:	c9 2b       	rjmp	80006a66 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006b44:	fa c7 fe f8 	sub	r7,sp,-264
80006b48:	1a d7       	st.w	--sp,r7
80006b4a:	49 ab       	lddpc	r11,80006bb0 <log+0x178>
80006b4c:	0e 9c       	mov	r12,r7
80006b4e:	f0 1f 00 17 	mcall	80006ba8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006b52:	5c 5c       	castu.b	r12
80006b54:	f8 c6 ff ff 	sub	r6,r12,-1
80006b58:	0c 9c       	mov	r12,r6
80006b5a:	f0 1f 00 17 	mcall	80006bb4 <log+0x17c>
80006b5e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006b60:	0c 9a       	mov	r10,r6
80006b62:	0e 9b       	mov	r11,r7
80006b64:	f0 1f 00 15 	mcall	80006bb8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006b68:	30 09       	mov	r9,0
80006b6a:	30 5a       	mov	r10,5
80006b6c:	fa cb fe f8 	sub	r11,sp,-264
80006b70:	49 38       	lddpc	r8,80006bbc <log+0x184>
80006b72:	70 0c       	ld.w	r12,r8[0x0]
80006b74:	f0 1f 00 13 	mcall	80006bc0 <log+0x188>
80006b78:	2f fd       	sub	sp,-4
	
	
}
80006b7a:	fe 3d fd f8 	sub	sp,-520
80006b7e:	d8 32       	popm	r0-r7,pc
80006b80:	80 00       	ld.sh	r0,r0[0x0]
80006b82:	73 f4       	ld.w	r4,r9[0x7c]
80006b84:	00 00       	add	r0,r0
80006b86:	0d 3c       	ld.ub	r12,r6++
80006b88:	80 00       	ld.sh	r0,r0[0x0]
80006b8a:	d3 d0       	acall	0x3d
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	69 5e       	ld.w	lr,r4[0x54]
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	d6 7c       	*unknown*
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	6a 38       	ld.w	r8,r5[0xc]
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	68 ac       	ld.w	r12,r4[0x28]
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	68 a8       	ld.w	r8,r4[0x28]
80006ba0:	80 00       	ld.sh	r0,r0[0x0]
80006ba2:	d6 8c       	*unknown*
80006ba4:	80 00       	ld.sh	r0,r0[0x0]
80006ba6:	d6 9c       	*unknown*
80006ba8:	80 00       	ld.sh	r0,r0[0x0]
80006baa:	76 e4       	ld.w	r4,r11[0x38]
80006bac:	80 00       	ld.sh	r0,r0[0x0]
80006bae:	d6 a4       	*unknown*
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	d6 ac       	*unknown*
80006bb4:	80 00       	ld.sh	r0,r0[0x0]
80006bb6:	5a ac       	cp.w	r12,-22
80006bb8:	80 00       	ld.sh	r0,r0[0x0]
80006bba:	72 ac       	ld.w	r12,r9[0x28]
80006bbc:	00 00       	add	r0,r0
80006bbe:	b6 70       	st.h	r11[0xe],r0
80006bc0:	80 00       	ld.sh	r0,r0[0x0]
80006bc2:	5e 00       	reteq	r0

80006bc4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006bc4:	d4 31       	pushm	r0-r7,lr
80006bc6:	fa cd 02 0c 	sub	sp,sp,524
80006bca:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006bcc:	e0 6a 01 00 	mov	r10,256
80006bd0:	30 0b       	mov	r11,0
80006bd2:	fa cc fe f4 	sub	r12,sp,-268
80006bd6:	f0 1f 00 4c 	mcall	80006d04 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006bda:	fa c4 fd d0 	sub	r4,sp,-560
80006bde:	30 0a       	mov	r10,0
80006be0:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006be2:	fa c3 ff fc 	sub	r3,sp,-4
80006be6:	e0 61 01 00 	mov	r1,256
80006bea:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006bec:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006bee:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006bf2:	02 9a       	mov	r10,r1
80006bf4:	00 9b       	mov	r11,r0
80006bf6:	06 9c       	mov	r12,r3
80006bf8:	f0 1f 00 43 	mcall	80006d04 <logFromISR+0x140>
			
			if(*str == '%')
80006bfc:	0f 88       	ld.ub	r8,r7[0x0]
80006bfe:	e4 08 18 00 	cp.b	r8,r2
80006c02:	c5 11       	brne	80006ca4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006c04:	ee c8 ff ff 	sub	r8,r7,-1
80006c08:	11 89       	ld.ub	r9,r8[0x0]
80006c0a:	4c 0a       	lddpc	r10,80006d08 <logFromISR+0x144>
80006c0c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006c0e:	23 09       	sub	r9,48
80006c10:	30 9a       	mov	r10,9
80006c12:	f4 09 18 00 	cp.b	r9,r10
80006c16:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006c1a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006c1e:	f7 b9 08 30 	subls	r9,48
80006c22:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006c26:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006c2a:	0f 88       	ld.ub	r8,r7[0x0]
80006c2c:	22 58       	sub	r8,37
80006c2e:	e0 48 00 53 	cp.w	r8,83
80006c32:	e0 8b 00 2b 	brhi	80006c88 <logFromISR+0xc4>
80006c36:	4b 69       	lddpc	r9,80006d0c <logFromISR+0x148>
80006c38:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006c3c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006c40:	06 9a       	mov	r10,r3
80006c42:	40 0b       	lddsp	r11,sp[0x0]
80006c44:	5c 5b       	castu.b	r11
80006c46:	68 0c       	ld.w	r12,r4[0x0]
80006c48:	f0 1f 00 32 	mcall	80006d10 <logFromISR+0x14c>
					break;
80006c4c:	c2 38       	rjmp	80006c92 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006c4e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006c52:	06 9a       	mov	r10,r3
80006c54:	40 0b       	lddsp	r11,sp[0x0]
80006c56:	5c 5b       	castu.b	r11
80006c58:	68 0c       	ld.w	r12,r4[0x0]
80006c5a:	f0 1f 00 2f 	mcall	80006d14 <logFromISR+0x150>
80006c5e:	06 9c       	mov	r12,r3
					break;
80006c60:	c1 98       	rjmp	80006c92 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006c62:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006c66:	06 9b       	mov	r11,r3
80006c68:	09 bc       	ld.ub	r12,r4[0x3]
80006c6a:	f0 1f 00 2c 	mcall	80006d18 <logFromISR+0x154>
80006c6e:	06 9c       	mov	r12,r3
					break;
80006c70:	c1 18       	rjmp	80006c92 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006c72:	e8 c5 ff fc 	sub	r5,r4,-4
80006c76:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006c78:	c0 d8       	rjmp	80006c92 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006c7a:	06 9b       	mov	r11,r3
80006c7c:	32 5c       	mov	r12,37
80006c7e:	f0 1f 00 27 	mcall	80006d18 <logFromISR+0x154>
80006c82:	08 95       	mov	r5,r4
80006c84:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006c86:	c0 68       	rjmp	80006c92 <logFromISR+0xce>
					default:
					log("I need relax.");
80006c88:	4a 5c       	lddpc	r12,80006d1c <logFromISR+0x158>
80006c8a:	f0 1f 00 26 	mcall	80006d20 <logFromISR+0x15c>
80006c8e:	08 95       	mov	r5,r4
80006c90:	06 9c       	mov	r12,r3
				}
				str++;
80006c92:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006c94:	1a dc       	st.w	--sp,r12
80006c96:	1a d6       	st.w	--sp,r6
80006c98:	4a 3b       	lddpc	r11,80006d24 <logFromISR+0x160>
80006c9a:	0c 9c       	mov	r12,r6
80006c9c:	f0 1f 00 23 	mcall	80006d28 <logFromISR+0x164>
80006ca0:	2f ed       	sub	sp,-8
80006ca2:	c0 a8       	rjmp	80006cb6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006ca4:	2f f7       	sub	r7,-1
80006ca6:	1a d8       	st.w	--sp,r8
80006ca8:	1a d6       	st.w	--sp,r6
80006caa:	4a 1b       	lddpc	r11,80006d2c <logFromISR+0x168>
80006cac:	0c 9c       	mov	r12,r6
80006cae:	f0 1f 00 1f 	mcall	80006d28 <logFromISR+0x164>
80006cb2:	08 95       	mov	r5,r4
80006cb4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006cb6:	0f 89       	ld.ub	r9,r7[0x0]
80006cb8:	30 08       	mov	r8,0
80006cba:	f0 09 18 00 	cp.b	r9,r8
80006cbe:	c0 30       	breq	80006cc4 <logFromISR+0x100>
80006cc0:	0a 94       	mov	r4,r5
80006cc2:	c9 8b       	rjmp	80006bf2 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006cc4:	fa c7 fe f4 	sub	r7,sp,-268
80006cc8:	1a d7       	st.w	--sp,r7
80006cca:	49 ab       	lddpc	r11,80006d30 <logFromISR+0x16c>
80006ccc:	0e 9c       	mov	r12,r7
80006cce:	f0 1f 00 17 	mcall	80006d28 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006cd2:	5c 5c       	castu.b	r12
80006cd4:	f8 c6 ff ff 	sub	r6,r12,-1
80006cd8:	0c 9c       	mov	r12,r6
80006cda:	f0 1f 00 17 	mcall	80006d34 <logFromISR+0x170>
80006cde:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006ce0:	0c 9a       	mov	r10,r6
80006ce2:	0e 9b       	mov	r11,r7
80006ce4:	f0 1f 00 15 	mcall	80006d38 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006ce8:	30 09       	mov	r9,0
80006cea:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006cec:	fa ca fe f8 	sub	r10,sp,-264
80006cf0:	fa cb fe f4 	sub	r11,sp,-268
80006cf4:	49 28       	lddpc	r8,80006d3c <logFromISR+0x178>
80006cf6:	70 0c       	ld.w	r12,r8[0x0]
80006cf8:	f0 1f 00 12 	mcall	80006d40 <logFromISR+0x17c>
80006cfc:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006cfe:	fe 3d fd f4 	sub	sp,-524
80006d02:	d8 32       	popm	r0-r7,pc
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	73 f4       	ld.w	r4,r9[0x7c]
80006d08:	00 00       	add	r0,r0
80006d0a:	0d 3d       	ld.ub	sp,r6++
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	d5 20       	acall	0x52
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	69 5e       	ld.w	lr,r4[0x54]
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	68 ac       	ld.w	r12,r4[0x28]
80006d18:	80 00       	ld.sh	r0,r0[0x0]
80006d1a:	68 a8       	ld.w	r8,r4[0x28]
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	d6 8c       	*unknown*
80006d20:	80 00       	ld.sh	r0,r0[0x0]
80006d22:	6a 38       	ld.w	r8,r5[0xc]
80006d24:	80 00       	ld.sh	r0,r0[0x0]
80006d26:	d6 9c       	*unknown*
80006d28:	80 00       	ld.sh	r0,r0[0x0]
80006d2a:	76 e4       	ld.w	r4,r11[0x38]
80006d2c:	80 00       	ld.sh	r0,r0[0x0]
80006d2e:	d6 a4       	*unknown*
80006d30:	80 00       	ld.sh	r0,r0[0x0]
80006d32:	d6 ac       	*unknown*
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	5a ac       	cp.w	r12,-22
80006d38:	80 00       	ld.sh	r0,r0[0x0]
80006d3a:	72 ac       	ld.w	r12,r9[0x28]
80006d3c:	00 00       	add	r0,r0
80006d3e:	b6 70       	st.h	r11[0xe],r0
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	5d b0       	*unknown*

80006d44 <log_init>:
		
	return str;
}

void log_init(void)
{
80006d44:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006d46:	30 2b       	mov	r11,2
80006d48:	48 fc       	lddpc	r12,80006d84 <log_init+0x40>
80006d4a:	f0 1f 00 10 	mcall	80006d88 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006d4e:	e0 6a 36 00 	mov	r10,13824
80006d52:	ea 1a 01 6e 	orh	r10,0x16e
80006d56:	48 eb       	lddpc	r11,80006d8c <log_init+0x48>
80006d58:	fe 7c 18 00 	mov	r12,-59392
80006d5c:	f0 1f 00 0d 	mcall	80006d90 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006d60:	30 4b       	mov	r11,4
80006d62:	33 2c       	mov	r12,50
80006d64:	f0 1f 00 0c 	mcall	80006d94 <log_init+0x50>
80006d68:	48 c8       	lddpc	r8,80006d98 <log_init+0x54>
80006d6a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006d6c:	30 09       	mov	r9,0
80006d6e:	1a d9       	st.w	--sp,r9
80006d70:	1a d9       	st.w	--sp,r9
80006d72:	1a d9       	st.w	--sp,r9
80006d74:	30 28       	mov	r8,2
80006d76:	36 4a       	mov	r10,100
80006d78:	48 9b       	lddpc	r11,80006d9c <log_init+0x58>
80006d7a:	48 ac       	lddpc	r12,80006da0 <log_init+0x5c>
80006d7c:	f0 1f 00 0a 	mcall	80006da4 <log_init+0x60>
80006d80:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006d82:	d8 02       	popm	pc
80006d84:	80 00       	ld.sh	r0,r0[0x0]
80006d86:	d6 b8       	*unknown*
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	51 18       	stdsp	sp[0x44],r8
80006d8c:	80 00       	ld.sh	r0,r0[0x0]
80006d8e:	d6 70       	acall	0x67
80006d90:	80 00       	ld.sh	r0,r0[0x0]
80006d92:	56 10       	stdsp	sp[0x184],r0
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	5f 58       	srlt	r8
80006d98:	00 00       	add	r0,r0
80006d9a:	b6 70       	st.h	r11[0xe],r0
80006d9c:	80 00       	ld.sh	r0,r0[0x0]
80006d9e:	d6 b4       	*unknown*
80006da0:	80 00       	ld.sh	r0,r0[0x0]
80006da2:	6d a8       	ld.w	r8,r6[0x68]
80006da4:	80 00       	ld.sh	r0,r0[0x0]
80006da6:	66 74       	ld.w	r4,r3[0x1c]

80006da8 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80006da8:	eb cd 40 f8 	pushm	r3-r7,lr
80006dac:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006dae:	48 c7       	lddpc	r7,80006ddc <task_log+0x34>
80006db0:	30 05       	mov	r5,0
80006db2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006db4:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006db8:	0a 99       	mov	r9,r5
80006dba:	08 9a       	mov	r10,r4
80006dbc:	1a 9b       	mov	r11,sp
80006dbe:	6e 0c       	ld.w	r12,r7[0x0]
80006dc0:	f0 1f 00 08 	mcall	80006de0 <task_log+0x38>
80006dc4:	58 1c       	cp.w	r12,1
80006dc6:	cf 91       	brne	80006db8 <task_log+0x10>
		{
			if( NULL != str)
80006dc8:	40 0b       	lddsp	r11,sp[0x0]
80006dca:	58 0b       	cp.w	r11,0
80006dcc:	cf 60       	breq	80006db8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006dce:	06 9c       	mov	r12,r3
80006dd0:	f0 1f 00 05 	mcall	80006de4 <task_log+0x3c>
				vPortFree(str);
80006dd4:	40 0c       	lddsp	r12,sp[0x0]
80006dd6:	f0 1f 00 05 	mcall	80006de8 <task_log+0x40>
80006dda:	ce fb       	rjmp	80006db8 <task_log+0x10>
80006ddc:	00 00       	add	r0,r0
80006dde:	b6 70       	st.h	r11[0xe],r0
80006de0:	80 00       	ld.sh	r0,r0[0x0]
80006de2:	5b f4       	cp.w	r4,-1
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	55 c0       	stdsp	sp[0x170],r0
80006de8:	80 00       	ld.sh	r0,r0[0x0]
80006dea:	5a 84       	cp.w	r4,-24

80006dec <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80006dec:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006dee:	fe 78 10 00 	mov	r8,-61440
80006df2:	30 19       	mov	r9,1
80006df4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006df8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006dfc:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006e00:	d3 03       	ssrf	0x10
	local_start_pll0();
80006e02:	f0 1f 00 0b 	mcall	80006e2c <main+0x40>
		
	INTC_init_interrupts();
80006e06:	f0 1f 00 0b 	mcall	80006e30 <main+0x44>
		
	log_init();
80006e0a:	f0 1f 00 0b 	mcall	80006e34 <main+0x48>
	log("----start debug----");
80006e0e:	48 bc       	lddpc	r12,80006e38 <main+0x4c>
80006e10:	f0 1f 00 0b 	mcall	80006e3c <main+0x50>
	
	xg_flashc_init();
80006e14:	f0 1f 00 0b 	mcall	80006e40 <main+0x54>
	
	//rfid_init();
		
	app_init();
80006e18:	f0 1f 00 0b 	mcall	80006e44 <main+0x58>
		
	xcmp_init();
80006e1c:	f0 1f 00 0b 	mcall	80006e48 <main+0x5c>

	local_start_timer();
80006e20:	f0 1f 00 0b 	mcall	80006e4c <main+0x60>
		
	vTaskStartScheduler();
80006e24:	f0 1f 00 0b 	mcall	80006e50 <main+0x64>
	return 0;
	
}
80006e28:	d8 0a       	popm	pc,r12=0
80006e2a:	00 00       	add	r0,r0
80006e2c:	80 00       	ld.sh	r0,r0[0x0]
80006e2e:	4f 94       	lddpc	r4,80007010 <_malloc_r+0x19c>
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	52 04       	stdsp	sp[0x80],r4
80006e34:	80 00       	ld.sh	r0,r0[0x0]
80006e36:	6d 44       	ld.w	r4,r6[0x50]
80006e38:	80 00       	ld.sh	r0,r0[0x0]
80006e3a:	d6 c8       	*unknown*
80006e3c:	80 00       	ld.sh	r0,r0[0x0]
80006e3e:	6a 38       	ld.w	r8,r5[0xc]
80006e40:	80 00       	ld.sh	r0,r0[0x0]
80006e42:	50 28       	stdsp	sp[0x8],r8
80006e44:	80 00       	ld.sh	r0,r0[0x0]
80006e46:	27 44       	sub	r4,116
80006e48:	80 00       	ld.sh	r0,r0[0x0]
80006e4a:	3f ac       	mov	r12,-6
80006e4c:	80 00       	ld.sh	r0,r0[0x0]
80006e4e:	4f 68       	lddpc	r8,80007024 <_malloc_r+0x1b0>
80006e50:	80 00       	ld.sh	r0,r0[0x0]
80006e52:	68 5c       	ld.w	r12,r4[0x14]

80006e54 <free>:
80006e54:	d4 01       	pushm	lr
80006e56:	e0 68 0a 30 	mov	r8,2608
80006e5a:	18 9b       	mov	r11,r12
80006e5c:	70 0c       	ld.w	r12,r8[0x0]
80006e5e:	e0 a0 1e 61 	rcall	8000ab20 <_free_r>
80006e62:	d8 02       	popm	pc

80006e64 <malloc>:
80006e64:	d4 01       	pushm	lr
80006e66:	e0 68 0a 30 	mov	r8,2608
80006e6a:	18 9b       	mov	r11,r12
80006e6c:	70 0c       	ld.w	r12,r8[0x0]
80006e6e:	c0 3c       	rcall	80006e74 <_malloc_r>
80006e70:	d8 02       	popm	pc
80006e72:	d7 03       	nop

80006e74 <_malloc_r>:
80006e74:	d4 31       	pushm	r0-r7,lr
80006e76:	f6 c8 ff f5 	sub	r8,r11,-11
80006e7a:	18 95       	mov	r5,r12
80006e7c:	10 97       	mov	r7,r8
80006e7e:	e0 17 ff f8 	andl	r7,0xfff8
80006e82:	59 68       	cp.w	r8,22
80006e84:	f9 b7 08 10 	movls	r7,16
80006e88:	16 37       	cp.w	r7,r11
80006e8a:	5f 38       	srlo	r8
80006e8c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006e90:	c0 50       	breq	80006e9a <_malloc_r+0x26>
80006e92:	30 c8       	mov	r8,12
80006e94:	99 38       	st.w	r12[0xc],r8
80006e96:	e0 8f 01 fa 	bral	8000728a <_malloc_r+0x416>
80006e9a:	fe b0 f5 ab 	rcall	800059f0 <__malloc_lock>
80006e9e:	e0 47 01 f7 	cp.w	r7,503
80006ea2:	e0 8b 00 1d 	brhi	80006edc <_malloc_r+0x68>
80006ea6:	ee 03 16 03 	lsr	r3,r7,0x3
80006eaa:	e0 68 05 30 	mov	r8,1328
80006eae:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006eb2:	70 36       	ld.w	r6,r8[0xc]
80006eb4:	10 36       	cp.w	r6,r8
80006eb6:	c0 61       	brne	80006ec2 <_malloc_r+0x4e>
80006eb8:	ec c8 ff f8 	sub	r8,r6,-8
80006ebc:	70 36       	ld.w	r6,r8[0xc]
80006ebe:	10 36       	cp.w	r6,r8
80006ec0:	c0 c0       	breq	80006ed8 <_malloc_r+0x64>
80006ec2:	6c 18       	ld.w	r8,r6[0x4]
80006ec4:	e0 18 ff fc 	andl	r8,0xfffc
80006ec8:	6c 3a       	ld.w	r10,r6[0xc]
80006eca:	ec 08 00 09 	add	r9,r6,r8
80006ece:	0a 9c       	mov	r12,r5
80006ed0:	6c 28       	ld.w	r8,r6[0x8]
80006ed2:	95 28       	st.w	r10[0x8],r8
80006ed4:	91 3a       	st.w	r8[0xc],r10
80006ed6:	c4 78       	rjmp	80006f64 <_malloc_r+0xf0>
80006ed8:	2f e3       	sub	r3,-2
80006eda:	c4 d8       	rjmp	80006f74 <_malloc_r+0x100>
80006edc:	ee 03 16 09 	lsr	r3,r7,0x9
80006ee0:	c0 41       	brne	80006ee8 <_malloc_r+0x74>
80006ee2:	ee 03 16 03 	lsr	r3,r7,0x3
80006ee6:	c2 68       	rjmp	80006f32 <_malloc_r+0xbe>
80006ee8:	58 43       	cp.w	r3,4
80006eea:	e0 8b 00 06 	brhi	80006ef6 <_malloc_r+0x82>
80006eee:	ee 03 16 06 	lsr	r3,r7,0x6
80006ef2:	2c 83       	sub	r3,-56
80006ef4:	c1 f8       	rjmp	80006f32 <_malloc_r+0xbe>
80006ef6:	59 43       	cp.w	r3,20
80006ef8:	e0 8b 00 04 	brhi	80006f00 <_malloc_r+0x8c>
80006efc:	2a 53       	sub	r3,-91
80006efe:	c1 a8       	rjmp	80006f32 <_malloc_r+0xbe>
80006f00:	e0 43 00 54 	cp.w	r3,84
80006f04:	e0 8b 00 06 	brhi	80006f10 <_malloc_r+0x9c>
80006f08:	ee 03 16 0c 	lsr	r3,r7,0xc
80006f0c:	29 23       	sub	r3,-110
80006f0e:	c1 28       	rjmp	80006f32 <_malloc_r+0xbe>
80006f10:	e0 43 01 54 	cp.w	r3,340
80006f14:	e0 8b 00 06 	brhi	80006f20 <_malloc_r+0xac>
80006f18:	ee 03 16 0f 	lsr	r3,r7,0xf
80006f1c:	28 93       	sub	r3,-119
80006f1e:	c0 a8       	rjmp	80006f32 <_malloc_r+0xbe>
80006f20:	e0 43 05 54 	cp.w	r3,1364
80006f24:	e0 88 00 04 	brls	80006f2c <_malloc_r+0xb8>
80006f28:	37 e3       	mov	r3,126
80006f2a:	c0 48       	rjmp	80006f32 <_malloc_r+0xbe>
80006f2c:	ee 03 16 12 	lsr	r3,r7,0x12
80006f30:	28 43       	sub	r3,-124
80006f32:	e0 6a 05 30 	mov	r10,1328
80006f36:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006f3a:	74 36       	ld.w	r6,r10[0xc]
80006f3c:	c1 98       	rjmp	80006f6e <_malloc_r+0xfa>
80006f3e:	6c 19       	ld.w	r9,r6[0x4]
80006f40:	e0 19 ff fc 	andl	r9,0xfffc
80006f44:	f2 07 01 0b 	sub	r11,r9,r7
80006f48:	58 fb       	cp.w	r11,15
80006f4a:	e0 8a 00 04 	brle	80006f52 <_malloc_r+0xde>
80006f4e:	20 13       	sub	r3,1
80006f50:	c1 18       	rjmp	80006f72 <_malloc_r+0xfe>
80006f52:	6c 38       	ld.w	r8,r6[0xc]
80006f54:	58 0b       	cp.w	r11,0
80006f56:	c0 b5       	brlt	80006f6c <_malloc_r+0xf8>
80006f58:	6c 2a       	ld.w	r10,r6[0x8]
80006f5a:	ec 09 00 09 	add	r9,r6,r9
80006f5e:	0a 9c       	mov	r12,r5
80006f60:	91 2a       	st.w	r8[0x8],r10
80006f62:	95 38       	st.w	r10[0xc],r8
80006f64:	72 18       	ld.w	r8,r9[0x4]
80006f66:	a1 a8       	sbr	r8,0x0
80006f68:	93 18       	st.w	r9[0x4],r8
80006f6a:	cb c8       	rjmp	800070e2 <_malloc_r+0x26e>
80006f6c:	10 96       	mov	r6,r8
80006f6e:	14 36       	cp.w	r6,r10
80006f70:	ce 71       	brne	80006f3e <_malloc_r+0xca>
80006f72:	2f f3       	sub	r3,-1
80006f74:	e0 6a 05 30 	mov	r10,1328
80006f78:	f4 cc ff f8 	sub	r12,r10,-8
80006f7c:	78 26       	ld.w	r6,r12[0x8]
80006f7e:	18 36       	cp.w	r6,r12
80006f80:	c6 c0       	breq	80007058 <_malloc_r+0x1e4>
80006f82:	6c 19       	ld.w	r9,r6[0x4]
80006f84:	e0 19 ff fc 	andl	r9,0xfffc
80006f88:	f2 07 01 08 	sub	r8,r9,r7
80006f8c:	58 f8       	cp.w	r8,15
80006f8e:	e0 89 00 8f 	brgt	800070ac <_malloc_r+0x238>
80006f92:	99 3c       	st.w	r12[0xc],r12
80006f94:	99 2c       	st.w	r12[0x8],r12
80006f96:	58 08       	cp.w	r8,0
80006f98:	c0 55       	brlt	80006fa2 <_malloc_r+0x12e>
80006f9a:	ec 09 00 09 	add	r9,r6,r9
80006f9e:	0a 9c       	mov	r12,r5
80006fa0:	ce 2b       	rjmp	80006f64 <_malloc_r+0xf0>
80006fa2:	e0 49 01 ff 	cp.w	r9,511
80006fa6:	e0 8b 00 13 	brhi	80006fcc <_malloc_r+0x158>
80006faa:	a3 99       	lsr	r9,0x3
80006fac:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006fb0:	70 2b       	ld.w	r11,r8[0x8]
80006fb2:	8d 38       	st.w	r6[0xc],r8
80006fb4:	8d 2b       	st.w	r6[0x8],r11
80006fb6:	97 36       	st.w	r11[0xc],r6
80006fb8:	91 26       	st.w	r8[0x8],r6
80006fba:	a3 49       	asr	r9,0x2
80006fbc:	74 18       	ld.w	r8,r10[0x4]
80006fbe:	30 1b       	mov	r11,1
80006fc0:	f6 09 09 49 	lsl	r9,r11,r9
80006fc4:	f1 e9 10 09 	or	r9,r8,r9
80006fc8:	95 19       	st.w	r10[0x4],r9
80006fca:	c4 78       	rjmp	80007058 <_malloc_r+0x1e4>
80006fcc:	f2 0a 16 09 	lsr	r10,r9,0x9
80006fd0:	58 4a       	cp.w	r10,4
80006fd2:	e0 8b 00 07 	brhi	80006fe0 <_malloc_r+0x16c>
80006fd6:	f2 0a 16 06 	lsr	r10,r9,0x6
80006fda:	2c 8a       	sub	r10,-56
80006fdc:	c2 08       	rjmp	8000701c <_malloc_r+0x1a8>
80006fde:	d7 03       	nop
80006fe0:	59 4a       	cp.w	r10,20
80006fe2:	e0 8b 00 04 	brhi	80006fea <_malloc_r+0x176>
80006fe6:	2a 5a       	sub	r10,-91
80006fe8:	c1 a8       	rjmp	8000701c <_malloc_r+0x1a8>
80006fea:	e0 4a 00 54 	cp.w	r10,84
80006fee:	e0 8b 00 06 	brhi	80006ffa <_malloc_r+0x186>
80006ff2:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006ff6:	29 2a       	sub	r10,-110
80006ff8:	c1 28       	rjmp	8000701c <_malloc_r+0x1a8>
80006ffa:	e0 4a 01 54 	cp.w	r10,340
80006ffe:	e0 8b 00 06 	brhi	8000700a <_malloc_r+0x196>
80007002:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007006:	28 9a       	sub	r10,-119
80007008:	c0 a8       	rjmp	8000701c <_malloc_r+0x1a8>
8000700a:	e0 4a 05 54 	cp.w	r10,1364
8000700e:	e0 88 00 04 	brls	80007016 <_malloc_r+0x1a2>
80007012:	37 ea       	mov	r10,126
80007014:	c0 48       	rjmp	8000701c <_malloc_r+0x1a8>
80007016:	f2 0a 16 12 	lsr	r10,r9,0x12
8000701a:	28 4a       	sub	r10,-124
8000701c:	e0 6b 05 30 	mov	r11,1328
80007020:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007024:	68 28       	ld.w	r8,r4[0x8]
80007026:	08 38       	cp.w	r8,r4
80007028:	c0 e1       	brne	80007044 <_malloc_r+0x1d0>
8000702a:	76 19       	ld.w	r9,r11[0x4]
8000702c:	a3 4a       	asr	r10,0x2
8000702e:	30 1e       	mov	lr,1
80007030:	fc 0a 09 4a 	lsl	r10,lr,r10
80007034:	f3 ea 10 0a 	or	r10,r9,r10
80007038:	10 99       	mov	r9,r8
8000703a:	97 1a       	st.w	r11[0x4],r10
8000703c:	c0 a8       	rjmp	80007050 <_malloc_r+0x1dc>
8000703e:	70 28       	ld.w	r8,r8[0x8]
80007040:	08 38       	cp.w	r8,r4
80007042:	c0 60       	breq	8000704e <_malloc_r+0x1da>
80007044:	70 1a       	ld.w	r10,r8[0x4]
80007046:	e0 1a ff fc 	andl	r10,0xfffc
8000704a:	14 39       	cp.w	r9,r10
8000704c:	cf 93       	brcs	8000703e <_malloc_r+0x1ca>
8000704e:	70 39       	ld.w	r9,r8[0xc]
80007050:	8d 39       	st.w	r6[0xc],r9
80007052:	8d 28       	st.w	r6[0x8],r8
80007054:	91 36       	st.w	r8[0xc],r6
80007056:	93 26       	st.w	r9[0x8],r6
80007058:	e6 08 14 02 	asr	r8,r3,0x2
8000705c:	30 1b       	mov	r11,1
8000705e:	e0 64 05 30 	mov	r4,1328
80007062:	f6 08 09 4b 	lsl	r11,r11,r8
80007066:	68 18       	ld.w	r8,r4[0x4]
80007068:	10 3b       	cp.w	r11,r8
8000706a:	e0 8b 00 6b 	brhi	80007140 <_malloc_r+0x2cc>
8000706e:	f7 e8 00 09 	and	r9,r11,r8
80007072:	c0 b1       	brne	80007088 <_malloc_r+0x214>
80007074:	e0 13 ff fc 	andl	r3,0xfffc
80007078:	a1 7b       	lsl	r11,0x1
8000707a:	2f c3       	sub	r3,-4
8000707c:	c0 38       	rjmp	80007082 <_malloc_r+0x20e>
8000707e:	2f c3       	sub	r3,-4
80007080:	a1 7b       	lsl	r11,0x1
80007082:	f7 e8 00 09 	and	r9,r11,r8
80007086:	cf c0       	breq	8000707e <_malloc_r+0x20a>
80007088:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000708c:	06 92       	mov	r2,r3
8000708e:	1c 91       	mov	r1,lr
80007090:	62 36       	ld.w	r6,r1[0xc]
80007092:	c2 e8       	rjmp	800070ee <_malloc_r+0x27a>
80007094:	6c 1a       	ld.w	r10,r6[0x4]
80007096:	e0 1a ff fc 	andl	r10,0xfffc
8000709a:	f4 07 01 08 	sub	r8,r10,r7
8000709e:	58 f8       	cp.w	r8,15
800070a0:	e0 8a 00 15 	brle	800070ca <_malloc_r+0x256>
800070a4:	6c 3a       	ld.w	r10,r6[0xc]
800070a6:	6c 29       	ld.w	r9,r6[0x8]
800070a8:	95 29       	st.w	r10[0x8],r9
800070aa:	93 3a       	st.w	r9[0xc],r10
800070ac:	0e 99       	mov	r9,r7
800070ae:	ec 07 00 07 	add	r7,r6,r7
800070b2:	a1 a9       	sbr	r9,0x0
800070b4:	99 37       	st.w	r12[0xc],r7
800070b6:	99 27       	st.w	r12[0x8],r7
800070b8:	8d 19       	st.w	r6[0x4],r9
800070ba:	ee 08 09 08 	st.w	r7[r8],r8
800070be:	8f 2c       	st.w	r7[0x8],r12
800070c0:	8f 3c       	st.w	r7[0xc],r12
800070c2:	a1 a8       	sbr	r8,0x0
800070c4:	0a 9c       	mov	r12,r5
800070c6:	8f 18       	st.w	r7[0x4],r8
800070c8:	c0 d8       	rjmp	800070e2 <_malloc_r+0x26e>
800070ca:	6c 39       	ld.w	r9,r6[0xc]
800070cc:	58 08       	cp.w	r8,0
800070ce:	c0 f5       	brlt	800070ec <_malloc_r+0x278>
800070d0:	ec 0a 00 0a 	add	r10,r6,r10
800070d4:	74 18       	ld.w	r8,r10[0x4]
800070d6:	a1 a8       	sbr	r8,0x0
800070d8:	0a 9c       	mov	r12,r5
800070da:	95 18       	st.w	r10[0x4],r8
800070dc:	6c 28       	ld.w	r8,r6[0x8]
800070de:	93 28       	st.w	r9[0x8],r8
800070e0:	91 39       	st.w	r8[0xc],r9
800070e2:	fe b0 f4 8d 	rcall	800059fc <__malloc_unlock>
800070e6:	ec cc ff f8 	sub	r12,r6,-8
800070ea:	d8 32       	popm	r0-r7,pc
800070ec:	12 96       	mov	r6,r9
800070ee:	02 36       	cp.w	r6,r1
800070f0:	cd 21       	brne	80007094 <_malloc_r+0x220>
800070f2:	2f f2       	sub	r2,-1
800070f4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800070f8:	c0 30       	breq	800070fe <_malloc_r+0x28a>
800070fa:	2f 81       	sub	r1,-8
800070fc:	cc ab       	rjmp	80007090 <_malloc_r+0x21c>
800070fe:	1c 98       	mov	r8,lr
80007100:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007104:	c0 81       	brne	80007114 <_malloc_r+0x2a0>
80007106:	68 19       	ld.w	r9,r4[0x4]
80007108:	f6 08 11 ff 	rsub	r8,r11,-1
8000710c:	f3 e8 00 08 	and	r8,r9,r8
80007110:	89 18       	st.w	r4[0x4],r8
80007112:	c0 78       	rjmp	80007120 <_malloc_r+0x2ac>
80007114:	f0 c9 00 08 	sub	r9,r8,8
80007118:	20 13       	sub	r3,1
8000711a:	70 08       	ld.w	r8,r8[0x0]
8000711c:	12 38       	cp.w	r8,r9
8000711e:	cf 10       	breq	80007100 <_malloc_r+0x28c>
80007120:	a1 7b       	lsl	r11,0x1
80007122:	68 18       	ld.w	r8,r4[0x4]
80007124:	10 3b       	cp.w	r11,r8
80007126:	e0 8b 00 0d 	brhi	80007140 <_malloc_r+0x2cc>
8000712a:	58 0b       	cp.w	r11,0
8000712c:	c0 a0       	breq	80007140 <_malloc_r+0x2cc>
8000712e:	04 93       	mov	r3,r2
80007130:	c0 38       	rjmp	80007136 <_malloc_r+0x2c2>
80007132:	2f c3       	sub	r3,-4
80007134:	a1 7b       	lsl	r11,0x1
80007136:	f7 e8 00 09 	and	r9,r11,r8
8000713a:	ca 71       	brne	80007088 <_malloc_r+0x214>
8000713c:	cf bb       	rjmp	80007132 <_malloc_r+0x2be>
8000713e:	d7 03       	nop
80007140:	68 23       	ld.w	r3,r4[0x8]
80007142:	66 12       	ld.w	r2,r3[0x4]
80007144:	e0 12 ff fc 	andl	r2,0xfffc
80007148:	0e 32       	cp.w	r2,r7
8000714a:	5f 39       	srlo	r9
8000714c:	e4 07 01 08 	sub	r8,r2,r7
80007150:	58 f8       	cp.w	r8,15
80007152:	5f aa       	srle	r10
80007154:	f5 e9 10 09 	or	r9,r10,r9
80007158:	e0 80 00 9a 	breq	8000728c <_malloc_r+0x418>
8000715c:	e0 68 0d 48 	mov	r8,3400
80007160:	70 01       	ld.w	r1,r8[0x0]
80007162:	e0 68 09 3c 	mov	r8,2364
80007166:	2f 01       	sub	r1,-16
80007168:	70 08       	ld.w	r8,r8[0x0]
8000716a:	0e 01       	add	r1,r7
8000716c:	5b f8       	cp.w	r8,-1
8000716e:	c0 40       	breq	80007176 <_malloc_r+0x302>
80007170:	28 11       	sub	r1,-127
80007172:	e0 11 ff 80 	andl	r1,0xff80
80007176:	02 9b       	mov	r11,r1
80007178:	0a 9c       	mov	r12,r5
8000717a:	e0 a0 02 a5 	rcall	800076c4 <_sbrk_r>
8000717e:	18 96       	mov	r6,r12
80007180:	5b fc       	cp.w	r12,-1
80007182:	c7 50       	breq	8000726c <_malloc_r+0x3f8>
80007184:	e6 02 00 08 	add	r8,r3,r2
80007188:	10 3c       	cp.w	r12,r8
8000718a:	c0 32       	brcc	80007190 <_malloc_r+0x31c>
8000718c:	08 33       	cp.w	r3,r4
8000718e:	c6 f1       	brne	8000726c <_malloc_r+0x3f8>
80007190:	e0 6a 0d 4c 	mov	r10,3404
80007194:	74 09       	ld.w	r9,r10[0x0]
80007196:	e2 09 00 09 	add	r9,r1,r9
8000719a:	95 09       	st.w	r10[0x0],r9
8000719c:	10 36       	cp.w	r6,r8
8000719e:	c0 a1       	brne	800071b2 <_malloc_r+0x33e>
800071a0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800071a4:	c0 71       	brne	800071b2 <_malloc_r+0x33e>
800071a6:	e2 02 00 02 	add	r2,r1,r2
800071aa:	68 28       	ld.w	r8,r4[0x8]
800071ac:	a1 a2       	sbr	r2,0x0
800071ae:	91 12       	st.w	r8[0x4],r2
800071b0:	c4 f8       	rjmp	8000724e <_malloc_r+0x3da>
800071b2:	e0 6a 09 3c 	mov	r10,2364
800071b6:	74 0b       	ld.w	r11,r10[0x0]
800071b8:	5b fb       	cp.w	r11,-1
800071ba:	c0 31       	brne	800071c0 <_malloc_r+0x34c>
800071bc:	95 06       	st.w	r10[0x0],r6
800071be:	c0 78       	rjmp	800071cc <_malloc_r+0x358>
800071c0:	ec 09 00 09 	add	r9,r6,r9
800071c4:	e0 6a 0d 4c 	mov	r10,3404
800071c8:	10 19       	sub	r9,r8
800071ca:	95 09       	st.w	r10[0x0],r9
800071cc:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800071d0:	f0 09 11 08 	rsub	r9,r8,8
800071d4:	58 08       	cp.w	r8,0
800071d6:	f2 08 17 10 	movne	r8,r9
800071da:	ed d8 e1 06 	addne	r6,r6,r8
800071de:	28 08       	sub	r8,-128
800071e0:	ec 01 00 01 	add	r1,r6,r1
800071e4:	0a 9c       	mov	r12,r5
800071e6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800071ea:	f0 01 01 01 	sub	r1,r8,r1
800071ee:	02 9b       	mov	r11,r1
800071f0:	e0 a0 02 6a 	rcall	800076c4 <_sbrk_r>
800071f4:	e0 68 0d 4c 	mov	r8,3404
800071f8:	5b fc       	cp.w	r12,-1
800071fa:	ec 0c 17 00 	moveq	r12,r6
800071fe:	f9 b1 00 00 	moveq	r1,0
80007202:	70 09       	ld.w	r9,r8[0x0]
80007204:	0c 1c       	sub	r12,r6
80007206:	89 26       	st.w	r4[0x8],r6
80007208:	02 0c       	add	r12,r1
8000720a:	12 01       	add	r1,r9
8000720c:	a1 ac       	sbr	r12,0x0
8000720e:	91 01       	st.w	r8[0x0],r1
80007210:	8d 1c       	st.w	r6[0x4],r12
80007212:	08 33       	cp.w	r3,r4
80007214:	c1 d0       	breq	8000724e <_malloc_r+0x3da>
80007216:	58 f2       	cp.w	r2,15
80007218:	e0 8b 00 05 	brhi	80007222 <_malloc_r+0x3ae>
8000721c:	30 18       	mov	r8,1
8000721e:	8d 18       	st.w	r6[0x4],r8
80007220:	c2 68       	rjmp	8000726c <_malloc_r+0x3f8>
80007222:	30 59       	mov	r9,5
80007224:	20 c2       	sub	r2,12
80007226:	e0 12 ff f8 	andl	r2,0xfff8
8000722a:	e6 02 00 08 	add	r8,r3,r2
8000722e:	91 29       	st.w	r8[0x8],r9
80007230:	91 19       	st.w	r8[0x4],r9
80007232:	66 18       	ld.w	r8,r3[0x4]
80007234:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007238:	e5 e8 10 08 	or	r8,r2,r8
8000723c:	87 18       	st.w	r3[0x4],r8
8000723e:	58 f2       	cp.w	r2,15
80007240:	e0 88 00 07 	brls	8000724e <_malloc_r+0x3da>
80007244:	e6 cb ff f8 	sub	r11,r3,-8
80007248:	0a 9c       	mov	r12,r5
8000724a:	e0 a0 1c 6b 	rcall	8000ab20 <_free_r>
8000724e:	e0 69 0d 44 	mov	r9,3396
80007252:	72 0a       	ld.w	r10,r9[0x0]
80007254:	e0 68 0d 4c 	mov	r8,3404
80007258:	70 08       	ld.w	r8,r8[0x0]
8000725a:	14 38       	cp.w	r8,r10
8000725c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007260:	e0 69 0d 40 	mov	r9,3392
80007264:	72 0a       	ld.w	r10,r9[0x0]
80007266:	14 38       	cp.w	r8,r10
80007268:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000726c:	68 28       	ld.w	r8,r4[0x8]
8000726e:	70 18       	ld.w	r8,r8[0x4]
80007270:	e0 18 ff fc 	andl	r8,0xfffc
80007274:	0e 38       	cp.w	r8,r7
80007276:	5f 39       	srlo	r9
80007278:	0e 18       	sub	r8,r7
8000727a:	58 f8       	cp.w	r8,15
8000727c:	5f aa       	srle	r10
8000727e:	f5 e9 10 09 	or	r9,r10,r9
80007282:	c0 50       	breq	8000728c <_malloc_r+0x418>
80007284:	0a 9c       	mov	r12,r5
80007286:	fe b0 f3 bb 	rcall	800059fc <__malloc_unlock>
8000728a:	d8 3a       	popm	r0-r7,pc,r12=0
8000728c:	68 26       	ld.w	r6,r4[0x8]
8000728e:	a1 a8       	sbr	r8,0x0
80007290:	0e 99       	mov	r9,r7
80007292:	a1 a9       	sbr	r9,0x0
80007294:	8d 19       	st.w	r6[0x4],r9
80007296:	ec 07 00 07 	add	r7,r6,r7
8000729a:	0a 9c       	mov	r12,r5
8000729c:	89 27       	st.w	r4[0x8],r7
8000729e:	8f 18       	st.w	r7[0x4],r8
800072a0:	fe b0 f3 ae 	rcall	800059fc <__malloc_unlock>
800072a4:	ec cc ff f8 	sub	r12,r6,-8
800072a8:	d8 32       	popm	r0-r7,pc
800072aa:	d7 03       	nop

800072ac <memcpy>:
800072ac:	58 8a       	cp.w	r10,8
800072ae:	c2 f5       	brlt	8000730c <memcpy+0x60>
800072b0:	f9 eb 10 09 	or	r9,r12,r11
800072b4:	e2 19 00 03 	andl	r9,0x3,COH
800072b8:	e0 81 00 97 	brne	800073e6 <memcpy+0x13a>
800072bc:	e0 4a 00 20 	cp.w	r10,32
800072c0:	c3 b4       	brge	80007336 <memcpy+0x8a>
800072c2:	f4 08 14 02 	asr	r8,r10,0x2
800072c6:	f0 09 11 08 	rsub	r9,r8,8
800072ca:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800072ce:	76 69       	ld.w	r9,r11[0x18]
800072d0:	99 69       	st.w	r12[0x18],r9
800072d2:	76 59       	ld.w	r9,r11[0x14]
800072d4:	99 59       	st.w	r12[0x14],r9
800072d6:	76 49       	ld.w	r9,r11[0x10]
800072d8:	99 49       	st.w	r12[0x10],r9
800072da:	76 39       	ld.w	r9,r11[0xc]
800072dc:	99 39       	st.w	r12[0xc],r9
800072de:	76 29       	ld.w	r9,r11[0x8]
800072e0:	99 29       	st.w	r12[0x8],r9
800072e2:	76 19       	ld.w	r9,r11[0x4]
800072e4:	99 19       	st.w	r12[0x4],r9
800072e6:	76 09       	ld.w	r9,r11[0x0]
800072e8:	99 09       	st.w	r12[0x0],r9
800072ea:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800072ee:	f8 08 00 28 	add	r8,r12,r8<<0x2
800072f2:	e0 1a 00 03 	andl	r10,0x3
800072f6:	f4 0a 11 04 	rsub	r10,r10,4
800072fa:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800072fe:	17 a9       	ld.ub	r9,r11[0x2]
80007300:	b0 a9       	st.b	r8[0x2],r9
80007302:	17 99       	ld.ub	r9,r11[0x1]
80007304:	b0 99       	st.b	r8[0x1],r9
80007306:	17 89       	ld.ub	r9,r11[0x0]
80007308:	b0 89       	st.b	r8[0x0],r9
8000730a:	5e fc       	retal	r12
8000730c:	f4 0a 11 09 	rsub	r10,r10,9
80007310:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007314:	17 f9       	ld.ub	r9,r11[0x7]
80007316:	b8 f9       	st.b	r12[0x7],r9
80007318:	17 e9       	ld.ub	r9,r11[0x6]
8000731a:	b8 e9       	st.b	r12[0x6],r9
8000731c:	17 d9       	ld.ub	r9,r11[0x5]
8000731e:	b8 d9       	st.b	r12[0x5],r9
80007320:	17 c9       	ld.ub	r9,r11[0x4]
80007322:	b8 c9       	st.b	r12[0x4],r9
80007324:	17 b9       	ld.ub	r9,r11[0x3]
80007326:	b8 b9       	st.b	r12[0x3],r9
80007328:	17 a9       	ld.ub	r9,r11[0x2]
8000732a:	b8 a9       	st.b	r12[0x2],r9
8000732c:	17 99       	ld.ub	r9,r11[0x1]
8000732e:	b8 99       	st.b	r12[0x1],r9
80007330:	17 89       	ld.ub	r9,r11[0x0]
80007332:	b8 89       	st.b	r12[0x0],r9
80007334:	5e fc       	retal	r12
80007336:	eb cd 40 c0 	pushm	r6-r7,lr
8000733a:	18 99       	mov	r9,r12
8000733c:	22 0a       	sub	r10,32
8000733e:	b7 07       	ld.d	r6,r11++
80007340:	b3 26       	st.d	r9++,r6
80007342:	b7 07       	ld.d	r6,r11++
80007344:	b3 26       	st.d	r9++,r6
80007346:	b7 07       	ld.d	r6,r11++
80007348:	b3 26       	st.d	r9++,r6
8000734a:	b7 07       	ld.d	r6,r11++
8000734c:	b3 26       	st.d	r9++,r6
8000734e:	22 0a       	sub	r10,32
80007350:	cf 74       	brge	8000733e <memcpy+0x92>
80007352:	2f 0a       	sub	r10,-16
80007354:	c0 65       	brlt	80007360 <memcpy+0xb4>
80007356:	b7 07       	ld.d	r6,r11++
80007358:	b3 26       	st.d	r9++,r6
8000735a:	b7 07       	ld.d	r6,r11++
8000735c:	b3 26       	st.d	r9++,r6
8000735e:	21 0a       	sub	r10,16
80007360:	5c 3a       	neg	r10
80007362:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007366:	d7 03       	nop
80007368:	d7 03       	nop
8000736a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000736e:	f3 66 00 0e 	st.b	r9[14],r6
80007372:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007376:	f3 66 00 0d 	st.b	r9[13],r6
8000737a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000737e:	f3 66 00 0c 	st.b	r9[12],r6
80007382:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007386:	f3 66 00 0b 	st.b	r9[11],r6
8000738a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000738e:	f3 66 00 0a 	st.b	r9[10],r6
80007392:	f7 36 00 09 	ld.ub	r6,r11[9]
80007396:	f3 66 00 09 	st.b	r9[9],r6
8000739a:	f7 36 00 08 	ld.ub	r6,r11[8]
8000739e:	f3 66 00 08 	st.b	r9[8],r6
800073a2:	f7 36 00 07 	ld.ub	r6,r11[7]
800073a6:	f3 66 00 07 	st.b	r9[7],r6
800073aa:	f7 36 00 06 	ld.ub	r6,r11[6]
800073ae:	f3 66 00 06 	st.b	r9[6],r6
800073b2:	f7 36 00 05 	ld.ub	r6,r11[5]
800073b6:	f3 66 00 05 	st.b	r9[5],r6
800073ba:	f7 36 00 04 	ld.ub	r6,r11[4]
800073be:	f3 66 00 04 	st.b	r9[4],r6
800073c2:	f7 36 00 03 	ld.ub	r6,r11[3]
800073c6:	f3 66 00 03 	st.b	r9[3],r6
800073ca:	f7 36 00 02 	ld.ub	r6,r11[2]
800073ce:	f3 66 00 02 	st.b	r9[2],r6
800073d2:	f7 36 00 01 	ld.ub	r6,r11[1]
800073d6:	f3 66 00 01 	st.b	r9[1],r6
800073da:	f7 36 00 00 	ld.ub	r6,r11[0]
800073de:	f3 66 00 00 	st.b	r9[0],r6
800073e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800073e6:	20 1a       	sub	r10,1
800073e8:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800073ec:	f8 0a 0b 09 	st.b	r12[r10],r9
800073f0:	cf b1       	brne	800073e6 <memcpy+0x13a>
800073f2:	5e fc       	retal	r12

800073f4 <memset>:
800073f4:	18 98       	mov	r8,r12
800073f6:	c0 38       	rjmp	800073fc <memset+0x8>
800073f8:	10 cb       	st.b	r8++,r11
800073fa:	20 1a       	sub	r10,1
800073fc:	58 0a       	cp.w	r10,0
800073fe:	cf d1       	brne	800073f8 <memset+0x4>
80007400:	5e fc       	retal	r12
80007402:	d7 03       	nop

80007404 <_realloc_r>:
80007404:	d4 31       	pushm	r0-r7,lr
80007406:	20 1d       	sub	sp,4
80007408:	16 94       	mov	r4,r11
8000740a:	18 92       	mov	r2,r12
8000740c:	14 9b       	mov	r11,r10
8000740e:	58 04       	cp.w	r4,0
80007410:	c0 51       	brne	8000741a <_realloc_r+0x16>
80007412:	fe b0 fd 31 	rcall	80006e74 <_malloc_r>
80007416:	18 95       	mov	r5,r12
80007418:	c5 39       	rjmp	800076be <_realloc_r+0x2ba>
8000741a:	50 0a       	stdsp	sp[0x0],r10
8000741c:	fe b0 f2 ea 	rcall	800059f0 <__malloc_lock>
80007420:	40 0b       	lddsp	r11,sp[0x0]
80007422:	f6 c8 ff f5 	sub	r8,r11,-11
80007426:	e8 c1 00 08 	sub	r1,r4,8
8000742a:	10 96       	mov	r6,r8
8000742c:	62 1c       	ld.w	r12,r1[0x4]
8000742e:	e0 16 ff f8 	andl	r6,0xfff8
80007432:	59 68       	cp.w	r8,22
80007434:	f9 b6 08 10 	movls	r6,16
80007438:	16 36       	cp.w	r6,r11
8000743a:	5f 38       	srlo	r8
8000743c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007440:	c0 50       	breq	8000744a <_realloc_r+0x46>
80007442:	30 c8       	mov	r8,12
80007444:	30 05       	mov	r5,0
80007446:	85 38       	st.w	r2[0xc],r8
80007448:	c3 b9       	rjmp	800076be <_realloc_r+0x2ba>
8000744a:	18 90       	mov	r0,r12
8000744c:	e0 10 ff fc 	andl	r0,0xfffc
80007450:	0c 30       	cp.w	r0,r6
80007452:	e0 84 01 0b 	brge	80007668 <_realloc_r+0x264>
80007456:	e0 68 05 30 	mov	r8,1328
8000745a:	e2 00 00 09 	add	r9,r1,r0
8000745e:	70 25       	ld.w	r5,r8[0x8]
80007460:	0a 39       	cp.w	r9,r5
80007462:	c0 90       	breq	80007474 <_realloc_r+0x70>
80007464:	72 1a       	ld.w	r10,r9[0x4]
80007466:	a1 ca       	cbr	r10,0x0
80007468:	f2 0a 00 0a 	add	r10,r9,r10
8000746c:	74 1a       	ld.w	r10,r10[0x4]
8000746e:	ed ba 00 00 	bld	r10,0x0
80007472:	c2 20       	breq	800074b6 <_realloc_r+0xb2>
80007474:	72 1a       	ld.w	r10,r9[0x4]
80007476:	e0 1a ff fc 	andl	r10,0xfffc
8000747a:	f4 00 00 03 	add	r3,r10,r0
8000747e:	0a 39       	cp.w	r9,r5
80007480:	c1 31       	brne	800074a6 <_realloc_r+0xa2>
80007482:	ec c7 ff f0 	sub	r7,r6,-16
80007486:	0e 33       	cp.w	r3,r7
80007488:	c1 95       	brlt	800074ba <_realloc_r+0xb6>
8000748a:	e2 06 00 09 	add	r9,r1,r6
8000748e:	0c 13       	sub	r3,r6
80007490:	a1 a3       	sbr	r3,0x0
80007492:	93 13       	st.w	r9[0x4],r3
80007494:	91 29       	st.w	r8[0x8],r9
80007496:	04 9c       	mov	r12,r2
80007498:	62 18       	ld.w	r8,r1[0x4]
8000749a:	08 95       	mov	r5,r4
8000749c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800074a0:	10 46       	or	r6,r8
800074a2:	83 16       	st.w	r1[0x4],r6
800074a4:	c0 b9       	rjmp	800076ba <_realloc_r+0x2b6>
800074a6:	0c 33       	cp.w	r3,r6
800074a8:	c0 95       	brlt	800074ba <_realloc_r+0xb6>
800074aa:	72 28       	ld.w	r8,r9[0x8]
800074ac:	02 97       	mov	r7,r1
800074ae:	72 39       	ld.w	r9,r9[0xc]
800074b0:	93 28       	st.w	r9[0x8],r8
800074b2:	91 39       	st.w	r8[0xc],r9
800074b4:	cd c8       	rjmp	8000766c <_realloc_r+0x268>
800074b6:	30 0a       	mov	r10,0
800074b8:	14 99       	mov	r9,r10
800074ba:	ed bc 00 00 	bld	r12,0x0
800074be:	e0 80 00 95 	breq	800075e8 <_realloc_r+0x1e4>
800074c2:	62 07       	ld.w	r7,r1[0x0]
800074c4:	e2 07 01 07 	sub	r7,r1,r7
800074c8:	6e 1c       	ld.w	r12,r7[0x4]
800074ca:	e0 1c ff fc 	andl	r12,0xfffc
800074ce:	58 09       	cp.w	r9,0
800074d0:	c5 60       	breq	8000757c <_realloc_r+0x178>
800074d2:	f8 00 00 03 	add	r3,r12,r0
800074d6:	0a 39       	cp.w	r9,r5
800074d8:	c4 81       	brne	80007568 <_realloc_r+0x164>
800074da:	14 03       	add	r3,r10
800074dc:	ec c9 ff f0 	sub	r9,r6,-16
800074e0:	12 33       	cp.w	r3,r9
800074e2:	c4 d5       	brlt	8000757c <_realloc_r+0x178>
800074e4:	6e 3a       	ld.w	r10,r7[0xc]
800074e6:	6e 29       	ld.w	r9,r7[0x8]
800074e8:	95 29       	st.w	r10[0x8],r9
800074ea:	93 3a       	st.w	r9[0xc],r10
800074ec:	ee c5 ff f8 	sub	r5,r7,-8
800074f0:	e0 ca 00 04 	sub	r10,r0,4
800074f4:	e0 4a 00 24 	cp.w	r10,36
800074f8:	e0 8b 00 25 	brhi	80007542 <_realloc_r+0x13e>
800074fc:	0a 99       	mov	r9,r5
800074fe:	59 3a       	cp.w	r10,19
80007500:	e0 88 00 1a 	brls	80007534 <_realloc_r+0x130>
80007504:	09 09       	ld.w	r9,r4++
80007506:	8b 09       	st.w	r5[0x0],r9
80007508:	09 09       	ld.w	r9,r4++
8000750a:	8f 39       	st.w	r7[0xc],r9
8000750c:	ee c9 ff f0 	sub	r9,r7,-16
80007510:	59 ba       	cp.w	r10,27
80007512:	e0 88 00 11 	brls	80007534 <_realloc_r+0x130>
80007516:	09 0b       	ld.w	r11,r4++
80007518:	93 0b       	st.w	r9[0x0],r11
8000751a:	09 09       	ld.w	r9,r4++
8000751c:	8f 59       	st.w	r7[0x14],r9
8000751e:	ee c9 ff e8 	sub	r9,r7,-24
80007522:	e0 4a 00 24 	cp.w	r10,36
80007526:	c0 71       	brne	80007534 <_realloc_r+0x130>
80007528:	09 0a       	ld.w	r10,r4++
8000752a:	93 0a       	st.w	r9[0x0],r10
8000752c:	ee c9 ff e0 	sub	r9,r7,-32
80007530:	09 0a       	ld.w	r10,r4++
80007532:	8f 7a       	st.w	r7[0x1c],r10
80007534:	09 0a       	ld.w	r10,r4++
80007536:	12 aa       	st.w	r9++,r10
80007538:	68 0a       	ld.w	r10,r4[0x0]
8000753a:	93 0a       	st.w	r9[0x0],r10
8000753c:	68 1a       	ld.w	r10,r4[0x4]
8000753e:	93 1a       	st.w	r9[0x4],r10
80007540:	c0 78       	rjmp	8000754e <_realloc_r+0x14a>
80007542:	50 08       	stdsp	sp[0x0],r8
80007544:	08 9b       	mov	r11,r4
80007546:	0a 9c       	mov	r12,r5
80007548:	e0 a0 1d 8f 	rcall	8000b066 <memmove>
8000754c:	40 08       	lddsp	r8,sp[0x0]
8000754e:	ee 06 00 09 	add	r9,r7,r6
80007552:	0c 13       	sub	r3,r6
80007554:	a1 a3       	sbr	r3,0x0
80007556:	93 13       	st.w	r9[0x4],r3
80007558:	91 29       	st.w	r8[0x8],r9
8000755a:	04 9c       	mov	r12,r2
8000755c:	6e 18       	ld.w	r8,r7[0x4]
8000755e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007562:	10 46       	or	r6,r8
80007564:	8f 16       	st.w	r7[0x4],r6
80007566:	ca a8       	rjmp	800076ba <_realloc_r+0x2b6>
80007568:	14 03       	add	r3,r10
8000756a:	0c 33       	cp.w	r3,r6
8000756c:	c0 85       	brlt	8000757c <_realloc_r+0x178>
8000756e:	72 28       	ld.w	r8,r9[0x8]
80007570:	72 39       	ld.w	r9,r9[0xc]
80007572:	93 28       	st.w	r9[0x8],r8
80007574:	91 39       	st.w	r8[0xc],r9
80007576:	6e 28       	ld.w	r8,r7[0x8]
80007578:	6e 39       	ld.w	r9,r7[0xc]
8000757a:	c0 78       	rjmp	80007588 <_realloc_r+0x184>
8000757c:	f8 00 00 03 	add	r3,r12,r0
80007580:	0c 33       	cp.w	r3,r6
80007582:	c3 35       	brlt	800075e8 <_realloc_r+0x1e4>
80007584:	6e 39       	ld.w	r9,r7[0xc]
80007586:	6e 28       	ld.w	r8,r7[0x8]
80007588:	93 28       	st.w	r9[0x8],r8
8000758a:	91 39       	st.w	r8[0xc],r9
8000758c:	e0 ca 00 04 	sub	r10,r0,4
80007590:	ee cc ff f8 	sub	r12,r7,-8
80007594:	e0 4a 00 24 	cp.w	r10,36
80007598:	e0 8b 00 24 	brhi	800075e0 <_realloc_r+0x1dc>
8000759c:	59 3a       	cp.w	r10,19
8000759e:	e0 88 00 1a 	brls	800075d2 <_realloc_r+0x1ce>
800075a2:	09 08       	ld.w	r8,r4++
800075a4:	99 08       	st.w	r12[0x0],r8
800075a6:	09 08       	ld.w	r8,r4++
800075a8:	8f 38       	st.w	r7[0xc],r8
800075aa:	ee cc ff f0 	sub	r12,r7,-16
800075ae:	59 ba       	cp.w	r10,27
800075b0:	e0 88 00 11 	brls	800075d2 <_realloc_r+0x1ce>
800075b4:	09 08       	ld.w	r8,r4++
800075b6:	99 08       	st.w	r12[0x0],r8
800075b8:	09 08       	ld.w	r8,r4++
800075ba:	8f 58       	st.w	r7[0x14],r8
800075bc:	ee cc ff e8 	sub	r12,r7,-24
800075c0:	e0 4a 00 24 	cp.w	r10,36
800075c4:	c0 71       	brne	800075d2 <_realloc_r+0x1ce>
800075c6:	09 08       	ld.w	r8,r4++
800075c8:	99 08       	st.w	r12[0x0],r8
800075ca:	ee cc ff e0 	sub	r12,r7,-32
800075ce:	09 08       	ld.w	r8,r4++
800075d0:	8f 78       	st.w	r7[0x1c],r8
800075d2:	09 08       	ld.w	r8,r4++
800075d4:	18 a8       	st.w	r12++,r8
800075d6:	68 08       	ld.w	r8,r4[0x0]
800075d8:	99 08       	st.w	r12[0x0],r8
800075da:	68 18       	ld.w	r8,r4[0x4]
800075dc:	99 18       	st.w	r12[0x4],r8
800075de:	c4 78       	rjmp	8000766c <_realloc_r+0x268>
800075e0:	08 9b       	mov	r11,r4
800075e2:	e0 a0 1d 42 	rcall	8000b066 <memmove>
800075e6:	c4 38       	rjmp	8000766c <_realloc_r+0x268>
800075e8:	04 9c       	mov	r12,r2
800075ea:	fe b0 fc 45 	rcall	80006e74 <_malloc_r>
800075ee:	18 95       	mov	r5,r12
800075f0:	c3 a0       	breq	80007664 <_realloc_r+0x260>
800075f2:	62 18       	ld.w	r8,r1[0x4]
800075f4:	f8 c9 00 08 	sub	r9,r12,8
800075f8:	a1 c8       	cbr	r8,0x0
800075fa:	e2 08 00 08 	add	r8,r1,r8
800075fe:	10 39       	cp.w	r9,r8
80007600:	c0 71       	brne	8000760e <_realloc_r+0x20a>
80007602:	72 13       	ld.w	r3,r9[0x4]
80007604:	02 97       	mov	r7,r1
80007606:	e0 13 ff fc 	andl	r3,0xfffc
8000760a:	00 03       	add	r3,r0
8000760c:	c3 08       	rjmp	8000766c <_realloc_r+0x268>
8000760e:	e0 ca 00 04 	sub	r10,r0,4
80007612:	e0 4a 00 24 	cp.w	r10,36
80007616:	e0 8b 00 20 	brhi	80007656 <_realloc_r+0x252>
8000761a:	08 99       	mov	r9,r4
8000761c:	18 98       	mov	r8,r12
8000761e:	59 3a       	cp.w	r10,19
80007620:	e0 88 00 14 	brls	80007648 <_realloc_r+0x244>
80007624:	13 0b       	ld.w	r11,r9++
80007626:	10 ab       	st.w	r8++,r11
80007628:	13 0b       	ld.w	r11,r9++
8000762a:	10 ab       	st.w	r8++,r11
8000762c:	59 ba       	cp.w	r10,27
8000762e:	e0 88 00 0d 	brls	80007648 <_realloc_r+0x244>
80007632:	13 0b       	ld.w	r11,r9++
80007634:	10 ab       	st.w	r8++,r11
80007636:	13 0b       	ld.w	r11,r9++
80007638:	10 ab       	st.w	r8++,r11
8000763a:	e0 4a 00 24 	cp.w	r10,36
8000763e:	c0 51       	brne	80007648 <_realloc_r+0x244>
80007640:	13 0a       	ld.w	r10,r9++
80007642:	10 aa       	st.w	r8++,r10
80007644:	13 0a       	ld.w	r10,r9++
80007646:	10 aa       	st.w	r8++,r10
80007648:	13 0a       	ld.w	r10,r9++
8000764a:	10 aa       	st.w	r8++,r10
8000764c:	72 0a       	ld.w	r10,r9[0x0]
8000764e:	91 0a       	st.w	r8[0x0],r10
80007650:	72 19       	ld.w	r9,r9[0x4]
80007652:	91 19       	st.w	r8[0x4],r9
80007654:	c0 48       	rjmp	8000765c <_realloc_r+0x258>
80007656:	08 9b       	mov	r11,r4
80007658:	e0 a0 1d 07 	rcall	8000b066 <memmove>
8000765c:	08 9b       	mov	r11,r4
8000765e:	04 9c       	mov	r12,r2
80007660:	e0 a0 1a 60 	rcall	8000ab20 <_free_r>
80007664:	04 9c       	mov	r12,r2
80007666:	c2 a8       	rjmp	800076ba <_realloc_r+0x2b6>
80007668:	00 93       	mov	r3,r0
8000766a:	02 97       	mov	r7,r1
8000766c:	e6 06 01 09 	sub	r9,r3,r6
80007670:	6e 18       	ld.w	r8,r7[0x4]
80007672:	58 f9       	cp.w	r9,15
80007674:	e0 88 00 16 	brls	800076a0 <_realloc_r+0x29c>
80007678:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000767c:	ed e8 10 08 	or	r8,r6,r8
80007680:	8f 18       	st.w	r7[0x4],r8
80007682:	12 98       	mov	r8,r9
80007684:	a1 a8       	sbr	r8,0x0
80007686:	ee 06 00 0b 	add	r11,r7,r6
8000768a:	f6 09 00 09 	add	r9,r11,r9
8000768e:	97 18       	st.w	r11[0x4],r8
80007690:	72 18       	ld.w	r8,r9[0x4]
80007692:	a1 a8       	sbr	r8,0x0
80007694:	2f 8b       	sub	r11,-8
80007696:	93 18       	st.w	r9[0x4],r8
80007698:	04 9c       	mov	r12,r2
8000769a:	e0 a0 1a 43 	rcall	8000ab20 <_free_r>
8000769e:	c0 b8       	rjmp	800076b4 <_realloc_r+0x2b0>
800076a0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800076a4:	e7 e8 10 08 	or	r8,r3,r8
800076a8:	8f 18       	st.w	r7[0x4],r8
800076aa:	ee 03 00 03 	add	r3,r7,r3
800076ae:	66 18       	ld.w	r8,r3[0x4]
800076b0:	a1 a8       	sbr	r8,0x0
800076b2:	87 18       	st.w	r3[0x4],r8
800076b4:	04 9c       	mov	r12,r2
800076b6:	ee c5 ff f8 	sub	r5,r7,-8
800076ba:	fe b0 f1 a1 	rcall	800059fc <__malloc_unlock>
800076be:	0a 9c       	mov	r12,r5
800076c0:	2f fd       	sub	sp,-4
800076c2:	d8 32       	popm	r0-r7,pc

800076c4 <_sbrk_r>:
800076c4:	d4 21       	pushm	r4-r7,lr
800076c6:	30 08       	mov	r8,0
800076c8:	18 97       	mov	r7,r12
800076ca:	e0 66 b6 74 	mov	r6,46708
800076ce:	16 9c       	mov	r12,r11
800076d0:	8d 08       	st.w	r6[0x0],r8
800076d2:	c8 5c       	rcall	800077dc <_sbrk>
800076d4:	5b fc       	cp.w	r12,-1
800076d6:	c0 51       	brne	800076e0 <_sbrk_r+0x1c>
800076d8:	6c 08       	ld.w	r8,r6[0x0]
800076da:	58 08       	cp.w	r8,0
800076dc:	ef f8 1a 03 	st.wne	r7[0xc],r8
800076e0:	d8 22       	popm	r4-r7,pc
800076e2:	d7 03       	nop

800076e4 <sprintf>:
800076e4:	d4 01       	pushm	lr
800076e6:	21 7d       	sub	sp,92
800076e8:	e0 68 ff ff 	mov	r8,65535
800076ec:	ea 18 7f ff 	orh	r8,0x7fff
800076f0:	50 58       	stdsp	sp[0x14],r8
800076f2:	50 28       	stdsp	sp[0x8],r8
800076f4:	e0 68 02 08 	mov	r8,520
800076f8:	ba 68       	st.h	sp[0xc],r8
800076fa:	3f f8       	mov	r8,-1
800076fc:	ba 78       	st.h	sp[0xe],r8
800076fe:	e0 68 0a 30 	mov	r8,2608
80007702:	50 4c       	stdsp	sp[0x10],r12
80007704:	16 9a       	mov	r10,r11
80007706:	50 0c       	stdsp	sp[0x0],r12
80007708:	fa c9 ff a0 	sub	r9,sp,-96
8000770c:	70 0c       	ld.w	r12,r8[0x0]
8000770e:	1a 9b       	mov	r11,sp
80007710:	e0 a0 02 1a 	rcall	80007b44 <_vfprintf_r>
80007714:	30 09       	mov	r9,0
80007716:	40 08       	lddsp	r8,sp[0x0]
80007718:	b0 89       	st.b	r8[0x0],r9
8000771a:	2e 9d       	sub	sp,-92
8000771c:	d8 02       	popm	pc
8000771e:	d7 03       	nop

80007720 <strncpy>:
80007720:	30 08       	mov	r8,0
80007722:	10 3a       	cp.w	r10,r8
80007724:	5e 0c       	reteq	r12
80007726:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000772a:	f8 08 0b 09 	st.b	r12[r8],r9
8000772e:	2f f8       	sub	r8,-1
80007730:	58 09       	cp.w	r9,0
80007732:	cf 81       	brne	80007722 <strncpy+0x2>
80007734:	10 3a       	cp.w	r10,r8
80007736:	5e 0c       	reteq	r12
80007738:	f8 08 0b 09 	st.b	r12[r8],r9
8000773c:	2f f8       	sub	r8,-1
8000773e:	cf bb       	rjmp	80007734 <strncpy+0x14>

80007740 <_close>:
80007740:	30 28       	mov	r8,2
80007742:	d6 73       	breakpoint
80007744:	3f fc       	mov	r12,-1
80007746:	35 8b       	mov	r11,88
80007748:	58 0c       	cp.w	r12,0
8000774a:	5e 4c       	retge	r12
8000774c:	e0 6a b6 74 	mov	r10,46708
80007750:	95 0b       	st.w	r10[0x0],r11
80007752:	5e fc       	retal	r12

80007754 <_lseek>:
80007754:	30 58       	mov	r8,5
80007756:	d6 73       	breakpoint
80007758:	3f fc       	mov	r12,-1
8000775a:	35 8b       	mov	r11,88
8000775c:	58 0c       	cp.w	r12,0
8000775e:	5e 4c       	retge	r12
80007760:	e0 6a b6 74 	mov	r10,46708
80007764:	95 0b       	st.w	r10[0x0],r11
80007766:	5e fc       	retal	r12

80007768 <isatty>:
80007768:	30 b8       	mov	r8,11
8000776a:	d6 73       	breakpoint
8000776c:	3f fc       	mov	r12,-1
8000776e:	35 8b       	mov	r11,88
80007770:	58 0c       	cp.w	r12,0
80007772:	5e 4c       	retge	r12
80007774:	e0 6a b6 74 	mov	r10,46708
80007778:	95 0b       	st.w	r10[0x0],r11
8000777a:	5e fc       	retal	r12

8000777c <_fstat_host>:
8000777c:	30 98       	mov	r8,9
8000777e:	d6 73       	breakpoint
80007780:	3f fc       	mov	r12,-1
80007782:	35 8b       	mov	r11,88
80007784:	58 0c       	cp.w	r12,0
80007786:	5e 4c       	retge	r12
80007788:	e0 6a b6 74 	mov	r10,46708
8000778c:	95 0b       	st.w	r10[0x0],r11
8000778e:	5e fc       	retal	r12

80007790 <_fstat>:
80007790:	d4 21       	pushm	r4-r7,lr
80007792:	21 0d       	sub	sp,64
80007794:	16 97       	mov	r7,r11
80007796:	1a 9b       	mov	r11,sp
80007798:	cf 2f       	rcall	8000777c <_fstat_host>
8000779a:	c0 34       	brge	800077a0 <_fstat+0x10>
8000779c:	3f fc       	mov	r12,-1
8000779e:	c1 c8       	rjmp	800077d6 <_fstat+0x46>
800077a0:	40 08       	lddsp	r8,sp[0x0]
800077a2:	ae 08       	st.h	r7[0x0],r8
800077a4:	40 18       	lddsp	r8,sp[0x4]
800077a6:	ae 18       	st.h	r7[0x2],r8
800077a8:	40 28       	lddsp	r8,sp[0x8]
800077aa:	8f 18       	st.w	r7[0x4],r8
800077ac:	40 38       	lddsp	r8,sp[0xc]
800077ae:	ae 48       	st.h	r7[0x8],r8
800077b0:	40 48       	lddsp	r8,sp[0x10]
800077b2:	ae 58       	st.h	r7[0xa],r8
800077b4:	40 58       	lddsp	r8,sp[0x14]
800077b6:	ae 68       	st.h	r7[0xc],r8
800077b8:	40 68       	lddsp	r8,sp[0x18]
800077ba:	ae 78       	st.h	r7[0xe],r8
800077bc:	40 88       	lddsp	r8,sp[0x20]
800077be:	8f 48       	st.w	r7[0x10],r8
800077c0:	40 a8       	lddsp	r8,sp[0x28]
800077c2:	8f b8       	st.w	r7[0x2c],r8
800077c4:	40 c8       	lddsp	r8,sp[0x30]
800077c6:	8f c8       	st.w	r7[0x30],r8
800077c8:	40 d8       	lddsp	r8,sp[0x34]
800077ca:	8f 58       	st.w	r7[0x14],r8
800077cc:	40 e8       	lddsp	r8,sp[0x38]
800077ce:	30 0c       	mov	r12,0
800077d0:	8f 78       	st.w	r7[0x1c],r8
800077d2:	40 f8       	lddsp	r8,sp[0x3c]
800077d4:	8f 98       	st.w	r7[0x24],r8
800077d6:	2f 0d       	sub	sp,-64
800077d8:	d8 22       	popm	r4-r7,pc
800077da:	d7 03       	nop

800077dc <_sbrk>:
800077dc:	d4 01       	pushm	lr
800077de:	e0 68 0d 74 	mov	r8,3444
800077e2:	70 09       	ld.w	r9,r8[0x0]
800077e4:	58 09       	cp.w	r9,0
800077e6:	c0 41       	brne	800077ee <_sbrk+0x12>
800077e8:	e0 69 b6 78 	mov	r9,46712
800077ec:	91 09       	st.w	r8[0x0],r9
800077ee:	e0 69 0d 74 	mov	r9,3444
800077f2:	e0 7a 70 00 	mov	r10,94208
800077f6:	72 08       	ld.w	r8,r9[0x0]
800077f8:	f0 0c 00 0c 	add	r12,r8,r12
800077fc:	14 3c       	cp.w	r12,r10
800077fe:	e0 8b 00 04 	brhi	80007806 <_sbrk+0x2a>
80007802:	93 0c       	st.w	r9[0x0],r12
80007804:	c0 68       	rjmp	80007810 <_sbrk+0x34>
80007806:	e0 a0 18 15 	rcall	8000a830 <__errno>
8000780a:	30 c8       	mov	r8,12
8000780c:	99 08       	st.w	r12[0x0],r8
8000780e:	3f f8       	mov	r8,-1
80007810:	10 9c       	mov	r12,r8
80007812:	d8 02       	popm	pc

80007814 <get_arg>:
80007814:	d4 31       	pushm	r0-r7,lr
80007816:	20 8d       	sub	sp,32
80007818:	fa c4 ff bc 	sub	r4,sp,-68
8000781c:	50 4b       	stdsp	sp[0x10],r11
8000781e:	68 2e       	ld.w	lr,r4[0x8]
80007820:	50 58       	stdsp	sp[0x14],r8
80007822:	12 96       	mov	r6,r9
80007824:	7c 0b       	ld.w	r11,lr[0x0]
80007826:	70 05       	ld.w	r5,r8[0x0]
80007828:	50 6e       	stdsp	sp[0x18],lr
8000782a:	58 0b       	cp.w	r11,0
8000782c:	f4 0b 17 00 	moveq	r11,r10
80007830:	68 03       	ld.w	r3,r4[0x0]
80007832:	68 11       	ld.w	r1,r4[0x4]
80007834:	40 49       	lddsp	r9,sp[0x10]
80007836:	30 08       	mov	r8,0
80007838:	c2 89       	rjmp	80007a88 <get_arg+0x274>
8000783a:	2f fb       	sub	r11,-1
8000783c:	32 5c       	mov	r12,37
8000783e:	17 8a       	ld.ub	r10,r11[0x0]
80007840:	f8 0a 18 00 	cp.b	r10,r12
80007844:	5f 1e       	srne	lr
80007846:	f0 0a 18 00 	cp.b	r10,r8
8000784a:	5f 1c       	srne	r12
8000784c:	fd ec 00 0c 	and	r12,lr,r12
80007850:	f0 0c 18 00 	cp.b	r12,r8
80007854:	cf 31       	brne	8000783a <get_arg+0x26>
80007856:	58 0a       	cp.w	r10,0
80007858:	e0 80 01 25 	breq	80007aa2 <get_arg+0x28e>
8000785c:	30 0c       	mov	r12,0
8000785e:	3f fa       	mov	r10,-1
80007860:	18 90       	mov	r0,r12
80007862:	50 3a       	stdsp	sp[0xc],r10
80007864:	18 94       	mov	r4,r12
80007866:	18 92       	mov	r2,r12
80007868:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000786c:	16 97       	mov	r7,r11
8000786e:	50 7c       	stdsp	sp[0x1c],r12
80007870:	fe cc 9e c0 	sub	r12,pc,-24896
80007874:	0f 3a       	ld.ub	r10,r7++
80007876:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000787a:	40 7c       	lddsp	r12,sp[0x1c]
8000787c:	1c 0c       	add	r12,lr
8000787e:	fe ce 9f 96 	sub	lr,pc,-24682
80007882:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007886:	20 1e       	sub	lr,1
80007888:	50 0e       	stdsp	sp[0x0],lr
8000788a:	fe ce a0 0e 	sub	lr,pc,-24562
8000788e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007892:	50 7c       	stdsp	sp[0x1c],r12
80007894:	40 0c       	lddsp	r12,sp[0x0]
80007896:	58 7c       	cp.w	r12,7
80007898:	e0 8b 00 f1 	brhi	80007a7a <get_arg+0x266>
8000789c:	fe ce a1 c0 	sub	lr,pc,-24128
800078a0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
800078a4:	36 8b       	mov	r11,104
800078a6:	f6 0a 18 00 	cp.b	r10,r11
800078aa:	e0 80 00 e8 	breq	80007a7a <get_arg+0x266>
800078ae:	37 1b       	mov	r11,113
800078b0:	f6 0a 18 00 	cp.b	r10,r11
800078b4:	c0 70       	breq	800078c2 <get_arg+0xae>
800078b6:	34 cb       	mov	r11,76
800078b8:	f6 0a 18 00 	cp.b	r10,r11
800078bc:	c0 51       	brne	800078c6 <get_arg+0xb2>
800078be:	a3 b4       	sbr	r4,0x3
800078c0:	cd d8       	rjmp	80007a7a <get_arg+0x266>
800078c2:	a5 b4       	sbr	r4,0x5
800078c4:	cd b8       	rjmp	80007a7a <get_arg+0x266>
800078c6:	08 9a       	mov	r10,r4
800078c8:	0e 9b       	mov	r11,r7
800078ca:	a5 aa       	sbr	r10,0x4
800078cc:	17 3c       	ld.ub	r12,r11++
800078ce:	a5 b4       	sbr	r4,0x5
800078d0:	36 ce       	mov	lr,108
800078d2:	fc 0c 18 00 	cp.b	r12,lr
800078d6:	e0 80 00 d3 	breq	80007a7c <get_arg+0x268>
800078da:	14 94       	mov	r4,r10
800078dc:	cc f8       	rjmp	80007a7a <get_arg+0x266>
800078de:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800078e2:	36 7c       	mov	r12,103
800078e4:	f8 0a 18 00 	cp.b	r10,r12
800078e8:	e0 8b 00 27 	brhi	80007936 <get_arg+0x122>
800078ec:	36 5b       	mov	r11,101
800078ee:	f6 0a 18 00 	cp.b	r10,r11
800078f2:	c4 82       	brcc	80007982 <get_arg+0x16e>
800078f4:	34 fb       	mov	r11,79
800078f6:	f6 0a 18 00 	cp.b	r10,r11
800078fa:	c4 80       	breq	8000798a <get_arg+0x176>
800078fc:	e0 8b 00 0c 	brhi	80007914 <get_arg+0x100>
80007900:	34 5b       	mov	r11,69
80007902:	f6 0a 18 00 	cp.b	r10,r11
80007906:	c3 e0       	breq	80007982 <get_arg+0x16e>
80007908:	34 7b       	mov	r11,71
8000790a:	f6 0a 18 00 	cp.b	r10,r11
8000790e:	c3 a0       	breq	80007982 <get_arg+0x16e>
80007910:	34 4b       	mov	r11,68
80007912:	c0 88       	rjmp	80007922 <get_arg+0x10e>
80007914:	35 8b       	mov	r11,88
80007916:	f6 0a 18 00 	cp.b	r10,r11
8000791a:	c2 c0       	breq	80007972 <get_arg+0x15e>
8000791c:	e0 8b 00 07 	brhi	8000792a <get_arg+0x116>
80007920:	35 5b       	mov	r11,85
80007922:	f6 0a 18 00 	cp.b	r10,r11
80007926:	c3 51       	brne	80007990 <get_arg+0x17c>
80007928:	c3 18       	rjmp	8000798a <get_arg+0x176>
8000792a:	36 3b       	mov	r11,99
8000792c:	f6 0a 18 00 	cp.b	r10,r11
80007930:	c2 f0       	breq	8000798e <get_arg+0x17a>
80007932:	36 4b       	mov	r11,100
80007934:	c0 e8       	rjmp	80007950 <get_arg+0x13c>
80007936:	37 0b       	mov	r11,112
80007938:	f6 0a 18 00 	cp.b	r10,r11
8000793c:	c2 50       	breq	80007986 <get_arg+0x172>
8000793e:	e0 8b 00 0d 	brhi	80007958 <get_arg+0x144>
80007942:	36 eb       	mov	r11,110
80007944:	f6 0a 18 00 	cp.b	r10,r11
80007948:	c1 f0       	breq	80007986 <get_arg+0x172>
8000794a:	e0 8b 00 14 	brhi	80007972 <get_arg+0x15e>
8000794e:	36 9b       	mov	r11,105
80007950:	f6 0a 18 00 	cp.b	r10,r11
80007954:	c1 e1       	brne	80007990 <get_arg+0x17c>
80007956:	c0 e8       	rjmp	80007972 <get_arg+0x15e>
80007958:	37 5b       	mov	r11,117
8000795a:	f6 0a 18 00 	cp.b	r10,r11
8000795e:	c0 a0       	breq	80007972 <get_arg+0x15e>
80007960:	37 8b       	mov	r11,120
80007962:	f6 0a 18 00 	cp.b	r10,r11
80007966:	c0 60       	breq	80007972 <get_arg+0x15e>
80007968:	37 3b       	mov	r11,115
8000796a:	f6 0a 18 00 	cp.b	r10,r11
8000796e:	c1 11       	brne	80007990 <get_arg+0x17c>
80007970:	c0 b8       	rjmp	80007986 <get_arg+0x172>
80007972:	ed b4 00 04 	bld	r4,0x4
80007976:	c0 a0       	breq	8000798a <get_arg+0x176>
80007978:	ed b4 00 05 	bld	r4,0x5
8000797c:	c0 91       	brne	8000798e <get_arg+0x17a>
8000797e:	30 20       	mov	r0,2
80007980:	c0 88       	rjmp	80007990 <get_arg+0x17c>
80007982:	30 40       	mov	r0,4
80007984:	c0 68       	rjmp	80007990 <get_arg+0x17c>
80007986:	30 30       	mov	r0,3
80007988:	c0 48       	rjmp	80007990 <get_arg+0x17c>
8000798a:	30 10       	mov	r0,1
8000798c:	c0 28       	rjmp	80007990 <get_arg+0x17c>
8000798e:	30 00       	mov	r0,0
80007990:	40 3b       	lddsp	r11,sp[0xc]
80007992:	5b fb       	cp.w	r11,-1
80007994:	c0 40       	breq	8000799c <get_arg+0x188>
80007996:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000799a:	c7 08       	rjmp	80007a7a <get_arg+0x266>
8000799c:	58 60       	cp.w	r0,6
8000799e:	e0 8b 00 6e 	brhi	80007a7a <get_arg+0x266>
800079a2:	6c 0a       	ld.w	r10,r6[0x0]
800079a4:	ea cc ff ff 	sub	r12,r5,-1
800079a8:	fe ce a2 ac 	sub	lr,pc,-23892
800079ac:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800079b0:	f4 cb ff f8 	sub	r11,r10,-8
800079b4:	8d 0b       	st.w	r6[0x0],r11
800079b6:	f4 ea 00 00 	ld.d	r10,r10[0]
800079ba:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800079be:	c0 f8       	rjmp	800079dc <get_arg+0x1c8>
800079c0:	f4 cb ff fc 	sub	r11,r10,-4
800079c4:	8d 0b       	st.w	r6[0x0],r11
800079c6:	74 0a       	ld.w	r10,r10[0x0]
800079c8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800079cc:	c0 88       	rjmp	800079dc <get_arg+0x1c8>
800079ce:	f4 cb ff f8 	sub	r11,r10,-8
800079d2:	8d 0b       	st.w	r6[0x0],r11
800079d4:	f4 ea 00 00 	ld.d	r10,r10[0]
800079d8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800079dc:	0e 9b       	mov	r11,r7
800079de:	18 95       	mov	r5,r12
800079e0:	c4 e8       	rjmp	80007a7c <get_arg+0x268>
800079e2:	62 0a       	ld.w	r10,r1[0x0]
800079e4:	5b fa       	cp.w	r10,-1
800079e6:	c0 b1       	brne	800079fc <get_arg+0x1e8>
800079e8:	50 19       	stdsp	sp[0x4],r9
800079ea:	50 28       	stdsp	sp[0x8],r8
800079ec:	e0 6a 00 80 	mov	r10,128
800079f0:	30 0b       	mov	r11,0
800079f2:	02 9c       	mov	r12,r1
800079f4:	fe b0 fd 00 	rcall	800073f4 <memset>
800079f8:	40 28       	lddsp	r8,sp[0x8]
800079fa:	40 19       	lddsp	r9,sp[0x4]
800079fc:	e4 cc 00 01 	sub	r12,r2,1
80007a00:	0e 9b       	mov	r11,r7
80007a02:	50 3c       	stdsp	sp[0xc],r12
80007a04:	f2 0c 0c 49 	max	r9,r9,r12
80007a08:	c3 a8       	rjmp	80007a7c <get_arg+0x268>
80007a0a:	62 0a       	ld.w	r10,r1[0x0]
80007a0c:	5b fa       	cp.w	r10,-1
80007a0e:	c0 b1       	brne	80007a24 <get_arg+0x210>
80007a10:	50 19       	stdsp	sp[0x4],r9
80007a12:	50 28       	stdsp	sp[0x8],r8
80007a14:	e0 6a 00 80 	mov	r10,128
80007a18:	30 0b       	mov	r11,0
80007a1a:	02 9c       	mov	r12,r1
80007a1c:	fe b0 fc ec 	rcall	800073f4 <memset>
80007a20:	40 28       	lddsp	r8,sp[0x8]
80007a22:	40 19       	lddsp	r9,sp[0x4]
80007a24:	20 12       	sub	r2,1
80007a26:	30 0a       	mov	r10,0
80007a28:	0e 9b       	mov	r11,r7
80007a2a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007a2e:	f2 02 0c 49 	max	r9,r9,r2
80007a32:	c2 58       	rjmp	80007a7c <get_arg+0x268>
80007a34:	16 97       	mov	r7,r11
80007a36:	6c 0a       	ld.w	r10,r6[0x0]
80007a38:	f4 cb ff fc 	sub	r11,r10,-4
80007a3c:	8d 0b       	st.w	r6[0x0],r11
80007a3e:	74 0a       	ld.w	r10,r10[0x0]
80007a40:	0e 9b       	mov	r11,r7
80007a42:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007a46:	2f f5       	sub	r5,-1
80007a48:	c1 a8       	rjmp	80007a7c <get_arg+0x268>
80007a4a:	f4 c2 00 30 	sub	r2,r10,48
80007a4e:	c0 68       	rjmp	80007a5a <get_arg+0x246>
80007a50:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007a54:	2f f7       	sub	r7,-1
80007a56:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007a5a:	0f 8a       	ld.ub	r10,r7[0x0]
80007a5c:	58 0a       	cp.w	r10,0
80007a5e:	c0 e0       	breq	80007a7a <get_arg+0x266>
80007a60:	23 0a       	sub	r10,48
80007a62:	58 9a       	cp.w	r10,9
80007a64:	fe 98 ff f6 	brls	80007a50 <get_arg+0x23c>
80007a68:	c0 98       	rjmp	80007a7a <get_arg+0x266>
80007a6a:	2f f7       	sub	r7,-1
80007a6c:	0f 8a       	ld.ub	r10,r7[0x0]
80007a6e:	58 0a       	cp.w	r10,0
80007a70:	c0 50       	breq	80007a7a <get_arg+0x266>
80007a72:	23 0a       	sub	r10,48
80007a74:	58 9a       	cp.w	r10,9
80007a76:	fe 98 ff fa 	brls	80007a6a <get_arg+0x256>
80007a7a:	0e 9b       	mov	r11,r7
80007a7c:	40 7c       	lddsp	r12,sp[0x1c]
80007a7e:	30 ba       	mov	r10,11
80007a80:	f4 0c 18 00 	cp.b	r12,r10
80007a84:	fe 91 fe f2 	brne	80007868 <get_arg+0x54>
80007a88:	40 42       	lddsp	r2,sp[0x10]
80007a8a:	17 8c       	ld.ub	r12,r11[0x0]
80007a8c:	0a 32       	cp.w	r2,r5
80007a8e:	5f 4a       	srge	r10
80007a90:	f0 0c 18 00 	cp.b	r12,r8
80007a94:	5f 1c       	srne	r12
80007a96:	f9 ea 00 0a 	and	r10,r12,r10
80007a9a:	f0 0a 18 00 	cp.b	r10,r8
80007a9e:	fe 91 fe cf 	brne	8000783c <get_arg+0x28>
80007aa2:	30 08       	mov	r8,0
80007aa4:	40 4e       	lddsp	lr,sp[0x10]
80007aa6:	17 8a       	ld.ub	r10,r11[0x0]
80007aa8:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007aac:	f0 0a 18 00 	cp.b	r10,r8
80007ab0:	fc 09 17 10 	movne	r9,lr
80007ab4:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007ab8:	06 9e       	mov	lr,r3
80007aba:	c2 a8       	rjmp	80007b0e <get_arg+0x2fa>
80007abc:	62 0a       	ld.w	r10,r1[0x0]
80007abe:	58 3a       	cp.w	r10,3
80007ac0:	c1 e0       	breq	80007afc <get_arg+0x2e8>
80007ac2:	e0 89 00 07 	brgt	80007ad0 <get_arg+0x2bc>
80007ac6:	58 1a       	cp.w	r10,1
80007ac8:	c1 a0       	breq	80007afc <get_arg+0x2e8>
80007aca:	58 2a       	cp.w	r10,2
80007acc:	c1 81       	brne	80007afc <get_arg+0x2e8>
80007ace:	c0 58       	rjmp	80007ad8 <get_arg+0x2c4>
80007ad0:	58 5a       	cp.w	r10,5
80007ad2:	c0 c0       	breq	80007aea <get_arg+0x2d6>
80007ad4:	c0 b5       	brlt	80007aea <get_arg+0x2d6>
80007ad6:	c1 38       	rjmp	80007afc <get_arg+0x2e8>
80007ad8:	6c 0a       	ld.w	r10,r6[0x0]
80007ada:	f4 cc ff f8 	sub	r12,r10,-8
80007ade:	8d 0c       	st.w	r6[0x0],r12
80007ae0:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ae4:	f0 e3 00 00 	st.d	r8[0],r2
80007ae8:	c1 08       	rjmp	80007b08 <get_arg+0x2f4>
80007aea:	6c 0a       	ld.w	r10,r6[0x0]
80007aec:	f4 cc ff f8 	sub	r12,r10,-8
80007af0:	8d 0c       	st.w	r6[0x0],r12
80007af2:	f4 e2 00 00 	ld.d	r2,r10[0]
80007af6:	f0 e3 00 00 	st.d	r8[0],r2
80007afa:	c0 78       	rjmp	80007b08 <get_arg+0x2f4>
80007afc:	6c 0a       	ld.w	r10,r6[0x0]
80007afe:	f4 cc ff fc 	sub	r12,r10,-4
80007b02:	8d 0c       	st.w	r6[0x0],r12
80007b04:	74 0a       	ld.w	r10,r10[0x0]
80007b06:	91 0a       	st.w	r8[0x0],r10
80007b08:	2f f5       	sub	r5,-1
80007b0a:	2f 88       	sub	r8,-8
80007b0c:	2f c1       	sub	r1,-4
80007b0e:	12 35       	cp.w	r5,r9
80007b10:	fe 9a ff d6 	brle	80007abc <get_arg+0x2a8>
80007b14:	1c 93       	mov	r3,lr
80007b16:	40 52       	lddsp	r2,sp[0x14]
80007b18:	40 6e       	lddsp	lr,sp[0x18]
80007b1a:	85 05       	st.w	r2[0x0],r5
80007b1c:	9d 0b       	st.w	lr[0x0],r11
80007b1e:	40 4b       	lddsp	r11,sp[0x10]
80007b20:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007b24:	2f 8d       	sub	sp,-32
80007b26:	d8 32       	popm	r0-r7,pc

80007b28 <__sprint_r>:
80007b28:	d4 21       	pushm	r4-r7,lr
80007b2a:	14 97       	mov	r7,r10
80007b2c:	74 28       	ld.w	r8,r10[0x8]
80007b2e:	58 08       	cp.w	r8,0
80007b30:	c0 41       	brne	80007b38 <__sprint_r+0x10>
80007b32:	95 18       	st.w	r10[0x4],r8
80007b34:	10 9c       	mov	r12,r8
80007b36:	d8 22       	popm	r4-r7,pc
80007b38:	e0 a0 18 ba 	rcall	8000acac <__sfvwrite_r>
80007b3c:	30 08       	mov	r8,0
80007b3e:	8f 18       	st.w	r7[0x4],r8
80007b40:	8f 28       	st.w	r7[0x8],r8
80007b42:	d8 22       	popm	r4-r7,pc

80007b44 <_vfprintf_r>:
80007b44:	d4 31       	pushm	r0-r7,lr
80007b46:	fa cd 06 bc 	sub	sp,sp,1724
80007b4a:	51 09       	stdsp	sp[0x40],r9
80007b4c:	16 91       	mov	r1,r11
80007b4e:	14 97       	mov	r7,r10
80007b50:	18 95       	mov	r5,r12
80007b52:	e0 a0 1a 1d 	rcall	8000af8c <_localeconv_r>
80007b56:	78 0c       	ld.w	r12,r12[0x0]
80007b58:	50 cc       	stdsp	sp[0x30],r12
80007b5a:	58 05       	cp.w	r5,0
80007b5c:	c0 70       	breq	80007b6a <_vfprintf_r+0x26>
80007b5e:	6a 68       	ld.w	r8,r5[0x18]
80007b60:	58 08       	cp.w	r8,0
80007b62:	c0 41       	brne	80007b6a <_vfprintf_r+0x26>
80007b64:	0a 9c       	mov	r12,r5
80007b66:	e0 a0 17 43 	rcall	8000a9ec <__sinit>
80007b6a:	fe c8 a0 aa 	sub	r8,pc,-24406
80007b6e:	10 31       	cp.w	r1,r8
80007b70:	c0 31       	brne	80007b76 <_vfprintf_r+0x32>
80007b72:	6a 01       	ld.w	r1,r5[0x0]
80007b74:	c0 c8       	rjmp	80007b8c <_vfprintf_r+0x48>
80007b76:	fe c8 a0 96 	sub	r8,pc,-24426
80007b7a:	10 31       	cp.w	r1,r8
80007b7c:	c0 31       	brne	80007b82 <_vfprintf_r+0x3e>
80007b7e:	6a 11       	ld.w	r1,r5[0x4]
80007b80:	c0 68       	rjmp	80007b8c <_vfprintf_r+0x48>
80007b82:	fe c8 a0 82 	sub	r8,pc,-24446
80007b86:	10 31       	cp.w	r1,r8
80007b88:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007b8c:	82 68       	ld.sh	r8,r1[0xc]
80007b8e:	ed b8 00 03 	bld	r8,0x3
80007b92:	c0 41       	brne	80007b9a <_vfprintf_r+0x56>
80007b94:	62 48       	ld.w	r8,r1[0x10]
80007b96:	58 08       	cp.w	r8,0
80007b98:	c0 71       	brne	80007ba6 <_vfprintf_r+0x62>
80007b9a:	02 9b       	mov	r11,r1
80007b9c:	0a 9c       	mov	r12,r5
80007b9e:	e0 a0 0f 5d 	rcall	80009a58 <__swsetup_r>
80007ba2:	e0 81 0f 54 	brne	80009a4a <_vfprintf_r+0x1f06>
80007ba6:	82 68       	ld.sh	r8,r1[0xc]
80007ba8:	10 99       	mov	r9,r8
80007baa:	e2 19 00 1a 	andl	r9,0x1a,COH
80007bae:	58 a9       	cp.w	r9,10
80007bb0:	c3 c1       	brne	80007c28 <_vfprintf_r+0xe4>
80007bb2:	82 79       	ld.sh	r9,r1[0xe]
80007bb4:	30 0a       	mov	r10,0
80007bb6:	f4 09 19 00 	cp.h	r9,r10
80007bba:	c3 75       	brlt	80007c28 <_vfprintf_r+0xe4>
80007bbc:	a1 d8       	cbr	r8,0x1
80007bbe:	fb 58 05 d0 	st.h	sp[1488],r8
80007bc2:	62 88       	ld.w	r8,r1[0x20]
80007bc4:	fb 48 05 e4 	st.w	sp[1508],r8
80007bc8:	62 a8       	ld.w	r8,r1[0x28]
80007bca:	fb 48 05 ec 	st.w	sp[1516],r8
80007bce:	fa c8 ff bc 	sub	r8,sp,-68
80007bd2:	fb 48 05 d4 	st.w	sp[1492],r8
80007bd6:	fb 48 05 c4 	st.w	sp[1476],r8
80007bda:	e0 68 04 00 	mov	r8,1024
80007bde:	fb 48 05 d8 	st.w	sp[1496],r8
80007be2:	fb 48 05 cc 	st.w	sp[1484],r8
80007be6:	30 08       	mov	r8,0
80007be8:	fb 59 05 d2 	st.h	sp[1490],r9
80007bec:	0e 9a       	mov	r10,r7
80007bee:	41 09       	lddsp	r9,sp[0x40]
80007bf0:	fa c7 fa 3c 	sub	r7,sp,-1476
80007bf4:	fb 48 05 dc 	st.w	sp[1500],r8
80007bf8:	0a 9c       	mov	r12,r5
80007bfa:	0e 9b       	mov	r11,r7
80007bfc:	ca 4f       	rcall	80007b44 <_vfprintf_r>
80007bfe:	50 bc       	stdsp	sp[0x2c],r12
80007c00:	c0 95       	brlt	80007c12 <_vfprintf_r+0xce>
80007c02:	0e 9b       	mov	r11,r7
80007c04:	0a 9c       	mov	r12,r5
80007c06:	e0 a0 16 1b 	rcall	8000a83c <_fflush_r>
80007c0a:	40 be       	lddsp	lr,sp[0x2c]
80007c0c:	f9 be 01 ff 	movne	lr,-1
80007c10:	50 be       	stdsp	sp[0x2c],lr
80007c12:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007c16:	ed b8 00 06 	bld	r8,0x6
80007c1a:	e0 81 0f 1a 	brne	80009a4e <_vfprintf_r+0x1f0a>
80007c1e:	82 68       	ld.sh	r8,r1[0xc]
80007c20:	a7 a8       	sbr	r8,0x6
80007c22:	a2 68       	st.h	r1[0xc],r8
80007c24:	e0 8f 0f 15 	bral	80009a4e <_vfprintf_r+0x1f0a>
80007c28:	30 08       	mov	r8,0
80007c2a:	fb 48 06 b4 	st.w	sp[1716],r8
80007c2e:	fb 48 06 90 	st.w	sp[1680],r8
80007c32:	fb 48 06 8c 	st.w	sp[1676],r8
80007c36:	fb 48 06 b0 	st.w	sp[1712],r8
80007c3a:	30 08       	mov	r8,0
80007c3c:	30 09       	mov	r9,0
80007c3e:	50 a7       	stdsp	sp[0x28],r7
80007c40:	50 78       	stdsp	sp[0x1c],r8
80007c42:	fa c3 f9 e0 	sub	r3,sp,-1568
80007c46:	3f f8       	mov	r8,-1
80007c48:	50 59       	stdsp	sp[0x14],r9
80007c4a:	fb 43 06 88 	st.w	sp[1672],r3
80007c4e:	fb 48 05 44 	st.w	sp[1348],r8
80007c52:	12 9c       	mov	r12,r9
80007c54:	50 69       	stdsp	sp[0x18],r9
80007c56:	50 d9       	stdsp	sp[0x34],r9
80007c58:	50 e9       	stdsp	sp[0x38],r9
80007c5a:	50 b9       	stdsp	sp[0x2c],r9
80007c5c:	12 97       	mov	r7,r9
80007c5e:	0a 94       	mov	r4,r5
80007c60:	40 a2       	lddsp	r2,sp[0x28]
80007c62:	32 5a       	mov	r10,37
80007c64:	30 08       	mov	r8,0
80007c66:	c0 28       	rjmp	80007c6a <_vfprintf_r+0x126>
80007c68:	2f f2       	sub	r2,-1
80007c6a:	05 89       	ld.ub	r9,r2[0x0]
80007c6c:	f0 09 18 00 	cp.b	r9,r8
80007c70:	5f 1b       	srne	r11
80007c72:	f4 09 18 00 	cp.b	r9,r10
80007c76:	5f 19       	srne	r9
80007c78:	f3 eb 00 0b 	and	r11,r9,r11
80007c7c:	f0 0b 18 00 	cp.b	r11,r8
80007c80:	cf 41       	brne	80007c68 <_vfprintf_r+0x124>
80007c82:	40 ab       	lddsp	r11,sp[0x28]
80007c84:	e4 0b 01 06 	sub	r6,r2,r11
80007c88:	c1 e0       	breq	80007cc4 <_vfprintf_r+0x180>
80007c8a:	fa f8 06 90 	ld.w	r8,sp[1680]
80007c8e:	0c 08       	add	r8,r6
80007c90:	87 0b       	st.w	r3[0x0],r11
80007c92:	fb 48 06 90 	st.w	sp[1680],r8
80007c96:	87 16       	st.w	r3[0x4],r6
80007c98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007c9c:	2f f8       	sub	r8,-1
80007c9e:	fb 48 06 8c 	st.w	sp[1676],r8
80007ca2:	58 78       	cp.w	r8,7
80007ca4:	e0 89 00 04 	brgt	80007cac <_vfprintf_r+0x168>
80007ca8:	2f 83       	sub	r3,-8
80007caa:	c0 a8       	rjmp	80007cbe <_vfprintf_r+0x17a>
80007cac:	fa ca f9 78 	sub	r10,sp,-1672
80007cb0:	02 9b       	mov	r11,r1
80007cb2:	08 9c       	mov	r12,r4
80007cb4:	c3 af       	rcall	80007b28 <__sprint_r>
80007cb6:	e0 81 0e c6 	brne	80009a42 <_vfprintf_r+0x1efe>
80007cba:	fa c3 f9 e0 	sub	r3,sp,-1568
80007cbe:	40 ba       	lddsp	r10,sp[0x2c]
80007cc0:	0c 0a       	add	r10,r6
80007cc2:	50 ba       	stdsp	sp[0x2c],r10
80007cc4:	05 89       	ld.ub	r9,r2[0x0]
80007cc6:	30 08       	mov	r8,0
80007cc8:	f0 09 18 00 	cp.b	r9,r8
80007ccc:	e0 80 0e aa 	breq	80009a20 <_vfprintf_r+0x1edc>
80007cd0:	30 09       	mov	r9,0
80007cd2:	fb 68 06 bb 	st.b	sp[1723],r8
80007cd6:	0e 96       	mov	r6,r7
80007cd8:	e4 c8 ff ff 	sub	r8,r2,-1
80007cdc:	3f fe       	mov	lr,-1
80007cde:	50 93       	stdsp	sp[0x24],r3
80007ce0:	50 41       	stdsp	sp[0x10],r1
80007ce2:	0e 93       	mov	r3,r7
80007ce4:	04 91       	mov	r1,r2
80007ce6:	50 89       	stdsp	sp[0x20],r9
80007ce8:	50 a8       	stdsp	sp[0x28],r8
80007cea:	50 2e       	stdsp	sp[0x8],lr
80007cec:	50 39       	stdsp	sp[0xc],r9
80007cee:	12 95       	mov	r5,r9
80007cf0:	12 90       	mov	r0,r9
80007cf2:	10 97       	mov	r7,r8
80007cf4:	08 92       	mov	r2,r4
80007cf6:	c0 78       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007cf8:	3f fc       	mov	r12,-1
80007cfa:	08 97       	mov	r7,r4
80007cfc:	50 2c       	stdsp	sp[0x8],r12
80007cfe:	c0 38       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007d00:	30 0b       	mov	r11,0
80007d02:	50 3b       	stdsp	sp[0xc],r11
80007d04:	0f 38       	ld.ub	r8,r7++
80007d06:	c0 28       	rjmp	80007d0a <_vfprintf_r+0x1c6>
80007d08:	12 90       	mov	r0,r9
80007d0a:	f0 c9 00 20 	sub	r9,r8,32
80007d0e:	e0 49 00 58 	cp.w	r9,88
80007d12:	e0 8b 0a 30 	brhi	80009172 <_vfprintf_r+0x162e>
80007d16:	fe ca a5 fe 	sub	r10,pc,-23042
80007d1a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007d1e:	50 a7       	stdsp	sp[0x28],r7
80007d20:	50 80       	stdsp	sp[0x20],r0
80007d22:	0c 97       	mov	r7,r6
80007d24:	04 94       	mov	r4,r2
80007d26:	06 96       	mov	r6,r3
80007d28:	02 92       	mov	r2,r1
80007d2a:	fe c9 a3 d6 	sub	r9,pc,-23594
80007d2e:	40 93       	lddsp	r3,sp[0x24]
80007d30:	10 90       	mov	r0,r8
80007d32:	40 41       	lddsp	r1,sp[0x10]
80007d34:	50 d9       	stdsp	sp[0x34],r9
80007d36:	e0 8f 08 8e 	bral	80008e52 <_vfprintf_r+0x130e>
80007d3a:	30 08       	mov	r8,0
80007d3c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007d40:	f0 09 18 00 	cp.b	r9,r8
80007d44:	ce 01       	brne	80007d04 <_vfprintf_r+0x1c0>
80007d46:	32 08       	mov	r8,32
80007d48:	c6 e8       	rjmp	80007e24 <_vfprintf_r+0x2e0>
80007d4a:	a1 a5       	sbr	r5,0x0
80007d4c:	cd cb       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007d4e:	0f 89       	ld.ub	r9,r7[0x0]
80007d50:	f2 c8 00 30 	sub	r8,r9,48
80007d54:	58 98       	cp.w	r8,9
80007d56:	e0 8b 00 1d 	brhi	80007d90 <_vfprintf_r+0x24c>
80007d5a:	ee c8 ff ff 	sub	r8,r7,-1
80007d5e:	30 0b       	mov	r11,0
80007d60:	23 09       	sub	r9,48
80007d62:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007d66:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007d6a:	11 39       	ld.ub	r9,r8++
80007d6c:	f2 ca 00 30 	sub	r10,r9,48
80007d70:	58 9a       	cp.w	r10,9
80007d72:	fe 98 ff f7 	brls	80007d60 <_vfprintf_r+0x21c>
80007d76:	e0 49 00 24 	cp.w	r9,36
80007d7a:	cc 31       	brne	80007d00 <_vfprintf_r+0x1bc>
80007d7c:	e0 4b 00 20 	cp.w	r11,32
80007d80:	e0 89 0e 60 	brgt	80009a40 <_vfprintf_r+0x1efc>
80007d84:	20 1b       	sub	r11,1
80007d86:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d8a:	12 3b       	cp.w	r11,r9
80007d8c:	c0 95       	brlt	80007d9e <_vfprintf_r+0x25a>
80007d8e:	c1 08       	rjmp	80007dae <_vfprintf_r+0x26a>
80007d90:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007d94:	ec ca ff ff 	sub	r10,r6,-1
80007d98:	12 36       	cp.w	r6,r9
80007d9a:	c1 f5       	brlt	80007dd8 <_vfprintf_r+0x294>
80007d9c:	c2 68       	rjmp	80007de8 <_vfprintf_r+0x2a4>
80007d9e:	fa ce f9 44 	sub	lr,sp,-1724
80007da2:	10 97       	mov	r7,r8
80007da4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007da8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007dac:	c3 58       	rjmp	80007e16 <_vfprintf_r+0x2d2>
80007dae:	10 97       	mov	r7,r8
80007db0:	fa c8 f9 50 	sub	r8,sp,-1712
80007db4:	1a d8       	st.w	--sp,r8
80007db6:	fa c8 fa b8 	sub	r8,sp,-1352
80007dba:	1a d8       	st.w	--sp,r8
80007dbc:	fa c8 fb b4 	sub	r8,sp,-1100
80007dc0:	02 9a       	mov	r10,r1
80007dc2:	1a d8       	st.w	--sp,r8
80007dc4:	04 9c       	mov	r12,r2
80007dc6:	fa c8 f9 40 	sub	r8,sp,-1728
80007dca:	fa c9 ff b4 	sub	r9,sp,-76
80007dce:	fe b0 fd 23 	rcall	80007814 <get_arg>
80007dd2:	2f dd       	sub	sp,-12
80007dd4:	78 00       	ld.w	r0,r12[0x0]
80007dd6:	c2 08       	rjmp	80007e16 <_vfprintf_r+0x2d2>
80007dd8:	fa cc f9 44 	sub	r12,sp,-1724
80007ddc:	14 96       	mov	r6,r10
80007dde:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007de2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007de6:	c1 88       	rjmp	80007e16 <_vfprintf_r+0x2d2>
80007de8:	41 08       	lddsp	r8,sp[0x40]
80007dea:	59 f9       	cp.w	r9,31
80007dec:	e0 89 00 11 	brgt	80007e0e <_vfprintf_r+0x2ca>
80007df0:	f0 cb ff fc 	sub	r11,r8,-4
80007df4:	51 0b       	stdsp	sp[0x40],r11
80007df6:	70 00       	ld.w	r0,r8[0x0]
80007df8:	fa cb f9 44 	sub	r11,sp,-1724
80007dfc:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007e00:	f1 40 fd 88 	st.w	r8[-632],r0
80007e04:	2f f9       	sub	r9,-1
80007e06:	14 96       	mov	r6,r10
80007e08:	fb 49 06 b4 	st.w	sp[1716],r9
80007e0c:	c0 58       	rjmp	80007e16 <_vfprintf_r+0x2d2>
80007e0e:	70 00       	ld.w	r0,r8[0x0]
80007e10:	14 96       	mov	r6,r10
80007e12:	2f c8       	sub	r8,-4
80007e14:	51 08       	stdsp	sp[0x40],r8
80007e16:	58 00       	cp.w	r0,0
80007e18:	fe 94 ff 76 	brge	80007d04 <_vfprintf_r+0x1c0>
80007e1c:	5c 30       	neg	r0
80007e1e:	a3 a5       	sbr	r5,0x2
80007e20:	c7 2b       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007e22:	32 b8       	mov	r8,43
80007e24:	fb 68 06 bb 	st.b	sp[1723],r8
80007e28:	c6 eb       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007e2a:	0f 38       	ld.ub	r8,r7++
80007e2c:	e0 48 00 2a 	cp.w	r8,42
80007e30:	c0 30       	breq	80007e36 <_vfprintf_r+0x2f2>
80007e32:	30 09       	mov	r9,0
80007e34:	c7 98       	rjmp	80007f26 <_vfprintf_r+0x3e2>
80007e36:	0f 88       	ld.ub	r8,r7[0x0]
80007e38:	f0 c9 00 30 	sub	r9,r8,48
80007e3c:	58 99       	cp.w	r9,9
80007e3e:	e0 8b 00 1f 	brhi	80007e7c <_vfprintf_r+0x338>
80007e42:	ee c4 ff ff 	sub	r4,r7,-1
80007e46:	30 0b       	mov	r11,0
80007e48:	23 08       	sub	r8,48
80007e4a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007e4e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007e52:	09 38       	ld.ub	r8,r4++
80007e54:	f0 c9 00 30 	sub	r9,r8,48
80007e58:	58 99       	cp.w	r9,9
80007e5a:	fe 98 ff f7 	brls	80007e48 <_vfprintf_r+0x304>
80007e5e:	e0 48 00 24 	cp.w	r8,36
80007e62:	fe 91 ff 4f 	brne	80007d00 <_vfprintf_r+0x1bc>
80007e66:	e0 4b 00 20 	cp.w	r11,32
80007e6a:	e0 89 0d eb 	brgt	80009a40 <_vfprintf_r+0x1efc>
80007e6e:	20 1b       	sub	r11,1
80007e70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e74:	10 3b       	cp.w	r11,r8
80007e76:	c0 a5       	brlt	80007e8a <_vfprintf_r+0x346>
80007e78:	c1 18       	rjmp	80007e9a <_vfprintf_r+0x356>
80007e7a:	d7 03       	nop
80007e7c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007e80:	ec c9 ff ff 	sub	r9,r6,-1
80007e84:	14 36       	cp.w	r6,r10
80007e86:	c1 f5       	brlt	80007ec4 <_vfprintf_r+0x380>
80007e88:	c2 88       	rjmp	80007ed8 <_vfprintf_r+0x394>
80007e8a:	fa ca f9 44 	sub	r10,sp,-1724
80007e8e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007e92:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007e96:	50 2b       	stdsp	sp[0x8],r11
80007e98:	c3 c8       	rjmp	80007f10 <_vfprintf_r+0x3cc>
80007e9a:	fa c8 f9 50 	sub	r8,sp,-1712
80007e9e:	1a d8       	st.w	--sp,r8
80007ea0:	fa c8 fa b8 	sub	r8,sp,-1352
80007ea4:	1a d8       	st.w	--sp,r8
80007ea6:	fa c8 fb b4 	sub	r8,sp,-1100
80007eaa:	02 9a       	mov	r10,r1
80007eac:	1a d8       	st.w	--sp,r8
80007eae:	04 9c       	mov	r12,r2
80007eb0:	fa c8 f9 40 	sub	r8,sp,-1728
80007eb4:	fa c9 ff b4 	sub	r9,sp,-76
80007eb8:	fe b0 fc ae 	rcall	80007814 <get_arg>
80007ebc:	2f dd       	sub	sp,-12
80007ebe:	78 0c       	ld.w	r12,r12[0x0]
80007ec0:	50 2c       	stdsp	sp[0x8],r12
80007ec2:	c2 78       	rjmp	80007f10 <_vfprintf_r+0x3cc>
80007ec4:	12 96       	mov	r6,r9
80007ec6:	0e 94       	mov	r4,r7
80007ec8:	fa c9 f9 44 	sub	r9,sp,-1724
80007ecc:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007ed0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007ed4:	50 28       	stdsp	sp[0x8],r8
80007ed6:	c1 d8       	rjmp	80007f10 <_vfprintf_r+0x3cc>
80007ed8:	41 08       	lddsp	r8,sp[0x40]
80007eda:	59 fa       	cp.w	r10,31
80007edc:	e0 89 00 14 	brgt	80007f04 <_vfprintf_r+0x3c0>
80007ee0:	f0 cb ff fc 	sub	r11,r8,-4
80007ee4:	70 08       	ld.w	r8,r8[0x0]
80007ee6:	51 0b       	stdsp	sp[0x40],r11
80007ee8:	50 28       	stdsp	sp[0x8],r8
80007eea:	fa c6 f9 44 	sub	r6,sp,-1724
80007eee:	40 2e       	lddsp	lr,sp[0x8]
80007ef0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007ef4:	f1 4e fd 88 	st.w	r8[-632],lr
80007ef8:	2f fa       	sub	r10,-1
80007efa:	0e 94       	mov	r4,r7
80007efc:	fb 4a 06 b4 	st.w	sp[1716],r10
80007f00:	12 96       	mov	r6,r9
80007f02:	c0 78       	rjmp	80007f10 <_vfprintf_r+0x3cc>
80007f04:	70 0c       	ld.w	r12,r8[0x0]
80007f06:	0e 94       	mov	r4,r7
80007f08:	2f c8       	sub	r8,-4
80007f0a:	50 2c       	stdsp	sp[0x8],r12
80007f0c:	12 96       	mov	r6,r9
80007f0e:	51 08       	stdsp	sp[0x40],r8
80007f10:	40 2b       	lddsp	r11,sp[0x8]
80007f12:	58 0b       	cp.w	r11,0
80007f14:	fe 95 fe f2 	brlt	80007cf8 <_vfprintf_r+0x1b4>
80007f18:	08 97       	mov	r7,r4
80007f1a:	cf 5a       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007f1c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f20:	0f 38       	ld.ub	r8,r7++
80007f22:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007f26:	f0 ca 00 30 	sub	r10,r8,48
80007f2a:	58 9a       	cp.w	r10,9
80007f2c:	fe 98 ff f8 	brls	80007f1c <_vfprintf_r+0x3d8>
80007f30:	3f fa       	mov	r10,-1
80007f32:	f2 0a 0c 49 	max	r9,r9,r10
80007f36:	50 29       	stdsp	sp[0x8],r9
80007f38:	ce 9a       	rjmp	80007d0a <_vfprintf_r+0x1c6>
80007f3a:	a7 b5       	sbr	r5,0x7
80007f3c:	ce 4a       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007f3e:	30 09       	mov	r9,0
80007f40:	23 08       	sub	r8,48
80007f42:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007f46:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007f4a:	0f 38       	ld.ub	r8,r7++
80007f4c:	f0 ca 00 30 	sub	r10,r8,48
80007f50:	58 9a       	cp.w	r10,9
80007f52:	fe 98 ff f7 	brls	80007f40 <_vfprintf_r+0x3fc>
80007f56:	e0 48 00 24 	cp.w	r8,36
80007f5a:	fe 91 fe d7 	brne	80007d08 <_vfprintf_r+0x1c4>
80007f5e:	e0 49 00 20 	cp.w	r9,32
80007f62:	e0 89 0d 6f 	brgt	80009a40 <_vfprintf_r+0x1efc>
80007f66:	f2 c3 00 01 	sub	r3,r9,1
80007f6a:	30 19       	mov	r9,1
80007f6c:	50 39       	stdsp	sp[0xc],r9
80007f6e:	cc ba       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007f70:	a3 b5       	sbr	r5,0x3
80007f72:	cc 9a       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007f74:	a7 a5       	sbr	r5,0x6
80007f76:	cc 7a       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007f78:	0a 98       	mov	r8,r5
80007f7a:	a5 b5       	sbr	r5,0x5
80007f7c:	a5 a8       	sbr	r8,0x4
80007f7e:	0f 89       	ld.ub	r9,r7[0x0]
80007f80:	36 ce       	mov	lr,108
80007f82:	fc 09 18 00 	cp.b	r9,lr
80007f86:	f7 b7 00 ff 	subeq	r7,-1
80007f8a:	f0 05 17 10 	movne	r5,r8
80007f8e:	cb ba       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007f90:	a5 b5       	sbr	r5,0x5
80007f92:	cb 9a       	rjmp	80007d04 <_vfprintf_r+0x1c0>
80007f94:	50 a7       	stdsp	sp[0x28],r7
80007f96:	50 80       	stdsp	sp[0x20],r0
80007f98:	0c 97       	mov	r7,r6
80007f9a:	10 90       	mov	r0,r8
80007f9c:	06 96       	mov	r6,r3
80007f9e:	04 94       	mov	r4,r2
80007fa0:	40 93       	lddsp	r3,sp[0x24]
80007fa2:	02 92       	mov	r2,r1
80007fa4:	0e 99       	mov	r9,r7
80007fa6:	40 41       	lddsp	r1,sp[0x10]
80007fa8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fac:	40 3c       	lddsp	r12,sp[0xc]
80007fae:	58 0c       	cp.w	r12,0
80007fb0:	c1 d0       	breq	80007fea <_vfprintf_r+0x4a6>
80007fb2:	10 36       	cp.w	r6,r8
80007fb4:	c0 64       	brge	80007fc0 <_vfprintf_r+0x47c>
80007fb6:	fa cb f9 44 	sub	r11,sp,-1724
80007fba:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fbe:	c1 d8       	rjmp	80007ff8 <_vfprintf_r+0x4b4>
80007fc0:	fa c8 f9 50 	sub	r8,sp,-1712
80007fc4:	1a d8       	st.w	--sp,r8
80007fc6:	fa c8 fa b8 	sub	r8,sp,-1352
80007fca:	1a d8       	st.w	--sp,r8
80007fcc:	fa c8 fb b4 	sub	r8,sp,-1100
80007fd0:	1a d8       	st.w	--sp,r8
80007fd2:	fa c8 f9 40 	sub	r8,sp,-1728
80007fd6:	fa c9 ff b4 	sub	r9,sp,-76
80007fda:	04 9a       	mov	r10,r2
80007fdc:	0c 9b       	mov	r11,r6
80007fde:	08 9c       	mov	r12,r4
80007fe0:	fe b0 fc 1a 	rcall	80007814 <get_arg>
80007fe4:	2f dd       	sub	sp,-12
80007fe6:	19 b8       	ld.ub	r8,r12[0x3]
80007fe8:	c2 28       	rjmp	8000802c <_vfprintf_r+0x4e8>
80007fea:	2f f7       	sub	r7,-1
80007fec:	10 39       	cp.w	r9,r8
80007fee:	c0 84       	brge	80007ffe <_vfprintf_r+0x4ba>
80007ff0:	fa ca f9 44 	sub	r10,sp,-1724
80007ff4:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007ff8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007ffc:	c1 88       	rjmp	8000802c <_vfprintf_r+0x4e8>
80007ffe:	41 09       	lddsp	r9,sp[0x40]
80008000:	59 f8       	cp.w	r8,31
80008002:	e0 89 00 12 	brgt	80008026 <_vfprintf_r+0x4e2>
80008006:	f2 ca ff fc 	sub	r10,r9,-4
8000800a:	51 0a       	stdsp	sp[0x40],r10
8000800c:	72 09       	ld.w	r9,r9[0x0]
8000800e:	fa c6 f9 44 	sub	r6,sp,-1724
80008012:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008016:	2f f8       	sub	r8,-1
80008018:	f5 49 fd 88 	st.w	r10[-632],r9
8000801c:	fb 48 06 b4 	st.w	sp[1716],r8
80008020:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008024:	c0 48       	rjmp	8000802c <_vfprintf_r+0x4e8>
80008026:	13 b8       	ld.ub	r8,r9[0x3]
80008028:	2f c9       	sub	r9,-4
8000802a:	51 09       	stdsp	sp[0x40],r9
8000802c:	fb 68 06 60 	st.b	sp[1632],r8
80008030:	30 0e       	mov	lr,0
80008032:	30 08       	mov	r8,0
80008034:	30 12       	mov	r2,1
80008036:	fb 68 06 bb 	st.b	sp[1723],r8
8000803a:	50 2e       	stdsp	sp[0x8],lr
8000803c:	e0 8f 08 ad 	bral	80009196 <_vfprintf_r+0x1652>
80008040:	50 a7       	stdsp	sp[0x28],r7
80008042:	50 80       	stdsp	sp[0x20],r0
80008044:	0c 97       	mov	r7,r6
80008046:	04 94       	mov	r4,r2
80008048:	06 96       	mov	r6,r3
8000804a:	02 92       	mov	r2,r1
8000804c:	40 93       	lddsp	r3,sp[0x24]
8000804e:	10 90       	mov	r0,r8
80008050:	40 41       	lddsp	r1,sp[0x10]
80008052:	a5 a5       	sbr	r5,0x4
80008054:	c0 a8       	rjmp	80008068 <_vfprintf_r+0x524>
80008056:	50 a7       	stdsp	sp[0x28],r7
80008058:	50 80       	stdsp	sp[0x20],r0
8000805a:	0c 97       	mov	r7,r6
8000805c:	04 94       	mov	r4,r2
8000805e:	06 96       	mov	r6,r3
80008060:	02 92       	mov	r2,r1
80008062:	40 93       	lddsp	r3,sp[0x24]
80008064:	10 90       	mov	r0,r8
80008066:	40 41       	lddsp	r1,sp[0x10]
80008068:	ed b5 00 05 	bld	r5,0x5
8000806c:	c5 11       	brne	8000810e <_vfprintf_r+0x5ca>
8000806e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008072:	40 3c       	lddsp	r12,sp[0xc]
80008074:	58 0c       	cp.w	r12,0
80008076:	c1 e0       	breq	800080b2 <_vfprintf_r+0x56e>
80008078:	10 36       	cp.w	r6,r8
8000807a:	c0 64       	brge	80008086 <_vfprintf_r+0x542>
8000807c:	fa cb f9 44 	sub	r11,sp,-1724
80008080:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008084:	c2 08       	rjmp	800080c4 <_vfprintf_r+0x580>
80008086:	fa c8 f9 50 	sub	r8,sp,-1712
8000808a:	1a d8       	st.w	--sp,r8
8000808c:	fa c8 fa b8 	sub	r8,sp,-1352
80008090:	0c 9b       	mov	r11,r6
80008092:	1a d8       	st.w	--sp,r8
80008094:	fa c8 fb b4 	sub	r8,sp,-1100
80008098:	1a d8       	st.w	--sp,r8
8000809a:	fa c9 ff b4 	sub	r9,sp,-76
8000809e:	fa c8 f9 40 	sub	r8,sp,-1728
800080a2:	04 9a       	mov	r10,r2
800080a4:	08 9c       	mov	r12,r4
800080a6:	fe b0 fb b7 	rcall	80007814 <get_arg>
800080aa:	2f dd       	sub	sp,-12
800080ac:	78 1b       	ld.w	r11,r12[0x4]
800080ae:	78 09       	ld.w	r9,r12[0x0]
800080b0:	c2 b8       	rjmp	80008106 <_vfprintf_r+0x5c2>
800080b2:	ee ca ff ff 	sub	r10,r7,-1
800080b6:	10 37       	cp.w	r7,r8
800080b8:	c0 b4       	brge	800080ce <_vfprintf_r+0x58a>
800080ba:	fa c9 f9 44 	sub	r9,sp,-1724
800080be:	14 97       	mov	r7,r10
800080c0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080c4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800080c8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800080cc:	c1 d8       	rjmp	80008106 <_vfprintf_r+0x5c2>
800080ce:	41 09       	lddsp	r9,sp[0x40]
800080d0:	59 f8       	cp.w	r8,31
800080d2:	e0 89 00 14 	brgt	800080fa <_vfprintf_r+0x5b6>
800080d6:	f2 cb ff f8 	sub	r11,r9,-8
800080da:	51 0b       	stdsp	sp[0x40],r11
800080dc:	fa c6 f9 44 	sub	r6,sp,-1724
800080e0:	72 1b       	ld.w	r11,r9[0x4]
800080e2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800080e6:	72 09       	ld.w	r9,r9[0x0]
800080e8:	f9 4b fd 8c 	st.w	r12[-628],r11
800080ec:	f9 49 fd 88 	st.w	r12[-632],r9
800080f0:	2f f8       	sub	r8,-1
800080f2:	14 97       	mov	r7,r10
800080f4:	fb 48 06 b4 	st.w	sp[1716],r8
800080f8:	c0 78       	rjmp	80008106 <_vfprintf_r+0x5c2>
800080fa:	f2 c8 ff f8 	sub	r8,r9,-8
800080fe:	72 1b       	ld.w	r11,r9[0x4]
80008100:	14 97       	mov	r7,r10
80008102:	51 08       	stdsp	sp[0x40],r8
80008104:	72 09       	ld.w	r9,r9[0x0]
80008106:	16 98       	mov	r8,r11
80008108:	fa e9 00 00 	st.d	sp[0],r8
8000810c:	ca e8       	rjmp	80008268 <_vfprintf_r+0x724>
8000810e:	ed b5 00 04 	bld	r5,0x4
80008112:	c1 71       	brne	80008140 <_vfprintf_r+0x5fc>
80008114:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008118:	40 3e       	lddsp	lr,sp[0xc]
8000811a:	58 0e       	cp.w	lr,0
8000811c:	c0 80       	breq	8000812c <_vfprintf_r+0x5e8>
8000811e:	10 36       	cp.w	r6,r8
80008120:	c6 94       	brge	800081f2 <_vfprintf_r+0x6ae>
80008122:	fa cc f9 44 	sub	r12,sp,-1724
80008126:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000812a:	c8 28       	rjmp	8000822e <_vfprintf_r+0x6ea>
8000812c:	ee ca ff ff 	sub	r10,r7,-1
80008130:	10 37       	cp.w	r7,r8
80008132:	e0 84 00 81 	brge	80008234 <_vfprintf_r+0x6f0>
80008136:	fa cb f9 44 	sub	r11,sp,-1724
8000813a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000813e:	c7 78       	rjmp	8000822c <_vfprintf_r+0x6e8>
80008140:	ed b5 00 06 	bld	r5,0x6
80008144:	c4 b1       	brne	800081da <_vfprintf_r+0x696>
80008146:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000814a:	40 3c       	lddsp	r12,sp[0xc]
8000814c:	58 0c       	cp.w	r12,0
8000814e:	c1 d0       	breq	80008188 <_vfprintf_r+0x644>
80008150:	10 36       	cp.w	r6,r8
80008152:	c0 64       	brge	8000815e <_vfprintf_r+0x61a>
80008154:	fa cb f9 44 	sub	r11,sp,-1724
80008158:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000815c:	c1 f8       	rjmp	8000819a <_vfprintf_r+0x656>
8000815e:	fa c8 f9 50 	sub	r8,sp,-1712
80008162:	1a d8       	st.w	--sp,r8
80008164:	fa c8 fa b8 	sub	r8,sp,-1352
80008168:	1a d8       	st.w	--sp,r8
8000816a:	fa c8 fb b4 	sub	r8,sp,-1100
8000816e:	1a d8       	st.w	--sp,r8
80008170:	fa c8 f9 40 	sub	r8,sp,-1728
80008174:	fa c9 ff b4 	sub	r9,sp,-76
80008178:	04 9a       	mov	r10,r2
8000817a:	0c 9b       	mov	r11,r6
8000817c:	08 9c       	mov	r12,r4
8000817e:	fe b0 fb 4b 	rcall	80007814 <get_arg>
80008182:	2f dd       	sub	sp,-12
80008184:	98 18       	ld.sh	r8,r12[0x2]
80008186:	c2 68       	rjmp	800081d2 <_vfprintf_r+0x68e>
80008188:	ee ca ff ff 	sub	r10,r7,-1
8000818c:	10 37       	cp.w	r7,r8
8000818e:	c0 94       	brge	800081a0 <_vfprintf_r+0x65c>
80008190:	fa c9 f9 44 	sub	r9,sp,-1724
80008194:	14 97       	mov	r7,r10
80008196:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000819a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000819e:	c1 a8       	rjmp	800081d2 <_vfprintf_r+0x68e>
800081a0:	41 09       	lddsp	r9,sp[0x40]
800081a2:	59 f8       	cp.w	r8,31
800081a4:	e0 89 00 13 	brgt	800081ca <_vfprintf_r+0x686>
800081a8:	f2 cb ff fc 	sub	r11,r9,-4
800081ac:	51 0b       	stdsp	sp[0x40],r11
800081ae:	72 09       	ld.w	r9,r9[0x0]
800081b0:	fa c6 f9 44 	sub	r6,sp,-1724
800081b4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800081b8:	2f f8       	sub	r8,-1
800081ba:	f7 49 fd 88 	st.w	r11[-632],r9
800081be:	fb 48 06 b4 	st.w	sp[1716],r8
800081c2:	14 97       	mov	r7,r10
800081c4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800081c8:	c0 58       	rjmp	800081d2 <_vfprintf_r+0x68e>
800081ca:	92 18       	ld.sh	r8,r9[0x2]
800081cc:	14 97       	mov	r7,r10
800081ce:	2f c9       	sub	r9,-4
800081d0:	51 09       	stdsp	sp[0x40],r9
800081d2:	50 18       	stdsp	sp[0x4],r8
800081d4:	bf 58       	asr	r8,0x1f
800081d6:	50 08       	stdsp	sp[0x0],r8
800081d8:	c4 88       	rjmp	80008268 <_vfprintf_r+0x724>
800081da:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081de:	40 3c       	lddsp	r12,sp[0xc]
800081e0:	58 0c       	cp.w	r12,0
800081e2:	c1 d0       	breq	8000821c <_vfprintf_r+0x6d8>
800081e4:	10 36       	cp.w	r6,r8
800081e6:	c0 64       	brge	800081f2 <_vfprintf_r+0x6ae>
800081e8:	fa cb f9 44 	sub	r11,sp,-1724
800081ec:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081f0:	c1 f8       	rjmp	8000822e <_vfprintf_r+0x6ea>
800081f2:	fa c8 f9 50 	sub	r8,sp,-1712
800081f6:	1a d8       	st.w	--sp,r8
800081f8:	fa c8 fa b8 	sub	r8,sp,-1352
800081fc:	0c 9b       	mov	r11,r6
800081fe:	1a d8       	st.w	--sp,r8
80008200:	fa c8 fb b4 	sub	r8,sp,-1100
80008204:	04 9a       	mov	r10,r2
80008206:	1a d8       	st.w	--sp,r8
80008208:	08 9c       	mov	r12,r4
8000820a:	fa c8 f9 40 	sub	r8,sp,-1728
8000820e:	fa c9 ff b4 	sub	r9,sp,-76
80008212:	fe b0 fb 01 	rcall	80007814 <get_arg>
80008216:	2f dd       	sub	sp,-12
80008218:	78 0b       	ld.w	r11,r12[0x0]
8000821a:	c2 48       	rjmp	80008262 <_vfprintf_r+0x71e>
8000821c:	ee ca ff ff 	sub	r10,r7,-1
80008220:	10 37       	cp.w	r7,r8
80008222:	c0 94       	brge	80008234 <_vfprintf_r+0x6f0>
80008224:	fa c9 f9 44 	sub	r9,sp,-1724
80008228:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000822c:	14 97       	mov	r7,r10
8000822e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008232:	c1 88       	rjmp	80008262 <_vfprintf_r+0x71e>
80008234:	41 09       	lddsp	r9,sp[0x40]
80008236:	59 f8       	cp.w	r8,31
80008238:	e0 89 00 11 	brgt	8000825a <_vfprintf_r+0x716>
8000823c:	f2 cb ff fc 	sub	r11,r9,-4
80008240:	51 0b       	stdsp	sp[0x40],r11
80008242:	fa c6 f9 44 	sub	r6,sp,-1724
80008246:	72 0b       	ld.w	r11,r9[0x0]
80008248:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000824c:	f3 4b fd 88 	st.w	r9[-632],r11
80008250:	2f f8       	sub	r8,-1
80008252:	14 97       	mov	r7,r10
80008254:	fb 48 06 b4 	st.w	sp[1716],r8
80008258:	c0 58       	rjmp	80008262 <_vfprintf_r+0x71e>
8000825a:	72 0b       	ld.w	r11,r9[0x0]
8000825c:	14 97       	mov	r7,r10
8000825e:	2f c9       	sub	r9,-4
80008260:	51 09       	stdsp	sp[0x40],r9
80008262:	50 1b       	stdsp	sp[0x4],r11
80008264:	bf 5b       	asr	r11,0x1f
80008266:	50 0b       	stdsp	sp[0x0],r11
80008268:	fa ea 00 00 	ld.d	r10,sp[0]
8000826c:	58 0a       	cp.w	r10,0
8000826e:	5c 2b       	cpc	r11
80008270:	c0 e4       	brge	8000828c <_vfprintf_r+0x748>
80008272:	30 08       	mov	r8,0
80008274:	fa ea 00 00 	ld.d	r10,sp[0]
80008278:	30 09       	mov	r9,0
8000827a:	f0 0a 01 0a 	sub	r10,r8,r10
8000827e:	f2 0b 01 4b 	sbc	r11,r9,r11
80008282:	32 d8       	mov	r8,45
80008284:	fa eb 00 00 	st.d	sp[0],r10
80008288:	fb 68 06 bb 	st.b	sp[1723],r8
8000828c:	30 18       	mov	r8,1
8000828e:	e0 8f 06 fa 	bral	80009082 <_vfprintf_r+0x153e>
80008292:	50 a7       	stdsp	sp[0x28],r7
80008294:	50 80       	stdsp	sp[0x20],r0
80008296:	0c 97       	mov	r7,r6
80008298:	04 94       	mov	r4,r2
8000829a:	06 96       	mov	r6,r3
8000829c:	02 92       	mov	r2,r1
8000829e:	40 93       	lddsp	r3,sp[0x24]
800082a0:	10 90       	mov	r0,r8
800082a2:	40 41       	lddsp	r1,sp[0x10]
800082a4:	0e 99       	mov	r9,r7
800082a6:	ed b5 00 03 	bld	r5,0x3
800082aa:	c4 11       	brne	8000832c <_vfprintf_r+0x7e8>
800082ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082b0:	40 3a       	lddsp	r10,sp[0xc]
800082b2:	58 0a       	cp.w	r10,0
800082b4:	c1 90       	breq	800082e6 <_vfprintf_r+0x7a2>
800082b6:	10 36       	cp.w	r6,r8
800082b8:	c6 45       	brlt	80008380 <_vfprintf_r+0x83c>
800082ba:	fa c8 f9 50 	sub	r8,sp,-1712
800082be:	1a d8       	st.w	--sp,r8
800082c0:	fa c8 fa b8 	sub	r8,sp,-1352
800082c4:	1a d8       	st.w	--sp,r8
800082c6:	fa c8 fb b4 	sub	r8,sp,-1100
800082ca:	0c 9b       	mov	r11,r6
800082cc:	1a d8       	st.w	--sp,r8
800082ce:	04 9a       	mov	r10,r2
800082d0:	fa c8 f9 40 	sub	r8,sp,-1728
800082d4:	fa c9 ff b4 	sub	r9,sp,-76
800082d8:	08 9c       	mov	r12,r4
800082da:	fe b0 fa 9d 	rcall	80007814 <get_arg>
800082de:	2f dd       	sub	sp,-12
800082e0:	78 16       	ld.w	r6,r12[0x4]
800082e2:	50 76       	stdsp	sp[0x1c],r6
800082e4:	c4 88       	rjmp	80008374 <_vfprintf_r+0x830>
800082e6:	2f f7       	sub	r7,-1
800082e8:	10 39       	cp.w	r9,r8
800082ea:	c0 c4       	brge	80008302 <_vfprintf_r+0x7be>
800082ec:	fa ce f9 44 	sub	lr,sp,-1724
800082f0:	fc 06 00 36 	add	r6,lr,r6<<0x3
800082f4:	ec fc fd 8c 	ld.w	r12,r6[-628]
800082f8:	50 7c       	stdsp	sp[0x1c],r12
800082fa:	ec f6 fd 88 	ld.w	r6,r6[-632]
800082fe:	50 56       	stdsp	sp[0x14],r6
80008300:	c6 68       	rjmp	800083cc <_vfprintf_r+0x888>
80008302:	41 09       	lddsp	r9,sp[0x40]
80008304:	59 f8       	cp.w	r8,31
80008306:	e0 89 00 10 	brgt	80008326 <_vfprintf_r+0x7e2>
8000830a:	f2 ca ff f8 	sub	r10,r9,-8
8000830e:	72 1b       	ld.w	r11,r9[0x4]
80008310:	51 0a       	stdsp	sp[0x40],r10
80008312:	72 09       	ld.w	r9,r9[0x0]
80008314:	fa ca f9 44 	sub	r10,sp,-1724
80008318:	50 7b       	stdsp	sp[0x1c],r11
8000831a:	50 59       	stdsp	sp[0x14],r9
8000831c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008320:	40 5b       	lddsp	r11,sp[0x14]
80008322:	40 7a       	lddsp	r10,sp[0x1c]
80008324:	c4 78       	rjmp	800083b2 <_vfprintf_r+0x86e>
80008326:	72 18       	ld.w	r8,r9[0x4]
80008328:	50 78       	stdsp	sp[0x1c],r8
8000832a:	c4 c8       	rjmp	800083c2 <_vfprintf_r+0x87e>
8000832c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008330:	40 3e       	lddsp	lr,sp[0xc]
80008332:	58 0e       	cp.w	lr,0
80008334:	c2 30       	breq	8000837a <_vfprintf_r+0x836>
80008336:	10 36       	cp.w	r6,r8
80008338:	c0 94       	brge	8000834a <_vfprintf_r+0x806>
8000833a:	fa cc f9 44 	sub	r12,sp,-1724
8000833e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008342:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008346:	50 7b       	stdsp	sp[0x1c],r11
80008348:	cd 9b       	rjmp	800082fa <_vfprintf_r+0x7b6>
8000834a:	fa c8 f9 50 	sub	r8,sp,-1712
8000834e:	1a d8       	st.w	--sp,r8
80008350:	fa c8 fa b8 	sub	r8,sp,-1352
80008354:	04 9a       	mov	r10,r2
80008356:	1a d8       	st.w	--sp,r8
80008358:	fa c8 fb b4 	sub	r8,sp,-1100
8000835c:	0c 9b       	mov	r11,r6
8000835e:	1a d8       	st.w	--sp,r8
80008360:	08 9c       	mov	r12,r4
80008362:	fa c8 f9 40 	sub	r8,sp,-1728
80008366:	fa c9 ff b4 	sub	r9,sp,-76
8000836a:	fe b0 fa 55 	rcall	80007814 <get_arg>
8000836e:	2f dd       	sub	sp,-12
80008370:	78 1a       	ld.w	r10,r12[0x4]
80008372:	50 7a       	stdsp	sp[0x1c],r10
80008374:	78 0c       	ld.w	r12,r12[0x0]
80008376:	50 5c       	stdsp	sp[0x14],r12
80008378:	c2 a8       	rjmp	800083cc <_vfprintf_r+0x888>
8000837a:	2f f7       	sub	r7,-1
8000837c:	10 39       	cp.w	r9,r8
8000837e:	c0 94       	brge	80008390 <_vfprintf_r+0x84c>
80008380:	fa c9 f9 44 	sub	r9,sp,-1724
80008384:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008388:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000838c:	50 78       	stdsp	sp[0x1c],r8
8000838e:	cb 6b       	rjmp	800082fa <_vfprintf_r+0x7b6>
80008390:	41 09       	lddsp	r9,sp[0x40]
80008392:	59 f8       	cp.w	r8,31
80008394:	e0 89 00 15 	brgt	800083be <_vfprintf_r+0x87a>
80008398:	f2 ca ff f8 	sub	r10,r9,-8
8000839c:	72 16       	ld.w	r6,r9[0x4]
8000839e:	72 09       	ld.w	r9,r9[0x0]
800083a0:	51 0a       	stdsp	sp[0x40],r10
800083a2:	50 59       	stdsp	sp[0x14],r9
800083a4:	fa ce f9 44 	sub	lr,sp,-1724
800083a8:	50 76       	stdsp	sp[0x1c],r6
800083aa:	fc 08 00 39 	add	r9,lr,r8<<0x3
800083ae:	40 5b       	lddsp	r11,sp[0x14]
800083b0:	0c 9a       	mov	r10,r6
800083b2:	f2 eb fd 88 	st.d	r9[-632],r10
800083b6:	2f f8       	sub	r8,-1
800083b8:	fb 48 06 b4 	st.w	sp[1716],r8
800083bc:	c0 88       	rjmp	800083cc <_vfprintf_r+0x888>
800083be:	72 1c       	ld.w	r12,r9[0x4]
800083c0:	50 7c       	stdsp	sp[0x1c],r12
800083c2:	f2 c8 ff f8 	sub	r8,r9,-8
800083c6:	51 08       	stdsp	sp[0x40],r8
800083c8:	72 09       	ld.w	r9,r9[0x0]
800083ca:	50 59       	stdsp	sp[0x14],r9
800083cc:	40 5b       	lddsp	r11,sp[0x14]
800083ce:	40 7a       	lddsp	r10,sp[0x1c]
800083d0:	e0 a0 19 54 	rcall	8000b678 <__isinfd>
800083d4:	18 96       	mov	r6,r12
800083d6:	c1 70       	breq	80008404 <_vfprintf_r+0x8c0>
800083d8:	30 08       	mov	r8,0
800083da:	30 09       	mov	r9,0
800083dc:	40 5b       	lddsp	r11,sp[0x14]
800083de:	40 7a       	lddsp	r10,sp[0x1c]
800083e0:	e0 a0 1d b4 	rcall	8000bf48 <__avr32_f64_cmp_lt>
800083e4:	c0 40       	breq	800083ec <_vfprintf_r+0x8a8>
800083e6:	32 d8       	mov	r8,45
800083e8:	fb 68 06 bb 	st.b	sp[1723],r8
800083ec:	fe c8 aa 84 	sub	r8,pc,-21884
800083f0:	fe c6 aa 84 	sub	r6,pc,-21884
800083f4:	a7 d5       	cbr	r5,0x7
800083f6:	e0 40 00 47 	cp.w	r0,71
800083fa:	f0 06 17 a0 	movle	r6,r8
800083fe:	30 32       	mov	r2,3
80008400:	e0 8f 06 ce 	bral	8000919c <_vfprintf_r+0x1658>
80008404:	40 5b       	lddsp	r11,sp[0x14]
80008406:	40 7a       	lddsp	r10,sp[0x1c]
80008408:	e0 a0 19 4d 	rcall	8000b6a2 <__isnand>
8000840c:	c0 e0       	breq	80008428 <_vfprintf_r+0x8e4>
8000840e:	50 26       	stdsp	sp[0x8],r6
80008410:	fe c8 aa a0 	sub	r8,pc,-21856
80008414:	fe c6 aa a0 	sub	r6,pc,-21856
80008418:	a7 d5       	cbr	r5,0x7
8000841a:	e0 40 00 47 	cp.w	r0,71
8000841e:	f0 06 17 a0 	movle	r6,r8
80008422:	30 32       	mov	r2,3
80008424:	e0 8f 06 c2 	bral	800091a8 <_vfprintf_r+0x1664>
80008428:	40 2a       	lddsp	r10,sp[0x8]
8000842a:	5b fa       	cp.w	r10,-1
8000842c:	c0 41       	brne	80008434 <_vfprintf_r+0x8f0>
8000842e:	30 69       	mov	r9,6
80008430:	50 29       	stdsp	sp[0x8],r9
80008432:	c1 18       	rjmp	80008454 <_vfprintf_r+0x910>
80008434:	e0 40 00 47 	cp.w	r0,71
80008438:	5f 09       	sreq	r9
8000843a:	e0 40 00 67 	cp.w	r0,103
8000843e:	5f 08       	sreq	r8
80008440:	f3 e8 10 08 	or	r8,r9,r8
80008444:	f8 08 18 00 	cp.b	r8,r12
80008448:	c0 60       	breq	80008454 <_vfprintf_r+0x910>
8000844a:	40 28       	lddsp	r8,sp[0x8]
8000844c:	58 08       	cp.w	r8,0
8000844e:	f9 b8 00 01 	moveq	r8,1
80008452:	50 28       	stdsp	sp[0x8],r8
80008454:	40 78       	lddsp	r8,sp[0x1c]
80008456:	40 59       	lddsp	r9,sp[0x14]
80008458:	fa e9 06 94 	st.d	sp[1684],r8
8000845c:	a9 a5       	sbr	r5,0x8
8000845e:	fa f8 06 94 	ld.w	r8,sp[1684]
80008462:	58 08       	cp.w	r8,0
80008464:	c0 65       	brlt	80008470 <_vfprintf_r+0x92c>
80008466:	40 5e       	lddsp	lr,sp[0x14]
80008468:	30 0c       	mov	r12,0
8000846a:	50 6e       	stdsp	sp[0x18],lr
8000846c:	50 9c       	stdsp	sp[0x24],r12
8000846e:	c0 78       	rjmp	8000847c <_vfprintf_r+0x938>
80008470:	40 5b       	lddsp	r11,sp[0x14]
80008472:	32 da       	mov	r10,45
80008474:	ee 1b 80 00 	eorh	r11,0x8000
80008478:	50 9a       	stdsp	sp[0x24],r10
8000847a:	50 6b       	stdsp	sp[0x18],r11
8000847c:	e0 40 00 46 	cp.w	r0,70
80008480:	5f 09       	sreq	r9
80008482:	e0 40 00 66 	cp.w	r0,102
80008486:	5f 08       	sreq	r8
80008488:	f3 e8 10 08 	or	r8,r9,r8
8000848c:	50 48       	stdsp	sp[0x10],r8
8000848e:	c0 40       	breq	80008496 <_vfprintf_r+0x952>
80008490:	40 22       	lddsp	r2,sp[0x8]
80008492:	30 39       	mov	r9,3
80008494:	c1 08       	rjmp	800084b4 <_vfprintf_r+0x970>
80008496:	e0 40 00 45 	cp.w	r0,69
8000849a:	5f 09       	sreq	r9
8000849c:	e0 40 00 65 	cp.w	r0,101
800084a0:	5f 08       	sreq	r8
800084a2:	40 22       	lddsp	r2,sp[0x8]
800084a4:	10 49       	or	r9,r8
800084a6:	2f f2       	sub	r2,-1
800084a8:	40 46       	lddsp	r6,sp[0x10]
800084aa:	ec 09 18 00 	cp.b	r9,r6
800084ae:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800084b2:	30 29       	mov	r9,2
800084b4:	fa c8 f9 5c 	sub	r8,sp,-1700
800084b8:	1a d8       	st.w	--sp,r8
800084ba:	fa c8 f9 54 	sub	r8,sp,-1708
800084be:	1a d8       	st.w	--sp,r8
800084c0:	fa c8 f9 4c 	sub	r8,sp,-1716
800084c4:	08 9c       	mov	r12,r4
800084c6:	1a d8       	st.w	--sp,r8
800084c8:	04 98       	mov	r8,r2
800084ca:	40 9b       	lddsp	r11,sp[0x24]
800084cc:	40 aa       	lddsp	r10,sp[0x28]
800084ce:	e0 a0 0b c3 	rcall	80009c54 <_dtoa_r>
800084d2:	e0 40 00 47 	cp.w	r0,71
800084d6:	5f 19       	srne	r9
800084d8:	e0 40 00 67 	cp.w	r0,103
800084dc:	5f 18       	srne	r8
800084de:	18 96       	mov	r6,r12
800084e0:	2f dd       	sub	sp,-12
800084e2:	f3 e8 00 08 	and	r8,r9,r8
800084e6:	c0 41       	brne	800084ee <_vfprintf_r+0x9aa>
800084e8:	ed b5 00 00 	bld	r5,0x0
800084ec:	c3 01       	brne	8000854c <_vfprintf_r+0xa08>
800084ee:	ec 02 00 0e 	add	lr,r6,r2
800084f2:	50 3e       	stdsp	sp[0xc],lr
800084f4:	40 4c       	lddsp	r12,sp[0x10]
800084f6:	58 0c       	cp.w	r12,0
800084f8:	c1 50       	breq	80008522 <_vfprintf_r+0x9de>
800084fa:	0d 89       	ld.ub	r9,r6[0x0]
800084fc:	33 08       	mov	r8,48
800084fe:	f0 09 18 00 	cp.b	r9,r8
80008502:	c0 b1       	brne	80008518 <_vfprintf_r+0x9d4>
80008504:	30 08       	mov	r8,0
80008506:	30 09       	mov	r9,0
80008508:	40 6b       	lddsp	r11,sp[0x18]
8000850a:	40 7a       	lddsp	r10,sp[0x1c]
8000850c:	e0 a0 1c d7 	rcall	8000beba <__avr32_f64_cmp_eq>
80008510:	fb b2 00 01 	rsubeq	r2,1
80008514:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008518:	40 3b       	lddsp	r11,sp[0xc]
8000851a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000851e:	10 0b       	add	r11,r8
80008520:	50 3b       	stdsp	sp[0xc],r11
80008522:	40 6b       	lddsp	r11,sp[0x18]
80008524:	30 08       	mov	r8,0
80008526:	30 09       	mov	r9,0
80008528:	40 7a       	lddsp	r10,sp[0x1c]
8000852a:	e0 a0 1c c8 	rcall	8000beba <__avr32_f64_cmp_eq>
8000852e:	c0 90       	breq	80008540 <_vfprintf_r+0x9fc>
80008530:	40 3a       	lddsp	r10,sp[0xc]
80008532:	fb 4a 06 a4 	st.w	sp[1700],r10
80008536:	c0 58       	rjmp	80008540 <_vfprintf_r+0x9fc>
80008538:	10 c9       	st.b	r8++,r9
8000853a:	fb 48 06 a4 	st.w	sp[1700],r8
8000853e:	c0 28       	rjmp	80008542 <_vfprintf_r+0x9fe>
80008540:	33 09       	mov	r9,48
80008542:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008546:	40 3e       	lddsp	lr,sp[0xc]
80008548:	1c 38       	cp.w	r8,lr
8000854a:	cf 73       	brcs	80008538 <_vfprintf_r+0x9f4>
8000854c:	e0 40 00 47 	cp.w	r0,71
80008550:	5f 09       	sreq	r9
80008552:	e0 40 00 67 	cp.w	r0,103
80008556:	5f 08       	sreq	r8
80008558:	f3 e8 10 08 	or	r8,r9,r8
8000855c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008560:	0c 19       	sub	r9,r6
80008562:	50 69       	stdsp	sp[0x18],r9
80008564:	58 08       	cp.w	r8,0
80008566:	c0 b0       	breq	8000857c <_vfprintf_r+0xa38>
80008568:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000856c:	5b d8       	cp.w	r8,-3
8000856e:	c0 55       	brlt	80008578 <_vfprintf_r+0xa34>
80008570:	40 2c       	lddsp	r12,sp[0x8]
80008572:	18 38       	cp.w	r8,r12
80008574:	e0 8a 00 6a 	brle	80008648 <_vfprintf_r+0xb04>
80008578:	20 20       	sub	r0,2
8000857a:	c0 58       	rjmp	80008584 <_vfprintf_r+0xa40>
8000857c:	e0 40 00 65 	cp.w	r0,101
80008580:	e0 89 00 46 	brgt	8000860c <_vfprintf_r+0xac8>
80008584:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008588:	fb 60 06 9c 	st.b	sp[1692],r0
8000858c:	20 1b       	sub	r11,1
8000858e:	fb 4b 06 ac 	st.w	sp[1708],r11
80008592:	c0 47       	brpl	8000859a <_vfprintf_r+0xa56>
80008594:	5c 3b       	neg	r11
80008596:	32 d8       	mov	r8,45
80008598:	c0 28       	rjmp	8000859c <_vfprintf_r+0xa58>
8000859a:	32 b8       	mov	r8,43
8000859c:	fb 68 06 9d 	st.b	sp[1693],r8
800085a0:	58 9b       	cp.w	r11,9
800085a2:	e0 8a 00 1d 	brle	800085dc <_vfprintf_r+0xa98>
800085a6:	fa c9 fa 35 	sub	r9,sp,-1483
800085aa:	30 aa       	mov	r10,10
800085ac:	12 98       	mov	r8,r9
800085ae:	0e 9c       	mov	r12,r7
800085b0:	0c 92       	mov	r2,r6
800085b2:	f6 0a 0c 06 	divs	r6,r11,r10
800085b6:	0e 9b       	mov	r11,r7
800085b8:	2d 0b       	sub	r11,-48
800085ba:	10 fb       	st.b	--r8,r11
800085bc:	0c 9b       	mov	r11,r6
800085be:	58 96       	cp.w	r6,9
800085c0:	fe 99 ff f9 	brgt	800085b2 <_vfprintf_r+0xa6e>
800085c4:	2d 0b       	sub	r11,-48
800085c6:	18 97       	mov	r7,r12
800085c8:	04 96       	mov	r6,r2
800085ca:	10 fb       	st.b	--r8,r11
800085cc:	fa ca f9 62 	sub	r10,sp,-1694
800085d0:	c0 38       	rjmp	800085d6 <_vfprintf_r+0xa92>
800085d2:	11 3b       	ld.ub	r11,r8++
800085d4:	14 cb       	st.b	r10++,r11
800085d6:	12 38       	cp.w	r8,r9
800085d8:	cf d3       	brcs	800085d2 <_vfprintf_r+0xa8e>
800085da:	c0 98       	rjmp	800085ec <_vfprintf_r+0xaa8>
800085dc:	2d 0b       	sub	r11,-48
800085de:	33 08       	mov	r8,48
800085e0:	fb 6b 06 9f 	st.b	sp[1695],r11
800085e4:	fb 68 06 9e 	st.b	sp[1694],r8
800085e8:	fa ca f9 60 	sub	r10,sp,-1696
800085ec:	fa c8 f9 64 	sub	r8,sp,-1692
800085f0:	f4 08 01 08 	sub	r8,r10,r8
800085f4:	50 e8       	stdsp	sp[0x38],r8
800085f6:	10 92       	mov	r2,r8
800085f8:	40 6b       	lddsp	r11,sp[0x18]
800085fa:	16 02       	add	r2,r11
800085fc:	58 1b       	cp.w	r11,1
800085fe:	e0 89 00 05 	brgt	80008608 <_vfprintf_r+0xac4>
80008602:	ed b5 00 00 	bld	r5,0x0
80008606:	c3 51       	brne	80008670 <_vfprintf_r+0xb2c>
80008608:	2f f2       	sub	r2,-1
8000860a:	c3 38       	rjmp	80008670 <_vfprintf_r+0xb2c>
8000860c:	e0 40 00 66 	cp.w	r0,102
80008610:	c1 c1       	brne	80008648 <_vfprintf_r+0xb04>
80008612:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008616:	58 02       	cp.w	r2,0
80008618:	e0 8a 00 0c 	brle	80008630 <_vfprintf_r+0xaec>
8000861c:	40 2a       	lddsp	r10,sp[0x8]
8000861e:	58 0a       	cp.w	r10,0
80008620:	c0 41       	brne	80008628 <_vfprintf_r+0xae4>
80008622:	ed b5 00 00 	bld	r5,0x0
80008626:	c2 51       	brne	80008670 <_vfprintf_r+0xb2c>
80008628:	2f f2       	sub	r2,-1
8000862a:	40 29       	lddsp	r9,sp[0x8]
8000862c:	12 02       	add	r2,r9
8000862e:	c0 b8       	rjmp	80008644 <_vfprintf_r+0xb00>
80008630:	40 28       	lddsp	r8,sp[0x8]
80008632:	58 08       	cp.w	r8,0
80008634:	c0 61       	brne	80008640 <_vfprintf_r+0xafc>
80008636:	ed b5 00 00 	bld	r5,0x0
8000863a:	c0 30       	breq	80008640 <_vfprintf_r+0xafc>
8000863c:	30 12       	mov	r2,1
8000863e:	c1 98       	rjmp	80008670 <_vfprintf_r+0xb2c>
80008640:	40 22       	lddsp	r2,sp[0x8]
80008642:	2f e2       	sub	r2,-2
80008644:	36 60       	mov	r0,102
80008646:	c1 58       	rjmp	80008670 <_vfprintf_r+0xb2c>
80008648:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000864c:	40 6e       	lddsp	lr,sp[0x18]
8000864e:	1c 32       	cp.w	r2,lr
80008650:	c0 65       	brlt	8000865c <_vfprintf_r+0xb18>
80008652:	ed b5 00 00 	bld	r5,0x0
80008656:	f7 b2 00 ff 	subeq	r2,-1
8000865a:	c0 a8       	rjmp	8000866e <_vfprintf_r+0xb2a>
8000865c:	e4 08 11 02 	rsub	r8,r2,2
80008660:	40 6c       	lddsp	r12,sp[0x18]
80008662:	58 02       	cp.w	r2,0
80008664:	f0 02 17 a0 	movle	r2,r8
80008668:	f9 b2 09 01 	movgt	r2,1
8000866c:	18 02       	add	r2,r12
8000866e:	36 70       	mov	r0,103
80008670:	40 9b       	lddsp	r11,sp[0x24]
80008672:	58 0b       	cp.w	r11,0
80008674:	e0 80 05 94 	breq	8000919c <_vfprintf_r+0x1658>
80008678:	32 d8       	mov	r8,45
8000867a:	fb 68 06 bb 	st.b	sp[1723],r8
8000867e:	e0 8f 05 93 	bral	800091a4 <_vfprintf_r+0x1660>
80008682:	50 a7       	stdsp	sp[0x28],r7
80008684:	04 94       	mov	r4,r2
80008686:	0c 97       	mov	r7,r6
80008688:	02 92       	mov	r2,r1
8000868a:	06 96       	mov	r6,r3
8000868c:	40 41       	lddsp	r1,sp[0x10]
8000868e:	40 93       	lddsp	r3,sp[0x24]
80008690:	0e 99       	mov	r9,r7
80008692:	ed b5 00 05 	bld	r5,0x5
80008696:	c4 81       	brne	80008726 <_vfprintf_r+0xbe2>
80008698:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000869c:	40 3e       	lddsp	lr,sp[0xc]
8000869e:	58 0e       	cp.w	lr,0
800086a0:	c1 d0       	breq	800086da <_vfprintf_r+0xb96>
800086a2:	10 36       	cp.w	r6,r8
800086a4:	c0 64       	brge	800086b0 <_vfprintf_r+0xb6c>
800086a6:	fa cc f9 44 	sub	r12,sp,-1724
800086aa:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086ae:	c1 d8       	rjmp	800086e8 <_vfprintf_r+0xba4>
800086b0:	fa c8 f9 50 	sub	r8,sp,-1712
800086b4:	1a d8       	st.w	--sp,r8
800086b6:	fa c8 fa b8 	sub	r8,sp,-1352
800086ba:	04 9a       	mov	r10,r2
800086bc:	1a d8       	st.w	--sp,r8
800086be:	fa c8 fb b4 	sub	r8,sp,-1100
800086c2:	0c 9b       	mov	r11,r6
800086c4:	1a d8       	st.w	--sp,r8
800086c6:	08 9c       	mov	r12,r4
800086c8:	fa c8 f9 40 	sub	r8,sp,-1728
800086cc:	fa c9 ff b4 	sub	r9,sp,-76
800086d0:	fe b0 f8 a2 	rcall	80007814 <get_arg>
800086d4:	2f dd       	sub	sp,-12
800086d6:	78 0a       	ld.w	r10,r12[0x0]
800086d8:	c2 08       	rjmp	80008718 <_vfprintf_r+0xbd4>
800086da:	2f f7       	sub	r7,-1
800086dc:	10 39       	cp.w	r9,r8
800086de:	c0 84       	brge	800086ee <_vfprintf_r+0xbaa>
800086e0:	fa cb f9 44 	sub	r11,sp,-1724
800086e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086e8:	ec fa fd 88 	ld.w	r10,r6[-632]
800086ec:	c1 68       	rjmp	80008718 <_vfprintf_r+0xbd4>
800086ee:	41 09       	lddsp	r9,sp[0x40]
800086f0:	59 f8       	cp.w	r8,31
800086f2:	e0 89 00 10 	brgt	80008712 <_vfprintf_r+0xbce>
800086f6:	f2 ca ff fc 	sub	r10,r9,-4
800086fa:	51 0a       	stdsp	sp[0x40],r10
800086fc:	fa c6 f9 44 	sub	r6,sp,-1724
80008700:	72 0a       	ld.w	r10,r9[0x0]
80008702:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008706:	f3 4a fd 88 	st.w	r9[-632],r10
8000870a:	2f f8       	sub	r8,-1
8000870c:	fb 48 06 b4 	st.w	sp[1716],r8
80008710:	c0 48       	rjmp	80008718 <_vfprintf_r+0xbd4>
80008712:	72 0a       	ld.w	r10,r9[0x0]
80008714:	2f c9       	sub	r9,-4
80008716:	51 09       	stdsp	sp[0x40],r9
80008718:	40 be       	lddsp	lr,sp[0x2c]
8000871a:	1c 98       	mov	r8,lr
8000871c:	95 1e       	st.w	r10[0x4],lr
8000871e:	bf 58       	asr	r8,0x1f
80008720:	95 08       	st.w	r10[0x0],r8
80008722:	fe 9f fa 9f 	bral	80007c60 <_vfprintf_r+0x11c>
80008726:	ed b5 00 04 	bld	r5,0x4
8000872a:	c4 80       	breq	800087ba <_vfprintf_r+0xc76>
8000872c:	e2 15 00 40 	andl	r5,0x40,COH
80008730:	c4 50       	breq	800087ba <_vfprintf_r+0xc76>
80008732:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008736:	40 3c       	lddsp	r12,sp[0xc]
80008738:	58 0c       	cp.w	r12,0
8000873a:	c1 d0       	breq	80008774 <_vfprintf_r+0xc30>
8000873c:	10 36       	cp.w	r6,r8
8000873e:	c0 64       	brge	8000874a <_vfprintf_r+0xc06>
80008740:	fa cb f9 44 	sub	r11,sp,-1724
80008744:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008748:	c1 d8       	rjmp	80008782 <_vfprintf_r+0xc3e>
8000874a:	fa c8 f9 50 	sub	r8,sp,-1712
8000874e:	1a d8       	st.w	--sp,r8
80008750:	fa c8 fa b8 	sub	r8,sp,-1352
80008754:	04 9a       	mov	r10,r2
80008756:	1a d8       	st.w	--sp,r8
80008758:	fa c8 fb b4 	sub	r8,sp,-1100
8000875c:	0c 9b       	mov	r11,r6
8000875e:	1a d8       	st.w	--sp,r8
80008760:	08 9c       	mov	r12,r4
80008762:	fa c8 f9 40 	sub	r8,sp,-1728
80008766:	fa c9 ff b4 	sub	r9,sp,-76
8000876a:	fe b0 f8 55 	rcall	80007814 <get_arg>
8000876e:	2f dd       	sub	sp,-12
80008770:	78 0a       	ld.w	r10,r12[0x0]
80008772:	c2 08       	rjmp	800087b2 <_vfprintf_r+0xc6e>
80008774:	2f f7       	sub	r7,-1
80008776:	10 39       	cp.w	r9,r8
80008778:	c0 84       	brge	80008788 <_vfprintf_r+0xc44>
8000877a:	fa ca f9 44 	sub	r10,sp,-1724
8000877e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008782:	ec fa fd 88 	ld.w	r10,r6[-632]
80008786:	c1 68       	rjmp	800087b2 <_vfprintf_r+0xc6e>
80008788:	41 09       	lddsp	r9,sp[0x40]
8000878a:	59 f8       	cp.w	r8,31
8000878c:	e0 89 00 10 	brgt	800087ac <_vfprintf_r+0xc68>
80008790:	f2 ca ff fc 	sub	r10,r9,-4
80008794:	51 0a       	stdsp	sp[0x40],r10
80008796:	fa c6 f9 44 	sub	r6,sp,-1724
8000879a:	72 0a       	ld.w	r10,r9[0x0]
8000879c:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087a0:	f3 4a fd 88 	st.w	r9[-632],r10
800087a4:	2f f8       	sub	r8,-1
800087a6:	fb 48 06 b4 	st.w	sp[1716],r8
800087aa:	c0 48       	rjmp	800087b2 <_vfprintf_r+0xc6e>
800087ac:	72 0a       	ld.w	r10,r9[0x0]
800087ae:	2f c9       	sub	r9,-4
800087b0:	51 09       	stdsp	sp[0x40],r9
800087b2:	40 be       	lddsp	lr,sp[0x2c]
800087b4:	b4 0e       	st.h	r10[0x0],lr
800087b6:	fe 9f fa 55 	bral	80007c60 <_vfprintf_r+0x11c>
800087ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087be:	40 3c       	lddsp	r12,sp[0xc]
800087c0:	58 0c       	cp.w	r12,0
800087c2:	c1 d0       	breq	800087fc <_vfprintf_r+0xcb8>
800087c4:	10 36       	cp.w	r6,r8
800087c6:	c0 64       	brge	800087d2 <_vfprintf_r+0xc8e>
800087c8:	fa cb f9 44 	sub	r11,sp,-1724
800087cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087d0:	c1 d8       	rjmp	8000880a <_vfprintf_r+0xcc6>
800087d2:	fa c8 f9 50 	sub	r8,sp,-1712
800087d6:	1a d8       	st.w	--sp,r8
800087d8:	fa c8 fa b8 	sub	r8,sp,-1352
800087dc:	04 9a       	mov	r10,r2
800087de:	1a d8       	st.w	--sp,r8
800087e0:	fa c8 fb b4 	sub	r8,sp,-1100
800087e4:	0c 9b       	mov	r11,r6
800087e6:	1a d8       	st.w	--sp,r8
800087e8:	08 9c       	mov	r12,r4
800087ea:	fa c8 f9 40 	sub	r8,sp,-1728
800087ee:	fa c9 ff b4 	sub	r9,sp,-76
800087f2:	fe b0 f8 11 	rcall	80007814 <get_arg>
800087f6:	2f dd       	sub	sp,-12
800087f8:	78 0a       	ld.w	r10,r12[0x0]
800087fa:	c2 08       	rjmp	8000883a <_vfprintf_r+0xcf6>
800087fc:	2f f7       	sub	r7,-1
800087fe:	10 39       	cp.w	r9,r8
80008800:	c0 84       	brge	80008810 <_vfprintf_r+0xccc>
80008802:	fa ca f9 44 	sub	r10,sp,-1724
80008806:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000880a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000880e:	c1 68       	rjmp	8000883a <_vfprintf_r+0xcf6>
80008810:	41 09       	lddsp	r9,sp[0x40]
80008812:	59 f8       	cp.w	r8,31
80008814:	e0 89 00 10 	brgt	80008834 <_vfprintf_r+0xcf0>
80008818:	f2 ca ff fc 	sub	r10,r9,-4
8000881c:	51 0a       	stdsp	sp[0x40],r10
8000881e:	fa c6 f9 44 	sub	r6,sp,-1724
80008822:	72 0a       	ld.w	r10,r9[0x0]
80008824:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008828:	f3 4a fd 88 	st.w	r9[-632],r10
8000882c:	2f f8       	sub	r8,-1
8000882e:	fb 48 06 b4 	st.w	sp[1716],r8
80008832:	c0 48       	rjmp	8000883a <_vfprintf_r+0xcf6>
80008834:	72 0a       	ld.w	r10,r9[0x0]
80008836:	2f c9       	sub	r9,-4
80008838:	51 09       	stdsp	sp[0x40],r9
8000883a:	40 be       	lddsp	lr,sp[0x2c]
8000883c:	95 0e       	st.w	r10[0x0],lr
8000883e:	fe 9f fa 11 	bral	80007c60 <_vfprintf_r+0x11c>
80008842:	50 a7       	stdsp	sp[0x28],r7
80008844:	50 80       	stdsp	sp[0x20],r0
80008846:	0c 97       	mov	r7,r6
80008848:	04 94       	mov	r4,r2
8000884a:	06 96       	mov	r6,r3
8000884c:	02 92       	mov	r2,r1
8000884e:	40 93       	lddsp	r3,sp[0x24]
80008850:	10 90       	mov	r0,r8
80008852:	40 41       	lddsp	r1,sp[0x10]
80008854:	a5 a5       	sbr	r5,0x4
80008856:	c0 a8       	rjmp	8000886a <_vfprintf_r+0xd26>
80008858:	50 a7       	stdsp	sp[0x28],r7
8000885a:	50 80       	stdsp	sp[0x20],r0
8000885c:	0c 97       	mov	r7,r6
8000885e:	04 94       	mov	r4,r2
80008860:	06 96       	mov	r6,r3
80008862:	02 92       	mov	r2,r1
80008864:	40 93       	lddsp	r3,sp[0x24]
80008866:	10 90       	mov	r0,r8
80008868:	40 41       	lddsp	r1,sp[0x10]
8000886a:	ed b5 00 05 	bld	r5,0x5
8000886e:	c5 d1       	brne	80008928 <_vfprintf_r+0xde4>
80008870:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008874:	40 3c       	lddsp	r12,sp[0xc]
80008876:	58 0c       	cp.w	r12,0
80008878:	c2 60       	breq	800088c4 <_vfprintf_r+0xd80>
8000887a:	10 36       	cp.w	r6,r8
8000887c:	c0 a4       	brge	80008890 <_vfprintf_r+0xd4c>
8000887e:	fa cb f9 44 	sub	r11,sp,-1724
80008882:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008886:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000888a:	fa e9 00 00 	st.d	sp[0],r8
8000888e:	c1 88       	rjmp	800088be <_vfprintf_r+0xd7a>
80008890:	fa c8 f9 50 	sub	r8,sp,-1712
80008894:	1a d8       	st.w	--sp,r8
80008896:	fa c8 fa b8 	sub	r8,sp,-1352
8000889a:	04 9a       	mov	r10,r2
8000889c:	1a d8       	st.w	--sp,r8
8000889e:	0c 9b       	mov	r11,r6
800088a0:	fa c8 fb b4 	sub	r8,sp,-1100
800088a4:	08 9c       	mov	r12,r4
800088a6:	1a d8       	st.w	--sp,r8
800088a8:	fa c8 f9 40 	sub	r8,sp,-1728
800088ac:	fa c9 ff b4 	sub	r9,sp,-76
800088b0:	fe b0 f7 b2 	rcall	80007814 <get_arg>
800088b4:	2f dd       	sub	sp,-12
800088b6:	f8 ea 00 00 	ld.d	r10,r12[0]
800088ba:	fa eb 00 00 	st.d	sp[0],r10
800088be:	30 08       	mov	r8,0
800088c0:	e0 8f 03 de 	bral	8000907c <_vfprintf_r+0x1538>
800088c4:	ee ca ff ff 	sub	r10,r7,-1
800088c8:	10 37       	cp.w	r7,r8
800088ca:	c0 b4       	brge	800088e0 <_vfprintf_r+0xd9c>
800088cc:	fa c9 f9 44 	sub	r9,sp,-1724
800088d0:	14 97       	mov	r7,r10
800088d2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088d6:	ec ea fd 88 	ld.d	r10,r6[-632]
800088da:	fa eb 00 00 	st.d	sp[0],r10
800088de:	c1 88       	rjmp	8000890e <_vfprintf_r+0xdca>
800088e0:	41 09       	lddsp	r9,sp[0x40]
800088e2:	59 f8       	cp.w	r8,31
800088e4:	e0 89 00 18 	brgt	80008914 <_vfprintf_r+0xdd0>
800088e8:	f2 e6 00 00 	ld.d	r6,r9[0]
800088ec:	f2 cb ff f8 	sub	r11,r9,-8
800088f0:	fa e7 00 00 	st.d	sp[0],r6
800088f4:	51 0b       	stdsp	sp[0x40],r11
800088f6:	fa c6 f9 44 	sub	r6,sp,-1724
800088fa:	ec 08 00 39 	add	r9,r6,r8<<0x3
800088fe:	fa e6 00 00 	ld.d	r6,sp[0]
80008902:	f2 e7 fd 88 	st.d	r9[-632],r6
80008906:	2f f8       	sub	r8,-1
80008908:	14 97       	mov	r7,r10
8000890a:	fb 48 06 b4 	st.w	sp[1716],r8
8000890e:	40 38       	lddsp	r8,sp[0xc]
80008910:	e0 8f 03 b6 	bral	8000907c <_vfprintf_r+0x1538>
80008914:	f2 e6 00 00 	ld.d	r6,r9[0]
80008918:	40 38       	lddsp	r8,sp[0xc]
8000891a:	fa e7 00 00 	st.d	sp[0],r6
8000891e:	2f 89       	sub	r9,-8
80008920:	14 97       	mov	r7,r10
80008922:	51 09       	stdsp	sp[0x40],r9
80008924:	e0 8f 03 ac 	bral	8000907c <_vfprintf_r+0x1538>
80008928:	ed b5 00 04 	bld	r5,0x4
8000892c:	c1 61       	brne	80008958 <_vfprintf_r+0xe14>
8000892e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008932:	40 3e       	lddsp	lr,sp[0xc]
80008934:	58 0e       	cp.w	lr,0
80008936:	c0 80       	breq	80008946 <_vfprintf_r+0xe02>
80008938:	10 36       	cp.w	r6,r8
8000893a:	c6 74       	brge	80008a08 <_vfprintf_r+0xec4>
8000893c:	fa cc f9 44 	sub	r12,sp,-1724
80008940:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008944:	c8 08       	rjmp	80008a44 <_vfprintf_r+0xf00>
80008946:	ee ca ff ff 	sub	r10,r7,-1
8000894a:	10 37       	cp.w	r7,r8
8000894c:	c7 f4       	brge	80008a4a <_vfprintf_r+0xf06>
8000894e:	fa cb f9 44 	sub	r11,sp,-1724
80008952:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008956:	c7 68       	rjmp	80008a42 <_vfprintf_r+0xefe>
80008958:	ed b5 00 06 	bld	r5,0x6
8000895c:	c4 a1       	brne	800089f0 <_vfprintf_r+0xeac>
8000895e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008962:	40 3c       	lddsp	r12,sp[0xc]
80008964:	58 0c       	cp.w	r12,0
80008966:	c1 d0       	breq	800089a0 <_vfprintf_r+0xe5c>
80008968:	10 36       	cp.w	r6,r8
8000896a:	c0 64       	brge	80008976 <_vfprintf_r+0xe32>
8000896c:	fa cb f9 44 	sub	r11,sp,-1724
80008970:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008974:	c1 f8       	rjmp	800089b2 <_vfprintf_r+0xe6e>
80008976:	fa c8 f9 50 	sub	r8,sp,-1712
8000897a:	1a d8       	st.w	--sp,r8
8000897c:	fa c8 fa b8 	sub	r8,sp,-1352
80008980:	1a d8       	st.w	--sp,r8
80008982:	fa c8 fb b4 	sub	r8,sp,-1100
80008986:	1a d8       	st.w	--sp,r8
80008988:	fa c8 f9 40 	sub	r8,sp,-1728
8000898c:	fa c9 ff b4 	sub	r9,sp,-76
80008990:	04 9a       	mov	r10,r2
80008992:	0c 9b       	mov	r11,r6
80008994:	08 9c       	mov	r12,r4
80008996:	fe b0 f7 3f 	rcall	80007814 <get_arg>
8000899a:	2f dd       	sub	sp,-12
8000899c:	98 18       	ld.sh	r8,r12[0x2]
8000899e:	c2 68       	rjmp	800089ea <_vfprintf_r+0xea6>
800089a0:	ee ca ff ff 	sub	r10,r7,-1
800089a4:	10 37       	cp.w	r7,r8
800089a6:	c0 94       	brge	800089b8 <_vfprintf_r+0xe74>
800089a8:	fa c9 f9 44 	sub	r9,sp,-1724
800089ac:	14 97       	mov	r7,r10
800089ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800089b6:	c1 a8       	rjmp	800089ea <_vfprintf_r+0xea6>
800089b8:	41 09       	lddsp	r9,sp[0x40]
800089ba:	59 f8       	cp.w	r8,31
800089bc:	e0 89 00 13 	brgt	800089e2 <_vfprintf_r+0xe9e>
800089c0:	f2 cb ff fc 	sub	r11,r9,-4
800089c4:	51 0b       	stdsp	sp[0x40],r11
800089c6:	72 09       	ld.w	r9,r9[0x0]
800089c8:	fa c6 f9 44 	sub	r6,sp,-1724
800089cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800089d0:	2f f8       	sub	r8,-1
800089d2:	f7 49 fd 88 	st.w	r11[-632],r9
800089d6:	fb 48 06 b4 	st.w	sp[1716],r8
800089da:	14 97       	mov	r7,r10
800089dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800089e0:	c0 58       	rjmp	800089ea <_vfprintf_r+0xea6>
800089e2:	92 18       	ld.sh	r8,r9[0x2]
800089e4:	14 97       	mov	r7,r10
800089e6:	2f c9       	sub	r9,-4
800089e8:	51 09       	stdsp	sp[0x40],r9
800089ea:	5c 78       	castu.h	r8
800089ec:	50 18       	stdsp	sp[0x4],r8
800089ee:	c4 68       	rjmp	80008a7a <_vfprintf_r+0xf36>
800089f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089f4:	40 3c       	lddsp	r12,sp[0xc]
800089f6:	58 0c       	cp.w	r12,0
800089f8:	c1 d0       	breq	80008a32 <_vfprintf_r+0xeee>
800089fa:	10 36       	cp.w	r6,r8
800089fc:	c0 64       	brge	80008a08 <_vfprintf_r+0xec4>
800089fe:	fa cb f9 44 	sub	r11,sp,-1724
80008a02:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a06:	c1 f8       	rjmp	80008a44 <_vfprintf_r+0xf00>
80008a08:	fa c8 f9 50 	sub	r8,sp,-1712
80008a0c:	1a d8       	st.w	--sp,r8
80008a0e:	fa c8 fa b8 	sub	r8,sp,-1352
80008a12:	0c 9b       	mov	r11,r6
80008a14:	1a d8       	st.w	--sp,r8
80008a16:	fa c8 fb b4 	sub	r8,sp,-1100
80008a1a:	04 9a       	mov	r10,r2
80008a1c:	1a d8       	st.w	--sp,r8
80008a1e:	08 9c       	mov	r12,r4
80008a20:	fa c8 f9 40 	sub	r8,sp,-1728
80008a24:	fa c9 ff b4 	sub	r9,sp,-76
80008a28:	fe b0 f6 f6 	rcall	80007814 <get_arg>
80008a2c:	2f dd       	sub	sp,-12
80008a2e:	78 0b       	ld.w	r11,r12[0x0]
80008a30:	c2 48       	rjmp	80008a78 <_vfprintf_r+0xf34>
80008a32:	ee ca ff ff 	sub	r10,r7,-1
80008a36:	10 37       	cp.w	r7,r8
80008a38:	c0 94       	brge	80008a4a <_vfprintf_r+0xf06>
80008a3a:	fa c9 f9 44 	sub	r9,sp,-1724
80008a3e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a42:	14 97       	mov	r7,r10
80008a44:	ec fb fd 88 	ld.w	r11,r6[-632]
80008a48:	c1 88       	rjmp	80008a78 <_vfprintf_r+0xf34>
80008a4a:	41 09       	lddsp	r9,sp[0x40]
80008a4c:	59 f8       	cp.w	r8,31
80008a4e:	e0 89 00 11 	brgt	80008a70 <_vfprintf_r+0xf2c>
80008a52:	f2 cb ff fc 	sub	r11,r9,-4
80008a56:	51 0b       	stdsp	sp[0x40],r11
80008a58:	fa c6 f9 44 	sub	r6,sp,-1724
80008a5c:	72 0b       	ld.w	r11,r9[0x0]
80008a5e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a62:	f3 4b fd 88 	st.w	r9[-632],r11
80008a66:	2f f8       	sub	r8,-1
80008a68:	14 97       	mov	r7,r10
80008a6a:	fb 48 06 b4 	st.w	sp[1716],r8
80008a6e:	c0 58       	rjmp	80008a78 <_vfprintf_r+0xf34>
80008a70:	72 0b       	ld.w	r11,r9[0x0]
80008a72:	14 97       	mov	r7,r10
80008a74:	2f c9       	sub	r9,-4
80008a76:	51 09       	stdsp	sp[0x40],r9
80008a78:	50 1b       	stdsp	sp[0x4],r11
80008a7a:	30 0e       	mov	lr,0
80008a7c:	50 0e       	stdsp	sp[0x0],lr
80008a7e:	1c 98       	mov	r8,lr
80008a80:	e0 8f 02 fe 	bral	8000907c <_vfprintf_r+0x1538>
80008a84:	50 a7       	stdsp	sp[0x28],r7
80008a86:	50 80       	stdsp	sp[0x20],r0
80008a88:	0c 97       	mov	r7,r6
80008a8a:	04 94       	mov	r4,r2
80008a8c:	06 96       	mov	r6,r3
80008a8e:	02 92       	mov	r2,r1
80008a90:	40 93       	lddsp	r3,sp[0x24]
80008a92:	40 41       	lddsp	r1,sp[0x10]
80008a94:	0e 99       	mov	r9,r7
80008a96:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a9a:	40 3c       	lddsp	r12,sp[0xc]
80008a9c:	58 0c       	cp.w	r12,0
80008a9e:	c1 d0       	breq	80008ad8 <_vfprintf_r+0xf94>
80008aa0:	10 36       	cp.w	r6,r8
80008aa2:	c0 64       	brge	80008aae <_vfprintf_r+0xf6a>
80008aa4:	fa cb f9 44 	sub	r11,sp,-1724
80008aa8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008aac:	c1 d8       	rjmp	80008ae6 <_vfprintf_r+0xfa2>
80008aae:	fa c8 f9 50 	sub	r8,sp,-1712
80008ab2:	1a d8       	st.w	--sp,r8
80008ab4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ab8:	1a d8       	st.w	--sp,r8
80008aba:	fa c8 fb b4 	sub	r8,sp,-1100
80008abe:	1a d8       	st.w	--sp,r8
80008ac0:	fa c9 ff b4 	sub	r9,sp,-76
80008ac4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ac8:	04 9a       	mov	r10,r2
80008aca:	0c 9b       	mov	r11,r6
80008acc:	08 9c       	mov	r12,r4
80008ace:	fe b0 f6 a3 	rcall	80007814 <get_arg>
80008ad2:	2f dd       	sub	sp,-12
80008ad4:	78 09       	ld.w	r9,r12[0x0]
80008ad6:	c2 18       	rjmp	80008b18 <_vfprintf_r+0xfd4>
80008ad8:	2f f7       	sub	r7,-1
80008ada:	10 39       	cp.w	r9,r8
80008adc:	c0 84       	brge	80008aec <_vfprintf_r+0xfa8>
80008ade:	fa ca f9 44 	sub	r10,sp,-1724
80008ae2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ae6:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008aea:	c1 78       	rjmp	80008b18 <_vfprintf_r+0xfd4>
80008aec:	41 09       	lddsp	r9,sp[0x40]
80008aee:	59 f8       	cp.w	r8,31
80008af0:	e0 89 00 10 	brgt	80008b10 <_vfprintf_r+0xfcc>
80008af4:	f2 ca ff fc 	sub	r10,r9,-4
80008af8:	51 0a       	stdsp	sp[0x40],r10
80008afa:	fa c6 f9 44 	sub	r6,sp,-1724
80008afe:	72 09       	ld.w	r9,r9[0x0]
80008b00:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008b04:	f5 49 fd 88 	st.w	r10[-632],r9
80008b08:	2f f8       	sub	r8,-1
80008b0a:	fb 48 06 b4 	st.w	sp[1716],r8
80008b0e:	c0 58       	rjmp	80008b18 <_vfprintf_r+0xfd4>
80008b10:	f2 c8 ff fc 	sub	r8,r9,-4
80008b14:	51 08       	stdsp	sp[0x40],r8
80008b16:	72 09       	ld.w	r9,r9[0x0]
80008b18:	33 08       	mov	r8,48
80008b1a:	fb 68 06 b8 	st.b	sp[1720],r8
80008b1e:	37 88       	mov	r8,120
80008b20:	30 0e       	mov	lr,0
80008b22:	fb 68 06 b9 	st.b	sp[1721],r8
80008b26:	fe cc b1 ae 	sub	r12,pc,-20050
80008b2a:	50 19       	stdsp	sp[0x4],r9
80008b2c:	a1 b5       	sbr	r5,0x1
80008b2e:	50 0e       	stdsp	sp[0x0],lr
80008b30:	50 dc       	stdsp	sp[0x34],r12
80008b32:	30 28       	mov	r8,2
80008b34:	37 80       	mov	r0,120
80008b36:	e0 8f 02 a3 	bral	8000907c <_vfprintf_r+0x1538>
80008b3a:	50 a7       	stdsp	sp[0x28],r7
80008b3c:	50 80       	stdsp	sp[0x20],r0
80008b3e:	10 90       	mov	r0,r8
80008b40:	30 08       	mov	r8,0
80008b42:	fb 68 06 bb 	st.b	sp[1723],r8
80008b46:	0c 97       	mov	r7,r6
80008b48:	04 94       	mov	r4,r2
80008b4a:	06 96       	mov	r6,r3
80008b4c:	02 92       	mov	r2,r1
80008b4e:	40 93       	lddsp	r3,sp[0x24]
80008b50:	40 41       	lddsp	r1,sp[0x10]
80008b52:	0e 99       	mov	r9,r7
80008b54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b58:	40 3b       	lddsp	r11,sp[0xc]
80008b5a:	58 0b       	cp.w	r11,0
80008b5c:	c1 d0       	breq	80008b96 <_vfprintf_r+0x1052>
80008b5e:	10 36       	cp.w	r6,r8
80008b60:	c0 64       	brge	80008b6c <_vfprintf_r+0x1028>
80008b62:	fa ca f9 44 	sub	r10,sp,-1724
80008b66:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b6a:	c1 d8       	rjmp	80008ba4 <_vfprintf_r+0x1060>
80008b6c:	fa c8 f9 50 	sub	r8,sp,-1712
80008b70:	1a d8       	st.w	--sp,r8
80008b72:	fa c8 fa b8 	sub	r8,sp,-1352
80008b76:	1a d8       	st.w	--sp,r8
80008b78:	fa c8 fb b4 	sub	r8,sp,-1100
80008b7c:	0c 9b       	mov	r11,r6
80008b7e:	1a d8       	st.w	--sp,r8
80008b80:	04 9a       	mov	r10,r2
80008b82:	fa c8 f9 40 	sub	r8,sp,-1728
80008b86:	fa c9 ff b4 	sub	r9,sp,-76
80008b8a:	08 9c       	mov	r12,r4
80008b8c:	fe b0 f6 44 	rcall	80007814 <get_arg>
80008b90:	2f dd       	sub	sp,-12
80008b92:	78 06       	ld.w	r6,r12[0x0]
80008b94:	c2 08       	rjmp	80008bd4 <_vfprintf_r+0x1090>
80008b96:	2f f7       	sub	r7,-1
80008b98:	10 39       	cp.w	r9,r8
80008b9a:	c0 84       	brge	80008baa <_vfprintf_r+0x1066>
80008b9c:	fa c9 f9 44 	sub	r9,sp,-1724
80008ba0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ba4:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008ba8:	c1 68       	rjmp	80008bd4 <_vfprintf_r+0x1090>
80008baa:	41 09       	lddsp	r9,sp[0x40]
80008bac:	59 f8       	cp.w	r8,31
80008bae:	e0 89 00 10 	brgt	80008bce <_vfprintf_r+0x108a>
80008bb2:	f2 ca ff fc 	sub	r10,r9,-4
80008bb6:	51 0a       	stdsp	sp[0x40],r10
80008bb8:	72 06       	ld.w	r6,r9[0x0]
80008bba:	fa ce f9 44 	sub	lr,sp,-1724
80008bbe:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008bc2:	f3 46 fd 88 	st.w	r9[-632],r6
80008bc6:	2f f8       	sub	r8,-1
80008bc8:	fb 48 06 b4 	st.w	sp[1716],r8
80008bcc:	c0 48       	rjmp	80008bd4 <_vfprintf_r+0x1090>
80008bce:	72 06       	ld.w	r6,r9[0x0]
80008bd0:	2f c9       	sub	r9,-4
80008bd2:	51 09       	stdsp	sp[0x40],r9
80008bd4:	40 2c       	lddsp	r12,sp[0x8]
80008bd6:	58 0c       	cp.w	r12,0
80008bd8:	c1 05       	brlt	80008bf8 <_vfprintf_r+0x10b4>
80008bda:	18 9a       	mov	r10,r12
80008bdc:	30 0b       	mov	r11,0
80008bde:	0c 9c       	mov	r12,r6
80008be0:	e0 a0 12 38 	rcall	8000b050 <memchr>
80008be4:	e0 80 02 df 	breq	800091a2 <_vfprintf_r+0x165e>
80008be8:	f8 06 01 02 	sub	r2,r12,r6
80008bec:	40 2b       	lddsp	r11,sp[0x8]
80008bee:	16 32       	cp.w	r2,r11
80008bf0:	e0 89 02 d9 	brgt	800091a2 <_vfprintf_r+0x165e>
80008bf4:	e0 8f 02 d4 	bral	8000919c <_vfprintf_r+0x1658>
80008bf8:	30 0a       	mov	r10,0
80008bfa:	0c 9c       	mov	r12,r6
80008bfc:	50 2a       	stdsp	sp[0x8],r10
80008bfe:	e0 a0 15 99 	rcall	8000b730 <strlen>
80008c02:	18 92       	mov	r2,r12
80008c04:	e0 8f 02 d2 	bral	800091a8 <_vfprintf_r+0x1664>
80008c08:	50 a7       	stdsp	sp[0x28],r7
80008c0a:	50 80       	stdsp	sp[0x20],r0
80008c0c:	0c 97       	mov	r7,r6
80008c0e:	04 94       	mov	r4,r2
80008c10:	06 96       	mov	r6,r3
80008c12:	02 92       	mov	r2,r1
80008c14:	40 93       	lddsp	r3,sp[0x24]
80008c16:	10 90       	mov	r0,r8
80008c18:	40 41       	lddsp	r1,sp[0x10]
80008c1a:	a5 a5       	sbr	r5,0x4
80008c1c:	c0 a8       	rjmp	80008c30 <_vfprintf_r+0x10ec>
80008c1e:	50 a7       	stdsp	sp[0x28],r7
80008c20:	50 80       	stdsp	sp[0x20],r0
80008c22:	0c 97       	mov	r7,r6
80008c24:	04 94       	mov	r4,r2
80008c26:	06 96       	mov	r6,r3
80008c28:	02 92       	mov	r2,r1
80008c2a:	40 93       	lddsp	r3,sp[0x24]
80008c2c:	10 90       	mov	r0,r8
80008c2e:	40 41       	lddsp	r1,sp[0x10]
80008c30:	ed b5 00 05 	bld	r5,0x5
80008c34:	c5 61       	brne	80008ce0 <_vfprintf_r+0x119c>
80008c36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c3a:	40 39       	lddsp	r9,sp[0xc]
80008c3c:	58 09       	cp.w	r9,0
80008c3e:	c2 10       	breq	80008c80 <_vfprintf_r+0x113c>
80008c40:	10 36       	cp.w	r6,r8
80008c42:	c0 74       	brge	80008c50 <_vfprintf_r+0x110c>
80008c44:	fa c8 f9 44 	sub	r8,sp,-1724
80008c48:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c4c:	c2 38       	rjmp	80008c92 <_vfprintf_r+0x114e>
80008c4e:	d7 03       	nop
80008c50:	fa c8 f9 50 	sub	r8,sp,-1712
80008c54:	1a d8       	st.w	--sp,r8
80008c56:	fa c8 fa b8 	sub	r8,sp,-1352
80008c5a:	1a d8       	st.w	--sp,r8
80008c5c:	fa c8 fb b4 	sub	r8,sp,-1100
80008c60:	1a d8       	st.w	--sp,r8
80008c62:	fa c8 f9 40 	sub	r8,sp,-1728
80008c66:	fa c9 ff b4 	sub	r9,sp,-76
80008c6a:	04 9a       	mov	r10,r2
80008c6c:	0c 9b       	mov	r11,r6
80008c6e:	08 9c       	mov	r12,r4
80008c70:	fe b0 f5 d2 	rcall	80007814 <get_arg>
80008c74:	2f dd       	sub	sp,-12
80008c76:	f8 e8 00 00 	ld.d	r8,r12[0]
80008c7a:	fa e9 00 00 	st.d	sp[0],r8
80008c7e:	c2 e8       	rjmp	80008cda <_vfprintf_r+0x1196>
80008c80:	ee ca ff ff 	sub	r10,r7,-1
80008c84:	10 37       	cp.w	r7,r8
80008c86:	c0 b4       	brge	80008c9c <_vfprintf_r+0x1158>
80008c88:	fa c8 f9 44 	sub	r8,sp,-1724
80008c8c:	14 97       	mov	r7,r10
80008c8e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008c92:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c96:	fa eb 00 00 	st.d	sp[0],r10
80008c9a:	c2 08       	rjmp	80008cda <_vfprintf_r+0x1196>
80008c9c:	41 09       	lddsp	r9,sp[0x40]
80008c9e:	59 f8       	cp.w	r8,31
80008ca0:	e0 89 00 16 	brgt	80008ccc <_vfprintf_r+0x1188>
80008ca4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ca8:	f2 cb ff f8 	sub	r11,r9,-8
80008cac:	fa e7 00 00 	st.d	sp[0],r6
80008cb0:	51 0b       	stdsp	sp[0x40],r11
80008cb2:	fa c6 f9 44 	sub	r6,sp,-1724
80008cb6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cba:	fa e6 00 00 	ld.d	r6,sp[0]
80008cbe:	f2 e7 fd 88 	st.d	r9[-632],r6
80008cc2:	2f f8       	sub	r8,-1
80008cc4:	14 97       	mov	r7,r10
80008cc6:	fb 48 06 b4 	st.w	sp[1716],r8
80008cca:	c0 88       	rjmp	80008cda <_vfprintf_r+0x1196>
80008ccc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008cd0:	2f 89       	sub	r9,-8
80008cd2:	fa e7 00 00 	st.d	sp[0],r6
80008cd6:	51 09       	stdsp	sp[0x40],r9
80008cd8:	14 97       	mov	r7,r10
80008cda:	30 18       	mov	r8,1
80008cdc:	e0 8f 01 d0 	bral	8000907c <_vfprintf_r+0x1538>
80008ce0:	ed b5 00 04 	bld	r5,0x4
80008ce4:	c1 61       	brne	80008d10 <_vfprintf_r+0x11cc>
80008ce6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cea:	40 3e       	lddsp	lr,sp[0xc]
80008cec:	58 0e       	cp.w	lr,0
80008cee:	c0 80       	breq	80008cfe <_vfprintf_r+0x11ba>
80008cf0:	10 36       	cp.w	r6,r8
80008cf2:	c6 74       	brge	80008dc0 <_vfprintf_r+0x127c>
80008cf4:	fa cc f9 44 	sub	r12,sp,-1724
80008cf8:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008cfc:	c8 08       	rjmp	80008dfc <_vfprintf_r+0x12b8>
80008cfe:	ee ca ff ff 	sub	r10,r7,-1
80008d02:	10 37       	cp.w	r7,r8
80008d04:	c7 f4       	brge	80008e02 <_vfprintf_r+0x12be>
80008d06:	fa cb f9 44 	sub	r11,sp,-1724
80008d0a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d0e:	c7 68       	rjmp	80008dfa <_vfprintf_r+0x12b6>
80008d10:	ed b5 00 06 	bld	r5,0x6
80008d14:	c4 a1       	brne	80008da8 <_vfprintf_r+0x1264>
80008d16:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d1a:	40 3c       	lddsp	r12,sp[0xc]
80008d1c:	58 0c       	cp.w	r12,0
80008d1e:	c1 d0       	breq	80008d58 <_vfprintf_r+0x1214>
80008d20:	10 36       	cp.w	r6,r8
80008d22:	c0 64       	brge	80008d2e <_vfprintf_r+0x11ea>
80008d24:	fa cb f9 44 	sub	r11,sp,-1724
80008d28:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d2c:	c1 f8       	rjmp	80008d6a <_vfprintf_r+0x1226>
80008d2e:	fa c8 f9 50 	sub	r8,sp,-1712
80008d32:	1a d8       	st.w	--sp,r8
80008d34:	fa c8 fa b8 	sub	r8,sp,-1352
80008d38:	1a d8       	st.w	--sp,r8
80008d3a:	fa c8 fb b4 	sub	r8,sp,-1100
80008d3e:	1a d8       	st.w	--sp,r8
80008d40:	fa c8 f9 40 	sub	r8,sp,-1728
80008d44:	fa c9 ff b4 	sub	r9,sp,-76
80008d48:	04 9a       	mov	r10,r2
80008d4a:	0c 9b       	mov	r11,r6
80008d4c:	08 9c       	mov	r12,r4
80008d4e:	fe b0 f5 63 	rcall	80007814 <get_arg>
80008d52:	2f dd       	sub	sp,-12
80008d54:	98 18       	ld.sh	r8,r12[0x2]
80008d56:	c2 68       	rjmp	80008da2 <_vfprintf_r+0x125e>
80008d58:	ee ca ff ff 	sub	r10,r7,-1
80008d5c:	10 37       	cp.w	r7,r8
80008d5e:	c0 94       	brge	80008d70 <_vfprintf_r+0x122c>
80008d60:	fa c9 f9 44 	sub	r9,sp,-1724
80008d64:	14 97       	mov	r7,r10
80008d66:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d6a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d6e:	c1 a8       	rjmp	80008da2 <_vfprintf_r+0x125e>
80008d70:	41 09       	lddsp	r9,sp[0x40]
80008d72:	59 f8       	cp.w	r8,31
80008d74:	e0 89 00 13 	brgt	80008d9a <_vfprintf_r+0x1256>
80008d78:	f2 cb ff fc 	sub	r11,r9,-4
80008d7c:	51 0b       	stdsp	sp[0x40],r11
80008d7e:	72 09       	ld.w	r9,r9[0x0]
80008d80:	fa c6 f9 44 	sub	r6,sp,-1724
80008d84:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d88:	2f f8       	sub	r8,-1
80008d8a:	f7 49 fd 88 	st.w	r11[-632],r9
80008d8e:	fb 48 06 b4 	st.w	sp[1716],r8
80008d92:	14 97       	mov	r7,r10
80008d94:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d98:	c0 58       	rjmp	80008da2 <_vfprintf_r+0x125e>
80008d9a:	92 18       	ld.sh	r8,r9[0x2]
80008d9c:	14 97       	mov	r7,r10
80008d9e:	2f c9       	sub	r9,-4
80008da0:	51 09       	stdsp	sp[0x40],r9
80008da2:	5c 78       	castu.h	r8
80008da4:	50 18       	stdsp	sp[0x4],r8
80008da6:	c4 68       	rjmp	80008e32 <_vfprintf_r+0x12ee>
80008da8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dac:	40 3c       	lddsp	r12,sp[0xc]
80008dae:	58 0c       	cp.w	r12,0
80008db0:	c1 d0       	breq	80008dea <_vfprintf_r+0x12a6>
80008db2:	10 36       	cp.w	r6,r8
80008db4:	c0 64       	brge	80008dc0 <_vfprintf_r+0x127c>
80008db6:	fa cb f9 44 	sub	r11,sp,-1724
80008dba:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dbe:	c1 f8       	rjmp	80008dfc <_vfprintf_r+0x12b8>
80008dc0:	fa c8 f9 50 	sub	r8,sp,-1712
80008dc4:	1a d8       	st.w	--sp,r8
80008dc6:	fa c8 fa b8 	sub	r8,sp,-1352
80008dca:	0c 9b       	mov	r11,r6
80008dcc:	1a d8       	st.w	--sp,r8
80008dce:	fa c8 fb b4 	sub	r8,sp,-1100
80008dd2:	04 9a       	mov	r10,r2
80008dd4:	1a d8       	st.w	--sp,r8
80008dd6:	08 9c       	mov	r12,r4
80008dd8:	fa c8 f9 40 	sub	r8,sp,-1728
80008ddc:	fa c9 ff b4 	sub	r9,sp,-76
80008de0:	fe b0 f5 1a 	rcall	80007814 <get_arg>
80008de4:	2f dd       	sub	sp,-12
80008de6:	78 0b       	ld.w	r11,r12[0x0]
80008de8:	c2 48       	rjmp	80008e30 <_vfprintf_r+0x12ec>
80008dea:	ee ca ff ff 	sub	r10,r7,-1
80008dee:	10 37       	cp.w	r7,r8
80008df0:	c0 94       	brge	80008e02 <_vfprintf_r+0x12be>
80008df2:	fa c9 f9 44 	sub	r9,sp,-1724
80008df6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dfa:	14 97       	mov	r7,r10
80008dfc:	ec fb fd 88 	ld.w	r11,r6[-632]
80008e00:	c1 88       	rjmp	80008e30 <_vfprintf_r+0x12ec>
80008e02:	41 09       	lddsp	r9,sp[0x40]
80008e04:	59 f8       	cp.w	r8,31
80008e06:	e0 89 00 11 	brgt	80008e28 <_vfprintf_r+0x12e4>
80008e0a:	f2 cb ff fc 	sub	r11,r9,-4
80008e0e:	51 0b       	stdsp	sp[0x40],r11
80008e10:	fa c6 f9 44 	sub	r6,sp,-1724
80008e14:	72 0b       	ld.w	r11,r9[0x0]
80008e16:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e1a:	f3 4b fd 88 	st.w	r9[-632],r11
80008e1e:	2f f8       	sub	r8,-1
80008e20:	14 97       	mov	r7,r10
80008e22:	fb 48 06 b4 	st.w	sp[1716],r8
80008e26:	c0 58       	rjmp	80008e30 <_vfprintf_r+0x12ec>
80008e28:	72 0b       	ld.w	r11,r9[0x0]
80008e2a:	14 97       	mov	r7,r10
80008e2c:	2f c9       	sub	r9,-4
80008e2e:	51 09       	stdsp	sp[0x40],r9
80008e30:	50 1b       	stdsp	sp[0x4],r11
80008e32:	30 0e       	mov	lr,0
80008e34:	30 18       	mov	r8,1
80008e36:	50 0e       	stdsp	sp[0x0],lr
80008e38:	c2 29       	rjmp	8000907c <_vfprintf_r+0x1538>
80008e3a:	50 a7       	stdsp	sp[0x28],r7
80008e3c:	50 80       	stdsp	sp[0x20],r0
80008e3e:	0c 97       	mov	r7,r6
80008e40:	04 94       	mov	r4,r2
80008e42:	06 96       	mov	r6,r3
80008e44:	02 92       	mov	r2,r1
80008e46:	fe cc b4 ce 	sub	r12,pc,-19250
80008e4a:	40 93       	lddsp	r3,sp[0x24]
80008e4c:	10 90       	mov	r0,r8
80008e4e:	40 41       	lddsp	r1,sp[0x10]
80008e50:	50 dc       	stdsp	sp[0x34],r12
80008e52:	ed b5 00 05 	bld	r5,0x5
80008e56:	c5 51       	brne	80008f00 <_vfprintf_r+0x13bc>
80008e58:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e5c:	40 3b       	lddsp	r11,sp[0xc]
80008e5e:	58 0b       	cp.w	r11,0
80008e60:	c2 20       	breq	80008ea4 <_vfprintf_r+0x1360>
80008e62:	10 36       	cp.w	r6,r8
80008e64:	c0 a4       	brge	80008e78 <_vfprintf_r+0x1334>
80008e66:	fa ca f9 44 	sub	r10,sp,-1724
80008e6a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e6e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008e72:	fa e9 00 00 	st.d	sp[0],r8
80008e76:	cf 28       	rjmp	8000905a <_vfprintf_r+0x1516>
80008e78:	fa c8 f9 50 	sub	r8,sp,-1712
80008e7c:	1a d8       	st.w	--sp,r8
80008e7e:	fa c8 fa b8 	sub	r8,sp,-1352
80008e82:	04 9a       	mov	r10,r2
80008e84:	1a d8       	st.w	--sp,r8
80008e86:	0c 9b       	mov	r11,r6
80008e88:	fa c8 fb b4 	sub	r8,sp,-1100
80008e8c:	08 9c       	mov	r12,r4
80008e8e:	1a d8       	st.w	--sp,r8
80008e90:	fa c8 f9 40 	sub	r8,sp,-1728
80008e94:	fa c9 ff b4 	sub	r9,sp,-76
80008e98:	fe b0 f4 be 	rcall	80007814 <get_arg>
80008e9c:	2f dd       	sub	sp,-12
80008e9e:	f8 ea 00 00 	ld.d	r10,r12[0]
80008ea2:	c0 c8       	rjmp	80008eba <_vfprintf_r+0x1376>
80008ea4:	ee ca ff ff 	sub	r10,r7,-1
80008ea8:	10 37       	cp.w	r7,r8
80008eaa:	c0 b4       	brge	80008ec0 <_vfprintf_r+0x137c>
80008eac:	fa c9 f9 44 	sub	r9,sp,-1724
80008eb0:	14 97       	mov	r7,r10
80008eb2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eb6:	ec ea fd 88 	ld.d	r10,r6[-632]
80008eba:	fa eb 00 00 	st.d	sp[0],r10
80008ebe:	cc e8       	rjmp	8000905a <_vfprintf_r+0x1516>
80008ec0:	41 09       	lddsp	r9,sp[0x40]
80008ec2:	59 f8       	cp.w	r8,31
80008ec4:	e0 89 00 16 	brgt	80008ef0 <_vfprintf_r+0x13ac>
80008ec8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ecc:	f2 cb ff f8 	sub	r11,r9,-8
80008ed0:	fa e7 00 00 	st.d	sp[0],r6
80008ed4:	51 0b       	stdsp	sp[0x40],r11
80008ed6:	fa c6 f9 44 	sub	r6,sp,-1724
80008eda:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ede:	fa e6 00 00 	ld.d	r6,sp[0]
80008ee2:	f2 e7 fd 88 	st.d	r9[-632],r6
80008ee6:	2f f8       	sub	r8,-1
80008ee8:	14 97       	mov	r7,r10
80008eea:	fb 48 06 b4 	st.w	sp[1716],r8
80008eee:	cb 68       	rjmp	8000905a <_vfprintf_r+0x1516>
80008ef0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ef4:	2f 89       	sub	r9,-8
80008ef6:	fa e7 00 00 	st.d	sp[0],r6
80008efa:	51 09       	stdsp	sp[0x40],r9
80008efc:	14 97       	mov	r7,r10
80008efe:	ca e8       	rjmp	8000905a <_vfprintf_r+0x1516>
80008f00:	ed b5 00 04 	bld	r5,0x4
80008f04:	c1 71       	brne	80008f32 <_vfprintf_r+0x13ee>
80008f06:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f0a:	40 3e       	lddsp	lr,sp[0xc]
80008f0c:	58 0e       	cp.w	lr,0
80008f0e:	c0 80       	breq	80008f1e <_vfprintf_r+0x13da>
80008f10:	10 36       	cp.w	r6,r8
80008f12:	c6 94       	brge	80008fe4 <_vfprintf_r+0x14a0>
80008f14:	fa cc f9 44 	sub	r12,sp,-1724
80008f18:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f1c:	c8 28       	rjmp	80009020 <_vfprintf_r+0x14dc>
80008f1e:	ee ca ff ff 	sub	r10,r7,-1
80008f22:	10 37       	cp.w	r7,r8
80008f24:	e0 84 00 81 	brge	80009026 <_vfprintf_r+0x14e2>
80008f28:	fa cb f9 44 	sub	r11,sp,-1724
80008f2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f30:	c7 78       	rjmp	8000901e <_vfprintf_r+0x14da>
80008f32:	ed b5 00 06 	bld	r5,0x6
80008f36:	c4 b1       	brne	80008fcc <_vfprintf_r+0x1488>
80008f38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f3c:	40 3c       	lddsp	r12,sp[0xc]
80008f3e:	58 0c       	cp.w	r12,0
80008f40:	c1 d0       	breq	80008f7a <_vfprintf_r+0x1436>
80008f42:	10 36       	cp.w	r6,r8
80008f44:	c0 64       	brge	80008f50 <_vfprintf_r+0x140c>
80008f46:	fa cb f9 44 	sub	r11,sp,-1724
80008f4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f4e:	c1 f8       	rjmp	80008f8c <_vfprintf_r+0x1448>
80008f50:	fa c8 f9 50 	sub	r8,sp,-1712
80008f54:	1a d8       	st.w	--sp,r8
80008f56:	fa c8 fa b8 	sub	r8,sp,-1352
80008f5a:	1a d8       	st.w	--sp,r8
80008f5c:	fa c8 fb b4 	sub	r8,sp,-1100
80008f60:	1a d8       	st.w	--sp,r8
80008f62:	fa c8 f9 40 	sub	r8,sp,-1728
80008f66:	fa c9 ff b4 	sub	r9,sp,-76
80008f6a:	04 9a       	mov	r10,r2
80008f6c:	0c 9b       	mov	r11,r6
80008f6e:	08 9c       	mov	r12,r4
80008f70:	fe b0 f4 52 	rcall	80007814 <get_arg>
80008f74:	2f dd       	sub	sp,-12
80008f76:	98 18       	ld.sh	r8,r12[0x2]
80008f78:	c2 78       	rjmp	80008fc6 <_vfprintf_r+0x1482>
80008f7a:	ee ca ff ff 	sub	r10,r7,-1
80008f7e:	10 37       	cp.w	r7,r8
80008f80:	c0 a4       	brge	80008f94 <_vfprintf_r+0x1450>
80008f82:	fa c9 f9 44 	sub	r9,sp,-1724
80008f86:	14 97       	mov	r7,r10
80008f88:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f8c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008f90:	c1 b8       	rjmp	80008fc6 <_vfprintf_r+0x1482>
80008f92:	d7 03       	nop
80008f94:	41 09       	lddsp	r9,sp[0x40]
80008f96:	59 f8       	cp.w	r8,31
80008f98:	e0 89 00 13 	brgt	80008fbe <_vfprintf_r+0x147a>
80008f9c:	f2 cb ff fc 	sub	r11,r9,-4
80008fa0:	51 0b       	stdsp	sp[0x40],r11
80008fa2:	72 09       	ld.w	r9,r9[0x0]
80008fa4:	fa c6 f9 44 	sub	r6,sp,-1724
80008fa8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008fac:	2f f8       	sub	r8,-1
80008fae:	f7 49 fd 88 	st.w	r11[-632],r9
80008fb2:	fb 48 06 b4 	st.w	sp[1716],r8
80008fb6:	14 97       	mov	r7,r10
80008fb8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008fbc:	c0 58       	rjmp	80008fc6 <_vfprintf_r+0x1482>
80008fbe:	92 18       	ld.sh	r8,r9[0x2]
80008fc0:	14 97       	mov	r7,r10
80008fc2:	2f c9       	sub	r9,-4
80008fc4:	51 09       	stdsp	sp[0x40],r9
80008fc6:	5c 78       	castu.h	r8
80008fc8:	50 18       	stdsp	sp[0x4],r8
80008fca:	c4 68       	rjmp	80009056 <_vfprintf_r+0x1512>
80008fcc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fd0:	40 3c       	lddsp	r12,sp[0xc]
80008fd2:	58 0c       	cp.w	r12,0
80008fd4:	c1 d0       	breq	8000900e <_vfprintf_r+0x14ca>
80008fd6:	10 36       	cp.w	r6,r8
80008fd8:	c0 64       	brge	80008fe4 <_vfprintf_r+0x14a0>
80008fda:	fa cb f9 44 	sub	r11,sp,-1724
80008fde:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fe2:	c1 f8       	rjmp	80009020 <_vfprintf_r+0x14dc>
80008fe4:	fa c8 f9 50 	sub	r8,sp,-1712
80008fe8:	1a d8       	st.w	--sp,r8
80008fea:	fa c8 fa b8 	sub	r8,sp,-1352
80008fee:	0c 9b       	mov	r11,r6
80008ff0:	1a d8       	st.w	--sp,r8
80008ff2:	fa c8 fb b4 	sub	r8,sp,-1100
80008ff6:	04 9a       	mov	r10,r2
80008ff8:	1a d8       	st.w	--sp,r8
80008ffa:	08 9c       	mov	r12,r4
80008ffc:	fa c8 f9 40 	sub	r8,sp,-1728
80009000:	fa c9 ff b4 	sub	r9,sp,-76
80009004:	fe b0 f4 08 	rcall	80007814 <get_arg>
80009008:	2f dd       	sub	sp,-12
8000900a:	78 0b       	ld.w	r11,r12[0x0]
8000900c:	c2 48       	rjmp	80009054 <_vfprintf_r+0x1510>
8000900e:	ee ca ff ff 	sub	r10,r7,-1
80009012:	10 37       	cp.w	r7,r8
80009014:	c0 94       	brge	80009026 <_vfprintf_r+0x14e2>
80009016:	fa c9 f9 44 	sub	r9,sp,-1724
8000901a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000901e:	14 97       	mov	r7,r10
80009020:	ec fb fd 88 	ld.w	r11,r6[-632]
80009024:	c1 88       	rjmp	80009054 <_vfprintf_r+0x1510>
80009026:	41 09       	lddsp	r9,sp[0x40]
80009028:	59 f8       	cp.w	r8,31
8000902a:	e0 89 00 11 	brgt	8000904c <_vfprintf_r+0x1508>
8000902e:	f2 cb ff fc 	sub	r11,r9,-4
80009032:	51 0b       	stdsp	sp[0x40],r11
80009034:	fa c6 f9 44 	sub	r6,sp,-1724
80009038:	72 0b       	ld.w	r11,r9[0x0]
8000903a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000903e:	f3 4b fd 88 	st.w	r9[-632],r11
80009042:	2f f8       	sub	r8,-1
80009044:	14 97       	mov	r7,r10
80009046:	fb 48 06 b4 	st.w	sp[1716],r8
8000904a:	c0 58       	rjmp	80009054 <_vfprintf_r+0x1510>
8000904c:	72 0b       	ld.w	r11,r9[0x0]
8000904e:	14 97       	mov	r7,r10
80009050:	2f c9       	sub	r9,-4
80009052:	51 09       	stdsp	sp[0x40],r9
80009054:	50 1b       	stdsp	sp[0x4],r11
80009056:	30 0e       	mov	lr,0
80009058:	50 0e       	stdsp	sp[0x0],lr
8000905a:	40 08       	lddsp	r8,sp[0x0]
8000905c:	40 1c       	lddsp	r12,sp[0x4]
8000905e:	18 48       	or	r8,r12
80009060:	5f 19       	srne	r9
80009062:	0a 98       	mov	r8,r5
80009064:	eb e9 00 09 	and	r9,r5,r9
80009068:	a1 b8       	sbr	r8,0x1
8000906a:	58 09       	cp.w	r9,0
8000906c:	c0 70       	breq	8000907a <_vfprintf_r+0x1536>
8000906e:	10 95       	mov	r5,r8
80009070:	fb 60 06 b9 	st.b	sp[1721],r0
80009074:	33 08       	mov	r8,48
80009076:	fb 68 06 b8 	st.b	sp[1720],r8
8000907a:	30 28       	mov	r8,2
8000907c:	30 09       	mov	r9,0
8000907e:	fb 69 06 bb 	st.b	sp[1723],r9
80009082:	0a 99       	mov	r9,r5
80009084:	a7 d9       	cbr	r9,0x7
80009086:	40 2b       	lddsp	r11,sp[0x8]
80009088:	40 16       	lddsp	r6,sp[0x4]
8000908a:	58 0b       	cp.w	r11,0
8000908c:	5f 1a       	srne	r10
8000908e:	f2 05 17 40 	movge	r5,r9
80009092:	fa c2 f9 78 	sub	r2,sp,-1672
80009096:	40 09       	lddsp	r9,sp[0x0]
80009098:	0c 49       	or	r9,r6
8000909a:	5f 19       	srne	r9
8000909c:	f5 e9 10 09 	or	r9,r10,r9
800090a0:	c5 c0       	breq	80009158 <_vfprintf_r+0x1614>
800090a2:	30 19       	mov	r9,1
800090a4:	f2 08 18 00 	cp.b	r8,r9
800090a8:	c0 60       	breq	800090b4 <_vfprintf_r+0x1570>
800090aa:	30 29       	mov	r9,2
800090ac:	f2 08 18 00 	cp.b	r8,r9
800090b0:	c0 41       	brne	800090b8 <_vfprintf_r+0x1574>
800090b2:	c3 c8       	rjmp	8000912a <_vfprintf_r+0x15e6>
800090b4:	04 96       	mov	r6,r2
800090b6:	c3 08       	rjmp	80009116 <_vfprintf_r+0x15d2>
800090b8:	04 96       	mov	r6,r2
800090ba:	fa e8 00 00 	ld.d	r8,sp[0]
800090be:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800090c2:	2d 0a       	sub	r10,-48
800090c4:	0c fa       	st.b	--r6,r10
800090c6:	f0 0b 16 03 	lsr	r11,r8,0x3
800090ca:	f2 0c 16 03 	lsr	r12,r9,0x3
800090ce:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800090d2:	18 99       	mov	r9,r12
800090d4:	16 98       	mov	r8,r11
800090d6:	58 08       	cp.w	r8,0
800090d8:	5c 29       	cpc	r9
800090da:	cf 21       	brne	800090be <_vfprintf_r+0x157a>
800090dc:	fa e9 00 00 	st.d	sp[0],r8
800090e0:	ed b5 00 00 	bld	r5,0x0
800090e4:	c4 51       	brne	8000916e <_vfprintf_r+0x162a>
800090e6:	33 09       	mov	r9,48
800090e8:	f2 0a 18 00 	cp.b	r10,r9
800090ec:	c4 10       	breq	8000916e <_vfprintf_r+0x162a>
800090ee:	0c f9       	st.b	--r6,r9
800090f0:	c3 f8       	rjmp	8000916e <_vfprintf_r+0x162a>
800090f2:	fa ea 00 00 	ld.d	r10,sp[0]
800090f6:	30 a8       	mov	r8,10
800090f8:	30 09       	mov	r9,0
800090fa:	e0 a0 1a 19 	rcall	8000c52c <__avr32_umod64>
800090fe:	30 a8       	mov	r8,10
80009100:	2d 0a       	sub	r10,-48
80009102:	30 09       	mov	r9,0
80009104:	ac 8a       	st.b	r6[0x0],r10
80009106:	fa ea 00 00 	ld.d	r10,sp[0]
8000910a:	e0 a0 18 df 	rcall	8000c2c8 <__avr32_udiv64>
8000910e:	16 99       	mov	r9,r11
80009110:	14 98       	mov	r8,r10
80009112:	fa e9 00 00 	st.d	sp[0],r8
80009116:	20 16       	sub	r6,1
80009118:	fa ea 00 00 	ld.d	r10,sp[0]
8000911c:	58 9a       	cp.w	r10,9
8000911e:	5c 2b       	cpc	r11
80009120:	fe 9b ff e9 	brhi	800090f2 <_vfprintf_r+0x15ae>
80009124:	1b f8       	ld.ub	r8,sp[0x7]
80009126:	2d 08       	sub	r8,-48
80009128:	c2 08       	rjmp	80009168 <_vfprintf_r+0x1624>
8000912a:	04 96       	mov	r6,r2
8000912c:	fa e8 00 00 	ld.d	r8,sp[0]
80009130:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009134:	40 de       	lddsp	lr,sp[0x34]
80009136:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000913a:	0c fa       	st.b	--r6,r10
8000913c:	f2 0b 16 04 	lsr	r11,r9,0x4
80009140:	f0 0a 16 04 	lsr	r10,r8,0x4
80009144:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009148:	16 99       	mov	r9,r11
8000914a:	14 98       	mov	r8,r10
8000914c:	58 08       	cp.w	r8,0
8000914e:	5c 29       	cpc	r9
80009150:	cf 01       	brne	80009130 <_vfprintf_r+0x15ec>
80009152:	fa e9 00 00 	st.d	sp[0],r8
80009156:	c0 c8       	rjmp	8000916e <_vfprintf_r+0x162a>
80009158:	58 08       	cp.w	r8,0
8000915a:	c0 91       	brne	8000916c <_vfprintf_r+0x1628>
8000915c:	ed b5 00 00 	bld	r5,0x0
80009160:	c0 61       	brne	8000916c <_vfprintf_r+0x1628>
80009162:	fa c6 f9 79 	sub	r6,sp,-1671
80009166:	33 08       	mov	r8,48
80009168:	ac 88       	st.b	r6[0x0],r8
8000916a:	c0 28       	rjmp	8000916e <_vfprintf_r+0x162a>
8000916c:	04 96       	mov	r6,r2
8000916e:	0c 12       	sub	r2,r6
80009170:	c1 c8       	rjmp	800091a8 <_vfprintf_r+0x1664>
80009172:	50 a7       	stdsp	sp[0x28],r7
80009174:	50 80       	stdsp	sp[0x20],r0
80009176:	40 93       	lddsp	r3,sp[0x24]
80009178:	0c 97       	mov	r7,r6
8000917a:	10 90       	mov	r0,r8
8000917c:	04 94       	mov	r4,r2
8000917e:	40 41       	lddsp	r1,sp[0x10]
80009180:	58 08       	cp.w	r8,0
80009182:	e0 80 04 4f 	breq	80009a20 <_vfprintf_r+0x1edc>
80009186:	fb 68 06 60 	st.b	sp[1632],r8
8000918a:	30 0c       	mov	r12,0
8000918c:	30 08       	mov	r8,0
8000918e:	30 12       	mov	r2,1
80009190:	fb 68 06 bb 	st.b	sp[1723],r8
80009194:	50 2c       	stdsp	sp[0x8],r12
80009196:	fa c6 f9 a0 	sub	r6,sp,-1632
8000919a:	c0 78       	rjmp	800091a8 <_vfprintf_r+0x1664>
8000919c:	30 0b       	mov	r11,0
8000919e:	50 2b       	stdsp	sp[0x8],r11
800091a0:	c0 48       	rjmp	800091a8 <_vfprintf_r+0x1664>
800091a2:	40 22       	lddsp	r2,sp[0x8]
800091a4:	30 0a       	mov	r10,0
800091a6:	50 2a       	stdsp	sp[0x8],r10
800091a8:	40 29       	lddsp	r9,sp[0x8]
800091aa:	e4 09 0c 49 	max	r9,r2,r9
800091ae:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800091b2:	50 39       	stdsp	sp[0xc],r9
800091b4:	0a 9e       	mov	lr,r5
800091b6:	30 09       	mov	r9,0
800091b8:	e2 1e 00 02 	andl	lr,0x2,COH
800091bc:	f2 08 18 00 	cp.b	r8,r9
800091c0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800091c4:	f7 b8 01 ff 	subne	r8,-1
800091c8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800091cc:	0a 9b       	mov	r11,r5
800091ce:	58 0e       	cp.w	lr,0
800091d0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800091d4:	f7 bc 01 fe 	subne	r12,-2
800091d8:	fb fc 1a 03 	st.wne	sp[0xc],r12
800091dc:	e2 1b 00 84 	andl	r11,0x84,COH
800091e0:	50 fe       	stdsp	sp[0x3c],lr
800091e2:	50 9b       	stdsp	sp[0x24],r11
800091e4:	c4 71       	brne	80009272 <_vfprintf_r+0x172e>
800091e6:	40 8a       	lddsp	r10,sp[0x20]
800091e8:	40 39       	lddsp	r9,sp[0xc]
800091ea:	12 1a       	sub	r10,r9
800091ec:	50 4a       	stdsp	sp[0x10],r10
800091ee:	58 0a       	cp.w	r10,0
800091f0:	e0 89 00 20 	brgt	80009230 <_vfprintf_r+0x16ec>
800091f4:	c3 f8       	rjmp	80009272 <_vfprintf_r+0x172e>
800091f6:	2f 09       	sub	r9,-16
800091f8:	2f f8       	sub	r8,-1
800091fa:	fe ce b8 6a 	sub	lr,pc,-18326
800091fe:	31 0c       	mov	r12,16
80009200:	fb 49 06 90 	st.w	sp[1680],r9
80009204:	87 0e       	st.w	r3[0x0],lr
80009206:	87 1c       	st.w	r3[0x4],r12
80009208:	fb 48 06 8c 	st.w	sp[1676],r8
8000920c:	58 78       	cp.w	r8,7
8000920e:	e0 89 00 04 	brgt	80009216 <_vfprintf_r+0x16d2>
80009212:	2f 83       	sub	r3,-8
80009214:	c0 b8       	rjmp	8000922a <_vfprintf_r+0x16e6>
80009216:	fa ca f9 78 	sub	r10,sp,-1672
8000921a:	02 9b       	mov	r11,r1
8000921c:	08 9c       	mov	r12,r4
8000921e:	fe b0 f4 85 	rcall	80007b28 <__sprint_r>
80009222:	e0 81 04 10 	brne	80009a42 <_vfprintf_r+0x1efe>
80009226:	fa c3 f9 e0 	sub	r3,sp,-1568
8000922a:	40 4b       	lddsp	r11,sp[0x10]
8000922c:	21 0b       	sub	r11,16
8000922e:	50 4b       	stdsp	sp[0x10],r11
80009230:	fa f9 06 90 	ld.w	r9,sp[1680]
80009234:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009238:	fe ca b8 a8 	sub	r10,pc,-18264
8000923c:	40 4e       	lddsp	lr,sp[0x10]
8000923e:	59 0e       	cp.w	lr,16
80009240:	fe 99 ff db 	brgt	800091f6 <_vfprintf_r+0x16b2>
80009244:	1c 09       	add	r9,lr
80009246:	2f f8       	sub	r8,-1
80009248:	87 0a       	st.w	r3[0x0],r10
8000924a:	fb 49 06 90 	st.w	sp[1680],r9
8000924e:	87 1e       	st.w	r3[0x4],lr
80009250:	fb 48 06 8c 	st.w	sp[1676],r8
80009254:	58 78       	cp.w	r8,7
80009256:	e0 89 00 04 	brgt	8000925e <_vfprintf_r+0x171a>
8000925a:	2f 83       	sub	r3,-8
8000925c:	c0 b8       	rjmp	80009272 <_vfprintf_r+0x172e>
8000925e:	fa ca f9 78 	sub	r10,sp,-1672
80009262:	02 9b       	mov	r11,r1
80009264:	08 9c       	mov	r12,r4
80009266:	fe b0 f4 61 	rcall	80007b28 <__sprint_r>
8000926a:	e0 81 03 ec 	brne	80009a42 <_vfprintf_r+0x1efe>
8000926e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009272:	30 09       	mov	r9,0
80009274:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009278:	f2 08 18 00 	cp.b	r8,r9
8000927c:	c1 f0       	breq	800092ba <_vfprintf_r+0x1776>
8000927e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009282:	fa c9 f9 45 	sub	r9,sp,-1723
80009286:	2f f8       	sub	r8,-1
80009288:	87 09       	st.w	r3[0x0],r9
8000928a:	fb 48 06 90 	st.w	sp[1680],r8
8000928e:	30 19       	mov	r9,1
80009290:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009294:	87 19       	st.w	r3[0x4],r9
80009296:	2f f8       	sub	r8,-1
80009298:	fb 48 06 8c 	st.w	sp[1676],r8
8000929c:	58 78       	cp.w	r8,7
8000929e:	e0 89 00 04 	brgt	800092a6 <_vfprintf_r+0x1762>
800092a2:	2f 83       	sub	r3,-8
800092a4:	c0 b8       	rjmp	800092ba <_vfprintf_r+0x1776>
800092a6:	fa ca f9 78 	sub	r10,sp,-1672
800092aa:	02 9b       	mov	r11,r1
800092ac:	08 9c       	mov	r12,r4
800092ae:	fe b0 f4 3d 	rcall	80007b28 <__sprint_r>
800092b2:	e0 81 03 c8 	brne	80009a42 <_vfprintf_r+0x1efe>
800092b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800092ba:	40 fc       	lddsp	r12,sp[0x3c]
800092bc:	58 0c       	cp.w	r12,0
800092be:	c1 f0       	breq	800092fc <_vfprintf_r+0x17b8>
800092c0:	fa f8 06 90 	ld.w	r8,sp[1680]
800092c4:	fa c9 f9 48 	sub	r9,sp,-1720
800092c8:	2f e8       	sub	r8,-2
800092ca:	87 09       	st.w	r3[0x0],r9
800092cc:	fb 48 06 90 	st.w	sp[1680],r8
800092d0:	30 29       	mov	r9,2
800092d2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092d6:	87 19       	st.w	r3[0x4],r9
800092d8:	2f f8       	sub	r8,-1
800092da:	fb 48 06 8c 	st.w	sp[1676],r8
800092de:	58 78       	cp.w	r8,7
800092e0:	e0 89 00 04 	brgt	800092e8 <_vfprintf_r+0x17a4>
800092e4:	2f 83       	sub	r3,-8
800092e6:	c0 b8       	rjmp	800092fc <_vfprintf_r+0x17b8>
800092e8:	fa ca f9 78 	sub	r10,sp,-1672
800092ec:	02 9b       	mov	r11,r1
800092ee:	08 9c       	mov	r12,r4
800092f0:	fe b0 f4 1c 	rcall	80007b28 <__sprint_r>
800092f4:	e0 81 03 a7 	brne	80009a42 <_vfprintf_r+0x1efe>
800092f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800092fc:	40 9b       	lddsp	r11,sp[0x24]
800092fe:	e0 4b 00 80 	cp.w	r11,128
80009302:	c4 71       	brne	80009390 <_vfprintf_r+0x184c>
80009304:	40 8a       	lddsp	r10,sp[0x20]
80009306:	40 39       	lddsp	r9,sp[0xc]
80009308:	12 1a       	sub	r10,r9
8000930a:	50 4a       	stdsp	sp[0x10],r10
8000930c:	58 0a       	cp.w	r10,0
8000930e:	e0 89 00 20 	brgt	8000934e <_vfprintf_r+0x180a>
80009312:	c3 f8       	rjmp	80009390 <_vfprintf_r+0x184c>
80009314:	2f 09       	sub	r9,-16
80009316:	2f f8       	sub	r8,-1
80009318:	fe ce b9 78 	sub	lr,pc,-18056
8000931c:	31 0c       	mov	r12,16
8000931e:	fb 49 06 90 	st.w	sp[1680],r9
80009322:	87 0e       	st.w	r3[0x0],lr
80009324:	87 1c       	st.w	r3[0x4],r12
80009326:	fb 48 06 8c 	st.w	sp[1676],r8
8000932a:	58 78       	cp.w	r8,7
8000932c:	e0 89 00 04 	brgt	80009334 <_vfprintf_r+0x17f0>
80009330:	2f 83       	sub	r3,-8
80009332:	c0 b8       	rjmp	80009348 <_vfprintf_r+0x1804>
80009334:	fa ca f9 78 	sub	r10,sp,-1672
80009338:	02 9b       	mov	r11,r1
8000933a:	08 9c       	mov	r12,r4
8000933c:	fe b0 f3 f6 	rcall	80007b28 <__sprint_r>
80009340:	e0 81 03 81 	brne	80009a42 <_vfprintf_r+0x1efe>
80009344:	fa c3 f9 e0 	sub	r3,sp,-1568
80009348:	40 4b       	lddsp	r11,sp[0x10]
8000934a:	21 0b       	sub	r11,16
8000934c:	50 4b       	stdsp	sp[0x10],r11
8000934e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009352:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009356:	fe ca b9 b6 	sub	r10,pc,-17994
8000935a:	40 4e       	lddsp	lr,sp[0x10]
8000935c:	59 0e       	cp.w	lr,16
8000935e:	fe 99 ff db 	brgt	80009314 <_vfprintf_r+0x17d0>
80009362:	1c 09       	add	r9,lr
80009364:	2f f8       	sub	r8,-1
80009366:	87 0a       	st.w	r3[0x0],r10
80009368:	fb 49 06 90 	st.w	sp[1680],r9
8000936c:	87 1e       	st.w	r3[0x4],lr
8000936e:	fb 48 06 8c 	st.w	sp[1676],r8
80009372:	58 78       	cp.w	r8,7
80009374:	e0 89 00 04 	brgt	8000937c <_vfprintf_r+0x1838>
80009378:	2f 83       	sub	r3,-8
8000937a:	c0 b8       	rjmp	80009390 <_vfprintf_r+0x184c>
8000937c:	fa ca f9 78 	sub	r10,sp,-1672
80009380:	02 9b       	mov	r11,r1
80009382:	08 9c       	mov	r12,r4
80009384:	fe b0 f3 d2 	rcall	80007b28 <__sprint_r>
80009388:	e0 81 03 5d 	brne	80009a42 <_vfprintf_r+0x1efe>
8000938c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009390:	40 2c       	lddsp	r12,sp[0x8]
80009392:	04 1c       	sub	r12,r2
80009394:	50 2c       	stdsp	sp[0x8],r12
80009396:	58 0c       	cp.w	r12,0
80009398:	e0 89 00 20 	brgt	800093d8 <_vfprintf_r+0x1894>
8000939c:	c3 f8       	rjmp	8000941a <_vfprintf_r+0x18d6>
8000939e:	2f 09       	sub	r9,-16
800093a0:	2f f8       	sub	r8,-1
800093a2:	fe cb ba 02 	sub	r11,pc,-17918
800093a6:	31 0a       	mov	r10,16
800093a8:	fb 49 06 90 	st.w	sp[1680],r9
800093ac:	87 0b       	st.w	r3[0x0],r11
800093ae:	87 1a       	st.w	r3[0x4],r10
800093b0:	fb 48 06 8c 	st.w	sp[1676],r8
800093b4:	58 78       	cp.w	r8,7
800093b6:	e0 89 00 04 	brgt	800093be <_vfprintf_r+0x187a>
800093ba:	2f 83       	sub	r3,-8
800093bc:	c0 b8       	rjmp	800093d2 <_vfprintf_r+0x188e>
800093be:	fa ca f9 78 	sub	r10,sp,-1672
800093c2:	02 9b       	mov	r11,r1
800093c4:	08 9c       	mov	r12,r4
800093c6:	fe b0 f3 b1 	rcall	80007b28 <__sprint_r>
800093ca:	e0 81 03 3c 	brne	80009a42 <_vfprintf_r+0x1efe>
800093ce:	fa c3 f9 e0 	sub	r3,sp,-1568
800093d2:	40 29       	lddsp	r9,sp[0x8]
800093d4:	21 09       	sub	r9,16
800093d6:	50 29       	stdsp	sp[0x8],r9
800093d8:	fa f9 06 90 	ld.w	r9,sp[1680]
800093dc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093e0:	fe ca ba 40 	sub	r10,pc,-17856
800093e4:	40 2e       	lddsp	lr,sp[0x8]
800093e6:	59 0e       	cp.w	lr,16
800093e8:	fe 99 ff db 	brgt	8000939e <_vfprintf_r+0x185a>
800093ec:	1c 09       	add	r9,lr
800093ee:	2f f8       	sub	r8,-1
800093f0:	87 0a       	st.w	r3[0x0],r10
800093f2:	fb 49 06 90 	st.w	sp[1680],r9
800093f6:	87 1e       	st.w	r3[0x4],lr
800093f8:	fb 48 06 8c 	st.w	sp[1676],r8
800093fc:	58 78       	cp.w	r8,7
800093fe:	e0 89 00 04 	brgt	80009406 <_vfprintf_r+0x18c2>
80009402:	2f 83       	sub	r3,-8
80009404:	c0 b8       	rjmp	8000941a <_vfprintf_r+0x18d6>
80009406:	fa ca f9 78 	sub	r10,sp,-1672
8000940a:	02 9b       	mov	r11,r1
8000940c:	08 9c       	mov	r12,r4
8000940e:	fe b0 f3 8d 	rcall	80007b28 <__sprint_r>
80009412:	e0 81 03 18 	brne	80009a42 <_vfprintf_r+0x1efe>
80009416:	fa c3 f9 e0 	sub	r3,sp,-1568
8000941a:	ed b5 00 08 	bld	r5,0x8
8000941e:	c0 b0       	breq	80009434 <_vfprintf_r+0x18f0>
80009420:	fa f8 06 90 	ld.w	r8,sp[1680]
80009424:	87 12       	st.w	r3[0x4],r2
80009426:	87 06       	st.w	r3[0x0],r6
80009428:	f0 02 00 02 	add	r2,r8,r2
8000942c:	fb 42 06 90 	st.w	sp[1680],r2
80009430:	e0 8f 01 d4 	bral	800097d8 <_vfprintf_r+0x1c94>
80009434:	e0 40 00 65 	cp.w	r0,101
80009438:	e0 8a 01 d6 	brle	800097e4 <_vfprintf_r+0x1ca0>
8000943c:	30 08       	mov	r8,0
8000943e:	30 09       	mov	r9,0
80009440:	40 5b       	lddsp	r11,sp[0x14]
80009442:	40 7a       	lddsp	r10,sp[0x1c]
80009444:	e0 a0 15 3b 	rcall	8000beba <__avr32_f64_cmp_eq>
80009448:	c7 90       	breq	8000953a <_vfprintf_r+0x19f6>
8000944a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000944e:	fe c9 ba c2 	sub	r9,pc,-17726
80009452:	2f f8       	sub	r8,-1
80009454:	87 09       	st.w	r3[0x0],r9
80009456:	fb 48 06 90 	st.w	sp[1680],r8
8000945a:	30 19       	mov	r9,1
8000945c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009460:	87 19       	st.w	r3[0x4],r9
80009462:	2f f8       	sub	r8,-1
80009464:	fb 48 06 8c 	st.w	sp[1676],r8
80009468:	58 78       	cp.w	r8,7
8000946a:	e0 89 00 05 	brgt	80009474 <_vfprintf_r+0x1930>
8000946e:	2f 83       	sub	r3,-8
80009470:	c0 c8       	rjmp	80009488 <_vfprintf_r+0x1944>
80009472:	d7 03       	nop
80009474:	fa ca f9 78 	sub	r10,sp,-1672
80009478:	02 9b       	mov	r11,r1
8000947a:	08 9c       	mov	r12,r4
8000947c:	fe b0 f3 56 	rcall	80007b28 <__sprint_r>
80009480:	e0 81 02 e1 	brne	80009a42 <_vfprintf_r+0x1efe>
80009484:	fa c3 f9 e0 	sub	r3,sp,-1568
80009488:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000948c:	40 6c       	lddsp	r12,sp[0x18]
8000948e:	18 38       	cp.w	r8,r12
80009490:	c0 55       	brlt	8000949a <_vfprintf_r+0x1956>
80009492:	ed b5 00 00 	bld	r5,0x0
80009496:	e0 81 02 6b 	brne	8000996c <_vfprintf_r+0x1e28>
8000949a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000949e:	2f f8       	sub	r8,-1
800094a0:	40 cb       	lddsp	r11,sp[0x30]
800094a2:	fb 48 06 90 	st.w	sp[1680],r8
800094a6:	30 19       	mov	r9,1
800094a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094ac:	87 0b       	st.w	r3[0x0],r11
800094ae:	2f f8       	sub	r8,-1
800094b0:	87 19       	st.w	r3[0x4],r9
800094b2:	fb 48 06 8c 	st.w	sp[1676],r8
800094b6:	58 78       	cp.w	r8,7
800094b8:	e0 89 00 04 	brgt	800094c0 <_vfprintf_r+0x197c>
800094bc:	2f 83       	sub	r3,-8
800094be:	c0 b8       	rjmp	800094d4 <_vfprintf_r+0x1990>
800094c0:	fa ca f9 78 	sub	r10,sp,-1672
800094c4:	02 9b       	mov	r11,r1
800094c6:	08 9c       	mov	r12,r4
800094c8:	fe b0 f3 30 	rcall	80007b28 <__sprint_r>
800094cc:	e0 81 02 bb 	brne	80009a42 <_vfprintf_r+0x1efe>
800094d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800094d4:	40 66       	lddsp	r6,sp[0x18]
800094d6:	20 16       	sub	r6,1
800094d8:	58 06       	cp.w	r6,0
800094da:	e0 89 00 1d 	brgt	80009514 <_vfprintf_r+0x19d0>
800094de:	e0 8f 02 47 	bral	8000996c <_vfprintf_r+0x1e28>
800094e2:	2f 09       	sub	r9,-16
800094e4:	2f f8       	sub	r8,-1
800094e6:	fb 49 06 90 	st.w	sp[1680],r9
800094ea:	87 02       	st.w	r3[0x0],r2
800094ec:	87 10       	st.w	r3[0x4],r0
800094ee:	fb 48 06 8c 	st.w	sp[1676],r8
800094f2:	58 78       	cp.w	r8,7
800094f4:	e0 89 00 04 	brgt	800094fc <_vfprintf_r+0x19b8>
800094f8:	2f 83       	sub	r3,-8
800094fa:	c0 b8       	rjmp	80009510 <_vfprintf_r+0x19cc>
800094fc:	fa ca f9 78 	sub	r10,sp,-1672
80009500:	02 9b       	mov	r11,r1
80009502:	08 9c       	mov	r12,r4
80009504:	fe b0 f3 12 	rcall	80007b28 <__sprint_r>
80009508:	e0 81 02 9d 	brne	80009a42 <_vfprintf_r+0x1efe>
8000950c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009510:	21 06       	sub	r6,16
80009512:	c0 48       	rjmp	8000951a <_vfprintf_r+0x19d6>
80009514:	fe c2 bb 74 	sub	r2,pc,-17548
80009518:	31 00       	mov	r0,16
8000951a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000951e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009522:	fe ca bb 82 	sub	r10,pc,-17534
80009526:	59 06       	cp.w	r6,16
80009528:	fe 99 ff dd 	brgt	800094e2 <_vfprintf_r+0x199e>
8000952c:	0c 09       	add	r9,r6
8000952e:	87 0a       	st.w	r3[0x0],r10
80009530:	fb 49 06 90 	st.w	sp[1680],r9
80009534:	2f f8       	sub	r8,-1
80009536:	87 16       	st.w	r3[0x4],r6
80009538:	c5 39       	rjmp	800097de <_vfprintf_r+0x1c9a>
8000953a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000953e:	58 0a       	cp.w	r10,0
80009540:	e0 89 00 92 	brgt	80009664 <_vfprintf_r+0x1b20>
80009544:	fa f8 06 90 	ld.w	r8,sp[1680]
80009548:	fe c9 bb bc 	sub	r9,pc,-17476
8000954c:	2f f8       	sub	r8,-1
8000954e:	87 09       	st.w	r3[0x0],r9
80009550:	fb 48 06 90 	st.w	sp[1680],r8
80009554:	30 19       	mov	r9,1
80009556:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000955a:	87 19       	st.w	r3[0x4],r9
8000955c:	2f f8       	sub	r8,-1
8000955e:	fb 48 06 8c 	st.w	sp[1676],r8
80009562:	58 78       	cp.w	r8,7
80009564:	e0 89 00 04 	brgt	8000956c <_vfprintf_r+0x1a28>
80009568:	2f 83       	sub	r3,-8
8000956a:	c0 b8       	rjmp	80009580 <_vfprintf_r+0x1a3c>
8000956c:	fa ca f9 78 	sub	r10,sp,-1672
80009570:	02 9b       	mov	r11,r1
80009572:	08 9c       	mov	r12,r4
80009574:	fe b0 f2 da 	rcall	80007b28 <__sprint_r>
80009578:	e0 81 02 65 	brne	80009a42 <_vfprintf_r+0x1efe>
8000957c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009580:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009584:	58 08       	cp.w	r8,0
80009586:	c0 81       	brne	80009596 <_vfprintf_r+0x1a52>
80009588:	40 6a       	lddsp	r10,sp[0x18]
8000958a:	58 0a       	cp.w	r10,0
8000958c:	c0 51       	brne	80009596 <_vfprintf_r+0x1a52>
8000958e:	ed b5 00 00 	bld	r5,0x0
80009592:	e0 81 01 ed 	brne	8000996c <_vfprintf_r+0x1e28>
80009596:	40 c9       	lddsp	r9,sp[0x30]
80009598:	fa f8 06 90 	ld.w	r8,sp[1680]
8000959c:	2f f8       	sub	r8,-1
8000959e:	87 09       	st.w	r3[0x0],r9
800095a0:	fb 48 06 90 	st.w	sp[1680],r8
800095a4:	30 19       	mov	r9,1
800095a6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095aa:	87 19       	st.w	r3[0x4],r9
800095ac:	2f f8       	sub	r8,-1
800095ae:	fb 48 06 8c 	st.w	sp[1676],r8
800095b2:	58 78       	cp.w	r8,7
800095b4:	e0 89 00 04 	brgt	800095bc <_vfprintf_r+0x1a78>
800095b8:	2f 83       	sub	r3,-8
800095ba:	c0 b8       	rjmp	800095d0 <_vfprintf_r+0x1a8c>
800095bc:	fa ca f9 78 	sub	r10,sp,-1672
800095c0:	02 9b       	mov	r11,r1
800095c2:	08 9c       	mov	r12,r4
800095c4:	fe b0 f2 b2 	rcall	80007b28 <__sprint_r>
800095c8:	e0 81 02 3d 	brne	80009a42 <_vfprintf_r+0x1efe>
800095cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800095d0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800095d4:	5c 32       	neg	r2
800095d6:	58 02       	cp.w	r2,0
800095d8:	e0 89 00 1d 	brgt	80009612 <_vfprintf_r+0x1ace>
800095dc:	c3 d8       	rjmp	80009656 <_vfprintf_r+0x1b12>
800095de:	2f 09       	sub	r9,-16
800095e0:	2f f8       	sub	r8,-1
800095e2:	31 0e       	mov	lr,16
800095e4:	fb 49 06 90 	st.w	sp[1680],r9
800095e8:	87 00       	st.w	r3[0x0],r0
800095ea:	87 1e       	st.w	r3[0x4],lr
800095ec:	fb 48 06 8c 	st.w	sp[1676],r8
800095f0:	58 78       	cp.w	r8,7
800095f2:	e0 89 00 04 	brgt	800095fa <_vfprintf_r+0x1ab6>
800095f6:	2f 83       	sub	r3,-8
800095f8:	c0 b8       	rjmp	8000960e <_vfprintf_r+0x1aca>
800095fa:	fa ca f9 78 	sub	r10,sp,-1672
800095fe:	02 9b       	mov	r11,r1
80009600:	08 9c       	mov	r12,r4
80009602:	fe b0 f2 93 	rcall	80007b28 <__sprint_r>
80009606:	e0 81 02 1e 	brne	80009a42 <_vfprintf_r+0x1efe>
8000960a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000960e:	21 02       	sub	r2,16
80009610:	c0 38       	rjmp	80009616 <_vfprintf_r+0x1ad2>
80009612:	fe c0 bc 72 	sub	r0,pc,-17294
80009616:	fa f9 06 90 	ld.w	r9,sp[1680]
8000961a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000961e:	fe ca bc 7e 	sub	r10,pc,-17282
80009622:	59 02       	cp.w	r2,16
80009624:	fe 99 ff dd 	brgt	800095de <_vfprintf_r+0x1a9a>
80009628:	04 09       	add	r9,r2
8000962a:	2f f8       	sub	r8,-1
8000962c:	87 0a       	st.w	r3[0x0],r10
8000962e:	fb 49 06 90 	st.w	sp[1680],r9
80009632:	87 12       	st.w	r3[0x4],r2
80009634:	fb 48 06 8c 	st.w	sp[1676],r8
80009638:	58 78       	cp.w	r8,7
8000963a:	e0 89 00 04 	brgt	80009642 <_vfprintf_r+0x1afe>
8000963e:	2f 83       	sub	r3,-8
80009640:	c0 b8       	rjmp	80009656 <_vfprintf_r+0x1b12>
80009642:	fa ca f9 78 	sub	r10,sp,-1672
80009646:	02 9b       	mov	r11,r1
80009648:	08 9c       	mov	r12,r4
8000964a:	fe b0 f2 6f 	rcall	80007b28 <__sprint_r>
8000964e:	e0 81 01 fa 	brne	80009a42 <_vfprintf_r+0x1efe>
80009652:	fa c3 f9 e0 	sub	r3,sp,-1568
80009656:	40 6c       	lddsp	r12,sp[0x18]
80009658:	fa f8 06 90 	ld.w	r8,sp[1680]
8000965c:	87 06       	st.w	r3[0x0],r6
8000965e:	87 1c       	st.w	r3[0x4],r12
80009660:	18 08       	add	r8,r12
80009662:	cb 98       	rjmp	800097d4 <_vfprintf_r+0x1c90>
80009664:	fa f9 06 90 	ld.w	r9,sp[1680]
80009668:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000966c:	40 6b       	lddsp	r11,sp[0x18]
8000966e:	16 3a       	cp.w	r10,r11
80009670:	c6 f5       	brlt	8000974e <_vfprintf_r+0x1c0a>
80009672:	16 09       	add	r9,r11
80009674:	2f f8       	sub	r8,-1
80009676:	87 06       	st.w	r3[0x0],r6
80009678:	fb 49 06 90 	st.w	sp[1680],r9
8000967c:	87 1b       	st.w	r3[0x4],r11
8000967e:	fb 48 06 8c 	st.w	sp[1676],r8
80009682:	58 78       	cp.w	r8,7
80009684:	e0 89 00 04 	brgt	8000968c <_vfprintf_r+0x1b48>
80009688:	2f 83       	sub	r3,-8
8000968a:	c0 b8       	rjmp	800096a0 <_vfprintf_r+0x1b5c>
8000968c:	fa ca f9 78 	sub	r10,sp,-1672
80009690:	02 9b       	mov	r11,r1
80009692:	08 9c       	mov	r12,r4
80009694:	fe b0 f2 4a 	rcall	80007b28 <__sprint_r>
80009698:	e0 81 01 d5 	brne	80009a42 <_vfprintf_r+0x1efe>
8000969c:	fa c3 f9 e0 	sub	r3,sp,-1568
800096a0:	fa f6 06 ac 	ld.w	r6,sp[1708]
800096a4:	40 6a       	lddsp	r10,sp[0x18]
800096a6:	14 16       	sub	r6,r10
800096a8:	58 06       	cp.w	r6,0
800096aa:	e0 89 00 1c 	brgt	800096e2 <_vfprintf_r+0x1b9e>
800096ae:	c3 d8       	rjmp	80009728 <_vfprintf_r+0x1be4>
800096b0:	2f 09       	sub	r9,-16
800096b2:	2f f8       	sub	r8,-1
800096b4:	fb 49 06 90 	st.w	sp[1680],r9
800096b8:	87 02       	st.w	r3[0x0],r2
800096ba:	87 10       	st.w	r3[0x4],r0
800096bc:	fb 48 06 8c 	st.w	sp[1676],r8
800096c0:	58 78       	cp.w	r8,7
800096c2:	e0 89 00 04 	brgt	800096ca <_vfprintf_r+0x1b86>
800096c6:	2f 83       	sub	r3,-8
800096c8:	c0 b8       	rjmp	800096de <_vfprintf_r+0x1b9a>
800096ca:	fa ca f9 78 	sub	r10,sp,-1672
800096ce:	02 9b       	mov	r11,r1
800096d0:	08 9c       	mov	r12,r4
800096d2:	fe b0 f2 2b 	rcall	80007b28 <__sprint_r>
800096d6:	e0 81 01 b6 	brne	80009a42 <_vfprintf_r+0x1efe>
800096da:	fa c3 f9 e0 	sub	r3,sp,-1568
800096de:	21 06       	sub	r6,16
800096e0:	c0 48       	rjmp	800096e8 <_vfprintf_r+0x1ba4>
800096e2:	fe c2 bd 42 	sub	r2,pc,-17086
800096e6:	31 00       	mov	r0,16
800096e8:	fa f9 06 90 	ld.w	r9,sp[1680]
800096ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096f0:	fe ca bd 50 	sub	r10,pc,-17072
800096f4:	59 06       	cp.w	r6,16
800096f6:	fe 99 ff dd 	brgt	800096b0 <_vfprintf_r+0x1b6c>
800096fa:	0c 09       	add	r9,r6
800096fc:	2f f8       	sub	r8,-1
800096fe:	87 0a       	st.w	r3[0x0],r10
80009700:	fb 49 06 90 	st.w	sp[1680],r9
80009704:	87 16       	st.w	r3[0x4],r6
80009706:	fb 48 06 8c 	st.w	sp[1676],r8
8000970a:	58 78       	cp.w	r8,7
8000970c:	e0 89 00 04 	brgt	80009714 <_vfprintf_r+0x1bd0>
80009710:	2f 83       	sub	r3,-8
80009712:	c0 b8       	rjmp	80009728 <_vfprintf_r+0x1be4>
80009714:	fa ca f9 78 	sub	r10,sp,-1672
80009718:	02 9b       	mov	r11,r1
8000971a:	08 9c       	mov	r12,r4
8000971c:	fe b0 f2 06 	rcall	80007b28 <__sprint_r>
80009720:	e0 81 01 91 	brne	80009a42 <_vfprintf_r+0x1efe>
80009724:	fa c3 f9 e0 	sub	r3,sp,-1568
80009728:	ed b5 00 00 	bld	r5,0x0
8000972c:	e0 81 01 20 	brne	8000996c <_vfprintf_r+0x1e28>
80009730:	40 c9       	lddsp	r9,sp[0x30]
80009732:	fa f8 06 90 	ld.w	r8,sp[1680]
80009736:	2f f8       	sub	r8,-1
80009738:	87 09       	st.w	r3[0x0],r9
8000973a:	fb 48 06 90 	st.w	sp[1680],r8
8000973e:	30 19       	mov	r9,1
80009740:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009744:	87 19       	st.w	r3[0x4],r9
80009746:	2f f8       	sub	r8,-1
80009748:	fb 48 06 8c 	st.w	sp[1676],r8
8000974c:	c0 29       	rjmp	80009950 <_vfprintf_r+0x1e0c>
8000974e:	14 09       	add	r9,r10
80009750:	2f f8       	sub	r8,-1
80009752:	fb 49 06 90 	st.w	sp[1680],r9
80009756:	87 06       	st.w	r3[0x0],r6
80009758:	87 1a       	st.w	r3[0x4],r10
8000975a:	fb 48 06 8c 	st.w	sp[1676],r8
8000975e:	58 78       	cp.w	r8,7
80009760:	e0 89 00 04 	brgt	80009768 <_vfprintf_r+0x1c24>
80009764:	2f 83       	sub	r3,-8
80009766:	c0 b8       	rjmp	8000977c <_vfprintf_r+0x1c38>
80009768:	fa ca f9 78 	sub	r10,sp,-1672
8000976c:	02 9b       	mov	r11,r1
8000976e:	08 9c       	mov	r12,r4
80009770:	fe b0 f1 dc 	rcall	80007b28 <__sprint_r>
80009774:	e0 81 01 67 	brne	80009a42 <_vfprintf_r+0x1efe>
80009778:	fa c3 f9 e0 	sub	r3,sp,-1568
8000977c:	40 c8       	lddsp	r8,sp[0x30]
8000977e:	87 08       	st.w	r3[0x0],r8
80009780:	fa f8 06 90 	ld.w	r8,sp[1680]
80009784:	2f f8       	sub	r8,-1
80009786:	30 19       	mov	r9,1
80009788:	fb 48 06 90 	st.w	sp[1680],r8
8000978c:	87 19       	st.w	r3[0x4],r9
8000978e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009792:	2f f8       	sub	r8,-1
80009794:	fb 48 06 8c 	st.w	sp[1676],r8
80009798:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000979c:	58 78       	cp.w	r8,7
8000979e:	e0 89 00 04 	brgt	800097a6 <_vfprintf_r+0x1c62>
800097a2:	2f 83       	sub	r3,-8
800097a4:	c0 b8       	rjmp	800097ba <_vfprintf_r+0x1c76>
800097a6:	fa ca f9 78 	sub	r10,sp,-1672
800097aa:	02 9b       	mov	r11,r1
800097ac:	08 9c       	mov	r12,r4
800097ae:	fe b0 f1 bd 	rcall	80007b28 <__sprint_r>
800097b2:	e0 81 01 48 	brne	80009a42 <_vfprintf_r+0x1efe>
800097b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ba:	04 06       	add	r6,r2
800097bc:	fa f8 06 ac 	ld.w	r8,sp[1708]
800097c0:	87 06       	st.w	r3[0x0],r6
800097c2:	fa f9 06 90 	ld.w	r9,sp[1680]
800097c6:	40 66       	lddsp	r6,sp[0x18]
800097c8:	40 6e       	lddsp	lr,sp[0x18]
800097ca:	10 16       	sub	r6,r8
800097cc:	f2 08 01 08 	sub	r8,r9,r8
800097d0:	87 16       	st.w	r3[0x4],r6
800097d2:	1c 08       	add	r8,lr
800097d4:	fb 48 06 90 	st.w	sp[1680],r8
800097d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097dc:	2f f8       	sub	r8,-1
800097de:	fb 48 06 8c 	st.w	sp[1676],r8
800097e2:	cb 78       	rjmp	80009950 <_vfprintf_r+0x1e0c>
800097e4:	40 6c       	lddsp	r12,sp[0x18]
800097e6:	58 1c       	cp.w	r12,1
800097e8:	e0 89 00 06 	brgt	800097f4 <_vfprintf_r+0x1cb0>
800097ec:	ed b5 00 00 	bld	r5,0x0
800097f0:	e0 81 00 85 	brne	800098fa <_vfprintf_r+0x1db6>
800097f4:	fa f8 06 90 	ld.w	r8,sp[1680]
800097f8:	2f f8       	sub	r8,-1
800097fa:	30 19       	mov	r9,1
800097fc:	fb 48 06 90 	st.w	sp[1680],r8
80009800:	87 06       	st.w	r3[0x0],r6
80009802:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009806:	87 19       	st.w	r3[0x4],r9
80009808:	2f f8       	sub	r8,-1
8000980a:	fb 48 06 8c 	st.w	sp[1676],r8
8000980e:	58 78       	cp.w	r8,7
80009810:	e0 89 00 04 	brgt	80009818 <_vfprintf_r+0x1cd4>
80009814:	2f 83       	sub	r3,-8
80009816:	c0 b8       	rjmp	8000982c <_vfprintf_r+0x1ce8>
80009818:	fa ca f9 78 	sub	r10,sp,-1672
8000981c:	02 9b       	mov	r11,r1
8000981e:	08 9c       	mov	r12,r4
80009820:	fe b0 f1 84 	rcall	80007b28 <__sprint_r>
80009824:	e0 81 01 0f 	brne	80009a42 <_vfprintf_r+0x1efe>
80009828:	fa c3 f9 e0 	sub	r3,sp,-1568
8000982c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009830:	2f f8       	sub	r8,-1
80009832:	40 cb       	lddsp	r11,sp[0x30]
80009834:	fb 48 06 90 	st.w	sp[1680],r8
80009838:	30 19       	mov	r9,1
8000983a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000983e:	87 0b       	st.w	r3[0x0],r11
80009840:	2f f8       	sub	r8,-1
80009842:	87 19       	st.w	r3[0x4],r9
80009844:	fb 48 06 8c 	st.w	sp[1676],r8
80009848:	58 78       	cp.w	r8,7
8000984a:	e0 89 00 05 	brgt	80009854 <_vfprintf_r+0x1d10>
8000984e:	2f 83       	sub	r3,-8
80009850:	c0 c8       	rjmp	80009868 <_vfprintf_r+0x1d24>
80009852:	d7 03       	nop
80009854:	fa ca f9 78 	sub	r10,sp,-1672
80009858:	02 9b       	mov	r11,r1
8000985a:	08 9c       	mov	r12,r4
8000985c:	fe b0 f1 66 	rcall	80007b28 <__sprint_r>
80009860:	e0 81 00 f1 	brne	80009a42 <_vfprintf_r+0x1efe>
80009864:	fa c3 f9 e0 	sub	r3,sp,-1568
80009868:	30 08       	mov	r8,0
8000986a:	30 09       	mov	r9,0
8000986c:	40 5b       	lddsp	r11,sp[0x14]
8000986e:	40 7a       	lddsp	r10,sp[0x1c]
80009870:	e0 a0 13 25 	rcall	8000beba <__avr32_f64_cmp_eq>
80009874:	40 68       	lddsp	r8,sp[0x18]
80009876:	20 18       	sub	r8,1
80009878:	58 0c       	cp.w	r12,0
8000987a:	c0 d1       	brne	80009894 <_vfprintf_r+0x1d50>
8000987c:	2f f6       	sub	r6,-1
8000987e:	87 18       	st.w	r3[0x4],r8
80009880:	87 06       	st.w	r3[0x0],r6
80009882:	fa f6 06 90 	ld.w	r6,sp[1680]
80009886:	10 06       	add	r6,r8
80009888:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000988c:	fb 46 06 90 	st.w	sp[1680],r6
80009890:	2f f8       	sub	r8,-1
80009892:	c3 18       	rjmp	800098f4 <_vfprintf_r+0x1db0>
80009894:	10 96       	mov	r6,r8
80009896:	58 08       	cp.w	r8,0
80009898:	e0 89 00 1c 	brgt	800098d0 <_vfprintf_r+0x1d8c>
8000989c:	c4 b8       	rjmp	80009932 <_vfprintf_r+0x1dee>
8000989e:	2f 09       	sub	r9,-16
800098a0:	2f f8       	sub	r8,-1
800098a2:	fb 49 06 90 	st.w	sp[1680],r9
800098a6:	87 02       	st.w	r3[0x0],r2
800098a8:	87 10       	st.w	r3[0x4],r0
800098aa:	fb 48 06 8c 	st.w	sp[1676],r8
800098ae:	58 78       	cp.w	r8,7
800098b0:	e0 89 00 04 	brgt	800098b8 <_vfprintf_r+0x1d74>
800098b4:	2f 83       	sub	r3,-8
800098b6:	c0 b8       	rjmp	800098cc <_vfprintf_r+0x1d88>
800098b8:	fa ca f9 78 	sub	r10,sp,-1672
800098bc:	02 9b       	mov	r11,r1
800098be:	08 9c       	mov	r12,r4
800098c0:	fe b0 f1 34 	rcall	80007b28 <__sprint_r>
800098c4:	e0 81 00 bf 	brne	80009a42 <_vfprintf_r+0x1efe>
800098c8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098cc:	21 06       	sub	r6,16
800098ce:	c0 48       	rjmp	800098d6 <_vfprintf_r+0x1d92>
800098d0:	fe c2 bf 30 	sub	r2,pc,-16592
800098d4:	31 00       	mov	r0,16
800098d6:	fa f9 06 90 	ld.w	r9,sp[1680]
800098da:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098de:	fe ca bf 3e 	sub	r10,pc,-16578
800098e2:	59 06       	cp.w	r6,16
800098e4:	fe 99 ff dd 	brgt	8000989e <_vfprintf_r+0x1d5a>
800098e8:	0c 09       	add	r9,r6
800098ea:	87 0a       	st.w	r3[0x0],r10
800098ec:	fb 49 06 90 	st.w	sp[1680],r9
800098f0:	2f f8       	sub	r8,-1
800098f2:	87 16       	st.w	r3[0x4],r6
800098f4:	fb 48 06 8c 	st.w	sp[1676],r8
800098f8:	c0 e8       	rjmp	80009914 <_vfprintf_r+0x1dd0>
800098fa:	fa f8 06 90 	ld.w	r8,sp[1680]
800098fe:	2f f8       	sub	r8,-1
80009900:	30 19       	mov	r9,1
80009902:	fb 48 06 90 	st.w	sp[1680],r8
80009906:	87 06       	st.w	r3[0x0],r6
80009908:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000990c:	87 19       	st.w	r3[0x4],r9
8000990e:	2f f8       	sub	r8,-1
80009910:	fb 48 06 8c 	st.w	sp[1676],r8
80009914:	58 78       	cp.w	r8,7
80009916:	e0 89 00 04 	brgt	8000991e <_vfprintf_r+0x1dda>
8000991a:	2f 83       	sub	r3,-8
8000991c:	c0 b8       	rjmp	80009932 <_vfprintf_r+0x1dee>
8000991e:	fa ca f9 78 	sub	r10,sp,-1672
80009922:	02 9b       	mov	r11,r1
80009924:	08 9c       	mov	r12,r4
80009926:	fe b0 f1 01 	rcall	80007b28 <__sprint_r>
8000992a:	e0 81 00 8c 	brne	80009a42 <_vfprintf_r+0x1efe>
8000992e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009932:	40 ea       	lddsp	r10,sp[0x38]
80009934:	fa f8 06 90 	ld.w	r8,sp[1680]
80009938:	14 08       	add	r8,r10
8000993a:	fa c9 f9 64 	sub	r9,sp,-1692
8000993e:	fb 48 06 90 	st.w	sp[1680],r8
80009942:	87 1a       	st.w	r3[0x4],r10
80009944:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009948:	87 09       	st.w	r3[0x0],r9
8000994a:	2f f8       	sub	r8,-1
8000994c:	fb 48 06 8c 	st.w	sp[1676],r8
80009950:	58 78       	cp.w	r8,7
80009952:	e0 89 00 04 	brgt	8000995a <_vfprintf_r+0x1e16>
80009956:	2f 83       	sub	r3,-8
80009958:	c0 a8       	rjmp	8000996c <_vfprintf_r+0x1e28>
8000995a:	fa ca f9 78 	sub	r10,sp,-1672
8000995e:	02 9b       	mov	r11,r1
80009960:	08 9c       	mov	r12,r4
80009962:	fe b0 f0 e3 	rcall	80007b28 <__sprint_r>
80009966:	c6 e1       	brne	80009a42 <_vfprintf_r+0x1efe>
80009968:	fa c3 f9 e0 	sub	r3,sp,-1568
8000996c:	e2 15 00 04 	andl	r5,0x4,COH
80009970:	c3 f0       	breq	800099ee <_vfprintf_r+0x1eaa>
80009972:	40 86       	lddsp	r6,sp[0x20]
80009974:	40 39       	lddsp	r9,sp[0xc]
80009976:	12 16       	sub	r6,r9
80009978:	58 06       	cp.w	r6,0
8000997a:	e0 89 00 1a 	brgt	800099ae <_vfprintf_r+0x1e6a>
8000997e:	c3 88       	rjmp	800099ee <_vfprintf_r+0x1eaa>
80009980:	2f 09       	sub	r9,-16
80009982:	2f f8       	sub	r8,-1
80009984:	fb 49 06 90 	st.w	sp[1680],r9
80009988:	87 05       	st.w	r3[0x0],r5
8000998a:	87 12       	st.w	r3[0x4],r2
8000998c:	fb 48 06 8c 	st.w	sp[1676],r8
80009990:	58 78       	cp.w	r8,7
80009992:	e0 89 00 04 	brgt	8000999a <_vfprintf_r+0x1e56>
80009996:	2f 83       	sub	r3,-8
80009998:	c0 98       	rjmp	800099aa <_vfprintf_r+0x1e66>
8000999a:	00 9a       	mov	r10,r0
8000999c:	02 9b       	mov	r11,r1
8000999e:	08 9c       	mov	r12,r4
800099a0:	fe b0 f0 c4 	rcall	80007b28 <__sprint_r>
800099a4:	c4 f1       	brne	80009a42 <_vfprintf_r+0x1efe>
800099a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800099aa:	21 06       	sub	r6,16
800099ac:	c0 68       	rjmp	800099b8 <_vfprintf_r+0x1e74>
800099ae:	fe c5 c0 1e 	sub	r5,pc,-16354
800099b2:	31 02       	mov	r2,16
800099b4:	fa c0 f9 78 	sub	r0,sp,-1672
800099b8:	fa f9 06 90 	ld.w	r9,sp[1680]
800099bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099c0:	fe ca c0 30 	sub	r10,pc,-16336
800099c4:	59 06       	cp.w	r6,16
800099c6:	fe 99 ff dd 	brgt	80009980 <_vfprintf_r+0x1e3c>
800099ca:	0c 09       	add	r9,r6
800099cc:	2f f8       	sub	r8,-1
800099ce:	87 0a       	st.w	r3[0x0],r10
800099d0:	87 16       	st.w	r3[0x4],r6
800099d2:	fb 49 06 90 	st.w	sp[1680],r9
800099d6:	fb 48 06 8c 	st.w	sp[1676],r8
800099da:	58 78       	cp.w	r8,7
800099dc:	e0 8a 00 09 	brle	800099ee <_vfprintf_r+0x1eaa>
800099e0:	fa ca f9 78 	sub	r10,sp,-1672
800099e4:	02 9b       	mov	r11,r1
800099e6:	08 9c       	mov	r12,r4
800099e8:	fe b0 f0 a0 	rcall	80007b28 <__sprint_r>
800099ec:	c2 b1       	brne	80009a42 <_vfprintf_r+0x1efe>
800099ee:	40 bc       	lddsp	r12,sp[0x2c]
800099f0:	40 36       	lddsp	r6,sp[0xc]
800099f2:	40 8e       	lddsp	lr,sp[0x20]
800099f4:	ec 0e 0c 48 	max	r8,r6,lr
800099f8:	10 0c       	add	r12,r8
800099fa:	50 bc       	stdsp	sp[0x2c],r12
800099fc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a00:	58 08       	cp.w	r8,0
80009a02:	c0 80       	breq	80009a12 <_vfprintf_r+0x1ece>
80009a04:	fa ca f9 78 	sub	r10,sp,-1672
80009a08:	02 9b       	mov	r11,r1
80009a0a:	08 9c       	mov	r12,r4
80009a0c:	fe b0 f0 8e 	rcall	80007b28 <__sprint_r>
80009a10:	c1 91       	brne	80009a42 <_vfprintf_r+0x1efe>
80009a12:	30 0b       	mov	r11,0
80009a14:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a18:	fb 4b 06 8c 	st.w	sp[1676],r11
80009a1c:	fe 9f f1 22 	bral	80007c60 <_vfprintf_r+0x11c>
80009a20:	08 95       	mov	r5,r4
80009a22:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a26:	58 08       	cp.w	r8,0
80009a28:	c0 80       	breq	80009a38 <_vfprintf_r+0x1ef4>
80009a2a:	08 9c       	mov	r12,r4
80009a2c:	fa ca f9 78 	sub	r10,sp,-1672
80009a30:	02 9b       	mov	r11,r1
80009a32:	fe b0 f0 7b 	rcall	80007b28 <__sprint_r>
80009a36:	c0 61       	brne	80009a42 <_vfprintf_r+0x1efe>
80009a38:	30 08       	mov	r8,0
80009a3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a3e:	c0 28       	rjmp	80009a42 <_vfprintf_r+0x1efe>
80009a40:	40 41       	lddsp	r1,sp[0x10]
80009a42:	82 68       	ld.sh	r8,r1[0xc]
80009a44:	ed b8 00 06 	bld	r8,0x6
80009a48:	c0 31       	brne	80009a4e <_vfprintf_r+0x1f0a>
80009a4a:	3f fa       	mov	r10,-1
80009a4c:	50 ba       	stdsp	sp[0x2c],r10
80009a4e:	40 bc       	lddsp	r12,sp[0x2c]
80009a50:	fe 3d f9 44 	sub	sp,-1724
80009a54:	d8 32       	popm	r0-r7,pc
80009a56:	d7 03       	nop

80009a58 <__swsetup_r>:
80009a58:	d4 21       	pushm	r4-r7,lr
80009a5a:	e0 68 0a 30 	mov	r8,2608
80009a5e:	18 96       	mov	r6,r12
80009a60:	16 97       	mov	r7,r11
80009a62:	70 0c       	ld.w	r12,r8[0x0]
80009a64:	58 0c       	cp.w	r12,0
80009a66:	c0 60       	breq	80009a72 <__swsetup_r+0x1a>
80009a68:	78 68       	ld.w	r8,r12[0x18]
80009a6a:	58 08       	cp.w	r8,0
80009a6c:	c0 31       	brne	80009a72 <__swsetup_r+0x1a>
80009a6e:	e0 a0 07 bf 	rcall	8000a9ec <__sinit>
80009a72:	fe c8 bf b2 	sub	r8,pc,-16462
80009a76:	10 37       	cp.w	r7,r8
80009a78:	c0 61       	brne	80009a84 <__swsetup_r+0x2c>
80009a7a:	e0 68 0a 30 	mov	r8,2608
80009a7e:	70 08       	ld.w	r8,r8[0x0]
80009a80:	70 07       	ld.w	r7,r8[0x0]
80009a82:	c1 28       	rjmp	80009aa6 <__swsetup_r+0x4e>
80009a84:	fe c8 bf a4 	sub	r8,pc,-16476
80009a88:	10 37       	cp.w	r7,r8
80009a8a:	c0 61       	brne	80009a96 <__swsetup_r+0x3e>
80009a8c:	e0 68 0a 30 	mov	r8,2608
80009a90:	70 08       	ld.w	r8,r8[0x0]
80009a92:	70 17       	ld.w	r7,r8[0x4]
80009a94:	c0 98       	rjmp	80009aa6 <__swsetup_r+0x4e>
80009a96:	fe c8 bf 96 	sub	r8,pc,-16490
80009a9a:	10 37       	cp.w	r7,r8
80009a9c:	c0 51       	brne	80009aa6 <__swsetup_r+0x4e>
80009a9e:	e0 68 0a 30 	mov	r8,2608
80009aa2:	70 08       	ld.w	r8,r8[0x0]
80009aa4:	70 27       	ld.w	r7,r8[0x8]
80009aa6:	8e 68       	ld.sh	r8,r7[0xc]
80009aa8:	ed b8 00 03 	bld	r8,0x3
80009aac:	c1 e0       	breq	80009ae8 <__swsetup_r+0x90>
80009aae:	ed b8 00 04 	bld	r8,0x4
80009ab2:	c3 e1       	brne	80009b2e <__swsetup_r+0xd6>
80009ab4:	ed b8 00 02 	bld	r8,0x2
80009ab8:	c1 51       	brne	80009ae2 <__swsetup_r+0x8a>
80009aba:	6e db       	ld.w	r11,r7[0x34]
80009abc:	58 0b       	cp.w	r11,0
80009abe:	c0 a0       	breq	80009ad2 <__swsetup_r+0x7a>
80009ac0:	ee c8 ff bc 	sub	r8,r7,-68
80009ac4:	10 3b       	cp.w	r11,r8
80009ac6:	c0 40       	breq	80009ace <__swsetup_r+0x76>
80009ac8:	0c 9c       	mov	r12,r6
80009aca:	e0 a0 08 2b 	rcall	8000ab20 <_free_r>
80009ace:	30 08       	mov	r8,0
80009ad0:	8f d8       	st.w	r7[0x34],r8
80009ad2:	8e 68       	ld.sh	r8,r7[0xc]
80009ad4:	e0 18 ff db 	andl	r8,0xffdb
80009ad8:	ae 68       	st.h	r7[0xc],r8
80009ada:	30 08       	mov	r8,0
80009adc:	8f 18       	st.w	r7[0x4],r8
80009ade:	6e 48       	ld.w	r8,r7[0x10]
80009ae0:	8f 08       	st.w	r7[0x0],r8
80009ae2:	8e 68       	ld.sh	r8,r7[0xc]
80009ae4:	a3 b8       	sbr	r8,0x3
80009ae6:	ae 68       	st.h	r7[0xc],r8
80009ae8:	6e 48       	ld.w	r8,r7[0x10]
80009aea:	58 08       	cp.w	r8,0
80009aec:	c0 b1       	brne	80009b02 <__swsetup_r+0xaa>
80009aee:	8e 68       	ld.sh	r8,r7[0xc]
80009af0:	e2 18 02 80 	andl	r8,0x280,COH
80009af4:	e0 48 02 00 	cp.w	r8,512
80009af8:	c0 50       	breq	80009b02 <__swsetup_r+0xaa>
80009afa:	0c 9c       	mov	r12,r6
80009afc:	0e 9b       	mov	r11,r7
80009afe:	e0 a0 0a 4b 	rcall	8000af94 <__smakebuf_r>
80009b02:	8e 69       	ld.sh	r9,r7[0xc]
80009b04:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009b08:	c0 70       	breq	80009b16 <__swsetup_r+0xbe>
80009b0a:	30 08       	mov	r8,0
80009b0c:	8f 28       	st.w	r7[0x8],r8
80009b0e:	6e 58       	ld.w	r8,r7[0x14]
80009b10:	5c 38       	neg	r8
80009b12:	8f 68       	st.w	r7[0x18],r8
80009b14:	c0 68       	rjmp	80009b20 <__swsetup_r+0xc8>
80009b16:	ed b9 00 01 	bld	r9,0x1
80009b1a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009b1e:	8f 28       	st.w	r7[0x8],r8
80009b20:	6e 48       	ld.w	r8,r7[0x10]
80009b22:	58 08       	cp.w	r8,0
80009b24:	c0 61       	brne	80009b30 <__swsetup_r+0xd8>
80009b26:	8e 68       	ld.sh	r8,r7[0xc]
80009b28:	ed b8 00 07 	bld	r8,0x7
80009b2c:	c0 21       	brne	80009b30 <__swsetup_r+0xd8>
80009b2e:	dc 2a       	popm	r4-r7,pc,r12=-1
80009b30:	d8 2a       	popm	r4-r7,pc,r12=0
80009b32:	d7 03       	nop

80009b34 <quorem>:
80009b34:	d4 31       	pushm	r0-r7,lr
80009b36:	20 2d       	sub	sp,8
80009b38:	18 97       	mov	r7,r12
80009b3a:	78 48       	ld.w	r8,r12[0x10]
80009b3c:	76 46       	ld.w	r6,r11[0x10]
80009b3e:	0c 38       	cp.w	r8,r6
80009b40:	c0 34       	brge	80009b46 <quorem+0x12>
80009b42:	30 0c       	mov	r12,0
80009b44:	c8 58       	rjmp	80009c4e <quorem+0x11a>
80009b46:	ec c2 ff fc 	sub	r2,r6,-4
80009b4a:	f6 c3 ff ec 	sub	r3,r11,-20
80009b4e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009b52:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009b56:	2f f9       	sub	r9,-1
80009b58:	20 16       	sub	r6,1
80009b5a:	f8 09 0d 08 	divu	r8,r12,r9
80009b5e:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009b62:	ee c4 ff ec 	sub	r4,r7,-20
80009b66:	10 95       	mov	r5,r8
80009b68:	58 08       	cp.w	r8,0
80009b6a:	c4 10       	breq	80009bec <quorem+0xb8>
80009b6c:	30 09       	mov	r9,0
80009b6e:	06 9a       	mov	r10,r3
80009b70:	08 98       	mov	r8,r4
80009b72:	12 91       	mov	r1,r9
80009b74:	50 0b       	stdsp	sp[0x0],r11
80009b76:	70 0e       	ld.w	lr,r8[0x0]
80009b78:	b1 8e       	lsr	lr,0x10
80009b7a:	50 1e       	stdsp	sp[0x4],lr
80009b7c:	15 0e       	ld.w	lr,r10++
80009b7e:	fc 00 16 10 	lsr	r0,lr,0x10
80009b82:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009b86:	ea 0e 03 41 	mac	r1,r5,lr
80009b8a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009b8e:	b1 81       	lsr	r1,0x10
80009b90:	40 1b       	lddsp	r11,sp[0x4]
80009b92:	ea 00 02 40 	mul	r0,r5,r0
80009b96:	e2 00 00 00 	add	r0,r1,r0
80009b9a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009b9e:	02 1b       	sub	r11,r1
80009ba0:	50 1b       	stdsp	sp[0x4],r11
80009ba2:	70 0b       	ld.w	r11,r8[0x0]
80009ba4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009ba8:	02 09       	add	r9,r1
80009baa:	f2 0e 01 0e 	sub	lr,r9,lr
80009bae:	b0 1e       	st.h	r8[0x2],lr
80009bb0:	fc 09 14 10 	asr	r9,lr,0x10
80009bb4:	40 1e       	lddsp	lr,sp[0x4]
80009bb6:	fc 09 00 09 	add	r9,lr,r9
80009bba:	b0 09       	st.h	r8[0x0],r9
80009bbc:	e0 01 16 10 	lsr	r1,r0,0x10
80009bc0:	2f c8       	sub	r8,-4
80009bc2:	b1 49       	asr	r9,0x10
80009bc4:	04 3a       	cp.w	r10,r2
80009bc6:	fe 98 ff d8 	brls	80009b76 <quorem+0x42>
80009bca:	40 0b       	lddsp	r11,sp[0x0]
80009bcc:	58 0c       	cp.w	r12,0
80009bce:	c0 f1       	brne	80009bec <quorem+0xb8>
80009bd0:	ec c8 ff fb 	sub	r8,r6,-5
80009bd4:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009bd8:	c0 28       	rjmp	80009bdc <quorem+0xa8>
80009bda:	20 16       	sub	r6,1
80009bdc:	20 48       	sub	r8,4
80009bde:	08 38       	cp.w	r8,r4
80009be0:	e0 88 00 05 	brls	80009bea <quorem+0xb6>
80009be4:	70 09       	ld.w	r9,r8[0x0]
80009be6:	58 09       	cp.w	r9,0
80009be8:	cf 90       	breq	80009bda <quorem+0xa6>
80009bea:	8f 46       	st.w	r7[0x10],r6
80009bec:	0e 9c       	mov	r12,r7
80009bee:	e0 a0 0a d2 	rcall	8000b192 <__mcmp>
80009bf2:	c2 d5       	brlt	80009c4c <quorem+0x118>
80009bf4:	2f f5       	sub	r5,-1
80009bf6:	08 98       	mov	r8,r4
80009bf8:	30 09       	mov	r9,0
80009bfa:	07 0b       	ld.w	r11,r3++
80009bfc:	f6 0a 16 10 	lsr	r10,r11,0x10
80009c00:	70 0c       	ld.w	r12,r8[0x0]
80009c02:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009c06:	f8 0e 16 10 	lsr	lr,r12,0x10
80009c0a:	14 1e       	sub	lr,r10
80009c0c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009c10:	16 1a       	sub	r10,r11
80009c12:	12 0a       	add	r10,r9
80009c14:	b0 1a       	st.h	r8[0x2],r10
80009c16:	b1 4a       	asr	r10,0x10
80009c18:	fc 0a 00 09 	add	r9,lr,r10
80009c1c:	b0 09       	st.h	r8[0x0],r9
80009c1e:	2f c8       	sub	r8,-4
80009c20:	b1 49       	asr	r9,0x10
80009c22:	04 33       	cp.w	r3,r2
80009c24:	fe 98 ff eb 	brls	80009bfa <quorem+0xc6>
80009c28:	ec c8 ff fb 	sub	r8,r6,-5
80009c2c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009c30:	58 09       	cp.w	r9,0
80009c32:	c0 d1       	brne	80009c4c <quorem+0x118>
80009c34:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009c38:	c0 28       	rjmp	80009c3c <quorem+0x108>
80009c3a:	20 16       	sub	r6,1
80009c3c:	20 48       	sub	r8,4
80009c3e:	08 38       	cp.w	r8,r4
80009c40:	e0 88 00 05 	brls	80009c4a <quorem+0x116>
80009c44:	70 09       	ld.w	r9,r8[0x0]
80009c46:	58 09       	cp.w	r9,0
80009c48:	cf 90       	breq	80009c3a <quorem+0x106>
80009c4a:	8f 46       	st.w	r7[0x10],r6
80009c4c:	0a 9c       	mov	r12,r5
80009c4e:	2f ed       	sub	sp,-8
80009c50:	d8 32       	popm	r0-r7,pc
80009c52:	d7 03       	nop

80009c54 <_dtoa_r>:
80009c54:	d4 31       	pushm	r0-r7,lr
80009c56:	21 ad       	sub	sp,104
80009c58:	fa c4 ff 74 	sub	r4,sp,-140
80009c5c:	18 97       	mov	r7,r12
80009c5e:	16 95       	mov	r5,r11
80009c60:	68 2c       	ld.w	r12,r4[0x8]
80009c62:	50 c9       	stdsp	sp[0x30],r9
80009c64:	68 16       	ld.w	r6,r4[0x4]
80009c66:	68 09       	ld.w	r9,r4[0x0]
80009c68:	50 e8       	stdsp	sp[0x38],r8
80009c6a:	14 94       	mov	r4,r10
80009c6c:	51 2c       	stdsp	sp[0x48],r12
80009c6e:	fa e5 00 08 	st.d	sp[8],r4
80009c72:	51 59       	stdsp	sp[0x54],r9
80009c74:	6e 95       	ld.w	r5,r7[0x24]
80009c76:	58 05       	cp.w	r5,0
80009c78:	c0 91       	brne	80009c8a <_dtoa_r+0x36>
80009c7a:	31 0c       	mov	r12,16
80009c7c:	fe b0 e8 f4 	rcall	80006e64 <malloc>
80009c80:	99 35       	st.w	r12[0xc],r5
80009c82:	8f 9c       	st.w	r7[0x24],r12
80009c84:	99 15       	st.w	r12[0x4],r5
80009c86:	99 25       	st.w	r12[0x8],r5
80009c88:	99 05       	st.w	r12[0x0],r5
80009c8a:	6e 99       	ld.w	r9,r7[0x24]
80009c8c:	72 08       	ld.w	r8,r9[0x0]
80009c8e:	58 08       	cp.w	r8,0
80009c90:	c0 f0       	breq	80009cae <_dtoa_r+0x5a>
80009c92:	72 1a       	ld.w	r10,r9[0x4]
80009c94:	91 1a       	st.w	r8[0x4],r10
80009c96:	30 1a       	mov	r10,1
80009c98:	72 19       	ld.w	r9,r9[0x4]
80009c9a:	f4 09 09 49 	lsl	r9,r10,r9
80009c9e:	10 9b       	mov	r11,r8
80009ca0:	91 29       	st.w	r8[0x8],r9
80009ca2:	0e 9c       	mov	r12,r7
80009ca4:	e0 a0 0a 90 	rcall	8000b1c4 <_Bfree>
80009ca8:	6e 98       	ld.w	r8,r7[0x24]
80009caa:	30 09       	mov	r9,0
80009cac:	91 09       	st.w	r8[0x0],r9
80009cae:	40 28       	lddsp	r8,sp[0x8]
80009cb0:	10 94       	mov	r4,r8
80009cb2:	58 08       	cp.w	r8,0
80009cb4:	c0 64       	brge	80009cc0 <_dtoa_r+0x6c>
80009cb6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009cba:	50 28       	stdsp	sp[0x8],r8
80009cbc:	30 18       	mov	r8,1
80009cbe:	c0 28       	rjmp	80009cc2 <_dtoa_r+0x6e>
80009cc0:	30 08       	mov	r8,0
80009cc2:	8d 08       	st.w	r6[0x0],r8
80009cc4:	fc 1c 7f f0 	movh	r12,0x7ff0
80009cc8:	40 26       	lddsp	r6,sp[0x8]
80009cca:	0c 98       	mov	r8,r6
80009ccc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009cd0:	18 38       	cp.w	r8,r12
80009cd2:	c2 01       	brne	80009d12 <_dtoa_r+0xbe>
80009cd4:	e0 68 27 0f 	mov	r8,9999
80009cd8:	41 5b       	lddsp	r11,sp[0x54]
80009cda:	97 08       	st.w	r11[0x0],r8
80009cdc:	40 3a       	lddsp	r10,sp[0xc]
80009cde:	58 0a       	cp.w	r10,0
80009ce0:	c0 71       	brne	80009cee <_dtoa_r+0x9a>
80009ce2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009ce6:	c0 41       	brne	80009cee <_dtoa_r+0x9a>
80009ce8:	fe cc c2 38 	sub	r12,pc,-15816
80009cec:	c0 38       	rjmp	80009cf2 <_dtoa_r+0x9e>
80009cee:	fe cc c2 32 	sub	r12,pc,-15822
80009cf2:	41 29       	lddsp	r9,sp[0x48]
80009cf4:	58 09       	cp.w	r9,0
80009cf6:	e0 80 05 9a 	breq	8000a82a <_dtoa_r+0xbd6>
80009cfa:	f8 c8 ff fd 	sub	r8,r12,-3
80009cfe:	f8 c9 ff f8 	sub	r9,r12,-8
80009d02:	11 8b       	ld.ub	r11,r8[0x0]
80009d04:	30 0a       	mov	r10,0
80009d06:	41 25       	lddsp	r5,sp[0x48]
80009d08:	f4 0b 18 00 	cp.b	r11,r10
80009d0c:	f2 08 17 10 	movne	r8,r9
80009d10:	c1 68       	rjmp	80009d3c <_dtoa_r+0xe8>
80009d12:	fa ea 00 08 	ld.d	r10,sp[8]
80009d16:	30 08       	mov	r8,0
80009d18:	fa eb 00 3c 	st.d	sp[60],r10
80009d1c:	30 09       	mov	r9,0
80009d1e:	e0 a0 10 ce 	rcall	8000beba <__avr32_f64_cmp_eq>
80009d22:	c1 00       	breq	80009d42 <_dtoa_r+0xee>
80009d24:	30 18       	mov	r8,1
80009d26:	41 5a       	lddsp	r10,sp[0x54]
80009d28:	95 08       	st.w	r10[0x0],r8
80009d2a:	fe cc c3 9e 	sub	r12,pc,-15458
80009d2e:	41 29       	lddsp	r9,sp[0x48]
80009d30:	f8 08 00 08 	add	r8,r12,r8
80009d34:	58 09       	cp.w	r9,0
80009d36:	e0 80 05 7a 	breq	8000a82a <_dtoa_r+0xbd6>
80009d3a:	12 95       	mov	r5,r9
80009d3c:	8b 08       	st.w	r5[0x0],r8
80009d3e:	e0 8f 05 76 	bral	8000a82a <_dtoa_r+0xbd6>
80009d42:	fa c8 ff 9c 	sub	r8,sp,-100
80009d46:	fa c9 ff a0 	sub	r9,sp,-96
80009d4a:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d4e:	0e 9c       	mov	r12,r7
80009d50:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009d54:	e0 a0 0a 8a 	rcall	8000b268 <__d2b>
80009d58:	18 93       	mov	r3,r12
80009d5a:	58 05       	cp.w	r5,0
80009d5c:	c0 d0       	breq	80009d76 <_dtoa_r+0x122>
80009d5e:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d62:	30 04       	mov	r4,0
80009d64:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009d68:	ea c5 03 ff 	sub	r5,r5,1023
80009d6c:	10 9b       	mov	r11,r8
80009d6e:	51 74       	stdsp	sp[0x5c],r4
80009d70:	ea 1b 3f f0 	orh	r11,0x3ff0
80009d74:	c2 58       	rjmp	80009dbe <_dtoa_r+0x16a>
80009d76:	41 88       	lddsp	r8,sp[0x60]
80009d78:	41 9c       	lddsp	r12,sp[0x64]
80009d7a:	10 0c       	add	r12,r8
80009d7c:	f8 c5 fb ce 	sub	r5,r12,-1074
80009d80:	e0 45 00 20 	cp.w	r5,32
80009d84:	e0 8a 00 0e 	brle	80009da0 <_dtoa_r+0x14c>
80009d88:	f8 cc fb ee 	sub	r12,r12,-1042
80009d8c:	40 3b       	lddsp	r11,sp[0xc]
80009d8e:	ea 08 11 40 	rsub	r8,r5,64
80009d92:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009d96:	ec 08 09 46 	lsl	r6,r6,r8
80009d9a:	0c 4c       	or	r12,r6
80009d9c:	c0 78       	rjmp	80009daa <_dtoa_r+0x156>
80009d9e:	d7 03       	nop
80009da0:	ea 0c 11 20 	rsub	r12,r5,32
80009da4:	40 3a       	lddsp	r10,sp[0xc]
80009da6:	f4 0c 09 4c 	lsl	r12,r10,r12
80009daa:	e0 a0 10 14 	rcall	8000bdd2 <__avr32_u32_to_f64>
80009dae:	fc 18 fe 10 	movh	r8,0xfe10
80009db2:	30 19       	mov	r9,1
80009db4:	ea c5 04 33 	sub	r5,r5,1075
80009db8:	f0 0b 00 0b 	add	r11,r8,r11
80009dbc:	51 79       	stdsp	sp[0x5c],r9
80009dbe:	30 08       	mov	r8,0
80009dc0:	fc 19 3f f8 	movh	r9,0x3ff8
80009dc4:	e0 a0 0e 9c 	rcall	8000bafc <__avr32_f64_sub>
80009dc8:	e0 68 43 61 	mov	r8,17249
80009dcc:	ea 18 63 6f 	orh	r8,0x636f
80009dd0:	e0 69 87 a7 	mov	r9,34727
80009dd4:	ea 19 3f d2 	orh	r9,0x3fd2
80009dd8:	e0 a0 0d a6 	rcall	8000b924 <__avr32_f64_mul>
80009ddc:	e0 68 c8 b3 	mov	r8,51379
80009de0:	ea 18 8b 60 	orh	r8,0x8b60
80009de4:	e0 69 8a 28 	mov	r9,35368
80009de8:	ea 19 3f c6 	orh	r9,0x3fc6
80009dec:	e0 a0 0f 56 	rcall	8000bc98 <__avr32_f64_add>
80009df0:	0a 9c       	mov	r12,r5
80009df2:	14 90       	mov	r0,r10
80009df4:	16 91       	mov	r1,r11
80009df6:	e0 a0 0f f2 	rcall	8000bdda <__avr32_s32_to_f64>
80009dfa:	e0 68 79 fb 	mov	r8,31227
80009dfe:	ea 18 50 9f 	orh	r8,0x509f
80009e02:	e0 69 44 13 	mov	r9,17427
80009e06:	ea 19 3f d3 	orh	r9,0x3fd3
80009e0a:	e0 a0 0d 8d 	rcall	8000b924 <__avr32_f64_mul>
80009e0e:	14 98       	mov	r8,r10
80009e10:	16 99       	mov	r9,r11
80009e12:	00 9a       	mov	r10,r0
80009e14:	02 9b       	mov	r11,r1
80009e16:	e0 a0 0f 41 	rcall	8000bc98 <__avr32_f64_add>
80009e1a:	14 90       	mov	r0,r10
80009e1c:	16 91       	mov	r1,r11
80009e1e:	e0 a0 0f c7 	rcall	8000bdac <__avr32_f64_to_s32>
80009e22:	30 08       	mov	r8,0
80009e24:	18 96       	mov	r6,r12
80009e26:	30 09       	mov	r9,0
80009e28:	00 9a       	mov	r10,r0
80009e2a:	02 9b       	mov	r11,r1
80009e2c:	e0 a0 10 8e 	rcall	8000bf48 <__avr32_f64_cmp_lt>
80009e30:	c0 c0       	breq	80009e48 <_dtoa_r+0x1f4>
80009e32:	0c 9c       	mov	r12,r6
80009e34:	e0 a0 0f d3 	rcall	8000bdda <__avr32_s32_to_f64>
80009e38:	14 98       	mov	r8,r10
80009e3a:	16 99       	mov	r9,r11
80009e3c:	00 9a       	mov	r10,r0
80009e3e:	02 9b       	mov	r11,r1
80009e40:	e0 a0 10 3d 	rcall	8000beba <__avr32_f64_cmp_eq>
80009e44:	f7 b6 00 01 	subeq	r6,1
80009e48:	59 66       	cp.w	r6,22
80009e4a:	e0 88 00 05 	brls	80009e54 <_dtoa_r+0x200>
80009e4e:	30 18       	mov	r8,1
80009e50:	51 48       	stdsp	sp[0x50],r8
80009e52:	c1 38       	rjmp	80009e78 <_dtoa_r+0x224>
80009e54:	fe c8 c2 e4 	sub	r8,pc,-15644
80009e58:	fa ea 00 3c 	ld.d	r10,sp[60]
80009e5c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009e60:	e0 a0 10 74 	rcall	8000bf48 <__avr32_f64_cmp_lt>
80009e64:	f9 b4 00 00 	moveq	r4,0
80009e68:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009e6c:	f7 b6 01 01 	subne	r6,1
80009e70:	f9 bc 01 00 	movne	r12,0
80009e74:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009e78:	41 90       	lddsp	r0,sp[0x64]
80009e7a:	20 10       	sub	r0,1
80009e7c:	0a 10       	sub	r0,r5
80009e7e:	c0 46       	brmi	80009e86 <_dtoa_r+0x232>
80009e80:	50 40       	stdsp	sp[0x10],r0
80009e82:	30 00       	mov	r0,0
80009e84:	c0 48       	rjmp	80009e8c <_dtoa_r+0x238>
80009e86:	30 0b       	mov	r11,0
80009e88:	5c 30       	neg	r0
80009e8a:	50 4b       	stdsp	sp[0x10],r11
80009e8c:	ec 02 11 00 	rsub	r2,r6,0
80009e90:	58 06       	cp.w	r6,0
80009e92:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009e96:	f5 d6 e4 0a 	addge	r10,r10,r6
80009e9a:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009e9e:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009ea2:	f9 b2 04 00 	movge	r2,0
80009ea6:	e1 d6 e5 10 	sublt	r0,r0,r6
80009eaa:	f9 b9 05 00 	movlt	r9,0
80009eae:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009eb2:	40 c8       	lddsp	r8,sp[0x30]
80009eb4:	58 98       	cp.w	r8,9
80009eb6:	e0 8b 00 20 	brhi	80009ef6 <_dtoa_r+0x2a2>
80009eba:	58 58       	cp.w	r8,5
80009ebc:	f9 b4 0a 01 	movle	r4,1
80009ec0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009ec4:	f7 b5 09 04 	subgt	r5,4
80009ec8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009ecc:	f9 b4 09 00 	movgt	r4,0
80009ed0:	40 cc       	lddsp	r12,sp[0x30]
80009ed2:	58 3c       	cp.w	r12,3
80009ed4:	c2 d0       	breq	80009f2e <_dtoa_r+0x2da>
80009ed6:	e0 89 00 05 	brgt	80009ee0 <_dtoa_r+0x28c>
80009eda:	58 2c       	cp.w	r12,2
80009edc:	c1 01       	brne	80009efc <_dtoa_r+0x2a8>
80009ede:	c1 88       	rjmp	80009f0e <_dtoa_r+0x2ba>
80009ee0:	40 cb       	lddsp	r11,sp[0x30]
80009ee2:	58 4b       	cp.w	r11,4
80009ee4:	c0 60       	breq	80009ef0 <_dtoa_r+0x29c>
80009ee6:	58 5b       	cp.w	r11,5
80009ee8:	c0 a1       	brne	80009efc <_dtoa_r+0x2a8>
80009eea:	30 1a       	mov	r10,1
80009eec:	50 da       	stdsp	sp[0x34],r10
80009eee:	c2 28       	rjmp	80009f32 <_dtoa_r+0x2de>
80009ef0:	30 19       	mov	r9,1
80009ef2:	50 d9       	stdsp	sp[0x34],r9
80009ef4:	c0 f8       	rjmp	80009f12 <_dtoa_r+0x2be>
80009ef6:	30 08       	mov	r8,0
80009ef8:	30 14       	mov	r4,1
80009efa:	50 c8       	stdsp	sp[0x30],r8
80009efc:	3f f5       	mov	r5,-1
80009efe:	30 1c       	mov	r12,1
80009f00:	30 0b       	mov	r11,0
80009f02:	50 95       	stdsp	sp[0x24],r5
80009f04:	50 dc       	stdsp	sp[0x34],r12
80009f06:	0a 91       	mov	r1,r5
80009f08:	31 28       	mov	r8,18
80009f0a:	50 eb       	stdsp	sp[0x38],r11
80009f0c:	c2 08       	rjmp	80009f4c <_dtoa_r+0x2f8>
80009f0e:	30 0a       	mov	r10,0
80009f10:	50 da       	stdsp	sp[0x34],r10
80009f12:	40 e9       	lddsp	r9,sp[0x38]
80009f14:	58 09       	cp.w	r9,0
80009f16:	e0 89 00 07 	brgt	80009f24 <_dtoa_r+0x2d0>
80009f1a:	30 18       	mov	r8,1
80009f1c:	50 98       	stdsp	sp[0x24],r8
80009f1e:	10 91       	mov	r1,r8
80009f20:	50 e8       	stdsp	sp[0x38],r8
80009f22:	c1 58       	rjmp	80009f4c <_dtoa_r+0x2f8>
80009f24:	40 e5       	lddsp	r5,sp[0x38]
80009f26:	50 95       	stdsp	sp[0x24],r5
80009f28:	0a 91       	mov	r1,r5
80009f2a:	0a 98       	mov	r8,r5
80009f2c:	c1 08       	rjmp	80009f4c <_dtoa_r+0x2f8>
80009f2e:	30 0c       	mov	r12,0
80009f30:	50 dc       	stdsp	sp[0x34],r12
80009f32:	40 eb       	lddsp	r11,sp[0x38]
80009f34:	ec 0b 00 0b 	add	r11,r6,r11
80009f38:	50 9b       	stdsp	sp[0x24],r11
80009f3a:	16 98       	mov	r8,r11
80009f3c:	2f f8       	sub	r8,-1
80009f3e:	58 08       	cp.w	r8,0
80009f40:	e0 89 00 05 	brgt	80009f4a <_dtoa_r+0x2f6>
80009f44:	10 91       	mov	r1,r8
80009f46:	30 18       	mov	r8,1
80009f48:	c0 28       	rjmp	80009f4c <_dtoa_r+0x2f8>
80009f4a:	10 91       	mov	r1,r8
80009f4c:	30 09       	mov	r9,0
80009f4e:	6e 9a       	ld.w	r10,r7[0x24]
80009f50:	95 19       	st.w	r10[0x4],r9
80009f52:	30 49       	mov	r9,4
80009f54:	c0 68       	rjmp	80009f60 <_dtoa_r+0x30c>
80009f56:	d7 03       	nop
80009f58:	6a 1a       	ld.w	r10,r5[0x4]
80009f5a:	a1 79       	lsl	r9,0x1
80009f5c:	2f fa       	sub	r10,-1
80009f5e:	8b 1a       	st.w	r5[0x4],r10
80009f60:	6e 95       	ld.w	r5,r7[0x24]
80009f62:	f2 ca ff ec 	sub	r10,r9,-20
80009f66:	10 3a       	cp.w	r10,r8
80009f68:	fe 98 ff f8 	brls	80009f58 <_dtoa_r+0x304>
80009f6c:	6a 1b       	ld.w	r11,r5[0x4]
80009f6e:	0e 9c       	mov	r12,r7
80009f70:	e0 a0 09 44 	rcall	8000b1f8 <_Balloc>
80009f74:	58 e1       	cp.w	r1,14
80009f76:	5f 88       	srls	r8
80009f78:	8b 0c       	st.w	r5[0x0],r12
80009f7a:	f1 e4 00 04 	and	r4,r8,r4
80009f7e:	6e 98       	ld.w	r8,r7[0x24]
80009f80:	70 08       	ld.w	r8,r8[0x0]
80009f82:	50 88       	stdsp	sp[0x20],r8
80009f84:	e0 80 01 82 	breq	8000a288 <_dtoa_r+0x634>
80009f88:	58 06       	cp.w	r6,0
80009f8a:	e0 8a 00 43 	brle	8000a010 <_dtoa_r+0x3bc>
80009f8e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009f92:	fe c8 c4 22 	sub	r8,pc,-15326
80009f96:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009f9a:	fa e5 00 18 	st.d	sp[24],r4
80009f9e:	ec 04 14 04 	asr	r4,r6,0x4
80009fa2:	ed b4 00 04 	bld	r4,0x4
80009fa6:	c0 30       	breq	80009fac <_dtoa_r+0x358>
80009fa8:	30 25       	mov	r5,2
80009faa:	c1 08       	rjmp	80009fca <_dtoa_r+0x376>
80009fac:	fe c8 c3 74 	sub	r8,pc,-15500
80009fb0:	f0 e8 00 20 	ld.d	r8,r8[32]
80009fb4:	fa ea 00 3c 	ld.d	r10,sp[60]
80009fb8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009fbc:	e0 a0 0f fa 	rcall	8000bfb0 <__avr32_f64_div>
80009fc0:	30 35       	mov	r5,3
80009fc2:	14 98       	mov	r8,r10
80009fc4:	16 99       	mov	r9,r11
80009fc6:	fa e9 00 08 	st.d	sp[8],r8
80009fca:	fe cc c3 92 	sub	r12,pc,-15470
80009fce:	50 a3       	stdsp	sp[0x28],r3
80009fd0:	0c 93       	mov	r3,r6
80009fd2:	18 96       	mov	r6,r12
80009fd4:	c0 f8       	rjmp	80009ff2 <_dtoa_r+0x39e>
80009fd6:	fa ea 00 18 	ld.d	r10,sp[24]
80009fda:	ed b4 00 00 	bld	r4,0x0
80009fde:	c0 81       	brne	80009fee <_dtoa_r+0x39a>
80009fe0:	ec e8 00 00 	ld.d	r8,r6[0]
80009fe4:	2f f5       	sub	r5,-1
80009fe6:	e0 a0 0c 9f 	rcall	8000b924 <__avr32_f64_mul>
80009fea:	fa eb 00 18 	st.d	sp[24],r10
80009fee:	a1 54       	asr	r4,0x1
80009ff0:	2f 86       	sub	r6,-8
80009ff2:	58 04       	cp.w	r4,0
80009ff4:	cf 11       	brne	80009fd6 <_dtoa_r+0x382>
80009ff6:	fa e8 00 18 	ld.d	r8,sp[24]
80009ffa:	fa ea 00 08 	ld.d	r10,sp[8]
80009ffe:	06 96       	mov	r6,r3
8000a000:	e0 a0 0f d8 	rcall	8000bfb0 <__avr32_f64_div>
8000a004:	40 a3       	lddsp	r3,sp[0x28]
8000a006:	14 98       	mov	r8,r10
8000a008:	16 99       	mov	r9,r11
8000a00a:	fa e9 00 08 	st.d	sp[8],r8
8000a00e:	c2 f8       	rjmp	8000a06c <_dtoa_r+0x418>
8000a010:	ec 08 11 00 	rsub	r8,r6,0
8000a014:	c0 31       	brne	8000a01a <_dtoa_r+0x3c6>
8000a016:	30 25       	mov	r5,2
8000a018:	c2 a8       	rjmp	8000a06c <_dtoa_r+0x418>
8000a01a:	fe cc c3 e2 	sub	r12,pc,-15390
8000a01e:	f0 04 14 04 	asr	r4,r8,0x4
8000a022:	50 1c       	stdsp	sp[0x4],r12
8000a024:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a028:	fe c9 c4 b8 	sub	r9,pc,-15176
8000a02c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a030:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a034:	e0 a0 0c 78 	rcall	8000b924 <__avr32_f64_mul>
8000a038:	40 1c       	lddsp	r12,sp[0x4]
8000a03a:	50 63       	stdsp	sp[0x18],r3
8000a03c:	30 25       	mov	r5,2
8000a03e:	0c 93       	mov	r3,r6
8000a040:	fa eb 00 08 	st.d	sp[8],r10
8000a044:	18 96       	mov	r6,r12
8000a046:	c0 f8       	rjmp	8000a064 <_dtoa_r+0x410>
8000a048:	fa ea 00 08 	ld.d	r10,sp[8]
8000a04c:	ed b4 00 00 	bld	r4,0x0
8000a050:	c0 81       	brne	8000a060 <_dtoa_r+0x40c>
8000a052:	ec e8 00 00 	ld.d	r8,r6[0]
8000a056:	2f f5       	sub	r5,-1
8000a058:	e0 a0 0c 66 	rcall	8000b924 <__avr32_f64_mul>
8000a05c:	fa eb 00 08 	st.d	sp[8],r10
8000a060:	a1 54       	asr	r4,0x1
8000a062:	2f 86       	sub	r6,-8
8000a064:	58 04       	cp.w	r4,0
8000a066:	cf 11       	brne	8000a048 <_dtoa_r+0x3f4>
8000a068:	06 96       	mov	r6,r3
8000a06a:	40 63       	lddsp	r3,sp[0x18]
8000a06c:	41 4a       	lddsp	r10,sp[0x50]
8000a06e:	58 0a       	cp.w	r10,0
8000a070:	c2 a0       	breq	8000a0c4 <_dtoa_r+0x470>
8000a072:	fa e8 00 08 	ld.d	r8,sp[8]
8000a076:	58 01       	cp.w	r1,0
8000a078:	5f 94       	srgt	r4
8000a07a:	fa e9 00 18 	st.d	sp[24],r8
8000a07e:	30 08       	mov	r8,0
8000a080:	fc 19 3f f0 	movh	r9,0x3ff0
8000a084:	fa ea 00 18 	ld.d	r10,sp[24]
8000a088:	e0 a0 0f 60 	rcall	8000bf48 <__avr32_f64_cmp_lt>
8000a08c:	f9 bc 00 00 	moveq	r12,0
8000a090:	f9 bc 01 01 	movne	r12,1
8000a094:	e9 ec 00 0c 	and	r12,r4,r12
8000a098:	c1 60       	breq	8000a0c4 <_dtoa_r+0x470>
8000a09a:	40 98       	lddsp	r8,sp[0x24]
8000a09c:	58 08       	cp.w	r8,0
8000a09e:	e0 8a 00 f1 	brle	8000a280 <_dtoa_r+0x62c>
8000a0a2:	30 08       	mov	r8,0
8000a0a4:	fc 19 40 24 	movh	r9,0x4024
8000a0a8:	ec c4 00 01 	sub	r4,r6,1
8000a0ac:	fa ea 00 18 	ld.d	r10,sp[24]
8000a0b0:	2f f5       	sub	r5,-1
8000a0b2:	50 64       	stdsp	sp[0x18],r4
8000a0b4:	e0 a0 0c 38 	rcall	8000b924 <__avr32_f64_mul>
8000a0b8:	40 94       	lddsp	r4,sp[0x24]
8000a0ba:	14 98       	mov	r8,r10
8000a0bc:	16 99       	mov	r9,r11
8000a0be:	fa e9 00 08 	st.d	sp[8],r8
8000a0c2:	c0 38       	rjmp	8000a0c8 <_dtoa_r+0x474>
8000a0c4:	50 66       	stdsp	sp[0x18],r6
8000a0c6:	02 94       	mov	r4,r1
8000a0c8:	0a 9c       	mov	r12,r5
8000a0ca:	e0 a0 0e 88 	rcall	8000bdda <__avr32_s32_to_f64>
8000a0ce:	fa e8 00 08 	ld.d	r8,sp[8]
8000a0d2:	e0 a0 0c 29 	rcall	8000b924 <__avr32_f64_mul>
8000a0d6:	30 08       	mov	r8,0
8000a0d8:	fc 19 40 1c 	movh	r9,0x401c
8000a0dc:	e0 a0 0d de 	rcall	8000bc98 <__avr32_f64_add>
8000a0e0:	14 98       	mov	r8,r10
8000a0e2:	16 99       	mov	r9,r11
8000a0e4:	fa e9 00 28 	st.d	sp[40],r8
8000a0e8:	fc 18 fc c0 	movh	r8,0xfcc0
8000a0ec:	40 a5       	lddsp	r5,sp[0x28]
8000a0ee:	10 05       	add	r5,r8
8000a0f0:	50 a5       	stdsp	sp[0x28],r5
8000a0f2:	58 04       	cp.w	r4,0
8000a0f4:	c2 11       	brne	8000a136 <_dtoa_r+0x4e2>
8000a0f6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0fa:	30 08       	mov	r8,0
8000a0fc:	fc 19 40 14 	movh	r9,0x4014
8000a100:	e0 a0 0c fe 	rcall	8000bafc <__avr32_f64_sub>
8000a104:	40 bc       	lddsp	r12,sp[0x2c]
8000a106:	fa eb 00 08 	st.d	sp[8],r10
8000a10a:	14 98       	mov	r8,r10
8000a10c:	16 99       	mov	r9,r11
8000a10e:	18 9a       	mov	r10,r12
8000a110:	0a 9b       	mov	r11,r5
8000a112:	e0 a0 0f 1b 	rcall	8000bf48 <__avr32_f64_cmp_lt>
8000a116:	e0 81 02 54 	brne	8000a5be <_dtoa_r+0x96a>
8000a11a:	0a 98       	mov	r8,r5
8000a11c:	40 b9       	lddsp	r9,sp[0x2c]
8000a11e:	ee 18 80 00 	eorh	r8,0x8000
8000a122:	fa ea 00 08 	ld.d	r10,sp[8]
8000a126:	10 95       	mov	r5,r8
8000a128:	12 98       	mov	r8,r9
8000a12a:	0a 99       	mov	r9,r5
8000a12c:	e0 a0 0f 0e 	rcall	8000bf48 <__avr32_f64_cmp_lt>
8000a130:	e0 81 02 3e 	brne	8000a5ac <_dtoa_r+0x958>
8000a134:	ca 68       	rjmp	8000a280 <_dtoa_r+0x62c>
8000a136:	fe c9 c5 c6 	sub	r9,pc,-14906
8000a13a:	e8 c8 00 01 	sub	r8,r4,1
8000a13e:	40 d5       	lddsp	r5,sp[0x34]
8000a140:	58 05       	cp.w	r5,0
8000a142:	c4 f0       	breq	8000a1e0 <_dtoa_r+0x58c>
8000a144:	30 0c       	mov	r12,0
8000a146:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a14a:	51 3c       	stdsp	sp[0x4c],r12
8000a14c:	30 0a       	mov	r10,0
8000a14e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a152:	e0 a0 0f 2f 	rcall	8000bfb0 <__avr32_f64_div>
8000a156:	fa e8 00 28 	ld.d	r8,sp[40]
8000a15a:	40 85       	lddsp	r5,sp[0x20]
8000a15c:	e0 a0 0c d0 	rcall	8000bafc <__avr32_f64_sub>
8000a160:	fa eb 00 28 	st.d	sp[40],r10
8000a164:	fa ea 00 08 	ld.d	r10,sp[8]
8000a168:	e0 a0 0e 22 	rcall	8000bdac <__avr32_f64_to_s32>
8000a16c:	51 6c       	stdsp	sp[0x58],r12
8000a16e:	e0 a0 0e 36 	rcall	8000bdda <__avr32_s32_to_f64>
8000a172:	14 98       	mov	r8,r10
8000a174:	16 99       	mov	r9,r11
8000a176:	fa ea 00 08 	ld.d	r10,sp[8]
8000a17a:	e0 a0 0c c1 	rcall	8000bafc <__avr32_f64_sub>
8000a17e:	fa eb 00 08 	st.d	sp[8],r10
8000a182:	41 68       	lddsp	r8,sp[0x58]
8000a184:	2d 08       	sub	r8,-48
8000a186:	0a c8       	st.b	r5++,r8
8000a188:	41 39       	lddsp	r9,sp[0x4c]
8000a18a:	2f f9       	sub	r9,-1
8000a18c:	51 39       	stdsp	sp[0x4c],r9
8000a18e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a192:	e0 a0 0e db 	rcall	8000bf48 <__avr32_f64_cmp_lt>
8000a196:	e0 81 03 39 	brne	8000a808 <_dtoa_r+0xbb4>
8000a19a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a19e:	30 0a       	mov	r10,0
8000a1a0:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a1a4:	e0 a0 0c ac 	rcall	8000bafc <__avr32_f64_sub>
8000a1a8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1ac:	e0 a0 0e ce 	rcall	8000bf48 <__avr32_f64_cmp_lt>
8000a1b0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a1b4:	30 08       	mov	r8,0
8000a1b6:	fc 19 40 24 	movh	r9,0x4024
8000a1ba:	e0 81 00 da 	brne	8000a36e <_dtoa_r+0x71a>
8000a1be:	41 3c       	lddsp	r12,sp[0x4c]
8000a1c0:	08 3c       	cp.w	r12,r4
8000a1c2:	c5 f4       	brge	8000a280 <_dtoa_r+0x62c>
8000a1c4:	e0 a0 0b b0 	rcall	8000b924 <__avr32_f64_mul>
8000a1c8:	30 08       	mov	r8,0
8000a1ca:	fa eb 00 28 	st.d	sp[40],r10
8000a1ce:	fc 19 40 24 	movh	r9,0x4024
8000a1d2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1d6:	e0 a0 0b a7 	rcall	8000b924 <__avr32_f64_mul>
8000a1da:	fa eb 00 08 	st.d	sp[8],r10
8000a1de:	cc 3b       	rjmp	8000a164 <_dtoa_r+0x510>
8000a1e0:	40 85       	lddsp	r5,sp[0x20]
8000a1e2:	08 05       	add	r5,r4
8000a1e4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a1e8:	51 35       	stdsp	sp[0x4c],r5
8000a1ea:	fa e8 00 28 	ld.d	r8,sp[40]
8000a1ee:	40 85       	lddsp	r5,sp[0x20]
8000a1f0:	e0 a0 0b 9a 	rcall	8000b924 <__avr32_f64_mul>
8000a1f4:	fa eb 00 28 	st.d	sp[40],r10
8000a1f8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a1fc:	e0 a0 0d d8 	rcall	8000bdac <__avr32_f64_to_s32>
8000a200:	51 6c       	stdsp	sp[0x58],r12
8000a202:	e0 a0 0d ec 	rcall	8000bdda <__avr32_s32_to_f64>
8000a206:	14 98       	mov	r8,r10
8000a208:	16 99       	mov	r9,r11
8000a20a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a20e:	e0 a0 0c 77 	rcall	8000bafc <__avr32_f64_sub>
8000a212:	fa eb 00 08 	st.d	sp[8],r10
8000a216:	41 68       	lddsp	r8,sp[0x58]
8000a218:	2d 08       	sub	r8,-48
8000a21a:	0a c8       	st.b	r5++,r8
8000a21c:	41 3c       	lddsp	r12,sp[0x4c]
8000a21e:	18 35       	cp.w	r5,r12
8000a220:	c2 81       	brne	8000a270 <_dtoa_r+0x61c>
8000a222:	30 08       	mov	r8,0
8000a224:	fc 19 3f e0 	movh	r9,0x3fe0
8000a228:	fa ea 00 28 	ld.d	r10,sp[40]
8000a22c:	e0 a0 0d 36 	rcall	8000bc98 <__avr32_f64_add>
8000a230:	40 85       	lddsp	r5,sp[0x20]
8000a232:	fa e8 00 08 	ld.d	r8,sp[8]
8000a236:	08 05       	add	r5,r4
8000a238:	e0 a0 0e 88 	rcall	8000bf48 <__avr32_f64_cmp_lt>
8000a23c:	e0 81 00 99 	brne	8000a36e <_dtoa_r+0x71a>
8000a240:	fa e8 00 28 	ld.d	r8,sp[40]
8000a244:	30 0a       	mov	r10,0
8000a246:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a24a:	e0 a0 0c 59 	rcall	8000bafc <__avr32_f64_sub>
8000a24e:	14 98       	mov	r8,r10
8000a250:	16 99       	mov	r9,r11
8000a252:	fa ea 00 08 	ld.d	r10,sp[8]
8000a256:	e0 a0 0e 79 	rcall	8000bf48 <__avr32_f64_cmp_lt>
8000a25a:	c1 30       	breq	8000a280 <_dtoa_r+0x62c>
8000a25c:	33 09       	mov	r9,48
8000a25e:	0a 98       	mov	r8,r5
8000a260:	11 7a       	ld.ub	r10,--r8
8000a262:	f2 0a 18 00 	cp.b	r10,r9
8000a266:	e0 81 02 d1 	brne	8000a808 <_dtoa_r+0xbb4>
8000a26a:	10 95       	mov	r5,r8
8000a26c:	cf 9b       	rjmp	8000a25e <_dtoa_r+0x60a>
8000a26e:	d7 03       	nop
8000a270:	30 08       	mov	r8,0
8000a272:	fc 19 40 24 	movh	r9,0x4024
8000a276:	e0 a0 0b 57 	rcall	8000b924 <__avr32_f64_mul>
8000a27a:	fa eb 00 08 	st.d	sp[8],r10
8000a27e:	cb db       	rjmp	8000a1f8 <_dtoa_r+0x5a4>
8000a280:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a284:	fa eb 00 08 	st.d	sp[8],r10
8000a288:	58 e6       	cp.w	r6,14
8000a28a:	5f ab       	srle	r11
8000a28c:	41 8a       	lddsp	r10,sp[0x60]
8000a28e:	30 08       	mov	r8,0
8000a290:	f4 09 11 ff 	rsub	r9,r10,-1
8000a294:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a298:	f0 09 18 00 	cp.b	r9,r8
8000a29c:	e0 80 00 82 	breq	8000a3a0 <_dtoa_r+0x74c>
8000a2a0:	40 ea       	lddsp	r10,sp[0x38]
8000a2a2:	58 01       	cp.w	r1,0
8000a2a4:	5f a9       	srle	r9
8000a2a6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a2aa:	fe ca c7 3a 	sub	r10,pc,-14534
8000a2ae:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a2b2:	fa e5 00 10 	st.d	sp[16],r4
8000a2b6:	f0 09 18 00 	cp.b	r9,r8
8000a2ba:	c1 40       	breq	8000a2e2 <_dtoa_r+0x68e>
8000a2bc:	58 01       	cp.w	r1,0
8000a2be:	e0 81 01 77 	brne	8000a5ac <_dtoa_r+0x958>
8000a2c2:	30 08       	mov	r8,0
8000a2c4:	fc 19 40 14 	movh	r9,0x4014
8000a2c8:	08 9a       	mov	r10,r4
8000a2ca:	0a 9b       	mov	r11,r5
8000a2cc:	e0 a0 0b 2c 	rcall	8000b924 <__avr32_f64_mul>
8000a2d0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a2d4:	e0 a0 0e 06 	rcall	8000bee0 <__avr32_f64_cmp_ge>
8000a2d8:	e0 81 01 6a 	brne	8000a5ac <_dtoa_r+0x958>
8000a2dc:	02 92       	mov	r2,r1
8000a2de:	e0 8f 01 72 	bral	8000a5c2 <_dtoa_r+0x96e>
8000a2e2:	40 85       	lddsp	r5,sp[0x20]
8000a2e4:	30 14       	mov	r4,1
8000a2e6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a2ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a2ee:	e0 a0 0e 61 	rcall	8000bfb0 <__avr32_f64_div>
8000a2f2:	e0 a0 0d 5d 	rcall	8000bdac <__avr32_f64_to_s32>
8000a2f6:	18 92       	mov	r2,r12
8000a2f8:	e0 a0 0d 71 	rcall	8000bdda <__avr32_s32_to_f64>
8000a2fc:	fa e8 00 10 	ld.d	r8,sp[16]
8000a300:	e0 a0 0b 12 	rcall	8000b924 <__avr32_f64_mul>
8000a304:	14 98       	mov	r8,r10
8000a306:	16 99       	mov	r9,r11
8000a308:	fa ea 00 08 	ld.d	r10,sp[8]
8000a30c:	e0 a0 0b f8 	rcall	8000bafc <__avr32_f64_sub>
8000a310:	fa eb 00 08 	st.d	sp[8],r10
8000a314:	e4 c8 ff d0 	sub	r8,r2,-48
8000a318:	0a c8       	st.b	r5++,r8
8000a31a:	fc 19 40 24 	movh	r9,0x4024
8000a31e:	30 08       	mov	r8,0
8000a320:	02 34       	cp.w	r4,r1
8000a322:	c3 31       	brne	8000a388 <_dtoa_r+0x734>
8000a324:	fa e8 00 08 	ld.d	r8,sp[8]
8000a328:	e0 a0 0c b8 	rcall	8000bc98 <__avr32_f64_add>
8000a32c:	16 91       	mov	r1,r11
8000a32e:	14 90       	mov	r0,r10
8000a330:	14 98       	mov	r8,r10
8000a332:	02 99       	mov	r9,r1
8000a334:	fa ea 00 10 	ld.d	r10,sp[16]
8000a338:	e0 a0 0e 08 	rcall	8000bf48 <__avr32_f64_cmp_lt>
8000a33c:	c1 a1       	brne	8000a370 <_dtoa_r+0x71c>
8000a33e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a342:	00 9a       	mov	r10,r0
8000a344:	02 9b       	mov	r11,r1
8000a346:	e0 a0 0d ba 	rcall	8000beba <__avr32_f64_cmp_eq>
8000a34a:	e0 80 02 5e 	breq	8000a806 <_dtoa_r+0xbb2>
8000a34e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a352:	c0 f1       	brne	8000a370 <_dtoa_r+0x71c>
8000a354:	e0 8f 02 59 	bral	8000a806 <_dtoa_r+0xbb2>
8000a358:	40 8a       	lddsp	r10,sp[0x20]
8000a35a:	14 38       	cp.w	r8,r10
8000a35c:	c0 30       	breq	8000a362 <_dtoa_r+0x70e>
8000a35e:	10 95       	mov	r5,r8
8000a360:	c0 98       	rjmp	8000a372 <_dtoa_r+0x71e>
8000a362:	33 08       	mov	r8,48
8000a364:	40 89       	lddsp	r9,sp[0x20]
8000a366:	2f f6       	sub	r6,-1
8000a368:	b2 88       	st.b	r9[0x0],r8
8000a36a:	40 88       	lddsp	r8,sp[0x20]
8000a36c:	c0 88       	rjmp	8000a37c <_dtoa_r+0x728>
8000a36e:	40 66       	lddsp	r6,sp[0x18]
8000a370:	33 99       	mov	r9,57
8000a372:	0a 98       	mov	r8,r5
8000a374:	11 7a       	ld.ub	r10,--r8
8000a376:	f2 0a 18 00 	cp.b	r10,r9
8000a37a:	ce f0       	breq	8000a358 <_dtoa_r+0x704>
8000a37c:	50 66       	stdsp	sp[0x18],r6
8000a37e:	11 89       	ld.ub	r9,r8[0x0]
8000a380:	2f f9       	sub	r9,-1
8000a382:	b0 89       	st.b	r8[0x0],r9
8000a384:	e0 8f 02 42 	bral	8000a808 <_dtoa_r+0xbb4>
8000a388:	e0 a0 0a ce 	rcall	8000b924 <__avr32_f64_mul>
8000a38c:	2f f4       	sub	r4,-1
8000a38e:	fa eb 00 08 	st.d	sp[8],r10
8000a392:	30 08       	mov	r8,0
8000a394:	30 09       	mov	r9,0
8000a396:	e0 a0 0d 92 	rcall	8000beba <__avr32_f64_cmp_eq>
8000a39a:	ca 60       	breq	8000a2e6 <_dtoa_r+0x692>
8000a39c:	e0 8f 02 35 	bral	8000a806 <_dtoa_r+0xbb2>
8000a3a0:	40 d8       	lddsp	r8,sp[0x34]
8000a3a2:	58 08       	cp.w	r8,0
8000a3a4:	c0 51       	brne	8000a3ae <_dtoa_r+0x75a>
8000a3a6:	04 98       	mov	r8,r2
8000a3a8:	00 95       	mov	r5,r0
8000a3aa:	40 d4       	lddsp	r4,sp[0x34]
8000a3ac:	c3 78       	rjmp	8000a41a <_dtoa_r+0x7c6>
8000a3ae:	40 c5       	lddsp	r5,sp[0x30]
8000a3b0:	58 15       	cp.w	r5,1
8000a3b2:	e0 89 00 0f 	brgt	8000a3d0 <_dtoa_r+0x77c>
8000a3b6:	41 74       	lddsp	r4,sp[0x5c]
8000a3b8:	58 04       	cp.w	r4,0
8000a3ba:	c0 40       	breq	8000a3c2 <_dtoa_r+0x76e>
8000a3bc:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a3c0:	c0 48       	rjmp	8000a3c8 <_dtoa_r+0x774>
8000a3c2:	41 99       	lddsp	r9,sp[0x64]
8000a3c4:	f2 09 11 36 	rsub	r9,r9,54
8000a3c8:	04 98       	mov	r8,r2
8000a3ca:	00 95       	mov	r5,r0
8000a3cc:	c1 c8       	rjmp	8000a404 <_dtoa_r+0x7b0>
8000a3ce:	d7 03       	nop
8000a3d0:	e2 c8 00 01 	sub	r8,r1,1
8000a3d4:	58 01       	cp.w	r1,0
8000a3d6:	e0 05 17 40 	movge	r5,r0
8000a3da:	e2 09 17 40 	movge	r9,r1
8000a3de:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a3e2:	f9 b9 05 00 	movlt	r9,0
8000a3e6:	10 32       	cp.w	r2,r8
8000a3e8:	e5 d8 e4 18 	subge	r8,r2,r8
8000a3ec:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a3f0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a3f4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a3f8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a3fc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a400:	f9 b8 05 00 	movlt	r8,0
8000a404:	40 4b       	lddsp	r11,sp[0x10]
8000a406:	12 0b       	add	r11,r9
8000a408:	50 08       	stdsp	sp[0x0],r8
8000a40a:	50 4b       	stdsp	sp[0x10],r11
8000a40c:	12 00       	add	r0,r9
8000a40e:	30 1b       	mov	r11,1
8000a410:	0e 9c       	mov	r12,r7
8000a412:	e0 a0 08 a7 	rcall	8000b560 <__i2b>
8000a416:	40 08       	lddsp	r8,sp[0x0]
8000a418:	18 94       	mov	r4,r12
8000a41a:	40 4a       	lddsp	r10,sp[0x10]
8000a41c:	58 05       	cp.w	r5,0
8000a41e:	5f 99       	srgt	r9
8000a420:	58 0a       	cp.w	r10,0
8000a422:	5f 9a       	srgt	r10
8000a424:	f5 e9 00 09 	and	r9,r10,r9
8000a428:	c0 80       	breq	8000a438 <_dtoa_r+0x7e4>
8000a42a:	40 4c       	lddsp	r12,sp[0x10]
8000a42c:	f8 05 0d 49 	min	r9,r12,r5
8000a430:	12 1c       	sub	r12,r9
8000a432:	12 10       	sub	r0,r9
8000a434:	50 4c       	stdsp	sp[0x10],r12
8000a436:	12 15       	sub	r5,r9
8000a438:	58 02       	cp.w	r2,0
8000a43a:	e0 8a 00 27 	brle	8000a488 <_dtoa_r+0x834>
8000a43e:	40 db       	lddsp	r11,sp[0x34]
8000a440:	58 0b       	cp.w	r11,0
8000a442:	c1 d0       	breq	8000a47c <_dtoa_r+0x828>
8000a444:	58 08       	cp.w	r8,0
8000a446:	e0 8a 00 17 	brle	8000a474 <_dtoa_r+0x820>
8000a44a:	10 9a       	mov	r10,r8
8000a44c:	50 08       	stdsp	sp[0x0],r8
8000a44e:	08 9b       	mov	r11,r4
8000a450:	0e 9c       	mov	r12,r7
8000a452:	e0 a0 08 cd 	rcall	8000b5ec <__pow5mult>
8000a456:	06 9a       	mov	r10,r3
8000a458:	18 9b       	mov	r11,r12
8000a45a:	18 94       	mov	r4,r12
8000a45c:	0e 9c       	mov	r12,r7
8000a45e:	e0 a0 08 01 	rcall	8000b460 <__multiply>
8000a462:	18 99       	mov	r9,r12
8000a464:	06 9b       	mov	r11,r3
8000a466:	50 19       	stdsp	sp[0x4],r9
8000a468:	0e 9c       	mov	r12,r7
8000a46a:	e0 a0 06 ad 	rcall	8000b1c4 <_Bfree>
8000a46e:	40 19       	lddsp	r9,sp[0x4]
8000a470:	40 08       	lddsp	r8,sp[0x0]
8000a472:	12 93       	mov	r3,r9
8000a474:	e4 08 01 0a 	sub	r10,r2,r8
8000a478:	c0 80       	breq	8000a488 <_dtoa_r+0x834>
8000a47a:	c0 28       	rjmp	8000a47e <_dtoa_r+0x82a>
8000a47c:	04 9a       	mov	r10,r2
8000a47e:	06 9b       	mov	r11,r3
8000a480:	0e 9c       	mov	r12,r7
8000a482:	e0 a0 08 b5 	rcall	8000b5ec <__pow5mult>
8000a486:	18 93       	mov	r3,r12
8000a488:	30 1b       	mov	r11,1
8000a48a:	0e 9c       	mov	r12,r7
8000a48c:	e0 a0 08 6a 	rcall	8000b560 <__i2b>
8000a490:	41 1a       	lddsp	r10,sp[0x44]
8000a492:	18 92       	mov	r2,r12
8000a494:	58 0a       	cp.w	r10,0
8000a496:	e0 8a 00 07 	brle	8000a4a4 <_dtoa_r+0x850>
8000a49a:	18 9b       	mov	r11,r12
8000a49c:	0e 9c       	mov	r12,r7
8000a49e:	e0 a0 08 a7 	rcall	8000b5ec <__pow5mult>
8000a4a2:	18 92       	mov	r2,r12
8000a4a4:	40 c9       	lddsp	r9,sp[0x30]
8000a4a6:	58 19       	cp.w	r9,1
8000a4a8:	e0 89 00 14 	brgt	8000a4d0 <_dtoa_r+0x87c>
8000a4ac:	40 38       	lddsp	r8,sp[0xc]
8000a4ae:	58 08       	cp.w	r8,0
8000a4b0:	c1 01       	brne	8000a4d0 <_dtoa_r+0x87c>
8000a4b2:	40 29       	lddsp	r9,sp[0x8]
8000a4b4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a4b8:	c0 c1       	brne	8000a4d0 <_dtoa_r+0x87c>
8000a4ba:	12 98       	mov	r8,r9
8000a4bc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a4c0:	c0 80       	breq	8000a4d0 <_dtoa_r+0x87c>
8000a4c2:	40 4c       	lddsp	r12,sp[0x10]
8000a4c4:	30 1b       	mov	r11,1
8000a4c6:	2f fc       	sub	r12,-1
8000a4c8:	2f f0       	sub	r0,-1
8000a4ca:	50 4c       	stdsp	sp[0x10],r12
8000a4cc:	50 6b       	stdsp	sp[0x18],r11
8000a4ce:	c0 38       	rjmp	8000a4d4 <_dtoa_r+0x880>
8000a4d0:	30 0a       	mov	r10,0
8000a4d2:	50 6a       	stdsp	sp[0x18],r10
8000a4d4:	41 19       	lddsp	r9,sp[0x44]
8000a4d6:	58 09       	cp.w	r9,0
8000a4d8:	c0 31       	brne	8000a4de <_dtoa_r+0x88a>
8000a4da:	30 1c       	mov	r12,1
8000a4dc:	c0 98       	rjmp	8000a4ee <_dtoa_r+0x89a>
8000a4de:	64 48       	ld.w	r8,r2[0x10]
8000a4e0:	2f c8       	sub	r8,-4
8000a4e2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a4e6:	e0 a0 05 df 	rcall	8000b0a4 <__hi0bits>
8000a4ea:	f8 0c 11 20 	rsub	r12,r12,32
8000a4ee:	40 4b       	lddsp	r11,sp[0x10]
8000a4f0:	f8 0b 00 08 	add	r8,r12,r11
8000a4f4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a4f8:	c0 c0       	breq	8000a510 <_dtoa_r+0x8bc>
8000a4fa:	f0 08 11 20 	rsub	r8,r8,32
8000a4fe:	58 48       	cp.w	r8,4
8000a500:	e0 8a 00 06 	brle	8000a50c <_dtoa_r+0x8b8>
8000a504:	20 48       	sub	r8,4
8000a506:	10 0b       	add	r11,r8
8000a508:	50 4b       	stdsp	sp[0x10],r11
8000a50a:	c0 78       	rjmp	8000a518 <_dtoa_r+0x8c4>
8000a50c:	58 48       	cp.w	r8,4
8000a50e:	c0 70       	breq	8000a51c <_dtoa_r+0x8c8>
8000a510:	40 4a       	lddsp	r10,sp[0x10]
8000a512:	2e 48       	sub	r8,-28
8000a514:	10 0a       	add	r10,r8
8000a516:	50 4a       	stdsp	sp[0x10],r10
8000a518:	10 00       	add	r0,r8
8000a51a:	10 05       	add	r5,r8
8000a51c:	58 00       	cp.w	r0,0
8000a51e:	e0 8a 00 08 	brle	8000a52e <_dtoa_r+0x8da>
8000a522:	06 9b       	mov	r11,r3
8000a524:	00 9a       	mov	r10,r0
8000a526:	0e 9c       	mov	r12,r7
8000a528:	e0 a0 07 58 	rcall	8000b3d8 <__lshift>
8000a52c:	18 93       	mov	r3,r12
8000a52e:	40 49       	lddsp	r9,sp[0x10]
8000a530:	58 09       	cp.w	r9,0
8000a532:	e0 8a 00 08 	brle	8000a542 <_dtoa_r+0x8ee>
8000a536:	04 9b       	mov	r11,r2
8000a538:	12 9a       	mov	r10,r9
8000a53a:	0e 9c       	mov	r12,r7
8000a53c:	e0 a0 07 4e 	rcall	8000b3d8 <__lshift>
8000a540:	18 92       	mov	r2,r12
8000a542:	41 48       	lddsp	r8,sp[0x50]
8000a544:	58 08       	cp.w	r8,0
8000a546:	c1 b0       	breq	8000a57c <_dtoa_r+0x928>
8000a548:	04 9b       	mov	r11,r2
8000a54a:	06 9c       	mov	r12,r3
8000a54c:	e0 a0 06 23 	rcall	8000b192 <__mcmp>
8000a550:	c1 64       	brge	8000a57c <_dtoa_r+0x928>
8000a552:	06 9b       	mov	r11,r3
8000a554:	30 09       	mov	r9,0
8000a556:	30 aa       	mov	r10,10
8000a558:	0e 9c       	mov	r12,r7
8000a55a:	e0 a0 08 0b 	rcall	8000b570 <__multadd>
8000a55e:	20 16       	sub	r6,1
8000a560:	18 93       	mov	r3,r12
8000a562:	40 dc       	lddsp	r12,sp[0x34]
8000a564:	58 0c       	cp.w	r12,0
8000a566:	c0 31       	brne	8000a56c <_dtoa_r+0x918>
8000a568:	40 91       	lddsp	r1,sp[0x24]
8000a56a:	c0 98       	rjmp	8000a57c <_dtoa_r+0x928>
8000a56c:	08 9b       	mov	r11,r4
8000a56e:	40 91       	lddsp	r1,sp[0x24]
8000a570:	30 09       	mov	r9,0
8000a572:	30 aa       	mov	r10,10
8000a574:	0e 9c       	mov	r12,r7
8000a576:	e0 a0 07 fd 	rcall	8000b570 <__multadd>
8000a57a:	18 94       	mov	r4,r12
8000a57c:	58 01       	cp.w	r1,0
8000a57e:	5f a9       	srle	r9
8000a580:	40 cb       	lddsp	r11,sp[0x30]
8000a582:	58 2b       	cp.w	r11,2
8000a584:	5f 98       	srgt	r8
8000a586:	f3 e8 00 08 	and	r8,r9,r8
8000a58a:	c2 50       	breq	8000a5d4 <_dtoa_r+0x980>
8000a58c:	58 01       	cp.w	r1,0
8000a58e:	c1 11       	brne	8000a5b0 <_dtoa_r+0x95c>
8000a590:	04 9b       	mov	r11,r2
8000a592:	02 99       	mov	r9,r1
8000a594:	30 5a       	mov	r10,5
8000a596:	0e 9c       	mov	r12,r7
8000a598:	e0 a0 07 ec 	rcall	8000b570 <__multadd>
8000a59c:	18 92       	mov	r2,r12
8000a59e:	18 9b       	mov	r11,r12
8000a5a0:	06 9c       	mov	r12,r3
8000a5a2:	e0 a0 05 f8 	rcall	8000b192 <__mcmp>
8000a5a6:	e0 89 00 0f 	brgt	8000a5c4 <_dtoa_r+0x970>
8000a5aa:	c0 38       	rjmp	8000a5b0 <_dtoa_r+0x95c>
8000a5ac:	30 02       	mov	r2,0
8000a5ae:	04 94       	mov	r4,r2
8000a5b0:	40 ea       	lddsp	r10,sp[0x38]
8000a5b2:	30 09       	mov	r9,0
8000a5b4:	5c da       	com	r10
8000a5b6:	40 85       	lddsp	r5,sp[0x20]
8000a5b8:	50 6a       	stdsp	sp[0x18],r10
8000a5ba:	50 49       	stdsp	sp[0x10],r9
8000a5bc:	c0 f9       	rjmp	8000a7da <_dtoa_r+0xb86>
8000a5be:	08 92       	mov	r2,r4
8000a5c0:	40 66       	lddsp	r6,sp[0x18]
8000a5c2:	04 94       	mov	r4,r2
8000a5c4:	2f f6       	sub	r6,-1
8000a5c6:	50 66       	stdsp	sp[0x18],r6
8000a5c8:	33 18       	mov	r8,49
8000a5ca:	40 85       	lddsp	r5,sp[0x20]
8000a5cc:	0a c8       	st.b	r5++,r8
8000a5ce:	30 08       	mov	r8,0
8000a5d0:	50 48       	stdsp	sp[0x10],r8
8000a5d2:	c0 49       	rjmp	8000a7da <_dtoa_r+0xb86>
8000a5d4:	40 dc       	lddsp	r12,sp[0x34]
8000a5d6:	58 0c       	cp.w	r12,0
8000a5d8:	e0 80 00 b5 	breq	8000a742 <_dtoa_r+0xaee>
8000a5dc:	58 05       	cp.w	r5,0
8000a5de:	e0 8a 00 08 	brle	8000a5ee <_dtoa_r+0x99a>
8000a5e2:	08 9b       	mov	r11,r4
8000a5e4:	0a 9a       	mov	r10,r5
8000a5e6:	0e 9c       	mov	r12,r7
8000a5e8:	e0 a0 06 f8 	rcall	8000b3d8 <__lshift>
8000a5ec:	18 94       	mov	r4,r12
8000a5ee:	40 6b       	lddsp	r11,sp[0x18]
8000a5f0:	58 0b       	cp.w	r11,0
8000a5f2:	c0 31       	brne	8000a5f8 <_dtoa_r+0x9a4>
8000a5f4:	08 9c       	mov	r12,r4
8000a5f6:	c1 38       	rjmp	8000a61c <_dtoa_r+0x9c8>
8000a5f8:	68 1b       	ld.w	r11,r4[0x4]
8000a5fa:	0e 9c       	mov	r12,r7
8000a5fc:	e0 a0 05 fe 	rcall	8000b1f8 <_Balloc>
8000a600:	68 4a       	ld.w	r10,r4[0x10]
8000a602:	18 95       	mov	r5,r12
8000a604:	e8 cb ff f4 	sub	r11,r4,-12
8000a608:	2f ea       	sub	r10,-2
8000a60a:	2f 4c       	sub	r12,-12
8000a60c:	a3 6a       	lsl	r10,0x2
8000a60e:	fe b0 e6 4f 	rcall	800072ac <memcpy>
8000a612:	0a 9b       	mov	r11,r5
8000a614:	30 1a       	mov	r10,1
8000a616:	0e 9c       	mov	r12,r7
8000a618:	e0 a0 06 e0 	rcall	8000b3d8 <__lshift>
8000a61c:	50 44       	stdsp	sp[0x10],r4
8000a61e:	40 3a       	lddsp	r10,sp[0xc]
8000a620:	30 19       	mov	r9,1
8000a622:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a626:	18 94       	mov	r4,r12
8000a628:	50 da       	stdsp	sp[0x34],r10
8000a62a:	40 85       	lddsp	r5,sp[0x20]
8000a62c:	50 99       	stdsp	sp[0x24],r9
8000a62e:	50 26       	stdsp	sp[0x8],r6
8000a630:	50 e1       	stdsp	sp[0x38],r1
8000a632:	04 9b       	mov	r11,r2
8000a634:	06 9c       	mov	r12,r3
8000a636:	fe b0 fa 7f 	rcall	80009b34 <quorem>
8000a63a:	40 4b       	lddsp	r11,sp[0x10]
8000a63c:	f8 c0 ff d0 	sub	r0,r12,-48
8000a640:	06 9c       	mov	r12,r3
8000a642:	e0 a0 05 a8 	rcall	8000b192 <__mcmp>
8000a646:	08 9a       	mov	r10,r4
8000a648:	50 6c       	stdsp	sp[0x18],r12
8000a64a:	04 9b       	mov	r11,r2
8000a64c:	0e 9c       	mov	r12,r7
8000a64e:	e0 a0 06 5d 	rcall	8000b308 <__mdiff>
8000a652:	18 91       	mov	r1,r12
8000a654:	78 38       	ld.w	r8,r12[0xc]
8000a656:	58 08       	cp.w	r8,0
8000a658:	c0 30       	breq	8000a65e <_dtoa_r+0xa0a>
8000a65a:	30 16       	mov	r6,1
8000a65c:	c0 68       	rjmp	8000a668 <_dtoa_r+0xa14>
8000a65e:	18 9b       	mov	r11,r12
8000a660:	06 9c       	mov	r12,r3
8000a662:	e0 a0 05 98 	rcall	8000b192 <__mcmp>
8000a666:	18 96       	mov	r6,r12
8000a668:	0e 9c       	mov	r12,r7
8000a66a:	02 9b       	mov	r11,r1
8000a66c:	e0 a0 05 ac 	rcall	8000b1c4 <_Bfree>
8000a670:	40 cc       	lddsp	r12,sp[0x30]
8000a672:	ed ec 10 08 	or	r8,r6,r12
8000a676:	c0 d1       	brne	8000a690 <_dtoa_r+0xa3c>
8000a678:	40 db       	lddsp	r11,sp[0x34]
8000a67a:	58 0b       	cp.w	r11,0
8000a67c:	c0 a1       	brne	8000a690 <_dtoa_r+0xa3c>
8000a67e:	40 26       	lddsp	r6,sp[0x8]
8000a680:	e0 40 00 39 	cp.w	r0,57
8000a684:	c3 00       	breq	8000a6e4 <_dtoa_r+0xa90>
8000a686:	40 6a       	lddsp	r10,sp[0x18]
8000a688:	58 0a       	cp.w	r10,0
8000a68a:	e0 89 00 24 	brgt	8000a6d2 <_dtoa_r+0xa7e>
8000a68e:	c2 f8       	rjmp	8000a6ec <_dtoa_r+0xa98>
8000a690:	40 69       	lddsp	r9,sp[0x18]
8000a692:	58 09       	cp.w	r9,0
8000a694:	c0 85       	brlt	8000a6a4 <_dtoa_r+0xa50>
8000a696:	12 98       	mov	r8,r9
8000a698:	40 cc       	lddsp	r12,sp[0x30]
8000a69a:	18 48       	or	r8,r12
8000a69c:	c1 d1       	brne	8000a6d6 <_dtoa_r+0xa82>
8000a69e:	40 db       	lddsp	r11,sp[0x34]
8000a6a0:	58 0b       	cp.w	r11,0
8000a6a2:	c1 a1       	brne	8000a6d6 <_dtoa_r+0xa82>
8000a6a4:	0c 99       	mov	r9,r6
8000a6a6:	40 26       	lddsp	r6,sp[0x8]
8000a6a8:	58 09       	cp.w	r9,0
8000a6aa:	e0 8a 00 21 	brle	8000a6ec <_dtoa_r+0xa98>
8000a6ae:	06 9b       	mov	r11,r3
8000a6b0:	30 1a       	mov	r10,1
8000a6b2:	0e 9c       	mov	r12,r7
8000a6b4:	e0 a0 06 92 	rcall	8000b3d8 <__lshift>
8000a6b8:	04 9b       	mov	r11,r2
8000a6ba:	18 93       	mov	r3,r12
8000a6bc:	e0 a0 05 6b 	rcall	8000b192 <__mcmp>
8000a6c0:	e0 89 00 06 	brgt	8000a6cc <_dtoa_r+0xa78>
8000a6c4:	c1 41       	brne	8000a6ec <_dtoa_r+0xa98>
8000a6c6:	ed b0 00 00 	bld	r0,0x0
8000a6ca:	c1 11       	brne	8000a6ec <_dtoa_r+0xa98>
8000a6cc:	e0 40 00 39 	cp.w	r0,57
8000a6d0:	c0 a0       	breq	8000a6e4 <_dtoa_r+0xa90>
8000a6d2:	2f f0       	sub	r0,-1
8000a6d4:	c0 c8       	rjmp	8000a6ec <_dtoa_r+0xa98>
8000a6d6:	58 06       	cp.w	r6,0
8000a6d8:	e0 8a 00 0c 	brle	8000a6f0 <_dtoa_r+0xa9c>
8000a6dc:	40 26       	lddsp	r6,sp[0x8]
8000a6de:	e0 40 00 39 	cp.w	r0,57
8000a6e2:	c0 41       	brne	8000a6ea <_dtoa_r+0xa96>
8000a6e4:	33 98       	mov	r8,57
8000a6e6:	0a c8       	st.b	r5++,r8
8000a6e8:	c6 78       	rjmp	8000a7b6 <_dtoa_r+0xb62>
8000a6ea:	2f f0       	sub	r0,-1
8000a6ec:	0a c0       	st.b	r5++,r0
8000a6ee:	c7 58       	rjmp	8000a7d8 <_dtoa_r+0xb84>
8000a6f0:	0a c0       	st.b	r5++,r0
8000a6f2:	40 9a       	lddsp	r10,sp[0x24]
8000a6f4:	40 e9       	lddsp	r9,sp[0x38]
8000a6f6:	12 3a       	cp.w	r10,r9
8000a6f8:	c4 30       	breq	8000a77e <_dtoa_r+0xb2a>
8000a6fa:	06 9b       	mov	r11,r3
8000a6fc:	30 09       	mov	r9,0
8000a6fe:	30 aa       	mov	r10,10
8000a700:	0e 9c       	mov	r12,r7
8000a702:	e0 a0 07 37 	rcall	8000b570 <__multadd>
8000a706:	40 48       	lddsp	r8,sp[0x10]
8000a708:	18 93       	mov	r3,r12
8000a70a:	08 38       	cp.w	r8,r4
8000a70c:	c0 91       	brne	8000a71e <_dtoa_r+0xaca>
8000a70e:	10 9b       	mov	r11,r8
8000a710:	30 09       	mov	r9,0
8000a712:	30 aa       	mov	r10,10
8000a714:	0e 9c       	mov	r12,r7
8000a716:	e0 a0 07 2d 	rcall	8000b570 <__multadd>
8000a71a:	50 4c       	stdsp	sp[0x10],r12
8000a71c:	c0 e8       	rjmp	8000a738 <_dtoa_r+0xae4>
8000a71e:	40 4b       	lddsp	r11,sp[0x10]
8000a720:	30 09       	mov	r9,0
8000a722:	30 aa       	mov	r10,10
8000a724:	0e 9c       	mov	r12,r7
8000a726:	e0 a0 07 25 	rcall	8000b570 <__multadd>
8000a72a:	08 9b       	mov	r11,r4
8000a72c:	50 4c       	stdsp	sp[0x10],r12
8000a72e:	30 09       	mov	r9,0
8000a730:	30 aa       	mov	r10,10
8000a732:	0e 9c       	mov	r12,r7
8000a734:	e0 a0 07 1e 	rcall	8000b570 <__multadd>
8000a738:	18 94       	mov	r4,r12
8000a73a:	40 9c       	lddsp	r12,sp[0x24]
8000a73c:	2f fc       	sub	r12,-1
8000a73e:	50 9c       	stdsp	sp[0x24],r12
8000a740:	c7 9b       	rjmp	8000a632 <_dtoa_r+0x9de>
8000a742:	30 18       	mov	r8,1
8000a744:	06 90       	mov	r0,r3
8000a746:	40 85       	lddsp	r5,sp[0x20]
8000a748:	08 93       	mov	r3,r4
8000a74a:	0c 94       	mov	r4,r6
8000a74c:	10 96       	mov	r6,r8
8000a74e:	04 9b       	mov	r11,r2
8000a750:	00 9c       	mov	r12,r0
8000a752:	fe b0 f9 f1 	rcall	80009b34 <quorem>
8000a756:	2d 0c       	sub	r12,-48
8000a758:	0a cc       	st.b	r5++,r12
8000a75a:	02 36       	cp.w	r6,r1
8000a75c:	c0 a4       	brge	8000a770 <_dtoa_r+0xb1c>
8000a75e:	00 9b       	mov	r11,r0
8000a760:	30 09       	mov	r9,0
8000a762:	30 aa       	mov	r10,10
8000a764:	0e 9c       	mov	r12,r7
8000a766:	2f f6       	sub	r6,-1
8000a768:	e0 a0 07 04 	rcall	8000b570 <__multadd>
8000a76c:	18 90       	mov	r0,r12
8000a76e:	cf 0b       	rjmp	8000a74e <_dtoa_r+0xafa>
8000a770:	08 96       	mov	r6,r4
8000a772:	30 0b       	mov	r11,0
8000a774:	06 94       	mov	r4,r3
8000a776:	50 4b       	stdsp	sp[0x10],r11
8000a778:	00 93       	mov	r3,r0
8000a77a:	18 90       	mov	r0,r12
8000a77c:	c0 28       	rjmp	8000a780 <_dtoa_r+0xb2c>
8000a77e:	40 26       	lddsp	r6,sp[0x8]
8000a780:	06 9b       	mov	r11,r3
8000a782:	30 1a       	mov	r10,1
8000a784:	0e 9c       	mov	r12,r7
8000a786:	e0 a0 06 29 	rcall	8000b3d8 <__lshift>
8000a78a:	04 9b       	mov	r11,r2
8000a78c:	18 93       	mov	r3,r12
8000a78e:	e0 a0 05 02 	rcall	8000b192 <__mcmp>
8000a792:	e0 89 00 12 	brgt	8000a7b6 <_dtoa_r+0xb62>
8000a796:	c1 b1       	brne	8000a7cc <_dtoa_r+0xb78>
8000a798:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a79c:	c0 d1       	brne	8000a7b6 <_dtoa_r+0xb62>
8000a79e:	c1 78       	rjmp	8000a7cc <_dtoa_r+0xb78>
8000a7a0:	40 89       	lddsp	r9,sp[0x20]
8000a7a2:	12 38       	cp.w	r8,r9
8000a7a4:	c0 30       	breq	8000a7aa <_dtoa_r+0xb56>
8000a7a6:	10 95       	mov	r5,r8
8000a7a8:	c0 88       	rjmp	8000a7b8 <_dtoa_r+0xb64>
8000a7aa:	2f f6       	sub	r6,-1
8000a7ac:	50 66       	stdsp	sp[0x18],r6
8000a7ae:	33 18       	mov	r8,49
8000a7b0:	40 8c       	lddsp	r12,sp[0x20]
8000a7b2:	b8 88       	st.b	r12[0x0],r8
8000a7b4:	c1 38       	rjmp	8000a7da <_dtoa_r+0xb86>
8000a7b6:	33 9a       	mov	r10,57
8000a7b8:	0a 98       	mov	r8,r5
8000a7ba:	11 79       	ld.ub	r9,--r8
8000a7bc:	f4 09 18 00 	cp.b	r9,r10
8000a7c0:	cf 00       	breq	8000a7a0 <_dtoa_r+0xb4c>
8000a7c2:	2f f9       	sub	r9,-1
8000a7c4:	b0 89       	st.b	r8[0x0],r9
8000a7c6:	c0 98       	rjmp	8000a7d8 <_dtoa_r+0xb84>
8000a7c8:	10 95       	mov	r5,r8
8000a7ca:	c0 28       	rjmp	8000a7ce <_dtoa_r+0xb7a>
8000a7cc:	33 09       	mov	r9,48
8000a7ce:	0a 98       	mov	r8,r5
8000a7d0:	11 7a       	ld.ub	r10,--r8
8000a7d2:	f2 0a 18 00 	cp.b	r10,r9
8000a7d6:	cf 90       	breq	8000a7c8 <_dtoa_r+0xb74>
8000a7d8:	50 66       	stdsp	sp[0x18],r6
8000a7da:	04 9b       	mov	r11,r2
8000a7dc:	0e 9c       	mov	r12,r7
8000a7de:	e0 a0 04 f3 	rcall	8000b1c4 <_Bfree>
8000a7e2:	58 04       	cp.w	r4,0
8000a7e4:	c1 20       	breq	8000a808 <_dtoa_r+0xbb4>
8000a7e6:	40 4b       	lddsp	r11,sp[0x10]
8000a7e8:	08 3b       	cp.w	r11,r4
8000a7ea:	5f 19       	srne	r9
8000a7ec:	58 0b       	cp.w	r11,0
8000a7ee:	5f 18       	srne	r8
8000a7f0:	f3 e8 00 08 	and	r8,r9,r8
8000a7f4:	c0 40       	breq	8000a7fc <_dtoa_r+0xba8>
8000a7f6:	0e 9c       	mov	r12,r7
8000a7f8:	e0 a0 04 e6 	rcall	8000b1c4 <_Bfree>
8000a7fc:	08 9b       	mov	r11,r4
8000a7fe:	0e 9c       	mov	r12,r7
8000a800:	e0 a0 04 e2 	rcall	8000b1c4 <_Bfree>
8000a804:	c0 28       	rjmp	8000a808 <_dtoa_r+0xbb4>
8000a806:	50 66       	stdsp	sp[0x18],r6
8000a808:	0e 9c       	mov	r12,r7
8000a80a:	06 9b       	mov	r11,r3
8000a80c:	e0 a0 04 dc 	rcall	8000b1c4 <_Bfree>
8000a810:	30 08       	mov	r8,0
8000a812:	aa 88       	st.b	r5[0x0],r8
8000a814:	40 68       	lddsp	r8,sp[0x18]
8000a816:	41 5a       	lddsp	r10,sp[0x54]
8000a818:	2f f8       	sub	r8,-1
8000a81a:	41 29       	lddsp	r9,sp[0x48]
8000a81c:	95 08       	st.w	r10[0x0],r8
8000a81e:	40 8c       	lddsp	r12,sp[0x20]
8000a820:	58 09       	cp.w	r9,0
8000a822:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a826:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a82a:	2e 6d       	sub	sp,-104
8000a82c:	d8 32       	popm	r0-r7,pc
8000a82e:	d7 03       	nop

8000a830 <__errno>:
8000a830:	e0 68 0a 30 	mov	r8,2608
8000a834:	70 0c       	ld.w	r12,r8[0x0]
8000a836:	2f 4c       	sub	r12,-12
8000a838:	5e fc       	retal	r12
8000a83a:	d7 03       	nop

8000a83c <_fflush_r>:
8000a83c:	d4 21       	pushm	r4-r7,lr
8000a83e:	16 97       	mov	r7,r11
8000a840:	18 96       	mov	r6,r12
8000a842:	76 48       	ld.w	r8,r11[0x10]
8000a844:	58 08       	cp.w	r8,0
8000a846:	c7 f0       	breq	8000a944 <_fflush_r+0x108>
8000a848:	58 0c       	cp.w	r12,0
8000a84a:	c0 50       	breq	8000a854 <_fflush_r+0x18>
8000a84c:	78 68       	ld.w	r8,r12[0x18]
8000a84e:	58 08       	cp.w	r8,0
8000a850:	c0 21       	brne	8000a854 <_fflush_r+0x18>
8000a852:	cc dc       	rcall	8000a9ec <__sinit>
8000a854:	fe c8 cd 94 	sub	r8,pc,-12908
8000a858:	10 37       	cp.w	r7,r8
8000a85a:	c0 31       	brne	8000a860 <_fflush_r+0x24>
8000a85c:	6c 07       	ld.w	r7,r6[0x0]
8000a85e:	c0 c8       	rjmp	8000a876 <_fflush_r+0x3a>
8000a860:	fe c8 cd 80 	sub	r8,pc,-12928
8000a864:	10 37       	cp.w	r7,r8
8000a866:	c0 31       	brne	8000a86c <_fflush_r+0x30>
8000a868:	6c 17       	ld.w	r7,r6[0x4]
8000a86a:	c0 68       	rjmp	8000a876 <_fflush_r+0x3a>
8000a86c:	fe c8 cd 6c 	sub	r8,pc,-12948
8000a870:	10 37       	cp.w	r7,r8
8000a872:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a876:	8e 6a       	ld.sh	r10,r7[0xc]
8000a878:	14 98       	mov	r8,r10
8000a87a:	ed ba 00 03 	bld	r10,0x3
8000a87e:	c4 20       	breq	8000a902 <_fflush_r+0xc6>
8000a880:	ab ba       	sbr	r10,0xb
8000a882:	ae 6a       	st.h	r7[0xc],r10
8000a884:	6e 18       	ld.w	r8,r7[0x4]
8000a886:	58 08       	cp.w	r8,0
8000a888:	e0 89 00 06 	brgt	8000a894 <_fflush_r+0x58>
8000a88c:	6f 08       	ld.w	r8,r7[0x40]
8000a88e:	58 08       	cp.w	r8,0
8000a890:	e0 8a 00 5a 	brle	8000a944 <_fflush_r+0x108>
8000a894:	6e b8       	ld.w	r8,r7[0x2c]
8000a896:	58 08       	cp.w	r8,0
8000a898:	c5 60       	breq	8000a944 <_fflush_r+0x108>
8000a89a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a89e:	c0 30       	breq	8000a8a4 <_fflush_r+0x68>
8000a8a0:	6f 55       	ld.w	r5,r7[0x54]
8000a8a2:	c0 f8       	rjmp	8000a8c0 <_fflush_r+0x84>
8000a8a4:	30 19       	mov	r9,1
8000a8a6:	6e 8b       	ld.w	r11,r7[0x20]
8000a8a8:	0c 9c       	mov	r12,r6
8000a8aa:	5d 18       	icall	r8
8000a8ac:	18 95       	mov	r5,r12
8000a8ae:	5b fc       	cp.w	r12,-1
8000a8b0:	c0 81       	brne	8000a8c0 <_fflush_r+0x84>
8000a8b2:	6c 38       	ld.w	r8,r6[0xc]
8000a8b4:	59 d8       	cp.w	r8,29
8000a8b6:	c4 70       	breq	8000a944 <_fflush_r+0x108>
8000a8b8:	8e 68       	ld.sh	r8,r7[0xc]
8000a8ba:	a7 a8       	sbr	r8,0x6
8000a8bc:	ae 68       	st.h	r7[0xc],r8
8000a8be:	d8 22       	popm	r4-r7,pc
8000a8c0:	8e 68       	ld.sh	r8,r7[0xc]
8000a8c2:	ed b8 00 02 	bld	r8,0x2
8000a8c6:	c0 91       	brne	8000a8d8 <_fflush_r+0x9c>
8000a8c8:	6e 18       	ld.w	r8,r7[0x4]
8000a8ca:	10 15       	sub	r5,r8
8000a8cc:	6e d8       	ld.w	r8,r7[0x34]
8000a8ce:	58 08       	cp.w	r8,0
8000a8d0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a8d4:	eb d8 e1 15 	subne	r5,r5,r8
8000a8d8:	6e b8       	ld.w	r8,r7[0x2c]
8000a8da:	0c 9c       	mov	r12,r6
8000a8dc:	30 09       	mov	r9,0
8000a8de:	0a 9a       	mov	r10,r5
8000a8e0:	6e 8b       	ld.w	r11,r7[0x20]
8000a8e2:	5d 18       	icall	r8
8000a8e4:	8e 68       	ld.sh	r8,r7[0xc]
8000a8e6:	0a 3c       	cp.w	r12,r5
8000a8e8:	c2 61       	brne	8000a934 <_fflush_r+0xf8>
8000a8ea:	ab d8       	cbr	r8,0xb
8000a8ec:	30 0c       	mov	r12,0
8000a8ee:	6e 49       	ld.w	r9,r7[0x10]
8000a8f0:	ae 68       	st.h	r7[0xc],r8
8000a8f2:	8f 1c       	st.w	r7[0x4],r12
8000a8f4:	8f 09       	st.w	r7[0x0],r9
8000a8f6:	ed b8 00 0c 	bld	r8,0xc
8000a8fa:	c2 51       	brne	8000a944 <_fflush_r+0x108>
8000a8fc:	ef 45 00 54 	st.w	r7[84],r5
8000a900:	d8 22       	popm	r4-r7,pc
8000a902:	6e 45       	ld.w	r5,r7[0x10]
8000a904:	58 05       	cp.w	r5,0
8000a906:	c1 f0       	breq	8000a944 <_fflush_r+0x108>
8000a908:	6e 04       	ld.w	r4,r7[0x0]
8000a90a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a90e:	8f 05       	st.w	r7[0x0],r5
8000a910:	f9 b8 01 00 	movne	r8,0
8000a914:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a918:	0a 14       	sub	r4,r5
8000a91a:	8f 28       	st.w	r7[0x8],r8
8000a91c:	c1 18       	rjmp	8000a93e <_fflush_r+0x102>
8000a91e:	08 99       	mov	r9,r4
8000a920:	0a 9a       	mov	r10,r5
8000a922:	6e a8       	ld.w	r8,r7[0x28]
8000a924:	6e 8b       	ld.w	r11,r7[0x20]
8000a926:	0c 9c       	mov	r12,r6
8000a928:	5d 18       	icall	r8
8000a92a:	18 14       	sub	r4,r12
8000a92c:	58 0c       	cp.w	r12,0
8000a92e:	e0 89 00 07 	brgt	8000a93c <_fflush_r+0x100>
8000a932:	8e 68       	ld.sh	r8,r7[0xc]
8000a934:	a7 a8       	sbr	r8,0x6
8000a936:	3f fc       	mov	r12,-1
8000a938:	ae 68       	st.h	r7[0xc],r8
8000a93a:	d8 22       	popm	r4-r7,pc
8000a93c:	18 05       	add	r5,r12
8000a93e:	58 04       	cp.w	r4,0
8000a940:	fe 99 ff ef 	brgt	8000a91e <_fflush_r+0xe2>
8000a944:	d8 2a       	popm	r4-r7,pc,r12=0
8000a946:	d7 03       	nop

8000a948 <__sfp_lock_acquire>:
8000a948:	5e fc       	retal	r12

8000a94a <__sfp_lock_release>:
8000a94a:	5e fc       	retal	r12

8000a94c <_cleanup_r>:
8000a94c:	d4 01       	pushm	lr
8000a94e:	fe cb f0 ae 	sub	r11,pc,-3922
8000a952:	e0 a0 02 f7 	rcall	8000af40 <_fwalk>
8000a956:	d8 02       	popm	pc

8000a958 <__sfmoreglue>:
8000a958:	d4 21       	pushm	r4-r7,lr
8000a95a:	16 95       	mov	r5,r11
8000a95c:	f6 06 10 5c 	mul	r6,r11,92
8000a960:	ec cb ff f4 	sub	r11,r6,-12
8000a964:	fe b0 e2 88 	rcall	80006e74 <_malloc_r>
8000a968:	18 97       	mov	r7,r12
8000a96a:	c0 90       	breq	8000a97c <__sfmoreglue+0x24>
8000a96c:	99 15       	st.w	r12[0x4],r5
8000a96e:	30 0b       	mov	r11,0
8000a970:	2f 4c       	sub	r12,-12
8000a972:	0c 9a       	mov	r10,r6
8000a974:	8f 2c       	st.w	r7[0x8],r12
8000a976:	8f 0b       	st.w	r7[0x0],r11
8000a978:	fe b0 e5 3e 	rcall	800073f4 <memset>
8000a97c:	0e 9c       	mov	r12,r7
8000a97e:	d8 22       	popm	r4-r7,pc

8000a980 <__sfp>:
8000a980:	d4 21       	pushm	r4-r7,lr
8000a982:	fe c8 ce 5e 	sub	r8,pc,-12706
8000a986:	18 96       	mov	r6,r12
8000a988:	70 07       	ld.w	r7,r8[0x0]
8000a98a:	6e 68       	ld.w	r8,r7[0x18]
8000a98c:	58 08       	cp.w	r8,0
8000a98e:	c0 31       	brne	8000a994 <__sfp+0x14>
8000a990:	0e 9c       	mov	r12,r7
8000a992:	c2 dc       	rcall	8000a9ec <__sinit>
8000a994:	ee c7 ff 28 	sub	r7,r7,-216
8000a998:	30 05       	mov	r5,0
8000a99a:	6e 2c       	ld.w	r12,r7[0x8]
8000a99c:	6e 18       	ld.w	r8,r7[0x4]
8000a99e:	c0 68       	rjmp	8000a9aa <__sfp+0x2a>
8000a9a0:	98 69       	ld.sh	r9,r12[0xc]
8000a9a2:	ea 09 19 00 	cp.h	r9,r5
8000a9a6:	c1 10       	breq	8000a9c8 <__sfp+0x48>
8000a9a8:	2a 4c       	sub	r12,-92
8000a9aa:	20 18       	sub	r8,1
8000a9ac:	cf a7       	brpl	8000a9a0 <__sfp+0x20>
8000a9ae:	6e 08       	ld.w	r8,r7[0x0]
8000a9b0:	58 08       	cp.w	r8,0
8000a9b2:	c0 61       	brne	8000a9be <__sfp+0x3e>
8000a9b4:	30 4b       	mov	r11,4
8000a9b6:	0c 9c       	mov	r12,r6
8000a9b8:	cd 0f       	rcall	8000a958 <__sfmoreglue>
8000a9ba:	8f 0c       	st.w	r7[0x0],r12
8000a9bc:	c0 30       	breq	8000a9c2 <__sfp+0x42>
8000a9be:	6e 07       	ld.w	r7,r7[0x0]
8000a9c0:	ce db       	rjmp	8000a99a <__sfp+0x1a>
8000a9c2:	30 c8       	mov	r8,12
8000a9c4:	8d 38       	st.w	r6[0xc],r8
8000a9c6:	d8 22       	popm	r4-r7,pc
8000a9c8:	30 08       	mov	r8,0
8000a9ca:	f9 48 00 4c 	st.w	r12[76],r8
8000a9ce:	99 08       	st.w	r12[0x0],r8
8000a9d0:	99 28       	st.w	r12[0x8],r8
8000a9d2:	99 18       	st.w	r12[0x4],r8
8000a9d4:	99 48       	st.w	r12[0x10],r8
8000a9d6:	99 58       	st.w	r12[0x14],r8
8000a9d8:	99 68       	st.w	r12[0x18],r8
8000a9da:	99 d8       	st.w	r12[0x34],r8
8000a9dc:	99 e8       	st.w	r12[0x38],r8
8000a9de:	f9 48 00 48 	st.w	r12[72],r8
8000a9e2:	3f f8       	mov	r8,-1
8000a9e4:	b8 78       	st.h	r12[0xe],r8
8000a9e6:	30 18       	mov	r8,1
8000a9e8:	b8 68       	st.h	r12[0xc],r8
8000a9ea:	d8 22       	popm	r4-r7,pc

8000a9ec <__sinit>:
8000a9ec:	d4 21       	pushm	r4-r7,lr
8000a9ee:	18 96       	mov	r6,r12
8000a9f0:	78 67       	ld.w	r7,r12[0x18]
8000a9f2:	58 07       	cp.w	r7,0
8000a9f4:	c4 91       	brne	8000aa86 <__sinit+0x9a>
8000a9f6:	fe c8 00 aa 	sub	r8,pc,170
8000a9fa:	30 15       	mov	r5,1
8000a9fc:	99 a8       	st.w	r12[0x28],r8
8000a9fe:	f9 47 00 d8 	st.w	r12[216],r7
8000aa02:	f9 47 00 dc 	st.w	r12[220],r7
8000aa06:	f9 47 00 e0 	st.w	r12[224],r7
8000aa0a:	99 65       	st.w	r12[0x18],r5
8000aa0c:	cb af       	rcall	8000a980 <__sfp>
8000aa0e:	8d 0c       	st.w	r6[0x0],r12
8000aa10:	0c 9c       	mov	r12,r6
8000aa12:	cb 7f       	rcall	8000a980 <__sfp>
8000aa14:	8d 1c       	st.w	r6[0x4],r12
8000aa16:	0c 9c       	mov	r12,r6
8000aa18:	cb 4f       	rcall	8000a980 <__sfp>
8000aa1a:	6c 09       	ld.w	r9,r6[0x0]
8000aa1c:	30 48       	mov	r8,4
8000aa1e:	93 07       	st.w	r9[0x0],r7
8000aa20:	b2 68       	st.h	r9[0xc],r8
8000aa22:	93 17       	st.w	r9[0x4],r7
8000aa24:	93 27       	st.w	r9[0x8],r7
8000aa26:	6c 18       	ld.w	r8,r6[0x4]
8000aa28:	b2 77       	st.h	r9[0xe],r7
8000aa2a:	93 47       	st.w	r9[0x10],r7
8000aa2c:	93 57       	st.w	r9[0x14],r7
8000aa2e:	93 67       	st.w	r9[0x18],r7
8000aa30:	93 89       	st.w	r9[0x20],r9
8000aa32:	91 07       	st.w	r8[0x0],r7
8000aa34:	91 17       	st.w	r8[0x4],r7
8000aa36:	91 27       	st.w	r8[0x8],r7
8000aa38:	fe ce f3 24 	sub	lr,pc,-3292
8000aa3c:	fe cb f3 54 	sub	r11,pc,-3244
8000aa40:	93 9e       	st.w	r9[0x24],lr
8000aa42:	93 ab       	st.w	r9[0x28],r11
8000aa44:	fe ca f3 7c 	sub	r10,pc,-3204
8000aa48:	fe c4 f3 88 	sub	r4,pc,-3192
8000aa4c:	93 ba       	st.w	r9[0x2c],r10
8000aa4e:	93 c4       	st.w	r9[0x30],r4
8000aa50:	30 99       	mov	r9,9
8000aa52:	b0 69       	st.h	r8[0xc],r9
8000aa54:	b0 75       	st.h	r8[0xe],r5
8000aa56:	91 c4       	st.w	r8[0x30],r4
8000aa58:	91 47       	st.w	r8[0x10],r7
8000aa5a:	91 57       	st.w	r8[0x14],r7
8000aa5c:	91 67       	st.w	r8[0x18],r7
8000aa5e:	91 88       	st.w	r8[0x20],r8
8000aa60:	91 9e       	st.w	r8[0x24],lr
8000aa62:	91 ab       	st.w	r8[0x28],r11
8000aa64:	91 ba       	st.w	r8[0x2c],r10
8000aa66:	8d 2c       	st.w	r6[0x8],r12
8000aa68:	31 28       	mov	r8,18
8000aa6a:	99 07       	st.w	r12[0x0],r7
8000aa6c:	b8 68       	st.h	r12[0xc],r8
8000aa6e:	99 17       	st.w	r12[0x4],r7
8000aa70:	99 27       	st.w	r12[0x8],r7
8000aa72:	30 28       	mov	r8,2
8000aa74:	b8 78       	st.h	r12[0xe],r8
8000aa76:	99 c4       	st.w	r12[0x30],r4
8000aa78:	99 67       	st.w	r12[0x18],r7
8000aa7a:	99 9e       	st.w	r12[0x24],lr
8000aa7c:	99 ab       	st.w	r12[0x28],r11
8000aa7e:	99 ba       	st.w	r12[0x2c],r10
8000aa80:	99 47       	st.w	r12[0x10],r7
8000aa82:	99 57       	st.w	r12[0x14],r7
8000aa84:	99 8c       	st.w	r12[0x20],r12
8000aa86:	d8 22       	popm	r4-r7,pc

8000aa88 <_malloc_trim_r>:
8000aa88:	d4 21       	pushm	r4-r7,lr
8000aa8a:	16 95       	mov	r5,r11
8000aa8c:	18 97       	mov	r7,r12
8000aa8e:	fe b0 d7 b1 	rcall	800059f0 <__malloc_lock>
8000aa92:	e0 64 05 30 	mov	r4,1328
8000aa96:	68 28       	ld.w	r8,r4[0x8]
8000aa98:	70 16       	ld.w	r6,r8[0x4]
8000aa9a:	e0 16 ff fc 	andl	r6,0xfffc
8000aa9e:	ec c8 ff 91 	sub	r8,r6,-111
8000aaa2:	f0 05 01 05 	sub	r5,r8,r5
8000aaa6:	e0 15 ff 80 	andl	r5,0xff80
8000aaaa:	ea c5 00 80 	sub	r5,r5,128
8000aaae:	e0 45 00 7f 	cp.w	r5,127
8000aab2:	e0 8a 00 25 	brle	8000aafc <_malloc_trim_r+0x74>
8000aab6:	30 0b       	mov	r11,0
8000aab8:	0e 9c       	mov	r12,r7
8000aaba:	fe b0 e6 05 	rcall	800076c4 <_sbrk_r>
8000aabe:	68 28       	ld.w	r8,r4[0x8]
8000aac0:	0c 08       	add	r8,r6
8000aac2:	10 3c       	cp.w	r12,r8
8000aac4:	c1 c1       	brne	8000aafc <_malloc_trim_r+0x74>
8000aac6:	ea 0b 11 00 	rsub	r11,r5,0
8000aaca:	0e 9c       	mov	r12,r7
8000aacc:	fe b0 e5 fc 	rcall	800076c4 <_sbrk_r>
8000aad0:	5b fc       	cp.w	r12,-1
8000aad2:	c1 91       	brne	8000ab04 <_malloc_trim_r+0x7c>
8000aad4:	30 0b       	mov	r11,0
8000aad6:	0e 9c       	mov	r12,r7
8000aad8:	fe b0 e5 f6 	rcall	800076c4 <_sbrk_r>
8000aadc:	68 28       	ld.w	r8,r4[0x8]
8000aade:	f8 08 01 09 	sub	r9,r12,r8
8000aae2:	58 f9       	cp.w	r9,15
8000aae4:	e0 8a 00 0c 	brle	8000aafc <_malloc_trim_r+0x74>
8000aae8:	a1 a9       	sbr	r9,0x0
8000aaea:	91 19       	st.w	r8[0x4],r9
8000aaec:	e0 68 09 3c 	mov	r8,2364
8000aaf0:	70 09       	ld.w	r9,r8[0x0]
8000aaf2:	e0 68 0d 4c 	mov	r8,3404
8000aaf6:	f8 09 01 09 	sub	r9,r12,r9
8000aafa:	91 09       	st.w	r8[0x0],r9
8000aafc:	0e 9c       	mov	r12,r7
8000aafe:	fe b0 d7 7f 	rcall	800059fc <__malloc_unlock>
8000ab02:	d8 2a       	popm	r4-r7,pc,r12=0
8000ab04:	68 28       	ld.w	r8,r4[0x8]
8000ab06:	0a 16       	sub	r6,r5
8000ab08:	a1 a6       	sbr	r6,0x0
8000ab0a:	91 16       	st.w	r8[0x4],r6
8000ab0c:	e0 68 0d 4c 	mov	r8,3404
8000ab10:	70 09       	ld.w	r9,r8[0x0]
8000ab12:	0a 19       	sub	r9,r5
8000ab14:	0e 9c       	mov	r12,r7
8000ab16:	91 09       	st.w	r8[0x0],r9
8000ab18:	fe b0 d7 72 	rcall	800059fc <__malloc_unlock>
8000ab1c:	da 2a       	popm	r4-r7,pc,r12=1
8000ab1e:	d7 03       	nop

8000ab20 <_free_r>:
8000ab20:	d4 21       	pushm	r4-r7,lr
8000ab22:	16 96       	mov	r6,r11
8000ab24:	18 97       	mov	r7,r12
8000ab26:	58 0b       	cp.w	r11,0
8000ab28:	e0 80 00 c0 	breq	8000aca8 <_free_r+0x188>
8000ab2c:	fe b0 d7 62 	rcall	800059f0 <__malloc_lock>
8000ab30:	20 86       	sub	r6,8
8000ab32:	e0 6a 05 30 	mov	r10,1328
8000ab36:	6c 18       	ld.w	r8,r6[0x4]
8000ab38:	74 2e       	ld.w	lr,r10[0x8]
8000ab3a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000ab3e:	a1 c8       	cbr	r8,0x0
8000ab40:	ec 08 00 09 	add	r9,r6,r8
8000ab44:	72 1b       	ld.w	r11,r9[0x4]
8000ab46:	e0 1b ff fc 	andl	r11,0xfffc
8000ab4a:	1c 39       	cp.w	r9,lr
8000ab4c:	c1 e1       	brne	8000ab88 <_free_r+0x68>
8000ab4e:	f6 08 00 08 	add	r8,r11,r8
8000ab52:	58 0c       	cp.w	r12,0
8000ab54:	c0 81       	brne	8000ab64 <_free_r+0x44>
8000ab56:	6c 09       	ld.w	r9,r6[0x0]
8000ab58:	12 16       	sub	r6,r9
8000ab5a:	12 08       	add	r8,r9
8000ab5c:	6c 3b       	ld.w	r11,r6[0xc]
8000ab5e:	6c 29       	ld.w	r9,r6[0x8]
8000ab60:	97 29       	st.w	r11[0x8],r9
8000ab62:	93 3b       	st.w	r9[0xc],r11
8000ab64:	10 99       	mov	r9,r8
8000ab66:	95 26       	st.w	r10[0x8],r6
8000ab68:	a1 a9       	sbr	r9,0x0
8000ab6a:	8d 19       	st.w	r6[0x4],r9
8000ab6c:	e0 69 09 38 	mov	r9,2360
8000ab70:	72 09       	ld.w	r9,r9[0x0]
8000ab72:	12 38       	cp.w	r8,r9
8000ab74:	c0 63       	brcs	8000ab80 <_free_r+0x60>
8000ab76:	e0 68 0d 48 	mov	r8,3400
8000ab7a:	0e 9c       	mov	r12,r7
8000ab7c:	70 0b       	ld.w	r11,r8[0x0]
8000ab7e:	c8 5f       	rcall	8000aa88 <_malloc_trim_r>
8000ab80:	0e 9c       	mov	r12,r7
8000ab82:	fe b0 d7 3d 	rcall	800059fc <__malloc_unlock>
8000ab86:	d8 22       	popm	r4-r7,pc
8000ab88:	93 1b       	st.w	r9[0x4],r11
8000ab8a:	58 0c       	cp.w	r12,0
8000ab8c:	c0 30       	breq	8000ab92 <_free_r+0x72>
8000ab8e:	30 0c       	mov	r12,0
8000ab90:	c1 08       	rjmp	8000abb0 <_free_r+0x90>
8000ab92:	6c 0e       	ld.w	lr,r6[0x0]
8000ab94:	f4 c5 ff f8 	sub	r5,r10,-8
8000ab98:	1c 16       	sub	r6,lr
8000ab9a:	1c 08       	add	r8,lr
8000ab9c:	6c 2e       	ld.w	lr,r6[0x8]
8000ab9e:	0a 3e       	cp.w	lr,r5
8000aba0:	f9 bc 00 01 	moveq	r12,1
8000aba4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000aba8:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000abac:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000abb0:	f2 0b 00 0e 	add	lr,r9,r11
8000abb4:	7c 1e       	ld.w	lr,lr[0x4]
8000abb6:	ed be 00 00 	bld	lr,0x0
8000abba:	c1 40       	breq	8000abe2 <_free_r+0xc2>
8000abbc:	16 08       	add	r8,r11
8000abbe:	58 0c       	cp.w	r12,0
8000abc0:	c0 d1       	brne	8000abda <_free_r+0xba>
8000abc2:	e0 6e 05 30 	mov	lr,1328
8000abc6:	72 2b       	ld.w	r11,r9[0x8]
8000abc8:	2f 8e       	sub	lr,-8
8000abca:	1c 3b       	cp.w	r11,lr
8000abcc:	c0 71       	brne	8000abda <_free_r+0xba>
8000abce:	97 36       	st.w	r11[0xc],r6
8000abd0:	97 26       	st.w	r11[0x8],r6
8000abd2:	8d 2b       	st.w	r6[0x8],r11
8000abd4:	8d 3b       	st.w	r6[0xc],r11
8000abd6:	30 1c       	mov	r12,1
8000abd8:	c0 58       	rjmp	8000abe2 <_free_r+0xc2>
8000abda:	72 2b       	ld.w	r11,r9[0x8]
8000abdc:	72 39       	ld.w	r9,r9[0xc]
8000abde:	93 2b       	st.w	r9[0x8],r11
8000abe0:	97 39       	st.w	r11[0xc],r9
8000abe2:	10 99       	mov	r9,r8
8000abe4:	ec 08 09 08 	st.w	r6[r8],r8
8000abe8:	a1 a9       	sbr	r9,0x0
8000abea:	8d 19       	st.w	r6[0x4],r9
8000abec:	58 0c       	cp.w	r12,0
8000abee:	c5 a1       	brne	8000aca2 <_free_r+0x182>
8000abf0:	e0 48 01 ff 	cp.w	r8,511
8000abf4:	e0 8b 00 13 	brhi	8000ac1a <_free_r+0xfa>
8000abf8:	a3 98       	lsr	r8,0x3
8000abfa:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000abfe:	72 2b       	ld.w	r11,r9[0x8]
8000ac00:	8d 39       	st.w	r6[0xc],r9
8000ac02:	8d 2b       	st.w	r6[0x8],r11
8000ac04:	97 36       	st.w	r11[0xc],r6
8000ac06:	93 26       	st.w	r9[0x8],r6
8000ac08:	a3 48       	asr	r8,0x2
8000ac0a:	74 19       	ld.w	r9,r10[0x4]
8000ac0c:	30 1b       	mov	r11,1
8000ac0e:	f6 08 09 48 	lsl	r8,r11,r8
8000ac12:	f3 e8 10 08 	or	r8,r9,r8
8000ac16:	95 18       	st.w	r10[0x4],r8
8000ac18:	c4 58       	rjmp	8000aca2 <_free_r+0x182>
8000ac1a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ac1e:	58 4b       	cp.w	r11,4
8000ac20:	e0 8b 00 06 	brhi	8000ac2c <_free_r+0x10c>
8000ac24:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ac28:	2c 8b       	sub	r11,-56
8000ac2a:	c2 08       	rjmp	8000ac6a <_free_r+0x14a>
8000ac2c:	59 4b       	cp.w	r11,20
8000ac2e:	e0 8b 00 04 	brhi	8000ac36 <_free_r+0x116>
8000ac32:	2a 5b       	sub	r11,-91
8000ac34:	c1 b8       	rjmp	8000ac6a <_free_r+0x14a>
8000ac36:	e0 4b 00 54 	cp.w	r11,84
8000ac3a:	e0 8b 00 06 	brhi	8000ac46 <_free_r+0x126>
8000ac3e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ac42:	29 2b       	sub	r11,-110
8000ac44:	c1 38       	rjmp	8000ac6a <_free_r+0x14a>
8000ac46:	e0 4b 01 54 	cp.w	r11,340
8000ac4a:	e0 8b 00 06 	brhi	8000ac56 <_free_r+0x136>
8000ac4e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ac52:	28 9b       	sub	r11,-119
8000ac54:	c0 b8       	rjmp	8000ac6a <_free_r+0x14a>
8000ac56:	e0 4b 05 54 	cp.w	r11,1364
8000ac5a:	e0 88 00 05 	brls	8000ac64 <_free_r+0x144>
8000ac5e:	37 eb       	mov	r11,126
8000ac60:	c0 58       	rjmp	8000ac6a <_free_r+0x14a>
8000ac62:	d7 03       	nop
8000ac64:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ac68:	28 4b       	sub	r11,-124
8000ac6a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ac6e:	78 29       	ld.w	r9,r12[0x8]
8000ac70:	18 39       	cp.w	r9,r12
8000ac72:	c0 e1       	brne	8000ac8e <_free_r+0x16e>
8000ac74:	74 18       	ld.w	r8,r10[0x4]
8000ac76:	a3 4b       	asr	r11,0x2
8000ac78:	30 1c       	mov	r12,1
8000ac7a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ac7e:	f1 eb 10 0b 	or	r11,r8,r11
8000ac82:	12 98       	mov	r8,r9
8000ac84:	95 1b       	st.w	r10[0x4],r11
8000ac86:	c0 a8       	rjmp	8000ac9a <_free_r+0x17a>
8000ac88:	72 29       	ld.w	r9,r9[0x8]
8000ac8a:	18 39       	cp.w	r9,r12
8000ac8c:	c0 60       	breq	8000ac98 <_free_r+0x178>
8000ac8e:	72 1a       	ld.w	r10,r9[0x4]
8000ac90:	e0 1a ff fc 	andl	r10,0xfffc
8000ac94:	14 38       	cp.w	r8,r10
8000ac96:	cf 93       	brcs	8000ac88 <_free_r+0x168>
8000ac98:	72 38       	ld.w	r8,r9[0xc]
8000ac9a:	8d 38       	st.w	r6[0xc],r8
8000ac9c:	8d 29       	st.w	r6[0x8],r9
8000ac9e:	93 36       	st.w	r9[0xc],r6
8000aca0:	91 26       	st.w	r8[0x8],r6
8000aca2:	0e 9c       	mov	r12,r7
8000aca4:	fe b0 d6 ac 	rcall	800059fc <__malloc_unlock>
8000aca8:	d8 22       	popm	r4-r7,pc
8000acaa:	d7 03       	nop

8000acac <__sfvwrite_r>:
8000acac:	d4 31       	pushm	r0-r7,lr
8000acae:	20 3d       	sub	sp,12
8000acb0:	14 94       	mov	r4,r10
8000acb2:	18 95       	mov	r5,r12
8000acb4:	16 97       	mov	r7,r11
8000acb6:	74 28       	ld.w	r8,r10[0x8]
8000acb8:	58 08       	cp.w	r8,0
8000acba:	e0 80 01 40 	breq	8000af3a <__sfvwrite_r+0x28e>
8000acbe:	96 68       	ld.sh	r8,r11[0xc]
8000acc0:	ed b8 00 03 	bld	r8,0x3
8000acc4:	c0 41       	brne	8000accc <__sfvwrite_r+0x20>
8000acc6:	76 48       	ld.w	r8,r11[0x10]
8000acc8:	58 08       	cp.w	r8,0
8000acca:	c0 c1       	brne	8000ace2 <__sfvwrite_r+0x36>
8000accc:	0e 9b       	mov	r11,r7
8000acce:	0a 9c       	mov	r12,r5
8000acd0:	fe b0 f6 c4 	rcall	80009a58 <__swsetup_r>
8000acd4:	c0 70       	breq	8000ace2 <__sfvwrite_r+0x36>
8000acd6:	8e 68       	ld.sh	r8,r7[0xc]
8000acd8:	a7 a8       	sbr	r8,0x6
8000acda:	ae 68       	st.h	r7[0xc],r8
8000acdc:	30 98       	mov	r8,9
8000acde:	8b 38       	st.w	r5[0xc],r8
8000ace0:	c2 b9       	rjmp	8000af36 <__sfvwrite_r+0x28a>
8000ace2:	8e 63       	ld.sh	r3,r7[0xc]
8000ace4:	68 00       	ld.w	r0,r4[0x0]
8000ace6:	06 96       	mov	r6,r3
8000ace8:	e2 16 00 02 	andl	r6,0x2,COH
8000acec:	c2 10       	breq	8000ad2e <__sfvwrite_r+0x82>
8000acee:	30 03       	mov	r3,0
8000acf0:	e0 62 04 00 	mov	r2,1024
8000acf4:	06 96       	mov	r6,r3
8000acf6:	c0 48       	rjmp	8000acfe <__sfvwrite_r+0x52>
8000acf8:	60 03       	ld.w	r3,r0[0x0]
8000acfa:	60 16       	ld.w	r6,r0[0x4]
8000acfc:	2f 80       	sub	r0,-8
8000acfe:	58 06       	cp.w	r6,0
8000ad00:	cf c0       	breq	8000acf8 <__sfvwrite_r+0x4c>
8000ad02:	e0 46 04 00 	cp.w	r6,1024
8000ad06:	ec 09 17 80 	movls	r9,r6
8000ad0a:	e4 09 17 b0 	movhi	r9,r2
8000ad0e:	06 9a       	mov	r10,r3
8000ad10:	6e a8       	ld.w	r8,r7[0x28]
8000ad12:	6e 8b       	ld.w	r11,r7[0x20]
8000ad14:	0a 9c       	mov	r12,r5
8000ad16:	5d 18       	icall	r8
8000ad18:	18 16       	sub	r6,r12
8000ad1a:	58 0c       	cp.w	r12,0
8000ad1c:	e0 8a 01 0a 	brle	8000af30 <__sfvwrite_r+0x284>
8000ad20:	68 28       	ld.w	r8,r4[0x8]
8000ad22:	18 18       	sub	r8,r12
8000ad24:	89 28       	st.w	r4[0x8],r8
8000ad26:	e0 80 01 0a 	breq	8000af3a <__sfvwrite_r+0x28e>
8000ad2a:	18 03       	add	r3,r12
8000ad2c:	ce 9b       	rjmp	8000acfe <__sfvwrite_r+0x52>
8000ad2e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000ad32:	c0 70       	breq	8000ad40 <__sfvwrite_r+0x94>
8000ad34:	50 06       	stdsp	sp[0x0],r6
8000ad36:	0c 93       	mov	r3,r6
8000ad38:	0c 91       	mov	r1,r6
8000ad3a:	50 15       	stdsp	sp[0x4],r5
8000ad3c:	08 92       	mov	r2,r4
8000ad3e:	c9 c8       	rjmp	8000ae76 <__sfvwrite_r+0x1ca>
8000ad40:	06 96       	mov	r6,r3
8000ad42:	08 91       	mov	r1,r4
8000ad44:	c0 48       	rjmp	8000ad4c <__sfvwrite_r+0xa0>
8000ad46:	60 03       	ld.w	r3,r0[0x0]
8000ad48:	60 16       	ld.w	r6,r0[0x4]
8000ad4a:	2f 80       	sub	r0,-8
8000ad4c:	58 06       	cp.w	r6,0
8000ad4e:	cf c0       	breq	8000ad46 <__sfvwrite_r+0x9a>
8000ad50:	8e 68       	ld.sh	r8,r7[0xc]
8000ad52:	6e 24       	ld.w	r4,r7[0x8]
8000ad54:	10 99       	mov	r9,r8
8000ad56:	e2 19 02 00 	andl	r9,0x200,COH
8000ad5a:	c5 50       	breq	8000ae04 <__sfvwrite_r+0x158>
8000ad5c:	08 36       	cp.w	r6,r4
8000ad5e:	c4 43       	brcs	8000ade6 <__sfvwrite_r+0x13a>
8000ad60:	10 99       	mov	r9,r8
8000ad62:	e2 19 04 80 	andl	r9,0x480,COH
8000ad66:	c4 00       	breq	8000ade6 <__sfvwrite_r+0x13a>
8000ad68:	6e 4b       	ld.w	r11,r7[0x10]
8000ad6a:	6e 09       	ld.w	r9,r7[0x0]
8000ad6c:	16 19       	sub	r9,r11
8000ad6e:	50 09       	stdsp	sp[0x0],r9
8000ad70:	6e 59       	ld.w	r9,r7[0x14]
8000ad72:	10 9c       	mov	r12,r8
8000ad74:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ad78:	30 28       	mov	r8,2
8000ad7a:	f4 08 0c 08 	divs	r8,r10,r8
8000ad7e:	fa e9 00 04 	st.d	sp[4],r8
8000ad82:	10 94       	mov	r4,r8
8000ad84:	40 09       	lddsp	r9,sp[0x0]
8000ad86:	e2 1c 04 00 	andl	r12,0x400,COH
8000ad8a:	2f f9       	sub	r9,-1
8000ad8c:	0c 09       	add	r9,r6
8000ad8e:	12 38       	cp.w	r8,r9
8000ad90:	f2 04 17 30 	movlo	r4,r9
8000ad94:	58 0c       	cp.w	r12,0
8000ad96:	c1 10       	breq	8000adb8 <__sfvwrite_r+0x10c>
8000ad98:	08 9b       	mov	r11,r4
8000ad9a:	0a 9c       	mov	r12,r5
8000ad9c:	fe b0 e0 6c 	rcall	80006e74 <_malloc_r>
8000ada0:	18 92       	mov	r2,r12
8000ada2:	c1 40       	breq	8000adca <__sfvwrite_r+0x11e>
8000ada4:	40 0a       	lddsp	r10,sp[0x0]
8000ada6:	6e 4b       	ld.w	r11,r7[0x10]
8000ada8:	fe b0 e2 82 	rcall	800072ac <memcpy>
8000adac:	8e 68       	ld.sh	r8,r7[0xc]
8000adae:	e0 18 fb 7f 	andl	r8,0xfb7f
8000adb2:	a7 b8       	sbr	r8,0x7
8000adb4:	ae 68       	st.h	r7[0xc],r8
8000adb6:	c0 d8       	rjmp	8000add0 <__sfvwrite_r+0x124>
8000adb8:	08 9a       	mov	r10,r4
8000adba:	0a 9c       	mov	r12,r5
8000adbc:	fe b0 e3 24 	rcall	80007404 <_realloc_r>
8000adc0:	18 92       	mov	r2,r12
8000adc2:	c0 71       	brne	8000add0 <__sfvwrite_r+0x124>
8000adc4:	6e 4b       	ld.w	r11,r7[0x10]
8000adc6:	0a 9c       	mov	r12,r5
8000adc8:	ca ce       	rcall	8000ab20 <_free_r>
8000adca:	30 c8       	mov	r8,12
8000adcc:	8b 38       	st.w	r5[0xc],r8
8000adce:	cb 18       	rjmp	8000af30 <__sfvwrite_r+0x284>
8000add0:	40 0a       	lddsp	r10,sp[0x0]
8000add2:	40 09       	lddsp	r9,sp[0x0]
8000add4:	e8 0a 01 0a 	sub	r10,r4,r10
8000add8:	e4 09 00 08 	add	r8,r2,r9
8000addc:	8f 54       	st.w	r7[0x14],r4
8000adde:	8f 2a       	st.w	r7[0x8],r10
8000ade0:	8f 08       	st.w	r7[0x0],r8
8000ade2:	8f 42       	st.w	r7[0x10],r2
8000ade4:	0c 94       	mov	r4,r6
8000ade6:	08 36       	cp.w	r6,r4
8000ade8:	ec 04 17 30 	movlo	r4,r6
8000adec:	06 9b       	mov	r11,r3
8000adee:	08 9a       	mov	r10,r4
8000adf0:	6e 0c       	ld.w	r12,r7[0x0]
8000adf2:	c3 ad       	rcall	8000b066 <memmove>
8000adf4:	6e 08       	ld.w	r8,r7[0x0]
8000adf6:	08 08       	add	r8,r4
8000adf8:	8f 08       	st.w	r7[0x0],r8
8000adfa:	6e 28       	ld.w	r8,r7[0x8]
8000adfc:	08 18       	sub	r8,r4
8000adfe:	0c 94       	mov	r4,r6
8000ae00:	8f 28       	st.w	r7[0x8],r8
8000ae02:	c2 e8       	rjmp	8000ae5e <__sfvwrite_r+0x1b2>
8000ae04:	08 36       	cp.w	r6,r4
8000ae06:	5f ba       	srhi	r10
8000ae08:	6e 0c       	ld.w	r12,r7[0x0]
8000ae0a:	6e 48       	ld.w	r8,r7[0x10]
8000ae0c:	10 3c       	cp.w	r12,r8
8000ae0e:	5f b8       	srhi	r8
8000ae10:	f5 e8 00 08 	and	r8,r10,r8
8000ae14:	f2 08 18 00 	cp.b	r8,r9
8000ae18:	c0 d0       	breq	8000ae32 <__sfvwrite_r+0x186>
8000ae1a:	06 9b       	mov	r11,r3
8000ae1c:	08 9a       	mov	r10,r4
8000ae1e:	c2 4d       	rcall	8000b066 <memmove>
8000ae20:	6e 08       	ld.w	r8,r7[0x0]
8000ae22:	08 08       	add	r8,r4
8000ae24:	0e 9b       	mov	r11,r7
8000ae26:	8f 08       	st.w	r7[0x0],r8
8000ae28:	0a 9c       	mov	r12,r5
8000ae2a:	fe b0 fd 09 	rcall	8000a83c <_fflush_r>
8000ae2e:	c1 80       	breq	8000ae5e <__sfvwrite_r+0x1b2>
8000ae30:	c8 08       	rjmp	8000af30 <__sfvwrite_r+0x284>
8000ae32:	6e 59       	ld.w	r9,r7[0x14]
8000ae34:	12 36       	cp.w	r6,r9
8000ae36:	c0 a3       	brcs	8000ae4a <__sfvwrite_r+0x19e>
8000ae38:	6e a8       	ld.w	r8,r7[0x28]
8000ae3a:	06 9a       	mov	r10,r3
8000ae3c:	6e 8b       	ld.w	r11,r7[0x20]
8000ae3e:	0a 9c       	mov	r12,r5
8000ae40:	5d 18       	icall	r8
8000ae42:	18 94       	mov	r4,r12
8000ae44:	e0 89 00 0d 	brgt	8000ae5e <__sfvwrite_r+0x1b2>
8000ae48:	c7 48       	rjmp	8000af30 <__sfvwrite_r+0x284>
8000ae4a:	0c 9a       	mov	r10,r6
8000ae4c:	06 9b       	mov	r11,r3
8000ae4e:	c0 cd       	rcall	8000b066 <memmove>
8000ae50:	6e 08       	ld.w	r8,r7[0x0]
8000ae52:	0c 08       	add	r8,r6
8000ae54:	0c 94       	mov	r4,r6
8000ae56:	8f 08       	st.w	r7[0x0],r8
8000ae58:	6e 28       	ld.w	r8,r7[0x8]
8000ae5a:	0c 18       	sub	r8,r6
8000ae5c:	8f 28       	st.w	r7[0x8],r8
8000ae5e:	62 28       	ld.w	r8,r1[0x8]
8000ae60:	08 18       	sub	r8,r4
8000ae62:	83 28       	st.w	r1[0x8],r8
8000ae64:	c6 b0       	breq	8000af3a <__sfvwrite_r+0x28e>
8000ae66:	08 16       	sub	r6,r4
8000ae68:	08 03       	add	r3,r4
8000ae6a:	c7 1b       	rjmp	8000ad4c <__sfvwrite_r+0xa0>
8000ae6c:	60 03       	ld.w	r3,r0[0x0]
8000ae6e:	60 11       	ld.w	r1,r0[0x4]
8000ae70:	30 08       	mov	r8,0
8000ae72:	2f 80       	sub	r0,-8
8000ae74:	50 08       	stdsp	sp[0x0],r8
8000ae76:	58 01       	cp.w	r1,0
8000ae78:	cf a0       	breq	8000ae6c <__sfvwrite_r+0x1c0>
8000ae7a:	40 0a       	lddsp	r10,sp[0x0]
8000ae7c:	58 0a       	cp.w	r10,0
8000ae7e:	c1 41       	brne	8000aea6 <__sfvwrite_r+0x1fa>
8000ae80:	e2 c6 ff ff 	sub	r6,r1,-1
8000ae84:	02 9a       	mov	r10,r1
8000ae86:	30 ab       	mov	r11,10
8000ae88:	06 9c       	mov	r12,r3
8000ae8a:	ce 3c       	rcall	8000b050 <memchr>
8000ae8c:	f8 c8 ff ff 	sub	r8,r12,-1
8000ae90:	58 0c       	cp.w	r12,0
8000ae92:	f1 d3 e1 16 	subne	r6,r8,r3
8000ae96:	f9 b9 01 01 	movne	r9,1
8000ae9a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ae9e:	f9 b8 00 01 	moveq	r8,1
8000aea2:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000aea6:	02 36       	cp.w	r6,r1
8000aea8:	ec 04 17 80 	movls	r4,r6
8000aeac:	e2 04 17 b0 	movhi	r4,r1
8000aeb0:	6e 59       	ld.w	r9,r7[0x14]
8000aeb2:	6e 25       	ld.w	r5,r7[0x8]
8000aeb4:	f2 05 00 05 	add	r5,r9,r5
8000aeb8:	0a 34       	cp.w	r4,r5
8000aeba:	5f 9a       	srgt	r10
8000aebc:	6e 0c       	ld.w	r12,r7[0x0]
8000aebe:	6e 48       	ld.w	r8,r7[0x10]
8000aec0:	10 3c       	cp.w	r12,r8
8000aec2:	5f b8       	srhi	r8
8000aec4:	f5 e8 00 08 	and	r8,r10,r8
8000aec8:	30 0a       	mov	r10,0
8000aeca:	f4 08 18 00 	cp.b	r8,r10
8000aece:	c0 d0       	breq	8000aee8 <__sfvwrite_r+0x23c>
8000aed0:	06 9b       	mov	r11,r3
8000aed2:	0a 9a       	mov	r10,r5
8000aed4:	cc 9c       	rcall	8000b066 <memmove>
8000aed6:	6e 08       	ld.w	r8,r7[0x0]
8000aed8:	0a 08       	add	r8,r5
8000aeda:	0e 9b       	mov	r11,r7
8000aedc:	8f 08       	st.w	r7[0x0],r8
8000aede:	40 1c       	lddsp	r12,sp[0x4]
8000aee0:	fe b0 fc ae 	rcall	8000a83c <_fflush_r>
8000aee4:	c1 70       	breq	8000af12 <__sfvwrite_r+0x266>
8000aee6:	c2 58       	rjmp	8000af30 <__sfvwrite_r+0x284>
8000aee8:	12 34       	cp.w	r4,r9
8000aeea:	c0 a5       	brlt	8000aefe <__sfvwrite_r+0x252>
8000aeec:	6e a8       	ld.w	r8,r7[0x28]
8000aeee:	06 9a       	mov	r10,r3
8000aef0:	6e 8b       	ld.w	r11,r7[0x20]
8000aef2:	40 1c       	lddsp	r12,sp[0x4]
8000aef4:	5d 18       	icall	r8
8000aef6:	18 95       	mov	r5,r12
8000aef8:	e0 89 00 0d 	brgt	8000af12 <__sfvwrite_r+0x266>
8000aefc:	c1 a8       	rjmp	8000af30 <__sfvwrite_r+0x284>
8000aefe:	08 9a       	mov	r10,r4
8000af00:	06 9b       	mov	r11,r3
8000af02:	cb 2c       	rcall	8000b066 <memmove>
8000af04:	6e 08       	ld.w	r8,r7[0x0]
8000af06:	08 08       	add	r8,r4
8000af08:	08 95       	mov	r5,r4
8000af0a:	8f 08       	st.w	r7[0x0],r8
8000af0c:	6e 28       	ld.w	r8,r7[0x8]
8000af0e:	08 18       	sub	r8,r4
8000af10:	8f 28       	st.w	r7[0x8],r8
8000af12:	0a 16       	sub	r6,r5
8000af14:	c0 71       	brne	8000af22 <__sfvwrite_r+0x276>
8000af16:	0e 9b       	mov	r11,r7
8000af18:	40 1c       	lddsp	r12,sp[0x4]
8000af1a:	fe b0 fc 91 	rcall	8000a83c <_fflush_r>
8000af1e:	c0 91       	brne	8000af30 <__sfvwrite_r+0x284>
8000af20:	50 06       	stdsp	sp[0x0],r6
8000af22:	64 28       	ld.w	r8,r2[0x8]
8000af24:	0a 18       	sub	r8,r5
8000af26:	85 28       	st.w	r2[0x8],r8
8000af28:	c0 90       	breq	8000af3a <__sfvwrite_r+0x28e>
8000af2a:	0a 11       	sub	r1,r5
8000af2c:	0a 03       	add	r3,r5
8000af2e:	ca 4b       	rjmp	8000ae76 <__sfvwrite_r+0x1ca>
8000af30:	8e 68       	ld.sh	r8,r7[0xc]
8000af32:	a7 a8       	sbr	r8,0x6
8000af34:	ae 68       	st.h	r7[0xc],r8
8000af36:	3f fc       	mov	r12,-1
8000af38:	c0 28       	rjmp	8000af3c <__sfvwrite_r+0x290>
8000af3a:	30 0c       	mov	r12,0
8000af3c:	2f dd       	sub	sp,-12
8000af3e:	d8 32       	popm	r0-r7,pc

8000af40 <_fwalk>:
8000af40:	d4 31       	pushm	r0-r7,lr
8000af42:	30 05       	mov	r5,0
8000af44:	16 91       	mov	r1,r11
8000af46:	f8 c7 ff 28 	sub	r7,r12,-216
8000af4a:	0a 92       	mov	r2,r5
8000af4c:	fe b0 fc fe 	rcall	8000a948 <__sfp_lock_acquire>
8000af50:	3f f3       	mov	r3,-1
8000af52:	c1 68       	rjmp	8000af7e <_fwalk+0x3e>
8000af54:	6e 26       	ld.w	r6,r7[0x8]
8000af56:	6e 14       	ld.w	r4,r7[0x4]
8000af58:	2f 46       	sub	r6,-12
8000af5a:	c0 c8       	rjmp	8000af72 <_fwalk+0x32>
8000af5c:	8c 08       	ld.sh	r8,r6[0x0]
8000af5e:	e4 08 19 00 	cp.h	r8,r2
8000af62:	c0 70       	breq	8000af70 <_fwalk+0x30>
8000af64:	8c 18       	ld.sh	r8,r6[0x2]
8000af66:	e6 08 19 00 	cp.h	r8,r3
8000af6a:	c0 30       	breq	8000af70 <_fwalk+0x30>
8000af6c:	5d 11       	icall	r1
8000af6e:	18 45       	or	r5,r12
8000af70:	2a 46       	sub	r6,-92
8000af72:	20 14       	sub	r4,1
8000af74:	ec cc 00 0c 	sub	r12,r6,12
8000af78:	58 04       	cp.w	r4,0
8000af7a:	cf 14       	brge	8000af5c <_fwalk+0x1c>
8000af7c:	6e 07       	ld.w	r7,r7[0x0]
8000af7e:	58 07       	cp.w	r7,0
8000af80:	ce a1       	brne	8000af54 <_fwalk+0x14>
8000af82:	fe b0 fc e4 	rcall	8000a94a <__sfp_lock_release>
8000af86:	0a 9c       	mov	r12,r5
8000af88:	d8 32       	popm	r0-r7,pc
8000af8a:	d7 03       	nop

8000af8c <_localeconv_r>:
8000af8c:	fe cc d4 64 	sub	r12,pc,-11164
8000af90:	5e fc       	retal	r12
8000af92:	d7 03       	nop

8000af94 <__smakebuf_r>:
8000af94:	d4 21       	pushm	r4-r7,lr
8000af96:	20 fd       	sub	sp,60
8000af98:	96 68       	ld.sh	r8,r11[0xc]
8000af9a:	16 97       	mov	r7,r11
8000af9c:	18 96       	mov	r6,r12
8000af9e:	e2 18 00 02 	andl	r8,0x2,COH
8000afa2:	c3 d1       	brne	8000b01c <__smakebuf_r+0x88>
8000afa4:	96 7b       	ld.sh	r11,r11[0xe]
8000afa6:	f0 0b 19 00 	cp.h	r11,r8
8000afaa:	c0 55       	brlt	8000afb4 <__smakebuf_r+0x20>
8000afac:	1a 9a       	mov	r10,sp
8000afae:	e0 a0 04 81 	rcall	8000b8b0 <_fstat_r>
8000afb2:	c0 f4       	brge	8000afd0 <__smakebuf_r+0x3c>
8000afb4:	8e 65       	ld.sh	r5,r7[0xc]
8000afb6:	0a 98       	mov	r8,r5
8000afb8:	ab b8       	sbr	r8,0xb
8000afba:	e2 15 00 80 	andl	r5,0x80,COH
8000afbe:	ae 68       	st.h	r7[0xc],r8
8000afc0:	30 04       	mov	r4,0
8000afc2:	e0 68 04 00 	mov	r8,1024
8000afc6:	f9 b5 01 40 	movne	r5,64
8000afca:	f0 05 17 00 	moveq	r5,r8
8000afce:	c1 c8       	rjmp	8000b006 <__smakebuf_r+0x72>
8000afd0:	40 18       	lddsp	r8,sp[0x4]
8000afd2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000afd6:	e0 48 20 00 	cp.w	r8,8192
8000afda:	5f 04       	sreq	r4
8000afdc:	e0 48 80 00 	cp.w	r8,32768
8000afe0:	c0 e1       	brne	8000affc <__smakebuf_r+0x68>
8000afe2:	6e b9       	ld.w	r9,r7[0x2c]
8000afe4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000afe8:	10 39       	cp.w	r9,r8
8000afea:	c0 91       	brne	8000affc <__smakebuf_r+0x68>
8000afec:	8e 68       	ld.sh	r8,r7[0xc]
8000afee:	e0 65 04 00 	mov	r5,1024
8000aff2:	ab a8       	sbr	r8,0xa
8000aff4:	ef 45 00 50 	st.w	r7[80],r5
8000aff8:	ae 68       	st.h	r7[0xc],r8
8000affa:	c0 68       	rjmp	8000b006 <__smakebuf_r+0x72>
8000affc:	8e 68       	ld.sh	r8,r7[0xc]
8000affe:	e0 65 04 00 	mov	r5,1024
8000b002:	ab b8       	sbr	r8,0xb
8000b004:	ae 68       	st.h	r7[0xc],r8
8000b006:	0a 9b       	mov	r11,r5
8000b008:	0c 9c       	mov	r12,r6
8000b00a:	fe b0 df 35 	rcall	80006e74 <_malloc_r>
8000b00e:	8e 68       	ld.sh	r8,r7[0xc]
8000b010:	c0 d1       	brne	8000b02a <__smakebuf_r+0x96>
8000b012:	ed b8 00 09 	bld	r8,0x9
8000b016:	c1 b0       	breq	8000b04c <__smakebuf_r+0xb8>
8000b018:	a1 b8       	sbr	r8,0x1
8000b01a:	ae 68       	st.h	r7[0xc],r8
8000b01c:	ee c8 ff b9 	sub	r8,r7,-71
8000b020:	8f 48       	st.w	r7[0x10],r8
8000b022:	8f 08       	st.w	r7[0x0],r8
8000b024:	30 18       	mov	r8,1
8000b026:	8f 58       	st.w	r7[0x14],r8
8000b028:	c1 28       	rjmp	8000b04c <__smakebuf_r+0xb8>
8000b02a:	a7 b8       	sbr	r8,0x7
8000b02c:	8f 4c       	st.w	r7[0x10],r12
8000b02e:	ae 68       	st.h	r7[0xc],r8
8000b030:	8f 55       	st.w	r7[0x14],r5
8000b032:	fe c8 06 e6 	sub	r8,pc,1766
8000b036:	8f 0c       	st.w	r7[0x0],r12
8000b038:	8d a8       	st.w	r6[0x28],r8
8000b03a:	58 04       	cp.w	r4,0
8000b03c:	c0 80       	breq	8000b04c <__smakebuf_r+0xb8>
8000b03e:	8e 7c       	ld.sh	r12,r7[0xe]
8000b040:	fe b0 e3 94 	rcall	80007768 <isatty>
8000b044:	c0 40       	breq	8000b04c <__smakebuf_r+0xb8>
8000b046:	8e 68       	ld.sh	r8,r7[0xc]
8000b048:	a1 a8       	sbr	r8,0x0
8000b04a:	ae 68       	st.h	r7[0xc],r8
8000b04c:	2f 1d       	sub	sp,-60
8000b04e:	d8 22       	popm	r4-r7,pc

8000b050 <memchr>:
8000b050:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b054:	c0 68       	rjmp	8000b060 <memchr+0x10>
8000b056:	20 1a       	sub	r10,1
8000b058:	19 88       	ld.ub	r8,r12[0x0]
8000b05a:	16 38       	cp.w	r8,r11
8000b05c:	5e 0c       	reteq	r12
8000b05e:	2f fc       	sub	r12,-1
8000b060:	58 0a       	cp.w	r10,0
8000b062:	cf a1       	brne	8000b056 <memchr+0x6>
8000b064:	5e fa       	retal	r10

8000b066 <memmove>:
8000b066:	d4 01       	pushm	lr
8000b068:	18 3b       	cp.w	r11,r12
8000b06a:	c1 92       	brcc	8000b09c <memmove+0x36>
8000b06c:	f6 0a 00 09 	add	r9,r11,r10
8000b070:	12 3c       	cp.w	r12,r9
8000b072:	c1 52       	brcc	8000b09c <memmove+0x36>
8000b074:	f8 0a 00 0b 	add	r11,r12,r10
8000b078:	30 08       	mov	r8,0
8000b07a:	c0 68       	rjmp	8000b086 <memmove+0x20>
8000b07c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b080:	20 1a       	sub	r10,1
8000b082:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b086:	20 18       	sub	r8,1
8000b088:	58 0a       	cp.w	r10,0
8000b08a:	cf 91       	brne	8000b07c <memmove+0x16>
8000b08c:	d8 02       	popm	pc
8000b08e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b092:	20 1a       	sub	r10,1
8000b094:	f8 08 0b 09 	st.b	r12[r8],r9
8000b098:	2f f8       	sub	r8,-1
8000b09a:	c0 28       	rjmp	8000b09e <memmove+0x38>
8000b09c:	30 08       	mov	r8,0
8000b09e:	58 0a       	cp.w	r10,0
8000b0a0:	cf 71       	brne	8000b08e <memmove+0x28>
8000b0a2:	d8 02       	popm	pc

8000b0a4 <__hi0bits>:
8000b0a4:	18 98       	mov	r8,r12
8000b0a6:	e0 1c 00 00 	andl	r12,0x0
8000b0aa:	f0 09 15 10 	lsl	r9,r8,0x10
8000b0ae:	58 0c       	cp.w	r12,0
8000b0b0:	f2 08 17 00 	moveq	r8,r9
8000b0b4:	f9 bc 00 10 	moveq	r12,16
8000b0b8:	f9 bc 01 00 	movne	r12,0
8000b0bc:	10 9a       	mov	r10,r8
8000b0be:	f0 09 15 08 	lsl	r9,r8,0x8
8000b0c2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b0c6:	f7 bc 00 f8 	subeq	r12,-8
8000b0ca:	f2 08 17 00 	moveq	r8,r9
8000b0ce:	10 9a       	mov	r10,r8
8000b0d0:	f0 09 15 04 	lsl	r9,r8,0x4
8000b0d4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b0d8:	f7 bc 00 fc 	subeq	r12,-4
8000b0dc:	f2 08 17 00 	moveq	r8,r9
8000b0e0:	10 9a       	mov	r10,r8
8000b0e2:	f0 09 15 02 	lsl	r9,r8,0x2
8000b0e6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b0ea:	f7 bc 00 fe 	subeq	r12,-2
8000b0ee:	f2 08 17 00 	moveq	r8,r9
8000b0f2:	58 08       	cp.w	r8,0
8000b0f4:	5e 5c       	retlt	r12
8000b0f6:	ed b8 00 1e 	bld	r8,0x1e
8000b0fa:	f9 bc 01 20 	movne	r12,32
8000b0fe:	f7 bc 00 ff 	subeq	r12,-1
8000b102:	5e fc       	retal	r12

8000b104 <__lo0bits>:
8000b104:	18 99       	mov	r9,r12
8000b106:	78 08       	ld.w	r8,r12[0x0]
8000b108:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b10c:	c1 50       	breq	8000b136 <__lo0bits+0x32>
8000b10e:	ed b8 00 00 	bld	r8,0x0
8000b112:	c0 21       	brne	8000b116 <__lo0bits+0x12>
8000b114:	5e fd       	retal	0
8000b116:	10 9b       	mov	r11,r8
8000b118:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b11c:	e2 1b 00 02 	andl	r11,0x2,COH
8000b120:	a3 88       	lsr	r8,0x2
8000b122:	58 0b       	cp.w	r11,0
8000b124:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b128:	f9 bc 01 01 	movne	r12,1
8000b12c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b130:	f9 bc 00 02 	moveq	r12,2
8000b134:	5e fc       	retal	r12
8000b136:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b13a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b13e:	58 0a       	cp.w	r10,0
8000b140:	f6 08 17 00 	moveq	r8,r11
8000b144:	f9 bc 00 10 	moveq	r12,16
8000b148:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b14c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b150:	58 0b       	cp.w	r11,0
8000b152:	f7 bc 00 f8 	subeq	r12,-8
8000b156:	f4 08 17 00 	moveq	r8,r10
8000b15a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b15e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b162:	58 0b       	cp.w	r11,0
8000b164:	f7 bc 00 fc 	subeq	r12,-4
8000b168:	f4 08 17 00 	moveq	r8,r10
8000b16c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b170:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b174:	58 0b       	cp.w	r11,0
8000b176:	f7 bc 00 fe 	subeq	r12,-2
8000b17a:	f4 08 17 00 	moveq	r8,r10
8000b17e:	ed b8 00 00 	bld	r8,0x0
8000b182:	c0 60       	breq	8000b18e <__lo0bits+0x8a>
8000b184:	a1 98       	lsr	r8,0x1
8000b186:	c0 31       	brne	8000b18c <__lo0bits+0x88>
8000b188:	32 0c       	mov	r12,32
8000b18a:	5e fc       	retal	r12
8000b18c:	2f fc       	sub	r12,-1
8000b18e:	93 08       	st.w	r9[0x0],r8
8000b190:	5e fc       	retal	r12

8000b192 <__mcmp>:
8000b192:	d4 01       	pushm	lr
8000b194:	18 98       	mov	r8,r12
8000b196:	76 49       	ld.w	r9,r11[0x10]
8000b198:	78 4c       	ld.w	r12,r12[0x10]
8000b19a:	12 1c       	sub	r12,r9
8000b19c:	c1 31       	brne	8000b1c2 <__mcmp+0x30>
8000b19e:	2f b9       	sub	r9,-5
8000b1a0:	a3 69       	lsl	r9,0x2
8000b1a2:	12 0b       	add	r11,r9
8000b1a4:	f0 09 00 09 	add	r9,r8,r9
8000b1a8:	2e c8       	sub	r8,-20
8000b1aa:	13 4e       	ld.w	lr,--r9
8000b1ac:	17 4a       	ld.w	r10,--r11
8000b1ae:	14 3e       	cp.w	lr,r10
8000b1b0:	c0 60       	breq	8000b1bc <__mcmp+0x2a>
8000b1b2:	f9 bc 03 ff 	movlo	r12,-1
8000b1b6:	f9 bc 02 01 	movhs	r12,1
8000b1ba:	d8 02       	popm	pc
8000b1bc:	10 39       	cp.w	r9,r8
8000b1be:	fe 9b ff f6 	brhi	8000b1aa <__mcmp+0x18>
8000b1c2:	d8 02       	popm	pc

8000b1c4 <_Bfree>:
8000b1c4:	d4 21       	pushm	r4-r7,lr
8000b1c6:	18 97       	mov	r7,r12
8000b1c8:	16 95       	mov	r5,r11
8000b1ca:	78 96       	ld.w	r6,r12[0x24]
8000b1cc:	58 06       	cp.w	r6,0
8000b1ce:	c0 91       	brne	8000b1e0 <_Bfree+0x1c>
8000b1d0:	31 0c       	mov	r12,16
8000b1d2:	fe b0 de 49 	rcall	80006e64 <malloc>
8000b1d6:	99 36       	st.w	r12[0xc],r6
8000b1d8:	8f 9c       	st.w	r7[0x24],r12
8000b1da:	99 16       	st.w	r12[0x4],r6
8000b1dc:	99 26       	st.w	r12[0x8],r6
8000b1de:	99 06       	st.w	r12[0x0],r6
8000b1e0:	58 05       	cp.w	r5,0
8000b1e2:	c0 90       	breq	8000b1f4 <_Bfree+0x30>
8000b1e4:	6a 19       	ld.w	r9,r5[0x4]
8000b1e6:	6e 98       	ld.w	r8,r7[0x24]
8000b1e8:	70 38       	ld.w	r8,r8[0xc]
8000b1ea:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b1ee:	8b 0a       	st.w	r5[0x0],r10
8000b1f0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b1f4:	d8 22       	popm	r4-r7,pc
8000b1f6:	d7 03       	nop

8000b1f8 <_Balloc>:
8000b1f8:	d4 21       	pushm	r4-r7,lr
8000b1fa:	18 97       	mov	r7,r12
8000b1fc:	16 96       	mov	r6,r11
8000b1fe:	78 95       	ld.w	r5,r12[0x24]
8000b200:	58 05       	cp.w	r5,0
8000b202:	c0 91       	brne	8000b214 <_Balloc+0x1c>
8000b204:	31 0c       	mov	r12,16
8000b206:	fe b0 de 2f 	rcall	80006e64 <malloc>
8000b20a:	99 35       	st.w	r12[0xc],r5
8000b20c:	8f 9c       	st.w	r7[0x24],r12
8000b20e:	99 15       	st.w	r12[0x4],r5
8000b210:	99 25       	st.w	r12[0x8],r5
8000b212:	99 05       	st.w	r12[0x0],r5
8000b214:	6e 95       	ld.w	r5,r7[0x24]
8000b216:	6a 38       	ld.w	r8,r5[0xc]
8000b218:	58 08       	cp.w	r8,0
8000b21a:	c0 b1       	brne	8000b230 <_Balloc+0x38>
8000b21c:	31 0a       	mov	r10,16
8000b21e:	30 4b       	mov	r11,4
8000b220:	0e 9c       	mov	r12,r7
8000b222:	e0 a0 02 a7 	rcall	8000b770 <_calloc_r>
8000b226:	8b 3c       	st.w	r5[0xc],r12
8000b228:	6e 98       	ld.w	r8,r7[0x24]
8000b22a:	70 3c       	ld.w	r12,r8[0xc]
8000b22c:	58 0c       	cp.w	r12,0
8000b22e:	c1 b0       	breq	8000b264 <_Balloc+0x6c>
8000b230:	6e 98       	ld.w	r8,r7[0x24]
8000b232:	70 38       	ld.w	r8,r8[0xc]
8000b234:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b238:	70 0c       	ld.w	r12,r8[0x0]
8000b23a:	58 0c       	cp.w	r12,0
8000b23c:	c0 40       	breq	8000b244 <_Balloc+0x4c>
8000b23e:	78 09       	ld.w	r9,r12[0x0]
8000b240:	91 09       	st.w	r8[0x0],r9
8000b242:	c0 e8       	rjmp	8000b25e <_Balloc+0x66>
8000b244:	0e 9c       	mov	r12,r7
8000b246:	30 17       	mov	r7,1
8000b248:	0e 9b       	mov	r11,r7
8000b24a:	ee 06 09 47 	lsl	r7,r7,r6
8000b24e:	ee ca ff fb 	sub	r10,r7,-5
8000b252:	a3 6a       	lsl	r10,0x2
8000b254:	e0 a0 02 8e 	rcall	8000b770 <_calloc_r>
8000b258:	c0 60       	breq	8000b264 <_Balloc+0x6c>
8000b25a:	99 16       	st.w	r12[0x4],r6
8000b25c:	99 27       	st.w	r12[0x8],r7
8000b25e:	30 08       	mov	r8,0
8000b260:	99 38       	st.w	r12[0xc],r8
8000b262:	99 48       	st.w	r12[0x10],r8
8000b264:	d8 22       	popm	r4-r7,pc
8000b266:	d7 03       	nop

8000b268 <__d2b>:
8000b268:	d4 31       	pushm	r0-r7,lr
8000b26a:	20 2d       	sub	sp,8
8000b26c:	16 93       	mov	r3,r11
8000b26e:	12 96       	mov	r6,r9
8000b270:	10 95       	mov	r5,r8
8000b272:	14 92       	mov	r2,r10
8000b274:	30 1b       	mov	r11,1
8000b276:	cc 1f       	rcall	8000b1f8 <_Balloc>
8000b278:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b27c:	50 09       	stdsp	sp[0x0],r9
8000b27e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b282:	b5 a9       	sbr	r9,0x14
8000b284:	f0 01 16 14 	lsr	r1,r8,0x14
8000b288:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b28c:	18 94       	mov	r4,r12
8000b28e:	58 02       	cp.w	r2,0
8000b290:	c1 d0       	breq	8000b2ca <__d2b+0x62>
8000b292:	fa cc ff f8 	sub	r12,sp,-8
8000b296:	18 d2       	st.w	--r12,r2
8000b298:	c3 6f       	rcall	8000b104 <__lo0bits>
8000b29a:	40 18       	lddsp	r8,sp[0x4]
8000b29c:	c0 d0       	breq	8000b2b6 <__d2b+0x4e>
8000b29e:	40 09       	lddsp	r9,sp[0x0]
8000b2a0:	f8 0a 11 20 	rsub	r10,r12,32
8000b2a4:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b2a8:	f5 e8 10 08 	or	r8,r10,r8
8000b2ac:	89 58       	st.w	r4[0x14],r8
8000b2ae:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b2b2:	50 09       	stdsp	sp[0x0],r9
8000b2b4:	c0 28       	rjmp	8000b2b8 <__d2b+0x50>
8000b2b6:	89 58       	st.w	r4[0x14],r8
8000b2b8:	40 08       	lddsp	r8,sp[0x0]
8000b2ba:	58 08       	cp.w	r8,0
8000b2bc:	f9 b3 01 02 	movne	r3,2
8000b2c0:	f9 b3 00 01 	moveq	r3,1
8000b2c4:	89 68       	st.w	r4[0x18],r8
8000b2c6:	89 43       	st.w	r4[0x10],r3
8000b2c8:	c0 88       	rjmp	8000b2d8 <__d2b+0x70>
8000b2ca:	1a 9c       	mov	r12,sp
8000b2cc:	c1 cf       	rcall	8000b104 <__lo0bits>
8000b2ce:	30 13       	mov	r3,1
8000b2d0:	40 08       	lddsp	r8,sp[0x0]
8000b2d2:	2e 0c       	sub	r12,-32
8000b2d4:	89 43       	st.w	r4[0x10],r3
8000b2d6:	89 58       	st.w	r4[0x14],r8
8000b2d8:	58 01       	cp.w	r1,0
8000b2da:	c0 90       	breq	8000b2ec <__d2b+0x84>
8000b2dc:	e2 c1 04 33 	sub	r1,r1,1075
8000b2e0:	18 01       	add	r1,r12
8000b2e2:	8d 01       	st.w	r6[0x0],r1
8000b2e4:	f8 0c 11 35 	rsub	r12,r12,53
8000b2e8:	8b 0c       	st.w	r5[0x0],r12
8000b2ea:	c0 c8       	rjmp	8000b302 <__d2b+0x9a>
8000b2ec:	e6 c8 ff fc 	sub	r8,r3,-4
8000b2f0:	f8 cc 04 32 	sub	r12,r12,1074
8000b2f4:	a5 73       	lsl	r3,0x5
8000b2f6:	8d 0c       	st.w	r6[0x0],r12
8000b2f8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b2fc:	cd 4e       	rcall	8000b0a4 <__hi0bits>
8000b2fe:	18 13       	sub	r3,r12
8000b300:	8b 03       	st.w	r5[0x0],r3
8000b302:	08 9c       	mov	r12,r4
8000b304:	2f ed       	sub	sp,-8
8000b306:	d8 32       	popm	r0-r7,pc

8000b308 <__mdiff>:
8000b308:	d4 31       	pushm	r0-r7,lr
8000b30a:	74 48       	ld.w	r8,r10[0x10]
8000b30c:	76 45       	ld.w	r5,r11[0x10]
8000b30e:	16 97       	mov	r7,r11
8000b310:	14 96       	mov	r6,r10
8000b312:	10 15       	sub	r5,r8
8000b314:	c1 31       	brne	8000b33a <__mdiff+0x32>
8000b316:	2f b8       	sub	r8,-5
8000b318:	ee ce ff ec 	sub	lr,r7,-20
8000b31c:	a3 68       	lsl	r8,0x2
8000b31e:	f4 08 00 0b 	add	r11,r10,r8
8000b322:	ee 08 00 08 	add	r8,r7,r8
8000b326:	11 4a       	ld.w	r10,--r8
8000b328:	17 49       	ld.w	r9,--r11
8000b32a:	12 3a       	cp.w	r10,r9
8000b32c:	c0 30       	breq	8000b332 <__mdiff+0x2a>
8000b32e:	c0 e2       	brcc	8000b34a <__mdiff+0x42>
8000b330:	c0 78       	rjmp	8000b33e <__mdiff+0x36>
8000b332:	1c 38       	cp.w	r8,lr
8000b334:	fe 9b ff f9 	brhi	8000b326 <__mdiff+0x1e>
8000b338:	c4 98       	rjmp	8000b3ca <__mdiff+0xc2>
8000b33a:	58 05       	cp.w	r5,0
8000b33c:	c0 64       	brge	8000b348 <__mdiff+0x40>
8000b33e:	0e 98       	mov	r8,r7
8000b340:	30 15       	mov	r5,1
8000b342:	0c 97       	mov	r7,r6
8000b344:	10 96       	mov	r6,r8
8000b346:	c0 28       	rjmp	8000b34a <__mdiff+0x42>
8000b348:	30 05       	mov	r5,0
8000b34a:	6e 1b       	ld.w	r11,r7[0x4]
8000b34c:	c5 6f       	rcall	8000b1f8 <_Balloc>
8000b34e:	6e 49       	ld.w	r9,r7[0x10]
8000b350:	6c 44       	ld.w	r4,r6[0x10]
8000b352:	99 35       	st.w	r12[0xc],r5
8000b354:	2f b4       	sub	r4,-5
8000b356:	f2 c5 ff fb 	sub	r5,r9,-5
8000b35a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b35e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b362:	2e c6       	sub	r6,-20
8000b364:	2e c7       	sub	r7,-20
8000b366:	f8 c8 ff ec 	sub	r8,r12,-20
8000b36a:	30 0a       	mov	r10,0
8000b36c:	0f 0e       	ld.w	lr,r7++
8000b36e:	0d 0b       	ld.w	r11,r6++
8000b370:	fc 02 16 10 	lsr	r2,lr,0x10
8000b374:	f6 03 16 10 	lsr	r3,r11,0x10
8000b378:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b37c:	e4 03 01 03 	sub	r3,r2,r3
8000b380:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b384:	fc 0b 01 0b 	sub	r11,lr,r11
8000b388:	f6 0a 00 0a 	add	r10,r11,r10
8000b38c:	b0 1a       	st.h	r8[0x2],r10
8000b38e:	b1 4a       	asr	r10,0x10
8000b390:	e6 0a 00 0a 	add	r10,r3,r10
8000b394:	b0 0a       	st.h	r8[0x0],r10
8000b396:	2f c8       	sub	r8,-4
8000b398:	b1 4a       	asr	r10,0x10
8000b39a:	08 36       	cp.w	r6,r4
8000b39c:	ce 83       	brcs	8000b36c <__mdiff+0x64>
8000b39e:	c0 d8       	rjmp	8000b3b8 <__mdiff+0xb0>
8000b3a0:	0f 0b       	ld.w	r11,r7++
8000b3a2:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b3a6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b3aa:	16 0a       	add	r10,r11
8000b3ac:	b0 1a       	st.h	r8[0x2],r10
8000b3ae:	b1 4a       	asr	r10,0x10
8000b3b0:	1c 0a       	add	r10,lr
8000b3b2:	b0 0a       	st.h	r8[0x0],r10
8000b3b4:	2f c8       	sub	r8,-4
8000b3b6:	b1 4a       	asr	r10,0x10
8000b3b8:	0a 37       	cp.w	r7,r5
8000b3ba:	cf 33       	brcs	8000b3a0 <__mdiff+0x98>
8000b3bc:	c0 28       	rjmp	8000b3c0 <__mdiff+0xb8>
8000b3be:	20 19       	sub	r9,1
8000b3c0:	11 4a       	ld.w	r10,--r8
8000b3c2:	58 0a       	cp.w	r10,0
8000b3c4:	cf d0       	breq	8000b3be <__mdiff+0xb6>
8000b3c6:	99 49       	st.w	r12[0x10],r9
8000b3c8:	d8 32       	popm	r0-r7,pc
8000b3ca:	30 0b       	mov	r11,0
8000b3cc:	c1 6f       	rcall	8000b1f8 <_Balloc>
8000b3ce:	30 18       	mov	r8,1
8000b3d0:	99 48       	st.w	r12[0x10],r8
8000b3d2:	30 08       	mov	r8,0
8000b3d4:	99 58       	st.w	r12[0x14],r8
8000b3d6:	d8 32       	popm	r0-r7,pc

8000b3d8 <__lshift>:
8000b3d8:	d4 31       	pushm	r0-r7,lr
8000b3da:	16 97       	mov	r7,r11
8000b3dc:	76 46       	ld.w	r6,r11[0x10]
8000b3de:	f4 02 14 05 	asr	r2,r10,0x5
8000b3e2:	2f f6       	sub	r6,-1
8000b3e4:	14 93       	mov	r3,r10
8000b3e6:	18 94       	mov	r4,r12
8000b3e8:	04 06       	add	r6,r2
8000b3ea:	76 1b       	ld.w	r11,r11[0x4]
8000b3ec:	6e 28       	ld.w	r8,r7[0x8]
8000b3ee:	c0 38       	rjmp	8000b3f4 <__lshift+0x1c>
8000b3f0:	2f fb       	sub	r11,-1
8000b3f2:	a1 78       	lsl	r8,0x1
8000b3f4:	10 36       	cp.w	r6,r8
8000b3f6:	fe 99 ff fd 	brgt	8000b3f0 <__lshift+0x18>
8000b3fa:	08 9c       	mov	r12,r4
8000b3fc:	cf ee       	rcall	8000b1f8 <_Balloc>
8000b3fe:	30 09       	mov	r9,0
8000b400:	18 95       	mov	r5,r12
8000b402:	f8 c8 ff ec 	sub	r8,r12,-20
8000b406:	12 9a       	mov	r10,r9
8000b408:	c0 38       	rjmp	8000b40e <__lshift+0x36>
8000b40a:	10 aa       	st.w	r8++,r10
8000b40c:	2f f9       	sub	r9,-1
8000b40e:	04 39       	cp.w	r9,r2
8000b410:	cf d5       	brlt	8000b40a <__lshift+0x32>
8000b412:	6e 4b       	ld.w	r11,r7[0x10]
8000b414:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b418:	2f bb       	sub	r11,-5
8000b41a:	ee c9 ff ec 	sub	r9,r7,-20
8000b41e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b422:	58 03       	cp.w	r3,0
8000b424:	c1 30       	breq	8000b44a <__lshift+0x72>
8000b426:	e6 0c 11 20 	rsub	r12,r3,32
8000b42a:	30 0a       	mov	r10,0
8000b42c:	72 02       	ld.w	r2,r9[0x0]
8000b42e:	e4 03 09 42 	lsl	r2,r2,r3
8000b432:	04 4a       	or	r10,r2
8000b434:	10 aa       	st.w	r8++,r10
8000b436:	13 0a       	ld.w	r10,r9++
8000b438:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b43c:	16 39       	cp.w	r9,r11
8000b43e:	cf 73       	brcs	8000b42c <__lshift+0x54>
8000b440:	91 0a       	st.w	r8[0x0],r10
8000b442:	58 0a       	cp.w	r10,0
8000b444:	c0 70       	breq	8000b452 <__lshift+0x7a>
8000b446:	2f f6       	sub	r6,-1
8000b448:	c0 58       	rjmp	8000b452 <__lshift+0x7a>
8000b44a:	13 0a       	ld.w	r10,r9++
8000b44c:	10 aa       	st.w	r8++,r10
8000b44e:	16 39       	cp.w	r9,r11
8000b450:	cf d3       	brcs	8000b44a <__lshift+0x72>
8000b452:	08 9c       	mov	r12,r4
8000b454:	20 16       	sub	r6,1
8000b456:	0e 9b       	mov	r11,r7
8000b458:	8b 46       	st.w	r5[0x10],r6
8000b45a:	cb 5e       	rcall	8000b1c4 <_Bfree>
8000b45c:	0a 9c       	mov	r12,r5
8000b45e:	d8 32       	popm	r0-r7,pc

8000b460 <__multiply>:
8000b460:	d4 31       	pushm	r0-r7,lr
8000b462:	20 2d       	sub	sp,8
8000b464:	76 49       	ld.w	r9,r11[0x10]
8000b466:	74 48       	ld.w	r8,r10[0x10]
8000b468:	16 96       	mov	r6,r11
8000b46a:	14 95       	mov	r5,r10
8000b46c:	10 39       	cp.w	r9,r8
8000b46e:	ec 08 17 50 	movlt	r8,r6
8000b472:	ea 06 17 50 	movlt	r6,r5
8000b476:	f0 05 17 50 	movlt	r5,r8
8000b47a:	6c 28       	ld.w	r8,r6[0x8]
8000b47c:	76 43       	ld.w	r3,r11[0x10]
8000b47e:	74 42       	ld.w	r2,r10[0x10]
8000b480:	76 1b       	ld.w	r11,r11[0x4]
8000b482:	e4 03 00 07 	add	r7,r2,r3
8000b486:	10 37       	cp.w	r7,r8
8000b488:	f7 bb 09 ff 	subgt	r11,-1
8000b48c:	cb 6e       	rcall	8000b1f8 <_Balloc>
8000b48e:	ee c4 ff fb 	sub	r4,r7,-5
8000b492:	f8 c9 ff ec 	sub	r9,r12,-20
8000b496:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b49a:	30 0a       	mov	r10,0
8000b49c:	12 98       	mov	r8,r9
8000b49e:	c0 28       	rjmp	8000b4a2 <__multiply+0x42>
8000b4a0:	10 aa       	st.w	r8++,r10
8000b4a2:	08 38       	cp.w	r8,r4
8000b4a4:	cf e3       	brcs	8000b4a0 <__multiply+0x40>
8000b4a6:	2f b3       	sub	r3,-5
8000b4a8:	2f b2       	sub	r2,-5
8000b4aa:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b4ae:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b4b2:	ec cb ff ec 	sub	r11,r6,-20
8000b4b6:	50 12       	stdsp	sp[0x4],r2
8000b4b8:	ea ca ff ec 	sub	r10,r5,-20
8000b4bc:	c4 48       	rjmp	8000b544 <__multiply+0xe4>
8000b4be:	94 95       	ld.uh	r5,r10[0x2]
8000b4c0:	58 05       	cp.w	r5,0
8000b4c2:	c2 00       	breq	8000b502 <__multiply+0xa2>
8000b4c4:	12 98       	mov	r8,r9
8000b4c6:	16 96       	mov	r6,r11
8000b4c8:	30 0e       	mov	lr,0
8000b4ca:	50 09       	stdsp	sp[0x0],r9
8000b4cc:	0d 02       	ld.w	r2,r6++
8000b4ce:	e4 00 16 10 	lsr	r0,r2,0x10
8000b4d2:	70 01       	ld.w	r1,r8[0x0]
8000b4d4:	70 09       	ld.w	r9,r8[0x0]
8000b4d6:	b1 81       	lsr	r1,0x10
8000b4d8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b4dc:	e0 05 03 41 	mac	r1,r0,r5
8000b4e0:	ab 32       	mul	r2,r5
8000b4e2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b4e6:	00 02       	add	r2,r0
8000b4e8:	e4 0e 00 0e 	add	lr,r2,lr
8000b4ec:	b0 1e       	st.h	r8[0x2],lr
8000b4ee:	b1 8e       	lsr	lr,0x10
8000b4f0:	1c 01       	add	r1,lr
8000b4f2:	b0 01       	st.h	r8[0x0],r1
8000b4f4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b4f8:	2f c8       	sub	r8,-4
8000b4fa:	06 36       	cp.w	r6,r3
8000b4fc:	ce 83       	brcs	8000b4cc <__multiply+0x6c>
8000b4fe:	40 09       	lddsp	r9,sp[0x0]
8000b500:	91 0e       	st.w	r8[0x0],lr
8000b502:	94 86       	ld.uh	r6,r10[0x0]
8000b504:	58 06       	cp.w	r6,0
8000b506:	c1 d0       	breq	8000b540 <__multiply+0xe0>
8000b508:	72 02       	ld.w	r2,r9[0x0]
8000b50a:	12 98       	mov	r8,r9
8000b50c:	16 9e       	mov	lr,r11
8000b50e:	30 05       	mov	r5,0
8000b510:	b0 12       	st.h	r8[0x2],r2
8000b512:	1d 01       	ld.w	r1,lr++
8000b514:	90 82       	ld.uh	r2,r8[0x0]
8000b516:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b51a:	ad 30       	mul	r0,r6
8000b51c:	e0 02 00 02 	add	r2,r0,r2
8000b520:	e4 05 00 05 	add	r5,r2,r5
8000b524:	b0 05       	st.h	r8[0x0],r5
8000b526:	b1 85       	lsr	r5,0x10
8000b528:	b1 81       	lsr	r1,0x10
8000b52a:	2f c8       	sub	r8,-4
8000b52c:	ad 31       	mul	r1,r6
8000b52e:	90 92       	ld.uh	r2,r8[0x2]
8000b530:	e2 02 00 02 	add	r2,r1,r2
8000b534:	0a 02       	add	r2,r5
8000b536:	e4 05 16 10 	lsr	r5,r2,0x10
8000b53a:	06 3e       	cp.w	lr,r3
8000b53c:	ce a3       	brcs	8000b510 <__multiply+0xb0>
8000b53e:	91 02       	st.w	r8[0x0],r2
8000b540:	2f ca       	sub	r10,-4
8000b542:	2f c9       	sub	r9,-4
8000b544:	40 18       	lddsp	r8,sp[0x4]
8000b546:	10 3a       	cp.w	r10,r8
8000b548:	cb b3       	brcs	8000b4be <__multiply+0x5e>
8000b54a:	c0 28       	rjmp	8000b54e <__multiply+0xee>
8000b54c:	20 17       	sub	r7,1
8000b54e:	58 07       	cp.w	r7,0
8000b550:	e0 8a 00 05 	brle	8000b55a <__multiply+0xfa>
8000b554:	09 48       	ld.w	r8,--r4
8000b556:	58 08       	cp.w	r8,0
8000b558:	cf a0       	breq	8000b54c <__multiply+0xec>
8000b55a:	99 47       	st.w	r12[0x10],r7
8000b55c:	2f ed       	sub	sp,-8
8000b55e:	d8 32       	popm	r0-r7,pc

8000b560 <__i2b>:
8000b560:	d4 21       	pushm	r4-r7,lr
8000b562:	16 97       	mov	r7,r11
8000b564:	30 1b       	mov	r11,1
8000b566:	c4 9e       	rcall	8000b1f8 <_Balloc>
8000b568:	30 19       	mov	r9,1
8000b56a:	99 57       	st.w	r12[0x14],r7
8000b56c:	99 49       	st.w	r12[0x10],r9
8000b56e:	d8 22       	popm	r4-r7,pc

8000b570 <__multadd>:
8000b570:	d4 31       	pushm	r0-r7,lr
8000b572:	30 08       	mov	r8,0
8000b574:	12 95       	mov	r5,r9
8000b576:	16 97       	mov	r7,r11
8000b578:	18 96       	mov	r6,r12
8000b57a:	76 44       	ld.w	r4,r11[0x10]
8000b57c:	f6 c9 ff ec 	sub	r9,r11,-20
8000b580:	72 0b       	ld.w	r11,r9[0x0]
8000b582:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b586:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b58a:	f4 0c 02 4c 	mul	r12,r10,r12
8000b58e:	f4 0b 03 45 	mac	r5,r10,r11
8000b592:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b596:	b1 85       	lsr	r5,0x10
8000b598:	18 05       	add	r5,r12
8000b59a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b59e:	f8 0b 00 0b 	add	r11,r12,r11
8000b5a2:	12 ab       	st.w	r9++,r11
8000b5a4:	2f f8       	sub	r8,-1
8000b5a6:	b1 85       	lsr	r5,0x10
8000b5a8:	08 38       	cp.w	r8,r4
8000b5aa:	ce b5       	brlt	8000b580 <__multadd+0x10>
8000b5ac:	58 05       	cp.w	r5,0
8000b5ae:	c1 c0       	breq	8000b5e6 <__multadd+0x76>
8000b5b0:	6e 28       	ld.w	r8,r7[0x8]
8000b5b2:	10 34       	cp.w	r4,r8
8000b5b4:	c1 35       	brlt	8000b5da <__multadd+0x6a>
8000b5b6:	6e 1b       	ld.w	r11,r7[0x4]
8000b5b8:	0c 9c       	mov	r12,r6
8000b5ba:	2f fb       	sub	r11,-1
8000b5bc:	c1 ee       	rcall	8000b1f8 <_Balloc>
8000b5be:	6e 4a       	ld.w	r10,r7[0x10]
8000b5c0:	ee cb ff f4 	sub	r11,r7,-12
8000b5c4:	18 93       	mov	r3,r12
8000b5c6:	2f ea       	sub	r10,-2
8000b5c8:	2f 4c       	sub	r12,-12
8000b5ca:	a3 6a       	lsl	r10,0x2
8000b5cc:	fe b0 de 70 	rcall	800072ac <memcpy>
8000b5d0:	0e 9b       	mov	r11,r7
8000b5d2:	0c 9c       	mov	r12,r6
8000b5d4:	fe b0 fd f8 	rcall	8000b1c4 <_Bfree>
8000b5d8:	06 97       	mov	r7,r3
8000b5da:	e8 c8 ff ff 	sub	r8,r4,-1
8000b5de:	2f b4       	sub	r4,-5
8000b5e0:	8f 48       	st.w	r7[0x10],r8
8000b5e2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b5e6:	0e 9c       	mov	r12,r7
8000b5e8:	d8 32       	popm	r0-r7,pc
8000b5ea:	d7 03       	nop

8000b5ec <__pow5mult>:
8000b5ec:	d4 31       	pushm	r0-r7,lr
8000b5ee:	14 96       	mov	r6,r10
8000b5f0:	18 97       	mov	r7,r12
8000b5f2:	16 94       	mov	r4,r11
8000b5f4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b5f8:	c0 90       	breq	8000b60a <__pow5mult+0x1e>
8000b5fa:	20 18       	sub	r8,1
8000b5fc:	fe c9 da 98 	sub	r9,pc,-9576
8000b600:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b604:	30 09       	mov	r9,0
8000b606:	cb 5f       	rcall	8000b570 <__multadd>
8000b608:	18 94       	mov	r4,r12
8000b60a:	a3 46       	asr	r6,0x2
8000b60c:	c3 40       	breq	8000b674 <__pow5mult+0x88>
8000b60e:	6e 95       	ld.w	r5,r7[0x24]
8000b610:	58 05       	cp.w	r5,0
8000b612:	c0 91       	brne	8000b624 <__pow5mult+0x38>
8000b614:	31 0c       	mov	r12,16
8000b616:	fe b0 dc 27 	rcall	80006e64 <malloc>
8000b61a:	99 35       	st.w	r12[0xc],r5
8000b61c:	8f 9c       	st.w	r7[0x24],r12
8000b61e:	99 15       	st.w	r12[0x4],r5
8000b620:	99 25       	st.w	r12[0x8],r5
8000b622:	99 05       	st.w	r12[0x0],r5
8000b624:	6e 93       	ld.w	r3,r7[0x24]
8000b626:	66 25       	ld.w	r5,r3[0x8]
8000b628:	58 05       	cp.w	r5,0
8000b62a:	c0 c1       	brne	8000b642 <__pow5mult+0x56>
8000b62c:	e0 6b 02 71 	mov	r11,625
8000b630:	0e 9c       	mov	r12,r7
8000b632:	c9 7f       	rcall	8000b560 <__i2b>
8000b634:	87 2c       	st.w	r3[0x8],r12
8000b636:	30 08       	mov	r8,0
8000b638:	18 95       	mov	r5,r12
8000b63a:	99 08       	st.w	r12[0x0],r8
8000b63c:	c0 38       	rjmp	8000b642 <__pow5mult+0x56>
8000b63e:	06 9c       	mov	r12,r3
8000b640:	18 95       	mov	r5,r12
8000b642:	ed b6 00 00 	bld	r6,0x0
8000b646:	c0 b1       	brne	8000b65c <__pow5mult+0x70>
8000b648:	08 9b       	mov	r11,r4
8000b64a:	0a 9a       	mov	r10,r5
8000b64c:	0e 9c       	mov	r12,r7
8000b64e:	c0 9f       	rcall	8000b460 <__multiply>
8000b650:	08 9b       	mov	r11,r4
8000b652:	18 93       	mov	r3,r12
8000b654:	0e 9c       	mov	r12,r7
8000b656:	06 94       	mov	r4,r3
8000b658:	fe b0 fd b6 	rcall	8000b1c4 <_Bfree>
8000b65c:	a1 56       	asr	r6,0x1
8000b65e:	c0 b0       	breq	8000b674 <__pow5mult+0x88>
8000b660:	6a 03       	ld.w	r3,r5[0x0]
8000b662:	58 03       	cp.w	r3,0
8000b664:	ce d1       	brne	8000b63e <__pow5mult+0x52>
8000b666:	0a 9a       	mov	r10,r5
8000b668:	0a 9b       	mov	r11,r5
8000b66a:	0e 9c       	mov	r12,r7
8000b66c:	cf ae       	rcall	8000b460 <__multiply>
8000b66e:	8b 0c       	st.w	r5[0x0],r12
8000b670:	99 03       	st.w	r12[0x0],r3
8000b672:	ce 7b       	rjmp	8000b640 <__pow5mult+0x54>
8000b674:	08 9c       	mov	r12,r4
8000b676:	d8 32       	popm	r0-r7,pc

8000b678 <__isinfd>:
8000b678:	14 98       	mov	r8,r10
8000b67a:	fc 19 7f f0 	movh	r9,0x7ff0
8000b67e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b682:	f0 0b 11 00 	rsub	r11,r8,0
8000b686:	f7 e8 10 08 	or	r8,r11,r8
8000b68a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b68e:	f2 08 01 08 	sub	r8,r9,r8
8000b692:	f0 0c 11 00 	rsub	r12,r8,0
8000b696:	f9 e8 10 08 	or	r8,r12,r8
8000b69a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b69e:	2f fc       	sub	r12,-1
8000b6a0:	5e fc       	retal	r12

8000b6a2 <__isnand>:
8000b6a2:	14 98       	mov	r8,r10
8000b6a4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b6a8:	f0 0c 11 00 	rsub	r12,r8,0
8000b6ac:	10 4c       	or	r12,r8
8000b6ae:	fc 18 7f f0 	movh	r8,0x7ff0
8000b6b2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b6b6:	f0 0c 01 0c 	sub	r12,r8,r12
8000b6ba:	bf 9c       	lsr	r12,0x1f
8000b6bc:	5e fc       	retal	r12
8000b6be:	d7 03       	nop

8000b6c0 <__sclose>:
8000b6c0:	d4 01       	pushm	lr
8000b6c2:	96 7b       	ld.sh	r11,r11[0xe]
8000b6c4:	c8 2c       	rcall	8000b7c8 <_close_r>
8000b6c6:	d8 02       	popm	pc

8000b6c8 <__sseek>:
8000b6c8:	d4 21       	pushm	r4-r7,lr
8000b6ca:	16 97       	mov	r7,r11
8000b6cc:	96 7b       	ld.sh	r11,r11[0xe]
8000b6ce:	c0 3d       	rcall	8000b8d4 <_lseek_r>
8000b6d0:	8e 68       	ld.sh	r8,r7[0xc]
8000b6d2:	10 99       	mov	r9,r8
8000b6d4:	ad c8       	cbr	r8,0xc
8000b6d6:	ad a9       	sbr	r9,0xc
8000b6d8:	5b fc       	cp.w	r12,-1
8000b6da:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b6de:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b6e2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b6e6:	d8 22       	popm	r4-r7,pc

8000b6e8 <__swrite>:
8000b6e8:	d4 21       	pushm	r4-r7,lr
8000b6ea:	96 68       	ld.sh	r8,r11[0xc]
8000b6ec:	16 97       	mov	r7,r11
8000b6ee:	14 95       	mov	r5,r10
8000b6f0:	12 94       	mov	r4,r9
8000b6f2:	e2 18 01 00 	andl	r8,0x100,COH
8000b6f6:	18 96       	mov	r6,r12
8000b6f8:	c0 50       	breq	8000b702 <__swrite+0x1a>
8000b6fa:	30 29       	mov	r9,2
8000b6fc:	30 0a       	mov	r10,0
8000b6fe:	96 7b       	ld.sh	r11,r11[0xe]
8000b700:	ce ac       	rcall	8000b8d4 <_lseek_r>
8000b702:	8e 68       	ld.sh	r8,r7[0xc]
8000b704:	ad c8       	cbr	r8,0xc
8000b706:	08 99       	mov	r9,r4
8000b708:	0a 9a       	mov	r10,r5
8000b70a:	8e 7b       	ld.sh	r11,r7[0xe]
8000b70c:	0c 9c       	mov	r12,r6
8000b70e:	ae 68       	st.h	r7[0xc],r8
8000b710:	c1 cc       	rcall	8000b748 <_write_r>
8000b712:	d8 22       	popm	r4-r7,pc

8000b714 <__sread>:
8000b714:	d4 21       	pushm	r4-r7,lr
8000b716:	16 97       	mov	r7,r11
8000b718:	96 7b       	ld.sh	r11,r11[0xe]
8000b71a:	cf 1c       	rcall	8000b8fc <_read_r>
8000b71c:	c0 65       	brlt	8000b728 <__sread+0x14>
8000b71e:	6f 58       	ld.w	r8,r7[0x54]
8000b720:	18 08       	add	r8,r12
8000b722:	ef 48 00 54 	st.w	r7[84],r8
8000b726:	d8 22       	popm	r4-r7,pc
8000b728:	8e 68       	ld.sh	r8,r7[0xc]
8000b72a:	ad c8       	cbr	r8,0xc
8000b72c:	ae 68       	st.h	r7[0xc],r8
8000b72e:	d8 22       	popm	r4-r7,pc

8000b730 <strlen>:
8000b730:	30 09       	mov	r9,0
8000b732:	18 98       	mov	r8,r12
8000b734:	c0 28       	rjmp	8000b738 <strlen+0x8>
8000b736:	2f f8       	sub	r8,-1
8000b738:	11 8a       	ld.ub	r10,r8[0x0]
8000b73a:	f2 0a 18 00 	cp.b	r10,r9
8000b73e:	cf c1       	brne	8000b736 <strlen+0x6>
8000b740:	f0 0c 01 0c 	sub	r12,r8,r12
8000b744:	5e fc       	retal	r12
8000b746:	d7 03       	nop

8000b748 <_write_r>:
8000b748:	d4 21       	pushm	r4-r7,lr
8000b74a:	16 98       	mov	r8,r11
8000b74c:	18 97       	mov	r7,r12
8000b74e:	10 9c       	mov	r12,r8
8000b750:	30 08       	mov	r8,0
8000b752:	14 9b       	mov	r11,r10
8000b754:	e0 66 b6 74 	mov	r6,46708
8000b758:	12 9a       	mov	r10,r9
8000b75a:	8d 08       	st.w	r6[0x0],r8
8000b75c:	fe b0 d1 76 	rcall	80005a48 <_write>
8000b760:	5b fc       	cp.w	r12,-1
8000b762:	c0 51       	brne	8000b76c <_write_r+0x24>
8000b764:	6c 08       	ld.w	r8,r6[0x0]
8000b766:	58 08       	cp.w	r8,0
8000b768:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b76c:	d8 22       	popm	r4-r7,pc
8000b76e:	d7 03       	nop

8000b770 <_calloc_r>:
8000b770:	d4 21       	pushm	r4-r7,lr
8000b772:	f4 0b 02 4b 	mul	r11,r10,r11
8000b776:	fe b0 db 7f 	rcall	80006e74 <_malloc_r>
8000b77a:	18 97       	mov	r7,r12
8000b77c:	c2 30       	breq	8000b7c2 <_calloc_r+0x52>
8000b77e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b782:	e0 1a ff fc 	andl	r10,0xfffc
8000b786:	20 4a       	sub	r10,4
8000b788:	e0 4a 00 24 	cp.w	r10,36
8000b78c:	e0 8b 00 18 	brhi	8000b7bc <_calloc_r+0x4c>
8000b790:	18 98       	mov	r8,r12
8000b792:	59 3a       	cp.w	r10,19
8000b794:	e0 88 00 0f 	brls	8000b7b2 <_calloc_r+0x42>
8000b798:	30 09       	mov	r9,0
8000b79a:	10 a9       	st.w	r8++,r9
8000b79c:	10 a9       	st.w	r8++,r9
8000b79e:	59 ba       	cp.w	r10,27
8000b7a0:	e0 88 00 09 	brls	8000b7b2 <_calloc_r+0x42>
8000b7a4:	10 a9       	st.w	r8++,r9
8000b7a6:	10 a9       	st.w	r8++,r9
8000b7a8:	e0 4a 00 24 	cp.w	r10,36
8000b7ac:	c0 31       	brne	8000b7b2 <_calloc_r+0x42>
8000b7ae:	10 a9       	st.w	r8++,r9
8000b7b0:	10 a9       	st.w	r8++,r9
8000b7b2:	30 09       	mov	r9,0
8000b7b4:	10 a9       	st.w	r8++,r9
8000b7b6:	91 19       	st.w	r8[0x4],r9
8000b7b8:	91 09       	st.w	r8[0x0],r9
8000b7ba:	c0 48       	rjmp	8000b7c2 <_calloc_r+0x52>
8000b7bc:	30 0b       	mov	r11,0
8000b7be:	fe b0 de 1b 	rcall	800073f4 <memset>
8000b7c2:	0e 9c       	mov	r12,r7
8000b7c4:	d8 22       	popm	r4-r7,pc
8000b7c6:	d7 03       	nop

8000b7c8 <_close_r>:
8000b7c8:	d4 21       	pushm	r4-r7,lr
8000b7ca:	30 08       	mov	r8,0
8000b7cc:	18 97       	mov	r7,r12
8000b7ce:	e0 66 b6 74 	mov	r6,46708
8000b7d2:	16 9c       	mov	r12,r11
8000b7d4:	8d 08       	st.w	r6[0x0],r8
8000b7d6:	fe b0 df b5 	rcall	80007740 <_close>
8000b7da:	5b fc       	cp.w	r12,-1
8000b7dc:	c0 51       	brne	8000b7e6 <_close_r+0x1e>
8000b7de:	6c 08       	ld.w	r8,r6[0x0]
8000b7e0:	58 08       	cp.w	r8,0
8000b7e2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b7e6:	d8 22       	popm	r4-r7,pc

8000b7e8 <_fclose_r>:
8000b7e8:	d4 21       	pushm	r4-r7,lr
8000b7ea:	18 96       	mov	r6,r12
8000b7ec:	16 97       	mov	r7,r11
8000b7ee:	58 0b       	cp.w	r11,0
8000b7f0:	c0 31       	brne	8000b7f6 <_fclose_r+0xe>
8000b7f2:	16 95       	mov	r5,r11
8000b7f4:	c5 38       	rjmp	8000b89a <_fclose_r+0xb2>
8000b7f6:	fe b0 f8 a9 	rcall	8000a948 <__sfp_lock_acquire>
8000b7fa:	58 06       	cp.w	r6,0
8000b7fc:	c0 70       	breq	8000b80a <_fclose_r+0x22>
8000b7fe:	6c 68       	ld.w	r8,r6[0x18]
8000b800:	58 08       	cp.w	r8,0
8000b802:	c0 41       	brne	8000b80a <_fclose_r+0x22>
8000b804:	0c 9c       	mov	r12,r6
8000b806:	fe b0 f8 f3 	rcall	8000a9ec <__sinit>
8000b80a:	fe c8 dd 4a 	sub	r8,pc,-8886
8000b80e:	10 37       	cp.w	r7,r8
8000b810:	c0 31       	brne	8000b816 <_fclose_r+0x2e>
8000b812:	6c 07       	ld.w	r7,r6[0x0]
8000b814:	c0 c8       	rjmp	8000b82c <_fclose_r+0x44>
8000b816:	fe c8 dd 36 	sub	r8,pc,-8906
8000b81a:	10 37       	cp.w	r7,r8
8000b81c:	c0 31       	brne	8000b822 <_fclose_r+0x3a>
8000b81e:	6c 17       	ld.w	r7,r6[0x4]
8000b820:	c0 68       	rjmp	8000b82c <_fclose_r+0x44>
8000b822:	fe c8 dd 22 	sub	r8,pc,-8926
8000b826:	10 37       	cp.w	r7,r8
8000b828:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b82c:	8e 69       	ld.sh	r9,r7[0xc]
8000b82e:	30 08       	mov	r8,0
8000b830:	f0 09 19 00 	cp.h	r9,r8
8000b834:	c0 51       	brne	8000b83e <_fclose_r+0x56>
8000b836:	fe b0 f8 8a 	rcall	8000a94a <__sfp_lock_release>
8000b83a:	30 05       	mov	r5,0
8000b83c:	c2 f8       	rjmp	8000b89a <_fclose_r+0xb2>
8000b83e:	0e 9b       	mov	r11,r7
8000b840:	0c 9c       	mov	r12,r6
8000b842:	fe b0 f7 fd 	rcall	8000a83c <_fflush_r>
8000b846:	6e c8       	ld.w	r8,r7[0x30]
8000b848:	18 95       	mov	r5,r12
8000b84a:	58 08       	cp.w	r8,0
8000b84c:	c0 60       	breq	8000b858 <_fclose_r+0x70>
8000b84e:	6e 8b       	ld.w	r11,r7[0x20]
8000b850:	0c 9c       	mov	r12,r6
8000b852:	5d 18       	icall	r8
8000b854:	f9 b5 05 ff 	movlt	r5,-1
8000b858:	8e 68       	ld.sh	r8,r7[0xc]
8000b85a:	ed b8 00 07 	bld	r8,0x7
8000b85e:	c0 51       	brne	8000b868 <_fclose_r+0x80>
8000b860:	6e 4b       	ld.w	r11,r7[0x10]
8000b862:	0c 9c       	mov	r12,r6
8000b864:	fe b0 f9 5e 	rcall	8000ab20 <_free_r>
8000b868:	6e db       	ld.w	r11,r7[0x34]
8000b86a:	58 0b       	cp.w	r11,0
8000b86c:	c0 a0       	breq	8000b880 <_fclose_r+0x98>
8000b86e:	ee c8 ff bc 	sub	r8,r7,-68
8000b872:	10 3b       	cp.w	r11,r8
8000b874:	c0 40       	breq	8000b87c <_fclose_r+0x94>
8000b876:	0c 9c       	mov	r12,r6
8000b878:	fe b0 f9 54 	rcall	8000ab20 <_free_r>
8000b87c:	30 08       	mov	r8,0
8000b87e:	8f d8       	st.w	r7[0x34],r8
8000b880:	6f 2b       	ld.w	r11,r7[0x48]
8000b882:	58 0b       	cp.w	r11,0
8000b884:	c0 70       	breq	8000b892 <_fclose_r+0xaa>
8000b886:	0c 9c       	mov	r12,r6
8000b888:	fe b0 f9 4c 	rcall	8000ab20 <_free_r>
8000b88c:	30 08       	mov	r8,0
8000b88e:	ef 48 00 48 	st.w	r7[72],r8
8000b892:	30 08       	mov	r8,0
8000b894:	ae 68       	st.h	r7[0xc],r8
8000b896:	fe b0 f8 5a 	rcall	8000a94a <__sfp_lock_release>
8000b89a:	0a 9c       	mov	r12,r5
8000b89c:	d8 22       	popm	r4-r7,pc
8000b89e:	d7 03       	nop

8000b8a0 <fclose>:
8000b8a0:	d4 01       	pushm	lr
8000b8a2:	e0 68 0a 30 	mov	r8,2608
8000b8a6:	18 9b       	mov	r11,r12
8000b8a8:	70 0c       	ld.w	r12,r8[0x0]
8000b8aa:	c9 ff       	rcall	8000b7e8 <_fclose_r>
8000b8ac:	d8 02       	popm	pc
8000b8ae:	d7 03       	nop

8000b8b0 <_fstat_r>:
8000b8b0:	d4 21       	pushm	r4-r7,lr
8000b8b2:	16 98       	mov	r8,r11
8000b8b4:	18 97       	mov	r7,r12
8000b8b6:	10 9c       	mov	r12,r8
8000b8b8:	30 08       	mov	r8,0
8000b8ba:	e0 66 b6 74 	mov	r6,46708
8000b8be:	14 9b       	mov	r11,r10
8000b8c0:	8d 08       	st.w	r6[0x0],r8
8000b8c2:	fe b0 df 67 	rcall	80007790 <_fstat>
8000b8c6:	5b fc       	cp.w	r12,-1
8000b8c8:	c0 51       	brne	8000b8d2 <_fstat_r+0x22>
8000b8ca:	6c 08       	ld.w	r8,r6[0x0]
8000b8cc:	58 08       	cp.w	r8,0
8000b8ce:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8d2:	d8 22       	popm	r4-r7,pc

8000b8d4 <_lseek_r>:
8000b8d4:	d4 21       	pushm	r4-r7,lr
8000b8d6:	16 98       	mov	r8,r11
8000b8d8:	18 97       	mov	r7,r12
8000b8da:	10 9c       	mov	r12,r8
8000b8dc:	30 08       	mov	r8,0
8000b8de:	14 9b       	mov	r11,r10
8000b8e0:	e0 66 b6 74 	mov	r6,46708
8000b8e4:	12 9a       	mov	r10,r9
8000b8e6:	8d 08       	st.w	r6[0x0],r8
8000b8e8:	fe b0 df 36 	rcall	80007754 <_lseek>
8000b8ec:	5b fc       	cp.w	r12,-1
8000b8ee:	c0 51       	brne	8000b8f8 <_lseek_r+0x24>
8000b8f0:	6c 08       	ld.w	r8,r6[0x0]
8000b8f2:	58 08       	cp.w	r8,0
8000b8f4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b8f8:	d8 22       	popm	r4-r7,pc
8000b8fa:	d7 03       	nop

8000b8fc <_read_r>:
8000b8fc:	d4 21       	pushm	r4-r7,lr
8000b8fe:	16 98       	mov	r8,r11
8000b900:	18 97       	mov	r7,r12
8000b902:	10 9c       	mov	r12,r8
8000b904:	30 08       	mov	r8,0
8000b906:	14 9b       	mov	r11,r10
8000b908:	e0 66 b6 74 	mov	r6,46708
8000b90c:	12 9a       	mov	r10,r9
8000b90e:	8d 08       	st.w	r6[0x0],r8
8000b910:	fe b0 d0 7c 	rcall	80005a08 <_read>
8000b914:	5b fc       	cp.w	r12,-1
8000b916:	c0 51       	brne	8000b920 <_read_r+0x24>
8000b918:	6c 08       	ld.w	r8,r6[0x0]
8000b91a:	58 08       	cp.w	r8,0
8000b91c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b920:	d8 22       	popm	r4-r7,pc
8000b922:	d7 03       	nop

8000b924 <__avr32_f64_mul>:
8000b924:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b928:	e0 80 00 dc 	breq	8000bae0 <__avr32_f64_mul_op1_zero>
8000b92c:	d4 21       	pushm	r4-r7,lr
8000b92e:	f7 e9 20 0e 	eor	lr,r11,r9
8000b932:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b936:	30 15       	mov	r5,1
8000b938:	c4 30       	breq	8000b9be <__avr32_f64_mul_op1_subnormal>
8000b93a:	ab 6b       	lsl	r11,0xa
8000b93c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b940:	ab 6a       	lsl	r10,0xa
8000b942:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b946:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b94a:	c5 c0       	breq	8000ba02 <__avr32_f64_mul_op2_subnormal>
8000b94c:	a1 78       	lsl	r8,0x1
8000b94e:	5c f9       	rol	r9
8000b950:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b954:	e0 47 07 ff 	cp.w	r7,2047
8000b958:	c7 70       	breq	8000ba46 <__avr32_f64_mul_op_nan_or_inf>
8000b95a:	e0 46 07 ff 	cp.w	r6,2047
8000b95e:	c7 40       	breq	8000ba46 <__avr32_f64_mul_op_nan_or_inf>
8000b960:	ee 06 00 0c 	add	r12,r7,r6
8000b964:	e0 2c 03 fe 	sub	r12,1022
8000b968:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b96c:	f4 09 07 44 	macu.d	r4,r10,r9
8000b970:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b974:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b978:	08 07       	add	r7,r4
8000b97a:	f4 05 00 4a 	adc	r10,r10,r5
8000b97e:	5c 0b       	acr	r11
8000b980:	ed bb 00 14 	bld	r11,0x14
8000b984:	c0 50       	breq	8000b98e <__avr32_f64_mul+0x6a>
8000b986:	a1 77       	lsl	r7,0x1
8000b988:	5c fa       	rol	r10
8000b98a:	5c fb       	rol	r11
8000b98c:	20 1c       	sub	r12,1
8000b98e:	58 0c       	cp.w	r12,0
8000b990:	e0 8a 00 6f 	brle	8000ba6e <__avr32_f64_mul_res_subnormal>
8000b994:	e0 4c 07 ff 	cp.w	r12,2047
8000b998:	e0 84 00 9c 	brge	8000bad0 <__avr32_f64_mul_res_inf>
8000b99c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b9a0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b9a4:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b9a8:	ee 17 80 00 	eorh	r7,0x8000
8000b9ac:	f1 b7 04 20 	satu	r7,0x1
8000b9b0:	0e 0a       	add	r10,r7
8000b9b2:	5c 0b       	acr	r11
8000b9b4:	ed be 00 1f 	bld	lr,0x1f
8000b9b8:	ef bb 00 1f 	bst	r11,0x1f
8000b9bc:	d8 22       	popm	r4-r7,pc

8000b9be <__avr32_f64_mul_op1_subnormal>:
8000b9be:	e4 1b 00 0f 	andh	r11,0xf
8000b9c2:	f4 0c 12 00 	clz	r12,r10
8000b9c6:	f6 06 12 00 	clz	r6,r11
8000b9ca:	f7 bc 03 e1 	sublo	r12,-31
8000b9ce:	f8 06 17 30 	movlo	r6,r12
8000b9d2:	f7 b6 02 01 	subhs	r6,1
8000b9d6:	e0 46 00 20 	cp.w	r6,32
8000b9da:	c0 d4       	brge	8000b9f4 <__avr32_f64_mul_op1_subnormal+0x36>
8000b9dc:	ec 0c 11 20 	rsub	r12,r6,32
8000b9e0:	f6 06 09 4b 	lsl	r11,r11,r6
8000b9e4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b9e8:	18 4b       	or	r11,r12
8000b9ea:	f4 06 09 4a 	lsl	r10,r10,r6
8000b9ee:	20 b6       	sub	r6,11
8000b9f0:	0c 17       	sub	r7,r6
8000b9f2:	ca ab       	rjmp	8000b946 <__avr32_f64_mul+0x22>
8000b9f4:	f4 06 09 4b 	lsl	r11,r10,r6
8000b9f8:	c6 40       	breq	8000bac0 <__avr32_f64_mul_res_zero>
8000b9fa:	30 0a       	mov	r10,0
8000b9fc:	20 b6       	sub	r6,11
8000b9fe:	0c 17       	sub	r7,r6
8000ba00:	ca 3b       	rjmp	8000b946 <__avr32_f64_mul+0x22>

8000ba02 <__avr32_f64_mul_op2_subnormal>:
8000ba02:	e4 19 00 0f 	andh	r9,0xf
8000ba06:	f0 0c 12 00 	clz	r12,r8
8000ba0a:	f2 05 12 00 	clz	r5,r9
8000ba0e:	f7 bc 03 ea 	sublo	r12,-22
8000ba12:	f8 05 17 30 	movlo	r5,r12
8000ba16:	f7 b5 02 0a 	subhs	r5,10
8000ba1a:	e0 45 00 20 	cp.w	r5,32
8000ba1e:	c0 d4       	brge	8000ba38 <__avr32_f64_mul_op2_subnormal+0x36>
8000ba20:	ea 0c 11 20 	rsub	r12,r5,32
8000ba24:	f2 05 09 49 	lsl	r9,r9,r5
8000ba28:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ba2c:	18 49       	or	r9,r12
8000ba2e:	f0 05 09 48 	lsl	r8,r8,r5
8000ba32:	20 25       	sub	r5,2
8000ba34:	0a 16       	sub	r6,r5
8000ba36:	c8 fb       	rjmp	8000b954 <__avr32_f64_mul+0x30>
8000ba38:	f0 05 09 49 	lsl	r9,r8,r5
8000ba3c:	c4 20       	breq	8000bac0 <__avr32_f64_mul_res_zero>
8000ba3e:	30 08       	mov	r8,0
8000ba40:	20 25       	sub	r5,2
8000ba42:	0a 16       	sub	r6,r5
8000ba44:	c8 8b       	rjmp	8000b954 <__avr32_f64_mul+0x30>

8000ba46 <__avr32_f64_mul_op_nan_or_inf>:
8000ba46:	e4 19 00 0f 	andh	r9,0xf
8000ba4a:	e4 1b 00 0f 	andh	r11,0xf
8000ba4e:	14 4b       	or	r11,r10
8000ba50:	10 49       	or	r9,r8
8000ba52:	e0 47 07 ff 	cp.w	r7,2047
8000ba56:	c0 91       	brne	8000ba68 <__avr32_f64_mul_op1_not_naninf>
8000ba58:	58 0b       	cp.w	r11,0
8000ba5a:	c3 81       	brne	8000baca <__avr32_f64_mul_res_nan>
8000ba5c:	e0 46 07 ff 	cp.w	r6,2047
8000ba60:	c3 81       	brne	8000bad0 <__avr32_f64_mul_res_inf>
8000ba62:	58 09       	cp.w	r9,0
8000ba64:	c3 60       	breq	8000bad0 <__avr32_f64_mul_res_inf>
8000ba66:	c3 28       	rjmp	8000baca <__avr32_f64_mul_res_nan>

8000ba68 <__avr32_f64_mul_op1_not_naninf>:
8000ba68:	58 09       	cp.w	r9,0
8000ba6a:	c3 30       	breq	8000bad0 <__avr32_f64_mul_res_inf>
8000ba6c:	c2 f8       	rjmp	8000baca <__avr32_f64_mul_res_nan>

8000ba6e <__avr32_f64_mul_res_subnormal>:
8000ba6e:	5c 3c       	neg	r12
8000ba70:	2f fc       	sub	r12,-1
8000ba72:	f1 bc 04 c0 	satu	r12,0x6
8000ba76:	e0 4c 00 20 	cp.w	r12,32
8000ba7a:	c1 14       	brge	8000ba9c <__avr32_f64_mul_res_subnormal+0x2e>
8000ba7c:	f8 08 11 20 	rsub	r8,r12,32
8000ba80:	0e 46       	or	r6,r7
8000ba82:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ba86:	f4 08 09 49 	lsl	r9,r10,r8
8000ba8a:	12 47       	or	r7,r9
8000ba8c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba90:	f6 08 09 49 	lsl	r9,r11,r8
8000ba94:	12 4a       	or	r10,r9
8000ba96:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ba9a:	c8 3b       	rjmp	8000b9a0 <__avr32_f64_mul+0x7c>
8000ba9c:	f8 08 11 20 	rsub	r8,r12,32
8000baa0:	f9 b9 00 00 	moveq	r9,0
8000baa4:	c0 30       	breq	8000baaa <__avr32_f64_mul_res_subnormal+0x3c>
8000baa6:	f6 08 09 49 	lsl	r9,r11,r8
8000baaa:	0e 46       	or	r6,r7
8000baac:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bab0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bab4:	f3 ea 10 07 	or	r7,r9,r10
8000bab8:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000babc:	30 0b       	mov	r11,0
8000babe:	c7 1b       	rjmp	8000b9a0 <__avr32_f64_mul+0x7c>

8000bac0 <__avr32_f64_mul_res_zero>:
8000bac0:	1c 9b       	mov	r11,lr
8000bac2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bac6:	30 0a       	mov	r10,0
8000bac8:	d8 22       	popm	r4-r7,pc

8000baca <__avr32_f64_mul_res_nan>:
8000baca:	3f fb       	mov	r11,-1
8000bacc:	3f fa       	mov	r10,-1
8000bace:	d8 22       	popm	r4-r7,pc

8000bad0 <__avr32_f64_mul_res_inf>:
8000bad0:	f0 6b 00 00 	mov	r11,-1048576
8000bad4:	ed be 00 1f 	bld	lr,0x1f
8000bad8:	ef bb 00 1f 	bst	r11,0x1f
8000badc:	30 0a       	mov	r10,0
8000bade:	d8 22       	popm	r4-r7,pc

8000bae0 <__avr32_f64_mul_op1_zero>:
8000bae0:	f7 e9 20 0b 	eor	r11,r11,r9
8000bae4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bae8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000baec:	e0 4c 07 ff 	cp.w	r12,2047
8000baf0:	5e 1c       	retne	r12
8000baf2:	3f fa       	mov	r10,-1
8000baf4:	3f fb       	mov	r11,-1
8000baf6:	5e fc       	retal	r12

8000baf8 <__avr32_f64_sub_from_add>:
8000baf8:	ee 19 80 00 	eorh	r9,0x8000

8000bafc <__avr32_f64_sub>:
8000bafc:	f7 e9 20 0c 	eor	r12,r11,r9
8000bb00:	e0 86 00 ca 	brmi	8000bc94 <__avr32_f64_add_from_sub>
8000bb04:	eb cd 40 e0 	pushm	r5-r7,lr
8000bb08:	16 9c       	mov	r12,r11
8000bb0a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bb0e:	bf db       	cbr	r11,0x1f
8000bb10:	bf d9       	cbr	r9,0x1f
8000bb12:	10 3a       	cp.w	r10,r8
8000bb14:	f2 0b 13 00 	cpc	r11,r9
8000bb18:	c0 92       	brcc	8000bb2a <__avr32_f64_sub+0x2e>
8000bb1a:	16 97       	mov	r7,r11
8000bb1c:	12 9b       	mov	r11,r9
8000bb1e:	0e 99       	mov	r9,r7
8000bb20:	14 97       	mov	r7,r10
8000bb22:	10 9a       	mov	r10,r8
8000bb24:	0e 98       	mov	r8,r7
8000bb26:	ee 1c 80 00 	eorh	r12,0x8000
8000bb2a:	f6 07 16 14 	lsr	r7,r11,0x14
8000bb2e:	ab 7b       	lsl	r11,0xb
8000bb30:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bb34:	ab 7a       	lsl	r10,0xb
8000bb36:	bf bb       	sbr	r11,0x1f
8000bb38:	f2 06 16 14 	lsr	r6,r9,0x14
8000bb3c:	c4 40       	breq	8000bbc4 <__avr32_f64_sub_opL_subnormal>
8000bb3e:	ab 79       	lsl	r9,0xb
8000bb40:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bb44:	ab 78       	lsl	r8,0xb
8000bb46:	bf b9       	sbr	r9,0x1f

8000bb48 <__avr32_f64_sub_opL_subnormal_done>:
8000bb48:	e0 47 07 ff 	cp.w	r7,2047
8000bb4c:	c4 f0       	breq	8000bbea <__avr32_f64_sub_opH_nan_or_inf>
8000bb4e:	0e 26       	rsub	r6,r7
8000bb50:	c1 20       	breq	8000bb74 <__avr32_f64_sub_shift_done>
8000bb52:	ec 05 11 20 	rsub	r5,r6,32
8000bb56:	e0 46 00 20 	cp.w	r6,32
8000bb5a:	c7 c2       	brcc	8000bc52 <__avr32_f64_sub_longshift>
8000bb5c:	f0 05 09 4e 	lsl	lr,r8,r5
8000bb60:	f2 05 09 45 	lsl	r5,r9,r5
8000bb64:	f0 06 0a 48 	lsr	r8,r8,r6
8000bb68:	f2 06 0a 49 	lsr	r9,r9,r6
8000bb6c:	0a 48       	or	r8,r5
8000bb6e:	58 0e       	cp.w	lr,0
8000bb70:	5f 1e       	srne	lr
8000bb72:	1c 48       	or	r8,lr

8000bb74 <__avr32_f64_sub_shift_done>:
8000bb74:	10 1a       	sub	r10,r8
8000bb76:	f6 09 01 4b 	sbc	r11,r11,r9
8000bb7a:	f6 06 12 00 	clz	r6,r11
8000bb7e:	c0 e0       	breq	8000bb9a <__avr32_f64_sub_longnormalize_done>
8000bb80:	c7 83       	brcs	8000bc70 <__avr32_f64_sub_longnormalize>
8000bb82:	ec 0e 11 20 	rsub	lr,r6,32
8000bb86:	f6 06 09 4b 	lsl	r11,r11,r6
8000bb8a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb8e:	1c 4b       	or	r11,lr
8000bb90:	f4 06 09 4a 	lsl	r10,r10,r6
8000bb94:	0c 17       	sub	r7,r6
8000bb96:	e0 8a 00 39 	brle	8000bc08 <__avr32_f64_sub_subnormal_result>

8000bb9a <__avr32_f64_sub_longnormalize_done>:
8000bb9a:	f4 09 15 15 	lsl	r9,r10,0x15
8000bb9e:	ab 9a       	lsr	r10,0xb
8000bba0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bba4:	ab 9b       	lsr	r11,0xb
8000bba6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bbaa:	18 4b       	or	r11,r12

8000bbac <__avr32_f64_sub_round>:
8000bbac:	fc 17 80 00 	movh	r7,0x8000
8000bbb0:	ed ba 00 00 	bld	r10,0x0
8000bbb4:	f7 b7 01 ff 	subne	r7,-1
8000bbb8:	0e 39       	cp.w	r9,r7
8000bbba:	5f 29       	srhs	r9
8000bbbc:	12 0a       	add	r10,r9
8000bbbe:	5c 0b       	acr	r11
8000bbc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bbc4 <__avr32_f64_sub_opL_subnormal>:
8000bbc4:	ab 79       	lsl	r9,0xb
8000bbc6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bbca:	ab 78       	lsl	r8,0xb
8000bbcc:	f3 e8 10 0e 	or	lr,r9,r8
8000bbd0:	f9 b6 01 01 	movne	r6,1
8000bbd4:	ee 0e 11 00 	rsub	lr,r7,0
8000bbd8:	f9 b7 00 01 	moveq	r7,1
8000bbdc:	ef bb 00 1f 	bst	r11,0x1f
8000bbe0:	f7 ea 10 0e 	or	lr,r11,r10
8000bbe4:	f9 b7 00 00 	moveq	r7,0
8000bbe8:	cb 0b       	rjmp	8000bb48 <__avr32_f64_sub_opL_subnormal_done>

8000bbea <__avr32_f64_sub_opH_nan_or_inf>:
8000bbea:	bf db       	cbr	r11,0x1f
8000bbec:	f7 ea 10 0e 	or	lr,r11,r10
8000bbf0:	c0 81       	brne	8000bc00 <__avr32_f64_sub_return_nan>
8000bbf2:	e0 46 07 ff 	cp.w	r6,2047
8000bbf6:	c0 50       	breq	8000bc00 <__avr32_f64_sub_return_nan>
8000bbf8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bbfc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc00 <__avr32_f64_sub_return_nan>:
8000bc00:	3f fa       	mov	r10,-1
8000bc02:	3f fb       	mov	r11,-1
8000bc04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc08 <__avr32_f64_sub_subnormal_result>:
8000bc08:	5c 37       	neg	r7
8000bc0a:	2f f7       	sub	r7,-1
8000bc0c:	f1 b7 04 c0 	satu	r7,0x6
8000bc10:	e0 47 00 20 	cp.w	r7,32
8000bc14:	c1 14       	brge	8000bc36 <__avr32_f64_sub_subnormal_result+0x2e>
8000bc16:	ee 08 11 20 	rsub	r8,r7,32
8000bc1a:	f4 08 09 49 	lsl	r9,r10,r8
8000bc1e:	5f 16       	srne	r6
8000bc20:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bc24:	0c 4a       	or	r10,r6
8000bc26:	f6 08 09 49 	lsl	r9,r11,r8
8000bc2a:	f5 e9 10 0a 	or	r10,r10,r9
8000bc2e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bc32:	30 07       	mov	r7,0
8000bc34:	cb 3b       	rjmp	8000bb9a <__avr32_f64_sub_longnormalize_done>
8000bc36:	ee 08 11 40 	rsub	r8,r7,64
8000bc3a:	f6 08 09 49 	lsl	r9,r11,r8
8000bc3e:	14 49       	or	r9,r10
8000bc40:	5f 16       	srne	r6
8000bc42:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bc46:	0c 4a       	or	r10,r6
8000bc48:	30 0b       	mov	r11,0
8000bc4a:	30 07       	mov	r7,0
8000bc4c:	ca 7b       	rjmp	8000bb9a <__avr32_f64_sub_longnormalize_done>
8000bc4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bc52 <__avr32_f64_sub_longshift>:
8000bc52:	f1 b6 04 c0 	satu	r6,0x6
8000bc56:	f0 0e 17 00 	moveq	lr,r8
8000bc5a:	c0 40       	breq	8000bc62 <__avr32_f64_sub_longshift+0x10>
8000bc5c:	f2 05 09 4e 	lsl	lr,r9,r5
8000bc60:	10 4e       	or	lr,r8
8000bc62:	f2 06 0a 48 	lsr	r8,r9,r6
8000bc66:	30 09       	mov	r9,0
8000bc68:	58 0e       	cp.w	lr,0
8000bc6a:	5f 1e       	srne	lr
8000bc6c:	1c 48       	or	r8,lr
8000bc6e:	c8 3b       	rjmp	8000bb74 <__avr32_f64_sub_shift_done>

8000bc70 <__avr32_f64_sub_longnormalize>:
8000bc70:	f4 06 12 00 	clz	r6,r10
8000bc74:	f9 b7 03 00 	movlo	r7,0
8000bc78:	f9 b6 03 00 	movlo	r6,0
8000bc7c:	f9 bc 03 00 	movlo	r12,0
8000bc80:	f7 b6 02 e0 	subhs	r6,-32
8000bc84:	f4 06 09 4b 	lsl	r11,r10,r6
8000bc88:	30 0a       	mov	r10,0
8000bc8a:	0c 17       	sub	r7,r6
8000bc8c:	fe 9a ff be 	brle	8000bc08 <__avr32_f64_sub_subnormal_result>
8000bc90:	c8 5b       	rjmp	8000bb9a <__avr32_f64_sub_longnormalize_done>
8000bc92:	d7 03       	nop

8000bc94 <__avr32_f64_add_from_sub>:
8000bc94:	ee 19 80 00 	eorh	r9,0x8000

8000bc98 <__avr32_f64_add>:
8000bc98:	f7 e9 20 0c 	eor	r12,r11,r9
8000bc9c:	fe 96 ff 2e 	brmi	8000baf8 <__avr32_f64_sub_from_add>
8000bca0:	eb cd 40 e0 	pushm	r5-r7,lr
8000bca4:	16 9c       	mov	r12,r11
8000bca6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bcaa:	bf db       	cbr	r11,0x1f
8000bcac:	bf d9       	cbr	r9,0x1f
8000bcae:	12 3b       	cp.w	r11,r9
8000bcb0:	c0 72       	brcc	8000bcbe <__avr32_f64_add+0x26>
8000bcb2:	16 97       	mov	r7,r11
8000bcb4:	12 9b       	mov	r11,r9
8000bcb6:	0e 99       	mov	r9,r7
8000bcb8:	14 97       	mov	r7,r10
8000bcba:	10 9a       	mov	r10,r8
8000bcbc:	0e 98       	mov	r8,r7
8000bcbe:	30 0e       	mov	lr,0
8000bcc0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bcc4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000bcc8:	b5 ab       	sbr	r11,0x14
8000bcca:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bcce:	c6 20       	breq	8000bd92 <__avr32_f64_add_op2_subnormal>
8000bcd0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000bcd4:	b5 a9       	sbr	r9,0x14
8000bcd6:	e0 47 07 ff 	cp.w	r7,2047
8000bcda:	c2 80       	breq	8000bd2a <__avr32_f64_add_opH_nan_or_inf>
8000bcdc:	0e 26       	rsub	r6,r7
8000bcde:	c1 20       	breq	8000bd02 <__avr32_f64_add_shift_done>
8000bce0:	e0 46 00 36 	cp.w	r6,54
8000bce4:	c1 52       	brcc	8000bd0e <__avr32_f64_add_res_of_done>
8000bce6:	ec 05 11 20 	rsub	r5,r6,32
8000bcea:	e0 46 00 20 	cp.w	r6,32
8000bcee:	c3 52       	brcc	8000bd58 <__avr32_f64_add_longshift>
8000bcf0:	f0 05 09 4e 	lsl	lr,r8,r5
8000bcf4:	f2 05 09 45 	lsl	r5,r9,r5
8000bcf8:	f0 06 0a 48 	lsr	r8,r8,r6
8000bcfc:	f2 06 0a 49 	lsr	r9,r9,r6
8000bd00:	0a 48       	or	r8,r5

8000bd02 <__avr32_f64_add_shift_done>:
8000bd02:	10 0a       	add	r10,r8
8000bd04:	f6 09 00 4b 	adc	r11,r11,r9
8000bd08:	ed bb 00 15 	bld	r11,0x15
8000bd0c:	c3 40       	breq	8000bd74 <__avr32_f64_add_res_of>

8000bd0e <__avr32_f64_add_res_of_done>:
8000bd0e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bd12:	18 4b       	or	r11,r12

8000bd14 <__avr32_f64_add_round>:
8000bd14:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000bd18:	18 4e       	or	lr,r12
8000bd1a:	ee 1e 80 00 	eorh	lr,0x8000
8000bd1e:	f1 be 04 20 	satu	lr,0x1
8000bd22:	1c 0a       	add	r10,lr
8000bd24:	5c 0b       	acr	r11
8000bd26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd2a <__avr32_f64_add_opH_nan_or_inf>:
8000bd2a:	b5 cb       	cbr	r11,0x14
8000bd2c:	f7 ea 10 0e 	or	lr,r11,r10
8000bd30:	c1 01       	brne	8000bd50 <__avr32_f64_add_return_nan>
8000bd32:	e0 46 07 ff 	cp.w	r6,2047
8000bd36:	c0 30       	breq	8000bd3c <__avr32_f64_add_opL_nan_or_inf>
8000bd38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd3c <__avr32_f64_add_opL_nan_or_inf>:
8000bd3c:	b5 c9       	cbr	r9,0x14
8000bd3e:	f3 e8 10 0e 	or	lr,r9,r8
8000bd42:	c0 71       	brne	8000bd50 <__avr32_f64_add_return_nan>
8000bd44:	30 0a       	mov	r10,0
8000bd46:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bd4a:	18 4b       	or	r11,r12
8000bd4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd50 <__avr32_f64_add_return_nan>:
8000bd50:	3f fa       	mov	r10,-1
8000bd52:	3f fb       	mov	r11,-1
8000bd54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bd58 <__avr32_f64_add_longshift>:
8000bd58:	f1 b6 04 c0 	satu	r6,0x6
8000bd5c:	f0 0e 17 00 	moveq	lr,r8
8000bd60:	c0 60       	breq	8000bd6c <__avr32_f64_add_longshift+0x14>
8000bd62:	f2 05 09 4e 	lsl	lr,r9,r5
8000bd66:	58 08       	cp.w	r8,0
8000bd68:	5f 18       	srne	r8
8000bd6a:	10 4e       	or	lr,r8
8000bd6c:	f2 06 0a 48 	lsr	r8,r9,r6
8000bd70:	30 09       	mov	r9,0
8000bd72:	cc 8b       	rjmp	8000bd02 <__avr32_f64_add_shift_done>

8000bd74 <__avr32_f64_add_res_of>:
8000bd74:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bd78:	a1 9b       	lsr	r11,0x1
8000bd7a:	5d 0a       	ror	r10
8000bd7c:	5d 0e       	ror	lr
8000bd7e:	2f f7       	sub	r7,-1
8000bd80:	e0 47 07 ff 	cp.w	r7,2047
8000bd84:	f9 ba 00 00 	moveq	r10,0
8000bd88:	f9 bb 00 00 	moveq	r11,0
8000bd8c:	f9 be 00 00 	moveq	lr,0
8000bd90:	cb fb       	rjmp	8000bd0e <__avr32_f64_add_res_of_done>

8000bd92 <__avr32_f64_add_op2_subnormal>:
8000bd92:	30 16       	mov	r6,1
8000bd94:	58 07       	cp.w	r7,0
8000bd96:	ca 01       	brne	8000bcd6 <__avr32_f64_add+0x3e>
8000bd98:	b5 cb       	cbr	r11,0x14
8000bd9a:	10 0a       	add	r10,r8
8000bd9c:	f6 09 00 4b 	adc	r11,r11,r9
8000bda0:	18 4b       	or	r11,r12
8000bda2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bda6:	d7 03       	nop

8000bda8 <__avr32_f64_to_u32>:
8000bda8:	58 0b       	cp.w	r11,0
8000bdaa:	5e 6d       	retmi	0

8000bdac <__avr32_f64_to_s32>:
8000bdac:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bdb0:	b5 9c       	lsr	r12,0x15
8000bdb2:	e0 2c 03 ff 	sub	r12,1023
8000bdb6:	5e 3d       	retlo	0
8000bdb8:	f8 0c 11 1f 	rsub	r12,r12,31
8000bdbc:	16 99       	mov	r9,r11
8000bdbe:	ab 7b       	lsl	r11,0xb
8000bdc0:	bf bb       	sbr	r11,0x1f
8000bdc2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bdc6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bdca:	a1 79       	lsl	r9,0x1
8000bdcc:	5e 2b       	reths	r11
8000bdce:	5c 3b       	neg	r11
8000bdd0:	5e fb       	retal	r11

8000bdd2 <__avr32_u32_to_f64>:
8000bdd2:	f8 cb 00 00 	sub	r11,r12,0
8000bdd6:	30 0c       	mov	r12,0
8000bdd8:	c0 38       	rjmp	8000bdde <__avr32_s32_to_f64+0x4>

8000bdda <__avr32_s32_to_f64>:
8000bdda:	18 9b       	mov	r11,r12
8000bddc:	5c 4b       	abs	r11
8000bdde:	30 0a       	mov	r10,0
8000bde0:	5e 0b       	reteq	r11
8000bde2:	d4 01       	pushm	lr
8000bde4:	e0 69 04 1e 	mov	r9,1054
8000bde8:	f6 08 12 00 	clz	r8,r11
8000bdec:	c1 70       	breq	8000be1a <__avr32_s32_to_f64+0x40>
8000bdee:	c0 c3       	brcs	8000be06 <__avr32_s32_to_f64+0x2c>
8000bdf0:	f0 0e 11 20 	rsub	lr,r8,32
8000bdf4:	f6 08 09 4b 	lsl	r11,r11,r8
8000bdf8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bdfc:	1c 4b       	or	r11,lr
8000bdfe:	f4 08 09 4a 	lsl	r10,r10,r8
8000be02:	10 19       	sub	r9,r8
8000be04:	c0 b8       	rjmp	8000be1a <__avr32_s32_to_f64+0x40>
8000be06:	f4 08 12 00 	clz	r8,r10
8000be0a:	f9 b8 03 00 	movlo	r8,0
8000be0e:	f7 b8 02 e0 	subhs	r8,-32
8000be12:	f4 08 09 4b 	lsl	r11,r10,r8
8000be16:	30 0a       	mov	r10,0
8000be18:	10 19       	sub	r9,r8
8000be1a:	58 09       	cp.w	r9,0
8000be1c:	e0 89 00 30 	brgt	8000be7c <__avr32_s32_to_f64+0xa2>
8000be20:	5c 39       	neg	r9
8000be22:	2f f9       	sub	r9,-1
8000be24:	e0 49 00 36 	cp.w	r9,54
8000be28:	c0 43       	brcs	8000be30 <__avr32_s32_to_f64+0x56>
8000be2a:	30 0b       	mov	r11,0
8000be2c:	30 0a       	mov	r10,0
8000be2e:	c2 68       	rjmp	8000be7a <__avr32_s32_to_f64+0xa0>
8000be30:	2f 69       	sub	r9,-10
8000be32:	f2 08 11 20 	rsub	r8,r9,32
8000be36:	e0 49 00 20 	cp.w	r9,32
8000be3a:	c0 b2       	brcc	8000be50 <__avr32_s32_to_f64+0x76>
8000be3c:	f4 08 09 4e 	lsl	lr,r10,r8
8000be40:	f6 08 09 48 	lsl	r8,r11,r8
8000be44:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be48:	f6 09 0a 4b 	lsr	r11,r11,r9
8000be4c:	10 4b       	or	r11,r8
8000be4e:	c0 88       	rjmp	8000be5e <__avr32_s32_to_f64+0x84>
8000be50:	f6 08 09 4e 	lsl	lr,r11,r8
8000be54:	14 4e       	or	lr,r10
8000be56:	16 9a       	mov	r10,r11
8000be58:	30 0b       	mov	r11,0
8000be5a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be5e:	ed ba 00 00 	bld	r10,0x0
8000be62:	c0 92       	brcc	8000be74 <__avr32_s32_to_f64+0x9a>
8000be64:	1c 7e       	tst	lr,lr
8000be66:	c0 41       	brne	8000be6e <__avr32_s32_to_f64+0x94>
8000be68:	ed ba 00 01 	bld	r10,0x1
8000be6c:	c0 42       	brcc	8000be74 <__avr32_s32_to_f64+0x9a>
8000be6e:	2f fa       	sub	r10,-1
8000be70:	f7 bb 02 ff 	subhs	r11,-1
8000be74:	5c fc       	rol	r12
8000be76:	5d 0b       	ror	r11
8000be78:	5d 0a       	ror	r10
8000be7a:	d8 02       	popm	pc
8000be7c:	e0 68 03 ff 	mov	r8,1023
8000be80:	ed ba 00 0b 	bld	r10,0xb
8000be84:	f7 b8 00 ff 	subeq	r8,-1
8000be88:	10 0a       	add	r10,r8
8000be8a:	5c 0b       	acr	r11
8000be8c:	f7 b9 03 fe 	sublo	r9,-2
8000be90:	e0 49 07 ff 	cp.w	r9,2047
8000be94:	c0 55       	brlt	8000be9e <__avr32_s32_to_f64+0xc4>
8000be96:	30 0a       	mov	r10,0
8000be98:	fc 1b ff e0 	movh	r11,0xffe0
8000be9c:	c0 c8       	rjmp	8000beb4 <__floatsidf_return_op1>
8000be9e:	ed bb 00 1f 	bld	r11,0x1f
8000bea2:	f7 b9 01 01 	subne	r9,1
8000bea6:	ab 9a       	lsr	r10,0xb
8000bea8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000beac:	a1 7b       	lsl	r11,0x1
8000beae:	ab 9b       	lsr	r11,0xb
8000beb0:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000beb4 <__floatsidf_return_op1>:
8000beb4:	a1 7c       	lsl	r12,0x1
8000beb6:	5d 0b       	ror	r11
8000beb8:	d8 02       	popm	pc

8000beba <__avr32_f64_cmp_eq>:
8000beba:	10 3a       	cp.w	r10,r8
8000bebc:	f2 0b 13 00 	cpc	r11,r9
8000bec0:	c0 80       	breq	8000bed0 <__avr32_f64_cmp_eq+0x16>
8000bec2:	a1 7b       	lsl	r11,0x1
8000bec4:	a1 79       	lsl	r9,0x1
8000bec6:	14 4b       	or	r11,r10
8000bec8:	12 4b       	or	r11,r9
8000beca:	10 4b       	or	r11,r8
8000becc:	5e 0f       	reteq	1
8000bece:	5e fd       	retal	0
8000bed0:	a1 7b       	lsl	r11,0x1
8000bed2:	fc 1c ff e0 	movh	r12,0xffe0
8000bed6:	58 0a       	cp.w	r10,0
8000bed8:	f8 0b 13 00 	cpc	r11,r12
8000bedc:	5e 8f       	retls	1
8000bede:	5e fd       	retal	0

8000bee0 <__avr32_f64_cmp_ge>:
8000bee0:	1a de       	st.w	--sp,lr
8000bee2:	1a d7       	st.w	--sp,r7
8000bee4:	a1 7b       	lsl	r11,0x1
8000bee6:	5f 3c       	srlo	r12
8000bee8:	a1 79       	lsl	r9,0x1
8000beea:	5f 37       	srlo	r7
8000beec:	5c fc       	rol	r12
8000beee:	fc 1e ff e0 	movh	lr,0xffe0
8000bef2:	58 0a       	cp.w	r10,0
8000bef4:	fc 0b 13 00 	cpc	r11,lr
8000bef8:	e0 8b 00 1d 	brhi	8000bf32 <__avr32_f64_cmp_ge+0x52>
8000befc:	58 08       	cp.w	r8,0
8000befe:	fc 09 13 00 	cpc	r9,lr
8000bf02:	e0 8b 00 18 	brhi	8000bf32 <__avr32_f64_cmp_ge+0x52>
8000bf06:	58 0b       	cp.w	r11,0
8000bf08:	f5 ba 00 00 	subfeq	r10,0
8000bf0c:	c1 50       	breq	8000bf36 <__avr32_f64_cmp_ge+0x56>
8000bf0e:	1b 07       	ld.w	r7,sp++
8000bf10:	1b 0e       	ld.w	lr,sp++
8000bf12:	58 3c       	cp.w	r12,3
8000bf14:	c0 a0       	breq	8000bf28 <__avr32_f64_cmp_ge+0x48>
8000bf16:	58 1c       	cp.w	r12,1
8000bf18:	c0 33       	brcs	8000bf1e <__avr32_f64_cmp_ge+0x3e>
8000bf1a:	5e 0f       	reteq	1
8000bf1c:	5e 1d       	retne	0
8000bf1e:	10 3a       	cp.w	r10,r8
8000bf20:	f2 0b 13 00 	cpc	r11,r9
8000bf24:	5e 2f       	reths	1
8000bf26:	5e 3d       	retlo	0
8000bf28:	14 38       	cp.w	r8,r10
8000bf2a:	f6 09 13 00 	cpc	r9,r11
8000bf2e:	5e 2f       	reths	1
8000bf30:	5e 3d       	retlo	0
8000bf32:	1b 07       	ld.w	r7,sp++
8000bf34:	d8 0a       	popm	pc,r12=0
8000bf36:	58 17       	cp.w	r7,1
8000bf38:	5f 0c       	sreq	r12
8000bf3a:	58 09       	cp.w	r9,0
8000bf3c:	f5 b8 00 00 	subfeq	r8,0
8000bf40:	1b 07       	ld.w	r7,sp++
8000bf42:	1b 0e       	ld.w	lr,sp++
8000bf44:	5e 0f       	reteq	1
8000bf46:	5e fc       	retal	r12

8000bf48 <__avr32_f64_cmp_lt>:
8000bf48:	1a de       	st.w	--sp,lr
8000bf4a:	1a d7       	st.w	--sp,r7
8000bf4c:	a1 7b       	lsl	r11,0x1
8000bf4e:	5f 3c       	srlo	r12
8000bf50:	a1 79       	lsl	r9,0x1
8000bf52:	5f 37       	srlo	r7
8000bf54:	5c fc       	rol	r12
8000bf56:	fc 1e ff e0 	movh	lr,0xffe0
8000bf5a:	58 0a       	cp.w	r10,0
8000bf5c:	fc 0b 13 00 	cpc	r11,lr
8000bf60:	e0 8b 00 1d 	brhi	8000bf9a <__avr32_f64_cmp_lt+0x52>
8000bf64:	58 08       	cp.w	r8,0
8000bf66:	fc 09 13 00 	cpc	r9,lr
8000bf6a:	e0 8b 00 18 	brhi	8000bf9a <__avr32_f64_cmp_lt+0x52>
8000bf6e:	58 0b       	cp.w	r11,0
8000bf70:	f5 ba 00 00 	subfeq	r10,0
8000bf74:	c1 50       	breq	8000bf9e <__avr32_f64_cmp_lt+0x56>
8000bf76:	1b 07       	ld.w	r7,sp++
8000bf78:	1b 0e       	ld.w	lr,sp++
8000bf7a:	58 3c       	cp.w	r12,3
8000bf7c:	c0 a0       	breq	8000bf90 <__avr32_f64_cmp_lt+0x48>
8000bf7e:	58 1c       	cp.w	r12,1
8000bf80:	c0 33       	brcs	8000bf86 <__avr32_f64_cmp_lt+0x3e>
8000bf82:	5e 0d       	reteq	0
8000bf84:	5e 1f       	retne	1
8000bf86:	10 3a       	cp.w	r10,r8
8000bf88:	f2 0b 13 00 	cpc	r11,r9
8000bf8c:	5e 2d       	reths	0
8000bf8e:	5e 3f       	retlo	1
8000bf90:	14 38       	cp.w	r8,r10
8000bf92:	f6 09 13 00 	cpc	r9,r11
8000bf96:	5e 2d       	reths	0
8000bf98:	5e 3f       	retlo	1
8000bf9a:	1b 07       	ld.w	r7,sp++
8000bf9c:	d8 0a       	popm	pc,r12=0
8000bf9e:	58 17       	cp.w	r7,1
8000bfa0:	5f 1c       	srne	r12
8000bfa2:	58 09       	cp.w	r9,0
8000bfa4:	f5 b8 00 00 	subfeq	r8,0
8000bfa8:	1b 07       	ld.w	r7,sp++
8000bfaa:	1b 0e       	ld.w	lr,sp++
8000bfac:	5e 0d       	reteq	0
8000bfae:	5e fc       	retal	r12

8000bfb0 <__avr32_f64_div>:
8000bfb0:	eb cd 40 ff 	pushm	r0-r7,lr
8000bfb4:	f7 e9 20 0e 	eor	lr,r11,r9
8000bfb8:	f6 07 16 14 	lsr	r7,r11,0x14
8000bfbc:	a9 7b       	lsl	r11,0x9
8000bfbe:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bfc2:	a9 7a       	lsl	r10,0x9
8000bfc4:	bd bb       	sbr	r11,0x1d
8000bfc6:	e4 1b 3f ff 	andh	r11,0x3fff
8000bfca:	ab d7       	cbr	r7,0xb
8000bfcc:	e0 80 00 cc 	breq	8000c164 <__avr32_f64_div_round_subnormal+0x54>
8000bfd0:	e0 47 07 ff 	cp.w	r7,2047
8000bfd4:	e0 84 00 b5 	brge	8000c13e <__avr32_f64_div_round_subnormal+0x2e>
8000bfd8:	f2 06 16 14 	lsr	r6,r9,0x14
8000bfdc:	a9 79       	lsl	r9,0x9
8000bfde:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bfe2:	a9 78       	lsl	r8,0x9
8000bfe4:	bd b9       	sbr	r9,0x1d
8000bfe6:	e4 19 3f ff 	andh	r9,0x3fff
8000bfea:	ab d6       	cbr	r6,0xb
8000bfec:	e0 80 00 e2 	breq	8000c1b0 <__avr32_f64_div_round_subnormal+0xa0>
8000bff0:	e0 46 07 ff 	cp.w	r6,2047
8000bff4:	e0 84 00 b2 	brge	8000c158 <__avr32_f64_div_round_subnormal+0x48>
8000bff8:	0c 17       	sub	r7,r6
8000bffa:	fe 37 fc 01 	sub	r7,-1023
8000bffe:	fc 1c 80 00 	movh	r12,0x8000
8000c002:	f8 03 16 01 	lsr	r3,r12,0x1
8000c006:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c00a:	5c d4       	com	r4
8000c00c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c010:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c014:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c018:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c01c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c020:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c024:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c028:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c02c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c030:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c034:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c038:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c03c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c040:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c044:	e4 09 07 40 	macu.d	r0,r2,r9
8000c048:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c04c:	02 04       	add	r4,r1
8000c04e:	5c 05       	acr	r5
8000c050:	a3 65       	lsl	r5,0x2
8000c052:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c056:	a3 64       	lsl	r4,0x2
8000c058:	5c 34       	neg	r4
8000c05a:	f8 05 01 45 	sbc	r5,r12,r5
8000c05e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c062:	e4 05 07 40 	macu.d	r0,r2,r5
8000c066:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c06a:	02 04       	add	r4,r1
8000c06c:	5c 05       	acr	r5
8000c06e:	ea 03 15 02 	lsl	r3,r5,0x2
8000c072:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c076:	e8 02 15 02 	lsl	r2,r4,0x2
8000c07a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c07e:	e4 09 07 40 	macu.d	r0,r2,r9
8000c082:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c086:	02 04       	add	r4,r1
8000c088:	5c 05       	acr	r5
8000c08a:	a3 65       	lsl	r5,0x2
8000c08c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c090:	a3 64       	lsl	r4,0x2
8000c092:	5c 34       	neg	r4
8000c094:	f8 05 01 45 	sbc	r5,r12,r5
8000c098:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c09c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c0a0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c0a4:	02 04       	add	r4,r1
8000c0a6:	5c 05       	acr	r5
8000c0a8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c0ac:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c0b0:	e8 02 15 02 	lsl	r2,r4,0x2
8000c0b4:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c0b8:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c0bc:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c0c0:	02 02       	add	r2,r1
8000c0c2:	5c 03       	acr	r3
8000c0c4:	ed b3 00 1c 	bld	r3,0x1c
8000c0c8:	c0 90       	breq	8000c0da <__avr32_f64_div+0x12a>
8000c0ca:	a1 72       	lsl	r2,0x1
8000c0cc:	5c f3       	rol	r3
8000c0ce:	20 17       	sub	r7,1
8000c0d0:	a3 9a       	lsr	r10,0x3
8000c0d2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c0d6:	a3 9b       	lsr	r11,0x3
8000c0d8:	c0 58       	rjmp	8000c0e2 <__avr32_f64_div+0x132>
8000c0da:	a5 8a       	lsr	r10,0x4
8000c0dc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c0e0:	a5 8b       	lsr	r11,0x4
8000c0e2:	58 07       	cp.w	r7,0
8000c0e4:	e0 8a 00 8b 	brle	8000c1fa <__avr32_f64_div_res_subnormal>
8000c0e8:	e0 12 ff 00 	andl	r2,0xff00
8000c0ec:	e8 12 00 80 	orl	r2,0x80
8000c0f0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c0f4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c0f8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c0fc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c100:	00 05       	add	r5,r0
8000c102:	f0 01 00 48 	adc	r8,r8,r1
8000c106:	5c 09       	acr	r9
8000c108:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c10c:	58 04       	cp.w	r4,0
8000c10e:	5c 25       	cpc	r5

8000c110 <__avr32_f64_div_round_subnormal>:
8000c110:	f4 08 13 00 	cpc	r8,r10
8000c114:	f6 09 13 00 	cpc	r9,r11
8000c118:	5f 36       	srlo	r6
8000c11a:	f8 06 17 00 	moveq	r6,r12
8000c11e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c122:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c126:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c12a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c12e:	ed be 00 1f 	bld	lr,0x1f
8000c132:	ef bb 00 1f 	bst	r11,0x1f
8000c136:	0c 0a       	add	r10,r6
8000c138:	5c 0b       	acr	r11
8000c13a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c13e:	e4 1b 00 0f 	andh	r11,0xf
8000c142:	14 4b       	or	r11,r10
8000c144:	e0 81 00 a7 	brne	8000c292 <__avr32_f64_div_res_subnormal+0x98>
8000c148:	f2 06 16 14 	lsr	r6,r9,0x14
8000c14c:	ab d6       	cbr	r6,0xb
8000c14e:	e0 46 07 ff 	cp.w	r6,2047
8000c152:	e0 81 00 a4 	brne	8000c29a <__avr32_f64_div_res_subnormal+0xa0>
8000c156:	c9 e8       	rjmp	8000c292 <__avr32_f64_div_res_subnormal+0x98>
8000c158:	e4 19 00 0f 	andh	r9,0xf
8000c15c:	10 49       	or	r9,r8
8000c15e:	e0 81 00 9a 	brne	8000c292 <__avr32_f64_div_res_subnormal+0x98>
8000c162:	c9 28       	rjmp	8000c286 <__avr32_f64_div_res_subnormal+0x8c>
8000c164:	a3 7b       	lsl	r11,0x3
8000c166:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c16a:	a3 7a       	lsl	r10,0x3
8000c16c:	f5 eb 10 04 	or	r4,r10,r11
8000c170:	e0 80 00 a0 	breq	8000c2b0 <__avr32_f64_div_op1_zero>
8000c174:	f6 04 12 00 	clz	r4,r11
8000c178:	c1 70       	breq	8000c1a6 <__avr32_f64_div_round_subnormal+0x96>
8000c17a:	c0 c3       	brcs	8000c192 <__avr32_f64_div_round_subnormal+0x82>
8000c17c:	e8 05 11 20 	rsub	r5,r4,32
8000c180:	f6 04 09 4b 	lsl	r11,r11,r4
8000c184:	f4 05 0a 45 	lsr	r5,r10,r5
8000c188:	0a 4b       	or	r11,r5
8000c18a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c18e:	08 17       	sub	r7,r4
8000c190:	c0 b8       	rjmp	8000c1a6 <__avr32_f64_div_round_subnormal+0x96>
8000c192:	f4 04 12 00 	clz	r4,r10
8000c196:	f9 b4 03 00 	movlo	r4,0
8000c19a:	f7 b4 02 e0 	subhs	r4,-32
8000c19e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c1a2:	30 0a       	mov	r10,0
8000c1a4:	08 17       	sub	r7,r4
8000c1a6:	a3 8a       	lsr	r10,0x2
8000c1a8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c1ac:	a3 8b       	lsr	r11,0x2
8000c1ae:	c1 1b       	rjmp	8000bfd0 <__avr32_f64_div+0x20>
8000c1b0:	a3 79       	lsl	r9,0x3
8000c1b2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c1b6:	a3 78       	lsl	r8,0x3
8000c1b8:	f3 e8 10 04 	or	r4,r9,r8
8000c1bc:	c6 f0       	breq	8000c29a <__avr32_f64_div_res_subnormal+0xa0>
8000c1be:	f2 04 12 00 	clz	r4,r9
8000c1c2:	c1 70       	breq	8000c1f0 <__avr32_f64_div_round_subnormal+0xe0>
8000c1c4:	c0 c3       	brcs	8000c1dc <__avr32_f64_div_round_subnormal+0xcc>
8000c1c6:	e8 05 11 20 	rsub	r5,r4,32
8000c1ca:	f2 04 09 49 	lsl	r9,r9,r4
8000c1ce:	f0 05 0a 45 	lsr	r5,r8,r5
8000c1d2:	0a 49       	or	r9,r5
8000c1d4:	f0 04 09 48 	lsl	r8,r8,r4
8000c1d8:	08 16       	sub	r6,r4
8000c1da:	c0 b8       	rjmp	8000c1f0 <__avr32_f64_div_round_subnormal+0xe0>
8000c1dc:	f0 04 12 00 	clz	r4,r8
8000c1e0:	f9 b4 03 00 	movlo	r4,0
8000c1e4:	f7 b4 02 e0 	subhs	r4,-32
8000c1e8:	f0 04 09 49 	lsl	r9,r8,r4
8000c1ec:	30 08       	mov	r8,0
8000c1ee:	08 16       	sub	r6,r4
8000c1f0:	a3 88       	lsr	r8,0x2
8000c1f2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c1f6:	a3 89       	lsr	r9,0x2
8000c1f8:	cf ca       	rjmp	8000bff0 <__avr32_f64_div+0x40>

8000c1fa <__avr32_f64_div_res_subnormal>:
8000c1fa:	5c 37       	neg	r7
8000c1fc:	2f f7       	sub	r7,-1
8000c1fe:	f1 b7 04 c0 	satu	r7,0x6
8000c202:	e0 47 00 20 	cp.w	r7,32
8000c206:	c1 54       	brge	8000c230 <__avr32_f64_div_res_subnormal+0x36>
8000c208:	ee 06 11 20 	rsub	r6,r7,32
8000c20c:	e4 07 0a 42 	lsr	r2,r2,r7
8000c210:	e6 06 09 4c 	lsl	r12,r3,r6
8000c214:	18 42       	or	r2,r12
8000c216:	e6 07 0a 43 	lsr	r3,r3,r7
8000c21a:	f4 06 09 41 	lsl	r1,r10,r6
8000c21e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c222:	f6 06 09 4c 	lsl	r12,r11,r6
8000c226:	18 4a       	or	r10,r12
8000c228:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c22c:	30 00       	mov	r0,0
8000c22e:	c1 58       	rjmp	8000c258 <__avr32_f64_div_res_subnormal+0x5e>
8000c230:	ee 06 11 20 	rsub	r6,r7,32
8000c234:	f9 b0 00 00 	moveq	r0,0
8000c238:	f9 bc 00 00 	moveq	r12,0
8000c23c:	c0 50       	breq	8000c246 <__avr32_f64_div_res_subnormal+0x4c>
8000c23e:	f4 06 09 40 	lsl	r0,r10,r6
8000c242:	f6 06 09 4c 	lsl	r12,r11,r6
8000c246:	e6 07 0a 42 	lsr	r2,r3,r7
8000c24a:	30 03       	mov	r3,0
8000c24c:	f4 07 0a 41 	lsr	r1,r10,r7
8000c250:	18 41       	or	r1,r12
8000c252:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c256:	30 0b       	mov	r11,0
8000c258:	e0 12 ff 00 	andl	r2,0xff00
8000c25c:	e8 12 00 80 	orl	r2,0x80
8000c260:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c264:	e4 09 07 46 	macu.d	r6,r2,r9
8000c268:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c26c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c270:	0c 05       	add	r5,r6
8000c272:	f0 07 00 48 	adc	r8,r8,r7
8000c276:	5c 09       	acr	r9
8000c278:	30 07       	mov	r7,0
8000c27a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c27e:	00 34       	cp.w	r4,r0
8000c280:	e2 05 13 00 	cpc	r5,r1
8000c284:	c4 6b       	rjmp	8000c110 <__avr32_f64_div_round_subnormal>
8000c286:	1c 9b       	mov	r11,lr
8000c288:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c28c:	30 0a       	mov	r10,0
8000c28e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c292:	3f fb       	mov	r11,-1
8000c294:	30 0a       	mov	r10,0
8000c296:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c29a:	f5 eb 10 04 	or	r4,r10,r11
8000c29e:	c0 90       	breq	8000c2b0 <__avr32_f64_div_op1_zero>
8000c2a0:	1c 9b       	mov	r11,lr
8000c2a2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c2a6:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c2aa:	30 0a       	mov	r10,0
8000c2ac:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c2b0 <__avr32_f64_div_op1_zero>:
8000c2b0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c2b4:	ce f0       	breq	8000c292 <__avr32_f64_div_res_subnormal+0x98>
8000c2b6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c2ba:	e0 44 07 ff 	cp.w	r4,2047
8000c2be:	ce 41       	brne	8000c286 <__avr32_f64_div_res_subnormal+0x8c>
8000c2c0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c2c4:	ce 10       	breq	8000c286 <__avr32_f64_div_res_subnormal+0x8c>
8000c2c6:	ce 6b       	rjmp	8000c292 <__avr32_f64_div_res_subnormal+0x98>

8000c2c8 <__avr32_udiv64>:
8000c2c8:	d4 31       	pushm	r0-r7,lr
8000c2ca:	1a 97       	mov	r7,sp
8000c2cc:	20 3d       	sub	sp,12
8000c2ce:	10 9c       	mov	r12,r8
8000c2d0:	12 9e       	mov	lr,r9
8000c2d2:	14 93       	mov	r3,r10
8000c2d4:	58 09       	cp.w	r9,0
8000c2d6:	e0 81 00 bd 	brne	8000c450 <__avr32_udiv64+0x188>
8000c2da:	16 38       	cp.w	r8,r11
8000c2dc:	e0 88 00 40 	brls	8000c35c <__avr32_udiv64+0x94>
8000c2e0:	f0 08 12 00 	clz	r8,r8
8000c2e4:	c0 d0       	breq	8000c2fe <__avr32_udiv64+0x36>
8000c2e6:	f6 08 09 4b 	lsl	r11,r11,r8
8000c2ea:	f0 09 11 20 	rsub	r9,r8,32
8000c2ee:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2f2:	f4 09 0a 49 	lsr	r9,r10,r9
8000c2f6:	f4 08 09 43 	lsl	r3,r10,r8
8000c2fa:	f3 eb 10 0b 	or	r11,r9,r11
8000c2fe:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c302:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c306:	f6 0e 0d 00 	divu	r0,r11,lr
8000c30a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c30e:	00 99       	mov	r9,r0
8000c310:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c314:	e0 0a 02 48 	mul	r8,r0,r10
8000c318:	10 3b       	cp.w	r11,r8
8000c31a:	c0 a2       	brcc	8000c32e <__avr32_udiv64+0x66>
8000c31c:	20 19       	sub	r9,1
8000c31e:	18 0b       	add	r11,r12
8000c320:	18 3b       	cp.w	r11,r12
8000c322:	c0 63       	brcs	8000c32e <__avr32_udiv64+0x66>
8000c324:	10 3b       	cp.w	r11,r8
8000c326:	f7 b9 03 01 	sublo	r9,1
8000c32a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c32e:	f6 08 01 01 	sub	r1,r11,r8
8000c332:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c336:	e2 0e 0d 00 	divu	r0,r1,lr
8000c33a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c33e:	00 98       	mov	r8,r0
8000c340:	e0 0a 02 4a 	mul	r10,r0,r10
8000c344:	14 33       	cp.w	r3,r10
8000c346:	c0 82       	brcc	8000c356 <__avr32_udiv64+0x8e>
8000c348:	20 18       	sub	r8,1
8000c34a:	18 03       	add	r3,r12
8000c34c:	18 33       	cp.w	r3,r12
8000c34e:	c0 43       	brcs	8000c356 <__avr32_udiv64+0x8e>
8000c350:	14 33       	cp.w	r3,r10
8000c352:	f7 b8 03 01 	sublo	r8,1
8000c356:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c35a:	cd f8       	rjmp	8000c518 <__avr32_udiv64+0x250>
8000c35c:	58 08       	cp.w	r8,0
8000c35e:	c0 51       	brne	8000c368 <__avr32_udiv64+0xa0>
8000c360:	30 19       	mov	r9,1
8000c362:	f2 08 0d 08 	divu	r8,r9,r8
8000c366:	10 9c       	mov	r12,r8
8000c368:	f8 06 12 00 	clz	r6,r12
8000c36c:	c0 41       	brne	8000c374 <__avr32_udiv64+0xac>
8000c36e:	18 1b       	sub	r11,r12
8000c370:	30 19       	mov	r9,1
8000c372:	c4 08       	rjmp	8000c3f2 <__avr32_udiv64+0x12a>
8000c374:	ec 01 11 20 	rsub	r1,r6,32
8000c378:	f4 01 0a 49 	lsr	r9,r10,r1
8000c37c:	f8 06 09 4c 	lsl	r12,r12,r6
8000c380:	f6 06 09 48 	lsl	r8,r11,r6
8000c384:	f6 01 0a 41 	lsr	r1,r11,r1
8000c388:	f3 e8 10 08 	or	r8,r9,r8
8000c38c:	f8 03 16 10 	lsr	r3,r12,0x10
8000c390:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c394:	e2 03 0d 00 	divu	r0,r1,r3
8000c398:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c39c:	00 9e       	mov	lr,r0
8000c39e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c3a2:	e0 05 02 49 	mul	r9,r0,r5
8000c3a6:	12 3b       	cp.w	r11,r9
8000c3a8:	c0 a2       	brcc	8000c3bc <__avr32_udiv64+0xf4>
8000c3aa:	20 1e       	sub	lr,1
8000c3ac:	18 0b       	add	r11,r12
8000c3ae:	18 3b       	cp.w	r11,r12
8000c3b0:	c0 63       	brcs	8000c3bc <__avr32_udiv64+0xf4>
8000c3b2:	12 3b       	cp.w	r11,r9
8000c3b4:	f7 be 03 01 	sublo	lr,1
8000c3b8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c3bc:	12 1b       	sub	r11,r9
8000c3be:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c3c2:	f6 03 0d 02 	divu	r2,r11,r3
8000c3c6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c3ca:	04 99       	mov	r9,r2
8000c3cc:	e4 05 02 4b 	mul	r11,r2,r5
8000c3d0:	16 38       	cp.w	r8,r11
8000c3d2:	c0 a2       	brcc	8000c3e6 <__avr32_udiv64+0x11e>
8000c3d4:	20 19       	sub	r9,1
8000c3d6:	18 08       	add	r8,r12
8000c3d8:	18 38       	cp.w	r8,r12
8000c3da:	c0 63       	brcs	8000c3e6 <__avr32_udiv64+0x11e>
8000c3dc:	16 38       	cp.w	r8,r11
8000c3de:	f7 b9 03 01 	sublo	r9,1
8000c3e2:	f1 dc e3 08 	addcs	r8,r8,r12
8000c3e6:	f4 06 09 43 	lsl	r3,r10,r6
8000c3ea:	f0 0b 01 0b 	sub	r11,r8,r11
8000c3ee:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c3f2:	f8 06 16 10 	lsr	r6,r12,0x10
8000c3f6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c3fa:	f6 06 0d 00 	divu	r0,r11,r6
8000c3fe:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c402:	00 9a       	mov	r10,r0
8000c404:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c408:	e0 0e 02 48 	mul	r8,r0,lr
8000c40c:	10 3b       	cp.w	r11,r8
8000c40e:	c0 a2       	brcc	8000c422 <__avr32_udiv64+0x15a>
8000c410:	20 1a       	sub	r10,1
8000c412:	18 0b       	add	r11,r12
8000c414:	18 3b       	cp.w	r11,r12
8000c416:	c0 63       	brcs	8000c422 <__avr32_udiv64+0x15a>
8000c418:	10 3b       	cp.w	r11,r8
8000c41a:	f7 ba 03 01 	sublo	r10,1
8000c41e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c422:	f6 08 01 01 	sub	r1,r11,r8
8000c426:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c42a:	e2 06 0d 00 	divu	r0,r1,r6
8000c42e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c432:	00 98       	mov	r8,r0
8000c434:	e0 0e 02 4b 	mul	r11,r0,lr
8000c438:	16 33       	cp.w	r3,r11
8000c43a:	c0 82       	brcc	8000c44a <__avr32_udiv64+0x182>
8000c43c:	20 18       	sub	r8,1
8000c43e:	18 03       	add	r3,r12
8000c440:	18 33       	cp.w	r3,r12
8000c442:	c0 43       	brcs	8000c44a <__avr32_udiv64+0x182>
8000c444:	16 33       	cp.w	r3,r11
8000c446:	f7 b8 03 01 	sublo	r8,1
8000c44a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c44e:	c6 98       	rjmp	8000c520 <__avr32_udiv64+0x258>
8000c450:	16 39       	cp.w	r9,r11
8000c452:	e0 8b 00 65 	brhi	8000c51c <__avr32_udiv64+0x254>
8000c456:	f2 09 12 00 	clz	r9,r9
8000c45a:	c0 b1       	brne	8000c470 <__avr32_udiv64+0x1a8>
8000c45c:	10 3a       	cp.w	r10,r8
8000c45e:	5f 2a       	srhs	r10
8000c460:	1c 3b       	cp.w	r11,lr
8000c462:	5f b8       	srhi	r8
8000c464:	10 4a       	or	r10,r8
8000c466:	f2 0a 18 00 	cp.b	r10,r9
8000c46a:	c5 90       	breq	8000c51c <__avr32_udiv64+0x254>
8000c46c:	30 18       	mov	r8,1
8000c46e:	c5 98       	rjmp	8000c520 <__avr32_udiv64+0x258>
8000c470:	f0 09 09 46 	lsl	r6,r8,r9
8000c474:	f2 03 11 20 	rsub	r3,r9,32
8000c478:	fc 09 09 4e 	lsl	lr,lr,r9
8000c47c:	f0 03 0a 48 	lsr	r8,r8,r3
8000c480:	f6 09 09 4c 	lsl	r12,r11,r9
8000c484:	f4 03 0a 42 	lsr	r2,r10,r3
8000c488:	ef 46 ff f4 	st.w	r7[-12],r6
8000c48c:	f6 03 0a 43 	lsr	r3,r11,r3
8000c490:	18 42       	or	r2,r12
8000c492:	f1 ee 10 0c 	or	r12,r8,lr
8000c496:	f8 01 16 10 	lsr	r1,r12,0x10
8000c49a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c49e:	e6 01 0d 04 	divu	r4,r3,r1
8000c4a2:	e4 03 16 10 	lsr	r3,r2,0x10
8000c4a6:	08 9e       	mov	lr,r4
8000c4a8:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c4ac:	e8 06 02 48 	mul	r8,r4,r6
8000c4b0:	10 33       	cp.w	r3,r8
8000c4b2:	c0 a2       	brcc	8000c4c6 <__avr32_udiv64+0x1fe>
8000c4b4:	20 1e       	sub	lr,1
8000c4b6:	18 03       	add	r3,r12
8000c4b8:	18 33       	cp.w	r3,r12
8000c4ba:	c0 63       	brcs	8000c4c6 <__avr32_udiv64+0x1fe>
8000c4bc:	10 33       	cp.w	r3,r8
8000c4be:	f7 be 03 01 	sublo	lr,1
8000c4c2:	e7 dc e3 03 	addcs	r3,r3,r12
8000c4c6:	10 13       	sub	r3,r8
8000c4c8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c4cc:	e6 01 0d 00 	divu	r0,r3,r1
8000c4d0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c4d4:	00 98       	mov	r8,r0
8000c4d6:	e0 06 02 46 	mul	r6,r0,r6
8000c4da:	0c 3b       	cp.w	r11,r6
8000c4dc:	c0 a2       	brcc	8000c4f0 <__avr32_udiv64+0x228>
8000c4de:	20 18       	sub	r8,1
8000c4e0:	18 0b       	add	r11,r12
8000c4e2:	18 3b       	cp.w	r11,r12
8000c4e4:	c0 63       	brcs	8000c4f0 <__avr32_udiv64+0x228>
8000c4e6:	0c 3b       	cp.w	r11,r6
8000c4e8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c4ec:	f7 b8 03 01 	sublo	r8,1
8000c4f0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c4f4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c4f8:	0c 1b       	sub	r11,r6
8000c4fa:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c4fe:	06 95       	mov	r5,r3
8000c500:	16 35       	cp.w	r5,r11
8000c502:	e0 8b 00 0a 	brhi	8000c516 <__avr32_udiv64+0x24e>
8000c506:	5f 0b       	sreq	r11
8000c508:	f4 09 09 49 	lsl	r9,r10,r9
8000c50c:	12 32       	cp.w	r2,r9
8000c50e:	5f b9       	srhi	r9
8000c510:	f7 e9 00 09 	and	r9,r11,r9
8000c514:	c0 60       	breq	8000c520 <__avr32_udiv64+0x258>
8000c516:	20 18       	sub	r8,1
8000c518:	30 09       	mov	r9,0
8000c51a:	c0 38       	rjmp	8000c520 <__avr32_udiv64+0x258>
8000c51c:	30 09       	mov	r9,0
8000c51e:	12 98       	mov	r8,r9
8000c520:	10 9a       	mov	r10,r8
8000c522:	12 93       	mov	r3,r9
8000c524:	10 92       	mov	r2,r8
8000c526:	12 9b       	mov	r11,r9
8000c528:	2f dd       	sub	sp,-12
8000c52a:	d8 32       	popm	r0-r7,pc

8000c52c <__avr32_umod64>:
8000c52c:	d4 31       	pushm	r0-r7,lr
8000c52e:	1a 97       	mov	r7,sp
8000c530:	20 3d       	sub	sp,12
8000c532:	10 9c       	mov	r12,r8
8000c534:	12 95       	mov	r5,r9
8000c536:	14 9e       	mov	lr,r10
8000c538:	16 91       	mov	r1,r11
8000c53a:	16 96       	mov	r6,r11
8000c53c:	58 09       	cp.w	r9,0
8000c53e:	e0 81 00 81 	brne	8000c640 <__avr32_umod64+0x114>
8000c542:	16 38       	cp.w	r8,r11
8000c544:	e0 88 00 12 	brls	8000c568 <__avr32_umod64+0x3c>
8000c548:	f0 08 12 00 	clz	r8,r8
8000c54c:	c4 e0       	breq	8000c5e8 <__avr32_umod64+0xbc>
8000c54e:	f6 08 09 46 	lsl	r6,r11,r8
8000c552:	f8 08 09 4c 	lsl	r12,r12,r8
8000c556:	f0 0b 11 20 	rsub	r11,r8,32
8000c55a:	f4 08 09 4e 	lsl	lr,r10,r8
8000c55e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c562:	f7 e6 10 06 	or	r6,r11,r6
8000c566:	c4 18       	rjmp	8000c5e8 <__avr32_umod64+0xbc>
8000c568:	58 08       	cp.w	r8,0
8000c56a:	c0 51       	brne	8000c574 <__avr32_umod64+0x48>
8000c56c:	30 19       	mov	r9,1
8000c56e:	f2 08 0d 08 	divu	r8,r9,r8
8000c572:	10 9c       	mov	r12,r8
8000c574:	f8 08 12 00 	clz	r8,r12
8000c578:	c0 31       	brne	8000c57e <__avr32_umod64+0x52>
8000c57a:	18 16       	sub	r6,r12
8000c57c:	c3 68       	rjmp	8000c5e8 <__avr32_umod64+0xbc>
8000c57e:	f0 03 11 20 	rsub	r3,r8,32
8000c582:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c586:	f8 08 09 4c 	lsl	r12,r12,r8
8000c58a:	ec 08 09 49 	lsl	r9,r6,r8
8000c58e:	ec 03 0a 43 	lsr	r3,r6,r3
8000c592:	f7 e9 10 09 	or	r9,r11,r9
8000c596:	f8 05 16 10 	lsr	r5,r12,0x10
8000c59a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c59e:	e6 05 0d 02 	divu	r2,r3,r5
8000c5a2:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c5a6:	ec 02 02 4b 	mul	r11,r6,r2
8000c5aa:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c5ae:	16 3e       	cp.w	lr,r11
8000c5b0:	c0 72       	brcc	8000c5be <__avr32_umod64+0x92>
8000c5b2:	18 0e       	add	lr,r12
8000c5b4:	18 3e       	cp.w	lr,r12
8000c5b6:	c0 43       	brcs	8000c5be <__avr32_umod64+0x92>
8000c5b8:	16 3e       	cp.w	lr,r11
8000c5ba:	fd dc e3 0e 	addcs	lr,lr,r12
8000c5be:	fc 0b 01 03 	sub	r3,lr,r11
8000c5c2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c5c6:	e6 05 0d 02 	divu	r2,r3,r5
8000c5ca:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c5ce:	a5 36       	mul	r6,r2
8000c5d0:	0c 39       	cp.w	r9,r6
8000c5d2:	c0 72       	brcc	8000c5e0 <__avr32_umod64+0xb4>
8000c5d4:	18 09       	add	r9,r12
8000c5d6:	18 39       	cp.w	r9,r12
8000c5d8:	c0 43       	brcs	8000c5e0 <__avr32_umod64+0xb4>
8000c5da:	0c 39       	cp.w	r9,r6
8000c5dc:	f3 dc e3 09 	addcs	r9,r9,r12
8000c5e0:	f2 06 01 06 	sub	r6,r9,r6
8000c5e4:	f4 08 09 4e 	lsl	lr,r10,r8
8000c5e8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c5ec:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c5f0:	ec 0a 0d 02 	divu	r2,r6,r10
8000c5f4:	fc 09 16 10 	lsr	r9,lr,0x10
8000c5f8:	ea 02 02 4b 	mul	r11,r5,r2
8000c5fc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c600:	16 39       	cp.w	r9,r11
8000c602:	c0 72       	brcc	8000c610 <__avr32_umod64+0xe4>
8000c604:	18 09       	add	r9,r12
8000c606:	18 39       	cp.w	r9,r12
8000c608:	c0 43       	brcs	8000c610 <__avr32_umod64+0xe4>
8000c60a:	16 39       	cp.w	r9,r11
8000c60c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c610:	f2 0b 01 0b 	sub	r11,r9,r11
8000c614:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c618:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c61c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c620:	ea 0a 02 4a 	mul	r10,r5,r10
8000c624:	14 3e       	cp.w	lr,r10
8000c626:	c0 72       	brcc	8000c634 <__avr32_umod64+0x108>
8000c628:	18 0e       	add	lr,r12
8000c62a:	18 3e       	cp.w	lr,r12
8000c62c:	c0 43       	brcs	8000c634 <__avr32_umod64+0x108>
8000c62e:	14 3e       	cp.w	lr,r10
8000c630:	fd dc e3 0e 	addcs	lr,lr,r12
8000c634:	fc 0a 01 0a 	sub	r10,lr,r10
8000c638:	30 0b       	mov	r11,0
8000c63a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c63e:	c7 b8       	rjmp	8000c734 <__avr32_umod64+0x208>
8000c640:	16 39       	cp.w	r9,r11
8000c642:	e0 8b 00 79 	brhi	8000c734 <__avr32_umod64+0x208>
8000c646:	f2 09 12 00 	clz	r9,r9
8000c64a:	c1 21       	brne	8000c66e <__avr32_umod64+0x142>
8000c64c:	10 3a       	cp.w	r10,r8
8000c64e:	5f 2b       	srhs	r11
8000c650:	0a 31       	cp.w	r1,r5
8000c652:	5f ba       	srhi	r10
8000c654:	f7 ea 10 0a 	or	r10,r11,r10
8000c658:	f2 0a 18 00 	cp.b	r10,r9
8000c65c:	c0 60       	breq	8000c668 <__avr32_umod64+0x13c>
8000c65e:	fc 08 01 0c 	sub	r12,lr,r8
8000c662:	e2 05 01 46 	sbc	r6,r1,r5
8000c666:	18 9e       	mov	lr,r12
8000c668:	0c 9b       	mov	r11,r6
8000c66a:	1c 9a       	mov	r10,lr
8000c66c:	c6 48       	rjmp	8000c734 <__avr32_umod64+0x208>
8000c66e:	ea 09 09 4c 	lsl	r12,r5,r9
8000c672:	f2 06 11 20 	rsub	r6,r9,32
8000c676:	f6 09 09 4b 	lsl	r11,r11,r9
8000c67a:	f0 09 09 42 	lsl	r2,r8,r9
8000c67e:	ef 46 ff f4 	st.w	r7[-12],r6
8000c682:	f0 06 0a 48 	lsr	r8,r8,r6
8000c686:	18 48       	or	r8,r12
8000c688:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c68c:	f4 09 09 43 	lsl	r3,r10,r9
8000c690:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c694:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c698:	16 4a       	or	r10,r11
8000c69a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c69e:	f8 0b 0d 04 	divu	r4,r12,r11
8000c6a2:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c6a6:	08 91       	mov	r1,r4
8000c6a8:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c6ac:	e8 0e 02 46 	mul	r6,r4,lr
8000c6b0:	0c 3c       	cp.w	r12,r6
8000c6b2:	c0 a2       	brcc	8000c6c6 <__avr32_umod64+0x19a>
8000c6b4:	20 11       	sub	r1,1
8000c6b6:	10 0c       	add	r12,r8
8000c6b8:	10 3c       	cp.w	r12,r8
8000c6ba:	c0 63       	brcs	8000c6c6 <__avr32_umod64+0x19a>
8000c6bc:	0c 3c       	cp.w	r12,r6
8000c6be:	f7 b1 03 01 	sublo	r1,1
8000c6c2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c6c6:	0c 1c       	sub	r12,r6
8000c6c8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c6cc:	f8 0b 0d 04 	divu	r4,r12,r11
8000c6d0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c6d4:	08 96       	mov	r6,r4
8000c6d6:	e8 0e 02 4e 	mul	lr,r4,lr
8000c6da:	1c 3b       	cp.w	r11,lr
8000c6dc:	c0 a2       	brcc	8000c6f0 <__avr32_umod64+0x1c4>
8000c6de:	20 16       	sub	r6,1
8000c6e0:	10 0b       	add	r11,r8
8000c6e2:	10 3b       	cp.w	r11,r8
8000c6e4:	c0 63       	brcs	8000c6f0 <__avr32_umod64+0x1c4>
8000c6e6:	1c 3b       	cp.w	r11,lr
8000c6e8:	f7 b6 03 01 	sublo	r6,1
8000c6ec:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c6f0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c6f4:	1c 1b       	sub	r11,lr
8000c6f6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c6fa:	00 9e       	mov	lr,r0
8000c6fc:	02 9c       	mov	r12,r1
8000c6fe:	16 3c       	cp.w	r12,r11
8000c700:	e0 8b 00 08 	brhi	8000c710 <__avr32_umod64+0x1e4>
8000c704:	5f 06       	sreq	r6
8000c706:	06 30       	cp.w	r0,r3
8000c708:	5f ba       	srhi	r10
8000c70a:	ed ea 00 0a 	and	r10,r6,r10
8000c70e:	c0 60       	breq	8000c71a <__avr32_umod64+0x1ee>
8000c710:	fc 02 01 04 	sub	r4,lr,r2
8000c714:	f8 08 01 4c 	sbc	r12,r12,r8
8000c718:	08 9e       	mov	lr,r4
8000c71a:	e6 0e 01 0a 	sub	r10,r3,lr
8000c71e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c722:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c726:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c72a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c72e:	f8 01 09 4c 	lsl	r12,r12,r1
8000c732:	18 4a       	or	r10,r12
8000c734:	2f dd       	sub	sp,-12
8000c736:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c800 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c800:	c0 08       	rjmp	8000c800 <_evba>
	...

8000c804 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c804:	c0 08       	rjmp	8000c804 <_handle_TLB_Multiple_Hit>
	...

8000c808 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c808:	c0 08       	rjmp	8000c808 <_handle_Bus_Error_Data_Fetch>
	...

8000c80c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c80c:	c0 08       	rjmp	8000c80c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c810 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c810:	c0 08       	rjmp	8000c810 <_handle_NMI>
	...

8000c814 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c814:	c0 08       	rjmp	8000c814 <_handle_Instruction_Address>
	...

8000c818 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c818:	c0 08       	rjmp	8000c818 <_handle_ITLB_Protection>
	...

8000c81c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c81c:	c0 08       	rjmp	8000c81c <_handle_Breakpoint>
	...

8000c820 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c820:	c0 08       	rjmp	8000c820 <_handle_Illegal_Opcode>
	...

8000c824 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c824:	c0 08       	rjmp	8000c824 <_handle_Unimplemented_Instruction>
	...

8000c828 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c828:	c0 08       	rjmp	8000c828 <_handle_Privilege_Violation>
	...

8000c82c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c82c:	c0 08       	rjmp	8000c82c <_handle_Floating_Point>
	...

8000c830 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c830:	c0 08       	rjmp	8000c830 <_handle_Coprocessor_Absent>
	...

8000c834 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c834:	c0 08       	rjmp	8000c834 <_handle_Data_Address_Read>
	...

8000c838 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c838:	c0 08       	rjmp	8000c838 <_handle_Data_Address_Write>
	...

8000c83c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c83c:	c0 08       	rjmp	8000c83c <_handle_DTLB_Protection_Read>
	...

8000c840 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c840:	c0 08       	rjmp	8000c840 <_handle_DTLB_Protection_Write>
	...

8000c844 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c844:	c0 08       	rjmp	8000c844 <_handle_DTLB_Modified>
	...

8000c850 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c850:	c0 08       	rjmp	8000c850 <_handle_ITLB_Miss>
	...

8000c860 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c860:	c0 08       	rjmp	8000c860 <_handle_DTLB_Miss_Read>
	...

8000c870 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c870:	c0 08       	rjmp	8000c870 <_handle_DTLB_Miss_Write>
	...

8000c900 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c900:	fe cf 70 58 	sub	pc,pc,28760

8000c904 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c904:	30 0c       	mov	r12,0
8000c906:	fe b0 c4 a9 	rcall	80005258 <_get_interrupt_handler>
8000c90a:	58 0c       	cp.w	r12,0
8000c90c:	f8 0f 17 10 	movne	pc,r12
8000c910:	d6 03       	rete

8000c912 <_int1>:
8000c912:	30 1c       	mov	r12,1
8000c914:	fe b0 c4 a2 	rcall	80005258 <_get_interrupt_handler>
8000c918:	58 0c       	cp.w	r12,0
8000c91a:	f8 0f 17 10 	movne	pc,r12
8000c91e:	d6 03       	rete

8000c920 <_int2>:
8000c920:	30 2c       	mov	r12,2
8000c922:	fe b0 c4 9b 	rcall	80005258 <_get_interrupt_handler>
8000c926:	58 0c       	cp.w	r12,0
8000c928:	f8 0f 17 10 	movne	pc,r12
8000c92c:	d6 03       	rete

8000c92e <_int3>:
8000c92e:	30 3c       	mov	r12,3
8000c930:	fe b0 c4 94 	rcall	80005258 <_get_interrupt_handler>
8000c934:	58 0c       	cp.w	r12,0
8000c936:	f8 0f 17 10 	movne	pc,r12
8000c93a:	d6 03       	rete

8000c93c <ipr_val>:
8000c93c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c94c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c95c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c96c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c97c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c98c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c99c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c9fc:	d7 03 d7 03                                         ....
