
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000aac4  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001290  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a30  00000004  8000e090  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a34  8000eac0  0000f234  2**0
                  ALLOC
  7 .bss          0000ac48  00000a38  8000eac0  0000f238  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f234  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001680  00000000  00000000  0000f268  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000364b  00000000  00000000  000108e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c4c6  00000000  00000000  00013f33  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000072c8  00000000  00000000  000403f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d3bf  00000000  00000000  000476c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003cf0  00000000  00000000  00054a80  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00008001  00000000  00000000  00058770  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f16e  00000000  00000000  00060771  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001748  00000000  00000000  0006f8e0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c5 9c 	sub	pc,pc,-14948

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	f8 c8 ff fe 	sub	r8,r12,-2
void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
80002008:	f1 2a 00 01 	ld.sb	r10,r8[1]
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
8000200c:	48 c9       	lddpc	r9,8000203c <DeviceManagement_brdcst_func+0x38>
8000200e:	92 39       	ld.sh	r9,r9[0x6]
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
		temp |= ptr->XCMP_Device_ID;
80002010:	11 a8       	ld.ub	r8,r8[0x2]
80002012:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002016:	f0 09 19 00 	cp.h	r9,r8
8000201a:	5e 1c       	retne	r12
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
		{
			if (xcmp->u8[0] == 0x01)
8000201c:	19 a9       	ld.ub	r9,r12[0x2]
8000201e:	30 18       	mov	r8,1
80002020:	f0 09 18 00 	cp.b	r9,r8
80002024:	c0 61       	brne	80002030 <DeviceManagement_brdcst_func+0x2c>
			//if(ptr->Function == Start)
			{
				//Enable Option Board
				bunchofrandomstatusflags |= 0x00000002;
80002026:	48 78       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002028:	70 09       	ld.w	r9,r8[0x0]
8000202a:	a1 b9       	sbr	r9,0x1
8000202c:	91 09       	st.w	r8[0x0],r9
8000202e:	5e fc       	retal	r12
			}
			else
			{
				//Disable Option Board.
				//log("Device State : %d\n", );
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002030:	48 48       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	a1 d9       	cbr	r9,0x1
80002036:	91 09       	st.w	r8[0x0],r9
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	97 04       	st.w	r11[0x0],r4
80002040:	00 00       	add	r0,r0
80002042:	0d 80       	ld.ub	r0,r6[0x0]

80002044 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002044:	5e fc       	retal	r12

80002046 <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002046:	5e fc       	retal	r12

80002048 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002048:	48 38       	lddpc	r8,80002054 <vApplicationIdleHook+0xc>
8000204a:	70 09       	ld.w	r9,r8[0x0]
8000204c:	2f f9       	sub	r9,-1
8000204e:	91 09       	st.w	r8[0x0],r9
	
}
80002050:	5e fc       	retal	r12
80002052:	00 00       	add	r0,r0
80002054:	00 00       	add	r0,r0
80002056:	0a 58       	eor	r8,r5

80002058 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002058:	d4 01       	pushm	lr
  log("R");
8000205a:	48 3c       	lddpc	r12,80002064 <app_payload_tx_proc+0xc>
8000205c:	f0 1f 00 03 	mcall	80002068 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002060:	d8 02       	popm	pc
80002062:	00 00       	add	r0,r0
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	ce 00       	breq	80002026 <DeviceManagement_brdcst_func+0x22>
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	6d c0       	ld.w	r0,r6[0x70]

8000206c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000206c:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000206e:	48 99       	lddpc	r9,80002090 <app_payload_rx_proc+0x24>
80002070:	13 88       	ld.ub	r8,r9[0x0]
80002072:	2f f8       	sub	r8,-1
80002074:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002076:	30 39       	mov	r9,3
80002078:	f2 08 18 00 	cp.b	r8,r9
8000207c:	c0 71       	brne	8000208a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000207e:	30 09       	mov	r9,0
80002080:	48 48       	lddpc	r8,80002090 <app_payload_rx_proc+0x24>
80002082:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002084:	48 4c       	lddpc	r12,80002094 <app_payload_rx_proc+0x28>
80002086:	f0 1f 00 05 	mcall	80002098 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000208a:	48 58       	lddpc	r8,8000209c <app_payload_rx_proc+0x30>
8000208c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000208e:	d8 02       	popm	pc
80002090:	00 00       	add	r0,r0
80002092:	0a 54       	eor	r4,r5
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	ce 04       	brge	80002056 <vApplicationIdleHook+0xe>
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	6d c0       	ld.w	r0,r6[0x70]
8000209c:	00 00       	add	r0,r0
8000209e:	0a 40       	or	r0,r5

800020a0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a2:	48 3c       	lddpc	r12,800020ac <FD_brdcst_func+0xc>
800020a4:	f0 1f 00 03 	mcall	800020b0 <FD_brdcst_func+0x10>
	
}
800020a8:	d8 02       	popm	pc
800020aa:	00 00       	add	r0,r0
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	ce 10       	breq	80002070 <app_payload_rx_proc+0x4>
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	6d c0       	ld.w	r0,r6[0x70]

800020b4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b6:	48 3c       	lddpc	r12,800020c0 <FD_reply_func+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <FD_reply_func+0x10>
	
	
}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	ce 30       	breq	80002088 <app_payload_rx_proc+0x1c>
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	6d c0       	ld.w	r0,r6[0x70]

800020c8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ca:	48 3c       	lddpc	r12,800020d4 <FD_request_func+0xc>
800020cc:	f0 1f 00 03 	mcall	800020d8 <FD_request_func+0x10>
	
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	ce 4c       	rcall	8000229e <ButtonConfig_reply_func+0x16>
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	6d c0       	ld.w	r0,r6[0x70]

800020dc <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020dc:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020de:	48 3c       	lddpc	r12,800020e8 <EnOB_brdcst_func+0xc>
800020e0:	f0 1f 00 03 	mcall	800020ec <EnOB_brdcst_func+0x10>
}
800020e4:	d8 02       	popm	pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	ce 68       	rjmp	800022b6 <ButtonConfig_reply_func+0x2e>
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	6d c0       	ld.w	r0,r6[0x70]

800020f0 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f6:	19 a9       	ld.ub	r9,r12[0x2]
800020f8:	30 08       	mov	r8,0
800020fa:	f0 09 18 00 	cp.b	r9,r8
800020fe:	c1 91       	brne	80002130 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002100:	19 b8       	ld.ub	r8,r12[0x3]
80002102:	30 19       	mov	r9,1
80002104:	f2 08 18 00 	cp.b	r8,r9
80002108:	c0 61       	brne	80002114 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210a:	49 0c       	lddpc	r12,80002148 <EnOB_reply_func+0x58>
8000210c:	f0 1f 00 10 	mcall	8000214c <EnOB_reply_func+0x5c>
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002114:	58 08       	cp.w	r8,0
80002116:	c0 61       	brne	80002122 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002118:	48 ec       	lddpc	r12,80002150 <EnOB_reply_func+0x60>
8000211a:	f0 1f 00 0d 	mcall	8000214c <EnOB_reply_func+0x5c>
8000211e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002122:	1a d8       	st.w	--sp,r8
80002124:	48 cc       	lddpc	r12,80002154 <EnOB_reply_func+0x64>
80002126:	f0 1f 00 0a 	mcall	8000214c <EnOB_reply_func+0x5c>
8000212a:	2f fd       	sub	sp,-4
8000212c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002130:	48 ac       	lddpc	r12,80002158 <EnOB_reply_func+0x68>
80002132:	f0 1f 00 07 	mcall	8000214c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002136:	0f a8       	ld.ub	r8,r7[0x2]
80002138:	1a d8       	st.w	--sp,r8
8000213a:	48 9c       	lddpc	r12,8000215c <EnOB_reply_func+0x6c>
8000213c:	f0 1f 00 04 	mcall	8000214c <EnOB_reply_func+0x5c>
80002140:	2f fd       	sub	sp,-4
80002142:	e3 cd 80 80 	ldm	sp++,r7,pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	ce 80       	breq	8000211a <EnOB_reply_func+0x2a>
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	6d c0       	ld.w	r0,r6[0x70]
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ce 98       	rjmp	80002324 <ShutDown_brdcst_func+0x28>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	ce ac       	rcall	8000232a <ShutDown_brdcst_func+0x2e>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ce c4       	brge	80002132 <EnOB_reply_func+0x42>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	ce e0       	breq	8000213a <EnOB_reply_func+0x4a>

80002160 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 91       	brne	80002180 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 ac       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x38>
80002172:	f0 1f 00 0b 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
80002176:	30 19       	mov	r9,1
80002178:	48 a8       	lddpc	r8,800021a0 <SingleDetection_brdcst_func+0x40>
8000217a:	b0 89       	st.b	r8[0x0],r9
8000217c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002180:	48 9c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x44>
80002182:	f0 1f 00 07 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
80002186:	0f a8       	ld.ub	r8,r7[0x2]
80002188:	1a d8       	st.w	--sp,r8
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x48>
8000218c:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
80002190:	2f fd       	sub	sp,-4
80002192:	e3 cd 80 80 	ldm	sp++,r7,pc
80002196:	00 00       	add	r0,r0
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	ce f8       	rjmp	80002378 <DataSession_reply_func+0x4c>
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	6d c0       	ld.w	r0,r6[0x70]
800021a0:	00 00       	add	r0,r0
800021a2:	00 04       	add	r4,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	cf 0c       	rcall	80002386 <DataSession_reply_func+0x5a>
800021a8:	80 00       	ld.sh	r0,r0[0x0]
800021aa:	cf 1c       	rcall	8000238c <CallControl_brdcst_func+0x4>

800021ac <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ac:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ae:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b4:	4a bc       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xb4>
800021b6:	f0 1f 00 2c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021ba:	0f 88       	ld.ub	r8,r7[0x0]
800021bc:	1a d8       	st.w	--sp,r8
800021be:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xbc>
800021c0:	f0 1f 00 29 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c4:	1a d5       	st.w	--sp,r5
800021c6:	4a ac       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc0>
800021c8:	f0 1f 00 27 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021cc:	0f a8       	ld.ub	r8,r7[0x2]
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	4a 8c       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc4>
800021d2:	f0 1f 00 25 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d6:	2f dd       	sub	sp,-12
800021d8:	58 05       	cp.w	r5,0
800021da:	c4 10       	breq	8000225c <ButtonConfig_brdcst_func+0xb0>
800021dc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021de:	4a 64       	lddpc	r4,80002274 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e0:	4a 63       	lddpc	r3,80002278 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e2:	4a 72       	lddpc	r2,8000227c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e4:	4a 71       	lddpc	r1,80002280 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e6:	4a 80       	lddpc	r0,80002284 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e8:	0f b9       	ld.ub	r9,r7[0x3]
800021ea:	0f c8       	ld.ub	r8,r7[0x4]
800021ec:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f0:	1a d8       	st.w	--sp,r8
800021f2:	1a d6       	st.w	--sp,r6
800021f4:	08 9c       	mov	r12,r4
800021f6:	f0 1f 00 1c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fa:	0f d9       	ld.ub	r9,r7[0x5]
800021fc:	0f e8       	ld.ub	r8,r7[0x6]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	06 9c       	mov	r12,r3
80002208:	f0 1f 00 17 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000220c:	0f f9       	ld.ub	r9,r7[0x7]
8000220e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002212:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002216:	1a d8       	st.w	--sp,r8
80002218:	1a d6       	st.w	--sp,r6
8000221a:	04 9c       	mov	r12,r2
8000221c:	f0 1f 00 12 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002220:	ef 39 00 09 	ld.ub	r9,r7[9]
80002224:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002228:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	1a d6       	st.w	--sp,r6
80002230:	02 9c       	mov	r12,r1
80002232:	f0 1f 00 0d 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002236:	2f 8d       	sub	sp,-32
80002238:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000223c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002240:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002244:	1a d8       	st.w	--sp,r8
80002246:	1a d6       	st.w	--sp,r6
80002248:	00 9c       	mov	r12,r0
8000224a:	f0 1f 00 07 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
8000224e:	2f f6       	sub	r6,-1
80002250:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002252:	2f ed       	sub	sp,-8
80002254:	ec 05 18 00 	cp.b	r5,r6
80002258:	fe 9b ff c8 	brhi	800021e8 <ButtonConfig_brdcst_func+0x3c>
8000225c:	d8 32       	popm	r0-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	cf 30       	breq	80002248 <ButtonConfig_brdcst_func+0x9c>
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	6d c0       	ld.w	r0,r6[0x70]
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	cf 50       	breq	80002254 <ButtonConfig_brdcst_func+0xa8>
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	cf 64       	brge	8000225a <ButtonConfig_brdcst_func+0xae>
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	cf 7c       	rcall	80002460 <TransmitControl_reply_func+0x4c>
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	cf 9c       	rcall	80002468 <TransmitControl_reply_func+0x54>
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	cf c4       	brge	80002272 <ButtonConfig_brdcst_func+0xc6>
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	cf ec       	rcall	8000247a <AudioRoutingControl_reply_func+0x6>
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d0 10       	acall	0x1
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d0 38       	*unknown*

80002288 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002288:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000228c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002290:	0f 89       	ld.ub	r9,r7[0x0]
80002292:	30 08       	mov	r8,0
80002294:	f0 09 18 00 	cp.b	r9,r8
80002298:	c0 c1       	brne	800022b0 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000229a:	48 9c       	lddpc	r12,800022bc <ButtonConfig_reply_func+0x34>
8000229c:	f0 1f 00 09 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a0:	0f 98       	ld.ub	r8,r7[0x1]
800022a2:	1a d8       	st.w	--sp,r8
800022a4:	48 8c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x3c>
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022aa:	2f fd       	sub	sp,-4
800022ac:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b0:	48 6c       	lddpc	r12,800022c8 <ButtonConfig_reply_func+0x40>
800022b2:	f0 1f 00 04 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d0 5c       	*unknown*
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	6d c0       	ld.w	r0,r6[0x70]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	cf 50       	breq	800022b0 <ButtonConfig_reply_func+0x28>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	d0 74       	*unknown*

800022cc <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022d0:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022d4:	0f 89       	ld.ub	r9,r7[0x0]
800022d6:	30 08       	mov	r8,0
800022d8:	f0 09 18 00 	cp.b	r9,r8
800022dc:	c0 40       	breq	800022e4 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022de:	48 5c       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x24>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 58       	lddpc	r8,800022f8 <BatteryLevel_brdcst_func+0x2c>
800022e8:	b0 89       	st.b	r8[0x0],r9

}
800022ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	d0 90       	acall	0x9
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	6d c0       	ld.w	r0,r6[0x70]
800022f8:	00 00       	add	r0,r0
800022fa:	0a 39       	cp.w	r9,r5

800022fc <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022fe:	19 a8       	ld.ub	r8,r12[0x2]
80002300:	30 19       	mov	r9,1
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 51       	brne	80002310 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002308:	48 6c       	lddpc	r12,80002320 <ShutDown_brdcst_func+0x24>
8000230a:	f0 1f 00 07 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002310:	30 29       	mov	r9,2
80002312:	f2 08 18 00 	cp.b	r8,r9
80002316:	c0 41       	brne	8000231e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002318:	48 4c       	lddpc	r12,80002328 <ShutDown_brdcst_func+0x2c>
8000231a:	f0 1f 00 03 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000231e:	d8 02       	popm	pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	d0 a4       	*unknown*
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	6d c0       	ld.w	r0,r6[0x70]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	d0 b8       	*unknown*

8000232c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
80002330:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002332:	19 a9       	ld.ub	r9,r12[0x2]
80002334:	30 08       	mov	r8,0
80002336:	f0 09 18 00 	cp.b	r9,r8
8000233a:	c0 61       	brne	80002346 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000233c:	48 dc       	lddpc	r12,80002370 <DataSession_reply_func+0x44>
8000233e:	f0 1f 00 0e 	mcall	80002374 <DataSession_reply_func+0x48>
80002342:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002346:	48 dc       	lddpc	r12,80002378 <DataSession_reply_func+0x4c>
80002348:	f0 1f 00 0b 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000234c:	0f a8       	ld.ub	r8,r7[0x2]
8000234e:	1a d8       	st.w	--sp,r8
80002350:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x50>
80002352:	f0 1f 00 09 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002356:	0f b8       	ld.ub	r8,r7[0x3]
80002358:	1a d8       	st.w	--sp,r8
8000235a:	48 ac       	lddpc	r12,80002380 <DataSession_reply_func+0x54>
8000235c:	f0 1f 00 06 	mcall	80002374 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002360:	0f c8       	ld.ub	r8,r7[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <DataSession_reply_func+0x58>
80002366:	f0 1f 00 04 	mcall	80002374 <DataSession_reply_func+0x48>
8000236a:	2f dd       	sub	sp,-12
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d0 c8       	*unknown*
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	6d c0       	ld.w	r0,r6[0x70]
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d0 d8       	*unknown*
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d0 e8       	*unknown*
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d0 f8       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	d1 04       	*unknown*

80002388 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002388:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000238c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002390:	0f 98       	ld.ub	r8,r7[0x1]
80002392:	1a d8       	st.w	--sp,r8
80002394:	48 bc       	lddpc	r12,800023c0 <CallControl_brdcst_func+0x38>
80002396:	f0 1f 00 0c 	mcall	800023c4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000239a:	2f fd       	sub	sp,-4
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 38       	mov	r8,3
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023a6:	30 09       	mov	r9,0
800023a8:	48 88       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023ac:	0f 99       	ld.ub	r9,r7[0x1]
800023ae:	30 48       	mov	r8,4
800023b0:	f0 09 18 00 	cp.b	r9,r8
800023b4:	c0 41       	brne	800023bc <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023b6:	30 19       	mov	r9,1
800023b8:	48 48       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023ba:	b0 89       	st.b	r8[0x0],r9
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	d1 10       	acall	0x11
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	6d c0       	ld.w	r0,r6[0x70]
800023c8:	00 00       	add	r0,r0
800023ca:	0a 42       	or	r2,r5

800023cc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023d0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023d4:	0f 99       	ld.ub	r9,r7[0x1]
800023d6:	30 08       	mov	r8,0
800023d8:	f0 09 18 00 	cp.b	r9,r8
800023dc:	c0 71       	brne	800023ea <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023de:	48 ac       	lddpc	r12,80002404 <TransmitControl_brdcst_func+0x38>
800023e0:	f0 1f 00 0a 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023e4:	30 09       	mov	r9,0
800023e6:	48 a8       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023e8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ea:	0f 99       	ld.ub	r9,r7[0x1]
800023ec:	30 18       	mov	r8,1
800023ee:	f0 09 18 00 	cp.b	r9,r8
800023f2:	c0 71       	brne	80002400 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023f4:	48 7c       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x44>
800023f6:	f0 1f 00 05 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023fa:	30 19       	mov	r9,1
800023fc:	48 48       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023fe:	b0 89       	st.b	r8[0x0],r9
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d1 28       	*unknown*
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	6d c0       	ld.w	r0,r6[0x70]
8000240c:	00 00       	add	r0,r0
8000240e:	0a 41       	or	r1,r5
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d1 40       	acall	0x14

80002414 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002418:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000241c:	0f 89       	ld.ub	r9,r7[0x0]
8000241e:	30 08       	mov	r8,0
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c1 61       	brne	80002450 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002426:	48 ec       	lddpc	r12,8000245c <TransmitControl_reply_func+0x48>
80002428:	f0 1f 00 0e 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000242c:	0f 98       	ld.ub	r8,r7[0x1]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	48 dc       	lddpc	r12,80002464 <TransmitControl_reply_func+0x50>
80002432:	f0 1f 00 0c 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002436:	0f a8       	ld.ub	r8,r7[0x2]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	48 cc       	lddpc	r12,80002468 <TransmitControl_reply_func+0x54>
8000243c:	f0 1f 00 09 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002440:	0f b8       	ld.ub	r8,r7[0x3]
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 ac       	lddpc	r12,8000246c <TransmitControl_reply_func+0x58>
80002446:	f0 1f 00 07 	mcall	80002460 <TransmitControl_reply_func+0x4c>
8000244a:	2f dd       	sub	sp,-12
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002450:	48 8c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x5c>
80002452:	f0 1f 00 04 	mcall	80002460 <TransmitControl_reply_func+0x4c>
80002456:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d1 54       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	6d c0       	ld.w	r0,r6[0x70]
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d1 70       	acall	0x17
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d1 84       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	d1 a0       	acall	0x1a
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d1 b0       	acall	0x1b

80002474 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002474:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002476:	19 a9       	ld.ub	r9,r12[0x2]
80002478:	30 08       	mov	r8,0
8000247a:	f0 09 18 00 	cp.b	r9,r8
8000247e:	c0 51       	brne	80002488 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x1c>
80002482:	f0 1f 00 05 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002488:	48 4c       	lddpc	r12,80002498 <AudioRoutingControl_reply_func+0x24>
8000248a:	f0 1f 00 03 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
8000248e:	d8 02       	popm	pc
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d1 c8       	*unknown*
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	6d c0       	ld.w	r0,r6[0x70]
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	d1 d8       	*unknown*

8000249c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024a4:	0f 89       	ld.ub	r9,r7[0x0]
800024a6:	30 08       	mov	r8,0
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c1 b1       	brne	800024e2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ae:	0f b8       	ld.ub	r8,r7[0x3]
800024b0:	31 09       	mov	r9,16
800024b2:	f2 08 18 00 	cp.b	r8,r9
800024b6:	c0 f1       	brne	800024d4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b8:	48 dc       	lddpc	r12,800024ec <Volume_reply_func+0x50>
800024ba:	f0 1f 00 0e 	mcall	800024f0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024be:	0f 99       	ld.ub	r9,r7[0x1]
800024c0:	0f a8       	ld.ub	r8,r7[0x2]
800024c2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 bc       	lddpc	r12,800024f4 <Volume_reply_func+0x58>
800024ca:	f0 1f 00 0a 	mcall	800024f0 <Volume_reply_func+0x54>
800024ce:	2f fd       	sub	sp,-4
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024d4:	1a d8       	st.w	--sp,r8
800024d6:	48 9c       	lddpc	r12,800024f8 <Volume_reply_func+0x5c>
800024d8:	f0 1f 00 06 	mcall	800024f0 <Volume_reply_func+0x54>
800024dc:	2f fd       	sub	sp,-4
800024de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024e2:	48 7c       	lddpc	r12,800024fc <Volume_reply_func+0x60>
800024e4:	f0 1f 00 03 	mcall	800024f0 <Volume_reply_func+0x54>
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d1 ec       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	6d c0       	ld.w	r0,r6[0x70]
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d2 00       	acall	0x20
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	d2 1c       	*unknown*
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d2 34       	*unknown*

80002500 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002502:	19 d9       	ld.ub	r9,r12[0x5]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 81       	brne	8000251a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000250c:	10 99       	mov	r9,r8
8000250e:	48 78       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
80002510:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002512:	48 7c       	lddpc	r12,8000252c <spk_brdcst_func+0x2c>
80002514:	f0 1f 00 07 	mcall	80002530 <spk_brdcst_func+0x30>
80002518:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000251a:	30 19       	mov	r9,1
8000251c:	48 38       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
8000251e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002520:	48 5c       	lddpc	r12,80002534 <spk_brdcst_func+0x34>
80002522:	f0 1f 00 04 	mcall	80002530 <spk_brdcst_func+0x30>
80002526:	d8 02       	popm	pc
80002528:	00 00       	add	r0,r0
8000252a:	0a 38       	cp.w	r8,r5
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d2 4c       	*unknown*
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	6d c0       	ld.w	r0,r6[0x70]
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	d2 5c       	*unknown*

80002538 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000253a:	19 a9       	ld.ub	r9,r12[0x2]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 f1       	brne	80002560 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002544:	19 e9       	ld.ub	r9,r12[0x6]
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 40       	breq	80002552 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000254c:	30 19       	mov	r9,1
8000254e:	48 98       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002550:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002552:	19 e8       	ld.ub	r8,r12[0x6]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <spk_reply_func+0x3c>
80002558:	f0 1f 00 08 	mcall	80002578 <spk_reply_func+0x40>
8000255c:	2f fd       	sub	sp,-4
8000255e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 48       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002564:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002566:	48 6c       	lddpc	r12,8000257c <spk_reply_func+0x44>
80002568:	f0 1f 00 04 	mcall	80002578 <spk_reply_func+0x40>
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	00 00       	add	r0,r0
80002572:	0a 38       	cp.w	r8,r5
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d2 68       	*unknown*
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	6d c0       	ld.w	r0,r6[0x70]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	d2 78       	*unknown*

80002580 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002588:	0f a9       	ld.ub	r9,r7[0x2]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 71       	brne	8000259e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002592:	48 dc       	lddpc	r12,800025c4 <mic_brdcst_func+0x44>
80002594:	f0 1f 00 0d 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002598:	30 09       	mov	r9,0
8000259a:	48 d8       	lddpc	r8,800025cc <mic_brdcst_func+0x4c>
8000259c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000259e:	0f a9       	ld.ub	r9,r7[0x2]
800025a0:	31 18       	mov	r8,17
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 d1       	brne	800025c0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a8:	48 ac       	lddpc	r12,800025d0 <mic_brdcst_func+0x50>
800025aa:	f0 1f 00 08 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ae:	48 89       	lddpc	r9,800025cc <mic_brdcst_func+0x4c>
800025b0:	30 18       	mov	r8,1
800025b2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025b4:	13 89       	ld.ub	r9,r9[0x0]
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 31       	brne	800025c0 <mic_brdcst_func+0x40>
800025bc:	48 68       	lddpc	r8,800025d4 <mic_brdcst_func+0x54>
800025be:	11 88       	ld.ub	r8,r8[0x0]
800025c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	d2 84       	*unknown*
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	6d c0       	ld.w	r0,r6[0x70]
800025cc:	00 00       	add	r0,r0
800025ce:	0a 46       	or	r6,r5
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	d2 98       	*unknown*
800025d4:	00 00       	add	r0,r0
800025d6:	0a 42       	or	r2,r5

800025d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025e0:	49 ac       	lddpc	r12,80002648 <mic_reply_func+0x70>
800025e2:	f0 1f 00 1b 	mcall	8000264c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025e6:	0f 89       	ld.ub	r9,r7[0x0]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c2 71       	brne	8000263c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025f0:	0f 98       	ld.ub	r8,r7[0x1]
800025f2:	30 29       	mov	r9,2
800025f4:	f2 08 18 00 	cp.b	r8,r9
800025f8:	c1 b1       	brne	8000262e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025fa:	49 6c       	lddpc	r12,80002650 <mic_reply_func+0x78>
800025fc:	f0 1f 00 14 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002600:	0f a8       	ld.ub	r8,r7[0x2]
80002602:	1a d8       	st.w	--sp,r8
80002604:	49 4c       	lddpc	r12,80002654 <mic_reply_func+0x7c>
80002606:	f0 1f 00 12 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000260a:	0f b8       	ld.ub	r8,r7[0x3]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	49 3c       	lddpc	r12,80002658 <mic_reply_func+0x80>
80002610:	f0 1f 00 0f 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002614:	0f c8       	ld.ub	r8,r7[0x4]
80002616:	1a d8       	st.w	--sp,r8
80002618:	49 1c       	lddpc	r12,8000265c <mic_reply_func+0x84>
8000261a:	f0 1f 00 0d 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000261e:	0f d8       	ld.ub	r8,r7[0x5]
80002620:	1a d8       	st.w	--sp,r8
80002622:	49 0c       	lddpc	r12,80002660 <mic_reply_func+0x88>
80002624:	f0 1f 00 0a 	mcall	8000264c <mic_reply_func+0x74>
80002628:	2f cd       	sub	sp,-16
8000262a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000262e:	1a d8       	st.w	--sp,r8
80002630:	48 dc       	lddpc	r12,80002664 <mic_reply_func+0x8c>
80002632:	f0 1f 00 07 	mcall	8000264c <mic_reply_func+0x74>
80002636:	2f fd       	sub	sp,-4
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000263c:	48 bc       	lddpc	r12,80002668 <mic_reply_func+0x90>
8000263e:	f0 1f 00 04 	mcall	8000264c <mic_reply_func+0x74>
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d2 ac       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	6d c0       	ld.w	r0,r6[0x70]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d2 bc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d2 d0       	acall	0x2d
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d2 e4       	*unknown*
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d3 00       	acall	0x30
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d3 18       	*unknown*
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	d3 30       	acall	0x33
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	d3 48       	*unknown*

8000266c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002674:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x34>
80002676:	f0 1f 00 0c 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000267a:	0f 88       	ld.ub	r8,r7[0x0]
8000267c:	1a d8       	st.w	--sp,r8
8000267e:	48 bc       	lddpc	r12,800026a8 <dcm_brdcst_func+0x3c>
80002680:	f0 1f 00 09 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 9c       	lddpc	r12,800026ac <dcm_brdcst_func+0x40>
8000268a:	f0 1f 00 07 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000268e:	0f 98       	ld.ub	r8,r7[0x1]
80002690:	1a d8       	st.w	--sp,r8
80002692:	48 8c       	lddpc	r12,800026b0 <dcm_brdcst_func+0x44>
80002694:	f0 1f 00 04 	mcall	800026a4 <dcm_brdcst_func+0x38>
80002698:	2f dd       	sub	sp,-12
	
	
}
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d3 58       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	6d c0       	ld.w	r0,r6[0x70]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d3 6c       	*unknown*
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	d3 80       	acall	0x38
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	d3 98       	*unknown*

800026b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026b4:	eb cd 40 80 	pushm	r7,lr
800026b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026ba:	19 a9       	ld.ub	r9,r12[0x2]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c1 b1       	brne	800026f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026c4:	19 b8       	ld.ub	r8,r12[0x3]
800026c6:	30 19       	mov	r9,1
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c0 51       	brne	800026d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ce:	48 ec       	lddpc	r12,80002704 <dcm_reply_func+0x50>
800026d0:	f0 1f 00 0e 	mcall	80002708 <dcm_reply_func+0x54>
800026d4:	c0 a8       	rjmp	800026e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026d6:	58 08       	cp.w	r8,0
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026da:	48 dc       	lddpc	r12,8000270c <dcm_reply_func+0x58>
800026dc:	f0 1f 00 0b 	mcall	80002708 <dcm_reply_func+0x54>
800026e0:	c0 48       	rjmp	800026e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026e2:	48 cc       	lddpc	r12,80002710 <dcm_reply_func+0x5c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e8:	0f d8       	ld.ub	r8,r7[0x5]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 ac       	lddpc	r12,80002714 <dcm_reply_func+0x60>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_reply_func+0x54>
800026f2:	2f fd       	sub	sp,-4
800026f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f8:	48 8c       	lddpc	r12,80002718 <dcm_reply_func+0x64>
800026fa:	f0 1f 00 04 	mcall	80002708 <dcm_reply_func+0x54>
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d3 b4       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	6d c0       	ld.w	r0,r6[0x70]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d3 c8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d3 dc       	*unknown*
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d3 f0       	acall	0x3f
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	d3 fc       	*unknown*

8000271c <ToneControl_reply_func>:
			//log("Device State : %d\n", ptr->Device_State);
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000271c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c0 51       	brne	80002730 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x1c>
8000272a:	f0 1f 00 05 	mcall	8000273c <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002730:	48 4c       	lddpc	r12,80002740 <ToneControl_reply_func+0x24>
80002732:	f0 1f 00 03 	mcall	8000273c <ToneControl_reply_func+0x20>
80002736:	d8 02       	popm	pc
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d4 08       	*unknown*
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	6d c0       	ld.w	r0,r6[0x70]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	d4 14       	*unknown*

80002744 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002744:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002746:	49 1c       	lddpc	r12,80002788 <app_init+0x44>
80002748:	f0 1f 00 11 	mcall	8000278c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000274c:	49 1b       	lddpc	r11,80002790 <app_init+0x4c>
8000274e:	49 2c       	lddpc	r12,80002794 <app_init+0x50>
80002750:	f0 1f 00 12 	mcall	80002798 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002754:	f0 1f 00 12 	mcall	8000279c <app_init+0x58>
80002758:	49 28       	lddpc	r8,800027a0 <app_init+0x5c>
8000275a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000275c:	70 08       	ld.w	r8,r8[0x0]
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 41       	brne	80002768 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002762:	49 1c       	lddpc	r12,800027a4 <app_init+0x60>
80002764:	f0 1f 00 11 	mcall	800027a8 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002768:	30 09       	mov	r9,0
8000276a:	1a d9       	st.w	--sp,r9
8000276c:	1a d9       	st.w	--sp,r9
8000276e:	1a d9       	st.w	--sp,r9
80002770:	30 18       	mov	r8,1
80002772:	e0 6a 03 20 	mov	r10,800
80002776:	48 eb       	lddpc	r11,800027ac <app_init+0x68>
80002778:	48 ec       	lddpc	r12,800027b0 <app_init+0x6c>
8000277a:	f0 1f 00 0f 	mcall	800027b4 <app_init+0x70>
8000277e:	48 f8       	lddpc	r8,800027b8 <app_init+0x74>
80002780:	91 0c       	st.w	r8[0x0],r12
80002782:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002784:	d8 02       	popm	pc
80002786:	00 00       	add	r0,r0
80002788:	00 00       	add	r0,r0
8000278a:	00 08       	add	r8,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	3d a8       	mov	r8,-38
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	20 58       	sub	r8,5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 6c       	sub	r12,6
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	2a 58       	sub	r8,-91
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	62 88       	ld.w	r8,r1[0x20]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 4c       	or	r12,r5
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d4 20       	acall	0x42
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	6d c0       	ld.w	r0,r6[0x70]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d4 4c       	*unknown*
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	27 bc       	sub	r12,123
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	69 fc       	ld.w	r12,r4[0x7c]
800027b8:	00 00       	add	r0,r0
800027ba:	0a 3c       	cp.w	r12,r5

800027bc <app_cfg>:
extern void xnl_send_device_master_query(void);
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
800027be:	21 4d       	sub	sp,80
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c0:	31 4c       	mov	r12,20
800027c2:	f0 1f 00 38 	mcall	800028a0 <app_cfg+0xe4>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027c6:	f0 1f 00 38 	mcall	800028a4 <app_cfg+0xe8>
800027ca:	4b 88       	lddpc	r8,800028a8 <app_cfg+0xec>
800027cc:	91 0c       	st.w	r8[0x0],r12
	
	static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	char str[80];
	memset(str, 0x00, 80);
800027ce:	35 0a       	mov	r10,80
800027d0:	30 0b       	mov	r11,0
800027d2:	1a 9c       	mov	r12,sp
800027d4:	f0 1f 00 36 	mcall	800028ac <app_cfg+0xf0>
	
	/* 'Give' the semaphore to unblock the task. */
	 //if( xBinarySemaphore != NULL ){
		//xSemaphoreGive(xBinarySemaphore);
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
800027d8:	4b 68       	lddpc	r8,800028b0 <app_cfg+0xf4>
800027da:	70 0c       	ld.w	r12,r8[0x0]
800027dc:	30 09       	mov	r9,0
800027de:	3f fa       	mov	r10,-1
800027e0:	12 9b       	mov	r11,r9
800027e2:	f0 1f 00 35 	mcall	800028b4 <app_cfg+0xf8>
		
	for(;;)
	{
		switch(OB_State)
800027e6:	4b 55       	lddpc	r5,800028b8 <app_cfg+0xfc>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027e8:	4b 54       	lddpc	r4,800028bc <app_cfg+0x100>
					nop();
					nop();
					nop();
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
					log("connecting...\n");
800027ea:	4b 62       	lddpc	r2,800028c0 <app_cfg+0x104>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027ec:	4a f6       	lddpc	r6,800028a8 <app_cfg+0xec>
800027ee:	e0 67 07 d0 	mov	r7,2000
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	4b 53       	lddpc	r3,800028c4 <app_cfg+0x108>
				{
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027f4:	30 c0       	mov	r0,12
800027f6:	30 11       	mov	r1,1
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
		
	for(;;)
	{
		switch(OB_State)
800027f8:	6a 08       	ld.w	r8,r5[0x0]
800027fa:	58 08       	cp.w	r8,0
800027fc:	c0 40       	breq	80002804 <app_cfg+0x48>
800027fe:	58 38       	cp.w	r8,3
80002800:	c4 a1       	brne	80002894 <app_cfg+0xd8>
80002802:	c3 a8       	rjmp	80002876 <app_cfg+0xba>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002804:	68 08       	ld.w	r8,r4[0x0]
80002806:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000280a:	58 38       	cp.w	r8,3
8000280c:	c2 81       	brne	8000285c <app_cfg+0xa0>
8000280e:	07 88       	ld.ub	r8,r3[0x0]
80002810:	58 08       	cp.w	r8,0
80002812:	c2 51       	brne	8000285c <app_cfg+0xa0>
				{
					connect_flag=1;
80002814:	30 18       	mov	r8,1
80002816:	a6 88       	st.b	r3[0x0],r8
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002818:	00 9b       	mov	r11,r0
8000281a:	02 9c       	mov	r12,r1
8000281c:	f0 1f 00 2b 	mcall	800028c8 <app_cfg+0x10c>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002820:	00 9b       	mov	r11,r0
80002822:	02 9c       	mov	r12,r1
80002824:	f0 1f 00 29 	mcall	800028c8 <app_cfg+0x10c>
					OB_State = OB_WAITINGAPPTASK;
80002828:	30 38       	mov	r8,3
8000282a:	8b 08       	st.w	r5[0x0],r8
					log("connect OB okay!\n");
8000282c:	4a 8c       	lddpc	r12,800028cc <app_cfg+0x110>
8000282e:	f0 1f 00 29 	mcall	800028d0 <app_cfg+0x114>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
													 XCMP_Version[2],  XCMP_Version[3]);
80002832:	4a 98       	lddpc	r8,800028d4 <app_cfg+0x118>
80002834:	11 bb       	ld.ub	r11,r8[0x3]
80002836:	11 aa       	ld.ub	r10,r8[0x2]
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
80002838:	11 99       	ld.ub	r9,r8[0x1]
8000283a:	11 88       	ld.ub	r8,r8[0x0]
8000283c:	1a db       	st.w	--sp,r11
8000283e:	1a da       	st.w	--sp,r10
80002840:	1a d9       	st.w	--sp,r9
80002842:	1a d8       	st.w	--sp,r8
80002844:	4a 5c       	lddpc	r12,800028d8 <app_cfg+0x11c>
80002846:	f0 1f 00 23 	mcall	800028d0 <app_cfg+0x114>
													 XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);							 
8000284a:	1a d1       	st.w	--sp,r1
8000284c:	1a d1       	st.w	--sp,r1
8000284e:	30 28       	mov	r8,2
80002850:	1a d8       	st.w	--sp,r8
80002852:	4a 3c       	lddpc	r12,800028dc <app_cfg+0x120>
80002854:	f0 1f 00 1f 	mcall	800028d0 <app_cfg+0x114>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002858:	2f 9d       	sub	sp,-28
8000285a:	c1 d8       	rjmp	80002894 <app_cfg+0xd8>
													 XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);							 
				}
				else
				{
					nop();
8000285c:	d7 03       	nop
					nop();
8000285e:	d7 03       	nop
					nop();
80002860:	d7 03       	nop
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
80002862:	f0 1f 00 20 	mcall	800028e0 <app_cfg+0x124>
					log("connecting...\n");
80002866:	04 9c       	mov	r12,r2
80002868:	f0 1f 00 1a 	mcall	800028d0 <app_cfg+0x114>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000286c:	0e 9b       	mov	r11,r7
8000286e:	0c 9c       	mov	r12,r6
80002870:	f0 1f 00 1d 	mcall	800028e4 <app_cfg+0x128>
80002874:	c1 08       	rjmp	80002894 <app_cfg+0xd8>
							//}
						//
						//}
					}
					
					if (0x00000003 != (bunchofrandomstatusflags & 0x00000003))//掉线
80002876:	68 08       	ld.w	r8,r4[0x0]
80002878:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000287c:	58 38       	cp.w	r8,3
8000287e:	c0 70       	breq	8000288c <app_cfg+0xd0>
					{					
						OB_State = OB_UNCONNECTEDWAITINGSTATUS;
80002880:	30 08       	mov	r8,0
80002882:	8b 08       	st.w	r5[0x0],r8
						connect_flag=0;
80002884:	a6 88       	st.b	r3[0x0],r8
						log("OB disconnecting!!!\n");
80002886:	49 9c       	lddpc	r12,800028e8 <app_cfg+0x12c>
80002888:	f0 1f 00 12 	mcall	800028d0 <app_cfg+0x114>
							//memset(str, 0x00, 80);
						//}
					//}
					
											
					nop();
8000288c:	d7 03       	nop
					log("app task run!\n");
8000288e:	49 8c       	lddpc	r12,800028ec <app_cfg+0x130>
80002890:	f0 1f 00 10 	mcall	800028d0 <app_cfg+0x114>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002894:	0e 9b       	mov	r11,r7
80002896:	0c 9c       	mov	r12,r6
80002898:	f0 1f 00 13 	mcall	800028e4 <app_cfg+0x128>
	}
8000289c:	ca eb       	rjmp	800027f8 <app_cfg+0x3c>
8000289e:	00 00       	add	r0,r0
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	5e 34       	retlo	r4
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	66 ec       	ld.w	r12,r3[0x38]
800028a8:	00 00       	add	r0,r0
800028aa:	0a 50       	eor	r0,r5
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	77 84       	ld.w	r4,r11[0x60]
800028b0:	00 00       	add	r0,r0
800028b2:	0b 58       	ld.sh	r8,--r5
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	5f 7c       	srpl	r12
800028b8:	00 00       	add	r0,r0
800028ba:	0a 48       	or	r8,r5
800028bc:	00 00       	add	r0,r0
800028be:	0d 80       	ld.ub	r0,r6[0x0]
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	d4 a4       	*unknown*
800028c4:	00 00       	add	r0,r0
800028c6:	0a 45       	or	r5,r5
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3f 40       	mov	r0,-12
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	d4 54       	*unknown*
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	6d c0       	ld.w	r0,r6[0x70]
800028d4:	00 00       	add	r0,r0
800028d6:	0d 7c       	ld.ub	r12,--r6
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	d4 68       	*unknown*
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	d4 84       	*unknown*
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	46 ec       	lddsp	r12,sp[0x1b8]
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	68 9c       	ld.w	r12,r4[0x24]
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	d4 b4       	*unknown*
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	d4 cc       	*unknown*

800028f0 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028f0:	d4 21       	pushm	r4-r7,lr
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028f2:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028f6:	0d 88       	ld.ub	r8,r6[0x0]
800028f8:	32 49       	mov	r9,36
800028fa:	f2 08 18 00 	cp.b	r8,r9
800028fe:	c2 91       	brne	80002950 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002900:	49 dc       	lddpc	r12,80002974 <DataSession_brdcst_func+0x84>
80002902:	f0 1f 00 1e 	mcall	80002978 <DataSession_brdcst_func+0x88>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002906:	0d a5       	ld.ub	r5,r6[0x2]
80002908:	0d b8       	ld.ub	r8,r6[0x3]
8000290a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000290e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002910:	0d 98       	ld.ub	r8,r6[0x1]
80002912:	1a d8       	st.w	--sp,r8
80002914:	49 ac       	lddpc	r12,8000297c <DataSession_brdcst_func+0x8c>
80002916:	f0 1f 00 19 	mcall	80002978 <DataSession_brdcst_func+0x88>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000291a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000291e:	1a d8       	st.w	--sp,r8
80002920:	49 8c       	lddpc	r12,80002980 <DataSession_brdcst_func+0x90>
80002922:	f0 1f 00 16 	mcall	80002978 <DataSession_brdcst_func+0x88>
		for(i=0; i<data_length; i++)
80002926:	2f ed       	sub	sp,-8
80002928:	58 05       	cp.w	r5,0
8000292a:	c2 40       	breq	80002972 <DataSession_brdcst_func+0x82>
8000292c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000292e:	49 64       	lddpc	r4,80002984 <DataSession_brdcst_func+0x94>
80002930:	ec 07 00 08 	add	r8,r6,r7
80002934:	11 c8       	ld.ub	r8,r8[0x4]
80002936:	1a d8       	st.w	--sp,r8
80002938:	1a d7       	st.w	--sp,r7
8000293a:	08 9c       	mov	r12,r4
8000293c:	f0 1f 00 0f 	mcall	80002978 <DataSession_brdcst_func+0x88>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002940:	2f f7       	sub	r7,-1
80002942:	5c 57       	castu.b	r7
80002944:	2f ed       	sub	sp,-8
80002946:	ee 05 19 00 	cp.h	r5,r7
8000294a:	fe 9b ff f3 	brhi	80002930 <DataSession_brdcst_func+0x40>
8000294e:	d8 22       	popm	r4-r7,pc
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002950:	1a d8       	st.w	--sp,r8
80002952:	48 ec       	lddpc	r12,80002988 <DataSession_brdcst_func+0x98>
80002954:	f0 1f 00 09 	mcall	80002978 <DataSession_brdcst_func+0x88>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002958:	2f fd       	sub	sp,-4
8000295a:	0d 89       	ld.ub	r9,r6[0x0]
8000295c:	30 38       	mov	r8,3
8000295e:	f0 09 18 00 	cp.b	r9,r8
80002962:	c0 81       	brne	80002972 <DataSession_brdcst_func+0x82>
		{
			log("data transmit success\n");
80002964:	48 ac       	lddpc	r12,8000298c <DataSession_brdcst_func+0x9c>
80002966:	f0 1f 00 05 	mcall	80002978 <DataSession_brdcst_func+0x88>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
8000296a:	e0 6c 07 d0 	mov	r12,2000
8000296e:	f0 1f 00 09 	mcall	80002990 <DataSession_brdcst_func+0xa0>
80002972:	d8 22       	popm	r4-r7,pc
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	d4 dc       	*unknown*
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	6d c0       	ld.w	r0,r6[0x70]
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	d4 f0       	acall	0x4f
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	d5 08       	*unknown*
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	d5 24       	*unknown*
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	d5 3c       	*unknown*
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	d5 48       	*unknown*
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	68 54       	ld.w	r4,r4[0x14]

80002994 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002994:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002998:	19 c7       	ld.ub	r7,r12[0x4]
8000299a:	19 d8       	ld.ub	r8,r12[0x5]
8000299c:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800029a0:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800029a2:	48 dc       	lddpc	r12,800029d4 <Phyuserinput_brdcst_func+0x40>
800029a4:	f0 1f 00 0d 	mcall	800029d8 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800029a8:	36 08       	mov	r8,96
800029aa:	f0 07 19 00 	cp.h	r7,r8
800029ae:	c1 11       	brne	800029d0 <Phyuserinput_brdcst_func+0x3c>
800029b0:	48 b8       	lddpc	r8,800029dc <Phyuserinput_brdcst_func+0x48>
800029b2:	11 89       	ld.ub	r9,r8[0x0]
800029b4:	30 18       	mov	r8,1
800029b6:	f0 09 18 00 	cp.b	r9,r8
800029ba:	c0 b1       	brne	800029d0 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
800029bc:	34 5b       	mov	r11,69
800029be:	30 1c       	mov	r12,1
800029c0:	f0 1f 00 08 	mcall	800029e0 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(100*2 / portTICK_RATE_MS);//延迟100ms
800029c4:	e0 6c 00 c8 	mov	r12,200
800029c8:	f0 1f 00 07 	mcall	800029e4 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message	
800029cc:	f0 1f 00 07 	mcall	800029e8 <Phyuserinput_brdcst_func+0x54>
800029d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	d5 60       	acall	0x56
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	6d c0       	ld.w	r0,r6[0x70]
800029dc:	00 00       	add	r0,r0
800029de:	0a 45       	or	r5,r5
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	3f 40       	mov	r0,-12
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	68 54       	ld.w	r4,r4[0x14]
800029e8:	80 00       	ld.sh	r0,r0[0x0]
800029ea:	4f 98       	lddpc	r8,80002bcc <phy_tx_func+0x50>

800029ec <DeviceInitializationStatus_brdcst_func>:
//xnl_content_master_status_brdcst_t XCMP_Version;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t *ptr = (DeviceInitializationStatus_brdcst_t* )xcmp->u8;
800029f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	//log("DeviceInitializationStatus_brdcst...\n");
	
	memcpy(XCMP_Version, &(ptr->XCMPVersion[0]), sizeof(XCMP_Version));
800029f4:	30 4a       	mov	r10,4
800029f6:	0e 9b       	mov	r11,r7
800029f8:	48 dc       	lddpc	r12,80002a2c <DeviceInitializationStatus_brdcst_func+0x40>
800029fa:	f0 1f 00 0e 	mcall	80002a30 <DeviceInitializationStatus_brdcst_func+0x44>
	
	if (ptr->DeviceInitType == Device_Init_Complete)
800029fe:	0f c8       	ld.ub	r8,r7[0x4]
80002a00:	30 19       	mov	r9,1
80002a02:	f2 08 18 00 	cp.b	r8,r9
80002a06:	c0 71       	brne	80002a14 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a08:	48 b8       	lddpc	r8,80002a34 <DeviceInitializationStatus_brdcst_func+0x48>
80002a0a:	70 09       	ld.w	r9,r8[0x0]
80002a0c:	a1 a9       	sbr	r9,0x0
80002a0e:	91 09       	st.w	r8[0x0],r9
80002a10:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else if(ptr->DeviceInitType  == Device_Init_Status)
80002a14:	58 08       	cp.w	r8,0
80002a16:	c0 81       	brne	80002a26 <DeviceInitializationStatus_brdcst_func+0x3a>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a18:	48 78       	lddpc	r8,80002a34 <DeviceInitializationStatus_brdcst_func+0x48>
80002a1a:	70 09       	ld.w	r9,r8[0x0]
80002a1c:	e0 19 ff fc 	andl	r9,0xfffc
80002a20:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a22:	f0 1f 00 06 	mcall	80002a38 <DeviceInitializationStatus_brdcst_func+0x4c>
80002a26:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a2a:	00 00       	add	r0,r0
80002a2c:	00 00       	add	r0,r0
80002a2e:	0d 7c       	ld.ub	r12,--r6
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	76 3c       	ld.w	r12,r11[0xc]
80002a34:	00 00       	add	r0,r0
80002a36:	0d 80       	ld.ub	r0,r6[0x0]
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	3e 8c       	mov	r12,-24

80002a3c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002a3c:	20 1c       	sub	r12,1
80002a3e:	5c 5c       	castu.b	r12
80002a40:	31 18       	mov	r8,17
80002a42:	f0 0c 18 00 	cp.b	r12,r8
80002a46:	e0 88 00 03 	brls	80002a4c <CalculateBurst+0x10>
80002a4a:	5e fd       	retal	0
80002a4c:	48 28       	lddpc	r8,80002a54 <CalculateBurst+0x18>
80002a4e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002a52:	5e fc       	retal	r12
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	d5 80       	acall	0x58

80002a58 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002a58:	48 38       	lddpc	r8,80002a64 <payload_init+0xc>
80002a5a:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002a5c:	48 38       	lddpc	r8,80002a68 <payload_init+0x10>
80002a5e:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002a60:	5e fc       	retal	r12
80002a62:	00 00       	add	r0,r0
80002a64:	00 00       	add	r0,r0
80002a66:	0a 5c       	eor	r12,r5
80002a68:	00 00       	add	r0,r0
80002a6a:	0a 60       	and	r0,r5

80002a6c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002a6c:	d4 01       	pushm	lr
80002a6e:	20 2d       	sub	sp,8
80002a70:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a72:	30 09       	mov	r9,0
80002a74:	fa ca ff f8 	sub	r10,sp,-8
80002a78:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a7a:	1a 9b       	mov	r11,sp
80002a7c:	f0 1f 00 02 	mcall	80002a84 <set_idle_store_isr+0x18>
}
80002a80:	2f ed       	sub	sp,-8
80002a82:	d8 02       	popm	pc
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	61 38       	ld.w	r8,r0[0x4c]

80002a88 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002a88:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002a8a:	48 48       	lddpc	r8,80002a98 <payload_rx+0x10>
80002a8c:	70 08       	ld.w	r8,r8[0x0]
80002a8e:	18 9b       	mov	r11,r12
80002a90:	10 9c       	mov	r12,r8
80002a92:	f0 1f 00 03 	mcall	80002a9c <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002a96:	d8 02       	popm	pc
80002a98:	00 00       	add	r0,r0
80002a9a:	0a 98       	mov	r8,r5
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	2a 6c       	sub	r12,-90

80002aa0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002aa0:	d4 01       	pushm	lr
80002aa2:	20 2d       	sub	sp,8
80002aa4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002aa6:	58 0c       	cp.w	r12,0
80002aa8:	c1 10       	breq	80002aca <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002aaa:	30 08       	mov	r8,0
80002aac:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002aae:	98 88       	ld.uh	r8,r12[0x0]
80002ab0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ab4:	e0 48 40 00 	cp.w	r8,16384
80002ab8:	c0 91       	brne	80002aca <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002aba:	48 68       	lddpc	r8,80002ad0 <phy_rx+0x30>
80002abc:	70 0c       	ld.w	r12,r8[0x0]
80002abe:	30 09       	mov	r9,0
80002ac0:	fa ca ff fc 	sub	r10,sp,-4
80002ac4:	1a 9b       	mov	r11,sp
80002ac6:	f0 1f 00 04 	mcall	80002ad4 <phy_rx+0x34>
		}	

    }
		
 
}
80002aca:	2f ed       	sub	sp,-8
80002acc:	d8 02       	popm	pc
80002ace:	00 00       	add	r0,r0
80002ad0:	00 00       	add	r0,r0
80002ad2:	0a a4       	st.w	r5++,r4
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	61 38       	ld.w	r8,r0[0x4c]

80002ad8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002ad8:	eb cd 40 80 	pushm	r7,lr
80002adc:	20 1d       	sub	sp,4
80002ade:	fa c7 ff fc 	sub	r7,sp,-4
80002ae2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002ae4:	30 09       	mov	r9,0
80002ae6:	12 9a       	mov	r10,r9
80002ae8:	1a 9b       	mov	r11,sp
80002aea:	f0 1f 00 03 	mcall	80002af4 <set_idle_store+0x1c>
}
80002aee:	2f fd       	sub	sp,-4
80002af0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	61 88       	ld.w	r8,r0[0x60]

80002af8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002af8:	d4 01       	pushm	lr
80002afa:	20 1d       	sub	sp,4
80002afc:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002afe:	98 88       	ld.uh	r8,r12[0x0]
80002b00:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b04:	e0 48 40 00 	cp.w	r8,16384
80002b08:	c0 d1       	brne	80002b22 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b0a:	49 08       	lddpc	r8,80002b48 <phy_tx+0x50>
80002b0c:	70 08       	ld.w	r8,r8[0x0]
80002b0e:	58 08       	cp.w	r8,0
80002b10:	c1 a0       	breq	80002b44 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002b12:	48 e8       	lddpc	r8,80002b48 <phy_tx+0x50>
80002b14:	70 0c       	ld.w	r12,r8[0x0]
80002b16:	30 09       	mov	r9,0
80002b18:	12 9a       	mov	r10,r9
80002b1a:	1a 9b       	mov	r11,sp
80002b1c:	f0 1f 00 0c 	mcall	80002b4c <phy_tx+0x54>
80002b20:	c1 28       	rjmp	80002b44 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002b22:	e0 48 10 00 	cp.w	r8,4096
80002b26:	5f 0a       	sreq	r10
80002b28:	e0 48 20 00 	cp.w	r8,8192
80002b2c:	5f 09       	sreq	r9
80002b2e:	f5 e9 10 09 	or	r9,r10,r9
80002b32:	c0 71       	brne	80002b40 <phy_tx+0x48>
80002b34:	e0 48 50 00 	cp.w	r8,20480
80002b38:	c0 40       	breq	80002b40 <phy_tx+0x48>
80002b3a:	e0 48 60 00 	cp.w	r8,24576
80002b3e:	c0 31       	brne	80002b44 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002b40:	48 48       	lddpc	r8,80002b50 <phy_tx+0x58>
80002b42:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002b44:	2f fd       	sub	sp,-4
80002b46:	d8 02       	popm	pc
80002b48:	00 00       	add	r0,r0
80002b4a:	0a c4       	st.b	r5++,r4
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	61 88       	ld.w	r8,r0[0x60]
80002b50:	00 00       	add	r0,r0
80002b52:	0a b8       	st.h	r5++,r8

80002b54 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002b54:	d4 01       	pushm	lr
80002b56:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002b58:	30 08       	mov	r8,0
80002b5a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b5c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002b5e:	1a 9a       	mov	r10,sp
80002b60:	fa cb ff fc 	sub	r11,sp,-4
80002b64:	f0 1f 00 05 	mcall	80002b78 <get_idle_store_isr+0x24>
80002b68:	58 1c       	cp.w	r12,1
80002b6a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b6e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002b72:	2f ed       	sub	sp,-8
80002b74:	d8 02       	popm	pc
80002b76:	00 00       	add	r0,r0
80002b78:	80 00       	ld.sh	r0,r0[0x0]
80002b7a:	5e 8c       	retls	r12

80002b7c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b7c:	eb cd 40 c0 	pushm	r6-r7,lr
80002b80:	20 1d       	sub	sp,4
80002b82:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b84:	4b a8       	lddpc	r8,80002c6c <phy_tx_func+0xf0>
80002b86:	70 08       	ld.w	r8,r8[0x0]
80002b88:	58 08       	cp.w	r8,0
80002b8a:	c6 60       	breq	80002c56 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b8c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b8e:	30 08       	mov	r8,0
80002b90:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b92:	4b 88       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002b94:	70 08       	ld.w	r8,r8[0x0]
80002b96:	58 18       	cp.w	r8,1
80002b98:	c2 60       	breq	80002be4 <phy_tx_func+0x68>
80002b9a:	c0 43       	brcs	80002ba2 <phy_tx_func+0x26>
80002b9c:	58 28       	cp.w	r8,2
80002b9e:	c5 c1       	brne	80002c56 <phy_tx_func+0xda>
80002ba0:	c5 58       	rjmp	80002c4a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ba2:	4b 38       	lddpc	r8,80002c6c <phy_tx_func+0xf0>
80002ba4:	70 0c       	ld.w	r12,r8[0x0]
80002ba6:	1a 9a       	mov	r10,sp
80002ba8:	4b 3b       	lddpc	r11,80002c74 <phy_tx_func+0xf8>
80002baa:	f0 1f 00 34 	mcall	80002c78 <phy_tx_func+0xfc>
80002bae:	58 1c       	cp.w	r12,1
80002bb0:	c1 41       	brne	80002bd8 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002bb2:	4b 18       	lddpc	r8,80002c74 <phy_tx_func+0xf8>
80002bb4:	70 08       	ld.w	r8,r8[0x0]
80002bb6:	90 08       	ld.sh	r8,r8[0x0]
80002bb8:	10 9a       	mov	r10,r8
80002bba:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002bbe:	4b 09       	lddpc	r9,80002c7c <phy_tx_func+0x100>
80002bc0:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002bc2:	5c 78       	castu.h	r8
80002bc4:	ea 18 ab cd 	orh	r8,0xabcd
80002bc8:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002bca:	30 19       	mov	r9,1
80002bcc:	4a d8       	lddpc	r8,80002c80 <phy_tx_func+0x104>
80002bce:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002bd0:	30 19       	mov	r9,1
80002bd2:	4a 88       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002bd4:	91 09       	st.w	r8[0x0],r9
80002bd6:	c4 08       	rjmp	80002c56 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002bd8:	e0 68 5a 5a 	mov	r8,23130
80002bdc:	ea 18 ab cd 	orh	r8,0xabcd
80002be0:	8f 18       	st.w	r7[0x4],r8
80002be2:	c3 a8       	rjmp	80002c56 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002be4:	4a 7a       	lddpc	r10,80002c80 <phy_tx_func+0x104>
80002be6:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002be8:	4a 39       	lddpc	r9,80002c74 <phy_tx_func+0xf8>
80002bea:	72 09       	ld.w	r9,r9[0x0]
80002bec:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002bf0:	b1 69       	lsl	r9,0x10
80002bf2:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002bf4:	2f f8       	sub	r8,-1
80002bf6:	5c 58       	castu.b	r8
80002bf8:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002bfa:	4a 1b       	lddpc	r11,80002c7c <phy_tx_func+0x100>
80002bfc:	96 0c       	ld.sh	r12,r11[0x0]
80002bfe:	20 2c       	sub	r12,2
80002c00:	5c 8c       	casts.h	r12
80002c02:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002c06:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c08:	30 0b       	mov	r11,0
80002c0a:	f6 0a 19 00 	cp.h	r10,r11
80002c0e:	e0 89 00 09 	brgt	80002c20 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002c12:	e8 19 00 ba 	orl	r9,0xba
80002c16:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002c18:	30 09       	mov	r9,0
80002c1a:	49 68       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002c1c:	91 09       	st.w	r8[0x0],r9
80002c1e:	c1 c8       	rjmp	80002c56 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002c20:	49 5a       	lddpc	r10,80002c74 <phy_tx_func+0xf8>
80002c22:	74 0a       	ld.w	r10,r10[0x0]
80002c24:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002c28:	14 49       	or	r9,r10
80002c2a:	8f 19       	st.w	r7[0x4],r9
80002c2c:	2f f8       	sub	r8,-1
80002c2e:	49 59       	lddpc	r9,80002c80 <phy_tx_func+0x104>
80002c30:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c32:	20 2c       	sub	r12,2
80002c34:	49 28       	lddpc	r8,80002c7c <phy_tx_func+0x100>
80002c36:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c38:	30 08       	mov	r8,0
80002c3a:	f0 0c 19 00 	cp.h	r12,r8
80002c3e:	e0 89 00 0c 	brgt	80002c56 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002c42:	30 29       	mov	r9,2
80002c44:	48 b8       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002c46:	91 09       	st.w	r8[0x0],r9
80002c48:	c0 78       	rjmp	80002c56 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002c4a:	fc 18 00 ba 	movh	r8,0xba
80002c4e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c50:	30 09       	mov	r9,0
80002c52:	48 88       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002c54:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002c56:	e0 68 5a 5a 	mov	r8,23130
80002c5a:	ea 18 ab cd 	orh	r8,0xabcd
80002c5e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002c60:	30 08       	mov	r8,0
80002c62:	8f 38       	st.w	r7[0xc],r8
}
80002c64:	2f fd       	sub	sp,-4
80002c66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c6a:	00 00       	add	r0,r0
80002c6c:	00 00       	add	r0,r0
80002c6e:	0a c4       	st.b	r5++,r4
80002c70:	00 00       	add	r0,r0
80002c72:	0a 84       	andn	r4,r5
80002c74:	00 00       	add	r0,r0
80002c76:	0a 90       	mov	r0,r5
80002c78:	80 00       	ld.sh	r0,r0[0x0]
80002c7a:	5e 8c       	retls	r12
80002c7c:	00 00       	add	r0,r0
80002c7e:	0a ac       	st.w	r5++,r12
80002c80:	00 00       	add	r0,r0
80002c82:	0a 64       	and	r4,r5

80002c84 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002c84:	d4 01       	pushm	lr
80002c86:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002c88:	30 0a       	mov	r10,0
80002c8a:	fa cb ff fc 	sub	r11,sp,-4
80002c8e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002c90:	14 99       	mov	r9,r10
80002c92:	1a 9b       	mov	r11,sp
80002c94:	f0 1f 00 05 	mcall	80002ca8 <get_idle_store+0x24>
80002c98:	58 1c       	cp.w	r12,1
80002c9a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c9e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002ca2:	2f fd       	sub	sp,-4
80002ca4:	d8 02       	popm	pc
80002ca6:	00 00       	add	r0,r0
80002ca8:	80 00       	ld.sh	r0,r0[0x0]
80002caa:	5f 7c       	srpl	r12

80002cac <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002cac:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002cae:	48 4b       	lddpc	r11,80002cbc <phy_init+0x10>
80002cb0:	48 4c       	lddpc	r12,80002cc0 <phy_init+0x14>
80002cb2:	f0 1f 00 05 	mcall	80002cc4 <phy_init+0x18>
	
	/*initialize the SSC*/
	ssc_init();
80002cb6:	f0 1f 00 05 	mcall	80002cc8 <phy_init+0x1c>
	
	/*send device_master_query to connect radio*/
	//xnl_send_device_master_query();
	
}
80002cba:	d8 02       	popm	pc
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	2b 7c       	sub	r12,-73
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	2c cc       	sub	r12,-52
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	3d 20       	mov	r0,-46
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	3d 34       	mov	r4,-45

80002ccc <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ccc:	eb cd 40 e0 	pushm	r5-r7,lr
80002cd0:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002cd2:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002cd6:	70 08       	ld.w	r8,r8[0x0]
80002cd8:	58 08       	cp.w	r8,0
80002cda:	e0 80 01 08 	breq	80002eea <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002cde:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002ce0:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002ce4:	70 09       	ld.w	r9,r8[0x0]
80002ce6:	2f f9       	sub	r9,-1
80002ce8:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002cea:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002cee:	70 08       	ld.w	r8,r8[0x0]
80002cf0:	58 18       	cp.w	r8,1
80002cf2:	e0 80 00 85 	breq	80002dfc <phy_rx_func+0x130>
80002cf6:	c0 73       	brcs	80002d04 <phy_rx_func+0x38>
80002cf8:	58 28       	cp.w	r8,2
80002cfa:	c5 c0       	breq	80002db2 <phy_rx_func+0xe6>
80002cfc:	58 38       	cp.w	r8,3
80002cfe:	e0 81 00 f6 	brne	80002eea <phy_rx_func+0x21e>
80002d02:	cd 58       	rjmp	80002eac <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002d04:	e0 6a 5a 5a 	mov	r10,23130
80002d08:	ea 1a ab cd 	orh	r10,0xabcd
80002d0c:	14 36       	cp.w	r6,r10
80002d0e:	e0 80 00 ee 	breq	80002eea <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002d12:	ec 08 16 10 	lsr	r8,r6,0x10
80002d16:	e0 48 ab cd 	cp.w	r8,43981
80002d1a:	e0 81 00 e8 	brne	80002eea <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002d1e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002d22:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002d26:	20 28       	sub	r8,2
80002d28:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002d2c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002d2e:	30 09       	mov	r9,0
80002d30:	f2 08 19 00 	cp.h	r8,r9
80002d34:	e0 8a 00 db 	brle	80002eea <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002d38:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002d3c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002d3e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002d42:	70 0c       	ld.w	r12,r8[0x0]
80002d44:	f0 1f 03 88 	mcall	80003b64 <phy_rx_func+0xe98>
80002d48:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002d4c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002d4e:	58 0c       	cp.w	r12,0
80002d50:	e0 80 00 cd 	breq	80002eea <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002d54:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002d58:	90 09       	ld.sh	r9,r8[0x0]
80002d5a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002d5e:	2f f9       	sub	r9,-1
80002d60:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d62:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002d66:	74 0a       	ld.w	r10,r10[0x0]
80002d68:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002d6c:	76 0b       	ld.w	r11,r11[0x0]
80002d6e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002d72:	2f f9       	sub	r9,-1
80002d74:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002d76:	e2 16 0f 00 	andl	r6,0xf00,COH
80002d7a:	e0 46 01 00 	cp.w	r6,256
80002d7e:	c0 c0       	breq	80002d96 <phy_rx_func+0xca>
80002d80:	e0 8b 00 05 	brhi	80002d8a <phy_rx_func+0xbe>
80002d84:	58 06       	cp.w	r6,0
80002d86:	c0 80       	breq	80002d96 <phy_rx_func+0xca>
80002d88:	c0 c8       	rjmp	80002da0 <phy_rx_func+0xd4>
80002d8a:	e0 46 02 00 	cp.w	r6,512
80002d8e:	c0 40       	breq	80002d96 <phy_rx_func+0xca>
80002d90:	e0 46 03 00 	cp.w	r6,768
80002d94:	c0 61       	brne	80002da0 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002d96:	30 29       	mov	r9,2
80002d98:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002d9c:	91 09       	st.w	r8[0x0],r9
80002d9e:	ca 68       	rjmp	80002eea <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002da0:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002da4:	70 0c       	ld.w	r12,r8[0x0]
80002da6:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002daa:	70 0b       	ld.w	r11,r8[0x0]
80002dac:	f0 1f 03 70 	mcall	80003b6c <phy_rx_func+0xea0>
80002db0:	c9 d8       	rjmp	80002eea <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002db2:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002db6:	b1 86       	lsr	r6,0x10
80002db8:	14 06       	add	r6,r10
80002dba:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002dbe:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002dc0:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002dc4:	90 09       	ld.sh	r9,r8[0x0]
80002dc6:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002dca:	76 0b       	ld.w	r11,r11[0x0]
80002dcc:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002dd0:	2f f9       	sub	r9,-1
80002dd2:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002dd4:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002dd8:	92 08       	ld.sh	r8,r9[0x0]
80002dda:	20 28       	sub	r8,2
80002ddc:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002dde:	30 09       	mov	r9,0
80002de0:	f2 08 19 00 	cp.h	r8,r9
80002de4:	e0 8a 00 07 	brle	80002df2 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002de8:	30 19       	mov	r9,1
80002dea:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002dee:	91 09       	st.w	r8[0x0],r9
80002df0:	c7 d8       	rjmp	80002eea <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002df2:	30 39       	mov	r9,3
80002df4:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002df8:	91 09       	st.w	r8[0x0],r9
80002dfa:	c7 88       	rjmp	80002eea <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002dfc:	ec 0a 14 10 	asr	r10,r6,0x10
80002e00:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002e04:	90 09       	ld.sh	r9,r8[0x0]
80002e06:	14 09       	add	r9,r10
80002e08:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e0a:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002e0e:	92 08       	ld.sh	r8,r9[0x0]
80002e10:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002e14:	76 0b       	ld.w	r11,r11[0x0]
80002e16:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002e1a:	2f f8       	sub	r8,-1
80002e1c:	5c 88       	casts.h	r8
80002e1e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002e20:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002e24:	94 09       	ld.sh	r9,r10[0x0]
80002e26:	20 29       	sub	r9,2
80002e28:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002e2a:	30 0a       	mov	r10,0
80002e2c:	f4 09 19 00 	cp.h	r9,r10
80002e30:	e0 89 00 20 	brgt	80002e70 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002e34:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002e38:	e0 46 00 ba 	cp.w	r6,186
80002e3c:	c0 d1       	brne	80002e56 <phy_rx_func+0x18a>
80002e3e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002e42:	90 09       	ld.sh	r9,r8[0x0]
80002e44:	f4 09 19 00 	cp.h	r9,r10
80002e48:	c0 71       	brne	80002e56 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002e4a:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002e4e:	70 0c       	ld.w	r12,r8[0x0]
80002e50:	f0 1f 03 49 	mcall	80003b74 <phy_rx_func+0xea8>
80002e54:	c0 98       	rjmp	80002e66 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002e56:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002e5a:	70 0c       	ld.w	r12,r8[0x0]
80002e5c:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002e60:	70 0b       	ld.w	r11,r8[0x0]
80002e62:	f0 1f 03 43 	mcall	80003b6c <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002e66:	30 09       	mov	r9,0
80002e68:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002e6c:	91 09       	st.w	r8[0x0],r9
80002e6e:	c3 e8       	rjmp	80002eea <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002e70:	5c 86       	casts.h	r6
80002e72:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002e76:	92 0a       	ld.sh	r10,r9[0x0]
80002e78:	0c 0a       	add	r10,r6
80002e7a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e7c:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002e80:	72 09       	ld.w	r9,r9[0x0]
80002e82:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002e86:	2f f8       	sub	r8,-1
80002e88:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002e8c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002e8e:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002e92:	92 08       	ld.sh	r8,r9[0x0]
80002e94:	20 28       	sub	r8,2
80002e96:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002e98:	30 09       	mov	r9,0
80002e9a:	f2 08 19 00 	cp.h	r8,r9
80002e9e:	e0 89 00 26 	brgt	80002eea <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002ea2:	30 39       	mov	r9,3
80002ea4:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002ea8:	91 09       	st.w	r8[0x0],r9
80002eaa:	c2 08       	rjmp	80002eea <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002eac:	e6 16 00 ff 	andh	r6,0xff,COH
80002eb0:	fc 19 00 ba 	movh	r9,0xba
80002eb4:	12 36       	cp.w	r6,r9
80002eb6:	c0 e1       	brne	80002ed2 <phy_rx_func+0x206>
80002eb8:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002ebc:	90 09       	ld.sh	r9,r8[0x0]
80002ebe:	30 08       	mov	r8,0
80002ec0:	f0 09 19 00 	cp.h	r9,r8
80002ec4:	c0 71       	brne	80002ed2 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002ec6:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002eca:	70 0c       	ld.w	r12,r8[0x0]
80002ecc:	f0 1f 03 2a 	mcall	80003b74 <phy_rx_func+0xea8>
80002ed0:	c0 98       	rjmp	80002ee2 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002ed2:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002ed6:	70 0c       	ld.w	r12,r8[0x0]
80002ed8:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002edc:	70 0b       	ld.w	r11,r8[0x0]
80002ede:	f0 1f 03 24 	mcall	80003b6c <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002ee2:	30 09       	mov	r9,0
80002ee4:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002ee8:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002eea:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002eee:	11 89       	ld.ub	r9,r8[0x0]
80002ef0:	30 08       	mov	r8,0
80002ef2:	f0 09 18 00 	cp.b	r9,r8
80002ef6:	c1 31       	brne	80002f1c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002ef8:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002efc:	6c 0c       	ld.w	r12,r6[0x0]
80002efe:	f0 1f 03 1a 	mcall	80003b64 <phy_rx_func+0xe98>
80002f02:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002f06:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002f08:	6c 0c       	ld.w	r12,r6[0x0]
80002f0a:	f0 1f 03 17 	mcall	80003b64 <phy_rx_func+0xe98>
80002f0e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002f12:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002f14:	30 19       	mov	r9,1
80002f16:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002f1a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002f1c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002f20:	70 08       	ld.w	r8,r8[0x0]
80002f22:	58 28       	cp.w	r8,2
80002f24:	e0 80 01 98 	breq	80003254 <phy_rx_func+0x588>
80002f28:	e0 8b 00 06 	brhi	80002f34 <phy_rx_func+0x268>
80002f2c:	58 08       	cp.w	r8,0
80002f2e:	c0 b0       	breq	80002f44 <phy_rx_func+0x278>
80002f30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f34:	58 38       	cp.w	r8,3
80002f36:	e0 80 05 c5 	breq	80003ac0 <phy_rx_func+0xdf4>
80002f3a:	58 48       	cp.w	r8,4
80002f3c:	e0 81 06 05 	brne	80003b46 <phy_rx_func+0xe7a>
80002f40:	e0 8f 02 4b 	bral	800033d6 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002f44:	6e 28       	ld.w	r8,r7[0x8]
80002f46:	e0 6a 5a 5a 	mov	r10,23130
80002f4a:	ea 1a ab cd 	orh	r10,0xabcd
80002f4e:	14 38       	cp.w	r8,r10
80002f50:	c0 71       	brne	80002f5e <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002f52:	30 09       	mov	r9,0
80002f54:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002f58:	91 09       	st.w	r8[0x0],r9
80002f5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002f5e:	10 99       	mov	r9,r8
80002f60:	e0 19 00 00 	andl	r9,0x0
80002f64:	fc 1a ab cd 	movh	r10,0xabcd
80002f68:	14 39       	cp.w	r9,r10
80002f6a:	e0 81 05 ee 	brne	80003b46 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002f6e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002f72:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002f76:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002f78:	6e 29       	ld.w	r9,r7[0x8]
80002f7a:	e2 19 f0 00 	andl	r9,0xf000,COH
80002f7e:	e0 49 c0 00 	cp.w	r9,49152
80002f82:	e0 81 00 ce 	brne	8000311e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002f86:	30 1a       	mov	r10,1
80002f88:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002f8c:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002f8e:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002f92:	72 09       	ld.w	r9,r9[0x0]
80002f94:	58 09       	cp.w	r9,0
80002f96:	c0 71       	brne	80002fa4 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002f98:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002f9c:	f0 1f 03 00 	mcall	80003b9c <phy_rx_func+0xed0>
80002fa0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002fa4:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002fa8:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002fac:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002fae:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002fb2:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002fb6:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002fba:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002fbc:	13 89       	ld.ub	r9,r9[0x0]
80002fbe:	37 fa       	mov	r10,127
80002fc0:	f4 09 18 00 	cp.b	r9,r10
80002fc4:	c6 d0       	breq	8000309e <phy_rx_func+0x3d2>
80002fc6:	e0 8b 00 0c 	brhi	80002fde <phy_rx_func+0x312>
80002fca:	31 2a       	mov	r10,18
80002fcc:	f4 09 18 00 	cp.b	r9,r10
80002fd0:	c4 20       	breq	80003054 <phy_rx_func+0x388>
80002fd2:	31 3a       	mov	r10,19
80002fd4:	f4 09 18 00 	cp.b	r9,r10
80002fd8:	e0 81 00 83 	brne	800030de <phy_rx_func+0x412>
80002fdc:	c5 b8       	rjmp	80003092 <phy_rx_func+0x3c6>
80002fde:	2f 09       	sub	r9,-16
80002fe0:	30 1a       	mov	r10,1
80002fe2:	f4 09 18 00 	cp.b	r9,r10
80002fe6:	e0 8b 00 7c 	brhi	800030de <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002fea:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002fee:	e2 18 00 f0 	andl	r8,0xf0,COH
80002ff2:	59 08       	cp.w	r8,16
80002ff4:	c0 71       	brne	80003002 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002ff6:	30 19       	mov	r9,1
80002ff8:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002ffc:	91 09       	st.w	r8[0x0],r9
80002ffe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003002:	e0 48 00 20 	cp.w	r8,32
80003006:	c2 11       	brne	80003048 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003008:	30 a9       	mov	r9,10
8000300a:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000300e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003010:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003014:	6c 08       	ld.w	r8,r6[0x0]
80003016:	f0 0a 11 ff 	rsub	r10,r8,-1
8000301a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000301e:	2f f8       	sub	r8,-1
80003020:	6e 0c       	ld.w	r12,r7[0x0]
80003022:	f4 ca fe 00 	sub	r10,r10,-512
80003026:	30 0b       	mov	r11,0
80003028:	10 0c       	add	r12,r8
8000302a:	f0 1f 02 e1 	mcall	80003bac <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000302e:	30 08       	mov	r8,0
80003030:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003032:	6e 0c       	ld.w	r12,r7[0x0]
80003034:	f0 1f 02 df 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003038:	fe f8 0b 44 	ld.w	r8,pc[2884]
8000303c:	70 0c       	ld.w	r12,r8[0x0]
8000303e:	f0 1f 02 ca 	mcall	80003b64 <phy_rx_func+0xe98>
80003042:	8f 0c       	st.w	r7[0x0],r12
80003044:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003048:	30 09       	mov	r9,0
8000304a:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000304e:	91 09       	st.w	r8[0x0],r9
80003050:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003054:	20 48       	sub	r8,4
80003056:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000305a:	93 08       	st.w	r9[0x0],r8
8000305c:	58 08       	cp.w	r8,0
8000305e:	e0 80 05 74 	breq	80003b46 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003062:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003066:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000306a:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000306e:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003070:	8e 69       	ld.sh	r9,r7[0xc]
80003072:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003076:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003078:	8e 79       	ld.sh	r9,r7[0xe]
8000307a:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000307c:	f0 1f 02 d0 	mcall	80003bbc <phy_rx_func+0xef0>
80003080:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003084:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003086:	30 49       	mov	r9,4
80003088:	fe f8 0b 00 	ld.w	r8,pc[2816]
8000308c:	91 09       	st.w	r8[0x0],r9
8000308e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003092:	30 09       	mov	r9,0
80003094:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003098:	91 09       	st.w	r8[0x0],r9
8000309a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000309e:	20 48       	sub	r8,4
800030a0:	fe f9 0a f0 	ld.w	r9,pc[2800]
800030a4:	93 08       	st.w	r9[0x0],r8
800030a6:	58 08       	cp.w	r8,0
800030a8:	e0 80 05 4f 	breq	80003b46 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800030ac:	fe f8 0b 14 	ld.w	r8,pc[2836]
800030b0:	70 09       	ld.w	r9,r8[0x0]
800030b2:	8e 7b       	ld.sh	r11,r7[0xe]
800030b4:	fe fa 0b 10 	ld.w	r10,pc[2832]
800030b8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800030bc:	2f f9       	sub	r9,-1
800030be:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800030c0:	fe f8 0a e4 	ld.w	r8,pc[2788]
800030c4:	70 09       	ld.w	r9,r8[0x0]
800030c6:	20 29       	sub	r9,2
800030c8:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800030ca:	30 29       	mov	r9,2
800030cc:	fe f8 0a c0 	ld.w	r8,pc[2752]
800030d0:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800030d2:	30 39       	mov	r9,3
800030d4:	fe f8 0a b4 	ld.w	r8,pc[2740]
800030d8:	91 09       	st.w	r8[0x0],r9
800030da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800030de:	30 3a       	mov	r10,3
800030e0:	fe f9 0a ac 	ld.w	r9,pc[2732]
800030e4:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800030e6:	6e 2a       	ld.w	r10,r7[0x8]
800030e8:	fe f9 0a e0 	ld.w	r9,pc[2784]
800030ec:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800030ee:	6e 3a       	ld.w	r10,r7[0xc]
800030f0:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800030f2:	59 48       	cp.w	r8,20
800030f4:	c0 61       	brne	80003100 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800030f6:	31 89       	mov	r9,24
800030f8:	fe f8 0a 98 	ld.w	r8,pc[2712]
800030fc:	91 09       	st.w	r8[0x0],r9
800030fe:	c0 a8       	rjmp	80003112 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003100:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003104:	70 08       	ld.w	r8,r8[0x0]
80003106:	59 08       	cp.w	r8,16
80003108:	c0 51       	brne	80003112 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000310a:	31 09       	mov	r9,16
8000310c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003110:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003112:	30 49       	mov	r9,4
80003114:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003118:	91 09       	st.w	r8[0x0],r9
8000311a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000311e:	e0 49 10 00 	cp.w	r9,4096
80003122:	5f 1a       	srne	r10
80003124:	e0 49 20 00 	cp.w	r9,8192
80003128:	5f 19       	srne	r9
8000312a:	f5 e9 00 09 	and	r9,r10,r9
8000312e:	e0 81 05 0c 	brne	80003b46 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003132:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003136:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003138:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000313c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000313e:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003142:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003144:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003148:	72 09       	ld.w	r9,r9[0x0]
8000314a:	58 09       	cp.w	r9,0
8000314c:	c0 71       	brne	8000315a <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000314e:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003152:	f0 1f 02 93 	mcall	80003b9c <phy_rx_func+0xed0>
80003156:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000315a:	6e 2a       	ld.w	r10,r7[0x8]
8000315c:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003160:	58 1a       	cp.w	r10,1
80003162:	e0 8b 00 4d 	brhi	800031fc <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003166:	20 48       	sub	r8,4
80003168:	fe f9 0a 28 	ld.w	r9,pc[2600]
8000316c:	93 08       	st.w	r9[0x0],r8
8000316e:	58 08       	cp.w	r8,0
80003170:	e0 80 04 eb 	breq	80003b46 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003174:	8e 68       	ld.sh	r8,r7[0xc]
80003176:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000317a:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000317e:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003180:	30 09       	mov	r9,0
80003182:	f2 08 19 00 	cp.h	r8,r9
80003186:	c0 70       	breq	80003194 <phy_rx_func+0x4c8>
80003188:	30 19       	mov	r9,1
8000318a:	f2 08 19 00 	cp.h	r8,r9
8000318e:	e0 81 04 dc 	brne	80003b46 <phy_rx_func+0xe7a>
80003192:	c2 68       	rjmp	800031de <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003194:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003198:	70 0a       	ld.w	r10,r8[0x0]
8000319a:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000319e:	72 09       	ld.w	r9,r9[0x0]
800031a0:	8e 7b       	ld.sh	r11,r7[0xe]
800031a2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800031a6:	70 09       	ld.w	r9,r8[0x0]
800031a8:	2f f9       	sub	r9,-1
800031aa:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031ac:	e0 49 00 ff 	cp.w	r9,255
800031b0:	e0 88 00 11 	brls	800031d2 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800031b4:	30 09       	mov	r9,0
800031b6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800031b8:	fe f7 09 c8 	ld.w	r7,pc[2504]
800031bc:	6e 0c       	ld.w	r12,r7[0x0]
800031be:	f0 1f 02 7d 	mcall	80003bb0 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800031c2:	fe f8 09 ba 	ld.w	r8,pc[2490]
800031c6:	70 0c       	ld.w	r12,r8[0x0]
800031c8:	f0 1f 02 67 	mcall	80003b64 <phy_rx_func+0xe98>
800031cc:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800031ce:	e0 80 04 bc 	breq	80003b46 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800031d2:	30 29       	mov	r9,2
800031d4:	fe f8 09 b4 	ld.w	r8,pc[2484]
800031d8:	91 09       	st.w	r8[0x0],r9
800031da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800031de:	8e 79       	ld.sh	r9,r7[0xe]
800031e0:	30 38       	mov	r8,3
800031e2:	f0 09 19 00 	cp.h	r9,r8
800031e6:	c0 51       	brne	800031f0 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800031e8:	30 19       	mov	r9,1
800031ea:	fe f8 09 f2 	ld.w	r8,pc[2546]
800031ee:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800031f0:	30 29       	mov	r9,2
800031f2:	fe f8 09 96 	ld.w	r8,pc[2454]
800031f6:	91 09       	st.w	r8[0x0],r9
800031f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800031fc:	58 18       	cp.w	r8,1
800031fe:	e0 88 04 a4 	brls	80003b46 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003202:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003206:	70 0a       	ld.w	r10,r8[0x0]
80003208:	6e 3b       	ld.w	r11,r7[0xc]
8000320a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000320e:	70 09       	ld.w	r9,r8[0x0]
80003210:	2f f9       	sub	r9,-1
80003212:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003214:	e0 49 00 ff 	cp.w	r9,255
80003218:	e0 88 00 11 	brls	8000323a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000321c:	30 09       	mov	r9,0
8000321e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003220:	fe f7 09 60 	ld.w	r7,pc[2400]
80003224:	6e 0c       	ld.w	r12,r7[0x0]
80003226:	f0 1f 02 63 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000322a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000322e:	70 0c       	ld.w	r12,r8[0x0]
80003230:	f0 1f 02 4d 	mcall	80003b64 <phy_rx_func+0xe98>
80003234:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003236:	e0 80 04 88 	breq	80003b46 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000323a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000323e:	72 08       	ld.w	r8,r9[0x0]
80003240:	20 28       	sub	r8,2
80003242:	93 08       	st.w	r9[0x0],r8
80003244:	e0 80 04 81 	breq	80003b46 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003248:	30 29       	mov	r9,2
8000324a:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000324e:	91 09       	st.w	r8[0x0],r9
80003250:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003254:	fe f8 09 84 	ld.w	r8,pc[2436]
80003258:	70 0a       	ld.w	r10,r8[0x0]
8000325a:	fe f9 09 26 	ld.w	r9,pc[2342]
8000325e:	72 09       	ld.w	r9,r9[0x0]
80003260:	8e 4b       	ld.sh	r11,r7[0x8]
80003262:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003266:	70 09       	ld.w	r9,r8[0x0]
80003268:	2f f9       	sub	r9,-1
8000326a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000326c:	e0 49 00 ff 	cp.w	r9,255
80003270:	e0 88 00 16 	brls	8000329c <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003274:	30 09       	mov	r9,0
80003276:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003278:	fe f6 09 08 	ld.w	r6,pc[2312]
8000327c:	6c 0c       	ld.w	r12,r6[0x0]
8000327e:	f0 1f 02 4d 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003282:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003286:	70 0c       	ld.w	r12,r8[0x0]
80003288:	f0 1f 02 37 	mcall	80003b64 <phy_rx_func+0xe98>
8000328c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000328e:	c0 71       	brne	8000329c <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003290:	30 09       	mov	r9,0
80003292:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003296:	91 09       	st.w	r8[0x0],r9
80003298:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
8000329c:	fe f9 08 f4 	ld.w	r9,pc[2292]
800032a0:	72 08       	ld.w	r8,r9[0x0]
800032a2:	20 28       	sub	r8,2
800032a4:	93 08       	st.w	r9[0x0],r8
800032a6:	c0 71       	brne	800032b4 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800032a8:	30 09       	mov	r9,0
800032aa:	fe f8 08 de 	ld.w	r8,pc[2270]
800032ae:	91 09       	st.w	r8[0x0],r9
800032b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800032b4:	fe f8 09 24 	ld.w	r8,pc[2340]
800032b8:	70 0a       	ld.w	r10,r8[0x0]
800032ba:	fe f9 08 c6 	ld.w	r9,pc[2246]
800032be:	72 09       	ld.w	r9,r9[0x0]
800032c0:	8e 5b       	ld.sh	r11,r7[0xa]
800032c2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032c6:	70 09       	ld.w	r9,r8[0x0]
800032c8:	2f f9       	sub	r9,-1
800032ca:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032cc:	e0 49 00 ff 	cp.w	r9,255
800032d0:	e0 88 00 16 	brls	800032fc <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800032d4:	30 09       	mov	r9,0
800032d6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032d8:	fe f6 08 a8 	ld.w	r6,pc[2216]
800032dc:	6c 0c       	ld.w	r12,r6[0x0]
800032de:	f0 1f 02 35 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032e2:	fe f8 08 9a 	ld.w	r8,pc[2202]
800032e6:	70 0c       	ld.w	r12,r8[0x0]
800032e8:	f0 1f 02 1f 	mcall	80003b64 <phy_rx_func+0xe98>
800032ec:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032ee:	c0 71       	brne	800032fc <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800032f0:	30 09       	mov	r9,0
800032f2:	fe f8 08 96 	ld.w	r8,pc[2198]
800032f6:	91 09       	st.w	r8[0x0],r9
800032f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032fc:	fe f9 08 94 	ld.w	r9,pc[2196]
80003300:	72 08       	ld.w	r8,r9[0x0]
80003302:	20 28       	sub	r8,2
80003304:	93 08       	st.w	r9[0x0],r8
80003306:	c0 71       	brne	80003314 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003308:	30 09       	mov	r9,0
8000330a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000330e:	91 09       	st.w	r8[0x0],r9
80003310:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003314:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003318:	70 0a       	ld.w	r10,r8[0x0]
8000331a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000331e:	72 09       	ld.w	r9,r9[0x0]
80003320:	8e 6b       	ld.sh	r11,r7[0xc]
80003322:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003326:	70 09       	ld.w	r9,r8[0x0]
80003328:	2f f9       	sub	r9,-1
8000332a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000332c:	e0 49 00 ff 	cp.w	r9,255
80003330:	e0 88 00 16 	brls	8000335c <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003334:	30 09       	mov	r9,0
80003336:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003338:	fe f6 08 48 	ld.w	r6,pc[2120]
8000333c:	6c 0c       	ld.w	r12,r6[0x0]
8000333e:	f0 1f 02 1d 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003342:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003346:	70 0c       	ld.w	r12,r8[0x0]
80003348:	f0 1f 02 07 	mcall	80003b64 <phy_rx_func+0xe98>
8000334c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000334e:	c0 71       	brne	8000335c <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003350:	30 09       	mov	r9,0
80003352:	fe f8 08 36 	ld.w	r8,pc[2102]
80003356:	91 09       	st.w	r8[0x0],r9
80003358:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000335c:	fe f9 08 34 	ld.w	r9,pc[2100]
80003360:	72 08       	ld.w	r8,r9[0x0]
80003362:	20 28       	sub	r8,2
80003364:	93 08       	st.w	r9[0x0],r8
80003366:	c0 71       	brne	80003374 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003368:	30 09       	mov	r9,0
8000336a:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000336e:	91 09       	st.w	r8[0x0],r9
80003370:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003374:	fe f8 08 64 	ld.w	r8,pc[2148]
80003378:	70 0a       	ld.w	r10,r8[0x0]
8000337a:	fe f9 08 06 	ld.w	r9,pc[2054]
8000337e:	72 09       	ld.w	r9,r9[0x0]
80003380:	8e 7b       	ld.sh	r11,r7[0xe]
80003382:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003386:	70 09       	ld.w	r9,r8[0x0]
80003388:	2f f9       	sub	r9,-1
8000338a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000338c:	e0 49 00 ff 	cp.w	r9,255
80003390:	e0 88 00 16 	brls	800033bc <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003394:	30 09       	mov	r9,0
80003396:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003398:	fe f7 07 e8 	ld.w	r7,pc[2024]
8000339c:	6e 0c       	ld.w	r12,r7[0x0]
8000339e:	f0 1f 02 05 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033a2:	fe f8 07 da 	ld.w	r8,pc[2010]
800033a6:	70 0c       	ld.w	r12,r8[0x0]
800033a8:	f0 1f 01 ef 	mcall	80003b64 <phy_rx_func+0xe98>
800033ac:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800033ae:	c0 71       	brne	800033bc <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800033b0:	30 09       	mov	r9,0
800033b2:	fe f8 07 d6 	ld.w	r8,pc[2006]
800033b6:	91 09       	st.w	r8[0x0],r9
800033b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800033bc:	fe f9 07 d4 	ld.w	r9,pc[2004]
800033c0:	72 08       	ld.w	r8,r9[0x0]
800033c2:	20 28       	sub	r8,2
800033c4:	93 08       	st.w	r9[0x0],r8
800033c6:	e0 81 03 c0 	brne	80003b46 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800033ca:	30 09       	mov	r9,0
800033cc:	fe f8 07 bc 	ld.w	r8,pc[1980]
800033d0:	91 09       	st.w	r8[0x0],r9
800033d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800033d6:	fe f8 07 ca 	ld.w	r8,pc[1994]
800033da:	11 89       	ld.ub	r9,r8[0x0]
800033dc:	31 28       	mov	r8,18
800033de:	f0 09 18 00 	cp.b	r9,r8
800033e2:	e0 81 01 4c 	brne	8000367a <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800033e6:	ef 39 00 09 	ld.ub	r9,r7[9]
800033ea:	fe f8 07 b6 	ld.w	r8,pc[1974]
800033ee:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800033f0:	11 89       	ld.ub	r9,r8[0x0]
800033f2:	3f 28       	mov	r8,-14
800033f4:	f0 09 18 00 	cp.b	r9,r8
800033f8:	e0 81 01 3b 	brne	8000366e <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800033fc:	30 19       	mov	r9,1
800033fe:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003402:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003404:	6e 29       	ld.w	r9,r7[0x8]
80003406:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000340a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000340e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003410:	8e 59       	ld.sh	r9,r7[0xa]
80003412:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003416:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003418:	8e 69       	ld.sh	r9,r7[0xc]
8000341a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000341c:	8e 79       	ld.sh	r9,r7[0xe]
8000341e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003420:	fe f8 07 88 	ld.w	r8,pc[1928]
80003424:	fe f9 07 60 	ld.w	r9,pc[1888]
80003428:	72 0a       	ld.w	r10,r9[0x0]
8000342a:	70 09       	ld.w	r9,r8[0x0]
8000342c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003430:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003434:	70 09       	ld.w	r9,r8[0x0]
80003436:	2f f9       	sub	r9,-1
80003438:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000343a:	e0 49 01 ff 	cp.w	r9,511
8000343e:	e0 88 00 16 	brls	8000346a <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003442:	30 09       	mov	r9,0
80003444:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003446:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000344a:	6c 0c       	ld.w	r12,r6[0x0]
8000344c:	f0 1f 01 d9 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003450:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003454:	70 0c       	ld.w	r12,r8[0x0]
80003456:	f0 1f 01 c4 	mcall	80003b64 <phy_rx_func+0xe98>
8000345a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000345c:	c0 71       	brne	8000346a <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000345e:	30 09       	mov	r9,0
80003460:	fe f8 07 28 	ld.w	r8,pc[1832]
80003464:	91 09       	st.w	r8[0x0],r9
80003466:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000346a:	fe f9 07 26 	ld.w	r9,pc[1830]
8000346e:	72 08       	ld.w	r8,r9[0x0]
80003470:	20 18       	sub	r8,1
80003472:	93 08       	st.w	r9[0x0],r8
80003474:	c0 71       	brne	80003482 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003476:	30 09       	mov	r9,0
80003478:	fe f8 07 10 	ld.w	r8,pc[1808]
8000347c:	91 09       	st.w	r8[0x0],r9
8000347e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003482:	fe f8 07 26 	ld.w	r8,pc[1830]
80003486:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000348a:	72 0a       	ld.w	r10,r9[0x0]
8000348c:	70 09       	ld.w	r9,r8[0x0]
8000348e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003492:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003496:	70 09       	ld.w	r9,r8[0x0]
80003498:	2f f9       	sub	r9,-1
8000349a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000349c:	e0 49 01 ff 	cp.w	r9,511
800034a0:	e0 88 00 16 	brls	800034cc <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800034a4:	30 09       	mov	r9,0
800034a6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034a8:	fe f6 06 dc 	ld.w	r6,pc[1756]
800034ac:	6c 0c       	ld.w	r12,r6[0x0]
800034ae:	f0 1f 01 c1 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034b2:	fe f8 06 ca 	ld.w	r8,pc[1738]
800034b6:	70 0c       	ld.w	r12,r8[0x0]
800034b8:	f0 1f 01 ab 	mcall	80003b64 <phy_rx_func+0xe98>
800034bc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034be:	c0 71       	brne	800034cc <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800034c0:	30 09       	mov	r9,0
800034c2:	fe f8 06 c6 	ld.w	r8,pc[1734]
800034c6:	91 09       	st.w	r8[0x0],r9
800034c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034cc:	fe f9 06 c4 	ld.w	r9,pc[1732]
800034d0:	72 08       	ld.w	r8,r9[0x0]
800034d2:	20 18       	sub	r8,1
800034d4:	93 08       	st.w	r9[0x0],r8
800034d6:	c0 71       	brne	800034e4 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800034d8:	30 09       	mov	r9,0
800034da:	fe f8 06 ae 	ld.w	r8,pc[1710]
800034de:	91 09       	st.w	r8[0x0],r9
800034e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800034e4:	fe f8 06 c4 	ld.w	r8,pc[1732]
800034e8:	fe f9 06 9c 	ld.w	r9,pc[1692]
800034ec:	72 0a       	ld.w	r10,r9[0x0]
800034ee:	70 09       	ld.w	r9,r8[0x0]
800034f0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800034f4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034f8:	70 09       	ld.w	r9,r8[0x0]
800034fa:	2f f9       	sub	r9,-1
800034fc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034fe:	e0 49 01 ff 	cp.w	r9,511
80003502:	e0 88 00 16 	brls	8000352e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003506:	30 09       	mov	r9,0
80003508:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000350a:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000350e:	6c 0c       	ld.w	r12,r6[0x0]
80003510:	f0 1f 01 a8 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003514:	fe f8 06 68 	ld.w	r8,pc[1640]
80003518:	70 0c       	ld.w	r12,r8[0x0]
8000351a:	f0 1f 01 93 	mcall	80003b64 <phy_rx_func+0xe98>
8000351e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003520:	c0 71       	brne	8000352e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003522:	30 09       	mov	r9,0
80003524:	fe f8 06 64 	ld.w	r8,pc[1636]
80003528:	91 09       	st.w	r8[0x0],r9
8000352a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000352e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003532:	72 08       	ld.w	r8,r9[0x0]
80003534:	20 18       	sub	r8,1
80003536:	93 08       	st.w	r9[0x0],r8
80003538:	c0 71       	brne	80003546 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000353a:	30 09       	mov	r9,0
8000353c:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003540:	91 09       	st.w	r8[0x0],r9
80003542:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003546:	fe f8 06 62 	ld.w	r8,pc[1634]
8000354a:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000354e:	72 0a       	ld.w	r10,r9[0x0]
80003550:	70 09       	ld.w	r9,r8[0x0]
80003552:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003556:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000355a:	70 09       	ld.w	r9,r8[0x0]
8000355c:	2f f9       	sub	r9,-1
8000355e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003560:	e0 49 01 ff 	cp.w	r9,511
80003564:	e0 88 00 16 	brls	80003590 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003568:	30 09       	mov	r9,0
8000356a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000356c:	fe f6 06 18 	ld.w	r6,pc[1560]
80003570:	6c 0c       	ld.w	r12,r6[0x0]
80003572:	f0 1f 01 90 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003576:	fe f8 06 06 	ld.w	r8,pc[1542]
8000357a:	70 0c       	ld.w	r12,r8[0x0]
8000357c:	f0 1f 01 7a 	mcall	80003b64 <phy_rx_func+0xe98>
80003580:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003582:	c0 71       	brne	80003590 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003584:	30 09       	mov	r9,0
80003586:	fe f8 06 02 	ld.w	r8,pc[1538]
8000358a:	91 09       	st.w	r8[0x0],r9
8000358c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003590:	fe f9 06 00 	ld.w	r9,pc[1536]
80003594:	72 08       	ld.w	r8,r9[0x0]
80003596:	20 18       	sub	r8,1
80003598:	93 08       	st.w	r9[0x0],r8
8000359a:	c0 71       	brne	800035a8 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
8000359c:	30 09       	mov	r9,0
8000359e:	fe f8 05 ea 	ld.w	r8,pc[1514]
800035a2:	91 09       	st.w	r8[0x0],r9
800035a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800035a8:	fe f8 06 00 	ld.w	r8,pc[1536]
800035ac:	fe f9 05 d8 	ld.w	r9,pc[1496]
800035b0:	72 0a       	ld.w	r10,r9[0x0]
800035b2:	70 09       	ld.w	r9,r8[0x0]
800035b4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800035b8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035bc:	70 09       	ld.w	r9,r8[0x0]
800035be:	2f f9       	sub	r9,-1
800035c0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035c2:	e0 49 01 ff 	cp.w	r9,511
800035c6:	e0 88 00 16 	brls	800035f2 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800035ca:	30 09       	mov	r9,0
800035cc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035ce:	fe f6 05 b6 	ld.w	r6,pc[1462]
800035d2:	6c 0c       	ld.w	r12,r6[0x0]
800035d4:	f0 1f 01 77 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035d8:	fe f8 05 a4 	ld.w	r8,pc[1444]
800035dc:	70 0c       	ld.w	r12,r8[0x0]
800035de:	f0 1f 01 62 	mcall	80003b64 <phy_rx_func+0xe98>
800035e2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035e4:	c0 71       	brne	800035f2 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800035e6:	30 09       	mov	r9,0
800035e8:	fe f8 05 a0 	ld.w	r8,pc[1440]
800035ec:	91 09       	st.w	r8[0x0],r9
800035ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035f2:	fe f9 05 9e 	ld.w	r9,pc[1438]
800035f6:	72 08       	ld.w	r8,r9[0x0]
800035f8:	20 18       	sub	r8,1
800035fa:	93 08       	st.w	r9[0x0],r8
800035fc:	c0 71       	brne	8000360a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800035fe:	30 09       	mov	r9,0
80003600:	fe f8 05 88 	ld.w	r8,pc[1416]
80003604:	91 09       	st.w	r8[0x0],r9
80003606:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000360a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000360e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003612:	72 0a       	ld.w	r10,r9[0x0]
80003614:	70 09       	ld.w	r9,r8[0x0]
80003616:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000361a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000361e:	70 09       	ld.w	r9,r8[0x0]
80003620:	2f f9       	sub	r9,-1
80003622:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003624:	e0 49 01 ff 	cp.w	r9,511
80003628:	e0 88 00 16 	brls	80003654 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000362c:	30 09       	mov	r9,0
8000362e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003630:	fe f7 05 54 	ld.w	r7,pc[1364]
80003634:	6e 0c       	ld.w	r12,r7[0x0]
80003636:	f0 1f 01 5f 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000363a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000363e:	70 0c       	ld.w	r12,r8[0x0]
80003640:	f0 1f 01 49 	mcall	80003b64 <phy_rx_func+0xe98>
80003644:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003646:	c0 71       	brne	80003654 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003648:	30 09       	mov	r9,0
8000364a:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000364e:	91 09       	st.w	r8[0x0],r9
80003650:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003654:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003658:	72 08       	ld.w	r8,r9[0x0]
8000365a:	20 18       	sub	r8,1
8000365c:	93 08       	st.w	r9[0x0],r8
8000365e:	e0 81 02 74 	brne	80003b46 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003662:	30 09       	mov	r9,0
80003664:	fe f8 05 24 	ld.w	r8,pc[1316]
80003668:	91 09       	st.w	r8[0x0],r9
8000366a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000366e:	30 09       	mov	r9,0
80003670:	fe f8 05 18 	ld.w	r8,pc[1304]
80003674:	91 09       	st.w	r8[0x0],r9
80003676:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000367a:	fe f8 05 26 	ld.w	r8,pc[1318]
8000367e:	11 89       	ld.ub	r9,r8[0x0]
80003680:	3f 28       	mov	r8,-14
80003682:	f0 09 18 00 	cp.b	r9,r8
80003686:	c4 31       	brne	8000370c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003688:	8e 49       	ld.sh	r9,r7[0x8]
8000368a:	fe f8 05 56 	ld.w	r8,pc[1366]
8000368e:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003690:	fe f8 05 18 	ld.w	r8,pc[1304]
80003694:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003698:	72 0a       	ld.w	r10,r9[0x0]
8000369a:	70 09       	ld.w	r9,r8[0x0]
8000369c:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036a0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036a4:	70 09       	ld.w	r9,r8[0x0]
800036a6:	2f f9       	sub	r9,-1
800036a8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036aa:	e0 49 01 ff 	cp.w	r9,511
800036ae:	e0 88 00 16 	brls	800036da <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800036b2:	30 09       	mov	r9,0
800036b4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036b6:	fe f7 04 ce 	ld.w	r7,pc[1230]
800036ba:	6e 0c       	ld.w	r12,r7[0x0]
800036bc:	f0 1f 01 3d 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036c0:	fe f8 04 bc 	ld.w	r8,pc[1212]
800036c4:	70 0c       	ld.w	r12,r8[0x0]
800036c6:	f0 1f 01 28 	mcall	80003b64 <phy_rx_func+0xe98>
800036ca:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036cc:	c0 71       	brne	800036da <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800036ce:	30 09       	mov	r9,0
800036d0:	fe f8 04 b8 	ld.w	r8,pc[1208]
800036d4:	91 09       	st.w	r8[0x0],r9
800036d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036da:	fe f9 04 b6 	ld.w	r9,pc[1206]
800036de:	72 08       	ld.w	r8,r9[0x0]
800036e0:	20 18       	sub	r8,1
800036e2:	93 08       	st.w	r9[0x0],r8
800036e4:	c0 71       	brne	800036f2 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800036e6:	30 09       	mov	r9,0
800036e8:	fe f8 04 a0 	ld.w	r8,pc[1184]
800036ec:	91 09       	st.w	r8[0x0],r9
800036ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800036f2:	20 18       	sub	r8,1
800036f4:	fe f9 04 9c 	ld.w	r9,pc[1180]
800036f8:	93 08       	st.w	r9[0x0],r8
800036fa:	58 08       	cp.w	r8,0
800036fc:	e0 81 02 25 	brne	80003b46 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003700:	30 09       	mov	r9,0
80003702:	fe f8 04 86 	ld.w	r8,pc[1158]
80003706:	91 09       	st.w	r8[0x0],r9
80003708:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000370c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003710:	11 89       	ld.ub	r9,r8[0x0]
80003712:	3f 38       	mov	r8,-13
80003714:	f0 09 18 00 	cp.b	r9,r8
80003718:	e0 81 01 0c 	brne	80003930 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000371c:	8e 49       	ld.sh	r9,r7[0x8]
8000371e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003722:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003724:	8e 59       	ld.sh	r9,r7[0xa]
80003726:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003728:	8e 69       	ld.sh	r9,r7[0xc]
8000372a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000372c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003730:	fe f9 04 54 	ld.w	r9,pc[1108]
80003734:	72 0a       	ld.w	r10,r9[0x0]
80003736:	70 09       	ld.w	r9,r8[0x0]
80003738:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000373c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003740:	70 09       	ld.w	r9,r8[0x0]
80003742:	2f f9       	sub	r9,-1
80003744:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003746:	e0 49 01 ff 	cp.w	r9,511
8000374a:	e0 88 00 16 	brls	80003776 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000374e:	30 09       	mov	r9,0
80003750:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003752:	fe f6 04 32 	ld.w	r6,pc[1074]
80003756:	6c 0c       	ld.w	r12,r6[0x0]
80003758:	f0 1f 01 16 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000375c:	fe f8 04 20 	ld.w	r8,pc[1056]
80003760:	70 0c       	ld.w	r12,r8[0x0]
80003762:	f0 1f 01 01 	mcall	80003b64 <phy_rx_func+0xe98>
80003766:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003768:	c0 71       	brne	80003776 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
8000376a:	30 09       	mov	r9,0
8000376c:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003770:	91 09       	st.w	r8[0x0],r9
80003772:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003776:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000377a:	72 08       	ld.w	r8,r9[0x0]
8000377c:	20 18       	sub	r8,1
8000377e:	93 08       	st.w	r9[0x0],r8
80003780:	c0 71       	brne	8000378e <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003782:	30 09       	mov	r9,0
80003784:	fe f8 04 04 	ld.w	r8,pc[1028]
80003788:	91 09       	st.w	r8[0x0],r9
8000378a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000378e:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003792:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003796:	72 0a       	ld.w	r10,r9[0x0]
80003798:	70 09       	ld.w	r9,r8[0x0]
8000379a:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000379e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037a2:	70 09       	ld.w	r9,r8[0x0]
800037a4:	2f f9       	sub	r9,-1
800037a6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037a8:	e0 49 01 ff 	cp.w	r9,511
800037ac:	e0 88 00 16 	brls	800037d8 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800037b0:	30 09       	mov	r9,0
800037b2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037b4:	fe f6 03 d0 	ld.w	r6,pc[976]
800037b8:	6c 0c       	ld.w	r12,r6[0x0]
800037ba:	f0 1f 00 fe 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037be:	fe f8 03 be 	ld.w	r8,pc[958]
800037c2:	70 0c       	ld.w	r12,r8[0x0]
800037c4:	f0 1f 00 e8 	mcall	80003b64 <phy_rx_func+0xe98>
800037c8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037ca:	c0 71       	brne	800037d8 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800037cc:	30 09       	mov	r9,0
800037ce:	fe f8 03 ba 	ld.w	r8,pc[954]
800037d2:	91 09       	st.w	r8[0x0],r9
800037d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037d8:	fe f9 03 b8 	ld.w	r9,pc[952]
800037dc:	72 08       	ld.w	r8,r9[0x0]
800037de:	20 18       	sub	r8,1
800037e0:	93 08       	st.w	r9[0x0],r8
800037e2:	c0 71       	brne	800037f0 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800037e4:	30 09       	mov	r9,0
800037e6:	fe f8 03 a2 	ld.w	r8,pc[930]
800037ea:	91 09       	st.w	r8[0x0],r9
800037ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800037f0:	fe f8 03 b8 	ld.w	r8,pc[952]
800037f4:	fe f9 03 90 	ld.w	r9,pc[912]
800037f8:	72 0a       	ld.w	r10,r9[0x0]
800037fa:	70 09       	ld.w	r9,r8[0x0]
800037fc:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003800:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003804:	70 09       	ld.w	r9,r8[0x0]
80003806:	2f f9       	sub	r9,-1
80003808:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000380a:	e0 49 01 ff 	cp.w	r9,511
8000380e:	e0 88 00 16 	brls	8000383a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003812:	30 09       	mov	r9,0
80003814:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003816:	fe f6 03 6e 	ld.w	r6,pc[878]
8000381a:	6c 0c       	ld.w	r12,r6[0x0]
8000381c:	f0 1f 00 e5 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003820:	fe f8 03 5c 	ld.w	r8,pc[860]
80003824:	70 0c       	ld.w	r12,r8[0x0]
80003826:	f0 1f 00 d0 	mcall	80003b64 <phy_rx_func+0xe98>
8000382a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000382c:	c0 71       	brne	8000383a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000382e:	30 09       	mov	r9,0
80003830:	fe f8 03 58 	ld.w	r8,pc[856]
80003834:	91 09       	st.w	r8[0x0],r9
80003836:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000383a:	fe f9 03 56 	ld.w	r9,pc[854]
8000383e:	72 08       	ld.w	r8,r9[0x0]
80003840:	20 18       	sub	r8,1
80003842:	93 08       	st.w	r9[0x0],r8
80003844:	c0 71       	brne	80003852 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003846:	30 09       	mov	r9,0
80003848:	fe f8 03 40 	ld.w	r8,pc[832]
8000384c:	91 09       	st.w	r8[0x0],r9
8000384e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003852:	fe f8 03 56 	ld.w	r8,pc[854]
80003856:	fe f9 03 2e 	ld.w	r9,pc[814]
8000385a:	72 0a       	ld.w	r10,r9[0x0]
8000385c:	70 09       	ld.w	r9,r8[0x0]
8000385e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003862:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003866:	70 09       	ld.w	r9,r8[0x0]
80003868:	2f f9       	sub	r9,-1
8000386a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000386c:	e0 49 01 ff 	cp.w	r9,511
80003870:	e0 88 00 16 	brls	8000389c <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003874:	30 09       	mov	r9,0
80003876:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003878:	fe f6 03 0c 	ld.w	r6,pc[780]
8000387c:	6c 0c       	ld.w	r12,r6[0x0]
8000387e:	f0 1f 00 cd 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003882:	fe f8 02 fa 	ld.w	r8,pc[762]
80003886:	70 0c       	ld.w	r12,r8[0x0]
80003888:	f0 1f 00 b7 	mcall	80003b64 <phy_rx_func+0xe98>
8000388c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000388e:	c0 71       	brne	8000389c <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003890:	30 09       	mov	r9,0
80003892:	fe f8 02 f6 	ld.w	r8,pc[758]
80003896:	91 09       	st.w	r8[0x0],r9
80003898:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000389c:	fe f9 02 f4 	ld.w	r9,pc[756]
800038a0:	72 08       	ld.w	r8,r9[0x0]
800038a2:	20 18       	sub	r8,1
800038a4:	93 08       	st.w	r9[0x0],r8
800038a6:	c0 71       	brne	800038b4 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800038a8:	30 09       	mov	r9,0
800038aa:	fe f8 02 de 	ld.w	r8,pc[734]
800038ae:	91 09       	st.w	r8[0x0],r9
800038b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800038b4:	fe f8 02 f4 	ld.w	r8,pc[756]
800038b8:	fe f9 02 cc 	ld.w	r9,pc[716]
800038bc:	72 0a       	ld.w	r10,r9[0x0]
800038be:	70 09       	ld.w	r9,r8[0x0]
800038c0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800038c4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038c8:	70 09       	ld.w	r9,r8[0x0]
800038ca:	2f f9       	sub	r9,-1
800038cc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038ce:	e0 49 01 ff 	cp.w	r9,511
800038d2:	e0 88 00 16 	brls	800038fe <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800038d6:	30 09       	mov	r9,0
800038d8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038da:	fe f7 02 aa 	ld.w	r7,pc[682]
800038de:	6e 0c       	ld.w	r12,r7[0x0]
800038e0:	f0 1f 00 b4 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038e4:	fe f8 02 98 	ld.w	r8,pc[664]
800038e8:	70 0c       	ld.w	r12,r8[0x0]
800038ea:	f0 1f 00 9f 	mcall	80003b64 <phy_rx_func+0xe98>
800038ee:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038f0:	c0 71       	brne	800038fe <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800038f2:	30 09       	mov	r9,0
800038f4:	fe f8 02 94 	ld.w	r8,pc[660]
800038f8:	91 09       	st.w	r8[0x0],r9
800038fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038fe:	fe f9 02 92 	ld.w	r9,pc[658]
80003902:	72 08       	ld.w	r8,r9[0x0]
80003904:	20 18       	sub	r8,1
80003906:	93 08       	st.w	r9[0x0],r8
80003908:	c0 71       	brne	80003916 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000390a:	30 09       	mov	r9,0
8000390c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003910:	91 09       	st.w	r8[0x0],r9
80003912:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003916:	20 18       	sub	r8,1
80003918:	fe f9 02 78 	ld.w	r9,pc[632]
8000391c:	93 08       	st.w	r9[0x0],r8
8000391e:	58 08       	cp.w	r8,0
80003920:	e0 81 01 13 	brne	80003b46 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003924:	30 09       	mov	r9,0
80003926:	fe f8 02 62 	ld.w	r8,pc[610]
8000392a:	91 09       	st.w	r8[0x0],r9
8000392c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003930:	fe f8 02 70 	ld.w	r8,pc[624]
80003934:	11 89       	ld.ub	r9,r8[0x0]
80003936:	30 48       	mov	r8,4
80003938:	f0 09 18 00 	cp.b	r9,r8
8000393c:	c0 80       	breq	8000394c <phy_rx_func+0xc80>
8000393e:	fe f8 02 62 	ld.w	r8,pc[610]
80003942:	11 89       	ld.ub	r9,r8[0x0]
80003944:	30 38       	mov	r8,3
80003946:	f0 09 18 00 	cp.b	r9,r8
8000394a:	c1 41       	brne	80003972 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
8000394c:	6e 29       	ld.w	r9,r7[0x8]
8000394e:	fe f8 02 7a 	ld.w	r8,pc[634]
80003952:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003954:	6e 39       	ld.w	r9,r7[0xc]
80003956:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003958:	fe f9 02 38 	ld.w	r9,pc[568]
8000395c:	72 08       	ld.w	r8,r9[0x0]
8000395e:	20 88       	sub	r8,8
80003960:	93 08       	st.w	r9[0x0],r8
80003962:	e0 81 00 f2 	brne	80003b46 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003966:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003968:	fe f9 02 20 	ld.w	r9,pc[544]
8000396c:	93 08       	st.w	r9[0x0],r8
8000396e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003972:	fe f8 02 2e 	ld.w	r8,pc[558]
80003976:	11 89       	ld.ub	r9,r8[0x0]
80003978:	31 38       	mov	r8,19
8000397a:	f0 09 18 00 	cp.b	r9,r8
8000397e:	e0 81 00 9c 	brne	80003ab6 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003982:	fe f8 02 62 	ld.w	r8,pc[610]
80003986:	11 88       	ld.ub	r8,r8[0x0]
80003988:	30 c9       	mov	r9,12
8000398a:	f2 08 18 00 	cp.b	r8,r9
8000398e:	e0 81 00 7b 	brne	80003a84 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003992:	8e 49       	ld.sh	r9,r7[0x8]
80003994:	fe f8 02 54 	ld.w	r8,pc[596]
80003998:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
8000399c:	30 09       	mov	r9,0
8000399e:	fe f8 02 46 	ld.w	r8,pc[582]
800039a2:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800039a4:	ef 39 00 0d 	ld.ub	r9,r7[13]
800039a8:	3f 38       	mov	r8,-13
800039aa:	f0 09 18 00 	cp.b	r9,r8
800039ae:	c6 61       	brne	80003a7a <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800039b0:	10 99       	mov	r9,r8
800039b2:	4f c8       	lddpc	r8,80003ba0 <phy_rx_func+0xed4>
800039b4:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800039b6:	ef 39 00 0c 	ld.ub	r9,r7[12]
800039ba:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800039be:	4f 58       	lddpc	r8,80003b90 <phy_rx_func+0xec4>
800039c0:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800039c2:	30 19       	mov	r9,1
800039c4:	fe f8 02 0c 	ld.w	r8,pc[524]
800039c8:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800039ca:	8e 79       	ld.sh	r9,r7[0xe]
800039cc:	fe f8 02 14 	ld.w	r8,pc[532]
800039d0:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800039d2:	4f 68       	lddpc	r8,80003ba8 <phy_rx_func+0xedc>
800039d4:	4e c9       	lddpc	r9,80003b84 <phy_rx_func+0xeb8>
800039d6:	72 0a       	ld.w	r10,r9[0x0]
800039d8:	70 09       	ld.w	r9,r8[0x0]
800039da:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800039de:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800039e2:	70 09       	ld.w	r9,r8[0x0]
800039e4:	2f f9       	sub	r9,-1
800039e6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039e8:	e0 49 01 ff 	cp.w	r9,511
800039ec:	e0 88 00 13 	brls	80003a12 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800039f0:	30 09       	mov	r9,0
800039f2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039f4:	4e 46       	lddpc	r6,80003b84 <phy_rx_func+0xeb8>
800039f6:	6c 0c       	ld.w	r12,r6[0x0]
800039f8:	f0 1f 00 6e 	mcall	80003bb0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039fc:	4e 08       	lddpc	r8,80003b7c <phy_rx_func+0xeb0>
800039fe:	70 0c       	ld.w	r12,r8[0x0]
80003a00:	f0 1f 00 59 	mcall	80003b64 <phy_rx_func+0xe98>
80003a04:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a06:	c0 61       	brne	80003a12 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003a08:	30 09       	mov	r9,0
80003a0a:	4e 08       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a0c:	91 09       	st.w	r8[0x0],r9
80003a0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a12:	4e 09       	lddpc	r9,80003b90 <phy_rx_func+0xec4>
80003a14:	72 08       	ld.w	r8,r9[0x0]
80003a16:	20 18       	sub	r8,1
80003a18:	93 08       	st.w	r9[0x0],r8
80003a1a:	c0 61       	brne	80003a26 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003a1c:	30 09       	mov	r9,0
80003a1e:	4d b8       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a20:	91 09       	st.w	r8[0x0],r9
80003a22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003a26:	4e 18       	lddpc	r8,80003ba8 <phy_rx_func+0xedc>
80003a28:	4d 79       	lddpc	r9,80003b84 <phy_rx_func+0xeb8>
80003a2a:	72 0a       	ld.w	r10,r9[0x0]
80003a2c:	70 09       	ld.w	r9,r8[0x0]
80003a2e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a32:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a36:	70 09       	ld.w	r9,r8[0x0]
80003a38:	2f f9       	sub	r9,-1
80003a3a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a3c:	e0 49 01 ff 	cp.w	r9,511
80003a40:	e0 88 00 13 	brls	80003a66 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a44:	30 09       	mov	r9,0
80003a46:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a48:	4c f7       	lddpc	r7,80003b84 <phy_rx_func+0xeb8>
80003a4a:	6e 0c       	ld.w	r12,r7[0x0]
80003a4c:	f0 1f 00 59 	mcall	80003bb0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a50:	4c b8       	lddpc	r8,80003b7c <phy_rx_func+0xeb0>
80003a52:	70 0c       	ld.w	r12,r8[0x0]
80003a54:	f0 1f 00 44 	mcall	80003b64 <phy_rx_func+0xe98>
80003a58:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a5a:	c0 61       	brne	80003a66 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003a5c:	30 09       	mov	r9,0
80003a5e:	4c b8       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a60:	91 09       	st.w	r8[0x0],r9
80003a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a66:	4c b9       	lddpc	r9,80003b90 <phy_rx_func+0xec4>
80003a68:	72 08       	ld.w	r8,r9[0x0]
80003a6a:	20 18       	sub	r8,1
80003a6c:	93 08       	st.w	r9[0x0],r8
80003a6e:	c6 c1       	brne	80003b46 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003a70:	30 09       	mov	r9,0
80003a72:	4c 68       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a74:	91 09       	st.w	r8[0x0],r9
80003a76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003a7a:	30 09       	mov	r9,0
80003a7c:	4c 38       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a7e:	91 09       	st.w	r8[0x0],r9
80003a80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003a84:	8e 4a       	ld.sh	r10,r7[0x8]
80003a86:	4d 99       	lddpc	r9,80003be8 <phy_rx_func+0xf1c>
80003a88:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003a8c:	4d 6a       	lddpc	r10,80003be4 <phy_rx_func+0xf18>
80003a8e:	15 88       	ld.ub	r8,r10[0x0]
80003a90:	f0 cb ff ff 	sub	r11,r8,-1
80003a94:	8e 5c       	ld.sh	r12,r7[0xa]
80003a96:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003a9a:	f0 cb ff fe 	sub	r11,r8,-2
80003a9e:	8e 6c       	ld.sh	r12,r7[0xc]
80003aa0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003aa4:	f0 cb ff fd 	sub	r11,r8,-3
80003aa8:	8e 7c       	ld.sh	r12,r7[0xe]
80003aaa:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003aae:	2f c8       	sub	r8,-4
80003ab0:	b4 88       	st.b	r10[0x0],r8
80003ab2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003ab6:	30 09       	mov	r9,0
80003ab8:	4b 48       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003aba:	91 09       	st.w	r8[0x0],r9
80003abc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003ac0:	4c 08       	lddpc	r8,80003bc0 <phy_rx_func+0xef4>
80003ac2:	70 09       	ld.w	r9,r8[0x0]
80003ac4:	8e 4b       	ld.sh	r11,r7[0x8]
80003ac6:	4c 0a       	lddpc	r10,80003bc4 <phy_rx_func+0xef8>
80003ac8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003acc:	2f f9       	sub	r9,-1
80003ace:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003ad0:	4b 58       	lddpc	r8,80003ba4 <phy_rx_func+0xed8>
80003ad2:	70 09       	ld.w	r9,r8[0x0]
80003ad4:	20 29       	sub	r9,2
80003ad6:	91 09       	st.w	r8[0x0],r9
80003ad8:	70 08       	ld.w	r8,r8[0x0]
80003ada:	58 08       	cp.w	r8,0
80003adc:	c2 f1       	brne	80003b3a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003ade:	30 09       	mov	r9,0
80003ae0:	4b 88       	lddpc	r8,80003bc0 <phy_rx_func+0xef4>
80003ae2:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ae4:	8e 59       	ld.sh	r9,r7[0xa]
80003ae6:	fe 78 82 12 	mov	r8,-32238
80003aea:	f0 09 19 00 	cp.h	r9,r8
80003aee:	c2 11       	brne	80003b30 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003af0:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003af4:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003af8:	4a f8       	lddpc	r8,80003bb4 <phy_rx_func+0xee8>
80003afa:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003afc:	8e 59       	ld.sh	r9,r7[0xa]
80003afe:	4a f8       	lddpc	r8,80003bb8 <phy_rx_func+0xeec>
80003b00:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003b02:	8e 69       	ld.sh	r9,r7[0xc]
80003b04:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003b06:	f0 1f 00 2e 	mcall	80003bbc <phy_rx_func+0xef0>
80003b0a:	4a 18       	lddpc	r8,80003b8c <phy_rx_func+0xec0>
80003b0c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b0e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003b12:	31 38       	mov	r8,19
80003b14:	f0 09 18 00 	cp.b	r9,r8
80003b18:	c0 71       	brne	80003b26 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003b1a:	10 99       	mov	r9,r8
80003b1c:	4a 18       	lddpc	r8,80003ba0 <phy_rx_func+0xed4>
80003b1e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003b20:	30 09       	mov	r9,0
80003b22:	49 c8       	lddpc	r8,80003b90 <phy_rx_func+0xec4>
80003b24:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003b26:	30 49       	mov	r9,4
80003b28:	49 88       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003b2a:	91 09       	st.w	r8[0x0],r9
80003b2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003b30:	30 09       	mov	r9,0
80003b32:	49 68       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003b34:	91 09       	st.w	r8[0x0],r9
80003b36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003b3a:	4a dc       	lddpc	r12,80003bec <phy_rx_func+0xf20>
80003b3c:	f0 1f 00 18 	mcall	80003b9c <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003b40:	30 09       	mov	r9,0
80003b42:	49 28       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003b44:	91 09       	st.w	r8[0x0],r9
80003b46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b4a:	00 00       	add	r0,r0
80003b4c:	00 00       	add	r0,r0
80003b4e:	0a a4       	st.w	r5++,r4
80003b50:	00 00       	add	r0,r0
80003b52:	0a bc       	st.h	r5++,r12
80003b54:	00 00       	add	r0,r0
80003b56:	0a 9c       	mov	r12,r5
80003b58:	00 00       	add	r0,r0
80003b5a:	0a 7e       	tst	lr,r5
80003b5c:	00 00       	add	r0,r0
80003b5e:	0a 6c       	and	r12,r5
80003b60:	00 00       	add	r0,r0
80003b62:	0a 94       	mov	r4,r5
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	2b 54       	sub	r4,-75
80003b68:	00 00       	add	r0,r0
80003b6a:	0a 8c       	andn	r12,r5
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	2a 6c       	sub	r12,-90
80003b70:	00 00       	add	r0,r0
80003b72:	0a a0       	st.w	r5++,r0
80003b74:	80 00       	ld.sh	r0,r0[0x0]
80003b76:	2a a0       	sub	r0,-86
80003b78:	00 00       	add	r0,r0
80003b7a:	0a 7d       	tst	sp,r5
80003b7c:	00 00       	add	r0,r0
80003b7e:	0a 98       	mov	r8,r5
80003b80:	00 00       	add	r0,r0
80003b82:	0a a8       	st.w	r5++,r8
80003b84:	00 00       	add	r0,r0
80003b86:	0a 80       	andn	r0,r5
80003b88:	00 00       	add	r0,r0
80003b8a:	0a c8       	st.b	r5++,r8
80003b8c:	00 00       	add	r0,r0
80003b8e:	0a b0       	st.h	r5++,r0
80003b90:	00 00       	add	r0,r0
80003b92:	0a 68       	and	r8,r5
80003b94:	00 00       	add	r0,r0
80003b96:	0a 44       	or	r4,r5
80003b98:	80 00       	ld.sh	r0,r0[0x0]
80003b9a:	d5 c8       	*unknown*
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	6f 4c       	ld.w	r12,r7[0x50]
80003ba0:	00 00       	add	r0,r0
80003ba2:	0a 7c       	tst	r12,r5
80003ba4:	00 00       	add	r0,r0
80003ba6:	0a d4       	st.w	--r5,r4
80003ba8:	00 00       	add	r0,r0
80003baa:	0a b4       	st.h	r5++,r4
80003bac:	80 00       	ld.sh	r0,r0[0x0]
80003bae:	77 84       	ld.w	r4,r11[0x60]
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	2a 88       	sub	r8,-88
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a 3a       	cp.w	r10,r5
80003bb8:	00 00       	add	r0,r0
80003bba:	1e 94       	mov	r4,pc
80003bbc:	80 00       	ld.sh	r0,r0[0x0]
80003bbe:	2a 3c       	sub	r12,-93
80003bc0:	00 00       	add	r0,r0
80003bc2:	0a 70       	tst	r0,r5
80003bc4:	00 00       	add	r0,r0
80003bc6:	1d 98       	ld.ub	r8,lr[0x1]
80003bc8:	00 00       	add	r0,r0
80003bca:	0a 74       	tst	r4,r5
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 40       	or	r0,r5
80003bd0:	00 00       	add	r0,r0
80003bd2:	0a 43       	or	r3,r5
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a cc       	st.b	r5++,r12
80003bd8:	00 00       	add	r0,r0
80003bda:	0a 88       	andn	r8,r5
80003bdc:	00 00       	add	r0,r0
80003bde:	0a 55       	eor	r5,r5
80003be0:	00 00       	add	r0,r0
80003be2:	1d 90       	ld.ub	r0,lr[0x1]
80003be4:	00 00       	add	r0,r0
80003be6:	0a c0       	st.b	r5++,r0
80003be8:	00 00       	add	r0,r0
80003bea:	1e 98       	mov	r8,pc
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	d5 e0       	acall	0x5e

80003bf0 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003bf0:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003bf2:	49 a8       	lddpc	r8,80003c58 <pdca_int_handler+0x68>
80003bf4:	70 09       	ld.w	r9,r8[0x0]
80003bf6:	2f f9       	sub	r9,-1
80003bf8:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003bfa:	49 98       	lddpc	r8,80003c5c <pdca_int_handler+0x6c>
80003bfc:	11 89       	ld.ub	r9,r8[0x0]
80003bfe:	ec 19 00 01 	eorl	r9,0x1
80003c02:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003c04:	11 89       	ld.ub	r9,r8[0x0]
80003c06:	a5 69       	lsl	r9,0x4
80003c08:	2f c9       	sub	r9,-4
80003c0a:	49 6a       	lddpc	r10,80003c60 <pdca_int_handler+0x70>
80003c0c:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003c0e:	fe 7a 00 40 	mov	r10,-65472
80003c12:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c14:	30 39       	mov	r9,3
80003c16:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c18:	11 8a       	ld.ub	r10,r8[0x0]
80003c1a:	a5 6a       	lsl	r10,0x4
80003c1c:	2f ca       	sub	r10,-4
80003c1e:	49 28       	lddpc	r8,80003c64 <pdca_int_handler+0x74>
80003c20:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c22:	fe 78 00 00 	mov	r8,-65536
80003c26:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c28:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c2a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c2c:	48 f8       	lddpc	r8,80003c68 <pdca_int_handler+0x78>
80003c2e:	70 08       	ld.w	r8,r8[0x0]
80003c30:	58 08       	cp.w	r8,0
80003c32:	c0 70       	breq	80003c40 <pdca_int_handler+0x50>
80003c34:	48 a9       	lddpc	r9,80003c5c <pdca_int_handler+0x6c>
80003c36:	13 89       	ld.ub	r9,r9[0x0]
80003c38:	a5 69       	lsl	r9,0x4
80003c3a:	48 bc       	lddpc	r12,80003c64 <pdca_int_handler+0x74>
80003c3c:	12 0c       	add	r12,r9
80003c3e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c40:	48 b8       	lddpc	r8,80003c6c <pdca_int_handler+0x7c>
80003c42:	70 08       	ld.w	r8,r8[0x0]
80003c44:	58 08       	cp.w	r8,0
80003c46:	c0 70       	breq	80003c54 <pdca_int_handler+0x64>
80003c48:	48 59       	lddpc	r9,80003c5c <pdca_int_handler+0x6c>
80003c4a:	13 89       	ld.ub	r9,r9[0x0]
80003c4c:	a5 69       	lsl	r9,0x4
80003c4e:	48 5c       	lddpc	r12,80003c60 <pdca_int_handler+0x70>
80003c50:	12 0c       	add	r12,r9
80003c52:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003c54:	d4 02       	popm	lr
80003c56:	d6 03       	rete
80003c58:	00 00       	add	r0,r0
80003c5a:	0a dc       	st.w	--r5,r12
80003c5c:	00 00       	add	r0,r0
80003c5e:	96 b8       	ld.uh	r8,r11[0x6]
80003c60:	00 00       	add	r0,r0
80003c62:	96 e0       	ld.uh	r0,r11[0xc]
80003c64:	00 00       	add	r0,r0
80003c66:	96 c0       	ld.uh	r0,r11[0x8]
80003c68:	00 00       	add	r0,r0
80003c6a:	0a d8       	st.w	--r5,r8
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a e0       	st.h	--r5,r0

80003c70 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003c70:	fe 78 10 00 	mov	r8,-61440
80003c74:	e0 69 0d c0 	mov	r9,3520
80003c78:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003c7c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003c80:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003c84:	fe 78 34 00 	mov	r8,-52224
80003c88:	e0 69 80 00 	mov	r9,32768
80003c8c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003c8e:	30 09       	mov	r9,0
80003c90:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003c92:	e0 69 04 21 	mov	r9,1057
80003c96:	ea 19 3f 20 	orh	r9,0x3f20
80003c9a:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003c9c:	e0 69 02 9f 	mov	r9,671
80003ca0:	ea 19 01 00 	orh	r9,0x100
80003ca4:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003ca6:	e0 6a 04 02 	mov	r10,1026
80003caa:	ea 1a 3f 20 	orh	r10,0x3f20
80003cae:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003cb0:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003cb2:	5e fc       	retal	r12

80003cb4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003cb4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003cb6:	30 19       	mov	r9,1
80003cb8:	49 78       	lddpc	r8,80003d14 <local_start_PDC+0x60>
80003cba:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003cbc:	fe 78 00 00 	mov	r8,-65536
80003cc0:	30 7b       	mov	r11,7
80003cc2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003cc4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003cc6:	49 59       	lddpc	r9,80003d18 <local_start_PDC+0x64>
80003cc8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ccc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003cce:	30 3a       	mov	r10,3
80003cd0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003cd2:	30 1c       	mov	r12,1
80003cd4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003cd6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003cd8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003cda:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003cdc:	30 2c       	mov	r12,2
80003cde:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003ce0:	48 f9       	lddpc	r9,80003d1c <local_start_PDC+0x68>
80003ce2:	e0 68 5a 5a 	mov	r8,23130
80003ce6:	ea 18 ab cd 	orh	r8,0xabcd
80003cea:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003cec:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003cee:	30 0e       	mov	lr,0
80003cf0:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003cf2:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003cf4:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003cf6:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003cf8:	fe 78 00 40 	mov	r8,-65472
80003cfc:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003cfe:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003d00:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003d04:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003d06:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003d08:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003d0a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003d0c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d0e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d10:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003d12:	d8 02       	popm	pc
80003d14:	00 00       	add	r0,r0
80003d16:	96 b8       	ld.uh	r8,r11[0x6]
80003d18:	00 00       	add	r0,r0
80003d1a:	96 c0       	ld.uh	r0,r11[0x8]
80003d1c:	00 00       	add	r0,r0
80003d1e:	96 e0       	ld.uh	r0,r11[0xc]

80003d20 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d20:	48 38       	lddpc	r8,80003d2c <register_rx_tx_func+0xc>
80003d22:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d24:	48 38       	lddpc	r8,80003d30 <register_rx_tx_func+0x10>
80003d26:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d28:	5e fc       	retal	r12
80003d2a:	00 00       	add	r0,r0
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a d8       	st.w	--r5,r8
80003d30:	00 00       	add	r0,r0
80003d32:	0a e0       	st.h	--r5,r0

80003d34 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d34:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d36:	fe 78 10 00 	mov	r8,-61440
80003d3a:	30 29       	mov	r9,2
80003d3c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d40:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003d44:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003d46:	30 3a       	mov	r10,3
80003d48:	36 0b       	mov	r11,96
80003d4a:	49 4c       	lddpc	r12,80003d98 <ssc_init+0x64>
80003d4c:	f0 1f 00 14 	mcall	80003d9c <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003d50:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003d52:	fe 79 10 00 	mov	r9,-61440
80003d56:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d5a:	e2 18 00 02 	andl	r8,0x2,COH
80003d5e:	cf c0       	breq	80003d56 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003d60:	fe 79 10 00 	mov	r9,-61440
80003d64:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d68:	e2 18 00 02 	andl	r8,0x2,COH
80003d6c:	cf c1       	brne	80003d64 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003d6e:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003d70:	f0 1f 00 0c 	mcall	80003da0 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003d74:	f0 1f 00 0c 	mcall	80003da4 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d78:	fe 79 00 00 	mov	r9,-65536
80003d7c:	30 18       	mov	r8,1
80003d7e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d80:	fe 7a 00 40 	mov	r10,-65472
80003d84:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003d86:	e0 6b 01 01 	mov	r11,257
80003d8a:	fe 7a 34 00 	mov	r10,-52224
80003d8e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003d90:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003d92:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003d94:	d8 02       	popm	pc
80003d96:	00 00       	add	r0,r0
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	3b f0       	mov	r0,-65
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	53 98       	stdsp	sp[0xe4],r8
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	3c 70       	mov	r0,-57
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	3c b4       	mov	r4,-53

80003da8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003da8:	48 28       	lddpc	r8,80003db0 <xcmp_register_app_list+0x8>
80003daa:	91 0c       	st.w	r8[0x0],r12
}
80003dac:	5e fc       	retal	r12
80003dae:	00 00       	add	r0,r0
80003db0:	00 00       	add	r0,r0
80003db2:	97 00       	st.w	r11[0x0],r0

80003db4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003db4:	eb cd 40 80 	pushm	r7,lr
80003db8:	fa cd 01 00 	sub	sp,sp,256
80003dbc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003dbe:	16 98       	mov	r8,r11
80003dc0:	2f 08       	sub	r8,-16
80003dc2:	af a8       	sbr	r8,0xe
80003dc4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003dc6:	3f f8       	mov	r8,-1
80003dc8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003dca:	30 b9       	mov	r9,11
80003dcc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003dce:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003dd0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003dd2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003dd4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003dd6:	f6 ca ff fe 	sub	r10,r11,-2
80003dda:	18 9b       	mov	r11,r12
80003ddc:	fa cc ff f0 	sub	r12,sp,-16
80003de0:	f0 1f 00 05 	mcall	80003df4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003de4:	2f e7       	sub	r7,-2
80003de6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003de8:	1a 9c       	mov	r12,sp
80003dea:	f0 1f 00 04 	mcall	80003df8 <xcmp_tx+0x44>
}
80003dee:	2c 0d       	sub	sp,-256
80003df0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003df4:	80 00       	ld.sh	r0,r0[0x0]
80003df6:	76 3c       	ld.w	r12,r11[0xc]
80003df8:	80 00       	ld.sh	r0,r0[0x0]
80003dfa:	43 cc       	lddsp	r12,sp[0xf0]

80003dfc <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80003dfc:	d4 21       	pushm	r4-r7,lr
80003dfe:	fa cd 00 d0 	sub	sp,sp,208
80003e02:	18 94       	mov	r4,r12
80003e04:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003e06:	e0 68 01 00 	mov	r8,256
80003e0a:	f0 0b 19 00 	cp.h	r11,r8
80003e0e:	e0 8b 00 38 	brhi	80003e7e <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003e12:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003e16:	e0 68 04 1d 	mov	r8,1053
80003e1a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003e1c:	30 18       	mov	r8,1
80003e1e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003e20:	32 08       	mov	r8,32
80003e22:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003e24:	30 28       	mov	r8,2
80003e26:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003e28:	30 48       	mov	r8,4
80003e2a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003e2c:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80003e30:	ea 1a 0c 00 	orh	r10,0xc00
80003e34:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003e36:	30 4a       	mov	r10,4
80003e38:	1a 9b       	mov	r11,sp
80003e3a:	fa cc ff f4 	sub	r12,sp,-12
80003e3e:	f0 1f 00 12 	mcall	80003e84 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003e42:	30 f8       	mov	r8,15
80003e44:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003e48:	3a 78       	mov	r8,-89
80003e4a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003e4e:	30 08       	mov	r8,0
80003e50:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003e54:	0e 9a       	mov	r10,r7
80003e56:	5c 7a       	castu.h	r10
80003e58:	f4 08 16 08 	lsr	r8,r10,0x8
80003e5c:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003e60:	0e 96       	mov	r6,r7
80003e62:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003e66:	08 9b       	mov	r11,r4
80003e68:	fa cc ff eb 	sub	r12,sp,-21
80003e6c:	f0 1f 00 06 	mcall	80003e84 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003e70:	ee cb ff f3 	sub	r11,r7,-13
80003e74:	5c 5b       	castu.b	r11
80003e76:	fa cc ff fa 	sub	r12,sp,-6
80003e7a:	f0 1f 00 04 	mcall	80003e88 <xcmp_data_session_req+0x8c>
}
80003e7e:	2c cd       	sub	sp,-208
80003e80:	d8 22       	popm	r4-r7,pc
80003e82:	00 00       	add	r0,r0
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	76 3c       	ld.w	r12,r11[0xc]
80003e88:	80 00       	ld.sh	r0,r0[0x0]
80003e8a:	3d b4       	mov	r4,-37

80003e8c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003e8c:	d4 01       	pushm	lr
80003e8e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003e92:	fe 78 b4 00 	mov	r8,-19456
80003e96:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003e98:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = XCMP_Version[0];
80003e9c:	48 c9       	lddpc	r9,80003ecc <xcmp_DeviceInitializationStatus_request+0x40>
80003e9e:	13 8a       	ld.ub	r10,r9[0x0]
80003ea0:	b0 8a       	st.b	r8[0x0],r10
	ptr->XCMPVersion[1] = XCMP_Version[1];
80003ea2:	13 9a       	ld.ub	r10,r9[0x1]
80003ea4:	b0 9a       	st.b	r8[0x1],r10
	ptr->XCMPVersion[2] = XCMP_Version[2];
80003ea6:	13 aa       	ld.ub	r10,r9[0x2]
80003ea8:	b0 aa       	st.b	r8[0x2],r10
	ptr->XCMPVersion[3] = XCMP_Version[3];
80003eaa:	13 b9       	ld.ub	r9,r9[0x3]
80003eac:	b0 b9       	st.b	r8[0x3],r9
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003eae:	30 09       	mov	r9,0
80003eb0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003eb2:	30 7a       	mov	r10,7
80003eb4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003eb6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003eb8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003eba:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003ebe:	30 9b       	mov	r11,9
80003ec0:	fa cc ff fe 	sub	r12,sp,-2
80003ec4:	f0 1f 00 03 	mcall	80003ed0 <xcmp_DeviceInitializationStatus_request+0x44>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003ec8:	2c dd       	sub	sp,-204
80003eca:	d8 02       	popm	pc
80003ecc:	00 00       	add	r0,r0
80003ece:	0d 7c       	ld.ub	r12,--r6
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	3d b4       	mov	r4,-37

80003ed4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003ed4:	d4 01       	pushm	lr
80003ed6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003eda:	fe 78 80 00 	mov	r8,-32768
80003ede:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003ee0:	30 38       	mov	r8,3
80003ee2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003ee4:	30 1b       	mov	r11,1
80003ee6:	fa cc ff fe 	sub	r12,sp,-2
80003eea:	f0 1f 00 03 	mcall	80003ef4 <xcmp_opcode_not_supported+0x20>
}
80003eee:	2c dd       	sub	sp,-204
80003ef0:	d8 02       	popm	pc
80003ef2:	00 00       	add	r0,r0
80003ef4:	80 00       	ld.sh	r0,r0[0x0]
80003ef6:	3d b4       	mov	r4,-37

80003ef8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003ef8:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003efa:	96 88       	ld.uh	r8,r11[0x0]
80003efc:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f00:	e0 48 80 00 	cp.w	r8,32768
80003f04:	c0 f0       	breq	80003f22 <xcmp_exec_func+0x2a>
80003f06:	e0 48 b0 00 	cp.w	r8,45056
80003f0a:	c1 20       	breq	80003f2e <xcmp_exec_func+0x36>
80003f0c:	58 08       	cp.w	r8,0
80003f0e:	c1 51       	brne	80003f38 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f10:	78 08       	ld.w	r8,r12[0x0]
80003f12:	58 08       	cp.w	r8,0
80003f14:	c0 40       	breq	80003f1c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f16:	16 9c       	mov	r12,r11
80003f18:	5d 18       	icall	r8
80003f1a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003f1c:	f0 1f 00 08 	mcall	80003f3c <xcmp_exec_func+0x44>
80003f20:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003f22:	78 18       	ld.w	r8,r12[0x4]
80003f24:	58 08       	cp.w	r8,0
80003f26:	c0 90       	breq	80003f38 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003f28:	16 9c       	mov	r12,r11
80003f2a:	5d 18       	icall	r8
80003f2c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003f2e:	78 28       	ld.w	r8,r12[0x8]
80003f30:	58 08       	cp.w	r8,0
80003f32:	c0 30       	breq	80003f38 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003f34:	16 9c       	mov	r12,r11
80003f36:	5d 18       	icall	r8
80003f38:	d8 02       	popm	pc
80003f3a:	00 00       	add	r0,r0
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	3e d4       	mov	r4,-19

80003f40 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003f40:	d4 01       	pushm	lr
80003f42:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003f46:	e0 68 04 09 	mov	r8,1033
80003f4a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f4c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003f50:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003f52:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003f56:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003f58:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003f5a:	30 09       	mov	r9,0
80003f5c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003f5e:	fb 69 00 08 	st.b	sp[8],r9
80003f62:	fa c8 ff f7 	sub	r8,sp,-9
80003f66:	b0 89       	st.b	r8[0x0],r9
80003f68:	fa c8 ff f6 	sub	r8,sp,-10
80003f6c:	b0 89       	st.b	r8[0x0],r9
80003f6e:	fa c8 ff f5 	sub	r8,sp,-11
80003f72:	b0 89       	st.b	r8[0x0],r9
80003f74:	fa c8 ff f4 	sub	r8,sp,-12
80003f78:	b0 89       	st.b	r8[0x0],r9
80003f7a:	fa c8 ff f3 	sub	r8,sp,-13
80003f7e:	b0 89       	st.b	r8[0x0],r9
80003f80:	fa c8 ff f2 	sub	r8,sp,-14
80003f84:	b0 89       	st.b	r8[0x0],r9
80003f86:	fa c8 ff f1 	sub	r8,sp,-15
80003f8a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003f8c:	30 cb       	mov	r11,12
80003f8e:	fa cc ff fe 	sub	r12,sp,-2
80003f92:	f0 1f 00 03 	mcall	80003f9c <xcmp_IdleTestTone+0x5c>
}
80003f96:	2c dd       	sub	sp,-204
80003f98:	d8 02       	popm	pc
80003f9a:	00 00       	add	r0,r0
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	3d b4       	mov	r4,-37

80003fa0 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003fa0:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003fa2:	48 dc       	lddpc	r12,80003fd4 <xcmp_init+0x34>
80003fa4:	f0 1f 00 0d 	mcall	80003fd8 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003fa8:	30 4b       	mov	r11,4
80003faa:	31 4c       	mov	r12,20
80003fac:	f0 1f 00 0c 	mcall	80003fdc <xcmp_init+0x3c>
80003fb0:	48 c8       	lddpc	r8,80003fe0 <xcmp_init+0x40>
80003fb2:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003fb4:	30 09       	mov	r9,0
80003fb6:	1a d9       	st.w	--sp,r9
80003fb8:	1a d9       	st.w	--sp,r9
80003fba:	1a d9       	st.w	--sp,r9
80003fbc:	30 38       	mov	r8,3
80003fbe:	e0 6a 04 00 	mov	r10,1024
80003fc2:	48 9b       	lddpc	r11,80003fe4 <xcmp_init+0x44>
80003fc4:	48 9c       	lddpc	r12,80003fe8 <xcmp_init+0x48>
80003fc6:	f0 1f 00 0a 	mcall	80003fec <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003fca:	f0 1f 00 0a 	mcall	80003ff0 <xcmp_init+0x50>
80003fce:	2f dd       	sub	sp,-12
	
}
80003fd0:	d8 02       	popm	pc
80003fd2:	00 00       	add	r0,r0
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	40 f0       	lddsp	r0,sp[0x3c]
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	41 3c       	lddsp	r12,sp[0x4c]
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	62 e0       	ld.w	r0,r1[0x38]
80003fe0:	00 00       	add	r0,r0
80003fe2:	0a fc       	st.b	--r5,r12
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	d6 0c       	*unknown*
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	3f f4       	mov	r4,-1
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	69 fc       	ld.w	r12,r4[0x7c]
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	41 74       	lddsp	r4,sp[0x5c]

80003ff4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003ff4:	d4 31       	pushm	r0-r7,lr
80003ff6:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003ff8:	4b 16       	lddpc	r6,800040bc <xcmp_rx_process+0xc8>
80003ffa:	30 05       	mov	r5,0
80003ffc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003ffe:	4b 13       	lddpc	r3,800040c0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004000:	4b 12       	lddpc	r2,800040c4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004002:	4b 21       	lddpc	r1,800040c8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004004:	4b 20       	lddpc	r0,800040cc <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004006:	6c 0c       	ld.w	r12,r6[0x0]
80004008:	0a 99       	mov	r9,r5
8000400a:	08 9a       	mov	r10,r4
8000400c:	1a 9b       	mov	r11,sp
8000400e:	f0 1f 00 31 	mcall	800040d0 <xcmp_rx_process+0xdc>
80004012:	58 1c       	cp.w	r12,1
80004014:	cf 91       	brne	80004006 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004016:	40 0b       	lddsp	r11,sp[0x0]
80004018:	58 0b       	cp.w	r11,0
8000401a:	cf 60       	breq	80004006 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
8000401c:	96 0a       	ld.sh	r10,r11[0x0]
8000401e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004022:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004026:	59 c8       	cp.w	r8,28
80004028:	c1 e0       	breq	80004064 <xcmp_rx_process+0x70>
8000402a:	e0 89 00 07 	brgt	80004038 <xcmp_rx_process+0x44>
8000402e:	58 e8       	cp.w	r8,14
80004030:	c0 e0       	breq	8000404c <xcmp_rx_process+0x58>
80004032:	58 f8       	cp.w	r8,15
80004034:	c2 41       	brne	8000407c <xcmp_rx_process+0x88>
80004036:	c0 f8       	rjmp	80004054 <xcmp_rx_process+0x60>
80004038:	e0 48 01 09 	cp.w	r8,265
8000403c:	c1 80       	breq	8000406c <xcmp_rx_process+0x78>
8000403e:	e0 48 01 0a 	cp.w	r8,266
80004042:	c1 90       	breq	80004074 <xcmp_rx_process+0x80>
80004044:	e0 48 00 2c 	cp.w	r8,44
80004048:	c1 a1       	brne	8000407c <xcmp_rx_process+0x88>
8000404a:	c0 98       	rjmp	8000405c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000404c:	4a 2c       	lddpc	r12,800040d4 <xcmp_rx_process+0xe0>
8000404e:	f0 1f 00 23 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004052:	c2 f8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004054:	4a 2c       	lddpc	r12,800040dc <xcmp_rx_process+0xe8>
80004056:	f0 1f 00 21 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
8000405a:	c2 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000405c:	4a 1c       	lddpc	r12,800040e0 <xcmp_rx_process+0xec>
8000405e:	f0 1f 00 1f 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004062:	c2 78       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004064:	04 9c       	mov	r12,r2
80004066:	f0 1f 00 1d 	mcall	800040d8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000406a:	c2 38       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000406c:	02 9c       	mov	r12,r1
8000406e:	f0 1f 00 1b 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004072:	c1 f8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004074:	00 9c       	mov	r12,r0
80004076:	f0 1f 00 19 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
8000407a:	c1 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000407c:	12 98       	mov	r8,r9
8000407e:	e2 18 04 00 	andl	r8,0x400,COH
80004082:	c0 70       	breq	80004090 <xcmp_rx_process+0x9c>
80004084:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004088:	e0 48 00 68 	cp.w	r8,104
8000408c:	e0 8a 00 08 	brle	8000409c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004090:	e2 19 f0 00 	andl	r9,0xf000,COH
80004094:	c0 e1       	brne	800040b0 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004096:	f0 1f 00 14 	mcall	800040e4 <xcmp_rx_process+0xf0>
8000409a:	c0 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000409c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800040a0:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800040a4:	49 19       	lddpc	r9,800040e8 <xcmp_rx_process+0xf4>
800040a6:	72 08       	ld.w	r8,r9[0x0]
800040a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800040ac:	f0 1f 00 0b 	mcall	800040d8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040b0:	66 0c       	ld.w	r12,r3[0x0]
800040b2:	40 0b       	lddsp	r11,sp[0x0]
800040b4:	f0 1f 00 0e 	mcall	800040ec <xcmp_rx_process+0xf8>
800040b8:	ca 7b       	rjmp	80004006 <xcmp_rx_process+0x12>
800040ba:	00 00       	add	r0,r0
800040bc:	00 00       	add	r0,r0
800040be:	0a fc       	st.b	--r5,r12
800040c0:	00 00       	add	r0,r0
800040c2:	0a 94       	mov	r4,r5
800040c4:	00 00       	add	r0,r0
800040c6:	0b 0c       	ld.w	r12,r5++
800040c8:	00 00       	add	r0,r0
800040ca:	0b 00       	ld.w	r0,r5++
800040cc:	00 00       	add	r0,r0
800040ce:	0a f0       	st.b	--r5,r0
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	5f 7c       	srpl	r12
800040d4:	00 00       	add	r0,r0
800040d6:	0b 24       	ld.uh	r4,r5++
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	3e f8       	mov	r8,-17
800040dc:	00 00       	add	r0,r0
800040de:	0a e4       	st.h	--r5,r4
800040e0:	00 00       	add	r0,r0
800040e2:	0b 18       	ld.sh	r8,r5++
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	3e d4       	mov	r4,-19
800040e8:	00 00       	add	r0,r0
800040ea:	97 00       	st.w	r11[0x0],r0
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	2a d8       	sub	r8,-83

800040f0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800040f0:	eb cd 40 90 	pushm	r4,r7,lr
800040f4:	20 1d       	sub	sp,4
800040f6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800040fa:	48 c8       	lddpc	r8,80004128 <xcmp_rx+0x38>
800040fc:	70 0c       	ld.w	r12,r8[0x0]
800040fe:	f0 1f 00 0c 	mcall	8000412c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004102:	c1 00       	breq	80004122 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004104:	fa c7 ff fc 	sub	r7,sp,-4
80004108:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000410a:	e0 6a 00 ca 	mov	r10,202
8000410e:	08 9b       	mov	r11,r4
80004110:	f0 1f 00 08 	mcall	80004130 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004114:	48 88       	lddpc	r8,80004134 <xcmp_rx+0x44>
80004116:	70 0c       	ld.w	r12,r8[0x0]
80004118:	30 09       	mov	r9,0
8000411a:	12 9a       	mov	r10,r9
8000411c:	1a 9b       	mov	r11,sp
8000411e:	f0 1f 00 07 	mcall	80004138 <xcmp_rx+0x48>
	}	
}
80004122:	2f fd       	sub	sp,-4
80004124:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004128:	00 00       	add	r0,r0
8000412a:	0a 94       	mov	r4,r5
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	2c 84       	sub	r4,-56
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	76 3c       	ld.w	r12,r11[0xc]
80004134:	00 00       	add	r0,r0
80004136:	0a fc       	st.b	--r5,r12
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	61 88       	ld.w	r8,r0[0x60]

8000413c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000413c:	48 28       	lddpc	r8,80004144 <xnl_register_xcmp_func+0x8>
8000413e:	91 0c       	st.w	r8[0x0],r12
}
80004140:	5e fc       	retal	r12
80004142:	00 00       	add	r0,r0
80004144:	00 00       	add	r0,r0
80004146:	0b 48       	ld.w	r8,--r5

80004148 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004148:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000414a:	48 88       	lddpc	r8,80004168 <xnl_get_msg_ack_func+0x20>
8000414c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000414e:	98 49       	ld.sh	r9,r12[0x8]
80004150:	f0 09 19 00 	cp.h	r9,r8
80004154:	c0 81       	brne	80004164 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004156:	48 68       	lddpc	r8,8000416c <xnl_get_msg_ack_func+0x24>
80004158:	70 0c       	ld.w	r12,r8[0x0]
8000415a:	30 09       	mov	r9,0
8000415c:	12 9a       	mov	r10,r9
8000415e:	12 9b       	mov	r11,r9
80004160:	f0 1f 00 04 	mcall	80004170 <xnl_get_msg_ack_func+0x28>
80004164:	d8 02       	popm	pc
80004166:	00 00       	add	r0,r0
80004168:	00 00       	add	r0,r0
8000416a:	97 04       	st.w	r11[0x0],r4
8000416c:	00 00       	add	r0,r0
8000416e:	0b 30       	ld.ub	r0,r5++
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	61 88       	ld.w	r8,r0[0x60]

80004174 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004174:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004178:	30 09       	mov	r9,0
8000417a:	4b 78       	lddpc	r8,80004254 <xnl_init+0xe0>
8000417c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000417e:	30 0b       	mov	r11,0
80004180:	30 1c       	mov	r12,1
80004182:	f0 1f 00 36 	mcall	80004258 <xnl_init+0xe4>
80004186:	4b 68       	lddpc	r8,8000425c <xnl_init+0xe8>
80004188:	91 0c       	st.w	r8[0x0],r12
8000418a:	70 08       	ld.w	r8,r8[0x0]
8000418c:	58 08       	cp.w	r8,0
8000418e:	c0 80       	breq	8000419e <xnl_init+0x2a>
80004190:	4b 38       	lddpc	r8,8000425c <xnl_init+0xe8>
80004192:	70 0c       	ld.w	r12,r8[0x0]
80004194:	30 09       	mov	r9,0
80004196:	12 9a       	mov	r10,r9
80004198:	12 9b       	mov	r11,r9
8000419a:	f0 1f 00 32 	mcall	80004260 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000419e:	30 4b       	mov	r11,4
800041a0:	33 2c       	mov	r12,50
800041a2:	f0 1f 00 2e 	mcall	80004258 <xnl_init+0xe4>
800041a6:	4b 08       	lddpc	r8,80004264 <xnl_init+0xf0>
800041a8:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800041aa:	30 4b       	mov	r11,4
800041ac:	36 4c       	mov	r12,100
800041ae:	f0 1f 00 2b 	mcall	80004258 <xnl_init+0xe4>
800041b2:	4a e8       	lddpc	r8,80004268 <xnl_init+0xf4>
800041b4:	91 0c       	st.w	r8[0x0],r12
800041b6:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800041b8:	10 96       	mov	r6,r8
800041ba:	4a d5       	lddpc	r5,8000426c <xnl_init+0xf8>
800041bc:	6c 0c       	ld.w	r12,r6[0x0]
800041be:	ea 07 00 0b 	add	r11,r5,r7
800041c2:	f0 1f 00 2c 	mcall	80004270 <xnl_init+0xfc>
800041c6:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800041ca:	e0 47 64 00 	cp.w	r7,25600
800041ce:	cf 71       	brne	800041bc <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041d0:	30 4b       	mov	r11,4
800041d2:	31 4c       	mov	r12,20
800041d4:	f0 1f 00 21 	mcall	80004258 <xnl_init+0xe4>
800041d8:	4a 78       	lddpc	r8,80004274 <xnl_init+0x100>
800041da:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041dc:	30 4b       	mov	r11,4
800041de:	31 4c       	mov	r12,20
800041e0:	f0 1f 00 1e 	mcall	80004258 <xnl_init+0xe4>
800041e4:	4a 58       	lddpc	r8,80004278 <xnl_init+0x104>
800041e6:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800041e8:	30 4b       	mov	r11,4
800041ea:	30 ac       	mov	r12,10
800041ec:	f0 1f 00 1b 	mcall	80004258 <xnl_init+0xe4>
800041f0:	4a 38       	lddpc	r8,8000427c <xnl_init+0x108>
800041f2:	91 0c       	st.w	r8[0x0],r12
800041f4:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800041f6:	10 96       	mov	r6,r8
800041f8:	4a 25       	lddpc	r5,80004280 <xnl_init+0x10c>
800041fa:	6c 0c       	ld.w	r12,r6[0x0]
800041fc:	ea 07 00 0b 	add	r11,r5,r7
80004200:	f0 1f 00 1c 	mcall	80004270 <xnl_init+0xfc>
80004204:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004208:	e0 47 14 00 	cp.w	r7,5120
8000420c:	cf 71       	brne	800041fa <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000420e:	30 4b       	mov	r11,4
80004210:	30 5c       	mov	r12,5
80004212:	f0 1f 00 12 	mcall	80004258 <xnl_init+0xe4>
80004216:	49 c8       	lddpc	r8,80004284 <xnl_init+0x110>
80004218:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000421a:	30 07       	mov	r7,0
8000421c:	1a d7       	st.w	--sp,r7
8000421e:	1a d7       	st.w	--sp,r7
80004220:	1a d7       	st.w	--sp,r7
80004222:	30 38       	mov	r8,3
80004224:	0e 99       	mov	r9,r7
80004226:	e0 6a 02 00 	mov	r10,512
8000422a:	49 8b       	lddpc	r11,80004288 <xnl_init+0x114>
8000422c:	49 8c       	lddpc	r12,8000428c <xnl_init+0x118>
8000422e:	f0 1f 00 19 	mcall	80004290 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004232:	1a d7       	st.w	--sp,r7
80004234:	1a d7       	st.w	--sp,r7
80004236:	1a d7       	st.w	--sp,r7
80004238:	30 38       	mov	r8,3
8000423a:	0e 99       	mov	r9,r7
8000423c:	e0 6a 00 82 	mov	r10,130
80004240:	49 5b       	lddpc	r11,80004294 <xnl_init+0x120>
80004242:	49 6c       	lddpc	r12,80004298 <xnl_init+0x124>
80004244:	f0 1f 00 13 	mcall	80004290 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004248:	f0 1f 00 15 	mcall	8000429c <xnl_init+0x128>
8000424c:	2f ad       	sub	sp,-24
}
8000424e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004252:	00 00       	add	r0,r0
80004254:	00 00       	add	r0,r0
80004256:	97 04       	st.w	r11[0x0],r4
80004258:	80 00       	ld.sh	r0,r0[0x0]
8000425a:	62 e0       	ld.w	r0,r1[0x38]
8000425c:	00 00       	add	r0,r0
8000425e:	0b 30       	ld.ub	r0,r5++
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	61 88       	ld.w	r8,r0[0x60]
80004264:	00 00       	add	r0,r0
80004266:	0b 3c       	ld.ub	r12,r5++
80004268:	00 00       	add	r0,r0
8000426a:	0a 94       	mov	r4,r5
8000426c:	00 00       	add	r0,r0
8000426e:	32 b2       	mov	r2,43
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	2a d8       	sub	r8,-83
80004274:	00 00       	add	r0,r0
80004276:	0a c4       	st.b	r5++,r4
80004278:	00 00       	add	r0,r0
8000427a:	0a a4       	st.w	r5++,r4
8000427c:	00 00       	add	r0,r0
8000427e:	0a 98       	mov	r8,r5
80004280:	00 00       	add	r0,r0
80004282:	1e b2       	st.h	pc++,r2
80004284:	00 00       	add	r0,r0
80004286:	0a d0       	st.w	--r5,r0
80004288:	80 00       	ld.sh	r0,r0[0x0]
8000428a:	d6 14       	*unknown*
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	42 a0       	lddsp	r0,sp[0xa8]
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	69 fc       	ld.w	r12,r4[0x7c]
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	d6 1c       	*unknown*
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	43 00       	lddsp	r0,sp[0xc0]
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	2c ac       	sub	r12,-54

800042a0 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800042a0:	eb cd 40 fe 	pushm	r1-r7,lr
800042a4:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042a6:	49 26       	lddpc	r6,800042ec <xnl_rx_process+0x4c>
800042a8:	30 05       	mov	r5,0
800042aa:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042ac:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ae:	49 11       	lddpc	r1,800042f0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042b0:	49 12       	lddpc	r2,800042f4 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042b2:	6c 0c       	ld.w	r12,r6[0x0]
800042b4:	0a 99       	mov	r9,r5
800042b6:	08 9a       	mov	r10,r4
800042b8:	1a 9b       	mov	r11,sp
800042ba:	f0 1f 00 10 	mcall	800042f8 <xnl_rx_process+0x58>
800042be:	58 1c       	cp.w	r12,1
800042c0:	cf 91       	brne	800042b2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800042c2:	40 0c       	lddsp	r12,sp[0x0]
800042c4:	58 0c       	cp.w	r12,0
800042c6:	cf 60       	breq	800042b2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042c8:	98 28       	ld.sh	r8,r12[0x4]
800042ca:	e6 08 19 00 	cp.h	r8,r3
800042ce:	e0 8b 00 0a 	brhi	800042e2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042d2:	5c 78       	castu.h	r8
800042d4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800042d8:	58 09       	cp.w	r9,0
800042da:	c0 40       	breq	800042e2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800042dc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800042e0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042e2:	62 0c       	ld.w	r12,r1[0x0]
800042e4:	40 0b       	lddsp	r11,sp[0x0]
800042e6:	f0 1f 00 06 	mcall	800042fc <xnl_rx_process+0x5c>
800042ea:	ce 4b       	rjmp	800042b2 <xnl_rx_process+0x12>
800042ec:	00 00       	add	r0,r0
800042ee:	0a a4       	st.w	r5++,r4
800042f0:	00 00       	add	r0,r0
800042f2:	0a 94       	mov	r4,r5
800042f4:	00 00       	add	r0,r0
800042f6:	04 f4       	st.b	--r2,r4
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	5f 7c       	srpl	r12
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	2a d8       	sub	r8,-83

80004300 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004300:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004302:	4a a6       	lddpc	r6,800043a8 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004304:	4a a2       	lddpc	r2,800043ac <xnl_tx_process+0xac>
80004306:	4a b4       	lddpc	r4,800043b0 <xnl_tx_process+0xb0>
80004308:	30 07       	mov	r7,0
8000430a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000430c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000430e:	4a a5       	lddpc	r5,800043b4 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004310:	4a a3       	lddpc	r3,800043b8 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004312:	6c 08       	ld.w	r8,r6[0x0]
80004314:	58 08       	cp.w	r8,0
80004316:	c0 40       	breq	8000431e <xnl_tx_process+0x1e>
80004318:	58 18       	cp.w	r8,1
8000431a:	cf d1       	brne	80004314 <xnl_tx_process+0x14>
8000431c:	c2 48       	rjmp	80004364 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000431e:	64 0c       	ld.w	r12,r2[0x0]
80004320:	0e 99       	mov	r9,r7
80004322:	02 9a       	mov	r10,r1
80004324:	08 9b       	mov	r11,r4
80004326:	f0 1f 00 26 	mcall	800043bc <xnl_tx_process+0xbc>
8000432a:	58 1c       	cp.w	r12,1
8000432c:	cf 31       	brne	80004312 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000432e:	68 0b       	ld.w	r11,r4[0x0]
80004330:	58 0b       	cp.w	r11,0
80004332:	cf 00       	breq	80004312 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004334:	96 28       	ld.sh	r8,r11[0x4]
80004336:	e0 08 19 00 	cp.h	r8,r0
8000433a:	c0 71       	brne	80004348 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
8000433c:	4a 18       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
8000433e:	70 08       	ld.w	r8,r8[0x0]
80004340:	10 9c       	mov	r12,r8
80004342:	f0 1f 00 21 	mcall	800043c4 <xnl_tx_process+0xc4>
						break;
80004346:	ce 6b       	rjmp	80004312 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004348:	16 9c       	mov	r12,r11
8000434a:	f0 1f 00 20 	mcall	800043c8 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000434e:	30 18       	mov	r8,1
80004350:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004352:	66 0c       	ld.w	r12,r3[0x0]
80004354:	0e 99       	mov	r9,r7
80004356:	0e 9a       	mov	r10,r7
80004358:	0e 9b       	mov	r11,r7
8000435a:	f0 1f 00 19 	mcall	800043bc <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000435e:	30 18       	mov	r8,1
80004360:	8d 08       	st.w	r6[0x0],r8
80004362:	cd 8b       	rjmp	80004312 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004364:	66 0c       	ld.w	r12,r3[0x0]
80004366:	0e 99       	mov	r9,r7
80004368:	36 4a       	mov	r10,100
8000436a:	0e 9b       	mov	r11,r7
8000436c:	f0 1f 00 14 	mcall	800043bc <xnl_tx_process+0xbc>
80004370:	58 1c       	cp.w	r12,1
80004372:	c0 81       	brne	80004382 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004374:	49 38       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
80004376:	70 0c       	ld.w	r12,r8[0x0]
80004378:	68 0b       	ld.w	r11,r4[0x0]
8000437a:	f0 1f 00 13 	mcall	800043c4 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000437e:	8d 07       	st.w	r6[0x0],r7
80004380:	cc 9b       	rjmp	80004312 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004382:	6a 08       	ld.w	r8,r5[0x0]
80004384:	58 38       	cp.w	r8,3
80004386:	e0 89 00 09 	brgt	80004398 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000438a:	68 0c       	ld.w	r12,r4[0x0]
8000438c:	f0 1f 00 0f 	mcall	800043c8 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004390:	6a 08       	ld.w	r8,r5[0x0]
80004392:	2f f8       	sub	r8,-1
80004394:	8b 08       	st.w	r5[0x0],r8
80004396:	cb eb       	rjmp	80004312 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004398:	48 a8       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
8000439a:	70 0c       	ld.w	r12,r8[0x0]
8000439c:	68 0b       	ld.w	r11,r4[0x0]
8000439e:	f0 1f 00 0a 	mcall	800043c4 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800043a2:	8d 07       	st.w	r6[0x0],r7
800043a4:	cb 7b       	rjmp	80004312 <xnl_tx_process+0x12>
800043a6:	00 00       	add	r0,r0
800043a8:	00 00       	add	r0,r0
800043aa:	0b 38       	ld.ub	r8,r5++
800043ac:	00 00       	add	r0,r0
800043ae:	0b 3c       	ld.ub	r12,r5++
800043b0:	00 00       	add	r0,r0
800043b2:	0b 44       	ld.w	r4,--r5
800043b4:	00 00       	add	r0,r0
800043b6:	0b 40       	ld.w	r0,--r5
800043b8:	00 00       	add	r0,r0
800043ba:	0b 30       	ld.ub	r0,r5++
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	5f 7c       	srpl	r12
800043c0:	00 00       	add	r0,r0
800043c2:	0a 94       	mov	r4,r5
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	2a d8       	sub	r8,-83
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	2a f8       	sub	r8,-81

800043cc <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800043cc:	eb cd 40 c0 	pushm	r6-r7,lr
800043d0:	20 1d       	sub	sp,4
800043d2:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800043d4:	98 39       	ld.sh	r9,r12[0x6]
800043d6:	3f f8       	mov	r8,-1
800043d8:	f0 09 19 00 	cp.h	r9,r8
800043dc:	c0 a1       	brne	800043f0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800043de:	4a e9       	lddpc	r9,80004494 <xnl_tx+0xc8>
800043e0:	13 88       	ld.ub	r8,r9[0x0]
800043e2:	2f f8       	sub	r8,-1
800043e4:	5c 58       	castu.b	r8
800043e6:	b2 88       	st.b	r9[0x0],r8
800043e8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043ec:	a9 a8       	sbr	r8,0x8
800043ee:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043f0:	8c 49       	ld.sh	r9,r6[0x8]
800043f2:	3f f8       	mov	r8,-1
800043f4:	f0 09 19 00 	cp.h	r9,r8
800043f8:	c0 41       	brne	80004400 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800043fa:	4a 88       	lddpc	r8,80004498 <xnl_tx+0xcc>
800043fc:	90 18       	ld.sh	r8,r8[0x2]
800043fe:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004400:	8c 59       	ld.sh	r9,r6[0xa]
80004402:	3f f8       	mov	r8,-1
80004404:	f0 09 19 00 	cp.h	r9,r8
80004408:	c0 41       	brne	80004410 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000440a:	4a 48       	lddpc	r8,80004498 <xnl_tx+0xcc>
8000440c:	90 28       	ld.sh	r8,r8[0x4]
8000440e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004410:	8c 69       	ld.sh	r9,r6[0xc]
80004412:	3f f8       	mov	r8,-1
80004414:	f0 09 19 00 	cp.h	r9,r8
80004418:	c0 e1       	brne	80004434 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000441a:	4a 08       	lddpc	r8,80004498 <xnl_tx+0xcc>
8000441c:	90 49       	ld.sh	r9,r8[0x8]
8000441e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004420:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004422:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004424:	90 49       	ld.sh	r9,r8[0x8]
80004426:	e0 19 ff 00 	andl	r9,0xff00
8000442a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000442e:	f3 e8 10 08 	or	r8,r9,r8
80004432:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004434:	0d 98       	ld.ub	r8,r6[0x1]
80004436:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004438:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000443c:	10 0c       	add	r12,r8
8000443e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004440:	58 0c       	cp.w	r12,0
80004442:	e0 89 00 04 	brgt	8000444a <xnl_tx+0x7e>
80004446:	30 09       	mov	r9,0
80004448:	c0 d8       	rjmp	80004462 <xnl_tx+0x96>
8000444a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000444e:	2f ec       	sub	r12,-2
80004450:	30 09       	mov	r9,0
80004452:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004454:	15 1b       	ld.sh	r11,r10++
80004456:	f6 09 00 09 	add	r9,r11,r9
8000445a:	5c 89       	casts.h	r9
		indextohWord     += 1;
8000445c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000445e:	18 38       	cp.w	r8,r12
80004460:	cf a1       	brne	80004454 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004462:	5c 39       	neg	r9
80004464:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004466:	48 e8       	lddpc	r8,8000449c <xnl_tx+0xd0>
80004468:	70 0c       	ld.w	r12,r8[0x0]
8000446a:	f0 1f 00 0e 	mcall	800044a0 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000446e:	c1 00       	breq	8000448e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004470:	fa c7 ff fc 	sub	r7,sp,-4
80004474:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004476:	e0 6a 01 00 	mov	r10,256
8000447a:	0c 9b       	mov	r11,r6
8000447c:	f0 1f 00 0a 	mcall	800044a4 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004480:	48 a8       	lddpc	r8,800044a8 <xnl_tx+0xdc>
80004482:	70 0c       	ld.w	r12,r8[0x0]
80004484:	30 09       	mov	r9,0
80004486:	12 9a       	mov	r10,r9
80004488:	1a 9b       	mov	r11,sp
8000448a:	f0 1f 00 09 	mcall	800044ac <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000448e:	2f fd       	sub	sp,-4
80004490:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004494:	00 00       	add	r0,r0
80004496:	0b 34       	ld.ub	r4,r5++
80004498:	00 00       	add	r0,r0
8000449a:	97 04       	st.w	r11[0x0],r4
8000449c:	00 00       	add	r0,r0
8000449e:	0a 94       	mov	r4,r5
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	2c 84       	sub	r4,-56
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	76 3c       	ld.w	r12,r11[0xc]
800044a8:	00 00       	add	r0,r0
800044aa:	0b 3c       	ld.ub	r12,r5++
800044ac:	80 00       	ld.sh	r0,r0[0x0]
800044ae:	61 88       	ld.w	r8,r0[0x60]

800044b0 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044b0:	eb cd 40 80 	pushm	r7,lr
800044b4:	fa cd 01 00 	sub	sp,sp,256
800044b8:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044ba:	e0 68 40 0e 	mov	r8,16398
800044be:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044c0:	3f f8       	mov	r8,-1
800044c2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800044c4:	30 c8       	mov	r8,12
800044c6:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800044c8:	98 38       	ld.sh	r8,r12[0x6]
800044ca:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800044cc:	98 58       	ld.sh	r8,r12[0xa]
800044ce:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800044d0:	98 48       	ld.sh	r8,r12[0x8]
800044d2:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800044d4:	98 68       	ld.sh	r8,r12[0xc]
800044d6:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800044d8:	30 08       	mov	r8,0
800044da:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044dc:	1a 9c       	mov	r12,sp
800044de:	f0 1f 00 0a 	mcall	80004504 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800044e2:	fa cd 00 cc 	sub	sp,sp,204
800044e6:	e0 6a 00 ca 	mov	r10,202
800044ea:	ee cb ff f0 	sub	r11,r7,-16
800044ee:	1a 9c       	mov	r12,sp
800044f0:	f0 1f 00 06 	mcall	80004508 <xnl_data_msg_func+0x58>
800044f4:	48 68       	lddpc	r8,8000450c <xnl_data_msg_func+0x5c>
800044f6:	70 08       	ld.w	r8,r8[0x0]
800044f8:	5d 18       	icall	r8
800044fa:	fa cd ff 34 	sub	sp,sp,-204
}
800044fe:	2c 0d       	sub	sp,-256
80004500:	e3 cd 80 80 	ldm	sp++,r7,pc
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	43 cc       	lddsp	r12,sp[0xf0]
80004508:	80 00       	ld.sh	r0,r0[0x0]
8000450a:	76 3c       	ld.w	r12,r11[0xc]
8000450c:	00 00       	add	r0,r0
8000450e:	0b 48       	ld.w	r8,--r5

80004510 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004510:	d4 21       	pushm	r4-r7,lr
80004512:	fa cd 01 00 	sub	sp,sp,256
80004516:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004518:	4c 28       	lddpc	r8,80004620 <xnl_device_auth_reply_func+0x110>
8000451a:	11 88       	ld.ub	r8,r8[0x0]
8000451c:	58 08       	cp.w	r8,0
8000451e:	e0 81 00 7f 	brne	8000461c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004522:	4c 18       	lddpc	r8,80004624 <xnl_device_auth_reply_func+0x114>
80004524:	70 0c       	ld.w	r12,r8[0x0]
80004526:	30 09       	mov	r9,0
80004528:	12 9a       	mov	r10,r9
8000452a:	12 9b       	mov	r11,r9
8000452c:	f0 1f 00 3f 	mcall	80004628 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004530:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004534:	4b b8       	lddpc	r8,80004620 <xnl_device_auth_reply_func+0x110>
80004536:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004538:	ef 39 00 12 	ld.ub	r9,r7[18]
8000453c:	ef 38 00 13 	ld.ub	r8,r7[19]
80004540:	b1 68       	lsl	r8,0x10
80004542:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004546:	ef 38 00 15 	ld.ub	r8,r7[21]
8000454a:	f3 e8 10 08 	or	r8,r9,r8
8000454e:	ef 39 00 14 	ld.ub	r9,r7[20]
80004552:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004556:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000455a:	ef 38 00 17 	ld.ub	r8,r7[23]
8000455e:	b1 68       	lsl	r8,0x10
80004560:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004564:	ef 38 00 19 	ld.ub	r8,r7[25]
80004568:	f5 e8 10 08 	or	r8,r10,r8
8000456c:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004570:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004574:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004576:	e0 64 79 b9 	mov	r4,31161
8000457a:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000457e:	e0 65 45 07 	mov	r5,17671
80004582:	ea 15 8a bd 	orh	r5,0x8abd
80004586:	e0 66 f9 3d 	mov	r6,63805
8000458a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000458e:	e0 6e b8 cf 	mov	lr,47311
80004592:	ea 1e 36 83 	orh	lr,0x3683
80004596:	e0 67 aa 1c 	mov	r7,43548
8000459a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000459e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045a0:	f4 08 00 0c 	add	r12,r10,r8
800045a4:	f0 0b 15 04 	lsl	r11,r8,0x4
800045a8:	0a 0b       	add	r11,r5
800045aa:	f9 eb 20 0b 	eor	r11,r12,r11
800045ae:	f0 0c 16 05 	lsr	r12,r8,0x5
800045b2:	0c 0c       	add	r12,r6
800045b4:	18 5b       	eor	r11,r12
800045b6:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045b8:	f2 0c 15 04 	lsl	r12,r9,0x4
800045bc:	1c 0c       	add	r12,lr
800045be:	f2 0b 16 05 	lsr	r11,r9,0x5
800045c2:	0e 0b       	add	r11,r7
800045c4:	f9 eb 20 0b 	eor	r11,r12,r11
800045c8:	f2 0a 00 0c 	add	r12,r9,r10
800045cc:	18 5b       	eor	r11,r12
800045ce:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800045d0:	e0 6b 37 20 	mov	r11,14112
800045d4:	ea 1b c6 ef 	orh	r11,0xc6ef
800045d8:	16 3a       	cp.w	r10,r11
800045da:	ce 21       	brne	8000459e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800045dc:	e0 6a 40 1a 	mov	r10,16410
800045e0:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045e2:	3f fa       	mov	r10,-1
800045e4:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800045e6:	30 6b       	mov	r11,6
800045e8:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045ea:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045ec:	48 db       	lddpc	r11,80004620 <xnl_device_auth_reply_func+0x110>
800045ee:	96 1c       	ld.sh	r12,r11[0x2]
800045f0:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800045f2:	96 2b       	ld.sh	r11,r11[0x4]
800045f4:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045f6:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800045f8:	30 ca       	mov	r10,12
800045fa:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800045fc:	30 0a       	mov	r10,0
800045fe:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004602:	30 7a       	mov	r10,7
80004604:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004608:	30 2a       	mov	r10,2
8000460a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000460e:	fa ca ff ec 	sub	r10,sp,-20
80004612:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004614:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004616:	1a 9c       	mov	r12,sp
80004618:	f0 1f 00 05 	mcall	8000462c <xnl_device_auth_reply_func+0x11c>
}
8000461c:	2c 0d       	sub	sp,-256
8000461e:	d8 22       	popm	r4-r7,pc
80004620:	00 00       	add	r0,r0
80004622:	97 04       	st.w	r11[0x0],r4
80004624:	00 00       	add	r0,r0
80004626:	0b 30       	ld.ub	r0,r5++
80004628:	80 00       	ld.sh	r0,r0[0x0]
8000462a:	61 88       	ld.w	r8,r0[0x60]
8000462c:	80 00       	ld.sh	r0,r0[0x0]
8000462e:	43 cc       	lddsp	r12,sp[0xf0]

80004630 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004630:	eb cd 40 80 	pushm	r7,lr
80004634:	fa cd 01 00 	sub	sp,sp,256
80004638:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000463a:	49 28       	lddpc	r8,80004680 <xnl_master_status_brdcst_func+0x50>
8000463c:	11 88       	ld.ub	r8,r8[0x0]
8000463e:	58 08       	cp.w	r8,0
80004640:	c1 c1       	brne	80004678 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004642:	49 18       	lddpc	r8,80004684 <xnl_master_status_brdcst_func+0x54>
80004644:	70 0c       	ld.w	r12,r8[0x0]
80004646:	30 09       	mov	r9,0
80004648:	12 9a       	mov	r10,r9
8000464a:	12 9b       	mov	r11,r9
8000464c:	f0 1f 00 0f 	mcall	80004688 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004650:	8e 58       	ld.sh	r8,r7[0xa]
80004652:	48 c9       	lddpc	r9,80004680 <xnl_master_status_brdcst_func+0x50>
80004654:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004656:	e0 68 40 0e 	mov	r8,16398
8000465a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000465c:	3f f8       	mov	r8,-1
8000465e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004660:	30 4a       	mov	r10,4
80004662:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004664:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004666:	92 19       	ld.sh	r9,r9[0x2]
80004668:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000466a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000466c:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000466e:	30 08       	mov	r8,0
80004670:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004672:	1a 9c       	mov	r12,sp
80004674:	f0 1f 00 06 	mcall	8000468c <xnl_master_status_brdcst_func+0x5c>
}
80004678:	2c 0d       	sub	sp,-256
8000467a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000467e:	00 00       	add	r0,r0
80004680:	00 00       	add	r0,r0
80004682:	97 04       	st.w	r11[0x0],r4
80004684:	00 00       	add	r0,r0
80004686:	0b 30       	ld.ub	r0,r5++
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	61 88       	ld.w	r8,r0[0x60]
8000468c:	80 00       	ld.sh	r0,r0[0x0]
8000468e:	43 cc       	lddsp	r12,sp[0xf0]

80004690 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004690:	eb cd 40 80 	pushm	r7,lr
80004694:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004696:	49 28       	lddpc	r8,800046dc <xnl_device_conn_reply_func+0x4c>
80004698:	70 0c       	ld.w	r12,r8[0x0]
8000469a:	30 09       	mov	r9,0
8000469c:	12 9a       	mov	r10,r9
8000469e:	12 9b       	mov	r11,r9
800046a0:	f0 1f 00 10 	mcall	800046e0 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046a4:	ef 18 00 10 	ld.uh	r8,r7[16]
800046a8:	10 99       	mov	r9,r8
800046aa:	e2 19 ff 00 	andl	r9,0xff00,COH
800046ae:	e0 49 01 00 	cp.w	r9,256
800046b2:	c0 60       	breq	800046be <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046b4:	0e 9c       	mov	r12,r7
800046b6:	f0 1f 00 0c 	mcall	800046e4 <xnl_device_conn_reply_func+0x54>
800046ba:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800046be:	a9 68       	lsl	r8,0x8
800046c0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800046c4:	48 98       	lddpc	r8,800046e8 <xnl_device_conn_reply_func+0x58>
800046c6:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800046c8:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800046cc:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800046ce:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800046d2:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800046d4:	30 19       	mov	r9,1
800046d6:	b0 89       	st.b	r8[0x0],r9
800046d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800046dc:	00 00       	add	r0,r0
800046de:	0b 30       	ld.ub	r0,r5++
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	61 88       	ld.w	r8,r0[0x60]
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	46 30       	lddsp	r0,sp[0x18c]
800046e8:	00 00       	add	r0,r0
800046ea:	97 04       	st.w	r11[0x0],r4

800046ec <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800046ec:	d4 01       	pushm	lr
800046ee:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046f2:	e0 68 40 0e 	mov	r8,16398
800046f6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046f8:	3f f8       	mov	r8,-1
800046fa:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800046fc:	30 38       	mov	r8,3
800046fe:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004700:	30 08       	mov	r8,0
80004702:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004704:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004706:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004708:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000470a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000470c:	1a 9c       	mov	r12,sp
8000470e:	f0 1f 00 03 	mcall	80004718 <xnl_send_device_master_query+0x2c>
}
80004712:	2c 0d       	sub	sp,-256
80004714:	d8 02       	popm	pc
80004716:	00 00       	add	r0,r0
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	43 cc       	lddsp	r12,sp[0xf0]

8000471c <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000471c:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000471e:	48 78       	lddpc	r8,80004738 <RC522_SPI_SetSpeed+0x1c>
80004720:	70 09       	ld.w	r9,r8[0x0]
80004722:	72 ca       	ld.w	r10,r9[0x30]
80004724:	5c 7c       	castu.h	r12
80004726:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000472a:	f9 ea 10 0a 	or	r10,r12,r10
8000472e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004730:	70 0c       	ld.w	r12,r8[0x0]
80004732:	f0 1f 00 03 	mcall	8000473c <RC522_SPI_SetSpeed+0x20>
		
	
}
80004736:	d8 02       	popm	pc
80004738:	00 00       	add	r0,r0
8000473a:	1d 8c       	ld.ub	r12,lr[0x0]
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	56 78       	stdsp	sp[0x19c],r8

80004740 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004740:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
80004742:	e0 6c 0a 00 	mov	r12,2560
80004746:	f0 1f 00 02 	mcall	8000474c <RC522_SPI_SetSpeedLow+0xc>
	
}
8000474a:	d8 02       	popm	pc
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	47 1c       	lddsp	r12,sp[0x1c4]

80004750 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004750:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004754:	48 76       	lddpc	r6,80004770 <RC522_ReadByte+0x20>
80004756:	e0 6b 00 ff 	mov	r11,255
8000475a:	6c 0c       	ld.w	r12,r6[0x0]
8000475c:	f0 1f 00 06 	mcall	80004774 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004760:	30 07       	mov	r7,0
80004762:	0e 9b       	mov	r11,r7
80004764:	6c 0c       	ld.w	r12,r6[0x0]
80004766:	f0 1f 00 05 	mcall	80004778 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
8000476a:	0f 9c       	ld.ub	r12,r7[0x1]
8000476c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004770:	00 00       	add	r0,r0
80004772:	1d 8c       	ld.ub	r12,lr[0x0]
80004774:	80 00       	ld.sh	r0,r0[0x0]
80004776:	56 7e       	stdsp	sp[0x19c],lr
80004778:	80 00       	ld.sh	r0,r0[0x0]
8000477a:	56 9a       	stdsp	sp[0x1a4],r10

8000477c <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
8000477c:	eb cd 40 80 	pushm	r7,lr
80004780:	20 1d       	sub	sp,4
80004782:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004784:	48 77       	lddpc	r7,800047a0 <RC522_WriteByte+0x24>
80004786:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
8000478a:	6e 0c       	ld.w	r12,r7[0x0]
8000478c:	f0 1f 00 06 	mcall	800047a4 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004790:	1a 9b       	mov	r11,sp
80004792:	6e 0c       	ld.w	r12,r7[0x0]
80004794:	f0 1f 00 05 	mcall	800047a8 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004798:	5c 5c       	castu.b	r12
8000479a:	2f fd       	sub	sp,-4
8000479c:	e3 cd 80 80 	ldm	sp++,r7,pc
800047a0:	00 00       	add	r0,r0
800047a2:	1d 8c       	ld.ub	r12,lr[0x0]
800047a4:	80 00       	ld.sh	r0,r0[0x0]
800047a6:	56 7e       	stdsp	sp[0x19c],lr
800047a8:	80 00       	ld.sh	r0,r0[0x0]
800047aa:	56 9a       	stdsp	sp[0x1a4],r10

800047ac <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800047ac:	eb cd 40 e0 	pushm	r5-r7,lr
800047b0:	18 96       	mov	r6,r12
800047b2:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800047b4:	48 a7       	lddpc	r7,800047dc <WriteRawRC+0x30>
800047b6:	30 0b       	mov	r11,0
800047b8:	6e 0c       	ld.w	r12,r7[0x0]
800047ba:	f0 1f 00 0a 	mcall	800047e0 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800047be:	ec 0c 15 01 	lsl	r12,r6,0x1
800047c2:	e2 1c 00 7e 	andl	r12,0x7e,COH
800047c6:	f0 1f 00 08 	mcall	800047e4 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800047ca:	0a 9c       	mov	r12,r5
800047cc:	f0 1f 00 06 	mcall	800047e4 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800047d0:	30 0b       	mov	r11,0
800047d2:	6e 0c       	ld.w	r12,r7[0x0]
800047d4:	f0 1f 00 05 	mcall	800047e8 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800047d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800047dc:	00 00       	add	r0,r0
800047de:	1d 8c       	ld.ub	r12,lr[0x0]
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	57 e4       	stdsp	sp[0x1f8],r4
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	47 7c       	lddsp	r12,sp[0x1dc]
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	57 a4       	stdsp	sp[0x1e8],r4

800047ec <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800047ec:	d4 01       	pushm	lr

	SET_RC522RST;
800047ee:	31 9c       	mov	r12,25
800047f0:	f0 1f 00 1b 	mcall	8000485c <PcdReset+0x70>
	delay_ns(10);
800047f4:	30 ac       	mov	r12,10
800047f6:	f0 1f 00 1b 	mcall	80004860 <PcdReset+0x74>

	CLR_RC522RST;
800047fa:	31 9c       	mov	r12,25
800047fc:	f0 1f 00 1a 	mcall	80004864 <PcdReset+0x78>
	delay_ns(10);
80004800:	30 ac       	mov	r12,10
80004802:	f0 1f 00 18 	mcall	80004860 <PcdReset+0x74>

	SET_RC522RST;
80004806:	31 9c       	mov	r12,25
80004808:	f0 1f 00 15 	mcall	8000485c <PcdReset+0x70>
	delay_ns(10);
8000480c:	30 ac       	mov	r12,10
8000480e:	f0 1f 00 15 	mcall	80004860 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004812:	30 fb       	mov	r11,15
80004814:	30 1c       	mov	r12,1
80004816:	f0 1f 00 15 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000481a:	30 fb       	mov	r11,15
8000481c:	30 1c       	mov	r12,1
8000481e:	f0 1f 00 13 	mcall	80004868 <PcdReset+0x7c>
	delay_ns(10);
80004822:	30 ac       	mov	r12,10
80004824:	f0 1f 00 0f 	mcall	80004860 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004828:	33 db       	mov	r11,61
8000482a:	31 1c       	mov	r12,17
8000482c:	f0 1f 00 0f 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004830:	31 eb       	mov	r11,30
80004832:	32 dc       	mov	r12,45
80004834:	f0 1f 00 0d 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004838:	30 0b       	mov	r11,0
8000483a:	32 cc       	mov	r12,44
8000483c:	f0 1f 00 0b 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004840:	e0 6b 00 8d 	mov	r11,141
80004844:	32 ac       	mov	r12,42
80004846:	f0 1f 00 09 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
8000484a:	33 eb       	mov	r11,62
8000484c:	32 bc       	mov	r12,43
8000484e:	f0 1f 00 07 	mcall	80004868 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004852:	34 0b       	mov	r11,64
80004854:	31 5c       	mov	r12,21
80004856:	f0 1f 00 05 	mcall	80004868 <PcdReset+0x7c>
	
	return MI_OK;
}
8000485a:	d8 0a       	popm	pc,r12=0
8000485c:	80 00       	ld.sh	r0,r0[0x0]
8000485e:	53 5c       	stdsp	sp[0xd4],r12
80004860:	80 00       	ld.sh	r0,r0[0x0]
80004862:	50 fc       	stdsp	sp[0x3c],r12
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	53 78       	stdsp	sp[0xdc],r8
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	47 ac       	lddsp	r12,sp[0x1e8]

8000486c <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
8000486c:	eb cd 40 c0 	pushm	r6-r7,lr
80004870:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004872:	48 c7       	lddpc	r7,800048a0 <ReadRawRC+0x34>
80004874:	30 0b       	mov	r11,0
80004876:	6e 0c       	ld.w	r12,r7[0x0]
80004878:	f0 1f 00 0b 	mcall	800048a4 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
8000487c:	a1 76       	lsl	r6,0x1
8000487e:	0c 9c       	mov	r12,r6
80004880:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004884:	a7 bc       	sbr	r12,0x7
80004886:	f0 1f 00 09 	mcall	800048a8 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
8000488a:	f0 1f 00 09 	mcall	800048ac <ReadRawRC+0x40>
8000488e:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004890:	30 0b       	mov	r11,0
80004892:	6e 0c       	ld.w	r12,r7[0x0]
80004894:	f0 1f 00 07 	mcall	800048b0 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004898:	0c 9c       	mov	r12,r6
8000489a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000489e:	00 00       	add	r0,r0
800048a0:	00 00       	add	r0,r0
800048a2:	1d 8c       	ld.ub	r12,lr[0x0]
800048a4:	80 00       	ld.sh	r0,r0[0x0]
800048a6:	57 e4       	stdsp	sp[0x1f8],r4
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	47 7c       	lddsp	r12,sp[0x1dc]
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	47 50       	lddsp	r0,sp[0x1d4]
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	57 a4       	stdsp	sp[0x1e8],r4

800048b4 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800048b4:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800048b6:	30 1c       	mov	r12,1
800048b8:	f0 1f 00 02 	mcall	800048c0 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800048bc:	d8 02       	popm	pc
800048be:	00 00       	add	r0,r0
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	48 6c       	lddpc	r12,800048d8 <Powerdown_RC522+0x14>

800048c4 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
800048c4:	eb cd 40 80 	pushm	r7,lr
800048c8:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800048ca:	30 1c       	mov	r12,1
800048cc:	f0 1f 00 0d 	mcall	80004900 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800048d0:	30 18       	mov	r8,1
800048d2:	f0 07 18 00 	cp.b	r7,r8
800048d6:	c0 91       	brne	800048e8 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800048d8:	18 9b       	mov	r11,r12
800048da:	a5 ab       	sbr	r11,0x4
800048dc:	5c 5b       	castu.b	r11
800048de:	30 1c       	mov	r12,1
800048e0:	f0 1f 00 09 	mcall	80004904 <Powerdown_RC522+0x40>
800048e4:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800048e8:	18 9b       	mov	r11,r12
800048ea:	30 1c       	mov	r12,1
800048ec:	f0 1f 00 06 	mcall	80004904 <Powerdown_RC522+0x40>
		delay_ns(2);
800048f0:	30 2c       	mov	r12,2
800048f2:	f0 1f 00 06 	mcall	80004908 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800048f6:	f0 1f 00 06 	mcall	8000490c <Powerdown_RC522+0x48>
800048fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800048fe:	00 00       	add	r0,r0
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	48 6c       	lddpc	r12,80004918 <SetBitMask+0x8>
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	47 ac       	lddsp	r12,sp[0x1e8]
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	50 fc       	stdsp	sp[0x3c],r12
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	48 b4       	lddpc	r4,80004938 <PcdAntennaOn+0x4>

80004910 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004910:	eb cd 40 c0 	pushm	r6-r7,lr
80004914:	18 97       	mov	r7,r12
80004916:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004918:	f0 1f 00 05 	mcall	8000492c <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
8000491c:	f9 e6 10 0b 	or	r11,r12,r6
80004920:	5c 5b       	castu.b	r11
80004922:	0e 9c       	mov	r12,r7
80004924:	f0 1f 00 03 	mcall	80004930 <SetBitMask+0x20>
}
80004928:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	48 6c       	lddpc	r12,80004944 <PcdAntennaOn+0x10>
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	47 ac       	lddsp	r12,sp[0x1e8]

80004934 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004934:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004936:	31 4c       	mov	r12,20
80004938:	f0 1f 00 05 	mcall	8000494c <PcdAntennaOn+0x18>
	if (!(i & 0x03))
8000493c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004940:	c0 51       	brne	8000494a <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004942:	30 3b       	mov	r11,3
80004944:	31 4c       	mov	r12,20
80004946:	f0 1f 00 03 	mcall	80004950 <PcdAntennaOn+0x1c>
8000494a:	d8 02       	popm	pc
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	48 6c       	lddpc	r12,80004964 <ClearBitMask+0x10>
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	49 10       	lddpc	r0,80004994 <M500PcdConfigISOType+0x8>

80004954 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004954:	eb cd 40 c0 	pushm	r6-r7,lr
80004958:	18 97       	mov	r7,r12
8000495a:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
8000495c:	f0 1f 00 06 	mcall	80004974 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004960:	5c d6       	com	r6
80004962:	f9 e6 00 06 	and	r6,r12,r6
80004966:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
8000496a:	0e 9c       	mov	r12,r7
8000496c:	f0 1f 00 03 	mcall	80004978 <ClearBitMask+0x24>
	
}
80004970:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	48 6c       	lddpc	r12,8000498c <M500PcdConfigISOType>
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	47 ac       	lddsp	r12,sp[0x1e8]

8000497c <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
8000497c:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000497e:	30 3b       	mov	r11,3
80004980:	31 4c       	mov	r12,20
80004982:	f0 1f 00 02 	mcall	80004988 <PcdAntennaOff+0xc>
}
80004986:	d8 02       	popm	pc
80004988:	80 00       	ld.sh	r0,r0[0x0]
8000498a:	49 54       	lddpc	r4,800049dc <M500PcdConfigISOType+0x50>

8000498c <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
8000498c:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000498e:	34 18       	mov	r8,65
80004990:	f0 0c 18 00 	cp.b	r12,r8
80004994:	c0 20       	breq	80004998 <M500PcdConfigISOType+0xc>
80004996:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004998:	30 8b       	mov	r11,8
8000499a:	16 9c       	mov	r12,r11
8000499c:	f0 1f 00 14 	mcall	800049ec <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800049a0:	33 db       	mov	r11,61
800049a2:	31 1c       	mov	r12,17
800049a4:	f0 1f 00 13 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800049a8:	e0 6b 00 86 	mov	r11,134
800049ac:	31 7c       	mov	r12,23
800049ae:	f0 1f 00 11 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800049b2:	37 fb       	mov	r11,127
800049b4:	32 6c       	mov	r12,38
800049b6:	f0 1f 00 0f 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800049ba:	31 eb       	mov	r11,30
800049bc:	32 dc       	mov	r12,45
800049be:	f0 1f 00 0d 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800049c2:	30 0b       	mov	r11,0
800049c4:	32 cc       	mov	r12,44
800049c6:	f0 1f 00 0b 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800049ca:	e0 6b 00 8d 	mov	r11,141
800049ce:	32 ac       	mov	r12,42
800049d0:	f0 1f 00 08 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800049d4:	33 eb       	mov	r11,62
800049d6:	32 bc       	mov	r12,43
800049d8:	f0 1f 00 06 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800049dc:	e0 6c 03 e8 	mov	r12,1000
800049e0:	f0 1f 00 05 	mcall	800049f4 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800049e4:	f0 1f 00 05 	mcall	800049f8 <M500PcdConfigISOType+0x6c>
800049e8:	d8 0a       	popm	pc,r12=0
800049ea:	00 00       	add	r0,r0
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	49 54       	lddpc	r4,80004a40 <rc522_init+0x44>
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	47 ac       	lddsp	r12,sp[0x1e8]
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	50 fc       	stdsp	sp[0x3c],r12
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	49 34       	lddpc	r4,80004a44 <rc522_init+0x48>

800049fc <rc522_init>:


//mfrc522 init

void rc522_init()
{
800049fc:	eb cd 40 c0 	pushm	r6-r7,lr
80004a00:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004a02:	4a 38       	lddpc	r8,80004a8c <rc522_init+0x90>
80004a04:	1a 96       	mov	r6,sp
80004a06:	f0 ea 00 00 	ld.d	r10,r8[0]
80004a0a:	fa eb 00 00 	st.d	sp[0],r10
80004a0e:	f0 e8 00 08 	ld.d	r8,r8[8]
80004a12:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004a16:	30 4b       	mov	r11,4
80004a18:	49 ec       	lddpc	r12,80004a90 <rc522_init+0x94>
80004a1a:	f0 1f 00 1f 	mcall	80004a94 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004a1e:	31 9c       	mov	r12,25
80004a20:	f0 1f 00 1e 	mcall	80004a98 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004a24:	31 9c       	mov	r12,25
80004a26:	f0 1f 00 1e 	mcall	80004a9c <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004a2a:	49 e7       	lddpc	r7,80004aa0 <rc522_init+0xa4>
80004a2c:	fe 7c 24 00 	mov	r12,-56320
80004a30:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004a32:	1a 9b       	mov	r11,sp
80004a34:	f0 1f 00 1c 	mcall	80004aa4 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004a38:	30 09       	mov	r9,0
80004a3a:	12 9a       	mov	r10,r9
80004a3c:	12 9b       	mov	r11,r9
80004a3e:	6e 0c       	ld.w	r12,r7[0x0]
80004a40:	f0 1f 00 1a 	mcall	80004aa8 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004a44:	6e 0c       	ld.w	r12,r7[0x0]
80004a46:	f0 1f 00 1a 	mcall	80004aac <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004a4a:	e0 6a 36 00 	mov	r10,13824
80004a4e:	ea 1a 01 6e 	orh	r10,0x16e
80004a52:	1a 9b       	mov	r11,sp
80004a54:	6e 0c       	ld.w	r12,r7[0x0]
80004a56:	f0 1f 00 17 	mcall	80004ab0 <rc522_init+0xb4>
80004a5a:	c0 50       	breq	80004a64 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004a5c:	30 29       	mov	r9,2
80004a5e:	49 68       	lddpc	r8,80004ab4 <rc522_init+0xb8>
80004a60:	b0 89       	st.b	r8[0x0],r9
80004a62:	c0 38       	rjmp	80004a68 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004a64:	f0 1f 00 15 	mcall	80004ab8 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004a68:	f0 1f 00 15 	mcall	80004abc <rc522_init+0xc0>
	
	PcdAntennaOff();
80004a6c:	f0 1f 00 15 	mcall	80004ac0 <rc522_init+0xc4>
	
	delay_ms(2); 
80004a70:	30 2c       	mov	r12,2
80004a72:	f0 1f 00 15 	mcall	80004ac4 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004a76:	f0 1f 00 15 	mcall	80004ac8 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004a7a:	34 1c       	mov	r12,65
80004a7c:	f0 1f 00 14 	mcall	80004acc <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004a80:	30 1c       	mov	r12,1
80004a82:	f0 1f 00 14 	mcall	80004ad0 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004a86:	2f cd       	sub	sp,-16
80004a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	d6 4c       	*unknown*
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	d6 2c       	*unknown*
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	53 14       	stdsp	sp[0xc4],r4
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	53 44       	stdsp	sp[0xd0],r4
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	53 5c       	stdsp	sp[0xd4],r12
80004aa0:	00 00       	add	r0,r0
80004aa2:	1d 8c       	ld.ub	r12,lr[0x0]
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	56 14       	stdsp	sp[0x184],r4
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	56 4c       	stdsp	sp[0x190],r12
80004aac:	80 00       	ld.sh	r0,r0[0x0]
80004aae:	56 78       	stdsp	sp[0x19c],r8
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	56 bc       	stdsp	sp[0x1ac],r12
80004ab4:	00 00       	add	r0,r0
80004ab6:	0b 4c       	ld.w	r12,--r5
80004ab8:	80 00       	ld.sh	r0,r0[0x0]
80004aba:	47 40       	lddsp	r0,sp[0x1d0]
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	47 ec       	lddsp	r12,sp[0x1f8]
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	49 7c       	lddpc	r12,80004b1c <PcdComMF522+0x48>
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	51 3c       	stdsp	sp[0x4c],r12
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	49 34       	lddpc	r4,80004b14 <PcdComMF522+0x40>
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	49 8c       	lddpc	r12,80004b2c <PcdComMF522+0x58>
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	48 c4       	lddpc	r4,80004b00 <PcdComMF522+0x2c>

80004ad4 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004ad4:	d4 31       	pushm	r0-r7,lr
80004ad6:	20 1d       	sub	sp,4
80004ad8:	18 92       	mov	r2,r12
80004ada:	16 95       	mov	r5,r11
80004adc:	14 96       	mov	r6,r10
80004ade:	50 09       	stdsp	sp[0x0],r9
80004ae0:	10 90       	mov	r0,r8
80004ae2:	f8 c8 00 0c 	sub	r8,r12,12
80004ae6:	5c 58       	castu.b	r8
80004ae8:	30 29       	mov	r9,2
80004aea:	f2 08 18 00 	cp.b	r8,r9
80004aee:	e0 88 00 05 	brls	80004af8 <PcdComMF522+0x24>
80004af2:	30 03       	mov	r3,0
80004af4:	06 91       	mov	r1,r3
80004af6:	c0 78       	rjmp	80004b04 <PcdComMF522+0x30>
80004af8:	4c f9       	lddpc	r9,80004c34 <PcdComMF522+0x160>
80004afa:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004afe:	4c f9       	lddpc	r9,80004c38 <PcdComMF522+0x164>
80004b00:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004b04:	02 9b       	mov	r11,r1
80004b06:	a7 bb       	sbr	r11,0x7
80004b08:	30 2c       	mov	r12,2
80004b0a:	f0 1f 00 4d 	mcall	80004c3c <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004b0e:	e0 6b 00 80 	mov	r11,128
80004b12:	30 4c       	mov	r12,4
80004b14:	f0 1f 00 4b 	mcall	80004c40 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b18:	30 0b       	mov	r11,0
80004b1a:	30 1c       	mov	r12,1
80004b1c:	f0 1f 00 48 	mcall	80004c3c <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004b20:	e0 6b 00 80 	mov	r11,128
80004b24:	30 ac       	mov	r12,10
80004b26:	f0 1f 00 48 	mcall	80004c44 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004b2a:	58 06       	cp.w	r6,0
80004b2c:	c0 c0       	breq	80004b44 <PcdComMF522+0x70>
80004b2e:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004b30:	30 94       	mov	r4,9
80004b32:	0f 3b       	ld.ub	r11,r7++
80004b34:	08 9c       	mov	r12,r4
80004b36:	f0 1f 00 42 	mcall	80004c3c <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004b3a:	0e 98       	mov	r8,r7
80004b3c:	0a 18       	sub	r8,r5
80004b3e:	ec 08 19 00 	cp.h	r8,r6
80004b42:	cf 83       	brcs	80004b32 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004b44:	04 9b       	mov	r11,r2
80004b46:	30 1c       	mov	r12,1
80004b48:	f0 1f 00 3d 	mcall	80004c3c <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004b4c:	30 c8       	mov	r8,12
80004b4e:	f0 02 18 00 	cp.b	r2,r8
80004b52:	c0 61       	brne	80004b5e <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004b54:	e0 6b 00 80 	mov	r11,128
80004b58:	30 dc       	mov	r12,13
80004b5a:	f0 1f 00 3b 	mcall	80004c44 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004b5e:	30 4c       	mov	r12,4
80004b60:	f0 1f 00 3a 	mcall	80004c48 <PcdComMF522+0x174>
80004b64:	18 97       	mov	r7,r12
80004b66:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004b6a:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004b6c:	30 44       	mov	r4,4
80004b6e:	c0 88       	rjmp	80004b7e <PcdComMF522+0xaa>
80004b70:	08 9c       	mov	r12,r4
80004b72:	f0 1f 00 36 	mcall	80004c48 <PcdComMF522+0x174>
80004b76:	18 97       	mov	r7,r12
		i--;
80004b78:	20 16       	sub	r6,1
80004b7a:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004b7c:	c0 a0       	breq	80004b90 <PcdComMF522+0xbc>
80004b7e:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004b82:	c4 c1       	brne	80004c1a <PcdComMF522+0x146>
80004b84:	ef e3 00 08 	and	r8,r7,r3
80004b88:	ea 08 18 00 	cp.b	r8,r5
80004b8c:	cf 20       	breq	80004b70 <PcdComMF522+0x9c>
80004b8e:	c4 68       	rjmp	80004c1a <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004b90:	e0 6b 00 80 	mov	r11,128
80004b94:	30 dc       	mov	r12,13
80004b96:	f0 1f 00 2b 	mcall	80004c40 <PcdComMF522+0x16c>
80004b9a:	30 27       	mov	r7,2
80004b9c:	c3 38       	rjmp	80004c02 <PcdComMF522+0x12e>
80004b9e:	02 67       	and	r7,r1
80004ba0:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ba4:	30 c8       	mov	r8,12
80004ba6:	f0 02 18 00 	cp.b	r2,r8
80004baa:	c2 c1       	brne	80004c02 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004bac:	30 ac       	mov	r12,10
80004bae:	f0 1f 00 27 	mcall	80004c48 <PcdComMF522+0x174>
80004bb2:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004bb4:	30 cc       	mov	r12,12
80004bb6:	f0 1f 00 25 	mcall	80004c48 <PcdComMF522+0x174>
80004bba:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004bbe:	c0 70       	breq	80004bcc <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004bc0:	08 98       	mov	r8,r4
80004bc2:	20 18       	sub	r8,1
80004bc4:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004bc8:	a0 8c       	st.b	r0[0x0],r12
80004bca:	c0 48       	rjmp	80004bd2 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004bcc:	e8 08 15 03 	lsl	r8,r4,0x3
80004bd0:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004bd2:	58 04       	cp.w	r4,0
80004bd4:	c0 61       	brne	80004be0 <PcdComMF522+0x10c>
80004bd6:	30 14       	mov	r4,1
80004bd8:	40 05       	lddsp	r5,sp[0x0]
80004bda:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004bdc:	30 93       	mov	r3,9
80004bde:	c0 98       	rjmp	80004bf0 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004be0:	31 28       	mov	r8,18
80004be2:	f0 04 18 00 	cp.b	r4,r8
80004be6:	f9 b4 0b 12 	movhi	r4,18
80004bea:	58 04       	cp.w	r4,0
80004bec:	cf 61       	brne	80004bd8 <PcdComMF522+0x104>
80004bee:	c0 a8       	rjmp	80004c02 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004bf0:	06 9c       	mov	r12,r3
80004bf2:	f0 1f 00 16 	mcall	80004c48 <PcdComMF522+0x174>
80004bf6:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004bf8:	ec 05 01 08 	sub	r8,r6,r5
80004bfc:	e8 08 19 00 	cp.h	r8,r4
80004c00:	cf 83       	brcs	80004bf0 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004c02:	e0 6b 00 80 	mov	r11,128
80004c06:	30 cc       	mov	r12,12
80004c08:	f0 1f 00 0f 	mcall	80004c44 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c0c:	30 0b       	mov	r11,0
80004c0e:	30 1c       	mov	r12,1
80004c10:	f0 1f 00 0b 	mcall	80004c3c <PcdComMF522+0x168>
	return status;
}
80004c14:	0e 9c       	mov	r12,r7
80004c16:	2f fd       	sub	sp,-4
80004c18:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004c1a:	e0 6b 00 80 	mov	r11,128
80004c1e:	30 dc       	mov	r12,13
80004c20:	f0 1f 00 08 	mcall	80004c40 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004c24:	30 6c       	mov	r12,6
80004c26:	f0 1f 00 09 	mcall	80004c48 <PcdComMF522+0x174>
80004c2a:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004c2e:	cb 80       	breq	80004b9e <PcdComMF522+0xca>
80004c30:	30 27       	mov	r7,2
80004c32:	ce 8b       	rjmp	80004c02 <PcdComMF522+0x12e>
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	d6 24       	*unknown*
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	d6 28       	*unknown*
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	47 ac       	lddsp	r12,sp[0x1e8]
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	49 54       	lddpc	r4,80004c94 <PcdAnticoll+0x48>
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	49 10       	lddpc	r0,80004c88 <PcdAnticoll+0x3c>
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	48 6c       	lddpc	r12,80004c60 <PcdAnticoll+0x14>

80004c4c <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004c4c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c50:	20 5d       	sub	sp,20
80004c52:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004c54:	30 8b       	mov	r11,8
80004c56:	16 9c       	mov	r12,r11
80004c58:	f0 1f 00 1a 	mcall	80004cc0 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004c5c:	30 0b       	mov	r11,0
80004c5e:	30 dc       	mov	r12,13
80004c60:	f0 1f 00 19 	mcall	80004cc4 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004c64:	e0 6b 00 80 	mov	r11,128
80004c68:	30 ec       	mov	r12,14
80004c6a:	f0 1f 00 16 	mcall	80004cc0 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004c6e:	39 38       	mov	r8,-109
80004c70:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004c72:	32 08       	mov	r8,32
80004c74:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004c76:	1a 9b       	mov	r11,sp
80004c78:	fa c8 ff ed 	sub	r8,sp,-19
80004c7c:	1a 99       	mov	r9,sp
80004c7e:	30 2a       	mov	r10,2
80004c80:	30 cc       	mov	r12,12
80004c82:	f0 1f 00 12 	mcall	80004cc8 <PcdAnticoll+0x7c>
80004c86:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004c88:	c1 21       	brne	80004cac <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c8a:	1b 89       	ld.ub	r9,sp[0x0]
80004c8c:	ac 89       	st.b	r6[0x0],r9
80004c8e:	1b 98       	ld.ub	r8,sp[0x1]
80004c90:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004c92:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c94:	1b a8       	ld.ub	r8,sp[0x2]
80004c96:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004c98:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c9c:	1b b9       	ld.ub	r9,sp[0x3]
80004c9e:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ca0:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004ca2:	1b c9       	ld.ub	r9,sp[0x4]
80004ca4:	f0 09 18 00 	cp.b	r9,r8
80004ca8:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004cac:	e0 6b 00 80 	mov	r11,128
80004cb0:	30 ec       	mov	r12,14
80004cb2:	f0 1f 00 07 	mcall	80004ccc <PcdAnticoll+0x80>
	return status;
}
80004cb6:	0e 9c       	mov	r12,r7
80004cb8:	2f bd       	sub	sp,-20
80004cba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004cbe:	00 00       	add	r0,r0
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	49 54       	lddpc	r4,80004d14 <PcdRequest+0x44>
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	47 ac       	lddsp	r12,sp[0x1e8]
80004cc8:	80 00       	ld.sh	r0,r0[0x0]
80004cca:	4a d4       	lddpc	r4,80004d7c <CalulateCRC+0x48>
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	49 10       	lddpc	r0,80004d10 <PcdRequest+0x40>

80004cd0 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004cd0:	eb cd 40 c0 	pushm	r6-r7,lr
80004cd4:	20 5d       	sub	sp,20
80004cd6:	18 97       	mov	r7,r12
80004cd8:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004cda:	30 8b       	mov	r11,8
80004cdc:	16 9c       	mov	r12,r11
80004cde:	f0 1f 00 12 	mcall	80004d24 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004ce2:	30 7b       	mov	r11,7
80004ce4:	30 dc       	mov	r12,13
80004ce6:	f0 1f 00 11 	mcall	80004d28 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004cea:	30 3b       	mov	r11,3
80004cec:	31 4c       	mov	r12,20
80004cee:	f0 1f 00 10 	mcall	80004d2c <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004cf2:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004cf4:	1a 9b       	mov	r11,sp
80004cf6:	fa c8 ff ed 	sub	r8,sp,-19
80004cfa:	1a 99       	mov	r9,sp
80004cfc:	30 1a       	mov	r10,1
80004cfe:	30 cc       	mov	r12,12
80004d00:	f0 1f 00 0c 	mcall	80004d30 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004d04:	c0 c1       	brne	80004d1c <PcdRequest+0x4c>
80004d06:	31 08       	mov	r8,16
80004d08:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d0c:	f0 09 18 00 	cp.b	r9,r8
80004d10:	c0 61       	brne	80004d1c <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004d12:	1b 88       	ld.ub	r8,sp[0x0]
80004d14:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004d16:	1b 98       	ld.ub	r8,sp[0x1]
80004d18:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004d1a:	c0 28       	rjmp	80004d1e <PcdRequest+0x4e>
80004d1c:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004d1e:	2f bd       	sub	sp,-20
80004d20:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d24:	80 00       	ld.sh	r0,r0[0x0]
80004d26:	49 54       	lddpc	r4,80004d78 <CalulateCRC+0x44>
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	47 ac       	lddsp	r12,sp[0x1e8]
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	49 10       	lddpc	r0,80004d70 <CalulateCRC+0x3c>
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	4a d4       	lddpc	r4,80004de4 <PcdSelect+0x24>

80004d34 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004d34:	eb cd 40 f8 	pushm	r3-r7,lr
80004d38:	18 95       	mov	r5,r12
80004d3a:	16 96       	mov	r6,r11
80004d3c:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004d3e:	30 4b       	mov	r11,4
80004d40:	30 5c       	mov	r12,5
80004d42:	f0 1f 00 1c 	mcall	80004db0 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d46:	30 0b       	mov	r11,0
80004d48:	30 1c       	mov	r12,1
80004d4a:	f0 1f 00 1b 	mcall	80004db4 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004d4e:	e0 6b 00 80 	mov	r11,128
80004d52:	30 ac       	mov	r12,10
80004d54:	f0 1f 00 19 	mcall	80004db8 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004d58:	58 06       	cp.w	r6,0
80004d5a:	c0 c0       	breq	80004d72 <CalulateCRC+0x3e>
80004d5c:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004d5e:	30 94       	mov	r4,9
80004d60:	0f 3b       	ld.ub	r11,r7++
80004d62:	08 9c       	mov	r12,r4
80004d64:	f0 1f 00 14 	mcall	80004db4 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004d68:	0e 98       	mov	r8,r7
80004d6a:	0a 18       	sub	r8,r5
80004d6c:	ec 08 18 00 	cp.b	r8,r6
80004d70:	cf 83       	brcs	80004d60 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004d72:	30 3b       	mov	r11,3
80004d74:	30 1c       	mov	r12,1
80004d76:	f0 1f 00 10 	mcall	80004db4 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004d7a:	30 5c       	mov	r12,5
80004d7c:	f0 1f 00 10 	mcall	80004dbc <CalulateCRC+0x88>
80004d80:	e0 67 00 fe 	mov	r7,254
80004d84:	30 56       	mov	r6,5
80004d86:	c0 78       	rjmp	80004d94 <CalulateCRC+0x60>
80004d88:	0c 9c       	mov	r12,r6
80004d8a:	f0 1f 00 0d 	mcall	80004dbc <CalulateCRC+0x88>
		i--;
80004d8e:	20 17       	sub	r7,1
80004d90:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004d92:	c0 40       	breq	80004d9a <CalulateCRC+0x66>
80004d94:	e2 1c 00 04 	andl	r12,0x4,COH
80004d98:	cf 80       	breq	80004d88 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004d9a:	32 2c       	mov	r12,34
80004d9c:	f0 1f 00 08 	mcall	80004dbc <CalulateCRC+0x88>
80004da0:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004da2:	32 1c       	mov	r12,33
80004da4:	f0 1f 00 06 	mcall	80004dbc <CalulateCRC+0x88>
80004da8:	a6 9c       	st.b	r3[0x1],r12
}
80004daa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004dae:	00 00       	add	r0,r0
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	49 54       	lddpc	r4,80004e04 <PcdSelect+0x44>
80004db4:	80 00       	ld.sh	r0,r0[0x0]
80004db6:	47 ac       	lddsp	r12,sp[0x1e8]
80004db8:	80 00       	ld.sh	r0,r0[0x0]
80004dba:	49 10       	lddpc	r0,80004dfc <PcdSelect+0x3c>
80004dbc:	80 00       	ld.sh	r0,r0[0x0]
80004dbe:	48 6c       	lddpc	r12,80004dd4 <PcdSelect+0x14>

80004dc0 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004dc0:	eb cd 40 80 	pushm	r7,lr
80004dc4:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004dc6:	39 38       	mov	r8,-109
80004dc8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004dca:	37 08       	mov	r8,112
80004dcc:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004dce:	30 08       	mov	r8,0
80004dd0:	ba e8       	st.b	sp[0x6],r8
80004dd2:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004dd6:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004dda:	19 89       	ld.ub	r9,r12[0x0]
80004ddc:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004dde:	19 3a       	ld.ub	r10,r12++
80004de0:	1b e9       	ld.ub	r9,sp[0x6]
80004de2:	f5 e9 20 09 	eor	r9,r10,r9
80004de6:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004de8:	16 38       	cp.w	r8,r11
80004dea:	cf 81       	brne	80004dda <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004dec:	1a 97       	mov	r7,sp
80004dee:	fa ca ff f9 	sub	r10,sp,-7
80004df2:	30 7b       	mov	r11,7
80004df4:	1a 9c       	mov	r12,sp
80004df6:	f0 1f 00 0d 	mcall	80004e28 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004dfa:	30 8b       	mov	r11,8
80004dfc:	16 9c       	mov	r12,r11
80004dfe:	f0 1f 00 0c 	mcall	80004e2c <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004e02:	fa c8 ff ed 	sub	r8,sp,-19
80004e06:	1a 99       	mov	r9,sp
80004e08:	30 9a       	mov	r10,9
80004e0a:	1a 9b       	mov	r11,sp
80004e0c:	30 cc       	mov	r12,12
80004e0e:	f0 1f 00 09 	mcall	80004e30 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004e12:	c0 71       	brne	80004e20 <PcdSelect+0x60>
80004e14:	31 88       	mov	r8,24
80004e16:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e1a:	f0 09 18 00 	cp.b	r9,r8
80004e1e:	c0 20       	breq	80004e22 <PcdSelect+0x62>
80004e20:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004e22:	2f bd       	sub	sp,-20
80004e24:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	4d 34       	lddpc	r4,80004f74 <scan_patrol+0x2c>
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	49 54       	lddpc	r4,80004e80 <rfid_auto_reader+0x4c>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4a d4       	lddpc	r4,80004ee4 <rfid_auto_reader+0xb0>

80004e34 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004e34:	eb cd 40 c0 	pushm	r6-r7,lr
80004e38:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004e3a:	f0 1f 00 35 	mcall	80004f0c <rfid_auto_reader+0xd8>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004e3e:	4b 5b       	lddpc	r11,80004f10 <rfid_auto_reader+0xdc>
80004e40:	35 2c       	mov	r12,82
80004e42:	f0 1f 00 35 	mcall	80004f14 <rfid_auto_reader+0xe0>
80004e46:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004e48:	c5 e1       	brne	80004f04 <rfid_auto_reader+0xd0>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e4a:	4b 28       	lddpc	r8,80004f10 <rfid_auto_reader+0xdc>
80004e4c:	11 88       	ld.ub	r8,r8[0x0]
80004e4e:	30 49       	mov	r9,4
80004e50:	f2 08 18 00 	cp.b	r8,r9
80004e54:	c0 b1       	brne	80004e6a <rfid_auto_reader+0x36>
80004e56:	4a f9       	lddpc	r9,80004f10 <rfid_auto_reader+0xdc>
80004e58:	13 9a       	ld.ub	r10,r9[0x1]
80004e5a:	30 09       	mov	r9,0
80004e5c:	f2 0a 18 00 	cp.b	r10,r9
80004e60:	c0 51       	brne	80004e6a <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004e62:	4a ec       	lddpc	r12,80004f18 <rfid_auto_reader+0xe4>
80004e64:	f0 1f 00 2e 	mcall	80004f1c <rfid_auto_reader+0xe8>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e68:	c3 c8       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004e6a:	30 29       	mov	r9,2
80004e6c:	f2 08 18 00 	cp.b	r8,r9
80004e70:	c0 b1       	brne	80004e86 <rfid_auto_reader+0x52>
80004e72:	4a 89       	lddpc	r9,80004f10 <rfid_auto_reader+0xdc>
80004e74:	13 9a       	ld.ub	r10,r9[0x1]
80004e76:	30 09       	mov	r9,0
80004e78:	f2 0a 18 00 	cp.b	r10,r9
80004e7c:	c0 51       	brne	80004e86 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004e7e:	4a 9c       	lddpc	r12,80004f20 <rfid_auto_reader+0xec>
80004e80:	f0 1f 00 27 	mcall	80004f1c <rfid_auto_reader+0xe8>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004e84:	c2 e8       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004e86:	34 49       	mov	r9,68
80004e88:	f2 08 18 00 	cp.b	r8,r9
80004e8c:	c0 b1       	brne	80004ea2 <rfid_auto_reader+0x6e>
80004e8e:	4a 19       	lddpc	r9,80004f10 <rfid_auto_reader+0xdc>
80004e90:	13 9a       	ld.ub	r10,r9[0x1]
80004e92:	30 09       	mov	r9,0
80004e94:	f2 0a 18 00 	cp.b	r10,r9
80004e98:	c0 51       	brne	80004ea2 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004e9a:	4a 3c       	lddpc	r12,80004f24 <rfid_auto_reader+0xf0>
80004e9c:	f0 1f 00 20 	mcall	80004f1c <rfid_auto_reader+0xe8>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ea0:	c2 08       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ea2:	30 89       	mov	r9,8
80004ea4:	f2 08 18 00 	cp.b	r8,r9
80004ea8:	c0 b1       	brne	80004ebe <rfid_auto_reader+0x8a>
80004eaa:	49 a9       	lddpc	r9,80004f10 <rfid_auto_reader+0xdc>
80004eac:	13 9a       	ld.ub	r10,r9[0x1]
80004eae:	30 09       	mov	r9,0
80004eb0:	f2 0a 18 00 	cp.b	r10,r9
80004eb4:	c0 51       	brne	80004ebe <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004eb6:	49 dc       	lddpc	r12,80004f28 <rfid_auto_reader+0xf4>
80004eb8:	f0 1f 00 19 	mcall	80004f1c <rfid_auto_reader+0xe8>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ebc:	c1 28       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ebe:	34 49       	mov	r9,68
80004ec0:	f2 08 18 00 	cp.b	r8,r9
80004ec4:	c0 b1       	brne	80004eda <rfid_auto_reader+0xa6>
80004ec6:	49 38       	lddpc	r8,80004f10 <rfid_auto_reader+0xdc>
80004ec8:	11 99       	ld.ub	r9,r8[0x1]
80004eca:	30 38       	mov	r8,3
80004ecc:	f0 09 18 00 	cp.b	r9,r8
80004ed0:	c0 51       	brne	80004eda <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004ed2:	49 7c       	lddpc	r12,80004f2c <rfid_auto_reader+0xf8>
80004ed4:	f0 1f 00 12 	mcall	80004f1c <rfid_auto_reader+0xe8>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ed8:	c0 48       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004eda:	49 6c       	lddpc	r12,80004f30 <rfid_auto_reader+0xfc>
80004edc:	f0 1f 00 10 	mcall	80004f1c <rfid_auto_reader+0xe8>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004ee0:	49 5c       	lddpc	r12,80004f34 <rfid_auto_reader+0x100>
80004ee2:	f0 1f 00 16 	mcall	80004f38 <rfid_auto_reader+0x104>
80004ee6:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004ee8:	c0 e1       	brne	80004f04 <rfid_auto_reader+0xd0>
		return status;
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004eea:	49 3c       	lddpc	r12,80004f34 <rfid_auto_reader+0x100>
80004eec:	f0 1f 00 14 	mcall	80004f3c <rfid_auto_reader+0x108>
80004ef0:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004ef2:	c0 91       	brne	80004f04 <rfid_auto_reader+0xd0>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004ef4:	30 4a       	mov	r10,4
80004ef6:	49 0b       	lddpc	r11,80004f34 <rfid_auto_reader+0x100>
80004ef8:	0c 9c       	mov	r12,r6
80004efa:	f0 1f 00 12 	mcall	80004f40 <rfid_auto_reader+0x10c>
		log("select okay\n");
80004efe:	49 2c       	lddpc	r12,80004f44 <rfid_auto_reader+0x110>
80004f00:	f0 1f 00 07 	mcall	80004f1c <rfid_auto_reader+0xe8>
		return status;	
	}
	
//}
	
}
80004f04:	0e 9c       	mov	r12,r7
80004f06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f0a:	00 00       	add	r0,r0
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	47 ec       	lddsp	r12,sp[0x1f8]
80004f10:	00 00       	add	r0,r0
80004f12:	97 20       	st.w	r11[0x8],r0
80004f14:	80 00       	ld.sh	r0,r0[0x0]
80004f16:	4c d0       	lddpc	r0,80005048 <rfid_sendID_message+0xb0>
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	d6 5c       	*unknown*
80004f1c:	80 00       	ld.sh	r0,r0[0x0]
80004f1e:	6d c0       	ld.w	r0,r6[0x70]
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	d6 68       	*unknown*
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	d6 74       	*unknown*
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	d6 84       	*unknown*
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	d6 8c       	*unknown*
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	d6 98       	*unknown*
80004f34:	00 00       	add	r0,r0
80004f36:	97 24       	st.w	r11[0x8],r4
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	4c 4c       	lddpc	r12,80005048 <rfid_sendID_message+0xb0>
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	4d c0       	lddpc	r0,800050ac <rfid_sendID_message+0x114>
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	76 3c       	ld.w	r12,r11[0xc]
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	d6 a4       	*unknown*

80004f48 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80004f48:	eb cd 40 80 	pushm	r7,lr
80004f4c:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80004f4e:	f0 1f 00 0d 	mcall	80004f80 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80004f52:	30 0c       	mov	r12,0
80004f54:	f0 1f 00 0c 	mcall	80004f84 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80004f58:	0e 9c       	mov	r12,r7
80004f5a:	f0 1f 00 0c 	mcall	80004f88 <scan_patrol+0x40>
80004f5e:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80004f60:	30 1c       	mov	r12,1
80004f62:	f0 1f 00 09 	mcall	80004f84 <scan_patrol+0x3c>
	if(return_err == 0)
80004f66:	58 07       	cp.w	r7,0
80004f68:	c0 51       	brne	80004f72 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80004f6a:	48 9c       	lddpc	r12,80004f8c <scan_patrol+0x44>
80004f6c:	f0 1f 00 09 	mcall	80004f90 <scan_patrol+0x48>
80004f70:	c0 48       	rjmp	80004f78 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80004f72:	48 9c       	lddpc	r12,80004f94 <scan_patrol+0x4c>
80004f74:	f0 1f 00 07 	mcall	80004f90 <scan_patrol+0x48>
		
	return return_err;

}
80004f78:	0e 9c       	mov	r12,r7
80004f7a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f7e:	00 00       	add	r0,r0
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	47 ec       	lddsp	r12,sp[0x1f8]
80004f84:	80 00       	ld.sh	r0,r0[0x0]
80004f86:	48 c4       	lddpc	r4,80004fb4 <rfid_sendID_message+0x1c>
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	4e 34       	lddpc	r4,80005114 <delay_us>
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	d6 b4       	*unknown*
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	6d c0       	ld.w	r0,r6[0x70]
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	d6 c8       	*unknown*

80004f98 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
{
80004f98:	eb cd 40 f8 	pushm	r3-r7,lr
80004f9c:	21 bd       	sub	sp,108
	U32 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80004f9e:	fa ca ff a0 	sub	r10,sp,-96
80004fa2:	30 08       	mov	r8,0
80004fa4:	30 09       	mov	r9,0
80004fa6:	f4 e9 00 00 	st.d	r10[0],r8
80004faa:	30 0b       	mov	r11,0
80004fac:	b4 4b       	st.h	r10[0x8],r11
	memset(message, 0x00, 80);
80004fae:	fa e9 00 10 	st.d	sp[16],r8
80004fb2:	fa e9 00 18 	st.d	sp[24],r8
80004fb6:	fa e9 00 20 	st.d	sp[32],r8
80004fba:	fa e9 00 28 	st.d	sp[40],r8
80004fbe:	fa e9 00 30 	st.d	sp[48],r8
80004fc2:	fa e9 00 38 	st.d	sp[56],r8
80004fc6:	fa e9 00 40 	st.d	sp[64],r8
80004fca:	fa e9 00 48 	st.d	sp[72],r8
80004fce:	fa e9 00 50 	st.d	sp[80],r8
80004fd2:	fa e9 00 58 	st.d	sp[88],r8
80004fd6:	30 07       	mov	r7,0
	
	//return_err = scan_patrol(SN);
	
	do 
	{	
		return_err = scan_patrol(SN);
80004fd8:	14 94       	mov	r4,r10
		if(return_err == 0)break;
		else
		{
			vTaskDelay(400*2 / portTICK_RATE_MS);//寤惰400ms
80004fda:	e0 63 03 20 	mov	r3,800
		}
		connect_counts++;
		
	} while ((connect_counts < 7) && (return_err !=0));
80004fde:	30 75       	mov	r5,7
	
	//return_err = scan_patrol(SN);
	
	do 
	{	
		return_err = scan_patrol(SN);
80004fe0:	08 9c       	mov	r12,r4
80004fe2:	f0 1f 00 3b 	mcall	800050cc <rfid_sendID_message+0x134>
80004fe6:	18 96       	mov	r6,r12
		if(return_err == 0)break;
80004fe8:	c0 a0       	breq	80004ffc <rfid_sendID_message+0x64>
		else
		{
			vTaskDelay(400*2 / portTICK_RATE_MS);//寤惰400ms
80004fea:	06 9c       	mov	r12,r3
80004fec:	f0 1f 00 39 	mcall	800050d0 <rfid_sendID_message+0x138>
		}
		connect_counts++;
80004ff0:	2f f7       	sub	r7,-1
80004ff2:	5c 57       	castu.b	r7
		
	} while ((connect_counts < 7) && (return_err !=0));
80004ff4:	ea 07 18 00 	cp.b	r7,r5
80004ff8:	cf 41       	brne	80004fe0 <rfid_sendID_message+0x48>
80004ffa:	c5 c8       	rjmp	800050b2 <rfid_sendID_message+0x11a>
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004ffc:	fb 3b 00 63 	ld.ub	r11,sp[99]
80005000:	fb 3a 00 62 	ld.ub	r10,sp[98]
80005004:	fb 39 00 61 	ld.ub	r9,sp[97]
80005008:	fb 38 00 60 	ld.ub	r8,sp[96]
8000500c:	1a db       	st.w	--sp,r11
8000500e:	1a da       	st.w	--sp,r10
80005010:	1a d9       	st.w	--sp,r9
80005012:	1a d8       	st.w	--sp,r8
80005014:	4b 0c       	lddpc	r12,800050d4 <rfid_sendID_message+0x13c>
80005016:	f0 1f 00 31 	mcall	800050d8 <rfid_sendID_message+0x140>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
8000501a:	34 4b       	mov	r11,68
8000501c:	30 1c       	mov	r12,1
8000501e:	f0 1f 00 30 	mcall	800050dc <rfid_sendID_message+0x144>
80005022:	fa c9 ff f0 	sub	r9,sp,-16
80005026:	fa ca ff ee 	sub	r10,sp,-18
8000502a:	30 08       	mov	r8,0
8000502c:	12 9d       	mov	sp,r9
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000502e:	30 97       	mov	r7,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005030:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005032:	fa cb ff 94 	sub	r11,sp,-108
80005036:	10 0b       	add	r11,r8
80005038:	f7 3b ff f4 	ld.ub	r11,r11[-12]
8000503c:	a5 8b       	lsr	r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000503e:	ee 0b 18 00 	cp.b	r11,r7
80005042:	f7 bb 08 d0 	subls	r11,-48
80005046:	f3 fb 8e 00 	st.bls	r9[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
8000504a:	f7 bb 0b a9 	subhi	r11,-87
8000504e:	f3 fb be 00 	st.bhi	r9[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005052:	b2 9c       	st.b	r9[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005054:	fa cb ff 94 	sub	r11,sp,-108
80005058:	10 0b       	add	r11,r8
8000505a:	f7 3b ff f4 	ld.ub	r11,r11[-12]
8000505e:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005062:	ee 0b 18 00 	cp.b	r11,r7
80005066:	f7 bb 08 d0 	subls	r11,-48
8000506a:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
8000506e:	f7 bb 0b a9 	subhi	r11,-87
80005072:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80005076:	b2 bc       	st.b	r9[0x3],r12
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005078:	2f f8       	sub	r8,-1
8000507a:	2f c9       	sub	r9,-4
8000507c:	2f ca       	sub	r10,-4
8000507e:	58 48       	cp.w	r8,4
80005080:	cd 91       	brne	80005032 <rfid_sendID_message+0x9a>
		//header.session_id = (++start_session);
	
		//memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
		//header.type = 0xe000;
	
		memcpy(message, unsure_data, sizeof(Message_Header_t));//疯header版
80005082:	fa c7 ff f0 	sub	r7,sp,-16
80005086:	49 78       	lddpc	r8,800050e0 <rfid_sendID_message+0x148>
80005088:	70 08       	ld.w	r8,r8[0x0]
8000508a:	8f 08       	st.w	r7[0x0],r8
		//memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
		
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
8000508c:	31 0a       	mov	r10,16
8000508e:	1a 9b       	mov	r11,sp
80005090:	fa cc ff ec 	sub	r12,sp,-20
80005094:	f0 1f 00 14 	mcall	800050e4 <rfid_sendID_message+0x14c>
		
		message[sizeof(Message_Header_t)+sizeof(Message_Data_t)] = 0x00;//terminate flag;
80005098:	30 08       	mov	r8,0
8000509a:	fb 68 00 24 	st.b	sp[36],r8
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)+1), destination);
8000509e:	e0 7a 01 01 	mov	r10,65793
800050a2:	31 5b       	mov	r11,21
800050a4:	0e 9c       	mov	r12,r7
800050a6:	f0 1f 00 11 	mcall	800050e8 <rfid_sendID_message+0x150>
		log("no card find...\n");
	}
	
	return return_err;
	
}
800050aa:	0c 9c       	mov	r12,r6
800050ac:	2e 5d       	sub	sp,-108
800050ae:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)+1), destination);
		
	}
	else
	{
		vTaskDelay(500*2 / portTICK_RATE_MS);//寤惰500ms
800050b2:	e0 6c 03 e8 	mov	r12,1000
800050b6:	f0 1f 00 07 	mcall	800050d0 <rfid_sendID_message+0x138>
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
800050ba:	34 fb       	mov	r11,79
800050bc:	30 1c       	mov	r12,1
800050be:	f0 1f 00 08 	mcall	800050dc <rfid_sendID_message+0x144>
		log("no card find...\n");
800050c2:	48 bc       	lddpc	r12,800050ec <rfid_sendID_message+0x154>
800050c4:	f0 1f 00 05 	mcall	800050d8 <rfid_sendID_message+0x140>
800050c8:	cf 1b       	rjmp	800050aa <rfid_sendID_message+0x112>
800050ca:	00 00       	add	r0,r0
800050cc:	80 00       	ld.sh	r0,r0[0x0]
800050ce:	4f 48       	lddpc	r8,8000529c <xg_flashc_init+0x78>
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	68 54       	ld.w	r4,r4[0x14]
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	d6 dc       	*unknown*
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	6d c0       	ld.w	r0,r6[0x70]
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	3f 40       	mov	r0,-12
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	d7 0c       	*unknown*
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	76 3c       	ld.w	r12,r11[0xc]
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	3d fc       	mov	r12,-33
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	d6 f8       	*unknown*

800050f0 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
800050f0:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800050f2:	f0 1f 00 02 	mcall	800050f8 <rfid_init+0x8>
	//rfid_sendID_message();
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
800050f6:	d8 02       	popm	pc
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	49 fc       	lddpc	r12,80005174 <local_start_timer+0x10>

800050fc <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800050fc:	58 0c       	cp.w	r12,0
800050fe:	5e 0c       	reteq	r12
80005100:	30 08       	mov	r8,0
	{
		nop();
80005102:	d7 03       	nop
		nop();
80005104:	d7 03       	nop
		nop();
80005106:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005108:	2f f8       	sub	r8,-1
8000510a:	10 3c       	cp.w	r12,r8
8000510c:	fe 9b ff fb 	brhi	80005102 <delay_ns+0x6>
80005110:	5e fc       	retal	r12
80005112:	d7 03       	nop

80005114 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005114:	eb cd 40 e0 	pushm	r5-r7,lr
80005118:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
8000511a:	58 0c       	cp.w	r12,0
8000511c:	c0 b0       	breq	80005132 <delay_us+0x1e>
8000511e:	30 07       	mov	r7,0
		delay_ns(1000);
80005120:	e0 65 03 e8 	mov	r5,1000
80005124:	0a 9c       	mov	r12,r5
80005126:	f0 1f 00 05 	mcall	80005138 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
8000512a:	2f f7       	sub	r7,-1
8000512c:	0e 36       	cp.w	r6,r7
8000512e:	fe 9b ff fb 	brhi	80005124 <delay_us+0x10>
80005132:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005136:	00 00       	add	r0,r0
80005138:	80 00       	ld.sh	r0,r0[0x0]
8000513a:	50 fc       	stdsp	sp[0x3c],r12

8000513c <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
8000513c:	eb cd 40 e0 	pushm	r5-r7,lr
80005140:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80005142:	58 0c       	cp.w	r12,0
80005144:	c0 b0       	breq	8000515a <delay_ms+0x1e>
80005146:	30 07       	mov	r7,0
		delay_us(1000);
80005148:	e0 65 03 e8 	mov	r5,1000
8000514c:	0a 9c       	mov	r12,r5
8000514e:	f0 1f 00 05 	mcall	80005160 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005152:	2f f7       	sub	r7,-1
80005154:	0e 36       	cp.w	r6,r7
80005156:	fe 9b ff fb 	brhi	8000514c <delay_ms+0x10>
8000515a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000515e:	00 00       	add	r0,r0
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	51 14       	stdsp	sp[0x44],r4

80005164 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005164:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005166:	30 3b       	mov	r11,3
80005168:	48 8c       	lddpc	r12,80005188 <local_start_timer+0x24>
8000516a:	f0 1f 00 09 	mcall	8000518c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000516e:	fe 78 38 00 	mov	r8,-51200
80005172:	e0 69 91 0d 	mov	r9,37133
80005176:	ea 19 00 52 	orh	r9,0x52
8000517a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000517c:	32 09       	mov	r9,32
8000517e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005180:	30 59       	mov	r9,5
80005182:	91 09       	st.w	r8[0x0],r9
}
80005184:	d8 02       	popm	pc
80005186:	00 00       	add	r0,r0
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	d7 10       	acall	0x71
8000518c:	80 00       	ld.sh	r0,r0[0x0]
8000518e:	53 14       	stdsp	sp[0xc4],r4

80005190 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005190:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005192:	30 3a       	mov	r10,3
80005194:	e0 6b 1b 00 	mov	r11,6912
80005198:	ea 1b 00 b7 	orh	r11,0xb7
8000519c:	fe 7c 0c 00 	mov	r12,-62464
800051a0:	f0 1f 00 19 	mcall	80005204 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800051a4:	31 08       	mov	r8,16
800051a6:	1a d8       	st.w	--sp,r8
800051a8:	30 08       	mov	r8,0
800051aa:	30 19       	mov	r9,1
800051ac:	30 7a       	mov	r10,7
800051ae:	10 9b       	mov	r11,r8
800051b0:	fe 7c 0c 00 	mov	r12,-62464
800051b4:	f0 1f 00 15 	mcall	80005208 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
800051b8:	30 08       	mov	r8,0
800051ba:	30 19       	mov	r9,1
800051bc:	12 9a       	mov	r10,r9
800051be:	10 9b       	mov	r11,r8
800051c0:	fe 7c 0c 00 	mov	r12,-62464
800051c4:	f0 1f 00 12 	mcall	8000520c <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
800051c8:	30 0b       	mov	r11,0
800051ca:	fe 7c 0c 00 	mov	r12,-62464
800051ce:	f0 1f 00 11 	mcall	80005210 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
800051d2:	fe 7c 0c 00 	mov	r12,-62464
800051d6:	f0 1f 00 10 	mcall	80005214 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
800051da:	30 0a       	mov	r10,0
800051dc:	1a da       	st.w	--sp,r10
800051de:	1a da       	st.w	--sp,r10
800051e0:	14 98       	mov	r8,r10
800051e2:	14 99       	mov	r9,r10
800051e4:	30 1b       	mov	r11,1
800051e6:	fe 7c 0c 00 	mov	r12,-62464
800051ea:	f0 1f 00 0c 	mcall	80005218 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800051ee:	30 1c       	mov	r12,1
800051f0:	f0 1f 00 0b 	mcall	8000521c <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800051f4:	30 2b       	mov	r11,2
800051f6:	fe 7c 0c 00 	mov	r12,-62464
800051fa:	f0 1f 00 0a 	mcall	80005220 <local_start_pll0+0x90>
800051fe:	2f dd       	sub	sp,-12
/****/
}
80005200:	d8 02       	popm	pc
80005202:	00 00       	add	r0,r0
80005204:	80 00       	ld.sh	r0,r0[0x0]
80005206:	55 c8       	stdsp	sp[0x170],r8
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	55 6a       	stdsp	sp[0x158],r10
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	55 8c       	stdsp	sp[0x160],r12
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	55 a6       	stdsp	sp[0x168],r6
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	55 b4       	stdsp	sp[0x16c],r4
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	55 24       	stdsp	sp[0x148],r4
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	52 b4       	stdsp	sp[0xac],r4
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	55 be       	stdsp	sp[0x16c],lr

80005224 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005224:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005228:	30 0b       	mov	r11,0
8000522a:	30 1c       	mov	r12,1
8000522c:	f0 1f 00 19 	mcall	80005290 <xg_flashc_init+0x6c>
80005230:	49 98       	lddpc	r8,80005294 <xg_flashc_init+0x70>
80005232:	91 0c       	st.w	r8[0x0],r12
80005234:	70 08       	ld.w	r8,r8[0x0]
80005236:	58 08       	cp.w	r8,0
80005238:	c0 80       	breq	80005248 <xg_flashc_init+0x24>
8000523a:	49 78       	lddpc	r8,80005294 <xg_flashc_init+0x70>
8000523c:	70 0c       	ld.w	r12,r8[0x0]
8000523e:	30 09       	mov	r9,0
80005240:	12 9a       	mov	r10,r9
80005242:	12 9b       	mov	r11,r9
80005244:	f0 1f 00 15 	mcall	80005298 <xg_flashc_init+0x74>
	if (xBinarySemaphore == NULL)
80005248:	49 38       	lddpc	r8,80005294 <xg_flashc_init+0x70>
8000524a:	70 08       	ld.w	r8,r8[0x0]
8000524c:	58 08       	cp.w	r8,0
8000524e:	c0 41       	brne	80005256 <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
80005250:	49 3c       	lddpc	r12,8000529c <xg_flashc_init+0x78>
80005252:	f0 1f 00 14 	mcall	800052a0 <xg_flashc_init+0x7c>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
80005256:	30 4b       	mov	r11,4
80005258:	e0 6c 01 2c 	mov	r12,300
8000525c:	f0 1f 00 0d 	mcall	80005290 <xg_flashc_init+0x6c>
80005260:	49 18       	lddpc	r8,800052a4 <xg_flashc_init+0x80>
80005262:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005264:	30 4b       	mov	r11,4
80005266:	e0 6c 01 90 	mov	r12,400
8000526a:	f0 1f 00 0a 	mcall	80005290 <xg_flashc_init+0x6c>
8000526e:	48 f8       	lddpc	r8,800052a8 <xg_flashc_init+0x84>
80005270:	91 0c       	st.w	r8[0x0],r12
80005272:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005274:	10 96       	mov	r6,r8
80005276:	48 e5       	lddpc	r5,800052ac <xg_flashc_init+0x88>
80005278:	6c 0c       	ld.w	r12,r6[0x0]
8000527a:	ea 07 00 0b 	add	r11,r5,r7
8000527e:	f0 1f 00 0d 	mcall	800052b0 <xg_flashc_init+0x8c>
80005282:	2e c7       	sub	r7,-20
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005284:	e0 47 1f 40 	cp.w	r7,8000
80005288:	cf 81       	brne	80005278 <xg_flashc_init+0x54>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
8000528a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000528e:	00 00       	add	r0,r0
80005290:	80 00       	ld.sh	r0,r0[0x0]
80005292:	62 e0       	ld.w	r0,r1[0x38]
80005294:	00 00       	add	r0,r0
80005296:	0b 58       	ld.sh	r8,--r5
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	61 88       	ld.w	r8,r0[0x60]
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	d7 28       	*unknown*
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	6d c0       	ld.w	r0,r6[0x70]
800052a4:	00 00       	add	r0,r0
800052a6:	0b 50       	ld.sh	r0,--r5
800052a8:	00 00       	add	r0,r0
800052aa:	0b 54       	ld.sh	r4,--r5
800052ac:	00 00       	add	r0,r0
800052ae:	97 28       	st.w	r11[0x8],r8
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	2a d8       	sub	r8,-83

800052b4 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800052b4:	fe 68 14 00 	mov	r8,-125952
800052b8:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800052ba:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800052be:	91 09       	st.w	r8[0x0],r9
}
800052c0:	5e fc       	retal	r12

800052c2 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800052c2:	f8 08 16 05 	lsr	r8,r12,0x5
800052c6:	a9 68       	lsl	r8,0x8
800052c8:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800052cc:	58 1b       	cp.w	r11,1
800052ce:	c0 d0       	breq	800052e8 <gpio_enable_module_pin+0x26>
800052d0:	c0 63       	brcs	800052dc <gpio_enable_module_pin+0x1a>
800052d2:	58 2b       	cp.w	r11,2
800052d4:	c1 00       	breq	800052f4 <gpio_enable_module_pin+0x32>
800052d6:	58 3b       	cp.w	r11,3
800052d8:	c1 40       	breq	80005300 <gpio_enable_module_pin+0x3e>
800052da:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800052dc:	30 19       	mov	r9,1
800052de:	f2 0c 09 49 	lsl	r9,r9,r12
800052e2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800052e4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052e6:	c1 28       	rjmp	8000530a <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800052e8:	30 19       	mov	r9,1
800052ea:	f2 0c 09 49 	lsl	r9,r9,r12
800052ee:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800052f0:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052f2:	c0 c8       	rjmp	8000530a <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800052f4:	30 19       	mov	r9,1
800052f6:	f2 0c 09 49 	lsl	r9,r9,r12
800052fa:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800052fc:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800052fe:	c0 68       	rjmp	8000530a <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005300:	30 19       	mov	r9,1
80005302:	f2 0c 09 49 	lsl	r9,r9,r12
80005306:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005308:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000530a:	30 19       	mov	r9,1
8000530c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005310:	91 2c       	st.w	r8[0x8],r12
80005312:	5e fd       	retal	0

80005314 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005314:	d4 21       	pushm	r4-r7,lr
80005316:	18 97       	mov	r7,r12
80005318:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000531a:	58 0b       	cp.w	r11,0
8000531c:	c0 31       	brne	80005322 <gpio_enable_module+0xe>
8000531e:	30 05       	mov	r5,0
80005320:	c0 d8       	rjmp	8000533a <gpio_enable_module+0x26>
80005322:	30 06       	mov	r6,0
80005324:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005326:	6e 1b       	ld.w	r11,r7[0x4]
80005328:	6e 0c       	ld.w	r12,r7[0x0]
8000532a:	f0 1f 00 06 	mcall	80005340 <gpio_enable_module+0x2c>
8000532e:	18 45       	or	r5,r12
		gpiomap++;
80005330:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005332:	2f f6       	sub	r6,-1
80005334:	0c 34       	cp.w	r4,r6
80005336:	fe 9b ff f8 	brhi	80005326 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000533a:	0a 9c       	mov	r12,r5
8000533c:	d8 22       	popm	r4-r7,pc
8000533e:	00 00       	add	r0,r0
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	52 c2       	stdsp	sp[0xb0],r2

80005344 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005344:	f8 08 16 05 	lsr	r8,r12,0x5
80005348:	a9 68       	lsl	r8,0x8
8000534a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000534e:	30 19       	mov	r9,1
80005350:	f2 0c 09 4c 	lsl	r12,r9,r12
80005354:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005358:	91 1c       	st.w	r8[0x4],r12
}
8000535a:	5e fc       	retal	r12

8000535c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000535c:	f8 08 16 05 	lsr	r8,r12,0x5
80005360:	a9 68       	lsl	r8,0x8
80005362:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005366:	30 19       	mov	r9,1
80005368:	f2 0c 09 4c 	lsl	r12,r9,r12
8000536c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005370:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005374:	91 1c       	st.w	r8[0x4],r12
}
80005376:	5e fc       	retal	r12

80005378 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005378:	f8 08 16 05 	lsr	r8,r12,0x5
8000537c:	a9 68       	lsl	r8,0x8
8000537e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005382:	30 19       	mov	r9,1
80005384:	f2 0c 09 4c 	lsl	r12,r9,r12
80005388:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000538c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005390:	91 1c       	st.w	r8[0x4],r12
}
80005392:	5e fc       	retal	r12

80005394 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005394:	c0 08       	rjmp	80005394 <_unhandled_interrupt>
80005396:	d7 03       	nop

80005398 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005398:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000539c:	49 99       	lddpc	r9,80005400 <INTC_register_interrupt+0x68>
8000539e:	f2 08 00 39 	add	r9,r9,r8<<0x3
800053a2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800053a6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800053a8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800053ac:	58 0a       	cp.w	r10,0
800053ae:	c0 91       	brne	800053c0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800053b0:	49 59       	lddpc	r9,80005404 <INTC_register_interrupt+0x6c>
800053b2:	49 6a       	lddpc	r10,80005408 <INTC_register_interrupt+0x70>
800053b4:	12 1a       	sub	r10,r9
800053b6:	fe 79 08 00 	mov	r9,-63488
800053ba:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053be:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800053c0:	58 1a       	cp.w	r10,1
800053c2:	c0 a1       	brne	800053d6 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800053c4:	49 09       	lddpc	r9,80005404 <INTC_register_interrupt+0x6c>
800053c6:	49 2a       	lddpc	r10,8000540c <INTC_register_interrupt+0x74>
800053c8:	12 1a       	sub	r10,r9
800053ca:	bf aa       	sbr	r10,0x1e
800053cc:	fe 79 08 00 	mov	r9,-63488
800053d0:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053d4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800053d6:	58 2a       	cp.w	r10,2
800053d8:	c0 a1       	brne	800053ec <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800053da:	48 b9       	lddpc	r9,80005404 <INTC_register_interrupt+0x6c>
800053dc:	48 da       	lddpc	r10,80005410 <INTC_register_interrupt+0x78>
800053de:	12 1a       	sub	r10,r9
800053e0:	bf ba       	sbr	r10,0x1f
800053e2:	fe 79 08 00 	mov	r9,-63488
800053e6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053ea:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800053ec:	48 69       	lddpc	r9,80005404 <INTC_register_interrupt+0x6c>
800053ee:	48 aa       	lddpc	r10,80005414 <INTC_register_interrupt+0x7c>
800053f0:	12 1a       	sub	r10,r9
800053f2:	ea 1a c0 00 	orh	r10,0xc000
800053f6:	fe 79 08 00 	mov	r9,-63488
800053fa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053fe:	5e fc       	retal	r12
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	d7 60       	acall	0x76
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	cc 00       	breq	80005386 <gpio_clr_gpio_pin+0xe>
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	cd 04       	brge	800053aa <INTC_register_interrupt+0x12>
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	cd 12       	brcc	800053b0 <INTC_register_interrupt+0x18>
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	cd 20       	breq	800053b6 <INTC_register_interrupt+0x1e>
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	cd 2e       	rcall	800051ba <local_start_pll0+0x2a>

80005418 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005418:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000541a:	49 18       	lddpc	r8,8000545c <INTC_init_interrupts+0x44>
8000541c:	e3 b8 00 01 	mtsr	0x4,r8
80005420:	49 0e       	lddpc	lr,80005460 <INTC_init_interrupts+0x48>
80005422:	30 07       	mov	r7,0
80005424:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005426:	49 0c       	lddpc	r12,80005464 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005428:	49 05       	lddpc	r5,80005468 <INTC_init_interrupts+0x50>
8000542a:	10 15       	sub	r5,r8
8000542c:	fe 76 08 00 	mov	r6,-63488
80005430:	c1 08       	rjmp	80005450 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005432:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005434:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005436:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005438:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000543c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000543e:	10 3a       	cp.w	r10,r8
80005440:	fe 9b ff fc 	brhi	80005438 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005444:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005448:	2f f7       	sub	r7,-1
8000544a:	2f 8e       	sub	lr,-8
8000544c:	59 37       	cp.w	r7,19
8000544e:	c0 50       	breq	80005458 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005450:	7c 08       	ld.w	r8,lr[0x0]
80005452:	58 08       	cp.w	r8,0
80005454:	ce f1       	brne	80005432 <INTC_init_interrupts+0x1a>
80005456:	cf 7b       	rjmp	80005444 <INTC_init_interrupts+0x2c>
80005458:	d8 22       	popm	r4-r7,pc
8000545a:	00 00       	add	r0,r0
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	cc 00       	breq	800053de <INTC_register_interrupt+0x46>
80005460:	80 00       	ld.sh	r0,r0[0x0]
80005462:	d7 60       	acall	0x76
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	53 94       	stdsp	sp[0xe4],r4
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	cd 04       	brge	8000540a <INTC_register_interrupt+0x72>

8000546c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000546c:	fe 78 08 00 	mov	r8,-63488
80005470:	e0 69 00 83 	mov	r9,131
80005474:	f2 0c 01 0c 	sub	r12,r9,r12
80005478:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000547c:	f2 ca ff c0 	sub	r10,r9,-64
80005480:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005484:	58 08       	cp.w	r8,0
80005486:	c0 21       	brne	8000548a <_get_interrupt_handler+0x1e>
80005488:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000548a:	f0 08 12 00 	clz	r8,r8
8000548e:	48 5a       	lddpc	r10,800054a0 <_get_interrupt_handler+0x34>
80005490:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005494:	f0 08 11 1f 	rsub	r8,r8,31
80005498:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000549a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000549e:	5e fc       	retal	r12
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	d7 60       	acall	0x76

800054a4 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800054a4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800054a6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800054aa:	99 a8       	st.w	r12[0x28],r8
}
800054ac:	5e fc       	retal	r12
800054ae:	d7 03       	nop

800054b0 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800054b0:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800054b2:	ec 5b bb 9f 	cp.w	r11,899999
800054b6:	e0 8b 00 04 	brhi	800054be <pm_enable_osc0_crystal+0xe>
800054ba:	30 4b       	mov	r11,4
800054bc:	c1 38       	rjmp	800054e2 <pm_enable_osc0_crystal+0x32>
800054be:	e0 68 c6 bf 	mov	r8,50879
800054c2:	ea 18 00 2d 	orh	r8,0x2d
800054c6:	10 3b       	cp.w	r11,r8
800054c8:	e0 8b 00 04 	brhi	800054d0 <pm_enable_osc0_crystal+0x20>
800054cc:	30 5b       	mov	r11,5
800054ce:	c0 a8       	rjmp	800054e2 <pm_enable_osc0_crystal+0x32>
800054d0:	e0 68 12 00 	mov	r8,4608
800054d4:	ea 18 00 7a 	orh	r8,0x7a
800054d8:	10 3b       	cp.w	r11,r8
800054da:	f9 bb 03 06 	movlo	r11,6
800054de:	f9 bb 02 07 	movhs	r11,7
800054e2:	f0 1f 00 02 	mcall	800054e8 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800054e6:	d8 02       	popm	pc
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	54 a4       	stdsp	sp[0x128],r4

800054ec <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800054ec:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800054ee:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800054f2:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800054f4:	78 08       	ld.w	r8,r12[0x0]
800054f6:	a3 a8       	sbr	r8,0x2
800054f8:	99 08       	st.w	r12[0x0],r8
}
800054fa:	5e fc       	retal	r12

800054fc <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800054fc:	79 58       	ld.w	r8,r12[0x54]
800054fe:	e2 18 00 80 	andl	r8,0x80,COH
80005502:	cf d0       	breq	800054fc <pm_wait_for_clk0_ready>
}
80005504:	5e fc       	retal	r12
80005506:	d7 03       	nop

80005508 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005508:	eb cd 40 80 	pushm	r7,lr
8000550c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000550e:	f0 1f 00 04 	mcall	8000551c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80005512:	0e 9c       	mov	r12,r7
80005514:	f0 1f 00 03 	mcall	80005520 <pm_enable_clk0+0x18>
}
80005518:	e3 cd 80 80 	ldm	sp++,r7,pc
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	54 ec       	stdsp	sp[0x138],r12
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	54 fc       	stdsp	sp[0x13c],r12

80005524 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005524:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005528:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
8000552c:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000552e:	09 f7       	ld.ub	r7,r4[0x7]
80005530:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005534:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005538:	09 b4       	ld.ub	r4,r4[0x3]
8000553a:	08 96       	mov	r6,r4
8000553c:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005540:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005544:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005548:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
8000554c:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005550:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005554:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005558:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
8000555c:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000555e:	79 58       	ld.w	r8,r12[0x54]
80005560:	e2 18 00 20 	andl	r8,0x20,COH
80005564:	cf d0       	breq	8000555e <pm_cksel+0x3a>
}
80005566:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000556a <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000556a:	eb cd 40 80 	pushm	r7,lr
8000556e:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005570:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005572:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80005576:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000557a:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000557e:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005582:	2f 8b       	sub	r11,-8
80005584:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005588:	e3 cd 80 80 	ldm	sp++,r7,pc

8000558c <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
8000558c:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000558e:	2f 8b       	sub	r11,-8
80005590:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005594:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005598:	f3 e8 10 28 	or	r8,r9,r8<<0x2
8000559c:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800055a0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800055a4:	d8 02       	popm	pc

800055a6 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800055a6:	2f 8b       	sub	r11,-8
800055a8:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800055ac:	a1 a8       	sbr	r8,0x0
800055ae:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800055b2:	5e fc       	retal	r12

800055b4 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800055b4:	79 58       	ld.w	r8,r12[0x54]
800055b6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800055ba:	cf d0       	breq	800055b4 <pm_wait_for_pll0_locked>
}
800055bc:	5e fc       	retal	r12

800055be <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800055be:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800055c0:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800055c4:	99 08       	st.w	r12[0x0],r8
}
800055c6:	5e fc       	retal	r12

800055c8 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800055c8:	eb cd 40 c0 	pushm	r6-r7,lr
800055cc:	18 97       	mov	r7,r12
800055ce:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800055d0:	f0 1f 00 06 	mcall	800055e8 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800055d4:	0c 9b       	mov	r11,r6
800055d6:	0e 9c       	mov	r12,r7
800055d8:	f0 1f 00 05 	mcall	800055ec <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800055dc:	30 1b       	mov	r11,1
800055de:	0e 9c       	mov	r12,r7
800055e0:	f0 1f 00 04 	mcall	800055f0 <pm_switch_to_osc0+0x28>
}
800055e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	54 b0       	stdsp	sp[0x12c],r0
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	55 08       	stdsp	sp[0x140],r8
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	55 be       	stdsp	sp[0x16c],lr

800055f4 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800055f4:	f8 c8 00 01 	sub	r8,r12,1
800055f8:	f0 0b 00 0b 	add	r11,r8,r11
800055fc:	f6 0c 0d 0a 	divu	r10,r11,r12
80005600:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005602:	f4 c8 00 01 	sub	r8,r10,1
80005606:	e0 48 00 fe 	cp.w	r8,254
8000560a:	e0 88 00 03 	brls	80005610 <getBaudDiv+0x1c>
8000560e:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005610:	5c 8c       	casts.h	r12
}
80005612:	5e fc       	retal	r12

80005614 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005614:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005618:	30 18       	mov	r8,1
8000561a:	f0 09 18 00 	cp.b	r9,r8
8000561e:	e0 88 00 04 	brls	80005626 <spi_initMaster+0x12>
80005622:	30 2c       	mov	r12,2
80005624:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005626:	e0 68 00 80 	mov	r8,128
8000562a:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
8000562c:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
8000562e:	30 19       	mov	r9,1
80005630:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005634:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005638:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
8000563c:	30 09       	mov	r9,0
8000563e:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005642:	30 fa       	mov	r10,15
80005644:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005648:	99 18       	st.w	r12[0x4],r8
8000564a:	5e f9       	retal	r9

8000564c <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
8000564c:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000564e:	30 18       	mov	r8,1
80005650:	f0 0b 18 00 	cp.b	r11,r8
80005654:	5f be       	srhi	lr
80005656:	f0 0a 18 00 	cp.b	r10,r8
8000565a:	5f b8       	srhi	r8
8000565c:	fd e8 10 08 	or	r8,lr,r8
80005660:	c0 30       	breq	80005666 <spi_selectionMode+0x1a>
80005662:	30 2c       	mov	r12,2
80005664:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005666:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005668:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000566c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005670:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005674:	99 18       	st.w	r12[0x4],r8
80005676:	d8 0a       	popm	pc,r12=0

80005678 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005678:	30 18       	mov	r8,1
8000567a:	99 08       	st.w	r12[0x0],r8
}
8000567c:	5e fc       	retal	r12

8000567e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000567e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005682:	c0 58       	rjmp	8000568c <spi_write+0xe>
		if (!timeout--) {
80005684:	58 08       	cp.w	r8,0
80005686:	c0 21       	brne	8000568a <spi_write+0xc>
80005688:	5e ff       	retal	1
8000568a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000568c:	78 49       	ld.w	r9,r12[0x10]
8000568e:	e2 19 00 02 	andl	r9,0x2,COH
80005692:	cf 90       	breq	80005684 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005694:	5c 7b       	castu.h	r11
80005696:	99 3b       	st.w	r12[0xc],r11
80005698:	5e fd       	retal	0

8000569a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000569a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000569e:	c0 58       	rjmp	800056a8 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800056a0:	58 08       	cp.w	r8,0
800056a2:	c0 21       	brne	800056a6 <spi_read+0xc>
800056a4:	5e ff       	retal	1
800056a6:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800056a8:	78 49       	ld.w	r9,r12[0x10]
800056aa:	e2 19 02 01 	andl	r9,0x201,COH
800056ae:	e0 49 02 01 	cp.w	r9,513
800056b2:	cf 71       	brne	800056a0 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800056b4:	78 28       	ld.w	r8,r12[0x8]
800056b6:	b6 08       	st.h	r11[0x0],r8
800056b8:	5e fd       	retal	0
800056ba:	d7 03       	nop

800056bc <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800056bc:	eb cd 40 f8 	pushm	r3-r7,lr
800056c0:	18 95       	mov	r5,r12
800056c2:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800056c4:	f7 36 00 0c 	ld.ub	r6,r11[12]
800056c8:	30 38       	mov	r8,3
800056ca:	f0 06 18 00 	cp.b	r6,r8
800056ce:	e0 8b 00 5e 	brhi	8000578a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800056d2:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800056d6:	30 18       	mov	r8,1
800056d8:	f0 04 18 00 	cp.b	r4,r8
800056dc:	e0 8b 00 57 	brhi	8000578a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800056e0:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800056e4:	30 78       	mov	r8,7
800056e6:	f0 03 18 00 	cp.b	r3,r8
800056ea:	e0 88 00 50 	brls	8000578a <spi_setupChipReg+0xce>
800056ee:	31 08       	mov	r8,16
800056f0:	f0 03 18 00 	cp.b	r3,r8
800056f4:	e0 8b 00 4b 	brhi	8000578a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800056f8:	14 9b       	mov	r11,r10
800056fa:	6e 1c       	ld.w	r12,r7[0x4]
800056fc:	f0 1f 00 26 	mcall	80005794 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005700:	c4 55       	brlt	8000578a <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005702:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005704:	ec 09 16 01 	lsr	r9,r6,0x1
80005708:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
8000570c:	ec 16 00 01 	eorl	r6,0x1
80005710:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005714:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005718:	20 83       	sub	r3,8
8000571a:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000571e:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005722:	ef 39 00 09 	ld.ub	r9,r7[9]
80005726:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000572a:	ef 39 00 0a 	ld.ub	r9,r7[10]
8000572e:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005732:	0f 89       	ld.ub	r9,r7[0x0]
80005734:	30 1a       	mov	r10,1
80005736:	f4 09 18 00 	cp.b	r9,r10
8000573a:	c0 d0       	breq	80005754 <spi_setupChipReg+0x98>
8000573c:	c0 a3       	brcs	80005750 <spi_setupChipReg+0x94>
8000573e:	30 2a       	mov	r10,2
80005740:	f4 09 18 00 	cp.b	r9,r10
80005744:	c0 a0       	breq	80005758 <spi_setupChipReg+0x9c>
80005746:	30 3a       	mov	r10,3
80005748:	f4 09 18 00 	cp.b	r9,r10
8000574c:	c1 f1       	brne	8000578a <spi_setupChipReg+0xce>
8000574e:	c0 78       	rjmp	8000575c <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005750:	8b c8       	st.w	r5[0x30],r8
		break;
80005752:	c0 68       	rjmp	8000575e <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005754:	8b d8       	st.w	r5[0x34],r8
		break;
80005756:	c0 48       	rjmp	8000575e <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005758:	8b e8       	st.w	r5[0x38],r8
		break;
8000575a:	c0 28       	rjmp	8000575e <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
8000575c:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000575e:	48 f8       	lddpc	r8,80005798 <spi_setupChipReg+0xdc>
80005760:	70 08       	ld.w	r8,r8[0x0]
80005762:	58 08       	cp.w	r8,0
80005764:	c1 61       	brne	80005790 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005766:	30 0b       	mov	r11,0
80005768:	30 1c       	mov	r12,1
8000576a:	f0 1f 00 0d 	mcall	8000579c <spi_setupChipReg+0xe0>
8000576e:	48 b8       	lddpc	r8,80005798 <spi_setupChipReg+0xdc>
80005770:	91 0c       	st.w	r8[0x0],r12
80005772:	58 0c       	cp.w	r12,0
80005774:	c0 a0       	breq	80005788 <spi_setupChipReg+0xcc>
80005776:	30 09       	mov	r9,0
80005778:	12 9a       	mov	r10,r9
8000577a:	12 9b       	mov	r11,r9
8000577c:	f0 1f 00 09 	mcall	800057a0 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005780:	48 68       	lddpc	r8,80005798 <spi_setupChipReg+0xdc>
80005782:	70 08       	ld.w	r8,r8[0x0]
80005784:	58 08       	cp.w	r8,0
80005786:	c0 51       	brne	80005790 <spi_setupChipReg+0xd4>
80005788:	c0 08       	rjmp	80005788 <spi_setupChipReg+0xcc>
8000578a:	30 2c       	mov	r12,2
8000578c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005790:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005794:	80 00       	ld.sh	r0,r0[0x0]
80005796:	55 f4       	stdsp	sp[0x17c],r4
80005798:	00 00       	add	r0,r0
8000579a:	b6 6c       	st.h	r11[0xc],r12
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	62 e0       	ld.w	r0,r1[0x38]
800057a0:	80 00       	ld.sh	r0,r0[0x0]
800057a2:	61 88       	ld.w	r8,r0[0x60]

800057a4 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800057a4:	d4 01       	pushm	lr
800057a6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800057aa:	c0 58       	rjmp	800057b4 <spi_unselectChip+0x10>
		if (!timeout--) {
800057ac:	58 08       	cp.w	r8,0
800057ae:	c0 21       	brne	800057b2 <spi_unselectChip+0xe>
800057b0:	da 0a       	popm	pc,r12=1
800057b2:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800057b4:	78 49       	ld.w	r9,r12[0x10]
800057b6:	e2 19 02 00 	andl	r9,0x200,COH
800057ba:	cf 90       	breq	800057ac <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800057bc:	78 18       	ld.w	r8,r12[0x4]
800057be:	ea 18 00 0f 	orh	r8,0xf
800057c2:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800057c4:	fc 18 01 00 	movh	r8,0x100
800057c8:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800057ca:	30 09       	mov	r9,0
800057cc:	12 9a       	mov	r10,r9
800057ce:	12 9b       	mov	r11,r9
800057d0:	48 38       	lddpc	r8,800057dc <spi_unselectChip+0x38>
800057d2:	70 0c       	ld.w	r12,r8[0x0]
800057d4:	f0 1f 00 03 	mcall	800057e0 <spi_unselectChip+0x3c>
800057d8:	d8 0a       	popm	pc,r12=0
800057da:	00 00       	add	r0,r0
800057dc:	00 00       	add	r0,r0
800057de:	b6 6c       	st.h	r11[0xc],r12
800057e0:	80 00       	ld.sh	r0,r0[0x0]
800057e2:	61 88       	ld.w	r8,r0[0x60]

800057e4 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800057e4:	eb cd 40 f8 	pushm	r3-r7,lr
800057e8:	18 94       	mov	r4,r12
800057ea:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800057ec:	49 a6       	lddpc	r6,80005854 <spi_selectChip+0x70>
800057ee:	30 07       	mov	r7,0
800057f0:	31 45       	mov	r5,20
800057f2:	0e 99       	mov	r9,r7
800057f4:	0a 9a       	mov	r10,r5
800057f6:	0e 9b       	mov	r11,r7
800057f8:	6c 0c       	ld.w	r12,r6[0x0]
800057fa:	f0 1f 00 18 	mcall	80005858 <spi_selectChip+0x74>
800057fe:	cf a0       	breq	800057f2 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005800:	68 18       	ld.w	r8,r4[0x4]
80005802:	ea 18 00 0f 	orh	r8,0xf
80005806:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005808:	68 18       	ld.w	r8,r4[0x4]
8000580a:	e2 18 00 04 	andl	r8,0x4,COH
8000580e:	c1 10       	breq	80005830 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005810:	30 e8       	mov	r8,14
80005812:	f0 03 18 00 	cp.b	r3,r8
80005816:	e0 8b 00 1c 	brhi	8000584e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000581a:	68 19       	ld.w	r9,r4[0x4]
8000581c:	e6 08 15 10 	lsl	r8,r3,0x10
80005820:	ea 18 ff f0 	orh	r8,0xfff0
80005824:	e8 18 ff ff 	orl	r8,0xffff
80005828:	12 68       	and	r8,r9
8000582a:	89 18       	st.w	r4[0x4],r8
8000582c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005830:	30 38       	mov	r8,3
80005832:	f0 03 18 00 	cp.b	r3,r8
80005836:	e0 8b 00 0c 	brhi	8000584e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000583a:	68 19       	ld.w	r9,r4[0x4]
8000583c:	2f 03       	sub	r3,-16
8000583e:	30 18       	mov	r8,1
80005840:	f0 03 09 48 	lsl	r8,r8,r3
80005844:	5c d8       	com	r8
80005846:	12 68       	and	r8,r9
80005848:	89 18       	st.w	r4[0x4],r8
8000584a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000584e:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005850:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005854:	00 00       	add	r0,r0
80005856:	b6 6c       	st.h	r11[0xc],r12
80005858:	80 00       	ld.sh	r0,r0[0x0]
8000585a:	5f 7c       	srpl	r12

8000585c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000585c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000585e:	f6 08 15 04 	lsl	r8,r11,0x4
80005862:	14 38       	cp.w	r8,r10
80005864:	f9 b8 08 10 	movls	r8,16
80005868:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000586c:	f0 0b 02 4b 	mul	r11,r8,r11
80005870:	f6 09 16 01 	lsr	r9,r11,0x1
80005874:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005878:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000587c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005880:	f2 cb 00 01 	sub	r11,r9,1
80005884:	e0 4b ff fe 	cp.w	r11,65534
80005888:	e0 88 00 03 	brls	8000588e <usart_set_async_baudrate+0x32>
8000588c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000588e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005890:	e8 6e 00 00 	mov	lr,524288
80005894:	59 08       	cp.w	r8,16
80005896:	fc 08 17 10 	movne	r8,lr
8000589a:	f9 b8 00 00 	moveq	r8,0
8000589e:	e4 1b ff f7 	andh	r11,0xfff7
800058a2:	e0 1b fe cf 	andl	r11,0xfecf
800058a6:	16 48       	or	r8,r11
800058a8:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800058aa:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800058ae:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800058b2:	99 89       	st.w	r12[0x20],r9
800058b4:	d8 0a       	popm	pc,r12=0

800058b6 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800058b6:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800058b8:	e2 18 00 02 	andl	r8,0x2,COH
800058bc:	c0 31       	brne	800058c2 <usart_write_char+0xc>
800058be:	30 2c       	mov	r12,2
800058c0:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800058c2:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800058c6:	99 7b       	st.w	r12[0x1c],r11
800058c8:	5e fd       	retal	0
800058ca:	d7 03       	nop

800058cc <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800058cc:	eb cd 40 e0 	pushm	r5-r7,lr
800058d0:	18 96       	mov	r6,r12
800058d2:	16 95       	mov	r5,r11
800058d4:	e0 67 27 0f 	mov	r7,9999
800058d8:	c0 68       	rjmp	800058e4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800058da:	58 07       	cp.w	r7,0
800058dc:	c0 31       	brne	800058e2 <usart_putchar+0x16>
800058de:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800058e2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800058e4:	0a 9b       	mov	r11,r5
800058e6:	0c 9c       	mov	r12,r6
800058e8:	f0 1f 00 03 	mcall	800058f4 <usart_putchar+0x28>
800058ec:	cf 71       	brne	800058da <usart_putchar+0xe>

  return USART_SUCCESS;
}
800058ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800058f2:	00 00       	add	r0,r0
800058f4:	80 00       	ld.sh	r0,r0[0x0]
800058f6:	58 b6       	cp.w	r6,11

800058f8 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800058f8:	78 58       	ld.w	r8,r12[0x14]
800058fa:	e2 18 00 e0 	andl	r8,0xe0,COH
800058fe:	c0 30       	breq	80005904 <usart_read_char+0xc>
80005900:	30 4c       	mov	r12,4
80005902:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005904:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005906:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000590a:	c0 31       	brne	80005910 <usart_read_char+0x18>
8000590c:	30 3c       	mov	r12,3
8000590e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005910:	78 68       	ld.w	r8,r12[0x18]
80005912:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005916:	97 08       	st.w	r11[0x0],r8
80005918:	5e fd       	retal	0
8000591a:	d7 03       	nop

8000591c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
8000591c:	eb cd 40 c0 	pushm	r6-r7,lr
80005920:	20 1d       	sub	sp,4
80005922:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005924:	1a 97       	mov	r7,sp
80005926:	1a 9b       	mov	r11,sp
80005928:	0c 9c       	mov	r12,r6
8000592a:	f0 1f 00 07 	mcall	80005944 <usart_getchar+0x28>
8000592e:	58 3c       	cp.w	r12,3
80005930:	cf b0       	breq	80005926 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005932:	58 4c       	cp.w	r12,4
80005934:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005938:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
8000593c:	2f fd       	sub	sp,-4
8000593e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005942:	00 00       	add	r0,r0
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	58 f8       	cp.w	r8,15

80005948 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005948:	eb cd 40 c0 	pushm	r6-r7,lr
8000594c:	18 96       	mov	r6,r12
8000594e:	16 97       	mov	r7,r11
  while (*string != '\0')
80005950:	17 8b       	ld.ub	r11,r11[0x0]
80005952:	58 0b       	cp.w	r11,0
80005954:	c0 80       	breq	80005964 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005956:	2f f7       	sub	r7,-1
80005958:	0c 9c       	mov	r12,r6
8000595a:	f0 1f 00 04 	mcall	80005968 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000595e:	0f 8b       	ld.ub	r11,r7[0x0]
80005960:	58 0b       	cp.w	r11,0
80005962:	cf a1       	brne	80005956 <usart_write_line+0xe>
80005964:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	58 cc       	cp.w	r12,12

8000596c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000596c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005970:	e6 18 00 01 	andh	r8,0x1,COH
80005974:	c0 71       	brne	80005982 <usart_reset+0x16>
80005976:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005978:	3f f8       	mov	r8,-1
8000597a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000597c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000597e:	d5 03       	csrf	0x10
80005980:	c0 48       	rjmp	80005988 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005982:	3f f8       	mov	r8,-1
80005984:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005986:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005988:	30 08       	mov	r8,0
8000598a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
8000598c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000598e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005990:	ea 68 61 0c 	mov	r8,680204
80005994:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005996:	5e fc       	retal	r12

80005998 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005998:	eb cd 40 e0 	pushm	r5-r7,lr
8000599c:	18 96       	mov	r6,r12
8000599e:	16 97       	mov	r7,r11
800059a0:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800059a2:	f0 1f 00 2f 	mcall	80005a5c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800059a6:	58 07       	cp.w	r7,0
800059a8:	c5 80       	breq	80005a58 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800059aa:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800059ac:	30 49       	mov	r9,4
800059ae:	f2 08 18 00 	cp.b	r8,r9
800059b2:	e0 88 00 53 	brls	80005a58 <usart_init_rs232+0xc0>
800059b6:	30 99       	mov	r9,9
800059b8:	f2 08 18 00 	cp.b	r8,r9
800059bc:	e0 8b 00 4e 	brhi	80005a58 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800059c0:	0f d9       	ld.ub	r9,r7[0x5]
800059c2:	30 78       	mov	r8,7
800059c4:	f0 09 18 00 	cp.b	r9,r8
800059c8:	e0 8b 00 48 	brhi	80005a58 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800059cc:	8e 39       	ld.sh	r9,r7[0x6]
800059ce:	e0 68 01 01 	mov	r8,257
800059d2:	f0 09 19 00 	cp.h	r9,r8
800059d6:	e0 8b 00 41 	brhi	80005a58 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800059da:	ef 39 00 08 	ld.ub	r9,r7[8]
800059de:	30 38       	mov	r8,3
800059e0:	f0 09 18 00 	cp.b	r9,r8
800059e4:	e0 8b 00 3a 	brhi	80005a58 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800059e8:	0a 9a       	mov	r10,r5
800059ea:	6e 0b       	ld.w	r11,r7[0x0]
800059ec:	0c 9c       	mov	r12,r6
800059ee:	f0 1f 00 1d 	mcall	80005a60 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800059f2:	58 1c       	cp.w	r12,1
800059f4:	c3 20       	breq	80005a58 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800059f6:	0f c8       	ld.ub	r8,r7[0x4]
800059f8:	30 99       	mov	r9,9
800059fa:	f2 08 18 00 	cp.b	r8,r9
800059fe:	c0 51       	brne	80005a08 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005a00:	6c 18       	ld.w	r8,r6[0x4]
80005a02:	b1 b8       	sbr	r8,0x11
80005a04:	8d 18       	st.w	r6[0x4],r8
80005a06:	c0 68       	rjmp	80005a12 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005a08:	6c 19       	ld.w	r9,r6[0x4]
80005a0a:	20 58       	sub	r8,5
80005a0c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005a10:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005a12:	6c 19       	ld.w	r9,r6[0x4]
80005a14:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005a18:	0f d8       	ld.ub	r8,r7[0x5]
80005a1a:	a9 78       	lsl	r8,0x9
80005a1c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005a20:	12 48       	or	r8,r9
80005a22:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005a24:	8e 38       	ld.sh	r8,r7[0x6]
80005a26:	30 29       	mov	r9,2
80005a28:	f2 08 19 00 	cp.h	r8,r9
80005a2c:	e0 88 00 09 	brls	80005a3e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005a30:	6c 18       	ld.w	r8,r6[0x4]
80005a32:	ad b8       	sbr	r8,0xd
80005a34:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005a36:	8e b8       	ld.uh	r8,r7[0x6]
80005a38:	20 28       	sub	r8,2
80005a3a:	8d a8       	st.w	r6[0x28],r8
80005a3c:	c0 68       	rjmp	80005a48 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005a3e:	6c 19       	ld.w	r9,r6[0x4]
80005a40:	5c 78       	castu.h	r8
80005a42:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005a46:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005a48:	6c 18       	ld.w	r8,r6[0x4]
80005a4a:	e0 18 ff f0 	andl	r8,0xfff0
80005a4e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005a50:	35 08       	mov	r8,80
80005a52:	8d 08       	st.w	r6[0x0],r8
80005a54:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005a58:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005a5c:	80 00       	ld.sh	r0,r0[0x0]
80005a5e:	59 6c       	cp.w	r12,22
80005a60:	80 00       	ld.sh	r0,r0[0x0]
80005a62:	58 5c       	cp.w	r12,5

80005a64 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005a64:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005a68:	fe c0 8e 68 	sub	r0,pc,-29080

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005a6c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005a70:	d5 53       	csrf	0x15
  cp      r0, r1
80005a72:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005a74:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005a78:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005a7a:	c0 62       	brcc	80005a86 <idata_load_loop_end>
  cp      r0, r1
80005a7c:	48 92       	lddpc	r2,80005aa0 <udata_clear_loop_end+0x4>

80005a7e <idata_load_loop>:
  brlo    idata_load_loop
80005a7e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005a80:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005a82:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005a84:	cf d3       	brcs	80005a7e <idata_load_loop>

80005a86 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005a86:	e0 60 0a 38 	mov	r0,2616
  mov     r2, 0
  mov     r3, 0
80005a8a:	e0 61 b6 80 	mov	r1,46720
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005a8e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005a90:	c0 62       	brcc	80005a9c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005a92:	30 02       	mov	r2,0
80005a94:	30 03       	mov	r3,0

80005a96 <udata_clear_loop>:
80005a96:	a1 22       	st.d	r0++,r2
80005a98:	02 30       	cp.w	r0,r1
80005a9a:	cf e3       	brcs	80005a96 <udata_clear_loop>

80005a9c <udata_clear_loop_end>:
80005a9c:	fe cf e9 28 	sub	pc,pc,-5848
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	e0 90 f8 c8 	breq	80044c32 <_data_lma+0x36ba2>

80005aa4 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005aa4:	f8 c8 ff f8 	sub	r8,r12,-8
80005aa8:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005aaa:	3f f9       	mov	r9,-1
80005aac:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005aae:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005ab0:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005ab2:	30 08       	mov	r8,0
80005ab4:	99 08       	st.w	r12[0x0],r8
}
80005ab6:	5e fc       	retal	r12

80005ab8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005ab8:	30 08       	mov	r8,0
80005aba:	99 48       	st.w	r12[0x10],r8
}
80005abc:	5e fc       	retal	r12

80005abe <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005abe:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005ac0:	70 19       	ld.w	r9,r8[0x4]
80005ac2:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005ac4:	78 19       	ld.w	r9,r12[0x4]
80005ac6:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005ac8:	70 19       	ld.w	r9,r8[0x4]
80005aca:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005acc:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005ace:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005ad0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005ad2:	78 08       	ld.w	r8,r12[0x0]
80005ad4:	2f f8       	sub	r8,-1
80005ad6:	99 08       	st.w	r12[0x0],r8
}
80005ad8:	5e fc       	retal	r12

80005ada <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005ada:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005adc:	5b fa       	cp.w	r10,-1
80005ade:	c0 31       	brne	80005ae4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005ae0:	78 48       	ld.w	r8,r12[0x10]
80005ae2:	c0 c8       	rjmp	80005afa <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005ae4:	f8 c8 ff f8 	sub	r8,r12,-8
80005ae8:	70 19       	ld.w	r9,r8[0x4]
80005aea:	72 09       	ld.w	r9,r9[0x0]
80005aec:	12 3a       	cp.w	r10,r9
80005aee:	c0 63       	brcs	80005afa <vListInsert+0x20>
80005af0:	70 18       	ld.w	r8,r8[0x4]
80005af2:	70 19       	ld.w	r9,r8[0x4]
80005af4:	72 09       	ld.w	r9,r9[0x0]
80005af6:	12 3a       	cp.w	r10,r9
80005af8:	cf c2       	brcc	80005af0 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005afa:	70 19       	ld.w	r9,r8[0x4]
80005afc:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005afe:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005b00:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b02:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b04:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b06:	78 08       	ld.w	r8,r12[0x0]
80005b08:	2f f8       	sub	r8,-1
80005b0a:	99 08       	st.w	r12[0x0],r8
}
80005b0c:	5e fc       	retal	r12

80005b0e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005b0e:	78 18       	ld.w	r8,r12[0x4]
80005b10:	78 29       	ld.w	r9,r12[0x8]
80005b12:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005b14:	78 28       	ld.w	r8,r12[0x8]
80005b16:	78 19       	ld.w	r9,r12[0x4]
80005b18:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005b1a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005b1c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005b1e:	18 39       	cp.w	r9,r12
80005b20:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005b24:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005b28:	30 09       	mov	r9,0
80005b2a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005b2c:	70 09       	ld.w	r9,r8[0x0]
80005b2e:	20 19       	sub	r9,1
80005b30:	91 09       	st.w	r8[0x0],r9
}
80005b32:	5e fc       	retal	r12

80005b34 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005b34:	e0 68 08 08 	mov	r8,2056
80005b38:	ea 18 08 08 	orh	r8,0x808
80005b3c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005b3e:	e0 68 09 09 	mov	r8,2313
80005b42:	ea 18 09 09 	orh	r8,0x909
80005b46:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005b48:	e0 68 0a 0a 	mov	r8,2570
80005b4c:	ea 18 0a 0a 	orh	r8,0xa0a
80005b50:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005b52:	e0 68 0b 0b 	mov	r8,2827
80005b56:	ea 18 0b 0b 	orh	r8,0xb0b
80005b5a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005b5c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005b5e:	e0 68 be ef 	mov	r8,48879
80005b62:	ea 18 de ad 	orh	r8,0xdead
80005b66:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005b68:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005b6a:	fc 18 00 40 	movh	r8,0x40
80005b6e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005b70:	e0 68 00 ff 	mov	r8,255
80005b74:	ea 18 ff 00 	orh	r8,0xff00
80005b78:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005b7a:	e0 68 01 01 	mov	r8,257
80005b7e:	ea 18 01 01 	orh	r8,0x101
80005b82:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005b84:	e0 68 02 02 	mov	r8,514
80005b88:	ea 18 02 02 	orh	r8,0x202
80005b8c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005b8e:	e0 68 03 03 	mov	r8,771
80005b92:	ea 18 03 03 	orh	r8,0x303
80005b96:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005b98:	e0 68 04 04 	mov	r8,1028
80005b9c:	ea 18 04 04 	orh	r8,0x404
80005ba0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005ba2:	e0 68 05 05 	mov	r8,1285
80005ba6:	ea 18 05 05 	orh	r8,0x505
80005baa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005bac:	e0 68 06 06 	mov	r8,1542
80005bb0:	ea 18 06 06 	orh	r8,0x606
80005bb4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005bb6:	e0 68 07 07 	mov	r8,1799
80005bba:	ea 18 07 07 	orh	r8,0x707
80005bbe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005bc0:	30 08       	mov	r8,0
80005bc2:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005bc4:	5e fc       	retal	r12
80005bc6:	d7 03       	nop

80005bc8 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005bc8:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005bca:	48 38       	lddpc	r8,80005bd4 <vPortEnterCritical+0xc>
80005bcc:	70 09       	ld.w	r9,r8[0x0]
80005bce:	2f f9       	sub	r9,-1
80005bd0:	91 09       	st.w	r8[0x0],r9
}
80005bd2:	5e fc       	retal	r12
80005bd4:	00 00       	add	r0,r0
80005bd6:	05 28       	ld.uh	r8,r2++

80005bd8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005bd8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005bda:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005bdc:	30 0a       	mov	r10,0
80005bde:	14 9b       	mov	r11,r10
80005be0:	49 2c       	lddpc	r12,80005c28 <xPortStartScheduler+0x50>
80005be2:	f0 1f 00 13 	mcall	80005c2c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005be6:	e0 68 5d c0 	mov	r8,24000
80005bea:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005bee:	30 08       	mov	r8,0
80005bf0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005bf4:	e0 68 0c d4 	mov	r8,3284
80005bf8:	ea 18 00 00 	orh	r8,0x0
80005bfc:	70 00       	ld.w	r0,r8[0x0]
80005bfe:	60 0d       	ld.w	sp,r0[0x0]
80005c00:	1b 00       	ld.w	r0,sp++
80005c02:	e0 68 05 28 	mov	r8,1320
80005c06:	ea 18 00 00 	orh	r8,0x0
80005c0a:	91 00       	st.w	r8[0x0],r0
80005c0c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c10:	2f ed       	sub	sp,-8
80005c12:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005c16:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005c1a:	e3 b0 00 00 	mtsr	0x0,r0
80005c1e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005c22:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005c26:	d8 0a       	popm	pc,r12=0
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	5c f4       	rol	r4
80005c2c:	80 00       	ld.sh	r0,r0[0x0]
80005c2e:	53 98       	stdsp	sp[0xe4],r8

80005c30 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005c30:	20 6d       	sub	sp,24
80005c32:	eb cd 00 ff 	pushm	r0-r7
80005c36:	fa c7 ff c0 	sub	r7,sp,-64
80005c3a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005c3e:	ef 40 ff e0 	st.w	r7[-32],r0
80005c42:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005c46:	ef 40 ff e4 	st.w	r7[-28],r0
80005c4a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005c4e:	e0 68 05 28 	mov	r8,1320
80005c52:	ea 18 00 00 	orh	r8,0x0
80005c56:	70 00       	ld.w	r0,r8[0x0]
80005c58:	1a d0       	st.w	--sp,r0
80005c5a:	f0 1f 00 1a 	mcall	80005cc0 <LABEL_RET_SCALL_263+0x14>
80005c5e:	e0 68 0c d4 	mov	r8,3284
80005c62:	ea 18 00 00 	orh	r8,0x0
80005c66:	70 00       	ld.w	r0,r8[0x0]
80005c68:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005c6a:	f0 1f 00 17 	mcall	80005cc4 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005c6e:	e0 68 0c d4 	mov	r8,3284
80005c72:	ea 18 00 00 	orh	r8,0x0
80005c76:	70 00       	ld.w	r0,r8[0x0]
80005c78:	60 0d       	ld.w	sp,r0[0x0]
80005c7a:	1b 00       	ld.w	r0,sp++
80005c7c:	e0 68 05 28 	mov	r8,1320
80005c80:	ea 18 00 00 	orh	r8,0x0
80005c84:	91 00       	st.w	r8[0x0],r0
80005c86:	fa c7 ff d8 	sub	r7,sp,-40
80005c8a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005c8e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005c92:	e0 61 05 28 	mov	r1,1320
80005c96:	ea 11 00 00 	orh	r1,0x0
80005c9a:	62 02       	ld.w	r2,r1[0x0]
80005c9c:	58 02       	cp.w	r2,0
80005c9e:	c0 70       	breq	80005cac <LABEL_RET_SCALL_263>
80005ca0:	e4 c2 00 01 	sub	r2,r2,1
80005ca4:	83 02       	st.w	r1[0x0],r2
80005ca6:	58 02       	cp.w	r2,0
80005ca8:	c0 21       	brne	80005cac <LABEL_RET_SCALL_263>
80005caa:	b1 c0       	cbr	r0,0x10

80005cac <LABEL_RET_SCALL_263>:
80005cac:	ef 40 ff f8 	st.w	r7[-8],r0
80005cb0:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005cb4:	ef 40 ff fc 	st.w	r7[-4],r0
80005cb8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005cbc:	2f ad       	sub	sp,-24
80005cbe:	d6 13       	rets
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	5b c8       	cp.w	r8,-4
80005cc4:	80 00       	ld.sh	r0,r0[0x0]
80005cc6:	63 64       	ld.w	r4,r1[0x58]

80005cc8 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005cc8:	e1 b8 00 43 	mfsr	r8,0x10c
80005ccc:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005cd0:	5e fc       	retal	r12
80005cd2:	d7 03       	nop

80005cd4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005cd4:	48 78       	lddpc	r8,80005cf0 <vPortExitCritical+0x1c>
80005cd6:	70 08       	ld.w	r8,r8[0x0]
80005cd8:	58 08       	cp.w	r8,0
80005cda:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005cdc:	48 58       	lddpc	r8,80005cf0 <vPortExitCritical+0x1c>
80005cde:	70 09       	ld.w	r9,r8[0x0]
80005ce0:	20 19       	sub	r9,1
80005ce2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005ce4:	70 08       	ld.w	r8,r8[0x0]
80005ce6:	58 08       	cp.w	r8,0
80005ce8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005cea:	d5 03       	csrf	0x10
80005cec:	5e fc       	retal	r12
80005cee:	00 00       	add	r0,r0
80005cf0:	00 00       	add	r0,r0
80005cf2:	05 28       	ld.uh	r8,r2++

80005cf4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005cf4:	eb cd 00 ff 	pushm	r0-r7
80005cf8:	e0 68 05 28 	mov	r8,1320
80005cfc:	ea 18 00 00 	orh	r8,0x0
80005d00:	70 00       	ld.w	r0,r8[0x0]
80005d02:	1a d0       	st.w	--sp,r0
80005d04:	7a 90       	ld.w	r0,sp[0x24]
80005d06:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d0a:	58 10       	cp.w	r0,1
80005d0c:	e0 8b 00 08 	brhi	80005d1c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005d10:	e0 68 0c d4 	mov	r8,3284
80005d14:	ea 18 00 00 	orh	r8,0x0
80005d18:	70 00       	ld.w	r0,r8[0x0]
80005d1a:	81 0d       	st.w	r0[0x0],sp

80005d1c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005d1c:	f0 1f 00 12 	mcall	80005d64 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005d20:	f0 1f 00 12 	mcall	80005d68 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005d24:	f0 1f 00 12 	mcall	80005d6c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005d28:	f0 1f 00 12 	mcall	80005d70 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005d2c:	7a 90       	ld.w	r0,sp[0x24]
80005d2e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d32:	58 10       	cp.w	r0,1
80005d34:	e0 8b 00 0e 	brhi	80005d50 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005d38:	f0 1f 00 0c 	mcall	80005d68 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005d3c:	f0 1f 00 0e 	mcall	80005d74 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005d40:	f0 1f 00 0c 	mcall	80005d70 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005d44:	e0 68 0c d4 	mov	r8,3284
80005d48:	ea 18 00 00 	orh	r8,0x0
80005d4c:	70 00       	ld.w	r0,r8[0x0]
80005d4e:	60 0d       	ld.w	sp,r0[0x0]

80005d50 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005d50:	1b 00       	ld.w	r0,sp++
80005d52:	e0 68 05 28 	mov	r8,1320
80005d56:	ea 18 00 00 	orh	r8,0x0
80005d5a:	91 00       	st.w	r8[0x0],r0
80005d5c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d60:	d6 03       	rete
80005d62:	00 00       	add	r0,r0
80005d64:	80 00       	ld.sh	r0,r0[0x0]
80005d66:	5c c8       	swap.bh	r8
80005d68:	80 00       	ld.sh	r0,r0[0x0]
80005d6a:	5b c8       	cp.w	r8,-4
80005d6c:	80 00       	ld.sh	r0,r0[0x0]
80005d6e:	65 68       	ld.w	r8,r2[0x58]
80005d70:	80 00       	ld.sh	r0,r0[0x0]
80005d72:	5c d4       	com	r4
80005d74:	80 00       	ld.sh	r0,r0[0x0]
80005d76:	63 64       	ld.w	r4,r1[0x58]

80005d78 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005d78:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005d7a:	f0 1f 00 02 	mcall	80005d80 <__malloc_lock+0x8>
}
80005d7e:	d8 02       	popm	pc
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	63 54       	ld.w	r4,r1[0x54]

80005d84 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005d84:	d4 01       	pushm	lr
	xTaskResumeAll();
80005d86:	f0 1f 00 02 	mcall	80005d8c <__malloc_unlock+0x8>
}
80005d8a:	d8 02       	popm	pc
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	67 10       	ld.w	r0,r3[0x44]

80005d90 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005d90:	d4 21       	pushm	r4-r7,lr
80005d92:	16 95       	mov	r5,r11
80005d94:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005d96:	58 0c       	cp.w	r12,0
80005d98:	c0 30       	breq	80005d9e <_read+0xe>
80005d9a:	3f f7       	mov	r7,-1
80005d9c:	c1 48       	rjmp	80005dc4 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005d9e:	58 0a       	cp.w	r10,0
80005da0:	e0 89 00 04 	brgt	80005da8 <_read+0x18>
80005da4:	30 07       	mov	r7,0
80005da6:	c0 f8       	rjmp	80005dc4 <_read+0x34>
80005da8:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005daa:	48 84       	lddpc	r4,80005dc8 <_read+0x38>
80005dac:	68 0c       	ld.w	r12,r4[0x0]
80005dae:	f0 1f 00 08 	mcall	80005dcc <_read+0x3c>
    if (c < 0)
80005db2:	c0 95       	brlt	80005dc4 <_read+0x34>
      break;

    *ptr++ = c;
80005db4:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005db8:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005dba:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005dbe:	58 08       	cp.w	r8,0
80005dc0:	fe 99 ff f6 	brgt	80005dac <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005dc4:	0e 9c       	mov	r12,r7
80005dc6:	d8 22       	popm	r4-r7,pc
80005dc8:	00 00       	add	r0,r0
80005dca:	b6 70       	st.h	r11[0xe],r0
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	59 1c       	cp.w	r12,17

80005dd0 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005dd0:	d4 21       	pushm	r4-r7,lr
80005dd2:	16 95       	mov	r5,r11
80005dd4:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005dd6:	20 1c       	sub	r12,1
80005dd8:	58 2c       	cp.w	r12,2
80005dda:	e0 8b 00 12 	brhi	80005dfe <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005dde:	58 0a       	cp.w	r10,0
80005de0:	c0 31       	brne	80005de6 <_write+0x16>
80005de2:	30 07       	mov	r7,0
80005de4:	c0 e8       	rjmp	80005e00 <_write+0x30>
80005de6:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005de8:	48 74       	lddpc	r4,80005e04 <_write+0x34>
80005dea:	68 0c       	ld.w	r12,r4[0x0]
80005dec:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005df0:	f0 1f 00 06 	mcall	80005e08 <_write+0x38>
80005df4:	c0 55       	brlt	80005dfe <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005df6:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005df8:	0e 36       	cp.w	r6,r7
80005dfa:	cf 81       	brne	80005dea <_write+0x1a>
80005dfc:	c0 28       	rjmp	80005e00 <_write+0x30>
80005dfe:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005e00:	0e 9c       	mov	r12,r7
80005e02:	d8 22       	popm	r4-r7,pc
80005e04:	00 00       	add	r0,r0
80005e06:	b6 70       	st.h	r11[0xe],r0
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	58 cc       	cp.w	r12,12

80005e0c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005e0c:	eb cd 40 80 	pushm	r7,lr
80005e10:	18 97       	mov	r7,r12
	if( pv )
80005e12:	58 0c       	cp.w	r12,0
80005e14:	c0 80       	breq	80005e24 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005e16:	f0 1f 00 05 	mcall	80005e28 <vPortFree+0x1c>
		{
			free( pv );
80005e1a:	0e 9c       	mov	r12,r7
80005e1c:	f0 1f 00 04 	mcall	80005e2c <vPortFree+0x20>
		}
		xTaskResumeAll();
80005e20:	f0 1f 00 04 	mcall	80005e30 <vPortFree+0x24>
80005e24:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e28:	80 00       	ld.sh	r0,r0[0x0]
80005e2a:	63 54       	ld.w	r4,r1[0x54]
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	71 e4       	ld.w	r4,r8[0x78]
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	67 10       	ld.w	r0,r3[0x44]

80005e34 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005e34:	eb cd 40 80 	pushm	r7,lr
80005e38:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005e3a:	f0 1f 00 06 	mcall	80005e50 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005e3e:	0e 9c       	mov	r12,r7
80005e40:	f0 1f 00 05 	mcall	80005e54 <pvPortMalloc+0x20>
80005e44:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005e46:	f0 1f 00 05 	mcall	80005e58 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005e4a:	0e 9c       	mov	r12,r7
80005e4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e50:	80 00       	ld.sh	r0,r0[0x0]
80005e52:	63 54       	ld.w	r4,r1[0x54]
80005e54:	80 00       	ld.sh	r0,r0[0x0]
80005e56:	71 f4       	ld.w	r4,r8[0x7c]
80005e58:	80 00       	ld.sh	r0,r0[0x0]
80005e5a:	67 10       	ld.w	r0,r3[0x44]

80005e5c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005e5c:	d4 01       	pushm	lr
80005e5e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005e60:	78 09       	ld.w	r9,r12[0x0]
80005e62:	58 09       	cp.w	r9,0
80005e64:	c1 10       	breq	80005e86 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005e66:	78 3a       	ld.w	r10,r12[0xc]
80005e68:	79 09       	ld.w	r9,r12[0x40]
80005e6a:	f4 09 00 09 	add	r9,r10,r9
80005e6e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005e70:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005e72:	14 39       	cp.w	r9,r10
80005e74:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005e78:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005e7c:	79 0a       	ld.w	r10,r12[0x40]
80005e7e:	78 3b       	ld.w	r11,r12[0xc]
80005e80:	10 9c       	mov	r12,r8
80005e82:	f0 1f 00 02 	mcall	80005e88 <prvCopyDataFromQueue+0x2c>
80005e86:	d8 02       	popm	pc
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	76 3c       	ld.w	r12,r11[0xc]

80005e8c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005e8c:	eb cd 40 c0 	pushm	r6-r7,lr
80005e90:	18 97       	mov	r7,r12
80005e92:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005e94:	78 e8       	ld.w	r8,r12[0x38]
80005e96:	58 08       	cp.w	r8,0
80005e98:	c0 31       	brne	80005e9e <xQueueReceiveFromISR+0x12>
80005e9a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005e9e:	f0 1f 00 0e 	mcall	80005ed4 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005ea2:	6e e8       	ld.w	r8,r7[0x38]
80005ea4:	20 18       	sub	r8,1
80005ea6:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005ea8:	6f 18       	ld.w	r8,r7[0x44]
80005eaa:	5b f8       	cp.w	r8,-1
80005eac:	c0 d1       	brne	80005ec6 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005eae:	6e 48       	ld.w	r8,r7[0x10]
80005eb0:	58 08       	cp.w	r8,0
80005eb2:	c0 f0       	breq	80005ed0 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005eb4:	ee cc ff f0 	sub	r12,r7,-16
80005eb8:	f0 1f 00 08 	mcall	80005ed8 <xQueueReceiveFromISR+0x4c>
80005ebc:	c0 a0       	breq	80005ed0 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005ebe:	30 1c       	mov	r12,1
80005ec0:	8d 0c       	st.w	r6[0x0],r12
80005ec2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005ec6:	2f f8       	sub	r8,-1
80005ec8:	ef 48 00 44 	st.w	r7[68],r8
80005ecc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005ed0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	5e 5c       	retlt	r12
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	64 ec       	ld.w	r12,r2[0x38]

80005edc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005edc:	eb cd 40 c0 	pushm	r6-r7,lr
80005ee0:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005ee2:	f0 1f 00 23 	mcall	80005f6c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005ee6:	6f 28       	ld.w	r8,r7[0x48]
80005ee8:	58 08       	cp.w	r8,0
80005eea:	e0 8a 00 18 	brle	80005f1a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005eee:	6e 98       	ld.w	r8,r7[0x24]
80005ef0:	58 08       	cp.w	r8,0
80005ef2:	c1 40       	breq	80005f1a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005ef4:	ee c6 ff dc 	sub	r6,r7,-36
80005ef8:	c0 48       	rjmp	80005f00 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005efa:	6e 98       	ld.w	r8,r7[0x24]
80005efc:	58 08       	cp.w	r8,0
80005efe:	c0 e0       	breq	80005f1a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f00:	0c 9c       	mov	r12,r6
80005f02:	f0 1f 00 1c 	mcall	80005f70 <prvUnlockQueue+0x94>
80005f06:	c0 30       	breq	80005f0c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005f08:	f0 1f 00 1b 	mcall	80005f74 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005f0c:	6f 28       	ld.w	r8,r7[0x48]
80005f0e:	20 18       	sub	r8,1
80005f10:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f14:	58 08       	cp.w	r8,0
80005f16:	fe 99 ff f2 	brgt	80005efa <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005f1a:	3f f8       	mov	r8,-1
80005f1c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005f20:	f0 1f 00 16 	mcall	80005f78 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005f24:	f0 1f 00 12 	mcall	80005f6c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f28:	6f 18       	ld.w	r8,r7[0x44]
80005f2a:	58 08       	cp.w	r8,0
80005f2c:	e0 8a 00 18 	brle	80005f5c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f30:	6e 48       	ld.w	r8,r7[0x10]
80005f32:	58 08       	cp.w	r8,0
80005f34:	c1 40       	breq	80005f5c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f36:	ee c6 ff f0 	sub	r6,r7,-16
80005f3a:	c0 48       	rjmp	80005f42 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f3c:	6e 48       	ld.w	r8,r7[0x10]
80005f3e:	58 08       	cp.w	r8,0
80005f40:	c0 e0       	breq	80005f5c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f42:	0c 9c       	mov	r12,r6
80005f44:	f0 1f 00 0b 	mcall	80005f70 <prvUnlockQueue+0x94>
80005f48:	c0 30       	breq	80005f4e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005f4a:	f0 1f 00 0b 	mcall	80005f74 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005f4e:	6f 18       	ld.w	r8,r7[0x44]
80005f50:	20 18       	sub	r8,1
80005f52:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f56:	58 08       	cp.w	r8,0
80005f58:	fe 99 ff f2 	brgt	80005f3c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005f5c:	3f f8       	mov	r8,-1
80005f5e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005f62:	f0 1f 00 06 	mcall	80005f78 <prvUnlockQueue+0x9c>
}
80005f66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f6a:	00 00       	add	r0,r0
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	5b c8       	cp.w	r8,-4
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	64 ec       	ld.w	r12,r2[0x38]
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	63 f8       	ld.w	r8,r1[0x7c]
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	5c d4       	com	r4

80005f7c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005f7c:	d4 31       	pushm	r0-r7,lr
80005f7e:	20 5d       	sub	sp,20
80005f80:	18 97       	mov	r7,r12
80005f82:	50 0b       	stdsp	sp[0x0],r11
80005f84:	50 2a       	stdsp	sp[0x8],r10
80005f86:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005f88:	f8 c2 ff dc 	sub	r2,r12,-36
80005f8c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005f8e:	fa c4 ff f4 	sub	r4,sp,-12
80005f92:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005f94:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005f96:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005f9a:	f0 1f 00 3e 	mcall	80006090 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005f9e:	6e e8       	ld.w	r8,r7[0x38]
80005fa0:	58 08       	cp.w	r8,0
80005fa2:	c2 a0       	breq	80005ff6 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005fa4:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005fa6:	40 0b       	lddsp	r11,sp[0x0]
80005fa8:	0e 9c       	mov	r12,r7
80005faa:	f0 1f 00 3b 	mcall	80006094 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005fae:	40 18       	lddsp	r8,sp[0x4]
80005fb0:	58 08       	cp.w	r8,0
80005fb2:	c1 51       	brne	80005fdc <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005fb4:	6e e8       	ld.w	r8,r7[0x38]
80005fb6:	20 18       	sub	r8,1
80005fb8:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005fba:	6e 08       	ld.w	r8,r7[0x0]
80005fbc:	58 08       	cp.w	r8,0
80005fbe:	c0 41       	brne	80005fc6 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005fc0:	f0 1f 00 36 	mcall	80006098 <xQueueGenericReceive+0x11c>
80005fc4:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005fc6:	6e 48       	ld.w	r8,r7[0x10]
80005fc8:	58 08       	cp.w	r8,0
80005fca:	c1 20       	breq	80005fee <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005fcc:	ee cc ff f0 	sub	r12,r7,-16
80005fd0:	f0 1f 00 33 	mcall	8000609c <xQueueGenericReceive+0x120>
80005fd4:	58 1c       	cp.w	r12,1
80005fd6:	c0 c1       	brne	80005fee <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005fd8:	d7 33       	scall
80005fda:	c0 a8       	rjmp	80005fee <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005fdc:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005fde:	6e 98       	ld.w	r8,r7[0x24]
80005fe0:	58 08       	cp.w	r8,0
80005fe2:	c0 60       	breq	80005fee <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005fe4:	04 9c       	mov	r12,r2
80005fe6:	f0 1f 00 2e 	mcall	8000609c <xQueueGenericReceive+0x120>
80005fea:	c0 20       	breq	80005fee <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005fec:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005fee:	f0 1f 00 2d 	mcall	800060a0 <xQueueGenericReceive+0x124>
80005ff2:	30 1c       	mov	r12,1
				return pdPASS;
80005ff4:	c4 c8       	rjmp	8000608c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005ff6:	40 28       	lddsp	r8,sp[0x8]
80005ff8:	58 08       	cp.w	r8,0
80005ffa:	c0 51       	brne	80006004 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005ffc:	f0 1f 00 29 	mcall	800060a0 <xQueueGenericReceive+0x124>
80006000:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006002:	c4 58       	rjmp	8000608c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006004:	58 05       	cp.w	r5,0
80006006:	c0 51       	brne	80006010 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006008:	08 9c       	mov	r12,r4
8000600a:	f0 1f 00 27 	mcall	800060a4 <xQueueGenericReceive+0x128>
8000600e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006010:	f0 1f 00 24 	mcall	800060a0 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006014:	f0 1f 00 25 	mcall	800060a8 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006018:	f0 1f 00 1e 	mcall	80006090 <xQueueGenericReceive+0x114>
8000601c:	6f 18       	ld.w	r8,r7[0x44]
8000601e:	5b f8       	cp.w	r8,-1
80006020:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006024:	6f 28       	ld.w	r8,r7[0x48]
80006026:	5b f8       	cp.w	r8,-1
80006028:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000602c:	f0 1f 00 1d 	mcall	800060a0 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006030:	06 9b       	mov	r11,r3
80006032:	08 9c       	mov	r12,r4
80006034:	f0 1f 00 1e 	mcall	800060ac <xQueueGenericReceive+0x130>
80006038:	c2 41       	brne	80006080 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000603a:	f0 1f 00 16 	mcall	80006090 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000603e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006040:	f0 1f 00 18 	mcall	800060a0 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006044:	58 06       	cp.w	r6,0
80006046:	c1 71       	brne	80006074 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006048:	6e 08       	ld.w	r8,r7[0x0]
8000604a:	58 08       	cp.w	r8,0
8000604c:	c0 81       	brne	8000605c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000604e:	f0 1f 00 11 	mcall	80006090 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006052:	6e 1c       	ld.w	r12,r7[0x4]
80006054:	f0 1f 00 17 	mcall	800060b0 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006058:	f0 1f 00 12 	mcall	800060a0 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000605c:	40 2b       	lddsp	r11,sp[0x8]
8000605e:	04 9c       	mov	r12,r2
80006060:	f0 1f 00 15 	mcall	800060b4 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006064:	0e 9c       	mov	r12,r7
80006066:	f0 1f 00 15 	mcall	800060b8 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000606a:	f0 1f 00 15 	mcall	800060bc <xQueueGenericReceive+0x140>
8000606e:	c9 61       	brne	80005f9a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006070:	d7 33       	scall
80006072:	c9 4b       	rjmp	80005f9a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006074:	0e 9c       	mov	r12,r7
80006076:	f0 1f 00 11 	mcall	800060b8 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000607a:	f0 1f 00 11 	mcall	800060bc <xQueueGenericReceive+0x140>
8000607e:	c8 eb       	rjmp	80005f9a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006080:	0e 9c       	mov	r12,r7
80006082:	f0 1f 00 0e 	mcall	800060b8 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006086:	f0 1f 00 0e 	mcall	800060bc <xQueueGenericReceive+0x140>
8000608a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
8000608c:	2f bd       	sub	sp,-20
8000608e:	d8 32       	popm	r0-r7,pc
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	5b c8       	cp.w	r8,-4
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	5e 5c       	retlt	r12
80006098:	80 00       	ld.sh	r0,r0[0x0]
8000609a:	64 04       	ld.w	r4,r2[0x0]
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	64 ec       	ld.w	r12,r2[0x38]
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	5c d4       	com	r4
800060a4:	80 00       	ld.sh	r0,r0[0x0]
800060a6:	63 e0       	ld.w	r0,r1[0x78]
800060a8:	80 00       	ld.sh	r0,r0[0x0]
800060aa:	63 54       	ld.w	r4,r1[0x54]
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	66 7c       	ld.w	r12,r3[0x1c]
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	64 68       	ld.w	r8,r2[0x18]
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	69 1c       	ld.w	r12,r4[0x44]
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	5e dc       	retvc	r12
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	67 10       	ld.w	r0,r3[0x44]

800060c0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800060c0:	eb cd 40 80 	pushm	r7,lr
800060c4:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800060c6:	79 08       	ld.w	r8,r12[0x40]
800060c8:	58 08       	cp.w	r8,0
800060ca:	c0 a1       	brne	800060de <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800060cc:	78 08       	ld.w	r8,r12[0x0]
800060ce:	58 08       	cp.w	r8,0
800060d0:	c2 b1       	brne	80006126 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800060d2:	78 1c       	ld.w	r12,r12[0x4]
800060d4:	f0 1f 00 17 	mcall	80006130 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800060d8:	30 08       	mov	r8,0
800060da:	8f 18       	st.w	r7[0x4],r8
800060dc:	c2 58       	rjmp	80006126 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800060de:	58 0a       	cp.w	r10,0
800060e0:	c1 01       	brne	80006100 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800060e2:	10 9a       	mov	r10,r8
800060e4:	78 2c       	ld.w	r12,r12[0x8]
800060e6:	f0 1f 00 14 	mcall	80006134 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800060ea:	6e 29       	ld.w	r9,r7[0x8]
800060ec:	6f 08       	ld.w	r8,r7[0x40]
800060ee:	f2 08 00 08 	add	r8,r9,r8
800060f2:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800060f4:	6e 19       	ld.w	r9,r7[0x4]
800060f6:	12 38       	cp.w	r8,r9
800060f8:	c1 73       	brcs	80006126 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800060fa:	6e 08       	ld.w	r8,r7[0x0]
800060fc:	8f 28       	st.w	r7[0x8],r8
800060fe:	c1 48       	rjmp	80006126 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006100:	10 9a       	mov	r10,r8
80006102:	78 3c       	ld.w	r12,r12[0xc]
80006104:	f0 1f 00 0c 	mcall	80006134 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006108:	6f 08       	ld.w	r8,r7[0x40]
8000610a:	6e 39       	ld.w	r9,r7[0xc]
8000610c:	f2 08 01 08 	sub	r8,r9,r8
80006110:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006112:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006114:	12 38       	cp.w	r8,r9
80006116:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000611a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000611e:	f3 d8 e3 19 	subcs	r9,r9,r8
80006122:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006126:	6e e8       	ld.w	r8,r7[0x38]
80006128:	2f f8       	sub	r8,-1
8000612a:	8f e8       	st.w	r7[0x38],r8
}
8000612c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	64 10       	ld.w	r0,r2[0x4]
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	76 3c       	ld.w	r12,r11[0xc]

80006138 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006138:	eb cd 40 c0 	pushm	r6-r7,lr
8000613c:	18 97       	mov	r7,r12
8000613e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006140:	78 ec       	ld.w	r12,r12[0x38]
80006142:	6e f8       	ld.w	r8,r7[0x3c]
80006144:	10 3c       	cp.w	r12,r8
80006146:	c0 33       	brcs	8000614c <xQueueGenericSendFromISR+0x14>
80006148:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000614c:	12 9a       	mov	r10,r9
8000614e:	0e 9c       	mov	r12,r7
80006150:	f0 1f 00 0c 	mcall	80006180 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006154:	6f 28       	ld.w	r8,r7[0x48]
80006156:	5b f8       	cp.w	r8,-1
80006158:	c0 d1       	brne	80006172 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000615a:	6e 98       	ld.w	r8,r7[0x24]
8000615c:	58 08       	cp.w	r8,0
8000615e:	c0 f0       	breq	8000617c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006160:	ee cc ff dc 	sub	r12,r7,-36
80006164:	f0 1f 00 08 	mcall	80006184 <xQueueGenericSendFromISR+0x4c>
80006168:	c0 a0       	breq	8000617c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000616a:	30 1c       	mov	r12,1
8000616c:	8d 0c       	st.w	r6[0x0],r12
8000616e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006172:	2f f8       	sub	r8,-1
80006174:	ef 48 00 48 	st.w	r7[72],r8
80006178:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000617c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	60 c0       	ld.w	r0,r0[0x30]
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	64 ec       	ld.w	r12,r2[0x38]

80006188 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006188:	d4 31       	pushm	r0-r7,lr
8000618a:	20 5d       	sub	sp,20
8000618c:	18 97       	mov	r7,r12
8000618e:	50 0b       	stdsp	sp[0x0],r11
80006190:	50 2a       	stdsp	sp[0x8],r10
80006192:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006194:	f8 c0 ff f0 	sub	r0,r12,-16
80006198:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000619a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000619e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061a0:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800061a4:	f0 1f 00 2f 	mcall	80006260 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800061a8:	6e e9       	ld.w	r9,r7[0x38]
800061aa:	6e f8       	ld.w	r8,r7[0x3c]
800061ac:	10 39       	cp.w	r9,r8
800061ae:	c1 42       	brcc	800061d6 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800061b0:	40 1a       	lddsp	r10,sp[0x4]
800061b2:	40 0b       	lddsp	r11,sp[0x0]
800061b4:	0e 9c       	mov	r12,r7
800061b6:	f0 1f 00 2c 	mcall	80006264 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061ba:	6e 98       	ld.w	r8,r7[0x24]
800061bc:	58 08       	cp.w	r8,0
800061be:	c0 80       	breq	800061ce <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800061c0:	ee cc ff dc 	sub	r12,r7,-36
800061c4:	f0 1f 00 29 	mcall	80006268 <xQueueGenericSend+0xe0>
800061c8:	58 1c       	cp.w	r12,1
800061ca:	c0 21       	brne	800061ce <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800061cc:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800061ce:	f0 1f 00 28 	mcall	8000626c <xQueueGenericSend+0xe4>
800061d2:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800061d4:	c4 38       	rjmp	8000625a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800061d6:	40 28       	lddsp	r8,sp[0x8]
800061d8:	58 08       	cp.w	r8,0
800061da:	c0 51       	brne	800061e4 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800061dc:	f0 1f 00 24 	mcall	8000626c <xQueueGenericSend+0xe4>
800061e0:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800061e2:	c3 c8       	rjmp	8000625a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800061e4:	58 04       	cp.w	r4,0
800061e6:	c0 51       	brne	800061f0 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061e8:	06 9c       	mov	r12,r3
800061ea:	f0 1f 00 22 	mcall	80006270 <xQueueGenericSend+0xe8>
800061ee:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800061f0:	f0 1f 00 1f 	mcall	8000626c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800061f4:	f0 1f 00 20 	mcall	80006274 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800061f8:	f0 1f 00 1a 	mcall	80006260 <xQueueGenericSend+0xd8>
800061fc:	6f 18       	ld.w	r8,r7[0x44]
800061fe:	5b f8       	cp.w	r8,-1
80006200:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006204:	6f 28       	ld.w	r8,r7[0x48]
80006206:	5b f8       	cp.w	r8,-1
80006208:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000620c:	f0 1f 00 18 	mcall	8000626c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006210:	04 9b       	mov	r11,r2
80006212:	06 9c       	mov	r12,r3
80006214:	f0 1f 00 19 	mcall	80006278 <xQueueGenericSend+0xf0>
80006218:	c1 b1       	brne	8000624e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000621a:	f0 1f 00 12 	mcall	80006260 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000621e:	6e e5       	ld.w	r5,r7[0x38]
80006220:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006222:	f0 1f 00 13 	mcall	8000626c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006226:	0c 35       	cp.w	r5,r6
80006228:	c0 d1       	brne	80006242 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000622a:	40 2b       	lddsp	r11,sp[0x8]
8000622c:	00 9c       	mov	r12,r0
8000622e:	f0 1f 00 14 	mcall	8000627c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006232:	0e 9c       	mov	r12,r7
80006234:	f0 1f 00 13 	mcall	80006280 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006238:	f0 1f 00 13 	mcall	80006284 <xQueueGenericSend+0xfc>
8000623c:	cb 41       	brne	800061a4 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000623e:	d7 33       	scall
80006240:	cb 2b       	rjmp	800061a4 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006242:	0e 9c       	mov	r12,r7
80006244:	f0 1f 00 0f 	mcall	80006280 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006248:	f0 1f 00 0f 	mcall	80006284 <xQueueGenericSend+0xfc>
8000624c:	ca cb       	rjmp	800061a4 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000624e:	0e 9c       	mov	r12,r7
80006250:	f0 1f 00 0c 	mcall	80006280 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006254:	f0 1f 00 0c 	mcall	80006284 <xQueueGenericSend+0xfc>
80006258:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000625a:	2f bd       	sub	sp,-20
8000625c:	d8 32       	popm	r0-r7,pc
8000625e:	00 00       	add	r0,r0
80006260:	80 00       	ld.sh	r0,r0[0x0]
80006262:	5b c8       	cp.w	r8,-4
80006264:	80 00       	ld.sh	r0,r0[0x0]
80006266:	60 c0       	ld.w	r0,r0[0x30]
80006268:	80 00       	ld.sh	r0,r0[0x0]
8000626a:	64 ec       	ld.w	r12,r2[0x38]
8000626c:	80 00       	ld.sh	r0,r0[0x0]
8000626e:	5c d4       	com	r4
80006270:	80 00       	ld.sh	r0,r0[0x0]
80006272:	63 e0       	ld.w	r0,r1[0x78]
80006274:	80 00       	ld.sh	r0,r0[0x0]
80006276:	63 54       	ld.w	r4,r1[0x54]
80006278:	80 00       	ld.sh	r0,r0[0x0]
8000627a:	66 7c       	ld.w	r12,r3[0x1c]
8000627c:	80 00       	ld.sh	r0,r0[0x0]
8000627e:	69 1c       	ld.w	r12,r4[0x44]
80006280:	80 00       	ld.sh	r0,r0[0x0]
80006282:	5e dc       	retvc	r12
80006284:	80 00       	ld.sh	r0,r0[0x0]
80006286:	67 10       	ld.w	r0,r3[0x44]

80006288 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006288:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000628c:	34 cc       	mov	r12,76
8000628e:	f0 1f 00 12 	mcall	800062d4 <xQueueCreateMutex+0x4c>
80006292:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006294:	c1 d0       	breq	800062ce <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80006296:	30 06       	mov	r6,0
80006298:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000629a:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
8000629c:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
8000629e:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800062a0:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800062a2:	30 18       	mov	r8,1
800062a4:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800062a6:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800062aa:	3f f8       	mov	r8,-1
800062ac:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800062b0:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800062b4:	2f 0c       	sub	r12,-16
800062b6:	f0 1f 00 09 	mcall	800062d8 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800062ba:	ee cc ff dc 	sub	r12,r7,-36
800062be:	f0 1f 00 07 	mcall	800062d8 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800062c2:	0c 99       	mov	r9,r6
800062c4:	0c 9a       	mov	r10,r6
800062c6:	0c 9b       	mov	r11,r6
800062c8:	0e 9c       	mov	r12,r7
800062ca:	f0 1f 00 05 	mcall	800062dc <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800062ce:	0e 9c       	mov	r12,r7
800062d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	5e 34       	retlo	r4
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	5a a4       	cp.w	r4,-22
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	61 88       	ld.w	r8,r0[0x60]

800062e0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800062e0:	d4 21       	pushm	r4-r7,lr
800062e2:	18 97       	mov	r7,r12
800062e4:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800062e6:	58 0c       	cp.w	r12,0
800062e8:	c2 f0       	breq	80006346 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800062ea:	34 cc       	mov	r12,76
800062ec:	f0 1f 00 17 	mcall	80006348 <xQueueCreate+0x68>
800062f0:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800062f2:	c2 a0       	breq	80006346 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800062f4:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800062f8:	e8 cc ff ff 	sub	r12,r4,-1
800062fc:	f0 1f 00 13 	mcall	80006348 <xQueueCreate+0x68>
80006300:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006302:	c1 e0       	breq	8000633e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006304:	f8 04 00 04 	add	r4,r12,r4
80006308:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000630a:	30 08       	mov	r8,0
8000630c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000630e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006310:	ee c8 00 01 	sub	r8,r7,1
80006314:	ad 38       	mul	r8,r6
80006316:	10 0c       	add	r12,r8
80006318:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000631a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000631c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006320:	3f f8       	mov	r8,-1
80006322:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006326:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000632a:	ea cc ff f0 	sub	r12,r5,-16
8000632e:	f0 1f 00 08 	mcall	8000634c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006332:	ea cc ff dc 	sub	r12,r5,-36
80006336:	f0 1f 00 06 	mcall	8000634c <xQueueCreate+0x6c>
8000633a:	0a 9c       	mov	r12,r5
8000633c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000633e:	0a 9c       	mov	r12,r5
80006340:	f0 1f 00 04 	mcall	80006350 <xQueueCreate+0x70>
80006344:	d8 2a       	popm	r4-r7,pc,r12=0
80006346:	d8 2a       	popm	r4-r7,pc,r12=0
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	5e 34       	retlo	r4
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	5a a4       	cp.w	r4,-22
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	5e 0c       	reteq	r12

80006354 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006354:	48 38       	lddpc	r8,80006360 <vTaskSuspendAll+0xc>
80006356:	70 09       	ld.w	r9,r8[0x0]
80006358:	2f f9       	sub	r9,-1
8000635a:	91 09       	st.w	r8[0x0],r9
}
8000635c:	5e fc       	retal	r12
8000635e:	00 00       	add	r0,r0
80006360:	00 00       	add	r0,r0
80006362:	0d 04       	ld.w	r4,r6++

80006364 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006364:	49 a8       	lddpc	r8,800063cc <vTaskSwitchContext+0x68>
80006366:	70 08       	ld.w	r8,r8[0x0]
80006368:	58 08       	cp.w	r8,0
8000636a:	c0 b1       	brne	80006380 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000636c:	49 98       	lddpc	r8,800063d0 <vTaskSwitchContext+0x6c>
8000636e:	70 08       	ld.w	r8,r8[0x0]
80006370:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006374:	49 89       	lddpc	r9,800063d4 <vTaskSwitchContext+0x70>
80006376:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000637a:	58 08       	cp.w	r8,0
8000637c:	c0 60       	breq	80006388 <vTaskSwitchContext+0x24>
8000637e:	c1 18       	rjmp	800063a0 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006380:	30 19       	mov	r9,1
80006382:	49 68       	lddpc	r8,800063d8 <vTaskSwitchContext+0x74>
80006384:	91 09       	st.w	r8[0x0],r9
80006386:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006388:	49 28       	lddpc	r8,800063d0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000638a:	49 3a       	lddpc	r10,800063d4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000638c:	70 09       	ld.w	r9,r8[0x0]
8000638e:	20 19       	sub	r9,1
80006390:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006392:	70 09       	ld.w	r9,r8[0x0]
80006394:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006398:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000639c:	58 09       	cp.w	r9,0
8000639e:	cf 70       	breq	8000638c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800063a0:	48 c8       	lddpc	r8,800063d0 <vTaskSwitchContext+0x6c>
800063a2:	70 08       	ld.w	r8,r8[0x0]
800063a4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063a8:	48 b9       	lddpc	r9,800063d4 <vTaskSwitchContext+0x70>
800063aa:	f2 08 00 28 	add	r8,r9,r8<<0x2
800063ae:	70 19       	ld.w	r9,r8[0x4]
800063b0:	72 19       	ld.w	r9,r9[0x4]
800063b2:	91 19       	st.w	r8[0x4],r9
800063b4:	f0 ca ff f8 	sub	r10,r8,-8
800063b8:	14 39       	cp.w	r9,r10
800063ba:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800063be:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800063c2:	70 18       	ld.w	r8,r8[0x4]
800063c4:	70 39       	ld.w	r9,r8[0xc]
800063c6:	48 68       	lddpc	r8,800063dc <vTaskSwitchContext+0x78>
800063c8:	91 09       	st.w	r8[0x0],r9
800063ca:	5e fc       	retal	r12
800063cc:	00 00       	add	r0,r0
800063ce:	0d 04       	ld.w	r4,r6++
800063d0:	00 00       	add	r0,r0
800063d2:	0d 3c       	ld.ub	r12,r6++
800063d4:	00 00       	add	r0,r0
800063d6:	0c 20       	rsub	r0,r6
800063d8:	00 00       	add	r0,r0
800063da:	0d 24       	ld.uh	r4,r6++
800063dc:	00 00       	add	r0,r0
800063de:	0c d4       	st.w	--r6,r4

800063e0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800063e0:	48 48       	lddpc	r8,800063f0 <vTaskSetTimeOutState+0x10>
800063e2:	70 08       	ld.w	r8,r8[0x0]
800063e4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800063e6:	48 48       	lddpc	r8,800063f4 <vTaskSetTimeOutState+0x14>
800063e8:	70 08       	ld.w	r8,r8[0x0]
800063ea:	99 18       	st.w	r12[0x4],r8
}
800063ec:	5e fc       	retal	r12
800063ee:	00 00       	add	r0,r0
800063f0:	00 00       	add	r0,r0
800063f2:	0c 18       	sub	r8,r6
800063f4:	00 00       	add	r0,r0
800063f6:	0d 00       	ld.w	r0,r6++

800063f8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800063f8:	30 19       	mov	r9,1
800063fa:	48 28       	lddpc	r8,80006400 <vTaskMissedYield+0x8>
800063fc:	91 09       	st.w	r8[0x0],r9
}
800063fe:	5e fc       	retal	r12
80006400:	00 00       	add	r0,r0
80006402:	0d 24       	ld.uh	r4,r6++

80006404 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006404:	48 28       	lddpc	r8,8000640c <xTaskGetCurrentTaskHandle+0x8>
80006406:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006408:	5e fc       	retal	r12
8000640a:	00 00       	add	r0,r0
8000640c:	00 00       	add	r0,r0
8000640e:	0c d4       	st.w	--r6,r4

80006410 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006410:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006414:	58 0c       	cp.w	r12,0
80006416:	c1 f0       	breq	80006454 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006418:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000641a:	78 b9       	ld.w	r9,r12[0x2c]
8000641c:	79 18       	ld.w	r8,r12[0x44]
8000641e:	10 39       	cp.w	r9,r8
80006420:	c1 a0       	breq	80006454 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006422:	f8 c6 ff fc 	sub	r6,r12,-4
80006426:	0c 9c       	mov	r12,r6
80006428:	f0 1f 00 0c 	mcall	80006458 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000642c:	6f 1c       	ld.w	r12,r7[0x44]
8000642e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006430:	f8 08 11 08 	rsub	r8,r12,8
80006434:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006436:	48 a8       	lddpc	r8,8000645c <vTaskPriorityDisinherit+0x4c>
80006438:	70 08       	ld.w	r8,r8[0x0]
8000643a:	10 3c       	cp.w	r12,r8
8000643c:	e0 88 00 04 	brls	80006444 <vTaskPriorityDisinherit+0x34>
80006440:	48 78       	lddpc	r8,8000645c <vTaskPriorityDisinherit+0x4c>
80006442:	91 0c       	st.w	r8[0x0],r12
80006444:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006448:	0c 9b       	mov	r11,r6
8000644a:	48 68       	lddpc	r8,80006460 <vTaskPriorityDisinherit+0x50>
8000644c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006450:	f0 1f 00 05 	mcall	80006464 <vTaskPriorityDisinherit+0x54>
80006454:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	5b 0e       	cp.w	lr,-16
8000645c:	00 00       	add	r0,r0
8000645e:	0d 3c       	ld.ub	r12,r6++
80006460:	00 00       	add	r0,r0
80006462:	0c 20       	rsub	r0,r6
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	5a be       	cp.w	lr,-21

80006468 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006468:	eb cd 40 c0 	pushm	r6-r7,lr
8000646c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000646e:	49 b8       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x70>
80006470:	70 08       	ld.w	r8,r8[0x0]
80006472:	78 b9       	ld.w	r9,r12[0x2c]
80006474:	70 b8       	ld.w	r8,r8[0x2c]
80006476:	10 39       	cp.w	r9,r8
80006478:	c2 d2       	brcc	800064d2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000647a:	49 88       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x70>
8000647c:	70 08       	ld.w	r8,r8[0x0]
8000647e:	70 b8       	ld.w	r8,r8[0x2c]
80006480:	f0 08 11 08 	rsub	r8,r8,8
80006484:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006486:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000648a:	49 59       	lddpc	r9,800064dc <vTaskPriorityInherit+0x74>
8000648c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006490:	78 59       	ld.w	r9,r12[0x14]
80006492:	10 39       	cp.w	r9,r8
80006494:	c1 b1       	brne	800064ca <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006496:	f8 c6 ff fc 	sub	r6,r12,-4
8000649a:	0c 9c       	mov	r12,r6
8000649c:	f0 1f 00 11 	mcall	800064e0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064a0:	48 e8       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x70>
800064a2:	70 08       	ld.w	r8,r8[0x0]
800064a4:	70 bc       	ld.w	r12,r8[0x2c]
800064a6:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800064a8:	48 f8       	lddpc	r8,800064e4 <vTaskPriorityInherit+0x7c>
800064aa:	70 08       	ld.w	r8,r8[0x0]
800064ac:	10 3c       	cp.w	r12,r8
800064ae:	e0 88 00 04 	brls	800064b6 <vTaskPriorityInherit+0x4e>
800064b2:	48 d8       	lddpc	r8,800064e4 <vTaskPriorityInherit+0x7c>
800064b4:	91 0c       	st.w	r8[0x0],r12
800064b6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064ba:	0c 9b       	mov	r11,r6
800064bc:	48 88       	lddpc	r8,800064dc <vTaskPriorityInherit+0x74>
800064be:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064c2:	f0 1f 00 0a 	mcall	800064e8 <vTaskPriorityInherit+0x80>
800064c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064ca:	48 48       	lddpc	r8,800064d8 <vTaskPriorityInherit+0x70>
800064cc:	70 08       	ld.w	r8,r8[0x0]
800064ce:	70 b8       	ld.w	r8,r8[0x2c]
800064d0:	99 b8       	st.w	r12[0x2c],r8
800064d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064d6:	00 00       	add	r0,r0
800064d8:	00 00       	add	r0,r0
800064da:	0c d4       	st.w	--r6,r4
800064dc:	00 00       	add	r0,r0
800064de:	0c 20       	rsub	r0,r6
800064e0:	80 00       	ld.sh	r0,r0[0x0]
800064e2:	5b 0e       	cp.w	lr,-16
800064e4:	00 00       	add	r0,r0
800064e6:	0d 3c       	ld.ub	r12,r6++
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	5a be       	cp.w	lr,-21

800064ec <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800064ec:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800064f0:	78 38       	ld.w	r8,r12[0xc]
800064f2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800064f4:	ee c6 ff e8 	sub	r6,r7,-24
800064f8:	0c 9c       	mov	r12,r6
800064fa:	f0 1f 00 15 	mcall	8000654c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800064fe:	49 58       	lddpc	r8,80006550 <xTaskRemoveFromEventList+0x64>
80006500:	70 08       	ld.w	r8,r8[0x0]
80006502:	58 08       	cp.w	r8,0
80006504:	c1 71       	brne	80006532 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006506:	ee c6 ff fc 	sub	r6,r7,-4
8000650a:	0c 9c       	mov	r12,r6
8000650c:	f0 1f 00 10 	mcall	8000654c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006510:	6e bc       	ld.w	r12,r7[0x2c]
80006512:	49 18       	lddpc	r8,80006554 <xTaskRemoveFromEventList+0x68>
80006514:	70 08       	ld.w	r8,r8[0x0]
80006516:	10 3c       	cp.w	r12,r8
80006518:	e0 88 00 04 	brls	80006520 <xTaskRemoveFromEventList+0x34>
8000651c:	48 e8       	lddpc	r8,80006554 <xTaskRemoveFromEventList+0x68>
8000651e:	91 0c       	st.w	r8[0x0],r12
80006520:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006524:	0c 9b       	mov	r11,r6
80006526:	48 d8       	lddpc	r8,80006558 <xTaskRemoveFromEventList+0x6c>
80006528:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000652c:	f0 1f 00 0c 	mcall	8000655c <xTaskRemoveFromEventList+0x70>
80006530:	c0 58       	rjmp	8000653a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006532:	0c 9b       	mov	r11,r6
80006534:	48 bc       	lddpc	r12,80006560 <xTaskRemoveFromEventList+0x74>
80006536:	f0 1f 00 0a 	mcall	8000655c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000653a:	48 b8       	lddpc	r8,80006564 <xTaskRemoveFromEventList+0x78>
8000653c:	70 08       	ld.w	r8,r8[0x0]
8000653e:	6e b9       	ld.w	r9,r7[0x2c]
80006540:	70 b8       	ld.w	r8,r8[0x2c]
80006542:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006544:	5f 2c       	srhs	r12
80006546:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000654a:	00 00       	add	r0,r0
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	5b 0e       	cp.w	lr,-16
80006550:	00 00       	add	r0,r0
80006552:	0d 04       	ld.w	r4,r6++
80006554:	00 00       	add	r0,r0
80006556:	0d 3c       	ld.ub	r12,r6++
80006558:	00 00       	add	r0,r0
8000655a:	0c 20       	rsub	r0,r6
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	5a be       	cp.w	lr,-21
80006560:	00 00       	add	r0,r0
80006562:	0c d8       	st.w	--r6,r8
80006564:	00 00       	add	r0,r0
80006566:	0c d4       	st.w	--r6,r4

80006568 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006568:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000656c:	4b 98       	lddpc	r8,80006650 <vTaskIncrementTick+0xe8>
8000656e:	70 08       	ld.w	r8,r8[0x0]
80006570:	58 08       	cp.w	r8,0
80006572:	c6 91       	brne	80006644 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006574:	4b 88       	lddpc	r8,80006654 <vTaskIncrementTick+0xec>
80006576:	70 09       	ld.w	r9,r8[0x0]
80006578:	2f f9       	sub	r9,-1
8000657a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000657c:	70 08       	ld.w	r8,r8[0x0]
8000657e:	58 08       	cp.w	r8,0
80006580:	c1 a1       	brne	800065b4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006582:	4b 68       	lddpc	r8,80006658 <vTaskIncrementTick+0xf0>
80006584:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006586:	4b 69       	lddpc	r9,8000665c <vTaskIncrementTick+0xf4>
80006588:	72 0b       	ld.w	r11,r9[0x0]
8000658a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000658c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000658e:	4b 59       	lddpc	r9,80006660 <vTaskIncrementTick+0xf8>
80006590:	72 0a       	ld.w	r10,r9[0x0]
80006592:	2f fa       	sub	r10,-1
80006594:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006596:	70 08       	ld.w	r8,r8[0x0]
80006598:	70 08       	ld.w	r8,r8[0x0]
8000659a:	58 08       	cp.w	r8,0
8000659c:	c0 51       	brne	800065a6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000659e:	3f f9       	mov	r9,-1
800065a0:	4b 18       	lddpc	r8,80006664 <vTaskIncrementTick+0xfc>
800065a2:	91 09       	st.w	r8[0x0],r9
800065a4:	c0 88       	rjmp	800065b4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800065a6:	4a d8       	lddpc	r8,80006658 <vTaskIncrementTick+0xf0>
800065a8:	70 08       	ld.w	r8,r8[0x0]
800065aa:	70 38       	ld.w	r8,r8[0xc]
800065ac:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800065ae:	70 19       	ld.w	r9,r8[0x4]
800065b0:	4a d8       	lddpc	r8,80006664 <vTaskIncrementTick+0xfc>
800065b2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800065b4:	4a 88       	lddpc	r8,80006654 <vTaskIncrementTick+0xec>
800065b6:	70 09       	ld.w	r9,r8[0x0]
800065b8:	4a b8       	lddpc	r8,80006664 <vTaskIncrementTick+0xfc>
800065ba:	70 08       	ld.w	r8,r8[0x0]
800065bc:	10 39       	cp.w	r9,r8
800065be:	c4 73       	brcs	8000664c <vTaskIncrementTick+0xe4>
800065c0:	4a 68       	lddpc	r8,80006658 <vTaskIncrementTick+0xf0>
800065c2:	70 08       	ld.w	r8,r8[0x0]
800065c4:	70 08       	ld.w	r8,r8[0x0]
800065c6:	58 08       	cp.w	r8,0
800065c8:	c0 c0       	breq	800065e0 <vTaskIncrementTick+0x78>
800065ca:	4a 48       	lddpc	r8,80006658 <vTaskIncrementTick+0xf0>
800065cc:	70 08       	ld.w	r8,r8[0x0]
800065ce:	70 38       	ld.w	r8,r8[0xc]
800065d0:	70 37       	ld.w	r7,r8[0xc]
800065d2:	6e 18       	ld.w	r8,r7[0x4]
800065d4:	4a 09       	lddpc	r9,80006654 <vTaskIncrementTick+0xec>
800065d6:	72 09       	ld.w	r9,r9[0x0]
800065d8:	12 38       	cp.w	r8,r9
800065da:	e0 88 00 14 	brls	80006602 <vTaskIncrementTick+0x9a>
800065de:	c0 e8       	rjmp	800065fa <vTaskIncrementTick+0x92>
800065e0:	3f f9       	mov	r9,-1
800065e2:	4a 18       	lddpc	r8,80006664 <vTaskIncrementTick+0xfc>
800065e4:	91 09       	st.w	r8[0x0],r9
800065e6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800065ea:	6a 08       	ld.w	r8,r5[0x0]
800065ec:	70 38       	ld.w	r8,r8[0xc]
800065ee:	70 37       	ld.w	r7,r8[0xc]
800065f0:	6e 18       	ld.w	r8,r7[0x4]
800065f2:	64 09       	ld.w	r9,r2[0x0]
800065f4:	12 38       	cp.w	r8,r9
800065f6:	e0 88 00 0a 	brls	8000660a <vTaskIncrementTick+0xa2>
800065fa:	49 b9       	lddpc	r9,80006664 <vTaskIncrementTick+0xfc>
800065fc:	93 08       	st.w	r9[0x0],r8
800065fe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006602:	49 a4       	lddpc	r4,80006668 <vTaskIncrementTick+0x100>
80006604:	49 a3       	lddpc	r3,8000666c <vTaskIncrementTick+0x104>
80006606:	49 55       	lddpc	r5,80006658 <vTaskIncrementTick+0xf0>
80006608:	49 32       	lddpc	r2,80006654 <vTaskIncrementTick+0xec>
8000660a:	ee c6 ff fc 	sub	r6,r7,-4
8000660e:	0c 9c       	mov	r12,r6
80006610:	f0 1f 00 18 	mcall	80006670 <vTaskIncrementTick+0x108>
80006614:	6e a8       	ld.w	r8,r7[0x28]
80006616:	58 08       	cp.w	r8,0
80006618:	c0 50       	breq	80006622 <vTaskIncrementTick+0xba>
8000661a:	ee cc ff e8 	sub	r12,r7,-24
8000661e:	f0 1f 00 15 	mcall	80006670 <vTaskIncrementTick+0x108>
80006622:	6e bc       	ld.w	r12,r7[0x2c]
80006624:	68 08       	ld.w	r8,r4[0x0]
80006626:	10 3c       	cp.w	r12,r8
80006628:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000662c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006630:	0c 9b       	mov	r11,r6
80006632:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006636:	f0 1f 00 10 	mcall	80006674 <vTaskIncrementTick+0x10c>
8000663a:	6a 08       	ld.w	r8,r5[0x0]
8000663c:	70 08       	ld.w	r8,r8[0x0]
8000663e:	58 08       	cp.w	r8,0
80006640:	cd 51       	brne	800065ea <vTaskIncrementTick+0x82>
80006642:	cc fb       	rjmp	800065e0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006644:	48 d8       	lddpc	r8,80006678 <vTaskIncrementTick+0x110>
80006646:	70 09       	ld.w	r9,r8[0x0]
80006648:	2f f9       	sub	r9,-1
8000664a:	91 09       	st.w	r8[0x0],r9
8000664c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006650:	00 00       	add	r0,r0
80006652:	0d 04       	ld.w	r4,r6++
80006654:	00 00       	add	r0,r0
80006656:	0d 00       	ld.w	r0,r6++
80006658:	00 00       	add	r0,r0
8000665a:	0c 0c       	add	r12,r6
8000665c:	00 00       	add	r0,r0
8000665e:	0c 1c       	sub	r12,r6
80006660:	00 00       	add	r0,r0
80006662:	0c 18       	sub	r8,r6
80006664:	00 00       	add	r0,r0
80006666:	05 2c       	ld.uh	r12,r2++
80006668:	00 00       	add	r0,r0
8000666a:	0d 3c       	ld.ub	r12,r6++
8000666c:	00 00       	add	r0,r0
8000666e:	0c 20       	rsub	r0,r6
80006670:	80 00       	ld.sh	r0,r0[0x0]
80006672:	5b 0e       	cp.w	lr,-16
80006674:	80 00       	ld.sh	r0,r0[0x0]
80006676:	5a be       	cp.w	lr,-21
80006678:	00 00       	add	r0,r0
8000667a:	0c 04       	add	r4,r6

8000667c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000667c:	eb cd 40 c0 	pushm	r6-r7,lr
80006680:	18 97       	mov	r7,r12
80006682:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006684:	f0 1f 00 15 	mcall	800066d8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006688:	6c 08       	ld.w	r8,r6[0x0]
8000668a:	5b f8       	cp.w	r8,-1
8000668c:	c0 31       	brne	80006692 <xTaskCheckForTimeOut+0x16>
8000668e:	30 07       	mov	r7,0
80006690:	c1 f8       	rjmp	800066ce <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006692:	49 39       	lddpc	r9,800066dc <xTaskCheckForTimeOut+0x60>
80006694:	72 09       	ld.w	r9,r9[0x0]
80006696:	6e 0a       	ld.w	r10,r7[0x0]
80006698:	12 3a       	cp.w	r10,r9
8000669a:	c0 70       	breq	800066a8 <xTaskCheckForTimeOut+0x2c>
8000669c:	49 19       	lddpc	r9,800066e0 <xTaskCheckForTimeOut+0x64>
8000669e:	72 09       	ld.w	r9,r9[0x0]
800066a0:	6e 1a       	ld.w	r10,r7[0x4]
800066a2:	12 3a       	cp.w	r10,r9
800066a4:	e0 88 00 14 	brls	800066cc <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800066a8:	48 e9       	lddpc	r9,800066e0 <xTaskCheckForTimeOut+0x64>
800066aa:	72 0a       	ld.w	r10,r9[0x0]
800066ac:	6e 19       	ld.w	r9,r7[0x4]
800066ae:	12 1a       	sub	r10,r9
800066b0:	14 38       	cp.w	r8,r10
800066b2:	e0 88 00 0d 	brls	800066cc <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800066b6:	48 ba       	lddpc	r10,800066e0 <xTaskCheckForTimeOut+0x64>
800066b8:	74 0a       	ld.w	r10,r10[0x0]
800066ba:	14 19       	sub	r9,r10
800066bc:	f2 08 00 08 	add	r8,r9,r8
800066c0:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800066c2:	0e 9c       	mov	r12,r7
800066c4:	f0 1f 00 08 	mcall	800066e4 <xTaskCheckForTimeOut+0x68>
800066c8:	30 07       	mov	r7,0
800066ca:	c0 28       	rjmp	800066ce <xTaskCheckForTimeOut+0x52>
800066cc:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800066ce:	f0 1f 00 07 	mcall	800066e8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800066d2:	0e 9c       	mov	r12,r7
800066d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066d8:	80 00       	ld.sh	r0,r0[0x0]
800066da:	5b c8       	cp.w	r8,-4
800066dc:	00 00       	add	r0,r0
800066de:	0c 18       	sub	r8,r6
800066e0:	00 00       	add	r0,r0
800066e2:	0d 00       	ld.w	r0,r6++
800066e4:	80 00       	ld.sh	r0,r0[0x0]
800066e6:	63 e0       	ld.w	r0,r1[0x78]
800066e8:	80 00       	ld.sh	r0,r0[0x0]
800066ea:	5c d4       	com	r4

800066ec <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800066ec:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800066f0:	f0 1f 00 05 	mcall	80006704 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800066f4:	48 58       	lddpc	r8,80006708 <xTaskGetTickCount+0x1c>
800066f6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800066f8:	f0 1f 00 05 	mcall	8000670c <xTaskGetTickCount+0x20>

	return xTicks;
}
800066fc:	0e 9c       	mov	r12,r7
800066fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80006702:	00 00       	add	r0,r0
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	5b c8       	cp.w	r8,-4
80006708:	00 00       	add	r0,r0
8000670a:	0d 00       	ld.w	r0,r6++
8000670c:	80 00       	ld.sh	r0,r0[0x0]
8000670e:	5c d4       	com	r4

80006710 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006710:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006714:	f0 1f 00 2c 	mcall	800067c4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006718:	4a c8       	lddpc	r8,800067c8 <xTaskResumeAll+0xb8>
8000671a:	70 09       	ld.w	r9,r8[0x0]
8000671c:	20 19       	sub	r9,1
8000671e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006720:	70 08       	ld.w	r8,r8[0x0]
80006722:	58 08       	cp.w	r8,0
80006724:	c4 91       	brne	800067b6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006726:	4a a8       	lddpc	r8,800067cc <xTaskResumeAll+0xbc>
80006728:	70 08       	ld.w	r8,r8[0x0]
8000672a:	58 08       	cp.w	r8,0
8000672c:	c4 50       	breq	800067b6 <xTaskResumeAll+0xa6>
8000672e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006730:	4a 85       	lddpc	r5,800067d0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006732:	4a 93       	lddpc	r3,800067d4 <xTaskResumeAll+0xc4>
80006734:	4a 92       	lddpc	r2,800067d8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006736:	4a a1       	lddpc	r1,800067dc <xTaskResumeAll+0xcc>
80006738:	c1 e8       	rjmp	80006774 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000673a:	6a 38       	ld.w	r8,r5[0xc]
8000673c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000673e:	ee cc ff e8 	sub	r12,r7,-24
80006742:	f0 1f 00 28 	mcall	800067e0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006746:	ee c6 ff fc 	sub	r6,r7,-4
8000674a:	0c 9c       	mov	r12,r6
8000674c:	f0 1f 00 25 	mcall	800067e0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006750:	6e bc       	ld.w	r12,r7[0x2c]
80006752:	66 08       	ld.w	r8,r3[0x0]
80006754:	10 3c       	cp.w	r12,r8
80006756:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000675a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000675e:	0c 9b       	mov	r11,r6
80006760:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006764:	f0 1f 00 20 	mcall	800067e4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006768:	62 08       	ld.w	r8,r1[0x0]
8000676a:	6e b9       	ld.w	r9,r7[0x2c]
8000676c:	70 b8       	ld.w	r8,r8[0x2c]
8000676e:	10 39       	cp.w	r9,r8
80006770:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006774:	6a 08       	ld.w	r8,r5[0x0]
80006776:	58 08       	cp.w	r8,0
80006778:	ce 11       	brne	8000673a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000677a:	49 c8       	lddpc	r8,800067e8 <xTaskResumeAll+0xd8>
8000677c:	70 08       	ld.w	r8,r8[0x0]
8000677e:	58 08       	cp.w	r8,0
80006780:	c0 f0       	breq	8000679e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006782:	49 a8       	lddpc	r8,800067e8 <xTaskResumeAll+0xd8>
80006784:	70 08       	ld.w	r8,r8[0x0]
80006786:	58 08       	cp.w	r8,0
80006788:	c1 10       	breq	800067aa <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000678a:	49 87       	lddpc	r7,800067e8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000678c:	f0 1f 00 18 	mcall	800067ec <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006790:	6e 08       	ld.w	r8,r7[0x0]
80006792:	20 18       	sub	r8,1
80006794:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006796:	6e 08       	ld.w	r8,r7[0x0]
80006798:	58 08       	cp.w	r8,0
8000679a:	cf 91       	brne	8000678c <xTaskResumeAll+0x7c>
8000679c:	c0 78       	rjmp	800067aa <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000679e:	58 14       	cp.w	r4,1
800067a0:	c0 50       	breq	800067aa <xTaskResumeAll+0x9a>
800067a2:	49 48       	lddpc	r8,800067f0 <xTaskResumeAll+0xe0>
800067a4:	70 08       	ld.w	r8,r8[0x0]
800067a6:	58 18       	cp.w	r8,1
800067a8:	c0 71       	brne	800067b6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800067aa:	30 09       	mov	r9,0
800067ac:	49 18       	lddpc	r8,800067f0 <xTaskResumeAll+0xe0>
800067ae:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800067b0:	d7 33       	scall
800067b2:	30 17       	mov	r7,1
800067b4:	c0 28       	rjmp	800067b8 <xTaskResumeAll+0xa8>
800067b6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800067b8:	f0 1f 00 0f 	mcall	800067f4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800067bc:	0e 9c       	mov	r12,r7
800067be:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800067c2:	00 00       	add	r0,r0
800067c4:	80 00       	ld.sh	r0,r0[0x0]
800067c6:	5b c8       	cp.w	r8,-4
800067c8:	00 00       	add	r0,r0
800067ca:	0d 04       	ld.w	r4,r6++
800067cc:	00 00       	add	r0,r0
800067ce:	0d 20       	ld.uh	r0,r6++
800067d0:	00 00       	add	r0,r0
800067d2:	0c d8       	st.w	--r6,r8
800067d4:	00 00       	add	r0,r0
800067d6:	0d 3c       	ld.ub	r12,r6++
800067d8:	00 00       	add	r0,r0
800067da:	0c 20       	rsub	r0,r6
800067dc:	00 00       	add	r0,r0
800067de:	0c d4       	st.w	--r6,r4
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	5b 0e       	cp.w	lr,-16
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	5a be       	cp.w	lr,-21
800067e8:	00 00       	add	r0,r0
800067ea:	0c 04       	add	r4,r6
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	65 68       	ld.w	r8,r2[0x58]
800067f0:	00 00       	add	r0,r0
800067f2:	0d 24       	ld.uh	r4,r6++
800067f4:	80 00       	ld.sh	r0,r0[0x0]
800067f6:	5c d4       	com	r4

800067f8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800067f8:	eb cd 40 80 	pushm	r7,lr
800067fc:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800067fe:	49 08       	lddpc	r8,8000683c <prvAddCurrentTaskToDelayedList+0x44>
80006800:	70 08       	ld.w	r8,r8[0x0]
80006802:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006804:	48 f8       	lddpc	r8,80006840 <prvAddCurrentTaskToDelayedList+0x48>
80006806:	70 08       	ld.w	r8,r8[0x0]
80006808:	10 3c       	cp.w	r12,r8
8000680a:	c0 a2       	brcc	8000681e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000680c:	48 c8       	lddpc	r8,8000683c <prvAddCurrentTaskToDelayedList+0x44>
8000680e:	70 0b       	ld.w	r11,r8[0x0]
80006810:	48 d8       	lddpc	r8,80006844 <prvAddCurrentTaskToDelayedList+0x4c>
80006812:	70 0c       	ld.w	r12,r8[0x0]
80006814:	2f cb       	sub	r11,-4
80006816:	f0 1f 00 0d 	mcall	80006848 <prvAddCurrentTaskToDelayedList+0x50>
8000681a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000681e:	48 88       	lddpc	r8,8000683c <prvAddCurrentTaskToDelayedList+0x44>
80006820:	70 0b       	ld.w	r11,r8[0x0]
80006822:	48 b8       	lddpc	r8,8000684c <prvAddCurrentTaskToDelayedList+0x54>
80006824:	70 0c       	ld.w	r12,r8[0x0]
80006826:	2f cb       	sub	r11,-4
80006828:	f0 1f 00 08 	mcall	80006848 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000682c:	48 98       	lddpc	r8,80006850 <prvAddCurrentTaskToDelayedList+0x58>
8000682e:	70 08       	ld.w	r8,r8[0x0]
80006830:	10 37       	cp.w	r7,r8
80006832:	c0 32       	brcc	80006838 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006834:	48 78       	lddpc	r8,80006850 <prvAddCurrentTaskToDelayedList+0x58>
80006836:	91 07       	st.w	r8[0x0],r7
80006838:	e3 cd 80 80 	ldm	sp++,r7,pc
8000683c:	00 00       	add	r0,r0
8000683e:	0c d4       	st.w	--r6,r4
80006840:	00 00       	add	r0,r0
80006842:	0d 00       	ld.w	r0,r6++
80006844:	00 00       	add	r0,r0
80006846:	0c 1c       	sub	r12,r6
80006848:	80 00       	ld.sh	r0,r0[0x0]
8000684a:	5a da       	cp.w	r10,-19
8000684c:	00 00       	add	r0,r0
8000684e:	0c 0c       	add	r12,r6
80006850:	00 00       	add	r0,r0
80006852:	05 2c       	ld.uh	r12,r2++

80006854 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006854:	eb cd 40 c0 	pushm	r6-r7,lr
80006858:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
8000685a:	58 0c       	cp.w	r12,0
8000685c:	c1 10       	breq	8000687e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000685e:	f0 1f 00 0a 	mcall	80006884 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006862:	48 a8       	lddpc	r8,80006888 <vTaskDelay+0x34>
80006864:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006866:	48 a8       	lddpc	r8,8000688c <vTaskDelay+0x38>
80006868:	70 0c       	ld.w	r12,r8[0x0]
8000686a:	2f cc       	sub	r12,-4
8000686c:	f0 1f 00 09 	mcall	80006890 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006870:	ee 06 00 0c 	add	r12,r7,r6
80006874:	f0 1f 00 08 	mcall	80006894 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006878:	f0 1f 00 08 	mcall	80006898 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000687c:	c0 21       	brne	80006880 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
8000687e:	d7 33       	scall
80006880:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	63 54       	ld.w	r4,r1[0x54]
80006888:	00 00       	add	r0,r0
8000688a:	0d 00       	ld.w	r0,r6++
8000688c:	00 00       	add	r0,r0
8000688e:	0c d4       	st.w	--r6,r4
80006890:	80 00       	ld.sh	r0,r0[0x0]
80006892:	5b 0e       	cp.w	lr,-16
80006894:	80 00       	ld.sh	r0,r0[0x0]
80006896:	67 f8       	ld.w	r8,r3[0x7c]
80006898:	80 00       	ld.sh	r0,r0[0x0]
8000689a:	67 10       	ld.w	r0,r3[0x44]

8000689c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000689c:	eb cd 40 c0 	pushm	r6-r7,lr
800068a0:	18 96       	mov	r6,r12
800068a2:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800068a4:	f0 1f 00 18 	mcall	80006904 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800068a8:	6c 08       	ld.w	r8,r6[0x0]
800068aa:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800068ac:	49 79       	lddpc	r9,80006908 <vTaskDelayUntil+0x6c>
800068ae:	72 09       	ld.w	r9,r9[0x0]
800068b0:	12 38       	cp.w	r8,r9
800068b2:	e0 88 00 0c 	brls	800068ca <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800068b6:	0e 38       	cp.w	r8,r7
800068b8:	e0 88 00 22 	brls	800068fc <vTaskDelayUntil+0x60>
800068bc:	49 38       	lddpc	r8,80006908 <vTaskDelayUntil+0x6c>
800068be:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800068c0:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800068c2:	10 37       	cp.w	r7,r8
800068c4:	e0 88 00 14 	brls	800068ec <vTaskDelayUntil+0x50>
800068c8:	c0 a8       	rjmp	800068dc <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800068ca:	0e 38       	cp.w	r8,r7
800068cc:	e0 8b 00 16 	brhi	800068f8 <vTaskDelayUntil+0x5c>
800068d0:	48 e8       	lddpc	r8,80006908 <vTaskDelayUntil+0x6c>
800068d2:	70 08       	ld.w	r8,r8[0x0]
800068d4:	10 37       	cp.w	r7,r8
800068d6:	e0 8b 00 11 	brhi	800068f8 <vTaskDelayUntil+0x5c>
800068da:	c1 18       	rjmp	800068fc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068dc:	48 c8       	lddpc	r8,8000690c <vTaskDelayUntil+0x70>
800068de:	70 0c       	ld.w	r12,r8[0x0]
800068e0:	2f cc       	sub	r12,-4
800068e2:	f0 1f 00 0c 	mcall	80006910 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800068e6:	0e 9c       	mov	r12,r7
800068e8:	f0 1f 00 0b 	mcall	80006914 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800068ec:	f0 1f 00 0b 	mcall	80006918 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800068f0:	c0 81       	brne	80006900 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800068f2:	d7 33       	scall
800068f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800068f8:	8d 07       	st.w	r6[0x0],r7
800068fa:	cf 1b       	rjmp	800068dc <vTaskDelayUntil+0x40>
800068fc:	8d 07       	st.w	r6[0x0],r7
800068fe:	cf 7b       	rjmp	800068ec <vTaskDelayUntil+0x50>
80006900:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006904:	80 00       	ld.sh	r0,r0[0x0]
80006906:	63 54       	ld.w	r4,r1[0x54]
80006908:	00 00       	add	r0,r0
8000690a:	0d 00       	ld.w	r0,r6++
8000690c:	00 00       	add	r0,r0
8000690e:	0c d4       	st.w	--r6,r4
80006910:	80 00       	ld.sh	r0,r0[0x0]
80006912:	5b 0e       	cp.w	lr,-16
80006914:	80 00       	ld.sh	r0,r0[0x0]
80006916:	67 f8       	ld.w	r8,r3[0x7c]
80006918:	80 00       	ld.sh	r0,r0[0x0]
8000691a:	67 10       	ld.w	r0,r3[0x44]

8000691c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000691c:	eb cd 40 c0 	pushm	r6-r7,lr
80006920:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006922:	48 e7       	lddpc	r7,80006958 <vTaskPlaceOnEventList+0x3c>
80006924:	6e 0b       	ld.w	r11,r7[0x0]
80006926:	2e 8b       	sub	r11,-24
80006928:	f0 1f 00 0d 	mcall	8000695c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000692c:	6e 0c       	ld.w	r12,r7[0x0]
8000692e:	2f cc       	sub	r12,-4
80006930:	f0 1f 00 0c 	mcall	80006960 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006934:	5b f6       	cp.w	r6,-1
80006936:	c0 81       	brne	80006946 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006938:	6e 0b       	ld.w	r11,r7[0x0]
8000693a:	2f cb       	sub	r11,-4
8000693c:	48 ac       	lddpc	r12,80006964 <vTaskPlaceOnEventList+0x48>
8000693e:	f0 1f 00 0b 	mcall	80006968 <vTaskPlaceOnEventList+0x4c>
80006942:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006946:	48 a8       	lddpc	r8,8000696c <vTaskPlaceOnEventList+0x50>
80006948:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000694a:	ec 0c 00 0c 	add	r12,r6,r12
8000694e:	f0 1f 00 09 	mcall	80006970 <vTaskPlaceOnEventList+0x54>
80006952:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006956:	00 00       	add	r0,r0
80006958:	00 00       	add	r0,r0
8000695a:	0c d4       	st.w	--r6,r4
8000695c:	80 00       	ld.sh	r0,r0[0x0]
8000695e:	5a da       	cp.w	r10,-19
80006960:	80 00       	ld.sh	r0,r0[0x0]
80006962:	5b 0e       	cp.w	lr,-16
80006964:	00 00       	add	r0,r0
80006966:	0d 28       	ld.uh	r8,r6++
80006968:	80 00       	ld.sh	r0,r0[0x0]
8000696a:	5a be       	cp.w	lr,-21
8000696c:	00 00       	add	r0,r0
8000696e:	0d 00       	ld.w	r0,r6++
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	67 f8       	ld.w	r8,r3[0x7c]

80006974 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006974:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006978:	49 67       	lddpc	r7,800069d0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000697a:	49 74       	lddpc	r4,800069d4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000697c:	49 73       	lddpc	r3,800069d8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000697e:	49 85       	lddpc	r5,800069dc <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006980:	6e 08       	ld.w	r8,r7[0x0]
80006982:	58 08       	cp.w	r8,0
80006984:	c1 e0       	breq	800069c0 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006986:	f0 1f 00 17 	mcall	800069e0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000698a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
8000698c:	f0 1f 00 16 	mcall	800069e4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006990:	58 06       	cp.w	r6,0
80006992:	c1 70       	breq	800069c0 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006994:	f0 1f 00 15 	mcall	800069e8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006998:	68 38       	ld.w	r8,r4[0xc]
8000699a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000699c:	ec cc ff fc 	sub	r12,r6,-4
800069a0:	f0 1f 00 13 	mcall	800069ec <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800069a4:	66 08       	ld.w	r8,r3[0x0]
800069a6:	20 18       	sub	r8,1
800069a8:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800069aa:	6e 08       	ld.w	r8,r7[0x0]
800069ac:	20 18       	sub	r8,1
800069ae:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800069b0:	f0 1f 00 10 	mcall	800069f0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800069b4:	6c cc       	ld.w	r12,r6[0x30]
800069b6:	f0 1f 00 10 	mcall	800069f4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800069ba:	0c 9c       	mov	r12,r6
800069bc:	f0 1f 00 0e 	mcall	800069f4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800069c0:	6a 08       	ld.w	r8,r5[0x0]
800069c2:	58 18       	cp.w	r8,1
800069c4:	e0 88 00 03 	brls	800069ca <prvIdleTask+0x56>
			{
				taskYIELD();
800069c8:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800069ca:	f0 1f 00 0c 	mcall	800069f8 <prvIdleTask+0x84>
		}
		#endif
	}
800069ce:	cd 9b       	rjmp	80006980 <prvIdleTask+0xc>
800069d0:	00 00       	add	r0,r0
800069d2:	0c 14       	sub	r4,r6
800069d4:	00 00       	add	r0,r0
800069d6:	0c c0       	st.b	r6++,r0
800069d8:	00 00       	add	r0,r0
800069da:	0d 20       	ld.uh	r0,r6++
800069dc:	00 00       	add	r0,r0
800069de:	0c 20       	rsub	r0,r6
800069e0:	80 00       	ld.sh	r0,r0[0x0]
800069e2:	63 54       	ld.w	r4,r1[0x54]
800069e4:	80 00       	ld.sh	r0,r0[0x0]
800069e6:	67 10       	ld.w	r0,r3[0x44]
800069e8:	80 00       	ld.sh	r0,r0[0x0]
800069ea:	5b c8       	cp.w	r8,-4
800069ec:	80 00       	ld.sh	r0,r0[0x0]
800069ee:	5b 0e       	cp.w	lr,-16
800069f0:	80 00       	ld.sh	r0,r0[0x0]
800069f2:	5c d4       	com	r4
800069f4:	80 00       	ld.sh	r0,r0[0x0]
800069f6:	5e 0c       	reteq	r12
800069f8:	80 00       	ld.sh	r0,r0[0x0]
800069fa:	20 48       	sub	r8,4

800069fc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800069fc:	d4 31       	pushm	r0-r7,lr
800069fe:	20 1d       	sub	sp,4
80006a00:	fa c4 ff d8 	sub	r4,sp,-40
80006a04:	50 0c       	stdsp	sp[0x0],r12
80006a06:	16 91       	mov	r1,r11
80006a08:	14 97       	mov	r7,r10
80006a0a:	12 90       	mov	r0,r9
80006a0c:	10 93       	mov	r3,r8
80006a0e:	68 02       	ld.w	r2,r4[0x0]
80006a10:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006a12:	34 8c       	mov	r12,72
80006a14:	f0 1f 00 5c 	mcall	80006b84 <xTaskGenericCreate+0x188>
80006a18:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006a1a:	c0 31       	brne	80006a20 <xTaskGenericCreate+0x24>
80006a1c:	3f fc       	mov	r12,-1
80006a1e:	ca f8       	rjmp	80006b7c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006a20:	58 06       	cp.w	r6,0
80006a22:	e0 81 00 af 	brne	80006b80 <xTaskGenericCreate+0x184>
80006a26:	0e 9c       	mov	r12,r7
80006a28:	5c 7c       	castu.h	r12
80006a2a:	a3 6c       	lsl	r12,0x2
80006a2c:	f0 1f 00 56 	mcall	80006b84 <xTaskGenericCreate+0x188>
80006a30:	18 96       	mov	r6,r12
80006a32:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006a34:	c0 61       	brne	80006a40 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006a36:	0a 9c       	mov	r12,r5
80006a38:	f0 1f 00 54 	mcall	80006b88 <xTaskGenericCreate+0x18c>
80006a3c:	3f fc       	mov	r12,-1
80006a3e:	c9 f8       	rjmp	80006b7c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006a40:	5c 77       	castu.h	r7
80006a42:	ee 0a 15 02 	lsl	r10,r7,0x2
80006a46:	e0 6b 00 a5 	mov	r11,165
80006a4a:	0c 9c       	mov	r12,r6
80006a4c:	f0 1f 00 50 	mcall	80006b8c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006a50:	ee c6 00 01 	sub	r6,r7,1
80006a54:	6a c8       	ld.w	r8,r5[0x30]
80006a56:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006a5a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006a5e:	31 0a       	mov	r10,16
80006a60:	02 9b       	mov	r11,r1
80006a62:	ea cc ff cc 	sub	r12,r5,-52
80006a66:	f0 1f 00 4b 	mcall	80006b90 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006a6a:	30 08       	mov	r8,0
80006a6c:	eb 68 00 43 	st.b	r5[67],r8
80006a70:	58 73       	cp.w	r3,7
80006a72:	e6 07 17 80 	movls	r7,r3
80006a76:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006a7a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006a7c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006a80:	ea c4 ff fc 	sub	r4,r5,-4
80006a84:	08 9c       	mov	r12,r4
80006a86:	f0 1f 00 44 	mcall	80006b94 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006a8a:	ea cc ff e8 	sub	r12,r5,-24
80006a8e:	f0 1f 00 42 	mcall	80006b94 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006a92:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006a94:	ee 07 11 08 	rsub	r7,r7,8
80006a98:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006a9a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006a9c:	00 9a       	mov	r10,r0
80006a9e:	40 0b       	lddsp	r11,sp[0x0]
80006aa0:	0c 9c       	mov	r12,r6
80006aa2:	f0 1f 00 3e 	mcall	80006b98 <xTaskGenericCreate+0x19c>
80006aa6:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006aa8:	58 02       	cp.w	r2,0
80006aaa:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006aae:	f0 1f 00 3c 	mcall	80006b9c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006ab2:	4b c8       	lddpc	r8,80006ba0 <xTaskGenericCreate+0x1a4>
80006ab4:	70 09       	ld.w	r9,r8[0x0]
80006ab6:	2f f9       	sub	r9,-1
80006ab8:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006aba:	4b b8       	lddpc	r8,80006ba4 <xTaskGenericCreate+0x1a8>
80006abc:	70 08       	ld.w	r8,r8[0x0]
80006abe:	58 08       	cp.w	r8,0
80006ac0:	c2 61       	brne	80006b0c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006ac2:	4b 98       	lddpc	r8,80006ba4 <xTaskGenericCreate+0x1a8>
80006ac4:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006ac6:	4b 78       	lddpc	r8,80006ba0 <xTaskGenericCreate+0x1a4>
80006ac8:	70 08       	ld.w	r8,r8[0x0]
80006aca:	58 18       	cp.w	r8,1
80006acc:	c2 b1       	brne	80006b22 <xTaskGenericCreate+0x126>
80006ace:	4b 77       	lddpc	r7,80006ba8 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006ad0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006ad4:	0e 9c       	mov	r12,r7
80006ad6:	f0 1f 00 36 	mcall	80006bac <xTaskGenericCreate+0x1b0>
80006ada:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006adc:	0c 37       	cp.w	r7,r6
80006ade:	cf b1       	brne	80006ad4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006ae0:	4b 47       	lddpc	r7,80006bb0 <xTaskGenericCreate+0x1b4>
80006ae2:	0e 9c       	mov	r12,r7
80006ae4:	f0 1f 00 32 	mcall	80006bac <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006ae8:	4b 36       	lddpc	r6,80006bb4 <xTaskGenericCreate+0x1b8>
80006aea:	0c 9c       	mov	r12,r6
80006aec:	f0 1f 00 30 	mcall	80006bac <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006af0:	4b 2c       	lddpc	r12,80006bb8 <xTaskGenericCreate+0x1bc>
80006af2:	f0 1f 00 2f 	mcall	80006bac <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006af6:	4b 2c       	lddpc	r12,80006bbc <xTaskGenericCreate+0x1c0>
80006af8:	f0 1f 00 2d 	mcall	80006bac <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006afc:	4b 1c       	lddpc	r12,80006bc0 <xTaskGenericCreate+0x1c4>
80006afe:	f0 1f 00 2c 	mcall	80006bac <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006b02:	4b 18       	lddpc	r8,80006bc4 <xTaskGenericCreate+0x1c8>
80006b04:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006b06:	4b 18       	lddpc	r8,80006bc8 <xTaskGenericCreate+0x1cc>
80006b08:	91 06       	st.w	r8[0x0],r6
80006b0a:	c0 c8       	rjmp	80006b22 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006b0c:	4b 08       	lddpc	r8,80006bcc <xTaskGenericCreate+0x1d0>
80006b0e:	70 08       	ld.w	r8,r8[0x0]
80006b10:	58 08       	cp.w	r8,0
80006b12:	c0 81       	brne	80006b22 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006b14:	4a 48       	lddpc	r8,80006ba4 <xTaskGenericCreate+0x1a8>
80006b16:	70 08       	ld.w	r8,r8[0x0]
80006b18:	70 b8       	ld.w	r8,r8[0x2c]
80006b1a:	10 33       	cp.w	r3,r8
80006b1c:	c0 33       	brcs	80006b22 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006b1e:	4a 28       	lddpc	r8,80006ba4 <xTaskGenericCreate+0x1a8>
80006b20:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006b22:	6a b8       	ld.w	r8,r5[0x2c]
80006b24:	4a b9       	lddpc	r9,80006bd0 <xTaskGenericCreate+0x1d4>
80006b26:	72 09       	ld.w	r9,r9[0x0]
80006b28:	12 38       	cp.w	r8,r9
80006b2a:	e0 88 00 04 	brls	80006b32 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006b2e:	4a 99       	lddpc	r9,80006bd0 <xTaskGenericCreate+0x1d4>
80006b30:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006b32:	4a 98       	lddpc	r8,80006bd4 <xTaskGenericCreate+0x1d8>
80006b34:	70 09       	ld.w	r9,r8[0x0]
80006b36:	2f f9       	sub	r9,-1
80006b38:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006b3a:	6a b8       	ld.w	r8,r5[0x2c]
80006b3c:	4a 79       	lddpc	r9,80006bd8 <xTaskGenericCreate+0x1dc>
80006b3e:	72 09       	ld.w	r9,r9[0x0]
80006b40:	12 38       	cp.w	r8,r9
80006b42:	e0 88 00 04 	brls	80006b4a <xTaskGenericCreate+0x14e>
80006b46:	4a 59       	lddpc	r9,80006bd8 <xTaskGenericCreate+0x1dc>
80006b48:	93 08       	st.w	r9[0x0],r8
80006b4a:	6a bc       	ld.w	r12,r5[0x2c]
80006b4c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006b50:	08 9b       	mov	r11,r4
80006b52:	49 68       	lddpc	r8,80006ba8 <xTaskGenericCreate+0x1ac>
80006b54:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006b58:	f0 1f 00 21 	mcall	80006bdc <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006b5c:	f0 1f 00 21 	mcall	80006be0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006b60:	49 b8       	lddpc	r8,80006bcc <xTaskGenericCreate+0x1d0>
80006b62:	70 08       	ld.w	r8,r8[0x0]
80006b64:	58 08       	cp.w	r8,0
80006b66:	c0 a0       	breq	80006b7a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006b68:	48 f8       	lddpc	r8,80006ba4 <xTaskGenericCreate+0x1a8>
80006b6a:	70 08       	ld.w	r8,r8[0x0]
80006b6c:	70 b8       	ld.w	r8,r8[0x2c]
80006b6e:	10 33       	cp.w	r3,r8
80006b70:	e0 88 00 05 	brls	80006b7a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006b74:	d7 33       	scall
80006b76:	30 1c       	mov	r12,1
80006b78:	c0 28       	rjmp	80006b7c <xTaskGenericCreate+0x180>
80006b7a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006b7c:	2f fd       	sub	sp,-4
80006b7e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006b80:	99 c6       	st.w	r12[0x30],r6
80006b82:	c5 fb       	rjmp	80006a40 <xTaskGenericCreate+0x44>
80006b84:	80 00       	ld.sh	r0,r0[0x0]
80006b86:	5e 34       	retlo	r4
80006b88:	80 00       	ld.sh	r0,r0[0x0]
80006b8a:	5e 0c       	reteq	r12
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	77 84       	ld.w	r4,r11[0x60]
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	7a b0       	ld.w	r0,sp[0x2c]
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	5a b8       	cp.w	r8,-21
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	5b 34       	cp.w	r4,-13
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	5b c8       	cp.w	r8,-4
80006ba0:	00 00       	add	r0,r0
80006ba2:	0d 20       	ld.uh	r0,r6++
80006ba4:	00 00       	add	r0,r0
80006ba6:	0c d4       	st.w	--r6,r4
80006ba8:	00 00       	add	r0,r0
80006baa:	0c 20       	rsub	r0,r6
80006bac:	80 00       	ld.sh	r0,r0[0x0]
80006bae:	5a a4       	cp.w	r4,-22
80006bb0:	00 00       	add	r0,r0
80006bb2:	0c ec       	st.h	--r6,r12
80006bb4:	00 00       	add	r0,r0
80006bb6:	0d 08       	ld.w	r8,r6++
80006bb8:	00 00       	add	r0,r0
80006bba:	0c d8       	st.w	--r6,r8
80006bbc:	00 00       	add	r0,r0
80006bbe:	0c c0       	st.b	r6++,r0
80006bc0:	00 00       	add	r0,r0
80006bc2:	0d 28       	ld.uh	r8,r6++
80006bc4:	00 00       	add	r0,r0
80006bc6:	0c 0c       	add	r12,r6
80006bc8:	00 00       	add	r0,r0
80006bca:	0c 1c       	sub	r12,r6
80006bcc:	00 00       	add	r0,r0
80006bce:	0c 10       	sub	r0,r6
80006bd0:	00 00       	add	r0,r0
80006bd2:	0c 08       	add	r8,r6
80006bd4:	00 00       	add	r0,r0
80006bd6:	0d 1c       	ld.sh	r12,r6++
80006bd8:	00 00       	add	r0,r0
80006bda:	0d 3c       	ld.ub	r12,r6++
80006bdc:	80 00       	ld.sh	r0,r0[0x0]
80006bde:	5a be       	cp.w	lr,-21
80006be0:	80 00       	ld.sh	r0,r0[0x0]
80006be2:	5c d4       	com	r4

80006be4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006be4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006be6:	30 09       	mov	r9,0
80006be8:	1a d9       	st.w	--sp,r9
80006bea:	1a d9       	st.w	--sp,r9
80006bec:	1a d9       	st.w	--sp,r9
80006bee:	12 98       	mov	r8,r9
80006bf0:	e0 6a 01 00 	mov	r10,256
80006bf4:	48 9b       	lddpc	r11,80006c18 <vTaskStartScheduler+0x34>
80006bf6:	48 ac       	lddpc	r12,80006c1c <vTaskStartScheduler+0x38>
80006bf8:	f0 1f 00 0a 	mcall	80006c20 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006bfc:	2f dd       	sub	sp,-12
80006bfe:	58 1c       	cp.w	r12,1
80006c00:	c0 a1       	brne	80006c14 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006c02:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006c04:	30 19       	mov	r9,1
80006c06:	48 88       	lddpc	r8,80006c24 <vTaskStartScheduler+0x40>
80006c08:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006c0a:	30 09       	mov	r9,0
80006c0c:	48 78       	lddpc	r8,80006c28 <vTaskStartScheduler+0x44>
80006c0e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006c10:	f0 1f 00 07 	mcall	80006c2c <vTaskStartScheduler+0x48>
80006c14:	d8 02       	popm	pc
80006c16:	00 00       	add	r0,r0
80006c18:	80 00       	ld.sh	r0,r0[0x0]
80006c1a:	d7 f8       	*unknown*
80006c1c:	80 00       	ld.sh	r0,r0[0x0]
80006c1e:	69 74       	ld.w	r4,r4[0x5c]
80006c20:	80 00       	ld.sh	r0,r0[0x0]
80006c22:	69 fc       	ld.w	r12,r4[0x7c]
80006c24:	00 00       	add	r0,r0
80006c26:	0c 10       	sub	r0,r6
80006c28:	00 00       	add	r0,r0
80006c2a:	0d 00       	ld.w	r0,r6++
80006c2c:	80 00       	ld.sh	r0,r0[0x0]
80006c2e:	5b d8       	cp.w	r8,-3

80006c30 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006c30:	16 cc       	st.b	r11++,r12
	return str;
}
80006c32:	5e fb       	retal	r11

80006c34 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006c34:	eb cd 40 c0 	pushm	r6-r7,lr
80006c38:	20 3d       	sub	sp,12
80006c3a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006c3c:	30 06       	mov	r6,0
80006c3e:	30 07       	mov	r7,0
80006c40:	fa e7 00 00 	st.d	sp[0],r6
80006c44:	30 0c       	mov	r12,0
80006c46:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006c48:	58 08       	cp.w	r8,0
80006c4a:	c1 30       	breq	80006c70 <PrintHex+0x3c>
80006c4c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006c4e:	1a 9c       	mov	r12,sp
80006c50:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c54:	58 9e       	cp.w	lr,9
80006c56:	e0 8a 00 04 	brle	80006c5e <PrintHex+0x2a>
80006c5a:	2c 9e       	sub	lr,-55
80006c5c:	c0 48       	rjmp	80006c64 <PrintHex+0x30>
80006c5e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c62:	2d 0e       	sub	lr,-48
80006c64:	f8 09 0b 0e 	st.b	r12[r9],lr
80006c68:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006c6a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006c6c:	cf 21       	brne	80006c50 <PrintHex+0x1c>
80006c6e:	c0 48       	rjmp	80006c76 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006c70:	33 08       	mov	r8,48
80006c72:	ba 88       	st.b	sp[0x0],r8
80006c74:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006c76:	f6 09 01 08 	sub	r8,r11,r9
80006c7a:	58 08       	cp.w	r8,0
80006c7c:	e0 8a 00 13 	brle	80006ca2 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006c80:	12 1b       	sub	r11,r9
80006c82:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006c86:	18 9e       	mov	lr,r12
80006c88:	58 0c       	cp.w	r12,0
80006c8a:	e0 8a 00 0c 	brle	80006ca2 <PrintHex+0x6e>
80006c8e:	1a 9b       	mov	r11,sp
80006c90:	12 0b       	add	r11,r9
80006c92:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006c94:	33 07       	mov	r7,48
80006c96:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006c98:	2f f8       	sub	r8,-1
80006c9a:	1c 38       	cp.w	r8,lr
80006c9c:	cf d5       	brlt	80006c96 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006c9e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ca2:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006ca6:	f0 cb ff ff 	sub	r11,r8,-1
80006caa:	58 0b       	cp.w	r11,0
80006cac:	e0 8a 00 19 	brle	80006cde <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006cb0:	fa cb ff f4 	sub	r11,sp,-12
80006cb4:	f6 09 00 09 	add	r9,r11,r9
80006cb8:	37 8b       	mov	r11,120
80006cba:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006cbe:	fa c9 ff f4 	sub	r9,sp,-12
80006cc2:	10 09       	add	r9,r8
80006cc4:	33 0b       	mov	r11,48
80006cc6:	f3 6b ff f4 	st.b	r9[-12],r11
80006cca:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006cce:	fa ce 00 01 	sub	lr,sp,1
80006cd2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006cd4:	11 8b       	ld.ub	r11,r8[0x0]
80006cd6:	12 cb       	st.b	r9++,r11
80006cd8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006cda:	1c 38       	cp.w	r8,lr
80006cdc:	cf c1       	brne	80006cd4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006cde:	14 9c       	mov	r12,r10
80006ce0:	2f dd       	sub	sp,-12
80006ce2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006ce6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006ce6:	d4 21       	pushm	r4-r7,lr
80006ce8:	20 3d       	sub	sp,12
80006cea:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006cec:	30 06       	mov	r6,0
80006cee:	30 07       	mov	r7,0
80006cf0:	fa e7 00 00 	st.d	sp[0],r6
80006cf4:	30 0c       	mov	r12,0
80006cf6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006cf8:	58 08       	cp.w	r8,0
80006cfa:	c0 35       	brlt	80006d00 <PrintDec+0x1a>
80006cfc:	14 97       	mov	r7,r10
80006cfe:	c0 58       	rjmp	80006d08 <PrintDec+0x22>
	{
		*p++ = '-';
80006d00:	14 97       	mov	r7,r10
80006d02:	32 d9       	mov	r9,45
80006d04:	0e c9       	st.b	r7++,r9
		i = -i;
80006d06:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006d08:	58 08       	cp.w	r8,0
80006d0a:	c0 51       	brne	80006d14 <PrintDec+0x2e>
80006d0c:	33 08       	mov	r8,48
80006d0e:	ba 88       	st.b	sp[0x0],r8
80006d10:	30 1e       	mov	lr,1
80006d12:	c2 f8       	rjmp	80006d70 <PrintDec+0x8a>
	
	int ten = i%10;
80006d14:	e0 65 66 67 	mov	r5,26215
80006d18:	ea 15 66 66 	orh	r5,0x6666
80006d1c:	f0 05 04 44 	muls.d	r4,r8,r5
80006d20:	ea 0c 14 02 	asr	r12,r5,0x2
80006d24:	f0 09 14 1f 	asr	r9,r8,0x1f
80006d28:	f8 09 01 09 	sub	r9,r12,r9
80006d2c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d30:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006d34:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006d36:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006d38:	e0 66 66 67 	mov	r6,26215
80006d3c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006d40:	2d 09       	sub	r9,-48
80006d42:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006d46:	2f fe       	sub	lr,-1
		i /= 10;
80006d48:	f0 06 04 44 	muls.d	r4,r8,r6
80006d4c:	ea 09 14 02 	asr	r9,r5,0x2
80006d50:	bf 58       	asr	r8,0x1f
80006d52:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006d56:	f0 06 04 44 	muls.d	r4,r8,r6
80006d5a:	ea 09 14 02 	asr	r9,r5,0x2
80006d5e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006d62:	0a 19       	sub	r9,r5
80006d64:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d68:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006d6c:	58 08       	cp.w	r8,0
80006d6e:	ce 91       	brne	80006d40 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006d70:	f6 0e 01 08 	sub	r8,r11,lr
80006d74:	58 08       	cp.w	r8,0
80006d76:	e0 89 00 06 	brgt	80006d82 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006d7a:	58 0e       	cp.w	lr,0
80006d7c:	e0 89 00 14 	brgt	80006da4 <PrintDec+0xbe>
80006d80:	c1 d8       	rjmp	80006dba <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006d82:	1c 1b       	sub	r11,lr
80006d84:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006d86:	16 9c       	mov	r12,r11
80006d88:	58 0b       	cp.w	r11,0
80006d8a:	fe 9a ff f8 	brle	80006d7a <PrintDec+0x94>
80006d8e:	1a 99       	mov	r9,sp
80006d90:	1c 09       	add	r9,lr
80006d92:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006d94:	33 06       	mov	r6,48
80006d96:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006d98:	2f f8       	sub	r8,-1
80006d9a:	18 38       	cp.w	r8,r12
80006d9c:	cf d5       	brlt	80006d96 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006d9e:	f6 0e 00 0e 	add	lr,r11,lr
80006da2:	ce cb       	rjmp	80006d7a <PrintDec+0x94>
80006da4:	fa c8 ff f4 	sub	r8,sp,-12
80006da8:	1c 08       	add	r8,lr
80006daa:	20 d8       	sub	r8,13
80006dac:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006db0:	11 89       	ld.ub	r9,r8[0x0]
80006db2:	0e c9       	st.b	r7++,r9
80006db4:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006db6:	16 38       	cp.w	r8,r11
80006db8:	cf c1       	brne	80006db0 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006dba:	14 9c       	mov	r12,r10
80006dbc:	2f dd       	sub	sp,-12
80006dbe:	d8 22       	popm	r4-r7,pc

80006dc0 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006dc0:	d4 31       	pushm	r0-r7,lr
80006dc2:	fa cd 02 08 	sub	sp,sp,520
80006dc6:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006dc8:	e0 6a 01 00 	mov	r10,256
80006dcc:	30 0b       	mov	r11,0
80006dce:	fa cc fe f8 	sub	r12,sp,-264
80006dd2:	f0 1f 00 4e 	mcall	80006f08 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006dd6:	fa c4 fd d4 	sub	r4,sp,-556
80006dda:	30 0a       	mov	r10,0
80006ddc:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006dde:	fa c3 ff fc 	sub	r3,sp,-4
80006de2:	e0 61 01 00 	mov	r1,256
80006de6:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006de8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006dea:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006dee:	02 9a       	mov	r10,r1
80006df0:	00 9b       	mov	r11,r0
80006df2:	06 9c       	mov	r12,r3
80006df4:	f0 1f 00 45 	mcall	80006f08 <log+0x148>
			
					if(*str == '%')
80006df8:	0f 88       	ld.ub	r8,r7[0x0]
80006dfa:	e4 08 18 00 	cp.b	r8,r2
80006dfe:	c5 71       	brne	80006eac <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006e00:	ee c8 ff ff 	sub	r8,r7,-1
80006e04:	11 89       	ld.ub	r9,r8[0x0]
80006e06:	4c 2a       	lddpc	r10,80006f0c <log+0x14c>
80006e08:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006e0a:	23 09       	sub	r9,48
80006e0c:	30 9a       	mov	r10,9
80006e0e:	f4 09 18 00 	cp.b	r9,r10
80006e12:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006e16:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006e1a:	f7 b9 08 30 	subls	r9,48
80006e1e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006e22:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006e26:	0f 88       	ld.ub	r8,r7[0x0]
80006e28:	22 58       	sub	r8,37
80006e2a:	e0 48 00 53 	cp.w	r8,83
80006e2e:	e0 8b 00 31 	brhi	80006e90 <log+0xd0>
80006e32:	4b 89       	lddpc	r9,80006f10 <log+0x150>
80006e34:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006e38:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006e3c:	06 9a       	mov	r10,r3
80006e3e:	40 0b       	lddsp	r11,sp[0x0]
80006e40:	5c 5b       	castu.b	r11
80006e42:	68 0c       	ld.w	r12,r4[0x0]
80006e44:	f0 1f 00 34 	mcall	80006f14 <log+0x154>
							break;
80006e48:	c2 98       	rjmp	80006e9a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006e4a:	4b 4c       	lddpc	r12,80006f18 <log+0x158>
80006e4c:	f0 1f 00 34 	mcall	80006f1c <log+0x15c>
80006e50:	08 95       	mov	r5,r4
80006e52:	06 9c       	mov	r12,r3
							break;
80006e54:	c2 38       	rjmp	80006e9a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006e56:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006e5a:	06 9a       	mov	r10,r3
80006e5c:	40 0b       	lddsp	r11,sp[0x0]
80006e5e:	5c 5b       	castu.b	r11
80006e60:	68 0c       	ld.w	r12,r4[0x0]
80006e62:	f0 1f 00 30 	mcall	80006f20 <log+0x160>
80006e66:	06 9c       	mov	r12,r3
							break;
80006e68:	c1 98       	rjmp	80006e9a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006e6a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006e6e:	06 9b       	mov	r11,r3
80006e70:	09 bc       	ld.ub	r12,r4[0x3]
80006e72:	f0 1f 00 2d 	mcall	80006f24 <log+0x164>
80006e76:	06 9c       	mov	r12,r3
							break;
80006e78:	c1 18       	rjmp	80006e9a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006e7a:	e8 c5 ff fc 	sub	r5,r4,-4
80006e7e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006e80:	c0 d8       	rjmp	80006e9a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006e82:	06 9b       	mov	r11,r3
80006e84:	32 5c       	mov	r12,37
80006e86:	f0 1f 00 28 	mcall	80006f24 <log+0x164>
80006e8a:	08 95       	mov	r5,r4
80006e8c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006e8e:	c0 68       	rjmp	80006e9a <log+0xda>
							
							default:
							log("I need relax.");
80006e90:	4a 6c       	lddpc	r12,80006f28 <log+0x168>
80006e92:	f0 1f 00 23 	mcall	80006f1c <log+0x15c>
80006e96:	08 95       	mov	r5,r4
80006e98:	06 9c       	mov	r12,r3
						}
						str++;
80006e9a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006e9c:	1a dc       	st.w	--sp,r12
80006e9e:	1a d6       	st.w	--sp,r6
80006ea0:	4a 3b       	lddpc	r11,80006f2c <log+0x16c>
80006ea2:	0c 9c       	mov	r12,r6
80006ea4:	f0 1f 00 23 	mcall	80006f30 <log+0x170>
80006ea8:	2f ed       	sub	sp,-8
80006eaa:	c0 a8       	rjmp	80006ebe <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006eac:	2f f7       	sub	r7,-1
80006eae:	1a d8       	st.w	--sp,r8
80006eb0:	1a d6       	st.w	--sp,r6
80006eb2:	4a 1b       	lddpc	r11,80006f34 <log+0x174>
80006eb4:	0c 9c       	mov	r12,r6
80006eb6:	f0 1f 00 1f 	mcall	80006f30 <log+0x170>
80006eba:	08 95       	mov	r5,r4
80006ebc:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006ebe:	0f 89       	ld.ub	r9,r7[0x0]
80006ec0:	30 08       	mov	r8,0
80006ec2:	f0 09 18 00 	cp.b	r9,r8
80006ec6:	c0 30       	breq	80006ecc <log+0x10c>
80006ec8:	0a 94       	mov	r4,r5
80006eca:	c9 2b       	rjmp	80006dee <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006ecc:	fa c7 fe f8 	sub	r7,sp,-264
80006ed0:	1a d7       	st.w	--sp,r7
80006ed2:	49 ab       	lddpc	r11,80006f38 <log+0x178>
80006ed4:	0e 9c       	mov	r12,r7
80006ed6:	f0 1f 00 17 	mcall	80006f30 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006eda:	5c 5c       	castu.b	r12
80006edc:	f8 c6 ff ff 	sub	r6,r12,-1
80006ee0:	0c 9c       	mov	r12,r6
80006ee2:	f0 1f 00 17 	mcall	80006f3c <log+0x17c>
80006ee6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006ee8:	0c 9a       	mov	r10,r6
80006eea:	0e 9b       	mov	r11,r7
80006eec:	f0 1f 00 15 	mcall	80006f40 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006ef0:	30 09       	mov	r9,0
80006ef2:	30 5a       	mov	r10,5
80006ef4:	fa cb fe f8 	sub	r11,sp,-264
80006ef8:	49 38       	lddpc	r8,80006f44 <log+0x184>
80006efa:	70 0c       	ld.w	r12,r8[0x0]
80006efc:	f0 1f 00 13 	mcall	80006f48 <log+0x188>
80006f00:	2f fd       	sub	sp,-4
	
	
}
80006f02:	fe 3d fd f8 	sub	sp,-520
80006f06:	d8 32       	popm	r0-r7,pc
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	77 84       	ld.w	r4,r11[0x60]
80006f0c:	00 00       	add	r0,r0
80006f0e:	0d 40       	ld.w	r0,--r6
80006f10:	80 00       	ld.sh	r0,r0[0x0]
80006f12:	d8 00       	acall	0x80
80006f14:	80 00       	ld.sh	r0,r0[0x0]
80006f16:	6c e6       	ld.w	r6,r6[0x38]
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	da ac       	*unknown*
80006f1c:	80 00       	ld.sh	r0,r0[0x0]
80006f1e:	6d c0       	ld.w	r0,r6[0x70]
80006f20:	80 00       	ld.sh	r0,r0[0x0]
80006f22:	6c 34       	ld.w	r4,r6[0xc]
80006f24:	80 00       	ld.sh	r0,r0[0x0]
80006f26:	6c 30       	ld.w	r0,r6[0xc]
80006f28:	80 00       	ld.sh	r0,r0[0x0]
80006f2a:	da bc       	*unknown*
80006f2c:	80 00       	ld.sh	r0,r0[0x0]
80006f2e:	da cc       	*unknown*
80006f30:	80 00       	ld.sh	r0,r0[0x0]
80006f32:	7a 74       	ld.w	r4,sp[0x1c]
80006f34:	80 00       	ld.sh	r0,r0[0x0]
80006f36:	da d4       	*unknown*
80006f38:	80 00       	ld.sh	r0,r0[0x0]
80006f3a:	da dc       	*unknown*
80006f3c:	80 00       	ld.sh	r0,r0[0x0]
80006f3e:	5e 34       	retlo	r4
80006f40:	80 00       	ld.sh	r0,r0[0x0]
80006f42:	76 3c       	ld.w	r12,r11[0xc]
80006f44:	00 00       	add	r0,r0
80006f46:	b6 74       	st.h	r11[0xe],r4
80006f48:	80 00       	ld.sh	r0,r0[0x0]
80006f4a:	61 88       	ld.w	r8,r0[0x60]

80006f4c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006f4c:	d4 31       	pushm	r0-r7,lr
80006f4e:	fa cd 02 0c 	sub	sp,sp,524
80006f52:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006f54:	e0 6a 01 00 	mov	r10,256
80006f58:	30 0b       	mov	r11,0
80006f5a:	fa cc fe f4 	sub	r12,sp,-268
80006f5e:	f0 1f 00 4c 	mcall	8000708c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006f62:	fa c4 fd d0 	sub	r4,sp,-560
80006f66:	30 0a       	mov	r10,0
80006f68:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f6a:	fa c3 ff fc 	sub	r3,sp,-4
80006f6e:	e0 61 01 00 	mov	r1,256
80006f72:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006f74:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f76:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f7a:	02 9a       	mov	r10,r1
80006f7c:	00 9b       	mov	r11,r0
80006f7e:	06 9c       	mov	r12,r3
80006f80:	f0 1f 00 43 	mcall	8000708c <logFromISR+0x140>
			
			if(*str == '%')
80006f84:	0f 88       	ld.ub	r8,r7[0x0]
80006f86:	e4 08 18 00 	cp.b	r8,r2
80006f8a:	c5 11       	brne	8000702c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006f8c:	ee c8 ff ff 	sub	r8,r7,-1
80006f90:	11 89       	ld.ub	r9,r8[0x0]
80006f92:	4c 0a       	lddpc	r10,80007090 <logFromISR+0x144>
80006f94:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006f96:	23 09       	sub	r9,48
80006f98:	30 9a       	mov	r10,9
80006f9a:	f4 09 18 00 	cp.b	r9,r10
80006f9e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006fa2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006fa6:	f7 b9 08 30 	subls	r9,48
80006faa:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006fae:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006fb2:	0f 88       	ld.ub	r8,r7[0x0]
80006fb4:	22 58       	sub	r8,37
80006fb6:	e0 48 00 53 	cp.w	r8,83
80006fba:	e0 8b 00 2b 	brhi	80007010 <logFromISR+0xc4>
80006fbe:	4b 69       	lddpc	r9,80007094 <logFromISR+0x148>
80006fc0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006fc4:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006fc8:	06 9a       	mov	r10,r3
80006fca:	40 0b       	lddsp	r11,sp[0x0]
80006fcc:	5c 5b       	castu.b	r11
80006fce:	68 0c       	ld.w	r12,r4[0x0]
80006fd0:	f0 1f 00 32 	mcall	80007098 <logFromISR+0x14c>
					break;
80006fd4:	c2 38       	rjmp	8000701a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006fd6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006fda:	06 9a       	mov	r10,r3
80006fdc:	40 0b       	lddsp	r11,sp[0x0]
80006fde:	5c 5b       	castu.b	r11
80006fe0:	68 0c       	ld.w	r12,r4[0x0]
80006fe2:	f0 1f 00 2f 	mcall	8000709c <logFromISR+0x150>
80006fe6:	06 9c       	mov	r12,r3
					break;
80006fe8:	c1 98       	rjmp	8000701a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006fea:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006fee:	06 9b       	mov	r11,r3
80006ff0:	09 bc       	ld.ub	r12,r4[0x3]
80006ff2:	f0 1f 00 2c 	mcall	800070a0 <logFromISR+0x154>
80006ff6:	06 9c       	mov	r12,r3
					break;
80006ff8:	c1 18       	rjmp	8000701a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006ffa:	e8 c5 ff fc 	sub	r5,r4,-4
80006ffe:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007000:	c0 d8       	rjmp	8000701a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007002:	06 9b       	mov	r11,r3
80007004:	32 5c       	mov	r12,37
80007006:	f0 1f 00 27 	mcall	800070a0 <logFromISR+0x154>
8000700a:	08 95       	mov	r5,r4
8000700c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000700e:	c0 68       	rjmp	8000701a <logFromISR+0xce>
					default:
					log("I need relax.");
80007010:	4a 5c       	lddpc	r12,800070a4 <logFromISR+0x158>
80007012:	f0 1f 00 26 	mcall	800070a8 <logFromISR+0x15c>
80007016:	08 95       	mov	r5,r4
80007018:	06 9c       	mov	r12,r3
				}
				str++;
8000701a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000701c:	1a dc       	st.w	--sp,r12
8000701e:	1a d6       	st.w	--sp,r6
80007020:	4a 3b       	lddpc	r11,800070ac <logFromISR+0x160>
80007022:	0c 9c       	mov	r12,r6
80007024:	f0 1f 00 23 	mcall	800070b0 <logFromISR+0x164>
80007028:	2f ed       	sub	sp,-8
8000702a:	c0 a8       	rjmp	8000703e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000702c:	2f f7       	sub	r7,-1
8000702e:	1a d8       	st.w	--sp,r8
80007030:	1a d6       	st.w	--sp,r6
80007032:	4a 1b       	lddpc	r11,800070b4 <logFromISR+0x168>
80007034:	0c 9c       	mov	r12,r6
80007036:	f0 1f 00 1f 	mcall	800070b0 <logFromISR+0x164>
8000703a:	08 95       	mov	r5,r4
8000703c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000703e:	0f 89       	ld.ub	r9,r7[0x0]
80007040:	30 08       	mov	r8,0
80007042:	f0 09 18 00 	cp.b	r9,r8
80007046:	c0 30       	breq	8000704c <logFromISR+0x100>
80007048:	0a 94       	mov	r4,r5
8000704a:	c9 8b       	rjmp	80006f7a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000704c:	fa c7 fe f4 	sub	r7,sp,-268
80007050:	1a d7       	st.w	--sp,r7
80007052:	49 ab       	lddpc	r11,800070b8 <logFromISR+0x16c>
80007054:	0e 9c       	mov	r12,r7
80007056:	f0 1f 00 17 	mcall	800070b0 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000705a:	5c 5c       	castu.b	r12
8000705c:	f8 c6 ff ff 	sub	r6,r12,-1
80007060:	0c 9c       	mov	r12,r6
80007062:	f0 1f 00 17 	mcall	800070bc <logFromISR+0x170>
80007066:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007068:	0c 9a       	mov	r10,r6
8000706a:	0e 9b       	mov	r11,r7
8000706c:	f0 1f 00 15 	mcall	800070c0 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007070:	30 09       	mov	r9,0
80007072:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007074:	fa ca fe f8 	sub	r10,sp,-264
80007078:	fa cb fe f4 	sub	r11,sp,-268
8000707c:	49 28       	lddpc	r8,800070c4 <logFromISR+0x178>
8000707e:	70 0c       	ld.w	r12,r8[0x0]
80007080:	f0 1f 00 12 	mcall	800070c8 <logFromISR+0x17c>
80007084:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007086:	fe 3d fd f4 	sub	sp,-524
8000708a:	d8 32       	popm	r0-r7,pc
8000708c:	80 00       	ld.sh	r0,r0[0x0]
8000708e:	77 84       	ld.w	r4,r11[0x60]
80007090:	00 00       	add	r0,r0
80007092:	0d 41       	ld.w	r1,--r6
80007094:	80 00       	ld.sh	r0,r0[0x0]
80007096:	d9 50       	acall	0x95
80007098:	80 00       	ld.sh	r0,r0[0x0]
8000709a:	6c e6       	ld.w	r6,r6[0x38]
8000709c:	80 00       	ld.sh	r0,r0[0x0]
8000709e:	6c 34       	ld.w	r4,r6[0xc]
800070a0:	80 00       	ld.sh	r0,r0[0x0]
800070a2:	6c 30       	ld.w	r0,r6[0xc]
800070a4:	80 00       	ld.sh	r0,r0[0x0]
800070a6:	da bc       	*unknown*
800070a8:	80 00       	ld.sh	r0,r0[0x0]
800070aa:	6d c0       	ld.w	r0,r6[0x70]
800070ac:	80 00       	ld.sh	r0,r0[0x0]
800070ae:	da cc       	*unknown*
800070b0:	80 00       	ld.sh	r0,r0[0x0]
800070b2:	7a 74       	ld.w	r4,sp[0x1c]
800070b4:	80 00       	ld.sh	r0,r0[0x0]
800070b6:	da d4       	*unknown*
800070b8:	80 00       	ld.sh	r0,r0[0x0]
800070ba:	da dc       	*unknown*
800070bc:	80 00       	ld.sh	r0,r0[0x0]
800070be:	5e 34       	retlo	r4
800070c0:	80 00       	ld.sh	r0,r0[0x0]
800070c2:	76 3c       	ld.w	r12,r11[0xc]
800070c4:	00 00       	add	r0,r0
800070c6:	b6 74       	st.h	r11[0xe],r4
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	61 38       	ld.w	r8,r0[0x4c]

800070cc <log_init>:
		
	return str;
}

void log_init(void)
{
800070cc:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800070ce:	30 2b       	mov	r11,2
800070d0:	48 fc       	lddpc	r12,8000710c <log_init+0x40>
800070d2:	f0 1f 00 10 	mcall	80007110 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800070d6:	e0 6a 36 00 	mov	r10,13824
800070da:	ea 1a 01 6e 	orh	r10,0x16e
800070de:	48 eb       	lddpc	r11,80007114 <log_init+0x48>
800070e0:	fe 7c 18 00 	mov	r12,-59392
800070e4:	f0 1f 00 0d 	mcall	80007118 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800070e8:	30 4b       	mov	r11,4
800070ea:	33 2c       	mov	r12,50
800070ec:	f0 1f 00 0c 	mcall	8000711c <log_init+0x50>
800070f0:	48 c8       	lddpc	r8,80007120 <log_init+0x54>
800070f2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800070f4:	30 09       	mov	r9,0
800070f6:	1a d9       	st.w	--sp,r9
800070f8:	1a d9       	st.w	--sp,r9
800070fa:	1a d9       	st.w	--sp,r9
800070fc:	30 28       	mov	r8,2
800070fe:	36 4a       	mov	r10,100
80007100:	48 9b       	lddpc	r11,80007124 <log_init+0x58>
80007102:	48 ac       	lddpc	r12,80007128 <log_init+0x5c>
80007104:	f0 1f 00 0a 	mcall	8000712c <log_init+0x60>
80007108:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000710a:	d8 02       	popm	pc
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	da e8       	*unknown*
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	53 14       	stdsp	sp[0xc4],r4
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	da a0       	acall	0xaa
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	59 98       	cp.w	r8,25
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	62 e0       	ld.w	r0,r1[0x38]
80007120:	00 00       	add	r0,r0
80007122:	b6 74       	st.h	r11[0xe],r4
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	da e4       	*unknown*
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	71 30       	ld.w	r0,r8[0x4c]
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	69 fc       	ld.w	r12,r4[0x7c]

80007130 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007130:	eb cd 40 f8 	pushm	r3-r7,lr
80007134:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007136:	48 c7       	lddpc	r7,80007164 <task_log+0x34>
80007138:	30 05       	mov	r5,0
8000713a:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000713c:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007140:	0a 99       	mov	r9,r5
80007142:	08 9a       	mov	r10,r4
80007144:	1a 9b       	mov	r11,sp
80007146:	6e 0c       	ld.w	r12,r7[0x0]
80007148:	f0 1f 00 08 	mcall	80007168 <task_log+0x38>
8000714c:	58 1c       	cp.w	r12,1
8000714e:	cf 91       	brne	80007140 <task_log+0x10>
		{
			if( NULL != str)
80007150:	40 0b       	lddsp	r11,sp[0x0]
80007152:	58 0b       	cp.w	r11,0
80007154:	cf 60       	breq	80007140 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007156:	06 9c       	mov	r12,r3
80007158:	f0 1f 00 05 	mcall	8000716c <task_log+0x3c>
				vPortFree(str);
8000715c:	40 0c       	lddsp	r12,sp[0x0]
8000715e:	f0 1f 00 05 	mcall	80007170 <task_log+0x40>
80007162:	ce fb       	rjmp	80007140 <task_log+0x10>
80007164:	00 00       	add	r0,r0
80007166:	b6 74       	st.h	r11[0xe],r4
80007168:	80 00       	ld.sh	r0,r0[0x0]
8000716a:	5f 7c       	srpl	r12
8000716c:	80 00       	ld.sh	r0,r0[0x0]
8000716e:	59 48       	cp.w	r8,20
80007170:	80 00       	ld.sh	r0,r0[0x0]
80007172:	5e 0c       	reteq	r12

80007174 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007174:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007176:	fe 78 10 00 	mov	r8,-61440
8000717a:	30 19       	mov	r9,1
8000717c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007180:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007184:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007188:	d3 03       	ssrf	0x10
	local_start_pll0();
8000718a:	f0 1f 00 0c 	mcall	800071b8 <main+0x44>
		
	INTC_init_interrupts();
8000718e:	f0 1f 00 0c 	mcall	800071bc <main+0x48>
		
	log_init();
80007192:	f0 1f 00 0c 	mcall	800071c0 <main+0x4c>
	log("----start debug----");
80007196:	48 cc       	lddpc	r12,800071c4 <main+0x50>
80007198:	f0 1f 00 0c 	mcall	800071c8 <main+0x54>
	
	xg_flashc_init();
8000719c:	f0 1f 00 0c 	mcall	800071cc <main+0x58>
	
	rfid_init();
800071a0:	f0 1f 00 0c 	mcall	800071d0 <main+0x5c>
		
	app_init();
800071a4:	f0 1f 00 0c 	mcall	800071d4 <main+0x60>
		
	xcmp_init();
800071a8:	f0 1f 00 0c 	mcall	800071d8 <main+0x64>

	local_start_timer();
800071ac:	f0 1f 00 0c 	mcall	800071dc <main+0x68>
		
	vTaskStartScheduler();
800071b0:	f0 1f 00 0c 	mcall	800071e0 <main+0x6c>
	return 0;
	
}
800071b4:	d8 0a       	popm	pc,r12=0
800071b6:	00 00       	add	r0,r0
800071b8:	80 00       	ld.sh	r0,r0[0x0]
800071ba:	51 90       	stdsp	sp[0x64],r0
800071bc:	80 00       	ld.sh	r0,r0[0x0]
800071be:	54 18       	stdsp	sp[0x104],r8
800071c0:	80 00       	ld.sh	r0,r0[0x0]
800071c2:	70 cc       	ld.w	r12,r8[0x30]
800071c4:	80 00       	ld.sh	r0,r0[0x0]
800071c6:	da f8       	*unknown*
800071c8:	80 00       	ld.sh	r0,r0[0x0]
800071ca:	6d c0       	ld.w	r0,r6[0x70]
800071cc:	80 00       	ld.sh	r0,r0[0x0]
800071ce:	52 24       	stdsp	sp[0x88],r4
800071d0:	80 00       	ld.sh	r0,r0[0x0]
800071d2:	50 f0       	stdsp	sp[0x3c],r0
800071d4:	80 00       	ld.sh	r0,r0[0x0]
800071d6:	27 44       	sub	r4,116
800071d8:	80 00       	ld.sh	r0,r0[0x0]
800071da:	3f a0       	mov	r0,-6
800071dc:	80 00       	ld.sh	r0,r0[0x0]
800071de:	51 64       	stdsp	sp[0x58],r4
800071e0:	80 00       	ld.sh	r0,r0[0x0]
800071e2:	6b e4       	ld.w	r4,r5[0x78]

800071e4 <free>:
800071e4:	d4 01       	pushm	lr
800071e6:	e0 68 0a 30 	mov	r8,2608
800071ea:	18 9b       	mov	r11,r12
800071ec:	70 0c       	ld.w	r12,r8[0x0]
800071ee:	e0 a0 1e 61 	rcall	8000aeb0 <_free_r>
800071f2:	d8 02       	popm	pc

800071f4 <malloc>:
800071f4:	d4 01       	pushm	lr
800071f6:	e0 68 0a 30 	mov	r8,2608
800071fa:	18 9b       	mov	r11,r12
800071fc:	70 0c       	ld.w	r12,r8[0x0]
800071fe:	c0 3c       	rcall	80007204 <_malloc_r>
80007200:	d8 02       	popm	pc
80007202:	d7 03       	nop

80007204 <_malloc_r>:
80007204:	d4 31       	pushm	r0-r7,lr
80007206:	f6 c8 ff f5 	sub	r8,r11,-11
8000720a:	18 95       	mov	r5,r12
8000720c:	10 97       	mov	r7,r8
8000720e:	e0 17 ff f8 	andl	r7,0xfff8
80007212:	59 68       	cp.w	r8,22
80007214:	f9 b7 08 10 	movls	r7,16
80007218:	16 37       	cp.w	r7,r11
8000721a:	5f 38       	srlo	r8
8000721c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007220:	c0 50       	breq	8000722a <_malloc_r+0x26>
80007222:	30 c8       	mov	r8,12
80007224:	99 38       	st.w	r12[0xc],r8
80007226:	e0 8f 01 fa 	bral	8000761a <_malloc_r+0x416>
8000722a:	fe b0 f5 a7 	rcall	80005d78 <__malloc_lock>
8000722e:	e0 47 01 f7 	cp.w	r7,503
80007232:	e0 8b 00 1d 	brhi	8000726c <_malloc_r+0x68>
80007236:	ee 03 16 03 	lsr	r3,r7,0x3
8000723a:	e0 68 05 30 	mov	r8,1328
8000723e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007242:	70 36       	ld.w	r6,r8[0xc]
80007244:	10 36       	cp.w	r6,r8
80007246:	c0 61       	brne	80007252 <_malloc_r+0x4e>
80007248:	ec c8 ff f8 	sub	r8,r6,-8
8000724c:	70 36       	ld.w	r6,r8[0xc]
8000724e:	10 36       	cp.w	r6,r8
80007250:	c0 c0       	breq	80007268 <_malloc_r+0x64>
80007252:	6c 18       	ld.w	r8,r6[0x4]
80007254:	e0 18 ff fc 	andl	r8,0xfffc
80007258:	6c 3a       	ld.w	r10,r6[0xc]
8000725a:	ec 08 00 09 	add	r9,r6,r8
8000725e:	0a 9c       	mov	r12,r5
80007260:	6c 28       	ld.w	r8,r6[0x8]
80007262:	95 28       	st.w	r10[0x8],r8
80007264:	91 3a       	st.w	r8[0xc],r10
80007266:	c4 78       	rjmp	800072f4 <_malloc_r+0xf0>
80007268:	2f e3       	sub	r3,-2
8000726a:	c4 d8       	rjmp	80007304 <_malloc_r+0x100>
8000726c:	ee 03 16 09 	lsr	r3,r7,0x9
80007270:	c0 41       	brne	80007278 <_malloc_r+0x74>
80007272:	ee 03 16 03 	lsr	r3,r7,0x3
80007276:	c2 68       	rjmp	800072c2 <_malloc_r+0xbe>
80007278:	58 43       	cp.w	r3,4
8000727a:	e0 8b 00 06 	brhi	80007286 <_malloc_r+0x82>
8000727e:	ee 03 16 06 	lsr	r3,r7,0x6
80007282:	2c 83       	sub	r3,-56
80007284:	c1 f8       	rjmp	800072c2 <_malloc_r+0xbe>
80007286:	59 43       	cp.w	r3,20
80007288:	e0 8b 00 04 	brhi	80007290 <_malloc_r+0x8c>
8000728c:	2a 53       	sub	r3,-91
8000728e:	c1 a8       	rjmp	800072c2 <_malloc_r+0xbe>
80007290:	e0 43 00 54 	cp.w	r3,84
80007294:	e0 8b 00 06 	brhi	800072a0 <_malloc_r+0x9c>
80007298:	ee 03 16 0c 	lsr	r3,r7,0xc
8000729c:	29 23       	sub	r3,-110
8000729e:	c1 28       	rjmp	800072c2 <_malloc_r+0xbe>
800072a0:	e0 43 01 54 	cp.w	r3,340
800072a4:	e0 8b 00 06 	brhi	800072b0 <_malloc_r+0xac>
800072a8:	ee 03 16 0f 	lsr	r3,r7,0xf
800072ac:	28 93       	sub	r3,-119
800072ae:	c0 a8       	rjmp	800072c2 <_malloc_r+0xbe>
800072b0:	e0 43 05 54 	cp.w	r3,1364
800072b4:	e0 88 00 04 	brls	800072bc <_malloc_r+0xb8>
800072b8:	37 e3       	mov	r3,126
800072ba:	c0 48       	rjmp	800072c2 <_malloc_r+0xbe>
800072bc:	ee 03 16 12 	lsr	r3,r7,0x12
800072c0:	28 43       	sub	r3,-124
800072c2:	e0 6a 05 30 	mov	r10,1328
800072c6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800072ca:	74 36       	ld.w	r6,r10[0xc]
800072cc:	c1 98       	rjmp	800072fe <_malloc_r+0xfa>
800072ce:	6c 19       	ld.w	r9,r6[0x4]
800072d0:	e0 19 ff fc 	andl	r9,0xfffc
800072d4:	f2 07 01 0b 	sub	r11,r9,r7
800072d8:	58 fb       	cp.w	r11,15
800072da:	e0 8a 00 04 	brle	800072e2 <_malloc_r+0xde>
800072de:	20 13       	sub	r3,1
800072e0:	c1 18       	rjmp	80007302 <_malloc_r+0xfe>
800072e2:	6c 38       	ld.w	r8,r6[0xc]
800072e4:	58 0b       	cp.w	r11,0
800072e6:	c0 b5       	brlt	800072fc <_malloc_r+0xf8>
800072e8:	6c 2a       	ld.w	r10,r6[0x8]
800072ea:	ec 09 00 09 	add	r9,r6,r9
800072ee:	0a 9c       	mov	r12,r5
800072f0:	91 2a       	st.w	r8[0x8],r10
800072f2:	95 38       	st.w	r10[0xc],r8
800072f4:	72 18       	ld.w	r8,r9[0x4]
800072f6:	a1 a8       	sbr	r8,0x0
800072f8:	93 18       	st.w	r9[0x4],r8
800072fa:	cb c8       	rjmp	80007472 <_malloc_r+0x26e>
800072fc:	10 96       	mov	r6,r8
800072fe:	14 36       	cp.w	r6,r10
80007300:	ce 71       	brne	800072ce <_malloc_r+0xca>
80007302:	2f f3       	sub	r3,-1
80007304:	e0 6a 05 30 	mov	r10,1328
80007308:	f4 cc ff f8 	sub	r12,r10,-8
8000730c:	78 26       	ld.w	r6,r12[0x8]
8000730e:	18 36       	cp.w	r6,r12
80007310:	c6 c0       	breq	800073e8 <_malloc_r+0x1e4>
80007312:	6c 19       	ld.w	r9,r6[0x4]
80007314:	e0 19 ff fc 	andl	r9,0xfffc
80007318:	f2 07 01 08 	sub	r8,r9,r7
8000731c:	58 f8       	cp.w	r8,15
8000731e:	e0 89 00 8f 	brgt	8000743c <_malloc_r+0x238>
80007322:	99 3c       	st.w	r12[0xc],r12
80007324:	99 2c       	st.w	r12[0x8],r12
80007326:	58 08       	cp.w	r8,0
80007328:	c0 55       	brlt	80007332 <_malloc_r+0x12e>
8000732a:	ec 09 00 09 	add	r9,r6,r9
8000732e:	0a 9c       	mov	r12,r5
80007330:	ce 2b       	rjmp	800072f4 <_malloc_r+0xf0>
80007332:	e0 49 01 ff 	cp.w	r9,511
80007336:	e0 8b 00 13 	brhi	8000735c <_malloc_r+0x158>
8000733a:	a3 99       	lsr	r9,0x3
8000733c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007340:	70 2b       	ld.w	r11,r8[0x8]
80007342:	8d 38       	st.w	r6[0xc],r8
80007344:	8d 2b       	st.w	r6[0x8],r11
80007346:	97 36       	st.w	r11[0xc],r6
80007348:	91 26       	st.w	r8[0x8],r6
8000734a:	a3 49       	asr	r9,0x2
8000734c:	74 18       	ld.w	r8,r10[0x4]
8000734e:	30 1b       	mov	r11,1
80007350:	f6 09 09 49 	lsl	r9,r11,r9
80007354:	f1 e9 10 09 	or	r9,r8,r9
80007358:	95 19       	st.w	r10[0x4],r9
8000735a:	c4 78       	rjmp	800073e8 <_malloc_r+0x1e4>
8000735c:	f2 0a 16 09 	lsr	r10,r9,0x9
80007360:	58 4a       	cp.w	r10,4
80007362:	e0 8b 00 07 	brhi	80007370 <_malloc_r+0x16c>
80007366:	f2 0a 16 06 	lsr	r10,r9,0x6
8000736a:	2c 8a       	sub	r10,-56
8000736c:	c2 08       	rjmp	800073ac <_malloc_r+0x1a8>
8000736e:	d7 03       	nop
80007370:	59 4a       	cp.w	r10,20
80007372:	e0 8b 00 04 	brhi	8000737a <_malloc_r+0x176>
80007376:	2a 5a       	sub	r10,-91
80007378:	c1 a8       	rjmp	800073ac <_malloc_r+0x1a8>
8000737a:	e0 4a 00 54 	cp.w	r10,84
8000737e:	e0 8b 00 06 	brhi	8000738a <_malloc_r+0x186>
80007382:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007386:	29 2a       	sub	r10,-110
80007388:	c1 28       	rjmp	800073ac <_malloc_r+0x1a8>
8000738a:	e0 4a 01 54 	cp.w	r10,340
8000738e:	e0 8b 00 06 	brhi	8000739a <_malloc_r+0x196>
80007392:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007396:	28 9a       	sub	r10,-119
80007398:	c0 a8       	rjmp	800073ac <_malloc_r+0x1a8>
8000739a:	e0 4a 05 54 	cp.w	r10,1364
8000739e:	e0 88 00 04 	brls	800073a6 <_malloc_r+0x1a2>
800073a2:	37 ea       	mov	r10,126
800073a4:	c0 48       	rjmp	800073ac <_malloc_r+0x1a8>
800073a6:	f2 0a 16 12 	lsr	r10,r9,0x12
800073aa:	28 4a       	sub	r10,-124
800073ac:	e0 6b 05 30 	mov	r11,1328
800073b0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800073b4:	68 28       	ld.w	r8,r4[0x8]
800073b6:	08 38       	cp.w	r8,r4
800073b8:	c0 e1       	brne	800073d4 <_malloc_r+0x1d0>
800073ba:	76 19       	ld.w	r9,r11[0x4]
800073bc:	a3 4a       	asr	r10,0x2
800073be:	30 1e       	mov	lr,1
800073c0:	fc 0a 09 4a 	lsl	r10,lr,r10
800073c4:	f3 ea 10 0a 	or	r10,r9,r10
800073c8:	10 99       	mov	r9,r8
800073ca:	97 1a       	st.w	r11[0x4],r10
800073cc:	c0 a8       	rjmp	800073e0 <_malloc_r+0x1dc>
800073ce:	70 28       	ld.w	r8,r8[0x8]
800073d0:	08 38       	cp.w	r8,r4
800073d2:	c0 60       	breq	800073de <_malloc_r+0x1da>
800073d4:	70 1a       	ld.w	r10,r8[0x4]
800073d6:	e0 1a ff fc 	andl	r10,0xfffc
800073da:	14 39       	cp.w	r9,r10
800073dc:	cf 93       	brcs	800073ce <_malloc_r+0x1ca>
800073de:	70 39       	ld.w	r9,r8[0xc]
800073e0:	8d 39       	st.w	r6[0xc],r9
800073e2:	8d 28       	st.w	r6[0x8],r8
800073e4:	91 36       	st.w	r8[0xc],r6
800073e6:	93 26       	st.w	r9[0x8],r6
800073e8:	e6 08 14 02 	asr	r8,r3,0x2
800073ec:	30 1b       	mov	r11,1
800073ee:	e0 64 05 30 	mov	r4,1328
800073f2:	f6 08 09 4b 	lsl	r11,r11,r8
800073f6:	68 18       	ld.w	r8,r4[0x4]
800073f8:	10 3b       	cp.w	r11,r8
800073fa:	e0 8b 00 6b 	brhi	800074d0 <_malloc_r+0x2cc>
800073fe:	f7 e8 00 09 	and	r9,r11,r8
80007402:	c0 b1       	brne	80007418 <_malloc_r+0x214>
80007404:	e0 13 ff fc 	andl	r3,0xfffc
80007408:	a1 7b       	lsl	r11,0x1
8000740a:	2f c3       	sub	r3,-4
8000740c:	c0 38       	rjmp	80007412 <_malloc_r+0x20e>
8000740e:	2f c3       	sub	r3,-4
80007410:	a1 7b       	lsl	r11,0x1
80007412:	f7 e8 00 09 	and	r9,r11,r8
80007416:	cf c0       	breq	8000740e <_malloc_r+0x20a>
80007418:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000741c:	06 92       	mov	r2,r3
8000741e:	1c 91       	mov	r1,lr
80007420:	62 36       	ld.w	r6,r1[0xc]
80007422:	c2 e8       	rjmp	8000747e <_malloc_r+0x27a>
80007424:	6c 1a       	ld.w	r10,r6[0x4]
80007426:	e0 1a ff fc 	andl	r10,0xfffc
8000742a:	f4 07 01 08 	sub	r8,r10,r7
8000742e:	58 f8       	cp.w	r8,15
80007430:	e0 8a 00 15 	brle	8000745a <_malloc_r+0x256>
80007434:	6c 3a       	ld.w	r10,r6[0xc]
80007436:	6c 29       	ld.w	r9,r6[0x8]
80007438:	95 29       	st.w	r10[0x8],r9
8000743a:	93 3a       	st.w	r9[0xc],r10
8000743c:	0e 99       	mov	r9,r7
8000743e:	ec 07 00 07 	add	r7,r6,r7
80007442:	a1 a9       	sbr	r9,0x0
80007444:	99 37       	st.w	r12[0xc],r7
80007446:	99 27       	st.w	r12[0x8],r7
80007448:	8d 19       	st.w	r6[0x4],r9
8000744a:	ee 08 09 08 	st.w	r7[r8],r8
8000744e:	8f 2c       	st.w	r7[0x8],r12
80007450:	8f 3c       	st.w	r7[0xc],r12
80007452:	a1 a8       	sbr	r8,0x0
80007454:	0a 9c       	mov	r12,r5
80007456:	8f 18       	st.w	r7[0x4],r8
80007458:	c0 d8       	rjmp	80007472 <_malloc_r+0x26e>
8000745a:	6c 39       	ld.w	r9,r6[0xc]
8000745c:	58 08       	cp.w	r8,0
8000745e:	c0 f5       	brlt	8000747c <_malloc_r+0x278>
80007460:	ec 0a 00 0a 	add	r10,r6,r10
80007464:	74 18       	ld.w	r8,r10[0x4]
80007466:	a1 a8       	sbr	r8,0x0
80007468:	0a 9c       	mov	r12,r5
8000746a:	95 18       	st.w	r10[0x4],r8
8000746c:	6c 28       	ld.w	r8,r6[0x8]
8000746e:	93 28       	st.w	r9[0x8],r8
80007470:	91 39       	st.w	r8[0xc],r9
80007472:	fe b0 f4 89 	rcall	80005d84 <__malloc_unlock>
80007476:	ec cc ff f8 	sub	r12,r6,-8
8000747a:	d8 32       	popm	r0-r7,pc
8000747c:	12 96       	mov	r6,r9
8000747e:	02 36       	cp.w	r6,r1
80007480:	cd 21       	brne	80007424 <_malloc_r+0x220>
80007482:	2f f2       	sub	r2,-1
80007484:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007488:	c0 30       	breq	8000748e <_malloc_r+0x28a>
8000748a:	2f 81       	sub	r1,-8
8000748c:	cc ab       	rjmp	80007420 <_malloc_r+0x21c>
8000748e:	1c 98       	mov	r8,lr
80007490:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007494:	c0 81       	brne	800074a4 <_malloc_r+0x2a0>
80007496:	68 19       	ld.w	r9,r4[0x4]
80007498:	f6 08 11 ff 	rsub	r8,r11,-1
8000749c:	f3 e8 00 08 	and	r8,r9,r8
800074a0:	89 18       	st.w	r4[0x4],r8
800074a2:	c0 78       	rjmp	800074b0 <_malloc_r+0x2ac>
800074a4:	f0 c9 00 08 	sub	r9,r8,8
800074a8:	20 13       	sub	r3,1
800074aa:	70 08       	ld.w	r8,r8[0x0]
800074ac:	12 38       	cp.w	r8,r9
800074ae:	cf 10       	breq	80007490 <_malloc_r+0x28c>
800074b0:	a1 7b       	lsl	r11,0x1
800074b2:	68 18       	ld.w	r8,r4[0x4]
800074b4:	10 3b       	cp.w	r11,r8
800074b6:	e0 8b 00 0d 	brhi	800074d0 <_malloc_r+0x2cc>
800074ba:	58 0b       	cp.w	r11,0
800074bc:	c0 a0       	breq	800074d0 <_malloc_r+0x2cc>
800074be:	04 93       	mov	r3,r2
800074c0:	c0 38       	rjmp	800074c6 <_malloc_r+0x2c2>
800074c2:	2f c3       	sub	r3,-4
800074c4:	a1 7b       	lsl	r11,0x1
800074c6:	f7 e8 00 09 	and	r9,r11,r8
800074ca:	ca 71       	brne	80007418 <_malloc_r+0x214>
800074cc:	cf bb       	rjmp	800074c2 <_malloc_r+0x2be>
800074ce:	d7 03       	nop
800074d0:	68 23       	ld.w	r3,r4[0x8]
800074d2:	66 12       	ld.w	r2,r3[0x4]
800074d4:	e0 12 ff fc 	andl	r2,0xfffc
800074d8:	0e 32       	cp.w	r2,r7
800074da:	5f 39       	srlo	r9
800074dc:	e4 07 01 08 	sub	r8,r2,r7
800074e0:	58 f8       	cp.w	r8,15
800074e2:	5f aa       	srle	r10
800074e4:	f5 e9 10 09 	or	r9,r10,r9
800074e8:	e0 80 00 9a 	breq	8000761c <_malloc_r+0x418>
800074ec:	e0 68 0d 4c 	mov	r8,3404
800074f0:	70 01       	ld.w	r1,r8[0x0]
800074f2:	e0 68 09 3c 	mov	r8,2364
800074f6:	2f 01       	sub	r1,-16
800074f8:	70 08       	ld.w	r8,r8[0x0]
800074fa:	0e 01       	add	r1,r7
800074fc:	5b f8       	cp.w	r8,-1
800074fe:	c0 40       	breq	80007506 <_malloc_r+0x302>
80007500:	28 11       	sub	r1,-127
80007502:	e0 11 ff 80 	andl	r1,0xff80
80007506:	02 9b       	mov	r11,r1
80007508:	0a 9c       	mov	r12,r5
8000750a:	e0 a0 02 a5 	rcall	80007a54 <_sbrk_r>
8000750e:	18 96       	mov	r6,r12
80007510:	5b fc       	cp.w	r12,-1
80007512:	c7 50       	breq	800075fc <_malloc_r+0x3f8>
80007514:	e6 02 00 08 	add	r8,r3,r2
80007518:	10 3c       	cp.w	r12,r8
8000751a:	c0 32       	brcc	80007520 <_malloc_r+0x31c>
8000751c:	08 33       	cp.w	r3,r4
8000751e:	c6 f1       	brne	800075fc <_malloc_r+0x3f8>
80007520:	e0 6a 0d 50 	mov	r10,3408
80007524:	74 09       	ld.w	r9,r10[0x0]
80007526:	e2 09 00 09 	add	r9,r1,r9
8000752a:	95 09       	st.w	r10[0x0],r9
8000752c:	10 36       	cp.w	r6,r8
8000752e:	c0 a1       	brne	80007542 <_malloc_r+0x33e>
80007530:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007534:	c0 71       	brne	80007542 <_malloc_r+0x33e>
80007536:	e2 02 00 02 	add	r2,r1,r2
8000753a:	68 28       	ld.w	r8,r4[0x8]
8000753c:	a1 a2       	sbr	r2,0x0
8000753e:	91 12       	st.w	r8[0x4],r2
80007540:	c4 f8       	rjmp	800075de <_malloc_r+0x3da>
80007542:	e0 6a 09 3c 	mov	r10,2364
80007546:	74 0b       	ld.w	r11,r10[0x0]
80007548:	5b fb       	cp.w	r11,-1
8000754a:	c0 31       	brne	80007550 <_malloc_r+0x34c>
8000754c:	95 06       	st.w	r10[0x0],r6
8000754e:	c0 78       	rjmp	8000755c <_malloc_r+0x358>
80007550:	ec 09 00 09 	add	r9,r6,r9
80007554:	e0 6a 0d 50 	mov	r10,3408
80007558:	10 19       	sub	r9,r8
8000755a:	95 09       	st.w	r10[0x0],r9
8000755c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007560:	f0 09 11 08 	rsub	r9,r8,8
80007564:	58 08       	cp.w	r8,0
80007566:	f2 08 17 10 	movne	r8,r9
8000756a:	ed d8 e1 06 	addne	r6,r6,r8
8000756e:	28 08       	sub	r8,-128
80007570:	ec 01 00 01 	add	r1,r6,r1
80007574:	0a 9c       	mov	r12,r5
80007576:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000757a:	f0 01 01 01 	sub	r1,r8,r1
8000757e:	02 9b       	mov	r11,r1
80007580:	e0 a0 02 6a 	rcall	80007a54 <_sbrk_r>
80007584:	e0 68 0d 50 	mov	r8,3408
80007588:	5b fc       	cp.w	r12,-1
8000758a:	ec 0c 17 00 	moveq	r12,r6
8000758e:	f9 b1 00 00 	moveq	r1,0
80007592:	70 09       	ld.w	r9,r8[0x0]
80007594:	0c 1c       	sub	r12,r6
80007596:	89 26       	st.w	r4[0x8],r6
80007598:	02 0c       	add	r12,r1
8000759a:	12 01       	add	r1,r9
8000759c:	a1 ac       	sbr	r12,0x0
8000759e:	91 01       	st.w	r8[0x0],r1
800075a0:	8d 1c       	st.w	r6[0x4],r12
800075a2:	08 33       	cp.w	r3,r4
800075a4:	c1 d0       	breq	800075de <_malloc_r+0x3da>
800075a6:	58 f2       	cp.w	r2,15
800075a8:	e0 8b 00 05 	brhi	800075b2 <_malloc_r+0x3ae>
800075ac:	30 18       	mov	r8,1
800075ae:	8d 18       	st.w	r6[0x4],r8
800075b0:	c2 68       	rjmp	800075fc <_malloc_r+0x3f8>
800075b2:	30 59       	mov	r9,5
800075b4:	20 c2       	sub	r2,12
800075b6:	e0 12 ff f8 	andl	r2,0xfff8
800075ba:	e6 02 00 08 	add	r8,r3,r2
800075be:	91 29       	st.w	r8[0x8],r9
800075c0:	91 19       	st.w	r8[0x4],r9
800075c2:	66 18       	ld.w	r8,r3[0x4]
800075c4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800075c8:	e5 e8 10 08 	or	r8,r2,r8
800075cc:	87 18       	st.w	r3[0x4],r8
800075ce:	58 f2       	cp.w	r2,15
800075d0:	e0 88 00 07 	brls	800075de <_malloc_r+0x3da>
800075d4:	e6 cb ff f8 	sub	r11,r3,-8
800075d8:	0a 9c       	mov	r12,r5
800075da:	e0 a0 1c 6b 	rcall	8000aeb0 <_free_r>
800075de:	e0 69 0d 48 	mov	r9,3400
800075e2:	72 0a       	ld.w	r10,r9[0x0]
800075e4:	e0 68 0d 50 	mov	r8,3408
800075e8:	70 08       	ld.w	r8,r8[0x0]
800075ea:	14 38       	cp.w	r8,r10
800075ec:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800075f0:	e0 69 0d 44 	mov	r9,3396
800075f4:	72 0a       	ld.w	r10,r9[0x0]
800075f6:	14 38       	cp.w	r8,r10
800075f8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800075fc:	68 28       	ld.w	r8,r4[0x8]
800075fe:	70 18       	ld.w	r8,r8[0x4]
80007600:	e0 18 ff fc 	andl	r8,0xfffc
80007604:	0e 38       	cp.w	r8,r7
80007606:	5f 39       	srlo	r9
80007608:	0e 18       	sub	r8,r7
8000760a:	58 f8       	cp.w	r8,15
8000760c:	5f aa       	srle	r10
8000760e:	f5 e9 10 09 	or	r9,r10,r9
80007612:	c0 50       	breq	8000761c <_malloc_r+0x418>
80007614:	0a 9c       	mov	r12,r5
80007616:	fe b0 f3 b7 	rcall	80005d84 <__malloc_unlock>
8000761a:	d8 3a       	popm	r0-r7,pc,r12=0
8000761c:	68 26       	ld.w	r6,r4[0x8]
8000761e:	a1 a8       	sbr	r8,0x0
80007620:	0e 99       	mov	r9,r7
80007622:	a1 a9       	sbr	r9,0x0
80007624:	8d 19       	st.w	r6[0x4],r9
80007626:	ec 07 00 07 	add	r7,r6,r7
8000762a:	0a 9c       	mov	r12,r5
8000762c:	89 27       	st.w	r4[0x8],r7
8000762e:	8f 18       	st.w	r7[0x4],r8
80007630:	fe b0 f3 aa 	rcall	80005d84 <__malloc_unlock>
80007634:	ec cc ff f8 	sub	r12,r6,-8
80007638:	d8 32       	popm	r0-r7,pc
8000763a:	d7 03       	nop

8000763c <memcpy>:
8000763c:	58 8a       	cp.w	r10,8
8000763e:	c2 f5       	brlt	8000769c <memcpy+0x60>
80007640:	f9 eb 10 09 	or	r9,r12,r11
80007644:	e2 19 00 03 	andl	r9,0x3,COH
80007648:	e0 81 00 97 	brne	80007776 <memcpy+0x13a>
8000764c:	e0 4a 00 20 	cp.w	r10,32
80007650:	c3 b4       	brge	800076c6 <memcpy+0x8a>
80007652:	f4 08 14 02 	asr	r8,r10,0x2
80007656:	f0 09 11 08 	rsub	r9,r8,8
8000765a:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000765e:	76 69       	ld.w	r9,r11[0x18]
80007660:	99 69       	st.w	r12[0x18],r9
80007662:	76 59       	ld.w	r9,r11[0x14]
80007664:	99 59       	st.w	r12[0x14],r9
80007666:	76 49       	ld.w	r9,r11[0x10]
80007668:	99 49       	st.w	r12[0x10],r9
8000766a:	76 39       	ld.w	r9,r11[0xc]
8000766c:	99 39       	st.w	r12[0xc],r9
8000766e:	76 29       	ld.w	r9,r11[0x8]
80007670:	99 29       	st.w	r12[0x8],r9
80007672:	76 19       	ld.w	r9,r11[0x4]
80007674:	99 19       	st.w	r12[0x4],r9
80007676:	76 09       	ld.w	r9,r11[0x0]
80007678:	99 09       	st.w	r12[0x0],r9
8000767a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000767e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007682:	e0 1a 00 03 	andl	r10,0x3
80007686:	f4 0a 11 04 	rsub	r10,r10,4
8000768a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000768e:	17 a9       	ld.ub	r9,r11[0x2]
80007690:	b0 a9       	st.b	r8[0x2],r9
80007692:	17 99       	ld.ub	r9,r11[0x1]
80007694:	b0 99       	st.b	r8[0x1],r9
80007696:	17 89       	ld.ub	r9,r11[0x0]
80007698:	b0 89       	st.b	r8[0x0],r9
8000769a:	5e fc       	retal	r12
8000769c:	f4 0a 11 09 	rsub	r10,r10,9
800076a0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800076a4:	17 f9       	ld.ub	r9,r11[0x7]
800076a6:	b8 f9       	st.b	r12[0x7],r9
800076a8:	17 e9       	ld.ub	r9,r11[0x6]
800076aa:	b8 e9       	st.b	r12[0x6],r9
800076ac:	17 d9       	ld.ub	r9,r11[0x5]
800076ae:	b8 d9       	st.b	r12[0x5],r9
800076b0:	17 c9       	ld.ub	r9,r11[0x4]
800076b2:	b8 c9       	st.b	r12[0x4],r9
800076b4:	17 b9       	ld.ub	r9,r11[0x3]
800076b6:	b8 b9       	st.b	r12[0x3],r9
800076b8:	17 a9       	ld.ub	r9,r11[0x2]
800076ba:	b8 a9       	st.b	r12[0x2],r9
800076bc:	17 99       	ld.ub	r9,r11[0x1]
800076be:	b8 99       	st.b	r12[0x1],r9
800076c0:	17 89       	ld.ub	r9,r11[0x0]
800076c2:	b8 89       	st.b	r12[0x0],r9
800076c4:	5e fc       	retal	r12
800076c6:	eb cd 40 c0 	pushm	r6-r7,lr
800076ca:	18 99       	mov	r9,r12
800076cc:	22 0a       	sub	r10,32
800076ce:	b7 07       	ld.d	r6,r11++
800076d0:	b3 26       	st.d	r9++,r6
800076d2:	b7 07       	ld.d	r6,r11++
800076d4:	b3 26       	st.d	r9++,r6
800076d6:	b7 07       	ld.d	r6,r11++
800076d8:	b3 26       	st.d	r9++,r6
800076da:	b7 07       	ld.d	r6,r11++
800076dc:	b3 26       	st.d	r9++,r6
800076de:	22 0a       	sub	r10,32
800076e0:	cf 74       	brge	800076ce <memcpy+0x92>
800076e2:	2f 0a       	sub	r10,-16
800076e4:	c0 65       	brlt	800076f0 <memcpy+0xb4>
800076e6:	b7 07       	ld.d	r6,r11++
800076e8:	b3 26       	st.d	r9++,r6
800076ea:	b7 07       	ld.d	r6,r11++
800076ec:	b3 26       	st.d	r9++,r6
800076ee:	21 0a       	sub	r10,16
800076f0:	5c 3a       	neg	r10
800076f2:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800076f6:	d7 03       	nop
800076f8:	d7 03       	nop
800076fa:	f7 36 00 0e 	ld.ub	r6,r11[14]
800076fe:	f3 66 00 0e 	st.b	r9[14],r6
80007702:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007706:	f3 66 00 0d 	st.b	r9[13],r6
8000770a:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000770e:	f3 66 00 0c 	st.b	r9[12],r6
80007712:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007716:	f3 66 00 0b 	st.b	r9[11],r6
8000771a:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000771e:	f3 66 00 0a 	st.b	r9[10],r6
80007722:	f7 36 00 09 	ld.ub	r6,r11[9]
80007726:	f3 66 00 09 	st.b	r9[9],r6
8000772a:	f7 36 00 08 	ld.ub	r6,r11[8]
8000772e:	f3 66 00 08 	st.b	r9[8],r6
80007732:	f7 36 00 07 	ld.ub	r6,r11[7]
80007736:	f3 66 00 07 	st.b	r9[7],r6
8000773a:	f7 36 00 06 	ld.ub	r6,r11[6]
8000773e:	f3 66 00 06 	st.b	r9[6],r6
80007742:	f7 36 00 05 	ld.ub	r6,r11[5]
80007746:	f3 66 00 05 	st.b	r9[5],r6
8000774a:	f7 36 00 04 	ld.ub	r6,r11[4]
8000774e:	f3 66 00 04 	st.b	r9[4],r6
80007752:	f7 36 00 03 	ld.ub	r6,r11[3]
80007756:	f3 66 00 03 	st.b	r9[3],r6
8000775a:	f7 36 00 02 	ld.ub	r6,r11[2]
8000775e:	f3 66 00 02 	st.b	r9[2],r6
80007762:	f7 36 00 01 	ld.ub	r6,r11[1]
80007766:	f3 66 00 01 	st.b	r9[1],r6
8000776a:	f7 36 00 00 	ld.ub	r6,r11[0]
8000776e:	f3 66 00 00 	st.b	r9[0],r6
80007772:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007776:	20 1a       	sub	r10,1
80007778:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000777c:	f8 0a 0b 09 	st.b	r12[r10],r9
80007780:	cf b1       	brne	80007776 <memcpy+0x13a>
80007782:	5e fc       	retal	r12

80007784 <memset>:
80007784:	18 98       	mov	r8,r12
80007786:	c0 38       	rjmp	8000778c <memset+0x8>
80007788:	10 cb       	st.b	r8++,r11
8000778a:	20 1a       	sub	r10,1
8000778c:	58 0a       	cp.w	r10,0
8000778e:	cf d1       	brne	80007788 <memset+0x4>
80007790:	5e fc       	retal	r12
80007792:	d7 03       	nop

80007794 <_realloc_r>:
80007794:	d4 31       	pushm	r0-r7,lr
80007796:	20 1d       	sub	sp,4
80007798:	16 94       	mov	r4,r11
8000779a:	18 92       	mov	r2,r12
8000779c:	14 9b       	mov	r11,r10
8000779e:	58 04       	cp.w	r4,0
800077a0:	c0 51       	brne	800077aa <_realloc_r+0x16>
800077a2:	fe b0 fd 31 	rcall	80007204 <_malloc_r>
800077a6:	18 95       	mov	r5,r12
800077a8:	c5 39       	rjmp	80007a4e <_realloc_r+0x2ba>
800077aa:	50 0a       	stdsp	sp[0x0],r10
800077ac:	fe b0 f2 e6 	rcall	80005d78 <__malloc_lock>
800077b0:	40 0b       	lddsp	r11,sp[0x0]
800077b2:	f6 c8 ff f5 	sub	r8,r11,-11
800077b6:	e8 c1 00 08 	sub	r1,r4,8
800077ba:	10 96       	mov	r6,r8
800077bc:	62 1c       	ld.w	r12,r1[0x4]
800077be:	e0 16 ff f8 	andl	r6,0xfff8
800077c2:	59 68       	cp.w	r8,22
800077c4:	f9 b6 08 10 	movls	r6,16
800077c8:	16 36       	cp.w	r6,r11
800077ca:	5f 38       	srlo	r8
800077cc:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800077d0:	c0 50       	breq	800077da <_realloc_r+0x46>
800077d2:	30 c8       	mov	r8,12
800077d4:	30 05       	mov	r5,0
800077d6:	85 38       	st.w	r2[0xc],r8
800077d8:	c3 b9       	rjmp	80007a4e <_realloc_r+0x2ba>
800077da:	18 90       	mov	r0,r12
800077dc:	e0 10 ff fc 	andl	r0,0xfffc
800077e0:	0c 30       	cp.w	r0,r6
800077e2:	e0 84 01 0b 	brge	800079f8 <_realloc_r+0x264>
800077e6:	e0 68 05 30 	mov	r8,1328
800077ea:	e2 00 00 09 	add	r9,r1,r0
800077ee:	70 25       	ld.w	r5,r8[0x8]
800077f0:	0a 39       	cp.w	r9,r5
800077f2:	c0 90       	breq	80007804 <_realloc_r+0x70>
800077f4:	72 1a       	ld.w	r10,r9[0x4]
800077f6:	a1 ca       	cbr	r10,0x0
800077f8:	f2 0a 00 0a 	add	r10,r9,r10
800077fc:	74 1a       	ld.w	r10,r10[0x4]
800077fe:	ed ba 00 00 	bld	r10,0x0
80007802:	c2 20       	breq	80007846 <_realloc_r+0xb2>
80007804:	72 1a       	ld.w	r10,r9[0x4]
80007806:	e0 1a ff fc 	andl	r10,0xfffc
8000780a:	f4 00 00 03 	add	r3,r10,r0
8000780e:	0a 39       	cp.w	r9,r5
80007810:	c1 31       	brne	80007836 <_realloc_r+0xa2>
80007812:	ec c7 ff f0 	sub	r7,r6,-16
80007816:	0e 33       	cp.w	r3,r7
80007818:	c1 95       	brlt	8000784a <_realloc_r+0xb6>
8000781a:	e2 06 00 09 	add	r9,r1,r6
8000781e:	0c 13       	sub	r3,r6
80007820:	a1 a3       	sbr	r3,0x0
80007822:	93 13       	st.w	r9[0x4],r3
80007824:	91 29       	st.w	r8[0x8],r9
80007826:	04 9c       	mov	r12,r2
80007828:	62 18       	ld.w	r8,r1[0x4]
8000782a:	08 95       	mov	r5,r4
8000782c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007830:	10 46       	or	r6,r8
80007832:	83 16       	st.w	r1[0x4],r6
80007834:	c0 b9       	rjmp	80007a4a <_realloc_r+0x2b6>
80007836:	0c 33       	cp.w	r3,r6
80007838:	c0 95       	brlt	8000784a <_realloc_r+0xb6>
8000783a:	72 28       	ld.w	r8,r9[0x8]
8000783c:	02 97       	mov	r7,r1
8000783e:	72 39       	ld.w	r9,r9[0xc]
80007840:	93 28       	st.w	r9[0x8],r8
80007842:	91 39       	st.w	r8[0xc],r9
80007844:	cd c8       	rjmp	800079fc <_realloc_r+0x268>
80007846:	30 0a       	mov	r10,0
80007848:	14 99       	mov	r9,r10
8000784a:	ed bc 00 00 	bld	r12,0x0
8000784e:	e0 80 00 95 	breq	80007978 <_realloc_r+0x1e4>
80007852:	62 07       	ld.w	r7,r1[0x0]
80007854:	e2 07 01 07 	sub	r7,r1,r7
80007858:	6e 1c       	ld.w	r12,r7[0x4]
8000785a:	e0 1c ff fc 	andl	r12,0xfffc
8000785e:	58 09       	cp.w	r9,0
80007860:	c5 60       	breq	8000790c <_realloc_r+0x178>
80007862:	f8 00 00 03 	add	r3,r12,r0
80007866:	0a 39       	cp.w	r9,r5
80007868:	c4 81       	brne	800078f8 <_realloc_r+0x164>
8000786a:	14 03       	add	r3,r10
8000786c:	ec c9 ff f0 	sub	r9,r6,-16
80007870:	12 33       	cp.w	r3,r9
80007872:	c4 d5       	brlt	8000790c <_realloc_r+0x178>
80007874:	6e 3a       	ld.w	r10,r7[0xc]
80007876:	6e 29       	ld.w	r9,r7[0x8]
80007878:	95 29       	st.w	r10[0x8],r9
8000787a:	93 3a       	st.w	r9[0xc],r10
8000787c:	ee c5 ff f8 	sub	r5,r7,-8
80007880:	e0 ca 00 04 	sub	r10,r0,4
80007884:	e0 4a 00 24 	cp.w	r10,36
80007888:	e0 8b 00 25 	brhi	800078d2 <_realloc_r+0x13e>
8000788c:	0a 99       	mov	r9,r5
8000788e:	59 3a       	cp.w	r10,19
80007890:	e0 88 00 1a 	brls	800078c4 <_realloc_r+0x130>
80007894:	09 09       	ld.w	r9,r4++
80007896:	8b 09       	st.w	r5[0x0],r9
80007898:	09 09       	ld.w	r9,r4++
8000789a:	8f 39       	st.w	r7[0xc],r9
8000789c:	ee c9 ff f0 	sub	r9,r7,-16
800078a0:	59 ba       	cp.w	r10,27
800078a2:	e0 88 00 11 	brls	800078c4 <_realloc_r+0x130>
800078a6:	09 0b       	ld.w	r11,r4++
800078a8:	93 0b       	st.w	r9[0x0],r11
800078aa:	09 09       	ld.w	r9,r4++
800078ac:	8f 59       	st.w	r7[0x14],r9
800078ae:	ee c9 ff e8 	sub	r9,r7,-24
800078b2:	e0 4a 00 24 	cp.w	r10,36
800078b6:	c0 71       	brne	800078c4 <_realloc_r+0x130>
800078b8:	09 0a       	ld.w	r10,r4++
800078ba:	93 0a       	st.w	r9[0x0],r10
800078bc:	ee c9 ff e0 	sub	r9,r7,-32
800078c0:	09 0a       	ld.w	r10,r4++
800078c2:	8f 7a       	st.w	r7[0x1c],r10
800078c4:	09 0a       	ld.w	r10,r4++
800078c6:	12 aa       	st.w	r9++,r10
800078c8:	68 0a       	ld.w	r10,r4[0x0]
800078ca:	93 0a       	st.w	r9[0x0],r10
800078cc:	68 1a       	ld.w	r10,r4[0x4]
800078ce:	93 1a       	st.w	r9[0x4],r10
800078d0:	c0 78       	rjmp	800078de <_realloc_r+0x14a>
800078d2:	50 08       	stdsp	sp[0x0],r8
800078d4:	08 9b       	mov	r11,r4
800078d6:	0a 9c       	mov	r12,r5
800078d8:	e0 a0 1d 8f 	rcall	8000b3f6 <memmove>
800078dc:	40 08       	lddsp	r8,sp[0x0]
800078de:	ee 06 00 09 	add	r9,r7,r6
800078e2:	0c 13       	sub	r3,r6
800078e4:	a1 a3       	sbr	r3,0x0
800078e6:	93 13       	st.w	r9[0x4],r3
800078e8:	91 29       	st.w	r8[0x8],r9
800078ea:	04 9c       	mov	r12,r2
800078ec:	6e 18       	ld.w	r8,r7[0x4]
800078ee:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800078f2:	10 46       	or	r6,r8
800078f4:	8f 16       	st.w	r7[0x4],r6
800078f6:	ca a8       	rjmp	80007a4a <_realloc_r+0x2b6>
800078f8:	14 03       	add	r3,r10
800078fa:	0c 33       	cp.w	r3,r6
800078fc:	c0 85       	brlt	8000790c <_realloc_r+0x178>
800078fe:	72 28       	ld.w	r8,r9[0x8]
80007900:	72 39       	ld.w	r9,r9[0xc]
80007902:	93 28       	st.w	r9[0x8],r8
80007904:	91 39       	st.w	r8[0xc],r9
80007906:	6e 28       	ld.w	r8,r7[0x8]
80007908:	6e 39       	ld.w	r9,r7[0xc]
8000790a:	c0 78       	rjmp	80007918 <_realloc_r+0x184>
8000790c:	f8 00 00 03 	add	r3,r12,r0
80007910:	0c 33       	cp.w	r3,r6
80007912:	c3 35       	brlt	80007978 <_realloc_r+0x1e4>
80007914:	6e 39       	ld.w	r9,r7[0xc]
80007916:	6e 28       	ld.w	r8,r7[0x8]
80007918:	93 28       	st.w	r9[0x8],r8
8000791a:	91 39       	st.w	r8[0xc],r9
8000791c:	e0 ca 00 04 	sub	r10,r0,4
80007920:	ee cc ff f8 	sub	r12,r7,-8
80007924:	e0 4a 00 24 	cp.w	r10,36
80007928:	e0 8b 00 24 	brhi	80007970 <_realloc_r+0x1dc>
8000792c:	59 3a       	cp.w	r10,19
8000792e:	e0 88 00 1a 	brls	80007962 <_realloc_r+0x1ce>
80007932:	09 08       	ld.w	r8,r4++
80007934:	99 08       	st.w	r12[0x0],r8
80007936:	09 08       	ld.w	r8,r4++
80007938:	8f 38       	st.w	r7[0xc],r8
8000793a:	ee cc ff f0 	sub	r12,r7,-16
8000793e:	59 ba       	cp.w	r10,27
80007940:	e0 88 00 11 	brls	80007962 <_realloc_r+0x1ce>
80007944:	09 08       	ld.w	r8,r4++
80007946:	99 08       	st.w	r12[0x0],r8
80007948:	09 08       	ld.w	r8,r4++
8000794a:	8f 58       	st.w	r7[0x14],r8
8000794c:	ee cc ff e8 	sub	r12,r7,-24
80007950:	e0 4a 00 24 	cp.w	r10,36
80007954:	c0 71       	brne	80007962 <_realloc_r+0x1ce>
80007956:	09 08       	ld.w	r8,r4++
80007958:	99 08       	st.w	r12[0x0],r8
8000795a:	ee cc ff e0 	sub	r12,r7,-32
8000795e:	09 08       	ld.w	r8,r4++
80007960:	8f 78       	st.w	r7[0x1c],r8
80007962:	09 08       	ld.w	r8,r4++
80007964:	18 a8       	st.w	r12++,r8
80007966:	68 08       	ld.w	r8,r4[0x0]
80007968:	99 08       	st.w	r12[0x0],r8
8000796a:	68 18       	ld.w	r8,r4[0x4]
8000796c:	99 18       	st.w	r12[0x4],r8
8000796e:	c4 78       	rjmp	800079fc <_realloc_r+0x268>
80007970:	08 9b       	mov	r11,r4
80007972:	e0 a0 1d 42 	rcall	8000b3f6 <memmove>
80007976:	c4 38       	rjmp	800079fc <_realloc_r+0x268>
80007978:	04 9c       	mov	r12,r2
8000797a:	fe b0 fc 45 	rcall	80007204 <_malloc_r>
8000797e:	18 95       	mov	r5,r12
80007980:	c3 a0       	breq	800079f4 <_realloc_r+0x260>
80007982:	62 18       	ld.w	r8,r1[0x4]
80007984:	f8 c9 00 08 	sub	r9,r12,8
80007988:	a1 c8       	cbr	r8,0x0
8000798a:	e2 08 00 08 	add	r8,r1,r8
8000798e:	10 39       	cp.w	r9,r8
80007990:	c0 71       	brne	8000799e <_realloc_r+0x20a>
80007992:	72 13       	ld.w	r3,r9[0x4]
80007994:	02 97       	mov	r7,r1
80007996:	e0 13 ff fc 	andl	r3,0xfffc
8000799a:	00 03       	add	r3,r0
8000799c:	c3 08       	rjmp	800079fc <_realloc_r+0x268>
8000799e:	e0 ca 00 04 	sub	r10,r0,4
800079a2:	e0 4a 00 24 	cp.w	r10,36
800079a6:	e0 8b 00 20 	brhi	800079e6 <_realloc_r+0x252>
800079aa:	08 99       	mov	r9,r4
800079ac:	18 98       	mov	r8,r12
800079ae:	59 3a       	cp.w	r10,19
800079b0:	e0 88 00 14 	brls	800079d8 <_realloc_r+0x244>
800079b4:	13 0b       	ld.w	r11,r9++
800079b6:	10 ab       	st.w	r8++,r11
800079b8:	13 0b       	ld.w	r11,r9++
800079ba:	10 ab       	st.w	r8++,r11
800079bc:	59 ba       	cp.w	r10,27
800079be:	e0 88 00 0d 	brls	800079d8 <_realloc_r+0x244>
800079c2:	13 0b       	ld.w	r11,r9++
800079c4:	10 ab       	st.w	r8++,r11
800079c6:	13 0b       	ld.w	r11,r9++
800079c8:	10 ab       	st.w	r8++,r11
800079ca:	e0 4a 00 24 	cp.w	r10,36
800079ce:	c0 51       	brne	800079d8 <_realloc_r+0x244>
800079d0:	13 0a       	ld.w	r10,r9++
800079d2:	10 aa       	st.w	r8++,r10
800079d4:	13 0a       	ld.w	r10,r9++
800079d6:	10 aa       	st.w	r8++,r10
800079d8:	13 0a       	ld.w	r10,r9++
800079da:	10 aa       	st.w	r8++,r10
800079dc:	72 0a       	ld.w	r10,r9[0x0]
800079de:	91 0a       	st.w	r8[0x0],r10
800079e0:	72 19       	ld.w	r9,r9[0x4]
800079e2:	91 19       	st.w	r8[0x4],r9
800079e4:	c0 48       	rjmp	800079ec <_realloc_r+0x258>
800079e6:	08 9b       	mov	r11,r4
800079e8:	e0 a0 1d 07 	rcall	8000b3f6 <memmove>
800079ec:	08 9b       	mov	r11,r4
800079ee:	04 9c       	mov	r12,r2
800079f0:	e0 a0 1a 60 	rcall	8000aeb0 <_free_r>
800079f4:	04 9c       	mov	r12,r2
800079f6:	c2 a8       	rjmp	80007a4a <_realloc_r+0x2b6>
800079f8:	00 93       	mov	r3,r0
800079fa:	02 97       	mov	r7,r1
800079fc:	e6 06 01 09 	sub	r9,r3,r6
80007a00:	6e 18       	ld.w	r8,r7[0x4]
80007a02:	58 f9       	cp.w	r9,15
80007a04:	e0 88 00 16 	brls	80007a30 <_realloc_r+0x29c>
80007a08:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a0c:	ed e8 10 08 	or	r8,r6,r8
80007a10:	8f 18       	st.w	r7[0x4],r8
80007a12:	12 98       	mov	r8,r9
80007a14:	a1 a8       	sbr	r8,0x0
80007a16:	ee 06 00 0b 	add	r11,r7,r6
80007a1a:	f6 09 00 09 	add	r9,r11,r9
80007a1e:	97 18       	st.w	r11[0x4],r8
80007a20:	72 18       	ld.w	r8,r9[0x4]
80007a22:	a1 a8       	sbr	r8,0x0
80007a24:	2f 8b       	sub	r11,-8
80007a26:	93 18       	st.w	r9[0x4],r8
80007a28:	04 9c       	mov	r12,r2
80007a2a:	e0 a0 1a 43 	rcall	8000aeb0 <_free_r>
80007a2e:	c0 b8       	rjmp	80007a44 <_realloc_r+0x2b0>
80007a30:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a34:	e7 e8 10 08 	or	r8,r3,r8
80007a38:	8f 18       	st.w	r7[0x4],r8
80007a3a:	ee 03 00 03 	add	r3,r7,r3
80007a3e:	66 18       	ld.w	r8,r3[0x4]
80007a40:	a1 a8       	sbr	r8,0x0
80007a42:	87 18       	st.w	r3[0x4],r8
80007a44:	04 9c       	mov	r12,r2
80007a46:	ee c5 ff f8 	sub	r5,r7,-8
80007a4a:	fe b0 f1 9d 	rcall	80005d84 <__malloc_unlock>
80007a4e:	0a 9c       	mov	r12,r5
80007a50:	2f fd       	sub	sp,-4
80007a52:	d8 32       	popm	r0-r7,pc

80007a54 <_sbrk_r>:
80007a54:	d4 21       	pushm	r4-r7,lr
80007a56:	30 08       	mov	r8,0
80007a58:	18 97       	mov	r7,r12
80007a5a:	e0 66 b6 78 	mov	r6,46712
80007a5e:	16 9c       	mov	r12,r11
80007a60:	8d 08       	st.w	r6[0x0],r8
80007a62:	c8 5c       	rcall	80007b6c <_sbrk>
80007a64:	5b fc       	cp.w	r12,-1
80007a66:	c0 51       	brne	80007a70 <_sbrk_r+0x1c>
80007a68:	6c 08       	ld.w	r8,r6[0x0]
80007a6a:	58 08       	cp.w	r8,0
80007a6c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007a70:	d8 22       	popm	r4-r7,pc
80007a72:	d7 03       	nop

80007a74 <sprintf>:
80007a74:	d4 01       	pushm	lr
80007a76:	21 7d       	sub	sp,92
80007a78:	e0 68 ff ff 	mov	r8,65535
80007a7c:	ea 18 7f ff 	orh	r8,0x7fff
80007a80:	50 58       	stdsp	sp[0x14],r8
80007a82:	50 28       	stdsp	sp[0x8],r8
80007a84:	e0 68 02 08 	mov	r8,520
80007a88:	ba 68       	st.h	sp[0xc],r8
80007a8a:	3f f8       	mov	r8,-1
80007a8c:	ba 78       	st.h	sp[0xe],r8
80007a8e:	e0 68 0a 30 	mov	r8,2608
80007a92:	50 4c       	stdsp	sp[0x10],r12
80007a94:	16 9a       	mov	r10,r11
80007a96:	50 0c       	stdsp	sp[0x0],r12
80007a98:	fa c9 ff a0 	sub	r9,sp,-96
80007a9c:	70 0c       	ld.w	r12,r8[0x0]
80007a9e:	1a 9b       	mov	r11,sp
80007aa0:	e0 a0 02 1a 	rcall	80007ed4 <_vfprintf_r>
80007aa4:	30 09       	mov	r9,0
80007aa6:	40 08       	lddsp	r8,sp[0x0]
80007aa8:	b0 89       	st.b	r8[0x0],r9
80007aaa:	2e 9d       	sub	sp,-92
80007aac:	d8 02       	popm	pc
80007aae:	d7 03       	nop

80007ab0 <strncpy>:
80007ab0:	30 08       	mov	r8,0
80007ab2:	10 3a       	cp.w	r10,r8
80007ab4:	5e 0c       	reteq	r12
80007ab6:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007aba:	f8 08 0b 09 	st.b	r12[r8],r9
80007abe:	2f f8       	sub	r8,-1
80007ac0:	58 09       	cp.w	r9,0
80007ac2:	cf 81       	brne	80007ab2 <strncpy+0x2>
80007ac4:	10 3a       	cp.w	r10,r8
80007ac6:	5e 0c       	reteq	r12
80007ac8:	f8 08 0b 09 	st.b	r12[r8],r9
80007acc:	2f f8       	sub	r8,-1
80007ace:	cf bb       	rjmp	80007ac4 <strncpy+0x14>

80007ad0 <_close>:
80007ad0:	30 28       	mov	r8,2
80007ad2:	d6 73       	breakpoint
80007ad4:	3f fc       	mov	r12,-1
80007ad6:	35 8b       	mov	r11,88
80007ad8:	58 0c       	cp.w	r12,0
80007ada:	5e 4c       	retge	r12
80007adc:	e0 6a b6 78 	mov	r10,46712
80007ae0:	95 0b       	st.w	r10[0x0],r11
80007ae2:	5e fc       	retal	r12

80007ae4 <_lseek>:
80007ae4:	30 58       	mov	r8,5
80007ae6:	d6 73       	breakpoint
80007ae8:	3f fc       	mov	r12,-1
80007aea:	35 8b       	mov	r11,88
80007aec:	58 0c       	cp.w	r12,0
80007aee:	5e 4c       	retge	r12
80007af0:	e0 6a b6 78 	mov	r10,46712
80007af4:	95 0b       	st.w	r10[0x0],r11
80007af6:	5e fc       	retal	r12

80007af8 <isatty>:
80007af8:	30 b8       	mov	r8,11
80007afa:	d6 73       	breakpoint
80007afc:	3f fc       	mov	r12,-1
80007afe:	35 8b       	mov	r11,88
80007b00:	58 0c       	cp.w	r12,0
80007b02:	5e 4c       	retge	r12
80007b04:	e0 6a b6 78 	mov	r10,46712
80007b08:	95 0b       	st.w	r10[0x0],r11
80007b0a:	5e fc       	retal	r12

80007b0c <_fstat_host>:
80007b0c:	30 98       	mov	r8,9
80007b0e:	d6 73       	breakpoint
80007b10:	3f fc       	mov	r12,-1
80007b12:	35 8b       	mov	r11,88
80007b14:	58 0c       	cp.w	r12,0
80007b16:	5e 4c       	retge	r12
80007b18:	e0 6a b6 78 	mov	r10,46712
80007b1c:	95 0b       	st.w	r10[0x0],r11
80007b1e:	5e fc       	retal	r12

80007b20 <_fstat>:
80007b20:	d4 21       	pushm	r4-r7,lr
80007b22:	21 0d       	sub	sp,64
80007b24:	16 97       	mov	r7,r11
80007b26:	1a 9b       	mov	r11,sp
80007b28:	cf 2f       	rcall	80007b0c <_fstat_host>
80007b2a:	c0 34       	brge	80007b30 <_fstat+0x10>
80007b2c:	3f fc       	mov	r12,-1
80007b2e:	c1 c8       	rjmp	80007b66 <_fstat+0x46>
80007b30:	40 08       	lddsp	r8,sp[0x0]
80007b32:	ae 08       	st.h	r7[0x0],r8
80007b34:	40 18       	lddsp	r8,sp[0x4]
80007b36:	ae 18       	st.h	r7[0x2],r8
80007b38:	40 28       	lddsp	r8,sp[0x8]
80007b3a:	8f 18       	st.w	r7[0x4],r8
80007b3c:	40 38       	lddsp	r8,sp[0xc]
80007b3e:	ae 48       	st.h	r7[0x8],r8
80007b40:	40 48       	lddsp	r8,sp[0x10]
80007b42:	ae 58       	st.h	r7[0xa],r8
80007b44:	40 58       	lddsp	r8,sp[0x14]
80007b46:	ae 68       	st.h	r7[0xc],r8
80007b48:	40 68       	lddsp	r8,sp[0x18]
80007b4a:	ae 78       	st.h	r7[0xe],r8
80007b4c:	40 88       	lddsp	r8,sp[0x20]
80007b4e:	8f 48       	st.w	r7[0x10],r8
80007b50:	40 a8       	lddsp	r8,sp[0x28]
80007b52:	8f b8       	st.w	r7[0x2c],r8
80007b54:	40 c8       	lddsp	r8,sp[0x30]
80007b56:	8f c8       	st.w	r7[0x30],r8
80007b58:	40 d8       	lddsp	r8,sp[0x34]
80007b5a:	8f 58       	st.w	r7[0x14],r8
80007b5c:	40 e8       	lddsp	r8,sp[0x38]
80007b5e:	30 0c       	mov	r12,0
80007b60:	8f 78       	st.w	r7[0x1c],r8
80007b62:	40 f8       	lddsp	r8,sp[0x3c]
80007b64:	8f 98       	st.w	r7[0x24],r8
80007b66:	2f 0d       	sub	sp,-64
80007b68:	d8 22       	popm	r4-r7,pc
80007b6a:	d7 03       	nop

80007b6c <_sbrk>:
80007b6c:	d4 01       	pushm	lr
80007b6e:	e0 68 0d 78 	mov	r8,3448
80007b72:	70 09       	ld.w	r9,r8[0x0]
80007b74:	58 09       	cp.w	r9,0
80007b76:	c0 41       	brne	80007b7e <_sbrk+0x12>
80007b78:	e0 69 b6 80 	mov	r9,46720
80007b7c:	91 09       	st.w	r8[0x0],r9
80007b7e:	e0 69 0d 78 	mov	r9,3448
80007b82:	e0 7a 70 00 	mov	r10,94208
80007b86:	72 08       	ld.w	r8,r9[0x0]
80007b88:	f0 0c 00 0c 	add	r12,r8,r12
80007b8c:	14 3c       	cp.w	r12,r10
80007b8e:	e0 8b 00 04 	brhi	80007b96 <_sbrk+0x2a>
80007b92:	93 0c       	st.w	r9[0x0],r12
80007b94:	c0 68       	rjmp	80007ba0 <_sbrk+0x34>
80007b96:	e0 a0 18 15 	rcall	8000abc0 <__errno>
80007b9a:	30 c8       	mov	r8,12
80007b9c:	99 08       	st.w	r12[0x0],r8
80007b9e:	3f f8       	mov	r8,-1
80007ba0:	10 9c       	mov	r12,r8
80007ba2:	d8 02       	popm	pc

80007ba4 <get_arg>:
80007ba4:	d4 31       	pushm	r0-r7,lr
80007ba6:	20 8d       	sub	sp,32
80007ba8:	fa c4 ff bc 	sub	r4,sp,-68
80007bac:	50 4b       	stdsp	sp[0x10],r11
80007bae:	68 2e       	ld.w	lr,r4[0x8]
80007bb0:	50 58       	stdsp	sp[0x14],r8
80007bb2:	12 96       	mov	r6,r9
80007bb4:	7c 0b       	ld.w	r11,lr[0x0]
80007bb6:	70 05       	ld.w	r5,r8[0x0]
80007bb8:	50 6e       	stdsp	sp[0x18],lr
80007bba:	58 0b       	cp.w	r11,0
80007bbc:	f4 0b 17 00 	moveq	r11,r10
80007bc0:	68 03       	ld.w	r3,r4[0x0]
80007bc2:	68 11       	ld.w	r1,r4[0x4]
80007bc4:	40 49       	lddsp	r9,sp[0x10]
80007bc6:	30 08       	mov	r8,0
80007bc8:	c2 89       	rjmp	80007e18 <get_arg+0x274>
80007bca:	2f fb       	sub	r11,-1
80007bcc:	32 5c       	mov	r12,37
80007bce:	17 8a       	ld.ub	r10,r11[0x0]
80007bd0:	f8 0a 18 00 	cp.b	r10,r12
80007bd4:	5f 1e       	srne	lr
80007bd6:	f0 0a 18 00 	cp.b	r10,r8
80007bda:	5f 1c       	srne	r12
80007bdc:	fd ec 00 0c 	and	r12,lr,r12
80007be0:	f0 0c 18 00 	cp.b	r12,r8
80007be4:	cf 31       	brne	80007bca <get_arg+0x26>
80007be6:	58 0a       	cp.w	r10,0
80007be8:	e0 80 01 25 	breq	80007e32 <get_arg+0x28e>
80007bec:	30 0c       	mov	r12,0
80007bee:	3f fa       	mov	r10,-1
80007bf0:	18 90       	mov	r0,r12
80007bf2:	50 3a       	stdsp	sp[0xc],r10
80007bf4:	18 94       	mov	r4,r12
80007bf6:	18 92       	mov	r2,r12
80007bf8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007bfc:	16 97       	mov	r7,r11
80007bfe:	50 7c       	stdsp	sp[0x1c],r12
80007c00:	fe cc 9e 20 	sub	r12,pc,-25056
80007c04:	0f 3a       	ld.ub	r10,r7++
80007c06:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007c0a:	40 7c       	lddsp	r12,sp[0x1c]
80007c0c:	1c 0c       	add	r12,lr
80007c0e:	fe ce 9e f6 	sub	lr,pc,-24842
80007c12:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007c16:	20 1e       	sub	lr,1
80007c18:	50 0e       	stdsp	sp[0x0],lr
80007c1a:	fe ce 9f 6e 	sub	lr,pc,-24722
80007c1e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007c22:	50 7c       	stdsp	sp[0x1c],r12
80007c24:	40 0c       	lddsp	r12,sp[0x0]
80007c26:	58 7c       	cp.w	r12,7
80007c28:	e0 8b 00 f1 	brhi	80007e0a <get_arg+0x266>
80007c2c:	fe ce a1 20 	sub	lr,pc,-24288
80007c30:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007c34:	36 8b       	mov	r11,104
80007c36:	f6 0a 18 00 	cp.b	r10,r11
80007c3a:	e0 80 00 e8 	breq	80007e0a <get_arg+0x266>
80007c3e:	37 1b       	mov	r11,113
80007c40:	f6 0a 18 00 	cp.b	r10,r11
80007c44:	c0 70       	breq	80007c52 <get_arg+0xae>
80007c46:	34 cb       	mov	r11,76
80007c48:	f6 0a 18 00 	cp.b	r10,r11
80007c4c:	c0 51       	brne	80007c56 <get_arg+0xb2>
80007c4e:	a3 b4       	sbr	r4,0x3
80007c50:	cd d8       	rjmp	80007e0a <get_arg+0x266>
80007c52:	a5 b4       	sbr	r4,0x5
80007c54:	cd b8       	rjmp	80007e0a <get_arg+0x266>
80007c56:	08 9a       	mov	r10,r4
80007c58:	0e 9b       	mov	r11,r7
80007c5a:	a5 aa       	sbr	r10,0x4
80007c5c:	17 3c       	ld.ub	r12,r11++
80007c5e:	a5 b4       	sbr	r4,0x5
80007c60:	36 ce       	mov	lr,108
80007c62:	fc 0c 18 00 	cp.b	r12,lr
80007c66:	e0 80 00 d3 	breq	80007e0c <get_arg+0x268>
80007c6a:	14 94       	mov	r4,r10
80007c6c:	cc f8       	rjmp	80007e0a <get_arg+0x266>
80007c6e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007c72:	36 7c       	mov	r12,103
80007c74:	f8 0a 18 00 	cp.b	r10,r12
80007c78:	e0 8b 00 27 	brhi	80007cc6 <get_arg+0x122>
80007c7c:	36 5b       	mov	r11,101
80007c7e:	f6 0a 18 00 	cp.b	r10,r11
80007c82:	c4 82       	brcc	80007d12 <get_arg+0x16e>
80007c84:	34 fb       	mov	r11,79
80007c86:	f6 0a 18 00 	cp.b	r10,r11
80007c8a:	c4 80       	breq	80007d1a <get_arg+0x176>
80007c8c:	e0 8b 00 0c 	brhi	80007ca4 <get_arg+0x100>
80007c90:	34 5b       	mov	r11,69
80007c92:	f6 0a 18 00 	cp.b	r10,r11
80007c96:	c3 e0       	breq	80007d12 <get_arg+0x16e>
80007c98:	34 7b       	mov	r11,71
80007c9a:	f6 0a 18 00 	cp.b	r10,r11
80007c9e:	c3 a0       	breq	80007d12 <get_arg+0x16e>
80007ca0:	34 4b       	mov	r11,68
80007ca2:	c0 88       	rjmp	80007cb2 <get_arg+0x10e>
80007ca4:	35 8b       	mov	r11,88
80007ca6:	f6 0a 18 00 	cp.b	r10,r11
80007caa:	c2 c0       	breq	80007d02 <get_arg+0x15e>
80007cac:	e0 8b 00 07 	brhi	80007cba <get_arg+0x116>
80007cb0:	35 5b       	mov	r11,85
80007cb2:	f6 0a 18 00 	cp.b	r10,r11
80007cb6:	c3 51       	brne	80007d20 <get_arg+0x17c>
80007cb8:	c3 18       	rjmp	80007d1a <get_arg+0x176>
80007cba:	36 3b       	mov	r11,99
80007cbc:	f6 0a 18 00 	cp.b	r10,r11
80007cc0:	c2 f0       	breq	80007d1e <get_arg+0x17a>
80007cc2:	36 4b       	mov	r11,100
80007cc4:	c0 e8       	rjmp	80007ce0 <get_arg+0x13c>
80007cc6:	37 0b       	mov	r11,112
80007cc8:	f6 0a 18 00 	cp.b	r10,r11
80007ccc:	c2 50       	breq	80007d16 <get_arg+0x172>
80007cce:	e0 8b 00 0d 	brhi	80007ce8 <get_arg+0x144>
80007cd2:	36 eb       	mov	r11,110
80007cd4:	f6 0a 18 00 	cp.b	r10,r11
80007cd8:	c1 f0       	breq	80007d16 <get_arg+0x172>
80007cda:	e0 8b 00 14 	brhi	80007d02 <get_arg+0x15e>
80007cde:	36 9b       	mov	r11,105
80007ce0:	f6 0a 18 00 	cp.b	r10,r11
80007ce4:	c1 e1       	brne	80007d20 <get_arg+0x17c>
80007ce6:	c0 e8       	rjmp	80007d02 <get_arg+0x15e>
80007ce8:	37 5b       	mov	r11,117
80007cea:	f6 0a 18 00 	cp.b	r10,r11
80007cee:	c0 a0       	breq	80007d02 <get_arg+0x15e>
80007cf0:	37 8b       	mov	r11,120
80007cf2:	f6 0a 18 00 	cp.b	r10,r11
80007cf6:	c0 60       	breq	80007d02 <get_arg+0x15e>
80007cf8:	37 3b       	mov	r11,115
80007cfa:	f6 0a 18 00 	cp.b	r10,r11
80007cfe:	c1 11       	brne	80007d20 <get_arg+0x17c>
80007d00:	c0 b8       	rjmp	80007d16 <get_arg+0x172>
80007d02:	ed b4 00 04 	bld	r4,0x4
80007d06:	c0 a0       	breq	80007d1a <get_arg+0x176>
80007d08:	ed b4 00 05 	bld	r4,0x5
80007d0c:	c0 91       	brne	80007d1e <get_arg+0x17a>
80007d0e:	30 20       	mov	r0,2
80007d10:	c0 88       	rjmp	80007d20 <get_arg+0x17c>
80007d12:	30 40       	mov	r0,4
80007d14:	c0 68       	rjmp	80007d20 <get_arg+0x17c>
80007d16:	30 30       	mov	r0,3
80007d18:	c0 48       	rjmp	80007d20 <get_arg+0x17c>
80007d1a:	30 10       	mov	r0,1
80007d1c:	c0 28       	rjmp	80007d20 <get_arg+0x17c>
80007d1e:	30 00       	mov	r0,0
80007d20:	40 3b       	lddsp	r11,sp[0xc]
80007d22:	5b fb       	cp.w	r11,-1
80007d24:	c0 40       	breq	80007d2c <get_arg+0x188>
80007d26:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007d2a:	c7 08       	rjmp	80007e0a <get_arg+0x266>
80007d2c:	58 60       	cp.w	r0,6
80007d2e:	e0 8b 00 6e 	brhi	80007e0a <get_arg+0x266>
80007d32:	6c 0a       	ld.w	r10,r6[0x0]
80007d34:	ea cc ff ff 	sub	r12,r5,-1
80007d38:	fe ce a2 0c 	sub	lr,pc,-24052
80007d3c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007d40:	f4 cb ff f8 	sub	r11,r10,-8
80007d44:	8d 0b       	st.w	r6[0x0],r11
80007d46:	f4 ea 00 00 	ld.d	r10,r10[0]
80007d4a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007d4e:	c0 f8       	rjmp	80007d6c <get_arg+0x1c8>
80007d50:	f4 cb ff fc 	sub	r11,r10,-4
80007d54:	8d 0b       	st.w	r6[0x0],r11
80007d56:	74 0a       	ld.w	r10,r10[0x0]
80007d58:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007d5c:	c0 88       	rjmp	80007d6c <get_arg+0x1c8>
80007d5e:	f4 cb ff f8 	sub	r11,r10,-8
80007d62:	8d 0b       	st.w	r6[0x0],r11
80007d64:	f4 ea 00 00 	ld.d	r10,r10[0]
80007d68:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007d6c:	0e 9b       	mov	r11,r7
80007d6e:	18 95       	mov	r5,r12
80007d70:	c4 e8       	rjmp	80007e0c <get_arg+0x268>
80007d72:	62 0a       	ld.w	r10,r1[0x0]
80007d74:	5b fa       	cp.w	r10,-1
80007d76:	c0 b1       	brne	80007d8c <get_arg+0x1e8>
80007d78:	50 19       	stdsp	sp[0x4],r9
80007d7a:	50 28       	stdsp	sp[0x8],r8
80007d7c:	e0 6a 00 80 	mov	r10,128
80007d80:	30 0b       	mov	r11,0
80007d82:	02 9c       	mov	r12,r1
80007d84:	fe b0 fd 00 	rcall	80007784 <memset>
80007d88:	40 28       	lddsp	r8,sp[0x8]
80007d8a:	40 19       	lddsp	r9,sp[0x4]
80007d8c:	e4 cc 00 01 	sub	r12,r2,1
80007d90:	0e 9b       	mov	r11,r7
80007d92:	50 3c       	stdsp	sp[0xc],r12
80007d94:	f2 0c 0c 49 	max	r9,r9,r12
80007d98:	c3 a8       	rjmp	80007e0c <get_arg+0x268>
80007d9a:	62 0a       	ld.w	r10,r1[0x0]
80007d9c:	5b fa       	cp.w	r10,-1
80007d9e:	c0 b1       	brne	80007db4 <get_arg+0x210>
80007da0:	50 19       	stdsp	sp[0x4],r9
80007da2:	50 28       	stdsp	sp[0x8],r8
80007da4:	e0 6a 00 80 	mov	r10,128
80007da8:	30 0b       	mov	r11,0
80007daa:	02 9c       	mov	r12,r1
80007dac:	fe b0 fc ec 	rcall	80007784 <memset>
80007db0:	40 28       	lddsp	r8,sp[0x8]
80007db2:	40 19       	lddsp	r9,sp[0x4]
80007db4:	20 12       	sub	r2,1
80007db6:	30 0a       	mov	r10,0
80007db8:	0e 9b       	mov	r11,r7
80007dba:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007dbe:	f2 02 0c 49 	max	r9,r9,r2
80007dc2:	c2 58       	rjmp	80007e0c <get_arg+0x268>
80007dc4:	16 97       	mov	r7,r11
80007dc6:	6c 0a       	ld.w	r10,r6[0x0]
80007dc8:	f4 cb ff fc 	sub	r11,r10,-4
80007dcc:	8d 0b       	st.w	r6[0x0],r11
80007dce:	74 0a       	ld.w	r10,r10[0x0]
80007dd0:	0e 9b       	mov	r11,r7
80007dd2:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007dd6:	2f f5       	sub	r5,-1
80007dd8:	c1 a8       	rjmp	80007e0c <get_arg+0x268>
80007dda:	f4 c2 00 30 	sub	r2,r10,48
80007dde:	c0 68       	rjmp	80007dea <get_arg+0x246>
80007de0:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007de4:	2f f7       	sub	r7,-1
80007de6:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007dea:	0f 8a       	ld.ub	r10,r7[0x0]
80007dec:	58 0a       	cp.w	r10,0
80007dee:	c0 e0       	breq	80007e0a <get_arg+0x266>
80007df0:	23 0a       	sub	r10,48
80007df2:	58 9a       	cp.w	r10,9
80007df4:	fe 98 ff f6 	brls	80007de0 <get_arg+0x23c>
80007df8:	c0 98       	rjmp	80007e0a <get_arg+0x266>
80007dfa:	2f f7       	sub	r7,-1
80007dfc:	0f 8a       	ld.ub	r10,r7[0x0]
80007dfe:	58 0a       	cp.w	r10,0
80007e00:	c0 50       	breq	80007e0a <get_arg+0x266>
80007e02:	23 0a       	sub	r10,48
80007e04:	58 9a       	cp.w	r10,9
80007e06:	fe 98 ff fa 	brls	80007dfa <get_arg+0x256>
80007e0a:	0e 9b       	mov	r11,r7
80007e0c:	40 7c       	lddsp	r12,sp[0x1c]
80007e0e:	30 ba       	mov	r10,11
80007e10:	f4 0c 18 00 	cp.b	r12,r10
80007e14:	fe 91 fe f2 	brne	80007bf8 <get_arg+0x54>
80007e18:	40 42       	lddsp	r2,sp[0x10]
80007e1a:	17 8c       	ld.ub	r12,r11[0x0]
80007e1c:	0a 32       	cp.w	r2,r5
80007e1e:	5f 4a       	srge	r10
80007e20:	f0 0c 18 00 	cp.b	r12,r8
80007e24:	5f 1c       	srne	r12
80007e26:	f9 ea 00 0a 	and	r10,r12,r10
80007e2a:	f0 0a 18 00 	cp.b	r10,r8
80007e2e:	fe 91 fe cf 	brne	80007bcc <get_arg+0x28>
80007e32:	30 08       	mov	r8,0
80007e34:	40 4e       	lddsp	lr,sp[0x10]
80007e36:	17 8a       	ld.ub	r10,r11[0x0]
80007e38:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007e3c:	f0 0a 18 00 	cp.b	r10,r8
80007e40:	fc 09 17 10 	movne	r9,lr
80007e44:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007e48:	06 9e       	mov	lr,r3
80007e4a:	c2 a8       	rjmp	80007e9e <get_arg+0x2fa>
80007e4c:	62 0a       	ld.w	r10,r1[0x0]
80007e4e:	58 3a       	cp.w	r10,3
80007e50:	c1 e0       	breq	80007e8c <get_arg+0x2e8>
80007e52:	e0 89 00 07 	brgt	80007e60 <get_arg+0x2bc>
80007e56:	58 1a       	cp.w	r10,1
80007e58:	c1 a0       	breq	80007e8c <get_arg+0x2e8>
80007e5a:	58 2a       	cp.w	r10,2
80007e5c:	c1 81       	brne	80007e8c <get_arg+0x2e8>
80007e5e:	c0 58       	rjmp	80007e68 <get_arg+0x2c4>
80007e60:	58 5a       	cp.w	r10,5
80007e62:	c0 c0       	breq	80007e7a <get_arg+0x2d6>
80007e64:	c0 b5       	brlt	80007e7a <get_arg+0x2d6>
80007e66:	c1 38       	rjmp	80007e8c <get_arg+0x2e8>
80007e68:	6c 0a       	ld.w	r10,r6[0x0]
80007e6a:	f4 cc ff f8 	sub	r12,r10,-8
80007e6e:	8d 0c       	st.w	r6[0x0],r12
80007e70:	f4 e2 00 00 	ld.d	r2,r10[0]
80007e74:	f0 e3 00 00 	st.d	r8[0],r2
80007e78:	c1 08       	rjmp	80007e98 <get_arg+0x2f4>
80007e7a:	6c 0a       	ld.w	r10,r6[0x0]
80007e7c:	f4 cc ff f8 	sub	r12,r10,-8
80007e80:	8d 0c       	st.w	r6[0x0],r12
80007e82:	f4 e2 00 00 	ld.d	r2,r10[0]
80007e86:	f0 e3 00 00 	st.d	r8[0],r2
80007e8a:	c0 78       	rjmp	80007e98 <get_arg+0x2f4>
80007e8c:	6c 0a       	ld.w	r10,r6[0x0]
80007e8e:	f4 cc ff fc 	sub	r12,r10,-4
80007e92:	8d 0c       	st.w	r6[0x0],r12
80007e94:	74 0a       	ld.w	r10,r10[0x0]
80007e96:	91 0a       	st.w	r8[0x0],r10
80007e98:	2f f5       	sub	r5,-1
80007e9a:	2f 88       	sub	r8,-8
80007e9c:	2f c1       	sub	r1,-4
80007e9e:	12 35       	cp.w	r5,r9
80007ea0:	fe 9a ff d6 	brle	80007e4c <get_arg+0x2a8>
80007ea4:	1c 93       	mov	r3,lr
80007ea6:	40 52       	lddsp	r2,sp[0x14]
80007ea8:	40 6e       	lddsp	lr,sp[0x18]
80007eaa:	85 05       	st.w	r2[0x0],r5
80007eac:	9d 0b       	st.w	lr[0x0],r11
80007eae:	40 4b       	lddsp	r11,sp[0x10]
80007eb0:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007eb4:	2f 8d       	sub	sp,-32
80007eb6:	d8 32       	popm	r0-r7,pc

80007eb8 <__sprint_r>:
80007eb8:	d4 21       	pushm	r4-r7,lr
80007eba:	14 97       	mov	r7,r10
80007ebc:	74 28       	ld.w	r8,r10[0x8]
80007ebe:	58 08       	cp.w	r8,0
80007ec0:	c0 41       	brne	80007ec8 <__sprint_r+0x10>
80007ec2:	95 18       	st.w	r10[0x4],r8
80007ec4:	10 9c       	mov	r12,r8
80007ec6:	d8 22       	popm	r4-r7,pc
80007ec8:	e0 a0 18 ba 	rcall	8000b03c <__sfvwrite_r>
80007ecc:	30 08       	mov	r8,0
80007ece:	8f 18       	st.w	r7[0x4],r8
80007ed0:	8f 28       	st.w	r7[0x8],r8
80007ed2:	d8 22       	popm	r4-r7,pc

80007ed4 <_vfprintf_r>:
80007ed4:	d4 31       	pushm	r0-r7,lr
80007ed6:	fa cd 06 bc 	sub	sp,sp,1724
80007eda:	51 09       	stdsp	sp[0x40],r9
80007edc:	16 91       	mov	r1,r11
80007ede:	14 97       	mov	r7,r10
80007ee0:	18 95       	mov	r5,r12
80007ee2:	e0 a0 1a 1d 	rcall	8000b31c <_localeconv_r>
80007ee6:	78 0c       	ld.w	r12,r12[0x0]
80007ee8:	50 cc       	stdsp	sp[0x30],r12
80007eea:	58 05       	cp.w	r5,0
80007eec:	c0 70       	breq	80007efa <_vfprintf_r+0x26>
80007eee:	6a 68       	ld.w	r8,r5[0x18]
80007ef0:	58 08       	cp.w	r8,0
80007ef2:	c0 41       	brne	80007efa <_vfprintf_r+0x26>
80007ef4:	0a 9c       	mov	r12,r5
80007ef6:	e0 a0 17 43 	rcall	8000ad7c <__sinit>
80007efa:	fe c8 a0 0a 	sub	r8,pc,-24566
80007efe:	10 31       	cp.w	r1,r8
80007f00:	c0 31       	brne	80007f06 <_vfprintf_r+0x32>
80007f02:	6a 01       	ld.w	r1,r5[0x0]
80007f04:	c0 c8       	rjmp	80007f1c <_vfprintf_r+0x48>
80007f06:	fe c8 9f f6 	sub	r8,pc,-24586
80007f0a:	10 31       	cp.w	r1,r8
80007f0c:	c0 31       	brne	80007f12 <_vfprintf_r+0x3e>
80007f0e:	6a 11       	ld.w	r1,r5[0x4]
80007f10:	c0 68       	rjmp	80007f1c <_vfprintf_r+0x48>
80007f12:	fe c8 9f e2 	sub	r8,pc,-24606
80007f16:	10 31       	cp.w	r1,r8
80007f18:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007f1c:	82 68       	ld.sh	r8,r1[0xc]
80007f1e:	ed b8 00 03 	bld	r8,0x3
80007f22:	c0 41       	brne	80007f2a <_vfprintf_r+0x56>
80007f24:	62 48       	ld.w	r8,r1[0x10]
80007f26:	58 08       	cp.w	r8,0
80007f28:	c0 71       	brne	80007f36 <_vfprintf_r+0x62>
80007f2a:	02 9b       	mov	r11,r1
80007f2c:	0a 9c       	mov	r12,r5
80007f2e:	e0 a0 0f 5d 	rcall	80009de8 <__swsetup_r>
80007f32:	e0 81 0f 54 	brne	80009dda <_vfprintf_r+0x1f06>
80007f36:	82 68       	ld.sh	r8,r1[0xc]
80007f38:	10 99       	mov	r9,r8
80007f3a:	e2 19 00 1a 	andl	r9,0x1a,COH
80007f3e:	58 a9       	cp.w	r9,10
80007f40:	c3 c1       	brne	80007fb8 <_vfprintf_r+0xe4>
80007f42:	82 79       	ld.sh	r9,r1[0xe]
80007f44:	30 0a       	mov	r10,0
80007f46:	f4 09 19 00 	cp.h	r9,r10
80007f4a:	c3 75       	brlt	80007fb8 <_vfprintf_r+0xe4>
80007f4c:	a1 d8       	cbr	r8,0x1
80007f4e:	fb 58 05 d0 	st.h	sp[1488],r8
80007f52:	62 88       	ld.w	r8,r1[0x20]
80007f54:	fb 48 05 e4 	st.w	sp[1508],r8
80007f58:	62 a8       	ld.w	r8,r1[0x28]
80007f5a:	fb 48 05 ec 	st.w	sp[1516],r8
80007f5e:	fa c8 ff bc 	sub	r8,sp,-68
80007f62:	fb 48 05 d4 	st.w	sp[1492],r8
80007f66:	fb 48 05 c4 	st.w	sp[1476],r8
80007f6a:	e0 68 04 00 	mov	r8,1024
80007f6e:	fb 48 05 d8 	st.w	sp[1496],r8
80007f72:	fb 48 05 cc 	st.w	sp[1484],r8
80007f76:	30 08       	mov	r8,0
80007f78:	fb 59 05 d2 	st.h	sp[1490],r9
80007f7c:	0e 9a       	mov	r10,r7
80007f7e:	41 09       	lddsp	r9,sp[0x40]
80007f80:	fa c7 fa 3c 	sub	r7,sp,-1476
80007f84:	fb 48 05 dc 	st.w	sp[1500],r8
80007f88:	0a 9c       	mov	r12,r5
80007f8a:	0e 9b       	mov	r11,r7
80007f8c:	ca 4f       	rcall	80007ed4 <_vfprintf_r>
80007f8e:	50 bc       	stdsp	sp[0x2c],r12
80007f90:	c0 95       	brlt	80007fa2 <_vfprintf_r+0xce>
80007f92:	0e 9b       	mov	r11,r7
80007f94:	0a 9c       	mov	r12,r5
80007f96:	e0 a0 16 1b 	rcall	8000abcc <_fflush_r>
80007f9a:	40 be       	lddsp	lr,sp[0x2c]
80007f9c:	f9 be 01 ff 	movne	lr,-1
80007fa0:	50 be       	stdsp	sp[0x2c],lr
80007fa2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007fa6:	ed b8 00 06 	bld	r8,0x6
80007faa:	e0 81 0f 1a 	brne	80009dde <_vfprintf_r+0x1f0a>
80007fae:	82 68       	ld.sh	r8,r1[0xc]
80007fb0:	a7 a8       	sbr	r8,0x6
80007fb2:	a2 68       	st.h	r1[0xc],r8
80007fb4:	e0 8f 0f 15 	bral	80009dde <_vfprintf_r+0x1f0a>
80007fb8:	30 08       	mov	r8,0
80007fba:	fb 48 06 b4 	st.w	sp[1716],r8
80007fbe:	fb 48 06 90 	st.w	sp[1680],r8
80007fc2:	fb 48 06 8c 	st.w	sp[1676],r8
80007fc6:	fb 48 06 b0 	st.w	sp[1712],r8
80007fca:	30 08       	mov	r8,0
80007fcc:	30 09       	mov	r9,0
80007fce:	50 a7       	stdsp	sp[0x28],r7
80007fd0:	50 78       	stdsp	sp[0x1c],r8
80007fd2:	fa c3 f9 e0 	sub	r3,sp,-1568
80007fd6:	3f f8       	mov	r8,-1
80007fd8:	50 59       	stdsp	sp[0x14],r9
80007fda:	fb 43 06 88 	st.w	sp[1672],r3
80007fde:	fb 48 05 44 	st.w	sp[1348],r8
80007fe2:	12 9c       	mov	r12,r9
80007fe4:	50 69       	stdsp	sp[0x18],r9
80007fe6:	50 d9       	stdsp	sp[0x34],r9
80007fe8:	50 e9       	stdsp	sp[0x38],r9
80007fea:	50 b9       	stdsp	sp[0x2c],r9
80007fec:	12 97       	mov	r7,r9
80007fee:	0a 94       	mov	r4,r5
80007ff0:	40 a2       	lddsp	r2,sp[0x28]
80007ff2:	32 5a       	mov	r10,37
80007ff4:	30 08       	mov	r8,0
80007ff6:	c0 28       	rjmp	80007ffa <_vfprintf_r+0x126>
80007ff8:	2f f2       	sub	r2,-1
80007ffa:	05 89       	ld.ub	r9,r2[0x0]
80007ffc:	f0 09 18 00 	cp.b	r9,r8
80008000:	5f 1b       	srne	r11
80008002:	f4 09 18 00 	cp.b	r9,r10
80008006:	5f 19       	srne	r9
80008008:	f3 eb 00 0b 	and	r11,r9,r11
8000800c:	f0 0b 18 00 	cp.b	r11,r8
80008010:	cf 41       	brne	80007ff8 <_vfprintf_r+0x124>
80008012:	40 ab       	lddsp	r11,sp[0x28]
80008014:	e4 0b 01 06 	sub	r6,r2,r11
80008018:	c1 e0       	breq	80008054 <_vfprintf_r+0x180>
8000801a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000801e:	0c 08       	add	r8,r6
80008020:	87 0b       	st.w	r3[0x0],r11
80008022:	fb 48 06 90 	st.w	sp[1680],r8
80008026:	87 16       	st.w	r3[0x4],r6
80008028:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000802c:	2f f8       	sub	r8,-1
8000802e:	fb 48 06 8c 	st.w	sp[1676],r8
80008032:	58 78       	cp.w	r8,7
80008034:	e0 89 00 04 	brgt	8000803c <_vfprintf_r+0x168>
80008038:	2f 83       	sub	r3,-8
8000803a:	c0 a8       	rjmp	8000804e <_vfprintf_r+0x17a>
8000803c:	fa ca f9 78 	sub	r10,sp,-1672
80008040:	02 9b       	mov	r11,r1
80008042:	08 9c       	mov	r12,r4
80008044:	c3 af       	rcall	80007eb8 <__sprint_r>
80008046:	e0 81 0e c6 	brne	80009dd2 <_vfprintf_r+0x1efe>
8000804a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000804e:	40 ba       	lddsp	r10,sp[0x2c]
80008050:	0c 0a       	add	r10,r6
80008052:	50 ba       	stdsp	sp[0x2c],r10
80008054:	05 89       	ld.ub	r9,r2[0x0]
80008056:	30 08       	mov	r8,0
80008058:	f0 09 18 00 	cp.b	r9,r8
8000805c:	e0 80 0e aa 	breq	80009db0 <_vfprintf_r+0x1edc>
80008060:	30 09       	mov	r9,0
80008062:	fb 68 06 bb 	st.b	sp[1723],r8
80008066:	0e 96       	mov	r6,r7
80008068:	e4 c8 ff ff 	sub	r8,r2,-1
8000806c:	3f fe       	mov	lr,-1
8000806e:	50 93       	stdsp	sp[0x24],r3
80008070:	50 41       	stdsp	sp[0x10],r1
80008072:	0e 93       	mov	r3,r7
80008074:	04 91       	mov	r1,r2
80008076:	50 89       	stdsp	sp[0x20],r9
80008078:	50 a8       	stdsp	sp[0x28],r8
8000807a:	50 2e       	stdsp	sp[0x8],lr
8000807c:	50 39       	stdsp	sp[0xc],r9
8000807e:	12 95       	mov	r5,r9
80008080:	12 90       	mov	r0,r9
80008082:	10 97       	mov	r7,r8
80008084:	08 92       	mov	r2,r4
80008086:	c0 78       	rjmp	80008094 <_vfprintf_r+0x1c0>
80008088:	3f fc       	mov	r12,-1
8000808a:	08 97       	mov	r7,r4
8000808c:	50 2c       	stdsp	sp[0x8],r12
8000808e:	c0 38       	rjmp	80008094 <_vfprintf_r+0x1c0>
80008090:	30 0b       	mov	r11,0
80008092:	50 3b       	stdsp	sp[0xc],r11
80008094:	0f 38       	ld.ub	r8,r7++
80008096:	c0 28       	rjmp	8000809a <_vfprintf_r+0x1c6>
80008098:	12 90       	mov	r0,r9
8000809a:	f0 c9 00 20 	sub	r9,r8,32
8000809e:	e0 49 00 58 	cp.w	r9,88
800080a2:	e0 8b 0a 30 	brhi	80009502 <_vfprintf_r+0x162e>
800080a6:	fe ca a5 5e 	sub	r10,pc,-23202
800080aa:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800080ae:	50 a7       	stdsp	sp[0x28],r7
800080b0:	50 80       	stdsp	sp[0x20],r0
800080b2:	0c 97       	mov	r7,r6
800080b4:	04 94       	mov	r4,r2
800080b6:	06 96       	mov	r6,r3
800080b8:	02 92       	mov	r2,r1
800080ba:	fe c9 a3 36 	sub	r9,pc,-23754
800080be:	40 93       	lddsp	r3,sp[0x24]
800080c0:	10 90       	mov	r0,r8
800080c2:	40 41       	lddsp	r1,sp[0x10]
800080c4:	50 d9       	stdsp	sp[0x34],r9
800080c6:	e0 8f 08 8e 	bral	800091e2 <_vfprintf_r+0x130e>
800080ca:	30 08       	mov	r8,0
800080cc:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800080d0:	f0 09 18 00 	cp.b	r9,r8
800080d4:	ce 01       	brne	80008094 <_vfprintf_r+0x1c0>
800080d6:	32 08       	mov	r8,32
800080d8:	c6 e8       	rjmp	800081b4 <_vfprintf_r+0x2e0>
800080da:	a1 a5       	sbr	r5,0x0
800080dc:	cd cb       	rjmp	80008094 <_vfprintf_r+0x1c0>
800080de:	0f 89       	ld.ub	r9,r7[0x0]
800080e0:	f2 c8 00 30 	sub	r8,r9,48
800080e4:	58 98       	cp.w	r8,9
800080e6:	e0 8b 00 1d 	brhi	80008120 <_vfprintf_r+0x24c>
800080ea:	ee c8 ff ff 	sub	r8,r7,-1
800080ee:	30 0b       	mov	r11,0
800080f0:	23 09       	sub	r9,48
800080f2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800080f6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800080fa:	11 39       	ld.ub	r9,r8++
800080fc:	f2 ca 00 30 	sub	r10,r9,48
80008100:	58 9a       	cp.w	r10,9
80008102:	fe 98 ff f7 	brls	800080f0 <_vfprintf_r+0x21c>
80008106:	e0 49 00 24 	cp.w	r9,36
8000810a:	cc 31       	brne	80008090 <_vfprintf_r+0x1bc>
8000810c:	e0 4b 00 20 	cp.w	r11,32
80008110:	e0 89 0e 60 	brgt	80009dd0 <_vfprintf_r+0x1efc>
80008114:	20 1b       	sub	r11,1
80008116:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000811a:	12 3b       	cp.w	r11,r9
8000811c:	c0 95       	brlt	8000812e <_vfprintf_r+0x25a>
8000811e:	c1 08       	rjmp	8000813e <_vfprintf_r+0x26a>
80008120:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008124:	ec ca ff ff 	sub	r10,r6,-1
80008128:	12 36       	cp.w	r6,r9
8000812a:	c1 f5       	brlt	80008168 <_vfprintf_r+0x294>
8000812c:	c2 68       	rjmp	80008178 <_vfprintf_r+0x2a4>
8000812e:	fa ce f9 44 	sub	lr,sp,-1724
80008132:	10 97       	mov	r7,r8
80008134:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008138:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000813c:	c3 58       	rjmp	800081a6 <_vfprintf_r+0x2d2>
8000813e:	10 97       	mov	r7,r8
80008140:	fa c8 f9 50 	sub	r8,sp,-1712
80008144:	1a d8       	st.w	--sp,r8
80008146:	fa c8 fa b8 	sub	r8,sp,-1352
8000814a:	1a d8       	st.w	--sp,r8
8000814c:	fa c8 fb b4 	sub	r8,sp,-1100
80008150:	02 9a       	mov	r10,r1
80008152:	1a d8       	st.w	--sp,r8
80008154:	04 9c       	mov	r12,r2
80008156:	fa c8 f9 40 	sub	r8,sp,-1728
8000815a:	fa c9 ff b4 	sub	r9,sp,-76
8000815e:	fe b0 fd 23 	rcall	80007ba4 <get_arg>
80008162:	2f dd       	sub	sp,-12
80008164:	78 00       	ld.w	r0,r12[0x0]
80008166:	c2 08       	rjmp	800081a6 <_vfprintf_r+0x2d2>
80008168:	fa cc f9 44 	sub	r12,sp,-1724
8000816c:	14 96       	mov	r6,r10
8000816e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008172:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008176:	c1 88       	rjmp	800081a6 <_vfprintf_r+0x2d2>
80008178:	41 08       	lddsp	r8,sp[0x40]
8000817a:	59 f9       	cp.w	r9,31
8000817c:	e0 89 00 11 	brgt	8000819e <_vfprintf_r+0x2ca>
80008180:	f0 cb ff fc 	sub	r11,r8,-4
80008184:	51 0b       	stdsp	sp[0x40],r11
80008186:	70 00       	ld.w	r0,r8[0x0]
80008188:	fa cb f9 44 	sub	r11,sp,-1724
8000818c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008190:	f1 40 fd 88 	st.w	r8[-632],r0
80008194:	2f f9       	sub	r9,-1
80008196:	14 96       	mov	r6,r10
80008198:	fb 49 06 b4 	st.w	sp[1716],r9
8000819c:	c0 58       	rjmp	800081a6 <_vfprintf_r+0x2d2>
8000819e:	70 00       	ld.w	r0,r8[0x0]
800081a0:	14 96       	mov	r6,r10
800081a2:	2f c8       	sub	r8,-4
800081a4:	51 08       	stdsp	sp[0x40],r8
800081a6:	58 00       	cp.w	r0,0
800081a8:	fe 94 ff 76 	brge	80008094 <_vfprintf_r+0x1c0>
800081ac:	5c 30       	neg	r0
800081ae:	a3 a5       	sbr	r5,0x2
800081b0:	c7 2b       	rjmp	80008094 <_vfprintf_r+0x1c0>
800081b2:	32 b8       	mov	r8,43
800081b4:	fb 68 06 bb 	st.b	sp[1723],r8
800081b8:	c6 eb       	rjmp	80008094 <_vfprintf_r+0x1c0>
800081ba:	0f 38       	ld.ub	r8,r7++
800081bc:	e0 48 00 2a 	cp.w	r8,42
800081c0:	c0 30       	breq	800081c6 <_vfprintf_r+0x2f2>
800081c2:	30 09       	mov	r9,0
800081c4:	c7 98       	rjmp	800082b6 <_vfprintf_r+0x3e2>
800081c6:	0f 88       	ld.ub	r8,r7[0x0]
800081c8:	f0 c9 00 30 	sub	r9,r8,48
800081cc:	58 99       	cp.w	r9,9
800081ce:	e0 8b 00 1f 	brhi	8000820c <_vfprintf_r+0x338>
800081d2:	ee c4 ff ff 	sub	r4,r7,-1
800081d6:	30 0b       	mov	r11,0
800081d8:	23 08       	sub	r8,48
800081da:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800081de:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800081e2:	09 38       	ld.ub	r8,r4++
800081e4:	f0 c9 00 30 	sub	r9,r8,48
800081e8:	58 99       	cp.w	r9,9
800081ea:	fe 98 ff f7 	brls	800081d8 <_vfprintf_r+0x304>
800081ee:	e0 48 00 24 	cp.w	r8,36
800081f2:	fe 91 ff 4f 	brne	80008090 <_vfprintf_r+0x1bc>
800081f6:	e0 4b 00 20 	cp.w	r11,32
800081fa:	e0 89 0d eb 	brgt	80009dd0 <_vfprintf_r+0x1efc>
800081fe:	20 1b       	sub	r11,1
80008200:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008204:	10 3b       	cp.w	r11,r8
80008206:	c0 a5       	brlt	8000821a <_vfprintf_r+0x346>
80008208:	c1 18       	rjmp	8000822a <_vfprintf_r+0x356>
8000820a:	d7 03       	nop
8000820c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008210:	ec c9 ff ff 	sub	r9,r6,-1
80008214:	14 36       	cp.w	r6,r10
80008216:	c1 f5       	brlt	80008254 <_vfprintf_r+0x380>
80008218:	c2 88       	rjmp	80008268 <_vfprintf_r+0x394>
8000821a:	fa ca f9 44 	sub	r10,sp,-1724
8000821e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008222:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008226:	50 2b       	stdsp	sp[0x8],r11
80008228:	c3 c8       	rjmp	800082a0 <_vfprintf_r+0x3cc>
8000822a:	fa c8 f9 50 	sub	r8,sp,-1712
8000822e:	1a d8       	st.w	--sp,r8
80008230:	fa c8 fa b8 	sub	r8,sp,-1352
80008234:	1a d8       	st.w	--sp,r8
80008236:	fa c8 fb b4 	sub	r8,sp,-1100
8000823a:	02 9a       	mov	r10,r1
8000823c:	1a d8       	st.w	--sp,r8
8000823e:	04 9c       	mov	r12,r2
80008240:	fa c8 f9 40 	sub	r8,sp,-1728
80008244:	fa c9 ff b4 	sub	r9,sp,-76
80008248:	fe b0 fc ae 	rcall	80007ba4 <get_arg>
8000824c:	2f dd       	sub	sp,-12
8000824e:	78 0c       	ld.w	r12,r12[0x0]
80008250:	50 2c       	stdsp	sp[0x8],r12
80008252:	c2 78       	rjmp	800082a0 <_vfprintf_r+0x3cc>
80008254:	12 96       	mov	r6,r9
80008256:	0e 94       	mov	r4,r7
80008258:	fa c9 f9 44 	sub	r9,sp,-1724
8000825c:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008260:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008264:	50 28       	stdsp	sp[0x8],r8
80008266:	c1 d8       	rjmp	800082a0 <_vfprintf_r+0x3cc>
80008268:	41 08       	lddsp	r8,sp[0x40]
8000826a:	59 fa       	cp.w	r10,31
8000826c:	e0 89 00 14 	brgt	80008294 <_vfprintf_r+0x3c0>
80008270:	f0 cb ff fc 	sub	r11,r8,-4
80008274:	70 08       	ld.w	r8,r8[0x0]
80008276:	51 0b       	stdsp	sp[0x40],r11
80008278:	50 28       	stdsp	sp[0x8],r8
8000827a:	fa c6 f9 44 	sub	r6,sp,-1724
8000827e:	40 2e       	lddsp	lr,sp[0x8]
80008280:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008284:	f1 4e fd 88 	st.w	r8[-632],lr
80008288:	2f fa       	sub	r10,-1
8000828a:	0e 94       	mov	r4,r7
8000828c:	fb 4a 06 b4 	st.w	sp[1716],r10
80008290:	12 96       	mov	r6,r9
80008292:	c0 78       	rjmp	800082a0 <_vfprintf_r+0x3cc>
80008294:	70 0c       	ld.w	r12,r8[0x0]
80008296:	0e 94       	mov	r4,r7
80008298:	2f c8       	sub	r8,-4
8000829a:	50 2c       	stdsp	sp[0x8],r12
8000829c:	12 96       	mov	r6,r9
8000829e:	51 08       	stdsp	sp[0x40],r8
800082a0:	40 2b       	lddsp	r11,sp[0x8]
800082a2:	58 0b       	cp.w	r11,0
800082a4:	fe 95 fe f2 	brlt	80008088 <_vfprintf_r+0x1b4>
800082a8:	08 97       	mov	r7,r4
800082aa:	cf 5a       	rjmp	80008094 <_vfprintf_r+0x1c0>
800082ac:	f2 09 00 29 	add	r9,r9,r9<<0x2
800082b0:	0f 38       	ld.ub	r8,r7++
800082b2:	f4 09 00 19 	add	r9,r10,r9<<0x1
800082b6:	f0 ca 00 30 	sub	r10,r8,48
800082ba:	58 9a       	cp.w	r10,9
800082bc:	fe 98 ff f8 	brls	800082ac <_vfprintf_r+0x3d8>
800082c0:	3f fa       	mov	r10,-1
800082c2:	f2 0a 0c 49 	max	r9,r9,r10
800082c6:	50 29       	stdsp	sp[0x8],r9
800082c8:	ce 9a       	rjmp	8000809a <_vfprintf_r+0x1c6>
800082ca:	a7 b5       	sbr	r5,0x7
800082cc:	ce 4a       	rjmp	80008094 <_vfprintf_r+0x1c0>
800082ce:	30 09       	mov	r9,0
800082d0:	23 08       	sub	r8,48
800082d2:	f2 09 00 29 	add	r9,r9,r9<<0x2
800082d6:	f0 09 00 19 	add	r9,r8,r9<<0x1
800082da:	0f 38       	ld.ub	r8,r7++
800082dc:	f0 ca 00 30 	sub	r10,r8,48
800082e0:	58 9a       	cp.w	r10,9
800082e2:	fe 98 ff f7 	brls	800082d0 <_vfprintf_r+0x3fc>
800082e6:	e0 48 00 24 	cp.w	r8,36
800082ea:	fe 91 fe d7 	brne	80008098 <_vfprintf_r+0x1c4>
800082ee:	e0 49 00 20 	cp.w	r9,32
800082f2:	e0 89 0d 6f 	brgt	80009dd0 <_vfprintf_r+0x1efc>
800082f6:	f2 c3 00 01 	sub	r3,r9,1
800082fa:	30 19       	mov	r9,1
800082fc:	50 39       	stdsp	sp[0xc],r9
800082fe:	cc ba       	rjmp	80008094 <_vfprintf_r+0x1c0>
80008300:	a3 b5       	sbr	r5,0x3
80008302:	cc 9a       	rjmp	80008094 <_vfprintf_r+0x1c0>
80008304:	a7 a5       	sbr	r5,0x6
80008306:	cc 7a       	rjmp	80008094 <_vfprintf_r+0x1c0>
80008308:	0a 98       	mov	r8,r5
8000830a:	a5 b5       	sbr	r5,0x5
8000830c:	a5 a8       	sbr	r8,0x4
8000830e:	0f 89       	ld.ub	r9,r7[0x0]
80008310:	36 ce       	mov	lr,108
80008312:	fc 09 18 00 	cp.b	r9,lr
80008316:	f7 b7 00 ff 	subeq	r7,-1
8000831a:	f0 05 17 10 	movne	r5,r8
8000831e:	cb ba       	rjmp	80008094 <_vfprintf_r+0x1c0>
80008320:	a5 b5       	sbr	r5,0x5
80008322:	cb 9a       	rjmp	80008094 <_vfprintf_r+0x1c0>
80008324:	50 a7       	stdsp	sp[0x28],r7
80008326:	50 80       	stdsp	sp[0x20],r0
80008328:	0c 97       	mov	r7,r6
8000832a:	10 90       	mov	r0,r8
8000832c:	06 96       	mov	r6,r3
8000832e:	04 94       	mov	r4,r2
80008330:	40 93       	lddsp	r3,sp[0x24]
80008332:	02 92       	mov	r2,r1
80008334:	0e 99       	mov	r9,r7
80008336:	40 41       	lddsp	r1,sp[0x10]
80008338:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000833c:	40 3c       	lddsp	r12,sp[0xc]
8000833e:	58 0c       	cp.w	r12,0
80008340:	c1 d0       	breq	8000837a <_vfprintf_r+0x4a6>
80008342:	10 36       	cp.w	r6,r8
80008344:	c0 64       	brge	80008350 <_vfprintf_r+0x47c>
80008346:	fa cb f9 44 	sub	r11,sp,-1724
8000834a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000834e:	c1 d8       	rjmp	80008388 <_vfprintf_r+0x4b4>
80008350:	fa c8 f9 50 	sub	r8,sp,-1712
80008354:	1a d8       	st.w	--sp,r8
80008356:	fa c8 fa b8 	sub	r8,sp,-1352
8000835a:	1a d8       	st.w	--sp,r8
8000835c:	fa c8 fb b4 	sub	r8,sp,-1100
80008360:	1a d8       	st.w	--sp,r8
80008362:	fa c8 f9 40 	sub	r8,sp,-1728
80008366:	fa c9 ff b4 	sub	r9,sp,-76
8000836a:	04 9a       	mov	r10,r2
8000836c:	0c 9b       	mov	r11,r6
8000836e:	08 9c       	mov	r12,r4
80008370:	fe b0 fc 1a 	rcall	80007ba4 <get_arg>
80008374:	2f dd       	sub	sp,-12
80008376:	19 b8       	ld.ub	r8,r12[0x3]
80008378:	c2 28       	rjmp	800083bc <_vfprintf_r+0x4e8>
8000837a:	2f f7       	sub	r7,-1
8000837c:	10 39       	cp.w	r9,r8
8000837e:	c0 84       	brge	8000838e <_vfprintf_r+0x4ba>
80008380:	fa ca f9 44 	sub	r10,sp,-1724
80008384:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008388:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000838c:	c1 88       	rjmp	800083bc <_vfprintf_r+0x4e8>
8000838e:	41 09       	lddsp	r9,sp[0x40]
80008390:	59 f8       	cp.w	r8,31
80008392:	e0 89 00 12 	brgt	800083b6 <_vfprintf_r+0x4e2>
80008396:	f2 ca ff fc 	sub	r10,r9,-4
8000839a:	51 0a       	stdsp	sp[0x40],r10
8000839c:	72 09       	ld.w	r9,r9[0x0]
8000839e:	fa c6 f9 44 	sub	r6,sp,-1724
800083a2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800083a6:	2f f8       	sub	r8,-1
800083a8:	f5 49 fd 88 	st.w	r10[-632],r9
800083ac:	fb 48 06 b4 	st.w	sp[1716],r8
800083b0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800083b4:	c0 48       	rjmp	800083bc <_vfprintf_r+0x4e8>
800083b6:	13 b8       	ld.ub	r8,r9[0x3]
800083b8:	2f c9       	sub	r9,-4
800083ba:	51 09       	stdsp	sp[0x40],r9
800083bc:	fb 68 06 60 	st.b	sp[1632],r8
800083c0:	30 0e       	mov	lr,0
800083c2:	30 08       	mov	r8,0
800083c4:	30 12       	mov	r2,1
800083c6:	fb 68 06 bb 	st.b	sp[1723],r8
800083ca:	50 2e       	stdsp	sp[0x8],lr
800083cc:	e0 8f 08 ad 	bral	80009526 <_vfprintf_r+0x1652>
800083d0:	50 a7       	stdsp	sp[0x28],r7
800083d2:	50 80       	stdsp	sp[0x20],r0
800083d4:	0c 97       	mov	r7,r6
800083d6:	04 94       	mov	r4,r2
800083d8:	06 96       	mov	r6,r3
800083da:	02 92       	mov	r2,r1
800083dc:	40 93       	lddsp	r3,sp[0x24]
800083de:	10 90       	mov	r0,r8
800083e0:	40 41       	lddsp	r1,sp[0x10]
800083e2:	a5 a5       	sbr	r5,0x4
800083e4:	c0 a8       	rjmp	800083f8 <_vfprintf_r+0x524>
800083e6:	50 a7       	stdsp	sp[0x28],r7
800083e8:	50 80       	stdsp	sp[0x20],r0
800083ea:	0c 97       	mov	r7,r6
800083ec:	04 94       	mov	r4,r2
800083ee:	06 96       	mov	r6,r3
800083f0:	02 92       	mov	r2,r1
800083f2:	40 93       	lddsp	r3,sp[0x24]
800083f4:	10 90       	mov	r0,r8
800083f6:	40 41       	lddsp	r1,sp[0x10]
800083f8:	ed b5 00 05 	bld	r5,0x5
800083fc:	c5 11       	brne	8000849e <_vfprintf_r+0x5ca>
800083fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008402:	40 3c       	lddsp	r12,sp[0xc]
80008404:	58 0c       	cp.w	r12,0
80008406:	c1 e0       	breq	80008442 <_vfprintf_r+0x56e>
80008408:	10 36       	cp.w	r6,r8
8000840a:	c0 64       	brge	80008416 <_vfprintf_r+0x542>
8000840c:	fa cb f9 44 	sub	r11,sp,-1724
80008410:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008414:	c2 08       	rjmp	80008454 <_vfprintf_r+0x580>
80008416:	fa c8 f9 50 	sub	r8,sp,-1712
8000841a:	1a d8       	st.w	--sp,r8
8000841c:	fa c8 fa b8 	sub	r8,sp,-1352
80008420:	0c 9b       	mov	r11,r6
80008422:	1a d8       	st.w	--sp,r8
80008424:	fa c8 fb b4 	sub	r8,sp,-1100
80008428:	1a d8       	st.w	--sp,r8
8000842a:	fa c9 ff b4 	sub	r9,sp,-76
8000842e:	fa c8 f9 40 	sub	r8,sp,-1728
80008432:	04 9a       	mov	r10,r2
80008434:	08 9c       	mov	r12,r4
80008436:	fe b0 fb b7 	rcall	80007ba4 <get_arg>
8000843a:	2f dd       	sub	sp,-12
8000843c:	78 1b       	ld.w	r11,r12[0x4]
8000843e:	78 09       	ld.w	r9,r12[0x0]
80008440:	c2 b8       	rjmp	80008496 <_vfprintf_r+0x5c2>
80008442:	ee ca ff ff 	sub	r10,r7,-1
80008446:	10 37       	cp.w	r7,r8
80008448:	c0 b4       	brge	8000845e <_vfprintf_r+0x58a>
8000844a:	fa c9 f9 44 	sub	r9,sp,-1724
8000844e:	14 97       	mov	r7,r10
80008450:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008454:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008458:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000845c:	c1 d8       	rjmp	80008496 <_vfprintf_r+0x5c2>
8000845e:	41 09       	lddsp	r9,sp[0x40]
80008460:	59 f8       	cp.w	r8,31
80008462:	e0 89 00 14 	brgt	8000848a <_vfprintf_r+0x5b6>
80008466:	f2 cb ff f8 	sub	r11,r9,-8
8000846a:	51 0b       	stdsp	sp[0x40],r11
8000846c:	fa c6 f9 44 	sub	r6,sp,-1724
80008470:	72 1b       	ld.w	r11,r9[0x4]
80008472:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008476:	72 09       	ld.w	r9,r9[0x0]
80008478:	f9 4b fd 8c 	st.w	r12[-628],r11
8000847c:	f9 49 fd 88 	st.w	r12[-632],r9
80008480:	2f f8       	sub	r8,-1
80008482:	14 97       	mov	r7,r10
80008484:	fb 48 06 b4 	st.w	sp[1716],r8
80008488:	c0 78       	rjmp	80008496 <_vfprintf_r+0x5c2>
8000848a:	f2 c8 ff f8 	sub	r8,r9,-8
8000848e:	72 1b       	ld.w	r11,r9[0x4]
80008490:	14 97       	mov	r7,r10
80008492:	51 08       	stdsp	sp[0x40],r8
80008494:	72 09       	ld.w	r9,r9[0x0]
80008496:	16 98       	mov	r8,r11
80008498:	fa e9 00 00 	st.d	sp[0],r8
8000849c:	ca e8       	rjmp	800085f8 <_vfprintf_r+0x724>
8000849e:	ed b5 00 04 	bld	r5,0x4
800084a2:	c1 71       	brne	800084d0 <_vfprintf_r+0x5fc>
800084a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084a8:	40 3e       	lddsp	lr,sp[0xc]
800084aa:	58 0e       	cp.w	lr,0
800084ac:	c0 80       	breq	800084bc <_vfprintf_r+0x5e8>
800084ae:	10 36       	cp.w	r6,r8
800084b0:	c6 94       	brge	80008582 <_vfprintf_r+0x6ae>
800084b2:	fa cc f9 44 	sub	r12,sp,-1724
800084b6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800084ba:	c8 28       	rjmp	800085be <_vfprintf_r+0x6ea>
800084bc:	ee ca ff ff 	sub	r10,r7,-1
800084c0:	10 37       	cp.w	r7,r8
800084c2:	e0 84 00 81 	brge	800085c4 <_vfprintf_r+0x6f0>
800084c6:	fa cb f9 44 	sub	r11,sp,-1724
800084ca:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084ce:	c7 78       	rjmp	800085bc <_vfprintf_r+0x6e8>
800084d0:	ed b5 00 06 	bld	r5,0x6
800084d4:	c4 b1       	brne	8000856a <_vfprintf_r+0x696>
800084d6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084da:	40 3c       	lddsp	r12,sp[0xc]
800084dc:	58 0c       	cp.w	r12,0
800084de:	c1 d0       	breq	80008518 <_vfprintf_r+0x644>
800084e0:	10 36       	cp.w	r6,r8
800084e2:	c0 64       	brge	800084ee <_vfprintf_r+0x61a>
800084e4:	fa cb f9 44 	sub	r11,sp,-1724
800084e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084ec:	c1 f8       	rjmp	8000852a <_vfprintf_r+0x656>
800084ee:	fa c8 f9 50 	sub	r8,sp,-1712
800084f2:	1a d8       	st.w	--sp,r8
800084f4:	fa c8 fa b8 	sub	r8,sp,-1352
800084f8:	1a d8       	st.w	--sp,r8
800084fa:	fa c8 fb b4 	sub	r8,sp,-1100
800084fe:	1a d8       	st.w	--sp,r8
80008500:	fa c8 f9 40 	sub	r8,sp,-1728
80008504:	fa c9 ff b4 	sub	r9,sp,-76
80008508:	04 9a       	mov	r10,r2
8000850a:	0c 9b       	mov	r11,r6
8000850c:	08 9c       	mov	r12,r4
8000850e:	fe b0 fb 4b 	rcall	80007ba4 <get_arg>
80008512:	2f dd       	sub	sp,-12
80008514:	98 18       	ld.sh	r8,r12[0x2]
80008516:	c2 68       	rjmp	80008562 <_vfprintf_r+0x68e>
80008518:	ee ca ff ff 	sub	r10,r7,-1
8000851c:	10 37       	cp.w	r7,r8
8000851e:	c0 94       	brge	80008530 <_vfprintf_r+0x65c>
80008520:	fa c9 f9 44 	sub	r9,sp,-1724
80008524:	14 97       	mov	r7,r10
80008526:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000852a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000852e:	c1 a8       	rjmp	80008562 <_vfprintf_r+0x68e>
80008530:	41 09       	lddsp	r9,sp[0x40]
80008532:	59 f8       	cp.w	r8,31
80008534:	e0 89 00 13 	brgt	8000855a <_vfprintf_r+0x686>
80008538:	f2 cb ff fc 	sub	r11,r9,-4
8000853c:	51 0b       	stdsp	sp[0x40],r11
8000853e:	72 09       	ld.w	r9,r9[0x0]
80008540:	fa c6 f9 44 	sub	r6,sp,-1724
80008544:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008548:	2f f8       	sub	r8,-1
8000854a:	f7 49 fd 88 	st.w	r11[-632],r9
8000854e:	fb 48 06 b4 	st.w	sp[1716],r8
80008552:	14 97       	mov	r7,r10
80008554:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008558:	c0 58       	rjmp	80008562 <_vfprintf_r+0x68e>
8000855a:	92 18       	ld.sh	r8,r9[0x2]
8000855c:	14 97       	mov	r7,r10
8000855e:	2f c9       	sub	r9,-4
80008560:	51 09       	stdsp	sp[0x40],r9
80008562:	50 18       	stdsp	sp[0x4],r8
80008564:	bf 58       	asr	r8,0x1f
80008566:	50 08       	stdsp	sp[0x0],r8
80008568:	c4 88       	rjmp	800085f8 <_vfprintf_r+0x724>
8000856a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000856e:	40 3c       	lddsp	r12,sp[0xc]
80008570:	58 0c       	cp.w	r12,0
80008572:	c1 d0       	breq	800085ac <_vfprintf_r+0x6d8>
80008574:	10 36       	cp.w	r6,r8
80008576:	c0 64       	brge	80008582 <_vfprintf_r+0x6ae>
80008578:	fa cb f9 44 	sub	r11,sp,-1724
8000857c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008580:	c1 f8       	rjmp	800085be <_vfprintf_r+0x6ea>
80008582:	fa c8 f9 50 	sub	r8,sp,-1712
80008586:	1a d8       	st.w	--sp,r8
80008588:	fa c8 fa b8 	sub	r8,sp,-1352
8000858c:	0c 9b       	mov	r11,r6
8000858e:	1a d8       	st.w	--sp,r8
80008590:	fa c8 fb b4 	sub	r8,sp,-1100
80008594:	04 9a       	mov	r10,r2
80008596:	1a d8       	st.w	--sp,r8
80008598:	08 9c       	mov	r12,r4
8000859a:	fa c8 f9 40 	sub	r8,sp,-1728
8000859e:	fa c9 ff b4 	sub	r9,sp,-76
800085a2:	fe b0 fb 01 	rcall	80007ba4 <get_arg>
800085a6:	2f dd       	sub	sp,-12
800085a8:	78 0b       	ld.w	r11,r12[0x0]
800085aa:	c2 48       	rjmp	800085f2 <_vfprintf_r+0x71e>
800085ac:	ee ca ff ff 	sub	r10,r7,-1
800085b0:	10 37       	cp.w	r7,r8
800085b2:	c0 94       	brge	800085c4 <_vfprintf_r+0x6f0>
800085b4:	fa c9 f9 44 	sub	r9,sp,-1724
800085b8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085bc:	14 97       	mov	r7,r10
800085be:	ec fb fd 88 	ld.w	r11,r6[-632]
800085c2:	c1 88       	rjmp	800085f2 <_vfprintf_r+0x71e>
800085c4:	41 09       	lddsp	r9,sp[0x40]
800085c6:	59 f8       	cp.w	r8,31
800085c8:	e0 89 00 11 	brgt	800085ea <_vfprintf_r+0x716>
800085cc:	f2 cb ff fc 	sub	r11,r9,-4
800085d0:	51 0b       	stdsp	sp[0x40],r11
800085d2:	fa c6 f9 44 	sub	r6,sp,-1724
800085d6:	72 0b       	ld.w	r11,r9[0x0]
800085d8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085dc:	f3 4b fd 88 	st.w	r9[-632],r11
800085e0:	2f f8       	sub	r8,-1
800085e2:	14 97       	mov	r7,r10
800085e4:	fb 48 06 b4 	st.w	sp[1716],r8
800085e8:	c0 58       	rjmp	800085f2 <_vfprintf_r+0x71e>
800085ea:	72 0b       	ld.w	r11,r9[0x0]
800085ec:	14 97       	mov	r7,r10
800085ee:	2f c9       	sub	r9,-4
800085f0:	51 09       	stdsp	sp[0x40],r9
800085f2:	50 1b       	stdsp	sp[0x4],r11
800085f4:	bf 5b       	asr	r11,0x1f
800085f6:	50 0b       	stdsp	sp[0x0],r11
800085f8:	fa ea 00 00 	ld.d	r10,sp[0]
800085fc:	58 0a       	cp.w	r10,0
800085fe:	5c 2b       	cpc	r11
80008600:	c0 e4       	brge	8000861c <_vfprintf_r+0x748>
80008602:	30 08       	mov	r8,0
80008604:	fa ea 00 00 	ld.d	r10,sp[0]
80008608:	30 09       	mov	r9,0
8000860a:	f0 0a 01 0a 	sub	r10,r8,r10
8000860e:	f2 0b 01 4b 	sbc	r11,r9,r11
80008612:	32 d8       	mov	r8,45
80008614:	fa eb 00 00 	st.d	sp[0],r10
80008618:	fb 68 06 bb 	st.b	sp[1723],r8
8000861c:	30 18       	mov	r8,1
8000861e:	e0 8f 06 fa 	bral	80009412 <_vfprintf_r+0x153e>
80008622:	50 a7       	stdsp	sp[0x28],r7
80008624:	50 80       	stdsp	sp[0x20],r0
80008626:	0c 97       	mov	r7,r6
80008628:	04 94       	mov	r4,r2
8000862a:	06 96       	mov	r6,r3
8000862c:	02 92       	mov	r2,r1
8000862e:	40 93       	lddsp	r3,sp[0x24]
80008630:	10 90       	mov	r0,r8
80008632:	40 41       	lddsp	r1,sp[0x10]
80008634:	0e 99       	mov	r9,r7
80008636:	ed b5 00 03 	bld	r5,0x3
8000863a:	c4 11       	brne	800086bc <_vfprintf_r+0x7e8>
8000863c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008640:	40 3a       	lddsp	r10,sp[0xc]
80008642:	58 0a       	cp.w	r10,0
80008644:	c1 90       	breq	80008676 <_vfprintf_r+0x7a2>
80008646:	10 36       	cp.w	r6,r8
80008648:	c6 45       	brlt	80008710 <_vfprintf_r+0x83c>
8000864a:	fa c8 f9 50 	sub	r8,sp,-1712
8000864e:	1a d8       	st.w	--sp,r8
80008650:	fa c8 fa b8 	sub	r8,sp,-1352
80008654:	1a d8       	st.w	--sp,r8
80008656:	fa c8 fb b4 	sub	r8,sp,-1100
8000865a:	0c 9b       	mov	r11,r6
8000865c:	1a d8       	st.w	--sp,r8
8000865e:	04 9a       	mov	r10,r2
80008660:	fa c8 f9 40 	sub	r8,sp,-1728
80008664:	fa c9 ff b4 	sub	r9,sp,-76
80008668:	08 9c       	mov	r12,r4
8000866a:	fe b0 fa 9d 	rcall	80007ba4 <get_arg>
8000866e:	2f dd       	sub	sp,-12
80008670:	78 16       	ld.w	r6,r12[0x4]
80008672:	50 76       	stdsp	sp[0x1c],r6
80008674:	c4 88       	rjmp	80008704 <_vfprintf_r+0x830>
80008676:	2f f7       	sub	r7,-1
80008678:	10 39       	cp.w	r9,r8
8000867a:	c0 c4       	brge	80008692 <_vfprintf_r+0x7be>
8000867c:	fa ce f9 44 	sub	lr,sp,-1724
80008680:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008684:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008688:	50 7c       	stdsp	sp[0x1c],r12
8000868a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000868e:	50 56       	stdsp	sp[0x14],r6
80008690:	c6 68       	rjmp	8000875c <_vfprintf_r+0x888>
80008692:	41 09       	lddsp	r9,sp[0x40]
80008694:	59 f8       	cp.w	r8,31
80008696:	e0 89 00 10 	brgt	800086b6 <_vfprintf_r+0x7e2>
8000869a:	f2 ca ff f8 	sub	r10,r9,-8
8000869e:	72 1b       	ld.w	r11,r9[0x4]
800086a0:	51 0a       	stdsp	sp[0x40],r10
800086a2:	72 09       	ld.w	r9,r9[0x0]
800086a4:	fa ca f9 44 	sub	r10,sp,-1724
800086a8:	50 7b       	stdsp	sp[0x1c],r11
800086aa:	50 59       	stdsp	sp[0x14],r9
800086ac:	f4 08 00 39 	add	r9,r10,r8<<0x3
800086b0:	40 5b       	lddsp	r11,sp[0x14]
800086b2:	40 7a       	lddsp	r10,sp[0x1c]
800086b4:	c4 78       	rjmp	80008742 <_vfprintf_r+0x86e>
800086b6:	72 18       	ld.w	r8,r9[0x4]
800086b8:	50 78       	stdsp	sp[0x1c],r8
800086ba:	c4 c8       	rjmp	80008752 <_vfprintf_r+0x87e>
800086bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086c0:	40 3e       	lddsp	lr,sp[0xc]
800086c2:	58 0e       	cp.w	lr,0
800086c4:	c2 30       	breq	8000870a <_vfprintf_r+0x836>
800086c6:	10 36       	cp.w	r6,r8
800086c8:	c0 94       	brge	800086da <_vfprintf_r+0x806>
800086ca:	fa cc f9 44 	sub	r12,sp,-1724
800086ce:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086d2:	ec fb fd 8c 	ld.w	r11,r6[-628]
800086d6:	50 7b       	stdsp	sp[0x1c],r11
800086d8:	cd 9b       	rjmp	8000868a <_vfprintf_r+0x7b6>
800086da:	fa c8 f9 50 	sub	r8,sp,-1712
800086de:	1a d8       	st.w	--sp,r8
800086e0:	fa c8 fa b8 	sub	r8,sp,-1352
800086e4:	04 9a       	mov	r10,r2
800086e6:	1a d8       	st.w	--sp,r8
800086e8:	fa c8 fb b4 	sub	r8,sp,-1100
800086ec:	0c 9b       	mov	r11,r6
800086ee:	1a d8       	st.w	--sp,r8
800086f0:	08 9c       	mov	r12,r4
800086f2:	fa c8 f9 40 	sub	r8,sp,-1728
800086f6:	fa c9 ff b4 	sub	r9,sp,-76
800086fa:	fe b0 fa 55 	rcall	80007ba4 <get_arg>
800086fe:	2f dd       	sub	sp,-12
80008700:	78 1a       	ld.w	r10,r12[0x4]
80008702:	50 7a       	stdsp	sp[0x1c],r10
80008704:	78 0c       	ld.w	r12,r12[0x0]
80008706:	50 5c       	stdsp	sp[0x14],r12
80008708:	c2 a8       	rjmp	8000875c <_vfprintf_r+0x888>
8000870a:	2f f7       	sub	r7,-1
8000870c:	10 39       	cp.w	r9,r8
8000870e:	c0 94       	brge	80008720 <_vfprintf_r+0x84c>
80008710:	fa c9 f9 44 	sub	r9,sp,-1724
80008714:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008718:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000871c:	50 78       	stdsp	sp[0x1c],r8
8000871e:	cb 6b       	rjmp	8000868a <_vfprintf_r+0x7b6>
80008720:	41 09       	lddsp	r9,sp[0x40]
80008722:	59 f8       	cp.w	r8,31
80008724:	e0 89 00 15 	brgt	8000874e <_vfprintf_r+0x87a>
80008728:	f2 ca ff f8 	sub	r10,r9,-8
8000872c:	72 16       	ld.w	r6,r9[0x4]
8000872e:	72 09       	ld.w	r9,r9[0x0]
80008730:	51 0a       	stdsp	sp[0x40],r10
80008732:	50 59       	stdsp	sp[0x14],r9
80008734:	fa ce f9 44 	sub	lr,sp,-1724
80008738:	50 76       	stdsp	sp[0x1c],r6
8000873a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000873e:	40 5b       	lddsp	r11,sp[0x14]
80008740:	0c 9a       	mov	r10,r6
80008742:	f2 eb fd 88 	st.d	r9[-632],r10
80008746:	2f f8       	sub	r8,-1
80008748:	fb 48 06 b4 	st.w	sp[1716],r8
8000874c:	c0 88       	rjmp	8000875c <_vfprintf_r+0x888>
8000874e:	72 1c       	ld.w	r12,r9[0x4]
80008750:	50 7c       	stdsp	sp[0x1c],r12
80008752:	f2 c8 ff f8 	sub	r8,r9,-8
80008756:	51 08       	stdsp	sp[0x40],r8
80008758:	72 09       	ld.w	r9,r9[0x0]
8000875a:	50 59       	stdsp	sp[0x14],r9
8000875c:	40 5b       	lddsp	r11,sp[0x14]
8000875e:	40 7a       	lddsp	r10,sp[0x1c]
80008760:	e0 a0 19 54 	rcall	8000ba08 <__isinfd>
80008764:	18 96       	mov	r6,r12
80008766:	c1 70       	breq	80008794 <_vfprintf_r+0x8c0>
80008768:	30 08       	mov	r8,0
8000876a:	30 09       	mov	r9,0
8000876c:	40 5b       	lddsp	r11,sp[0x14]
8000876e:	40 7a       	lddsp	r10,sp[0x1c]
80008770:	e0 a0 1d b4 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
80008774:	c0 40       	breq	8000877c <_vfprintf_r+0x8a8>
80008776:	32 d8       	mov	r8,45
80008778:	fb 68 06 bb 	st.b	sp[1723],r8
8000877c:	fe c8 a9 e4 	sub	r8,pc,-22044
80008780:	fe c6 a9 e4 	sub	r6,pc,-22044
80008784:	a7 d5       	cbr	r5,0x7
80008786:	e0 40 00 47 	cp.w	r0,71
8000878a:	f0 06 17 a0 	movle	r6,r8
8000878e:	30 32       	mov	r2,3
80008790:	e0 8f 06 ce 	bral	8000952c <_vfprintf_r+0x1658>
80008794:	40 5b       	lddsp	r11,sp[0x14]
80008796:	40 7a       	lddsp	r10,sp[0x1c]
80008798:	e0 a0 19 4d 	rcall	8000ba32 <__isnand>
8000879c:	c0 e0       	breq	800087b8 <_vfprintf_r+0x8e4>
8000879e:	50 26       	stdsp	sp[0x8],r6
800087a0:	fe c8 aa 00 	sub	r8,pc,-22016
800087a4:	fe c6 aa 00 	sub	r6,pc,-22016
800087a8:	a7 d5       	cbr	r5,0x7
800087aa:	e0 40 00 47 	cp.w	r0,71
800087ae:	f0 06 17 a0 	movle	r6,r8
800087b2:	30 32       	mov	r2,3
800087b4:	e0 8f 06 c2 	bral	80009538 <_vfprintf_r+0x1664>
800087b8:	40 2a       	lddsp	r10,sp[0x8]
800087ba:	5b fa       	cp.w	r10,-1
800087bc:	c0 41       	brne	800087c4 <_vfprintf_r+0x8f0>
800087be:	30 69       	mov	r9,6
800087c0:	50 29       	stdsp	sp[0x8],r9
800087c2:	c1 18       	rjmp	800087e4 <_vfprintf_r+0x910>
800087c4:	e0 40 00 47 	cp.w	r0,71
800087c8:	5f 09       	sreq	r9
800087ca:	e0 40 00 67 	cp.w	r0,103
800087ce:	5f 08       	sreq	r8
800087d0:	f3 e8 10 08 	or	r8,r9,r8
800087d4:	f8 08 18 00 	cp.b	r8,r12
800087d8:	c0 60       	breq	800087e4 <_vfprintf_r+0x910>
800087da:	40 28       	lddsp	r8,sp[0x8]
800087dc:	58 08       	cp.w	r8,0
800087de:	f9 b8 00 01 	moveq	r8,1
800087e2:	50 28       	stdsp	sp[0x8],r8
800087e4:	40 78       	lddsp	r8,sp[0x1c]
800087e6:	40 59       	lddsp	r9,sp[0x14]
800087e8:	fa e9 06 94 	st.d	sp[1684],r8
800087ec:	a9 a5       	sbr	r5,0x8
800087ee:	fa f8 06 94 	ld.w	r8,sp[1684]
800087f2:	58 08       	cp.w	r8,0
800087f4:	c0 65       	brlt	80008800 <_vfprintf_r+0x92c>
800087f6:	40 5e       	lddsp	lr,sp[0x14]
800087f8:	30 0c       	mov	r12,0
800087fa:	50 6e       	stdsp	sp[0x18],lr
800087fc:	50 9c       	stdsp	sp[0x24],r12
800087fe:	c0 78       	rjmp	8000880c <_vfprintf_r+0x938>
80008800:	40 5b       	lddsp	r11,sp[0x14]
80008802:	32 da       	mov	r10,45
80008804:	ee 1b 80 00 	eorh	r11,0x8000
80008808:	50 9a       	stdsp	sp[0x24],r10
8000880a:	50 6b       	stdsp	sp[0x18],r11
8000880c:	e0 40 00 46 	cp.w	r0,70
80008810:	5f 09       	sreq	r9
80008812:	e0 40 00 66 	cp.w	r0,102
80008816:	5f 08       	sreq	r8
80008818:	f3 e8 10 08 	or	r8,r9,r8
8000881c:	50 48       	stdsp	sp[0x10],r8
8000881e:	c0 40       	breq	80008826 <_vfprintf_r+0x952>
80008820:	40 22       	lddsp	r2,sp[0x8]
80008822:	30 39       	mov	r9,3
80008824:	c1 08       	rjmp	80008844 <_vfprintf_r+0x970>
80008826:	e0 40 00 45 	cp.w	r0,69
8000882a:	5f 09       	sreq	r9
8000882c:	e0 40 00 65 	cp.w	r0,101
80008830:	5f 08       	sreq	r8
80008832:	40 22       	lddsp	r2,sp[0x8]
80008834:	10 49       	or	r9,r8
80008836:	2f f2       	sub	r2,-1
80008838:	40 46       	lddsp	r6,sp[0x10]
8000883a:	ec 09 18 00 	cp.b	r9,r6
8000883e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008842:	30 29       	mov	r9,2
80008844:	fa c8 f9 5c 	sub	r8,sp,-1700
80008848:	1a d8       	st.w	--sp,r8
8000884a:	fa c8 f9 54 	sub	r8,sp,-1708
8000884e:	1a d8       	st.w	--sp,r8
80008850:	fa c8 f9 4c 	sub	r8,sp,-1716
80008854:	08 9c       	mov	r12,r4
80008856:	1a d8       	st.w	--sp,r8
80008858:	04 98       	mov	r8,r2
8000885a:	40 9b       	lddsp	r11,sp[0x24]
8000885c:	40 aa       	lddsp	r10,sp[0x28]
8000885e:	e0 a0 0b c3 	rcall	80009fe4 <_dtoa_r>
80008862:	e0 40 00 47 	cp.w	r0,71
80008866:	5f 19       	srne	r9
80008868:	e0 40 00 67 	cp.w	r0,103
8000886c:	5f 18       	srne	r8
8000886e:	18 96       	mov	r6,r12
80008870:	2f dd       	sub	sp,-12
80008872:	f3 e8 00 08 	and	r8,r9,r8
80008876:	c0 41       	brne	8000887e <_vfprintf_r+0x9aa>
80008878:	ed b5 00 00 	bld	r5,0x0
8000887c:	c3 01       	brne	800088dc <_vfprintf_r+0xa08>
8000887e:	ec 02 00 0e 	add	lr,r6,r2
80008882:	50 3e       	stdsp	sp[0xc],lr
80008884:	40 4c       	lddsp	r12,sp[0x10]
80008886:	58 0c       	cp.w	r12,0
80008888:	c1 50       	breq	800088b2 <_vfprintf_r+0x9de>
8000888a:	0d 89       	ld.ub	r9,r6[0x0]
8000888c:	33 08       	mov	r8,48
8000888e:	f0 09 18 00 	cp.b	r9,r8
80008892:	c0 b1       	brne	800088a8 <_vfprintf_r+0x9d4>
80008894:	30 08       	mov	r8,0
80008896:	30 09       	mov	r9,0
80008898:	40 6b       	lddsp	r11,sp[0x18]
8000889a:	40 7a       	lddsp	r10,sp[0x1c]
8000889c:	e0 a0 1c d7 	rcall	8000c24a <__avr32_f64_cmp_eq>
800088a0:	fb b2 00 01 	rsubeq	r2,1
800088a4:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800088a8:	40 3b       	lddsp	r11,sp[0xc]
800088aa:	fa f8 06 ac 	ld.w	r8,sp[1708]
800088ae:	10 0b       	add	r11,r8
800088b0:	50 3b       	stdsp	sp[0xc],r11
800088b2:	40 6b       	lddsp	r11,sp[0x18]
800088b4:	30 08       	mov	r8,0
800088b6:	30 09       	mov	r9,0
800088b8:	40 7a       	lddsp	r10,sp[0x1c]
800088ba:	e0 a0 1c c8 	rcall	8000c24a <__avr32_f64_cmp_eq>
800088be:	c0 90       	breq	800088d0 <_vfprintf_r+0x9fc>
800088c0:	40 3a       	lddsp	r10,sp[0xc]
800088c2:	fb 4a 06 a4 	st.w	sp[1700],r10
800088c6:	c0 58       	rjmp	800088d0 <_vfprintf_r+0x9fc>
800088c8:	10 c9       	st.b	r8++,r9
800088ca:	fb 48 06 a4 	st.w	sp[1700],r8
800088ce:	c0 28       	rjmp	800088d2 <_vfprintf_r+0x9fe>
800088d0:	33 09       	mov	r9,48
800088d2:	fa f8 06 a4 	ld.w	r8,sp[1700]
800088d6:	40 3e       	lddsp	lr,sp[0xc]
800088d8:	1c 38       	cp.w	r8,lr
800088da:	cf 73       	brcs	800088c8 <_vfprintf_r+0x9f4>
800088dc:	e0 40 00 47 	cp.w	r0,71
800088e0:	5f 09       	sreq	r9
800088e2:	e0 40 00 67 	cp.w	r0,103
800088e6:	5f 08       	sreq	r8
800088e8:	f3 e8 10 08 	or	r8,r9,r8
800088ec:	fa f9 06 a4 	ld.w	r9,sp[1700]
800088f0:	0c 19       	sub	r9,r6
800088f2:	50 69       	stdsp	sp[0x18],r9
800088f4:	58 08       	cp.w	r8,0
800088f6:	c0 b0       	breq	8000890c <_vfprintf_r+0xa38>
800088f8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800088fc:	5b d8       	cp.w	r8,-3
800088fe:	c0 55       	brlt	80008908 <_vfprintf_r+0xa34>
80008900:	40 2c       	lddsp	r12,sp[0x8]
80008902:	18 38       	cp.w	r8,r12
80008904:	e0 8a 00 6a 	brle	800089d8 <_vfprintf_r+0xb04>
80008908:	20 20       	sub	r0,2
8000890a:	c0 58       	rjmp	80008914 <_vfprintf_r+0xa40>
8000890c:	e0 40 00 65 	cp.w	r0,101
80008910:	e0 89 00 46 	brgt	8000899c <_vfprintf_r+0xac8>
80008914:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008918:	fb 60 06 9c 	st.b	sp[1692],r0
8000891c:	20 1b       	sub	r11,1
8000891e:	fb 4b 06 ac 	st.w	sp[1708],r11
80008922:	c0 47       	brpl	8000892a <_vfprintf_r+0xa56>
80008924:	5c 3b       	neg	r11
80008926:	32 d8       	mov	r8,45
80008928:	c0 28       	rjmp	8000892c <_vfprintf_r+0xa58>
8000892a:	32 b8       	mov	r8,43
8000892c:	fb 68 06 9d 	st.b	sp[1693],r8
80008930:	58 9b       	cp.w	r11,9
80008932:	e0 8a 00 1d 	brle	8000896c <_vfprintf_r+0xa98>
80008936:	fa c9 fa 35 	sub	r9,sp,-1483
8000893a:	30 aa       	mov	r10,10
8000893c:	12 98       	mov	r8,r9
8000893e:	0e 9c       	mov	r12,r7
80008940:	0c 92       	mov	r2,r6
80008942:	f6 0a 0c 06 	divs	r6,r11,r10
80008946:	0e 9b       	mov	r11,r7
80008948:	2d 0b       	sub	r11,-48
8000894a:	10 fb       	st.b	--r8,r11
8000894c:	0c 9b       	mov	r11,r6
8000894e:	58 96       	cp.w	r6,9
80008950:	fe 99 ff f9 	brgt	80008942 <_vfprintf_r+0xa6e>
80008954:	2d 0b       	sub	r11,-48
80008956:	18 97       	mov	r7,r12
80008958:	04 96       	mov	r6,r2
8000895a:	10 fb       	st.b	--r8,r11
8000895c:	fa ca f9 62 	sub	r10,sp,-1694
80008960:	c0 38       	rjmp	80008966 <_vfprintf_r+0xa92>
80008962:	11 3b       	ld.ub	r11,r8++
80008964:	14 cb       	st.b	r10++,r11
80008966:	12 38       	cp.w	r8,r9
80008968:	cf d3       	brcs	80008962 <_vfprintf_r+0xa8e>
8000896a:	c0 98       	rjmp	8000897c <_vfprintf_r+0xaa8>
8000896c:	2d 0b       	sub	r11,-48
8000896e:	33 08       	mov	r8,48
80008970:	fb 6b 06 9f 	st.b	sp[1695],r11
80008974:	fb 68 06 9e 	st.b	sp[1694],r8
80008978:	fa ca f9 60 	sub	r10,sp,-1696
8000897c:	fa c8 f9 64 	sub	r8,sp,-1692
80008980:	f4 08 01 08 	sub	r8,r10,r8
80008984:	50 e8       	stdsp	sp[0x38],r8
80008986:	10 92       	mov	r2,r8
80008988:	40 6b       	lddsp	r11,sp[0x18]
8000898a:	16 02       	add	r2,r11
8000898c:	58 1b       	cp.w	r11,1
8000898e:	e0 89 00 05 	brgt	80008998 <_vfprintf_r+0xac4>
80008992:	ed b5 00 00 	bld	r5,0x0
80008996:	c3 51       	brne	80008a00 <_vfprintf_r+0xb2c>
80008998:	2f f2       	sub	r2,-1
8000899a:	c3 38       	rjmp	80008a00 <_vfprintf_r+0xb2c>
8000899c:	e0 40 00 66 	cp.w	r0,102
800089a0:	c1 c1       	brne	800089d8 <_vfprintf_r+0xb04>
800089a2:	fa f2 06 ac 	ld.w	r2,sp[1708]
800089a6:	58 02       	cp.w	r2,0
800089a8:	e0 8a 00 0c 	brle	800089c0 <_vfprintf_r+0xaec>
800089ac:	40 2a       	lddsp	r10,sp[0x8]
800089ae:	58 0a       	cp.w	r10,0
800089b0:	c0 41       	brne	800089b8 <_vfprintf_r+0xae4>
800089b2:	ed b5 00 00 	bld	r5,0x0
800089b6:	c2 51       	brne	80008a00 <_vfprintf_r+0xb2c>
800089b8:	2f f2       	sub	r2,-1
800089ba:	40 29       	lddsp	r9,sp[0x8]
800089bc:	12 02       	add	r2,r9
800089be:	c0 b8       	rjmp	800089d4 <_vfprintf_r+0xb00>
800089c0:	40 28       	lddsp	r8,sp[0x8]
800089c2:	58 08       	cp.w	r8,0
800089c4:	c0 61       	brne	800089d0 <_vfprintf_r+0xafc>
800089c6:	ed b5 00 00 	bld	r5,0x0
800089ca:	c0 30       	breq	800089d0 <_vfprintf_r+0xafc>
800089cc:	30 12       	mov	r2,1
800089ce:	c1 98       	rjmp	80008a00 <_vfprintf_r+0xb2c>
800089d0:	40 22       	lddsp	r2,sp[0x8]
800089d2:	2f e2       	sub	r2,-2
800089d4:	36 60       	mov	r0,102
800089d6:	c1 58       	rjmp	80008a00 <_vfprintf_r+0xb2c>
800089d8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800089dc:	40 6e       	lddsp	lr,sp[0x18]
800089de:	1c 32       	cp.w	r2,lr
800089e0:	c0 65       	brlt	800089ec <_vfprintf_r+0xb18>
800089e2:	ed b5 00 00 	bld	r5,0x0
800089e6:	f7 b2 00 ff 	subeq	r2,-1
800089ea:	c0 a8       	rjmp	800089fe <_vfprintf_r+0xb2a>
800089ec:	e4 08 11 02 	rsub	r8,r2,2
800089f0:	40 6c       	lddsp	r12,sp[0x18]
800089f2:	58 02       	cp.w	r2,0
800089f4:	f0 02 17 a0 	movle	r2,r8
800089f8:	f9 b2 09 01 	movgt	r2,1
800089fc:	18 02       	add	r2,r12
800089fe:	36 70       	mov	r0,103
80008a00:	40 9b       	lddsp	r11,sp[0x24]
80008a02:	58 0b       	cp.w	r11,0
80008a04:	e0 80 05 94 	breq	8000952c <_vfprintf_r+0x1658>
80008a08:	32 d8       	mov	r8,45
80008a0a:	fb 68 06 bb 	st.b	sp[1723],r8
80008a0e:	e0 8f 05 93 	bral	80009534 <_vfprintf_r+0x1660>
80008a12:	50 a7       	stdsp	sp[0x28],r7
80008a14:	04 94       	mov	r4,r2
80008a16:	0c 97       	mov	r7,r6
80008a18:	02 92       	mov	r2,r1
80008a1a:	06 96       	mov	r6,r3
80008a1c:	40 41       	lddsp	r1,sp[0x10]
80008a1e:	40 93       	lddsp	r3,sp[0x24]
80008a20:	0e 99       	mov	r9,r7
80008a22:	ed b5 00 05 	bld	r5,0x5
80008a26:	c4 81       	brne	80008ab6 <_vfprintf_r+0xbe2>
80008a28:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a2c:	40 3e       	lddsp	lr,sp[0xc]
80008a2e:	58 0e       	cp.w	lr,0
80008a30:	c1 d0       	breq	80008a6a <_vfprintf_r+0xb96>
80008a32:	10 36       	cp.w	r6,r8
80008a34:	c0 64       	brge	80008a40 <_vfprintf_r+0xb6c>
80008a36:	fa cc f9 44 	sub	r12,sp,-1724
80008a3a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a3e:	c1 d8       	rjmp	80008a78 <_vfprintf_r+0xba4>
80008a40:	fa c8 f9 50 	sub	r8,sp,-1712
80008a44:	1a d8       	st.w	--sp,r8
80008a46:	fa c8 fa b8 	sub	r8,sp,-1352
80008a4a:	04 9a       	mov	r10,r2
80008a4c:	1a d8       	st.w	--sp,r8
80008a4e:	fa c8 fb b4 	sub	r8,sp,-1100
80008a52:	0c 9b       	mov	r11,r6
80008a54:	1a d8       	st.w	--sp,r8
80008a56:	08 9c       	mov	r12,r4
80008a58:	fa c8 f9 40 	sub	r8,sp,-1728
80008a5c:	fa c9 ff b4 	sub	r9,sp,-76
80008a60:	fe b0 f8 a2 	rcall	80007ba4 <get_arg>
80008a64:	2f dd       	sub	sp,-12
80008a66:	78 0a       	ld.w	r10,r12[0x0]
80008a68:	c2 08       	rjmp	80008aa8 <_vfprintf_r+0xbd4>
80008a6a:	2f f7       	sub	r7,-1
80008a6c:	10 39       	cp.w	r9,r8
80008a6e:	c0 84       	brge	80008a7e <_vfprintf_r+0xbaa>
80008a70:	fa cb f9 44 	sub	r11,sp,-1724
80008a74:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a78:	ec fa fd 88 	ld.w	r10,r6[-632]
80008a7c:	c1 68       	rjmp	80008aa8 <_vfprintf_r+0xbd4>
80008a7e:	41 09       	lddsp	r9,sp[0x40]
80008a80:	59 f8       	cp.w	r8,31
80008a82:	e0 89 00 10 	brgt	80008aa2 <_vfprintf_r+0xbce>
80008a86:	f2 ca ff fc 	sub	r10,r9,-4
80008a8a:	51 0a       	stdsp	sp[0x40],r10
80008a8c:	fa c6 f9 44 	sub	r6,sp,-1724
80008a90:	72 0a       	ld.w	r10,r9[0x0]
80008a92:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a96:	f3 4a fd 88 	st.w	r9[-632],r10
80008a9a:	2f f8       	sub	r8,-1
80008a9c:	fb 48 06 b4 	st.w	sp[1716],r8
80008aa0:	c0 48       	rjmp	80008aa8 <_vfprintf_r+0xbd4>
80008aa2:	72 0a       	ld.w	r10,r9[0x0]
80008aa4:	2f c9       	sub	r9,-4
80008aa6:	51 09       	stdsp	sp[0x40],r9
80008aa8:	40 be       	lddsp	lr,sp[0x2c]
80008aaa:	1c 98       	mov	r8,lr
80008aac:	95 1e       	st.w	r10[0x4],lr
80008aae:	bf 58       	asr	r8,0x1f
80008ab0:	95 08       	st.w	r10[0x0],r8
80008ab2:	fe 9f fa 9f 	bral	80007ff0 <_vfprintf_r+0x11c>
80008ab6:	ed b5 00 04 	bld	r5,0x4
80008aba:	c4 80       	breq	80008b4a <_vfprintf_r+0xc76>
80008abc:	e2 15 00 40 	andl	r5,0x40,COH
80008ac0:	c4 50       	breq	80008b4a <_vfprintf_r+0xc76>
80008ac2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ac6:	40 3c       	lddsp	r12,sp[0xc]
80008ac8:	58 0c       	cp.w	r12,0
80008aca:	c1 d0       	breq	80008b04 <_vfprintf_r+0xc30>
80008acc:	10 36       	cp.w	r6,r8
80008ace:	c0 64       	brge	80008ada <_vfprintf_r+0xc06>
80008ad0:	fa cb f9 44 	sub	r11,sp,-1724
80008ad4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ad8:	c1 d8       	rjmp	80008b12 <_vfprintf_r+0xc3e>
80008ada:	fa c8 f9 50 	sub	r8,sp,-1712
80008ade:	1a d8       	st.w	--sp,r8
80008ae0:	fa c8 fa b8 	sub	r8,sp,-1352
80008ae4:	04 9a       	mov	r10,r2
80008ae6:	1a d8       	st.w	--sp,r8
80008ae8:	fa c8 fb b4 	sub	r8,sp,-1100
80008aec:	0c 9b       	mov	r11,r6
80008aee:	1a d8       	st.w	--sp,r8
80008af0:	08 9c       	mov	r12,r4
80008af2:	fa c8 f9 40 	sub	r8,sp,-1728
80008af6:	fa c9 ff b4 	sub	r9,sp,-76
80008afa:	fe b0 f8 55 	rcall	80007ba4 <get_arg>
80008afe:	2f dd       	sub	sp,-12
80008b00:	78 0a       	ld.w	r10,r12[0x0]
80008b02:	c2 08       	rjmp	80008b42 <_vfprintf_r+0xc6e>
80008b04:	2f f7       	sub	r7,-1
80008b06:	10 39       	cp.w	r9,r8
80008b08:	c0 84       	brge	80008b18 <_vfprintf_r+0xc44>
80008b0a:	fa ca f9 44 	sub	r10,sp,-1724
80008b0e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b12:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b16:	c1 68       	rjmp	80008b42 <_vfprintf_r+0xc6e>
80008b18:	41 09       	lddsp	r9,sp[0x40]
80008b1a:	59 f8       	cp.w	r8,31
80008b1c:	e0 89 00 10 	brgt	80008b3c <_vfprintf_r+0xc68>
80008b20:	f2 ca ff fc 	sub	r10,r9,-4
80008b24:	51 0a       	stdsp	sp[0x40],r10
80008b26:	fa c6 f9 44 	sub	r6,sp,-1724
80008b2a:	72 0a       	ld.w	r10,r9[0x0]
80008b2c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b30:	f3 4a fd 88 	st.w	r9[-632],r10
80008b34:	2f f8       	sub	r8,-1
80008b36:	fb 48 06 b4 	st.w	sp[1716],r8
80008b3a:	c0 48       	rjmp	80008b42 <_vfprintf_r+0xc6e>
80008b3c:	72 0a       	ld.w	r10,r9[0x0]
80008b3e:	2f c9       	sub	r9,-4
80008b40:	51 09       	stdsp	sp[0x40],r9
80008b42:	40 be       	lddsp	lr,sp[0x2c]
80008b44:	b4 0e       	st.h	r10[0x0],lr
80008b46:	fe 9f fa 55 	bral	80007ff0 <_vfprintf_r+0x11c>
80008b4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b4e:	40 3c       	lddsp	r12,sp[0xc]
80008b50:	58 0c       	cp.w	r12,0
80008b52:	c1 d0       	breq	80008b8c <_vfprintf_r+0xcb8>
80008b54:	10 36       	cp.w	r6,r8
80008b56:	c0 64       	brge	80008b62 <_vfprintf_r+0xc8e>
80008b58:	fa cb f9 44 	sub	r11,sp,-1724
80008b5c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b60:	c1 d8       	rjmp	80008b9a <_vfprintf_r+0xcc6>
80008b62:	fa c8 f9 50 	sub	r8,sp,-1712
80008b66:	1a d8       	st.w	--sp,r8
80008b68:	fa c8 fa b8 	sub	r8,sp,-1352
80008b6c:	04 9a       	mov	r10,r2
80008b6e:	1a d8       	st.w	--sp,r8
80008b70:	fa c8 fb b4 	sub	r8,sp,-1100
80008b74:	0c 9b       	mov	r11,r6
80008b76:	1a d8       	st.w	--sp,r8
80008b78:	08 9c       	mov	r12,r4
80008b7a:	fa c8 f9 40 	sub	r8,sp,-1728
80008b7e:	fa c9 ff b4 	sub	r9,sp,-76
80008b82:	fe b0 f8 11 	rcall	80007ba4 <get_arg>
80008b86:	2f dd       	sub	sp,-12
80008b88:	78 0a       	ld.w	r10,r12[0x0]
80008b8a:	c2 08       	rjmp	80008bca <_vfprintf_r+0xcf6>
80008b8c:	2f f7       	sub	r7,-1
80008b8e:	10 39       	cp.w	r9,r8
80008b90:	c0 84       	brge	80008ba0 <_vfprintf_r+0xccc>
80008b92:	fa ca f9 44 	sub	r10,sp,-1724
80008b96:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b9a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b9e:	c1 68       	rjmp	80008bca <_vfprintf_r+0xcf6>
80008ba0:	41 09       	lddsp	r9,sp[0x40]
80008ba2:	59 f8       	cp.w	r8,31
80008ba4:	e0 89 00 10 	brgt	80008bc4 <_vfprintf_r+0xcf0>
80008ba8:	f2 ca ff fc 	sub	r10,r9,-4
80008bac:	51 0a       	stdsp	sp[0x40],r10
80008bae:	fa c6 f9 44 	sub	r6,sp,-1724
80008bb2:	72 0a       	ld.w	r10,r9[0x0]
80008bb4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008bb8:	f3 4a fd 88 	st.w	r9[-632],r10
80008bbc:	2f f8       	sub	r8,-1
80008bbe:	fb 48 06 b4 	st.w	sp[1716],r8
80008bc2:	c0 48       	rjmp	80008bca <_vfprintf_r+0xcf6>
80008bc4:	72 0a       	ld.w	r10,r9[0x0]
80008bc6:	2f c9       	sub	r9,-4
80008bc8:	51 09       	stdsp	sp[0x40],r9
80008bca:	40 be       	lddsp	lr,sp[0x2c]
80008bcc:	95 0e       	st.w	r10[0x0],lr
80008bce:	fe 9f fa 11 	bral	80007ff0 <_vfprintf_r+0x11c>
80008bd2:	50 a7       	stdsp	sp[0x28],r7
80008bd4:	50 80       	stdsp	sp[0x20],r0
80008bd6:	0c 97       	mov	r7,r6
80008bd8:	04 94       	mov	r4,r2
80008bda:	06 96       	mov	r6,r3
80008bdc:	02 92       	mov	r2,r1
80008bde:	40 93       	lddsp	r3,sp[0x24]
80008be0:	10 90       	mov	r0,r8
80008be2:	40 41       	lddsp	r1,sp[0x10]
80008be4:	a5 a5       	sbr	r5,0x4
80008be6:	c0 a8       	rjmp	80008bfa <_vfprintf_r+0xd26>
80008be8:	50 a7       	stdsp	sp[0x28],r7
80008bea:	50 80       	stdsp	sp[0x20],r0
80008bec:	0c 97       	mov	r7,r6
80008bee:	04 94       	mov	r4,r2
80008bf0:	06 96       	mov	r6,r3
80008bf2:	02 92       	mov	r2,r1
80008bf4:	40 93       	lddsp	r3,sp[0x24]
80008bf6:	10 90       	mov	r0,r8
80008bf8:	40 41       	lddsp	r1,sp[0x10]
80008bfa:	ed b5 00 05 	bld	r5,0x5
80008bfe:	c5 d1       	brne	80008cb8 <_vfprintf_r+0xde4>
80008c00:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c04:	40 3c       	lddsp	r12,sp[0xc]
80008c06:	58 0c       	cp.w	r12,0
80008c08:	c2 60       	breq	80008c54 <_vfprintf_r+0xd80>
80008c0a:	10 36       	cp.w	r6,r8
80008c0c:	c0 a4       	brge	80008c20 <_vfprintf_r+0xd4c>
80008c0e:	fa cb f9 44 	sub	r11,sp,-1724
80008c12:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c16:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008c1a:	fa e9 00 00 	st.d	sp[0],r8
80008c1e:	c1 88       	rjmp	80008c4e <_vfprintf_r+0xd7a>
80008c20:	fa c8 f9 50 	sub	r8,sp,-1712
80008c24:	1a d8       	st.w	--sp,r8
80008c26:	fa c8 fa b8 	sub	r8,sp,-1352
80008c2a:	04 9a       	mov	r10,r2
80008c2c:	1a d8       	st.w	--sp,r8
80008c2e:	0c 9b       	mov	r11,r6
80008c30:	fa c8 fb b4 	sub	r8,sp,-1100
80008c34:	08 9c       	mov	r12,r4
80008c36:	1a d8       	st.w	--sp,r8
80008c38:	fa c8 f9 40 	sub	r8,sp,-1728
80008c3c:	fa c9 ff b4 	sub	r9,sp,-76
80008c40:	fe b0 f7 b2 	rcall	80007ba4 <get_arg>
80008c44:	2f dd       	sub	sp,-12
80008c46:	f8 ea 00 00 	ld.d	r10,r12[0]
80008c4a:	fa eb 00 00 	st.d	sp[0],r10
80008c4e:	30 08       	mov	r8,0
80008c50:	e0 8f 03 de 	bral	8000940c <_vfprintf_r+0x1538>
80008c54:	ee ca ff ff 	sub	r10,r7,-1
80008c58:	10 37       	cp.w	r7,r8
80008c5a:	c0 b4       	brge	80008c70 <_vfprintf_r+0xd9c>
80008c5c:	fa c9 f9 44 	sub	r9,sp,-1724
80008c60:	14 97       	mov	r7,r10
80008c62:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c66:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c6a:	fa eb 00 00 	st.d	sp[0],r10
80008c6e:	c1 88       	rjmp	80008c9e <_vfprintf_r+0xdca>
80008c70:	41 09       	lddsp	r9,sp[0x40]
80008c72:	59 f8       	cp.w	r8,31
80008c74:	e0 89 00 18 	brgt	80008ca4 <_vfprintf_r+0xdd0>
80008c78:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c7c:	f2 cb ff f8 	sub	r11,r9,-8
80008c80:	fa e7 00 00 	st.d	sp[0],r6
80008c84:	51 0b       	stdsp	sp[0x40],r11
80008c86:	fa c6 f9 44 	sub	r6,sp,-1724
80008c8a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c8e:	fa e6 00 00 	ld.d	r6,sp[0]
80008c92:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c96:	2f f8       	sub	r8,-1
80008c98:	14 97       	mov	r7,r10
80008c9a:	fb 48 06 b4 	st.w	sp[1716],r8
80008c9e:	40 38       	lddsp	r8,sp[0xc]
80008ca0:	e0 8f 03 b6 	bral	8000940c <_vfprintf_r+0x1538>
80008ca4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ca8:	40 38       	lddsp	r8,sp[0xc]
80008caa:	fa e7 00 00 	st.d	sp[0],r6
80008cae:	2f 89       	sub	r9,-8
80008cb0:	14 97       	mov	r7,r10
80008cb2:	51 09       	stdsp	sp[0x40],r9
80008cb4:	e0 8f 03 ac 	bral	8000940c <_vfprintf_r+0x1538>
80008cb8:	ed b5 00 04 	bld	r5,0x4
80008cbc:	c1 61       	brne	80008ce8 <_vfprintf_r+0xe14>
80008cbe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cc2:	40 3e       	lddsp	lr,sp[0xc]
80008cc4:	58 0e       	cp.w	lr,0
80008cc6:	c0 80       	breq	80008cd6 <_vfprintf_r+0xe02>
80008cc8:	10 36       	cp.w	r6,r8
80008cca:	c6 74       	brge	80008d98 <_vfprintf_r+0xec4>
80008ccc:	fa cc f9 44 	sub	r12,sp,-1724
80008cd0:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008cd4:	c8 08       	rjmp	80008dd4 <_vfprintf_r+0xf00>
80008cd6:	ee ca ff ff 	sub	r10,r7,-1
80008cda:	10 37       	cp.w	r7,r8
80008cdc:	c7 f4       	brge	80008dda <_vfprintf_r+0xf06>
80008cde:	fa cb f9 44 	sub	r11,sp,-1724
80008ce2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ce6:	c7 68       	rjmp	80008dd2 <_vfprintf_r+0xefe>
80008ce8:	ed b5 00 06 	bld	r5,0x6
80008cec:	c4 a1       	brne	80008d80 <_vfprintf_r+0xeac>
80008cee:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cf2:	40 3c       	lddsp	r12,sp[0xc]
80008cf4:	58 0c       	cp.w	r12,0
80008cf6:	c1 d0       	breq	80008d30 <_vfprintf_r+0xe5c>
80008cf8:	10 36       	cp.w	r6,r8
80008cfa:	c0 64       	brge	80008d06 <_vfprintf_r+0xe32>
80008cfc:	fa cb f9 44 	sub	r11,sp,-1724
80008d00:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d04:	c1 f8       	rjmp	80008d42 <_vfprintf_r+0xe6e>
80008d06:	fa c8 f9 50 	sub	r8,sp,-1712
80008d0a:	1a d8       	st.w	--sp,r8
80008d0c:	fa c8 fa b8 	sub	r8,sp,-1352
80008d10:	1a d8       	st.w	--sp,r8
80008d12:	fa c8 fb b4 	sub	r8,sp,-1100
80008d16:	1a d8       	st.w	--sp,r8
80008d18:	fa c8 f9 40 	sub	r8,sp,-1728
80008d1c:	fa c9 ff b4 	sub	r9,sp,-76
80008d20:	04 9a       	mov	r10,r2
80008d22:	0c 9b       	mov	r11,r6
80008d24:	08 9c       	mov	r12,r4
80008d26:	fe b0 f7 3f 	rcall	80007ba4 <get_arg>
80008d2a:	2f dd       	sub	sp,-12
80008d2c:	98 18       	ld.sh	r8,r12[0x2]
80008d2e:	c2 68       	rjmp	80008d7a <_vfprintf_r+0xea6>
80008d30:	ee ca ff ff 	sub	r10,r7,-1
80008d34:	10 37       	cp.w	r7,r8
80008d36:	c0 94       	brge	80008d48 <_vfprintf_r+0xe74>
80008d38:	fa c9 f9 44 	sub	r9,sp,-1724
80008d3c:	14 97       	mov	r7,r10
80008d3e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d42:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d46:	c1 a8       	rjmp	80008d7a <_vfprintf_r+0xea6>
80008d48:	41 09       	lddsp	r9,sp[0x40]
80008d4a:	59 f8       	cp.w	r8,31
80008d4c:	e0 89 00 13 	brgt	80008d72 <_vfprintf_r+0xe9e>
80008d50:	f2 cb ff fc 	sub	r11,r9,-4
80008d54:	51 0b       	stdsp	sp[0x40],r11
80008d56:	72 09       	ld.w	r9,r9[0x0]
80008d58:	fa c6 f9 44 	sub	r6,sp,-1724
80008d5c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d60:	2f f8       	sub	r8,-1
80008d62:	f7 49 fd 88 	st.w	r11[-632],r9
80008d66:	fb 48 06 b4 	st.w	sp[1716],r8
80008d6a:	14 97       	mov	r7,r10
80008d6c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d70:	c0 58       	rjmp	80008d7a <_vfprintf_r+0xea6>
80008d72:	92 18       	ld.sh	r8,r9[0x2]
80008d74:	14 97       	mov	r7,r10
80008d76:	2f c9       	sub	r9,-4
80008d78:	51 09       	stdsp	sp[0x40],r9
80008d7a:	5c 78       	castu.h	r8
80008d7c:	50 18       	stdsp	sp[0x4],r8
80008d7e:	c4 68       	rjmp	80008e0a <_vfprintf_r+0xf36>
80008d80:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d84:	40 3c       	lddsp	r12,sp[0xc]
80008d86:	58 0c       	cp.w	r12,0
80008d88:	c1 d0       	breq	80008dc2 <_vfprintf_r+0xeee>
80008d8a:	10 36       	cp.w	r6,r8
80008d8c:	c0 64       	brge	80008d98 <_vfprintf_r+0xec4>
80008d8e:	fa cb f9 44 	sub	r11,sp,-1724
80008d92:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d96:	c1 f8       	rjmp	80008dd4 <_vfprintf_r+0xf00>
80008d98:	fa c8 f9 50 	sub	r8,sp,-1712
80008d9c:	1a d8       	st.w	--sp,r8
80008d9e:	fa c8 fa b8 	sub	r8,sp,-1352
80008da2:	0c 9b       	mov	r11,r6
80008da4:	1a d8       	st.w	--sp,r8
80008da6:	fa c8 fb b4 	sub	r8,sp,-1100
80008daa:	04 9a       	mov	r10,r2
80008dac:	1a d8       	st.w	--sp,r8
80008dae:	08 9c       	mov	r12,r4
80008db0:	fa c8 f9 40 	sub	r8,sp,-1728
80008db4:	fa c9 ff b4 	sub	r9,sp,-76
80008db8:	fe b0 f6 f6 	rcall	80007ba4 <get_arg>
80008dbc:	2f dd       	sub	sp,-12
80008dbe:	78 0b       	ld.w	r11,r12[0x0]
80008dc0:	c2 48       	rjmp	80008e08 <_vfprintf_r+0xf34>
80008dc2:	ee ca ff ff 	sub	r10,r7,-1
80008dc6:	10 37       	cp.w	r7,r8
80008dc8:	c0 94       	brge	80008dda <_vfprintf_r+0xf06>
80008dca:	fa c9 f9 44 	sub	r9,sp,-1724
80008dce:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dd2:	14 97       	mov	r7,r10
80008dd4:	ec fb fd 88 	ld.w	r11,r6[-632]
80008dd8:	c1 88       	rjmp	80008e08 <_vfprintf_r+0xf34>
80008dda:	41 09       	lddsp	r9,sp[0x40]
80008ddc:	59 f8       	cp.w	r8,31
80008dde:	e0 89 00 11 	brgt	80008e00 <_vfprintf_r+0xf2c>
80008de2:	f2 cb ff fc 	sub	r11,r9,-4
80008de6:	51 0b       	stdsp	sp[0x40],r11
80008de8:	fa c6 f9 44 	sub	r6,sp,-1724
80008dec:	72 0b       	ld.w	r11,r9[0x0]
80008dee:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008df2:	f3 4b fd 88 	st.w	r9[-632],r11
80008df6:	2f f8       	sub	r8,-1
80008df8:	14 97       	mov	r7,r10
80008dfa:	fb 48 06 b4 	st.w	sp[1716],r8
80008dfe:	c0 58       	rjmp	80008e08 <_vfprintf_r+0xf34>
80008e00:	72 0b       	ld.w	r11,r9[0x0]
80008e02:	14 97       	mov	r7,r10
80008e04:	2f c9       	sub	r9,-4
80008e06:	51 09       	stdsp	sp[0x40],r9
80008e08:	50 1b       	stdsp	sp[0x4],r11
80008e0a:	30 0e       	mov	lr,0
80008e0c:	50 0e       	stdsp	sp[0x0],lr
80008e0e:	1c 98       	mov	r8,lr
80008e10:	e0 8f 02 fe 	bral	8000940c <_vfprintf_r+0x1538>
80008e14:	50 a7       	stdsp	sp[0x28],r7
80008e16:	50 80       	stdsp	sp[0x20],r0
80008e18:	0c 97       	mov	r7,r6
80008e1a:	04 94       	mov	r4,r2
80008e1c:	06 96       	mov	r6,r3
80008e1e:	02 92       	mov	r2,r1
80008e20:	40 93       	lddsp	r3,sp[0x24]
80008e22:	40 41       	lddsp	r1,sp[0x10]
80008e24:	0e 99       	mov	r9,r7
80008e26:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e2a:	40 3c       	lddsp	r12,sp[0xc]
80008e2c:	58 0c       	cp.w	r12,0
80008e2e:	c1 d0       	breq	80008e68 <_vfprintf_r+0xf94>
80008e30:	10 36       	cp.w	r6,r8
80008e32:	c0 64       	brge	80008e3e <_vfprintf_r+0xf6a>
80008e34:	fa cb f9 44 	sub	r11,sp,-1724
80008e38:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e3c:	c1 d8       	rjmp	80008e76 <_vfprintf_r+0xfa2>
80008e3e:	fa c8 f9 50 	sub	r8,sp,-1712
80008e42:	1a d8       	st.w	--sp,r8
80008e44:	fa c8 fa b8 	sub	r8,sp,-1352
80008e48:	1a d8       	st.w	--sp,r8
80008e4a:	fa c8 fb b4 	sub	r8,sp,-1100
80008e4e:	1a d8       	st.w	--sp,r8
80008e50:	fa c9 ff b4 	sub	r9,sp,-76
80008e54:	fa c8 f9 40 	sub	r8,sp,-1728
80008e58:	04 9a       	mov	r10,r2
80008e5a:	0c 9b       	mov	r11,r6
80008e5c:	08 9c       	mov	r12,r4
80008e5e:	fe b0 f6 a3 	rcall	80007ba4 <get_arg>
80008e62:	2f dd       	sub	sp,-12
80008e64:	78 09       	ld.w	r9,r12[0x0]
80008e66:	c2 18       	rjmp	80008ea8 <_vfprintf_r+0xfd4>
80008e68:	2f f7       	sub	r7,-1
80008e6a:	10 39       	cp.w	r9,r8
80008e6c:	c0 84       	brge	80008e7c <_vfprintf_r+0xfa8>
80008e6e:	fa ca f9 44 	sub	r10,sp,-1724
80008e72:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e76:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008e7a:	c1 78       	rjmp	80008ea8 <_vfprintf_r+0xfd4>
80008e7c:	41 09       	lddsp	r9,sp[0x40]
80008e7e:	59 f8       	cp.w	r8,31
80008e80:	e0 89 00 10 	brgt	80008ea0 <_vfprintf_r+0xfcc>
80008e84:	f2 ca ff fc 	sub	r10,r9,-4
80008e88:	51 0a       	stdsp	sp[0x40],r10
80008e8a:	fa c6 f9 44 	sub	r6,sp,-1724
80008e8e:	72 09       	ld.w	r9,r9[0x0]
80008e90:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008e94:	f5 49 fd 88 	st.w	r10[-632],r9
80008e98:	2f f8       	sub	r8,-1
80008e9a:	fb 48 06 b4 	st.w	sp[1716],r8
80008e9e:	c0 58       	rjmp	80008ea8 <_vfprintf_r+0xfd4>
80008ea0:	f2 c8 ff fc 	sub	r8,r9,-4
80008ea4:	51 08       	stdsp	sp[0x40],r8
80008ea6:	72 09       	ld.w	r9,r9[0x0]
80008ea8:	33 08       	mov	r8,48
80008eaa:	fb 68 06 b8 	st.b	sp[1720],r8
80008eae:	37 88       	mov	r8,120
80008eb0:	30 0e       	mov	lr,0
80008eb2:	fb 68 06 b9 	st.b	sp[1721],r8
80008eb6:	fe cc b1 0e 	sub	r12,pc,-20210
80008eba:	50 19       	stdsp	sp[0x4],r9
80008ebc:	a1 b5       	sbr	r5,0x1
80008ebe:	50 0e       	stdsp	sp[0x0],lr
80008ec0:	50 dc       	stdsp	sp[0x34],r12
80008ec2:	30 28       	mov	r8,2
80008ec4:	37 80       	mov	r0,120
80008ec6:	e0 8f 02 a3 	bral	8000940c <_vfprintf_r+0x1538>
80008eca:	50 a7       	stdsp	sp[0x28],r7
80008ecc:	50 80       	stdsp	sp[0x20],r0
80008ece:	10 90       	mov	r0,r8
80008ed0:	30 08       	mov	r8,0
80008ed2:	fb 68 06 bb 	st.b	sp[1723],r8
80008ed6:	0c 97       	mov	r7,r6
80008ed8:	04 94       	mov	r4,r2
80008eda:	06 96       	mov	r6,r3
80008edc:	02 92       	mov	r2,r1
80008ede:	40 93       	lddsp	r3,sp[0x24]
80008ee0:	40 41       	lddsp	r1,sp[0x10]
80008ee2:	0e 99       	mov	r9,r7
80008ee4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ee8:	40 3b       	lddsp	r11,sp[0xc]
80008eea:	58 0b       	cp.w	r11,0
80008eec:	c1 d0       	breq	80008f26 <_vfprintf_r+0x1052>
80008eee:	10 36       	cp.w	r6,r8
80008ef0:	c0 64       	brge	80008efc <_vfprintf_r+0x1028>
80008ef2:	fa ca f9 44 	sub	r10,sp,-1724
80008ef6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008efa:	c1 d8       	rjmp	80008f34 <_vfprintf_r+0x1060>
80008efc:	fa c8 f9 50 	sub	r8,sp,-1712
80008f00:	1a d8       	st.w	--sp,r8
80008f02:	fa c8 fa b8 	sub	r8,sp,-1352
80008f06:	1a d8       	st.w	--sp,r8
80008f08:	fa c8 fb b4 	sub	r8,sp,-1100
80008f0c:	0c 9b       	mov	r11,r6
80008f0e:	1a d8       	st.w	--sp,r8
80008f10:	04 9a       	mov	r10,r2
80008f12:	fa c8 f9 40 	sub	r8,sp,-1728
80008f16:	fa c9 ff b4 	sub	r9,sp,-76
80008f1a:	08 9c       	mov	r12,r4
80008f1c:	fe b0 f6 44 	rcall	80007ba4 <get_arg>
80008f20:	2f dd       	sub	sp,-12
80008f22:	78 06       	ld.w	r6,r12[0x0]
80008f24:	c2 08       	rjmp	80008f64 <_vfprintf_r+0x1090>
80008f26:	2f f7       	sub	r7,-1
80008f28:	10 39       	cp.w	r9,r8
80008f2a:	c0 84       	brge	80008f3a <_vfprintf_r+0x1066>
80008f2c:	fa c9 f9 44 	sub	r9,sp,-1724
80008f30:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f34:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008f38:	c1 68       	rjmp	80008f64 <_vfprintf_r+0x1090>
80008f3a:	41 09       	lddsp	r9,sp[0x40]
80008f3c:	59 f8       	cp.w	r8,31
80008f3e:	e0 89 00 10 	brgt	80008f5e <_vfprintf_r+0x108a>
80008f42:	f2 ca ff fc 	sub	r10,r9,-4
80008f46:	51 0a       	stdsp	sp[0x40],r10
80008f48:	72 06       	ld.w	r6,r9[0x0]
80008f4a:	fa ce f9 44 	sub	lr,sp,-1724
80008f4e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008f52:	f3 46 fd 88 	st.w	r9[-632],r6
80008f56:	2f f8       	sub	r8,-1
80008f58:	fb 48 06 b4 	st.w	sp[1716],r8
80008f5c:	c0 48       	rjmp	80008f64 <_vfprintf_r+0x1090>
80008f5e:	72 06       	ld.w	r6,r9[0x0]
80008f60:	2f c9       	sub	r9,-4
80008f62:	51 09       	stdsp	sp[0x40],r9
80008f64:	40 2c       	lddsp	r12,sp[0x8]
80008f66:	58 0c       	cp.w	r12,0
80008f68:	c1 05       	brlt	80008f88 <_vfprintf_r+0x10b4>
80008f6a:	18 9a       	mov	r10,r12
80008f6c:	30 0b       	mov	r11,0
80008f6e:	0c 9c       	mov	r12,r6
80008f70:	e0 a0 12 38 	rcall	8000b3e0 <memchr>
80008f74:	e0 80 02 df 	breq	80009532 <_vfprintf_r+0x165e>
80008f78:	f8 06 01 02 	sub	r2,r12,r6
80008f7c:	40 2b       	lddsp	r11,sp[0x8]
80008f7e:	16 32       	cp.w	r2,r11
80008f80:	e0 89 02 d9 	brgt	80009532 <_vfprintf_r+0x165e>
80008f84:	e0 8f 02 d4 	bral	8000952c <_vfprintf_r+0x1658>
80008f88:	30 0a       	mov	r10,0
80008f8a:	0c 9c       	mov	r12,r6
80008f8c:	50 2a       	stdsp	sp[0x8],r10
80008f8e:	e0 a0 15 99 	rcall	8000bac0 <strlen>
80008f92:	18 92       	mov	r2,r12
80008f94:	e0 8f 02 d2 	bral	80009538 <_vfprintf_r+0x1664>
80008f98:	50 a7       	stdsp	sp[0x28],r7
80008f9a:	50 80       	stdsp	sp[0x20],r0
80008f9c:	0c 97       	mov	r7,r6
80008f9e:	04 94       	mov	r4,r2
80008fa0:	06 96       	mov	r6,r3
80008fa2:	02 92       	mov	r2,r1
80008fa4:	40 93       	lddsp	r3,sp[0x24]
80008fa6:	10 90       	mov	r0,r8
80008fa8:	40 41       	lddsp	r1,sp[0x10]
80008faa:	a5 a5       	sbr	r5,0x4
80008fac:	c0 a8       	rjmp	80008fc0 <_vfprintf_r+0x10ec>
80008fae:	50 a7       	stdsp	sp[0x28],r7
80008fb0:	50 80       	stdsp	sp[0x20],r0
80008fb2:	0c 97       	mov	r7,r6
80008fb4:	04 94       	mov	r4,r2
80008fb6:	06 96       	mov	r6,r3
80008fb8:	02 92       	mov	r2,r1
80008fba:	40 93       	lddsp	r3,sp[0x24]
80008fbc:	10 90       	mov	r0,r8
80008fbe:	40 41       	lddsp	r1,sp[0x10]
80008fc0:	ed b5 00 05 	bld	r5,0x5
80008fc4:	c5 61       	brne	80009070 <_vfprintf_r+0x119c>
80008fc6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fca:	40 39       	lddsp	r9,sp[0xc]
80008fcc:	58 09       	cp.w	r9,0
80008fce:	c2 10       	breq	80009010 <_vfprintf_r+0x113c>
80008fd0:	10 36       	cp.w	r6,r8
80008fd2:	c0 74       	brge	80008fe0 <_vfprintf_r+0x110c>
80008fd4:	fa c8 f9 44 	sub	r8,sp,-1724
80008fd8:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008fdc:	c2 38       	rjmp	80009022 <_vfprintf_r+0x114e>
80008fde:	d7 03       	nop
80008fe0:	fa c8 f9 50 	sub	r8,sp,-1712
80008fe4:	1a d8       	st.w	--sp,r8
80008fe6:	fa c8 fa b8 	sub	r8,sp,-1352
80008fea:	1a d8       	st.w	--sp,r8
80008fec:	fa c8 fb b4 	sub	r8,sp,-1100
80008ff0:	1a d8       	st.w	--sp,r8
80008ff2:	fa c8 f9 40 	sub	r8,sp,-1728
80008ff6:	fa c9 ff b4 	sub	r9,sp,-76
80008ffa:	04 9a       	mov	r10,r2
80008ffc:	0c 9b       	mov	r11,r6
80008ffe:	08 9c       	mov	r12,r4
80009000:	fe b0 f5 d2 	rcall	80007ba4 <get_arg>
80009004:	2f dd       	sub	sp,-12
80009006:	f8 e8 00 00 	ld.d	r8,r12[0]
8000900a:	fa e9 00 00 	st.d	sp[0],r8
8000900e:	c2 e8       	rjmp	8000906a <_vfprintf_r+0x1196>
80009010:	ee ca ff ff 	sub	r10,r7,-1
80009014:	10 37       	cp.w	r7,r8
80009016:	c0 b4       	brge	8000902c <_vfprintf_r+0x1158>
80009018:	fa c8 f9 44 	sub	r8,sp,-1724
8000901c:	14 97       	mov	r7,r10
8000901e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009022:	ec ea fd 88 	ld.d	r10,r6[-632]
80009026:	fa eb 00 00 	st.d	sp[0],r10
8000902a:	c2 08       	rjmp	8000906a <_vfprintf_r+0x1196>
8000902c:	41 09       	lddsp	r9,sp[0x40]
8000902e:	59 f8       	cp.w	r8,31
80009030:	e0 89 00 16 	brgt	8000905c <_vfprintf_r+0x1188>
80009034:	f2 e6 00 00 	ld.d	r6,r9[0]
80009038:	f2 cb ff f8 	sub	r11,r9,-8
8000903c:	fa e7 00 00 	st.d	sp[0],r6
80009040:	51 0b       	stdsp	sp[0x40],r11
80009042:	fa c6 f9 44 	sub	r6,sp,-1724
80009046:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000904a:	fa e6 00 00 	ld.d	r6,sp[0]
8000904e:	f2 e7 fd 88 	st.d	r9[-632],r6
80009052:	2f f8       	sub	r8,-1
80009054:	14 97       	mov	r7,r10
80009056:	fb 48 06 b4 	st.w	sp[1716],r8
8000905a:	c0 88       	rjmp	8000906a <_vfprintf_r+0x1196>
8000905c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009060:	2f 89       	sub	r9,-8
80009062:	fa e7 00 00 	st.d	sp[0],r6
80009066:	51 09       	stdsp	sp[0x40],r9
80009068:	14 97       	mov	r7,r10
8000906a:	30 18       	mov	r8,1
8000906c:	e0 8f 01 d0 	bral	8000940c <_vfprintf_r+0x1538>
80009070:	ed b5 00 04 	bld	r5,0x4
80009074:	c1 61       	brne	800090a0 <_vfprintf_r+0x11cc>
80009076:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000907a:	40 3e       	lddsp	lr,sp[0xc]
8000907c:	58 0e       	cp.w	lr,0
8000907e:	c0 80       	breq	8000908e <_vfprintf_r+0x11ba>
80009080:	10 36       	cp.w	r6,r8
80009082:	c6 74       	brge	80009150 <_vfprintf_r+0x127c>
80009084:	fa cc f9 44 	sub	r12,sp,-1724
80009088:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000908c:	c8 08       	rjmp	8000918c <_vfprintf_r+0x12b8>
8000908e:	ee ca ff ff 	sub	r10,r7,-1
80009092:	10 37       	cp.w	r7,r8
80009094:	c7 f4       	brge	80009192 <_vfprintf_r+0x12be>
80009096:	fa cb f9 44 	sub	r11,sp,-1724
8000909a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000909e:	c7 68       	rjmp	8000918a <_vfprintf_r+0x12b6>
800090a0:	ed b5 00 06 	bld	r5,0x6
800090a4:	c4 a1       	brne	80009138 <_vfprintf_r+0x1264>
800090a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090aa:	40 3c       	lddsp	r12,sp[0xc]
800090ac:	58 0c       	cp.w	r12,0
800090ae:	c1 d0       	breq	800090e8 <_vfprintf_r+0x1214>
800090b0:	10 36       	cp.w	r6,r8
800090b2:	c0 64       	brge	800090be <_vfprintf_r+0x11ea>
800090b4:	fa cb f9 44 	sub	r11,sp,-1724
800090b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090bc:	c1 f8       	rjmp	800090fa <_vfprintf_r+0x1226>
800090be:	fa c8 f9 50 	sub	r8,sp,-1712
800090c2:	1a d8       	st.w	--sp,r8
800090c4:	fa c8 fa b8 	sub	r8,sp,-1352
800090c8:	1a d8       	st.w	--sp,r8
800090ca:	fa c8 fb b4 	sub	r8,sp,-1100
800090ce:	1a d8       	st.w	--sp,r8
800090d0:	fa c8 f9 40 	sub	r8,sp,-1728
800090d4:	fa c9 ff b4 	sub	r9,sp,-76
800090d8:	04 9a       	mov	r10,r2
800090da:	0c 9b       	mov	r11,r6
800090dc:	08 9c       	mov	r12,r4
800090de:	fe b0 f5 63 	rcall	80007ba4 <get_arg>
800090e2:	2f dd       	sub	sp,-12
800090e4:	98 18       	ld.sh	r8,r12[0x2]
800090e6:	c2 68       	rjmp	80009132 <_vfprintf_r+0x125e>
800090e8:	ee ca ff ff 	sub	r10,r7,-1
800090ec:	10 37       	cp.w	r7,r8
800090ee:	c0 94       	brge	80009100 <_vfprintf_r+0x122c>
800090f0:	fa c9 f9 44 	sub	r9,sp,-1724
800090f4:	14 97       	mov	r7,r10
800090f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090fa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800090fe:	c1 a8       	rjmp	80009132 <_vfprintf_r+0x125e>
80009100:	41 09       	lddsp	r9,sp[0x40]
80009102:	59 f8       	cp.w	r8,31
80009104:	e0 89 00 13 	brgt	8000912a <_vfprintf_r+0x1256>
80009108:	f2 cb ff fc 	sub	r11,r9,-4
8000910c:	51 0b       	stdsp	sp[0x40],r11
8000910e:	72 09       	ld.w	r9,r9[0x0]
80009110:	fa c6 f9 44 	sub	r6,sp,-1724
80009114:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009118:	2f f8       	sub	r8,-1
8000911a:	f7 49 fd 88 	st.w	r11[-632],r9
8000911e:	fb 48 06 b4 	st.w	sp[1716],r8
80009122:	14 97       	mov	r7,r10
80009124:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009128:	c0 58       	rjmp	80009132 <_vfprintf_r+0x125e>
8000912a:	92 18       	ld.sh	r8,r9[0x2]
8000912c:	14 97       	mov	r7,r10
8000912e:	2f c9       	sub	r9,-4
80009130:	51 09       	stdsp	sp[0x40],r9
80009132:	5c 78       	castu.h	r8
80009134:	50 18       	stdsp	sp[0x4],r8
80009136:	c4 68       	rjmp	800091c2 <_vfprintf_r+0x12ee>
80009138:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000913c:	40 3c       	lddsp	r12,sp[0xc]
8000913e:	58 0c       	cp.w	r12,0
80009140:	c1 d0       	breq	8000917a <_vfprintf_r+0x12a6>
80009142:	10 36       	cp.w	r6,r8
80009144:	c0 64       	brge	80009150 <_vfprintf_r+0x127c>
80009146:	fa cb f9 44 	sub	r11,sp,-1724
8000914a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000914e:	c1 f8       	rjmp	8000918c <_vfprintf_r+0x12b8>
80009150:	fa c8 f9 50 	sub	r8,sp,-1712
80009154:	1a d8       	st.w	--sp,r8
80009156:	fa c8 fa b8 	sub	r8,sp,-1352
8000915a:	0c 9b       	mov	r11,r6
8000915c:	1a d8       	st.w	--sp,r8
8000915e:	fa c8 fb b4 	sub	r8,sp,-1100
80009162:	04 9a       	mov	r10,r2
80009164:	1a d8       	st.w	--sp,r8
80009166:	08 9c       	mov	r12,r4
80009168:	fa c8 f9 40 	sub	r8,sp,-1728
8000916c:	fa c9 ff b4 	sub	r9,sp,-76
80009170:	fe b0 f5 1a 	rcall	80007ba4 <get_arg>
80009174:	2f dd       	sub	sp,-12
80009176:	78 0b       	ld.w	r11,r12[0x0]
80009178:	c2 48       	rjmp	800091c0 <_vfprintf_r+0x12ec>
8000917a:	ee ca ff ff 	sub	r10,r7,-1
8000917e:	10 37       	cp.w	r7,r8
80009180:	c0 94       	brge	80009192 <_vfprintf_r+0x12be>
80009182:	fa c9 f9 44 	sub	r9,sp,-1724
80009186:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000918a:	14 97       	mov	r7,r10
8000918c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009190:	c1 88       	rjmp	800091c0 <_vfprintf_r+0x12ec>
80009192:	41 09       	lddsp	r9,sp[0x40]
80009194:	59 f8       	cp.w	r8,31
80009196:	e0 89 00 11 	brgt	800091b8 <_vfprintf_r+0x12e4>
8000919a:	f2 cb ff fc 	sub	r11,r9,-4
8000919e:	51 0b       	stdsp	sp[0x40],r11
800091a0:	fa c6 f9 44 	sub	r6,sp,-1724
800091a4:	72 0b       	ld.w	r11,r9[0x0]
800091a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091aa:	f3 4b fd 88 	st.w	r9[-632],r11
800091ae:	2f f8       	sub	r8,-1
800091b0:	14 97       	mov	r7,r10
800091b2:	fb 48 06 b4 	st.w	sp[1716],r8
800091b6:	c0 58       	rjmp	800091c0 <_vfprintf_r+0x12ec>
800091b8:	72 0b       	ld.w	r11,r9[0x0]
800091ba:	14 97       	mov	r7,r10
800091bc:	2f c9       	sub	r9,-4
800091be:	51 09       	stdsp	sp[0x40],r9
800091c0:	50 1b       	stdsp	sp[0x4],r11
800091c2:	30 0e       	mov	lr,0
800091c4:	30 18       	mov	r8,1
800091c6:	50 0e       	stdsp	sp[0x0],lr
800091c8:	c2 29       	rjmp	8000940c <_vfprintf_r+0x1538>
800091ca:	50 a7       	stdsp	sp[0x28],r7
800091cc:	50 80       	stdsp	sp[0x20],r0
800091ce:	0c 97       	mov	r7,r6
800091d0:	04 94       	mov	r4,r2
800091d2:	06 96       	mov	r6,r3
800091d4:	02 92       	mov	r2,r1
800091d6:	fe cc b4 2e 	sub	r12,pc,-19410
800091da:	40 93       	lddsp	r3,sp[0x24]
800091dc:	10 90       	mov	r0,r8
800091de:	40 41       	lddsp	r1,sp[0x10]
800091e0:	50 dc       	stdsp	sp[0x34],r12
800091e2:	ed b5 00 05 	bld	r5,0x5
800091e6:	c5 51       	brne	80009290 <_vfprintf_r+0x13bc>
800091e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091ec:	40 3b       	lddsp	r11,sp[0xc]
800091ee:	58 0b       	cp.w	r11,0
800091f0:	c2 20       	breq	80009234 <_vfprintf_r+0x1360>
800091f2:	10 36       	cp.w	r6,r8
800091f4:	c0 a4       	brge	80009208 <_vfprintf_r+0x1334>
800091f6:	fa ca f9 44 	sub	r10,sp,-1724
800091fa:	f4 06 00 36 	add	r6,r10,r6<<0x3
800091fe:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009202:	fa e9 00 00 	st.d	sp[0],r8
80009206:	cf 28       	rjmp	800093ea <_vfprintf_r+0x1516>
80009208:	fa c8 f9 50 	sub	r8,sp,-1712
8000920c:	1a d8       	st.w	--sp,r8
8000920e:	fa c8 fa b8 	sub	r8,sp,-1352
80009212:	04 9a       	mov	r10,r2
80009214:	1a d8       	st.w	--sp,r8
80009216:	0c 9b       	mov	r11,r6
80009218:	fa c8 fb b4 	sub	r8,sp,-1100
8000921c:	08 9c       	mov	r12,r4
8000921e:	1a d8       	st.w	--sp,r8
80009220:	fa c8 f9 40 	sub	r8,sp,-1728
80009224:	fa c9 ff b4 	sub	r9,sp,-76
80009228:	fe b0 f4 be 	rcall	80007ba4 <get_arg>
8000922c:	2f dd       	sub	sp,-12
8000922e:	f8 ea 00 00 	ld.d	r10,r12[0]
80009232:	c0 c8       	rjmp	8000924a <_vfprintf_r+0x1376>
80009234:	ee ca ff ff 	sub	r10,r7,-1
80009238:	10 37       	cp.w	r7,r8
8000923a:	c0 b4       	brge	80009250 <_vfprintf_r+0x137c>
8000923c:	fa c9 f9 44 	sub	r9,sp,-1724
80009240:	14 97       	mov	r7,r10
80009242:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009246:	ec ea fd 88 	ld.d	r10,r6[-632]
8000924a:	fa eb 00 00 	st.d	sp[0],r10
8000924e:	cc e8       	rjmp	800093ea <_vfprintf_r+0x1516>
80009250:	41 09       	lddsp	r9,sp[0x40]
80009252:	59 f8       	cp.w	r8,31
80009254:	e0 89 00 16 	brgt	80009280 <_vfprintf_r+0x13ac>
80009258:	f2 e6 00 00 	ld.d	r6,r9[0]
8000925c:	f2 cb ff f8 	sub	r11,r9,-8
80009260:	fa e7 00 00 	st.d	sp[0],r6
80009264:	51 0b       	stdsp	sp[0x40],r11
80009266:	fa c6 f9 44 	sub	r6,sp,-1724
8000926a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000926e:	fa e6 00 00 	ld.d	r6,sp[0]
80009272:	f2 e7 fd 88 	st.d	r9[-632],r6
80009276:	2f f8       	sub	r8,-1
80009278:	14 97       	mov	r7,r10
8000927a:	fb 48 06 b4 	st.w	sp[1716],r8
8000927e:	cb 68       	rjmp	800093ea <_vfprintf_r+0x1516>
80009280:	f2 e6 00 00 	ld.d	r6,r9[0]
80009284:	2f 89       	sub	r9,-8
80009286:	fa e7 00 00 	st.d	sp[0],r6
8000928a:	51 09       	stdsp	sp[0x40],r9
8000928c:	14 97       	mov	r7,r10
8000928e:	ca e8       	rjmp	800093ea <_vfprintf_r+0x1516>
80009290:	ed b5 00 04 	bld	r5,0x4
80009294:	c1 71       	brne	800092c2 <_vfprintf_r+0x13ee>
80009296:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000929a:	40 3e       	lddsp	lr,sp[0xc]
8000929c:	58 0e       	cp.w	lr,0
8000929e:	c0 80       	breq	800092ae <_vfprintf_r+0x13da>
800092a0:	10 36       	cp.w	r6,r8
800092a2:	c6 94       	brge	80009374 <_vfprintf_r+0x14a0>
800092a4:	fa cc f9 44 	sub	r12,sp,-1724
800092a8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800092ac:	c8 28       	rjmp	800093b0 <_vfprintf_r+0x14dc>
800092ae:	ee ca ff ff 	sub	r10,r7,-1
800092b2:	10 37       	cp.w	r7,r8
800092b4:	e0 84 00 81 	brge	800093b6 <_vfprintf_r+0x14e2>
800092b8:	fa cb f9 44 	sub	r11,sp,-1724
800092bc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092c0:	c7 78       	rjmp	800093ae <_vfprintf_r+0x14da>
800092c2:	ed b5 00 06 	bld	r5,0x6
800092c6:	c4 b1       	brne	8000935c <_vfprintf_r+0x1488>
800092c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092cc:	40 3c       	lddsp	r12,sp[0xc]
800092ce:	58 0c       	cp.w	r12,0
800092d0:	c1 d0       	breq	8000930a <_vfprintf_r+0x1436>
800092d2:	10 36       	cp.w	r6,r8
800092d4:	c0 64       	brge	800092e0 <_vfprintf_r+0x140c>
800092d6:	fa cb f9 44 	sub	r11,sp,-1724
800092da:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092de:	c1 f8       	rjmp	8000931c <_vfprintf_r+0x1448>
800092e0:	fa c8 f9 50 	sub	r8,sp,-1712
800092e4:	1a d8       	st.w	--sp,r8
800092e6:	fa c8 fa b8 	sub	r8,sp,-1352
800092ea:	1a d8       	st.w	--sp,r8
800092ec:	fa c8 fb b4 	sub	r8,sp,-1100
800092f0:	1a d8       	st.w	--sp,r8
800092f2:	fa c8 f9 40 	sub	r8,sp,-1728
800092f6:	fa c9 ff b4 	sub	r9,sp,-76
800092fa:	04 9a       	mov	r10,r2
800092fc:	0c 9b       	mov	r11,r6
800092fe:	08 9c       	mov	r12,r4
80009300:	fe b0 f4 52 	rcall	80007ba4 <get_arg>
80009304:	2f dd       	sub	sp,-12
80009306:	98 18       	ld.sh	r8,r12[0x2]
80009308:	c2 78       	rjmp	80009356 <_vfprintf_r+0x1482>
8000930a:	ee ca ff ff 	sub	r10,r7,-1
8000930e:	10 37       	cp.w	r7,r8
80009310:	c0 a4       	brge	80009324 <_vfprintf_r+0x1450>
80009312:	fa c9 f9 44 	sub	r9,sp,-1724
80009316:	14 97       	mov	r7,r10
80009318:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000931c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009320:	c1 b8       	rjmp	80009356 <_vfprintf_r+0x1482>
80009322:	d7 03       	nop
80009324:	41 09       	lddsp	r9,sp[0x40]
80009326:	59 f8       	cp.w	r8,31
80009328:	e0 89 00 13 	brgt	8000934e <_vfprintf_r+0x147a>
8000932c:	f2 cb ff fc 	sub	r11,r9,-4
80009330:	51 0b       	stdsp	sp[0x40],r11
80009332:	72 09       	ld.w	r9,r9[0x0]
80009334:	fa c6 f9 44 	sub	r6,sp,-1724
80009338:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000933c:	2f f8       	sub	r8,-1
8000933e:	f7 49 fd 88 	st.w	r11[-632],r9
80009342:	fb 48 06 b4 	st.w	sp[1716],r8
80009346:	14 97       	mov	r7,r10
80009348:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000934c:	c0 58       	rjmp	80009356 <_vfprintf_r+0x1482>
8000934e:	92 18       	ld.sh	r8,r9[0x2]
80009350:	14 97       	mov	r7,r10
80009352:	2f c9       	sub	r9,-4
80009354:	51 09       	stdsp	sp[0x40],r9
80009356:	5c 78       	castu.h	r8
80009358:	50 18       	stdsp	sp[0x4],r8
8000935a:	c4 68       	rjmp	800093e6 <_vfprintf_r+0x1512>
8000935c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009360:	40 3c       	lddsp	r12,sp[0xc]
80009362:	58 0c       	cp.w	r12,0
80009364:	c1 d0       	breq	8000939e <_vfprintf_r+0x14ca>
80009366:	10 36       	cp.w	r6,r8
80009368:	c0 64       	brge	80009374 <_vfprintf_r+0x14a0>
8000936a:	fa cb f9 44 	sub	r11,sp,-1724
8000936e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009372:	c1 f8       	rjmp	800093b0 <_vfprintf_r+0x14dc>
80009374:	fa c8 f9 50 	sub	r8,sp,-1712
80009378:	1a d8       	st.w	--sp,r8
8000937a:	fa c8 fa b8 	sub	r8,sp,-1352
8000937e:	0c 9b       	mov	r11,r6
80009380:	1a d8       	st.w	--sp,r8
80009382:	fa c8 fb b4 	sub	r8,sp,-1100
80009386:	04 9a       	mov	r10,r2
80009388:	1a d8       	st.w	--sp,r8
8000938a:	08 9c       	mov	r12,r4
8000938c:	fa c8 f9 40 	sub	r8,sp,-1728
80009390:	fa c9 ff b4 	sub	r9,sp,-76
80009394:	fe b0 f4 08 	rcall	80007ba4 <get_arg>
80009398:	2f dd       	sub	sp,-12
8000939a:	78 0b       	ld.w	r11,r12[0x0]
8000939c:	c2 48       	rjmp	800093e4 <_vfprintf_r+0x1510>
8000939e:	ee ca ff ff 	sub	r10,r7,-1
800093a2:	10 37       	cp.w	r7,r8
800093a4:	c0 94       	brge	800093b6 <_vfprintf_r+0x14e2>
800093a6:	fa c9 f9 44 	sub	r9,sp,-1724
800093aa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093ae:	14 97       	mov	r7,r10
800093b0:	ec fb fd 88 	ld.w	r11,r6[-632]
800093b4:	c1 88       	rjmp	800093e4 <_vfprintf_r+0x1510>
800093b6:	41 09       	lddsp	r9,sp[0x40]
800093b8:	59 f8       	cp.w	r8,31
800093ba:	e0 89 00 11 	brgt	800093dc <_vfprintf_r+0x1508>
800093be:	f2 cb ff fc 	sub	r11,r9,-4
800093c2:	51 0b       	stdsp	sp[0x40],r11
800093c4:	fa c6 f9 44 	sub	r6,sp,-1724
800093c8:	72 0b       	ld.w	r11,r9[0x0]
800093ca:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093ce:	f3 4b fd 88 	st.w	r9[-632],r11
800093d2:	2f f8       	sub	r8,-1
800093d4:	14 97       	mov	r7,r10
800093d6:	fb 48 06 b4 	st.w	sp[1716],r8
800093da:	c0 58       	rjmp	800093e4 <_vfprintf_r+0x1510>
800093dc:	72 0b       	ld.w	r11,r9[0x0]
800093de:	14 97       	mov	r7,r10
800093e0:	2f c9       	sub	r9,-4
800093e2:	51 09       	stdsp	sp[0x40],r9
800093e4:	50 1b       	stdsp	sp[0x4],r11
800093e6:	30 0e       	mov	lr,0
800093e8:	50 0e       	stdsp	sp[0x0],lr
800093ea:	40 08       	lddsp	r8,sp[0x0]
800093ec:	40 1c       	lddsp	r12,sp[0x4]
800093ee:	18 48       	or	r8,r12
800093f0:	5f 19       	srne	r9
800093f2:	0a 98       	mov	r8,r5
800093f4:	eb e9 00 09 	and	r9,r5,r9
800093f8:	a1 b8       	sbr	r8,0x1
800093fa:	58 09       	cp.w	r9,0
800093fc:	c0 70       	breq	8000940a <_vfprintf_r+0x1536>
800093fe:	10 95       	mov	r5,r8
80009400:	fb 60 06 b9 	st.b	sp[1721],r0
80009404:	33 08       	mov	r8,48
80009406:	fb 68 06 b8 	st.b	sp[1720],r8
8000940a:	30 28       	mov	r8,2
8000940c:	30 09       	mov	r9,0
8000940e:	fb 69 06 bb 	st.b	sp[1723],r9
80009412:	0a 99       	mov	r9,r5
80009414:	a7 d9       	cbr	r9,0x7
80009416:	40 2b       	lddsp	r11,sp[0x8]
80009418:	40 16       	lddsp	r6,sp[0x4]
8000941a:	58 0b       	cp.w	r11,0
8000941c:	5f 1a       	srne	r10
8000941e:	f2 05 17 40 	movge	r5,r9
80009422:	fa c2 f9 78 	sub	r2,sp,-1672
80009426:	40 09       	lddsp	r9,sp[0x0]
80009428:	0c 49       	or	r9,r6
8000942a:	5f 19       	srne	r9
8000942c:	f5 e9 10 09 	or	r9,r10,r9
80009430:	c5 c0       	breq	800094e8 <_vfprintf_r+0x1614>
80009432:	30 19       	mov	r9,1
80009434:	f2 08 18 00 	cp.b	r8,r9
80009438:	c0 60       	breq	80009444 <_vfprintf_r+0x1570>
8000943a:	30 29       	mov	r9,2
8000943c:	f2 08 18 00 	cp.b	r8,r9
80009440:	c0 41       	brne	80009448 <_vfprintf_r+0x1574>
80009442:	c3 c8       	rjmp	800094ba <_vfprintf_r+0x15e6>
80009444:	04 96       	mov	r6,r2
80009446:	c3 08       	rjmp	800094a6 <_vfprintf_r+0x15d2>
80009448:	04 96       	mov	r6,r2
8000944a:	fa e8 00 00 	ld.d	r8,sp[0]
8000944e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009452:	2d 0a       	sub	r10,-48
80009454:	0c fa       	st.b	--r6,r10
80009456:	f0 0b 16 03 	lsr	r11,r8,0x3
8000945a:	f2 0c 16 03 	lsr	r12,r9,0x3
8000945e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009462:	18 99       	mov	r9,r12
80009464:	16 98       	mov	r8,r11
80009466:	58 08       	cp.w	r8,0
80009468:	5c 29       	cpc	r9
8000946a:	cf 21       	brne	8000944e <_vfprintf_r+0x157a>
8000946c:	fa e9 00 00 	st.d	sp[0],r8
80009470:	ed b5 00 00 	bld	r5,0x0
80009474:	c4 51       	brne	800094fe <_vfprintf_r+0x162a>
80009476:	33 09       	mov	r9,48
80009478:	f2 0a 18 00 	cp.b	r10,r9
8000947c:	c4 10       	breq	800094fe <_vfprintf_r+0x162a>
8000947e:	0c f9       	st.b	--r6,r9
80009480:	c3 f8       	rjmp	800094fe <_vfprintf_r+0x162a>
80009482:	fa ea 00 00 	ld.d	r10,sp[0]
80009486:	30 a8       	mov	r8,10
80009488:	30 09       	mov	r9,0
8000948a:	e0 a0 1a 19 	rcall	8000c8bc <__avr32_umod64>
8000948e:	30 a8       	mov	r8,10
80009490:	2d 0a       	sub	r10,-48
80009492:	30 09       	mov	r9,0
80009494:	ac 8a       	st.b	r6[0x0],r10
80009496:	fa ea 00 00 	ld.d	r10,sp[0]
8000949a:	e0 a0 18 df 	rcall	8000c658 <__avr32_udiv64>
8000949e:	16 99       	mov	r9,r11
800094a0:	14 98       	mov	r8,r10
800094a2:	fa e9 00 00 	st.d	sp[0],r8
800094a6:	20 16       	sub	r6,1
800094a8:	fa ea 00 00 	ld.d	r10,sp[0]
800094ac:	58 9a       	cp.w	r10,9
800094ae:	5c 2b       	cpc	r11
800094b0:	fe 9b ff e9 	brhi	80009482 <_vfprintf_r+0x15ae>
800094b4:	1b f8       	ld.ub	r8,sp[0x7]
800094b6:	2d 08       	sub	r8,-48
800094b8:	c2 08       	rjmp	800094f8 <_vfprintf_r+0x1624>
800094ba:	04 96       	mov	r6,r2
800094bc:	fa e8 00 00 	ld.d	r8,sp[0]
800094c0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800094c4:	40 de       	lddsp	lr,sp[0x34]
800094c6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800094ca:	0c fa       	st.b	--r6,r10
800094cc:	f2 0b 16 04 	lsr	r11,r9,0x4
800094d0:	f0 0a 16 04 	lsr	r10,r8,0x4
800094d4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800094d8:	16 99       	mov	r9,r11
800094da:	14 98       	mov	r8,r10
800094dc:	58 08       	cp.w	r8,0
800094de:	5c 29       	cpc	r9
800094e0:	cf 01       	brne	800094c0 <_vfprintf_r+0x15ec>
800094e2:	fa e9 00 00 	st.d	sp[0],r8
800094e6:	c0 c8       	rjmp	800094fe <_vfprintf_r+0x162a>
800094e8:	58 08       	cp.w	r8,0
800094ea:	c0 91       	brne	800094fc <_vfprintf_r+0x1628>
800094ec:	ed b5 00 00 	bld	r5,0x0
800094f0:	c0 61       	brne	800094fc <_vfprintf_r+0x1628>
800094f2:	fa c6 f9 79 	sub	r6,sp,-1671
800094f6:	33 08       	mov	r8,48
800094f8:	ac 88       	st.b	r6[0x0],r8
800094fa:	c0 28       	rjmp	800094fe <_vfprintf_r+0x162a>
800094fc:	04 96       	mov	r6,r2
800094fe:	0c 12       	sub	r2,r6
80009500:	c1 c8       	rjmp	80009538 <_vfprintf_r+0x1664>
80009502:	50 a7       	stdsp	sp[0x28],r7
80009504:	50 80       	stdsp	sp[0x20],r0
80009506:	40 93       	lddsp	r3,sp[0x24]
80009508:	0c 97       	mov	r7,r6
8000950a:	10 90       	mov	r0,r8
8000950c:	04 94       	mov	r4,r2
8000950e:	40 41       	lddsp	r1,sp[0x10]
80009510:	58 08       	cp.w	r8,0
80009512:	e0 80 04 4f 	breq	80009db0 <_vfprintf_r+0x1edc>
80009516:	fb 68 06 60 	st.b	sp[1632],r8
8000951a:	30 0c       	mov	r12,0
8000951c:	30 08       	mov	r8,0
8000951e:	30 12       	mov	r2,1
80009520:	fb 68 06 bb 	st.b	sp[1723],r8
80009524:	50 2c       	stdsp	sp[0x8],r12
80009526:	fa c6 f9 a0 	sub	r6,sp,-1632
8000952a:	c0 78       	rjmp	80009538 <_vfprintf_r+0x1664>
8000952c:	30 0b       	mov	r11,0
8000952e:	50 2b       	stdsp	sp[0x8],r11
80009530:	c0 48       	rjmp	80009538 <_vfprintf_r+0x1664>
80009532:	40 22       	lddsp	r2,sp[0x8]
80009534:	30 0a       	mov	r10,0
80009536:	50 2a       	stdsp	sp[0x8],r10
80009538:	40 29       	lddsp	r9,sp[0x8]
8000953a:	e4 09 0c 49 	max	r9,r2,r9
8000953e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009542:	50 39       	stdsp	sp[0xc],r9
80009544:	0a 9e       	mov	lr,r5
80009546:	30 09       	mov	r9,0
80009548:	e2 1e 00 02 	andl	lr,0x2,COH
8000954c:	f2 08 18 00 	cp.b	r8,r9
80009550:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009554:	f7 b8 01 ff 	subne	r8,-1
80009558:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000955c:	0a 9b       	mov	r11,r5
8000955e:	58 0e       	cp.w	lr,0
80009560:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009564:	f7 bc 01 fe 	subne	r12,-2
80009568:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000956c:	e2 1b 00 84 	andl	r11,0x84,COH
80009570:	50 fe       	stdsp	sp[0x3c],lr
80009572:	50 9b       	stdsp	sp[0x24],r11
80009574:	c4 71       	brne	80009602 <_vfprintf_r+0x172e>
80009576:	40 8a       	lddsp	r10,sp[0x20]
80009578:	40 39       	lddsp	r9,sp[0xc]
8000957a:	12 1a       	sub	r10,r9
8000957c:	50 4a       	stdsp	sp[0x10],r10
8000957e:	58 0a       	cp.w	r10,0
80009580:	e0 89 00 20 	brgt	800095c0 <_vfprintf_r+0x16ec>
80009584:	c3 f8       	rjmp	80009602 <_vfprintf_r+0x172e>
80009586:	2f 09       	sub	r9,-16
80009588:	2f f8       	sub	r8,-1
8000958a:	fe ce b7 ca 	sub	lr,pc,-18486
8000958e:	31 0c       	mov	r12,16
80009590:	fb 49 06 90 	st.w	sp[1680],r9
80009594:	87 0e       	st.w	r3[0x0],lr
80009596:	87 1c       	st.w	r3[0x4],r12
80009598:	fb 48 06 8c 	st.w	sp[1676],r8
8000959c:	58 78       	cp.w	r8,7
8000959e:	e0 89 00 04 	brgt	800095a6 <_vfprintf_r+0x16d2>
800095a2:	2f 83       	sub	r3,-8
800095a4:	c0 b8       	rjmp	800095ba <_vfprintf_r+0x16e6>
800095a6:	fa ca f9 78 	sub	r10,sp,-1672
800095aa:	02 9b       	mov	r11,r1
800095ac:	08 9c       	mov	r12,r4
800095ae:	fe b0 f4 85 	rcall	80007eb8 <__sprint_r>
800095b2:	e0 81 04 10 	brne	80009dd2 <_vfprintf_r+0x1efe>
800095b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800095ba:	40 4b       	lddsp	r11,sp[0x10]
800095bc:	21 0b       	sub	r11,16
800095be:	50 4b       	stdsp	sp[0x10],r11
800095c0:	fa f9 06 90 	ld.w	r9,sp[1680]
800095c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095c8:	fe ca b8 08 	sub	r10,pc,-18424
800095cc:	40 4e       	lddsp	lr,sp[0x10]
800095ce:	59 0e       	cp.w	lr,16
800095d0:	fe 99 ff db 	brgt	80009586 <_vfprintf_r+0x16b2>
800095d4:	1c 09       	add	r9,lr
800095d6:	2f f8       	sub	r8,-1
800095d8:	87 0a       	st.w	r3[0x0],r10
800095da:	fb 49 06 90 	st.w	sp[1680],r9
800095de:	87 1e       	st.w	r3[0x4],lr
800095e0:	fb 48 06 8c 	st.w	sp[1676],r8
800095e4:	58 78       	cp.w	r8,7
800095e6:	e0 89 00 04 	brgt	800095ee <_vfprintf_r+0x171a>
800095ea:	2f 83       	sub	r3,-8
800095ec:	c0 b8       	rjmp	80009602 <_vfprintf_r+0x172e>
800095ee:	fa ca f9 78 	sub	r10,sp,-1672
800095f2:	02 9b       	mov	r11,r1
800095f4:	08 9c       	mov	r12,r4
800095f6:	fe b0 f4 61 	rcall	80007eb8 <__sprint_r>
800095fa:	e0 81 03 ec 	brne	80009dd2 <_vfprintf_r+0x1efe>
800095fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009602:	30 09       	mov	r9,0
80009604:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009608:	f2 08 18 00 	cp.b	r8,r9
8000960c:	c1 f0       	breq	8000964a <_vfprintf_r+0x1776>
8000960e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009612:	fa c9 f9 45 	sub	r9,sp,-1723
80009616:	2f f8       	sub	r8,-1
80009618:	87 09       	st.w	r3[0x0],r9
8000961a:	fb 48 06 90 	st.w	sp[1680],r8
8000961e:	30 19       	mov	r9,1
80009620:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009624:	87 19       	st.w	r3[0x4],r9
80009626:	2f f8       	sub	r8,-1
80009628:	fb 48 06 8c 	st.w	sp[1676],r8
8000962c:	58 78       	cp.w	r8,7
8000962e:	e0 89 00 04 	brgt	80009636 <_vfprintf_r+0x1762>
80009632:	2f 83       	sub	r3,-8
80009634:	c0 b8       	rjmp	8000964a <_vfprintf_r+0x1776>
80009636:	fa ca f9 78 	sub	r10,sp,-1672
8000963a:	02 9b       	mov	r11,r1
8000963c:	08 9c       	mov	r12,r4
8000963e:	fe b0 f4 3d 	rcall	80007eb8 <__sprint_r>
80009642:	e0 81 03 c8 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009646:	fa c3 f9 e0 	sub	r3,sp,-1568
8000964a:	40 fc       	lddsp	r12,sp[0x3c]
8000964c:	58 0c       	cp.w	r12,0
8000964e:	c1 f0       	breq	8000968c <_vfprintf_r+0x17b8>
80009650:	fa f8 06 90 	ld.w	r8,sp[1680]
80009654:	fa c9 f9 48 	sub	r9,sp,-1720
80009658:	2f e8       	sub	r8,-2
8000965a:	87 09       	st.w	r3[0x0],r9
8000965c:	fb 48 06 90 	st.w	sp[1680],r8
80009660:	30 29       	mov	r9,2
80009662:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009666:	87 19       	st.w	r3[0x4],r9
80009668:	2f f8       	sub	r8,-1
8000966a:	fb 48 06 8c 	st.w	sp[1676],r8
8000966e:	58 78       	cp.w	r8,7
80009670:	e0 89 00 04 	brgt	80009678 <_vfprintf_r+0x17a4>
80009674:	2f 83       	sub	r3,-8
80009676:	c0 b8       	rjmp	8000968c <_vfprintf_r+0x17b8>
80009678:	fa ca f9 78 	sub	r10,sp,-1672
8000967c:	02 9b       	mov	r11,r1
8000967e:	08 9c       	mov	r12,r4
80009680:	fe b0 f4 1c 	rcall	80007eb8 <__sprint_r>
80009684:	e0 81 03 a7 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009688:	fa c3 f9 e0 	sub	r3,sp,-1568
8000968c:	40 9b       	lddsp	r11,sp[0x24]
8000968e:	e0 4b 00 80 	cp.w	r11,128
80009692:	c4 71       	brne	80009720 <_vfprintf_r+0x184c>
80009694:	40 8a       	lddsp	r10,sp[0x20]
80009696:	40 39       	lddsp	r9,sp[0xc]
80009698:	12 1a       	sub	r10,r9
8000969a:	50 4a       	stdsp	sp[0x10],r10
8000969c:	58 0a       	cp.w	r10,0
8000969e:	e0 89 00 20 	brgt	800096de <_vfprintf_r+0x180a>
800096a2:	c3 f8       	rjmp	80009720 <_vfprintf_r+0x184c>
800096a4:	2f 09       	sub	r9,-16
800096a6:	2f f8       	sub	r8,-1
800096a8:	fe ce b8 d8 	sub	lr,pc,-18216
800096ac:	31 0c       	mov	r12,16
800096ae:	fb 49 06 90 	st.w	sp[1680],r9
800096b2:	87 0e       	st.w	r3[0x0],lr
800096b4:	87 1c       	st.w	r3[0x4],r12
800096b6:	fb 48 06 8c 	st.w	sp[1676],r8
800096ba:	58 78       	cp.w	r8,7
800096bc:	e0 89 00 04 	brgt	800096c4 <_vfprintf_r+0x17f0>
800096c0:	2f 83       	sub	r3,-8
800096c2:	c0 b8       	rjmp	800096d8 <_vfprintf_r+0x1804>
800096c4:	fa ca f9 78 	sub	r10,sp,-1672
800096c8:	02 9b       	mov	r11,r1
800096ca:	08 9c       	mov	r12,r4
800096cc:	fe b0 f3 f6 	rcall	80007eb8 <__sprint_r>
800096d0:	e0 81 03 81 	brne	80009dd2 <_vfprintf_r+0x1efe>
800096d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800096d8:	40 4b       	lddsp	r11,sp[0x10]
800096da:	21 0b       	sub	r11,16
800096dc:	50 4b       	stdsp	sp[0x10],r11
800096de:	fa f9 06 90 	ld.w	r9,sp[1680]
800096e2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096e6:	fe ca b9 16 	sub	r10,pc,-18154
800096ea:	40 4e       	lddsp	lr,sp[0x10]
800096ec:	59 0e       	cp.w	lr,16
800096ee:	fe 99 ff db 	brgt	800096a4 <_vfprintf_r+0x17d0>
800096f2:	1c 09       	add	r9,lr
800096f4:	2f f8       	sub	r8,-1
800096f6:	87 0a       	st.w	r3[0x0],r10
800096f8:	fb 49 06 90 	st.w	sp[1680],r9
800096fc:	87 1e       	st.w	r3[0x4],lr
800096fe:	fb 48 06 8c 	st.w	sp[1676],r8
80009702:	58 78       	cp.w	r8,7
80009704:	e0 89 00 04 	brgt	8000970c <_vfprintf_r+0x1838>
80009708:	2f 83       	sub	r3,-8
8000970a:	c0 b8       	rjmp	80009720 <_vfprintf_r+0x184c>
8000970c:	fa ca f9 78 	sub	r10,sp,-1672
80009710:	02 9b       	mov	r11,r1
80009712:	08 9c       	mov	r12,r4
80009714:	fe b0 f3 d2 	rcall	80007eb8 <__sprint_r>
80009718:	e0 81 03 5d 	brne	80009dd2 <_vfprintf_r+0x1efe>
8000971c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009720:	40 2c       	lddsp	r12,sp[0x8]
80009722:	04 1c       	sub	r12,r2
80009724:	50 2c       	stdsp	sp[0x8],r12
80009726:	58 0c       	cp.w	r12,0
80009728:	e0 89 00 20 	brgt	80009768 <_vfprintf_r+0x1894>
8000972c:	c3 f8       	rjmp	800097aa <_vfprintf_r+0x18d6>
8000972e:	2f 09       	sub	r9,-16
80009730:	2f f8       	sub	r8,-1
80009732:	fe cb b9 62 	sub	r11,pc,-18078
80009736:	31 0a       	mov	r10,16
80009738:	fb 49 06 90 	st.w	sp[1680],r9
8000973c:	87 0b       	st.w	r3[0x0],r11
8000973e:	87 1a       	st.w	r3[0x4],r10
80009740:	fb 48 06 8c 	st.w	sp[1676],r8
80009744:	58 78       	cp.w	r8,7
80009746:	e0 89 00 04 	brgt	8000974e <_vfprintf_r+0x187a>
8000974a:	2f 83       	sub	r3,-8
8000974c:	c0 b8       	rjmp	80009762 <_vfprintf_r+0x188e>
8000974e:	fa ca f9 78 	sub	r10,sp,-1672
80009752:	02 9b       	mov	r11,r1
80009754:	08 9c       	mov	r12,r4
80009756:	fe b0 f3 b1 	rcall	80007eb8 <__sprint_r>
8000975a:	e0 81 03 3c 	brne	80009dd2 <_vfprintf_r+0x1efe>
8000975e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009762:	40 29       	lddsp	r9,sp[0x8]
80009764:	21 09       	sub	r9,16
80009766:	50 29       	stdsp	sp[0x8],r9
80009768:	fa f9 06 90 	ld.w	r9,sp[1680]
8000976c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009770:	fe ca b9 a0 	sub	r10,pc,-18016
80009774:	40 2e       	lddsp	lr,sp[0x8]
80009776:	59 0e       	cp.w	lr,16
80009778:	fe 99 ff db 	brgt	8000972e <_vfprintf_r+0x185a>
8000977c:	1c 09       	add	r9,lr
8000977e:	2f f8       	sub	r8,-1
80009780:	87 0a       	st.w	r3[0x0],r10
80009782:	fb 49 06 90 	st.w	sp[1680],r9
80009786:	87 1e       	st.w	r3[0x4],lr
80009788:	fb 48 06 8c 	st.w	sp[1676],r8
8000978c:	58 78       	cp.w	r8,7
8000978e:	e0 89 00 04 	brgt	80009796 <_vfprintf_r+0x18c2>
80009792:	2f 83       	sub	r3,-8
80009794:	c0 b8       	rjmp	800097aa <_vfprintf_r+0x18d6>
80009796:	fa ca f9 78 	sub	r10,sp,-1672
8000979a:	02 9b       	mov	r11,r1
8000979c:	08 9c       	mov	r12,r4
8000979e:	fe b0 f3 8d 	rcall	80007eb8 <__sprint_r>
800097a2:	e0 81 03 18 	brne	80009dd2 <_vfprintf_r+0x1efe>
800097a6:	fa c3 f9 e0 	sub	r3,sp,-1568
800097aa:	ed b5 00 08 	bld	r5,0x8
800097ae:	c0 b0       	breq	800097c4 <_vfprintf_r+0x18f0>
800097b0:	fa f8 06 90 	ld.w	r8,sp[1680]
800097b4:	87 12       	st.w	r3[0x4],r2
800097b6:	87 06       	st.w	r3[0x0],r6
800097b8:	f0 02 00 02 	add	r2,r8,r2
800097bc:	fb 42 06 90 	st.w	sp[1680],r2
800097c0:	e0 8f 01 d4 	bral	80009b68 <_vfprintf_r+0x1c94>
800097c4:	e0 40 00 65 	cp.w	r0,101
800097c8:	e0 8a 01 d6 	brle	80009b74 <_vfprintf_r+0x1ca0>
800097cc:	30 08       	mov	r8,0
800097ce:	30 09       	mov	r9,0
800097d0:	40 5b       	lddsp	r11,sp[0x14]
800097d2:	40 7a       	lddsp	r10,sp[0x1c]
800097d4:	e0 a0 15 3b 	rcall	8000c24a <__avr32_f64_cmp_eq>
800097d8:	c7 90       	breq	800098ca <_vfprintf_r+0x19f6>
800097da:	fa f8 06 90 	ld.w	r8,sp[1680]
800097de:	fe c9 ba 22 	sub	r9,pc,-17886
800097e2:	2f f8       	sub	r8,-1
800097e4:	87 09       	st.w	r3[0x0],r9
800097e6:	fb 48 06 90 	st.w	sp[1680],r8
800097ea:	30 19       	mov	r9,1
800097ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097f0:	87 19       	st.w	r3[0x4],r9
800097f2:	2f f8       	sub	r8,-1
800097f4:	fb 48 06 8c 	st.w	sp[1676],r8
800097f8:	58 78       	cp.w	r8,7
800097fa:	e0 89 00 05 	brgt	80009804 <_vfprintf_r+0x1930>
800097fe:	2f 83       	sub	r3,-8
80009800:	c0 c8       	rjmp	80009818 <_vfprintf_r+0x1944>
80009802:	d7 03       	nop
80009804:	fa ca f9 78 	sub	r10,sp,-1672
80009808:	02 9b       	mov	r11,r1
8000980a:	08 9c       	mov	r12,r4
8000980c:	fe b0 f3 56 	rcall	80007eb8 <__sprint_r>
80009810:	e0 81 02 e1 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009814:	fa c3 f9 e0 	sub	r3,sp,-1568
80009818:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000981c:	40 6c       	lddsp	r12,sp[0x18]
8000981e:	18 38       	cp.w	r8,r12
80009820:	c0 55       	brlt	8000982a <_vfprintf_r+0x1956>
80009822:	ed b5 00 00 	bld	r5,0x0
80009826:	e0 81 02 6b 	brne	80009cfc <_vfprintf_r+0x1e28>
8000982a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000982e:	2f f8       	sub	r8,-1
80009830:	40 cb       	lddsp	r11,sp[0x30]
80009832:	fb 48 06 90 	st.w	sp[1680],r8
80009836:	30 19       	mov	r9,1
80009838:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000983c:	87 0b       	st.w	r3[0x0],r11
8000983e:	2f f8       	sub	r8,-1
80009840:	87 19       	st.w	r3[0x4],r9
80009842:	fb 48 06 8c 	st.w	sp[1676],r8
80009846:	58 78       	cp.w	r8,7
80009848:	e0 89 00 04 	brgt	80009850 <_vfprintf_r+0x197c>
8000984c:	2f 83       	sub	r3,-8
8000984e:	c0 b8       	rjmp	80009864 <_vfprintf_r+0x1990>
80009850:	fa ca f9 78 	sub	r10,sp,-1672
80009854:	02 9b       	mov	r11,r1
80009856:	08 9c       	mov	r12,r4
80009858:	fe b0 f3 30 	rcall	80007eb8 <__sprint_r>
8000985c:	e0 81 02 bb 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009860:	fa c3 f9 e0 	sub	r3,sp,-1568
80009864:	40 66       	lddsp	r6,sp[0x18]
80009866:	20 16       	sub	r6,1
80009868:	58 06       	cp.w	r6,0
8000986a:	e0 89 00 1d 	brgt	800098a4 <_vfprintf_r+0x19d0>
8000986e:	e0 8f 02 47 	bral	80009cfc <_vfprintf_r+0x1e28>
80009872:	2f 09       	sub	r9,-16
80009874:	2f f8       	sub	r8,-1
80009876:	fb 49 06 90 	st.w	sp[1680],r9
8000987a:	87 02       	st.w	r3[0x0],r2
8000987c:	87 10       	st.w	r3[0x4],r0
8000987e:	fb 48 06 8c 	st.w	sp[1676],r8
80009882:	58 78       	cp.w	r8,7
80009884:	e0 89 00 04 	brgt	8000988c <_vfprintf_r+0x19b8>
80009888:	2f 83       	sub	r3,-8
8000988a:	c0 b8       	rjmp	800098a0 <_vfprintf_r+0x19cc>
8000988c:	fa ca f9 78 	sub	r10,sp,-1672
80009890:	02 9b       	mov	r11,r1
80009892:	08 9c       	mov	r12,r4
80009894:	fe b0 f3 12 	rcall	80007eb8 <__sprint_r>
80009898:	e0 81 02 9d 	brne	80009dd2 <_vfprintf_r+0x1efe>
8000989c:	fa c3 f9 e0 	sub	r3,sp,-1568
800098a0:	21 06       	sub	r6,16
800098a2:	c0 48       	rjmp	800098aa <_vfprintf_r+0x19d6>
800098a4:	fe c2 ba d4 	sub	r2,pc,-17708
800098a8:	31 00       	mov	r0,16
800098aa:	fa f9 06 90 	ld.w	r9,sp[1680]
800098ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098b2:	fe ca ba e2 	sub	r10,pc,-17694
800098b6:	59 06       	cp.w	r6,16
800098b8:	fe 99 ff dd 	brgt	80009872 <_vfprintf_r+0x199e>
800098bc:	0c 09       	add	r9,r6
800098be:	87 0a       	st.w	r3[0x0],r10
800098c0:	fb 49 06 90 	st.w	sp[1680],r9
800098c4:	2f f8       	sub	r8,-1
800098c6:	87 16       	st.w	r3[0x4],r6
800098c8:	c5 39       	rjmp	80009b6e <_vfprintf_r+0x1c9a>
800098ca:	fa fa 06 ac 	ld.w	r10,sp[1708]
800098ce:	58 0a       	cp.w	r10,0
800098d0:	e0 89 00 92 	brgt	800099f4 <_vfprintf_r+0x1b20>
800098d4:	fa f8 06 90 	ld.w	r8,sp[1680]
800098d8:	fe c9 bb 1c 	sub	r9,pc,-17636
800098dc:	2f f8       	sub	r8,-1
800098de:	87 09       	st.w	r3[0x0],r9
800098e0:	fb 48 06 90 	st.w	sp[1680],r8
800098e4:	30 19       	mov	r9,1
800098e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098ea:	87 19       	st.w	r3[0x4],r9
800098ec:	2f f8       	sub	r8,-1
800098ee:	fb 48 06 8c 	st.w	sp[1676],r8
800098f2:	58 78       	cp.w	r8,7
800098f4:	e0 89 00 04 	brgt	800098fc <_vfprintf_r+0x1a28>
800098f8:	2f 83       	sub	r3,-8
800098fa:	c0 b8       	rjmp	80009910 <_vfprintf_r+0x1a3c>
800098fc:	fa ca f9 78 	sub	r10,sp,-1672
80009900:	02 9b       	mov	r11,r1
80009902:	08 9c       	mov	r12,r4
80009904:	fe b0 f2 da 	rcall	80007eb8 <__sprint_r>
80009908:	e0 81 02 65 	brne	80009dd2 <_vfprintf_r+0x1efe>
8000990c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009910:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009914:	58 08       	cp.w	r8,0
80009916:	c0 81       	brne	80009926 <_vfprintf_r+0x1a52>
80009918:	40 6a       	lddsp	r10,sp[0x18]
8000991a:	58 0a       	cp.w	r10,0
8000991c:	c0 51       	brne	80009926 <_vfprintf_r+0x1a52>
8000991e:	ed b5 00 00 	bld	r5,0x0
80009922:	e0 81 01 ed 	brne	80009cfc <_vfprintf_r+0x1e28>
80009926:	40 c9       	lddsp	r9,sp[0x30]
80009928:	fa f8 06 90 	ld.w	r8,sp[1680]
8000992c:	2f f8       	sub	r8,-1
8000992e:	87 09       	st.w	r3[0x0],r9
80009930:	fb 48 06 90 	st.w	sp[1680],r8
80009934:	30 19       	mov	r9,1
80009936:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000993a:	87 19       	st.w	r3[0x4],r9
8000993c:	2f f8       	sub	r8,-1
8000993e:	fb 48 06 8c 	st.w	sp[1676],r8
80009942:	58 78       	cp.w	r8,7
80009944:	e0 89 00 04 	brgt	8000994c <_vfprintf_r+0x1a78>
80009948:	2f 83       	sub	r3,-8
8000994a:	c0 b8       	rjmp	80009960 <_vfprintf_r+0x1a8c>
8000994c:	fa ca f9 78 	sub	r10,sp,-1672
80009950:	02 9b       	mov	r11,r1
80009952:	08 9c       	mov	r12,r4
80009954:	fe b0 f2 b2 	rcall	80007eb8 <__sprint_r>
80009958:	e0 81 02 3d 	brne	80009dd2 <_vfprintf_r+0x1efe>
8000995c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009960:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009964:	5c 32       	neg	r2
80009966:	58 02       	cp.w	r2,0
80009968:	e0 89 00 1d 	brgt	800099a2 <_vfprintf_r+0x1ace>
8000996c:	c3 d8       	rjmp	800099e6 <_vfprintf_r+0x1b12>
8000996e:	2f 09       	sub	r9,-16
80009970:	2f f8       	sub	r8,-1
80009972:	31 0e       	mov	lr,16
80009974:	fb 49 06 90 	st.w	sp[1680],r9
80009978:	87 00       	st.w	r3[0x0],r0
8000997a:	87 1e       	st.w	r3[0x4],lr
8000997c:	fb 48 06 8c 	st.w	sp[1676],r8
80009980:	58 78       	cp.w	r8,7
80009982:	e0 89 00 04 	brgt	8000998a <_vfprintf_r+0x1ab6>
80009986:	2f 83       	sub	r3,-8
80009988:	c0 b8       	rjmp	8000999e <_vfprintf_r+0x1aca>
8000998a:	fa ca f9 78 	sub	r10,sp,-1672
8000998e:	02 9b       	mov	r11,r1
80009990:	08 9c       	mov	r12,r4
80009992:	fe b0 f2 93 	rcall	80007eb8 <__sprint_r>
80009996:	e0 81 02 1e 	brne	80009dd2 <_vfprintf_r+0x1efe>
8000999a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000999e:	21 02       	sub	r2,16
800099a0:	c0 38       	rjmp	800099a6 <_vfprintf_r+0x1ad2>
800099a2:	fe c0 bb d2 	sub	r0,pc,-17454
800099a6:	fa f9 06 90 	ld.w	r9,sp[1680]
800099aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099ae:	fe ca bb de 	sub	r10,pc,-17442
800099b2:	59 02       	cp.w	r2,16
800099b4:	fe 99 ff dd 	brgt	8000996e <_vfprintf_r+0x1a9a>
800099b8:	04 09       	add	r9,r2
800099ba:	2f f8       	sub	r8,-1
800099bc:	87 0a       	st.w	r3[0x0],r10
800099be:	fb 49 06 90 	st.w	sp[1680],r9
800099c2:	87 12       	st.w	r3[0x4],r2
800099c4:	fb 48 06 8c 	st.w	sp[1676],r8
800099c8:	58 78       	cp.w	r8,7
800099ca:	e0 89 00 04 	brgt	800099d2 <_vfprintf_r+0x1afe>
800099ce:	2f 83       	sub	r3,-8
800099d0:	c0 b8       	rjmp	800099e6 <_vfprintf_r+0x1b12>
800099d2:	fa ca f9 78 	sub	r10,sp,-1672
800099d6:	02 9b       	mov	r11,r1
800099d8:	08 9c       	mov	r12,r4
800099da:	fe b0 f2 6f 	rcall	80007eb8 <__sprint_r>
800099de:	e0 81 01 fa 	brne	80009dd2 <_vfprintf_r+0x1efe>
800099e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800099e6:	40 6c       	lddsp	r12,sp[0x18]
800099e8:	fa f8 06 90 	ld.w	r8,sp[1680]
800099ec:	87 06       	st.w	r3[0x0],r6
800099ee:	87 1c       	st.w	r3[0x4],r12
800099f0:	18 08       	add	r8,r12
800099f2:	cb 98       	rjmp	80009b64 <_vfprintf_r+0x1c90>
800099f4:	fa f9 06 90 	ld.w	r9,sp[1680]
800099f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099fc:	40 6b       	lddsp	r11,sp[0x18]
800099fe:	16 3a       	cp.w	r10,r11
80009a00:	c6 f5       	brlt	80009ade <_vfprintf_r+0x1c0a>
80009a02:	16 09       	add	r9,r11
80009a04:	2f f8       	sub	r8,-1
80009a06:	87 06       	st.w	r3[0x0],r6
80009a08:	fb 49 06 90 	st.w	sp[1680],r9
80009a0c:	87 1b       	st.w	r3[0x4],r11
80009a0e:	fb 48 06 8c 	st.w	sp[1676],r8
80009a12:	58 78       	cp.w	r8,7
80009a14:	e0 89 00 04 	brgt	80009a1c <_vfprintf_r+0x1b48>
80009a18:	2f 83       	sub	r3,-8
80009a1a:	c0 b8       	rjmp	80009a30 <_vfprintf_r+0x1b5c>
80009a1c:	fa ca f9 78 	sub	r10,sp,-1672
80009a20:	02 9b       	mov	r11,r1
80009a22:	08 9c       	mov	r12,r4
80009a24:	fe b0 f2 4a 	rcall	80007eb8 <__sprint_r>
80009a28:	e0 81 01 d5 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009a2c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a30:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009a34:	40 6a       	lddsp	r10,sp[0x18]
80009a36:	14 16       	sub	r6,r10
80009a38:	58 06       	cp.w	r6,0
80009a3a:	e0 89 00 1c 	brgt	80009a72 <_vfprintf_r+0x1b9e>
80009a3e:	c3 d8       	rjmp	80009ab8 <_vfprintf_r+0x1be4>
80009a40:	2f 09       	sub	r9,-16
80009a42:	2f f8       	sub	r8,-1
80009a44:	fb 49 06 90 	st.w	sp[1680],r9
80009a48:	87 02       	st.w	r3[0x0],r2
80009a4a:	87 10       	st.w	r3[0x4],r0
80009a4c:	fb 48 06 8c 	st.w	sp[1676],r8
80009a50:	58 78       	cp.w	r8,7
80009a52:	e0 89 00 04 	brgt	80009a5a <_vfprintf_r+0x1b86>
80009a56:	2f 83       	sub	r3,-8
80009a58:	c0 b8       	rjmp	80009a6e <_vfprintf_r+0x1b9a>
80009a5a:	fa ca f9 78 	sub	r10,sp,-1672
80009a5e:	02 9b       	mov	r11,r1
80009a60:	08 9c       	mov	r12,r4
80009a62:	fe b0 f2 2b 	rcall	80007eb8 <__sprint_r>
80009a66:	e0 81 01 b6 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009a6a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a6e:	21 06       	sub	r6,16
80009a70:	c0 48       	rjmp	80009a78 <_vfprintf_r+0x1ba4>
80009a72:	fe c2 bc a2 	sub	r2,pc,-17246
80009a76:	31 00       	mov	r0,16
80009a78:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a7c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a80:	fe ca bc b0 	sub	r10,pc,-17232
80009a84:	59 06       	cp.w	r6,16
80009a86:	fe 99 ff dd 	brgt	80009a40 <_vfprintf_r+0x1b6c>
80009a8a:	0c 09       	add	r9,r6
80009a8c:	2f f8       	sub	r8,-1
80009a8e:	87 0a       	st.w	r3[0x0],r10
80009a90:	fb 49 06 90 	st.w	sp[1680],r9
80009a94:	87 16       	st.w	r3[0x4],r6
80009a96:	fb 48 06 8c 	st.w	sp[1676],r8
80009a9a:	58 78       	cp.w	r8,7
80009a9c:	e0 89 00 04 	brgt	80009aa4 <_vfprintf_r+0x1bd0>
80009aa0:	2f 83       	sub	r3,-8
80009aa2:	c0 b8       	rjmp	80009ab8 <_vfprintf_r+0x1be4>
80009aa4:	fa ca f9 78 	sub	r10,sp,-1672
80009aa8:	02 9b       	mov	r11,r1
80009aaa:	08 9c       	mov	r12,r4
80009aac:	fe b0 f2 06 	rcall	80007eb8 <__sprint_r>
80009ab0:	e0 81 01 91 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009ab4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ab8:	ed b5 00 00 	bld	r5,0x0
80009abc:	e0 81 01 20 	brne	80009cfc <_vfprintf_r+0x1e28>
80009ac0:	40 c9       	lddsp	r9,sp[0x30]
80009ac2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ac6:	2f f8       	sub	r8,-1
80009ac8:	87 09       	st.w	r3[0x0],r9
80009aca:	fb 48 06 90 	st.w	sp[1680],r8
80009ace:	30 19       	mov	r9,1
80009ad0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ad4:	87 19       	st.w	r3[0x4],r9
80009ad6:	2f f8       	sub	r8,-1
80009ad8:	fb 48 06 8c 	st.w	sp[1676],r8
80009adc:	c0 29       	rjmp	80009ce0 <_vfprintf_r+0x1e0c>
80009ade:	14 09       	add	r9,r10
80009ae0:	2f f8       	sub	r8,-1
80009ae2:	fb 49 06 90 	st.w	sp[1680],r9
80009ae6:	87 06       	st.w	r3[0x0],r6
80009ae8:	87 1a       	st.w	r3[0x4],r10
80009aea:	fb 48 06 8c 	st.w	sp[1676],r8
80009aee:	58 78       	cp.w	r8,7
80009af0:	e0 89 00 04 	brgt	80009af8 <_vfprintf_r+0x1c24>
80009af4:	2f 83       	sub	r3,-8
80009af6:	c0 b8       	rjmp	80009b0c <_vfprintf_r+0x1c38>
80009af8:	fa ca f9 78 	sub	r10,sp,-1672
80009afc:	02 9b       	mov	r11,r1
80009afe:	08 9c       	mov	r12,r4
80009b00:	fe b0 f1 dc 	rcall	80007eb8 <__sprint_r>
80009b04:	e0 81 01 67 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009b08:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b0c:	40 c8       	lddsp	r8,sp[0x30]
80009b0e:	87 08       	st.w	r3[0x0],r8
80009b10:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b14:	2f f8       	sub	r8,-1
80009b16:	30 19       	mov	r9,1
80009b18:	fb 48 06 90 	st.w	sp[1680],r8
80009b1c:	87 19       	st.w	r3[0x4],r9
80009b1e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b22:	2f f8       	sub	r8,-1
80009b24:	fb 48 06 8c 	st.w	sp[1676],r8
80009b28:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b2c:	58 78       	cp.w	r8,7
80009b2e:	e0 89 00 04 	brgt	80009b36 <_vfprintf_r+0x1c62>
80009b32:	2f 83       	sub	r3,-8
80009b34:	c0 b8       	rjmp	80009b4a <_vfprintf_r+0x1c76>
80009b36:	fa ca f9 78 	sub	r10,sp,-1672
80009b3a:	02 9b       	mov	r11,r1
80009b3c:	08 9c       	mov	r12,r4
80009b3e:	fe b0 f1 bd 	rcall	80007eb8 <__sprint_r>
80009b42:	e0 81 01 48 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009b46:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b4a:	04 06       	add	r6,r2
80009b4c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b50:	87 06       	st.w	r3[0x0],r6
80009b52:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b56:	40 66       	lddsp	r6,sp[0x18]
80009b58:	40 6e       	lddsp	lr,sp[0x18]
80009b5a:	10 16       	sub	r6,r8
80009b5c:	f2 08 01 08 	sub	r8,r9,r8
80009b60:	87 16       	st.w	r3[0x4],r6
80009b62:	1c 08       	add	r8,lr
80009b64:	fb 48 06 90 	st.w	sp[1680],r8
80009b68:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b6c:	2f f8       	sub	r8,-1
80009b6e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b72:	cb 78       	rjmp	80009ce0 <_vfprintf_r+0x1e0c>
80009b74:	40 6c       	lddsp	r12,sp[0x18]
80009b76:	58 1c       	cp.w	r12,1
80009b78:	e0 89 00 06 	brgt	80009b84 <_vfprintf_r+0x1cb0>
80009b7c:	ed b5 00 00 	bld	r5,0x0
80009b80:	e0 81 00 85 	brne	80009c8a <_vfprintf_r+0x1db6>
80009b84:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b88:	2f f8       	sub	r8,-1
80009b8a:	30 19       	mov	r9,1
80009b8c:	fb 48 06 90 	st.w	sp[1680],r8
80009b90:	87 06       	st.w	r3[0x0],r6
80009b92:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b96:	87 19       	st.w	r3[0x4],r9
80009b98:	2f f8       	sub	r8,-1
80009b9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b9e:	58 78       	cp.w	r8,7
80009ba0:	e0 89 00 04 	brgt	80009ba8 <_vfprintf_r+0x1cd4>
80009ba4:	2f 83       	sub	r3,-8
80009ba6:	c0 b8       	rjmp	80009bbc <_vfprintf_r+0x1ce8>
80009ba8:	fa ca f9 78 	sub	r10,sp,-1672
80009bac:	02 9b       	mov	r11,r1
80009bae:	08 9c       	mov	r12,r4
80009bb0:	fe b0 f1 84 	rcall	80007eb8 <__sprint_r>
80009bb4:	e0 81 01 0f 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009bb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bbc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bc0:	2f f8       	sub	r8,-1
80009bc2:	40 cb       	lddsp	r11,sp[0x30]
80009bc4:	fb 48 06 90 	st.w	sp[1680],r8
80009bc8:	30 19       	mov	r9,1
80009bca:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bce:	87 0b       	st.w	r3[0x0],r11
80009bd0:	2f f8       	sub	r8,-1
80009bd2:	87 19       	st.w	r3[0x4],r9
80009bd4:	fb 48 06 8c 	st.w	sp[1676],r8
80009bd8:	58 78       	cp.w	r8,7
80009bda:	e0 89 00 05 	brgt	80009be4 <_vfprintf_r+0x1d10>
80009bde:	2f 83       	sub	r3,-8
80009be0:	c0 c8       	rjmp	80009bf8 <_vfprintf_r+0x1d24>
80009be2:	d7 03       	nop
80009be4:	fa ca f9 78 	sub	r10,sp,-1672
80009be8:	02 9b       	mov	r11,r1
80009bea:	08 9c       	mov	r12,r4
80009bec:	fe b0 f1 66 	rcall	80007eb8 <__sprint_r>
80009bf0:	e0 81 00 f1 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009bf4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bf8:	30 08       	mov	r8,0
80009bfa:	30 09       	mov	r9,0
80009bfc:	40 5b       	lddsp	r11,sp[0x14]
80009bfe:	40 7a       	lddsp	r10,sp[0x1c]
80009c00:	e0 a0 13 25 	rcall	8000c24a <__avr32_f64_cmp_eq>
80009c04:	40 68       	lddsp	r8,sp[0x18]
80009c06:	20 18       	sub	r8,1
80009c08:	58 0c       	cp.w	r12,0
80009c0a:	c0 d1       	brne	80009c24 <_vfprintf_r+0x1d50>
80009c0c:	2f f6       	sub	r6,-1
80009c0e:	87 18       	st.w	r3[0x4],r8
80009c10:	87 06       	st.w	r3[0x0],r6
80009c12:	fa f6 06 90 	ld.w	r6,sp[1680]
80009c16:	10 06       	add	r6,r8
80009c18:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c1c:	fb 46 06 90 	st.w	sp[1680],r6
80009c20:	2f f8       	sub	r8,-1
80009c22:	c3 18       	rjmp	80009c84 <_vfprintf_r+0x1db0>
80009c24:	10 96       	mov	r6,r8
80009c26:	58 08       	cp.w	r8,0
80009c28:	e0 89 00 1c 	brgt	80009c60 <_vfprintf_r+0x1d8c>
80009c2c:	c4 b8       	rjmp	80009cc2 <_vfprintf_r+0x1dee>
80009c2e:	2f 09       	sub	r9,-16
80009c30:	2f f8       	sub	r8,-1
80009c32:	fb 49 06 90 	st.w	sp[1680],r9
80009c36:	87 02       	st.w	r3[0x0],r2
80009c38:	87 10       	st.w	r3[0x4],r0
80009c3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009c3e:	58 78       	cp.w	r8,7
80009c40:	e0 89 00 04 	brgt	80009c48 <_vfprintf_r+0x1d74>
80009c44:	2f 83       	sub	r3,-8
80009c46:	c0 b8       	rjmp	80009c5c <_vfprintf_r+0x1d88>
80009c48:	fa ca f9 78 	sub	r10,sp,-1672
80009c4c:	02 9b       	mov	r11,r1
80009c4e:	08 9c       	mov	r12,r4
80009c50:	fe b0 f1 34 	rcall	80007eb8 <__sprint_r>
80009c54:	e0 81 00 bf 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009c58:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c5c:	21 06       	sub	r6,16
80009c5e:	c0 48       	rjmp	80009c66 <_vfprintf_r+0x1d92>
80009c60:	fe c2 be 90 	sub	r2,pc,-16752
80009c64:	31 00       	mov	r0,16
80009c66:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c6a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c6e:	fe ca be 9e 	sub	r10,pc,-16738
80009c72:	59 06       	cp.w	r6,16
80009c74:	fe 99 ff dd 	brgt	80009c2e <_vfprintf_r+0x1d5a>
80009c78:	0c 09       	add	r9,r6
80009c7a:	87 0a       	st.w	r3[0x0],r10
80009c7c:	fb 49 06 90 	st.w	sp[1680],r9
80009c80:	2f f8       	sub	r8,-1
80009c82:	87 16       	st.w	r3[0x4],r6
80009c84:	fb 48 06 8c 	st.w	sp[1676],r8
80009c88:	c0 e8       	rjmp	80009ca4 <_vfprintf_r+0x1dd0>
80009c8a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c8e:	2f f8       	sub	r8,-1
80009c90:	30 19       	mov	r9,1
80009c92:	fb 48 06 90 	st.w	sp[1680],r8
80009c96:	87 06       	st.w	r3[0x0],r6
80009c98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c9c:	87 19       	st.w	r3[0x4],r9
80009c9e:	2f f8       	sub	r8,-1
80009ca0:	fb 48 06 8c 	st.w	sp[1676],r8
80009ca4:	58 78       	cp.w	r8,7
80009ca6:	e0 89 00 04 	brgt	80009cae <_vfprintf_r+0x1dda>
80009caa:	2f 83       	sub	r3,-8
80009cac:	c0 b8       	rjmp	80009cc2 <_vfprintf_r+0x1dee>
80009cae:	fa ca f9 78 	sub	r10,sp,-1672
80009cb2:	02 9b       	mov	r11,r1
80009cb4:	08 9c       	mov	r12,r4
80009cb6:	fe b0 f1 01 	rcall	80007eb8 <__sprint_r>
80009cba:	e0 81 00 8c 	brne	80009dd2 <_vfprintf_r+0x1efe>
80009cbe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cc2:	40 ea       	lddsp	r10,sp[0x38]
80009cc4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cc8:	14 08       	add	r8,r10
80009cca:	fa c9 f9 64 	sub	r9,sp,-1692
80009cce:	fb 48 06 90 	st.w	sp[1680],r8
80009cd2:	87 1a       	st.w	r3[0x4],r10
80009cd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cd8:	87 09       	st.w	r3[0x0],r9
80009cda:	2f f8       	sub	r8,-1
80009cdc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ce0:	58 78       	cp.w	r8,7
80009ce2:	e0 89 00 04 	brgt	80009cea <_vfprintf_r+0x1e16>
80009ce6:	2f 83       	sub	r3,-8
80009ce8:	c0 a8       	rjmp	80009cfc <_vfprintf_r+0x1e28>
80009cea:	fa ca f9 78 	sub	r10,sp,-1672
80009cee:	02 9b       	mov	r11,r1
80009cf0:	08 9c       	mov	r12,r4
80009cf2:	fe b0 f0 e3 	rcall	80007eb8 <__sprint_r>
80009cf6:	c6 e1       	brne	80009dd2 <_vfprintf_r+0x1efe>
80009cf8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cfc:	e2 15 00 04 	andl	r5,0x4,COH
80009d00:	c3 f0       	breq	80009d7e <_vfprintf_r+0x1eaa>
80009d02:	40 86       	lddsp	r6,sp[0x20]
80009d04:	40 39       	lddsp	r9,sp[0xc]
80009d06:	12 16       	sub	r6,r9
80009d08:	58 06       	cp.w	r6,0
80009d0a:	e0 89 00 1a 	brgt	80009d3e <_vfprintf_r+0x1e6a>
80009d0e:	c3 88       	rjmp	80009d7e <_vfprintf_r+0x1eaa>
80009d10:	2f 09       	sub	r9,-16
80009d12:	2f f8       	sub	r8,-1
80009d14:	fb 49 06 90 	st.w	sp[1680],r9
80009d18:	87 05       	st.w	r3[0x0],r5
80009d1a:	87 12       	st.w	r3[0x4],r2
80009d1c:	fb 48 06 8c 	st.w	sp[1676],r8
80009d20:	58 78       	cp.w	r8,7
80009d22:	e0 89 00 04 	brgt	80009d2a <_vfprintf_r+0x1e56>
80009d26:	2f 83       	sub	r3,-8
80009d28:	c0 98       	rjmp	80009d3a <_vfprintf_r+0x1e66>
80009d2a:	00 9a       	mov	r10,r0
80009d2c:	02 9b       	mov	r11,r1
80009d2e:	08 9c       	mov	r12,r4
80009d30:	fe b0 f0 c4 	rcall	80007eb8 <__sprint_r>
80009d34:	c4 f1       	brne	80009dd2 <_vfprintf_r+0x1efe>
80009d36:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d3a:	21 06       	sub	r6,16
80009d3c:	c0 68       	rjmp	80009d48 <_vfprintf_r+0x1e74>
80009d3e:	fe c5 bf 7e 	sub	r5,pc,-16514
80009d42:	31 02       	mov	r2,16
80009d44:	fa c0 f9 78 	sub	r0,sp,-1672
80009d48:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d4c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d50:	fe ca bf 90 	sub	r10,pc,-16496
80009d54:	59 06       	cp.w	r6,16
80009d56:	fe 99 ff dd 	brgt	80009d10 <_vfprintf_r+0x1e3c>
80009d5a:	0c 09       	add	r9,r6
80009d5c:	2f f8       	sub	r8,-1
80009d5e:	87 0a       	st.w	r3[0x0],r10
80009d60:	87 16       	st.w	r3[0x4],r6
80009d62:	fb 49 06 90 	st.w	sp[1680],r9
80009d66:	fb 48 06 8c 	st.w	sp[1676],r8
80009d6a:	58 78       	cp.w	r8,7
80009d6c:	e0 8a 00 09 	brle	80009d7e <_vfprintf_r+0x1eaa>
80009d70:	fa ca f9 78 	sub	r10,sp,-1672
80009d74:	02 9b       	mov	r11,r1
80009d76:	08 9c       	mov	r12,r4
80009d78:	fe b0 f0 a0 	rcall	80007eb8 <__sprint_r>
80009d7c:	c2 b1       	brne	80009dd2 <_vfprintf_r+0x1efe>
80009d7e:	40 bc       	lddsp	r12,sp[0x2c]
80009d80:	40 36       	lddsp	r6,sp[0xc]
80009d82:	40 8e       	lddsp	lr,sp[0x20]
80009d84:	ec 0e 0c 48 	max	r8,r6,lr
80009d88:	10 0c       	add	r12,r8
80009d8a:	50 bc       	stdsp	sp[0x2c],r12
80009d8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d90:	58 08       	cp.w	r8,0
80009d92:	c0 80       	breq	80009da2 <_vfprintf_r+0x1ece>
80009d94:	fa ca f9 78 	sub	r10,sp,-1672
80009d98:	02 9b       	mov	r11,r1
80009d9a:	08 9c       	mov	r12,r4
80009d9c:	fe b0 f0 8e 	rcall	80007eb8 <__sprint_r>
80009da0:	c1 91       	brne	80009dd2 <_vfprintf_r+0x1efe>
80009da2:	30 0b       	mov	r11,0
80009da4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009da8:	fb 4b 06 8c 	st.w	sp[1676],r11
80009dac:	fe 9f f1 22 	bral	80007ff0 <_vfprintf_r+0x11c>
80009db0:	08 95       	mov	r5,r4
80009db2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009db6:	58 08       	cp.w	r8,0
80009db8:	c0 80       	breq	80009dc8 <_vfprintf_r+0x1ef4>
80009dba:	08 9c       	mov	r12,r4
80009dbc:	fa ca f9 78 	sub	r10,sp,-1672
80009dc0:	02 9b       	mov	r11,r1
80009dc2:	fe b0 f0 7b 	rcall	80007eb8 <__sprint_r>
80009dc6:	c0 61       	brne	80009dd2 <_vfprintf_r+0x1efe>
80009dc8:	30 08       	mov	r8,0
80009dca:	fb 48 06 8c 	st.w	sp[1676],r8
80009dce:	c0 28       	rjmp	80009dd2 <_vfprintf_r+0x1efe>
80009dd0:	40 41       	lddsp	r1,sp[0x10]
80009dd2:	82 68       	ld.sh	r8,r1[0xc]
80009dd4:	ed b8 00 06 	bld	r8,0x6
80009dd8:	c0 31       	brne	80009dde <_vfprintf_r+0x1f0a>
80009dda:	3f fa       	mov	r10,-1
80009ddc:	50 ba       	stdsp	sp[0x2c],r10
80009dde:	40 bc       	lddsp	r12,sp[0x2c]
80009de0:	fe 3d f9 44 	sub	sp,-1724
80009de4:	d8 32       	popm	r0-r7,pc
80009de6:	d7 03       	nop

80009de8 <__swsetup_r>:
80009de8:	d4 21       	pushm	r4-r7,lr
80009dea:	e0 68 0a 30 	mov	r8,2608
80009dee:	18 96       	mov	r6,r12
80009df0:	16 97       	mov	r7,r11
80009df2:	70 0c       	ld.w	r12,r8[0x0]
80009df4:	58 0c       	cp.w	r12,0
80009df6:	c0 60       	breq	80009e02 <__swsetup_r+0x1a>
80009df8:	78 68       	ld.w	r8,r12[0x18]
80009dfa:	58 08       	cp.w	r8,0
80009dfc:	c0 31       	brne	80009e02 <__swsetup_r+0x1a>
80009dfe:	e0 a0 07 bf 	rcall	8000ad7c <__sinit>
80009e02:	fe c8 bf 12 	sub	r8,pc,-16622
80009e06:	10 37       	cp.w	r7,r8
80009e08:	c0 61       	brne	80009e14 <__swsetup_r+0x2c>
80009e0a:	e0 68 0a 30 	mov	r8,2608
80009e0e:	70 08       	ld.w	r8,r8[0x0]
80009e10:	70 07       	ld.w	r7,r8[0x0]
80009e12:	c1 28       	rjmp	80009e36 <__swsetup_r+0x4e>
80009e14:	fe c8 bf 04 	sub	r8,pc,-16636
80009e18:	10 37       	cp.w	r7,r8
80009e1a:	c0 61       	brne	80009e26 <__swsetup_r+0x3e>
80009e1c:	e0 68 0a 30 	mov	r8,2608
80009e20:	70 08       	ld.w	r8,r8[0x0]
80009e22:	70 17       	ld.w	r7,r8[0x4]
80009e24:	c0 98       	rjmp	80009e36 <__swsetup_r+0x4e>
80009e26:	fe c8 be f6 	sub	r8,pc,-16650
80009e2a:	10 37       	cp.w	r7,r8
80009e2c:	c0 51       	brne	80009e36 <__swsetup_r+0x4e>
80009e2e:	e0 68 0a 30 	mov	r8,2608
80009e32:	70 08       	ld.w	r8,r8[0x0]
80009e34:	70 27       	ld.w	r7,r8[0x8]
80009e36:	8e 68       	ld.sh	r8,r7[0xc]
80009e38:	ed b8 00 03 	bld	r8,0x3
80009e3c:	c1 e0       	breq	80009e78 <__swsetup_r+0x90>
80009e3e:	ed b8 00 04 	bld	r8,0x4
80009e42:	c3 e1       	brne	80009ebe <__swsetup_r+0xd6>
80009e44:	ed b8 00 02 	bld	r8,0x2
80009e48:	c1 51       	brne	80009e72 <__swsetup_r+0x8a>
80009e4a:	6e db       	ld.w	r11,r7[0x34]
80009e4c:	58 0b       	cp.w	r11,0
80009e4e:	c0 a0       	breq	80009e62 <__swsetup_r+0x7a>
80009e50:	ee c8 ff bc 	sub	r8,r7,-68
80009e54:	10 3b       	cp.w	r11,r8
80009e56:	c0 40       	breq	80009e5e <__swsetup_r+0x76>
80009e58:	0c 9c       	mov	r12,r6
80009e5a:	e0 a0 08 2b 	rcall	8000aeb0 <_free_r>
80009e5e:	30 08       	mov	r8,0
80009e60:	8f d8       	st.w	r7[0x34],r8
80009e62:	8e 68       	ld.sh	r8,r7[0xc]
80009e64:	e0 18 ff db 	andl	r8,0xffdb
80009e68:	ae 68       	st.h	r7[0xc],r8
80009e6a:	30 08       	mov	r8,0
80009e6c:	8f 18       	st.w	r7[0x4],r8
80009e6e:	6e 48       	ld.w	r8,r7[0x10]
80009e70:	8f 08       	st.w	r7[0x0],r8
80009e72:	8e 68       	ld.sh	r8,r7[0xc]
80009e74:	a3 b8       	sbr	r8,0x3
80009e76:	ae 68       	st.h	r7[0xc],r8
80009e78:	6e 48       	ld.w	r8,r7[0x10]
80009e7a:	58 08       	cp.w	r8,0
80009e7c:	c0 b1       	brne	80009e92 <__swsetup_r+0xaa>
80009e7e:	8e 68       	ld.sh	r8,r7[0xc]
80009e80:	e2 18 02 80 	andl	r8,0x280,COH
80009e84:	e0 48 02 00 	cp.w	r8,512
80009e88:	c0 50       	breq	80009e92 <__swsetup_r+0xaa>
80009e8a:	0c 9c       	mov	r12,r6
80009e8c:	0e 9b       	mov	r11,r7
80009e8e:	e0 a0 0a 4b 	rcall	8000b324 <__smakebuf_r>
80009e92:	8e 69       	ld.sh	r9,r7[0xc]
80009e94:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009e98:	c0 70       	breq	80009ea6 <__swsetup_r+0xbe>
80009e9a:	30 08       	mov	r8,0
80009e9c:	8f 28       	st.w	r7[0x8],r8
80009e9e:	6e 58       	ld.w	r8,r7[0x14]
80009ea0:	5c 38       	neg	r8
80009ea2:	8f 68       	st.w	r7[0x18],r8
80009ea4:	c0 68       	rjmp	80009eb0 <__swsetup_r+0xc8>
80009ea6:	ed b9 00 01 	bld	r9,0x1
80009eaa:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009eae:	8f 28       	st.w	r7[0x8],r8
80009eb0:	6e 48       	ld.w	r8,r7[0x10]
80009eb2:	58 08       	cp.w	r8,0
80009eb4:	c0 61       	brne	80009ec0 <__swsetup_r+0xd8>
80009eb6:	8e 68       	ld.sh	r8,r7[0xc]
80009eb8:	ed b8 00 07 	bld	r8,0x7
80009ebc:	c0 21       	brne	80009ec0 <__swsetup_r+0xd8>
80009ebe:	dc 2a       	popm	r4-r7,pc,r12=-1
80009ec0:	d8 2a       	popm	r4-r7,pc,r12=0
80009ec2:	d7 03       	nop

80009ec4 <quorem>:
80009ec4:	d4 31       	pushm	r0-r7,lr
80009ec6:	20 2d       	sub	sp,8
80009ec8:	18 97       	mov	r7,r12
80009eca:	78 48       	ld.w	r8,r12[0x10]
80009ecc:	76 46       	ld.w	r6,r11[0x10]
80009ece:	0c 38       	cp.w	r8,r6
80009ed0:	c0 34       	brge	80009ed6 <quorem+0x12>
80009ed2:	30 0c       	mov	r12,0
80009ed4:	c8 58       	rjmp	80009fde <quorem+0x11a>
80009ed6:	ec c2 ff fc 	sub	r2,r6,-4
80009eda:	f6 c3 ff ec 	sub	r3,r11,-20
80009ede:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009ee2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009ee6:	2f f9       	sub	r9,-1
80009ee8:	20 16       	sub	r6,1
80009eea:	f8 09 0d 08 	divu	r8,r12,r9
80009eee:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009ef2:	ee c4 ff ec 	sub	r4,r7,-20
80009ef6:	10 95       	mov	r5,r8
80009ef8:	58 08       	cp.w	r8,0
80009efa:	c4 10       	breq	80009f7c <quorem+0xb8>
80009efc:	30 09       	mov	r9,0
80009efe:	06 9a       	mov	r10,r3
80009f00:	08 98       	mov	r8,r4
80009f02:	12 91       	mov	r1,r9
80009f04:	50 0b       	stdsp	sp[0x0],r11
80009f06:	70 0e       	ld.w	lr,r8[0x0]
80009f08:	b1 8e       	lsr	lr,0x10
80009f0a:	50 1e       	stdsp	sp[0x4],lr
80009f0c:	15 0e       	ld.w	lr,r10++
80009f0e:	fc 00 16 10 	lsr	r0,lr,0x10
80009f12:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009f16:	ea 0e 03 41 	mac	r1,r5,lr
80009f1a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009f1e:	b1 81       	lsr	r1,0x10
80009f20:	40 1b       	lddsp	r11,sp[0x4]
80009f22:	ea 00 02 40 	mul	r0,r5,r0
80009f26:	e2 00 00 00 	add	r0,r1,r0
80009f2a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009f2e:	02 1b       	sub	r11,r1
80009f30:	50 1b       	stdsp	sp[0x4],r11
80009f32:	70 0b       	ld.w	r11,r8[0x0]
80009f34:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009f38:	02 09       	add	r9,r1
80009f3a:	f2 0e 01 0e 	sub	lr,r9,lr
80009f3e:	b0 1e       	st.h	r8[0x2],lr
80009f40:	fc 09 14 10 	asr	r9,lr,0x10
80009f44:	40 1e       	lddsp	lr,sp[0x4]
80009f46:	fc 09 00 09 	add	r9,lr,r9
80009f4a:	b0 09       	st.h	r8[0x0],r9
80009f4c:	e0 01 16 10 	lsr	r1,r0,0x10
80009f50:	2f c8       	sub	r8,-4
80009f52:	b1 49       	asr	r9,0x10
80009f54:	04 3a       	cp.w	r10,r2
80009f56:	fe 98 ff d8 	brls	80009f06 <quorem+0x42>
80009f5a:	40 0b       	lddsp	r11,sp[0x0]
80009f5c:	58 0c       	cp.w	r12,0
80009f5e:	c0 f1       	brne	80009f7c <quorem+0xb8>
80009f60:	ec c8 ff fb 	sub	r8,r6,-5
80009f64:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009f68:	c0 28       	rjmp	80009f6c <quorem+0xa8>
80009f6a:	20 16       	sub	r6,1
80009f6c:	20 48       	sub	r8,4
80009f6e:	08 38       	cp.w	r8,r4
80009f70:	e0 88 00 05 	brls	80009f7a <quorem+0xb6>
80009f74:	70 09       	ld.w	r9,r8[0x0]
80009f76:	58 09       	cp.w	r9,0
80009f78:	cf 90       	breq	80009f6a <quorem+0xa6>
80009f7a:	8f 46       	st.w	r7[0x10],r6
80009f7c:	0e 9c       	mov	r12,r7
80009f7e:	e0 a0 0a d2 	rcall	8000b522 <__mcmp>
80009f82:	c2 d5       	brlt	80009fdc <quorem+0x118>
80009f84:	2f f5       	sub	r5,-1
80009f86:	08 98       	mov	r8,r4
80009f88:	30 09       	mov	r9,0
80009f8a:	07 0b       	ld.w	r11,r3++
80009f8c:	f6 0a 16 10 	lsr	r10,r11,0x10
80009f90:	70 0c       	ld.w	r12,r8[0x0]
80009f92:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009f96:	f8 0e 16 10 	lsr	lr,r12,0x10
80009f9a:	14 1e       	sub	lr,r10
80009f9c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009fa0:	16 1a       	sub	r10,r11
80009fa2:	12 0a       	add	r10,r9
80009fa4:	b0 1a       	st.h	r8[0x2],r10
80009fa6:	b1 4a       	asr	r10,0x10
80009fa8:	fc 0a 00 09 	add	r9,lr,r10
80009fac:	b0 09       	st.h	r8[0x0],r9
80009fae:	2f c8       	sub	r8,-4
80009fb0:	b1 49       	asr	r9,0x10
80009fb2:	04 33       	cp.w	r3,r2
80009fb4:	fe 98 ff eb 	brls	80009f8a <quorem+0xc6>
80009fb8:	ec c8 ff fb 	sub	r8,r6,-5
80009fbc:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009fc0:	58 09       	cp.w	r9,0
80009fc2:	c0 d1       	brne	80009fdc <quorem+0x118>
80009fc4:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009fc8:	c0 28       	rjmp	80009fcc <quorem+0x108>
80009fca:	20 16       	sub	r6,1
80009fcc:	20 48       	sub	r8,4
80009fce:	08 38       	cp.w	r8,r4
80009fd0:	e0 88 00 05 	brls	80009fda <quorem+0x116>
80009fd4:	70 09       	ld.w	r9,r8[0x0]
80009fd6:	58 09       	cp.w	r9,0
80009fd8:	cf 90       	breq	80009fca <quorem+0x106>
80009fda:	8f 46       	st.w	r7[0x10],r6
80009fdc:	0a 9c       	mov	r12,r5
80009fde:	2f ed       	sub	sp,-8
80009fe0:	d8 32       	popm	r0-r7,pc
80009fe2:	d7 03       	nop

80009fe4 <_dtoa_r>:
80009fe4:	d4 31       	pushm	r0-r7,lr
80009fe6:	21 ad       	sub	sp,104
80009fe8:	fa c4 ff 74 	sub	r4,sp,-140
80009fec:	18 97       	mov	r7,r12
80009fee:	16 95       	mov	r5,r11
80009ff0:	68 2c       	ld.w	r12,r4[0x8]
80009ff2:	50 c9       	stdsp	sp[0x30],r9
80009ff4:	68 16       	ld.w	r6,r4[0x4]
80009ff6:	68 09       	ld.w	r9,r4[0x0]
80009ff8:	50 e8       	stdsp	sp[0x38],r8
80009ffa:	14 94       	mov	r4,r10
80009ffc:	51 2c       	stdsp	sp[0x48],r12
80009ffe:	fa e5 00 08 	st.d	sp[8],r4
8000a002:	51 59       	stdsp	sp[0x54],r9
8000a004:	6e 95       	ld.w	r5,r7[0x24]
8000a006:	58 05       	cp.w	r5,0
8000a008:	c0 91       	brne	8000a01a <_dtoa_r+0x36>
8000a00a:	31 0c       	mov	r12,16
8000a00c:	fe b0 e8 f4 	rcall	800071f4 <malloc>
8000a010:	99 35       	st.w	r12[0xc],r5
8000a012:	8f 9c       	st.w	r7[0x24],r12
8000a014:	99 15       	st.w	r12[0x4],r5
8000a016:	99 25       	st.w	r12[0x8],r5
8000a018:	99 05       	st.w	r12[0x0],r5
8000a01a:	6e 99       	ld.w	r9,r7[0x24]
8000a01c:	72 08       	ld.w	r8,r9[0x0]
8000a01e:	58 08       	cp.w	r8,0
8000a020:	c0 f0       	breq	8000a03e <_dtoa_r+0x5a>
8000a022:	72 1a       	ld.w	r10,r9[0x4]
8000a024:	91 1a       	st.w	r8[0x4],r10
8000a026:	30 1a       	mov	r10,1
8000a028:	72 19       	ld.w	r9,r9[0x4]
8000a02a:	f4 09 09 49 	lsl	r9,r10,r9
8000a02e:	10 9b       	mov	r11,r8
8000a030:	91 29       	st.w	r8[0x8],r9
8000a032:	0e 9c       	mov	r12,r7
8000a034:	e0 a0 0a 90 	rcall	8000b554 <_Bfree>
8000a038:	6e 98       	ld.w	r8,r7[0x24]
8000a03a:	30 09       	mov	r9,0
8000a03c:	91 09       	st.w	r8[0x0],r9
8000a03e:	40 28       	lddsp	r8,sp[0x8]
8000a040:	10 94       	mov	r4,r8
8000a042:	58 08       	cp.w	r8,0
8000a044:	c0 64       	brge	8000a050 <_dtoa_r+0x6c>
8000a046:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a04a:	50 28       	stdsp	sp[0x8],r8
8000a04c:	30 18       	mov	r8,1
8000a04e:	c0 28       	rjmp	8000a052 <_dtoa_r+0x6e>
8000a050:	30 08       	mov	r8,0
8000a052:	8d 08       	st.w	r6[0x0],r8
8000a054:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a058:	40 26       	lddsp	r6,sp[0x8]
8000a05a:	0c 98       	mov	r8,r6
8000a05c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a060:	18 38       	cp.w	r8,r12
8000a062:	c2 01       	brne	8000a0a2 <_dtoa_r+0xbe>
8000a064:	e0 68 27 0f 	mov	r8,9999
8000a068:	41 5b       	lddsp	r11,sp[0x54]
8000a06a:	97 08       	st.w	r11[0x0],r8
8000a06c:	40 3a       	lddsp	r10,sp[0xc]
8000a06e:	58 0a       	cp.w	r10,0
8000a070:	c0 71       	brne	8000a07e <_dtoa_r+0x9a>
8000a072:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a076:	c0 41       	brne	8000a07e <_dtoa_r+0x9a>
8000a078:	fe cc c1 98 	sub	r12,pc,-15976
8000a07c:	c0 38       	rjmp	8000a082 <_dtoa_r+0x9e>
8000a07e:	fe cc c1 92 	sub	r12,pc,-15982
8000a082:	41 29       	lddsp	r9,sp[0x48]
8000a084:	58 09       	cp.w	r9,0
8000a086:	e0 80 05 9a 	breq	8000abba <_dtoa_r+0xbd6>
8000a08a:	f8 c8 ff fd 	sub	r8,r12,-3
8000a08e:	f8 c9 ff f8 	sub	r9,r12,-8
8000a092:	11 8b       	ld.ub	r11,r8[0x0]
8000a094:	30 0a       	mov	r10,0
8000a096:	41 25       	lddsp	r5,sp[0x48]
8000a098:	f4 0b 18 00 	cp.b	r11,r10
8000a09c:	f2 08 17 10 	movne	r8,r9
8000a0a0:	c1 68       	rjmp	8000a0cc <_dtoa_r+0xe8>
8000a0a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0a6:	30 08       	mov	r8,0
8000a0a8:	fa eb 00 3c 	st.d	sp[60],r10
8000a0ac:	30 09       	mov	r9,0
8000a0ae:	e0 a0 10 ce 	rcall	8000c24a <__avr32_f64_cmp_eq>
8000a0b2:	c1 00       	breq	8000a0d2 <_dtoa_r+0xee>
8000a0b4:	30 18       	mov	r8,1
8000a0b6:	41 5a       	lddsp	r10,sp[0x54]
8000a0b8:	95 08       	st.w	r10[0x0],r8
8000a0ba:	fe cc c2 fe 	sub	r12,pc,-15618
8000a0be:	41 29       	lddsp	r9,sp[0x48]
8000a0c0:	f8 08 00 08 	add	r8,r12,r8
8000a0c4:	58 09       	cp.w	r9,0
8000a0c6:	e0 80 05 7a 	breq	8000abba <_dtoa_r+0xbd6>
8000a0ca:	12 95       	mov	r5,r9
8000a0cc:	8b 08       	st.w	r5[0x0],r8
8000a0ce:	e0 8f 05 76 	bral	8000abba <_dtoa_r+0xbd6>
8000a0d2:	fa c8 ff 9c 	sub	r8,sp,-100
8000a0d6:	fa c9 ff a0 	sub	r9,sp,-96
8000a0da:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a0de:	0e 9c       	mov	r12,r7
8000a0e0:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a0e4:	e0 a0 0a 8a 	rcall	8000b5f8 <__d2b>
8000a0e8:	18 93       	mov	r3,r12
8000a0ea:	58 05       	cp.w	r5,0
8000a0ec:	c0 d0       	breq	8000a106 <_dtoa_r+0x122>
8000a0ee:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a0f2:	30 04       	mov	r4,0
8000a0f4:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a0f8:	ea c5 03 ff 	sub	r5,r5,1023
8000a0fc:	10 9b       	mov	r11,r8
8000a0fe:	51 74       	stdsp	sp[0x5c],r4
8000a100:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a104:	c2 58       	rjmp	8000a14e <_dtoa_r+0x16a>
8000a106:	41 88       	lddsp	r8,sp[0x60]
8000a108:	41 9c       	lddsp	r12,sp[0x64]
8000a10a:	10 0c       	add	r12,r8
8000a10c:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a110:	e0 45 00 20 	cp.w	r5,32
8000a114:	e0 8a 00 0e 	brle	8000a130 <_dtoa_r+0x14c>
8000a118:	f8 cc fb ee 	sub	r12,r12,-1042
8000a11c:	40 3b       	lddsp	r11,sp[0xc]
8000a11e:	ea 08 11 40 	rsub	r8,r5,64
8000a122:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a126:	ec 08 09 46 	lsl	r6,r6,r8
8000a12a:	0c 4c       	or	r12,r6
8000a12c:	c0 78       	rjmp	8000a13a <_dtoa_r+0x156>
8000a12e:	d7 03       	nop
8000a130:	ea 0c 11 20 	rsub	r12,r5,32
8000a134:	40 3a       	lddsp	r10,sp[0xc]
8000a136:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a13a:	e0 a0 10 14 	rcall	8000c162 <__avr32_u32_to_f64>
8000a13e:	fc 18 fe 10 	movh	r8,0xfe10
8000a142:	30 19       	mov	r9,1
8000a144:	ea c5 04 33 	sub	r5,r5,1075
8000a148:	f0 0b 00 0b 	add	r11,r8,r11
8000a14c:	51 79       	stdsp	sp[0x5c],r9
8000a14e:	30 08       	mov	r8,0
8000a150:	fc 19 3f f8 	movh	r9,0x3ff8
8000a154:	e0 a0 0e 9c 	rcall	8000be8c <__avr32_f64_sub>
8000a158:	e0 68 43 61 	mov	r8,17249
8000a15c:	ea 18 63 6f 	orh	r8,0x636f
8000a160:	e0 69 87 a7 	mov	r9,34727
8000a164:	ea 19 3f d2 	orh	r9,0x3fd2
8000a168:	e0 a0 0d a6 	rcall	8000bcb4 <__avr32_f64_mul>
8000a16c:	e0 68 c8 b3 	mov	r8,51379
8000a170:	ea 18 8b 60 	orh	r8,0x8b60
8000a174:	e0 69 8a 28 	mov	r9,35368
8000a178:	ea 19 3f c6 	orh	r9,0x3fc6
8000a17c:	e0 a0 0f 56 	rcall	8000c028 <__avr32_f64_add>
8000a180:	0a 9c       	mov	r12,r5
8000a182:	14 90       	mov	r0,r10
8000a184:	16 91       	mov	r1,r11
8000a186:	e0 a0 0f f2 	rcall	8000c16a <__avr32_s32_to_f64>
8000a18a:	e0 68 79 fb 	mov	r8,31227
8000a18e:	ea 18 50 9f 	orh	r8,0x509f
8000a192:	e0 69 44 13 	mov	r9,17427
8000a196:	ea 19 3f d3 	orh	r9,0x3fd3
8000a19a:	e0 a0 0d 8d 	rcall	8000bcb4 <__avr32_f64_mul>
8000a19e:	14 98       	mov	r8,r10
8000a1a0:	16 99       	mov	r9,r11
8000a1a2:	00 9a       	mov	r10,r0
8000a1a4:	02 9b       	mov	r11,r1
8000a1a6:	e0 a0 0f 41 	rcall	8000c028 <__avr32_f64_add>
8000a1aa:	14 90       	mov	r0,r10
8000a1ac:	16 91       	mov	r1,r11
8000a1ae:	e0 a0 0f c7 	rcall	8000c13c <__avr32_f64_to_s32>
8000a1b2:	30 08       	mov	r8,0
8000a1b4:	18 96       	mov	r6,r12
8000a1b6:	30 09       	mov	r9,0
8000a1b8:	00 9a       	mov	r10,r0
8000a1ba:	02 9b       	mov	r11,r1
8000a1bc:	e0 a0 10 8e 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a1c0:	c0 c0       	breq	8000a1d8 <_dtoa_r+0x1f4>
8000a1c2:	0c 9c       	mov	r12,r6
8000a1c4:	e0 a0 0f d3 	rcall	8000c16a <__avr32_s32_to_f64>
8000a1c8:	14 98       	mov	r8,r10
8000a1ca:	16 99       	mov	r9,r11
8000a1cc:	00 9a       	mov	r10,r0
8000a1ce:	02 9b       	mov	r11,r1
8000a1d0:	e0 a0 10 3d 	rcall	8000c24a <__avr32_f64_cmp_eq>
8000a1d4:	f7 b6 00 01 	subeq	r6,1
8000a1d8:	59 66       	cp.w	r6,22
8000a1da:	e0 88 00 05 	brls	8000a1e4 <_dtoa_r+0x200>
8000a1de:	30 18       	mov	r8,1
8000a1e0:	51 48       	stdsp	sp[0x50],r8
8000a1e2:	c1 38       	rjmp	8000a208 <_dtoa_r+0x224>
8000a1e4:	fe c8 c2 44 	sub	r8,pc,-15804
8000a1e8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a1ec:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a1f0:	e0 a0 10 74 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a1f4:	f9 b4 00 00 	moveq	r4,0
8000a1f8:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a1fc:	f7 b6 01 01 	subne	r6,1
8000a200:	f9 bc 01 00 	movne	r12,0
8000a204:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a208:	41 90       	lddsp	r0,sp[0x64]
8000a20a:	20 10       	sub	r0,1
8000a20c:	0a 10       	sub	r0,r5
8000a20e:	c0 46       	brmi	8000a216 <_dtoa_r+0x232>
8000a210:	50 40       	stdsp	sp[0x10],r0
8000a212:	30 00       	mov	r0,0
8000a214:	c0 48       	rjmp	8000a21c <_dtoa_r+0x238>
8000a216:	30 0b       	mov	r11,0
8000a218:	5c 30       	neg	r0
8000a21a:	50 4b       	stdsp	sp[0x10],r11
8000a21c:	ec 02 11 00 	rsub	r2,r6,0
8000a220:	58 06       	cp.w	r6,0
8000a222:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a226:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a22a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a22e:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a232:	f9 b2 04 00 	movge	r2,0
8000a236:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a23a:	f9 b9 05 00 	movlt	r9,0
8000a23e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a242:	40 c8       	lddsp	r8,sp[0x30]
8000a244:	58 98       	cp.w	r8,9
8000a246:	e0 8b 00 20 	brhi	8000a286 <_dtoa_r+0x2a2>
8000a24a:	58 58       	cp.w	r8,5
8000a24c:	f9 b4 0a 01 	movle	r4,1
8000a250:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a254:	f7 b5 09 04 	subgt	r5,4
8000a258:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a25c:	f9 b4 09 00 	movgt	r4,0
8000a260:	40 cc       	lddsp	r12,sp[0x30]
8000a262:	58 3c       	cp.w	r12,3
8000a264:	c2 d0       	breq	8000a2be <_dtoa_r+0x2da>
8000a266:	e0 89 00 05 	brgt	8000a270 <_dtoa_r+0x28c>
8000a26a:	58 2c       	cp.w	r12,2
8000a26c:	c1 01       	brne	8000a28c <_dtoa_r+0x2a8>
8000a26e:	c1 88       	rjmp	8000a29e <_dtoa_r+0x2ba>
8000a270:	40 cb       	lddsp	r11,sp[0x30]
8000a272:	58 4b       	cp.w	r11,4
8000a274:	c0 60       	breq	8000a280 <_dtoa_r+0x29c>
8000a276:	58 5b       	cp.w	r11,5
8000a278:	c0 a1       	brne	8000a28c <_dtoa_r+0x2a8>
8000a27a:	30 1a       	mov	r10,1
8000a27c:	50 da       	stdsp	sp[0x34],r10
8000a27e:	c2 28       	rjmp	8000a2c2 <_dtoa_r+0x2de>
8000a280:	30 19       	mov	r9,1
8000a282:	50 d9       	stdsp	sp[0x34],r9
8000a284:	c0 f8       	rjmp	8000a2a2 <_dtoa_r+0x2be>
8000a286:	30 08       	mov	r8,0
8000a288:	30 14       	mov	r4,1
8000a28a:	50 c8       	stdsp	sp[0x30],r8
8000a28c:	3f f5       	mov	r5,-1
8000a28e:	30 1c       	mov	r12,1
8000a290:	30 0b       	mov	r11,0
8000a292:	50 95       	stdsp	sp[0x24],r5
8000a294:	50 dc       	stdsp	sp[0x34],r12
8000a296:	0a 91       	mov	r1,r5
8000a298:	31 28       	mov	r8,18
8000a29a:	50 eb       	stdsp	sp[0x38],r11
8000a29c:	c2 08       	rjmp	8000a2dc <_dtoa_r+0x2f8>
8000a29e:	30 0a       	mov	r10,0
8000a2a0:	50 da       	stdsp	sp[0x34],r10
8000a2a2:	40 e9       	lddsp	r9,sp[0x38]
8000a2a4:	58 09       	cp.w	r9,0
8000a2a6:	e0 89 00 07 	brgt	8000a2b4 <_dtoa_r+0x2d0>
8000a2aa:	30 18       	mov	r8,1
8000a2ac:	50 98       	stdsp	sp[0x24],r8
8000a2ae:	10 91       	mov	r1,r8
8000a2b0:	50 e8       	stdsp	sp[0x38],r8
8000a2b2:	c1 58       	rjmp	8000a2dc <_dtoa_r+0x2f8>
8000a2b4:	40 e5       	lddsp	r5,sp[0x38]
8000a2b6:	50 95       	stdsp	sp[0x24],r5
8000a2b8:	0a 91       	mov	r1,r5
8000a2ba:	0a 98       	mov	r8,r5
8000a2bc:	c1 08       	rjmp	8000a2dc <_dtoa_r+0x2f8>
8000a2be:	30 0c       	mov	r12,0
8000a2c0:	50 dc       	stdsp	sp[0x34],r12
8000a2c2:	40 eb       	lddsp	r11,sp[0x38]
8000a2c4:	ec 0b 00 0b 	add	r11,r6,r11
8000a2c8:	50 9b       	stdsp	sp[0x24],r11
8000a2ca:	16 98       	mov	r8,r11
8000a2cc:	2f f8       	sub	r8,-1
8000a2ce:	58 08       	cp.w	r8,0
8000a2d0:	e0 89 00 05 	brgt	8000a2da <_dtoa_r+0x2f6>
8000a2d4:	10 91       	mov	r1,r8
8000a2d6:	30 18       	mov	r8,1
8000a2d8:	c0 28       	rjmp	8000a2dc <_dtoa_r+0x2f8>
8000a2da:	10 91       	mov	r1,r8
8000a2dc:	30 09       	mov	r9,0
8000a2de:	6e 9a       	ld.w	r10,r7[0x24]
8000a2e0:	95 19       	st.w	r10[0x4],r9
8000a2e2:	30 49       	mov	r9,4
8000a2e4:	c0 68       	rjmp	8000a2f0 <_dtoa_r+0x30c>
8000a2e6:	d7 03       	nop
8000a2e8:	6a 1a       	ld.w	r10,r5[0x4]
8000a2ea:	a1 79       	lsl	r9,0x1
8000a2ec:	2f fa       	sub	r10,-1
8000a2ee:	8b 1a       	st.w	r5[0x4],r10
8000a2f0:	6e 95       	ld.w	r5,r7[0x24]
8000a2f2:	f2 ca ff ec 	sub	r10,r9,-20
8000a2f6:	10 3a       	cp.w	r10,r8
8000a2f8:	fe 98 ff f8 	brls	8000a2e8 <_dtoa_r+0x304>
8000a2fc:	6a 1b       	ld.w	r11,r5[0x4]
8000a2fe:	0e 9c       	mov	r12,r7
8000a300:	e0 a0 09 44 	rcall	8000b588 <_Balloc>
8000a304:	58 e1       	cp.w	r1,14
8000a306:	5f 88       	srls	r8
8000a308:	8b 0c       	st.w	r5[0x0],r12
8000a30a:	f1 e4 00 04 	and	r4,r8,r4
8000a30e:	6e 98       	ld.w	r8,r7[0x24]
8000a310:	70 08       	ld.w	r8,r8[0x0]
8000a312:	50 88       	stdsp	sp[0x20],r8
8000a314:	e0 80 01 82 	breq	8000a618 <_dtoa_r+0x634>
8000a318:	58 06       	cp.w	r6,0
8000a31a:	e0 8a 00 43 	brle	8000a3a0 <_dtoa_r+0x3bc>
8000a31e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a322:	fe c8 c3 82 	sub	r8,pc,-15486
8000a326:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a32a:	fa e5 00 18 	st.d	sp[24],r4
8000a32e:	ec 04 14 04 	asr	r4,r6,0x4
8000a332:	ed b4 00 04 	bld	r4,0x4
8000a336:	c0 30       	breq	8000a33c <_dtoa_r+0x358>
8000a338:	30 25       	mov	r5,2
8000a33a:	c1 08       	rjmp	8000a35a <_dtoa_r+0x376>
8000a33c:	fe c8 c2 d4 	sub	r8,pc,-15660
8000a340:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a344:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a348:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a34c:	e0 a0 0f fa 	rcall	8000c340 <__avr32_f64_div>
8000a350:	30 35       	mov	r5,3
8000a352:	14 98       	mov	r8,r10
8000a354:	16 99       	mov	r9,r11
8000a356:	fa e9 00 08 	st.d	sp[8],r8
8000a35a:	fe cc c2 f2 	sub	r12,pc,-15630
8000a35e:	50 a3       	stdsp	sp[0x28],r3
8000a360:	0c 93       	mov	r3,r6
8000a362:	18 96       	mov	r6,r12
8000a364:	c0 f8       	rjmp	8000a382 <_dtoa_r+0x39e>
8000a366:	fa ea 00 18 	ld.d	r10,sp[24]
8000a36a:	ed b4 00 00 	bld	r4,0x0
8000a36e:	c0 81       	brne	8000a37e <_dtoa_r+0x39a>
8000a370:	ec e8 00 00 	ld.d	r8,r6[0]
8000a374:	2f f5       	sub	r5,-1
8000a376:	e0 a0 0c 9f 	rcall	8000bcb4 <__avr32_f64_mul>
8000a37a:	fa eb 00 18 	st.d	sp[24],r10
8000a37e:	a1 54       	asr	r4,0x1
8000a380:	2f 86       	sub	r6,-8
8000a382:	58 04       	cp.w	r4,0
8000a384:	cf 11       	brne	8000a366 <_dtoa_r+0x382>
8000a386:	fa e8 00 18 	ld.d	r8,sp[24]
8000a38a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a38e:	06 96       	mov	r6,r3
8000a390:	e0 a0 0f d8 	rcall	8000c340 <__avr32_f64_div>
8000a394:	40 a3       	lddsp	r3,sp[0x28]
8000a396:	14 98       	mov	r8,r10
8000a398:	16 99       	mov	r9,r11
8000a39a:	fa e9 00 08 	st.d	sp[8],r8
8000a39e:	c2 f8       	rjmp	8000a3fc <_dtoa_r+0x418>
8000a3a0:	ec 08 11 00 	rsub	r8,r6,0
8000a3a4:	c0 31       	brne	8000a3aa <_dtoa_r+0x3c6>
8000a3a6:	30 25       	mov	r5,2
8000a3a8:	c2 a8       	rjmp	8000a3fc <_dtoa_r+0x418>
8000a3aa:	fe cc c3 42 	sub	r12,pc,-15550
8000a3ae:	f0 04 14 04 	asr	r4,r8,0x4
8000a3b2:	50 1c       	stdsp	sp[0x4],r12
8000a3b4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a3b8:	fe c9 c4 18 	sub	r9,pc,-15336
8000a3bc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a3c0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a3c4:	e0 a0 0c 78 	rcall	8000bcb4 <__avr32_f64_mul>
8000a3c8:	40 1c       	lddsp	r12,sp[0x4]
8000a3ca:	50 63       	stdsp	sp[0x18],r3
8000a3cc:	30 25       	mov	r5,2
8000a3ce:	0c 93       	mov	r3,r6
8000a3d0:	fa eb 00 08 	st.d	sp[8],r10
8000a3d4:	18 96       	mov	r6,r12
8000a3d6:	c0 f8       	rjmp	8000a3f4 <_dtoa_r+0x410>
8000a3d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3dc:	ed b4 00 00 	bld	r4,0x0
8000a3e0:	c0 81       	brne	8000a3f0 <_dtoa_r+0x40c>
8000a3e2:	ec e8 00 00 	ld.d	r8,r6[0]
8000a3e6:	2f f5       	sub	r5,-1
8000a3e8:	e0 a0 0c 66 	rcall	8000bcb4 <__avr32_f64_mul>
8000a3ec:	fa eb 00 08 	st.d	sp[8],r10
8000a3f0:	a1 54       	asr	r4,0x1
8000a3f2:	2f 86       	sub	r6,-8
8000a3f4:	58 04       	cp.w	r4,0
8000a3f6:	cf 11       	brne	8000a3d8 <_dtoa_r+0x3f4>
8000a3f8:	06 96       	mov	r6,r3
8000a3fa:	40 63       	lddsp	r3,sp[0x18]
8000a3fc:	41 4a       	lddsp	r10,sp[0x50]
8000a3fe:	58 0a       	cp.w	r10,0
8000a400:	c2 a0       	breq	8000a454 <_dtoa_r+0x470>
8000a402:	fa e8 00 08 	ld.d	r8,sp[8]
8000a406:	58 01       	cp.w	r1,0
8000a408:	5f 94       	srgt	r4
8000a40a:	fa e9 00 18 	st.d	sp[24],r8
8000a40e:	30 08       	mov	r8,0
8000a410:	fc 19 3f f0 	movh	r9,0x3ff0
8000a414:	fa ea 00 18 	ld.d	r10,sp[24]
8000a418:	e0 a0 0f 60 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a41c:	f9 bc 00 00 	moveq	r12,0
8000a420:	f9 bc 01 01 	movne	r12,1
8000a424:	e9 ec 00 0c 	and	r12,r4,r12
8000a428:	c1 60       	breq	8000a454 <_dtoa_r+0x470>
8000a42a:	40 98       	lddsp	r8,sp[0x24]
8000a42c:	58 08       	cp.w	r8,0
8000a42e:	e0 8a 00 f1 	brle	8000a610 <_dtoa_r+0x62c>
8000a432:	30 08       	mov	r8,0
8000a434:	fc 19 40 24 	movh	r9,0x4024
8000a438:	ec c4 00 01 	sub	r4,r6,1
8000a43c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a440:	2f f5       	sub	r5,-1
8000a442:	50 64       	stdsp	sp[0x18],r4
8000a444:	e0 a0 0c 38 	rcall	8000bcb4 <__avr32_f64_mul>
8000a448:	40 94       	lddsp	r4,sp[0x24]
8000a44a:	14 98       	mov	r8,r10
8000a44c:	16 99       	mov	r9,r11
8000a44e:	fa e9 00 08 	st.d	sp[8],r8
8000a452:	c0 38       	rjmp	8000a458 <_dtoa_r+0x474>
8000a454:	50 66       	stdsp	sp[0x18],r6
8000a456:	02 94       	mov	r4,r1
8000a458:	0a 9c       	mov	r12,r5
8000a45a:	e0 a0 0e 88 	rcall	8000c16a <__avr32_s32_to_f64>
8000a45e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a462:	e0 a0 0c 29 	rcall	8000bcb4 <__avr32_f64_mul>
8000a466:	30 08       	mov	r8,0
8000a468:	fc 19 40 1c 	movh	r9,0x401c
8000a46c:	e0 a0 0d de 	rcall	8000c028 <__avr32_f64_add>
8000a470:	14 98       	mov	r8,r10
8000a472:	16 99       	mov	r9,r11
8000a474:	fa e9 00 28 	st.d	sp[40],r8
8000a478:	fc 18 fc c0 	movh	r8,0xfcc0
8000a47c:	40 a5       	lddsp	r5,sp[0x28]
8000a47e:	10 05       	add	r5,r8
8000a480:	50 a5       	stdsp	sp[0x28],r5
8000a482:	58 04       	cp.w	r4,0
8000a484:	c2 11       	brne	8000a4c6 <_dtoa_r+0x4e2>
8000a486:	fa ea 00 08 	ld.d	r10,sp[8]
8000a48a:	30 08       	mov	r8,0
8000a48c:	fc 19 40 14 	movh	r9,0x4014
8000a490:	e0 a0 0c fe 	rcall	8000be8c <__avr32_f64_sub>
8000a494:	40 bc       	lddsp	r12,sp[0x2c]
8000a496:	fa eb 00 08 	st.d	sp[8],r10
8000a49a:	14 98       	mov	r8,r10
8000a49c:	16 99       	mov	r9,r11
8000a49e:	18 9a       	mov	r10,r12
8000a4a0:	0a 9b       	mov	r11,r5
8000a4a2:	e0 a0 0f 1b 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a4a6:	e0 81 02 54 	brne	8000a94e <_dtoa_r+0x96a>
8000a4aa:	0a 98       	mov	r8,r5
8000a4ac:	40 b9       	lddsp	r9,sp[0x2c]
8000a4ae:	ee 18 80 00 	eorh	r8,0x8000
8000a4b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4b6:	10 95       	mov	r5,r8
8000a4b8:	12 98       	mov	r8,r9
8000a4ba:	0a 99       	mov	r9,r5
8000a4bc:	e0 a0 0f 0e 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a4c0:	e0 81 02 3e 	brne	8000a93c <_dtoa_r+0x958>
8000a4c4:	ca 68       	rjmp	8000a610 <_dtoa_r+0x62c>
8000a4c6:	fe c9 c5 26 	sub	r9,pc,-15066
8000a4ca:	e8 c8 00 01 	sub	r8,r4,1
8000a4ce:	40 d5       	lddsp	r5,sp[0x34]
8000a4d0:	58 05       	cp.w	r5,0
8000a4d2:	c4 f0       	breq	8000a570 <_dtoa_r+0x58c>
8000a4d4:	30 0c       	mov	r12,0
8000a4d6:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a4da:	51 3c       	stdsp	sp[0x4c],r12
8000a4dc:	30 0a       	mov	r10,0
8000a4de:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a4e2:	e0 a0 0f 2f 	rcall	8000c340 <__avr32_f64_div>
8000a4e6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a4ea:	40 85       	lddsp	r5,sp[0x20]
8000a4ec:	e0 a0 0c d0 	rcall	8000be8c <__avr32_f64_sub>
8000a4f0:	fa eb 00 28 	st.d	sp[40],r10
8000a4f4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4f8:	e0 a0 0e 22 	rcall	8000c13c <__avr32_f64_to_s32>
8000a4fc:	51 6c       	stdsp	sp[0x58],r12
8000a4fe:	e0 a0 0e 36 	rcall	8000c16a <__avr32_s32_to_f64>
8000a502:	14 98       	mov	r8,r10
8000a504:	16 99       	mov	r9,r11
8000a506:	fa ea 00 08 	ld.d	r10,sp[8]
8000a50a:	e0 a0 0c c1 	rcall	8000be8c <__avr32_f64_sub>
8000a50e:	fa eb 00 08 	st.d	sp[8],r10
8000a512:	41 68       	lddsp	r8,sp[0x58]
8000a514:	2d 08       	sub	r8,-48
8000a516:	0a c8       	st.b	r5++,r8
8000a518:	41 39       	lddsp	r9,sp[0x4c]
8000a51a:	2f f9       	sub	r9,-1
8000a51c:	51 39       	stdsp	sp[0x4c],r9
8000a51e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a522:	e0 a0 0e db 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a526:	e0 81 03 39 	brne	8000ab98 <_dtoa_r+0xbb4>
8000a52a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a52e:	30 0a       	mov	r10,0
8000a530:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a534:	e0 a0 0c ac 	rcall	8000be8c <__avr32_f64_sub>
8000a538:	fa e8 00 28 	ld.d	r8,sp[40]
8000a53c:	e0 a0 0e ce 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a540:	fa ea 00 28 	ld.d	r10,sp[40]
8000a544:	30 08       	mov	r8,0
8000a546:	fc 19 40 24 	movh	r9,0x4024
8000a54a:	e0 81 00 da 	brne	8000a6fe <_dtoa_r+0x71a>
8000a54e:	41 3c       	lddsp	r12,sp[0x4c]
8000a550:	08 3c       	cp.w	r12,r4
8000a552:	c5 f4       	brge	8000a610 <_dtoa_r+0x62c>
8000a554:	e0 a0 0b b0 	rcall	8000bcb4 <__avr32_f64_mul>
8000a558:	30 08       	mov	r8,0
8000a55a:	fa eb 00 28 	st.d	sp[40],r10
8000a55e:	fc 19 40 24 	movh	r9,0x4024
8000a562:	fa ea 00 08 	ld.d	r10,sp[8]
8000a566:	e0 a0 0b a7 	rcall	8000bcb4 <__avr32_f64_mul>
8000a56a:	fa eb 00 08 	st.d	sp[8],r10
8000a56e:	cc 3b       	rjmp	8000a4f4 <_dtoa_r+0x510>
8000a570:	40 85       	lddsp	r5,sp[0x20]
8000a572:	08 05       	add	r5,r4
8000a574:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a578:	51 35       	stdsp	sp[0x4c],r5
8000a57a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a57e:	40 85       	lddsp	r5,sp[0x20]
8000a580:	e0 a0 0b 9a 	rcall	8000bcb4 <__avr32_f64_mul>
8000a584:	fa eb 00 28 	st.d	sp[40],r10
8000a588:	fa ea 00 08 	ld.d	r10,sp[8]
8000a58c:	e0 a0 0d d8 	rcall	8000c13c <__avr32_f64_to_s32>
8000a590:	51 6c       	stdsp	sp[0x58],r12
8000a592:	e0 a0 0d ec 	rcall	8000c16a <__avr32_s32_to_f64>
8000a596:	14 98       	mov	r8,r10
8000a598:	16 99       	mov	r9,r11
8000a59a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a59e:	e0 a0 0c 77 	rcall	8000be8c <__avr32_f64_sub>
8000a5a2:	fa eb 00 08 	st.d	sp[8],r10
8000a5a6:	41 68       	lddsp	r8,sp[0x58]
8000a5a8:	2d 08       	sub	r8,-48
8000a5aa:	0a c8       	st.b	r5++,r8
8000a5ac:	41 3c       	lddsp	r12,sp[0x4c]
8000a5ae:	18 35       	cp.w	r5,r12
8000a5b0:	c2 81       	brne	8000a600 <_dtoa_r+0x61c>
8000a5b2:	30 08       	mov	r8,0
8000a5b4:	fc 19 3f e0 	movh	r9,0x3fe0
8000a5b8:	fa ea 00 28 	ld.d	r10,sp[40]
8000a5bc:	e0 a0 0d 36 	rcall	8000c028 <__avr32_f64_add>
8000a5c0:	40 85       	lddsp	r5,sp[0x20]
8000a5c2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5c6:	08 05       	add	r5,r4
8000a5c8:	e0 a0 0e 88 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a5cc:	e0 81 00 99 	brne	8000a6fe <_dtoa_r+0x71a>
8000a5d0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5d4:	30 0a       	mov	r10,0
8000a5d6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a5da:	e0 a0 0c 59 	rcall	8000be8c <__avr32_f64_sub>
8000a5de:	14 98       	mov	r8,r10
8000a5e0:	16 99       	mov	r9,r11
8000a5e2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5e6:	e0 a0 0e 79 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a5ea:	c1 30       	breq	8000a610 <_dtoa_r+0x62c>
8000a5ec:	33 09       	mov	r9,48
8000a5ee:	0a 98       	mov	r8,r5
8000a5f0:	11 7a       	ld.ub	r10,--r8
8000a5f2:	f2 0a 18 00 	cp.b	r10,r9
8000a5f6:	e0 81 02 d1 	brne	8000ab98 <_dtoa_r+0xbb4>
8000a5fa:	10 95       	mov	r5,r8
8000a5fc:	cf 9b       	rjmp	8000a5ee <_dtoa_r+0x60a>
8000a5fe:	d7 03       	nop
8000a600:	30 08       	mov	r8,0
8000a602:	fc 19 40 24 	movh	r9,0x4024
8000a606:	e0 a0 0b 57 	rcall	8000bcb4 <__avr32_f64_mul>
8000a60a:	fa eb 00 08 	st.d	sp[8],r10
8000a60e:	cb db       	rjmp	8000a588 <_dtoa_r+0x5a4>
8000a610:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a614:	fa eb 00 08 	st.d	sp[8],r10
8000a618:	58 e6       	cp.w	r6,14
8000a61a:	5f ab       	srle	r11
8000a61c:	41 8a       	lddsp	r10,sp[0x60]
8000a61e:	30 08       	mov	r8,0
8000a620:	f4 09 11 ff 	rsub	r9,r10,-1
8000a624:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a628:	f0 09 18 00 	cp.b	r9,r8
8000a62c:	e0 80 00 82 	breq	8000a730 <_dtoa_r+0x74c>
8000a630:	40 ea       	lddsp	r10,sp[0x38]
8000a632:	58 01       	cp.w	r1,0
8000a634:	5f a9       	srle	r9
8000a636:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a63a:	fe ca c6 9a 	sub	r10,pc,-14694
8000a63e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a642:	fa e5 00 10 	st.d	sp[16],r4
8000a646:	f0 09 18 00 	cp.b	r9,r8
8000a64a:	c1 40       	breq	8000a672 <_dtoa_r+0x68e>
8000a64c:	58 01       	cp.w	r1,0
8000a64e:	e0 81 01 77 	brne	8000a93c <_dtoa_r+0x958>
8000a652:	30 08       	mov	r8,0
8000a654:	fc 19 40 14 	movh	r9,0x4014
8000a658:	08 9a       	mov	r10,r4
8000a65a:	0a 9b       	mov	r11,r5
8000a65c:	e0 a0 0b 2c 	rcall	8000bcb4 <__avr32_f64_mul>
8000a660:	fa e8 00 08 	ld.d	r8,sp[8]
8000a664:	e0 a0 0e 06 	rcall	8000c270 <__avr32_f64_cmp_ge>
8000a668:	e0 81 01 6a 	brne	8000a93c <_dtoa_r+0x958>
8000a66c:	02 92       	mov	r2,r1
8000a66e:	e0 8f 01 72 	bral	8000a952 <_dtoa_r+0x96e>
8000a672:	40 85       	lddsp	r5,sp[0x20]
8000a674:	30 14       	mov	r4,1
8000a676:	fa e8 00 10 	ld.d	r8,sp[16]
8000a67a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a67e:	e0 a0 0e 61 	rcall	8000c340 <__avr32_f64_div>
8000a682:	e0 a0 0d 5d 	rcall	8000c13c <__avr32_f64_to_s32>
8000a686:	18 92       	mov	r2,r12
8000a688:	e0 a0 0d 71 	rcall	8000c16a <__avr32_s32_to_f64>
8000a68c:	fa e8 00 10 	ld.d	r8,sp[16]
8000a690:	e0 a0 0b 12 	rcall	8000bcb4 <__avr32_f64_mul>
8000a694:	14 98       	mov	r8,r10
8000a696:	16 99       	mov	r9,r11
8000a698:	fa ea 00 08 	ld.d	r10,sp[8]
8000a69c:	e0 a0 0b f8 	rcall	8000be8c <__avr32_f64_sub>
8000a6a0:	fa eb 00 08 	st.d	sp[8],r10
8000a6a4:	e4 c8 ff d0 	sub	r8,r2,-48
8000a6a8:	0a c8       	st.b	r5++,r8
8000a6aa:	fc 19 40 24 	movh	r9,0x4024
8000a6ae:	30 08       	mov	r8,0
8000a6b0:	02 34       	cp.w	r4,r1
8000a6b2:	c3 31       	brne	8000a718 <_dtoa_r+0x734>
8000a6b4:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6b8:	e0 a0 0c b8 	rcall	8000c028 <__avr32_f64_add>
8000a6bc:	16 91       	mov	r1,r11
8000a6be:	14 90       	mov	r0,r10
8000a6c0:	14 98       	mov	r8,r10
8000a6c2:	02 99       	mov	r9,r1
8000a6c4:	fa ea 00 10 	ld.d	r10,sp[16]
8000a6c8:	e0 a0 0e 08 	rcall	8000c2d8 <__avr32_f64_cmp_lt>
8000a6cc:	c1 a1       	brne	8000a700 <_dtoa_r+0x71c>
8000a6ce:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6d2:	00 9a       	mov	r10,r0
8000a6d4:	02 9b       	mov	r11,r1
8000a6d6:	e0 a0 0d ba 	rcall	8000c24a <__avr32_f64_cmp_eq>
8000a6da:	e0 80 02 5e 	breq	8000ab96 <_dtoa_r+0xbb2>
8000a6de:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a6e2:	c0 f1       	brne	8000a700 <_dtoa_r+0x71c>
8000a6e4:	e0 8f 02 59 	bral	8000ab96 <_dtoa_r+0xbb2>
8000a6e8:	40 8a       	lddsp	r10,sp[0x20]
8000a6ea:	14 38       	cp.w	r8,r10
8000a6ec:	c0 30       	breq	8000a6f2 <_dtoa_r+0x70e>
8000a6ee:	10 95       	mov	r5,r8
8000a6f0:	c0 98       	rjmp	8000a702 <_dtoa_r+0x71e>
8000a6f2:	33 08       	mov	r8,48
8000a6f4:	40 89       	lddsp	r9,sp[0x20]
8000a6f6:	2f f6       	sub	r6,-1
8000a6f8:	b2 88       	st.b	r9[0x0],r8
8000a6fa:	40 88       	lddsp	r8,sp[0x20]
8000a6fc:	c0 88       	rjmp	8000a70c <_dtoa_r+0x728>
8000a6fe:	40 66       	lddsp	r6,sp[0x18]
8000a700:	33 99       	mov	r9,57
8000a702:	0a 98       	mov	r8,r5
8000a704:	11 7a       	ld.ub	r10,--r8
8000a706:	f2 0a 18 00 	cp.b	r10,r9
8000a70a:	ce f0       	breq	8000a6e8 <_dtoa_r+0x704>
8000a70c:	50 66       	stdsp	sp[0x18],r6
8000a70e:	11 89       	ld.ub	r9,r8[0x0]
8000a710:	2f f9       	sub	r9,-1
8000a712:	b0 89       	st.b	r8[0x0],r9
8000a714:	e0 8f 02 42 	bral	8000ab98 <_dtoa_r+0xbb4>
8000a718:	e0 a0 0a ce 	rcall	8000bcb4 <__avr32_f64_mul>
8000a71c:	2f f4       	sub	r4,-1
8000a71e:	fa eb 00 08 	st.d	sp[8],r10
8000a722:	30 08       	mov	r8,0
8000a724:	30 09       	mov	r9,0
8000a726:	e0 a0 0d 92 	rcall	8000c24a <__avr32_f64_cmp_eq>
8000a72a:	ca 60       	breq	8000a676 <_dtoa_r+0x692>
8000a72c:	e0 8f 02 35 	bral	8000ab96 <_dtoa_r+0xbb2>
8000a730:	40 d8       	lddsp	r8,sp[0x34]
8000a732:	58 08       	cp.w	r8,0
8000a734:	c0 51       	brne	8000a73e <_dtoa_r+0x75a>
8000a736:	04 98       	mov	r8,r2
8000a738:	00 95       	mov	r5,r0
8000a73a:	40 d4       	lddsp	r4,sp[0x34]
8000a73c:	c3 78       	rjmp	8000a7aa <_dtoa_r+0x7c6>
8000a73e:	40 c5       	lddsp	r5,sp[0x30]
8000a740:	58 15       	cp.w	r5,1
8000a742:	e0 89 00 0f 	brgt	8000a760 <_dtoa_r+0x77c>
8000a746:	41 74       	lddsp	r4,sp[0x5c]
8000a748:	58 04       	cp.w	r4,0
8000a74a:	c0 40       	breq	8000a752 <_dtoa_r+0x76e>
8000a74c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a750:	c0 48       	rjmp	8000a758 <_dtoa_r+0x774>
8000a752:	41 99       	lddsp	r9,sp[0x64]
8000a754:	f2 09 11 36 	rsub	r9,r9,54
8000a758:	04 98       	mov	r8,r2
8000a75a:	00 95       	mov	r5,r0
8000a75c:	c1 c8       	rjmp	8000a794 <_dtoa_r+0x7b0>
8000a75e:	d7 03       	nop
8000a760:	e2 c8 00 01 	sub	r8,r1,1
8000a764:	58 01       	cp.w	r1,0
8000a766:	e0 05 17 40 	movge	r5,r0
8000a76a:	e2 09 17 40 	movge	r9,r1
8000a76e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a772:	f9 b9 05 00 	movlt	r9,0
8000a776:	10 32       	cp.w	r2,r8
8000a778:	e5 d8 e4 18 	subge	r8,r2,r8
8000a77c:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a780:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a784:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a788:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a78c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a790:	f9 b8 05 00 	movlt	r8,0
8000a794:	40 4b       	lddsp	r11,sp[0x10]
8000a796:	12 0b       	add	r11,r9
8000a798:	50 08       	stdsp	sp[0x0],r8
8000a79a:	50 4b       	stdsp	sp[0x10],r11
8000a79c:	12 00       	add	r0,r9
8000a79e:	30 1b       	mov	r11,1
8000a7a0:	0e 9c       	mov	r12,r7
8000a7a2:	e0 a0 08 a7 	rcall	8000b8f0 <__i2b>
8000a7a6:	40 08       	lddsp	r8,sp[0x0]
8000a7a8:	18 94       	mov	r4,r12
8000a7aa:	40 4a       	lddsp	r10,sp[0x10]
8000a7ac:	58 05       	cp.w	r5,0
8000a7ae:	5f 99       	srgt	r9
8000a7b0:	58 0a       	cp.w	r10,0
8000a7b2:	5f 9a       	srgt	r10
8000a7b4:	f5 e9 00 09 	and	r9,r10,r9
8000a7b8:	c0 80       	breq	8000a7c8 <_dtoa_r+0x7e4>
8000a7ba:	40 4c       	lddsp	r12,sp[0x10]
8000a7bc:	f8 05 0d 49 	min	r9,r12,r5
8000a7c0:	12 1c       	sub	r12,r9
8000a7c2:	12 10       	sub	r0,r9
8000a7c4:	50 4c       	stdsp	sp[0x10],r12
8000a7c6:	12 15       	sub	r5,r9
8000a7c8:	58 02       	cp.w	r2,0
8000a7ca:	e0 8a 00 27 	brle	8000a818 <_dtoa_r+0x834>
8000a7ce:	40 db       	lddsp	r11,sp[0x34]
8000a7d0:	58 0b       	cp.w	r11,0
8000a7d2:	c1 d0       	breq	8000a80c <_dtoa_r+0x828>
8000a7d4:	58 08       	cp.w	r8,0
8000a7d6:	e0 8a 00 17 	brle	8000a804 <_dtoa_r+0x820>
8000a7da:	10 9a       	mov	r10,r8
8000a7dc:	50 08       	stdsp	sp[0x0],r8
8000a7de:	08 9b       	mov	r11,r4
8000a7e0:	0e 9c       	mov	r12,r7
8000a7e2:	e0 a0 08 cd 	rcall	8000b97c <__pow5mult>
8000a7e6:	06 9a       	mov	r10,r3
8000a7e8:	18 9b       	mov	r11,r12
8000a7ea:	18 94       	mov	r4,r12
8000a7ec:	0e 9c       	mov	r12,r7
8000a7ee:	e0 a0 08 01 	rcall	8000b7f0 <__multiply>
8000a7f2:	18 99       	mov	r9,r12
8000a7f4:	06 9b       	mov	r11,r3
8000a7f6:	50 19       	stdsp	sp[0x4],r9
8000a7f8:	0e 9c       	mov	r12,r7
8000a7fa:	e0 a0 06 ad 	rcall	8000b554 <_Bfree>
8000a7fe:	40 19       	lddsp	r9,sp[0x4]
8000a800:	40 08       	lddsp	r8,sp[0x0]
8000a802:	12 93       	mov	r3,r9
8000a804:	e4 08 01 0a 	sub	r10,r2,r8
8000a808:	c0 80       	breq	8000a818 <_dtoa_r+0x834>
8000a80a:	c0 28       	rjmp	8000a80e <_dtoa_r+0x82a>
8000a80c:	04 9a       	mov	r10,r2
8000a80e:	06 9b       	mov	r11,r3
8000a810:	0e 9c       	mov	r12,r7
8000a812:	e0 a0 08 b5 	rcall	8000b97c <__pow5mult>
8000a816:	18 93       	mov	r3,r12
8000a818:	30 1b       	mov	r11,1
8000a81a:	0e 9c       	mov	r12,r7
8000a81c:	e0 a0 08 6a 	rcall	8000b8f0 <__i2b>
8000a820:	41 1a       	lddsp	r10,sp[0x44]
8000a822:	18 92       	mov	r2,r12
8000a824:	58 0a       	cp.w	r10,0
8000a826:	e0 8a 00 07 	brle	8000a834 <_dtoa_r+0x850>
8000a82a:	18 9b       	mov	r11,r12
8000a82c:	0e 9c       	mov	r12,r7
8000a82e:	e0 a0 08 a7 	rcall	8000b97c <__pow5mult>
8000a832:	18 92       	mov	r2,r12
8000a834:	40 c9       	lddsp	r9,sp[0x30]
8000a836:	58 19       	cp.w	r9,1
8000a838:	e0 89 00 14 	brgt	8000a860 <_dtoa_r+0x87c>
8000a83c:	40 38       	lddsp	r8,sp[0xc]
8000a83e:	58 08       	cp.w	r8,0
8000a840:	c1 01       	brne	8000a860 <_dtoa_r+0x87c>
8000a842:	40 29       	lddsp	r9,sp[0x8]
8000a844:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a848:	c0 c1       	brne	8000a860 <_dtoa_r+0x87c>
8000a84a:	12 98       	mov	r8,r9
8000a84c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a850:	c0 80       	breq	8000a860 <_dtoa_r+0x87c>
8000a852:	40 4c       	lddsp	r12,sp[0x10]
8000a854:	30 1b       	mov	r11,1
8000a856:	2f fc       	sub	r12,-1
8000a858:	2f f0       	sub	r0,-1
8000a85a:	50 4c       	stdsp	sp[0x10],r12
8000a85c:	50 6b       	stdsp	sp[0x18],r11
8000a85e:	c0 38       	rjmp	8000a864 <_dtoa_r+0x880>
8000a860:	30 0a       	mov	r10,0
8000a862:	50 6a       	stdsp	sp[0x18],r10
8000a864:	41 19       	lddsp	r9,sp[0x44]
8000a866:	58 09       	cp.w	r9,0
8000a868:	c0 31       	brne	8000a86e <_dtoa_r+0x88a>
8000a86a:	30 1c       	mov	r12,1
8000a86c:	c0 98       	rjmp	8000a87e <_dtoa_r+0x89a>
8000a86e:	64 48       	ld.w	r8,r2[0x10]
8000a870:	2f c8       	sub	r8,-4
8000a872:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a876:	e0 a0 05 df 	rcall	8000b434 <__hi0bits>
8000a87a:	f8 0c 11 20 	rsub	r12,r12,32
8000a87e:	40 4b       	lddsp	r11,sp[0x10]
8000a880:	f8 0b 00 08 	add	r8,r12,r11
8000a884:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a888:	c0 c0       	breq	8000a8a0 <_dtoa_r+0x8bc>
8000a88a:	f0 08 11 20 	rsub	r8,r8,32
8000a88e:	58 48       	cp.w	r8,4
8000a890:	e0 8a 00 06 	brle	8000a89c <_dtoa_r+0x8b8>
8000a894:	20 48       	sub	r8,4
8000a896:	10 0b       	add	r11,r8
8000a898:	50 4b       	stdsp	sp[0x10],r11
8000a89a:	c0 78       	rjmp	8000a8a8 <_dtoa_r+0x8c4>
8000a89c:	58 48       	cp.w	r8,4
8000a89e:	c0 70       	breq	8000a8ac <_dtoa_r+0x8c8>
8000a8a0:	40 4a       	lddsp	r10,sp[0x10]
8000a8a2:	2e 48       	sub	r8,-28
8000a8a4:	10 0a       	add	r10,r8
8000a8a6:	50 4a       	stdsp	sp[0x10],r10
8000a8a8:	10 00       	add	r0,r8
8000a8aa:	10 05       	add	r5,r8
8000a8ac:	58 00       	cp.w	r0,0
8000a8ae:	e0 8a 00 08 	brle	8000a8be <_dtoa_r+0x8da>
8000a8b2:	06 9b       	mov	r11,r3
8000a8b4:	00 9a       	mov	r10,r0
8000a8b6:	0e 9c       	mov	r12,r7
8000a8b8:	e0 a0 07 58 	rcall	8000b768 <__lshift>
8000a8bc:	18 93       	mov	r3,r12
8000a8be:	40 49       	lddsp	r9,sp[0x10]
8000a8c0:	58 09       	cp.w	r9,0
8000a8c2:	e0 8a 00 08 	brle	8000a8d2 <_dtoa_r+0x8ee>
8000a8c6:	04 9b       	mov	r11,r2
8000a8c8:	12 9a       	mov	r10,r9
8000a8ca:	0e 9c       	mov	r12,r7
8000a8cc:	e0 a0 07 4e 	rcall	8000b768 <__lshift>
8000a8d0:	18 92       	mov	r2,r12
8000a8d2:	41 48       	lddsp	r8,sp[0x50]
8000a8d4:	58 08       	cp.w	r8,0
8000a8d6:	c1 b0       	breq	8000a90c <_dtoa_r+0x928>
8000a8d8:	04 9b       	mov	r11,r2
8000a8da:	06 9c       	mov	r12,r3
8000a8dc:	e0 a0 06 23 	rcall	8000b522 <__mcmp>
8000a8e0:	c1 64       	brge	8000a90c <_dtoa_r+0x928>
8000a8e2:	06 9b       	mov	r11,r3
8000a8e4:	30 09       	mov	r9,0
8000a8e6:	30 aa       	mov	r10,10
8000a8e8:	0e 9c       	mov	r12,r7
8000a8ea:	e0 a0 08 0b 	rcall	8000b900 <__multadd>
8000a8ee:	20 16       	sub	r6,1
8000a8f0:	18 93       	mov	r3,r12
8000a8f2:	40 dc       	lddsp	r12,sp[0x34]
8000a8f4:	58 0c       	cp.w	r12,0
8000a8f6:	c0 31       	brne	8000a8fc <_dtoa_r+0x918>
8000a8f8:	40 91       	lddsp	r1,sp[0x24]
8000a8fa:	c0 98       	rjmp	8000a90c <_dtoa_r+0x928>
8000a8fc:	08 9b       	mov	r11,r4
8000a8fe:	40 91       	lddsp	r1,sp[0x24]
8000a900:	30 09       	mov	r9,0
8000a902:	30 aa       	mov	r10,10
8000a904:	0e 9c       	mov	r12,r7
8000a906:	e0 a0 07 fd 	rcall	8000b900 <__multadd>
8000a90a:	18 94       	mov	r4,r12
8000a90c:	58 01       	cp.w	r1,0
8000a90e:	5f a9       	srle	r9
8000a910:	40 cb       	lddsp	r11,sp[0x30]
8000a912:	58 2b       	cp.w	r11,2
8000a914:	5f 98       	srgt	r8
8000a916:	f3 e8 00 08 	and	r8,r9,r8
8000a91a:	c2 50       	breq	8000a964 <_dtoa_r+0x980>
8000a91c:	58 01       	cp.w	r1,0
8000a91e:	c1 11       	brne	8000a940 <_dtoa_r+0x95c>
8000a920:	04 9b       	mov	r11,r2
8000a922:	02 99       	mov	r9,r1
8000a924:	30 5a       	mov	r10,5
8000a926:	0e 9c       	mov	r12,r7
8000a928:	e0 a0 07 ec 	rcall	8000b900 <__multadd>
8000a92c:	18 92       	mov	r2,r12
8000a92e:	18 9b       	mov	r11,r12
8000a930:	06 9c       	mov	r12,r3
8000a932:	e0 a0 05 f8 	rcall	8000b522 <__mcmp>
8000a936:	e0 89 00 0f 	brgt	8000a954 <_dtoa_r+0x970>
8000a93a:	c0 38       	rjmp	8000a940 <_dtoa_r+0x95c>
8000a93c:	30 02       	mov	r2,0
8000a93e:	04 94       	mov	r4,r2
8000a940:	40 ea       	lddsp	r10,sp[0x38]
8000a942:	30 09       	mov	r9,0
8000a944:	5c da       	com	r10
8000a946:	40 85       	lddsp	r5,sp[0x20]
8000a948:	50 6a       	stdsp	sp[0x18],r10
8000a94a:	50 49       	stdsp	sp[0x10],r9
8000a94c:	c0 f9       	rjmp	8000ab6a <_dtoa_r+0xb86>
8000a94e:	08 92       	mov	r2,r4
8000a950:	40 66       	lddsp	r6,sp[0x18]
8000a952:	04 94       	mov	r4,r2
8000a954:	2f f6       	sub	r6,-1
8000a956:	50 66       	stdsp	sp[0x18],r6
8000a958:	33 18       	mov	r8,49
8000a95a:	40 85       	lddsp	r5,sp[0x20]
8000a95c:	0a c8       	st.b	r5++,r8
8000a95e:	30 08       	mov	r8,0
8000a960:	50 48       	stdsp	sp[0x10],r8
8000a962:	c0 49       	rjmp	8000ab6a <_dtoa_r+0xb86>
8000a964:	40 dc       	lddsp	r12,sp[0x34]
8000a966:	58 0c       	cp.w	r12,0
8000a968:	e0 80 00 b5 	breq	8000aad2 <_dtoa_r+0xaee>
8000a96c:	58 05       	cp.w	r5,0
8000a96e:	e0 8a 00 08 	brle	8000a97e <_dtoa_r+0x99a>
8000a972:	08 9b       	mov	r11,r4
8000a974:	0a 9a       	mov	r10,r5
8000a976:	0e 9c       	mov	r12,r7
8000a978:	e0 a0 06 f8 	rcall	8000b768 <__lshift>
8000a97c:	18 94       	mov	r4,r12
8000a97e:	40 6b       	lddsp	r11,sp[0x18]
8000a980:	58 0b       	cp.w	r11,0
8000a982:	c0 31       	brne	8000a988 <_dtoa_r+0x9a4>
8000a984:	08 9c       	mov	r12,r4
8000a986:	c1 38       	rjmp	8000a9ac <_dtoa_r+0x9c8>
8000a988:	68 1b       	ld.w	r11,r4[0x4]
8000a98a:	0e 9c       	mov	r12,r7
8000a98c:	e0 a0 05 fe 	rcall	8000b588 <_Balloc>
8000a990:	68 4a       	ld.w	r10,r4[0x10]
8000a992:	18 95       	mov	r5,r12
8000a994:	e8 cb ff f4 	sub	r11,r4,-12
8000a998:	2f ea       	sub	r10,-2
8000a99a:	2f 4c       	sub	r12,-12
8000a99c:	a3 6a       	lsl	r10,0x2
8000a99e:	fe b0 e6 4f 	rcall	8000763c <memcpy>
8000a9a2:	0a 9b       	mov	r11,r5
8000a9a4:	30 1a       	mov	r10,1
8000a9a6:	0e 9c       	mov	r12,r7
8000a9a8:	e0 a0 06 e0 	rcall	8000b768 <__lshift>
8000a9ac:	50 44       	stdsp	sp[0x10],r4
8000a9ae:	40 3a       	lddsp	r10,sp[0xc]
8000a9b0:	30 19       	mov	r9,1
8000a9b2:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a9b6:	18 94       	mov	r4,r12
8000a9b8:	50 da       	stdsp	sp[0x34],r10
8000a9ba:	40 85       	lddsp	r5,sp[0x20]
8000a9bc:	50 99       	stdsp	sp[0x24],r9
8000a9be:	50 26       	stdsp	sp[0x8],r6
8000a9c0:	50 e1       	stdsp	sp[0x38],r1
8000a9c2:	04 9b       	mov	r11,r2
8000a9c4:	06 9c       	mov	r12,r3
8000a9c6:	fe b0 fa 7f 	rcall	80009ec4 <quorem>
8000a9ca:	40 4b       	lddsp	r11,sp[0x10]
8000a9cc:	f8 c0 ff d0 	sub	r0,r12,-48
8000a9d0:	06 9c       	mov	r12,r3
8000a9d2:	e0 a0 05 a8 	rcall	8000b522 <__mcmp>
8000a9d6:	08 9a       	mov	r10,r4
8000a9d8:	50 6c       	stdsp	sp[0x18],r12
8000a9da:	04 9b       	mov	r11,r2
8000a9dc:	0e 9c       	mov	r12,r7
8000a9de:	e0 a0 06 5d 	rcall	8000b698 <__mdiff>
8000a9e2:	18 91       	mov	r1,r12
8000a9e4:	78 38       	ld.w	r8,r12[0xc]
8000a9e6:	58 08       	cp.w	r8,0
8000a9e8:	c0 30       	breq	8000a9ee <_dtoa_r+0xa0a>
8000a9ea:	30 16       	mov	r6,1
8000a9ec:	c0 68       	rjmp	8000a9f8 <_dtoa_r+0xa14>
8000a9ee:	18 9b       	mov	r11,r12
8000a9f0:	06 9c       	mov	r12,r3
8000a9f2:	e0 a0 05 98 	rcall	8000b522 <__mcmp>
8000a9f6:	18 96       	mov	r6,r12
8000a9f8:	0e 9c       	mov	r12,r7
8000a9fa:	02 9b       	mov	r11,r1
8000a9fc:	e0 a0 05 ac 	rcall	8000b554 <_Bfree>
8000aa00:	40 cc       	lddsp	r12,sp[0x30]
8000aa02:	ed ec 10 08 	or	r8,r6,r12
8000aa06:	c0 d1       	brne	8000aa20 <_dtoa_r+0xa3c>
8000aa08:	40 db       	lddsp	r11,sp[0x34]
8000aa0a:	58 0b       	cp.w	r11,0
8000aa0c:	c0 a1       	brne	8000aa20 <_dtoa_r+0xa3c>
8000aa0e:	40 26       	lddsp	r6,sp[0x8]
8000aa10:	e0 40 00 39 	cp.w	r0,57
8000aa14:	c3 00       	breq	8000aa74 <_dtoa_r+0xa90>
8000aa16:	40 6a       	lddsp	r10,sp[0x18]
8000aa18:	58 0a       	cp.w	r10,0
8000aa1a:	e0 89 00 24 	brgt	8000aa62 <_dtoa_r+0xa7e>
8000aa1e:	c2 f8       	rjmp	8000aa7c <_dtoa_r+0xa98>
8000aa20:	40 69       	lddsp	r9,sp[0x18]
8000aa22:	58 09       	cp.w	r9,0
8000aa24:	c0 85       	brlt	8000aa34 <_dtoa_r+0xa50>
8000aa26:	12 98       	mov	r8,r9
8000aa28:	40 cc       	lddsp	r12,sp[0x30]
8000aa2a:	18 48       	or	r8,r12
8000aa2c:	c1 d1       	brne	8000aa66 <_dtoa_r+0xa82>
8000aa2e:	40 db       	lddsp	r11,sp[0x34]
8000aa30:	58 0b       	cp.w	r11,0
8000aa32:	c1 a1       	brne	8000aa66 <_dtoa_r+0xa82>
8000aa34:	0c 99       	mov	r9,r6
8000aa36:	40 26       	lddsp	r6,sp[0x8]
8000aa38:	58 09       	cp.w	r9,0
8000aa3a:	e0 8a 00 21 	brle	8000aa7c <_dtoa_r+0xa98>
8000aa3e:	06 9b       	mov	r11,r3
8000aa40:	30 1a       	mov	r10,1
8000aa42:	0e 9c       	mov	r12,r7
8000aa44:	e0 a0 06 92 	rcall	8000b768 <__lshift>
8000aa48:	04 9b       	mov	r11,r2
8000aa4a:	18 93       	mov	r3,r12
8000aa4c:	e0 a0 05 6b 	rcall	8000b522 <__mcmp>
8000aa50:	e0 89 00 06 	brgt	8000aa5c <_dtoa_r+0xa78>
8000aa54:	c1 41       	brne	8000aa7c <_dtoa_r+0xa98>
8000aa56:	ed b0 00 00 	bld	r0,0x0
8000aa5a:	c1 11       	brne	8000aa7c <_dtoa_r+0xa98>
8000aa5c:	e0 40 00 39 	cp.w	r0,57
8000aa60:	c0 a0       	breq	8000aa74 <_dtoa_r+0xa90>
8000aa62:	2f f0       	sub	r0,-1
8000aa64:	c0 c8       	rjmp	8000aa7c <_dtoa_r+0xa98>
8000aa66:	58 06       	cp.w	r6,0
8000aa68:	e0 8a 00 0c 	brle	8000aa80 <_dtoa_r+0xa9c>
8000aa6c:	40 26       	lddsp	r6,sp[0x8]
8000aa6e:	e0 40 00 39 	cp.w	r0,57
8000aa72:	c0 41       	brne	8000aa7a <_dtoa_r+0xa96>
8000aa74:	33 98       	mov	r8,57
8000aa76:	0a c8       	st.b	r5++,r8
8000aa78:	c6 78       	rjmp	8000ab46 <_dtoa_r+0xb62>
8000aa7a:	2f f0       	sub	r0,-1
8000aa7c:	0a c0       	st.b	r5++,r0
8000aa7e:	c7 58       	rjmp	8000ab68 <_dtoa_r+0xb84>
8000aa80:	0a c0       	st.b	r5++,r0
8000aa82:	40 9a       	lddsp	r10,sp[0x24]
8000aa84:	40 e9       	lddsp	r9,sp[0x38]
8000aa86:	12 3a       	cp.w	r10,r9
8000aa88:	c4 30       	breq	8000ab0e <_dtoa_r+0xb2a>
8000aa8a:	06 9b       	mov	r11,r3
8000aa8c:	30 09       	mov	r9,0
8000aa8e:	30 aa       	mov	r10,10
8000aa90:	0e 9c       	mov	r12,r7
8000aa92:	e0 a0 07 37 	rcall	8000b900 <__multadd>
8000aa96:	40 48       	lddsp	r8,sp[0x10]
8000aa98:	18 93       	mov	r3,r12
8000aa9a:	08 38       	cp.w	r8,r4
8000aa9c:	c0 91       	brne	8000aaae <_dtoa_r+0xaca>
8000aa9e:	10 9b       	mov	r11,r8
8000aaa0:	30 09       	mov	r9,0
8000aaa2:	30 aa       	mov	r10,10
8000aaa4:	0e 9c       	mov	r12,r7
8000aaa6:	e0 a0 07 2d 	rcall	8000b900 <__multadd>
8000aaaa:	50 4c       	stdsp	sp[0x10],r12
8000aaac:	c0 e8       	rjmp	8000aac8 <_dtoa_r+0xae4>
8000aaae:	40 4b       	lddsp	r11,sp[0x10]
8000aab0:	30 09       	mov	r9,0
8000aab2:	30 aa       	mov	r10,10
8000aab4:	0e 9c       	mov	r12,r7
8000aab6:	e0 a0 07 25 	rcall	8000b900 <__multadd>
8000aaba:	08 9b       	mov	r11,r4
8000aabc:	50 4c       	stdsp	sp[0x10],r12
8000aabe:	30 09       	mov	r9,0
8000aac0:	30 aa       	mov	r10,10
8000aac2:	0e 9c       	mov	r12,r7
8000aac4:	e0 a0 07 1e 	rcall	8000b900 <__multadd>
8000aac8:	18 94       	mov	r4,r12
8000aaca:	40 9c       	lddsp	r12,sp[0x24]
8000aacc:	2f fc       	sub	r12,-1
8000aace:	50 9c       	stdsp	sp[0x24],r12
8000aad0:	c7 9b       	rjmp	8000a9c2 <_dtoa_r+0x9de>
8000aad2:	30 18       	mov	r8,1
8000aad4:	06 90       	mov	r0,r3
8000aad6:	40 85       	lddsp	r5,sp[0x20]
8000aad8:	08 93       	mov	r3,r4
8000aada:	0c 94       	mov	r4,r6
8000aadc:	10 96       	mov	r6,r8
8000aade:	04 9b       	mov	r11,r2
8000aae0:	00 9c       	mov	r12,r0
8000aae2:	fe b0 f9 f1 	rcall	80009ec4 <quorem>
8000aae6:	2d 0c       	sub	r12,-48
8000aae8:	0a cc       	st.b	r5++,r12
8000aaea:	02 36       	cp.w	r6,r1
8000aaec:	c0 a4       	brge	8000ab00 <_dtoa_r+0xb1c>
8000aaee:	00 9b       	mov	r11,r0
8000aaf0:	30 09       	mov	r9,0
8000aaf2:	30 aa       	mov	r10,10
8000aaf4:	0e 9c       	mov	r12,r7
8000aaf6:	2f f6       	sub	r6,-1
8000aaf8:	e0 a0 07 04 	rcall	8000b900 <__multadd>
8000aafc:	18 90       	mov	r0,r12
8000aafe:	cf 0b       	rjmp	8000aade <_dtoa_r+0xafa>
8000ab00:	08 96       	mov	r6,r4
8000ab02:	30 0b       	mov	r11,0
8000ab04:	06 94       	mov	r4,r3
8000ab06:	50 4b       	stdsp	sp[0x10],r11
8000ab08:	00 93       	mov	r3,r0
8000ab0a:	18 90       	mov	r0,r12
8000ab0c:	c0 28       	rjmp	8000ab10 <_dtoa_r+0xb2c>
8000ab0e:	40 26       	lddsp	r6,sp[0x8]
8000ab10:	06 9b       	mov	r11,r3
8000ab12:	30 1a       	mov	r10,1
8000ab14:	0e 9c       	mov	r12,r7
8000ab16:	e0 a0 06 29 	rcall	8000b768 <__lshift>
8000ab1a:	04 9b       	mov	r11,r2
8000ab1c:	18 93       	mov	r3,r12
8000ab1e:	e0 a0 05 02 	rcall	8000b522 <__mcmp>
8000ab22:	e0 89 00 12 	brgt	8000ab46 <_dtoa_r+0xb62>
8000ab26:	c1 b1       	brne	8000ab5c <_dtoa_r+0xb78>
8000ab28:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ab2c:	c0 d1       	brne	8000ab46 <_dtoa_r+0xb62>
8000ab2e:	c1 78       	rjmp	8000ab5c <_dtoa_r+0xb78>
8000ab30:	40 89       	lddsp	r9,sp[0x20]
8000ab32:	12 38       	cp.w	r8,r9
8000ab34:	c0 30       	breq	8000ab3a <_dtoa_r+0xb56>
8000ab36:	10 95       	mov	r5,r8
8000ab38:	c0 88       	rjmp	8000ab48 <_dtoa_r+0xb64>
8000ab3a:	2f f6       	sub	r6,-1
8000ab3c:	50 66       	stdsp	sp[0x18],r6
8000ab3e:	33 18       	mov	r8,49
8000ab40:	40 8c       	lddsp	r12,sp[0x20]
8000ab42:	b8 88       	st.b	r12[0x0],r8
8000ab44:	c1 38       	rjmp	8000ab6a <_dtoa_r+0xb86>
8000ab46:	33 9a       	mov	r10,57
8000ab48:	0a 98       	mov	r8,r5
8000ab4a:	11 79       	ld.ub	r9,--r8
8000ab4c:	f4 09 18 00 	cp.b	r9,r10
8000ab50:	cf 00       	breq	8000ab30 <_dtoa_r+0xb4c>
8000ab52:	2f f9       	sub	r9,-1
8000ab54:	b0 89       	st.b	r8[0x0],r9
8000ab56:	c0 98       	rjmp	8000ab68 <_dtoa_r+0xb84>
8000ab58:	10 95       	mov	r5,r8
8000ab5a:	c0 28       	rjmp	8000ab5e <_dtoa_r+0xb7a>
8000ab5c:	33 09       	mov	r9,48
8000ab5e:	0a 98       	mov	r8,r5
8000ab60:	11 7a       	ld.ub	r10,--r8
8000ab62:	f2 0a 18 00 	cp.b	r10,r9
8000ab66:	cf 90       	breq	8000ab58 <_dtoa_r+0xb74>
8000ab68:	50 66       	stdsp	sp[0x18],r6
8000ab6a:	04 9b       	mov	r11,r2
8000ab6c:	0e 9c       	mov	r12,r7
8000ab6e:	e0 a0 04 f3 	rcall	8000b554 <_Bfree>
8000ab72:	58 04       	cp.w	r4,0
8000ab74:	c1 20       	breq	8000ab98 <_dtoa_r+0xbb4>
8000ab76:	40 4b       	lddsp	r11,sp[0x10]
8000ab78:	08 3b       	cp.w	r11,r4
8000ab7a:	5f 19       	srne	r9
8000ab7c:	58 0b       	cp.w	r11,0
8000ab7e:	5f 18       	srne	r8
8000ab80:	f3 e8 00 08 	and	r8,r9,r8
8000ab84:	c0 40       	breq	8000ab8c <_dtoa_r+0xba8>
8000ab86:	0e 9c       	mov	r12,r7
8000ab88:	e0 a0 04 e6 	rcall	8000b554 <_Bfree>
8000ab8c:	08 9b       	mov	r11,r4
8000ab8e:	0e 9c       	mov	r12,r7
8000ab90:	e0 a0 04 e2 	rcall	8000b554 <_Bfree>
8000ab94:	c0 28       	rjmp	8000ab98 <_dtoa_r+0xbb4>
8000ab96:	50 66       	stdsp	sp[0x18],r6
8000ab98:	0e 9c       	mov	r12,r7
8000ab9a:	06 9b       	mov	r11,r3
8000ab9c:	e0 a0 04 dc 	rcall	8000b554 <_Bfree>
8000aba0:	30 08       	mov	r8,0
8000aba2:	aa 88       	st.b	r5[0x0],r8
8000aba4:	40 68       	lddsp	r8,sp[0x18]
8000aba6:	41 5a       	lddsp	r10,sp[0x54]
8000aba8:	2f f8       	sub	r8,-1
8000abaa:	41 29       	lddsp	r9,sp[0x48]
8000abac:	95 08       	st.w	r10[0x0],r8
8000abae:	40 8c       	lddsp	r12,sp[0x20]
8000abb0:	58 09       	cp.w	r9,0
8000abb2:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000abb6:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000abba:	2e 6d       	sub	sp,-104
8000abbc:	d8 32       	popm	r0-r7,pc
8000abbe:	d7 03       	nop

8000abc0 <__errno>:
8000abc0:	e0 68 0a 30 	mov	r8,2608
8000abc4:	70 0c       	ld.w	r12,r8[0x0]
8000abc6:	2f 4c       	sub	r12,-12
8000abc8:	5e fc       	retal	r12
8000abca:	d7 03       	nop

8000abcc <_fflush_r>:
8000abcc:	d4 21       	pushm	r4-r7,lr
8000abce:	16 97       	mov	r7,r11
8000abd0:	18 96       	mov	r6,r12
8000abd2:	76 48       	ld.w	r8,r11[0x10]
8000abd4:	58 08       	cp.w	r8,0
8000abd6:	c7 f0       	breq	8000acd4 <_fflush_r+0x108>
8000abd8:	58 0c       	cp.w	r12,0
8000abda:	c0 50       	breq	8000abe4 <_fflush_r+0x18>
8000abdc:	78 68       	ld.w	r8,r12[0x18]
8000abde:	58 08       	cp.w	r8,0
8000abe0:	c0 21       	brne	8000abe4 <_fflush_r+0x18>
8000abe2:	cc dc       	rcall	8000ad7c <__sinit>
8000abe4:	fe c8 cc f4 	sub	r8,pc,-13068
8000abe8:	10 37       	cp.w	r7,r8
8000abea:	c0 31       	brne	8000abf0 <_fflush_r+0x24>
8000abec:	6c 07       	ld.w	r7,r6[0x0]
8000abee:	c0 c8       	rjmp	8000ac06 <_fflush_r+0x3a>
8000abf0:	fe c8 cc e0 	sub	r8,pc,-13088
8000abf4:	10 37       	cp.w	r7,r8
8000abf6:	c0 31       	brne	8000abfc <_fflush_r+0x30>
8000abf8:	6c 17       	ld.w	r7,r6[0x4]
8000abfa:	c0 68       	rjmp	8000ac06 <_fflush_r+0x3a>
8000abfc:	fe c8 cc cc 	sub	r8,pc,-13108
8000ac00:	10 37       	cp.w	r7,r8
8000ac02:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ac06:	8e 6a       	ld.sh	r10,r7[0xc]
8000ac08:	14 98       	mov	r8,r10
8000ac0a:	ed ba 00 03 	bld	r10,0x3
8000ac0e:	c4 20       	breq	8000ac92 <_fflush_r+0xc6>
8000ac10:	ab ba       	sbr	r10,0xb
8000ac12:	ae 6a       	st.h	r7[0xc],r10
8000ac14:	6e 18       	ld.w	r8,r7[0x4]
8000ac16:	58 08       	cp.w	r8,0
8000ac18:	e0 89 00 06 	brgt	8000ac24 <_fflush_r+0x58>
8000ac1c:	6f 08       	ld.w	r8,r7[0x40]
8000ac1e:	58 08       	cp.w	r8,0
8000ac20:	e0 8a 00 5a 	brle	8000acd4 <_fflush_r+0x108>
8000ac24:	6e b8       	ld.w	r8,r7[0x2c]
8000ac26:	58 08       	cp.w	r8,0
8000ac28:	c5 60       	breq	8000acd4 <_fflush_r+0x108>
8000ac2a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ac2e:	c0 30       	breq	8000ac34 <_fflush_r+0x68>
8000ac30:	6f 55       	ld.w	r5,r7[0x54]
8000ac32:	c0 f8       	rjmp	8000ac50 <_fflush_r+0x84>
8000ac34:	30 19       	mov	r9,1
8000ac36:	6e 8b       	ld.w	r11,r7[0x20]
8000ac38:	0c 9c       	mov	r12,r6
8000ac3a:	5d 18       	icall	r8
8000ac3c:	18 95       	mov	r5,r12
8000ac3e:	5b fc       	cp.w	r12,-1
8000ac40:	c0 81       	brne	8000ac50 <_fflush_r+0x84>
8000ac42:	6c 38       	ld.w	r8,r6[0xc]
8000ac44:	59 d8       	cp.w	r8,29
8000ac46:	c4 70       	breq	8000acd4 <_fflush_r+0x108>
8000ac48:	8e 68       	ld.sh	r8,r7[0xc]
8000ac4a:	a7 a8       	sbr	r8,0x6
8000ac4c:	ae 68       	st.h	r7[0xc],r8
8000ac4e:	d8 22       	popm	r4-r7,pc
8000ac50:	8e 68       	ld.sh	r8,r7[0xc]
8000ac52:	ed b8 00 02 	bld	r8,0x2
8000ac56:	c0 91       	brne	8000ac68 <_fflush_r+0x9c>
8000ac58:	6e 18       	ld.w	r8,r7[0x4]
8000ac5a:	10 15       	sub	r5,r8
8000ac5c:	6e d8       	ld.w	r8,r7[0x34]
8000ac5e:	58 08       	cp.w	r8,0
8000ac60:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ac64:	eb d8 e1 15 	subne	r5,r5,r8
8000ac68:	6e b8       	ld.w	r8,r7[0x2c]
8000ac6a:	0c 9c       	mov	r12,r6
8000ac6c:	30 09       	mov	r9,0
8000ac6e:	0a 9a       	mov	r10,r5
8000ac70:	6e 8b       	ld.w	r11,r7[0x20]
8000ac72:	5d 18       	icall	r8
8000ac74:	8e 68       	ld.sh	r8,r7[0xc]
8000ac76:	0a 3c       	cp.w	r12,r5
8000ac78:	c2 61       	brne	8000acc4 <_fflush_r+0xf8>
8000ac7a:	ab d8       	cbr	r8,0xb
8000ac7c:	30 0c       	mov	r12,0
8000ac7e:	6e 49       	ld.w	r9,r7[0x10]
8000ac80:	ae 68       	st.h	r7[0xc],r8
8000ac82:	8f 1c       	st.w	r7[0x4],r12
8000ac84:	8f 09       	st.w	r7[0x0],r9
8000ac86:	ed b8 00 0c 	bld	r8,0xc
8000ac8a:	c2 51       	brne	8000acd4 <_fflush_r+0x108>
8000ac8c:	ef 45 00 54 	st.w	r7[84],r5
8000ac90:	d8 22       	popm	r4-r7,pc
8000ac92:	6e 45       	ld.w	r5,r7[0x10]
8000ac94:	58 05       	cp.w	r5,0
8000ac96:	c1 f0       	breq	8000acd4 <_fflush_r+0x108>
8000ac98:	6e 04       	ld.w	r4,r7[0x0]
8000ac9a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ac9e:	8f 05       	st.w	r7[0x0],r5
8000aca0:	f9 b8 01 00 	movne	r8,0
8000aca4:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aca8:	0a 14       	sub	r4,r5
8000acaa:	8f 28       	st.w	r7[0x8],r8
8000acac:	c1 18       	rjmp	8000acce <_fflush_r+0x102>
8000acae:	08 99       	mov	r9,r4
8000acb0:	0a 9a       	mov	r10,r5
8000acb2:	6e a8       	ld.w	r8,r7[0x28]
8000acb4:	6e 8b       	ld.w	r11,r7[0x20]
8000acb6:	0c 9c       	mov	r12,r6
8000acb8:	5d 18       	icall	r8
8000acba:	18 14       	sub	r4,r12
8000acbc:	58 0c       	cp.w	r12,0
8000acbe:	e0 89 00 07 	brgt	8000accc <_fflush_r+0x100>
8000acc2:	8e 68       	ld.sh	r8,r7[0xc]
8000acc4:	a7 a8       	sbr	r8,0x6
8000acc6:	3f fc       	mov	r12,-1
8000acc8:	ae 68       	st.h	r7[0xc],r8
8000acca:	d8 22       	popm	r4-r7,pc
8000accc:	18 05       	add	r5,r12
8000acce:	58 04       	cp.w	r4,0
8000acd0:	fe 99 ff ef 	brgt	8000acae <_fflush_r+0xe2>
8000acd4:	d8 2a       	popm	r4-r7,pc,r12=0
8000acd6:	d7 03       	nop

8000acd8 <__sfp_lock_acquire>:
8000acd8:	5e fc       	retal	r12

8000acda <__sfp_lock_release>:
8000acda:	5e fc       	retal	r12

8000acdc <_cleanup_r>:
8000acdc:	d4 01       	pushm	lr
8000acde:	fe cb f0 ae 	sub	r11,pc,-3922
8000ace2:	e0 a0 02 f7 	rcall	8000b2d0 <_fwalk>
8000ace6:	d8 02       	popm	pc

8000ace8 <__sfmoreglue>:
8000ace8:	d4 21       	pushm	r4-r7,lr
8000acea:	16 95       	mov	r5,r11
8000acec:	f6 06 10 5c 	mul	r6,r11,92
8000acf0:	ec cb ff f4 	sub	r11,r6,-12
8000acf4:	fe b0 e2 88 	rcall	80007204 <_malloc_r>
8000acf8:	18 97       	mov	r7,r12
8000acfa:	c0 90       	breq	8000ad0c <__sfmoreglue+0x24>
8000acfc:	99 15       	st.w	r12[0x4],r5
8000acfe:	30 0b       	mov	r11,0
8000ad00:	2f 4c       	sub	r12,-12
8000ad02:	0c 9a       	mov	r10,r6
8000ad04:	8f 2c       	st.w	r7[0x8],r12
8000ad06:	8f 0b       	st.w	r7[0x0],r11
8000ad08:	fe b0 e5 3e 	rcall	80007784 <memset>
8000ad0c:	0e 9c       	mov	r12,r7
8000ad0e:	d8 22       	popm	r4-r7,pc

8000ad10 <__sfp>:
8000ad10:	d4 21       	pushm	r4-r7,lr
8000ad12:	fe c8 cd be 	sub	r8,pc,-12866
8000ad16:	18 96       	mov	r6,r12
8000ad18:	70 07       	ld.w	r7,r8[0x0]
8000ad1a:	6e 68       	ld.w	r8,r7[0x18]
8000ad1c:	58 08       	cp.w	r8,0
8000ad1e:	c0 31       	brne	8000ad24 <__sfp+0x14>
8000ad20:	0e 9c       	mov	r12,r7
8000ad22:	c2 dc       	rcall	8000ad7c <__sinit>
8000ad24:	ee c7 ff 28 	sub	r7,r7,-216
8000ad28:	30 05       	mov	r5,0
8000ad2a:	6e 2c       	ld.w	r12,r7[0x8]
8000ad2c:	6e 18       	ld.w	r8,r7[0x4]
8000ad2e:	c0 68       	rjmp	8000ad3a <__sfp+0x2a>
8000ad30:	98 69       	ld.sh	r9,r12[0xc]
8000ad32:	ea 09 19 00 	cp.h	r9,r5
8000ad36:	c1 10       	breq	8000ad58 <__sfp+0x48>
8000ad38:	2a 4c       	sub	r12,-92
8000ad3a:	20 18       	sub	r8,1
8000ad3c:	cf a7       	brpl	8000ad30 <__sfp+0x20>
8000ad3e:	6e 08       	ld.w	r8,r7[0x0]
8000ad40:	58 08       	cp.w	r8,0
8000ad42:	c0 61       	brne	8000ad4e <__sfp+0x3e>
8000ad44:	30 4b       	mov	r11,4
8000ad46:	0c 9c       	mov	r12,r6
8000ad48:	cd 0f       	rcall	8000ace8 <__sfmoreglue>
8000ad4a:	8f 0c       	st.w	r7[0x0],r12
8000ad4c:	c0 30       	breq	8000ad52 <__sfp+0x42>
8000ad4e:	6e 07       	ld.w	r7,r7[0x0]
8000ad50:	ce db       	rjmp	8000ad2a <__sfp+0x1a>
8000ad52:	30 c8       	mov	r8,12
8000ad54:	8d 38       	st.w	r6[0xc],r8
8000ad56:	d8 22       	popm	r4-r7,pc
8000ad58:	30 08       	mov	r8,0
8000ad5a:	f9 48 00 4c 	st.w	r12[76],r8
8000ad5e:	99 08       	st.w	r12[0x0],r8
8000ad60:	99 28       	st.w	r12[0x8],r8
8000ad62:	99 18       	st.w	r12[0x4],r8
8000ad64:	99 48       	st.w	r12[0x10],r8
8000ad66:	99 58       	st.w	r12[0x14],r8
8000ad68:	99 68       	st.w	r12[0x18],r8
8000ad6a:	99 d8       	st.w	r12[0x34],r8
8000ad6c:	99 e8       	st.w	r12[0x38],r8
8000ad6e:	f9 48 00 48 	st.w	r12[72],r8
8000ad72:	3f f8       	mov	r8,-1
8000ad74:	b8 78       	st.h	r12[0xe],r8
8000ad76:	30 18       	mov	r8,1
8000ad78:	b8 68       	st.h	r12[0xc],r8
8000ad7a:	d8 22       	popm	r4-r7,pc

8000ad7c <__sinit>:
8000ad7c:	d4 21       	pushm	r4-r7,lr
8000ad7e:	18 96       	mov	r6,r12
8000ad80:	78 67       	ld.w	r7,r12[0x18]
8000ad82:	58 07       	cp.w	r7,0
8000ad84:	c4 91       	brne	8000ae16 <__sinit+0x9a>
8000ad86:	fe c8 00 aa 	sub	r8,pc,170
8000ad8a:	30 15       	mov	r5,1
8000ad8c:	99 a8       	st.w	r12[0x28],r8
8000ad8e:	f9 47 00 d8 	st.w	r12[216],r7
8000ad92:	f9 47 00 dc 	st.w	r12[220],r7
8000ad96:	f9 47 00 e0 	st.w	r12[224],r7
8000ad9a:	99 65       	st.w	r12[0x18],r5
8000ad9c:	cb af       	rcall	8000ad10 <__sfp>
8000ad9e:	8d 0c       	st.w	r6[0x0],r12
8000ada0:	0c 9c       	mov	r12,r6
8000ada2:	cb 7f       	rcall	8000ad10 <__sfp>
8000ada4:	8d 1c       	st.w	r6[0x4],r12
8000ada6:	0c 9c       	mov	r12,r6
8000ada8:	cb 4f       	rcall	8000ad10 <__sfp>
8000adaa:	6c 09       	ld.w	r9,r6[0x0]
8000adac:	30 48       	mov	r8,4
8000adae:	93 07       	st.w	r9[0x0],r7
8000adb0:	b2 68       	st.h	r9[0xc],r8
8000adb2:	93 17       	st.w	r9[0x4],r7
8000adb4:	93 27       	st.w	r9[0x8],r7
8000adb6:	6c 18       	ld.w	r8,r6[0x4]
8000adb8:	b2 77       	st.h	r9[0xe],r7
8000adba:	93 47       	st.w	r9[0x10],r7
8000adbc:	93 57       	st.w	r9[0x14],r7
8000adbe:	93 67       	st.w	r9[0x18],r7
8000adc0:	93 89       	st.w	r9[0x20],r9
8000adc2:	91 07       	st.w	r8[0x0],r7
8000adc4:	91 17       	st.w	r8[0x4],r7
8000adc6:	91 27       	st.w	r8[0x8],r7
8000adc8:	fe ce f3 24 	sub	lr,pc,-3292
8000adcc:	fe cb f3 54 	sub	r11,pc,-3244
8000add0:	93 9e       	st.w	r9[0x24],lr
8000add2:	93 ab       	st.w	r9[0x28],r11
8000add4:	fe ca f3 7c 	sub	r10,pc,-3204
8000add8:	fe c4 f3 88 	sub	r4,pc,-3192
8000addc:	93 ba       	st.w	r9[0x2c],r10
8000adde:	93 c4       	st.w	r9[0x30],r4
8000ade0:	30 99       	mov	r9,9
8000ade2:	b0 69       	st.h	r8[0xc],r9
8000ade4:	b0 75       	st.h	r8[0xe],r5
8000ade6:	91 c4       	st.w	r8[0x30],r4
8000ade8:	91 47       	st.w	r8[0x10],r7
8000adea:	91 57       	st.w	r8[0x14],r7
8000adec:	91 67       	st.w	r8[0x18],r7
8000adee:	91 88       	st.w	r8[0x20],r8
8000adf0:	91 9e       	st.w	r8[0x24],lr
8000adf2:	91 ab       	st.w	r8[0x28],r11
8000adf4:	91 ba       	st.w	r8[0x2c],r10
8000adf6:	8d 2c       	st.w	r6[0x8],r12
8000adf8:	31 28       	mov	r8,18
8000adfa:	99 07       	st.w	r12[0x0],r7
8000adfc:	b8 68       	st.h	r12[0xc],r8
8000adfe:	99 17       	st.w	r12[0x4],r7
8000ae00:	99 27       	st.w	r12[0x8],r7
8000ae02:	30 28       	mov	r8,2
8000ae04:	b8 78       	st.h	r12[0xe],r8
8000ae06:	99 c4       	st.w	r12[0x30],r4
8000ae08:	99 67       	st.w	r12[0x18],r7
8000ae0a:	99 9e       	st.w	r12[0x24],lr
8000ae0c:	99 ab       	st.w	r12[0x28],r11
8000ae0e:	99 ba       	st.w	r12[0x2c],r10
8000ae10:	99 47       	st.w	r12[0x10],r7
8000ae12:	99 57       	st.w	r12[0x14],r7
8000ae14:	99 8c       	st.w	r12[0x20],r12
8000ae16:	d8 22       	popm	r4-r7,pc

8000ae18 <_malloc_trim_r>:
8000ae18:	d4 21       	pushm	r4-r7,lr
8000ae1a:	16 95       	mov	r5,r11
8000ae1c:	18 97       	mov	r7,r12
8000ae1e:	fe b0 d7 ad 	rcall	80005d78 <__malloc_lock>
8000ae22:	e0 64 05 30 	mov	r4,1328
8000ae26:	68 28       	ld.w	r8,r4[0x8]
8000ae28:	70 16       	ld.w	r6,r8[0x4]
8000ae2a:	e0 16 ff fc 	andl	r6,0xfffc
8000ae2e:	ec c8 ff 91 	sub	r8,r6,-111
8000ae32:	f0 05 01 05 	sub	r5,r8,r5
8000ae36:	e0 15 ff 80 	andl	r5,0xff80
8000ae3a:	ea c5 00 80 	sub	r5,r5,128
8000ae3e:	e0 45 00 7f 	cp.w	r5,127
8000ae42:	e0 8a 00 25 	brle	8000ae8c <_malloc_trim_r+0x74>
8000ae46:	30 0b       	mov	r11,0
8000ae48:	0e 9c       	mov	r12,r7
8000ae4a:	fe b0 e6 05 	rcall	80007a54 <_sbrk_r>
8000ae4e:	68 28       	ld.w	r8,r4[0x8]
8000ae50:	0c 08       	add	r8,r6
8000ae52:	10 3c       	cp.w	r12,r8
8000ae54:	c1 c1       	brne	8000ae8c <_malloc_trim_r+0x74>
8000ae56:	ea 0b 11 00 	rsub	r11,r5,0
8000ae5a:	0e 9c       	mov	r12,r7
8000ae5c:	fe b0 e5 fc 	rcall	80007a54 <_sbrk_r>
8000ae60:	5b fc       	cp.w	r12,-1
8000ae62:	c1 91       	brne	8000ae94 <_malloc_trim_r+0x7c>
8000ae64:	30 0b       	mov	r11,0
8000ae66:	0e 9c       	mov	r12,r7
8000ae68:	fe b0 e5 f6 	rcall	80007a54 <_sbrk_r>
8000ae6c:	68 28       	ld.w	r8,r4[0x8]
8000ae6e:	f8 08 01 09 	sub	r9,r12,r8
8000ae72:	58 f9       	cp.w	r9,15
8000ae74:	e0 8a 00 0c 	brle	8000ae8c <_malloc_trim_r+0x74>
8000ae78:	a1 a9       	sbr	r9,0x0
8000ae7a:	91 19       	st.w	r8[0x4],r9
8000ae7c:	e0 68 09 3c 	mov	r8,2364
8000ae80:	70 09       	ld.w	r9,r8[0x0]
8000ae82:	e0 68 0d 50 	mov	r8,3408
8000ae86:	f8 09 01 09 	sub	r9,r12,r9
8000ae8a:	91 09       	st.w	r8[0x0],r9
8000ae8c:	0e 9c       	mov	r12,r7
8000ae8e:	fe b0 d7 7b 	rcall	80005d84 <__malloc_unlock>
8000ae92:	d8 2a       	popm	r4-r7,pc,r12=0
8000ae94:	68 28       	ld.w	r8,r4[0x8]
8000ae96:	0a 16       	sub	r6,r5
8000ae98:	a1 a6       	sbr	r6,0x0
8000ae9a:	91 16       	st.w	r8[0x4],r6
8000ae9c:	e0 68 0d 50 	mov	r8,3408
8000aea0:	70 09       	ld.w	r9,r8[0x0]
8000aea2:	0a 19       	sub	r9,r5
8000aea4:	0e 9c       	mov	r12,r7
8000aea6:	91 09       	st.w	r8[0x0],r9
8000aea8:	fe b0 d7 6e 	rcall	80005d84 <__malloc_unlock>
8000aeac:	da 2a       	popm	r4-r7,pc,r12=1
8000aeae:	d7 03       	nop

8000aeb0 <_free_r>:
8000aeb0:	d4 21       	pushm	r4-r7,lr
8000aeb2:	16 96       	mov	r6,r11
8000aeb4:	18 97       	mov	r7,r12
8000aeb6:	58 0b       	cp.w	r11,0
8000aeb8:	e0 80 00 c0 	breq	8000b038 <_free_r+0x188>
8000aebc:	fe b0 d7 5e 	rcall	80005d78 <__malloc_lock>
8000aec0:	20 86       	sub	r6,8
8000aec2:	e0 6a 05 30 	mov	r10,1328
8000aec6:	6c 18       	ld.w	r8,r6[0x4]
8000aec8:	74 2e       	ld.w	lr,r10[0x8]
8000aeca:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000aece:	a1 c8       	cbr	r8,0x0
8000aed0:	ec 08 00 09 	add	r9,r6,r8
8000aed4:	72 1b       	ld.w	r11,r9[0x4]
8000aed6:	e0 1b ff fc 	andl	r11,0xfffc
8000aeda:	1c 39       	cp.w	r9,lr
8000aedc:	c1 e1       	brne	8000af18 <_free_r+0x68>
8000aede:	f6 08 00 08 	add	r8,r11,r8
8000aee2:	58 0c       	cp.w	r12,0
8000aee4:	c0 81       	brne	8000aef4 <_free_r+0x44>
8000aee6:	6c 09       	ld.w	r9,r6[0x0]
8000aee8:	12 16       	sub	r6,r9
8000aeea:	12 08       	add	r8,r9
8000aeec:	6c 3b       	ld.w	r11,r6[0xc]
8000aeee:	6c 29       	ld.w	r9,r6[0x8]
8000aef0:	97 29       	st.w	r11[0x8],r9
8000aef2:	93 3b       	st.w	r9[0xc],r11
8000aef4:	10 99       	mov	r9,r8
8000aef6:	95 26       	st.w	r10[0x8],r6
8000aef8:	a1 a9       	sbr	r9,0x0
8000aefa:	8d 19       	st.w	r6[0x4],r9
8000aefc:	e0 69 09 38 	mov	r9,2360
8000af00:	72 09       	ld.w	r9,r9[0x0]
8000af02:	12 38       	cp.w	r8,r9
8000af04:	c0 63       	brcs	8000af10 <_free_r+0x60>
8000af06:	e0 68 0d 4c 	mov	r8,3404
8000af0a:	0e 9c       	mov	r12,r7
8000af0c:	70 0b       	ld.w	r11,r8[0x0]
8000af0e:	c8 5f       	rcall	8000ae18 <_malloc_trim_r>
8000af10:	0e 9c       	mov	r12,r7
8000af12:	fe b0 d7 39 	rcall	80005d84 <__malloc_unlock>
8000af16:	d8 22       	popm	r4-r7,pc
8000af18:	93 1b       	st.w	r9[0x4],r11
8000af1a:	58 0c       	cp.w	r12,0
8000af1c:	c0 30       	breq	8000af22 <_free_r+0x72>
8000af1e:	30 0c       	mov	r12,0
8000af20:	c1 08       	rjmp	8000af40 <_free_r+0x90>
8000af22:	6c 0e       	ld.w	lr,r6[0x0]
8000af24:	f4 c5 ff f8 	sub	r5,r10,-8
8000af28:	1c 16       	sub	r6,lr
8000af2a:	1c 08       	add	r8,lr
8000af2c:	6c 2e       	ld.w	lr,r6[0x8]
8000af2e:	0a 3e       	cp.w	lr,r5
8000af30:	f9 bc 00 01 	moveq	r12,1
8000af34:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000af38:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000af3c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000af40:	f2 0b 00 0e 	add	lr,r9,r11
8000af44:	7c 1e       	ld.w	lr,lr[0x4]
8000af46:	ed be 00 00 	bld	lr,0x0
8000af4a:	c1 40       	breq	8000af72 <_free_r+0xc2>
8000af4c:	16 08       	add	r8,r11
8000af4e:	58 0c       	cp.w	r12,0
8000af50:	c0 d1       	brne	8000af6a <_free_r+0xba>
8000af52:	e0 6e 05 30 	mov	lr,1328
8000af56:	72 2b       	ld.w	r11,r9[0x8]
8000af58:	2f 8e       	sub	lr,-8
8000af5a:	1c 3b       	cp.w	r11,lr
8000af5c:	c0 71       	brne	8000af6a <_free_r+0xba>
8000af5e:	97 36       	st.w	r11[0xc],r6
8000af60:	97 26       	st.w	r11[0x8],r6
8000af62:	8d 2b       	st.w	r6[0x8],r11
8000af64:	8d 3b       	st.w	r6[0xc],r11
8000af66:	30 1c       	mov	r12,1
8000af68:	c0 58       	rjmp	8000af72 <_free_r+0xc2>
8000af6a:	72 2b       	ld.w	r11,r9[0x8]
8000af6c:	72 39       	ld.w	r9,r9[0xc]
8000af6e:	93 2b       	st.w	r9[0x8],r11
8000af70:	97 39       	st.w	r11[0xc],r9
8000af72:	10 99       	mov	r9,r8
8000af74:	ec 08 09 08 	st.w	r6[r8],r8
8000af78:	a1 a9       	sbr	r9,0x0
8000af7a:	8d 19       	st.w	r6[0x4],r9
8000af7c:	58 0c       	cp.w	r12,0
8000af7e:	c5 a1       	brne	8000b032 <_free_r+0x182>
8000af80:	e0 48 01 ff 	cp.w	r8,511
8000af84:	e0 8b 00 13 	brhi	8000afaa <_free_r+0xfa>
8000af88:	a3 98       	lsr	r8,0x3
8000af8a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000af8e:	72 2b       	ld.w	r11,r9[0x8]
8000af90:	8d 39       	st.w	r6[0xc],r9
8000af92:	8d 2b       	st.w	r6[0x8],r11
8000af94:	97 36       	st.w	r11[0xc],r6
8000af96:	93 26       	st.w	r9[0x8],r6
8000af98:	a3 48       	asr	r8,0x2
8000af9a:	74 19       	ld.w	r9,r10[0x4]
8000af9c:	30 1b       	mov	r11,1
8000af9e:	f6 08 09 48 	lsl	r8,r11,r8
8000afa2:	f3 e8 10 08 	or	r8,r9,r8
8000afa6:	95 18       	st.w	r10[0x4],r8
8000afa8:	c4 58       	rjmp	8000b032 <_free_r+0x182>
8000afaa:	f0 0b 16 09 	lsr	r11,r8,0x9
8000afae:	58 4b       	cp.w	r11,4
8000afb0:	e0 8b 00 06 	brhi	8000afbc <_free_r+0x10c>
8000afb4:	f0 0b 16 06 	lsr	r11,r8,0x6
8000afb8:	2c 8b       	sub	r11,-56
8000afba:	c2 08       	rjmp	8000affa <_free_r+0x14a>
8000afbc:	59 4b       	cp.w	r11,20
8000afbe:	e0 8b 00 04 	brhi	8000afc6 <_free_r+0x116>
8000afc2:	2a 5b       	sub	r11,-91
8000afc4:	c1 b8       	rjmp	8000affa <_free_r+0x14a>
8000afc6:	e0 4b 00 54 	cp.w	r11,84
8000afca:	e0 8b 00 06 	brhi	8000afd6 <_free_r+0x126>
8000afce:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000afd2:	29 2b       	sub	r11,-110
8000afd4:	c1 38       	rjmp	8000affa <_free_r+0x14a>
8000afd6:	e0 4b 01 54 	cp.w	r11,340
8000afda:	e0 8b 00 06 	brhi	8000afe6 <_free_r+0x136>
8000afde:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000afe2:	28 9b       	sub	r11,-119
8000afe4:	c0 b8       	rjmp	8000affa <_free_r+0x14a>
8000afe6:	e0 4b 05 54 	cp.w	r11,1364
8000afea:	e0 88 00 05 	brls	8000aff4 <_free_r+0x144>
8000afee:	37 eb       	mov	r11,126
8000aff0:	c0 58       	rjmp	8000affa <_free_r+0x14a>
8000aff2:	d7 03       	nop
8000aff4:	f0 0b 16 12 	lsr	r11,r8,0x12
8000aff8:	28 4b       	sub	r11,-124
8000affa:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000affe:	78 29       	ld.w	r9,r12[0x8]
8000b000:	18 39       	cp.w	r9,r12
8000b002:	c0 e1       	brne	8000b01e <_free_r+0x16e>
8000b004:	74 18       	ld.w	r8,r10[0x4]
8000b006:	a3 4b       	asr	r11,0x2
8000b008:	30 1c       	mov	r12,1
8000b00a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b00e:	f1 eb 10 0b 	or	r11,r8,r11
8000b012:	12 98       	mov	r8,r9
8000b014:	95 1b       	st.w	r10[0x4],r11
8000b016:	c0 a8       	rjmp	8000b02a <_free_r+0x17a>
8000b018:	72 29       	ld.w	r9,r9[0x8]
8000b01a:	18 39       	cp.w	r9,r12
8000b01c:	c0 60       	breq	8000b028 <_free_r+0x178>
8000b01e:	72 1a       	ld.w	r10,r9[0x4]
8000b020:	e0 1a ff fc 	andl	r10,0xfffc
8000b024:	14 38       	cp.w	r8,r10
8000b026:	cf 93       	brcs	8000b018 <_free_r+0x168>
8000b028:	72 38       	ld.w	r8,r9[0xc]
8000b02a:	8d 38       	st.w	r6[0xc],r8
8000b02c:	8d 29       	st.w	r6[0x8],r9
8000b02e:	93 36       	st.w	r9[0xc],r6
8000b030:	91 26       	st.w	r8[0x8],r6
8000b032:	0e 9c       	mov	r12,r7
8000b034:	fe b0 d6 a8 	rcall	80005d84 <__malloc_unlock>
8000b038:	d8 22       	popm	r4-r7,pc
8000b03a:	d7 03       	nop

8000b03c <__sfvwrite_r>:
8000b03c:	d4 31       	pushm	r0-r7,lr
8000b03e:	20 3d       	sub	sp,12
8000b040:	14 94       	mov	r4,r10
8000b042:	18 95       	mov	r5,r12
8000b044:	16 97       	mov	r7,r11
8000b046:	74 28       	ld.w	r8,r10[0x8]
8000b048:	58 08       	cp.w	r8,0
8000b04a:	e0 80 01 40 	breq	8000b2ca <__sfvwrite_r+0x28e>
8000b04e:	96 68       	ld.sh	r8,r11[0xc]
8000b050:	ed b8 00 03 	bld	r8,0x3
8000b054:	c0 41       	brne	8000b05c <__sfvwrite_r+0x20>
8000b056:	76 48       	ld.w	r8,r11[0x10]
8000b058:	58 08       	cp.w	r8,0
8000b05a:	c0 c1       	brne	8000b072 <__sfvwrite_r+0x36>
8000b05c:	0e 9b       	mov	r11,r7
8000b05e:	0a 9c       	mov	r12,r5
8000b060:	fe b0 f6 c4 	rcall	80009de8 <__swsetup_r>
8000b064:	c0 70       	breq	8000b072 <__sfvwrite_r+0x36>
8000b066:	8e 68       	ld.sh	r8,r7[0xc]
8000b068:	a7 a8       	sbr	r8,0x6
8000b06a:	ae 68       	st.h	r7[0xc],r8
8000b06c:	30 98       	mov	r8,9
8000b06e:	8b 38       	st.w	r5[0xc],r8
8000b070:	c2 b9       	rjmp	8000b2c6 <__sfvwrite_r+0x28a>
8000b072:	8e 63       	ld.sh	r3,r7[0xc]
8000b074:	68 00       	ld.w	r0,r4[0x0]
8000b076:	06 96       	mov	r6,r3
8000b078:	e2 16 00 02 	andl	r6,0x2,COH
8000b07c:	c2 10       	breq	8000b0be <__sfvwrite_r+0x82>
8000b07e:	30 03       	mov	r3,0
8000b080:	e0 62 04 00 	mov	r2,1024
8000b084:	06 96       	mov	r6,r3
8000b086:	c0 48       	rjmp	8000b08e <__sfvwrite_r+0x52>
8000b088:	60 03       	ld.w	r3,r0[0x0]
8000b08a:	60 16       	ld.w	r6,r0[0x4]
8000b08c:	2f 80       	sub	r0,-8
8000b08e:	58 06       	cp.w	r6,0
8000b090:	cf c0       	breq	8000b088 <__sfvwrite_r+0x4c>
8000b092:	e0 46 04 00 	cp.w	r6,1024
8000b096:	ec 09 17 80 	movls	r9,r6
8000b09a:	e4 09 17 b0 	movhi	r9,r2
8000b09e:	06 9a       	mov	r10,r3
8000b0a0:	6e a8       	ld.w	r8,r7[0x28]
8000b0a2:	6e 8b       	ld.w	r11,r7[0x20]
8000b0a4:	0a 9c       	mov	r12,r5
8000b0a6:	5d 18       	icall	r8
8000b0a8:	18 16       	sub	r6,r12
8000b0aa:	58 0c       	cp.w	r12,0
8000b0ac:	e0 8a 01 0a 	brle	8000b2c0 <__sfvwrite_r+0x284>
8000b0b0:	68 28       	ld.w	r8,r4[0x8]
8000b0b2:	18 18       	sub	r8,r12
8000b0b4:	89 28       	st.w	r4[0x8],r8
8000b0b6:	e0 80 01 0a 	breq	8000b2ca <__sfvwrite_r+0x28e>
8000b0ba:	18 03       	add	r3,r12
8000b0bc:	ce 9b       	rjmp	8000b08e <__sfvwrite_r+0x52>
8000b0be:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b0c2:	c0 70       	breq	8000b0d0 <__sfvwrite_r+0x94>
8000b0c4:	50 06       	stdsp	sp[0x0],r6
8000b0c6:	0c 93       	mov	r3,r6
8000b0c8:	0c 91       	mov	r1,r6
8000b0ca:	50 15       	stdsp	sp[0x4],r5
8000b0cc:	08 92       	mov	r2,r4
8000b0ce:	c9 c8       	rjmp	8000b206 <__sfvwrite_r+0x1ca>
8000b0d0:	06 96       	mov	r6,r3
8000b0d2:	08 91       	mov	r1,r4
8000b0d4:	c0 48       	rjmp	8000b0dc <__sfvwrite_r+0xa0>
8000b0d6:	60 03       	ld.w	r3,r0[0x0]
8000b0d8:	60 16       	ld.w	r6,r0[0x4]
8000b0da:	2f 80       	sub	r0,-8
8000b0dc:	58 06       	cp.w	r6,0
8000b0de:	cf c0       	breq	8000b0d6 <__sfvwrite_r+0x9a>
8000b0e0:	8e 68       	ld.sh	r8,r7[0xc]
8000b0e2:	6e 24       	ld.w	r4,r7[0x8]
8000b0e4:	10 99       	mov	r9,r8
8000b0e6:	e2 19 02 00 	andl	r9,0x200,COH
8000b0ea:	c5 50       	breq	8000b194 <__sfvwrite_r+0x158>
8000b0ec:	08 36       	cp.w	r6,r4
8000b0ee:	c4 43       	brcs	8000b176 <__sfvwrite_r+0x13a>
8000b0f0:	10 99       	mov	r9,r8
8000b0f2:	e2 19 04 80 	andl	r9,0x480,COH
8000b0f6:	c4 00       	breq	8000b176 <__sfvwrite_r+0x13a>
8000b0f8:	6e 4b       	ld.w	r11,r7[0x10]
8000b0fa:	6e 09       	ld.w	r9,r7[0x0]
8000b0fc:	16 19       	sub	r9,r11
8000b0fe:	50 09       	stdsp	sp[0x0],r9
8000b100:	6e 59       	ld.w	r9,r7[0x14]
8000b102:	10 9c       	mov	r12,r8
8000b104:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b108:	30 28       	mov	r8,2
8000b10a:	f4 08 0c 08 	divs	r8,r10,r8
8000b10e:	fa e9 00 04 	st.d	sp[4],r8
8000b112:	10 94       	mov	r4,r8
8000b114:	40 09       	lddsp	r9,sp[0x0]
8000b116:	e2 1c 04 00 	andl	r12,0x400,COH
8000b11a:	2f f9       	sub	r9,-1
8000b11c:	0c 09       	add	r9,r6
8000b11e:	12 38       	cp.w	r8,r9
8000b120:	f2 04 17 30 	movlo	r4,r9
8000b124:	58 0c       	cp.w	r12,0
8000b126:	c1 10       	breq	8000b148 <__sfvwrite_r+0x10c>
8000b128:	08 9b       	mov	r11,r4
8000b12a:	0a 9c       	mov	r12,r5
8000b12c:	fe b0 e0 6c 	rcall	80007204 <_malloc_r>
8000b130:	18 92       	mov	r2,r12
8000b132:	c1 40       	breq	8000b15a <__sfvwrite_r+0x11e>
8000b134:	40 0a       	lddsp	r10,sp[0x0]
8000b136:	6e 4b       	ld.w	r11,r7[0x10]
8000b138:	fe b0 e2 82 	rcall	8000763c <memcpy>
8000b13c:	8e 68       	ld.sh	r8,r7[0xc]
8000b13e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b142:	a7 b8       	sbr	r8,0x7
8000b144:	ae 68       	st.h	r7[0xc],r8
8000b146:	c0 d8       	rjmp	8000b160 <__sfvwrite_r+0x124>
8000b148:	08 9a       	mov	r10,r4
8000b14a:	0a 9c       	mov	r12,r5
8000b14c:	fe b0 e3 24 	rcall	80007794 <_realloc_r>
8000b150:	18 92       	mov	r2,r12
8000b152:	c0 71       	brne	8000b160 <__sfvwrite_r+0x124>
8000b154:	6e 4b       	ld.w	r11,r7[0x10]
8000b156:	0a 9c       	mov	r12,r5
8000b158:	ca ce       	rcall	8000aeb0 <_free_r>
8000b15a:	30 c8       	mov	r8,12
8000b15c:	8b 38       	st.w	r5[0xc],r8
8000b15e:	cb 18       	rjmp	8000b2c0 <__sfvwrite_r+0x284>
8000b160:	40 0a       	lddsp	r10,sp[0x0]
8000b162:	40 09       	lddsp	r9,sp[0x0]
8000b164:	e8 0a 01 0a 	sub	r10,r4,r10
8000b168:	e4 09 00 08 	add	r8,r2,r9
8000b16c:	8f 54       	st.w	r7[0x14],r4
8000b16e:	8f 2a       	st.w	r7[0x8],r10
8000b170:	8f 08       	st.w	r7[0x0],r8
8000b172:	8f 42       	st.w	r7[0x10],r2
8000b174:	0c 94       	mov	r4,r6
8000b176:	08 36       	cp.w	r6,r4
8000b178:	ec 04 17 30 	movlo	r4,r6
8000b17c:	06 9b       	mov	r11,r3
8000b17e:	08 9a       	mov	r10,r4
8000b180:	6e 0c       	ld.w	r12,r7[0x0]
8000b182:	c3 ad       	rcall	8000b3f6 <memmove>
8000b184:	6e 08       	ld.w	r8,r7[0x0]
8000b186:	08 08       	add	r8,r4
8000b188:	8f 08       	st.w	r7[0x0],r8
8000b18a:	6e 28       	ld.w	r8,r7[0x8]
8000b18c:	08 18       	sub	r8,r4
8000b18e:	0c 94       	mov	r4,r6
8000b190:	8f 28       	st.w	r7[0x8],r8
8000b192:	c2 e8       	rjmp	8000b1ee <__sfvwrite_r+0x1b2>
8000b194:	08 36       	cp.w	r6,r4
8000b196:	5f ba       	srhi	r10
8000b198:	6e 0c       	ld.w	r12,r7[0x0]
8000b19a:	6e 48       	ld.w	r8,r7[0x10]
8000b19c:	10 3c       	cp.w	r12,r8
8000b19e:	5f b8       	srhi	r8
8000b1a0:	f5 e8 00 08 	and	r8,r10,r8
8000b1a4:	f2 08 18 00 	cp.b	r8,r9
8000b1a8:	c0 d0       	breq	8000b1c2 <__sfvwrite_r+0x186>
8000b1aa:	06 9b       	mov	r11,r3
8000b1ac:	08 9a       	mov	r10,r4
8000b1ae:	c2 4d       	rcall	8000b3f6 <memmove>
8000b1b0:	6e 08       	ld.w	r8,r7[0x0]
8000b1b2:	08 08       	add	r8,r4
8000b1b4:	0e 9b       	mov	r11,r7
8000b1b6:	8f 08       	st.w	r7[0x0],r8
8000b1b8:	0a 9c       	mov	r12,r5
8000b1ba:	fe b0 fd 09 	rcall	8000abcc <_fflush_r>
8000b1be:	c1 80       	breq	8000b1ee <__sfvwrite_r+0x1b2>
8000b1c0:	c8 08       	rjmp	8000b2c0 <__sfvwrite_r+0x284>
8000b1c2:	6e 59       	ld.w	r9,r7[0x14]
8000b1c4:	12 36       	cp.w	r6,r9
8000b1c6:	c0 a3       	brcs	8000b1da <__sfvwrite_r+0x19e>
8000b1c8:	6e a8       	ld.w	r8,r7[0x28]
8000b1ca:	06 9a       	mov	r10,r3
8000b1cc:	6e 8b       	ld.w	r11,r7[0x20]
8000b1ce:	0a 9c       	mov	r12,r5
8000b1d0:	5d 18       	icall	r8
8000b1d2:	18 94       	mov	r4,r12
8000b1d4:	e0 89 00 0d 	brgt	8000b1ee <__sfvwrite_r+0x1b2>
8000b1d8:	c7 48       	rjmp	8000b2c0 <__sfvwrite_r+0x284>
8000b1da:	0c 9a       	mov	r10,r6
8000b1dc:	06 9b       	mov	r11,r3
8000b1de:	c0 cd       	rcall	8000b3f6 <memmove>
8000b1e0:	6e 08       	ld.w	r8,r7[0x0]
8000b1e2:	0c 08       	add	r8,r6
8000b1e4:	0c 94       	mov	r4,r6
8000b1e6:	8f 08       	st.w	r7[0x0],r8
8000b1e8:	6e 28       	ld.w	r8,r7[0x8]
8000b1ea:	0c 18       	sub	r8,r6
8000b1ec:	8f 28       	st.w	r7[0x8],r8
8000b1ee:	62 28       	ld.w	r8,r1[0x8]
8000b1f0:	08 18       	sub	r8,r4
8000b1f2:	83 28       	st.w	r1[0x8],r8
8000b1f4:	c6 b0       	breq	8000b2ca <__sfvwrite_r+0x28e>
8000b1f6:	08 16       	sub	r6,r4
8000b1f8:	08 03       	add	r3,r4
8000b1fa:	c7 1b       	rjmp	8000b0dc <__sfvwrite_r+0xa0>
8000b1fc:	60 03       	ld.w	r3,r0[0x0]
8000b1fe:	60 11       	ld.w	r1,r0[0x4]
8000b200:	30 08       	mov	r8,0
8000b202:	2f 80       	sub	r0,-8
8000b204:	50 08       	stdsp	sp[0x0],r8
8000b206:	58 01       	cp.w	r1,0
8000b208:	cf a0       	breq	8000b1fc <__sfvwrite_r+0x1c0>
8000b20a:	40 0a       	lddsp	r10,sp[0x0]
8000b20c:	58 0a       	cp.w	r10,0
8000b20e:	c1 41       	brne	8000b236 <__sfvwrite_r+0x1fa>
8000b210:	e2 c6 ff ff 	sub	r6,r1,-1
8000b214:	02 9a       	mov	r10,r1
8000b216:	30 ab       	mov	r11,10
8000b218:	06 9c       	mov	r12,r3
8000b21a:	ce 3c       	rcall	8000b3e0 <memchr>
8000b21c:	f8 c8 ff ff 	sub	r8,r12,-1
8000b220:	58 0c       	cp.w	r12,0
8000b222:	f1 d3 e1 16 	subne	r6,r8,r3
8000b226:	f9 b9 01 01 	movne	r9,1
8000b22a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b22e:	f9 b8 00 01 	moveq	r8,1
8000b232:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b236:	02 36       	cp.w	r6,r1
8000b238:	ec 04 17 80 	movls	r4,r6
8000b23c:	e2 04 17 b0 	movhi	r4,r1
8000b240:	6e 59       	ld.w	r9,r7[0x14]
8000b242:	6e 25       	ld.w	r5,r7[0x8]
8000b244:	f2 05 00 05 	add	r5,r9,r5
8000b248:	0a 34       	cp.w	r4,r5
8000b24a:	5f 9a       	srgt	r10
8000b24c:	6e 0c       	ld.w	r12,r7[0x0]
8000b24e:	6e 48       	ld.w	r8,r7[0x10]
8000b250:	10 3c       	cp.w	r12,r8
8000b252:	5f b8       	srhi	r8
8000b254:	f5 e8 00 08 	and	r8,r10,r8
8000b258:	30 0a       	mov	r10,0
8000b25a:	f4 08 18 00 	cp.b	r8,r10
8000b25e:	c0 d0       	breq	8000b278 <__sfvwrite_r+0x23c>
8000b260:	06 9b       	mov	r11,r3
8000b262:	0a 9a       	mov	r10,r5
8000b264:	cc 9c       	rcall	8000b3f6 <memmove>
8000b266:	6e 08       	ld.w	r8,r7[0x0]
8000b268:	0a 08       	add	r8,r5
8000b26a:	0e 9b       	mov	r11,r7
8000b26c:	8f 08       	st.w	r7[0x0],r8
8000b26e:	40 1c       	lddsp	r12,sp[0x4]
8000b270:	fe b0 fc ae 	rcall	8000abcc <_fflush_r>
8000b274:	c1 70       	breq	8000b2a2 <__sfvwrite_r+0x266>
8000b276:	c2 58       	rjmp	8000b2c0 <__sfvwrite_r+0x284>
8000b278:	12 34       	cp.w	r4,r9
8000b27a:	c0 a5       	brlt	8000b28e <__sfvwrite_r+0x252>
8000b27c:	6e a8       	ld.w	r8,r7[0x28]
8000b27e:	06 9a       	mov	r10,r3
8000b280:	6e 8b       	ld.w	r11,r7[0x20]
8000b282:	40 1c       	lddsp	r12,sp[0x4]
8000b284:	5d 18       	icall	r8
8000b286:	18 95       	mov	r5,r12
8000b288:	e0 89 00 0d 	brgt	8000b2a2 <__sfvwrite_r+0x266>
8000b28c:	c1 a8       	rjmp	8000b2c0 <__sfvwrite_r+0x284>
8000b28e:	08 9a       	mov	r10,r4
8000b290:	06 9b       	mov	r11,r3
8000b292:	cb 2c       	rcall	8000b3f6 <memmove>
8000b294:	6e 08       	ld.w	r8,r7[0x0]
8000b296:	08 08       	add	r8,r4
8000b298:	08 95       	mov	r5,r4
8000b29a:	8f 08       	st.w	r7[0x0],r8
8000b29c:	6e 28       	ld.w	r8,r7[0x8]
8000b29e:	08 18       	sub	r8,r4
8000b2a0:	8f 28       	st.w	r7[0x8],r8
8000b2a2:	0a 16       	sub	r6,r5
8000b2a4:	c0 71       	brne	8000b2b2 <__sfvwrite_r+0x276>
8000b2a6:	0e 9b       	mov	r11,r7
8000b2a8:	40 1c       	lddsp	r12,sp[0x4]
8000b2aa:	fe b0 fc 91 	rcall	8000abcc <_fflush_r>
8000b2ae:	c0 91       	brne	8000b2c0 <__sfvwrite_r+0x284>
8000b2b0:	50 06       	stdsp	sp[0x0],r6
8000b2b2:	64 28       	ld.w	r8,r2[0x8]
8000b2b4:	0a 18       	sub	r8,r5
8000b2b6:	85 28       	st.w	r2[0x8],r8
8000b2b8:	c0 90       	breq	8000b2ca <__sfvwrite_r+0x28e>
8000b2ba:	0a 11       	sub	r1,r5
8000b2bc:	0a 03       	add	r3,r5
8000b2be:	ca 4b       	rjmp	8000b206 <__sfvwrite_r+0x1ca>
8000b2c0:	8e 68       	ld.sh	r8,r7[0xc]
8000b2c2:	a7 a8       	sbr	r8,0x6
8000b2c4:	ae 68       	st.h	r7[0xc],r8
8000b2c6:	3f fc       	mov	r12,-1
8000b2c8:	c0 28       	rjmp	8000b2cc <__sfvwrite_r+0x290>
8000b2ca:	30 0c       	mov	r12,0
8000b2cc:	2f dd       	sub	sp,-12
8000b2ce:	d8 32       	popm	r0-r7,pc

8000b2d0 <_fwalk>:
8000b2d0:	d4 31       	pushm	r0-r7,lr
8000b2d2:	30 05       	mov	r5,0
8000b2d4:	16 91       	mov	r1,r11
8000b2d6:	f8 c7 ff 28 	sub	r7,r12,-216
8000b2da:	0a 92       	mov	r2,r5
8000b2dc:	fe b0 fc fe 	rcall	8000acd8 <__sfp_lock_acquire>
8000b2e0:	3f f3       	mov	r3,-1
8000b2e2:	c1 68       	rjmp	8000b30e <_fwalk+0x3e>
8000b2e4:	6e 26       	ld.w	r6,r7[0x8]
8000b2e6:	6e 14       	ld.w	r4,r7[0x4]
8000b2e8:	2f 46       	sub	r6,-12
8000b2ea:	c0 c8       	rjmp	8000b302 <_fwalk+0x32>
8000b2ec:	8c 08       	ld.sh	r8,r6[0x0]
8000b2ee:	e4 08 19 00 	cp.h	r8,r2
8000b2f2:	c0 70       	breq	8000b300 <_fwalk+0x30>
8000b2f4:	8c 18       	ld.sh	r8,r6[0x2]
8000b2f6:	e6 08 19 00 	cp.h	r8,r3
8000b2fa:	c0 30       	breq	8000b300 <_fwalk+0x30>
8000b2fc:	5d 11       	icall	r1
8000b2fe:	18 45       	or	r5,r12
8000b300:	2a 46       	sub	r6,-92
8000b302:	20 14       	sub	r4,1
8000b304:	ec cc 00 0c 	sub	r12,r6,12
8000b308:	58 04       	cp.w	r4,0
8000b30a:	cf 14       	brge	8000b2ec <_fwalk+0x1c>
8000b30c:	6e 07       	ld.w	r7,r7[0x0]
8000b30e:	58 07       	cp.w	r7,0
8000b310:	ce a1       	brne	8000b2e4 <_fwalk+0x14>
8000b312:	fe b0 fc e4 	rcall	8000acda <__sfp_lock_release>
8000b316:	0a 9c       	mov	r12,r5
8000b318:	d8 32       	popm	r0-r7,pc
8000b31a:	d7 03       	nop

8000b31c <_localeconv_r>:
8000b31c:	fe cc d3 c4 	sub	r12,pc,-11324
8000b320:	5e fc       	retal	r12
8000b322:	d7 03       	nop

8000b324 <__smakebuf_r>:
8000b324:	d4 21       	pushm	r4-r7,lr
8000b326:	20 fd       	sub	sp,60
8000b328:	96 68       	ld.sh	r8,r11[0xc]
8000b32a:	16 97       	mov	r7,r11
8000b32c:	18 96       	mov	r6,r12
8000b32e:	e2 18 00 02 	andl	r8,0x2,COH
8000b332:	c3 d1       	brne	8000b3ac <__smakebuf_r+0x88>
8000b334:	96 7b       	ld.sh	r11,r11[0xe]
8000b336:	f0 0b 19 00 	cp.h	r11,r8
8000b33a:	c0 55       	brlt	8000b344 <__smakebuf_r+0x20>
8000b33c:	1a 9a       	mov	r10,sp
8000b33e:	e0 a0 04 81 	rcall	8000bc40 <_fstat_r>
8000b342:	c0 f4       	brge	8000b360 <__smakebuf_r+0x3c>
8000b344:	8e 65       	ld.sh	r5,r7[0xc]
8000b346:	0a 98       	mov	r8,r5
8000b348:	ab b8       	sbr	r8,0xb
8000b34a:	e2 15 00 80 	andl	r5,0x80,COH
8000b34e:	ae 68       	st.h	r7[0xc],r8
8000b350:	30 04       	mov	r4,0
8000b352:	e0 68 04 00 	mov	r8,1024
8000b356:	f9 b5 01 40 	movne	r5,64
8000b35a:	f0 05 17 00 	moveq	r5,r8
8000b35e:	c1 c8       	rjmp	8000b396 <__smakebuf_r+0x72>
8000b360:	40 18       	lddsp	r8,sp[0x4]
8000b362:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b366:	e0 48 20 00 	cp.w	r8,8192
8000b36a:	5f 04       	sreq	r4
8000b36c:	e0 48 80 00 	cp.w	r8,32768
8000b370:	c0 e1       	brne	8000b38c <__smakebuf_r+0x68>
8000b372:	6e b9       	ld.w	r9,r7[0x2c]
8000b374:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b378:	10 39       	cp.w	r9,r8
8000b37a:	c0 91       	brne	8000b38c <__smakebuf_r+0x68>
8000b37c:	8e 68       	ld.sh	r8,r7[0xc]
8000b37e:	e0 65 04 00 	mov	r5,1024
8000b382:	ab a8       	sbr	r8,0xa
8000b384:	ef 45 00 50 	st.w	r7[80],r5
8000b388:	ae 68       	st.h	r7[0xc],r8
8000b38a:	c0 68       	rjmp	8000b396 <__smakebuf_r+0x72>
8000b38c:	8e 68       	ld.sh	r8,r7[0xc]
8000b38e:	e0 65 04 00 	mov	r5,1024
8000b392:	ab b8       	sbr	r8,0xb
8000b394:	ae 68       	st.h	r7[0xc],r8
8000b396:	0a 9b       	mov	r11,r5
8000b398:	0c 9c       	mov	r12,r6
8000b39a:	fe b0 df 35 	rcall	80007204 <_malloc_r>
8000b39e:	8e 68       	ld.sh	r8,r7[0xc]
8000b3a0:	c0 d1       	brne	8000b3ba <__smakebuf_r+0x96>
8000b3a2:	ed b8 00 09 	bld	r8,0x9
8000b3a6:	c1 b0       	breq	8000b3dc <__smakebuf_r+0xb8>
8000b3a8:	a1 b8       	sbr	r8,0x1
8000b3aa:	ae 68       	st.h	r7[0xc],r8
8000b3ac:	ee c8 ff b9 	sub	r8,r7,-71
8000b3b0:	8f 48       	st.w	r7[0x10],r8
8000b3b2:	8f 08       	st.w	r7[0x0],r8
8000b3b4:	30 18       	mov	r8,1
8000b3b6:	8f 58       	st.w	r7[0x14],r8
8000b3b8:	c1 28       	rjmp	8000b3dc <__smakebuf_r+0xb8>
8000b3ba:	a7 b8       	sbr	r8,0x7
8000b3bc:	8f 4c       	st.w	r7[0x10],r12
8000b3be:	ae 68       	st.h	r7[0xc],r8
8000b3c0:	8f 55       	st.w	r7[0x14],r5
8000b3c2:	fe c8 06 e6 	sub	r8,pc,1766
8000b3c6:	8f 0c       	st.w	r7[0x0],r12
8000b3c8:	8d a8       	st.w	r6[0x28],r8
8000b3ca:	58 04       	cp.w	r4,0
8000b3cc:	c0 80       	breq	8000b3dc <__smakebuf_r+0xb8>
8000b3ce:	8e 7c       	ld.sh	r12,r7[0xe]
8000b3d0:	fe b0 e3 94 	rcall	80007af8 <isatty>
8000b3d4:	c0 40       	breq	8000b3dc <__smakebuf_r+0xb8>
8000b3d6:	8e 68       	ld.sh	r8,r7[0xc]
8000b3d8:	a1 a8       	sbr	r8,0x0
8000b3da:	ae 68       	st.h	r7[0xc],r8
8000b3dc:	2f 1d       	sub	sp,-60
8000b3de:	d8 22       	popm	r4-r7,pc

8000b3e0 <memchr>:
8000b3e0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b3e4:	c0 68       	rjmp	8000b3f0 <memchr+0x10>
8000b3e6:	20 1a       	sub	r10,1
8000b3e8:	19 88       	ld.ub	r8,r12[0x0]
8000b3ea:	16 38       	cp.w	r8,r11
8000b3ec:	5e 0c       	reteq	r12
8000b3ee:	2f fc       	sub	r12,-1
8000b3f0:	58 0a       	cp.w	r10,0
8000b3f2:	cf a1       	brne	8000b3e6 <memchr+0x6>
8000b3f4:	5e fa       	retal	r10

8000b3f6 <memmove>:
8000b3f6:	d4 01       	pushm	lr
8000b3f8:	18 3b       	cp.w	r11,r12
8000b3fa:	c1 92       	brcc	8000b42c <memmove+0x36>
8000b3fc:	f6 0a 00 09 	add	r9,r11,r10
8000b400:	12 3c       	cp.w	r12,r9
8000b402:	c1 52       	brcc	8000b42c <memmove+0x36>
8000b404:	f8 0a 00 0b 	add	r11,r12,r10
8000b408:	30 08       	mov	r8,0
8000b40a:	c0 68       	rjmp	8000b416 <memmove+0x20>
8000b40c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b410:	20 1a       	sub	r10,1
8000b412:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b416:	20 18       	sub	r8,1
8000b418:	58 0a       	cp.w	r10,0
8000b41a:	cf 91       	brne	8000b40c <memmove+0x16>
8000b41c:	d8 02       	popm	pc
8000b41e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b422:	20 1a       	sub	r10,1
8000b424:	f8 08 0b 09 	st.b	r12[r8],r9
8000b428:	2f f8       	sub	r8,-1
8000b42a:	c0 28       	rjmp	8000b42e <memmove+0x38>
8000b42c:	30 08       	mov	r8,0
8000b42e:	58 0a       	cp.w	r10,0
8000b430:	cf 71       	brne	8000b41e <memmove+0x28>
8000b432:	d8 02       	popm	pc

8000b434 <__hi0bits>:
8000b434:	18 98       	mov	r8,r12
8000b436:	e0 1c 00 00 	andl	r12,0x0
8000b43a:	f0 09 15 10 	lsl	r9,r8,0x10
8000b43e:	58 0c       	cp.w	r12,0
8000b440:	f2 08 17 00 	moveq	r8,r9
8000b444:	f9 bc 00 10 	moveq	r12,16
8000b448:	f9 bc 01 00 	movne	r12,0
8000b44c:	10 9a       	mov	r10,r8
8000b44e:	f0 09 15 08 	lsl	r9,r8,0x8
8000b452:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b456:	f7 bc 00 f8 	subeq	r12,-8
8000b45a:	f2 08 17 00 	moveq	r8,r9
8000b45e:	10 9a       	mov	r10,r8
8000b460:	f0 09 15 04 	lsl	r9,r8,0x4
8000b464:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b468:	f7 bc 00 fc 	subeq	r12,-4
8000b46c:	f2 08 17 00 	moveq	r8,r9
8000b470:	10 9a       	mov	r10,r8
8000b472:	f0 09 15 02 	lsl	r9,r8,0x2
8000b476:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b47a:	f7 bc 00 fe 	subeq	r12,-2
8000b47e:	f2 08 17 00 	moveq	r8,r9
8000b482:	58 08       	cp.w	r8,0
8000b484:	5e 5c       	retlt	r12
8000b486:	ed b8 00 1e 	bld	r8,0x1e
8000b48a:	f9 bc 01 20 	movne	r12,32
8000b48e:	f7 bc 00 ff 	subeq	r12,-1
8000b492:	5e fc       	retal	r12

8000b494 <__lo0bits>:
8000b494:	18 99       	mov	r9,r12
8000b496:	78 08       	ld.w	r8,r12[0x0]
8000b498:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b49c:	c1 50       	breq	8000b4c6 <__lo0bits+0x32>
8000b49e:	ed b8 00 00 	bld	r8,0x0
8000b4a2:	c0 21       	brne	8000b4a6 <__lo0bits+0x12>
8000b4a4:	5e fd       	retal	0
8000b4a6:	10 9b       	mov	r11,r8
8000b4a8:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b4ac:	e2 1b 00 02 	andl	r11,0x2,COH
8000b4b0:	a3 88       	lsr	r8,0x2
8000b4b2:	58 0b       	cp.w	r11,0
8000b4b4:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b4b8:	f9 bc 01 01 	movne	r12,1
8000b4bc:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b4c0:	f9 bc 00 02 	moveq	r12,2
8000b4c4:	5e fc       	retal	r12
8000b4c6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b4ca:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b4ce:	58 0a       	cp.w	r10,0
8000b4d0:	f6 08 17 00 	moveq	r8,r11
8000b4d4:	f9 bc 00 10 	moveq	r12,16
8000b4d8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b4dc:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b4e0:	58 0b       	cp.w	r11,0
8000b4e2:	f7 bc 00 f8 	subeq	r12,-8
8000b4e6:	f4 08 17 00 	moveq	r8,r10
8000b4ea:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b4ee:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b4f2:	58 0b       	cp.w	r11,0
8000b4f4:	f7 bc 00 fc 	subeq	r12,-4
8000b4f8:	f4 08 17 00 	moveq	r8,r10
8000b4fc:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b500:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b504:	58 0b       	cp.w	r11,0
8000b506:	f7 bc 00 fe 	subeq	r12,-2
8000b50a:	f4 08 17 00 	moveq	r8,r10
8000b50e:	ed b8 00 00 	bld	r8,0x0
8000b512:	c0 60       	breq	8000b51e <__lo0bits+0x8a>
8000b514:	a1 98       	lsr	r8,0x1
8000b516:	c0 31       	brne	8000b51c <__lo0bits+0x88>
8000b518:	32 0c       	mov	r12,32
8000b51a:	5e fc       	retal	r12
8000b51c:	2f fc       	sub	r12,-1
8000b51e:	93 08       	st.w	r9[0x0],r8
8000b520:	5e fc       	retal	r12

8000b522 <__mcmp>:
8000b522:	d4 01       	pushm	lr
8000b524:	18 98       	mov	r8,r12
8000b526:	76 49       	ld.w	r9,r11[0x10]
8000b528:	78 4c       	ld.w	r12,r12[0x10]
8000b52a:	12 1c       	sub	r12,r9
8000b52c:	c1 31       	brne	8000b552 <__mcmp+0x30>
8000b52e:	2f b9       	sub	r9,-5
8000b530:	a3 69       	lsl	r9,0x2
8000b532:	12 0b       	add	r11,r9
8000b534:	f0 09 00 09 	add	r9,r8,r9
8000b538:	2e c8       	sub	r8,-20
8000b53a:	13 4e       	ld.w	lr,--r9
8000b53c:	17 4a       	ld.w	r10,--r11
8000b53e:	14 3e       	cp.w	lr,r10
8000b540:	c0 60       	breq	8000b54c <__mcmp+0x2a>
8000b542:	f9 bc 03 ff 	movlo	r12,-1
8000b546:	f9 bc 02 01 	movhs	r12,1
8000b54a:	d8 02       	popm	pc
8000b54c:	10 39       	cp.w	r9,r8
8000b54e:	fe 9b ff f6 	brhi	8000b53a <__mcmp+0x18>
8000b552:	d8 02       	popm	pc

8000b554 <_Bfree>:
8000b554:	d4 21       	pushm	r4-r7,lr
8000b556:	18 97       	mov	r7,r12
8000b558:	16 95       	mov	r5,r11
8000b55a:	78 96       	ld.w	r6,r12[0x24]
8000b55c:	58 06       	cp.w	r6,0
8000b55e:	c0 91       	brne	8000b570 <_Bfree+0x1c>
8000b560:	31 0c       	mov	r12,16
8000b562:	fe b0 de 49 	rcall	800071f4 <malloc>
8000b566:	99 36       	st.w	r12[0xc],r6
8000b568:	8f 9c       	st.w	r7[0x24],r12
8000b56a:	99 16       	st.w	r12[0x4],r6
8000b56c:	99 26       	st.w	r12[0x8],r6
8000b56e:	99 06       	st.w	r12[0x0],r6
8000b570:	58 05       	cp.w	r5,0
8000b572:	c0 90       	breq	8000b584 <_Bfree+0x30>
8000b574:	6a 19       	ld.w	r9,r5[0x4]
8000b576:	6e 98       	ld.w	r8,r7[0x24]
8000b578:	70 38       	ld.w	r8,r8[0xc]
8000b57a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b57e:	8b 0a       	st.w	r5[0x0],r10
8000b580:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b584:	d8 22       	popm	r4-r7,pc
8000b586:	d7 03       	nop

8000b588 <_Balloc>:
8000b588:	d4 21       	pushm	r4-r7,lr
8000b58a:	18 97       	mov	r7,r12
8000b58c:	16 96       	mov	r6,r11
8000b58e:	78 95       	ld.w	r5,r12[0x24]
8000b590:	58 05       	cp.w	r5,0
8000b592:	c0 91       	brne	8000b5a4 <_Balloc+0x1c>
8000b594:	31 0c       	mov	r12,16
8000b596:	fe b0 de 2f 	rcall	800071f4 <malloc>
8000b59a:	99 35       	st.w	r12[0xc],r5
8000b59c:	8f 9c       	st.w	r7[0x24],r12
8000b59e:	99 15       	st.w	r12[0x4],r5
8000b5a0:	99 25       	st.w	r12[0x8],r5
8000b5a2:	99 05       	st.w	r12[0x0],r5
8000b5a4:	6e 95       	ld.w	r5,r7[0x24]
8000b5a6:	6a 38       	ld.w	r8,r5[0xc]
8000b5a8:	58 08       	cp.w	r8,0
8000b5aa:	c0 b1       	brne	8000b5c0 <_Balloc+0x38>
8000b5ac:	31 0a       	mov	r10,16
8000b5ae:	30 4b       	mov	r11,4
8000b5b0:	0e 9c       	mov	r12,r7
8000b5b2:	e0 a0 02 a7 	rcall	8000bb00 <_calloc_r>
8000b5b6:	8b 3c       	st.w	r5[0xc],r12
8000b5b8:	6e 98       	ld.w	r8,r7[0x24]
8000b5ba:	70 3c       	ld.w	r12,r8[0xc]
8000b5bc:	58 0c       	cp.w	r12,0
8000b5be:	c1 b0       	breq	8000b5f4 <_Balloc+0x6c>
8000b5c0:	6e 98       	ld.w	r8,r7[0x24]
8000b5c2:	70 38       	ld.w	r8,r8[0xc]
8000b5c4:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b5c8:	70 0c       	ld.w	r12,r8[0x0]
8000b5ca:	58 0c       	cp.w	r12,0
8000b5cc:	c0 40       	breq	8000b5d4 <_Balloc+0x4c>
8000b5ce:	78 09       	ld.w	r9,r12[0x0]
8000b5d0:	91 09       	st.w	r8[0x0],r9
8000b5d2:	c0 e8       	rjmp	8000b5ee <_Balloc+0x66>
8000b5d4:	0e 9c       	mov	r12,r7
8000b5d6:	30 17       	mov	r7,1
8000b5d8:	0e 9b       	mov	r11,r7
8000b5da:	ee 06 09 47 	lsl	r7,r7,r6
8000b5de:	ee ca ff fb 	sub	r10,r7,-5
8000b5e2:	a3 6a       	lsl	r10,0x2
8000b5e4:	e0 a0 02 8e 	rcall	8000bb00 <_calloc_r>
8000b5e8:	c0 60       	breq	8000b5f4 <_Balloc+0x6c>
8000b5ea:	99 16       	st.w	r12[0x4],r6
8000b5ec:	99 27       	st.w	r12[0x8],r7
8000b5ee:	30 08       	mov	r8,0
8000b5f0:	99 38       	st.w	r12[0xc],r8
8000b5f2:	99 48       	st.w	r12[0x10],r8
8000b5f4:	d8 22       	popm	r4-r7,pc
8000b5f6:	d7 03       	nop

8000b5f8 <__d2b>:
8000b5f8:	d4 31       	pushm	r0-r7,lr
8000b5fa:	20 2d       	sub	sp,8
8000b5fc:	16 93       	mov	r3,r11
8000b5fe:	12 96       	mov	r6,r9
8000b600:	10 95       	mov	r5,r8
8000b602:	14 92       	mov	r2,r10
8000b604:	30 1b       	mov	r11,1
8000b606:	cc 1f       	rcall	8000b588 <_Balloc>
8000b608:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b60c:	50 09       	stdsp	sp[0x0],r9
8000b60e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b612:	b5 a9       	sbr	r9,0x14
8000b614:	f0 01 16 14 	lsr	r1,r8,0x14
8000b618:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b61c:	18 94       	mov	r4,r12
8000b61e:	58 02       	cp.w	r2,0
8000b620:	c1 d0       	breq	8000b65a <__d2b+0x62>
8000b622:	fa cc ff f8 	sub	r12,sp,-8
8000b626:	18 d2       	st.w	--r12,r2
8000b628:	c3 6f       	rcall	8000b494 <__lo0bits>
8000b62a:	40 18       	lddsp	r8,sp[0x4]
8000b62c:	c0 d0       	breq	8000b646 <__d2b+0x4e>
8000b62e:	40 09       	lddsp	r9,sp[0x0]
8000b630:	f8 0a 11 20 	rsub	r10,r12,32
8000b634:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b638:	f5 e8 10 08 	or	r8,r10,r8
8000b63c:	89 58       	st.w	r4[0x14],r8
8000b63e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b642:	50 09       	stdsp	sp[0x0],r9
8000b644:	c0 28       	rjmp	8000b648 <__d2b+0x50>
8000b646:	89 58       	st.w	r4[0x14],r8
8000b648:	40 08       	lddsp	r8,sp[0x0]
8000b64a:	58 08       	cp.w	r8,0
8000b64c:	f9 b3 01 02 	movne	r3,2
8000b650:	f9 b3 00 01 	moveq	r3,1
8000b654:	89 68       	st.w	r4[0x18],r8
8000b656:	89 43       	st.w	r4[0x10],r3
8000b658:	c0 88       	rjmp	8000b668 <__d2b+0x70>
8000b65a:	1a 9c       	mov	r12,sp
8000b65c:	c1 cf       	rcall	8000b494 <__lo0bits>
8000b65e:	30 13       	mov	r3,1
8000b660:	40 08       	lddsp	r8,sp[0x0]
8000b662:	2e 0c       	sub	r12,-32
8000b664:	89 43       	st.w	r4[0x10],r3
8000b666:	89 58       	st.w	r4[0x14],r8
8000b668:	58 01       	cp.w	r1,0
8000b66a:	c0 90       	breq	8000b67c <__d2b+0x84>
8000b66c:	e2 c1 04 33 	sub	r1,r1,1075
8000b670:	18 01       	add	r1,r12
8000b672:	8d 01       	st.w	r6[0x0],r1
8000b674:	f8 0c 11 35 	rsub	r12,r12,53
8000b678:	8b 0c       	st.w	r5[0x0],r12
8000b67a:	c0 c8       	rjmp	8000b692 <__d2b+0x9a>
8000b67c:	e6 c8 ff fc 	sub	r8,r3,-4
8000b680:	f8 cc 04 32 	sub	r12,r12,1074
8000b684:	a5 73       	lsl	r3,0x5
8000b686:	8d 0c       	st.w	r6[0x0],r12
8000b688:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b68c:	cd 4e       	rcall	8000b434 <__hi0bits>
8000b68e:	18 13       	sub	r3,r12
8000b690:	8b 03       	st.w	r5[0x0],r3
8000b692:	08 9c       	mov	r12,r4
8000b694:	2f ed       	sub	sp,-8
8000b696:	d8 32       	popm	r0-r7,pc

8000b698 <__mdiff>:
8000b698:	d4 31       	pushm	r0-r7,lr
8000b69a:	74 48       	ld.w	r8,r10[0x10]
8000b69c:	76 45       	ld.w	r5,r11[0x10]
8000b69e:	16 97       	mov	r7,r11
8000b6a0:	14 96       	mov	r6,r10
8000b6a2:	10 15       	sub	r5,r8
8000b6a4:	c1 31       	brne	8000b6ca <__mdiff+0x32>
8000b6a6:	2f b8       	sub	r8,-5
8000b6a8:	ee ce ff ec 	sub	lr,r7,-20
8000b6ac:	a3 68       	lsl	r8,0x2
8000b6ae:	f4 08 00 0b 	add	r11,r10,r8
8000b6b2:	ee 08 00 08 	add	r8,r7,r8
8000b6b6:	11 4a       	ld.w	r10,--r8
8000b6b8:	17 49       	ld.w	r9,--r11
8000b6ba:	12 3a       	cp.w	r10,r9
8000b6bc:	c0 30       	breq	8000b6c2 <__mdiff+0x2a>
8000b6be:	c0 e2       	brcc	8000b6da <__mdiff+0x42>
8000b6c0:	c0 78       	rjmp	8000b6ce <__mdiff+0x36>
8000b6c2:	1c 38       	cp.w	r8,lr
8000b6c4:	fe 9b ff f9 	brhi	8000b6b6 <__mdiff+0x1e>
8000b6c8:	c4 98       	rjmp	8000b75a <__mdiff+0xc2>
8000b6ca:	58 05       	cp.w	r5,0
8000b6cc:	c0 64       	brge	8000b6d8 <__mdiff+0x40>
8000b6ce:	0e 98       	mov	r8,r7
8000b6d0:	30 15       	mov	r5,1
8000b6d2:	0c 97       	mov	r7,r6
8000b6d4:	10 96       	mov	r6,r8
8000b6d6:	c0 28       	rjmp	8000b6da <__mdiff+0x42>
8000b6d8:	30 05       	mov	r5,0
8000b6da:	6e 1b       	ld.w	r11,r7[0x4]
8000b6dc:	c5 6f       	rcall	8000b588 <_Balloc>
8000b6de:	6e 49       	ld.w	r9,r7[0x10]
8000b6e0:	6c 44       	ld.w	r4,r6[0x10]
8000b6e2:	99 35       	st.w	r12[0xc],r5
8000b6e4:	2f b4       	sub	r4,-5
8000b6e6:	f2 c5 ff fb 	sub	r5,r9,-5
8000b6ea:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b6ee:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b6f2:	2e c6       	sub	r6,-20
8000b6f4:	2e c7       	sub	r7,-20
8000b6f6:	f8 c8 ff ec 	sub	r8,r12,-20
8000b6fa:	30 0a       	mov	r10,0
8000b6fc:	0f 0e       	ld.w	lr,r7++
8000b6fe:	0d 0b       	ld.w	r11,r6++
8000b700:	fc 02 16 10 	lsr	r2,lr,0x10
8000b704:	f6 03 16 10 	lsr	r3,r11,0x10
8000b708:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b70c:	e4 03 01 03 	sub	r3,r2,r3
8000b710:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b714:	fc 0b 01 0b 	sub	r11,lr,r11
8000b718:	f6 0a 00 0a 	add	r10,r11,r10
8000b71c:	b0 1a       	st.h	r8[0x2],r10
8000b71e:	b1 4a       	asr	r10,0x10
8000b720:	e6 0a 00 0a 	add	r10,r3,r10
8000b724:	b0 0a       	st.h	r8[0x0],r10
8000b726:	2f c8       	sub	r8,-4
8000b728:	b1 4a       	asr	r10,0x10
8000b72a:	08 36       	cp.w	r6,r4
8000b72c:	ce 83       	brcs	8000b6fc <__mdiff+0x64>
8000b72e:	c0 d8       	rjmp	8000b748 <__mdiff+0xb0>
8000b730:	0f 0b       	ld.w	r11,r7++
8000b732:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b736:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b73a:	16 0a       	add	r10,r11
8000b73c:	b0 1a       	st.h	r8[0x2],r10
8000b73e:	b1 4a       	asr	r10,0x10
8000b740:	1c 0a       	add	r10,lr
8000b742:	b0 0a       	st.h	r8[0x0],r10
8000b744:	2f c8       	sub	r8,-4
8000b746:	b1 4a       	asr	r10,0x10
8000b748:	0a 37       	cp.w	r7,r5
8000b74a:	cf 33       	brcs	8000b730 <__mdiff+0x98>
8000b74c:	c0 28       	rjmp	8000b750 <__mdiff+0xb8>
8000b74e:	20 19       	sub	r9,1
8000b750:	11 4a       	ld.w	r10,--r8
8000b752:	58 0a       	cp.w	r10,0
8000b754:	cf d0       	breq	8000b74e <__mdiff+0xb6>
8000b756:	99 49       	st.w	r12[0x10],r9
8000b758:	d8 32       	popm	r0-r7,pc
8000b75a:	30 0b       	mov	r11,0
8000b75c:	c1 6f       	rcall	8000b588 <_Balloc>
8000b75e:	30 18       	mov	r8,1
8000b760:	99 48       	st.w	r12[0x10],r8
8000b762:	30 08       	mov	r8,0
8000b764:	99 58       	st.w	r12[0x14],r8
8000b766:	d8 32       	popm	r0-r7,pc

8000b768 <__lshift>:
8000b768:	d4 31       	pushm	r0-r7,lr
8000b76a:	16 97       	mov	r7,r11
8000b76c:	76 46       	ld.w	r6,r11[0x10]
8000b76e:	f4 02 14 05 	asr	r2,r10,0x5
8000b772:	2f f6       	sub	r6,-1
8000b774:	14 93       	mov	r3,r10
8000b776:	18 94       	mov	r4,r12
8000b778:	04 06       	add	r6,r2
8000b77a:	76 1b       	ld.w	r11,r11[0x4]
8000b77c:	6e 28       	ld.w	r8,r7[0x8]
8000b77e:	c0 38       	rjmp	8000b784 <__lshift+0x1c>
8000b780:	2f fb       	sub	r11,-1
8000b782:	a1 78       	lsl	r8,0x1
8000b784:	10 36       	cp.w	r6,r8
8000b786:	fe 99 ff fd 	brgt	8000b780 <__lshift+0x18>
8000b78a:	08 9c       	mov	r12,r4
8000b78c:	cf ee       	rcall	8000b588 <_Balloc>
8000b78e:	30 09       	mov	r9,0
8000b790:	18 95       	mov	r5,r12
8000b792:	f8 c8 ff ec 	sub	r8,r12,-20
8000b796:	12 9a       	mov	r10,r9
8000b798:	c0 38       	rjmp	8000b79e <__lshift+0x36>
8000b79a:	10 aa       	st.w	r8++,r10
8000b79c:	2f f9       	sub	r9,-1
8000b79e:	04 39       	cp.w	r9,r2
8000b7a0:	cf d5       	brlt	8000b79a <__lshift+0x32>
8000b7a2:	6e 4b       	ld.w	r11,r7[0x10]
8000b7a4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b7a8:	2f bb       	sub	r11,-5
8000b7aa:	ee c9 ff ec 	sub	r9,r7,-20
8000b7ae:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b7b2:	58 03       	cp.w	r3,0
8000b7b4:	c1 30       	breq	8000b7da <__lshift+0x72>
8000b7b6:	e6 0c 11 20 	rsub	r12,r3,32
8000b7ba:	30 0a       	mov	r10,0
8000b7bc:	72 02       	ld.w	r2,r9[0x0]
8000b7be:	e4 03 09 42 	lsl	r2,r2,r3
8000b7c2:	04 4a       	or	r10,r2
8000b7c4:	10 aa       	st.w	r8++,r10
8000b7c6:	13 0a       	ld.w	r10,r9++
8000b7c8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b7cc:	16 39       	cp.w	r9,r11
8000b7ce:	cf 73       	brcs	8000b7bc <__lshift+0x54>
8000b7d0:	91 0a       	st.w	r8[0x0],r10
8000b7d2:	58 0a       	cp.w	r10,0
8000b7d4:	c0 70       	breq	8000b7e2 <__lshift+0x7a>
8000b7d6:	2f f6       	sub	r6,-1
8000b7d8:	c0 58       	rjmp	8000b7e2 <__lshift+0x7a>
8000b7da:	13 0a       	ld.w	r10,r9++
8000b7dc:	10 aa       	st.w	r8++,r10
8000b7de:	16 39       	cp.w	r9,r11
8000b7e0:	cf d3       	brcs	8000b7da <__lshift+0x72>
8000b7e2:	08 9c       	mov	r12,r4
8000b7e4:	20 16       	sub	r6,1
8000b7e6:	0e 9b       	mov	r11,r7
8000b7e8:	8b 46       	st.w	r5[0x10],r6
8000b7ea:	cb 5e       	rcall	8000b554 <_Bfree>
8000b7ec:	0a 9c       	mov	r12,r5
8000b7ee:	d8 32       	popm	r0-r7,pc

8000b7f0 <__multiply>:
8000b7f0:	d4 31       	pushm	r0-r7,lr
8000b7f2:	20 2d       	sub	sp,8
8000b7f4:	76 49       	ld.w	r9,r11[0x10]
8000b7f6:	74 48       	ld.w	r8,r10[0x10]
8000b7f8:	16 96       	mov	r6,r11
8000b7fa:	14 95       	mov	r5,r10
8000b7fc:	10 39       	cp.w	r9,r8
8000b7fe:	ec 08 17 50 	movlt	r8,r6
8000b802:	ea 06 17 50 	movlt	r6,r5
8000b806:	f0 05 17 50 	movlt	r5,r8
8000b80a:	6c 28       	ld.w	r8,r6[0x8]
8000b80c:	76 43       	ld.w	r3,r11[0x10]
8000b80e:	74 42       	ld.w	r2,r10[0x10]
8000b810:	76 1b       	ld.w	r11,r11[0x4]
8000b812:	e4 03 00 07 	add	r7,r2,r3
8000b816:	10 37       	cp.w	r7,r8
8000b818:	f7 bb 09 ff 	subgt	r11,-1
8000b81c:	cb 6e       	rcall	8000b588 <_Balloc>
8000b81e:	ee c4 ff fb 	sub	r4,r7,-5
8000b822:	f8 c9 ff ec 	sub	r9,r12,-20
8000b826:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b82a:	30 0a       	mov	r10,0
8000b82c:	12 98       	mov	r8,r9
8000b82e:	c0 28       	rjmp	8000b832 <__multiply+0x42>
8000b830:	10 aa       	st.w	r8++,r10
8000b832:	08 38       	cp.w	r8,r4
8000b834:	cf e3       	brcs	8000b830 <__multiply+0x40>
8000b836:	2f b3       	sub	r3,-5
8000b838:	2f b2       	sub	r2,-5
8000b83a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b83e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b842:	ec cb ff ec 	sub	r11,r6,-20
8000b846:	50 12       	stdsp	sp[0x4],r2
8000b848:	ea ca ff ec 	sub	r10,r5,-20
8000b84c:	c4 48       	rjmp	8000b8d4 <__multiply+0xe4>
8000b84e:	94 95       	ld.uh	r5,r10[0x2]
8000b850:	58 05       	cp.w	r5,0
8000b852:	c2 00       	breq	8000b892 <__multiply+0xa2>
8000b854:	12 98       	mov	r8,r9
8000b856:	16 96       	mov	r6,r11
8000b858:	30 0e       	mov	lr,0
8000b85a:	50 09       	stdsp	sp[0x0],r9
8000b85c:	0d 02       	ld.w	r2,r6++
8000b85e:	e4 00 16 10 	lsr	r0,r2,0x10
8000b862:	70 01       	ld.w	r1,r8[0x0]
8000b864:	70 09       	ld.w	r9,r8[0x0]
8000b866:	b1 81       	lsr	r1,0x10
8000b868:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b86c:	e0 05 03 41 	mac	r1,r0,r5
8000b870:	ab 32       	mul	r2,r5
8000b872:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b876:	00 02       	add	r2,r0
8000b878:	e4 0e 00 0e 	add	lr,r2,lr
8000b87c:	b0 1e       	st.h	r8[0x2],lr
8000b87e:	b1 8e       	lsr	lr,0x10
8000b880:	1c 01       	add	r1,lr
8000b882:	b0 01       	st.h	r8[0x0],r1
8000b884:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b888:	2f c8       	sub	r8,-4
8000b88a:	06 36       	cp.w	r6,r3
8000b88c:	ce 83       	brcs	8000b85c <__multiply+0x6c>
8000b88e:	40 09       	lddsp	r9,sp[0x0]
8000b890:	91 0e       	st.w	r8[0x0],lr
8000b892:	94 86       	ld.uh	r6,r10[0x0]
8000b894:	58 06       	cp.w	r6,0
8000b896:	c1 d0       	breq	8000b8d0 <__multiply+0xe0>
8000b898:	72 02       	ld.w	r2,r9[0x0]
8000b89a:	12 98       	mov	r8,r9
8000b89c:	16 9e       	mov	lr,r11
8000b89e:	30 05       	mov	r5,0
8000b8a0:	b0 12       	st.h	r8[0x2],r2
8000b8a2:	1d 01       	ld.w	r1,lr++
8000b8a4:	90 82       	ld.uh	r2,r8[0x0]
8000b8a6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b8aa:	ad 30       	mul	r0,r6
8000b8ac:	e0 02 00 02 	add	r2,r0,r2
8000b8b0:	e4 05 00 05 	add	r5,r2,r5
8000b8b4:	b0 05       	st.h	r8[0x0],r5
8000b8b6:	b1 85       	lsr	r5,0x10
8000b8b8:	b1 81       	lsr	r1,0x10
8000b8ba:	2f c8       	sub	r8,-4
8000b8bc:	ad 31       	mul	r1,r6
8000b8be:	90 92       	ld.uh	r2,r8[0x2]
8000b8c0:	e2 02 00 02 	add	r2,r1,r2
8000b8c4:	0a 02       	add	r2,r5
8000b8c6:	e4 05 16 10 	lsr	r5,r2,0x10
8000b8ca:	06 3e       	cp.w	lr,r3
8000b8cc:	ce a3       	brcs	8000b8a0 <__multiply+0xb0>
8000b8ce:	91 02       	st.w	r8[0x0],r2
8000b8d0:	2f ca       	sub	r10,-4
8000b8d2:	2f c9       	sub	r9,-4
8000b8d4:	40 18       	lddsp	r8,sp[0x4]
8000b8d6:	10 3a       	cp.w	r10,r8
8000b8d8:	cb b3       	brcs	8000b84e <__multiply+0x5e>
8000b8da:	c0 28       	rjmp	8000b8de <__multiply+0xee>
8000b8dc:	20 17       	sub	r7,1
8000b8de:	58 07       	cp.w	r7,0
8000b8e0:	e0 8a 00 05 	brle	8000b8ea <__multiply+0xfa>
8000b8e4:	09 48       	ld.w	r8,--r4
8000b8e6:	58 08       	cp.w	r8,0
8000b8e8:	cf a0       	breq	8000b8dc <__multiply+0xec>
8000b8ea:	99 47       	st.w	r12[0x10],r7
8000b8ec:	2f ed       	sub	sp,-8
8000b8ee:	d8 32       	popm	r0-r7,pc

8000b8f0 <__i2b>:
8000b8f0:	d4 21       	pushm	r4-r7,lr
8000b8f2:	16 97       	mov	r7,r11
8000b8f4:	30 1b       	mov	r11,1
8000b8f6:	c4 9e       	rcall	8000b588 <_Balloc>
8000b8f8:	30 19       	mov	r9,1
8000b8fa:	99 57       	st.w	r12[0x14],r7
8000b8fc:	99 49       	st.w	r12[0x10],r9
8000b8fe:	d8 22       	popm	r4-r7,pc

8000b900 <__multadd>:
8000b900:	d4 31       	pushm	r0-r7,lr
8000b902:	30 08       	mov	r8,0
8000b904:	12 95       	mov	r5,r9
8000b906:	16 97       	mov	r7,r11
8000b908:	18 96       	mov	r6,r12
8000b90a:	76 44       	ld.w	r4,r11[0x10]
8000b90c:	f6 c9 ff ec 	sub	r9,r11,-20
8000b910:	72 0b       	ld.w	r11,r9[0x0]
8000b912:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b916:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b91a:	f4 0c 02 4c 	mul	r12,r10,r12
8000b91e:	f4 0b 03 45 	mac	r5,r10,r11
8000b922:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b926:	b1 85       	lsr	r5,0x10
8000b928:	18 05       	add	r5,r12
8000b92a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b92e:	f8 0b 00 0b 	add	r11,r12,r11
8000b932:	12 ab       	st.w	r9++,r11
8000b934:	2f f8       	sub	r8,-1
8000b936:	b1 85       	lsr	r5,0x10
8000b938:	08 38       	cp.w	r8,r4
8000b93a:	ce b5       	brlt	8000b910 <__multadd+0x10>
8000b93c:	58 05       	cp.w	r5,0
8000b93e:	c1 c0       	breq	8000b976 <__multadd+0x76>
8000b940:	6e 28       	ld.w	r8,r7[0x8]
8000b942:	10 34       	cp.w	r4,r8
8000b944:	c1 35       	brlt	8000b96a <__multadd+0x6a>
8000b946:	6e 1b       	ld.w	r11,r7[0x4]
8000b948:	0c 9c       	mov	r12,r6
8000b94a:	2f fb       	sub	r11,-1
8000b94c:	c1 ee       	rcall	8000b588 <_Balloc>
8000b94e:	6e 4a       	ld.w	r10,r7[0x10]
8000b950:	ee cb ff f4 	sub	r11,r7,-12
8000b954:	18 93       	mov	r3,r12
8000b956:	2f ea       	sub	r10,-2
8000b958:	2f 4c       	sub	r12,-12
8000b95a:	a3 6a       	lsl	r10,0x2
8000b95c:	fe b0 de 70 	rcall	8000763c <memcpy>
8000b960:	0e 9b       	mov	r11,r7
8000b962:	0c 9c       	mov	r12,r6
8000b964:	fe b0 fd f8 	rcall	8000b554 <_Bfree>
8000b968:	06 97       	mov	r7,r3
8000b96a:	e8 c8 ff ff 	sub	r8,r4,-1
8000b96e:	2f b4       	sub	r4,-5
8000b970:	8f 48       	st.w	r7[0x10],r8
8000b972:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b976:	0e 9c       	mov	r12,r7
8000b978:	d8 32       	popm	r0-r7,pc
8000b97a:	d7 03       	nop

8000b97c <__pow5mult>:
8000b97c:	d4 31       	pushm	r0-r7,lr
8000b97e:	14 96       	mov	r6,r10
8000b980:	18 97       	mov	r7,r12
8000b982:	16 94       	mov	r4,r11
8000b984:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b988:	c0 90       	breq	8000b99a <__pow5mult+0x1e>
8000b98a:	20 18       	sub	r8,1
8000b98c:	fe c9 d9 f8 	sub	r9,pc,-9736
8000b990:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b994:	30 09       	mov	r9,0
8000b996:	cb 5f       	rcall	8000b900 <__multadd>
8000b998:	18 94       	mov	r4,r12
8000b99a:	a3 46       	asr	r6,0x2
8000b99c:	c3 40       	breq	8000ba04 <__pow5mult+0x88>
8000b99e:	6e 95       	ld.w	r5,r7[0x24]
8000b9a0:	58 05       	cp.w	r5,0
8000b9a2:	c0 91       	brne	8000b9b4 <__pow5mult+0x38>
8000b9a4:	31 0c       	mov	r12,16
8000b9a6:	fe b0 dc 27 	rcall	800071f4 <malloc>
8000b9aa:	99 35       	st.w	r12[0xc],r5
8000b9ac:	8f 9c       	st.w	r7[0x24],r12
8000b9ae:	99 15       	st.w	r12[0x4],r5
8000b9b0:	99 25       	st.w	r12[0x8],r5
8000b9b2:	99 05       	st.w	r12[0x0],r5
8000b9b4:	6e 93       	ld.w	r3,r7[0x24]
8000b9b6:	66 25       	ld.w	r5,r3[0x8]
8000b9b8:	58 05       	cp.w	r5,0
8000b9ba:	c0 c1       	brne	8000b9d2 <__pow5mult+0x56>
8000b9bc:	e0 6b 02 71 	mov	r11,625
8000b9c0:	0e 9c       	mov	r12,r7
8000b9c2:	c9 7f       	rcall	8000b8f0 <__i2b>
8000b9c4:	87 2c       	st.w	r3[0x8],r12
8000b9c6:	30 08       	mov	r8,0
8000b9c8:	18 95       	mov	r5,r12
8000b9ca:	99 08       	st.w	r12[0x0],r8
8000b9cc:	c0 38       	rjmp	8000b9d2 <__pow5mult+0x56>
8000b9ce:	06 9c       	mov	r12,r3
8000b9d0:	18 95       	mov	r5,r12
8000b9d2:	ed b6 00 00 	bld	r6,0x0
8000b9d6:	c0 b1       	brne	8000b9ec <__pow5mult+0x70>
8000b9d8:	08 9b       	mov	r11,r4
8000b9da:	0a 9a       	mov	r10,r5
8000b9dc:	0e 9c       	mov	r12,r7
8000b9de:	c0 9f       	rcall	8000b7f0 <__multiply>
8000b9e0:	08 9b       	mov	r11,r4
8000b9e2:	18 93       	mov	r3,r12
8000b9e4:	0e 9c       	mov	r12,r7
8000b9e6:	06 94       	mov	r4,r3
8000b9e8:	fe b0 fd b6 	rcall	8000b554 <_Bfree>
8000b9ec:	a1 56       	asr	r6,0x1
8000b9ee:	c0 b0       	breq	8000ba04 <__pow5mult+0x88>
8000b9f0:	6a 03       	ld.w	r3,r5[0x0]
8000b9f2:	58 03       	cp.w	r3,0
8000b9f4:	ce d1       	brne	8000b9ce <__pow5mult+0x52>
8000b9f6:	0a 9a       	mov	r10,r5
8000b9f8:	0a 9b       	mov	r11,r5
8000b9fa:	0e 9c       	mov	r12,r7
8000b9fc:	cf ae       	rcall	8000b7f0 <__multiply>
8000b9fe:	8b 0c       	st.w	r5[0x0],r12
8000ba00:	99 03       	st.w	r12[0x0],r3
8000ba02:	ce 7b       	rjmp	8000b9d0 <__pow5mult+0x54>
8000ba04:	08 9c       	mov	r12,r4
8000ba06:	d8 32       	popm	r0-r7,pc

8000ba08 <__isinfd>:
8000ba08:	14 98       	mov	r8,r10
8000ba0a:	fc 19 7f f0 	movh	r9,0x7ff0
8000ba0e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba12:	f0 0b 11 00 	rsub	r11,r8,0
8000ba16:	f7 e8 10 08 	or	r8,r11,r8
8000ba1a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ba1e:	f2 08 01 08 	sub	r8,r9,r8
8000ba22:	f0 0c 11 00 	rsub	r12,r8,0
8000ba26:	f9 e8 10 08 	or	r8,r12,r8
8000ba2a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ba2e:	2f fc       	sub	r12,-1
8000ba30:	5e fc       	retal	r12

8000ba32 <__isnand>:
8000ba32:	14 98       	mov	r8,r10
8000ba34:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba38:	f0 0c 11 00 	rsub	r12,r8,0
8000ba3c:	10 4c       	or	r12,r8
8000ba3e:	fc 18 7f f0 	movh	r8,0x7ff0
8000ba42:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ba46:	f0 0c 01 0c 	sub	r12,r8,r12
8000ba4a:	bf 9c       	lsr	r12,0x1f
8000ba4c:	5e fc       	retal	r12
8000ba4e:	d7 03       	nop

8000ba50 <__sclose>:
8000ba50:	d4 01       	pushm	lr
8000ba52:	96 7b       	ld.sh	r11,r11[0xe]
8000ba54:	c8 2c       	rcall	8000bb58 <_close_r>
8000ba56:	d8 02       	popm	pc

8000ba58 <__sseek>:
8000ba58:	d4 21       	pushm	r4-r7,lr
8000ba5a:	16 97       	mov	r7,r11
8000ba5c:	96 7b       	ld.sh	r11,r11[0xe]
8000ba5e:	c0 3d       	rcall	8000bc64 <_lseek_r>
8000ba60:	8e 68       	ld.sh	r8,r7[0xc]
8000ba62:	10 99       	mov	r9,r8
8000ba64:	ad c8       	cbr	r8,0xc
8000ba66:	ad a9       	sbr	r9,0xc
8000ba68:	5b fc       	cp.w	r12,-1
8000ba6a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ba6e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ba72:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ba76:	d8 22       	popm	r4-r7,pc

8000ba78 <__swrite>:
8000ba78:	d4 21       	pushm	r4-r7,lr
8000ba7a:	96 68       	ld.sh	r8,r11[0xc]
8000ba7c:	16 97       	mov	r7,r11
8000ba7e:	14 95       	mov	r5,r10
8000ba80:	12 94       	mov	r4,r9
8000ba82:	e2 18 01 00 	andl	r8,0x100,COH
8000ba86:	18 96       	mov	r6,r12
8000ba88:	c0 50       	breq	8000ba92 <__swrite+0x1a>
8000ba8a:	30 29       	mov	r9,2
8000ba8c:	30 0a       	mov	r10,0
8000ba8e:	96 7b       	ld.sh	r11,r11[0xe]
8000ba90:	ce ac       	rcall	8000bc64 <_lseek_r>
8000ba92:	8e 68       	ld.sh	r8,r7[0xc]
8000ba94:	ad c8       	cbr	r8,0xc
8000ba96:	08 99       	mov	r9,r4
8000ba98:	0a 9a       	mov	r10,r5
8000ba9a:	8e 7b       	ld.sh	r11,r7[0xe]
8000ba9c:	0c 9c       	mov	r12,r6
8000ba9e:	ae 68       	st.h	r7[0xc],r8
8000baa0:	c1 cc       	rcall	8000bad8 <_write_r>
8000baa2:	d8 22       	popm	r4-r7,pc

8000baa4 <__sread>:
8000baa4:	d4 21       	pushm	r4-r7,lr
8000baa6:	16 97       	mov	r7,r11
8000baa8:	96 7b       	ld.sh	r11,r11[0xe]
8000baaa:	cf 1c       	rcall	8000bc8c <_read_r>
8000baac:	c0 65       	brlt	8000bab8 <__sread+0x14>
8000baae:	6f 58       	ld.w	r8,r7[0x54]
8000bab0:	18 08       	add	r8,r12
8000bab2:	ef 48 00 54 	st.w	r7[84],r8
8000bab6:	d8 22       	popm	r4-r7,pc
8000bab8:	8e 68       	ld.sh	r8,r7[0xc]
8000baba:	ad c8       	cbr	r8,0xc
8000babc:	ae 68       	st.h	r7[0xc],r8
8000babe:	d8 22       	popm	r4-r7,pc

8000bac0 <strlen>:
8000bac0:	30 09       	mov	r9,0
8000bac2:	18 98       	mov	r8,r12
8000bac4:	c0 28       	rjmp	8000bac8 <strlen+0x8>
8000bac6:	2f f8       	sub	r8,-1
8000bac8:	11 8a       	ld.ub	r10,r8[0x0]
8000baca:	f2 0a 18 00 	cp.b	r10,r9
8000bace:	cf c1       	brne	8000bac6 <strlen+0x6>
8000bad0:	f0 0c 01 0c 	sub	r12,r8,r12
8000bad4:	5e fc       	retal	r12
8000bad6:	d7 03       	nop

8000bad8 <_write_r>:
8000bad8:	d4 21       	pushm	r4-r7,lr
8000bada:	16 98       	mov	r8,r11
8000badc:	18 97       	mov	r7,r12
8000bade:	10 9c       	mov	r12,r8
8000bae0:	30 08       	mov	r8,0
8000bae2:	14 9b       	mov	r11,r10
8000bae4:	e0 66 b6 78 	mov	r6,46712
8000bae8:	12 9a       	mov	r10,r9
8000baea:	8d 08       	st.w	r6[0x0],r8
8000baec:	fe b0 d1 72 	rcall	80005dd0 <_write>
8000baf0:	5b fc       	cp.w	r12,-1
8000baf2:	c0 51       	brne	8000bafc <_write_r+0x24>
8000baf4:	6c 08       	ld.w	r8,r6[0x0]
8000baf6:	58 08       	cp.w	r8,0
8000baf8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bafc:	d8 22       	popm	r4-r7,pc
8000bafe:	d7 03       	nop

8000bb00 <_calloc_r>:
8000bb00:	d4 21       	pushm	r4-r7,lr
8000bb02:	f4 0b 02 4b 	mul	r11,r10,r11
8000bb06:	fe b0 db 7f 	rcall	80007204 <_malloc_r>
8000bb0a:	18 97       	mov	r7,r12
8000bb0c:	c2 30       	breq	8000bb52 <_calloc_r+0x52>
8000bb0e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bb12:	e0 1a ff fc 	andl	r10,0xfffc
8000bb16:	20 4a       	sub	r10,4
8000bb18:	e0 4a 00 24 	cp.w	r10,36
8000bb1c:	e0 8b 00 18 	brhi	8000bb4c <_calloc_r+0x4c>
8000bb20:	18 98       	mov	r8,r12
8000bb22:	59 3a       	cp.w	r10,19
8000bb24:	e0 88 00 0f 	brls	8000bb42 <_calloc_r+0x42>
8000bb28:	30 09       	mov	r9,0
8000bb2a:	10 a9       	st.w	r8++,r9
8000bb2c:	10 a9       	st.w	r8++,r9
8000bb2e:	59 ba       	cp.w	r10,27
8000bb30:	e0 88 00 09 	brls	8000bb42 <_calloc_r+0x42>
8000bb34:	10 a9       	st.w	r8++,r9
8000bb36:	10 a9       	st.w	r8++,r9
8000bb38:	e0 4a 00 24 	cp.w	r10,36
8000bb3c:	c0 31       	brne	8000bb42 <_calloc_r+0x42>
8000bb3e:	10 a9       	st.w	r8++,r9
8000bb40:	10 a9       	st.w	r8++,r9
8000bb42:	30 09       	mov	r9,0
8000bb44:	10 a9       	st.w	r8++,r9
8000bb46:	91 19       	st.w	r8[0x4],r9
8000bb48:	91 09       	st.w	r8[0x0],r9
8000bb4a:	c0 48       	rjmp	8000bb52 <_calloc_r+0x52>
8000bb4c:	30 0b       	mov	r11,0
8000bb4e:	fe b0 de 1b 	rcall	80007784 <memset>
8000bb52:	0e 9c       	mov	r12,r7
8000bb54:	d8 22       	popm	r4-r7,pc
8000bb56:	d7 03       	nop

8000bb58 <_close_r>:
8000bb58:	d4 21       	pushm	r4-r7,lr
8000bb5a:	30 08       	mov	r8,0
8000bb5c:	18 97       	mov	r7,r12
8000bb5e:	e0 66 b6 78 	mov	r6,46712
8000bb62:	16 9c       	mov	r12,r11
8000bb64:	8d 08       	st.w	r6[0x0],r8
8000bb66:	fe b0 df b5 	rcall	80007ad0 <_close>
8000bb6a:	5b fc       	cp.w	r12,-1
8000bb6c:	c0 51       	brne	8000bb76 <_close_r+0x1e>
8000bb6e:	6c 08       	ld.w	r8,r6[0x0]
8000bb70:	58 08       	cp.w	r8,0
8000bb72:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bb76:	d8 22       	popm	r4-r7,pc

8000bb78 <_fclose_r>:
8000bb78:	d4 21       	pushm	r4-r7,lr
8000bb7a:	18 96       	mov	r6,r12
8000bb7c:	16 97       	mov	r7,r11
8000bb7e:	58 0b       	cp.w	r11,0
8000bb80:	c0 31       	brne	8000bb86 <_fclose_r+0xe>
8000bb82:	16 95       	mov	r5,r11
8000bb84:	c5 38       	rjmp	8000bc2a <_fclose_r+0xb2>
8000bb86:	fe b0 f8 a9 	rcall	8000acd8 <__sfp_lock_acquire>
8000bb8a:	58 06       	cp.w	r6,0
8000bb8c:	c0 70       	breq	8000bb9a <_fclose_r+0x22>
8000bb8e:	6c 68       	ld.w	r8,r6[0x18]
8000bb90:	58 08       	cp.w	r8,0
8000bb92:	c0 41       	brne	8000bb9a <_fclose_r+0x22>
8000bb94:	0c 9c       	mov	r12,r6
8000bb96:	fe b0 f8 f3 	rcall	8000ad7c <__sinit>
8000bb9a:	fe c8 dc aa 	sub	r8,pc,-9046
8000bb9e:	10 37       	cp.w	r7,r8
8000bba0:	c0 31       	brne	8000bba6 <_fclose_r+0x2e>
8000bba2:	6c 07       	ld.w	r7,r6[0x0]
8000bba4:	c0 c8       	rjmp	8000bbbc <_fclose_r+0x44>
8000bba6:	fe c8 dc 96 	sub	r8,pc,-9066
8000bbaa:	10 37       	cp.w	r7,r8
8000bbac:	c0 31       	brne	8000bbb2 <_fclose_r+0x3a>
8000bbae:	6c 17       	ld.w	r7,r6[0x4]
8000bbb0:	c0 68       	rjmp	8000bbbc <_fclose_r+0x44>
8000bbb2:	fe c8 dc 82 	sub	r8,pc,-9086
8000bbb6:	10 37       	cp.w	r7,r8
8000bbb8:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bbbc:	8e 69       	ld.sh	r9,r7[0xc]
8000bbbe:	30 08       	mov	r8,0
8000bbc0:	f0 09 19 00 	cp.h	r9,r8
8000bbc4:	c0 51       	brne	8000bbce <_fclose_r+0x56>
8000bbc6:	fe b0 f8 8a 	rcall	8000acda <__sfp_lock_release>
8000bbca:	30 05       	mov	r5,0
8000bbcc:	c2 f8       	rjmp	8000bc2a <_fclose_r+0xb2>
8000bbce:	0e 9b       	mov	r11,r7
8000bbd0:	0c 9c       	mov	r12,r6
8000bbd2:	fe b0 f7 fd 	rcall	8000abcc <_fflush_r>
8000bbd6:	6e c8       	ld.w	r8,r7[0x30]
8000bbd8:	18 95       	mov	r5,r12
8000bbda:	58 08       	cp.w	r8,0
8000bbdc:	c0 60       	breq	8000bbe8 <_fclose_r+0x70>
8000bbde:	6e 8b       	ld.w	r11,r7[0x20]
8000bbe0:	0c 9c       	mov	r12,r6
8000bbe2:	5d 18       	icall	r8
8000bbe4:	f9 b5 05 ff 	movlt	r5,-1
8000bbe8:	8e 68       	ld.sh	r8,r7[0xc]
8000bbea:	ed b8 00 07 	bld	r8,0x7
8000bbee:	c0 51       	brne	8000bbf8 <_fclose_r+0x80>
8000bbf0:	6e 4b       	ld.w	r11,r7[0x10]
8000bbf2:	0c 9c       	mov	r12,r6
8000bbf4:	fe b0 f9 5e 	rcall	8000aeb0 <_free_r>
8000bbf8:	6e db       	ld.w	r11,r7[0x34]
8000bbfa:	58 0b       	cp.w	r11,0
8000bbfc:	c0 a0       	breq	8000bc10 <_fclose_r+0x98>
8000bbfe:	ee c8 ff bc 	sub	r8,r7,-68
8000bc02:	10 3b       	cp.w	r11,r8
8000bc04:	c0 40       	breq	8000bc0c <_fclose_r+0x94>
8000bc06:	0c 9c       	mov	r12,r6
8000bc08:	fe b0 f9 54 	rcall	8000aeb0 <_free_r>
8000bc0c:	30 08       	mov	r8,0
8000bc0e:	8f d8       	st.w	r7[0x34],r8
8000bc10:	6f 2b       	ld.w	r11,r7[0x48]
8000bc12:	58 0b       	cp.w	r11,0
8000bc14:	c0 70       	breq	8000bc22 <_fclose_r+0xaa>
8000bc16:	0c 9c       	mov	r12,r6
8000bc18:	fe b0 f9 4c 	rcall	8000aeb0 <_free_r>
8000bc1c:	30 08       	mov	r8,0
8000bc1e:	ef 48 00 48 	st.w	r7[72],r8
8000bc22:	30 08       	mov	r8,0
8000bc24:	ae 68       	st.h	r7[0xc],r8
8000bc26:	fe b0 f8 5a 	rcall	8000acda <__sfp_lock_release>
8000bc2a:	0a 9c       	mov	r12,r5
8000bc2c:	d8 22       	popm	r4-r7,pc
8000bc2e:	d7 03       	nop

8000bc30 <fclose>:
8000bc30:	d4 01       	pushm	lr
8000bc32:	e0 68 0a 30 	mov	r8,2608
8000bc36:	18 9b       	mov	r11,r12
8000bc38:	70 0c       	ld.w	r12,r8[0x0]
8000bc3a:	c9 ff       	rcall	8000bb78 <_fclose_r>
8000bc3c:	d8 02       	popm	pc
8000bc3e:	d7 03       	nop

8000bc40 <_fstat_r>:
8000bc40:	d4 21       	pushm	r4-r7,lr
8000bc42:	16 98       	mov	r8,r11
8000bc44:	18 97       	mov	r7,r12
8000bc46:	10 9c       	mov	r12,r8
8000bc48:	30 08       	mov	r8,0
8000bc4a:	e0 66 b6 78 	mov	r6,46712
8000bc4e:	14 9b       	mov	r11,r10
8000bc50:	8d 08       	st.w	r6[0x0],r8
8000bc52:	fe b0 df 67 	rcall	80007b20 <_fstat>
8000bc56:	5b fc       	cp.w	r12,-1
8000bc58:	c0 51       	brne	8000bc62 <_fstat_r+0x22>
8000bc5a:	6c 08       	ld.w	r8,r6[0x0]
8000bc5c:	58 08       	cp.w	r8,0
8000bc5e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc62:	d8 22       	popm	r4-r7,pc

8000bc64 <_lseek_r>:
8000bc64:	d4 21       	pushm	r4-r7,lr
8000bc66:	16 98       	mov	r8,r11
8000bc68:	18 97       	mov	r7,r12
8000bc6a:	10 9c       	mov	r12,r8
8000bc6c:	30 08       	mov	r8,0
8000bc6e:	14 9b       	mov	r11,r10
8000bc70:	e0 66 b6 78 	mov	r6,46712
8000bc74:	12 9a       	mov	r10,r9
8000bc76:	8d 08       	st.w	r6[0x0],r8
8000bc78:	fe b0 df 36 	rcall	80007ae4 <_lseek>
8000bc7c:	5b fc       	cp.w	r12,-1
8000bc7e:	c0 51       	brne	8000bc88 <_lseek_r+0x24>
8000bc80:	6c 08       	ld.w	r8,r6[0x0]
8000bc82:	58 08       	cp.w	r8,0
8000bc84:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc88:	d8 22       	popm	r4-r7,pc
8000bc8a:	d7 03       	nop

8000bc8c <_read_r>:
8000bc8c:	d4 21       	pushm	r4-r7,lr
8000bc8e:	16 98       	mov	r8,r11
8000bc90:	18 97       	mov	r7,r12
8000bc92:	10 9c       	mov	r12,r8
8000bc94:	30 08       	mov	r8,0
8000bc96:	14 9b       	mov	r11,r10
8000bc98:	e0 66 b6 78 	mov	r6,46712
8000bc9c:	12 9a       	mov	r10,r9
8000bc9e:	8d 08       	st.w	r6[0x0],r8
8000bca0:	fe b0 d0 78 	rcall	80005d90 <_read>
8000bca4:	5b fc       	cp.w	r12,-1
8000bca6:	c0 51       	brne	8000bcb0 <_read_r+0x24>
8000bca8:	6c 08       	ld.w	r8,r6[0x0]
8000bcaa:	58 08       	cp.w	r8,0
8000bcac:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcb0:	d8 22       	popm	r4-r7,pc
8000bcb2:	d7 03       	nop

8000bcb4 <__avr32_f64_mul>:
8000bcb4:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bcb8:	e0 80 00 dc 	breq	8000be70 <__avr32_f64_mul_op1_zero>
8000bcbc:	d4 21       	pushm	r4-r7,lr
8000bcbe:	f7 e9 20 0e 	eor	lr,r11,r9
8000bcc2:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bcc6:	30 15       	mov	r5,1
8000bcc8:	c4 30       	breq	8000bd4e <__avr32_f64_mul_op1_subnormal>
8000bcca:	ab 6b       	lsl	r11,0xa
8000bccc:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bcd0:	ab 6a       	lsl	r10,0xa
8000bcd2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bcd6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bcda:	c5 c0       	breq	8000bd92 <__avr32_f64_mul_op2_subnormal>
8000bcdc:	a1 78       	lsl	r8,0x1
8000bcde:	5c f9       	rol	r9
8000bce0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bce4:	e0 47 07 ff 	cp.w	r7,2047
8000bce8:	c7 70       	breq	8000bdd6 <__avr32_f64_mul_op_nan_or_inf>
8000bcea:	e0 46 07 ff 	cp.w	r6,2047
8000bcee:	c7 40       	breq	8000bdd6 <__avr32_f64_mul_op_nan_or_inf>
8000bcf0:	ee 06 00 0c 	add	r12,r7,r6
8000bcf4:	e0 2c 03 fe 	sub	r12,1022
8000bcf8:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bcfc:	f4 09 07 44 	macu.d	r4,r10,r9
8000bd00:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bd04:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bd08:	08 07       	add	r7,r4
8000bd0a:	f4 05 00 4a 	adc	r10,r10,r5
8000bd0e:	5c 0b       	acr	r11
8000bd10:	ed bb 00 14 	bld	r11,0x14
8000bd14:	c0 50       	breq	8000bd1e <__avr32_f64_mul+0x6a>
8000bd16:	a1 77       	lsl	r7,0x1
8000bd18:	5c fa       	rol	r10
8000bd1a:	5c fb       	rol	r11
8000bd1c:	20 1c       	sub	r12,1
8000bd1e:	58 0c       	cp.w	r12,0
8000bd20:	e0 8a 00 6f 	brle	8000bdfe <__avr32_f64_mul_res_subnormal>
8000bd24:	e0 4c 07 ff 	cp.w	r12,2047
8000bd28:	e0 84 00 9c 	brge	8000be60 <__avr32_f64_mul_res_inf>
8000bd2c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bd30:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bd34:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bd38:	ee 17 80 00 	eorh	r7,0x8000
8000bd3c:	f1 b7 04 20 	satu	r7,0x1
8000bd40:	0e 0a       	add	r10,r7
8000bd42:	5c 0b       	acr	r11
8000bd44:	ed be 00 1f 	bld	lr,0x1f
8000bd48:	ef bb 00 1f 	bst	r11,0x1f
8000bd4c:	d8 22       	popm	r4-r7,pc

8000bd4e <__avr32_f64_mul_op1_subnormal>:
8000bd4e:	e4 1b 00 0f 	andh	r11,0xf
8000bd52:	f4 0c 12 00 	clz	r12,r10
8000bd56:	f6 06 12 00 	clz	r6,r11
8000bd5a:	f7 bc 03 e1 	sublo	r12,-31
8000bd5e:	f8 06 17 30 	movlo	r6,r12
8000bd62:	f7 b6 02 01 	subhs	r6,1
8000bd66:	e0 46 00 20 	cp.w	r6,32
8000bd6a:	c0 d4       	brge	8000bd84 <__avr32_f64_mul_op1_subnormal+0x36>
8000bd6c:	ec 0c 11 20 	rsub	r12,r6,32
8000bd70:	f6 06 09 4b 	lsl	r11,r11,r6
8000bd74:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bd78:	18 4b       	or	r11,r12
8000bd7a:	f4 06 09 4a 	lsl	r10,r10,r6
8000bd7e:	20 b6       	sub	r6,11
8000bd80:	0c 17       	sub	r7,r6
8000bd82:	ca ab       	rjmp	8000bcd6 <__avr32_f64_mul+0x22>
8000bd84:	f4 06 09 4b 	lsl	r11,r10,r6
8000bd88:	c6 40       	breq	8000be50 <__avr32_f64_mul_res_zero>
8000bd8a:	30 0a       	mov	r10,0
8000bd8c:	20 b6       	sub	r6,11
8000bd8e:	0c 17       	sub	r7,r6
8000bd90:	ca 3b       	rjmp	8000bcd6 <__avr32_f64_mul+0x22>

8000bd92 <__avr32_f64_mul_op2_subnormal>:
8000bd92:	e4 19 00 0f 	andh	r9,0xf
8000bd96:	f0 0c 12 00 	clz	r12,r8
8000bd9a:	f2 05 12 00 	clz	r5,r9
8000bd9e:	f7 bc 03 ea 	sublo	r12,-22
8000bda2:	f8 05 17 30 	movlo	r5,r12
8000bda6:	f7 b5 02 0a 	subhs	r5,10
8000bdaa:	e0 45 00 20 	cp.w	r5,32
8000bdae:	c0 d4       	brge	8000bdc8 <__avr32_f64_mul_op2_subnormal+0x36>
8000bdb0:	ea 0c 11 20 	rsub	r12,r5,32
8000bdb4:	f2 05 09 49 	lsl	r9,r9,r5
8000bdb8:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bdbc:	18 49       	or	r9,r12
8000bdbe:	f0 05 09 48 	lsl	r8,r8,r5
8000bdc2:	20 25       	sub	r5,2
8000bdc4:	0a 16       	sub	r6,r5
8000bdc6:	c8 fb       	rjmp	8000bce4 <__avr32_f64_mul+0x30>
8000bdc8:	f0 05 09 49 	lsl	r9,r8,r5
8000bdcc:	c4 20       	breq	8000be50 <__avr32_f64_mul_res_zero>
8000bdce:	30 08       	mov	r8,0
8000bdd0:	20 25       	sub	r5,2
8000bdd2:	0a 16       	sub	r6,r5
8000bdd4:	c8 8b       	rjmp	8000bce4 <__avr32_f64_mul+0x30>

8000bdd6 <__avr32_f64_mul_op_nan_or_inf>:
8000bdd6:	e4 19 00 0f 	andh	r9,0xf
8000bdda:	e4 1b 00 0f 	andh	r11,0xf
8000bdde:	14 4b       	or	r11,r10
8000bde0:	10 49       	or	r9,r8
8000bde2:	e0 47 07 ff 	cp.w	r7,2047
8000bde6:	c0 91       	brne	8000bdf8 <__avr32_f64_mul_op1_not_naninf>
8000bde8:	58 0b       	cp.w	r11,0
8000bdea:	c3 81       	brne	8000be5a <__avr32_f64_mul_res_nan>
8000bdec:	e0 46 07 ff 	cp.w	r6,2047
8000bdf0:	c3 81       	brne	8000be60 <__avr32_f64_mul_res_inf>
8000bdf2:	58 09       	cp.w	r9,0
8000bdf4:	c3 60       	breq	8000be60 <__avr32_f64_mul_res_inf>
8000bdf6:	c3 28       	rjmp	8000be5a <__avr32_f64_mul_res_nan>

8000bdf8 <__avr32_f64_mul_op1_not_naninf>:
8000bdf8:	58 09       	cp.w	r9,0
8000bdfa:	c3 30       	breq	8000be60 <__avr32_f64_mul_res_inf>
8000bdfc:	c2 f8       	rjmp	8000be5a <__avr32_f64_mul_res_nan>

8000bdfe <__avr32_f64_mul_res_subnormal>:
8000bdfe:	5c 3c       	neg	r12
8000be00:	2f fc       	sub	r12,-1
8000be02:	f1 bc 04 c0 	satu	r12,0x6
8000be06:	e0 4c 00 20 	cp.w	r12,32
8000be0a:	c1 14       	brge	8000be2c <__avr32_f64_mul_res_subnormal+0x2e>
8000be0c:	f8 08 11 20 	rsub	r8,r12,32
8000be10:	0e 46       	or	r6,r7
8000be12:	ee 0c 0a 47 	lsr	r7,r7,r12
8000be16:	f4 08 09 49 	lsl	r9,r10,r8
8000be1a:	12 47       	or	r7,r9
8000be1c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be20:	f6 08 09 49 	lsl	r9,r11,r8
8000be24:	12 4a       	or	r10,r9
8000be26:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be2a:	c8 3b       	rjmp	8000bd30 <__avr32_f64_mul+0x7c>
8000be2c:	f8 08 11 20 	rsub	r8,r12,32
8000be30:	f9 b9 00 00 	moveq	r9,0
8000be34:	c0 30       	breq	8000be3a <__avr32_f64_mul_res_subnormal+0x3c>
8000be36:	f6 08 09 49 	lsl	r9,r11,r8
8000be3a:	0e 46       	or	r6,r7
8000be3c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000be40:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be44:	f3 ea 10 07 	or	r7,r9,r10
8000be48:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000be4c:	30 0b       	mov	r11,0
8000be4e:	c7 1b       	rjmp	8000bd30 <__avr32_f64_mul+0x7c>

8000be50 <__avr32_f64_mul_res_zero>:
8000be50:	1c 9b       	mov	r11,lr
8000be52:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be56:	30 0a       	mov	r10,0
8000be58:	d8 22       	popm	r4-r7,pc

8000be5a <__avr32_f64_mul_res_nan>:
8000be5a:	3f fb       	mov	r11,-1
8000be5c:	3f fa       	mov	r10,-1
8000be5e:	d8 22       	popm	r4-r7,pc

8000be60 <__avr32_f64_mul_res_inf>:
8000be60:	f0 6b 00 00 	mov	r11,-1048576
8000be64:	ed be 00 1f 	bld	lr,0x1f
8000be68:	ef bb 00 1f 	bst	r11,0x1f
8000be6c:	30 0a       	mov	r10,0
8000be6e:	d8 22       	popm	r4-r7,pc

8000be70 <__avr32_f64_mul_op1_zero>:
8000be70:	f7 e9 20 0b 	eor	r11,r11,r9
8000be74:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be78:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000be7c:	e0 4c 07 ff 	cp.w	r12,2047
8000be80:	5e 1c       	retne	r12
8000be82:	3f fa       	mov	r10,-1
8000be84:	3f fb       	mov	r11,-1
8000be86:	5e fc       	retal	r12

8000be88 <__avr32_f64_sub_from_add>:
8000be88:	ee 19 80 00 	eorh	r9,0x8000

8000be8c <__avr32_f64_sub>:
8000be8c:	f7 e9 20 0c 	eor	r12,r11,r9
8000be90:	e0 86 00 ca 	brmi	8000c024 <__avr32_f64_add_from_sub>
8000be94:	eb cd 40 e0 	pushm	r5-r7,lr
8000be98:	16 9c       	mov	r12,r11
8000be9a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000be9e:	bf db       	cbr	r11,0x1f
8000bea0:	bf d9       	cbr	r9,0x1f
8000bea2:	10 3a       	cp.w	r10,r8
8000bea4:	f2 0b 13 00 	cpc	r11,r9
8000bea8:	c0 92       	brcc	8000beba <__avr32_f64_sub+0x2e>
8000beaa:	16 97       	mov	r7,r11
8000beac:	12 9b       	mov	r11,r9
8000beae:	0e 99       	mov	r9,r7
8000beb0:	14 97       	mov	r7,r10
8000beb2:	10 9a       	mov	r10,r8
8000beb4:	0e 98       	mov	r8,r7
8000beb6:	ee 1c 80 00 	eorh	r12,0x8000
8000beba:	f6 07 16 14 	lsr	r7,r11,0x14
8000bebe:	ab 7b       	lsl	r11,0xb
8000bec0:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bec4:	ab 7a       	lsl	r10,0xb
8000bec6:	bf bb       	sbr	r11,0x1f
8000bec8:	f2 06 16 14 	lsr	r6,r9,0x14
8000becc:	c4 40       	breq	8000bf54 <__avr32_f64_sub_opL_subnormal>
8000bece:	ab 79       	lsl	r9,0xb
8000bed0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bed4:	ab 78       	lsl	r8,0xb
8000bed6:	bf b9       	sbr	r9,0x1f

8000bed8 <__avr32_f64_sub_opL_subnormal_done>:
8000bed8:	e0 47 07 ff 	cp.w	r7,2047
8000bedc:	c4 f0       	breq	8000bf7a <__avr32_f64_sub_opH_nan_or_inf>
8000bede:	0e 26       	rsub	r6,r7
8000bee0:	c1 20       	breq	8000bf04 <__avr32_f64_sub_shift_done>
8000bee2:	ec 05 11 20 	rsub	r5,r6,32
8000bee6:	e0 46 00 20 	cp.w	r6,32
8000beea:	c7 c2       	brcc	8000bfe2 <__avr32_f64_sub_longshift>
8000beec:	f0 05 09 4e 	lsl	lr,r8,r5
8000bef0:	f2 05 09 45 	lsl	r5,r9,r5
8000bef4:	f0 06 0a 48 	lsr	r8,r8,r6
8000bef8:	f2 06 0a 49 	lsr	r9,r9,r6
8000befc:	0a 48       	or	r8,r5
8000befe:	58 0e       	cp.w	lr,0
8000bf00:	5f 1e       	srne	lr
8000bf02:	1c 48       	or	r8,lr

8000bf04 <__avr32_f64_sub_shift_done>:
8000bf04:	10 1a       	sub	r10,r8
8000bf06:	f6 09 01 4b 	sbc	r11,r11,r9
8000bf0a:	f6 06 12 00 	clz	r6,r11
8000bf0e:	c0 e0       	breq	8000bf2a <__avr32_f64_sub_longnormalize_done>
8000bf10:	c7 83       	brcs	8000c000 <__avr32_f64_sub_longnormalize>
8000bf12:	ec 0e 11 20 	rsub	lr,r6,32
8000bf16:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf1a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bf1e:	1c 4b       	or	r11,lr
8000bf20:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf24:	0c 17       	sub	r7,r6
8000bf26:	e0 8a 00 39 	brle	8000bf98 <__avr32_f64_sub_subnormal_result>

8000bf2a <__avr32_f64_sub_longnormalize_done>:
8000bf2a:	f4 09 15 15 	lsl	r9,r10,0x15
8000bf2e:	ab 9a       	lsr	r10,0xb
8000bf30:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf34:	ab 9b       	lsr	r11,0xb
8000bf36:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bf3a:	18 4b       	or	r11,r12

8000bf3c <__avr32_f64_sub_round>:
8000bf3c:	fc 17 80 00 	movh	r7,0x8000
8000bf40:	ed ba 00 00 	bld	r10,0x0
8000bf44:	f7 b7 01 ff 	subne	r7,-1
8000bf48:	0e 39       	cp.w	r9,r7
8000bf4a:	5f 29       	srhs	r9
8000bf4c:	12 0a       	add	r10,r9
8000bf4e:	5c 0b       	acr	r11
8000bf50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf54 <__avr32_f64_sub_opL_subnormal>:
8000bf54:	ab 79       	lsl	r9,0xb
8000bf56:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bf5a:	ab 78       	lsl	r8,0xb
8000bf5c:	f3 e8 10 0e 	or	lr,r9,r8
8000bf60:	f9 b6 01 01 	movne	r6,1
8000bf64:	ee 0e 11 00 	rsub	lr,r7,0
8000bf68:	f9 b7 00 01 	moveq	r7,1
8000bf6c:	ef bb 00 1f 	bst	r11,0x1f
8000bf70:	f7 ea 10 0e 	or	lr,r11,r10
8000bf74:	f9 b7 00 00 	moveq	r7,0
8000bf78:	cb 0b       	rjmp	8000bed8 <__avr32_f64_sub_opL_subnormal_done>

8000bf7a <__avr32_f64_sub_opH_nan_or_inf>:
8000bf7a:	bf db       	cbr	r11,0x1f
8000bf7c:	f7 ea 10 0e 	or	lr,r11,r10
8000bf80:	c0 81       	brne	8000bf90 <__avr32_f64_sub_return_nan>
8000bf82:	e0 46 07 ff 	cp.w	r6,2047
8000bf86:	c0 50       	breq	8000bf90 <__avr32_f64_sub_return_nan>
8000bf88:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bf8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf90 <__avr32_f64_sub_return_nan>:
8000bf90:	3f fa       	mov	r10,-1
8000bf92:	3f fb       	mov	r11,-1
8000bf94:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf98 <__avr32_f64_sub_subnormal_result>:
8000bf98:	5c 37       	neg	r7
8000bf9a:	2f f7       	sub	r7,-1
8000bf9c:	f1 b7 04 c0 	satu	r7,0x6
8000bfa0:	e0 47 00 20 	cp.w	r7,32
8000bfa4:	c1 14       	brge	8000bfc6 <__avr32_f64_sub_subnormal_result+0x2e>
8000bfa6:	ee 08 11 20 	rsub	r8,r7,32
8000bfaa:	f4 08 09 49 	lsl	r9,r10,r8
8000bfae:	5f 16       	srne	r6
8000bfb0:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bfb4:	0c 4a       	or	r10,r6
8000bfb6:	f6 08 09 49 	lsl	r9,r11,r8
8000bfba:	f5 e9 10 0a 	or	r10,r10,r9
8000bfbe:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bfc2:	30 07       	mov	r7,0
8000bfc4:	cb 3b       	rjmp	8000bf2a <__avr32_f64_sub_longnormalize_done>
8000bfc6:	ee 08 11 40 	rsub	r8,r7,64
8000bfca:	f6 08 09 49 	lsl	r9,r11,r8
8000bfce:	14 49       	or	r9,r10
8000bfd0:	5f 16       	srne	r6
8000bfd2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bfd6:	0c 4a       	or	r10,r6
8000bfd8:	30 0b       	mov	r11,0
8000bfda:	30 07       	mov	r7,0
8000bfdc:	ca 7b       	rjmp	8000bf2a <__avr32_f64_sub_longnormalize_done>
8000bfde:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bfe2 <__avr32_f64_sub_longshift>:
8000bfe2:	f1 b6 04 c0 	satu	r6,0x6
8000bfe6:	f0 0e 17 00 	moveq	lr,r8
8000bfea:	c0 40       	breq	8000bff2 <__avr32_f64_sub_longshift+0x10>
8000bfec:	f2 05 09 4e 	lsl	lr,r9,r5
8000bff0:	10 4e       	or	lr,r8
8000bff2:	f2 06 0a 48 	lsr	r8,r9,r6
8000bff6:	30 09       	mov	r9,0
8000bff8:	58 0e       	cp.w	lr,0
8000bffa:	5f 1e       	srne	lr
8000bffc:	1c 48       	or	r8,lr
8000bffe:	c8 3b       	rjmp	8000bf04 <__avr32_f64_sub_shift_done>

8000c000 <__avr32_f64_sub_longnormalize>:
8000c000:	f4 06 12 00 	clz	r6,r10
8000c004:	f9 b7 03 00 	movlo	r7,0
8000c008:	f9 b6 03 00 	movlo	r6,0
8000c00c:	f9 bc 03 00 	movlo	r12,0
8000c010:	f7 b6 02 e0 	subhs	r6,-32
8000c014:	f4 06 09 4b 	lsl	r11,r10,r6
8000c018:	30 0a       	mov	r10,0
8000c01a:	0c 17       	sub	r7,r6
8000c01c:	fe 9a ff be 	brle	8000bf98 <__avr32_f64_sub_subnormal_result>
8000c020:	c8 5b       	rjmp	8000bf2a <__avr32_f64_sub_longnormalize_done>
8000c022:	d7 03       	nop

8000c024 <__avr32_f64_add_from_sub>:
8000c024:	ee 19 80 00 	eorh	r9,0x8000

8000c028 <__avr32_f64_add>:
8000c028:	f7 e9 20 0c 	eor	r12,r11,r9
8000c02c:	fe 96 ff 2e 	brmi	8000be88 <__avr32_f64_sub_from_add>
8000c030:	eb cd 40 e0 	pushm	r5-r7,lr
8000c034:	16 9c       	mov	r12,r11
8000c036:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c03a:	bf db       	cbr	r11,0x1f
8000c03c:	bf d9       	cbr	r9,0x1f
8000c03e:	12 3b       	cp.w	r11,r9
8000c040:	c0 72       	brcc	8000c04e <__avr32_f64_add+0x26>
8000c042:	16 97       	mov	r7,r11
8000c044:	12 9b       	mov	r11,r9
8000c046:	0e 99       	mov	r9,r7
8000c048:	14 97       	mov	r7,r10
8000c04a:	10 9a       	mov	r10,r8
8000c04c:	0e 98       	mov	r8,r7
8000c04e:	30 0e       	mov	lr,0
8000c050:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c054:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c058:	b5 ab       	sbr	r11,0x14
8000c05a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c05e:	c6 20       	breq	8000c122 <__avr32_f64_add_op2_subnormal>
8000c060:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c064:	b5 a9       	sbr	r9,0x14
8000c066:	e0 47 07 ff 	cp.w	r7,2047
8000c06a:	c2 80       	breq	8000c0ba <__avr32_f64_add_opH_nan_or_inf>
8000c06c:	0e 26       	rsub	r6,r7
8000c06e:	c1 20       	breq	8000c092 <__avr32_f64_add_shift_done>
8000c070:	e0 46 00 36 	cp.w	r6,54
8000c074:	c1 52       	brcc	8000c09e <__avr32_f64_add_res_of_done>
8000c076:	ec 05 11 20 	rsub	r5,r6,32
8000c07a:	e0 46 00 20 	cp.w	r6,32
8000c07e:	c3 52       	brcc	8000c0e8 <__avr32_f64_add_longshift>
8000c080:	f0 05 09 4e 	lsl	lr,r8,r5
8000c084:	f2 05 09 45 	lsl	r5,r9,r5
8000c088:	f0 06 0a 48 	lsr	r8,r8,r6
8000c08c:	f2 06 0a 49 	lsr	r9,r9,r6
8000c090:	0a 48       	or	r8,r5

8000c092 <__avr32_f64_add_shift_done>:
8000c092:	10 0a       	add	r10,r8
8000c094:	f6 09 00 4b 	adc	r11,r11,r9
8000c098:	ed bb 00 15 	bld	r11,0x15
8000c09c:	c3 40       	breq	8000c104 <__avr32_f64_add_res_of>

8000c09e <__avr32_f64_add_res_of_done>:
8000c09e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0a2:	18 4b       	or	r11,r12

8000c0a4 <__avr32_f64_add_round>:
8000c0a4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c0a8:	18 4e       	or	lr,r12
8000c0aa:	ee 1e 80 00 	eorh	lr,0x8000
8000c0ae:	f1 be 04 20 	satu	lr,0x1
8000c0b2:	1c 0a       	add	r10,lr
8000c0b4:	5c 0b       	acr	r11
8000c0b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0ba <__avr32_f64_add_opH_nan_or_inf>:
8000c0ba:	b5 cb       	cbr	r11,0x14
8000c0bc:	f7 ea 10 0e 	or	lr,r11,r10
8000c0c0:	c1 01       	brne	8000c0e0 <__avr32_f64_add_return_nan>
8000c0c2:	e0 46 07 ff 	cp.w	r6,2047
8000c0c6:	c0 30       	breq	8000c0cc <__avr32_f64_add_opL_nan_or_inf>
8000c0c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0cc <__avr32_f64_add_opL_nan_or_inf>:
8000c0cc:	b5 c9       	cbr	r9,0x14
8000c0ce:	f3 e8 10 0e 	or	lr,r9,r8
8000c0d2:	c0 71       	brne	8000c0e0 <__avr32_f64_add_return_nan>
8000c0d4:	30 0a       	mov	r10,0
8000c0d6:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c0da:	18 4b       	or	r11,r12
8000c0dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0e0 <__avr32_f64_add_return_nan>:
8000c0e0:	3f fa       	mov	r10,-1
8000c0e2:	3f fb       	mov	r11,-1
8000c0e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0e8 <__avr32_f64_add_longshift>:
8000c0e8:	f1 b6 04 c0 	satu	r6,0x6
8000c0ec:	f0 0e 17 00 	moveq	lr,r8
8000c0f0:	c0 60       	breq	8000c0fc <__avr32_f64_add_longshift+0x14>
8000c0f2:	f2 05 09 4e 	lsl	lr,r9,r5
8000c0f6:	58 08       	cp.w	r8,0
8000c0f8:	5f 18       	srne	r8
8000c0fa:	10 4e       	or	lr,r8
8000c0fc:	f2 06 0a 48 	lsr	r8,r9,r6
8000c100:	30 09       	mov	r9,0
8000c102:	cc 8b       	rjmp	8000c092 <__avr32_f64_add_shift_done>

8000c104 <__avr32_f64_add_res_of>:
8000c104:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c108:	a1 9b       	lsr	r11,0x1
8000c10a:	5d 0a       	ror	r10
8000c10c:	5d 0e       	ror	lr
8000c10e:	2f f7       	sub	r7,-1
8000c110:	e0 47 07 ff 	cp.w	r7,2047
8000c114:	f9 ba 00 00 	moveq	r10,0
8000c118:	f9 bb 00 00 	moveq	r11,0
8000c11c:	f9 be 00 00 	moveq	lr,0
8000c120:	cb fb       	rjmp	8000c09e <__avr32_f64_add_res_of_done>

8000c122 <__avr32_f64_add_op2_subnormal>:
8000c122:	30 16       	mov	r6,1
8000c124:	58 07       	cp.w	r7,0
8000c126:	ca 01       	brne	8000c066 <__avr32_f64_add+0x3e>
8000c128:	b5 cb       	cbr	r11,0x14
8000c12a:	10 0a       	add	r10,r8
8000c12c:	f6 09 00 4b 	adc	r11,r11,r9
8000c130:	18 4b       	or	r11,r12
8000c132:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c136:	d7 03       	nop

8000c138 <__avr32_f64_to_u32>:
8000c138:	58 0b       	cp.w	r11,0
8000c13a:	5e 6d       	retmi	0

8000c13c <__avr32_f64_to_s32>:
8000c13c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c140:	b5 9c       	lsr	r12,0x15
8000c142:	e0 2c 03 ff 	sub	r12,1023
8000c146:	5e 3d       	retlo	0
8000c148:	f8 0c 11 1f 	rsub	r12,r12,31
8000c14c:	16 99       	mov	r9,r11
8000c14e:	ab 7b       	lsl	r11,0xb
8000c150:	bf bb       	sbr	r11,0x1f
8000c152:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c156:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c15a:	a1 79       	lsl	r9,0x1
8000c15c:	5e 2b       	reths	r11
8000c15e:	5c 3b       	neg	r11
8000c160:	5e fb       	retal	r11

8000c162 <__avr32_u32_to_f64>:
8000c162:	f8 cb 00 00 	sub	r11,r12,0
8000c166:	30 0c       	mov	r12,0
8000c168:	c0 38       	rjmp	8000c16e <__avr32_s32_to_f64+0x4>

8000c16a <__avr32_s32_to_f64>:
8000c16a:	18 9b       	mov	r11,r12
8000c16c:	5c 4b       	abs	r11
8000c16e:	30 0a       	mov	r10,0
8000c170:	5e 0b       	reteq	r11
8000c172:	d4 01       	pushm	lr
8000c174:	e0 69 04 1e 	mov	r9,1054
8000c178:	f6 08 12 00 	clz	r8,r11
8000c17c:	c1 70       	breq	8000c1aa <__avr32_s32_to_f64+0x40>
8000c17e:	c0 c3       	brcs	8000c196 <__avr32_s32_to_f64+0x2c>
8000c180:	f0 0e 11 20 	rsub	lr,r8,32
8000c184:	f6 08 09 4b 	lsl	r11,r11,r8
8000c188:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c18c:	1c 4b       	or	r11,lr
8000c18e:	f4 08 09 4a 	lsl	r10,r10,r8
8000c192:	10 19       	sub	r9,r8
8000c194:	c0 b8       	rjmp	8000c1aa <__avr32_s32_to_f64+0x40>
8000c196:	f4 08 12 00 	clz	r8,r10
8000c19a:	f9 b8 03 00 	movlo	r8,0
8000c19e:	f7 b8 02 e0 	subhs	r8,-32
8000c1a2:	f4 08 09 4b 	lsl	r11,r10,r8
8000c1a6:	30 0a       	mov	r10,0
8000c1a8:	10 19       	sub	r9,r8
8000c1aa:	58 09       	cp.w	r9,0
8000c1ac:	e0 89 00 30 	brgt	8000c20c <__avr32_s32_to_f64+0xa2>
8000c1b0:	5c 39       	neg	r9
8000c1b2:	2f f9       	sub	r9,-1
8000c1b4:	e0 49 00 36 	cp.w	r9,54
8000c1b8:	c0 43       	brcs	8000c1c0 <__avr32_s32_to_f64+0x56>
8000c1ba:	30 0b       	mov	r11,0
8000c1bc:	30 0a       	mov	r10,0
8000c1be:	c2 68       	rjmp	8000c20a <__avr32_s32_to_f64+0xa0>
8000c1c0:	2f 69       	sub	r9,-10
8000c1c2:	f2 08 11 20 	rsub	r8,r9,32
8000c1c6:	e0 49 00 20 	cp.w	r9,32
8000c1ca:	c0 b2       	brcc	8000c1e0 <__avr32_s32_to_f64+0x76>
8000c1cc:	f4 08 09 4e 	lsl	lr,r10,r8
8000c1d0:	f6 08 09 48 	lsl	r8,r11,r8
8000c1d4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c1d8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c1dc:	10 4b       	or	r11,r8
8000c1de:	c0 88       	rjmp	8000c1ee <__avr32_s32_to_f64+0x84>
8000c1e0:	f6 08 09 4e 	lsl	lr,r11,r8
8000c1e4:	14 4e       	or	lr,r10
8000c1e6:	16 9a       	mov	r10,r11
8000c1e8:	30 0b       	mov	r11,0
8000c1ea:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c1ee:	ed ba 00 00 	bld	r10,0x0
8000c1f2:	c0 92       	brcc	8000c204 <__avr32_s32_to_f64+0x9a>
8000c1f4:	1c 7e       	tst	lr,lr
8000c1f6:	c0 41       	brne	8000c1fe <__avr32_s32_to_f64+0x94>
8000c1f8:	ed ba 00 01 	bld	r10,0x1
8000c1fc:	c0 42       	brcc	8000c204 <__avr32_s32_to_f64+0x9a>
8000c1fe:	2f fa       	sub	r10,-1
8000c200:	f7 bb 02 ff 	subhs	r11,-1
8000c204:	5c fc       	rol	r12
8000c206:	5d 0b       	ror	r11
8000c208:	5d 0a       	ror	r10
8000c20a:	d8 02       	popm	pc
8000c20c:	e0 68 03 ff 	mov	r8,1023
8000c210:	ed ba 00 0b 	bld	r10,0xb
8000c214:	f7 b8 00 ff 	subeq	r8,-1
8000c218:	10 0a       	add	r10,r8
8000c21a:	5c 0b       	acr	r11
8000c21c:	f7 b9 03 fe 	sublo	r9,-2
8000c220:	e0 49 07 ff 	cp.w	r9,2047
8000c224:	c0 55       	brlt	8000c22e <__avr32_s32_to_f64+0xc4>
8000c226:	30 0a       	mov	r10,0
8000c228:	fc 1b ff e0 	movh	r11,0xffe0
8000c22c:	c0 c8       	rjmp	8000c244 <__floatsidf_return_op1>
8000c22e:	ed bb 00 1f 	bld	r11,0x1f
8000c232:	f7 b9 01 01 	subne	r9,1
8000c236:	ab 9a       	lsr	r10,0xb
8000c238:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c23c:	a1 7b       	lsl	r11,0x1
8000c23e:	ab 9b       	lsr	r11,0xb
8000c240:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c244 <__floatsidf_return_op1>:
8000c244:	a1 7c       	lsl	r12,0x1
8000c246:	5d 0b       	ror	r11
8000c248:	d8 02       	popm	pc

8000c24a <__avr32_f64_cmp_eq>:
8000c24a:	10 3a       	cp.w	r10,r8
8000c24c:	f2 0b 13 00 	cpc	r11,r9
8000c250:	c0 80       	breq	8000c260 <__avr32_f64_cmp_eq+0x16>
8000c252:	a1 7b       	lsl	r11,0x1
8000c254:	a1 79       	lsl	r9,0x1
8000c256:	14 4b       	or	r11,r10
8000c258:	12 4b       	or	r11,r9
8000c25a:	10 4b       	or	r11,r8
8000c25c:	5e 0f       	reteq	1
8000c25e:	5e fd       	retal	0
8000c260:	a1 7b       	lsl	r11,0x1
8000c262:	fc 1c ff e0 	movh	r12,0xffe0
8000c266:	58 0a       	cp.w	r10,0
8000c268:	f8 0b 13 00 	cpc	r11,r12
8000c26c:	5e 8f       	retls	1
8000c26e:	5e fd       	retal	0

8000c270 <__avr32_f64_cmp_ge>:
8000c270:	1a de       	st.w	--sp,lr
8000c272:	1a d7       	st.w	--sp,r7
8000c274:	a1 7b       	lsl	r11,0x1
8000c276:	5f 3c       	srlo	r12
8000c278:	a1 79       	lsl	r9,0x1
8000c27a:	5f 37       	srlo	r7
8000c27c:	5c fc       	rol	r12
8000c27e:	fc 1e ff e0 	movh	lr,0xffe0
8000c282:	58 0a       	cp.w	r10,0
8000c284:	fc 0b 13 00 	cpc	r11,lr
8000c288:	e0 8b 00 1d 	brhi	8000c2c2 <__avr32_f64_cmp_ge+0x52>
8000c28c:	58 08       	cp.w	r8,0
8000c28e:	fc 09 13 00 	cpc	r9,lr
8000c292:	e0 8b 00 18 	brhi	8000c2c2 <__avr32_f64_cmp_ge+0x52>
8000c296:	58 0b       	cp.w	r11,0
8000c298:	f5 ba 00 00 	subfeq	r10,0
8000c29c:	c1 50       	breq	8000c2c6 <__avr32_f64_cmp_ge+0x56>
8000c29e:	1b 07       	ld.w	r7,sp++
8000c2a0:	1b 0e       	ld.w	lr,sp++
8000c2a2:	58 3c       	cp.w	r12,3
8000c2a4:	c0 a0       	breq	8000c2b8 <__avr32_f64_cmp_ge+0x48>
8000c2a6:	58 1c       	cp.w	r12,1
8000c2a8:	c0 33       	brcs	8000c2ae <__avr32_f64_cmp_ge+0x3e>
8000c2aa:	5e 0f       	reteq	1
8000c2ac:	5e 1d       	retne	0
8000c2ae:	10 3a       	cp.w	r10,r8
8000c2b0:	f2 0b 13 00 	cpc	r11,r9
8000c2b4:	5e 2f       	reths	1
8000c2b6:	5e 3d       	retlo	0
8000c2b8:	14 38       	cp.w	r8,r10
8000c2ba:	f6 09 13 00 	cpc	r9,r11
8000c2be:	5e 2f       	reths	1
8000c2c0:	5e 3d       	retlo	0
8000c2c2:	1b 07       	ld.w	r7,sp++
8000c2c4:	d8 0a       	popm	pc,r12=0
8000c2c6:	58 17       	cp.w	r7,1
8000c2c8:	5f 0c       	sreq	r12
8000c2ca:	58 09       	cp.w	r9,0
8000c2cc:	f5 b8 00 00 	subfeq	r8,0
8000c2d0:	1b 07       	ld.w	r7,sp++
8000c2d2:	1b 0e       	ld.w	lr,sp++
8000c2d4:	5e 0f       	reteq	1
8000c2d6:	5e fc       	retal	r12

8000c2d8 <__avr32_f64_cmp_lt>:
8000c2d8:	1a de       	st.w	--sp,lr
8000c2da:	1a d7       	st.w	--sp,r7
8000c2dc:	a1 7b       	lsl	r11,0x1
8000c2de:	5f 3c       	srlo	r12
8000c2e0:	a1 79       	lsl	r9,0x1
8000c2e2:	5f 37       	srlo	r7
8000c2e4:	5c fc       	rol	r12
8000c2e6:	fc 1e ff e0 	movh	lr,0xffe0
8000c2ea:	58 0a       	cp.w	r10,0
8000c2ec:	fc 0b 13 00 	cpc	r11,lr
8000c2f0:	e0 8b 00 1d 	brhi	8000c32a <__avr32_f64_cmp_lt+0x52>
8000c2f4:	58 08       	cp.w	r8,0
8000c2f6:	fc 09 13 00 	cpc	r9,lr
8000c2fa:	e0 8b 00 18 	brhi	8000c32a <__avr32_f64_cmp_lt+0x52>
8000c2fe:	58 0b       	cp.w	r11,0
8000c300:	f5 ba 00 00 	subfeq	r10,0
8000c304:	c1 50       	breq	8000c32e <__avr32_f64_cmp_lt+0x56>
8000c306:	1b 07       	ld.w	r7,sp++
8000c308:	1b 0e       	ld.w	lr,sp++
8000c30a:	58 3c       	cp.w	r12,3
8000c30c:	c0 a0       	breq	8000c320 <__avr32_f64_cmp_lt+0x48>
8000c30e:	58 1c       	cp.w	r12,1
8000c310:	c0 33       	brcs	8000c316 <__avr32_f64_cmp_lt+0x3e>
8000c312:	5e 0d       	reteq	0
8000c314:	5e 1f       	retne	1
8000c316:	10 3a       	cp.w	r10,r8
8000c318:	f2 0b 13 00 	cpc	r11,r9
8000c31c:	5e 2d       	reths	0
8000c31e:	5e 3f       	retlo	1
8000c320:	14 38       	cp.w	r8,r10
8000c322:	f6 09 13 00 	cpc	r9,r11
8000c326:	5e 2d       	reths	0
8000c328:	5e 3f       	retlo	1
8000c32a:	1b 07       	ld.w	r7,sp++
8000c32c:	d8 0a       	popm	pc,r12=0
8000c32e:	58 17       	cp.w	r7,1
8000c330:	5f 1c       	srne	r12
8000c332:	58 09       	cp.w	r9,0
8000c334:	f5 b8 00 00 	subfeq	r8,0
8000c338:	1b 07       	ld.w	r7,sp++
8000c33a:	1b 0e       	ld.w	lr,sp++
8000c33c:	5e 0d       	reteq	0
8000c33e:	5e fc       	retal	r12

8000c340 <__avr32_f64_div>:
8000c340:	eb cd 40 ff 	pushm	r0-r7,lr
8000c344:	f7 e9 20 0e 	eor	lr,r11,r9
8000c348:	f6 07 16 14 	lsr	r7,r11,0x14
8000c34c:	a9 7b       	lsl	r11,0x9
8000c34e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c352:	a9 7a       	lsl	r10,0x9
8000c354:	bd bb       	sbr	r11,0x1d
8000c356:	e4 1b 3f ff 	andh	r11,0x3fff
8000c35a:	ab d7       	cbr	r7,0xb
8000c35c:	e0 80 00 cc 	breq	8000c4f4 <__avr32_f64_div_round_subnormal+0x54>
8000c360:	e0 47 07 ff 	cp.w	r7,2047
8000c364:	e0 84 00 b5 	brge	8000c4ce <__avr32_f64_div_round_subnormal+0x2e>
8000c368:	f2 06 16 14 	lsr	r6,r9,0x14
8000c36c:	a9 79       	lsl	r9,0x9
8000c36e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c372:	a9 78       	lsl	r8,0x9
8000c374:	bd b9       	sbr	r9,0x1d
8000c376:	e4 19 3f ff 	andh	r9,0x3fff
8000c37a:	ab d6       	cbr	r6,0xb
8000c37c:	e0 80 00 e2 	breq	8000c540 <__avr32_f64_div_round_subnormal+0xa0>
8000c380:	e0 46 07 ff 	cp.w	r6,2047
8000c384:	e0 84 00 b2 	brge	8000c4e8 <__avr32_f64_div_round_subnormal+0x48>
8000c388:	0c 17       	sub	r7,r6
8000c38a:	fe 37 fc 01 	sub	r7,-1023
8000c38e:	fc 1c 80 00 	movh	r12,0x8000
8000c392:	f8 03 16 01 	lsr	r3,r12,0x1
8000c396:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c39a:	5c d4       	com	r4
8000c39c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c3a0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3a4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c3a8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3ac:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3b0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3b4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c3b8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3bc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3c0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3c4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c3c8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3cc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3d0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c3d4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c3d8:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3dc:	02 04       	add	r4,r1
8000c3de:	5c 05       	acr	r5
8000c3e0:	a3 65       	lsl	r5,0x2
8000c3e2:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c3e6:	a3 64       	lsl	r4,0x2
8000c3e8:	5c 34       	neg	r4
8000c3ea:	f8 05 01 45 	sbc	r5,r12,r5
8000c3ee:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c3f2:	e4 05 07 40 	macu.d	r0,r2,r5
8000c3f6:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3fa:	02 04       	add	r4,r1
8000c3fc:	5c 05       	acr	r5
8000c3fe:	ea 03 15 02 	lsl	r3,r5,0x2
8000c402:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c406:	e8 02 15 02 	lsl	r2,r4,0x2
8000c40a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c40e:	e4 09 07 40 	macu.d	r0,r2,r9
8000c412:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c416:	02 04       	add	r4,r1
8000c418:	5c 05       	acr	r5
8000c41a:	a3 65       	lsl	r5,0x2
8000c41c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c420:	a3 64       	lsl	r4,0x2
8000c422:	5c 34       	neg	r4
8000c424:	f8 05 01 45 	sbc	r5,r12,r5
8000c428:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c42c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c430:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c434:	02 04       	add	r4,r1
8000c436:	5c 05       	acr	r5
8000c438:	ea 03 15 02 	lsl	r3,r5,0x2
8000c43c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c440:	e8 02 15 02 	lsl	r2,r4,0x2
8000c444:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c448:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c44c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c450:	02 02       	add	r2,r1
8000c452:	5c 03       	acr	r3
8000c454:	ed b3 00 1c 	bld	r3,0x1c
8000c458:	c0 90       	breq	8000c46a <__avr32_f64_div+0x12a>
8000c45a:	a1 72       	lsl	r2,0x1
8000c45c:	5c f3       	rol	r3
8000c45e:	20 17       	sub	r7,1
8000c460:	a3 9a       	lsr	r10,0x3
8000c462:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c466:	a3 9b       	lsr	r11,0x3
8000c468:	c0 58       	rjmp	8000c472 <__avr32_f64_div+0x132>
8000c46a:	a5 8a       	lsr	r10,0x4
8000c46c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c470:	a5 8b       	lsr	r11,0x4
8000c472:	58 07       	cp.w	r7,0
8000c474:	e0 8a 00 8b 	brle	8000c58a <__avr32_f64_div_res_subnormal>
8000c478:	e0 12 ff 00 	andl	r2,0xff00
8000c47c:	e8 12 00 80 	orl	r2,0x80
8000c480:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c484:	e4 09 07 40 	macu.d	r0,r2,r9
8000c488:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c48c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c490:	00 05       	add	r5,r0
8000c492:	f0 01 00 48 	adc	r8,r8,r1
8000c496:	5c 09       	acr	r9
8000c498:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c49c:	58 04       	cp.w	r4,0
8000c49e:	5c 25       	cpc	r5

8000c4a0 <__avr32_f64_div_round_subnormal>:
8000c4a0:	f4 08 13 00 	cpc	r8,r10
8000c4a4:	f6 09 13 00 	cpc	r9,r11
8000c4a8:	5f 36       	srlo	r6
8000c4aa:	f8 06 17 00 	moveq	r6,r12
8000c4ae:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c4b2:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c4b6:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c4ba:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c4be:	ed be 00 1f 	bld	lr,0x1f
8000c4c2:	ef bb 00 1f 	bst	r11,0x1f
8000c4c6:	0c 0a       	add	r10,r6
8000c4c8:	5c 0b       	acr	r11
8000c4ca:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c4ce:	e4 1b 00 0f 	andh	r11,0xf
8000c4d2:	14 4b       	or	r11,r10
8000c4d4:	e0 81 00 a7 	brne	8000c622 <__avr32_f64_div_res_subnormal+0x98>
8000c4d8:	f2 06 16 14 	lsr	r6,r9,0x14
8000c4dc:	ab d6       	cbr	r6,0xb
8000c4de:	e0 46 07 ff 	cp.w	r6,2047
8000c4e2:	e0 81 00 a4 	brne	8000c62a <__avr32_f64_div_res_subnormal+0xa0>
8000c4e6:	c9 e8       	rjmp	8000c622 <__avr32_f64_div_res_subnormal+0x98>
8000c4e8:	e4 19 00 0f 	andh	r9,0xf
8000c4ec:	10 49       	or	r9,r8
8000c4ee:	e0 81 00 9a 	brne	8000c622 <__avr32_f64_div_res_subnormal+0x98>
8000c4f2:	c9 28       	rjmp	8000c616 <__avr32_f64_div_res_subnormal+0x8c>
8000c4f4:	a3 7b       	lsl	r11,0x3
8000c4f6:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c4fa:	a3 7a       	lsl	r10,0x3
8000c4fc:	f5 eb 10 04 	or	r4,r10,r11
8000c500:	e0 80 00 a0 	breq	8000c640 <__avr32_f64_div_op1_zero>
8000c504:	f6 04 12 00 	clz	r4,r11
8000c508:	c1 70       	breq	8000c536 <__avr32_f64_div_round_subnormal+0x96>
8000c50a:	c0 c3       	brcs	8000c522 <__avr32_f64_div_round_subnormal+0x82>
8000c50c:	e8 05 11 20 	rsub	r5,r4,32
8000c510:	f6 04 09 4b 	lsl	r11,r11,r4
8000c514:	f4 05 0a 45 	lsr	r5,r10,r5
8000c518:	0a 4b       	or	r11,r5
8000c51a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c51e:	08 17       	sub	r7,r4
8000c520:	c0 b8       	rjmp	8000c536 <__avr32_f64_div_round_subnormal+0x96>
8000c522:	f4 04 12 00 	clz	r4,r10
8000c526:	f9 b4 03 00 	movlo	r4,0
8000c52a:	f7 b4 02 e0 	subhs	r4,-32
8000c52e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c532:	30 0a       	mov	r10,0
8000c534:	08 17       	sub	r7,r4
8000c536:	a3 8a       	lsr	r10,0x2
8000c538:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c53c:	a3 8b       	lsr	r11,0x2
8000c53e:	c1 1b       	rjmp	8000c360 <__avr32_f64_div+0x20>
8000c540:	a3 79       	lsl	r9,0x3
8000c542:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c546:	a3 78       	lsl	r8,0x3
8000c548:	f3 e8 10 04 	or	r4,r9,r8
8000c54c:	c6 f0       	breq	8000c62a <__avr32_f64_div_res_subnormal+0xa0>
8000c54e:	f2 04 12 00 	clz	r4,r9
8000c552:	c1 70       	breq	8000c580 <__avr32_f64_div_round_subnormal+0xe0>
8000c554:	c0 c3       	brcs	8000c56c <__avr32_f64_div_round_subnormal+0xcc>
8000c556:	e8 05 11 20 	rsub	r5,r4,32
8000c55a:	f2 04 09 49 	lsl	r9,r9,r4
8000c55e:	f0 05 0a 45 	lsr	r5,r8,r5
8000c562:	0a 49       	or	r9,r5
8000c564:	f0 04 09 48 	lsl	r8,r8,r4
8000c568:	08 16       	sub	r6,r4
8000c56a:	c0 b8       	rjmp	8000c580 <__avr32_f64_div_round_subnormal+0xe0>
8000c56c:	f0 04 12 00 	clz	r4,r8
8000c570:	f9 b4 03 00 	movlo	r4,0
8000c574:	f7 b4 02 e0 	subhs	r4,-32
8000c578:	f0 04 09 49 	lsl	r9,r8,r4
8000c57c:	30 08       	mov	r8,0
8000c57e:	08 16       	sub	r6,r4
8000c580:	a3 88       	lsr	r8,0x2
8000c582:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c586:	a3 89       	lsr	r9,0x2
8000c588:	cf ca       	rjmp	8000c380 <__avr32_f64_div+0x40>

8000c58a <__avr32_f64_div_res_subnormal>:
8000c58a:	5c 37       	neg	r7
8000c58c:	2f f7       	sub	r7,-1
8000c58e:	f1 b7 04 c0 	satu	r7,0x6
8000c592:	e0 47 00 20 	cp.w	r7,32
8000c596:	c1 54       	brge	8000c5c0 <__avr32_f64_div_res_subnormal+0x36>
8000c598:	ee 06 11 20 	rsub	r6,r7,32
8000c59c:	e4 07 0a 42 	lsr	r2,r2,r7
8000c5a0:	e6 06 09 4c 	lsl	r12,r3,r6
8000c5a4:	18 42       	or	r2,r12
8000c5a6:	e6 07 0a 43 	lsr	r3,r3,r7
8000c5aa:	f4 06 09 41 	lsl	r1,r10,r6
8000c5ae:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c5b2:	f6 06 09 4c 	lsl	r12,r11,r6
8000c5b6:	18 4a       	or	r10,r12
8000c5b8:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c5bc:	30 00       	mov	r0,0
8000c5be:	c1 58       	rjmp	8000c5e8 <__avr32_f64_div_res_subnormal+0x5e>
8000c5c0:	ee 06 11 20 	rsub	r6,r7,32
8000c5c4:	f9 b0 00 00 	moveq	r0,0
8000c5c8:	f9 bc 00 00 	moveq	r12,0
8000c5cc:	c0 50       	breq	8000c5d6 <__avr32_f64_div_res_subnormal+0x4c>
8000c5ce:	f4 06 09 40 	lsl	r0,r10,r6
8000c5d2:	f6 06 09 4c 	lsl	r12,r11,r6
8000c5d6:	e6 07 0a 42 	lsr	r2,r3,r7
8000c5da:	30 03       	mov	r3,0
8000c5dc:	f4 07 0a 41 	lsr	r1,r10,r7
8000c5e0:	18 41       	or	r1,r12
8000c5e2:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c5e6:	30 0b       	mov	r11,0
8000c5e8:	e0 12 ff 00 	andl	r2,0xff00
8000c5ec:	e8 12 00 80 	orl	r2,0x80
8000c5f0:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c5f4:	e4 09 07 46 	macu.d	r6,r2,r9
8000c5f8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c5fc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c600:	0c 05       	add	r5,r6
8000c602:	f0 07 00 48 	adc	r8,r8,r7
8000c606:	5c 09       	acr	r9
8000c608:	30 07       	mov	r7,0
8000c60a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c60e:	00 34       	cp.w	r4,r0
8000c610:	e2 05 13 00 	cpc	r5,r1
8000c614:	c4 6b       	rjmp	8000c4a0 <__avr32_f64_div_round_subnormal>
8000c616:	1c 9b       	mov	r11,lr
8000c618:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c61c:	30 0a       	mov	r10,0
8000c61e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c622:	3f fb       	mov	r11,-1
8000c624:	30 0a       	mov	r10,0
8000c626:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c62a:	f5 eb 10 04 	or	r4,r10,r11
8000c62e:	c0 90       	breq	8000c640 <__avr32_f64_div_op1_zero>
8000c630:	1c 9b       	mov	r11,lr
8000c632:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c636:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c63a:	30 0a       	mov	r10,0
8000c63c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c640 <__avr32_f64_div_op1_zero>:
8000c640:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c644:	ce f0       	breq	8000c622 <__avr32_f64_div_res_subnormal+0x98>
8000c646:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c64a:	e0 44 07 ff 	cp.w	r4,2047
8000c64e:	ce 41       	brne	8000c616 <__avr32_f64_div_res_subnormal+0x8c>
8000c650:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c654:	ce 10       	breq	8000c616 <__avr32_f64_div_res_subnormal+0x8c>
8000c656:	ce 6b       	rjmp	8000c622 <__avr32_f64_div_res_subnormal+0x98>

8000c658 <__avr32_udiv64>:
8000c658:	d4 31       	pushm	r0-r7,lr
8000c65a:	1a 97       	mov	r7,sp
8000c65c:	20 3d       	sub	sp,12
8000c65e:	10 9c       	mov	r12,r8
8000c660:	12 9e       	mov	lr,r9
8000c662:	14 93       	mov	r3,r10
8000c664:	58 09       	cp.w	r9,0
8000c666:	e0 81 00 bd 	brne	8000c7e0 <__avr32_udiv64+0x188>
8000c66a:	16 38       	cp.w	r8,r11
8000c66c:	e0 88 00 40 	brls	8000c6ec <__avr32_udiv64+0x94>
8000c670:	f0 08 12 00 	clz	r8,r8
8000c674:	c0 d0       	breq	8000c68e <__avr32_udiv64+0x36>
8000c676:	f6 08 09 4b 	lsl	r11,r11,r8
8000c67a:	f0 09 11 20 	rsub	r9,r8,32
8000c67e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c682:	f4 09 0a 49 	lsr	r9,r10,r9
8000c686:	f4 08 09 43 	lsl	r3,r10,r8
8000c68a:	f3 eb 10 0b 	or	r11,r9,r11
8000c68e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c692:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c696:	f6 0e 0d 00 	divu	r0,r11,lr
8000c69a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c69e:	00 99       	mov	r9,r0
8000c6a0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c6a4:	e0 0a 02 48 	mul	r8,r0,r10
8000c6a8:	10 3b       	cp.w	r11,r8
8000c6aa:	c0 a2       	brcc	8000c6be <__avr32_udiv64+0x66>
8000c6ac:	20 19       	sub	r9,1
8000c6ae:	18 0b       	add	r11,r12
8000c6b0:	18 3b       	cp.w	r11,r12
8000c6b2:	c0 63       	brcs	8000c6be <__avr32_udiv64+0x66>
8000c6b4:	10 3b       	cp.w	r11,r8
8000c6b6:	f7 b9 03 01 	sublo	r9,1
8000c6ba:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c6be:	f6 08 01 01 	sub	r1,r11,r8
8000c6c2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c6c6:	e2 0e 0d 00 	divu	r0,r1,lr
8000c6ca:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c6ce:	00 98       	mov	r8,r0
8000c6d0:	e0 0a 02 4a 	mul	r10,r0,r10
8000c6d4:	14 33       	cp.w	r3,r10
8000c6d6:	c0 82       	brcc	8000c6e6 <__avr32_udiv64+0x8e>
8000c6d8:	20 18       	sub	r8,1
8000c6da:	18 03       	add	r3,r12
8000c6dc:	18 33       	cp.w	r3,r12
8000c6de:	c0 43       	brcs	8000c6e6 <__avr32_udiv64+0x8e>
8000c6e0:	14 33       	cp.w	r3,r10
8000c6e2:	f7 b8 03 01 	sublo	r8,1
8000c6e6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c6ea:	cd f8       	rjmp	8000c8a8 <__avr32_udiv64+0x250>
8000c6ec:	58 08       	cp.w	r8,0
8000c6ee:	c0 51       	brne	8000c6f8 <__avr32_udiv64+0xa0>
8000c6f0:	30 19       	mov	r9,1
8000c6f2:	f2 08 0d 08 	divu	r8,r9,r8
8000c6f6:	10 9c       	mov	r12,r8
8000c6f8:	f8 06 12 00 	clz	r6,r12
8000c6fc:	c0 41       	brne	8000c704 <__avr32_udiv64+0xac>
8000c6fe:	18 1b       	sub	r11,r12
8000c700:	30 19       	mov	r9,1
8000c702:	c4 08       	rjmp	8000c782 <__avr32_udiv64+0x12a>
8000c704:	ec 01 11 20 	rsub	r1,r6,32
8000c708:	f4 01 0a 49 	lsr	r9,r10,r1
8000c70c:	f8 06 09 4c 	lsl	r12,r12,r6
8000c710:	f6 06 09 48 	lsl	r8,r11,r6
8000c714:	f6 01 0a 41 	lsr	r1,r11,r1
8000c718:	f3 e8 10 08 	or	r8,r9,r8
8000c71c:	f8 03 16 10 	lsr	r3,r12,0x10
8000c720:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c724:	e2 03 0d 00 	divu	r0,r1,r3
8000c728:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c72c:	00 9e       	mov	lr,r0
8000c72e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c732:	e0 05 02 49 	mul	r9,r0,r5
8000c736:	12 3b       	cp.w	r11,r9
8000c738:	c0 a2       	brcc	8000c74c <__avr32_udiv64+0xf4>
8000c73a:	20 1e       	sub	lr,1
8000c73c:	18 0b       	add	r11,r12
8000c73e:	18 3b       	cp.w	r11,r12
8000c740:	c0 63       	brcs	8000c74c <__avr32_udiv64+0xf4>
8000c742:	12 3b       	cp.w	r11,r9
8000c744:	f7 be 03 01 	sublo	lr,1
8000c748:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c74c:	12 1b       	sub	r11,r9
8000c74e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c752:	f6 03 0d 02 	divu	r2,r11,r3
8000c756:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c75a:	04 99       	mov	r9,r2
8000c75c:	e4 05 02 4b 	mul	r11,r2,r5
8000c760:	16 38       	cp.w	r8,r11
8000c762:	c0 a2       	brcc	8000c776 <__avr32_udiv64+0x11e>
8000c764:	20 19       	sub	r9,1
8000c766:	18 08       	add	r8,r12
8000c768:	18 38       	cp.w	r8,r12
8000c76a:	c0 63       	brcs	8000c776 <__avr32_udiv64+0x11e>
8000c76c:	16 38       	cp.w	r8,r11
8000c76e:	f7 b9 03 01 	sublo	r9,1
8000c772:	f1 dc e3 08 	addcs	r8,r8,r12
8000c776:	f4 06 09 43 	lsl	r3,r10,r6
8000c77a:	f0 0b 01 0b 	sub	r11,r8,r11
8000c77e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c782:	f8 06 16 10 	lsr	r6,r12,0x10
8000c786:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c78a:	f6 06 0d 00 	divu	r0,r11,r6
8000c78e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c792:	00 9a       	mov	r10,r0
8000c794:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c798:	e0 0e 02 48 	mul	r8,r0,lr
8000c79c:	10 3b       	cp.w	r11,r8
8000c79e:	c0 a2       	brcc	8000c7b2 <__avr32_udiv64+0x15a>
8000c7a0:	20 1a       	sub	r10,1
8000c7a2:	18 0b       	add	r11,r12
8000c7a4:	18 3b       	cp.w	r11,r12
8000c7a6:	c0 63       	brcs	8000c7b2 <__avr32_udiv64+0x15a>
8000c7a8:	10 3b       	cp.w	r11,r8
8000c7aa:	f7 ba 03 01 	sublo	r10,1
8000c7ae:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7b2:	f6 08 01 01 	sub	r1,r11,r8
8000c7b6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c7ba:	e2 06 0d 00 	divu	r0,r1,r6
8000c7be:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c7c2:	00 98       	mov	r8,r0
8000c7c4:	e0 0e 02 4b 	mul	r11,r0,lr
8000c7c8:	16 33       	cp.w	r3,r11
8000c7ca:	c0 82       	brcc	8000c7da <__avr32_udiv64+0x182>
8000c7cc:	20 18       	sub	r8,1
8000c7ce:	18 03       	add	r3,r12
8000c7d0:	18 33       	cp.w	r3,r12
8000c7d2:	c0 43       	brcs	8000c7da <__avr32_udiv64+0x182>
8000c7d4:	16 33       	cp.w	r3,r11
8000c7d6:	f7 b8 03 01 	sublo	r8,1
8000c7da:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c7de:	c6 98       	rjmp	8000c8b0 <__avr32_udiv64+0x258>
8000c7e0:	16 39       	cp.w	r9,r11
8000c7e2:	e0 8b 00 65 	brhi	8000c8ac <__avr32_udiv64+0x254>
8000c7e6:	f2 09 12 00 	clz	r9,r9
8000c7ea:	c0 b1       	brne	8000c800 <__avr32_udiv64+0x1a8>
8000c7ec:	10 3a       	cp.w	r10,r8
8000c7ee:	5f 2a       	srhs	r10
8000c7f0:	1c 3b       	cp.w	r11,lr
8000c7f2:	5f b8       	srhi	r8
8000c7f4:	10 4a       	or	r10,r8
8000c7f6:	f2 0a 18 00 	cp.b	r10,r9
8000c7fa:	c5 90       	breq	8000c8ac <__avr32_udiv64+0x254>
8000c7fc:	30 18       	mov	r8,1
8000c7fe:	c5 98       	rjmp	8000c8b0 <__avr32_udiv64+0x258>
8000c800:	f0 09 09 46 	lsl	r6,r8,r9
8000c804:	f2 03 11 20 	rsub	r3,r9,32
8000c808:	fc 09 09 4e 	lsl	lr,lr,r9
8000c80c:	f0 03 0a 48 	lsr	r8,r8,r3
8000c810:	f6 09 09 4c 	lsl	r12,r11,r9
8000c814:	f4 03 0a 42 	lsr	r2,r10,r3
8000c818:	ef 46 ff f4 	st.w	r7[-12],r6
8000c81c:	f6 03 0a 43 	lsr	r3,r11,r3
8000c820:	18 42       	or	r2,r12
8000c822:	f1 ee 10 0c 	or	r12,r8,lr
8000c826:	f8 01 16 10 	lsr	r1,r12,0x10
8000c82a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c82e:	e6 01 0d 04 	divu	r4,r3,r1
8000c832:	e4 03 16 10 	lsr	r3,r2,0x10
8000c836:	08 9e       	mov	lr,r4
8000c838:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c83c:	e8 06 02 48 	mul	r8,r4,r6
8000c840:	10 33       	cp.w	r3,r8
8000c842:	c0 a2       	brcc	8000c856 <__avr32_udiv64+0x1fe>
8000c844:	20 1e       	sub	lr,1
8000c846:	18 03       	add	r3,r12
8000c848:	18 33       	cp.w	r3,r12
8000c84a:	c0 63       	brcs	8000c856 <__avr32_udiv64+0x1fe>
8000c84c:	10 33       	cp.w	r3,r8
8000c84e:	f7 be 03 01 	sublo	lr,1
8000c852:	e7 dc e3 03 	addcs	r3,r3,r12
8000c856:	10 13       	sub	r3,r8
8000c858:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c85c:	e6 01 0d 00 	divu	r0,r3,r1
8000c860:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c864:	00 98       	mov	r8,r0
8000c866:	e0 06 02 46 	mul	r6,r0,r6
8000c86a:	0c 3b       	cp.w	r11,r6
8000c86c:	c0 a2       	brcc	8000c880 <__avr32_udiv64+0x228>
8000c86e:	20 18       	sub	r8,1
8000c870:	18 0b       	add	r11,r12
8000c872:	18 3b       	cp.w	r11,r12
8000c874:	c0 63       	brcs	8000c880 <__avr32_udiv64+0x228>
8000c876:	0c 3b       	cp.w	r11,r6
8000c878:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c87c:	f7 b8 03 01 	sublo	r8,1
8000c880:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c884:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c888:	0c 1b       	sub	r11,r6
8000c88a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c88e:	06 95       	mov	r5,r3
8000c890:	16 35       	cp.w	r5,r11
8000c892:	e0 8b 00 0a 	brhi	8000c8a6 <__avr32_udiv64+0x24e>
8000c896:	5f 0b       	sreq	r11
8000c898:	f4 09 09 49 	lsl	r9,r10,r9
8000c89c:	12 32       	cp.w	r2,r9
8000c89e:	5f b9       	srhi	r9
8000c8a0:	f7 e9 00 09 	and	r9,r11,r9
8000c8a4:	c0 60       	breq	8000c8b0 <__avr32_udiv64+0x258>
8000c8a6:	20 18       	sub	r8,1
8000c8a8:	30 09       	mov	r9,0
8000c8aa:	c0 38       	rjmp	8000c8b0 <__avr32_udiv64+0x258>
8000c8ac:	30 09       	mov	r9,0
8000c8ae:	12 98       	mov	r8,r9
8000c8b0:	10 9a       	mov	r10,r8
8000c8b2:	12 93       	mov	r3,r9
8000c8b4:	10 92       	mov	r2,r8
8000c8b6:	12 9b       	mov	r11,r9
8000c8b8:	2f dd       	sub	sp,-12
8000c8ba:	d8 32       	popm	r0-r7,pc

8000c8bc <__avr32_umod64>:
8000c8bc:	d4 31       	pushm	r0-r7,lr
8000c8be:	1a 97       	mov	r7,sp
8000c8c0:	20 3d       	sub	sp,12
8000c8c2:	10 9c       	mov	r12,r8
8000c8c4:	12 95       	mov	r5,r9
8000c8c6:	14 9e       	mov	lr,r10
8000c8c8:	16 91       	mov	r1,r11
8000c8ca:	16 96       	mov	r6,r11
8000c8cc:	58 09       	cp.w	r9,0
8000c8ce:	e0 81 00 81 	brne	8000c9d0 <__avr32_umod64+0x114>
8000c8d2:	16 38       	cp.w	r8,r11
8000c8d4:	e0 88 00 12 	brls	8000c8f8 <__avr32_umod64+0x3c>
8000c8d8:	f0 08 12 00 	clz	r8,r8
8000c8dc:	c4 e0       	breq	8000c978 <__avr32_umod64+0xbc>
8000c8de:	f6 08 09 46 	lsl	r6,r11,r8
8000c8e2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c8e6:	f0 0b 11 20 	rsub	r11,r8,32
8000c8ea:	f4 08 09 4e 	lsl	lr,r10,r8
8000c8ee:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c8f2:	f7 e6 10 06 	or	r6,r11,r6
8000c8f6:	c4 18       	rjmp	8000c978 <__avr32_umod64+0xbc>
8000c8f8:	58 08       	cp.w	r8,0
8000c8fa:	c0 51       	brne	8000c904 <__avr32_umod64+0x48>
8000c8fc:	30 19       	mov	r9,1
8000c8fe:	f2 08 0d 08 	divu	r8,r9,r8
8000c902:	10 9c       	mov	r12,r8
8000c904:	f8 08 12 00 	clz	r8,r12
8000c908:	c0 31       	brne	8000c90e <__avr32_umod64+0x52>
8000c90a:	18 16       	sub	r6,r12
8000c90c:	c3 68       	rjmp	8000c978 <__avr32_umod64+0xbc>
8000c90e:	f0 03 11 20 	rsub	r3,r8,32
8000c912:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c916:	f8 08 09 4c 	lsl	r12,r12,r8
8000c91a:	ec 08 09 49 	lsl	r9,r6,r8
8000c91e:	ec 03 0a 43 	lsr	r3,r6,r3
8000c922:	f7 e9 10 09 	or	r9,r11,r9
8000c926:	f8 05 16 10 	lsr	r5,r12,0x10
8000c92a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c92e:	e6 05 0d 02 	divu	r2,r3,r5
8000c932:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c936:	ec 02 02 4b 	mul	r11,r6,r2
8000c93a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c93e:	16 3e       	cp.w	lr,r11
8000c940:	c0 72       	brcc	8000c94e <__avr32_umod64+0x92>
8000c942:	18 0e       	add	lr,r12
8000c944:	18 3e       	cp.w	lr,r12
8000c946:	c0 43       	brcs	8000c94e <__avr32_umod64+0x92>
8000c948:	16 3e       	cp.w	lr,r11
8000c94a:	fd dc e3 0e 	addcs	lr,lr,r12
8000c94e:	fc 0b 01 03 	sub	r3,lr,r11
8000c952:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c956:	e6 05 0d 02 	divu	r2,r3,r5
8000c95a:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c95e:	a5 36       	mul	r6,r2
8000c960:	0c 39       	cp.w	r9,r6
8000c962:	c0 72       	brcc	8000c970 <__avr32_umod64+0xb4>
8000c964:	18 09       	add	r9,r12
8000c966:	18 39       	cp.w	r9,r12
8000c968:	c0 43       	brcs	8000c970 <__avr32_umod64+0xb4>
8000c96a:	0c 39       	cp.w	r9,r6
8000c96c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c970:	f2 06 01 06 	sub	r6,r9,r6
8000c974:	f4 08 09 4e 	lsl	lr,r10,r8
8000c978:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c97c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c980:	ec 0a 0d 02 	divu	r2,r6,r10
8000c984:	fc 09 16 10 	lsr	r9,lr,0x10
8000c988:	ea 02 02 4b 	mul	r11,r5,r2
8000c98c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c990:	16 39       	cp.w	r9,r11
8000c992:	c0 72       	brcc	8000c9a0 <__avr32_umod64+0xe4>
8000c994:	18 09       	add	r9,r12
8000c996:	18 39       	cp.w	r9,r12
8000c998:	c0 43       	brcs	8000c9a0 <__avr32_umod64+0xe4>
8000c99a:	16 39       	cp.w	r9,r11
8000c99c:	f3 dc e3 09 	addcs	r9,r9,r12
8000c9a0:	f2 0b 01 0b 	sub	r11,r9,r11
8000c9a4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c9a8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c9ac:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c9b0:	ea 0a 02 4a 	mul	r10,r5,r10
8000c9b4:	14 3e       	cp.w	lr,r10
8000c9b6:	c0 72       	brcc	8000c9c4 <__avr32_umod64+0x108>
8000c9b8:	18 0e       	add	lr,r12
8000c9ba:	18 3e       	cp.w	lr,r12
8000c9bc:	c0 43       	brcs	8000c9c4 <__avr32_umod64+0x108>
8000c9be:	14 3e       	cp.w	lr,r10
8000c9c0:	fd dc e3 0e 	addcs	lr,lr,r12
8000c9c4:	fc 0a 01 0a 	sub	r10,lr,r10
8000c9c8:	30 0b       	mov	r11,0
8000c9ca:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c9ce:	c7 b8       	rjmp	8000cac4 <__avr32_umod64+0x208>
8000c9d0:	16 39       	cp.w	r9,r11
8000c9d2:	e0 8b 00 79 	brhi	8000cac4 <__avr32_umod64+0x208>
8000c9d6:	f2 09 12 00 	clz	r9,r9
8000c9da:	c1 21       	brne	8000c9fe <__avr32_umod64+0x142>
8000c9dc:	10 3a       	cp.w	r10,r8
8000c9de:	5f 2b       	srhs	r11
8000c9e0:	0a 31       	cp.w	r1,r5
8000c9e2:	5f ba       	srhi	r10
8000c9e4:	f7 ea 10 0a 	or	r10,r11,r10
8000c9e8:	f2 0a 18 00 	cp.b	r10,r9
8000c9ec:	c0 60       	breq	8000c9f8 <__avr32_umod64+0x13c>
8000c9ee:	fc 08 01 0c 	sub	r12,lr,r8
8000c9f2:	e2 05 01 46 	sbc	r6,r1,r5
8000c9f6:	18 9e       	mov	lr,r12
8000c9f8:	0c 9b       	mov	r11,r6
8000c9fa:	1c 9a       	mov	r10,lr
8000c9fc:	c6 48       	rjmp	8000cac4 <__avr32_umod64+0x208>
8000c9fe:	ea 09 09 4c 	lsl	r12,r5,r9
8000ca02:	f2 06 11 20 	rsub	r6,r9,32
8000ca06:	f6 09 09 4b 	lsl	r11,r11,r9
8000ca0a:	f0 09 09 42 	lsl	r2,r8,r9
8000ca0e:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca12:	f0 06 0a 48 	lsr	r8,r8,r6
8000ca16:	18 48       	or	r8,r12
8000ca18:	e2 06 0a 4c 	lsr	r12,r1,r6
8000ca1c:	f4 09 09 43 	lsl	r3,r10,r9
8000ca20:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ca24:	f4 06 0a 4a 	lsr	r10,r10,r6
8000ca28:	16 4a       	or	r10,r11
8000ca2a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ca2e:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca32:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ca36:	08 91       	mov	r1,r4
8000ca38:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000ca3c:	e8 0e 02 46 	mul	r6,r4,lr
8000ca40:	0c 3c       	cp.w	r12,r6
8000ca42:	c0 a2       	brcc	8000ca56 <__avr32_umod64+0x19a>
8000ca44:	20 11       	sub	r1,1
8000ca46:	10 0c       	add	r12,r8
8000ca48:	10 3c       	cp.w	r12,r8
8000ca4a:	c0 63       	brcs	8000ca56 <__avr32_umod64+0x19a>
8000ca4c:	0c 3c       	cp.w	r12,r6
8000ca4e:	f7 b1 03 01 	sublo	r1,1
8000ca52:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000ca56:	0c 1c       	sub	r12,r6
8000ca58:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000ca5c:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca60:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ca64:	08 96       	mov	r6,r4
8000ca66:	e8 0e 02 4e 	mul	lr,r4,lr
8000ca6a:	1c 3b       	cp.w	r11,lr
8000ca6c:	c0 a2       	brcc	8000ca80 <__avr32_umod64+0x1c4>
8000ca6e:	20 16       	sub	r6,1
8000ca70:	10 0b       	add	r11,r8
8000ca72:	10 3b       	cp.w	r11,r8
8000ca74:	c0 63       	brcs	8000ca80 <__avr32_umod64+0x1c4>
8000ca76:	1c 3b       	cp.w	r11,lr
8000ca78:	f7 b6 03 01 	sublo	r6,1
8000ca7c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ca80:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ca84:	1c 1b       	sub	r11,lr
8000ca86:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ca8a:	00 9e       	mov	lr,r0
8000ca8c:	02 9c       	mov	r12,r1
8000ca8e:	16 3c       	cp.w	r12,r11
8000ca90:	e0 8b 00 08 	brhi	8000caa0 <__avr32_umod64+0x1e4>
8000ca94:	5f 06       	sreq	r6
8000ca96:	06 30       	cp.w	r0,r3
8000ca98:	5f ba       	srhi	r10
8000ca9a:	ed ea 00 0a 	and	r10,r6,r10
8000ca9e:	c0 60       	breq	8000caaa <__avr32_umod64+0x1ee>
8000caa0:	fc 02 01 04 	sub	r4,lr,r2
8000caa4:	f8 08 01 4c 	sbc	r12,r12,r8
8000caa8:	08 9e       	mov	lr,r4
8000caaa:	e6 0e 01 0a 	sub	r10,r3,lr
8000caae:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cab2:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cab6:	f8 09 0a 4b 	lsr	r11,r12,r9
8000caba:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cabe:	f8 01 09 4c 	lsl	r12,r12,r1
8000cac2:	18 4a       	or	r10,r12
8000cac4:	2f dd       	sub	sp,-12
8000cac6:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 d0 	sub	pc,pc,28880

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c3 b3 	rcall	8000546c <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c3 ac 	rcall	8000546c <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 a5 	rcall	8000546c <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 9e 	rcall	8000546c <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
